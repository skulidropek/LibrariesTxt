internal abstract class Microsoft.CodeAnalysis.AbstractProjectExtensionProvider`2 : object {
    private AnalyzerReference _reference;
    private ImmutableDictionary`2<string, ImmutableArray`1<TExtension>> _extensionsPerLanguage;
    public AbstractProjectExtensionProvider`2(AnalyzerReference reference);
    protected abstract virtual bool SupportsLanguage(TExportAttribute exportAttribute, string language);
    protected abstract virtual bool TryGetExtensionsFromReference(AnalyzerReference reference, ImmutableArray`1& extensions);
    public ImmutableArray`1<TExtension> GetExtensions(string language);
    private ImmutableArray`1<TExtension> CreateExtensions(string language);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal abstract class Microsoft.CodeAnalysis.AddAccessibilityModifiers.AbstractAddAccessibilityModifiersCodeFixProvider : SyntaxEditorBasedCodeFixProvider {
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ImmutableArray`1<string> FixableDiagnosticIds { get; }
    internal CodeFixCategory CodeFixCategory { get; }
    protected abstract virtual SyntaxNode MapToDeclarator(SyntaxNode declaration);
    public sealed virtual ImmutableArray`1<string> get_FixableDiagnosticIds();
    internal sealed virtual CodeFixCategory get_CodeFixCategory();
    public sealed virtual Task RegisterCodeFixesAsync(CodeFixContext context);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.AddAccessibilityModifiers.AbstractAddAccessibilityModifiersCodeFixProvider/<FixAllAsync>d__6")]
protected sealed virtual Task FixAllAsync(Document document, ImmutableArray`1<Diagnostic> diagnostics, SyntaxEditor editor, CancellationToken cancellationToken);
    private static Accessibility GetPreferredAccessibility(ISymbol symbol);
}
internal abstract class Microsoft.CodeAnalysis.AddAccessibilityModifiers.AbstractAddAccessibilityModifiersDiagnosticAnalyzer`1 : AbstractBuiltInCodeStyleDiagnosticAnalyzer {
    public sealed virtual DiagnosticAnalyzerCategory GetAnalyzerCategory();
    protected sealed virtual void InitializeWorker(AnalysisContext context);
    private void AnalyzeSyntaxTree(SyntaxTreeAnalysisContext context);
    protected abstract virtual void ProcessCompilationUnit(SyntaxTreeAnalysisContext context, CodeStyleOption2`1<AccessibilityModifiersRequired> option, TCompilationUnitSyntax compilationUnitSyntax);
}
internal abstract class Microsoft.CodeAnalysis.AddAnonymousTypeMemberName.AbstractAddAnonymousTypeMemberNameCodeFixProvider`3 : SyntaxEditorBasedCodeFixProvider {
    internal CodeFixCategory CodeFixCategory { get; }
    protected abstract virtual bool HasName(TAnonymousObjectMemberDeclaratorSyntax declarator);
    protected abstract virtual TExpressionSyntax GetExpression(TAnonymousObjectMemberDeclaratorSyntax declarator);
    protected abstract virtual TAnonymousObjectMemberDeclaratorSyntax WithName(TAnonymousObjectMemberDeclaratorSyntax declarator, SyntaxToken name);
    protected abstract virtual IEnumerable`1<string> GetAnonymousObjectMemberNames(TAnonymousObjectInitializer initializer);
    internal sealed virtual CodeFixCategory get_CodeFixCategory();
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.AddAnonymousTypeMemberName.AbstractAddAnonymousTypeMemberNameCodeFixProvider`3/<RegisterCodeFixesAsync>d__7")]
public virtual Task RegisterCodeFixesAsync(CodeFixContext context);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.AddAnonymousTypeMemberName.AbstractAddAnonymousTypeMemberNameCodeFixProvider`3/<GetMemberDeclaratorAsync>d__8")]
private Task`1<TAnonymousObjectMemberDeclaratorSyntax> GetMemberDeclaratorAsync(Document document, Diagnostic diagnostic, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.AddAnonymousTypeMemberName.AbstractAddAnonymousTypeMemberNameCodeFixProvider`3/<FixAllAsync>d__9")]
protected virtual Task FixAllAsync(Document document, ImmutableArray`1<Diagnostic> diagnostics, SyntaxEditor editor, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.AddAnonymousTypeMemberName.AbstractAddAnonymousTypeMemberNameCodeFixProvider`3/<FixOneAsync>d__10")]
private Task FixOneAsync(Document document, SemanticModel semanticModel, Diagnostic diagnostic, SyntaxEditor editor, SyntaxAnnotation annotation, CancellationToken cancellationToken);
}
[ExportCodeRefactoringProviderAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
[SharedAttribute]
[ExtensionOrderAttribute]
internal class Microsoft.CodeAnalysis.AddConstructorParametersFromMembers.AddConstructorParametersFromMembersCodeRefactoringProvider : AbstractGenerateFromMembersCodeRefactoringProvider {
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.AddConstructorParametersFromMembers.AddConstructorParametersFromMembersCodeRefactoringProvider/<ComputeRefactoringsAsync>d__3")]
public virtual Task ComputeRefactoringsAsync(CodeRefactoringContext context);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.AddConstructorParametersFromMembers.AddConstructorParametersFromMembersCodeRefactoringProvider/<AddConstructorParametersFromMembersAsync>d__4")]
public static Task`1<ImmutableArray`1<CodeAction>> AddConstructorParametersFromMembersAsync(Document document, TextSpan textSpan, CancellationToken cancellationToken);
    private static ImmutableArray`1<CodeAction> CreateCodeActions(Document document, State state);
    [CompilerGeneratedAttribute]
internal static bool <CreateCodeActions>g__CanHaveRequiredParameters|5_0(ImmutableArray`1<IParameterSymbol> parameters);
    [CompilerGeneratedAttribute]
internal static CodeAction <CreateCodeActions>g__GetOptionalContructorParametersCodeAction|5_1(Document document, ConstructorCandidate constructorCandidate, INamedTypeSymbol containingType, bool useSubMenuName);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal abstract class Microsoft.CodeAnalysis.AddDebuggerDisplay.AbstractAddDebuggerDisplayCodeRefactoringProvider`2 : CodeRefactoringProvider {
    private static string DebuggerDisplayPrefix;
    private static string DebuggerDisplayMethodName;
    private static string DebuggerDisplaySuffix;
    protected bool CanNameofAccessNonPublicMembersFromAttributeArgument { get; }
    protected abstract virtual bool get_CanNameofAccessNonPublicMembersFromAttributeArgument();
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.AddDebuggerDisplay.AbstractAddDebuggerDisplayCodeRefactoringProvider`2/<ComputeRefactoringsAsync>d__5")]
public virtual Task ComputeRefactoringsAsync(CodeRefactoringContext context);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.AddDebuggerDisplay.AbstractAddDebuggerDisplayCodeRefactoringProvider`2/<GetRelevantTypeFromHeaderAsync>d__6")]
private static Task`1<Nullable`1<ValueTuple`2<TTypeDeclarationSyntax, CodeActionPriority>>> GetRelevantTypeFromHeaderAsync(CodeRefactoringContext context);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.AddDebuggerDisplay.AbstractAddDebuggerDisplayCodeRefactoringProvider`2/<GetRelevantTypeFromMethodAsync>d__7")]
private static Task`1<Nullable`1<ValueTuple`2<TTypeDeclarationSyntax, CodeActionPriority>>> GetRelevantTypeFromMethodAsync(CodeRefactoringContext context);
    private static bool IsToStringMethod(IMethodSymbol methodSymbol);
    private static bool IsDebuggerDisplayMethod(IMethodSymbol methodSymbol);
    private static bool IsClassOrStruct(ITypeSymbol typeSymbol);
    private static bool HasDebuggerDisplayAttribute(ITypeSymbol typeSymbol, Compilation compilation);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.AddDebuggerDisplay.AbstractAddDebuggerDisplayCodeRefactoringProvider`2/<ApplyAsync>d__12")]
private Task`1<Document> ApplyAsync(Document document, TTypeDeclarationSyntax type, INamedTypeSymbol debuggerAttributeTypeSymbol, CancellationToken cancellationToken);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal abstract class Microsoft.CodeAnalysis.AddFileBanner.AbstractAddFileBannerCodeRefactoringProvider : CodeRefactoringProvider {
    protected abstract virtual bool IsCommentStartCharacter(char ch);
    protected abstract virtual SyntaxTrivia CreateTrivia(SyntaxTrivia trivia, string text);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.AddFileBanner.AbstractAddFileBannerCodeRefactoringProvider/<ComputeRefactoringsAsync>d__2")]
public virtual Task ComputeRefactoringsAsync(CodeRefactoringContext context);
    private Task`1<Document> AddBannerAsync(Document document, SyntaxNode root, Document siblingDocument, ImmutableArray`1<SyntaxTrivia> banner);
    [NullableContextAttribute("0")]
private ImmutableArray`1<SyntaxTrivia> UpdateEmbeddedFileNames(Document sourceDocument, Document destinationDocument, ImmutableArray`1<SyntaxTrivia> banner);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.AddFileBanner.AbstractAddFileBannerCodeRefactoringProvider/<TryGetBannerAsync>d__5")]
private Task`1<ImmutableArray`1<SyntaxTrivia>> TryGetBannerAsync(Document document, SyntaxNode root, CancellationToken cancellationToken);
}
internal abstract class Microsoft.CodeAnalysis.AddImport.AbstractAddImportCodeFixProvider : CodeFixProvider {
    private static int MaxResults;
    private IPackageInstallerService _packageInstallerService;
    private ISymbolSearchService _symbolSearchService;
    protected AbstractAddImportCodeFixProvider(IPackageInstallerService packageInstallerService, ISymbolSearchService symbolSearchService);
    public sealed virtual FixAllProvider GetFixAllProvider();
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.AddImport.AbstractAddImportCodeFixProvider/<RegisterCodeFixesAsync>d__5")]
public sealed virtual Task RegisterCodeFixesAsync(CodeFixContext context);
    private IPackageInstallerService GetPackageInstallerService(Document document);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal abstract class Microsoft.CodeAnalysis.AddImport.AbstractAddImportFeatureService`1 : object {
    protected abstract virtual bool CanAddImport(SyntaxNode node, bool allowInHiddenRegions, CancellationToken cancellationToken);
    protected abstract virtual bool CanAddImportForMethod(string diagnosticId, ISyntaxFacts syntaxFacts, SyntaxNode node, TSimpleNameSyntax& nameNode);
    protected abstract virtual bool CanAddImportForNamespace(string diagnosticId, SyntaxNode node, TSimpleNameSyntax& nameNode);
    protected abstract virtual bool CanAddImportForDeconstruct(string diagnosticId, SyntaxNode node);
    protected abstract virtual bool CanAddImportForGetAwaiter(string diagnosticId, ISyntaxFacts syntaxFactsService, SyntaxNode node);
    protected abstract virtual bool CanAddImportForGetEnumerator(string diagnosticId, ISyntaxFacts syntaxFactsService, SyntaxNode node);
    protected abstract virtual bool CanAddImportForGetAsyncEnumerator(string diagnosticId, ISyntaxFacts syntaxFactsService, SyntaxNode node);
    protected abstract virtual bool CanAddImportForQuery(string diagnosticId, SyntaxNode node);
    protected abstract virtual bool CanAddImportForType(string diagnosticId, SyntaxNode node, TSimpleNameSyntax& nameNode);
    protected abstract virtual ISet`1<INamespaceSymbol> GetImportNamespacesInScope(SemanticModel semanticModel, SyntaxNode node, CancellationToken cancellationToken);
    protected abstract virtual ITypeSymbol GetDeconstructInfo(SemanticModel semanticModel, SyntaxNode node, CancellationToken cancellationToken);
    protected abstract virtual ITypeSymbol GetQueryClauseInfo(SemanticModel semanticModel, SyntaxNode node, CancellationToken cancellationToken);
    protected abstract virtual bool IsViableExtensionMethod(IMethodSymbol method, SyntaxNode expression, SemanticModel semanticModel, ISyntaxFacts syntaxFacts, CancellationToken cancellationToken);
    protected abstract virtual Task`1<Document> AddImportAsync(SyntaxNode contextNode, INamespaceOrTypeSymbol symbol, Document document, bool specialCaseSystem, bool allowInHiddenRegions, CancellationToken cancellationToken);
    protected abstract virtual Task`1<Document> AddImportAsync(SyntaxNode contextNode, IReadOnlyList`1<string> nameSpaceParts, Document document, bool specialCaseSystem, bool allowInHiddenRegions, CancellationToken cancellationToken);
    protected abstract virtual bool IsAddMethodContext(SyntaxNode node, SemanticModel semanticModel);
    protected abstract virtual string GetDescription(IReadOnlyList`1<string> nameParts);
    protected abstract virtual ValueTuple`2<string, bool> GetDescription(Document document, INamespaceOrTypeSymbol symbol, SemanticModel semanticModel, SyntaxNode root, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.AddImport.AbstractAddImportFeatureService`1/<GetFixesAsync>d__18")]
public sealed virtual Task`1<ImmutableArray`1<AddImportFixData>> GetFixesAsync(Document document, TextSpan span, string diagnosticId, int maxResults, bool placeSystemNamespaceFirst, bool allowInHiddenRegions, ISymbolSearchService symbolSearchService, bool searchReferenceAssemblies, ImmutableArray`1<PackageSource> packageSources, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.AddImport.AbstractAddImportFeatureService`1/<GetFixesInCurrentProcessAsync>d__19")]
private Task`1<ImmutableArray`1<AddImportFixData>> GetFixesInCurrentProcessAsync(Document document, TextSpan span, string diagnosticId, int maxResults, bool placeSystemNamespaceFirst, bool allowInHiddenRegions, ISymbolSearchService symbolSearchService, bool searchReferenceAssemblies, ImmutableArray`1<PackageSource> packageSources, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.AddImport.AbstractAddImportFeatureService`1/<FindResultsAsync>d__20")]
private Task`1<ImmutableArray`1<Reference<TSimpleNameSyntax>>> FindResultsAsync(Document document, SemanticModel semanticModel, string diagnosticId, SyntaxNode node, int maxResults, ISymbolSearchService symbolSearchService, bool searchReferenceAssemblies, ImmutableArray`1<PackageSource> packageSources, CancellationToken cancellationToken);
    private static bool IsHostOrRemoteWorkspace(Project project);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.AddImport.AbstractAddImportFeatureService`1/<FindResultsAsync>d__22")]
private Task`1<ImmutableArray`1<Reference<TSimpleNameSyntax>>> FindResultsAsync(ConcurrentDictionary`2<Project, AsyncLazy`1<IAssemblySymbol>> projectToAssembly, ConcurrentDictionary`2<PortableExecutableReference, Compilation> referenceToCompilation, Project project, int maxResults, SymbolReferenceFinder<TSimpleNameSyntax> finder, bool exact, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.AddImport.AbstractAddImportFeatureService`1/<FindResultsInAllSymbolsInStartingProjectAsync>d__23")]
private static Task FindResultsInAllSymbolsInStartingProjectAsync(ArrayBuilder`1<Reference<TSimpleNameSyntax>> allSymbolReferences, int maxResults, SymbolReferenceFinder<TSimpleNameSyntax> finder, bool exact, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.AddImport.AbstractAddImportFeatureService`1/<FindResultsInUnreferencedProjectSourceSymbolsAsync>d__24")]
private static Task FindResultsInUnreferencedProjectSourceSymbolsAsync(ConcurrentDictionary`2<Project, AsyncLazy`1<IAssemblySymbol>> projectToAssembly, Project project, ArrayBuilder`1<Reference<TSimpleNameSyntax>> allSymbolReferences, int maxResults, SymbolReferenceFinder<TSimpleNameSyntax> finder, bool exact, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.AddImport.AbstractAddImportFeatureService`1/<FindResultsInUnreferencedMetadataSymbolsAsync>d__25")]
private Task FindResultsInUnreferencedMetadataSymbolsAsync(ConcurrentDictionary`2<PortableExecutableReference, Compilation> referenceToCompilation, Project project, ArrayBuilder`1<Reference<TSimpleNameSyntax>> allSymbolReferences, int maxResults, SymbolReferenceFinder<TSimpleNameSyntax> finder, bool exact, CancellationToken cancellationToken);
    private static ImmutableArray`1<ValueTuple`2<ProjectId, PortableExecutableReference>> GetUnreferencedMetadataReferences(Project project, HashSet`1<PortableExecutableReference> seenReferences);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.AddImport.AbstractAddImportFeatureService`1/<WaitForTasksAsync>d__27")]
private static Task WaitForTasksAsync(ArrayBuilder`1<Reference<TSimpleNameSyntax>> allSymbolReferences, int maxResults, HashSet`1<Task`1<ImmutableArray`1<SymbolReference<TSimpleNameSyntax>>>> findTasks, CancellationTokenSource nestedTokenSource, CancellationToken cancellationToken);
    private static bool IsInPackagesDirectory(PortableExecutableReference reference);
    private static Compilation CreateCompilation(Project project, PortableExecutableReference reference);
    [NullableContextAttribute("2")]
private sealed virtual override bool System.Collections.Generic.IEqualityComparer<Microsoft.CodeAnalysis.PortableExecutableReference>.Equals(PortableExecutableReference x, PortableExecutableReference y);
    private sealed virtual override int System.Collections.Generic.IEqualityComparer<Microsoft.CodeAnalysis.PortableExecutableReference>.GetHashCode(PortableExecutableReference obj);
    private static HashSet`1<Project> GetViableUnreferencedProjects(Project project);
    [NullableContextAttribute("0")]
private static void AddRange(ArrayBuilder`1<Reference<TSimpleNameSyntax>> allSymbolReferences, ImmutableArray`1<TReference> proposedReferences, int maxResults);
    protected static bool IsViableExtensionMethod(IMethodSymbol method, ITypeSymbol receiver);
    private static bool NotGlobalNamespace(SymbolReference<TSimpleNameSyntax> reference);
    private static bool NotNull(SymbolReference<TSimpleNameSyntax> reference);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.AddImport.AbstractAddImportFeatureService`1/<GetFixesForDiagnosticsAsync>d__37")]
public sealed virtual Task`1<ImmutableArray`1<ValueTuple`2<Diagnostic, ImmutableArray`1<AddImportFixData>>>> GetFixesForDiagnosticsAsync(Document document, TextSpan span, ImmutableArray`1<Diagnostic> diagnostics, int maxResultsPerDiagnostic, ISymbolSearchService symbolSearchService, bool searchReferenceAssemblies, ImmutableArray`1<PackageSource> packageSources, CancellationToken cancellationToken);
    public sealed virtual ImmutableArray`1<CodeAction> GetCodeActionsForFixes(Document document, ImmutableArray`1<AddImportFixData> fixes, IPackageInstallerService installerService, int maxResults);
    private static CodeAction TryCreateCodeAction(Document document, AddImportFixData fixData, IPackageInstallerService installerService);
    private static ITypeSymbol GetAwaitInfo(SemanticModel semanticModel, ISyntaxFacts syntaxFactsService, SyntaxNode node);
    private static ITypeSymbol GetCollectionExpressionType(SemanticModel semanticModel, ISyntaxFacts syntaxFactsService, SyntaxNode node);
    protected static bool AncestorOrSelfIsAwaitExpression(ISyntaxFacts syntaxFactsService, SyntaxNode node);
    private static SyntaxNode FirstAwaitExpressionAncestor(ISyntaxFacts syntaxFactsService, SyntaxNode node);
    private static SyntaxNode FirstForeachCollectionExpressionAncestor(ISyntaxFacts syntaxFactsService, SyntaxNode node);
    [CompilerGeneratedAttribute]
internal static bool <IsInPackagesDirectory>g__ContainsPathComponent|28_0(PortableExecutableReference reference, string pathComponent);
}
[DataContractAttribute]
internal class Microsoft.CodeAnalysis.AddImport.AddImportFixData : object {
    [CompilerGeneratedAttribute]
private AddImportFixKind <Kind>k__BackingField;
    [DataMemberAttribute]
public ImmutableArray`1<TextChange> TextChanges;
    [DataMemberAttribute]
public string Title;
    [DataMemberAttribute]
public ImmutableArray`1<string> Tags;
    [DataMemberAttribute]
public CodeActionPriority Priority;
    [DataMemberAttribute]
public ProjectId ProjectReferenceToAdd;
    [DataMemberAttribute]
public ProjectId PortableExecutableReferenceProjectId;
    [DataMemberAttribute]
public string PortableExecutableReferenceFilePathToAdd;
    [DataMemberAttribute]
public string AssemblyReferenceAssemblyName;
    [DataMemberAttribute]
public string AssemblyReferenceFullyQualifiedTypeName;
    [DataMemberAttribute]
public string PackageSource;
    [DataMemberAttribute]
public string PackageName;
    [DataMemberAttribute]
public string PackageVersionOpt;
    [DataMemberAttribute]
public AddImportFixKind Kind { get; }
    public AddImportFixData(AddImportFixKind kind, ImmutableArray`1<TextChange> textChanges, string title, ImmutableArray`1<string> tags, CodeActionPriority priority, ProjectId projectReferenceToAdd, ProjectId portableExecutableReferenceProjectId, string portableExecutableReferenceFilePathToAdd, string assemblyReferenceAssemblyName, string assemblyReferenceFullyQualifiedTypeName, string packageSource, string packageName, string packageVersionOpt);
    [CompilerGeneratedAttribute]
public AddImportFixKind get_Kind();
    public static AddImportFixData CreateForProjectSymbol(ImmutableArray`1<TextChange> textChanges, string title, ImmutableArray`1<string> tags, CodeActionPriority priority, ProjectId projectReferenceToAdd);
    public static AddImportFixData CreateForMetadataSymbol(ImmutableArray`1<TextChange> textChanges, string title, ImmutableArray`1<string> tags, CodeActionPriority priority, ProjectId portableExecutableReferenceProjectId, string portableExecutableReferenceFilePathToAdd);
    public static AddImportFixData CreateForReferenceAssemblySymbol(ImmutableArray`1<TextChange> textChanges, string title, string assemblyReferenceAssemblyName, string assemblyReferenceFullyQualifiedTypeName);
    public static AddImportFixData CreateForPackageSymbol(ImmutableArray`1<TextChange> textChanges, string packageSource, string packageName, string packageVersionOpt);
}
internal enum Microsoft.CodeAnalysis.AddImport.AddImportFixKind : Enum {
    public int value__;
    public static AddImportFixKind ProjectSymbol;
    public static AddImportFixKind MetadataSymbol;
    public static AddImportFixKind PackageSymbol;
    public static AddImportFixKind ReferenceAssemblySymbol;
}
[NullableContextAttribute("1")]
internal interface Microsoft.CodeAnalysis.AddImport.IAddImportFeatureService {
    public abstract virtual Task`1<ImmutableArray`1<AddImportFixData>> GetFixesAsync(Document document, TextSpan span, string diagnosticId, int maxResults, bool placeSystemNamespaceFirst, bool allowInHiddenRegions, ISymbolSearchService symbolSearchService, bool searchReferenceAssemblies, ImmutableArray`1<PackageSource> packageSources, CancellationToken cancellationToken);
    public abstract virtual Task`1<ImmutableArray`1<ValueTuple`2<Diagnostic, ImmutableArray`1<AddImportFixData>>>> GetFixesForDiagnosticsAsync(Document document, TextSpan span, ImmutableArray`1<Diagnostic> diagnostics, int maxResultsPerDiagnostic, ISymbolSearchService symbolSearchService, bool searchReferenceAssemblies, ImmutableArray`1<PackageSource> packageSources, CancellationToken cancellationToken);
    public abstract virtual ImmutableArray`1<CodeAction> GetCodeActionsForFixes(Document document, ImmutableArray`1<AddImportFixData> fixes, IPackageInstallerService installerService, int maxResults);
}
internal interface Microsoft.CodeAnalysis.AddImport.IRemoteMissingImportDiscoveryService {
    public abstract virtual ValueTask`1<ImmutableArray`1<AddImportFixData>> GetFixesAsync(PinnedSolutionInfo solutionInfo, RemoteServiceCallbackId callbackId, DocumentId documentId, TextSpan span, string diagnosticId, int maxResults, bool placeSystemNamespaceFirst, bool allowInHiddenRegions, bool searchReferenceAssemblies, ImmutableArray`1<PackageSource> packageSources, CancellationToken cancellationToken);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExportRemoteServiceCallbackDispatcherAttribute("Microsoft.CodeAnalysis.AddImport.IRemoteMissingImportDiscoveryService")]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.AddImport.RemoteMissingImportDiscoveryServiceCallbackDispatcher : RemoteServiceCallbackDispatcher {
    private ISymbolSearchService GetService(RemoteServiceCallbackId callbackId);
    public sealed virtual ValueTask`1<ImmutableArray`1<PackageWithTypeResult>> FindPackagesWithTypeAsync(RemoteServiceCallbackId callbackId, string source, string name, int arity, CancellationToken cancellationToken);
    public sealed virtual ValueTask`1<ImmutableArray`1<PackageWithAssemblyResult>> FindPackagesWithAssemblyAsync(RemoteServiceCallbackId callbackId, string source, string name, CancellationToken cancellationToken);
    public sealed virtual ValueTask`1<ImmutableArray`1<ReferenceAssemblyWithTypeResult>> FindReferenceAssembliesWithTypeAsync(RemoteServiceCallbackId callbackId, string name, int arity, CancellationToken cancellationToken);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal abstract class Microsoft.CodeAnalysis.AddMissingImports.AbstractAddMissingImportsFeatureService : object {
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
protected ImmutableArray`1<string> FixableDiagnosticIds { get; }
    protected abstract virtual ImmutableArray`1<string> get_FixableDiagnosticIds();
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.AddMissingImports.AbstractAddMissingImportsFeatureService/<AddMissingImportsAsync>d__2")]
public sealed virtual Task`1<Document> AddMissingImportsAsync(Document document, TextSpan textSpan, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.AddMissingImports.AbstractAddMissingImportsFeatureService/<AddMissingImportsAsync>d__3")]
public sealed virtual Task`1<Document> AddMissingImportsAsync(Document document, AddMissingImportsAnalysisResult analysisResult, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.AddMissingImports.AbstractAddMissingImportsFeatureService/<AnalyzeAsync>d__4")]
public sealed virtual Task`1<AddMissingImportsAnalysisResult> AnalyzeAsync(Document document, TextSpan textSpan, CancellationToken cancellationToken);
    private static bool DoesNotAddReference(AddImportFixData fixData, ProjectId currentProjectId);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.AddMissingImports.AbstractAddMissingImportsFeatureService/<GetDiagnosticsAsync>d__6")]
private Task`1<ImmutableArray`1<Diagnostic>> GetDiagnosticsAsync(Document document, TextSpan textSpan, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.AddMissingImports.AbstractAddMissingImportsFeatureService/<GetUnambiguousFixesAsync>d__7")]
private static Task`1<ImmutableArray`1<AddImportFixData>> GetUnambiguousFixesAsync(Document document, ImmutableArray`1<Diagnostic> diagnostics, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.AddMissingImports.AbstractAddMissingImportsFeatureService/<ApplyFixesAsync>d__8")]
private static Task`1<Document> ApplyFixesAsync(Document document, ImmutableArray`1<AddImportFixData> fixes, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.AddMissingImports.AbstractAddMissingImportsFeatureService/<CleanUpNewLinesAsync>d__9")]
private static Task`1<Document> CleanUpNewLinesAsync(Document document, IEnumerable`1<TextSpan> insertSpans, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.AddMissingImports.AbstractAddMissingImportsFeatureService/<CleanUpNewLinesAsync>d__10")]
private static Task`1<Document> CleanUpNewLinesAsync(Document document, TextSpan insertSpan, ISyntaxFormattingService languageFormatter, OptionSet optionSet, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.AddMissingImports.AbstractAddMissingImportsFeatureService/<GetChangesForCodeActionAsync>d__11")]
private static Task`1<ValueTuple`2<ProjectChanges, IEnumerable`1<TextChange>>> GetChangesForCodeActionAsync(Document document, CodeAction codeAction, ProgressTracker progressTracker, IDocumentTextDifferencingService textDiffingService, CancellationToken cancellationToken);
    [NullableContextAttribute("0")]
[CompilerGeneratedAttribute]
private bool <GetDiagnosticsAsync>b__6_0(Diagnostic diagnostic);
}
internal abstract class Microsoft.CodeAnalysis.AddMissingImports.AbstractAddMissingImportsRefactoringProvider : CodeRefactoringProvider {
    private IPasteTrackingService _pasteTrackingService;
    protected string CodeActionTitle { get; }
    public AbstractAddMissingImportsRefactoringProvider(IPasteTrackingService pasteTrackingService);
    protected abstract virtual string get_CodeActionTitle();
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.AddMissingImports.AbstractAddMissingImportsRefactoringProvider/<ComputeRefactoringsAsync>d__4")]
public virtual Task ComputeRefactoringsAsync(CodeRefactoringContext context);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.AddMissingImports.AbstractAddMissingImportsRefactoringProvider/<AddMissingImportsAsync>d__5")]
private static Task`1<Solution> AddMissingImportsAsync(Document document, IAddMissingImportsFeatureService addMissingImportsService, AddMissingImportsAnalysisResult analysis, CancellationToken cancellationToken);
}
internal class Microsoft.CodeAnalysis.AddMissingImports.AddMissingImportsAnalysisResult : object {
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private ImmutableArray`1<AddImportFixData> <AddImportFixData>k__BackingField;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ImmutableArray`1<AddImportFixData> AddImportFixData { get; }
    public bool CanAddMissingImports { get; }
    public AddMissingImportsAnalysisResult(ImmutableArray`1<AddImportFixData> addImportFixData);
    [CompilerGeneratedAttribute]
public ImmutableArray`1<AddImportFixData> get_AddImportFixData();
    public bool get_CanAddMissingImports();
}
[NullableContextAttribute("1")]
internal interface Microsoft.CodeAnalysis.AddMissingImports.IAddMissingImportsFeatureService {
    public abstract virtual Task`1<Document> AddMissingImportsAsync(Document document, TextSpan textSpan, CancellationToken cancellationToken);
    public abstract virtual Task`1<AddMissingImportsAnalysisResult> AnalyzeAsync(Document document, TextSpan textSpan, CancellationToken cancellationToken);
    public abstract virtual Task`1<Document> AddMissingImportsAsync(Document document, AddMissingImportsAnalysisResult analysisResult, CancellationToken cancellationToken);
}
internal abstract class Microsoft.CodeAnalysis.AddMissingReference.AbstractAddMissingReferenceCodeFixProvider : AbstractAddPackageCodeFixProvider {
    protected bool IncludePrerelease { get; }
    protected AbstractAddMissingReferenceCodeFixProvider(IPackageInstallerService packageInstallerService, ISymbolSearchService symbolSearchService);
    protected virtual bool get_IncludePrerelease();
    public virtual FixAllProvider GetFixAllProvider();
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.AddMissingReference.AbstractAddMissingReferenceCodeFixProvider/<RegisterCodeFixesAsync>d__4")]
public virtual Task RegisterCodeFixesAsync(CodeFixContext context);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.AddMissingReference.AbstractAddMissingReferenceCodeFixProvider/<GetAddReferencesCodeActionsAsync>d__5")]
private static Task`1<ImmutableArray`1<CodeAction>> GetAddReferencesCodeActionsAsync(CodeFixContext context, ISet`1<AssemblyIdentity> uniqueIdentities);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.AddMissingReference.AbstractAddMissingReferenceCodeFixProvider/<GetUniqueIdentitiesAsync>d__6")]
private static Task`1<ISet`1<AssemblyIdentity>> GetUniqueIdentitiesAsync(CodeFixContext context);
}
internal class Microsoft.CodeAnalysis.AddMissingReference.AddMissingReferenceCodeAction : CodeAction {
    private Project _project;
    private ProjectReference _projectReferenceToAdd;
    private AssemblyIdentity _missingAssemblyIdentity;
    [CompilerGeneratedAttribute]
private string <Title>k__BackingField;
    public string Title { get; }
    public AddMissingReferenceCodeAction(Project project, string title, ProjectReference projectReferenceToAdd, AssemblyIdentity missingAssemblyIdentity);
    [CompilerGeneratedAttribute]
public virtual string get_Title();
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.AddMissingReference.AddMissingReferenceCodeAction/<CreateAsync>d__7")]
public static Task`1<CodeAction> CreateAsync(Project project, AssemblyIdentity missingAssemblyIdentity, CancellationToken cancellationToken);
    protected virtual Task`1<IEnumerable`1<CodeActionOperation>> ComputeOperationsAsync(CancellationToken cancellationToken);
}
internal abstract class Microsoft.CodeAnalysis.AddObsoleteAttribute.AbstractAddObsoleteAttributeCodeFixProvider : SyntaxEditorBasedCodeFixProvider {
    private ISyntaxFacts _syntaxFacts;
    private string _title;
    internal CodeFixCategory CodeFixCategory { get; }
    protected AbstractAddObsoleteAttributeCodeFixProvider(ISyntaxFacts syntaxFacts, string title);
    internal sealed virtual CodeFixCategory get_CodeFixCategory();
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.AddObsoleteAttribute.AbstractAddObsoleteAttributeCodeFixProvider/<RegisterCodeFixesAsync>d__5")]
public virtual Task RegisterCodeFixesAsync(CodeFixContext context);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.AddObsoleteAttribute.AbstractAddObsoleteAttributeCodeFixProvider/<GetObsoleteAttributeAsync>d__6")]
private static Task`1<INamedTypeSymbol> GetObsoleteAttributeAsync(Document document, CancellationToken cancellationToken);
    private SyntaxNode GetContainer(SyntaxNode root, SyntaxNode node);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.AddObsoleteAttribute.AbstractAddObsoleteAttributeCodeFixProvider/<FixAllAsync>d__8")]
protected virtual Task FixAllAsync(Document document, ImmutableArray`1<Diagnostic> diagnostics, SyntaxEditor editor, CancellationToken cancellationToken);
}
internal abstract class Microsoft.CodeAnalysis.AddPackage.AbstractAddPackageCodeFixProvider : CodeFixProvider {
    private IPackageInstallerService _packageInstallerService;
    private ISymbolSearchService _symbolSearchService;
    protected bool IncludePrerelease { get; }
    protected AbstractAddPackageCodeFixProvider(IPackageInstallerService packageInstallerService, ISymbolSearchService symbolSearchService);
    protected abstract virtual bool get_IncludePrerelease();
    public abstract virtual FixAllProvider GetFixAllProvider();
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.AddPackage.AbstractAddPackageCodeFixProvider/<GetAddPackagesCodeActionsAsync>d__6")]
protected Task`1<ImmutableArray`1<CodeAction>> GetAddPackagesCodeActionsAsync(CodeFixContext context, ISet`1<string> assemblyNames);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.AddPackage.AbstractAddPackageCodeFixProvider/<FindMatchingPackagesAsync>d__7")]
private static Task`1<ImmutableArray`1<PackageWithAssemblyResult>> FindMatchingPackagesAsync(PackageSource source, ISymbolSearchService searchService, ISet`1<string> assemblyNames, CancellationToken cancellationToken);
}
internal abstract class Microsoft.CodeAnalysis.AddPackage.AbstractAddSpecificPackageCodeFixProvider : AbstractAddPackageCodeFixProvider {
    protected bool IncludePrerelease { get; }
    protected AbstractAddSpecificPackageCodeFixProvider(IPackageInstallerService packageInstallerService, ISymbolSearchService symbolSearchService);
    protected virtual bool get_IncludePrerelease();
    public virtual FixAllProvider GetFixAllProvider();
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.AddPackage.AbstractAddSpecificPackageCodeFixProvider/<RegisterCodeFixesAsync>d__4")]
public virtual Task RegisterCodeFixesAsync(CodeFixContext context);
    protected abstract virtual string GetAssemblyName(string id);
}
internal class Microsoft.CodeAnalysis.AddPackage.InstallPackageDirectlyCodeAction : CodeAction {
    private CodeActionOperation _installPackageOperation;
    [CompilerGeneratedAttribute]
private string <Title>k__BackingField;
    public string Title { get; }
    public InstallPackageDirectlyCodeAction(IPackageInstallerService installerService, Document document, string source, string packageName, string versionOpt, bool includePrerelease, bool isLocal);
    [CompilerGeneratedAttribute]
public virtual string get_Title();
    protected virtual Task`1<IEnumerable`1<CodeActionOperation>> ComputeOperationsAsync(CancellationToken cancellationToken);
}
internal class Microsoft.CodeAnalysis.AddPackage.InstallPackageDirectlyCodeActionOperation : CodeActionOperation {
    private Document _document;
    private IPackageInstallerService _installerService;
    private string _source;
    private string _packageName;
    private string _versionOpt;
    private bool _includePrerelease;
    private bool _isLocal;
    private List`1<string> _projectsWithMatchingVersion;
    public string Title { get; }
    internal bool ApplyDuringTests { get; }
    public InstallPackageDirectlyCodeActionOperation(IPackageInstallerService installerService, Document document, string source, string packageName, string versionOpt, bool includePrerelease, bool isLocal);
    public virtual string get_Title();
    internal virtual bool get_ApplyDuringTests();
    internal virtual bool TryApply(Workspace workspace, IProgressTracker progressTracker, CancellationToken cancellationToken);
}
internal class Microsoft.CodeAnalysis.AddPackage.InstallPackageParentCodeAction : CodeActionWithNestedActions {
    public ImmutableArray`1<string> Tags { get; }
    public InstallPackageParentCodeAction(IPackageInstallerService installerService, string source, string packageName, bool includePrerelease, Document document);
    public virtual ImmutableArray`1<string> get_Tags();
    private static ImmutableArray`1<CodeAction> CreateNestedActions(IPackageInstallerService installerService, string source, string packageName, bool includePrerelease, Document document);
    private static CodeAction CreateCodeAction(IPackageInstallerService installerService, string source, string packageName, Document document, string versionOpt, bool includePrerelease, bool isLocal);
}
internal class Microsoft.CodeAnalysis.AddPackage.InstallWithPackageManagerCodeAction : CodeAction {
    private IPackageInstallerService _installerService;
    private string _packageName;
    public string Title { get; }
    public InstallWithPackageManagerCodeAction(IPackageInstallerService installerService, string packageName);
    public virtual string get_Title();
    protected virtual Task`1<IEnumerable`1<CodeActionOperation>> ComputeOperationsAsync(CancellationToken cancellationToken);
}
internal abstract class Microsoft.CodeAnalysis.AddParameter.AbstractAddParameterCodeFixProvider`6 : CodeFixProvider {
    private static SymbolDisplayFormat SimpleFormat;
    protected ImmutableArray`1<string> TooManyArgumentsDiagnosticIds { get; }
    protected ImmutableArray`1<string> CannotConvertDiagnosticIds { get; }
    private static AbstractAddParameterCodeFixProvider`6();
    protected abstract virtual ImmutableArray`1<string> get_TooManyArgumentsDiagnosticIds();
    protected abstract virtual ImmutableArray`1<string> get_CannotConvertDiagnosticIds();
    public virtual FixAllProvider GetFixAllProvider();
    protected virtual RegisterFixData`1<TArgumentSyntax> TryGetLanguageSpecificFixInfo(SemanticModel semanticModel, SyntaxNode node, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.AddParameter.AbstractAddParameterCodeFixProvider`6/<RegisterCodeFixesAsync>d__6")]
public virtual Task RegisterCodeFixesAsync(CodeFixContext context);
    private TArgumentSyntax TryGetRelevantArgument(SyntaxNode initialNode, SyntaxNode node, Diagnostic diagnostic);
    private static RegisterFixData`1<TArgumentSyntax> TryGetInvocationExpressionFixInfo(SemanticModel semanticModel, ISyntaxFactsService syntaxFacts, SyntaxNode node, CancellationToken cancellationToken);
    private static RegisterFixData`1<TArgumentSyntax> TryGetObjectCreationFixInfo(SemanticModel semanticModel, ISyntaxFactsService syntaxFacts, SyntaxNode node, CancellationToken cancellationToken);
    private static ImmutableArray`1<ArgumentInsertPositionData`1<TArgumentSyntax>> GetArgumentInsertPositionForMethodCandidates(TArgumentSyntax argumentOpt, SemanticModel semanticModel, ISyntaxFactsService syntaxFacts, SeparatedSyntaxList`1<TArgumentSyntax> arguments, ImmutableArray`1<IMethodSymbol> methodCandidates);
    private static int NonParamsParameterCount(IMethodSymbol method);
    private static void RegisterFixForMethodOverloads(CodeFixContext context, SeparatedSyntaxList`1<TArgumentSyntax> arguments, ImmutableArray`1<ArgumentInsertPositionData`1<TArgumentSyntax>> methodsAndArgumentsToAdd);
    private static ImmutableArray`1<CodeFixData> PrepareCreationOfCodeActions(Document document, SeparatedSyntaxList`1<TArgumentSyntax> arguments, ImmutableArray`1<ArgumentInsertPositionData`1<TArgumentSyntax>> methodsAndArgumentsToAdd);
    private static string GetCodeFixTitle(string resourceString, IMethodSymbol methodToUpdate, bool includeParameters);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.AddParameter.AbstractAddParameterCodeFixProvider`6/<FixAsync>d__15")]
private static Task`1<Solution> FixAsync(Document invocationDocument, IMethodSymbol method, TArgumentSyntax argument, SeparatedSyntaxList`1<TArgumentSyntax> argumentList, bool fixAllReferences, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.AddParameter.AbstractAddParameterCodeFixProvider`6/<GetArgumentTypeAndRefKindAsync>d__16")]
private static Task`1<ValueTuple`2<ITypeSymbol, RefKind>> GetArgumentTypeAndRefKindAsync(Document invocationDocument, TArgumentSyntax argument, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.AddParameter.AbstractAddParameterCodeFixProvider`6/<GetNameSuggestionForArgumentAsync>d__17")]
private static Task`1<ValueTuple`2<string, bool>> GetNameSuggestionForArgumentAsync(Document invocationDocument, TArgumentSyntax argument, CancellationToken cancellationToken);
    private static TArgumentSyntax DetermineFirstArgumentToAdd(SemanticModel semanticModel, ISyntaxFactsService syntaxFacts, StringComparer comparer, IMethodSymbol method, SeparatedSyntaxList`1<TArgumentSyntax> arguments);
    private static bool TypeInfoMatchesWithParamsExpansion(Compilation compilation, TypeInfo argumentTypeInfo, IParameterSymbol parameter, bool isNullLiteral, bool isDefaultLiteral);
    private static bool TypeInfoMatchesType(Compilation compilation, TypeInfo argumentTypeInfo, ITypeSymbol parameterType, bool isNullLiteral, bool isDefaultLiteral);
    [CompilerGeneratedAttribute]
internal static ImmutableArray`1<CodeAction> <RegisterFixForMethodOverloads>g__NestByOverload|12_0(<>c__DisplayClass12_0& );
    [CompilerGeneratedAttribute]
internal static ImmutableArray`1<CodeAction> <RegisterFixForMethodOverloads>g__NestByCascading|12_1(<>c__DisplayClass12_0& );
}
internal class Microsoft.CodeAnalysis.AddParameter.AddParameterService : object {
    public static AddParameterService Instance;
    private static AddParameterService();
    public sealed virtual bool HasCascadingDeclarations(IMethodSymbol method);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.AddParameter.AddParameterService/<AddParameterAsync>d__3")]
public sealed virtual Task`1<Solution> AddParameterAsync(Document invocationDocument, IMethodSymbol method, ITypeSymbol newParamaterType, RefKind refKind, string parameterName, Nullable`1<int> newParameterIndex, bool fixAllReferences, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.AddParameter.AddParameterService/<FindMethodDeclarationReferencesAsync>d__4")]
private static Task`1<ImmutableArray`1<IMethodSymbol>> FindMethodDeclarationReferencesAsync(Document invocationDocument, IMethodSymbol method, CancellationToken cancellationToken);
    private static IParameterSymbol CreateParameterSymbol(IMethodSymbol method, ITypeSymbol parameterType, RefKind refKind, bool isOptional, string argumentNameSuggestion);
    private static void AddParameter(ISyntaxFactsService syntaxFacts, SyntaxEditor editor, SyntaxNode declaration, int insertionIndex, SyntaxNode parameterDeclaration, CancellationToken cancellationToken);
    private static ImmutableArray`1<SyntaxTrivia> GetDesiredLeadingIndentation(SyntaxGenerator generator, ISyntaxFactsService syntaxFacts, SyntaxNode node, bool includeLeadingNewLine);
    private static bool ShouldPlaceParametersOnNewLine(IReadOnlyList`1<SyntaxNode> parameters, CancellationToken cancellationToken);
}
[IsReadOnlyAttribute]
internal class Microsoft.CodeAnalysis.AddParameter.ArgumentInsertPositionData`1 : ValueType {
    [CompilerGeneratedAttribute]
private IMethodSymbol <MethodToUpdate>k__BackingField;
    [CompilerGeneratedAttribute]
private TArgumentSyntax <ArgumentToInsert>k__BackingField;
    [CompilerGeneratedAttribute]
private int <ArgumentInsertionIndex>k__BackingField;
    public IMethodSymbol MethodToUpdate { get; }
    public TArgumentSyntax ArgumentToInsert { get; }
    public int ArgumentInsertionIndex { get; }
    public ArgumentInsertPositionData`1(IMethodSymbol methodToUpdate, TArgumentSyntax argumentToInsert, int argumentInsertionIndex);
    [CompilerGeneratedAttribute]
public IMethodSymbol get_MethodToUpdate();
    [CompilerGeneratedAttribute]
public TArgumentSyntax get_ArgumentToInsert();
    [CompilerGeneratedAttribute]
public int get_ArgumentInsertionIndex();
}
[IsReadOnlyAttribute]
internal class Microsoft.CodeAnalysis.AddParameter.CodeFixData : ValueType {
    [CompilerGeneratedAttribute]
private IMethodSymbol <Method>k__BackingField;
    [CompilerGeneratedAttribute]
private Func`2<CancellationToken, Task`1<Solution>> <CreateChangedSolutionNonCascading>k__BackingField;
    [CompilerGeneratedAttribute]
private Func`2<CancellationToken, Task`1<Solution>> <CreateChangedSolutionCascading>k__BackingField;
    public IMethodSymbol Method { get; }
    public Func`2<CancellationToken, Task`1<Solution>> CreateChangedSolutionNonCascading { get; }
    public Func`2<CancellationToken, Task`1<Solution>> CreateChangedSolutionCascading { get; }
    public CodeFixData(IMethodSymbol method, Func`2<CancellationToken, Task`1<Solution>> createChangedSolutionNonCascading, Func`2<CancellationToken, Task`1<Solution>> createChangedSolutionCascading);
    [CompilerGeneratedAttribute]
public IMethodSymbol get_Method();
    [CompilerGeneratedAttribute]
public Func`2<CancellationToken, Task`1<Solution>> get_CreateChangedSolutionNonCascading();
    [CompilerGeneratedAttribute]
public Func`2<CancellationToken, Task`1<Solution>> get_CreateChangedSolutionCascading();
}
internal interface Microsoft.CodeAnalysis.AddParameter.IAddParameterService {
    public abstract virtual bool HasCascadingDeclarations(IMethodSymbol method);
    public abstract virtual Task`1<Solution> AddParameterAsync(Document invocationDocument, IMethodSymbol method, ITypeSymbol newParamaterType, RefKind refKind, string parameterName, Nullable`1<int> newParameterIndex, bool fixAllReferences, CancellationToken cancellationToken);
}
internal class Microsoft.CodeAnalysis.AddParameter.RegisterFixData`1 : object {
    [CompilerGeneratedAttribute]
private SeparatedSyntaxList`1<TArgumentSyntax> <Arguments>k__BackingField;
    [CompilerGeneratedAttribute]
private ImmutableArray`1<IMethodSymbol> <MethodCandidates>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsConstructorInitializer>k__BackingField;
    public SeparatedSyntaxList`1<TArgumentSyntax> Arguments { get; }
    public ImmutableArray`1<IMethodSymbol> MethodCandidates { get; }
    public bool IsConstructorInitializer { get; }
    public RegisterFixData`1(SeparatedSyntaxList`1<TArgumentSyntax> arguments, ImmutableArray`1<IMethodSymbol> methodCandidates, bool isConstructorInitializer);
    [CompilerGeneratedAttribute]
public SeparatedSyntaxList`1<TArgumentSyntax> get_Arguments();
    [CompilerGeneratedAttribute]
public ImmutableArray`1<IMethodSymbol> get_MethodCandidates();
    [CompilerGeneratedAttribute]
public bool get_IsConstructorInitializer();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal abstract class Microsoft.CodeAnalysis.AddRequiredParentheses.AbstractAddRequiredParenthesesDiagnosticAnalyzer`3 : AbstractParenthesesDiagnosticAnalyzer {
    [TupleElementNamesAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private static Dictionary`2<ValueTuple`2<bool, string>, ImmutableDictionary`2<string, string>> s_cachedProperties;
    private IPrecedenceService _precedenceService;
    private static AbstractAddRequiredParenthesesDiagnosticAnalyzer`3();
    protected AbstractAddRequiredParenthesesDiagnosticAnalyzer`3(IPrecedenceService precedenceService);
    private static string GetEquivalenceKey(PerLanguageOption2`1<CodeStyleOption2`1<ParenthesesPreference>> parentPrecedence);
    private static ImmutableDictionary`2<string, string> GetProperties(bool includeInFixAll, string equivalenceKey);
    protected abstract virtual int GetPrecedence(TBinaryLikeExpressionSyntax binaryLike);
    protected abstract virtual TExpressionSyntax TryGetAppropriateParent(TBinaryLikeExpressionSyntax binaryLike);
    protected abstract virtual bool IsBinaryLike(TExpressionSyntax node);
    protected abstract virtual ValueTuple`3<TExpressionSyntax, SyntaxToken, TExpressionSyntax> GetPartsOfBinaryLike(TBinaryLikeExpressionSyntax binaryLike);
    public sealed virtual DiagnosticAnalyzerCategory GetAnalyzerCategory();
    protected sealed virtual void InitializeWorker(AnalysisContext context);
    [NullableContextAttribute("0")]
protected abstract virtual ImmutableArray`1<TLanguageKindEnum> GetSyntaxNodeKinds();
    private void AnalyzeSyntax(SyntaxNodeAnalysisContext context);
    private void AddDiagnostics(SyntaxNodeAnalysisContext context, TBinaryLikeExpressionSyntax binaryLikeOpt, int precedence, ReportDiagnostic severity, ImmutableArray`1<Location> additionalLocations, string equivalenceKey, bool includeInFixAll);
}
[ExportCodeFixProviderAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.AddRequiredParentheses.AddRequiredParenthesesCodeFixProvider : SyntaxEditorBasedCodeFixProvider {
    public ImmutableArray`1<string> FixableDiagnosticIds { get; }
    internal CodeFixCategory CodeFixCategory { get; }
    public virtual ImmutableArray`1<string> get_FixableDiagnosticIds();
    internal sealed virtual CodeFixCategory get_CodeFixCategory();
    protected virtual bool IncludeDiagnosticDuringFixAll(Diagnostic diagnostic, Document document, string equivalenceKey, CancellationToken cancellationToken);
    public virtual Task RegisterCodeFixesAsync(CodeFixContext context);
    protected virtual Task FixAllAsync(Document document, ImmutableArray`1<Diagnostic> diagnostics, SyntaxEditor editor, CancellationToken cancellationToken);
}
internal static class Microsoft.CodeAnalysis.AddRequiredParentheses.AddRequiredParenthesesConstants : object {
    public static string EquivalenceKey;
    public static string IncludeInFixAll;
}
internal abstract class Microsoft.CodeAnalysis.AliasAmbiguousType.AbstractAliasAmbiguousTypeCodeFixProvider : CodeFixProvider {
    protected abstract virtual string GetTextPreviewOfChange(string aliasName, ITypeSymbol typeSymbol);
    public virtual FixAllProvider GetFixAllProvider();
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.AliasAmbiguousType.AbstractAliasAmbiguousTypeCodeFixProvider/<RegisterCodeFixesAsync>d__2")]
public sealed virtual Task RegisterCodeFixesAsync(CodeFixContext context);
    private static bool SymbolCandidatesContainsSupportedSymbols(SymbolInfo symbolInfo);
}
internal static class Microsoft.CodeAnalysis.AnalyzersResources : object {
    private static ResourceManager s_resourceManager;
    [CompilerGeneratedAttribute]
private static CultureInfo <Culture>k__BackingField;
    internal static ResourceManager ResourceManager { get; }
    internal static CultureInfo Culture { get; internal set; }
    internal static string Remove_Unnecessary_Cast { get; }
    internal static string Remove_unused_member { get; }
    internal static string Private_member_0_is_unused { get; }
    internal static string Remove_unused_private_members { get; }
    internal static string Remove_unread_private_members { get; }
    internal static string Private_member_0_can_be_removed_as_the_value_assigned_to_it_is_never_read { get; }
    internal static string Private_method_0_can_be_removed_as_it_is_never_invoked { get; }
    internal static string Private_property_0_can_be_converted_to_a_method_as_its_get_accessor_is_never_invoked { get; }
    internal static string A_source_file_is_missing_a_required_header { get; }
    internal static string The_file_header_is_missing_or_not_located_at_the_top_of_the_file { get; }
    internal static string A_source_file_contains_a_header_that_does_not_match_the_required_text { get; }
    internal static string The_file_header_does_not_match_the_required_text { get; }
    internal static string Use_throw_expression { get; }
    internal static string Add_this_or_Me_qualification { get; }
    internal static string Member_access_should_be_qualified { get; }
    internal static string Null_check_can_be_simplified { get; }
    internal static string Simplify_collection_initialization { get; }
    internal static string Collection_initialization_can_be_simplified { get; }
    internal static string Simplify_object_initialization { get; }
    internal static string Object_initialization_can_be_simplified { get; }
    internal static string Add_readonly_modifier { get; }
    internal static string Make_field_readonly { get; }
    internal static string Naming_rule_violation_0 { get; }
    internal static string Naming_Styles { get; }
    internal static string Add_missing_cases { get; }
    internal static string Populate_switch { get; }
    internal static string Modifiers_are_not_ordered { get; }
    internal static string Order_modifiers { get; }
    internal static string Expression_value_is_never_used { get; }
    internal static string Unnecessary_assignment_of_a_value_to_0 { get; }
    internal static string Unnecessary_assignment_of_a_value { get; }
    internal static string Avoid_unnecessary_value_assignments_in_your_code_as_these_likely_indicate_redundant_value_computations_If_the_value_computation_is_not_redundant_and_you_intend_to_retain_the_assignmentcomma_then_change_the_assignment_target_to_a_local_variable_whose_name_starts_with_an_underscore_and_is_optionally_followed_by_an_integercomma_such_as___comma__1_comma__2_comma_etc { get; }
    internal static string Remove_unused_parameter { get; }
    internal static string Remove_unused_parameter_0 { get; }
    internal static string Avoid_unused_parameters_in_your_code_If_the_parameter_cannot_be_removed_then_change_its_name_so_it_starts_with_an_underscore_and_is_optionally_followed_by_an_integer_such_as__comma__1_comma__2_etc_These_are_treated_as_special_discard_symbol_names { get; }
    internal static string Remove_unused_parameter_0_if_it_is_not_part_of_a_shipped_public_API { get; }
    internal static string Parameter_0_can_be_removed_if_it_is_not_part_of_a_shipped_public_API_its_initial_value_is_never_used { get; }
    internal static string Parameter_0_can_be_removed_its_initial_value_is_never_used { get; }
    internal static string Add_accessibility_modifiers { get; }
    internal static string Accessibility_modifiers_required { get; }
    internal static string Convert_to_conditional_expression { get; }
    internal static string Use_coalesce_expression { get; }
    internal static string Changes_to_expression_trees_may_result_in_behavior_changes_at_runtime { get; }
    internal static string Parentheses_can_be_removed { get; }
    internal static string Remove_unnecessary_parentheses { get; }
    internal static string Add_parentheses_for_clarity { get; }
    internal static string Parentheses_should_be_added_for_clarity { get; }
    internal static string Prefer_explicitly_provided_tuple_element_name { get; }
    internal static string Use_explicitly_provided_tuple_name { get; }
    internal static string Use_System_HashCode { get; }
    internal static string GetHashCode_implementation_can_be_simplified { get; }
    internal static string Use_compound_assignment { get; }
    internal static string Use_null_propagation { get; }
    internal static string Use_inferred_member_name { get; }
    internal static string Member_name_can_be_simplified { get; }
    internal static string Interpolation_can_be_simplified { get; }
    internal static string Simplify_interpolation { get; }
    internal static string Use_auto_property { get; }
    internal static string Format_string_contains_invalid_placeholder { get; }
    internal static string Invalid_format_string { get; }
    internal static string Convert_to_tuple { get; }
    internal static string Simplify_conditional_expression { get; }
    internal static string Conditional_expression_can_be_simplified { get; }
    internal static string Invalid_global_SuppressMessageAttribute { get; }
    internal static string Invalid_scope_for_SuppressMessageAttribute { get; }
    internal static string Invalid_or_missing_target_for_SuppressMessageAttribute { get; }
    internal static string Avoid_legacy_format_target_in_SuppressMessageAttribute { get; }
    internal static string Avoid_legacy_format_target_0_in_SuppressMessageAttribute { get; }
    internal static string Remove_unnecessary_suppression { get; }
    internal static string Remove_redundant_equality { get; }
    internal static string Use_decrement_operator { get; }
    internal static string Use_increment_operator { get; }
    internal static ResourceManager get_ResourceManager();
    [CompilerGeneratedAttribute]
internal static CultureInfo get_Culture();
    [CompilerGeneratedAttribute]
internal static void set_Culture(CultureInfo value);
    internal static string GetResourceString(string resourceKey, string defaultValue);
    internal static string get_Remove_Unnecessary_Cast();
    internal static string get_Remove_unused_member();
    internal static string get_Private_member_0_is_unused();
    internal static string get_Remove_unused_private_members();
    internal static string get_Remove_unread_private_members();
    internal static string get_Private_member_0_can_be_removed_as_the_value_assigned_to_it_is_never_read();
    internal static string get_Private_method_0_can_be_removed_as_it_is_never_invoked();
    internal static string get_Private_property_0_can_be_converted_to_a_method_as_its_get_accessor_is_never_invoked();
    internal static string get_A_source_file_is_missing_a_required_header();
    internal static string get_The_file_header_is_missing_or_not_located_at_the_top_of_the_file();
    internal static string get_A_source_file_contains_a_header_that_does_not_match_the_required_text();
    internal static string get_The_file_header_does_not_match_the_required_text();
    internal static string get_Use_throw_expression();
    internal static string get_Add_this_or_Me_qualification();
    internal static string get_Member_access_should_be_qualified();
    internal static string get_Null_check_can_be_simplified();
    internal static string get_Simplify_collection_initialization();
    internal static string get_Collection_initialization_can_be_simplified();
    internal static string get_Simplify_object_initialization();
    internal static string get_Object_initialization_can_be_simplified();
    internal static string get_Add_readonly_modifier();
    internal static string get_Make_field_readonly();
    internal static string get_Naming_rule_violation_0();
    internal static string get_Naming_Styles();
    internal static string get_Add_missing_cases();
    internal static string get_Populate_switch();
    internal static string get_Modifiers_are_not_ordered();
    internal static string get_Order_modifiers();
    internal static string get_Expression_value_is_never_used();
    internal static string get_Unnecessary_assignment_of_a_value_to_0();
    internal static string get_Unnecessary_assignment_of_a_value();
    internal static string get_Avoid_unnecessary_value_assignments_in_your_code_as_these_likely_indicate_redundant_value_computations_If_the_value_computation_is_not_redundant_and_you_intend_to_retain_the_assignmentcomma_then_change_the_assignment_target_to_a_local_variable_whose_name_starts_with_an_underscore_and_is_optionally_followed_by_an_integercomma_such_as___comma__1_comma__2_comma_etc();
    internal static string get_Remove_unused_parameter();
    internal static string get_Remove_unused_parameter_0();
    internal static string get_Avoid_unused_parameters_in_your_code_If_the_parameter_cannot_be_removed_then_change_its_name_so_it_starts_with_an_underscore_and_is_optionally_followed_by_an_integer_such_as__comma__1_comma__2_etc_These_are_treated_as_special_discard_symbol_names();
    internal static string get_Remove_unused_parameter_0_if_it_is_not_part_of_a_shipped_public_API();
    internal static string get_Parameter_0_can_be_removed_if_it_is_not_part_of_a_shipped_public_API_its_initial_value_is_never_used();
    internal static string get_Parameter_0_can_be_removed_its_initial_value_is_never_used();
    internal static string get_Add_accessibility_modifiers();
    internal static string get_Accessibility_modifiers_required();
    internal static string get_Convert_to_conditional_expression();
    internal static string get_Use_coalesce_expression();
    internal static string get_Changes_to_expression_trees_may_result_in_behavior_changes_at_runtime();
    internal static string get_Parentheses_can_be_removed();
    internal static string get_Remove_unnecessary_parentheses();
    internal static string get_Add_parentheses_for_clarity();
    internal static string get_Parentheses_should_be_added_for_clarity();
    internal static string get_Prefer_explicitly_provided_tuple_element_name();
    internal static string get_Use_explicitly_provided_tuple_name();
    internal static string get_Use_System_HashCode();
    internal static string get_GetHashCode_implementation_can_be_simplified();
    internal static string get_Use_compound_assignment();
    internal static string get_Use_null_propagation();
    internal static string get_Use_inferred_member_name();
    internal static string get_Member_name_can_be_simplified();
    internal static string get_Interpolation_can_be_simplified();
    internal static string get_Simplify_interpolation();
    internal static string get_Use_auto_property();
    internal static string get_Format_string_contains_invalid_placeholder();
    internal static string get_Invalid_format_string();
    internal static string get_Convert_to_tuple();
    internal static string get_Simplify_conditional_expression();
    internal static string get_Conditional_expression_can_be_simplified();
    internal static string get_Invalid_global_SuppressMessageAttribute();
    internal static string get_Invalid_scope_for_SuppressMessageAttribute();
    internal static string get_Invalid_or_missing_target_for_SuppressMessageAttribute();
    internal static string get_Avoid_legacy_format_target_in_SuppressMessageAttribute();
    internal static string get_Avoid_legacy_format_target_0_in_SuppressMessageAttribute();
    internal static string get_Remove_unnecessary_suppression();
    internal static string get_Remove_redundant_equality();
    internal static string get_Use_decrement_operator();
    internal static string get_Use_increment_operator();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal abstract class Microsoft.CodeAnalysis.BraceCompletion.AbstractBraceCompletionService : object {
    protected char OpeningBrace { get; }
    protected char ClosingBrace { get; }
    protected abstract virtual char get_OpeningBrace();
    protected abstract virtual char get_ClosingBrace();
    protected abstract virtual bool IsValidOpeningBraceToken(SyntaxToken token);
    protected abstract virtual bool IsValidClosingBraceToken(SyntaxToken token);
    public abstract virtual Task`1<bool> AllowOverTypeAsync(BraceCompletionContext braceCompletionContext, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.BraceCompletion.AbstractBraceCompletionService/<GetBraceCompletionAsync>d__7")]
public sealed virtual Task`1<Nullable`1<BraceCompletionResult>> GetBraceCompletionAsync(BraceCompletionContext braceCompletionContext, CancellationToken cancellationToken);
    public virtual Task`1<Nullable`1<BraceCompletionResult>> GetTextChangesAfterCompletionAsync(BraceCompletionContext braceCompletionContext, CancellationToken cancellationToken);
    public virtual Task`1<Nullable`1<BraceCompletionResult>> GetTextChangeAfterReturnAsync(BraceCompletionContext braceCompletionContext, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.BraceCompletion.AbstractBraceCompletionService/<CanProvideBraceCompletionAsync>d__10")]
public virtual Task`1<bool> CanProvideBraceCompletionAsync(char brace, int openingPosition, Document document, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.BraceCompletion.AbstractBraceCompletionService/<GetCompletedBraceContextAsync>d__11")]
public sealed virtual Task`1<Nullable`1<BraceCompletionContext>> GetCompletedBraceContextAsync(Document document, int caretLocation, CancellationToken cancellationToken);
    protected virtual Task`1<bool> IsValidOpenBraceTokenAtPositionAsync(SyntaxToken token, int position, Document document, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.BraceCompletion.AbstractBraceCompletionService/<AllowOverTypeInUserCodeWithValidClosingTokenAsync>d__13")]
protected Task`1<bool> AllowOverTypeInUserCodeWithValidClosingTokenAsync(BraceCompletionContext context, CancellationToken cancellationToken);
    protected Task`1<bool> AllowOverTypeWithValidClosingTokenAsync(BraceCompletionContext context, CancellationToken cancellationToken);
    protected static bool ParentIsSkippedTokensTriviaOrNull(ISyntaxFactsService syntaxFactsService, SyntaxToken token);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.BraceCompletion.AbstractBraceCompletionService/<CheckClosingTokenKindAsync>d__16")]
private Task`1<bool> CheckClosingTokenKindAsync(Document document, int closingPosition, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.BraceCompletion.AbstractBraceCompletionService/<CouldEscapePreviousOpenBraceAsync>d__23")]
protected static Task`1<bool> CouldEscapePreviousOpenBraceAsync(char openingBrace, int position, Document document, CancellationToken cancellationToken);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[IsReadOnlyAttribute]
internal class Microsoft.CodeAnalysis.BraceCompletion.BraceCompletionContext : ValueType {
    [CompilerGeneratedAttribute]
private Document <Document>k__BackingField;
    [CompilerGeneratedAttribute]
private int <OpeningPoint>k__BackingField;
    [CompilerGeneratedAttribute]
private int <ClosingPoint>k__BackingField;
    [CompilerGeneratedAttribute]
private int <CaretLocation>k__BackingField;
    public Document Document { get; }
    public int OpeningPoint { get; }
    public int ClosingPoint { get; }
    public int CaretLocation { get; }
    public BraceCompletionContext(Document document, int openingPoint, int closingPoint, int caretLocation);
    [CompilerGeneratedAttribute]
public Document get_Document();
    [CompilerGeneratedAttribute]
public int get_OpeningPoint();
    [CompilerGeneratedAttribute]
public int get_ClosingPoint();
    [CompilerGeneratedAttribute]
public int get_CaretLocation();
}
internal class Microsoft.CodeAnalysis.BraceCompletion.BraceCompletionOptions : object {
    [NullableAttribute("1")]
public static PerLanguageOption2`1<bool> AutoFormattingOnCloseBrace;
    private static BraceCompletionOptions();
}
[IsReadOnlyAttribute]
internal class Microsoft.CodeAnalysis.BraceCompletion.BraceCompletionResult : ValueType {
    [CompilerGeneratedAttribute]
private ImmutableArray`1<TextChange> <TextChanges>k__BackingField;
    [CompilerGeneratedAttribute]
private LinePosition <CaretLocation>k__BackingField;
    public ImmutableArray`1<TextChange> TextChanges { get; }
    public LinePosition CaretLocation { get; }
    public BraceCompletionResult(ImmutableArray`1<TextChange> textChanges, LinePosition caretLocation);
    [CompilerGeneratedAttribute]
public ImmutableArray`1<TextChange> get_TextChanges();
    [CompilerGeneratedAttribute]
public LinePosition get_CaretLocation();
}
[NullableContextAttribute("1")]
internal interface Microsoft.CodeAnalysis.BraceCompletion.IBraceCompletionService {
    public abstract virtual Task`1<bool> CanProvideBraceCompletionAsync(char brace, int openingPosition, Document document, CancellationToken cancellationToken);
    public abstract virtual Task`1<Nullable`1<BraceCompletionResult>> GetBraceCompletionAsync(BraceCompletionContext braceCompletionContext, CancellationToken cancellationToken);
    public abstract virtual Task`1<Nullable`1<BraceCompletionResult>> GetTextChangesAfterCompletionAsync(BraceCompletionContext braceCompletionContext, CancellationToken cancellationToken);
    public abstract virtual Task`1<Nullable`1<BraceCompletionResult>> GetTextChangeAfterReturnAsync(BraceCompletionContext braceCompletionContext, CancellationToken cancellationToken);
    public abstract virtual Task`1<Nullable`1<BraceCompletionContext>> GetCompletedBraceContextAsync(Document document, int caretLocation, CancellationToken cancellationToken);
    public abstract virtual Task`1<bool> AllowOverTypeAsync(BraceCompletionContext braceCompletionContext, CancellationToken cancellationToken);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal abstract class Microsoft.CodeAnalysis.ChangeNamespace.AbstractChangeNamespaceService : object {
    public abstract virtual Task`1<bool> CanChangeNamespaceAsync(Document document, SyntaxNode container, CancellationToken cancellationToken);
    public abstract virtual Task`1<Solution> ChangeNamespaceAsync(Document document, SyntaxNode container, string targetNamespace, CancellationToken cancellationToken);
    public abstract virtual Task`1<Solution> TryChangeTopLevelNamespacesAsync(Document document, string targetNamespace, CancellationToken cancellationToken);
    public abstract virtual bool TryGetReplacementReferenceSyntax(SyntaxNode reference, ImmutableArray`1<string> newNamespaceParts, ISyntaxFactsService syntaxFacts, SyntaxNode& old, SyntaxNode& new);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal abstract class Microsoft.CodeAnalysis.ChangeNamespace.AbstractChangeNamespaceService`3 : AbstractChangeNamespaceService {
    private static Char[] s_dotSeparator;
    [CompilerGeneratedAttribute]
private static SyntaxAnnotation <ContainerAnnotation>k__BackingField;
    [CompilerGeneratedAttribute]
private static SyntaxAnnotation <WarningAnnotation>k__BackingField;
    protected static SyntaxAnnotation ContainerAnnotation { get; }
    protected static SyntaxAnnotation WarningAnnotation { get; }
    private static AbstractChangeNamespaceService`3();
    [CompilerGeneratedAttribute]
protected static SyntaxAnnotation get_ContainerAnnotation();
    [CompilerGeneratedAttribute]
protected static SyntaxAnnotation get_WarningAnnotation();
    protected abstract virtual TCompilationUnitSyntax ChangeNamespaceDeclaration(TCompilationUnitSyntax root, ImmutableArray`1<string> declaredNamespaceParts, ImmutableArray`1<string> targetNamespaceParts);
    protected abstract virtual SyntaxList`1<TMemberDeclarationSyntax> GetMemberDeclarationsInContainer(SyntaxNode compilationUnitOrNamespaceDecl);
    protected abstract virtual Task`1<SyntaxNode> TryGetApplicableContainerFromSpanAsync(Document document, TextSpan span, CancellationToken cancellationToken);
    protected abstract virtual string GetDeclaredNamespace(SyntaxNode container);
    protected abstract virtual Task`1<ImmutableArray`1<ValueTuple`2<DocumentId, SyntaxNode>>> GetValidContainersFromAllLinkedDocumentsAsync(Document document, SyntaxNode container, CancellationToken cancellationToken);
    private static bool IsValidContainer(SyntaxNode container);
    protected static bool IsGlobalNamespace(ImmutableArray`1<string> parts);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.ChangeNamespace.AbstractChangeNamespaceService`3/<CanChangeNamespaceAsync>d__14")]
public virtual Task`1<bool> CanChangeNamespaceAsync(Document document, SyntaxNode container, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.ChangeNamespace.AbstractChangeNamespaceService`3/<TryChangeTopLevelNamespacesAsync>d__15")]
public virtual Task`1<Solution> TryChangeTopLevelNamespacesAsync(Document document, string targetNamespace, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.ChangeNamespace.AbstractChangeNamespaceService`3/<ChangeNamespaceAsync>d__16")]
public virtual Task`1<Solution> ChangeNamespaceAsync(Document document, SyntaxNode container, string targetNamespace, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.ChangeNamespace.AbstractChangeNamespaceService`3/<TryGetApplicableContainersFromAllDocumentsAsync>d__17")]
protected Task`1<ImmutableArray`1<ValueTuple`2<DocumentId, SyntaxNode>>> TryGetApplicableContainersFromAllDocumentsAsync(Solution solution, ImmutableArray`1<DocumentId> ids, TextSpan span, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.ChangeNamespace.AbstractChangeNamespaceService`3/<AnnotateContainersAsync>d__18")]
protected static Task`1<Solution> AnnotateContainersAsync(Solution solution, ImmutableArray`1<ValueTuple`2<DocumentId, SyntaxNode>> containers, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.ChangeNamespace.AbstractChangeNamespaceService`3/<ContainsPartialTypeWithMultipleDeclarationsAsync>d__19")]
protected Task`1<bool> ContainsPartialTypeWithMultipleDeclarationsAsync(Document document, SyntaxNode container, CancellationToken cancellationToken);
    protected static bool IsSupportedLinkedDocument(Document document, ImmutableArray`1& allDocumentIds);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.ChangeNamespace.AbstractChangeNamespaceService`3/<GetDeclaredSymbolsInContainerAsync>d__21")]
private Task`1<ImmutableArray`1<ISymbol>> GetDeclaredSymbolsInContainerAsync(Document document, SyntaxNode container, CancellationToken cancellationToken);
    private static ImmutableArray`1<string> GetNamespaceParts(string namespace);
    private static ImmutableArray`1<string> GetAllNamespaceImportsForDeclaringDocument(string oldNamespace, string newNamespace);
    private static ImmutableArray`1<SyntaxNode> CreateImports(Document document, ImmutableArray`1<string> names, bool withFormatterAnnotation);
    private static SyntaxNode CreateImport(SyntaxGenerator syntaxGenerator, string name, bool withFormatterAnnotation);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.ChangeNamespace.AbstractChangeNamespaceService`3/<ChangeNamespaceInSingleDocumentAsync>d__26")]
private Task`1<ValueTuple`2<Solution, ImmutableArray`1<DocumentId>>> ChangeNamespaceInSingleDocumentAsync(Solution solution, DocumentId id, string oldNamespace, string newNamespace, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.ChangeNamespace.AbstractChangeNamespaceService`3/<MergeDocumentChangesAsync>d__27")]
private static Task`1<Solution> MergeDocumentChangesAsync(Solution originalSolution, Document[] changedDocuments, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.ChangeNamespace.AbstractChangeNamespaceService`3/<FindReferenceLocationsForSymbolAsync>d__29")]
private static Task`1<ImmutableArray`1<LocationForAffectedSymbol<TNamespaceDeclarationSyntax, TCompilationUnitSyntax, TMemberDeclarationSyntax>>> FindReferenceLocationsForSymbolAsync(Document document, ISymbol symbol, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.ChangeNamespace.AbstractChangeNamespaceService`3/<FindReferencesAsync>d__30")]
private static Task`1<ImmutableArray`1<ReferencedSymbol>> FindReferencesAsync(ISymbol symbol, Document document, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.ChangeNamespace.AbstractChangeNamespaceService`3/<FixDeclarationDocumentAsync>d__31")]
private Task`1<Document> FixDeclarationDocumentAsync(Document document, IReadOnlyList`1<LocationForAffectedSymbol<TNamespaceDeclarationSyntax, TCompilationUnitSyntax, TMemberDeclarationSyntax>> refLocations, string oldNamespace, string newNamespace, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.ChangeNamespace.AbstractChangeNamespaceService`3/<FixReferencingDocumentAsync>d__32")]
private static Task`1<Document> FixReferencingDocumentAsync(Document document, IEnumerable`1<LocationForAffectedSymbol<TNamespaceDeclarationSyntax, TCompilationUnitSyntax, TMemberDeclarationSyntax>> refLocations, string newNamespace, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.ChangeNamespace.AbstractChangeNamespaceService`3/<FixReferencesAsync>d__33")]
private static Task`1<ValueTuple`2<Document, ImmutableArray`1<SyntaxNode>>> FixReferencesAsync(Document document, IChangeNamespaceService changeNamespaceService, IAddImportsService addImportService, IEnumerable`1<LocationForAffectedSymbol<TNamespaceDeclarationSyntax, TCompilationUnitSyntax, TMemberDeclarationSyntax>> refLocations, ImmutableArray`1<string> newNamespaceParts, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.ChangeNamespace.AbstractChangeNamespaceService`3/<RemoveUnnecessaryImportsAsync>d__34")]
private static Task`1<Solution> RemoveUnnecessaryImportsAsync(Solution solution, ImmutableArray`1<DocumentId> ids, ImmutableArray`1<string> names, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.ChangeNamespace.AbstractChangeNamespaceService`3/<AddImportsInContainersAsync>d__35")]
private static Task`1<Document> AddImportsInContainersAsync(Document document, IAddImportsService addImportService, ImmutableArray`1<SyntaxNode> containers, ImmutableArray`1<string> names, bool placeSystemNamespaceFirst, bool allowInHiddenRegions, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.ChangeNamespace.AbstractChangeNamespaceService`3/<MergeDiffAsync>d__36")]
private static Task`1<Solution> MergeDiffAsync(Solution oldSolution, Solution newSolution, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.ChangeNamespace.AbstractChangeNamespaceService`3/<<TryChangeTopLevelNamespacesAsync>g__GetTopLevelNamespacesAsync|15_0>d")]
[CompilerGeneratedAttribute]
internal static Task`1<ImmutableArray`1<SyntaxNode>> <TryChangeTopLevelNamespacesAsync>g__GetTopLevelNamespacesAsync|15_0(Document document, CancellationToken cancellationToken);
    [CompilerGeneratedAttribute]
internal static Task`1<Document> <RemoveUnnecessaryImportsAsync>g__RemoveUnnecessaryImportsWorker|34_0(Document doc, IEnumerable`1<SyntaxNode> importsToRemove, CancellationToken token);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal abstract class Microsoft.CodeAnalysis.ChangeSignature.AbstractChangeSignatureService : object {
    protected SyntaxAnnotation changeSignatureFormattingAnnotation;
    protected SyntaxGenerator Generator { get; }
    protected ISyntaxFacts SyntaxFacts { get; }
    public abstract virtual Task`1<ValueTuple`2<ISymbol, int>> GetInvocationSymbolAsync(Document document, int position, bool restrictToDeclarations, CancellationToken cancellationToken);
    public abstract virtual SyntaxNode FindNodeToUpdate(Document document, SyntaxNode node);
    public abstract virtual Task`1<ImmutableArray`1<ISymbol>> DetermineCascadedSymbolsFromDelegateInvokeAsync(IMethodSymbol symbol, Document document, CancellationToken cancellationToken);
    public abstract virtual Task`1<SyntaxNode> ChangeSignatureAsync(Document document, ISymbol declarationSymbol, SyntaxNode potentiallyUpdatedNode, SyntaxNode originalNode, SignatureChange signaturePermutation, CancellationToken cancellationToken);
    protected abstract virtual IEnumerable`1<AbstractFormattingRule> GetFormattingRules(Document document);
    protected abstract virtual T TransferLeadingWhitespaceTrivia(T newArgument, SyntaxNode oldArgument);
    protected abstract virtual SyntaxToken CommaTokenWithElasticSpace();
    protected abstract virtual SyntaxNode CreateExplicitParamsArrayFromIndividualArguments(SeparatedSyntaxList`1<SyntaxNode> newArguments, int startingIndex, IParameterSymbol parameterSymbol);
    protected abstract virtual SyntaxNode AddNameToArgument(SyntaxNode argument, string name);
    protected abstract virtual bool SupportsOptionalAndParamsArrayParametersSimultaneously();
    protected abstract virtual SyntaxGenerator get_Generator();
    protected abstract virtual ISyntaxFacts get_SyntaxFacts();
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.ChangeSignature.AbstractChangeSignatureService/<GetChangeSignatureCodeActionAsync>d__15")]
public Task`1<ImmutableArray`1<ChangeSignatureCodeAction>> GetChangeSignatureCodeActionAsync(Document document, TextSpan span, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.ChangeSignature.AbstractChangeSignatureService/<GetChangeSignatureContextAsync>d__16")]
internal Task`1<ChangeSignatureAnalyzedContext> GetChangeSignatureContextAsync(Document document, int position, bool restrictToDeclarations, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.ChangeSignature.AbstractChangeSignatureService/<ChangeSignatureWithContextAsync>d__17")]
internal Task`1<ChangeSignatureResult> ChangeSignatureWithContextAsync(ChangeSignatureAnalyzedContext context, ChangeSignatureOptionsResult options, CancellationToken cancellationToken);
    internal static ChangeSignatureOptionsResult GetChangeSignatureOptions(ChangeSignatureAnalyzedContext context);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.ChangeSignature.AbstractChangeSignatureService/<FindChangeSignatureReferencesAsync>d__19")]
private static Task`1<ImmutableArray`1<ReferencedSymbol>> FindChangeSignatureReferencesAsync(ISymbol symbol, Solution solution, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.ChangeSignature.AbstractChangeSignatureService/<CreateUpdatedSolutionAsync>d__20")]
private Task`1<ValueTuple`2<Solution, string>> CreateUpdatedSolutionAsync(ChangeSignatureAnalysisSucceededContext context, ChangeSignatureOptionsResult options, CancellationToken cancellationToken);
    [NullableContextAttribute("0")]
private static void AddUpdatableNodeToDictionaries(Dictionary`2<DocumentId, List`1<SyntaxNode>> nodesToUpdate, DocumentId documentId, SyntaxNode nodeToUpdate, Dictionary`2<SyntaxNode, ISymbol> definitionToUse, ISymbol symbolWithSemanticParameters);
    [NullableContextAttribute("0")]
private static bool TryGetNodeWithEditableSignatureOrAttributes(Location location, Solution solution, SyntaxNode& nodeToUpdate, DocumentId& documentId);
    [NullableContextAttribute("0")]
protected static ImmutableArray`1<IUnifiedArgumentSyntax> PermuteArguments(ISymbol declarationSymbol, ImmutableArray`1<IUnifiedArgumentSyntax> arguments, SignatureChange updatedSignature, bool isReducedExtensionMethod);
    [NullableContextAttribute("0")]
private static SignatureChange UpdateSignatureChangeToIncludeExtraParametersFromTheDeclarationSymbol(ISymbol declarationSymbol, SignatureChange updatedSignature);
    [NullableContextAttribute("0")]
private static ImmutableArray`1<IParameterSymbol> GetParametersToPermute(ImmutableArray`1<IUnifiedArgumentSyntax> arguments, ImmutableArray`1<IParameterSymbol> originalParameters, bool isReducedExtensionMethod);
    [NullableContextAttribute("0")]
protected static int GetParameterIndex(SeparatedSyntaxList`1<TNode> parameters, int position);
    [NullableContextAttribute("0")]
protected ValueTuple`2<ImmutableArray`1<T>, ImmutableArray`1<SyntaxToken>> UpdateDeclarationBase(SeparatedSyntaxList`1<T> list, SignatureChange updatedSignature, Func`2<AddedParameter, T> createNewParameterMethod);
    [NullableContextAttribute("0")]
protected ImmutableArray`1<SyntaxToken> GetSeparators(SeparatedSyntaxList`1<T> arguments, int numSeparatorsToSkip);
    [NullableContextAttribute("0")]
[AsyncStateMachineAttribute("Microsoft.CodeAnalysis.ChangeSignature.AbstractChangeSignatureService/<AddNewArgumentsToListAsync>d__29")]
protected virtual Task`1<SeparatedSyntaxList`1<SyntaxNode>> AddNewArgumentsToListAsync(ISymbol declarationSymbol, SeparatedSyntaxList`1<SyntaxNode> newArguments, SignatureChange signaturePermutation, bool isReducedExtensionMethod, bool isParamsArrayExpanded, bool generateAttributeArguments, Document document, int position, CancellationToken cancellationToken);
    [NullableContextAttribute("0")]
[AsyncStateMachineAttribute("Microsoft.CodeAnalysis.ChangeSignature.AbstractChangeSignatureService/<GenerateInferredCallsiteExpressionAsync>d__30")]
private Task`1<SyntaxNode> GenerateInferredCallsiteExpressionAsync(Document document, int position, AddedParameter addedParameter, CancellationToken cancellationToken);
    [NullableContextAttribute("0")]
protected ImmutableArray`1<SyntaxTrivia> GetPermutedDocCommentTrivia(Document document, SyntaxNode node, ImmutableArray`1<SyntaxNode> permutedParamNodes);
    [NullableContextAttribute("0")]
protected static bool IsParamsArrayExpandedHelper(ISymbol symbol, int argumentCount, bool lastArgumentIsNamed, SemanticModel semanticModel, SyntaxNode lastArgumentExpression, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.ChangeSignature.AbstractChangeSignatureService/<<ChangeSignatureWithContextAsync>g__GetChangeSignatureResultAsync|17_0>d")]
[CompilerGeneratedAttribute]
private Task`1<ChangeSignatureResult> <ChangeSignatureWithContextAsync>g__GetChangeSignatureResultAsync|17_0(ChangeSignatureAnalysisSucceededContext context, ChangeSignatureOptionsResult options, CancellationToken cancellationToken);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.CodeAnalysis.ChangeSignature.AddedParameter : Parameter {
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    [CompilerGeneratedAttribute]
private ITypeSymbol <Type>k__BackingField;
    [CompilerGeneratedAttribute]
private string <TypeName>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <TypeBinds>k__BackingField;
    [CompilerGeneratedAttribute]
private CallSiteKind <CallSiteKind>k__BackingField;
    [CompilerGeneratedAttribute]
private string <CallSiteValue>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsRequired>k__BackingField;
    [CompilerGeneratedAttribute]
private string <DefaultValue>k__BackingField;
    public string Name { get; }
    public bool HasDefaultValue { get; }
    public ITypeSymbol Type { get; }
    public string TypeName { get; }
    public bool TypeBinds { get; }
    public CallSiteKind CallSiteKind { get; }
    public string CallSiteValue { get; }
    public bool IsRequired { get; }
    public string DefaultValue { get; }
    public AddedParameter(ITypeSymbol type, string typeName, string name, CallSiteKind callSiteKind, string callSiteValue, bool isRequired, string defaultValue, bool typeBinds);
    [CompilerGeneratedAttribute]
public virtual string get_Name();
    public virtual bool get_HasDefaultValue();
    [CompilerGeneratedAttribute]
public ITypeSymbol get_Type();
    [CompilerGeneratedAttribute]
public string get_TypeName();
    [CompilerGeneratedAttribute]
public bool get_TypeBinds();
    [CompilerGeneratedAttribute]
public CallSiteKind get_CallSiteKind();
    [CompilerGeneratedAttribute]
public string get_CallSiteValue();
    [CompilerGeneratedAttribute]
public bool get_IsRequired();
    [CompilerGeneratedAttribute]
public string get_DefaultValue();
    public virtual string ToString();
}
internal enum Microsoft.CodeAnalysis.ChangeSignature.CallSiteKind : Enum {
    public int value__;
    public static CallSiteKind Value;
    public static CallSiteKind ValueWithName;
    public static CallSiteKind Todo;
    public static CallSiteKind Omitted;
    public static CallSiteKind Inferred;
}
internal class Microsoft.CodeAnalysis.ChangeSignature.CannotChangeSignatureAnalyzedContext : ChangeSignatureAnalyzedContext {
    public ChangeSignatureFailureKind CannotChangeSignatureReason;
    public CannotChangeSignatureAnalyzedContext(ChangeSignatureFailureKind reason);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.CodeAnalysis.ChangeSignature.ChangeSignatureAnalysisSucceededContext : ChangeSignatureAnalyzedContext {
    public Document Document;
    public ISymbol Symbol;
    public ParameterConfiguration ParameterConfiguration;
    public int PositionForTypeBinding;
    public Solution Solution { get; }
    public ChangeSignatureAnalysisSucceededContext(Document document, int positionForTypeBinding, ISymbol symbol, ParameterConfiguration parameterConfiguration);
    public Solution get_Solution();
}
internal abstract class Microsoft.CodeAnalysis.ChangeSignature.ChangeSignatureAnalyzedContext : object {
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.CodeAnalysis.ChangeSignature.ChangeSignatureCodeAction : CodeActionWithOptions {
    private AbstractChangeSignatureService _changeSignatureService;
    private ChangeSignatureAnalysisSucceededContext _context;
    public string Title { get; }
    public ChangeSignatureCodeAction(AbstractChangeSignatureService changeSignatureService, ChangeSignatureAnalysisSucceededContext context);
    public virtual string get_Title();
    [NullableContextAttribute("2")]
public virtual object GetOptions(CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.ChangeSignature.ChangeSignatureCodeAction/<ComputeOperationsAsync>d__6")]
protected virtual Task`1<IEnumerable`1<CodeActionOperation>> ComputeOperationsAsync(object options, CancellationToken cancellationToken);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.CodeAnalysis.ChangeSignature.ChangeSignatureCodeActionOperation : CodeActionOperation {
    [CompilerGeneratedAttribute]
private Solution <ChangedSolution>k__BackingField;
    [NullableAttribute("2")]
[CompilerGeneratedAttribute]
private string <ConfirmationMessage>k__BackingField;
    public Solution ChangedSolution { get; }
    [NullableAttribute("2")]
public string ConfirmationMessage { get; }
    internal bool ApplyDuringTests { get; }
    public ChangeSignatureCodeActionOperation(Solution changedSolution, string confirmationMessage);
    [CompilerGeneratedAttribute]
public Solution get_ChangedSolution();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public string get_ConfirmationMessage();
    internal virtual bool get_ApplyDuringTests();
    public virtual void Apply(Workspace workspace, CancellationToken cancellationToken);
    internal virtual bool TryApply(Workspace workspace, IProgressTracker progressTracker, CancellationToken cancellationToken);
}
[ExportCodeRefactoringProviderAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.ChangeSignature.ChangeSignatureCodeRefactoringProvider : CodeRefactoringProvider {
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.ChangeSignature.ChangeSignatureCodeRefactoringProvider/<ComputeRefactoringsAsync>d__1")]
public sealed virtual Task ComputeRefactoringsAsync(CodeRefactoringContext context);
}
internal enum Microsoft.CodeAnalysis.ChangeSignature.ChangeSignatureFailureKind : Enum {
    public int value__;
    public static ChangeSignatureFailureKind None;
    public static ChangeSignatureFailureKind DefinedInMetadata;
    public static ChangeSignatureFailureKind IncorrectKind;
}
internal class Microsoft.CodeAnalysis.ChangeSignature.ChangeSignatureLogger : object {
    private static string Maximum;
    private static string Minimum;
    private static string Mean;
    private static LogAggregator s_logAggregator;
    private static StatisticLogAggregator s_statisticLogAggregator;
    private static HistogramLogAggregator s_histogramLogAggregator;
    private static ChangeSignatureLogger();
    internal static void LogChangeSignatureDialogLaunched();
    internal static void LogChangeSignatureDialogCommitted();
    internal static void LogAddParameterDialogLaunched();
    internal static void LogAddParameterDialogCommitted();
    internal static void LogTransformationInformation(int numOriginalParameters, int numParametersAdded, int numParametersRemoved, bool anyParametersReordered);
    private static void LogTransformationCombination(bool parametersAdded, bool parametersRemoved, bool parametersReordered);
    internal static void LogCommitInformation(int numDeclarationsUpdated, int numCallSitesUpdated, int elapsedMS);
    internal static void LogAddedParameterTypeBinds();
    internal static void LogAddedParameterRequired();
    internal static void LogAddedParameter_ValueExplicit();
    internal static void LogAddedParameter_ValueExplicitNamed();
    internal static void LogAddedParameter_ValueTODO();
    internal static void LogAddedParameter_ValueOmitted();
    internal static void ReportTelemetry();
    private static string CreateProperty(string parent, string child);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.CodeAnalysis.ChangeSignature.ChangeSignatureOptionsResult : object {
    public bool PreviewChanges;
    public SignatureChange UpdatedSignature;
    public ChangeSignatureOptionsResult(SignatureChange updatedSignature, bool previewChanges);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
internal class Microsoft.CodeAnalysis.ChangeSignature.ChangeSignatureResult : object {
    [CompilerGeneratedAttribute]
private bool <Succeeded>k__BackingField;
    [CompilerGeneratedAttribute]
private Solution <UpdatedSolution>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<Glyph> <Glyph>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <PreviewChanges>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<ChangeSignatureFailureKind> <ChangeSignatureFailureKind>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ConfirmationMessage>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    [MemberNotNullWhenAttribute("True", "UpdatedSolution")]
public bool Succeeded { get; }
    public Solution UpdatedSolution { get; }
    public Nullable`1<Glyph> Glyph { get; }
    public bool PreviewChanges { get; }
    public Nullable`1<ChangeSignatureFailureKind> ChangeSignatureFailureKind { get; }
    public string ConfirmationMessage { get; }
    public string Name { get; }
    public ChangeSignatureResult(bool succeeded, Solution updatedSolution, string name, Nullable`1<Glyph> glyph, bool previewChanges, Nullable`1<ChangeSignatureFailureKind> changeSignatureFailureKind, string confirmationMessage);
    [CompilerGeneratedAttribute]
[MemberNotNullWhenAttribute("True", "UpdatedSolution")]
public bool get_Succeeded();
    [CompilerGeneratedAttribute]
public Solution get_UpdatedSolution();
    [CompilerGeneratedAttribute]
public Nullable`1<Glyph> get_Glyph();
    [CompilerGeneratedAttribute]
public bool get_PreviewChanges();
    [CompilerGeneratedAttribute]
public Nullable`1<ChangeSignatureFailureKind> get_ChangeSignatureFailureKind();
    [CompilerGeneratedAttribute]
public string get_ConfirmationMessage();
    [CompilerGeneratedAttribute]
public string get_Name();
}
internal class Microsoft.CodeAnalysis.ChangeSignature.DelegateInvokeMethodReferenceFinder : AbstractReferenceFinder`1<IMethodSymbol> {
    public static IReferenceFinder DelegateInvokeMethod;
    private static DelegateInvokeMethodReferenceFinder();
    protected virtual bool CanFind(IMethodSymbol symbol);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.ChangeSignature.DelegateInvokeMethodReferenceFinder/<DetermineCascadedSymbolsAsync>d__2")]
protected virtual Task`1<ImmutableArray`1<ISymbol>> DetermineCascadedSymbolsAsync(IMethodSymbol symbol, Solution solution, IImmutableSet`1<Project> projects, FindReferencesSearchOptions options, CancellationToken cancellationToken);
    protected virtual Task`1<ImmutableArray`1<Document>> DetermineDocumentsToSearchAsync(IMethodSymbol symbol, Project project, IImmutableSet`1<Document> documents, FindReferencesSearchOptions options, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.ChangeSignature.DelegateInvokeMethodReferenceFinder/<FindReferencesInDocumentAsync>d__4")]
protected virtual ValueTask`1<ImmutableArray`1<FinderLocation>> FindReferencesInDocumentAsync(IMethodSymbol methodSymbol, Document document, SemanticModel semanticModel, FindReferencesSearchOptions options, CancellationToken cancellationToken);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.CodeAnalysis.ChangeSignature.ExistingParameter : Parameter {
    [CompilerGeneratedAttribute]
private IParameterSymbol <Symbol>k__BackingField;
    public IParameterSymbol Symbol { get; }
    public bool HasDefaultValue { get; }
    public string Name { get; }
    public ExistingParameter(IParameterSymbol param);
    [CompilerGeneratedAttribute]
public IParameterSymbol get_Symbol();
    public virtual bool get_HasDefaultValue();
    public virtual string get_Name();
}
internal interface Microsoft.CodeAnalysis.ChangeSignature.IChangeSignatureOptionsService {
    [NullableContextAttribute("1")]
public abstract virtual ChangeSignatureOptionsResult GetChangeSignatureOptions(Document document, int positionForTypeBinding, ISymbol symbol, ParameterConfiguration parameters);
}
internal interface Microsoft.CodeAnalysis.ChangeSignature.IUnifiedArgumentSyntax {
    public bool IsDefault { get; }
    public bool IsNamed { get; }
    public abstract virtual bool get_IsDefault();
    public abstract virtual bool get_IsNamed();
    public abstract virtual string GetName();
    public abstract virtual IUnifiedArgumentSyntax WithName(string name);
    public abstract virtual IUnifiedArgumentSyntax WithAdditionalAnnotations(SyntaxAnnotation annotation);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal abstract class Microsoft.CodeAnalysis.ChangeSignature.Parameter : object {
    public bool HasDefaultValue { get; }
    public string Name { get; }
    public abstract virtual bool get_HasDefaultValue();
    public abstract virtual string get_Name();
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
internal class Microsoft.CodeAnalysis.ChangeSignature.ParameterConfiguration : object {
    public ExistingParameter ThisParameter;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ImmutableArray`1<Parameter> ParametersWithoutDefaultValues;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ImmutableArray`1<Parameter> RemainingEditableParameters;
    public ExistingParameter ParamsParameter;
    public int SelectedIndex;
    public ParameterConfiguration(ExistingParameter thisParameter, ImmutableArray`1<Parameter> parametersWithoutDefaultValues, ImmutableArray`1<Parameter> remainingEditableParameters, ExistingParameter paramsParameter, int selectedIndex);
    [NullableContextAttribute("1")]
public static ParameterConfiguration Create(ImmutableArray`1<Parameter> parameters, bool isExtensionMethod, int selectedIndex);
    [NullableContextAttribute("1")]
internal ParameterConfiguration WithoutAddedParameters();
    public ImmutableArray`1<Parameter> ToListOfParameters();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.CodeAnalysis.ChangeSignature.SignatureChange : object {
    public ParameterConfiguration OriginalConfiguration;
    public ParameterConfiguration UpdatedConfiguration;
    private Dictionary`2<int, Nullable`1<int>> _originalIndexToUpdatedIndexMap;
    public SignatureChange(ParameterConfiguration originalConfiguration, ParameterConfiguration updatedConfiguration);
    public Nullable`1<int> GetUpdatedIndex(int parameterIndex);
    internal SignatureChange WithoutAddedParameters();
    internal void LogTelemetry();
    private static bool AnyParametersReordered(ImmutableArray`1<Parameter> originalListOfParameters, ImmutableArray`1<Parameter> updatedListOfParameters);
}
[IsReadOnlyAttribute]
internal class Microsoft.CodeAnalysis.Classification.ClassifiedSpansAndHighlightSpan : ValueType {
    public static string Key;
    public ImmutableArray`1<ClassifiedSpan> ClassifiedSpans;
    public TextSpan HighlightSpan;
    public ClassifiedSpansAndHighlightSpan(ImmutableArray`1<ClassifiedSpan> classifiedSpans, TextSpan highlightSpan);
}
internal static class Microsoft.CodeAnalysis.Classification.ClassifiedSpansAndHighlightSpanFactory : object {
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.Classification.ClassifiedSpansAndHighlightSpanFactory/<GetClassifiedDocumentSpanAsync>d__0")]
public static Task`1<DocumentSpan> GetClassifiedDocumentSpanAsync(Document document, TextSpan sourceSpan, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.Classification.ClassifiedSpansAndHighlightSpanFactory/<ClassifyAsync>d__1")]
public static Task`1<ClassifiedSpansAndHighlightSpan> ClassifyAsync(DocumentSpan documentSpan, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.Classification.ClassifiedSpansAndHighlightSpanFactory/<ClassifyAsync>d__2")]
private static Task`1<ClassifiedSpansAndHighlightSpan> ClassifyAsync(Document document, TextSpan sourceSpan, CancellationToken cancellationToken);
    private static TextSpan GetLineSpanForReference(SourceText sourceText, TextSpan referenceSpan);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.Classification.ClassifiedSpansAndHighlightSpanFactory/<GetTaggedTextForDocumentRegionAsync>d__4")]
private static Task`1<ClassifiedSpansAndHighlightSpan> GetTaggedTextForDocumentRegionAsync(Document document, TextSpan narrowSpan, TextSpan widenedSpan, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.Classification.ClassifiedSpansAndHighlightSpanFactory/<GetClassifiedSpansAsync>d__5")]
private static Task`1<ImmutableArray`1<ClassifiedSpan>> GetClassifiedSpansAsync(Document document, TextSpan narrowSpan, TextSpan widenedSpan, CancellationToken cancellationToken);
}
public class Microsoft.CodeAnalysis.CodeActions.DocumentNavigationOperation : CodeActionOperation {
    private DocumentId _documentId;
    private int _position;
    public DocumentNavigationOperation(DocumentId documentId, int position);
    public virtual void Apply(Workspace workspace, CancellationToken cancellationToken);
}
internal interface Microsoft.CodeAnalysis.CodeActions.WorkspaceServices.IAddMetadataReferenceCodeActionOperationFactoryWorkspaceService {
    public abstract virtual CodeActionOperation CreateAddMetadataReferenceOperation(ProjectId projectId, AssemblyIdentity assemblyIdentity);
}
internal interface Microsoft.CodeAnalysis.CodeActions.WorkspaceServices.ISymbolRenamedCodeActionOperationFactoryWorkspaceService {
    public abstract virtual CodeActionOperation CreateSymbolRenamedOperation(ISymbol symbol, string newName, Solution startingSolution, Solution updatedSolution);
}
internal class Microsoft.CodeAnalysis.CodeCleanup.DiagnosticSet : object {
    [CompilerGeneratedAttribute]
private string <Description>k__BackingField;
    [CompilerGeneratedAttribute]
private ImmutableArray`1<string> <DiagnosticIds>k__BackingField;
    public string Description { get; }
    public ImmutableArray`1<string> DiagnosticIds { get; }
    public DiagnosticSet(string description, String[] diagnosticIds);
    [CompilerGeneratedAttribute]
public string get_Description();
    [CompilerGeneratedAttribute]
public ImmutableArray`1<string> get_DiagnosticIds();
}
internal class Microsoft.CodeAnalysis.CodeCleanup.EnabledDiagnosticOptions : object {
    [CompilerGeneratedAttribute]
private bool <FormatDocument>k__BackingField;
    [CompilerGeneratedAttribute]
private ImmutableArray`1<DiagnosticSet> <Diagnostics>k__BackingField;
    [CompilerGeneratedAttribute]
private OrganizeUsingsSet <OrganizeUsings>k__BackingField;
    public bool FormatDocument { get; }
    public ImmutableArray`1<DiagnosticSet> Diagnostics { get; }
    public OrganizeUsingsSet OrganizeUsings { get; }
    public EnabledDiagnosticOptions(bool formatDocument, ImmutableArray`1<DiagnosticSet> diagnostics, OrganizeUsingsSet organizeUsings);
    [CompilerGeneratedAttribute]
public bool get_FormatDocument();
    [CompilerGeneratedAttribute]
public ImmutableArray`1<DiagnosticSet> get_Diagnostics();
    [CompilerGeneratedAttribute]
public OrganizeUsingsSet get_OrganizeUsings();
}
internal interface Microsoft.CodeAnalysis.CodeCleanup.ICodeCleanupService {
    public abstract virtual Task`1<Document> CleanupAsync(Document document, EnabledDiagnosticOptions enabledDiagnostics, IProgressTracker progressTracker, CancellationToken cancellationToken);
    public abstract virtual EnabledDiagnosticOptions GetAllDiagnostics();
}
internal class Microsoft.CodeAnalysis.CodeCleanup.OrganizeUsingsSet : object {
    [CompilerGeneratedAttribute]
private bool <IsRemoveUnusedImportEnabled>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsSortImportsEnabled>k__BackingField;
    public bool IsRemoveUnusedImportEnabled { get; }
    public bool IsSortImportsEnabled { get; }
    public OrganizeUsingsSet(bool isRemoveUnusedImportEnabled, bool isSortImportsEnabled);
    [CompilerGeneratedAttribute]
public bool get_IsRemoveUnusedImportEnabled();
    [CompilerGeneratedAttribute]
public bool get_IsSortImportsEnabled();
}
internal abstract class Microsoft.CodeAnalysis.CodeFixes.AbstractConfigurationActionWithNestedActions : CodeActionWithNestedActions {
    internal CodeActionPriority Priority { get; }
    internal CodeActionPriority AdditionalPriority { get; }
    internal bool IsBulkConfigurationAction { get; }
    protected AbstractConfigurationActionWithNestedActions(ImmutableArray`1<CodeAction> nestedActions, string title);
    internal virtual CodeActionPriority get_Priority();
    internal virtual CodeActionPriority get_AdditionalPriority();
    internal virtual bool get_IsBulkConfigurationAction();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal abstract class Microsoft.CodeAnalysis.CodeFixes.AddExplicitCast.AbstractAddExplicitCastCodeFixProvider`1 : SyntaxEditorBasedCodeFixProvider {
    private static int MaximumConversionOptions;
    [CompilerGeneratedAttribute]
private ISyntaxFacts <SyntaxFacts>k__BackingField;
    internal CodeFixCategory CodeFixCategory { get; }
    protected ISyntaxFacts SyntaxFacts { get; }
    protected AbstractAddExplicitCastCodeFixProvider`1(ISyntaxFacts syntaxFacts);
    internal sealed virtual CodeFixCategory get_CodeFixCategory();
    [CompilerGeneratedAttribute]
protected ISyntaxFacts get_SyntaxFacts();
    protected abstract virtual SyntaxNode ApplyFix(SyntaxNode currentRoot, TExpressionSyntax targetNode, ITypeSymbol conversionType);
    protected abstract virtual CommonConversion ClassifyConversion(SemanticModel semanticModel, TExpressionSyntax expression, ITypeSymbol type);
    protected abstract virtual bool TryGetTargetTypeInfo(Document document, SemanticModel semanticModel, SyntaxNode root, string diagnosticId, TExpressionSyntax spanNode, CancellationToken cancellationToken, ImmutableArray`1& potentialConversionTypes);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.CodeFixes.AddExplicitCast.AbstractAddExplicitCastCodeFixProvider`1/<RegisterCodeFixesAsync>d__10")]
public virtual Task RegisterCodeFixesAsync(CodeFixContext context);
    private static string GetSubItemName(SemanticModel semanticModel, int position, ITypeSymbol conversionType);
    private static void ReportTelemetryIfNecessary(ImmutableArray`1<ValueTuple`2<TExpressionSyntax, ITypeSymbol>> potentialConversionTypes);
    protected ImmutableArray`1<ValueTuple`2<TExpressionSyntax, ITypeSymbol>> FilterValidPotentialConversionTypes(SemanticModel semanticModel, ArrayBuilder`1<ValueTuple`2<TExpressionSyntax, ITypeSymbol>> mutablePotentialConversionTypes);
    protected static bool FindCorrespondingParameterByName(string argumentName, ImmutableArray`1<IParameterSymbol> parameters, Int32& parameterIndex);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.CodeFixes.AddExplicitCast.AbstractAddExplicitCastCodeFixProvider`1/<FixAllAsync>d__15")]
protected virtual Task FixAllAsync(Document document, ImmutableArray`1<Diagnostic> diagnostics, SyntaxEditor editor, CancellationToken cancellationToken);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.CodeAnalysis.CodeFixes.AddExplicitCast.InheritanceDistanceComparer`1 : object {
    private SemanticModel _semanticModel;
    public InheritanceDistanceComparer`1(SemanticModel semanticModel);
    public sealed virtual int Compare(ValueTuple`2<TExpressionSyntax, ITypeSymbol> x, ValueTuple`2<TExpressionSyntax, ITypeSymbol> y);
    private int GetInheritanceDistanceRecursive(ITypeSymbol baseType, ITypeSymbol derivedType);
    private int GetInheritanceDistance(ITypeSymbol baseType, ITypeSymbol castType);
}
internal abstract class Microsoft.CodeAnalysis.CodeFixes.Async.AbstractConvertToAsyncCodeFixProvider : CodeFixProvider {
    protected abstract virtual Task`1<string> GetDescriptionAsync(Diagnostic diagnostic, SyntaxNode node, SemanticModel semanticModel, CancellationToken cancellationToken);
    protected abstract virtual Task`1<Tuple`2<SyntaxTree, SyntaxNode>> GetRootInOtherSyntaxTreeAsync(SyntaxNode node, SemanticModel semanticModel, Diagnostic diagnostic, CancellationToken cancellationToken);
    public virtual FixAllProvider GetFixAllProvider();
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.CodeFixes.Async.AbstractConvertToAsyncCodeFixProvider/<RegisterCodeFixesAsync>d__3")]
public sealed virtual Task RegisterCodeFixesAsync(CodeFixContext context);
    private static bool TryGetNode(SyntaxNode root, TextSpan span, SyntaxNode& node);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.CodeFixes.Async.AbstractConvertToAsyncCodeFixProvider/<GetCodeActionAsync>d__5")]
private Task`1<CodeAction> GetCodeActionAsync(SyntaxNode node, Document document, Diagnostic diagnostic, CancellationToken cancellationToken);
}
internal class Microsoft.CodeAnalysis.CodeFixes.CodeFixCollection : object {
    [CompilerGeneratedAttribute]
private object <Provider>k__BackingField;
    [CompilerGeneratedAttribute]
private TextSpan <TextSpan>k__BackingField;
    [CompilerGeneratedAttribute]
private ImmutableArray`1<CodeFix> <Fixes>k__BackingField;
    [CompilerGeneratedAttribute]
private FixAllState <FixAllState>k__BackingField;
    [CompilerGeneratedAttribute]
private ImmutableArray`1<FixAllScope> <SupportedScopes>k__BackingField;
    [CompilerGeneratedAttribute]
private Diagnostic <FirstDiagnostic>k__BackingField;
    public object Provider { get; }
    public TextSpan TextSpan { get; }
    public ImmutableArray`1<CodeFix> Fixes { get; }
    public FixAllState FixAllState { get; }
    public ImmutableArray`1<FixAllScope> SupportedScopes { get; }
    public Diagnostic FirstDiagnostic { get; }
    public CodeFixCollection(object provider, TextSpan span, ImmutableArray`1<CodeFix> fixes, FixAllState fixAllState, ImmutableArray`1<FixAllScope> supportedScopes, Diagnostic firstDiagnostic);
    [CompilerGeneratedAttribute]
public object get_Provider();
    [CompilerGeneratedAttribute]
public TextSpan get_TextSpan();
    [CompilerGeneratedAttribute]
public ImmutableArray`1<CodeFix> get_Fixes();
    [CompilerGeneratedAttribute]
public FixAllState get_FixAllState();
    [CompilerGeneratedAttribute]
public ImmutableArray`1<FixAllScope> get_SupportedScopes();
    [CompilerGeneratedAttribute]
public Diagnostic get_FirstDiagnostic();
}
[ExtensionAttribute]
internal static class Microsoft.CodeAnalysis.CodeFixes.CodeFixContextExtensions : object {
    [ExtensionAttribute]
internal static void RegisterFixes(CodeFixContext context, IEnumerable`1<CodeAction> actions, Diagnostic diagnostic);
    [ExtensionAttribute]
internal static void RegisterFixes(CodeFixContext context, IEnumerable`1<CodeAction> actions, ImmutableArray`1<Diagnostic> diagnostics);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExportAttribute("Microsoft.CodeAnalysis.CodeFixes.ICodeFixService")]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.CodeFixes.CodeFixService : object {
    private static Comparison`1<DiagnosticData> s_diagnosticDataComparisonById;
    private IDiagnosticAnalyzerService _diagnosticService;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private Func`2<Workspace, ImmutableDictionary`2<string, Lazy`1<ImmutableDictionary`2<string, ImmutableArray`1<CodeFixProvider>>>>> _getWorkspaceFixersMap;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private ImmutableDictionary`2<string, Lazy`1<ImmutableDictionary`2<string, ImmutableArray`1<CodeFixProvider>>>> _lazyWorkspaceFixersMap;
    private ConditionalWeakTable`2<IReadOnlyList`1<AnalyzerReference>, ImmutableDictionary`2<string, List`1<CodeFixProvider>>> _projectFixersMap;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private ImmutableDictionary`2<CodeFixProvider, ImmutableArray`1<string>> _fixerToFixableIdsMap;
    private Func`2<Workspace, ImmutableDictionary`2<string, Lazy`1<ImmutableDictionary`2<CodeFixProvider, int>>>> _getFixerPriorityMap;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private ImmutableDictionary`2<string, Lazy`1<ImmutableDictionary`2<CodeFixProvider, int>>> _lazyFixerPriorityMap;
    private ConditionalWeakTable`2<AnalyzerReference, ProjectCodeFixProvider> _analyzerReferenceToFixersMap;
    private CreateValueCallback<AnalyzerReference, ProjectCodeFixProvider> _createProjectCodeFixProvider;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private ImmutableDictionary`2<string, Lazy`1<ImmutableArray`1<IConfigurationFixProvider>>> _configurationProvidersMap;
    private IEnumerable`1<Lazy`1<IErrorLoggerService>> _errorLoggers;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private ImmutableDictionary`2<object, FixAllProviderInfo> _fixAllProviderMap;
    private static Func`2<string, List`1<CodeFixProvider>> s_createList;
    [ImportingConstructorAttribute]
public CodeFixService(IDiagnosticAnalyzerService diagnosticAnalyzerService, IEnumerable`1<Lazy`1<IErrorLoggerService>> loggers, IEnumerable`1<Lazy`2<CodeFixProvider, CodeChangeProviderMetadata>> fixers, IEnumerable`1<Lazy`2<IConfigurationFixProvider, CodeChangeProviderMetadata>> configurationProviders);
    private static CodeFixService();
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.CodeFixes.CodeFixService/<GetMostSevereFixableDiagnosticAsync>d__14")]
public sealed virtual Task`1<FirstDiagnosticResult> GetMostSevereFixableDiagnosticAsync(Document document, TextSpan range, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.CodeFixes.CodeFixService/<GetFirstDiagnosticWithFixAsync>d__15")]
private Task`1<DiagnosticData> GetFirstDiagnosticWithFixAsync(Document document, IEnumerable`1<DiagnosticData> severityGroup, TextSpan range, CancellationToken cancellationToken);
    public sealed virtual Task`1<ImmutableArray`1<CodeFixCollection>> GetFixesAsync(Document document, TextSpan range, bool includeConfigurationFixes, CancellationToken cancellationToken);
    public sealed virtual Task`1<ImmutableArray`1<CodeFixCollection>> GetFixesAsync(Document document, TextSpan range, bool includeConfigurationFixes, bool isBlocking, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.CodeFixes.CodeFixService/<GetFixesAsync>d__18")]
public sealed virtual Task`1<ImmutableArray`1<CodeFixCollection>> GetFixesAsync(Document document, TextSpan range, bool includeConfigurationFixes, bool isBlocking, Func`2<string, IDisposable> addOperationScope, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.CodeFixes.CodeFixService/<GetDocumentFixAllForIdInSpanAsync>d__19")]
public sealed virtual Task`1<CodeFixCollection> GetDocumentFixAllForIdInSpanAsync(Document document, TextSpan range, string diagnosticId, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.CodeFixes.CodeFixService/<ApplyCodeFixesForSpecificDiagnosticIdAsync>d__20")]
public sealed virtual Task`1<Document> ApplyCodeFixesForSpecificDiagnosticIdAsync(Document document, string diagnosticId, IProgressTracker progressTracker, CancellationToken cancellationToken);
    private bool TryGetWorkspaceFixersMap(Document document, Lazy`1& fixerMap);
    private bool TryGetWorkspaceFixersPriorityMap(Document document, Lazy`1& fixersPriorityMap);
    private bool TryGetWorkspaceFixer(Lazy`2<CodeFixProvider, CodeChangeProviderMetadata> lazyFixer, Workspace workspace, bool logExceptionWithInfoBar, CodeFixProvider& fixer);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.CodeFixes.CodeFixService/<AppendFixesAsync>d__24")]
private Task AppendFixesAsync(Document document, TextSpan span, IEnumerable`1<DiagnosticData> diagnostics, bool fixAllForInSpan, bool isBlocking, ArrayBuilder`1<CodeFixCollection> result, Func`2<string, IDisposable> addOperationScope, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.CodeFixes.CodeFixService/<GetCodeFixesAsync>d__25")]
private static Task`1<ImmutableArray`1<CodeFix>> GetCodeFixesAsync(Document document, TextSpan span, CodeFixProvider fixer, bool isBlocking, ImmutableArray`1<Diagnostic> diagnostics, Dictionary`2<Diagnostic, PooledHashSet`1<string>> uniqueDiagosticToEquivalenceKeysMap, Dictionary`2<ValueTuple`2<Diagnostic, string>, CodeFixProvider> diagnosticAndEquivalenceKeyToFixersMap, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.CodeFixes.CodeFixService/<AppendConfigurationsAsync>d__26")]
private Task AppendConfigurationsAsync(Document document, TextSpan diagnosticsSpan, IEnumerable`1<DiagnosticData> diagnostics, ArrayBuilder`1<CodeFixCollection> result, PooledHashSet`1<string> registeredConfigurationFixTitles, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.CodeFixes.CodeFixService/<AppendFixesOrConfigurationsAsync>d__27`1")]
private Task AppendFixesOrConfigurationsAsync(Document document, TextSpan fixesSpan, IEnumerable`1<DiagnosticData> diagnosticsWithSameSpan, bool fixAllForInSpan, ArrayBuilder`1<CodeFixCollection> result, TCodeFixProvider fixer, Func`2<Diagnostic, bool> hasFix, Func`2<ImmutableArray`1<Diagnostic>, Task`1<ImmutableArray`1<CodeFix>>> getFixes, CancellationToken cancellationToken);
    public sealed virtual CodeFixProvider GetSuppressionFixer(string language, IEnumerable`1<string> diagnosticIds);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.CodeFixes.CodeFixService/<GetDocumentDiagnosticsAsync>d__29")]
private Task`1<IEnumerable`1<Diagnostic>> GetDocumentDiagnosticsAsync(Document document, ImmutableHashSet`1<string> diagnosticIds, bool includeSuppressedDiagnostics, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.CodeFixes.CodeFixService/<GetProjectDiagnosticsAsync>d__30")]
private Task`1<IEnumerable`1<Diagnostic>> GetProjectDiagnosticsAsync(Project project, bool includeAllDocumentDiagnostics, ImmutableHashSet`1<string> diagnosticIds, bool includeSuppressedDiagnostics, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.CodeFixes.CodeFixService/<ContainsAnyFixAsync>d__31")]
private Task`1<bool> ContainsAnyFixAsync(Document document, DiagnosticData diagnostic, CancellationToken cancellationToken);
    private bool IsInteractiveCodeFixProvider(CodeFixProvider provider);
    private ImmutableArray`1<string> GetFixableDiagnosticIds(CodeFixProvider fixer, IExtensionManager extensionManager);
    private static ImmutableArray`1<string> GetAndTestFixableDiagnosticIds(CodeFixProvider codeFixProvider);
    private ImmutableDictionary`2<string, Lazy`1<ImmutableDictionary`2<string, ImmutableArray`1<CodeFixProvider>>>> GetFixerPerLanguageMap(Dictionary`2<string, List`1<Lazy`2<CodeFixProvider, CodeChangeProviderMetadata>>> fixersPerLanguage, Workspace workspace);
    private static ImmutableDictionary`2<string, Lazy`1<ImmutableArray`1<IConfigurationFixProvider>>> GetConfigurationProvidersPerLanguageMap(Dictionary`2<string, List`1<Lazy`2<IConfigurationFixProvider, CodeChangeProviderMetadata>>> configurationProvidersPerLanguage);
    private ImmutableDictionary`2<string, Lazy`1<ImmutableDictionary`2<CodeFixProvider, int>>> GetFixerPriorityPerLanguageMap(Dictionary`2<string, List`1<Lazy`2<CodeFixProvider, CodeChangeProviderMetadata>>> fixersPerLanguage, Workspace workspace);
    private ImmutableDictionary`2<string, List`1<CodeFixProvider>> GetProjectFixers(Project project);
    private ImmutableDictionary`2<string, List`1<CodeFixProvider>> ComputeProjectFixers(Project project);
    [CompilerGeneratedAttribute]
internal static ImmutableArray`1<Diagnostic> <GetCodeFixesAsync>g__FilterApplicableDiagnostics|25_1(ImmutableArray`1<Diagnostic> applicableDiagnostics, string equivalenceKey, CodeFixProvider fixer, Dictionary`2<Diagnostic, PooledHashSet`1<string>> uniqueDiagosticToEquivalenceKeysMap, Dictionary`2<ValueTuple`2<Diagnostic, string>, CodeFixProvider> diagnosticAndEquivalenceKeyToFixersMap);
    [CompilerGeneratedAttribute]
internal static ImmutableArray`1<IConfigurationFixProvider> <GetConfigurationProvidersPerLanguageMap>g__GetConfigurationFixProviders|37_0(List`1<Lazy`2<IConfigurationFixProvider, CodeChangeProviderMetadata>> languageKindAndFixers);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.CodeAnalysis.CodeFixes.Configuration.ConfigurationUpdater : object {
    private static string DiagnosticOptionPrefix;
    private static string SeveritySuffix;
    private static string BulkConfigureAllAnalyzerDiagnosticsOptionKey;
    private static string BulkConfigureAnalyzerDiagnosticsByCategoryOptionPrefix;
    private static string AllAnalyzerDiagnosticsCategory;
    private static Regex s_headerPattern;
    private static Regex s_optionEntryPattern;
    [NullableAttribute("2")]
private string _optionNameOpt;
    [NullableAttribute("2")]
private string _newOptionValueOpt;
    private string _newSeverity;
    private ConfigurationKind _configurationKind;
    [NullableAttribute("2")]
private Diagnostic _diagnostic;
    [NullableAttribute("2")]
private string _categoryToBulkConfigure;
    private bool _isPerLanguage;
    private Project _project;
    private CancellationToken _cancellationToken;
    private bool _addNewEntryIfNoExistingEntryFound;
    private string _language;
    [NullableContextAttribute("2")]
private ConfigurationUpdater(string optionNameOpt, string newOptionValueOpt, string newSeverity, ConfigurationKind configurationKind, Diagnostic diagnosticToConfigure, string categoryToBulkConfigure, bool isPerLanguage, Project project, bool addNewEntryIfNoExistingEntryFound, CancellationToken cancellationToken);
    private static ConfigurationUpdater();
    public static Task`1<Solution> ConfigureSeverityAsync(ReportDiagnostic severity, Diagnostic diagnostic, Project project, CancellationToken cancellationToken);
    public static Task`1<Solution> ConfigureSeverityAsync(string editorConfigSeverity, Diagnostic diagnostic, Project project, CancellationToken cancellationToken);
    public static Task`1<Solution> BulkConfigureSeverityAsync(string editorConfigSeverity, string category, Project project, CancellationToken cancellationToken);
    public static Task`1<Solution> BulkConfigureSeverityAsync(string editorConfigSeverity, Project project, CancellationToken cancellationToken);
    private static Task`1<Solution> BulkConfigureSeverityCoreAsync(string editorConfigSeverity, string category, Project project, CancellationToken cancellationToken);
    public static Task`1<Solution> ConfigureCodeStyleOptionAsync(string optionName, string optionValue, Diagnostic diagnostic, bool isPerLanguage, Project project, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.CodeFixes.Configuration.ConfigurationUpdater/<ConfigureCodeStyleOptionsAsync>d__26")]
private static Task`1<Solution> ConfigureCodeStyleOptionsAsync(IEnumerable`1<ValueTuple`3<string, string, bool>> codeStyleOptionValues, string editorConfigSeverity, Diagnostic diagnostic, Project project, ConfigurationKind configurationKind, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.CodeFixes.Configuration.ConfigurationUpdater/<ConfigureAsync>d__27")]
private Task`1<Solution> ConfigureAsync();
    [NullableContextAttribute("2")]
private AnalyzerConfigDocument FindOrGenerateEditorConfig();
    private static ImmutableArray`1<ValueTuple`3<string, string, bool>> GetCodeStyleOptionValuesForDiagnostic(Diagnostic diagnostic, Project project);
    internal static bool TryGetEditorConfigStringParts(ICodeStyleOption codeStyleOption, IEditorConfigStorageLocation2 editorConfigLocation, OptionSet optionSet, ValueTuple`2& parts);
    internal static ImmutableArray`1<ValueTuple`4<OptionKey, ICodeStyleOption, IEditorConfigStorageLocation2, bool>> GetCodeStyleOptionsForDiagnostic(Diagnostic diagnostic, Project project);
    private SourceText GetNewAnalyzerConfigDocumentText(SourceText originalText, AnalyzerConfigDocument editorConfigDocument);
    private ValueTuple`3<SourceText, Nullable`1<TextLine>, Nullable`1<TextLine>> CheckIfRuleExistsAndReplaceInFile(SourceText result, AnalyzerConfigDocument editorConfigDocument);
    private SourceText AddMissingRule(SourceText result, Nullable`1<TextLine> lastValidHeaderSpanEnd, Nullable`1<TextLine> lastValidSpecificHeaderSpanEnd);
}
[ExportConfigurationFixProviderAttribute("ConfigureCodeStyleOption", "Mono.Cecil.CustomAttributeArgument[]")]
[SharedAttribute]
[ExtensionOrderAttribute]
[ExtensionOrderAttribute]
internal class Microsoft.CodeAnalysis.CodeFixes.Configuration.ConfigureCodeStyle.ConfigureCodeStyleOptionCodeFixProvider : object {
    private static ImmutableArray`1<bool> s_boolValues;
    private static ConfigureCodeStyleOptionCodeFixProvider();
    public sealed virtual bool IsFixableDiagnostic(Diagnostic diagnostic);
    public sealed virtual FixAllProvider GetFixAllProvider();
    public sealed virtual Task`1<ImmutableArray`1<CodeFix>> GetFixesAsync(Document document, TextSpan span, IEnumerable`1<Diagnostic> diagnostics, CancellationToken cancellationToken);
    public sealed virtual Task`1<ImmutableArray`1<CodeFix>> GetFixesAsync(Project project, IEnumerable`1<Diagnostic> diagnostics, CancellationToken cancellationToken);
    private static ImmutableArray`1<CodeFix> GetConfigurations(Project project, IEnumerable`1<Diagnostic> diagnostics, CancellationToken cancellationToken);
}
[ExportConfigurationFixProviderAttribute("ConfigureSeverity", "Mono.Cecil.CustomAttributeArgument[]")]
[SharedAttribute]
[ExtensionOrderAttribute]
internal class Microsoft.CodeAnalysis.CodeFixes.Configuration.ConfigureSeverity.ConfigureSeverityLevelCodeFixProvider : object {
    [TupleElementNamesAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private static ImmutableArray`1<ValueTuple`2<string, string>> s_editorConfigSeverityStrings;
    private static ConfigureSeverityLevelCodeFixProvider();
    [NullableContextAttribute("1")]
public sealed virtual bool IsFixableDiagnostic(Diagnostic diagnostic);
    [NullableContextAttribute("2")]
public sealed virtual FixAllProvider GetFixAllProvider();
    [NullableContextAttribute("1")]
public sealed virtual Task`1<ImmutableArray`1<CodeFix>> GetFixesAsync(Document document, TextSpan span, IEnumerable`1<Diagnostic> diagnostics, CancellationToken cancellationToken);
    [NullableContextAttribute("1")]
public sealed virtual Task`1<ImmutableArray`1<CodeFix>> GetFixesAsync(Project project, IEnumerable`1<Diagnostic> diagnostics, CancellationToken cancellationToken);
    [NullableContextAttribute("1")]
private static ImmutableArray`1<CodeFix> GetConfigurations(Project project, IEnumerable`1<Diagnostic> diagnostics, CancellationToken cancellationToken);
}
[MetadataAttributeAttribute]
[AttributeUsageAttribute("4")]
internal class Microsoft.CodeAnalysis.CodeFixes.ExportConfigurationFixProviderAttribute : ExportAttribute {
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    [CompilerGeneratedAttribute]
private String[] <Languages>k__BackingField;
    public string Name { get; }
    public String[] Languages { get; }
    public ExportConfigurationFixProviderAttribute(string name, String[] languages);
    [CompilerGeneratedAttribute]
public string get_Name();
    [CompilerGeneratedAttribute]
public String[] get_Languages();
}
[IsReadOnlyAttribute]
internal class Microsoft.CodeAnalysis.CodeFixes.FirstDiagnosticResult : ValueType {
    public bool PartialResult;
    public bool HasFix;
    public DiagnosticData Diagnostic;
    public FirstDiagnosticResult(bool partialResult, bool hasFix, DiagnosticData diagnostic);
}
internal class Microsoft.CodeAnalysis.CodeFixes.FixMultipleCodeAction : FixSomeCodeAction {
    private string _title;
    private string _computingFixWaitDialogMessage;
    public string Title { get; }
    internal string Message { get; }
    internal FixMultipleCodeAction(FixAllState fixAllState, string title, string computingFixWaitDialogMessage);
    public virtual string get_Title();
    internal virtual string get_Message();
}
internal abstract class Microsoft.CodeAnalysis.CodeFixes.FixSomeCodeAction : CodeAction {
    private static HashSet`1<string> s_predefinedCodeFixProviderNames;
    internal FixAllState FixAllState;
    private bool _showPreviewChangesDialog;
    internal FixSomeCodeAction(FixAllState fixAllState, bool showPreviewChangesDialog);
    private static FixSomeCodeAction();
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.CodeFixes.FixSomeCodeAction/<ComputeOperationsAsync>d__4")]
protected virtual Task`1<IEnumerable`1<CodeActionOperation>> ComputeOperationsAsync(CancellationToken cancellationToken);
    internal virtual Task`1<ImmutableArray`1<CodeActionOperation>> ComputeOperationsAsync(IProgressTracker progressTracker, CancellationToken cancellationToken);
    internal sealed virtual Task`1<Solution> GetChangedSolutionAsync(IProgressTracker progressTracker, CancellationToken cancellationToken);
    private static bool IsInternalCodeFixProvider(CodeFixProvider fixer);
    private static HashSet`1<string> GetPredefinedCodeFixProviderNames();
    internal TestAccessor GetTestAccessor();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal abstract class Microsoft.CodeAnalysis.CodeFixes.FullyQualify.AbstractFullyQualifyCodeFixProvider : CodeFixProvider {
    private static int MaxResults;
    private static int NamespaceWithNoErrorsWeight;
    private static int TypeWeight;
    private static int NamespaceWithErrorsWeight;
    protected bool IgnoreCase { get; }
    [NullableContextAttribute("2")]
public virtual FixAllProvider GetFixAllProvider();
    protected abstract virtual bool get_IgnoreCase();
    protected abstract virtual bool CanFullyQualify(Diagnostic diagnostic, SyntaxNode& node);
    protected abstract virtual Task`1<SyntaxNode> ReplaceNodeAsync(SyntaxNode node, string containerName, bool resultingSymbolIsType, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.CodeFixes.FullyQualify.AbstractFullyQualifyCodeFixProvider/<RegisterCodeFixesAsync>d__10")]
public sealed virtual Task RegisterCodeFixesAsync(CodeFixContext context);
    [IteratorStateMachineAttribute("Microsoft.CodeAnalysis.CodeFixes.FullyQualify.AbstractFullyQualifyCodeFixProvider/<CreateActions>d__11")]
private IEnumerable`1<CodeAction> CreateActions(Document document, SyntaxNode node, SemanticModel semanticModel, IEnumerable`1<SymbolResult> proposedContainers);
    private static string GetNodeName(Document document, SyntaxNode node);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.CodeFixes.FullyQualify.AbstractFullyQualifyCodeFixProvider/<ProcessNodeAsync>d__13")]
private Task`1<Document> ProcessNodeAsync(Document document, SyntaxNode node, string containerName, INamespaceOrTypeSymbol originalSymbol, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.CodeFixes.FullyQualify.AbstractFullyQualifyCodeFixProvider/<GetMatchingTypesAsync>d__14")]
private Task`1<ImmutableArray`1<SymbolResult>> GetMatchingTypesAsync(Project project, SemanticModel semanticModel, SyntaxNode node, CancellationToken cancellationToken);
    private static bool IsValidNamedTypeSearchResult(SemanticModel semanticModel, int arity, bool inAttributeContext, bool looksGeneric, INamedTypeSymbol searchResult);
    private static bool HasValidContainer(ISymbol symbol);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.CodeFixes.FullyQualify.AbstractFullyQualifyCodeFixProvider/<GetMatchingNamespacesAsync>d__17")]
private Task`1<ImmutableArray`1<SymbolResult>> GetMatchingNamespacesAsync(Project project, SemanticModel semanticModel, SyntaxNode simpleName, CancellationToken cancellationToken);
    private bool BindsWithoutErrors(INamespaceSymbol ns, string rightName, bool isAttributeName);
    private static bool HasAccessibleTypes(INamespaceSymbol namespace, SemanticModel model, CancellationToken cancellationToken);
    [IteratorStateMachineAttribute("Microsoft.CodeAnalysis.CodeFixes.FullyQualify.AbstractFullyQualifyCodeFixProvider/<GetContainers>d__20")]
private static IEnumerable`1<SymbolResult> GetContainers(ImmutableArray`1<SymbolResult> symbols, Compilation compilation);
    private static IEnumerable`1<SymbolResult> FilterAndSort(IEnumerable`1<SymbolResult> symbols);
}
internal abstract class Microsoft.CodeAnalysis.CodeFixes.GenerateMember.AbstractGenerateMemberCodeFixProvider : CodeFixProvider {
    public virtual FixAllProvider GetFixAllProvider();
    protected abstract virtual Task`1<ImmutableArray`1<CodeAction>> GetCodeActionsAsync(Document document, SyntaxNode node, CancellationToken cancellationToken);
    protected abstract virtual bool IsCandidate(SyntaxNode node, SyntaxToken token, Diagnostic diagnostic);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.CodeFixes.GenerateMember.AbstractGenerateMemberCodeFixProvider/<RegisterCodeFixesAsync>d__3")]
public sealed virtual Task RegisterCodeFixesAsync(CodeFixContext context);
    protected virtual SyntaxNode GetTargetNode(SyntaxNode node);
    [IteratorStateMachineAttribute("Microsoft.CodeAnalysis.CodeFixes.GenerateMember.AbstractGenerateMemberCodeFixProvider/<GetTargetNodes>d__5")]
private IEnumerable`1<SyntaxNode> GetTargetNodes(ISyntaxFactsService syntaxFacts, SyntaxNode root, TextSpan span, Diagnostic diagnostic);
}
internal interface Microsoft.CodeAnalysis.CodeFixes.IAddSolutionItemService {
    public abstract virtual void TrackFilePathAndAddSolutionItemWhenFileCreated(string filePath);
    public abstract virtual Task AddSolutionItemAsync(string filePath, CancellationToken cancellationToken);
}
internal interface Microsoft.CodeAnalysis.CodeFixes.ICodeFixProviderFactory {
    public abstract virtual ImmutableArray`1<CodeFixProvider> GetFixers();
}
[NullableContextAttribute("1")]
internal interface Microsoft.CodeAnalysis.CodeFixes.ICodeFixService {
    public abstract virtual Task`1<ImmutableArray`1<CodeFixCollection>> GetFixesAsync(Document document, TextSpan textSpan, bool includeSuppressionFixes, bool isBlocking, CancellationToken cancellationToken);
    public abstract virtual Task`1<ImmutableArray`1<CodeFixCollection>> GetFixesAsync(Document document, TextSpan textSpan, bool includeSuppressionFixes, bool isBlocking, Func`2<string, IDisposable> addOperationScope, CancellationToken cancellationToken);
    public abstract virtual Task`1<ImmutableArray`1<CodeFixCollection>> GetFixesAsync(Document document, TextSpan textSpan, bool includeSuppressionFixes, CancellationToken cancellationToken);
    public abstract virtual Task`1<CodeFixCollection> GetDocumentFixAllForIdInSpanAsync(Document document, TextSpan textSpan, string diagnosticId, CancellationToken cancellationToken);
    public abstract virtual Task`1<Document> ApplyCodeFixesForSpecificDiagnosticIdAsync(Document document, string diagnosticId, IProgressTracker progressTracker, CancellationToken cancellationToken);
    public abstract virtual CodeFixProvider GetSuppressionFixer(string language, IEnumerable`1<string> diagnosticIds);
    public abstract virtual Task`1<FirstDiagnosticResult> GetMostSevereFixableDiagnosticAsync(Document document, TextSpan range, CancellationToken cancellationToken);
}
internal interface Microsoft.CodeAnalysis.CodeFixes.IFixAllGetFixesService {
    public abstract virtual Task`1<ImmutableArray`1<CodeActionOperation>> GetFixAllOperationsAsync(FixAllContext fixAllContext, bool showPreviewChangesDialog);
    public abstract virtual Task`1<Solution> GetFixAllChangedSolutionAsync(FixAllContext fixAllContext);
}
internal interface Microsoft.CodeAnalysis.CodeFixes.IFixMultipleOccurrencesService {
    public abstract virtual Solution GetFix(ImmutableDictionary`2<Document, ImmutableArray`1<Diagnostic>> diagnosticsToFix, Workspace workspace, CodeFixProvider fixProvider, FixAllProvider fixAllProvider, string equivalenceKey, string waitDialogTitle, string waitDialogMessage, CancellationToken cancellationToken);
    public abstract virtual Solution GetFix(ImmutableDictionary`2<Project, ImmutableArray`1<Diagnostic>> diagnosticsToFix, Workspace workspace, CodeFixProvider fixProvider, FixAllProvider fixAllProvider, string equivalenceKey, string waitDialogTitle, string waitDialogMessage, CancellationToken cancellationToken);
}
internal abstract class Microsoft.CodeAnalysis.CodeFixes.Iterator.AbstractIteratorCodeFixProvider : CodeFixProvider {
    public virtual FixAllProvider GetFixAllProvider();
    protected abstract virtual Task`1<CodeAction> GetCodeFixAsync(SyntaxNode root, SyntaxNode node, Document document, Diagnostic diagnostics, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.CodeFixes.Iterator.AbstractIteratorCodeFixProvider/<RegisterCodeFixesAsync>d__2")]
public sealed virtual Task RegisterCodeFixesAsync(CodeFixContext context);
    protected virtual bool TryGetNode(SyntaxNode root, TextSpan span, SyntaxNode& node);
}
[ExportCodeFixProviderAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.CodeFixes.NamingStyles.NamingStyleCodeFixProvider : CodeFixProvider {
    [CompilerGeneratedAttribute]
private ImmutableArray`1<string> <FixableDiagnosticIds>k__BackingField;
    public ImmutableArray`1<string> FixableDiagnosticIds { get; }
    [CompilerGeneratedAttribute]
public virtual ImmutableArray`1<string> get_FixableDiagnosticIds();
    public virtual FixAllProvider GetFixAllProvider();
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.CodeFixes.NamingStyles.NamingStyleCodeFixProvider/<RegisterCodeFixesAsync>d__5")]
public sealed virtual Task RegisterCodeFixesAsync(CodeFixContext context);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.CodeFixes.NamingStyles.NamingStyleCodeFixProvider/<FixAsync>d__6")]
private static Task`1<Solution> FixAsync(Document document, ISymbol symbol, string fixedName, CancellationToken cancellationToken);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal static class Microsoft.CodeAnalysis.CodeFixes.PredefinedCodeFixProviderNames : object {
    public static string AddDocCommentNodes;
    public static string AddAsync;
    public static string AddParameter;
    public static string AddParenthesesAroundConditionalExpressionInInterpolatedString;
    public static string AliasAmbiguousType;
    public static string ApplyNamingStyle;
    public static string AddBraces;
    public static string ChangeReturnType;
    public static string ChangeToYield;
    public static string ConfigureCodeStyleOption;
    public static string ConfigureSeverity;
    public static string ConvertToAsync;
    public static string ConvertToIterator;
    public static string CorrectNextControlVariable;
    public static string ConvertTypeOfToNameOf;
    public static string RemoveDocCommentNode;
    public static string AddMissingReference;
    public static string AddImport;
    public static string FullyQualify;
    public static string FixFormatting;
    public static string FixIncorrectFunctionReturnType;
    public static string FixIncorrectExitContinue;
    public static string FixReturnType;
    public static string GenerateConstructor;
    public static string GenerateEndConstruct;
    public static string GenerateEnumMember;
    public static string GenerateEvent;
    public static string GenerateVariable;
    public static string GenerateMethod;
    public static string GenerateConversion;
    public static string GenerateDeconstructMethod;
    public static string GenerateType;
    public static string ImplementAbstractClass;
    public static string ImplementInterface;
    public static string MakeFieldReadonly;
    public static string MakeStatementAsynchronous;
    public static string MakeMethodSynchronous;
    public static string MoveMisplacedUsingDirectives;
    public static string MoveToTopOfFile;
    public static string PopulateSwitch;
    public static string QualifyMemberAccess;
    public static string ReplaceDefaultLiteral;
    public static string RemoveUnnecessaryCast;
    public static string DeclareAsNullable;
    public static string RemoveAsyncModifier;
    public static string RemoveUnnecessaryImports;
    public static string RemoveUnnecessaryAttributeSuppressions;
    public static string RemoveUnnecessaryPragmaSuppressions;
    public static string RemoveUnreachableCode;
    public static string RemoveUnusedValues;
    public static string RemoveUnusedLocalFunction;
    public static string RemoveUnusedMembers;
    public static string RemoveUnusedVariable;
    public static string SimplifyNames;
    public static string SimplifyThisOrMe;
    public static string SpellCheck;
    public static string Suppression;
    public static string AddOverloads;
    public static string AddNew;
    public static string RemoveNew;
    public static string UpdateLegacySuppressions;
    public static string UnsealClass;
    public static string UseImplicitType;
    public static string UseExplicitType;
    public static string UseExplicitTypeForConst;
    public static string UseCollectionInitializer;
    public static string UseObjectInitializer;
    public static string UseThrowExpression;
    public static string PreferFrameworkType;
    public static string MakeStructFieldsWritable;
    public static string AddExplicitCast;
    public static string RemoveIn;
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal abstract class Microsoft.CodeAnalysis.CodeFixes.Suppression.AbstractSuppressionBatchFixAllProvider : FixAllProvider {
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private static Func`2<DocumentId, ConcurrentBag`1<ValueTuple`2<CodeAction, Document>>> s_getValue;
    private static AbstractSuppressionBatchFixAllProvider();
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.CodeFixes.Suppression.AbstractSuppressionBatchFixAllProvider/<GetFixAsync>d__1")]
public virtual Task`1<CodeAction> GetFixAsync(FixAllContext fixAllContext);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.CodeFixes.Suppression.AbstractSuppressionBatchFixAllProvider/<GetFixAsync>d__2")]
private Task`1<CodeAction> GetFixAsync(ImmutableDictionary`2<Document, ImmutableArray`1<Diagnostic>> documentsAndDiagnosticsToFixMap, FixAllContext fixAllContext);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.CodeFixes.Suppression.AbstractSuppressionBatchFixAllProvider/<GetDiagnosticsAndCodeActionsAsync>d__3")]
private Task`1<ImmutableArray`1<ValueTuple`2<Diagnostic, CodeAction>>> GetDiagnosticsAndCodeActionsAsync(ImmutableDictionary`2<Document, ImmutableArray`1<Diagnostic>> documentsAndDiagnosticsToFixMap, FixAllContext fixAllContext);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.CodeFixes.Suppression.AbstractSuppressionBatchFixAllProvider/<AddDocumentFixesAsync>d__4")]
private Task AddDocumentFixesAsync(Document document, ImmutableArray`1<Diagnostic> diagnostics, ConcurrentBag`1<ValueTuple`2<Diagnostic, CodeAction>> fixes, FixAllState fixAllState, IProgressTracker progressTracker, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.CodeFixes.Suppression.AbstractSuppressionBatchFixAllProvider/<AddDocumentFixesAsync>d__5")]
protected virtual Task AddDocumentFixesAsync(Document document, ImmutableArray`1<Diagnostic> diagnostics, ConcurrentBag`1<ValueTuple`2<Diagnostic, CodeAction>> fixes, FixAllState fixAllState, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.CodeFixes.Suppression.AbstractSuppressionBatchFixAllProvider/<GetFixAsync>d__6")]
private Task`1<CodeAction> GetFixAsync(ImmutableDictionary`2<Project, ImmutableArray`1<Diagnostic>> projectsAndDiagnosticsToFixMap, FixAllContext fixAllContext);
    private static Action`2<CodeAction, ImmutableArray`1<Diagnostic>> GetRegisterCodeFixAction(FixAllState fixAllState, ConcurrentBag`1<ValueTuple`2<Diagnostic, CodeAction>> result);
    protected virtual Task AddProjectFixesAsync(Project project, ImmutableArray`1<Diagnostic> diagnostics, ConcurrentBag`1<ValueTuple`2<Diagnostic, CodeAction>> fixes, FixAllState fixAllState, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.CodeFixes.Suppression.AbstractSuppressionBatchFixAllProvider/<TryGetMergedFixAsync>d__9")]
public virtual Task`1<CodeAction> TryGetMergedFixAsync(ImmutableArray`1<ValueTuple`2<Diagnostic, CodeAction>> batchOfFixes, FixAllState fixAllState, CancellationToken cancellationToken);
    public virtual string GetFixAllTitle(FixAllState fixAllState);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.CodeFixes.Suppression.AbstractSuppressionBatchFixAllProvider/<TryMergeFixesAsync>d__11")]
public virtual Task`1<Solution> TryMergeFixesAsync(Solution oldSolution, ImmutableArray`1<ValueTuple`2<Diagnostic, CodeAction>> diagnosticsAndCodeActions, FixAllState fixAllState, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.CodeFixes.Suppression.AbstractSuppressionBatchFixAllProvider/<GetDocumentIdToChangedDocumentsAsync>d__12")]
private static Task`1<IReadOnlyDictionary`2<DocumentId, ConcurrentBag`1<ValueTuple`2<CodeAction, Document>>>> GetDocumentIdToChangedDocumentsAsync(Solution oldSolution, ImmutableArray`1<ValueTuple`2<Diagnostic, CodeAction>> diagnosticsAndCodeActions, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.CodeFixes.Suppression.AbstractSuppressionBatchFixAllProvider/<GetDocumentIdToFinalTextAsync>d__13")]
private static Task`1<IReadOnlyDictionary`2<DocumentId, SourceText>> GetDocumentIdToFinalTextAsync(Solution oldSolution, IReadOnlyDictionary`2<DocumentId, ConcurrentBag`1<ValueTuple`2<CodeAction, Document>>> documentIdToChangedDocuments, ImmutableArray`1<ValueTuple`2<Diagnostic, CodeAction>> diagnosticsAndCodeActions, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.CodeFixes.Suppression.AbstractSuppressionBatchFixAllProvider/<GetFinalDocumentTextAsync>d__14")]
private static Task GetFinalDocumentTextAsync(Solution oldSolution, Dictionary`2<CodeAction, int> codeActionToDiagnosticLocation, ConcurrentDictionary`2<DocumentId, SourceText> documentIdToFinalText, IEnumerable`1<ValueTuple`2<CodeAction, Document>> changedDocuments, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.CodeFixes.Suppression.AbstractSuppressionBatchFixAllProvider/<GetChangedDocumentsAsync>d__16")]
private static Task GetChangedDocumentsAsync(Solution oldSolution, ConcurrentDictionary`2<DocumentId, ConcurrentBag`1<ValueTuple`2<CodeAction, Document>>> documentIdToChangedDocuments, CodeAction codeAction, CancellationToken cancellationToken);
}
internal abstract class Microsoft.CodeAnalysis.CodeFixes.Suppression.AbstractSuppressionCodeFixProvider : object {
    public static string SuppressMessageAttributeName;
    private static string s_globalSuppressionsFileName;
    private static string s_suppressionsFileCommentTemplate;
    protected string DefaultFileExtension { get; }
    protected string SingleLineCommentStart { get; }
    protected string GlobalSuppressionsFileHeaderComment { get; }
    public sealed virtual FixAllProvider GetFixAllProvider();
    public sealed virtual bool IsFixableDiagnostic(Diagnostic diagnostic);
    protected abstract virtual SyntaxTriviaList CreatePragmaDisableDirectiveTrivia(Diagnostic diagnostic, Func`2<SyntaxNode, SyntaxNode> formatNode, bool needsLeadingEndOfLine, bool needsTrailingEndOfLine);
    protected abstract virtual SyntaxTriviaList CreatePragmaRestoreDirectiveTrivia(Diagnostic diagnostic, Func`2<SyntaxNode, SyntaxNode> formatNode, bool needsLeadingEndOfLine, bool needsTrailingEndOfLine);
    protected abstract virtual SyntaxNode AddGlobalSuppressMessageAttribute(SyntaxNode newRoot, ISymbol targetSymbol, INamedTypeSymbol suppressMessageAttribute, Diagnostic diagnostic, Workspace workspace, Compilation compilation, IAddImportsService addImportsService, CancellationToken cancellationToken);
    protected abstract virtual SyntaxNode AddLocalSuppressMessageAttribute(SyntaxNode targetNode, ISymbol targetSymbol, INamedTypeSymbol suppressMessageAttribute, Diagnostic diagnostic);
    protected abstract virtual string get_DefaultFileExtension();
    protected abstract virtual string get_SingleLineCommentStart();
    protected abstract virtual bool IsAttributeListWithAssemblyAttributes(SyntaxNode node);
    protected abstract virtual bool IsEndOfLine(SyntaxTrivia trivia);
    protected abstract virtual bool IsEndOfFileToken(SyntaxToken token);
    protected abstract virtual bool IsSingleAttributeInAttributeList(SyntaxNode attribute);
    protected abstract virtual bool IsAnyPragmaDirectiveForId(SyntaxTrivia trivia, string id, Boolean& enableDirective, Boolean& hasMultipleIds);
    protected abstract virtual SyntaxTrivia TogglePragmaDirective(SyntaxTrivia trivia);
    protected string get_GlobalSuppressionsFileHeaderComment();
    protected static string GetOrMapDiagnosticId(Diagnostic diagnostic, Boolean& includeTitle);
    protected virtual SyntaxToken GetAdjustedTokenForPragmaDisable(SyntaxToken token, SyntaxNode root, TextLineCollection lines, int indexOfLine);
    protected virtual SyntaxToken GetAdjustedTokenForPragmaRestore(SyntaxToken token, SyntaxNode root, TextLineCollection lines, int indexOfLine);
    public sealed virtual Task`1<ImmutableArray`1<CodeFix>> GetFixesAsync(Document document, TextSpan span, IEnumerable`1<Diagnostic> diagnostics, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.CodeFixes.Suppression.AbstractSuppressionCodeFixProvider/<GetPragmaSuppressionsAsync>d__28")]
internal Task`1<ImmutableArray`1<PragmaWarningCodeAction>> GetPragmaSuppressionsAsync(Document document, TextSpan span, IEnumerable`1<Diagnostic> diagnostics, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.CodeFixes.Suppression.AbstractSuppressionCodeFixProvider/<GetSuppressionsAsync>d__29")]
private Task`1<ImmutableArray`1<CodeFix>> GetSuppressionsAsync(Document document, TextSpan span, IEnumerable`1<Diagnostic> diagnostics, bool skipSuppressMessage, bool skipUnsuppress, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.CodeFixes.Suppression.AbstractSuppressionCodeFixProvider/<GetFixesAsync>d__30")]
public sealed virtual Task`1<ImmutableArray`1<CodeFix>> GetFixesAsync(Project project, IEnumerable`1<Diagnostic> diagnostics, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.CodeFixes.Suppression.AbstractSuppressionCodeFixProvider/<GetSuppressionsAsync>d__31")]
private Task`1<ImmutableArray`1<CodeFix>> GetSuppressionsAsync(Document documentOpt, Project project, IEnumerable`1<Diagnostic> diagnostics, SuppressionTargetInfo suppressionTargetInfo, bool skipSuppressMessage, bool skipUnsuppress, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.CodeFixes.Suppression.AbstractSuppressionCodeFixProvider/<GetSuppressionTargetInfoAsync>d__33")]
private Task`1<SuppressionTargetInfo> GetSuppressionTargetInfoAsync(Document document, TextSpan span, CancellationToken cancellationToken);
    internal SyntaxNode GetNodeWithTokens(SyntaxToken startToken, SyntaxToken endToken, SyntaxNode root);
    protected static string GetScopeString(SymbolKind targetSymbolKind);
    protected static string GetTargetString(ISymbol targetSymbol);
}
internal abstract class Microsoft.CodeAnalysis.CodeFixes.Suppression.NestedSuppressionCodeAction : CodeAction {
    [CompilerGeneratedAttribute]
private string <Title>k__BackingField;
    internal CodeActionPriority Priority { get; }
    public string Title { get; }
    protected string DiagnosticIdForEquivalenceKey { get; }
    public string EquivalenceKey { get; }
    protected NestedSuppressionCodeAction(string title);
    internal virtual CodeActionPriority get_Priority();
    [CompilerGeneratedAttribute]
public sealed virtual string get_Title();
    protected abstract virtual string get_DiagnosticIdForEquivalenceKey();
    public virtual string get_EquivalenceKey();
    public static bool IsEquivalenceKeyForGlobalSuppression(string equivalenceKey);
    public static bool IsEquivalenceKeyForPragmaWarning(string equivalenceKey);
    public static bool IsEquivalenceKeyForRemoveSuppression(string equivalenceKey);
    public static bool IsEquivalenceKeyForLocalSuppression(string equivalenceKey);
}
internal static class Microsoft.CodeAnalysis.CodeFixes.Suppression.SuppressionHelpers : object {
    private static string SynthesizedExternalSourceDiagnosticTag;
    public static ImmutableArray`1<string> SynthesizedExternalSourceDiagnosticCustomTags;
    private static SuppressionHelpers();
    public static bool CanBeSuppressed(Diagnostic diagnostic);
    public static bool CanBeSuppressedWithAttribute(Diagnostic diagnostic);
    public static bool CanBeUnsuppressed(Diagnostic diagnostic);
    private static bool CanBeSuppressedOrUnsuppressed(Diagnostic diagnostic, bool checkCanBeSuppressed);
    public static bool IsNotConfigurableDiagnostic(DiagnosticData diagnostic);
    public static bool IsNotConfigurableDiagnostic(Diagnostic diagnostic);
    public static bool IsCompilerDiagnostic(DiagnosticData diagnostic);
    public static bool IsCompilerDiagnostic(Diagnostic diagnostic);
    public static bool IsSynthesizedExternalSourceDiagnostic(DiagnosticData diagnostic);
    public static bool IsSynthesizedExternalSourceDiagnostic(Diagnostic diagnostic);
    public static bool HasCustomTag(IEnumerable`1<string> customTags, string tagToFind);
}
internal class Microsoft.CodeAnalysis.CodeFixes.Suppression.TopLevelSuppressionCodeAction : AbstractConfigurationActionWithNestedActions {
    public TopLevelSuppressionCodeAction(Diagnostic diagnostic, ImmutableArray`1<NestedSuppressionCodeAction> nestedActions);
}
internal class Microsoft.CodeAnalysis.CodeFixes.Suppression.WrapperCodeFixProvider : CodeFixProvider {
    private ImmutableArray`1<string> _originalDiagnosticIds;
    private IConfigurationFixProvider _suppressionFixProvider;
    public IConfigurationFixProvider SuppressionFixProvider { get; }
    public ImmutableArray`1<string> FixableDiagnosticIds { get; }
    public WrapperCodeFixProvider(IConfigurationFixProvider suppressionFixProvider, IEnumerable`1<string> diagnosticIds);
    public IConfigurationFixProvider get_SuppressionFixProvider();
    public virtual ImmutableArray`1<string> get_FixableDiagnosticIds();
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.CodeFixes.Suppression.WrapperCodeFixProvider/<RegisterCodeFixesAsync>d__7")]
public virtual Task RegisterCodeFixesAsync(CodeFixContext context);
    private static void RegisterSuppressionFixes(CodeFixContext context, ImmutableArray`1<CodeFix> suppressionFixes);
    public virtual FixAllProvider GetFixAllProvider();
}
internal static class Microsoft.CodeAnalysis.CodeFixesResources : object {
    private static ResourceManager s_resourceManager;
    [CompilerGeneratedAttribute]
private static CultureInfo <Culture>k__BackingField;
    internal static ResourceManager ResourceManager { get; }
    internal static CultureInfo Culture { get; internal set; }
    internal static string Add_file_header { get; }
    internal static string Fix_Name_Violation_colon_0 { get; }
    internal static string Add_both { get; }
    internal static string Add_default_case { get; }
    internal static string Use_discarded_local { get; }
    internal static string Use_discard_underscore { get; }
    internal static string Remove_redundant_assignment { get; }
    internal static string Update_suppression_format { get; }
    internal static string Suppress_or_Configure_issues { get; }
    internal static string Fix_all_occurrences_in { get; }
    internal static ResourceManager get_ResourceManager();
    [CompilerGeneratedAttribute]
internal static CultureInfo get_Culture();
    [CompilerGeneratedAttribute]
internal static void set_Culture(CultureInfo value);
    internal static string GetResourceString(string resourceKey, string defaultValue);
    internal static string get_Add_file_header();
    internal static string get_Fix_Name_Violation_colon_0();
    internal static string get_Add_both();
    internal static string get_Add_default_case();
    internal static string get_Use_discarded_local();
    internal static string get_Use_discard_underscore();
    internal static string get_Remove_redundant_assignment();
    internal static string get_Update_suppression_format();
    internal static string get_Suppress_or_Configure_issues();
    internal static string get_Fix_all_occurrences_in();
}
internal class Microsoft.CodeAnalysis.CodeLens.CodeLensFindReferencesProgress : object {
    private CancellationTokenSource _aggregateCancellationTokenSource;
    private SyntaxNode _queriedNode;
    private ISymbol _queriedSymbol;
    private ConcurrentSet`1<Location> _locations;
    [CompilerGeneratedAttribute]
private int <SearchCap>k__BackingField;
    public int SearchCap { get; }
    public CancellationToken CancellationToken { get; }
    public bool SearchCapReached { get; }
    public int ReferencesCount { get; }
    public ImmutableArray`1<Location> Locations { get; }
    public CodeLensFindReferencesProgress(ISymbol queriedDefinition, SyntaxNode queriedNode, int searchCap, CancellationToken cancellationToken);
    [CompilerGeneratedAttribute]
public int get_SearchCap();
    public CancellationToken get_CancellationToken();
    public bool get_SearchCapReached();
    public int get_ReferencesCount();
    public ImmutableArray`1<Location> get_Locations();
    public sealed virtual void OnStarted();
    public sealed virtual void OnCompleted();
    public sealed virtual void OnFindInDocumentStarted(Document document);
    public sealed virtual void OnFindInDocumentCompleted(Document document);
    private static bool FilterDefinition(ISymbol definition);
    private IEnumerable`1<Location> GetPartialLocations(ISymbol symbol, CancellationToken cancellationToken);
    public sealed virtual void OnDefinitionFound(ISymbol symbol);
    private bool FilterReference(ISymbol definition, ReferenceLocation reference);
    public sealed virtual void OnReferenceFound(ISymbol symbol, ReferenceLocation location);
    public sealed virtual void ReportProgress(int current, int maximum);
    public sealed virtual void Dispose();
}
internal class Microsoft.CodeAnalysis.CodeLens.CodeLensReferencesService : object {
    private static SymbolDisplayFormat MethodDisplayFormat;
    private static CodeLensReferencesService();
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.CodeLens.CodeLensReferencesService/<FindAsync>d__1`1")]
private static Task`1<Nullable`1<T>> FindAsync(Solution solution, DocumentId documentId, SyntaxNode syntaxNode, Func`2<CodeLensFindReferencesProgress, Task`1<T>> onResults, Func`2<CodeLensFindReferencesProgress, Task`1<T>> onCapped, int searchCap, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.CodeLens.CodeLensReferencesService/<GetProjectCodeLensVersionAsync>d__2")]
public sealed virtual ValueTask`1<VersionStamp> GetProjectCodeLensVersionAsync(Solution solution, ProjectId projectId, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.CodeLens.CodeLensReferencesService/<GetReferenceCountAsync>d__3")]
public sealed virtual Task`1<Nullable`1<ReferenceCount>> GetReferenceCountAsync(Solution solution, DocumentId documentId, SyntaxNode syntaxNode, int maxSearchResults, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.CodeLens.CodeLensReferencesService/<GetDescriptorOfEnclosingSymbolAsync>d__4")]
private static Task`1<ReferenceLocationDescriptor> GetDescriptorOfEnclosingSymbolAsync(Solution solution, Location location, CancellationToken cancellationToken);
    private static SyntaxNode GetEnclosingCodeElementNode(Document document, SyntaxToken token, ICodeLensDisplayInfoService langServices, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.CodeLens.CodeLensReferencesService/<FindReferenceLocationsAsync>d__6")]
public sealed virtual Task`1<Nullable`1<ImmutableArray`1<ReferenceLocationDescriptor>>> FindReferenceLocationsAsync(Solution solution, DocumentId documentId, SyntaxNode syntaxNode, CancellationToken cancellationToken);
    private static ISymbol GetEnclosingMethod(SemanticModel semanticModel, Location location, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.CodeLens.CodeLensReferencesService/<TryGetMethodDescriptorAsync>d__8")]
private static Task`1<ReferenceMethodDescriptor> TryGetMethodDescriptorAsync(Location commonLocation, Solution solution, CancellationToken cancellationToken);
    public sealed virtual Task`1<Nullable`1<ImmutableArray`1<ReferenceMethodDescriptor>>> FindReferenceMethodsAsync(Solution solution, DocumentId documentId, SyntaxNode syntaxNode, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.CodeLens.CodeLensReferencesService/<GetFullyQualifiedNameAsync>d__10")]
public sealed virtual Task`1<string> GetFullyQualifiedNameAsync(Solution solution, DocumentId documentId, SyntaxNode syntaxNode, CancellationToken cancellationToken);
}
[ExportWorkspaceServiceFactoryAttribute("Microsoft.CodeAnalysis.CodeLens.ICodeLensReferencesService", "Default")]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.CodeLens.CodeLensReferencesServiceFactory : object {
    public static ICodeLensReferencesService Instance;
    private static CodeLensReferencesServiceFactory();
    public sealed virtual IWorkspaceService CreateService(HostWorkspaceServices workspaceServices);
}
internal interface Microsoft.CodeAnalysis.CodeLens.ICodeLensDisplayInfoService {
    public abstract virtual SyntaxNode GetDisplayNode(SyntaxNode node);
    public abstract virtual string GetDisplayName(SemanticModel semanticModel, SyntaxNode node);
}
[NullableContextAttribute("1")]
internal interface Microsoft.CodeAnalysis.CodeLens.ICodeLensReferencesService {
    public abstract virtual ValueTask`1<VersionStamp> GetProjectCodeLensVersionAsync(Solution solution, ProjectId projectId, CancellationToken cancellationToken);
    public abstract virtual Task`1<Nullable`1<ReferenceCount>> GetReferenceCountAsync(Solution solution, DocumentId documentId, SyntaxNode syntaxNode, int maxSearchResults, CancellationToken cancellationToken);
    public abstract virtual Task`1<Nullable`1<ImmutableArray`1<ReferenceLocationDescriptor>>> FindReferenceLocationsAsync(Solution solution, DocumentId documentId, SyntaxNode syntaxNode, CancellationToken cancellationToken);
    public abstract virtual Task`1<Nullable`1<ImmutableArray`1<ReferenceMethodDescriptor>>> FindReferenceMethodsAsync(Solution solution, DocumentId documentId, SyntaxNode syntaxNode, CancellationToken cancellationToken);
    public abstract virtual Task`1<string> GetFullyQualifiedNameAsync(Solution solution, DocumentId documentId, SyntaxNode syntaxNode, CancellationToken cancellationToken);
}
internal interface Microsoft.CodeAnalysis.CodeLens.IRemoteCodeLensReferencesService {
    public abstract virtual ValueTask`1<Nullable`1<ReferenceCount>> GetReferenceCountAsync(PinnedSolutionInfo solutionInfo, DocumentId documentId, TextSpan textSpan, int maxResultCount, CancellationToken cancellationToken);
    public abstract virtual ValueTask`1<Nullable`1<ImmutableArray`1<ReferenceLocationDescriptor>>> FindReferenceLocationsAsync(PinnedSolutionInfo solutionInfo, DocumentId documentId, TextSpan textSpan, CancellationToken cancellationToken);
    public abstract virtual ValueTask`1<Nullable`1<ImmutableArray`1<ReferenceMethodDescriptor>>> FindReferenceMethodsAsync(PinnedSolutionInfo solutionInfo, DocumentId documentId, TextSpan textSpan, CancellationToken cancellationToken);
    public abstract virtual ValueTask`1<string> GetFullyQualifiedNameAsync(PinnedSolutionInfo solutionInfo, DocumentId documentId, TextSpan textSpan, CancellationToken cancellationToken);
}
internal class Microsoft.CodeAnalysis.CodeLens.LocationComparer : object {
    [CompilerGeneratedAttribute]
private static LocationComparer <Instance>k__BackingField;
    public static LocationComparer Instance { get; }
    private static LocationComparer();
    [CompilerGeneratedAttribute]
public static LocationComparer get_Instance();
    public sealed virtual bool Equals(Location x, Location y);
    public sealed virtual int GetHashCode(Location obj);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[IsReadOnlyAttribute]
[DataContractAttribute]
internal class Microsoft.CodeAnalysis.CodeLens.ReferenceCount : ValueType {
    [CompilerGeneratedAttribute]
private int <Count>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsCapped>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Version>k__BackingField;
    [DataMemberAttribute]
public int Count { get; }
    [DataMemberAttribute]
public bool IsCapped { get; }
    [DataMemberAttribute]
public string Version { get; }
    public ReferenceCount(int count, bool isCapped, string version);
    [CompilerGeneratedAttribute]
public int get_Count();
    [CompilerGeneratedAttribute]
public bool get_IsCapped();
    [CompilerGeneratedAttribute]
public string get_Version();
    public static bool op_Equality(ReferenceCount left, ReferenceCount right);
    public static bool op_Inequality(ReferenceCount left, ReferenceCount right);
    [NullableContextAttribute("2")]
public virtual bool Equals(object obj);
    public sealed virtual bool Equals(ReferenceCount other);
    public virtual int GetHashCode();
}
[DataContractAttribute]
internal class Microsoft.CodeAnalysis.CodeLens.ReferenceLocationDescriptor : object {
    [CompilerGeneratedAttribute]
private string <LongDescription>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Language>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<Glyph> <Glyph>k__BackingField;
    [CompilerGeneratedAttribute]
private int <SpanStart>k__BackingField;
    [CompilerGeneratedAttribute]
private int <SpanLength>k__BackingField;
    [CompilerGeneratedAttribute]
private int <LineNumber>k__BackingField;
    [CompilerGeneratedAttribute]
private int <ColumnNumber>k__BackingField;
    [CompilerGeneratedAttribute]
private Guid <ProjectGuid>k__BackingField;
    [CompilerGeneratedAttribute]
private Guid <DocumentGuid>k__BackingField;
    [CompilerGeneratedAttribute]
private string <FilePath>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ReferenceLineText>k__BackingField;
    [CompilerGeneratedAttribute]
private int <ReferenceStart>k__BackingField;
    [CompilerGeneratedAttribute]
private int <ReferenceLength>k__BackingField;
    [CompilerGeneratedAttribute]
private string <BeforeReferenceText1>k__BackingField;
    [CompilerGeneratedAttribute]
private string <BeforeReferenceText2>k__BackingField;
    [CompilerGeneratedAttribute]
private string <AfterReferenceText1>k__BackingField;
    [CompilerGeneratedAttribute]
private string <AfterReferenceText2>k__BackingField;
    [DataMemberAttribute]
public string LongDescription { get; }
    [DataMemberAttribute]
public string Language { get; }
    [DataMemberAttribute]
public Nullable`1<Glyph> Glyph { get; }
    [DataMemberAttribute]
public int SpanStart { get; }
    [DataMemberAttribute]
public int SpanLength { get; }
    [DataMemberAttribute]
public int LineNumber { get; }
    [DataMemberAttribute]
public int ColumnNumber { get; }
    [DataMemberAttribute]
public Guid ProjectGuid { get; }
    [DataMemberAttribute]
public Guid DocumentGuid { get; }
    [DataMemberAttribute]
public string FilePath { get; }
    [DataMemberAttribute]
public string ReferenceLineText { get; }
    [DataMemberAttribute]
public int ReferenceStart { get; }
    [DataMemberAttribute]
public int ReferenceLength { get; }
    [DataMemberAttribute]
public string BeforeReferenceText1 { get; }
    [DataMemberAttribute]
public string BeforeReferenceText2 { get; }
    [DataMemberAttribute]
public string AfterReferenceText1 { get; }
    [DataMemberAttribute]
public string AfterReferenceText2 { get; }
    public ReferenceLocationDescriptor(string longDescription, string language, Nullable`1<Glyph> glyph, int spanStart, int spanLength, int lineNumber, int columnNumber, Guid projectGuid, Guid documentGuid, string filePath, string referenceLineText, int referenceStart, int referenceLength, string beforeReferenceText1, string beforeReferenceText2, string afterReferenceText1, string afterReferenceText2);
    [CompilerGeneratedAttribute]
public string get_LongDescription();
    [CompilerGeneratedAttribute]
public string get_Language();
    [CompilerGeneratedAttribute]
public Nullable`1<Glyph> get_Glyph();
    [CompilerGeneratedAttribute]
public int get_SpanStart();
    [CompilerGeneratedAttribute]
public int get_SpanLength();
    [CompilerGeneratedAttribute]
public int get_LineNumber();
    [CompilerGeneratedAttribute]
public int get_ColumnNumber();
    [CompilerGeneratedAttribute]
public Guid get_ProjectGuid();
    [CompilerGeneratedAttribute]
public Guid get_DocumentGuid();
    [CompilerGeneratedAttribute]
public string get_FilePath();
    [CompilerGeneratedAttribute]
public string get_ReferenceLineText();
    [CompilerGeneratedAttribute]
public int get_ReferenceStart();
    [CompilerGeneratedAttribute]
public int get_ReferenceLength();
    [CompilerGeneratedAttribute]
public string get_BeforeReferenceText1();
    [CompilerGeneratedAttribute]
public string get_BeforeReferenceText2();
    [CompilerGeneratedAttribute]
public string get_AfterReferenceText1();
    [CompilerGeneratedAttribute]
public string get_AfterReferenceText2();
}
[DataContractAttribute]
internal class Microsoft.CodeAnalysis.CodeLens.ReferenceMethodDescriptor : object {
    [CompilerGeneratedAttribute]
private string <FullName>k__BackingField;
    [CompilerGeneratedAttribute]
private string <FilePath>k__BackingField;
    [CompilerGeneratedAttribute]
private string <OutputFilePath>k__BackingField;
    [DataMemberAttribute]
public string FullName { get; private set; }
    [DataMemberAttribute]
public string FilePath { get; private set; }
    [DataMemberAttribute]
public string OutputFilePath { get; private set; }
    public ReferenceMethodDescriptor(string fullName, string filePath, string outputFilePath);
    [CompilerGeneratedAttribute]
public string get_FullName();
    [CompilerGeneratedAttribute]
private void set_FullName(string value);
    [CompilerGeneratedAttribute]
public string get_FilePath();
    [CompilerGeneratedAttribute]
private void set_FilePath(string value);
    [CompilerGeneratedAttribute]
public string get_OutputFilePath();
    [CompilerGeneratedAttribute]
private void set_OutputFilePath(string value);
}
internal abstract class Microsoft.CodeAnalysis.CodeQuality.AbstractCodeQualityDiagnosticAnalyzer : DiagnosticAnalyzer {
    private GeneratedCodeAnalysisFlags _generatedCodeAnalysisFlags;
    [CompilerGeneratedAttribute]
private ImmutableArray`1<DiagnosticDescriptor> <SupportedDiagnostics>k__BackingField;
    public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    protected AbstractCodeQualityDiagnosticAnalyzer(ImmutableArray`1<DiagnosticDescriptor> descriptors, GeneratedCodeAnalysisFlags generatedCodeAnalysisFlags);
    [CompilerGeneratedAttribute]
public sealed virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    public sealed virtual void Initialize(AnalysisContext context);
    protected abstract virtual void InitializeWorker(AnalysisContext context);
    public abstract virtual DiagnosticAnalyzerCategory GetAnalyzerCategory();
    public sealed virtual bool OpenFileOnly(OptionSet options);
    protected static DiagnosticDescriptor CreateDescriptor(string id, EnforceOnBuild enforceOnBuild, LocalizableString title, LocalizableString messageFormat, bool isUnnecessary, bool isEnabledByDefault, bool isConfigurable, LocalizableString description);
}
internal static class Microsoft.CodeAnalysis.CodeRefactoringHelpers : object {
    [NullableContextAttribute("2")]
public static bool IsNodeUnderselected(SyntaxNode node, TextSpan selection);
    [NullableContextAttribute("1")]
[AsyncStateMachineAttribute("Microsoft.CodeAnalysis.CodeRefactoringHelpers/<GetTrimmedTextSpanAsync>d__1")]
public static Task`1<TextSpan> GetTrimmedTextSpanAsync(Document document, TextSpan span, CancellationToken cancellationToken);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal abstract class Microsoft.CodeAnalysis.CodeRefactorings.AbstractRefactoringHelpersService`3 : object {
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.CodeRefactorings.AbstractRefactoringHelpersService`3/<GetRelevantNodesAsync>d__0`1")]
public sealed virtual Task`1<ImmutableArray`1<TSyntaxNode>> GetRelevantNodesAsync(Document document, TextSpan selectionRaw, CancellationToken cancellationToken);
    [NullableContextAttribute("0")]
private static bool IsWantedTypeExpressionLike();
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.CodeRefactorings.AbstractRefactoringHelpersService`3/<GetTokensToRightOrInToLeftAndUpdatedLocationAsync>d__2")]
private static Task`1<ValueTuple`3<SyntaxToken, SyntaxToken, int>> GetTokensToRightOrInToLeftAndUpdatedLocationAsync(Document document, SyntaxNode root, TextSpan selectionTrimmed, CancellationToken cancellationToken);
    private void AddNodesForTokenToLeft(ISyntaxFactsService syntaxFacts, ArrayBuilder`1<TSyntaxNode> relevantNodesBuilder, int location, SyntaxToken tokenToLeft, CancellationToken cancellationToken);
    private void AddNodesForTokenToRightOrIn(ISyntaxFactsService syntaxFacts, SyntaxNode root, ArrayBuilder`1<TSyntaxNode> relevantNodesBuilder, int location, SyntaxToken tokenToRightOrIn, CancellationToken cancellationToken);
    private void AddRelevantNodesForSelection(ISyntaxFactsService syntaxFacts, SyntaxNode root, TextSpan selectionTrimmed, ArrayBuilder`1<TSyntaxNode> relevantNodesBuilder, CancellationToken cancellationToken);
    [IteratorStateMachineAttribute("Microsoft.CodeAnalysis.CodeRefactorings.AbstractRefactoringHelpersService`3/<ExtractNodesSimple>d__6")]
protected virtual IEnumerable`1<SyntaxNode> ExtractNodesSimple(SyntaxNode node, ISyntaxFactsService syntaxFacts);
    [IteratorStateMachineAttribute("Microsoft.CodeAnalysis.CodeRefactorings.AbstractRefactoringHelpersService`3/<ExtractNodesInHeader>d__7")]
protected virtual IEnumerable`1<SyntaxNode> ExtractNodesInHeader(SyntaxNode root, int location, ISyntaxFactsService syntaxFacts);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.CodeRefactorings.AbstractRefactoringHelpersService`3/<AddNodesDeepInAsync>d__8`1")]
protected virtual Task AddNodesDeepInAsync(Document document, int position, ArrayBuilder`1<TSyntaxNode> relevantNodesBuilder, CancellationToken cancellationToken);
    private static void AddNonHiddenCorrectTypeNodes(IEnumerable`1<SyntaxNode> nodes, ArrayBuilder`1<TSyntaxNode> resultBuilder, CancellationToken cancellationToken);
    [CompilerGeneratedAttribute]
internal static bool <IsWantedTypeExpressionLike>g__IsAEqualOrSubclassOfB|1_0(Type a, Type b);
    [CompilerGeneratedAttribute]
internal static bool <GetTokensToRightOrInToLeftAndUpdatedLocationAsync>g__IsAcceptableLineDistanceAway|2_0(SourceText sourceText, SyntaxToken tokenOnLocation, int location);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal abstract class Microsoft.CodeAnalysis.CodeRefactorings.AddAwait.AbstractAddAwaitCodeRefactoringProvider`1 : CodeRefactoringProvider {
    protected abstract virtual string GetTitle();
    protected abstract virtual string GetTitleWithConfigureAwait();
    protected abstract virtual bool IsInAsyncContext(SyntaxNode node);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.CodeRefactorings.AddAwait.AbstractAddAwaitCodeRefactoringProvider`1/<ComputeRefactoringsAsync>d__3")]
public sealed virtual Task ComputeRefactoringsAsync(CodeRefactoringContext context);
    private static bool IsValidAwaitableExpression(SyntaxNode invocation, SemanticModel model, ISyntaxFactsService syntaxFacts);
    private static Task`1<Document> AddAwaitAsync(Document document, TExpressionSyntax expression, bool withConfigureAwait, CancellationToken cancellationToken);
}
internal class Microsoft.CodeAnalysis.CodeRefactorings.CodeRefactoring : object {
    [CompilerGeneratedAttribute]
private CodeRefactoringProvider <Provider>k__BackingField;
    [TupleElementNamesAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private ImmutableArray`1<ValueTuple`2<CodeAction, Nullable`1<TextSpan>>> <CodeActions>k__BackingField;
    public CodeRefactoringProvider Provider { get; }
    [TupleElementNamesAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ImmutableArray`1<ValueTuple`2<CodeAction, Nullable`1<TextSpan>>> CodeActions { get; }
    public CodeRefactoring(CodeRefactoringProvider provider, ImmutableArray`1<ValueTuple`2<CodeAction, Nullable`1<TextSpan>>> actions);
    [CompilerGeneratedAttribute]
public CodeRefactoringProvider get_Provider();
    [CompilerGeneratedAttribute]
public ImmutableArray`1<ValueTuple`2<CodeAction, Nullable`1<TextSpan>>> get_CodeActions();
}
[ExtensionAttribute]
internal static class Microsoft.CodeAnalysis.CodeRefactorings.CodeRefactoringContextExtensions : object {
    [ExtensionAttribute]
internal static void RegisterRefactorings(CodeRefactoringContext context, ImmutableArray`1<TCodeAction> actions, Nullable`1<TextSpan> applicableToSpan);
    [ExtensionAttribute]
internal static Task`1<TSyntaxNode> TryGetRelevantNodeAsync(CodeRefactoringContext context);
    [ExtensionAttribute]
internal static Task`1<ImmutableArray`1<TSyntaxNode>> GetRelevantNodesAsync(CodeRefactoringContext context);
    [NullableContextAttribute("1")]
[AsyncStateMachineAttribute("Microsoft.CodeAnalysis.CodeRefactorings.CodeRefactoringContextExtensions/<TryGetRelevantNodeAsync>d__3`1")]
[ExtensionAttribute]
internal static Task`1<TSyntaxNode> TryGetRelevantNodeAsync(Document document, TextSpan span, CancellationToken cancellationToken);
    [NullableContextAttribute("1")]
[ExtensionAttribute]
internal static Task`1<ImmutableArray`1<TSyntaxNode>> GetRelevantNodesAsync(Document document, TextSpan span, CancellationToken cancellationToken);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExportAttribute("Microsoft.CodeAnalysis.CodeRefactorings.ICodeRefactoringService")]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.CodeRefactorings.CodeRefactoringService : object {
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private Lazy`1<ImmutableDictionary`2<string, Lazy`1<ImmutableArray`1<CodeRefactoringProvider>>>> _lazyLanguageToProvidersMap;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private ConditionalWeakTable`2<IReadOnlyList`1<AnalyzerReference>, StrongBox`1<ImmutableArray`1<CodeRefactoringProvider>>> _projectRefactoringsMap;
    private ConditionalWeakTable`2<AnalyzerReference, ProjectCodeRefactoringProvider> _analyzerReferenceToRefactoringsMap;
    private CreateValueCallback<AnalyzerReference, ProjectCodeRefactoringProvider> _createProjectCodeRefactoringsProvider;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private ImmutableDictionary`2<string, Lazy`1<ImmutableArray`1<CodeRefactoringProvider>>> LanguageToProvidersMap { get; }
    [ImportingConstructorAttribute]
[ObsoleteAttribute("This exported object must be obtained through the MEF export provider.", "True")]
public CodeRefactoringService(IEnumerable`1<Lazy`2<CodeRefactoringProvider, CodeChangeProviderMetadata>> providers);
    [IteratorStateMachineAttribute("Microsoft.CodeAnalysis.CodeRefactorings.CodeRefactoringService/<DistributeLanguages>d__5")]
private static IEnumerable`1<Lazy`2<CodeRefactoringProvider, OrderableLanguageMetadata>> DistributeLanguages(IEnumerable`1<Lazy`2<CodeRefactoringProvider, CodeChangeProviderMetadata>> providers);
    private ImmutableDictionary`2<string, Lazy`1<ImmutableArray`1<CodeRefactoringProvider>>> get_LanguageToProvidersMap();
    private ConcatImmutableArray`1<CodeRefactoringProvider> GetProviders(Document document);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.CodeRefactorings.CodeRefactoringService/<HasRefactoringsAsync>d__9")]
public sealed virtual Task`1<bool> HasRefactoringsAsync(Document document, TextSpan state, CancellationToken cancellationToken);
    public sealed virtual Task`1<ImmutableArray`1<CodeRefactoring>> GetRefactoringsAsync(Document document, TextSpan state, CancellationToken cancellationToken);
    public sealed virtual Task`1<ImmutableArray`1<CodeRefactoring>> GetRefactoringsAsync(Document document, TextSpan state, bool isBlocking, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.CodeRefactorings.CodeRefactoringService/<GetRefactoringsAsync>d__12")]
public sealed virtual Task`1<ImmutableArray`1<CodeRefactoring>> GetRefactoringsAsync(Document document, TextSpan state, bool isBlocking, Func`2<string, IDisposable> addOperationScope, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.CodeRefactorings.CodeRefactoringService/<GetRefactoringFromProviderAsync>d__13")]
private static Task`1<CodeRefactoring> GetRefactoringFromProviderAsync(Document document, TextSpan state, CodeRefactoringProvider provider, IExtensionManager extensionManager, bool isBlocking, CancellationToken cancellationToken);
    private ImmutableArray`1<CodeRefactoringProvider> GetProjectRefactorings(Project project);
    [CompilerGeneratedAttribute]
private ImmutableArray`1<CodeRefactoringProvider> <GetProjectRefactorings>g__GetProjectRefactoringsSlow|14_0(Project project);
    [CompilerGeneratedAttribute]
private ImmutableArray`1<CodeRefactoringProvider> <GetProjectRefactorings>g__ComputeProjectRefactorings|14_1(Project project);
}
[ExportCodeRefactoringProviderAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.CodeRefactorings.ExtractMethod.ExtractMethodCodeRefactoringProvider : CodeRefactoringProvider {
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.CodeRefactorings.ExtractMethod.ExtractMethodCodeRefactoringProvider/<ComputeRefactoringsAsync>d__1")]
public virtual Task ComputeRefactoringsAsync(CodeRefactoringContext context);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.CodeRefactorings.ExtractMethod.ExtractMethodCodeRefactoringProvider/<GetCodeActionsAsync>d__2")]
private static Task`1<ImmutableArray`1<CodeAction>> GetCodeActionsAsync(Document document, TextSpan textSpan, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.CodeRefactorings.ExtractMethod.ExtractMethodCodeRefactoringProvider/<ExtractMethodAsync>d__3")]
private static Task`1<CodeAction> ExtractMethodAsync(Document document, TextSpan textSpan, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.CodeRefactorings.ExtractMethod.ExtractMethodCodeRefactoringProvider/<ExtractLocalFunctionAsync>d__4")]
private static Task`1<CodeAction> ExtractLocalFunctionAsync(Document document, TextSpan textSpan, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.CodeRefactorings.ExtractMethod.ExtractMethodCodeRefactoringProvider/<AddRenameAnnotationAsync>d__5")]
private static Task`1<Document> AddRenameAnnotationAsync(Document document, SyntaxToken invocationNameToken, CancellationToken cancellationToken);
}
internal interface Microsoft.CodeAnalysis.CodeRefactorings.ICodeRefactoringHelpersService {
    public bool ActiveInlineRenameSession { get; }
    public abstract virtual bool get_ActiveInlineRenameSession();
}
internal interface Microsoft.CodeAnalysis.CodeRefactorings.ICodeRefactoringProviderFactory {
    public abstract virtual ImmutableArray`1<CodeRefactoringProvider> GetRefactorings();
}
[NullableContextAttribute("1")]
internal interface Microsoft.CodeAnalysis.CodeRefactorings.ICodeRefactoringService {
    public abstract virtual Task`1<bool> HasRefactoringsAsync(Document document, TextSpan textSpan, CancellationToken cancellationToken);
    public abstract virtual Task`1<ImmutableArray`1<CodeRefactoring>> GetRefactoringsAsync(Document document, TextSpan textSpan, CancellationToken cancellationToken);
    public abstract virtual Task`1<ImmutableArray`1<CodeRefactoring>> GetRefactoringsAsync(Document document, TextSpan textSpan, bool isBlocking, CancellationToken cancellationToken);
    public abstract virtual Task`1<ImmutableArray`1<CodeRefactoring>> GetRefactoringsAsync(Document document, TextSpan textSpan, bool isBlocking, Func`2<string, IDisposable> addOperationScope, CancellationToken cancellationToken);
}
internal interface Microsoft.CodeAnalysis.CodeRefactorings.IRefactoringHelpersService {
    [NullableContextAttribute("1")]
public abstract virtual Task`1<ImmutableArray`1<TSyntaxNode>> GetRelevantNodesAsync(Document document, TextSpan selection, CancellationToken cancellationToken);
}
internal abstract class Microsoft.CodeAnalysis.CodeRefactorings.MoveType.AbstractMoveTypeService : object {
    public static SyntaxAnnotation NamespaceScopeMovedAnnotation;
    private static AbstractMoveTypeService();
    public abstract virtual Task`1<Solution> GetModifiedSolutionAsync(Document document, TextSpan textSpan, MoveTypeOperationKind operationKind, CancellationToken cancellationToken);
    public abstract virtual Task`1<ImmutableArray`1<CodeAction>> GetRefactoringAsync(Document document, TextSpan textSpan, CancellationToken cancellationToken);
}
internal abstract class Microsoft.CodeAnalysis.CodeRefactorings.MoveType.AbstractMoveTypeService`5 : AbstractMoveTypeService {
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.CodeRefactorings.MoveType.AbstractMoveTypeService`5/<GetRefactoringAsync>d__0")]
public virtual Task`1<ImmutableArray`1<CodeAction>> GetRefactoringAsync(Document document, TextSpan textSpan, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.CodeRefactorings.MoveType.AbstractMoveTypeService`5/<GetModifiedSolutionAsync>d__1")]
public virtual Task`1<Solution> GetModifiedSolutionAsync(Document document, TextSpan textSpan, MoveTypeOperationKind operationKind, CancellationToken cancellationToken);
    protected abstract virtual Task`1<TTypeDeclarationSyntax> GetRelevantNodeAsync(Document document, TextSpan textSpan, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.CodeRefactorings.MoveType.AbstractMoveTypeService`5/<CreateStateAsync>d__3")]
private Task`1<State<TService, TTypeDeclarationSyntax, TNamespaceDeclarationSyntax, TMemberDeclarationSyntax, TCompilationUnitSyntax>> CreateStateAsync(Document document, TextSpan textSpan, CancellationToken cancellationToken);
    private ImmutableArray`1<CodeAction> CreateActions(State<TService, TTypeDeclarationSyntax, TNamespaceDeclarationSyntax, TMemberDeclarationSyntax, TCompilationUnitSyntax> state, CancellationToken cancellationToken);
    private CodeAction GetCodeAction(State<TService, TTypeDeclarationSyntax, TNamespaceDeclarationSyntax, TMemberDeclarationSyntax, TCompilationUnitSyntax> state, string fileName, MoveTypeOperationKind operationKind);
    private static bool IsNestedType(TTypeDeclarationSyntax typeNode);
    private static bool MultipleTopLevelTypeDeclarationInSourceDocument(SyntaxNode root);
    private static IEnumerable`1<TTypeDeclarationSyntax> TopLevelTypeDeclarations(SyntaxNode root);
    private static bool AnyTopLevelTypeMatchesDocumentName(State<TService, TTypeDeclarationSyntax, TNamespaceDeclarationSyntax, TMemberDeclarationSyntax, TCompilationUnitSyntax> state, CancellationToken cancellationToken);
    protected static bool TypeMatchesDocumentName(TTypeDeclarationSyntax typeNode, string typeName, string documentNameWithoutExtension, SemanticModel semanticModel, CancellationToken cancellationToken);
    private static ImmutableArray`1<string> GetSuggestedFileNames(TTypeDeclarationSyntax typeNode, bool isNestedType, string typeName, string documentNameWithExtension, SemanticModel semanticModel, CancellationToken cancellationToken);
    private static IEnumerable`1<string> GetTypeNamePartsForNestedTypeNode(TTypeDeclarationSyntax typeNode, SemanticModel semanticModel, CancellationToken cancellationToken);
}
internal interface Microsoft.CodeAnalysis.CodeRefactorings.MoveType.IMoveTypeService {
    public abstract virtual Task`1<ImmutableArray`1<CodeAction>> GetRefactoringAsync(Document document, TextSpan textSpan, CancellationToken cancellationToken);
    public abstract virtual Task`1<Solution> GetModifiedSolutionAsync(Document document, TextSpan textSpan, MoveTypeOperationKind operationKind, CancellationToken cancellationToken);
}
[ExportCodeRefactoringProviderAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.CodeRefactorings.MoveType.MoveTypeCodeRefactoringProvider : CodeRefactoringProvider {
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.CodeRefactorings.MoveType.MoveTypeCodeRefactoringProvider/<ComputeRefactoringsAsync>d__1")]
public virtual Task ComputeRefactoringsAsync(CodeRefactoringContext context);
}
internal enum Microsoft.CodeAnalysis.CodeRefactorings.MoveType.MoveTypeOperationKind : Enum {
    public int value__;
    public static MoveTypeOperationKind MoveType;
    public static MoveTypeOperationKind MoveTypeNamespaceScope;
    public static MoveTypeOperationKind RenameType;
    public static MoveTypeOperationKind RenameFile;
}
internal static class Microsoft.CodeAnalysis.CodeRefactorings.PredefinedCodeRefactoringProviderNames : object {
    public static string AddAwait;
    public static string AddConstructorParametersFromMembers;
    public static string AddFileBanner;
    public static string AddMissingImports;
    public static string ChangeSignature;
    public static string ConvertAnonymousTypeToClass;
    public static string ConvertDirectCastToTryCast;
    public static string ConvertTryCastToDirectCast;
    public static string ConvertToInterpolatedString;
    public static string ConvertTupleToStruct;
    public static string EncapsulateField;
    public static string ExtractClass;
    public static string ExtractInterface;
    public static string ExtractMethod;
    public static string GenerateConstructorFromMembers;
    public static string GenerateDefaultConstructors;
    public static string GenerateEqualsAndGetHashCodeFromMembers;
    public static string GenerateOverrides;
    public static string InlineTemporary;
    public static string IntroduceUsingStatement;
    public static string IntroduceVariable;
    public static string InvertConditional;
    public static string InvertIf;
    public static string InvertLogical;
    public static string MergeConsecutiveIfStatements;
    public static string MergeNestedIfStatements;
    public static string MoveDeclarationNearReference;
    public static string MoveToNamespace;
    public static string MoveTypeToFile;
    public static string PullMemberUp;
    public static string InlineMethod;
    public static string ReplaceDocCommentTextWithTag;
    public static string SimplifyLambda;
    public static string SplitIntoConsecutiveIfStatements;
    public static string SplitIntoNestedIfStatements;
    public static string SyncNamespace;
    public static string UseExplicitType;
    public static string UseExpressionBody;
    public static string UseImplicitType;
    public static string Wrapping;
}
internal abstract class Microsoft.CodeAnalysis.CodeRefactorings.PullMemberUp.AbstractPullMemberUpRefactoringProvider : CodeRefactoringProvider {
    private IPullMemberUpOptionsService _service;
    protected AbstractPullMemberUpRefactoringProvider(IPullMemberUpOptionsService service);
    protected abstract virtual Task`1<SyntaxNode> GetSelectedNodeAsync(CodeRefactoringContext context);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.CodeRefactorings.PullMemberUp.AbstractPullMemberUpRefactoringProvider/<ComputeRefactoringsAsync>d__3")]
public virtual Task ComputeRefactoringsAsync(CodeRefactoringContext context);
    private static ImmutableArray`1<INamedTypeSymbol> FindAllValidDestinations(ISymbol selectedMember, Solution solution, CancellationToken cancellationToken);
}
internal interface Microsoft.CodeAnalysis.CodeRefactorings.PullMemberUp.Dialog.IPullMemberUpOptionsService {
    public abstract virtual PullMembersUpOptions GetPullMemberUpOptions(Document document, ISymbol selectedNodeSymbol);
}
internal static class Microsoft.CodeAnalysis.CodeRefactorings.PullMemberUp.MembersPuller : object {
    public static CodeAction TryComputeCodeAction(Document document, ISymbol selectedMember, INamedTypeSymbol destination);
    public static Task`1<Solution> PullMembersUpAsync(Document document, PullMembersUpOptions pullMembersUpOptions, CancellationToken cancellationToken);
    private static IMethodSymbol FilterOutNonPublicAccessor(IMethodSymbol getterOrSetter);
    private static IMethodSymbol MakePublicAccessor(IMethodSymbol getterOrSetter);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.CodeRefactorings.PullMemberUp.MembersPuller/<PullMembersIntoInterfaceAsync>d__4")]
private static Task`1<Solution> PullMembersIntoInterfaceAsync(Document document, PullMembersUpOptions pullMemberUpOptions, Solution solution, CancellationToken cancellationToken);
    private static ISymbol GetSymbolsToPullUp(MemberAnalysisResult analysisResult);
    private static void ChangeMemberToPublicAndNonStatic(ICodeGenerationService codeGenerationService, DocumentEditor editor, SyntaxNode memberDeclaration, ISymbol member);
    private static void ChangeEventToPublicAndNonStatic(ICodeGenerationService codeGenerationService, DocumentEditor editor, IEventSymbol eventSymbol, SyntaxNode eventDeclaration, DeclarationModifiers modifiers);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.CodeRefactorings.PullMemberUp.MembersPuller/<PullMembersIntoClassAsync>d__8")]
private static Task`1<Solution> PullMembersIntoClassAsync(Document document, PullMembersUpOptions result, Solution solution, CancellationToken cancellationToken);
    private static ISymbol MakeAbstractVersion(ISymbol member);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.CodeRefactorings.PullMemberUp.MembersPuller/<InitializeSymbolToDeclarationsMapAsync>d__10")]
private static Task`1<ImmutableDictionary`2<ISymbol, ImmutableArray`1<SyntaxNode>>> InitializeSymbolToDeclarationsMapAsync(PullMembersUpOptions result, CancellationToken cancellationToken);
    private static bool IsSelectedMemberDeclarationAlreadyInDestination(ISymbol selectedMember, INamedTypeSymbol destination);
    private static bool IsSelectedMemberDeclarationAlreadyInDestinationClass(ISymbol selectedMember, INamedTypeSymbol destination);
    private static bool IsSelectedMemberDeclarationAlreadyInDestinationInterface(ISymbol selectedMember, INamedTypeSymbol destination);
}
internal class Microsoft.CodeAnalysis.CodeRefactorings.PullMemberUp.PullMembersUpOptionsBuilder : object {
    public static PullMembersUpOptions BuildPullMembersUpOptions(INamedTypeSymbol destination, ImmutableArray`1<ValueTuple`2<ISymbol, bool>> members);
}
[ExportWorkspaceServiceFactoryAttribute("Microsoft.CodeAnalysis.CodeRefactorings.ICodeRefactoringHelpersService", "Default")]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.CodeRefactorings.ServicesLayerCodeActionHelpersService : object {
    public sealed virtual IWorkspaceService CreateService(HostWorkspaceServices workspaceServices);
}
internal abstract class Microsoft.CodeAnalysis.CodeRefactorings.SyncNamespace.AbstractSyncNamespaceCodeRefactoringProvider`3 : CodeRefactoringProvider {
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.CodeRefactorings.SyncNamespace.AbstractSyncNamespaceCodeRefactoringProvider`3/<ComputeRefactoringsAsync>d__0")]
public virtual Task ComputeRefactoringsAsync(CodeRefactoringContext context);
    protected abstract virtual Task`1<SyntaxNode> TryGetApplicableInvocationNodeAsync(Document document, TextSpan span, CancellationToken cancellationToken);
    protected abstract virtual string EscapeIdentifier(string identifier);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal abstract class Microsoft.CodeAnalysis.CodeStyle.AbstractBuiltInCodeStyleDiagnosticAnalyzer : DiagnosticAnalyzer {
    [NullableAttribute("2")]
protected string DescriptorId;
    protected DiagnosticDescriptor Descriptor;
    protected LocalizableString _localizableTitle;
    protected LocalizableString _localizableMessageFormat;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private ImmutableArray`1<DiagnosticDescriptor> <SupportedDiagnostics>k__BackingField;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    protected AbstractBuiltInCodeStyleDiagnosticAnalyzer(string diagnosticId, EnforceOnBuild enforceOnBuild, IPerLanguageOption option, LocalizableString title, LocalizableString messageFormat, bool isUnnecessary, bool configurable);
    protected AbstractBuiltInCodeStyleDiagnosticAnalyzer(string diagnosticId, EnforceOnBuild enforceOnBuild, ILanguageSpecificOption option, string language, LocalizableString title, LocalizableString messageFormat, bool isUnnecessary, bool configurable);
    protected AbstractBuiltInCodeStyleDiagnosticAnalyzer(string diagnosticId, EnforceOnBuild enforceOnBuild, ImmutableHashSet`1<IPerLanguageOption> options, LocalizableString title, LocalizableString messageFormat, bool isUnnecessary, bool configurable);
    protected AbstractBuiltInCodeStyleDiagnosticAnalyzer(string diagnosticId, EnforceOnBuild enforceOnBuild, ImmutableHashSet`1<ILanguageSpecificOption> options, string language, LocalizableString title, LocalizableString messageFormat, bool isUnnecessary, bool configurable);
    protected AbstractBuiltInCodeStyleDiagnosticAnalyzer(ImmutableDictionary`2<DiagnosticDescriptor, IPerLanguageOption> supportedDiagnosticsWithOptions);
    protected AbstractBuiltInCodeStyleDiagnosticAnalyzer(ImmutableDictionary`2<DiagnosticDescriptor, ILanguageSpecificOption> supportedDiagnosticsWithOptions, string language);
    protected AbstractBuiltInCodeStyleDiagnosticAnalyzer(ImmutableDictionary`2<DiagnosticDescriptor, ILanguageSpecificOption> supportedDiagnosticsWithLangaugeSpecificOptions, ImmutableDictionary`2<DiagnosticDescriptor, IPerLanguageOption> supportedDiagnosticsWithPerLanguageOptions, string language);
    private AbstractBuiltInCodeStyleDiagnosticAnalyzer(string descriptorId, EnforceOnBuild enforceOnBuild, LocalizableString title, LocalizableString messageFormat, bool isUnnecessary, bool configurable);
    protected AbstractBuiltInCodeStyleDiagnosticAnalyzer(ImmutableArray`1<DiagnosticDescriptor> supportedDiagnostics);
    private static void AddDiagnosticIdToOptionMapping(string diagnosticId, IPerLanguageOption option);
    private static void AddDiagnosticIdToOptionMapping(string diagnosticId, ILanguageSpecificOption option, string language);
    private static void AddDiagnosticIdToOptionMapping(string diagnosticId, ImmutableHashSet`1<IPerLanguageOption> options);
    private static void AddDiagnosticIdToOptionMapping(string diagnosticId, ImmutableHashSet`1<ILanguageSpecificOption> options, string language);
    public abstract virtual DiagnosticAnalyzerCategory GetAnalyzerCategory();
    public virtual bool OpenFileOnly(OptionSet options);
    [CompilerGeneratedAttribute]
public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    protected static DiagnosticDescriptor CreateDescriptorWithId(string id, EnforceOnBuild enforceOnBuild, LocalizableString title, LocalizableString messageFormat, bool isUnnecessary, bool isConfigurable, LocalizableString description);
    public sealed virtual void Initialize(AnalysisContext context);
    protected abstract virtual void InitializeWorker(AnalysisContext context);
}
internal abstract class Microsoft.CodeAnalysis.CodeStyle.AbstractCodeStyleProvider`2 : object {
    private Option2`1<CodeStyleOption2`1<TOptionKind>> _option;
    private string _language;
    private string _descriptorId;
    private EnforceOnBuild _enforceOnBuild;
    private LocalizableString _title;
    private LocalizableString _message;
    protected AbstractCodeStyleProvider`2(Option2`1<CodeStyleOption2`1<TOptionKind>> option, string language, string descriptorId, EnforceOnBuild enforceOnBuild, LocalizableString title, LocalizableString message);
    protected static ReportDiagnostic GetOptionSeverity(CodeStyleOption2`1<TOptionKind> optionValue);
    protected abstract virtual void DiagnosticAnalyzerInitialize(AnalysisContext<TOptionKind, TCodeStyleProvider> context);
    protected abstract virtual DiagnosticAnalyzerCategory GetAnalyzerCategory();
    protected DiagnosticDescriptor CreateDescriptorWithId(LocalizableString title, LocalizableString message);
    protected abstract virtual Task`1<ImmutableArray`1<CodeAction>> ComputeCodeActionsAsync(Document document, Diagnostic diagnostic, CancellationToken cancellationToken);
    protected abstract virtual Task FixAllAsync(Document document, ImmutableArray`1<Diagnostic> diagnostics, SyntaxEditor editor, CancellationToken cancellationToken);
    protected Task`1<Document> FixWithSyntaxEditorAsync(Document document, Diagnostic diagnostic, CancellationToken cancellationToken);
    protected abstract virtual Task`1<ImmutableArray`1<CodeAction>> ComputeAllRefactoringsWhenAnalyzerInactiveAsync(Document document, TextSpan span, CancellationToken cancellationToken);
    protected abstract virtual Task`1<ImmutableArray`1<CodeAction>> ComputeOpposingRefactoringsWhenAnalyzerActiveAsync(Document document, TextSpan span, TOptionKind option, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.CodeStyle.AbstractCodeStyleProvider`2/<RegisterCodeFixesAsync>d__18")]
private Task RegisterCodeFixesAsync(CodeFixContext context);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.CodeStyle.AbstractCodeStyleProvider`2/<ComputeRefactoringsAsync>d__20")]
private Task ComputeRefactoringsAsync(CodeRefactoringContext context);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.CodeStyle.AbstractCodeStyleProvider`2/<ComputeRefactoringsAsync>d__21")]
private Task ComputeRefactoringsAsync(CodeRefactoringContext context, TOptionKind option, bool analyzerActive);
}
internal enum Microsoft.CodeAnalysis.CodeStyle.EnforceOnBuild : Enum {
    public int value__;
    public static EnforceOnBuild Never;
    public static EnforceOnBuild WhenExplicitlyEnabled;
    public static EnforceOnBuild Recommended;
    public static EnforceOnBuild HighlyRecommended;
}
[ExtensionAttribute]
internal static class Microsoft.CodeAnalysis.CodeStyle.EnforceOnBuildExtensions : object {
    [NullableContextAttribute("1")]
[ExtensionAttribute]
public static string ToCustomTag(EnforceOnBuild enforceOnBuild);
}
internal static class Microsoft.CodeAnalysis.CodeStyle.FormattingAnalyzerHelper : object {
    internal static void AnalyzeSyntaxTree(SyntaxTreeAnalysisContext context, Workspace formatterState, DiagnosticDescriptor descriptor, OptionSet options);
}
internal abstract class Microsoft.CodeAnalysis.CommentSelection.AbstractCommentSelectionService : object {
    public string BlockCommentEndString { get; }
    public string BlockCommentStartString { get; }
    public string SingleLineCommentString { get; }
    public bool SupportsBlockComment { get; }
    public abstract virtual string get_BlockCommentEndString();
    public abstract virtual string get_BlockCommentStartString();
    public abstract virtual string get_SingleLineCommentString();
    public abstract virtual bool get_SupportsBlockComment();
    public sealed virtual Task`1<Document> FormatAsync(Document document, ImmutableArray`1<TextSpan> changes, CancellationToken cancellationToken);
    public sealed virtual Task`1<CommentSelectionInfo> GetInfoAsync(Document document, TextSpan textSpan, CancellationToken cancellationToken);
}
[IsReadOnlyAttribute]
internal class Microsoft.CodeAnalysis.CommentSelection.CommentSelectionInfo : ValueType {
    [CompilerGeneratedAttribute]
private bool <SupportsSingleLineComment>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <SupportsBlockComment>k__BackingField;
    [CompilerGeneratedAttribute]
private string <SingleLineCommentString>k__BackingField;
    [CompilerGeneratedAttribute]
private string <BlockCommentStartString>k__BackingField;
    [CompilerGeneratedAttribute]
private string <BlockCommentEndString>k__BackingField;
    public bool SupportsSingleLineComment { get; }
    public bool SupportsBlockComment { get; }
    public string SingleLineCommentString { get; }
    public string BlockCommentStartString { get; }
    public string BlockCommentEndString { get; }
    public CommentSelectionInfo(bool supportsSingleLineComment, bool supportsBlockComment, string singleLineCommentString, string blockCommentStartString, string blockCommentEndString);
    [CompilerGeneratedAttribute]
public bool get_SupportsSingleLineComment();
    [CompilerGeneratedAttribute]
public bool get_SupportsBlockComment();
    [CompilerGeneratedAttribute]
public string get_SingleLineCommentString();
    [CompilerGeneratedAttribute]
public string get_BlockCommentStartString();
    [CompilerGeneratedAttribute]
public string get_BlockCommentEndString();
}
internal interface Microsoft.CodeAnalysis.CommentSelection.ICommentSelectionService {
    public abstract virtual Task`1<CommentSelectionInfo> GetInfoAsync(Document document, TextSpan textSpan, CancellationToken cancellationToken);
    public abstract virtual Task`1<Document> FormatAsync(Document document, ImmutableArray`1<TextSpan> changes, CancellationToken cancellationToken);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.CodeAnalysis.Common.UpdatedEventArgs : EventArgs {
    [CompilerGeneratedAttribute]
private object <Id>k__BackingField;
    [CompilerGeneratedAttribute]
private Workspace <Workspace>k__BackingField;
    [NullableAttribute("2")]
[CompilerGeneratedAttribute]
private ProjectId <ProjectId>k__BackingField;
    [NullableAttribute("2")]
[CompilerGeneratedAttribute]
private DocumentId <DocumentId>k__BackingField;
    public object Id { get; }
    public Workspace Workspace { get; }
    [NullableAttribute("2")]
public ProjectId ProjectId { get; }
    [NullableAttribute("2")]
public DocumentId DocumentId { get; }
    public UpdatedEventArgs(object id, Workspace workspace, ProjectId projectId, DocumentId documentId);
    [CompilerGeneratedAttribute]
public object get_Id();
    [CompilerGeneratedAttribute]
public Workspace get_Workspace();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public ProjectId get_ProjectId();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public DocumentId get_DocumentId();
}
internal abstract class Microsoft.CodeAnalysis.Completion.AbstractDefaultArgumentProvider : ArgumentProvider {
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.CodeAnalysis.Completion.ArgumentContext : object {
    [CompilerGeneratedAttribute]
private ArgumentProvider <Provider>k__BackingField;
    [CompilerGeneratedAttribute]
private Document <Document>k__BackingField;
    [CompilerGeneratedAttribute]
private int <Position>k__BackingField;
    [CompilerGeneratedAttribute]
private IParameterSymbol <Parameter>k__BackingField;
    [NullableAttribute("2")]
[CompilerGeneratedAttribute]
private string <PreviousValue>k__BackingField;
    [CompilerGeneratedAttribute]
private CancellationToken <CancellationToken>k__BackingField;
    [NullableAttribute("2")]
[CompilerGeneratedAttribute]
private string <DefaultValue>k__BackingField;
    internal ArgumentProvider Provider { get; }
    public Document Document { get; }
    public int Position { get; }
    public IParameterSymbol Parameter { get; }
    [NullableAttribute("2")]
public string PreviousValue { get; }
    public CancellationToken CancellationToken { get; }
    [NullableAttribute("2")]
public string DefaultValue { get; public set; }
    public ArgumentContext(ArgumentProvider provider, Document document, int position, IParameterSymbol parameter, string previousValue, CancellationToken cancellationToken);
    [CompilerGeneratedAttribute]
internal ArgumentProvider get_Provider();
    [CompilerGeneratedAttribute]
public Document get_Document();
    [CompilerGeneratedAttribute]
public int get_Position();
    [CompilerGeneratedAttribute]
public IParameterSymbol get_Parameter();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public string get_PreviousValue();
    [CompilerGeneratedAttribute]
public CancellationToken get_CancellationToken();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public string get_DefaultValue();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public void set_DefaultValue(string value);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal abstract class Microsoft.CodeAnalysis.Completion.ArgumentProvider : object {
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    public string Name { get; }
    [CompilerGeneratedAttribute]
public string get_Name();
    public abstract virtual Task ProvideArgumentAsync(ArgumentContext context);
}
public enum Microsoft.CodeAnalysis.Completion.CharacterSetModificationKind : Enum {
    public int value__;
    public static CharacterSetModificationKind Add;
    public static CharacterSetModificationKind Remove;
    public static CharacterSetModificationKind Replace;
}
[IsReadOnlyAttribute]
public class Microsoft.CodeAnalysis.Completion.CharacterSetModificationRule : ValueType {
    [CompilerGeneratedAttribute]
private CharacterSetModificationKind <Kind>k__BackingField;
    [CompilerGeneratedAttribute]
private ImmutableArray`1<char> <Characters>k__BackingField;
    public CharacterSetModificationKind Kind { get; }
    public ImmutableArray`1<char> Characters { get; }
    private CharacterSetModificationRule(CharacterSetModificationKind kind, ImmutableArray`1<char> characters);
    [CompilerGeneratedAttribute]
public CharacterSetModificationKind get_Kind();
    [CompilerGeneratedAttribute]
public ImmutableArray`1<char> get_Characters();
    public static CharacterSetModificationRule Create(CharacterSetModificationKind kind, ImmutableArray`1<char> characters);
    public static CharacterSetModificationRule Create(CharacterSetModificationKind kind, Char[] characters);
}
internal static class Microsoft.CodeAnalysis.Completion.CommonCompletionItem : object {
    private static Char[] s_descriptionSeparators;
    private static CommonCompletionItem();
    public static CompletionItem Create(string displayText, string displayTextSuffix, CompletionItemRules rules, Nullable`1<Glyph> glyph, ImmutableArray`1<SymbolDisplayPart> description, string sortText, string filterText, bool showsWarningIcon, ImmutableDictionary`2<string, string> properties, ImmutableArray`1<string> tags, string inlineDescription);
    public static bool HasDescription(CompletionItem item);
    public static CompletionDescription GetDescription(CompletionItem item);
    private static string EncodeDescription(ImmutableArray`1<SymbolDisplayPart> description);
    private static string EncodeDescription(ImmutableArray`1<TaggedText> description);
    private static CompletionDescription DecodeDescription(string encoded);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal abstract class Microsoft.CodeAnalysis.Completion.CommonCompletionProvider : CompletionProvider {
    private static CompletionItemRules s_suggestionItemRules;
    private static CommonCompletionProvider();
    public virtual bool ShouldTriggerCompletion(SourceText text, int position, CompletionTrigger trigger, OptionSet options);
    public virtual bool IsInsertionTrigger(SourceText text, int insertedCharacterPosition, OptionSet options);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.Completion.CommonCompletionProvider/<GetDescriptionAsync>d__3")]
public virtual Task`1<CompletionDescription> GetDescriptionAsync(Document document, CompletionItem item, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.Completion.CommonCompletionProvider/<TryAddSnippetInvocationPartAsync>d__4")]
private Task`1<ImmutableArray`1<TaggedText>> TryAddSnippetInvocationPartAsync(Document document, CompletionItem item, ImmutableArray`1<TaggedText> parts, CancellationToken cancellationToken);
    protected virtual Task`1<CompletionDescription> GetDescriptionWorkerAsync(Document document, CompletionItem item, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.Completion.CommonCompletionProvider/<GetChangeAsync>d__6")]
public virtual Task`1<CompletionChange> GetChangeAsync(Document document, CompletionItem item, Nullable`1<char> commitKey, CancellationToken cancellationToken);
    public virtual Task`1<Nullable`1<TextChange>> GetTextChangeAsync(Document document, CompletionItem selectedItem, Nullable`1<char> ch, CancellationToken cancellationToken);
    protected virtual Task`1<Nullable`1<TextChange>> GetTextChangeAsync(CompletionItem selectedItem, Nullable`1<char> ch, CancellationToken cancellationToken);
    [NullableContextAttribute("2")]
protected static CompletionItem CreateSuggestionModeItem(string displayText, string description);
}
internal abstract class Microsoft.CodeAnalysis.Completion.CommonCompletionService : CompletionServiceWithProviders {
    protected CommonCompletionService(Workspace workspace);
    protected virtual CompletionItem GetBetterItem(CompletionItem item, CompletionItem existingItem);
    internal virtual Task`1<ValueTuple`2<CompletionList, bool>> GetCompletionsInternalAsync(Document document, int caretPosition, CompletionTrigger trigger, ImmutableHashSet`1<string> roles, OptionSet options, CancellationToken cancellationToken);
    protected static bool IsKeywordItem(CompletionItem item);
    protected static bool IsSnippetItem(CompletionItem item);
    internal virtual ImmutableArray`1<CompletionItem> FilterItems(Document document, ImmutableArray`1<ValueTuple`2<CompletionItem, Nullable`1<PatternMatch>>> itemsWithPatternMatch, string filterText);
}
internal static class Microsoft.CodeAnalysis.Completion.CommonCompletionUtilities : object {
    private static string NonBreakingSpaceString;
    public static TextSpan GetWordSpan(SourceText text, int position, Func`2<char, bool> isWordStartCharacter, Func`2<char, bool> isWordCharacter);
    public static TextSpan GetWordSpan(SourceText text, int position, Func`2<char, bool> isWordStartCharacter, Func`2<char, bool> isWordCharacter, bool alwaysExtendEndSpan);
    public static bool IsStartingNewWord(SourceText text, int characterPosition, Func`2<char, bool> isWordStartCharacter, Func`2<char, bool> isWordCharacter);
    public static Func`2<CancellationToken, Task`1<CompletionDescription>> CreateDescriptionFactory(Workspace workspace, SemanticModel semanticModel, int position, ISymbol symbol);
    public static Func`2<CancellationToken, Task`1<CompletionDescription>> CreateDescriptionFactory(Workspace workspace, SemanticModel semanticModel, int position, IReadOnlyList`1<ISymbol> symbols);
    public static Func`2<CancellationToken, Task`1<CompletionDescription>> CreateDescriptionFactory(Workspace workspace, SemanticModel semanticModel, int position, IReadOnlyList`1<ISymbol> symbols, SupportedPlatformData supportedPlatforms);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.Completion.CommonCompletionUtilities/<CreateDescriptionAsync>d__7")]
public static Task`1<CompletionDescription> CreateDescriptionAsync(Workspace workspace, SemanticModel semanticModel, int position, ISymbol symbol, int overloadCount, SupportedPlatformData supportedPlatforms, CancellationToken cancellationToken);
    public static Task`1<CompletionDescription> CreateDescriptionAsync(Workspace workspace, SemanticModel semanticModel, int position, IReadOnlyList`1<ISymbol> symbols, SupportedPlatformData supportedPlatforms, CancellationToken cancellationToken);
    private static void AddOverloadPart(List`1<TaggedText> textContentBuilder, int overloadCount, bool isGeneric);
    private static void AddDocumentationPart(List`1<TaggedText> textContentBuilder, ISymbol symbol, SemanticModel semanticModel, int position, IDocumentationCommentFormattingService formatter, CancellationToken cancellationToken);
    internal static bool IsTextualTriggerString(SourceText text, int characterPosition, string value);
    public static bool TryRemoveAttributeSuffix(ISymbol symbol, SyntaxContext context, String& name);
}
public class Microsoft.CodeAnalysis.Completion.CompletionChange : object {
    [CompilerGeneratedAttribute]
private TextChange <TextChange>k__BackingField;
    [CompilerGeneratedAttribute]
private ImmutableArray`1<TextChange> <TextChanges>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<int> <NewPosition>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IncludesCommitCharacter>k__BackingField;
    public TextChange TextChange { get; }
    [ObsoleteAttribute("Use TextChange instead", "True")]
public ImmutableArray`1<TextChange> TextChanges { get; }
    public Nullable`1<int> NewPosition { get; }
    public bool IncludesCommitCharacter { get; }
    private CompletionChange(ImmutableArray`1<TextChange> textChanges, Nullable`1<int> newPosition, bool includesCommitCharacter);
    private CompletionChange(TextChange textChange, Nullable`1<int> newPosition, bool includesCommitCharacter);
    [CompilerGeneratedAttribute]
public TextChange get_TextChange();
    [CompilerGeneratedAttribute]
public ImmutableArray`1<TextChange> get_TextChanges();
    [CompilerGeneratedAttribute]
public Nullable`1<int> get_NewPosition();
    [CompilerGeneratedAttribute]
public bool get_IncludesCommitCharacter();
    [ObsoleteAttribute("Use Create overload that only takes a single TextChange", "True")]
public static CompletionChange Create(ImmutableArray`1<TextChange> textChanges, Nullable`1<int> newPosition, bool includesCommitCharacter);
    public static CompletionChange Create(TextChange textChange, Nullable`1<int> newPosition, bool includesCommitCharacter);
    [ObsoleteAttribute("Use WithTextChange instead", "True")]
public CompletionChange WithTextChanges(ImmutableArray`1<TextChange> textChanges);
    public CompletionChange WithTextChange(TextChange textChange);
    public CompletionChange WithNewPosition(Nullable`1<int> newPostion);
    public CompletionChange WithIncludesCommitCharacter(bool includesCommitCharacter);
}
public class Microsoft.CodeAnalysis.Completion.CompletionContext : object {
    private List`1<CompletionItem> _items;
    [CompilerGeneratedAttribute]
private CompletionProvider <Provider>k__BackingField;
    [CompilerGeneratedAttribute]
private Document <Document>k__BackingField;
    [CompilerGeneratedAttribute]
private int <Position>k__BackingField;
    [CompilerGeneratedAttribute]
private TextSpan <DefaultItemSpan>k__BackingField;
    [CompilerGeneratedAttribute]
private TextSpan <CompletionListSpan>k__BackingField;
    [CompilerGeneratedAttribute]
private CompletionTrigger <Trigger>k__BackingField;
    [CompilerGeneratedAttribute]
private OptionSet <Options>k__BackingField;
    [CompilerGeneratedAttribute]
private CancellationToken <CancellationToken>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsExclusive>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <ExpandItemsAvailable>k__BackingField;
    private CompletionItem _suggestionModeItem;
    internal IReadOnlyList`1<CompletionItem> Items { get; }
    internal CompletionProvider Provider { get; }
    public Document Document { get; }
    public int Position { get; }
    [ObsoleteAttribute("Not used anymore. Use CompletionListSpan instead.", "True")]
public TextSpan DefaultItemSpan { get; }
    public TextSpan CompletionListSpan { get; public set; }
    public CompletionTrigger Trigger { get; }
    public OptionSet Options { get; }
    public CancellationToken CancellationToken { get; }
    public bool IsExclusive { get; public set; }
    internal bool ExpandItemsAvailable { get; internal set; }
    public CompletionItem SuggestionModeItem { get; public set; }
    public CompletionContext(CompletionProvider provider, Document document, int position, TextSpan defaultSpan, CompletionTrigger trigger, OptionSet options, CancellationToken cancellationToken);
    internal IReadOnlyList`1<CompletionItem> get_Items();
    [CompilerGeneratedAttribute]
internal CompletionProvider get_Provider();
    [CompilerGeneratedAttribute]
public Document get_Document();
    [CompilerGeneratedAttribute]
public int get_Position();
    [CompilerGeneratedAttribute]
public TextSpan get_DefaultItemSpan();
    [CompilerGeneratedAttribute]
public TextSpan get_CompletionListSpan();
    [CompilerGeneratedAttribute]
public void set_CompletionListSpan(TextSpan value);
    [CompilerGeneratedAttribute]
public CompletionTrigger get_Trigger();
    [CompilerGeneratedAttribute]
public OptionSet get_Options();
    [CompilerGeneratedAttribute]
public CancellationToken get_CancellationToken();
    [CompilerGeneratedAttribute]
public bool get_IsExclusive();
    [CompilerGeneratedAttribute]
public void set_IsExclusive(bool value);
    [CompilerGeneratedAttribute]
internal bool get_ExpandItemsAvailable();
    [CompilerGeneratedAttribute]
internal void set_ExpandItemsAvailable(bool value);
    public void AddItem(CompletionItem item);
    public void AddItems(IEnumerable`1<CompletionItem> items);
    public CompletionItem get_SuggestionModeItem();
    public void set_SuggestionModeItem(CompletionItem value);
    private CompletionItem FixItem(CompletionItem item);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal static class Microsoft.CodeAnalysis.Completion.CompletionControllerOptions : object {
    public static Option2`1<bool> FilterOutOfScopeLocals;
    public static Option2`1<bool> ShowXmlDocCommentCompletion;
    private static CompletionControllerOptions();
}
public class Microsoft.CodeAnalysis.Completion.CompletionDescription : object {
    public static CompletionDescription Empty;
    [CompilerGeneratedAttribute]
private ImmutableArray`1<TaggedText> <TaggedParts>k__BackingField;
    private string _text;
    public ImmutableArray`1<TaggedText> TaggedParts { get; }
    public string Text { get; }
    private CompletionDescription(ImmutableArray`1<TaggedText> taggedParts);
    private static CompletionDescription();
    [CompilerGeneratedAttribute]
public ImmutableArray`1<TaggedText> get_TaggedParts();
    public static CompletionDescription Create(ImmutableArray`1<TaggedText> taggedParts);
    public static CompletionDescription FromText(string text);
    public CompletionDescription WithTaggedParts(ImmutableArray`1<TaggedText> taggedParts);
    public string get_Text();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.CodeAnalysis.Completion.CompletionHelper : object {
    private object _gate;
    [TupleElementNamesAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private Dictionary`2<ValueTuple`3<string, CultureInfo, bool>, PatternMatcher> _patternMatcherMap;
    private static CultureInfo EnUSCultureInfo;
    private bool _isCaseSensitive;
    public CompletionHelper(bool isCaseSensitive);
    private static CompletionHelper();
    public static CompletionHelper GetHelper(Document document);
    public ImmutableArray`1<TextSpan> GetHighlightedSpans(string text, string pattern, CultureInfo culture);
    public bool MatchesPattern(string text, string pattern, CultureInfo culture);
    public Nullable`1<PatternMatch> GetMatch(string completionItemText, string pattern, bool includeMatchSpans, CultureInfo culture);
    private static Nullable`1<PatternMatch> AdjustMatchedSpans(PatternMatch value, int offset);
    private Nullable`1<PatternMatch> GetMatchWorker(string completionItemText, string pattern, CultureInfo culture, bool includeMatchSpans);
    private PatternMatcher GetPatternMatcher(string pattern, CultureInfo culture, bool includeMatchedSpans, Dictionary`2<ValueTuple`3<string, CultureInfo, bool>, PatternMatcher> map);
    private PatternMatcher GetPatternMatcher(string pattern, CultureInfo culture, bool includeMatchedSpans);
    public int CompareItems(CompletionItem item1, CompletionItem item2, string pattern, CultureInfo culture);
    public int CompareItems(CompletionItem item1, Nullable`1<PatternMatch> match1, CompletionItem item2, Nullable`1<PatternMatch> match2);
    private static bool TagsEqual(CompletionItem item1, CompletionItem item2);
    private static bool TagsEqual(ImmutableArray`1<string> tags1, ImmutableArray`1<string> tags2);
    private static bool IsKeywordItem(CompletionItem item);
    private int CompareMatches(PatternMatch match1, PatternMatch match2, CompletionItem item1, CompletionItem item2);
    private static int ComparePreselection(CompletionItem item1, CompletionItem item2);
    private static int CompareExpandedItem(CompletionItem item1, PatternMatch match1, CompletionItem item2, PatternMatch match2);
    public static string ConcatNamespace(string containingNamespace, string name);
}
[ExportWorkspaceServiceFactoryAttribute("Microsoft.CodeAnalysis.Completion.ICompletionHelperService", "Default")]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.Completion.CompletionHelperServiceFactory : object {
    public sealed virtual IWorkspaceService CreateService(HostWorkspaceServices workspaceServices);
}
[DebuggerDisplayAttribute("{DisplayText}")]
public class Microsoft.CodeAnalysis.Completion.CompletionItem : object {
    private string _filterText;
    [CompilerGeneratedAttribute]
private string <DisplayText>k__BackingField;
    [CompilerGeneratedAttribute]
private string <DisplayTextPrefix>k__BackingField;
    [CompilerGeneratedAttribute]
private string <DisplayTextSuffix>k__BackingField;
    [CompilerGeneratedAttribute]
private string <SortText>k__BackingField;
    [CompilerGeneratedAttribute]
private string <InlineDescription>k__BackingField;
    [CompilerGeneratedAttribute]
private TextSpan <Span>k__BackingField;
    [CompilerGeneratedAttribute]
private ImmutableDictionary`2<string, string> <Properties>k__BackingField;
    [CompilerGeneratedAttribute]
private ImmutableArray`1<string> <Tags>k__BackingField;
    [CompilerGeneratedAttribute]
private CompletionItemRules <Rules>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ProviderName>k__BackingField;
    [CompilerGeneratedAttribute]
private string <AutomationText>k__BackingField;
    [CompilerGeneratedAttribute]
private CompletionItemFlags <Flags>k__BackingField;
    private string _entireDisplayText;
    public string DisplayText { get; }
    public string DisplayTextPrefix { get; }
    public string DisplayTextSuffix { get; }
    public string FilterText { get; }
    internal bool HasDifferentFilterText { get; }
    public string SortText { get; }
    public string InlineDescription { get; }
    public TextSpan Span { get; internal set; }
    public ImmutableDictionary`2<string, string> Properties { get; }
    public ImmutableArray`1<string> Tags { get; }
    public CompletionItemRules Rules { get; }
    internal string ProviderName { get; internal set; }
    internal string AutomationText { get; internal set; }
    internal CompletionItemFlags Flags { get; internal set; }
    private CompletionItem(string displayText, string filterText, string sortText, TextSpan span, ImmutableDictionary`2<string, string> properties, ImmutableArray`1<string> tags, CompletionItemRules rules, string displayTextPrefix, string displayTextSuffix, string inlineDescription);
    [CompilerGeneratedAttribute]
public string get_DisplayText();
    [CompilerGeneratedAttribute]
public string get_DisplayTextPrefix();
    [CompilerGeneratedAttribute]
public string get_DisplayTextSuffix();
    public string get_FilterText();
    internal bool get_HasDifferentFilterText();
    [CompilerGeneratedAttribute]
public string get_SortText();
    [CompilerGeneratedAttribute]
public string get_InlineDescription();
    [CompilerGeneratedAttribute]
public TextSpan get_Span();
    [CompilerGeneratedAttribute]
internal void set_Span(TextSpan value);
    [CompilerGeneratedAttribute]
public ImmutableDictionary`2<string, string> get_Properties();
    [CompilerGeneratedAttribute]
public ImmutableArray`1<string> get_Tags();
    [CompilerGeneratedAttribute]
public CompletionItemRules get_Rules();
    [CompilerGeneratedAttribute]
internal string get_ProviderName();
    [CompilerGeneratedAttribute]
internal void set_ProviderName(string value);
    [CompilerGeneratedAttribute]
internal string get_AutomationText();
    [CompilerGeneratedAttribute]
internal void set_AutomationText(string value);
    [CompilerGeneratedAttribute]
internal CompletionItemFlags get_Flags();
    [CompilerGeneratedAttribute]
internal void set_Flags(CompletionItemFlags value);
    public static CompletionItem Create(string displayText, string filterText, string sortText, ImmutableDictionary`2<string, string> properties, ImmutableArray`1<string> tags, CompletionItemRules rules);
    public static CompletionItem Create(string displayText, string filterText, string sortText, ImmutableDictionary`2<string, string> properties, ImmutableArray`1<string> tags, CompletionItemRules rules, string displayTextPrefix, string displayTextSuffix);
    public static CompletionItem Create(string displayText, string filterText, string sortText, ImmutableDictionary`2<string, string> properties, ImmutableArray`1<string> tags, CompletionItemRules rules, string displayTextPrefix, string displayTextSuffix, string inlineDescription);
    [ObsoleteAttribute("Use the Create overload that does not take a span", "True")]
[EditorBrowsableAttribute("1")]
public static CompletionItem Create(string displayText, string filterText, string sortText, TextSpan span, ImmutableDictionary`2<string, string> properties, ImmutableArray`1<string> tags, CompletionItemRules rules);
    private CompletionItem With(Optional`1<TextSpan> span, Optional`1<string> displayText, Optional`1<string> filterText, Optional`1<string> sortText, Optional`1<ImmutableDictionary`2<string, string>> properties, Optional`1<ImmutableArray`1<string>> tags, Optional`1<CompletionItemRules> rules, Optional`1<string> displayTextPrefix, Optional`1<string> displayTextSuffix, Optional`1<string> inlineDescription);
    [ObsoleteAttribute("Not used anymore.  CompletionList.Span is used to control the span used for filtering.", "True")]
[EditorBrowsableAttribute("1")]
public CompletionItem WithSpan(TextSpan span);
    public CompletionItem WithDisplayText(string text);
    public CompletionItem WithDisplayTextPrefix(string displayTextPrefix);
    public CompletionItem WithDisplayTextSuffix(string displayTextSuffix);
    public CompletionItem WithFilterText(string text);
    public CompletionItem WithSortText(string text);
    public CompletionItem WithProperties(ImmutableDictionary`2<string, string> properties);
    public CompletionItem AddProperty(string name, string value);
    public CompletionItem WithTags(ImmutableArray`1<string> tags);
    public CompletionItem AddTag(string tag);
    public CompletionItem WithRules(CompletionItemRules rules);
    private sealed virtual override int System.IComparable<Microsoft.CodeAnalysis.Completion.CompletionItem>.CompareTo(CompletionItem other);
    internal string GetEntireDisplayText();
    public virtual string ToString();
}
[FlagsAttribute]
internal enum Microsoft.CodeAnalysis.Completion.CompletionItemFlags : Enum {
    public int value__;
    public static CompletionItemFlags None;
    public static CompletionItemFlags Cached;
    public static CompletionItemFlags Expanded;
    public static CompletionItemFlags CachedAndExpanded;
}
[ExtensionAttribute]
internal static class Microsoft.CodeAnalysis.Completion.CompletionItemFlagsExtensions : object {
    [ExtensionAttribute]
public static bool IsCached(CompletionItemFlags flags);
    [ExtensionAttribute]
public static bool IsExpanded(CompletionItemFlags flags);
}
public class Microsoft.CodeAnalysis.Completion.CompletionItemRules : object {
    public static CompletionItemRules Default;
    [CompilerGeneratedAttribute]
private ImmutableArray`1<CharacterSetModificationRule> <FilterCharacterRules>k__BackingField;
    [CompilerGeneratedAttribute]
private ImmutableArray`1<CharacterSetModificationRule> <CommitCharacterRules>k__BackingField;
    [CompilerGeneratedAttribute]
private EnterKeyRule <EnterKeyRule>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <FormatOnCommit>k__BackingField;
    [CompilerGeneratedAttribute]
private int <MatchPriority>k__BackingField;
    [CompilerGeneratedAttribute]
private CompletionItemSelectionBehavior <SelectionBehavior>k__BackingField;
    public ImmutableArray`1<CharacterSetModificationRule> FilterCharacterRules { get; }
    public ImmutableArray`1<CharacterSetModificationRule> CommitCharacterRules { get; }
    public EnterKeyRule EnterKeyRule { get; }
    public bool FormatOnCommit { get; }
    public int MatchPriority { get; }
    public CompletionItemSelectionBehavior SelectionBehavior { get; }
    private CompletionItemRules(ImmutableArray`1<CharacterSetModificationRule> filterCharacterRules, ImmutableArray`1<CharacterSetModificationRule> commitCharacterRules, EnterKeyRule enterKeyRule, bool formatOnCommit, int matchPriority, CompletionItemSelectionBehavior selectionBehavior);
    private static CompletionItemRules();
    [CompilerGeneratedAttribute]
public ImmutableArray`1<CharacterSetModificationRule> get_FilterCharacterRules();
    [CompilerGeneratedAttribute]
public ImmutableArray`1<CharacterSetModificationRule> get_CommitCharacterRules();
    [CompilerGeneratedAttribute]
public EnterKeyRule get_EnterKeyRule();
    [CompilerGeneratedAttribute]
public bool get_FormatOnCommit();
    [CompilerGeneratedAttribute]
public int get_MatchPriority();
    [CompilerGeneratedAttribute]
public CompletionItemSelectionBehavior get_SelectionBehavior();
    public static CompletionItemRules Create(ImmutableArray`1<CharacterSetModificationRule> filterCharacterRules, ImmutableArray`1<CharacterSetModificationRule> commitCharacterRules, EnterKeyRule enterKeyRule, bool formatOnCommit, Nullable`1<int> matchPriority);
    public static CompletionItemRules Create(ImmutableArray`1<CharacterSetModificationRule> filterCharacterRules, ImmutableArray`1<CharacterSetModificationRule> commitCharacterRules, EnterKeyRule enterKeyRule, bool formatOnCommit, Nullable`1<int> matchPriority, CompletionItemSelectionBehavior selectionBehavior);
    internal static CompletionItemRules Create(ImmutableArray`1<CharacterSetModificationRule> filterCharacterRules, ImmutableArray`1<CharacterSetModificationRule> commitCharacterRules, EnterKeyRule enterKeyRule, bool formatOnCommit, bool preselect);
    private CompletionItemRules With(Optional`1<ImmutableArray`1<CharacterSetModificationRule>> filterRules, Optional`1<ImmutableArray`1<CharacterSetModificationRule>> commitRules, Optional`1<EnterKeyRule> enterKeyRule, Optional`1<bool> formatOnCommit, Optional`1<int> matchPriority, Optional`1<CompletionItemSelectionBehavior> selectionBehavior);
    public CompletionItemRules WithFilterCharacterRules(ImmutableArray`1<CharacterSetModificationRule> filterCharacterRules);
    internal CompletionItemRules WithFilterCharacterRule(CharacterSetModificationRule rule);
    internal CompletionItemRules WithCommitCharacterRule(CharacterSetModificationRule rule);
    public CompletionItemRules WithCommitCharacterRules(ImmutableArray`1<CharacterSetModificationRule> commitCharacterRules);
    public CompletionItemRules WithEnterKeyRule(EnterKeyRule enterKeyRule);
    public CompletionItemRules WithFormatOnCommit(bool formatOnCommit);
    public CompletionItemRules WithMatchPriority(int matchPriority);
    public CompletionItemRules WithSelectionBehavior(CompletionItemSelectionBehavior selectionBehavior);
}
public enum Microsoft.CodeAnalysis.Completion.CompletionItemSelectionBehavior : Enum {
    public int value__;
    public static CompletionItemSelectionBehavior Default;
    public static CompletionItemSelectionBehavior SoftSelection;
    public static CompletionItemSelectionBehavior HardSelection;
}
public class Microsoft.CodeAnalysis.Completion.CompletionList : object {
    private bool _isExclusive;
    [CompilerGeneratedAttribute]
private ImmutableArray`1<CompletionItem> <Items>k__BackingField;
    [CompilerGeneratedAttribute]
private TextSpan <DefaultSpan>k__BackingField;
    [CompilerGeneratedAttribute]
private TextSpan <Span>k__BackingField;
    [CompilerGeneratedAttribute]
private CompletionRules <Rules>k__BackingField;
    [CompilerGeneratedAttribute]
private CompletionItem <SuggestionModeItem>k__BackingField;
    public static CompletionList Empty;
    public ImmutableArray`1<CompletionItem> Items { get; }
    [ObsoleteAttribute("Not used anymore.  CompletionList.Span is used instead.", "True")]
public TextSpan DefaultSpan { get; }
    public TextSpan Span { get; }
    public CompletionRules Rules { get; }
    public CompletionItem SuggestionModeItem { get; }
    private CompletionList(TextSpan defaultSpan, ImmutableArray`1<CompletionItem> items, CompletionRules rules, CompletionItem suggestionModeItem, bool isExclusive);
    private static CompletionList();
    [CompilerGeneratedAttribute]
public ImmutableArray`1<CompletionItem> get_Items();
    [CompilerGeneratedAttribute]
public TextSpan get_DefaultSpan();
    [CompilerGeneratedAttribute]
public TextSpan get_Span();
    [CompilerGeneratedAttribute]
public CompletionRules get_Rules();
    [CompilerGeneratedAttribute]
public CompletionItem get_SuggestionModeItem();
    public static CompletionList Create(TextSpan defaultSpan, ImmutableArray`1<CompletionItem> items, CompletionRules rules, CompletionItem suggestionModeItem);
    internal static CompletionList Create(TextSpan defaultSpan, ImmutableArray`1<CompletionItem> items, CompletionRules rules, CompletionItem suggestionModeItem, bool isExclusive);
    private CompletionList With(Optional`1<TextSpan> span, Optional`1<ImmutableArray`1<CompletionItem>> items, Optional`1<CompletionRules> rules, Optional`1<CompletionItem> suggestionModeItem);
    [ObsoleteAttribute("Not used anymore.  Use WithSpan instead.", "True")]
public CompletionList WithDefaultSpan(TextSpan span);
    public CompletionList WithSpan(TextSpan span);
    public CompletionList WithItems(ImmutableArray`1<CompletionItem> items);
    public CompletionList WithRules(CompletionRules rules);
    public CompletionList WithSuggestionModeItem(CompletionItem suggestionModeItem);
    internal TestAccessor GetTestAccessor();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal static class Microsoft.CodeAnalysis.Completion.CompletionOptions : object {
    public static PerLanguageOption2`1<bool> HideAdvancedMembers;
    public static PerLanguageOption2`1<bool> TriggerOnTyping;
    public static PerLanguageOption2`1<bool> TriggerOnTypingLetters2;
    public static PerLanguageOption`1<bool> TriggerOnTypingLetters;
    public static PerLanguageOption2`1<Nullable`1<bool>> TriggerOnDeletion;
    public static PerLanguageOption2`1<EnterKeyRule> EnterKeyBehavior;
    public static PerLanguageOption2`1<SnippetsRule> SnippetsBehavior;
    public static PerLanguageOption2`1<bool> ShowCompletionItemFilters;
    public static PerLanguageOption2`1<bool> HighlightMatchingPortionsOfCompletionListItems;
    public static PerLanguageOption2`1<bool> BlockForCompletionItems2;
    public static PerLanguageOption`1<bool> BlockForCompletionItems;
    public static PerLanguageOption2`1<bool> ShowNameSuggestions;
    public static PerLanguageOption2`1<Nullable`1<bool>> ShowItemsFromUnimportedNamespaces;
    public static PerLanguageOption2`1<Nullable`1<bool>> TriggerInArgumentLists;
    private static CompletionOptions();
    [IteratorStateMachineAttribute("Microsoft.CodeAnalysis.Completion.CompletionOptions/<GetDev15CompletionOptions>d__14")]
public static IEnumerable`1<PerLanguageOption2`1<bool>> GetDev15CompletionOptions();
}
[ExportOptionProviderAttribute]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.Completion.CompletionOptionsProvider : object {
    [CompilerGeneratedAttribute]
private ImmutableArray`1<IOption> <Options>k__BackingField;
    public ImmutableArray`1<IOption> Options { get; }
    [CompilerGeneratedAttribute]
public sealed virtual ImmutableArray`1<IOption> get_Options();
}
public abstract class Microsoft.CodeAnalysis.Completion.CompletionProvider : object {
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    internal string Name { get; }
    internal bool IsSnippetProvider { get; }
    internal bool IsExpandItemProvider { get; }
    [CompilerGeneratedAttribute]
internal string get_Name();
    public abstract virtual Task ProvideCompletionsAsync(CompletionContext context);
    public virtual bool ShouldTriggerCompletion(SourceText text, int caretPosition, CompletionTrigger trigger, OptionSet options);
    internal virtual bool ShouldTriggerCompletion(HostLanguageServices languageServices, SourceText text, int caretPosition, CompletionTrigger trigger, OptionSet options);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.Completion.CompletionProvider/<IsSyntacticTriggerCharacterAsync>d__7")]
internal virtual Task`1<bool> IsSyntacticTriggerCharacterAsync(Document document, int caretPosition, CompletionTrigger trigger, OptionSet options, CancellationToken cancellationToken);
    public virtual Task`1<CompletionDescription> GetDescriptionAsync(Document document, CompletionItem item, CancellationToken cancellationToken);
    public virtual Task`1<CompletionChange> GetChangeAsync(Document document, CompletionItem item, Nullable`1<char> commitKey, CancellationToken cancellationToken);
    internal virtual Task`1<CompletionChange> GetChangeAsync(Document document, CompletionItem item, TextSpan completionListSpan, Nullable`1<char> commitKey, bool disallowAddingImports, CancellationToken cancellationToken);
    internal virtual bool get_IsSnippetProvider();
    internal virtual bool get_IsExpandItemProvider();
}
public class Microsoft.CodeAnalysis.Completion.CompletionRules : object {
    [CompilerGeneratedAttribute]
private bool <DismissIfEmpty>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <DismissIfLastCharacterDeleted>k__BackingField;
    [CompilerGeneratedAttribute]
private ImmutableArray`1<char> <DefaultCommitCharacters>k__BackingField;
    [CompilerGeneratedAttribute]
private EnterKeyRule <DefaultEnterKeyRule>k__BackingField;
    [CompilerGeneratedAttribute]
private SnippetsRule <SnippetsRule>k__BackingField;
    private static ImmutableArray`1<char> s_defaultCommitKeys;
    public static CompletionRules Default;
    public bool DismissIfEmpty { get; }
    public bool DismissIfLastCharacterDeleted { get; }
    public ImmutableArray`1<char> DefaultCommitCharacters { get; }
    public EnterKeyRule DefaultEnterKeyRule { get; }
    public SnippetsRule SnippetsRule { get; }
    private CompletionRules(bool dismissIfEmpty, bool dismissIfLastCharacterDeleted, ImmutableArray`1<char> defaultCommitCharacters, EnterKeyRule defaultEnterKeyRule, SnippetsRule snippetsRule);
    private static CompletionRules();
    [CompilerGeneratedAttribute]
public bool get_DismissIfEmpty();
    [CompilerGeneratedAttribute]
public bool get_DismissIfLastCharacterDeleted();
    [CompilerGeneratedAttribute]
public ImmutableArray`1<char> get_DefaultCommitCharacters();
    [CompilerGeneratedAttribute]
public EnterKeyRule get_DefaultEnterKeyRule();
    [CompilerGeneratedAttribute]
public SnippetsRule get_SnippetsRule();
    public static CompletionRules Create(bool dismissIfEmpty, bool dismissIfLastCharacterDeleted, ImmutableArray`1<char> defaultCommitCharacters, EnterKeyRule defaultEnterKeyRule);
    public static CompletionRules Create(bool dismissIfEmpty, bool dismissIfLastCharacterDeleted, ImmutableArray`1<char> defaultCommitCharacters, EnterKeyRule defaultEnterKeyRule, SnippetsRule snippetsRule);
    private CompletionRules With(Optional`1<bool> dismissIfEmpty, Optional`1<bool> dismissIfLastCharacterDeleted, Optional`1<ImmutableArray`1<char>> defaultCommitCharacters, Optional`1<EnterKeyRule> defaultEnterKeyRule, Optional`1<SnippetsRule> snippetsRule);
    public CompletionRules WithDismissIfEmpty(bool dismissIfEmpty);
    public CompletionRules WithDismissIfLastCharacterDeleted(bool dismissIfLastCharacterDeleted);
    public CompletionRules WithDefaultCommitCharacters(ImmutableArray`1<char> defaultCommitCharacters);
    public CompletionRules WithDefaultEnterKeyRule(EnterKeyRule defaultEnterKeyRule);
    public CompletionRules WithSnippetsRule(SnippetsRule snippetsRule);
}
public abstract class Microsoft.CodeAnalysis.Completion.CompletionService : object {
    public string Language { get; }
    public static CompletionService GetService(Document document);
    public abstract virtual string get_Language();
    public virtual CompletionRules GetRules();
    public virtual bool ShouldTriggerCompletion(SourceText text, int caretPosition, CompletionTrigger trigger, ImmutableHashSet`1<string> roles, OptionSet options);
    internal virtual bool ShouldTriggerCompletion(Project project, SourceText text, int caretPosition, CompletionTrigger trigger, ImmutableHashSet`1<string> roles, OptionSet options);
    [ObsoleteAttribute("Not used anymore. CompletionService.GetDefaultCompletionListSpan is used instead.", "True")]
public virtual TextSpan GetDefaultItemSpan(SourceText text, int caretPosition);
    public virtual TextSpan GetDefaultCompletionListSpan(SourceText text, int caretPosition);
    public abstract virtual Task`1<CompletionList> GetCompletionsAsync(Document document, int caretPosition, CompletionTrigger trigger, ImmutableHashSet`1<string> roles, OptionSet options, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.Completion.CompletionService/<GetCompletionsInternalAsync>d__9")]
internal virtual Task`1<ValueTuple`2<CompletionList, bool>> GetCompletionsInternalAsync(Document document, int caretPosition, CompletionTrigger trigger, ImmutableHashSet`1<string> roles, OptionSet options, CancellationToken cancellationToken);
    public virtual Task`1<CompletionDescription> GetDescriptionAsync(Document document, CompletionItem item, CancellationToken cancellationToken);
    public virtual Task`1<CompletionChange> GetChangeAsync(Document document, CompletionItem item, Nullable`1<char> commitCharacter, CancellationToken cancellationToken);
    internal virtual Task`1<CompletionChange> GetChangeAsync(Document document, CompletionItem item, TextSpan completionListSpan, Nullable`1<char> commitCharacter, bool disallowAddingImports, CancellationToken cancellationToken);
    public virtual ImmutableArray`1<CompletionItem> FilterItems(Document document, ImmutableArray`1<CompletionItem> items, string filterText);
    internal virtual ImmutableArray`1<CompletionItem> FilterItems(Document document, ImmutableArray`1<ValueTuple`2<CompletionItem, Nullable`1<PatternMatch>>> itemsWithPatternMatch, string filterText);
    internal static ImmutableArray`1<CompletionItem> FilterItems(CompletionHelper completionHelper, ImmutableArray`1<CompletionItem> items, string filterText);
    internal static ImmutableArray`1<CompletionItem> FilterItems(CompletionHelper completionHelper, ImmutableArray`1<ValueTuple`2<CompletionItem, Nullable`1<PatternMatch>>> itemsWithPatternMatch);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal static class Microsoft.CodeAnalysis.Completion.CompletionServiceOptions : object {
    public static Option2`1<bool> IsExpandedCompletion;
    public static Option2`1<bool> DisallowAddingImports;
    public static Option2`1<int> TimeoutInMillisecondsForExtensionMethodImportCompletion;
    private static CompletionServiceOptions();
}
public abstract class Microsoft.CodeAnalysis.Completion.CompletionServiceWithProviders : CompletionService {
    private object _gate;
    private ConditionalWeakTable`2<IReadOnlyList`1<AnalyzerReference>, StrongBox`1<ImmutableArray`1<CompletionProvider>>> _projectCompletionProvidersMap;
    private ConditionalWeakTable`2<AnalyzerReference, ProjectCompletionProvider> _analyzerReferenceToCompletionProvidersMap;
    private CreateValueCallback<AnalyzerReference, ProjectCompletionProvider> _createProjectCompletionProvidersProvider;
    private Dictionary`2<string, CompletionProvider> _nameToProvider;
    private Dictionary`2<ImmutableHashSet`1<string>, ImmutableArray`1<CompletionProvider>> _rolesToProviders;
    private Func`2<ImmutableHashSet`1<string>, ImmutableArray`1<CompletionProvider>> _createRoleProviders;
    private Func`2<string, CompletionProvider> _getProviderByName;
    private Workspace _workspace;
    private IEnumerable`1<Lazy`2<CompletionProvider, CompletionProviderMetadata>> _importedProviders;
    protected CompletionServiceWithProviders(Workspace workspace);
    public virtual CompletionRules GetRules();
    [ObsoleteAttribute("Built-in providers will be ignored in a future release, please make them MEF exports instead.")]
protected virtual ImmutableArray`1<CompletionProvider> GetBuiltInProviders();
    private IEnumerable`1<Lazy`2<CompletionProvider, CompletionProviderMetadata>> GetImportedProviders();
    private ImmutableArray`1<CompletionProvider> CreateRoleProviders(ImmutableHashSet`1<string> roles);
    private ImmutableArray`1<CompletionProvider> GetAllProviders(ImmutableHashSet`1<string> roles);
    protected ImmutableArray`1<CompletionProvider> GetProviders(ImmutableHashSet`1<string> roles);
    private ConcatImmutableArray`1<CompletionProvider> GetFilteredProviders(Project project, ImmutableHashSet`1<string> roles, CompletionTrigger trigger, OptionSet options);
    protected virtual ImmutableArray`1<CompletionProvider> GetProviders(ImmutableHashSet`1<string> roles, CompletionTrigger trigger);
    private ImmutableArray`1<CompletionProvider> GetProjectCompletionProviders(Project project);
    private ImmutableArray`1<CompletionProvider> FilterProviders(ImmutableArray`1<CompletionProvider> providers, CompletionTrigger trigger, OptionSet options);
    protected internal CompletionProvider GetProvider(CompletionItem item);
    private CompletionProvider GetProviderByName(string providerName);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.Completion.CompletionServiceWithProviders/<GetCompletionsAsync>d__24")]
public virtual Task`1<CompletionList> GetCompletionsAsync(Document document, int caretPosition, CompletionTrigger trigger, ImmutableHashSet`1<string> roles, OptionSet options, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.Completion.CompletionServiceWithProviders/<GetCompletionsWithAvailabilityOfExpandedItemsAsync>d__25")]
private protected Task`1<ValueTuple`2<CompletionList, bool>> GetCompletionsWithAvailabilityOfExpandedItemsAsync(Document document, int caretPosition, CompletionTrigger trigger, ImmutableHashSet`1<string> roles, OptionSet options, CancellationToken cancellationToken);
    private static bool ValidatePossibleTriggerCharacterSet(CompletionTriggerKind completionTriggerKind, IEnumerable`1<CompletionProvider> triggeredProviders, Document document, SourceText text, int caretPosition, OptionSet optionSet);
    private static bool HasAnyItems(CompletionContext cc);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.Completion.CompletionServiceWithProviders/<ComputeNonEmptyCompletionContextsAsync>d__28")]
private Task`1<ValueTuple`2<ImmutableArray`1<CompletionContext>, bool>> ComputeNonEmptyCompletionContextsAsync(Document document, int caretPosition, CompletionTrigger trigger, OptionSet options, TextSpan defaultItemSpan, ImmutableArray`1<CompletionProvider> providers, CancellationToken cancellationToken);
    private CompletionList MergeAndPruneCompletionLists(IEnumerable`1<CompletionContext> completionContexts, TextSpan defaultSpan, bool isExclusive);
    protected virtual bool ItemsMatch(CompletionItem item, CompletionItem existingItem);
    protected virtual CompletionItem GetBetterItem(CompletionItem item, CompletionItem existingItem);
    private static Dictionary`2<CompletionProvider, int> GetCompletionProviderToIndex(ConcatImmutableArray`1<CompletionProvider> completionProviders);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.Completion.CompletionServiceWithProviders/<GetContextAsync>d__33")]
private Task`1<CompletionContext> GetContextAsync(CompletionProvider provider, Document document, int position, CompletionTrigger triggerInfo, OptionSet options, Nullable`1<TextSpan> defaultSpan, CancellationToken cancellationToken);
    public virtual Task`1<CompletionDescription> GetDescriptionAsync(Document document, CompletionItem item, CancellationToken cancellationToken);
    public virtual bool ShouldTriggerCompletion(SourceText text, int caretPosition, CompletionTrigger trigger, ImmutableHashSet`1<string> roles, OptionSet options);
    internal virtual bool ShouldTriggerCompletion(Project project, SourceText text, int caretPosition, CompletionTrigger trigger, ImmutableHashSet`1<string> roles, OptionSet options);
    internal virtual bool SupportsTriggerOnDeletion(OptionSet options);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.Completion.CompletionServiceWithProviders/<GetChangeAsync>d__38")]
public virtual Task`1<CompletionChange> GetChangeAsync(Document document, CompletionItem item, Nullable`1<char> commitKey, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.Completion.CompletionServiceWithProviders/<GetChangeAsync>d__39")]
internal virtual Task`1<CompletionChange> GetChangeAsync(Document document, CompletionItem item, TextSpan completionListSpan, Nullable`1<char> commitKey, bool disallowAddingImports, CancellationToken cancellationToken);
    private sealed virtual override bool System.Collections.Generic.IEqualityComparer<System.Collections.Immutable.ImmutableHashSet<System.String>>.Equals(ImmutableHashSet`1<string> x, ImmutableHashSet`1<string> y);
    private sealed virtual override int System.Collections.Generic.IEqualityComparer<System.Collections.Immutable.ImmutableHashSet<System.String>>.GetHashCode(ImmutableHashSet`1<string> obj);
    internal TestAccessor GetTestAccessor();
    [CompilerGeneratedAttribute]
private ImmutableArray`1<CompletionProvider> <GetProjectCompletionProviders>g__GetProjectCompletionProvidersSlow|20_0(Project project);
    [CompilerGeneratedAttribute]
private ImmutableArray`1<CompletionProvider> <GetProjectCompletionProviders>g__ComputeProjectCompletionProviders|20_1(Project project);
}
[ObsoleteAttribute("Use Microsoft.CodeAnalysis.Tags.WellKnownTags instead.")]
[EditorBrowsableAttribute("1")]
public static class Microsoft.CodeAnalysis.Completion.CompletionTags : object {
    public static string Public;
    public static string Protected;
    public static string Private;
    public static string Internal;
    public static string File;
    public static string Project;
    public static string Folder;
    public static string Assembly;
    public static string Class;
    public static string Constant;
    public static string Delegate;
    public static string Enum;
    public static string EnumMember;
    public static string Event;
    public static string ExtensionMethod;
    public static string Field;
    public static string Interface;
    public static string Intrinsic;
    public static string Keyword;
    public static string Label;
    public static string Local;
    public static string Namespace;
    public static string Method;
    public static string Module;
    public static string Operator;
    public static string Parameter;
    public static string Property;
    public static string RangeVariable;
    public static string Reference;
    public static string Structure;
    public static string TypeParameter;
    public static string Snippet;
    public static string Error;
    public static string Warning;
    internal static string StatusInformation;
}
[IsReadOnlyAttribute]
public class Microsoft.CodeAnalysis.Completion.CompletionTrigger : ValueType {
    [CompilerGeneratedAttribute]
private CompletionTriggerKind <Kind>k__BackingField;
    [CompilerGeneratedAttribute]
private char <Character>k__BackingField;
    [ObsoleteAttribute("Use 'Invoke' instead.")]
public static CompletionTrigger Default;
    public static CompletionTrigger Invoke;
    public CompletionTriggerKind Kind { get; }
    public char Character { get; }
    internal CompletionTrigger(CompletionTriggerKind kind, char character);
    private static CompletionTrigger();
    [CompilerGeneratedAttribute]
public CompletionTriggerKind get_Kind();
    [CompilerGeneratedAttribute]
public char get_Character();
    public static CompletionTrigger CreateInsertionTrigger(char insertedCharacter);
    public static CompletionTrigger CreateDeletionTrigger(char deletedCharacter);
}
public enum Microsoft.CodeAnalysis.Completion.CompletionTriggerKind : Enum {
    public int value__;
    [ObsoleteAttribute("Use 'Invoke' instead.")]
public static CompletionTriggerKind Other;
    public static CompletionTriggerKind Invoke;
    public static CompletionTriggerKind Insertion;
    public static CompletionTriggerKind Deletion;
    public static CompletionTriggerKind Snippets;
    public static CompletionTriggerKind InvokeAndCommitIfUnique;
}
public enum Microsoft.CodeAnalysis.Completion.EnterKeyRule : Enum {
    public int value__;
    public static EnterKeyRule Default;
    public static EnterKeyRule Never;
    public static EnterKeyRule Always;
    public static EnterKeyRule AfterFullyTypedWord;
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[MetadataAttributeAttribute]
[AttributeUsageAttribute("4")]
internal class Microsoft.CodeAnalysis.Completion.ExportArgumentProviderAttribute : ExportAttribute {
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Language>k__BackingField;
    [CompilerGeneratedAttribute]
private String[] <Roles>k__BackingField;
    public string Name { get; }
    public string Language { get; }
    public String[] Roles { get; public set; }
    public ExportArgumentProviderAttribute(string name, string language);
    [CompilerGeneratedAttribute]
public string get_Name();
    [CompilerGeneratedAttribute]
public string get_Language();
    [CompilerGeneratedAttribute]
public String[] get_Roles();
    [CompilerGeneratedAttribute]
public void set_Roles(String[] value);
}
[MetadataAttributeAttribute]
[AttributeUsageAttribute("4")]
public class Microsoft.CodeAnalysis.Completion.ExportCompletionProviderAttribute : ExportAttribute {
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Language>k__BackingField;
    [CompilerGeneratedAttribute]
private String[] <Roles>k__BackingField;
    public string Name { get; }
    public string Language { get; }
    public String[] Roles { get; public set; }
    public ExportCompletionProviderAttribute(string name, string language);
    [CompilerGeneratedAttribute]
public string get_Name();
    [CompilerGeneratedAttribute]
public string get_Language();
    [CompilerGeneratedAttribute]
public String[] get_Roles();
    [CompilerGeneratedAttribute]
public void set_Roles(String[] value);
}
internal class Microsoft.CodeAnalysis.Completion.FileSystemCompletionHelper : object {
    private static Char[] s_windowsDirectorySeparator;
    private Glyph _folderGlyph;
    private Glyph _fileGlyph;
    private ImmutableArray`1<string> _searchPaths;
    private string _baseDirectoryOpt;
    private ImmutableArray`1<string> _allowableExtensions;
    private CompletionItemRules _itemRules;
    public FileSystemCompletionHelper(Glyph folderGlyph, Glyph fileGlyph, ImmutableArray`1<string> searchPaths, string baseDirectoryOpt, ImmutableArray`1<string> allowableExtensions, CompletionItemRules itemRules);
    private static FileSystemCompletionHelper();
    protected virtual String[] GetLogicalDrives();
    protected virtual bool DirectoryExists(string fullPath);
    protected virtual IEnumerable`1<string> EnumerateDirectories(string fullDirectoryPath);
    protected virtual IEnumerable`1<string> EnumerateFiles(string fullDirectoryPath);
    protected virtual bool IsVisibleFileSystemEntry(string fullPath);
    private CompletionItem CreateNetworkRoot();
    private CompletionItem CreateUnixRoot();
    private CompletionItem CreateFileSystemEntryItem(string fullPath, bool isDirectory);
    private CompletionItem CreateLogicalDriveItem(string drive);
    public Task`1<ImmutableArray`1<CompletionItem>> GetItemsAsync(string directoryPath, CancellationToken cancellationToken);
    private ImmutableArray`1<CompletionItem> GetItems(string directoryPath, CancellationToken cancellationToken);
    [IteratorStateMachineAttribute("Microsoft.CodeAnalysis.Completion.FileSystemCompletionHelper/<GetItemsInDirectory>d__19")]
private IEnumerable`1<CompletionItem> GetItemsInDirectory(string fullDirectoryPath, CancellationToken cancellationToken);
    internal TestAccessor GetTestAccessor();
}
internal interface Microsoft.CodeAnalysis.Completion.ICompletionHelperService {
    public abstract virtual CompletionHelper GetCompletionHelper(Document document);
}
internal interface Microsoft.CodeAnalysis.Completion.ICompletionProviderFactory {
    public abstract virtual ImmutableArray`1<CompletionProvider> GetCompletionProviders();
}
internal class Microsoft.CodeAnalysis.Completion.Log.CompletionProvidersLogger : object {
    private static string Max;
    private static string Min;
    private static string Mean;
    private static string Range;
    private static string Count;
    private static StatisticLogAggregator s_statisticLogAggregator;
    private static LogAggregator s_logAggregator;
    private static HistogramLogAggregator s_histogramLogAggregator;
    private static CompletionProvidersLogger();
    internal static void LogTypeImportCompletionTicksDataPoint(int count);
    internal static void LogTypeImportCompletionItemCountDataPoint(int count);
    internal static void LogTypeImportCompletionReferenceCountDataPoint(int count);
    internal static void LogTypeImportCompletionCacheMiss();
    internal static void LogCommitOfTypeImportCompletionItem();
    internal static void LogTargetTypeCompletionTicksDataPoint(int count);
    internal static void LogExtensionMethodCompletionTicksDataPoint(int count);
    internal static void LogExtensionMethodCompletionMethodsProvidedDataPoint(int count);
    internal static void LogExtensionMethodCompletionGetSymbolsTicksDataPoint(int count);
    internal static void LogExtensionMethodCompletionCreateItemsTicksDataPoint(int count);
    internal static void LogCommitOfExtensionMethodImportCompletionItem();
    internal static void LogExtensionMethodCompletionPartialResultCount();
    internal static void LogExtensionMethodCompletionTimeoutCount();
    internal static void LogCommitUsingSemicolonToAddParenthesis();
    internal static void ReportTelemetry();
    private static string CreateProperty(string parent, string child);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal abstract class Microsoft.CodeAnalysis.Completion.LSPCompletionProvider : CommonCompletionProvider {
    public ImmutableHashSet`1<char> TriggerCharacters { get; }
    public abstract virtual ImmutableHashSet`1<char> get_TriggerCharacters();
}
public static class Microsoft.CodeAnalysis.Completion.MatchPriority : object {
    public static int Default;
    public static int Preselect;
    private static MatchPriority();
}
internal abstract class Microsoft.CodeAnalysis.Completion.Providers.AbstractCrefCompletionProvider : LSPCompletionProvider {
    protected static string HideAdvancedMembers;
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.Completion.Providers.AbstractCrefCompletionProvider/<GetDescriptionWorkerAsync>d__1")]
protected virtual Task`1<CompletionDescription> GetDescriptionWorkerAsync(Document document, CompletionItem item, CancellationToken cancellationToken);
    protected abstract virtual Task`1<ValueTuple`3<SyntaxToken, SemanticModel, ImmutableArray`1<ISymbol>>> GetSymbolsAsync(Document document, int position, OptionSet options, CancellationToken cancellationToken);
}
internal abstract class Microsoft.CodeAnalysis.Completion.Providers.AbstractDocCommentCompletionProvider`1 : LSPCompletionProvider {
    private static ImmutableArray`1<string> s_listTagNames;
    private static ImmutableArray`1<string> s_listHeaderTagNames;
    private static ImmutableArray`1<string> s_nestedTagNames;
    private static ImmutableArray`1<string> s_topLevelRepeatableTagNames;
    private static ImmutableArray`1<string> s_topLevelSingleUseTagNames;
    [TupleElementNamesAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private static Dictionary`2<string, ValueTuple`4<string, string, string, string>> s_tagMap;
    private static String[][] s_attributeMap;
    private static ImmutableArray`1<string> s_listTypeValues;
    private CompletionItemRules defaultRules;
    private static CharacterSetModificationRule WithoutQuoteRule;
    private static CharacterSetModificationRule WithoutSpaceRule;
    protected static ImmutableArray`1<CharacterSetModificationRule> FilterRules;
    protected AbstractDocCommentCompletionProvider`1(CompletionItemRules defaultRules);
    private static AbstractDocCommentCompletionProvider`1();
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.Completion.Providers.AbstractDocCommentCompletionProvider`1/<ProvideCompletionsAsync>d__10")]
public virtual Task ProvideCompletionsAsync(CompletionContext context);
    protected abstract virtual Task`1<IEnumerable`1<CompletionItem>> GetItemsWorkerAsync(Document document, int position, CompletionTrigger trigger, CancellationToken cancellationToken);
    protected abstract virtual IEnumerable`1<string> GetExistingTopLevelElementNames(TSyntax syntax);
    protected abstract virtual IEnumerable`1<string> GetExistingTopLevelAttributeValues(TSyntax syntax, string tagName, string attributeName);
    private CompletionItem GetItem(string name);
    protected IEnumerable`1<CompletionItem> GetAttributeItems(string tagName, ISet`1<string> existingAttributes);
    protected IEnumerable`1<CompletionItem> GetAlwaysVisibleItems();
    private CompletionItem GetCommentItem();
    private CompletionItem GetCDataItem();
    protected IEnumerable`1<CompletionItem> GetNestedItems(ISymbol symbol, bool includeKeywords);
    private IEnumerable`1<CompletionItem> GetParamRefItems(ISymbol symbol);
    private IEnumerable`1<CompletionItem> GetTypeParamRefItems(ISymbol symbol);
    protected IEnumerable`1<CompletionItem> GetAttributeValueItems(ISymbol symbol, string tagName, string attributeName);
    protected abstract virtual IEnumerable`1<string> GetKeywordNames();
    protected ImmutableArray`1<CompletionItem> GetTopLevelItems(ISymbol symbol, TSyntax syntax);
    protected IEnumerable`1<CompletionItem> GetItemTagItems();
    protected IEnumerable`1<CompletionItem> GetListItems();
    protected IEnumerable`1<CompletionItem> GetListHeaderItems();
    private IEnumerable`1<CompletionItem> GetParameterItems(ImmutableArray`1<TSymbol> symbols, TSyntax syntax, string tagName);
    private static string FormatParameter(string kind, string name);
    private static string FormatParameterRefTag(string kind, string name);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.Completion.Providers.AbstractDocCommentCompletionProvider`1/<GetChangeAsync>d__31")]
public virtual Task`1<CompletionChange> GetChangeAsync(Document document, CompletionItem item, Nullable`1<char> commitChar, CancellationToken cancellationToken);
    private CompletionItem CreateCompletionItem(string displayText);
    private CompletionItem CreateLangwordCompletionItem(string displayText);
    protected CompletionItem CreateCompletionItem(string displayText, string beforeCaretText, string afterCaretText, string beforeCaretTextOnSpace, string afterCaretTextOnSpace);
    private CompletionItemRules GetCompletionItemRules(string displayText);
    [CompilerGeneratedAttribute]
private CompletionItem <GetParamRefItems>b__20_1(string p);
    [CompilerGeneratedAttribute]
private CompletionItem <GetTypeParamRefItems>b__21_1(string t);
    [CompilerGeneratedAttribute]
private CompletionItem <GetAttributeValueItems>b__22_0(IParameterSymbol parameter);
    [CompilerGeneratedAttribute]
private CompletionItem <GetAttributeValueItems>b__22_1(ITypeParameterSymbol typeParameter);
    [CompilerGeneratedAttribute]
private CompletionItem <GetAttributeValueItems>b__22_2(ITypeParameterSymbol typeParameter);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal abstract class Microsoft.CodeAnalysis.Completion.Providers.AbstractEmbeddedLanguageCompletionProvider : LSPCompletionProvider {
    public static string EmbeddedProviderName;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private ImmutableArray`1<IEmbeddedLanguage> _languageProviders;
    [CompilerGeneratedAttribute]
private ImmutableHashSet`1<char> <TriggerCharacters>k__BackingField;
    public ImmutableHashSet`1<char> TriggerCharacters { get; }
    protected AbstractEmbeddedLanguageCompletionProvider(IEnumerable`1<Lazy`2<ILanguageService, LanguageServiceMetadata>> languageServices, string languageName);
    private static ImmutableHashSet`1<char> GetTriggerCharactersForEmbeddedLanguage(IEmbeddedLanguage language);
    private static bool IsEmbeddedLanguageProvider(Lazy`2<ILanguageService, LanguageServiceMetadata> lazyLanguageService, string languageName, string embeddedLanguageServiceType);
    [NullableContextAttribute("2")]
protected ImmutableArray`1<IEmbeddedLanguage> GetLanguageProviders(HostLanguageServices languageServices);
    [CompilerGeneratedAttribute]
public virtual ImmutableHashSet`1<char> get_TriggerCharacters();
    internal virtual bool ShouldTriggerCompletion(HostLanguageServices languageServices, SourceText text, int caretPosition, CompletionTrigger trigger, OptionSet options);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.Completion.Providers.AbstractEmbeddedLanguageCompletionProvider/<ProvideCompletionsAsync>d__10")]
public virtual Task ProvideCompletionsAsync(CompletionContext context);
    public virtual Task`1<CompletionChange> GetChangeAsync(Document document, CompletionItem item, Nullable`1<char> commitKey, CancellationToken cancellationToken);
    public virtual Task`1<CompletionDescription> GetDescriptionAsync(Document document, CompletionItem item, CancellationToken cancellationToken);
    private IEmbeddedLanguageFeatures GetLanguage(CompletionItem item);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal abstract class Microsoft.CodeAnalysis.Completion.Providers.AbstractExtensionMethodImportCompletionProvider : AbstractImportCompletionProvider {
    private Nullable`1<bool> _isTargetTypeCompletionFilterExperimentEnabled;
    protected string GenericSuffix { get; }
    protected abstract virtual string get_GenericSuffix();
    protected virtual bool ShouldProvideCompletion(CompletionContext completionContext, SyntaxContext syntaxContext);
    protected virtual void LogCommit();
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.Completion.Providers.AbstractExtensionMethodImportCompletionProvider/<AddCompletionItemsAsync>d__5")]
protected virtual Task AddCompletionItemsAsync(CompletionContext completionContext, SyntaxContext syntaxContext, HashSet`1<string> namespaceInScope, bool isExpandedCompletion, CancellationToken cancellationToken);
    private bool IsTargetTypeCompletionFilterExperimentEnabled(Workspace workspace);
    private static bool TryGetReceiverTypeSymbol(SyntaxContext syntaxContext, ISyntaxFactsService syntaxFacts, CancellationToken cancellationToken, ITypeSymbol& receiverTypeSymbol);
    private static ITypeSymbol GetSymbolType(ISymbol symbol);
    private CompletionItem Convert(SerializableImportCompletionItem serializableItem, string receiverTypeSymbolKey);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal abstract class Microsoft.CodeAnalysis.Completion.Providers.AbstractImportCompletionProvider : LSPCompletionProvider {
    private Nullable`1<bool> _isImportCompletionExperimentEnabled;
    internal bool IsExpandItemProvider { get; }
    protected abstract virtual Task`1<SyntaxContext> CreateContextAsync(Document document, int position, CancellationToken cancellationToken);
    protected abstract virtual ImmutableArray`1<string> GetImportedNamespaces(SyntaxNode location, SemanticModel semanticModel, CancellationToken cancellationToken);
    protected abstract virtual bool ShouldProvideCompletion(CompletionContext completionContext, SyntaxContext syntaxContext);
    protected abstract virtual Task AddCompletionItemsAsync(CompletionContext completionContext, SyntaxContext syntaxContext, HashSet`1<string> namespacesInScope, bool isExpandedCompletion, CancellationToken cancellationToken);
    protected abstract virtual bool IsFinalSemicolonOfUsingOrExtern(SyntaxNode directive, SyntaxToken token);
    protected abstract virtual Task`1<bool> ShouldProvideParenthesisCompletionAsync(Document document, CompletionItem item, Nullable`1<char> commitKey, CancellationToken cancellationToken);
    protected abstract virtual void LogCommit();
    internal virtual bool get_IsExpandItemProvider();
    private bool IsExperimentEnabled(Workspace workspace);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.Completion.Providers.AbstractImportCompletionProvider/<ProvideCompletionsAsync>d__11")]
public virtual Task ProvideCompletionsAsync(CompletionContext completionContext);
    private HashSet`1<string> GetNamespacesInScope(Document document, SyntaxContext syntaxContext, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.Completion.Providers.AbstractImportCompletionProvider/<GetChangeAsync>d__13")]
internal virtual Task`1<CompletionChange> GetChangeAsync(Document document, CompletionItem completionItem, TextSpan completionListSpan, Nullable`1<char> commitKey, bool disallowAddingImports, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.Completion.Providers.AbstractImportCompletionProvider/<IsInImportsDirectiveAsync>d__14")]
private Task`1<bool> IsInImportsDirectiveAsync(Document document, int position, CancellationToken cancellationToken);
    protected static bool IsAddingImportsSupported(Document document, bool disallowAddingImports);
    private static SyntaxNode CreateImport(Document document, string namespaceName);
    protected virtual Task`1<CompletionDescription> GetDescriptionWorkerAsync(Document document, CompletionItem item, CancellationToken cancellationToken);
}
internal abstract class Microsoft.CodeAnalysis.Completion.Providers.AbstractInternalsVisibleToCompletionProvider : LSPCompletionProvider {
    private static string ProjectGuidKey;
    [CompilerGeneratedAttribute]
private ImmutableHashSet`1<char> <TriggerCharacters>k__BackingField;
    public ImmutableHashSet`1<char> TriggerCharacters { get; }
    protected abstract virtual IImmutableList`1<SyntaxNode> GetAssemblyScopedAttributeSyntaxNodesOfDocument(SyntaxNode documentRoot);
    protected abstract virtual SyntaxNode GetConstructorArgumentOfInternalsVisibleToAttribute(SyntaxNode internalsVisibleToAttribute);
    public sealed virtual bool IsInsertionTrigger(SourceText text, int insertedCharacterPosition, OptionSet options);
    protected abstract virtual bool ShouldTriggerAfterQuotes(SourceText text, int insertedCharacterPosition);
    [CompilerGeneratedAttribute]
public virtual ImmutableHashSet`1<char> get_TriggerCharacters();
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.Completion.Providers.AbstractInternalsVisibleToCompletionProvider/<ProvideCompletionsAsync>d__8")]
public virtual Task ProvideCompletionsAsync(CompletionContext context);
    private static SyntaxNode GetAttributeSyntaxNodeOfToken(ISyntaxFactsService syntaxFactsService, SyntaxToken token);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.Completion.Providers.AbstractInternalsVisibleToCompletionProvider/<CheckTypeInfoOfAttributeAsync>d__10")]
private static Task`1<bool> CheckTypeInfoOfAttributeAsync(Document document, SyntaxNode attributeNode, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.Completion.Providers.AbstractInternalsVisibleToCompletionProvider/<AddAssemblyCompletionItemsAsync>d__11")]
private Task AddAssemblyCompletionItemsAsync(CompletionContext context, CancellationToken cancellationToken);
    private static bool IsProjectTypeUnsupported(Project project);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.Completion.Providers.AbstractInternalsVisibleToCompletionProvider/<GetAllInternalsVisibleToAssemblyNamesOfProjectAsync>d__13")]
private Task`1<IImmutableSet`1<string>> GetAllInternalsVisibleToAssemblyNamesOfProjectAsync(CompletionContext completionContext, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.Completion.Providers.AbstractInternalsVisibleToCompletionProvider/<GetAssemblyNameFromInternalsVisibleToAttributeAsync>d__14")]
private Task`1<string> GetAssemblyNameFromInternalsVisibleToAttributeAsync(Document document, SyntaxNode node, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.Completion.Providers.AbstractInternalsVisibleToCompletionProvider/<GetTextChangeSpanAsync>d__15")]
private static Task`1<TextSpan> GetTextChangeSpanAsync(Document document, TextSpan startSpan, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.Completion.Providers.AbstractInternalsVisibleToCompletionProvider/<GetChangeAsync>d__16")]
public virtual Task`1<CompletionChange> GetChangeAsync(Document document, CompletionItem item, Nullable`1<char> commitKey, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.Completion.Providers.AbstractInternalsVisibleToCompletionProvider/<GetPublicKeyOfProjectAsync>d__17")]
private static Task`1<string> GetPublicKeyOfProjectAsync(Project project, CancellationToken cancellationToken);
    private static string GetPublicKeyAsHexString(ImmutableArray`1<byte> publicKey);
    [CompilerGeneratedAttribute]
internal static bool <GetTextChangeSpanAsync>g__IsWordCharacter|15_0(char ch);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal abstract class Microsoft.CodeAnalysis.Completion.Providers.AbstractKeywordCompletionProvider`1 : LSPCompletionProvider {
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private static Comparer<TContext> s_comparer;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private ImmutableArray`1<IKeywordRecommender`1<TContext>> _keywordRecommenders;
    protected AbstractKeywordCompletionProvider`1(ImmutableArray`1<IKeywordRecommender`1<TContext>> keywordRecommenders);
    private static AbstractKeywordCompletionProvider`1();
    protected abstract virtual CompletionItem CreateItem(RecommendedKeyword keyword, TContext context, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.Completion.Providers.AbstractKeywordCompletionProvider`1/<ProvideCompletionsAsync>d__4")]
public virtual Task ProvideCompletionsAsync(CompletionContext context);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.Completion.Providers.AbstractKeywordCompletionProvider`1/<RecommendCompletionItemsAsync>d__5")]
private Task`1<ImmutableArray`1<CompletionItem>> RecommendCompletionItemsAsync(Document document, int position, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.Completion.Providers.AbstractKeywordCompletionProvider`1/<RecommendKeywordsAsync>d__6")]
private Task`1<ImmutableArray`1<RecommendedKeyword>> RecommendKeywordsAsync(Document document, int position, TContext context, CancellationToken cancellationToken);
    public sealed virtual Task`1<Nullable`1<TextChange>> GetTextChangeAsync(Document document, CompletionItem item, Nullable`1<char> ch, CancellationToken cancellationToken);
}
internal abstract class Microsoft.CodeAnalysis.Completion.Providers.AbstractMemberInsertingCompletionProvider : LSPCompletionProvider {
    private SyntaxAnnotation _annotation;
    private SyntaxAnnotation _otherAnnotation;
    private static ImmutableArray`1<CharacterSetModificationRule> s_commitRules;
    private static ImmutableArray`1<CharacterSetModificationRule> s_filterRules;
    private static CompletionItemRules s_defaultRules;
    private static AbstractMemberInsertingCompletionProvider();
    protected abstract virtual SyntaxToken GetToken(CompletionItem completionItem, SyntaxTree tree, CancellationToken cancellationToken);
    protected abstract virtual Task`1<ISymbol> GenerateMemberAsync(ISymbol member, INamedTypeSymbol containingType, Document document, CompletionItem item, CancellationToken cancellationToken);
    protected abstract virtual int GetTargetCaretPosition(SyntaxNode caretTarget);
    protected abstract virtual SyntaxNode GetSyntax(SyntaxToken commonSyntaxToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.Completion.Providers.AbstractMemberInsertingCompletionProvider/<GetChangeAsync>d__7")]
public virtual Task`1<CompletionChange> GetChangeAsync(Document document, CompletionItem item, Nullable`1<char> commitKey, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.Completion.Providers.AbstractMemberInsertingCompletionProvider/<DetermineNewDocumentAsync>d__8")]
private Task`1<Document> DetermineNewDocumentAsync(Document document, CompletionItem completionItem, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.Completion.Providers.AbstractMemberInsertingCompletionProvider/<GenerateMemberAndUsingsAsync>d__9")]
private Task`1<Document> GenerateMemberAndUsingsAsync(Document document, CompletionItem completionItem, TextLine line, CancellationToken cancellationToken);
    private TextSpan ComputeDestinationSpan(SyntaxNode insertionRoot);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.Completion.Providers.AbstractMemberInsertingCompletionProvider/<GenerateInsertionTextAsync>d__11")]
private Task`1<string> GenerateInsertionTextAsync(Document memberContainingDocument, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.Completion.Providers.AbstractMemberInsertingCompletionProvider/<GetTreeWithAddedSyntaxNodeRemovedAsync>d__12")]
private Task`1<SyntaxNode> GetTreeWithAddedSyntaxNodeRemovedAsync(Document document, CancellationToken cancellationToken);
    protected static CompletionItemRules GetRules();
    protected virtual Task`1<CompletionDescription> GetDescriptionWorkerAsync(Document document, CompletionItem item, CancellationToken cancellationToken);
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal abstract class Microsoft.CodeAnalysis.Completion.Providers.AbstractObjectCreationCompletionProvider`1 : AbstractSymbolCompletionProvider`1<TSyntaxContext> {
    protected abstract virtual SyntaxNode GetObjectCreationNewExpression(SyntaxTree tree, int position, CancellationToken cancellationToken);
    protected abstract virtual CompletionItemRules GetCompletionItemRules(ImmutableArray`1<ValueTuple`2<ISymbol, bool>> symbols);
    protected virtual CompletionItem CreateItem(CompletionContext completionContext, string displayText, string displayTextSuffix, string insertionText, ImmutableArray`1<ValueTuple`2<ISymbol, bool>> symbols, TSyntaxContext context, SupportedPlatformData supportedPlatformData);
    protected virtual Task`1<ImmutableArray`1<ValueTuple`2<ISymbol, bool>>> GetSymbolsAsync(CompletionContext completionContext, TSyntaxContext context, int position, OptionSet options, CancellationToken cancellationToken);
    protected virtual ValueTuple`3<string, string, string> GetDisplayAndSuffixAndInsertionText(ISymbol symbol, TSyntaxContext context);
}
internal abstract class Microsoft.CodeAnalysis.Completion.Providers.AbstractObjectInitializerCompletionProvider : LSPCompletionProvider {
    private static CompletionItemRules s_rules;
    private static AbstractObjectInitializerCompletionProvider();
    protected abstract virtual Tuple`2<ITypeSymbol, Location> GetInitializedType(Document document, SemanticModel semanticModel, int position, CancellationToken cancellationToken);
    protected abstract virtual HashSet`1<string> GetInitializedMembers(SyntaxTree tree, int position, CancellationToken cancellationToken);
    protected abstract virtual string EscapeIdentifier(ISymbol symbol);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.Completion.Providers.AbstractObjectInitializerCompletionProvider/<ProvideCompletionsAsync>d__3")]
public virtual Task ProvideCompletionsAsync(CompletionContext context);
    protected virtual Task`1<CompletionDescription> GetDescriptionWorkerAsync(Document document, CompletionItem item, CancellationToken cancellationToken);
    protected abstract virtual Task`1<bool> IsExclusiveAsync(Document document, int position, CancellationToken cancellationToken);
    private static bool IsLegalFieldOrProperty(ISymbol symbol);
    protected virtual bool IsInitializable(ISymbol member, INamedTypeSymbol containingType);
    private static bool CanSupportObjectInitializer(ISymbol symbol);
}
internal abstract class Microsoft.CodeAnalysis.Completion.Providers.AbstractOverrideCompletionProvider : AbstractMemberInsertingCompletionProvider {
    public abstract virtual SyntaxToken FindStartingToken(SyntaxTree tree, int position, CancellationToken cancellationToken);
    public abstract virtual ImmutableArray`1<ISymbol> FilterOverrides(ImmutableArray`1<ISymbol> members, ITypeSymbol returnType);
    public abstract virtual bool TryDetermineModifiers(SyntaxToken startToken, SourceText text, int startLine, Accessibility& seenAccessibility, DeclarationModifiers& modifiers);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.Completion.Providers.AbstractOverrideCompletionProvider/<ProvideCompletionsAsync>d__4")]
public virtual Task ProvideCompletionsAsync(CompletionContext context);
    protected virtual Task`1<ISymbol> GenerateMemberAsync(ISymbol newOverriddenMember, INamedTypeSymbol newContainingType, Document newDocument, CompletionItem completionItem, CancellationToken cancellationToken);
    public abstract virtual bool TryDetermineReturnType(SyntaxToken startToken, SemanticModel semanticModel, CancellationToken cancellationToken, ITypeSymbol& returnType, SyntaxToken& nextToken);
    protected static bool IsOnStartLine(int position, SourceText text, int startLine);
    protected static ITypeSymbol GetReturnType(ISymbol symbol);
}
internal abstract class Microsoft.CodeAnalysis.Completion.Providers.AbstractPartialMethodCompletionProvider : AbstractMemberInsertingCompletionProvider {
    protected static SymbolDisplayFormat SignatureDisplayFormat;
    private static AbstractPartialMethodCompletionProvider();
    protected abstract virtual bool IncludeAccessibility(IMethodSymbol method, CancellationToken cancellationToken);
    protected abstract virtual bool IsPartialMethodCompletionContext(SyntaxTree tree, int position, CancellationToken cancellationToken, DeclarationModifiers& modifiers, SyntaxToken& token);
    protected abstract virtual string GetDisplayText(IMethodSymbol method, SemanticModel semanticModel, int position);
    protected abstract virtual bool IsPartial(IMethodSymbol method);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.Completion.Providers.AbstractPartialMethodCompletionProvider/<ProvideCompletionsAsync>d__6")]
public virtual Task ProvideCompletionsAsync(CompletionContext context);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.Completion.Providers.AbstractPartialMethodCompletionProvider/<GenerateMemberAsync>d__7")]
protected virtual Task`1<ISymbol> GenerateMemberAsync(ISymbol member, INamedTypeSymbol containingType, Document document, CompletionItem item, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.Completion.Providers.AbstractPartialMethodCompletionProvider/<CreatePartialItemsAsync>d__8")]
protected Task`1<IEnumerable`1<CompletionItem>> CreatePartialItemsAsync(Document document, int position, TextSpan span, DeclarationModifiers modifiers, SyntaxToken token, CancellationToken cancellationToken);
    private CompletionItem CreateItem(IMethodSymbol method, int line, TextSpan span, SemanticModel semanticModel, DeclarationModifiers modifiers, SyntaxToken token);
}
internal abstract class Microsoft.CodeAnalysis.Completion.Providers.AbstractPartialTypeCompletionProvider`1 : LSPCompletionProvider {
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.Completion.Providers.AbstractPartialTypeCompletionProvider`1/<ProvideCompletionsAsync>d__1")]
public sealed virtual Task ProvideCompletionsAsync(CompletionContext completionContext);
    private CompletionItem CreateCompletionItem(INamedTypeSymbol symbol, TSyntaxContext context);
    protected abstract virtual ImmutableDictionary`2<string, string> GetProperties(INamedTypeSymbol symbol, TSyntaxContext context);
    protected abstract virtual SyntaxNode GetPartialTypeSyntaxNode(SyntaxTree tree, int position, CancellationToken cancellationToken);
    protected abstract virtual ValueTuple`3<string, string, string> GetDisplayAndSuffixAndInsertionText(INamedTypeSymbol symbol, TSyntaxContext context);
    protected virtual IEnumerable`1<INamedTypeSymbol> LookupCandidateSymbols(TSyntaxContext context, INamedTypeSymbol declaredSymbol, CancellationToken cancellationToken);
    private static bool InSameProject(INamedTypeSymbol symbol, Compilation compilation);
    private static bool NotNewDeclaredMember(INamedTypeSymbol symbol, TSyntaxContext context);
    protected virtual Task`1<CompletionDescription> GetDescriptionWorkerAsync(Document document, CompletionItem item, CancellationToken cancellationToken);
    public virtual Task`1<Nullable`1<TextChange>> GetTextChangeAsync(Document document, CompletionItem selectedItem, Nullable`1<char> ch, CancellationToken cancellationToken);
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal abstract class Microsoft.CodeAnalysis.Completion.Providers.AbstractRecommendationServiceBasedCompletionProvider`1 : AbstractSymbolCompletionProvider`1<TSyntaxContext> {
    protected CompletionItemSelectionBehavior PreselectedItemSelectionBehavior { get; }
    protected bool ShouldCollectTelemetryForTargetTypeCompletion { get; }
    protected abstract virtual Task`1<bool> ShouldPreselectInferredTypesAsync(CompletionContext completionContext, int position, OptionSet options, CancellationToken cancellationToken);
    protected abstract virtual CompletionItemRules GetCompletionItemRules(ImmutableArray`1<ValueTuple`2<ISymbol, bool>> symbols, TSyntaxContext context);
    protected abstract virtual CompletionItemSelectionBehavior get_PreselectedItemSelectionBehavior();
    protected abstract virtual bool IsInstrinsic(ISymbol symbol);
    protected abstract virtual bool IsTriggerOnDot(SyntaxToken token, int characterPosition);
    protected sealed virtual bool get_ShouldCollectTelemetryForTargetTypeCompletion();
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.Completion.Providers.AbstractRecommendationServiceBasedCompletionProvider`1/<GetSymbolsAsync>d__8")]
protected sealed virtual Task`1<ImmutableArray`1<ValueTuple`2<ISymbol, bool>>> GetSymbolsAsync(CompletionContext completionContext, TSyntaxContext context, int position, OptionSet options, CancellationToken cancellationToken);
    private static ITypeSymbol GetSymbolType(ISymbol symbol);
    protected virtual CompletionItem CreateItem(CompletionContext completionContext, string displayText, string displayTextSuffix, string insertionText, ImmutableArray`1<ValueTuple`2<ISymbol, bool>> symbols, TSyntaxContext context, SupportedPlatformData supportedPlatformData);
    private static bool ShouldSoftSelectInArgumentList(CompletionContext completionContext, TSyntaxContext context, bool preselect);
    private static bool IsArgumentListTriggerCharacter(char character);
    private static int ComputeSymbolMatchPriority(ISymbol symbol);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.Completion.Providers.AbstractRecommendationServiceBasedCompletionProvider`1/<GetDescriptionWorkerAsync>d__14")]
protected sealed virtual Task`1<CompletionDescription> GetDescriptionWorkerAsync(Document document, CompletionItem item, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.Completion.Providers.AbstractRecommendationServiceBasedCompletionProvider`1/<IsSemanticTriggerCharacterAsync>d__15")]
protected sealed virtual Task`1<bool> IsSemanticTriggerCharacterAsync(Document document, int characterPosition, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.Completion.Providers.AbstractRecommendationServiceBasedCompletionProvider`1/<IsTriggerOnDotAsync>d__16")]
protected Task`1<Nullable`1<bool>> IsTriggerOnDotAsync(Document document, int characterPosition, CancellationToken cancellationToken);
    [CompilerGeneratedAttribute]
internal static bool <GetDescriptionWorkerAsync>g__SymbolMatches|14_0(ValueTuple`2<ISymbol, bool> tuple, string name, Nullable`1<SymbolKind> kind, bool isGeneric);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal abstract class Microsoft.CodeAnalysis.Completion.Providers.AbstractSuggestionModeCompletionProvider : LSPCompletionProvider {
    public ImmutableHashSet`1<char> TriggerCharacters { get; }
    protected abstract virtual Task`1<CompletionItem> GetSuggestionModeItemAsync(Document document, int position, TextSpan span, CompletionTrigger triggerInfo, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.Completion.Providers.AbstractSuggestionModeCompletionProvider/<ProvideCompletionsAsync>d__1")]
public virtual Task ProvideCompletionsAsync(CompletionContext context);
    protected static CompletionItem CreateEmptySuggestionModeItem();
    public virtual ImmutableHashSet`1<char> get_TriggerCharacters();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal abstract class Microsoft.CodeAnalysis.Completion.Providers.AbstractSymbolCompletionProvider`1 : LSPCompletionProvider {
    private static ConditionalWeakTable`2<Document, Tuple`2<int, AsyncLazy`1<TSyntaxContext>>> s_cachedDocuments;
    private Nullable`1<bool> _isTargetTypeCompletionFilterExperimentEnabled;
    protected bool ShouldCollectTelemetryForTargetTypeCompletion { get; }
    private static AbstractSymbolCompletionProvider`1();
    protected abstract virtual Task`1<ImmutableArray`1<ValueTuple`2<ISymbol, bool>>> GetSymbolsAsync(CompletionContext completionContext, TSyntaxContext syntaxContext, int position, OptionSet options, CancellationToken cancellationToken);
    protected abstract virtual ValueTuple`3<string, string, string> GetDisplayAndSuffixAndInsertionText(ISymbol symbol, TSyntaxContext context);
    protected virtual CompletionItemRules GetCompletionItemRules(ImmutableArray`1<ValueTuple`2<ISymbol, bool>> symbols);
    protected bool IsTargetTypeCompletionFilterExperimentEnabled(Workspace workspace);
    private static bool ShouldIncludeInTargetTypedCompletionList(ISymbol symbol, ImmutableArray`1<ITypeSymbol> inferredTypes, SemanticModel semanticModel, int position, Dictionary`2<ITypeSymbol, bool> typeConvertibilityCache);
    private ImmutableArray`1<CompletionItem> CreateItems(CompletionContext completionContext, ImmutableArray`1<ValueTuple`2<ISymbol, bool>> symbols, Func`2<ValueTuple`2<ISymbol, bool>, TSyntaxContext> contextLookup, Dictionary`2<ISymbol, List`1<ProjectId>> invalidProjectMap, List`1<ProjectId> totalProjects, TelemetryCounter<TSyntaxContext> telemetryCounter);
    protected static bool TryFindFirstSymbolMatchesTargetTypes(Func`2<ValueTuple`2<ISymbol, bool>, TSyntaxContext> contextLookup, ImmutableArray`1<ValueTuple`2<ISymbol, bool>> symbolList, Dictionary`2<ITypeSymbol, bool> typeConvertibilityCache, Int32& index);
    private CompletionItem CreateItem(CompletionContext completionContext, string displayText, string displayTextSuffix, string insertionText, ImmutableArray`1<ValueTuple`2<ISymbol, bool>> symbols, TSyntaxContext context, Dictionary`2<ISymbol, List`1<ProjectId>> invalidProjectMap, List`1<ProjectId> totalProjects);
    protected virtual CompletionItem CreateItem(CompletionContext completionContext, string displayText, string displayTextSuffix, string insertionText, ImmutableArray`1<ValueTuple`2<ISymbol, bool>> symbols, TSyntaxContext context, SupportedPlatformData supportedPlatformData);
    protected virtual string GetFilterText(ISymbol symbol, string displayText, TSyntaxContext context);
    protected virtual Task`1<CompletionDescription> GetDescriptionWorkerAsync(Document document, CompletionItem item, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.Completion.Providers.AbstractSymbolCompletionProvider`1/<ProvideCompletionsAsync>d__14")]
public virtual Task ProvideCompletionsAsync(CompletionContext completionContext);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.Completion.Providers.AbstractSymbolCompletionProvider`1/<GetItemsAsync>d__15")]
private Task`1<ImmutableArray`1<CompletionItem>> GetItemsAsync(CompletionContext completionContext, TSyntaxContext syntaxContext, Document document, int position, OptionSet options, TelemetryCounter<TSyntaxContext> telemetryCounter, CancellationToken cancellationToken);
    protected virtual bool IsExclusive();
    protected virtual Task`1<bool> IsSemanticTriggerCharacterAsync(Document document, int characterPosition, CancellationToken cancellationToken);
    private static Dictionary`2<ValueTuple`2<ISymbol, bool>, TSyntaxContext> UnionSymbols(ImmutableArray`1<ValueTuple`3<DocumentId, TSyntaxContext, ImmutableArray`1<ValueTuple`2<ISymbol, bool>>>> linkedContextSymbolLists);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.Completion.Providers.AbstractSymbolCompletionProvider`1/<GetPerContextSymbolsAsync>d__19")]
private Task`1<ImmutableArray`1<ValueTuple`3<DocumentId, TSyntaxContext, ImmutableArray`1<ValueTuple`2<ISymbol, bool>>>>> GetPerContextSymbolsAsync(CompletionContext completionContext, Document document, int position, OptionSet options, IEnumerable`1<DocumentId> relatedDocuments, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.Completion.Providers.AbstractSymbolCompletionProvider`1/<TryGetSymbolsForContextAsync>d__20")]
protected Task`1<ImmutableArray`1<ValueTuple`2<ISymbol, bool>>> TryGetSymbolsForContextAsync(CompletionContext completionContext, TSyntaxContext syntaxContext, OptionSet options, CancellationToken cancellationToken);
    protected static OptionSet GetUpdatedRecommendationOptions(OptionSet options, string language);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.Completion.Providers.AbstractSymbolCompletionProvider`1/<CreateContextAsync>d__22")]
protected static Task`1<TSyntaxContext> CreateContextAsync(Document document, int position, CancellationToken cancellationToken);
    private static Task`1<TSyntaxContext> GetOrCreateContextAsync(Document document, int position, CancellationToken cancellationToken);
    private static Dictionary`2<ISymbol, List`1<ProjectId>> FindSymbolsMissingInLinkedContexts(Dictionary`2<ValueTuple`2<ISymbol, bool>, TSyntaxContext> symbolToContext, ImmutableArray`1<ValueTuple`3<DocumentId, TSyntaxContext, ImmutableArray`1<ValueTuple`2<ISymbol, bool>>>> linkedContextSymbolLists);
    public sealed virtual Task`1<Nullable`1<TextChange>> GetTextChangeAsync(Document document, CompletionItem selectedItem, Nullable`1<char> ch, CancellationToken cancellationToken);
    private string GetInsertionText(CompletionItem item, Nullable`1<char> ch);
    protected virtual string GetInsertionText(CompletionItem item, char ch);
    protected virtual bool get_ShouldCollectTelemetryForTargetTypeCompletion();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal abstract class Microsoft.CodeAnalysis.Completion.Providers.AbstractTypeImportCompletionProvider : AbstractImportCompletionProvider {
    protected virtual bool ShouldProvideCompletion(CompletionContext completionContext, SyntaxContext syntaxContext);
    protected virtual void LogCommit();
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.Completion.Providers.AbstractTypeImportCompletionProvider/<AddCompletionItemsAsync>d__2")]
protected virtual Task AddCompletionItemsAsync(CompletionContext completionContext, SyntaxContext syntaxContext, HashSet`1<string> namespacesInScope, bool isExpandedCompletion, CancellationToken cancellationToken);
    private static void AddItems(ImmutableArray`1<CompletionItem> items, CompletionContext completionContext, HashSet`1<string> namespacesInScope, TelemetryCounter counter);
}
internal class Microsoft.CodeAnalysis.Completion.Providers.CompletionProviderMetadata : OrderableLanguageMetadata {
    [CompilerGeneratedAttribute]
private String[] <Roles>k__BackingField;
    public String[] Roles { get; }
    public CompletionProviderMetadata(IDictionary`2<string, object> data);
    [CompilerGeneratedAttribute]
public String[] get_Roles();
}
internal static class Microsoft.CodeAnalysis.Completion.Providers.CompletionUtilities : object {
    [NullableContextAttribute("1")]
public static bool IsTypeImplicitlyConvertible(Compilation compilation, ITypeSymbol sourceType, ImmutableArray`1<ITypeSymbol> targetTypes);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal static class Microsoft.CodeAnalysis.Completion.Providers.ExtensionMethodImportCompletionHelper : object {
    private static object s_gate;
    private static Task s_indexingTask;
    private static ExtensionMethodImportCompletionHelper();
    private static IImportCompletionCacheService`2<CacheEntry, object> GetCacheService(Workspace workspace);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.Completion.Providers.ExtensionMethodImportCompletionHelper/<GetCacheEntryAsync>d__3")]
private static Task`1<Nullable`1<CacheEntry>> GetCacheEntryAsync(Project project, bool loadOnly, IImportCompletionCacheService`2<CacheEntry, object> cacheService, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.Completion.Providers.ExtensionMethodImportCompletionHelper/<GetUnimportedExtensionMethodsAsync>d__6")]
public static Task`1<ImmutableArray`1<SerializableImportCompletionItem>> GetUnimportedExtensionMethodsAsync(Document document, int position, ITypeSymbol receiverTypeSymbol, ISet`1<string> namespaceInScope, ImmutableArray`1<ITypeSymbol> targetTypesSymbols, bool forceIndexCreation, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.Completion.Providers.ExtensionMethodImportCompletionHelper/<GetUnimportedExtensionMethodsInCurrentProcessAsync>d__7")]
public static Task`1<SerializableUnimportedExtensionMethods> GetUnimportedExtensionMethodsInCurrentProcessAsync(Document document, int position, ITypeSymbol receiverTypeSymbol, ISet`1<string> namespaceInScope, ImmutableArray`1<ITypeSymbol> targetTypes, bool forceIndexCreation, CancellationToken cancellationToken);
    [NullableContextAttribute("0")]
private static ImmutableArray`1<SerializableImportCompletionItem> ConvertSymbolsToCompletionItems(Compilation compilation, ImmutableArray`1<IMethodSymbol> extentsionMethodSymbols, ImmutableArray`1<ITypeSymbol> targetTypeSymbols, CancellationToken cancellationToken);
    private static bool ShouldIncludeInTargetTypedCompletion(Compilation compilation, IMethodSymbol methodSymbol, ImmutableArray`1<ITypeSymbol> targetTypeSymbols, Dictionary`2<ITypeSymbol, bool> typeConvertibilityCache);
    private static string GetFullyQualifiedNamespaceName(INamespaceSymbol symbol, Dictionary`2<INamespaceSymbol, string> stringCache);
}
[NullableContextAttribute("1")]
internal interface Microsoft.CodeAnalysis.Completion.Providers.IKeywordRecommender`1 {
    public abstract virtual ImmutableArray`1<RecommendedKeyword> RecommendKeywords(int position, TContext context, CancellationToken cancellationToken);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal abstract class Microsoft.CodeAnalysis.Completion.Providers.ImportCompletion.AbstractImportCompletionCacheServiceFactory`2 : object {
    private ConcurrentDictionary`2<string, TMetadataCacheEntry> _peItemsCache;
    private ConcurrentDictionary`2<ProjectId, TProjectCacheEntry> _projectItemsCache;
    public sealed virtual IWorkspaceService CreateService(HostWorkspaceServices workspaceServices);
    private void OnCacheFlushRequested(object sender, EventArgs e);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal abstract class Microsoft.CodeAnalysis.Completion.Providers.ImportCompletion.AbstractTypeImportCompletionService : object {
    private static object s_gate;
    private static Task s_cachingTask;
    [CompilerGeneratedAttribute]
private IImportCompletionCacheService`2<CacheEntry, CacheEntry> <CacheService>k__BackingField;
    private IImportCompletionCacheService`2<CacheEntry, CacheEntry> CacheService { get; }
    protected string GenericTypeSuffix { get; }
    protected bool IsCaseSensitive { get; }
    internal AbstractTypeImportCompletionService(Workspace workspace);
    private static AbstractTypeImportCompletionService();
    [CompilerGeneratedAttribute]
private IImportCompletionCacheService`2<CacheEntry, CacheEntry> get_CacheService();
    protected abstract virtual string get_GenericTypeSuffix();
    protected abstract virtual bool get_IsCaseSensitive();
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.Completion.Providers.ImportCompletion.AbstractTypeImportCompletionService/<GetAllTopLevelTypesAsync>d__12")]
public sealed virtual Task`1<Nullable`1<ImmutableArray`1<ImmutableArray`1<CompletionItem>>>> GetAllTopLevelTypesAsync(Project currentProject, SyntaxContext syntaxContext, bool forceCacheCreation, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.Completion.Providers.ImportCompletion.AbstractTypeImportCompletionService/<GetCacheEntriesAsync>d__13")]
private Task`1<Nullable`1<ImmutableArray`1<GetCacheResult>>> GetCacheEntriesAsync(Project currentProject, SyntaxContext syntaxContext, bool forceCacheCreation, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.Completion.Providers.ImportCompletion.AbstractTypeImportCompletionService/<GetCacheForProjectAsync>d__14")]
private Task`1<Nullable`1<GetCacheResult>> GetCacheForProjectAsync(Project project, SyntaxContext syntaxContext, bool forceCacheCreation, Lazy`1<EditorBrowsableInfo> editorBrowsableInfo, CancellationToken cancellationToken);
    private bool TryGetCacheForPEReference(Solution solution, IAssemblySymbol assemblySymbol, Lazy`1<EditorBrowsableInfo> editorBrowsableInfo, PortableExecutableReference peReference, SyntaxContext syntaxContext, bool forceCacheCreation, CancellationToken cancellationToken, Nullable`1& result);
    private Nullable`1<GetCacheResult> GetCacheWorker(TKey key, IAssemblySymbol assembly, Checksum checksum, SyntaxContext syntaxContext, bool forceCacheCreation, IDictionary`2<TKey, CacheEntry> cache, Lazy`1<EditorBrowsableInfo> editorBrowsableInfo, CancellationToken cancellationToken);
    private static void GetCompletionItemsForTopLevelTypeDeclarations(INamespaceSymbol rootNamespaceSymbol, Builder builder, CancellationToken cancellationToken);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
internal static bool <GetCacheEntriesAsync>g__HasGlobalAlias|13_2(MetadataReference metadataReference);
    [CompilerGeneratedAttribute]
internal static void <GetCompletionItemsForTopLevelTypeDeclarations>g__VisitNamespace|17_0(INamespaceSymbol symbol, string containingNamespace, Builder builder, CancellationToken cancellationToken);
}
[NullableContextAttribute("1")]
internal interface Microsoft.CodeAnalysis.Completion.Providers.ImportCompletion.IImportCompletionCacheService`2 {
    public IDictionary`2<string, TPortableExecutable> PEItemsCache { get; }
    public IDictionary`2<ProjectId, TProject> ProjectItemsCache { get; }
    public abstract virtual IDictionary`2<string, TPortableExecutable> get_PEItemsCache();
    public abstract virtual IDictionary`2<ProjectId, TProject> get_ProjectItemsCache();
}
internal interface Microsoft.CodeAnalysis.Completion.Providers.ImportCompletion.ITypeImportCompletionService {
    [NullableContextAttribute("1")]
public abstract virtual Task`1<Nullable`1<ImmutableArray`1<ImmutableArray`1<CompletionItem>>>> GetAllTopLevelTypesAsync(Project project, SyntaxContext syntaxContext, bool forceCacheCreation, CancellationToken cancellationToken);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal static class Microsoft.CodeAnalysis.Completion.Providers.ImportCompletionItem : object {
    private static string SortTextFormat;
    private static string TypeAritySuffixName;
    private static string AttributeFullName;
    private static string MethodKey;
    private static string ReceiverKey;
    private static string OverloadCountKey;
    public static CompletionItem Create(string name, int arity, string containingNamespace, Glyph glyph, string genericTypeSuffix, CompletionItemFlags flags, Nullable`1<ValueTuple`3<string, string, int>> extensionMethodData, bool includedInTargetTypeCompletion);
    public static CompletionItem CreateAttributeItemWithoutSuffix(CompletionItem attributeItem, string attributeNameWithoutSuffix, CompletionItemFlags flags);
    public static CompletionItem CreateItemWithGenericDisplaySuffix(CompletionItem item, string genericTypeSuffix);
    public static string GetContainingNamespace(CompletionItem item);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.Completion.Providers.ImportCompletionItem/<GetCompletionDescriptionAsync>d__10")]
public static Task`1<CompletionDescription> GetCompletionDescriptionAsync(Document document, CompletionItem item, CancellationToken cancellationToken);
    private static string GetFullyQualifiedName(string namespaceName, string typeName);
    private static ValueTuple`2<ISymbol, int> GetSymbolAndOverloadCount(CompletionItem item, Compilation compilation);
}
[NullableContextAttribute("1")]
internal interface Microsoft.CodeAnalysis.Completion.Providers.IRemoteExtensionMethodImportCompletionService {
    public abstract virtual ValueTask`1<SerializableUnimportedExtensionMethods> GetUnimportedExtensionMethodsAsync(PinnedSolutionInfo solutionInfo, DocumentId documentId, int position, string receiverTypeSymbolKeyData, ImmutableArray`1<string> namespaceInScope, ImmutableArray`1<string> targetTypesSymbolKeyData, bool forceIndexCreation, CancellationToken cancellationToken);
}
internal class Microsoft.CodeAnalysis.Completion.Providers.MemberInsertionCompletionItem : object {
    public static CompletionItem Create(string displayText, string displayTextSuffix, DeclarationModifiers modifiers, int line, ISymbol symbol, SyntaxToken token, int descriptionPosition, CompletionItemRules rules);
    public static Task`1<CompletionDescription> GetDescriptionAsync(CompletionItem item, Document document, CancellationToken cancellationToken);
    public static DeclarationModifiers GetModifiers(CompletionItem item);
    public static int GetLine(CompletionItem item);
    public static int GetTokenSpanEnd(CompletionItem item);
}
internal class Microsoft.CodeAnalysis.Completion.Providers.RecommendedKeyword : object {
    [CompilerGeneratedAttribute]
private Glyph <Glyph>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Keyword>k__BackingField;
    [CompilerGeneratedAttribute]
private Func`2<CancellationToken, ImmutableArray`1<SymbolDisplayPart>> <DescriptionFactory>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsIntrinsic>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <ShouldFormatOnCommit>k__BackingField;
    [CompilerGeneratedAttribute]
private int <MatchPriority>k__BackingField;
    public Glyph Glyph { get; }
    public string Keyword { get; }
    public Func`2<CancellationToken, ImmutableArray`1<SymbolDisplayPart>> DescriptionFactory { get; }
    public bool IsIntrinsic { get; }
    public bool ShouldFormatOnCommit { get; }
    public int MatchPriority { get; }
    public RecommendedKeyword(string keyword, string toolTip, Glyph glyph, bool isIntrinsic, bool shouldFormatOnCommit, Nullable`1<int> matchPriority);
    public RecommendedKeyword(string keyword, Glyph glyph, Func`2<CancellationToken, ImmutableArray`1<SymbolDisplayPart>> descriptionFactory, bool isIntrinsic, bool shouldFormatOnCommit, Nullable`1<int> matchPriority);
    [CompilerGeneratedAttribute]
public Glyph get_Glyph();
    [CompilerGeneratedAttribute]
public string get_Keyword();
    [CompilerGeneratedAttribute]
public Func`2<CancellationToken, ImmutableArray`1<SymbolDisplayPart>> get_DescriptionFactory();
    [CompilerGeneratedAttribute]
public bool get_IsIntrinsic();
    [CompilerGeneratedAttribute]
public bool get_ShouldFormatOnCommit();
    [CompilerGeneratedAttribute]
public int get_MatchPriority();
    internal static ImmutableArray`1<SymbolDisplayPart> CreateDisplayParts(string keyword, string toolTip);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[IsReadOnlyAttribute]
[DataContractAttribute]
internal class Microsoft.CodeAnalysis.Completion.Providers.SerializableImportCompletionItem : ValueType {
    [DataMemberAttribute]
public string SymbolKeyData;
    [DataMemberAttribute]
public string Name;
    [DataMemberAttribute]
public int Arity;
    [DataMemberAttribute]
public Glyph Glyph;
    [DataMemberAttribute]
public string ContainingNamespace;
    [DataMemberAttribute]
public int AdditionalOverloadCount;
    [DataMemberAttribute]
public bool IncludedInTargetTypeCompletion;
    public SerializableImportCompletionItem(string symbolKeyData, string name, int arity, Glyph glyph, string containingNamespace, int additionalOverloadCount, bool includedInTargetTypeCompletion);
}
[IsReadOnlyAttribute]
[DataContractAttribute]
internal class Microsoft.CodeAnalysis.Completion.Providers.SerializableUnimportedExtensionMethods : ValueType {
    [DataMemberAttribute]
public ImmutableArray`1<SerializableImportCompletionItem> CompletionItems;
    [DataMemberAttribute]
public bool IsPartialResult;
    [DataMemberAttribute]
public int GetSymbolsTicks;
    [DataMemberAttribute]
public int CreateItemsTicks;
    public SerializableUnimportedExtensionMethods(ImmutableArray`1<SerializableImportCompletionItem> completionItems, bool isPartialResult, int getSymbolsTicks, int createItemsTicks);
}
internal static class Microsoft.CodeAnalysis.Completion.Providers.SymbolCompletionItem : object {
    private static Func`3<IReadOnlyList`1<ISymbol>, CompletionItem, CompletionItem> s_addSymbolEncoding;
    private static Func`3<IReadOnlyList`1<ISymbol>, CompletionItem, CompletionItem> s_addSymbolInfo;
    private static Char[] s_symbolSplitters;
    private static Char[] projectSeperators;
    private static SymbolCompletionItem();
    private static CompletionItem CreateWorker(string displayText, string displayTextSuffix, IReadOnlyList`1<ISymbol> symbols, CompletionItemRules rules, int contextPosition, Func`3<IReadOnlyList`1<ISymbol>, CompletionItem, CompletionItem> symbolEncoder, string sortText, string insertionText, string filterText, SupportedPlatformData supportedPlatforms, ImmutableDictionary`2<string, string> properties, ImmutableArray`1<string> tags);
    public static CompletionItem AddSymbolEncoding(IReadOnlyList`1<ISymbol> symbols, CompletionItem item);
    public static CompletionItem AddSymbolInfo(IReadOnlyList`1<ISymbol> symbols, CompletionItem item);
    public static CompletionItem AddShouldProvideParenthesisCompletion(CompletionItem item);
    public static bool GetShouldProvideParenthesisCompletion(CompletionItem item);
    public static string EncodeSymbols(IReadOnlyList`1<ISymbol> symbols);
    public static string EncodeSymbol(ISymbol symbol);
    public static bool HasSymbols(CompletionItem item);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.Completion.Providers.SymbolCompletionItem/<GetSymbolsAsync>d__11")]
public static Task`1<ImmutableArray`1<ISymbol>> GetSymbolsAsync(CompletionItem item, Document document, CancellationToken cancellationToken);
    private static void DecodeSymbols(List`1<string> ids, Compilation compilation, ArrayBuilder`1<ISymbol> symbols);
    private static ISymbol DecodeSymbol(string id, Compilation compilation);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.Completion.Providers.SymbolCompletionItem/<GetDescriptionAsync>d__14")]
public static Task`1<CompletionDescription> GetDescriptionAsync(CompletionItem item, Document document, CancellationToken cancellationToken);
    private static Document FindAppropriateDocumentForDescriptionContext(Document document, SupportedPlatformData supportedPlatforms);
    private static CompletionItem WithSupportedPlatforms(CompletionItem completionItem, SupportedPlatformData supportedPlatforms);
    public static SupportedPlatformData GetSupportedPlatforms(CompletionItem item, Workspace workspace);
    public static int GetContextPosition(CompletionItem item);
    public static int GetDescriptionPosition(CompletionItem item);
    public static string GetInsertionText(CompletionItem item);
    public static CompletionItem CreateWithSymbolId(string displayText, IReadOnlyList`1<ISymbol> symbols, CompletionItemRules rules, int contextPosition, string sortText, string insertionText, string filterText, SupportedPlatformData supportedPlatforms, ImmutableDictionary`2<string, string> properties, ImmutableArray`1<string> tags);
    public static CompletionItem CreateWithSymbolId(string displayText, string displayTextSuffix, IReadOnlyList`1<ISymbol> symbols, CompletionItemRules rules, int contextPosition, string sortText, string insertionText, string filterText, SupportedPlatformData supportedPlatforms, ImmutableDictionary`2<string, string> properties, ImmutableArray`1<string> tags);
    public static CompletionItem CreateWithNameAndKind(string displayText, string displayTextSuffix, IReadOnlyList`1<ISymbol> symbols, CompletionItemRules rules, int contextPosition, string sortText, string insertionText, string filterText, SupportedPlatformData supportedPlatforms, ImmutableDictionary`2<string, string> properties, ImmutableArray`1<string> tags);
    internal static string GetSymbolName(CompletionItem item);
    internal static Nullable`1<SymbolKind> GetKind(CompletionItem item);
    internal static bool GetSymbolIsGeneric(CompletionItem item);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.Completion.Providers.SymbolCompletionItem/<GetDescriptionAsync>d__28")]
public static Task`1<CompletionDescription> GetDescriptionAsync(CompletionItem item, IReadOnlyList`1<ISymbol> symbols, Document document, SemanticModel semanticModel, CancellationToken cancellationToken);
}
internal static class Microsoft.CodeAnalysis.Completion.Providers.SymbolMatchPriority : object {
    internal static int Keyword;
    internal static int PreferType;
    internal static int PreferNamedArgument;
    internal static int PreferEventOrMethod;
    internal static int PreferFieldOrProperty;
    internal static int PreferLocalOrParameterOrRangeVariable;
    private static SymbolMatchPriority();
}
internal class Microsoft.CodeAnalysis.Completion.Providers.UnionCompletionItemComparer : object {
    [CompilerGeneratedAttribute]
private static UnionCompletionItemComparer <Instance>k__BackingField;
    public static UnionCompletionItemComparer Instance { get; }
    private static UnionCompletionItemComparer();
    [CompilerGeneratedAttribute]
public static UnionCompletionItemComparer get_Instance();
    public sealed virtual bool Equals(CompletionItem x, CompletionItem y);
    public sealed virtual int GetHashCode(CompletionItem obj);
}
internal static class Microsoft.CodeAnalysis.Completion.Providers.XmlDocCommentCompletionItem : object {
    private static string BeforeCaretText;
    private static string AfterCaretText;
    private static string BeforeCaretTextOnSpace;
    private static string AfterCaretTextOnSpace;
    public static CompletionItem Create(string displayText, string beforeCaretText, string afterCaretText, string beforeCaretTextOnSpace, string afterCaretTextOnSpace, CompletionItemRules rules);
    public static string GetBeforeCaretText(CompletionItem item);
    public static string GetAfterCaretText(CompletionItem item);
    public static bool TryGetInsertionTextOnSpace(CompletionItem item, String& beforeCaretText, String& afterCaretText);
}
public enum Microsoft.CodeAnalysis.Completion.SnippetsRule : Enum {
    public int value__;
    public static SnippetsRule Default;
    public static SnippetsRule NeverInclude;
    public static SnippetsRule AlwaysInclude;
    public static SnippetsRule IncludeAfterTypingIdentifierQuestionTab;
}
internal static class Microsoft.CodeAnalysis.Completion.Utilities : object {
    public static TextChange Collapse(SourceText newText, ImmutableArray`1<TextChange> changes);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal abstract class Microsoft.CodeAnalysis.ConflictMarkerResolution.AbstractResolveConflictMarkerCodeFixProvider : CodeFixProvider {
    internal static string TakeTopEquivalenceKey;
    internal static string TakeBottomEquivalenceKey;
    internal static string TakeBothEquivalenceKey;
    private static int s_mergeConflictLength;
    private ISyntaxKinds _syntaxKinds;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private ImmutableArray`1<string> <FixableDiagnosticIds>k__BackingField;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ImmutableArray`1<string> FixableDiagnosticIds { get; }
    protected AbstractResolveConflictMarkerCodeFixProvider(ISyntaxKinds syntaxKinds, string diagnosticId);
    private static AbstractResolveConflictMarkerCodeFixProvider();
    [CompilerGeneratedAttribute]
public virtual ImmutableArray`1<string> get_FixableDiagnosticIds();
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.ConflictMarkerResolution.AbstractResolveConflictMarkerCodeFixProvider/<RegisterCodeFixesAsync>d__9")]
public virtual Task RegisterCodeFixesAsync(CodeFixContext context);
    private bool ShouldFix(SyntaxNode root, SourceText text, int position, TextLine& startLine, TextLine& middleLine, TextLine& endLine);
    private static bool TryGetConflictLines(SourceText text, int position, TextLine& startLine, TextLine& middleLine, TextLine& endLine);
    private static bool TryFindLineForwards(TextLine startLine, char ch, TextLine& foundLine);
    private static bool TryFindLineBackwards(TextLine startLine, char ch, TextLine& foundLine);
    private static bool IsConflictMarker(TextLine currentLine, char ch);
    private static void RegisterCodeFixes(CodeFixContext context, TextLine startLine, TextLine middleLine, TextLine endLine);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.ConflictMarkerResolution.AbstractResolveConflictMarkerCodeFixProvider/<AddEditsAsync>d__16")]
private static Task`1<Document> AddEditsAsync(Document document, int startPos, int equalsPos, int endPos, Action`5<SourceText, ArrayBuilder`1<TextChange>, int, int, int> addEdits, CancellationToken cancellationToken);
    private static void AddTopEdits(SourceText text, ArrayBuilder`1<TextChange> edits, int startPos, int equalsPos, int endPos);
    private static void AddBottomEdits(SourceText text, ArrayBuilder`1<TextChange> edits, int startPos, int equalsPos, int endPos);
    private static void AddBothEdits(SourceText text, ArrayBuilder`1<TextChange> edits, int startPos, int equalsPos, int endPos);
    private static Task`1<Document> TakeTopAsync(Document document, int startPos, int equalsPos, int endPos, CancellationToken cancellationToken);
    private static Task`1<Document> TakeBottomAsync(Document document, int startPos, int equalsPos, int endPos, CancellationToken cancellationToken);
    private static Task`1<Document> TakeBothAsync(Document document, int startPos, int equalsPos, int endPos, CancellationToken cancellationToken);
    private static int GetEndIncludingLineBreak(SourceText text, int position);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.ConflictMarkerResolution.AbstractResolveConflictMarkerCodeFixProvider/<FixAllAsync>d__24")]
private Task`1<Document> FixAllAsync(Document document, ImmutableArray`1<Diagnostic> diagnostics, string equivalenceKey, CancellationToken cancellationToken);
    public virtual FixAllProvider GetFixAllProvider();
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.ConflictMarkerResolution.AbstractResolveConflictMarkerCodeFixProvider/<<GetFixAllProvider>b__25_0>d")]
[CompilerGeneratedAttribute]
private Task`1<Document> <GetFixAllProvider>b__25_0(FixAllContext context, Document document, ImmutableArray`1<Diagnostic> diagnostics);
}
internal abstract class Microsoft.CodeAnalysis.ConvertAnonymousTypeToTuple.AbstractConvertAnonymousTypeToTupleCodeFixProvider`3 : SyntaxEditorBasedCodeFixProvider {
    [CompilerGeneratedAttribute]
private ImmutableArray`1<string> <FixableDiagnosticIds>k__BackingField;
    public ImmutableArray`1<string> FixableDiagnosticIds { get; }
    internal CodeFixCategory CodeFixCategory { get; }
    protected abstract virtual TTupleExpressionSyntax ConvertToTuple(TAnonymousObjectCreationExpressionSyntax anonCreation);
    [CompilerGeneratedAttribute]
public virtual ImmutableArray`1<string> get_FixableDiagnosticIds();
    internal sealed virtual CodeFixCategory get_CodeFixCategory();
    public virtual Task RegisterCodeFixesAsync(CodeFixContext context);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.ConvertAnonymousTypeToTuple.AbstractConvertAnonymousTypeToTupleCodeFixProvider`3/<FixInCurrentMemberAsync>d__7")]
private Task FixInCurrentMemberAsync(Document document, SyntaxEditor editor, Diagnostic diagnostic, CancellationToken cancellationToken);
    protected virtual Task FixAllAsync(Document document, ImmutableArray`1<Diagnostic> diagnostics, SyntaxEditor editor, CancellationToken cancellationToken);
    private void ReplaceWithTuple(SyntaxEditor editor, TAnonymousObjectCreationExpressionSyntax node);
    private static TAnonymousObjectCreationExpressionSyntax TryGetCreationNode(Diagnostic diagnostic, CancellationToken cancellationToken);
    [NullableContextAttribute("1")]
[CompilerGeneratedAttribute]
private SyntaxNode <ReplaceWithTuple>b__9_0(SyntaxNode current, SyntaxGenerator _);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal abstract class Microsoft.CodeAnalysis.ConvertAnonymousTypeToTuple.AbstractConvertAnonymousTypeToTupleDiagnosticAnalyzer`2 : AbstractBuiltInCodeStyleDiagnosticAnalyzer {
    private ISyntaxKinds _syntaxKinds;
    protected AbstractConvertAnonymousTypeToTupleDiagnosticAnalyzer`2(ISyntaxKinds syntaxKinds);
    protected abstract virtual int GetInitializerCount(TAnonymousObjectCreationExpressionSyntax anonymousType);
    public virtual DiagnosticAnalyzerCategory GetAnalyzerCategory();
    protected virtual void InitializeWorker(AnalysisContext context);
    private void AnalyzeSyntax(SyntaxNodeAnalysisContext context);
}
internal abstract class Microsoft.CodeAnalysis.ConvertAutoPropertyToFullProperty.AbstractConvertAutoPropertyToFullPropertyCodeRefactoringProvider`2 : CodeRefactoringProvider {
    internal abstract virtual Task`1<string> GetFieldNameAsync(Document document, IPropertySymbol propertySymbol, CancellationToken cancellationToken);
    internal abstract virtual ValueTuple`2<SyntaxNode, SyntaxNode> GetNewAccessors(DocumentOptionSet options, SyntaxNode property, string fieldName, SyntaxGenerator generator);
    internal abstract virtual SyntaxNode GetPropertyWithoutInitializer(SyntaxNode property);
    internal abstract virtual SyntaxNode GetInitializerValue(SyntaxNode property);
    internal abstract virtual SyntaxNode ConvertPropertyToExpressionBodyIfDesired(DocumentOptionSet options, SyntaxNode fullProperty);
    internal abstract virtual SyntaxNode GetTypeBlock(SyntaxNode syntaxNode);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.ConvertAutoPropertyToFullProperty.AbstractConvertAutoPropertyToFullPropertyCodeRefactoringProvider`2/<ComputeRefactoringsAsync>d__6")]
public virtual Task ComputeRefactoringsAsync(CodeRefactoringContext context);
    internal static bool IsValidAutoProperty(IPropertySymbol propertySymbol);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.ConvertAutoPropertyToFullProperty.AbstractConvertAutoPropertyToFullPropertyCodeRefactoringProvider`2/<GetPropertyAsync>d__8")]
private static Task`1<SyntaxNode> GetPropertyAsync(CodeRefactoringContext context);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.ConvertAutoPropertyToFullProperty.AbstractConvertAutoPropertyToFullPropertyCodeRefactoringProvider`2/<ExpandToFullPropertyAsync>d__9")]
private Task`1<Document> ExpandToFullPropertyAsync(Document document, SyntaxNode property, IPropertySymbol propertySymbol, SyntaxNode root, CancellationToken cancellationToken);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal abstract class Microsoft.CodeAnalysis.ConvertCast.AbstractConvertCastCodeRefactoringProvider`3 : CodeRefactoringProvider {
    protected int FromKind { get; }
    protected abstract virtual string GetTitle();
    protected abstract virtual int get_FromKind();
    protected abstract virtual TToExpression ConvertExpression(TFromExpression from);
    protected abstract virtual TTypeNode GetTypeNode(TFromExpression from);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.ConvertCast.AbstractConvertCastCodeRefactoringProvider`3/<ComputeRefactoringsAsync>d__5")]
public sealed virtual Task ComputeRefactoringsAsync(CodeRefactoringContext context);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.ConvertCast.AbstractConvertCastCodeRefactoringProvider`3/<ConvertAsync>d__6")]
protected Task`1<Document> ConvertAsync(Document document, TFromExpression from, CancellationToken cancellationToken);
}
internal abstract class Microsoft.CodeAnalysis.ConvertForEachToFor.AbstractConvertForEachToForCodeRefactoringProvider`2 : CodeRefactoringProvider {
    private static string get_Count;
    private static string get_Item;
    private static string Length;
    private static string Count;
    private static ImmutableArray`1<string> s_KnownInterfaceNames;
    [CompilerGeneratedAttribute]
private bool <IsForEachVariableWrittenInside>k__BackingField;
    protected bool IsForEachVariableWrittenInside { get; private set; }
    protected string Title { get; }
    private static AbstractConvertForEachToForCodeRefactoringProvider`2();
    [CompilerGeneratedAttribute]
protected bool get_IsForEachVariableWrittenInside();
    [CompilerGeneratedAttribute]
private void set_IsForEachVariableWrittenInside(bool value);
    protected abstract virtual string get_Title();
    protected abstract virtual bool ValidLocation(ForEachInfo<TStatementSyntax, TForEachStatement> foreachInfo);
    protected abstract virtual ValueTuple`2<SyntaxNode, SyntaxNode> GetForEachBody(TForEachStatement foreachStatement);
    protected abstract virtual void ConvertToForStatement(SemanticModel model, ForEachInfo<TStatementSyntax, TForEachStatement> info, SyntaxEditor editor, CancellationToken cancellationToken);
    protected abstract virtual bool IsValid(TForEachStatement foreachNode);
    protected abstract virtual bool IsSupported(ILocalSymbol foreachVariable, IForEachLoopOperation forEachOperation, TForEachStatement foreachStatement);
    protected static SyntaxAnnotation CreateWarningAnnotation();
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.ConvertForEachToFor.AbstractConvertForEachToForCodeRefactoringProvider`2/<ComputeRefactoringsAsync>d__17")]
public virtual Task ComputeRefactoringsAsync(CodeRefactoringContext context);
    protected static SyntaxToken CreateUniqueName(ISemanticFactsService semanticFacts, SemanticModel model, SyntaxNode location, string baseName, CancellationToken cancellationToken);
    protected static SyntaxNode GetCollectionVariableName(SemanticModel model, SyntaxGenerator generator, ForEachInfo<TStatementSyntax, TForEachStatement> foreachInfo, SyntaxNode foreachCollectionExpression, CancellationToken cancellationToken);
    protected static void IntroduceCollectionStatement(ForEachInfo<TStatementSyntax, TForEachStatement> foreachInfo, SyntaxEditor editor, SyntaxNode type, SyntaxNode foreachCollectionExpression, SyntaxNode collectionVariable);
    protected static TStatementSyntax AddItemVariableDeclaration(SyntaxGenerator generator, SyntaxNode type, SyntaxToken foreachVariable, ITypeSymbol castType, SyntaxNode collectionVariable, SyntaxToken indexVariable);
    private ForEachInfo<TStatementSyntax, TForEachStatement> GetForeachInfo(ISemanticFactsService semanticFact, SemanticModel model, TForEachStatement foreachStatement, CancellationToken cancellationToken);
    private static void GetInterfaceInfo(SemanticModel model, ILocalSymbol foreachVariable, IOperation foreachCollection, ITypeSymbol& explicitCastInterface, String& collectionNameSuggestion, String& countName);
    private static bool IsExchangable(ITypeSymbol type1, ITypeSymbol type2, Compilation compilation);
    private static bool IsNullOrErrorType(ITypeSymbol type);
    private static IMethodSymbol GetInterfaceMember(ITypeSymbol interfaceType, string memberName);
    private static bool CheckRequireCollectionStatement(IOperation operation);
    private IOperation RemoveImplicitConversion(IOperation collection);
    private bool CheckIfForEachVariableIsWrittenInside(SemanticModel semanticModel, ISymbol foreachVariable, TForEachStatement foreachStatement);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.ConvertForEachToFor.AbstractConvertForEachToForCodeRefactoringProvider`2/<ConvertForeachToForAsync>d__30")]
private Task`1<Document> ConvertForeachToForAsync(Document document, ForEachInfo<TStatementSyntax, TForEachStatement> foreachInfo, CancellationToken cancellationToken);
}
internal abstract class Microsoft.CodeAnalysis.ConvertForToForEach.AbstractConvertForToForEachCodeRefactoringProvider`6 : CodeRefactoringProvider {
    protected abstract virtual string GetTitle();
    protected abstract virtual SyntaxList`1<TStatementSyntax> GetBodyStatements(TForStatementSyntax forStatement);
    protected abstract virtual bool IsValidVariableDeclarator(TVariableDeclaratorSyntax firstVariable);
    protected abstract virtual bool TryGetForStatementComponents(TForStatementSyntax forStatement, SyntaxToken& iterationVariable, TExpressionSyntax& initializer, TMemberAccessExpressionSyntax& memberAccess, TExpressionSyntax& stepValueExpressionOpt, CancellationToken cancellationToken);
    protected abstract virtual SyntaxNode ConvertForNode(TForStatementSyntax currentFor, TTypeNode typeNode, SyntaxToken foreachIdentifier, TExpressionSyntax collectionExpression, ITypeSymbol iterationVariableType, OptionSet options);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.ConvertForToForEach.AbstractConvertForToForEachCodeRefactoringProvider`6/<ComputeRefactoringsAsync>d__5")]
public virtual Task ComputeRefactoringsAsync(CodeRefactoringContext context);
    private static IEnumerable`1<TSymbol> TryFindMembersInThisOrBaseTypes(INamedTypeSymbol containingType, ITypeSymbol type, string memberName);
    private static TSymbol TryFindMemberInThisOrBaseTypes(INamedTypeSymbol containingType, ITypeSymbol type, string memberName);
    private static bool TryGetIterationElementType(INamedTypeSymbol containingType, ITypeSymbol collectionType, INamedTypeSymbol ienumerableType, INamedTypeSymbol ienumeratorType, ITypeSymbol& iterationType);
    private static bool TryGetIterationElementTypeFromGetEnumerator(INamedTypeSymbol containingType, IMethodSymbol getEnumeratorMethod, INamedTypeSymbol ienumeratorType, ITypeSymbol& iterationType);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.ConvertForToForEach.AbstractConvertForToForEachCodeRefactoringProvider`6/<ConvertForToForEachAsync>d__10")]
private Task`1<Document> ConvertForToForEachAsync(Document document, TForStatementSyntax forStatement, SyntaxToken iterationVariable, TExpressionSyntax collectionExpression, INamedTypeSymbol containingType, ITypeSymbol collectionType, ITypeSymbol iterationType, CancellationToken cancellationToken);
    private static ITypeSymbol GetIndexerType(INamedTypeSymbol containingType, ITypeSymbol collectionType);
    private static bool IsViableIndexer(IPropertySymbol property);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal abstract class Microsoft.CodeAnalysis.ConvertIfToSwitch.AbstractConvertIfToSwitchCodeRefactoringProvider`4 : CodeRefactoringProvider {
    public abstract virtual string GetTitle(bool forSwitchExpression);
    public abstract virtual Analyzer<TIfStatementSyntax, TExpressionSyntax, TIsExpressionSyntax, TPatternSyntax> CreateAnalyzer(ISyntaxFacts syntaxFacts, ParseOptions options);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.ConvertIfToSwitch.AbstractConvertIfToSwitchCodeRefactoringProvider`4/<ComputeRefactoringsAsync>d__7")]
public sealed virtual Task ComputeRefactoringsAsync(CodeRefactoringContext context);
    private static bool CanConvertToSwitchExpression(bool supportsOrPattern, ImmutableArray`1<AnalyzedSwitchSection<TIfStatementSyntax, TExpressionSyntax, TIsExpressionSyntax, TPatternSyntax>> sections);
    public abstract virtual SyntaxNode CreateSwitchExpressionStatement(SyntaxNode target, ImmutableArray`1<AnalyzedSwitchSection<TIfStatementSyntax, TExpressionSyntax, TIsExpressionSyntax, TPatternSyntax>> sections, Feature<TIfStatementSyntax, TExpressionSyntax, TIsExpressionSyntax, TPatternSyntax> feature);
    public abstract virtual SyntaxNode CreateSwitchStatement(TIfStatementSyntax ifStatement, SyntaxNode target, IEnumerable`1<SyntaxNode> sectionList);
    public abstract virtual IEnumerable`1<SyntaxNode> AsSwitchSectionStatements(IOperation operation);
    [NullableContextAttribute("0")]
public abstract virtual SyntaxNode AsSwitchLabelSyntax(AnalyzedSwitchLabel<TIfStatementSyntax, TExpressionSyntax, TIsExpressionSyntax, TPatternSyntax> label, Feature<TIfStatementSyntax, TExpressionSyntax, TIsExpressionSyntax, TPatternSyntax> feature);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.ConvertIfToSwitch.AbstractConvertIfToSwitchCodeRefactoringProvider`4/<UpdateDocumentAsync>d__14")]
private Task`1<Document> UpdateDocumentAsync(Document document, SyntaxNode target, TIfStatementSyntax ifStatement, ImmutableArray`1<AnalyzedSwitchSection<TIfStatementSyntax, TExpressionSyntax, TIsExpressionSyntax, TPatternSyntax>> sections, Feature<TIfStatementSyntax, TExpressionSyntax, TIsExpressionSyntax, TPatternSyntax> feature, bool convertToSwitchExpression, CancellationToken cancellationToken);
    private SyntaxNode AsSwitchSectionSyntax(AnalyzedSwitchSection<TIfStatementSyntax, TExpressionSyntax, TIsExpressionSyntax, TPatternSyntax> section, SyntaxGenerator generator, Feature<TIfStatementSyntax, TExpressionSyntax, TIsExpressionSyntax, TPatternSyntax> feature);
    [CompilerGeneratedAttribute]
internal static OperationKind <CanConvertToSwitchExpression>g__GetSwitchArmKind|8_3(IOperation op);
    [CompilerGeneratedAttribute]
internal static bool <CanConvertToSwitchExpression>g__CanConvertSectionForSwitchExpression|8_4(bool supportsOrPattern, AnalyzedSwitchSection<TIfStatementSyntax, TExpressionSyntax, TIsExpressionSyntax, TPatternSyntax> section);
}
internal abstract class Microsoft.CodeAnalysis.ConvertLinq.AbstractConvertLinqQueryToForEachProvider`2 : CodeRefactoringProvider {
    protected string Title { get; }
    protected abstract virtual string get_Title();
    protected abstract virtual bool TryConvert(TQueryExpression queryExpression, SemanticModel semanticModel, ISemanticFactsService semanticFacts, CancellationToken cancellationToken, DocumentUpdateInfo& documentUpdate);
    protected abstract virtual Task`1<TQueryExpression> FindNodeToRefactorAsync(CodeRefactoringContext context);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.ConvertLinq.AbstractConvertLinqQueryToForEachProvider`2/<ComputeRefactoringsAsync>d__4")]
public virtual Task ComputeRefactoringsAsync(CodeRefactoringContext context);
}
internal abstract class Microsoft.CodeAnalysis.ConvertLinq.ConvertForEachToLinqQuery.AbstractConvertForEachToLinqQueryProvider`2 : CodeRefactoringProvider {
    protected abstract virtual ForEachInfo`2<TForEachStatement, TStatement> CreateForEachInfo(TForEachStatement forEachStatement, SemanticModel semanticModel, bool convertLocalDeclarations);
    protected abstract virtual bool TryBuildSpecificConverter(ForEachInfo`2<TForEachStatement, TStatement> forEachInfo, SemanticModel semanticModel, TStatement statementCannotBeConverted, CancellationToken cancellationToken, IConverter`2& converter);
    protected abstract virtual IConverter`2<TForEachStatement, TStatement> CreateDefaultConverter(ForEachInfo`2<TForEachStatement, TStatement> forEachInfo);
    protected abstract virtual SyntaxNode AddLinqUsing(IConverter`2<TForEachStatement, TStatement> converter, SemanticModel semanticModel, SyntaxNode root);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.ConvertLinq.ConvertForEachToLinqQuery.AbstractConvertForEachToLinqQueryProvider`2/<ComputeRefactoringsAsync>d__4")]
public virtual Task ComputeRefactoringsAsync(CodeRefactoringContext context);
    private Task`1<Document> ApplyConversionAsync(IConverter`2<TForEachStatement, TStatement> converter, Document document, bool convertToQuery, CancellationToken cancellationToken);
    private bool TryBuildConverter(TForEachStatement forEachStatement, SemanticModel semanticModel, bool convertLocalDeclarations, CancellationToken cancellationToken, IConverter`2& converter);
}
[IsReadOnlyAttribute]
internal class Microsoft.CodeAnalysis.ConvertLinq.ConvertForEachToLinqQuery.ExtendedSyntaxNode : ValueType {
    [CompilerGeneratedAttribute]
private SyntaxNode <Node>k__BackingField;
    [CompilerGeneratedAttribute]
private ImmutableArray`1<SyntaxTrivia> <ExtraLeadingComments>k__BackingField;
    [CompilerGeneratedAttribute]
private ImmutableArray`1<SyntaxTrivia> <ExtraTrailingComments>k__BackingField;
    public SyntaxNode Node { get; }
    public ImmutableArray`1<SyntaxTrivia> ExtraLeadingComments { get; }
    public ImmutableArray`1<SyntaxTrivia> ExtraTrailingComments { get; }
    public ExtendedSyntaxNode(SyntaxNode node, IEnumerable`1<SyntaxToken> extraLeadingTokens, IEnumerable`1<SyntaxToken> extraTrailingTokens);
    public ExtendedSyntaxNode(SyntaxNode node, IEnumerable`1<SyntaxTrivia> extraLeadingComments, IEnumerable`1<SyntaxTrivia> extraTrailingComments);
    [CompilerGeneratedAttribute]
public SyntaxNode get_Node();
    [CompilerGeneratedAttribute]
public ImmutableArray`1<SyntaxTrivia> get_ExtraLeadingComments();
    [CompilerGeneratedAttribute]
public ImmutableArray`1<SyntaxTrivia> get_ExtraTrailingComments();
}
[IsReadOnlyAttribute]
internal class Microsoft.CodeAnalysis.ConvertLinq.ConvertForEachToLinqQuery.ForEachInfo`2 : ValueType {
    [CompilerGeneratedAttribute]
private TForEachStatement <ForEachStatement>k__BackingField;
    [CompilerGeneratedAttribute]
private SemanticModel <SemanticModel>k__BackingField;
    [CompilerGeneratedAttribute]
private ImmutableArray`1<ExtendedSyntaxNode> <ConvertingExtendedNodes>k__BackingField;
    [CompilerGeneratedAttribute]
private ImmutableArray`1<SyntaxToken> <Identifiers>k__BackingField;
    [CompilerGeneratedAttribute]
private ImmutableArray`1<TStatement> <Statements>k__BackingField;
    [CompilerGeneratedAttribute]
private ImmutableArray`1<SyntaxToken> <LeadingTokens>k__BackingField;
    [CompilerGeneratedAttribute]
private ImmutableArray`1<SyntaxToken> <TrailingTokens>k__BackingField;
    public TForEachStatement ForEachStatement { get; }
    public SemanticModel SemanticModel { get; }
    public ImmutableArray`1<ExtendedSyntaxNode> ConvertingExtendedNodes { get; }
    public ImmutableArray`1<SyntaxToken> Identifiers { get; }
    public ImmutableArray`1<TStatement> Statements { get; }
    public ImmutableArray`1<SyntaxToken> LeadingTokens { get; }
    public ImmutableArray`1<SyntaxToken> TrailingTokens { get; }
    public ForEachInfo`2(TForEachStatement forEachStatement, SemanticModel semanticModel, ImmutableArray`1<ExtendedSyntaxNode> convertingExtendedNodes, ImmutableArray`1<SyntaxToken> identifiers, ImmutableArray`1<TStatement> statements, ImmutableArray`1<SyntaxToken> leadingTokens, ImmutableArray`1<SyntaxToken> trailingTokens);
    [CompilerGeneratedAttribute]
public TForEachStatement get_ForEachStatement();
    [CompilerGeneratedAttribute]
public SemanticModel get_SemanticModel();
    [CompilerGeneratedAttribute]
public ImmutableArray`1<ExtendedSyntaxNode> get_ConvertingExtendedNodes();
    [CompilerGeneratedAttribute]
public ImmutableArray`1<SyntaxToken> get_Identifiers();
    [CompilerGeneratedAttribute]
public ImmutableArray`1<TStatement> get_Statements();
    [CompilerGeneratedAttribute]
public ImmutableArray`1<SyntaxToken> get_LeadingTokens();
    [CompilerGeneratedAttribute]
public ImmutableArray`1<SyntaxToken> get_TrailingTokens();
}
internal interface Microsoft.CodeAnalysis.ConvertLinq.ConvertForEachToLinqQuery.IConverter`2 {
    public ForEachInfo`2<TForEachStatement, TStatement> ForEachInfo { get; }
    public abstract virtual ForEachInfo`2<TForEachStatement, TStatement> get_ForEachInfo();
    public abstract virtual void Convert(SyntaxEditor editor, bool convertToQuery, CancellationToken cancellationToken);
}
internal abstract class Microsoft.CodeAnalysis.ConvertNumericLiteral.AbstractConvertNumericLiteralCodeRefactoringProvider`1 : CodeRefactoringProvider {
    protected abstract virtual ValueTuple`2<string, string> GetNumericLiteralPrefixes();
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.ConvertNumericLiteral.AbstractConvertNumericLiteralCodeRefactoringProvider`1/<ComputeRefactoringsAsync>d__1")]
public sealed virtual Task ComputeRefactoringsAsync(CodeRefactoringContext context);
    private static Task`1<Document> ReplaceTokenAsync(Document document, SyntaxNode root, SyntaxToken numericToken, long value, string text, string suffix);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.ConvertNumericLiteral.AbstractConvertNumericLiteralCodeRefactoringProvider`1/<GetNumericTokenAsync>d__3")]
internal virtual Task`1<SyntaxToken> GetNumericTokenAsync(CodeRefactoringContext context);
    private static ValueTuple`3<string, string, string> GetNumericLiteralParts(string numericText, string hexPrefix, string binaryPrefix);
    private static string AddSeparators(string numericText, int interval);
    private static bool IsIntegral(SpecialType specialType);
}
internal abstract class Microsoft.CodeAnalysis.ConvertToInterpolatedString.AbstractConvertConcatenationToInterpolatedStringRefactoringProvider`1 : CodeRefactoringProvider {
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.ConvertToInterpolatedString.AbstractConvertConcatenationToInterpolatedStringRefactoringProvider`1/<ComputeRefactoringsAsync>d__0")]
public virtual Task ComputeRefactoringsAsync(CodeRefactoringContext context);
    private static Task`1<Document> UpdateDocumentAsync(Document document, SyntaxNode root, SyntaxNode top, SyntaxNode interpolatedString);
    protected SyntaxNode CreateInterpolatedString(Document document, bool isVerbatimStringLiteral, ArrayBuilder`1<SyntaxNode> pieces);
    private static SyntaxNode ConcatenateTextToTextNode(SyntaxGenerator generator, SyntaxNode interpolatedStringTextNode, string textWithoutQuotes);
    protected abstract virtual string GetTextWithoutQuotes(string text, bool isVerbatimStringLiteral, bool isCharacterLiteral);
    private void CollectPiecesDown(ISyntaxFactsService syntaxFacts, ArrayBuilder`1<SyntaxNode> pieces, SyntaxNode node, SemanticModel semanticModel, CancellationToken cancellationToken);
    private static bool IsStringConcat(ISyntaxFactsService syntaxFacts, SyntaxNode expression, SemanticModel semanticModel, CancellationToken cancellationToken);
}
internal abstract class Microsoft.CodeAnalysis.ConvertToInterpolatedString.AbstractConvertPlaceholderToInterpolatedStringRefactoringProvider`5 : CodeRefactoringProvider {
    protected abstract virtual SyntaxNode GetInterpolatedString(string text);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.ConvertToInterpolatedString.AbstractConvertPlaceholderToInterpolatedStringRefactoringProvider`5/<ComputeRefactoringsAsync>d__1")]
public virtual Task ComputeRefactoringsAsync(CodeRefactoringContext context);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.ConvertToInterpolatedString.AbstractConvertPlaceholderToInterpolatedStringRefactoringProvider`5/<TryFindInvocationAsync>d__2")]
private Task`1<ValueTuple`2<TInvocationExpressionSyntax, ISymbol>> TryFindInvocationAsync(TextSpan span, Document document, SemanticModel semanticModel, ImmutableArray`1<IMethodSymbol> formatMethods, ISyntaxFactsService syntaxFactsService, CancellationToken cancellationToken);
    private static bool IsArgumentListCorrect(Nullable`1<SeparatedSyntaxList`1<TArgumentSyntax>> nullableArguments, ISymbol invocationSymbol, ImmutableArray`1<IMethodSymbol> formatMethods, SemanticModel semanticModel, ISyntaxFactsService syntaxFactsService, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.ConvertToInterpolatedString.AbstractConvertPlaceholderToInterpolatedStringRefactoringProvider`5/<CreateInterpolatedStringAsync>d__4")]
private Task`1<Document> CreateInterpolatedStringAsync(TInvocationExpressionSyntax invocation, Document document, ISyntaxFactsService syntaxFactsService, CancellationToken cancellationToken);
    private static string GetArgumentName(TArgumentSyntax argument, ISyntaxFacts syntaxFacts);
    private static SyntaxNode GetParamsArgument(SeparatedSyntaxList`1<TArgumentSyntax> arguments, ISyntaxFactsService syntaxFactsService);
    private static TArgumentSyntax GetFormatArgument(SeparatedSyntaxList`1<TArgumentSyntax> arguments, ISyntaxFactsService syntaxFactsService);
    private static TArgumentSyntax GetArgument(SeparatedSyntaxList`1<TArgumentSyntax> arguments, int index, ISyntaxFacts syntaxFacts);
    private static ImmutableArray`1<TExpressionSyntax> GetExpandedArguments(SemanticModel semanticModel, SeparatedSyntaxList`1<TArgumentSyntax> arguments, SyntaxGenerator syntaxGenerator, ISyntaxFacts syntaxFacts);
    private static SyntaxNode VisitArguments(ImmutableArray`1<TExpressionSyntax> expandedArguments, SyntaxNode interpolatedString, ISyntaxFactsService syntaxFactsService);
    private static bool ShouldIncludeFormatMethod(IMethodSymbol methodSymbol);
    private static bool IsArgumentListNotPassingArrayToParams(SyntaxNode expression, ISymbol invocationSymbol, ImmutableArray`1<IMethodSymbol> formatMethods, SemanticModel semanticModel, CancellationToken cancellationToken);
    [CompilerGeneratedAttribute]
internal static bool <TryFindInvocationAsync>g__IsValidPlaceholderToInterpolatedString|2_1(TInvocationExpressionSyntax invocation, ISyntaxFactsService syntaxFactsService, SemanticModel semanticModel, ImmutableArray`1<IMethodSymbol> formatMethods, AbstractConvertPlaceholderToInterpolatedStringRefactoringProvider`5<TInvocationExpressionSyntax, TExpressionSyntax, TArgumentSyntax, TLiteralExpressionSyntax, TArgumentListExpressionSyntax> thisInstance, CancellationToken cancellationToken);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExportCodeRefactoringProviderAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.ConvertToInterpolatedString.ConvertRegularStringToInterpolatedStringRefactoringProvider : CodeRefactoringProvider {
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.ConvertToInterpolatedString.ConvertRegularStringToInterpolatedStringRefactoringProvider/<ComputeRefactoringsAsync>d__1")]
public virtual Task ComputeRefactoringsAsync(CodeRefactoringContext context);
    private static string GetTextWithoutQuotes(string text, bool isVerbatim);
    private static SyntaxNode CreateInterpolatedString(Document document, SyntaxNode literalExpression, bool isVerbatim);
    private static Task`1<Document> UpdateDocumentAsync(Document document, SyntaxNode root, SyntaxToken token);
}
internal abstract class Microsoft.CodeAnalysis.ConvertTupleToStruct.AbstractConvertTupleToStructCodeRefactoringProvider`10 : CodeRefactoringProvider {
    protected abstract virtual TArgumentSyntax GetArgumentWithChangedName(TArgumentSyntax argument, string name);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.ConvertTupleToStruct.AbstractConvertTupleToStructCodeRefactoringProvider`10/<ComputeRefactoringsAsync>d__1")]
public virtual Task ComputeRefactoringsAsync(CodeRefactoringContext context);
    private CodeAction CreateAction(CodeRefactoringContext context, Scope scope);
    private static string GetTitle(Scope scope);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.ConvertTupleToStruct.AbstractConvertTupleToStructCodeRefactoringProvider`10/<TryGetTupleInfoAsync>d__4")]
private static Task`1<ValueTuple`2<SyntaxNode, INamedTypeSymbol>> TryGetTupleInfoAsync(Document document, TextSpan span, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.ConvertTupleToStruct.AbstractConvertTupleToStructCodeRefactoringProvider`10/<ConvertToStructAsync>d__5")]
public sealed virtual Task`1<Solution> ConvertToStructAsync(Document document, TextSpan span, Scope scope, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.ConvertTupleToStruct.AbstractConvertTupleToStructCodeRefactoringProvider`10/<AddRenameTokenAsync>d__6")]
private static Task`1<Solution> AddRenameTokenAsync(Solution solution, ValueTuple`2<DocumentId, TextSpan> renamedToken, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.ConvertTupleToStruct.AbstractConvertTupleToStructCodeRefactoringProvider`10/<ConvertToStructInCurrentProcessAsync>d__7")]
private Task`1<Solution> ConvertToStructInCurrentProcessAsync(Document document, TextSpan span, Scope scope, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.ConvertTupleToStruct.AbstractConvertTupleToStructCodeRefactoringProvider`10/<ReplaceExpressionAndTypesInScopeAsync>d__8")]
private Task ReplaceExpressionAndTypesInScopeAsync(Dictionary`2<Document, SyntaxEditor> documentToEditorMap, ImmutableArray`1<DocumentToUpdate> documentsToUpdate, SyntaxNode tupleExprOrTypeNode, INamedTypeSymbol tupleType, string structName, ImmutableArray`1<ITypeParameterSymbol> typeParameters, INamespaceSymbol containingNamespace, NamingRule parameterNamingRule, CancellationToken cancellationToken);
    private static TNameSyntax CreateStructNameNode(SyntaxGenerator generator, string structName, ImmutableArray`1<ITypeParameterSymbol> typeParameters, bool addRenameAnnotation);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.ConvertTupleToStruct.AbstractConvertTupleToStructCodeRefactoringProvider`10/<GetDocumentsToUpdateAsync>d__10")]
private static Task`1<ImmutableArray`1<DocumentToUpdate>> GetDocumentsToUpdateAsync(Document document, SyntaxNode tupleExprOrTypeNode, INamedTypeSymbol tupleType, Scope scope, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.ConvertTupleToStruct.AbstractConvertTupleToStructCodeRefactoringProvider`10/<GetDocumentsToUpdateForDependentProjectAsync>d__11")]
private static Task`1<ImmutableArray`1<DocumentToUpdate>> GetDocumentsToUpdateForDependentProjectAsync(Project startingProject, INamedTypeSymbol tupleType, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.ConvertTupleToStruct.AbstractConvertTupleToStructCodeRefactoringProvider`10/<GetDocumentsToUpdateForContainingProjectAsync>d__12")]
private static Task`1<ImmutableArray`1<DocumentToUpdate>> GetDocumentsToUpdateForContainingProjectAsync(Project project, INamedTypeSymbol tupleType, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.ConvertTupleToStruct.AbstractConvertTupleToStructCodeRefactoringProvider`10/<AddDocumentsToUpdateForProjectAsync>d__13")]
private static Task AddDocumentsToUpdateForProjectAsync(Project project, ArrayBuilder`1<DocumentToUpdate> result, ImmutableArray`1<string> tupleFieldNames, CancellationToken cancellationToken);
    private static bool InfoProbablyContainsTupleFieldNames(SyntaxTreeIndex info, ImmutableArray`1<string> tupleFieldNames);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.ConvertTupleToStruct.AbstractConvertTupleToStructCodeRefactoringProvider`10/<GetDocumentsToUpdateForContainingTypeAsync>d__15")]
private static Task`1<ImmutableArray`1<DocumentToUpdate>> GetDocumentsToUpdateForContainingTypeAsync(Document startingDocument, SyntaxNode tupleExprOrTypeNode, CancellationToken cancellationToken);
    private static ImmutableArray`1<DocumentToUpdate> GetDocumentsToUpdateForContainingMember(Document document, SyntaxNode tupleExprOrTypeNode);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.ConvertTupleToStruct.AbstractConvertTupleToStructCodeRefactoringProvider`10/<GenerateStructIntoContainingNamespaceAsync>d__17")]
private static Task GenerateStructIntoContainingNamespaceAsync(Document document, SyntaxNode tupleExprOrTypeNode, INamedTypeSymbol namedTypeSymbol, Dictionary`2<Document, SyntaxEditor> documentToEditorMap, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.ConvertTupleToStruct.AbstractConvertTupleToStructCodeRefactoringProvider`10/<ApplyChangesAsync>d__18")]
private static Task`1<Solution> ApplyChangesAsync(Document startingDocument, Dictionary`2<Document, SyntaxEditor> documentToEditorMap, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.ConvertTupleToStruct.AbstractConvertTupleToStructCodeRefactoringProvider`10/<ReplaceTupleExpressionsAndTypesInDocumentAsync>d__19")]
private Task`1<bool> ReplaceTupleExpressionsAndTypesInDocumentAsync(Document document, NamingRule parameterNamingRule, SyntaxEditor editor, SyntaxNode startingNode, INamedTypeSymbol tupleType, TNameSyntax fullyQualifiedStructName, string structName, ImmutableArray`1<ITypeParameterSymbol> typeParameters, SyntaxNode containerToUpdate, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.ConvertTupleToStruct.AbstractConvertTupleToStructCodeRefactoringProvider`10/<ReplaceMatchingTupleExpressionsAsync>d__20")]
private Task`1<bool> ReplaceMatchingTupleExpressionsAsync(Document document, NamingRule parameterNamingRule, SyntaxEditor editor, SyntaxNode startingNode, INamedTypeSymbol tupleType, TNameSyntax qualifiedTypeName, string typeName, ImmutableArray`1<ITypeParameterSymbol> typeParameters, SyntaxNode containingMember, CancellationToken cancellationToken);
    private static bool AreEquivalent(StringComparer comparer, INamedTypeSymbol tupleType, INamedTypeSymbol childType);
    private static bool NamesMatch(StringComparer comparer, ImmutableArray`1<IFieldSymbol> fields1, ImmutableArray`1<IFieldSymbol> fields2);
    private void ReplaceWithObjectCreation(SyntaxEditor editor, string typeName, ImmutableArray`1<ITypeParameterSymbol> typeParameters, TNameSyntax qualifiedTypeName, SyntaxNode startingCreationNode, TTupleExpressionSyntax childCreation, NamingRule parameterNamingRule);
    private SeparatedSyntaxList`1<TArgumentSyntax> ConvertArguments(SyntaxGenerator generator, NamingRule parameterNamingRule, SeparatedSyntaxList`1<TArgumentSyntax> arguments);
    private SyntaxNodeOrTokenList ConvertArguments(SyntaxGenerator generator, NamingRule parameterNamingRule, SyntaxNodeOrTokenList list);
    private SyntaxNodeOrToken ConvertArgumentOrToken(SyntaxGenerator generator, NamingRule parameterNamingRule, SyntaxNodeOrToken arg);
    private TArgumentSyntax ConvertArgument(SyntaxGenerator generator, NamingRule parameterNamingRule, TArgumentSyntax argument);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.ConvertTupleToStruct.AbstractConvertTupleToStructCodeRefactoringProvider`10/<ReplaceMatchingTupleTypesAsync>d__28")]
private static Task`1<bool> ReplaceMatchingTupleTypesAsync(Document document, SyntaxEditor editor, SyntaxNode startingNode, INamedTypeSymbol tupleType, TNameSyntax qualifiedTypeName, string typeName, ImmutableArray`1<ITypeParameterSymbol> typeParameters, SyntaxNode containingMember, CancellationToken cancellationToken);
    private static void ReplaceWithTypeNode(SyntaxEditor editor, string typeName, ImmutableArray`1<ITypeParameterSymbol> typeParameters, TNameSyntax qualifiedTypeName, SyntaxNode startingNode, TTupleTypeSyntax childTupleType);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.ConvertTupleToStruct.AbstractConvertTupleToStructCodeRefactoringProvider`10/<GenerateFinalNamedTypeAsync>d__30")]
private static Task`1<INamedTypeSymbol> GenerateFinalNamedTypeAsync(Document document, Scope scope, string structName, ImmutableArray`1<ITypeParameterSymbol> typeParameters, INamedTypeSymbol tupleType, NamingRule parameterNamingRule, CancellationToken cancellationToken);
    private static IMethodSymbol GenerateDeconstructMethod(SemanticModel model, SyntaxGenerator generator, INamedTypeSymbol tupleType, IMethodSymbol constructor);
    private static void AddConversions(SyntaxGenerator generator, ArrayBuilder`1<ISymbol> members, INamedTypeSymbol tupleType, INamedTypeSymbol structType);
    private static INamedTypeSymbol CreateNamedType(IAssemblySymbol containingAssembly, Scope scope, string structName, ImmutableArray`1<ITypeParameterSymbol> typeParameters, ImmutableArray`1<ISymbol> members);
    private static IMethodSymbol CreateConstructor(SemanticModel semanticModel, string className, ImmutableArray`1<IFieldSymbol> fields, SyntaxGenerator generator, NamingRule parameterNamingRule);
    private static string GetConstructorParameterName(NamingRule parameterNamingRule, string name);
}
[IsReadOnlyAttribute]
internal class Microsoft.CodeAnalysis.ConvertTupleToStruct.DocumentToUpdate : ValueType {
    public Document Document;
    public ImmutableArray`1<SyntaxNode> NodesToUpdate;
    public DocumentToUpdate(Document document, ImmutableArray`1<SyntaxNode> nodesToUpdate);
}
internal interface Microsoft.CodeAnalysis.ConvertTupleToStruct.IConvertTupleToStructCodeRefactoringProvider {
    public abstract virtual Task`1<Solution> ConvertToStructAsync(Document document, TextSpan span, Scope scope, CancellationToken cancellationToken);
}
internal interface Microsoft.CodeAnalysis.ConvertTupleToStruct.IRemoteConvertTupleToStructCodeRefactoringService {
    public abstract virtual ValueTask`1<SerializableConvertTupleToStructResult> ConvertToStructAsync(PinnedSolutionInfo solutionInfo, DocumentId documentId, TextSpan span, Scope scope, CancellationToken cancellationToken);
}
internal enum Microsoft.CodeAnalysis.ConvertTupleToStruct.Scope : Enum {
    public int value__;
    public static Scope ContainingMember;
    public static Scope ContainingType;
    public static Scope ContainingProject;
    public static Scope DependentProjects;
}
[IsReadOnlyAttribute]
[DataContractAttribute]
internal class Microsoft.CodeAnalysis.ConvertTupleToStruct.SerializableConvertTupleToStructResult : ValueType {
    [DataMemberAttribute]
public ImmutableArray`1<ValueTuple`2<DocumentId, ImmutableArray`1<TextChange>>> DocumentTextChanges;
    [DataMemberAttribute]
public ValueTuple`2<DocumentId, TextSpan> RenamedToken;
    public SerializableConvertTupleToStructResult(ImmutableArray`1<ValueTuple`2<DocumentId, ImmutableArray`1<TextChange>>> documentTextChanges, ValueTuple`2<DocumentId, TextSpan> renamedToken);
}
internal abstract class Microsoft.CodeAnalysis.ConvertTypeOfToNameOf.AbstractConvertTypeOfToNameOfCodeFixProvider : SyntaxEditorBasedCodeFixProvider {
    private static string s_codeFixTitle;
    public ImmutableArray`1<string> FixableDiagnosticIds { get; }
    internal CodeFixCategory CodeFixCategory { get; }
    public sealed virtual ImmutableArray`1<string> get_FixableDiagnosticIds();
    internal sealed virtual CodeFixCategory get_CodeFixCategory();
    public virtual Task RegisterCodeFixesAsync(CodeFixContext context);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.ConvertTypeOfToNameOf.AbstractConvertTypeOfToNameOfCodeFixProvider/<FixAllAsync>d__7")]
protected virtual Task FixAllAsync(Document document, ImmutableArray`1<Diagnostic> diagnostics, SyntaxEditor editor, CancellationToken cancellationToken);
    public void ConvertTypeOfToNameOf(SemanticModel semanticModel, SyntaxEditor editor, SyntaxNode nodeToReplace);
    protected abstract virtual SyntaxNode GetSymbolTypeExpression(SemanticModel model, SyntaxNode node);
    protected abstract virtual string GetCodeFixTitle();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal abstract class Microsoft.CodeAnalysis.ConvertTypeOfToNameOf.AbstractConvertTypeOfToNameOfDiagnosticAnalyzer : AbstractBuiltInCodeStyleDiagnosticAnalyzer {
    protected AbstractConvertTypeOfToNameOfDiagnosticAnalyzer(LocalizableString title, string language);
    public virtual DiagnosticAnalyzerCategory GetAnalyzerCategory();
    protected abstract virtual bool IsValidTypeofAction(OperationAnalysisContext context);
    protected virtual void InitializeWorker(AnalysisContext context);
    protected void AnalyzeAction(OperationAnalysisContext context);
    private static bool IsValidOperation(IOperation operation);
}
internal abstract class Microsoft.CodeAnalysis.CSharp.Completion.Providers.AbstractPreprocessorCompletionProvider : LSPCompletionProvider {
    [NullableContextAttribute("1")]
[AsyncStateMachineAttribute("Microsoft.CodeAnalysis.CSharp.Completion.Providers.AbstractPreprocessorCompletionProvider/<ProvideCompletionsAsync>d__0")]
public sealed virtual Task ProvideCompletionsAsync(CompletionContext context);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal abstract class Microsoft.CodeAnalysis.CSharp.ConvertAnonymousTypeToClass.AbstractConvertAnonymousTypeToClassCodeRefactoringProvider`6 : CodeRefactoringProvider {
    protected abstract virtual TObjectCreationExpressionSyntax CreateObjectCreationExpression(TNameSyntax nameNode, TAnonymousObjectCreationExpressionSyntax currentAnonymousObject);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.CSharp.ConvertAnonymousTypeToClass.AbstractConvertAnonymousTypeToClassCodeRefactoringProvider`6/<ComputeRefactoringsAsync>d__1")]
public virtual Task ComputeRefactoringsAsync(CodeRefactoringContext context);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.CSharp.ConvertAnonymousTypeToClass.AbstractConvertAnonymousTypeToClassCodeRefactoringProvider`6/<TryGetAnonymousObjectAsync>d__2")]
private static Task`1<ValueTuple`2<TAnonymousObjectCreationExpressionSyntax, INamedTypeSymbol>> TryGetAnonymousObjectAsync(Document document, TextSpan span, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.CSharp.ConvertAnonymousTypeToClass.AbstractConvertAnonymousTypeToClassCodeRefactoringProvider`6/<ConvertAsync>d__3")]
private Task`1<Document> ConvertAsync(Document document, TextSpan span, bool isRecord, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.CSharp.ConvertAnonymousTypeToClass.AbstractConvertAnonymousTypeToClassCodeRefactoringProvider`6/<ReplacePropertyReferencesAsync>d__4")]
private static Task ReplacePropertyReferencesAsync(Document document, SyntaxEditor editor, SyntaxNode containingMember, ImmutableDictionary`2<IPropertySymbol, string> propertyMap, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.CSharp.ConvertAnonymousTypeToClass.AbstractConvertAnonymousTypeToClassCodeRefactoringProvider`6/<ReplaceMatchingAnonymousTypesAsync>d__5")]
private Task ReplaceMatchingAnonymousTypesAsync(Document document, SyntaxEditor editor, INamedTypeSymbol classSymbol, SyntaxNode containingMember, TAnonymousObjectCreationExpressionSyntax creationNode, INamedTypeSymbol anonymousType, CancellationToken cancellationToken);
    private void ReplaceWithObjectCreation(SyntaxEditor editor, INamedTypeSymbol classSymbol, TAnonymousObjectCreationExpressionSyntax startingCreationNode, TAnonymousObjectCreationExpressionSyntax childCreation);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.CSharp.ConvertAnonymousTypeToClass.AbstractConvertAnonymousTypeToClassCodeRefactoringProvider`6/<GenerateFinalNamedTypeAsync>d__7")]
private static Task`1<INamedTypeSymbol> GenerateFinalNamedTypeAsync(Document document, string typeName, bool isRecord, ImmutableArray`1<IPropertySymbol> properties, CancellationToken cancellationToken);
    private static INamedTypeSymbol CreateNamedType(string className, bool isRecord, ImmutableArray`1<ITypeParameterSymbol> capturedTypeParameters, ImmutableArray`1<ISymbol> members);
    private static ValueTuple`2<ImmutableArray`1<IPropertySymbol>, ImmutableDictionary`2<IPropertySymbol, string>> GenerateProperties(Document document, INamedTypeSymbol anonymousType);
    private static IPropertySymbol GenerateProperty(Document document, IPropertySymbol prop);
    private static string GetLegalName(string name, Document document);
    private static IMethodSymbol CreateAccessorSymbol(IPropertySymbol prop, MethodKind kind);
    private static IMethodSymbol CreateClassConstructor(SemanticModel semanticModel, string className, ImmutableArray`1<IPropertySymbol> properties, SyntaxGenerator generator);
}
internal abstract class Microsoft.CodeAnalysis.Debugging.AbstractBreakpointResolver : object {
    private static SymbolDisplayFormat s_vsDebugNameFormat;
    protected string Text;
    private string _language;
    private Solution _solution;
    private IEqualityComparer`1<string> _identifierComparer;
    protected AbstractBreakpointResolver(Solution solution, string text, string language, IEqualityComparer`1<string> identifierComparer);
    private static AbstractBreakpointResolver();
    protected abstract virtual void ParseText(IList`1& nameParts, Nullable`1& parameterCount);
    protected abstract virtual IEnumerable`1<ISymbol> GetMembers(INamedTypeSymbol type, string name);
    protected abstract virtual bool HasMethodBody(IMethodSymbol method, CancellationToken cancellationToken);
    private BreakpointResolutionResult CreateBreakpoint(ISymbol methodSymbol);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.Debugging.AbstractBreakpointResolver/<DoAsync>d__10")]
public Task`1<IEnumerable`1<BreakpointResolutionResult>> DoAsync(CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.Debugging.AbstractBreakpointResolver/<FindMembersAsync>d__11")]
private Task`1<IEnumerable`1<ISymbol>> FindMembersAsync(IList`1<NameAndArity> nameParts, CancellationToken cancellationToken);
    private static bool MatchesName(INamespaceOrTypeSymbol typeOrNamespace, NameAndArity nameAndArity, IEqualityComparer`1<string> comparer);
    private static bool MatchesNames(INamedTypeSymbol type, NameAndArity[] names, IEqualityComparer`1<string> comparer);
    private IEnumerable`1<ISymbol> FindMembers(IEnumerable`1<INamespaceOrTypeSymbol> containers, NameAndArity[] names);
    private IEnumerable`1<ISymbol> FindMembers(IEnumerable`1<INamedTypeSymbol> types, NameAndArity nameAndArity);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.Debugging.AbstractBreakpointResolver/<GetAllTypesAsync>d__16")]
private Task`1<IEnumerable`1<INamedTypeSymbol>> GetAllTypesAsync(CancellationToken cancellationToken);
    private static IMethodSymbol GetPartialImplementationPartOrNull(ISymbol symbol);
    private bool IsApplicable(ISymbol methodOrProperty, Nullable`1<int> parameterCount, CancellationToken cancellationToken);
    private static bool IsMismatch(ISymbol methodOrProperty, Nullable`1<int> parameterCount);
    private static IEnumerable`1<INamedTypeSymbol> GetTypeMembersRecursive(INamespaceOrTypeSymbol container);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.CodeAnalysis.Debugging.BreakpointResolutionResult : object {
    [CompilerGeneratedAttribute]
private Document <Document>k__BackingField;
    [CompilerGeneratedAttribute]
private TextSpan <TextSpan>k__BackingField;
    [NullableAttribute("2")]
[CompilerGeneratedAttribute]
private string <LocationNameOpt>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsLineBreakpoint>k__BackingField;
    public Document Document { get; }
    public TextSpan TextSpan { get; }
    [NullableAttribute("2")]
public string LocationNameOpt { get; }
    public bool IsLineBreakpoint { get; }
    private BreakpointResolutionResult(Document document, TextSpan textSpan, string locationNameOpt, bool isLineBreakpoint);
    [CompilerGeneratedAttribute]
public Document get_Document();
    [CompilerGeneratedAttribute]
public TextSpan get_TextSpan();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public string get_LocationNameOpt();
    [CompilerGeneratedAttribute]
public bool get_IsLineBreakpoint();
    internal static BreakpointResolutionResult CreateSpanResult(Document document, TextSpan textSpan, string locationNameOpt);
    internal static BreakpointResolutionResult CreateLineResult(Document document, string locationNameOpt);
}
internal static class Microsoft.CodeAnalysis.Debugging.CustomDebugInfoConstants : object {
    internal static byte Version;
    internal static int GlobalHeaderSize;
    internal static int RecordHeaderSize;
}
internal class Microsoft.CodeAnalysis.Debugging.CustomDebugInfoEncoder : ValueType {
    [CompilerGeneratedAttribute]
private BlobBuilder <Builder>k__BackingField;
    private Blob _recordCountFixup;
    private int _recordCount;
    internal static int DynamicAttributeSize;
    internal static int IdentifierSize;
    public BlobBuilder Builder { get; }
    public int RecordCount { get; }
    public CustomDebugInfoEncoder(BlobBuilder builder);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public BlobBuilder get_Builder();
    public int get_RecordCount();
    public Byte[] ToArray();
    public void AddStateMachineTypeName(string typeName);
    public void AddForwardMethodInfo(MethodDefinitionHandle methodHandle);
    public void AddForwardModuleInfo(MethodDefinitionHandle methodHandle);
    public void AddUsingGroups(IReadOnlyCollection`1<int> groupSizes);
    public void AddStateMachineHoistedLocalScopes(ImmutableArray`1<StateMachineHoistedLocalScope> scopes);
    public void AddDynamicLocals(IReadOnlyCollection`1<ValueTuple`4<string, Byte[], int, int>> dynamicLocals);
    public void AddTupleElementNames(IReadOnlyCollection`1<ValueTuple`5<string, int, int, int, ImmutableArray`1<string>>> tupleLocals);
    public void AddRecord(CustomDebugInfoKind kind, T debugInfo, Action`2<T, BlobBuilder> recordSerializer);
}
internal enum Microsoft.CodeAnalysis.Debugging.CustomDebugInfoKind : Enum {
    public byte value__;
    public static CustomDebugInfoKind UsingGroups;
    public static CustomDebugInfoKind ForwardMethodInfo;
    public static CustomDebugInfoKind ForwardModuleInfo;
    public static CustomDebugInfoKind StateMachineHoistedLocalScopes;
    public static CustomDebugInfoKind StateMachineTypeName;
    public static CustomDebugInfoKind DynamicLocals;
    public static CustomDebugInfoKind EditAndContinueLocalSlotMap;
    public static CustomDebugInfoKind EditAndContinueLambdaMap;
    public static CustomDebugInfoKind TupleElementNames;
}
internal static class Microsoft.CodeAnalysis.Debugging.CustomDebugInfoReader : object {
    private static void ReadGlobalHeader(Byte[] bytes, Int32& offset, Byte& version, Byte& count);
    private static void ReadRecordHeader(Byte[] bytes, Int32& offset, Byte& version, CustomDebugInfoKind& kind, Int32& size, Int32& alignmentSize);
    public static ImmutableArray`1<byte> TryGetCustomDebugInfoRecord(Byte[] customDebugInfo, CustomDebugInfoKind recordKind);
    [IteratorStateMachineAttribute("Microsoft.CodeAnalysis.Debugging.CustomDebugInfoReader/<GetCustomDebugInfoRecords>d__3")]
public static IEnumerable`1<CustomDebugInfoRecord> GetCustomDebugInfoRecords(Byte[] customDebugInfo);
    public static ImmutableArray`1<short> DecodeUsingRecord(ImmutableArray`1<byte> bytes);
    public static int DecodeForwardRecord(ImmutableArray`1<byte> bytes);
    public static int DecodeForwardToModuleRecord(ImmutableArray`1<byte> bytes);
    public static ImmutableArray`1<StateMachineHoistedLocalScope> DecodeStateMachineHoistedLocalScopesRecord(ImmutableArray`1<byte> bytes);
    public static string DecodeForwardIteratorRecord(ImmutableArray`1<byte> bytes);
    public static ImmutableArray`1<DynamicLocalInfo> DecodeDynamicLocalsRecord(ImmutableArray`1<byte> bytes);
    public static ImmutableArray`1<TupleElementNamesInfo> DecodeTupleElementNamesRecord(ImmutableArray`1<byte> bytes);
    private static TupleElementNamesInfo DecodeTupleElementNamesInfo(ImmutableArray`1<byte> bytes, Int32& offset);
    private static void ReadRawRecordBody(Byte[] bytes, Int32& offset, int size, ImmutableArray`1& body);
    private static void SkipRecord(Byte[] bytes, Int32& offset, int size);
    public static ImmutableArray`1<ImmutableArray`1<string>> GetCSharpGroupedImportStrings(int methodToken, TArg arg, Func`3<int, TArg, Byte[]> getMethodCustomDebugInfo, Func`3<int, TArg, ImmutableArray`1<string>> getMethodImportStrings, ImmutableArray`1& externAliasStrings);
    public static ImmutableArray`1<string> GetVisualBasicImportStrings(int methodToken, TArg arg, Func`3<int, TArg, ImmutableArray`1<string>> getMethodImportStrings);
    private static void CheckVersion(byte globalVersion, int methodToken);
    private static int ReadInt32(ImmutableArray`1<byte> bytes, Int32& offset);
    private static short ReadInt16(ImmutableArray`1<byte> bytes, Int32& offset);
    private static byte ReadByte(ImmutableArray`1<byte> bytes, Int32& offset);
    private static bool IsCSharpExternAliasInfo(string import);
    public static bool TryParseCSharpImportString(string import, String& alias, String& externAlias, String& target, ImportTargetKind& kind);
    public static bool TryParseVisualBasicImportString(string import, String& alias, String& target, ImportTargetKind& kind, VBImportScopeKind& scope);
    private static bool TrySplit(string input, int offset, char separator, String& before, String& after);
    private static string FormatMethodToken(int methodToken);
    private static string ReadUtf8String(ImmutableArray`1<byte> bytes, Int32& offset);
}
internal class Microsoft.CodeAnalysis.Debugging.CustomDebugInfoRecord : ValueType {
    public CustomDebugInfoKind Kind;
    public byte Version;
    public ImmutableArray`1<byte> Data;
    public CustomDebugInfoRecord(CustomDebugInfoKind kind, byte version, ImmutableArray`1<byte> data);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[IsReadOnlyAttribute]
internal class Microsoft.CodeAnalysis.Debugging.DebugDataTipInfo : ValueType {
    public TextSpan Span;
    public string Text;
    public bool IsDefault { get; }
    public DebugDataTipInfo(TextSpan span, string text);
    public bool get_IsDefault();
}
internal enum Microsoft.CodeAnalysis.Debugging.DebuggingState : Enum {
    public int value__;
    public static DebuggingState Design;
    public static DebuggingState Run;
    public static DebuggingState Break;
}
[IsReadOnlyAttribute]
internal class Microsoft.CodeAnalysis.Debugging.DebuggingStateChangedEventArgs : ValueType {
    public DebuggingState Before;
    public DebuggingState After;
    public DebuggingStateChangedEventArgs(DebuggingState before, DebuggingState after);
}
internal class Microsoft.CodeAnalysis.Debugging.DebuggingWorkspaceService : object {
    [CompilerGeneratedAttribute]
private EventHandler`1<DebuggingStateChangedEventArgs> BeforeDebuggingStateChanged;
    [CompilerGeneratedAttribute]
public sealed virtual void add_BeforeDebuggingStateChanged(EventHandler`1<DebuggingStateChangedEventArgs> value);
    [CompilerGeneratedAttribute]
public sealed virtual void remove_BeforeDebuggingStateChanged(EventHandler`1<DebuggingStateChangedEventArgs> value);
    public sealed virtual void OnBeforeDebuggingStateChanged(DebuggingState before, DebuggingState after);
}
[ExportWorkspaceServiceFactoryAttribute("Microsoft.CodeAnalysis.Debugging.IDebuggingWorkspaceService", "Host")]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.Debugging.DebuggingWorkspaceServiceFactory : object {
    public sealed virtual IWorkspaceService CreateService(HostWorkspaceServices workspaceServices);
}
internal abstract class Microsoft.CodeAnalysis.Debugging.DebugInformationReaderProvider : object {
    public abstract virtual void Dispose();
    public abstract virtual EditAndContinueMethodDebugInfoReader CreateEditAndContinueMethodDebugInfoReader();
    public static DebugInformationReaderProvider CreateFromStream(Stream stream);
    public static DebugInformationReaderProvider CreateFromMetadataReader(MetadataReaderProvider metadataProvider);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[IsReadOnlyAttribute]
internal class Microsoft.CodeAnalysis.Debugging.DebugLocationInfo : ValueType {
    public string Name;
    public int LineOffset;
    public bool IsDefault { get; }
    public DebugLocationInfo(string name, int lineOffset);
    public bool get_IsDefault();
}
internal enum Microsoft.CodeAnalysis.Debugging.DebugMode : Enum {
    public int value__;
    public static DebugMode Design;
    public static DebugMode Break;
    public static DebugMode Run;
}
internal class Microsoft.CodeAnalysis.Debugging.DynamicLocalInfo : ValueType {
    public ImmutableArray`1<bool> Flags;
    public int SlotId;
    public string LocalName;
    public DynamicLocalInfo(ImmutableArray`1<bool> flags, int slotId, string localName);
}
[NullableContextAttribute("1")]
internal interface Microsoft.CodeAnalysis.Debugging.IBreakpointResolutionService {
    public abstract virtual Task`1<BreakpointResolutionResult> ResolveBreakpointAsync(Document document, TextSpan textSpan, CancellationToken cancellationToken);
    public abstract virtual Task`1<IEnumerable`1<BreakpointResolutionResult>> ResolveBreakpointsAsync(Solution solution, string name, CancellationToken cancellationToken);
}
internal interface Microsoft.CodeAnalysis.Debugging.IDebuggingWorkspaceService {
    [CompilerGeneratedAttribute]
public abstract virtual void add_BeforeDebuggingStateChanged(EventHandler`1<DebuggingStateChangedEventArgs> value);
    [CompilerGeneratedAttribute]
public abstract virtual void remove_BeforeDebuggingStateChanged(EventHandler`1<DebuggingStateChangedEventArgs> value);
    public abstract virtual void OnBeforeDebuggingStateChanged(DebuggingState before, DebuggingState after);
}
[NullableContextAttribute("1")]
internal interface Microsoft.CodeAnalysis.Debugging.ILanguageDebugInfoService {
    public abstract virtual Task`1<DebugLocationInfo> GetLocationInfoAsync(Document document, int position, CancellationToken cancellationToken);
    public abstract virtual Task`1<DebugDataTipInfo> GetDataTipInfoAsync(Document document, int position, CancellationToken cancellationToken);
}
internal enum Microsoft.CodeAnalysis.Debugging.ImportTargetKind : Enum {
    public int value__;
    public static ImportTargetKind Namespace;
    public static ImportTargetKind Type;
    public static ImportTargetKind NamespaceOrType;
    public static ImportTargetKind Assembly;
    public static ImportTargetKind XmlNamespace;
    public static ImportTargetKind MethodToken;
    public static ImportTargetKind CurrentNamespace;
    public static ImportTargetKind DefaultNamespace;
    public static ImportTargetKind Defunct;
}
internal interface Microsoft.CodeAnalysis.Debugging.IProximityExpressionsService {
    public abstract virtual Task`1<IList`1<string>> GetProximityExpressionsAsync(Document document, int position, CancellationToken cancellationToken);
    public abstract virtual Task`1<bool> IsValidAsync(Document document, int position, string expressionValue, CancellationToken cancellationToken);
}
internal static class Microsoft.CodeAnalysis.Debugging.PortableCustomDebugInfoKinds : object {
    public static Guid AsyncMethodSteppingInformationBlob;
    public static Guid StateMachineHoistedLocalScopes;
    public static Guid DynamicLocalVariables;
    public static Guid TupleElementNames;
    public static Guid DefaultNamespace;
    public static Guid EncLocalSlotMap;
    public static Guid EncLambdaAndClosureMap;
    public static Guid SourceLink;
    public static Guid EmbeddedSource;
    public static Guid CompilationMetadataReferences;
    public static Guid CompilationOptions;
    private static PortableCustomDebugInfoKinds();
}
internal static class Microsoft.CodeAnalysis.Debugging.SourceHashAlgorithms : object {
    private static Guid s_guidSha1;
    private static Guid s_guidSha256;
    private static SourceHashAlgorithms();
    public static bool IsSupportedAlgorithm(SourceHashAlgorithm algorithm);
    public static Guid GetAlgorithmGuid(SourceHashAlgorithm algorithm);
    public static SourceHashAlgorithm GetSourceHashAlgorithm(Guid guid);
}
internal class Microsoft.CodeAnalysis.Debugging.StateMachineHoistedLocalScope : ValueType {
    public int StartOffset;
    public int EndOffset;
    public int Length { get; }
    public bool IsDefault { get; }
    public StateMachineHoistedLocalScope(int startOffset, int endOffset);
    public int get_Length();
    public bool get_IsDefault();
}
internal class Microsoft.CodeAnalysis.Debugging.TupleElementNamesInfo : ValueType {
    internal ImmutableArray`1<string> ElementNames;
    internal int SlotIndex;
    internal string LocalName;
    internal int ScopeStart;
    internal int ScopeEnd;
    internal TupleElementNamesInfo(ImmutableArray`1<string> elementNames, int slotIndex, string localName, int scopeStart, int scopeEnd);
}
internal enum Microsoft.CodeAnalysis.Debugging.VBImportScopeKind : Enum {
    public int value__;
    public static VBImportScopeKind Unspecified;
    public static VBImportScopeKind File;
    public static VBImportScopeKind Project;
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.CodeAnalysis.DeclarationComputer : object {
    internal static DeclarationInfo GetDeclarationInfo(SemanticModel model, SyntaxNode node, bool getSymbol, IEnumerable`1<SyntaxNode> executableCodeBlocks, CancellationToken cancellationToken);
    internal static DeclarationInfo GetDeclarationInfo(SyntaxNode node, ISymbol declaredSymbol, IEnumerable`1<SyntaxNode> executableCodeBlocks);
    internal static DeclarationInfo GetDeclarationInfo(SemanticModel model, SyntaxNode node, bool getSymbol, CancellationToken cancellationToken);
    internal static DeclarationInfo GetDeclarationInfo(SemanticModel model, SyntaxNode node, bool getSymbol, SyntaxNode executableCodeBlock, CancellationToken cancellationToken);
    internal static DeclarationInfo GetDeclarationInfo(SemanticModel model, SyntaxNode node, bool getSymbol, CancellationToken cancellationToken, SyntaxNode[] executableCodeBlocks);
    private static ISymbol GetDeclaredSymbol(SemanticModel model, SyntaxNode node, bool getSymbol, CancellationToken cancellationToken);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[IsReadOnlyAttribute]
internal class Microsoft.CodeAnalysis.DeclarationInfo : ValueType {
    [CompilerGeneratedAttribute]
private SyntaxNode <DeclaredNode>k__BackingField;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private ImmutableArray`1<SyntaxNode> <ExecutableCodeBlocks>k__BackingField;
    [NullableAttribute("2")]
[CompilerGeneratedAttribute]
private ISymbol <DeclaredSymbol>k__BackingField;
    public SyntaxNode DeclaredNode { get; }
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ImmutableArray`1<SyntaxNode> ExecutableCodeBlocks { get; }
    [NullableAttribute("2")]
public ISymbol DeclaredSymbol { get; }
    internal DeclarationInfo(SyntaxNode declaredNode, ImmutableArray`1<SyntaxNode> executableCodeBlocks, ISymbol declaredSymbol);
    [CompilerGeneratedAttribute]
public SyntaxNode get_DeclaredNode();
    [CompilerGeneratedAttribute]
public ImmutableArray`1<SyntaxNode> get_ExecutableCodeBlocks();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public ISymbol get_DeclaredSymbol();
}
internal interface Microsoft.CodeAnalysis.DecompiledSource.IDecompiledSourceService {
    public abstract virtual Task`1<Document> AddSourceToAsync(Document document, Compilation symbolCompilation, ISymbol symbol, CancellationToken cancellationToken);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal abstract class Microsoft.CodeAnalysis.DesignerAttribute.AbstractDesignerAttributeIncrementalAnalyzer : IncrementalAnalyzerBase {
    [TupleElementNamesAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private ConcurrentDictionary`2<DocumentId, ValueTuple`2<string, VersionStamp>> _documentToLastReportedInformation;
    protected abstract virtual ValueTask ReportProjectRemovedAsync(ProjectId projectId, CancellationToken cancellationToken);
    [NullableContextAttribute("0")]
protected abstract virtual ValueTask ReportDesignerAttributeDataAsync(ImmutableArray`1<DesignerAttributeData> data, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.DesignerAttribute.AbstractDesignerAttributeIncrementalAnalyzer/<RemoveProjectAsync>d__4")]
public virtual Task RemoveProjectAsync(ProjectId projectId, CancellationToken cancellationToken);
    public virtual Task RemoveDocumentAsync(DocumentId documentId, CancellationToken cancellationToken);
    public virtual Task AnalyzeProjectAsync(Project project, bool semanticsChanged, InvocationReasons reasons, CancellationToken cancellationToken);
    public virtual Task AnalyzeDocumentAsync(Document document, SyntaxNode body, InvocationReasons reasons, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.DesignerAttribute.AbstractDesignerAttributeIncrementalAnalyzer/<AnalyzeProjectAsync>d__8")]
private Task AnalyzeProjectAsync(Project project, Document specificDocument, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.DesignerAttribute.AbstractDesignerAttributeIncrementalAnalyzer/<ComputeLatestDataAsync>d__9")]
private Task`1<ValueTuple`2[]> ComputeLatestDataAsync(Project project, Document specificDocument, VersionStamp projectVersion, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.DesignerAttribute.AbstractDesignerAttributeIncrementalAnalyzer/<ComputeDesignerAttributeDataAsync>d__10")]
private static Task`1<ValueTuple`2<Document, DesignerAttributeData>> ComputeDesignerAttributeDataAsync(INamedTypeSymbol designerCategoryType, Document document, CancellationToken cancellationToken);
    [NullableContextAttribute("0")]
[CompilerGeneratedAttribute]
private bool <AnalyzeProjectAsync>b__8_0(ValueTuple`2<Document, DesignerAttributeData> d);
}
internal abstract class Microsoft.CodeAnalysis.DiagnosticComments.CodeFixes.AbstractAddDocCommentNodesCodeFixProvider`4 : CodeFixProvider {
    protected string NodeName { get; }
    public virtual FixAllProvider GetFixAllProvider();
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.DiagnosticComments.CodeFixes.AbstractAddDocCommentNodesCodeFixProvider`4/<RegisterCodeFixesAsync>d__1")]
public sealed virtual Task RegisterCodeFixesAsync(CodeFixContext context);
    protected abstract virtual string get_NodeName();
    protected abstract virtual List`1<TXmlNameAttributeSyntax> GetNameAttributes(TXmlElementSyntax node);
    protected abstract virtual string GetValueFromNameAttribute(TXmlNameAttributeSyntax attribute);
    protected abstract virtual SyntaxNode TryGetDocCommentNode(SyntaxTriviaList parameter);
    protected abstract virtual string GetXmlElementLocalName(TXmlElementSyntax element);
    protected abstract virtual List`1<string> GetParameterNames(TMemberDeclarationSyntax method);
    protected abstract virtual TXmlElementSyntax GetNewNode(string parameterName, bool isFirstNodeInComment);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.DiagnosticComments.CodeFixes.AbstractAddDocCommentNodesCodeFixProvider`4/<AddParamTagAsync>d__10")]
protected Task`1<Document> AddParamTagAsync(Document document, TextSpan span, CancellationToken cancellationToken);
    private List`1<TXmlElementSyntax> GetElementNodes(SyntaxNode docComment, string nodeName);
    private bool NodeExists(IEnumerable`1<TXmlElementSyntax> paramNodes, string name);
    protected TXmlElementSyntax GetParamNodeForParamName(IEnumerable`1<TXmlElementSyntax> paramNodeList, string name);
}
internal abstract class Microsoft.CodeAnalysis.DiagnosticComments.CodeFixes.AbstractRemoveDocCommentNodeCodeFixProvider`2 : CodeFixProvider {
    public ImmutableArray`1<string> FixableDiagnosticIds { get; }
    protected string DocCommentSignifierToken { get; }
    public virtual FixAllProvider GetFixAllProvider();
    public abstract virtual ImmutableArray`1<string> get_FixableDiagnosticIds();
    protected abstract virtual string get_DocCommentSignifierToken();
    protected abstract virtual SyntaxTriviaList GetRevisedDocCommentTrivia(string docCommentText);
    protected abstract virtual SyntaxTokenList GetTextTokens(TXmlTextSyntax xmlText);
    protected abstract virtual bool IsXmlNewLineToken(SyntaxToken token);
    protected abstract virtual bool IsXmlWhitespaceToken(SyntaxToken token);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.DiagnosticComments.CodeFixes.AbstractRemoveDocCommentNodeCodeFixProvider`2/<RegisterCodeFixesAsync>d__9")]
public sealed virtual Task RegisterCodeFixesAsync(CodeFixContext context);
    private static TXmlElementSyntax GetParamNode(SyntaxNode root, TextSpan span);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.DiagnosticComments.CodeFixes.AbstractRemoveDocCommentNodeCodeFixProvider`2/<RemoveDuplicateParamTagAsync>d__11")]
private Task`1<Document> RemoveDuplicateParamTagAsync(Document document, TextSpan span, CancellationToken cancellationToken);
    private bool ShouldRemovePreviousSibling(List`1<SyntaxNode> paramNodeSiblings, int paramNodeIndex);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal abstract class Microsoft.CodeAnalysis.Diagnostics.AbstractHostDiagnosticUpdateSource : object {
    private ImmutableDictionary`2<DiagnosticAnalyzer, ImmutableHashSet`1<DiagnosticData>> _analyzerHostDiagnosticsMap;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private EventHandler`1<DiagnosticsUpdatedArgs> DiagnosticsUpdated;
    public Workspace Workspace { get; }
    public bool SupportGetDiagnostics { get; }
    public abstract virtual Workspace get_Workspace();
    public sealed virtual bool get_SupportGetDiagnostics();
    public sealed virtual ValueTask`1<ImmutableArray`1<DiagnosticData>> GetDiagnosticsAsync(Workspace workspace, ProjectId projectId, DocumentId documentId, object id, bool includeSuppressedDiagnostics, CancellationToken cancellationToken);
    [CompilerGeneratedAttribute]
public sealed virtual void add_DiagnosticsUpdated(EventHandler`1<DiagnosticsUpdatedArgs> value);
    [CompilerGeneratedAttribute]
public sealed virtual void remove_DiagnosticsUpdated(EventHandler`1<DiagnosticsUpdatedArgs> value);
    public sealed virtual void add_DiagnosticsCleared(EventHandler value);
    public sealed virtual void remove_DiagnosticsCleared(EventHandler value);
    public void RaiseDiagnosticsUpdated(DiagnosticsUpdatedArgs args);
    public void ReportAnalyzerDiagnostic(DiagnosticAnalyzer analyzer, Diagnostic diagnostic, ProjectId projectId);
    public void ReportAnalyzerDiagnostic(DiagnosticAnalyzer analyzer, DiagnosticData diagnosticData, Project project);
    public void ClearAnalyzerReferenceDiagnostics(AnalyzerFileReference analyzerReference, string language, ProjectId projectId);
    public void ClearAnalyzerDiagnostics(ImmutableArray`1<DiagnosticAnalyzer> analyzers, ProjectId projectId);
    public void ClearAnalyzerDiagnostics(ProjectId projectId);
    private void ClearAnalyzerDiagnostics(DiagnosticAnalyzer analyzer, ProjectId projectId);
    private DiagnosticsUpdatedArgs MakeCreatedArgs(DiagnosticAnalyzer analyzer, ImmutableHashSet`1<DiagnosticData> items, Project project);
    private DiagnosticsUpdatedArgs MakeRemovedArgs(DiagnosticAnalyzer analyzer, Project project);
    private HostArgsId CreateId(DiagnosticAnalyzer analyzer, Project project);
    internal TestAccessor GetTestAccessor();
}
internal abstract class Microsoft.CodeAnalysis.Diagnostics.AddImport.UnboundIdentifiersDiagnosticAnalyzerBase`5 : DiagnosticAnalyzer {
    protected DiagnosticDescriptor DiagnosticDescriptor { get; }
    protected DiagnosticDescriptor DiagnosticDescriptor2 { get; }
    protected ImmutableArray`1<TLanguageKindEnum> SyntaxKindsOfInterest { get; }
    public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    protected abstract virtual DiagnosticDescriptor get_DiagnosticDescriptor();
    protected abstract virtual DiagnosticDescriptor get_DiagnosticDescriptor2();
    protected abstract virtual ImmutableArray`1<TLanguageKindEnum> get_SyntaxKindsOfInterest();
    protected abstract virtual bool ConstructorDoesNotExist(SyntaxNode node, SymbolInfo info, SemanticModel semanticModel);
    protected abstract virtual bool IsNameOf(SyntaxNode node);
    public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    public sealed virtual bool OpenFileOnly(OptionSet options);
    public virtual void Initialize(AnalysisContext context);
    protected static DiagnosticDescriptor GetDiagnosticDescriptor(string id, LocalizableString messageFormat);
    private void AnalyzeNode(SyntaxNodeAnalysisContext context);
    private static bool IsBrokenLambda(SyntaxNodeAnalysisContext context);
    private void ReportUnboundIdentifierNames(SyntaxNodeAnalysisContext context, SyntaxNode member);
    public sealed virtual DiagnosticAnalyzerCategory GetAnalyzerCategory();
    [CompilerGeneratedAttribute]
internal static bool <ReportUnboundIdentifierNames>g__isQualifiedOrSimpleName|15_0(SyntaxNode n);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.CodeAnalysis.Diagnostics.AnalyzerConfigOptionSet : OptionSet {
    private AnalyzerConfigOptions _analyzerConfigOptions;
    [NullableAttribute("2")]
private OptionSet _optionSet;
    public AnalyzerConfigOptionSet(AnalyzerConfigOptions analyzerConfigOptions, OptionSet optionSet);
    private protected virtual object GetOptionCore(OptionKey optionKey);
    public virtual OptionSet WithChangedOption(OptionKey optionAndLanguage, object value);
    private protected virtual AnalyzerConfigOptions CreateAnalyzerConfigOptions(IOptionService optionService, string language);
    internal virtual IEnumerable`1<OptionKey> GetChangedOptions(OptionSet optionSet);
}
[ExtensionAttribute]
internal static class Microsoft.CodeAnalysis.Diagnostics.AnalyzerExceptionDescriptionBuilder : object {
    private static string s_separator;
    private static AnalyzerExceptionDescriptionBuilder();
    [ExtensionAttribute]
public static string CreateDiagnosticDescription(Exception exception);
    private static string GetExceptionMessage(Exception exception);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
internal static class Microsoft.CodeAnalysis.Diagnostics.AnalyzerHelper : object {
    internal static string WRN_AnalyzerCannotBeCreatedIdCS;
    internal static string WRN_AnalyzerCannotBeCreatedIdVB;
    internal static string WRN_NoAnalyzerInAssemblyIdCS;
    internal static string WRN_NoAnalyzerInAssemblyIdVB;
    internal static string WRN_UnableToLoadAnalyzerIdCS;
    internal static string WRN_UnableToLoadAnalyzerIdVB;
    internal static string WRN_AnalyzerReferencesNetFrameworkIdCS;
    internal static string WRN_AnalyzerReferencesNetFrameworkIdVB;
    internal static string AnalyzerExceptionDiagnosticId;
    internal static string AnalyzerDriverExceptionDiagnosticId;
    internal static string WRN_AnalyzerCannotBeCreatedId;
    internal static string WRN_NoAnalyzerInAssemblyId;
    internal static string WRN_UnableToLoadAnalyzerId;
    internal static string WRN_AnalyzerReferencesNetFrameworkId;
    private static string AnalyzerExceptionDiagnosticCategory;
    [ExtensionAttribute]
public static bool IsWorkspaceDiagnosticAnalyzer(DiagnosticAnalyzer analyzer);
    [ExtensionAttribute]
public static bool IsBuiltInAnalyzer(DiagnosticAnalyzer analyzer);
    [ExtensionAttribute]
public static bool IsOpenFileOnly(DiagnosticAnalyzer analyzer, OptionSet options);
    [ExtensionAttribute]
public static ReportDiagnostic GetEffectiveSeverity(DiagnosticDescriptor descriptor, CompilationOptions options);
    [ExtensionAttribute]
public static ValueTuple`2<string, VersionStamp> GetAnalyzerIdAndVersion(DiagnosticAnalyzer analyzer);
    [ExtensionAttribute]
public static string GetAnalyzerAssemblyName(DiagnosticAnalyzer analyzer);
    [ExtensionAttribute]
public static OptionSet GetAnalyzerOptionSet(AnalyzerOptions analyzerOptions, SyntaxTree syntaxTree, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.Diagnostics.AnalyzerHelper/<GetAnalyzerOptionSetAsync>d__22")]
[ExtensionAttribute]
public static ValueTask`1<OptionSet> GetAnalyzerOptionSetAsync(AnalyzerOptions analyzerOptions, SyntaxTree syntaxTree, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static T GetOption(AnalyzerOptions analyzerOptions, ILanguageSpecificOption`1<T> option, SyntaxTree syntaxTree, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static T GetOption(AnalyzerOptions analyzerOptions, IPerLanguageOption`1<T> option, string language, SyntaxTree syntaxTree, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.Diagnostics.AnalyzerHelper/<GetOptionAsync>d__25`1")]
[ExtensionAttribute]
public static ValueTask`1<T> GetOptionAsync(AnalyzerOptions analyzerOptions, IOption option, string language, SyntaxTree syntaxTree, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static ValueTask`1<OptionSet> GetDocumentOptionSetAsync(AnalyzerOptions analyzerOptions, SyntaxTree syntaxTree, CancellationToken cancellationToken);
    internal static Diagnostic CreateAnalyzerExceptionDiagnostic(DiagnosticAnalyzer analyzer, Exception e);
    private static VersionStamp GetAnalyzerVersion(string path);
    public static DiagnosticData CreateAnalyzerLoadFailureDiagnostic(AnalyzerLoadFailureEventArgs e, string fullPath, ProjectId projectId, string language);
    [ExtensionAttribute]
public static void AppendAnalyzerMap(Dictionary`2<string, DiagnosticAnalyzer> analyzerMap, IEnumerable`1<DiagnosticAnalyzer> analyzers);
    [ExtensionAttribute]
public static IEnumerable`1<AnalyzerPerformanceInfo> ToAnalyzerPerformanceInfo(IDictionary`2<DiagnosticAnalyzer, AnalyzerTelemetryInfo> analysisResult, DiagnosticAnalyzerInfoCache analyzerInfo);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.Diagnostics.AnalyzerHelper/<CreateCompilationWithAnalyzersAsync>d__32")]
public static Task`1<CompilationWithAnalyzers> CreateCompilationWithAnalyzersAsync(Project project, IEnumerable`1<DiagnosticAnalyzer> analyzers, bool includeSuppressedDiagnostics, CancellationToken cancellationToken);
    [ConditionalAttribute("DEBUG")]
private static void AssertCompilation(Project project, Compilation compilation1);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.Diagnostics.AnalyzerHelper/<ComputeDocumentDiagnosticAnalyzerDiagnosticsAsync>d__34")]
public static Task`1<ImmutableArray`1<Diagnostic>> ComputeDocumentDiagnosticAnalyzerDiagnosticsAsync(DocumentDiagnosticAnalyzer analyzer, Document document, AnalysisKind kind, Compilation compilation, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.Diagnostics.AnalyzerHelper/<ComputeProjectDiagnosticAnalyzerDiagnosticsAsync>d__35")]
public static Task`1<ImmutableArray`1<Diagnostic>> ComputeProjectDiagnosticAnalyzerDiagnosticsAsync(ProjectDiagnosticAnalyzer analyzer, Project project, Compilation compilation, CancellationToken cancellationToken);
    private static bool IsCanceled(Exception ex, CancellationToken cancellationToken);
    [IteratorStateMachineAttribute("Microsoft.CodeAnalysis.Diagnostics.AnalyzerHelper/<ConvertToLocalDiagnostics>d__37")]
[ExtensionAttribute]
public static IEnumerable`1<DiagnosticData> ConvertToLocalDiagnostics(IEnumerable`1<Diagnostic> diagnostics, TextDocument targetTextDocument, Nullable`1<TextSpan> span);
    [ExtensionAttribute]
public static T GetOption(SemanticModelAnalysisContext context, Option2`1<T> option);
    [ExtensionAttribute]
public static T GetOption(SyntaxNodeAnalysisContext context, Option2`1<T> option);
    [ExtensionAttribute]
public static T GetOption(SyntaxTreeAnalysisContext context, Option2`1<T> option);
    [ExtensionAttribute]
public static T GetOption(OperationAnalysisContext context, Option2`1<T> option);
    [ExtensionAttribute]
public static T GetOption(SemanticModelAnalysisContext context, PerLanguageOption2`1<T> option, string language);
    [ExtensionAttribute]
public static T GetOption(SyntaxNodeAnalysisContext context, PerLanguageOption2`1<T> option, string language);
    [ExtensionAttribute]
public static T GetOption(SyntaxTreeAnalysisContext context, PerLanguageOption2`1<T> option, string language);
    [ExtensionAttribute]
public static T GetOption(OperationAnalysisContext context, PerLanguageOption2`1<T> option, string language);
    [ExtensionAttribute]
public static bool TryGetEditorConfigOption(AnalyzerOptions analyzerOptions, IOption option, SyntaxTree syntaxTree, T& value);
    [CompilerGeneratedAttribute]
internal static string <CreateAnalyzerLoadFailureDiagnostic>g__GetLanguageSpecificId|29_0(string language, string noLanguageId, string csharpId, string vbId);
    [CompilerGeneratedAttribute]
internal static bool <ConvertToLocalDiagnostics>g__IsReportedInDocument|37_0(Diagnostic diagnostic, TextDocument targetTextDocument);
}
[IsReadOnlyAttribute]
[DataContractAttribute]
internal class Microsoft.CodeAnalysis.Diagnostics.AnalyzerPerformanceInfo : ValueType {
    [DataMemberAttribute]
public string AnalyzerId;
    [DataMemberAttribute]
public bool BuiltIn;
    [DataMemberAttribute]
public TimeSpan TimeSpan;
    public AnalyzerPerformanceInfo(string analyzerId, bool builtIn, TimeSpan timeSpan);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal abstract class Microsoft.CodeAnalysis.Diagnostics.Analyzers.NamingStyles.NamingStyleDiagnosticAnalyzerBase`1 : AbstractBuiltInCodeStyleDiagnosticAnalyzer {
    private static LocalizableString s_localizableMessageFormat;
    private static LocalizableString s_localizableTitleNamingStyle;
    [NullableAttribute("0")]
private static ImmutableArray`1<SymbolKind> _symbolKinds;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private static Func`2<Guid, ConcurrentDictionary`2<string, string>> s_createCache;
    [NullableAttribute("0")]
protected ImmutableArray`1<TLanguageKindEnum> SupportedSyntaxKinds { get; }
    private static NamingStyleDiagnosticAnalyzerBase`1();
    [NullableContextAttribute("0")]
protected abstract virtual ImmutableArray`1<TLanguageKindEnum> get_SupportedSyntaxKinds();
    protected abstract virtual bool ShouldIgnore(ISymbol symbol);
    protected virtual void InitializeWorker(AnalysisContext context);
    private void CompilationStartAction(CompilationStartAnalysisContext context);
    private Diagnostic TryGetDiagnostic(Compilation compilation, ISymbol symbol, AnalyzerOptions options, ConcurrentDictionary`2<Guid, ConcurrentDictionary`2<string, string>> idToCachedResult, CancellationToken cancellationToken);
    private static NamingStylePreferences GetNamingStylePreferences(Compilation compilation, ISymbol symbol, AnalyzerOptions options, CancellationToken cancellationToken);
    public virtual DiagnosticAnalyzerCategory GetAnalyzerCategory();
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal class Microsoft.CodeAnalysis.Diagnostics.AnalyzerUpdateArgsId : Base`1<DiagnosticAnalyzer> {
    public DiagnosticAnalyzer Analyzer { get; }
    public string BuildTool { get; }
    protected AnalyzerUpdateArgsId(DiagnosticAnalyzer analyzer);
    public DiagnosticAnalyzer get_Analyzer();
    public virtual string get_BuildTool();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal abstract class Microsoft.CodeAnalysis.Diagnostics.BuildToolId : object {
    public string BuildTool { get; }
    public abstract virtual string get_BuildTool();
}
[SharedAttribute]
[ExportIncrementalAnalyzerProviderAttribute("Diagnostic", "")]
internal class Microsoft.CodeAnalysis.Diagnostics.DefaultDiagnosticAnalyzerService : object {
    private DiagnosticAnalyzerInfoCache _analyzerInfoCache;
    [CompilerGeneratedAttribute]
private EventHandler`1<DiagnosticsUpdatedArgs> DiagnosticsUpdated;
    public bool SupportGetDiagnostics { get; }
    [ImportingConstructorAttribute]
[ObsoleteAttribute("This exported object must be obtained through the MEF export provider.", "True")]
public DefaultDiagnosticAnalyzerService(IDiagnosticUpdateSourceRegistrationService registrationService);
    public sealed virtual IIncrementalAnalyzer CreateIncrementalAnalyzer(Workspace workspace);
    [CompilerGeneratedAttribute]
public sealed virtual void add_DiagnosticsUpdated(EventHandler`1<DiagnosticsUpdatedArgs> value);
    [CompilerGeneratedAttribute]
public sealed virtual void remove_DiagnosticsUpdated(EventHandler`1<DiagnosticsUpdatedArgs> value);
    public sealed virtual void add_DiagnosticsCleared(EventHandler value);
    public sealed virtual void remove_DiagnosticsCleared(EventHandler value);
    public sealed virtual bool get_SupportGetDiagnostics();
    public sealed virtual ValueTask`1<ImmutableArray`1<DiagnosticData>> GetDiagnosticsAsync(Workspace workspace, ProjectId projectId, DocumentId documentId, object id, bool includeSuppressedDiagnostics, CancellationToken cancellationToken);
    internal void RaiseDiagnosticsUpdated(DiagnosticsUpdatedArgs state);
}
[ExportWorkspaceServiceFactoryAttribute("Microsoft.CodeAnalysis.Diagnostics.IDiagnosticModeService", "Default")]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.Diagnostics.DefaultDiagnosticModeServiceFactory : object {
    [NullableContextAttribute("1")]
public sealed virtual IWorkspaceService CreateService(HostWorkspaceServices workspaceServices);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExportAttribute("Microsoft.CodeAnalysis.Diagnostics.IDiagnosticAnalyzerService")]
[SharedAttribute]
[ExportIncrementalAnalyzerProviderAttribute("True", "Diagnostic", "Mono.Cecil.CustomAttributeArgument[]")]
internal class Microsoft.CodeAnalysis.Diagnostics.DiagnosticAnalyzerService : object {
    private static string DiagnosticsUpdatedEventName;
    private EventMap _eventMap;
    private TaskQueue _eventQueue;
    [CompilerGeneratedAttribute]
private DiagnosticAnalyzerInfoCache <AnalyzerInfoCache>k__BackingField;
    [CompilerGeneratedAttribute]
private IAsynchronousOperationListener <Listener>k__BackingField;
    private ConditionalWeakTable`2<Workspace, DiagnosticIncrementalAnalyzer> _map;
    private CreateValueCallback<Workspace, DiagnosticIncrementalAnalyzer> _createIncrementalAnalyzer;
    public DiagnosticAnalyzerInfoCache AnalyzerInfoCache { get; private set; }
    public IAsynchronousOperationListener Listener { get; }
    private bool Microsoft.CodeAnalysis.Diagnostics.IDiagnosticUpdateSource.SupportGetDiagnostics { get; }
    [ImportingConstructorAttribute]
[ObsoleteAttribute("This exported object must be obtained through the MEF export provider.", "True")]
public DiagnosticAnalyzerService(IDiagnosticUpdateSourceRegistrationService registrationService, IAsynchronousOperationListenerProvider listenerProvider);
    [CompilerGeneratedAttribute]
public sealed virtual DiagnosticAnalyzerInfoCache get_AnalyzerInfoCache();
    [CompilerGeneratedAttribute]
private void set_AnalyzerInfoCache(DiagnosticAnalyzerInfoCache value);
    [CompilerGeneratedAttribute]
public IAsynchronousOperationListener get_Listener();
    public sealed virtual void Reanalyze(Workspace workspace, IEnumerable`1<ProjectId> projectIds, IEnumerable`1<DocumentId> documentIds, bool highPriority);
    public sealed virtual Task`1<bool> TryAppendDiagnosticsForSpanAsync(Document document, TextSpan range, ArrayBuilder`1<DiagnosticData> diagnostics, bool includeSuppressedDiagnostics, CancellationToken cancellationToken);
    public sealed virtual Task`1<ImmutableArray`1<DiagnosticData>> GetDiagnosticsForSpanAsync(Document document, TextSpan range, string diagnosticId, bool includeSuppressedDiagnostics, Func`2<string, IDisposable> addOperationScope, CancellationToken cancellationToken);
    [NullableContextAttribute("2")]
public sealed virtual Task`1<ImmutableArray`1<DiagnosticData>> GetCachedDiagnosticsAsync(Workspace workspace, ProjectId projectId, DocumentId documentId, bool includeSuppressedDiagnostics, CancellationToken cancellationToken);
    public sealed virtual Task`1<ImmutableArray`1<DiagnosticData>> GetSpecificCachedDiagnosticsAsync(Workspace workspace, object id, bool includeSuppressedDiagnostics, CancellationToken cancellationToken);
    [NullableContextAttribute("2")]
public sealed virtual Task`1<ImmutableArray`1<DiagnosticData>> GetDiagnosticsAsync(Solution solution, ProjectId projectId, DocumentId documentId, bool includeSuppressedDiagnostics, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.Diagnostics.DiagnosticAnalyzerService/<ForceAnalyzeAsync>d__19")]
public sealed virtual Task ForceAnalyzeAsync(Solution solution, Action`1<Project> onProjectAnalyzed, ProjectId projectId, CancellationToken cancellationToken);
    [NullableContextAttribute("2")]
public sealed virtual Task`1<ImmutableArray`1<DiagnosticData>> GetDiagnosticsForIdsAsync(Solution solution, ProjectId projectId, DocumentId documentId, ImmutableHashSet`1<string> diagnosticIds, bool includeSuppressedDiagnostics, CancellationToken cancellationToken);
    public sealed virtual Task`1<ImmutableArray`1<DiagnosticData>> GetProjectDiagnosticsForIdsAsync(Solution solution, ProjectId projectId, ImmutableHashSet`1<string> diagnosticIds, bool includeSuppressedDiagnostics, CancellationToken cancellationToken);
    public sealed virtual bool ContainsDiagnostics(Workspace workspace, ProjectId projectId);
    [NullableContextAttribute("0")]
public Task SynchronizeWithBuildAsync(Workspace workspace, ImmutableDictionary`2<ProjectId, ImmutableArray`1<DiagnosticData>> diagnostics, TaskQueue postBuildAndErrorListRefreshTaskQueue, bool onBuildCompleted, CancellationToken cancellationToken);
    [NullableContextAttribute("0")]
public sealed virtual IIncrementalAnalyzer CreateIncrementalAnalyzer(Workspace workspace);
    [NullableContextAttribute("0")]
public void ShutdownAnalyzerFrom(Workspace workspace);
    [NullableContextAttribute("0")]
[ObsoleteAttribute("This factory method only provides services for the MEF export provider.", "True")]
private DiagnosticIncrementalAnalyzer CreateIncrementalAnalyzerCallback(Workspace workspace);
    [NullableContextAttribute("0")]
private void OnDocumentActiveContextChanged(object sender, DocumentActiveContextChangedEventArgs e);
    [NullableContextAttribute("0")]
public sealed virtual void add_DiagnosticsUpdated(EventHandler`1<DiagnosticsUpdatedArgs> value);
    [NullableContextAttribute("0")]
public sealed virtual void remove_DiagnosticsUpdated(EventHandler`1<DiagnosticsUpdatedArgs> value);
    [NullableContextAttribute("0")]
public sealed virtual void add_DiagnosticsCleared(EventHandler value);
    [NullableContextAttribute("0")]
public sealed virtual void remove_DiagnosticsCleared(EventHandler value);
    [NullableContextAttribute("0")]
internal void RaiseDiagnosticsUpdated(DiagnosticsUpdatedArgs args);
    [NullableContextAttribute("0")]
internal void RaiseBulkDiagnosticsUpdated(Action`1<Action`1<DiagnosticsUpdatedArgs>> eventAction);
    [NullableContextAttribute("0")]
internal void RaiseBulkDiagnosticsUpdated(Func`2<Action`1<DiagnosticsUpdatedArgs>, Task> eventActionAsync);
    private sealed virtual override bool Microsoft.CodeAnalysis.Diagnostics.IDiagnosticUpdateSource.get_SupportGetDiagnostics();
    [NullableContextAttribute("0")]
private sealed virtual override ValueTask`1<ImmutableArray`1<DiagnosticData>> Microsoft.CodeAnalysis.Diagnostics.IDiagnosticUpdateSource.GetDiagnosticsAsync(Workspace workspace, ProjectId projectId, DocumentId documentId, object id, bool includeSuppressedDiagnostics, CancellationToken cancellationToken);
}
internal class Microsoft.CodeAnalysis.Diagnostics.DiagnosticAnalyzerTelemetry : object {
    private object _guard;
    private ImmutableDictionary`2<Type, Data> _analyzerInfoMap;
    public void UpdateAnalyzerActionsTelemetry(DiagnosticAnalyzer analyzer, AnalyzerTelemetryInfo analyzerTelemetryInfo, bool isTelemetryCollectionAllowed);
    public void ReportAndClear(int correlationId);
    private static string ComputeSha256Hash(string name);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[DataContractAttribute]
internal class Microsoft.CodeAnalysis.Diagnostics.DiagnosticArguments : object {
    [DataMemberAttribute]
public bool ReportSuppressedDiagnostics;
    [DataMemberAttribute]
public bool LogPerformanceInfo;
    [DataMemberAttribute]
public bool GetTelemetryInfo;
    [NullableAttribute("2")]
[DataMemberAttribute]
public DocumentId DocumentId;
    [DataMemberAttribute]
public Nullable`1<TextSpan> DocumentSpan;
    [DataMemberAttribute]
public Nullable`1<AnalysisKind> DocumentAnalysisKind;
    [DataMemberAttribute]
public ProjectId ProjectId;
    [DataMemberAttribute]
public String[] AnalyzerIds;
    public DiagnosticArguments(bool reportSuppressedDiagnostics, bool logPerformanceInfo, bool getTelemetryInfo, DocumentId documentId, Nullable`1<TextSpan> documentSpan, Nullable`1<AnalysisKind> documentAnalysisKind, ProjectId projectId, String[] analyzerIds);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[IsReadOnlyAttribute]
internal class Microsoft.CodeAnalysis.Diagnostics.DiagnosticBucket : ValueType {
    public object Id;
    public Workspace Workspace;
    [NullableAttribute("2")]
public ProjectId ProjectId;
    [NullableAttribute("2")]
public DocumentId DocumentId;
    public DiagnosticBucket(object id, Workspace workspace, ProjectId projectId, DocumentId documentId);
}
internal static class Microsoft.CodeAnalysis.Diagnostics.DiagnosticCustomTags : object {
    private static string s_enforceOnBuildNeverTag;
    private static String[] s_microsoftCustomTags;
    private static String[] s_editAndContinueCustomTags;
    private static String[] s_unnecessaryCustomTags;
    private static String[] s_notConfigurableCustomTags;
    private static String[] s_unnecessaryAndNotConfigurableCustomTags;
    public static String[] Microsoft { get; }
    public static String[] EditAndContinue { get; }
    public static String[] Unnecessary { get; }
    public static String[] NotConfigurable { get; }
    public static String[] UnnecessaryAndNotConfigurable { get; }
    private static DiagnosticCustomTags();
    public static String[] get_Microsoft();
    public static String[] get_EditAndContinue();
    public static String[] get_Unnecessary();
    public static String[] get_NotConfigurable();
    public static String[] get_UnnecessaryAndNotConfigurable();
    [ConditionalAttribute("DEBUG")]
private static void Assert(String[] customTags, String[] tags);
    internal static String[] Create(bool isUnnecessary, bool isConfigurable, EnforceOnBuild enforceOnBuild);
}
internal static class Microsoft.CodeAnalysis.Diagnostics.DiagnosticHelper : object {
    public static Diagnostic Create(DiagnosticDescriptor descriptor, Location location, ReportDiagnostic effectiveSeverity, IEnumerable`1<Location> additionalLocations, ImmutableDictionary`2<string, string> properties, Object[] messageArgs);
    public static Diagnostic CreateWithLocationTags(DiagnosticDescriptor descriptor, Location location, ReportDiagnostic effectiveSeverity, ImmutableArray`1<Location> additionalLocations, ImmutableArray`1<Location> additionalUnnecessaryLocations, Object[] messageArgs);
    public static Diagnostic CreateWithLocationTags(DiagnosticDescriptor descriptor, Location location, ReportDiagnostic effectiveSeverity, ImmutableArray`1<Location> additionalLocations, ImmutableArray`1<Location> additionalUnnecessaryLocations, ImmutableDictionary`2<string, string> properties, Object[] messageArgs);
    private static Diagnostic CreateWithLocationTags(DiagnosticDescriptor descriptor, Location location, ReportDiagnostic effectiveSeverity, IEnumerable`1<Location> additionalLocations, IDictionary`2<string, IEnumerable`1<int>> tagIndices, ImmutableDictionary`2<string, string> properties, Object[] messageArgs);
    public static Diagnostic CreateWithMessage(DiagnosticDescriptor descriptor, Location location, ReportDiagnostic effectiveSeverity, IEnumerable`1<Location> additionalLocations, ImmutableDictionary`2<string, string> properties, LocalizableString message);
    public static string GetHelpLinkForDiagnosticId(string id);
    [CompilerGeneratedAttribute]
internal static string <CreateWithLocationTags>g__EncodeIndices|3_1(IEnumerable`1<int> indices, int additionalLocationsLength);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
internal static class Microsoft.CodeAnalysis.Diagnostics.DiagnosticModeExtensions : object {
    [ExtensionAttribute]
public static DiagnosticMode GetDiagnosticMode(Workspace workspace, Option2`1<DiagnosticMode> option);
    [ExtensionAttribute]
public static bool IsPullDiagnostics(Workspace workspace, Option2`1<DiagnosticMode> option);
    [ExtensionAttribute]
public static bool IsPushDiagnostics(Workspace workspace, Option2`1<DiagnosticMode> option);
}
internal class Microsoft.CodeAnalysis.Diagnostics.DiagnosticProviderMetadata : object {
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Language>k__BackingField;
    public string Name { get; }
    public string Language { get; }
    public DiagnosticProviderMetadata(IDictionary`2<string, object> data);
    [CompilerGeneratedAttribute]
public string get_Name();
    [CompilerGeneratedAttribute]
public sealed virtual string get_Language();
}
[ExportAttribute("Microsoft.CodeAnalysis.Diagnostics.IDiagnosticService")]
[SharedAttribute]
[ExportAttribute("Microsoft.CodeAnalysis.Diagnostics.IDiagnosticUpdateSourceRegistrationService")]
internal class Microsoft.CodeAnalysis.Diagnostics.DiagnosticService : object {
    private static string DiagnosticsUpdatedEventName;
    private EventMap _eventMap;
    private TaskQueue _eventQueue;
    private object _gate;
    private Dictionary`2<IDiagnosticUpdateSource, Dictionary`2<Workspace, Dictionary`2<object, Data>>> _map;
    private EventListenerTracker`1<IDiagnosticService> _eventListenerTracker;
    private ImmutableHashSet`1<IDiagnosticUpdateSource> _updateSources;
    [ImportingConstructorAttribute]
[ObsoleteAttribute("This exported object must be obtained through the MEF export provider.", "True")]
public DiagnosticService(IAsynchronousOperationListenerProvider listenerProvider, IEnumerable`1<Lazy`2<IEventListener, EventListenerMetadata>> eventListeners);
    public sealed virtual void add_DiagnosticsUpdated(EventHandler`1<DiagnosticsUpdatedArgs> value);
    public sealed virtual void remove_DiagnosticsUpdated(EventHandler`1<DiagnosticsUpdatedArgs> value);
    private void RaiseDiagnosticsUpdated(IDiagnosticUpdateSource source, DiagnosticsUpdatedArgs args);
    private void RaiseDiagnosticsCleared(IDiagnosticUpdateSource source);
    private bool UpdateDataMap(IDiagnosticUpdateSource source, DiagnosticsUpdatedArgs args);
    private bool ClearDiagnosticsReportedBySource(IDiagnosticUpdateSource source, List`1<DiagnosticsUpdatedArgs> removed);
    private void OnDiagnosticsUpdated(object sender, DiagnosticsUpdatedArgs e);
    private void OnCleared(object sender, EventArgs e);
    [ObsoleteAttribute]
private sealed virtual override ImmutableArray`1<DiagnosticData> Microsoft.CodeAnalysis.Diagnostics.IDiagnosticService.GetDiagnostics(Workspace workspace, ProjectId projectId, DocumentId documentId, object id, bool includeSuppressedDiagnostics, CancellationToken cancellationToken);
    public sealed virtual ValueTask`1<ImmutableArray`1<DiagnosticData>> GetPullDiagnosticsAsync(Workspace workspace, ProjectId projectId, DocumentId documentId, object id, bool includeSuppressedDiagnostics, Option2`1<DiagnosticMode> diagnosticMode, CancellationToken cancellationToken);
    public sealed virtual ValueTask`1<ImmutableArray`1<DiagnosticData>> GetPushDiagnosticsAsync(Workspace workspace, ProjectId projectId, DocumentId documentId, object id, bool includeSuppressedDiagnostics, Option2`1<DiagnosticMode> diagnosticMode, CancellationToken cancellationToken);
    private ValueTask`1<ImmutableArray`1<DiagnosticData>> GetDiagnosticsAsync(Workspace workspace, ProjectId projectId, DocumentId documentId, object id, bool includeSuppressedDiagnostics, bool forPullDiagnostics, Option2`1<DiagnosticMode> diagnosticMode, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.Diagnostics.DiagnosticService/<GetSpecificDiagnosticsAsync>d__21")]
private ValueTask`1<ImmutableArray`1<DiagnosticData>> GetSpecificDiagnosticsAsync(Workspace workspace, ProjectId projectId, DocumentId documentId, object id, bool includeSuppressedDiagnostics, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.Diagnostics.DiagnosticService/<GetDiagnosticsAsync>d__22")]
private ValueTask`1<ImmutableArray`1<DiagnosticData>> GetDiagnosticsAsync(Workspace workspace, ProjectId projectId, DocumentId documentId, bool includeSuppressedDiagnostics, CancellationToken cancellationToken);
    public sealed virtual ImmutableArray`1<DiagnosticBucket> GetPullDiagnosticBuckets(Workspace workspace, ProjectId projectId, DocumentId documentId, Option2`1<DiagnosticMode> diagnosticMode, CancellationToken cancellationToken);
    public sealed virtual ImmutableArray`1<DiagnosticBucket> GetPushDiagnosticBuckets(Workspace workspace, ProjectId projectId, DocumentId documentId, Option2`1<DiagnosticMode> diagnosticMode, CancellationToken cancellationToken);
    private ImmutableArray`1<DiagnosticBucket> GetDiagnosticBuckets(Workspace workspace, ProjectId projectId, DocumentId documentId, bool forPullDiagnostics, Option2`1<DiagnosticMode> diagnosticMode, CancellationToken cancellationToken);
    private void AppendMatchingData(IDiagnosticUpdateSource source, Workspace workspace, ProjectId projectId, DocumentId documentId, object id, ArrayBuilder`1<Data> list);
    private static bool TryAddData(Workspace workspace, T key, Data data, Func`2<Data, T> keyGetter, ArrayBuilder`1<Data> result);
    [ConditionalAttribute("DEBUG")]
private static void AssertIfNull(ImmutableArray`1<DiagnosticData> diagnostics);
    [ConditionalAttribute("DEBUG")]
private static void AssertIfNull(T obj);
    internal TestAccessor GetTestAccessor();
    public sealed virtual void Register(IDiagnosticUpdateSource source);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.CodeAnalysis.Diagnostics.DiagnosticsUpdatedArgs : UpdatedEventArgs {
    [CompilerGeneratedAttribute]
private DiagnosticsUpdatedKind <Kind>k__BackingField;
    [NullableAttribute("2")]
[CompilerGeneratedAttribute]
private Solution <Solution>k__BackingField;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private ImmutableArray`1<DiagnosticData> _diagnostics;
    public DiagnosticsUpdatedKind Kind { get; }
    [NullableAttribute("2")]
public Solution Solution { get; }
    [NullableContextAttribute("2")]
private DiagnosticsUpdatedArgs(object id, Workspace workspace, Solution solution, ProjectId projectId, DocumentId documentId, ImmutableArray`1<DiagnosticData> diagnostics, DiagnosticsUpdatedKind kind);
    [CompilerGeneratedAttribute]
public DiagnosticsUpdatedKind get_Kind();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public Solution get_Solution();
    public ImmutableArray`1<DiagnosticData> GetAllDiagnosticsRegardlessOfPushPullSetting();
    public ImmutableArray`1<DiagnosticData> GetPullDiagnostics(Workspace workspace, Option2`1<DiagnosticMode> diagnosticMode);
    public ImmutableArray`1<DiagnosticData> GetPushDiagnostics(Workspace workspace, Option2`1<DiagnosticMode> diagnosticMode);
    public static DiagnosticsUpdatedArgs DiagnosticsCreated(object id, Workspace workspace, Solution solution, ProjectId projectId, DocumentId documentId, ImmutableArray`1<DiagnosticData> diagnostics);
    public static DiagnosticsUpdatedArgs DiagnosticsRemoved(object id, Workspace workspace, Solution solution, ProjectId projectId, DocumentId documentId);
}
internal enum Microsoft.CodeAnalysis.Diagnostics.DiagnosticsUpdatedKind : Enum {
    public int value__;
    public static DiagnosticsUpdatedKind DiagnosticsRemoved;
    public static DiagnosticsUpdatedKind DiagnosticsCreated;
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.CodeAnalysis.Diagnostics.DocumentAnalysisExecutor : object {
    [NullableAttribute("2")]
private CompilationWithAnalyzers _compilationWithAnalyzers;
    private InProcOrRemoteHostAnalyzerRunner _diagnosticAnalyzerRunner;
    private bool _logPerformanceInfo;
    [NullableAttribute("2")]
private Action _onAnalysisException;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private ImmutableArray`1<DiagnosticAnalyzer> _compilationBasedAnalyzersInAnalysisScope;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private ImmutableDictionary`2<DiagnosticAnalyzer, DiagnosticAnalysisResult> _lazySyntaxDiagnostics;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private ImmutableDictionary`2<DiagnosticAnalyzer, DiagnosticAnalysisResult> _lazySemanticDiagnostics;
    [CompilerGeneratedAttribute]
private DocumentAnalysisScope <AnalysisScope>k__BackingField;
    public DocumentAnalysisScope AnalysisScope { get; }
    public DocumentAnalysisExecutor(DocumentAnalysisScope analysisScope, CompilationWithAnalyzers compilationWithAnalyzers, InProcOrRemoteHostAnalyzerRunner diagnosticAnalyzerRunner, bool logPerformanceInfo, Action onAnalysisException);
    [CompilerGeneratedAttribute]
public DocumentAnalysisScope get_AnalysisScope();
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.Diagnostics.DocumentAnalysisExecutor/<ComputeDiagnosticsAsync>d__11")]
public Task`1<IEnumerable`1<DiagnosticData>> ComputeDiagnosticsAsync(DiagnosticAnalyzer analyzer, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.Diagnostics.DocumentAnalysisExecutor/<GetAnalysisResultAsync>d__12")]
private Task`1<ImmutableDictionary`2<DiagnosticAnalyzer, DiagnosticAnalysisResult>> GetAnalysisResultAsync(DocumentAnalysisScope analysisScope, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.Diagnostics.DocumentAnalysisExecutor/<GetCompilerAnalyzerDiagnosticsAsync>d__13")]
private Task`1<ImmutableArray`1<DiagnosticData>> GetCompilerAnalyzerDiagnosticsAsync(DiagnosticAnalyzer analyzer, Nullable`1<TextSpan> span, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.Diagnostics.DocumentAnalysisExecutor/<GetSyntaxDiagnosticsAsync>d__14")]
private Task`1<ImmutableArray`1<DiagnosticData>> GetSyntaxDiagnosticsAsync(DiagnosticAnalyzer analyzer, bool isCompilerAnalyzer, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.Diagnostics.DocumentAnalysisExecutor/<GetSemanticDiagnosticsAsync>d__15")]
private Task`1<ImmutableArray`1<DiagnosticData>> GetSemanticDiagnosticsAsync(DiagnosticAnalyzer analyzer, bool isCompilerAnalyzer, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.Diagnostics.DocumentAnalysisExecutor/<RemapDiagnosticLocationsIfRequiredAsync>d__16")]
private static Task`1<ImmutableArray`1<DiagnosticData>> RemapDiagnosticLocationsIfRequiredAsync(TextDocument textDocument, ImmutableArray`1<DiagnosticData> diagnostics, CancellationToken cancellationToken);
}
internal static class Microsoft.CodeAnalysis.Diagnostics.EnforceOnBuildValues : object {
    public static EnforceOnBuild RemoveUnnecessaryImports;
    public static EnforceOnBuild UseImplicitType;
    public static EnforceOnBuild UseExplicitType;
    public static EnforceOnBuild AddBraces;
    public static EnforceOnBuild OrderModifiers;
    public static EnforceOnBuild AddAccessibilityModifiers;
    public static EnforceOnBuild ValidateFormatString;
    public static EnforceOnBuild MakeFieldReadonly;
    public static EnforceOnBuild RemoveUnusedMembers;
    public static EnforceOnBuild RemoveUnreadMembers;
    public static EnforceOnBuild Formatting;
    public static EnforceOnBuild ValueAssignedIsUnused;
    public static EnforceOnBuild UnusedParameter;
    public static EnforceOnBuild FileHeaderMismatch;
    public static EnforceOnBuild InvalidSuppressMessageAttribute;
    public static EnforceOnBuild LegacyFormatSuppressMessageAttribute;
    public static EnforceOnBuild RemoveConfusingSuppressionForIsExpression;
    public static EnforceOnBuild UseThrowExpression;
    public static EnforceOnBuild UseObjectInitializer;
    public static EnforceOnBuild InlineDeclaration;
    public static EnforceOnBuild InlineAsType;
    public static EnforceOnBuild InlineIsType;
    public static EnforceOnBuild UseExpressionBodyForConstructors;
    public static EnforceOnBuild UseExpressionBodyForMethods;
    public static EnforceOnBuild UseExpressionBodyForConversionOperators;
    public static EnforceOnBuild UseExpressionBodyForOperators;
    public static EnforceOnBuild UseExpressionBodyForProperties;
    public static EnforceOnBuild UseExpressionBodyForIndexers;
    public static EnforceOnBuild UseExpressionBodyForAccessors;
    public static EnforceOnBuild UseCollectionInitializer;
    public static EnforceOnBuild UseCoalesceExpression;
    public static EnforceOnBuild UseCoalesceExpressionForNullable;
    public static EnforceOnBuild UseNullPropagation;
    public static EnforceOnBuild UseAutoProperty;
    public static EnforceOnBuild UseExplicitTupleName;
    public static EnforceOnBuild UseDefaultLiteral;
    public static EnforceOnBuild InlineIsTypeWithoutName;
    public static EnforceOnBuild UseLocalFunction;
    public static EnforceOnBuild UseDeconstruction;
    public static EnforceOnBuild UseConditionalExpressionForAssignment;
    public static EnforceOnBuild UseConditionalExpressionForReturn;
    public static EnforceOnBuild RemoveUnnecessaryParentheses;
    public static EnforceOnBuild UseExpressionBodyForLambdaExpressions;
    public static EnforceOnBuild UseCompoundAssignment;
    public static EnforceOnBuild UseIndexOperator;
    public static EnforceOnBuild UseRangeOperator;
    public static EnforceOnBuild UseExpressionBodyForLocalFunctions;
    public static EnforceOnBuild MakeLocalFunctionStatic;
    public static EnforceOnBuild UseSimpleUsingStatement;
    public static EnforceOnBuild MoveMisplacedUsingDirectives;
    public static EnforceOnBuild UseSystemHashCode;
    public static EnforceOnBuild SimplifyInterpolation;
    public static EnforceOnBuild UseCoalesceCompoundAssignment;
    public static EnforceOnBuild SimplifyConditionalExpression;
    public static EnforceOnBuild UsePatternCombinators;
    public static EnforceOnBuild RemoveUnnecessaryByVal;
    public static EnforceOnBuild ConvertTypeOfToNameOf;
    public static EnforceOnBuild UseNotPattern;
    public static EnforceOnBuild UseIsNotExpression;
    public static EnforceOnBuild UseImplicitObjectCreation;
    public static EnforceOnBuild RemoveRedundantEquality;
    public static EnforceOnBuild RemoveUnnecessaryDiscardDesignation;
    public static EnforceOnBuild InvokeDelegateWithConditionalAccess;
    public static EnforceOnBuild NamingRule;
    public static EnforceOnBuild RemoveUnnecessaryCast;
    public static EnforceOnBuild PopulateSwitchStatement;
    public static EnforceOnBuild UseInferredMemberName;
    public static EnforceOnBuild UseIsNullCheck;
    public static EnforceOnBuild AddRequiredParentheses;
    public static EnforceOnBuild ExpressionValueIsUnused;
    public static EnforceOnBuild MakeStructFieldsWritable;
    public static EnforceOnBuild ConvertSwitchStatementToExpression;
    public static EnforceOnBuild PopulateSwitchExpression;
    public static EnforceOnBuild Regex;
    public static EnforceOnBuild SimplifyNames;
    public static EnforceOnBuild SimplifyMemberAccess;
    public static EnforceOnBuild RemoveQualification;
    public static EnforceOnBuild AddQualification;
    public static EnforceOnBuild PreferBuiltInOrFrameworkType;
    public static EnforceOnBuild ConvertAnonymousTypeToTuple;
    public static EnforceOnBuild RemoveUnreachableCode;
    public static EnforceOnBuild RemoveUnnecessarySuppression;
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.CodeAnalysis.Diagnostics.EngineV2.DiagnosticIncrementalAnalyzer : object {
    private int _correlationId;
    private DiagnosticAnalyzerTelemetry _telemetry;
    private StateManager _stateManager;
    private InProcOrRemoteHostAnalyzerRunner _diagnosticAnalyzerRunner;
    [NullableAttribute("2")]
private IDocumentTrackingService _documentTrackingService;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private ConditionalWeakTable`2<Project, CompilationWithAnalyzers> _projectCompilationsWithAnalyzers;
    [CompilerGeneratedAttribute]
private DiagnosticAnalyzerService <AnalyzerService>k__BackingField;
    [CompilerGeneratedAttribute]
private Workspace <Workspace>k__BackingField;
    [CompilerGeneratedAttribute]
private IPersistentStorageService <PersistentStorageService>k__BackingField;
    internal DiagnosticAnalyzerService AnalyzerService { get; }
    internal Workspace Workspace { get; }
    internal IPersistentStorageService PersistentStorageService { get; }
    internal DiagnosticAnalyzerInfoCache DiagnosticAnalyzerInfoCache { get; }
    [ObsoleteAttribute("This factory method only provides services for the MEF export provider.", "True")]
public DiagnosticIncrementalAnalyzer(DiagnosticAnalyzerService analyzerService, int correlationId, Workspace workspace, DiagnosticAnalyzerInfoCache analyzerInfoCache);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.Diagnostics.EngineV2.DiagnosticIncrementalAnalyzer/<GetOrCreateCompilationWithAnalyzersAsync>d__3")]
private Task`1<CompilationWithAnalyzers> GetOrCreateCompilationWithAnalyzersAsync(Project project, IEnumerable`1<StateSet> stateSets, CancellationToken cancellationToken);
    private static Task`1<CompilationWithAnalyzers> CreateCompilationWithAnalyzersAsync(Project project, IEnumerable`1<StateSet> stateSets, bool includeSuppressedDiagnostics, CancellationToken cancellationToken);
    private void ClearCompilationsWithAnalyzersCache(Project project);
    private void ClearCompilationsWithAnalyzersCache();
    [ConditionalAttribute("DEBUG")]
private static void AssertAnalyzers(CompilationWithAnalyzers compilation, IEnumerable`1<StateSet> stateSets);
    [CompilerGeneratedAttribute]
internal DiagnosticAnalyzerService get_AnalyzerService();
    [CompilerGeneratedAttribute]
internal Workspace get_Workspace();
    [CompilerGeneratedAttribute]
internal IPersistentStorageService get_PersistentStorageService();
    internal DiagnosticAnalyzerInfoCache get_DiagnosticAnalyzerInfoCache();
    public bool ContainsDiagnostics(ProjectId projectId);
    public sealed virtual bool NeedsReanalysisOnOptionChanged(object sender, OptionChangedEventArgs e);
    private void OnProjectAnalyzerReferenceChanged(object sender, ProjectAnalyzerReferenceChangedEventArgs e);
    public void Shutdown();
    private void ClearAllDiagnostics(ImmutableArray`1<StateSet> stateSets, ProjectId projectId);
    private void RaiseDiagnosticsCreated(Project project, StateSet stateSet, ImmutableArray`1<DiagnosticData> items, Action`1<DiagnosticsUpdatedArgs> raiseEvents);
    private void RaiseDiagnosticsRemoved(ProjectId projectId, Solution solution, StateSet stateSet, Action`1<DiagnosticsUpdatedArgs> raiseEvents);
    private void RaiseDiagnosticsCreated(TextDocument document, StateSet stateSet, AnalysisKind kind, ImmutableArray`1<DiagnosticData> items, Action`1<DiagnosticsUpdatedArgs> raiseEvents);
    private void RaiseDiagnosticsRemoved(DocumentId documentId, Solution solution, StateSet stateSet, AnalysisKind kind, Action`1<DiagnosticsUpdatedArgs> raiseEvents);
    private static object CreateId(StateSet stateSet, DocumentId documentId, AnalysisKind kind);
    private static object CreateId(StateSet stateSet, ProjectId projectId, AnalysisKind kind);
    public static Task`1<VersionStamp> GetDiagnosticVersionAsync(Project project, CancellationToken cancellationToken);
    private static DiagnosticAnalysisResult GetResultOrEmpty(ImmutableDictionary`2<DiagnosticAnalyzer, DiagnosticAnalysisResult> map, DiagnosticAnalyzer analyzer, ProjectId projectId, VersionStamp version);
    public void LogAnalyzerCountSummary();
    internal IEnumerable`1<DiagnosticAnalyzer> GetAnalyzersTestOnly(Project project);
    private static string GetDocumentLogMessage(string title, TextDocument document, DiagnosticAnalyzer analyzer);
    private static string GetProjectLogMessage(Project project, IEnumerable`1<StateSet> stateSets);
    private static string GetResetLogMessage(TextDocument document);
    private static string GetOpenLogMessage(TextDocument document);
    private static string GetRemoveLogMessage(DocumentId id);
    private static string GetRemoveLogMessage(ProjectId id);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.Diagnostics.EngineV2.DiagnosticIncrementalAnalyzer/<TryGetCachedDocumentAnalysisDataAsync>d__47")]
private Task`1<Nullable`1<DocumentAnalysisData>> TryGetCachedDocumentAnalysisDataAsync(TextDocument document, StateSet stateSet, AnalysisKind kind, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.Diagnostics.EngineV2.DiagnosticIncrementalAnalyzer/<ComputeDocumentAnalysisDataAsync>d__48")]
private static Task`1<DocumentAnalysisData> ComputeDocumentAnalysisDataAsync(DocumentAnalysisExecutor executor, StateSet stateSet, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.Diagnostics.EngineV2.DiagnosticIncrementalAnalyzer/<GetProjectAnalysisDataAsync>d__49")]
private Task`1<ProjectAnalysisData> GetProjectAnalysisDataAsync(CompilationWithAnalyzers compilationWithAnalyzers, Project project, IEnumerable`1<StateSet> stateSets, bool forceAnalyzerRun, CancellationToken cancellationToken);
    private static bool CompilationHasOpenFileOnlyAnalyzers(CompilationWithAnalyzers compilationWithAnalyzers, OptionSet options);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.Diagnostics.EngineV2.DiagnosticIncrementalAnalyzer/<RemoveCompilerSemanticErrorsIfProjectNotLoadedAsync>d__51")]
private static Task`1<ImmutableDictionary`2<DiagnosticAnalyzer, DiagnosticAnalysisResult>> RemoveCompilerSemanticErrorsIfProjectNotLoadedAsync(ImmutableDictionary`2<DiagnosticAnalyzer, DiagnosticAnalysisResult> result, Project project, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.Diagnostics.EngineV2.DiagnosticIncrementalAnalyzer/<ComputeDiagnosticsAsync>d__52")]
private Task`1<ImmutableDictionary`2<DiagnosticAnalyzer, DiagnosticAnalysisResult>> ComputeDiagnosticsAsync(CompilationWithAnalyzers compilationWithAnalyzers, Project project, ImmutableArray`1<DiagnosticAnalyzer> ideAnalyzers, bool forcedAnalysis, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.Diagnostics.EngineV2.DiagnosticIncrementalAnalyzer/<ComputeDiagnosticsAsync>d__53")]
private Task`1<ImmutableDictionary`2<DiagnosticAnalyzer, DiagnosticAnalysisResult>> ComputeDiagnosticsAsync(CompilationWithAnalyzers compilationWithAnalyzers, Project project, IEnumerable`1<StateSet> stateSets, bool forcedAnalysis, ImmutableDictionary`2<DiagnosticAnalyzer, DiagnosticAnalysisResult> existing, CancellationToken cancellationToken);
    private static ImmutableDictionary`2<DiagnosticAnalyzer, DiagnosticAnalysisResult> MergeExistingDiagnostics(VersionStamp version, ImmutableDictionary`2<DiagnosticAnalyzer, DiagnosticAnalysisResult> existing, ImmutableDictionary`2<DiagnosticAnalyzer, DiagnosticAnalysisResult> result);
    private static bool TryReduceAnalyzersToRun(CompilationWithAnalyzers compilationWithAnalyzers, Project project, VersionStamp version, ImmutableDictionary`2<DiagnosticAnalyzer, DiagnosticAnalysisResult> existing, ImmutableArray`1& analyzers);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.Diagnostics.EngineV2.DiagnosticIncrementalAnalyzer/<MergeProjectDiagnosticAnalyzerDiagnosticsAsync>d__56")]
private static Task`1<ImmutableDictionary`2<DiagnosticAnalyzer, DiagnosticAnalysisResult>> MergeProjectDiagnosticAnalyzerDiagnosticsAsync(Project project, ImmutableArray`1<DiagnosticAnalyzer> ideAnalyzers, Compilation compilation, ImmutableDictionary`2<DiagnosticAnalyzer, DiagnosticAnalysisResult> result, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.Diagnostics.EngineV2.DiagnosticIncrementalAnalyzer/<GetDocumentLoadFailuresAsync>d__57")]
private static Task`1<ValueTuple`2<DiagnosticAnalysisResult, ImmutableHashSet`1<Document>>> GetDocumentLoadFailuresAsync(Project project, VersionStamp version, CancellationToken cancellationToken);
    private void UpdateAnalyzerTelemetryData(ImmutableDictionary`2<DiagnosticAnalyzer, AnalyzerTelemetryInfo> telemetry);
    internal static bool FullAnalysisEnabled(Project project, bool forceAnalyzerRun);
    private static void GetLogFunctionIdAndTitle(AnalysisKind kind, FunctionId& functionId, String& title);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.Diagnostics.EngineV2.DiagnosticIncrementalAnalyzer/<SynchronizeWithBuildAsync>d__67")]
public Task SynchronizeWithBuildAsync(ImmutableDictionary`2<ProjectId, ImmutableArray`1<DiagnosticData>> buildDiagnostics, TaskQueue postBuildAndErrorListRefreshTaskQueue, bool onBuildCompleted, CancellationToken cancellationToken);
    [ConditionalAttribute("DEBUG")]
private static void DebugVerifyDiagnosticLocations(ImmutableDictionary`2<ProjectId, ImmutableArray`1<DiagnosticData>> buildDiagnostics);
    private ImmutableDictionary`2<DiagnosticAnalyzer, DiagnosticAnalysisResult> CreateAnalysisResults(Project project, ImmutableArray`1<StateSet> stateSets, ImmutableArray`1<DiagnosticData> diagnostics);
    private static bool PreferBuildErrors(OptionSet options);
    private static bool PreferLiveErrorsOnOpenedFiles(OptionSet options);
    private static ImmutableArray`1<DiagnosticData> ConvertToLiveDiagnostics(ILookup`2<string, DiagnosticData> lookup, ImmutableArray`1<DiagnosticDescriptor> descriptors, HashSet`1<string> seen);
    private static DiagnosticData CreateLiveDiagnostic(DiagnosticDescriptor descriptor, DiagnosticData diagnostic);
    private static string LogSynchronizeWithBuild(OptionSet options, ImmutableDictionary`2<ProjectId, ImmutableArray`1<DiagnosticData>> map);
    public Task`1<ImmutableArray`1<DiagnosticData>> GetSpecificCachedDiagnosticsAsync(Solution solution, object id, bool includeSuppressedDiagnostics, CancellationToken cancellationToken);
    [NullableContextAttribute("2")]
public Task`1<ImmutableArray`1<DiagnosticData>> GetCachedDiagnosticsAsync(Solution solution, ProjectId projectId, DocumentId documentId, bool includeSuppressedDiagnostics, CancellationToken cancellationToken);
    [NullableContextAttribute("2")]
public Task`1<ImmutableArray`1<DiagnosticData>> GetDiagnosticsAsync(Solution solution, ProjectId projectId, DocumentId documentId, bool includeSuppressedDiagnostics, CancellationToken cancellationToken);
    [NullableContextAttribute("2")]
public Task`1<ImmutableArray`1<DiagnosticData>> GetDiagnosticsForIdsAsync(Solution solution, ProjectId projectId, DocumentId documentId, ImmutableHashSet`1<string> diagnosticIds, bool includeSuppressedDiagnostics, CancellationToken cancellationToken);
    public Task`1<ImmutableArray`1<DiagnosticData>> GetProjectDiagnosticsForIdsAsync(Solution solution, ProjectId projectId, ImmutableHashSet`1<string> diagnosticIds, bool includeSuppressedDiagnostics, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.Diagnostics.EngineV2.DiagnosticIncrementalAnalyzer/<TryAppendDiagnosticsForSpanAsync>d__83")]
public Task`1<bool> TryAppendDiagnosticsForSpanAsync(Document document, TextSpan range, ArrayBuilder`1<DiagnosticData> result, string diagnosticId, bool includeSuppressedDiagnostics, bool blockForData, Func`2<string, IDisposable> addOperationScope, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.Diagnostics.EngineV2.DiagnosticIncrementalAnalyzer/<GetDiagnosticsForSpanAsync>d__84")]
public Task`1<ImmutableArray`1<DiagnosticData>> GetDiagnosticsForSpanAsync(Document document, TextSpan range, string diagnosticId, bool includeSuppressedDiagnostics, bool blockForData, Func`2<string, IDisposable> addOperationScope, CancellationToken cancellationToken);
    public sealed virtual Task AnalyzeSyntaxAsync(Document document, InvocationReasons reasons, CancellationToken cancellationToken);
    public sealed virtual Task AnalyzeDocumentAsync(Document document, SyntaxNode bodyOpt, InvocationReasons reasons, CancellationToken cancellationToken);
    public sealed virtual Task AnalyzeNonSourceDocumentAsync(TextDocument textDocument, InvocationReasons reasons, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.Diagnostics.EngineV2.DiagnosticIncrementalAnalyzer/<AnalyzeDocumentForKindAsync>d__89")]
private Task AnalyzeDocumentForKindAsync(TextDocument document, AnalysisKind kind, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.Diagnostics.EngineV2.DiagnosticIncrementalAnalyzer/<AnalyzeProjectAsync>d__90")]
public sealed virtual Task AnalyzeProjectAsync(Project project, bool semanticsChanged, InvocationReasons reasons, CancellationToken cancellationToken);
    public Task ForceAnalyzeProjectAsync(Project project, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.Diagnostics.EngineV2.DiagnosticIncrementalAnalyzer/<AnalyzeProjectAsync>d__92")]
private Task AnalyzeProjectAsync(Project project, bool forceAnalyzerRun, CancellationToken cancellationToken);
    public sealed virtual Task DocumentOpenAsync(Document document, CancellationToken cancellationToken);
    public sealed virtual Task NonSourceDocumentOpenAsync(TextDocument document, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.Diagnostics.EngineV2.DiagnosticIncrementalAnalyzer/<TextDocumentOpenAsync>d__95")]
private Task TextDocumentOpenAsync(TextDocument document, CancellationToken cancellationToken);
    public sealed virtual Task DocumentCloseAsync(Document document, CancellationToken cancellationToken);
    public sealed virtual Task NonSourceDocumentCloseAsync(TextDocument document, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.Diagnostics.EngineV2.DiagnosticIncrementalAnalyzer/<TextDocumentCloseAsync>d__98")]
private Task TextDocumentCloseAsync(TextDocument document, CancellationToken cancellationToken);
    public sealed virtual Task DocumentResetAsync(Document document, CancellationToken cancellationToken);
    public sealed virtual Task NonSourceDocumentResetAsync(TextDocument document, CancellationToken cancellationToken);
    private Task TextDocumentResetAsync(TextDocument document, CancellationToken cancellationToken);
    private void RaiseDiagnosticsRemovedIfRequiredForClosedOrResetDocument(TextDocument document, IEnumerable`1<StateSet> stateSets, bool documentHadDiagnostics);
    public sealed virtual Task RemoveDocumentAsync(DocumentId documentId, CancellationToken cancellationToken);
    private void RaiseDiagnosticsRemovedForDocument(DocumentId documentId, IEnumerable`1<StateSet> stateSets);
    public sealed virtual Task RemoveProjectAsync(ProjectId projectId, CancellationToken cancellation);
    public sealed virtual Task NewSolutionSnapshotAsync(Solution solution, CancellationToken cancellationToken);
    private static bool AnalysisEnabled(TextDocument document);
    private IEnumerable`1<StateSet> GetStateSetsForFullSolutionAnalysis(IEnumerable`1<StateSet> stateSets, Project project);
    private bool IsCandidateForFullSolutionAnalysis(DiagnosticAnalyzer analyzer, Project project, Nullable`1<AnalyzerConfigOptionsResult> analyzerConfigOptions);
    private void RaiseProjectDiagnosticsIfNeeded(Project project, IEnumerable`1<StateSet> stateSets, ImmutableDictionary`2<DiagnosticAnalyzer, DiagnosticAnalysisResult> result);
    private void RaiseProjectDiagnosticsIfNeeded(Project project, IEnumerable`1<StateSet> stateSets, ImmutableDictionary`2<DiagnosticAnalyzer, DiagnosticAnalysisResult> oldResult, ImmutableDictionary`2<DiagnosticAnalyzer, DiagnosticAnalysisResult> newResult);
    private void RaiseDocumentDiagnosticsIfNeeded(TextDocument document, StateSet stateSet, AnalysisKind kind, ImmutableArray`1<DiagnosticData> items);
    private void RaiseDocumentDiagnosticsIfNeeded(TextDocument document, StateSet stateSet, AnalysisKind kind, ImmutableArray`1<DiagnosticData> oldItems, ImmutableArray`1<DiagnosticData> newItems);
    private void RaiseDocumentDiagnosticsIfNeeded(TextDocument document, StateSet stateSet, AnalysisKind kind, DiagnosticAnalysisResult oldResult, DiagnosticAnalysisResult newResult, Action`1<DiagnosticsUpdatedArgs> raiseEvents);
    private void RaiseDocumentDiagnosticsIfNeeded(TextDocument document, StateSet stateSet, AnalysisKind kind, ImmutableArray`1<DiagnosticData> oldItems, ImmutableArray`1<DiagnosticData> newItems, Action`1<DiagnosticsUpdatedArgs> raiseEvents, bool forceUpdate);
    private void RaiseProjectDiagnosticsCreated(Project project, StateSet stateSet, DiagnosticAnalysisResult oldAnalysisResult, DiagnosticAnalysisResult newAnalysisResult, Action`1<DiagnosticsUpdatedArgs> raiseEvents);
    private void RaiseProjectDiagnosticsRemoved(StateSet stateSet, ProjectId projectId, IEnumerable`1<DocumentId> documentIds, bool handleActiveFile, Action`1<DiagnosticsUpdatedArgs> raiseEvents);
}
internal interface Microsoft.CodeAnalysis.Diagnostics.IAnalyzerDriverService {
    public abstract virtual void ComputeDeclarationsInSpan(SemanticModel model, TextSpan span, bool getSymbol, ArrayBuilder`1<DeclarationInfo> builder, CancellationToken cancellationToken);
}
internal static class Microsoft.CodeAnalysis.Diagnostics.IDEDiagnosticIds : object {
    public static string SimplifyNamesDiagnosticId;
    public static string SimplifyMemberAccessDiagnosticId;
    public static string RemoveQualificationDiagnosticId;
    public static string RemoveUnnecessaryCastDiagnosticId;
    public static string RemoveUnnecessaryImportsDiagnosticId;
    public static string IntellisenseBuildFailedDiagnosticId;
    public static string UseImplicitTypeDiagnosticId;
    public static string UseExplicitTypeDiagnosticId;
    public static string AddQualificationDiagnosticId;
    public static string PopulateSwitchStatementDiagnosticId;
    public static string AddBracesDiagnosticId;
    public static string UseThrowExpressionDiagnosticId;
    public static string UseObjectInitializerDiagnosticId;
    public static string InlineDeclarationDiagnosticId;
    public static string InlineAsTypeCheckId;
    public static string InlineIsTypeCheckId;
    public static string UseExpressionBodyForConstructorsDiagnosticId;
    public static string UseExpressionBodyForMethodsDiagnosticId;
    public static string UseExpressionBodyForConversionOperatorsDiagnosticId;
    public static string UseExpressionBodyForOperatorsDiagnosticId;
    public static string UseExpressionBodyForPropertiesDiagnosticId;
    public static string UseExpressionBodyForIndexersDiagnosticId;
    public static string UseExpressionBodyForAccessorsDiagnosticId;
    public static string UseCollectionInitializerDiagnosticId;
    public static string UseCoalesceExpressionDiagnosticId;
    public static string UseCoalesceExpressionForNullableDiagnosticId;
    public static string UseNullPropagationDiagnosticId;
    public static string UseAutoPropertyDiagnosticId;
    public static string UseExplicitTupleNameDiagnosticId;
    public static string UseDefaultLiteralDiagnosticId;
    public static string RemoveUnreachableCodeDiagnosticId;
    public static string OrderModifiersDiagnosticId;
    public static string UseInferredMemberNameDiagnosticId;
    public static string InlineIsTypeWithoutNameCheckDiagnosticsId;
    public static string UseLocalFunctionDiagnosticId;
    public static string AddAccessibilityModifiersDiagnosticId;
    public static string UseIsNullCheckDiagnosticId;
    public static string UseDeconstructionDiagnosticId;
    public static string ValidateFormatStringDiagnosticID;
    public static string MakeFieldReadonlyDiagnosticId;
    public static string UseConditionalExpressionForAssignmentDiagnosticId;
    public static string UseConditionalExpressionForReturnDiagnosticId;
    public static string RemoveUnnecessaryParenthesesDiagnosticId;
    public static string AddRequiredParenthesesDiagnosticId;
    public static string PreferBuiltInOrFrameworkTypeDiagnosticId;
    public static string ConvertAnonymousTypeToTupleDiagnosticId;
    public static string RemoveUnusedMembersDiagnosticId;
    public static string RemoveUnreadMembersDiagnosticId;
    public static string UseExpressionBodyForLambdaExpressionsDiagnosticId;
    public static string UseCompoundAssignmentDiagnosticId;
    public static string FormattingDiagnosticId;
    public static string UseIndexOperatorDiagnosticId;
    public static string UseRangeOperatorDiagnosticId;
    public static string ExpressionValueIsUnusedDiagnosticId;
    public static string ValueAssignedIsUnusedDiagnosticId;
    public static string UnusedParameterDiagnosticId;
    public static string UseExpressionBodyForLocalFunctionsDiagnosticId;
    public static string MakeLocalFunctionStaticDiagnosticId;
    public static string UseSimpleUsingStatementDiagnosticId;
    public static string MakeStructFieldsWritable;
    public static string MoveMisplacedUsingDirectivesDiagnosticId;
    public static string ConvertSwitchStatementToExpressionDiagnosticId;
    public static string UseSystemHashCode;
    public static string SimplifyInterpolationId;
    public static string PopulateSwitchExpressionDiagnosticId;
    public static string FileHeaderMismatch;
    public static string UseCoalesceCompoundAssignmentDiagnosticId;
    public static string SimplifyConditionalExpressionDiagnosticId;
    public static string InvalidSuppressMessageAttributeDiagnosticId;
    public static string LegacyFormatSuppressMessageAttributeDiagnosticId;
    public static string UsePatternCombinatorsDiagnosticId;
    public static string RemoveUnnecessarySuppressionDiagnosticId;
    public static string RemoveConfusingSuppressionForIsExpressionDiagnosticId;
    public static string RemoveUnnecessaryByValDiagnosticId;
    public static string ConvertTypeOfToNameOfDiagnosticId;
    public static string UseNotPatternDiagnosticId;
    public static string UseIsNotExpressionDiagnosticId;
    public static string UseImplicitObjectCreationDiagnosticId;
    public static string RemoveRedundantEqualityDiagnosticId;
    public static string RemoveUnnecessaryDiscardDesignationDiagnosticId;
    public static string AnalyzerChangedId;
    public static string AnalyzerDependencyConflictId;
    public static string MissingAnalyzerReferenceId;
    public static string ErrorReadingRulesetId;
    public static string InvokeDelegateWithConditionalAccessId;
    public static string NamingRuleId;
    public static string UnboundIdentifierId;
    public static string UnboundConstructorId;
}
internal static class Microsoft.CodeAnalysis.Diagnostics.IDEDiagnosticIdToOptionMappingHelper : object {
    private static ConcurrentDictionary`2<string, ImmutableHashSet`1<IOption2>> s_diagnosticIdToOptionMap;
    private static ConcurrentDictionary`2<string, ConcurrentDictionary`2<string, ImmutableHashSet`1<IOption2>>> s_diagnosticIdToLanguageSpecificOptionsMap;
    private static IDEDiagnosticIdToOptionMappingHelper();
    public static bool TryGetMappedOptions(string diagnosticId, string language, ImmutableHashSet`1& options);
    public static void AddOptionMapping(string diagnosticId, ImmutableHashSet`1<IPerLanguageOption> perLanguageOptions);
    public static void AddOptionMapping(string diagnosticId, ImmutableHashSet`1<ILanguageSpecificOption> languageSpecificOptions, string language);
    private static void AddOptionMapping(ConcurrentDictionary`2<string, ImmutableHashSet`1<IOption2>> map, string diagnosticId, ImmutableHashSet`1<IOption2> options);
}
[NullableContextAttribute("1")]
internal interface Microsoft.CodeAnalysis.Diagnostics.IDiagnosticAnalyzerService {
    public DiagnosticAnalyzerInfoCache AnalyzerInfoCache { get; }
    public abstract virtual DiagnosticAnalyzerInfoCache get_AnalyzerInfoCache();
    public abstract virtual void Reanalyze(Workspace workspace, IEnumerable`1<ProjectId> projectIds, IEnumerable`1<DocumentId> documentIds, bool highPriority);
    public abstract virtual Task`1<ImmutableArray`1<DiagnosticData>> GetSpecificCachedDiagnosticsAsync(Workspace workspace, object id, bool includeSuppressedDiagnostics, CancellationToken cancellationToken);
    [NullableContextAttribute("2")]
public abstract virtual Task`1<ImmutableArray`1<DiagnosticData>> GetCachedDiagnosticsAsync(Workspace workspace, ProjectId projectId, DocumentId documentId, bool includeSuppressedDiagnostics, CancellationToken cancellationToken);
    [NullableContextAttribute("2")]
public abstract virtual Task`1<ImmutableArray`1<DiagnosticData>> GetDiagnosticsAsync(Solution solution, ProjectId projectId, DocumentId documentId, bool includeSuppressedDiagnostics, CancellationToken cancellationToken);
    public abstract virtual Task ForceAnalyzeAsync(Solution solution, Action`1<Project> onProjectAnalyzed, ProjectId projectId, CancellationToken cancellationToken);
    public abstract virtual bool ContainsDiagnostics(Workspace workspace, ProjectId projectId);
    [NullableContextAttribute("2")]
public abstract virtual Task`1<ImmutableArray`1<DiagnosticData>> GetDiagnosticsForIdsAsync(Solution solution, ProjectId projectId, DocumentId documentId, ImmutableHashSet`1<string> diagnosticIds, bool includeSuppressedDiagnostics, CancellationToken cancellationToken);
    public abstract virtual Task`1<ImmutableArray`1<DiagnosticData>> GetProjectDiagnosticsForIdsAsync(Solution solution, ProjectId projectId, ImmutableHashSet`1<string> diagnosticIds, bool includeSuppressedDiagnostics, CancellationToken cancellationToken);
    public abstract virtual Task`1<bool> TryAppendDiagnosticsForSpanAsync(Document document, TextSpan range, ArrayBuilder`1<DiagnosticData> diagnostics, bool includeSuppressedDiagnostics, CancellationToken cancellationToken);
    public abstract virtual Task`1<ImmutableArray`1<DiagnosticData>> GetDiagnosticsForSpanAsync(Document document, TextSpan range, string diagnosticIdOpt, bool includeSuppressedDiagnostics, Func`2<string, IDisposable> addOperationScope, CancellationToken cancellationToken);
}
internal interface Microsoft.CodeAnalysis.Diagnostics.IDiagnosticModeService {
    [NullableContextAttribute("1")]
public abstract virtual DiagnosticMode GetDiagnosticMode(Option2`1<DiagnosticMode> diagnosticMode);
}
[NullableContextAttribute("1")]
internal interface Microsoft.CodeAnalysis.Diagnostics.IDiagnosticService {
    [CompilerGeneratedAttribute]
public abstract virtual void add_DiagnosticsUpdated(EventHandler`1<DiagnosticsUpdatedArgs> value);
    [CompilerGeneratedAttribute]
public abstract virtual void remove_DiagnosticsUpdated(EventHandler`1<DiagnosticsUpdatedArgs> value);
    [NullableContextAttribute("2")]
[ObsoleteAttribute("Legacy overload for TypeScript.  Use GetPullDiagnostics or GetPushDiagnostics instead.", "False")]
public abstract virtual ImmutableArray`1<DiagnosticData> GetDiagnostics(Workspace workspace, ProjectId projectId, DocumentId documentId, object id, bool includeSuppressedDiagnostics, CancellationToken cancellationToken);
    [NullableContextAttribute("2")]
public abstract virtual ValueTask`1<ImmutableArray`1<DiagnosticData>> GetPullDiagnosticsAsync(Workspace workspace, ProjectId projectId, DocumentId documentId, object id, bool includeSuppressedDiagnostics, Option2`1<DiagnosticMode> diagnosticMode, CancellationToken cancellationToken);
    [NullableContextAttribute("2")]
public abstract virtual ValueTask`1<ImmutableArray`1<DiagnosticData>> GetPushDiagnosticsAsync(Workspace workspace, ProjectId projectId, DocumentId documentId, object id, bool includeSuppressedDiagnostics, Option2`1<DiagnosticMode> diagnosticMode, CancellationToken cancellationToken);
    public abstract virtual ImmutableArray`1<DiagnosticBucket> GetPullDiagnosticBuckets(Workspace workspace, ProjectId projectId, DocumentId documentId, Option2`1<DiagnosticMode> diagnosticMode, CancellationToken cancellationToken);
    public abstract virtual ImmutableArray`1<DiagnosticBucket> GetPushDiagnosticBuckets(Workspace workspace, ProjectId projectId, DocumentId documentId, Option2`1<DiagnosticMode> diagnosticMode, CancellationToken cancellationToken);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
internal static class Microsoft.CodeAnalysis.Diagnostics.IDiagnosticServiceExtensions : object {
    [ExtensionAttribute]
public static ValueTask`1<ImmutableArray`1<DiagnosticData>> GetPullDiagnosticsAsync(IDiagnosticService service, DiagnosticBucket bucket, bool includeSuppressedDiagnostics, Option2`1<DiagnosticMode> diagnosticMode, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static ValueTask`1<ImmutableArray`1<DiagnosticData>> GetPushDiagnosticsAsync(IDiagnosticService service, DiagnosticBucket bucket, bool includeSuppressedDiagnostics, Option2`1<DiagnosticMode> diagnosticMode, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static ValueTask`1<ImmutableArray`1<DiagnosticData>> GetPushDiagnosticsAsync(IDiagnosticService service, Document document, bool includeSuppressedDiagnostics, Option2`1<DiagnosticMode> diagnosticMode, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static ValueTask`1<ImmutableArray`1<DiagnosticData>> GetPullDiagnosticsAsync(IDiagnosticService service, Document document, bool includeSuppressedDiagnostics, Option2`1<DiagnosticMode> diagnosticMode, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.Diagnostics.IDiagnosticServiceExtensions/<GetDiagnosticsAsync>d__4")]
[ExtensionAttribute]
public static ValueTask`1<ImmutableArray`1<DiagnosticData>> GetDiagnosticsAsync(IDiagnosticService service, Document document, bool includeSuppressedDiagnostics, bool forPullDiagnostics, Option2`1<DiagnosticMode> diagnosticMode, CancellationToken cancellationToken);
}
[NullableContextAttribute("1")]
internal interface Microsoft.CodeAnalysis.Diagnostics.IDiagnosticUpdateSource {
    public bool SupportGetDiagnostics { get; }
    [CompilerGeneratedAttribute]
public abstract virtual void add_DiagnosticsUpdated(EventHandler`1<DiagnosticsUpdatedArgs> value);
    [CompilerGeneratedAttribute]
public abstract virtual void remove_DiagnosticsUpdated(EventHandler`1<DiagnosticsUpdatedArgs> value);
    [CompilerGeneratedAttribute]
public abstract virtual void add_DiagnosticsCleared(EventHandler value);
    [CompilerGeneratedAttribute]
public abstract virtual void remove_DiagnosticsCleared(EventHandler value);
    public abstract virtual bool get_SupportGetDiagnostics();
    public abstract virtual ValueTask`1<ImmutableArray`1<DiagnosticData>> GetDiagnosticsAsync(Workspace workspace, ProjectId projectId, DocumentId documentId, object id, bool includeSuppressedDiagnostics, CancellationToken cancellationToken);
}
internal interface Microsoft.CodeAnalysis.Diagnostics.IDiagnosticUpdateSourceRegistrationService {
    public abstract virtual void Register(IDiagnosticUpdateSource source);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.CodeAnalysis.Diagnostics.InProcOrRemoteHostAnalyzerRunner : object {
    private IAsynchronousOperationListener _asyncOperationListener;
    [CompilerGeneratedAttribute]
private DiagnosticAnalyzerInfoCache <AnalyzerInfoCache>k__BackingField;
    public DiagnosticAnalyzerInfoCache AnalyzerInfoCache { get; }
    public InProcOrRemoteHostAnalyzerRunner(DiagnosticAnalyzerInfoCache analyzerInfoCache, IAsynchronousOperationListener operationListener);
    [CompilerGeneratedAttribute]
public DiagnosticAnalyzerInfoCache get_AnalyzerInfoCache();
    public Task`1<DiagnosticAnalysisResultMap`2<DiagnosticAnalyzer, DiagnosticAnalysisResult>> AnalyzeDocumentAsync(DocumentAnalysisScope documentAnalysisScope, CompilationWithAnalyzers compilationWithAnalyzers, bool logPerformanceInfo, bool getTelemetryInfo, CancellationToken cancellationToken);
    public Task`1<DiagnosticAnalysisResultMap`2<DiagnosticAnalyzer, DiagnosticAnalysisResult>> AnalyzeProjectAsync(Project project, CompilationWithAnalyzers compilationWithAnalyzers, bool forceExecuteAllAnalyzers, bool logPerformanceInfo, bool getTelemetryInfo, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.Diagnostics.InProcOrRemoteHostAnalyzerRunner/<AnalyzeAsync>d__7")]
private Task`1<DiagnosticAnalysisResultMap`2<DiagnosticAnalyzer, DiagnosticAnalysisResult>> AnalyzeAsync(DocumentAnalysisScope documentAnalysisScope, Project project, CompilationWithAnalyzers compilationWithAnalyzers, bool forceExecuteAllAnalyzers, bool logPerformanceInfo, bool getTelemetryInfo, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.Diagnostics.InProcOrRemoteHostAnalyzerRunner/<AnalyzeInProcAsync>d__8")]
private Task`1<DiagnosticAnalysisResultMap`2<DiagnosticAnalyzer, DiagnosticAnalysisResult>> AnalyzeInProcAsync(DocumentAnalysisScope documentAnalysisScope, Project project, CompilationWithAnalyzers compilationWithAnalyzers, RemoteHostClient client, bool logPerformanceInfo, bool getTelemetryInfo, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.Diagnostics.InProcOrRemoteHostAnalyzerRunner/<FireAndForgetReportAnalyzerPerformanceAsync>d__9")]
private Task FireAndForgetReportAnalyzerPerformanceAsync(DocumentAnalysisScope documentAnalysisScope, Project project, RemoteHostClient client, AnalysisResult analysisResult, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.Diagnostics.InProcOrRemoteHostAnalyzerRunner/<AnalyzeOutOfProcAsync>d__10")]
private static Task`1<DiagnosticAnalysisResultMap`2<DiagnosticAnalyzer, DiagnosticAnalysisResult>> AnalyzeOutOfProcAsync(DocumentAnalysisScope documentAnalysisScope, Project project, CompilationWithAnalyzers compilationWithAnalyzers, RemoteHostClient client, bool forceExecuteAllAnalyzers, bool logPerformanceInfo, bool getTelemetryInfo, CancellationToken cancellationToken);
    private static ImmutableDictionary`2<DocumentId, ImmutableArray`1<DiagnosticData>> Hydrate(ImmutableArray`1<ValueTuple`2<DocumentId, ImmutableArray`1<DiagnosticData>>> diagnosticByDocument, Project project);
}
[ExportOptionProviderAttribute]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.Diagnostics.InternalDiagnosticsOptionsProvider : object {
    [CompilerGeneratedAttribute]
private ImmutableArray`1<IOption> <Options>k__BackingField;
    public ImmutableArray`1<IOption> Options { get; }
    [CompilerGeneratedAttribute]
public sealed virtual ImmutableArray`1<IOption> get_Options();
}
internal interface Microsoft.CodeAnalysis.Diagnostics.IRemoteDiagnosticAnalyzerService {
    public abstract virtual ValueTask`1<SerializableDiagnosticAnalysisResults> CalculateDiagnosticsAsync(PinnedSolutionInfo solutionInfo, DiagnosticArguments arguments, CancellationToken cancellationToken);
    public abstract virtual ValueTask ReportAnalyzerPerformanceAsync(ImmutableArray`1<AnalyzerPerformanceInfo> snapshot, int unitCount, CancellationToken cancellationToken);
}
internal interface Microsoft.CodeAnalysis.Diagnostics.ISupportLiveUpdate {
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.CodeAnalysis.Diagnostics.LiveDiagnosticUpdateArgsId : AnalyzerUpdateArgsId {
    private string _analyzerPackageName;
    public object ProjectOrDocumentId;
    public int Kind;
    public string BuildTool { get; }
    public LiveDiagnosticUpdateArgsId(DiagnosticAnalyzer analyzer, object projectOrDocumentId, int kind, string analyzerPackageName);
    public virtual string get_BuildTool();
    [NullableContextAttribute("2")]
public virtual bool Equals(object obj);
    public virtual int GetHashCode();
}
internal static class Microsoft.CodeAnalysis.Diagnostics.Log.DiagnosticLogger : object {
    private static string From;
    private static string Id;
    private static string HasDescription;
    private static string Uri;
    public static void LogHyperlink(string from, string id, bool description, bool telemetry, string uri);
}
internal static class Microsoft.CodeAnalysis.Diagnostics.PredefinedBuildTools : object {
    public static string Build;
    public static string Live;
    private static PredefinedBuildTools();
}
internal static class Microsoft.CodeAnalysis.Diagnostics.PredefinedDiagnosticProviderNames : object {
    public static string AddUsingOrImport;
    public static string ImplementInterface;
    public static string RemoveUnnecessaryCast;
    public static string RemoveUnnecessaryImports;
    public static string RenameTracking;
    public static string SimplifyNames;
    public static string SpellCheck;
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.CodeAnalysis.Diagnostics.SuppressMessageAttributeState : object {
    internal static string SuppressMessageScope;
    internal static string SuppressMessageTarget;
    private static ImmutableDictionary`2<string, TargetScope> s_targetScopesMap;
    private Compilation _compilation;
    private INamedTypeSymbol _suppressMessageAttributeType;
    [NullableAttribute("0")]
private static string s_suppressionPrefix;
    public SuppressMessageAttributeState(Compilation compilation, INamedTypeSymbol suppressMessageAttributeType);
    private static SuppressMessageAttributeState();
    private static ImmutableDictionary`2<string, TargetScope> CreateTargetScopesMap();
    public bool IsSuppressMessageAttributeWithNamedArguments(SyntaxNode attributeSyntax, SemanticModel model, CancellationToken cancellationToken, ImmutableArray`1& namedAttributeArguments);
    public static bool HasValidScope(ImmutableArray`1<ValueTuple`2<string, IOperation>> namedAttributeArguments, TargetScope& targetScope);
    [NullableContextAttribute("2")]
public bool HasValidTarget(ImmutableArray`1<ValueTuple`2<string, IOperation>> namedAttributeArguments, TargetScope targetScope, Boolean& targetHasDocCommentIdFormat, String& targetSymbolString, IOperation& targetValueOperation, ImmutableArray`1& resolvedSymbols);
    [NullableContextAttribute("2")]
private static bool TryGetNamedArgument(ImmutableArray`1<ValueTuple`2<string, IOperation>> namedAttributeArguments, string argumentName, String& argumentValue, IOperation& argumentValueOperation);
}
internal class Microsoft.CodeAnalysis.Diagnostics.WorkspaceAnalyzerOptions : AnalyzerOptions {
    private Solution _solution;
    public HostWorkspaceServices Services { get; }
    public WorkspaceAnalyzerOptions(AnalyzerOptions options, Solution solution);
    public HostWorkspaceServices get_Services();
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.Diagnostics.WorkspaceAnalyzerOptions/<GetDocumentOptionSetAsync>d__4")]
public ValueTask`1<OptionSet> GetDocumentOptionSetAsync(SyntaxTree syntaxTree, CancellationToken cancellationToken);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
}
internal abstract class Microsoft.CodeAnalysis.DocumentationComments.AbstractDocumentationCommentFormattingService : object {
    public sealed virtual string Format(string rawXmlText, Compilation compilation);
    public sealed virtual IEnumerable`1<TaggedText> Format(string rawXmlText, ISymbol symbol, SemanticModel semanticModel, int position, SymbolDisplayFormat format, CancellationToken cancellationToken);
    private static void AppendTextFromNode(FormatterState state, XNode node, Compilation compilation);
    private static Nullable`1<ValueTuple`2<string, string>> GetNavigationTarget(XElement element, SemanticModel semanticModel, int position, SymbolDisplayFormat format);
    private static void AppendTextFromAttribute(FormatterState state, XAttribute attribute, string attributeNameToParse, SymbolDisplayPartKind kind);
    internal static IEnumerable`1<SymbolDisplayPart> CrefToSymbolDisplayParts(string crefValue, int position, SemanticModel semanticModel, SymbolDisplayFormat format, SymbolDisplayPartKind kind);
    internal static IEnumerable`1<SymbolDisplayPart> TypeParameterRefToSymbolDisplayParts(string crefValue, ISymbol typeResolutionSymbol, int position, SemanticModel semanticModel, SymbolDisplayFormat format);
    private static string TrimCrefPrefix(string value);
    private static void AppendTextFromTextNode(FormatterState state, XText element);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal abstract class Microsoft.CodeAnalysis.DocumentationComments.AbstractDocumentationCommentSnippetService`2 : object {
    public string DocumentationCommentCharacter { get; }
    protected string ExteriorTriviaText { get; }
    protected bool AddIndent { get; }
    protected abstract virtual TMemberNode GetContainingMember(SyntaxTree syntaxTree, int position, CancellationToken cancellationToken);
    protected abstract virtual bool SupportsDocumentationComments(TMemberNode member);
    protected abstract virtual bool HasDocumentationComment(TMemberNode member);
    protected abstract virtual int GetPrecedingDocumentationCommentCount(TMemberNode member);
    protected abstract virtual bool IsMemberDeclaration(TMemberNode member);
    protected abstract virtual List`1<string> GetDocumentationCommentStubLines(TMemberNode member);
    protected abstract virtual SyntaxToken GetTokenToRight(SyntaxTree syntaxTree, int position, CancellationToken cancellationToken);
    protected abstract virtual SyntaxToken GetTokenToLeft(SyntaxTree syntaxTree, int position, CancellationToken cancellationToken);
    protected abstract virtual bool IsDocCommentNewLine(SyntaxToken token);
    protected abstract virtual bool IsEndOfLineTrivia(SyntaxTrivia trivia);
    protected abstract virtual bool IsSingleExteriorTrivia(TDocumentationComment documentationComment, bool allowWhitespace);
    [NullableContextAttribute("2")]
protected abstract virtual bool EndsWithSingleExteriorTrivia(TDocumentationComment documentationComment);
    [NullableContextAttribute("2")]
protected abstract virtual bool IsMultilineDocComment(TDocumentationComment documentationComment);
    protected abstract virtual bool HasSkippedTrailingTrivia(SyntaxToken token);
    public abstract virtual string get_DocumentationCommentCharacter();
    protected abstract virtual string get_ExteriorTriviaText();
    protected abstract virtual bool get_AddIndent();
    public sealed virtual DocumentationCommentSnippet GetDocumentationCommentSnippetOnCharacterTyped(SyntaxTree syntaxTree, SourceText text, int position, DocumentOptionSet options, CancellationToken cancellationToken);
    private List`1<string> GetDocumentationCommentLines(SyntaxToken token, SourceText text, DocumentOptionSet options, String& indentText);
    public sealed virtual bool IsValidTargetMember(SyntaxTree syntaxTree, SourceText text, int position, CancellationToken cancellationToken);
    private TMemberNode GetTargetMember(SyntaxTree syntaxTree, SourceText text, int position, CancellationToken cancellationToken);
    private TMemberNode GetTargetMember(TDocumentationComment documentationComment);
    private static void AddLineBreaks(IList`1<string> lines, string newLine);
    private static void IndentLines(List`1<string> lines, string indentText);
    public sealed virtual DocumentationCommentSnippet GetDocumentationCommentSnippetOnEnterTyped(SyntaxTree syntaxTree, SourceText text, int position, DocumentOptionSet options, CancellationToken cancellationToken);
    private DocumentationCommentSnippet GenerateDocumentationCommentAfterEnter(SyntaxTree syntaxTree, SourceText text, int position, DocumentOptionSet options, CancellationToken cancellationToken);
    public sealed virtual DocumentationCommentSnippet GetDocumentationCommentSnippetOnCommandInvoke(SyntaxTree syntaxTree, SourceText text, int position, DocumentOptionSet options, CancellationToken cancellationToken);
    private DocumentationCommentSnippet GenerateExteriorTriviaAfterEnter(SyntaxTree syntaxTree, SourceText text, int position, DocumentOptionSet options, CancellationToken cancellationToken);
    public sealed virtual DocumentationCommentSnippet GetDocumentationCommentSnippetFromPreviousLine(DocumentOptionSet options, TextLine currentLine, TextLine previousLine);
    private string CreateInsertionTextFromPreviousLine(TextLine previousLine, DocumentOptionSet options);
}
internal static class Microsoft.CodeAnalysis.DocumentationComments.DocumentationCommentOptions : object {
    [NullableAttribute("1")]
public static PerLanguageOption2`1<bool> AutoXmlDocCommentGeneration;
    private static DocumentationCommentOptions();
}
[ExportOptionProviderAttribute]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.DocumentationComments.DocumentationCommentOptionsProvider : object {
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private ImmutableArray`1<IOption> <Options>k__BackingField;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ImmutableArray`1<IOption> Options { get; }
    [CompilerGeneratedAttribute]
public sealed virtual ImmutableArray`1<IOption> get_Options();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.CodeAnalysis.DocumentationComments.DocumentationCommentSnippet : object {
    [CompilerGeneratedAttribute]
private TextSpan <SpanToReplace>k__BackingField;
    [CompilerGeneratedAttribute]
private string <SnippetText>k__BackingField;
    [CompilerGeneratedAttribute]
private int <CaretOffset>k__BackingField;
    public TextSpan SpanToReplace { get; }
    public string SnippetText { get; }
    public int CaretOffset { get; }
    internal DocumentationCommentSnippet(TextSpan spanToReplace, string snippetText, int caretOffset);
    [CompilerGeneratedAttribute]
public TextSpan get_SpanToReplace();
    [CompilerGeneratedAttribute]
public string get_SnippetText();
    [CompilerGeneratedAttribute]
public int get_CaretOffset();
}
internal interface Microsoft.CodeAnalysis.DocumentationComments.IDocumentationCommentFormattingService {
    public abstract virtual string Format(string rawXmlText, Compilation compilation);
    public abstract virtual IEnumerable`1<TaggedText> Format(string rawXmlText, ISymbol symbol, SemanticModel semanticModel, int position, SymbolDisplayFormat format, CancellationToken cancellationToken);
}
[NullableContextAttribute("1")]
internal interface Microsoft.CodeAnalysis.DocumentationComments.IDocumentationCommentSnippetService {
    public string DocumentationCommentCharacter { get; }
    public abstract virtual string get_DocumentationCommentCharacter();
    public abstract virtual DocumentationCommentSnippet GetDocumentationCommentSnippetOnCharacterTyped(SyntaxTree syntaxTree, SourceText text, int position, DocumentOptionSet options, CancellationToken cancellationToken);
    public abstract virtual DocumentationCommentSnippet GetDocumentationCommentSnippetOnCommandInvoke(SyntaxTree syntaxTree, SourceText text, int position, DocumentOptionSet options, CancellationToken cancellationToken);
    public abstract virtual DocumentationCommentSnippet GetDocumentationCommentSnippetOnEnterTyped(SyntaxTree syntaxTree, SourceText text, int position, DocumentOptionSet options, CancellationToken cancellationToken);
    public abstract virtual DocumentationCommentSnippet GetDocumentationCommentSnippetFromPreviousLine(DocumentOptionSet options, TextLine currentLine, TextLine previousLine);
    public abstract virtual bool IsValidTargetMember(SyntaxTree syntaxTree, SourceText text, int caretPosition, CancellationToken cancellationToken);
}
internal abstract class Microsoft.CodeAnalysis.DocumentHighlighting.AbstractDocumentHighlightsService : object {
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.DocumentHighlighting.AbstractDocumentHighlightsService/<GetDocumentHighlightsAsync>d__0")]
public sealed virtual Task`1<ImmutableArray`1<DocumentHighlights>> GetDocumentHighlightsAsync(Document document, int position, IImmutableSet`1<Document> documentsToSearch, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.DocumentHighlighting.AbstractDocumentHighlightsService/<GetDocumentHighlightsInCurrentProcessAsync>d__1")]
private Task`1<ImmutableArray`1<DocumentHighlights>> GetDocumentHighlightsInCurrentProcessAsync(Document document, int position, IImmutableSet`1<Document> documentsToSearch, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.DocumentHighlighting.AbstractDocumentHighlightsService/<TryGetEmbeddedLanguageHighlightsAsync>d__2")]
private static Task`1<ImmutableArray`1<DocumentHighlights>> TryGetEmbeddedLanguageHighlightsAsync(Document document, int position, IImmutableSet`1<Document> documentsToSearch, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.DocumentHighlighting.AbstractDocumentHighlightsService/<GetTagsForReferencedSymbolAsync>d__3")]
private Task`1<ImmutableArray`1<DocumentHighlights>> GetTagsForReferencedSymbolAsync(ISymbol symbol, Document document, IImmutableSet`1<Document> documentsToSearch, CancellationToken cancellationToken);
    private static bool ShouldConsiderSymbol(ISymbol symbol);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.DocumentHighlighting.AbstractDocumentHighlightsService/<FilterAndCreateSpansAsync>d__5")]
private Task`1<ImmutableArray`1<DocumentHighlights>> FilterAndCreateSpansAsync(ImmutableArray`1<ReferencedSymbol> references, Document startingDocument, IImmutableSet`1<Document> documentsToSearch, ISymbol symbol, FindReferencesSearchOptions options, CancellationToken cancellationToken);
    protected virtual Task`1<ImmutableArray`1<Location>> GetAdditionalReferencesAsync(Document document, ISymbol symbol, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.DocumentHighlighting.AbstractDocumentHighlightsService/<CreateSpansAsync>d__7")]
private static Task`1<ImmutableArray`1<DocumentHighlights>> CreateSpansAsync(Solution solution, ISymbol symbol, IEnumerable`1<ReferencedSymbol> references, ArrayBuilder`1<Location> additionalReferences, IImmutableSet`1<Document> documentToSearch, CancellationToken cancellationToken);
    private static bool ShouldIncludeDefinition(ISymbol symbol);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.DocumentHighlighting.AbstractDocumentHighlightsService/<AddLocationSpanAsync>d__9")]
private static Task AddLocationSpanAsync(Location location, Solution solution, HashSet`1<DocumentSpan> spanSet, MultiDictionary`2<Document, HighlightSpan> tagList, HighlightSpanKind kind, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.DocumentHighlighting.AbstractDocumentHighlightsService/<GetLocationSpanAsync>d__10")]
private static Task`1<Nullable`1<DocumentSpan>> GetLocationSpanAsync(Solution solution, Location location, CancellationToken cancellationToken);
}
[IsReadOnlyAttribute]
internal class Microsoft.CodeAnalysis.DocumentHighlighting.DocumentHighlights : ValueType {
    [CompilerGeneratedAttribute]
private Document <Document>k__BackingField;
    [CompilerGeneratedAttribute]
private ImmutableArray`1<HighlightSpan> <HighlightSpans>k__BackingField;
    public Document Document { get; }
    public ImmutableArray`1<HighlightSpan> HighlightSpans { get; }
    public DocumentHighlights(Document document, ImmutableArray`1<HighlightSpan> highlightSpans);
    [CompilerGeneratedAttribute]
public Document get_Document();
    [CompilerGeneratedAttribute]
public ImmutableArray`1<HighlightSpan> get_HighlightSpans();
}
[IsReadOnlyAttribute]
[DataContractAttribute]
internal class Microsoft.CodeAnalysis.DocumentHighlighting.HighlightSpan : ValueType {
    [CompilerGeneratedAttribute]
private TextSpan <TextSpan>k__BackingField;
    [CompilerGeneratedAttribute]
private HighlightSpanKind <Kind>k__BackingField;
    [DataMemberAttribute]
public TextSpan TextSpan { get; }
    [DataMemberAttribute]
public HighlightSpanKind Kind { get; }
    public HighlightSpan(TextSpan textSpan, HighlightSpanKind kind);
    [CompilerGeneratedAttribute]
public TextSpan get_TextSpan();
    [CompilerGeneratedAttribute]
public HighlightSpanKind get_Kind();
}
internal enum Microsoft.CodeAnalysis.DocumentHighlighting.HighlightSpanKind : Enum {
    public int value__;
    public static HighlightSpanKind None;
    public static HighlightSpanKind Definition;
    public static HighlightSpanKind Reference;
    public static HighlightSpanKind WrittenReference;
}
internal interface Microsoft.CodeAnalysis.DocumentHighlighting.IDocumentHighlightsService {
    public abstract virtual Task`1<ImmutableArray`1<DocumentHighlights>> GetDocumentHighlightsAsync(Document document, int position, IImmutableSet`1<Document> documentsToSearch, CancellationToken cancellationToken);
}
[NullableContextAttribute("1")]
internal interface Microsoft.CodeAnalysis.DocumentHighlighting.IRemoteDocumentHighlightsService {
    public abstract virtual ValueTask`1<ImmutableArray`1<SerializableDocumentHighlights>> GetDocumentHighlightsAsync(PinnedSolutionInfo solutionInfo, DocumentId documentId, int position, ImmutableArray`1<DocumentId> documentIdsToSearch, CancellationToken cancellationToken);
}
[IsReadOnlyAttribute]
[DataContractAttribute]
internal class Microsoft.CodeAnalysis.DocumentHighlighting.SerializableDocumentHighlights : ValueType {
    [NullableAttribute("1")]
[DataMemberAttribute]
public DocumentId DocumentId;
    [DataMemberAttribute]
public ImmutableArray`1<HighlightSpan> HighlightSpans;
    public SerializableDocumentHighlights(DocumentId documentId, ImmutableArray`1<HighlightSpan> highlightSpans);
    [NullableContextAttribute("1")]
public DocumentHighlights Rehydrate(Solution solution);
    public static SerializableDocumentHighlights Dehydrate(DocumentHighlights highlights);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[IsReadOnlyAttribute]
internal class Microsoft.CodeAnalysis.DocumentSpan : ValueType {
    [CompilerGeneratedAttribute]
private Document <Document>k__BackingField;
    [CompilerGeneratedAttribute]
private TextSpan <SourceSpan>k__BackingField;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private ImmutableDictionary`2<string, object> <Properties>k__BackingField;
    public Document Document { get; }
    public TextSpan SourceSpan { get; }
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ImmutableDictionary`2<string, object> Properties { get; }
    public DocumentSpan(Document document, TextSpan sourceSpan);
    public DocumentSpan(Document document, TextSpan sourceSpan, ImmutableDictionary`2<string, object> properties);
    [CompilerGeneratedAttribute]
public Document get_Document();
    [CompilerGeneratedAttribute]
public TextSpan get_SourceSpan();
    [CompilerGeneratedAttribute]
public ImmutableDictionary`2<string, object> get_Properties();
    [NullableContextAttribute("2")]
public virtual bool Equals(object obj);
    public sealed virtual bool Equals(DocumentSpan obj);
    public static bool op_Equality(DocumentSpan d1, DocumentSpan d2);
    public static bool op_Inequality(DocumentSpan d1, DocumentSpan d2);
    public virtual int GetHashCode();
}
[ExtensionAttribute]
internal static class Microsoft.CodeAnalysis.DocumentSpanExtensions : object {
    [ExtensionAttribute]
public static bool CanNavigateTo(DocumentSpan documentSpan, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static bool TryNavigateTo(DocumentSpan documentSpan, bool showInPreviewTab, bool activateTab, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.DocumentSpanExtensions/<IsHiddenAsync>d__2")]
[ExtensionAttribute]
public static Task`1<bool> IsHiddenAsync(DocumentSpan documentSpan, CancellationToken cancellationToken);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal abstract class Microsoft.CodeAnalysis.EditAndContinue.AbstractEditAndContinueAnalyzer : object {
    internal static int DefaultStatementPart;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private Action`1<SyntaxNode> _testFaultInjector;
    private static SourceText s_emptySource;
    protected static SymbolEquivalenceComparer s_assemblyEqualityComparer;
    protected SymbolDisplayFormat ErrorDisplayFormat { get; }
    internal SyntaxNode EmptyCompilationUnit { get; }
    protected AbstractEditAndContinueAnalyzer(Action`1<SyntaxNode> testFaultInjector);
    private static AbstractEditAndContinueAnalyzer();
    internal abstract virtual bool ExperimentalFeaturesEnabled(SyntaxTree tree);
    [NullableContextAttribute("2")]
internal abstract virtual SyntaxNode FindMemberDeclaration(SyntaxNode root, SyntaxNode node);
    internal SyntaxNode FindMemberDeclaration(SyntaxNode root, int activeStatementStart);
    internal abstract virtual SyntaxNode TryGetDeclarationBody(SyntaxNode node, bool isMember);
    [NullableContextAttribute("2")]
protected virtual bool TryGetDeclarationBodyEdit(Edit`1<SyntaxNode> edit, Dictionary`2<SyntaxNode, EditKind> editMap, SyntaxNode& oldBody, SyntaxNode& newBody);
    internal abstract virtual IEnumerable`1<SyntaxToken> TryGetActiveTokens(SyntaxNode node);
    [NullableContextAttribute("2")]
protected SyntaxNode GetEncompassingAncestor(SyntaxNode bodyOrMatchRoot);
    protected abstract virtual SyntaxNode GetEncompassingAncestorImpl(SyntaxNode bodyOrMatchRoot);
    protected abstract virtual SyntaxNode FindStatementAndPartner(SyntaxNode declarationBody, TextSpan span, SyntaxNode partnerDeclarationBody, SyntaxNode& partner, Int32& statementPart);
    private SyntaxNode FindStatement(SyntaxNode declarationBody, TextSpan span, Int32& statementPart);
    internal abstract virtual SyntaxNode FindPartner(SyntaxNode leftRoot, SyntaxNode rightRoot, SyntaxNode leftNode);
    internal abstract virtual SyntaxNode FindPartnerInMemberInitializer(SemanticModel leftModel, INamedTypeSymbol leftType, SyntaxNode leftNode, INamedTypeSymbol rightType, CancellationToken cancellationToken);
    [NullableContextAttribute("2")]
protected abstract virtual SyntaxNode FindEnclosingLambdaBody(SyntaxNode container, SyntaxNode node);
    protected abstract virtual IEnumerable`1<SyntaxNode> GetLambdaBodyExpressionsAndStatements(SyntaxNode lambdaBody);
    protected abstract virtual SyntaxNode TryGetPartnerLambdaBody(SyntaxNode oldBody, SyntaxNode newLambda);
    protected abstract virtual Match`1<SyntaxNode> ComputeTopLevelMatch(SyntaxNode oldCompilationUnit, SyntaxNode newCompilationUnit);
    protected abstract virtual Match`1<SyntaxNode> ComputeBodyMatch(SyntaxNode oldBody, SyntaxNode newBody, IEnumerable`1<KeyValuePair`2<SyntaxNode, SyntaxNode>> knownMatches);
    protected abstract virtual IEnumerable`1<SequenceEdit> GetSyntaxSequenceEdits(ImmutableArray`1<SyntaxNode> oldNodes, ImmutableArray`1<SyntaxNode> newNodes);
    protected abstract virtual bool TryMatchActiveStatement(SyntaxNode oldStatement, int statementPart, SyntaxNode oldBody, SyntaxNode newBody, SyntaxNode& newStatement);
    protected abstract virtual bool TryGetEnclosingBreakpointSpan(SyntaxNode root, int position, TextSpan& span);
    protected abstract virtual bool TryGetActiveSpan(SyntaxNode node, int statementPart, int minLength, TextSpan& span);
    protected abstract virtual IEnumerable`1<ValueTuple`2<SyntaxNode, int>> EnumerateNearStatements(SyntaxNode statement);
    protected abstract virtual bool StatementLabelEquals(SyntaxNode node1, SyntaxNode node2);
    protected virtual bool StateMachineSuspensionPointKindEquals(SyntaxNode suspensionPoint1, SyntaxNode suspensionPoint2);
    protected abstract virtual bool AreEquivalent(SyntaxNode left, SyntaxNode right);
    protected abstract virtual bool AreEquivalentActiveStatements(SyntaxNode oldStatement, SyntaxNode newStatement, int statementPart);
    protected abstract virtual ISymbol GetSymbolForEdit(SemanticModel model, SyntaxNode node, EditKind editKind, Dictionary`2<SyntaxNode, EditKind> editMap, CancellationToken cancellationToken);
    protected abstract virtual ImmutableArray`1<ISymbol> GetCapturedVariables(SemanticModel model, SyntaxNode memberBody);
    protected abstract virtual IEnumerable`1<SyntaxNode> GetVariableUseSites(IEnumerable`1<SyntaxNode> roots, ISymbol localOrParameter, SemanticModel model, CancellationToken cancellationToken);
    protected abstract virtual Nullable`1<TextSpan> TryGetDiagnosticSpan(SyntaxNode node, EditKind editKind);
    internal TextSpan GetDiagnosticSpan(SyntaxNode node, EditKind editKind);
    protected virtual TextSpan GetBodyDiagnosticSpan(SyntaxNode node, EditKind editKind);
    internal abstract virtual TextSpan GetLambdaParameterDiagnosticSpan(SyntaxNode lambda, int ordinal);
    internal string GetDisplayName(SyntaxNode node, EditKind editKind);
    protected virtual string GetBodyDisplayName(SyntaxNode node, EditKind editKind);
    protected abstract virtual string TryGetDisplayName(SyntaxNode node, EditKind editKind);
    protected virtual string GetSuspensionPointDisplayName(SyntaxNode node, EditKind editKind);
    protected abstract virtual SymbolDisplayFormat get_ErrorDisplayFormat();
    protected abstract virtual List`1<SyntaxNode> GetExceptionHandlingAncestors(SyntaxNode node, bool isNonLeaf);
    protected abstract virtual void GetStateMachineInfo(SyntaxNode body, ImmutableArray`1& suspensionPoints, StateMachineKinds& kinds);
    protected abstract virtual TextSpan GetExceptionHandlingRegion(SyntaxNode node, Boolean& coversAllChildren);
    internal abstract virtual void ReportSyntacticRudeEdits(List`1<RudeEditDiagnostic> diagnostics, Match`1<SyntaxNode> match, Edit`1<SyntaxNode> edit, Dictionary`2<SyntaxNode, EditKind> editMap);
    internal abstract virtual void ReportEnclosingExceptionHandlingRudeEdits(List`1<RudeEditDiagnostic> diagnostics, IEnumerable`1<Edit`1<SyntaxNode>> exceptionHandlingEdits, SyntaxNode oldStatement, TextSpan newStatementSpan);
    internal abstract virtual void ReportOtherRudeEditsAroundActiveStatement(List`1<RudeEditDiagnostic> diagnostics, Match`1<SyntaxNode> match, SyntaxNode oldStatement, SyntaxNode newStatement, bool isNonLeaf);
    internal abstract virtual void ReportMemberUpdateRudeEdits(List`1<RudeEditDiagnostic> diagnostics, SyntaxNode newMember, Nullable`1<TextSpan> span);
    internal abstract virtual void ReportInsertedMemberSymbolRudeEdits(List`1<RudeEditDiagnostic> diagnostics, ISymbol newSymbol);
    internal abstract virtual void ReportStateMachineSuspensionPointRudeEdits(List`1<RudeEditDiagnostic> diagnostics, SyntaxNode oldNode, SyntaxNode newNode);
    internal abstract virtual bool IsLambda(SyntaxNode node);
    internal abstract virtual bool IsInterfaceDeclaration(SyntaxNode node);
    internal abstract virtual bool IsNestedFunction(SyntaxNode node);
    internal abstract virtual bool IsLocalFunction(SyntaxNode node);
    internal abstract virtual bool IsClosureScope(SyntaxNode node);
    internal abstract virtual bool ContainsLambda(SyntaxNode declaration);
    internal abstract virtual SyntaxNode GetLambda(SyntaxNode lambdaBody);
    internal abstract virtual IMethodSymbol GetLambdaExpressionSymbol(SemanticModel model, SyntaxNode lambdaExpression, CancellationToken cancellationToken);
    internal abstract virtual SyntaxNode GetContainingQueryExpression(SyntaxNode node);
    internal abstract virtual bool QueryClauseLambdasTypeEquivalent(SemanticModel oldModel, SyntaxNode oldNode, SemanticModel newModel, SyntaxNode newNode, CancellationToken cancellationToken);
    internal abstract virtual bool HasParameterClosureScope(ISymbol member);
    [NullableContextAttribute("2")]
internal abstract virtual bool TryGetLambdaBodies(SyntaxNode node, SyntaxNode& body1, SyntaxNode& body2);
    internal abstract virtual bool IsStateMachineMethod(SyntaxNode declaration);
    internal abstract virtual SyntaxNode TryGetContainingTypeDeclaration(SyntaxNode node);
    internal abstract virtual bool HasBackingField(SyntaxNode propertyDeclaration);
    internal abstract virtual bool IsDeclarationWithInitializer(SyntaxNode declaration);
    internal abstract virtual bool IsConstructorWithMemberInitializers(SyntaxNode declaration);
    internal abstract virtual bool IsPartial(INamedTypeSymbol type);
    internal abstract virtual SyntaxNode get_EmptyCompilationUnit();
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.EditAndContinue.AbstractEditAndContinueAnalyzer/<AnalyzeDocumentAsync>d__72")]
public sealed virtual Task`1<DocumentAnalysisResults> AnalyzeDocumentAsync(Document oldDocument, ImmutableArray`1<ActiveStatement> baseActiveStatements, Document document, ImmutableArray`1<TextSpan> newActiveStatementSpans, CancellationToken cancellationToken);
    internal static Dictionary`2<SyntaxNode, EditKind> BuildEditMap(EditScript`1<SyntaxNode> editScript);
    private void AnalyzeSyntax(EditScript`1<SyntaxNode> script, Dictionary`2<SyntaxNode, EditKind> editMap, SourceText oldText, SourceText newText, ImmutableArray`1<ActiveStatement> oldActiveStatements, ImmutableArray`1<TextSpan> newActiveStatementSpans, ActiveStatement[] newActiveStatements, ImmutableArray`1[] newExceptionRegions, List`1<UpdatedMemberInfo> updatedMethods, List`1<RudeEditDiagnostic> diagnostics);
    private void UpdateUneditedSpans(List`1<RudeEditDiagnostic> diagnostics, Match`1<SyntaxNode> topMatch, SourceText oldText, SourceText newText, ImmutableArray`1<ActiveStatement> oldActiveStatements, ImmutableArray`1<TextSpan> newActiveStatementSpans, ActiveStatement[] newActiveStatements, ImmutableArray`1[] newExceptionRegions);
    private void AnalyzeUnchangedDocument(ImmutableArray`1<ActiveStatement> oldActiveStatements, SourceText newText, SyntaxNode newRoot, ActiveStatement[] newActiveStatements, ImmutableArray`1[] newExceptionRegions);
    private void AnalyzeUpdatedActiveMethodBodies(EditScript`1<SyntaxNode> topEditScript, int editOrdinal, Dictionary`2<SyntaxNode, EditKind> editMap, SourceText oldText, SourceText newText, ImmutableArray`1<ActiveStatement> oldActiveStatements, ImmutableArray`1<TextSpan> newActiveStatementSpans, ActiveStatement[] newActiveStatements, ImmutableArray`1[] newExceptionRegions, List`1<UpdatedMemberInfo> updatedMembers, List`1<RudeEditDiagnostic> diagnostics);
    private void CalculateExceptionRegionsAroundActiveStatement(Match`1<SyntaxNode> bodyMatch, SyntaxNode oldStatementSyntax, SyntaxNode newStatementSyntax, TextSpan newStatementSyntaxSpan, int ordinal, SourceText newText, bool isNonLeaf, ImmutableArray`1[] newExceptionRegions, List`1<RudeEditDiagnostic> diagnostics);
    private BidirectionalMap`1<SyntaxNode> ComputeMap(Match`1<SyntaxNode> bodyMatch, ActiveNode[] activeNodes, Dictionary`2& lazyActiveOrMatchedLambdas, List`1<RudeEditDiagnostic> diagnostics);
    private Match`1<SyntaxNode> ComputeLambdaBodyMatch(SyntaxNode oldLambdaBody, SyntaxNode newLambdaBody, ActiveNode[] activeNodes, Dictionary`2<SyntaxNode, LambdaInfo> activeOrMatchedLambdas, List`1<RudeEditDiagnostic> diagnostics);
    private Match`1<SyntaxNode> ComputeBodyMatch(SyntaxNode oldBody, SyntaxNode newBody, ActiveNode[] activeNodes, List`1<RudeEditDiagnostic> diagnostics, Boolean& oldHasStateMachineSuspensionPoint, Boolean& newHasStateMachineSuspensionPoint);
    internal virtual void ReportStateMachineSuspensionPointDeletedRudeEdit(List`1<RudeEditDiagnostic> diagnostics, Match`1<SyntaxNode> match, SyntaxNode deletedSuspensionPoint);
    internal virtual void ReportStateMachineSuspensionPointInsertedRudeEdit(List`1<RudeEditDiagnostic> diagnostics, Match`1<SyntaxNode> match, SyntaxNode insertedSuspensionPoint, bool aroundActiveStatement);
    private static void AddMatchingActiveNodes(List`1& lazyKnownMatches, IEnumerable`1<ActiveNode> activeNodes);
    [NullableContextAttribute("2")]
private void AddMatchingStateMachineSuspensionPoints(List`1& lazyKnownMatches, List`1& lazyRudeEdits, ImmutableArray`1<SyntaxNode> oldStateMachineSuspensionPoints, ImmutableArray`1<SyntaxNode> newStateMachineSuspensionPoints);
    public sealed virtual ImmutableArray`1<LinePositionSpan> GetExceptionRegions(SourceText text, SyntaxNode syntaxRoot, LinePositionSpan activeStatementSpan, bool isNonLeaf, Boolean& isCovered);
    private ImmutableArray`1<LinePositionSpan> GetExceptionRegions(List`1<SyntaxNode> exceptionHandlingAncestors, SourceText text);
    private ImmutableArray`1<LinePositionSpan> GetExceptionRegions(List`1<SyntaxNode> exceptionHandlingAncestors, SourceText text, Boolean& isCovered);
    private TextSpan GetDeletedNodeDiagnosticSpan(SyntaxNode deletedLambdaBody, Match`1<SyntaxNode> match, Dictionary`2<SyntaxNode, LambdaInfo> lambdaInfos);
    private TextSpan FindClosestActiveSpan(SyntaxNode statement, int statementPart);
    internal TextSpan GetDeletedNodeActiveSpan(IReadOnlyDictionary`2<SyntaxNode, SyntaxNode> forwardMap, SyntaxNode deletedNode);
    internal TextSpan GetDeletedNodeDiagnosticSpan(IReadOnlyDictionary`2<SyntaxNode, SyntaxNode> forwardMap, SyntaxNode deletedNode);
    [NullableContextAttribute("2")]
private static bool TryGetMatchingAncestor(IReadOnlyDictionary`2<SyntaxNode, SyntaxNode> forwardMap, SyntaxNode oldNode, SyntaxNode& newAncestor);
    protected virtual bool TryGetOverlappingActiveStatements(SourceText baseText, TextSpan declarationSpan, ImmutableArray`1<ActiveStatement> statements, Int32& start, Int32& end);
    protected static bool HasParentEdit(Dictionary`2<SyntaxNode, EditKind> editMap, Edit`1<SyntaxNode> edit);
    protected static bool HasEdit(Dictionary`2<SyntaxNode, EditKind> editMap, SyntaxNode node, EditKind editKind);
    [NullableContextAttribute("2")]
protected void AddAroundActiveStatementRudeDiagnostic(List`1<RudeEditDiagnostic> diagnostics, SyntaxNode oldNode, SyntaxNode newNode, TextSpan newActiveStatementSpan);
    protected void AddRudeUpdateAroundActiveStatement(List`1<RudeEditDiagnostic> diagnostics, SyntaxNode newNode);
    protected void AddRudeInsertAroundActiveStatement(List`1<RudeEditDiagnostic> diagnostics, SyntaxNode newNode);
    protected void AddRudeDeleteAroundActiveStatement(List`1<RudeEditDiagnostic> diagnostics, SyntaxNode oldNode, TextSpan newActiveStatementSpan);
    protected void ReportUnmatchedStatements(List`1<RudeEditDiagnostic> diagnostics, Match`1<SyntaxNode> match, Func`2<SyntaxNode, bool> nodeSelector, SyntaxNode oldActiveStatement, SyntaxNode newActiveStatement, Func`3<TSyntaxNode, TSyntaxNode, bool> areEquivalent, Func`3<TSyntaxNode, TSyntaxNode, bool> areSimilar);
    private void ReportRudeEditsAndInserts(List`1<SyntaxNode> oldNodes, List`1<SyntaxNode> newNodes, List`1<RudeEditDiagnostic> diagnostics);
    private int MatchNodes(List`1<SyntaxNode> oldNodes, List`1<SyntaxNode> newNodes, List`1<RudeEditDiagnostic> diagnostics, Match`1<SyntaxNode> match, Func`3<TSyntaxNode, TSyntaxNode, bool> comparer);
    private static int IndexOfEquivalent(SyntaxNode newNode, List`1<SyntaxNode> oldNodes, int startIndex, Func`3<TSyntaxNode, TSyntaxNode, bool> comparer);
    private static List`1<SyntaxNode> GetAncestors(SyntaxNode root, SyntaxNode node, Func`2<SyntaxNode, bool> nodeSelector);
    private void AnalyzeTrivia(SourceText oldSource, SourceText newSource, Match`1<SyntaxNode> topMatch, Dictionary`2<SyntaxNode, EditKind> editMap, List`1<ValueTuple`2<SyntaxNode, SyntaxNode>> triviaEdits, List`1<LineChange> lineEdits, List`1<RudeEditDiagnostic> diagnostics, CancellationToken cancellationToken);
    private static int CompareLineChanges(LineChange x, LineChange y);
    protected static bool SignaturesEquivalent(ImmutableArray`1<IParameterSymbol> oldParameters, ITypeSymbol oldReturnType, ImmutableArray`1<IParameterSymbol> newParameters, ITypeSymbol newReturnType);
    [NullableContextAttribute("2")]
protected static bool MemberSignaturesEquivalent(ISymbol oldMember, ISymbol newMember, Func`5<ImmutableArray`1<IParameterSymbol>, ITypeSymbol, ImmutableArray`1<IParameterSymbol>, ITypeSymbol, bool> signatureComparer);
    private void AnalyzeSemantics(EditScript`1<SyntaxNode> editScript, Dictionary`2<SyntaxNode, EditKind> editMap, SourceText oldText, ImmutableArray`1<ActiveStatement> oldActiveStatements, List`1<ValueTuple`2<SyntaxNode, SyntaxNode>> triviaEdits, List`1<UpdatedMemberInfo> updatedMembers, SemanticModel oldModel, SemanticModel newModel, List`1<SemanticEdit> semanticEdits, List`1<RudeEditDiagnostic> diagnostics, Diagnostic& firstDeclarationError, CancellationToken cancellationToken);
    private static Diagnostic GetFirstDeclarationError(SemanticModel primaryModel, ISymbol symbol, CancellationToken cancellationToken);
    internal void ReportTypeLayoutUpdateRudeEdits(List`1<RudeEditDiagnostic> diagnostics, ISymbol newSymbol, SyntaxNode newSyntax, SemanticModel newModel, INamedTypeSymbol& lazyLayoutAttribute);
    private void ReportTypeLayoutUpdateRudeEdits(List`1<RudeEditDiagnostic> diagnostics, ISymbol symbol, SyntaxNode syntax);
    private static bool HasBackingField(IEventSymbol event);
    private static bool HasExplicitOrSequentialLayout(INamedTypeSymbol type, SemanticModel model, INamedTypeSymbol& lazyLayoutAttribute);
    private static INamedTypeSymbol TryGetPartnerType(SyntaxNode typeSyntax, Match`1<SyntaxNode> topMatch, SemanticModel partnerModel, CancellationToken cancellationToken);
    private Func`2<SyntaxNode, SyntaxNode> CreateSyntaxMapForEquivalentNodes(SyntaxNode oldRoot, SyntaxNode newRoot);
    private static Func`2<SyntaxNode, SyntaxNode> CreateSyntaxMap(IReadOnlyDictionary`2<SyntaxNode, SyntaxNode> reverseMap);
    private Func`2<SyntaxNode, SyntaxNode> CreateSyntaxMapForPartialTypeConstructor(INamedTypeSymbol oldType, INamedTypeSymbol newType, SemanticModel newModel, Func`2<SyntaxNode, SyntaxNode> ctorSyntaxMap);
    private Func`2<SyntaxNode, SyntaxNode> CreateAggregateSyntaxMap(IReadOnlyDictionary`2<SyntaxNode, SyntaxNode> reverseTopMatches, IReadOnlyDictionary`2<SyntaxNode, Func`2<SyntaxNode, SyntaxNode>> changedDeclarations);
    private static IMethodSymbol AsParameterlessConstructor(ISymbol symbol);
    private bool DeferConstructorEdit(INamedTypeSymbol oldType, INamedTypeSymbol newType, SemanticEditKind editKind, SyntaxNode newDeclaration, ISymbol newSymbol, SemanticModel newModel, bool isConstructor, Func`2& syntaxMap, Dictionary`2& instanceConstructorEdits, Dictionary`2& staticConstructorEdits, List`1<RudeEditDiagnostic> diagnostics, CancellationToken cancellationToken);
    private void AddConstructorEdits(Dictionary`2<INamedTypeSymbol, ConstructorEdit> updatedTypes, Match`1<SyntaxNode> topMatch, SemanticModel oldModel, HashSet`1<ISymbol> newSymbolsWithEdit, bool isStatic, List`1<SemanticEdit> semanticEdits, List`1<RudeEditDiagnostic> diagnostics, CancellationToken cancellationToken);
    private bool HasMemberInitializerContainingLambda(INamedTypeSymbol type, bool isStatic, Nullable`1& lazyHasMemberInitializerContainingLambda, CancellationToken cancellationToken);
    private bool HasMemberInitializerContainingLambda(INamedTypeSymbol type, bool isStatic, CancellationToken cancellationToken);
    private static ISymbol TryGetParameterlessConstructor(INamedTypeSymbol type, bool isStatic);
    private void ReportLambdaAndClosureRudeEdits(SemanticModel oldModel, SyntaxNode oldMemberBody, SemanticModel newModel, SyntaxNode newMemberBody, ISymbol newMember, IReadOnlyDictionary`2<SyntaxNode, LambdaInfo> matchedLambdas, BidirectionalMap`1<SyntaxNode> map, List`1<RudeEditDiagnostic> diagnostics, Boolean& newBodyHasLambdas, CancellationToken cancellationToken);
    private void ReportMultiScopeCaptures(SyntaxNode lambdaBody, SemanticModel model, ImmutableArray`1<ISymbol> captures, ImmutableArray`1<ISymbol> newCaptures, ArrayBuilder`1<SyntaxNode> newCapturesToClosureScopes, PooledDictionary`2<ISymbol, int> capturesIndex, ArrayBuilder`1<int> reverseCapturesMap, List`1<RudeEditDiagnostic> diagnostics, bool isInsert, CancellationToken cancellationToken);
    private BitVector GetAccessedCaptures(SyntaxNode lambdaBody, SemanticModel model, ImmutableArray`1<ISymbol> captures, PooledDictionary`2<ISymbol, int> capturesIndex);
    private static void MarkVariables(BitVector& mask, ImmutableArray`1<ISymbol> variables, Dictionary`2<ISymbol, int> index);
    private static void BuildIndex(Dictionary`2<TKey, int> index, ImmutableArray`1<TKey> array);
    protected static SyntaxNode GetSymbolSyntax(ISymbol local, CancellationToken cancellationToken);
    private static TextSpan GetThisParameterDiagnosticSpan(ISymbol member);
    private static TextSpan GetVariableDiagnosticSpan(ISymbol local);
    private static ValueTuple`2<SyntaxNode, int> GetParameterKey(IParameterSymbol parameter, CancellationToken cancellationToken);
    private static bool TryMapParameter(ValueTuple`2<SyntaxNode, int> parameterKey, IReadOnlyDictionary`2<SyntaxNode, SyntaxNode> map, ValueTuple`2& mappedParameterKey);
    private void CalculateCapturedVariablesMaps(ImmutableArray`1<ISymbol> oldCaptures, SyntaxNode oldMemberBody, ImmutableArray`1<ISymbol> newCaptures, ISymbol newMember, SyntaxNode newMemberBody, BidirectionalMap`1<SyntaxNode> map, ArrayBuilder`1<int> reverseCapturesMap, ArrayBuilder`1<SyntaxNode> newCapturesToClosureScopes, ArrayBuilder`1<SyntaxNode> oldCapturesToClosureScopes, List`1<RudeEditDiagnostic> diagnostics, Boolean& hasErrors, CancellationToken cancellationToken);
    protected virtual void ReportLambdaSignatureRudeEdits(SemanticModel oldModel, SyntaxNode oldLambdaBody, SemanticModel newModel, SyntaxNode newLambdaBody, List`1<RudeEditDiagnostic> diagnostics, Boolean& hasErrors, CancellationToken cancellationToken);
    private static ITypeSymbol GetType(ISymbol localOrParameter);
    private SyntaxNode GetCapturedVariableScope(ISymbol localOrParameter, SyntaxNode memberBody, CancellationToken cancellationToken);
    private static bool AreEquivalentClosureScopes(SyntaxNode oldScopeOpt, SyntaxNode newScopeOpt, IReadOnlyDictionary`2<SyntaxNode, SyntaxNode> reverseMap);
    private void ReportStateMachineRudeEdits(Compilation oldCompilation, UpdatedMemberInfo updatedInfo, ISymbol oldMember, List`1<RudeEditDiagnostic> diagnostics);
    private static SyntaxNode TryGetNode(SyntaxNode root, int position);
    private static bool TryGetTextSpan(TextLineCollection lines, LinePositionSpan lineSpan, TextSpan& span);
    internal TestAccessor GetTestAccessor();
    [CompilerGeneratedAttribute]
private void <AddMatchingStateMachineSuspensionPoints>g__AddMatch|88_0(List`1& lazyKnownMatches, int oldIndex, int newIndex, <>c__DisplayClass88_0& );
    [NullableContextAttribute("0")]
[CompilerGeneratedAttribute]
private SyntaxNode <ReportLambdaAndClosureRudeEdits>b__133_1(SyntaxNode clause);
}
[IsReadOnlyAttribute]
[DebuggerDisplayAttribute("{GetDebuggerDisplay(),nq}")]
internal class Microsoft.CodeAnalysis.EditAndContinue.ActiveInstructionId : ValueType {
    public ActiveMethodId MethodId;
    public int ILOffset;
    public ActiveInstructionId(Guid moduleId, int methodToken, int methodVersion, int ilOffset);
    public virtual bool Equals(object obj);
    public sealed virtual bool Equals(ActiveInstructionId other);
    public virtual int GetHashCode();
    public static bool op_Equality(ActiveInstructionId left, ActiveInstructionId right);
    public static bool op_Inequality(ActiveInstructionId left, ActiveInstructionId right);
    internal string GetDebuggerDisplay();
}
[IsReadOnlyAttribute]
[DebuggerDisplayAttribute("{GetDebuggerDisplay(),nq}")]
internal class Microsoft.CodeAnalysis.EditAndContinue.ActiveMethodId : ValueType {
    public Guid ModuleId;
    public int Token;
    public int Version;
    public ActiveMethodId(Guid moduleId, int token, int version);
    public virtual bool Equals(object obj);
    public sealed virtual bool Equals(ActiveMethodId other);
    public virtual int GetHashCode();
    public static bool op_Equality(ActiveMethodId left, ActiveMethodId right);
    public static bool op_Inequality(ActiveMethodId left, ActiveMethodId right);
    internal string GetDebuggerDisplay();
}
internal class Microsoft.CodeAnalysis.EditAndContinue.ActiveStatement : object {
    public int Ordinal;
    public int PrimaryDocumentOrdinal;
    public ActiveInstructionId InstructionId;
    public LinePositionSpan Span;
    public ImmutableArray`1<DocumentId> DocumentIds;
    public ImmutableArray`1<Guid> ThreadIds;
    public ActiveStatementFlags Flags;
    public bool IsLeaf { get; }
    public bool IsNonLeaf { get; }
    public bool IsMethodUpToDate { get; }
    public DocumentId PrimaryDocumentId { get; }
    public ActiveStatement(int ordinal, int primaryDocumentOrdinal, ImmutableArray`1<DocumentId> documentIds, ActiveStatementFlags flags, LinePositionSpan span, ActiveInstructionId instructionId, ImmutableArray`1<Guid> threadIds);
    public bool get_IsLeaf();
    public bool get_IsNonLeaf();
    public bool get_IsMethodUpToDate();
    public DocumentId get_PrimaryDocumentId();
    internal ActiveStatement WithSpan(LinePositionSpan span);
    internal ActiveStatement WithFlags(ActiveStatementFlags flags);
}
[IsReadOnlyAttribute]
internal class Microsoft.CodeAnalysis.EditAndContinue.ActiveStatementDebugInfo : ValueType {
    public ActiveInstructionId InstructionId;
    public string DocumentNameOpt;
    public LinePositionSpan LinePositionSpan;
    public ActiveStatementFlags Flags;
    public ImmutableArray`1<Guid> ThreadIds;
    public bool HasSourceLocation { get; }
    public ActiveStatementDebugInfo(ActiveInstructionId instructionId, string documentNameOpt, LinePositionSpan linePositionSpan, ImmutableArray`1<Guid> threadIds, ActiveStatementFlags flags);
    public bool get_HasSourceLocation();
}
[IsReadOnlyAttribute]
internal class Microsoft.CodeAnalysis.EditAndContinue.ActiveStatementExceptionRegions : ValueType {
    public ImmutableArray`1<LinePositionSpan> Spans;
    public bool IsActiveStatementCovered;
    public ActiveStatementExceptionRegions(ImmutableArray`1<LinePositionSpan> spans, bool isActiveStatementCovered);
}
[FlagsAttribute]
internal enum Microsoft.CodeAnalysis.EditAndContinue.ActiveStatementFlags : Enum {
    public int value__;
    public static ActiveStatementFlags None;
    public static ActiveStatementFlags IsLeafFrame;
    public static ActiveStatementFlags PartiallyExecuted;
    public static ActiveStatementFlags NonUserCode;
    public static ActiveStatementFlags MethodUpToDate;
    public static ActiveStatementFlags IsNonLeafFrame;
}
[IsReadOnlyAttribute]
internal class Microsoft.CodeAnalysis.EditAndContinue.ActiveStatementId : ValueType {
    public DocumentId DocumentId;
    public int Ordinal;
    public ActiveStatementId(DocumentId documentId, int ordinal);
}
internal class Microsoft.CodeAnalysis.EditAndContinue.ActiveStatementProvider : MulticastDelegate {
    public ActiveStatementProvider(object object, IntPtr method);
    public virtual Task`1<ImmutableArray`1<ActiveStatementDebugInfo>> Invoke(CancellationToken cancellationToken);
    public virtual IAsyncResult BeginInvoke(CancellationToken cancellationToken, AsyncCallback callback, object object);
    public virtual Task`1<ImmutableArray`1<ActiveStatementDebugInfo>> EndInvoke(IAsyncResult result);
}
[IsReadOnlyAttribute]
internal class Microsoft.CodeAnalysis.EditAndContinue.ActiveStatementsMap : ValueType {
    public IReadOnlyDictionary`2<DocumentId, ImmutableArray`1<ActiveStatement>> DocumentMap;
    public IReadOnlyDictionary`2<ActiveInstructionId, ActiveStatement> InstructionMap;
    public ActiveStatementsMap(IReadOnlyDictionary`2<DocumentId, ImmutableArray`1<ActiveStatement>> documentMap, IReadOnlyDictionary`2<ActiveInstructionId, ActiveStatement> instructionMap);
}
[IsReadOnlyAttribute]
internal class Microsoft.CodeAnalysis.EditAndContinue.ActiveStatementTextSpan : ValueType {
    public ActiveStatementFlags Flags;
    public TextSpan Span;
    public bool IsLeaf { get; }
    public bool IsNonLeaf { get; }
    public ActiveStatementTextSpan(ActiveStatementFlags flags, TextSpan span);
    public bool get_IsLeaf();
    public bool get_IsNonLeaf();
}
[IsReadOnlyAttribute]
internal class Microsoft.CodeAnalysis.EditAndContinue.BidirectionalMap`1 : ValueType {
    public IReadOnlyDictionary`2<T, T> Forward;
    public IReadOnlyDictionary`2<T, T> Reverse;
    public bool IsDefaultOrEmpty { get; }
    public BidirectionalMap`1(IReadOnlyDictionary`2<T, T> forward, IReadOnlyDictionary`2<T, T> reverse);
    public BidirectionalMap`1(IEnumerable`1<KeyValuePair`2<T, T>> entries);
    public static BidirectionalMap`1<T> FromMatch(Match`1<T> match);
    public bool get_IsDefaultOrEmpty();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.CodeAnalysis.EditAndContinue.CommittedSolution : object {
    private DebuggingSession _debuggingSession;
    private Solution _solution;
    private Dictionary`2<DocumentId, DocumentState> _documentState;
    private object _guard;
    public CommittedSolution(DebuggingSession debuggingSession, Solution solution);
    internal void Test_SetDocumentState(DocumentId documentId, DocumentState state);
    public bool HasNoChanges(Solution solution);
    public Project GetProject(ProjectId id);
    public ImmutableArray`1<DocumentId> GetDocumentIdsWithFilePath(string path);
    public bool ContainsDocument(DocumentId documentId);
    public Task OnSourceFileUpdatedAsync(Document document, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.EditAndContinue.CommittedSolution/<GetDocumentAndStateAsync>d__12")]
public Task`1<ValueTuple`2<Document, DocumentState>> GetDocumentAndStateAsync(DocumentId documentId, Document currentDocument, CancellationToken cancellationToken, bool reloadOutOfSyncDocument);
    public void CommitSolution(Solution solution);
    private ValueTuple`2<SourceText, Nullable`1<bool>> TryGetPdbMatchingSourceText(string sourceFilePath, Encoding encoding, Project project);
    private Nullable`1<bool> TryReadSourceFileChecksumFromPdb(string sourceFilePath, Project project, ImmutableArray`1& checksum, SourceHashAlgorithm& algorithm);
}
internal class Microsoft.CodeAnalysis.EditAndContinue.DebuggeeModuleInfo : object {
    [CompilerGeneratedAttribute]
private ModuleMetadata <Metadata>k__BackingField;
    private ISymUnmanagedReader5 _symReader;
    public ModuleMetadata Metadata { get; }
    public ISymUnmanagedReader5 SymReader { get; }
    public DebuggeeModuleInfo(ModuleMetadata metadata, ISymUnmanagedReader5 symReader);
    [CompilerGeneratedAttribute]
public ModuleMetadata get_Metadata();
    public ISymUnmanagedReader5 get_SymReader();
    public sealed virtual void Dispose();
}
internal class Microsoft.CodeAnalysis.EditAndContinue.DebuggeeModuleInfoCache : object {
    private Dictionary`2<Guid, DebuggeeModuleInfo> _lazyCache;
    public DebuggeeModuleInfo GetOrAdd(Guid mvid, Func`2<Guid, DebuggeeModuleInfo> provider);
    public bool Remove(Guid mvid);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.CodeAnalysis.EditAndContinue.DebuggingSession : object {
    private Func`2<Project, CompilationOutputs> _compilationOutputsProvider;
    private CancellationTokenSource _cancellationSource;
    [TupleElementNamesAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private Dictionary`2<ProjectId, ValueTuple`2<Guid, Diagnostic>> _projectModuleIds;
    private object _projectModuleIdsGuard;
    private Dictionary`2<ProjectId, EmitBaseline> _projectEmitBaselines;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private List`1<IDisposable> _lazyBaselineModuleReaders;
    private object _projectEmitBaselinesGuard;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private ImmutableDictionary`2<ActiveMethodId, ImmutableArray`1<NonRemappableRegion>> <NonRemappableRegions>k__BackingField;
    private HashSet`1<Guid> _modulesPreparedForUpdate;
    private object _modulesPreparedForUpdateGuard;
    internal CommittedSolution LastCommittedSolution;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal ImmutableDictionary`2<ActiveMethodId, ImmutableArray`1<NonRemappableRegion>> NonRemappableRegions { get; private set; }
    internal CancellationToken CancellationToken { get; }
    internal DebuggingSession(Solution solution, Func`2<Project, CompilationOutputs> compilationOutputsProvider);
    [CompilerGeneratedAttribute]
internal ImmutableDictionary`2<ActiveMethodId, ImmutableArray`1<NonRemappableRegion>> get_NonRemappableRegions();
    [CompilerGeneratedAttribute]
private void set_NonRemappableRegions(ImmutableDictionary`2<ActiveMethodId, ImmutableArray`1<NonRemappableRegion>> value);
    internal void Test_SetNonRemappableRegions(ImmutableDictionary`2<ActiveMethodId, ImmutableArray`1<NonRemappableRegion>> nonRemappableRegions);
    internal ImmutableHashSet`1<Guid> Test_GetModulesPreparedForUpdate();
    internal EmitBaseline Test_GetProjectEmitBaseline(ProjectId id);
    internal ImmutableArray`1<IDisposable> GetBaselineModuleReaders();
    internal CancellationToken get_CancellationToken();
    internal void Cancel();
    public sealed virtual void Dispose();
    internal CompilationOutputs GetCompilationOutputs(Project project);
    internal bool AddModulePreparedForUpdate(Guid mvid);
    public void CommitSolutionUpdate(PendingSolutionUpdate update);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.EditAndContinue.DebuggingSession/<GetProjectModuleIdAsync>d__26")]
public Task`1<ValueTuple`2<Guid, Diagnostic>> GetProjectModuleIdAsync(Project project, CancellationToken cancellationToken);
    public EmitBaseline GetOrCreateEmitBaseline(ProjectId projectId, Guid mvid, IDebuggeeModuleMetadataProvider debugeeModuleMetadataProvider);
    private static ImmutableDictionary`2<K, ImmutableArray`1<V>> GroupToImmutableDictionary(IEnumerable`1<IGrouping`2<K, V>> items);
}
internal class Microsoft.CodeAnalysis.EditAndContinue.DebuggingSessionTelemetry : object {
    private object _guard;
    private List`1<Data> _editSessionData;
    private int _emptyEditSessionCount;
    public Data GetDataAndClear();
    public void LogEditSession(Data editSessionTelemetryData);
}
internal class Microsoft.CodeAnalysis.EditAndContinue.Deltas : object {
    public Guid Mvid;
    public ILDelta IL;
    public MetadataDelta Metadata;
    [TupleElementNamesAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ImmutableArray`1<ValueTuple`2<string, ImmutableArray`1<LineChange>>> LineEdits;
    public PdbDelta Pdb;
    [TupleElementNamesAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ImmutableArray`1<ValueTuple`2<ActiveMethodId, NonRemappableRegion>> NonRemappableRegions;
    [TupleElementNamesAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ImmutableArray`1<ValueTuple`3<Guid, ActiveInstructionId, LinePositionSpan>> ActiveStatementsInUpdatedMethods;
    public Deltas(Guid mvid, ImmutableArray`1<byte> il, ImmutableArray`1<byte> metadata, ImmutableArray`1<byte> pdb, ImmutableArray`1<int> updatedMethods, ImmutableArray`1<ValueTuple`2<string, ImmutableArray`1<LineChange>>> lineEdits, ImmutableArray`1<ValueTuple`2<ActiveMethodId, NonRemappableRegion>> nonRemappableRegions, ImmutableArray`1<ValueTuple`3<Guid, ActiveInstructionId, LinePositionSpan>> activeStatementsInUpdatedMethods);
}
internal class Microsoft.CodeAnalysis.EditAndContinue.DocumentActiveStatementSpanProvider : MulticastDelegate {
    public DocumentActiveStatementSpanProvider(object object, IntPtr method);
    public virtual Task`1<ImmutableArray`1<TextSpan>> Invoke(CancellationToken cancellationToken);
    public virtual IAsyncResult BeginInvoke(CancellationToken cancellationToken, AsyncCallback callback, object object);
    public virtual Task`1<ImmutableArray`1<TextSpan>> EndInvoke(IAsyncResult result);
}
internal class Microsoft.CodeAnalysis.EditAndContinue.DocumentAnalysisResults : object {
    [CompilerGeneratedAttribute]
private ImmutableArray`1<ActiveStatement> <ActiveStatements>k__BackingField;
    [CompilerGeneratedAttribute]
private ImmutableArray`1<RudeEditDiagnostic> <RudeEditErrors>k__BackingField;
    [CompilerGeneratedAttribute]
private ImmutableArray`1<SemanticEdit> <SemanticEdits>k__BackingField;
    [CompilerGeneratedAttribute]
private ImmutableArray`1<ImmutableArray`1<LinePositionSpan>> <ExceptionRegions>k__BackingField;
    [CompilerGeneratedAttribute]
private ImmutableArray`1<LineChange> <LineEdits>k__BackingField;
    private Nullable`1<bool> _hasCompilationErrors;
    internal static TraceLog Log;
    public ImmutableArray`1<ActiveStatement> ActiveStatements { get; }
    public ImmutableArray`1<RudeEditDiagnostic> RudeEditErrors { get; }
    public ImmutableArray`1<SemanticEdit> SemanticEdits { get; }
    public ImmutableArray`1<ImmutableArray`1<LinePositionSpan>> ExceptionRegions { get; }
    public ImmutableArray`1<LineChange> LineEdits { get; }
    public bool HasChanges { get; }
    public bool HasChangesAndErrors { get; }
    public bool HasChangesAndCompilationErrors { get; }
    public bool HasSignificantValidChanges { get; }
    private DocumentAnalysisResults(ImmutableArray`1<RudeEditDiagnostic> rudeEdits);
    public DocumentAnalysisResults(ImmutableArray`1<ActiveStatement> activeStatements, ImmutableArray`1<RudeEditDiagnostic> rudeEdits, ImmutableArray`1<SemanticEdit> semanticEditsOpt, ImmutableArray`1<ImmutableArray`1<LinePositionSpan>> exceptionRegionsOpt, ImmutableArray`1<LineChange> lineEditsOpt, Nullable`1<bool> hasSemanticErrors);
    private static DocumentAnalysisResults();
    [CompilerGeneratedAttribute]
public ImmutableArray`1<ActiveStatement> get_ActiveStatements();
    [CompilerGeneratedAttribute]
public ImmutableArray`1<RudeEditDiagnostic> get_RudeEditErrors();
    [CompilerGeneratedAttribute]
public ImmutableArray`1<SemanticEdit> get_SemanticEdits();
    [CompilerGeneratedAttribute]
public ImmutableArray`1<ImmutableArray`1<LinePositionSpan>> get_ExceptionRegions();
    [CompilerGeneratedAttribute]
public ImmutableArray`1<LineChange> get_LineEdits();
    public bool get_HasChanges();
    public bool get_HasChangesAndErrors();
    public bool get_HasChangesAndCompilationErrors();
    public bool get_HasSignificantValidChanges();
    public static DocumentAnalysisResults SyntaxErrors(ImmutableArray`1<RudeEditDiagnostic> rudeEdits);
    public static DocumentAnalysisResults Unchanged(ImmutableArray`1<ActiveStatement> activeStatements, ImmutableArray`1<ImmutableArray`1<LinePositionSpan>> exceptionRegionsOpt);
    public static DocumentAnalysisResults Errors(ImmutableArray`1<ActiveStatement> activeStatements, ImmutableArray`1<RudeEditDiagnostic> rudeEdits, bool hasSemanticErrors);
}
internal static class Microsoft.CodeAnalysis.EditAndContinue.EditAndContinueDiagnosticDescriptors : object {
    private static int GeneralDiagnosticBaseId;
    private static int ModuleDiagnosticBaseId;
    private static int s_diagnosticBaseIndex;
    private static LocalizableResourceString s_rudeEditLocString;
    private static LocalizableResourceString s_encLocString;
    private static LocalizableResourceString s_encDisallowedByProjectLocString;
    private static ImmutableArray`1<DiagnosticDescriptor> s_descriptors;
    private static Dictionary`2<int, DiagnosticDescriptor> s_lazyModuleDiagnosticDescriptors;
    private static object s_moduleDiagnosticDescriptorsGuard;
    private static EditAndContinueDiagnosticDescriptors();
    internal static ImmutableArray`1<DiagnosticDescriptor> GetDescriptors();
    internal static DiagnosticDescriptor GetDescriptor(RudeEditKind kind);
    internal static DiagnosticDescriptor GetDescriptor(EditAndContinueErrorCode errorCode);
    internal static DiagnosticDescriptor GetModuleDiagnosticDescriptor(int errorCode);
    private static int GetDescriptorIndex(RudeEditKind kind);
    private static int GetDescriptorIndex(EditAndContinueErrorCode errorCode);
    [CompilerGeneratedAttribute]
internal static void <.cctor>g__add|9_0(int index, int id, string resourceName, LocalizableResourceString title, DiagnosticSeverity severity, <>c__DisplayClass9_0& );
    [CompilerGeneratedAttribute]
internal static void <.cctor>g__AddRudeEdit|9_1(RudeEditKind kind, string resourceName, <>c__DisplayClass9_0& );
    [CompilerGeneratedAttribute]
internal static void <.cctor>g__AddGeneralDiagnostic|9_2(EditAndContinueErrorCode code, string resourceName, DiagnosticSeverity severity, <>c__DisplayClass9_0& );
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExportAttribute("Microsoft.CodeAnalysis.EditAndContinue.EditAndContinueDiagnosticUpdateSource")]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.EditAndContinue.EditAndContinueDiagnosticUpdateSource : object {
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private EventHandler`1<DiagnosticsUpdatedArgs> DiagnosticsUpdated;
    [NullableAttribute("2")]
[CompilerGeneratedAttribute]
private EventHandler DiagnosticsCleared;
    public bool SupportGetDiagnostics { get; }
    [ImportingConstructorAttribute]
[ObsoleteAttribute("This exported object must be obtained through the MEF export provider.", "True")]
public EditAndContinueDiagnosticUpdateSource(IDiagnosticUpdateSourceRegistrationService registrationService);
    [CompilerGeneratedAttribute]
public sealed virtual void add_DiagnosticsUpdated(EventHandler`1<DiagnosticsUpdatedArgs> value);
    [CompilerGeneratedAttribute]
public sealed virtual void remove_DiagnosticsUpdated(EventHandler`1<DiagnosticsUpdatedArgs> value);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public sealed virtual void add_DiagnosticsCleared(EventHandler value);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public sealed virtual void remove_DiagnosticsCleared(EventHandler value);
    public sealed virtual bool get_SupportGetDiagnostics();
    public sealed virtual ValueTask`1<ImmutableArray`1<DiagnosticData>> GetDiagnosticsAsync(Workspace workspace, ProjectId projectId, DocumentId documentId, object id, bool includeSuppressedDiagnostics, CancellationToken cancellationToken);
    public void ClearDiagnostics();
    public void ReportDiagnostics(Workspace workspace, Solution solution, ProjectId projectId, IEnumerable`1<Diagnostic> diagnostics);
}
internal enum Microsoft.CodeAnalysis.EditAndContinue.EditAndContinueErrorCode : Enum {
    public int value__;
    public static EditAndContinueErrorCode ErrorReadingFile;
    public static EditAndContinueErrorCode CannotApplyChangesUnexpectedError;
    public static EditAndContinueErrorCode ChangesNotAppliedWhileRunning;
    public static EditAndContinueErrorCode ChangesDisallowedWhileStoppedAtException;
    public static EditAndContinueErrorCode DocumentIsOutOfSyncWithDebuggee;
    public static EditAndContinueErrorCode UnableToReadSourceFileOrPdb;
}
internal abstract class Microsoft.CodeAnalysis.EditAndContinue.EditAndContinueMethodDebugInfoReader : object {
    public bool IsPortable { get; }
    public abstract virtual bool get_IsPortable();
    public abstract virtual EditAndContinueMethodDebugInformation GetDebugInfo(MethodDefinitionHandle methodHandle);
    public abstract virtual StandaloneSignatureHandle GetLocalSignature(MethodDefinitionHandle methodHandle);
    public abstract virtual bool TryGetDocumentChecksum(string documentPath, ImmutableArray`1& checksum, Guid& algorithmId);
    public static EditAndContinueMethodDebugInfoReader Create(ISymUnmanagedReader5 symReader, int version);
    public static EditAndContinueMethodDebugInfoReader Create(MetadataReader pdbReader);
    internal static bool TryGetDocumentChecksum(ISymUnmanagedReader5 symReader, string documentPath, ImmutableArray`1& checksum, Guid& algorithmId);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.CodeAnalysis.EditAndContinue.EditAndContinueWorkspaceService : object {
    internal static TraceLog Log;
    private Workspace _workspace;
    private IDiagnosticAnalyzerService _diagnosticService;
    private IDebuggeeModuleMetadataProvider _debugeeModuleMetadataProvider;
    private EditAndContinueDiagnosticUpdateSource _emitDiagnosticsUpdateSource;
    private EditSessionTelemetry _editSessionTelemetry;
    private DebuggingSessionTelemetry _debuggingSessionTelemetry;
    private Func`2<Project, CompilationOutputs> _compilationOutputsProvider;
    private Action`1<Data> _reportTelemetry;
    private HashSet`1<DocumentId> _documentsWithReportedDiagnosticsDuringRunMode;
    private object _documentsWithReportedDiagnosticsDuringRunModeGuard;
    [NullableAttribute("2")]
private DebuggingSession _debuggingSession;
    [NullableAttribute("2")]
private EditSession _editSession;
    public bool IsDebuggingSessionInProgress { get; }
    internal EditAndContinueWorkspaceService(Workspace workspace, IDiagnosticAnalyzerService diagnosticService, EditAndContinueDiagnosticUpdateSource diagnosticUpdateSource, IDebuggeeModuleMetadataProvider debugeeModuleMetadataProvider, Func`2<Project, CompilationOutputs> testCompilationOutputsProvider, Action`1<Data> testReportTelemetry);
    private static EditAndContinueWorkspaceService();
    [NullableContextAttribute("2")]
internal DebuggingSession Test_GetDebuggingSession();
    [NullableContextAttribute("2")]
internal EditSession Test_GetEditSession();
    internal Workspace Test_GetWorkspace();
    public sealed virtual bool get_IsDebuggingSessionInProgress();
    private static CompilationOutputs GetCompilationOutputs(Project project);
    public sealed virtual void OnSourceFileUpdated(Document document);
    public sealed virtual void StartDebuggingSession(Solution solution);
    public sealed virtual void StartEditSession(ActiveStatementProvider activeStatementsProvider);
    public sealed virtual void EndEditSession();
    public sealed virtual void EndDebuggingSession();
    internal static bool SupportsEditAndContinue(Project project);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.EditAndContinue.EditAndContinueWorkspaceService/<GetDocumentDiagnosticsAsync>d__26")]
public sealed virtual Task`1<ImmutableArray`1<Diagnostic>> GetDocumentDiagnosticsAsync(Document document, DocumentActiveStatementSpanProvider activeStatementSpanProvider, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.EditAndContinue.EditAndContinueWorkspaceService/<GetChangedSpansAsync>d__27")]
private static Task`1<IEnumerable`1<TextSpan>> GetChangedSpansAsync(Document oldDocument, SyntaxTree newSyntaxTree, CancellationToken cancellationToken);
    private ImmutableArray`1<Diagnostic> GetRunModeDocumentDiagnostics(Document newDocument, SyntaxTree newSyntaxTree, IEnumerable`1<TextSpan> changedSpans);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.EditAndContinue.EditAndContinueWorkspaceService/<GetDocumentTextChangesAsync>d__29")]
internal static Task`1<IList`1<TextChange>> GetDocumentTextChangesAsync(SyntaxTree oldSyntaxTree, SyntaxTree newSyntaxTree, CancellationToken cancellationToken);
    [IteratorStateMachineAttribute("Microsoft.CodeAnalysis.EditAndContinue.EditAndContinueWorkspaceService/<GetSpansInNewDocument>d__30")]
internal static IEnumerable`1<TextSpan> GetSpansInNewDocument(IEnumerable`1<TextChange> changes);
    private void ClearReportedRunModeDiagnostics();
    public sealed virtual Task`1<bool> HasChangesAsync(Solution solution, SolutionActiveStatementSpanProvider solutionActiveStatementSpanProvider, string sourceFilePath, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.EditAndContinue.EditAndContinueWorkspaceService/<EmitSolutionUpdateAsync>d__33")]
public sealed virtual Task`1<ValueTuple`2<SolutionUpdateStatus, ImmutableArray`1<Deltas>>> EmitSolutionUpdateAsync(Solution solution, SolutionActiveStatementSpanProvider activeStatementSpanProvider, CancellationToken cancellationToken);
    public sealed virtual void CommitSolutionUpdate();
    public sealed virtual void DiscardSolutionUpdate();
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.EditAndContinue.EditAndContinueWorkspaceService/<GetBaseActiveStatementSpansAsync>d__36")]
public sealed virtual Task`1<ImmutableArray`1<ImmutableArray`1<ValueTuple`2<LinePositionSpan, ActiveStatementFlags>>>> GetBaseActiveStatementSpansAsync(Solution solution, ImmutableArray`1<DocumentId> documentIds, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.EditAndContinue.EditAndContinueWorkspaceService/<GetAdjustedActiveStatementSpansAsync>d__37")]
public sealed virtual Task`1<ImmutableArray`1<ValueTuple`2<LinePositionSpan, ActiveStatementFlags>>> GetAdjustedActiveStatementSpansAsync(Document document, DocumentActiveStatementSpanProvider activeStatementSpanProvider, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.EditAndContinue.EditAndContinueWorkspaceService/<GetCurrentActiveStatementPositionAsync>d__38")]
public sealed virtual Task`1<Nullable`1<LinePositionSpan>> GetCurrentActiveStatementPositionAsync(Solution solution, SolutionActiveStatementSpanProvider activeStatementSpanProvider, ActiveInstructionId instructionId, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.EditAndContinue.EditAndContinueWorkspaceService/<IsActiveStatementInExceptionRegionAsync>d__39")]
public sealed virtual Task`1<Nullable`1<bool>> IsActiveStatementInExceptionRegionAsync(Solution solution, ActiveInstructionId instructionId, CancellationToken cancellationToken);
    public sealed virtual void ReportApplyChangesException(Solution solution, string message);
    private static void ReportTelemetry(Data data);
    internal static void LogDebuggingSessionTelemetry(Data debugSessionData, Action`2<FunctionId, LogMessage> log, Func`1<int> getNextId);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExportWorkspaceServiceFactoryAttribute("Microsoft.CodeAnalysis.EditAndContinue.IEditAndContinueWorkspaceService", "Default")]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.EditAndContinue.EditAndContinueWorkspaceServiceFactory : object {
    private IDiagnosticAnalyzerService _diagnosticService;
    [NullableAttribute("2")]
private IDebuggeeModuleMetadataProvider _debugeeModuleMetadataProvider;
    private EditAndContinueDiagnosticUpdateSource _diagnosticUpdateSource;
    [ImportingConstructorAttribute]
[ObsoleteAttribute("This exported object must be obtained through the MEF export provider.", "True")]
public EditAndContinueWorkspaceServiceFactory(IDiagnosticAnalyzerService diagnosticService, EditAndContinueDiagnosticUpdateSource diagnosticUpdateSource, IDebuggeeModuleMetadataProvider debugeeModuleMetadataProvider);
    [ObsoleteAttribute("This factory method only provides services for the MEF export provider.", "True")]
public sealed virtual IWorkspaceService CreateService(HostWorkspaceServices workspaceServices);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.CodeAnalysis.EditAndContinue.EditSession : object {
    private CancellationTokenSource _cancellationSource;
    internal DebuggingSession DebuggingSession;
    internal EditSessionTelemetry Telemetry;
    internal IDebuggeeModuleMetadataProvider DebugeeModuleMetadataProvider;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private ImmutableDictionary`2<ActiveMethodId, ImmutableArray`1<NonRemappableRegion>> _nonRemappableRegions;
    internal AsyncLazy`1<ActiveStatementsMap> BaseActiveStatements;
    [NullableAttribute("0")]
internal ImmutableArray`1<ActiveStatementExceptionRegions> _lazyBaseActiveExceptionRegions;
    [TupleElementNamesAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private Dictionary`2<DocumentId, ValueTuple`2<Document, AsyncLazy`1<DocumentAnalysisResults>>> _analyses;
    private object _analysesGuard;
    private HashSet`1<DocumentId> _documentsWithReportedDiagnostics;
    private object _documentsWithReportedDiagnosticsGuard;
    [NullableAttribute("2")]
private PendingSolutionUpdate _pendingUpdate;
    private bool _changesApplied;
    internal CancellationToken CancellationToken { get; }
    internal EditSession(DebuggingSession debuggingSession, EditSessionTelemetry telemetry, ActiveStatementProvider activeStatementProvider, IDebuggeeModuleMetadataProvider debugeeModuleMetadataProvider);
    [NullableContextAttribute("2")]
internal PendingSolutionUpdate Test_GetPendingSolutionUpdate();
    internal CancellationToken get_CancellationToken();
    internal void Cancel();
    public sealed virtual void Dispose();
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.EditAndContinue.EditSession/<GetModuleDiagnosticsAsync>d__19")]
public Task`1<Nullable`1<ImmutableArray`1<Diagnostic>>> GetModuleDiagnosticsAsync(Guid mvid, string projectDisplayName, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.EditAndContinue.EditSession/<GetBaseActiveStatementsAsync>d__20")]
private Task`1<ActiveStatementsMap> GetBaseActiveStatementsAsync(ActiveStatementProvider activeStatementProvider, CancellationToken cancellationToken);
    [NullableContextAttribute("0")]
private ActiveStatementsMap CreateActiveStatementsMap(ImmutableArray`1<ActiveStatementDebugInfo> debugInfos);
    private LinePositionSpan GetUpToDateSpan(ActiveStatementDebugInfo activeStatementInfo);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.EditAndContinue.EditSession/<GetBaseActiveExceptionRegionsAsync>d__23")]
internal Task`1<ImmutableArray`1<ActiveStatementExceptionRegions>> GetBaseActiveExceptionRegionsAsync(Solution solution, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.EditAndContinue.EditSession/<PopulateChangedAndAddedDocumentsAsync>d__24")]
private static Task PopulateChangedAndAddedDocumentsAsync(CommittedSolution baseSolution, Project project, ArrayBuilder`1<Document> changedOrAddedDocuments, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.EditAndContinue.EditSession/<AnalyzeDocumentsAsync>d__25")]
private Task`1<ValueTuple`2<ImmutableArray`1<ValueTuple`2<Document, AsyncLazy`1<DocumentAnalysisResults>>>, ImmutableArray`1<Diagnostic>>> AnalyzeDocumentsAsync(ArrayBuilder`1<Document> changedOrAddedDocuments, SolutionActiveStatementSpanProvider newDocumentActiveStatementSpanProvider, CancellationToken cancellationToken);
    public AsyncLazy`1<DocumentAnalysisResults> GetDocumentAnalysis(Document baseDocument, Document document, ImmutableArray`1<TextSpan> activeStatementSpans);
    private AsyncLazy`1<DocumentAnalysisResults> GetDocumentAnalysisNoLock(Document baseDocument, Document document, ImmutableArray`1<TextSpan> activeStatementSpans);
    internal ImmutableArray`1<DocumentId> GetDocumentsWithReportedDiagnostics();
    internal void TrackDocumentWithReportedDiagnostics(DocumentId documentId);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.EditAndContinue.EditSession/<HasChangesAsync>d__30")]
public Task`1<bool> HasChangesAsync(Solution solution, SolutionActiveStatementSpanProvider solutionActiveStatementSpanProvider, string sourceFilePath, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.EditAndContinue.EditSession/<GetProjectAnalysisSymmaryAsync>d__31")]
private static Task`1<ProjectAnalysisSummary> GetProjectAnalysisSymmaryAsync(ImmutableArray`1<ValueTuple`2<Document, AsyncLazy`1<DocumentAnalysisResults>>> documentAnalyses, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.EditAndContinue.EditSession/<GetProjectChangesAsync>d__32")]
private static Task`1<ProjectChanges> GetProjectChangesAsync(ImmutableArray`1<ValueTuple`2<Document, AsyncLazy`1<DocumentAnalysisResults>>> changedDocumentAnalyses, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.EditAndContinue.EditSession/<EmitSolutionUpdateAsync>d__33")]
public Task`1<SolutionUpdate> EmitSolutionUpdateAsync(Solution solution, SolutionActiveStatementSpanProvider solutionActiveStatementSpanProvider, CancellationToken cancellationToken);
    [NullableContextAttribute("2")]
private static bool CreateInitialBaselineForDeferredModuleUpdate(CompilationOutputs compilationOutputs, ImmutableArray`1& diagnostics, EmitBaseline& baseline, DebugInformationReaderProvider& debugInfoReaderProvider, MetadataReaderProvider& metadataReaderProvider);
    [NullableContextAttribute("0")]
internal static void GetActiveStatementAndExceptionRegionSpans(Guid moduleId, ActiveStatementsMap baseActiveStatements, ImmutableArray`1<ActiveStatementExceptionRegions> baseActiveExceptionRegions, ImmutableArray`1<int> updatedMethodTokens, ImmutableDictionary`2<ActiveMethodId, ImmutableArray`1<NonRemappableRegion>> previousNonRemappableRegions, ImmutableArray`1<ValueTuple`3<DocumentId, ImmutableArray`1<ActiveStatement>, ImmutableArray`1<ImmutableArray`1<LinePositionSpan>>>> newActiveStatementsInChangedDocuments, ImmutableArray`1& activeStatementsInUpdatedMethods, ImmutableArray`1& nonRemappableRegions);
    internal void StorePendingUpdate(Solution solution, SolutionUpdate update);
    internal PendingSolutionUpdate RetrievePendingUpdate();
    internal void ChangesApplied();
    [CompilerGeneratedAttribute]
private bool <CreateActiveStatementsMap>g__supportsEditAndContinue|21_0(DocumentId documentId);
    [NullableContextAttribute("0")]
[CompilerGeneratedAttribute]
private ValueTuple`2<Document, AsyncLazy`1<DocumentAnalysisResults>> <AnalyzeDocumentsAsync>b__25_0(ValueTuple`3<Document, Document, ImmutableArray`1<TextSpan>> change);
    [CompilerGeneratedAttribute]
internal static void <GetActiveStatementAndExceptionRegionSpans>g__AddNonRemappableRegion|35_0(LinePositionSpan oldSpan, LinePositionSpan newSpan, bool isExceptionRegion, <>c__DisplayClass35_0& , <>c__DisplayClass35_1& );
}
internal class Microsoft.CodeAnalysis.EditAndContinue.EditSessionTelemetry : object {
    private object _guard;
    private HashSet`1<ValueTuple`2<ushort, ushort>> _rudeEdits;
    private HashSet`1<string> _emitErrorIds;
    private bool _hadCompilationErrors;
    private bool _hadRudeEdits;
    private bool _hadValidChanges;
    private bool _hadValidInsignificantChanges;
    public Data GetDataAndClear();
    public void LogProjectAnalysisSummary(ProjectAnalysisSummary summary, ImmutableArray`1<string> errorsIds);
    public void LogProjectAnalysisSummary(ProjectAnalysisSummary summary, ImmutableArray`1<Diagnostic> emitDiagnostics);
    public void LogRudeEditDiagnostics(ImmutableArray`1<RudeEditDiagnostic> diagnostics);
}
[NullableContextAttribute("1")]
internal interface Microsoft.CodeAnalysis.EditAndContinue.IDebuggeeModuleMetadataProvider {
    [NullableContextAttribute("2")]
public abstract virtual DebuggeeModuleInfo TryGetBaselineModuleInfo(Guid mvid);
    public abstract virtual Task`1<Nullable`1<ValueTuple`2<int, string>>> GetEncAvailabilityAsync(Guid mvid, CancellationToken cancellationToken);
    public abstract virtual Task PrepareModuleForUpdateAsync(Guid mvid, CancellationToken cancellationToken);
}
[NullableContextAttribute("1")]
internal interface Microsoft.CodeAnalysis.EditAndContinue.IEditAndContinueAnalyzer {
    public abstract virtual Task`1<DocumentAnalysisResults> AnalyzeDocumentAsync(Document oldDocument, ImmutableArray`1<ActiveStatement> activeStatements, Document document, ImmutableArray`1<TextSpan> newActiveStatementSpans, CancellationToken cancellationToken);
    public abstract virtual ImmutableArray`1<LinePositionSpan> GetExceptionRegions(SourceText text, SyntaxNode syntaxRoot, LinePositionSpan activeStatementSpan, bool isLeaf, Boolean& isCovered);
}
[NullableContextAttribute("1")]
internal interface Microsoft.CodeAnalysis.EditAndContinue.IEditAndContinueWorkspaceService {
    public bool IsDebuggingSessionInProgress { get; }
    public abstract virtual Task`1<ImmutableArray`1<ImmutableArray`1<ValueTuple`2<LinePositionSpan, ActiveStatementFlags>>>> GetBaseActiveStatementSpansAsync(Solution solution, ImmutableArray`1<DocumentId> documentIds, CancellationToken cancellationToken);
    public abstract virtual Task`1<ImmutableArray`1<ValueTuple`2<LinePositionSpan, ActiveStatementFlags>>> GetAdjustedActiveStatementSpansAsync(Document document, DocumentActiveStatementSpanProvider activeStatementSpanProvider, CancellationToken cancellationToken);
    public abstract virtual Task`1<ImmutableArray`1<Diagnostic>> GetDocumentDiagnosticsAsync(Document document, DocumentActiveStatementSpanProvider activeStatementSpanProvider, CancellationToken cancellationToken);
    public abstract virtual Task`1<bool> HasChangesAsync(Solution solution, SolutionActiveStatementSpanProvider activeStatementSpanProvider, string sourceFilePath, CancellationToken cancellationToken);
    public abstract virtual Task`1<ValueTuple`2<SolutionUpdateStatus, ImmutableArray`1<Deltas>>> EmitSolutionUpdateAsync(Solution solution, SolutionActiveStatementSpanProvider activeStatementSpanProvider, CancellationToken cancellationToken);
    public abstract virtual void CommitSolutionUpdate();
    public abstract virtual void DiscardSolutionUpdate();
    public abstract virtual bool get_IsDebuggingSessionInProgress();
    public abstract virtual void OnSourceFileUpdated(Document document);
    public abstract virtual void StartDebuggingSession(Solution solution);
    public abstract virtual void StartEditSession(ActiveStatementProvider activeStatementProvider);
    public abstract virtual void EndEditSession();
    public abstract virtual void EndDebuggingSession();
    public abstract virtual Task`1<Nullable`1<bool>> IsActiveStatementInExceptionRegionAsync(Solution solution, ActiveInstructionId instructionId, CancellationToken cancellationToken);
    public abstract virtual Task`1<Nullable`1<LinePositionSpan>> GetCurrentActiveStatementPositionAsync(Solution solution, SolutionActiveStatementSpanProvider activeStatementSpanProvider, ActiveInstructionId instructionId, CancellationToken cancellationToken);
    public abstract virtual void ReportApplyChangesException(Solution solution, string message);
}
[IsReadOnlyAttribute]
internal class Microsoft.CodeAnalysis.EditAndContinue.ILDelta : ValueType {
    public ImmutableArray`1<byte> Value;
    public ILDelta(ImmutableArray`1<byte> value);
}
[IsReadOnlyAttribute]
internal class Microsoft.CodeAnalysis.EditAndContinue.LineChange : ValueType {
    public int OldLine;
    public int NewLine;
    internal LineChange(int oldLine, int newLine);
    public virtual bool Equals(object obj);
    public sealed virtual bool Equals(LineChange other);
    public virtual int GetHashCode();
    public virtual string ToString();
}
[ExtensionAttribute]
internal static class Microsoft.CodeAnalysis.EditAndContinue.LinePositionSpanExtensions : object {
    [ExtensionAttribute]
internal static LinePositionSpan AddLineDelta(LinePositionSpan span, int lineDelta);
    [ExtensionAttribute]
internal static int GetLineDelta(LinePositionSpan oldSpan, LinePositionSpan newSpan);
    [ExtensionAttribute]
internal static bool Contains(LinePositionSpan container, LinePositionSpan span);
    [ExtensionAttribute]
internal static TextSpan GetTextSpanSafe(TextLineCollection lines, LinePositionSpan span);
}
[IsReadOnlyAttribute]
internal class Microsoft.CodeAnalysis.EditAndContinue.MetadataDelta : ValueType {
    public ImmutableArray`1<byte> Bytes;
    public MetadataDelta(ImmutableArray`1<byte> bytes);
}
[IsReadOnlyAttribute]
[DebuggerDisplayAttribute("{GetDebuggerDisplay(),nq}")]
internal class Microsoft.CodeAnalysis.EditAndContinue.NonRemappableRegion : ValueType {
    public LinePositionSpan Span;
    public int LineDelta;
    public bool IsExceptionRegion;
    public NonRemappableRegion(LinePositionSpan span, int lineDelta, bool isExceptionRegion);
    public NonRemappableRegion WithLineDelta(int value);
    internal string GetDebuggerDisplay();
}
[IsReadOnlyAttribute]
internal class Microsoft.CodeAnalysis.EditAndContinue.PdbDelta : ValueType {
    public ImmutableArray`1<int> UpdatedMethods;
    public ImmutableArray`1<byte> Stream;
    public PdbDelta(ImmutableArray`1<byte> stream, ImmutableArray`1<int> updatedMethods);
}
internal class Microsoft.CodeAnalysis.EditAndContinue.PendingSolutionUpdate : object {
    public Solution Solution;
    [TupleElementNamesAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ImmutableArray`1<ValueTuple`2<ProjectId, EmitBaseline>> EmitBaselines;
    public ImmutableArray`1<Deltas> Deltas;
    public ImmutableArray`1<IDisposable> ModuleReaders;
    public PendingSolutionUpdate(Solution solution, ImmutableArray`1<ValueTuple`2<ProjectId, EmitBaseline>> emitBaselines, ImmutableArray`1<Deltas> deltas, ImmutableArray`1<IDisposable> moduleReaders);
}
internal enum Microsoft.CodeAnalysis.EditAndContinue.ProjectAnalysisSummary : Enum {
    public int value__;
    public static ProjectAnalysisSummary NoChanges;
    public static ProjectAnalysisSummary CompilationErrors;
    public static ProjectAnalysisSummary RudeEdits;
    public static ProjectAnalysisSummary ValidInsignificantChanges;
    public static ProjectAnalysisSummary ValidChanges;
}
[IsReadOnlyAttribute]
internal class Microsoft.CodeAnalysis.EditAndContinue.ProjectChanges : ValueType {
    public ImmutableArray`1<SemanticEdit> SemanticEdits;
    [TupleElementNamesAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ImmutableArray`1<ValueTuple`2<DocumentId, ImmutableArray`1<LineChange>>> LineChanges;
    public ImmutableHashSet`1<ISymbol> AddedSymbols;
    [TupleElementNamesAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ImmutableArray`1<ValueTuple`3<DocumentId, ImmutableArray`1<ActiveStatement>, ImmutableArray`1<ImmutableArray`1<LinePositionSpan>>>> NewActiveStatements;
    public ProjectChanges(ImmutableArray`1<SemanticEdit> semanticEdits, ImmutableArray`1<ValueTuple`2<DocumentId, ImmutableArray`1<LineChange>>> lineChanges, ImmutableHashSet`1<ISymbol> addedSymbols, ImmutableArray`1<ValueTuple`3<DocumentId, ImmutableArray`1<ActiveStatement>, ImmutableArray`1<ImmutableArray`1<LinePositionSpan>>>> newActiveStatements);
}
[IsReadOnlyAttribute]
internal class Microsoft.CodeAnalysis.EditAndContinue.RudeEditDiagnostic : ValueType {
    public RudeEditKind Kind;
    public TextSpan Span;
    public ushort SyntaxKind;
    public String[] Arguments;
    internal RudeEditDiagnostic(RudeEditKind kind, TextSpan span, SyntaxNode node, String[] arguments);
    internal Diagnostic ToDiagnostic(SyntaxTree tree);
}
internal enum Microsoft.CodeAnalysis.EditAndContinue.RudeEditKind : Enum {
    public ushort value__;
    public static RudeEditKind None;
    public static RudeEditKind ActiveStatementUpdate;
    public static RudeEditKind ActiveStatementLambdaRemoved;
    public static RudeEditKind Update;
    public static RudeEditKind ModifiersUpdate;
    public static RudeEditKind HandlesClauseUpdate;
    public static RudeEditKind ImplementsClauseUpdate;
    public static RudeEditKind VarianceUpdate;
    public static RudeEditKind FieldKindUpdate;
    public static RudeEditKind TypeUpdate;
    public static RudeEditKind ConstraintKindUpdate;
    public static RudeEditKind InitializerUpdate;
    public static RudeEditKind FixedSizeFieldUpdate;
    public static RudeEditKind EnumUnderlyingTypeUpdate;
    public static RudeEditKind BaseTypeOrInterfaceUpdate;
    public static RudeEditKind TypeKindUpdate;
    public static RudeEditKind AccessorKindUpdate;
    public static RudeEditKind MethodKindUpdate;
    public static RudeEditKind DeclareLibraryUpdate;
    public static RudeEditKind DeclareAliasUpdate;
    public static RudeEditKind Renamed;
    public static RudeEditKind Insert;
    public static RudeEditKind InsertVirtual;
    public static RudeEditKind InsertOverridable;
    public static RudeEditKind InsertExtern;
    public static RudeEditKind InsertOperator;
    public static RudeEditKind InsertGenericMethod;
    public static RudeEditKind InsertDllImport;
    public static RudeEditKind InsertIntoStruct;
    public static RudeEditKind InsertIntoClassWithLayout;
    public static RudeEditKind Move;
    public static RudeEditKind Delete;
    public static RudeEditKind MethodBodyAdd;
    public static RudeEditKind MethodBodyDelete;
    public static RudeEditKind GenericMethodUpdate;
    public static RudeEditKind GenericMethodTriviaUpdate;
    public static RudeEditKind GenericTypeUpdate;
    public static RudeEditKind GenericTypeTriviaUpdate;
    public static RudeEditKind GenericTypeInitializerUpdate;
    public static RudeEditKind PartialTypeInitializerUpdate;
    public static RudeEditKind StackAllocUpdate;
    public static RudeEditKind ExperimentalFeaturesEnabled;
    public static RudeEditKind AwaitStatementUpdate;
    public static RudeEditKind ChangingConstructorVisibility;
    public static RudeEditKind CapturingVariable;
    public static RudeEditKind NotCapturingVariable;
    public static RudeEditKind DeletingCapturedVariable;
    public static RudeEditKind ChangingCapturedVariableType;
    public static RudeEditKind ChangingCapturedVariableScope;
    public static RudeEditKind ChangingLambdaParameters;
    public static RudeEditKind ChangingLambdaReturnType;
    public static RudeEditKind AccessingCapturedVariableInLambda;
    public static RudeEditKind NotAccessingCapturedVariableInLambda;
    public static RudeEditKind InsertLambdaWithMultiScopeCapture;
    public static RudeEditKind DeleteLambdaWithMultiScopeCapture;
    public static RudeEditKind ChangingQueryLambdaType;
    public static RudeEditKind InsertAroundActiveStatement;
    public static RudeEditKind DeleteAroundActiveStatement;
    public static RudeEditKind DeleteActiveStatement;
    public static RudeEditKind UpdateAroundActiveStatement;
    public static RudeEditKind UpdateExceptionHandlerOfActiveTry;
    public static RudeEditKind UpdateTryOrCatchWithActiveFinally;
    public static RudeEditKind UpdateCatchHandlerAroundActiveStatement;
    public static RudeEditKind UpdateStaticLocal;
    public static RudeEditKind InsertConstructorToTypeWithInitializersWithLambdas;
    public static RudeEditKind RenamingCapturedVariable;
    public static RudeEditKind InsertHandlesClause;
    public static RudeEditKind InsertFile;
    public static RudeEditKind PartiallyExecutedActiveStatementUpdate;
    public static RudeEditKind PartiallyExecutedActiveStatementDelete;
    public static RudeEditKind UpdatingStateMachineMethodAroundActiveStatement;
    public static RudeEditKind UpdatingStateMachineMethodMissingAttribute;
    public static RudeEditKind SwitchBetweenLambdaAndLocalFunction;
    public static RudeEditKind InternalError;
    public static RudeEditKind InsertMethodWithExplicitInterfaceSpecifier;
    public static RudeEditKind InsertIntoInterface;
    public static RudeEditKind InsertLocalFunctionIntoInterfaceMethod;
    public static RudeEditKind SwitchExpressionUpdate;
    public static RudeEditKind ChangingFromAsynchronousToSynchronous;
    public static RudeEditKind ChangingStateMachineShape;
    public static RudeEditKind ComplexQueryExpression;
    public static RudeEditKind MemberBodyInternalError;
    public static RudeEditKind SourceFileTooBig;
    public static RudeEditKind MemberBodyTooBig;
}
internal class Microsoft.CodeAnalysis.EditAndContinue.SolutionActiveStatementSpanProvider : MulticastDelegate {
    public SolutionActiveStatementSpanProvider(object object, IntPtr method);
    public virtual Task`1<ImmutableArray`1<TextSpan>> Invoke(DocumentId documentId, CancellationToken cancellationToken);
    public virtual IAsyncResult BeginInvoke(DocumentId documentId, CancellationToken cancellationToken, AsyncCallback callback, object object);
    public virtual Task`1<ImmutableArray`1<TextSpan>> EndInvoke(IAsyncResult result);
}
[IsReadOnlyAttribute]
internal class Microsoft.CodeAnalysis.EditAndContinue.SolutionUpdate : ValueType {
    public SolutionUpdateStatus Summary;
    public ImmutableArray`1<Deltas> Deltas;
    public ImmutableArray`1<IDisposable> ModuleReaders;
    [TupleElementNamesAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ImmutableArray`1<ValueTuple`2<ProjectId, EmitBaseline>> EmitBaselines;
    [TupleElementNamesAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ImmutableArray`1<ValueTuple`2<ProjectId, ImmutableArray`1<Diagnostic>>> Diagnostics;
    public SolutionUpdate(SolutionUpdateStatus summary, ImmutableArray`1<Deltas> deltas, ImmutableArray`1<IDisposable> moduleReaders, ImmutableArray`1<ValueTuple`2<ProjectId, EmitBaseline>> emitBaselines, ImmutableArray`1<ValueTuple`2<ProjectId, ImmutableArray`1<Diagnostic>>> diagnostics);
    public static SolutionUpdate Blocked();
    public static SolutionUpdate Blocked(ImmutableArray`1<ValueTuple`2<ProjectId, ImmutableArray`1<Diagnostic>>> diagnostics);
}
internal enum Microsoft.CodeAnalysis.EditAndContinue.SolutionUpdateStatus : Enum {
    public int value__;
    public static SolutionUpdateStatus None;
    public static SolutionUpdateStatus Ready;
    public static SolutionUpdateStatus Blocked;
}
[FlagsAttribute]
internal enum Microsoft.CodeAnalysis.EditAndContinue.StateMachineKinds : Enum {
    public int value__;
    public static StateMachineKinds None;
    public static StateMachineKinds Async;
    public static StateMachineKinds Iterator;
}
internal class Microsoft.CodeAnalysis.EditAndContinue.TraceLog : object {
    private Entry[] _log;
    private string _id;
    private int _currentLine;
    public TraceLog(int logSize, string id);
    private void Append(Entry entry);
    public void Write(string str);
    public void Write(string format, Arg[] args);
    [ConditionalAttribute("DEBUG")]
public void DebugWrite(string str);
    [ConditionalAttribute("DEBUG")]
public void DebugWrite(string format, Arg[] args);
    internal TestAccessor GetTestAccessor();
}
[CompilerGeneratedAttribute]
[EmbeddedAttribute]
internal class Microsoft.CodeAnalysis.EmbeddedAttribute : Attribute {
}
internal class Microsoft.CodeAnalysis.EmbeddedLanguages.DateAndTime.DateAndTimeOptions : object {
    [NullableAttribute("1")]
public static PerLanguageOption2`1<bool> ProvideDateAndTimeCompletions;
    private static DateAndTimeOptions();
}
[ExportOptionProviderAttribute]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.EmbeddedLanguages.DateAndTime.DateAndTimeOptionsProvider : object {
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private ImmutableArray`1<IOption> <Options>k__BackingField;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ImmutableArray`1<IOption> Options { get; }
    [CompilerGeneratedAttribute]
public sealed virtual ImmutableArray`1<IOption> get_Options();
}
internal class Microsoft.CodeAnalysis.EmbeddedLanguages.DateAndTime.LanguageServices.DateAndTimeEmbeddedLanguage : object {
    public EmbeddedLanguageInfo Info;
    [NullableAttribute("2")]
public ISyntaxClassifier Classifier { get; }
    public DateAndTimeEmbeddedLanguage(EmbeddedLanguageInfo info);
    [NullableContextAttribute("2")]
public sealed virtual ISyntaxClassifier get_Classifier();
    [NullableContextAttribute("1")]
[AsyncStateMachineAttribute("Microsoft.CodeAnalysis.EmbeddedLanguages.DateAndTime.LanguageServices.DateAndTimeEmbeddedLanguage/<TryGetDateAndTimeTokenAtPositionAsync>d__4")]
internal Task`1<Nullable`1<SyntaxToken>> TryGetDateAndTimeTokenAtPositionAsync(Document document, int position, CancellationToken cancellationToken);
    [NullableContextAttribute("1")]
private static SyntaxToken GetToken(ISyntaxFactsService syntaxFacts, SyntaxNode root, int position);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.CodeAnalysis.EmbeddedLanguages.DateAndTime.LanguageServices.DateAndTimePatternDetector : object {
    private static string FormatName;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private static ConditionalWeakTable`2<SemanticModel, DateAndTimePatternDetector> _modelToDetector;
    private EmbeddedLanguageInfo _info;
    private SemanticModel _semanticModel;
    private INamedTypeSymbol _dateTimeType;
    private INamedTypeSymbol _dateTimeOffsetType;
    public DateAndTimePatternDetector(SemanticModel semanticModel, EmbeddedLanguageInfo info, INamedTypeSymbol dateTimeType, INamedTypeSymbol dateTimeOffsetType);
    private static DateAndTimePatternDetector();
    public static DateAndTimePatternDetector TryGetOrCreate(SemanticModel semanticModel, EmbeddedLanguageInfo info);
    private static DateAndTimePatternDetector TryCreate(SemanticModel semanticModel, EmbeddedLanguageInfo info);
    [NullableContextAttribute("2")]
public static bool IsPossiblyDateAndTimeArgumentToken(SyntaxToken token, ISyntaxFacts syntaxFacts, SyntaxNode& argumentNode, SyntaxNode& invocationExpression);
    private static string GetNameOfInvokedExpression(ISyntaxFacts syntaxFacts, SyntaxNode invokedExpression);
    private static bool IsMethodArgument(SyntaxToken token, ISyntaxFacts syntaxFacts);
    public bool IsDateAndTimeToken(SyntaxToken token, ISyntaxFacts syntaxFacts, CancellationToken cancellationToken);
    private ValueTuple`2<string, Nullable`1<int>> GetArgumentNameOrIndex(SyntaxNode argument);
    [NullableContextAttribute("2")]
private bool TryAnalyzeInvocation(ISymbol symbol, string argName, Nullable`1<int> argIndex);
    [NullableContextAttribute("2")]
private bool IsDateTimeType(ITypeSymbol type);
    private static bool AnalyzeStringLiteral(IMethodSymbol method, string argName, Nullable`1<int> argIndex);
}
internal interface Microsoft.CodeAnalysis.EmbeddedLanguages.RegularExpressions.IRegexNodeVisitor {
    public abstract virtual void Visit(RegexCompilationUnit node);
    public abstract virtual void Visit(RegexSequenceNode node);
    public abstract virtual void Visit(RegexTextNode node);
    public abstract virtual void Visit(RegexCharacterClassNode node);
    public abstract virtual void Visit(RegexNegatedCharacterClassNode node);
    public abstract virtual void Visit(RegexCharacterClassRangeNode node);
    public abstract virtual void Visit(RegexCharacterClassSubtractionNode node);
    public abstract virtual void Visit(RegexPosixPropertyNode node);
    public abstract virtual void Visit(RegexWildcardNode node);
    public abstract virtual void Visit(RegexZeroOrMoreQuantifierNode node);
    public abstract virtual void Visit(RegexOneOrMoreQuantifierNode node);
    public abstract virtual void Visit(RegexZeroOrOneQuantifierNode node);
    public abstract virtual void Visit(RegexLazyQuantifierNode node);
    public abstract virtual void Visit(RegexExactNumericQuantifierNode node);
    public abstract virtual void Visit(RegexOpenNumericRangeQuantifierNode node);
    public abstract virtual void Visit(RegexClosedNumericRangeQuantifierNode node);
    public abstract virtual void Visit(RegexAnchorNode node);
    public abstract virtual void Visit(RegexAlternationNode node);
    public abstract virtual void Visit(RegexSimpleGroupingNode node);
    public abstract virtual void Visit(RegexSimpleOptionsGroupingNode node);
    public abstract virtual void Visit(RegexNestedOptionsGroupingNode node);
    public abstract virtual void Visit(RegexNonCapturingGroupingNode node);
    public abstract virtual void Visit(RegexPositiveLookaheadGroupingNode node);
    public abstract virtual void Visit(RegexNegativeLookaheadGroupingNode node);
    public abstract virtual void Visit(RegexPositiveLookbehindGroupingNode node);
    public abstract virtual void Visit(RegexNegativeLookbehindGroupingNode node);
    public abstract virtual void Visit(RegexAtomicGroupingNode node);
    public abstract virtual void Visit(RegexCaptureGroupingNode node);
    public abstract virtual void Visit(RegexBalancingGroupingNode node);
    public abstract virtual void Visit(RegexConditionalCaptureGroupingNode node);
    public abstract virtual void Visit(RegexConditionalExpressionGroupingNode node);
    public abstract virtual void Visit(RegexSimpleEscapeNode node);
    public abstract virtual void Visit(RegexAnchorEscapeNode node);
    public abstract virtual void Visit(RegexCharacterClassEscapeNode node);
    public abstract virtual void Visit(RegexControlEscapeNode node);
    public abstract virtual void Visit(RegexHexEscapeNode node);
    public abstract virtual void Visit(RegexUnicodeEscapeNode node);
    public abstract virtual void Visit(RegexCaptureEscapeNode node);
    public abstract virtual void Visit(RegexKCaptureEscapeNode node);
    public abstract virtual void Visit(RegexOctalEscapeNode node);
    public abstract virtual void Visit(RegexBackreferenceEscapeNode node);
    public abstract virtual void Visit(RegexCategoryEscapeNode node);
}
internal class Microsoft.CodeAnalysis.EmbeddedLanguages.RegularExpressions.LanguageServices.RegexPatternDetector : object {
    private static string _patternName;
    private static ConditionalWeakTable`2<Compilation, RegexPatternDetector> _modelToDetector;
    private EmbeddedLanguageInfo _info;
    private INamedTypeSymbol _regexType;
    private HashSet`1<string> _methodNamesOfInterest;
    private static Regex s_languageCommentDetector;
    private static Dictionary`2<string, RegexOptions> s_nameToOption;
    public RegexPatternDetector(EmbeddedLanguageInfo info, INamedTypeSymbol regexType, HashSet`1<string> methodNamesOfInterest);
    private static RegexPatternDetector();
    public static RegexPatternDetector TryGetOrCreate(Compilation compilation, EmbeddedLanguageInfo info);
    private static RegexPatternDetector TryCreate(Compilation compilation, EmbeddedLanguageInfo info);
    public static bool IsPossiblyPatternToken(SyntaxToken token, ISyntaxFacts syntaxFacts);
    private static bool HasRegexLanguageComment(SyntaxToken token, ISyntaxFacts syntaxFacts, RegexOptions& options);
    private static bool HasRegexLanguageComment(SyntaxTriviaList list, ISyntaxFacts syntaxFacts, RegexOptions& options);
    private static bool HasRegexLanguageComment(SyntaxTrivia trivia, ISyntaxFacts syntaxFacts, RegexOptions& options);
    private static ValueTuple`2<bool, RegexOptions> TryMatch(string text);
    private static bool IsMethodOrConstructorArgument(SyntaxToken token, ISyntaxFacts syntaxFacts);
    private static HashSet`1<string> GetMethodNamesOfInterest(INamedTypeSymbol regexType, ISyntaxFacts syntaxFacts);
    public bool IsRegexPattern(SyntaxToken token, SemanticModel semanticModel, CancellationToken cancellationToken, RegexOptions& options);
    private bool TryAnalyzeInvocation(SyntaxNode argumentNode, SemanticModel semanticModel, ISymbol method, CancellationToken cancellationToken, RegexOptions& options);
    public RegexTree TryParseRegexPattern(SyntaxToken token, SemanticModel semanticModel, CancellationToken cancellationToken);
    private bool AnalyzeStringLiteral(SyntaxNode argumentNode, SemanticModel semanticModel, CancellationToken cancellationToken, RegexOptions& options);
    private RegexOptions GetRegexOptions(SyntaxNode argumentNode, SemanticModel semanticModel, CancellationToken cancellationToken);
    private string GetNameOfType(SyntaxNode typeNode, ISyntaxFacts syntaxFacts);
    private string GetNameOfInvokedExpression(SyntaxNode invokedExpression);
}
internal class Microsoft.CodeAnalysis.EmbeddedLanguages.RegularExpressions.LanguageServices.RegexSyntaxClassifier : AbstractSyntaxClassifier {
    private static ObjectPool`1<Visitor> s_visitorPool;
    private EmbeddedLanguageInfo _info;
    [CompilerGeneratedAttribute]
private ImmutableArray`1<int> <SyntaxTokenKinds>k__BackingField;
    public ImmutableArray`1<int> SyntaxTokenKinds { get; }
    public RegexSyntaxClassifier(EmbeddedLanguageInfo info);
    private static RegexSyntaxClassifier();
    [CompilerGeneratedAttribute]
public virtual ImmutableArray`1<int> get_SyntaxTokenKinds();
    public virtual void AddClassifications(Workspace workspace, SyntaxToken token, SemanticModel semanticModel, ArrayBuilder`1<ClassifiedSpan> result, CancellationToken cancellationToken);
    private static void AddClassifications(RegexNode node, Visitor visitor, ArrayBuilder`1<ClassifiedSpan> result);
    private static void AddTriviaClassifications(EmbeddedSyntaxToken`1<RegexKind> token, ArrayBuilder`1<ClassifiedSpan> result);
    private static void AddTriviaClassifications(EmbeddedSyntaxTrivia`1<RegexKind> trivia, ArrayBuilder`1<ClassifiedSpan> result);
}
internal class Microsoft.CodeAnalysis.EmbeddedLanguages.RegularExpressions.RegexAlternationNode : RegexExpressionNode {
    [CompilerGeneratedAttribute]
private RegexExpressionNode <Left>k__BackingField;
    [CompilerGeneratedAttribute]
private EmbeddedSyntaxToken`1<RegexKind> <BarToken>k__BackingField;
    [CompilerGeneratedAttribute]
private RegexSequenceNode <Right>k__BackingField;
    public RegexExpressionNode Left { get; }
    public EmbeddedSyntaxToken`1<RegexKind> BarToken { get; }
    public RegexSequenceNode Right { get; }
    internal int ChildCount { get; }
    public RegexAlternationNode(RegexExpressionNode left, EmbeddedSyntaxToken`1<RegexKind> barToken, RegexSequenceNode right);
    [CompilerGeneratedAttribute]
public RegexExpressionNode get_Left();
    [CompilerGeneratedAttribute]
public EmbeddedSyntaxToken`1<RegexKind> get_BarToken();
    [CompilerGeneratedAttribute]
public RegexSequenceNode get_Right();
    internal virtual int get_ChildCount();
    internal virtual EmbeddedSyntaxNodeOrToken`2<RegexKind, RegexNode> ChildAt(int index);
    public virtual void Accept(IRegexNodeVisitor visitor);
}
internal class Microsoft.CodeAnalysis.EmbeddedLanguages.RegularExpressions.RegexAnchorEscapeNode : RegexTypeEscapeNode {
    internal int ChildCount { get; }
    public RegexAnchorEscapeNode(EmbeddedSyntaxToken`1<RegexKind> backslashToken, EmbeddedSyntaxToken`1<RegexKind> typeToken);
    internal virtual int get_ChildCount();
    internal virtual EmbeddedSyntaxNodeOrToken`2<RegexKind, RegexNode> ChildAt(int index);
    public virtual void Accept(IRegexNodeVisitor visitor);
}
internal class Microsoft.CodeAnalysis.EmbeddedLanguages.RegularExpressions.RegexAnchorNode : RegexPrimaryExpressionNode {
    [CompilerGeneratedAttribute]
private EmbeddedSyntaxToken`1<RegexKind> <AnchorToken>k__BackingField;
    public EmbeddedSyntaxToken`1<RegexKind> AnchorToken { get; }
    internal int ChildCount { get; }
    public RegexAnchorNode(RegexKind kind, EmbeddedSyntaxToken`1<RegexKind> anchorToken);
    [CompilerGeneratedAttribute]
public EmbeddedSyntaxToken`1<RegexKind> get_AnchorToken();
    internal virtual int get_ChildCount();
    internal virtual EmbeddedSyntaxNodeOrToken`2<RegexKind, RegexNode> ChildAt(int index);
    public virtual void Accept(IRegexNodeVisitor visitor);
}
internal class Microsoft.CodeAnalysis.EmbeddedLanguages.RegularExpressions.RegexAtomicGroupingNode : RegexQuestionGroupingNode {
    [CompilerGeneratedAttribute]
private EmbeddedSyntaxToken`1<RegexKind> <GreaterThanToken>k__BackingField;
    [CompilerGeneratedAttribute]
private RegexExpressionNode <Expression>k__BackingField;
    public EmbeddedSyntaxToken`1<RegexKind> GreaterThanToken { get; }
    public RegexExpressionNode Expression { get; }
    internal int ChildCount { get; }
    public RegexAtomicGroupingNode(EmbeddedSyntaxToken`1<RegexKind> openParenToken, EmbeddedSyntaxToken`1<RegexKind> questionToken, EmbeddedSyntaxToken`1<RegexKind> greaterThanToken, RegexExpressionNode expression, EmbeddedSyntaxToken`1<RegexKind> closeParenToken);
    [CompilerGeneratedAttribute]
public EmbeddedSyntaxToken`1<RegexKind> get_GreaterThanToken();
    [CompilerGeneratedAttribute]
public RegexExpressionNode get_Expression();
    internal virtual int get_ChildCount();
    internal virtual EmbeddedSyntaxNodeOrToken`2<RegexKind, RegexNode> ChildAt(int index);
    public virtual void Accept(IRegexNodeVisitor visitor);
}
internal class Microsoft.CodeAnalysis.EmbeddedLanguages.RegularExpressions.RegexBackreferenceEscapeNode : RegexEscapeNode {
    [CompilerGeneratedAttribute]
private EmbeddedSyntaxToken`1<RegexKind> <NumberToken>k__BackingField;
    internal int ChildCount { get; }
    public EmbeddedSyntaxToken`1<RegexKind> NumberToken { get; }
    public RegexBackreferenceEscapeNode(EmbeddedSyntaxToken`1<RegexKind> backslashToken, EmbeddedSyntaxToken`1<RegexKind> numberToken);
    internal virtual int get_ChildCount();
    [CompilerGeneratedAttribute]
public EmbeddedSyntaxToken`1<RegexKind> get_NumberToken();
    internal virtual EmbeddedSyntaxNodeOrToken`2<RegexKind, RegexNode> ChildAt(int index);
    public virtual void Accept(IRegexNodeVisitor visitor);
}
internal class Microsoft.CodeAnalysis.EmbeddedLanguages.RegularExpressions.RegexBalancingGroupingNode : RegexQuestionGroupingNode {
    [CompilerGeneratedAttribute]
private EmbeddedSyntaxToken`1<RegexKind> <OpenToken>k__BackingField;
    [CompilerGeneratedAttribute]
private EmbeddedSyntaxToken`1<RegexKind> <FirstCaptureToken>k__BackingField;
    [CompilerGeneratedAttribute]
private EmbeddedSyntaxToken`1<RegexKind> <MinusToken>k__BackingField;
    [CompilerGeneratedAttribute]
private EmbeddedSyntaxToken`1<RegexKind> <SecondCaptureToken>k__BackingField;
    [CompilerGeneratedAttribute]
private EmbeddedSyntaxToken`1<RegexKind> <CloseToken>k__BackingField;
    [CompilerGeneratedAttribute]
private RegexExpressionNode <Expression>k__BackingField;
    public EmbeddedSyntaxToken`1<RegexKind> OpenToken { get; }
    public EmbeddedSyntaxToken`1<RegexKind> FirstCaptureToken { get; }
    public EmbeddedSyntaxToken`1<RegexKind> MinusToken { get; }
    public EmbeddedSyntaxToken`1<RegexKind> SecondCaptureToken { get; }
    public EmbeddedSyntaxToken`1<RegexKind> CloseToken { get; }
    public RegexExpressionNode Expression { get; }
    internal int ChildCount { get; }
    public RegexBalancingGroupingNode(EmbeddedSyntaxToken`1<RegexKind> openParenToken, EmbeddedSyntaxToken`1<RegexKind> questionToken, EmbeddedSyntaxToken`1<RegexKind> openToken, EmbeddedSyntaxToken`1<RegexKind> firstCaptureToken, EmbeddedSyntaxToken`1<RegexKind> minusToken, EmbeddedSyntaxToken`1<RegexKind> secondCaptureToken, EmbeddedSyntaxToken`1<RegexKind> closeToken, RegexExpressionNode expression, EmbeddedSyntaxToken`1<RegexKind> closeParenToken);
    [CompilerGeneratedAttribute]
public EmbeddedSyntaxToken`1<RegexKind> get_OpenToken();
    [CompilerGeneratedAttribute]
public EmbeddedSyntaxToken`1<RegexKind> get_FirstCaptureToken();
    [CompilerGeneratedAttribute]
public EmbeddedSyntaxToken`1<RegexKind> get_MinusToken();
    [CompilerGeneratedAttribute]
public EmbeddedSyntaxToken`1<RegexKind> get_SecondCaptureToken();
    [CompilerGeneratedAttribute]
public EmbeddedSyntaxToken`1<RegexKind> get_CloseToken();
    [CompilerGeneratedAttribute]
public RegexExpressionNode get_Expression();
    internal virtual int get_ChildCount();
    internal virtual EmbeddedSyntaxNodeOrToken`2<RegexKind, RegexNode> ChildAt(int index);
    public virtual void Accept(IRegexNodeVisitor visitor);
}
internal abstract class Microsoft.CodeAnalysis.EmbeddedLanguages.RegularExpressions.RegexBaseCharacterClassNode : RegexPrimaryExpressionNode {
    [CompilerGeneratedAttribute]
private EmbeddedSyntaxToken`1<RegexKind> <OpenBracketToken>k__BackingField;
    [CompilerGeneratedAttribute]
private RegexSequenceNode <Components>k__BackingField;
    [CompilerGeneratedAttribute]
private EmbeddedSyntaxToken`1<RegexKind> <CloseBracketToken>k__BackingField;
    public EmbeddedSyntaxToken`1<RegexKind> OpenBracketToken { get; }
    public RegexSequenceNode Components { get; }
    public EmbeddedSyntaxToken`1<RegexKind> CloseBracketToken { get; }
    protected RegexBaseCharacterClassNode(RegexKind kind, EmbeddedSyntaxToken`1<RegexKind> openBracketToken, RegexSequenceNode components, EmbeddedSyntaxToken`1<RegexKind> closeBracketToken);
    [CompilerGeneratedAttribute]
public EmbeddedSyntaxToken`1<RegexKind> get_OpenBracketToken();
    [CompilerGeneratedAttribute]
public RegexSequenceNode get_Components();
    [CompilerGeneratedAttribute]
public EmbeddedSyntaxToken`1<RegexKind> get_CloseBracketToken();
}
internal class Microsoft.CodeAnalysis.EmbeddedLanguages.RegularExpressions.RegexCaptureEscapeNode : RegexEscapeNode {
    [CompilerGeneratedAttribute]
private EmbeddedSyntaxToken`1<RegexKind> <OpenToken>k__BackingField;
    [CompilerGeneratedAttribute]
private EmbeddedSyntaxToken`1<RegexKind> <CaptureToken>k__BackingField;
    [CompilerGeneratedAttribute]
private EmbeddedSyntaxToken`1<RegexKind> <CloseToken>k__BackingField;
    internal int ChildCount { get; }
    public EmbeddedSyntaxToken`1<RegexKind> OpenToken { get; }
    public EmbeddedSyntaxToken`1<RegexKind> CaptureToken { get; }
    public EmbeddedSyntaxToken`1<RegexKind> CloseToken { get; }
    public RegexCaptureEscapeNode(EmbeddedSyntaxToken`1<RegexKind> backslashToken, EmbeddedSyntaxToken`1<RegexKind> openToken, EmbeddedSyntaxToken`1<RegexKind> captureToken, EmbeddedSyntaxToken`1<RegexKind> closeToken);
    internal virtual int get_ChildCount();
    [CompilerGeneratedAttribute]
public EmbeddedSyntaxToken`1<RegexKind> get_OpenToken();
    [CompilerGeneratedAttribute]
public EmbeddedSyntaxToken`1<RegexKind> get_CaptureToken();
    [CompilerGeneratedAttribute]
public EmbeddedSyntaxToken`1<RegexKind> get_CloseToken();
    internal virtual EmbeddedSyntaxNodeOrToken`2<RegexKind, RegexNode> ChildAt(int index);
    public virtual void Accept(IRegexNodeVisitor visitor);
}
internal class Microsoft.CodeAnalysis.EmbeddedLanguages.RegularExpressions.RegexCaptureGroupingNode : RegexQuestionGroupingNode {
    [CompilerGeneratedAttribute]
private EmbeddedSyntaxToken`1<RegexKind> <OpenToken>k__BackingField;
    [CompilerGeneratedAttribute]
private EmbeddedSyntaxToken`1<RegexKind> <CaptureToken>k__BackingField;
    [CompilerGeneratedAttribute]
private EmbeddedSyntaxToken`1<RegexKind> <CloseToken>k__BackingField;
    [CompilerGeneratedAttribute]
private RegexExpressionNode <Expression>k__BackingField;
    public EmbeddedSyntaxToken`1<RegexKind> OpenToken { get; }
    public EmbeddedSyntaxToken`1<RegexKind> CaptureToken { get; }
    public EmbeddedSyntaxToken`1<RegexKind> CloseToken { get; }
    public RegexExpressionNode Expression { get; }
    internal int ChildCount { get; }
    public RegexCaptureGroupingNode(EmbeddedSyntaxToken`1<RegexKind> openParenToken, EmbeddedSyntaxToken`1<RegexKind> questionToken, EmbeddedSyntaxToken`1<RegexKind> openToken, EmbeddedSyntaxToken`1<RegexKind> captureToken, EmbeddedSyntaxToken`1<RegexKind> closeToken, RegexExpressionNode expression, EmbeddedSyntaxToken`1<RegexKind> closeParenToken);
    [CompilerGeneratedAttribute]
public EmbeddedSyntaxToken`1<RegexKind> get_OpenToken();
    [CompilerGeneratedAttribute]
public EmbeddedSyntaxToken`1<RegexKind> get_CaptureToken();
    [CompilerGeneratedAttribute]
public EmbeddedSyntaxToken`1<RegexKind> get_CloseToken();
    [CompilerGeneratedAttribute]
public RegexExpressionNode get_Expression();
    internal virtual int get_ChildCount();
    internal virtual EmbeddedSyntaxNodeOrToken`2<RegexKind, RegexNode> ChildAt(int index);
    public virtual void Accept(IRegexNodeVisitor visitor);
}
internal class Microsoft.CodeAnalysis.EmbeddedLanguages.RegularExpressions.RegexCategoryEscapeNode : RegexEscapeNode {
    [CompilerGeneratedAttribute]
private EmbeddedSyntaxToken`1<RegexKind> <TypeToken>k__BackingField;
    [CompilerGeneratedAttribute]
private EmbeddedSyntaxToken`1<RegexKind> <OpenBraceToken>k__BackingField;
    [CompilerGeneratedAttribute]
private EmbeddedSyntaxToken`1<RegexKind> <CategoryToken>k__BackingField;
    [CompilerGeneratedAttribute]
private EmbeddedSyntaxToken`1<RegexKind> <CloseBraceToken>k__BackingField;
    public EmbeddedSyntaxToken`1<RegexKind> TypeToken { get; }
    public EmbeddedSyntaxToken`1<RegexKind> OpenBraceToken { get; }
    public EmbeddedSyntaxToken`1<RegexKind> CategoryToken { get; }
    public EmbeddedSyntaxToken`1<RegexKind> CloseBraceToken { get; }
    internal int ChildCount { get; }
    public RegexCategoryEscapeNode(EmbeddedSyntaxToken`1<RegexKind> backslashToken, EmbeddedSyntaxToken`1<RegexKind> typeToken, EmbeddedSyntaxToken`1<RegexKind> openBraceToken, EmbeddedSyntaxToken`1<RegexKind> categoryToken, EmbeddedSyntaxToken`1<RegexKind> closeBraceToken);
    [CompilerGeneratedAttribute]
public EmbeddedSyntaxToken`1<RegexKind> get_TypeToken();
    [CompilerGeneratedAttribute]
public EmbeddedSyntaxToken`1<RegexKind> get_OpenBraceToken();
    [CompilerGeneratedAttribute]
public EmbeddedSyntaxToken`1<RegexKind> get_CategoryToken();
    [CompilerGeneratedAttribute]
public EmbeddedSyntaxToken`1<RegexKind> get_CloseBraceToken();
    internal virtual int get_ChildCount();
    internal virtual EmbeddedSyntaxNodeOrToken`2<RegexKind, RegexNode> ChildAt(int index);
    public virtual void Accept(IRegexNodeVisitor visitor);
}
internal class Microsoft.CodeAnalysis.EmbeddedLanguages.RegularExpressions.RegexCharacterClassEscapeNode : RegexTypeEscapeNode {
    internal int ChildCount { get; }
    public RegexCharacterClassEscapeNode(EmbeddedSyntaxToken`1<RegexKind> backslashToken, EmbeddedSyntaxToken`1<RegexKind> typeToken);
    internal virtual int get_ChildCount();
    internal virtual EmbeddedSyntaxNodeOrToken`2<RegexKind, RegexNode> ChildAt(int index);
    public virtual void Accept(IRegexNodeVisitor visitor);
}
internal class Microsoft.CodeAnalysis.EmbeddedLanguages.RegularExpressions.RegexCharacterClassNode : RegexBaseCharacterClassNode {
    internal int ChildCount { get; }
    public RegexCharacterClassNode(EmbeddedSyntaxToken`1<RegexKind> openBracketToken, RegexSequenceNode components, EmbeddedSyntaxToken`1<RegexKind> closeBracketToken);
    internal virtual int get_ChildCount();
    internal virtual EmbeddedSyntaxNodeOrToken`2<RegexKind, RegexNode> ChildAt(int index);
    public virtual void Accept(IRegexNodeVisitor visitor);
}
internal class Microsoft.CodeAnalysis.EmbeddedLanguages.RegularExpressions.RegexCharacterClassRangeNode : RegexPrimaryExpressionNode {
    [CompilerGeneratedAttribute]
private RegexExpressionNode <Left>k__BackingField;
    [CompilerGeneratedAttribute]
private EmbeddedSyntaxToken`1<RegexKind> <MinusToken>k__BackingField;
    [CompilerGeneratedAttribute]
private RegexExpressionNode <Right>k__BackingField;
    public RegexExpressionNode Left { get; }
    public EmbeddedSyntaxToken`1<RegexKind> MinusToken { get; }
    public RegexExpressionNode Right { get; }
    internal int ChildCount { get; }
    public RegexCharacterClassRangeNode(RegexExpressionNode left, EmbeddedSyntaxToken`1<RegexKind> minusToken, RegexExpressionNode right);
    [CompilerGeneratedAttribute]
public RegexExpressionNode get_Left();
    [CompilerGeneratedAttribute]
public EmbeddedSyntaxToken`1<RegexKind> get_MinusToken();
    [CompilerGeneratedAttribute]
public RegexExpressionNode get_Right();
    internal virtual int get_ChildCount();
    internal virtual EmbeddedSyntaxNodeOrToken`2<RegexKind, RegexNode> ChildAt(int index);
    public virtual void Accept(IRegexNodeVisitor visitor);
}
internal class Microsoft.CodeAnalysis.EmbeddedLanguages.RegularExpressions.RegexCharacterClassSubtractionNode : RegexPrimaryExpressionNode {
    [CompilerGeneratedAttribute]
private EmbeddedSyntaxToken`1<RegexKind> <MinusToken>k__BackingField;
    [CompilerGeneratedAttribute]
private RegexBaseCharacterClassNode <CharacterClass>k__BackingField;
    public EmbeddedSyntaxToken`1<RegexKind> MinusToken { get; }
    public RegexBaseCharacterClassNode CharacterClass { get; }
    internal int ChildCount { get; }
    public RegexCharacterClassSubtractionNode(EmbeddedSyntaxToken`1<RegexKind> minusToken, RegexBaseCharacterClassNode characterClass);
    [CompilerGeneratedAttribute]
public EmbeddedSyntaxToken`1<RegexKind> get_MinusToken();
    [CompilerGeneratedAttribute]
public RegexBaseCharacterClassNode get_CharacterClass();
    internal virtual int get_ChildCount();
    internal virtual EmbeddedSyntaxNodeOrToken`2<RegexKind, RegexNode> ChildAt(int index);
    public virtual void Accept(IRegexNodeVisitor visitor);
}
internal static class Microsoft.CodeAnalysis.EmbeddedLanguages.RegularExpressions.RegexCharClass : object {
    private static int FLAGS;
    private static int SETLENGTH;
    private static int CATEGORYLENGTH;
    private static int SETSTART;
    private static short SpaceConst;
    private static short NotSpaceConst;
    private static char ZeroWidthJoiner;
    private static char ZeroWidthNonJoiner;
    private static string WordClass;
    [TupleElementNamesAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static Dictionary`2<string, ValueTuple`2<string, string>> EscapeCategories;
    private static RegexCharClass();
    public static bool IsEscapeCategory(string value);
    public static bool IsWordChar(VirtualChar r);
    internal static bool CharInClass(char ch, string set);
    internal static bool CharInClassRecursive(char ch, string set, int start);
    private static bool CharInClassInternal(char ch, string set, int start, int mySetLength, int myCategoryLength);
    private static bool CharInCategory(char ch, string set, int start, int mySetLength, int myCategoryLength);
    private static bool CharInCategoryGroup(UnicodeCategory chcategory, string category, Int32& i);
}
internal class Microsoft.CodeAnalysis.EmbeddedLanguages.RegularExpressions.RegexClosedNumericRangeQuantifierNode : RegexNumericQuantifierNode {
    [CompilerGeneratedAttribute]
private EmbeddedSyntaxToken`1<RegexKind> <CommaToken>k__BackingField;
    [CompilerGeneratedAttribute]
private EmbeddedSyntaxToken`1<RegexKind> <SecondNumberToken>k__BackingField;
    public EmbeddedSyntaxToken`1<RegexKind> CommaToken { get; }
    public EmbeddedSyntaxToken`1<RegexKind> SecondNumberToken { get; }
    internal int ChildCount { get; }
    public RegexClosedNumericRangeQuantifierNode(RegexPrimaryExpressionNode expression, EmbeddedSyntaxToken`1<RegexKind> openBraceToken, EmbeddedSyntaxToken`1<RegexKind> firstNumberToken, EmbeddedSyntaxToken`1<RegexKind> commaToken, EmbeddedSyntaxToken`1<RegexKind> secondNumberToken, EmbeddedSyntaxToken`1<RegexKind> closeBraceToken);
    [CompilerGeneratedAttribute]
public EmbeddedSyntaxToken`1<RegexKind> get_CommaToken();
    [CompilerGeneratedAttribute]
public EmbeddedSyntaxToken`1<RegexKind> get_SecondNumberToken();
    internal virtual int get_ChildCount();
    internal virtual EmbeddedSyntaxNodeOrToken`2<RegexKind, RegexNode> ChildAt(int index);
    public virtual void Accept(IRegexNodeVisitor visitor);
}
internal class Microsoft.CodeAnalysis.EmbeddedLanguages.RegularExpressions.RegexCompilationUnit : RegexNode {
    [CompilerGeneratedAttribute]
private RegexExpressionNode <Expression>k__BackingField;
    [CompilerGeneratedAttribute]
private EmbeddedSyntaxToken`1<RegexKind> <EndOfFileToken>k__BackingField;
    public RegexExpressionNode Expression { get; }
    public EmbeddedSyntaxToken`1<RegexKind> EndOfFileToken { get; }
    internal int ChildCount { get; }
    public RegexCompilationUnit(RegexExpressionNode expression, EmbeddedSyntaxToken`1<RegexKind> endOfFileToken);
    [CompilerGeneratedAttribute]
public RegexExpressionNode get_Expression();
    [CompilerGeneratedAttribute]
public EmbeddedSyntaxToken`1<RegexKind> get_EndOfFileToken();
    internal virtual int get_ChildCount();
    internal virtual EmbeddedSyntaxNodeOrToken`2<RegexKind, RegexNode> ChildAt(int index);
    public virtual void Accept(IRegexNodeVisitor visitor);
}
internal class Microsoft.CodeAnalysis.EmbeddedLanguages.RegularExpressions.RegexConditionalCaptureGroupingNode : RegexConditionalGroupingNode {
    [CompilerGeneratedAttribute]
private EmbeddedSyntaxToken`1<RegexKind> <InnerOpenParenToken>k__BackingField;
    [CompilerGeneratedAttribute]
private EmbeddedSyntaxToken`1<RegexKind> <CaptureToken>k__BackingField;
    [CompilerGeneratedAttribute]
private EmbeddedSyntaxToken`1<RegexKind> <InnerCloseParenToken>k__BackingField;
    public EmbeddedSyntaxToken`1<RegexKind> InnerOpenParenToken { get; }
    public EmbeddedSyntaxToken`1<RegexKind> CaptureToken { get; }
    public EmbeddedSyntaxToken`1<RegexKind> InnerCloseParenToken { get; }
    internal int ChildCount { get; }
    public RegexConditionalCaptureGroupingNode(EmbeddedSyntaxToken`1<RegexKind> openParenToken, EmbeddedSyntaxToken`1<RegexKind> questionToken, EmbeddedSyntaxToken`1<RegexKind> innerOpenParenToken, EmbeddedSyntaxToken`1<RegexKind> captureToken, EmbeddedSyntaxToken`1<RegexKind> innerCloseParenToken, RegexExpressionNode result, EmbeddedSyntaxToken`1<RegexKind> closeParenToken);
    [CompilerGeneratedAttribute]
public EmbeddedSyntaxToken`1<RegexKind> get_InnerOpenParenToken();
    [CompilerGeneratedAttribute]
public EmbeddedSyntaxToken`1<RegexKind> get_CaptureToken();
    [CompilerGeneratedAttribute]
public EmbeddedSyntaxToken`1<RegexKind> get_InnerCloseParenToken();
    internal virtual int get_ChildCount();
    internal virtual EmbeddedSyntaxNodeOrToken`2<RegexKind, RegexNode> ChildAt(int index);
    public virtual void Accept(IRegexNodeVisitor visitor);
}
internal class Microsoft.CodeAnalysis.EmbeddedLanguages.RegularExpressions.RegexConditionalExpressionGroupingNode : RegexConditionalGroupingNode {
    [CompilerGeneratedAttribute]
private RegexGroupingNode <Grouping>k__BackingField;
    internal int ChildCount { get; }
    public RegexGroupingNode Grouping { get; }
    public RegexConditionalExpressionGroupingNode(EmbeddedSyntaxToken`1<RegexKind> openParenToken, EmbeddedSyntaxToken`1<RegexKind> questionToken, RegexGroupingNode grouping, RegexExpressionNode result, EmbeddedSyntaxToken`1<RegexKind> closeParenToken);
    internal virtual int get_ChildCount();
    [CompilerGeneratedAttribute]
public RegexGroupingNode get_Grouping();
    internal virtual EmbeddedSyntaxNodeOrToken`2<RegexKind, RegexNode> ChildAt(int index);
    public virtual void Accept(IRegexNodeVisitor visitor);
}
internal abstract class Microsoft.CodeAnalysis.EmbeddedLanguages.RegularExpressions.RegexConditionalGroupingNode : RegexQuestionGroupingNode {
    [CompilerGeneratedAttribute]
private RegexExpressionNode <Result>k__BackingField;
    public RegexExpressionNode Result { get; }
    protected RegexConditionalGroupingNode(RegexKind kind, EmbeddedSyntaxToken`1<RegexKind> openParenToken, EmbeddedSyntaxToken`1<RegexKind> questionToken, RegexExpressionNode result, EmbeddedSyntaxToken`1<RegexKind> closeParenToken);
    [CompilerGeneratedAttribute]
public RegexExpressionNode get_Result();
}
internal class Microsoft.CodeAnalysis.EmbeddedLanguages.RegularExpressions.RegexControlEscapeNode : RegexTypeEscapeNode {
    [CompilerGeneratedAttribute]
private EmbeddedSyntaxToken`1<RegexKind> <ControlToken>k__BackingField;
    internal int ChildCount { get; }
    public EmbeddedSyntaxToken`1<RegexKind> ControlToken { get; }
    public RegexControlEscapeNode(EmbeddedSyntaxToken`1<RegexKind> backslashToken, EmbeddedSyntaxToken`1<RegexKind> typeToken, EmbeddedSyntaxToken`1<RegexKind> controlToken);
    internal virtual int get_ChildCount();
    [CompilerGeneratedAttribute]
public EmbeddedSyntaxToken`1<RegexKind> get_ControlToken();
    internal virtual EmbeddedSyntaxNodeOrToken`2<RegexKind, RegexNode> ChildAt(int index);
    public virtual void Accept(IRegexNodeVisitor visitor);
}
internal abstract class Microsoft.CodeAnalysis.EmbeddedLanguages.RegularExpressions.RegexEscapeNode : RegexPrimaryExpressionNode {
    [CompilerGeneratedAttribute]
private EmbeddedSyntaxToken`1<RegexKind> <BackslashToken>k__BackingField;
    public EmbeddedSyntaxToken`1<RegexKind> BackslashToken { get; }
    protected RegexEscapeNode(RegexKind kind, EmbeddedSyntaxToken`1<RegexKind> backslashToken);
    [CompilerGeneratedAttribute]
public EmbeddedSyntaxToken`1<RegexKind> get_BackslashToken();
}
internal class Microsoft.CodeAnalysis.EmbeddedLanguages.RegularExpressions.RegexExactNumericQuantifierNode : RegexNumericQuantifierNode {
    internal int ChildCount { get; }
    public RegexExactNumericQuantifierNode(RegexPrimaryExpressionNode expression, EmbeddedSyntaxToken`1<RegexKind> openBraceToken, EmbeddedSyntaxToken`1<RegexKind> numberToken, EmbeddedSyntaxToken`1<RegexKind> closeBraceToken);
    internal virtual int get_ChildCount();
    internal virtual EmbeddedSyntaxNodeOrToken`2<RegexKind, RegexNode> ChildAt(int index);
    public virtual void Accept(IRegexNodeVisitor visitor);
}
internal abstract class Microsoft.CodeAnalysis.EmbeddedLanguages.RegularExpressions.RegexExpressionNode : RegexNode {
    protected RegexExpressionNode(RegexKind kind);
}
internal abstract class Microsoft.CodeAnalysis.EmbeddedLanguages.RegularExpressions.RegexGroupingNode : RegexPrimaryExpressionNode {
    [CompilerGeneratedAttribute]
private EmbeddedSyntaxToken`1<RegexKind> <OpenParenToken>k__BackingField;
    [CompilerGeneratedAttribute]
private EmbeddedSyntaxToken`1<RegexKind> <CloseParenToken>k__BackingField;
    public EmbeddedSyntaxToken`1<RegexKind> OpenParenToken { get; }
    public EmbeddedSyntaxToken`1<RegexKind> CloseParenToken { get; }
    protected RegexGroupingNode(RegexKind kind, EmbeddedSyntaxToken`1<RegexKind> openParenToken, EmbeddedSyntaxToken`1<RegexKind> closeParenToken);
    [CompilerGeneratedAttribute]
public EmbeddedSyntaxToken`1<RegexKind> get_OpenParenToken();
    [CompilerGeneratedAttribute]
public EmbeddedSyntaxToken`1<RegexKind> get_CloseParenToken();
}
[ExtensionAttribute]
internal static class Microsoft.CodeAnalysis.EmbeddedLanguages.RegularExpressions.RegexHelpers : object {
    public static bool HasOption(RegexOptions options, RegexOptions val);
    public static EmbeddedSyntaxToken`1<RegexKind> CreateToken(RegexKind kind, ImmutableArray`1<EmbeddedSyntaxTrivia`1<RegexKind>> leadingTrivia, VirtualCharSequence virtualChars);
    public static EmbeddedSyntaxToken`1<RegexKind> CreateMissingToken(RegexKind kind);
    public static EmbeddedSyntaxTrivia`1<RegexKind> CreateTrivia(RegexKind kind, VirtualCharSequence virtualChars);
    public static EmbeddedSyntaxTrivia`1<RegexKind> CreateTrivia(RegexKind kind, VirtualCharSequence virtualChars, ImmutableArray`1<EmbeddedDiagnostic> diagnostics);
    public static VirtualChar MapEscapeChar(VirtualChar ch);
    [ExtensionAttribute]
public static bool IsSelfEscape(RegexSimpleEscapeNode node);
}
internal class Microsoft.CodeAnalysis.EmbeddedLanguages.RegularExpressions.RegexHexEscapeNode : RegexTypeEscapeNode {
    [CompilerGeneratedAttribute]
private EmbeddedSyntaxToken`1<RegexKind> <HexText>k__BackingField;
    internal int ChildCount { get; }
    public EmbeddedSyntaxToken`1<RegexKind> HexText { get; }
    public RegexHexEscapeNode(EmbeddedSyntaxToken`1<RegexKind> backslashToken, EmbeddedSyntaxToken`1<RegexKind> typeToken, EmbeddedSyntaxToken`1<RegexKind> hexText);
    internal virtual int get_ChildCount();
    [CompilerGeneratedAttribute]
public EmbeddedSyntaxToken`1<RegexKind> get_HexText();
    internal virtual EmbeddedSyntaxNodeOrToken`2<RegexKind, RegexNode> ChildAt(int index);
    public virtual void Accept(IRegexNodeVisitor visitor);
}
internal class Microsoft.CodeAnalysis.EmbeddedLanguages.RegularExpressions.RegexKCaptureEscapeNode : RegexTypeEscapeNode {
    [CompilerGeneratedAttribute]
private EmbeddedSyntaxToken`1<RegexKind> <OpenToken>k__BackingField;
    [CompilerGeneratedAttribute]
private EmbeddedSyntaxToken`1<RegexKind> <CaptureToken>k__BackingField;
    [CompilerGeneratedAttribute]
private EmbeddedSyntaxToken`1<RegexKind> <CloseToken>k__BackingField;
    internal int ChildCount { get; }
    public EmbeddedSyntaxToken`1<RegexKind> OpenToken { get; }
    public EmbeddedSyntaxToken`1<RegexKind> CaptureToken { get; }
    public EmbeddedSyntaxToken`1<RegexKind> CloseToken { get; }
    public RegexKCaptureEscapeNode(EmbeddedSyntaxToken`1<RegexKind> backslashToken, EmbeddedSyntaxToken`1<RegexKind> typeToken, EmbeddedSyntaxToken`1<RegexKind> openToken, EmbeddedSyntaxToken`1<RegexKind> captureToken, EmbeddedSyntaxToken`1<RegexKind> closeToken);
    internal virtual int get_ChildCount();
    [CompilerGeneratedAttribute]
public EmbeddedSyntaxToken`1<RegexKind> get_OpenToken();
    [CompilerGeneratedAttribute]
public EmbeddedSyntaxToken`1<RegexKind> get_CaptureToken();
    [CompilerGeneratedAttribute]
public EmbeddedSyntaxToken`1<RegexKind> get_CloseToken();
    internal virtual EmbeddedSyntaxNodeOrToken`2<RegexKind, RegexNode> ChildAt(int index);
    public virtual void Accept(IRegexNodeVisitor visitor);
}
internal enum Microsoft.CodeAnalysis.EmbeddedLanguages.RegularExpressions.RegexKind : Enum {
    public int value__;
    public static RegexKind None;
    public static RegexKind EndOfFile;
    public static RegexKind Sequence;
    public static RegexKind CompilationUnit;
    public static RegexKind Text;
    public static RegexKind StartAnchor;
    public static RegexKind EndAnchor;
    public static RegexKind Alternation;
    public static RegexKind Wildcard;
    public static RegexKind CharacterClass;
    public static RegexKind NegatedCharacterClass;
    public static RegexKind CharacterClassRange;
    public static RegexKind CharacterClassSubtraction;
    public static RegexKind PosixProperty;
    public static RegexKind ZeroOrMoreQuantifier;
    public static RegexKind OneOrMoreQuantifier;
    public static RegexKind ZeroOrOneQuantifier;
    public static RegexKind ExactNumericQuantifier;
    public static RegexKind OpenRangeNumericQuantifier;
    public static RegexKind ClosedRangeNumericQuantifier;
    public static RegexKind LazyQuantifier;
    public static RegexKind SimpleGrouping;
    public static RegexKind SimpleOptionsGrouping;
    public static RegexKind NestedOptionsGrouping;
    public static RegexKind NonCapturingGrouping;
    public static RegexKind PositiveLookaheadGrouping;
    public static RegexKind NegativeLookaheadGrouping;
    public static RegexKind PositiveLookbehindGrouping;
    public static RegexKind NegativeLookbehindGrouping;
    public static RegexKind AtomicGrouping;
    public static RegexKind CaptureGrouping;
    public static RegexKind BalancingGrouping;
    public static RegexKind ConditionalCaptureGrouping;
    public static RegexKind ConditionalExpressionGrouping;
    public static RegexKind SimpleEscape;
    public static RegexKind AnchorEscape;
    public static RegexKind CharacterClassEscape;
    public static RegexKind CategoryEscape;
    public static RegexKind ControlEscape;
    public static RegexKind HexEscape;
    public static RegexKind UnicodeEscape;
    public static RegexKind OctalEscape;
    public static RegexKind CaptureEscape;
    public static RegexKind KCaptureEscape;
    public static RegexKind BackreferenceEscape;
    public static RegexKind DollarToken;
    public static RegexKind OpenBraceToken;
    public static RegexKind CloseBraceToken;
    public static RegexKind OpenBracketToken;
    public static RegexKind CloseBracketToken;
    public static RegexKind OpenParenToken;
    public static RegexKind CloseParenToken;
    public static RegexKind BarToken;
    public static RegexKind DotToken;
    public static RegexKind CaretToken;
    public static RegexKind TextToken;
    public static RegexKind QuestionToken;
    public static RegexKind AsteriskToken;
    public static RegexKind PlusToken;
    public static RegexKind CommaToken;
    public static RegexKind BackslashToken;
    public static RegexKind ColonToken;
    public static RegexKind EqualsToken;
    public static RegexKind ExclamationToken;
    public static RegexKind GreaterThanToken;
    public static RegexKind LessThanToken;
    public static RegexKind MinusToken;
    public static RegexKind SingleQuoteToken;
    public static RegexKind OptionsToken;
    public static RegexKind NumberToken;
    public static RegexKind CaptureNameToken;
    public static RegexKind EscapeCategoryToken;
    public static RegexKind CommentTrivia;
    public static RegexKind WhitespaceTrivia;
}
internal class Microsoft.CodeAnalysis.EmbeddedLanguages.RegularExpressions.RegexLazyQuantifierNode : RegexExpressionNode {
    [CompilerGeneratedAttribute]
private RegexQuantifierNode <Quantifier>k__BackingField;
    [CompilerGeneratedAttribute]
private EmbeddedSyntaxToken`1<RegexKind> <QuestionToken>k__BackingField;
    public RegexQuantifierNode Quantifier { get; }
    public EmbeddedSyntaxToken`1<RegexKind> QuestionToken { get; }
    internal int ChildCount { get; }
    public RegexLazyQuantifierNode(RegexQuantifierNode quantifier, EmbeddedSyntaxToken`1<RegexKind> questionToken);
    [CompilerGeneratedAttribute]
public RegexQuantifierNode get_Quantifier();
    [CompilerGeneratedAttribute]
public EmbeddedSyntaxToken`1<RegexKind> get_QuestionToken();
    internal virtual int get_ChildCount();
    internal virtual EmbeddedSyntaxNodeOrToken`2<RegexKind, RegexNode> ChildAt(int index);
    public virtual void Accept(IRegexNodeVisitor visitor);
}
internal class Microsoft.CodeAnalysis.EmbeddedLanguages.RegularExpressions.RegexLexer : ValueType {
    public VirtualCharSequence Text;
    public int Position;
    public VirtualChar CurrentChar { get; }
    public RegexLexer(VirtualCharSequence text);
    public VirtualChar get_CurrentChar();
    public VirtualCharSequence GetSubPatternToCurrentPos(int start);
    public VirtualCharSequence GetSubPattern(int start, int end);
    public EmbeddedSyntaxToken`1<RegexKind> ScanNextToken(bool allowTrivia, RegexOptions options);
    private static RegexKind GetKind(VirtualChar ch);
    private ImmutableArray`1<EmbeddedSyntaxTrivia`1<RegexKind>> ScanLeadingTrivia(bool allowTrivia, RegexOptions options);
    public Nullable`1<EmbeddedSyntaxTrivia`1<RegexKind>> ScanComment(RegexOptions options);
    public TextSpan GetTextSpan(int startInclusive, int endExclusive);
    public bool IsAt(string val);
    private bool TextAt(int position, string val);
    private Nullable`1<EmbeddedSyntaxTrivia`1<RegexKind>> ScanWhitespace(RegexOptions options);
    private static bool IsBlank(VirtualChar ch);
    public Nullable`1<EmbeddedSyntaxToken`1<RegexKind>> TryScanEscapeCategory();
    private static bool IsEscapeCategoryChar(VirtualChar ch);
    public Nullable`1<EmbeddedSyntaxToken`1<RegexKind>> TryScanNumber();
    public Nullable`1<EmbeddedSyntaxToken`1<RegexKind>> TryScanCaptureName();
    public Nullable`1<EmbeddedSyntaxToken`1<RegexKind>> TryScanNumberOrCaptureName();
    public Nullable`1<EmbeddedSyntaxToken`1<RegexKind>> TryScanOptions();
    private static bool IsOptionChar(VirtualChar ch);
    public EmbeddedSyntaxToken`1<RegexKind> ScanHexCharacters(int count);
    public static bool IsHexChar(VirtualChar ch);
    private static bool IsDecimalDigit(VirtualChar ch);
    private static bool IsOctalDigit(VirtualChar ch);
    public EmbeddedSyntaxToken`1<RegexKind> ScanOctalCharacters(RegexOptions options);
}
internal abstract class Microsoft.CodeAnalysis.EmbeddedLanguages.RegularExpressions.RegexLookbehindGroupingNode : RegexQuestionGroupingNode {
    [CompilerGeneratedAttribute]
private EmbeddedSyntaxToken`1<RegexKind> <LessThanToken>k__BackingField;
    public EmbeddedSyntaxToken`1<RegexKind> LessThanToken { get; }
    protected RegexLookbehindGroupingNode(RegexKind kind, EmbeddedSyntaxToken`1<RegexKind> openParenToken, EmbeddedSyntaxToken`1<RegexKind> questionToken, EmbeddedSyntaxToken`1<RegexKind> lessThanToken, EmbeddedSyntaxToken`1<RegexKind> closeParenToken);
    [CompilerGeneratedAttribute]
public EmbeddedSyntaxToken`1<RegexKind> get_LessThanToken();
}
internal class Microsoft.CodeAnalysis.EmbeddedLanguages.RegularExpressions.RegexNegatedCharacterClassNode : RegexBaseCharacterClassNode {
    [CompilerGeneratedAttribute]
private EmbeddedSyntaxToken`1<RegexKind> <CaretToken>k__BackingField;
    public EmbeddedSyntaxToken`1<RegexKind> CaretToken { get; }
    internal int ChildCount { get; }
    public RegexNegatedCharacterClassNode(EmbeddedSyntaxToken`1<RegexKind> openBracketToken, EmbeddedSyntaxToken`1<RegexKind> caretToken, RegexSequenceNode components, EmbeddedSyntaxToken`1<RegexKind> closeBracketToken);
    [CompilerGeneratedAttribute]
public EmbeddedSyntaxToken`1<RegexKind> get_CaretToken();
    internal virtual int get_ChildCount();
    internal virtual EmbeddedSyntaxNodeOrToken`2<RegexKind, RegexNode> ChildAt(int index);
    public virtual void Accept(IRegexNodeVisitor visitor);
}
internal class Microsoft.CodeAnalysis.EmbeddedLanguages.RegularExpressions.RegexNegativeLookaheadGroupingNode : RegexQuestionGroupingNode {
    [CompilerGeneratedAttribute]
private EmbeddedSyntaxToken`1<RegexKind> <ExclamationToken>k__BackingField;
    [CompilerGeneratedAttribute]
private RegexExpressionNode <Expression>k__BackingField;
    public EmbeddedSyntaxToken`1<RegexKind> ExclamationToken { get; }
    public RegexExpressionNode Expression { get; }
    internal int ChildCount { get; }
    public RegexNegativeLookaheadGroupingNode(EmbeddedSyntaxToken`1<RegexKind> openParenToken, EmbeddedSyntaxToken`1<RegexKind> questionToken, EmbeddedSyntaxToken`1<RegexKind> exclamationToken, RegexExpressionNode expression, EmbeddedSyntaxToken`1<RegexKind> closeParenToken);
    [CompilerGeneratedAttribute]
public EmbeddedSyntaxToken`1<RegexKind> get_ExclamationToken();
    [CompilerGeneratedAttribute]
public RegexExpressionNode get_Expression();
    internal virtual int get_ChildCount();
    internal virtual EmbeddedSyntaxNodeOrToken`2<RegexKind, RegexNode> ChildAt(int index);
    public virtual void Accept(IRegexNodeVisitor visitor);
}
internal class Microsoft.CodeAnalysis.EmbeddedLanguages.RegularExpressions.RegexNegativeLookbehindGroupingNode : RegexLookbehindGroupingNode {
    [CompilerGeneratedAttribute]
private EmbeddedSyntaxToken`1<RegexKind> <ExclamationToken>k__BackingField;
    [CompilerGeneratedAttribute]
private RegexExpressionNode <Expression>k__BackingField;
    public EmbeddedSyntaxToken`1<RegexKind> ExclamationToken { get; }
    public RegexExpressionNode Expression { get; }
    internal int ChildCount { get; }
    public RegexNegativeLookbehindGroupingNode(EmbeddedSyntaxToken`1<RegexKind> openParenToken, EmbeddedSyntaxToken`1<RegexKind> questionToken, EmbeddedSyntaxToken`1<RegexKind> lessThanToken, EmbeddedSyntaxToken`1<RegexKind> exclamationToken, RegexExpressionNode expression, EmbeddedSyntaxToken`1<RegexKind> closeParenToken);
    [CompilerGeneratedAttribute]
public EmbeddedSyntaxToken`1<RegexKind> get_ExclamationToken();
    [CompilerGeneratedAttribute]
public RegexExpressionNode get_Expression();
    internal virtual int get_ChildCount();
    internal virtual EmbeddedSyntaxNodeOrToken`2<RegexKind, RegexNode> ChildAt(int index);
    public virtual void Accept(IRegexNodeVisitor visitor);
}
internal class Microsoft.CodeAnalysis.EmbeddedLanguages.RegularExpressions.RegexNestedOptionsGroupingNode : RegexOptionsGroupingNode {
    [CompilerGeneratedAttribute]
private EmbeddedSyntaxToken`1<RegexKind> <ColonToken>k__BackingField;
    [CompilerGeneratedAttribute]
private RegexExpressionNode <Expression>k__BackingField;
    public EmbeddedSyntaxToken`1<RegexKind> ColonToken { get; }
    public RegexExpressionNode Expression { get; }
    internal int ChildCount { get; }
    public RegexNestedOptionsGroupingNode(EmbeddedSyntaxToken`1<RegexKind> openParenToken, EmbeddedSyntaxToken`1<RegexKind> questionToken, EmbeddedSyntaxToken`1<RegexKind> optionsToken, EmbeddedSyntaxToken`1<RegexKind> colonToken, RegexExpressionNode expression, EmbeddedSyntaxToken`1<RegexKind> closeParenToken);
    [CompilerGeneratedAttribute]
public EmbeddedSyntaxToken`1<RegexKind> get_ColonToken();
    [CompilerGeneratedAttribute]
public RegexExpressionNode get_Expression();
    internal virtual int get_ChildCount();
    internal virtual EmbeddedSyntaxNodeOrToken`2<RegexKind, RegexNode> ChildAt(int index);
    public virtual void Accept(IRegexNodeVisitor visitor);
}
internal abstract class Microsoft.CodeAnalysis.EmbeddedLanguages.RegularExpressions.RegexNode : EmbeddedSyntaxNode`2<RegexKind, RegexNode> {
    protected RegexNode(RegexKind kind);
    public abstract virtual void Accept(IRegexNodeVisitor visitor);
}
internal class Microsoft.CodeAnalysis.EmbeddedLanguages.RegularExpressions.RegexNonCapturingGroupingNode : RegexQuestionGroupingNode {
    [CompilerGeneratedAttribute]
private EmbeddedSyntaxToken`1<RegexKind> <ColonToken>k__BackingField;
    [CompilerGeneratedAttribute]
private RegexExpressionNode <Expression>k__BackingField;
    public EmbeddedSyntaxToken`1<RegexKind> ColonToken { get; }
    public RegexExpressionNode Expression { get; }
    internal int ChildCount { get; }
    public RegexNonCapturingGroupingNode(EmbeddedSyntaxToken`1<RegexKind> openParenToken, EmbeddedSyntaxToken`1<RegexKind> questionToken, EmbeddedSyntaxToken`1<RegexKind> colonToken, RegexExpressionNode expression, EmbeddedSyntaxToken`1<RegexKind> closeParenToken);
    [CompilerGeneratedAttribute]
public EmbeddedSyntaxToken`1<RegexKind> get_ColonToken();
    [CompilerGeneratedAttribute]
public RegexExpressionNode get_Expression();
    internal virtual int get_ChildCount();
    internal virtual EmbeddedSyntaxNodeOrToken`2<RegexKind, RegexNode> ChildAt(int index);
    public virtual void Accept(IRegexNodeVisitor visitor);
}
internal abstract class Microsoft.CodeAnalysis.EmbeddedLanguages.RegularExpressions.RegexNumericQuantifierNode : RegexQuantifierNode {
    [CompilerGeneratedAttribute]
private RegexExpressionNode <Expression>k__BackingField;
    [CompilerGeneratedAttribute]
private EmbeddedSyntaxToken`1<RegexKind> <OpenBraceToken>k__BackingField;
    [CompilerGeneratedAttribute]
private EmbeddedSyntaxToken`1<RegexKind> <FirstNumberToken>k__BackingField;
    [CompilerGeneratedAttribute]
private EmbeddedSyntaxToken`1<RegexKind> <CloseBraceToken>k__BackingField;
    public RegexExpressionNode Expression { get; }
    public EmbeddedSyntaxToken`1<RegexKind> OpenBraceToken { get; }
    public EmbeddedSyntaxToken`1<RegexKind> FirstNumberToken { get; }
    public EmbeddedSyntaxToken`1<RegexKind> CloseBraceToken { get; }
    protected RegexNumericQuantifierNode(RegexKind kind, RegexPrimaryExpressionNode expression, EmbeddedSyntaxToken`1<RegexKind> openBraceToken, EmbeddedSyntaxToken`1<RegexKind> firstNumberToken, EmbeddedSyntaxToken`1<RegexKind> closeBraceToken);
    [CompilerGeneratedAttribute]
public RegexExpressionNode get_Expression();
    [CompilerGeneratedAttribute]
public EmbeddedSyntaxToken`1<RegexKind> get_OpenBraceToken();
    [CompilerGeneratedAttribute]
public EmbeddedSyntaxToken`1<RegexKind> get_FirstNumberToken();
    [CompilerGeneratedAttribute]
public EmbeddedSyntaxToken`1<RegexKind> get_CloseBraceToken();
}
internal class Microsoft.CodeAnalysis.EmbeddedLanguages.RegularExpressions.RegexOctalEscapeNode : RegexEscapeNode {
    [CompilerGeneratedAttribute]
private EmbeddedSyntaxToken`1<RegexKind> <OctalText>k__BackingField;
    internal int ChildCount { get; }
    public EmbeddedSyntaxToken`1<RegexKind> OctalText { get; }
    public RegexOctalEscapeNode(EmbeddedSyntaxToken`1<RegexKind> backslashToken, EmbeddedSyntaxToken`1<RegexKind> octalText);
    internal virtual int get_ChildCount();
    [CompilerGeneratedAttribute]
public EmbeddedSyntaxToken`1<RegexKind> get_OctalText();
    internal virtual EmbeddedSyntaxNodeOrToken`2<RegexKind, RegexNode> ChildAt(int index);
    public virtual void Accept(IRegexNodeVisitor visitor);
}
internal class Microsoft.CodeAnalysis.EmbeddedLanguages.RegularExpressions.RegexOneOrMoreQuantifierNode : RegexQuantifierNode {
    [CompilerGeneratedAttribute]
private RegexExpressionNode <Expression>k__BackingField;
    [CompilerGeneratedAttribute]
private EmbeddedSyntaxToken`1<RegexKind> <PlusToken>k__BackingField;
    public RegexExpressionNode Expression { get; }
    public EmbeddedSyntaxToken`1<RegexKind> PlusToken { get; }
    internal int ChildCount { get; }
    public RegexOneOrMoreQuantifierNode(RegexExpressionNode expression, EmbeddedSyntaxToken`1<RegexKind> plusToken);
    [CompilerGeneratedAttribute]
public RegexExpressionNode get_Expression();
    [CompilerGeneratedAttribute]
public EmbeddedSyntaxToken`1<RegexKind> get_PlusToken();
    internal virtual int get_ChildCount();
    internal virtual EmbeddedSyntaxNodeOrToken`2<RegexKind, RegexNode> ChildAt(int index);
    public virtual void Accept(IRegexNodeVisitor visitor);
}
internal class Microsoft.CodeAnalysis.EmbeddedLanguages.RegularExpressions.RegexOpenNumericRangeQuantifierNode : RegexNumericQuantifierNode {
    [CompilerGeneratedAttribute]
private EmbeddedSyntaxToken`1<RegexKind> <CommaToken>k__BackingField;
    public EmbeddedSyntaxToken`1<RegexKind> CommaToken { get; }
    internal int ChildCount { get; }
    public RegexOpenNumericRangeQuantifierNode(RegexPrimaryExpressionNode expression, EmbeddedSyntaxToken`1<RegexKind> openBraceToken, EmbeddedSyntaxToken`1<RegexKind> firstNumberToken, EmbeddedSyntaxToken`1<RegexKind> commaToken, EmbeddedSyntaxToken`1<RegexKind> closeBraceToken);
    [CompilerGeneratedAttribute]
public EmbeddedSyntaxToken`1<RegexKind> get_CommaToken();
    internal virtual int get_ChildCount();
    internal virtual EmbeddedSyntaxNodeOrToken`2<RegexKind, RegexNode> ChildAt(int index);
    public virtual void Accept(IRegexNodeVisitor visitor);
}
internal abstract class Microsoft.CodeAnalysis.EmbeddedLanguages.RegularExpressions.RegexOptionsGroupingNode : RegexQuestionGroupingNode {
    [CompilerGeneratedAttribute]
private EmbeddedSyntaxToken`1<RegexKind> <OptionsToken>k__BackingField;
    public EmbeddedSyntaxToken`1<RegexKind> OptionsToken { get; }
    protected RegexOptionsGroupingNode(RegexKind kind, EmbeddedSyntaxToken`1<RegexKind> openParenToken, EmbeddedSyntaxToken`1<RegexKind> questionToken, EmbeddedSyntaxToken`1<RegexKind> optionsToken, EmbeddedSyntaxToken`1<RegexKind> closeParenToken);
    [CompilerGeneratedAttribute]
public EmbeddedSyntaxToken`1<RegexKind> get_OptionsToken();
}
internal class Microsoft.CodeAnalysis.EmbeddedLanguages.RegularExpressions.RegexParser : ValueType {
    private ImmutableDictionary`2<string, TextSpan> _captureNamesToSpan;
    private ImmutableDictionary`2<int, TextSpan> _captureNumbersToSpan;
    private RegexLexer _lexer;
    private RegexOptions _options;
    private EmbeddedSyntaxToken`1<RegexKind> _currentToken;
    private int _recursionDepth;
    private RegexParser(VirtualCharSequence text, RegexOptions options, ImmutableDictionary`2<string, TextSpan> captureNamesToSpan, ImmutableDictionary`2<int, TextSpan> captureNumbersToSpan);
    private EmbeddedSyntaxToken`1<RegexKind> ConsumeCurrentToken(bool allowTrivia);
    public static RegexTree TryParse(VirtualCharSequence text, RegexOptions options);
    private RegexTree ParseTree();
    private static void CollectDiagnostics(RegexNode node, HashSet`1<EmbeddedDiagnostic> seenDiagnostics, ArrayBuilder`1<EmbeddedDiagnostic> diagnostics);
    private static void AddUniqueDiagnostics(HashSet`1<EmbeddedDiagnostic> seenDiagnostics, ImmutableArray`1<EmbeddedDiagnostic> from, ArrayBuilder`1<EmbeddedDiagnostic> to);
    private RegexExpressionNode ParseAlternatingSequences(bool consumeCloseParen);
    private RegexExpressionNode ParseAlternatingSequencesWorker(bool consumeCloseParen);
    private RegexSequenceNode ParseSequence(bool consumeCloseParen);
    private static void MergeTextNodes(ArrayBuilder`1<RegexExpressionNode> list, ArrayBuilder`1<RegexExpressionNode> final);
    private bool ShouldConsumeSequenceElement(bool consumeCloseParen);
    private RegexExpressionNode ParsePrimaryExpressionAndQuantifiers(RegexExpressionNode lastExpression);
    private RegexExpressionNode TryParseLazyQuantifier(RegexQuantifierNode quantifier);
    private RegexExpressionNode ParseZeroOrMoreQuantifier(RegexPrimaryExpressionNode current);
    private RegexExpressionNode ParseOneOrMoreQuantifier(RegexPrimaryExpressionNode current);
    private RegexExpressionNode ParseZeroOrOneQuantifier(RegexPrimaryExpressionNode current);
    private RegexExpressionNode TryParseNumericQuantifier(RegexPrimaryExpressionNode expression, EmbeddedSyntaxToken`1<RegexKind> openBraceToken);
    private static RegexQuantifierNode CreateQuantifier(RegexPrimaryExpressionNode expression, EmbeddedSyntaxToken`1<RegexKind> openBraceToken, EmbeddedSyntaxToken`1<RegexKind> firstNumberToken, Nullable`1<EmbeddedSyntaxToken`1<RegexKind>> commaToken, Nullable`1<EmbeddedSyntaxToken`1<RegexKind>> secondNumberToken, EmbeddedSyntaxToken`1<RegexKind> closeBraceToken);
    private bool TryParseNumericQuantifierParts(EmbeddedSyntaxToken`1& firstNumberToken, Nullable`1& commaToken, Nullable`1& secondNumberToken, EmbeddedSyntaxToken`1& closeBraceToken);
    private void ResetToPositionAndConsumeCurrentToken(int position, bool allowTrivia);
    private RegexPrimaryExpressionNode ParsePrimaryExpression(RegexExpressionNode lastExpression);
    private RegexPrimaryExpressionNode ParsePossibleUnexpectedNumericQuantifier(RegexExpressionNode lastExpression);
    private RegexPrimaryExpressionNode ParseUnexpectedCloseParenToken();
    private RegexPrimaryExpressionNode ParseText();
    private RegexPrimaryExpressionNode ParseEndAnchor();
    private RegexPrimaryExpressionNode ParseStartAnchor();
    private RegexPrimaryExpressionNode ParseWildcard();
    private RegexGroupingNode ParseGrouping();
    private EmbeddedSyntaxToken`1<RegexKind> ParseGroupingCloseParen();
    private RegexSimpleGroupingNode ParseSimpleGroup(EmbeddedSyntaxToken`1<RegexKind> openParenToken);
    private RegexExpressionNode ParseGroupingEmbeddedExpression(RegexOptions embeddedOptions);
    private TextSpan GetTokenSpanIncludingEOF(EmbeddedSyntaxToken`1<RegexKind> token);
    private TextSpan GetTokenStartPositionSpan(EmbeddedSyntaxToken`1<RegexKind> token);
    private RegexGroupingNode ParseGroupQuestion(EmbeddedSyntaxToken`1<RegexKind> openParenToken, EmbeddedSyntaxToken`1<RegexKind> questionToken);
    private RegexConditionalGroupingNode ParseConditionalGrouping(EmbeddedSyntaxToken`1<RegexKind> openParenToken, EmbeddedSyntaxToken`1<RegexKind> questionToken);
    private bool HasCapture(int value);
    private bool HasCapture(string value);
    private void MoveBackBeforePreviousScan();
    private RegexConditionalGroupingNode ParseConditionalExpressionGrouping(EmbeddedSyntaxToken`1<RegexKind> openParenToken, EmbeddedSyntaxToken`1<RegexKind> questionToken);
    private RegexExpressionNode ParseConditionalGroupingResult();
    private static RegexExpressionNode CheckConditionalAlternation(RegexExpressionNode result);
    private RegexGroupingNode ParseLookbehindOrNamedCaptureOrBalancingGrouping(EmbeddedSyntaxToken`1<RegexKind> openParenToken, EmbeddedSyntaxToken`1<RegexKind> questionToken);
    private RegexGroupingNode ParseNamedCaptureOrBalancingGrouping(EmbeddedSyntaxToken`1<RegexKind> openParenToken, EmbeddedSyntaxToken`1<RegexKind> questionToken, EmbeddedSyntaxToken`1<RegexKind> openToken);
    private EmbeddedSyntaxToken`1<RegexKind> ParseCaptureGroupingCloseToken(EmbeddedSyntaxToken`1& openParenToken, EmbeddedSyntaxToken`1<RegexKind> openToken);
    private RegexBalancingGroupingNode ParseBalancingGrouping(EmbeddedSyntaxToken`1<RegexKind> openParenToken, EmbeddedSyntaxToken`1<RegexKind> questionToken, EmbeddedSyntaxToken`1<RegexKind> openToken, EmbeddedSyntaxToken`1<RegexKind> firstCapture);
    private void CheckCapture(EmbeddedSyntaxToken`1& captureToken);
    private RegexNonCapturingGroupingNode ParseNonCapturingGroupingNode(EmbeddedSyntaxToken`1<RegexKind> openParenToken, EmbeddedSyntaxToken`1<RegexKind> questionToken);
    private RegexPositiveLookaheadGroupingNode ParsePositiveLookaheadGrouping(EmbeddedSyntaxToken`1<RegexKind> openParenToken, EmbeddedSyntaxToken`1<RegexKind> questionToken);
    private RegexNegativeLookaheadGroupingNode ParseNegativeLookaheadGrouping(EmbeddedSyntaxToken`1<RegexKind> openParenToken, EmbeddedSyntaxToken`1<RegexKind> questionToken);
    private RegexAtomicGroupingNode ParseAtomicGrouping(EmbeddedSyntaxToken`1<RegexKind> openParenToken, EmbeddedSyntaxToken`1<RegexKind> questionToken);
    private RegexGroupingNode ParseOptionsGroupingNode(EmbeddedSyntaxToken`1<RegexKind> openParenToken, EmbeddedSyntaxToken`1<RegexKind> questionToken, EmbeddedSyntaxToken`1<RegexKind> optionsToken);
    private RegexNestedOptionsGroupingNode ParseNestedOptionsGroupingNode(EmbeddedSyntaxToken`1<RegexKind> openParenToken, EmbeddedSyntaxToken`1<RegexKind> questionToken, EmbeddedSyntaxToken`1<RegexKind> optionsToken);
    private static bool IsTextChar(EmbeddedSyntaxToken`1<RegexKind> currentToken, char ch);
    private static RegexOptions GetNewOptionsFromToken(RegexOptions currentOptions, EmbeddedSyntaxToken`1<RegexKind> optionsToken);
    private static RegexOptions OptionFromCode(VirtualChar ch);
    private RegexBaseCharacterClassNode ParseCharacterClass();
    private void ParseCharacterClassComponents(ArrayBuilder`1<RegexExpressionNode> components);
    private static bool IsEscapedMinus(RegexNode node);
    private bool TryGetRangeComponentValue(RegexExpressionNode component, Int32& ch);
    private bool TryGetRangeComponentValueWorker(RegexNode component, Int32& ch);
    private static int GetCharValue(EmbeddedSyntaxToken`1<RegexKind> hexText, int withBase);
    private static int HexValue(VirtualChar ch);
    private bool HasProblem(EmbeddedSyntaxNodeOrToken`2<RegexKind, RegexNode> component);
    private RegexPrimaryExpressionNode ParseSingleCharacterClassComponent(bool isFirst, bool afterRangeMinus);
    private RegexPrimaryExpressionNode ParseCharacterClassSubtractionNode(EmbeddedSyntaxToken`1<RegexKind> minusToken);
    private RegexEscapeNode ParseEscape(EmbeddedSyntaxToken`1<RegexKind> backslashToken, bool allowTriviaAfterEnd);
    private RegexEscapeNode ParseBasicBackslash(EmbeddedSyntaxToken`1<RegexKind> backslashToken, bool allowTriviaAfterEnd);
    private RegexEscapeNode ParsePossibleBackreferenceEscape(EmbeddedSyntaxToken`1<RegexKind> backslashToken, bool allowTriviaAfterEnd);
    private RegexEscapeNode ParsePossibleEcmascriptBackreferenceEscape(EmbeddedSyntaxToken`1<RegexKind> backslashToken, bool allowTriviaAfterEnd);
    private RegexEscapeNode ParsePossibleRegularBackreferenceEscape(EmbeddedSyntaxToken`1<RegexKind> backslashToken, bool allowTriviaAfterEnd);
    private RegexEscapeNode ParsePossibleCaptureEscape(EmbeddedSyntaxToken`1<RegexKind> backslashToken, bool allowTriviaAfterEnd);
    private RegexEscapeNode ParsePossibleKCaptureEscape(EmbeddedSyntaxToken`1<RegexKind> backslashToken, bool allowTriviaAfterEnd);
    private void ScanCaptureParts(bool allowTriviaAfterEnd, EmbeddedSyntaxToken`1& openToken, EmbeddedSyntaxToken`1& capture, EmbeddedSyntaxToken`1& closeToken);
    private RegexEscapeNode ParseCharEscape(EmbeddedSyntaxToken`1<RegexKind> backslashToken, bool allowTriviaAfterEnd);
    private RegexEscapeNode ParseUnicodeEscape(EmbeddedSyntaxToken`1<RegexKind> backslashToken, bool allowTriviaAfterEnd);
    private RegexEscapeNode ParseHexEscape(EmbeddedSyntaxToken`1<RegexKind> backslashToken, bool allowTriviaAfterEnd);
    private RegexControlEscapeNode ParseControlEscape(EmbeddedSyntaxToken`1<RegexKind> backslashToken, bool allowTriviaAfterEnd);
    private RegexEscapeNode ParseCategoryEscape(EmbeddedSyntaxToken`1<RegexKind> backslash, bool allowTriviaAfterEnd);
    private bool TryGetCategoryEscapeParts(bool allowTriviaAfterEnd, EmbeddedSyntaxToken`1& openBraceToken, EmbeddedSyntaxToken`1& categoryToken, EmbeddedSyntaxToken`1& closeBraceToken, String& message);
    private RegexTextNode ParseUnexpectedQuantifier(RegexExpressionNode lastExpression);
    private static void CheckQuantifierExpression(RegexExpressionNode current, EmbeddedSyntaxToken`1& token);
    [CompilerGeneratedAttribute]
internal static int <MergeTextNodes>g__MergeAndAddAdjacentTextNodes|16_0(ArrayBuilder`1<RegexExpressionNode> list, ArrayBuilder`1<RegexExpressionNode> final, int index);
    [CompilerGeneratedAttribute]
internal static bool <MergeTextNodes>g__CanMerge|16_1(RegexTextNode lastNode, RegexExpressionNode next);
}
internal class Microsoft.CodeAnalysis.EmbeddedLanguages.RegularExpressions.RegexPositiveLookaheadGroupingNode : RegexQuestionGroupingNode {
    [CompilerGeneratedAttribute]
private EmbeddedSyntaxToken`1<RegexKind> <EqualsToken>k__BackingField;
    [CompilerGeneratedAttribute]
private RegexExpressionNode <Expression>k__BackingField;
    public EmbeddedSyntaxToken`1<RegexKind> EqualsToken { get; }
    public RegexExpressionNode Expression { get; }
    internal int ChildCount { get; }
    public RegexPositiveLookaheadGroupingNode(EmbeddedSyntaxToken`1<RegexKind> openParenToken, EmbeddedSyntaxToken`1<RegexKind> questionToken, EmbeddedSyntaxToken`1<RegexKind> equalsToken, RegexExpressionNode expression, EmbeddedSyntaxToken`1<RegexKind> closeParenToken);
    [CompilerGeneratedAttribute]
public EmbeddedSyntaxToken`1<RegexKind> get_EqualsToken();
    [CompilerGeneratedAttribute]
public RegexExpressionNode get_Expression();
    internal virtual int get_ChildCount();
    internal virtual EmbeddedSyntaxNodeOrToken`2<RegexKind, RegexNode> ChildAt(int index);
    public virtual void Accept(IRegexNodeVisitor visitor);
}
internal class Microsoft.CodeAnalysis.EmbeddedLanguages.RegularExpressions.RegexPositiveLookbehindGroupingNode : RegexLookbehindGroupingNode {
    [CompilerGeneratedAttribute]
private EmbeddedSyntaxToken`1<RegexKind> <EqualsToken>k__BackingField;
    [CompilerGeneratedAttribute]
private RegexExpressionNode <Expression>k__BackingField;
    public EmbeddedSyntaxToken`1<RegexKind> EqualsToken { get; }
    public RegexExpressionNode Expression { get; }
    internal int ChildCount { get; }
    public RegexPositiveLookbehindGroupingNode(EmbeddedSyntaxToken`1<RegexKind> openParenToken, EmbeddedSyntaxToken`1<RegexKind> questionToken, EmbeddedSyntaxToken`1<RegexKind> lessThanToken, EmbeddedSyntaxToken`1<RegexKind> equalsToken, RegexExpressionNode expression, EmbeddedSyntaxToken`1<RegexKind> closeParenToken);
    [CompilerGeneratedAttribute]
public EmbeddedSyntaxToken`1<RegexKind> get_EqualsToken();
    [CompilerGeneratedAttribute]
public RegexExpressionNode get_Expression();
    internal virtual int get_ChildCount();
    internal virtual EmbeddedSyntaxNodeOrToken`2<RegexKind, RegexNode> ChildAt(int index);
    public virtual void Accept(IRegexNodeVisitor visitor);
}
internal class Microsoft.CodeAnalysis.EmbeddedLanguages.RegularExpressions.RegexPosixPropertyNode : RegexPrimaryExpressionNode {
    [CompilerGeneratedAttribute]
private EmbeddedSyntaxToken`1<RegexKind> <TextToken>k__BackingField;
    public EmbeddedSyntaxToken`1<RegexKind> TextToken { get; }
    internal int ChildCount { get; }
    public RegexPosixPropertyNode(EmbeddedSyntaxToken`1<RegexKind> textToken);
    [CompilerGeneratedAttribute]
public EmbeddedSyntaxToken`1<RegexKind> get_TextToken();
    internal virtual int get_ChildCount();
    internal virtual EmbeddedSyntaxNodeOrToken`2<RegexKind, RegexNode> ChildAt(int index);
    public virtual void Accept(IRegexNodeVisitor visitor);
}
internal abstract class Microsoft.CodeAnalysis.EmbeddedLanguages.RegularExpressions.RegexPrimaryExpressionNode : RegexExpressionNode {
    protected RegexPrimaryExpressionNode(RegexKind kind);
}
internal abstract class Microsoft.CodeAnalysis.EmbeddedLanguages.RegularExpressions.RegexQuantifierNode : RegexExpressionNode {
    protected RegexQuantifierNode(RegexKind kind);
}
internal abstract class Microsoft.CodeAnalysis.EmbeddedLanguages.RegularExpressions.RegexQuestionGroupingNode : RegexGroupingNode {
    [CompilerGeneratedAttribute]
private EmbeddedSyntaxToken`1<RegexKind> <QuestionToken>k__BackingField;
    public EmbeddedSyntaxToken`1<RegexKind> QuestionToken { get; }
    protected RegexQuestionGroupingNode(RegexKind kind, EmbeddedSyntaxToken`1<RegexKind> openParenToken, EmbeddedSyntaxToken`1<RegexKind> questionToken, EmbeddedSyntaxToken`1<RegexKind> closeParenToken);
    [CompilerGeneratedAttribute]
public EmbeddedSyntaxToken`1<RegexKind> get_QuestionToken();
}
internal class Microsoft.CodeAnalysis.EmbeddedLanguages.RegularExpressions.RegexSequenceNode : RegexExpressionNode {
    [CompilerGeneratedAttribute]
private ImmutableArray`1<RegexExpressionNode> <Children>k__BackingField;
    public ImmutableArray`1<RegexExpressionNode> Children { get; }
    internal int ChildCount { get; }
    public RegexSequenceNode(ImmutableArray`1<RegexExpressionNode> children);
    [CompilerGeneratedAttribute]
public ImmutableArray`1<RegexExpressionNode> get_Children();
    internal virtual int get_ChildCount();
    internal virtual EmbeddedSyntaxNodeOrToken`2<RegexKind, RegexNode> ChildAt(int index);
    public virtual void Accept(IRegexNodeVisitor visitor);
}
internal class Microsoft.CodeAnalysis.EmbeddedLanguages.RegularExpressions.RegexSimpleEscapeNode : RegexTypeEscapeNode {
    internal int ChildCount { get; }
    public RegexSimpleEscapeNode(EmbeddedSyntaxToken`1<RegexKind> backslashToken, EmbeddedSyntaxToken`1<RegexKind> typeToken);
    internal virtual int get_ChildCount();
    internal virtual EmbeddedSyntaxNodeOrToken`2<RegexKind, RegexNode> ChildAt(int index);
    public virtual void Accept(IRegexNodeVisitor visitor);
}
internal class Microsoft.CodeAnalysis.EmbeddedLanguages.RegularExpressions.RegexSimpleGroupingNode : RegexGroupingNode {
    [CompilerGeneratedAttribute]
private RegexExpressionNode <Expression>k__BackingField;
    public RegexExpressionNode Expression { get; }
    internal int ChildCount { get; }
    public RegexSimpleGroupingNode(EmbeddedSyntaxToken`1<RegexKind> openParenToken, RegexExpressionNode expression, EmbeddedSyntaxToken`1<RegexKind> closeParenToken);
    [CompilerGeneratedAttribute]
public RegexExpressionNode get_Expression();
    internal virtual int get_ChildCount();
    internal virtual EmbeddedSyntaxNodeOrToken`2<RegexKind, RegexNode> ChildAt(int index);
    public virtual void Accept(IRegexNodeVisitor visitor);
}
internal class Microsoft.CodeAnalysis.EmbeddedLanguages.RegularExpressions.RegexSimpleOptionsGroupingNode : RegexOptionsGroupingNode {
    internal int ChildCount { get; }
    public RegexSimpleOptionsGroupingNode(EmbeddedSyntaxToken`1<RegexKind> openParenToken, EmbeddedSyntaxToken`1<RegexKind> questionToken, EmbeddedSyntaxToken`1<RegexKind> optionsToken, EmbeddedSyntaxToken`1<RegexKind> closeParenToken);
    internal virtual int get_ChildCount();
    internal virtual EmbeddedSyntaxNodeOrToken`2<RegexKind, RegexNode> ChildAt(int index);
    public virtual void Accept(IRegexNodeVisitor visitor);
}
internal class Microsoft.CodeAnalysis.EmbeddedLanguages.RegularExpressions.RegexTextNode : RegexPrimaryExpressionNode {
    [CompilerGeneratedAttribute]
private EmbeddedSyntaxToken`1<RegexKind> <TextToken>k__BackingField;
    public EmbeddedSyntaxToken`1<RegexKind> TextToken { get; }
    internal int ChildCount { get; }
    public RegexTextNode(EmbeddedSyntaxToken`1<RegexKind> textToken);
    [CompilerGeneratedAttribute]
public EmbeddedSyntaxToken`1<RegexKind> get_TextToken();
    internal virtual int get_ChildCount();
    internal virtual EmbeddedSyntaxNodeOrToken`2<RegexKind, RegexNode> ChildAt(int index);
    public virtual void Accept(IRegexNodeVisitor visitor);
}
internal class Microsoft.CodeAnalysis.EmbeddedLanguages.RegularExpressions.RegexTree : EmbeddedSyntaxTree`3<RegexKind, RegexNode, RegexCompilationUnit> {
    public ImmutableDictionary`2<string, TextSpan> CaptureNamesToSpan;
    public ImmutableDictionary`2<int, TextSpan> CaptureNumbersToSpan;
    public RegexTree(VirtualCharSequence text, RegexCompilationUnit root, ImmutableArray`1<EmbeddedDiagnostic> diagnostics, ImmutableDictionary`2<string, TextSpan> captureNamesToSpan, ImmutableDictionary`2<int, TextSpan> captureNumbersToSpan);
}
internal abstract class Microsoft.CodeAnalysis.EmbeddedLanguages.RegularExpressions.RegexTypeEscapeNode : RegexEscapeNode {
    [CompilerGeneratedAttribute]
private EmbeddedSyntaxToken`1<RegexKind> <TypeToken>k__BackingField;
    public EmbeddedSyntaxToken`1<RegexKind> TypeToken { get; }
    protected RegexTypeEscapeNode(RegexKind kind, EmbeddedSyntaxToken`1<RegexKind> backslashToken, EmbeddedSyntaxToken`1<RegexKind> typeToken);
    [CompilerGeneratedAttribute]
public EmbeddedSyntaxToken`1<RegexKind> get_TypeToken();
}
internal class Microsoft.CodeAnalysis.EmbeddedLanguages.RegularExpressions.RegexUnicodeEscapeNode : RegexTypeEscapeNode {
    [CompilerGeneratedAttribute]
private EmbeddedSyntaxToken`1<RegexKind> <HexText>k__BackingField;
    internal int ChildCount { get; }
    public EmbeddedSyntaxToken`1<RegexKind> HexText { get; }
    public RegexUnicodeEscapeNode(EmbeddedSyntaxToken`1<RegexKind> backslashToken, EmbeddedSyntaxToken`1<RegexKind> typeToken, EmbeddedSyntaxToken`1<RegexKind> hexText);
    internal virtual int get_ChildCount();
    [CompilerGeneratedAttribute]
public EmbeddedSyntaxToken`1<RegexKind> get_HexText();
    internal virtual EmbeddedSyntaxNodeOrToken`2<RegexKind, RegexNode> ChildAt(int index);
    public virtual void Accept(IRegexNodeVisitor visitor);
}
internal class Microsoft.CodeAnalysis.EmbeddedLanguages.RegularExpressions.RegexWildcardNode : RegexPrimaryExpressionNode {
    [CompilerGeneratedAttribute]
private EmbeddedSyntaxToken`1<RegexKind> <DotToken>k__BackingField;
    public EmbeddedSyntaxToken`1<RegexKind> DotToken { get; }
    internal int ChildCount { get; }
    public RegexWildcardNode(EmbeddedSyntaxToken`1<RegexKind> dotToken);
    [CompilerGeneratedAttribute]
public EmbeddedSyntaxToken`1<RegexKind> get_DotToken();
    internal virtual int get_ChildCount();
    internal virtual EmbeddedSyntaxNodeOrToken`2<RegexKind, RegexNode> ChildAt(int index);
    public virtual void Accept(IRegexNodeVisitor visitor);
}
internal class Microsoft.CodeAnalysis.EmbeddedLanguages.RegularExpressions.RegexZeroOrMoreQuantifierNode : RegexQuantifierNode {
    [CompilerGeneratedAttribute]
private RegexExpressionNode <Expression>k__BackingField;
    [CompilerGeneratedAttribute]
private EmbeddedSyntaxToken`1<RegexKind> <AsteriskToken>k__BackingField;
    public RegexExpressionNode Expression { get; }
    public EmbeddedSyntaxToken`1<RegexKind> AsteriskToken { get; }
    internal int ChildCount { get; }
    public RegexZeroOrMoreQuantifierNode(RegexExpressionNode expression, EmbeddedSyntaxToken`1<RegexKind> asteriskToken);
    [CompilerGeneratedAttribute]
public RegexExpressionNode get_Expression();
    [CompilerGeneratedAttribute]
public EmbeddedSyntaxToken`1<RegexKind> get_AsteriskToken();
    internal virtual int get_ChildCount();
    internal virtual EmbeddedSyntaxNodeOrToken`2<RegexKind, RegexNode> ChildAt(int index);
    public virtual void Accept(IRegexNodeVisitor visitor);
}
internal class Microsoft.CodeAnalysis.EmbeddedLanguages.RegularExpressions.RegexZeroOrOneQuantifierNode : RegexQuantifierNode {
    [CompilerGeneratedAttribute]
private RegexExpressionNode <Expression>k__BackingField;
    [CompilerGeneratedAttribute]
private EmbeddedSyntaxToken`1<RegexKind> <QuestionToken>k__BackingField;
    public RegexExpressionNode Expression { get; }
    public EmbeddedSyntaxToken`1<RegexKind> QuestionToken { get; }
    internal int ChildCount { get; }
    public RegexZeroOrOneQuantifierNode(RegexExpressionNode expression, EmbeddedSyntaxToken`1<RegexKind> questionToken);
    [CompilerGeneratedAttribute]
public RegexExpressionNode get_Expression();
    [CompilerGeneratedAttribute]
public EmbeddedSyntaxToken`1<RegexKind> get_QuestionToken();
    internal virtual int get_ChildCount();
    internal virtual EmbeddedSyntaxNodeOrToken`2<RegexKind, RegexNode> ChildAt(int index);
    public virtual void Accept(IRegexNodeVisitor visitor);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.CodeAnalysis.EmbeddedLanguages.RegularExpressions.RegularExpressionsOptions : object {
    public static PerLanguageOption2`1<bool> ColorizeRegexPatterns;
    public static PerLanguageOption2`1<bool> ReportInvalidRegexPatterns;
    public static PerLanguageOption2`1<bool> HighlightRelatedRegexComponentsUnderCursor;
    public static PerLanguageOption2`1<bool> ProvideRegexCompletions;
    private static RegularExpressionsOptions();
}
[ExportOptionProviderAttribute]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.EmbeddedLanguages.RegularExpressions.RegularExpressionsOptionsProvider : object {
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private ImmutableArray`1<IOption> <Options>k__BackingField;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ImmutableArray`1<IOption> Options { get; }
    [CompilerGeneratedAttribute]
public sealed virtual ImmutableArray`1<IOption> get_Options();
}
internal class Microsoft.CodeAnalysis.Emit.CompilationOutputFiles : CompilationOutputs {
    internal static CompilationOutputFiles None;
    [CompilerGeneratedAttribute]
private string <PdbFilePath>k__BackingField;
    [CompilerGeneratedAttribute]
private string <AssemblyFilePath>k__BackingField;
    public string AssemblyDisplayPath { get; }
    public string PdbDisplayPath { get; }
    public string PdbFilePath { get; }
    public string AssemblyFilePath { get; }
    public CompilationOutputFiles(string assemblyFilePath, string pdbFilePath);
    private static CompilationOutputFiles();
    public virtual string get_AssemblyDisplayPath();
    public virtual string get_PdbDisplayPath();
    [CompilerGeneratedAttribute]
public string get_PdbFilePath();
    [CompilerGeneratedAttribute]
public string get_AssemblyFilePath();
    protected virtual Stream OpenAssemblyStream();
    protected virtual Stream OpenPdbStream();
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
internal class Microsoft.CodeAnalysis.Emit.CompilationOutputFilesWithImplicitPdbPath : CompilationOutputs {
    [CompilerGeneratedAttribute]
private string <AssemblyFilePath>k__BackingField;
    public string AssemblyFilePath { get; }
    public string AssemblyDisplayPath { get; }
    [NullableAttribute("1")]
public string PdbDisplayPath { get; }
    public CompilationOutputFilesWithImplicitPdbPath(string assemblyFilePath);
    [CompilerGeneratedAttribute]
public string get_AssemblyFilePath();
    public virtual string get_AssemblyDisplayPath();
    [NullableContextAttribute("1")]
public virtual string get_PdbDisplayPath();
    protected virtual Stream OpenAssemblyStream();
    [NullableContextAttribute("1")]
protected virtual Stream OpenPdbStream();
    public virtual DebugInformationReaderProvider OpenPdb();
    private static Stream TryOpenFileStream(string path);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
internal abstract class Microsoft.CodeAnalysis.Emit.CompilationOutputs : object {
    public string AssemblyDisplayPath { get; }
    public string PdbDisplayPath { get; }
    public abstract virtual string get_AssemblyDisplayPath();
    public abstract virtual string get_PdbDisplayPath();
    public virtual MetadataReaderProvider OpenAssemblyMetadata(bool prefetch);
    internal virtual Guid ReadAssemblyModuleVersionId();
    public virtual DebugInformationReaderProvider OpenPdb();
    private static Stream ValidateStream(Stream stream, string methodName);
    private Stream OpenPdbStreamChecked();
    private Stream OpenAssemblyStreamChecked();
    protected abstract virtual Stream OpenAssemblyStream();
    protected abstract virtual Stream OpenPdbStream();
}
internal interface Microsoft.CodeAnalysis.Emit.ICompilationOutputsProviderService {
    public abstract virtual CompilationOutputs GetCompilationOutputs(ProjectId projectId);
}
internal abstract class Microsoft.CodeAnalysis.EncapsulateField.AbstractEncapsulateFieldService : object {
    private static Char[] s_underscoreCharArray;
    private static CultureInfo EnUSCultureInfo;
    private static AbstractEncapsulateFieldService();
    protected abstract virtual Task`1<SyntaxNode> RewriteFieldNameAndAccessibilityAsync(string originalFieldName, bool makePrivate, Document document, SyntaxAnnotation declarationAnnotation, CancellationToken cancellationToken);
    protected abstract virtual Task`1<ImmutableArray`1<IFieldSymbol>> GetFieldsAsync(Document document, TextSpan span, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.EncapsulateField.AbstractEncapsulateFieldService/<EncapsulateFieldsInSpanAsync>d__2")]
public Task`1<EncapsulateFieldResult> EncapsulateFieldsInSpanAsync(Document document, TextSpan span, bool useDefaultBehavior, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.EncapsulateField.AbstractEncapsulateFieldService/<GetEncapsulateFieldCodeActionsAsync>d__3")]
public Task`1<ImmutableArray`1<CodeAction>> GetEncapsulateFieldCodeActionsAsync(Document document, TextSpan span, CancellationToken cancellationToken);
    private ImmutableArray`1<CodeAction> EncapsulateAllFields(Document document, ImmutableArray`1<IFieldSymbol> fields);
    private ImmutableArray`1<CodeAction> EncapsulateOneField(Document document, IFieldSymbol field);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.EncapsulateField.AbstractEncapsulateFieldService/<EncapsulateFieldsAsync>d__6")]
public Task`1<Solution> EncapsulateFieldsAsync(Document document, ImmutableArray`1<IFieldSymbol> fields, bool updateReferences, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.EncapsulateField.AbstractEncapsulateFieldService/<EncapsulateFieldsInCurrentProcessAsync>d__7")]
private Task`1<Solution> EncapsulateFieldsInCurrentProcessAsync(Document document, ImmutableArray`1<IFieldSymbol> fields, bool updateReferences, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.EncapsulateField.AbstractEncapsulateFieldService/<EncapsulateFieldAsync>d__8")]
private Task`1<Solution> EncapsulateFieldAsync(Document document, IFieldSymbol field, bool updateReferences, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.EncapsulateField.AbstractEncapsulateFieldService/<UpdateReferencesAsync>d__9")]
private Task`1<Solution> UpdateReferencesAsync(bool updateReferences, Solution solution, Document document, IFieldSymbol field, string finalFieldName, string generatedPropertyName, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.EncapsulateField.AbstractEncapsulateFieldService/<RenameAsync>d__10")]
private static Task`1<Solution> RenameAsync(Solution solution, IFieldSymbol field, string finalName, Func`2<Location, bool> filter, CancellationToken cancellationToken);
    private static bool IntersectsWithAny(Location location, ISet`1<Location> constructorLocations);
    private ISet`1<Location> GetConstructorLocations(INamedTypeSymbol containingType);
    internal abstract virtual IEnumerable`1<SyntaxNode> GetConstructorNodes(INamedTypeSymbol containingType);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.EncapsulateField.AbstractEncapsulateFieldService/<AddPropertyAsync>d__14")]
protected static Task`1<Solution> AddPropertyAsync(Document document, Solution destinationSolution, IFieldSymbol field, IPropertySymbol property, CancellationToken cancellationToken);
    protected static IPropertySymbol GenerateProperty(string propertyName, string fieldName, Accessibility accessibility, IFieldSymbol field, INamedTypeSymbol containingSymbol, SyntaxAnnotation annotation, Document document);
    protected abstract virtual ValueTuple`2<string, string> GenerateFieldAndPropertyNames(IFieldSymbol field);
    protected static Accessibility ComputeAccessibility(Accessibility accessibility, ITypeSymbol type);
    protected static IMethodSymbol CreateSet(string originalFieldName, IFieldSymbol field, SyntaxGenerator factory);
    protected static IMethodSymbol CreateGet(string originalFieldName, IFieldSymbol field, SyntaxGenerator factory);
    protected static string GeneratePropertyName(string fieldName);
}
[ExportCodeRefactoringProviderAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.EncapsulateField.EncapsulateFieldRefactoringProvider : CodeRefactoringProvider {
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.EncapsulateField.EncapsulateFieldRefactoringProvider/<ComputeRefactoringsAsync>d__1")]
public sealed virtual Task ComputeRefactoringsAsync(CodeRefactoringContext context);
}
internal class Microsoft.CodeAnalysis.EncapsulateField.EncapsulateFieldResult : object {
    public string Name;
    public Glyph Glyph;
    private AsyncLazy`1<Solution> _lazySolution;
    public EncapsulateFieldResult(string name, Glyph glyph, Func`2<CancellationToken, Task`1<Solution>> getSolutionAsync);
    public Task`1<Solution> GetSolutionAsync(CancellationToken cancellationToken);
}
internal interface Microsoft.CodeAnalysis.EncapsulateField.IRemoteEncapsulateFieldService {
    public abstract virtual ValueTask`1<ImmutableArray`1<ValueTuple`2<DocumentId, ImmutableArray`1<TextChange>>>> EncapsulateFieldsAsync(PinnedSolutionInfo solutionInfo, DocumentId documentId, ImmutableArray`1<string> fieldSymbolKeys, bool updateReferences, CancellationToken cancellationToken);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal abstract class Microsoft.CodeAnalysis.ExternalAccess.Pythia.Api.PythiaCompletionProviderBase : CommonCompletionProvider {
    public static PerLanguageOption2`1<bool> HideAdvancedMembersOption { get; }
    public static PerLanguageOption2`1<bool> get_HideAdvancedMembersOption();
    public static CompletionItem CreateCommonCompletionItem(string displayText, string displayTextSuffix, CompletionItemRules rules, Nullable`1<PythiaGlyph> glyph, ImmutableArray`1<SymbolDisplayPart> description, string sortText, string filterText, bool showsWarningIcon, ImmutableDictionary`2<string, string> properties, ImmutableArray`1<string> tags, string inlineDescription);
    public static CompletionItem CreateSymbolCompletionItem(string displayText, IReadOnlyList`1<ISymbol> symbols, CompletionItemRules rules, int contextPosition, string sortText, string insertionText, string filterText, SupportedPlatformData supportedPlatforms, ImmutableDictionary`2<string, string> properties, ImmutableArray`1<string> tags);
    public static ImmutableArray`1<SymbolDisplayPart> CreateRecommendedKeywordDisplayParts(string keyword, string toolTip);
    public static Task`1<CompletionDescription> GetDescriptionAsync(CompletionItem item, Document document, CancellationToken cancellationToken);
    public static CompletionDescription GetDescription(CompletionItem item);
    public virtual Task`1<CompletionChange> GetChangeAsync(Document document, CompletionItem item, Nullable`1<char> commitKey, CancellationToken cancellationToken);
}
internal static class Microsoft.CodeAnalysis.ExternalAccess.Pythia.Api.PythiaDocumentationCommentFormatting : object {
    [NullableContextAttribute("1")]
public static IEnumerable`1<TaggedText> GetDocumentationParts(ISymbol symbol, SemanticModel semanticModel, int position, IDocumentationCommentFormattingService formatter, CancellationToken cancellationToken);
}
internal enum Microsoft.CodeAnalysis.ExternalAccess.Pythia.Api.PythiaGlyph : Enum {
    public int value__;
    public static PythiaGlyph Keyword;
}
internal static class Microsoft.CodeAnalysis.ExternalAccess.Pythia.Api.PythiaSymbolMatchPriority : object {
    internal static int Keyword;
    internal static int PreferType;
    internal static int PreferNamedArgument;
    internal static int PreferEventOrMethod;
    internal static int PreferFieldOrProperty;
    internal static int PreferLocalOrParameterOrRangeVariable;
    private static PythiaSymbolMatchPriority();
}
internal static class Microsoft.CodeAnalysis.ExternalAccess.Pythia.Api.PythiaSymbolSorting : object {
    [NullableContextAttribute("1")]
public static ImmutableArray`1<TSymbol> Sort(ImmutableArray`1<TSymbol> symbols, ISymbolDisplayService symbolDisplayService, SemanticModel semanticModel, int position);
}
[ObsoleteAttribute]
internal interface Microsoft.CodeAnalysis.ExternalAccess.UnitTesting.Api.IUnitTestingSolutionCrawlerServiceAccessor {
    public abstract virtual void Reanalyze(Workspace workspace, IEnumerable`1<ProjectId> projectIds, IEnumerable`1<DocumentId> documentIds, bool highPriority);
    public abstract virtual void AddAnalyzerProvider(IUnitTestingIncrementalAnalyzerProviderImplementation provider, UnitTestingIncrementalAnalyzerProviderMetadataWrapper metadata);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.CodeAnalysis.ExternalAccess.UnitTesting.Api.UnitTestingIncrementalAnalyzerProvider : object {
    private IUnitTestingIncrementalAnalyzerProviderImplementation _incrementalAnalyzerProvider;
    private Workspace _workspace;
    [NullableAttribute("2")]
private IIncrementalAnalyzer _lazyAnalyzer;
    internal UnitTestingIncrementalAnalyzerProvider(Workspace workspace, IUnitTestingIncrementalAnalyzerProviderImplementation incrementalAnalyzerProvider);
    private sealed virtual override IIncrementalAnalyzer Microsoft.CodeAnalysis.SolutionCrawler.IIncrementalAnalyzerProvider.CreateIncrementalAnalyzer(Workspace workspace);
    public void Reanalyze();
    public static UnitTestingIncrementalAnalyzerProvider TryRegister(Workspace workspace, string analyzerName, IUnitTestingIncrementalAnalyzerProviderImplementation provider);
}
[ObsoleteAttribute]
internal class Microsoft.CodeAnalysis.ExternalAccess.UnitTesting.UnitTestingSolutionCrawlerServiceAccessor : object {
    private ISolutionCrawlerRegistrationService _registrationService;
    private ISolutionCrawlerService _solutionCrawlerService;
    private UnitTestingIncrementalAnalyzerProvider _analyzerProvider;
    [ObsoleteAttribute("This factory method only provides services for the MEF export provider.", "True")]
public UnitTestingSolutionCrawlerServiceAccessor(ISolutionCrawlerRegistrationService registrationService, ISolutionCrawlerService solutionCrawlerService);
    public sealed virtual void AddAnalyzerProvider(IUnitTestingIncrementalAnalyzerProviderImplementation provider, UnitTestingIncrementalAnalyzerProviderMetadataWrapper metadata);
    public sealed virtual void Reanalyze(Workspace workspace, IEnumerable`1<ProjectId> projectIds, IEnumerable`1<DocumentId> documentIds, bool highPriority);
    public void Register(Workspace workspace);
}
[ObsoleteAttribute]
[ExportWorkspaceServiceFactoryAttribute("Microsoft.CodeAnalysis.ExternalAccess.UnitTesting.Api.IUnitTestingSolutionCrawlerServiceAccessor", "Default")]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.ExternalAccess.UnitTesting.UnitTestingSolutionCrawlerServiceAccessorFactory : object {
    [ObsoleteAttribute("This factory method only provides services for the MEF export provider.", "True")]
public sealed virtual IWorkspaceService CreateService(HostWorkspaceServices workspaceServices);
}
[NullableContextAttribute("1")]
internal interface Microsoft.CodeAnalysis.ExternalAccess.VSTypeScript.Api.IVSTypeScriptDiagnosticAnalyzerImplementation {
    public abstract virtual Task`1<ImmutableArray`1<Diagnostic>> AnalyzeProjectAsync(Project project, CancellationToken cancellationToken);
    public abstract virtual Task`1<ImmutableArray`1<Diagnostic>> AnalyzeDocumentSyntaxAsync(Document document, CancellationToken cancellationToken);
    public abstract virtual Task`1<ImmutableArray`1<Diagnostic>> AnalyzeDocumentSemanticsAsync(Document document, CancellationToken cancellationToken);
}
[NullableContextAttribute("1")]
internal interface Microsoft.CodeAnalysis.ExternalAccess.VSTypeScript.Api.IVSTypeScriptDiagnosticAnalyzerService {
    public abstract virtual void Reanalyze(Workspace workspace, IEnumerable`1<ProjectId> projectIds, IEnumerable`1<DocumentId> documentIds, bool highPriority);
}
internal interface Microsoft.CodeAnalysis.ExternalAccess.VSTypeScript.Api.IVSTypeScriptNavigableItem {
    public Glyph Glyph { get; }
    public ImmutableArray`1<TaggedText> DisplayTaggedParts { get; }
    public bool DisplayFileLocation { get; }
    public bool IsImplicitlyDeclared { get; }
    [NullableAttribute("1")]
public Document Document { get; }
    public TextSpan SourceSpan { get; }
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ImmutableArray`1<IVSTypeScriptNavigableItem> ChildItems { get; }
    public abstract virtual Glyph get_Glyph();
    public abstract virtual ImmutableArray`1<TaggedText> get_DisplayTaggedParts();
    public abstract virtual bool get_DisplayFileLocation();
    public abstract virtual bool get_IsImplicitlyDeclared();
    [NullableContextAttribute("1")]
public abstract virtual Document get_Document();
    public abstract virtual TextSpan get_SourceSpan();
    public abstract virtual ImmutableArray`1<IVSTypeScriptNavigableItem> get_ChildItems();
}
[NullableContextAttribute("1")]
internal interface Microsoft.CodeAnalysis.ExternalAccess.VSTypeScript.Api.IVSTypeScriptNavigateToSearchResult {
    public string AdditionalInformation { get; }
    public string Kind { get; }
    public VSTypeScriptNavigateToMatchKind MatchKind { get; }
    public bool IsCaseSensitive { get; }
    public string Name { get; }
    [NullableAttribute("0")]
public ImmutableArray`1<TextSpan> NameMatchSpans { get; }
    public string SecondarySort { get; }
    public string Summary { get; }
    public IVSTypeScriptNavigableItem NavigableItem { get; }
    public abstract virtual string get_AdditionalInformation();
    public abstract virtual string get_Kind();
    public abstract virtual VSTypeScriptNavigateToMatchKind get_MatchKind();
    public abstract virtual bool get_IsCaseSensitive();
    public abstract virtual string get_Name();
    [NullableContextAttribute("0")]
public abstract virtual ImmutableArray`1<TextSpan> get_NameMatchSpans();
    public abstract virtual string get_SecondarySort();
    public abstract virtual string get_Summary();
    public abstract virtual IVSTypeScriptNavigableItem get_NavigableItem();
}
[NullableContextAttribute("1")]
internal interface Microsoft.CodeAnalysis.ExternalAccess.VSTypeScript.Api.IVSTypeScriptNavigateToSearchService {
    public IImmutableSet`1<string> KindsProvided { get; }
    public bool CanFilter { get; }
    public abstract virtual IImmutableSet`1<string> get_KindsProvided();
    public abstract virtual bool get_CanFilter();
    public abstract virtual Task`1<ImmutableArray`1<IVSTypeScriptNavigateToSearchResult>> SearchProjectAsync(Project project, ImmutableArray`1<Document> priorityDocuments, string searchPattern, IImmutableSet`1<string> kinds, CancellationToken cancellationToken);
    public abstract virtual Task`1<ImmutableArray`1<IVSTypeScriptNavigateToSearchResult>> SearchDocumentAsync(Document document, string searchPattern, IImmutableSet`1<string> kinds, CancellationToken cancellationToken);
}
internal abstract class Microsoft.CodeAnalysis.ExternalAccess.VSTypeScript.Api.VSTypeScriptDefinitionItemBase : DefinitionItem {
    protected VSTypeScriptDefinitionItemBase(ImmutableArray`1<string> tags, ImmutableArray`1<TaggedText> displayParts);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[IsReadOnlyAttribute]
internal class Microsoft.CodeAnalysis.ExternalAccess.VSTypeScript.Api.VSTypeScriptDocumentNavigationServiceWrapper : ValueType {
    private IDocumentNavigationService _underlyingObject;
    public VSTypeScriptDocumentNavigationServiceWrapper(IDocumentNavigationService underlyingObject);
    public static VSTypeScriptDocumentNavigationServiceWrapper Create(Workspace workspace);
    [ObsoleteAttribute("Call overload that takes a CancellationToken", "False")]
public bool TryNavigateToPosition(Workspace workspace, DocumentId documentId, int position, int virtualSpace, OptionSet options);
    public bool TryNavigateToPosition(Workspace workspace, DocumentId documentId, int position, int virtualSpace, OptionSet options, CancellationToken cancellationToken);
}
internal enum Microsoft.CodeAnalysis.ExternalAccess.VSTypeScript.Api.VSTypeScriptGlyph : Enum {
    public int value__;
    public static VSTypeScriptGlyph None;
    public static VSTypeScriptGlyph Assembly;
    public static VSTypeScriptGlyph BasicFile;
    public static VSTypeScriptGlyph BasicProject;
    public static VSTypeScriptGlyph ClassPublic;
    public static VSTypeScriptGlyph ClassProtected;
    public static VSTypeScriptGlyph ClassPrivate;
    public static VSTypeScriptGlyph ClassInternal;
    public static VSTypeScriptGlyph CSharpFile;
    public static VSTypeScriptGlyph CSharpProject;
    public static VSTypeScriptGlyph ConstantPublic;
    public static VSTypeScriptGlyph ConstantProtected;
    public static VSTypeScriptGlyph ConstantPrivate;
    public static VSTypeScriptGlyph ConstantInternal;
    public static VSTypeScriptGlyph DelegatePublic;
    public static VSTypeScriptGlyph DelegateProtected;
    public static VSTypeScriptGlyph DelegatePrivate;
    public static VSTypeScriptGlyph DelegateInternal;
    public static VSTypeScriptGlyph EnumPublic;
    public static VSTypeScriptGlyph EnumProtected;
    public static VSTypeScriptGlyph EnumPrivate;
    public static VSTypeScriptGlyph EnumInternal;
    public static VSTypeScriptGlyph EnumMemberPublic;
    public static VSTypeScriptGlyph EnumMemberProtected;
    public static VSTypeScriptGlyph EnumMemberPrivate;
    public static VSTypeScriptGlyph EnumMemberInternal;
    public static VSTypeScriptGlyph Error;
    public static VSTypeScriptGlyph StatusInformation;
    public static VSTypeScriptGlyph EventPublic;
    public static VSTypeScriptGlyph EventProtected;
    public static VSTypeScriptGlyph EventPrivate;
    public static VSTypeScriptGlyph EventInternal;
    public static VSTypeScriptGlyph ExtensionMethodPublic;
    public static VSTypeScriptGlyph ExtensionMethodProtected;
    public static VSTypeScriptGlyph ExtensionMethodPrivate;
    public static VSTypeScriptGlyph ExtensionMethodInternal;
    public static VSTypeScriptGlyph FieldPublic;
    public static VSTypeScriptGlyph FieldProtected;
    public static VSTypeScriptGlyph FieldPrivate;
    public static VSTypeScriptGlyph FieldInternal;
    public static VSTypeScriptGlyph InterfacePublic;
    public static VSTypeScriptGlyph InterfaceProtected;
    public static VSTypeScriptGlyph InterfacePrivate;
    public static VSTypeScriptGlyph InterfaceInternal;
    public static VSTypeScriptGlyph Intrinsic;
    public static VSTypeScriptGlyph Keyword;
    public static VSTypeScriptGlyph Label;
    public static VSTypeScriptGlyph Local;
    public static VSTypeScriptGlyph Namespace;
    public static VSTypeScriptGlyph MethodPublic;
    public static VSTypeScriptGlyph MethodProtected;
    public static VSTypeScriptGlyph MethodPrivate;
    public static VSTypeScriptGlyph MethodInternal;
    public static VSTypeScriptGlyph ModulePublic;
    public static VSTypeScriptGlyph ModuleProtected;
    public static VSTypeScriptGlyph ModulePrivate;
    public static VSTypeScriptGlyph ModuleInternal;
    public static VSTypeScriptGlyph OpenFolder;
    public static VSTypeScriptGlyph Operator;
    public static VSTypeScriptGlyph Parameter;
    public static VSTypeScriptGlyph PropertyPublic;
    public static VSTypeScriptGlyph PropertyProtected;
    public static VSTypeScriptGlyph PropertyPrivate;
    public static VSTypeScriptGlyph PropertyInternal;
    public static VSTypeScriptGlyph RangeVariable;
    public static VSTypeScriptGlyph Reference;
    public static VSTypeScriptGlyph StructurePublic;
    public static VSTypeScriptGlyph StructureProtected;
    public static VSTypeScriptGlyph StructurePrivate;
    public static VSTypeScriptGlyph StructureInternal;
    public static VSTypeScriptGlyph TypeParameter;
    public static VSTypeScriptGlyph Snippet;
    public static VSTypeScriptGlyph CompletionWarning;
    public static VSTypeScriptGlyph AddReference;
    public static VSTypeScriptGlyph NuGet;
    public static VSTypeScriptGlyph TargetTypeMatch;
}
internal enum Microsoft.CodeAnalysis.ExternalAccess.VSTypeScript.Api.VSTypeScriptNavigateToMatchKind : Enum {
    public int value__;
    public static VSTypeScriptNavigateToMatchKind Exact;
    public static VSTypeScriptNavigateToMatchKind Prefix;
    public static VSTypeScriptNavigateToMatchKind Substring;
    public static VSTypeScriptNavigateToMatchKind Regular;
    public static VSTypeScriptNavigateToMatchKind None;
    public static VSTypeScriptNavigateToMatchKind CamelCaseExact;
    public static VSTypeScriptNavigateToMatchKind CamelCasePrefix;
    public static VSTypeScriptNavigateToMatchKind CamelCaseNonContiguousPrefix;
    public static VSTypeScriptNavigateToMatchKind CamelCaseSubstring;
    public static VSTypeScriptNavigateToMatchKind CamelCaseNonContiguousSubstring;
    public static VSTypeScriptNavigateToMatchKind Fuzzy;
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[SharedAttribute]
[ExportAttribute("Microsoft.CodeAnalysis.ExternalAccess.VSTypeScript.Api.IVSTypeScriptDiagnosticAnalyzerService")]
internal class Microsoft.CodeAnalysis.ExternalAccess.VSTypeScript.VSTypeScriptAnalyzerService : object {
    private IDiagnosticAnalyzerService _service;
    [ImportingConstructorAttribute]
[ObsoleteAttribute("This exported object must be obtained through the MEF export provider.", "True")]
public VSTypeScriptAnalyzerService(IDiagnosticAnalyzerService service);
    public sealed virtual void Reanalyze(Workspace workspace, IEnumerable`1<ProjectId> projectIds, IEnumerable`1<DocumentId> documentIds, bool highPriority);
}
[SharedAttribute]
[ExportLanguageServiceAttribute("Microsoft.CodeAnalysis.ExternalAccess.VSTypeScript.VSTypeScriptDiagnosticAnalyzerLanguageService", "TypeScript", "Default")]
internal class Microsoft.CodeAnalysis.ExternalAccess.VSTypeScript.VSTypeScriptDiagnosticAnalyzerLanguageService : object {
    [NullableAttribute("2")]
internal IVSTypeScriptDiagnosticAnalyzerImplementation Implementation;
    [NullableContextAttribute("2")]
[ImportingConstructorAttribute]
[ObsoleteAttribute("This exported object must be obtained through the MEF export provider.", "True")]
public VSTypeScriptDiagnosticAnalyzerLanguageService(IVSTypeScriptDiagnosticAnalyzerImplementation implementation);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[DiagnosticAnalyzerAttribute("TypeScript", "Mono.Cecil.CustomAttributeArgument[]")]
internal class Microsoft.CodeAnalysis.ExternalAccess.VSTypeScript.VSTypeScriptDocumentDiagnosticAnalyzer : DocumentDiagnosticAnalyzer {
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    public virtual Task`1<ImmutableArray`1<Diagnostic>> AnalyzeSyntaxAsync(Document document, CancellationToken cancellationToken);
    public virtual Task`1<ImmutableArray`1<Diagnostic>> AnalyzeSemanticsAsync(Document document, CancellationToken cancellationToken);
}
internal static class Microsoft.CodeAnalysis.ExternalAccess.VSTypeScript.VSTypeScriptGlyphHelpers : object {
    public static VSTypeScriptGlyph ConvertFrom(Glyph glyph);
    public static Glyph ConvertTo(VSTypeScriptGlyph glyph);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExportLanguageServiceAttribute("Microsoft.CodeAnalysis.NavigateTo.INavigateToSearchService", "TypeScript", "Default")]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.ExternalAccess.VSTypeScript.VSTypeScriptNavigateToSearchService : object {
    [NullableAttribute("2")]
private IVSTypeScriptNavigateToSearchService _searchService;
    public IImmutableSet`1<string> KindsProvided { get; }
    public bool CanFilter { get; }
    [NullableContextAttribute("2")]
[ImportingConstructorAttribute]
[ObsoleteAttribute("This exported object must be obtained through the MEF export provider.", "True")]
public VSTypeScriptNavigateToSearchService(IVSTypeScriptNavigateToSearchService searchService);
    public sealed virtual IImmutableSet`1<string> get_KindsProvided();
    public sealed virtual bool get_CanFilter();
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.ExternalAccess.VSTypeScript.VSTypeScriptNavigateToSearchService/<SearchDocumentAsync>d__6")]
public sealed virtual Task`1<ImmutableArray`1<INavigateToSearchResult>> SearchDocumentAsync(Document document, string searchPattern, IImmutableSet`1<string> kinds, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.ExternalAccess.VSTypeScript.VSTypeScriptNavigateToSearchService/<SearchProjectAsync>d__7")]
public sealed virtual Task`1<ImmutableArray`1<INavigateToSearchResult>> SearchProjectAsync(Project project, ImmutableArray`1<Document> priorityDocuments, string searchPattern, IImmutableSet`1<string> kinds, CancellationToken cancellationToken);
    private static INavigateToSearchResult Convert(IVSTypeScriptNavigateToSearchResult result);
}
[DiagnosticAnalyzerAttribute("TypeScript", "Mono.Cecil.CustomAttributeArgument[]")]
internal class Microsoft.CodeAnalysis.ExternalAccess.VSTypeScript.VSTypeScriptProjectDiagnosticAnalyzer : ProjectDiagnosticAnalyzer {
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    [NullableContextAttribute("1")]
public virtual Task`1<ImmutableArray`1<Diagnostic>> AnalyzeProjectAsync(Project project, CancellationToken cancellationToken);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal abstract class Microsoft.CodeAnalysis.ExtractClass.AbstractExtractClassRefactoringProvider : CodeRefactoringProvider {
    [NullableAttribute("2")]
private IExtractClassOptionsService _optionsService;
    [NullableContextAttribute("2")]
public AbstractExtractClassRefactoringProvider(IExtractClassOptionsService service);
    protected abstract virtual Task`1<SyntaxNode> GetSelectedNodeAsync(CodeRefactoringContext context);
    protected abstract virtual Task`1<SyntaxNode> GetSelectedClassDeclarationAsync(CodeRefactoringContext context);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.ExtractClass.AbstractExtractClassRefactoringProvider/<ComputeRefactoringsAsync>d__4")]
public virtual Task ComputeRefactoringsAsync(CodeRefactoringContext context);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.ExtractClass.AbstractExtractClassRefactoringProvider/<TryGetMemberActionAsync>d__5")]
private Task`1<ExtractClassWithDialogCodeAction> TryGetMemberActionAsync(CodeRefactoringContext context, IExtractClassOptionsService optionsService);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.ExtractClass.AbstractExtractClassRefactoringProvider/<TryGetClassActionAsync>d__6")]
private Task`1<ExtractClassWithDialogCodeAction> TryGetClassActionAsync(CodeRefactoringContext context, IExtractClassOptionsService optionsService);
}
internal class Microsoft.CodeAnalysis.ExtractClass.ExtractClassMemberAnalysisResult : object {
    [CompilerGeneratedAttribute]
private ISymbol <Member>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <MakeAbstract>k__BackingField;
    public ISymbol Member { get; }
    public bool MakeAbstract { get; }
    public ExtractClassMemberAnalysisResult(ISymbol member, bool makeAbstract);
    [CompilerGeneratedAttribute]
public ISymbol get_Member();
    [CompilerGeneratedAttribute]
public bool get_MakeAbstract();
}
internal class Microsoft.CodeAnalysis.ExtractClass.ExtractClassOptions : object {
    [CompilerGeneratedAttribute]
private string <FileName>k__BackingField;
    [CompilerGeneratedAttribute]
private string <TypeName>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <SameFile>k__BackingField;
    [CompilerGeneratedAttribute]
private ImmutableArray`1<ExtractClassMemberAnalysisResult> <MemberAnalysisResults>k__BackingField;
    public string FileName { get; }
    public string TypeName { get; }
    public bool SameFile { get; }
    public ImmutableArray`1<ExtractClassMemberAnalysisResult> MemberAnalysisResults { get; }
    public ExtractClassOptions(string fileName, string typeName, bool sameFile, ImmutableArray`1<ExtractClassMemberAnalysisResult> memberAnalysisResults);
    [CompilerGeneratedAttribute]
public string get_FileName();
    [CompilerGeneratedAttribute]
public string get_TypeName();
    [CompilerGeneratedAttribute]
public bool get_SameFile();
    [CompilerGeneratedAttribute]
public ImmutableArray`1<ExtractClassMemberAnalysisResult> get_MemberAnalysisResults();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.CodeAnalysis.ExtractClass.ExtractClassWithDialogCodeAction : CodeActionWithOptions {
    private Document _document;
    [NullableAttribute("2")]
private ISymbol _selectedMember;
    private INamedTypeSymbol _selectedType;
    private SyntaxNode _selectedTypeDeclarationNode;
    private IExtractClassOptionsService _service;
    [CompilerGeneratedAttribute]
private TextSpan <Span>k__BackingField;
    public TextSpan Span { get; }
    public string Title { get; }
    public ExtractClassWithDialogCodeAction(Document document, TextSpan span, IExtractClassOptionsService service, INamedTypeSymbol selectedType, SyntaxNode selectedTypeDeclarationNode, ISymbol selectedMember);
    [CompilerGeneratedAttribute]
public TextSpan get_Span();
    public virtual string get_Title();
    [NullableContextAttribute("2")]
public virtual object GetOptions(CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.ExtractClass.ExtractClassWithDialogCodeAction/<ComputeOperationsAsync>d__12")]
protected virtual Task`1<IEnumerable`1<CodeActionOperation>> ComputeOperationsAsync(object options, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.ExtractClass.ExtractClassWithDialogCodeAction/<PullMembersUpAsync>d__13")]
private Task`1<Solution> PullMembersUpAsync(Solution solution, INamedTypeSymbol newType, AnnotatedSymbolMapping symbolMapping, ImmutableArray`1<ExtractClassMemberAnalysisResult> memberAnalysisResults, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.ExtractClass.ExtractClassWithDialogCodeAction/<GetNewTypeSymbolAsync>d__14")]
private static Task`1<INamedTypeSymbol> GetNewTypeSymbolAsync(Document document, SyntaxAnnotation typeAnnotation, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.ExtractClass.ExtractClassWithDialogCodeAction/<GetSolutionWithBaseAddedAsync>d__15")]
private static Task`1<Solution> GetSolutionWithBaseAddedAsync(Solution solution, AnnotatedSymbolMapping symbolMapping, INamedTypeSymbol newType, ImmutableArray`1<ExtractClassMemberAnalysisResult> memberAnalysisResults, CancellationToken cancellationToken);
}
internal interface Microsoft.CodeAnalysis.ExtractClass.IExtractClassOptionsService {
    [NullableContextAttribute("1")]
public abstract virtual Task`1<ExtractClassOptions> GetExtractClassOptionsAsync(Document document, INamedTypeSymbol originalType, ISymbol selectedMember);
}
internal abstract class Microsoft.CodeAnalysis.ExtractInterface.AbstractExtractInterfaceService : object {
    protected abstract virtual Task`1<SyntaxNode> GetTypeDeclarationAsync(Document document, int position, TypeDiscoveryRule typeDiscoveryRule, CancellationToken cancellationToken);
    protected abstract virtual Task`1<Solution> UpdateMembersWithExplicitImplementationsAsync(Solution unformattedSolution, IReadOnlyList`1<DocumentId> documentId, INamedTypeSymbol extractedInterfaceSymbol, INamedTypeSymbol typeToExtractFrom, IEnumerable`1<ISymbol> includedMembers, ImmutableDictionary`2<ISymbol, SyntaxAnnotation> symbolToDeclarationAnnotationMap, CancellationToken cancellationToken);
    internal abstract virtual string GetContainingNamespaceDisplay(INamedTypeSymbol typeSymbol, CompilationOptions compilationOptions);
    internal abstract virtual bool ShouldIncludeAccessibilityModifier(SyntaxNode typeNode);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.ExtractInterface.AbstractExtractInterfaceService/<GetExtractInterfaceCodeActionAsync>d__4")]
public Task`1<ImmutableArray`1<ExtractInterfaceCodeAction>> GetExtractInterfaceCodeActionAsync(Document document, TextSpan span, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.ExtractInterface.AbstractExtractInterfaceService/<ExtractInterfaceAsync>d__5")]
public Task`1<ExtractInterfaceResult> ExtractInterfaceAsync(Document documentWithTypeToExtractFrom, int position, Action`2<string, NotificationSeverity> errorHandler, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.ExtractInterface.AbstractExtractInterfaceService/<AnalyzeTypeAtPositionAsync>d__6")]
public Task`1<ExtractInterfaceTypeAnalysisResult> AnalyzeTypeAtPositionAsync(Document document, int position, TypeDiscoveryRule typeDiscoveryRule, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.ExtractInterface.AbstractExtractInterfaceService/<ExtractInterfaceFromAnalyzedTypeAsync>d__7")]
public Task`1<ExtractInterfaceResult> ExtractInterfaceFromAnalyzedTypeAsync(ExtractInterfaceTypeAnalysisResult refactoringResult, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.ExtractInterface.AbstractExtractInterfaceService/<ExtractInterfaceFromAnalyzedTypeAsync>d__8")]
public Task`1<ExtractInterfaceResult> ExtractInterfaceFromAnalyzedTypeAsync(ExtractInterfaceTypeAnalysisResult refactoringResult, ExtractInterfaceOptionsResult extractInterfaceOptions, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.ExtractInterface.AbstractExtractInterfaceService/<ExtractInterfaceToNewFileAsync>d__9")]
private Task`1<ExtractInterfaceResult> ExtractInterfaceToNewFileAsync(Solution solution, string containingNamespaceDisplay, INamedTypeSymbol extractedInterfaceSymbol, ExtractInterfaceTypeAnalysisResult refactoringResult, ExtractInterfaceOptionsResult extractInterfaceOptions, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.ExtractInterface.AbstractExtractInterfaceService/<ExtractInterfaceToSameFileAsync>d__10")]
private Task`1<ExtractInterfaceResult> ExtractInterfaceToSameFileAsync(Solution solution, ExtractInterfaceTypeAnalysisResult refactoringResult, INamedTypeSymbol extractedInterfaceSymbol, ExtractInterfaceOptionsResult extractInterfaceOptions, CancellationToken cancellationToken);
    internal static Task`1<ExtractInterfaceOptionsResult> GetExtractInterfaceOptionsAsync(Document document, INamedTypeSymbol type, IEnumerable`1<ISymbol> extractableMembers, string containingNamespace, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.ExtractInterface.AbstractExtractInterfaceService/<GetFormattedSolutionAsync>d__12")]
private static Task`1<Solution> GetFormattedSolutionAsync(Solution unformattedSolution, IEnumerable`1<DocumentId> documentIds, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.ExtractInterface.AbstractExtractInterfaceService/<GetSolutionWithOriginalTypeUpdatedAsync>d__13")]
private Task`1<Solution> GetSolutionWithOriginalTypeUpdatedAsync(Solution solution, ImmutableArray`1<DocumentId> documentIds, SyntaxAnnotation typeNodeAnnotation, INamedTypeSymbol typeToExtractFrom, INamedTypeSymbol extractedInterfaceSymbol, IEnumerable`1<ISymbol> includedMembers, ImmutableDictionary`2<ISymbol, SyntaxAnnotation> symbolToDeclarationAnnotationMap, CancellationToken cancellationToken);
    private static ImmutableArray`1<ISymbol> CreateInterfaceMembers(IEnumerable`1<ISymbol> includedMembers);
    internal virtual bool IsExtractableMember(ISymbol m);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.CodeAnalysis.ExtractInterface.ExtractInterfaceCodeAction : CodeActionWithOptions {
    private ExtractInterfaceTypeAnalysisResult _typeAnalysisResult;
    private AbstractExtractInterfaceService _extractInterfaceService;
    public string Title { get; }
    public ExtractInterfaceCodeAction(AbstractExtractInterfaceService extractInterfaceService, ExtractInterfaceTypeAnalysisResult typeAnalysisResult);
    public virtual object GetOptions(CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.ExtractInterface.ExtractInterfaceCodeAction/<ComputeOperationsAsync>d__4")]
protected virtual Task`1<IEnumerable`1<CodeActionOperation>> ComputeOperationsAsync(object options, CancellationToken cancellationToken);
    public virtual string get_Title();
}
[ExportCodeRefactoringProviderAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.ExtractInterface.ExtractInterfaceCodeRefactoringProvider : CodeRefactoringProvider {
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.ExtractInterface.ExtractInterfaceCodeRefactoringProvider/<ComputeRefactoringsAsync>d__1")]
public sealed virtual Task ComputeRefactoringsAsync(CodeRefactoringContext context);
}
internal class Microsoft.CodeAnalysis.ExtractInterface.ExtractInterfaceOptionsResult : object {
    public static ExtractInterfaceOptionsResult Cancelled;
    [CompilerGeneratedAttribute]
private bool <IsCancelled>k__BackingField;
    [CompilerGeneratedAttribute]
private ImmutableArray`1<ISymbol> <IncludedMembers>k__BackingField;
    [CompilerGeneratedAttribute]
private string <InterfaceName>k__BackingField;
    [CompilerGeneratedAttribute]
private string <FileName>k__BackingField;
    [CompilerGeneratedAttribute]
private ExtractLocation <Location>k__BackingField;
    public bool IsCancelled { get; }
    public ImmutableArray`1<ISymbol> IncludedMembers { get; }
    public string InterfaceName { get; }
    public string FileName { get; }
    public ExtractLocation Location { get; }
    public ExtractInterfaceOptionsResult(bool isCancelled, ImmutableArray`1<ISymbol> includedMembers, string interfaceName, string fileName, ExtractLocation location);
    private ExtractInterfaceOptionsResult(bool isCancelled);
    private static ExtractInterfaceOptionsResult();
    [CompilerGeneratedAttribute]
public bool get_IsCancelled();
    [CompilerGeneratedAttribute]
public ImmutableArray`1<ISymbol> get_IncludedMembers();
    [CompilerGeneratedAttribute]
public string get_InterfaceName();
    [CompilerGeneratedAttribute]
public string get_FileName();
    [CompilerGeneratedAttribute]
public ExtractLocation get_Location();
}
internal class Microsoft.CodeAnalysis.ExtractInterface.ExtractInterfaceResult : object {
    [CompilerGeneratedAttribute]
private bool <Succeeded>k__BackingField;
    [CompilerGeneratedAttribute]
private Solution <UpdatedSolution>k__BackingField;
    [CompilerGeneratedAttribute]
private DocumentId <NavigationDocumentId>k__BackingField;
    public bool Succeeded { get; }
    public Solution UpdatedSolution { get; }
    public DocumentId NavigationDocumentId { get; }
    public ExtractInterfaceResult(bool succeeded, Solution updatedSolution, DocumentId navigationDocumentId);
    [CompilerGeneratedAttribute]
public bool get_Succeeded();
    [CompilerGeneratedAttribute]
public Solution get_UpdatedSolution();
    [CompilerGeneratedAttribute]
public DocumentId get_NavigationDocumentId();
}
internal class Microsoft.CodeAnalysis.ExtractInterface.ExtractInterfaceTypeAnalysisResult : object {
    public bool CanExtractInterface;
    public Document DocumentToExtractFrom;
    public SyntaxNode TypeNode;
    public INamedTypeSymbol TypeToExtractFrom;
    public IEnumerable`1<ISymbol> ExtractableMembers;
    public string ErrorMessage;
    public ExtractInterfaceTypeAnalysisResult(Document documentToExtractFrom, SyntaxNode typeNode, INamedTypeSymbol typeToExtractFrom, IEnumerable`1<ISymbol> extractableMembers);
    public ExtractInterfaceTypeAnalysisResult(string errorMessage);
}
internal interface Microsoft.CodeAnalysis.ExtractInterface.IExtractInterfaceOptionsService {
    public abstract virtual Task`1<ExtractInterfaceOptionsResult> GetExtractInterfaceOptionsAsync(ISyntaxFactsService syntaxFactsService, INotificationService notificationService, List`1<ISymbol> extractableMembers, string defaultInterfaceName, List`1<string> conflictingTypeNames, string defaultNamespace, string generatedNameTypeParameterSuffix, string languageName);
}
internal enum Microsoft.CodeAnalysis.ExtractInterface.TypeDiscoveryRule : Enum {
    public int value__;
    public static TypeDiscoveryRule TypeDeclaration;
    public static TypeDiscoveryRule TypeNameOnly;
}
internal abstract class Microsoft.CodeAnalysis.ExtractMethod.AbstractExtractMethodService`3 : object {
    protected abstract virtual TValidator CreateSelectionValidator(SemanticDocument document, TextSpan textSpan, OptionSet options);
    protected abstract virtual TExtractor CreateMethodExtractor(TResult selectionResult, bool localFunction);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.ExtractMethod.AbstractExtractMethodService`3/<ExtractMethodAsync>d__2")]
public sealed virtual Task`1<ExtractMethodResult> ExtractMethodAsync(Document document, TextSpan textSpan, bool localFunction, OptionSet options, CancellationToken cancellationToken);
}
internal abstract class Microsoft.CodeAnalysis.ExtractMethod.AbstractSyntaxTriviaService : object {
    private static int TriviaLocationsCount;
    private ISyntaxFacts _syntaxFacts;
    private int _endOfLineKind;
    protected AbstractSyntaxTriviaService(ISyntaxFacts syntaxFacts, int endOfLineKind);
    public sealed virtual ITriviaSavedResult SaveTriviaAroundSelection(SyntaxNode root, TextSpan textSpan);
    private static SyntaxNode ReplaceTokens(SyntaxNode root, IEnumerable`1<SyntaxToken> oldTokens, Func`3<SyntaxToken, SyntaxToken, SyntaxToken> computeReplacementToken);
    private ITriviaSavedResult CreateResult(SyntaxNode root, Dictionary`2<TriviaLocation, SyntaxAnnotation> annotations, Dictionary`2<TriviaLocation, IEnumerable`1<SyntaxTrivia>> triviaList);
    private static Dictionary`2<SyntaxToken, SyntaxToken> CreateOldToNewTokensMap(Dictionary`2<TriviaLocation, SyntaxToken> tokens, Dictionary`2<TriviaLocation, SyntaxAnnotation> annotations);
    private static Dictionary`2<TriviaLocation, IEnumerable`1<SyntaxTrivia>> GetTriviaAtEdges(Dictionary`2<TriviaLocation, SyntaxToken> tokens, TextSpan textSpan);
    private Dictionary`2<TriviaLocation, SyntaxToken> GetTokensAtEdges(SyntaxNode root, TextSpan textSpan);
    private static Tuple`2<List`1<SyntaxTrivia>, List`1<SyntaxTrivia>> SplitTrivia(SyntaxToken token1, SyntaxToken token2, Func`2<SyntaxTrivia, bool> conditionToLeftAtCallSite);
}
internal class Microsoft.CodeAnalysis.ExtractMethod.AnnotationResolver : MulticastDelegate {
    public AnnotationResolver(object object, IntPtr method);
    public virtual SyntaxToken Invoke(SyntaxNode root, TriviaLocation location, SyntaxAnnotation annotation);
    public virtual IAsyncResult BeginInvoke(SyntaxNode root, TriviaLocation location, SyntaxAnnotation annotation, AsyncCallback callback, object object);
    public virtual SyntaxToken EndInvoke(IAsyncResult result);
}
internal enum Microsoft.CodeAnalysis.ExtractMethod.DeclarationBehavior : Enum {
    public int value__;
    public static DeclarationBehavior None;
    public static DeclarationBehavior Delete;
    public static DeclarationBehavior MoveIn;
    public static DeclarationBehavior MoveOut;
    public static DeclarationBehavior SplitIn;
    public static DeclarationBehavior SplitOut;
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
internal static class Microsoft.CodeAnalysis.ExtractMethod.Extensions : object {
    [ExtensionAttribute]
public static bool Succeeded(OperationStatus status);
    [ExtensionAttribute]
public static bool FailedWithNoBestEffortSuggestion(OperationStatus status);
    [ExtensionAttribute]
public static bool Failed(OperationStatus status);
    [ExtensionAttribute]
public static bool Succeeded(OperationStatusFlag flag);
    [ExtensionAttribute]
public static bool Failed(OperationStatusFlag flag);
    [ExtensionAttribute]
public static bool HasBestEffort(OperationStatusFlag flag);
    [ExtensionAttribute]
public static bool HasSuggestion(OperationStatusFlag flag);
    [ExtensionAttribute]
public static bool HasMask(OperationStatusFlag flag, OperationStatusFlag mask);
    [ExtensionAttribute]
public static OperationStatusFlag RemoveFlag(OperationStatusFlag baseFlag, OperationStatusFlag flagToRemove);
    [ExtensionAttribute]
public static ITypeSymbol GetLambdaOrAnonymousMethodReturnType(SemanticModel binding, SyntaxNode node);
    [ExtensionAttribute]
public static Task`1<SemanticDocument> WithSyntaxRootAsync(SemanticDocument semanticDocument, SyntaxNode root, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static SyntaxToken GetTokenWithAnnotation(SemanticDocument document, SyntaxAnnotation annotation);
    [ExtensionAttribute]
public static T ResolveType(SemanticModel semanticModel, T symbol);
    [ExtensionAttribute]
public static bool HasDiagnostics(SyntaxNode node);
    [ExtensionAttribute]
public static bool FromScript(SyntaxNode node);
}
internal class Microsoft.CodeAnalysis.ExtractMethod.ExtractMethodMatrix : object {
    private static Dictionary`2<Key, VariableStyle> s_matrix;
    private static ExtractMethodMatrix();
    public static bool TryGetVariableStyle(bool bestEffort, bool dataFlowIn, bool dataFlowOut, bool alwaysAssigned, bool variableDeclared, bool readInside, bool writtenInside, bool readOutside, bool writtenOutside, bool unsafeAddressTaken, VariableStyle& variableStyle);
    private static void BuildMatrix();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal static class Microsoft.CodeAnalysis.ExtractMethod.ExtractMethodOptions : object {
    public static PerLanguageOption2`1<bool> AllowBestEffort;
    public static PerLanguageOption2`1<bool> DontPutOutOrRefOnStruct;
    private static ExtractMethodOptions();
}
[ExportOptionProviderAttribute]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.ExtractMethod.ExtractMethodOptionsProvider : object {
    [CompilerGeneratedAttribute]
private ImmutableArray`1<IOption> <Options>k__BackingField;
    public ImmutableArray`1<IOption> Options { get; }
    [CompilerGeneratedAttribute]
public sealed virtual ImmutableArray`1<IOption> get_Options();
}
internal class Microsoft.CodeAnalysis.ExtractMethod.ExtractMethodResult : object {
    [CompilerGeneratedAttribute]
private bool <Succeeded>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <SucceededWithSuggestion>k__BackingField;
    [CompilerGeneratedAttribute]
private Document <Document>k__BackingField;
    [CompilerGeneratedAttribute]
private IEnumerable`1<string> <Reasons>k__BackingField;
    [CompilerGeneratedAttribute]
private SyntaxNode <MethodDeclarationNode>k__BackingField;
    [CompilerGeneratedAttribute]
private SyntaxToken <InvocationNameToken>k__BackingField;
    [CompilerGeneratedAttribute]
private OperationStatusFlag <Status>k__BackingField;
    public bool Succeeded { get; }
    public bool SucceededWithSuggestion { get; }
    public Document Document { get; }
    public IEnumerable`1<string> Reasons { get; }
    public SyntaxNode MethodDeclarationNode { get; }
    public SyntaxToken InvocationNameToken { get; }
    internal OperationStatusFlag Status { get; }
    internal ExtractMethodResult(OperationStatusFlag status, IEnumerable`1<string> reasons, Document document, SyntaxToken invocationNameToken, SyntaxNode methodDeclarationNode);
    [CompilerGeneratedAttribute]
public bool get_Succeeded();
    [CompilerGeneratedAttribute]
public bool get_SucceededWithSuggestion();
    [CompilerGeneratedAttribute]
public Document get_Document();
    [CompilerGeneratedAttribute]
public IEnumerable`1<string> get_Reasons();
    [CompilerGeneratedAttribute]
public SyntaxNode get_MethodDeclarationNode();
    [CompilerGeneratedAttribute]
public SyntaxToken get_InvocationNameToken();
    [CompilerGeneratedAttribute]
internal OperationStatusFlag get_Status();
}
internal static class Microsoft.CodeAnalysis.ExtractMethod.ExtractMethodService : object {
    public static Task`1<ExtractMethodResult> ExtractMethodAsync(Document document, TextSpan textSpan, bool localFunction, OptionSet options, CancellationToken cancellationToken);
}
internal class Microsoft.CodeAnalysis.ExtractMethod.FailedExtractMethodResult : ExtractMethodResult {
    public FailedExtractMethodResult(OperationStatus status);
}
internal interface Microsoft.CodeAnalysis.ExtractMethod.IExtractMethodService {
    public abstract virtual Task`1<ExtractMethodResult> ExtractMethodAsync(Document document, TextSpan textSpan, bool localFunction, OptionSet options, CancellationToken cancellationToken);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.CodeAnalysis.ExtractMethod.InsertionPoint : object {
    private SyntaxAnnotation _annotation;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private Lazy`1<SyntaxNode> _context;
    [CompilerGeneratedAttribute]
private SemanticDocument <SemanticDocument>k__BackingField;
    public SemanticDocument SemanticDocument { get; }
    private InsertionPoint(SemanticDocument document, SyntaxAnnotation annotation);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.ExtractMethod.InsertionPoint/<CreateAsync>d__2")]
public static Task`1<InsertionPoint> CreateAsync(SemanticDocument document, SyntaxNode node, CancellationToken cancellationToken);
    [CompilerGeneratedAttribute]
public SemanticDocument get_SemanticDocument();
    public SyntaxNode GetRoot();
    [NullableContextAttribute("2")]
public SyntaxNode GetContext();
    public InsertionPoint With(SemanticDocument document);
    private Lazy`1<SyntaxNode> CreateLazyContextNode();
    [NullableContextAttribute("2")]
private SyntaxNode ComputeContextNode();
}
internal interface Microsoft.CodeAnalysis.ExtractMethod.ISyntaxTriviaService {
    public abstract virtual ITriviaSavedResult SaveTriviaAroundSelection(SyntaxNode root, TextSpan textSpan);
}
internal interface Microsoft.CodeAnalysis.ExtractMethod.ITriviaSavedResult {
    public SyntaxNode Root { get; }
    public abstract virtual SyntaxNode get_Root();
    public abstract virtual SyntaxNode RestoreTrivia(SyntaxNode root, AnnotationResolver annotationResolver, TriviaResolver triviaResolver);
}
internal class Microsoft.CodeAnalysis.ExtractMethod.LeadingTrailingTriviaPair : ValueType {
    [CompilerGeneratedAttribute]
private IEnumerable`1<SyntaxTrivia> <LeadingTrivia>k__BackingField;
    [CompilerGeneratedAttribute]
private IEnumerable`1<SyntaxTrivia> <TrailingTrivia>k__BackingField;
    public IEnumerable`1<SyntaxTrivia> LeadingTrivia { get; public set; }
    public IEnumerable`1<SyntaxTrivia> TrailingTrivia { get; public set; }
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public IEnumerable`1<SyntaxTrivia> get_LeadingTrivia();
    [CompilerGeneratedAttribute]
public void set_LeadingTrivia(IEnumerable`1<SyntaxTrivia> value);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public IEnumerable`1<SyntaxTrivia> get_TrailingTrivia();
    [CompilerGeneratedAttribute]
public void set_TrailingTrivia(IEnumerable`1<SyntaxTrivia> value);
}
internal abstract class Microsoft.CodeAnalysis.ExtractMethod.MethodExtractor : object {
    protected SelectionResult OriginalSelectionResult;
    protected bool LocalFunction;
    public MethodExtractor(SelectionResult selectionResult, bool localFunction);
    protected abstract virtual Task`1<AnalyzerResult> AnalyzeAsync(SelectionResult selectionResult, bool localFunction, CancellationToken cancellationToken);
    protected abstract virtual Task`1<InsertionPoint> GetInsertionPointAsync(SemanticDocument document, CancellationToken cancellationToken);
    protected abstract virtual Task`1<TriviaResult> PreserveTriviaAsync(SelectionResult selectionResult, CancellationToken cancellationToken);
    protected abstract virtual Task`1<SemanticDocument> ExpandAsync(SelectionResult selection, CancellationToken cancellationToken);
    protected abstract virtual Task`1<GeneratedCode> GenerateCodeAsync(InsertionPoint insertionPoint, SelectionResult selectionResult, AnalyzerResult analyzeResult, OptionSet options, CancellationToken cancellationToken);
    protected abstract virtual SyntaxToken GetMethodNameAtInvocation(IEnumerable`1<SyntaxNodeOrToken> methodNames);
    protected abstract virtual IEnumerable`1<AbstractFormattingRule> GetFormattingRules(Document document);
    protected abstract virtual Task`1<OperationStatus> CheckTypeAsync(Document document, SyntaxNode contextNode, Location location, ITypeSymbol type, CancellationToken cancellationToken);
    protected abstract virtual Task`1<ValueTuple`3<Document, SyntaxToken, SyntaxNode>> InsertNewLineBeforeLocalFunctionIfNecessaryAsync(Document document, SyntaxToken methodName, SyntaxNode methodDefinition, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.ExtractMethod.MethodExtractor/<ExtractMethodAsync>d__15")]
public Task`1<ExtractMethodResult> ExtractMethodAsync(CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.ExtractMethod.MethodExtractor/<CreateExtractMethodResultAsync>d__16")]
private Task`1<ExtractMethodResult> CreateExtractMethodResultAsync(OperationStatus status, SemanticDocument semanticDocument, SyntaxAnnotation invocationAnnotation, SyntaxAnnotation methodAnnotation, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.ExtractMethod.MethodExtractor/<CheckVariableTypesAsync>d__17")]
private Task`1<OperationStatus> CheckVariableTypesAsync(OperationStatus status, AnalyzerResult analyzeResult, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.ExtractMethod.MethodExtractor/<TryCheckVariableTypeAsync>d__18")]
private Task`1<Tuple`2<bool, OperationStatus>> TryCheckVariableTypeAsync(SemanticDocument document, SyntaxNode contextNode, IEnumerable`1<VariableInfo> variables, OperationStatus status, CancellationToken cancellationToken);
    internal static string MakeMethodName(string prefix, string originalName, bool camelCase);
}
internal class Microsoft.CodeAnalysis.ExtractMethod.OperationStatus : object {
    [CompilerGeneratedAttribute]
private OperationStatusFlag <Flag>k__BackingField;
    [CompilerGeneratedAttribute]
private IEnumerable`1<string> <Reasons>k__BackingField;
    public static OperationStatus Succeeded;
    public static OperationStatus FailedWithUnknownReason;
    public static OperationStatus OverlapsHiddenPosition;
    public static OperationStatus NoValidLocationToInsertMethodCall;
    public static OperationStatus NoActiveStatement;
    public static OperationStatus ErrorOrUnknownType;
    public static OperationStatus UnsafeAddressTaken;
    public static OperationStatus LocalFunctionCallWithoutDeclaration;
    public OperationStatusFlag Flag { get; }
    public IEnumerable`1<string> Reasons { get; }
    public OperationStatus(OperationStatusFlag flag, string reason);
    private OperationStatus(OperationStatusFlag flag, IEnumerable`1<string> reasons);
    private static OperationStatus();
    public OperationStatus With(OperationStatusFlag flag, string reason);
    public OperationStatus With(OperationStatus operationStatus);
    public OperationStatus MakeFail();
    public OperationStatus MarkSuggestion();
    public OperationStatus`1<T> With(T data);
    [CompilerGeneratedAttribute]
public OperationStatusFlag get_Flag();
    [CompilerGeneratedAttribute]
public IEnumerable`1<string> get_Reasons();
    public static OperationStatus`1<T> Create(OperationStatus status, T data);
}
internal class Microsoft.CodeAnalysis.ExtractMethod.OperationStatus`1 : object {
    [CompilerGeneratedAttribute]
private OperationStatus <Status>k__BackingField;
    [CompilerGeneratedAttribute]
private T <Data>k__BackingField;
    public OperationStatus Status { get; }
    public T Data { get; }
    public OperationStatus`1(OperationStatus status, T data);
    [CompilerGeneratedAttribute]
public OperationStatus get_Status();
    [CompilerGeneratedAttribute]
public T get_Data();
    public OperationStatus`1<T> With(OperationStatus status);
    public OperationStatus`1<TNew> With(TNew data);
}
[FlagsAttribute]
internal enum Microsoft.CodeAnalysis.ExtractMethod.OperationStatusFlag : Enum {
    public int value__;
    public static OperationStatusFlag None;
    public static OperationStatusFlag Succeeded;
    public static OperationStatusFlag Suggestion;
    public static OperationStatusFlag BestEffort;
}
internal enum Microsoft.CodeAnalysis.ExtractMethod.ParameterBehavior : Enum {
    public int value__;
    public static ParameterBehavior None;
    public static ParameterBehavior Input;
    public static ParameterBehavior Out;
    public static ParameterBehavior Ref;
}
internal class Microsoft.CodeAnalysis.ExtractMethod.ParameterStyle : object {
    [CompilerGeneratedAttribute]
private ParameterBehavior <ParameterBehavior>k__BackingField;
    [CompilerGeneratedAttribute]
private DeclarationBehavior <DeclarationBehavior>k__BackingField;
    [CompilerGeneratedAttribute]
private DeclarationBehavior <SaferDeclarationBehavior>k__BackingField;
    public static ParameterStyle None;
    public static ParameterStyle InputOnly;
    public static ParameterStyle Delete;
    public static ParameterStyle MoveOut;
    public static ParameterStyle SplitOut;
    public static ParameterStyle MoveIn;
    public static ParameterStyle SplitIn;
    public static ParameterStyle Out;
    public static ParameterStyle Ref;
    public static ParameterStyle OutWithMoveOut;
    public ParameterBehavior ParameterBehavior { get; private set; }
    public DeclarationBehavior DeclarationBehavior { get; private set; }
    public DeclarationBehavior SaferDeclarationBehavior { get; private set; }
    private static ParameterStyle();
    [CompilerGeneratedAttribute]
public ParameterBehavior get_ParameterBehavior();
    [CompilerGeneratedAttribute]
private void set_ParameterBehavior(ParameterBehavior value);
    [CompilerGeneratedAttribute]
public DeclarationBehavior get_DeclarationBehavior();
    [CompilerGeneratedAttribute]
private void set_DeclarationBehavior(DeclarationBehavior value);
    [CompilerGeneratedAttribute]
public DeclarationBehavior get_SaferDeclarationBehavior();
    [CompilerGeneratedAttribute]
private void set_SaferDeclarationBehavior(DeclarationBehavior value);
}
internal class Microsoft.CodeAnalysis.ExtractMethod.PreviousNextTokenPair : ValueType {
    [CompilerGeneratedAttribute]
private SyntaxToken <PreviousToken>k__BackingField;
    [CompilerGeneratedAttribute]
private SyntaxToken <NextToken>k__BackingField;
    public SyntaxToken PreviousToken { get; public set; }
    public SyntaxToken NextToken { get; public set; }
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public SyntaxToken get_PreviousToken();
    [CompilerGeneratedAttribute]
public void set_PreviousToken(SyntaxToken value);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public SyntaxToken get_NextToken();
    [CompilerGeneratedAttribute]
public void set_NextToken(SyntaxToken value);
}
internal enum Microsoft.CodeAnalysis.ExtractMethod.ReturnBehavior : Enum {
    public int value__;
    public static ReturnBehavior None;
    public static ReturnBehavior Initialization;
    public static ReturnBehavior Assignment;
}
internal class Microsoft.CodeAnalysis.ExtractMethod.ReturnStyle : object {
    [CompilerGeneratedAttribute]
private ParameterBehavior <ParameterBehavior>k__BackingField;
    [CompilerGeneratedAttribute]
private ReturnBehavior <ReturnBehavior>k__BackingField;
    [CompilerGeneratedAttribute]
private DeclarationBehavior <DeclarationBehavior>k__BackingField;
    public static ReturnStyle None;
    public static ReturnStyle AssignmentWithInput;
    public static ReturnStyle AssignmentWithNoInput;
    public static ReturnStyle Initialization;
    public ParameterBehavior ParameterBehavior { get; private set; }
    public ReturnBehavior ReturnBehavior { get; private set; }
    public DeclarationBehavior DeclarationBehavior { get; private set; }
    private static ReturnStyle();
    [CompilerGeneratedAttribute]
public ParameterBehavior get_ParameterBehavior();
    [CompilerGeneratedAttribute]
private void set_ParameterBehavior(ParameterBehavior value);
    [CompilerGeneratedAttribute]
public ReturnBehavior get_ReturnBehavior();
    [CompilerGeneratedAttribute]
private void set_ReturnBehavior(ReturnBehavior value);
    [CompilerGeneratedAttribute]
public DeclarationBehavior get_DeclarationBehavior();
    [CompilerGeneratedAttribute]
private void set_DeclarationBehavior(DeclarationBehavior value);
}
internal abstract class Microsoft.CodeAnalysis.ExtractMethod.SelectionResult : object {
    [CompilerGeneratedAttribute]
private OperationStatus <Status>k__BackingField;
    [CompilerGeneratedAttribute]
private TextSpan <OriginalSpan>k__BackingField;
    [CompilerGeneratedAttribute]
private TextSpan <FinalSpan>k__BackingField;
    [CompilerGeneratedAttribute]
private OptionSet <Options>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <SelectionInExpression>k__BackingField;
    [CompilerGeneratedAttribute]
private SemanticDocument <SemanticDocument>k__BackingField;
    [CompilerGeneratedAttribute]
private SyntaxAnnotation <FirstTokenAnnotation>k__BackingField;
    [CompilerGeneratedAttribute]
private SyntaxAnnotation <LastTokenAnnotation>k__BackingField;
    public OperationStatus Status { get; }
    public TextSpan OriginalSpan { get; }
    public TextSpan FinalSpan { get; }
    public OptionSet Options { get; }
    public bool SelectionInExpression { get; }
    public SemanticDocument SemanticDocument { get; private set; }
    public SyntaxAnnotation FirstTokenAnnotation { get; }
    public SyntaxAnnotation LastTokenAnnotation { get; }
    public bool ContainsValidContext { get; }
    public bool DontPutOutOrRefOnStruct { get; }
    protected SelectionResult(OperationStatus status);
    protected SelectionResult(OperationStatus status, TextSpan originalSpan, TextSpan finalSpan, OptionSet options, bool selectionInExpression, SemanticDocument document, SyntaxAnnotation firstTokenAnnotation, SyntaxAnnotation lastTokenAnnotation);
    protected abstract virtual bool UnderAnonymousOrLocalMethod(SyntaxToken token, SyntaxToken firstToken, SyntaxToken lastToken);
    public abstract virtual bool ContainingScopeHasAsyncKeyword();
    public abstract virtual SyntaxNode GetContainingScope();
    public abstract virtual ITypeSymbol GetContainingScopeType();
    [CompilerGeneratedAttribute]
public OperationStatus get_Status();
    [CompilerGeneratedAttribute]
public TextSpan get_OriginalSpan();
    [CompilerGeneratedAttribute]
public TextSpan get_FinalSpan();
    [CompilerGeneratedAttribute]
public OptionSet get_Options();
    [CompilerGeneratedAttribute]
public bool get_SelectionInExpression();
    [CompilerGeneratedAttribute]
public SemanticDocument get_SemanticDocument();
    [CompilerGeneratedAttribute]
private void set_SemanticDocument(SemanticDocument value);
    [CompilerGeneratedAttribute]
public SyntaxAnnotation get_FirstTokenAnnotation();
    [CompilerGeneratedAttribute]
public SyntaxAnnotation get_LastTokenAnnotation();
    public SelectionResult With(SemanticDocument document);
    public bool get_ContainsValidContext();
    public SyntaxToken GetFirstTokenInSelection();
    public SyntaxToken GetLastTokenInSelection();
    public TNode GetContainingScopeOf();
    protected T GetFirstStatement();
    protected T GetLastStatement();
    public bool ShouldPutAsyncModifier();
    public bool ShouldCallConfigureAwaitFalse();
    private bool IsConfigureAwaitFalse(SyntaxNode node);
    public bool get_DontPutOutOrRefOnStruct();
}
internal abstract class Microsoft.CodeAnalysis.ExtractMethod.SelectionValidator : object {
    protected static SelectionResult NullSelection;
    protected SemanticDocument SemanticDocument;
    protected TextSpan OriginalSpan;
    protected OptionSet Options;
    public bool ContainsValidSelection { get; }
    protected SelectionValidator(SemanticDocument document, TextSpan textSpan, OptionSet options);
    private static SelectionValidator();
    public bool get_ContainsValidSelection();
    public abstract virtual Task`1<SelectionResult> GetValidSelectionAsync(CancellationToken cancellationToken);
    public abstract virtual IEnumerable`1<SyntaxNode> GetOuterReturnStatements(SyntaxNode commonRoot, IEnumerable`1<SyntaxNode> jumpsOutOfRegion);
    public abstract virtual bool IsFinalSpanSemanticallyValidSpan(SyntaxNode node, TextSpan textSpan, IEnumerable`1<SyntaxNode> returnStatements, CancellationToken cancellationToken);
    public abstract virtual bool ContainsNonReturnExitPointsStatements(IEnumerable`1<SyntaxNode> jumpsOutOfRegion);
    protected bool IsFinalSpanSemanticallyValidSpan(SemanticModel semanticModel, TextSpan textSpan, Tuple`2<SyntaxNode, SyntaxNode> range, CancellationToken cancellationToken);
    protected static Tuple`2<SyntaxNode, SyntaxNode> GetStatementRangeContainingSpan(SyntaxNode root, TextSpan textSpan, CancellationToken cancellationToken);
    protected static Tuple`2<SyntaxNode, SyntaxNode> GetStatementRangeContainedInSpan(SyntaxNode root, TextSpan textSpan, CancellationToken cancellationToken);
}
internal class Microsoft.CodeAnalysis.ExtractMethod.SimpleExtractMethodResult : ExtractMethodResult {
    public SimpleExtractMethodResult(OperationStatus status, Document document, SyntaxToken invocationNameToken, SyntaxNode methodDefinition);
}
internal enum Microsoft.CodeAnalysis.ExtractMethod.TriviaLocation : Enum {
    public int value__;
    public static TriviaLocation BeforeBeginningOfSpan;
    public static TriviaLocation AfterBeginningOfSpan;
    public static TriviaLocation BeforeEndOfSpan;
    public static TriviaLocation AfterEndOfSpan;
}
internal class Microsoft.CodeAnalysis.ExtractMethod.TriviaResolver : MulticastDelegate {
    public TriviaResolver(object object, IntPtr method);
    public virtual IEnumerable`1<SyntaxTrivia> Invoke(TriviaLocation location, PreviousNextTokenPair tokenPair, Dictionary`2<SyntaxToken, LeadingTrailingTriviaPair> triviaMap);
    public virtual IAsyncResult BeginInvoke(TriviaLocation location, PreviousNextTokenPair tokenPair, Dictionary`2<SyntaxToken, LeadingTrailingTriviaPair> triviaMap, AsyncCallback callback, object object);
    public virtual IEnumerable`1<SyntaxTrivia> EndInvoke(IAsyncResult result);
}
internal class Microsoft.CodeAnalysis.ExtractMethod.UniqueNameGenerator : object {
    private SemanticModel _semanticModel;
    public UniqueNameGenerator(SemanticModel semanticModel);
    public string CreateUniqueMethodName(SyntaxNode contextNode, string baseName);
}
internal class Microsoft.CodeAnalysis.ExtractMethod.VariableStyle : object {
    [CompilerGeneratedAttribute]
private ParameterStyle <ParameterStyle>k__BackingField;
    [CompilerGeneratedAttribute]
private ReturnStyle <ReturnStyle>k__BackingField;
    public static VariableStyle None;
    public static VariableStyle InputOnly;
    public static VariableStyle Delete;
    public static VariableStyle MoveOut;
    public static VariableStyle SplitOut;
    public static VariableStyle MoveIn;
    public static VariableStyle SplitIn;
    public static VariableStyle NotUsed;
    public static VariableStyle Ref;
    public static VariableStyle OnlyAsRefParam;
    public static VariableStyle Out;
    public static VariableStyle OutWithErrorInput;
    public static VariableStyle OutWithMoveOut;
    public ParameterStyle ParameterStyle { get; private set; }
    public ReturnStyle ReturnStyle { get; private set; }
    private static VariableStyle();
    [CompilerGeneratedAttribute]
public ParameterStyle get_ParameterStyle();
    [CompilerGeneratedAttribute]
private void set_ParameterStyle(ParameterStyle value);
    [CompilerGeneratedAttribute]
public ReturnStyle get_ReturnStyle();
    [CompilerGeneratedAttribute]
private void set_ReturnStyle(ReturnStyle value);
}
internal abstract class Microsoft.CodeAnalysis.Features.EmbeddedLanguages.AbstractEmbeddedLanguageFeaturesProvider : AbstractEmbeddedLanguagesProvider {
    [CompilerGeneratedAttribute]
private ImmutableArray`1<IEmbeddedLanguage> <Languages>k__BackingField;
    public ImmutableArray`1<IEmbeddedLanguage> Languages { get; }
    protected AbstractEmbeddedLanguageFeaturesProvider(EmbeddedLanguageInfo info);
    [CompilerGeneratedAttribute]
public virtual ImmutableArray`1<IEmbeddedLanguage> get_Languages();
    internal abstract virtual string EscapeText(string text, SyntaxToken token);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.CodeAnalysis.Features.EmbeddedLanguages.DateAndTime.DateAndTimeEmbeddedCompletionProvider : LSPCompletionProvider {
    private static string StartKey;
    private static string LengthKey;
    private static string NewTextKey;
    private static string DescriptionKey;
    private static CompletionItemRules s_rules;
    private DateAndTimeEmbeddedLanguageFeatures _language;
    [CompilerGeneratedAttribute]
private ImmutableHashSet`1<char> <TriggerCharacters>k__BackingField;
    public ImmutableHashSet`1<char> TriggerCharacters { get; }
    public DateAndTimeEmbeddedCompletionProvider(DateAndTimeEmbeddedLanguageFeatures language);
    private static DateAndTimeEmbeddedCompletionProvider();
    [CompilerGeneratedAttribute]
public virtual ImmutableHashSet`1<char> get_TriggerCharacters();
    public virtual bool ShouldTriggerCompletion(SourceText text, int caretPosition, CompletionTrigger trigger, OptionSet options);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.Features.EmbeddedLanguages.DateAndTime.DateAndTimeEmbeddedCompletionProvider/<ProvideCompletionsAsync>d__11")]
public virtual Task ProvideCompletionsAsync(CompletionContext context);
    private static void ProvideStandardFormats(EmbeddedCompletionContext context);
    private static void ProvideCustomFormats(EmbeddedCompletionContext context);
    public virtual Task`1<CompletionChange> GetChangeAsync(Document document, CompletionItem item, Nullable`1<char> commitKey, CancellationToken cancellationToken);
    public virtual Task`1<CompletionDescription> GetDescriptionAsync(Document document, CompletionItem item, CancellationToken cancellationToken);
}
internal class Microsoft.CodeAnalysis.Features.EmbeddedLanguages.DateAndTime.DateAndTimeEmbeddedLanguageFeatures : DateAndTimeEmbeddedLanguage {
    [NullableAttribute("2")]
[CompilerGeneratedAttribute]
private IDocumentHighlightsService <DocumentHighlightsService>k__BackingField;
    [NullableAttribute("1")]
[CompilerGeneratedAttribute]
private CompletionProvider <CompletionProvider>k__BackingField;
    [NullableAttribute("2")]
public IDocumentHighlightsService DocumentHighlightsService { get; }
    [NullableAttribute("1")]
public CompletionProvider CompletionProvider { get; }
    public DateAndTimeEmbeddedLanguageFeatures(EmbeddedLanguageInfo info);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public sealed virtual IDocumentHighlightsService get_DocumentHighlightsService();
    [NullableContextAttribute("1")]
[CompilerGeneratedAttribute]
public sealed virtual CompletionProvider get_CompletionProvider();
}
internal interface Microsoft.CodeAnalysis.Features.EmbeddedLanguages.IEmbeddedLanguageFeatures {
    public IDocumentHighlightsService DocumentHighlightsService { get; }
    public CompletionProvider CompletionProvider { get; }
    public abstract virtual IDocumentHighlightsService get_DocumentHighlightsService();
    public abstract virtual CompletionProvider get_CompletionProvider();
}
internal abstract class Microsoft.CodeAnalysis.Features.EmbeddedLanguages.RegularExpressions.AbstractRegexDiagnosticAnalyzer : AbstractBuiltInCodeStyleDiagnosticAnalyzer {
    public static string DiagnosticId;
    private EmbeddedLanguageInfo _info;
    protected AbstractRegexDiagnosticAnalyzer(EmbeddedLanguageInfo info);
    public virtual DiagnosticAnalyzerCategory GetAnalyzerCategory();
    protected virtual void InitializeWorker(AnalysisContext context);
    public void Analyze(SemanticModelAnalysisContext context);
    private void AnalyzeToken(SemanticModelAnalysisContext context, RegexPatternDetector detector, SyntaxToken token, CancellationToken cancellationToken);
}
internal class Microsoft.CodeAnalysis.Features.EmbeddedLanguages.RegularExpressions.RegexDocumentHighlightsService : object {
    private RegexEmbeddedLanguage _language;
    public RegexDocumentHighlightsService(RegexEmbeddedLanguage language);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.Features.EmbeddedLanguages.RegularExpressions.RegexDocumentHighlightsService/<GetDocumentHighlightsAsync>d__2")]
public sealed virtual Task`1<ImmutableArray`1<DocumentHighlights>> GetDocumentHighlightsAsync(Document document, int position, IImmutableSet`1<Document> documentsToSearch, CancellationToken cancellationToken);
    private ImmutableArray`1<HighlightSpan> GetHighlights(RegexTree tree, int positionInDocument);
    private ImmutableArray`1<HighlightSpan> GetReferences(RegexTree tree, int position);
    private ImmutableArray`1<HighlightSpan> FindReferenceHighlights(RegexTree tree, VirtualChar ch);
    private static ImmutableArray`1<HighlightSpan> CreateHighlights(RegexEscapeNode node, TextSpan captureSpan);
    private static HighlightSpan CreateHighlightSpan(TextSpan textSpan);
    private static EmbeddedSyntaxToken`1<RegexKind> GetCaptureToken(RegexEscapeNode node);
    private RegexEscapeNode FindReferenceNode(RegexNode node, VirtualChar virtualChar);
}
internal class Microsoft.CodeAnalysis.Features.EmbeddedLanguages.RegularExpressions.RegexEmbeddedCompletionProvider : LSPCompletionProvider {
    private static string StartKey;
    private static string LengthKey;
    private static string NewTextKey;
    private static string NewPositionKey;
    private static string DescriptionKey;
    private static CompletionItemRules s_rules;
    private RegexEmbeddedLanguage _language;
    [CompilerGeneratedAttribute]
private ImmutableHashSet`1<char> <TriggerCharacters>k__BackingField;
    public ImmutableHashSet`1<char> TriggerCharacters { get; }
    public RegexEmbeddedCompletionProvider(RegexEmbeddedLanguage language);
    private static RegexEmbeddedCompletionProvider();
    [CompilerGeneratedAttribute]
public virtual ImmutableHashSet`1<char> get_TriggerCharacters();
    public virtual bool ShouldTriggerCompletion(SourceText text, int caretPosition, CompletionTrigger trigger, OptionSet options);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.Features.EmbeddedLanguages.RegularExpressions.RegexEmbeddedCompletionProvider/<ProvideCompletionsAsync>d__13")]
public virtual Task ProvideCompletionsAsync(CompletionContext context);
    private void ProvideCompletions(EmbeddedCompletionContext context);
    private void ProvideCompletionsBasedOffOfPrecedingCharacter(EmbeddedCompletionContext context);
    private static void ProvideTopLevelCompletions(EmbeddedCompletionContext context, bool inCharacterClass);
    private void ProvideOpenBraceCompletions(EmbeddedCompletionContext context, RegexTree tree, VirtualChar previousVirtualChar);
    private static void ProvideEscapeCategoryCompletions(EmbeddedCompletionContext context);
    private static void ProvideOpenParenCompletions(EmbeddedCompletionContext context, bool inCharacterClass, RegexNode parentOpt);
    private static void ProvideOpenBracketCompletions(EmbeddedCompletionContext context, bool inCharacterClass, RegexNode parentOpt);
    private static void ProvideBackslashCompletions(EmbeddedCompletionContext context, bool inCharacterClass, RegexNode parentOpt);
    private Nullable`1<ValueTuple`2<RegexNode, EmbeddedSyntaxToken`1<RegexKind>>> FindToken(RegexNode parent, VirtualChar ch);
    private static bool IsInCharacterClass(RegexNode start, VirtualChar ch);
    public virtual Task`1<CompletionChange> GetChangeAsync(Document document, CompletionItem item, Nullable`1<char> commitKey, CancellationToken cancellationToken);
    public virtual Task`1<CompletionDescription> GetDescriptionAsync(Document document, CompletionItem item, CancellationToken cancellationToken);
    [CompilerGeneratedAttribute]
internal static bool <IsInCharacterClass>g__IsInCharacterClassWorker|23_0(RegexNode parent, bool inCharacterClass, <>c__DisplayClass23_0& );
}
internal class Microsoft.CodeAnalysis.Features.EmbeddedLanguages.RegularExpressions.RegexEmbeddedLanguage : object {
    public EmbeddedLanguageInfo Info;
    private AbstractEmbeddedLanguageFeaturesProvider _provider;
    [CompilerGeneratedAttribute]
private ISyntaxClassifier <Classifier>k__BackingField;
    [CompilerGeneratedAttribute]
private IDocumentHighlightsService <DocumentHighlightsService>k__BackingField;
    [CompilerGeneratedAttribute]
private CompletionProvider <CompletionProvider>k__BackingField;
    public ISyntaxClassifier Classifier { get; }
    public IDocumentHighlightsService DocumentHighlightsService { get; }
    public CompletionProvider CompletionProvider { get; }
    public RegexEmbeddedLanguage(AbstractEmbeddedLanguageFeaturesProvider provider, EmbeddedLanguageInfo info);
    [CompilerGeneratedAttribute]
public sealed virtual ISyntaxClassifier get_Classifier();
    [CompilerGeneratedAttribute]
public sealed virtual IDocumentHighlightsService get_DocumentHighlightsService();
    [CompilerGeneratedAttribute]
public sealed virtual CompletionProvider get_CompletionProvider();
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.Features.EmbeddedLanguages.RegularExpressions.RegexEmbeddedLanguage/<TryGetTreeAndTokenAtPositionAsync>d__12")]
internal Task`1<ValueTuple`2<RegexTree, SyntaxToken>> TryGetTreeAndTokenAtPositionAsync(Document document, int position, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.Features.EmbeddedLanguages.RegularExpressions.RegexEmbeddedLanguage/<TryGetTreeAtPositionAsync>d__13")]
internal Task`1<RegexTree> TryGetTreeAtPositionAsync(Document document, int position, CancellationToken cancellationToken);
    public string EscapeText(string text, SyntaxToken token);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal abstract class Microsoft.CodeAnalysis.Features.RQName.Nodes.RQArrayOrPointerType : RQType {
    public RQType ElementType;
    public RQArrayOrPointerType(RQType elementType);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.CodeAnalysis.Features.RQName.Nodes.RQArrayType : RQArrayOrPointerType {
    public int Rank;
    public RQArrayType(int rank, RQType elementType);
    public virtual SimpleTreeNode ToSimpleTree();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.CodeAnalysis.Features.RQName.Nodes.RQConstructedType : RQType {
    public RQUnconstructedType DefiningType;
    public ReadOnlyCollection`1<RQType> TypeArguments;
    public RQConstructedType(RQUnconstructedType definingType, IList`1<RQType> typeArguments);
    public virtual SimpleTreeNode ToSimpleTree();
}
internal class Microsoft.CodeAnalysis.Features.RQName.Nodes.RQConstructor : RQMethodBase {
    [NullableContextAttribute("1")]
public RQConstructor(RQUnconstructedType containingType, RQMethodPropertyOrEventName memberName, int typeParameterCount, IList`1<RQParameter> parameters);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.CodeAnalysis.Features.RQName.Nodes.RQErrorType : RQType {
    public string Name;
    public RQErrorType(string name);
    public virtual SimpleTreeNode ToSimpleTree();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.CodeAnalysis.Features.RQName.Nodes.RQEvent : RQMethodPropertyOrEvent {
    protected string RQKeyword { get; }
    public RQEvent(RQUnconstructedType containingType, RQMethodPropertyOrEventName memberName);
    protected virtual string get_RQKeyword();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.CodeAnalysis.Features.RQName.Nodes.RQExplicitInterfaceMemberName : RQMethodPropertyOrEventName {
    public RQType InterfaceType;
    public RQOrdinaryMethodPropertyOrEventName Name;
    public string OrdinaryNameValue { get; }
    public RQExplicitInterfaceMemberName(RQType interfaceType, RQOrdinaryMethodPropertyOrEventName name);
    public virtual string get_OrdinaryNameValue();
    public virtual SimpleGroupNode ToSimpleTree();
}
internal class Microsoft.CodeAnalysis.Features.RQName.Nodes.RQIndexer : RQPropertyBase {
    [NullableContextAttribute("1")]
public RQIndexer(RQUnconstructedType containingType, RQMethodPropertyOrEventName memberName, int typeParameterCount, IList`1<RQParameter> parameters);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal abstract class Microsoft.CodeAnalysis.Features.RQName.Nodes.RQMember : RQNode {
    public RQUnconstructedType ContainingType;
    public string MemberName { get; }
    public RQMember(RQUnconstructedType containingType);
    public abstract virtual string get_MemberName();
    protected virtual void AppendChildren(List`1<SimpleTreeNode> childList);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.CodeAnalysis.Features.RQName.Nodes.RQMemberParameterIndex : RQNode {
    public RQMember ContainingMember;
    public int ParameterIndex;
    protected string RQKeyword { get; }
    public RQMemberParameterIndex(RQMember containingMember, int parameterIndex);
    protected virtual string get_RQKeyword();
    protected virtual void AppendChildren(List`1<SimpleTreeNode> childList);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.CodeAnalysis.Features.RQName.Nodes.RQMemberParameterIndexFromPartialImplementation : RQMemberParameterIndex {
    public RQMemberParameterIndexFromPartialImplementation(RQMember containingMember, int parameterIndex);
    protected virtual void AppendChildren(List`1<SimpleTreeNode> childList);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.CodeAnalysis.Features.RQName.Nodes.RQMemberParameterIndexFromPartialSignature : RQMemberParameterIndex {
    public RQMemberParameterIndexFromPartialSignature(RQMember containingMember, int parameterIndex);
    protected virtual void AppendChildren(List`1<SimpleTreeNode> childList);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.CodeAnalysis.Features.RQName.Nodes.RQMemberVariable : RQMember {
    public string Name;
    public string MemberName { get; }
    protected string RQKeyword { get; }
    public RQMemberVariable(RQUnconstructedType containingType, string name);
    public virtual string get_MemberName();
    protected virtual string get_RQKeyword();
    protected virtual void AppendChildren(List`1<SimpleTreeNode> childList);
}
internal class Microsoft.CodeAnalysis.Features.RQName.Nodes.RQMethod : RQMethodBase {
    [NullableContextAttribute("1")]
public RQMethod(RQUnconstructedType containingType, RQMethodPropertyOrEventName memberName, int typeParameterCount, IList`1<RQParameter> parameters);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal abstract class Microsoft.CodeAnalysis.Features.RQName.Nodes.RQMethodBase : RQMethodOrProperty {
    protected string RQKeyword { get; }
    public RQMethodBase(RQUnconstructedType containingType, RQMethodPropertyOrEventName memberName, int typeParameterCount, IList`1<RQParameter> parameters);
    protected virtual string get_RQKeyword();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal abstract class Microsoft.CodeAnalysis.Features.RQName.Nodes.RQMethodOrProperty : RQMethodPropertyOrEvent {
    public int TypeParameterCount;
    public ReadOnlyCollection`1<RQParameter> Parameters;
    public RQMethodOrProperty(RQUnconstructedType containingType, RQMethodPropertyOrEventName memberName, int typeParameterCount, IList`1<RQParameter> parameters);
    protected virtual void AppendChildren(List`1<SimpleTreeNode> childList);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal abstract class Microsoft.CodeAnalysis.Features.RQName.Nodes.RQMethodPropertyOrEvent : RQMember {
    public RQMethodPropertyOrEventName RqMemberName;
    public string MemberName { get; }
    public RQMethodPropertyOrEvent(RQUnconstructedType containingType, RQMethodPropertyOrEventName memberName);
    public virtual string get_MemberName();
    protected virtual void AppendChildren(List`1<SimpleTreeNode> childList);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal abstract class Microsoft.CodeAnalysis.Features.RQName.Nodes.RQMethodPropertyOrEventName : object {
    public string OrdinaryNameValue { get; }
    public abstract virtual string get_OrdinaryNameValue();
    public abstract virtual SimpleGroupNode ToSimpleTree();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.CodeAnalysis.Features.RQName.Nodes.RQNamespace : RQTypeOrNamespace {
    protected string RQKeyword { get; }
    public RQNamespace(IList`1<string> namespaceNames);
    protected virtual string get_RQKeyword();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal abstract class Microsoft.CodeAnalysis.Features.RQName.Nodes.RQNode : object {
    protected string RQKeyword { get; }
    protected abstract virtual string get_RQKeyword();
    protected abstract virtual void AppendChildren(List`1<SimpleTreeNode> childList);
    public SimpleGroupNode ToSimpleTree();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.CodeAnalysis.Features.RQName.Nodes.RQNormalParameter : RQParameter {
    public RQNormalParameter(RQType type);
    public virtual SimpleTreeNode CreateSimpleTreeForType();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.CodeAnalysis.Features.RQName.Nodes.RQNullType : RQType {
    public static RQNullType Singleton;
    private static RQNullType();
    public virtual SimpleTreeNode ToSimpleTree();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.CodeAnalysis.Features.RQName.Nodes.RQOrdinaryMethodPropertyOrEventName : RQMethodPropertyOrEventName {
    private string _constructType;
    public string Name;
    public string OrdinaryNameValue { get; }
    internal RQOrdinaryMethodPropertyOrEventName(string constructType, string name);
    public virtual string get_OrdinaryNameValue();
    public static RQOrdinaryMethodPropertyOrEventName CreateConstructorName();
    public static RQOrdinaryMethodPropertyOrEventName CreateDestructorName();
    public static RQOrdinaryMethodPropertyOrEventName CreateOrdinaryIndexerName();
    public static RQOrdinaryMethodPropertyOrEventName CreateOrdinaryMethodName(string name);
    public static RQOrdinaryMethodPropertyOrEventName CreateOrdinaryEventName(string name);
    public static RQOrdinaryMethodPropertyOrEventName CreateOrdinaryPropertyName(string name);
    public virtual SimpleGroupNode ToSimpleTree();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.CodeAnalysis.Features.RQName.Nodes.RQOutParameter : RQParameter {
    public RQOutParameter(RQType type);
    public virtual SimpleTreeNode CreateSimpleTreeForType();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal abstract class Microsoft.CodeAnalysis.Features.RQName.Nodes.RQParameter : object {
    public RQType Type;
    public RQParameter(RQType type);
    public SimpleTreeNode ToSimpleTree();
    public abstract virtual SimpleTreeNode CreateSimpleTreeForType();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.CodeAnalysis.Features.RQName.Nodes.RQPointerType : RQArrayOrPointerType {
    public RQPointerType(RQType elementType);
    public virtual SimpleTreeNode ToSimpleTree();
}
internal class Microsoft.CodeAnalysis.Features.RQName.Nodes.RQProperty : RQPropertyBase {
    [NullableContextAttribute("1")]
public RQProperty(RQUnconstructedType containingType, RQMethodPropertyOrEventName memberName, int typeParameterCount, IList`1<RQParameter> parameters);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal abstract class Microsoft.CodeAnalysis.Features.RQName.Nodes.RQPropertyBase : RQMethodOrProperty {
    protected string RQKeyword { get; }
    public RQPropertyBase(RQUnconstructedType containingType, RQMethodPropertyOrEventName memberName, int typeParameterCount, IList`1<RQParameter> parameters);
    protected virtual string get_RQKeyword();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.CodeAnalysis.Features.RQName.Nodes.RQRefParameter : RQParameter {
    public RQRefParameter(RQType type);
    public virtual SimpleTreeNode CreateSimpleTreeForType();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal abstract class Microsoft.CodeAnalysis.Features.RQName.Nodes.RQType : object {
    public static RQType ObjectType;
    private static RQType();
    public abstract virtual SimpleTreeNode ToSimpleTree();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal abstract class Microsoft.CodeAnalysis.Features.RQName.Nodes.RQTypeOrNamespace : RQNode {
    public ReadOnlyCollection`1<string> NamespaceNames;
    protected RQTypeOrNamespace(IList`1<string> namespaceNames);
    protected virtual void AppendChildren(List`1<SimpleTreeNode> childList);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.CodeAnalysis.Features.RQName.Nodes.RQTypeVariableType : RQType {
    public string Name;
    public RQTypeVariableType(string name);
    public virtual SimpleTreeNode ToSimpleTree();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.CodeAnalysis.Features.RQName.Nodes.RQUnconstructedType : RQTypeOrNamespace {
    public ReadOnlyCollection`1<RQUnconstructedTypeInfo> TypeInfos;
    protected string RQKeyword { get; }
    public RQUnconstructedType(IList`1<string> namespaceNames, IList`1<RQUnconstructedTypeInfo> typeInfos);
    protected virtual string get_RQKeyword();
    protected virtual void AppendChildren(List`1<SimpleTreeNode> childList);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[IsReadOnlyAttribute]
internal class Microsoft.CodeAnalysis.Features.RQName.Nodes.RQUnconstructedTypeInfo : ValueType {
    public string TypeName;
    public int TypeVariableCount;
    public RQUnconstructedTypeInfo(string typeName, int typeVariableCount);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.CodeAnalysis.Features.RQName.Nodes.RQVoidType : RQType {
    public static RQVoidType Singleton;
    private static RQVoidType();
    public virtual SimpleTreeNode ToSimpleTree();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal static class Microsoft.CodeAnalysis.Features.RQName.ParenthesesTreeWriter : object {
    public static string ToParenthesesFormat(SimpleTreeNode tree);
    private static void WriteNode(SimpleTreeNode node, StringBuilder sb);
}
internal static class Microsoft.CodeAnalysis.Features.RQName.RQNameInternal : object {
    [NullableContextAttribute("1")]
public static string From(ISymbol symbol);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.CodeAnalysis.Features.RQName.RQNameStrings : object {
    internal static string Namespace;
    internal static string Agg;
    internal static string MembVar;
    internal static string Event;
    internal static string Meth;
    internal static string Prop;
    internal static string Params;
    internal static string Param;
    internal static string ParamMod;
    internal static string AggType;
    internal static string TypeParams;
    internal static string Array;
    internal static string Pointer;
    internal static string Ref;
    internal static string Out;
    internal static string TyVar;
    internal static string Void;
    internal static string Error;
    internal static string Null;
    internal static string Dynamic;
    internal static string NsName;
    internal static string AggName;
    internal static string MembVarName;
    internal static string MethName;
    internal static string PropName;
    internal static string EventName;
    internal static string IntfExplName;
    internal static string TypeVarCnt;
    internal static string MemberParamIndex;
    internal static string NotPartial;
    internal static string PartialSignature;
    internal static string PartialImplementation;
    internal static string SpecialIndexerName;
    internal static string SpecialConstructorName;
    internal static string SpecialDestructorName;
    internal static string SpecialStaticConstructorName;
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal static class Microsoft.CodeAnalysis.Features.RQName.RQNodeBuilder : object {
    public static RQNode Build(ISymbol symbol);
    private static RQNamespace BuildNamespace(INamespaceSymbol namespace);
    private static IList`1<string> GetNameParts(INamespaceSymbol namespace);
    private static RQUnconstructedType BuildUnconstructedNamedType(INamedTypeSymbol type);
    private static RQMember BuildField(IFieldSymbol symbol);
    private static RQProperty BuildProperty(IPropertySymbol symbol);
    private static IList`1<RQParameter> BuildParameterList(ImmutableArray`1<IParameterSymbol> parameters);
    private static RQEvent BuildEvent(IEventSymbol symbol);
    private static RQMethod BuildMethod(IMethodSymbol symbol);
    private static RQType BuildType(ITypeSymbol symbol);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[DefaultMemberAttribute("Item")]
internal class Microsoft.CodeAnalysis.Features.RQName.SimpleTree.SimpleGroupNode : SimpleTreeNode {
    private IList`1<SimpleTreeNode> _children;
    public IList`1<SimpleTreeNode> Children { get; }
    public SimpleTreeNode Item { get; }
    public int Count { get; }
    public SimpleGroupNode(string text, IList`1<SimpleTreeNode> children);
    public SimpleGroupNode(string text, string singleLeafChildText);
    public SimpleGroupNode(string text, SimpleTreeNode[] children);
    public IList`1<SimpleTreeNode> get_Children();
    public SimpleTreeNode get_Item(int index);
    public int get_Count();
}
internal class Microsoft.CodeAnalysis.Features.RQName.SimpleTree.SimpleLeafNode : SimpleTreeNode {
    [NullableContextAttribute("1")]
public SimpleLeafNode(string text);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal abstract class Microsoft.CodeAnalysis.Features.RQName.SimpleTree.SimpleTreeNode : object {
    public string Text;
    public SimpleTreeNode(string text);
}
internal static class Microsoft.CodeAnalysis.FeaturesResources : object {
    private static ResourceManager s_resourceManager;
    [CompilerGeneratedAttribute]
private static CultureInfo <Culture>k__BackingField;
    internal static ResourceManager ResourceManager { get; }
    internal static CultureInfo Culture { get; internal set; }
    internal static string Add_project_reference_to_0 { get; }
    internal static string Add_reference_to_0 { get; }
    internal static string Actions_can_not_be_empty { get; }
    internal static string generic_overload { get; }
    internal static string generic_overloads { get; }
    internal static string overload { get; }
    internal static string overloads_ { get; }
    internal static string _0_Keyword { get; }
    internal static string Encapsulate_field_colon_0_and_use_property { get; }
    internal static string Encapsulate_field_colon_0_but_still_use_field { get; }
    internal static string Encapsulate_fields_and_use_property { get; }
    internal static string Encapsulate_fields_but_still_use_field { get; }
    internal static string Could_not_extract_interface_colon_The_selection_is_not_inside_a_class_interface_struct { get; }
    internal static string Could_not_extract_interface_colon_The_type_does_not_contain_any_member_that_can_be_extracted_to_an_interface { get; }
    internal static string can_t_not_construct_final_tree { get; }
    internal static string Parameters_type_or_return_type_cannot_be_an_anonymous_type_colon_bracket_0_bracket { get; }
    internal static string The_selection_contains_no_active_statement { get; }
    internal static string The_selection_contains_a_local_function_call_without_its_declaration { get; }
    internal static string The_selection_contains_an_error_or_unknown_type { get; }
    internal static string Type_parameter_0_is_hidden_by_another_type_parameter_1 { get; }
    internal static string The_address_of_a_variable_is_used_inside_the_selected_code { get; }
    internal static string Assigning_to_readonly_fields_must_be_done_in_a_constructor_colon_bracket_0_bracket { get; }
    internal static string generated_code_is_overlapping_with_hidden_portion_of_the_code { get; }
    internal static string Add_optional_parameters_to_0 { get; }
    internal static string Add_parameters_to_0 { get; }
    internal static string Generate_delegating_constructor_0_1 { get; }
    internal static string Generate_constructor_0_1 { get; }
    internal static string Generate_field_assigning_constructor_0_1 { get; }
    internal static string Generate_Equals_and_GetHashCode { get; }
    internal static string Generate_Equals_object { get; }
    internal static string Generate_GetHashCode { get; }
    internal static string Generate_constructor_in_0 { get; }
    internal static string Generate_all { get; }
    internal static string Generate_enum_member_1_0 { get; }
    internal static string Generate_constant_1_0 { get; }
    internal static string Generate_read_only_property_1_0 { get; }
    internal static string Generate_property_1_0 { get; }
    internal static string Generate_read_only_field_1_0 { get; }
    internal static string Generate_field_1_0 { get; }
    internal static string Generate_local_0 { get; }
    internal static string Generate_0_1_in_new_file { get; }
    internal static string Generate_nested_0_1 { get; }
    internal static string Global_Namespace { get; }
    internal static string Implement_all_members_explicitly { get; }
    internal static string Implement_interface_abstractly { get; }
    internal static string Implement_interface_through_0 { get; }
    internal static string Implement_interface { get; }
    internal static string Introduce_field_for_0 { get; }
    internal static string Introduce_local_for_0 { get; }
    internal static string Introduce_constant_for_0 { get; }
    internal static string Introduce_local_constant_for_0 { get; }
    internal static string Introduce_field_for_all_occurrences_of_0 { get; }
    internal static string Introduce_local_for_all_occurrences_of_0 { get; }
    internal static string Introduce_constant_for_all_occurrences_of_0 { get; }
    internal static string Introduce_local_constant_for_all_occurrences_of_0 { get; }
    internal static string Introduce_query_variable_for_all_occurrences_of_0 { get; }
    internal static string Introduce_query_variable_for_0 { get; }
    internal static string Anonymous_Types_colon { get; }
    internal static string is_ { get; }
    internal static string Represents_an_object_whose_operations_will_be_resolved_at_runtime { get; }
    internal static string constant { get; }
    internal static string field { get; }
    internal static string local_constant { get; }
    internal static string local_variable { get; }
    internal static string label { get; }
    internal static string range_variable { get; }
    internal static string parameter { get; }
    internal static string discard { get; }
    internal static string in_ { get; }
    internal static string Summary_colon { get; }
    internal static string Locals_and_parameters { get; }
    internal static string Type_parameters_colon { get; }
    internal static string Returns_colon { get; }
    internal static string Exceptions_colon { get; }
    internal static string Remarks_colon { get; }
    internal static string generating_source_for_symbols_of_this_type_is_not_supported { get; }
    internal static string Assembly { get; }
    internal static string location_unknown { get; }
    internal static string Extract_interface { get; }
    internal static string Updating_0_will_prevent_the_debug_session_from_continuing { get; }
    internal static string Changing_0_to_1_will_prevent_the_debug_session_from_continuing_because_it_changes_the_shape_of_the_state_machine { get; }
    internal static string Updating_a_complex_statement_containing_an_await_expression_will_prevent_the_debug_session_from_continuing { get; }
    internal static string Changing_visibility_of_a_constructor_will_prevent_the_debug_session_from_continuing { get; }
    internal static string Capturing_variable_0_that_hasn_t_been_captured_before_will_prevent_the_debug_session_from_continuing { get; }
    internal static string Ceasing_to_capture_variable_0_will_prevent_the_debug_session_from_continuing { get; }
    internal static string Deleting_captured_variable_0_will_prevent_the_debug_session_from_continuing { get; }
    internal static string Changing_the_type_of_a_captured_variable_0_previously_of_type_1_will_prevent_the_debug_session_from_continuing { get; }
    internal static string Changing_the_parameters_of_0_will_prevent_the_debug_session_from_continuing { get; }
    internal static string Changing_the_return_type_of_0_will_prevent_the_debug_session_from_continuing { get; }
    internal static string Changing_the_type_of_0_will_prevent_the_debug_session_from_continuing { get; }
    internal static string Changing_the_declaration_scope_of_a_captured_variable_0_will_prevent_the_debug_session_from_continuing { get; }
    internal static string Accessing_captured_variable_0_that_hasn_t_been_accessed_before_in_1_will_prevent_the_debug_session_from_continuing { get; }
    internal static string Ceasing_to_access_captured_variable_0_in_1_will_prevent_the_debug_session_from_continuing { get; }
    internal static string Adding_0_that_accesses_captured_variables_1_and_2_declared_in_different_scopes_will_prevent_the_debug_session_from_continuing { get; }
    internal static string Removing_0_that_accessed_captured_variables_1_and_2_declared_in_different_scopes_will_prevent_the_debug_session_from_continuing { get; }
    internal static string Adding_0_into_a_1_will_prevent_the_debug_session_from_continuing { get; }
    internal static string Adding_0_into_an_interface_will_prevent_the_debug_session_from_continuing { get; }
    internal static string Adding_0_into_an_interface_method_will_prevent_the_debug_session_from_continuing { get; }
    internal static string Adding_0_into_a_class_with_explicit_or_sequential_layout_will_prevent_the_debug_session_from_continuing { get; }
    internal static string Updating_the_modifiers_of_0_will_prevent_the_debug_session_from_continuing { get; }
    internal static string Updating_the_Handles_clause_of_0_will_prevent_the_debug_session_from_continuing { get; }
    internal static string Adding_0_with_the_Handles_clause_will_prevent_the_debug_session_from_continuing { get; }
    internal static string Updating_the_Implements_clause_of_a_0_will_prevent_the_debug_session_from_continuing { get; }
    internal static string Changing_the_constraint_from_0_to_1_will_prevent_the_debug_session_from_continuing { get; }
    internal static string Updating_the_variance_of_0_will_prevent_the_debug_session_from_continuing { get; }
    internal static string Updating_the_type_of_0_will_prevent_the_debug_session_from_continuing { get; }
    internal static string Updating_the_initializer_of_0_will_prevent_the_debug_session_from_continuing { get; }
    internal static string Updating_the_size_of_a_0_will_prevent_the_debug_session_from_continuing { get; }
    internal static string Updating_the_underlying_type_of_0_will_prevent_the_debug_session_from_continuing { get; }
    internal static string Updating_the_base_class_and_or_base_interface_s_of_0_will_prevent_the_debug_session_from_continuing { get; }
    internal static string Updating_a_field_to_an_event_or_vice_versa_will_prevent_the_debug_session_from_continuing { get; }
    internal static string Updating_the_kind_of_a_type_will_prevent_the_debug_session_from_continuing { get; }
    internal static string Updating_the_kind_of_an_property_event_accessor_will_prevent_the_debug_session_from_continuing { get; }
    internal static string Updating_the_kind_of_a_method_Sub_Function_will_prevent_the_debug_session_from_continuing { get; }
    internal static string Updating_the_library_name_of_Declare_Statement_will_prevent_the_debug_session_from_continuing { get; }
    internal static string Updating_the_alias_of_Declare_Statement_will_prevent_the_debug_session_from_continuing { get; }
    internal static string Renaming_0_will_prevent_the_debug_session_from_continuing { get; }
    internal static string Adding_0_will_prevent_the_debug_session_from_continuing { get; }
    internal static string Adding_an_abstract_0_or_overriding_an_inherited_0_will_prevent_the_debug_session_from_continuing { get; }
    internal static string Adding_a_MustOverride_0_or_overriding_an_inherited_0_will_prevent_the_debug_session_from_continuing { get; }
    internal static string Adding_an_extern_0_will_prevent_the_debug_session_from_continuing { get; }
    internal static string Adding_an_imported_method_will_prevent_the_debug_session_from_continuing { get; }
    internal static string Adding_a_user_defined_0_will_prevent_the_debug_session_from_continuing { get; }
    internal static string Adding_a_generic_0_will_prevent_the_debug_session_from_continuing { get; }
    internal static string Adding_0_around_an_active_statement_will_prevent_the_debug_session_from_continuing { get; }
    internal static string Moving_0_will_prevent_the_debug_session_from_continuing { get; }
    internal static string Deleting_0_will_prevent_the_debug_session_from_continuing { get; }
    internal static string Deleting_0_around_an_active_statement_will_prevent_the_debug_session_from_continuing { get; }
    internal static string Adding_a_method_body_will_prevent_the_debug_session_from_continuing { get; }
    internal static string Deleting_a_method_body_will_prevent_the_debug_session_from_continuing { get; }
    internal static string An_active_statement_has_been_removed_from_its_original_method_You_must_revert_your_changes_to_continue_or_restart_the_debugging_session { get; }
    internal static string Updating_a_0_around_an_active_statement_will_prevent_the_debug_session_from_continuing { get; }
    internal static string Updating_async_or_iterator_modifier_around_an_active_statement_will_prevent_the_debug_session_from_continuing { get; }
    internal static string Changing_0_from_asynchronous_to_synchronous_will_prevent_the_debug_session_from_continuing { get; }
    internal static string Modifying_a_generic_method_will_prevent_the_debug_session_from_continuing { get; }
    internal static string Modifying_whitespace_or_comments_in_a_generic_0_will_prevent_the_debug_session_from_continuing { get; }
    internal static string Modifying_a_method_inside_the_context_of_a_generic_type_will_prevent_the_debug_session_from_continuing { get; }
    internal static string Modifying_whitespace_or_comments_in_0_inside_the_context_of_a_generic_type_will_prevent_the_debug_session_from_continuing { get; }
    internal static string Modifying_the_initializer_of_0_in_a_generic_type_will_prevent_the_debug_session_from_continuing { get; }
    internal static string Modifying_the_initializer_of_0_in_a_partial_type_will_prevent_the_debug_session_from_continuing { get; }
    internal static string Adding_a_constructor_to_a_type_with_a_field_or_property_initializer_that_contains_an_anonymous_function_will_prevent_the_debug_session_from_continuing { get; }
    internal static string Renaming_a_captured_variable_from_0_to_1_will_prevent_the_debug_session_from_continuing { get; }
    internal static string Modifying_a_catch_finally_handler_with_an_active_statement_in_the_try_block_will_prevent_the_debug_session_from_continuing { get; }
    internal static string Modifying_a_try_catch_finally_statement_when_the_finally_block_is_active_will_prevent_the_debug_session_from_continuing { get; }
    internal static string Modifying_a_catch_handler_around_an_active_statement_will_prevent_the_debug_session_from_continuing { get; }
    internal static string Modifying_0_which_contains_the_stackalloc_operator_will_prevent_the_debug_session_from_continuing { get; }
    internal static string Modifying_0_which_contains_a_switch_expression_will_prevent_the_debug_session_from_continuing { get; }
    internal static string Modifying_an_active_0_which_contains_On_Error_or_Resume_statements_will_prevent_the_debug_session_from_continuing { get; }
    internal static string Modifying_0_which_contains_an_Aggregate_Group_By_or_Join_query_clauses_will_prevent_the_debug_session_from_continuing { get; }
    internal static string Modifying_source_with_experimental_language_features_enabled_will_prevent_the_debug_session_from_continuing { get; }
    internal static string Updating_an_active_statement_will_prevent_the_debug_session_from_continuing { get; }
    internal static string Removing_0_that_contains_an_active_statement_will_prevent_the_debug_session_from_continuing { get; }
    internal static string Adding_a_new_file_will_prevent_the_debug_session_from_continuing { get; }
    internal static string Attribute_0_is_missing_Updating_an_async_method_or_an_iterator_will_prevent_the_debug_session_from_continuing { get; }
    internal static string Unexpected_interface_member_kind_colon_0 { get; }
    internal static string Unknown_symbol_kind { get; }
    internal static string Generate_abstract_property_1_0 { get; }
    internal static string Generate_abstract_method_1_0 { get; }
    internal static string Generate_method_1_0 { get; }
    internal static string Requested_assembly_already_loaded_from_0 { get; }
    internal static string The_symbol_does_not_have_an_icon { get; }
    internal static string Extract_local_function { get; }
    internal static string Extract_method { get; }
    internal static string Asynchronous_method_cannot_have_ref_out_parameters_colon_bracket_0_bracket { get; }
    internal static string The_member_is_defined_in_metadata { get; }
    internal static string You_can_only_change_the_signature_of_a_constructor_indexer_method_or_delegate { get; }
    internal static string This_symbol_has_related_definitions_or_references_in_metadata_Changing_its_signature_may_result_in_build_errors_Do_you_want_to_continue { get; }
    internal static string Change_signature { get; }
    internal static string Generate_new_type { get; }
    internal static string User_Diagnostic_Analyzer_Failure { get; }
    internal static string Analyzer_0_threw_an_exception_of_type_1_with_message_2 { get; }
    internal static string Analyzer_0_threw_the_following_exception_colon_1 { get; }
    internal static string Simplify_Names { get; }
    internal static string Simplify_Member_Access { get; }
    internal static string Remove_qualification { get; }
    internal static string Unknown_error_occurred { get; }
    internal static string No_valid_location_to_insert_method_call { get; }
    internal static string Available { get; }
    internal static string Not_Available { get; }
    internal static string _0_1 { get; }
    internal static string You_can_use_the_navigation_bar_to_switch_context { get; }
    internal static string in_Source { get; }
    internal static string in_Suppression_File { get; }
    internal static string Remove_Suppression_0 { get; }
    internal static string Remove_Suppression { get; }
    internal static string Configure_0_severity { get; }
    internal static string Configure_0_code_style { get; }
    internal static string Configure_severity_for_all_0_analyzers { get; }
    internal static string Configure_severity_for_all_analyzers { get; }
    internal static string Pending { get; }
    internal static string Awaited_task_returns_0 { get; }
    internal static string Awaited_task_returns_no_value { get; }
    internal static string Note_colon_Tab_twice_to_insert_the_0_snippet { get; }
    internal static string Implement_interface_explicitly_with_Dispose_pattern { get; }
    internal static string Implement_interface_with_Dispose_pattern { get; }
    internal static string Suppress_0 { get; }
    internal static string Re_triage_0_currently_1 { get; }
    internal static string Argument_cannot_have_a_null_element { get; }
    internal static string Argument_cannot_be_empty { get; }
    internal static string Reported_diagnostic_with_ID_0_is_not_supported_by_the_analyzer { get; }
    internal static string Computing_fix_all_occurrences_code_fix { get; }
    internal static string Fix_all_occurrences { get; }
    internal static string Document { get; }
    internal static string Project { get; }
    internal static string Solution { get; }
    internal static string TODO_colon_dispose_managed_state_managed_objects { get; }
    internal static string TODO_colon_set_large_fields_to_null { get; }
    internal static string Modifying_0_which_contains_a_static_variable_will_prevent_the_debug_session_from_continuing { get; }
    internal static string Compiler2 { get; }
    internal static string EditAndContinue { get; }
    internal static string Live { get; }
    internal static string namespace_ { get; }
    internal static string class_ { get; }
    internal static string interface_ { get; }
    internal static string enum_ { get; }
    internal static string enum_value { get; }
    internal static string delegate_ { get; }
    internal static string const_field { get; }
    internal static string method { get; }
    internal static string operator_ { get; }
    internal static string constructor { get; }
    internal static string auto_property { get; }
    internal static string property_ { get; }
    internal static string event_ { get; }
    internal static string event_accessor { get; }
    internal static string type_constraint { get; }
    internal static string type_parameter { get; }
    internal static string attribute { get; }
    internal static string Replace_0_and_1_with_property { get; }
    internal static string Replace_0_with_property { get; }
    internal static string Method_referenced_implicitly { get; }
    internal static string Generate_type_0 { get; }
    internal static string Generate_0_1 { get; }
    internal static string Change_0_to_1 { get; }
    internal static string Non_invoked_method_cannot_be_replaced_with_property { get; }
    internal static string Only_methods_with_a_single_argument_which_is_not_an_out_variable_declaration_can_be_replaced_with_a_property { get; }
    internal static string Roslyn_HostError { get; }
    internal static string An_instance_of_analyzer_0_cannot_be_created_from_1_colon_2 { get; }
    internal static string The_assembly_0_does_not_contain_any_analyzers { get; }
    internal static string Unable_to_load_Analyzer_assembly_0_colon_1 { get; }
    internal static string Make_method_synchronous { get; }
    internal static string from_0 { get; }
    internal static string Find_and_install_latest_version { get; }
    internal static string Use_local_version_0 { get; }
    internal static string Use_locally_installed_0_version_1_This_version_used_in_colon_2 { get; }
    internal static string Find_and_install_latest_version_of_0 { get; }
    internal static string Install_with_package_manager { get; }
    internal static string Install_0_1 { get; }
    internal static string Install_version_0 { get; }
    internal static string Generate_variable_0 { get; }
    internal static string Classes { get; }
    internal static string Constants { get; }
    internal static string Delegates { get; }
    internal static string Enums { get; }
    internal static string Events { get; }
    internal static string Extension_methods { get; }
    internal static string Fields { get; }
    internal static string Interfaces { get; }
    internal static string Locals { get; }
    internal static string Methods { get; }
    internal static string Modules { get; }
    internal static string Namespaces { get; }
    internal static string Properties { get; }
    internal static string Structures { get; }
    internal static string Parameters_colon { get; }
    internal static string Variadic_SignatureHelpItem_must_have_at_least_one_parameter { get; }
    internal static string Replace_0_with_method { get; }
    internal static string Replace_0_with_methods { get; }
    internal static string Property_referenced_implicitly { get; }
    internal static string Property_cannot_safely_be_replaced_with_a_method_call { get; }
    internal static string Convert_to_interpolated_string { get; }
    internal static string Move_type_to_0 { get; }
    internal static string Rename_file_to_0 { get; }
    internal static string Rename_type_to_0 { get; }
    internal static string Remove_tag { get; }
    internal static string Add_missing_param_nodes { get; }
    internal static string Make_containing_scope_async { get; }
    internal static string Make_containing_scope_async_return_Task { get; }
    internal static string paren_Unknown_paren { get; }
    internal static string Implement_abstract_class { get; }
    internal static string Use_framework_type { get; }
    internal static string Install_package_0 { get; }
    internal static string project_0 { get; }
    internal static string Use_interpolated_verbatim_string { get; }
    internal static string Fix_typo_0 { get; }
    internal static string Fully_qualify_0 { get; }
    internal static string Remove_reference_to_0 { get; }
    internal static string Keywords { get; }
    internal static string Snippets { get; }
    internal static string All_lowercase { get; }
    internal static string All_uppercase { get; }
    internal static string First_word_capitalized { get; }
    internal static string Pascal_Case { get; }
    internal static string Remove_document_0 { get; }
    internal static string Add_document_0 { get; }
    internal static string Add_argument_name_0 { get; }
    internal static string Add_tuple_element_name_0 { get; }
    internal static string Take_0 { get; }
    internal static string Take_both { get; }
    internal static string Take_bottom { get; }
    internal static string Take_top { get; }
    internal static string Remove_unused_variable { get; }
    internal static string Convert_to_binary { get; }
    internal static string Convert_to_decimal { get; }
    internal static string Convert_to_hex { get; }
    internal static string Separate_thousands { get; }
    internal static string Separate_words { get; }
    internal static string Separate_nibbles { get; }
    internal static string Remove_separators { get; }
    internal static string Add_parameter_to_0 { get; }
    internal static string Add_parameter_to_0_and_overrides_implementations { get; }
    internal static string Add_to_0 { get; }
    internal static string Related_method_signatures_found_in_metadata_will_not_be_updated { get; }
    internal static string Generate_constructor { get; }
    internal static string Pick_members_to_be_used_as_constructor_parameters { get; }
    internal static string Pick_members_to_be_used_in_Equals_GetHashCode { get; }
    internal static string Generate_overrides { get; }
    internal static string Pick_members_to_override { get; }
    internal static string Add_null_check { get; }
    internal static string Add_string_IsNullOrEmpty_check { get; }
    internal static string Add_string_IsNullOrWhiteSpace_check { get; }
    internal static string Create_and_assign_field_0 { get; }
    internal static string Create_and_assign_property_0 { get; }
    internal static string Initialize_field_0 { get; }
    internal static string Initialize_property_0 { get; }
    internal static string Add_null_checks { get; }
    internal static string Generate_operators { get; }
    internal static string Implement_0 { get; }
    internal static string Reported_diagnostic_0_has_a_source_location_in_file_1_which_is_not_part_of_the_compilation_being_analyzed { get; }
    internal static string Reported_diagnostic_0_has_a_source_location_1_in_file_2_which_is_outside_of_the_given_file { get; }
    internal static string in_0_project_1 { get; }
    internal static string Add_accessibility_modifiers { get; }
    internal static string Move_declaration_near_reference { get; }
    internal static string Convert_to_full_property { get; }
    internal static string Warning_Method_overrides_symbol_from_metadata { get; }
    internal static string Use_0 { get; }
    internal static string Switching_between_lambda_and_local_function_will_prevent_the_debug_session_from_continuing { get; }
    internal static string Add_argument_name_0_including_trailing_arguments { get; }
    internal static string local_function { get; }
    internal static string indexer_ { get; }
    internal static string Alias_ambiguous_type_0 { get; }
    internal static string Warning_colon_Collection_was_modified_during_iteration { get; }
    internal static string Warning_colon_Iteration_variable_crossed_function_boundary { get; }
    internal static string Warning_colon_Collection_may_be_modified_during_iteration { get; }
    internal static string Convert_to_linq { get; }
    internal static string Convert_to_class { get; }
    internal static string Convert_to_struct { get; }
    internal static string updating_usages_in_containing_member { get; }
    internal static string updating_usages_in_containing_project { get; }
    internal static string updating_usages_in_containing_type { get; }
    internal static string updating_usages_in_dependent_projects { get; }
    internal static string Formatting_document { get; }
    internal static string Add_member_name { get; }
    internal static string Use_block_body_for_lambda_expressions { get; }
    internal static string Use_expression_body_for_lambda_expressions { get; }
    internal static string Convert_to_linq_call_form { get; }
    internal static string Adding_method_with_explicit_interface_specifier_will_prevernt_the_debug_session_from_continuing { get; }
    internal static string Modifying_source_file_will_prevent_the_debug_session_from_continuing_due_to_internal_error { get; }
    internal static string Modifying_source_file_will_prevent_the_debug_session_from_continuing_because_the_file_is_too_big { get; }
    internal static string Modifying_body_of_member_will_prevent_the_debug_session_from_continuing_due_to_internal_error { get; }
    internal static string Modifying_body_of_member_will_prevent_the_debug_session_from_continuing_because_the_body_has_too_many_statements { get; }
    internal static string Change_namespace_to_0 { get; }
    internal static string Move_file_to_0 { get; }
    internal static string Move_file_to_project_root_folder { get; }
    internal static string Move_to_namespace { get; }
    internal static string Change_to_global_namespace { get; }
    internal static string Warning_colon_changing_namespace_may_produce_invalid_code_and_change_code_meaning { get; }
    internal static string Invert_conditional { get; }
    internal static string Replace_0_with_1 { get; }
    internal static string Align_wrapped_parameters { get; }
    internal static string Indent_all_parameters { get; }
    internal static string Indent_wrapped_parameters { get; }
    internal static string Unwrap_all_parameters { get; }
    internal static string Unwrap_and_indent_all_parameters { get; }
    internal static string Wrap_every_parameter { get; }
    internal static string Wrap_long_parameter_list { get; }
    internal static string Unwrap_parameter_list { get; }
    internal static string Align_wrapped_arguments { get; }
    internal static string Indent_all_arguments { get; }
    internal static string Indent_wrapped_arguments { get; }
    internal static string Unwrap_all_arguments { get; }
    internal static string Unwrap_and_indent_all_arguments { get; }
    internal static string Wrap_every_argument { get; }
    internal static string Wrap_long_argument_list { get; }
    internal static string Unwrap_argument_list { get; }
    internal static string Introduce_constant { get; }
    internal static string Introduce_field { get; }
    internal static string Introduce_local { get; }
    internal static string Introduce_query_variable { get; }
    internal static string Failed_to_analyze_data_flow_for_0 { get; }
    internal static string Fix_formatting { get; }
    internal static string Split_into_nested_0_statements { get; }
    internal static string Merge_with_outer_0_statement { get; }
    internal static string Split_into_consecutive_0_statements { get; }
    internal static string Merge_with_previous_0_statement { get; }
    internal static string Unwrap_expression { get; }
    internal static string Wrap_expression { get; }
    internal static string Wrapping { get; }
    internal static string Merge_with_nested_0_statement { get; }
    internal static string Merge_with_next_0_statement { get; }
    internal static string Pull_0_up { get; }
    internal static string Pull_members_up_to_base_type { get; }
    internal static string Unwrap_call_chain { get; }
    internal static string Wrap_call_chain { get; }
    internal static string Wrap_long_call_chain { get; }
    internal static string Pull_0_up_to_1 { get; }
    internal static string Wrap_and_align_expression { get; }
    internal static string Move_contents_to_namespace { get; }
    internal static string Add_optional_parameter_to_constructor { get; }
    internal static string Add_parameter_to_constructor { get; }
    internal static string Target_type_matches { get; }
    internal static string Generate_parameter_0 { get; }
    internal static string Generate_parameter_0_and_overrides_implementations { get; }
    internal static string in_Source_attribute { get; }
    internal static string StreamMustSupportReadAndSeek { get; }
    internal static string MethodMustReturnStreamThatSupportsReadAndSeek { get; }
    internal static string RudeEdit { get; }
    internal static string EditAndContinueDisallowedByModule { get; }
    internal static string CannotApplyChangesUnexpectedError { get; }
    internal static string ErrorReadingFile { get; }
    internal static string EditAndContinueDisallowedByProject { get; }
    internal static string ChangesNotAppliedWhileRunning { get; }
    internal static string DocumentIsOutOfSyncWithDebuggee { get; }
    internal static string UnableToReadSourceFileOrPdb { get; }
    internal static string ChangesDisallowedWhileStoppedAtException { get; }
    internal static string Wrap_and_align_call_chain { get; }
    internal static string Wrap_and_align_long_call_chain { get; }
    internal static string Warning_colon_semantics_may_change_when_converting_statement { get; }
    internal static string Add_null_checks_for_all_parameters { get; }
    internal static string Implement_0_implicitly { get; }
    internal static string Implement_all_interfaces_implicitly { get; }
    internal static string Implement_implicitly { get; }
    internal static string Implement_0_explicitly { get; }
    internal static string Make_member_static { get; }
    internal static string ChangeSignature_NewParameterIntroduceTODOVariable { get; }
    internal static string ChangeSignature_NewParameterOmitValue { get; }
    internal static string Value_colon { get; }
    internal static string Implement_through_0 { get; }
    internal static string Implement_all_interfaces_explicitly { get; }
    internal static string Implement_explicitly { get; }
    internal static string Resolve_conflict_markers { get; }
    internal static string Base_classes_contain_inaccessible_unimplemented_members { get; }
    internal static string Add_DebuggerDisplay_attribute { get; }
    internal static string Do_not_change_this_code_Put_cleanup_code_in_0_method { get; }
    internal static string TODO_colon_free_unmanaged_resources_unmanaged_objects_and_override_finalizer { get; }
    internal static string TODO_colon_override_finalizer_only_if_0_has_code_to_free_unmanaged_resources { get; }
    internal static string AM_PM_abbreviated { get; }
    internal static string AM_PM_abbreviated_description { get; }
    internal static string AM_PM_full { get; }
    internal static string AM_PM_full_description { get; }
    internal static string date_separator { get; }
    internal static string date_separator_description { get; }
    internal static string day_of_the_month_1_2_digits { get; }
    internal static string day_of_the_month_1_2_digits_description { get; }
    internal static string day_of_the_month_2_digits { get; }
    internal static string day_of_the_month_2_digits_description { get; }
    internal static string day_of_the_week_abbreviated { get; }
    internal static string day_of_the_week_abbreviated_description { get; }
    internal static string day_of_the_week_full { get; }
    internal static string day_of_the_week_full_description { get; }
    internal static string full_long_date_time { get; }
    internal static string full_long_date_time_description { get; }
    internal static string full_short_date_time { get; }
    internal static string full_short_date_time_description { get; }
    internal static string general_long_date_time { get; }
    internal static string general_long_date_time_description { get; }
    internal static string general_short_date_time { get; }
    internal static string general_short_date_time_description { get; }
    internal static string long_date { get; }
    internal static string long_date_description { get; }
    internal static string long_time { get; }
    internal static string long_time_description { get; }
    internal static string minute_1_2_digits { get; }
    internal static string minute_1_2_digits_description { get; }
    internal static string minute_2_digits { get; }
    internal static string minute_2_digits_description { get; }
    internal static string month_1_2_digits { get; }
    internal static string month_1_2_digits_description { get; }
    internal static string month_2_digits { get; }
    internal static string month_2_digits_description { get; }
    internal static string month_abbreviated { get; }
    internal static string month_abbreviated_description { get; }
    internal static string month_day { get; }
    internal static string month_day_description { get; }
    internal static string month_full { get; }
    internal static string month_full_description { get; }
    internal static string period_era { get; }
    internal static string period_era_description { get; }
    internal static string rfc1123_date_time { get; }
    internal static string rfc1123_date_time_description { get; }
    internal static string round_trip_date_time { get; }
    internal static string round_trip_date_time_description { get; }
    internal static string second_1_2_digits { get; }
    internal static string second_1_2_digits_description { get; }
    internal static string second_2_digits { get; }
    internal static string second_2_digits_description { get; }
    internal static string short_date { get; }
    internal static string short_date_description { get; }
    internal static string short_time { get; }
    internal static string short_time_description { get; }
    internal static string sortable_date_time { get; }
    internal static string sortable_date_time_description { get; }
    internal static string time_separator { get; }
    internal static string time_separator_description { get; }
    internal static string time_zone { get; }
    internal static string time_zone_description { get; }
    internal static string universal_full_date_time { get; }
    internal static string universal_full_date_time_description { get; }
    internal static string universal_sortable_date_time { get; }
    internal static string universal_sortable_date_time_description { get; }
    internal static string utc_hour_and_minute_offset { get; }
    internal static string utc_hour_and_minute_offset_description { get; }
    internal static string utc_hour_offset_1_2_digits { get; }
    internal static string utc_hour_offset_1_2_digits_description { get; }
    internal static string utc_hour_offset_2_digits { get; }
    internal static string utc_hour_offset_2_digits_description { get; }
    internal static string year_1_2_digits { get; }
    internal static string year_1_2_digits_description { get; }
    internal static string year_2_digits { get; }
    internal static string year_2_digits_description { get; }
    internal static string year_3_4_digits { get; }
    internal static string year_3_4_digits_description { get; }
    internal static string year_4_digits { get; }
    internal static string year_4_digits_description { get; }
    internal static string year_5_digits { get; }
    internal static string year_5_digits_description { get; }
    internal static string year_month { get; }
    internal static string year_month_description { get; }
    internal static string _10000000ths_of_a_second { get; }
    internal static string _10000000ths_of_a_second_description { get; }
    internal static string _10000000ths_of_a_second_non_zero { get; }
    internal static string _10000000ths_of_a_second_non_zero_description { get; }
    internal static string _1000000ths_of_a_second { get; }
    internal static string _1000000ths_of_a_second_description { get; }
    internal static string _1000000ths_of_a_second_non_zero { get; }
    internal static string _1000000ths_of_a_second_non_zero_description { get; }
    internal static string _100000ths_of_a_second { get; }
    internal static string _100000ths_of_a_second_description { get; }
    internal static string _100000ths_of_a_second_non_zero { get; }
    internal static string _100000ths_of_a_second_non_zero_description { get; }
    internal static string _10000ths_of_a_second { get; }
    internal static string _10000ths_of_a_second_description { get; }
    internal static string _10000ths_of_a_second_non_zero { get; }
    internal static string _10000ths_of_a_second_non_zero_description { get; }
    internal static string _1000ths_of_a_second { get; }
    internal static string _1000ths_of_a_second_description { get; }
    internal static string _1000ths_of_a_second_non_zero { get; }
    internal static string _1000ths_of_a_second_non_zero_description { get; }
    internal static string _100ths_of_a_second { get; }
    internal static string _100ths_of_a_second_description { get; }
    internal static string _100ths_of_a_second_non_zero { get; }
    internal static string _100ths_of_a_second_non_zero_description { get; }
    internal static string _10ths_of_a_second { get; }
    internal static string _10ths_of_a_second_description { get; }
    internal static string _10ths_of_a_second_non_zero { get; }
    internal static string _10ths_of_a_second_non_zero_description { get; }
    internal static string _12_hour_clock_1_2_digits { get; }
    internal static string _12_hour_clock_1_2_digits_description { get; }
    internal static string _12_hour_clock_2_digits { get; }
    internal static string _12_hour_clock_2_digits_description { get; }
    internal static string _24_hour_clock_1_2_digits { get; }
    internal static string _24_hour_clock_1_2_digits_description { get; }
    internal static string _24_hour_clock_2_digits { get; }
    internal static string _24_hour_clock_2_digits_description { get; }
    internal static string Implement_remaining_members_explicitly { get; }
    internal static string Generate_for_0 { get; }
    internal static string Generate_comparison_operators { get; }
    internal static string Create_and_assign_remaining_as_fields { get; }
    internal static string Create_and_assign_remaining_as_properties { get; }
    internal static string Add_explicit_cast { get; }
    internal static string Example { get; }
    internal static string Examples { get; }
    internal static string Alternation_conditions_cannot_be_comments { get; }
    internal static string Alternation_conditions_do_not_capture_and_cannot_be_named { get; }
    internal static string A_subtraction_must_be_the_last_element_in_a_character_class { get; }
    internal static string Cannot_include_class_0_in_character_range { get; }
    internal static string Capture_group_numbers_must_be_less_than_or_equal_to_Int32_MaxValue { get; }
    internal static string Capture_number_cannot_be_zero { get; }
    internal static string Illegal_backslash_at_end_of_pattern { get; }
    internal static string Illegal_x_y_with_x_less_than_y { get; }
    internal static string Incomplete_character_escape { get; }
    internal static string Insufficient_hexadecimal_digits { get; }
    internal static string Invalid_group_name_Group_names_must_begin_with_a_word_character { get; }
    internal static string Malformed { get; }
    internal static string Malformed_character_escape { get; }
    internal static string Malformed_named_back_reference { get; }
    internal static string Missing_control_character { get; }
    internal static string Nested_quantifier_0 { get; }
    internal static string Not_enough_close_parens { get; }
    internal static string Quantifier_x_y_following_nothing { get; }
    internal static string Reference_to_undefined_group { get; }
    internal static string Reference_to_undefined_group_name_0 { get; }
    internal static string Reference_to_undefined_group_number_0 { get; }
    internal static string Too_many_bars_in_conditional_grouping { get; }
    internal static string Too_many_close_parens { get; }
    internal static string Unknown_property { get; }
    internal static string Unknown_property_0 { get; }
    internal static string Unrecognized_control_character { get; }
    internal static string Unrecognized_escape_sequence_0 { get; }
    internal static string Unrecognized_grouping_construct { get; }
    internal static string Unterminated_character_class_set { get; }
    internal static string Unterminated_regex_comment { get; }
    internal static string x_y_range_in_reverse_order { get; }
    internal static string Regex_issue_0 { get; }
    internal static string Regex_number_decimal_digit { get; }
    internal static string Regex_number_letter { get; }
    internal static string Regex_number_other { get; }
    internal static string Regex_other_control { get; }
    internal static string Regex_other_format { get; }
    internal static string Regex_other_not_assigned { get; }
    internal static string Regex_other_private_use { get; }
    internal static string Regex_other_surrogate { get; }
    internal static string Regex_punctuation_close { get; }
    internal static string Regex_punctuation_connector { get; }
    internal static string Regex_punctuation_dash { get; }
    internal static string Regex_punctuation_final_quote { get; }
    internal static string Regex_punctuation_initial_quote { get; }
    internal static string Regex_punctuation_open { get; }
    internal static string Regex_punctuation_other { get; }
    internal static string Regex_separator_line { get; }
    internal static string Regex_separator_paragraph { get; }
    internal static string Regex_separator_space { get; }
    internal static string Regex_symbol_currency { get; }
    internal static string Regex_symbol_math { get; }
    internal static string Regex_symbol_modifier { get; }
    internal static string Regex_symbol_other { get; }
    internal static string Regex_letter_lowercase { get; }
    internal static string Regex_letter_modifier { get; }
    internal static string Regex_letter_other { get; }
    internal static string Regex_letter_titlecase { get; }
    internal static string Regex_mark_enclosing { get; }
    internal static string Regex_mark_nonspacing { get; }
    internal static string Regex_mark_spacing_combining { get; }
    internal static string Regex_contiguous_matches_long { get; }
    internal static string Regex_contiguous_matches_short { get; }
    internal static string Regex_end_of_string_only_long { get; }
    internal static string Regex_end_of_string_only_short { get; }
    internal static string Regex_end_of_string_or_before_ending_newline_long { get; }
    internal static string Regex_end_of_string_or_before_ending_newline_short { get; }
    internal static string Regex_non_word_boundary_long { get; }
    internal static string Regex_non_word_boundary_short { get; }
    internal static string Regex_start_of_string_only_long { get; }
    internal static string Regex_start_of_string_only_short { get; }
    internal static string Regex_word_boundary_long { get; }
    internal static string Regex_word_boundary_short { get; }
    internal static string Regex_start_of_string_or_line_long { get; }
    internal static string Regex_start_of_string_or_line_short { get; }
    internal static string Regex_end_of_string_or_line_long { get; }
    internal static string Regex_end_of_string_or_line_short { get; }
    internal static string Regex_any_character_group_long { get; }
    internal static string Regex_any_character_group_short { get; }
    internal static string Regex_backspace_character_long { get; }
    internal static string Regex_backspace_character_short { get; }
    internal static string Regex_bell_character_long { get; }
    internal static string Regex_bell_character_short { get; }
    internal static string Regex_carriage_return_character_long { get; }
    internal static string Regex_carriage_return_character_short { get; }
    internal static string Regex_control_character_long { get; }
    internal static string Regex_control_character_short { get; }
    internal static string Regex_decimal_digit_character_long { get; }
    internal static string Regex_decimal_digit_character_short { get; }
    internal static string Regex_escape_character_long { get; }
    internal static string Regex_escape_character_short { get; }
    internal static string Regex_form_feed_character_long { get; }
    internal static string Regex_form_feed_character_short { get; }
    internal static string Regex_hexadecimal_escape_long { get; }
    internal static string Regex_hexadecimal_escape_short { get; }
    internal static string Regex_letter_uppercase { get; }
    internal static string Regex_matched_subexpression_long { get; }
    internal static string Regex_matched_subexpression_short { get; }
    internal static string Regex_negative_character_group_long { get; }
    internal static string Regex_negative_character_group_short { get; }
    internal static string Regex_negative_character_range_long { get; }
    internal static string Regex_negative_character_range_short { get; }
    internal static string Regex_negative_unicode_category_long { get; }
    internal static string Regex_negative_unicode_category_short { get; }
    internal static string Regex_new_line_character_long { get; }
    internal static string Regex_new_line_character_short { get; }
    internal static string Regex_non_digit_character_long { get; }
    internal static string Regex_non_digit_character_short { get; }
    internal static string Regex_non_white_space_character_long { get; }
    internal static string Regex_non_white_space_character_short { get; }
    internal static string Regex_non_word_character_long { get; }
    internal static string Regex_non_word_character_short { get; }
    internal static string Regex_positive_character_group_long { get; }
    internal static string Regex_positive_character_group_short { get; }
    internal static string Regex_positive_character_range_long { get; }
    internal static string Regex_positive_character_range_short { get; }
    internal static string Regex_subexpression { get; }
    internal static string Regex_tab_character_long { get; }
    internal static string Regex_tab_character_short { get; }
    internal static string Regex_unicode_category_long { get; }
    internal static string Regex_unicode_category_short { get; }
    internal static string Regex_unicode_escape_long { get; }
    internal static string Regex_unicode_escape_short { get; }
    internal static string Regex_vertical_tab_character_long { get; }
    internal static string Regex_vertical_tab_character_short { get; }
    internal static string Regex_white_space_character_long { get; }
    internal static string Regex_white_space_character_short { get; }
    internal static string Regex_word_character_long { get; }
    internal static string Regex_word_character_short { get; }
    internal static string Regex_alternation_long { get; }
    internal static string Regex_alternation_short { get; }
    internal static string Regex_balancing_group_long { get; }
    internal static string Regex_balancing_group_short { get; }
    internal static string Regex_comment { get; }
    internal static string Regex_conditional_expression_match_long { get; }
    internal static string Regex_conditional_expression_match_short { get; }
    internal static string Regex_conditional_group_match_long { get; }
    internal static string Regex_conditional_group_match_short { get; }
    internal static string Regex_end_of_line_comment_long { get; }
    internal static string Regex_end_of_line_comment_short { get; }
    internal static string Regex_expression { get; }
    internal static string Regex_group_options_long { get; }
    internal static string Regex_group_options_short { get; }
    internal static string Regex_inline_comment_long { get; }
    internal static string Regex_inline_comment_short { get; }
    internal static string Regex_name { get; }
    internal static string Regex_name1 { get; }
    internal static string Regex_name2 { get; }
    internal static string Regex_named_backreference_long { get; }
    internal static string Regex_named_backreference_short { get; }
    internal static string Regex_named_matched_subexpression_long { get; }
    internal static string Regex_named_matched_subexpression_short { get; }
    internal static string Regex_name_or_number { get; }
    internal static string Regex_no { get; }
    internal static string Regex_atomic_group_long { get; }
    internal static string Regex_atomic_group_short { get; }
    internal static string Regex_noncapturing_group_long { get; }
    internal static string Regex_noncapturing_group_short { get; }
    internal static string Regex_numbered_backreference_long { get; }
    internal static string Regex_numbered_backreference_short { get; }
    internal static string Regex_yes { get; }
    internal static string Regex_zero_width_negative_lookahead_assertion_long { get; }
    internal static string Regex_zero_width_negative_lookahead_assertion_short { get; }
    internal static string Regex_zero_width_negative_lookbehind_assertion_long { get; }
    internal static string Regex_zero_width_negative_lookbehind_assertion_short { get; }
    internal static string Regex_zero_width_positive_lookahead_assertion_long { get; }
    internal static string Regex_zero_width_positive_lookahead_assertion_short { get; }
    internal static string Regex_zero_width_positive_lookbehind_assertion_long { get; }
    internal static string Regex_zero_width_positive_lookbehind_assertion_short { get; }
    internal static string Regex_all_control_characters_long { get; }
    internal static string Regex_all_control_characters_short { get; }
    internal static string Regex_all_diacritic_marks_long { get; }
    internal static string Regex_all_diacritic_marks_short { get; }
    internal static string Regex_all_letter_characters_long { get; }
    internal static string Regex_all_letter_characters_short { get; }
    internal static string Regex_all_numbers_long { get; }
    internal static string Regex_all_numbers_short { get; }
    internal static string Regex_all_punctuation_characters_long { get; }
    internal static string Regex_all_punctuation_characters_short { get; }
    internal static string Regex_all_separator_characters_long { get; }
    internal static string Regex_all_separator_characters_short { get; }
    internal static string Regex_all_symbols_long { get; }
    internal static string Regex_all_symbols_short { get; }
    internal static string Regex_base_group { get; }
    internal static string Regex_character_class_subtraction_long { get; }
    internal static string Regex_character_class_subtraction_short { get; }
    internal static string Regex_character_group { get; }
    internal static string Regex_excluded_group { get; }
    internal static string Regex_match_at_least_n_times_lazy_long { get; }
    internal static string Regex_match_at_least_n_times_lazy_short { get; }
    internal static string Regex_match_at_least_n_times_long { get; }
    internal static string Regex_match_at_least_n_times_short { get; }
    internal static string Regex_match_between_m_and_n_times_lazy_long { get; }
    internal static string Regex_match_between_m_and_n_times_lazy_short { get; }
    internal static string Regex_match_between_m_and_n_times_long { get; }
    internal static string Regex_match_between_m_and_n_times_short { get; }
    internal static string Regex_match_exactly_n_times_lazy_long { get; }
    internal static string Regex_match_exactly_n_times_lazy_short { get; }
    internal static string Regex_match_exactly_n_times_long { get; }
    internal static string Regex_match_exactly_n_times_short { get; }
    internal static string Regex_match_one_or_more_times_lazy_long { get; }
    internal static string Regex_match_one_or_more_times_lazy_short { get; }
    internal static string Regex_match_one_or_more_times_long { get; }
    internal static string Regex_match_one_or_more_times_short { get; }
    internal static string Regex_match_zero_or_more_times_lazy_long { get; }
    internal static string Regex_match_zero_or_more_times_lazy_short { get; }
    internal static string Regex_match_zero_or_more_times_long { get; }
    internal static string Regex_match_zero_or_more_times_short { get; }
    internal static string Regex_match_zero_or_one_time_lazy_long { get; }
    internal static string Regex_match_zero_or_one_time_lazy_short { get; }
    internal static string Regex_match_zero_or_one_time_long { get; }
    internal static string Regex_match_zero_or_one_time_short { get; }
    internal static string Regex_unicode_general_category_0 { get; }
    internal static string Regex_inline_options_long { get; }
    internal static string Regex_inline_options_short { get; }
    internal static string _0_cannot_be_null_or_empty { get; }
    internal static string _0_cannot_be_null_or_whitespace { get; }
    internal static string _0_is_not_null_here { get; }
    internal static string _0_may_be_null_here { get; }
    internal static string ChangeSignature_NewParameterInferValue { get; }
    internal static string Convert_type_to_0 { get; }
    internal static string from_metadata { get; }
    internal static string symbol_cannot_be_a_namespace { get; }
    internal static string Document_must_be_contained_in_the_workspace_that_created_this_service { get; }
    internal static string Generate_constructor_in_0_with_fields { get; }
    internal static string Generate_constructor_in_0_with_properties { get; }
    internal static string Property_reference_cannot_be_updated { get; }
    internal static string Make_class_abstract { get; }
    internal static string Inline_0 { get; }
    internal static string Remove_async_modifier { get; }
    internal static string Extract_base_class { get; }
    internal static string Inline_and_keep_0 { get; }
    internal static string Pull_members_up_to_new_base_class { get; }
    internal static string The_assembly_0_containing_type_1_references_NET_Framework { get; }
    internal static string Error_creating_instance_of_CodeFixProvider { get; }
    internal static string Error_creating_instance_of_CodeFixProvider_0 { get; }
    internal static string Removal_of_document_not_supported { get; }
    internal static string in_0_1_2 { get; }
    internal static string _0_dash_1 { get; }
    internal static string Convert_to_record { get; }
    internal static ResourceManager get_ResourceManager();
    [CompilerGeneratedAttribute]
internal static CultureInfo get_Culture();
    [CompilerGeneratedAttribute]
internal static void set_Culture(CultureInfo value);
    internal static string GetResourceString(string resourceKey, string defaultValue);
    internal static string get_Add_project_reference_to_0();
    internal static string get_Add_reference_to_0();
    internal static string get_Actions_can_not_be_empty();
    internal static string get_generic_overload();
    internal static string get_generic_overloads();
    internal static string get_overload();
    internal static string get_overloads_();
    internal static string get__0_Keyword();
    internal static string get_Encapsulate_field_colon_0_and_use_property();
    internal static string get_Encapsulate_field_colon_0_but_still_use_field();
    internal static string get_Encapsulate_fields_and_use_property();
    internal static string get_Encapsulate_fields_but_still_use_field();
    internal static string get_Could_not_extract_interface_colon_The_selection_is_not_inside_a_class_interface_struct();
    internal static string get_Could_not_extract_interface_colon_The_type_does_not_contain_any_member_that_can_be_extracted_to_an_interface();
    internal static string get_can_t_not_construct_final_tree();
    internal static string get_Parameters_type_or_return_type_cannot_be_an_anonymous_type_colon_bracket_0_bracket();
    internal static string get_The_selection_contains_no_active_statement();
    internal static string get_The_selection_contains_a_local_function_call_without_its_declaration();
    internal static string get_The_selection_contains_an_error_or_unknown_type();
    internal static string get_Type_parameter_0_is_hidden_by_another_type_parameter_1();
    internal static string get_The_address_of_a_variable_is_used_inside_the_selected_code();
    internal static string get_Assigning_to_readonly_fields_must_be_done_in_a_constructor_colon_bracket_0_bracket();
    internal static string get_generated_code_is_overlapping_with_hidden_portion_of_the_code();
    internal static string get_Add_optional_parameters_to_0();
    internal static string get_Add_parameters_to_0();
    internal static string get_Generate_delegating_constructor_0_1();
    internal static string get_Generate_constructor_0_1();
    internal static string get_Generate_field_assigning_constructor_0_1();
    internal static string get_Generate_Equals_and_GetHashCode();
    internal static string get_Generate_Equals_object();
    internal static string get_Generate_GetHashCode();
    internal static string get_Generate_constructor_in_0();
    internal static string get_Generate_all();
    internal static string get_Generate_enum_member_1_0();
    internal static string get_Generate_constant_1_0();
    internal static string get_Generate_read_only_property_1_0();
    internal static string get_Generate_property_1_0();
    internal static string get_Generate_read_only_field_1_0();
    internal static string get_Generate_field_1_0();
    internal static string get_Generate_local_0();
    internal static string get_Generate_0_1_in_new_file();
    internal static string get_Generate_nested_0_1();
    internal static string get_Global_Namespace();
    internal static string get_Implement_all_members_explicitly();
    internal static string get_Implement_interface_abstractly();
    internal static string get_Implement_interface_through_0();
    internal static string get_Implement_interface();
    internal static string get_Introduce_field_for_0();
    internal static string get_Introduce_local_for_0();
    internal static string get_Introduce_constant_for_0();
    internal static string get_Introduce_local_constant_for_0();
    internal static string get_Introduce_field_for_all_occurrences_of_0();
    internal static string get_Introduce_local_for_all_occurrences_of_0();
    internal static string get_Introduce_constant_for_all_occurrences_of_0();
    internal static string get_Introduce_local_constant_for_all_occurrences_of_0();
    internal static string get_Introduce_query_variable_for_all_occurrences_of_0();
    internal static string get_Introduce_query_variable_for_0();
    internal static string get_Anonymous_Types_colon();
    internal static string get_is_();
    internal static string get_Represents_an_object_whose_operations_will_be_resolved_at_runtime();
    internal static string get_constant();
    internal static string get_field();
    internal static string get_local_constant();
    internal static string get_local_variable();
    internal static string get_label();
    internal static string get_range_variable();
    internal static string get_parameter();
    internal static string get_discard();
    internal static string get_in_();
    internal static string get_Summary_colon();
    internal static string get_Locals_and_parameters();
    internal static string get_Type_parameters_colon();
    internal static string get_Returns_colon();
    internal static string get_Exceptions_colon();
    internal static string get_Remarks_colon();
    internal static string get_generating_source_for_symbols_of_this_type_is_not_supported();
    internal static string get_Assembly();
    internal static string get_location_unknown();
    internal static string get_Extract_interface();
    internal static string get_Updating_0_will_prevent_the_debug_session_from_continuing();
    internal static string get_Changing_0_to_1_will_prevent_the_debug_session_from_continuing_because_it_changes_the_shape_of_the_state_machine();
    internal static string get_Updating_a_complex_statement_containing_an_await_expression_will_prevent_the_debug_session_from_continuing();
    internal static string get_Changing_visibility_of_a_constructor_will_prevent_the_debug_session_from_continuing();
    internal static string get_Capturing_variable_0_that_hasn_t_been_captured_before_will_prevent_the_debug_session_from_continuing();
    internal static string get_Ceasing_to_capture_variable_0_will_prevent_the_debug_session_from_continuing();
    internal static string get_Deleting_captured_variable_0_will_prevent_the_debug_session_from_continuing();
    internal static string get_Changing_the_type_of_a_captured_variable_0_previously_of_type_1_will_prevent_the_debug_session_from_continuing();
    internal static string get_Changing_the_parameters_of_0_will_prevent_the_debug_session_from_continuing();
    internal static string get_Changing_the_return_type_of_0_will_prevent_the_debug_session_from_continuing();
    internal static string get_Changing_the_type_of_0_will_prevent_the_debug_session_from_continuing();
    internal static string get_Changing_the_declaration_scope_of_a_captured_variable_0_will_prevent_the_debug_session_from_continuing();
    internal static string get_Accessing_captured_variable_0_that_hasn_t_been_accessed_before_in_1_will_prevent_the_debug_session_from_continuing();
    internal static string get_Ceasing_to_access_captured_variable_0_in_1_will_prevent_the_debug_session_from_continuing();
    internal static string get_Adding_0_that_accesses_captured_variables_1_and_2_declared_in_different_scopes_will_prevent_the_debug_session_from_continuing();
    internal static string get_Removing_0_that_accessed_captured_variables_1_and_2_declared_in_different_scopes_will_prevent_the_debug_session_from_continuing();
    internal static string get_Adding_0_into_a_1_will_prevent_the_debug_session_from_continuing();
    internal static string get_Adding_0_into_an_interface_will_prevent_the_debug_session_from_continuing();
    internal static string get_Adding_0_into_an_interface_method_will_prevent_the_debug_session_from_continuing();
    internal static string get_Adding_0_into_a_class_with_explicit_or_sequential_layout_will_prevent_the_debug_session_from_continuing();
    internal static string get_Updating_the_modifiers_of_0_will_prevent_the_debug_session_from_continuing();
    internal static string get_Updating_the_Handles_clause_of_0_will_prevent_the_debug_session_from_continuing();
    internal static string get_Adding_0_with_the_Handles_clause_will_prevent_the_debug_session_from_continuing();
    internal static string get_Updating_the_Implements_clause_of_a_0_will_prevent_the_debug_session_from_continuing();
    internal static string get_Changing_the_constraint_from_0_to_1_will_prevent_the_debug_session_from_continuing();
    internal static string get_Updating_the_variance_of_0_will_prevent_the_debug_session_from_continuing();
    internal static string get_Updating_the_type_of_0_will_prevent_the_debug_session_from_continuing();
    internal static string get_Updating_the_initializer_of_0_will_prevent_the_debug_session_from_continuing();
    internal static string get_Updating_the_size_of_a_0_will_prevent_the_debug_session_from_continuing();
    internal static string get_Updating_the_underlying_type_of_0_will_prevent_the_debug_session_from_continuing();
    internal static string get_Updating_the_base_class_and_or_base_interface_s_of_0_will_prevent_the_debug_session_from_continuing();
    internal static string get_Updating_a_field_to_an_event_or_vice_versa_will_prevent_the_debug_session_from_continuing();
    internal static string get_Updating_the_kind_of_a_type_will_prevent_the_debug_session_from_continuing();
    internal static string get_Updating_the_kind_of_an_property_event_accessor_will_prevent_the_debug_session_from_continuing();
    internal static string get_Updating_the_kind_of_a_method_Sub_Function_will_prevent_the_debug_session_from_continuing();
    internal static string get_Updating_the_library_name_of_Declare_Statement_will_prevent_the_debug_session_from_continuing();
    internal static string get_Updating_the_alias_of_Declare_Statement_will_prevent_the_debug_session_from_continuing();
    internal static string get_Renaming_0_will_prevent_the_debug_session_from_continuing();
    internal static string get_Adding_0_will_prevent_the_debug_session_from_continuing();
    internal static string get_Adding_an_abstract_0_or_overriding_an_inherited_0_will_prevent_the_debug_session_from_continuing();
    internal static string get_Adding_a_MustOverride_0_or_overriding_an_inherited_0_will_prevent_the_debug_session_from_continuing();
    internal static string get_Adding_an_extern_0_will_prevent_the_debug_session_from_continuing();
    internal static string get_Adding_an_imported_method_will_prevent_the_debug_session_from_continuing();
    internal static string get_Adding_a_user_defined_0_will_prevent_the_debug_session_from_continuing();
    internal static string get_Adding_a_generic_0_will_prevent_the_debug_session_from_continuing();
    internal static string get_Adding_0_around_an_active_statement_will_prevent_the_debug_session_from_continuing();
    internal static string get_Moving_0_will_prevent_the_debug_session_from_continuing();
    internal static string get_Deleting_0_will_prevent_the_debug_session_from_continuing();
    internal static string get_Deleting_0_around_an_active_statement_will_prevent_the_debug_session_from_continuing();
    internal static string get_Adding_a_method_body_will_prevent_the_debug_session_from_continuing();
    internal static string get_Deleting_a_method_body_will_prevent_the_debug_session_from_continuing();
    internal static string get_An_active_statement_has_been_removed_from_its_original_method_You_must_revert_your_changes_to_continue_or_restart_the_debugging_session();
    internal static string get_Updating_a_0_around_an_active_statement_will_prevent_the_debug_session_from_continuing();
    internal static string get_Updating_async_or_iterator_modifier_around_an_active_statement_will_prevent_the_debug_session_from_continuing();
    internal static string get_Changing_0_from_asynchronous_to_synchronous_will_prevent_the_debug_session_from_continuing();
    internal static string get_Modifying_a_generic_method_will_prevent_the_debug_session_from_continuing();
    internal static string get_Modifying_whitespace_or_comments_in_a_generic_0_will_prevent_the_debug_session_from_continuing();
    internal static string get_Modifying_a_method_inside_the_context_of_a_generic_type_will_prevent_the_debug_session_from_continuing();
    internal static string get_Modifying_whitespace_or_comments_in_0_inside_the_context_of_a_generic_type_will_prevent_the_debug_session_from_continuing();
    internal static string get_Modifying_the_initializer_of_0_in_a_generic_type_will_prevent_the_debug_session_from_continuing();
    internal static string get_Modifying_the_initializer_of_0_in_a_partial_type_will_prevent_the_debug_session_from_continuing();
    internal static string get_Adding_a_constructor_to_a_type_with_a_field_or_property_initializer_that_contains_an_anonymous_function_will_prevent_the_debug_session_from_continuing();
    internal static string get_Renaming_a_captured_variable_from_0_to_1_will_prevent_the_debug_session_from_continuing();
    internal static string get_Modifying_a_catch_finally_handler_with_an_active_statement_in_the_try_block_will_prevent_the_debug_session_from_continuing();
    internal static string get_Modifying_a_try_catch_finally_statement_when_the_finally_block_is_active_will_prevent_the_debug_session_from_continuing();
    internal static string get_Modifying_a_catch_handler_around_an_active_statement_will_prevent_the_debug_session_from_continuing();
    internal static string get_Modifying_0_which_contains_the_stackalloc_operator_will_prevent_the_debug_session_from_continuing();
    internal static string get_Modifying_0_which_contains_a_switch_expression_will_prevent_the_debug_session_from_continuing();
    internal static string get_Modifying_an_active_0_which_contains_On_Error_or_Resume_statements_will_prevent_the_debug_session_from_continuing();
    internal static string get_Modifying_0_which_contains_an_Aggregate_Group_By_or_Join_query_clauses_will_prevent_the_debug_session_from_continuing();
    internal static string get_Modifying_source_with_experimental_language_features_enabled_will_prevent_the_debug_session_from_continuing();
    internal static string get_Updating_an_active_statement_will_prevent_the_debug_session_from_continuing();
    internal static string get_Removing_0_that_contains_an_active_statement_will_prevent_the_debug_session_from_continuing();
    internal static string get_Adding_a_new_file_will_prevent_the_debug_session_from_continuing();
    internal static string get_Attribute_0_is_missing_Updating_an_async_method_or_an_iterator_will_prevent_the_debug_session_from_continuing();
    internal static string get_Unexpected_interface_member_kind_colon_0();
    internal static string get_Unknown_symbol_kind();
    internal static string get_Generate_abstract_property_1_0();
    internal static string get_Generate_abstract_method_1_0();
    internal static string get_Generate_method_1_0();
    internal static string get_Requested_assembly_already_loaded_from_0();
    internal static string get_The_symbol_does_not_have_an_icon();
    internal static string get_Extract_local_function();
    internal static string get_Extract_method();
    internal static string get_Asynchronous_method_cannot_have_ref_out_parameters_colon_bracket_0_bracket();
    internal static string get_The_member_is_defined_in_metadata();
    internal static string get_You_can_only_change_the_signature_of_a_constructor_indexer_method_or_delegate();
    internal static string get_This_symbol_has_related_definitions_or_references_in_metadata_Changing_its_signature_may_result_in_build_errors_Do_you_want_to_continue();
    internal static string get_Change_signature();
    internal static string get_Generate_new_type();
    internal static string get_User_Diagnostic_Analyzer_Failure();
    internal static string get_Analyzer_0_threw_an_exception_of_type_1_with_message_2();
    internal static string get_Analyzer_0_threw_the_following_exception_colon_1();
    internal static string get_Simplify_Names();
    internal static string get_Simplify_Member_Access();
    internal static string get_Remove_qualification();
    internal static string get_Unknown_error_occurred();
    internal static string get_No_valid_location_to_insert_method_call();
    internal static string get_Available();
    internal static string get_Not_Available();
    internal static string get__0_1();
    internal static string get_You_can_use_the_navigation_bar_to_switch_context();
    internal static string get_in_Source();
    internal static string get_in_Suppression_File();
    internal static string get_Remove_Suppression_0();
    internal static string get_Remove_Suppression();
    internal static string get_Configure_0_severity();
    internal static string get_Configure_0_code_style();
    internal static string get_Configure_severity_for_all_0_analyzers();
    internal static string get_Configure_severity_for_all_analyzers();
    internal static string get_Pending();
    internal static string get_Awaited_task_returns_0();
    internal static string get_Awaited_task_returns_no_value();
    internal static string get_Note_colon_Tab_twice_to_insert_the_0_snippet();
    internal static string get_Implement_interface_explicitly_with_Dispose_pattern();
    internal static string get_Implement_interface_with_Dispose_pattern();
    internal static string get_Suppress_0();
    internal static string get_Re_triage_0_currently_1();
    internal static string get_Argument_cannot_have_a_null_element();
    internal static string get_Argument_cannot_be_empty();
    internal static string get_Reported_diagnostic_with_ID_0_is_not_supported_by_the_analyzer();
    internal static string get_Computing_fix_all_occurrences_code_fix();
    internal static string get_Fix_all_occurrences();
    internal static string get_Document();
    internal static string get_Project();
    internal static string get_Solution();
    internal static string get_TODO_colon_dispose_managed_state_managed_objects();
    internal static string get_TODO_colon_set_large_fields_to_null();
    internal static string get_Modifying_0_which_contains_a_static_variable_will_prevent_the_debug_session_from_continuing();
    internal static string get_Compiler2();
    internal static string get_EditAndContinue();
    internal static string get_Live();
    internal static string get_namespace_();
    internal static string get_class_();
    internal static string get_interface_();
    internal static string get_enum_();
    internal static string get_enum_value();
    internal static string get_delegate_();
    internal static string get_const_field();
    internal static string get_method();
    internal static string get_operator_();
    internal static string get_constructor();
    internal static string get_auto_property();
    internal static string get_property_();
    internal static string get_event_();
    internal static string get_event_accessor();
    internal static string get_type_constraint();
    internal static string get_type_parameter();
    internal static string get_attribute();
    internal static string get_Replace_0_and_1_with_property();
    internal static string get_Replace_0_with_property();
    internal static string get_Method_referenced_implicitly();
    internal static string get_Generate_type_0();
    internal static string get_Generate_0_1();
    internal static string get_Change_0_to_1();
    internal static string get_Non_invoked_method_cannot_be_replaced_with_property();
    internal static string get_Only_methods_with_a_single_argument_which_is_not_an_out_variable_declaration_can_be_replaced_with_a_property();
    internal static string get_Roslyn_HostError();
    internal static string get_An_instance_of_analyzer_0_cannot_be_created_from_1_colon_2();
    internal static string get_The_assembly_0_does_not_contain_any_analyzers();
    internal static string get_Unable_to_load_Analyzer_assembly_0_colon_1();
    internal static string get_Make_method_synchronous();
    internal static string get_from_0();
    internal static string get_Find_and_install_latest_version();
    internal static string get_Use_local_version_0();
    internal static string get_Use_locally_installed_0_version_1_This_version_used_in_colon_2();
    internal static string get_Find_and_install_latest_version_of_0();
    internal static string get_Install_with_package_manager();
    internal static string get_Install_0_1();
    internal static string get_Install_version_0();
    internal static string get_Generate_variable_0();
    internal static string get_Classes();
    internal static string get_Constants();
    internal static string get_Delegates();
    internal static string get_Enums();
    internal static string get_Events();
    internal static string get_Extension_methods();
    internal static string get_Fields();
    internal static string get_Interfaces();
    internal static string get_Locals();
    internal static string get_Methods();
    internal static string get_Modules();
    internal static string get_Namespaces();
    internal static string get_Properties();
    internal static string get_Structures();
    internal static string get_Parameters_colon();
    internal static string get_Variadic_SignatureHelpItem_must_have_at_least_one_parameter();
    internal static string get_Replace_0_with_method();
    internal static string get_Replace_0_with_methods();
    internal static string get_Property_referenced_implicitly();
    internal static string get_Property_cannot_safely_be_replaced_with_a_method_call();
    internal static string get_Convert_to_interpolated_string();
    internal static string get_Move_type_to_0();
    internal static string get_Rename_file_to_0();
    internal static string get_Rename_type_to_0();
    internal static string get_Remove_tag();
    internal static string get_Add_missing_param_nodes();
    internal static string get_Make_containing_scope_async();
    internal static string get_Make_containing_scope_async_return_Task();
    internal static string get_paren_Unknown_paren();
    internal static string get_Implement_abstract_class();
    internal static string get_Use_framework_type();
    internal static string get_Install_package_0();
    internal static string get_project_0();
    internal static string get_Use_interpolated_verbatim_string();
    internal static string get_Fix_typo_0();
    internal static string get_Fully_qualify_0();
    internal static string get_Remove_reference_to_0();
    internal static string get_Keywords();
    internal static string get_Snippets();
    internal static string get_All_lowercase();
    internal static string get_All_uppercase();
    internal static string get_First_word_capitalized();
    internal static string get_Pascal_Case();
    internal static string get_Remove_document_0();
    internal static string get_Add_document_0();
    internal static string get_Add_argument_name_0();
    internal static string get_Add_tuple_element_name_0();
    internal static string get_Take_0();
    internal static string get_Take_both();
    internal static string get_Take_bottom();
    internal static string get_Take_top();
    internal static string get_Remove_unused_variable();
    internal static string get_Convert_to_binary();
    internal static string get_Convert_to_decimal();
    internal static string get_Convert_to_hex();
    internal static string get_Separate_thousands();
    internal static string get_Separate_words();
    internal static string get_Separate_nibbles();
    internal static string get_Remove_separators();
    internal static string get_Add_parameter_to_0();
    internal static string get_Add_parameter_to_0_and_overrides_implementations();
    internal static string get_Add_to_0();
    internal static string get_Related_method_signatures_found_in_metadata_will_not_be_updated();
    internal static string get_Generate_constructor();
    internal static string get_Pick_members_to_be_used_as_constructor_parameters();
    internal static string get_Pick_members_to_be_used_in_Equals_GetHashCode();
    internal static string get_Generate_overrides();
    internal static string get_Pick_members_to_override();
    internal static string get_Add_null_check();
    internal static string get_Add_string_IsNullOrEmpty_check();
    internal static string get_Add_string_IsNullOrWhiteSpace_check();
    internal static string get_Create_and_assign_field_0();
    internal static string get_Create_and_assign_property_0();
    internal static string get_Initialize_field_0();
    internal static string get_Initialize_property_0();
    internal static string get_Add_null_checks();
    internal static string get_Generate_operators();
    internal static string get_Implement_0();
    internal static string get_Reported_diagnostic_0_has_a_source_location_in_file_1_which_is_not_part_of_the_compilation_being_analyzed();
    internal static string get_Reported_diagnostic_0_has_a_source_location_1_in_file_2_which_is_outside_of_the_given_file();
    internal static string get_in_0_project_1();
    internal static string get_Add_accessibility_modifiers();
    internal static string get_Move_declaration_near_reference();
    internal static string get_Convert_to_full_property();
    internal static string get_Warning_Method_overrides_symbol_from_metadata();
    internal static string get_Use_0();
    internal static string get_Switching_between_lambda_and_local_function_will_prevent_the_debug_session_from_continuing();
    internal static string get_Add_argument_name_0_including_trailing_arguments();
    internal static string get_local_function();
    internal static string get_indexer_();
    internal static string get_Alias_ambiguous_type_0();
    internal static string get_Warning_colon_Collection_was_modified_during_iteration();
    internal static string get_Warning_colon_Iteration_variable_crossed_function_boundary();
    internal static string get_Warning_colon_Collection_may_be_modified_during_iteration();
    internal static string get_Convert_to_linq();
    internal static string get_Convert_to_class();
    internal static string get_Convert_to_struct();
    internal static string get_updating_usages_in_containing_member();
    internal static string get_updating_usages_in_containing_project();
    internal static string get_updating_usages_in_containing_type();
    internal static string get_updating_usages_in_dependent_projects();
    internal static string get_Formatting_document();
    internal static string get_Add_member_name();
    internal static string get_Use_block_body_for_lambda_expressions();
    internal static string get_Use_expression_body_for_lambda_expressions();
    internal static string get_Convert_to_linq_call_form();
    internal static string get_Adding_method_with_explicit_interface_specifier_will_prevernt_the_debug_session_from_continuing();
    internal static string get_Modifying_source_file_will_prevent_the_debug_session_from_continuing_due_to_internal_error();
    internal static string get_Modifying_source_file_will_prevent_the_debug_session_from_continuing_because_the_file_is_too_big();
    internal static string get_Modifying_body_of_member_will_prevent_the_debug_session_from_continuing_due_to_internal_error();
    internal static string get_Modifying_body_of_member_will_prevent_the_debug_session_from_continuing_because_the_body_has_too_many_statements();
    internal static string get_Change_namespace_to_0();
    internal static string get_Move_file_to_0();
    internal static string get_Move_file_to_project_root_folder();
    internal static string get_Move_to_namespace();
    internal static string get_Change_to_global_namespace();
    internal static string get_Warning_colon_changing_namespace_may_produce_invalid_code_and_change_code_meaning();
    internal static string get_Invert_conditional();
    internal static string get_Replace_0_with_1();
    internal static string get_Align_wrapped_parameters();
    internal static string get_Indent_all_parameters();
    internal static string get_Indent_wrapped_parameters();
    internal static string get_Unwrap_all_parameters();
    internal static string get_Unwrap_and_indent_all_parameters();
    internal static string get_Wrap_every_parameter();
    internal static string get_Wrap_long_parameter_list();
    internal static string get_Unwrap_parameter_list();
    internal static string get_Align_wrapped_arguments();
    internal static string get_Indent_all_arguments();
    internal static string get_Indent_wrapped_arguments();
    internal static string get_Unwrap_all_arguments();
    internal static string get_Unwrap_and_indent_all_arguments();
    internal static string get_Wrap_every_argument();
    internal static string get_Wrap_long_argument_list();
    internal static string get_Unwrap_argument_list();
    internal static string get_Introduce_constant();
    internal static string get_Introduce_field();
    internal static string get_Introduce_local();
    internal static string get_Introduce_query_variable();
    internal static string get_Failed_to_analyze_data_flow_for_0();
    internal static string get_Fix_formatting();
    internal static string get_Split_into_nested_0_statements();
    internal static string get_Merge_with_outer_0_statement();
    internal static string get_Split_into_consecutive_0_statements();
    internal static string get_Merge_with_previous_0_statement();
    internal static string get_Unwrap_expression();
    internal static string get_Wrap_expression();
    internal static string get_Wrapping();
    internal static string get_Merge_with_nested_0_statement();
    internal static string get_Merge_with_next_0_statement();
    internal static string get_Pull_0_up();
    internal static string get_Pull_members_up_to_base_type();
    internal static string get_Unwrap_call_chain();
    internal static string get_Wrap_call_chain();
    internal static string get_Wrap_long_call_chain();
    internal static string get_Pull_0_up_to_1();
    internal static string get_Wrap_and_align_expression();
    internal static string get_Move_contents_to_namespace();
    internal static string get_Add_optional_parameter_to_constructor();
    internal static string get_Add_parameter_to_constructor();
    internal static string get_Target_type_matches();
    internal static string get_Generate_parameter_0();
    internal static string get_Generate_parameter_0_and_overrides_implementations();
    internal static string get_in_Source_attribute();
    internal static string get_StreamMustSupportReadAndSeek();
    internal static string get_MethodMustReturnStreamThatSupportsReadAndSeek();
    internal static string get_RudeEdit();
    internal static string get_EditAndContinueDisallowedByModule();
    internal static string get_CannotApplyChangesUnexpectedError();
    internal static string get_ErrorReadingFile();
    internal static string get_EditAndContinueDisallowedByProject();
    internal static string get_ChangesNotAppliedWhileRunning();
    internal static string get_DocumentIsOutOfSyncWithDebuggee();
    internal static string get_UnableToReadSourceFileOrPdb();
    internal static string get_ChangesDisallowedWhileStoppedAtException();
    internal static string get_Wrap_and_align_call_chain();
    internal static string get_Wrap_and_align_long_call_chain();
    internal static string get_Warning_colon_semantics_may_change_when_converting_statement();
    internal static string get_Add_null_checks_for_all_parameters();
    internal static string get_Implement_0_implicitly();
    internal static string get_Implement_all_interfaces_implicitly();
    internal static string get_Implement_implicitly();
    internal static string get_Implement_0_explicitly();
    internal static string get_Make_member_static();
    internal static string get_ChangeSignature_NewParameterIntroduceTODOVariable();
    internal static string get_ChangeSignature_NewParameterOmitValue();
    internal static string get_Value_colon();
    internal static string get_Implement_through_0();
    internal static string get_Implement_all_interfaces_explicitly();
    internal static string get_Implement_explicitly();
    internal static string get_Resolve_conflict_markers();
    internal static string get_Base_classes_contain_inaccessible_unimplemented_members();
    internal static string get_Add_DebuggerDisplay_attribute();
    internal static string get_Do_not_change_this_code_Put_cleanup_code_in_0_method();
    internal static string get_TODO_colon_free_unmanaged_resources_unmanaged_objects_and_override_finalizer();
    internal static string get_TODO_colon_override_finalizer_only_if_0_has_code_to_free_unmanaged_resources();
    internal static string get_AM_PM_abbreviated();
    internal static string get_AM_PM_abbreviated_description();
    internal static string get_AM_PM_full();
    internal static string get_AM_PM_full_description();
    internal static string get_date_separator();
    internal static string get_date_separator_description();
    internal static string get_day_of_the_month_1_2_digits();
    internal static string get_day_of_the_month_1_2_digits_description();
    internal static string get_day_of_the_month_2_digits();
    internal static string get_day_of_the_month_2_digits_description();
    internal static string get_day_of_the_week_abbreviated();
    internal static string get_day_of_the_week_abbreviated_description();
    internal static string get_day_of_the_week_full();
    internal static string get_day_of_the_week_full_description();
    internal static string get_full_long_date_time();
    internal static string get_full_long_date_time_description();
    internal static string get_full_short_date_time();
    internal static string get_full_short_date_time_description();
    internal static string get_general_long_date_time();
    internal static string get_general_long_date_time_description();
    internal static string get_general_short_date_time();
    internal static string get_general_short_date_time_description();
    internal static string get_long_date();
    internal static string get_long_date_description();
    internal static string get_long_time();
    internal static string get_long_time_description();
    internal static string get_minute_1_2_digits();
    internal static string get_minute_1_2_digits_description();
    internal static string get_minute_2_digits();
    internal static string get_minute_2_digits_description();
    internal static string get_month_1_2_digits();
    internal static string get_month_1_2_digits_description();
    internal static string get_month_2_digits();
    internal static string get_month_2_digits_description();
    internal static string get_month_abbreviated();
    internal static string get_month_abbreviated_description();
    internal static string get_month_day();
    internal static string get_month_day_description();
    internal static string get_month_full();
    internal static string get_month_full_description();
    internal static string get_period_era();
    internal static string get_period_era_description();
    internal static string get_rfc1123_date_time();
    internal static string get_rfc1123_date_time_description();
    internal static string get_round_trip_date_time();
    internal static string get_round_trip_date_time_description();
    internal static string get_second_1_2_digits();
    internal static string get_second_1_2_digits_description();
    internal static string get_second_2_digits();
    internal static string get_second_2_digits_description();
    internal static string get_short_date();
    internal static string get_short_date_description();
    internal static string get_short_time();
    internal static string get_short_time_description();
    internal static string get_sortable_date_time();
    internal static string get_sortable_date_time_description();
    internal static string get_time_separator();
    internal static string get_time_separator_description();
    internal static string get_time_zone();
    internal static string get_time_zone_description();
    internal static string get_universal_full_date_time();
    internal static string get_universal_full_date_time_description();
    internal static string get_universal_sortable_date_time();
    internal static string get_universal_sortable_date_time_description();
    internal static string get_utc_hour_and_minute_offset();
    internal static string get_utc_hour_and_minute_offset_description();
    internal static string get_utc_hour_offset_1_2_digits();
    internal static string get_utc_hour_offset_1_2_digits_description();
    internal static string get_utc_hour_offset_2_digits();
    internal static string get_utc_hour_offset_2_digits_description();
    internal static string get_year_1_2_digits();
    internal static string get_year_1_2_digits_description();
    internal static string get_year_2_digits();
    internal static string get_year_2_digits_description();
    internal static string get_year_3_4_digits();
    internal static string get_year_3_4_digits_description();
    internal static string get_year_4_digits();
    internal static string get_year_4_digits_description();
    internal static string get_year_5_digits();
    internal static string get_year_5_digits_description();
    internal static string get_year_month();
    internal static string get_year_month_description();
    internal static string get__10000000ths_of_a_second();
    internal static string get__10000000ths_of_a_second_description();
    internal static string get__10000000ths_of_a_second_non_zero();
    internal static string get__10000000ths_of_a_second_non_zero_description();
    internal static string get__1000000ths_of_a_second();
    internal static string get__1000000ths_of_a_second_description();
    internal static string get__1000000ths_of_a_second_non_zero();
    internal static string get__1000000ths_of_a_second_non_zero_description();
    internal static string get__100000ths_of_a_second();
    internal static string get__100000ths_of_a_second_description();
    internal static string get__100000ths_of_a_second_non_zero();
    internal static string get__100000ths_of_a_second_non_zero_description();
    internal static string get__10000ths_of_a_second();
    internal static string get__10000ths_of_a_second_description();
    internal static string get__10000ths_of_a_second_non_zero();
    internal static string get__10000ths_of_a_second_non_zero_description();
    internal static string get__1000ths_of_a_second();
    internal static string get__1000ths_of_a_second_description();
    internal static string get__1000ths_of_a_second_non_zero();
    internal static string get__1000ths_of_a_second_non_zero_description();
    internal static string get__100ths_of_a_second();
    internal static string get__100ths_of_a_second_description();
    internal static string get__100ths_of_a_second_non_zero();
    internal static string get__100ths_of_a_second_non_zero_description();
    internal static string get__10ths_of_a_second();
    internal static string get__10ths_of_a_second_description();
    internal static string get__10ths_of_a_second_non_zero();
    internal static string get__10ths_of_a_second_non_zero_description();
    internal static string get__12_hour_clock_1_2_digits();
    internal static string get__12_hour_clock_1_2_digits_description();
    internal static string get__12_hour_clock_2_digits();
    internal static string get__12_hour_clock_2_digits_description();
    internal static string get__24_hour_clock_1_2_digits();
    internal static string get__24_hour_clock_1_2_digits_description();
    internal static string get__24_hour_clock_2_digits();
    internal static string get__24_hour_clock_2_digits_description();
    internal static string get_Implement_remaining_members_explicitly();
    internal static string get_Generate_for_0();
    internal static string get_Generate_comparison_operators();
    internal static string get_Create_and_assign_remaining_as_fields();
    internal static string get_Create_and_assign_remaining_as_properties();
    internal static string get_Add_explicit_cast();
    internal static string get_Example();
    internal static string get_Examples();
    internal static string get_Alternation_conditions_cannot_be_comments();
    internal static string get_Alternation_conditions_do_not_capture_and_cannot_be_named();
    internal static string get_A_subtraction_must_be_the_last_element_in_a_character_class();
    internal static string get_Cannot_include_class_0_in_character_range();
    internal static string get_Capture_group_numbers_must_be_less_than_or_equal_to_Int32_MaxValue();
    internal static string get_Capture_number_cannot_be_zero();
    internal static string get_Illegal_backslash_at_end_of_pattern();
    internal static string get_Illegal_x_y_with_x_less_than_y();
    internal static string get_Incomplete_character_escape();
    internal static string get_Insufficient_hexadecimal_digits();
    internal static string get_Invalid_group_name_Group_names_must_begin_with_a_word_character();
    internal static string get_Malformed();
    internal static string get_Malformed_character_escape();
    internal static string get_Malformed_named_back_reference();
    internal static string get_Missing_control_character();
    internal static string get_Nested_quantifier_0();
    internal static string get_Not_enough_close_parens();
    internal static string get_Quantifier_x_y_following_nothing();
    internal static string get_Reference_to_undefined_group();
    internal static string get_Reference_to_undefined_group_name_0();
    internal static string get_Reference_to_undefined_group_number_0();
    internal static string get_Too_many_bars_in_conditional_grouping();
    internal static string get_Too_many_close_parens();
    internal static string get_Unknown_property();
    internal static string get_Unknown_property_0();
    internal static string get_Unrecognized_control_character();
    internal static string get_Unrecognized_escape_sequence_0();
    internal static string get_Unrecognized_grouping_construct();
    internal static string get_Unterminated_character_class_set();
    internal static string get_Unterminated_regex_comment();
    internal static string get_x_y_range_in_reverse_order();
    internal static string get_Regex_issue_0();
    internal static string get_Regex_number_decimal_digit();
    internal static string get_Regex_number_letter();
    internal static string get_Regex_number_other();
    internal static string get_Regex_other_control();
    internal static string get_Regex_other_format();
    internal static string get_Regex_other_not_assigned();
    internal static string get_Regex_other_private_use();
    internal static string get_Regex_other_surrogate();
    internal static string get_Regex_punctuation_close();
    internal static string get_Regex_punctuation_connector();
    internal static string get_Regex_punctuation_dash();
    internal static string get_Regex_punctuation_final_quote();
    internal static string get_Regex_punctuation_initial_quote();
    internal static string get_Regex_punctuation_open();
    internal static string get_Regex_punctuation_other();
    internal static string get_Regex_separator_line();
    internal static string get_Regex_separator_paragraph();
    internal static string get_Regex_separator_space();
    internal static string get_Regex_symbol_currency();
    internal static string get_Regex_symbol_math();
    internal static string get_Regex_symbol_modifier();
    internal static string get_Regex_symbol_other();
    internal static string get_Regex_letter_lowercase();
    internal static string get_Regex_letter_modifier();
    internal static string get_Regex_letter_other();
    internal static string get_Regex_letter_titlecase();
    internal static string get_Regex_mark_enclosing();
    internal static string get_Regex_mark_nonspacing();
    internal static string get_Regex_mark_spacing_combining();
    internal static string get_Regex_contiguous_matches_long();
    internal static string get_Regex_contiguous_matches_short();
    internal static string get_Regex_end_of_string_only_long();
    internal static string get_Regex_end_of_string_only_short();
    internal static string get_Regex_end_of_string_or_before_ending_newline_long();
    internal static string get_Regex_end_of_string_or_before_ending_newline_short();
    internal static string get_Regex_non_word_boundary_long();
    internal static string get_Regex_non_word_boundary_short();
    internal static string get_Regex_start_of_string_only_long();
    internal static string get_Regex_start_of_string_only_short();
    internal static string get_Regex_word_boundary_long();
    internal static string get_Regex_word_boundary_short();
    internal static string get_Regex_start_of_string_or_line_long();
    internal static string get_Regex_start_of_string_or_line_short();
    internal static string get_Regex_end_of_string_or_line_long();
    internal static string get_Regex_end_of_string_or_line_short();
    internal static string get_Regex_any_character_group_long();
    internal static string get_Regex_any_character_group_short();
    internal static string get_Regex_backspace_character_long();
    internal static string get_Regex_backspace_character_short();
    internal static string get_Regex_bell_character_long();
    internal static string get_Regex_bell_character_short();
    internal static string get_Regex_carriage_return_character_long();
    internal static string get_Regex_carriage_return_character_short();
    internal static string get_Regex_control_character_long();
    internal static string get_Regex_control_character_short();
    internal static string get_Regex_decimal_digit_character_long();
    internal static string get_Regex_decimal_digit_character_short();
    internal static string get_Regex_escape_character_long();
    internal static string get_Regex_escape_character_short();
    internal static string get_Regex_form_feed_character_long();
    internal static string get_Regex_form_feed_character_short();
    internal static string get_Regex_hexadecimal_escape_long();
    internal static string get_Regex_hexadecimal_escape_short();
    internal static string get_Regex_letter_uppercase();
    internal static string get_Regex_matched_subexpression_long();
    internal static string get_Regex_matched_subexpression_short();
    internal static string get_Regex_negative_character_group_long();
    internal static string get_Regex_negative_character_group_short();
    internal static string get_Regex_negative_character_range_long();
    internal static string get_Regex_negative_character_range_short();
    internal static string get_Regex_negative_unicode_category_long();
    internal static string get_Regex_negative_unicode_category_short();
    internal static string get_Regex_new_line_character_long();
    internal static string get_Regex_new_line_character_short();
    internal static string get_Regex_non_digit_character_long();
    internal static string get_Regex_non_digit_character_short();
    internal static string get_Regex_non_white_space_character_long();
    internal static string get_Regex_non_white_space_character_short();
    internal static string get_Regex_non_word_character_long();
    internal static string get_Regex_non_word_character_short();
    internal static string get_Regex_positive_character_group_long();
    internal static string get_Regex_positive_character_group_short();
    internal static string get_Regex_positive_character_range_long();
    internal static string get_Regex_positive_character_range_short();
    internal static string get_Regex_subexpression();
    internal static string get_Regex_tab_character_long();
    internal static string get_Regex_tab_character_short();
    internal static string get_Regex_unicode_category_long();
    internal static string get_Regex_unicode_category_short();
    internal static string get_Regex_unicode_escape_long();
    internal static string get_Regex_unicode_escape_short();
    internal static string get_Regex_vertical_tab_character_long();
    internal static string get_Regex_vertical_tab_character_short();
    internal static string get_Regex_white_space_character_long();
    internal static string get_Regex_white_space_character_short();
    internal static string get_Regex_word_character_long();
    internal static string get_Regex_word_character_short();
    internal static string get_Regex_alternation_long();
    internal static string get_Regex_alternation_short();
    internal static string get_Regex_balancing_group_long();
    internal static string get_Regex_balancing_group_short();
    internal static string get_Regex_comment();
    internal static string get_Regex_conditional_expression_match_long();
    internal static string get_Regex_conditional_expression_match_short();
    internal static string get_Regex_conditional_group_match_long();
    internal static string get_Regex_conditional_group_match_short();
    internal static string get_Regex_end_of_line_comment_long();
    internal static string get_Regex_end_of_line_comment_short();
    internal static string get_Regex_expression();
    internal static string get_Regex_group_options_long();
    internal static string get_Regex_group_options_short();
    internal static string get_Regex_inline_comment_long();
    internal static string get_Regex_inline_comment_short();
    internal static string get_Regex_name();
    internal static string get_Regex_name1();
    internal static string get_Regex_name2();
    internal static string get_Regex_named_backreference_long();
    internal static string get_Regex_named_backreference_short();
    internal static string get_Regex_named_matched_subexpression_long();
    internal static string get_Regex_named_matched_subexpression_short();
    internal static string get_Regex_name_or_number();
    internal static string get_Regex_no();
    internal static string get_Regex_atomic_group_long();
    internal static string get_Regex_atomic_group_short();
    internal static string get_Regex_noncapturing_group_long();
    internal static string get_Regex_noncapturing_group_short();
    internal static string get_Regex_numbered_backreference_long();
    internal static string get_Regex_numbered_backreference_short();
    internal static string get_Regex_yes();
    internal static string get_Regex_zero_width_negative_lookahead_assertion_long();
    internal static string get_Regex_zero_width_negative_lookahead_assertion_short();
    internal static string get_Regex_zero_width_negative_lookbehind_assertion_long();
    internal static string get_Regex_zero_width_negative_lookbehind_assertion_short();
    internal static string get_Regex_zero_width_positive_lookahead_assertion_long();
    internal static string get_Regex_zero_width_positive_lookahead_assertion_short();
    internal static string get_Regex_zero_width_positive_lookbehind_assertion_long();
    internal static string get_Regex_zero_width_positive_lookbehind_assertion_short();
    internal static string get_Regex_all_control_characters_long();
    internal static string get_Regex_all_control_characters_short();
    internal static string get_Regex_all_diacritic_marks_long();
    internal static string get_Regex_all_diacritic_marks_short();
    internal static string get_Regex_all_letter_characters_long();
    internal static string get_Regex_all_letter_characters_short();
    internal static string get_Regex_all_numbers_long();
    internal static string get_Regex_all_numbers_short();
    internal static string get_Regex_all_punctuation_characters_long();
    internal static string get_Regex_all_punctuation_characters_short();
    internal static string get_Regex_all_separator_characters_long();
    internal static string get_Regex_all_separator_characters_short();
    internal static string get_Regex_all_symbols_long();
    internal static string get_Regex_all_symbols_short();
    internal static string get_Regex_base_group();
    internal static string get_Regex_character_class_subtraction_long();
    internal static string get_Regex_character_class_subtraction_short();
    internal static string get_Regex_character_group();
    internal static string get_Regex_excluded_group();
    internal static string get_Regex_match_at_least_n_times_lazy_long();
    internal static string get_Regex_match_at_least_n_times_lazy_short();
    internal static string get_Regex_match_at_least_n_times_long();
    internal static string get_Regex_match_at_least_n_times_short();
    internal static string get_Regex_match_between_m_and_n_times_lazy_long();
    internal static string get_Regex_match_between_m_and_n_times_lazy_short();
    internal static string get_Regex_match_between_m_and_n_times_long();
    internal static string get_Regex_match_between_m_and_n_times_short();
    internal static string get_Regex_match_exactly_n_times_lazy_long();
    internal static string get_Regex_match_exactly_n_times_lazy_short();
    internal static string get_Regex_match_exactly_n_times_long();
    internal static string get_Regex_match_exactly_n_times_short();
    internal static string get_Regex_match_one_or_more_times_lazy_long();
    internal static string get_Regex_match_one_or_more_times_lazy_short();
    internal static string get_Regex_match_one_or_more_times_long();
    internal static string get_Regex_match_one_or_more_times_short();
    internal static string get_Regex_match_zero_or_more_times_lazy_long();
    internal static string get_Regex_match_zero_or_more_times_lazy_short();
    internal static string get_Regex_match_zero_or_more_times_long();
    internal static string get_Regex_match_zero_or_more_times_short();
    internal static string get_Regex_match_zero_or_one_time_lazy_long();
    internal static string get_Regex_match_zero_or_one_time_lazy_short();
    internal static string get_Regex_match_zero_or_one_time_long();
    internal static string get_Regex_match_zero_or_one_time_short();
    internal static string get_Regex_unicode_general_category_0();
    internal static string get_Regex_inline_options_long();
    internal static string get_Regex_inline_options_short();
    internal static string get__0_cannot_be_null_or_empty();
    internal static string get__0_cannot_be_null_or_whitespace();
    internal static string get__0_is_not_null_here();
    internal static string get__0_may_be_null_here();
    internal static string get_ChangeSignature_NewParameterInferValue();
    internal static string get_Convert_type_to_0();
    internal static string get_from_metadata();
    internal static string get_symbol_cannot_be_a_namespace();
    internal static string get_Document_must_be_contained_in_the_workspace_that_created_this_service();
    internal static string get_Generate_constructor_in_0_with_fields();
    internal static string get_Generate_constructor_in_0_with_properties();
    internal static string get_Property_reference_cannot_be_updated();
    internal static string get_Make_class_abstract();
    internal static string get_Inline_0();
    internal static string get_Remove_async_modifier();
    internal static string get_Extract_base_class();
    internal static string get_Inline_and_keep_0();
    internal static string get_Pull_members_up_to_new_base_class();
    internal static string get_The_assembly_0_containing_type_1_references_NET_Framework();
    internal static string get_Error_creating_instance_of_CodeFixProvider();
    internal static string get_Error_creating_instance_of_CodeFixProvider_0();
    internal static string get_Removal_of_document_not_supported();
    internal static string get_in_0_1_2();
    internal static string get__0_dash_1();
    internal static string get_Convert_to_record();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal abstract class Microsoft.CodeAnalysis.FileHeaders.AbstractFileHeaderCodeFixProvider : CodeFixProvider {
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private ImmutableArray`1<string> <FixableDiagnosticIds>k__BackingField;
    protected AbstractFileHeaderHelper FileHeaderHelper { get; }
    protected ISyntaxFacts SyntaxFacts { get; }
    protected ISyntaxKinds SyntaxKinds { get; }
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ImmutableArray`1<string> FixableDiagnosticIds { get; }
    protected abstract virtual AbstractFileHeaderHelper get_FileHeaderHelper();
    protected abstract virtual ISyntaxFacts get_SyntaxFacts();
    protected abstract virtual ISyntaxKinds get_SyntaxKinds();
    protected abstract virtual SyntaxTrivia EndOfLine(string text);
    [CompilerGeneratedAttribute]
public virtual ImmutableArray`1<string> get_FixableDiagnosticIds();
    public virtual Task RegisterCodeFixesAsync(CodeFixContext context);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.FileHeaders.AbstractFileHeaderCodeFixProvider/<GetTransformedDocumentAsync>d__11")]
private Task`1<Document> GetTransformedDocumentAsync(Document document, CancellationToken cancellationToken);
    private Task`1<SyntaxNode> GetTransformedSyntaxRootAsync(Document document, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.FileHeaders.AbstractFileHeaderCodeFixProvider/<GetTransformedSyntaxRootAsync>d__13")]
internal static Task`1<SyntaxNode> GetTransformedSyntaxRootAsync(ISyntaxFacts syntaxFacts, AbstractFileHeaderHelper fileHeaderHelper, SyntaxTrivia newLineTrivia, Document document, CancellationToken cancellationToken);
    private static SyntaxNode ReplaceHeader(ISyntaxFacts syntaxFacts, AbstractFileHeaderHelper fileHeaderHelper, SyntaxTrivia newLineTrivia, SyntaxNode root, string expectedFileHeader);
    private static SyntaxNode AddHeader(ISyntaxFacts syntaxFacts, AbstractFileHeaderHelper fileHeaderHelper, SyntaxTrivia newLineTrivia, SyntaxNode root, string expectedFileHeader);
    private static SyntaxTriviaList CreateNewHeader(ISyntaxFacts syntaxFacts, string prefixWithLeadingSpaces, string expectedFileHeader, string newLineText);
    private static string GetCopyrightText(string prefixWithLeadingSpaces, string copyrightText, string newLineText);
    public virtual FixAllProvider GetFixAllProvider();
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.FileHeaders.AbstractFileHeaderCodeFixProvider/<<GetFixAllProvider>b__19_0>d")]
[CompilerGeneratedAttribute]
private Task`1<Document> <GetFixAllProvider>b__19_0(FixAllContext context, Document document, ImmutableArray`1<Diagnostic> diagnostics);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal abstract class Microsoft.CodeAnalysis.FileHeaders.AbstractFileHeaderDiagnosticAnalyzer : AbstractBuiltInCodeStyleDiagnosticAnalyzer {
    [CompilerGeneratedAttribute]
private DiagnosticDescriptor <InvalidHeaderDescriptor>k__BackingField;
    protected AbstractFileHeaderHelper FileHeaderHelper { get; }
    internal DiagnosticDescriptor MissingHeaderDescriptor { get; }
    internal DiagnosticDescriptor InvalidHeaderDescriptor { get; }
    protected AbstractFileHeaderDiagnosticAnalyzer(string language);
    protected abstract virtual AbstractFileHeaderHelper get_FileHeaderHelper();
    internal DiagnosticDescriptor get_MissingHeaderDescriptor();
    [CompilerGeneratedAttribute]
internal DiagnosticDescriptor get_InvalidHeaderDescriptor();
    public virtual DiagnosticAnalyzerCategory GetAnalyzerCategory();
    protected virtual void InitializeWorker(AnalysisContext context);
    private void HandleSyntaxTree(SyntaxTreeAnalysisContext context);
    private static bool CompareCopyrightText(string expectedFileHeader, string copyrightText);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal abstract class Microsoft.CodeAnalysis.FileHeaders.AbstractFileHeaderHelper : object {
    [CompilerGeneratedAttribute]
private int <SingleLineCommentTriviaKind>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<int> <MultiLineCommentTriviaKind>k__BackingField;
    [CompilerGeneratedAttribute]
private int <WhitespaceTriviaKind>k__BackingField;
    [CompilerGeneratedAttribute]
private int <EndOfLineTriviaKind>k__BackingField;
    public string CommentPrefix { get; }
    private int SingleLineCommentTriviaKind { get; }
    private Nullable`1<int> MultiLineCommentTriviaKind { get; }
    private int WhitespaceTriviaKind { get; }
    private int EndOfLineTriviaKind { get; }
    protected AbstractFileHeaderHelper(ISyntaxKinds syntaxKinds);
    public abstract virtual string get_CommentPrefix();
    [NullableContextAttribute("0")]
protected abstract virtual ReadOnlyMemory`1<char> GetTextContextOfComment(SyntaxTrivia commentTrivia);
    [CompilerGeneratedAttribute]
private int get_SingleLineCommentTriviaKind();
    [CompilerGeneratedAttribute]
private Nullable`1<int> get_MultiLineCommentTriviaKind();
    [CompilerGeneratedAttribute]
private int get_WhitespaceTriviaKind();
    [CompilerGeneratedAttribute]
private int get_EndOfLineTriviaKind();
    public FileHeader ParseFileHeader(SyntaxNode root);
    private int IndexOfFirstNonWhitespaceTrivia(T triviaList);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[IsReadOnlyAttribute]
internal class Microsoft.CodeAnalysis.FileHeaders.FileHeader : ValueType {
    private int _fileHeaderStart;
    private int _commentPrefixLength;
    [CompilerGeneratedAttribute]
private bool <IsMissing>k__BackingField;
    [CompilerGeneratedAttribute]
private string <CopyrightText>k__BackingField;
    internal bool IsMissing { get; }
    internal string CopyrightText { get; }
    internal FileHeader(string copyrightText, int fileHeaderStart, int fileHeaderEnd, int commentPrefixLength);
    private FileHeader(int fileHeaderStart, bool isMissing);
    [CompilerGeneratedAttribute]
internal bool get_IsMissing();
    [CompilerGeneratedAttribute]
internal string get_CopyrightText();
    internal static FileHeader MissingFileHeader(int fileHeaderStart);
    internal Location GetLocation(SyntaxTree syntaxTree);
}
internal abstract class Microsoft.CodeAnalysis.FindUsages.DefinitionItem : object {
    internal static string Primary;
    internal static string RQNameKey1;
    internal static string RQNameKey2;
    private static string MetadataSymbolKey;
    private static string MetadataSymbolOriginatingProjectIdGuid;
    private static string MetadataSymbolOriginatingProjectIdDebugName;
    private static string NonNavigable;
    [CompilerGeneratedAttribute]
private ImmutableArray`1<string> <Tags>k__BackingField;
    [CompilerGeneratedAttribute]
private ImmutableDictionary`2<string, string> <Properties>k__BackingField;
    [CompilerGeneratedAttribute]
private ImmutableDictionary`2<string, string> <DisplayableProperties>k__BackingField;
    [CompilerGeneratedAttribute]
private ImmutableArray`1<TaggedText> <NameDisplayParts>k__BackingField;
    [CompilerGeneratedAttribute]
private ImmutableArray`1<TaggedText> <DisplayParts>k__BackingField;
    [CompilerGeneratedAttribute]
private ImmutableArray`1<TaggedText> <OriginationParts>k__BackingField;
    [CompilerGeneratedAttribute]
private ImmutableArray`1<DocumentSpan> <SourceSpans>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <DisplayIfNoReferences>k__BackingField;
    public ImmutableArray`1<string> Tags { get; }
    public ImmutableDictionary`2<string, string> Properties { get; }
    public ImmutableDictionary`2<string, string> DisplayableProperties { get; }
    public ImmutableArray`1<TaggedText> NameDisplayParts { get; }
    public ImmutableArray`1<TaggedText> DisplayParts { get; }
    public ImmutableArray`1<TaggedText> OriginationParts { get; }
    public ImmutableArray`1<DocumentSpan> SourceSpans { get; }
    public bool DisplayIfNoReferences { get; }
    internal bool IsExternal { get; }
    protected DefinitionItem(ImmutableArray`1<string> tags, ImmutableArray`1<TaggedText> displayParts, ImmutableArray`1<TaggedText> nameDisplayParts, ImmutableArray`1<TaggedText> originationParts, ImmutableArray`1<DocumentSpan> sourceSpans, ImmutableDictionary`2<string, string> properties, bool displayIfNoReferences);
    protected DefinitionItem(ImmutableArray`1<string> tags, ImmutableArray`1<TaggedText> displayParts, ImmutableArray`1<TaggedText> nameDisplayParts, ImmutableArray`1<TaggedText> originationParts, ImmutableArray`1<DocumentSpan> sourceSpans, ImmutableDictionary`2<string, string> properties, ImmutableDictionary`2<string, string> displayableProperties, bool displayIfNoReferences);
    [CompilerGeneratedAttribute]
public ImmutableArray`1<string> get_Tags();
    [CompilerGeneratedAttribute]
public ImmutableDictionary`2<string, string> get_Properties();
    [CompilerGeneratedAttribute]
public ImmutableDictionary`2<string, string> get_DisplayableProperties();
    [CompilerGeneratedAttribute]
public ImmutableArray`1<TaggedText> get_NameDisplayParts();
    [CompilerGeneratedAttribute]
public ImmutableArray`1<TaggedText> get_DisplayParts();
    [CompilerGeneratedAttribute]
public ImmutableArray`1<TaggedText> get_OriginationParts();
    [CompilerGeneratedAttribute]
public ImmutableArray`1<DocumentSpan> get_SourceSpans();
    [CompilerGeneratedAttribute]
public bool get_DisplayIfNoReferences();
    internal abstract virtual bool get_IsExternal();
    public abstract virtual bool CanNavigateTo(Workspace workspace, CancellationToken cancellationToken);
    public abstract virtual bool TryNavigateTo(Workspace workspace, bool showInPreviewTab, bool activateTab, CancellationToken cancellationToken);
    public static DefinitionItem Create(ImmutableArray`1<string> tags, ImmutableArray`1<TaggedText> displayParts, DocumentSpan sourceSpan, ImmutableArray`1<TaggedText> nameDisplayParts, bool displayIfNoReferences);
    public static DefinitionItem Create(ImmutableArray`1<string> tags, ImmutableArray`1<TaggedText> displayParts, ImmutableArray`1<DocumentSpan> sourceSpans, ImmutableArray`1<TaggedText> nameDisplayParts, bool displayIfNoReferences);
    public static DefinitionItem Create(ImmutableArray`1<string> tags, ImmutableArray`1<TaggedText> displayParts, ImmutableArray`1<DocumentSpan> sourceSpans, ImmutableArray`1<TaggedText> nameDisplayParts, ImmutableDictionary`2<string, string> properties, bool displayIfNoReferences);
    public static DefinitionItem Create(ImmutableArray`1<string> tags, ImmutableArray`1<TaggedText> displayParts, ImmutableArray`1<DocumentSpan> sourceSpans, ImmutableArray`1<TaggedText> nameDisplayParts, ImmutableDictionary`2<string, string> properties, ImmutableDictionary`2<string, string> displayableProperties, bool displayIfNoReferences);
    internal static DefinitionItem CreateMetadataDefinition(ImmutableArray`1<string> tags, ImmutableArray`1<TaggedText> displayParts, ImmutableArray`1<TaggedText> nameDisplayParts, Solution solution, ISymbol symbol, ImmutableDictionary`2<string, string> properties, bool displayIfNoReferences);
    public static DefinitionItem CreateNonNavigableItem(ImmutableArray`1<string> tags, ImmutableArray`1<TaggedText> displayParts, ImmutableArray`1<TaggedText> originationParts, bool displayIfNoReferences);
    public static DefinitionItem CreateNonNavigableItem(ImmutableArray`1<string> tags, ImmutableArray`1<TaggedText> displayParts, ImmutableArray`1<TaggedText> originationParts, ImmutableDictionary`2<string, string> properties, bool displayIfNoReferences);
    internal static ImmutableArray`1<TaggedText> GetOriginationParts(ISymbol symbol);
}
[IsReadOnlyAttribute]
internal class Microsoft.CodeAnalysis.FindUsages.DefinitionsAndReferences : ValueType {
    public static DefinitionsAndReferences Empty;
    [CompilerGeneratedAttribute]
private ImmutableArray`1<DefinitionItem> <Definitions>k__BackingField;
    [CompilerGeneratedAttribute]
private ImmutableArray`1<SourceReferenceItem> <References>k__BackingField;
    public ImmutableArray`1<DefinitionItem> Definitions { get; }
    public ImmutableArray`1<SourceReferenceItem> References { get; }
    public DefinitionsAndReferences(ImmutableArray`1<DefinitionItem> definitions, ImmutableArray`1<SourceReferenceItem> references);
    private static DefinitionsAndReferences();
    [CompilerGeneratedAttribute]
public ImmutableArray`1<DefinitionItem> get_Definitions();
    [CompilerGeneratedAttribute]
public ImmutableArray`1<SourceReferenceItem> get_References();
}
internal enum Microsoft.CodeAnalysis.FindUsages.ExternalScope : Enum {
    public int value__;
    public static ExternalScope Default;
    public static ExternalScope Repository;
    public static ExternalScope Organization;
    public static ExternalScope Global;
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.CodeAnalysis.FindUsages.FindUsagesServerCallback : object {
    private Solution _solution;
    private IFindUsagesContext _context;
    private Dictionary`2<int, DefinitionItem> _idToDefinition;
    public FindUsagesServerCallback(Solution solution, IFindUsagesContext context);
    public ValueTask AddItemsAsync(int count);
    public ValueTask ItemCompletedAsync();
    public ValueTask ReportMessageAsync(string message);
    [ObsoleteAttribute]
public ValueTask ReportProgressAsync(int current, int maximum);
    public ValueTask SetSearchTitleAsync(string title);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.FindUsages.FindUsagesServerCallback/<OnDefinitionFoundAsync>d__9")]
public ValueTask OnDefinitionFoundAsync(SerializableDefinitionItem definition);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.FindUsages.FindUsagesServerCallback/<OnReferenceFoundAsync>d__10")]
public ValueTask OnReferenceFoundAsync(SerializableSourceReferenceItem reference);
    private DefinitionItem GetDefinition(int definitionId);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExportRemoteServiceCallbackDispatcherAttribute("Microsoft.CodeAnalysis.FindUsages.IRemoteFindUsagesService")]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.FindUsages.FindUsagesServerCallbackDispatcher : RemoteServiceCallbackDispatcher {
    private FindUsagesServerCallback GetCallback(RemoteServiceCallbackId callbackId);
    public sealed virtual ValueTask AddItemsAsync(RemoteServiceCallbackId callbackId, int count);
    public sealed virtual ValueTask ItemCompletedAsync(RemoteServiceCallbackId callbackId);
    public sealed virtual ValueTask OnDefinitionFoundAsync(RemoteServiceCallbackId callbackId, SerializableDefinitionItem definition);
    public sealed virtual ValueTask OnReferenceFoundAsync(RemoteServiceCallbackId callbackId, SerializableSourceReferenceItem reference);
    public sealed virtual ValueTask ReportMessageAsync(RemoteServiceCallbackId callbackId, string message);
    [ObsoleteAttribute]
public sealed virtual ValueTask ReportProgressAsync(RemoteServiceCallbackId callbackId, int current, int maximum);
    public sealed virtual ValueTask SetSearchTitleAsync(RemoteServiceCallbackId callbackId, string title);
}
internal interface Microsoft.CodeAnalysis.FindUsages.IFindUsagesContext {
    public CancellationToken CancellationToken { get; }
    public IStreamingProgressTracker ProgressTracker { get; }
    public abstract virtual CancellationToken get_CancellationToken();
    public abstract virtual IStreamingProgressTracker get_ProgressTracker();
    public abstract virtual ValueTask ReportMessageAsync(string message);
    public abstract virtual ValueTask SetSearchTitleAsync(string title);
    public abstract virtual ValueTask OnDefinitionFoundAsync(DefinitionItem definition);
    public abstract virtual ValueTask OnReferenceFoundAsync(SourceReferenceItem reference);
    [ObsoleteAttribute("Use ProgressTracker instead", "False")]
public abstract virtual ValueTask ReportProgressAsync(int current, int maximum);
}
[NullableContextAttribute("1")]
internal interface Microsoft.CodeAnalysis.FindUsages.IRemoteFindUsagesService {
    public abstract virtual ValueTask FindReferencesAsync(PinnedSolutionInfo solutionInfo, RemoteServiceCallbackId callbackId, SerializableSymbolAndProjectId symbolAndProjectId, FindReferencesSearchOptions options, CancellationToken cancellationToken);
    public abstract virtual ValueTask FindImplementationsAsync(PinnedSolutionInfo solutionInfo, RemoteServiceCallbackId callbackId, SerializableSymbolAndProjectId symbolAndProjectId, CancellationToken cancellationToken);
}
[IsReadOnlyAttribute]
[DataContractAttribute]
internal class Microsoft.CodeAnalysis.FindUsages.SerializableDefinitionItem : ValueType {
    [DataMemberAttribute]
public int Id;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[DataMemberAttribute]
public ImmutableArray`1<string> Tags;
    [DataMemberAttribute]
public ImmutableArray`1<TaggedText> DisplayParts;
    [DataMemberAttribute]
public ImmutableArray`1<TaggedText> NameDisplayParts;
    [DataMemberAttribute]
public ImmutableArray`1<TaggedText> OriginationParts;
    [DataMemberAttribute]
public ImmutableArray`1<SerializableDocumentSpan> SourceSpans;
    [NullableAttribute("1")]
[DataMemberAttribute]
public ImmutableDictionary`2<string, string> Properties;
    [NullableAttribute("1")]
[DataMemberAttribute]
public ImmutableDictionary`2<string, string> DisplayableProperties;
    [DataMemberAttribute]
public bool DisplayIfNoReferences;
    public SerializableDefinitionItem(int id, ImmutableArray`1<string> tags, ImmutableArray`1<TaggedText> displayParts, ImmutableArray`1<TaggedText> nameDisplayParts, ImmutableArray`1<TaggedText> originationParts, ImmutableArray`1<SerializableDocumentSpan> sourceSpans, ImmutableDictionary`2<string, string> properties, ImmutableDictionary`2<string, string> displayableProperties, bool displayIfNoReferences);
    [NullableContextAttribute("1")]
public static SerializableDefinitionItem Dehydrate(int id, DefinitionItem item);
    [NullableContextAttribute("1")]
[AsyncStateMachineAttribute("Microsoft.CodeAnalysis.FindUsages.SerializableDefinitionItem/<RehydrateAsync>d__11")]
public ValueTask`1<DefinitionItem> RehydrateAsync(Solution solution, CancellationToken cancellationToken);
}
[IsReadOnlyAttribute]
[DataContractAttribute]
internal class Microsoft.CodeAnalysis.FindUsages.SerializableDocumentSpan : ValueType {
    [NullableAttribute("1")]
[DataMemberAttribute]
public DocumentId DocumentId;
    [DataMemberAttribute]
public TextSpan SourceSpan;
    [NullableContextAttribute("1")]
public SerializableDocumentSpan(DocumentId documentId, TextSpan sourceSpan);
    public static SerializableDocumentSpan Dehydrate(DocumentSpan documentSpan);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.FindUsages.SerializableDocumentSpan/<RehydrateAsync>d__4")]
public ValueTask`1<DocumentSpan> RehydrateAsync(Solution solution, CancellationToken cancellationToken);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[IsReadOnlyAttribute]
[DataContractAttribute]
internal class Microsoft.CodeAnalysis.FindUsages.SerializableSourceReferenceItem : ValueType {
    [DataMemberAttribute]
public int DefinitionId;
    [DataMemberAttribute]
public SerializableDocumentSpan SourceSpan;
    [DataMemberAttribute]
public SymbolUsageInfo SymbolUsageInfo;
    [DataMemberAttribute]
public ImmutableDictionary`2<string, string> AdditionalProperties;
    public SerializableSourceReferenceItem(int definitionId, SerializableDocumentSpan sourceSpan, SymbolUsageInfo symbolUsageInfo, ImmutableDictionary`2<string, string> additionalProperties);
    public static SerializableSourceReferenceItem Dehydrate(int definitionId, SourceReferenceItem item);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.FindUsages.SerializableSourceReferenceItem/<RehydrateAsync>d__6")]
public Task`1<SourceReferenceItem> RehydrateAsync(Solution solution, DefinitionItem definition, CancellationToken cancellationToken);
}
internal class Microsoft.CodeAnalysis.FindUsages.SourceReferenceItem : object {
    [CompilerGeneratedAttribute]
private DefinitionItem <Definition>k__BackingField;
    [CompilerGeneratedAttribute]
private DocumentSpan <SourceSpan>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsWrittenTo>k__BackingField;
    [CompilerGeneratedAttribute]
private SymbolUsageInfo <SymbolUsageInfo>k__BackingField;
    [CompilerGeneratedAttribute]
private ImmutableDictionary`2<string, string> <AdditionalProperties>k__BackingField;
    public DefinitionItem Definition { get; }
    public DocumentSpan SourceSpan { get; }
    public bool IsWrittenTo { get; }
    public SymbolUsageInfo SymbolUsageInfo { get; }
    public ImmutableDictionary`2<string, string> AdditionalProperties { get; }
    private SourceReferenceItem(DefinitionItem definition, DocumentSpan sourceSpan, SymbolUsageInfo symbolUsageInfo, ImmutableDictionary`2<string, string> additionalProperties, bool isWrittenTo);
    internal SourceReferenceItem(DefinitionItem definition, DocumentSpan sourceSpan);
    internal SourceReferenceItem(DefinitionItem definition, DocumentSpan sourceSpan, SymbolUsageInfo symbolUsageInfo);
    internal SourceReferenceItem(DefinitionItem definition, DocumentSpan sourceSpan, SymbolUsageInfo symbolUsageInfo, ImmutableDictionary`2<string, string> additionalProperties);
    [CompilerGeneratedAttribute]
public DefinitionItem get_Definition();
    [CompilerGeneratedAttribute]
public DocumentSpan get_SourceSpan();
    [CompilerGeneratedAttribute]
public bool get_IsWrittenTo();
    [CompilerGeneratedAttribute]
public SymbolUsageInfo get_SymbolUsageInfo();
    [CompilerGeneratedAttribute]
public ImmutableDictionary`2<string, string> get_AdditionalProperties();
}
[ExportCodeFixProviderAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.Formatting.FormattingCodeFixProvider : SyntaxEditorBasedCodeFixProvider {
    public ImmutableArray`1<string> FixableDiagnosticIds { get; }
    internal CodeFixCategory CodeFixCategory { get; }
    public virtual ImmutableArray`1<string> get_FixableDiagnosticIds();
    internal sealed virtual CodeFixCategory get_CodeFixCategory();
    public virtual Task RegisterCodeFixesAsync(CodeFixContext context);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.Formatting.FormattingCodeFixProvider/<FixOneAsync>d__6")]
private static Task`1<Document> FixOneAsync(CodeFixContext context, Diagnostic diagnostic, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.Formatting.FormattingCodeFixProvider/<FixAllAsync>d__7")]
protected virtual Task FixAllAsync(Document document, ImmutableArray`1<Diagnostic> diagnostics, SyntaxEditor editor, CancellationToken cancellationToken);
}
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
internal class Microsoft.CodeAnalysis.Formatting.FormattingDiagnosticAnalyzer : AbstractBuiltInCodeStyleDiagnosticAnalyzer {
    public virtual DiagnosticAnalyzerCategory GetAnalyzerCategory();
    protected virtual void InitializeWorker(AnalysisContext context);
    private void AnalyzeSyntaxTree(SyntaxTreeAnalysisContext context);
}
internal static class Microsoft.CodeAnalysis.FormattingCodeFixHelper : object {
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.FormattingCodeFixHelper/<FixOneAsync>d__0")]
internal static Task`1<SyntaxTree> FixOneAsync(SyntaxTree syntaxTree, Workspace formatterState, OptionSet options, Diagnostic diagnostic, CancellationToken cancellationToken);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExportCodeRefactoringProviderAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.GenerateComparisonOperators.GenerateComparisonOperatorsCodeRefactoringProvider : CodeRefactoringProvider {
    private static string LeftName;
    private static string RightName;
    [NullableAttribute("0")]
private static ImmutableArray`1<CodeGenerationOperatorKind> s_operatorKinds;
    private static GenerateComparisonOperatorsCodeRefactoringProvider();
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.GenerateComparisonOperators.GenerateComparisonOperatorsCodeRefactoringProvider/<ComputeRefactoringsAsync>d__4")]
public virtual Task ComputeRefactoringsAsync(CodeRefactoringContext context);
    private static IMethodSymbol TryGetCompareMethodImpl(INamedTypeSymbol containingType, ITypeSymbol comparableType);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.GenerateComparisonOperators.GenerateComparisonOperatorsCodeRefactoringProvider/<GenerateComparisonOperatorsAsync>d__6")]
private static Task`1<Document> GenerateComparisonOperatorsAsync(Document document, SyntaxNode typeDeclaration, INamedTypeSymbol comparableType, CancellationToken cancellationToken);
    private static SyntaxNode GenerateLeftExpression(SyntaxGenerator generator, INamedTypeSymbol comparableType, IMethodSymbol compareMethod);
    private static ImmutableArray`1<IMethodSymbol> GenerateComparisonOperators(SyntaxGenerator generator, Compilation compilation, INamedTypeSymbol containingType, INamedTypeSymbol comparableType, SyntaxNode thisExpression);
    private static SyntaxNode GenerateStatement(SyntaxGenerator generator, CodeGenerationOperatorKind kind, SyntaxNode leftExpression);
    private static bool HasAllComparisonOperators(INamedTypeSymbol containingType, ITypeSymbol comparedType);
    private static bool HasComparisonOperator(INamedTypeSymbol containingType, ITypeSymbol comparedType, CodeGenerationOperatorKind kind);
    private static string GetOperatorName(CodeGenerationOperatorKind kind);
}
internal abstract class Microsoft.CodeAnalysis.GenerateConstructorFromMembers.AbstractGenerateConstructorFromMembersCodeRefactoringProvider : AbstractGenerateFromMembersCodeRefactoringProvider {
    private static string AddNullChecksId;
    private IPickMembersService _pickMembersService_forTesting;
    protected AbstractGenerateConstructorFromMembersCodeRefactoringProvider(IPickMembersService pickMembersService_forTesting);
    protected abstract virtual bool ContainingTypesOrSelfHasUnsafeKeyword(INamedTypeSymbol containingType);
    protected abstract virtual string ToDisplayString(IParameterSymbol parameter, SymbolDisplayFormat format);
    protected abstract virtual bool PrefersThrowExpression(DocumentOptionSet options);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.GenerateConstructorFromMembers.AbstractGenerateConstructorFromMembersCodeRefactoringProvider/<ComputeRefactoringsAsync>d__8")]
public virtual Task ComputeRefactoringsAsync(CodeRefactoringContext context);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.GenerateConstructorFromMembers.AbstractGenerateConstructorFromMembersCodeRefactoringProvider/<HandleNonSelectionAsync>d__9")]
private Task HandleNonSelectionAsync(CodeRefactoringContext context);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.GenerateConstructorFromMembers.AbstractGenerateConstructorFromMembersCodeRefactoringProvider/<GenerateConstructorFromMembersAsync>d__10")]
public Task`1<ImmutableArray`1<CodeAction>> GenerateConstructorFromMembersAsync(Document document, TextSpan textSpan, bool addNullChecks, CancellationToken cancellationToken);
    private ImmutableArray`1<CodeAction> GetCodeActions(Document document, State state, bool addNullChecks);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.GenerateConstructorFromMembers.AbstractGenerateConstructorFromMembersCodeRefactoringProvider/<AddNavigationAnnotationAsync>d__12")]
private static Task`1<Document> AddNavigationAnnotationAsync(Document document, CancellationToken cancellationToken);
}
internal static class Microsoft.CodeAnalysis.GenerateConstructorFromMembers.GenerateConstructorFromMembersOptions : object {
    [NullableAttribute("1")]
public static PerLanguageOption2`1<bool> AddNullChecks;
    private static GenerateConstructorFromMembersOptions();
}
[ExportCodeRefactoringProviderAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.GenerateDefaultConstructors.GenerateDefaultConstructorsCodeRefactoringProvider : CodeRefactoringProvider {
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.GenerateDefaultConstructors.GenerateDefaultConstructorsCodeRefactoringProvider/<ComputeRefactoringsAsync>d__1")]
public virtual Task ComputeRefactoringsAsync(CodeRefactoringContext context);
}
internal abstract class Microsoft.CodeAnalysis.GenerateEqualsAndGetHashCodeFromMembers.AbstractGenerateEqualsAndGetHashCodeService : object {
    private static string GetHashCodeName;
    private static SyntaxAnnotation s_specializedFormattingAnnotation;
    private static AbstractGenerateEqualsAndGetHashCodeService();
    protected abstract virtual bool TryWrapWithUnchecked(ImmutableArray`1<SyntaxNode> statements, ImmutableArray`1& wrappedStatements);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.GenerateEqualsAndGetHashCodeFromMembers.AbstractGenerateEqualsAndGetHashCodeService/<FormatDocumentAsync>d__3")]
public sealed virtual Task`1<Document> FormatDocumentAsync(Document document, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.GenerateEqualsAndGetHashCodeFromMembers.AbstractGenerateEqualsAndGetHashCodeService/<GenerateEqualsMethodAsync>d__4")]
public sealed virtual Task`1<IMethodSymbol> GenerateEqualsMethodAsync(Document document, INamedTypeSymbol namedType, ImmutableArray`1<ISymbol> members, string localNameOpt, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.GenerateEqualsAndGetHashCodeFromMembers.AbstractGenerateEqualsAndGetHashCodeService/<GenerateIEquatableEqualsMethodAsync>d__5")]
public sealed virtual Task`1<IMethodSymbol> GenerateIEquatableEqualsMethodAsync(Document document, INamedTypeSymbol namedType, ImmutableArray`1<ISymbol> members, INamedTypeSymbol constructedEquatableType, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.GenerateEqualsAndGetHashCodeFromMembers.AbstractGenerateEqualsAndGetHashCodeService/<GenerateEqualsMethodThroughIEquatableEqualsAsync>d__6")]
public sealed virtual Task`1<IMethodSymbol> GenerateEqualsMethodThroughIEquatableEqualsAsync(Document document, INamedTypeSymbol containingType, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.GenerateEqualsAndGetHashCodeFromMembers.AbstractGenerateEqualsAndGetHashCodeService/<GenerateGetHashCodeMethodAsync>d__7")]
public sealed virtual Task`1<IMethodSymbol> GenerateGetHashCodeMethodAsync(Document document, INamedTypeSymbol namedType, ImmutableArray`1<ISymbol> members, CancellationToken cancellationToken);
    private IMethodSymbol CreateGetHashCodeMethod(SyntaxGenerator factory, Compilation compilation, INamedTypeSymbol namedType, ImmutableArray`1<ISymbol> members);
    private ImmutableArray`1<SyntaxNode> CreateGetHashCodeStatements(SyntaxGenerator factory, Compilation compilation, INamedTypeSymbol namedType, ImmutableArray`1<ISymbol> members);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExportCodeRefactoringProviderAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
[SharedAttribute]
[ExtensionOrderAttribute]
internal class Microsoft.CodeAnalysis.GenerateEqualsAndGetHashCodeFromMembers.GenerateEqualsAndGetHashCodeFromMembersCodeRefactoringProvider : AbstractGenerateFromMembersCodeRefactoringProvider {
    public static string GenerateOperatorsId;
    public static string ImplementIEquatableId;
    private static string EqualsName;
    private static string GetHashCodeName;
    [NullableAttribute("2")]
private IPickMembersService _pickMembersService_forTestingPurposes;
    [NullableContextAttribute("2")]
public GenerateEqualsAndGetHashCodeFromMembersCodeRefactoringProvider(IPickMembersService pickMembersService);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.GenerateEqualsAndGetHashCodeFromMembers.GenerateEqualsAndGetHashCodeFromMembersCodeRefactoringProvider/<ComputeRefactoringsAsync>d__8")]
public virtual Task ComputeRefactoringsAsync(CodeRefactoringContext context);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.GenerateEqualsAndGetHashCodeFromMembers.GenerateEqualsAndGetHashCodeFromMembersCodeRefactoringProvider/<HandleNonSelectionAsync>d__9")]
private Task HandleNonSelectionAsync(CodeRefactoringContext context);
    private static bool HasOperators(INamedTypeSymbol containingType);
    private static bool HasOperator(INamedTypeSymbol containingType, string operatorName);
    private static bool CanImplementIEquatable(SemanticModel semanticModel, INamedTypeSymbol containingType, INamedTypeSymbol& constructedType);
    private static void GetExistingMemberInfo(INamedTypeSymbol containingType, Boolean& hasEquals, Boolean& hasGetHashCode);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.GenerateEqualsAndGetHashCodeFromMembers.GenerateEqualsAndGetHashCodeFromMembersCodeRefactoringProvider/<GenerateEqualsAndGetHashCodeFromMembersAsync>d__14")]
public Task`1<ImmutableArray`1<CodeAction>> GenerateEqualsAndGetHashCodeFromMembersAsync(Document document, TextSpan textSpan, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.GenerateEqualsAndGetHashCodeFromMembers.GenerateEqualsAndGetHashCodeFromMembersCodeRefactoringProvider/<CreateActionsAsync>d__15")]
private Task`1<ImmutableArray`1<CodeAction>> CreateActionsAsync(Document document, SyntaxNode typeDeclaration, INamedTypeSymbol containingType, ImmutableArray`1<ISymbol> selectedMembers, bool hasEquals, bool hasGetHashCode, bool withDialog, CancellationToken cancellationToken);
    private Task`1<CodeAction> CreateCodeActionAsync(Document document, SyntaxNode typeDeclaration, INamedTypeSymbol containingType, ImmutableArray`1<ISymbol> members, bool generateEquals, bool generateGetHashCode, bool withDialog, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.GenerateEqualsAndGetHashCodeFromMembers.GenerateEqualsAndGetHashCodeFromMembersCodeRefactoringProvider/<CreateCodeActionWithDialogAsync>d__17")]
private Task`1<CodeAction> CreateCodeActionWithDialogAsync(Document document, SyntaxNode typeDeclaration, INamedTypeSymbol containingType, ImmutableArray`1<ISymbol> members, bool generateEquals, bool generateGetHashCode, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.GenerateEqualsAndGetHashCodeFromMembers.GenerateEqualsAndGetHashCodeFromMembersCodeRefactoringProvider/<CreateCodeActionWithoutDialogAsync>d__18")]
private static Task`1<CodeAction> CreateCodeActionWithoutDialogAsync(Document document, SyntaxNode typeDeclaration, INamedTypeSymbol containingType, ImmutableArray`1<ISymbol> members, bool generateEquals, bool generateGetHashCode, CancellationToken cancellationToken);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal static class Microsoft.CodeAnalysis.GenerateEqualsAndGetHashCodeFromMembers.GenerateEqualsAndGetHashCodeFromMembersOptions : object {
    public static PerLanguageOption2`1<bool> GenerateOperators;
    public static PerLanguageOption2`1<bool> ImplementIEquatable;
    private static GenerateEqualsAndGetHashCodeFromMembersOptions();
}
internal interface Microsoft.CodeAnalysis.GenerateEqualsAndGetHashCodeFromMembers.IGenerateEqualsAndGetHashCodeService {
    public abstract virtual Task`1<Document> FormatDocumentAsync(Document document, CancellationToken cancellationToken);
    public abstract virtual Task`1<IMethodSymbol> GenerateEqualsMethodAsync(Document document, INamedTypeSymbol namedType, ImmutableArray`1<ISymbol> members, string localNameOpt, CancellationToken cancellationToken);
    public abstract virtual Task`1<IMethodSymbol> GenerateEqualsMethodThroughIEquatableEqualsAsync(Document document, INamedTypeSymbol namedType, CancellationToken cancellationToken);
    public abstract virtual Task`1<IMethodSymbol> GenerateIEquatableEqualsMethodAsync(Document document, INamedTypeSymbol namedType, ImmutableArray`1<ISymbol> members, INamedTypeSymbol constructedEquatableType, CancellationToken cancellationToken);
    public abstract virtual Task`1<IMethodSymbol> GenerateGetHashCodeMethodAsync(Document document, INamedTypeSymbol namedType, ImmutableArray`1<ISymbol> members, CancellationToken cancellationToken);
}
[ExtensionAttribute]
internal static class Microsoft.CodeAnalysis.GenerateEqualsAndGetHashCodeFromMembers.IGenerateEqualsAndGetHashCodeServiceExtensions : object {
    [ExtensionAttribute]
public static Task`1<IMethodSymbol> GenerateEqualsMethodAsync(IGenerateEqualsAndGetHashCodeService service, Document document, INamedTypeSymbol namedType, ImmutableArray`1<ISymbol> members, CancellationToken cancellationToken);
}
internal abstract class Microsoft.CodeAnalysis.GenerateFromMembers.AbstractGenerateFromMembersCodeRefactoringProvider : CodeRefactoringProvider {
    protected static SymbolDisplayFormat SimpleFormat;
    private static AbstractGenerateFromMembersCodeRefactoringProvider();
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.GenerateFromMembers.AbstractGenerateFromMembersCodeRefactoringProvider/<GetSelectedMemberInfoAsync>d__1")]
protected static Task`1<SelectedMemberInfo> GetSelectedMemberInfoAsync(Document document, TextSpan textSpan, bool allowPartialSelection, CancellationToken cancellationToken);
    protected static bool IsReadableInstanceFieldOrProperty(ISymbol symbol);
    protected static bool IsWritableInstanceFieldOrProperty(ISymbol symbol);
    private static bool IsReadableFieldOrProperty(ISymbol symbol);
    private static bool IsWritableFieldOrProperty(ISymbol symbol);
    private static bool IsViableField(IFieldSymbol field);
    private static bool IsViableProperty(IPropertySymbol property);
    protected static ImmutableArray`1<IParameterSymbol> DetermineParameters(ImmutableArray`1<ISymbol> selectedMembers, ImmutableArray`1<NamingRule> rules);
}
internal abstract class Microsoft.CodeAnalysis.GenerateMember.AbstractGenerateMemberService`2 : object {
    protected static ISet`1<TypeKind> EnumType;
    protected static ISet`1<TypeKind> ClassInterfaceModuleStructTypes;
    private static AbstractGenerateMemberService`2();
    protected static bool ValidateTypeToGenerateIn(INamedTypeSymbol typeToGenerateIn, bool isStatic, ISet`1<TypeKind> typeKinds);
    protected static bool TryDetermineTypeToGenerateIn(SemanticDocument document, INamedTypeSymbol containingType, TExpressionSyntax simpleNameOrMemberAccessExpression, CancellationToken cancellationToken, INamedTypeSymbol& typeToGenerateIn, Boolean& isStatic);
    private static void TryDetermineTypeToGenerateInWorker(SemanticDocument semanticDocument, INamedTypeSymbol containingType, TExpressionSyntax expression, CancellationToken cancellationToken, INamedTypeSymbol& typeToGenerateIn, Boolean& isStatic);
    private static void DetermineTypeToGenerateInWorker(SemanticModel semanticModel, SyntaxNode expression, INamedTypeSymbol& typeToGenerateIn, Boolean& isStatic, CancellationToken cancellationToken);
}
internal abstract class Microsoft.CodeAnalysis.GenerateMember.GenerateConstructor.AbstractGenerateConstructorService`2 : object {
    protected abstract virtual bool ContainingTypesOrSelfHasUnsafeKeyword(INamedTypeSymbol containingType);
    protected abstract virtual bool IsSimpleNameGeneration(SemanticDocument document, SyntaxNode node, CancellationToken cancellationToken);
    protected abstract virtual bool IsConstructorInitializerGeneration(SemanticDocument document, SyntaxNode node, CancellationToken cancellationToken);
    protected abstract virtual bool IsImplicitObjectCreation(SemanticDocument document, SyntaxNode node, CancellationToken cancellationToken);
    protected abstract virtual bool TryInitializeImplicitObjectCreation(SemanticDocument document, SyntaxNode node, CancellationToken cancellationToken, SyntaxToken& token, ImmutableArray`1& arguments, INamedTypeSymbol& typeToGenerateIn);
    protected abstract virtual bool TryInitializeSimpleNameGenerationState(SemanticDocument document, SyntaxNode simpleName, CancellationToken cancellationToken, SyntaxToken& token, ImmutableArray`1& arguments, INamedTypeSymbol& typeToGenerateIn);
    protected abstract virtual bool TryInitializeConstructorInitializerGeneration(SemanticDocument document, SyntaxNode constructorInitializer, CancellationToken cancellationToken, SyntaxToken& token, ImmutableArray`1& arguments, INamedTypeSymbol& typeToGenerateIn);
    protected abstract virtual bool TryInitializeSimpleAttributeNameGenerationState(SemanticDocument document, SyntaxNode simpleName, CancellationToken cancellationToken, SyntaxToken& token, ImmutableArray`1& arguments, INamedTypeSymbol& typeToGenerateIn);
    protected abstract virtual ITypeSymbol GetArgumentType(SemanticModel semanticModel, Argument<TService, TExpressionSyntax> argument, CancellationToken cancellationToken);
    protected abstract virtual string GenerateNameForExpression(SemanticModel semanticModel, TExpressionSyntax expression, CancellationToken cancellationToken);
    protected abstract virtual bool IsConversionImplicit(Compilation compilation, ITypeSymbol sourceType, ITypeSymbol targetType);
    protected abstract virtual IMethodSymbol GetCurrentConstructor(SemanticModel semanticModel, SyntaxToken token, CancellationToken cancellationToken);
    protected abstract virtual IMethodSymbol GetDelegatedConstructor(SemanticModel semanticModel, IMethodSymbol constructor, CancellationToken cancellationToken);
    protected bool WillCauseConstructorCycle(State<TService, TExpressionSyntax> state, SemanticDocument document, IMethodSymbol delegatedConstructor, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.GenerateMember.GenerateConstructor.AbstractGenerateConstructorService`2/<GenerateConstructorAsync>d__14")]
public sealed virtual Task`1<ImmutableArray`1<CodeAction>> GenerateConstructorAsync(Document document, SyntaxNode node, CancellationToken cancellationToken);
    protected static bool IsSymbolAccessible(ISymbol symbol, SemanticDocument document);
    protected string GenerateNameForArgument(SemanticModel semanticModel, Argument<TService, TExpressionSyntax> argument, CancellationToken cancellationToken);
    private ImmutableArray`1<ParameterName> GenerateParameterNames(SemanticDocument document, IEnumerable`1<Argument<TService, TExpressionSyntax>> arguments, IList`1<string> reservedNames, NamingRule parameterNamingRule, CancellationToken cancellationToken);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal static class Microsoft.CodeAnalysis.GenerateMember.GenerateConstructor.GenerateConstructorHelpers : object {
    public static bool CanDelegateTo(SemanticDocument document, ImmutableArray`1<IParameterSymbol> parameters, ImmutableArray`1<TExpressionSyntax> expressions, IMethodSymbol constructor);
    private static bool IsSymbolAccessible(Compilation compilation, ISymbol symbol);
    private static bool IsCompatible(ISemanticFactsService semanticFacts, SemanticModel semanticModel, IMethodSymbol constructor, ImmutableArray`1<TExpressionSyntax> expressions);
}
internal interface Microsoft.CodeAnalysis.GenerateMember.GenerateConstructor.IGenerateConstructorService {
    public abstract virtual Task`1<ImmutableArray`1<CodeAction>> GenerateConstructorAsync(Document document, SyntaxNode node, CancellationToken cancellationToken);
}
internal abstract class Microsoft.CodeAnalysis.GenerateMember.GenerateDefaultConstructors.AbstractGenerateDefaultConstructorsService`1 : object {
    protected abstract virtual bool TryInitializeState(SemanticDocument document, TextSpan textSpan, CancellationToken cancellationToken, INamedTypeSymbol& classType);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.GenerateMember.GenerateDefaultConstructors.AbstractGenerateDefaultConstructorsService`1/<GenerateDefaultConstructorsAsync>d__5")]
public sealed virtual Task`1<ImmutableArray`1<CodeAction>> GenerateDefaultConstructorsAsync(Document document, TextSpan textSpan, CancellationToken cancellationToken);
}
internal interface Microsoft.CodeAnalysis.GenerateMember.GenerateDefaultConstructors.IGenerateDefaultConstructorsService {
    public abstract virtual Task`1<ImmutableArray`1<CodeAction>> GenerateDefaultConstructorsAsync(Document document, TextSpan textSpan, CancellationToken cancellationToken);
}
internal abstract class Microsoft.CodeAnalysis.GenerateMember.GenerateEnumMember.AbstractGenerateEnumMemberService`3 : AbstractGenerateMemberService`2<TSimpleNameSyntax, TExpressionSyntax> {
    protected abstract virtual bool IsIdentifierNameGeneration(SyntaxNode node);
    protected abstract virtual bool TryInitializeIdentifierNameState(SemanticDocument document, TSimpleNameSyntax identifierName, CancellationToken cancellationToken, SyntaxToken& identifierToken, TExpressionSyntax& simpleNameOrMemberAccessExpression);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.GenerateMember.GenerateEnumMember.AbstractGenerateEnumMemberService`3/<GenerateEnumMemberAsync>d__4")]
public sealed virtual Task`1<ImmutableArray`1<CodeAction>> GenerateEnumMemberAsync(Document document, SyntaxNode node, CancellationToken cancellationToken);
    private static ImmutableArray`1<CodeAction> GetActions(Document document, State<TService, TSimpleNameSyntax, TExpressionSyntax> state);
}
internal interface Microsoft.CodeAnalysis.GenerateMember.GenerateEnumMember.IGenerateEnumMemberService {
    public abstract virtual Task`1<ImmutableArray`1<CodeAction>> GenerateEnumMemberAsync(Document document, SyntaxNode node, CancellationToken cancellationToken);
}
internal abstract class Microsoft.CodeAnalysis.GenerateMember.GenerateParameterizedMember.AbstractGenerateConversionService`4 : AbstractGenerateParameterizedMemberService`4<TService, TSimpleNameSyntax, TExpressionSyntax, TInvocationExpressionSyntax> {
    protected abstract virtual bool IsImplicitConversionGeneration(SyntaxNode node);
    protected abstract virtual bool IsExplicitConversionGeneration(SyntaxNode node);
    protected abstract virtual bool TryInitializeImplicitConversionState(SemanticDocument document, SyntaxNode expression, ISet`1<TypeKind> classInterfaceModuleStructTypes, CancellationToken cancellationToken, SyntaxToken& identifierToken, IMethodSymbol& methodSymbol, INamedTypeSymbol& typeToGenerateIn);
    protected abstract virtual bool TryInitializeExplicitConversionState(SemanticDocument document, SyntaxNode expression, ISet`1<TypeKind> classInterfaceModuleStructTypes, CancellationToken cancellationToken, SyntaxToken& identifierToken, IMethodSymbol& methodSymbol, INamedTypeSymbol& typeToGenerateIn);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.GenerateMember.GenerateParameterizedMember.AbstractGenerateConversionService`4/<GenerateConversionAsync>d__4")]
public sealed virtual Task`1<ImmutableArray`1<CodeAction>> GenerateConversionAsync(Document document, SyntaxNode node, CancellationToken cancellationToken);
}
internal abstract class Microsoft.CodeAnalysis.GenerateMember.GenerateParameterizedMember.AbstractGenerateDeconstructMethodService`4 : AbstractGenerateParameterizedMemberService`4<TService, TSimpleNameSyntax, TExpressionSyntax, TInvocationExpressionSyntax> {
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.GenerateMember.GenerateParameterizedMember.AbstractGenerateDeconstructMethodService`4/<GenerateDeconstructMethodAsync>d__0")]
public sealed virtual Task`1<ImmutableArray`1<CodeAction>> GenerateDeconstructMethodAsync(Document document, SyntaxNode leftSide, INamedTypeSymbol typeToGenerateIn, CancellationToken cancellationToken);
}
internal abstract class Microsoft.CodeAnalysis.GenerateMember.GenerateParameterizedMember.AbstractGenerateMethodService`4 : AbstractGenerateParameterizedMemberService`4<TService, TSimpleNameSyntax, TExpressionSyntax, TInvocationExpressionSyntax> {
    protected abstract virtual bool IsSimpleNameGeneration(SyntaxNode node);
    protected abstract virtual bool IsExplicitInterfaceGeneration(SyntaxNode node);
    protected abstract virtual bool TryInitializeExplicitInterfaceState(SemanticDocument document, SyntaxNode node, CancellationToken cancellationToken, SyntaxToken& identifierToken, IMethodSymbol& methodSymbol, INamedTypeSymbol& typeToGenerateIn);
    protected abstract virtual bool TryInitializeSimpleNameState(SemanticDocument document, TSimpleNameSyntax simpleName, CancellationToken cancellationToken, SyntaxToken& identifierToken, TExpressionSyntax& simpleNameOrMemberAccessExpression, TInvocationExpressionSyntax& invocationExpressionOpt, Boolean& isInConditionalExpression);
    protected abstract virtual ITypeSymbol DetermineReturnTypeForSimpleNameOrMemberAccessExpression(ITypeInferenceService typeInferenceService, SemanticModel semanticModel, TExpressionSyntax expression, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.GenerateMember.GenerateParameterizedMember.AbstractGenerateMethodService`4/<GenerateMethodAsync>d__5")]
public sealed virtual Task`1<ImmutableArray`1<CodeAction>> GenerateMethodAsync(Document document, SyntaxNode node, CancellationToken cancellationToken);
}
internal abstract class Microsoft.CodeAnalysis.GenerateMember.GenerateParameterizedMember.AbstractGenerateParameterizedMemberService`4 : AbstractGenerateMemberService`2<TSimpleNameSyntax, TExpressionSyntax> {
    protected abstract virtual AbstractInvocationInfo<TService, TSimpleNameSyntax, TExpressionSyntax, TInvocationExpressionSyntax> CreateInvocationMethodInfo(SemanticDocument document, State<TService, TSimpleNameSyntax, TExpressionSyntax, TInvocationExpressionSyntax> abstractState);
    protected abstract virtual bool IsValidSymbol(ISymbol symbol, SemanticModel semanticModel);
    protected abstract virtual bool AreSpecialOptionsActive(SemanticModel semanticModel);
    protected virtual bool ContainingTypesOrSelfHasUnsafeKeyword(INamedTypeSymbol containingType);
    protected virtual string GetImplicitConversionDisplayText(State<TService, TSimpleNameSyntax, TExpressionSyntax, TInvocationExpressionSyntax> state);
    protected virtual string GetExplicitConversionDisplayText(State<TService, TSimpleNameSyntax, TExpressionSyntax, TInvocationExpressionSyntax> state);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.GenerateMember.GenerateParameterizedMember.AbstractGenerateParameterizedMemberService`4/<GetActionsAsync>d__9")]
protected ValueTask`1<ImmutableArray`1<CodeAction>> GetActionsAsync(Document document, State<TService, TSimpleNameSyntax, TExpressionSyntax, TInvocationExpressionSyntax> state, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.GenerateMember.GenerateParameterizedMember.AbstractGenerateParameterizedMemberService`4/<ReplaceTypeParametersBasedOnTypeConstraintsAsync>d__13")]
private static ValueTask`1<ITypeSymbol> ReplaceTypeParametersBasedOnTypeConstraintsAsync(Project project, ITypeSymbol type, Compilation compilation, ISet`1<string> availableTypeParameterNames, CancellationToken cancellationToken);
}
internal interface Microsoft.CodeAnalysis.GenerateMember.GenerateParameterizedMember.IGenerateConversionService {
    public abstract virtual Task`1<ImmutableArray`1<CodeAction>> GenerateConversionAsync(Document document, SyntaxNode node, CancellationToken cancellationToken);
}
internal interface Microsoft.CodeAnalysis.GenerateMember.GenerateParameterizedMember.IGenerateDeconstructMemberService {
    public abstract virtual Task`1<ImmutableArray`1<CodeAction>> GenerateDeconstructMethodAsync(Document document, SyntaxNode targetVariables, INamedTypeSymbol typeToGenerateIn, CancellationToken cancellationToken);
}
internal interface Microsoft.CodeAnalysis.GenerateMember.GenerateParameterizedMember.IGenerateParameterizedMemberService {
    public abstract virtual Task`1<ImmutableArray`1<CodeAction>> GenerateMethodAsync(Document document, SyntaxNode node, CancellationToken cancellationToken);
}
internal enum Microsoft.CodeAnalysis.GenerateMember.GenerateParameterizedMember.MethodGenerationKind : Enum {
    public int value__;
    public static MethodGenerationKind Member;
    public static MethodGenerationKind ImplicitConversion;
    public static MethodGenerationKind ExplicitConversion;
}
internal abstract class Microsoft.CodeAnalysis.GenerateMember.GenerateVariable.AbstractGenerateVariableService`3 : AbstractGenerateMemberService`2<TSimpleNameSyntax, TExpressionSyntax> {
    protected abstract virtual bool IsExplicitInterfaceGeneration(SyntaxNode node);
    protected abstract virtual bool IsIdentifierNameGeneration(SyntaxNode node);
    protected abstract virtual bool TryInitializeExplicitInterfaceState(SemanticDocument document, SyntaxNode node, CancellationToken cancellationToken, SyntaxToken& identifierToken, IPropertySymbol& propertySymbol, INamedTypeSymbol& typeToGenerateIn);
    protected abstract virtual bool TryInitializeIdentifierNameState(SemanticDocument document, TSimpleNameSyntax identifierName, CancellationToken cancellationToken, SyntaxToken& identifierToken, TExpressionSyntax& simpleNameOrMemberAccessExpression, Boolean& isInExecutableBlock, Boolean& isinConditionalAccessExpression);
    protected abstract virtual bool TryConvertToLocalDeclaration(ITypeSymbol type, SyntaxToken identifierToken, OptionSet options, SemanticModel semanticModel, CancellationToken cancellationToken, SyntaxNode& newRoot);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.GenerateMember.GenerateVariable.AbstractGenerateVariableService`3/<GenerateVariableAsync>d__7")]
public sealed virtual Task`1<ImmutableArray`1<CodeAction>> GenerateVariableAsync(Document document, SyntaxNode node, CancellationToken cancellationToken);
    protected virtual bool ContainingTypesOrSelfHasUnsafeKeyword(INamedTypeSymbol containingType);
    private static void AddPropertyCodeActions(ArrayBuilder`1<CodeAction> result, SemanticDocument document, State<TService, TSimpleNameSyntax, TExpressionSyntax> state);
    private static void GenerateWritableProperty(ArrayBuilder`1<CodeAction> result, SemanticDocument document, State<TService, TSimpleNameSyntax, TExpressionSyntax> state);
    private static void AddFieldCodeActions(ArrayBuilder`1<CodeAction> result, SemanticDocument document, State<TService, TSimpleNameSyntax, TExpressionSyntax> state);
    private static void GenerateWriteableField(ArrayBuilder`1<CodeAction> result, SemanticDocument document, State<TService, TSimpleNameSyntax, TExpressionSyntax> state);
    private void AddLocalCodeActions(ArrayBuilder`1<CodeAction> result, Document document, State<TService, TSimpleNameSyntax, TExpressionSyntax> state);
    private static void AddParameterCodeActions(ArrayBuilder`1<CodeAction> result, Document document, State<TService, TSimpleNameSyntax, TExpressionSyntax> state);
    private static RefKind GetRefKindFromContext(State<TService, TSimpleNameSyntax, TExpressionSyntax> state);
}
internal interface Microsoft.CodeAnalysis.GenerateMember.GenerateVariable.IGenerateVariableService {
    public abstract virtual Task`1<ImmutableArray`1<CodeAction>> GenerateVariableAsync(Document document, SyntaxNode node, CancellationToken cancellationToken);
}
[ExportCodeRefactoringProviderAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
[SharedAttribute]
[ExtensionOrderAttribute]
internal class Microsoft.CodeAnalysis.GenerateOverrides.GenerateOverridesCodeRefactoringProvider : CodeRefactoringProvider {
    private IPickMembersService _pickMembersService_forTestingPurposes;
    public GenerateOverridesCodeRefactoringProvider(IPickMembersService pickMembersService);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.GenerateOverrides.GenerateOverridesCodeRefactoringProvider/<ComputeRefactoringsAsync>d__3")]
public virtual Task ComputeRefactoringsAsync(CodeRefactoringContext context);
}
internal abstract class Microsoft.CodeAnalysis.GenerateType.AbstractGenerateTypeService`6 : object {
    protected string DefaultFileExtension { get; }
    protected abstract virtual bool TryInitializeState(SemanticDocument document, TSimpleNameSyntax simpleName, CancellationToken cancellationToken, GenerateTypeServiceStateOptions& generateTypeServiceStateOptions);
    protected abstract virtual TExpressionSyntax GetLeftSideOfDot(TSimpleNameSyntax simpleName);
    protected abstract virtual bool TryGetArgumentList(TObjectCreationExpressionSyntax objectCreationExpression, IList`1& argumentList);
    protected abstract virtual string get_DefaultFileExtension();
    protected abstract virtual ImmutableArray`1<ITypeParameterSymbol> GetTypeParameters(State<TService, TSimpleNameSyntax, TObjectCreationExpressionSyntax, TExpressionSyntax, TTypeDeclarationSyntax, TArgumentSyntax> state, SemanticModel semanticModel, CancellationToken cancellationToken);
    protected abstract virtual Accessibility GetAccessibility(State<TService, TSimpleNameSyntax, TObjectCreationExpressionSyntax, TExpressionSyntax, TTypeDeclarationSyntax, TArgumentSyntax> state, SemanticModel semanticModel, bool intoNamespace, CancellationToken cancellationToken);
    protected abstract virtual IList`1<ParameterName> GenerateParameterNames(SemanticModel semanticModel, IList`1<TArgumentSyntax> arguments, CancellationToken cancellationToken);
    protected abstract virtual INamedTypeSymbol DetermineTypeToGenerateIn(SemanticModel semanticModel, TSimpleNameSyntax simpleName, CancellationToken cancellationToken);
    protected abstract virtual ITypeSymbol DetermineArgumentType(SemanticModel semanticModel, TArgumentSyntax argument, CancellationToken cancellationToken);
    protected abstract virtual bool IsInCatchDeclaration(TExpressionSyntax expression);
    protected abstract virtual bool IsArrayElementType(TExpressionSyntax expression);
    protected abstract virtual bool IsInVariableTypeContext(TExpressionSyntax expression);
    protected abstract virtual bool IsInValueTypeConstraintContext(SemanticModel semanticModel, TExpressionSyntax expression, CancellationToken cancellationToken);
    protected abstract virtual bool IsInInterfaceList(TExpressionSyntax expression);
    internal abstract virtual bool TryGetBaseList(TExpressionSyntax expression, TypeKindOptions& returnValue);
    internal abstract virtual bool IsPublicOnlyAccessibility(TExpressionSyntax expression, Project project);
    internal abstract virtual bool IsGenericName(TSimpleNameSyntax simpleName);
    internal abstract virtual bool IsSimpleName(TExpressionSyntax expression);
    internal abstract virtual Task`1<Solution> TryAddUsingsOrImportToDocumentAsync(Solution updatedSolution, SyntaxNode modifiedRoot, Document document, TSimpleNameSyntax simpleName, string includeUsingsOrImports, CancellationToken cancellationToken);
    protected abstract virtual bool TryGetNameParts(TExpressionSyntax expression, IList`1& nameParts);
    public abstract virtual string GetRootNamespace(CompilationOptions options);
    public abstract virtual Task`1<ValueTuple`3<INamespaceSymbol, INamespaceOrTypeSymbol, Location>> GetOrGenerateEnclosingNamespaceSymbolAsync(INamedTypeSymbol namedTypeSymbol, String[] containers, Document selectedDocument, SyntaxNode selectedDocumentRoot, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.GenerateType.AbstractGenerateTypeService`6/<GenerateTypeAsync>d__26")]
public sealed virtual Task`1<ImmutableArray`1<CodeAction>> GenerateTypeAsync(Document document, SyntaxNode node, CancellationToken cancellationToken);
    private ImmutableArray`1<CodeAction> GetActions(SemanticDocument document, SyntaxNode node, State<TService, TSimpleNameSyntax, TObjectCreationExpressionSyntax, TExpressionSyntax, TTypeDeclarationSyntax, TArgumentSyntax> state, CancellationToken cancellationToken);
    private static bool CanGenerateIntoContainingNamespace(SemanticDocument semanticDocument, SyntaxNode node, CancellationToken cancellationToken);
    private static bool IsGeneratingIntoContainingNamespace(SemanticDocument document, SyntaxNode node, State<TService, TSimpleNameSyntax, TObjectCreationExpressionSyntax, TExpressionSyntax, TTypeDeclarationSyntax, TArgumentSyntax> state, CancellationToken cancellationToken);
    protected static string GetTypeName(State<TService, TSimpleNameSyntax, TObjectCreationExpressionSyntax, TExpressionSyntax, TTypeDeclarationSyntax, TArgumentSyntax> state);
    protected static ImmutableArray`1<ITypeParameterSymbol> GetTypeParameters(State<TService, TSimpleNameSyntax, TObjectCreationExpressionSyntax, TExpressionSyntax, TTypeDeclarationSyntax, TArgumentSyntax> state, SemanticModel semanticModel, IEnumerable`1<SyntaxNode> typeArguments, CancellationToken cancellationToken);
    protected static Accessibility DetermineDefaultAccessibility(State<TService, TSimpleNameSyntax, TObjectCreationExpressionSyntax, TExpressionSyntax, TTypeDeclarationSyntax, TArgumentSyntax> state, SemanticModel semanticModel, bool intoNamespace, CancellationToken cancellationToken);
    protected IList`1<ITypeParameterSymbol> GetAvailableTypeParameters(State<TService, TSimpleNameSyntax, TObjectCreationExpressionSyntax, TExpressionSyntax, TTypeDeclarationSyntax, TArgumentSyntax> state, SemanticModel semanticModel, bool intoNamespace, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.GenerateType.AbstractGenerateTypeService`6/<IsWithinTheImportingNamespaceAsync>d__34")]
protected static Task`1<bool> IsWithinTheImportingNamespaceAsync(Document document, int triggeringPosition, string includeUsingsOrImports, CancellationToken cancellationToken);
    protected static bool GeneratedTypesMustBePublic(Project project);
    protected abstract virtual bool IsConversionImplicit(Compilation compilation, ITypeSymbol sourceType, ITypeSymbol targetType);
    internal abstract virtual bool TryGenerateProperty(TSimpleNameSyntax propertyName, SemanticModel semanticModel, ITypeInferenceService typeInference, CancellationToken cancellationToken, IPropertySymbol& property);
}
internal class Microsoft.CodeAnalysis.GenerateType.GenerateTypeDialogOptions : object {
    [CompilerGeneratedAttribute]
private bool <IsPublicOnlyAccessibility>k__BackingField;
    [CompilerGeneratedAttribute]
private TypeKindOptions <TypeKindOptions>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsAttribute>k__BackingField;
    public bool IsPublicOnlyAccessibility { get; }
    public TypeKindOptions TypeKindOptions { get; }
    public bool IsAttribute { get; }
    public GenerateTypeDialogOptions(bool isPublicOnlyAccessibility, TypeKindOptions typeKindOptions, bool isAttribute);
    [CompilerGeneratedAttribute]
public bool get_IsPublicOnlyAccessibility();
    [CompilerGeneratedAttribute]
public TypeKindOptions get_TypeKindOptions();
    [CompilerGeneratedAttribute]
public bool get_IsAttribute();
}
internal class Microsoft.CodeAnalysis.GenerateType.GenerateTypeOptionsResult : object {
    public static GenerateTypeOptionsResult Cancelled;
    [CompilerGeneratedAttribute]
private Accessibility <Accessibility>k__BackingField;
    [CompilerGeneratedAttribute]
private Document <ExistingDocument>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsCancelled>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsNewFile>k__BackingField;
    [CompilerGeneratedAttribute]
private IList`1<string> <Folders>k__BackingField;
    [CompilerGeneratedAttribute]
private string <NewFileName>k__BackingField;
    [CompilerGeneratedAttribute]
private Project <Project>k__BackingField;
    [CompilerGeneratedAttribute]
private TypeKind <TypeKind>k__BackingField;
    [CompilerGeneratedAttribute]
private string <FullFilePath>k__BackingField;
    [CompilerGeneratedAttribute]
private string <TypeName>k__BackingField;
    [CompilerGeneratedAttribute]
private string <DefaultNamespace>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <AreFoldersValidIdentifiers>k__BackingField;
    public Accessibility Accessibility { get; }
    public Document ExistingDocument { get; }
    public bool IsCancelled { get; }
    public bool IsNewFile { get; }
    public IList`1<string> Folders { get; }
    public string NewFileName { get; }
    public Project Project { get; }
    public TypeKind TypeKind { get; }
    public string FullFilePath { get; }
    public string TypeName { get; }
    public string DefaultNamespace { get; }
    public bool AreFoldersValidIdentifiers { get; }
    public GenerateTypeOptionsResult(Accessibility accessibility, TypeKind typeKind, string typeName, Project project, bool isNewFile, string newFileName, IList`1<string> folders, string fullFilePath, Document existingDocument, bool areFoldersValidIdentifiers, string defaultNamespace, bool isCancelled);
    private GenerateTypeOptionsResult(bool isCancelled);
    private static GenerateTypeOptionsResult();
    [CompilerGeneratedAttribute]
public Accessibility get_Accessibility();
    [CompilerGeneratedAttribute]
public Document get_ExistingDocument();
    [CompilerGeneratedAttribute]
public bool get_IsCancelled();
    [CompilerGeneratedAttribute]
public bool get_IsNewFile();
    [CompilerGeneratedAttribute]
public IList`1<string> get_Folders();
    [CompilerGeneratedAttribute]
public string get_NewFileName();
    [CompilerGeneratedAttribute]
public Project get_Project();
    [CompilerGeneratedAttribute]
public TypeKind get_TypeKind();
    [CompilerGeneratedAttribute]
public string get_FullFilePath();
    [CompilerGeneratedAttribute]
public string get_TypeName();
    [CompilerGeneratedAttribute]
public string get_DefaultNamespace();
    [CompilerGeneratedAttribute]
public bool get_AreFoldersValidIdentifiers();
}
internal interface Microsoft.CodeAnalysis.GenerateType.IGenerateTypeOptionsService {
    public abstract virtual GenerateTypeOptionsResult GetGenerateTypeOptions(string className, GenerateTypeDialogOptions generateTypeDialogOptions, Document document, INotificationService notificationService, IProjectManagementService projectManagementService, ISyntaxFactsService syntaxFactsService);
}
internal interface Microsoft.CodeAnalysis.GenerateType.IGenerateTypeService {
    public abstract virtual Task`1<ImmutableArray`1<CodeAction>> GenerateTypeAsync(Document document, SyntaxNode node, CancellationToken cancellationToken);
    public abstract virtual Task`1<ValueTuple`3<INamespaceSymbol, INamespaceOrTypeSymbol, Location>> GetOrGenerateEnclosingNamespaceSymbolAsync(INamedTypeSymbol namedTypeSymbol, String[] containers, Document selectedDocument, SyntaxNode selectedDocumentRoot, CancellationToken cancellationToken);
    public abstract virtual string GetRootNamespace(CompilationOptions options);
}
[FlagsAttribute]
internal enum Microsoft.CodeAnalysis.GenerateType.TypeKindOptions : Enum {
    public int value__;
    public static TypeKindOptions None;
    public static TypeKindOptions Class;
    public static TypeKindOptions Structure;
    public static TypeKindOptions Interface;
    public static TypeKindOptions Enum;
    public static TypeKindOptions Delegate;
    public static TypeKindOptions Module;
    public static TypeKindOptions AllOptions;
    public static TypeKindOptions Attribute;
    public static TypeKindOptions BaseList;
    public static TypeKindOptions AllOptionsWithModule;
    public static TypeKindOptions MemberAccessWithNamespace;
    public static TypeKindOptions GenericInCompatibleTypes;
}
internal class Microsoft.CodeAnalysis.GenerateType.TypeKindOptionsHelper : object {
    public static bool IsClass(TypeKindOptions option);
    public static bool IsStructure(TypeKindOptions option);
    public static bool IsInterface(TypeKindOptions option);
    public static bool IsEnum(TypeKindOptions option);
    public static bool IsDelegate(TypeKindOptions option);
    public static bool IsModule(TypeKindOptions option);
    public static TypeKindOptions RemoveOptions(TypeKindOptions fromValue, TypeKindOptions[] removeValues);
    internal static TypeKindOptions AddOption(TypeKindOptions toValue, TypeKindOptions addValue);
}
internal enum Microsoft.CodeAnalysis.Glyph : Enum {
    public int value__;
    public static Glyph None;
    public static Glyph Assembly;
    public static Glyph BasicFile;
    public static Glyph BasicProject;
    public static Glyph ClassPublic;
    public static Glyph ClassProtected;
    public static Glyph ClassPrivate;
    public static Glyph ClassInternal;
    public static Glyph CSharpFile;
    public static Glyph CSharpProject;
    public static Glyph ConstantPublic;
    public static Glyph ConstantProtected;
    public static Glyph ConstantPrivate;
    public static Glyph ConstantInternal;
    public static Glyph DelegatePublic;
    public static Glyph DelegateProtected;
    public static Glyph DelegatePrivate;
    public static Glyph DelegateInternal;
    public static Glyph EnumPublic;
    public static Glyph EnumProtected;
    public static Glyph EnumPrivate;
    public static Glyph EnumInternal;
    public static Glyph EnumMemberPublic;
    public static Glyph EnumMemberProtected;
    public static Glyph EnumMemberPrivate;
    public static Glyph EnumMemberInternal;
    public static Glyph Error;
    public static Glyph StatusInformation;
    public static Glyph EventPublic;
    public static Glyph EventProtected;
    public static Glyph EventPrivate;
    public static Glyph EventInternal;
    public static Glyph ExtensionMethodPublic;
    public static Glyph ExtensionMethodProtected;
    public static Glyph ExtensionMethodPrivate;
    public static Glyph ExtensionMethodInternal;
    public static Glyph FieldPublic;
    public static Glyph FieldProtected;
    public static Glyph FieldPrivate;
    public static Glyph FieldInternal;
    public static Glyph InterfacePublic;
    public static Glyph InterfaceProtected;
    public static Glyph InterfacePrivate;
    public static Glyph InterfaceInternal;
    public static Glyph Intrinsic;
    public static Glyph Keyword;
    public static Glyph Label;
    public static Glyph Local;
    public static Glyph Namespace;
    public static Glyph MethodPublic;
    public static Glyph MethodProtected;
    public static Glyph MethodPrivate;
    public static Glyph MethodInternal;
    public static Glyph ModulePublic;
    public static Glyph ModuleProtected;
    public static Glyph ModulePrivate;
    public static Glyph ModuleInternal;
    public static Glyph OpenFolder;
    public static Glyph Operator;
    public static Glyph Parameter;
    public static Glyph PropertyPublic;
    public static Glyph PropertyProtected;
    public static Glyph PropertyPrivate;
    public static Glyph PropertyInternal;
    public static Glyph RangeVariable;
    public static Glyph Reference;
    public static Glyph StructurePublic;
    public static Glyph StructureProtected;
    public static Glyph StructurePrivate;
    public static Glyph StructureInternal;
    public static Glyph TypeParameter;
    public static Glyph Snippet;
    public static Glyph CompletionWarning;
    public static Glyph AddReference;
    public static Glyph NuGet;
    public static Glyph TargetTypeMatch;
}
[ExtensionAttribute]
internal static class Microsoft.CodeAnalysis.GlyphExtensions : object {
    [ExtensionAttribute]
public static ImmutableArray`1<Glyph> GetGlyphs(ImmutableArray`1<string> tags);
    [ExtensionAttribute]
public static Glyph GetFirstGlyph(ImmutableArray`1<string> tags);
    private static Glyph GetGlyph(string tag, ImmutableArray`1<string> allTags);
    private static Accessibility GetAccessibility(ImmutableArray`1<string> tags);
}
internal static class Microsoft.CodeAnalysis.GlyphTags : object {
    public static ImmutableArray`1<string> GetTags(Glyph glyph);
}
internal class Microsoft.CodeAnalysis.GoToDefinition.AbstractFindDefinitionService : object {
    [NullableContextAttribute("1")]
[AsyncStateMachineAttribute("Microsoft.CodeAnalysis.GoToDefinition.AbstractFindDefinitionService/<FindDefinitionsAsync>d__0")]
public sealed virtual Task`1<ImmutableArray`1<INavigableItem>> FindDefinitionsAsync(Document document, int position, CancellationToken cancellationToken);
}
internal abstract class Microsoft.CodeAnalysis.GoToDefinition.AbstractGoToDefinitionSymbolService : object {
    [NullableContextAttribute("1")]
protected abstract virtual ISymbol FindRelatedExplicitlyDeclaredSymbol(ISymbol symbol, Compilation compilation);
    [NullableContextAttribute("1")]
[AsyncStateMachineAttribute("Microsoft.CodeAnalysis.GoToDefinition.AbstractGoToDefinitionSymbolService/<GetSymbolAndBoundSpanAsync>d__1")]
public sealed virtual Task`1<ValueTuple`2<ISymbol, TextSpan>> GetSymbolAndBoundSpanAsync(Document document, int position, bool includeType, CancellationToken cancellationToken);
    [NullableContextAttribute("2")]
private static ISymbol GetSymbol(TokenSemanticInfo semanticInfo, bool includeType);
}
internal interface Microsoft.CodeAnalysis.GoToDefinition.IFindDefinitionService {
    [NullableContextAttribute("1")]
public abstract virtual Task`1<ImmutableArray`1<INavigableItem>> FindDefinitionsAsync(Document document, int position, CancellationToken cancellationToken);
}
internal interface Microsoft.CodeAnalysis.GoToDefinition.IGoToDefinitionSymbolService {
    [NullableContextAttribute("1")]
public abstract virtual Task`1<ValueTuple`2<ISymbol, TextSpan>> GetSymbolAndBoundSpanAsync(Document document, int position, bool includeType, CancellationToken cancellationToken);
}
internal class Microsoft.CodeAnalysis.Host.BackgroundCompiler : object {
    private Workspace _workspace;
    private TaskQueue _taskQueue;
    private Compilation[] _mostRecentCompilations;
    private object _buildGate;
    private CancellationTokenSource _cancellationSource;
    public BackgroundCompiler(Workspace workspace);
    public sealed virtual void Dispose();
    private void OnDocumentOpened(object sender, DocumentEventArgs args);
    private void OnDocumentClosed(object sender, DocumentEventArgs args);
    private void OnWorkspaceChanged(object sender, WorkspaceChangeEventArgs args);
    private void Rebuild(Solution solution, ProjectId initialProject);
    private void CancelBuild(bool releasePreviousCompilations);
    private Task BuildCompilationsAsync(Solution solution, ProjectId initialProject, ISet`1<ProjectId> allProjects);
    private Task BuildCompilationsAsync(Solution solution, ProjectId initialProject, ISet`1<ProjectId> projectsToBuild, CancellationToken cancellationToken);
}
internal class Microsoft.CodeAnalysis.Host.BackgroundParser : object {
    private Workspace _workspace;
    private TaskQueue _taskQueue;
    private IDocumentTrackingService _documentTrackingService;
    private ReaderWriterLockSlim _stateLock;
    private object _parseGate;
    private ImmutableDictionary`2<DocumentId, CancellationTokenSource> _workMap;
    [CompilerGeneratedAttribute]
private bool <IsStarted>k__BackingField;
    public bool IsStarted { get; private set; }
    public BackgroundParser(Workspace workspace);
    [CompilerGeneratedAttribute]
public bool get_IsStarted();
    [CompilerGeneratedAttribute]
private void set_IsStarted(bool value);
    private void OnDocumentOpened(object sender, DocumentEventArgs args);
    private void OnDocumentClosed(object sender, DocumentEventArgs args);
    private void OnWorkspaceChanged(object sender, WorkspaceChangeEventArgs args);
    public void Start();
    public void Stop();
    public void CancelAllParses();
    private void CancelAllParses_NoLock();
    public void CancelParse(DocumentId documentId);
    public void Parse(Document document);
    private void ParseIfOpen(Document document);
    private Task ParseDocumentAsync(Document document);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.CodeAnalysis.Host.ProjectCacheService : object {
    internal static int ImplicitCacheSize;
    private object _gate;
    private Workspace _workspace;
    private Dictionary`2<ProjectId, Cache> _activeCaches;
    [NullableAttribute("2")]
private SimpleMRUCache _implicitCache;
    [NullableAttribute("2")]
private ImplicitCacheMonitor _implicitCacheMonitor;
    public bool IsImplicitCacheEmpty { get; }
    public ProjectCacheService(Workspace workspace);
    public ProjectCacheService(Workspace workspace, int implicitCacheTimeout);
    public bool get_IsImplicitCacheEmpty();
    public void ClearImplicitCache();
    public void ClearExpiredImplicitCache(DateTime expirationTime);
    public sealed virtual IDisposable EnableCaching(ProjectId key);
    public sealed virtual T CacheObjectIfCachingEnabledForKey(ProjectId key, object owner, T instance);
    private bool PartOfP2PReferences(ProjectId key);
    public sealed virtual T CacheObjectIfCachingEnabledForKey(ProjectId key, ICachedObjectOwner owner, T instance);
    private void DisableCaching(ProjectId key, Cache cache);
}
[NullableContextAttribute("1")]
internal interface Microsoft.CodeAnalysis.IDocumentTrackingService {
    [NullableContextAttribute("2")]
public abstract virtual DocumentId TryGetActiveDocument();
    public abstract virtual ImmutableArray`1<DocumentId> GetVisibleDocuments();
    [CompilerGeneratedAttribute]
public abstract virtual void add_ActiveDocumentChanged(EventHandler`1<DocumentId> value);
    [CompilerGeneratedAttribute]
public abstract virtual void remove_ActiveDocumentChanged(EventHandler`1<DocumentId> value);
    [CompilerGeneratedAttribute]
public abstract virtual void add_NonRoslynBufferTextChanged(EventHandler`1<EventArgs> value);
    [CompilerGeneratedAttribute]
public abstract virtual void remove_NonRoslynBufferTextChanged(EventHandler`1<EventArgs> value);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
internal static class Microsoft.CodeAnalysis.IDocumentTrackingServiceExtensions : object {
    [ExtensionAttribute]
public static Document GetActiveDocument(IDocumentTrackingService service, Solution solution);
    [ExtensionAttribute]
public static ImmutableArray`1<Document> GetVisibleDocuments(IDocumentTrackingService service, Solution solution);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal abstract class Microsoft.CodeAnalysis.ImplementAbstractClass.AbstractImplementAbstractClassCodeFixProvider`1 : CodeFixProvider {
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private ImmutableArray`1<string> <FixableDiagnosticIds>k__BackingField;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ImmutableArray`1<string> FixableDiagnosticIds { get; }
    protected AbstractImplementAbstractClassCodeFixProvider`1(string diagnosticId);
    [CompilerGeneratedAttribute]
public sealed virtual ImmutableArray`1<string> get_FixableDiagnosticIds();
    public sealed virtual FixAllProvider GetFixAllProvider();
    protected abstract virtual SyntaxToken GetClassIdentifier(TClassNode classNode);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.ImplementAbstractClass.AbstractImplementAbstractClassCodeFixProvider`1/<RegisterCodeFixesAsync>d__6")]
public sealed virtual Task RegisterCodeFixesAsync(CodeFixContext context);
    private static string GetCodeActionId(string assemblyName, string abstractTypeFullyQualifiedName, string through);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.CodeAnalysis.ImplementAbstractClass.ImplementAbstractClassData : object {
    private Document _document;
    private SyntaxNode _classNode;
    private SyntaxToken _classIdentifier;
    [TupleElementNamesAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private ImmutableArray`1<ValueTuple`2<INamedTypeSymbol, ImmutableArray`1<ISymbol>>> _unimplementedMembers;
    public INamedTypeSymbol ClassType;
    public INamedTypeSymbol AbstractClassType;
    public ImplementAbstractClassData(Document document, SyntaxNode classNode, SyntaxToken classIdentifier, INamedTypeSymbol classType, INamedTypeSymbol abstractClassType, ImmutableArray`1<ValueTuple`2<INamedTypeSymbol, ImmutableArray`1<ISymbol>>> unimplementedMembers);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.ImplementAbstractClass.ImplementAbstractClassData/<TryGetDataAsync>d__7")]
public static Task`1<ImplementAbstractClassData> TryGetDataAsync(Document document, SyntaxNode classNode, SyntaxToken classIdentifier, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.ImplementAbstractClass.ImplementAbstractClassData/<TryImplementAbstractClassAsync>d__8")]
public static Task`1<Document> TryImplementAbstractClassAsync(Document document, SyntaxNode classNode, SyntaxToken classIdentifier, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.ImplementAbstractClass.ImplementAbstractClassData/<ImplementAbstractClassAsync>d__9")]
public Task`1<Document> ImplementAbstractClassAsync(ISymbol throughMember, Nullable`1<bool> canDelegateAllMembers, CancellationToken cancellationToken);
    private ImmutableArray`1<ISymbol> GenerateMembers(Compilation compilation, ISymbol throughMember, ImplementTypePropertyGenerationBehavior propertyGenerationBehavior, CancellationToken cancellationToken);
    private ISymbol GenerateMember(Compilation compilation, ISymbol member, ISymbol throughMember, ImplementTypePropertyGenerationBehavior propertyGenerationBehavior, CancellationToken cancellationToken);
    private ISymbol GenerateMember(Compilation compilation, ISymbol member, ISymbol throughMember, bool addUnsafe, ImplementTypePropertyGenerationBehavior propertyGenerationBehavior);
    private ISymbol GenerateMethod(Compilation compilation, IMethodSymbol method, ISymbol throughMember, DeclarationModifiers modifiers, Accessibility accessibility);
    private IPropertySymbol GenerateProperty(Compilation compilation, IPropertySymbol property, ISymbol throughMember, DeclarationModifiers modifiers, Accessibility accessibility, ImplementTypePropertyGenerationBehavior propertyGenerationBehavior);
    private IEventSymbol GenerateEvent(IEventSymbol event, ISymbol throughMember, Accessibility accessibility, DeclarationModifiers modifiers);
    [NullableContextAttribute("2")]
private IMethodSymbol GetEventAddOrRemoveMethod(IEventSymbol event, IMethodSymbol accessor, ISymbol throughMember, Func`3<SyntaxNode, SyntaxNode, SyntaxNode> createAddOrRemoveHandler);
    [NullableContextAttribute("2")]
private bool ShouldGenerateAccessor(IMethodSymbol method);
    [IteratorStateMachineAttribute("Microsoft.CodeAnalysis.ImplementAbstractClass.ImplementAbstractClassData/<GetDelegatableMembers>d__18")]
public IEnumerable`1<ValueTuple`2<ISymbol, bool>> GetDelegatableMembers();
    private static bool InheritsFromOrEquals(ITypeSymbol type, ITypeSymbol baseType);
    [IteratorStateMachineAttribute("Microsoft.CodeAnalysis.ImplementAbstractClass.ImplementAbstractClassData/<GetBaseTypesAndThis>d__20")]
private static IEnumerable`1<ITypeSymbol> GetBaseTypesAndThis(ITypeSymbol type);
    [NullableContextAttribute("0")]
[CompilerGeneratedAttribute]
private bool <GetDelegatableMembers>b__18_1(IFieldSymbol f);
    [NullableContextAttribute("0")]
[CompilerGeneratedAttribute]
private bool <GetDelegatableMembers>b__18_3(IPropertySymbol p);
}
internal abstract class Microsoft.CodeAnalysis.ImplementInterface.AbstractImplementInterfaceService : object {
    protected static string DisposingName;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private static ImmutableArray`1<string> s_disposedValueNameParts;
    [NullableAttribute("1")]
private static SymbolDisplayFormat s_format;
    protected bool CanImplementImplicitly { get; }
    protected bool HasHiddenExplicitImplementation { get; }
    private static AbstractImplementInterfaceService();
    protected abstract virtual string ToDisplayString(IMethodSymbol disposeImplMethod, SymbolDisplayFormat format);
    protected abstract virtual bool get_CanImplementImplicitly();
    protected abstract virtual bool get_HasHiddenExplicitImplementation();
    protected abstract virtual bool TryInitializeState(Document document, SemanticModel model, SyntaxNode interfaceNode, CancellationToken cancellationToken, SyntaxNode& classOrStructDecl, INamedTypeSymbol& classOrStructType, IEnumerable`1& interfaceTypes);
    protected abstract virtual SyntaxNode AddCommentInsideIfStatement(SyntaxNode ifDisposingStatement, SyntaxTriviaList trivia);
    protected abstract virtual SyntaxNode CreateFinalizer(SyntaxGenerator generator, INamedTypeSymbol classType, string disposeMethodDisplayString);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.ImplementInterface.AbstractImplementInterfaceService/<ImplementInterfaceAsync>d__11")]
public sealed virtual Task`1<Document> ImplementInterfaceAsync(Document document, SyntaxNode node, CancellationToken cancellationToken);
    public sealed virtual ImmutableArray`1<CodeAction> GetCodeActions(Document document, SemanticModel model, SyntaxNode node, CancellationToken cancellationToken);
    [IteratorStateMachineAttribute("Microsoft.CodeAnalysis.ImplementInterface.AbstractImplementInterfaceService/<GetActions>d__13")]
private IEnumerable`1<CodeAction> GetActions(Document document, State state);
    private static bool AnyImplementedImplicitly(State state);
    private static IList`1<ISymbol> GetDelegatableMembers(State state);
    protected static TNode AddComment(SyntaxGenerator g, string comment, TNode node);
    protected static TNode AddComments(SyntaxGenerator g, string comment1, string comment2, TNode node);
    protected static TNode AddComments(SyntaxGenerator g, String[] comments, TNode node);
    protected static SyntaxTriviaList CreateCommentTrivia(SyntaxGenerator generator, String[] comments);
    [NullableContextAttribute("1")]
private static IMethodSymbol TryGetIDisposableDispose(Compilation compilation);
    [NullableContextAttribute("1")]
private static bool ShouldImplementDisposePattern(State state, bool explicitly);
}
internal interface Microsoft.CodeAnalysis.ImplementInterface.IImplementInterfaceService {
    public abstract virtual Task`1<Document> ImplementInterfaceAsync(Document document, SyntaxNode node, CancellationToken cancellationToken);
    public abstract virtual ImmutableArray`1<CodeAction> GetCodeActions(Document document, SemanticModel model, SyntaxNode node, CancellationToken cancellationToken);
}
internal enum Microsoft.CodeAnalysis.ImplementType.ImplementTypeInsertionBehavior : Enum {
    public int value__;
    public static ImplementTypeInsertionBehavior WithOtherMembersOfTheSameKind;
    public static ImplementTypeInsertionBehavior AtTheEnd;
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal static class Microsoft.CodeAnalysis.ImplementType.ImplementTypeOptions : object {
    public static PerLanguageOption2`1<ImplementTypeInsertionBehavior> InsertionBehavior;
    public static PerLanguageOption2`1<ImplementTypePropertyGenerationBehavior> PropertyGenerationBehavior;
    private static ImplementTypeOptions();
}
[ExportOptionProviderAttribute]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.ImplementType.ImplementTypeOptionsProvider : object {
    [CompilerGeneratedAttribute]
private ImmutableArray`1<IOption> <Options>k__BackingField;
    public ImmutableArray`1<IOption> Options { get; }
    [CompilerGeneratedAttribute]
public sealed virtual ImmutableArray`1<IOption> get_Options();
}
internal enum Microsoft.CodeAnalysis.ImplementType.ImplementTypePropertyGenerationBehavior : Enum {
    public int value__;
    public static ImplementTypePropertyGenerationBehavior PreferThrowingProperties;
    public static ImplementTypePropertyGenerationBehavior PreferAutoProperties;
}
[SharedAttribute]
[ExportIncrementalAnalyzerProviderAttribute("SymbolTreeInfoIncrementalAnalyzerProvider", "Mono.Cecil.CustomAttributeArgument[]")]
[ExportWorkspaceServiceFactoryAttribute("Microsoft.CodeAnalysis.FindSymbols.SymbolTree.ISymbolTreeInfoCacheService", "Default")]
internal class Microsoft.CodeAnalysis.IncrementalCaches.SymbolTreeInfoIncrementalAnalyzerProvider : object {
    private ConcurrentDictionary`2<ProjectId, SymbolTreeInfo> _projectIdToInfo;
    private ConcurrentDictionary`2<MetadataId, MetadataInfo> _metadataIdToInfo;
    public sealed virtual IIncrementalAnalyzer CreateIncrementalAnalyzer(Workspace workspace);
    public sealed virtual IWorkspaceService CreateService(HostWorkspaceServices workspaceServices);
}
[ExportIncrementalAnalyzerProviderAttribute("SyntaxTreeInfoIncrementalAnalyzerProvider", "Mono.Cecil.CustomAttributeArgument[]")]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.IncrementalCaches.SyntaxTreeInfoIncrementalAnalyzerProvider : object {
    public sealed virtual IIncrementalAnalyzer CreateIncrementalAnalyzer(Workspace workspace);
}
internal abstract class Microsoft.CodeAnalysis.InitializeParameter.AbstractAddParameterCheckCodeRefactoringProvider`5 : AbstractInitializeParameterCodeRefactoringProvider`4<TTypeDeclarationSyntax, TParameterSyntax, TStatementSyntax, TExpressionSyntax> {
    private Func`2<SyntaxNode, bool> _isFunctionDeclarationFunc;
    protected abstract virtual bool CanOffer(SyntaxNode body);
    protected abstract virtual bool PrefersThrowExpression(DocumentOptionSet options);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.InitializeParameter.AbstractAddParameterCheckCodeRefactoringProvider`5/<GetRefactoringsForAllParametersAsync>d__4")]
protected virtual Task`1<ImmutableArray`1<CodeAction>> GetRefactoringsForAllParametersAsync(Document document, SyntaxNode functionDeclaration, IMethodSymbol methodSymbol, IBlockOperation blockStatementOpt, ImmutableArray`1<SyntaxNode> listOfParameterNodes, TextSpan parameterSpan, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.InitializeParameter.AbstractAddParameterCheckCodeRefactoringProvider`5/<GetRefactoringsForSingleParameterAsync>d__5")]
protected virtual Task`1<ImmutableArray`1<CodeAction>> GetRefactoringsForSingleParameterAsync(Document document, IParameterSymbol parameter, SyntaxNode functionDeclaration, IMethodSymbol methodSymbol, IBlockOperation blockStatementOpt, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.InitializeParameter.AbstractAddParameterCheckCodeRefactoringProvider`5/<UpdateDocumentForRefactoringAsync>d__6")]
private Task`1<Document> UpdateDocumentForRefactoringAsync(Document document, IBlockOperation blockStatementOpt, List`1<int> listOfParametersOrdinals, TextSpan parameterSpan, CancellationToken cancellationToken);
    private static IParameterSymbol GetParameterAtOrdinal(int index, IReadOnlyList`1<SyntaxNode> parameterNodes, SemanticModel semanticModel, CancellationToken cancellationToken);
    private static bool ContainsNullCoalesceCheck(ISyntaxFactsService syntaxFacts, SemanticModel semanticModel, IOperation statement, IParameterSymbol parameter, CancellationToken cancellationToken);
    private static bool IsIfNullCheck(IOperation statement, IParameterSymbol parameter);
    protected bool ParameterValidForNullCheck(Document document, IParameterSymbol parameter, SemanticModel semanticModel, IBlockOperation blockStatementOpt, CancellationToken cancellationToken);
    private static bool IsStringCheck(IOperation condition, IParameterSymbol parameter);
    private static bool IsNullCheck(IOperation operand1, IOperation operand2, IParameterSymbol parameter);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.InitializeParameter.AbstractAddParameterCheckCodeRefactoringProvider`5/<AddNullCheckAsync>d__13")]
private Task`1<Document> AddNullCheckAsync(Document document, IParameterSymbol parameter, SyntaxNode functionDeclaration, IMethodSymbol method, IBlockOperation blockStatementOpt, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.InitializeParameter.AbstractAddParameterCheckCodeRefactoringProvider`5/<AddStringCheckAsync>d__14")]
private Task`1<Document> AddStringCheckAsync(Document document, IParameterSymbol parameter, SyntaxNode functionDeclaration, IMethodSymbol method, IBlockOperation blockStatementOpt, string methodName, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.InitializeParameter.AbstractAddParameterCheckCodeRefactoringProvider`5/<AddNullCheckStatementAsync>d__15")]
private Task`1<Document> AddNullCheckStatementAsync(Document document, IParameterSymbol parameter, SyntaxNode functionDeclaration, IMethodSymbol method, IBlockOperation blockStatementOpt, Func`3<SemanticModel, SyntaxGenerator, TStatementSyntax> generateNullCheck, CancellationToken cancellationToken);
    private static TStatementSyntax CreateNullCheckStatement(SemanticModel semanticModel, SyntaxGenerator generator, IParameterSymbol parameter);
    private static TStatementSyntax CreateStringCheckStatement(Compilation compilation, SyntaxGenerator generator, IParameterSymbol parameter, string methodName);
    private static SyntaxNode GetStatementToAddNullCheckAfter(SemanticModel semanticModel, IParameterSymbol parameter, IBlockOperation blockStatementOpt, CancellationToken cancellationToken);
    private static IOperation TryFindParameterCheckStatement(SemanticModel semanticModel, IParameterSymbol parameterSymbol, IBlockOperation blockStatementOpt, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.InitializeParameter.AbstractAddParameterCheckCodeRefactoringProvider`5/<TryAddNullCheckToAssignmentAsync>d__20")]
private Task`1<Document> TryAddNullCheckToAssignmentAsync(Document document, IParameterSymbol parameter, IBlockOperation blockStatementOpt, CancellationToken cancellationToken);
    private static SyntaxNode GetTypeNode(Compilation compilation, SyntaxGenerator generator, Type type);
    private static SyntaxNode CreateArgumentNullException(Compilation compilation, SyntaxGenerator generator, IParameterSymbol parameter);
    private static SyntaxNode CreateArgumentException(Compilation compilation, SyntaxGenerator generator, IParameterSymbol parameter, string methodName);
    private static SyntaxNode InterpolatedStringText(SyntaxGenerator generator, string text);
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal abstract class Microsoft.CodeAnalysis.InitializeParameter.AbstractInitializeMemberFromParameterCodeRefactoringProvider`4 : AbstractInitializeParameterCodeRefactoringProvider`4<TTypeDeclarationSyntax, TParameterSyntax, TStatementSyntax, TExpressionSyntax> {
    protected abstract virtual SyntaxNode TryGetLastStatement(IBlockOperation blockStatementOpt);
    protected abstract virtual Accessibility DetermineDefaultFieldAccessibility(INamedTypeSymbol containingType);
    protected abstract virtual Accessibility DetermineDefaultPropertyAccessibility();
    protected virtual Task`1<ImmutableArray`1<CodeAction>> GetRefactoringsForAllParametersAsync(Document document, SyntaxNode functionDeclaration, IMethodSymbol method, IBlockOperation blockStatementOpt, ImmutableArray`1<SyntaxNode> listOfParameterNodes, TextSpan parameterSpan, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.InitializeParameter.AbstractInitializeMemberFromParameterCodeRefactoringProvider`4/<GetRefactoringsForSingleParameterAsync>d__4")]
protected virtual Task`1<ImmutableArray`1<CodeAction>> GetRefactoringsForSingleParameterAsync(Document document, IParameterSymbol parameter, SyntaxNode constructorDeclaration, IMethodSymbol method, IBlockOperation blockStatementOpt, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.InitializeParameter.AbstractInitializeMemberFromParameterCodeRefactoringProvider`4/<HandleNoExistingFieldOrPropertyAsync>d__5")]
private Task`1<ImmutableArray`1<CodeAction>> HandleNoExistingFieldOrPropertyAsync(Document document, IParameterSymbol parameter, SyntaxNode constructorDeclaration, IMethodSymbol method, IBlockOperation blockStatementOpt, ImmutableArray`1<NamingRule> rules, CancellationToken cancellationToken);
    private ValueTuple`2<CodeAction, CodeAction> AddAllParameterInitializationActions(Document document, SyntaxNode constructorDeclaration, IMethodSymbol method, IBlockOperation blockStatementOpt, ImmutableArray`1<NamingRule> rules, DocumentOptionSet options);
    private ValueTuple`2<CodeAction, CodeAction> AddSpecificParameterInitializationActions(Document document, IParameterSymbol parameter, SyntaxNode constructorDeclaration, IBlockOperation blockStatementOpt, ImmutableArray`1<NamingRule> rules, DocumentOptionSet options);
    [NullableContextAttribute("0")]
private static ImmutableArray`1<IParameterSymbol> GetParametersWithoutAssociatedMembers(IBlockOperation blockStatementOpt, ImmutableArray`1<NamingRule> rules, IMethodSymbol method);
    private ImmutableArray`1<CodeAction> HandleExistingFieldOrProperty(Document document, IParameterSymbol parameter, SyntaxNode functionDeclaration, IBlockOperation blockStatementOpt, ISymbol fieldOrProperty);
    [NullableContextAttribute("2")]
private static ISymbol TryFindSiblingFieldOrProperty(IParameterSymbol parameter, IBlockOperation blockStatementOpt);
    private IFieldSymbol CreateField(IParameterSymbol parameter, DocumentOptionSet options, ImmutableArray`1<NamingRule> rules);
    private static string GenerateUniqueName(IParameterSymbol parameter, ImmutableArray`1<string> parameterNameParts, NamingRule rule);
    private IPropertySymbol CreateProperty(IParameterSymbol parameter, DocumentOptionSet options, ImmutableArray`1<NamingRule> rules);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.InitializeParameter.AbstractInitializeMemberFromParameterCodeRefactoringProvider`4/<AddAllSymbolInitializationsAsync>d__14")]
private Task`1<Document> AddAllSymbolInitializationsAsync(Document document, SyntaxNode constructorDeclaration, IBlockOperation blockStatementOpt, ImmutableArray`1<IParameterSymbol> parameters, ImmutableArray`1<ISymbol> fieldsOrProperties, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.InitializeParameter.AbstractInitializeMemberFromParameterCodeRefactoringProvider`4/<AddSingleSymbolInitializationAsync>d__15")]
private Task`1<Document> AddSingleSymbolInitializationAsync(Document document, SyntaxNode constructorDeclaration, IBlockOperation blockStatementOpt, IParameterSymbol parameter, ISymbol fieldOrProperty, CancellationToken cancellationToken);
    private static CodeGenerationOptions GetAddOptions(IParameterSymbol parameter, IBlockOperation blockStatementOpt, SyntaxNode typeDeclaration, OptionSet options, CancellationToken cancellationToken);
    private static ImmutableArray`1<ValueTuple`2<IParameterSymbol, bool>> GetSiblingParameters(IParameterSymbol parameter);
    [NullableContextAttribute("2")]
private SyntaxNode TryGetStatementToAddInitializationAfter(IParameterSymbol parameter, IBlockOperation blockStatementOpt);
    [NullableContextAttribute("2")]
private static IOperation TryFindFieldOrPropertyAssignmentStatement(IParameterSymbol parameter, IBlockOperation blockStatementOpt);
    [NullableContextAttribute("2")]
private static IOperation TryFindFieldOrPropertyAssignmentStatement(IParameterSymbol parameter, IBlockOperation blockStatementOpt, ISymbol& fieldOrProperty);
    private static bool IsParameterReferenceOrCoalesceOfParameterReference(IAssignmentOperation assignmentExpression, IParameterSymbol parameter);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.InitializeParameter.AbstractInitializeMemberFromParameterCodeRefactoringProvider`4/<TryFindMatchingUninitializedFieldOrPropertySymbolAsync>d__22")]
private Task`1<ISymbol> TryFindMatchingUninitializedFieldOrPropertySymbolAsync(Document document, IParameterSymbol parameter, IBlockOperation blockStatementOpt, ImmutableArray`1<NamingRule> rules, ImmutableArray`1<string> parameterWords, CancellationToken cancellationToken);
    private static bool ContainsMemberAssignment(IBlockOperation blockStatementOpt, ISymbol member);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal abstract class Microsoft.CodeAnalysis.InitializeParameter.AbstractInitializeParameterCodeRefactoringProvider`4 : CodeRefactoringProvider {
    private Func`2<SyntaxNode, bool> _isFunctionDeclarationFunc;
    protected abstract virtual bool IsFunctionDeclaration(SyntaxNode node);
    protected abstract virtual bool IsImplicitConversion(Compilation compilation, ITypeSymbol source, ITypeSymbol destination);
    protected abstract virtual SyntaxNode GetBody(SyntaxNode functionDeclaration);
    protected abstract virtual Task`1<ImmutableArray`1<CodeAction>> GetRefactoringsForAllParametersAsync(Document document, SyntaxNode functionDeclaration, IMethodSymbol method, IBlockOperation blockStatementOpt, ImmutableArray`1<SyntaxNode> listOfParameterNodes, TextSpan parameterSpan, CancellationToken cancellationToken);
    protected abstract virtual Task`1<ImmutableArray`1<CodeAction>> GetRefactoringsForSingleParameterAsync(Document document, IParameterSymbol parameter, SyntaxNode functionDeclaration, IMethodSymbol methodSymbol, IBlockOperation blockStatementOpt, CancellationToken cancellationToken);
    protected abstract virtual void InsertStatement(SyntaxEditor editor, SyntaxNode functionDeclaration, bool returnsVoid, SyntaxNode statementToAddAfterOpt, TStatementSyntax statement);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.InitializeParameter.AbstractInitializeParameterCodeRefactoringProvider`4/<ComputeRefactoringsAsync>d__8")]
public virtual Task ComputeRefactoringsAsync(CodeRefactoringContext context);
    protected bool CanOfferRefactoring(SyntaxNode functionDeclaration, SemanticModel semanticModel, ISyntaxFactsService syntaxFacts, CancellationToken cancellationToken, IBlockOperation& blockStatementOpt);
    protected static bool IsParameterReference(IOperation operation, IParameterSymbol parameter);
    protected static IOperation UnwrapImplicitConversion(IOperation operation);
    protected static bool ContainsParameterReference(SemanticModel semanticModel, IOperation condition, IParameterSymbol parameter, CancellationToken cancellationToken);
    protected static bool IsFieldOrPropertyAssignment(IOperation statement, INamedTypeSymbol containingType, IAssignmentOperation& assignmentExpression);
    protected static bool IsFieldOrPropertyAssignment(IOperation statement, INamedTypeSymbol containingType, IAssignmentOperation& assignmentExpression, ISymbol& fieldOrProperty);
    protected static bool IsFieldOrPropertyReference(IOperation operation, INamedTypeSymbol containingType);
    [NullableContextAttribute("2")]
protected static bool IsFieldOrPropertyReference(IOperation operation, INamedTypeSymbol containingType, ISymbol& fieldOrProperty);
    [CompilerGeneratedAttribute]
internal static bool <ComputeRefactoringsAsync>g__TryGetParameterSymbol|8_0(SyntaxNode parameterNode, SemanticModel semanticModel, IParameterSymbol& parameter, CancellationToken cancellationToken);
}
internal abstract class Microsoft.CodeAnalysis.InlineHints.AbstractInlineHintsService : object {
    [NullableContextAttribute("1")]
[AsyncStateMachineAttribute("Microsoft.CodeAnalysis.InlineHints.AbstractInlineHintsService/<GetInlineHintsAsync>d__0")]
public sealed virtual Task`1<ImmutableArray`1<InlineHint>> GetInlineHintsAsync(Document document, TextSpan textSpan, CancellationToken cancellationToken);
}
internal abstract class Microsoft.CodeAnalysis.InlineHints.AbstractInlineParameterNameHintsService : object {
    [NullableContextAttribute("1")]
protected abstract virtual void AddAllParameterNameHintLocations(SemanticModel semanticModel, SyntaxNode node, ArrayBuilder`1<ValueTuple`3<int, IParameterSymbol, HintKind>> buffer, CancellationToken cancellationToken);
    [NullableContextAttribute("1")]
[AsyncStateMachineAttribute("Microsoft.CodeAnalysis.InlineHints.AbstractInlineParameterNameHintsService/<GetInlineHintsAsync>d__2")]
public sealed virtual Task`1<ImmutableArray`1<InlineHint>> GetInlineHintsAsync(Document document, TextSpan textSpan, CancellationToken cancellationToken);
    private static bool ParametersDifferOnlyBySuffix(ArrayBuilder`1<ValueTuple`3<int, IParameterSymbol, HintKind>> parameterHints);
    private static bool HintMatches(HintKind kind, bool literalParameters, bool objectCreationParameters, bool otherParameters);
    [NullableContextAttribute("2")]
protected static bool MatchesMethodIntent(IParameterSymbol parameter);
    [CompilerGeneratedAttribute]
internal static bool <ParametersDifferOnlyBySuffix>g__ParametersDifferOnlyByAlphaSuffix|3_0(ArrayBuilder`1<ValueTuple`3<int, IParameterSymbol, HintKind>> parameterHints);
    [CompilerGeneratedAttribute]
internal static bool <ParametersDifferOnlyBySuffix>g__ParametersDifferOnlyByNumericSuffix|3_1(ArrayBuilder`1<ValueTuple`3<int, IParameterSymbol, HintKind>> parameterHints);
    [CompilerGeneratedAttribute]
internal static bool <ParametersDifferOnlyBySuffix>g__HasAlphaSuffix|3_2(IParameterSymbol parameter, ReadOnlyMemory`1& prefix);
    [CompilerGeneratedAttribute]
internal static bool <ParametersDifferOnlyBySuffix>g__HasNumericSuffix|3_3(IParameterSymbol parameter, ReadOnlyMemory`1& prefix);
    [CompilerGeneratedAttribute]
internal static bool <ParametersDifferOnlyBySuffix>g__IsUpperAlpha|3_4(char c);
    [CompilerGeneratedAttribute]
internal static bool <ParametersDifferOnlyBySuffix>g__IsNumeric|3_5(char c);
    [NullableContextAttribute("1")]
[CompilerGeneratedAttribute]
internal static bool <MatchesMethodIntent>g__TryGetSuffix|5_0(string prefix, string nameValue, ReadOnlyMemory`1& suffix);
    [CompilerGeneratedAttribute]
internal static bool <MatchesMethodIntent>g__SuffixMatchesParameterName|5_1(ReadOnlyMemory`1<char> suffix, string parameterName);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal abstract class Microsoft.CodeAnalysis.InlineHints.AbstractInlineTypeHintsService : object {
    private static SymbolDisplayFormat s_minimalTypeStyle;
    private static AbstractInlineTypeHintsService();
    protected abstract virtual Nullable`1<TypeHint> TryGetTypeHint(SemanticModel semanticModel, SyntaxNode node, bool displayAllOverride, bool forImplicitVariableTypes, bool forLambdaParameterTypes, bool forImplicitObjectCreation, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.InlineHints.AbstractInlineTypeHintsService/<GetInlineHintsAsync>d__2")]
public sealed virtual Task`1<ImmutableArray`1<InlineHint>> GetInlineHintsAsync(Document document, TextSpan textSpan, CancellationToken cancellationToken);
    private void AddParts(IAnonymousTypeDisplayService anonymousTypeService, ArrayBuilder`1<SymbolDisplayPart> finalParts, ImmutableArray`1<SymbolDisplayPart> parts, SemanticModel semanticModel, int position, HashSet`1<INamedTypeSymbol> seenSymbols);
}
internal interface Microsoft.CodeAnalysis.InlineHints.IInlineHintsService {
    [NullableContextAttribute("1")]
public abstract virtual Task`1<ImmutableArray`1<InlineHint>> GetInlineHintsAsync(Document document, TextSpan textSpan, CancellationToken cancellationToken);
}
internal interface Microsoft.CodeAnalysis.InlineHints.IInlineParameterNameHintsService {
    [NullableContextAttribute("1")]
public abstract virtual Task`1<ImmutableArray`1<InlineHint>> GetInlineHintsAsync(Document document, TextSpan textSpan, CancellationToken cancellationToken);
}
internal interface Microsoft.CodeAnalysis.InlineHints.IInlineTypeHintsService {
    [NullableContextAttribute("1")]
public abstract virtual Task`1<ImmutableArray`1<InlineHint>> GetInlineHintsAsync(Document document, TextSpan textSpan, CancellationToken cancellationToken);
}
[IsReadOnlyAttribute]
internal class Microsoft.CodeAnalysis.InlineHints.InlineHint : ValueType {
    public TextSpan Span;
    public ImmutableArray`1<TaggedText> DisplayParts;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private Func`3<Document, CancellationToken, Task`1<ImmutableArray`1<TaggedText>>> _getDescriptionAsync;
    public InlineHint(TextSpan span, ImmutableArray`1<TaggedText> displayParts, Func`3<Document, CancellationToken, Task`1<ImmutableArray`1<TaggedText>>> getDescriptionAsync);
    [NullableContextAttribute("1")]
public Task`1<ImmutableArray`1<TaggedText>> GetDescriptionAsync(Document document, CancellationToken cancellationToken);
}
internal static class Microsoft.CodeAnalysis.InlineHints.InlineHintHelpers : object {
    public static Func`3<Document, CancellationToken, Task`1<ImmutableArray`1<TaggedText>>> GetDescriptionFunction(int position, SymbolKey symbolKey);
    [NullableContextAttribute("1")]
[AsyncStateMachineAttribute("Microsoft.CodeAnalysis.InlineHints.InlineHintHelpers/<GetDescriptionAsync>d__1")]
private static Task`1<ImmutableArray`1<TaggedText>> GetDescriptionAsync(Document document, int position, SymbolKey symbolKey, CancellationToken cancellationToken);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal static class Microsoft.CodeAnalysis.InlineHints.InlineHintsOptions : object {
    public static Option2`1<bool> DisplayAllHintsWhilePressingAltF1;
    public static PerLanguageOption2`1<bool> ColorHints;
    public static Option2`1<bool> DisplayAllOverride;
    public static PerLanguageOption2`1<bool> EnabledForParameters;
    public static PerLanguageOption2`1<bool> ForLiteralParameters;
    public static PerLanguageOption2`1<bool> ForObjectCreationParameters;
    public static PerLanguageOption2`1<bool> ForOtherParameters;
    public static PerLanguageOption2`1<bool> SuppressForParametersThatDifferOnlyBySuffix;
    public static PerLanguageOption2`1<bool> SuppressForParametersThatMatchMethodIntent;
    public static PerLanguageOption2`1<bool> EnabledForTypes;
    public static PerLanguageOption2`1<bool> ForImplicitVariableTypes;
    public static PerLanguageOption2`1<bool> ForLambdaParameterTypes;
    public static PerLanguageOption2`1<bool> ForImplicitObjectCreation;
    private static InlineHintsOptions();
}
[ExportOptionProviderAttribute]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.InlineHints.InlineHintsOptionsProvider : object {
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private ImmutableArray`1<IOption> <Options>k__BackingField;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ImmutableArray`1<IOption> Options { get; }
    [CompilerGeneratedAttribute]
public sealed virtual ImmutableArray`1<IOption> get_Options();
}
[IsReadOnlyAttribute]
internal class Microsoft.CodeAnalysis.InlineHints.TypeHint : ValueType {
    private static ImmutableArray`1<SymbolDisplayPart> s_spaceArray;
    [NullableAttribute("1")]
[CompilerGeneratedAttribute]
private ITypeSymbol <Type>k__BackingField;
    [CompilerGeneratedAttribute]
private TextSpan <Span>k__BackingField;
    [CompilerGeneratedAttribute]
private ImmutableArray`1<SymbolDisplayPart> <Prefix>k__BackingField;
    [CompilerGeneratedAttribute]
private ImmutableArray`1<SymbolDisplayPart> <Suffix>k__BackingField;
    [NullableAttribute("1")]
public ITypeSymbol Type { get; }
    public TextSpan Span { get; }
    public ImmutableArray`1<SymbolDisplayPart> Prefix { get; }
    public ImmutableArray`1<SymbolDisplayPart> Suffix { get; }
    [NullableContextAttribute("1")]
public TypeHint(ITypeSymbol type, TextSpan span, bool leadingSpace, bool trailingSpace);
    private static TypeHint();
    [NullableContextAttribute("1")]
[CompilerGeneratedAttribute]
public ITypeSymbol get_Type();
    [CompilerGeneratedAttribute]
public TextSpan get_Span();
    [CompilerGeneratedAttribute]
public ImmutableArray`1<SymbolDisplayPart> get_Prefix();
    [CompilerGeneratedAttribute]
public ImmutableArray`1<SymbolDisplayPart> get_Suffix();
    private static ImmutableArray`1<SymbolDisplayPart> CreateSpaceSymbolPartArray(bool hasSpace);
    public void Deconstruct(ITypeSymbol& type, TextSpan& span, ImmutableArray`1& prefix, ImmutableArray`1& suffix);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal abstract class Microsoft.CodeAnalysis.InlineMethod.AbstractInlineMethodRefactoringProvider`4 : CodeRefactoringProvider {
    private static string TemporaryName;
    private ISyntaxFacts _syntaxFacts;
    private ISemanticFactsService _semanticFactsService;
    protected AbstractInlineMethodRefactoringProvider`4(ISyntaxFacts syntaxFacts, ISemanticFactsService semanticFactsService);
    protected abstract virtual TExpressionSyntax GetRawInlineExpression(TMethodDeclarationSyntax calleeMethodDeclarationSyntaxNode);
    protected abstract virtual SyntaxNode GenerateTypeSyntax(ITypeSymbol symbol, bool allowVar);
    protected abstract virtual TExpressionSyntax GenerateLiteralExpression(ITypeSymbol typeSymbol, object value);
    protected abstract virtual bool IsFieldDeclarationSyntax(SyntaxNode node);
    protected abstract virtual bool IsValidExpressionUnderExpressionStatement(TExpressionSyntax expressionNode);
    protected abstract virtual bool CanBeReplacedByThrowExpression(SyntaxNode syntaxNode);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.InlineMethod.AbstractInlineMethodRefactoringProvider`4/<ComputeRefactoringsAsync>d__10")]
public virtual Task ComputeRefactoringsAsync(CodeRefactoringContext context);
    private ImmutableArray`1<CodeAction> GenerateCodeActions(Document document, TInvocationSyntax calleeMethodInvocationNode, IMethodSymbol calleeMethodSymbol, TMethodDeclarationSyntax calleeMethodNode, ISymbol callerSymbol, SyntaxNode callerMethodNode, TExpressionSyntax inlineExpression, IInvocationOperation invocationOperation);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.InlineMethod.AbstractInlineMethodRefactoringProvider`4/<InlineMethodAsync>d__12")]
private Task`1<Solution> InlineMethodAsync(Document document, TInvocationSyntax calleeInvocationNode, IMethodSymbol calleeMethodSymbol, TMethodDeclarationSyntax calleeMethodNode, ISymbol callerSymbol, SyntaxNode callerNode, TExpressionSyntax rawInlineExpression, IInvocationOperation invocationOperation, bool removeCalleeDeclarationNode, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.InlineMethod.AbstractInlineMethodRefactoringProvider`4/<GetChangedCallerAsync>d__13")]
private Task`1<SyntaxNode> GetChangedCallerAsync(Document document, TInvocationSyntax calleeInvocationNode, IMethodSymbol calleeMethodSymbol, ISymbol callerSymbol, SyntaxNode callerDeclarationNode, TStatementSyntax statementContainsInvocation, TExpressionSyntax rawInlineExpression, MethodParametersInfo<TMethodDeclarationSyntax, TStatementSyntax, TExpressionSyntax, TInvocationSyntax> methodParametersInfo, InlineMethodContext<TMethodDeclarationSyntax, TStatementSyntax, TExpressionSyntax, TInvocationSyntax> inlineMethodContext, CancellationToken cancellationToken);
    private ValueTuple`2<SyntaxNode, SyntaxNode> GetInlineNode(TInvocationSyntax calleeInvocationNode, IMethodSymbol calleeMethodSymbol, TStatementSyntax statementContainsInvocation, TExpressionSyntax rawInlineExpression, MethodParametersInfo<TMethodDeclarationSyntax, TStatementSyntax, TExpressionSyntax, TInvocationSyntax> methodParametersInfo, InlineMethodContext<TMethodDeclarationSyntax, TStatementSyntax, TExpressionSyntax, TInvocationSyntax> inlineMethodContext, SemanticModel semanticModel, SyntaxGenerator syntaxGenerator, CancellationToken cancellationToken);
    private ISymbol GetCallerSymbol(TInvocationSyntax calleeMethodInvocationNode, SemanticModel semanticModel, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.InlineMethod.AbstractInlineMethodRefactoringProvider`4/<GetInlineMethodContextAsync>d__18")]
private Task`1<InlineMethodContext<TMethodDeclarationSyntax, TStatementSyntax, TExpressionSyntax, TInvocationSyntax>> GetInlineMethodContextAsync(Document document, TMethodDeclarationSyntax calleeMethodNode, TInvocationSyntax calleeInvocationNode, IMethodSymbol calleeMethodSymbol, TExpressionSyntax rawInlineExpression, MethodParametersInfo<TMethodDeclarationSyntax, TStatementSyntax, TExpressionSyntax, TInvocationSyntax> methodParametersInfo, CancellationToken cancellationToken);
    private static ImmutableArray`1<TStatementSyntax> GetLocalDeclarationStatementsNeedInsert(SyntaxGenerator syntaxGenerator, ImmutableArray`1<ValueTuple`2<IParameterSymbol, TExpressionSyntax>> parametersToGenerateFreshVariablesFor, ImmutableArray`1<ValueTuple`2<IParameterSymbol, string>> parametersWithVariableDeclarationArgument, ImmutableDictionary`2<ISymbol, string> renameTable);
    private bool ContainsAwaitExpression(TExpressionSyntax inlineExpression);
    private static TStatementSyntax CreateLocalDeclarationStatement(SyntaxGenerator syntaxGenerator, ImmutableDictionary`2<ISymbol, string> renameTable, ValueTuple`2<IParameterSymbol, TExpressionSyntax> parameterAndExpression);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.InlineMethod.AbstractInlineMethodRefactoringProvider`4/<ReplaceAllSyntaxNodesForSymbolAsync>d__22")]
private static Task`1<TExpressionSyntax> ReplaceAllSyntaxNodesForSymbolAsync(Document document, TExpressionSyntax inlineExpression, SyntaxGenerator syntaxGenerator, ImmutableDictionary`2<ISymbol, SyntaxNode> replacementTable, CancellationToken cancellationToken);
    private ImmutableDictionary`2<ISymbol, SyntaxNode> ComputeReplacementTable(IMethodSymbol calleeMethodSymbol, ImmutableArray`1<ValueTuple`2<IParameterSymbol, string>> parametersWithVariableDeclarationArgument, ImmutableDictionary`2<IParameterSymbol, TExpressionSyntax> parametersToReplace, SyntaxGenerator syntaxGenerator, ImmutableDictionary`2<ISymbol, string> renameTable);
    private static ImmutableDictionary`2<ISymbol, string> ComputeRenameTable(ISemanticFactsService semanticFacts, SemanticModel callerSemanticModel, SemanticModel calleeSemanticModel, SyntaxNode calleeInvocationNode, TExpressionSyntax rawInlineExpression, ImmutableArray`1<IParameterSymbol> parametersNeedGenerateFreshVariableFor, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.InlineMethod.AbstractInlineMethodRefactoringProvider`4/<GetMethodParametersInfoAsync>d__27")]
private Task`1<MethodParametersInfo<TMethodDeclarationSyntax, TStatementSyntax, TExpressionSyntax, TInvocationSyntax>> GetMethodParametersInfoAsync(Document document, TInvocationSyntax calleeInvocationNode, TMethodDeclarationSyntax calleeMethodNode, TStatementSyntax statementContainingInvocation, TExpressionSyntax rawInlineExpression, IInvocationOperation invocationOperation, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.InlineMethod.AbstractInlineMethodRefactoringProvider`4/<GetArgumentsReadOnlyOnceAsync>d__28")]
private static Task`1<ImmutableArray`1<IArgumentOperation>> GetArgumentsReadOnlyOnceAsync(Document document, ImmutableArray`1<IArgumentOperation> arguments, TMethodDeclarationSyntax calleeMethodNode, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.InlineMethod.AbstractInlineMethodRefactoringProvider`4/<ShouldMergeInlineContentAndVariableDeclarationArgumentAsync>d__29")]
private Task`1<bool> ShouldMergeInlineContentAndVariableDeclarationArgumentAsync(Document calleeDocument, TInvocationSyntax calleInvocationNode, ImmutableArray`1<ValueTuple`2<IParameterSymbol, string>> parametersWithVariableDeclarationArgument, TExpressionSyntax inlineExpressionNode, CancellationToken cancellationToken);
    private TExpressionSyntax GenerateArgumentExpression(SyntaxGenerator syntaxGenerator, IArgumentOperation argumentOperation);
    [NullableContextAttribute("0")]
[CompilerGeneratedAttribute]
private bool <InlineMethodAsync>b__12_0(SyntaxNode node);
    [CompilerGeneratedAttribute]
private bool <ContainsAwaitExpression>b__20_0(SyntaxNode node);
}
internal abstract class Microsoft.CodeAnalysis.InlineTemporary.AbstractInlineTemporaryCodeRefactoringProvider`1 : CodeRefactoringProvider {
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.InlineTemporary.AbstractInlineTemporaryCodeRefactoringProvider`1/<GetReferenceLocationsAsync>d__0")]
protected static Task`1<ImmutableArray`1<ReferenceLocation>> GetReferenceLocationsAsync(Document document, TVariableDeclaratorSyntax variableDeclarator, CancellationToken cancellationToken);
}
internal static class Microsoft.CodeAnalysis.InternalLanguageNames : object {
    [NullableAttribute("1")]
public static string TypeScript;
}
internal abstract class Microsoft.CodeAnalysis.IntroduceUsingStatement.AbstractIntroduceUsingStatementCodeRefactoringProvider`2 : CodeRefactoringProvider {
    protected string CodeActionTitle { get; }
    protected abstract virtual string get_CodeActionTitle();
    protected abstract virtual bool CanRefactorToContainBlockStatements(SyntaxNode parent);
    protected abstract virtual SyntaxList`1<TStatementSyntax> GetStatements(SyntaxNode parentOfStatementsToSurround);
    protected abstract virtual SyntaxNode WithStatements(SyntaxNode parentOfStatementsToSurround, SyntaxList`1<TStatementSyntax> statements);
    protected abstract virtual TStatementSyntax CreateUsingStatement(TLocalDeclarationSyntax declarationStatement, SyntaxTriviaList sameLineTrivia, SyntaxList`1<TStatementSyntax> statementsToSurround);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.IntroduceUsingStatement.AbstractIntroduceUsingStatementCodeRefactoringProvider`2/<ComputeRefactoringsAsync>d__6")]
public virtual Task ComputeRefactoringsAsync(CodeRefactoringContext context);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.IntroduceUsingStatement.AbstractIntroduceUsingStatementCodeRefactoringProvider`2/<FindDisposableLocalDeclarationAsync>d__7")]
private Task`1<TLocalDeclarationSyntax> FindDisposableLocalDeclarationAsync(Document document, TextSpan selection, CancellationToken cancellationToken);
    private static bool IsLegalUsingStatementType(Compilation compilation, ITypeSymbol disposableType, ITypeSymbol type);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.IntroduceUsingStatement.AbstractIntroduceUsingStatementCodeRefactoringProvider`2/<IntroduceUsingStatementAsync>d__9")]
private Task`1<Document> IntroduceUsingStatementAsync(Document document, TLocalDeclarationSyntax declarationStatement, CancellationToken cancellationToken);
    private SyntaxList`1<TStatementSyntax> GetStatementsToSurround(TLocalDeclarationSyntax declarationStatement, SemanticModel semanticModel, ISyntaxFactsService syntaxFactsService, CancellationToken cancellationToken);
    private static ValueTuple`2<SyntaxTriviaList, SyntaxTriviaList> SplitTrailingTrivia(SyntaxNode node, ISyntaxFactsService syntaxFactsService);
    private static TStatementSyntax FindSiblingStatementContainingLastUsage(TStatementSyntax declarationSyntax, SemanticModel semanticModel, ISyntaxFactsService syntaxFactsService, CancellationToken cancellationToken);
    private static void AddReferencedLocalVariables(HashSet`1<ISymbol> referencedVariables, SyntaxNode node, IReadOnlyList`1<ISymbol> localVariables, SemanticModel semanticModel, ISyntaxFactsService syntaxFactsService, CancellationToken cancellationToken);
}
internal abstract class Microsoft.CodeAnalysis.IntroduceVariable.AbstractIntroduceLocalForExpressionCodeRefactoringProvider`4 : CodeRefactoringProvider {
    protected abstract virtual bool IsValid(TExpressionStatementSyntax expressionStatement, TextSpan span);
    protected abstract virtual TLocalDeclarationStatementSyntax FixupLocalDeclaration(TExpressionStatementSyntax expressionStatement, TLocalDeclarationStatementSyntax localDeclaration);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.IntroduceVariable.AbstractIntroduceLocalForExpressionCodeRefactoringProvider`4/<ComputeRefactoringsAsync>d__2")]
public sealed virtual Task ComputeRefactoringsAsync(CodeRefactoringContext context);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.IntroduceVariable.AbstractIntroduceLocalForExpressionCodeRefactoringProvider`4/<GetExpressionStatementAsync>d__3")]
protected Task`1<TExpressionStatementSyntax> GetExpressionStatementAsync(CodeRefactoringContext context);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.IntroduceVariable.AbstractIntroduceLocalForExpressionCodeRefactoringProvider`4/<IntroduceLocalAsync>d__4")]
private Task`1<Document> IntroduceLocalAsync(Document document, TExpressionStatementSyntax expressionStatement, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.IntroduceVariable.AbstractIntroduceLocalForExpressionCodeRefactoringProvider`4/<GenerateUniqueNameAsync>d__5")]
protected static Task`1<SyntaxToken> GenerateUniqueNameAsync(Document document, TExpressionSyntax expression, CancellationToken cancellationToken);
}
internal abstract class Microsoft.CodeAnalysis.IntroduceVariable.AbstractIntroduceVariableService`6 : object {
    protected abstract virtual bool IsInNonFirstQueryClause(TExpressionSyntax expression);
    protected abstract virtual bool IsInFieldInitializer(TExpressionSyntax expression);
    protected abstract virtual bool IsInParameterInitializer(TExpressionSyntax expression);
    protected abstract virtual bool IsInConstructorInitializer(TExpressionSyntax expression);
    protected abstract virtual bool IsInAttributeArgumentInitializer(TExpressionSyntax expression);
    protected abstract virtual bool IsInAutoPropertyInitializer(TExpressionSyntax expression);
    protected abstract virtual bool IsInExpressionBodiedMember(TExpressionSyntax expression);
    protected abstract virtual IEnumerable`1<SyntaxNode> GetContainingExecutableBlocks(TExpressionSyntax expression);
    protected abstract virtual IList`1<bool> GetInsertionIndices(TTypeDeclarationSyntax destination, CancellationToken cancellationToken);
    protected abstract virtual bool CanIntroduceVariableFor(TExpressionSyntax expression);
    protected abstract virtual bool CanReplace(TExpressionSyntax expression);
    protected abstract virtual bool IsExpressionInStaticLocalFunction(TExpressionSyntax expression);
    protected abstract virtual Task`1<Document> IntroduceQueryLocalAsync(SemanticDocument document, TExpressionSyntax expression, bool allOccurrences, CancellationToken cancellationToken);
    protected abstract virtual Task`1<Document> IntroduceLocalAsync(SemanticDocument document, TExpressionSyntax expression, bool allOccurrences, bool isConstant, CancellationToken cancellationToken);
    protected abstract virtual Task`1<Document> IntroduceFieldAsync(SemanticDocument document, TExpressionSyntax expression, bool allOccurrences, bool isConstant, CancellationToken cancellationToken);
    protected abstract virtual int DetermineFieldInsertPosition(TTypeDeclarationSyntax oldDeclaration, TTypeDeclarationSyntax newDeclaration);
    protected abstract virtual int DetermineConstantInsertPosition(TTypeDeclarationSyntax oldDeclaration, TTypeDeclarationSyntax newDeclaration);
    protected virtual bool BlockOverlapsHiddenPosition(SyntaxNode block, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.IntroduceVariable.AbstractIntroduceVariableService`6/<IntroduceVariableAsync>d__20")]
public sealed virtual Task`1<CodeAction> IntroduceVariableAsync(Document document, TextSpan textSpan, CancellationToken cancellationToken);
    private ValueTuple`2<string, ImmutableArray`1<CodeAction>> CreateActions(State<TService, TExpressionSyntax, TTypeSyntax, TTypeDeclarationSyntax, TQueryExpressionSyntax, TNameSyntax> state, CancellationToken cancellationToken);
    private string AddActionsAndGetTitle(State<TService, TExpressionSyntax, TTypeSyntax, TTypeDeclarationSyntax, TQueryExpressionSyntax, TNameSyntax> state, ArrayBuilder`1<CodeAction> actions, CancellationToken cancellationToken);
    private static string GetConstantOrFieldResource(bool isConstant);
    private static string GetConstantOrLocalResource(bool isConstant);
    private void CreateConstantFieldActions(State<TService, TExpressionSyntax, TTypeSyntax, TTypeDeclarationSyntax, TQueryExpressionSyntax, TNameSyntax> state, ArrayBuilder`1<CodeAction> actions, CancellationToken cancellationToken);
    protected int GetFieldInsertionIndex(bool isConstant, TTypeDeclarationSyntax oldType, TTypeDeclarationSyntax newType, CancellationToken cancellationToken);
    private bool CanGenerateIntoContainer(State<TService, TExpressionSyntax, TTypeSyntax, TTypeDeclarationSyntax, TQueryExpressionSyntax, TNameSyntax> state, CancellationToken cancellationToken);
    private CodeAction CreateAction(State<TService, TExpressionSyntax, TTypeSyntax, TTypeDeclarationSyntax, TQueryExpressionSyntax, TNameSyntax> state, bool allOccurrences, bool isConstant, bool isLocal, bool isQueryLocal);
    protected static SyntaxToken GenerateUniqueFieldName(SemanticDocument semanticDocument, TExpressionSyntax expression, bool isConstant, CancellationToken cancellationToken);
    protected static SyntaxToken GenerateUniqueLocalName(SemanticDocument semanticDocument, TExpressionSyntax expression, bool isConstant, SyntaxNode containerOpt, CancellationToken cancellationToken);
    protected ISet`1<TExpressionSyntax> FindMatches(SemanticDocument originalDocument, TExpressionSyntax expressionInOriginal, SemanticDocument currentDocument, SyntaxNode withinNodeInCurrent, bool allOccurrences, CancellationToken cancellationToken);
    private bool NodeMatchesExpression(SemanticModel originalSemanticModel, SemanticModel currentSemanticModel, TExpressionSyntax expressionInOriginal, TExpressionSyntax nodeInCurrent, bool allOccurrences, CancellationToken cancellationToken);
    protected TNode Rewrite(SemanticDocument originalDocument, TExpressionSyntax expressionInOriginal, TExpressionSyntax variableName, SemanticDocument currentDocument, TNode withinNodeInCurrent, bool allOccurrences, CancellationToken cancellationToken);
    protected abstract virtual TNode RewriteCore(TNode node, SyntaxNode replacementNode, ISet`1<TExpressionSyntax> matches);
    protected static ITypeSymbol GetTypeSymbol(SemanticDocument document, TExpressionSyntax expression, CancellationToken cancellationToken, bool objectAsDefault);
    protected static IEnumerable`1<IParameterSymbol> GetAnonymousMethodParameters(SemanticDocument document, TExpressionSyntax expression, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.IntroduceVariable.AbstractIntroduceVariableService`6/<ComplexifyParentingStatementsAsync>d__37")]
protected static Task`1<ValueTuple`2<SemanticDocument, ISet`1<TExpressionSyntax>>> ComplexifyParentingStatementsAsync(SemanticDocument semanticDocument, ISet`1<TExpressionSyntax> matches, CancellationToken cancellationToken);
    [CompilerGeneratedAttribute]
internal static bool <NodeMatchesExpression>g__IsInstanceMemberReference|32_0(IOperation operation);
}
internal interface Microsoft.CodeAnalysis.IntroduceVariable.IIntroduceVariableService {
    public abstract virtual Task`1<CodeAction> IntroduceVariableAsync(Document document, TextSpan textSpan, CancellationToken cancellationToken);
}
[ExtensionOrderAttribute]
[ExtensionOrderAttribute]
[ExtensionOrderAttribute]
[ExtensionOrderAttribute]
[ExportCodeRefactoringProviderAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.IntroduceVariable.IntroduceVariableCodeRefactoringProvider : CodeRefactoringProvider {
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.IntroduceVariable.IntroduceVariableCodeRefactoringProvider/<ComputeRefactoringsAsync>d__1")]
public virtual Task ComputeRefactoringsAsync(CodeRefactoringContext context);
}
internal abstract class Microsoft.CodeAnalysis.InvertConditional.AbstractInvertConditionalCodeRefactoringProvider`1 : CodeRefactoringProvider {
    protected abstract virtual bool ShouldOffer(TConditionalExpressionSyntax conditional);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.InvertConditional.AbstractInvertConditionalCodeRefactoringProvider`1/<ComputeRefactoringsAsync>d__1")]
public virtual Task ComputeRefactoringsAsync(CodeRefactoringContext context);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.InvertConditional.AbstractInvertConditionalCodeRefactoringProvider`1/<FindConditionalAsync>d__2")]
private static Task`1<TConditionalExpressionSyntax> FindConditionalAsync(Document document, TextSpan span, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.InvertConditional.AbstractInvertConditionalCodeRefactoringProvider`1/<InvertConditionalAsync>d__3")]
private static Task`1<Document> InvertConditionalAsync(Document document, TextSpan span, CancellationToken cancellationToken);
}
internal abstract class Microsoft.CodeAnalysis.InvertIf.AbstractInvertIfCodeRefactoringProvider`3 : CodeRefactoringProvider {
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.InvertIf.AbstractInvertIfCodeRefactoringProvider`3/<ComputeRefactoringsAsync>d__1")]
public sealed virtual Task ComputeRefactoringsAsync(CodeRefactoringContext context);
    private InvertIfStyle<TIfStatementSyntax, TStatementSyntax, TEmbeddedStatement> GetInvertIfStyle(TIfStatementSyntax ifNode, SemanticModel semanticModel, SyntaxNode& subsequentSingleExitPointOpt);
    private bool SingleSubsequentStatement(ImmutableArray`1<StatementRange<TIfStatementSyntax, TStatementSyntax, TEmbeddedStatement>> subsequentStatementRanges);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.InvertIf.AbstractInvertIfCodeRefactoringProvider`3/<InvertIfAsync>d__4")]
private Task`1<Document> InvertIfAsync(Document document, TIfStatementSyntax ifNode, CancellationToken cancellationToken);
    private static void AnalyzeSubsequentControlFlow(SemanticModel semanticModel, ImmutableArray`1<StatementRange<TIfStatementSyntax, TStatementSyntax, TEmbeddedStatement>> subsequentStatementRanges, Boolean& subsequentEndPointIsReachable, SyntaxNode& subsequentSingleExitPointOpt);
    private static void AnalyzeControlFlow(SemanticModel semanticModel, StatementRange<TIfStatementSyntax, TStatementSyntax, TEmbeddedStatement> statementRange, Boolean& endPointIsReachable, SyntaxNode& singleExitPointOpt);
    private static bool SubsequentStatementsAreInTheSameBlock(TIfStatementSyntax ifNode, ImmutableArray`1<StatementRange<TIfStatementSyntax, TStatementSyntax, TEmbeddedStatement>> subsequentStatementRanges);
    private int GetNearmostParentJumpStatementRawKind(SyntaxNode ifNode);
    private bool IsEmptyStatementRange(StatementRange<TIfStatementSyntax, TStatementSyntax, TEmbeddedStatement> statementRange);
    private ImmutableArray`1<StatementRange<TIfStatementSyntax, TStatementSyntax, TEmbeddedStatement>> GetSubsequentStatementRanges(TIfStatementSyntax ifNode);
    protected abstract virtual string GetTitle();
    protected abstract virtual SyntaxList`1<TStatementSyntax> GetStatements(SyntaxNode node);
    protected abstract virtual TStatementSyntax GetNextStatement(TStatementSyntax node);
    protected abstract virtual TStatementSyntax GetJumpStatement(int rawKind);
    protected abstract virtual int GetJumpStatementRawKind(SyntaxNode node);
    protected abstract virtual bool IsNoOpSyntaxNode(SyntaxNode node);
    protected abstract virtual bool IsExecutableStatement(SyntaxNode node);
    protected abstract virtual bool IsStatementContainer(SyntaxNode node);
    protected abstract virtual bool IsSingleStatementStatementRange(StatementRange<TIfStatementSyntax, TStatementSyntax, TEmbeddedStatement> statementRange);
    protected abstract virtual bool CanControlFlowOut(SyntaxNode node);
    protected abstract virtual bool CanInvert(TIfStatementSyntax ifNode);
    protected abstract virtual bool IsElseless(TIfStatementSyntax ifNode);
    protected abstract virtual StatementRange<TIfStatementSyntax, TStatementSyntax, TEmbeddedStatement> GetIfBodyStatementRange(TIfStatementSyntax ifNode);
    protected abstract virtual SyntaxNode GetCondition(TIfStatementSyntax ifNode);
    protected abstract virtual IEnumerable`1<TStatementSyntax> UnwrapBlock(TEmbeddedStatement ifBody);
    protected abstract virtual TEmbeddedStatement GetIfBody(TIfStatementSyntax ifNode);
    protected abstract virtual TEmbeddedStatement GetElseBody(TIfStatementSyntax ifNode);
    protected abstract virtual TEmbeddedStatement GetEmptyEmbeddedStatement();
    protected abstract virtual TEmbeddedStatement AsEmbeddedStatement(IEnumerable`1<TStatementSyntax> statements, TEmbeddedStatement original);
    protected abstract virtual TIfStatementSyntax UpdateIf(SourceText sourceText, TIfStatementSyntax ifNode, SyntaxNode condition, TEmbeddedStatement trueStatement, TEmbeddedStatement falseStatementOpt);
    protected abstract virtual SyntaxNode WithStatements(SyntaxNode node, IEnumerable`1<TStatementSyntax> statements);
    private SyntaxNode GetRootWithInvertIfStatement(SourceText text, SyntaxNode root, TIfStatementSyntax ifNode, InvertIfStyle<TIfStatementSyntax, TStatementSyntax, TEmbeddedStatement> invertIfStyle, SyntaxNode subsequentSingleExitPointOpt, SyntaxNode negatedExpression);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal abstract class Microsoft.CodeAnalysis.InvertLogical.AbstractInvertLogicalCodeRefactoringProvider`3 : CodeRefactoringProvider {
    private static SyntaxAnnotation s_annotation;
    private static AbstractInvertLogicalCodeRefactoringProvider`3();
    [NullableContextAttribute("0")]
protected abstract virtual string GetOperatorText(TSyntaxKind binaryExprKind);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.InvertLogical.AbstractInvertLogicalCodeRefactoringProvider`3/<ComputeRefactoringsAsync>d__2")]
public virtual Task ComputeRefactoringsAsync(CodeRefactoringContext context);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.InvertLogical.AbstractInvertLogicalCodeRefactoringProvider`3/<InvertLogicalAsync>d__3")]
private static Task`1<Document> InvertLogicalAsync(Document document1, SyntaxNode binaryExpression, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.InvertLogical.AbstractInvertLogicalCodeRefactoringProvider`3/<InvertInnerExpressionAsync>d__4")]
private static Task`1<Document> InvertInnerExpressionAsync(Document document, SyntaxNode binaryExpression, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.InvertLogical.AbstractInvertLogicalCodeRefactoringProvider`3/<InvertOuterExpressionAsync>d__5")]
private static Task`1<Document> InvertOuterExpressionAsync(Document document, CancellationToken cancellationToken);
    private string GetTitle(ISyntaxKindsService syntaxKinds, int binaryExprKind);
    private static int InvertedKind(ISyntaxKindsService syntaxKinds, int binaryExprKind);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.CodeAnalysis.LanguageServerIndexFormat.SymbolMoniker : object {
    [CompilerGeneratedAttribute]
private string <Scheme>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Identifier>k__BackingField;
    public string Scheme { get; }
    public string Identifier { get; }
    public SymbolMoniker(string scheme, string identifier);
    [CompilerGeneratedAttribute]
public string get_Scheme();
    [CompilerGeneratedAttribute]
public string get_Identifier();
    public static SymbolMoniker TryCreate(ISymbol symbol);
    [CompilerGeneratedAttribute]
internal static string <TryCreate>g__GetRequiredDocumentationCommentId|7_0(ISymbol symbol);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal static class Microsoft.CodeAnalysis.LanguageServerIndexFormat.WellKnownSymbolMonikerSchemes : object {
    public static string DotnetNamespace;
    public static string DotnetXmlDoc;
}
internal abstract class Microsoft.CodeAnalysis.LanguageServices.AbstractAnonymousTypeDisplayService : object {
    public abstract virtual ImmutableArray`1<SymbolDisplayPart> GetAnonymousTypeParts(INamedTypeSymbol anonymousType, SemanticModel semanticModel, int position);
    public sealed virtual AnonymousTypeDisplayInfo GetNormalAnonymousTypeDisplayInfo(ISymbol orderSymbol, IEnumerable`1<INamedTypeSymbol> directNormalAnonymousTypeReferences, SemanticModel semanticModel, int position);
    private static Dictionary`2<INamedTypeSymbol, string> GenerateAnonymousTypeNames(IList`1<INamedTypeSymbol> anonymousTypes);
    private static string GenerateAnonymousTypeName(int current);
    private static IList`1<INamedTypeSymbol> OrderAnonymousTypes(IList`1<INamedTypeSymbol> transitiveAnonymousTypeReferences, ISymbol symbol);
    private static IList`1<INamedTypeSymbol> GetTransitiveNormalAnonymousTypeReferences(ISet`1<INamedTypeSymbol> anonymousTypeReferences);
    [IteratorStateMachineAttribute("Microsoft.CodeAnalysis.LanguageServices.AbstractAnonymousTypeDisplayService/<LineBreak>d__6")]
protected static IEnumerable`1<SymbolDisplayPart> LineBreak(int count);
    protected static SymbolDisplayPart PlainText(string text);
    private static SymbolDisplayPart Part(SymbolDisplayPartKind kind, string text);
    private static SymbolDisplayPart Part(SymbolDisplayPartKind kind, ISymbol symbol, string text);
    [IteratorStateMachineAttribute("Microsoft.CodeAnalysis.LanguageServices.AbstractAnonymousTypeDisplayService/<Space>d__10")]
protected static IEnumerable`1<SymbolDisplayPart> Space(int count);
    protected static SymbolDisplayPart Punctuation(string text);
    protected static SymbolDisplayPart Keyword(string text);
}
internal abstract class Microsoft.CodeAnalysis.LanguageServices.AbstractSymbolDisplayService : object {
    protected IAnonymousTypeDisplayService AnonymousTypeDisplayService;
    protected AbstractSymbolDisplayService(IAnonymousTypeDisplayService anonymousTypeDisplayService);
    protected abstract virtual AbstractSymbolDescriptionBuilder CreateDescriptionBuilder(Workspace workspace, SemanticModel semanticModel, int position, CancellationToken cancellationToken);
    public sealed virtual Task`1<string> ToDescriptionStringAsync(Workspace workspace, SemanticModel semanticModel, int position, ISymbol symbol, SymbolDescriptionGroups groups, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.LanguageServices.AbstractSymbolDisplayService/<ToDescriptionStringAsync>d__5")]
public sealed virtual Task`1<string> ToDescriptionStringAsync(Workspace workspace, SemanticModel semanticModel, int position, ImmutableArray`1<ISymbol> symbols, SymbolDescriptionGroups groups, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.LanguageServices.AbstractSymbolDisplayService/<ToDescriptionPartsAsync>d__6")]
public sealed virtual Task`1<ImmutableArray`1<SymbolDisplayPart>> ToDescriptionPartsAsync(Workspace workspace, SemanticModel semanticModel, int position, ImmutableArray`1<ISymbol> symbols, SymbolDescriptionGroups groups, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.LanguageServices.AbstractSymbolDisplayService/<ToDescriptionGroupsAsync>d__7")]
public sealed virtual Task`1<IDictionary`2<SymbolDescriptionGroups, ImmutableArray`1<TaggedText>>> ToDescriptionGroupsAsync(Workspace workspace, SemanticModel semanticModel, int position, ImmutableArray`1<ISymbol> symbols, CancellationToken cancellationToken);
}
[IsReadOnlyAttribute]
internal class Microsoft.CodeAnalysis.LanguageServices.AnonymousTypeDisplayInfo : ValueType {
    [CompilerGeneratedAttribute]
private IDictionary`2<INamedTypeSymbol, string> <AnonymousTypeToName>k__BackingField;
    [CompilerGeneratedAttribute]
private IList`1<SymbolDisplayPart> <AnonymousTypesParts>k__BackingField;
    public IDictionary`2<INamedTypeSymbol, string> AnonymousTypeToName { get; }
    public IList`1<SymbolDisplayPart> AnonymousTypesParts { get; }
    public AnonymousTypeDisplayInfo(IDictionary`2<INamedTypeSymbol, string> anonymousTypeToName, IList`1<SymbolDisplayPart> anonymousTypesParts);
    [CompilerGeneratedAttribute]
public IDictionary`2<INamedTypeSymbol, string> get_AnonymousTypeToName();
    [CompilerGeneratedAttribute]
public IList`1<SymbolDisplayPart> get_AnonymousTypesParts();
    public IList`1<SymbolDisplayPart> ReplaceAnonymousTypes(IList`1<SymbolDisplayPart> parts);
    public static IList`1<SymbolDisplayPart> ReplaceAnonymousTypes(IList`1<SymbolDisplayPart> parts, IDictionary`2<INamedTypeSymbol, string> anonymousTypeToName);
}
[ExtensionAttribute]
internal static class Microsoft.CodeAnalysis.LanguageServices.IAnonymousTypeDisplayExtensions : object {
    [ExtensionAttribute]
public static IList`1<SymbolDisplayPart> InlineDelegateAnonymousTypes(IAnonymousTypeDisplayService service, IList`1<SymbolDisplayPart> parts, SemanticModel semanticModel, int position);
    private static void ReplaceAnonymousType(IList`1<SymbolDisplayPart> list, INamedTypeSymbol anonymousType, IEnumerable`1<SymbolDisplayPart> parts);
}
[NullableContextAttribute("1")]
internal interface Microsoft.CodeAnalysis.LanguageServices.IAnonymousTypeDisplayService {
    public abstract virtual AnonymousTypeDisplayInfo GetNormalAnonymousTypeDisplayInfo(ISymbol orderSymbol, IEnumerable`1<INamedTypeSymbol> directNormalAnonymousTypeReferences, SemanticModel semanticModel, int position);
    public abstract virtual ImmutableArray`1<SymbolDisplayPart> GetAnonymousTypeParts(INamedTypeSymbol anonymousType, SemanticModel semanticModel, int position);
}
internal interface Microsoft.CodeAnalysis.LanguageServices.ISymbolDisplayService {
    public abstract virtual Task`1<string> ToDescriptionStringAsync(Workspace workspace, SemanticModel semanticModel, int position, ISymbol symbol, SymbolDescriptionGroups groups, CancellationToken cancellationToken);
    public abstract virtual Task`1<string> ToDescriptionStringAsync(Workspace workspace, SemanticModel semanticModel, int position, ImmutableArray`1<ISymbol> symbols, SymbolDescriptionGroups groups, CancellationToken cancellationToken);
    public abstract virtual Task`1<ImmutableArray`1<SymbolDisplayPart>> ToDescriptionPartsAsync(Workspace workspace, SemanticModel semanticModel, int position, ImmutableArray`1<ISymbol> symbols, SymbolDescriptionGroups groups, CancellationToken cancellationToken);
    public abstract virtual Task`1<IDictionary`2<SymbolDescriptionGroups, ImmutableArray`1<TaggedText>>> ToDescriptionGroupsAsync(Workspace workspace, SemanticModel semanticModel, int position, ImmutableArray`1<ISymbol> symbols, CancellationToken cancellationToken);
}
internal interface Microsoft.CodeAnalysis.LanguageServices.ProjectInfoService.IProjectInfoService {
    public abstract virtual bool GeneratedTypesMustBePublic(Project project);
}
[FlagsAttribute]
internal enum Microsoft.CodeAnalysis.LanguageServices.SymbolDescriptionGroups : Enum {
    public int value__;
    public static SymbolDescriptionGroups None;
    public static SymbolDescriptionGroups MainDescription;
    public static SymbolDescriptionGroups AwaitableUsageText;
    public static SymbolDescriptionGroups Documentation;
    public static SymbolDescriptionGroups TypeParameterMap;
    public static SymbolDescriptionGroups AnonymousTypes;
    public static SymbolDescriptionGroups Exceptions;
    public static SymbolDescriptionGroups Captures;
    public static SymbolDescriptionGroups ReturnsDocumentation;
    public static SymbolDescriptionGroups ValueDocumentation;
    public static SymbolDescriptionGroups RemarksDocumentation;
    public static SymbolDescriptionGroups All;
}
internal abstract class Microsoft.CodeAnalysis.MakeFieldReadonly.AbstractMakeFieldReadonlyCodeFixProvider`2 : SyntaxEditorBasedCodeFixProvider {
    public ImmutableArray`1<string> FixableDiagnosticIds { get; }
    internal CodeFixCategory CodeFixCategory { get; }
    public virtual ImmutableArray`1<string> get_FixableDiagnosticIds();
    internal sealed virtual CodeFixCategory get_CodeFixCategory();
    protected abstract virtual SyntaxNode GetInitializerNode(TSymbolSyntax declaration);
    protected abstract virtual ImmutableList`1<TSymbolSyntax> GetVariableDeclarators(TFieldDeclarationSyntax declaration);
    public virtual Task RegisterCodeFixesAsync(CodeFixContext context);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.MakeFieldReadonly.AbstractMakeFieldReadonlyCodeFixProvider`2/<FixAllAsync>d__7")]
protected virtual Task FixAllAsync(Document document, ImmutableArray`1<Diagnostic> diagnostics, SyntaxEditor editor, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.MakeFieldReadonly.AbstractMakeFieldReadonlyCodeFixProvider`2/<MakeFieldReadonlyAsync>d__8")]
private Task MakeFieldReadonlyAsync(Document document, SyntaxEditor editor, List`1<TSymbolSyntax> declarators);
    private static DeclarationModifiers WithReadOnly(DeclarationModifiers modifiers);
}
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
internal class Microsoft.CodeAnalysis.MakeFieldReadonly.MakeFieldReadonlyDiagnosticAnalyzer : AbstractBuiltInCodeStyleDiagnosticAnalyzer {
    public virtual DiagnosticAnalyzerCategory GetAnalyzerCategory();
    protected virtual void InitializeWorker(AnalysisContext context);
    private static bool IsFieldWrite(IFieldReferenceOperation fieldReference, ISymbol owningSymbol);
    private static CodeStyleOption2`1<bool> GetCodeStyleOption(IFieldSymbol field, AnalyzerOptions options, CancellationToken cancellationToken);
    [NullableContextAttribute("1")]
[CompilerGeneratedAttribute]
private void <InitializeWorker>b__2_0(CompilationStartAnalysisContext compilationStartContext);
    [CompilerGeneratedAttribute]
internal static bool <InitializeWorker>g__IsCandidateField|2_5(IFieldSymbol symbol, INamedTypeSymbol threadStaticAttribute);
    [CompilerGeneratedAttribute]
internal static ValueTuple`2<bool, bool> <InitializeWorker>g__ComputeInitialFieldState|2_8(IFieldSymbol field, AnalyzerOptions options, INamedTypeSymbol threadStaticAttribute, CancellationToken cancellationToken);
}
internal abstract class Microsoft.CodeAnalysis.MakeMemberStatic.AbstractMakeMemberStaticCodeFixProvider : SyntaxEditorBasedCodeFixProvider {
    internal CodeFixCategory CodeFixCategory { get; }
    internal sealed virtual CodeFixCategory get_CodeFixCategory();
    public sealed virtual Task RegisterCodeFixesAsync(CodeFixContext context);
    protected sealed virtual Task FixAllAsync(Document document, ImmutableArray`1<Diagnostic> diagnostics, SyntaxEditor editor, CancellationToken cancellationToken);
    protected abstract virtual bool IsValidMemberNode(SyntaxNode node);
}
internal abstract class Microsoft.CodeAnalysis.MakeMethodAsynchronous.AbstractMakeMethodAsynchronousCodeFixProvider : CodeFixProvider {
    private static string AsyncSuffix;
    protected abstract virtual bool IsAsyncSupportingFunctionSyntax(SyntaxNode node);
    protected abstract virtual bool IsAsyncReturnType(ITypeSymbol type, KnownTypes knownTypes);
    protected abstract virtual SyntaxNode AddAsyncTokenAndFixReturnType(bool keepVoid, IMethodSymbol methodSymbolOpt, SyntaxNode node, KnownTypes knownTypes);
    public virtual FixAllProvider GetFixAllProvider();
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.MakeMethodAsynchronous.AbstractMakeMethodAsynchronousCodeFixProvider/<RegisterCodeFixesAsync>d__4")]
public virtual Task RegisterCodeFixesAsync(CodeFixContext context);
    private static bool IsLikelyEntryPointName(string name, Document document);
    protected abstract virtual string GetMakeAsyncTaskFunctionResource();
    protected abstract virtual string GetMakeAsyncVoidFunctionResource();
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.MakeMethodAsynchronous.AbstractMakeMethodAsynchronousCodeFixProvider/<FixNodeAsync>d__9")]
private Task`1<Solution> FixNodeAsync(Document document, Diagnostic diagnostic, bool keepVoid, bool isEntryPoint, CancellationToken cancellationToken);
    private SyntaxNode GetContainingFunction(Diagnostic diagnostic, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.MakeMethodAsynchronous.AbstractMakeMethodAsynchronousCodeFixProvider/<RenameThenAddAsyncTokenAsync>d__11")]
private Task`1<Solution> RenameThenAddAsyncTokenAsync(bool keepVoid, Document document, SyntaxNode node, IMethodSymbol methodSymbol, KnownTypes knownTypes, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.MakeMethodAsynchronous.AbstractMakeMethodAsynchronousCodeFixProvider/<AddAsyncTokenAsync>d__12")]
private Task`1<Solution> AddAsyncTokenAsync(bool keepVoid, Document document, IMethodSymbol methodSymbolOpt, KnownTypes knownTypes, SyntaxNode node, CancellationToken cancellationToken);
    protected static bool IsTaskLike(ITypeSymbol returnType, KnownTypes knownTypes);
    [CompilerGeneratedAttribute]
internal static bool <FixNodeAsync>g__NeedsRename|9_0(AbstractMakeMethodAsynchronousCodeFixProvider this, IMethodSymbol methodSymbol, bool keepVoid, bool isEntryPoint, KnownTypes& knownTypes);
}
internal abstract class Microsoft.CodeAnalysis.MakeMethodSynchronous.AbstractMakeMethodSynchronousCodeFixProvider : CodeFixProvider {
    public static string EquivalenceKey;
    private static string AsyncSuffix;
    private static AbstractMakeMethodSynchronousCodeFixProvider();
    protected abstract virtual bool IsAsyncSupportingFunctionSyntax(SyntaxNode node);
    protected abstract virtual SyntaxNode RemoveAsyncTokenAndFixReturnType(IMethodSymbol methodSymbolOpt, SyntaxNode node, KnownTypes knownTypes);
    public virtual FixAllProvider GetFixAllProvider();
    public virtual Task RegisterCodeFixesAsync(CodeFixContext context);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.MakeMethodSynchronous.AbstractMakeMethodSynchronousCodeFixProvider/<FixNodeAsync>d__6")]
private Task`1<Solution> FixNodeAsync(Document document, Diagnostic diagnostic, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.MakeMethodSynchronous.AbstractMakeMethodSynchronousCodeFixProvider/<RenameThenRemoveAsyncTokenAsync>d__7")]
private Task`1<Solution> RenameThenRemoveAsyncTokenAsync(Document document, SyntaxNode node, IMethodSymbol methodSymbol, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.MakeMethodSynchronous.AbstractMakeMethodSynchronousCodeFixProvider/<RemoveAsyncTokenAsync>d__8")]
private Task`1<Solution> RemoveAsyncTokenAsync(Document document, IMethodSymbol methodSymbolOpt, SyntaxNode node, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.MakeMethodSynchronous.AbstractMakeMethodSynchronousCodeFixProvider/<RemoveAwaitFromCallersAsync>d__9")]
private static Task`1<Solution> RemoveAwaitFromCallersAsync(Document document, SyntaxAnnotation annotation, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.MakeMethodSynchronous.AbstractMakeMethodSynchronousCodeFixProvider/<RemoveAwaitFromCallersAsync>d__10")]
private static Task`1<Solution> RemoveAwaitFromCallersAsync(Solution solution, ImmutableArray`1<ReferenceLocation> locations, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.MakeMethodSynchronous.AbstractMakeMethodSynchronousCodeFixProvider/<RemoveAwaitFromCallersAsync>d__11")]
private static Task`1<Solution> RemoveAwaitFromCallersAsync(Solution currentSolution, IGrouping`2<Document, ReferenceLocation> group, CancellationToken cancellationToken);
    private static void RemoveAwaitFromCallerIfPresent(SyntaxEditor editor, ISyntaxFactsService syntaxFacts, SyntaxNode root, ReferenceLocation referenceLocation, CancellationToken cancellationToken);
}
internal abstract class Microsoft.CodeAnalysis.MakeTypeAbstract.AbstractMakeTypeAbstractCodeFixProvider`1 : SyntaxEditorBasedCodeFixProvider {
    internal CodeFixCategory CodeFixCategory { get; }
    [NullableContextAttribute("2")]
protected abstract virtual bool IsValidRefactoringContext(SyntaxNode node, TTypeDeclarationSyntax& typeDeclaration);
    internal sealed virtual CodeFixCategory get_CodeFixCategory();
    [NullableContextAttribute("1")]
public sealed virtual Task RegisterCodeFixesAsync(CodeFixContext context);
    [NullableContextAttribute("1")]
protected sealed virtual Task FixAllAsync(Document document, ImmutableArray`1<Diagnostic> diagnostics, SyntaxEditor editor, CancellationToken cancellationToken);
}
internal abstract class Microsoft.CodeAnalysis.MetadataAsSource.AbstractMetadataAsSourceService : object {
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.MetadataAsSource.AbstractMetadataAsSourceService/<AddSourceToAsync>d__4")]
public sealed virtual Task`1<Document> AddSourceToAsync(Document document, Compilation symbolCompilation, ISymbol symbol, CancellationToken cancellationToken);
    protected abstract virtual Task`1<Document> AddNullableRegionsAsync(Document document, CancellationToken cancellationToken);
    protected abstract virtual IEnumerable`1<AbstractFormattingRule> GetFormattingRules(Document document);
    protected abstract virtual Task`1<Document> AddAssemblyInfoRegionAsync(Document document, Compilation symbolCompilation, ISymbol symbol, CancellationToken cancellationToken);
    protected abstract virtual Task`1<Document> ConvertDocCommentsToRegularCommentsAsync(Document document, IDocumentationCommentFormattingService docCommentFormattingService, CancellationToken cancellationToken);
    protected abstract virtual ImmutableArray`1<AbstractReducer> GetReducers();
    private static INamespaceOrTypeSymbol CreateCodeGenerationSymbol(Document document, ISymbol symbol);
    private static CodeGenerationOptions CreateCodeGenerationOptions(Location contextLocation, OptionSet options);
}
internal static class Microsoft.CodeAnalysis.MetadataAsSource.DocumentationCommentUtilities : object {
    private static ObjectPool`1<List`1<string>> s_pool;
    private static DocumentationCommentUtilities();
    public static string ExtractXMLFragment(string input, string docCommentPrefix);
}
[NullableContextAttribute("1")]
internal interface Microsoft.CodeAnalysis.MetadataAsSource.IMetadataAsSourceFileService {
    public abstract virtual Task`1<MetadataAsSourceFile> GetGeneratedFileAsync(Project project, ISymbol symbol, bool allowDecompilation, CancellationToken cancellationToken);
    public abstract virtual bool TryAddDocumentToWorkspace(string filePath, SourceTextContainer buffer);
    public abstract virtual bool TryRemoveDocumentFromWorkspace(string filePath);
    public abstract virtual void CleanupGeneratedFiles();
    public abstract virtual bool IsNavigableMetadataSymbol(ISymbol symbol);
    [NullableContextAttribute("2")]
public abstract virtual Workspace TryGetWorkspace();
}
internal interface Microsoft.CodeAnalysis.MetadataAsSource.IMetadataAsSourceService {
    public abstract virtual Task`1<Document> AddSourceToAsync(Document document, Compilation symbolCompilation, ISymbol symbol, CancellationToken cancellationToken);
}
internal class Microsoft.CodeAnalysis.MetadataAsSource.MetadataAsSourceFile : object {
    private string _filePath;
    private Location _identifierLocation;
    private string _documentTitle;
    private string _documentTooltip;
    public string FilePath { get; }
    public Location IdentifierLocation { get; }
    public string DocumentTitle { get; }
    public string DocumentTooltip { get; }
    internal MetadataAsSourceFile(string filePath, Location identifierLocation, string documentTitle, string documentTooltip);
    public string get_FilePath();
    public Location get_IdentifierLocation();
    public string get_DocumentTitle();
    public string get_DocumentTooltip();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExportAttribute("Microsoft.CodeAnalysis.MetadataAsSource.IMetadataAsSourceFileService")]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.MetadataAsSource.MetadataAsSourceFileService : object {
    private SemaphoreSlim _gate;
    private Dictionary`2<UniqueDocumentKey, MetadataAsSourceGeneratedFileInfo> _keyToInformation;
    private Dictionary`2<string, MetadataAsSourceGeneratedFileInfo> _generatedFilenameToInformation;
    private IBidirectionalMap`2<MetadataAsSourceGeneratedFileInfo, DocumentId> _openedDocumentIds;
    [NullableAttribute("2")]
private MetadataAsSourceWorkspace _workspace;
    [NullableAttribute("2")]
private Mutex _mutex;
    [NullableAttribute("2")]
private string _rootTemporaryPathWithGuid;
    private string _rootTemporaryPath;
    private static string CreateMutexName(string directoryName);
    private string GetRootPathWithGuid_NoLock();
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.MetadataAsSource.MetadataAsSourceFileService/<GetGeneratedFileAsync>d__11")]
public sealed virtual Task`1<MetadataAsSourceFile> GetGeneratedFileAsync(Project project, ISymbol symbol, bool allowDecompilation, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.MetadataAsSource.MetadataAsSourceFileService/<RelocateSymbol_NoLockAsync>d__12")]
private Task`1<Location> RelocateSymbol_NoLockAsync(MetadataAsSourceGeneratedFileInfo fileInfo, SymbolKey symbolId, CancellationToken cancellationToken);
    public sealed virtual bool TryAddDocumentToWorkspace(string filePath, SourceTextContainer sourceTextContainer);
    public sealed virtual bool TryRemoveDocumentFromWorkspace(string filePath);
    private void RemoveDocumentFromWorkspace_NoLock(MetadataAsSourceGeneratedFileInfo fileInfo);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.MetadataAsSource.MetadataAsSourceFileService/<GetUniqueDocumentKeyAsync>d__16")]
private static Task`1<UniqueDocumentKey> GetUniqueDocumentKeyAsync(Project project, INamedTypeSymbol topLevelNamedType, bool allowDecompilation, CancellationToken cancellationToken);
    private void InitializeWorkspace(Project project);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.MetadataAsSource.MetadataAsSourceFileService/<MapSymbolAsync>d__18")]
internal Task`1<SymbolMappingResult> MapSymbolAsync(Document document, SymbolKey symbolId, CancellationToken cancellationToken);
    public sealed virtual void CleanupGeneratedFiles();
    private static void TryDeleteFolderWhichContainsReadOnlyFiles(string directoryPath);
    public sealed virtual bool IsNavigableMetadataSymbol(ISymbol symbol);
    [NullableContextAttribute("2")]
public sealed virtual Workspace TryGetWorkspace();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.CodeAnalysis.MetadataAsSource.MetadataAsSourceGeneratedFileInfo : object {
    public ProjectId SourceProjectId;
    public Workspace Workspace;
    public AssemblyIdentity AssemblyIdentity;
    public string LanguageName;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ImmutableArray`1<MetadataReference> References;
    public string TemporaryFilePath;
    [NullableAttribute("2")]
private ParseOptions _parseOptions;
    public static Encoding Encoding { get; }
    public MetadataAsSourceGeneratedFileInfo(string rootPath, Project sourceProject, INamedTypeSymbol topLevelNamedType, bool allowDecompilation);
    public static Encoding get_Encoding();
    public Tuple`2<ProjectInfo, DocumentId> GetProjectInfoAndDocumentId(Workspace workspace, bool loadFileFromDisk);
}
internal class Microsoft.CodeAnalysis.MetadataAsSource.MetadataAsSourceHelpers : object {
    public static string GetAssemblyInfo(IAssemblySymbol assemblySymbol);
    public static string GetAssemblyDisplay(Compilation compilation, IAssemblySymbol assemblySymbol);
    public static INamedTypeSymbol GetTopLevelContainingNamedType(ISymbol symbol);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.MetadataAsSource.MetadataAsSourceHelpers/<GetLocationInGeneratedSourceAsync>d__3")]
public static Task`1<Location> GetLocationInGeneratedSourceAsync(SymbolKey symbolId, Document generatedDocument, CancellationToken cancellationToken);
    private static Location GetFirstSourceLocation(SymbolKeyResolution resolution);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.CodeAnalysis.MetadataAsSource.MetadataAsSourceWorkspace : Workspace {
    public MetadataAsSourceFileService FileService;
    public MetadataAsSourceWorkspace(MetadataAsSourceFileService fileService, HostServices hostServices);
}
[ExportWorkspaceServiceFactoryAttribute("Microsoft.CodeAnalysis.SymbolMapping.ISymbolMappingService", "MetadataAsSource")]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.MetadataAsSource.SymbolMappingServiceFactory : object {
    [NullableContextAttribute("1")]
public sealed virtual IWorkspaceService CreateService(HostWorkspaceServices workspaceServices);
}
internal abstract class Microsoft.CodeAnalysis.MoveDeclarationNearReference.AbstractMoveDeclarationNearReferenceCodeRefactoringProvider`1 : CodeRefactoringProvider {
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.MoveDeclarationNearReference.AbstractMoveDeclarationNearReferenceCodeRefactoringProvider`1/<ComputeRefactoringsAsync>d__1")]
public virtual Task ComputeRefactoringsAsync(CodeRefactoringContext context);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.MoveDeclarationNearReference.AbstractMoveDeclarationNearReferenceCodeRefactoringProvider`1/<MoveDeclarationNearReferenceAsync>d__2")]
private static Task`1<Document> MoveDeclarationNearReferenceAsync(Document document, SyntaxNode statement, CancellationToken cancellationToken);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal abstract class Microsoft.CodeAnalysis.MoveToNamespace.AbstractMoveToNamespaceCodeAction : CodeActionWithOptions {
    private IMoveToNamespaceService _moveToNamespaceService;
    private MoveToNamespaceAnalysisResult _moveToNamespaceAnalysisResult;
    public AbstractMoveToNamespaceCodeAction(IMoveToNamespaceService moveToNamespaceService, MoveToNamespaceAnalysisResult analysisResult);
    public virtual object GetOptions(CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.MoveToNamespace.AbstractMoveToNamespaceCodeAction/<ComputeOperationsAsync>d__4")]
protected virtual Task`1<IEnumerable`1<CodeActionOperation>> ComputeOperationsAsync(object options, CancellationToken cancellationToken);
    private static ImmutableArray`1<CodeActionOperation> CreateRenameOperations(MoveToNamespaceResult moveToNamespaceResult);
    public static AbstractMoveToNamespaceCodeAction Generate(IMoveToNamespaceService changeNamespaceService, MoveToNamespaceAnalysisResult analysisResult);
}
internal abstract class Microsoft.CodeAnalysis.MoveToNamespace.AbstractMoveToNamespaceService`3 : object {
    [CompilerGeneratedAttribute]
private IMoveToNamespaceOptionsService <OptionsService>k__BackingField;
    private static SymbolDisplayFormat QualifiedNamespaceFormat;
    public IMoveToNamespaceOptionsService OptionsService { get; }
    protected AbstractMoveToNamespaceService`3(IMoveToNamespaceOptionsService moveToNamespaceOptionsService);
    private static AbstractMoveToNamespaceService`3();
    protected abstract virtual string GetNamespaceName(SyntaxNode namespaceSyntax);
    protected abstract virtual bool IsContainedInNamespaceDeclaration(TNamespaceDeclarationSyntax namespaceSyntax, int position);
    [CompilerGeneratedAttribute]
public sealed virtual IMoveToNamespaceOptionsService get_OptionsService();
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.MoveToNamespace.AbstractMoveToNamespaceService`3/<GetCodeActionsAsync>d__6")]
public sealed virtual Task`1<ImmutableArray`1<AbstractMoveToNamespaceCodeAction>> GetCodeActionsAsync(Document document, TextSpan span, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.MoveToNamespace.AbstractMoveToNamespaceService`3/<AnalyzeTypeAtPositionAsync>d__7")]
public sealed virtual Task`1<MoveToNamespaceAnalysisResult> AnalyzeTypeAtPositionAsync(Document document, int position, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.MoveToNamespace.AbstractMoveToNamespaceService`3/<TryAnalyzeNamespaceAsync>d__8")]
private Task`1<MoveToNamespaceAnalysisResult> TryAnalyzeNamespaceAsync(Document document, SyntaxNode node, int position, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.MoveToNamespace.AbstractMoveToNamespaceService`3/<TryAnalyzeNamedTypeAsync>d__9")]
private Task`1<MoveToNamespaceAnalysisResult> TryAnalyzeNamedTypeAsync(Document document, SyntaxNode node, CancellationToken cancellationToken);
    private static TNamespaceDeclarationSyntax GetContainingNamespace(TNamedTypeDeclarationSyntax namedTypeSyntax);
    private static int GetNamespaceInSpineCount(SyntaxNode node);
    private static bool ContainsMultipleTypesInSpine(SyntaxNode node);
    public sealed virtual Task`1<MoveToNamespaceResult> MoveToNamespaceAsync(MoveToNamespaceAnalysisResult analysisResult, string targetNamespace, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.MoveToNamespace.AbstractMoveToNamespaceService`3/<GetMemberSymbolsAsync>d__14")]
private static Task`1<ImmutableArray`1<ISymbol>> GetMemberSymbolsAsync(Document document, SyntaxNode container, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.MoveToNamespace.AbstractMoveToNamespaceService`3/<MoveItemsInNamespaceAsync>d__15")]
private static Task`1<MoveToNamespaceResult> MoveItemsInNamespaceAsync(Document document, SyntaxNode container, string targetNamespace, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.MoveToNamespace.AbstractMoveToNamespaceService`3/<MoveTypeToNamespaceAsync>d__16")]
private static Task`1<MoveToNamespaceResult> MoveTypeToNamespaceAsync(Document document, SyntaxNode container, string targetNamespace, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.MoveToNamespace.AbstractMoveToNamespaceService`3/<PropagateChangeToLinkedDocumentsAsync>d__17")]
private static Task`1<Solution> PropagateChangeToLinkedDocumentsAsync(Document document, CancellationToken cancellationToken);
    private static string GetNewSymbolName(ISymbol symbol, string targetNamespace);
    protected static string GetQualifiedName(INamespaceSymbol namespaceSymbol);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.MoveToNamespace.AbstractMoveToNamespaceService`3/<GetNamespacesAsync>d__21")]
private static Task`1<IEnumerable`1<string>> GetNamespacesAsync(Document document, CancellationToken cancellationToken);
    public sealed virtual MoveToNamespaceOptionsResult GetChangeNamespaceOptions(Document document, string defaultNamespace, ImmutableArray`1<string> namespaces);
}
internal interface Microsoft.CodeAnalysis.MoveToNamespace.IMoveToNamespaceOptionsService {
    public abstract virtual MoveToNamespaceOptionsResult GetChangeNamespaceOptions(string defaultNamespace, ImmutableArray`1<string> availableNamespaces, ISyntaxFacts syntaxFactsService);
}
internal interface Microsoft.CodeAnalysis.MoveToNamespace.IMoveToNamespaceService {
    public IMoveToNamespaceOptionsService OptionsService { get; }
    public abstract virtual Task`1<ImmutableArray`1<AbstractMoveToNamespaceCodeAction>> GetCodeActionsAsync(Document document, TextSpan span, CancellationToken cancellationToken);
    public abstract virtual Task`1<MoveToNamespaceAnalysisResult> AnalyzeTypeAtPositionAsync(Document document, int position, CancellationToken cancellationToken);
    public abstract virtual Task`1<MoveToNamespaceResult> MoveToNamespaceAsync(MoveToNamespaceAnalysisResult analysisResult, string targetNamespace, CancellationToken cancellationToken);
    public abstract virtual MoveToNamespaceOptionsResult GetChangeNamespaceOptions(Document document, string defaultNamespace, ImmutableArray`1<string> namespaces);
    public abstract virtual IMoveToNamespaceOptionsService get_OptionsService();
}
internal class Microsoft.CodeAnalysis.MoveToNamespace.MoveToNamespaceAnalysisResult : object {
    public static MoveToNamespaceAnalysisResult Invalid;
    [CompilerGeneratedAttribute]
private bool <CanPerform>k__BackingField;
    [CompilerGeneratedAttribute]
private Document <Document>k__BackingField;
    [CompilerGeneratedAttribute]
private SyntaxNode <SyntaxNode>k__BackingField;
    [CompilerGeneratedAttribute]
private string <OriginalNamespace>k__BackingField;
    [CompilerGeneratedAttribute]
private ContainerType <Container>k__BackingField;
    [CompilerGeneratedAttribute]
private ImmutableArray`1<string> <Namespaces>k__BackingField;
    public bool CanPerform { get; }
    public Document Document { get; }
    public SyntaxNode SyntaxNode { get; }
    public string OriginalNamespace { get; }
    public ContainerType Container { get; }
    public ImmutableArray`1<string> Namespaces { get; }
    public MoveToNamespaceAnalysisResult(Document document, SyntaxNode syntaxNode, string originalNamespace, ImmutableArray`1<string> namespaces, ContainerType container);
    private static MoveToNamespaceAnalysisResult();
    [CompilerGeneratedAttribute]
public bool get_CanPerform();
    [CompilerGeneratedAttribute]
public Document get_Document();
    [CompilerGeneratedAttribute]
public SyntaxNode get_SyntaxNode();
    [CompilerGeneratedAttribute]
public string get_OriginalNamespace();
    [CompilerGeneratedAttribute]
public ContainerType get_Container();
    [CompilerGeneratedAttribute]
public ImmutableArray`1<string> get_Namespaces();
}
[ExportCodeRefactoringProviderAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
[SharedAttribute]
[ExtensionOrderAttribute]
[ExtensionOrderAttribute]
internal class Microsoft.CodeAnalysis.MoveToNamespace.MoveToNamespaceCodeActionProvider : CodeRefactoringProvider {
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.MoveToNamespace.MoveToNamespaceCodeActionProvider/<ComputeRefactoringsAsync>d__1")]
public virtual Task ComputeRefactoringsAsync(CodeRefactoringContext context);
}
internal class Microsoft.CodeAnalysis.MoveToNamespace.MoveToNamespaceOptionsResult : object {
    public static MoveToNamespaceOptionsResult Cancelled;
    [CompilerGeneratedAttribute]
private bool <IsCancelled>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Namespace>k__BackingField;
    public bool IsCancelled { get; }
    public string Namespace { get; }
    public MoveToNamespaceOptionsResult(string namespace);
    private static MoveToNamespaceOptionsResult();
    [CompilerGeneratedAttribute]
public bool get_IsCancelled();
    [CompilerGeneratedAttribute]
public string get_Namespace();
}
internal class Microsoft.CodeAnalysis.MoveToNamespace.MoveToNamespaceResult : object {
    public static MoveToNamespaceResult Failed;
    [CompilerGeneratedAttribute]
private bool <Succeeded>k__BackingField;
    [CompilerGeneratedAttribute]
private Solution <UpdatedSolution>k__BackingField;
    [CompilerGeneratedAttribute]
private Solution <OriginalSolution>k__BackingField;
    [CompilerGeneratedAttribute]
private DocumentId <UpdatedDocumentId>k__BackingField;
    [CompilerGeneratedAttribute]
private ImmutableDictionary`2<string, ISymbol> <NewNameOriginalSymbolMapping>k__BackingField;
    [CompilerGeneratedAttribute]
private string <NewName>k__BackingField;
    public bool Succeeded { get; }
    public Solution UpdatedSolution { get; }
    public Solution OriginalSolution { get; }
    public DocumentId UpdatedDocumentId { get; }
    public ImmutableDictionary`2<string, ISymbol> NewNameOriginalSymbolMapping { get; }
    public string NewName { get; }
    public MoveToNamespaceResult(Solution originalSolution, Solution updatedSolution, DocumentId updatedDocumentId, ImmutableDictionary`2<string, ISymbol> newNameOriginalSymbolMapping);
    private static MoveToNamespaceResult();
    [CompilerGeneratedAttribute]
public bool get_Succeeded();
    [CompilerGeneratedAttribute]
public Solution get_UpdatedSolution();
    [CompilerGeneratedAttribute]
public Solution get_OriginalSolution();
    [CompilerGeneratedAttribute]
public DocumentId get_UpdatedDocumentId();
    [CompilerGeneratedAttribute]
public ImmutableDictionary`2<string, ISymbol> get_NewNameOriginalSymbolMapping();
    [CompilerGeneratedAttribute]
public string get_NewName();
}
internal abstract class Microsoft.CodeAnalysis.NameTupleElement.AbstractNameTupleElementCodeRefactoringProvider`2 : CodeRefactoringProvider {
    protected abstract virtual TArgumentSyntax WithName(TArgumentSyntax argument, string argumentName);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.NameTupleElement.AbstractNameTupleElementCodeRefactoringProvider`2/<ComputeRefactoringsAsync>d__1")]
public virtual Task ComputeRefactoringsAsync(CodeRefactoringContext context);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.NameTupleElement.AbstractNameTupleElementCodeRefactoringProvider`2/<TryGetArgumentInfoAsync>d__2")]
private static Task`1<ValueTuple`3<SyntaxNode, TArgumentSyntax, string>> TryGetArgumentInfoAsync(Document document, TextSpan span, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.NameTupleElement.AbstractNameTupleElementCodeRefactoringProvider`2/<AddNamedElementAsync>d__3")]
private Task`1<Document> AddNamedElementAsync(Document document, TextSpan span, CancellationToken cancellationToken);
}
internal abstract class Microsoft.CodeAnalysis.NavigateTo.AbstractNavigateToSearchService : object {
    [NullableAttribute("1")]
[CompilerGeneratedAttribute]
private IImmutableSet`1<string> <KindsProvided>k__BackingField;
    [TupleElementNamesAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private static ImmutableArray`1<ValueTuple`2<PatternMatchKind, NavigateToMatchKind>> s_kindPairs;
    [NullableAttribute("1")]
public IImmutableSet`1<string> KindsProvided { get; }
    public bool CanFilter { get; }
    private static AbstractNavigateToSearchService();
    [NullableContextAttribute("1")]
[CompilerGeneratedAttribute]
public sealed virtual IImmutableSet`1<string> get_KindsProvided();
    public sealed virtual bool get_CanFilter();
    [NullableContextAttribute("1")]
[AsyncStateMachineAttribute("Microsoft.CodeAnalysis.NavigateTo.AbstractNavigateToSearchService/<SearchDocumentAsync>d__5")]
public sealed virtual Task`1<ImmutableArray`1<INavigateToSearchResult>> SearchDocumentAsync(Document document, string searchPattern, IImmutableSet`1<string> kinds, CancellationToken cancellationToken);
    [NullableContextAttribute("1")]
[AsyncStateMachineAttribute("Microsoft.CodeAnalysis.NavigateTo.AbstractNavigateToSearchService/<SearchProjectAsync>d__6")]
public sealed virtual Task`1<ImmutableArray`1<INavigateToSearchResult>> SearchProjectAsync(Project project, ImmutableArray`1<Document> priorityDocuments, string searchPattern, IImmutableSet`1<string> kinds, CancellationToken cancellationToken);
    private static ValueTask`1<ImmutableArray`1<INavigateToSearchResult>> RehydrateAsync(Optional`1<ImmutableArray`1<SerializableNavigateToSearchResult>> result, Solution solution, CancellationToken cancellationToken);
    public static Task`1<ImmutableArray`1<INavigateToSearchResult>> SearchProjectInCurrentProcessAsync(Project project, ImmutableArray`1<Document> priorityDocuments, string searchPattern, IImmutableSet`1<string> kinds, CancellationToken cancellationToken);
    public static Task`1<ImmutableArray`1<INavigateToSearchResult>> SearchDocumentInCurrentProcessAsync(Document document, string searchPattern, IImmutableSet`1<string> kinds, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.NavigateTo.AbstractNavigateToSearchService/<FindSearchResultsAsync>d__11")]
private static Task`1<ImmutableArray`1<INavigateToSearchResult>> FindSearchResultsAsync(Project project, ImmutableArray`1<Document> priorityDocuments, Document searchDocument, string pattern, IImmutableSet`1<string> kinds, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.NavigateTo.AbstractNavigateToSearchService/<ComputeSearchResultsAsync>d__12")]
private static Task`1<ImmutableArray`1<SearchResult>> ComputeSearchResultsAsync(Project project, ImmutableArray`1<Document> priorityDocuments, Document searchDocument, PatternMatcher nameMatcher, PatternMatcher containerMatcherOpt, DeclaredSymbolInfoKindSet kinds, ArrayBuilder`1<PatternMatch> nameMatches, ArrayBuilder`1<PatternMatch> containerMatches, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.NavigateTo.AbstractNavigateToSearchService/<AddResultIfMatchAsync>d__13")]
private static Task AddResultIfMatchAsync(Document document, DeclaredSymbolInfo declaredSymbolInfo, PatternMatcher nameMatcher, PatternMatcher containerMatcherOpt, DeclaredSymbolInfoKindSet kinds, ArrayBuilder`1<PatternMatch> nameMatches, ArrayBuilder`1<PatternMatch> containerMatches, ArrayBuilder`1<SearchResult> result, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.NavigateTo.AbstractNavigateToSearchService/<ConvertResultAsync>d__14")]
private static Task`1<SearchResult> ConvertResultAsync(DeclaredSymbolInfo declaredSymbolInfo, Document document, ArrayBuilder`1<PatternMatch> nameMatches, ArrayBuilder`1<PatternMatch> containerMatches, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.NavigateTo.AbstractNavigateToSearchService/<GetAdditionalProjectsWithMatchAsync>d__15")]
private static Task`1<ImmutableArray`1<Project>> GetAdditionalProjectsWithMatchAsync(Document document, DeclaredSymbolInfo declaredSymbolInfo, CancellationToken cancellationToken);
    private static string GetItemKind(DeclaredSymbolInfo declaredSymbolInfo);
    private static NavigateToMatchKind GetNavigateToMatchKind(ArrayBuilder`1<PatternMatch> nameMatches);
}
[NullableContextAttribute("1")]
internal interface Microsoft.CodeAnalysis.NavigateTo.INavigateToSearchCallback {
    public abstract virtual void Done(bool isFullyLoaded);
    public abstract virtual Task AddItemAsync(Project project, INavigateToSearchResult result, CancellationToken cancellationToken);
    public abstract virtual void ReportProgress(int current, int maximum);
}
internal interface Microsoft.CodeAnalysis.NavigateTo.INavigateToSearchResult {
    public string AdditionalInformation { get; }
    public string Kind { get; }
    public NavigateToMatchKind MatchKind { get; }
    public bool IsCaseSensitive { get; }
    public string Name { get; }
    public ImmutableArray`1<TextSpan> NameMatchSpans { get; }
    public string SecondarySort { get; }
    public string Summary { get; }
    public INavigableItem NavigableItem { get; }
    public abstract virtual string get_AdditionalInformation();
    public abstract virtual string get_Kind();
    public abstract virtual NavigateToMatchKind get_MatchKind();
    public abstract virtual bool get_IsCaseSensitive();
    public abstract virtual string get_Name();
    public abstract virtual ImmutableArray`1<TextSpan> get_NameMatchSpans();
    public abstract virtual string get_SecondarySort();
    public abstract virtual string get_Summary();
    public abstract virtual INavigableItem get_NavigableItem();
}
[NullableContextAttribute("1")]
internal interface Microsoft.CodeAnalysis.NavigateTo.INavigateToSearchService {
    public IImmutableSet`1<string> KindsProvided { get; }
    public bool CanFilter { get; }
    public abstract virtual IImmutableSet`1<string> get_KindsProvided();
    public abstract virtual bool get_CanFilter();
    public abstract virtual Task`1<ImmutableArray`1<INavigateToSearchResult>> SearchProjectAsync(Project project, ImmutableArray`1<Document> priorityDocuments, string searchPattern, IImmutableSet`1<string> kinds, CancellationToken cancellationToken);
    public abstract virtual Task`1<ImmutableArray`1<INavigateToSearchResult>> SearchDocumentAsync(Document document, string searchPattern, IImmutableSet`1<string> kinds, CancellationToken cancellationToken);
}
[NullableContextAttribute("1")]
[ObsoleteAttribute("Use INavigateToSearchResult instead", "False")]
internal interface Microsoft.CodeAnalysis.NavigateTo.INavigateToSeINavigateToSearchService_RemoveInterfaceAboveAndRenameThisAfterInternalsVisibleToUsersUpdatearchService {
    public IImmutableSet`1<string> KindsProvided { get; }
    public bool CanFilter { get; }
    public abstract virtual IImmutableSet`1<string> get_KindsProvided();
    public abstract virtual bool get_CanFilter();
    public abstract virtual Task`1<ImmutableArray`1<INavigateToSearchResult>> SearchProjectAsync(Project project, ImmutableArray`1<Document> priorityDocuments, string searchPattern, IImmutableSet`1<string> kinds, CancellationToken cancellationToken);
    public abstract virtual Task`1<ImmutableArray`1<INavigateToSearchResult>> SearchDocumentAsync(Document document, string searchPattern, IImmutableSet`1<string> kinds, CancellationToken cancellationToken);
}
[NullableContextAttribute("1")]
internal interface Microsoft.CodeAnalysis.NavigateTo.IRemoteNavigateToSearchService {
    public abstract virtual ValueTask`1<ImmutableArray`1<SerializableNavigateToSearchResult>> SearchDocumentAsync(PinnedSolutionInfo solutionInfo, DocumentId documentId, string searchPattern, ImmutableArray`1<string> kinds, CancellationToken cancellationToken);
    public abstract virtual ValueTask`1<ImmutableArray`1<SerializableNavigateToSearchResult>> SearchProjectAsync(PinnedSolutionInfo solutionInfo, ProjectId projectId, ImmutableArray`1<DocumentId> priorityDocumentIds, string searchPattern, ImmutableArray`1<string> kinds, CancellationToken cancellationToken);
}
internal static class Microsoft.CodeAnalysis.NavigateTo.NavigateToItemKind : object {
    public static string Line;
    public static string File;
    public static string Class;
    public static string Record;
    public static string Structure;
    public static string Interface;
    public static string Delegate;
    public static string Enum;
    public static string Module;
    public static string Constant;
    public static string EnumItem;
    public static string Field;
    public static string Method;
    public static string Property;
    public static string Event;
    public static string OtherSymbol;
}
internal enum Microsoft.CodeAnalysis.NavigateTo.NavigateToMatchKind : Enum {
    public int value__;
    public static NavigateToMatchKind Exact;
    public static NavigateToMatchKind Prefix;
    public static NavigateToMatchKind Substring;
    public static NavigateToMatchKind Regular;
    public static NavigateToMatchKind None;
    public static NavigateToMatchKind CamelCaseExact;
    public static NavigateToMatchKind CamelCasePrefix;
    public static NavigateToMatchKind CamelCaseNonContiguousPrefix;
    public static NavigateToMatchKind CamelCaseSubstring;
    public static NavigateToMatchKind CamelCaseNonContiguousSubstring;
    public static NavigateToMatchKind Fuzzy;
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.CodeAnalysis.NavigateTo.NavigateToSearcher : object {
    private Solution _solution;
    private IAsynchronousOperationListener _asyncListener;
    private INavigateToSearchCallback _callback;
    private string _searchPattern;
    private bool _searchCurrentDocument;
    private IImmutableSet`1<string> _kinds;
    [NullableAttribute("2")]
private Document _currentDocument;
    private ProgressTracker _progress;
    private CancellationToken _cancellationToken;
    public NavigateToSearcher(Solution solution, IAsynchronousOperationListener asyncListener, INavigateToSearchCallback callback, string searchPattern, bool searchCurrentDocument, IImmutableSet`1<string> kinds, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.NavigateTo.NavigateToSearcher/<SearchAsync>d__10")]
internal Task SearchAsync();
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.NavigateTo.NavigateToSearcher/<SearchAllProjectsAsync>d__11")]
private Task SearchAllProjectsAsync();
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.NavigateTo.NavigateToSearcher/<SearchAsync>d__12")]
private Task SearchAsync(Project project, ImmutableArray`1<Document> priorityDocuments, HashSet`1<INavigateToSearchResult> seenItems);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.NavigateTo.NavigateToSearcher/<SearchCoreAsync>d__13")]
private Task SearchCoreAsync(Project project, ImmutableArray`1<Document> priorityDocuments, HashSet`1<INavigateToSearchResult> seenItems);
    private static INavigateToSearchService GetSearchService(Project project);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
internal class Microsoft.CodeAnalysis.NavigateTo.NavigateToSearchResultComparer : object {
    [NullableAttribute("1")]
public static IEqualityComparer`1<INavigateToSearchResult> Instance;
    private static NavigateToSearchResultComparer();
    public sealed virtual bool Equals(INavigateToSearchResult x, INavigateToSearchResult y);
    public sealed virtual int GetHashCode(INavigateToSearchResult obj);
}
internal class Microsoft.CodeAnalysis.Navigation.DefaultDocumentNavigationService : object {
    public sealed virtual bool CanNavigateToSpan(Workspace workspace, DocumentId documentId, TextSpan textSpan, CancellationToken cancellationToken);
    public sealed virtual bool CanNavigateToLineAndOffset(Workspace workspace, DocumentId documentId, int lineNumber, int offset, CancellationToken cancellationToken);
    public sealed virtual bool CanNavigateToPosition(Workspace workspace, DocumentId documentId, int position, int virtualSpace, CancellationToken cancellationToken);
    public sealed virtual bool TryNavigateToSpan(Workspace workspace, DocumentId documentId, TextSpan textSpan, OptionSet options, CancellationToken cancellationToken);
    public sealed virtual bool TryNavigateToLineAndOffset(Workspace workspace, DocumentId documentId, int lineNumber, int offset, OptionSet options, CancellationToken cancellationToken);
    public sealed virtual bool TryNavigateToPosition(Workspace workspace, DocumentId documentId, int position, int virtualSpace, OptionSet options, CancellationToken cancellationToken);
}
[ExportWorkspaceServiceFactoryAttribute("Microsoft.CodeAnalysis.Navigation.IDocumentNavigationService", "Default")]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.Navigation.DefaultDocumentNavigationServiceFactory : object {
    private IDocumentNavigationService _singleton;
    public sealed virtual IWorkspaceService CreateService(HostWorkspaceServices workspaceServices);
}
internal class Microsoft.CodeAnalysis.Navigation.DefaultSymbolNavigationService : object {
    public sealed virtual bool TryNavigateToSymbol(ISymbol symbol, Project project, OptionSet options, CancellationToken cancellationToken);
    public sealed virtual bool TrySymbolNavigationNotify(ISymbol symbol, Project project, CancellationToken cancellationToken);
    public sealed virtual bool WouldNavigateToSymbol(DefinitionItem definitionItem, Solution solution, CancellationToken cancellationToken, String& filePath, Int32& lineNumber, Int32& charOffset);
}
[ExportWorkspaceServiceFactoryAttribute("Microsoft.CodeAnalysis.Navigation.ISymbolNavigationService", "Default")]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.Navigation.DefaultSymbolNavigationServiceFactory : object {
    private ISymbolNavigationService _singleton;
    public sealed virtual IWorkspaceService CreateService(HostWorkspaceServices workspaceServices);
}
internal interface Microsoft.CodeAnalysis.Navigation.IDocumentNavigationService {
    public abstract virtual bool CanNavigateToSpan(Workspace workspace, DocumentId documentId, TextSpan textSpan, CancellationToken cancellationToken);
    public abstract virtual bool CanNavigateToLineAndOffset(Workspace workspace, DocumentId documentId, int lineNumber, int offset, CancellationToken cancellationToken);
    public abstract virtual bool CanNavigateToPosition(Workspace workspace, DocumentId documentId, int position, int virtualSpace, CancellationToken cancellationToken);
    public abstract virtual bool TryNavigateToSpan(Workspace workspace, DocumentId documentId, TextSpan textSpan, OptionSet options, CancellationToken cancellationToken);
    public abstract virtual bool TryNavigateToLineAndOffset(Workspace workspace, DocumentId documentId, int lineNumber, int offset, OptionSet options, CancellationToken cancellationToken);
    public abstract virtual bool TryNavigateToPosition(Workspace workspace, DocumentId documentId, int position, int virtualSpace, OptionSet options, CancellationToken cancellationToken);
}
[ExtensionAttribute]
internal static class Microsoft.CodeAnalysis.Navigation.IDocumentNavigationServiceExtensions : object {
    [ExtensionAttribute]
public static bool CanNavigateToPosition(IDocumentNavigationService service, Workspace workspace, DocumentId documentId, int position, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static bool TryNavigateToSpan(IDocumentNavigationService service, Workspace workspace, DocumentId documentId, TextSpan textSpan, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static bool TryNavigateToLineAndOffset(IDocumentNavigationService service, Workspace workspace, DocumentId documentId, int lineNumber, int offset, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static bool TryNavigateToPosition(IDocumentNavigationService service, Workspace workspace, DocumentId documentId, int position, CancellationToken cancellationToken);
}
internal interface Microsoft.CodeAnalysis.Navigation.INavigableItem {
    public Glyph Glyph { get; }
    public ImmutableArray`1<TaggedText> DisplayTaggedParts { get; }
    public bool DisplayFileLocation { get; }
    public bool IsImplicitlyDeclared { get; }
    public Document Document { get; }
    public TextSpan SourceSpan { get; }
    public ImmutableArray`1<INavigableItem> ChildItems { get; }
    public abstract virtual Glyph get_Glyph();
    public abstract virtual ImmutableArray`1<TaggedText> get_DisplayTaggedParts();
    public abstract virtual bool get_DisplayFileLocation();
    public abstract virtual bool get_IsImplicitlyDeclared();
    public abstract virtual Document get_Document();
    public abstract virtual TextSpan get_SourceSpan();
    public abstract virtual ImmutableArray`1<INavigableItem> get_ChildItems();
}
internal interface Microsoft.CodeAnalysis.Navigation.ISymbolNavigationService {
    public abstract virtual bool TryNavigateToSymbol(ISymbol symbol, Project project, OptionSet options, CancellationToken cancellationToken);
    public abstract virtual bool TrySymbolNavigationNotify(ISymbol symbol, Project project, CancellationToken cancellationToken);
    public abstract virtual bool WouldNavigateToSymbol(DefinitionItem definitionItem, Solution solution, CancellationToken cancellationToken, String& filePath, Int32& lineNumber, Int32& charOffset);
}
internal static class Microsoft.CodeAnalysis.Navigation.NavigableItemFactory : object {
    public static INavigableItem GetItemFromSymbolLocation(Solution solution, ISymbol symbol, Location location, Nullable`1<ImmutableArray`1<TaggedText>> displayTaggedParts);
    public static INavigableItem GetItemFromDeclaredSymbolInfo(DeclaredSymbolInfo declaredSymbolInfo, Document document);
    public static ImmutableArray`1<INavigableItem> GetItemsFromPreferredSourceLocations(Solution solution, ISymbol symbol, Nullable`1<ImmutableArray`1<TaggedText>> displayTaggedParts, CancellationToken cancellationToken);
    public static IEnumerable`1<Location> GetPreferredSourceLocations(Solution solution, ISymbol symbol, CancellationToken cancellationToken);
    private static IEnumerable`1<Location> GetPreferredSourceLocations(ISymbol symbol);
}
internal static class Microsoft.CodeAnalysis.Navigation.NavigationOptions : object {
    public static Option2`1<bool> PreferProvisionalTab;
    public static Option2`1<bool> ActivateTab;
    private static NavigationOptions();
}
[ExportOptionProviderAttribute]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.Navigation.NavigationOptionsProvider : object {
    [CompilerGeneratedAttribute]
private ImmutableArray`1<IOption> <Options>k__BackingField;
    public ImmutableArray`1<IOption> Options { get; }
    [CompilerGeneratedAttribute]
public sealed virtual ImmutableArray`1<IOption> get_Options();
}
internal interface Microsoft.CodeAnalysis.Notification.INotificationService {
    public abstract virtual void SendNotification(string message, string title, NotificationSeverity severity);
    public abstract virtual bool ConfirmMessageBox(string message, string title, NotificationSeverity severity);
}
internal interface Microsoft.CodeAnalysis.Notification.INotificationServiceCallback {
    public Action`3<string, string, NotificationSeverity> NotificationCallback { get; public set; }
    public abstract virtual Action`3<string, string, NotificationSeverity> get_NotificationCallback();
    public abstract virtual void set_NotificationCallback(Action`3<string, string, NotificationSeverity> value);
}
internal enum Microsoft.CodeAnalysis.Notification.NotificationSeverity : Enum {
    public int value__;
    public static NotificationSeverity Information;
    public static NotificationSeverity Warning;
    public static NotificationSeverity Error;
}
internal abstract class Microsoft.CodeAnalysis.OrderModifiers.AbstractOrderModifiersCodeFixProvider : SyntaxEditorBasedCodeFixProvider {
    private ISyntaxFacts _syntaxFacts;
    private Option2`1<CodeStyleOption2`1<string>> _option;
    private AbstractOrderModifiersHelpers _helpers;
    protected ImmutableArray`1<string> FixableCompilerErrorIds { get; }
    public ImmutableArray`1<string> FixableDiagnosticIds { get; }
    internal CodeFixCategory CodeFixCategory { get; }
    protected AbstractOrderModifiersCodeFixProvider(ISyntaxFacts syntaxFacts, Option2`1<CodeStyleOption2`1<string>> option, AbstractOrderModifiersHelpers helpers);
    protected abstract virtual ImmutableArray`1<string> get_FixableCompilerErrorIds();
    public sealed virtual ImmutableArray`1<string> get_FixableDiagnosticIds();
    internal sealed virtual CodeFixCategory get_CodeFixCategory();
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.OrderModifiers.AbstractOrderModifiersCodeFixProvider/<RegisterCodeFixesAsync>d__10")]
public virtual Task RegisterCodeFixesAsync(CodeFixContext context);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.OrderModifiers.AbstractOrderModifiersCodeFixProvider/<FixAllAsync>d__11")]
protected virtual Task FixAllAsync(Document document, ImmutableArray`1<Diagnostic> diagnostics, SyntaxEditor editor, CancellationToken cancellationToken);
}
internal abstract class Microsoft.CodeAnalysis.OrderModifiers.AbstractOrderModifiersDiagnosticAnalyzer : AbstractBuiltInCodeStyleDiagnosticAnalyzer {
    private ISyntaxFacts _syntaxFacts;
    private Option2`1<CodeStyleOption2`1<string>> _option;
    private AbstractOrderModifiersHelpers _helpers;
    protected AbstractOrderModifiersDiagnosticAnalyzer(ISyntaxFacts syntaxFacts, Option2`1<CodeStyleOption2`1<string>> option, AbstractOrderModifiersHelpers helpers, string language);
    public virtual DiagnosticAnalyzerCategory GetAnalyzerCategory();
    protected virtual void InitializeWorker(AnalysisContext context);
    private void AnalyzeSyntaxTree(SyntaxTreeAnalysisContext context);
    protected abstract virtual void Recurse(SyntaxTreeAnalysisContext context, Dictionary`2<int, int> preferredOrder, ReportDiagnostic severity, SyntaxNode root);
    protected void CheckModifiers(SyntaxTreeAnalysisContext context, Dictionary`2<int, int> preferredOrder, ReportDiagnostic severity, SyntaxNode memberDeclaration);
}
internal abstract class Microsoft.CodeAnalysis.OrderModifiers.AbstractOrderModifiersHelpers : object {
    private static Char[] s_comma;
    private Tuple`2<string, Dictionary`2<int, int>> _lastParsed;
    private static AbstractOrderModifiersHelpers();
    protected abstract virtual int GetKeywordKind(string trimmed);
    public static bool IsOrdered(Dictionary`2<int, int> preferredOrder, SyntaxTokenList modifiers);
    public bool TryGetOrComputePreferredOrder(string value, Dictionary`2& preferredOrder);
    protected virtual bool TryParse(string value, Dictionary`2& parsed);
}
internal abstract class Microsoft.CodeAnalysis.Organizing.AbstractOrganizingService : object {
    private IEnumerable`1<ISyntaxOrganizer> _organizers;
    protected AbstractOrganizingService(IEnumerable`1<ISyntaxOrganizer> organizers);
    public sealed virtual IEnumerable`1<ISyntaxOrganizer> GetDefaultOrganizers();
    protected abstract virtual Task`1<Document> ProcessAsync(Document document, IEnumerable`1<ISyntaxOrganizer> organizers, CancellationToken cancellationToken);
    public sealed virtual Task`1<Document> OrganizeAsync(Document document, IEnumerable`1<ISyntaxOrganizer> organizers, CancellationToken cancellationToken);
    protected Func`2<SyntaxNode, IEnumerable`1<ISyntaxOrganizer>> GetNodeToOrganizers(IEnumerable`1<ISyntaxOrganizer> organizers);
}
internal interface Microsoft.CodeAnalysis.Organizing.IOrganizingService {
    public abstract virtual IEnumerable`1<ISyntaxOrganizer> GetDefaultOrganizers();
    public abstract virtual Task`1<Document> OrganizeAsync(Document document, IEnumerable`1<ISyntaxOrganizer> organizers, CancellationToken cancellationToken);
}
internal abstract class Microsoft.CodeAnalysis.Organizing.Organizers.AbstractSyntaxNodeOrganizer`1 : object {
    public IEnumerable`1<Type> SyntaxNodeTypes { get; }
    public sealed virtual IEnumerable`1<Type> get_SyntaxNodeTypes();
    public sealed virtual SyntaxNode OrganizeNode(SemanticModel semanticModel, SyntaxNode node, CancellationToken cancellationToken);
    protected abstract virtual TSyntaxNode Organize(TSyntaxNode node, CancellationToken cancellationToken);
}
[MetadataAttributeAttribute]
[AttributeUsageAttribute("4")]
internal class Microsoft.CodeAnalysis.Organizing.Organizers.ExportSyntaxNodeOrganizerAttribute : ExportAttribute {
    [CompilerGeneratedAttribute]
private string <Language>k__BackingField;
    public string Language { get; }
    public ExportSyntaxNodeOrganizerAttribute(string languageName);
    [CompilerGeneratedAttribute]
public string get_Language();
}
internal interface Microsoft.CodeAnalysis.Organizing.Organizers.ISyntaxOrganizer {
    public IEnumerable`1<Type> SyntaxNodeTypes { get; }
    public abstract virtual IEnumerable`1<Type> get_SyntaxNodeTypes();
    public abstract virtual SyntaxNode OrganizeNode(SemanticModel semanticModel, SyntaxNode node, CancellationToken cancellationToken);
}
internal static class Microsoft.CodeAnalysis.Organizing.OrganizingService : object {
    public static Task`1<Document> OrganizeAsync(Document document, IEnumerable`1<ISyntaxOrganizer> organizers, CancellationToken cancellationToken);
}
internal interface Microsoft.CodeAnalysis.PasteTracking.IPasteTrackingService {
    public abstract virtual bool TryGetPastedTextSpan(SourceTextContainer sourceTextContainer, TextSpan& textSpan);
}
internal interface Microsoft.CodeAnalysis.PickMembers.IPickMembersService {
    public abstract virtual PickMembersResult PickMembers(string title, ImmutableArray`1<ISymbol> members, ImmutableArray`1<PickMembersOption> options);
}
internal class Microsoft.CodeAnalysis.PickMembers.PickMembersOption : object {
    [CompilerGeneratedAttribute]
private string <Id>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Title>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <Value>k__BackingField;
    public string Id { get; }
    public string Title { get; }
    public bool Value { get; public set; }
    public PickMembersOption(string id, string title, bool value);
    [CompilerGeneratedAttribute]
public string get_Id();
    [CompilerGeneratedAttribute]
public string get_Title();
    [CompilerGeneratedAttribute]
public bool get_Value();
    [CompilerGeneratedAttribute]
public void set_Value(bool value);
}
internal class Microsoft.CodeAnalysis.PickMembers.PickMembersResult : object {
    public static PickMembersResult Canceled;
    public bool IsCanceled;
    public ImmutableArray`1<ISymbol> Members;
    public ImmutableArray`1<PickMembersOption> Options;
    private PickMembersResult(bool isCanceled);
    public PickMembersResult(ImmutableArray`1<ISymbol> members, ImmutableArray`1<PickMembersOption> options);
    private static PickMembersResult();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal abstract class Microsoft.CodeAnalysis.PopulateSwitch.AbstractPopulateSwitchCodeFixProvider`4 : SyntaxEditorBasedCodeFixProvider {
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private ImmutableArray`1<string> <FixableDiagnosticIds>k__BackingField;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ImmutableArray`1<string> FixableDiagnosticIds { get; }
    internal CodeFixCategory CodeFixCategory { get; }
    protected AbstractPopulateSwitchCodeFixProvider`4(string diagnosticId);
    [CompilerGeneratedAttribute]
public sealed virtual ImmutableArray`1<string> get_FixableDiagnosticIds();
    protected abstract virtual ITypeSymbol GetSwitchType(TSwitchOperation switchStatement);
    protected abstract virtual ICollection`1<ISymbol> GetMissingEnumMembers(TSwitchOperation switchOperation);
    protected abstract virtual TSwitchArmSyntax CreateSwitchArm(SyntaxGenerator generator, Compilation compilation, TMemberAccessExpression caseLabel);
    protected abstract virtual TSwitchArmSyntax CreateDefaultSwitchArm(SyntaxGenerator generator, Compilation compilation);
    protected abstract virtual int InsertPosition(TSwitchOperation switchOperation);
    protected abstract virtual TSwitchSyntax InsertSwitchArms(SyntaxGenerator generator, TSwitchSyntax switchNode, int insertLocation, List`1<TSwitchArmSyntax> newArms);
    protected abstract virtual void FixOneDiagnostic(Document document, SyntaxEditor editor, SemanticModel semanticModel, bool addCases, bool addDefaultCase, bool onlyOneDiagnostic, bool hasMissingCases, bool hasMissingDefaultCase, TSwitchSyntax switchNode, TSwitchOperation switchOperation);
    internal sealed virtual CodeFixCategory get_CodeFixCategory();
    public sealed virtual Task RegisterCodeFixesAsync(CodeFixContext context);
    private Task`1<Document> FixAsync(Document document, Diagnostic diagnostic, bool addCases, bool addDefaultCase, CancellationToken cancellationToken);
    private Task`1<Document> FixAllAsync(Document document, ImmutableArray`1<Diagnostic> diagnostics, bool addCases, bool addDefaultCase, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.PopulateSwitch.AbstractPopulateSwitchCodeFixProvider`4/<FixWithEditorAsync>d__16")]
private Task FixWithEditorAsync(Document document, SyntaxEditor editor, ImmutableArray`1<Diagnostic> diagnostics, bool addCases, bool addDefaultCase, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.PopulateSwitch.AbstractPopulateSwitchCodeFixProvider`4/<FixOneDiagnosticAsync>d__17")]
private Task FixOneDiagnosticAsync(Document document, SyntaxEditor editor, Diagnostic diagnostic, bool addCases, bool addDefaultCase, bool onlyOneDiagnostic, CancellationToken cancellationToken);
    protected TSwitchSyntax UpdateSwitchNode(SyntaxEditor editor, SemanticModel semanticModel, bool addCases, bool addDefaultCase, bool hasMissingCases, bool hasMissingDefaultCase, TSwitchSyntax switchNode, TSwitchOperation switchOperation);
    protected static void AddMissingBraces(Document document, SyntaxNode& root, TSwitchSyntax& switchNode);
    protected virtual Task FixAllAsync(Document document, ImmutableArray`1<Diagnostic> diagnostics, SyntaxEditor editor, CancellationToken cancellationToken);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal abstract class Microsoft.CodeAnalysis.PopulateSwitch.AbstractPopulateSwitchDiagnosticAnalyzer`2 : AbstractBuiltInCodeStyleDiagnosticAnalyzer {
    private static LocalizableString s_localizableTitle;
    private static LocalizableString s_localizableMessage;
    protected OperationKind OperationKind { get; }
    protected AbstractPopulateSwitchDiagnosticAnalyzer`2(string diagnosticId, EnforceOnBuild enforceOnBuild);
    private static AbstractPopulateSwitchDiagnosticAnalyzer`2();
    protected abstract virtual OperationKind get_OperationKind();
    protected abstract virtual ICollection`1<ISymbol> GetMissingEnumMembers(TSwitchOperation operation);
    protected abstract virtual bool HasDefaultCase(TSwitchOperation operation);
    protected abstract virtual Location GetDiagnosticLocation(TSwitchSyntax switchBlock);
    public sealed virtual DiagnosticAnalyzerCategory GetAnalyzerCategory();
    protected sealed virtual void InitializeWorker(AnalysisContext context);
    private void AnalyzeOperation(OperationAnalysisContext context);
    private bool SwitchIsIncomplete(TSwitchOperation operation, Boolean& missingCases, Boolean& missingDefaultCase);
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal abstract class Microsoft.CodeAnalysis.PopulateSwitch.AbstractPopulateSwitchExpressionCodeFixProvider`4 : AbstractPopulateSwitchCodeFixProvider`4<ISwitchExpressionOperation, TSwitchSyntax, TSwitchArmSyntax, TMemberAccessExpressionSyntax> {
    protected sealed virtual void FixOneDiagnostic(Document document, SyntaxEditor editor, SemanticModel semanticModel, bool addCases, bool addDefaultCase, bool onlyOneDiagnostic, bool hasMissingCases, bool hasMissingDefaultCase, TSwitchSyntax switchNode, ISwitchExpressionOperation switchExpression);
    protected sealed virtual ITypeSymbol GetSwitchType(ISwitchExpressionOperation switchExpression);
    protected sealed virtual ICollection`1<ISymbol> GetMissingEnumMembers(ISwitchExpressionOperation switchOperation);
    protected static TExpressionSyntax Exception(SyntaxGenerator generator, Compilation compilation);
    protected sealed virtual int InsertPosition(ISwitchExpressionOperation switchExpression);
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal abstract class Microsoft.CodeAnalysis.PopulateSwitch.AbstractPopulateSwitchExpressionDiagnosticAnalyzer`1 : AbstractPopulateSwitchDiagnosticAnalyzer`2<ISwitchExpressionOperation, TSwitchSyntax> {
    protected OperationKind OperationKind { get; }
    protected sealed virtual OperationKind get_OperationKind();
    protected sealed virtual ICollection`1<ISymbol> GetMissingEnumMembers(ISwitchExpressionOperation operation);
    protected sealed virtual bool HasDefaultCase(ISwitchExpressionOperation operation);
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal abstract class Microsoft.CodeAnalysis.PopulateSwitch.AbstractPopulateSwitchStatementCodeFixProvider`3 : AbstractPopulateSwitchCodeFixProvider`4<ISwitchOperation, TSwitchSyntax, TSwitchArmSyntax, TMemberAccessExpression> {
    protected sealed virtual void FixOneDiagnostic(Document document, SyntaxEditor editor, SemanticModel semanticModel, bool addCases, bool addDefaultCase, bool onlyOneDiagnostic, bool hasMissingCases, bool hasMissingDefaultCase, TSwitchSyntax switchNode, ISwitchOperation switchOperation);
    protected sealed virtual ITypeSymbol GetSwitchType(ISwitchOperation switchOperation);
    protected sealed virtual ICollection`1<ISymbol> GetMissingEnumMembers(ISwitchOperation switchOperation);
    protected sealed virtual TSwitchSyntax InsertSwitchArms(SyntaxGenerator generator, TSwitchSyntax switchNode, int insertLocation, List`1<TSwitchArmSyntax> newArms);
    protected sealed virtual TSwitchArmSyntax CreateDefaultSwitchArm(SyntaxGenerator generator, Compilation compilation);
    protected sealed virtual TSwitchArmSyntax CreateSwitchArm(SyntaxGenerator generator, Compilation compilation, TMemberAccessExpression caseLabel);
    protected sealed virtual int InsertPosition(ISwitchOperation switchStatement);
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal abstract class Microsoft.CodeAnalysis.PopulateSwitch.AbstractPopulateSwitchStatementDiagnosticAnalyzer`1 : AbstractPopulateSwitchDiagnosticAnalyzer`2<ISwitchOperation, TSwitchSyntax> {
    protected OperationKind OperationKind { get; }
    protected sealed virtual OperationKind get_OperationKind();
    protected sealed virtual ICollection`1<ISymbol> GetMissingEnumMembers(ISwitchOperation operation);
    protected sealed virtual bool HasDefaultCase(ISwitchOperation operation);
    protected sealed virtual Location GetDiagnosticLocation(TSwitchSyntax switchBlock);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal static class Microsoft.CodeAnalysis.PopulateSwitch.PopulateSwitchExpressionHelpers : object {
    public static ICollection`1<ISymbol> GetMissingEnumMembers(ISwitchExpressionOperation operation);
    private static bool TryRemoveExistingEnumMembers(ISwitchExpressionOperation operation, Dictionary`2<long, ISymbol> enumMembers);
    public static bool HasDefaultCase(ISwitchExpressionOperation operation);
    public static bool IsDefault(ISwitchExpressionArmOperation arm);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal static class Microsoft.CodeAnalysis.PopulateSwitch.PopulateSwitchStatementHelpers : object {
    public static string MissingCases;
    public static string MissingDefaultCase;
    public static bool HasDefaultCase(ISwitchOperation switchStatement);
    private static bool HasDefaultCase(ISwitchCaseOperation switchCase);
    public static ICollection`1<ISymbol> GetMissingEnumMembers(ISwitchOperation switchStatement);
    private static bool TryRemoveExistingEnumMembers(ISwitchOperation switchStatement, Dictionary`2<long, ISymbol> enumValues);
    public static bool TryGetAllEnumMembers(ITypeSymbol enumType, Dictionary`2<long, ISymbol> enumValues);
}
[ExportCodeFixProviderAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.PreferFrameworkType.PreferFrameworkTypeCodeFixProvider : SyntaxEditorBasedCodeFixProvider {
    [CompilerGeneratedAttribute]
private ImmutableArray`1<string> <FixableDiagnosticIds>k__BackingField;
    public ImmutableArray`1<string> FixableDiagnosticIds { get; }
    internal CodeFixCategory CodeFixCategory { get; }
    [CompilerGeneratedAttribute]
public sealed virtual ImmutableArray`1<string> get_FixableDiagnosticIds();
    internal sealed virtual CodeFixCategory get_CodeFixCategory();
    public virtual Task RegisterCodeFixesAsync(CodeFixContext context);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.PreferFrameworkType.PreferFrameworkTypeCodeFixProvider/<FixAllAsync>d__7")]
protected virtual Task FixAllAsync(Document document, ImmutableArray`1<Diagnostic> diagnostics, SyntaxEditor editor, CancellationToken cancellationToken);
    protected virtual bool IncludeDiagnosticDuringFixAll(Diagnostic diagnostic);
}
internal static class Microsoft.CodeAnalysis.PreferFrameworkType.PreferFrameworkTypeConstants : object {
    public static string PreferFrameworkType;
    public static ImmutableDictionary`2<string, string> Properties;
    private static PreferFrameworkTypeConstants();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal abstract class Microsoft.CodeAnalysis.PreferFrameworkType.PreferFrameworkTypeDiagnosticAnalyzerBase`3 : AbstractBuiltInCodeStyleDiagnosticAnalyzer {
    private static PerLanguageOption2`1<CodeStyleOption2`1<bool>> GetOptionForDeclarationContext { get; }
    private static PerLanguageOption2`1<CodeStyleOption2`1<bool>> GetOptionForMemberAccessContext { get; }
    [NullableAttribute("0")]
protected ImmutableArray`1<TSyntaxKind> SyntaxKindsOfInterest { get; }
    private static PerLanguageOption2`1<CodeStyleOption2`1<bool>> get_GetOptionForDeclarationContext();
    private static PerLanguageOption2`1<CodeStyleOption2`1<bool>> get_GetOptionForMemberAccessContext();
    public virtual bool OpenFileOnly(OptionSet options);
    public virtual DiagnosticAnalyzerCategory GetAnalyzerCategory();
    protected abstract virtual string GetLanguageName();
    [NullableContextAttribute("0")]
protected abstract virtual ImmutableArray`1<TSyntaxKind> get_SyntaxKindsOfInterest();
    protected abstract virtual bool IsPredefinedTypeReplaceableWithFrameworkType(TPredefinedTypeSyntax node);
    protected abstract virtual bool IsInMemberAccessOrCrefReferenceContext(TExpressionSyntax node);
    protected sealed virtual void InitializeWorker(AnalysisContext context);
    protected void AnalyzeNode(SyntaxNodeAnalysisContext context);
    private bool ShouldReportDiagnostic(TPredefinedTypeSyntax predefinedTypeNode, SyntaxNodeAnalysisContext context, string language, ReportDiagnostic& severity);
    private static bool IsStylePreferred(SyntaxNodeAnalysisContext context, string language);
    private static bool IsFrameworkTypePreferred(SyntaxNodeAnalysisContext context, PerLanguageOption2`1<CodeStyleOption2`1<bool>> option, string language);
    private static bool OptionSettingPrefersFrameworkType(CodeStyleOption2`1<bool> optionValue, ReportDiagnostic severity);
}
internal interface Microsoft.CodeAnalysis.ProjectManagement.IProjectManagementService {
    public abstract virtual IList`1<string> GetFolders(ProjectId projectId, Workspace workspace);
    public abstract virtual string GetDefaultNamespace(Project project, Workspace workspace);
}
[IsReadOnlyAttribute]
internal class Microsoft.CodeAnalysis.PullMemberUp.MemberAnalysisResult : ValueType {
    public ISymbol Member;
    public bool ChangeOriginalToPublic;
    public bool ChangeOriginalToNonStatic;
    public bool MakeMemberDeclarationAbstract;
    public bool ChangeDestinationTypeToAbstract;
    public bool PullMemberUpNeedsToDoExtraChanges { get; }
    public MemberAnalysisResult(ISymbol member, bool changeOriginalToPublic, bool changeOriginalToNonStatic, bool makeMemberDeclarationAbstract, bool changeDestinationTypeToAbstract);
    public bool get_PullMemberUpNeedsToDoExtraChanges();
}
internal static class Microsoft.CodeAnalysis.PullMemberUp.MemberAndDestinationValidator : object {
    public static bool IsDestinationValid(Solution solution, INamedTypeSymbol destination, CancellationToken cancellationToken);
    public static bool IsMemberValid(ISymbol member);
}
internal class Microsoft.CodeAnalysis.PullMemberUp.PullMembersUpOptions : object {
    public INamedTypeSymbol Destination;
    public ImmutableArray`1<MemberAnalysisResult> MemberAnalysisResults;
    public bool PullUpOperationNeedsToDoExtraChanges;
    public PullMembersUpOptions(INamedTypeSymbol destination, ImmutableArray`1<MemberAnalysisResult> memberAnalysisResults);
}
internal abstract class Microsoft.CodeAnalysis.QualifyMemberAccess.AbstractQualifyMemberAccessCodeFixprovider`2 : SyntaxEditorBasedCodeFixProvider {
    public ImmutableArray`1<string> FixableDiagnosticIds { get; }
    internal CodeFixCategory CodeFixCategory { get; }
    protected abstract virtual string GetTitle();
    public sealed virtual ImmutableArray`1<string> get_FixableDiagnosticIds();
    internal sealed virtual CodeFixCategory get_CodeFixCategory();
    public virtual Task RegisterCodeFixesAsync(CodeFixContext context);
    protected virtual Task FixAllAsync(Document document, ImmutableArray`1<Diagnostic> diagnostics, SyntaxEditor editor, CancellationToken cancellationToken);
    protected abstract virtual TSimpleNameSyntax GetNode(Diagnostic diagnostic, CancellationToken cancellationToken);
}
internal abstract class Microsoft.CodeAnalysis.QualifyMemberAccess.AbstractQualifyMemberAccessDiagnosticAnalyzer`3 : AbstractBuiltInCodeStyleDiagnosticAnalyzer {
    public virtual bool OpenFileOnly(OptionSet options);
    protected abstract virtual string GetLanguageName();
    protected abstract virtual bool CanMemberAccessBeQualified(ISymbol containingSymbol, SyntaxNode node);
    protected abstract virtual bool IsAlreadyQualifiedMemberAccess(TExpressionSyntax node);
    protected virtual void InitializeWorker(AnalysisContext context);
    protected abstract virtual Location GetLocation(IOperation operation);
    public virtual DiagnosticAnalyzerCategory GetAnalyzerCategory();
    private void AnalyzeOperation(OperationAnalysisContext context);
    private void AnalyzeOperation(OperationAnalysisContext context, IOperation operation, IOperation instanceOperation);
    private static bool IsStaticMemberOrIsLocalFunction(IOperation operation);
    [CompilerGeneratedAttribute]
internal static bool <IsStaticMemberOrIsLocalFunction>g__IsStaticMemberOrIsLocalFunctionHelper|10_0(ISymbol symbol);
}
internal static class Microsoft.CodeAnalysis.QualifyMemberAccess.QualifyMembersHelpers : object {
    public static PerLanguageOption2`1<CodeStyleOption2`1<bool>> GetApplicableOptionFromSymbolKind(SymbolKind symbolKind);
    internal static PerLanguageOption2`1<CodeStyleOption2`1<bool>> GetApplicableOptionFromSymbolKind(IOperation operation);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal abstract class Microsoft.CodeAnalysis.QuickInfo.CommonQuickInfoProvider : QuickInfoProvider {
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.QuickInfo.CommonQuickInfoProvider/<GetQuickInfoAsync>d__0")]
public virtual Task`1<QuickInfoItem> GetQuickInfoAsync(QuickInfoContext context);
    protected virtual bool ShouldCheckPreviousToken(SyntaxToken token);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.QuickInfo.CommonQuickInfoProvider/<GetQuickInfoAsync>d__2")]
private Task`1<QuickInfoItem> GetQuickInfoAsync(Document document, SyntaxToken token, int position, CancellationToken cancellationToken);
    protected abstract virtual Task`1<QuickInfoItem> BuildQuickInfoAsync(Document document, SyntaxToken token, CancellationToken cancellationToken);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal abstract class Microsoft.CodeAnalysis.QuickInfo.CommonSemanticQuickInfoProvider : CommonQuickInfoProvider {
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.QuickInfo.CommonSemanticQuickInfoProvider/<BuildQuickInfoAsync>d__0")]
protected virtual Task`1<QuickInfoItem> BuildQuickInfoAsync(Document document, SyntaxToken token, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.QuickInfo.CommonSemanticQuickInfoProvider/<ComputeQuickInfoDataAsync>d__1")]
private Task`1<ValueTuple`3<SemanticModel, TokenInformation, SupportedPlatformData>> ComputeQuickInfoDataAsync(Document document, SyntaxToken token, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.QuickInfo.CommonSemanticQuickInfoProvider/<ComputeFromLinkedDocumentsAsync>d__2")]
private Task`1<ValueTuple`3<SemanticModel, TokenInformation, SupportedPlatformData>> ComputeFromLinkedDocumentsAsync(Document document, ImmutableArray`1<DocumentId> linkedDocumentIds, SyntaxToken token, CancellationToken cancellationToken);
    private static bool HasNoErrors(ImmutableArray`1<ISymbol> symbols);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.QuickInfo.CommonSemanticQuickInfoProvider/<FindTokenInLinkedDocumentAsync>d__4")]
private static Task`1<SyntaxToken> FindTokenInLinkedDocumentAsync(SyntaxToken token, Document linkedDocument, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.QuickInfo.CommonSemanticQuickInfoProvider/<CreateContentAsync>d__5")]
protected static Task`1<QuickInfoItem> CreateContentAsync(Workspace workspace, SyntaxToken token, SemanticModel semanticModel, TokenInformation tokenInformation, SupportedPlatformData supportedPlatforms, CancellationToken cancellationToken);
    private static ImmutableArray`1<TaggedText> GetDocumentationContent(ISymbol documentedSymbol, IDictionary`2<SymbolDescriptionGroups, ImmutableArray`1<TaggedText>> sections, SemanticModel semanticModel, SyntaxToken token, IDocumentationCommentFormattingService formatter, CancellationToken cancellationToken);
    private static ImmutableArray`1<TaggedText> GetRemarksDocumentationContent(Workspace workspace, ISymbol documentedSymbol, IDictionary`2<SymbolDescriptionGroups, ImmutableArray`1<TaggedText>> sections, SemanticModel semanticModel, SyntaxToken token, IDocumentationCommentFormattingService formatter, CancellationToken cancellationToken);
    private static ImmutableArray`1<TaggedText> GetReturnsDocumentationContent(ISymbol documentedSymbol, IDictionary`2<SymbolDescriptionGroups, ImmutableArray`1<TaggedText>> sections, SemanticModel semanticModel, SyntaxToken token, IDocumentationCommentFormattingService formatter, CancellationToken cancellationToken);
    private static ImmutableArray`1<TaggedText> GetValueDocumentationContent(ISymbol documentedSymbol, IDictionary`2<SymbolDescriptionGroups, ImmutableArray`1<TaggedText>> sections, SemanticModel semanticModel, SyntaxToken token, IDocumentationCommentFormattingService formatter, CancellationToken cancellationToken);
    [NullableContextAttribute("2")]
protected abstract virtual bool GetBindableNodeForTokenIndicatingLambda(SyntaxToken token, SyntaxNode& found);
    [NullableContextAttribute("2")]
protected abstract virtual bool GetBindableNodeForTokenIndicatingPossibleIndexerAccess(SyntaxToken token, SyntaxNode& found);
    protected virtual NullableFlowState GetNullabilityAnalysis(Workspace workspace, SemanticModel semanticModel, ISymbol symbol, SyntaxNode node, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.QuickInfo.CommonSemanticQuickInfoProvider/<BindTokenAsync>d__13")]
private Task`1<ValueTuple`2<SemanticModel, TokenInformation>> BindTokenAsync(Document document, SyntaxToken token, CancellationToken cancellationToken);
    private ImmutableArray`1<ISymbol> GetSymbolsFromToken(SyntaxToken token, Workspace workspace, SemanticModel semanticModel, CancellationToken cancellationToken);
    [NullableContextAttribute("2")]
private static bool IsOk(ISymbol symbol);
    private static bool IsAccessible(ISymbol symbol, INamedTypeSymbol within);
    [NullableContextAttribute("0")]
[CompilerGeneratedAttribute]
internal static bool <CreateContentAsync>g__TryGetGroupText|5_0(SymbolDescriptionGroups group, ImmutableArray`1& taggedParts, <>c__DisplayClass5_0& );
    [NullableContextAttribute("0")]
[CompilerGeneratedAttribute]
internal static void <CreateContentAsync>g__AddSection|5_1(string kind, ImmutableArray`1<TaggedText> taggedParts, <>c__DisplayClass5_0& );
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[MetadataAttributeAttribute]
[AttributeUsageAttribute("4")]
internal class Microsoft.CodeAnalysis.QuickInfo.ExportQuickInfoProviderAttribute : ExportAttribute {
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Language>k__BackingField;
    public string Name { get; }
    public string Language { get; }
    public ExportQuickInfoProviderAttribute(string name, string language);
    [CompilerGeneratedAttribute]
public string get_Name();
    [CompilerGeneratedAttribute]
public string get_Language();
}
internal static class Microsoft.CodeAnalysis.QuickInfo.IndentationHelper : object {
    public static ImmutableArray`1<ClassifiedSpan> GetSpansWithAlignedIndentation(SourceText text, ImmutableArray`1<ClassifiedSpan> classifiedSpans, int tabSize);
    private static int DetermineIndentationColumn(SourceText text, ImmutableArray`1<ClassifiedSpan> spans, int tabSize);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.CodeAnalysis.QuickInfo.QuickInfoContext : object {
    [CompilerGeneratedAttribute]
private Document <Document>k__BackingField;
    [CompilerGeneratedAttribute]
private int <Position>k__BackingField;
    [CompilerGeneratedAttribute]
private CancellationToken <CancellationToken>k__BackingField;
    public Document Document { get; }
    public int Position { get; }
    public CancellationToken CancellationToken { get; }
    public QuickInfoContext(Document document, int position, CancellationToken cancellationToken);
    [CompilerGeneratedAttribute]
public Document get_Document();
    [CompilerGeneratedAttribute]
public int get_Position();
    [CompilerGeneratedAttribute]
public CancellationToken get_CancellationToken();
}
public class Microsoft.CodeAnalysis.QuickInfo.QuickInfoItem : object {
    [CompilerGeneratedAttribute]
private TextSpan <Span>k__BackingField;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private ImmutableArray`1<string> <Tags>k__BackingField;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private ImmutableArray`1<QuickInfoSection> <Sections>k__BackingField;
    [CompilerGeneratedAttribute]
private ImmutableArray`1<TextSpan> <RelatedSpans>k__BackingField;
    public TextSpan Span { get; }
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ImmutableArray`1<string> Tags { get; }
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ImmutableArray`1<QuickInfoSection> Sections { get; }
    public ImmutableArray`1<TextSpan> RelatedSpans { get; }
    private QuickInfoItem(TextSpan span, ImmutableArray`1<string> tags, ImmutableArray`1<QuickInfoSection> sections, ImmutableArray`1<TextSpan> relatedSpans);
    [CompilerGeneratedAttribute]
public TextSpan get_Span();
    [CompilerGeneratedAttribute]
public ImmutableArray`1<string> get_Tags();
    [CompilerGeneratedAttribute]
public ImmutableArray`1<QuickInfoSection> get_Sections();
    [CompilerGeneratedAttribute]
public ImmutableArray`1<TextSpan> get_RelatedSpans();
    public static QuickInfoItem Create(TextSpan span, ImmutableArray`1<string> tags, ImmutableArray`1<QuickInfoSection> sections, ImmutableArray`1<TextSpan> relatedSpans);
}
internal static class Microsoft.CodeAnalysis.QuickInfo.QuickInfoOptions : object {
    [NullableAttribute("1")]
public static PerLanguageOption2`1<bool> ShowRemarksInQuickInfo;
    private static QuickInfoOptions();
}
[ExportOptionProviderAttribute]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.QuickInfo.QuickInfoOptionsProvider : object {
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private ImmutableArray`1<IOption> <Options>k__BackingField;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ImmutableArray`1<IOption> Options { get; }
    [CompilerGeneratedAttribute]
public sealed virtual ImmutableArray`1<IOption> get_Options();
}
internal abstract class Microsoft.CodeAnalysis.QuickInfo.QuickInfoProvider : object {
    [NullableContextAttribute("1")]
public abstract virtual Task`1<QuickInfoItem> GetQuickInfoAsync(QuickInfoContext context);
}
internal class Microsoft.CodeAnalysis.QuickInfo.QuickInfoProviderMetadata : OrderableLanguageMetadata {
    [NullableContextAttribute("1")]
public QuickInfoProviderMetadata(IDictionary`2<string, object> data);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal static class Microsoft.CodeAnalysis.QuickInfo.QuickInfoProviderNames : object {
    public static string Semantic;
    public static string Syntactic;
    public static string DiagnosticAnalyzer;
}
public class Microsoft.CodeAnalysis.QuickInfo.QuickInfoSection : object {
    [NullableAttribute("1")]
[CompilerGeneratedAttribute]
private string <Kind>k__BackingField;
    [CompilerGeneratedAttribute]
private ImmutableArray`1<TaggedText> <TaggedParts>k__BackingField;
    [NullableAttribute("2")]
private string _text;
    [NullableAttribute("1")]
public string Kind { get; }
    public ImmutableArray`1<TaggedText> TaggedParts { get; }
    [NullableAttribute("1")]
public string Text { get; }
    private QuickInfoSection(string kind, ImmutableArray`1<TaggedText> taggedParts);
    [NullableContextAttribute("1")]
[CompilerGeneratedAttribute]
public string get_Kind();
    [CompilerGeneratedAttribute]
public ImmutableArray`1<TaggedText> get_TaggedParts();
    public static QuickInfoSection Create(string kind, ImmutableArray`1<TaggedText> taggedParts);
    [NullableContextAttribute("1")]
public string get_Text();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public static class Microsoft.CodeAnalysis.QuickInfo.QuickInfoSectionKinds : object {
    public static string Description;
    public static string DocumentationComments;
    public static string RemarksDocumentationComments;
    public static string ReturnsDocumentationComments;
    public static string ValueDocumentationComments;
    public static string TypeParameters;
    public static string AnonymousTypes;
    public static string Usage;
    public static string Exception;
    public static string Text;
    public static string Captures;
    internal static string NullabilityAnalysis;
}
public abstract class Microsoft.CodeAnalysis.QuickInfo.QuickInfoService : object {
    [NullableContextAttribute("2")]
public static QuickInfoService GetService(Document document);
    [NullableContextAttribute("1")]
public virtual Task`1<QuickInfoItem> GetQuickInfoAsync(Document document, int position, CancellationToken cancellationToken);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal abstract class Microsoft.CodeAnalysis.QuickInfo.QuickInfoServiceWithProviders : QuickInfoService {
    private Workspace _workspace;
    private string _language;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private ImmutableArray`1<QuickInfoProvider> _providers;
    protected QuickInfoServiceWithProviders(Workspace workspace, string language);
    private ImmutableArray`1<QuickInfoProvider> GetProviders();
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.QuickInfo.QuickInfoServiceWithProviders/<GetQuickInfoAsync>d__5")]
public virtual Task`1<QuickInfoItem> GetQuickInfoAsync(Document document, int position, CancellationToken cancellationToken);
    [NullableContextAttribute("0")]
[CompilerGeneratedAttribute]
private bool <GetProviders>b__4_0(Lazy`2<QuickInfoProvider, QuickInfoProviderMetadata> lz);
}
[DataContractAttribute]
internal class Microsoft.CodeAnalysis.Remote.SerializableNavigableItem : object {
    [DataMemberAttribute]
public Glyph Glyph;
    [DataMemberAttribute]
public ImmutableArray`1<TaggedText> DisplayTaggedParts;
    [DataMemberAttribute]
public bool DisplayFileLocation;
    [DataMemberAttribute]
public bool IsImplicitlyDeclared;
    [DataMemberAttribute]
public DocumentId Document;
    [DataMemberAttribute]
public TextSpan SourceSpan;
    [DataMemberAttribute]
public ImmutableArray`1<SerializableNavigableItem> ChildItems;
    public SerializableNavigableItem(Glyph glyph, ImmutableArray`1<TaggedText> displayTaggedParts, bool displayFileLocation, bool isImplicitlyDeclared, DocumentId document, TextSpan sourceSpan, ImmutableArray`1<SerializableNavigableItem> childItems);
    public static SerializableNavigableItem Dehydrate(INavigableItem item);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.Remote.SerializableNavigableItem/<RehydrateAsync>d__9")]
public ValueTask`1<INavigableItem> RehydrateAsync(Solution solution, CancellationToken cancellationToken);
}
[IsReadOnlyAttribute]
[DataContractAttribute]
internal class Microsoft.CodeAnalysis.Remote.SerializableNavigateToSearchResult : ValueType {
    [DataMemberAttribute]
public string AdditionalInformation;
    [DataMemberAttribute]
public string Kind;
    [DataMemberAttribute]
public NavigateToMatchKind MatchKind;
    [DataMemberAttribute]
public bool IsCaseSensitive;
    [DataMemberAttribute]
public string Name;
    [DataMemberAttribute]
public ImmutableArray`1<TextSpan> NameMatchSpans;
    [DataMemberAttribute]
public string SecondarySort;
    [DataMemberAttribute]
public string Summary;
    [DataMemberAttribute]
public SerializableNavigableItem NavigableItem;
    public SerializableNavigateToSearchResult(string additionalInformation, string kind, NavigateToMatchKind matchKind, bool isCaseSensitive, string name, ImmutableArray`1<TextSpan> nameMatchSpans, string secondarySort, string summary, SerializableNavigableItem navigableItem);
    internal static SerializableNavigateToSearchResult Dehydrate(INavigateToSearchResult result);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.Remote.SerializableNavigateToSearchResult/<RehydrateAsync>d__11")]
internal ValueTask`1<INavigateToSearchResult> RehydrateAsync(Solution solution, CancellationToken cancellationToken);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal abstract class Microsoft.CodeAnalysis.RemoveAsyncModifier.AbstractRemoveAsyncModifierCodeFixProvider`2 : SyntaxEditorBasedCodeFixProvider {
    internal CodeFixCategory CodeFixCategory { get; }
    internal sealed virtual CodeFixCategory get_CodeFixCategory();
    protected abstract virtual bool IsAsyncSupportingFunctionSyntax(SyntaxNode node);
    protected abstract virtual SyntaxNode RemoveAsyncModifier(SyntaxGenerator generator, SyntaxNode methodLikeNode);
    protected abstract virtual SyntaxNode ConvertToBlockBody(SyntaxNode node, TExpressionSyntax expressionBody);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.RemoveAsyncModifier.AbstractRemoveAsyncModifierCodeFixProvider`2/<RegisterCodeFixesAsync>d__5")]
public virtual Task RegisterCodeFixesAsync(CodeFixContext context);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.RemoveAsyncModifier.AbstractRemoveAsyncModifierCodeFixProvider`2/<FixAllAsync>d__6")]
protected sealed virtual Task FixAllAsync(Document document, ImmutableArray`1<Diagnostic> diagnostics, SyntaxEditor editor, CancellationToken cancellationToken);
    private static IMethodSymbol GetMethodSymbol(SyntaxNode node, SemanticModel semanticModel, CancellationToken cancellationToken);
    private static bool ShouldOfferFix(ITypeSymbol returnType, KnownTypes knownTypes);
    private static bool IsTaskType(ITypeSymbol returnType, KnownTypes knownTypes);
    private SyntaxNode RemoveAsyncModifier(SyntaxGenerator generator, SyntaxNode node, ITypeSymbol returnType, KnownTypes knownTypes, bool needsReturnStatementAdded);
    private static ControlFlowAnalysis GetControlFlowAnalysis(SyntaxGenerator generator, SemanticModel semanticModel, SyntaxNode node);
    private static SyntaxNode AddReturnStatement(SyntaxGenerator generator, SyntaxNode node);
    private SyntaxNode ChangeReturnStatements(SyntaxGenerator generator, SyntaxNode node, ITypeSymbol returnType, KnownTypes knownTypes);
    private static SyntaxNode GetReturnTaskCompletedTaskStatement(SyntaxGenerator generator, ITypeSymbol returnType, KnownTypes knownTypes);
    private static SyntaxNode WrapExpressionWithTaskFromResult(SyntaxGenerator generator, SyntaxNode expression, ITypeSymbol returnType, KnownTypes knownTypes);
    private static SyntaxNode TypeExpressionForStaticMemberAccess(SyntaxGenerator generator, INamedTypeSymbol typeSymbol);
    [CompilerGeneratedAttribute]
internal static SyntaxNode <TypeExpressionForStaticMemberAccess>g__QualifiedNameToMemberAccess|16_0(int qualifiedNameSyntaxKind, int memberAccessExpressionSyntaxKind, SyntaxNode expression, SyntaxGenerator generator);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal abstract class Microsoft.CodeAnalysis.RemoveRedundantEquality.AbstractRemoveRedundantEqualityDiagnosticAnalyzer : AbstractBuiltInCodeStyleDiagnosticAnalyzer {
    private ISyntaxFacts _syntaxFacts;
    protected AbstractRemoveRedundantEqualityDiagnosticAnalyzer(ISyntaxFacts syntaxFacts);
    public virtual DiagnosticAnalyzerCategory GetAnalyzerCategory();
    protected virtual void InitializeWorker(AnalysisContext context);
    private void AnalyzeBinaryOperator(OperationAnalysisContext context);
    [CompilerGeneratedAttribute]
internal static Nullable`1<bool> <AnalyzeBinaryOperator>g__TryGetLiteralValue|4_0(IOperation operand);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal static class Microsoft.CodeAnalysis.RemoveRedundantEquality.RedundantEqualityConstants : object {
    public static string RedundantSide;
    public static string Left;
    public static string Right;
}
[ExportCodeFixProviderAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.RemoveRedundantEquality.RemoveRedundantEqualityCodeFixProvider : SyntaxEditorBasedCodeFixProvider {
    public ImmutableArray`1<string> FixableDiagnosticIds { get; }
    internal CodeFixCategory CodeFixCategory { get; }
    public virtual ImmutableArray`1<string> get_FixableDiagnosticIds();
    internal virtual CodeFixCategory get_CodeFixCategory();
    public virtual Task RegisterCodeFixesAsync(CodeFixContext context);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.RemoveRedundantEquality.RemoveRedundantEqualityCodeFixProvider/<FixAllAsync>d__6")]
protected virtual Task FixAllAsync(Document document, ImmutableArray`1<Diagnostic> diagnostics, SyntaxEditor editor, CancellationToken cancellationToken);
    [CompilerGeneratedAttribute]
internal static SyntaxNode <FixAllAsync>g__WithElasticTrailingTrivia|6_0(SyntaxNode node);
}
internal abstract class Microsoft.CodeAnalysis.RemoveUnnecessaryCast.AbstractRemoveUnnecessaryCastDiagnosticAnalyzer`2 : AbstractBuiltInCodeStyleDiagnosticAnalyzer {
    protected ImmutableArray`1<TLanguageKindEnum> SyntaxKindsOfInterest { get; }
    protected abstract virtual ImmutableArray`1<TLanguageKindEnum> get_SyntaxKindsOfInterest();
    [NullableContextAttribute("1")]
protected abstract virtual TextSpan GetFadeSpan(TCastExpression node);
    [NullableContextAttribute("1")]
protected abstract virtual bool IsUnnecessaryCast(SemanticModel model, TCastExpression node, CancellationToken cancellationToken);
    public virtual DiagnosticAnalyzerCategory GetAnalyzerCategory();
    [NullableContextAttribute("1")]
protected virtual void InitializeWorker(AnalysisContext context);
    private void AnalyzeSyntax(SyntaxNodeAnalysisContext context);
    [NullableContextAttribute("1")]
private Diagnostic TryRemoveCastExpression(SemanticModel model, TCastExpression node, CancellationToken cancellationToken);
}
internal abstract class Microsoft.CodeAnalysis.RemoveUnnecessaryImports.AbstractRemoveUnnecessaryImportsCodeFixProvider : CodeFixProvider {
    public ImmutableArray`1<string> FixableDiagnosticIds { get; }
    public sealed virtual ImmutableArray`1<string> get_FixableDiagnosticIds();
    public sealed virtual FixAllProvider GetFixAllProvider();
    public sealed virtual Task RegisterCodeFixesAsync(CodeFixContext context);
    protected abstract virtual string GetTitle();
    private static Task`1<Document> RemoveUnnecessaryImportsAsync(Document document, CancellationToken cancellationToken);
}
internal abstract class Microsoft.CodeAnalysis.RemoveUnnecessaryImports.AbstractRemoveUnnecessaryImportsDiagnosticAnalyzer : DiagnosticAnalyzer {
    internal static string DiagnosticFixableId;
    private static DiagnosticDescriptor s_fixableIdDescriptor;
    private DiagnosticDescriptor _unnecessaryClassificationIdDescriptor;
    private DiagnosticDescriptor _classificationIdDescriptor;
    private DiagnosticDescriptor _unnecessaryGeneratedCodeClassificationIdDescriptor;
    private DiagnosticDescriptor _generatedCodeClassificationIdDescriptor;
    protected IUnnecessaryImportsProvider UnnecessaryImportsProvider { get; }
    public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    private static AbstractRemoveUnnecessaryImportsDiagnosticAnalyzer();
    protected abstract virtual LocalizableString GetTitleAndMessageFormatForClassificationIdDescriptor();
    protected abstract virtual ImmutableArray`1<SyntaxNode> MergeImports(ImmutableArray`1<SyntaxNode> unnecessaryImports);
    protected abstract virtual bool IsRegularCommentOrDocComment(SyntaxTrivia trivia);
    protected abstract virtual IUnnecessaryImportsProvider get_UnnecessaryImportsProvider();
    private void EnsureClassificationIdDescriptors();
    public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    public sealed virtual bool OpenFileOnly(OptionSet options);
    public virtual void Initialize(AnalysisContext context);
    private void AnalyzeSemanticModel(SemanticModelAnalysisContext context);
    protected virtual Func`2<SyntaxNode, SyntaxToken> GetLastTokenDelegateForContiguousSpans();
    [IteratorStateMachineAttribute("Microsoft.CodeAnalysis.RemoveUnnecessaryImports.AbstractRemoveUnnecessaryImportsDiagnosticAnalyzer/<CreateClassificationDiagnostics>d__18")]
private static IEnumerable`1<Diagnostic> CreateClassificationDiagnostics(IEnumerable`1<TextSpan> contiguousSpans, SyntaxTree tree, DiagnosticDescriptor descriptor, CancellationToken cancellationToken);
    protected abstract virtual IEnumerable`1<TextSpan> GetFixableDiagnosticSpans(IEnumerable`1<SyntaxNode> nodes, SyntaxTree tree, CancellationToken cancellationToken);
    [IteratorStateMachineAttribute("Microsoft.CodeAnalysis.RemoveUnnecessaryImports.AbstractRemoveUnnecessaryImportsDiagnosticAnalyzer/<CreateFixableDiagnostics>d__20")]
private IEnumerable`1<Diagnostic> CreateFixableDiagnostics(IEnumerable`1<SyntaxNode> nodes, SyntaxTree tree, CancellationToken cancellationToken);
    public sealed virtual DiagnosticAnalyzerCategory GetAnalyzerCategory();
    [CompilerGeneratedAttribute]
internal static bool <AnalyzeSemanticModel>g__ShouldFade|16_0(AnalyzerOptions options, SyntaxTree tree, string language, CancellationToken cancellationToken);
}
internal abstract class Microsoft.CodeAnalysis.RemoveUnnecessaryParentheses.AbstractParenthesesDiagnosticAnalyzer : AbstractBuiltInCodeStyleDiagnosticAnalyzer {
    protected AbstractParenthesesDiagnosticAnalyzer(string descriptorId, EnforceOnBuild enforceOnBuild, LocalizableString title, LocalizableString message, bool isUnnecessary);
    protected static PerLanguageOption2`1<CodeStyleOption2`1<ParenthesesPreference>> GetLanguageOption(PrecedenceKind precedenceKind);
}
internal abstract class Microsoft.CodeAnalysis.RemoveUnnecessaryParentheses.AbstractRemoveUnnecessaryParenthesesCodeFixProvider`1 : SyntaxEditorBasedCodeFixProvider {
    public ImmutableArray`1<string> FixableDiagnosticIds { get; }
    internal CodeFixCategory CodeFixCategory { get; }
    public virtual ImmutableArray`1<string> get_FixableDiagnosticIds();
    internal sealed virtual CodeFixCategory get_CodeFixCategory();
    protected abstract virtual bool CanRemoveParentheses(TParenthesizedExpressionSyntax current, SemanticModel semanticModel);
    public virtual Task RegisterCodeFixesAsync(CodeFixContext context);
    protected virtual Task FixAllAsync(Document document, ImmutableArray`1<Diagnostic> diagnostics, SyntaxEditor editor, CancellationToken cancellationToken);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal abstract class Microsoft.CodeAnalysis.RemoveUnnecessaryParentheses.AbstractRemoveUnnecessaryParenthesesDiagnosticAnalyzer`2 : AbstractParenthesesDiagnosticAnalyzer {
    [NullableContextAttribute("0")]
protected abstract virtual TLanguageKindEnum GetSyntaxKind();
    protected abstract virtual ISyntaxFacts GetSyntaxFacts();
    public sealed virtual DiagnosticAnalyzerCategory GetAnalyzerCategory();
    protected sealed virtual void InitializeWorker(AnalysisContext context);
    protected abstract virtual bool CanRemoveParentheses(TParenthesizedExpressionSyntax parenthesizedExpression, SemanticModel semanticModel, PrecedenceKind& precedence, Boolean& clarifiesPrecedence);
    private void AnalyzeSyntax(SyntaxNodeAnalysisContext context);
    private static Location GetDiagnosticSquiggleLocation(TParenthesizedExpressionSyntax parenthesizedExpression, CancellationToken cancellationToken);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal abstract class Microsoft.CodeAnalysis.RemoveUnnecessarySuppressions.AbstractRemoveUnnecessaryAttributeSuppressionsDiagnosticAnalyzer : AbstractCodeQualityDiagnosticAnalyzer {
    internal static string DocCommentIdKey;
    private static LocalizableResourceString s_localizableTitle;
    private static LocalizableResourceString s_localizableInvalidScopeMessage;
    private static LocalizableResourceString s_localizableInvalidOrMissingTargetMessage;
    private static DiagnosticDescriptor s_invalidScopeDescriptor;
    private static DiagnosticDescriptor s_invalidOrMissingTargetDescriptor;
    private static LocalizableResourceString s_localizableLegacyFormatTitle;
    private static LocalizableResourceString s_localizableLegacyFormatMessage;
    internal static DiagnosticDescriptor LegacyFormatTargetDescriptor;
    private static AbstractRemoveUnnecessaryAttributeSuppressionsDiagnosticAnalyzer();
    protected abstract virtual void RegisterAttributeSyntaxAction(CompilationStartAnalysisContext context, CompilationAnalyzer compilationAnalyzer);
    public sealed virtual DiagnosticAnalyzerCategory GetAnalyzerCategory();
    protected sealed virtual void InitializeWorker(AnalysisContext context);
    [CompilerGeneratedAttribute]
private void <InitializeWorker>b__12_0(CompilationStartAnalysisContext context);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal abstract class Microsoft.CodeAnalysis.RemoveUnnecessarySuppressions.AbstractRemoveUnnecessaryInlineSuppressionsDiagnosticAnalyzer : AbstractCodeQualityDiagnosticAnalyzer {
    private static LocalizableResourceString s_localizableRemoveUnnecessarySuppression;
    internal static DiagnosticDescriptor s_removeUnnecessarySuppressionDescriptor;
    private Lazy`1<ImmutableHashSet`1<int>> _lazySupportedCompilerErrorCodes;
    protected string CompilerErrorCodePrefix { get; }
    protected int CompilerErrorCodeDigitCount { get; }
    protected ISyntaxFacts SyntaxFacts { get; }
    protected ISemanticFacts SemanticFacts { get; }
    private static AbstractRemoveUnnecessaryInlineSuppressionsDiagnosticAnalyzer();
    protected abstract virtual string get_CompilerErrorCodePrefix();
    protected abstract virtual int get_CompilerErrorCodeDigitCount();
    protected abstract virtual ISyntaxFacts get_SyntaxFacts();
    protected abstract virtual ISemanticFacts get_SemanticFacts();
    protected abstract virtual ValueTuple`2<Assembly, string> GetCompilerDiagnosticAnalyzerInfo();
    private ImmutableHashSet`1<int> GetSupportedCompilerErrorCodes();
    public sealed virtual DiagnosticAnalyzerCategory GetAnalyzerCategory();
    protected sealed virtual void InitializeWorker(AnalysisContext context);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.RemoveUnnecessarySuppressions.AbstractRemoveUnnecessaryInlineSuppressionsDiagnosticAnalyzer/<AnalyzeAsync>d__16")]
public sealed virtual Task AnalyzeAsync(SemanticModel semanticModel, Nullable`1<TextSpan> span, CompilationWithAnalyzers compilationWithAnalyzers, Func`2<DiagnosticAnalyzer, ImmutableArray`1<DiagnosticDescriptor>> getSupportedDiagnostics, Action`1<Diagnostic> reportDiagnostic, CancellationToken cancellationToken);
    private bool ProcessPragmaDirectives(SyntaxNode root, Nullable`1<TextSpan> span, PooledDictionary`2<string, List`1<ValueTuple`2<SyntaxTrivia, bool>>> idToPragmasMap, PooledDictionary`2<SyntaxTrivia, bool> pragmasToIsUsedMap, ArrayBuilder`1<ValueTuple`3<SyntaxTrivia, ImmutableArray`1<string>, bool>> sortedPragmasWithIds, PooledHashSet`1<string> compilerDiagnosticIds, ImmutableArray`1<string> userExclusions);
    private bool IsSupportedId(SyntaxNode idNode, String& id, Boolean& isCompilerDiagnosticId);
    private static bool IsSupportedAnalyzerDiagnosticId(string id);
    [NullableContextAttribute("2")]
private static ValueTuple`3<ImmutableArray`1<string>, ImmutableArray`1<string>, bool> ParseUserExclusions(string userExclusions);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.RemoveUnnecessarySuppressions.AbstractRemoveUnnecessaryInlineSuppressionsDiagnosticAnalyzer/<GetReportedDiagnosticsForIdsAsync>d__21")]
private static Task`1<ValueTuple`2<ImmutableArray`1<Diagnostic>, ImmutableArray`1<string>>> GetReportedDiagnosticsForIdsAsync(ImmutableHashSet`1<string> idsToAnalyze, SyntaxNode root, SemanticModel semanticModel, CompilationWithAnalyzers compilationWithAnalyzers, Func`2<DiagnosticAnalyzer, ImmutableArray`1<DiagnosticDescriptor>> getSupportedDiagnostics, PooledHashSet`1<string> compilerDiagnosticIds, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.RemoveUnnecessarySuppressions.AbstractRemoveUnnecessaryInlineSuppressionsDiagnosticAnalyzer/<ProcessReportedDiagnosticsAsync>d__22")]
private static Task ProcessReportedDiagnosticsAsync(ImmutableArray`1<Diagnostic> diagnostics, SyntaxTree tree, CompilationWithAnalyzers compilationWithAnalyzers, PooledDictionary`2<string, List`1<ValueTuple`2<SyntaxTrivia, bool>>> idToPragmasMap, PooledDictionary`2<SyntaxTrivia, bool> pragmasToIsUsedMap, PooledDictionary`2<string, List`1<SyntaxNode>> idToSuppressMessageAttributesMap, PooledDictionary`2<SyntaxNode, bool> suppressMessageAttributesToIsUsedMap, CancellationToken cancellationToken);
    private static void ReportUnnecessarySuppressions(PooledDictionary`2<SyntaxTrivia, bool> pragmasToIsUsedMap, ArrayBuilder`1<ValueTuple`3<SyntaxTrivia, ImmutableArray`1<string>, bool>> sortedPragmasWithIds, PooledDictionary`2<SyntaxNode, bool> suppressMessageAttributesToIsUsedMap, Action`1<Diagnostic> reportDiagnostic, DiagnosticSeverity severity, Compilation compilation);
    private static bool TryGetTogglingPragmaDirective(SyntaxTrivia pragma, ArrayBuilder`1<ValueTuple`3<SyntaxTrivia, ImmutableArray`1<string>, bool>> sortedPragmasWithIds, SyntaxTrivia& togglePragma);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.RemoveUnnecessarySuppressions.AbstractRemoveUnnecessaryInlineSuppressionsDiagnosticAnalyzer/<ProcessSuppressMessageAttributesAsync>d__25")]
private Task`1<bool> ProcessSuppressMessageAttributesAsync(SyntaxNode root, SemanticModel semanticModel, Nullable`1<TextSpan> span, PooledDictionary`2<string, List`1<SyntaxNode>> idToSuppressMessageAttributesMap, PooledDictionary`2<SyntaxNode, bool> suppressMessageAttributesToIsUsedMap, ImmutableArray`1<string> userIdExclusions, ImmutableArray`1<string> userCategoryExclusions, CancellationToken cancellationToken);
    private static bool TryGetSuppressedDiagnosticId(AttributeData attribute, INamedTypeSymbol suppressMessageAttributeType, String& id, String& category);
    [CompilerGeneratedAttribute]
private ImmutableHashSet`1<int> <.ctor>b__3_0();
    [CompilerGeneratedAttribute]
internal static void <GetReportedDiagnosticsForIdsAsync>g__AddAllDiagnostics|21_0(ImmutableDictionary`2<DiagnosticAnalyzer, ImmutableArray`1<Diagnostic>> diagnostics, ArrayBuilder`1<Diagnostic> reportedDiagnostics);
    [CompilerGeneratedAttribute]
internal static void <GetReportedDiagnosticsForIdsAsync>g__AddAllCompilationDiagnosticsForTree|21_1(AnalysisResult analysisResult, SyntaxTree tree, ArrayBuilder`1<Diagnostic> reportedDiagnostics);
    [CompilerGeneratedAttribute]
internal static void <ProcessReportedDiagnosticsAsync>g__ProcessPragmaSuppressions|22_0(Diagnostic diagnostic, SyntaxTree tree, PooledDictionary`2<string, List`1<ValueTuple`2<SyntaxTrivia, bool>>> idToPragmasMap, PooledDictionary`2<SyntaxTrivia, bool> pragmasToIsUsedMap);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.RemoveUnnecessarySuppressions.AbstractRemoveUnnecessaryInlineSuppressionsDiagnosticAnalyzer/<<ProcessReportedDiagnosticsAsync>g__ProcessAttributeSuppressionsAsync|22_1>d")]
[CompilerGeneratedAttribute]
internal static Task <ProcessReportedDiagnosticsAsync>g__ProcessAttributeSuppressionsAsync|22_1(Diagnostic diagnostic, AttributeData attribute, PooledDictionary`2<string, List`1<SyntaxNode>> idToSuppressMessageAttributesMap, PooledDictionary`2<SyntaxNode, bool> suppressMessageAttributesToIsUsedMap, CancellationToken cancellationToken);
    [CompilerGeneratedAttribute]
internal static void <ReportUnnecessarySuppressions>g__AddUnnecessaryPragmaDiagnostics|23_0(ArrayBuilder`1<Diagnostic> diagnosticsBuilder, PooledDictionary`2<SyntaxTrivia, bool> pragmasToIsUsedMap, ArrayBuilder`1<ValueTuple`3<SyntaxTrivia, ImmutableArray`1<string>, bool>> sortedPragmasWithIds, DiagnosticSeverity severity);
    [CompilerGeneratedAttribute]
internal static void <ReportUnnecessarySuppressions>g__AddUnnecessarySuppressMessageAttributeDiagnostics|23_1(ArrayBuilder`1<Diagnostic> diagnosticsBuilder, PooledDictionary`2<SyntaxNode, bool> suppressMessageAttributesToIsUsedMap, DiagnosticSeverity severity);
}
[ExportCodeFixProviderAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.RemoveUnnecessarySuppressions.RemoveUnnecessaryAttributeSuppressionsCodeFixProvider : SyntaxEditorBasedCodeFixProvider {
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ImmutableArray`1<string> FixableDiagnosticIds { get; }
    internal CodeFixCategory CodeFixCategory { get; }
    public virtual ImmutableArray`1<string> get_FixableDiagnosticIds();
    internal virtual CodeFixCategory get_CodeFixCategory();
    [NullableContextAttribute("1")]
[AsyncStateMachineAttribute("Microsoft.CodeAnalysis.RemoveUnnecessarySuppressions.RemoveUnnecessaryAttributeSuppressionsCodeFixProvider/<RegisterCodeFixesAsync>d__5")]
public virtual Task RegisterCodeFixesAsync(CodeFixContext context);
    [NullableContextAttribute("1")]
protected virtual Task FixAllAsync(Document document, ImmutableArray`1<Diagnostic> diagnostics, SyntaxEditor editor, CancellationToken cancellationToken);
}
[ExportCodeFixProviderAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.RemoveUnnecessarySuppressions.RemoveUnnecessaryInlineSuppressionsCodeFixProvider : SyntaxEditorBasedCodeFixProvider {
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ImmutableArray`1<string> FixableDiagnosticIds { get; }
    internal CodeFixCategory CodeFixCategory { get; }
    public virtual ImmutableArray`1<string> get_FixableDiagnosticIds();
    internal virtual CodeFixCategory get_CodeFixCategory();
    [NullableContextAttribute("1")]
[AsyncStateMachineAttribute("Microsoft.CodeAnalysis.RemoveUnnecessarySuppressions.RemoveUnnecessaryInlineSuppressionsCodeFixProvider/<RegisterCodeFixesAsync>d__5")]
public virtual Task RegisterCodeFixesAsync(CodeFixContext context);
    [NullableContextAttribute("1")]
protected virtual Task FixAllAsync(Document document, ImmutableArray`1<Diagnostic> diagnostics, SyntaxEditor editor, CancellationToken cancellationToken);
    [NullableContextAttribute("1")]
[CompilerGeneratedAttribute]
internal static void <FixAllAsync>g__RemoveNode|6_0(Location location, SyntaxEditor editor, HashSet`1<SyntaxNode> processedNodes, ISyntaxFacts syntaxFacts);
}
internal abstract class Microsoft.CodeAnalysis.RemoveUnusedMembers.AbstractRemoveUnusedMembersCodeFixProvider`1 : SyntaxEditorBasedCodeFixProvider {
    public ImmutableArray`1<string> FixableDiagnosticIds { get; }
    internal CodeFixCategory CodeFixCategory { get; }
    public virtual ImmutableArray`1<string> get_FixableDiagnosticIds();
    internal sealed virtual CodeFixCategory get_CodeFixCategory();
    protected abstract virtual void AdjustAndAddAppropriateDeclaratorsToRemove(HashSet`1<TFieldDeclarationSyntax> fieldDeclarators, HashSet`1<SyntaxNode> declarators);
    public virtual Task RegisterCodeFixesAsync(CodeFixContext context);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.RemoveUnusedMembers.AbstractRemoveUnusedMembersCodeFixProvider`1/<FixAllAsync>d__6")]
protected virtual Task FixAllAsync(Document document, ImmutableArray`1<Diagnostic> diagnostics, SyntaxEditor editor, CancellationToken cancellationToken);
    protected static void AdjustAndAddAppropriateDeclaratorsToRemove(SyntaxNode parentDeclaration, IEnumerable`1<SyntaxNode> childDeclarators, HashSet`1<SyntaxNode> declarators);
}
internal abstract class Microsoft.CodeAnalysis.RemoveUnusedMembers.AbstractRemoveUnusedMembersDiagnosticAnalyzer`2 : AbstractCodeQualityDiagnosticAnalyzer {
    private static DiagnosticDescriptor s_removeUnusedMembersRule;
    private static DiagnosticDescriptor s_removeUnreadMembersRule;
    private static AbstractRemoveUnusedMembersDiagnosticAnalyzer`2();
    public virtual DiagnosticAnalyzerCategory GetAnalyzerCategory();
    protected sealed virtual void InitializeWorker(AnalysisContext context);
    protected virtual void HandleNamedTypeSymbolStart(SymbolStartAnalysisContext context, Action`2<ISymbol, ValueUsageInfo> onSymbolUsageFound);
    [NullableContextAttribute("1")]
[CompilerGeneratedAttribute]
private void <InitializeWorker>b__4_0(CompilationStartAnalysisContext compilationStartContext);
}
internal abstract class Microsoft.CodeAnalysis.RemoveUnusedParametersAndValues.AbstractRemoveUnusedParametersAndValuesDiagnosticAnalyzer : AbstractBuiltInCodeStyleDiagnosticAnalyzer {
    public static string DiscardVariableName;
    private static string UnusedValuePreferenceKey;
    private static string IsUnusedLocalAssignmentKey;
    private static string IsRemovableAssignmentKey;
    private static DiagnosticDescriptor s_expressionValueIsUnusedRule;
    private static DiagnosticDescriptor s_valueAssignedIsUnusedRule;
    private static DiagnosticDescriptor s_unusedParameterRule;
    [TupleElementNamesAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private static ImmutableDictionary`2<ValueTuple`3<UnusedValuePreference, bool, bool>, ImmutableDictionary`2<string, string>> s_propertiesMap;
    [CompilerGeneratedAttribute]
private Option2`1<CodeStyleOption2`1<UnusedValuePreference>> <UnusedValueExpressionStatementOption>k__BackingField;
    [CompilerGeneratedAttribute]
private Option2`1<CodeStyleOption2`1<UnusedValuePreference>> <UnusedValueAssignmentOption>k__BackingField;
    private Option2`1<CodeStyleOption2`1<UnusedValuePreference>> UnusedValueExpressionStatementOption { get; }
    private Option2`1<CodeStyleOption2`1<UnusedValuePreference>> UnusedValueAssignmentOption { get; }
    protected AbstractRemoveUnusedParametersAndValuesDiagnosticAnalyzer(Option2`1<CodeStyleOption2`1<UnusedValuePreference>> unusedValueExpressionStatementOption, Option2`1<CodeStyleOption2`1<UnusedValuePreference>> unusedValueAssignmentOption, string language);
    private static AbstractRemoveUnusedParametersAndValuesDiagnosticAnalyzer();
    protected abstract virtual bool IsRecordDeclaration(SyntaxNode node);
    protected abstract virtual Location GetDefinitionLocationToFade(IOperation unusedDefinition);
    protected abstract virtual bool SupportsDiscard(SyntaxTree tree);
    protected abstract virtual bool MethodHasHandlesClause(IMethodSymbol method);
    protected abstract virtual bool IsIfConditionalDirective(SyntaxNode node);
    [CompilerGeneratedAttribute]
private Option2`1<CodeStyleOption2`1<UnusedValuePreference>> get_UnusedValueExpressionStatementOption();
    [CompilerGeneratedAttribute]
private Option2`1<CodeStyleOption2`1<UnusedValuePreference>> get_UnusedValueAssignmentOption();
    protected virtual bool ShouldBailOutFromRemovableAssignmentAnalysis(IOperation unusedSymbolWriteOperation);
    protected abstract virtual bool IsCallStatement(IExpressionStatementOperation expressionStatement);
    protected abstract virtual bool IsExpressionOfExpressionBody(IExpressionStatementOperation expressionStatement);
    private static ImmutableDictionary`2<ValueTuple`3<UnusedValuePreference, bool, bool>, ImmutableDictionary`2<string, string>> CreatePropertiesMap();
    public virtual DiagnosticAnalyzerCategory GetAnalyzerCategory();
    protected sealed virtual void InitializeWorker(AnalysisContext context);
    private bool TryGetOptions(SyntaxTree syntaxTree, string language, AnalyzerOptions analyzerOptions, CancellationToken cancellationToken, Options& options);
    public static bool ShouldReportUnusedParameters(ISymbol symbol, UnusedParametersPreference unusedParametersPreference, ReportDiagnostic unusedParametersSeverity);
    public static bool TryGetUnusedValuePreference(Diagnostic diagnostic, UnusedValuePreference& preference);
    public static bool GetIsUnusedLocalDiagnostic(Diagnostic diagnostic);
    public static bool GetIsRemovableAssignmentDiagnostic(Diagnostic diagnostic);
    [CompilerGeneratedAttribute]
internal static void <CreatePropertiesMap>g__AddEntries|23_0(UnusedValuePreference preference, <>c__DisplayClass23_0& );
    [CompilerGeneratedAttribute]
internal static void <CreatePropertiesMap>g__AddEntries2|23_1(UnusedValuePreference preference, bool isUnusedLocalAssignment, <>c__DisplayClass23_0& );
    [CompilerGeneratedAttribute]
internal static void <CreatePropertiesMap>g__AddEntryCore|23_2(UnusedValuePreference preference, bool isUnusedLocalAssignment, bool isRemovableAssignment, <>c__DisplayClass23_0& );
    [NullableContextAttribute("1")]
[CompilerGeneratedAttribute]
private void <InitializeWorker>b__25_0(CompilationStartAnalysisContext compilationContext);
    [CompilerGeneratedAttribute]
private ValueTuple`2<UnusedValuePreference, ReportDiagnostic> <TryGetOptions>g__GetPreferenceAndSeverity|26_0(Option2`1<CodeStyleOption2`1<UnusedValuePreference>> codeStyleOption, <>c__DisplayClass26_0& );
}
internal abstract class Microsoft.CodeAnalysis.RemoveUnusedParametersAndValues.AbstractRemoveUnusedValuesCodeFixProvider`11 : SyntaxEditorBasedCodeFixProvider {
    private static SyntaxAnnotation s_memberAnnotation;
    private static SyntaxAnnotation s_newLocalDeclarationStatementAnnotation;
    private static SyntaxAnnotation s_unusedLocalDeclarationAnnotation;
    private static SyntaxAnnotation s_existingLocalDeclarationWithoutInitializerAnnotation;
    public ImmutableArray`1<string> FixableDiagnosticIds { get; }
    internal CodeFixCategory CodeFixCategory { get; }
    private static AbstractRemoveUnusedValuesCodeFixProvider`11();
    public sealed virtual ImmutableArray`1<string> get_FixableDiagnosticIds();
    internal sealed virtual CodeFixCategory get_CodeFixCategory();
    protected abstract virtual SyntaxNode TryUpdateNameForFlaggedNode(SyntaxNode node, SyntaxToken newName);
    protected abstract virtual SyntaxToken GetForEachStatementIdentifier(TForEachStatementSyntax node);
    protected abstract virtual TBlockSyntax WrapWithBlockIfNecessary(IEnumerable`1<TStatementSyntax> statements);
    protected abstract virtual void InsertAtStartOfSwitchCaseBlockForDeclarationInCaseLabelOrClause(TSwitchCaseBlockSyntax switchCaseBlock, SyntaxEditor editor, TLocalDeclarationStatementSyntax declarationStatement);
    protected abstract virtual SyntaxNode GetReplacementNodeForCompoundAssignment(SyntaxNode originalCompoundAssignment, SyntaxNode newAssignmentTarget, SyntaxEditor editor, ISyntaxFactsService syntaxFacts);
    protected virtual SyntaxNode TryUpdateParentOfUpdatedNode(SyntaxNode parent, SyntaxNode newNameNode, SyntaxEditor editor, ISyntaxFacts syntaxFacts);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.RemoveUnusedParametersAndValues.AbstractRemoveUnusedValuesCodeFixProvider`11/<RegisterCodeFixesAsync>d__14")]
public sealed virtual Task RegisterCodeFixesAsync(CodeFixContext context);
    private static bool IsForEachIterationVariableDiagnostic(Diagnostic diagnostic, Document document, CancellationToken cancellationToken);
    private static string GetEquivalenceKey(UnusedValuePreference preference, bool isRemovableAssignment);
    private static string GetEquivalenceKey(Diagnostic diagnostic);
    private static bool NeedsToMoveNewLocalDeclarationsNearReference(string diagnosticId);
    protected virtual bool IncludeDiagnosticDuringFixAll(Diagnostic diagnostic, Document document, string equivalenceKey, CancellationToken cancellationToken);
    private static IEnumerable`1<IGrouping`2<SyntaxNode, Diagnostic>> GetDiagnosticsGroupedByMember(ImmutableArray`1<Diagnostic> diagnostics, ISyntaxFactsService syntaxFacts, SyntaxNode root, String& diagnosticId, UnusedValuePreference& preference, Boolean& removeAssignments);
    private static IEnumerable`1<IGrouping`2<SyntaxNode, Diagnostic>> GetDiagnosticsGroupedByMember(ImmutableArray`1<Diagnostic> diagnostics, ISyntaxFactsService syntaxFacts, SyntaxNode root);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.RemoveUnusedParametersAndValues.AbstractRemoveUnusedValuesCodeFixProvider`11/<PreprocessDocumentAsync>d__22")]
private static Task`1<Document> PreprocessDocumentAsync(Document document, ImmutableArray`1<Diagnostic> diagnostics, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.RemoveUnusedParametersAndValues.AbstractRemoveUnusedValuesCodeFixProvider`11/<FixAllAsync>d__23")]
protected sealed virtual Task FixAllAsync(Document document, ImmutableArray`1<Diagnostic> diagnostics, SyntaxEditor editor, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.RemoveUnusedParametersAndValues.AbstractRemoveUnusedValuesCodeFixProvider`11/<FixAllAsync>d__24")]
private Task FixAllAsync(string diagnosticId, IEnumerable`1<Diagnostic> diagnostics, Document document, SemanticModel semanticModel, SyntaxNode root, SyntaxNode containingMemberDeclaration, UnusedValuePreference preference, bool removeAssignments, UniqueVariableNameGenerator<TExpressionSyntax, TStatementSyntax, TBlockSyntax, TExpressionStatementSyntax, TLocalDeclarationStatementSyntax, TVariableDeclaratorSyntax, TForEachStatementSyntax, TSwitchCaseBlockSyntax, TSwitchCaseLabelOrClauseSyntax, TCatchStatementSyntax, TCatchBlockSyntax> nameGenerator, SyntaxEditor editor, ISyntaxFactsService syntaxFacts, CancellationToken cancellationToken);
    private static void FixAllExpressionValueIsUnusedDiagnostics(IOrderedEnumerable`1<Diagnostic> diagnostics, SemanticModel semanticModel, SyntaxNode root, UnusedValuePreference preference, UniqueVariableNameGenerator<TExpressionSyntax, TStatementSyntax, TBlockSyntax, TExpressionStatementSyntax, TLocalDeclarationStatementSyntax, TVariableDeclaratorSyntax, TForEachStatementSyntax, TSwitchCaseBlockSyntax, TSwitchCaseLabelOrClauseSyntax, TCatchStatementSyntax, TCatchBlockSyntax> nameGenerator, SyntaxEditor editor, ISyntaxFactsService syntaxFacts);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.RemoveUnusedParametersAndValues.AbstractRemoveUnusedValuesCodeFixProvider`11/<FixAllValueAssignedIsUnusedDiagnosticsAsync>d__26")]
private Task FixAllValueAssignedIsUnusedDiagnosticsAsync(IOrderedEnumerable`1<Diagnostic> diagnostics, Document document, SemanticModel semanticModel, SyntaxNode root, SyntaxNode containingMemberDeclaration, UnusedValuePreference preference, bool removeAssignments, UniqueVariableNameGenerator<TExpressionSyntax, TStatementSyntax, TBlockSyntax, TExpressionStatementSyntax, TLocalDeclarationStatementSyntax, TVariableDeclaratorSyntax, TForEachStatementSyntax, TSwitchCaseBlockSyntax, TSwitchCaseLabelOrClauseSyntax, TCatchStatementSyntax, TCatchBlockSyntax> nameGenerator, SyntaxEditor editor, ISyntaxFactsService syntaxFacts, CancellationToken cancellationToken);
    protected abstract virtual TLocalDeclarationStatementSyntax GetCandidateLocalDeclarationForRemoval(TVariableDeclaratorSyntax declarator);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.RemoveUnusedParametersAndValues.AbstractRemoveUnusedValuesCodeFixProvider`11/<PostProcessDocumentAsync>d__28")]
private Task`1<SyntaxNode> PostProcessDocumentAsync(Document document, SyntaxNode currentRoot, string diagnosticId, UnusedValuePreference preference, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.RemoveUnusedParametersAndValues.AbstractRemoveUnusedValuesCodeFixProvider`11/<PostProcessDocumentCoreAsync>d__29")]
private static Task`1<SyntaxNode> PostProcessDocumentCoreAsync(Func`4<SyntaxNode, Document, CancellationToken, Task`1<SyntaxNode>> processMemberDeclarationAsync, SyntaxNode currentRoot, Document document, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.RemoveUnusedParametersAndValues.AbstractRemoveUnusedValuesCodeFixProvider`11/<ReplaceDiscardDeclarationsWithAssignmentsAsync>d__30")]
private Task`1<SyntaxNode> ReplaceDiscardDeclarationsWithAssignmentsAsync(SyntaxNode memberDeclaration, Document document, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.RemoveUnusedParametersAndValues.AbstractRemoveUnusedValuesCodeFixProvider`11/<AdjustLocalDeclarationsAsync>d__31")]
private Task`1<SyntaxNode> AdjustLocalDeclarationsAsync(SyntaxNode memberDeclaration, Document document, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.RemoveUnusedParametersAndValues.AbstractRemoveUnusedValuesCodeFixProvider`11/<IsLocalDeclarationWithNoReferencesAsync>d__32")]
private static Task`1<bool> IsLocalDeclarationWithNoReferencesAsync(TLocalDeclarationStatementSyntax declStatement, Document document, CancellationToken cancellationToken);
}
internal abstract class Microsoft.CodeAnalysis.RemoveUnusedVariable.AbstractRemoveUnusedVariableCodeFixProvider`3 : SyntaxEditorBasedCodeFixProvider {
    internal CodeFixCategory CodeFixCategory { get; }
    protected abstract virtual bool IsCatchDeclarationIdentifier(SyntaxToken token);
    protected abstract virtual SyntaxNode GetNodeToRemoveOrReplace(SyntaxNode node);
    protected abstract virtual void RemoveOrReplaceNode(SyntaxEditor editor, SyntaxNode node, ISyntaxFactsService syntaxFacts);
    protected abstract virtual SeparatedSyntaxList`1<SyntaxNode> GetVariables(TLocalDeclarationStatement localDeclarationStatement);
    internal sealed virtual CodeFixCategory get_CodeFixCategory();
    public sealed virtual Task RegisterCodeFixesAsync(CodeFixContext context);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.RemoveUnusedVariable.AbstractRemoveUnusedVariableCodeFixProvider`3/<FixAllAsync>d__7")]
protected virtual Task FixAllAsync(Document document, ImmutableArray`1<Diagnostic> diagnostics, SyntaxEditor syntaxEditor, CancellationToken cancellationToken);
    protected static void RemoveNode(SyntaxEditor editor, SyntaxNode node, ISyntaxFactsService syntaxFacts);
    private static SyntaxRemoveOptions CreateSyntaxRemoveOptions(TLocalDeclarationStatement localDeclaration, ISyntaxFactsService syntaxFacts);
    private void MergeNodesToRemove(HashSet`1<SyntaxNode> nodesToRemove);
}
internal abstract class Microsoft.CodeAnalysis.ReplaceDocCommentTextWithTag.AbstractReplaceDocCommentTextWithTagCodeRefactoringProvider : CodeRefactoringProvider {
    protected abstract virtual bool IsInXMLAttribute(SyntaxToken token);
    protected abstract virtual bool IsKeyword(string text);
    protected abstract virtual bool IsXmlTextToken(SyntaxToken token);
    protected abstract virtual SyntaxNode ParseExpression(string text);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.ReplaceDocCommentTextWithTag.AbstractReplaceDocCommentTextWithTagCodeRefactoringProvider/<ComputeRefactoringsAsync>d__4")]
public virtual Task ComputeRefactoringsAsync(CodeRefactoringContext context);
    private bool TryRegisterSeeCrefTagIfSymbol(CodeRefactoringContext context, SemanticModel semanticModel, SyntaxToken token, TextSpan replacementSpan, CancellationToken cancellationToken);
    private static ISymbol GetEnclosingSymbol(SemanticModel semanticModel, int position, CancellationToken cancellationToken);
    private static void RegisterRefactoring(CodeRefactoringContext context, TextSpan expandedSpan, string replacement);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.ReplaceDocCommentTextWithTag.AbstractReplaceDocCommentTextWithTagCodeRefactoringProvider/<ReplaceTextAsync>d__8")]
private static Task`1<Document> ReplaceTextAsync(Document document, TextSpan span, string replacement, CancellationToken cancellationToken);
    private static TextSpan ExpandSpan(SourceText sourceText, TextSpan span, bool fullyQualifiedName);
    private static bool ShouldExpandSpanForwardOneCharacter(SourceText sourceText, int endExclusive, bool fullyQualifiedName);
    private static bool ShouldExpandSpanBackwardOneCharacter(SourceText sourceText, int startInclusive, bool fullyQualifiedName);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal abstract class Microsoft.CodeAnalysis.ReplaceMethodWithProperty.AbstractReplaceMethodWithPropertyService`1 : object {
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.ReplaceMethodWithProperty.AbstractReplaceMethodWithPropertyService`1/<GetMethodDeclarationAsync>d__0")]
public Task`1<SyntaxNode> GetMethodDeclarationAsync(CodeRefactoringContext context);
    [NullableContextAttribute("2")]
protected static string GetWarning(GetAndSetMethods getAndSetMethods);
    private static bool OverridesMetadataSymbol(IMethodSymbol method);
    protected static TPropertyDeclaration SetLeadingTrivia(ISyntaxFacts syntaxFacts, GetAndSetMethods getAndSetMethods, TPropertyDeclaration property);
    private static void AddParamListTriviaIfNeeded(ISyntaxFacts syntaxFacts, SyntaxNode methodDeclaration, List`1<SyntaxTrivia> finalLeadingTrivia);
}
[IsReadOnlyAttribute]
internal class Microsoft.CodeAnalysis.ReplaceMethodWithProperty.GetAndSetMethods : ValueType {
    public IMethodSymbol GetMethod;
    public IMethodSymbol SetMethod;
    public SyntaxNode GetMethodDeclaration;
    public SyntaxNode SetMethodDeclaration;
    public GetAndSetMethods(IMethodSymbol getMethod, IMethodSymbol setMethod, SyntaxNode getMethodDeclaration, SyntaxNode setMethodDeclaration);
}
internal interface Microsoft.CodeAnalysis.ReplaceMethodWithProperty.IReplaceMethodWithPropertyService {
    public abstract virtual Task`1<SyntaxNode> GetMethodDeclarationAsync(CodeRefactoringContext context);
    public abstract virtual void ReplaceGetReference(SyntaxEditor editor, SyntaxToken nameToken, string propertyName, bool nameChanged);
    public abstract virtual void ReplaceSetReference(SyntaxEditor editor, SyntaxToken nameToken, string propertyName, bool nameChanged);
    public abstract virtual void ReplaceGetMethodWithProperty(DocumentOptionSet documentOptions, ParseOptions parseOptions, SyntaxEditor editor, SemanticModel semanticModel, GetAndSetMethods getAndSetMethods, string propertyName, bool nameChanged);
    public abstract virtual void RemoveSetMethod(SyntaxEditor editor, SyntaxNode setMethodDeclaration);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExportCodeRefactoringProviderAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.ReplaceMethodWithProperty.ReplaceMethodWithPropertyCodeRefactoringProvider : CodeRefactoringProvider {
    private static string GetPrefix;
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.ReplaceMethodWithProperty.ReplaceMethodWithPropertyCodeRefactoringProvider/<ComputeRefactoringsAsync>d__2")]
public virtual Task ComputeRefactoringsAsync(CodeRefactoringContext context);
    private static bool HasGetPrefix(SyntaxToken identifier);
    private static bool HasGetPrefix(string text);
    private static bool HasPrefix(string text, string prefix);
    private static IMethodSymbol FindSetMethod(IMethodSymbol getMethod);
    private static bool IsValidGetMethod(IMethodSymbol getMethod);
    private static bool OverridesMethodFromSystemObject(IMethodSymbol method);
    private static bool IsValidSetMethod(IMethodSymbol setMethod, IMethodSymbol getMethod);
    private static bool IsValidSetMethod(IMethodSymbol setMethod);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.ReplaceMethodWithProperty.ReplaceMethodWithPropertyCodeRefactoringProvider/<ReplaceMethodsWithPropertyAsync>d__11")]
private static Task`1<Solution> ReplaceMethodsWithPropertyAsync(Document document, string propertyName, bool nameChanged, IMethodSymbol getMethod, IMethodSymbol setMethod, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.ReplaceMethodWithProperty.ReplaceMethodWithPropertyCodeRefactoringProvider/<UpdateReferencesAsync>d__12")]
private static Task`1<Solution> UpdateReferencesAsync(Solution updatedSolution, string propertyName, bool nameChanged, ILookup`2<Document, ReferenceLocation> getReferencesByDocument, ILookup`2<Document, ReferenceLocation> setReferencesByDocument, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.ReplaceMethodWithProperty.ReplaceMethodWithPropertyCodeRefactoringProvider/<UpdateReferencesInDocumentAsync>d__13")]
private static Task`1<Solution> UpdateReferencesInDocumentAsync(string propertyName, bool nameChanged, Solution updatedSolution, Document originalDocument, IEnumerable`1<ReferenceLocation> getReferences, IEnumerable`1<ReferenceLocation> setReferences, CancellationToken cancellationToken);
    private static void ReplaceGetReferences(string propertyName, bool nameChanged, IEnumerable`1<ReferenceLocation> getReferences, SyntaxNode root, SyntaxEditor editor, IReplaceMethodWithPropertyService service, CancellationToken cancellationToken);
    private static void ReplaceSetReferences(string propertyName, bool nameChanged, IEnumerable`1<ReferenceLocation> setReferences, SyntaxNode root, SyntaxEditor editor, IReplaceMethodWithPropertyService service, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.ReplaceMethodWithProperty.ReplaceMethodWithPropertyCodeRefactoringProvider/<ReplaceGetMethodsAndRemoveSetMethodsAsync>d__16")]
private static Task`1<Solution> ReplaceGetMethodsAndRemoveSetMethodsAsync(Solution originalSolution, Solution updatedSolution, string propertyName, bool nameChanged, IEnumerable`1<ReferencedSymbol> getMethodReferences, IEnumerable`1<ReferencedSymbol> setMethodReferences, bool updateSetMethod, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.ReplaceMethodWithProperty.ReplaceMethodWithPropertyCodeRefactoringProvider/<ReplaceGetMethodsAndRemoveSetMethodsAsync>d__17")]
private static Task`1<Solution> ReplaceGetMethodsAndRemoveSetMethodsAsync(string propertyName, bool nameChanged, Solution updatedSolution, DocumentId documentId, ValueSet<DocumentId, IMethodSymbol> originalGetDefinitions, ValueSet<DocumentId, IMethodSymbol> originalSetDefinitions, bool updateSetMethod, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.ReplaceMethodWithProperty.ReplaceMethodWithPropertyCodeRefactoringProvider/<GetGetSetPairsAsync>d__18")]
private static Task`1<ImmutableArray`1<GetAndSetMethods>> GetGetSetPairsAsync(Solution updatedSolution, Compilation compilation, DocumentId documentId, ValueSet<DocumentId, IMethodSymbol> originalDefinitions, bool updateSetMethod, CancellationToken cancellationToken);
    private static TSymbol GetSymbolInCurrentCompilation(Compilation compilation, TSymbol originalDefinition, CancellationToken cancellationToken);
    [NullableContextAttribute("2")]
[AsyncStateMachineAttribute("Microsoft.CodeAnalysis.ReplaceMethodWithProperty.ReplaceMethodWithPropertyCodeRefactoringProvider/<GetMethodDeclarationAsync>d__20")]
private static Task`1<SyntaxNode> GetMethodDeclarationAsync(IMethodSymbol method, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.ReplaceMethodWithProperty.ReplaceMethodWithPropertyCodeRefactoringProvider/<GetDefinitionsByDocumentIdAsync>d__21")]
private static Task`1<MultiDictionary`2<DocumentId, IMethodSymbol>> GetDefinitionsByDocumentIdAsync(Solution originalSolution, IEnumerable`1<ReferencedSymbol> referencedSymbols, CancellationToken cancellationToken);
    private static string GetDefinitionIssues(IEnumerable`1<ReferencedSymbol> getMethodReferences);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal abstract class Microsoft.CodeAnalysis.ReplacePropertyWithMethods.AbstractReplacePropertyWithMethodsService`5 : object {
    public abstract virtual SyntaxNode GetPropertyNodeToReplace(SyntaxNode propertyDeclaration);
    public abstract virtual Task`1<ImmutableArray`1<SyntaxNode>> GetReplacementMembersAsync(Document document, IPropertySymbol property, SyntaxNode propertyDeclaration, IFieldSymbol propertyBackingField, string desiredGetMethodName, string desiredSetMethodName, CancellationToken cancellationToken);
    protected abstract virtual TCrefSyntax TryGetCrefSyntax(TIdentifierNameSyntax identifierName);
    protected abstract virtual TCrefSyntax CreateCrefSyntax(TCrefSyntax originalCref, SyntaxToken identifierToken, SyntaxNode parameterType);
    protected abstract virtual TExpressionSyntax UnwrapCompoundAssignment(SyntaxNode compoundAssignment, TExpressionSyntax readExpression);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.ReplacePropertyWithMethods.AbstractReplacePropertyWithMethodsService`5/<GetPropertyDeclarationAsync>d__5")]
public sealed virtual Task`1<SyntaxNode> GetPropertyDeclarationAsync(CodeRefactoringContext context);
    protected static SyntaxNode GetFieldReference(SyntaxGenerator generator, IFieldSymbol propertyBackingField);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.ReplacePropertyWithMethods.AbstractReplacePropertyWithMethodsService`5/<ReplaceReferenceAsync>d__7")]
public sealed virtual Task ReplaceReferenceAsync(Document document, SyntaxEditor editor, SyntaxNode identifierName, IPropertySymbol property, IFieldSymbol propertyBackingField, string desiredGetMethodName, string desiredSetMethodName, CancellationToken cancellationToken);
}
internal interface Microsoft.CodeAnalysis.ReplacePropertyWithMethods.IReplacePropertyWithMethodsService {
    public abstract virtual Task`1<SyntaxNode> GetPropertyDeclarationAsync(CodeRefactoringContext context);
    public abstract virtual Task ReplaceReferenceAsync(Document document, SyntaxEditor editor, SyntaxNode identifierName, IPropertySymbol property, IFieldSymbol propertyBackingField, string desiredGetMethodName, string desiredSetMethodName, CancellationToken cancellationToken);
    public abstract virtual Task`1<ImmutableArray`1<SyntaxNode>> GetReplacementMembersAsync(Document document, IPropertySymbol property, SyntaxNode propertyDeclaration, IFieldSymbol propertyBackingField, string desiredGetMethodName, string desiredSetMethodName, CancellationToken cancellationToken);
    public abstract virtual SyntaxNode GetPropertyNodeToReplace(SyntaxNode propertyDeclaration);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExportCodeRefactoringProviderAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.ReplacePropertyWithMethods.ReplacePropertyWithMethodsCodeRefactoringProvider : CodeRefactoringProvider {
    private static string GetPrefix;
    private static string SetPrefix;
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.ReplacePropertyWithMethods.ReplacePropertyWithMethodsCodeRefactoringProvider/<ComputeRefactoringsAsync>d__3")]
public virtual Task ComputeRefactoringsAsync(CodeRefactoringContext context);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.ReplacePropertyWithMethods.ReplacePropertyWithMethodsCodeRefactoringProvider/<ReplacePropertyWithMethodsAsync>d__4")]
private static Task`1<Solution> ReplacePropertyWithMethodsAsync(Document document, IPropertySymbol propertySymbol, CancellationToken cancellationToken);
    private static ImmutableDictionary`2<IPropertySymbol, IFieldSymbol> CreateDefinitionToBackingFieldMap(IEnumerable`1<ReferencedSymbol> propertyReferences);
    private static bool HasAnyMatchingGetOrSetMethods(IPropertySymbol property, string name);
    private static bool HasAnyMatchingGetMethods(IPropertySymbol property, string name);
    private static bool HasAnyMatchingSetMethods(IPropertySymbol property, string name);
    private static IFieldSymbol GetBackingField(IPropertySymbol property);
    private static string GetDefinitionIssues(IEnumerable`1<ReferencedSymbol> getMethodReferences);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.ReplacePropertyWithMethods.ReplacePropertyWithMethodsCodeRefactoringProvider/<UpdateReferencesAsync>d__11")]
private static Task`1<Solution> UpdateReferencesAsync(Solution updatedSolution, ILookup`2<Document, ValueTuple`2<IPropertySymbol, ReferenceLocation>> referencesByDocument, ImmutableDictionary`2<IPropertySymbol, IFieldSymbol> propertyToBackingField, string desiredGetMethodName, string desiredSetMethodName, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.ReplacePropertyWithMethods.ReplacePropertyWithMethodsCodeRefactoringProvider/<UpdateReferencesInDocumentAsync>d__12")]
private static Task`1<Solution> UpdateReferencesInDocumentAsync(Solution updatedSolution, Document originalDocument, IEnumerable`1<ValueTuple`2<IPropertySymbol, ReferenceLocation>> references, ImmutableDictionary`2<IPropertySymbol, IFieldSymbol> propertyToBackingField, string desiredGetMethodName, string desiredSetMethodName, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.ReplacePropertyWithMethods.ReplacePropertyWithMethodsCodeRefactoringProvider/<ReplaceReferencesAsync>d__13")]
private static Task ReplaceReferencesAsync(Document originalDocument, IEnumerable`1<ValueTuple`2<IPropertySymbol, ReferenceLocation>> references, IDictionary`2<IPropertySymbol, IFieldSymbol> propertyToBackingField, SyntaxNode root, SyntaxEditor editor, IReplacePropertyWithMethodsService service, string desiredGetMethodName, string desiredSetMethodName, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.ReplacePropertyWithMethods.ReplacePropertyWithMethodsCodeRefactoringProvider/<ReplaceDefinitionsWithMethodsAsync>d__14")]
private static Task`1<Solution> ReplaceDefinitionsWithMethodsAsync(Solution originalSolution, Solution updatedSolution, IEnumerable`1<ReferencedSymbol> references, ImmutableDictionary`2<IPropertySymbol, IFieldSymbol> definitionToBackingField, string desiredGetMethodName, string desiredSetMethodName, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.ReplacePropertyWithMethods.ReplacePropertyWithMethodsCodeRefactoringProvider/<GetDefinitionsByDocumentIdAsync>d__15")]
private static Task`1<MultiDictionary`2<DocumentId, IPropertySymbol>> GetDefinitionsByDocumentIdAsync(Solution originalSolution, IEnumerable`1<ReferencedSymbol> referencedSymbols, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.ReplacePropertyWithMethods.ReplacePropertyWithMethodsCodeRefactoringProvider/<ReplaceDefinitionsWithMethodsAsync>d__16")]
private static Task`1<Solution> ReplaceDefinitionsWithMethodsAsync(Solution updatedSolution, DocumentId documentId, ValueSet<DocumentId, IPropertySymbol> originalDefinitions, IDictionary`2<IPropertySymbol, IFieldSymbol> definitionToBackingField, string desiredGetMethodName, string desiredSetMethodName, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.ReplacePropertyWithMethods.ReplacePropertyWithMethodsCodeRefactoringProvider/<GetCurrentPropertiesAsync>d__17")]
private static Task`1<ImmutableArray`1<ValueTuple`2<IPropertySymbol, SyntaxNode>>> GetCurrentPropertiesAsync(Solution updatedSolution, Compilation compilation, DocumentId documentId, ValueSet<DocumentId, IPropertySymbol> originalDefinitions, CancellationToken cancellationToken);
    [NullableContextAttribute("2")]
[AsyncStateMachineAttribute("Microsoft.CodeAnalysis.ReplacePropertyWithMethods.ReplacePropertyWithMethodsCodeRefactoringProvider/<GetPropertyDeclarationAsync>d__18")]
private static Task`1<SyntaxNode> GetPropertyDeclarationAsync(IPropertySymbol property, CancellationToken cancellationToken);
    private static TSymbol GetSymbolInCurrentCompilation(Compilation compilation, TSymbol originalDefinition, CancellationToken cancellationToken);
}
internal static class Microsoft.CodeAnalysis.RoslynAssemblyHelper : object {
    public static bool HasRoslynPublicKey(object source);
}
internal interface Microsoft.CodeAnalysis.Scripting.IScriptEnvironmentService {
    public string BaseDirectory { get; }
    public ImmutableArray`1<string> MetadataReferenceSearchPaths { get; }
    public ImmutableArray`1<string> SourceReferenceSearchPaths { get; }
    public abstract virtual string get_BaseDirectory();
    public abstract virtual ImmutableArray`1<string> get_MetadataReferenceSearchPaths();
    public abstract virtual ImmutableArray`1<string> get_SourceReferenceSearchPaths();
}
[ExportWorkspaceServiceAttribute("Microsoft.CodeAnalysis.Shared.IDocumentSupportsFeatureService", "Default")]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.Shared.DefaultDocumentSupportsFeatureService : object {
    public sealed virtual bool SupportsCodeFixes(Document document);
    public sealed virtual bool SupportsNavigationToAnyPosition(Document document);
    public sealed virtual bool SupportsRefactorings(Document document);
    public sealed virtual bool SupportsRename(Document document);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
internal static class Microsoft.CodeAnalysis.Shared.Extensions.DocumentExtensions : object {
    [ExtensionAttribute]
public static bool ShouldHideAdvancedMembers(Document document);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.Shared.Extensions.DocumentExtensions/<ReplaceNodeAsync>d__1`1")]
[ExtensionAttribute]
public static Task`1<Document> ReplaceNodeAsync(Document document, TNode oldNode, TNode newNode, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static Document ReplaceNodeSynchronously(Document document, TNode oldNode, TNode newNode, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static Document ReplaceNode(Document document, SyntaxNode root, TNode oldNode, TNode newNode);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.Shared.Extensions.DocumentExtensions/<ReplaceNodesAsync>d__4")]
[ExtensionAttribute]
public static Task`1<Document> ReplaceNodesAsync(Document document, IEnumerable`1<SyntaxNode> nodes, Func`3<SyntaxNode, SyntaxNode, SyntaxNode> computeReplacementNode, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.Shared.Extensions.DocumentExtensions/<GetUnionItemsFromDocumentAndLinkedDocumentsAsync>d__5`1")]
[ExtensionAttribute]
public static Task`1<ImmutableArray`1<T>> GetUnionItemsFromDocumentAndLinkedDocumentsAsync(Document document, IEqualityComparer`1<T> comparer, Func`2<Document, Task`1<ImmutableArray`1<T>>> getItemsWorker);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.Shared.Extensions.DocumentExtensions/<IsValidContextForDocumentOrLinkedDocumentsAsync>d__6")]
[ExtensionAttribute]
public static Task`1<bool> IsValidContextForDocumentOrLinkedDocumentsAsync(Document document, Func`3<Document, CancellationToken, Task`1<bool>> contextChecker, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static Task`1<ImmutableArray`1<NamingRule>> GetNamingRulesAsync(Document document, CancellationToken cancellationToken);
    [NullableContextAttribute("0")]
[AsyncStateMachineAttribute("Microsoft.CodeAnalysis.Shared.Extensions.DocumentExtensions/<GetNamingRulesAsync>d__8")]
[ExtensionAttribute]
public static Task`1<ImmutableArray`1<NamingRule>> GetNamingRulesAsync(Document document, ImmutableArray`1<NamingRule> defaultRules, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.Shared.Extensions.DocumentExtensions/<GetApplicableNamingRuleAsync>d__9")]
[ExtensionAttribute]
public static Task`1<NamingRule> GetApplicableNamingRuleAsync(Document document, ISymbol symbol, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.Shared.Extensions.DocumentExtensions/<GetApplicableNamingRuleAsync>d__10")]
[ExtensionAttribute]
public static Task`1<NamingRule> GetApplicableNamingRuleAsync(Document document, SymbolKind symbolKind, Accessibility accessibility, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.Shared.Extensions.DocumentExtensions/<GetApplicableNamingRuleAsync>d__11")]
[ExtensionAttribute]
public static Task`1<NamingRule> GetApplicableNamingRuleAsync(Document document, SymbolKindOrTypeKind kind, DeclarationModifiers modifiers, Nullable`1<Accessibility> accessibility, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static ImmutableArray`1<AbstractFormattingRule> GetFormattingRules(Document document, TextSpan span, IEnumerable`1<AbstractFormattingRule> additionalRules);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
internal static class Microsoft.CodeAnalysis.Shared.Extensions.ISymbolExtensions2 : object {
    public static SymbolDisplayFormat CrefFormat;
    private static ISymbolExtensions2();
    [ExtensionAttribute]
public static Glyph GetGlyph(ISymbol symbol);
    [ExtensionAttribute]
public static IEnumerable`1<TaggedText> GetDocumentationParts(ISymbol symbol, SemanticModel semanticModel, int position, IDocumentationCommentFormattingService formatter, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static IEnumerable`1<TaggedText> GetRemarksDocumentationParts(ISymbol symbol, SemanticModel semanticModel, int position, IDocumentationCommentFormattingService formatter, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static IEnumerable`1<TaggedText> GetReturnsDocumentationParts(ISymbol symbol, SemanticModel semanticModel, int position, IDocumentationCommentFormattingService formatter, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static IEnumerable`1<TaggedText> GetValueDocumentationParts(ISymbol symbol, SemanticModel semanticModel, int position, IDocumentationCommentFormattingService formatter, CancellationToken cancellationToken);
    private static string GetDocumentation(ISymbol symbol, Compilation compilation, CancellationToken cancellationToken);
    private static string GetRemarksDocumentation(ISymbol symbol, Compilation compilation, CancellationToken cancellationToken);
    private static string GetReturnsDocumentation(ISymbol symbol, Compilation compilation, CancellationToken cancellationToken);
    private static string GetValueDocumentation(ISymbol symbol, Compilation compilation, CancellationToken cancellationToken);
    private static string GetParameterDocumentation(IParameterSymbol parameter, Compilation compilation, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static Func`2<CancellationToken, IEnumerable`1<TaggedText>> GetDocumentationPartsFactory(ISymbol symbol, SemanticModel semanticModel, int position, IDocumentationCommentFormattingService formatter);
    private static DocumentationComment GetMethodDocumentation(IMethodSymbol method, Compilation compilation, CancellationToken cancellationToken);
    [NullableContextAttribute("0")]
[ExtensionAttribute]
[ObsoleteAttribute("Use overload without ISymbolDisplayService")]
public static ImmutableArray`1<TSymbol> Sort(ImmutableArray`1<TSymbol> symbols, ISymbolDisplayService symbolDisplayService, SemanticModel semanticModel, int position);
    [NullableContextAttribute("0")]
[ExtensionAttribute]
public static ImmutableArray`1<TSymbol> Sort(ImmutableArray`1<TSymbol> symbols, SemanticModel semanticModel, int position);
    [NullableContextAttribute("0")]
private static INamedTypeSymbol GetNamedType(ITypeSymbol type);
    [NullableContextAttribute("0")]
private static int CompareParameters(ImmutableArray`1<IParameterSymbol> xParameters, String[] xTypeNames, ImmutableArray`1<IParameterSymbol> yParameters, String[] yTypeNames);
    [NullableContextAttribute("0")]
private static int CompareProperties(IPropertySymbol xProperty, String[] xTypeNames, IPropertySymbol yProperty, String[] yTypeNames);
    [NullableContextAttribute("0")]
private static int CompareMethods(IMethodSymbol xMethod, String[] xTypeNames, IMethodSymbol yMethod, String[] yTypeNames);
    [NullableContextAttribute("0")]
private static int CompareEvents(IEventSymbol xEvent, String[] xTypeNames, IEventSymbol yEvent, String[] yTypeNames);
    [NullableContextAttribute("0")]
private static int CompareNamedTypes(INamedTypeSymbol xNamedType, INamedTypeSymbol yNamedType);
    [NullableContextAttribute("0")]
private static String[] GetParameterTypeNames(ISymbol symbol, SemanticModel semanticModel, int position);
    [NullableContextAttribute("0")]
private static ImmutableArray`1<IParameterSymbol> GetMethodOrIndexerOrEventParameters(ISymbol symbol);
    [NullableContextAttribute("0")]
private static int Compare(TSymbol s1, TSymbol s2, ConcurrentDictionary`2<TSymbol, String[]> symbolToParameterTypeNames, Func`2<TSymbol, String[]> getParameterTypeNames);
}
[ExtensionAttribute]
internal static class Microsoft.CodeAnalysis.Shared.Extensions.ProjectExtensions : object {
    [ExtensionAttribute]
public static Glyph GetGlyph(Project project);
}
[ExtensionAttribute]
internal static class Microsoft.CodeAnalysis.Shared.Extensions.SyntaxTokenListExtensions : object {
    [ExtensionAttribute]
internal static string GetValueText(SyntaxTokenList tokens);
}
internal interface Microsoft.CodeAnalysis.Shared.IDocumentSupportsFeatureService {
    public abstract virtual bool SupportsCodeFixes(Document document);
    public abstract virtual bool SupportsRefactorings(Document document);
    public abstract virtual bool SupportsRename(Document document);
    public abstract virtual bool SupportsNavigationToAnyPosition(Document document);
}
internal static class Microsoft.CodeAnalysis.Shared.Naming.FallbackNamingRules : object {
    public static ImmutableArray`1<NamingRule> Default;
    internal static ImmutableArray`1<NamingRule> CompletionOfferingRules;
    private static FallbackNamingRules();
    private static NamingRule CreateGetAsyncRule();
    private static NamingRule CreateCamelCaseFieldsAndParametersRule();
    private static NamingRule CreateEndWithAsyncRule();
    private static NamingRule CreateMethodStartsWithGetRule();
}
[IsReadOnlyAttribute]
internal class Microsoft.CodeAnalysis.Shared.Naming.IdentifierNameParts : ValueType {
    public string BaseName;
    public ImmutableArray`1<string> BaseNameParts;
    public IdentifierNameParts(string baseName, ImmutableArray`1<string> baseNameParts);
    public static IdentifierNameParts CreateIdentifierNameParts(ISymbol symbol, ImmutableArray`1<NamingRule> rules);
    private static string RemovePrefixesAndSuffixes(ISymbol symbol, ImmutableArray`1<NamingRule> rules, string baseName);
    private static ImmutableArray`1<string> CreateWords(ArrayBuilder`1<TextSpan> parts, string name);
}
internal static class Microsoft.CodeAnalysis.Shared.Options.ServiceComponentOnOffOptions : object {
    public static Option2`1<bool> DiagnosticProvider;
    private static ServiceComponentOnOffOptions();
}
[ExportOptionProviderAttribute]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.Shared.Options.ServiceComponentOnOffOptionsProvider : object {
    [CompilerGeneratedAttribute]
private ImmutableArray`1<IOption> <Options>k__BackingField;
    public ImmutableArray`1<IOption> Options { get; }
    [CompilerGeneratedAttribute]
public sealed virtual ImmutableArray`1<IOption> get_Options();
}
internal static class Microsoft.CodeAnalysis.Shared.Options.ServiceFeatureOnOffOptions : object {
    [NullableAttribute("1")]
public static PerLanguageOption`1<bool> RemoveDocumentDiagnosticsOnDocumentClose;
    private static ServiceFeatureOnOffOptions();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.CodeAnalysis.Shared.Utilities.AnnotatedSymbolMapping : object {
    [CompilerGeneratedAttribute]
private ImmutableDictionary`2<ISymbol, SyntaxAnnotation> <SymbolToDeclarationAnnotationMap>k__BackingField;
    [CompilerGeneratedAttribute]
private Solution <AnnotatedSolution>k__BackingField;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private ImmutableDictionary`2<DocumentId, ImmutableArray`1<ISymbol>> <DocumentIdsToSymbolMap>k__BackingField;
    [CompilerGeneratedAttribute]
private SyntaxAnnotation <TypeNodeAnnotation>k__BackingField;
    public ImmutableDictionary`2<ISymbol, SyntaxAnnotation> SymbolToDeclarationAnnotationMap { get; }
    public Solution AnnotatedSolution { get; }
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ImmutableDictionary`2<DocumentId, ImmutableArray`1<ISymbol>> DocumentIdsToSymbolMap { get; }
    public SyntaxAnnotation TypeNodeAnnotation { get; }
    public AnnotatedSymbolMapping(ImmutableDictionary`2<ISymbol, SyntaxAnnotation> symbolToDeclarationAnnotationMap, Solution annotatedSolution, ImmutableDictionary`2<DocumentId, ImmutableArray`1<ISymbol>> documentIdsToSymbolMap, SyntaxAnnotation typeNodeAnnotation);
    [CompilerGeneratedAttribute]
public ImmutableDictionary`2<ISymbol, SyntaxAnnotation> get_SymbolToDeclarationAnnotationMap();
    [CompilerGeneratedAttribute]
public Solution get_AnnotatedSolution();
    [CompilerGeneratedAttribute]
public ImmutableDictionary`2<DocumentId, ImmutableArray`1<ISymbol>> get_DocumentIdsToSymbolMap();
    [CompilerGeneratedAttribute]
public SyntaxAnnotation get_TypeNodeAnnotation();
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.Shared.Utilities.AnnotatedSymbolMapping/<CreateAsync>d__13")]
public static Task`1<AnnotatedSymbolMapping> CreateAsync(IEnumerable`1<ISymbol> symbols, Solution solution, SyntaxNode typeNode, CancellationToken cancellationToken);
}
[IsReadOnlyAttribute]
internal class Microsoft.CodeAnalysis.Shared.Utilities.DeserializationConstructorCheck : ValueType {
    private INamedTypeSymbol _iSerializableType;
    private INamedTypeSymbol _serializationInfoType;
    private INamedTypeSymbol _streamingContextType;
    public DeserializationConstructorCheck(Compilation compilation);
    public bool IsDeserializationConstructor(IMethodSymbol methodSymbol);
}
internal static class Microsoft.CodeAnalysis.Shared.Utilities.ExtractTypeHelpers : object {
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.Shared.Utilities.ExtractTypeHelpers/<AddTypeToExistingFileAsync>d__0")]
public static Task`1<ValueTuple`2<Document, SyntaxAnnotation>> AddTypeToExistingFileAsync(Document document, INamedTypeSymbol newType, AnnotatedSymbolMapping symbolMapping, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.Shared.Utilities.ExtractTypeHelpers/<AddTypeToNewFileAsync>d__1")]
public static Task`1<ValueTuple`2<Document, SyntaxAnnotation>> AddTypeToNewFileAsync(Solution solution, string containingNamespaceDisplay, string fileName, ProjectId projectId, IEnumerable`1<string> folders, INamedTypeSymbol newSymbol, ImmutableArray`1<SyntaxTrivia> fileBanner, CancellationToken cancellationToken);
    public static string GetTypeParameterSuffix(Document document, INamedTypeSymbol type, IEnumerable`1<ISymbol> extractableMembers);
    public static ImmutableArray`1<ITypeParameterSymbol> GetRequiredTypeParametersForMembers(INamedTypeSymbol type, IEnumerable`1<ISymbol> includedMembers);
    private static ImmutableArray`1<ITypeParameterSymbol> GetPotentialTypeParameters(INamedTypeSymbol type);
    private static ImmutableArray`1<ITypeParameterSymbol> GetDirectlyReferencedTypeParameters(IEnumerable`1<ITypeParameterSymbol> potentialTypeParameters, IEnumerable`1<ISymbol> includedMembers);
    private static bool DoesMemberReferenceTypeParameter(ISymbol member, ITypeParameterSymbol typeParameter, HashSet`1<ITypeSymbol> checkedTypes);
    private static bool DoesTypeReferenceTypeParameter(ITypeSymbol type, ITypeParameterSymbol typeParameter, HashSet`1<ITypeSymbol> checkedTypes);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.CodeAnalysis.Shared.Utilities.LinkedFilesSymbolEquivalenceComparer : object {
    public static LinkedFilesSymbolEquivalenceComparer Instance;
    private static LinkedFilesSymbolEquivalenceComparer();
    [NullableContextAttribute("2")]
public sealed virtual bool Equals(ISymbol x, ISymbol y);
    public sealed virtual int GetHashCode(ISymbol symbol);
}
internal class Microsoft.CodeAnalysis.Shared.Utilities.SupportedPlatformData : object {
    public List`1<ProjectId> InvalidProjects;
    public IEnumerable`1<ProjectId> CandidateProjects;
    public Workspace Workspace;
    public SupportedPlatformData(List`1<ProjectId> invalidProjects, IEnumerable`1<ProjectId> candidateProjects, Workspace workspace);
    public IList`1<SymbolDisplayPart> ToDisplayParts();
    private static string Supported(bool supported);
    public bool HasValidAndInvalidProjects();
    [CompilerGeneratedAttribute]
private Project <ToDisplayParts>b__4_0(ProjectId p);
}
internal abstract class Microsoft.CodeAnalysis.SignatureHelp.AbstractSignatureHelpProvider : object {
    protected static SymbolDisplayFormat MinimallyQualifiedWithoutParametersFormat;
    protected static SymbolDisplayFormat MinimallyQualifiedWithoutTypeParametersFormat;
    private static AbstractSignatureHelpProvider();
    public abstract virtual bool IsTriggerCharacter(char ch);
    public abstract virtual bool IsRetriggerCharacter(char ch);
    public abstract virtual SignatureHelpState GetCurrentArgumentState(SyntaxNode root, int position, ISyntaxFactsService syntaxFacts, TextSpan currentSpan, CancellationToken cancellationToken);
    protected abstract virtual Task`1<SignatureHelpItems> GetItemsWorkerAsync(Document document, int position, SignatureHelpTriggerInfo triggerInfo, CancellationToken cancellationToken);
    protected static SignatureHelpItems CreateSignatureHelpItems(IList`1<SignatureHelpItem> items, TextSpan applicableSpan, SignatureHelpState state);
    protected static SignatureHelpItems CreateSignatureHelpItems(IList`1<SignatureHelpItem> items, TextSpan applicableSpan, SignatureHelpState state, Nullable`1<int> selectedItem);
    protected static SignatureHelpItems CreateCollectionInitializerSignatureHelpItems(IList`1<SignatureHelpItem> items, TextSpan applicableSpan, SignatureHelpState state);
    private static ValueTuple`2<IList`1<SignatureHelpItem>, Nullable`1<int>> Filter(IList`1<SignatureHelpItem> items, IEnumerable`1<string> parameterNames, Nullable`1<int> selectedItem);
    private static bool Include(SignatureHelpItem item, IEnumerable`1<string> parameterNames);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.SignatureHelp.AbstractSignatureHelpProvider/<GetCurrentArgumentStateAsync>d__12")]
public Task`1<SignatureHelpState> GetCurrentArgumentStateAsync(Document document, int position, TextSpan currentSpan, CancellationToken cancellationToken);
    [ObsoleteAttribute("Use overload without ISymbolDisplayService")]
protected SignatureHelpItem CreateItem(ISymbol orderSymbol, SemanticModel semanticModel, int position, ISymbolDisplayService symbolDisplayService, IAnonymousTypeDisplayService anonymousTypeDisplayService, bool isVariadic, Func`2<CancellationToken, IEnumerable`1<TaggedText>> documentationFactory, IList`1<SymbolDisplayPart> prefixParts, IList`1<SymbolDisplayPart> separatorParts, IList`1<SymbolDisplayPart> suffixParts, IList`1<SignatureHelpSymbolParameter> parameters, IList`1<SymbolDisplayPart> descriptionParts);
    protected static SignatureHelpItem CreateItem(ISymbol orderSymbol, SemanticModel semanticModel, int position, IAnonymousTypeDisplayService anonymousTypeDisplayService, bool isVariadic, Func`2<CancellationToken, IEnumerable`1<TaggedText>> documentationFactory, IList`1<SymbolDisplayPart> prefixParts, IList`1<SymbolDisplayPart> separatorParts, IList`1<SymbolDisplayPart> suffixParts, IList`1<SignatureHelpSymbolParameter> parameters, IList`1<SymbolDisplayPart> descriptionParts);
    protected static SignatureHelpItem CreateItemImpl(ISymbol orderSymbol, SemanticModel semanticModel, int position, IAnonymousTypeDisplayService anonymousTypeDisplayService, bool isVariadic, Func`2<CancellationToken, IEnumerable`1<TaggedText>> documentationFactory, IList`1<SymbolDisplayPart> prefixParts, IList`1<SymbolDisplayPart> separatorParts, IList`1<SymbolDisplayPart> suffixParts, IList`1<SignatureHelpSymbolParameter> parameters, IList`1<SymbolDisplayPart> descriptionParts);
    private static SignatureHelpSymbolParameter ReplaceAnonymousTypes(SignatureHelpSymbolParameter parameter, AnonymousTypeDisplayInfo info);
    private static SignatureHelpSymbolParameter InlineDelegateAnonymousTypes(SignatureHelpSymbolParameter parameter, SemanticModel semanticModel, int position, IAnonymousTypeDisplayService anonymousTypeDisplayService);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.SignatureHelp.AbstractSignatureHelpProvider/<GetItemsAsync>d__18")]
public sealed virtual Task`1<SignatureHelpItems> GetItemsAsync(Document document, int position, SignatureHelpTriggerInfo triggerInfo, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.SignatureHelp.AbstractSignatureHelpProvider/<ExtractSymbolsFromRelatedItemsAsync>d__19")]
private static Task`1<List`1<Tuple`2<ProjectId, ISet`1<ISymbol>>>> ExtractSymbolsFromRelatedItemsAsync(int position, List`1<Tuple`2<Document, IEnumerable`1<SignatureHelpItem>>> relatedDocuments, CancellationToken cancellationToken);
    private static SignatureHelpItem UpdateItem(SignatureHelpItem item, SupportedPlatformData platformData);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.SignatureHelp.AbstractSignatureHelpProvider/<GetItemsForRelatedDocumentsAsync>d__21")]
protected Task`1<List`1<Tuple`2<Document, IEnumerable`1<SignatureHelpItem>>>> GetItemsForRelatedDocumentsAsync(Document document, IEnumerable`1<DocumentId> relatedDocuments, int position, SignatureHelpTriggerInfo triggerInfo, CancellationToken cancellationToken);
    protected static Nullable`1<int> TryGetSelectedIndex(ImmutableArray`1<TSymbol> candidates, ISymbol currentSymbol);
}
internal static class Microsoft.CodeAnalysis.SignatureHelp.CommonSignatureHelpUtilities : object {
    internal static SignatureHelpState GetSignatureHelpState(TArgumentList argumentList, int position, Func`2<TArgumentList, SyntaxToken> getOpenToken, Func`2<TArgumentList, SyntaxToken> getCloseToken, Func`2<TArgumentList, IEnumerable`1<SyntaxNodeOrToken>> getArgumentsWithSeparators, Func`2<TArgumentList, IEnumerable`1<string>> getArgumentNames);
    private static bool TryGetCurrentArgumentIndex(TArgumentList argumentList, int position, Func`2<TArgumentList, SyntaxToken> getOpenToken, Func`2<TArgumentList, SyntaxToken> getCloseToken, Func`2<TArgumentList, IEnumerable`1<SyntaxNodeOrToken>> getArgumentsWithSeparators, Int32& index);
    internal static TextSpan GetSignatureHelpSpan(TArgumentList argumentList, Func`2<TArgumentList, SyntaxToken> getCloseToken);
    internal static TextSpan GetSignatureHelpSpan(TArgumentList argumentList, int start, Func`2<TArgumentList, SyntaxToken> getCloseToken);
    internal static bool TryGetSyntax(SyntaxNode root, int position, ISyntaxFactsService syntaxFacts, SignatureHelpTriggerReason triggerReason, Func`2<SyntaxToken, bool> isTriggerToken, Func`3<TSyntax, SyntaxToken, bool> isArgumentListToken, CancellationToken cancellationToken, TSyntax& expression);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.SignatureHelp.CommonSignatureHelpUtilities/<GetCollectionInitializerAddMethodsAsync>d__5")]
public static Task`1<ImmutableArray`1<IMethodSymbol>> GetCollectionInitializerAddMethodsAsync(Document document, SyntaxNode initializer, CancellationToken cancellationToken);
}
[MetadataAttributeAttribute]
[AttributeUsageAttribute("4")]
internal class Microsoft.CodeAnalysis.SignatureHelp.ExportSignatureHelpProviderAttribute : ExportAttribute {
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Language>k__BackingField;
    public string Name { get; }
    public string Language { get; }
    public ExportSignatureHelpProviderAttribute(string name, string language);
    [CompilerGeneratedAttribute]
public string get_Name();
    [CompilerGeneratedAttribute]
public string get_Language();
}
internal interface Microsoft.CodeAnalysis.SignatureHelp.ISignatureHelpProvider {
    public abstract virtual bool IsTriggerCharacter(char ch);
    public abstract virtual bool IsRetriggerCharacter(char ch);
    public abstract virtual Task`1<SignatureHelpItems> GetItemsAsync(Document document, int position, SignatureHelpTriggerInfo triggerInfo, CancellationToken cancellationToken);
}
internal class Microsoft.CodeAnalysis.SignatureHelp.SignatureHelpItem : object {
    [CompilerGeneratedAttribute]
private bool <IsVariadic>k__BackingField;
    [CompilerGeneratedAttribute]
private ImmutableArray`1<TaggedText> <PrefixDisplayParts>k__BackingField;
    [CompilerGeneratedAttribute]
private ImmutableArray`1<TaggedText> <SuffixDisplayParts>k__BackingField;
    [CompilerGeneratedAttribute]
private ImmutableArray`1<TaggedText> <SeparatorDisplayParts>k__BackingField;
    [CompilerGeneratedAttribute]
private ImmutableArray`1<SignatureHelpParameter> <Parameters>k__BackingField;
    [CompilerGeneratedAttribute]
private ImmutableArray`1<TaggedText> <DescriptionParts>k__BackingField;
    [CompilerGeneratedAttribute]
private Func`2<CancellationToken, IEnumerable`1<TaggedText>> <DocumentationFactory>k__BackingField;
    private static Func`2<CancellationToken, IEnumerable`1<TaggedText>> s_emptyDocumentationFactory;
    public bool IsVariadic { get; }
    public ImmutableArray`1<TaggedText> PrefixDisplayParts { get; }
    public ImmutableArray`1<TaggedText> SuffixDisplayParts { get; }
    public ImmutableArray`1<TaggedText> SeparatorDisplayParts { get; }
    public ImmutableArray`1<SignatureHelpParameter> Parameters { get; }
    public ImmutableArray`1<TaggedText> DescriptionParts { get; internal set; }
    public Func`2<CancellationToken, IEnumerable`1<TaggedText>> DocumentationFactory { get; }
    public SignatureHelpItem(bool isVariadic, Func`2<CancellationToken, IEnumerable`1<TaggedText>> documentationFactory, IEnumerable`1<TaggedText> prefixParts, IEnumerable`1<TaggedText> separatorParts, IEnumerable`1<TaggedText> suffixParts, IEnumerable`1<SignatureHelpParameter> parameters, IEnumerable`1<TaggedText> descriptionParts);
    public SignatureHelpItem(bool isVariadic, Func`2<CancellationToken, IEnumerable`1<SymbolDisplayPart>> documentationFactory, IEnumerable`1<SymbolDisplayPart> prefixParts, IEnumerable`1<SymbolDisplayPart> separatorParts, IEnumerable`1<SymbolDisplayPart> suffixParts, IEnumerable`1<SignatureHelpParameter> parameters, IEnumerable`1<SymbolDisplayPart> descriptionParts);
    private static SignatureHelpItem();
    [CompilerGeneratedAttribute]
public bool get_IsVariadic();
    [CompilerGeneratedAttribute]
public ImmutableArray`1<TaggedText> get_PrefixDisplayParts();
    [CompilerGeneratedAttribute]
public ImmutableArray`1<TaggedText> get_SuffixDisplayParts();
    [CompilerGeneratedAttribute]
public ImmutableArray`1<TaggedText> get_SeparatorDisplayParts();
    [CompilerGeneratedAttribute]
public ImmutableArray`1<SignatureHelpParameter> get_Parameters();
    [CompilerGeneratedAttribute]
public ImmutableArray`1<TaggedText> get_DescriptionParts();
    [CompilerGeneratedAttribute]
internal void set_DescriptionParts(ImmutableArray`1<TaggedText> value);
    [CompilerGeneratedAttribute]
public Func`2<CancellationToken, IEnumerable`1<TaggedText>> get_DocumentationFactory();
    internal IEnumerable`1<TaggedText> GetAllParts();
    public virtual string ToString();
}
internal class Microsoft.CodeAnalysis.SignatureHelp.SignatureHelpItems : object {
    [CompilerGeneratedAttribute]
private IList`1<SignatureHelpItem> <Items>k__BackingField;
    [CompilerGeneratedAttribute]
private TextSpan <ApplicableSpan>k__BackingField;
    [CompilerGeneratedAttribute]
private int <ArgumentIndex>k__BackingField;
    [CompilerGeneratedAttribute]
private int <ArgumentCount>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ArgumentName>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<int> <SelectedItemIndex>k__BackingField;
    public IList`1<SignatureHelpItem> Items { get; }
    public TextSpan ApplicableSpan { get; }
    public int ArgumentIndex { get; }
    public int ArgumentCount { get; }
    public string ArgumentName { get; }
    public Nullable`1<int> SelectedItemIndex { get; }
    public SignatureHelpItems(IList`1<SignatureHelpItem> items, TextSpan applicableSpan, int argumentIndex, int argumentCount, string argumentName, Nullable`1<int> selectedItem);
    [CompilerGeneratedAttribute]
public IList`1<SignatureHelpItem> get_Items();
    [CompilerGeneratedAttribute]
public TextSpan get_ApplicableSpan();
    [CompilerGeneratedAttribute]
public int get_ArgumentIndex();
    [CompilerGeneratedAttribute]
public int get_ArgumentCount();
    [CompilerGeneratedAttribute]
public string get_ArgumentName();
    [CompilerGeneratedAttribute]
public Nullable`1<int> get_SelectedItemIndex();
}
internal class Microsoft.CodeAnalysis.SignatureHelp.SignatureHelpParameter : object {
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    [CompilerGeneratedAttribute]
private Func`2<CancellationToken, IEnumerable`1<TaggedText>> <DocumentationFactory>k__BackingField;
    [CompilerGeneratedAttribute]
private IList`1<TaggedText> <PrefixDisplayParts>k__BackingField;
    [CompilerGeneratedAttribute]
private IList`1<TaggedText> <SuffixDisplayParts>k__BackingField;
    [CompilerGeneratedAttribute]
private IList`1<TaggedText> <DisplayParts>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsOptional>k__BackingField;
    [CompilerGeneratedAttribute]
private IList`1<TaggedText> <SelectedDisplayParts>k__BackingField;
    private static Func`2<CancellationToken, IEnumerable`1<TaggedText>> s_emptyDocumentationFactory;
    public string Name { get; }
    public Func`2<CancellationToken, IEnumerable`1<TaggedText>> DocumentationFactory { get; }
    public IList`1<TaggedText> PrefixDisplayParts { get; }
    public IList`1<TaggedText> SuffixDisplayParts { get; }
    public IList`1<TaggedText> DisplayParts { get; }
    public bool IsOptional { get; }
    public IList`1<TaggedText> SelectedDisplayParts { get; }
    public SignatureHelpParameter(string name, bool isOptional, Func`2<CancellationToken, IEnumerable`1<SymbolDisplayPart>> documentationFactory, IEnumerable`1<SymbolDisplayPart> displayParts, IEnumerable`1<SymbolDisplayPart> prefixDisplayParts, IEnumerable`1<SymbolDisplayPart> suffixDisplayParts, IEnumerable`1<SymbolDisplayPart> selectedDisplayParts);
    public SignatureHelpParameter(string name, bool isOptional, Func`2<CancellationToken, IEnumerable`1<TaggedText>> documentationFactory, IEnumerable`1<TaggedText> displayParts, IEnumerable`1<TaggedText> prefixDisplayParts, IEnumerable`1<TaggedText> suffixDisplayParts, IEnumerable`1<TaggedText> selectedDisplayParts);
    private static SignatureHelpParameter();
    [CompilerGeneratedAttribute]
public string get_Name();
    [CompilerGeneratedAttribute]
public Func`2<CancellationToken, IEnumerable`1<TaggedText>> get_DocumentationFactory();
    [CompilerGeneratedAttribute]
public IList`1<TaggedText> get_PrefixDisplayParts();
    [CompilerGeneratedAttribute]
public IList`1<TaggedText> get_SuffixDisplayParts();
    [CompilerGeneratedAttribute]
public IList`1<TaggedText> get_DisplayParts();
    [CompilerGeneratedAttribute]
public bool get_IsOptional();
    [CompilerGeneratedAttribute]
public IList`1<TaggedText> get_SelectedDisplayParts();
    internal IEnumerable`1<TaggedText> GetAllParts();
    public virtual string ToString();
}
internal class Microsoft.CodeAnalysis.SignatureHelp.SignatureHelpState : object {
    public int ArgumentIndex;
    public int ArgumentCount;
    public string ArgumentName;
    public IList`1<string> ArgumentNames;
    public SignatureHelpState(int argumentIndex, int argumentCount, string argumentName, IList`1<string> argumentNames);
}
internal class Microsoft.CodeAnalysis.SignatureHelp.SignatureHelpSymbolParameter : object {
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    [CompilerGeneratedAttribute]
private Func`2<CancellationToken, IEnumerable`1<TaggedText>> <DocumentationFactory>k__BackingField;
    [CompilerGeneratedAttribute]
private IList`1<SymbolDisplayPart> <PrefixDisplayParts>k__BackingField;
    [CompilerGeneratedAttribute]
private IList`1<SymbolDisplayPart> <SuffixDisplayParts>k__BackingField;
    [CompilerGeneratedAttribute]
private IList`1<SymbolDisplayPart> <DisplayParts>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsOptional>k__BackingField;
    [CompilerGeneratedAttribute]
private IList`1<SymbolDisplayPart> <SelectedDisplayParts>k__BackingField;
    private static Func`2<CancellationToken, IEnumerable`1<TaggedText>> s_emptyDocumentationFactory;
    public string Name { get; }
    public Func`2<CancellationToken, IEnumerable`1<TaggedText>> DocumentationFactory { get; }
    public IList`1<SymbolDisplayPart> PrefixDisplayParts { get; }
    public IList`1<SymbolDisplayPart> SuffixDisplayParts { get; }
    public IList`1<SymbolDisplayPart> DisplayParts { get; }
    public bool IsOptional { get; }
    public IList`1<SymbolDisplayPart> SelectedDisplayParts { get; }
    public SignatureHelpSymbolParameter(string name, bool isOptional, Func`2<CancellationToken, IEnumerable`1<TaggedText>> documentationFactory, IEnumerable`1<SymbolDisplayPart> displayParts, IEnumerable`1<SymbolDisplayPart> prefixDisplayParts, IEnumerable`1<SymbolDisplayPart> suffixDisplayParts, IEnumerable`1<SymbolDisplayPart> selectedDisplayParts);
    private static SignatureHelpSymbolParameter();
    [CompilerGeneratedAttribute]
public string get_Name();
    [CompilerGeneratedAttribute]
public Func`2<CancellationToken, IEnumerable`1<TaggedText>> get_DocumentationFactory();
    [CompilerGeneratedAttribute]
public IList`1<SymbolDisplayPart> get_PrefixDisplayParts();
    [CompilerGeneratedAttribute]
public IList`1<SymbolDisplayPart> get_SuffixDisplayParts();
    [CompilerGeneratedAttribute]
public IList`1<SymbolDisplayPart> get_DisplayParts();
    [CompilerGeneratedAttribute]
public bool get_IsOptional();
    [CompilerGeneratedAttribute]
public IList`1<SymbolDisplayPart> get_SelectedDisplayParts();
    internal IEnumerable`1<SymbolDisplayPart> GetAllParts();
    public static SignatureHelpParameter op_Explicit(SignatureHelpSymbolParameter parameter);
}
[IsReadOnlyAttribute]
internal class Microsoft.CodeAnalysis.SignatureHelp.SignatureHelpTriggerInfo : ValueType {
    [CompilerGeneratedAttribute]
private SignatureHelpTriggerReason <TriggerReason>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<char> <TriggerCharacter>k__BackingField;
    public SignatureHelpTriggerReason TriggerReason { get; }
    public Nullable`1<char> TriggerCharacter { get; }
    internal SignatureHelpTriggerInfo(SignatureHelpTriggerReason triggerReason, Nullable`1<char> triggerCharacter);
    [CompilerGeneratedAttribute]
public SignatureHelpTriggerReason get_TriggerReason();
    [CompilerGeneratedAttribute]
public Nullable`1<char> get_TriggerCharacter();
}
internal enum Microsoft.CodeAnalysis.SignatureHelp.SignatureHelpTriggerReason : Enum {
    public int value__;
    public static SignatureHelpTriggerReason InvokeSignatureHelpCommand;
    public static SignatureHelpTriggerReason TypeCharCommand;
    public static SignatureHelpTriggerReason RetriggerCommand;
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal abstract class Microsoft.CodeAnalysis.SimplifyBooleanExpression.AbstractSimplifyConditionalDiagnosticAnalyzer`3 : AbstractBuiltInCodeStyleDiagnosticAnalyzer {
    private static ImmutableDictionary`2<string, string> s_takeCondition;
    private static ImmutableDictionary`2<string, string> s_negateCondition;
    private static ImmutableDictionary`2<string, string> s_takeConditionOrWhenFalse;
    private static ImmutableDictionary`2<string, string> s_negateConditionAndWhenFalse;
    private static ImmutableDictionary`2<string, string> s_negateConditionOrWhenTrue;
    private static ImmutableDictionary`2<string, string> s_takeConditionAndWhenTrue;
    private static ImmutableDictionary`2<string, string> s_takeConditionAndWhenFalse;
    protected ISyntaxFacts SyntaxFacts { get; }
    private static AbstractSimplifyConditionalDiagnosticAnalyzer`3();
    protected abstract virtual ISyntaxFacts get_SyntaxFacts();
    protected abstract virtual CommonConversion GetConversion(SemanticModel semanticModel, TExpressionSyntax node, CancellationToken cancellationToken);
    public sealed virtual DiagnosticAnalyzerCategory GetAnalyzerCategory();
    protected sealed virtual void InitializeWorker(AnalysisContext context);
    private void AnalyzeConditionalExpression(SyntaxNodeAnalysisContext context);
    [NullableContextAttribute("0")]
[CompilerGeneratedAttribute]
private void <AnalyzeConditionalExpression>g__ReportDiagnostic|13_0(ImmutableDictionary`2<string, string> properties, <>c__DisplayClass13_0& );
    [NullableContextAttribute("0")]
[CompilerGeneratedAttribute]
private bool <AnalyzeConditionalExpression>g__IsSimpleBooleanType|13_1(TExpressionSyntax node, <>c__DisplayClass13_0& );
    [NullableContextAttribute("0")]
[CompilerGeneratedAttribute]
private bool <AnalyzeConditionalExpression>g__IsTrue|13_2(TExpressionSyntax node, <>c__DisplayClass13_0& );
    [NullableContextAttribute("0")]
[CompilerGeneratedAttribute]
private bool <AnalyzeConditionalExpression>g__IsFalse|13_3(TExpressionSyntax node, <>c__DisplayClass13_0& );
    [NullableContextAttribute("0")]
[CompilerGeneratedAttribute]
private bool <AnalyzeConditionalExpression>g__IsBoolValue|13_4(TExpressionSyntax node, bool value, <>c__DisplayClass13_0& );
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal static class Microsoft.CodeAnalysis.SimplifyBooleanExpression.SimplifyBooleanExpressionConstants : object {
    public static string Negate;
    public static string Or;
    public static string And;
    public static string WhenTrue;
    public static string WhenFalse;
}
[ExportCodeFixProviderAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.SimplifyBooleanExpression.SimplifyConditionalCodeFixProvider : SyntaxEditorBasedCodeFixProvider {
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private ImmutableArray`1<string> <FixableDiagnosticIds>k__BackingField;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ImmutableArray`1<string> FixableDiagnosticIds { get; }
    internal CodeFixCategory CodeFixCategory { get; }
    [CompilerGeneratedAttribute]
public sealed virtual ImmutableArray`1<string> get_FixableDiagnosticIds();
    internal sealed virtual CodeFixCategory get_CodeFixCategory();
    [NullableContextAttribute("1")]
public sealed virtual Task RegisterCodeFixesAsync(CodeFixContext context);
    [NullableContextAttribute("1")]
[AsyncStateMachineAttribute("Microsoft.CodeAnalysis.SimplifyBooleanExpression.SimplifyConditionalCodeFixProvider/<FixAllAsync>d__7")]
protected sealed virtual Task FixAllAsync(Document document, ImmutableArray`1<Diagnostic> diagnostics, SyntaxEditor editor, CancellationToken cancellationToken);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal abstract class Microsoft.CodeAnalysis.SimplifyInterpolation.AbstractSimplifyInterpolationCodeFixProvider`7 : SyntaxEditorBasedCodeFixProvider {
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private ImmutableArray`1<string> <FixableDiagnosticIds>k__BackingField;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ImmutableArray`1<string> FixableDiagnosticIds { get; }
    internal CodeFixCategory CodeFixCategory { get; }
    [CompilerGeneratedAttribute]
public virtual ImmutableArray`1<string> get_FixableDiagnosticIds();
    internal virtual CodeFixCategory get_CodeFixCategory();
    protected abstract virtual TInterpolationSyntax WithExpression(TInterpolationSyntax interpolation, TExpressionSyntax expression);
    protected abstract virtual TInterpolationSyntax WithAlignmentClause(TInterpolationSyntax interpolation, TInterpolationAlignmentClause alignmentClause);
    protected abstract virtual TInterpolationSyntax WithFormatClause(TInterpolationSyntax interpolation, TInterpolationFormatClause formatClause);
    protected abstract virtual string Escape(TInterpolatedStringExpressionSyntax interpolatedString, string formatString);
    public virtual Task RegisterCodeFixesAsync(CodeFixContext context);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.SimplifyInterpolation.AbstractSimplifyInterpolationCodeFixProvider`7/<FixAllAsync>d__10")]
protected virtual Task FixAllAsync(Document document, ImmutableArray`1<Diagnostic> diagnostics, SyntaxEditor editor, CancellationToken cancellationToken);
    private TInterpolationSyntax Update(SyntaxGeneratorInternal generator, TInterpolatedStringExpressionSyntax interpolatedString, TInterpolationSyntax interpolation, TExpressionSyntax unwrapped, TExpressionSyntax alignment, string formatString);
}
internal abstract class Microsoft.CodeAnalysis.SimplifyInterpolation.AbstractSimplifyInterpolationDiagnosticAnalyzer`4 : AbstractBuiltInCodeStyleDiagnosticAnalyzer {
    protected abstract virtual IVirtualCharService GetVirtualCharService();
    protected abstract virtual ISyntaxFacts GetSyntaxFacts();
    public virtual DiagnosticAnalyzerCategory GetAnalyzerCategory();
    protected virtual void InitializeWorker(AnalysisContext context);
    private void AnalyzeInterpolation(OperationAnalysisContext context);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal static class Microsoft.CodeAnalysis.SimplifyInterpolation.Helpers : object {
    private static SyntaxNode GetPreservedInterpolationExpressionSyntax(IOperation operation);
    public static void UnwrapInterpolation(IVirtualCharService virtualCharService, ISyntaxFacts syntaxFacts, IInterpolationOperation interpolation, TExpressionSyntax& unwrapped, TExpressionSyntax& alignment, Boolean& negate, String& formatString, ImmutableArray`1& unnecessaryLocations);
    private static IOperation Unwrap(IOperation expression);
    private static void UnwrapFormatString(IVirtualCharService virtualCharService, ISyntaxFacts syntaxFacts, IOperation expression, IOperation& unwrapped, String& formatString, List`1<TextSpan> unnecessarySpans);
    private static TextSpan GetSpanWithinLiteralQuotes(IVirtualCharService virtualCharService, SyntaxToken formatToken);
    private static void UnwrapAlignmentPadding(IOperation expression, IOperation& unwrapped, TExpressionSyntax& alignment, Boolean& negate, List`1<TextSpan> unnecessarySpans);
    private static bool HasNonImplicitInstance(IInvocationOperation invocation);
    private static bool IsSpaceChar(IArgumentOperation argument);
}
internal abstract class Microsoft.CodeAnalysis.SimplifyThisOrMe.AbstractSimplifyThisOrMeCodeFixProvider`1 : SyntaxEditorBasedCodeFixProvider {
    [CompilerGeneratedAttribute]
private ImmutableArray`1<string> <FixableDiagnosticIds>k__BackingField;
    public ImmutableArray`1<string> FixableDiagnosticIds { get; }
    internal CodeFixCategory CodeFixCategory { get; }
    protected abstract virtual string GetTitle();
    [CompilerGeneratedAttribute]
public sealed virtual ImmutableArray`1<string> get_FixableDiagnosticIds();
    internal sealed virtual CodeFixCategory get_CodeFixCategory();
    public sealed virtual Task RegisterCodeFixesAsync(CodeFixContext context);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.SimplifyThisOrMe.AbstractSimplifyThisOrMeCodeFixProvider`1/<FixAllAsync>d__8")]
protected virtual Task FixAllAsync(Document document, ImmutableArray`1<Diagnostic> diagnostics, SyntaxEditor editor, CancellationToken cancellationToken);
    protected abstract virtual SyntaxNode Rewrite(SyntaxNode root, ISet`1<TMemberAccessExpressionSyntax> memberAccessNodes);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal abstract class Microsoft.CodeAnalysis.SimplifyThisOrMe.AbstractSimplifyThisOrMeDiagnosticAnalyzer`4 : AbstractBuiltInCodeStyleDiagnosticAnalyzer {
    [NullableAttribute("0")]
private ImmutableArray`1<TLanguageKindEnum> _kindsOfInterest;
    protected abstract virtual string GetLanguageName();
    protected abstract virtual ISyntaxFacts GetSyntaxFacts();
    protected abstract virtual bool CanSimplifyTypeNameExpression(SemanticModel model, TMemberAccessExpressionSyntax memberAccess, OptionSet optionSet, TextSpan& issueSpan, CancellationToken cancellationToken);
    public virtual DiagnosticAnalyzerCategory GetAnalyzerCategory();
    protected virtual void InitializeWorker(AnalysisContext context);
    private void AnalyzeNode(SyntaxNodeAnalysisContext context);
}
internal abstract class Microsoft.CodeAnalysis.SimplifyTypeNames.AbstractSimplifyTypeNamesCodeFixProvider`1 : SyntaxEditorBasedCodeFixProvider {
    private SimplifyTypeNamesDiagnosticAnalyzerBase`1<TSyntaxKind> _analyzer;
    [CompilerGeneratedAttribute]
private ImmutableArray`1<string> <FixableDiagnosticIds>k__BackingField;
    public ImmutableArray`1<string> FixableDiagnosticIds { get; }
    internal CodeFixCategory CodeFixCategory { get; }
    protected AbstractSimplifyTypeNamesCodeFixProvider`1(SimplifyTypeNamesDiagnosticAnalyzerBase`1<TSyntaxKind> analyzer);
    protected abstract virtual string GetTitle(string diagnosticId, string nodeText);
    protected abstract virtual SyntaxNode AddSimplificationAnnotationTo(SyntaxNode node);
    [CompilerGeneratedAttribute]
public sealed virtual ImmutableArray`1<string> get_FixableDiagnosticIds();
    internal sealed virtual CodeFixCategory get_CodeFixCategory();
    private ValueTuple`2<SyntaxNode, string> GetNodeToSimplify(SyntaxNode root, SemanticModel model, TextSpan span, OptionSet optionSet, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.SimplifyTypeNames.AbstractSimplifyTypeNamesCodeFixProvider`1/<RegisterCodeFixesAsync>d__10")]
public sealed virtual Task RegisterCodeFixesAsync(CodeFixContext context);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.SimplifyTypeNames.AbstractSimplifyTypeNamesCodeFixProvider`1/<FixAllAsync>d__11")]
protected virtual Task FixAllAsync(Document document, ImmutableArray`1<Diagnostic> diagnostics, SyntaxEditor editor, CancellationToken cancellationToken);
    private bool CanSimplifyTypeNameExpression(SemanticModel model, SyntaxNode node, OptionSet optionSet, TextSpan span, String& diagnosticId, CancellationToken cancellationToken);
    [NullableContextAttribute("1")]
[CompilerGeneratedAttribute]
private SyntaxNode <FixAllAsync>b__11_0(SyntaxNode current, SyntaxGenerator _);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal abstract class Microsoft.CodeAnalysis.SimplifyTypeNames.SimplifyTypeNamesDiagnosticAnalyzerBase`1 : DiagnosticAnalyzer {
    private static LocalizableString s_localizableMessage;
    private static LocalizableString s_localizableTitleSimplifyNames;
    private static DiagnosticDescriptor s_descriptorSimplifyNames;
    private static LocalizableString s_localizableTitleSimplifyMemberAccess;
    private static DiagnosticDescriptor s_descriptorSimplifyMemberAccess;
    private static DiagnosticDescriptor s_descriptorPreferBuiltinOrFrameworkType;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private ImmutableArray`1<DiagnosticDescriptor> <SupportedDiagnostics>k__BackingField;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    private static SimplifyTypeNamesDiagnosticAnalyzerBase`1();
    internal abstract virtual bool IsCandidate(SyntaxNode node);
    internal abstract virtual bool CanSimplifyTypeNameExpression(SemanticModel model, SyntaxNode node, OptionSet optionSet, TextSpan& issueSpan, String& diagnosticId, Boolean& inDeclaration, CancellationToken cancellationToken);
    [CompilerGeneratedAttribute]
public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    public sealed virtual bool OpenFileOnly(OptionSet options);
    public sealed virtual void Initialize(AnalysisContext context);
    private void AnalyzeCompilation(CompilationStartAnalysisContext context);
    protected abstract virtual bool IsIgnoredCodeBlock(SyntaxNode codeBlock);
    protected abstract virtual ImmutableArray`1<Diagnostic> AnalyzeCodeBlock(CodeBlockAnalysisContext context);
    [NullableContextAttribute("2")]
protected abstract virtual ImmutableArray`1<Diagnostic> AnalyzeSemanticModel(SemanticModelAnalysisContext context, SimpleIntervalTree`2<TextSpan, TextSpanIntervalIntrospector> codeBlockIntervalTree);
    protected abstract virtual string GetLanguageName();
    public bool TrySimplify(SemanticModel model, SyntaxNode node, Diagnostic& diagnostic, OptionSet optionSet, CancellationToken cancellationToken);
    internal static Diagnostic CreateDiagnostic(SemanticModel model, OptionSet optionSet, TextSpan issueSpan, string diagnosticId, bool inDeclaration);
    public sealed virtual DiagnosticAnalyzerCategory GetAnalyzerCategory();
}
internal interface Microsoft.CodeAnalysis.Snippets.ISnippetInfoService {
    public abstract virtual IEnumerable`1<SnippetInfo> GetSnippetsIfAvailable();
    public abstract virtual bool SnippetShortcutExists_NonBlocking(string shortcut);
    public abstract virtual bool ShouldFormatSnippet(SnippetInfo snippetInfo);
}
internal class Microsoft.CodeAnalysis.Snippets.SnippetInfo : object {
    [CompilerGeneratedAttribute]
private string <Shortcut>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Title>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Description>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Path>k__BackingField;
    public string Shortcut { get; }
    public string Title { get; }
    public string Description { get; }
    public string Path { get; }
    public SnippetInfo(string shortcut, string title, string description, string path);
    [CompilerGeneratedAttribute]
public string get_Shortcut();
    [CompilerGeneratedAttribute]
public string get_Title();
    [CompilerGeneratedAttribute]
public string get_Description();
    [CompilerGeneratedAttribute]
public string get_Path();
}
internal abstract class Microsoft.CodeAnalysis.SolutionCrawler.AbstractDocumentDifferenceService : object {
    [NullableContextAttribute("1")]
[AsyncStateMachineAttribute("Microsoft.CodeAnalysis.SolutionCrawler.AbstractDocumentDifferenceService/<GetDifferenceAsync>d__0")]
public sealed virtual Task`1<DocumentDifferenceResult> GetDifferenceAsync(Document oldDocument, Document newDocument, CancellationToken cancellationToken);
    [NullableContextAttribute("1")]
private static SyntaxNode GetChangedMember(ISyntaxFactsService syntaxFactsService, SyntaxNode oldRoot, SyntaxNode newRoot, TextChangeRange range);
    [NullableContextAttribute("1")]
private static SyntaxNode GetBestGuessChangedMember(ISyntaxFactsService syntaxFactsService, SyntaxNode oldRoot, SyntaxNode newRoot, TextChangeRange range);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.CodeAnalysis.SolutionCrawler.AggregateIncrementalAnalyzer : object {
    public ImmutableDictionary`2<string, Lazy`1<IIncrementalAnalyzer>> Analyzers;
    public AggregateIncrementalAnalyzer(Workspace workspace, IncrementalAnalyzerProviderBase owner, List`1<Lazy`2<IPerLanguageIncrementalAnalyzerProvider, PerLanguageIncrementalAnalyzerProviderMetadata>> providers);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.SolutionCrawler.AggregateIncrementalAnalyzer/<NewSolutionSnapshotAsync>d__2")]
public sealed virtual Task NewSolutionSnapshotAsync(Solution solution, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.SolutionCrawler.AggregateIncrementalAnalyzer/<DocumentOpenAsync>d__3")]
public sealed virtual Task DocumentOpenAsync(Document document, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.SolutionCrawler.AggregateIncrementalAnalyzer/<DocumentResetAsync>d__4")]
public sealed virtual Task DocumentResetAsync(Document document, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.SolutionCrawler.AggregateIncrementalAnalyzer/<DocumentCloseAsync>d__5")]
public sealed virtual Task DocumentCloseAsync(Document document, CancellationToken cancellationToken);
    public sealed virtual bool NeedsReanalysisOnOptionChanged(object sender, OptionChangedEventArgs e);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.SolutionCrawler.AggregateIncrementalAnalyzer/<AnalyzeSyntaxAsync>d__7")]
public sealed virtual Task AnalyzeSyntaxAsync(Document document, InvocationReasons reasons, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.SolutionCrawler.AggregateIncrementalAnalyzer/<AnalyzeDocumentAsync>d__8")]
public sealed virtual Task AnalyzeDocumentAsync(Document document, SyntaxNode bodyOpt, InvocationReasons reasons, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.SolutionCrawler.AggregateIncrementalAnalyzer/<AnalyzeProjectAsync>d__9")]
public sealed virtual Task AnalyzeProjectAsync(Project project, bool semanticsChanged, InvocationReasons reasons, CancellationToken cancellationToken);
    private bool TryGetAnalyzer(Project project, IIncrementalAnalyzer& analyzer);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.SolutionCrawler.AggregateIncrementalAnalyzer/<RemoveDocumentAsync>d__11")]
public sealed virtual Task RemoveDocumentAsync(DocumentId documentId, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.SolutionCrawler.AggregateIncrementalAnalyzer/<RemoveProjectAsync>d__12")]
public sealed virtual Task RemoveProjectAsync(ProjectId projectId, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.SolutionCrawler.AggregateIncrementalAnalyzer/<NonSourceDocumentOpenAsync>d__13")]
public sealed virtual Task NonSourceDocumentOpenAsync(TextDocument textDocument, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.SolutionCrawler.AggregateIncrementalAnalyzer/<NonSourceDocumentCloseAsync>d__14")]
public sealed virtual Task NonSourceDocumentCloseAsync(TextDocument textDocument, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.SolutionCrawler.AggregateIncrementalAnalyzer/<NonSourceDocumentResetAsync>d__15")]
public sealed virtual Task NonSourceDocumentResetAsync(TextDocument textDocument, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.SolutionCrawler.AggregateIncrementalAnalyzer/<AnalyzeNonSourceDocumentAsync>d__16")]
public sealed virtual Task AnalyzeNonSourceDocumentAsync(TextDocument textDocument, InvocationReasons reasons, CancellationToken cancellationToken);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
internal class Microsoft.CodeAnalysis.SolutionCrawler.DocumentDifferenceResult : object {
    [CompilerGeneratedAttribute]
private InvocationReasons <ChangeType>k__BackingField;
    [CompilerGeneratedAttribute]
private SyntaxNode <ChangedMember>k__BackingField;
    public InvocationReasons ChangeType { get; }
    public SyntaxNode ChangedMember { get; }
    public DocumentDifferenceResult(InvocationReasons changeType, SyntaxNode changedMember);
    [CompilerGeneratedAttribute]
public InvocationReasons get_ChangeType();
    [CompilerGeneratedAttribute]
public SyntaxNode get_ChangedMember();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[MetadataAttributeAttribute]
[AttributeUsageAttribute("4")]
internal class Microsoft.CodeAnalysis.SolutionCrawler.ExportPerLanguageIncrementalAnalyzerProviderAttribute : ExportAttribute {
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Language>k__BackingField;
    public string Name { get; }
    public string Language { get; }
    public ExportPerLanguageIncrementalAnalyzerProviderAttribute(string name, string language);
    [CompilerGeneratedAttribute]
public string get_Name();
    [CompilerGeneratedAttribute]
public string get_Language();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
internal static class Microsoft.CodeAnalysis.SolutionCrawler.Extensions : object {
    [ExtensionAttribute]
public static string ToBase64(string data);
    [ExtensionAttribute]
public static string DecodeBase64(string data);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal abstract class Microsoft.CodeAnalysis.SolutionCrawler.GlobalOperationAwareIdleProcessor : IdleProcessor {
    private IGlobalOperationNotificationService _globalOperationNotificationService;
    [NullableAttribute("2")]
private TaskCompletionSource`1<object> _globalOperation;
    private Task _globalOperationTask;
    protected Task GlobalOperationTask { get; }
    public GlobalOperationAwareIdleProcessor(IAsynchronousOperationListener listener, IGlobalOperationNotificationService globalOperationNotificationService, int backOffTimeSpanInMs, CancellationToken shutdownToken);
    protected Task get_GlobalOperationTask();
    protected abstract virtual void PauseOnGlobalOperation();
    private void OnGlobalOperationStarted(object sender, EventArgs e);
    private void OnGlobalOperationStopped(object sender, GlobalOperationEventArgs e);
    public virtual void Shutdown();
}
[ExportEventListenerAttribute("Workspace", "Mono.Cecil.CustomAttributeArgument[]")]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.SolutionCrawler.HostSolutionCrawlerWorkspaceEventListener : object {
    [NullableContextAttribute("1")]
public sealed virtual void StartListening(Workspace workspace, object serviceOpt);
    [NullableContextAttribute("1")]
public sealed virtual void StopListening(Workspace workspace);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal abstract class Microsoft.CodeAnalysis.SolutionCrawler.IdleProcessor : object {
    private static int MinimumDelayInMS;
    protected IAsynchronousOperationListener Listener;
    protected CancellationToken CancellationToken;
    protected int BackOffTimeSpanInMS;
    [NullableAttribute("2")]
private Task _processorTask;
    private int _lastAccessTimeInMS;
    public Task AsyncProcessorTask { get; }
    public IdleProcessor(IAsynchronousOperationListener listener, int backOffTimeSpanInMS, CancellationToken cancellationToken);
    protected abstract virtual Task WaitAsync(CancellationToken cancellationToken);
    protected abstract virtual Task ExecuteAsync();
    protected void Start();
    protected void UpdateLastAccessTime();
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.SolutionCrawler.IdleProcessor/<WaitForIdleAsync>d__11")]
protected Task WaitForIdleAsync(IExpeditableDelaySource expeditableDelaySource);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.SolutionCrawler.IdleProcessor/<ProcessAsync>d__12")]
private Task ProcessAsync();
    public virtual Task get_AsyncProcessorTask();
}
internal interface Microsoft.CodeAnalysis.SolutionCrawler.IDocumentDifferenceService {
    [NullableContextAttribute("1")]
public abstract virtual Task`1<DocumentDifferenceResult> GetDifferenceAsync(Document oldDocument, Document newDocument, CancellationToken cancellationToken);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.CodeAnalysis.SolutionCrawler.IncrementalAnalyzerBase : object {
    public virtual Task NewSolutionSnapshotAsync(Solution solution, CancellationToken cancellationToken);
    public virtual Task DocumentOpenAsync(Document document, CancellationToken cancellationToken);
    public virtual Task DocumentCloseAsync(Document document, CancellationToken cancellationToken);
    public virtual Task DocumentResetAsync(Document document, CancellationToken cancellationToken);
    public virtual bool NeedsReanalysisOnOptionChanged(object sender, OptionChangedEventArgs e);
    public virtual Task AnalyzeSyntaxAsync(Document document, InvocationReasons reasons, CancellationToken cancellationToken);
    public virtual Task AnalyzeDocumentAsync(Document document, SyntaxNode bodyOpt, InvocationReasons reasons, CancellationToken cancellationToken);
    public virtual Task AnalyzeProjectAsync(Project project, bool semanticsChanged, InvocationReasons reasons, CancellationToken cancellationToken);
    public virtual Task RemoveDocumentAsync(DocumentId documentId, CancellationToken cancellationToken);
    public virtual Task RemoveProjectAsync(ProjectId projectId, CancellationToken cancellation);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.CodeAnalysis.SolutionCrawler.IncrementalAnalyzerProviderBase : object {
    private List`1<Lazy`2<IPerLanguageIncrementalAnalyzerProvider, PerLanguageIncrementalAnalyzerProviderMetadata>> _providers;
    protected IncrementalAnalyzerProviderBase(string name, IEnumerable`1<Lazy`2<IPerLanguageIncrementalAnalyzerProvider, PerLanguageIncrementalAnalyzerProviderMetadata>> providers);
    public virtual IIncrementalAnalyzer CreateIncrementalAnalyzer(Workspace workspace);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal static class Microsoft.CodeAnalysis.SolutionCrawler.InternalSolutionCrawlerOptions : object {
    private static string LocalRegistryPath;
    public static Option2`1<bool> SolutionCrawler;
    public static Option2`1<bool> DirectDependencyPropagationOnly;
    public static Option2`1<int> ActiveFileWorkerBackOffTimeSpanInMS;
    public static Option2`1<int> AllFilesWorkerBackOffTimeSpanInMS;
    public static Option2`1<int> EntireProjectWorkerBackOffTimeSpanInMS;
    public static Option2`1<int> SemanticChangeBackOffTimeSpanInMS;
    public static Option2`1<int> ProjectPropagationBackOffTimeSpanInMS;
    public static Option2`1<int> PreviewBackOffTimeSpanInMS;
    private static InternalSolutionCrawlerOptions();
}
[ExportOptionProviderAttribute]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.SolutionCrawler.InternalSolutionCrawlerOptionsProvider : object {
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private ImmutableArray`1<IOption> <Options>k__BackingField;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ImmutableArray`1<IOption> Options { get; }
    [CompilerGeneratedAttribute]
public sealed virtual ImmutableArray`1<IOption> get_Options();
}
[NullableContextAttribute("1")]
internal interface Microsoft.CodeAnalysis.SolutionCrawler.IPerLanguageIncrementalAnalyzerProvider {
    public abstract virtual IIncrementalAnalyzer CreatePerLanguageIncrementalAnalyzer(Workspace workspace, IIncrementalAnalyzerProvider provider);
}
[NullableContextAttribute("1")]
internal interface Microsoft.CodeAnalysis.SolutionCrawler.ISolutionCrawlerProgressReporter {
    public bool InProgress { get; }
    public abstract virtual bool get_InProgress();
    [CompilerGeneratedAttribute]
public abstract virtual void add_ProgressChanged(EventHandler`1<ProgressData> value);
    [CompilerGeneratedAttribute]
public abstract virtual void remove_ProgressChanged(EventHandler`1<ProgressData> value);
}
[NullableContextAttribute("1")]
internal interface Microsoft.CodeAnalysis.SolutionCrawler.ISolutionCrawlerService {
    public abstract virtual void Reanalyze(Workspace workspace, IIncrementalAnalyzer analyzer, IEnumerable`1<ProjectId> projectIds, IEnumerable`1<DocumentId> documentIds, bool highPriority);
    public abstract virtual ISolutionCrawlerProgressReporter GetProgressReporter(Workspace workspace);
}
internal interface Microsoft.CodeAnalysis.SolutionCrawler.IWorkCoordinatorPriorityService {
    [NullableContextAttribute("1")]
public abstract virtual Task`1<bool> IsLowPriorityAsync(Document document, CancellationToken cancellationToken);
}
[ExportEventListenerAttribute("Workspace", "Mono.Cecil.CustomAttributeArgument[]")]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.SolutionCrawler.MiscSolutionCrawlerWorkspaceEventListener : object {
    [NullableContextAttribute("1")]
public sealed virtual void StartListening(Workspace workspace, object serviceOpt);
    [NullableContextAttribute("1")]
public sealed virtual void StopListening(Workspace workspace);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
internal class Microsoft.CodeAnalysis.SolutionCrawler.PerLanguageIncrementalAnalyzerProviderMetadata : LanguageMetadata {
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    public string Name { get; }
    [NullableContextAttribute("1")]
public PerLanguageIncrementalAnalyzerProviderMetadata(IDictionary`2<string, object> data);
    [CompilerGeneratedAttribute]
public string get_Name();
}
[IsReadOnlyAttribute]
internal class Microsoft.CodeAnalysis.SolutionCrawler.ProgressData : ValueType {
    [CompilerGeneratedAttribute]
private ProgressStatus <Status>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<int> <PendingItemCount>k__BackingField;
    public ProgressStatus Status { get; }
    public Nullable`1<int> PendingItemCount { get; }
    public ProgressData(ProgressStatus type, Nullable`1<int> pendingItemCount);
    [CompilerGeneratedAttribute]
public ProgressStatus get_Status();
    [CompilerGeneratedAttribute]
public Nullable`1<int> get_PendingItemCount();
}
internal enum Microsoft.CodeAnalysis.SolutionCrawler.ProgressStatus : Enum {
    public int value__;
    public static ProgressStatus Started;
    public static ProgressStatus Paused;
    public static ProgressStatus PendingItemCountUpdated;
    public static ProgressStatus Evaluating;
    public static ProgressStatus Stopped;
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal static class Microsoft.CodeAnalysis.SolutionCrawler.SolutionCrawlerLogger : object {
    private static string Id;
    private static string Kind;
    private static string Analyzer;
    private static string DocumentCount;
    private static string Languages;
    private static string HighPriority;
    private static string Enabled;
    private static string AnalyzerCount;
    private static string PersistentStorage;
    private static string GlobalOperation;
    private static string HigherPriority;
    private static string LowerPriority;
    private static string TopLevel;
    private static string MemberLevel;
    private static string NewWorkItem;
    private static string UpdateWorkItem;
    private static string ProjectEnqueue;
    private static string ResetStates;
    private static string ProjectNotExist;
    private static string DocumentNotExist;
    private static string ProcessProject;
    private static string OpenDocument;
    private static string CloseDocument;
    private static string SolutionHash;
    private static string ProcessDocument;
    private static string ProcessDocumentCancellation;
    private static string ProcessProjectCancellation;
    private static string ActiveFileEnqueue;
    private static string ActiveFileProcessDocument;
    private static string ActiveFileProcessDocumentCancellation;
    private static string Max;
    private static string Min;
    private static string Median;
    private static string Mean;
    private static string Mode;
    private static string Range;
    private static string Count;
    public static void LogRegistration(int correlationId, Workspace workspace);
    public static void LogUnregistration(int correlationId);
    public static void LogReanalyze(int correlationId, IIncrementalAnalyzer analyzer, int documentCount, string languages, bool highPriority);
    public static void LogOptionChanged(int correlationId, bool value);
    public static void LogAnalyzers(int correlationId, Workspace workspace, ImmutableArray`1<IIncrementalAnalyzer> reordered, bool onlyHighPriorityAnalyzer);
    private static void LogAnalyzersWorker(FunctionId analyzersId, FunctionId analyzerId, int correlationId, Workspace workspace, ImmutableArray`1<IIncrementalAnalyzer> reordered);
    public static void LogWorkCoordinatorShutdownTimeout(int correlationId);
    public static void LogWorkspaceEvent(LogAggregator logAggregator, int kind);
    public static void LogWorkCoordinatorShutdown(int correlationId, LogAggregator logAggregator);
    public static void LogGlobalOperation(LogAggregator logAggregator);
    public static void LogActiveFileEnqueue(LogAggregator logAggregator);
    public static void LogWorkItemEnqueue(LogAggregator logAggregator, ProjectId _);
    public static void LogWorkItemEnqueue(LogAggregator logAggregator, string language, DocumentId documentId, InvocationReasons reasons, bool lowPriority, SyntaxPath activeMember, bool added);
    public static void LogHigherPriority(LogAggregator logAggregator, Guid documentId);
    public static void LogResetStates(LogAggregator logAggregator);
    public static void LogIncrementalAnalyzerProcessorStatistics(int correlationId, Solution solution, LogAggregator logAggregator, ImmutableArray`1<IIncrementalAnalyzer> analyzers);
    private static int GetSolutionHash(Solution solution);
    private static string CreateProperty(string parent, string child);
    public static void LogProcessCloseDocument(LogAggregator logAggregator, Guid documentId);
    public static void LogProcessOpenDocument(LogAggregator logAggregator, Guid documentId);
    public static void LogProcessActiveFileDocument(LogAggregator logAggregator, Guid _, bool processed);
    public static void LogProcessDocument(LogAggregator logAggregator, Guid documentId, bool processed);
    public static void LogProcessDocumentNotExist(LogAggregator logAggregator);
    public static void LogProcessProject(LogAggregator logAggregator, Guid projectId, bool processed);
    public static void LogProcessProjectNotExist(LogAggregator logAggregator);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExportWorkspaceServiceAttribute("Microsoft.CodeAnalysis.SolutionCrawler.ISolutionCrawlerRegistrationService", "Host")]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.SolutionCrawler.SolutionCrawlerRegistrationService : object {
    private static string Default;
    private object _gate;
    private SolutionCrawlerProgressReporter _progressReporter;
    private IAsynchronousOperationListener _listener;
    private Dictionary`2<Workspace, WorkCoordinator> _documentWorkCoordinatorMap;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private ImmutableDictionary`2<string, ImmutableArray`1<Lazy`2<IIncrementalAnalyzerProvider, IncrementalAnalyzerProviderMetadata>>> _analyzerProviders;
    public static string EnqueueItem;
    [ImportingConstructorAttribute]
[ObsoleteAttribute("This exported object must be obtained through the MEF export provider.", "True")]
public SolutionCrawlerRegistrationService(IEnumerable`1<Lazy`2<IIncrementalAnalyzerProvider, IncrementalAnalyzerProviderMetadata>> analyzerProviders, IAsynchronousOperationListenerProvider listenerProvider);
    public sealed virtual void Register(Workspace workspace);
    public void EnsureRegistration(Workspace workspace, bool initializeLazily);
    public sealed virtual void Unregister(Workspace workspace, bool blockingShutdown);
    public sealed virtual void AddAnalyzerProvider(IIncrementalAnalyzerProvider provider, IncrementalAnalyzerProviderMetadata metadata);
    public void Reanalyze(Workspace workspace, IIncrementalAnalyzer analyzer, IEnumerable`1<ProjectId> projectIds, IEnumerable`1<DocumentId> documentIds, bool highPriority);
    [IteratorStateMachineAttribute("Microsoft.CodeAnalysis.SolutionCrawler.SolutionCrawlerRegistrationService/<GetAnalyzerProviders>d__14")]
private IEnumerable`1<Lazy`2<IIncrementalAnalyzerProvider, IncrementalAnalyzerProviderMetadata>> GetAnalyzerProviders(string workspaceKind);
    private static bool TryGetProvider(string kind, ImmutableArray`1<Lazy`2<IIncrementalAnalyzerProvider, IncrementalAnalyzerProviderMetadata>> lazyProviders, Lazy`2& lazyProvider);
    [ConditionalAttribute("DEBUG")]
private static void AssertAnalyzerProviders(ImmutableDictionary`2<string, ImmutableArray`1<Lazy`2<IIncrementalAnalyzerProvider, IncrementalAnalyzerProviderMetadata>>> analyzerProviders);
    private static bool IsDefaultProvider(IncrementalAnalyzerProviderMetadata providerMetadata);
    internal TestAccessor GetTestAccessor();
}
internal abstract class Microsoft.CodeAnalysis.SolutionCrawler.State.AbstractAnalyzerState`3 : object {
    protected ConcurrentDictionary`2<TKey, CacheEntry<TKey, TValue, TData>> DataCache;
    public int Count { get; }
    protected abstract virtual TKey GetCacheKey(TValue value);
    protected abstract virtual Solution GetSolution(TValue value);
    protected abstract virtual bool ShouldCache(TValue value);
    protected abstract virtual int GetCount(TData data);
    protected abstract virtual Task`1<Stream> ReadStreamAsync(IPersistentStorage storage, TValue value, CancellationToken cancellationToken);
    protected abstract virtual TData TryGetExistingData(Stream stream, TValue value, CancellationToken cancellationToken);
    protected abstract virtual void WriteTo(Stream stream, TData data, CancellationToken cancellationToken);
    protected abstract virtual Task`1<bool> WriteStreamAsync(IPersistentStorage storage, TValue value, Stream stream, CancellationToken cancellationToken);
    public int get_Count();
    public int GetDataCount(TKey key);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.SolutionCrawler.State.AbstractAnalyzerState`3/<TryGetExistingDataAsync>d__12")]
public Task`1<TData> TryGetExistingDataAsync(TValue value, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.SolutionCrawler.State.AbstractAnalyzerState`3/<PersistAsync>d__13")]
public Task PersistAsync(TValue value, TData data, CancellationToken cancellationToken);
    public virtual bool Remove(TKey id);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.SolutionCrawler.State.AbstractAnalyzerState`3/<WriteToStreamAsync>d__15")]
private Task`1<bool> WriteToStreamAsync(TValue value, TData data, CancellationToken cancellationToken);
}
internal abstract class Microsoft.CodeAnalysis.SolutionCrawler.State.AbstractDocumentAnalyzerState`1 : AbstractAnalyzerState`3<DocumentId, Document, T> {
    protected string StateName { get; }
    protected abstract virtual string get_StateName();
    protected virtual DocumentId GetCacheKey(Document value);
    protected virtual Solution GetSolution(Document value);
    protected virtual bool ShouldCache(Document value);
    protected virtual Task`1<Stream> ReadStreamAsync(IPersistentStorage storage, Document value, CancellationToken cancellationToken);
    protected virtual Task`1<bool> WriteStreamAsync(IPersistentStorage storage, Document value, Stream stream, CancellationToken cancellationToken);
}
internal abstract class Microsoft.CodeAnalysis.SpellCheck.AbstractSpellCheckCodeFixProvider`1 : CodeFixProvider {
    private static int MinTokenLength;
    private static Char[] s_punctuation;
    private static AbstractSpellCheckCodeFixProvider`1();
    public virtual FixAllProvider GetFixAllProvider();
    protected abstract virtual bool IsGeneric(SyntaxToken nameToken);
    protected abstract virtual bool IsGeneric(TSimpleName nameNode);
    protected abstract virtual bool IsGeneric(CompletionItem completionItem);
    protected abstract virtual SyntaxToken CreateIdentifier(SyntaxToken nameToken, string newName);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.SpellCheck.AbstractSpellCheckCodeFixProvider`1/<RegisterCodeFixesAsync>d__6")]
public virtual Task RegisterCodeFixesAsync(CodeFixContext context);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.SpellCheck.AbstractSpellCheckCodeFixProvider`1/<CheckNodeAsync>d__7")]
private Task CheckNodeAsync(CodeFixContext context, Document document, SyntaxNode node, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.SpellCheck.AbstractSpellCheckCodeFixProvider`1/<CheckTokenAsync>d__8")]
private Task CheckTokenAsync(CodeFixContext context, Document document, SyntaxToken token, CancellationToken cancellationToken);
    protected abstract virtual bool ShouldSpellCheck(TSimpleName name);
    protected abstract virtual bool DescendIntoChildren(SyntaxNode arg);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.SpellCheck.AbstractSpellCheckCodeFixProvider`1/<CreateSpellCheckCodeIssueAsync>d__11")]
private Task CreateSpellCheckCodeIssueAsync(CodeFixContext context, SyntaxToken nameToken, bool isGeneric, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.SpellCheck.AbstractSpellCheckCodeFixProvider`1/<CheckItemsAsync>d__12")]
private Task CheckItemsAsync(CodeFixContext context, SyntaxToken nameToken, bool isGeneric, CompletionList completionList, WordSimilarityChecker similarityChecker);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.SpellCheck.AbstractSpellCheckCodeFixProvider`1/<GetInsertionTextAsync>d__14")]
private static Task`1<string> GetInsertionTextAsync(Document document, CompletionItem item, TextSpan completionListSpan, CancellationToken cancellationToken);
    private SpellCheckCodeAction<TSimpleName> CreateCodeAction(SyntaxToken nameToken, string oldName, string newName, Document document);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.SpellCheck.AbstractSpellCheckCodeFixProvider`1/<UpdateAsync>d__16")]
private Task`1<Document> UpdateAsync(Document document, SyntaxToken nameToken, string newName, CancellationToken cancellationToken);
}
internal abstract class Microsoft.CodeAnalysis.SplitOrMergeIfStatements.AbstractMergeConsecutiveIfStatementsCodeRefactoringProvider : AbstractMergeIfStatementsCodeRefactoringProvider {
    protected sealed virtual CodeAction CreateCodeAction(Func`2<CancellationToken, Task`1<Document>> createChangedDocument, MergeDirection direction, string ifKeywordText);
    protected sealed virtual Task`1<bool> CanBeMergedUpAsync(Document document, SyntaxNode ifOrElseIf, CancellationToken cancellationToken, SyntaxNode& firstIfOrElseIf);
    protected sealed virtual Task`1<bool> CanBeMergedDownAsync(Document document, SyntaxNode ifOrElseIf, CancellationToken cancellationToken, SyntaxNode& secondIfOrElseIf);
    protected sealed virtual SyntaxNode GetChangedRoot(Document document, SyntaxNode root, SyntaxNode firstIfOrElseIf, SyntaxNode secondIfOrElseIf);
    private static bool CanBeMergedWithParent(ISyntaxFactsService syntaxFacts, IIfLikeStatementGenerator ifGenerator, SyntaxNode ifOrElseIf, SyntaxNode& parentIfOrElseIf);
    private static bool CanBeMergedWithElseIf(ISyntaxFactsService syntaxFacts, IIfLikeStatementGenerator ifGenerator, SyntaxNode ifOrElseIf, SyntaxNode& elseIfClause);
    private static Task`1<bool> CanBeMergedWithPreviousStatementAsync(Document document, ISyntaxFactsService syntaxFacts, IIfLikeStatementGenerator ifGenerator, SyntaxNode ifOrElseIf, CancellationToken cancellationToken, SyntaxNode& previousStatement);
    private static Task`1<bool> CanBeMergedWithNextStatementAsync(Document document, ISyntaxFactsService syntaxFacts, IIfLikeStatementGenerator ifGenerator, SyntaxNode ifOrElseIf, CancellationToken cancellationToken, SyntaxNode& nextStatement);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.SplitOrMergeIfStatements.AbstractMergeConsecutiveIfStatementsCodeRefactoringProvider/<CanStatementsBeMergedAsync>d__8")]
private static Task`1<bool> CanStatementsBeMergedAsync(Document document, ISyntaxFactsService syntaxFacts, IIfLikeStatementGenerator ifGenerator, SyntaxNode firstStatement, SyntaxNode secondStatement, CancellationToken cancellationToken);
    private static bool TryGetSiblingStatement(ISyntaxFactsService syntaxFacts, SyntaxNode ifOrElseIf, int relativeIndex, SyntaxNode& statement);
    private static bool ContainEquivalentStatements(ISyntaxFactsService syntaxFacts, SyntaxNode ifStatement1, SyntaxNode ifStatement2, IReadOnlyList`1& statements);
}
internal abstract class Microsoft.CodeAnalysis.SplitOrMergeIfStatements.AbstractMergeIfStatementsCodeRefactoringProvider : CodeRefactoringProvider {
    protected abstract virtual bool IsApplicableSpan(SyntaxNode node, TextSpan span, SyntaxNode& ifOrElseIf);
    protected abstract virtual CodeAction CreateCodeAction(Func`2<CancellationToken, Task`1<Document>> createChangedDocument, MergeDirection direction, string ifKeywordText);
    protected abstract virtual Task`1<bool> CanBeMergedUpAsync(Document document, SyntaxNode ifOrElseIf, CancellationToken cancellationToken, SyntaxNode& upperIfOrElseIf);
    protected abstract virtual Task`1<bool> CanBeMergedDownAsync(Document document, SyntaxNode ifOrElseIf, CancellationToken cancellationToken, SyntaxNode& lowerIfOrElseIf);
    protected abstract virtual SyntaxNode GetChangedRoot(Document document, SyntaxNode root, SyntaxNode upperIfOrElseIf, SyntaxNode lowerIfOrElseIf);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.SplitOrMergeIfStatements.AbstractMergeIfStatementsCodeRefactoringProvider/<ComputeRefactoringsAsync>d__5")]
public sealed virtual Task ComputeRefactoringsAsync(CodeRefactoringContext context);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.SplitOrMergeIfStatements.AbstractMergeIfStatementsCodeRefactoringProvider/<RefactorAsync>d__6")]
private Task`1<Document> RefactorAsync(Document document, TextSpan upperIfOrElseIfSpan, TextSpan lowerIfOrElseIfSpan, CancellationToken cancellationToken);
    protected static IReadOnlyList`1<SyntaxNode> WalkDownScopeBlocks(ISyntaxFactsService syntaxFacts, IReadOnlyList`1<SyntaxNode> statements);
    protected static IReadOnlyList`1<SyntaxNode> WalkUpScopeBlocks(ISyntaxFactsService syntaxFacts, IReadOnlyList`1<SyntaxNode> statements);
    [CompilerGeneratedAttribute]
internal static SyntaxNode <RefactorAsync>g__FindIfOrElseIf|6_0(TextSpan span, IIfLikeStatementGenerator ifGenerator, SyntaxNode root);
}
internal abstract class Microsoft.CodeAnalysis.SplitOrMergeIfStatements.AbstractMergeNestedIfStatementsCodeRefactoringProvider : AbstractMergeIfStatementsCodeRefactoringProvider {
    protected sealed virtual CodeAction CreateCodeAction(Func`2<CancellationToken, Task`1<Document>> createChangedDocument, MergeDirection direction, string ifKeywordText);
    protected sealed virtual Task`1<bool> CanBeMergedUpAsync(Document document, SyntaxNode ifOrElseIf, CancellationToken cancellationToken, SyntaxNode& outerIfOrElseIf);
    protected sealed virtual Task`1<bool> CanBeMergedDownAsync(Document document, SyntaxNode ifOrElseIf, CancellationToken cancellationToken, SyntaxNode& innerIfStatement);
    protected sealed virtual SyntaxNode GetChangedRoot(Document document, SyntaxNode root, SyntaxNode outerIfOrElseIf, SyntaxNode innerIfStatement);
    private static bool IsFirstStatementOfIfOrElseIf(ISyntaxFactsService syntaxFacts, IIfLikeStatementGenerator ifGenerator, SyntaxNode statement, SyntaxNode& ifOrElseIf);
    private static bool IsFirstStatementIfStatement(ISyntaxFactsService syntaxFacts, IIfLikeStatementGenerator ifGenerator, SyntaxNode ifOrElseIf, SyntaxNode& ifStatement);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.SplitOrMergeIfStatements.AbstractMergeNestedIfStatementsCodeRefactoringProvider/<CanBeMergedAsync>d__6")]
private static Task`1<bool> CanBeMergedAsync(Document document, ISyntaxFactsService syntaxFacts, IIfLikeStatementGenerator ifGenerator, SyntaxNode outerIfOrElseIf, SyntaxNode innerIfStatement, CancellationToken cancellationToken);
    private static bool IsElseIfOrElseClauseEquivalent(ISyntaxFactsService syntaxFacts, IIfLikeStatementGenerator ifGenerator, SyntaxNode elseIfOrElseClause1, SyntaxNode elseIfOrElseClause2);
}
internal abstract class Microsoft.CodeAnalysis.SplitOrMergeIfStatements.AbstractSplitIfStatementCodeRefactoringProvider : CodeRefactoringProvider {
    protected abstract virtual int GetLogicalExpressionKind(ISyntaxKindsService syntaxKinds);
    protected abstract virtual CodeAction CreateCodeAction(Func`2<CancellationToken, Task`1<Document>> createChangedDocument, string ifKeywordText);
    protected abstract virtual Task`1<SyntaxNode> GetChangedRootAsync(Document document, SyntaxNode root, SyntaxNode ifOrElseIf, SyntaxNode leftCondition, SyntaxNode rightCondition, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.SplitOrMergeIfStatements.AbstractSplitIfStatementCodeRefactoringProvider/<ComputeRefactoringsAsync>d__3")]
public sealed virtual Task ComputeRefactoringsAsync(CodeRefactoringContext context);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.SplitOrMergeIfStatements.AbstractSplitIfStatementCodeRefactoringProvider/<RefactorAsync>d__4")]
private Task`1<Document> RefactorAsync(Document document, TextSpan tokenSpan, TextSpan ifOrElseIfSpan, CancellationToken cancellationToken);
    private static bool IsPartOfBinaryExpressionChain(SyntaxToken token, int syntaxKind, SyntaxNode& rootExpression);
    private static ValueTuple`2<SyntaxNode, SyntaxNode> SplitBinaryExpressionChain(SyntaxToken token, SyntaxNode rootExpression, ISyntaxFactsService syntaxFacts);
}
internal abstract class Microsoft.CodeAnalysis.SplitOrMergeIfStatements.AbstractSplitIntoConsecutiveIfStatementsCodeRefactoringProvider : AbstractSplitIfStatementCodeRefactoringProvider {
    protected sealed virtual int GetLogicalExpressionKind(ISyntaxKindsService syntaxKinds);
    protected sealed virtual CodeAction CreateCodeAction(Func`2<CancellationToken, Task`1<Document>> createChangedDocument, string ifKeywordText);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.SplitOrMergeIfStatements.AbstractSplitIntoConsecutiveIfStatementsCodeRefactoringProvider/<GetChangedRootAsync>d__2")]
protected sealed virtual Task`1<SyntaxNode> GetChangedRootAsync(Document document, SyntaxNode root, SyntaxNode ifOrElseIf, SyntaxNode leftCondition, SyntaxNode rightCondition, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.SplitOrMergeIfStatements.AbstractSplitIntoConsecutiveIfStatementsCodeRefactoringProvider/<CanBeSeparateStatementsAsync>d__3")]
private static Task`1<bool> CanBeSeparateStatementsAsync(Document document, ISyntaxFactsService syntaxFacts, IIfLikeStatementGenerator ifGenerator, SyntaxNode ifOrElseIf, CancellationToken cancellationToken);
}
internal abstract class Microsoft.CodeAnalysis.SplitOrMergeIfStatements.AbstractSplitIntoNestedIfStatementsCodeRefactoringProvider : AbstractSplitIfStatementCodeRefactoringProvider {
    protected sealed virtual int GetLogicalExpressionKind(ISyntaxKindsService syntaxKinds);
    protected sealed virtual CodeAction CreateCodeAction(Func`2<CancellationToken, Task`1<Document>> createChangedDocument, string ifKeywordText);
    protected sealed virtual Task`1<SyntaxNode> GetChangedRootAsync(Document document, SyntaxNode root, SyntaxNode ifOrElseIf, SyntaxNode leftCondition, SyntaxNode rightCondition, CancellationToken cancellationToken);
}
internal interface Microsoft.CodeAnalysis.SplitOrMergeIfStatements.IIfLikeStatementGenerator {
    public abstract virtual bool IsIfOrElseIf(SyntaxNode node);
    public abstract virtual bool IsCondition(SyntaxNode expression, SyntaxNode& ifOrElseIf);
    public abstract virtual bool IsElseIfClause(SyntaxNode node, SyntaxNode& parentIfOrElseIf);
    public abstract virtual bool HasElseIfClause(SyntaxNode ifOrElseIf, SyntaxNode& elseIfClause);
    public abstract virtual SyntaxNode GetCondition(SyntaxNode ifOrElseIf);
    public abstract virtual SyntaxNode GetRootIfStatement(SyntaxNode ifOrElseIf);
    public abstract virtual ImmutableArray`1<SyntaxNode> GetElseIfAndElseClauses(SyntaxNode ifOrElseIf);
    public abstract virtual SyntaxNode WithCondition(SyntaxNode ifOrElseIf, SyntaxNode condition);
    public abstract virtual SyntaxNode WithStatementInBlock(SyntaxNode ifOrElseIf, SyntaxNode statement);
    public abstract virtual SyntaxNode WithStatementsOf(SyntaxNode ifOrElseIf, SyntaxNode otherIfOrElseIf);
    public abstract virtual SyntaxNode WithElseIfAndElseClausesOf(SyntaxNode ifStatement, SyntaxNode otherIfStatement);
    public abstract virtual SyntaxNode ToIfStatement(SyntaxNode ifOrElseIf);
    public abstract virtual SyntaxNode ToElseIfClause(SyntaxNode ifOrElseIf);
    public abstract virtual void InsertElseIfClause(SyntaxEditor editor, SyntaxNode afterIfOrElseIf, SyntaxNode elseIfClause);
    public abstract virtual void RemoveElseIfClause(SyntaxEditor editor, SyntaxNode elseIfClause);
}
internal abstract class Microsoft.CodeAnalysis.Structure.AbstractBlockStructureProvider : BlockStructureProvider {
    private ImmutableDictionary`2<Type, ImmutableArray`1<AbstractSyntaxStructureProvider>> _nodeProviderMap;
    private ImmutableDictionary`2<int, ImmutableArray`1<AbstractSyntaxStructureProvider>> _triviaProviderMap;
    protected AbstractBlockStructureProvider(ImmutableDictionary`2<Type, ImmutableArray`1<AbstractSyntaxStructureProvider>> defaultNodeOutlinerMap, ImmutableDictionary`2<int, ImmutableArray`1<AbstractSyntaxStructureProvider>> defaultTriviaOutlinerMap);
    public virtual void ProvideBlockStructure(BlockStructureContext context);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.Structure.AbstractBlockStructureProvider/<ProvideBlockStructureAsync>d__4")]
public virtual Task ProvideBlockStructureAsync(BlockStructureContext context);
    private void ProvideBlockStructureWorker(BlockStructureContext context, SyntaxNode syntaxRoot);
}
internal abstract class Microsoft.CodeAnalysis.Structure.AbstractSyntaxNodeStructureProvider`1 : AbstractSyntaxStructureProvider {
    public sealed virtual void CollectBlockSpans(SyntaxTrivia trivia, TemporaryArray`1& spans, BlockStructureOptionProvider optionProvider, CancellationToken cancellationToken);
    [NullableContextAttribute("1")]
public sealed virtual void CollectBlockSpans(SyntaxNode node, TemporaryArray`1& spans, BlockStructureOptionProvider optionProvider, CancellationToken cancellationToken);
    [NullableContextAttribute("1")]
protected abstract virtual void CollectBlockSpans(TSyntaxNode node, TemporaryArray`1& spans, BlockStructureOptionProvider optionProvider, CancellationToken cancellationToken);
}
internal abstract class Microsoft.CodeAnalysis.Structure.AbstractSyntaxStructureProvider : object {
    [NullableContextAttribute("1")]
public abstract virtual void CollectBlockSpans(SyntaxNode node, TemporaryArray`1& spans, BlockStructureOptionProvider optionProvider, CancellationToken cancellationToken);
    public abstract virtual void CollectBlockSpans(SyntaxTrivia trivia, TemporaryArray`1& spans, BlockStructureOptionProvider optionProvider, CancellationToken cancellationToken);
}
internal abstract class Microsoft.CodeAnalysis.Structure.AbstractSyntaxTriviaStructureProvider : AbstractSyntaxStructureProvider {
    [NullableContextAttribute("1")]
public sealed virtual void CollectBlockSpans(SyntaxNode node, TemporaryArray`1& spans, BlockStructureOptionProvider optionProvider, CancellationToken cancellationToken);
}
[IsReadOnlyAttribute]
internal class Microsoft.CodeAnalysis.Structure.BlockSpan : ValueType {
    private static string Ellipses;
    [CompilerGeneratedAttribute]
private bool <IsCollapsible>k__BackingField;
    [CompilerGeneratedAttribute]
private TextSpan <TextSpan>k__BackingField;
    [CompilerGeneratedAttribute]
private TextSpan <HintSpan>k__BackingField;
    [CompilerGeneratedAttribute]
private string <BannerText>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <AutoCollapse>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsDefaultCollapsed>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Type>k__BackingField;
    public bool IsCollapsible { get; }
    public TextSpan TextSpan { get; }
    public TextSpan HintSpan { get; }
    public string BannerText { get; }
    public bool AutoCollapse { get; }
    public bool IsDefaultCollapsed { get; }
    public string Type { get; }
    public BlockSpan(string type, bool isCollapsible, TextSpan textSpan, string bannerText, bool autoCollapse, bool isDefaultCollapsed);
    public BlockSpan(string type, bool isCollapsible, TextSpan textSpan, TextSpan hintSpan, string bannerText, bool autoCollapse, bool isDefaultCollapsed);
    [CompilerGeneratedAttribute]
public bool get_IsCollapsible();
    [CompilerGeneratedAttribute]
public TextSpan get_TextSpan();
    [CompilerGeneratedAttribute]
public TextSpan get_HintSpan();
    [CompilerGeneratedAttribute]
public string get_BannerText();
    [CompilerGeneratedAttribute]
public bool get_AutoCollapse();
    [CompilerGeneratedAttribute]
public bool get_IsDefaultCollapsed();
    [CompilerGeneratedAttribute]
public string get_Type();
    public virtual string ToString();
    internal BlockSpan WithType(string type);
    internal BlockSpan WithIsCollapsible(bool isCollapsible);
    internal BlockSpan With(Optional`1<bool> isCollapsible, Optional`1<TextSpan> textSpan, Optional`1<TextSpan> hintSpan, Optional`1<string> type, Optional`1<string> bannerText, Optional`1<bool> autoCollapse, Optional`1<bool> isDefaultCollapsed);
}
internal class Microsoft.CodeAnalysis.Structure.BlockSpanCollector : object {
    [NullableAttribute("1")]
private BlockStructureOptionProvider _optionProvider;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private ImmutableDictionary`2<Type, ImmutableArray`1<AbstractSyntaxStructureProvider>> _nodeProviderMap;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private ImmutableDictionary`2<int, ImmutableArray`1<AbstractSyntaxStructureProvider>> _triviaProviderMap;
    private CancellationToken _cancellationToken;
    [NullableContextAttribute("1")]
private BlockSpanCollector(BlockStructureOptionProvider optionProvider, ImmutableDictionary`2<Type, ImmutableArray`1<AbstractSyntaxStructureProvider>> nodeOutlinerMap, ImmutableDictionary`2<int, ImmutableArray`1<AbstractSyntaxStructureProvider>> triviaOutlinerMap, CancellationToken cancellationToken);
    [NullableContextAttribute("1")]
public static void CollectBlockSpans(SyntaxNode syntaxRoot, BlockStructureOptionProvider optionProvider, ImmutableDictionary`2<Type, ImmutableArray`1<AbstractSyntaxStructureProvider>> nodeOutlinerMap, ImmutableDictionary`2<int, ImmutableArray`1<AbstractSyntaxStructureProvider>> triviaOutlinerMap, TemporaryArray`1& spans, CancellationToken cancellationToken);
    private void Collect(SyntaxNode root, TemporaryArray`1& spans);
    private void GetBlockSpans(SyntaxNode node, TemporaryArray`1& spans);
    private void GetBlockSpans(SyntaxToken token, TemporaryArray`1& spans);
    private void GetOutliningSpans(SyntaxTriviaList triviaList, TemporaryArray`1& spans);
}
internal class Microsoft.CodeAnalysis.Structure.BlockStructure : object {
    [CompilerGeneratedAttribute]
private ImmutableArray`1<BlockSpan> <Spans>k__BackingField;
    public ImmutableArray`1<BlockSpan> Spans { get; }
    public BlockStructure(ImmutableArray`1<BlockSpan> spans);
    [CompilerGeneratedAttribute]
public ImmutableArray`1<BlockSpan> get_Spans();
}
internal class Microsoft.CodeAnalysis.Structure.BlockStructureContext : object {
    private Builder<BlockSpan> _spans;
    [CompilerGeneratedAttribute]
private SyntaxTree <SyntaxTree>k__BackingField;
    [CompilerGeneratedAttribute]
private BlockStructureOptionProvider <OptionProvider>k__BackingField;
    [CompilerGeneratedAttribute]
private CancellationToken <CancellationToken>k__BackingField;
    public SyntaxTree SyntaxTree { get; }
    public BlockStructureOptionProvider OptionProvider { get; }
    public CancellationToken CancellationToken { get; }
    internal ImmutableArray`1<BlockSpan> Spans { get; }
    public BlockStructureContext(SyntaxTree syntaxTree, BlockStructureOptionProvider optionProvider, CancellationToken cancellationToken);
    [CompilerGeneratedAttribute]
public SyntaxTree get_SyntaxTree();
    [CompilerGeneratedAttribute]
public BlockStructureOptionProvider get_OptionProvider();
    [CompilerGeneratedAttribute]
public CancellationToken get_CancellationToken();
    internal ImmutableArray`1<BlockSpan> get_Spans();
    public void AddBlockSpan(BlockSpan span);
}
[ExtensionAttribute]
internal static class Microsoft.CodeAnalysis.Structure.BlockStructureExtensions : object {
    [ExtensionAttribute]
public static void Add(Builder<Type, ImmutableArray`1<AbstractSyntaxStructureProvider>> builder);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.CodeAnalysis.Structure.BlockStructureOptionProvider : object {
    private OptionSet _options;
    [CompilerGeneratedAttribute]
private bool <IsMetadataAsSource>k__BackingField;
    public bool IsMetadataAsSource { get; }
    public BlockStructureOptionProvider(OptionSet options, bool isMetadataAsSource);
    [CompilerGeneratedAttribute]
public bool get_IsMetadataAsSource();
    public T GetOption(PerLanguageOption2`1<T> option, string language);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal static class Microsoft.CodeAnalysis.Structure.BlockStructureOptions : object {
    public static PerLanguageOption2`1<bool> ShowBlockStructureGuidesForCommentsAndPreprocessorRegions;
    public static PerLanguageOption2`1<bool> ShowBlockStructureGuidesForDeclarationLevelConstructs;
    public static PerLanguageOption2`1<bool> ShowBlockStructureGuidesForCodeLevelConstructs;
    public static PerLanguageOption2`1<bool> ShowOutliningForCommentsAndPreprocessorRegions;
    public static PerLanguageOption2`1<bool> ShowOutliningForDeclarationLevelConstructs;
    public static PerLanguageOption2`1<bool> ShowOutliningForCodeLevelConstructs;
    public static PerLanguageOption2`1<bool> CollapseRegionsWhenCollapsingToDefinitions;
    public static PerLanguageOption2`1<int> MaximumBannerLength;
    private static BlockStructureOptions();
}
internal abstract class Microsoft.CodeAnalysis.Structure.BlockStructureProvider : object {
    public abstract virtual Task ProvideBlockStructureAsync(BlockStructureContext context);
    public virtual void ProvideBlockStructure(BlockStructureContext context);
}
internal abstract class Microsoft.CodeAnalysis.Structure.BlockStructureService : object {
    public string Language { get; }
    public static BlockStructureService GetService(Document document);
    public abstract virtual string get_Language();
    public abstract virtual Task`1<BlockStructure> GetBlockStructureAsync(Document document, CancellationToken cancellationToken);
    public virtual BlockStructure GetBlockStructure(Document document, CancellationToken cancellationToken);
}
internal abstract class Microsoft.CodeAnalysis.Structure.BlockStructureServiceWithProviders : BlockStructureService {
    private Workspace _workspace;
    private ImmutableArray`1<BlockStructureProvider> _providers;
    protected BlockStructureServiceWithProviders(Workspace workspace);
    protected virtual ImmutableArray`1<BlockStructureProvider> GetBuiltInProviders();
    private ImmutableArray`1<BlockStructureProvider> GetImportedProviders();
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.Structure.BlockStructureServiceWithProviders/<GetBlockStructureAsync>d__5")]
public virtual Task`1<BlockStructure> GetBlockStructureAsync(Document document, CancellationToken cancellationToken);
    public virtual BlockStructure GetBlockStructure(Document document, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.Structure.BlockStructureServiceWithProviders/<GetBlockStructureAsync>d__7")]
public Task`1<BlockStructure> GetBlockStructureAsync(SyntaxTree syntaxTree, OptionSet options, bool isMetadataAsSource, CancellationToken cancellationToken);
    public BlockStructure GetBlockStructure(SyntaxTree syntaxTree, OptionSet options, bool isMetadataAsSource, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.Structure.BlockStructureServiceWithProviders/<CreateContextAsync>d__9")]
private static Task`1<BlockStructureContext> CreateContextAsync(Document document, CancellationToken cancellationToken);
    private static BlockStructureContext CreateContext(SyntaxTree syntaxTree, OptionSet options, bool isMetadataAsSource, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.Structure.BlockStructureServiceWithProviders/<GetBlockStructureAsync>d__11")]
private static Task`1<BlockStructure> GetBlockStructureAsync(BlockStructureContext context, ImmutableArray`1<BlockStructureProvider> providers);
    private static BlockStructure GetBlockStructure(BlockStructureContext context, ImmutableArray`1<BlockStructureProvider> providers);
    private static BlockStructure CreateBlockStructure(BlockStructureContext context);
    private static BlockSpan UpdateBlockSpan(BlockSpan blockSpan, bool showIndentGuidesForCodeLevelConstructs, bool showIndentGuidesForDeclarationLevelConstructs, bool showIndentGuidesForCommentsAndPreprocessorRegions, bool showOutliningForCodeLevelConstructs, bool showOutliningForDeclarationLevelConstructs, bool showOutliningForCommentsAndPreprocessorRegions);
}
internal static class Microsoft.CodeAnalysis.Structure.BlockTypes : object {
    public static string Nonstructural;
    public static string Comment;
    public static string PreprocessorRegion;
    public static string Imports;
    public static string Namespace;
    public static string Type;
    public static string Member;
    public static string Statement;
    public static string Conditional;
    public static string Loop;
    public static string Expression;
    internal static bool IsCommentOrPreprocessorRegion(string type);
    internal static bool IsExpressionLevelConstruct(string type);
    internal static bool IsStatementLevelConstruct(string type);
    internal static bool IsCodeLevelConstruct(string type);
    internal static bool IsDeclarationLevelConstruct(string type);
}
internal static class Microsoft.CodeAnalysis.SymbolDisplayPartKindTags : object {
    public static string GetTag(SymbolDisplayPartKind kind);
}
[ExportWorkspaceServiceAttribute("Microsoft.CodeAnalysis.SymbolMapping.ISymbolMappingService", "Default")]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.SymbolMapping.DefaultSymbolMappingService : object {
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.SymbolMapping.DefaultSymbolMappingService/<MapSymbolAsync>d__1")]
public sealed virtual Task`1<SymbolMappingResult> MapSymbolAsync(Document document, SymbolKey symbolId, CancellationToken cancellationToken);
    public sealed virtual Task`1<SymbolMappingResult> MapSymbolAsync(Document document, ISymbol symbol, CancellationToken cancellationToken);
}
[NullableContextAttribute("1")]
internal interface Microsoft.CodeAnalysis.SymbolMapping.ISymbolMappingService {
    public abstract virtual Task`1<SymbolMappingResult> MapSymbolAsync(Document document, SymbolKey symbolId, CancellationToken cancellationToken);
    public abstract virtual Task`1<SymbolMappingResult> MapSymbolAsync(Document document, ISymbol symbol, CancellationToken cancellationToken);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.CodeAnalysis.SymbolMapping.SymbolMappingResult : object {
    [CompilerGeneratedAttribute]
private Project <Project>k__BackingField;
    [CompilerGeneratedAttribute]
private ISymbol <Symbol>k__BackingField;
    public Project Project { get; }
    public ISymbol Symbol { get; }
    public Solution Solution { get; }
    internal SymbolMappingResult(Project project, ISymbol symbol);
    [CompilerGeneratedAttribute]
public Project get_Project();
    [CompilerGeneratedAttribute]
public ISymbol get_Symbol();
    public Solution get_Solution();
}
[IsReadOnlyAttribute]
[DataContractAttribute]
public class Microsoft.CodeAnalysis.TaggedText : ValueType {
    [CompilerGeneratedAttribute]
private string <Tag>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Text>k__BackingField;
    [CompilerGeneratedAttribute]
private TaggedTextStyle <Style>k__BackingField;
    [CompilerGeneratedAttribute]
private string <NavigationTarget>k__BackingField;
    [CompilerGeneratedAttribute]
private string <NavigationHint>k__BackingField;
    [DataMemberAttribute]
public string Tag { get; }
    [DataMemberAttribute]
public string Text { get; }
    [DataMemberAttribute]
internal TaggedTextStyle Style { get; }
    [DataMemberAttribute]
internal string NavigationTarget { get; }
    [DataMemberAttribute]
internal string NavigationHint { get; }
    public TaggedText(string tag, string text);
    internal TaggedText(string tag, string text, TaggedTextStyle style, string navigationTarget, string navigationHint);
    [CompilerGeneratedAttribute]
public string get_Tag();
    [CompilerGeneratedAttribute]
public string get_Text();
    [CompilerGeneratedAttribute]
internal TaggedTextStyle get_Style();
    [CompilerGeneratedAttribute]
internal string get_NavigationTarget();
    [CompilerGeneratedAttribute]
internal string get_NavigationHint();
    public virtual string ToString();
}
[ExtensionAttribute]
internal static class Microsoft.CodeAnalysis.TaggedTextExtensions : object {
    private static string LeftToRightMarkerPrefix;
    [ExtensionAttribute]
public static ImmutableArray`1<TaggedText> ToTaggedText(IEnumerable`1<SymbolDisplayPart> displayParts);
    [ExtensionAttribute]
public static ImmutableArray`1<TaggedText> ToTaggedText(IEnumerable`1<SymbolDisplayPart> displayParts, TaggedTextStyle style);
    [ExtensionAttribute]
public static string JoinText(ImmutableArray`1<TaggedText> values);
    private static string Join(ImmutableArray`1<TaggedText> values);
    [ExtensionAttribute]
public static string ToClassificationTypeName(string taggedTextTag);
    [IteratorStateMachineAttribute("Microsoft.CodeAnalysis.TaggedTextExtensions/<ToClassifiedSpans>d__5")]
[ExtensionAttribute]
public static IEnumerable`1<ClassifiedSpan> ToClassifiedSpans(IEnumerable`1<TaggedText> parts);
    [ExtensionAttribute]
public static string ToVisibleDisplayString(TaggedText part, bool includeLeftToRightMarker);
    [ExtensionAttribute]
public static string ToVisibleDisplayString(IEnumerable`1<TaggedText> parts, bool includeLeftToRightMarker);
    [ExtensionAttribute]
public static string GetFullText(IEnumerable`1<TaggedText> parts);
    [ExtensionAttribute]
public static void AddAliasName(IList`1<TaggedText> parts, string text);
    [ExtensionAttribute]
public static void AddAssemblyName(IList`1<TaggedText> parts, string text);
    [ExtensionAttribute]
public static void AddClassName(IList`1<TaggedText> parts, string text);
    [ExtensionAttribute]
public static void AddDelegateName(IList`1<TaggedText> parts, string text);
    [ExtensionAttribute]
public static void AddEnumName(IList`1<TaggedText> parts, string text);
    [ExtensionAttribute]
public static void AddErrorTypeName(IList`1<TaggedText> parts, string text);
    [ExtensionAttribute]
public static void AddEventName(IList`1<TaggedText> parts, string text);
    [ExtensionAttribute]
public static void AddFieldName(IList`1<TaggedText> parts, string text);
    [ExtensionAttribute]
public static void AddInterfaceName(IList`1<TaggedText> parts, string text);
    [ExtensionAttribute]
public static void AddKeyword(IList`1<TaggedText> parts, string text);
    [ExtensionAttribute]
public static void AddLabelName(IList`1<TaggedText> parts, string text);
    [ExtensionAttribute]
public static void AddLineBreak(IList`1<TaggedText> parts, string text);
    [ExtensionAttribute]
public static void AddNumericLiteral(IList`1<TaggedText> parts, string text);
    [ExtensionAttribute]
public static void AddStringLiteral(IList`1<TaggedText> parts, string text);
    [ExtensionAttribute]
public static void AddLocalName(IList`1<TaggedText> parts, string text);
    [ExtensionAttribute]
public static void AddMethodName(IList`1<TaggedText> parts, string text);
    [ExtensionAttribute]
public static void AddModuleName(IList`1<TaggedText> parts, string text);
    [ExtensionAttribute]
public static void AddNamespaceName(IList`1<TaggedText> parts, string text);
    [ExtensionAttribute]
public static void AddOperator(IList`1<TaggedText> parts, string text);
    [ExtensionAttribute]
public static void AddParameterName(IList`1<TaggedText> parts, string text);
    [ExtensionAttribute]
public static void AddPropertyName(IList`1<TaggedText> parts, string text);
    [ExtensionAttribute]
public static void AddPunctuation(IList`1<TaggedText> parts, string text);
    [ExtensionAttribute]
public static void AddRangeVariableName(IList`1<TaggedText> parts, string text);
    [ExtensionAttribute]
public static void AddStructName(IList`1<TaggedText> parts, string text);
    [ExtensionAttribute]
public static void AddSpace(IList`1<TaggedText> parts, string text);
    [ExtensionAttribute]
public static void AddText(IList`1<TaggedText> parts, string text);
    [ExtensionAttribute]
public static void AddTypeParameterName(IList`1<TaggedText> parts, string text);
    [CompilerGeneratedAttribute]
internal static string <ToTaggedText>g__GetNavigationTarget|1_1(ISymbol symbol);
    [CompilerGeneratedAttribute]
internal static string <ToTaggedText>g__GetNavigationHint|1_2(ISymbol symbol);
}
[FlagsAttribute]
internal enum Microsoft.CodeAnalysis.TaggedTextStyle : Enum {
    public int value__;
    public static TaggedTextStyle None;
    public static TaggedTextStyle Strong;
    public static TaggedTextStyle Emphasis;
    public static TaggedTextStyle Underline;
    public static TaggedTextStyle Code;
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal static class Microsoft.CodeAnalysis.Text.TextUtilities : object {
    internal static int GetLengthOfLineBreak(SourceText text, int index);
    private static int GetLengthOfLineBreakSlow(SourceText text, int index, char c);
    public static void GetStartAndLengthOfLineBreakEndingAt(SourceText text, int index, Int32& startLinebreak, Int32& lengthLinebreak);
    internal static bool IsAnyLineBreakCharacter(char c);
}
public static class Microsoft.CodeAnalysis.TextTags : object {
    public static string Alias;
    public static string Assembly;
    public static string Class;
    public static string Delegate;
    public static string Enum;
    public static string ErrorType;
    public static string Event;
    public static string Field;
    public static string Interface;
    public static string Keyword;
    public static string Label;
    public static string LineBreak;
    public static string NumericLiteral;
    public static string StringLiteral;
    public static string Local;
    public static string Method;
    public static string Module;
    public static string Namespace;
    public static string Operator;
    public static string Parameter;
    public static string Property;
    public static string Punctuation;
    public static string Space;
    public static string Struct;
    public static string AnonymousTypeIndicator;
    public static string Text;
    public static string TypeParameter;
    public static string RangeVariable;
    public static string EnumMember;
    public static string ExtensionMethod;
    public static string Constant;
    public static string Record;
    internal static string ContainerStart;
    internal static string ContainerEnd;
}
internal abstract class Microsoft.CodeAnalysis.TodoComments.AbstractTodoCommentService : object {
    protected abstract virtual bool PreprocessorHasComment(SyntaxTrivia trivia);
    protected abstract virtual bool IsSingleLineComment(SyntaxTrivia trivia);
    protected abstract virtual bool IsMultilineComment(SyntaxTrivia trivia);
    protected abstract virtual bool IsIdentifierCharacter(char ch);
    protected abstract virtual string GetNormalizedText(string message);
    protected abstract virtual int GetCommentStartingIndex(string message);
    protected abstract virtual void AppendTodoComments(ImmutableArray`1<TodoCommentDescriptor> commentDescriptors, SyntacticDocument document, SyntaxTrivia trivia, ArrayBuilder`1<TodoComment> todoList);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.TodoComments.AbstractTodoCommentService/<GetTodoCommentsAsync>d__7")]
public sealed virtual Task`1<ImmutableArray`1<TodoComment>> GetTodoCommentsAsync(Document document, ImmutableArray`1<TodoCommentDescriptor> commentDescriptors, CancellationToken cancellationToken);
    private bool ContainsComments(SyntaxTrivia trivia);
    protected void AppendTodoCommentInfoFromSingleLine(ImmutableArray`1<TodoCommentDescriptor> commentDescriptors, string message, int start, ArrayBuilder`1<TodoComment> todoList);
    protected void ProcessMultilineComment(ImmutableArray`1<TodoCommentDescriptor> commentDescriptors, SyntacticDocument document, SyntaxTrivia trivia, int postfixLength, ArrayBuilder`1<TodoComment> todoList);
}
internal abstract class Microsoft.CodeAnalysis.TodoComments.AbstractTodoCommentsIncrementalAnalyzer : IncrementalAnalyzerBase {
    [NullableAttribute("1")]
private object _gate;
    [NullableAttribute("2")]
private string _lastOptionText;
    private ImmutableArray`1<TodoCommentDescriptor> _lastDescriptors;
    protected abstract virtual ValueTask ReportTodoCommentDataAsync(DocumentId documentId, ImmutableArray`1<TodoCommentData> data, CancellationToken cancellationToken);
    [NullableContextAttribute("1")]
public virtual bool NeedsReanalysisOnOptionChanged(object sender, OptionChangedEventArgs e);
    [NullableContextAttribute("1")]
public virtual Task RemoveDocumentAsync(DocumentId documentId, CancellationToken cancellationToken);
    private ImmutableArray`1<TodoCommentDescriptor> GetTodoCommentDescriptors(Document document);
    [NullableContextAttribute("1")]
[AsyncStateMachineAttribute("Microsoft.CodeAnalysis.TodoComments.AbstractTodoCommentsIncrementalAnalyzer/<AnalyzeSyntaxAsync>d__8")]
public virtual Task AnalyzeSyntaxAsync(Document document, InvocationReasons reasons, CancellationToken cancellationToken);
}
internal interface Microsoft.CodeAnalysis.TodoComments.ITodoCommentService {
    public abstract virtual Task`1<ImmutableArray`1<TodoComment>> GetTodoCommentsAsync(Document document, ImmutableArray`1<TodoCommentDescriptor> commentDescriptors, CancellationToken cancellationToken);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[IsReadOnlyAttribute]
internal class Microsoft.CodeAnalysis.TodoComments.TodoComment : ValueType {
    [CompilerGeneratedAttribute]
private TodoCommentDescriptor <Descriptor>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Message>k__BackingField;
    [CompilerGeneratedAttribute]
private int <Position>k__BackingField;
    public TodoCommentDescriptor Descriptor { get; }
    public string Message { get; }
    public int Position { get; }
    public TodoComment(TodoCommentDescriptor descriptor, string message, int position);
    [CompilerGeneratedAttribute]
public TodoCommentDescriptor get_Descriptor();
    [CompilerGeneratedAttribute]
public string get_Message();
    [CompilerGeneratedAttribute]
public int get_Position();
    private TodoCommentData CreateSerializableData(Document document, SourceText text, SyntaxTree tree);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.TodoComments.TodoComment/<ConvertAsync>d__11")]
public static Task ConvertAsync(Document document, ImmutableArray`1<TodoComment> todoComments, ArrayBuilder`1<TodoCommentData> converted, CancellationToken cancellationToken);
}
[IsReadOnlyAttribute]
internal class Microsoft.CodeAnalysis.TodoComments.TodoCommentDescriptor : ValueType {
    [CompilerGeneratedAttribute]
private string <Text>k__BackingField;
    [CompilerGeneratedAttribute]
private int <Priority>k__BackingField;
    public string Text { get; }
    public int Priority { get; }
    public TodoCommentDescriptor(string text, int priority);
    [CompilerGeneratedAttribute]
public string get_Text();
    [CompilerGeneratedAttribute]
public int get_Priority();
    public static ImmutableArray`1<TodoCommentDescriptor> Parse(string data);
}
[NullableContextAttribute("1")]
internal interface Microsoft.CodeAnalysis.UnifiedSuggestions.IUnifiedSuggestedAction {
    public Workspace Workspace { get; }
    public CodeAction OriginalCodeAction { get; }
    public CodeActionPriority CodeActionPriority { get; }
    public abstract virtual Workspace get_Workspace();
    public abstract virtual CodeAction get_OriginalCodeAction();
    public abstract virtual CodeActionPriority get_CodeActionPriority();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.CodeAnalysis.UnifiedSuggestions.UnifiedCodeFixSuggestedAction : UnifiedSuggestedAction {
    [CompilerGeneratedAttribute]
private CodeFix <CodeFix>k__BackingField;
    [CompilerGeneratedAttribute]
private object <Provider>k__BackingField;
    [NullableAttribute("2")]
[CompilerGeneratedAttribute]
private UnifiedSuggestedActionSet <FixAllFlavors>k__BackingField;
    public CodeFix CodeFix { get; }
    public object Provider { get; }
    [NullableAttribute("2")]
public UnifiedSuggestedActionSet FixAllFlavors { get; }
    public UnifiedCodeFixSuggestedAction(Workspace workspace, CodeAction codeAction, CodeActionPriority codeActionPriority, CodeFix codeFix, object provider, UnifiedSuggestedActionSet fixAllFlavors);
    [CompilerGeneratedAttribute]
public sealed virtual CodeFix get_CodeFix();
    [CompilerGeneratedAttribute]
public object get_Provider();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public UnifiedSuggestedActionSet get_FixAllFlavors();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.CodeAnalysis.UnifiedSuggestions.UnifiedCodeRefactoringSuggestedAction : UnifiedSuggestedAction {
    [CompilerGeneratedAttribute]
private CodeRefactoringProvider <CodeRefactoringProvider>k__BackingField;
    public CodeRefactoringProvider CodeRefactoringProvider { get; }
    public UnifiedCodeRefactoringSuggestedAction(Workspace workspace, CodeAction codeAction, CodeActionPriority codeActionPriority, CodeRefactoringProvider codeRefactoringProvider);
    [CompilerGeneratedAttribute]
public sealed virtual CodeRefactoringProvider get_CodeRefactoringProvider();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.CodeAnalysis.UnifiedSuggestions.UnifiedFixAllSuggestedAction : UnifiedSuggestedAction {
    [CompilerGeneratedAttribute]
private Diagnostic <Diagnostic>k__BackingField;
    [NullableAttribute("2")]
[CompilerGeneratedAttribute]
private FixAllState <FixAllState>k__BackingField;
    public Diagnostic Diagnostic { get; }
    [NullableAttribute("2")]
public FixAllState FixAllState { get; }
    public UnifiedFixAllSuggestedAction(Workspace workspace, CodeAction codeAction, CodeActionPriority codeActionPriority, FixAllState fixAllState, Diagnostic diagnostic);
    [CompilerGeneratedAttribute]
public sealed virtual Diagnostic get_Diagnostic();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public sealed virtual FixAllState get_FixAllState();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal static class Microsoft.CodeAnalysis.UnifiedSuggestions.UnifiedPredefinedSuggestedActionCategoryNames : object {
    public static string Any;
    public static string CodeFix;
    public static string ErrorFix;
    public static string StyleFix;
    public static string Refactoring;
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.CodeAnalysis.UnifiedSuggestions.UnifiedSuggestedAction : object {
    [CompilerGeneratedAttribute]
private Workspace <Workspace>k__BackingField;
    [CompilerGeneratedAttribute]
private CodeAction <OriginalCodeAction>k__BackingField;
    [CompilerGeneratedAttribute]
private CodeActionPriority <CodeActionPriority>k__BackingField;
    public Workspace Workspace { get; }
    public CodeAction OriginalCodeAction { get; }
    public CodeActionPriority CodeActionPriority { get; }
    public UnifiedSuggestedAction(Workspace workspace, CodeAction codeAction, CodeActionPriority codeActionPriority);
    [CompilerGeneratedAttribute]
public sealed virtual Workspace get_Workspace();
    [CompilerGeneratedAttribute]
public sealed virtual CodeAction get_OriginalCodeAction();
    [CompilerGeneratedAttribute]
public sealed virtual CodeActionPriority get_CodeActionPriority();
}
[NullableContextAttribute("1")]
internal interface Microsoft.CodeAnalysis.UnifiedSuggestions.UnifiedSuggestedActions.ICodeFixSuggestedAction {
    public CodeFix CodeFix { get; }
    public abstract virtual CodeFix get_CodeFix();
}
[NullableContextAttribute("1")]
internal interface Microsoft.CodeAnalysis.UnifiedSuggestions.UnifiedSuggestedActions.ICodeRefactoringSuggestedAction {
    public CodeRefactoringProvider CodeRefactoringProvider { get; }
    public abstract virtual CodeRefactoringProvider get_CodeRefactoringProvider();
}
[NullableContextAttribute("1")]
internal interface Microsoft.CodeAnalysis.UnifiedSuggestions.UnifiedSuggestedActions.IFixAllSuggestedAction {
    public Diagnostic Diagnostic { get; }
    public CodeAction OriginalCodeAction { get; }
    [NullableAttribute("2")]
public FixAllState FixAllState { get; }
    public abstract virtual Diagnostic get_Diagnostic();
    public abstract virtual CodeAction get_OriginalCodeAction();
    [NullableContextAttribute("2")]
public abstract virtual FixAllState get_FixAllState();
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
internal class Microsoft.CodeAnalysis.UnifiedSuggestions.UnifiedSuggestedActionSet : object {
    [CompilerGeneratedAttribute]
private string <CategoryName>k__BackingField;
    [NullableAttribute("1")]
[CompilerGeneratedAttribute]
private IEnumerable`1<IUnifiedSuggestedAction> <Actions>k__BackingField;
    [CompilerGeneratedAttribute]
private object <Title>k__BackingField;
    [CompilerGeneratedAttribute]
private UnifiedSuggestedActionSetPriority <Priority>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<TextSpan> <ApplicableToSpan>k__BackingField;
    public string CategoryName { get; }
    [NullableAttribute("1")]
public IEnumerable`1<IUnifiedSuggestedAction> Actions { get; }
    public object Title { get; }
    public UnifiedSuggestedActionSetPriority Priority { get; }
    public Nullable`1<TextSpan> ApplicableToSpan { get; }
    public UnifiedSuggestedActionSet(string categoryName, IEnumerable`1<IUnifiedSuggestedAction> actions, object title, UnifiedSuggestedActionSetPriority priority, Nullable`1<TextSpan> applicableToSpan);
    [CompilerGeneratedAttribute]
public string get_CategoryName();
    [NullableContextAttribute("1")]
[CompilerGeneratedAttribute]
public IEnumerable`1<IUnifiedSuggestedAction> get_Actions();
    [CompilerGeneratedAttribute]
public object get_Title();
    [CompilerGeneratedAttribute]
public UnifiedSuggestedActionSetPriority get_Priority();
    [CompilerGeneratedAttribute]
public Nullable`1<TextSpan> get_ApplicableToSpan();
}
internal class Microsoft.CodeAnalysis.UnifiedSuggestions.UnifiedSuggestedActionSetComparer : object {
    private Nullable`1<TextSpan> _targetSpan;
    public UnifiedSuggestedActionSetComparer(Nullable`1<TextSpan> targetSpan);
    private static int Distance(Nullable`1<TextSpan> maybeA, Nullable`1<TextSpan> maybeB);
    public sealed virtual int Compare(UnifiedSuggestedActionSet x, UnifiedSuggestedActionSet y);
}
internal enum Microsoft.CodeAnalysis.UnifiedSuggestions.UnifiedSuggestedActionSetPriority : Enum {
    public int value__;
    public static UnifiedSuggestedActionSetPriority Lowest;
    public static UnifiedSuggestedActionSetPriority Low;
    public static UnifiedSuggestedActionSetPriority Medium;
    public static UnifiedSuggestedActionSetPriority High;
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.CodeAnalysis.UnifiedSuggestions.UnifiedSuggestedActionsSource : object {
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.UnifiedSuggestions.UnifiedSuggestedActionsSource/<GetFilterAndOrderCodeFixesAsync>d__0")]
public static Task`1<ImmutableArray`1<UnifiedSuggestedActionSet>> GetFilterAndOrderCodeFixesAsync(Workspace workspace, ICodeFixService codeFixService, Document document, TextSpan selection, bool includeSuppressionFixes, bool isBlocking, Func`2<string, IDisposable> addOperationScope, CancellationToken cancellationToken);
    private static ImmutableArray`1<UnifiedSuggestedActionSet> OrganizeFixes(Workspace workspace, ImmutableArray`1<CodeFixCollection> fixCollections, bool includeSuppressionFixes);
    private static void GroupFixes(Workspace workspace, ImmutableArray`1<CodeFixCollection> fixCollections, IDictionary`2<Tuple`3<DiagnosticData, CodeActionPriority, Nullable`1<CodeActionPriority>>, IList`1<UnifiedSuggestedAction>> map, ArrayBuilder`1<Tuple`3<DiagnosticData, CodeActionPriority, Nullable`1<CodeActionPriority>>> order, bool includeSuppressionFixes);
    private static void ProcessFixCollection(Workspace workspace, IDictionary`2<Tuple`3<DiagnosticData, CodeActionPriority, Nullable`1<CodeActionPriority>>, IList`1<UnifiedSuggestedAction>> map, ArrayBuilder`1<Tuple`3<DiagnosticData, CodeActionPriority, Nullable`1<CodeActionPriority>>> order, bool includeSuppressionFixes, CodeFixCollection fixCollection);
    private static void AddCodeActions(Workspace workspace, IDictionary`2<Tuple`3<DiagnosticData, CodeActionPriority, Nullable`1<CodeActionPriority>>, IList`1<UnifiedSuggestedAction>> map, ArrayBuilder`1<Tuple`3<DiagnosticData, CodeActionPriority, Nullable`1<CodeActionPriority>>> order, CodeFixCollection fixCollection, Func`2<CodeAction, UnifiedSuggestedActionSet> getFixAllSuggestedActionSet, ImmutableArray`1<CodeFix> codeFixes);
    private static void AddFix(CodeFix fix, UnifiedSuggestedAction suggestedAction, IDictionary`2<Tuple`3<DiagnosticData, CodeActionPriority, Nullable`1<CodeActionPriority>>, IList`1<UnifiedSuggestedAction>> map, ArrayBuilder`1<Tuple`3<DiagnosticData, CodeActionPriority, Nullable`1<CodeActionPriority>>> order);
    private static UnifiedSuggestedActionSet GetUnifiedFixAllSuggestedActionSet(CodeAction action, int actionCount, FixAllState fixAllState, ImmutableArray`1<FixAllScope> supportedScopes, Diagnostic firstDiagnostic, Workspace workspace);
    private static ImmutableArray`1<UnifiedSuggestedActionSet> PrioritizeFixGroups(ImmutableDictionary`2<Tuple`3<DiagnosticData, CodeActionPriority, Nullable`1<CodeActionPriority>>, IList`1<UnifiedSuggestedAction>> map, ImmutableArray`1<Tuple`3<DiagnosticData, CodeActionPriority, Nullable`1<CodeActionPriority>>> order, Workspace workspace);
    private static void AddUnifiedSuggestedActionsSet(IEnumerable`1<UnifiedSuggestedAction> actions, Tuple`3<DiagnosticData, CodeActionPriority, Nullable`1<CodeActionPriority>> groupKey, ArrayBuilder`1<UnifiedSuggestedActionSet> sets);
    private static string GetFixCategory(DiagnosticSeverity severity);
    private static bool IsTopLevelSuppressionAction(CodeAction action);
    private static bool IsBulkConfigurationAction(CodeAction action);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.UnifiedSuggestions.UnifiedSuggestedActionsSource/<GetFilterAndOrderCodeRefactoringsAsync>d__12")]
public static Task`1<ImmutableArray`1<UnifiedSuggestedActionSet>> GetFilterAndOrderCodeRefactoringsAsync(Workspace workspace, ICodeRefactoringService codeRefactoringService, Document document, TextSpan selection, bool isBlocking, Func`2<string, IDisposable> addOperationScope, bool filterOutsideSelection, CancellationToken cancellationToken);
    private static ImmutableArray`1<CodeRefactoring> FilterOnAnyThread(ImmutableArray`1<CodeRefactoring> refactorings, TextSpan selection, bool filterOutsideSelection);
    private static CodeRefactoring FilterOnAnyThread(CodeRefactoring refactoring, TextSpan selection, bool filterOutsideSelection);
    private static UnifiedSuggestedActionSet OrganizeRefactorings(Workspace workspace, CodeRefactoring refactoring);
    private static UnifiedSuggestedActionSetPriority GetUnifiedSuggestedActionSetPriority(CodeActionPriority key);
    public static Nullable`1<ImmutableArray`1<UnifiedSuggestedActionSet>> FilterAndOrderActionSets(ImmutableArray`1<UnifiedSuggestedActionSet> fixes, ImmutableArray`1<UnifiedSuggestedActionSet> refactorings, Nullable`1<TextSpan> selectionOpt);
    private static ImmutableArray`1<UnifiedSuggestedActionSet> GetInitiallyOrderedActionSets(Nullable`1<TextSpan> selectionOpt, ImmutableArray`1<UnifiedSuggestedActionSet> fixes, ImmutableArray`1<UnifiedSuggestedActionSet> refactorings);
    private static ImmutableArray`1<UnifiedSuggestedActionSet> OrderActionSets(ImmutableArray`1<UnifiedSuggestedActionSet> actionSets, Nullable`1<TextSpan> selectionOpt);
    private static UnifiedSuggestedActionSet WithPriority(UnifiedSuggestedActionSet set, UnifiedSuggestedActionSetPriority priority);
    private static ImmutableArray`1<UnifiedSuggestedActionSet> InlineActionSetsIfDesirable(ImmutableArray`1<UnifiedSuggestedActionSet> allActionSets);
    private static UnifiedSuggestedActionSet InlineActions(UnifiedSuggestedActionSet actionSet);
    private static ImmutableArray`1<UnifiedSuggestedActionSet> FilterActionSetsByTitle(ImmutableArray`1<UnifiedSuggestedActionSet> allActionSets);
    private static UnifiedSuggestedActionSet FilterActionSetByTitle(UnifiedSuggestedActionSet set, HashSet`1<string> seenTitles);
    [CompilerGeneratedAttribute]
internal static Tuple`3<DiagnosticData, CodeActionPriority, Nullable`1<CodeActionPriority>> <AddFix>g__GetGroupKey|5_0(CodeFix fix);
    [CompilerGeneratedAttribute]
internal static ValueTuple`2<Nullable`1<TextSpan>, string> <PrioritizeFixGroups>g__CombineSpansAndCategory|7_0(IEnumerable`1<UnifiedSuggestedActionSet> sets);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
internal class Microsoft.CodeAnalysis.UnifiedSuggestions.UnifiedSuggestedActionWithNestedActions : UnifiedSuggestedAction {
    [CompilerGeneratedAttribute]
private object <Provider>k__BackingField;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private ImmutableArray`1<UnifiedSuggestedActionSet> <NestedActionSets>k__BackingField;
    public object Provider { get; }
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ImmutableArray`1<UnifiedSuggestedActionSet> NestedActionSets { get; }
    [NullableContextAttribute("1")]
public UnifiedSuggestedActionWithNestedActions(Workspace workspace, CodeAction codeAction, CodeActionPriority codeActionPriority, object provider, ImmutableArray`1<UnifiedSuggestedActionSet> nestedActionSets);
    [CompilerGeneratedAttribute]
public object get_Provider();
    [CompilerGeneratedAttribute]
public ImmutableArray`1<UnifiedSuggestedActionSet> get_NestedActionSets();
}
internal abstract class Microsoft.CodeAnalysis.UnsealClass.AbstractUnsealClassCodeFixProvider : CodeFixProvider {
    protected string TitleFormat { get; }
    protected abstract virtual string get_TitleFormat();
    public virtual FixAllProvider GetFixAllProvider();
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.UnsealClass.AbstractUnsealClassCodeFixProvider/<RegisterCodeFixesAsync>d__3")]
public virtual Task RegisterCodeFixesAsync(CodeFixContext context);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.UnsealClass.AbstractUnsealClassCodeFixProvider/<UnsealDeclarationsAsync>d__4")]
private static Task`1<Solution> UnsealDeclarationsAsync(Solution solution, ImmutableArray`1<SyntaxReference> declarationReferences, CancellationToken cancellationToken);
}
[ExportCodeFixProviderAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.UpdateLegacySuppressions.UpdateLegacySuppressionsCodeFixProvider : SyntaxEditorBasedCodeFixProvider {
    public ImmutableArray`1<string> FixableDiagnosticIds { get; }
    internal CodeFixCategory CodeFixCategory { get; }
    public virtual ImmutableArray`1<string> get_FixableDiagnosticIds();
    internal virtual CodeFixCategory get_CodeFixCategory();
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.UpdateLegacySuppressions.UpdateLegacySuppressionsCodeFixProvider/<RegisterCodeFixesAsync>d__5")]
public virtual Task RegisterCodeFixesAsync(CodeFixContext context);
    protected virtual Task FixAllAsync(Document document, ImmutableArray`1<Diagnostic> diagnostics, SyntaxEditor editor, CancellationToken cancellationToken);
}
internal abstract class Microsoft.CodeAnalysis.UpgradeProject.AbstractUpgradeProjectCodeFixProvider : CodeFixProvider {
    public string UpgradeThisProjectResource { get; }
    public string UpgradeAllProjectsResource { get; }
    public abstract virtual string SuggestedVersion(ImmutableArray`1<Diagnostic> diagnostics);
    public abstract virtual Solution UpgradeProject(Project project, string version);
    public abstract virtual bool IsUpgrade(Project project, string newVersion);
    public abstract virtual string get_UpgradeThisProjectResource();
    public abstract virtual string get_UpgradeAllProjectsResource();
    public virtual FixAllProvider GetFixAllProvider();
    public virtual Task RegisterCodeFixesAsync(CodeFixContext context);
    protected ImmutableArray`1<CodeAction> GetUpgradeProjectCodeActions(CodeFixContext context);
    public Solution UpgradeAllProjects(Solution solution, string language, string version, CancellationToken cancellationToken);
    private bool CanUpgrade(Project project, string language, string version);
}
internal class Microsoft.CodeAnalysis.UpgradeProject.ProjectOptionsChangeAction : SolutionChangeAction {
    public ProjectOptionsChangeAction(string title, Func`2<CancellationToken, Task`1<Solution>> createChangedSolution);
    protected virtual Task`1<IEnumerable`1<CodeActionOperation>> ComputePreviewOperationsAsync(CancellationToken cancellationToken);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal abstract class Microsoft.CodeAnalysis.UseAutoProperty.AbstractUseAutoPropertyAnalyzer`4 : AbstractBuiltInCodeStyleDiagnosticAnalyzer {
    private static LocalizableString s_title;
    private static AbstractUseAutoPropertyAnalyzer`4();
    public virtual DiagnosticAnalyzerCategory GetAnalyzerCategory();
    protected abstract virtual void AnalyzeCompilationUnit(SemanticModelAnalysisContext context, SyntaxNode root, List`1<AnalysisResult<TPropertyDeclaration, TFieldDeclaration, TVariableDeclarator, TExpression>> analysisResults);
    protected abstract virtual bool SupportsReadOnlyProperties(Compilation compilation);
    protected abstract virtual bool SupportsPropertyInitializer(Compilation compilation);
    protected abstract virtual bool CanExplicitInterfaceImplementationsBeFixed();
    protected abstract virtual TExpression GetFieldInitializer(TVariableDeclarator variable, CancellationToken cancellationToken);
    protected abstract virtual TExpression GetGetterExpression(IMethodSymbol getMethod, CancellationToken cancellationToken);
    protected abstract virtual TExpression GetSetterExpression(IMethodSymbol setMethod, SemanticModel semanticModel, CancellationToken cancellationToken);
    protected abstract virtual SyntaxNode GetFieldNode(TFieldDeclaration fieldDeclaration, TVariableDeclarator variableDeclarator);
    protected abstract virtual void RegisterIneligibleFieldsAction(List`1<AnalysisResult<TPropertyDeclaration, TFieldDeclaration, TVariableDeclarator, TExpression>> analysisResults, HashSet`1<IFieldSymbol> ineligibleFields, Compilation compilation, CancellationToken cancellationToken);
    protected sealed virtual void InitializeWorker(AnalysisContext context);
    private void AnalyzeSemanticModel(SemanticModelAnalysisContext context);
    protected void AnalyzeProperty(SemanticModelAnalysisContext context, TPropertyDeclaration propertyDeclaration, List`1<AnalysisResult<TPropertyDeclaration, TFieldDeclaration, TVariableDeclarator, TExpression>> analysisResults);
    protected virtual bool CanConvert(IPropertySymbol property);
    private IFieldSymbol GetSetterField(SemanticModel semanticModel, IMethodSymbol setMethod, CancellationToken cancellationToken);
    private IFieldSymbol GetGetterField(SemanticModel semanticModel, IMethodSymbol getMethod, CancellationToken cancellationToken);
    [NullableContextAttribute("2")]
private static IFieldSymbol CheckFieldAccessExpression(SemanticModel semanticModel, TExpression expression);
    private void Process(List`1<AnalysisResult<TPropertyDeclaration, TFieldDeclaration, TVariableDeclarator, TExpression>> analysisResults, HashSet`1<IFieldSymbol> ineligibleFields, SemanticModelAnalysisContext context);
    private void Process(AnalysisResult<TPropertyDeclaration, TFieldDeclaration, TVariableDeclarator, TExpression> result, SemanticModelAnalysisContext context);
    protected virtual bool IsEligibleHeuristic(IFieldSymbol field, TPropertyDeclaration propertyDeclaration, SemanticModel semanticModel, Compilation compilation, CancellationToken cancellationToken);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal abstract class Microsoft.CodeAnalysis.UseAutoProperty.AbstractUseAutoPropertyCodeFixProvider`5 : CodeFixProvider {
    protected static SyntaxAnnotation SpecializedFormattingAnnotation;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ImmutableArray`1<string> FixableDiagnosticIds { get; }
    private static AbstractUseAutoPropertyCodeFixProvider`5();
    public sealed virtual ImmutableArray`1<string> get_FixableDiagnosticIds();
    public sealed virtual FixAllProvider GetFixAllProvider();
    protected abstract virtual TPropertyDeclaration GetPropertyDeclaration(SyntaxNode node);
    protected abstract virtual SyntaxNode GetNodeToRemove(TVariableDeclarator declarator);
    protected abstract virtual IEnumerable`1<AbstractFormattingRule> GetFormattingRules(Document document);
    protected abstract virtual Task`1<SyntaxNode> UpdatePropertyAsync(Document propertyDocument, Compilation compilation, IFieldSymbol fieldSymbol, IPropertySymbol propertySymbol, TPropertyDeclaration propertyDeclaration, bool isWrittenOutsideConstructor, CancellationToken cancellationToken);
    public sealed virtual Task RegisterCodeFixesAsync(CodeFixContext context);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.UseAutoProperty.AbstractUseAutoPropertyCodeFixProvider`5/<ProcessResultAsync>d__9")]
private Task`1<Solution> ProcessResultAsync(CodeFixContext context, Diagnostic diagnostic, CancellationToken cancellationToken);
    private static SyntaxRemoveOptions CreateSyntaxRemoveOptions(SyntaxNode nodeToRemove);
    private static bool WillRemoveFirstFieldInTypeDirectlyAboveProperty(ISyntaxFactsService syntaxFacts, TPropertyDeclaration property, SyntaxNode fieldToRemove);
    private static bool CanEditDocument(Solution solution, SyntaxTree sourceTree, HashSet`1<DocumentId> linkedDocuments, Dictionary`2<SyntaxTree, bool> canEdit);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.UseAutoProperty.AbstractUseAutoPropertyCodeFixProvider`5/<FormatAsync>d__13")]
private Task`1<SyntaxNode> FormatAsync(SyntaxNode newRoot, Document document, CancellationToken cancellationToken);
    private static bool IsWrittenToOutsideOfConstructorOrProperty(IFieldSymbol field, RenameLocations renameLocations, TPropertyDeclaration propertyDeclaration, CancellationToken cancellationToken);
    private static bool IsWrittenToOutsideOfConstructorOrProperty(Solution solution, RenameLocation location, TPropertyDeclaration propertyDeclaration, ISet`1<TConstructorDeclaration> constructorNodes, CancellationToken cancellationToken);
}
internal abstract class Microsoft.CodeAnalysis.UseCoalesceExpression.AbstractUseCoalesceExpressionDiagnosticAnalyzer`4 : AbstractBuiltInCodeStyleDiagnosticAnalyzer {
    public virtual DiagnosticAnalyzerCategory GetAnalyzerCategory();
    [NullableContextAttribute("1")]
protected abstract virtual ISyntaxFacts GetSyntaxFacts();
    [NullableContextAttribute("1")]
protected virtual void InitializeWorker(AnalysisContext context);
    private void AnalyzeSyntax(SyntaxNodeAnalysisContext context);
}
internal abstract class Microsoft.CodeAnalysis.UseCoalesceExpression.AbstractUseCoalesceExpressionForNullableDiagnosticAnalyzer`6 : AbstractBuiltInCodeStyleDiagnosticAnalyzer {
    public virtual DiagnosticAnalyzerCategory GetAnalyzerCategory();
    [NullableContextAttribute("1")]
protected abstract virtual ISyntaxFacts GetSyntaxFacts();
    [NullableContextAttribute("1")]
protected virtual void InitializeWorker(AnalysisContext context);
    private void AnalyzeSyntax(SyntaxNodeAnalysisContext context);
}
[ExportCodeFixProviderAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.UseCoalesceExpression.UseCoalesceExpressionCodeFixProvider : SyntaxEditorBasedCodeFixProvider {
    public ImmutableArray`1<string> FixableDiagnosticIds { get; }
    internal CodeFixCategory CodeFixCategory { get; }
    public virtual ImmutableArray`1<string> get_FixableDiagnosticIds();
    internal sealed virtual CodeFixCategory get_CodeFixCategory();
    protected virtual bool IncludeDiagnosticDuringFixAll(Diagnostic diagnostic);
    public virtual Task RegisterCodeFixesAsync(CodeFixContext context);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.UseCoalesceExpression.UseCoalesceExpressionCodeFixProvider/<FixAllAsync>d__7")]
protected virtual Task FixAllAsync(Document document, ImmutableArray`1<Diagnostic> diagnostics, SyntaxEditor editor, CancellationToken cancellationToken);
    private static void ApplyEdit(SyntaxEditor editor, SemanticModel semanticModel, INamedTypeSymbol expressionTypeOpt, ISyntaxFactsService syntaxFacts, ISemanticFactsService semanticFacts, Diagnostic diagnostic, CancellationToken cancellationToken);
    private static SyntaxNode GetCoalesceExpression(ISyntaxFactsService syntaxFacts, SyntaxGenerator generator, SyntaxNode whenPart, SyntaxNode whenTrue, SyntaxNode conditionalPartLow, SyntaxNode currentWhenTrue, SyntaxNode currentWhenFalse);
}
[ExportCodeFixProviderAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.UseCoalesceExpression.UseCoalesceExpressionForNullableCodeFixProvider : SyntaxEditorBasedCodeFixProvider {
    public ImmutableArray`1<string> FixableDiagnosticIds { get; }
    internal CodeFixCategory CodeFixCategory { get; }
    public virtual ImmutableArray`1<string> get_FixableDiagnosticIds();
    internal sealed virtual CodeFixCategory get_CodeFixCategory();
    protected virtual bool IncludeDiagnosticDuringFixAll(Diagnostic diagnostic);
    public virtual Task RegisterCodeFixesAsync(CodeFixContext context);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.UseCoalesceExpression.UseCoalesceExpressionForNullableCodeFixProvider/<FixAllAsync>d__7")]
protected virtual Task FixAllAsync(Document document, ImmutableArray`1<Diagnostic> diagnostics, SyntaxEditor editor, CancellationToken cancellationToken);
}
internal abstract class Microsoft.CodeAnalysis.UseCollectionInitializer.AbstractObjectCreationExpressionAnalyzer`5 : object {
    protected SemanticModel _semanticModel;
    protected ISyntaxFacts _syntaxFacts;
    protected TObjectCreationExpressionSyntax _objectCreationExpression;
    protected CancellationToken _cancellationToken;
    protected TStatementSyntax _containingStatement;
    private SyntaxNodeOrToken _valuePattern;
    private ISymbol _initializedSymbol;
    public void Initialize(SemanticModel semanticModel, ISyntaxFacts syntaxFacts, TObjectCreationExpressionSyntax objectCreationExpression, CancellationToken cancellationToken);
    protected void Clear();
    protected abstract virtual void AddMatches(ArrayBuilder`1<TMatch> matches);
    protected Nullable`1<ImmutableArray`1<TMatch>> AnalyzeWorker();
    private bool TryInitializeVariableDeclarationCase();
    private bool TryInitializeAssignmentCase();
    protected bool ValuePatternMatches(TExpressionSyntax expression);
    protected bool ExpressionContainsValuePatternOrReferencesInitializedSymbol(SyntaxNode expression);
    protected abstract virtual bool ShouldAnalyze();
}
internal abstract class Microsoft.CodeAnalysis.UseCollectionInitializer.AbstractUseCollectionInitializerCodeFixProvider`8 : SyntaxEditorBasedCodeFixProvider {
    public ImmutableArray`1<string> FixableDiagnosticIds { get; }
    internal CodeFixCategory CodeFixCategory { get; }
    public virtual ImmutableArray`1<string> get_FixableDiagnosticIds();
    internal sealed virtual CodeFixCategory get_CodeFixCategory();
    protected virtual bool IncludeDiagnosticDuringFixAll(Diagnostic diagnostic);
    public virtual Task RegisterCodeFixesAsync(CodeFixContext context);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.UseCollectionInitializer.AbstractUseCollectionInitializerCodeFixProvider`8/<FixAllAsync>d__6")]
protected virtual Task FixAllAsync(Document document, ImmutableArray`1<Diagnostic> diagnostics, SyntaxEditor editor, CancellationToken cancellationToken);
    protected abstract virtual TStatementSyntax GetNewStatement(TStatementSyntax statement, TObjectCreationExpressionSyntax objectCreation, ImmutableArray`1<TExpressionStatementSyntax> matches);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal abstract class Microsoft.CodeAnalysis.UseCollectionInitializer.AbstractUseCollectionInitializerDiagnosticAnalyzer`8 : AbstractBuiltInCodeStyleDiagnosticAnalyzer {
    public virtual DiagnosticAnalyzerCategory GetAnalyzerCategory();
    protected virtual void InitializeWorker(AnalysisContext context);
    private void OnCompilationStart(CompilationStartAnalysisContext context);
    protected abstract virtual bool AreCollectionInitializersSupported(SyntaxNodeAnalysisContext context);
    private void AnalyzeNode(SyntaxNodeAnalysisContext context, INamedTypeSymbol ienumerableType);
    private void FadeOutCode(SyntaxNodeAnalysisContext context, ImmutableArray`1<TExpressionStatementSyntax> matches, ImmutableArray`1<Location> locations);
    protected abstract virtual ISyntaxFacts GetSyntaxFacts();
}
internal class Microsoft.CodeAnalysis.UseCollectionInitializer.ObjectCreationExpressionAnalyzer`7 : AbstractObjectCreationExpressionAnalyzer`5<TExpressionSyntax, TStatementSyntax, TObjectCreationExpressionSyntax, TVariableDeclaratorSyntax, TExpressionStatementSyntax> {
    private static ObjectPool`1<ObjectCreationExpressionAnalyzer`7<TExpressionSyntax, TStatementSyntax, TObjectCreationExpressionSyntax, TMemberAccessExpressionSyntax, TInvocationExpressionSyntax, TExpressionStatementSyntax, TVariableDeclaratorSyntax>> s_pool;
    private static ObjectCreationExpressionAnalyzer`7();
    public static Nullable`1<ImmutableArray`1<TExpressionStatementSyntax>> Analyze(SemanticModel semanticModel, ISyntaxFacts syntaxFacts, TObjectCreationExpressionSyntax objectCreationExpression, CancellationToken cancellationToken);
    protected virtual void AddMatches(ArrayBuilder`1<TExpressionStatementSyntax> matches);
    protected virtual bool ShouldAnalyze();
    private bool TryAnalyzeIndexAssignment(TExpressionStatementSyntax statement, SyntaxNode& instance);
    private bool TryAnalyzeAddInvocation(TExpressionStatementSyntax statement, SyntaxNode& instance);
}
internal abstract class Microsoft.CodeAnalysis.UseCompoundAssignment.AbstractUseCompoundAssignmentCodeFixProvider`3 : SyntaxEditorBasedCodeFixProvider {
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private ImmutableArray`1<string> <FixableDiagnosticIds>k__BackingField;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private ImmutableDictionary`2<TSyntaxKind, TSyntaxKind> _binaryToAssignmentMap;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private ImmutableDictionary`2<TSyntaxKind, TSyntaxKind> _assignmentToTokenMap;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ImmutableArray`1<string> FixableDiagnosticIds { get; }
    internal CodeFixCategory CodeFixCategory { get; }
    protected AbstractUseCompoundAssignmentCodeFixProvider`3(ImmutableArray`1<ValueTuple`3<TSyntaxKind, TSyntaxKind, TSyntaxKind>> kinds);
    [CompilerGeneratedAttribute]
public virtual ImmutableArray`1<string> get_FixableDiagnosticIds();
    internal sealed virtual CodeFixCategory get_CodeFixCategory();
    protected abstract virtual SyntaxToken Token(TSyntaxKind kind);
    [NullableContextAttribute("1")]
protected abstract virtual TAssignmentSyntax Assignment(TSyntaxKind assignmentOpKind, TExpressionSyntax left, SyntaxToken syntaxToken, TExpressionSyntax right);
    [NullableContextAttribute("1")]
protected abstract virtual TExpressionSyntax Increment(TExpressionSyntax left);
    [NullableContextAttribute("1")]
protected abstract virtual TExpressionSyntax Decrement(TExpressionSyntax left);
    [NullableContextAttribute("1")]
public virtual Task RegisterCodeFixesAsync(CodeFixContext context);
    [NullableContextAttribute("1")]
protected virtual Task FixAllAsync(Document document, ImmutableArray`1<Diagnostic> diagnostics, SyntaxEditor editor, CancellationToken cancellationToken);
}
internal abstract class Microsoft.CodeAnalysis.UseCompoundAssignment.AbstractUseCompoundAssignmentDiagnosticAnalyzer`3 : AbstractBuiltInCodeStyleDiagnosticAnalyzer {
    [NullableAttribute("1")]
private ISyntaxFacts _syntaxFacts;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private ImmutableDictionary`2<TSyntaxKind, TSyntaxKind> _binaryToAssignmentMap;
    [NullableAttribute("1")]
private DiagnosticDescriptor _incrementDescriptor;
    [NullableAttribute("1")]
private DiagnosticDescriptor _decrementDescriptor;
    protected AbstractUseCompoundAssignmentDiagnosticAnalyzer`3(ISyntaxFacts syntaxFacts, ImmutableArray`1<ValueTuple`3<TSyntaxKind, TSyntaxKind, TSyntaxKind>> kinds);
    protected abstract virtual TSyntaxKind GetAnalysisKind();
    protected abstract virtual bool IsSupported(TSyntaxKind assignmentKind, ParseOptions options);
    protected abstract virtual int TryGetIncrementOrDecrement(TSyntaxKind opKind, object constantValue);
    public virtual DiagnosticAnalyzerCategory GetAnalyzerCategory();
    [NullableContextAttribute("1")]
protected virtual void InitializeWorker(AnalysisContext context);
    private void AnalyzeAssignment(SyntaxNodeAnalysisContext context);
}
internal static class Microsoft.CodeAnalysis.UseCompoundAssignment.UseCompoundAssignmentUtilities : object {
    internal static string Increment;
    internal static string Decrement;
    public static void GenerateMaps(ImmutableArray`1<ValueTuple`3<TSyntaxKind, TSyntaxKind, TSyntaxKind>> kinds, ImmutableDictionary`2& binaryToAssignmentMap, ImmutableDictionary`2& assignmentToTokenMap);
    public static bool IsSideEffectFree(ISyntaxFacts syntaxFacts, SyntaxNode expr, SemanticModel semanticModel, CancellationToken cancellationToken);
    private static bool IsSideEffectFreeRecurse(ISyntaxFacts syntaxFacts, SyntaxNode expr, SemanticModel semanticModel, bool isTopLevel, CancellationToken cancellationToken);
    private static bool IsSideEffectFreeSymbol(SyntaxNode expr, SemanticModel semanticModel, bool isTopLevel, CancellationToken cancellationToken);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal abstract class Microsoft.CodeAnalysis.UseConditionalExpression.AbstractUseConditionalExpressionCodeFixProvider`4 : SyntaxEditorBasedCodeFixProvider {
    internal CodeFixCategory CodeFixCategory { get; }
    internal sealed virtual CodeFixCategory get_CodeFixCategory();
    protected abstract virtual AbstractFormattingRule GetMultiLineFormattingRule();
    protected abstract virtual TExpressionSyntax ConvertToExpression(IThrowOperation throwOperation);
    protected abstract virtual TStatementSyntax WrapWithBlockIfAppropriate(TIfStatementSyntax ifStatement, TStatementSyntax statement);
    protected abstract virtual Task FixOneAsync(Document document, Diagnostic diagnostic, SyntaxEditor editor, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.UseConditionalExpression.AbstractUseConditionalExpressionCodeFixProvider`4/<FixAllAsync>d__6")]
protected virtual Task FixAllAsync(Document document, ImmutableArray`1<Diagnostic> diagnostics, SyntaxEditor editor, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.UseConditionalExpression.AbstractUseConditionalExpressionCodeFixProvider`4/<CreateConditionalExpressionAsync>d__7")]
protected Task`1<TExpressionSyntax> CreateConditionalExpressionAsync(Document document, IConditionalOperation ifOperation, IOperation trueStatement, IOperation falseStatement, IOperation trueValue, IOperation falseValue, bool isRef, CancellationToken cancellationToken);
    private static bool IsBooleanLiteral(IOperation trueValue, bool val);
    private static TExpressionSyntax MakeRef(SyntaxGeneratorInternal generator, bool isRef, TExpressionSyntax syntaxNode);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.UseConditionalExpression.AbstractUseConditionalExpressionCodeFixProvider`4/<MakeMultiLineAsync>d__10")]
private static Task`1<bool> MakeMultiLineAsync(Document document, SyntaxNode condition, SyntaxNode trueSyntax, SyntaxNode falseSyntax, CancellationToken cancellationToken);
    private TExpressionSyntax CastValueIfNecessary(SyntaxGenerator generator, IOperation statement, IOperation value);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal abstract class Microsoft.CodeAnalysis.UseConditionalExpression.AbstractUseConditionalExpressionDiagnosticAnalyzer`1 : AbstractBuiltInCodeStyleDiagnosticAnalyzer {
    private PerLanguageOption2`1<CodeStyleOption2`1<bool>> _option;
    protected AbstractUseConditionalExpressionDiagnosticAnalyzer`1(string descriptorId, EnforceOnBuild enforceOnBuild, LocalizableResourceString message, PerLanguageOption2`1<CodeStyleOption2`1<bool>> option);
    public sealed virtual DiagnosticAnalyzerCategory GetAnalyzerCategory();
    protected abstract virtual ISyntaxFacts GetSyntaxFacts();
    protected abstract virtual bool TryMatchPattern(IConditionalOperation ifOperation, ISymbol containingSymbol);
    protected sealed virtual void InitializeWorker(AnalysisContext context);
    private void AnalyzeOperation(OperationAnalysisContext context);
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal abstract class Microsoft.CodeAnalysis.UseConditionalExpression.AbstractUseConditionalExpressionForAssignmentCodeFixProvider`6 : AbstractUseConditionalExpressionCodeFixProvider`4<TStatementSyntax, TIfStatementSyntax, TExpressionSyntax, TConditionalExpressionSyntax> {
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ImmutableArray`1<string> FixableDiagnosticIds { get; }
    protected abstract virtual TVariableDeclaratorSyntax WithInitializer(TVariableDeclaratorSyntax variable, TExpressionSyntax value);
    protected abstract virtual TVariableDeclaratorSyntax GetDeclaratorSyntax(IVariableDeclaratorOperation declarator);
    protected abstract virtual TLocalDeclarationStatementSyntax AddSimplificationToType(TLocalDeclarationStatementSyntax updatedLocalDeclaration);
    public virtual ImmutableArray`1<string> get_FixableDiagnosticIds();
    public virtual Task RegisterCodeFixesAsync(CodeFixContext context);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.UseConditionalExpression.AbstractUseConditionalExpressionForAssignmentCodeFixProvider`6/<FixOneAsync>d__6")]
protected virtual Task FixOneAsync(Document document, Diagnostic diagnostic, SyntaxEditor editor, CancellationToken cancellationToken);
    private void ConvertOnlyIfToConditionalExpression(SyntaxEditor editor, IConditionalOperation ifOperation, ISimpleAssignmentOperation assignment, TExpressionSyntax conditionalExpression);
    private bool TryConvertWhenAssignmentToLocalDeclaredImmediateAbove(ISyntaxFactsService syntaxFacts, SyntaxEditor editor, IConditionalOperation ifOperation, ISimpleAssignmentOperation trueAssignment, ISimpleAssignmentOperation falseAssignment, TExpressionSyntax conditionalExpression);
    [NullableContextAttribute("2")]
private bool TryFindMatchingLocalDeclarationImmediatelyAbove(IConditionalOperation ifOperation, ISimpleAssignmentOperation trueAssignment, ISimpleAssignmentOperation falseAssignment, IVariableDeclarationGroupOperation& localDeclaration, IVariableDeclaratorOperation& declarator);
    private bool ReferencesLocalVariable(IOperation operation, ILocalSymbol variable);
}
internal abstract class Microsoft.CodeAnalysis.UseConditionalExpression.AbstractUseConditionalExpressionForAssignmentDiagnosticAnalyzer`1 : AbstractUseConditionalExpressionDiagnosticAnalyzer`1<TIfStatementSyntax> {
    protected AbstractUseConditionalExpressionForAssignmentDiagnosticAnalyzer`1(LocalizableResourceString message);
    protected virtual bool TryMatchPattern(IConditionalOperation ifOperation, ISymbol containingSymbol);
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal abstract class Microsoft.CodeAnalysis.UseConditionalExpression.AbstractUseConditionalExpressionForReturnCodeFixProvider`4 : AbstractUseConditionalExpressionCodeFixProvider`4<TStatementSyntax, TIfStatementSyntax, TExpressionSyntax, TConditionalExpressionSyntax> {
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ImmutableArray`1<string> FixableDiagnosticIds { get; }
    public virtual ImmutableArray`1<string> get_FixableDiagnosticIds();
    public virtual Task RegisterCodeFixesAsync(CodeFixContext context);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.UseConditionalExpression.AbstractUseConditionalExpressionForReturnCodeFixProvider`4/<FixOneAsync>d__3")]
protected virtual Task FixOneAsync(Document document, Diagnostic diagnostic, SyntaxEditor editor, CancellationToken cancellationToken);
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal abstract class Microsoft.CodeAnalysis.UseConditionalExpression.AbstractUseConditionalExpressionForReturnDiagnosticAnalyzer`1 : AbstractUseConditionalExpressionDiagnosticAnalyzer`1<TIfStatementSyntax> {
    protected AbstractUseConditionalExpressionForReturnDiagnosticAnalyzer`1(LocalizableResourceString message);
    protected virtual bool TryMatchPattern(IConditionalOperation ifOperation, ISymbol containingSymbol);
}
internal static class Microsoft.CodeAnalysis.UseConditionalExpression.UseConditionalExpressionCodeFixHelpers : object {
    public static SyntaxAnnotation SpecializedFormattingAnnotation;
    private static UseConditionalExpressionCodeFixHelpers();
    public static SyntaxRemoveOptions GetRemoveOptions(ISyntaxFactsService syntaxFacts, SyntaxNode syntax);
}
internal static class Microsoft.CodeAnalysis.UseConditionalExpression.UseConditionalExpressionForAssignmentHelpers : object {
    [NullableContextAttribute("1")]
public static bool TryMatchPattern(ISyntaxFacts syntaxFacts, IConditionalOperation ifOperation, IOperation& trueStatement, IOperation& falseStatement, ISimpleAssignmentOperation& trueAssignment, ISimpleAssignmentOperation& falseAssignment);
    [NullableContextAttribute("2")]
private static bool TryGetAssignmentOrThrow(IOperation statement, ISimpleAssignmentOperation& assignment, IThrowOperation& throwOperation);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
internal static class Microsoft.CodeAnalysis.UseConditionalExpression.UseConditionalExpressionForReturnHelpers : object {
    public static bool TryMatchPattern(ISyntaxFacts syntaxFacts, IConditionalOperation ifOperation, ISymbol containingSymbol, IOperation& trueStatement, IOperation& falseStatement, IReturnOperation& trueReturn, IReturnOperation& falseReturn);
    private static bool IsReturnExprOrThrow(IOperation statement);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal static class Microsoft.CodeAnalysis.UseConditionalExpression.UseConditionalExpressionHelpers : object {
    public static bool CanConvert(ISyntaxFacts syntaxFacts, IConditionalOperation ifOperation, IOperation whenTrue, IOperation whenFalse);
    [NullableContextAttribute("2")]
public static IOperation UnwrapSingleStatementBlock(IOperation statement);
    public static IOperation UnwrapImplicitConversion(IOperation value);
    public static bool HasRegularComments(ISyntaxFacts syntaxFacts, SyntaxNode syntax);
    public static bool HasRegularCommentTrivia(ISyntaxFacts syntaxFacts, SyntaxTriviaList triviaList);
    [NullableContextAttribute("2")]
public static bool HasInconvertibleThrowStatement(ISyntaxFacts syntaxFacts, bool isRef, IThrowOperation trueThrow, IThrowOperation falseThrow);
}
internal static class Microsoft.CodeAnalysis.UseConditionalExpression.UseConditionalExpressionOptions : object {
    [NullableAttribute("1")]
public static PerLanguageOption2`1<int> ConditionalExpressionWrappingLength;
    private static UseConditionalExpressionOptions();
}
[ExportCodeFixProviderAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.UseExplicitTupleName.UseExplicitTupleNameCodeFixProvider : SyntaxEditorBasedCodeFixProvider {
    [CompilerGeneratedAttribute]
private ImmutableArray`1<string> <FixableDiagnosticIds>k__BackingField;
    public ImmutableArray`1<string> FixableDiagnosticIds { get; }
    internal CodeFixCategory CodeFixCategory { get; }
    [CompilerGeneratedAttribute]
public virtual ImmutableArray`1<string> get_FixableDiagnosticIds();
    internal sealed virtual CodeFixCategory get_CodeFixCategory();
    public virtual Task RegisterCodeFixesAsync(CodeFixContext context);
    protected virtual Task FixAllAsync(Document document, ImmutableArray`1<Diagnostic> diagnostics, SyntaxEditor editor, CancellationToken cancellationToken);
}
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
internal class Microsoft.CodeAnalysis.UseExplicitTupleName.UseExplicitTupleNameDiagnosticAnalyzer : AbstractBuiltInCodeStyleDiagnosticAnalyzer {
    public static string ElementName;
    public virtual DiagnosticAnalyzerCategory GetAnalyzerCategory();
    protected virtual void InitializeWorker(AnalysisContext context);
    private void AnalyzeOperation(OperationAnalysisContext context);
    private static IFieldSymbol GetNamedField(INamedTypeSymbol containingType, IFieldSymbol unnamedField, CancellationToken cancellationToken);
}
internal abstract class Microsoft.CodeAnalysis.UseInferredMemberName.AbstractUseInferredMemberNameCodeFixProvider : SyntaxEditorBasedCodeFixProvider {
    [CompilerGeneratedAttribute]
private ImmutableArray`1<string> <FixableDiagnosticIds>k__BackingField;
    public ImmutableArray`1<string> FixableDiagnosticIds { get; }
    internal CodeFixCategory CodeFixCategory { get; }
    protected abstract virtual void LanguageSpecificRemoveSuggestedNode(SyntaxEditor editor, SyntaxNode node);
    [CompilerGeneratedAttribute]
public virtual ImmutableArray`1<string> get_FixableDiagnosticIds();
    internal sealed virtual CodeFixCategory get_CodeFixCategory();
    public virtual Task RegisterCodeFixesAsync(CodeFixContext context);
    protected virtual Task FixAllAsync(Document document, ImmutableArray`1<Diagnostic> diagnostics, SyntaxEditor editor, CancellationToken cancellationToken);
}
internal abstract class Microsoft.CodeAnalysis.UseInferredMemberName.AbstractUseInferredMemberNameDiagnosticAnalyzer : AbstractBuiltInCodeStyleDiagnosticAnalyzer {
    protected abstract virtual void LanguageSpecificAnalyzeSyntax(SyntaxNodeAnalysisContext context, SyntaxTree syntaxTree, AnalyzerOptions options, CancellationToken cancellationToken);
    public virtual DiagnosticAnalyzerCategory GetAnalyzerCategory();
    protected void AnalyzeSyntax(SyntaxNodeAnalysisContext context);
}
internal abstract class Microsoft.CodeAnalysis.UseIsNullCheck.AbstractUseIsNullCheckForReferenceEqualsCodeFixProvider`1 : SyntaxEditorBasedCodeFixProvider {
    public ImmutableArray`1<string> FixableDiagnosticIds { get; }
    internal CodeFixCategory CodeFixCategory { get; }
    public virtual ImmutableArray`1<string> get_FixableDiagnosticIds();
    internal sealed virtual CodeFixCategory get_CodeFixCategory();
    protected abstract virtual string GetIsNullTitle();
    protected abstract virtual string GetIsNotNullTitle();
    protected abstract virtual SyntaxNode CreateNullCheck(TExpressionSyntax argument, bool isUnconstrainedGeneric);
    protected abstract virtual SyntaxNode CreateNotNullCheck(TExpressionSyntax argument);
    private static bool IsSupportedDiagnostic(Diagnostic diagnostic);
    public virtual Task RegisterCodeFixesAsync(CodeFixContext context);
    protected virtual Task FixAllAsync(Document document, ImmutableArray`1<Diagnostic> diagnostics, SyntaxEditor editor, CancellationToken cancellationToken);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal abstract class Microsoft.CodeAnalysis.UseIsNullCheck.AbstractUseIsNullCheckForReferenceEqualsDiagnosticAnalyzer`1 : AbstractBuiltInCodeStyleDiagnosticAnalyzer {
    protected AbstractUseIsNullCheckForReferenceEqualsDiagnosticAnalyzer`1(LocalizableString title);
    public virtual DiagnosticAnalyzerCategory GetAnalyzerCategory();
    protected virtual void InitializeWorker(AnalysisContext context);
    protected abstract virtual bool IsLanguageVersionSupported(ParseOptions options);
    protected abstract virtual bool IsUnconstrainedGenericSupported(ParseOptions options);
    protected abstract virtual ISyntaxFacts GetSyntaxFacts();
    private void AnalyzeSyntax(SyntaxNodeAnalysisContext context, IMethodSymbol referenceEqualsMethod);
    private static ITypeParameterSymbol GetGenericParameterSymbol(ISyntaxFacts syntaxFacts, SemanticModel semanticModel, SyntaxNode node1, SyntaxNode node2, CancellationToken cancellationToken);
    private static bool MatchesPattern(ISyntaxFacts syntaxFacts, SyntaxNode node1, SyntaxNode node2);
}
internal static class Microsoft.CodeAnalysis.UseIsNullCheck.UseIsNullConstants : object {
    public static string Kind;
    public static string ReferenceEqualsKey;
    public static string CastAndEqualityKey;
    public static string Negated;
    public static string UnconstrainedGeneric;
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal abstract class Microsoft.CodeAnalysis.UseNamedArguments.AbstractUseNamedArgumentsCodeRefactoringProvider : CodeRefactoringProvider {
    private IAnalyzer _argumentAnalyzer;
    private IAnalyzer _attributeArgumentAnalyzer;
    protected AbstractUseNamedArgumentsCodeRefactoringProvider(IAnalyzer argumentAnalyzer, IAnalyzer attributeArgumentAnalyzer);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.UseNamedArguments.AbstractUseNamedArgumentsCodeRefactoringProvider/<ComputeRefactoringsAsync>d__5")]
public sealed virtual Task ComputeRefactoringsAsync(CodeRefactoringContext context);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal abstract class Microsoft.CodeAnalysis.UseNullPropagation.AbstractUseNullPropagationCodeFixProvider`10 : SyntaxEditorBasedCodeFixProvider {
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ImmutableArray`1<string> FixableDiagnosticIds { get; }
    internal CodeFixCategory CodeFixCategory { get; }
    protected abstract virtual TElementBindingExpression ElementBindingExpression(TElementBindingArgumentList argumentList);
    public virtual ImmutableArray`1<string> get_FixableDiagnosticIds();
    internal sealed virtual CodeFixCategory get_CodeFixCategory();
    protected virtual bool IncludeDiagnosticDuringFixAll(Diagnostic diagnostic);
    public virtual Task RegisterCodeFixesAsync(CodeFixContext context);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.UseNullPropagation.AbstractUseNullPropagationCodeFixProvider`10/<FixAllAsync>d__7")]
protected virtual Task FixAllAsync(Document document, ImmutableArray`1<Diagnostic> diagnostics, SyntaxEditor editor, CancellationToken cancellationToken);
    private SyntaxNode CreateConditionalAccessExpression(ISyntaxFactsService syntaxFacts, SyntaxGeneratorInternal generator, bool whenPartIsNullable, SyntaxNode whenPart, SyntaxNode match, SyntaxNode currentConditional);
    private SyntaxNode CreateConditionalAccessExpression(ISyntaxFactsService syntaxFacts, SyntaxGeneratorInternal generator, SyntaxNode whenPart, SyntaxNode match, SyntaxNode matchParent, SyntaxNode currentConditional);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal abstract class Microsoft.CodeAnalysis.UseNullPropagation.AbstractUseNullPropagationDiagnosticAnalyzer`8 : AbstractBuiltInCodeStyleDiagnosticAnalyzer {
    public virtual DiagnosticAnalyzerCategory GetAnalyzerCategory();
    protected abstract virtual bool ShouldAnalyze(ParseOptions options);
    protected abstract virtual ISyntaxFacts GetSyntaxFacts();
    protected abstract virtual bool IsInExpressionTree(SemanticModel semanticModel, SyntaxNode node, INamedTypeSymbol expressionTypeOpt, CancellationToken cancellationToken);
    protected abstract virtual bool TryAnalyzePatternCondition(ISyntaxFacts syntaxFacts, SyntaxNode conditionNode, SyntaxNode& conditionPartToCheck, Boolean& isEquals);
    protected virtual void InitializeWorker(AnalysisContext context);
    [NullableContextAttribute("2")]
private void AnalyzeSyntax(SyntaxNodeAnalysisContext context, INamedTypeSymbol expressionTypeOpt, IMethodSymbol referenceEqualsMethodOpt);
    private bool TryAnalyzeCondition(SyntaxNodeAnalysisContext context, ISyntaxFacts syntaxFacts, IMethodSymbol referenceEqualsMethodOpt, SyntaxNode conditionNode, SyntaxNode& conditionPartToCheck, Boolean& isEquals);
    private static bool TryAnalyzeBinaryExpressionCondition(ISyntaxFacts syntaxFacts, TBinaryExpressionSyntax condition, SyntaxNode& conditionPartToCheck, Boolean& isEquals);
    private static bool TryAnalyzeInvocationCondition(SyntaxNodeAnalysisContext context, ISyntaxFacts syntaxFacts, IMethodSymbol referenceEqualsMethodOpt, TInvocationExpression invocation, SyntaxNode& conditionPartToCheck, Boolean& isEquals);
    private static SyntaxNode GetConditionPartToCheck(ISyntaxFacts syntaxFacts, SyntaxNode conditionLeft, SyntaxNode conditionRight);
    internal static SyntaxNode GetWhenPartMatch(ISyntaxFacts syntaxFacts, SemanticModel semanticModel, SyntaxNode expressionToMatch, SyntaxNode whenPart);
    private static SyntaxNode RemoveObjectCastIfAny(ISyntaxFacts syntaxFacts, SemanticModel semanticModel, SyntaxNode node);
    private static SyntaxNode Unwrap(ISyntaxFacts syntaxFacts, SyntaxNode node);
    [CompilerGeneratedAttribute]
private void <InitializeWorker>b__6_0(CompilationStartAnalysisContext startContext);
}
internal static class Microsoft.CodeAnalysis.UseNullPropagation.UseNullPropagationConstants : object {
    [NullableAttribute("1")]
public static string WhenPartIsNullable;
}
internal abstract class Microsoft.CodeAnalysis.UseObjectInitializer.AbstractUseObjectInitializerCodeFixProvider`7 : SyntaxEditorBasedCodeFixProvider {
    public ImmutableArray`1<string> FixableDiagnosticIds { get; }
    internal CodeFixCategory CodeFixCategory { get; }
    public virtual ImmutableArray`1<string> get_FixableDiagnosticIds();
    internal sealed virtual CodeFixCategory get_CodeFixCategory();
    protected virtual bool IncludeDiagnosticDuringFixAll(Diagnostic diagnostic);
    public virtual Task RegisterCodeFixesAsync(CodeFixContext context);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.UseObjectInitializer.AbstractUseObjectInitializerCodeFixProvider`7/<FixAllAsync>d__6")]
protected virtual Task FixAllAsync(Document document, ImmutableArray`1<Diagnostic> diagnostics, SyntaxEditor editor, CancellationToken cancellationToken);
    protected abstract virtual TStatementSyntax GetNewStatement(TStatementSyntax statement, TObjectCreationExpressionSyntax objectCreation, ImmutableArray`1<Match`4<TExpressionSyntax, TStatementSyntax, TMemberAccessExpressionSyntax, TAssignmentStatementSyntax>> matches);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal abstract class Microsoft.CodeAnalysis.UseObjectInitializer.AbstractUseObjectInitializerDiagnosticAnalyzer`7 : AbstractBuiltInCodeStyleDiagnosticAnalyzer {
    protected bool FadeOutOperatorToken { get; }
    protected abstract virtual bool get_FadeOutOperatorToken();
    protected virtual void InitializeWorker(AnalysisContext context);
    protected abstract virtual bool AreObjectInitializersSupported(SyntaxNodeAnalysisContext context);
    protected abstract virtual bool IsValidContainingStatement(TStatementSyntax node);
    private void AnalyzeNode(SyntaxNodeAnalysisContext context);
    private void FadeOutCode(SyntaxNodeAnalysisContext context, ImmutableArray`1<Match`4<TExpressionSyntax, TStatementSyntax, TMemberAccessExpressionSyntax, TAssignmentStatementSyntax>> matches, ImmutableArray`1<Location> locations);
    protected abstract virtual ISyntaxFacts GetSyntaxFacts();
    public virtual DiagnosticAnalyzerCategory GetAnalyzerCategory();
}
[IsReadOnlyAttribute]
internal class Microsoft.CodeAnalysis.UseObjectInitializer.Match`4 : ValueType {
    public TAssignmentStatementSyntax Statement;
    public TMemberAccessExpressionSyntax MemberAccessExpression;
    public TExpressionSyntax Initializer;
    public string MemberName;
    public Match`4(TAssignmentStatementSyntax statement, TMemberAccessExpressionSyntax memberAccessExpression, TExpressionSyntax initializer, string memberName);
}
internal class Microsoft.CodeAnalysis.UseObjectInitializer.ObjectCreationExpressionAnalyzer`6 : AbstractObjectCreationExpressionAnalyzer`5<TExpressionSyntax, TStatementSyntax, TObjectCreationExpressionSyntax, TVariableDeclaratorSyntax, Match`4<TExpressionSyntax, TStatementSyntax, TMemberAccessExpressionSyntax, TAssignmentStatementSyntax>> {
    private static ObjectPool`1<ObjectCreationExpressionAnalyzer`6<TExpressionSyntax, TStatementSyntax, TObjectCreationExpressionSyntax, TMemberAccessExpressionSyntax, TAssignmentStatementSyntax, TVariableDeclaratorSyntax>> s_pool;
    private static ObjectCreationExpressionAnalyzer`6();
    public static Nullable`1<ImmutableArray`1<Match`4<TExpressionSyntax, TStatementSyntax, TMemberAccessExpressionSyntax, TAssignmentStatementSyntax>>> Analyze(SemanticModel semanticModel, ISyntaxFacts syntaxFacts, TObjectCreationExpressionSyntax objectCreationExpression, CancellationToken cancellationToken);
    protected virtual void AddMatches(ArrayBuilder`1<Match`4<TExpressionSyntax, TStatementSyntax, TMemberAccessExpressionSyntax, TAssignmentStatementSyntax>> matches);
    private static bool IsExplicitlyImplemented(INamedTypeSymbol classOrStructType, ISymbol member, ISymbol& typeMember);
    protected virtual bool ShouldAnalyze();
    private bool ImplicitMemberAccessWouldBeAffected(SyntaxNode node);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.CodeAnalysis.UseSystemHashCode.Analyzer : ValueType {
    private Compilation _compilation;
    private IMethodSymbol _objectGetHashCodeMethod;
    [NullableAttribute("2")]
private INamedTypeSymbol _equalityComparerType;
    public INamedTypeSymbol SystemHashCodeType;
    private Analyzer(Compilation compilation, IMethodSymbol objectGetHashCodeMethod, INamedTypeSymbol equalityComparerType, INamedTypeSymbol systemHashCodeType);
    public static bool TryGetAnalyzer(Compilation compilation, Analyzer& analyzer);
    [NullableContextAttribute("2")]
public ValueTuple`3<bool, ImmutableArray`1<ISymbol>, ImmutableArray`1<IOperation>> GetHashedMembers(ISymbol owningSymbol, IOperation operation);
    private Nullable`1<ValueTuple`2<bool, ImmutableArray`1<ISymbol>>> MatchTuplePattern(IMethodSymbol method, ImmutableArray`1<IOperation> statements);
    private Nullable`1<ValueTuple`2<bool, ImmutableArray`1<ISymbol>>> MatchAccumulatorPattern(IMethodSymbol method, ImmutableArray`1<IOperation> statements);
    [NullableContextAttribute("2")]
private bool OverridesSystemObject(IMethodSymbol method);
    private static bool IsLocalReference(IOperation value, ILocalSymbol accumulatorVariable);
    private static bool IsLiteralNumber(IOperation value);
    private static IOperation Unwrap(IOperation value);
}
[ExportCodeFixProviderAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.UseSystemHashCode.UseSystemHashCodeCodeFixProvider : SyntaxEditorBasedCodeFixProvider {
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private ImmutableArray`1<string> <FixableDiagnosticIds>k__BackingField;
    [CompilerGeneratedAttribute]
private CodeFixCategory <CodeFixCategory>k__BackingField;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ImmutableArray`1<string> FixableDiagnosticIds { get; }
    internal CodeFixCategory CodeFixCategory { get; }
    [CompilerGeneratedAttribute]
public virtual ImmutableArray`1<string> get_FixableDiagnosticIds();
    [CompilerGeneratedAttribute]
internal virtual CodeFixCategory get_CodeFixCategory();
    [NullableContextAttribute("1")]
public virtual Task RegisterCodeFixesAsync(CodeFixContext context);
    [NullableContextAttribute("1")]
[AsyncStateMachineAttribute("Microsoft.CodeAnalysis.UseSystemHashCode.UseSystemHashCodeCodeFixProvider/<FixAllAsync>d__8")]
protected virtual Task FixAllAsync(Document document, ImmutableArray`1<Diagnostic> diagnostics, SyntaxEditor editor, CancellationToken cancellationToken);
}
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
internal class Microsoft.CodeAnalysis.UseSystemHashCode.UseSystemHashCodeDiagnosticAnalyzer : AbstractBuiltInCodeStyleDiagnosticAnalyzer {
    public virtual DiagnosticAnalyzerCategory GetAnalyzerCategory();
    [NullableContextAttribute("1")]
protected virtual void InitializeWorker(AnalysisContext context);
    private void AnalyzeOperationBlock(Analyzer analyzer, OperationBlockAnalysisContext context);
    [NullableContextAttribute("1")]
[CompilerGeneratedAttribute]
private void <InitializeWorker>b__2_0(CompilationStartAnalysisContext c);
}
internal abstract class Microsoft.CodeAnalysis.UseThrowExpression.AbstractUseThrowExpressionDiagnosticAnalyzer : AbstractBuiltInCodeStyleDiagnosticAnalyzer {
    private Option2`1<CodeStyleOption2`1<bool>> _preferThrowExpressionOption;
    protected AbstractUseThrowExpressionDiagnosticAnalyzer(Option2`1<CodeStyleOption2`1<bool>> preferThrowExpressionOption, string language);
    public virtual DiagnosticAnalyzerCategory GetAnalyzerCategory();
    protected abstract virtual bool IsSupported(ParseOptions options);
    protected virtual void InitializeWorker(AnalysisContext context);
    private void AnalyzeOperation(OperationAnalysisContext context, INamedTypeSymbol expressionTypeOpt);
    private static bool ValueIsAccessed(SemanticModel semanticModel, IConditionalOperation ifOperation, IBlockOperation containingBlock, ISymbol localOrParameter, IExpressionStatementOperation expressionStatement, IAssignmentOperation assignmentExpression);
    protected abstract virtual bool IsInExpressionTree(SemanticModel semanticModel, SyntaxNode node, INamedTypeSymbol expressionTypeOpt, CancellationToken cancellationToken);
    private bool TryFindAssignmentExpression(IBlockOperation containingBlock, IConditionalOperation ifOperation, ISymbol localOrParameter, IExpressionStatementOperation& expressionStatement, IAssignmentOperation& assignmentExpression);
    private bool TryDecomposeIfCondition(IConditionalOperation ifStatement, ISymbol& localOrParameter);
    private bool TryGetLocalOrParameterSymbol(IOperation operation, ISymbol& localOrParameter);
    private static bool IsNull(IOperation operation);
    private static IConditionalOperation GetContainingIfOperation(SemanticModel semanticModel, IThrowOperation throwOperation, CancellationToken cancellationToken);
    [NullableContextAttribute("1")]
[CompilerGeneratedAttribute]
private void <InitializeWorker>b__4_0(CompilationStartAnalysisContext startContext);
}
[ExportCodeFixProviderAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.UseThrowExpression.UseThrowExpressionCodeFixProvider : SyntaxEditorBasedCodeFixProvider {
    public ImmutableArray`1<string> FixableDiagnosticIds { get; }
    internal CodeFixCategory CodeFixCategory { get; }
    public virtual ImmutableArray`1<string> get_FixableDiagnosticIds();
    internal sealed virtual CodeFixCategory get_CodeFixCategory();
    protected virtual bool IncludeDiagnosticDuringFixAll(Diagnostic diagnostic);
    public virtual Task RegisterCodeFixesAsync(CodeFixContext context);
    protected virtual Task FixAllAsync(Document document, ImmutableArray`1<Diagnostic> diagnostics, SyntaxEditor editor, CancellationToken cancellationToken);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal abstract class Microsoft.CodeAnalysis.ValidateFormatString.AbstractValidateFormatStringDiagnosticAnalyzer`1 : DiagnosticAnalyzer {
    private static string DiagnosticID;
    private static LocalizableString Title;
    private static LocalizableString MessageFormat;
    private static LocalizableString Description;
    private static DiagnosticDescriptor Rule;
    private static Regex s_removeEscapedBracketsRegex;
    private static Regex s_extractPlaceholdersRegex;
    private static string NameOfArgsParameter;
    private static string NameOfFormatStringParameter;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    private static AbstractValidateFormatStringDiagnosticAnalyzer`1();
    public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    protected abstract virtual ISyntaxFacts GetSyntaxFacts();
    protected abstract virtual SyntaxNode GetArgumentExpression(SyntaxNode syntaxNode);
    protected abstract virtual SyntaxNode TryGetMatchingNamedArgument(SeparatedSyntaxList`1<SyntaxNode> arguments, string searchArgumentName);
    public virtual void Initialize(AnalysisContext context);
    private void AnalyzeNode(SyntaxNodeAnalysisContext context, INamedTypeSymbol formatProviderType);
    private static bool IsValidFormatMethod(ISyntaxFacts syntaxFacts, SyntaxNode expression);
    private bool ArgsIsArrayOfReferenceTypes(SemanticModel semanticModel, SeparatedSyntaxList`1<SyntaxNode> arguments, ImmutableArray`1<IParameterSymbol> parameters, ISyntaxFacts syntaxFacts);
    private ITypeSymbol TryGetArgsArgumentType(SemanticModel semanticModel, SeparatedSyntaxList`1<SyntaxNode> arguments, ImmutableArray`1<IParameterSymbol> parameters, ISyntaxFacts syntaxFacts);
    protected SyntaxNode TryGetArgument(string searchArgumentName, SeparatedSyntaxList`1<SyntaxNode> arguments, ImmutableArray`1<IParameterSymbol> parameters);
    private static IParameterSymbol GetParameterWithMatchingName(ImmutableArray`1<IParameterSymbol> parameters, string searchArgumentName);
    protected SyntaxNode TryGetFormatStringLiteralExpressionSyntax(SeparatedSyntaxList`1<SyntaxNode> arguments, ImmutableArray`1<IParameterSymbol> parameters, ISyntaxFacts syntaxFacts);
    [NullableContextAttribute("2")]
protected static IMethodSymbol TryGetValidFormatMethodSymbol(SymbolInfo symbolInfo);
    private static bool FormatCallWorksAtRuntime(string formatString, int numberOfPlaceholderArguments);
    protected static void ValidateAndReportDiagnostic(SyntaxNodeAnalysisContext context, int numberOfPlaceholderArguments, string formatString, int formatStringPosition);
    private static string RemoveEscapedBrackets(string formatString);
    private static bool PlaceholderIndexIsValid(string textInsideBrackets, int numberOfPlaceholderArguments);
    [CompilerGeneratedAttribute]
private void <Initialize>b__14_0(CompilationStartAnalysisContext startContext);
}
internal class Microsoft.CodeAnalysis.ValidateFormatString.ValidateFormatStringOption : object {
    [NullableAttribute("1")]
public static PerLanguageOption2`1<bool> ReportInvalidPlaceholdersInStringDotFormatCalls;
    private static ValidateFormatStringOption();
}
[ExportOptionProviderAttribute]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.ValidateFormatString.ValidateFormatStringOptionProvider : object {
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private ImmutableArray`1<IOption> <Options>k__BackingField;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ImmutableArray`1<IOption> Options { get; }
    [CompilerGeneratedAttribute]
public sealed virtual ImmutableArray`1<IOption> get_Options();
}
internal abstract class Microsoft.CodeAnalysis.Wrapping.AbstractSyntaxWrapper : object {
    [CompilerGeneratedAttribute]
private IIndentationService <IndentationService>k__BackingField;
    protected IIndentationService IndentationService { get; }
    protected AbstractSyntaxWrapper(IIndentationService indentationService);
    [CompilerGeneratedAttribute]
protected IIndentationService get_IndentationService();
    public abstract virtual Task`1<ICodeActionComputer> TryCreateComputerAsync(Document document, int position, SyntaxNode node, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.Wrapping.AbstractSyntaxWrapper/<ContainsUnformattableContentAsync>d__6")]
protected static Task`1<bool> ContainsUnformattableContentAsync(Document document, IEnumerable`1<SyntaxNodeOrToken> nodesAndTokens, CancellationToken cancellationToken);
}
internal abstract class Microsoft.CodeAnalysis.Wrapping.AbstractWrappingCodeRefactoringProvider : CodeRefactoringProvider {
    private ImmutableArray`1<ISyntaxWrapper> _wrappers;
    protected AbstractWrappingCodeRefactoringProvider(ImmutableArray`1<ISyntaxWrapper> wrappers);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.Wrapping.AbstractWrappingCodeRefactoringProvider/<ComputeRefactoringsAsync>d__2")]
public virtual Task ComputeRefactoringsAsync(CodeRefactoringContext context);
}
internal abstract class Microsoft.CodeAnalysis.Wrapping.BinaryExpression.AbstractBinaryExpressionWrapper`1 : AbstractSyntaxWrapper {
    private ISyntaxFacts _syntaxFacts;
    private IPrecedenceService _precedenceService;
    protected AbstractBinaryExpressionWrapper`1(IIndentationService indentationService, ISyntaxFacts syntaxFacts, IPrecedenceService precedenceService);
    protected abstract virtual SyntaxTriviaList GetNewLineBeforeOperatorTrivia(SyntaxTriviaList newLine);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.Wrapping.BinaryExpression.AbstractBinaryExpressionWrapper`1/<TryCreateComputerAsync>d__4")]
public sealed virtual Task`1<ICodeActionComputer> TryCreateComputerAsync(Document document, int position, SyntaxNode node, CancellationToken cancellationToken);
    private ImmutableArray`1<SyntaxNodeOrToken> GetExpressionsAndOperators(PrecedenceKind precedence, TBinaryExpressionSyntax binaryExpr);
    private void AddExpressionsAndOperators(PrecedenceKind precedence, SyntaxNode expr, ArrayBuilder`1<SyntaxNodeOrToken> result);
}
internal abstract class Microsoft.CodeAnalysis.Wrapping.ChainedExpression.AbstractChainedExpressionWrapper`2 : AbstractSyntaxWrapper {
    private ISyntaxFacts _syntaxFacts;
    private int _dotToken;
    private int _questionToken;
    protected AbstractChainedExpressionWrapper`2(IIndentationService indentationService, ISyntaxFacts syntaxFacts);
    protected abstract virtual SyntaxTriviaList GetNewLineBeforeOperatorTrivia(SyntaxTriviaList newLine);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.Wrapping.ChainedExpression.AbstractChainedExpressionWrapper`2/<TryCreateComputerAsync>d__5")]
public sealed virtual Task`1<ICodeActionComputer> TryCreateComputerAsync(Document document, int position, SyntaxNode node, CancellationToken cancellationToken);
    private ImmutableArray`1<ImmutableArray`1<SyntaxNodeOrToken>> GetChainChunks(SyntaxNode node);
    private void BreakPiecesIntoChunks(ArrayBuilder`1<SyntaxNodeOrToken> pieces, ArrayBuilder`1<ImmutableArray`1<SyntaxNodeOrToken>> chunks);
    private int FindNextChunkStart(ArrayBuilder`1<SyntaxNodeOrToken> pieces, bool firstChunk, int index);
    private static bool IsNode(ArrayBuilder`1<SyntaxNodeOrToken> pieces, int index);
    private static bool IsToken(int tokenKind, ArrayBuilder`1<SyntaxNodeOrToken> pieces, int index);
    private static ImmutableArray`1<SyntaxNodeOrToken> GetSubRange(ArrayBuilder`1<SyntaxNodeOrToken> pieces, int start, int end);
    private bool IsDecomposableChainPart(SyntaxNode node);
    private void Decompose(SyntaxNode node, ArrayBuilder`1<SyntaxNodeOrToken> pieces);
}
[IsReadOnlyAttribute]
internal class Microsoft.CodeAnalysis.Wrapping.Edit : ValueType {
    public SyntaxToken Left;
    public SyntaxToken Right;
    public SyntaxTriviaList NewLeftTrailingTrivia;
    public SyntaxTriviaList NewRightLeadingTrivia;
    private Edit(SyntaxToken left, SyntaxTriviaList newLeftTrailingTrivia, SyntaxToken right, SyntaxTriviaList newRightLeadingTrivia);
    public string GetNewTrivia();
    private static void AppendTrivia(PooledStringBuilder result, SyntaxTriviaList triviaList);
    public static Edit DeleteBetween(SyntaxNodeOrToken left, SyntaxNodeOrToken right);
    public static Edit UpdateBetween(SyntaxNodeOrToken left, SyntaxTriviaList leftTrailingTrivia, SyntaxTrivia rightLeadingTrivia, SyntaxNodeOrToken right);
    public static Edit UpdateBetween(SyntaxNodeOrToken left, SyntaxTriviaList leftTrailingTrivia, SyntaxTriviaList rightLeadingTrivia, SyntaxNodeOrToken right);
}
internal interface Microsoft.CodeAnalysis.Wrapping.ICodeActionComputer {
    public abstract virtual Task`1<ImmutableArray`1<CodeAction>> GetTopLevelCodeActionsAsync();
}
internal interface Microsoft.CodeAnalysis.Wrapping.ISyntaxWrapper {
    public abstract virtual Task`1<ICodeActionComputer> TryCreateComputerAsync(Document document, int position, SyntaxNode node, CancellationToken cancellationToken);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal abstract class Microsoft.CodeAnalysis.Wrapping.SeparatedSyntaxList.AbstractSeparatedSyntaxListWrapper`2 : AbstractSyntaxWrapper {
    protected string Unwrap_list { get; }
    protected string Wrap_long_list { get; }
    protected string Unwrap_and_indent_all_items { get; }
    protected string Unwrap_all_items { get; }
    protected string Indent_all_items { get; }
    protected string Align_wrapped_items { get; }
    protected string Indent_wrapped_items { get; }
    protected string Wrap_every_item { get; }
    protected AbstractSeparatedSyntaxListWrapper`2(IIndentationService indentationService);
    protected abstract virtual string get_Unwrap_list();
    protected abstract virtual string get_Wrap_long_list();
    protected abstract virtual string get_Unwrap_and_indent_all_items();
    protected abstract virtual string get_Unwrap_all_items();
    protected abstract virtual string get_Indent_all_items();
    protected abstract virtual string get_Align_wrapped_items();
    protected abstract virtual string get_Indent_wrapped_items();
    protected abstract virtual string get_Wrap_every_item();
    protected abstract virtual TListSyntax TryGetApplicableList(SyntaxNode node);
    protected abstract virtual SeparatedSyntaxList`1<TListItemSyntax> GetListItems(TListSyntax listSyntax);
    protected abstract virtual bool PositionIsApplicable(SyntaxNode root, int position, SyntaxNode declaration, TListSyntax listSyntax);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.Wrapping.SeparatedSyntaxList.AbstractSeparatedSyntaxListWrapper`2/<TryCreateComputerAsync>d__20")]
public virtual Task`1<ICodeActionComputer> TryCreateComputerAsync(Document document, int position, SyntaxNode declaration, CancellationToken cancellationToken);
}
internal enum Microsoft.CodeAnalysis.Wrapping.SeparatedSyntaxList.WrappingStyle : Enum {
    public int value__;
    public static WrappingStyle WrapFirst_IndentRest;
    public static WrappingStyle UnwrapFirst_AlignRest;
    public static WrappingStyle UnwrapFirst_IndentRest;
}
internal class Microsoft.CodeAnalysis.Wrapping.WrapItemsAction : DocumentChangeAction {
    private static ImmutableArray`1<string> s_mruTitles;
    [CompilerGeneratedAttribute]
private string <ParentTitle>k__BackingField;
    [CompilerGeneratedAttribute]
private string <SortTitle>k__BackingField;
    public string ParentTitle { get; }
    public string SortTitle { get; }
    internal CodeActionPriority Priority { get; }
    public WrapItemsAction(string title, string parentTitle, Func`2<CancellationToken, Task`1<Document>> createChangedDocument);
    private static WrapItemsAction();
    [CompilerGeneratedAttribute]
public string get_ParentTitle();
    [CompilerGeneratedAttribute]
public string get_SortTitle();
    internal virtual CodeActionPriority get_Priority();
    protected virtual Task`1<IEnumerable`1<CodeActionOperation>> ComputePreviewOperationsAsync(CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.Wrapping.WrapItemsAction/<ComputeOperationsAsync>d__11")]
protected virtual Task`1<IEnumerable`1<CodeActionOperation>> ComputeOperationsAsync(CancellationToken cancellationToken);
    public static ImmutableArray`1<CodeAction> SortActionsByMostRecentlyUsed(ImmutableArray`1<CodeAction> codeActions);
    public static ImmutableArray`1<T> SortByMostRecentlyUsed(ImmutableArray`1<T> items, ImmutableArray`1<string> mostRecentlyUsedKeys, Func`2<T, string> getKey);
    private static string GetSortTitle(CodeAction codeAction);
    [NullableContextAttribute("1")]
[CompilerGeneratedAttribute]
[DebuggerHiddenAttribute]
private Task`1<IEnumerable`1<CodeActionOperation>> <>n__0(CancellationToken cancellationToken);
}
[IsReadOnlyAttribute]
internal class Microsoft.CodeAnalysis.Wrapping.WrappingGroup : ValueType {
    public bool IsInlinable;
    public ImmutableArray`1<WrapItemsAction> WrappingActions;
    public WrappingGroup(bool isInlinable, ImmutableArray`1<WrapItemsAction> wrappingActions);
}
[CompilerGeneratedAttribute]
[EmbeddedAttribute]
internal class System.Runtime.CompilerServices.IsReadOnlyAttribute : Attribute {
}
[CompilerGeneratedAttribute]
[EmbeddedAttribute]
[AttributeUsageAttribute("27524")]
internal class System.Runtime.CompilerServices.NullableAttribute : Attribute {
    public Byte[] NullableFlags;
    public NullableAttribute(byte );
    public NullableAttribute(Byte[] );
}
[CompilerGeneratedAttribute]
[EmbeddedAttribute]
[AttributeUsageAttribute("5196")]
internal class System.Runtime.CompilerServices.NullableContextAttribute : Attribute {
    public byte Flag;
    public NullableContextAttribute(byte );
}
