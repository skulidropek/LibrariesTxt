public enum Microsoft.DocAsCode.MarkdownLite.Align : Enum {
    public int value__;
    public static Align NotSpec;
    public static Align Left;
    public static Align Center;
    public static Align Right;
}
public class Microsoft.DocAsCode.MarkdownLite.CompositeMarkdownTokenAggregator : object {
    private ImmutableArray`1<IMarkdownTokenAggregator> _aggregators;
    public CompositeMarkdownTokenAggregator(IEnumerable`1<IMarkdownTokenAggregator> aggregators);
    public sealed virtual bool Aggregate(IMarkdownTokenAggregateContext context);
}
public class Microsoft.DocAsCode.MarkdownLite.EmptyRenderer : object {
    public virtual StringBuffer Render(IMarkdownRenderer renderer, IMarkdownToken token, IMarkdownContext context);
}
public class Microsoft.DocAsCode.MarkdownLite.GfmDelInlineRule : object {
    public string Name { get; }
    public Regex Del { get; }
    public virtual string get_Name();
    public virtual Regex get_Del();
    public virtual IMarkdownToken TryMatch(IMarkdownParser parser, IMarkdownParsingContext context);
}
public class Microsoft.DocAsCode.MarkdownLite.GfmDelInlineToken : object {
    [CompilerGeneratedAttribute]
private IMarkdownRule <Rule>k__BackingField;
    [CompilerGeneratedAttribute]
private IMarkdownContext <Context>k__BackingField;
    [CompilerGeneratedAttribute]
private ImmutableArray`1<IMarkdownToken> <Content>k__BackingField;
    [CompilerGeneratedAttribute]
private SourceInfo <SourceInfo>k__BackingField;
    public IMarkdownRule Rule { get; }
    public IMarkdownContext Context { get; }
    public ImmutableArray`1<IMarkdownToken> Content { get; }
    public SourceInfo SourceInfo { get; }
    public GfmDelInlineToken(IMarkdownRule rule, IMarkdownContext context, ImmutableArray`1<IMarkdownToken> content, SourceInfo sourceInfo);
    [CompilerGeneratedAttribute]
public sealed virtual IMarkdownRule get_Rule();
    [CompilerGeneratedAttribute]
public sealed virtual IMarkdownContext get_Context();
    [CompilerGeneratedAttribute]
public ImmutableArray`1<IMarkdownToken> get_Content();
    [CompilerGeneratedAttribute]
public sealed virtual SourceInfo get_SourceInfo();
    public sealed virtual GfmDelInlineToken Rewrite(IMarkdownRewriteEngine rewriterEngine);
    public sealed virtual IEnumerable`1<IMarkdownToken> GetChildren();
}
public class Microsoft.DocAsCode.MarkdownLite.GfmEmInlineRule : MarkdownEmInlineRule {
    public string Name { get; }
    public Regex Em { get; }
    public virtual string get_Name();
    public virtual Regex get_Em();
}
public class Microsoft.DocAsCode.MarkdownLite.GfmEmojiInlineRule : object {
    private static Dictionary`2<string, string> _emoji;
    public string Name { get; }
    public Regex Emoji { get; }
    private static GfmEmojiInlineRule();
    public virtual string get_Name();
    public virtual Regex get_Emoji();
    protected virtual string GetEmoji(string shortCode);
    public virtual IMarkdownToken TryMatch(IMarkdownParser parser, IMarkdownParsingContext context);
    private static Dictionary`2<string, string> LoadEmoji();
}
public class Microsoft.DocAsCode.MarkdownLite.GfmEmojiInlineToken : object {
    [CompilerGeneratedAttribute]
private IMarkdownRule <Rule>k__BackingField;
    [CompilerGeneratedAttribute]
private IMarkdownContext <Context>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ShortCode>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Emoji>k__BackingField;
    [CompilerGeneratedAttribute]
private SourceInfo <SourceInfo>k__BackingField;
    public IMarkdownRule Rule { get; }
    public IMarkdownContext Context { get; }
    public string ShortCode { get; }
    public string Emoji { get; }
    public SourceInfo SourceInfo { get; }
    public GfmEmojiInlineToken(IMarkdownRule rule, IMarkdownContext context, string shortCode, string emoji, SourceInfo sourceInfo);
    [CompilerGeneratedAttribute]
public sealed virtual IMarkdownRule get_Rule();
    [CompilerGeneratedAttribute]
public sealed virtual IMarkdownContext get_Context();
    [CompilerGeneratedAttribute]
public string get_ShortCode();
    [CompilerGeneratedAttribute]
public string get_Emoji();
    [CompilerGeneratedAttribute]
public sealed virtual SourceInfo get_SourceInfo();
}
public class Microsoft.DocAsCode.MarkdownLite.GfmEngineBuilder : MarkdownEngineBuilder {
    public GfmEngineBuilder(Options options);
    protected virtual void BuildRules();
    protected virtual void BuildBlockRules();
    protected virtual void BuildInlineRules();
}
public class Microsoft.DocAsCode.MarkdownLite.GfmEscapeInlineRule : MarkdownEscapeInlineRule {
    public Regex Escape { get; }
    public virtual Regex get_Escape();
}
public class Microsoft.DocAsCode.MarkdownLite.GfmFencesBlockRule : object {
    private static Matcher _EndFences;
    private static Matcher _FencesMatcher;
    public string Name { get; }
    public Matcher FencesMatcher { get; }
    [ObsoleteAttribute("Please use FencesMatcher.", "True")]
public Regex Fences { get; }
    private static GfmFencesBlockRule();
    public virtual string get_Name();
    public virtual Matcher get_FencesMatcher();
    public virtual Regex get_Fences();
    public sealed virtual IMarkdownToken TryMatch(IMarkdownParser parser, IMarkdownParsingContext context);
}
[ObsoleteAttribute]
public class Microsoft.DocAsCode.MarkdownLite.GfmHeadingBlockRule : MarkdownHeadingBlockRule {
}
public class Microsoft.DocAsCode.MarkdownLite.GfmHtmlCommentBlockRule : object {
    private static Matcher _HtmlCommentMatcher;
    public string Name { get; }
    [ObsoleteAttribute("Please use HtmlCommentMatcher.")]
public Regex HtmlComment { get; }
    public Matcher HtmlCommentMatcher { get; }
    private static GfmHtmlCommentBlockRule();
    public virtual string get_Name();
    public virtual Regex get_HtmlComment();
    public virtual Matcher get_HtmlCommentMatcher();
    public virtual IMarkdownToken TryMatch(IMarkdownParser parser, IMarkdownParsingContext context);
    private IMarkdownToken TryMatchOld(IMarkdownParser parser, IMarkdownParsingContext context);
}
public class Microsoft.DocAsCode.MarkdownLite.GfmStrongEmInlineRule : object {
    public string Name { get; }
    public Regex StrongEm { get; }
    public virtual string get_Name();
    public virtual Regex get_StrongEm();
    public virtual IMarkdownToken TryMatch(IMarkdownParser parser, IMarkdownParsingContext context);
    private ImmutableArray`1<IMarkdownToken> GetContent(IMarkdownParser parser, Match match, SourceInfo sourceInfo);
}
public class Microsoft.DocAsCode.MarkdownLite.GfmStrongInlineRule : MarkdownStrongInlineRule {
    public string Name { get; }
    public Regex Strong { get; }
    public virtual string get_Name();
    public virtual Regex get_Strong();
}
public class Microsoft.DocAsCode.MarkdownLite.GfmTextInlineRule : MarkdownTextInlineRule {
    public Regex Text { get; }
    public virtual Regex get_Text();
}
public class Microsoft.DocAsCode.MarkdownLite.GfmUrlInlineRule : object {
    public string Name { get; }
    public Regex Url { get; }
    public virtual string get_Name();
    public virtual Regex get_Url();
    public virtual IMarkdownToken TryMatch(IMarkdownParser parser, IMarkdownParsingContext context);
}
public class Microsoft.DocAsCode.MarkdownLite.HtmlRenderer : object {
    public virtual StringBuffer Render(IMarkdownRenderer renderer, MarkdownNewLineBlockToken token, MarkdownBlockContext context);
    public virtual StringBuffer Render(IMarkdownRenderer renderer, MarkdownCodeBlockToken token, MarkdownBlockContext context);
    public virtual StringBuffer Render(IMarkdownRenderer renderer, MarkdownHeadingBlockToken token, MarkdownBlockContext context);
    public virtual StringBuffer Render(IMarkdownRenderer renderer, MarkdownHrBlockToken token, MarkdownBlockContext context);
    public virtual StringBuffer Render(IMarkdownRenderer renderer, MarkdownBlockquoteBlockToken token, MarkdownBlockContext context);
    public virtual StringBuffer Render(IMarkdownRenderer renderer, MarkdownListBlockToken token, MarkdownBlockContext context);
    protected virtual StringBuffer Render(IMarkdownRenderer renderer, MarkdownListItemBlockToken token);
    public virtual StringBuffer Render(IMarkdownRenderer renderer, MarkdownHtmlBlockToken token, MarkdownBlockContext context);
    public virtual StringBuffer Render(IMarkdownRenderer renderer, MarkdownParagraphBlockToken token, MarkdownBlockContext context);
    public virtual StringBuffer Render(IMarkdownRenderer renderer, MarkdownTextToken token, MarkdownBlockContext context);
    public virtual StringBuffer Render(IMarkdownRenderer renderer, MarkdownTableBlockToken token, MarkdownBlockContext context);
    public virtual StringBuffer Render(IMarkdownRenderer renderer, MarkdownNonParagraphBlockToken token, MarkdownBlockContext context);
    public virtual StringBuffer Render(IMarkdownRenderer renderer, MarkdownEscapeInlineToken token, MarkdownInlineContext context);
    public virtual StringBuffer Render(IMarkdownRenderer renderer, MarkdownLinkInlineToken token, MarkdownInlineContext context);
    public virtual StringBuffer Render(IMarkdownRenderer renderer, MarkdownImageInlineToken token, MarkdownInlineContext context);
    public virtual StringBuffer Render(IMarkdownRenderer renderer, MarkdownStrongInlineToken token, MarkdownInlineContext context);
    public virtual StringBuffer Render(IMarkdownRenderer renderer, MarkdownEmInlineToken token, MarkdownInlineContext context);
    public virtual StringBuffer Render(IMarkdownRenderer renderer, MarkdownCodeInlineToken token, MarkdownInlineContext context);
    public virtual StringBuffer Render(IMarkdownRenderer renderer, GfmDelInlineToken token, MarkdownInlineContext context);
    public virtual StringBuffer Render(IMarkdownRenderer renderer, MarkdownTagInlineToken token, MarkdownInlineContext context);
    public virtual StringBuffer Render(IMarkdownRenderer renderer, MarkdownBrInlineToken token, MarkdownInlineContext context);
    public virtual StringBuffer Render(IMarkdownRenderer renderer, GfmEmojiInlineToken token, MarkdownInlineContext context);
    public virtual StringBuffer Render(IMarkdownRenderer renderer, MarkdownTextToken token, MarkdownInlineContext context);
    public virtual StringBuffer Render(IMarkdownRenderer renderer, MarkdownIgnoreToken token, IMarkdownContext context);
    public virtual StringBuffer Render(IMarkdownRenderer renderer, MarkdownRawToken token, IMarkdownContext context);
    public static StringBuffer AppendSourceInfo(StringBuffer result, Options options, IMarkdownToken token);
    private static StringBuffer AppendSourceInfoCore(StringBuffer result, IMarkdownToken token);
    protected static StringBuffer AppendSourceInfo(StringBuffer result, IMarkdownRenderer renderer, IMarkdownToken token);
    protected static StringBuffer AppendAttribute(StringBuffer buffer, string attributeName, string value);
}
public interface Microsoft.DocAsCode.MarkdownLite.IInitializable {
    public abstract virtual void Initialize(IMarkdownRewriteEngine rewriteEngine);
}
public interface Microsoft.DocAsCode.MarkdownLite.IMarkdownContext {
    public ImmutableList`1<IMarkdownRule> Rules { get; }
    public ImmutableDictionary`2<string, object> Variables { get; }
    public abstract virtual ImmutableList`1<IMarkdownRule> get_Rules();
    public abstract virtual ImmutableDictionary`2<string, object> get_Variables();
    public abstract virtual IMarkdownContext CreateContext(ImmutableDictionary`2<string, object> variables);
}
public interface Microsoft.DocAsCode.MarkdownLite.IMarkdownEngine {
    public IMarkdownParser Parser { get; }
    public IMarkdownRenderer Renderer { get; }
    public IMarkdownRewriteEngine RewriteEngine { get; }
    public IMarkdownTokenTreeValidator TokenTreeValidator { get; public set; }
    public abstract virtual IMarkdownParser get_Parser();
    public abstract virtual IMarkdownRenderer get_Renderer();
    public abstract virtual IMarkdownRewriteEngine get_RewriteEngine();
    public abstract virtual IMarkdownTokenTreeValidator get_TokenTreeValidator();
    public abstract virtual void set_TokenTreeValidator(IMarkdownTokenTreeValidator value);
    public abstract virtual StringBuffer Mark(SourceInfo sourceInfo, IMarkdownContext context);
    public abstract virtual string Markup(string markdown, string file);
}
public interface Microsoft.DocAsCode.MarkdownLite.IMarkdownExpression {
    public abstract virtual IEnumerable`1<IMarkdownToken> GetChildren();
}
public interface Microsoft.DocAsCode.MarkdownLite.IMarkdownParser {
    public IMarkdownContext Context { get; }
    public Dictionary`2<string, LinkObj> Links { get; }
    public Options Options { get; }
    public abstract virtual IMarkdownContext get_Context();
    public abstract virtual Dictionary`2<string, LinkObj> get_Links();
    public abstract virtual Options get_Options();
    public abstract virtual IMarkdownContext SwitchContext(IMarkdownContext context);
    public abstract virtual ImmutableArray`1<IMarkdownToken> Tokenize(SourceInfo sourceInfo);
}
public interface Microsoft.DocAsCode.MarkdownLite.IMarkdownParsingContext {
    public string Markdown { get; }
    public string CurrentMarkdown { get; }
    public int LineNumber { get; }
    public string File { get; }
    public bool IsInParagraph { get; public set; }
    public abstract virtual string get_Markdown();
    public abstract virtual string get_CurrentMarkdown();
    public abstract virtual int get_LineNumber();
    public abstract virtual string get_File();
    public abstract virtual bool get_IsInParagraph();
    public abstract virtual void set_IsInParagraph(bool value);
    public abstract virtual SourceInfo Consume(int charCount);
    public abstract virtual MatchResult Match(Matcher matcher);
}
public interface Microsoft.DocAsCode.MarkdownLite.IMarkdownRenderer {
    public IMarkdownEngine Engine { get; }
    public Dictionary`2<string, LinkObj> Links { get; }
    public Options Options { get; }
    public abstract virtual IMarkdownEngine get_Engine();
    public abstract virtual Dictionary`2<string, LinkObj> get_Links();
    public abstract virtual Options get_Options();
    public abstract virtual StringBuffer Render(IMarkdownToken token);
}
public interface Microsoft.DocAsCode.MarkdownLite.IMarkdownRewritable`1 {
    public abstract virtual T Rewrite(IMarkdownRewriteEngine rewriteEngine);
}
public interface Microsoft.DocAsCode.MarkdownLite.IMarkdownRewriteEngine {
    public IMarkdownEngine Engine { get; }
    public abstract virtual IMarkdownEngine get_Engine();
    public abstract virtual ImmutableArray`1<IMarkdownToken> Rewrite(ImmutableArray`1<IMarkdownToken> tokens);
    public abstract virtual ImmutableArray`1<IMarkdownToken> GetParents();
    public abstract virtual bool HasVariable(string name);
    public abstract virtual object GetVariable(string name);
    public abstract virtual void SetVariable(string name, object value);
    public abstract virtual void RemoveVariable(string name);
    public abstract virtual bool HasPostProcess(string name);
    public abstract virtual void SetPostProcess(string name, Action`1<IMarkdownRewriteEngine> action);
    public abstract virtual void RemovePostProcess(string name);
    public abstract virtual void Initialize();
    public abstract virtual void Complete();
}
public interface Microsoft.DocAsCode.MarkdownLite.IMarkdownRule {
    public string Name { get; }
    public abstract virtual string get_Name();
    public abstract virtual IMarkdownToken TryMatch(IMarkdownParser parser, IMarkdownParsingContext context);
}
public interface Microsoft.DocAsCode.MarkdownLite.IMarkdownToken {
    public IMarkdownRule Rule { get; }
    public IMarkdownContext Context { get; }
    public SourceInfo SourceInfo { get; }
    public abstract virtual IMarkdownRule get_Rule();
    public abstract virtual IMarkdownContext get_Context();
    public abstract virtual SourceInfo get_SourceInfo();
}
public interface Microsoft.DocAsCode.MarkdownLite.IMarkdownTokenAggregateContext {
    public IMarkdownToken ParentToken { get; }
    public IMarkdownToken CurrentToken { get; }
    public abstract virtual IMarkdownToken get_ParentToken();
    public abstract virtual IMarkdownToken get_CurrentToken();
    public abstract virtual IMarkdownToken LookAhead(int offset);
    public abstract virtual void AggregateTo(IMarkdownToken token, int tokenCount);
}
public interface Microsoft.DocAsCode.MarkdownLite.IMarkdownTokenAggregator {
    public abstract virtual bool Aggregate(IMarkdownTokenAggregateContext context);
}
public interface Microsoft.DocAsCode.MarkdownLite.IMarkdownTokenRewriter {
    public abstract virtual IMarkdownToken Rewrite(IMarkdownRewriteEngine engine, IMarkdownToken token);
}
public interface Microsoft.DocAsCode.MarkdownLite.IMarkdownTokenTreeValidator {
    public abstract virtual void Validate(ImmutableArray`1<IMarkdownToken> tokens);
}
public interface Microsoft.DocAsCode.MarkdownLite.IMarkdownTokenValidator {
    public abstract virtual void Validate(IMarkdownToken token);
}
public interface Microsoft.DocAsCode.MarkdownLite.IMarkdownTokenValidatorProvider {
    public abstract virtual ImmutableArray`1<IMarkdownTokenValidator> GetValidators();
}
public class Microsoft.DocAsCode.MarkdownLite.InlineContent : object {
    [CompilerGeneratedAttribute]
private ImmutableArray`1<IMarkdownToken> <Tokens>k__BackingField;
    public ImmutableArray`1<IMarkdownToken> Tokens { get; }
    public InlineContent(ImmutableArray`1<IMarkdownToken> tokens);
    [CompilerGeneratedAttribute]
public ImmutableArray`1<IMarkdownToken> get_Tokens();
    public sealed virtual InlineContent Rewrite(IMarkdownRewriteEngine rewriterEngine);
}
public class Microsoft.DocAsCode.MarkdownLite.JsonTokenTreeRenderer : object {
    public virtual StringBuffer Render(IMarkdownRenderer renderer, MarkdownNewLineBlockToken token, MarkdownBlockContext context);
    public virtual StringBuffer Render(IMarkdownRenderer renderer, MarkdownCodeBlockToken token, MarkdownBlockContext context);
    public virtual StringBuffer Render(IMarkdownRenderer renderer, MarkdownHeadingBlockToken token, MarkdownBlockContext context);
    public virtual StringBuffer Render(IMarkdownRenderer renderer, MarkdownHrBlockToken token, MarkdownBlockContext context);
    public virtual StringBuffer Render(IMarkdownRenderer renderer, MarkdownBlockquoteBlockToken token, MarkdownBlockContext context);
    public virtual StringBuffer Render(IMarkdownRenderer renderer, MarkdownListBlockToken token, MarkdownBlockContext context);
    protected virtual StringBuffer Render(IMarkdownRenderer renderer, MarkdownListItemBlockToken token);
    public virtual StringBuffer Render(IMarkdownRenderer renderer, MarkdownHtmlBlockToken token, MarkdownBlockContext context);
    public virtual StringBuffer Render(IMarkdownRenderer renderer, MarkdownParagraphBlockToken token, MarkdownBlockContext context);
    public virtual StringBuffer Render(IMarkdownRenderer renderer, MarkdownTextToken token, MarkdownBlockContext context);
    public virtual StringBuffer Render(IMarkdownRenderer renderer, MarkdownTableBlockToken token, MarkdownBlockContext context);
    public virtual StringBuffer Render(IMarkdownRenderer renderer, MarkdownNonParagraphBlockToken token, MarkdownBlockContext context);
    public virtual StringBuffer Render(IMarkdownRenderer renderer, MarkdownEscapeInlineToken token, MarkdownInlineContext context);
    public virtual StringBuffer Render(IMarkdownRenderer renderer, MarkdownLinkInlineToken token, MarkdownInlineContext context);
    public virtual StringBuffer Render(IMarkdownRenderer renderer, MarkdownImageInlineToken token, MarkdownInlineContext context);
    public virtual StringBuffer Render(IMarkdownRenderer renderer, MarkdownStrongInlineToken token, MarkdownInlineContext context);
    public virtual StringBuffer Render(IMarkdownRenderer renderer, MarkdownEmInlineToken token, MarkdownInlineContext context);
    public virtual StringBuffer Render(IMarkdownRenderer renderer, MarkdownCodeInlineToken token, MarkdownInlineContext context);
    public virtual StringBuffer Render(IMarkdownRenderer renderer, GfmDelInlineToken token, MarkdownInlineContext context);
    public virtual StringBuffer Render(IMarkdownRenderer renderer, MarkdownTagInlineToken token, MarkdownInlineContext context);
    public virtual StringBuffer Render(IMarkdownRenderer renderer, MarkdownBrInlineToken token, MarkdownInlineContext context);
    public virtual StringBuffer Render(IMarkdownRenderer renderer, MarkdownTextToken token, MarkdownInlineContext context);
    public virtual StringBuffer Render(IMarkdownRenderer renderer, MarkdownIgnoreToken token, IMarkdownContext context);
    public virtual StringBuffer Render(IMarkdownRenderer renderer, MarkdownRawToken token, IMarkdownContext context);
    protected StringBuffer Insert(IMarkdownToken token, StringBuffer name, StringBuffer tokenContent);
    protected StringBuffer Insert(int startLineNumber, int endLineNumber, StringBuffer name, StringBuffer tokenContent);
    protected string Escape(string content);
    protected string ExposeTokenName(IMarkdownToken token);
    protected string TrimStringStart(string source, string target);
    protected string TrimStringEnd(string source, string target);
}
public class Microsoft.DocAsCode.MarkdownLite.LinkObj : object {
    [CompilerGeneratedAttribute]
private string <Href>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Title>k__BackingField;
    public string Href { get; public set; }
    public string Title { get; public set; }
    [CompilerGeneratedAttribute]
public string get_Href();
    [CompilerGeneratedAttribute]
public void set_Href(string value);
    [CompilerGeneratedAttribute]
public string get_Title();
    [CompilerGeneratedAttribute]
public void set_Title(string value);
}
internal class Microsoft.DocAsCode.MarkdownLite.MarkdownAggregateEngine : object {
    private IMarkdownTokenAggregator _aggregator;
    private Stack`1<IMarkdownToken> _parents;
    [CompilerGeneratedAttribute]
private IMarkdownEngine <Engine>k__BackingField;
    public IMarkdownEngine Engine { get; }
    public MarkdownAggregateEngine(IMarkdownEngine engine, IMarkdownTokenAggregator aggregator);
    [CompilerGeneratedAttribute]
public sealed virtual IMarkdownEngine get_Engine();
    public sealed virtual ImmutableArray`1<IMarkdownToken> Rewrite(ImmutableArray`1<IMarkdownToken> tokens);
    private void Aggregate(MarkdownTokenAggregateContext aggContext);
    private sealed virtual override ImmutableArray`1<IMarkdownToken> Microsoft.DocAsCode.MarkdownLite.IMarkdownRewriteEngine.GetParents();
    private sealed virtual override bool Microsoft.DocAsCode.MarkdownLite.IMarkdownRewriteEngine.HasVariable(string name);
    private sealed virtual override object Microsoft.DocAsCode.MarkdownLite.IMarkdownRewriteEngine.GetVariable(string name);
    private sealed virtual override void Microsoft.DocAsCode.MarkdownLite.IMarkdownRewriteEngine.SetVariable(string name, object value);
    private sealed virtual override void Microsoft.DocAsCode.MarkdownLite.IMarkdownRewriteEngine.RemoveVariable(string name);
    private sealed virtual override bool Microsoft.DocAsCode.MarkdownLite.IMarkdownRewriteEngine.HasPostProcess(string name);
    private sealed virtual override void Microsoft.DocAsCode.MarkdownLite.IMarkdownRewriteEngine.SetPostProcess(string name, Action`1<IMarkdownRewriteEngine> action);
    private sealed virtual override void Microsoft.DocAsCode.MarkdownLite.IMarkdownRewriteEngine.RemovePostProcess(string name);
    private sealed virtual override void Microsoft.DocAsCode.MarkdownLite.IMarkdownRewriteEngine.Complete();
    private sealed virtual override void Microsoft.DocAsCode.MarkdownLite.IMarkdownRewriteEngine.Initialize();
}
public class Microsoft.DocAsCode.MarkdownLite.MarkdownAutoLinkInlineRule : object {
    private int _mangleCounter;
    public string Name { get; }
    public Regex AutoLink { get; }
    public virtual string get_Name();
    public virtual Regex get_AutoLink();
    public virtual IMarkdownToken TryMatch(IMarkdownParser parser, IMarkdownParsingContext context);
    private StringBuffer Mangle(bool enableMangle, string text);
    protected virtual StringBuffer Mangle(string text);
}
public class Microsoft.DocAsCode.MarkdownLite.MarkdownBlockContext : object {
    public static string IsTop;
    public static string IsBlockQuote;
    private IMarkdownContext _inlineContext;
    [CompilerGeneratedAttribute]
private ImmutableList`1<IMarkdownRule> <Rules>k__BackingField;
    [CompilerGeneratedAttribute]
private ImmutableDictionary`2<string, object> <Variables>k__BackingField;
    public ImmutableList`1<IMarkdownRule> Rules { get; }
    public ImmutableDictionary`2<string, object> Variables { get; private set; }
    public MarkdownBlockContext(ImmutableList`1<IMarkdownRule> rules, IMarkdownContext inlineContext);
    protected MarkdownBlockContext(ImmutableList`1<IMarkdownRule> rules, IMarkdownContext inlineContext, ImmutableDictionary`2<string, object> variables);
    public virtual IMarkdownContext SetRules(ImmutableList`1<IMarkdownRule> rules);
    public IMarkdownContext GetInlineContext();
    [CompilerGeneratedAttribute]
public sealed virtual ImmutableList`1<IMarkdownRule> get_Rules();
    [CompilerGeneratedAttribute]
public sealed virtual ImmutableDictionary`2<string, object> get_Variables();
    [CompilerGeneratedAttribute]
private void set_Variables(ImmutableDictionary`2<string, object> value);
    public virtual IMarkdownContext CreateContext(ImmutableDictionary`2<string, object> variables);
}
public class Microsoft.DocAsCode.MarkdownLite.MarkdownBlockquoteBlockRule : object {
    private static Matcher _BlockquoteMatcher;
    public string Name { get; }
    [ObsoleteAttribute("Please use BlockquoteMatcher.")]
public Regex Blockquote { get; }
    public Matcher BlockquoteMatcher { get; }
    public Regex LeadingBlockquote { get; }
    private static MarkdownBlockquoteBlockRule();
    public virtual string get_Name();
    public virtual Regex get_Blockquote();
    public virtual Matcher get_BlockquoteMatcher();
    public virtual Regex get_LeadingBlockquote();
    public virtual IMarkdownToken TryMatch(IMarkdownParser parser, IMarkdownParsingContext context);
    private IMarkdownToken TryMatchOld(IMarkdownParser parser, IMarkdownParsingContext context);
}
public class Microsoft.DocAsCode.MarkdownLite.MarkdownBlockquoteBlockToken : object {
    [CompilerGeneratedAttribute]
private IMarkdownRule <Rule>k__BackingField;
    [CompilerGeneratedAttribute]
private IMarkdownContext <Context>k__BackingField;
    [CompilerGeneratedAttribute]
private ImmutableArray`1<IMarkdownToken> <Tokens>k__BackingField;
    [CompilerGeneratedAttribute]
private SourceInfo <SourceInfo>k__BackingField;
    public IMarkdownRule Rule { get; }
    public IMarkdownContext Context { get; }
    public ImmutableArray`1<IMarkdownToken> Tokens { get; }
    public SourceInfo SourceInfo { get; }
    public MarkdownBlockquoteBlockToken(IMarkdownRule rule, IMarkdownContext context, ImmutableArray`1<IMarkdownToken> tokens, SourceInfo sourceInfo);
    [CompilerGeneratedAttribute]
public sealed virtual IMarkdownRule get_Rule();
    [CompilerGeneratedAttribute]
public sealed virtual IMarkdownContext get_Context();
    [CompilerGeneratedAttribute]
public ImmutableArray`1<IMarkdownToken> get_Tokens();
    [CompilerGeneratedAttribute]
public sealed virtual SourceInfo get_SourceInfo();
    public sealed virtual MarkdownBlockquoteBlockToken Rewrite(IMarkdownRewriteEngine rewriterEngine);
    public sealed virtual IEnumerable`1<IMarkdownToken> GetChildren();
}
public class Microsoft.DocAsCode.MarkdownLite.MarkdownBrInlineRule : object {
    public string Name { get; }
    [ObsoleteAttribute]
public Regex Br { get; }
    public Matcher BrMatcher { get; }
    public virtual string get_Name();
    public virtual Regex get_Br();
    public virtual Matcher get_BrMatcher();
    public virtual IMarkdownToken TryMatch(IMarkdownParser parser, IMarkdownParsingContext context);
    [ObsoleteAttribute]
private IMarkdownToken TryMatchOld(IMarkdownParser parser, IMarkdownParsingContext context);
}
public class Microsoft.DocAsCode.MarkdownLite.MarkdownBrInlineToken : object {
    [CompilerGeneratedAttribute]
private IMarkdownRule <Rule>k__BackingField;
    [CompilerGeneratedAttribute]
private IMarkdownContext <Context>k__BackingField;
    [CompilerGeneratedAttribute]
private SourceInfo <SourceInfo>k__BackingField;
    public IMarkdownRule Rule { get; }
    public IMarkdownContext Context { get; }
    public SourceInfo SourceInfo { get; }
    public MarkdownBrInlineToken(IMarkdownRule rule, IMarkdownContext context, SourceInfo sourceInfo);
    [CompilerGeneratedAttribute]
public sealed virtual IMarkdownRule get_Rule();
    [CompilerGeneratedAttribute]
public sealed virtual IMarkdownContext get_Context();
    [CompilerGeneratedAttribute]
public sealed virtual SourceInfo get_SourceInfo();
}
public class Microsoft.DocAsCode.MarkdownLite.MarkdownCodeBlockRule : object {
    private static Matcher _CodeMatcher;
    public string Name { get; }
    [ObsoleteAttribute("Please use CodeMatcher.")]
public Regex Code { get; }
    public Matcher CodeMatcher { get; }
    private static MarkdownCodeBlockRule();
    public virtual string get_Name();
    public virtual Regex get_Code();
    public virtual Matcher get_CodeMatcher();
    public virtual IMarkdownToken TryMatch(IMarkdownParser parser, IMarkdownParsingContext context);
    private IMarkdownToken TryMatchOld(IMarkdownParser parser, IMarkdownParsingContext context);
}
public class Microsoft.DocAsCode.MarkdownLite.MarkdownCodeBlockToken : object {
    [CompilerGeneratedAttribute]
private IMarkdownRule <Rule>k__BackingField;
    [CompilerGeneratedAttribute]
private IMarkdownContext <Context>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Code>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Lang>k__BackingField;
    [CompilerGeneratedAttribute]
private SourceInfo <SourceInfo>k__BackingField;
    public IMarkdownRule Rule { get; }
    public IMarkdownContext Context { get; }
    public string Code { get; }
    public string Lang { get; }
    public SourceInfo SourceInfo { get; }
    public MarkdownCodeBlockToken(IMarkdownRule rule, IMarkdownContext context, string code, string lang, SourceInfo sourceInfo);
    [CompilerGeneratedAttribute]
public sealed virtual IMarkdownRule get_Rule();
    [CompilerGeneratedAttribute]
public sealed virtual IMarkdownContext get_Context();
    [CompilerGeneratedAttribute]
public string get_Code();
    [CompilerGeneratedAttribute]
public string get_Lang();
    [CompilerGeneratedAttribute]
public sealed virtual SourceInfo get_SourceInfo();
}
public class Microsoft.DocAsCode.MarkdownLite.MarkdownCodeInlineRule : object {
    public string Name { get; }
    public Regex Code { get; }
    public virtual string get_Name();
    public virtual Regex get_Code();
    public virtual IMarkdownToken TryMatch(IMarkdownParser parser, IMarkdownParsingContext context);
}
public class Microsoft.DocAsCode.MarkdownLite.MarkdownCodeInlineToken : object {
    [CompilerGeneratedAttribute]
private IMarkdownRule <Rule>k__BackingField;
    [CompilerGeneratedAttribute]
private IMarkdownContext <Context>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Content>k__BackingField;
    [CompilerGeneratedAttribute]
private SourceInfo <SourceInfo>k__BackingField;
    public IMarkdownRule Rule { get; }
    public IMarkdownContext Context { get; }
    public string Content { get; }
    public SourceInfo SourceInfo { get; }
    public MarkdownCodeInlineToken(IMarkdownRule rule, IMarkdownContext context, string content, SourceInfo sourceInfo);
    [CompilerGeneratedAttribute]
public sealed virtual IMarkdownRule get_Rule();
    [CompilerGeneratedAttribute]
public sealed virtual IMarkdownContext get_Context();
    [CompilerGeneratedAttribute]
public string get_Content();
    [CompilerGeneratedAttribute]
public sealed virtual SourceInfo get_SourceInfo();
}
public class Microsoft.DocAsCode.MarkdownLite.MarkdownCommentInlineRule : object {
    public string Name { get; }
    public Regex Comment { get; }
    public virtual string get_Name();
    public virtual Regex get_Comment();
    public virtual IMarkdownToken TryMatch(IMarkdownParser parser, IMarkdownParsingContext context);
}
internal class Microsoft.DocAsCode.MarkdownLite.MarkdownCompositeTokenRewriter : object {
    [CompilerGeneratedAttribute]
private ImmutableList`1<IMarkdownTokenRewriter> <Rewriters>k__BackingField;
    public ImmutableList`1<IMarkdownTokenRewriter> Rewriters { get; }
    public MarkdownCompositeTokenRewriter(ImmutableList`1<IMarkdownTokenRewriter> rewriters);
    [CompilerGeneratedAttribute]
public ImmutableList`1<IMarkdownTokenRewriter> get_Rewriters();
    public sealed virtual void Initialize(IMarkdownRewriteEngine rewriteEngine);
    public sealed virtual IMarkdownToken Rewrite(IMarkdownRewriteEngine engine, IMarkdownToken token);
}
public class Microsoft.DocAsCode.MarkdownLite.MarkdownDefBlockRule : object {
    private static Matcher _DefMatcher;
    public string Name { get; }
    [ObsoleteAttribute("Please use DefMatcher.")]
public Regex Def { get; }
    public Matcher DefMatcher { get; }
    private static MarkdownDefBlockRule();
    public virtual string get_Name();
    public virtual Regex get_Def();
    public virtual Matcher get_DefMatcher();
    public virtual IMarkdownToken TryMatch(IMarkdownParser parser, IMarkdownParsingContext context);
    [ObsoleteAttribute]
public virtual IMarkdownToken TryMatchOld(IMarkdownParser parser, IMarkdownParsingContext context);
}
public class Microsoft.DocAsCode.MarkdownLite.MarkdownEmInlineRule : object {
    public string Name { get; }
    public Regex Em { get; }
    public virtual string get_Name();
    public virtual Regex get_Em();
    public virtual IMarkdownToken TryMatch(IMarkdownParser parser, IMarkdownParsingContext context);
}
public class Microsoft.DocAsCode.MarkdownLite.MarkdownEmInlineToken : object {
    [CompilerGeneratedAttribute]
private IMarkdownRule <Rule>k__BackingField;
    [CompilerGeneratedAttribute]
private IMarkdownContext <Context>k__BackingField;
    [CompilerGeneratedAttribute]
private ImmutableArray`1<IMarkdownToken> <Content>k__BackingField;
    [CompilerGeneratedAttribute]
private SourceInfo <SourceInfo>k__BackingField;
    public IMarkdownRule Rule { get; }
    public IMarkdownContext Context { get; }
    public ImmutableArray`1<IMarkdownToken> Content { get; }
    public SourceInfo SourceInfo { get; }
    public MarkdownEmInlineToken(IMarkdownRule rule, IMarkdownContext context, ImmutableArray`1<IMarkdownToken> content, SourceInfo sourceInfo);
    [CompilerGeneratedAttribute]
public sealed virtual IMarkdownRule get_Rule();
    [CompilerGeneratedAttribute]
public sealed virtual IMarkdownContext get_Context();
    [CompilerGeneratedAttribute]
public ImmutableArray`1<IMarkdownToken> get_Content();
    [CompilerGeneratedAttribute]
public sealed virtual SourceInfo get_SourceInfo();
    public sealed virtual MarkdownEmInlineToken Rewrite(IMarkdownRewriteEngine rewriterEngine);
    public sealed virtual IEnumerable`1<IMarkdownToken> GetChildren();
}
public class Microsoft.DocAsCode.MarkdownLite.MarkdownEngine : object {
    private static Char[] NewLineOrTab;
    private static String[] Spaces;
    [CompilerGeneratedAttribute]
private object <RendererImpl>k__BackingField;
    [CompilerGeneratedAttribute]
private Options <Options>k__BackingField;
    [CompilerGeneratedAttribute]
private IMarkdownContext <Context>k__BackingField;
    [CompilerGeneratedAttribute]
private IMarkdownTokenRewriter <Rewriter>k__BackingField;
    [CompilerGeneratedAttribute]
private IMarkdownTokenTreeValidator <TokenTreeValidator>k__BackingField;
    [CompilerGeneratedAttribute]
private IMarkdownTokenAggregator <TokenAggregator>k__BackingField;
    [CompilerGeneratedAttribute]
private ImmutableList`1<IMarkdownTokenAggregator> <TokenAggregators>k__BackingField;
    [CompilerGeneratedAttribute]
private Dictionary`2<string, LinkObj> <Links>k__BackingField;
    [CompilerGeneratedAttribute]
private int <MaxExtractCount>k__BackingField;
    public object RendererImpl { get; }
    public Options Options { get; }
    public IMarkdownContext Context { get; private set; }
    public IMarkdownTokenRewriter Rewriter { get; }
    public IMarkdownTokenTreeValidator TokenTreeValidator { get; public set; }
    [ObsoleteAttribute]
public IMarkdownTokenAggregator TokenAggregator { get; public set; }
    public ImmutableList`1<IMarkdownTokenAggregator> TokenAggregators { get; public set; }
    public Dictionary`2<string, LinkObj> Links { get; }
    public int MaxExtractCount { get; public set; }
    public IMarkdownParser Parser { get; }
    public IMarkdownRewriteEngine RewriteEngine { get; }
    public IMarkdownRenderer Renderer { get; }
    public MarkdownEngine(IMarkdownContext context, object renderer, Options options);
    public MarkdownEngine(IMarkdownContext context, IMarkdownTokenRewriter rewriter, object renderer, Options options);
    protected MarkdownEngine(IMarkdownContext context, IMarkdownTokenRewriter rewriter, object renderer, Options options, Dictionary`2<string, LinkObj> links);
    private static MarkdownEngine();
    [CompilerGeneratedAttribute]
public object get_RendererImpl();
    [CompilerGeneratedAttribute]
public Options get_Options();
    [CompilerGeneratedAttribute]
public IMarkdownContext get_Context();
    [CompilerGeneratedAttribute]
private void set_Context(IMarkdownContext value);
    [CompilerGeneratedAttribute]
public IMarkdownTokenRewriter get_Rewriter();
    [CompilerGeneratedAttribute]
public sealed virtual IMarkdownTokenTreeValidator get_TokenTreeValidator();
    [CompilerGeneratedAttribute]
public sealed virtual void set_TokenTreeValidator(IMarkdownTokenTreeValidator value);
    [CompilerGeneratedAttribute]
public IMarkdownTokenAggregator get_TokenAggregator();
    [CompilerGeneratedAttribute]
public void set_TokenAggregator(IMarkdownTokenAggregator value);
    [CompilerGeneratedAttribute]
public ImmutableList`1<IMarkdownTokenAggregator> get_TokenAggregators();
    [CompilerGeneratedAttribute]
public void set_TokenAggregators(ImmutableList`1<IMarkdownTokenAggregator> value);
    [CompilerGeneratedAttribute]
public Dictionary`2<string, LinkObj> get_Links();
    [CompilerGeneratedAttribute]
public int get_MaxExtractCount();
    [CompilerGeneratedAttribute]
public void set_MaxExtractCount(int value);
    public static string Normalize(string markdown);
    public sealed virtual StringBuffer Mark(SourceInfo sourceInfo, IMarkdownContext context);
    private static ImmutableArray`1<IMarkdownToken> RewriteTokens(ImmutableArray`1<IMarkdownToken> tokens, string file, IMarkdownRewriteEngine rewriteEngine);
    public virtual string Markup(string markdown, string file);
    protected virtual string Preprocess(string src);
    public virtual IMarkdownParser get_Parser();
    public virtual IMarkdownRewriteEngine get_RewriteEngine();
    public virtual IMarkdownRenderer get_Renderer();
}
public class Microsoft.DocAsCode.MarkdownLite.MarkdownEngineBuilder : object {
    [CompilerGeneratedAttribute]
private Options <Options>k__BackingField;
    [CompilerGeneratedAttribute]
private ImmutableList`1<IMarkdownRule> <BlockRules>k__BackingField;
    [CompilerGeneratedAttribute]
private ImmutableList`1<IMarkdownRule> <InlineRules>k__BackingField;
    [CompilerGeneratedAttribute]
private IMarkdownTokenRewriter <Rewriter>k__BackingField;
    [CompilerGeneratedAttribute]
private IMarkdownTokenTreeValidator <TokenTreeValidator>k__BackingField;
    [CompilerGeneratedAttribute]
private ImmutableList`1<IMarkdownTokenAggregator> <TokenAggregators>k__BackingField;
    public Options Options { get; }
    public ImmutableList`1<IMarkdownRule> BlockRules { get; public set; }
    public ImmutableList`1<IMarkdownRule> InlineRules { get; public set; }
    public IMarkdownTokenRewriter Rewriter { get; public set; }
    public IMarkdownTokenTreeValidator TokenTreeValidator { get; public set; }
    public ImmutableList`1<IMarkdownTokenAggregator> TokenAggregators { get; public set; }
    public MarkdownEngineBuilder(Options options);
    [CompilerGeneratedAttribute]
public Options get_Options();
    [CompilerGeneratedAttribute]
public ImmutableList`1<IMarkdownRule> get_BlockRules();
    [CompilerGeneratedAttribute]
public void set_BlockRules(ImmutableList`1<IMarkdownRule> value);
    [CompilerGeneratedAttribute]
public ImmutableList`1<IMarkdownRule> get_InlineRules();
    [CompilerGeneratedAttribute]
public void set_InlineRules(ImmutableList`1<IMarkdownRule> value);
    [CompilerGeneratedAttribute]
public IMarkdownTokenRewriter get_Rewriter();
    [CompilerGeneratedAttribute]
public void set_Rewriter(IMarkdownTokenRewriter value);
    [CompilerGeneratedAttribute]
public IMarkdownTokenTreeValidator get_TokenTreeValidator();
    [CompilerGeneratedAttribute]
public void set_TokenTreeValidator(IMarkdownTokenTreeValidator value);
    [CompilerGeneratedAttribute]
public ImmutableList`1<IMarkdownTokenAggregator> get_TokenAggregators();
    [CompilerGeneratedAttribute]
public void set_TokenAggregators(ImmutableList`1<IMarkdownTokenAggregator> value);
    public virtual IMarkdownContext CreateParseContext();
    public virtual IMarkdownEngine CreateEngine(object renderer);
}
public class Microsoft.DocAsCode.MarkdownLite.MarkdownEngineByOptionsBuilder : MarkdownEngineBuilder {
    public MarkdownEngineByOptionsBuilder(Options options);
    private void BuildRulesByOptions();
    private void BuildBlockRulesByOptions();
    private void BuildInlineRulesByOptions();
}
public class Microsoft.DocAsCode.MarkdownLite.MarkdownEscapedTextInlineRule : object {
    public string Name { get; }
    public Regex EscapedText { get; }
    public virtual string get_Name();
    public virtual Regex get_EscapedText();
    public virtual IMarkdownToken TryMatch(IMarkdownParser parser, IMarkdownParsingContext context);
}
public class Microsoft.DocAsCode.MarkdownLite.MarkdownEscapeInlineRule : object {
    public string Name { get; }
    public Regex Escape { get; }
    public virtual string get_Name();
    public virtual Regex get_Escape();
    public virtual IMarkdownToken TryMatch(IMarkdownParser parser, IMarkdownParsingContext context);
}
public class Microsoft.DocAsCode.MarkdownLite.MarkdownEscapeInlineToken : object {
    [CompilerGeneratedAttribute]
private IMarkdownRule <Rule>k__BackingField;
    [CompilerGeneratedAttribute]
private IMarkdownContext <Context>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Content>k__BackingField;
    [CompilerGeneratedAttribute]
private SourceInfo <SourceInfo>k__BackingField;
    public IMarkdownRule Rule { get; }
    public IMarkdownContext Context { get; }
    public string Content { get; }
    public SourceInfo SourceInfo { get; }
    public MarkdownEscapeInlineToken(IMarkdownRule rule, IMarkdownContext context, string content, SourceInfo sourceInfo);
    [CompilerGeneratedAttribute]
public sealed virtual IMarkdownRule get_Rule();
    [CompilerGeneratedAttribute]
public sealed virtual IMarkdownContext get_Context();
    [CompilerGeneratedAttribute]
public string get_Content();
    [CompilerGeneratedAttribute]
public sealed virtual SourceInfo get_SourceInfo();
}
public class Microsoft.DocAsCode.MarkdownLite.MarkdownException : Exception {
    public MarkdownException(string message);
    public MarkdownException(string message, Exception innerException);
}
public class Microsoft.DocAsCode.MarkdownLite.MarkdownHeadingBlockRule : object {
    private static Matcher _EndSymbol;
    private static Matcher _HeadingMatcher;
    public string Name { get; }
    [ObsoleteAttribute("Please use HeadingMatcher.")]
public Regex Heading { get; }
    public Matcher HeadingMatcher { get; }
    private static MarkdownHeadingBlockRule();
    public virtual string get_Name();
    public virtual Regex get_Heading();
    public virtual Matcher get_HeadingMatcher();
    public virtual IMarkdownToken TryMatch(IMarkdownParser parser, IMarkdownParsingContext context);
    private IMarkdownToken OldMatch(IMarkdownParser parser, IMarkdownParsingContext context);
}
public class Microsoft.DocAsCode.MarkdownLite.MarkdownHeadingBlockToken : object {
    [CompilerGeneratedAttribute]
private IMarkdownRule <Rule>k__BackingField;
    [CompilerGeneratedAttribute]
private IMarkdownContext <Context>k__BackingField;
    [CompilerGeneratedAttribute]
private InlineContent <Content>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Id>k__BackingField;
    [CompilerGeneratedAttribute]
private int <Depth>k__BackingField;
    [CompilerGeneratedAttribute]
private SourceInfo <SourceInfo>k__BackingField;
    public IMarkdownRule Rule { get; }
    public IMarkdownContext Context { get; }
    public InlineContent Content { get; }
    public string Id { get; }
    public int Depth { get; }
    public SourceInfo SourceInfo { get; }
    public MarkdownHeadingBlockToken(IMarkdownRule rule, IMarkdownContext context, InlineContent content, string id, int depth, SourceInfo sourceInfo);
    [CompilerGeneratedAttribute]
public sealed virtual IMarkdownRule get_Rule();
    [CompilerGeneratedAttribute]
public sealed virtual IMarkdownContext get_Context();
    [CompilerGeneratedAttribute]
public InlineContent get_Content();
    [CompilerGeneratedAttribute]
public string get_Id();
    [CompilerGeneratedAttribute]
public int get_Depth();
    [CompilerGeneratedAttribute]
public sealed virtual SourceInfo get_SourceInfo();
    public sealed virtual MarkdownHeadingBlockToken Rewrite(IMarkdownRewriteEngine rewriterEngine);
    internal MarkdownHeadingBlockToken RewriteId(Dictionary`2<string, int> idTable);
    private string GenerateNewId(Dictionary`2<string, int> idTable, string Id);
    public sealed virtual IEnumerable`1<IMarkdownToken> GetChildren();
}
public class Microsoft.DocAsCode.MarkdownLite.MarkdownHrBlockRule : object {
    private static Matcher _HrMatcher;
    public string Name { get; }
    [ObsoleteAttribute("Please use HrMatcher.")]
public Regex Hr { get; }
    public Matcher HrMatcher { get; }
    private static MarkdownHrBlockRule();
    public virtual string get_Name();
    public virtual Regex get_Hr();
    public virtual Matcher get_HrMatcher();
    public virtual IMarkdownToken TryMatch(IMarkdownParser parser, IMarkdownParsingContext context);
    public virtual IMarkdownToken TryMatchOld(IMarkdownParser parser, IMarkdownParsingContext context);
}
public class Microsoft.DocAsCode.MarkdownLite.MarkdownHrBlockToken : object {
    [CompilerGeneratedAttribute]
private IMarkdownRule <Rule>k__BackingField;
    [CompilerGeneratedAttribute]
private IMarkdownContext <Context>k__BackingField;
    [CompilerGeneratedAttribute]
private SourceInfo <SourceInfo>k__BackingField;
    public IMarkdownRule Rule { get; }
    public IMarkdownContext Context { get; }
    public SourceInfo SourceInfo { get; }
    public MarkdownHrBlockToken(IMarkdownRule rule, IMarkdownContext context, SourceInfo sourceInfo);
    [CompilerGeneratedAttribute]
public sealed virtual IMarkdownRule get_Rule();
    [CompilerGeneratedAttribute]
public sealed virtual IMarkdownContext get_Context();
    [CompilerGeneratedAttribute]
public sealed virtual SourceInfo get_SourceInfo();
}
public class Microsoft.DocAsCode.MarkdownLite.MarkdownHtmlBlockRule : object {
    private static Matcher InlineElementNames;
    private static Matcher _ElementName;
    private static Matcher _EndSymbol;
    private static Matcher _HtmlMatcher;
    public string Name { get; }
    [ObsoleteAttribute("Please use HtmlMatcher.")]
public Regex Html { get; }
    public Matcher HtmlMatcher { get; }
    private static MarkdownHtmlBlockRule();
    public virtual string get_Name();
    public virtual Regex get_Html();
    public virtual Matcher get_HtmlMatcher();
    public virtual IMarkdownToken TryMatch(IMarkdownParser parser, IMarkdownParsingContext context);
    private IMarkdownToken TryMatchOld(IMarkdownParser parser, IMarkdownParsingContext context);
}
public class Microsoft.DocAsCode.MarkdownLite.MarkdownHtmlBlockToken : object {
    [CompilerGeneratedAttribute]
private IMarkdownRule <Rule>k__BackingField;
    [CompilerGeneratedAttribute]
private IMarkdownContext <Context>k__BackingField;
    [CompilerGeneratedAttribute]
private InlineContent <Content>k__BackingField;
    [CompilerGeneratedAttribute]
private SourceInfo <SourceInfo>k__BackingField;
    public IMarkdownRule Rule { get; }
    public IMarkdownContext Context { get; }
    public InlineContent Content { get; }
    public SourceInfo SourceInfo { get; }
    public MarkdownHtmlBlockToken(IMarkdownRule rule, IMarkdownContext context, InlineContent content, SourceInfo sourceInfo);
    [CompilerGeneratedAttribute]
public sealed virtual IMarkdownRule get_Rule();
    [CompilerGeneratedAttribute]
public sealed virtual IMarkdownContext get_Context();
    [CompilerGeneratedAttribute]
public InlineContent get_Content();
    [CompilerGeneratedAttribute]
public sealed virtual SourceInfo get_SourceInfo();
    public sealed virtual MarkdownHtmlBlockToken Rewrite(IMarkdownRewriteEngine rewriterEngine);
    public sealed virtual IEnumerable`1<IMarkdownToken> GetChildren();
}
public class Microsoft.DocAsCode.MarkdownLite.MarkdownIgnoreToken : object {
    [CompilerGeneratedAttribute]
private IMarkdownRule <Rule>k__BackingField;
    [CompilerGeneratedAttribute]
private IMarkdownContext <Context>k__BackingField;
    [CompilerGeneratedAttribute]
private SourceInfo <SourceInfo>k__BackingField;
    public IMarkdownRule Rule { get; }
    public IMarkdownContext Context { get; }
    public SourceInfo SourceInfo { get; }
    public MarkdownIgnoreToken(IMarkdownRule rule, IMarkdownContext context, SourceInfo sourceInfo);
    [CompilerGeneratedAttribute]
public sealed virtual IMarkdownRule get_Rule();
    [CompilerGeneratedAttribute]
public sealed virtual IMarkdownContext get_Context();
    [CompilerGeneratedAttribute]
public sealed virtual SourceInfo get_SourceInfo();
}
public class Microsoft.DocAsCode.MarkdownLite.MarkdownImageInlineToken : object {
    [CompilerGeneratedAttribute]
private IMarkdownRule <Rule>k__BackingField;
    [CompilerGeneratedAttribute]
private IMarkdownContext <Context>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Href>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Title>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Text>k__BackingField;
    [CompilerGeneratedAttribute]
private SourceInfo <SourceInfo>k__BackingField;
    [CompilerGeneratedAttribute]
private MarkdownLinkType <LinkType>k__BackingField;
    [CompilerGeneratedAttribute]
private string <RefId>k__BackingField;
    public IMarkdownRule Rule { get; }
    public IMarkdownContext Context { get; }
    public string Href { get; }
    public string Title { get; }
    public string Text { get; }
    public SourceInfo SourceInfo { get; }
    public MarkdownLinkType LinkType { get; }
    public string RefId { get; }
    public MarkdownImageInlineToken(IMarkdownRule rule, IMarkdownContext context, string href, string title, string text, SourceInfo sourceInfo, MarkdownLinkType linkType, string refId);
    [CompilerGeneratedAttribute]
public sealed virtual IMarkdownRule get_Rule();
    [CompilerGeneratedAttribute]
public sealed virtual IMarkdownContext get_Context();
    [CompilerGeneratedAttribute]
public string get_Href();
    [CompilerGeneratedAttribute]
public string get_Title();
    [CompilerGeneratedAttribute]
public string get_Text();
    [CompilerGeneratedAttribute]
public sealed virtual SourceInfo get_SourceInfo();
    [CompilerGeneratedAttribute]
public MarkdownLinkType get_LinkType();
    [CompilerGeneratedAttribute]
public string get_RefId();
}
internal class Microsoft.DocAsCode.MarkdownLite.MarkdownInitializableLambdaTokenRewriter`2 : object {
    [CompilerGeneratedAttribute]
private Func`3<TEngine, TToken, IMarkdownToken> <RewriteFunc>k__BackingField;
    [CompilerGeneratedAttribute]
private Action`1<TEngine> <Initializer>k__BackingField;
    public Func`3<TEngine, TToken, IMarkdownToken> RewriteFunc { get; }
    public Action`1<TEngine> Initializer { get; }
    public MarkdownInitializableLambdaTokenRewriter`2(Func`3<TEngine, TToken, IMarkdownToken> rewriteFunc, Action`1<TEngine> initializer);
    [CompilerGeneratedAttribute]
public Func`3<TEngine, TToken, IMarkdownToken> get_RewriteFunc();
    [CompilerGeneratedAttribute]
public Action`1<TEngine> get_Initializer();
    public sealed virtual void Initialize(IMarkdownRewriteEngine rewriteEngine);
    public sealed virtual IMarkdownToken Rewrite(IMarkdownRewriteEngine engine, IMarkdownToken token);
}
public class Microsoft.DocAsCode.MarkdownLite.MarkdownInlineContext : object {
    public static string IsInLink;
    private static object BoxedFalse;
    [CompilerGeneratedAttribute]
private ImmutableList`1<IMarkdownRule> <Rules>k__BackingField;
    [CompilerGeneratedAttribute]
private ImmutableDictionary`2<string, object> <Variables>k__BackingField;
    public ImmutableList`1<IMarkdownRule> Rules { get; }
    public ImmutableDictionary`2<string, object> Variables { get; private set; }
    public MarkdownInlineContext(ImmutableList`1<IMarkdownRule> rules);
    protected MarkdownInlineContext(ImmutableList`1<IMarkdownRule> rules, ImmutableDictionary`2<string, object> variables);
    private static MarkdownInlineContext();
    [CompilerGeneratedAttribute]
public sealed virtual ImmutableList`1<IMarkdownRule> get_Rules();
    [CompilerGeneratedAttribute]
public sealed virtual ImmutableDictionary`2<string, object> get_Variables();
    [CompilerGeneratedAttribute]
private void set_Variables(ImmutableDictionary`2<string, object> value);
    public virtual IMarkdownContext CreateContext(ImmutableDictionary`2<string, object> variables);
    public static bool GetIsInLink(IMarkdownContext context);
}
internal class Microsoft.DocAsCode.MarkdownLite.MarkdownLambdaTokenRewriter`2 : object {
    [CompilerGeneratedAttribute]
private Func`3<TEngine, TToken, IMarkdownToken> <RewriteFunc>k__BackingField;
    public Func`3<TEngine, TToken, IMarkdownToken> RewriteFunc { get; }
    public MarkdownLambdaTokenRewriter`2(Func`3<TEngine, TToken, IMarkdownToken> rewriteFunc);
    [CompilerGeneratedAttribute]
public Func`3<TEngine, TToken, IMarkdownToken> get_RewriteFunc();
    public sealed virtual IMarkdownToken Rewrite(IMarkdownRewriteEngine engine, IMarkdownToken token);
}
public class Microsoft.DocAsCode.MarkdownLite.MarkdownLHeadingBlockRule : object {
    private static Matcher _LHeadingMatcher;
    public string Name { get; }
    [ObsoleteAttribute("Please use LHeadingMatcher.")]
public Regex LHeading { get; }
    public Matcher LHeadingMatcher { get; }
    private static MarkdownLHeadingBlockRule();
    public virtual string get_Name();
    public virtual Regex get_LHeading();
    public virtual Matcher get_LHeadingMatcher();
    public virtual IMarkdownToken TryMatch(IMarkdownParser parser, IMarkdownParsingContext context);
    private IMarkdownToken TryMatchOld(IMarkdownParser parser, IMarkdownParsingContext context);
}
public abstract class Microsoft.DocAsCode.MarkdownLite.MarkdownLinkBaseInlineRule : object {
    private static object BoxedTrue;
    public string Name { get; }
    private static MarkdownLinkBaseInlineRule();
    public abstract virtual string get_Name();
    public abstract virtual IMarkdownToken TryMatch(IMarkdownParser parser, IMarkdownParsingContext context);
    protected virtual IMarkdownToken GenerateToken(IMarkdownParser parser, string href, string title, string text, bool isImage, SourceInfo sourceInfo, MarkdownLinkType linkType, string refId);
}
public class Microsoft.DocAsCode.MarkdownLite.MarkdownLinkInlineRule : MarkdownLinkBaseInlineRule {
    public string Name { get; }
    public Regex Link { get; }
    public virtual string get_Name();
    public virtual Regex get_Link();
    public virtual IMarkdownToken TryMatch(IMarkdownParser parser, IMarkdownParsingContext context);
    private bool IsEscape(string text);
}
public class Microsoft.DocAsCode.MarkdownLite.MarkdownLinkInlineToken : object {
    [CompilerGeneratedAttribute]
private IMarkdownRule <Rule>k__BackingField;
    [CompilerGeneratedAttribute]
private IMarkdownContext <Context>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Href>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Title>k__BackingField;
    [CompilerGeneratedAttribute]
private ImmutableArray`1<IMarkdownToken> <Content>k__BackingField;
    [CompilerGeneratedAttribute]
private SourceInfo <SourceInfo>k__BackingField;
    [CompilerGeneratedAttribute]
private MarkdownLinkType <LinkType>k__BackingField;
    [CompilerGeneratedAttribute]
private string <RefId>k__BackingField;
    public IMarkdownRule Rule { get; }
    public IMarkdownContext Context { get; }
    public string Href { get; }
    public string Title { get; }
    public ImmutableArray`1<IMarkdownToken> Content { get; }
    public SourceInfo SourceInfo { get; }
    public MarkdownLinkType LinkType { get; }
    public string RefId { get; }
    public MarkdownLinkInlineToken(IMarkdownRule rule, IMarkdownContext context, string href, string title, ImmutableArray`1<IMarkdownToken> content, SourceInfo sourceInfo, MarkdownLinkType linkType, string refId);
    [CompilerGeneratedAttribute]
public sealed virtual IMarkdownRule get_Rule();
    [CompilerGeneratedAttribute]
public sealed virtual IMarkdownContext get_Context();
    [CompilerGeneratedAttribute]
public string get_Href();
    [CompilerGeneratedAttribute]
public string get_Title();
    [CompilerGeneratedAttribute]
public ImmutableArray`1<IMarkdownToken> get_Content();
    [CompilerGeneratedAttribute]
public sealed virtual SourceInfo get_SourceInfo();
    [CompilerGeneratedAttribute]
public MarkdownLinkType get_LinkType();
    [CompilerGeneratedAttribute]
public string get_RefId();
    public sealed virtual MarkdownLinkInlineToken Rewrite(IMarkdownRewriteEngine rewriterEngine);
    public sealed virtual IEnumerable`1<IMarkdownToken> GetChildren();
}
public enum Microsoft.DocAsCode.MarkdownLite.MarkdownLinkType : Enum {
    public int value__;
    public static MarkdownLinkType AutoLink;
    public static MarkdownLinkType NormalLink;
    public static MarkdownLinkType NumberLink;
    public static MarkdownLinkType RefLink;
    public static MarkdownLinkType UrlLink;
}
public class Microsoft.DocAsCode.MarkdownLite.MarkdownListBlockRule : object {
    private static Matcher _ChildList;
    private static Matcher _FollowingText;
    private static Matcher _OrderListMatcher;
    private static Matcher _UnorderListMatcher;
    public string Name { get; }
    [ObsoleteAttribute("Please use OrderListMatcher.")]
public Regex OrderList { get; }
    [ObsoleteAttribute("Please use ListMatcher.")]
public Regex UnorderList { get; }
    public Matcher OrderListMatcher { get; }
    public Matcher UnorderListMatcher { get; }
    public Regex Item { get; }
    public Regex Bullet { get; }
    private static MarkdownListBlockRule();
    public virtual string get_Name();
    public virtual Regex get_OrderList();
    public virtual Regex get_UnorderList();
    public virtual Matcher get_OrderListMatcher();
    public virtual Matcher get_UnorderListMatcher();
    public virtual Regex get_Item();
    public virtual Regex get_Bullet();
    public virtual IMarkdownToken TryMatch(IMarkdownParser parser, IMarkdownParsingContext context);
    private IMarkdownToken TryMatchOld(IMarkdownParser parser, IMarkdownParsingContext context);
    private static int CountLine(string item);
}
public class Microsoft.DocAsCode.MarkdownLite.MarkdownListBlockToken : object {
    [CompilerGeneratedAttribute]
private IMarkdownRule <Rule>k__BackingField;
    [CompilerGeneratedAttribute]
private IMarkdownContext <Context>k__BackingField;
    [CompilerGeneratedAttribute]
private ImmutableArray`1<IMarkdownToken> <Tokens>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <Ordered>k__BackingField;
    [CompilerGeneratedAttribute]
private int <Start>k__BackingField;
    [CompilerGeneratedAttribute]
private SourceInfo <SourceInfo>k__BackingField;
    public IMarkdownRule Rule { get; }
    public IMarkdownContext Context { get; }
    public ImmutableArray`1<IMarkdownToken> Tokens { get; }
    public bool Ordered { get; }
    public int Start { get; }
    public SourceInfo SourceInfo { get; }
    public MarkdownListBlockToken(IMarkdownRule rule, IMarkdownContext context, ImmutableArray`1<IMarkdownToken> tokens, bool ordered, SourceInfo sourceInfo);
    public MarkdownListBlockToken(IMarkdownRule rule, IMarkdownContext context, ImmutableArray`1<IMarkdownToken> tokens, bool ordered, int start, SourceInfo sourceInfo);
    [CompilerGeneratedAttribute]
public sealed virtual IMarkdownRule get_Rule();
    [CompilerGeneratedAttribute]
public sealed virtual IMarkdownContext get_Context();
    [CompilerGeneratedAttribute]
public ImmutableArray`1<IMarkdownToken> get_Tokens();
    [CompilerGeneratedAttribute]
public bool get_Ordered();
    [CompilerGeneratedAttribute]
public int get_Start();
    [CompilerGeneratedAttribute]
public sealed virtual SourceInfo get_SourceInfo();
    public sealed virtual MarkdownListBlockToken Rewrite(IMarkdownRewriteEngine rewriterEngine);
    public sealed virtual IEnumerable`1<IMarkdownToken> GetChildren();
}
public class Microsoft.DocAsCode.MarkdownLite.MarkdownListItemBlockToken : object {
    [CompilerGeneratedAttribute]
private IMarkdownRule <Rule>k__BackingField;
    [CompilerGeneratedAttribute]
private IMarkdownContext <Context>k__BackingField;
    [CompilerGeneratedAttribute]
private ImmutableArray`1<IMarkdownToken> <Tokens>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <Loose>k__BackingField;
    [CompilerGeneratedAttribute]
private SourceInfo <SourceInfo>k__BackingField;
    public IMarkdownRule Rule { get; }
    public IMarkdownContext Context { get; }
    public ImmutableArray`1<IMarkdownToken> Tokens { get; }
    public bool Loose { get; }
    public SourceInfo SourceInfo { get; }
    public MarkdownListItemBlockToken(IMarkdownRule rule, IMarkdownContext context, ImmutableArray`1<IMarkdownToken> tokens, bool loose, SourceInfo sourceInfo);
    [CompilerGeneratedAttribute]
public sealed virtual IMarkdownRule get_Rule();
    [CompilerGeneratedAttribute]
public sealed virtual IMarkdownContext get_Context();
    [CompilerGeneratedAttribute]
public ImmutableArray`1<IMarkdownToken> get_Tokens();
    [CompilerGeneratedAttribute]
public bool get_Loose();
    [CompilerGeneratedAttribute]
public sealed virtual SourceInfo get_SourceInfo();
    public sealed virtual MarkdownListItemBlockToken Rewrite(IMarkdownRewriteEngine rewriterEngine);
    public sealed virtual IEnumerable`1<IMarkdownToken> GetChildren();
}
internal class Microsoft.DocAsCode.MarkdownLite.MarkdownLoopTokenRewriter : object {
    [CompilerGeneratedAttribute]
private IMarkdownTokenRewriter <Inner>k__BackingField;
    [CompilerGeneratedAttribute]
private int <MaxLoopCount>k__BackingField;
    public IMarkdownTokenRewriter Inner { get; }
    public int MaxLoopCount { get; }
    public MarkdownLoopTokenRewriter(IMarkdownTokenRewriter inner, int maxLoopCount);
    [CompilerGeneratedAttribute]
public IMarkdownTokenRewriter get_Inner();
    [CompilerGeneratedAttribute]
public int get_MaxLoopCount();
    public sealed virtual void Initialize(IMarkdownRewriteEngine rewriteEngine);
    public sealed virtual IMarkdownToken Rewrite(IMarkdownRewriteEngine engine, IMarkdownToken token);
}
public class Microsoft.DocAsCode.MarkdownLite.MarkdownNewLineBlockRule : object {
    private static Matcher _NewLineMatcher;
    public string Name { get; }
    [ObsoleteAttribute("Please use NewLineMatcher.")]
public Regex Newline { get; }
    public Matcher NewLineMatcher { get; }
    private static MarkdownNewLineBlockRule();
    public virtual string get_Name();
    public virtual Regex get_Newline();
    public virtual Matcher get_NewLineMatcher();
    public virtual IMarkdownToken TryMatch(IMarkdownParser parser, IMarkdownParsingContext context);
    private IMarkdownToken TryMatchOld(IMarkdownParser parser, IMarkdownParsingContext context);
}
public class Microsoft.DocAsCode.MarkdownLite.MarkdownNewLineBlockToken : object {
    [CompilerGeneratedAttribute]
private IMarkdownRule <Rule>k__BackingField;
    [CompilerGeneratedAttribute]
private IMarkdownContext <Context>k__BackingField;
    [CompilerGeneratedAttribute]
private SourceInfo <SourceInfo>k__BackingField;
    public IMarkdownRule Rule { get; }
    public IMarkdownContext Context { get; }
    public SourceInfo SourceInfo { get; }
    public MarkdownNewLineBlockToken(IMarkdownRule rule, IMarkdownContext context, SourceInfo sourceInfo);
    [CompilerGeneratedAttribute]
public sealed virtual IMarkdownRule get_Rule();
    [CompilerGeneratedAttribute]
public sealed virtual IMarkdownContext get_Context();
    [CompilerGeneratedAttribute]
public sealed virtual SourceInfo get_SourceInfo();
}
public class Microsoft.DocAsCode.MarkdownLite.MarkdownNoLinkInlineRule : MarkdownLinkBaseInlineRule {
    public string Name { get; }
    public Regex NoLink { get; }
    public virtual string get_Name();
    public virtual Regex get_NoLink();
    public virtual IMarkdownToken TryMatch(IMarkdownParser parser, IMarkdownParsingContext context);
}
public class Microsoft.DocAsCode.MarkdownLite.MarkdownNonParagraphBlockToken : object {
    [CompilerGeneratedAttribute]
private IMarkdownRule <Rule>k__BackingField;
    [CompilerGeneratedAttribute]
private IMarkdownContext <Context>k__BackingField;
    [CompilerGeneratedAttribute]
private InlineContent <Content>k__BackingField;
    [CompilerGeneratedAttribute]
private SourceInfo <SourceInfo>k__BackingField;
    public IMarkdownRule Rule { get; }
    public IMarkdownContext Context { get; }
    public InlineContent Content { get; }
    public SourceInfo SourceInfo { get; }
    public MarkdownNonParagraphBlockToken(IMarkdownRule rule, IMarkdownContext context, InlineContent content, SourceInfo sourceInfo);
    [CompilerGeneratedAttribute]
public sealed virtual IMarkdownRule get_Rule();
    [CompilerGeneratedAttribute]
public sealed virtual IMarkdownContext get_Context();
    [CompilerGeneratedAttribute]
public InlineContent get_Content();
    [CompilerGeneratedAttribute]
public sealed virtual SourceInfo get_SourceInfo();
    public sealed virtual MarkdownNonParagraphBlockToken Rewrite(IMarkdownRewriteEngine rewriteEngine);
    public sealed virtual IEnumerable`1<IMarkdownToken> GetChildren();
}
public class Microsoft.DocAsCode.MarkdownLite.MarkdownNpTableBlockRule : object {
    private static Matcher _NpTableMatcher;
    public string Name { get; }
    [ObsoleteAttribute("Please use NewLineMatcher.")]
public Regex NpTable { get; }
    public Matcher NpTableMatcher { get; }
    private static MarkdownNpTableBlockRule();
    public virtual string get_Name();
    public virtual Regex get_NpTable();
    public virtual Matcher get_NpTableMatcher();
    public virtual IMarkdownToken TryMatch(IMarkdownParser parser, IMarkdownParsingContext context);
    private IMarkdownToken TryMatchOld(IMarkdownParser parser, IMarkdownParsingContext context);
    protected virtual Align[] ParseAligns(String[] aligns);
}
internal class Microsoft.DocAsCode.MarkdownLite.MarkdownNullTokenRewriter : object {
    public sealed virtual IMarkdownToken Rewrite(IMarkdownRewriteEngine engine, IMarkdownToken token);
}
public class Microsoft.DocAsCode.MarkdownLite.MarkdownParagraphBlockRule : object {
    public static MarkdownParagraphBlockRule Instance;
    public string Name { get; }
    private static MarkdownParagraphBlockRule();
    public sealed virtual string get_Name();
    public sealed virtual IMarkdownToken TryMatch(IMarkdownParser parser, IMarkdownParsingContext context);
}
public class Microsoft.DocAsCode.MarkdownLite.MarkdownParagraphBlockToken : object {
    [CompilerGeneratedAttribute]
private IMarkdownRule <Rule>k__BackingField;
    [CompilerGeneratedAttribute]
private IMarkdownContext <Context>k__BackingField;
    [CompilerGeneratedAttribute]
private InlineContent <InlineTokens>k__BackingField;
    [CompilerGeneratedAttribute]
private SourceInfo <SourceInfo>k__BackingField;
    public IMarkdownRule Rule { get; }
    public IMarkdownContext Context { get; }
    public InlineContent InlineTokens { get; }
    public SourceInfo SourceInfo { get; }
    public MarkdownParagraphBlockToken(IMarkdownRule rule, IMarkdownContext context, InlineContent inlineTokens, SourceInfo sourceInfo);
    [CompilerGeneratedAttribute]
public sealed virtual IMarkdownRule get_Rule();
    [CompilerGeneratedAttribute]
public sealed virtual IMarkdownContext get_Context();
    [CompilerGeneratedAttribute]
public InlineContent get_InlineTokens();
    [CompilerGeneratedAttribute]
public sealed virtual SourceInfo get_SourceInfo();
    public static MarkdownParagraphBlockToken Create(IMarkdownRule rule, MarkdownParser engine, string content, SourceInfo sourceInfo);
    public sealed virtual MarkdownParagraphBlockToken Rewrite(IMarkdownRewriteEngine rewriterEngine);
    public sealed virtual IEnumerable`1<IMarkdownToken> GetChildren();
}
public class Microsoft.DocAsCode.MarkdownLite.MarkdownParser : object {
    [CompilerGeneratedAttribute]
private Options <Options>k__BackingField;
    [CompilerGeneratedAttribute]
private IMarkdownContext <Context>k__BackingField;
    [CompilerGeneratedAttribute]
private Dictionary`2<string, LinkObj> <Links>k__BackingField;
    public Options Options { get; }
    public IMarkdownContext Context { get; private set; }
    public Dictionary`2<string, LinkObj> Links { get; }
    public MarkdownParser(IMarkdownContext context, Options options, Dictionary`2<string, LinkObj> links);
    [CompilerGeneratedAttribute]
public sealed virtual Options get_Options();
    [CompilerGeneratedAttribute]
public sealed virtual IMarkdownContext get_Context();
    [CompilerGeneratedAttribute]
private void set_Context(IMarkdownContext value);
    [CompilerGeneratedAttribute]
public sealed virtual Dictionary`2<string, LinkObj> get_Links();
    public sealed virtual IMarkdownContext SwitchContext(IMarkdownContext context);
    private IMarkdownContext SwitchContextCore(IMarkdownContext context);
    protected virtual string Preprocess(string src);
    public sealed virtual ImmutableArray`1<IMarkdownToken> Tokenize(SourceInfo sourceInfo);
    private List`1<IMarkdownToken> TokenizeCore(SourceInfo sourceInfo);
    private IMarkdownToken ApplyRules(MarkdownParsingContext pc);
}
[ExtensionAttribute]
public static class Microsoft.DocAsCode.MarkdownLite.MarkdownParserExtensions : object {
    [ExtensionAttribute]
public static IMarkdownContext SwitchContext(IMarkdownParser parser, string variableKey, object value);
    [ExtensionAttribute]
public static IMarkdownContext SwitchContext(IMarkdownParser parser, IReadOnlyDictionary`2<string, object> variables);
    [ExtensionAttribute]
public static InlineContent TokenizeInline(IMarkdownParser parser, SourceInfo sourceInfo);
}
public class Microsoft.DocAsCode.MarkdownLite.MarkdownParsingContext : object {
    private string _markdown;
    private int _startIndex;
    private List`1<int> _lineIndexer;
    private string _file;
    private int _lineOffset;
    private string _currentMarkdown;
    [CompilerGeneratedAttribute]
private bool <IsInParagraph>k__BackingField;
    public string Markdown { get; }
    public string CurrentMarkdown { get; }
    public bool IsInParagraph { get; public set; }
    public int LineNumber { get; }
    public string File { get; }
    public MarkdownParsingContext(SourceInfo sourceInfo);
    public sealed virtual string get_Markdown();
    public sealed virtual string get_CurrentMarkdown();
    [CompilerGeneratedAttribute]
public sealed virtual bool get_IsInParagraph();
    [CompilerGeneratedAttribute]
public sealed virtual void set_IsInParagraph(bool value);
    public sealed virtual int get_LineNumber();
    public sealed virtual string get_File();
    public SourceInfo ToSourceInfo();
    public sealed virtual SourceInfo Consume(int charCount);
    public sealed virtual MatchResult Match(Matcher matcher);
    private static List`1<int> CreateLineIndexer(string markdown);
    private int CalcLineNumber(int offset);
}
public class Microsoft.DocAsCode.MarkdownLite.MarkdownParsingException : MarkdownException {
    [CompilerGeneratedAttribute]
private SourceInfo <SourceInfo>k__BackingField;
    public SourceInfo SourceInfo { get; private set; }
    public MarkdownParsingException(SourceInfo sourceInfo);
    public MarkdownParsingException(string message, SourceInfo sourceInfo);
    public MarkdownParsingException(string message, SourceInfo sourceInfo, Exception innerException);
    [CompilerGeneratedAttribute]
public SourceInfo get_SourceInfo();
    [CompilerGeneratedAttribute]
private void set_SourceInfo(SourceInfo value);
    private static string GetMessage(string message, SourceInfo sourceInfo);
}
public class Microsoft.DocAsCode.MarkdownLite.MarkdownPreElementBlockRule : object {
    private static Matcher _ender;
    private static Matcher _preElementMatcher;
    public string Name { get; }
    public Regex PreElement { get; }
    public Matcher PreElementMatcher { get; }
    private static MarkdownPreElementBlockRule();
    public virtual string get_Name();
    public virtual Regex get_PreElement();
    public virtual Matcher get_PreElementMatcher();
    public virtual IMarkdownToken TryMatch(IMarkdownParser parser, IMarkdownParsingContext context);
    private IMarkdownToken TryMatchOld(IMarkdownParser parser, IMarkdownParsingContext context);
}
public class Microsoft.DocAsCode.MarkdownLite.MarkdownPreElementInlineRule : object {
    public string Name { get; }
    public Regex PreElement { get; }
    public virtual string get_Name();
    public virtual Regex get_PreElement();
    public virtual IMarkdownToken TryMatch(IMarkdownParser parser, IMarkdownParsingContext context);
}
public class Microsoft.DocAsCode.MarkdownLite.MarkdownRawToken : object {
    [CompilerGeneratedAttribute]
private IMarkdownRule <Rule>k__BackingField;
    [CompilerGeneratedAttribute]
private IMarkdownContext <Context>k__BackingField;
    [CompilerGeneratedAttribute]
private SourceInfo <SourceInfo>k__BackingField;
    public IMarkdownRule Rule { get; }
    public IMarkdownContext Context { get; }
    public SourceInfo SourceInfo { get; }
    public MarkdownRawToken(IMarkdownRule rule, IMarkdownContext context, SourceInfo sourceInfo);
    [CompilerGeneratedAttribute]
public sealed virtual IMarkdownRule get_Rule();
    [CompilerGeneratedAttribute]
public sealed virtual IMarkdownContext get_Context();
    [CompilerGeneratedAttribute]
public sealed virtual SourceInfo get_SourceInfo();
}
public class Microsoft.DocAsCode.MarkdownLite.MarkdownRefLinkInlineRule : MarkdownLinkBaseInlineRule {
    public string Name { get; }
    public Regex RefLink { get; }
    public virtual string get_Name();
    public virtual Regex get_RefLink();
    public virtual IMarkdownToken TryMatch(IMarkdownParser parser, IMarkdownParsingContext context);
}
public class Microsoft.DocAsCode.MarkdownLite.MarkdownRenderer : object {
    public virtual StringBuffer Render(IMarkdownRenderer render, IMarkdownToken token, IMarkdownContext context);
    public virtual StringBuffer Render(IMarkdownRenderer render, MarkdownImageInlineToken token, MarkdownInlineContext context);
    public virtual StringBuffer Render(IMarkdownRenderer render, MarkdownLinkInlineToken token, MarkdownInlineContext context);
    private StringBuffer RenderImageNormalLink(IMarkdownRenderer render, MarkdownImageInlineToken token, MarkdownInlineContext context);
    private StringBuffer RenderLinkNormalLink(IMarkdownRenderer render, MarkdownLinkInlineToken token, MarkdownInlineContext context);
    private StringBuffer RenderNumberLink(IMarkdownRenderer render, IMarkdownToken token, MarkdownInlineContext context);
    private StringBuffer RenderRefLink(IMarkdownRenderer render, IMarkdownToken token, MarkdownInlineContext context);
    private StringBuffer RenderAutoLink(IMarkdownRenderer render, MarkdownLinkInlineToken token, MarkdownInlineContext context);
    private StringBuffer RenderUrlLink(IMarkdownRenderer render, MarkdownLinkInlineToken token, MarkdownInlineContext context);
    public virtual StringBuffer Render(IMarkdownRenderer render, GfmDelInlineToken token, MarkdownInlineContext context);
    public virtual StringBuffer Render(IMarkdownRenderer render, MarkdownEmInlineToken token, MarkdownInlineContext context);
    public virtual StringBuffer Render(IMarkdownRenderer render, MarkdownStrongInlineToken token, MarkdownInlineContext context);
    public virtual StringBuffer Render(IMarkdownRenderer render, MarkdownHtmlBlockToken token, MarkdownBlockContext context);
    public virtual StringBuffer Render(IMarkdownRenderer render, MarkdownHrBlockToken token, MarkdownBlockContext context);
    public virtual StringBuffer Render(IMarkdownRenderer render, MarkdownHeadingBlockToken token, MarkdownBlockContext context);
    public virtual StringBuffer Render(IMarkdownRenderer render, MarkdownNonParagraphBlockToken token, MarkdownBlockContext context);
    public virtual StringBuffer Render(IMarkdownRenderer render, MarkdownParagraphBlockToken token, MarkdownBlockContext context);
    public virtual StringBuffer Render(IMarkdownRenderer render, MarkdownTableBlockToken token, MarkdownBlockContext context);
    public virtual StringBuffer Render(IMarkdownRenderer render, MarkdownBlockquoteBlockToken token, MarkdownBlockContext context);
    public virtual StringBuffer Render(IMarkdownRenderer render, MarkdownListBlockToken token, MarkdownBlockContext context);
    public virtual StringBuffer Render(IMarkdownRenderer render, MarkdownNewLineBlockToken token, IMarkdownContext context);
    protected virtual StringBuffer Render(IMarkdownRenderer render, MarkdownListItemBlockToken token, string indent);
}
public class Microsoft.DocAsCode.MarkdownLite.MarkdownRendererAdapter : object {
    [CompilerGeneratedAttribute]
private IMarkdownEngine <Engine>k__BackingField;
    [CompilerGeneratedAttribute]
private object <Renderer>k__BackingField;
    [CompilerGeneratedAttribute]
private Options <Options>k__BackingField;
    [CompilerGeneratedAttribute]
private Dictionary`2<string, LinkObj> <Links>k__BackingField;
    public IMarkdownEngine Engine { get; }
    public object Renderer { get; }
    public Options Options { get; }
    public Dictionary`2<string, LinkObj> Links { get; }
    public MarkdownRendererAdapter(IMarkdownEngine engine, object renderer, Options options, Dictionary`2<string, LinkObj> links);
    [CompilerGeneratedAttribute]
public sealed virtual IMarkdownEngine get_Engine();
    [CompilerGeneratedAttribute]
public object get_Renderer();
    [CompilerGeneratedAttribute]
public sealed virtual Options get_Options();
    [CompilerGeneratedAttribute]
public sealed virtual Dictionary`2<string, LinkObj> get_Links();
    public sealed virtual StringBuffer Render(IMarkdownToken token);
}
public class Microsoft.DocAsCode.MarkdownLite.MarkdownRewriteEngine : object {
    private IMarkdownTokenRewriter _rewriter;
    private Stack`1<IMarkdownToken> _parents;
    private Dictionary`2<string, object> _variables;
    private Dictionary`2<string, Action`1<IMarkdownRewriteEngine>> _postProcesses;
    [CompilerGeneratedAttribute]
private IMarkdownEngine <Engine>k__BackingField;
    public IMarkdownEngine Engine { get; }
    public MarkdownRewriteEngine(IMarkdownEngine engine, IMarkdownTokenRewriter rewriter);
    [CompilerGeneratedAttribute]
public sealed virtual IMarkdownEngine get_Engine();
    public virtual ImmutableArray`1<IMarkdownToken> Rewrite(ImmutableArray`1<IMarkdownToken> tokens);
    public virtual ImmutableArray`1<IMarkdownToken> GetParents();
    public virtual bool HasVariable(string name);
    public virtual object GetVariable(string name);
    public virtual void SetVariable(string name, object value);
    public virtual void RemoveVariable(string name);
    public virtual bool HasPostProcess(string name);
    public virtual void SetPostProcess(string name, Action`1<IMarkdownRewriteEngine> action);
    public virtual void RemovePostProcess(string name);
    public virtual void Complete();
    public sealed virtual void Initialize();
}
internal class Microsoft.DocAsCode.MarkdownLite.MarkdownSequenceTokenRewriter : object {
    [CompilerGeneratedAttribute]
private ImmutableArray`1<IMarkdownTokenRewriter> <Inner>k__BackingField;
    public ImmutableArray`1<IMarkdownTokenRewriter> Inner { get; }
    public MarkdownSequenceTokenRewriter(ImmutableArray`1<IMarkdownTokenRewriter> inner);
    [CompilerGeneratedAttribute]
public ImmutableArray`1<IMarkdownTokenRewriter> get_Inner();
    public sealed virtual void Initialize(IMarkdownRewriteEngine rewriteEngine);
    public sealed virtual IMarkdownToken Rewrite(IMarkdownRewriteEngine engine, IMarkdownToken token);
}
public class Microsoft.DocAsCode.MarkdownLite.MarkdownStrongInlineRule : object {
    public string Name { get; }
    public Regex Strong { get; }
    public virtual string get_Name();
    public virtual Regex get_Strong();
    public virtual IMarkdownToken TryMatch(IMarkdownParser parser, IMarkdownParsingContext context);
}
public class Microsoft.DocAsCode.MarkdownLite.MarkdownStrongInlineToken : object {
    [CompilerGeneratedAttribute]
private IMarkdownRule <Rule>k__BackingField;
    [CompilerGeneratedAttribute]
private IMarkdownContext <Context>k__BackingField;
    [CompilerGeneratedAttribute]
private ImmutableArray`1<IMarkdownToken> <Content>k__BackingField;
    [CompilerGeneratedAttribute]
private SourceInfo <SourceInfo>k__BackingField;
    public IMarkdownRule Rule { get; }
    public IMarkdownContext Context { get; }
    public ImmutableArray`1<IMarkdownToken> Content { get; }
    public SourceInfo SourceInfo { get; }
    public MarkdownStrongInlineToken(IMarkdownRule rule, IMarkdownContext context, ImmutableArray`1<IMarkdownToken> content, SourceInfo sourceInfo);
    [CompilerGeneratedAttribute]
public sealed virtual IMarkdownRule get_Rule();
    [CompilerGeneratedAttribute]
public sealed virtual IMarkdownContext get_Context();
    [CompilerGeneratedAttribute]
public ImmutableArray`1<IMarkdownToken> get_Content();
    [CompilerGeneratedAttribute]
public sealed virtual SourceInfo get_SourceInfo();
    public sealed virtual MarkdownStrongInlineToken Rewrite(IMarkdownRewriteEngine rewriterEngine);
    public sealed virtual IEnumerable`1<IMarkdownToken> GetChildren();
}
public class Microsoft.DocAsCode.MarkdownLite.MarkdownTableBlockRule : object {
    private static Matcher _TableMatcher;
    public string Name { get; }
    [ObsoleteAttribute("Please use TableMatcher.")]
public Regex Table { get; }
    public Matcher TableMatcher { get; }
    private static MarkdownTableBlockRule();
    public virtual string get_Name();
    public virtual Regex get_Table();
    public virtual Matcher get_TableMatcher();
    public virtual IMarkdownToken TryMatch(IMarkdownParser parser, IMarkdownParsingContext context);
    private IMarkdownToken TryMatchOld(IMarkdownParser parser, IMarkdownParsingContext context);
    protected virtual Align[] ParseAligns(String[] aligns);
}
public class Microsoft.DocAsCode.MarkdownLite.MarkdownTableBlockToken : object {
    [CompilerGeneratedAttribute]
private IMarkdownRule <Rule>k__BackingField;
    [CompilerGeneratedAttribute]
private IMarkdownContext <Context>k__BackingField;
    [CompilerGeneratedAttribute]
private ImmutableArray`1<MarkdownTableItemBlockToken> <Header>k__BackingField;
    [CompilerGeneratedAttribute]
private ImmutableArray`1<Align> <Align>k__BackingField;
    [CompilerGeneratedAttribute]
private ImmutableArray`1<ImmutableArray`1<MarkdownTableItemBlockToken>> <Cells>k__BackingField;
    [CompilerGeneratedAttribute]
private SourceInfo <SourceInfo>k__BackingField;
    public IMarkdownRule Rule { get; }
    public IMarkdownContext Context { get; }
    public ImmutableArray`1<MarkdownTableItemBlockToken> Header { get; }
    public ImmutableArray`1<Align> Align { get; }
    public ImmutableArray`1<ImmutableArray`1<MarkdownTableItemBlockToken>> Cells { get; }
    public SourceInfo SourceInfo { get; }
    public MarkdownTableBlockToken(IMarkdownRule rule, IMarkdownContext context, ImmutableArray`1<MarkdownTableItemBlockToken> header, ImmutableArray`1<Align> align, ImmutableArray`1<ImmutableArray`1<MarkdownTableItemBlockToken>> cells, SourceInfo sourceInfo);
    [CompilerGeneratedAttribute]
public sealed virtual IMarkdownRule get_Rule();
    [CompilerGeneratedAttribute]
public sealed virtual IMarkdownContext get_Context();
    [CompilerGeneratedAttribute]
public ImmutableArray`1<MarkdownTableItemBlockToken> get_Header();
    [CompilerGeneratedAttribute]
public ImmutableArray`1<Align> get_Align();
    [CompilerGeneratedAttribute]
public ImmutableArray`1<ImmutableArray`1<MarkdownTableItemBlockToken>> get_Cells();
    [CompilerGeneratedAttribute]
public sealed virtual SourceInfo get_SourceInfo();
    public sealed virtual MarkdownTableBlockToken Rewrite(IMarkdownRewriteEngine rewriterEngine);
    public sealed virtual IEnumerable`1<IMarkdownToken> GetChildren();
}
public class Microsoft.DocAsCode.MarkdownLite.MarkdownTableItemBlockToken : object {
    [CompilerGeneratedAttribute]
private IMarkdownContext <Context>k__BackingField;
    [CompilerGeneratedAttribute]
private IMarkdownRule <Rule>k__BackingField;
    [CompilerGeneratedAttribute]
private SourceInfo <SourceInfo>k__BackingField;
    [CompilerGeneratedAttribute]
private InlineContent <Content>k__BackingField;
    public IMarkdownContext Context { get; }
    public IMarkdownRule Rule { get; }
    public SourceInfo SourceInfo { get; }
    public InlineContent Content { get; }
    public MarkdownTableItemBlockToken(IMarkdownRule rule, IMarkdownContext context, InlineContent content, SourceInfo sourceInfo);
    [CompilerGeneratedAttribute]
public sealed virtual IMarkdownContext get_Context();
    [CompilerGeneratedAttribute]
public sealed virtual IMarkdownRule get_Rule();
    [CompilerGeneratedAttribute]
public sealed virtual SourceInfo get_SourceInfo();
    [CompilerGeneratedAttribute]
public InlineContent get_Content();
    public sealed virtual MarkdownTableItemBlockToken Rewrite(IMarkdownRewriteEngine rewriterEngine);
}
public class Microsoft.DocAsCode.MarkdownLite.MarkdownTagInlineRule : object {
    public string Name { get; }
    public Regex Tag { get; }
    public virtual string get_Name();
    public virtual Regex get_Tag();
    public virtual IMarkdownToken TryMatch(IMarkdownParser parser, IMarkdownParsingContext context);
}
public class Microsoft.DocAsCode.MarkdownLite.MarkdownTagInlineToken : object {
    [CompilerGeneratedAttribute]
private IMarkdownRule <Rule>k__BackingField;
    [CompilerGeneratedAttribute]
private IMarkdownContext <Context>k__BackingField;
    [CompilerGeneratedAttribute]
private SourceInfo <SourceInfo>k__BackingField;
    public IMarkdownRule Rule { get; }
    public IMarkdownContext Context { get; }
    public SourceInfo SourceInfo { get; }
    public MarkdownTagInlineToken(IMarkdownRule rule, IMarkdownContext context, SourceInfo sourceInfo);
    [CompilerGeneratedAttribute]
public sealed virtual IMarkdownRule get_Rule();
    [CompilerGeneratedAttribute]
public sealed virtual IMarkdownContext get_Context();
    [CompilerGeneratedAttribute]
public sealed virtual SourceInfo get_SourceInfo();
}
public class Microsoft.DocAsCode.MarkdownLite.MarkdownTextBlockRule : object {
    private static Matcher _TextMatcher;
    public string Name { get; }
    [ObsoleteAttribute("Please use LHeadingMatcher.")]
public Regex Text { get; }
    public Matcher TextMatcher { get; }
    private static MarkdownTextBlockRule();
    public virtual string get_Name();
    public virtual Regex get_Text();
    public virtual Matcher get_TextMatcher();
    public virtual IMarkdownToken TryMatch(IMarkdownParser parser, IMarkdownParsingContext context);
    public virtual IMarkdownToken TryMatchOld(IMarkdownParser parser, IMarkdownParsingContext context);
}
public class Microsoft.DocAsCode.MarkdownLite.MarkdownTextInlineRule : object {
    public string Name { get; }
    public Regex Text { get; }
    public virtual string get_Name();
    public virtual Regex get_Text();
    public virtual IMarkdownToken TryMatch(IMarkdownParser parser, IMarkdownParsingContext context);
    protected virtual string Smartypants(Options options, string text);
}
public class Microsoft.DocAsCode.MarkdownLite.MarkdownTextToken : object {
    [CompilerGeneratedAttribute]
private IMarkdownRule <Rule>k__BackingField;
    [CompilerGeneratedAttribute]
private IMarkdownContext <Context>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Content>k__BackingField;
    [CompilerGeneratedAttribute]
private SourceInfo <SourceInfo>k__BackingField;
    public IMarkdownRule Rule { get; }
    public IMarkdownContext Context { get; }
    public string Content { get; }
    public SourceInfo SourceInfo { get; }
    public MarkdownTextToken(IMarkdownRule rule, IMarkdownContext context, string content, SourceInfo sourceInfo);
    [CompilerGeneratedAttribute]
public sealed virtual IMarkdownRule get_Rule();
    [CompilerGeneratedAttribute]
public sealed virtual IMarkdownContext get_Context();
    [CompilerGeneratedAttribute]
public string get_Content();
    [CompilerGeneratedAttribute]
public sealed virtual SourceInfo get_SourceInfo();
}
internal class Microsoft.DocAsCode.MarkdownLite.MarkdownTokenAggregateContext : object {
    private ImmutableArray`1<IMarkdownToken> _sourceTokens;
    private int _currentTokenIndex;
    private List`1<IMarkdownToken> _tokens;
    [CompilerGeneratedAttribute]
private IMarkdownToken <ParentToken>k__BackingField;
    public IMarkdownToken ParentToken { get; }
    public IMarkdownToken CurrentToken { get; }
    internal IList`1<IMarkdownToken> Tokens { get; }
    internal ImmutableArray`1<IMarkdownToken> ImmutableTokens { get; }
    internal int TokenLength { get; }
    public MarkdownTokenAggregateContext(IMarkdownToken parentToken, ImmutableArray`1<IMarkdownToken> tokens);
    [CompilerGeneratedAttribute]
public sealed virtual IMarkdownToken get_ParentToken();
    public sealed virtual IMarkdownToken LookAhead(int offset);
    public sealed virtual void AggregateTo(IMarkdownToken token, int tokenCount);
    public sealed virtual IMarkdownToken get_CurrentToken();
    internal IList`1<IMarkdownToken> get_Tokens();
    internal ImmutableArray`1<IMarkdownToken> get_ImmutableTokens();
    internal bool NextToken();
    internal IMarkdownToken GetToken(int index);
    internal void SetToken(int index, IMarkdownToken token);
    internal int get_TokenLength();
    private void EnsureWrite();
}
public abstract class Microsoft.DocAsCode.MarkdownLite.MarkdownTokenAggregator`1 : object {
    public sealed virtual bool Aggregate(IMarkdownTokenAggregateContext context);
    protected abstract virtual bool AggregateCore(THeader headToken, IMarkdownTokenAggregateContext context);
}
[ExtensionAttribute]
public static class Microsoft.DocAsCode.MarkdownLite.MarkdownTokenExtensions : object {
    [ExtensionAttribute]
public static IEnumerable`1<IMarkdownToken> Children(IMarkdownToken token);
    [ExtensionAttribute]
public static IEnumerable`1<T> Children(IMarkdownToken token);
    private static IEnumerable`1<IMarkdownToken> ChildrenCore(IMarkdownToken token);
    [ExtensionAttribute]
public static IEnumerable`1<IMarkdownToken> Descendants(IMarkdownToken token);
    [ExtensionAttribute]
public static IEnumerable`1<T> Descendants(IMarkdownToken token);
    private static IEnumerable`1<IMarkdownToken> DescendantsCore(IMarkdownToken token);
    [ExtensionAttribute]
public static IEnumerable`1<IMarkdownToken> BlockTokens(IEnumerable`1<IMarkdownToken> tokens);
    [ExtensionAttribute]
public static IEnumerable`1<IMarkdownToken> InlineTokens(IEnumerable`1<IMarkdownToken> tokens);
}
public static class Microsoft.DocAsCode.MarkdownLite.MarkdownTokenRewriterFactory : object {
    public static IMarkdownTokenRewriter Null;
    private static MarkdownTokenRewriterFactory();
    public static IMarkdownTokenRewriter FromLambda(Func`3<TEngine, TToken, IMarkdownToken> rewriteFunc);
    public static IMarkdownTokenRewriter FromLambda(Func`3<TEngine, TToken, IMarkdownToken> rewriteFunc, Action`1<TEngine> initializer);
    public static IMarkdownTokenRewriter FromValidators(IEnumerable`1<IMarkdownTokenValidator> validators);
    public static IMarkdownTokenRewriter FromValidators(IMarkdownTokenValidator[] validators);
    public static IMarkdownTokenRewriter FromValidators(string scopeName, IEnumerable`1<IMarkdownTokenValidator> validators);
    public static IMarkdownTokenRewriter Composite(IMarkdownTokenRewriter[] rewriters);
    public static IMarkdownTokenRewriter Composite(IEnumerable`1<IMarkdownTokenRewriter> rewriters);
    public static IMarkdownTokenRewriter Loop(IMarkdownTokenRewriter rewriter, int maxLoopCount);
    public static IMarkdownTokenRewriter Sequence(IMarkdownTokenRewriter[] rewriters);
}
public static class Microsoft.DocAsCode.MarkdownLite.MarkdownTokenTreeValidatorFactory : object {
    public static IMarkdownTokenTreeValidator Null;
    private static MarkdownTokenTreeValidatorFactory();
    public static IMarkdownTokenTreeValidator Combine(IMarkdownTokenTreeValidator[] validators);
    public static IMarkdownTokenTreeValidator Combine(IEnumerable`1<IMarkdownTokenTreeValidator> validators);
}
internal class Microsoft.DocAsCode.MarkdownLite.MarkdownTokenValidatorAdapter : object {
    [CompilerGeneratedAttribute]
private ImmutableArray`1<IMarkdownTokenValidator> <Validators>k__BackingField;
    public ImmutableArray`1<IMarkdownTokenValidator> Validators { get; }
    public MarkdownTokenValidatorAdapter(IEnumerable`1<IMarkdownTokenValidator> validators);
    [CompilerGeneratedAttribute]
public ImmutableArray`1<IMarkdownTokenValidator> get_Validators();
    public sealed virtual IMarkdownToken Rewrite(IMarkdownRewriteEngine engine, IMarkdownToken token);
    public sealed virtual void Initialize(IMarkdownRewriteEngine rewriteEngine);
}
public class Microsoft.DocAsCode.MarkdownLite.MarkdownTokenValidatorContext : object {
    [ThreadStaticAttribute]
private static MarkdownTokenValidatorContext _current;
    private IMarkdownRewriteEngine _rewriteEngine;
    private string _file;
    public static IMarkdownRewriteEngine CurrentRewriteEngine { get; }
    public static string CurrentFile { get; }
    internal MarkdownTokenValidatorContext(IMarkdownRewriteEngine rewriteEngine, string file);
    public static IMarkdownRewriteEngine get_CurrentRewriteEngine();
    public static string get_CurrentFile();
    private sealed virtual override void System.IDisposable.Dispose();
}
public static class Microsoft.DocAsCode.MarkdownLite.MarkdownTokenValidatorFactory : object {
    public static IMarkdownTokenValidator FromLambda(Action`1<TToken> validator);
    public static IMarkdownTokenValidator FromLambda(Action`1<TToken> validator, Action`1<IMarkdownRewriteEngine> initializer);
}
internal class Microsoft.DocAsCode.MarkdownLite.Matchers.AnyCharInMatcher : Matcher {
    private Char[] _ch;
    public AnyCharInMatcher(Char[] ch);
    public virtual int Match(MatchContent content);
    public sealed virtual Matcher Repeat(int minOccur, int maxOccur);
    public virtual string ToString();
}
internal class Microsoft.DocAsCode.MarkdownLite.Matchers.AnyCharInRangeMatcher : Matcher {
    private char _start;
    private char _end;
    public AnyCharInRangeMatcher(char start, char end);
    public virtual int Match(MatchContent content);
    public sealed virtual Matcher Repeat(int minOccur, int maxOccur);
    public virtual string ToString();
}
internal class Microsoft.DocAsCode.MarkdownLite.Matchers.AnyCharInRangeRepeatMatcher : Matcher {
    private char _start;
    private char _end;
    private int _minOccur;
    private int _maxOccur;
    public AnyCharInRangeRepeatMatcher(char start, char end, int minOccur, int maxOccur);
    public virtual int Match(MatchContent content);
    public virtual string ToString();
}
internal class Microsoft.DocAsCode.MarkdownLite.Matchers.AnyCharInRepeatMatcher : Matcher {
    private Char[] _ch;
    private int _minOccur;
    private int _maxOccur;
    public AnyCharInRepeatMatcher(Char[] ch, int minOccur, int maxOccur);
    public virtual int Match(MatchContent content);
    public virtual string ToString();
}
internal class Microsoft.DocAsCode.MarkdownLite.Matchers.AnyCharMatcher : Matcher {
    public virtual int Match(MatchContent content);
    public virtual string ToString();
}
internal class Microsoft.DocAsCode.MarkdownLite.Matchers.AnyCharNotInMatcher : Matcher {
    private Char[] _ch;
    public AnyCharNotInMatcher(Char[] ch);
    public virtual int Match(MatchContent content);
    public sealed virtual Matcher Repeat(int minOccur, int maxOccur);
    public virtual string ToString();
}
internal class Microsoft.DocAsCode.MarkdownLite.Matchers.AnyCharNotInRepeatMatcher : Matcher {
    private Char[] _ch;
    private int _minOccur;
    private int _maxOccur;
    public AnyCharNotInRepeatMatcher(Char[] ch, int minOccur, int maxOccur);
    public virtual int Match(MatchContent content);
    public virtual string ToString();
}
internal class Microsoft.DocAsCode.MarkdownLite.Matchers.AnyCharNotMatcher : Matcher {
    private char _ch;
    public AnyCharNotMatcher(char ch);
    public virtual int Match(MatchContent content);
    public sealed virtual Matcher Repeat(int minOccur, int maxOccur);
    public virtual string ToString();
}
internal class Microsoft.DocAsCode.MarkdownLite.Matchers.AnyCharNotRepeatMatcher : Matcher {
    private char _ch;
    private int _minOccur;
    private int _maxOccur;
    public AnyCharNotRepeatMatcher(char ch, int minOccur, int maxOccur);
    public virtual int Match(MatchContent content);
    public virtual string ToString();
}
internal class Microsoft.DocAsCode.MarkdownLite.Matchers.AnyMatcher : Matcher {
    private Matcher[] _inners;
    internal Matcher[] Inners { get; }
    public AnyMatcher(Matcher[] inners);
    public virtual int Match(MatchContent content);
    internal Matcher[] get_Inners();
    public virtual string ToString();
}
internal class Microsoft.DocAsCode.MarkdownLite.Matchers.BackReferenceMatcher : Matcher {
    private string _groupName;
    public BackReferenceMatcher(string groupName);
    public virtual int Match(MatchContent content);
    public virtual string ToString();
}
internal class Microsoft.DocAsCode.MarkdownLite.Matchers.CaptureGroupMatcher : Matcher {
    private string _groupName;
    private Matcher _inner;
    public CaptureGroupMatcher(string groupName, Matcher inner);
    public virtual int Match(MatchContent content);
    public virtual string ToString();
}
internal class Microsoft.DocAsCode.MarkdownLite.Matchers.CaseInsensitiveStringMatcher : Matcher {
    private string _upperCaseText;
    private string _lowerCaseText;
    public CaseInsensitiveStringMatcher(string text);
    public virtual int Match(MatchContent content);
    public virtual string ToString();
}
internal class Microsoft.DocAsCode.MarkdownLite.Matchers.CharMatcher : Matcher {
    private char _ch;
    public CharMatcher(char ch);
    public virtual int Match(MatchContent content);
    public sealed virtual Matcher Repeat(int minOccur, int maxOccur);
    public virtual string ToString();
}
internal class Microsoft.DocAsCode.MarkdownLite.Matchers.CharRepeatMatcher : Matcher {
    private char _ch;
    private int _minOccur;
    private int _maxOccur;
    public CharRepeatMatcher(char ch, int minOccur, int maxOccur);
    public virtual int Match(MatchContent content);
    public virtual string ToString();
}
internal class Microsoft.DocAsCode.MarkdownLite.Matchers.EndOfStringMatcher : Matcher {
    public virtual int Match(MatchContent content);
    public virtual string ToString();
}
internal interface Microsoft.DocAsCode.MarkdownLite.Matchers.IRepeatable {
    public abstract virtual Matcher Repeat(int minOccur, int maxOccur);
}
public enum Microsoft.DocAsCode.MarkdownLite.Matchers.LengthComparison : Enum {
    public int value__;
    public static LengthComparison Equals;
    public static LengthComparison LessThan;
    public static LengthComparison GreaterThan;
    public static LengthComparison LessThanOrEquals;
    public static LengthComparison GreaterThanOrEquals;
}
internal class Microsoft.DocAsCode.MarkdownLite.Matchers.LengthComparisonMatcher : Matcher {
    private string _groupName;
    private Matcher _inner;
    private LengthComparison _comparsion;
    public LengthComparisonMatcher(Matcher inner, LengthComparison comparsion, string groupName);
    public virtual int Match(MatchContent content);
    public virtual string ToString();
}
[DefaultMemberAttribute("Item")]
public class Microsoft.DocAsCode.MarkdownLite.Matchers.MatchContent : ValueType {
    public string Text;
    public int StartIndex;
    public MatchDirection Direction;
    private Dictionary`2<string, KeyValuePair`2<int, int>> _group;
    public char Item { get; }
    public int Length { get; }
    public MatchContent(string text, int startIndex, MatchDirection direction);
    private MatchContent(string text, int startIndex, MatchDirection direction, Dictionary`2<string, KeyValuePair`2<int, int>> group);
    public char GetCurrentChar();
    public char get_Item(int offset);
    public bool BeginOfString();
    public bool EndOfString();
    public int get_Length();
    public MatchContent Offset(int offset);
    public MatchContent Reverse();
    public int CountUntil(char ch, int maxCount);
    public int CountUntilAny(Char[] ch, int maxCount);
    public int CountUntilInRange(char start, char end, int maxCount);
    public int CountWhile(char ch, int maxCount);
    internal int CountWhileAny(Char[] ch, int maxCount);
    public int CountWhileInRange(char start, char end, int maxCount);
    public void AddGroup(string name, int startIndex, int count);
    public Nullable`1<MatchGroup> GetGroup(string name);
    [IteratorStateMachineAttribute("Microsoft.DocAsCode.MarkdownLite.Matchers.MatchContent/<EnumerateGroups>d__23")]
public IEnumerable`1<MatchGroup> EnumerateGroups();
    private int GetIndex(int offset);
    private int GetCharIndex(int offset);
    private int GetIndexNoThrow(int offset);
}
public enum Microsoft.DocAsCode.MarkdownLite.Matchers.MatchDirection : Enum {
    public byte value__;
    public static MatchDirection Forward;
    public static MatchDirection Backward;
}
public abstract class Microsoft.DocAsCode.MarkdownLite.Matchers.Matcher : object {
    public static int NotMatch;
    [CompilerGeneratedAttribute]
private static Matcher <AnyChar>k__BackingField;
    [CompilerGeneratedAttribute]
private static Matcher <WhiteSpace>k__BackingField;
    [CompilerGeneratedAttribute]
private static Matcher <WhiteSpaces>k__BackingField;
    [CompilerGeneratedAttribute]
private static Matcher <WhiteSpacesOrEmpty>k__BackingField;
    [CompilerGeneratedAttribute]
private static Matcher <NewLine>k__BackingField;
    [CompilerGeneratedAttribute]
private static Matcher <BlankCharacter>k__BackingField;
    [CompilerGeneratedAttribute]
private static Matcher <Blank>k__BackingField;
    [CompilerGeneratedAttribute]
private static Matcher <BlankOrEmpty>k__BackingField;
    [CompilerGeneratedAttribute]
private static Matcher <AnyStringInSingleLine>k__BackingField;
    [CompilerGeneratedAttribute]
private static Matcher <AnyStringInSingleLineOrEmpty>k__BackingField;
    [CompilerGeneratedAttribute]
private static Matcher <AnyWordCharacter>k__BackingField;
    [CompilerGeneratedAttribute]
private static Matcher <EndOfString>k__BackingField;
    [CompilerGeneratedAttribute]
private static Matcher <WordBoundary>k__BackingField;
    public static Matcher AnyChar { get; }
    public static Matcher WhiteSpace { get; }
    public static Matcher WhiteSpaces { get; }
    public static Matcher WhiteSpacesOrEmpty { get; }
    public static Matcher NewLine { get; }
    public static Matcher BlankCharacter { get; }
    public static Matcher Blank { get; }
    public static Matcher BlankOrEmpty { get; }
    public static Matcher AnyStringInSingleLine { get; }
    public static Matcher AnyStringInSingleLineOrEmpty { get; }
    public static Matcher AnyWordCharacter { get; }
    public static Matcher EndOfString { get; }
    public static Matcher WordBoundary { get; }
    private static Matcher();
    public abstract virtual int Match(MatchContent content);
    protected string EscapeText(string text);
    public static Matcher Char(char ch);
    [CompilerGeneratedAttribute]
public static Matcher get_AnyChar();
    public static Matcher AnyCharIn(Char[] ch);
    public static Matcher AnyCharInRange(char start, char end);
    public static Matcher AnyCharNot(char ch);
    public static Matcher AnyCharNotIn(Char[] ch);
    [CompilerGeneratedAttribute]
public static Matcher get_WhiteSpace();
    [CompilerGeneratedAttribute]
public static Matcher get_WhiteSpaces();
    [CompilerGeneratedAttribute]
public static Matcher get_WhiteSpacesOrEmpty();
    [CompilerGeneratedAttribute]
public static Matcher get_NewLine();
    [CompilerGeneratedAttribute]
public static Matcher get_BlankCharacter();
    [CompilerGeneratedAttribute]
public static Matcher get_Blank();
    [CompilerGeneratedAttribute]
public static Matcher get_BlankOrEmpty();
    public static Matcher String(string text);
    public static Matcher CaseInsensitiveString(string text);
    [CompilerGeneratedAttribute]
public static Matcher get_AnyStringInSingleLine();
    [CompilerGeneratedAttribute]
public static Matcher get_AnyStringInSingleLineOrEmpty();
    [CompilerGeneratedAttribute]
public static Matcher get_AnyWordCharacter();
    [CompilerGeneratedAttribute]
public static Matcher get_EndOfString();
    [CompilerGeneratedAttribute]
public static Matcher get_WordBoundary();
    public static Matcher Maybe(Matcher matcher);
    public static Matcher Repeat(Matcher matcher, int minOccur);
    public static Matcher Repeat(Matcher matcher, int minOccur, int maxOccur);
    public static Matcher Any(Matcher[] matchers);
    public static Matcher Sequence(Matcher[] matchers);
    public static Matcher Test(Matcher[] matchers);
    public static Matcher NegativeTest(Matcher[] matchers);
    public static Matcher ReverseTest(Matcher[] matchers);
    public static Matcher ReverseNegativeTest(Matcher[] matchers);
    public static Matcher CaptureGroup(string name, Matcher matcher);
    public static Matcher BackReference(string groupName);
    public static Matcher CompareLength(Matcher inner, LengthComparison comparsion, string groupName);
    private static void ValidateMatcherArray(Matcher[] matchers);
    public static Matcher op_Addition(Matcher left, Matcher right);
    public static Matcher op_Addition(Matcher left, char right);
    public static Matcher op_Addition(Matcher left, string right);
    public static Matcher op_BitwiseOr(Matcher left, Matcher right);
    public static Matcher op_Multiply(Matcher matcher, int count);
    public static Matcher op_Explicit(string text);
    public static Matcher op_Explicit(char ch);
}
[ExtensionAttribute]
public static class Microsoft.DocAsCode.MarkdownLite.Matchers.MatcherExtensions : object {
    [ExtensionAttribute]
public static MatchResult Match(Matcher matcher, string text, int startIndex);
    [ExtensionAttribute]
public static Matcher ToGroup(Matcher matcher, string groupName);
    [ExtensionAttribute]
public static Matcher Maybe(Matcher matcher);
    [ExtensionAttribute]
public static Matcher RepeatAtLeast(Matcher matcher, int minOccur);
    [ExtensionAttribute]
public static Matcher Repeat(Matcher matcher, int minOccur, int maxOccur);
    [ExtensionAttribute]
public static Matcher ToTest(Matcher matcher);
    [ExtensionAttribute]
public static Matcher ToNegativeTest(Matcher matcher);
    [ExtensionAttribute]
public static Matcher ToReverseTest(Matcher matcher);
    [ExtensionAttribute]
public static Matcher ToReverseNegativeTest(Matcher matcher);
    [ExtensionAttribute]
public static Matcher CompareLength(Matcher matcher, LengthComparison comparsion, string groupName);
}
public class Microsoft.DocAsCode.MarkdownLite.Matchers.MatchGroup : ValueType {
    public string Name;
    public int StartIndex;
    public int Count;
    private string _text;
    private string _value;
    public MatchGroup(string name, string text, int startIndex, int count);
    public string GetValue();
}
[DefaultMemberAttribute("Item")]
public class Microsoft.DocAsCode.MarkdownLite.Matchers.MatchResult : object {
    private MatchContent _mc;
    [CompilerGeneratedAttribute]
private int <Length>k__BackingField;
    public int Length { get; }
    public MatchGroup Item { get; }
    public MatchResult(int length, MatchContent mc);
    [CompilerGeneratedAttribute]
public int get_Length();
    public MatchGroup get_Item(string name);
    public Nullable`1<MatchGroup> GetGroup(string name);
    public IEnumerable`1<MatchGroup> EnumerateGroups();
}
internal class Microsoft.DocAsCode.MarkdownLite.Matchers.RepeatMatcher : Matcher {
    private Matcher _inner;
    private int _minOccur;
    private int _maxOccur;
    public RepeatMatcher(Matcher inner, int minOccur, int maxOccur);
    public virtual int Match(MatchContent content);
    public virtual string ToString();
}
internal class Microsoft.DocAsCode.MarkdownLite.Matchers.ReverseMatcher : Matcher {
    private Matcher _inner;
    public ReverseMatcher(Matcher inner);
    public virtual int Match(MatchContent content);
    public virtual string ToString();
}
internal class Microsoft.DocAsCode.MarkdownLite.Matchers.SequenceMatcher : Matcher {
    private Matcher[] _inners;
    internal Matcher[] Inners { get; }
    public SequenceMatcher(Matcher[] inners);
    public virtual int Match(MatchContent content);
    internal Matcher[] get_Inners();
    public virtual string ToString();
}
internal class Microsoft.DocAsCode.MarkdownLite.Matchers.StringMatcher : Matcher {
    private string _text;
    public StringMatcher(string text);
    public virtual int Match(MatchContent content);
    public virtual string ToString();
}
internal class Microsoft.DocAsCode.MarkdownLite.Matchers.TestMatcher : Matcher {
    private Matcher[] _inner;
    private bool _isNegative;
    public TestMatcher(Matcher[] inner, bool isNegative);
    public virtual int Match(MatchContent content);
    public virtual string ToString();
}
public class Microsoft.DocAsCode.MarkdownLite.Options : object {
    [CompilerGeneratedAttribute]
private Func`3<string, string, string> <Highlight>k__BackingField;
    [CompilerGeneratedAttribute]
private Func`2<string, string> <Sanitizer>k__BackingField;
    [CompilerGeneratedAttribute]
private string <LangPrefix>k__BackingField;
    [CompilerGeneratedAttribute]
private string <HeaderPrefix>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <XHtml>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <Sanitize>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <Pedantic>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <Mangle>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <Smartypants>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <Breaks>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <Gfm>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <Tables>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <SmartLists>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <ShouldExportSourceInfo>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <LegacyMode>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <ShouldFixId>k__BackingField;
    public Func`3<string, string, string> Highlight { get; public set; }
    public Func`2<string, string> Sanitizer { get; public set; }
    public string LangPrefix { get; public set; }
    public string HeaderPrefix { get; public set; }
    public bool XHtml { get; public set; }
    public bool Sanitize { get; public set; }
    public bool Pedantic { get; public set; }
    public bool Mangle { get; public set; }
    public bool Smartypants { get; public set; }
    public bool Breaks { get; public set; }
    public bool Gfm { get; public set; }
    public bool Tables { get; public set; }
    public bool SmartLists { get; public set; }
    public bool ShouldExportSourceInfo { get; public set; }
    public bool LegacyMode { get; public set; }
    public bool ShouldFixId { get; public set; }
    [CompilerGeneratedAttribute]
public Func`3<string, string, string> get_Highlight();
    [CompilerGeneratedAttribute]
public void set_Highlight(Func`3<string, string, string> value);
    [CompilerGeneratedAttribute]
public Func`2<string, string> get_Sanitizer();
    [CompilerGeneratedAttribute]
public void set_Sanitizer(Func`2<string, string> value);
    [CompilerGeneratedAttribute]
public string get_LangPrefix();
    [CompilerGeneratedAttribute]
public void set_LangPrefix(string value);
    [CompilerGeneratedAttribute]
public string get_HeaderPrefix();
    [CompilerGeneratedAttribute]
public void set_HeaderPrefix(string value);
    [CompilerGeneratedAttribute]
public bool get_XHtml();
    [CompilerGeneratedAttribute]
public void set_XHtml(bool value);
    [CompilerGeneratedAttribute]
public bool get_Sanitize();
    [CompilerGeneratedAttribute]
public void set_Sanitize(bool value);
    [CompilerGeneratedAttribute]
public bool get_Pedantic();
    [CompilerGeneratedAttribute]
public void set_Pedantic(bool value);
    [CompilerGeneratedAttribute]
public bool get_Mangle();
    [CompilerGeneratedAttribute]
public void set_Mangle(bool value);
    [CompilerGeneratedAttribute]
public bool get_Smartypants();
    [CompilerGeneratedAttribute]
public void set_Smartypants(bool value);
    [CompilerGeneratedAttribute]
public bool get_Breaks();
    [CompilerGeneratedAttribute]
public void set_Breaks(bool value);
    [CompilerGeneratedAttribute]
public bool get_Gfm();
    [CompilerGeneratedAttribute]
public void set_Gfm(bool value);
    [CompilerGeneratedAttribute]
public bool get_Tables();
    [CompilerGeneratedAttribute]
public void set_Tables(bool value);
    [CompilerGeneratedAttribute]
public bool get_SmartLists();
    [CompilerGeneratedAttribute]
public void set_SmartLists(bool value);
    [CompilerGeneratedAttribute]
public bool get_ShouldExportSourceInfo();
    [CompilerGeneratedAttribute]
public void set_ShouldExportSourceInfo(bool value);
    [CompilerGeneratedAttribute]
public bool get_LegacyMode();
    [CompilerGeneratedAttribute]
public void set_LegacyMode(bool value);
    [CompilerGeneratedAttribute]
public bool get_ShouldFixId();
    [CompilerGeneratedAttribute]
public void set_ShouldFixId(bool value);
}
internal static class Microsoft.DocAsCode.MarkdownLite.Regexes : object {
    private static RegexOptions RegexOptionCompiled;
    private static TimeSpan RegexTimeOut;
    private static Regexes();
}
[ExtensionAttribute]
internal static class Microsoft.DocAsCode.MarkdownLite.RegexExtentions : object {
    [ExtensionAttribute]
public static string NotEmpty(Match match, int index1, int index2);
}
public class Microsoft.DocAsCode.MarkdownLite.SourceInfo : ValueType {
    private int _validLineCount;
    [CompilerGeneratedAttribute]
private string <Markdown>k__BackingField;
    [CompilerGeneratedAttribute]
private string <File>k__BackingField;
    [CompilerGeneratedAttribute]
private int <LineNumber>k__BackingField;
    public string Markdown { get; }
    public string File { get; }
    public int LineNumber { get; }
    public int ValidLineCount { get; }
    private SourceInfo(string markdown, string file, int lineNumber, int validLineCount);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public string get_Markdown();
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public string get_File();
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public int get_LineNumber();
    public int get_ValidLineCount();
    public static SourceInfo Create(string markdown, string file);
    public static SourceInfo Create(string markdown, string file, int lineNumber);
    public static SourceInfo Create(string markdown, string file, int lineNumber, int lineCount);
    public SourceInfo Copy(string markdown, int lineOffset);
    private static int GetValidLineCount(string markdown);
    private static int GetValidLineCount(string markdown, int lineCount);
}
public class Microsoft.DocAsCode.MarkdownLite.StringBuffer : object {
    private static int MinArrayLength;
    private static int ShrinkArrayLength;
    public static StringBuffer Empty;
    private String[] _buffer;
    private int _index;
    private StringBuffer(int length);
    private StringBuffer(string value);
    private static StringBuffer();
    public StringBuffer Append(string str);
    public StringBuffer Concat(StringBuffer another);
    private StringBuffer EnsureCapacity(int count);
    public StringBuffer Clone();
    public int GetLength();
    public bool StartsWith(char character);
    public bool StartsWith(string text);
    public bool EndsWith(char character);
    public bool EndsWith(string text);
    public StringBuffer Substring(int startIndex, int maxCount);
    public virtual string ToString();
    public static StringBuffer op_Addition(StringBuffer buffer, string value);
    public static StringBuffer op_Addition(StringBuffer buffer, StringBuffer another);
    public static StringBuffer op_Implicit(string value);
    public static string op_Implicit(StringBuffer buffer);
}
[ExtensionAttribute]
public static class Microsoft.DocAsCode.MarkdownLite.StringHelper : object {
    private static String[] EmptyArray;
    private static StringHelper();
    public static string DecodeURIComponent(string str);
    public static string HtmlEncode(string html);
    public static string HtmlDecode(string html);
    public static string Escape(string html, bool encode);
    public static string Unescape(string html);
    public static string EscapeMarkdown(string text);
    public static string EscapeMarkdownHref(string text);
    [ObsoleteAttribute]
public static string LegacyEscapeMarkdown(string text);
    public static string UnescapeMarkdown(string markdown);
    [ObsoleteAttribute]
public static string LegacyUnescapeMarkdown(string markdown);
    public static string NotEmpty(IList`1<string> source, int index1, int index2);
    [ExtensionAttribute]
public static string ReplaceRegex(string input, Regex pattern, string replacement);
    [ExtensionAttribute]
public static String[] SplitRegex(string input, Regex pattern);
    [ExtensionAttribute]
public static String[] Apply(Regex regex, string src, int index);
    [ExtensionAttribute]
public static String[] Match(string src, Regex regex);
}
public static class Microsoft.DocAsCode.MarkdownLite.TokenHelper : object {
    public static ImmutableArray`1<IMarkdownToken> CreateParagraghs(IMarkdownParser parser, IMarkdownRule rule, ImmutableArray`1<IMarkdownToken> blockTokens, bool wrapParagraph, SourceInfo sourceInfo);
    private static IMarkdownToken GroupTextTokens(IMarkdownParser parser, IMarkdownRule rule, bool wrapParagraph, StringBuffer textContent, SourceInfo si);
    private static TwoPhaseBlockToken CreateTwoPhaseToken(IMarkdownParser parser, IMarkdownRule rule, string markdown, bool wrapParagraph, SourceInfo sourceInfo);
}
public class Microsoft.DocAsCode.MarkdownLite.TwoPhaseBlockToken : object {
    private Func`3<IMarkdownParser, TwoPhaseBlockToken, IMarkdownToken> _extractor;
    [CompilerGeneratedAttribute]
private IMarkdownRule <Rule>k__BackingField;
    [CompilerGeneratedAttribute]
private IMarkdownContext <Context>k__BackingField;
    [CompilerGeneratedAttribute]
private SourceInfo <SourceInfo>k__BackingField;
    public IMarkdownRule Rule { get; }
    public IMarkdownContext Context { get; }
    public SourceInfo SourceInfo { get; }
    public TwoPhaseBlockToken(IMarkdownRule rule, IMarkdownContext context, SourceInfo sourceInfo, Func`3<IMarkdownParser, TwoPhaseBlockToken, IMarkdownToken> extractor);
    public TwoPhaseBlockToken(TwoPhaseBlockToken token, IMarkdownContext context);
    [CompilerGeneratedAttribute]
public sealed virtual IMarkdownRule get_Rule();
    [CompilerGeneratedAttribute]
public sealed virtual IMarkdownContext get_Context();
    [CompilerGeneratedAttribute]
public sealed virtual SourceInfo get_SourceInfo();
    public IMarkdownToken Extract(IMarkdownParser parser);
}
