[CompilerGeneratedAttribute]
[EmbeddedAttribute]
internal class Microsoft.CodeAnalysis.EmbeddedAttribute : Attribute {
}
public class Microsoft.DocAsCode.Metadata.ManagedReference.AllMemberFilterVisitor : object {
    public sealed virtual bool CanVisitApi(ISymbol symbol, bool wantProtectedMember, IFilterVisitor outer);
    public sealed virtual bool CanVisitAttribute(ISymbol symbol, bool wantProtectedMember, IFilterVisitor outer);
    private static bool CanVisitCore(ISymbol symbol, Func`4<ISymbol, bool, IFilterVisitor, bool> visitFunc, bool wantProtectedMember, IFilterVisitor outer);
    private static bool CanVisitCore(INamedTypeSymbol symbol, Func`4<ISymbol, bool, IFilterVisitor, bool> visitFunc, bool wantProtectedMember, IFilterVisitor outer);
    private static bool CanVisitCore(IMethodSymbol symbol, Func`4<ISymbol, bool, IFilterVisitor, bool> visitFunc, bool wantProtectedMember, IFilterVisitor outer);
    private static bool CanVisitCore(IPropertySymbol symbol, Func`4<ISymbol, bool, IFilterVisitor, bool> visitFunc, bool wantProtectedMember, IFilterVisitor outer);
    private static bool CanVisitCore(IEventSymbol symbol, Func`4<ISymbol, bool, IFilterVisitor, bool> visitFunc, bool wantProtectedMember, IFilterVisitor outer);
    private static bool CanVisitCore(IFieldSymbol symbol, Func`4<ISymbol, bool, IFilterVisitor, bool> visitFunc, bool wantProtected, IFilterVisitor outer);
}
public class Microsoft.DocAsCode.Metadata.ManagedReference.CachedFilterVisitor : DelegatingFilterVisitor {
    private Dictionary`2<CachedKey, bool> _cache;
    private Dictionary`2<CachedKey, bool> _attributeCache;
    public CachedFilterVisitor(IFilterVisitor inner);
    protected virtual bool CanVisitApiCore(ISymbol symbol, bool wantProtectedMember, IFilterVisitor outer);
    protected virtual bool CanVisitAttributeCore(ISymbol symbol, bool wantProtectedMember, IFilterVisitor outer);
}
[ExtensionAttribute]
internal static class Microsoft.DocAsCode.Metadata.ManagedReference.CodeAnalysisSymbolExtensions : object {
    [ExtensionAttribute]
public static T FindSymbol(Compilation compilation, T symbol);
    [ExtensionAttribute]
public static ISymbol FindSymbol(INamespaceOrTypeSymbol container, ISymbol symbol);
    [IteratorStateMachineAttribute("Microsoft.DocAsCode.Metadata.ManagedReference.CodeAnalysisSymbolExtensions/<FindCore>d__2")]
private static IEnumerable`1<ISymbol> FindCore(INamespaceOrTypeSymbol container, List`1<string> parts);
    private static List`1<string> GetQualifiedNameList(ISymbol symbol);
}
public class Microsoft.DocAsCode.Metadata.ManagedReference.CompositeYamlModelGenerator : YamlModelGenerator {
    private List`1<SimpleYamlModelGenerator> _generators;
    public CompositeYamlModelGenerator(IEnumerable`1<SimpleYamlModelGenerator> generators);
    public CompositeYamlModelGenerator(SimpleYamlModelGenerator[] generators);
    public virtual void DefaultVisit(ISymbol symbol, MetadataItem item, SymbolVisitorAdapter adapter);
    public virtual void GenerateNamedType(INamedTypeSymbol symbol, MetadataItem item, SymbolVisitorAdapter adapter);
    public virtual void GenerateMethod(IMethodSymbol symbol, MetadataItem item, SymbolVisitorAdapter adapter);
    public virtual void GenerateField(IFieldSymbol symbol, MetadataItem item, SymbolVisitorAdapter adapter);
    public virtual void GenerateProperty(IPropertySymbol symbol, MetadataItem item, SymbolVisitorAdapter adapter);
    public virtual void GenerateEvent(IEventSymbol symbol, MetadataItem item, SymbolVisitorAdapter adapter);
    internal virtual void GenerateReferenceInternal(ISymbol symbol, ReferenceItem reference, SymbolVisitorAdapter adapter, bool asOverload);
    internal virtual void GenerateSyntax(MemberType type, ISymbol symbol, SyntaxDetail syntax, SymbolVisitorAdapter adapter);
    public static CompositeYamlModelGenerator op_Addition(CompositeYamlModelGenerator left, SimpleYamlModelGenerator right);
}
public class Microsoft.DocAsCode.Metadata.ManagedReference.ConfigFilterVisitor : DelegatingFilterVisitor {
    private ConfigFilterRule _configRule;
    public ConfigFilterVisitor(IFilterVisitor inner, string configFile);
    public ConfigFilterVisitor(IFilterVisitor inner, ConfigFilterRule rule);
    protected virtual bool CanVisitApiCore(ISymbol symbol, bool wantProtectedMember, IFilterVisitor outer);
    protected virtual bool CanVisitAttributeCore(ISymbol symbol, bool wantProtectedMember, IFilterVisitor outer);
}
internal class Microsoft.DocAsCode.Metadata.ManagedReference.CSharpNameVisitor : NameVisitor {
    private NameOptions Options;
    public CSharpNameVisitor(NameOptions options);
    public virtual void VisitNamedType(INamedTypeSymbol symbol);
    public virtual void VisitNamespace(INamespaceSymbol symbol);
    public virtual void VisitArrayType(IArrayTypeSymbol symbol);
    public virtual void VisitPointerType(IPointerTypeSymbol symbol);
    public virtual void VisitFunctionPointerType(IFunctionPointerTypeSymbol symbol);
    public virtual void VisitTypeParameter(ITypeParameterSymbol symbol);
    public virtual void VisitMethod(IMethodSymbol symbol);
    public virtual void VisitProperty(IPropertySymbol symbol);
    public virtual void VisitEvent(IEventSymbol symbol);
    public virtual void VisitField(IFieldSymbol symbol);
    public virtual void VisitParameter(IParameterSymbol symbol);
    public virtual void VisitDynamicType(IDynamicTypeSymbol symbol);
    private bool TrySpecialType(INamedTypeSymbol symbol);
    private void WriteGeneric(int typeParameterCount);
    private void WriteGeneric(IReadOnlyList`1<ITypeSymbol> types);
    private void WriteRefKind(RefKind kind, bool isReturn);
    private void WriteUnmanagedCallConv(SignatureCallingConvention callConv);
    private void WriteUnmanagedCallConv(INamedTypeSymbol symbol);
}
public class Microsoft.DocAsCode.Metadata.ManagedReference.CSharpNameVisitorCreator : NameVisitorCreator {
    private NameOptions _options;
    public CSharpNameVisitorCreator(NameOptions options);
    protected virtual NameVisitor Create();
}
public class Microsoft.DocAsCode.Metadata.ManagedReference.CSReferenceItemVisitor : ReferenceItemVisitor {
    private bool _asOverload;
    public CSReferenceItemVisitor(ReferenceItem referenceItem, bool asOverload);
    public virtual void VisitNamespace(INamespaceSymbol symbol);
    public virtual void VisitTypeParameter(ITypeParameterSymbol symbol);
    public virtual void VisitArrayType(IArrayTypeSymbol symbol);
    public virtual void VisitPointerType(IPointerTypeSymbol symbol);
    public virtual void VisitFunctionPointerType(IFunctionPointerTypeSymbol symbol);
    public virtual void VisitMethod(IMethodSymbol symbol);
    public virtual void VisitProperty(IPropertySymbol symbol);
    public virtual void VisitEvent(IEventSymbol symbol);
    public virtual void VisitField(IFieldSymbol symbol);
    public virtual void VisitDynamicType(IDynamicTypeSymbol symbol);
    protected virtual void AddBeginGenericParameter();
    protected virtual void AddEndGenericParameter();
    protected virtual void AddGenericParameterSeparator();
    protected virtual void AddLinkItems(INamedTypeSymbol symbol, bool withGenericeParameter);
}
public class Microsoft.DocAsCode.Metadata.ManagedReference.CSYamlModelGenerator : SimpleYamlModelGenerator {
    private static Regex BracesRegex;
    private static CSYamlModelGenerator();
    public virtual void DefaultVisit(ISymbol symbol, MetadataItem item, SymbolVisitorAdapter adapter);
    public virtual void GenerateNamedType(INamedTypeSymbol symbol, MetadataItem item, SymbolVisitorAdapter adapter);
    public virtual void GenerateMethod(IMethodSymbol symbol, MetadataItem item, SymbolVisitorAdapter adapter);
    public virtual void GenerateField(IFieldSymbol symbol, MetadataItem item, SymbolVisitorAdapter adapter);
    public virtual void GenerateProperty(IPropertySymbol symbol, MetadataItem item, SymbolVisitorAdapter adapter);
    public virtual void GenerateEvent(IEventSymbol symbol, MetadataItem item, SymbolVisitorAdapter adapter);
    protected virtual string GetSyntaxContent(MemberType typeKind, ISymbol symbol, SymbolVisitorAdapter adapter);
    protected virtual void GenerateReference(ISymbol symbol, ReferenceItem reference, SymbolVisitorAdapter adapter, bool asOverload);
    private string GetClassSyntax(INamedTypeSymbol symbol, IFilterVisitor filterVisitor);
    private string GetEnumSyntax(INamedTypeSymbol symbol, IFilterVisitor filterVisitor);
    private string GetInterfaceSyntax(INamedTypeSymbol symbol, IFilterVisitor filterVisitor);
    private string GetStructSyntax(INamedTypeSymbol symbol, IFilterVisitor filterVisitor);
    private string GetDelegateSyntax(INamedTypeSymbol symbol, IFilterVisitor filterVisitor);
    private string GetMethodSyntax(IMethodSymbol symbol, IFilterVisitor filterVisitor);
    private string GetOperatorSyntax(IMethodSymbol symbol, IFilterVisitor filterVisitor);
    private string GetConstructorSyntax(IMethodSymbol symbol, IFilterVisitor filterVisitor);
    private string GetFieldSyntax(IFieldSymbol symbol, IFilterVisitor filterVisitor);
    private string GetEventSyntax(IEventSymbol symbol, IFilterVisitor filterVisitor);
    private string GetPropertySyntax(IPropertySymbol symbol, IFilterVisitor filterVisitor);
    private static SyntaxList`1<AttributeListSyntax> GetAttributes(ISymbol symbol, IFilterVisitor filterVisitor, bool inOneLine);
    private static AttributeSyntax GetAttributeSyntax(AttributeData attr);
    private static string GetMemberName(IMethodSymbol symbol, IFilterVisitor filterVisitor);
    private static string GetMemberName(IEventSymbol symbol, IFilterVisitor filterVisitor);
    private static string GetMemberName(IPropertySymbol symbol, IFilterVisitor filterVisitor);
    private static string GetEiiContainerTypeName(IMethodSymbol symbol, IFilterVisitor filterVisitor);
    private static string GetEiiContainerTypeName(IEventSymbol symbol, IFilterVisitor filterVisitor);
    private static string GetEiiContainerTypeName(IPropertySymbol symbol, IFilterVisitor filterVisitor);
    private static ParameterSyntax GetParameter(IParameterSymbol parameter, IFilterVisitor filterVisitor, bool isThisParameter);
    [IteratorStateMachineAttribute("Microsoft.DocAsCode.Metadata.ManagedReference.CSYamlModelGenerator/<GetParameterModifiers>d__30")]
private static IEnumerable`1<SyntaxToken> GetParameterModifiers(IParameterSymbol parameter, bool isThisParameter);
    private static EqualsValueClauseSyntax GetDefaultValueClause(IParameterSymbol symbol);
    private static EqualsValueClauseSyntax GetDefaultValueClause(IFieldSymbol symbol);
    private static EqualsValueClauseSyntax GetDefaultValueClauseCore(object value, ITypeSymbol type);
    private static ExpressionSyntax GetLiteralExpression(TypedConstant constant);
    private static ExpressionSyntax GetLiteralExpression(object value, ITypeSymbol type);
    private static IEnumerable`1<ExpressionSyntax> GetFlagExpressions(IEnumerable`1<ValueTuple`2<string, object>> flags, object value, INamedTypeSymbol namedType);
    private static IEnumerable`1<ExpressionSyntax> GetFlagExpressions(IEnumerable`1<ValueTuple`2<string, T>> flags, T value, INamedTypeSymbol namedType);
    public static ExpressionSyntax GetLiteralExpressionCore(object value, ITypeSymbol type);
    [IteratorStateMachineAttribute("Microsoft.DocAsCode.Metadata.ManagedReference.CSYamlModelGenerator/<GetTypeParameterConstraints>d__39")]
private static IEnumerable`1<TypeParameterConstraintClauseSyntax> GetTypeParameterConstraints(INamedTypeSymbol symbol);
    [IteratorStateMachineAttribute("Microsoft.DocAsCode.Metadata.ManagedReference.CSYamlModelGenerator/<GetTypeParameterConstraints>d__40")]
private static IEnumerable`1<TypeParameterConstraintClauseSyntax> GetTypeParameterConstraints(IMethodSymbol symbol);
    [IteratorStateMachineAttribute("Microsoft.DocAsCode.Metadata.ManagedReference.CSYamlModelGenerator/<GetTypeParameterConstraint>d__41")]
private static IEnumerable`1<TypeParameterConstraintSyntax> GetTypeParameterConstraint(ITypeParameterSymbol symbol);
    private BaseListSyntax GetBaseTypeList(INamedTypeSymbol symbol);
    private static bool IsSymbolAccessible(ISymbol symbol);
    private BaseListSyntax GetEnumBaseTypeList(INamedTypeSymbol symbol);
    private static TypeParameterListSyntax GetTypeParameters(INamedTypeSymbol symbol);
    private static TypeParameterListSyntax GetTypeParameters(IMethodSymbol symbol);
    private static SyntaxToken GetVarianceToken(ITypeParameterSymbol t);
    [IteratorStateMachineAttribute("Microsoft.DocAsCode.Metadata.ManagedReference.CSYamlModelGenerator/<GetTypeModifiers>d__48")]
private static IEnumerable`1<SyntaxToken> GetTypeModifiers(INamedTypeSymbol symbol);
    [IteratorStateMachineAttribute("Microsoft.DocAsCode.Metadata.ManagedReference.CSYamlModelGenerator/<GetMemberModifiers>d__49")]
private static IEnumerable`1<SyntaxToken> GetMemberModifiers(IMethodSymbol symbol);
    [IteratorStateMachineAttribute("Microsoft.DocAsCode.Metadata.ManagedReference.CSYamlModelGenerator/<GetMemberModifiers>d__50")]
private static IEnumerable`1<SyntaxToken> GetMemberModifiers(IEventSymbol symbol);
    private static bool IsPropertyReadonly(IPropertySymbol property);
    [IteratorStateMachineAttribute("Microsoft.DocAsCode.Metadata.ManagedReference.CSYamlModelGenerator/<GetMemberModifiers>d__52")]
private static IEnumerable`1<SyntaxToken> GetMemberModifiers(IPropertySymbol symbol);
    [IteratorStateMachineAttribute("Microsoft.DocAsCode.Metadata.ManagedReference.CSYamlModelGenerator/<GetMemberModifiers>d__53")]
private static IEnumerable`1<SyntaxToken> GetMemberModifiers(IFieldSymbol symbol);
    private static Nullable`1<SyntaxToken> GetOperatorToken(IMethodSymbol symbol);
    [IteratorStateMachineAttribute("Microsoft.DocAsCode.Metadata.ManagedReference.CSYamlModelGenerator/<GetPropertyAccessors>d__55")]
private static IEnumerable`1<AccessorDeclarationSyntax> GetPropertyAccessors(IPropertySymbol propertySymbol, IFilterVisitor filterVisitor);
    private static AccessorDeclarationSyntax GetPropertyAccessorCore(IPropertySymbol propertySymbol, IMethodSymbol methodSymbol, SyntaxKind kind, SyntaxKind keyword, IFilterVisitor filterVisitor, bool isPropertyReadonly);
    private static string RemoveBraces(string text);
    private static TypeSyntax GetRefType(TypeSyntax typeSyntax, RefKind refKind);
    private static TypeSyntax GetMethodTypeSyntax(IMethodSymbol method);
    private static TypeSyntax GetPropertyTypeSyntax(IPropertySymbol property);
    private static TypeSyntax GetTypeSyntax(ITypeSymbol type);
    private static string GetVisiblity(Accessibility accessibility);
    [CompilerGeneratedAttribute]
internal static ExpressionSyntax <GetFlagExpressions>g__GetFlagExpression|37_4(string flagName, <>c__DisplayClass37_0`1& );
}
public class Microsoft.DocAsCode.Metadata.ManagedReference.DefaultFilterVisitor : object {
    public sealed virtual bool CanVisitApi(ISymbol symbol, bool wantProtectedMember, IFilterVisitor outer);
    public sealed virtual bool CanVisitAttribute(ISymbol symbol, bool wantProtectedMember, IFilterVisitor outer);
    private static bool CanVisitCore(ISymbol symbol, Func`4<ISymbol, bool, IFilterVisitor, bool> visitFunc, bool wantProtectedMember, IFilterVisitor outer);
    private static bool CanVisitCore(INamedTypeSymbol symbol, Func`4<ISymbol, bool, IFilterVisitor, bool> visitFunc, bool wantProtectedMember, IFilterVisitor outer);
    private static bool CanVisitCore(IMethodSymbol symbol, Func`4<ISymbol, bool, IFilterVisitor, bool> visitFunc, bool wantProtectedMember, IFilterVisitor outer);
    private static bool CanVisitCore(IPropertySymbol symbol, Func`4<ISymbol, bool, IFilterVisitor, bool> visitFunc, bool wantProtectedMember, IFilterVisitor outer);
    private static bool CanVisitCore(IEventSymbol symbol, Func`4<ISymbol, bool, IFilterVisitor, bool> visitFunc, bool wantProtectedMember, IFilterVisitor outer);
    private static bool CanVisitCore(IFieldSymbol symbol, Func`4<ISymbol, bool, IFilterVisitor, bool> visitFunc, bool wantProtected, IFilterVisitor outer);
}
public class Microsoft.DocAsCode.Metadata.ManagedReference.DelegatingFilterVisitor : object {
    [CompilerGeneratedAttribute]
private IFilterVisitor <Inner>k__BackingField;
    protected IFilterVisitor Inner { get; private set; }
    public DelegatingFilterVisitor(IFilterVisitor inner);
    [CompilerGeneratedAttribute]
protected IFilterVisitor get_Inner();
    [CompilerGeneratedAttribute]
private void set_Inner(IFilterVisitor value);
    public sealed virtual bool CanVisitApi(ISymbol symbol, bool wantProtectedMember, IFilterVisitor outer);
    public sealed virtual bool CanVisitAttribute(ISymbol symbol, bool wantProtectedMember, IFilterVisitor outer);
    protected virtual bool CanVisitApiCore(ISymbol symbol, bool wantProtectedMember, IFilterVisitor outer);
    protected virtual bool CanVisitAttributeCore(ISymbol symbol, bool wantProtectedMember, IFilterVisitor outer);
}
[ExtensionAttribute]
public static class Microsoft.DocAsCode.Metadata.ManagedReference.FilterVisitorExtensions : object {
    [ExtensionAttribute]
public static IFilterVisitor WithConfig(IFilterVisitor fv, string configFile);
    [ExtensionAttribute]
public static IFilterVisitor WithConfig(IFilterVisitor fv, ConfigFilterRule rule);
    [ExtensionAttribute]
public static IFilterVisitor WithCache(IFilterVisitor fv);
}
public interface Microsoft.DocAsCode.Metadata.ManagedReference.IFilterVisitor {
    public abstract virtual bool CanVisitApi(ISymbol symbol, bool wantProtectedMember, IFilterVisitor outer);
    public abstract virtual bool CanVisitAttribute(ISymbol symbol, bool wantProtectedMember, IFilterVisitor outer);
}
public interface Microsoft.DocAsCode.Metadata.ManagedReference.IRoslynBuildController {
    public abstract virtual Compilation GetCompilation(IInputParameters key);
    public abstract virtual IAssemblySymbol GetAssembly(IInputParameters key);
}
[FlagsAttribute]
public enum Microsoft.DocAsCode.Metadata.ManagedReference.NameOptions : Enum {
    public int value__;
    public static NameOptions None;
    public static NameOptions UseAlias;
    public static NameOptions WithNamespace;
    public static NameOptions WithTypeGenericParameter;
    public static NameOptions WithParameter;
    public static NameOptions WithType;
    public static NameOptions WithMethodGenericParameter;
    public static NameOptions WithGenericParameter;
    public static NameOptions Qualified;
    public static NameOptions All;
}
public abstract class Microsoft.DocAsCode.Metadata.ManagedReference.NameVisitor : SymbolVisitor {
    private StringBuilder sb;
    protected void Append(string text);
    internal string GetTypeName();
}
public abstract class Microsoft.DocAsCode.Metadata.ManagedReference.NameVisitorCreator : object {
    private static CSharpNameVisitorCreator[] _csCreators;
    private static VBNameVisitorCreator[] _vbCreators;
    private static NameVisitorCreator();
    public string GetName(ISymbol symbol);
    protected abstract virtual NameVisitor Create();
    public static NameVisitorCreator GetCSharp(NameOptions option);
    public static NameVisitorCreator GetVB(NameOptions option);
}
public abstract class Microsoft.DocAsCode.Metadata.ManagedReference.ReferenceItemVisitor : SymbolVisitor {
    public static SymbolDisplayFormat ShortFormat;
    public static SymbolDisplayFormat QualifiedFormat;
    public static SymbolDisplayFormat ShortFormatWithoutGenericeParameter;
    public static SymbolDisplayFormat QualifiedFormatWithoutGenericeParameter;
    [CompilerGeneratedAttribute]
private ReferenceItem <ReferenceItem>k__BackingField;
    protected ReferenceItem ReferenceItem { get; private set; }
    protected ReferenceItemVisitor(ReferenceItem referenceItem);
    private static ReferenceItemVisitor();
    [CompilerGeneratedAttribute]
protected ReferenceItem get_ReferenceItem();
    [CompilerGeneratedAttribute]
private void set_ReferenceItem(ReferenceItem value);
    public virtual void VisitNamedType(INamedTypeSymbol symbol);
    protected abstract virtual void AddLinkItems(INamedTypeSymbol symbol, bool withGenericeParameter);
    protected abstract virtual void AddBeginGenericParameter();
    protected abstract virtual void AddGenericParameterSeparator();
    protected abstract virtual void AddEndGenericParameter();
}
internal class Microsoft.DocAsCode.Metadata.ManagedReference.Roslyn.Helpers.EnumOps : object {
    public static bool HasAllFlags(T value, T flags);
    public static T ClearFlags(T value, T flags);
}
public class Microsoft.DocAsCode.Metadata.ManagedReference.RoslynCompilation : AbstractCompilation {
    private Compilation _compilation;
    public Compilation Compilation { get; }
    public RoslynCompilation(Compilation compilation);
    public Compilation get_Compilation();
    public virtual IBuildController GetBuildController();
}
public class Microsoft.DocAsCode.Metadata.ManagedReference.RoslynDocument : AbstractDocument {
    private Document _document;
    public string FilePath { get; }
    public RoslynDocument(Document document);
    public virtual string get_FilePath();
}
internal class Microsoft.DocAsCode.Metadata.ManagedReference.RoslynFilterData : object {
    public static SymbolFilterData GetSymbolFilterData(ISymbol symbol);
    public static AttributeFilterData GetAttributeFilterData(AttributeData attribute);
    private static Nullable`1<ExtendedSymbolKind> GetExtendedSymbolKindFromSymbol(ISymbol symbol);
    private static Nullable`1<ExtendedSymbolKind> GetExtendedSymbolKindFromINamedTypeSymbol(INamedTypeSymbol symbol);
    private static string GetLiteralString(TypedConstant constant);
}
public class Microsoft.DocAsCode.Metadata.ManagedReference.RoslynIntermediateMetadataExtractor : object {
    private IRoslynBuildController _controller;
    public RoslynIntermediateMetadataExtractor(IRoslynBuildController controller);
    public sealed virtual MetadataItem Extract(IInputParameters key);
    internal static MetadataItem GenerateYamlMetadata(Compilation compilation, IAssemblySymbol assembly, ExtractMetadataOptions options);
    public static IReadOnlyDictionary`2<Compilation, IEnumerable`1<IMethodSymbol>> GetAllExtensionMethodsFromCompilation(IEnumerable`1<Compilation> compilations);
    public static IReadOnlyDictionary`2<Compilation, IEnumerable`1<IMethodSymbol>> GetAllExtensionMethodsFromAssembly(Compilation compilation, IEnumerable`1<IAssemblySymbol> assemblies);
    [IteratorStateMachineAttribute("Microsoft.DocAsCode.Metadata.ManagedReference.RoslynIntermediateMetadataExtractor/<GetAllNamespaceMembers>d__6")]
private static IEnumerable`1<INamespaceSymbol> GetAllNamespaceMembers(IAssemblySymbol assembly);
    [IteratorStateMachineAttribute("Microsoft.DocAsCode.Metadata.ManagedReference.RoslynIntermediateMetadataExtractor/<GetExtensionMethodPerNamespace>d__7")]
private static IEnumerable`1<IMethodSymbol> GetExtensionMethodPerNamespace(INamespaceSymbol space);
}
internal class Microsoft.DocAsCode.Metadata.ManagedReference.RoslynMetadataExtractor : object {
    private Compilation _compilation;
    private IAssemblySymbol _assembly;
    public RoslynMetadataExtractor(Compilation compilation, IAssemblySymbol assembly);
    public MetadataItem Extract(ExtractMetadataOptions options);
}
public class Microsoft.DocAsCode.Metadata.ManagedReference.RoslynProject : AbstractProject {
    private Project _project;
    public string FilePath { get; }
    public bool HasDocuments { get; }
    public IEnumerable`1<AbstractDocument> Documents { get; }
    public IEnumerable`1<string> PortableExecutableMetadataReferences { get; }
    public IEnumerable`1<AbstractProject> ProjectReferences { get; }
    public RoslynProject(Project project);
    public virtual string get_FilePath();
    public virtual bool get_HasDocuments();
    public virtual IEnumerable`1<AbstractDocument> get_Documents();
    public virtual IEnumerable`1<string> get_PortableExecutableMetadataReferences();
    public virtual IEnumerable`1<AbstractProject> get_ProjectReferences();
    [AsyncStateMachineAttribute("Microsoft.DocAsCode.Metadata.ManagedReference.RoslynProject/<GetCompilationAsync>d__12")]
public virtual Task`1<AbstractCompilation> GetCompilationAsync();
    [CompilerGeneratedAttribute]
private RoslynProject <get_ProjectReferences>b__11_0(ProjectReference pr);
}
public class Microsoft.DocAsCode.Metadata.ManagedReference.RoslynProjectLoader : object {
    private Lazy`1<MSBuildWorkspace> _workspace;
    public RoslynProjectLoader(Lazy`1<MSBuildWorkspace> workspace);
    public sealed virtual AbstractProject TryLoad(string path, AbstractProjectLoader loader);
}
public class Microsoft.DocAsCode.Metadata.ManagedReference.RoslynSourceFileBuildController : object {
    private Compilation _compilation;
    private IAssemblySymbol _assembly;
    public RoslynSourceFileBuildController(Compilation compilation, IAssemblySymbol assembly);
    public sealed virtual MetadataItem ExtractMetadata(IInputParameters parameters);
    public sealed virtual IAssemblySymbol GetAssembly(IInputParameters key);
    public sealed virtual Compilation GetCompilation(IInputParameters key);
}
public abstract class Microsoft.DocAsCode.Metadata.ManagedReference.SimpleYamlModelGenerator : YamlModelGenerator {
    public static SymbolDisplayFormat ShortFormat;
    public static SymbolDisplayFormat QualifiedFormat;
    [CompilerGeneratedAttribute]
private SyntaxLanguage <Language>k__BackingField;
    public SyntaxLanguage Language { get; private set; }
    protected SimpleYamlModelGenerator(SyntaxLanguage language);
    private static SimpleYamlModelGenerator();
    [CompilerGeneratedAttribute]
public SyntaxLanguage get_Language();
    [CompilerGeneratedAttribute]
private void set_Language(SyntaxLanguage value);
    protected abstract virtual string GetSyntaxContent(MemberType typeKind, ISymbol symbol, SymbolVisitorAdapter adapter);
    protected abstract virtual void GenerateReference(ISymbol symbol, ReferenceItem reference, SymbolVisitorAdapter adapter, bool asOverload);
    internal sealed virtual void GenerateSyntax(MemberType type, ISymbol symbol, SyntaxDetail syntax, SymbolVisitorAdapter adapter);
    internal sealed virtual void GenerateReferenceInternal(ISymbol symbol, ReferenceItem reference, SymbolVisitorAdapter adapter, bool asOverload);
    public static CompositeYamlModelGenerator op_Addition(SimpleYamlModelGenerator left, SimpleYamlModelGenerator right);
}
internal class Microsoft.DocAsCode.Metadata.ManagedReference.SpecIdCoreVisitor : SymbolVisitor`1<string> {
    public static SpecIdCoreVisitor Instance;
    private static SpecIdCoreVisitor();
    public virtual string DefaultVisit(ISymbol symbol);
    public virtual string VisitPointerType(IPointerTypeSymbol symbol);
    public virtual string VisitArrayType(IArrayTypeSymbol symbol);
    public virtual string VisitTypeParameter(ITypeParameterSymbol symbol);
}
internal class Microsoft.DocAsCode.Metadata.ManagedReference.SpecIdHelper : object {
    private static Regex TypeParameterRegex;
    private static Regex MethodParameterRegex;
    private static SpecIdHelper();
    public static string GetSpecId(ISymbol symbol, IReadOnlyList`1<string> typeGenericParameters, IReadOnlyList`1<string> methodGenericParameters);
    private static string SpecMethodGenericParameter(IMethodSymbol symbol, string id);
    private static string SpecTypeGenericParameter(IReadOnlyList`1<string> names, string id);
    private static string SpecMethodGenericParameter(IReadOnlyList`1<string> names, string id);
    private static string SpecExtensionMethodReceiverType(IMethodSymbol symbol, string id);
}
public class Microsoft.DocAsCode.Metadata.ManagedReference.SymbolVisitorAdapter : SymbolVisitor`1<MetadataItem> {
    private static Regex MemberSigRegex;
    private static IReadOnlyList`1<string> EmptyListOfString;
    private YamlModelGenerator _generator;
    private Dictionary`2<string, ReferenceItem> _references;
    private bool _preserveRawInlineComments;
    private IReadOnlyDictionary`2<Compilation, IEnumerable`1<IMethodSymbol>> _extensionMethods;
    private Compilation _currentCompilation;
    private CompilationReference _currentCompilationRef;
    private string _codeSourceBasePath;
    [CompilerGeneratedAttribute]
private SyntaxLanguage <Language>k__BackingField;
    [CompilerGeneratedAttribute]
private IFilterVisitor <FilterVisitor>k__BackingField;
    public SyntaxLanguage Language { get; private set; }
    public IFilterVisitor FilterVisitor { get; private set; }
    public SymbolVisitorAdapter(YamlModelGenerator generator, SyntaxLanguage language, Compilation compilation, ExtractMetadataOptions options);
    private static SymbolVisitorAdapter();
    [CompilerGeneratedAttribute]
public SyntaxLanguage get_Language();
    [CompilerGeneratedAttribute]
private void set_Language(SyntaxLanguage value);
    [CompilerGeneratedAttribute]
public IFilterVisitor get_FilterVisitor();
    [CompilerGeneratedAttribute]
private void set_FilterVisitor(IFilterVisitor value);
    public virtual MetadataItem DefaultVisit(ISymbol symbol);
    public virtual MetadataItem VisitAssembly(IAssemblySymbol symbol);
    public virtual MetadataItem VisitNamespace(INamespaceSymbol symbol);
    public virtual MetadataItem VisitNamedType(INamedTypeSymbol symbol);
    public virtual MetadataItem VisitMethod(IMethodSymbol symbol);
    public virtual MetadataItem VisitField(IFieldSymbol symbol);
    public virtual MetadataItem VisitEvent(IEventSymbol symbol);
    public virtual MetadataItem VisitProperty(IPropertySymbol symbol);
    public string AddReference(ISymbol symbol);
    public string AddReference(string id, string commentId);
    public string AddOverloadReference(ISymbol symbol);
    public string AddSpecReference(ISymbol symbol, IReadOnlyList`1<string> typeGenericParameters, IReadOnlyList`1<string> methodGenericParameters);
    private MemberType GetMemberTypeFromSymbol(ISymbol symbol);
    private MetadataItem GetYamlItem(ISymbol symbol);
    private List`1<MetadataItem> VisitDescendants(IEnumerable`1<T> children, Func`2<T, IEnumerable`1<T>> getChildren, Func`2<T, bool> filter);
    private bool IsInheritable(ISymbol memberSymbol);
    private void GenerateInheritance(INamedTypeSymbol symbol, MetadataItem item);
    private void AddMemberImplements(ISymbol symbol, MetadataItem item, IReadOnlyList`1<string> typeGenericParameters);
    private void AddMemberImplements(IMethodSymbol symbol, MetadataItem item, IReadOnlyList`1<string> typeGenericParameters, IReadOnlyList`1<string> methodGenericParameters);
    private void GenerateExtensionMethods(INamedTypeSymbol symbol, MetadataItem item);
    private void AddInheritedMembers(INamedTypeSymbol symbol, INamedTypeSymbol type, Dictionary`2<string, string> dict, IReadOnlyList`1<string> typeParamterNames);
    private void AddMethodSyntax(IMethodSymbol symbol, MetadataItem result, IReadOnlyList`1<string> typeGenericParameters, IReadOnlyList`1<string> methodGenericParameters);
    private ITripleSlashCommentParserContext GetTripleSlashCommentParserContext(MetadataItem item, bool preserve);
    private List`1<AttributeInfo> GetAttributeInfo(ImmutableArray`1<AttributeData> attributes);
    private List`1<ArgumentInfo> GetArguments(AttributeData attr);
    private ArgumentInfo GetArgumentInfo(TypedConstant arg);
    private object GetConstantValueForArgumentInfo(TypedConstant arg);
    private List`1<NamedArgumentInfo> GetNamedArguments(AttributeData attr);
    private NamedArgumentInfo GetNamedArgumentInfo(KeyValuePair`2<string, TypedConstant> pair);
    private Action`2<string, string> GetAddReferenceDelegate(MetadataItem item);
    [CompilerGeneratedAttribute]
private IEnumerable`1<IMethodSymbol> <.ctor>b__9_1(KeyValuePair`2<Compilation, IEnumerable`1<IMethodSymbol>> p);
    [CompilerGeneratedAttribute]
private bool <.ctor>b__9_2(IMethodSymbol e);
    [CompilerGeneratedAttribute]
private bool <VisitAssembly>b__19_1(INamespaceSymbol ns);
    [CompilerGeneratedAttribute]
private bool <VisitAssembly>b__19_2(INamedTypeSymbol t);
    [CompilerGeneratedAttribute]
private bool <GenerateInheritance>b__34_0(INamedTypeSymbol t);
    [CompilerGeneratedAttribute]
private bool <GetAttributeInfo>b__41_2(AttributeData attr);
    [CompilerGeneratedAttribute]
private AttributeInfo <GetAttributeInfo>b__41_3(AttributeData attr);
    [CompilerGeneratedAttribute]
private NamedArgumentInfo <GetNamedArguments>b__45_0(KeyValuePair`2<string, TypedConstant> pair);
}
internal class Microsoft.DocAsCode.Metadata.ManagedReference.TypeGenericParameterNameVisitor : SymbolVisitor`1<List`1<string>> {
    public static TypeGenericParameterNameVisitor Instance;
    private static TypeGenericParameterNameVisitor();
    public virtual List`1<string> DefaultVisit(ISymbol symbol);
    public virtual List`1<string> VisitNamedType(INamedTypeSymbol symbol);
    public virtual List`1<string> VisitEvent(IEventSymbol symbol);
    public virtual List`1<string> VisitField(IFieldSymbol symbol);
    public virtual List`1<string> VisitMethod(IMethodSymbol symbol);
    public virtual List`1<string> VisitProperty(IPropertySymbol symbol);
    public virtual List`1<string> VisitTypeParameter(ITypeParameterSymbol symbol);
}
internal class Microsoft.DocAsCode.Metadata.ManagedReference.VBNameVisitor : NameVisitor {
    private NameOptions Options;
    public VBNameVisitor(NameOptions options);
    public virtual void VisitNamedType(INamedTypeSymbol symbol);
    public virtual void VisitNamespace(INamespaceSymbol symbol);
    public virtual void VisitArrayType(IArrayTypeSymbol symbol);
    public virtual void VisitPointerType(IPointerTypeSymbol symbol);
    public virtual void VisitTypeParameter(ITypeParameterSymbol symbol);
    public virtual void VisitMethod(IMethodSymbol symbol);
    public virtual void VisitProperty(IPropertySymbol symbol);
    public virtual void VisitEvent(IEventSymbol symbol);
    public virtual void VisitField(IFieldSymbol symbol);
    public virtual void VisitParameter(IParameterSymbol symbol);
    public virtual void VisitDynamicType(IDynamicTypeSymbol symbol);
    private bool TrySpecialType(INamedTypeSymbol symbol);
    private void WriteGeneric(int typeParameterCount);
    private void WriteGeneric(IReadOnlyList`1<ITypeSymbol> types);
}
public class Microsoft.DocAsCode.Metadata.ManagedReference.VBNameVisitorCreator : NameVisitorCreator {
    private NameOptions _options;
    public VBNameVisitorCreator(NameOptions options);
    protected virtual NameVisitor Create();
}
public class Microsoft.DocAsCode.Metadata.ManagedReference.VBReferenceItemVisitor : ReferenceItemVisitor {
    private bool _asOverload;
    public VBReferenceItemVisitor(ReferenceItem referenceItem, bool asOverload);
    public virtual void VisitNamespace(INamespaceSymbol symbol);
    public virtual void VisitTypeParameter(ITypeParameterSymbol symbol);
    public virtual void VisitArrayType(IArrayTypeSymbol symbol);
    public virtual void VisitPointerType(IPointerTypeSymbol symbol);
    public virtual void VisitFunctionPointerType(IFunctionPointerTypeSymbol symbol);
    public virtual void VisitMethod(IMethodSymbol symbol);
    public virtual void VisitProperty(IPropertySymbol symbol);
    public virtual void VisitEvent(IEventSymbol symbol);
    public virtual void VisitField(IFieldSymbol symbol);
    protected virtual void AddBeginGenericParameter();
    protected virtual void AddEndGenericParameter();
    protected virtual void AddGenericParameterSeparator();
    protected virtual void AddLinkItems(INamedTypeSymbol symbol, bool withGenericParameter);
}
public class Microsoft.DocAsCode.Metadata.ManagedReference.VBYamlModelGenerator : SimpleYamlModelGenerator {
    private static Regex EndRegex;
    private static VBYamlModelGenerator();
    public virtual void DefaultVisit(ISymbol symbol, MetadataItem item, SymbolVisitorAdapter adapter);
    public virtual void GenerateNamedType(INamedTypeSymbol symbol, MetadataItem item, SymbolVisitorAdapter adapter);
    public virtual void GenerateMethod(IMethodSymbol symbol, MetadataItem item, SymbolVisitorAdapter adapter);
    public virtual void GenerateField(IFieldSymbol symbol, MetadataItem item, SymbolVisitorAdapter adapter);
    public virtual void GenerateProperty(IPropertySymbol symbol, MetadataItem item, SymbolVisitorAdapter adapter);
    public virtual void GenerateEvent(IEventSymbol symbol, MetadataItem item, SymbolVisitorAdapter adapter);
    protected virtual string GetSyntaxContent(MemberType typeKind, ISymbol symbol, SymbolVisitorAdapter adapter);
    protected virtual void GenerateReference(ISymbol symbol, ReferenceItem reference, SymbolVisitorAdapter adapter, bool asOverload);
    private string GetClassSyntax(INamedTypeSymbol symbol, IFilterVisitor filterVisitor);
    private string GetEnumSyntax(INamedTypeSymbol symbol, IFilterVisitor filterVisitor);
    private string GetInterfaceSyntax(INamedTypeSymbol symbol, IFilterVisitor filterVisitor);
    private string GetStructSyntax(INamedTypeSymbol symbol, IFilterVisitor filterVisitor);
    private string GetDelegateSyntax(INamedTypeSymbol symbol, IFilterVisitor filterVisitor);
    private string GetMethodSyntax(IMethodSymbol symbol, IFilterVisitor filterVisitor);
    private string GetOperatorSyntax(IMethodSymbol symbol, IFilterVisitor filterVisitor);
    private string GetConstructorSyntax(IMethodSymbol symbol, IFilterVisitor filterVisitor);
    private string GetFieldSyntax(IFieldSymbol symbol, IFilterVisitor filterVisitor);
    private string GetEventSyntax(IEventSymbol symbol, IFilterVisitor filterVisitor);
    private string GetPropertySyntax(IPropertySymbol symbol, IFilterVisitor filterVisitor);
    private static SyntaxList`1<AttributeListSyntax> GetAttributes(ISymbol symbol, IFilterVisitor filterVisitor, bool inOneLine, bool isExtensionMethod);
    private static AttributeSyntax GetAttributeSyntax(AttributeData attr);
    [IteratorStateMachineAttribute("Microsoft.DocAsCode.Metadata.ManagedReference.VBYamlModelGenerator/<GetTypeModifiers>d__23")]
private static IEnumerable`1<SyntaxToken> GetTypeModifiers(INamedTypeSymbol symbol);
    [IteratorStateMachineAttribute("Microsoft.DocAsCode.Metadata.ManagedReference.VBYamlModelGenerator/<GetMemberModifiers>d__24")]
private IEnumerable`1<SyntaxToken> GetMemberModifiers(IMethodSymbol symbol);
    [IteratorStateMachineAttribute("Microsoft.DocAsCode.Metadata.ManagedReference.VBYamlModelGenerator/<GetMemberModifiers>d__25")]
private IEnumerable`1<SyntaxToken> GetMemberModifiers(IFieldSymbol symbol);
    [IteratorStateMachineAttribute("Microsoft.DocAsCode.Metadata.ManagedReference.VBYamlModelGenerator/<GetMemberModifiers>d__26")]
private IEnumerable`1<SyntaxToken> GetMemberModifiers(IEventSymbol symbol);
    [IteratorStateMachineAttribute("Microsoft.DocAsCode.Metadata.ManagedReference.VBYamlModelGenerator/<GetMemberModifiers>d__27")]
private IEnumerable`1<SyntaxToken> GetMemberModifiers(IPropertySymbol symbol);
    private static TypeParameterListSyntax GetTypeParameters(INamedTypeSymbol symbol);
    private static TypeParameterListSyntax GetTypeParameters(IMethodSymbol symbol);
    private static SyntaxToken GetVarianceToken(ITypeParameterSymbol t);
    private static TypeParameterConstraintClauseSyntax GetTypeParameterConstraintClauseSyntax(ITypeParameterSymbol symbol);
    [IteratorStateMachineAttribute("Microsoft.DocAsCode.Metadata.ManagedReference.VBYamlModelGenerator/<GetConstraintSyntaxes>d__32")]
private static IEnumerable`1<ConstraintSyntax> GetConstraintSyntaxes(ITypeParameterSymbol symbol);
    private SyntaxList`1<InheritsStatementSyntax> GetInheritsList(INamedTypeSymbol symbol);
    private SyntaxList`1<ImplementsStatementSyntax> GetImplementsList(INamedTypeSymbol symbol);
    private static bool IsSymbolAccessible(ISymbol symbol);
    private AsClauseSyntax GetEnumUnderlyingType(INamedTypeSymbol symbol);
    private ParameterListSyntax GetParamerterList(IMethodSymbol symbol);
    private ParameterListSyntax GetParamerterList(IPropertySymbol symbol);
    [IteratorStateMachineAttribute("Microsoft.DocAsCode.Metadata.ManagedReference.VBYamlModelGenerator/<GetParameterModifiers>d__39")]
private IEnumerable`1<SyntaxToken> GetParameterModifiers(IParameterSymbol symbol);
    private ImplementsClauseSyntax GetImplementsClause(IMethodSymbol symbol, IFilterVisitor filterVisitor);
    private ImplementsClauseSyntax GetImplementsClause(IEventSymbol symbol, IFilterVisitor filterVisitor);
    private ImplementsClauseSyntax GetImplementsClause(IPropertySymbol symbol, IFilterVisitor filterVisitor);
    private EqualsValueSyntax GetDefaultValue(IParameterSymbol symbol);
    private EqualsValueSyntax GetDefaultValue(IFieldSymbol symbol);
    private static EqualsValueSyntax GetDefaultValueCore(object value, ITypeSymbol type);
    private static ExpressionSyntax GetLiteralExpression(TypedConstant constant);
    private static ExpressionSyntax GetLiteralExpression(object value, ITypeSymbol type);
    private static IEnumerable`1<ExpressionSyntax> GetFlagExpressions(IEnumerable`1<ValueTuple`2<string, object>> flags, object value, INamedTypeSymbol namedType);
    private static IEnumerable`1<ExpressionSyntax> GetFlagExpressions(IEnumerable`1<ValueTuple`2<string, T>> flags, T value, INamedTypeSymbol namedType);
    private static ExpressionSyntax GetLiteralExpressionCore(object value, ITypeSymbol type);
    private SimpleAsClauseSyntax GetReturnAsClause(IMethodSymbol symbol);
    private static Nullable`1<SyntaxToken> GetOperatorToken(IMethodSymbol symbol);
    private static TypeSyntax GetTypeSyntax(ITypeSymbol type);
    private static SyntaxToken GetIdentifier(ITypeSymbol type);
    private static NameSyntax GetQualifiedNameSyntax(ITypeSymbol type);
    private static string RemoveEnd(string code);
    private static string GetVisiblity(Accessibility accessibility);
    [CompilerGeneratedAttribute]
private ParameterSyntax <GetParamerterList>b__37_0(IParameterSymbol p);
    [CompilerGeneratedAttribute]
private ParameterSyntax <GetParamerterList>b__38_0(IParameterSymbol p);
    [CompilerGeneratedAttribute]
internal static ExpressionSyntax <GetFlagExpressions>g__GetFlagExpression|49_4(string flagName, <>c__DisplayClass49_0`1& );
}
public static class Microsoft.DocAsCode.Metadata.ManagedReference.VisitorHelper : object {
    [CompilerGeneratedAttribute]
private static string <GlobalNamespaceId>k__BackingField;
    private static Regex GenericMethodPostFix;
    public static string GlobalNamespaceId { get; public set; }
    private static VisitorHelper();
    [CompilerGeneratedAttribute]
public static string get_GlobalNamespaceId();
    [CompilerGeneratedAttribute]
public static void set_GlobalNamespaceId(string value);
    public static void FeedComments(MetadataItem item, ITripleSlashCommentParserContext context);
    public static string GetId(ISymbol symbol);
    private static string GetDocumentationCommentId(ISymbol symbol);
    public static string GetCommentId(ISymbol symbol);
    public static string GetOverloadId(ISymbol symbol);
    public static string GetOverloadIdBody(ISymbol symbol);
    public static ApiParameter GetParameterDescription(ISymbol symbol, MetadataItem item, string id, bool isReturn, ITripleSlashCommentParserContext context);
    public static ApiParameter GetTypeParameterDescription(ITypeParameterSymbol symbol, MetadataItem item, ITripleSlashCommentParserContext context);
    public static SourceDetail GetSourceDetail(ISymbol symbol);
    public static MemberType GetMemberTypeFromTypeKind(TypeKind typeKind);
    public static bool InGlobalNamespace(ISymbol symbol);
}
public abstract class Microsoft.DocAsCode.Metadata.ManagedReference.YamlModelGenerator : object {
    public virtual void DefaultVisit(ISymbol symbol, MetadataItem item, SymbolVisitorAdapter adapter);
    public virtual void GenerateNamedType(INamedTypeSymbol symbol, MetadataItem item, SymbolVisitorAdapter adapter);
    public virtual void GenerateMethod(IMethodSymbol symbol, MetadataItem item, SymbolVisitorAdapter adapter);
    public virtual void GenerateField(IFieldSymbol symbol, MetadataItem item, SymbolVisitorAdapter adapter);
    public virtual void GenerateEvent(IEventSymbol symbol, MetadataItem item, SymbolVisitorAdapter adapter);
    public virtual void GenerateProperty(IPropertySymbol symbol, MetadataItem item, SymbolVisitorAdapter adapter);
    internal string AddReference(ISymbol symbol, Dictionary`2<string, ReferenceItem> references, SymbolVisitorAdapter adapter);
    internal string AddReference(string id, string commentId, Dictionary`2<string, ReferenceItem> references);
    internal string AddOverloadReference(ISymbol symbol, Dictionary`2<string, ReferenceItem> references, SymbolVisitorAdapter adapter);
    internal string AddSpecReference(ISymbol symbol, IReadOnlyList`1<string> typeGenericParameters, IReadOnlyList`1<string> methodGenericParameters, Dictionary`2<string, ReferenceItem> references, SymbolVisitorAdapter adapter);
    private string GetReferenceParent(ISymbol symbol, IReadOnlyList`1<string> typeGenericParameters, IReadOnlyList`1<string> methodGenericParameters, Dictionary`2<string, ReferenceItem> references, SymbolVisitorAdapter adapter);
    private static bool IsGlobalNamespace(ISymbol symbol);
    internal abstract virtual void GenerateReferenceInternal(ISymbol symbol, ReferenceItem reference, SymbolVisitorAdapter adapter, bool asOverload);
    internal abstract virtual void GenerateSyntax(MemberType type, ISymbol symbol, SyntaxDetail syntax, SymbolVisitorAdapter adapter);
}
[CompilerGeneratedAttribute]
[EmbeddedAttribute]
internal class System.Runtime.CompilerServices.IsUnmanagedAttribute : Attribute {
}
