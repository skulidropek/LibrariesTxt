[CompilerGeneratedAttribute]
[EmbeddedAttribute]
internal class Microsoft.CodeAnalysis.EmbeddedAttribute : Attribute {
}
public enum Newtonsoft.Json.Schema.ErrorType : Enum {
    public int value__;
    [EnumMemberAttribute]
public static ErrorType None;
    [EnumMemberAttribute]
public static ErrorType MultipleOf;
    [EnumMemberAttribute]
public static ErrorType Maximum;
    [EnumMemberAttribute]
public static ErrorType Minimum;
    [EnumMemberAttribute]
public static ErrorType MaximumLength;
    [EnumMemberAttribute]
public static ErrorType MinimumLength;
    [EnumMemberAttribute]
public static ErrorType Pattern;
    [EnumMemberAttribute]
public static ErrorType AdditionalItems;
    [EnumMemberAttribute]
public static ErrorType Items;
    [EnumMemberAttribute]
public static ErrorType MaximumItems;
    [EnumMemberAttribute]
public static ErrorType MinimumItems;
    [EnumMemberAttribute]
public static ErrorType UniqueItems;
    [EnumMemberAttribute]
public static ErrorType MaximumProperties;
    [EnumMemberAttribute]
public static ErrorType MinimumProperties;
    [EnumMemberAttribute]
public static ErrorType Required;
    [EnumMemberAttribute]
public static ErrorType AdditionalProperties;
    [EnumMemberAttribute]
public static ErrorType Dependencies;
    [EnumMemberAttribute]
public static ErrorType Enum;
    [EnumMemberAttribute]
public static ErrorType Type;
    [EnumMemberAttribute]
public static ErrorType AllOf;
    [EnumMemberAttribute]
public static ErrorType AnyOf;
    [EnumMemberAttribute]
public static ErrorType OneOf;
    [EnumMemberAttribute]
public static ErrorType Not;
    [EnumMemberAttribute]
public static ErrorType Format;
    [EnumMemberAttribute]
public static ErrorType Id;
    [EnumMemberAttribute]
public static ErrorType PatternProperties;
    [EnumMemberAttribute]
public static ErrorType Validator;
    [EnumMemberAttribute]
public static ErrorType Valid;
    [EnumMemberAttribute]
public static ErrorType Const;
    [EnumMemberAttribute]
public static ErrorType Contains;
    [EnumMemberAttribute]
public static ErrorType ContentEncoding;
    [EnumMemberAttribute]
public static ErrorType ContentMediaType;
    [EnumMemberAttribute]
public static ErrorType Then;
    [EnumMemberAttribute]
public static ErrorType Else;
    [EnumMemberAttribute]
public static ErrorType MaximumContains;
    [EnumMemberAttribute]
public static ErrorType MinimumContains;
    [EnumMemberAttribute]
public static ErrorType UnevaluatedItems;
    [EnumMemberAttribute]
public static ErrorType UnevaluatedProperties;
    [EnumMemberAttribute]
public static ErrorType Ref;
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Newtonsoft.Json.Schema.ExternalSchema : object {
    [CompilerGeneratedAttribute]
private Uri <Uri>k__BackingField;
    [CompilerGeneratedAttribute]
private JSchema <Schema>k__BackingField;
    public Uri Uri { get; }
    public JSchema Schema { get; }
    public ExternalSchema(Uri uri, JSchema schema);
    public ExternalSchema(JSchema schema);
    [CompilerGeneratedAttribute]
public Uri get_Uri();
    [CompilerGeneratedAttribute]
public JSchema get_Schema();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public abstract class Newtonsoft.Json.Schema.Generation.JSchemaGenerationProvider : object {
    public abstract virtual JSchema GetSchema(JSchemaTypeGenerationContext context);
    public virtual bool CanGenerateSchema(JSchemaTypeGenerationContext context);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[AttributeUsageAttribute("3484")]
public class Newtonsoft.Json.Schema.Generation.JSchemaGenerationProviderAttribute : Attribute {
    private Type _providerType;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private Object[] _providerParameters;
    public Type ProviderType { get; }
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public Object[] ProviderParameters { get; }
    public JSchemaGenerationProviderAttribute(Type providerType);
    public JSchemaGenerationProviderAttribute(Type providerType, Object[] providerParameters);
    public Type get_ProviderType();
    public Object[] get_ProviderParameters();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Newtonsoft.Json.Schema.Generation.JSchemaGenerator : object {
    private static IContractResolver _defaultInstance;
    [NullableAttribute("2")]
private IContractResolver _contractResolver;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal List`1<JSchemaGenerationProvider> _generationProviders;
    private SchemaReferenceHandling _schemaReferenceHandling;
    private Required _defaultRequired;
    [CompilerGeneratedAttribute]
private SchemaIdGenerationHandling <SchemaIdGenerationHandling>k__BackingField;
    [CompilerGeneratedAttribute]
private SchemaPropertyOrderHandling <SchemaPropertyOrderHandling>k__BackingField;
    [CompilerGeneratedAttribute]
private SchemaLocationHandling <SchemaLocationHandling>k__BackingField;
    private static IContractResolver DefaultInstance { get; }
    public SchemaIdGenerationHandling SchemaIdGenerationHandling { get; public set; }
    public SchemaPropertyOrderHandling SchemaPropertyOrderHandling { get; public set; }
    public SchemaLocationHandling SchemaLocationHandling { get; public set; }
    public SchemaReferenceHandling SchemaReferenceHandling { get; public set; }
    public Required DefaultRequired { get; public set; }
    public IList`1<JSchemaGenerationProvider> GenerationProviders { get; }
    public IContractResolver ContractResolver { get; public set; }
    private static JSchemaGenerator();
    private static IContractResolver get_DefaultInstance();
    [CompilerGeneratedAttribute]
public virtual SchemaIdGenerationHandling get_SchemaIdGenerationHandling();
    [CompilerGeneratedAttribute]
public virtual void set_SchemaIdGenerationHandling(SchemaIdGenerationHandling value);
    [CompilerGeneratedAttribute]
public virtual SchemaPropertyOrderHandling get_SchemaPropertyOrderHandling();
    [CompilerGeneratedAttribute]
public virtual void set_SchemaPropertyOrderHandling(SchemaPropertyOrderHandling value);
    [CompilerGeneratedAttribute]
public virtual SchemaLocationHandling get_SchemaLocationHandling();
    [CompilerGeneratedAttribute]
public virtual void set_SchemaLocationHandling(SchemaLocationHandling value);
    public virtual SchemaReferenceHandling get_SchemaReferenceHandling();
    public virtual void set_SchemaReferenceHandling(SchemaReferenceHandling value);
    public virtual Required get_DefaultRequired();
    public virtual void set_DefaultRequired(Required value);
    public virtual IList`1<JSchemaGenerationProvider> get_GenerationProviders();
    public virtual IContractResolver get_ContractResolver();
    public virtual void set_ContractResolver(IContractResolver value);
    public virtual JSchema Generate(Type type);
    public virtual JSchema Generate(Type type, bool rootSchemaNullable);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Newtonsoft.Json.Schema.Generation.JSchemaGeneratorInternal : object {
    internal JSchemaGenerator _generator;
    private List`1<TypeSchema> _typeSchemas;
    public JSchemaGeneratorInternal(JSchemaGenerator generator);
    public JSchema Generate(Type type, Required required);
    private string GetTypeName(Type type);
    public JSchema GenerateSubschema(Type type, Required required, JSchemaGenerationProvider currentGenerationProvider);
    [NullableContextAttribute("2")]
private string GetTitle(Type type, JsonProperty memberProperty);
    [NullableContextAttribute("2")]
private string GetDescription(Type type, JsonProperty memberProperty);
    private Uri GetTypeId(Type type, bool explicitOnly);
    [NullableContextAttribute("2")]
private JSchemaGenerationProvider ResolveTypeProvider(Type nonNullableType, JsonProperty memberProperty);
    [NullableContextAttribute("2")]
private JSchema GenerateInternal(Type type, Nullable`1<Required> valueRequired, JsonProperty memberProperty, JsonContainerContract container, JSchemaGenerationProvider currentGenerationProvider);
    private TypeSchema GetCachedSchema(TypeSchemaKey key);
    private bool ShouldReferenceType(JsonContract contract);
    private TypeSchemaKey CreateKey(Required valueRequired, JsonProperty memberProperty, JsonContract contract);
    private void PopulateSchema(JSchema schema, JsonContract contract, JsonProperty memberProperty, Required valueRequired);
    private void PopulatePrimativeSchema(JSchema schema, JsonContract contract, JsonProperty memberProperty, Required valueRequired);
    private JSchemaType AddNullType(JSchemaType type, Required valueRequired);
    private bool HasFlag(DefaultValueHandling value, DefaultValueHandling flag);
    private void GenerateObjectSchema(JSchema schema, Type type, JsonObjectContract contract);
    internal static bool HasFlag(Nullable`1<JSchemaType> value, JSchemaType flag);
    private JSchemaType GetJSchemaType(Type type, Required valueRequired);
    private Type GetNonNullableUnderlyingType(JsonContract contract);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Newtonsoft.Json.Schema.Generation.JSchemaGeneratorProxy : JSchemaGenerator {
    private JSchemaGenerator _generator;
    private JSchemaGeneratorInternal _generatorInternal;
    [NullableAttribute("2")]
private JSchemaGenerationProvider _generationProvider;
    public IContractResolver ContractResolver { get; public set; }
    public Required DefaultRequired { get; public set; }
    public IList`1<JSchemaGenerationProvider> GenerationProviders { get; }
    public SchemaIdGenerationHandling SchemaIdGenerationHandling { get; public set; }
    public SchemaLocationHandling SchemaLocationHandling { get; public set; }
    public SchemaPropertyOrderHandling SchemaPropertyOrderHandling { get; public set; }
    public SchemaReferenceHandling SchemaReferenceHandling { get; public set; }
    public JSchemaGeneratorProxy(JSchemaGeneratorInternal generatorInternal, JSchemaGenerationProvider generationProvider);
    public virtual IContractResolver get_ContractResolver();
    public virtual void set_ContractResolver(IContractResolver value);
    public virtual Required get_DefaultRequired();
    public virtual void set_DefaultRequired(Required value);
    public virtual IList`1<JSchemaGenerationProvider> get_GenerationProviders();
    public virtual SchemaIdGenerationHandling get_SchemaIdGenerationHandling();
    public virtual void set_SchemaIdGenerationHandling(SchemaIdGenerationHandling value);
    public virtual SchemaLocationHandling get_SchemaLocationHandling();
    public virtual void set_SchemaLocationHandling(SchemaLocationHandling value);
    public virtual SchemaPropertyOrderHandling get_SchemaPropertyOrderHandling();
    public virtual void set_SchemaPropertyOrderHandling(SchemaPropertyOrderHandling value);
    public virtual SchemaReferenceHandling get_SchemaReferenceHandling();
    public virtual void set_SchemaReferenceHandling(SchemaReferenceHandling value);
    public virtual JSchema Generate(Type type);
    public virtual JSchema Generate(Type type, bool rootSchemaNullable);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
public class Newtonsoft.Json.Schema.Generation.JSchemaTypeGenerationContext : object {
    [NullableAttribute("1")]
private JSchemaGeneratorInternal _generatorInternal;
    internal JSchemaGenerationProvider GenerationProvider;
    private JSchemaGeneratorProxy _generatorProxy;
    [CompilerGeneratedAttribute]
private string <SchemaTitle>k__BackingField;
    [CompilerGeneratedAttribute]
private string <SchemaDescription>k__BackingField;
    [NullableAttribute("1")]
[CompilerGeneratedAttribute]
private Type <ObjectType>k__BackingField;
    [CompilerGeneratedAttribute]
private Required <Required>k__BackingField;
    [CompilerGeneratedAttribute]
private JsonProperty <MemberProperty>k__BackingField;
    [CompilerGeneratedAttribute]
private JsonContainerContract <ParentContract>k__BackingField;
    public string SchemaTitle { get; }
    public string SchemaDescription { get; }
    [NullableAttribute("1")]
public Type ObjectType { get; }
    public Required Required { get; }
    public JsonProperty MemberProperty { get; }
    public JsonContainerContract ParentContract { get; }
    [NullableAttribute("1")]
public JSchemaGenerator Generator { get; }
    internal JSchemaTypeGenerationContext(Type objectType, Required required, JsonProperty memberProperty, JsonContainerContract parentContract, JSchemaGeneratorInternal generatorInternal, string schemaTitle, string schemaDescription);
    [CompilerGeneratedAttribute]
public string get_SchemaTitle();
    [CompilerGeneratedAttribute]
public string get_SchemaDescription();
    [NullableContextAttribute("1")]
[CompilerGeneratedAttribute]
public Type get_ObjectType();
    [CompilerGeneratedAttribute]
public Required get_Required();
    [CompilerGeneratedAttribute]
public JsonProperty get_MemberProperty();
    [CompilerGeneratedAttribute]
public JsonContainerContract get_ParentContract();
    [NullableContextAttribute("1")]
public JSchemaGenerator get_Generator();
}
public enum Newtonsoft.Json.Schema.Generation.SchemaIdGenerationHandling : Enum {
    public int value__;
    public static SchemaIdGenerationHandling None;
    public static SchemaIdGenerationHandling TypeName;
    public static SchemaIdGenerationHandling FullTypeName;
    public static SchemaIdGenerationHandling AssemblyQualifiedName;
}
public enum Newtonsoft.Json.Schema.Generation.SchemaLocationHandling : Enum {
    public int value__;
    public static SchemaLocationHandling Definitions;
    public static SchemaLocationHandling Inline;
}
public enum Newtonsoft.Json.Schema.Generation.SchemaPropertyOrderHandling : Enum {
    public int value__;
    public static SchemaPropertyOrderHandling Default;
    public static SchemaPropertyOrderHandling Alphabetical;
}
[FlagsAttribute]
public enum Newtonsoft.Json.Schema.Generation.SchemaReferenceHandling : Enum {
    public int value__;
    public static SchemaReferenceHandling None;
    public static SchemaReferenceHandling Objects;
    public static SchemaReferenceHandling Arrays;
    public static SchemaReferenceHandling Dictionaries;
    public static SchemaReferenceHandling All;
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Newtonsoft.Json.Schema.Generation.StringEnumGenerationProvider : JSchemaGenerationProvider {
    private static CamelCaseNamingStrategy _camelCaseNamingStrategy;
    [CompilerGeneratedAttribute]
private bool <CamelCaseText>k__BackingField;
    public bool CamelCaseText { get; public set; }
    private static StringEnumGenerationProvider();
    [CompilerGeneratedAttribute]
public bool get_CamelCaseText();
    [CompilerGeneratedAttribute]
public void set_CamelCaseText(bool value);
    public virtual JSchema GetSchema(JSchemaTypeGenerationContext context);
    [NullableContextAttribute("2")]
private NamingStrategy GetResolveNamingStrategy();
    public virtual bool CanGenerateSchema(JSchemaTypeGenerationContext context);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Newtonsoft.Json.Schema.Generation.TypeSchema : object {
    public TypeSchemaKey Key;
    public JSchema Schema;
    public TypeSchema(TypeSchemaKey key, JSchema schema);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
internal class Newtonsoft.Json.Schema.Generation.TypeSchemaKey : object {
    [NullableAttribute("1")]
public Type Type;
    public Required Required;
    public Nullable`1<int> MinLength;
    public Nullable`1<int> MaxLength;
    public string Title;
    public string Description;
    public TypeSchemaKey(Type type, Required required, Nullable`1<int> minLength, Nullable`1<int> maxLength, string title, string description);
    public sealed virtual bool Equals(TypeSchemaKey other);
    [NullableContextAttribute("1")]
public virtual bool Equals(object obj);
    public virtual int GetHashCode();
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
internal static class Newtonsoft.Json.Schema.Infrastructure.AttributeHelpers : object {
    private static ReflectionObject _dataTypeReflectionObject;
    private static ReflectionObject _regexReflectionObject;
    private static ReflectionObject _maxLengthReflectionObject;
    private static ReflectionObject _minLengthReflectionObject;
    private static ReflectionObject _enumTypeReflectionObject;
    private static ReflectionObject _stringLengthReflectionObject;
    private static ReflectionObject _rangeReflectionObject;
    private static ReflectionObject _displayReflectionObject;
    private static ReflectionObject _displayNameReflectionObject;
    private static ReflectionObject _descriptionReflectionObject;
    [NullableAttribute("1")]
private static string DisplayNameAttributeName;
    [NullableAttribute("1")]
private static string DescriptionAttributeName;
    [NullableAttribute("1")]
private static string DisplayAttributeName;
    [NullableAttribute("1")]
private static string RequiredAttributeName;
    [NullableAttribute("1")]
private static string MinLengthAttributeName;
    [NullableAttribute("1")]
private static string MaxLengthAttributeName;
    [NullableAttribute("1")]
private static string DataTypeAttributeName;
    [NullableAttribute("1")]
private static string RegularExpressionAttributeName;
    [NullableAttribute("1")]
private static string RangeAttributeName;
    [NullableAttribute("1")]
private static string UrlAttributeName;
    [NullableAttribute("1")]
private static string PhoneAttributeName;
    [NullableAttribute("1")]
private static string EmailAddressAttributeName;
    [NullableAttribute("1")]
private static string StringLengthAttributeName;
    [NullableAttribute("1")]
private static string EnumDataTypeAttributeName;
    private static bool GetDisplay(Type type, JsonProperty memberProperty, String& name, String& description);
    public static bool GetDisplayName(Type type, JsonProperty memberProperty, String& displayName);
    public static bool GetDescription(Type type, JsonProperty memberProperty, String& description);
    public static bool GetRange(JsonProperty property, Double& minimum, Double& maximum);
    public static bool GetStringLength(JsonProperty property, Int32& minimumLength, Int32& maximumLength);
    public static Type GetEnumDataType(JsonProperty property);
    public static Nullable`1<int> GetMinLength(JsonProperty property);
    public static Nullable`1<int> GetMaxLength(JsonProperty property);
    [NullableContextAttribute("1")]
public static bool GetRequired(JsonProperty property);
    public static string GetPattern(JsonProperty property);
    public static string GetFormat(JsonProperty property);
    [NullableContextAttribute("1")]
private static Attribute GetAttributeByName(JsonProperty property, string name, Type& matchingType);
    private static Attribute GetAttributeByName(IAttributeProvider attributeProvider, string name, Type& matchingType);
    [NullableContextAttribute("1")]
private static bool IsMatchingAttribute(Type attributeType, string name, Type& matchingType);
    private static Attribute GetAttributeByNameFromTypeOrProperty(Type type, JsonProperty memberProperty, string name, Type& matchingType);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
[ExtensionAttribute]
internal static class Newtonsoft.Json.Schema.Infrastructure.CollectionHelpers : object {
    [NullableAttribute("1")]
public static Object[] EmptyArray;
    private static CollectionHelpers();
    [ExtensionAttribute]
public static bool IsNullOrEmpty(List`1<T> values);
    [ExtensionAttribute]
public static bool IsNullOrEmpty(IList`1<T> values);
    [ExtensionAttribute]
public static bool IsNullOrEmpty(Dictionary`2<TKey, TValue> values);
    [ExtensionAttribute]
public static bool IsNullOrEmpty(IDictionary`2<TKey, TValue> values);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[DefaultMemberAttribute("Item")]
internal abstract class Newtonsoft.Json.Schema.Infrastructure.Collections.DictionaryBase`2 : object {
    private IDictionary`2<TKey, TValue> _dictionary;
    protected IDictionary`2<TKey, TValue> Dictionary { get; }
    public TValue Item { get; public set; }
    public ICollection`1<TKey> Keys { get; }
    public ICollection`1<TValue> Values { get; }
    public int Count { get; }
    [NullableAttribute("2")]
private object System.Collections.IDictionary.Item { get; private set; }
    private ICollection System.Collections.IDictionary.Keys { get; }
    private ICollection System.Collections.IDictionary.Values { get; }
    public bool IsFixedSize { get; }
    public bool IsReadOnly { get; }
    private object System.Collections.ICollection.SyncRoot { get; }
    private bool System.Collections.ICollection.IsSynchronized { get; }
    protected DictionaryBase`2(IDictionary`2<TKey, TValue> dictionary);
    protected DictionaryBase`2(IEqualityComparer`1<TKey> comparer);
    protected DictionaryBase`2(int capacity);
    protected DictionaryBase`2(IDictionary`2<TKey, TValue> dictionary, IEqualityComparer`1<TKey> comparer);
    protected DictionaryBase`2(int capacity, IEqualityComparer`1<TKey> comparer);
    protected IDictionary`2<TKey, TValue> get_Dictionary();
    protected virtual void AddItem(TKey key, TValue value);
    protected virtual void SetItem(TKey key, TValue value);
    protected virtual bool RemoveItem(TKey key);
    protected virtual void ClearItems();
    private static void VerifyKey(object key);
    [NullableContextAttribute("2")]
private static void VerifyValueType(object value);
    private static bool IsCompatibleKey(object key);
    public sealed virtual bool ContainsKey(TKey key);
    public sealed virtual void Add(TKey key, TValue value);
    public sealed virtual bool Remove(TKey key);
    public sealed virtual bool TryGetValue(TKey key, TValue& value);
    public sealed virtual TValue get_Item(TKey key);
    public sealed virtual void set_Item(TKey key, TValue value);
    public sealed virtual ICollection`1<TKey> get_Keys();
    public sealed virtual ICollection`1<TValue> get_Values();
    private sealed virtual override void System.Collections.Generic.ICollection<System.Collections.Generic.KeyValuePair<TKey,TValue>>.Add(KeyValuePair`2<TKey, TValue> keyValuePair);
    public sealed virtual void Clear();
    private sealed virtual override bool System.Collections.Generic.ICollection<System.Collections.Generic.KeyValuePair<TKey,TValue>>.Contains(KeyValuePair`2<TKey, TValue> keyValuePair);
    private sealed virtual override void System.Collections.Generic.ICollection<System.Collections.Generic.KeyValuePair<TKey,TValue>>.CopyTo(KeyValuePair`2[] array, int arrayIndex);
    private sealed virtual override bool System.Collections.Generic.ICollection<System.Collections.Generic.KeyValuePair<TKey,TValue>>.Remove(KeyValuePair`2<TKey, TValue> keyValuePair);
    public sealed virtual int get_Count();
    private sealed virtual override IEnumerator`1<KeyValuePair`2<TKey, TValue>> System.Collections.Generic.IEnumerable<System.Collections.Generic.KeyValuePair<TKey,TValue>>.GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    private sealed virtual override void System.Collections.IDictionary.Add(object key, object value);
    private sealed virtual override bool System.Collections.IDictionary.Contains(object key);
    private sealed virtual override IDictionaryEnumerator System.Collections.IDictionary.GetEnumerator();
    private sealed virtual override void System.Collections.IDictionary.Remove(object key);
    private sealed virtual override object System.Collections.IDictionary.get_Item(object key);
    private sealed virtual override void System.Collections.IDictionary.set_Item(object key, object value);
    private sealed virtual override ICollection System.Collections.IDictionary.get_Keys();
    private sealed virtual override ICollection System.Collections.IDictionary.get_Values();
    public sealed virtual bool get_IsFixedSize();
    public sealed virtual bool get_IsReadOnly();
    private sealed virtual override void System.Collections.ICollection.CopyTo(Array array, int index);
    private sealed virtual override object System.Collections.ICollection.get_SyncRoot();
    private sealed virtual override bool System.Collections.ICollection.get_IsSynchronized();
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal class Newtonsoft.Json.Schema.Infrastructure.Collections.JSchemaCollection : Collection`1<JSchema> {
    private JSchema _parentSchema;
    public JSchemaCollection(JSchema parentSchema);
    private void OnChanged();
    private void OnChildChanged(JSchema changedSchema);
    protected virtual void InsertItem(int index, JSchema item);
    protected virtual void SetItem(int index, JSchema item);
    protected virtual void RemoveItem(int index);
    protected virtual void ClearItems();
    public List`1<JSchema> GetInnerList();
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal class Newtonsoft.Json.Schema.Infrastructure.Collections.JSchemaDependencyDictionary : DictionaryBase`2<string, object> {
    private JSchema _parentSchema;
    private int _schemasCount;
    public bool HasSchemas { get; }
    public JSchemaDependencyDictionary(JSchema parentSchema);
    public bool get_HasSchemas();
    public Dictionary`2<string, object> GetInnerDictionary();
    private void OnChanged();
    private void OnChildChanged(JSchema changedSchema);
    protected virtual void AddItem(string key, object value);
    protected virtual void SetItem(string key, object value);
    protected virtual bool RemoveItem(string key);
    protected virtual void ClearItems();
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal class Newtonsoft.Json.Schema.Infrastructure.Collections.JSchemaDictionary : DictionaryBase`2<string, JSchema> {
    private JSchema _parentSchema;
    public JSchemaDictionary(JSchema parentSchema, IDictionary`2<string, JSchema> dictionary);
    public JSchemaDictionary(JSchema parentSchema);
    private void OnChanged();
    private void OnChildChanged(JSchema changedSchema);
    protected virtual void AddItem(string key, JSchema value);
    protected virtual void SetItem(string key, JSchema value);
    protected virtual bool RemoveItem(string key);
    protected virtual void ClearItems();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[DefaultMemberAttribute("Item")]
internal class Newtonsoft.Json.Schema.Infrastructure.Collections.JSchemaPatternDictionary : object {
    private Dictionary`2<string, PatternSchema> _inner;
    [NullableAttribute("2")]
private ValuesCollection _values;
    public int Count { get; }
    public bool IsReadOnly { get; }
    public JSchema Item { get; public set; }
    public ICollection`1<string> Keys { get; }
    public ICollection`1<JSchema> Values { get; }
    public IEnumerable`1<PatternSchema> GetPatternSchemas();
    [IteratorStateMachineAttribute("Newtonsoft.Json.Schema.Infrastructure.Collections.JSchemaPatternDictionary/<GetEnumerator>d__4")]
public sealed virtual IEnumerator`1<KeyValuePair`2<string, JSchema>> GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    public sealed virtual void Add(KeyValuePair`2<string, JSchema> item);
    public sealed virtual void Clear();
    public sealed virtual bool Contains(KeyValuePair`2<string, JSchema> item);
    public sealed virtual void CopyTo(KeyValuePair`2[] array, int arrayIndex);
    public sealed virtual bool Remove(KeyValuePair`2<string, JSchema> item);
    public sealed virtual int get_Count();
    public sealed virtual bool get_IsReadOnly();
    public sealed virtual bool ContainsKey(string key);
    public sealed virtual void Add(string key, JSchema value);
    public sealed virtual bool Remove(string key);
    public sealed virtual bool TryGetValue(string key, JSchema& value);
    public sealed virtual JSchema get_Item(string key);
    public sealed virtual void set_Item(string key, JSchema value);
    public sealed virtual ICollection`1<string> get_Keys();
    public sealed virtual ICollection`1<JSchema> get_Values();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Newtonsoft.Json.Schema.Infrastructure.Collections.PatternSchema : object {
    private JSchema _schema;
    private string _pattern;
    [NullableAttribute("2")]
private Regex _patternRegex;
    [NullableAttribute("2")]
private string _patternError;
    public string Pattern { get; }
    public JSchema Schema { get; }
    public PatternSchema(string pattern, JSchema schema);
    public string get_Pattern();
    public JSchema get_Schema();
    [NullableContextAttribute("2")]
internal bool TryGetPatternRegex(Nullable`1<TimeSpan> matchTimeout, Regex& regex, String& errorMessage);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Newtonsoft.Json.Schema.Infrastructure.Collections.ValuesCollection : object {
    private ICollection`1<PatternSchema> _inner;
    public int Count { get; }
    public bool IsReadOnly { get; }
    public ValuesCollection(ICollection`1<PatternSchema> inner);
    [IteratorStateMachineAttribute("Newtonsoft.Json.Schema.Infrastructure.Collections.ValuesCollection/<GetEnumerator>d__2")]
public sealed virtual IEnumerator`1<JSchema> GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    public sealed virtual void Add(JSchema item);
    public sealed virtual void Clear();
    public sealed virtual bool Contains(JSchema item);
    public sealed virtual void CopyTo(JSchema[] array, int arrayIndex);
    public sealed virtual bool Remove(JSchema item);
    public sealed virtual int get_Count();
    public sealed virtual bool get_IsReadOnly();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal static class Newtonsoft.Json.Schema.Infrastructure.ColorHelpers : object {
    private static List`1<string> NamedColors;
    private static ColorHelpers();
    public static bool IsValid(string s);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal static class Newtonsoft.Json.Schema.Infrastructure.CompareUtils : object {
    [NullableContextAttribute("2")]
internal static int CompareInteger(object objA, object objB);
    private static int CompareFloat(object objA, object objB);
    public static bool ApproxEquals(double d1, double d2);
    private static int CompareBigInteger(BigInteger i1, object i2);
    internal static BigInteger ToBigInteger(object value);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal static class Newtonsoft.Json.Schema.Infrastructure.Constants : object {
    public static List`1<JsonToken> NumberTokens;
    public static List`1<JsonToken> SchemaTokens;
    public static List`1<JsonToken> ItemsTokens;
    public static List`1<JsonToken> ItemsDraft4Tokens;
    public static List`1<JsonToken> DependencyTokens;
    public static List`1<JsonToken> DependencyDraft4Tokens;
    public static List`1<JsonToken> MaximumMinimumTokens;
    public static IDictionary`2<string, JSchemaType> JSchemaTypeMapping;
    public static JSchemaType AnyType;
    private static Constants();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal static class Newtonsoft.Json.Schema.Infrastructure.ConvertUtils : object {
    private static Dictionary`2<Type, PrimitiveTypeCode> TypeCodeMap;
    private static ConvertUtils();
    public static PrimitiveTypeCode GetTypeCode(Type t);
    public static PrimitiveTypeCode GetTypeCode(Type t, Boolean& isEnum);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
[DebuggerDisplayAttribute("Reference = {ResolvedReference}, IsRecursive = {IsRecursiveReference}, Success = {Success}")]
internal class Newtonsoft.Json.Schema.Infrastructure.DeferedSchema : object {
    [NullableAttribute("1")]
public Uri OriginalReference;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public List`1<IIdentiferScope> IdentiferScopeStack;
    [NullableAttribute("1")]
public Uri ResolvedReference;
    [NullableAttribute("1")]
public JSchema ReferenceSchema;
    private bool _supportsRef;
    [NullableAttribute("1")]
public List`1<SetSchema> SetSchemas;
    public bool IsRecursiveReference;
    private bool _success;
    private JSchema _resolvedSchema;
    [CompilerGeneratedAttribute]
private Uri <ScopeId>k__BackingField;
    [CompilerGeneratedAttribute]
private string <DynamicAnchor>k__BackingField;
    [MemberNotNullWhenAttribute("True", "ResolvedSchema")]
public bool Success { get; }
    public JSchema ResolvedSchema { get; }
    public Uri ScopeId { get; }
    public bool Root { get; }
    public string DynamicAnchor { get; }
    [NullableContextAttribute("1")]
public DeferedSchema(Uri resolvedReference, Uri originalReference, Uri scopeId, string dynamicAnchor, List`1<IIdentiferScope> identiferScopeStack, bool isRecursiveReference, JSchema referenceSchema, bool supportsRef);
    [MemberNotNullWhenAttribute("True", "ResolvedSchema")]
public bool get_Success();
    public JSchema get_ResolvedSchema();
    [CompilerGeneratedAttribute]
public sealed virtual Uri get_ScopeId();
    public sealed virtual bool get_Root();
    [CompilerGeneratedAttribute]
public sealed virtual string get_DynamicAnchor();
    [NullableContextAttribute("1")]
public static DeferedSchemaKey CreateKey(DeferedSchema deferedSchema);
    [NullableContextAttribute("1")]
public void AddSchemaSet(Action`1<JSchema> setSchema, JSchema target);
    [NullableContextAttribute("1")]
public void SetResolvedSchema(JSchema schema);
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal class Newtonsoft.Json.Schema.Infrastructure.DeferedSchemaCollection : KeyedCollection`2<DeferedSchemaKey, DeferedSchema> {
    protected virtual DeferedSchemaKey GetKeyForItem(DeferedSchema item);
    [NullableContextAttribute("2")]
public bool TryGetValue(DeferedSchemaKey key, DeferedSchema& value);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Newtonsoft.Json.Schema.Infrastructure.DeferedSchemaKey : ValueType {
    [CompilerGeneratedAttribute]
private Uri <ResolvedReference>k__BackingField;
    [NullableAttribute("2")]
[CompilerGeneratedAttribute]
private Uri <DynamicScopeId>k__BackingField;
    public Uri ResolvedReference { get; }
    [NullableAttribute("2")]
public Uri DynamicScopeId { get; }
    public DeferedSchemaKey(Uri resolvedReference, Uri dynamicScopeId);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public Uri get_ResolvedReference();
    [IsReadOnlyAttribute]
[NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public Uri get_DynamicScopeId();
    public virtual bool Equals(object obj);
    public sealed virtual bool Equals(DeferedSchemaKey other);
    public virtual int GetHashCode();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Newtonsoft.Json.Schema.Infrastructure.Discovery.JSchemaDiscovery : object {
    [NullableAttribute("2")]
private JSchema _rootSchema;
    private KnownSchemaState _state;
    private List`1<SchemaPath> _pathStack;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private List`1<ValidationError> <ValidationErrors>k__BackingField;
    [CompilerGeneratedAttribute]
private KnownSchemaCollection <KnownSchemas>k__BackingField;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public List`1<ValidationError> ValidationErrors { get; public set; }
    public KnownSchemaCollection KnownSchemas { get; }
    [NullableContextAttribute("2")]
public JSchemaDiscovery(JSchema rootSchema);
    public JSchemaDiscovery(JSchema rootSchema, KnownSchemaCollection knownSchemas, KnownSchemaState state);
    [CompilerGeneratedAttribute]
public List`1<ValidationError> get_ValidationErrors();
    [CompilerGeneratedAttribute]
public void set_ValidationErrors(List`1<ValidationError> value);
    [CompilerGeneratedAttribute]
public KnownSchemaCollection get_KnownSchemas();
    public void Discover(JSchema schema, Uri scopedUri, string path);
    private void DiscoverInternal(JSchema schema, string latestPath, bool isDefinitionSchema);
    private Uri GetSchemaIdAndNewScopeId(JSchema schema, String& latestPath, Uri& newScopeId);
    private static string GetFragment(Uri referencedAs);
    public static Uri ResolveSchemaIdAndScopeId(Uri idScope, JSchema schema, string path, Uri& newScope);
    private void DiscoverTokenSchemas(JSchema schema, string name, JToken token, bool isDefinitionSchema);
    private void DiscoverDictionarySchemas(string name, IDictionary`2<string, object> schemas);
    private void DiscoverDictionarySchemas(string name, IDictionary`2<string, JSchema> schemas);
    private void DiscoverArraySchemas(string name, IList`1<JSchema> schemas);
    private void DiscoverSchema(string name, JSchema schema);
    private string EscapePath(string path);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[DebuggerDisplayAttribute("{Id}")]
internal class Newtonsoft.Json.Schema.Infrastructure.Discovery.KnownSchema : object {
    public Uri Id;
    public JSchema Schema;
    public KnownSchemaState State;
    public KnownSchema(Uri id, JSchema schema, KnownSchemaState state);
}
internal enum Newtonsoft.Json.Schema.Infrastructure.Discovery.KnownSchemaState : Enum {
    public int value__;
    public static KnownSchemaState External;
    public static KnownSchemaState InlinePending;
    public static KnownSchemaState DefinitionPending;
    public static KnownSchemaState Written;
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal static class Newtonsoft.Json.Schema.Infrastructure.Discovery.SchemaDiscovery : object {
    private static string UnescapeReference(string reference);
    private static Uri GetTokenId(JToken o, JSchemaReader schemaReader);
    private static string GetTokenDynamicAnchor(JToken o, JSchemaReader schemaReader);
    [NullableContextAttribute("2")]
public static Uri CombineIdAndAnchor(Uri id, string anchor);
    private static Uri GetTokenUri(JValue t);
    public static bool FindSchema(Action`1<JSchema> setSchema, JSchema schema, Uri rootSchemaId, Uri reference, Uri originalReference, Uri dynamicScope, JSchemaReader schemaReader, JSchemaDiscovery& discovery);
    private static bool SplitReference(Uri reference, Uri& path, Uri& fragment);
    private static bool IsInternalSchemaReference(string firstPart, Uri rootSchemaId);
    private static bool TryFindSchemaInDefinitions(string definitionsName, Action`1<JSchema> setSchema, JSchema schema, Uri rootSchemaId, Uri dynamicScope, JSchemaReader schemaReader, JSchemaDiscovery discovery, Uri resolvedReference);
    private static bool CheckDefinitionSchemaIds(string definitionsName, Action`1<JSchema> setSchema, Uri rootSchemaId, Uri dynamicScope, JSchemaReader schemaReader, JSchemaDiscovery discovery, Uri resolvedReference, Uri matchingId, Uri matchingFragment, JObject definitionsObject);
    private static bool IsNestedDefinitionMatch(string definitionsName, Action`1<JSchema> setSchema, Uri rootSchemaId, Uri dynamicScope, JSchemaReader schemaReader, JSchemaDiscovery discovery, Uri resolvedReference, Uri matchingId, Uri matchingFragment, JObject obj);
    private static bool IsIdMatch(JSchemaReader schemaReader, Uri resolvedReference, JObject o, Uri rootSchemaId);
    private static bool TryGetImplicitItemsSchema(JSchema parent, IList`1<JSchema> items, JSchema& schema);
    private static object GetCurrentFromSchema(JSchema s, string unescapedPart);
    private static object GetCurrentFromToken(JToken t, string unescapedPart, Uri dynamicScope);
    private static bool TryCompare(string value, Uri resolvedReference);
    public static Uri ResolveSchemaId(Uri idScope, Uri schemaId);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[DebuggerDisplayAttribute("Id = {ScopeId}, Path = {Path}")]
internal class Newtonsoft.Json.Schema.Infrastructure.Discovery.SchemaPath : object {
    public Uri ScopeId;
    [NullableAttribute("2")]
public Uri ReferencedAs;
    public string Path;
    public SchemaPath(Uri scopeId, Uri referencedAs, string path);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal static class Newtonsoft.Json.Schema.Infrastructure.EmailHelpers : object {
    private static string AtomCharacters;
    private static bool IsLetterOrDigit(char c);
    private static bool IsAtom(char c, bool allowInternational);
    private static bool IsDomain(char c, bool allowInternational);
    private static bool SkipAtom(string text, Int32& index, bool allowInternational);
    private static bool SkipSubDomain(string text, Int32& index, bool allowInternational);
    private static bool SkipDomain(string text, Int32& index, bool allowInternational);
    private static bool SkipQuoted(string text, Int32& index, bool allowInternational);
    private static bool SkipWord(string text, Int32& index, bool allowInternational);
    private static bool SkipIPv4Literal(string text, Int32& index);
    private static bool IsHexDigit(char c);
    private static bool SkipIPv6Literal(string text, Int32& index);
    public static bool Validate(string email, bool allowInternational);
}
internal static class Newtonsoft.Json.Schema.Infrastructure.EnumHelpers : object {
    public static List`1<T> GetAllEnums();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Newtonsoft.Json.Schema.Infrastructure.EnumInfo : object {
    public bool IsFlags;
    public UInt64[] Values;
    public String[] Names;
    public String[] ResolvedNames;
    public EnumInfo(bool isFlags, UInt64[] values, String[] names, String[] resolvedNames);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal static class Newtonsoft.Json.Schema.Infrastructure.EnumUtils : object {
    private static char EnumSeparatorChar;
    private static string EnumSeparatorString;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private static ThreadSafeStore`2<StructMultiKey`2<Type, NamingStrategy>, EnumInfo> ValuesAndNamesPerEnum;
    private static EnumUtils();
    private static EnumInfo InitializeValuesAndNames(StructMultiKey`2<Type, NamingStrategy> key);
    [NullableContextAttribute("0")]
public static IList`1<T> GetFlagsValues(T value);
    public static bool TryToString(Type enumType, object value, NamingStrategy namingStrategy, String& name);
    private static string InternalFlagsFormat(EnumInfo entry, ulong result);
    public static EnumInfo GetEnumValuesAndNames(Type enumType, NamingStrategy namingStrategy);
    private static ulong ToUInt64(object value);
    public static object ParseEnum(Type enumType, NamingStrategy namingStrategy, string value, bool disallowNumber);
    private static Nullable`1<int> MatchName(string value, String[] enumNames, String[] resolvedNames, int valueIndex, int valueSubstringLength, StringComparison comparison);
    private static Nullable`1<int> FindIndexByName(String[] enumNames, string value, int valueIndex, int valueSubstringLength, StringComparison comparison);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Newtonsoft.Json.Schema.Infrastructure.ExpressionReflectionDelegateFactory : ReflectionDelegateFactory {
    private static ExpressionReflectionDelegateFactory _instance;
    internal static ReflectionDelegateFactory Instance { get; }
    private static ExpressionReflectionDelegateFactory();
    internal static ReflectionDelegateFactory get_Instance();
    public virtual ObjectConstructor`1<object> CreateParameterizedConstructor(MethodBase method);
    public virtual MethodCall`2<T, object> CreateMethodCall(MethodBase method);
    private Expression BuildMethodCall(MethodBase method, Type type, ParameterExpression targetParameterExpression, ParameterExpression argsParameterExpression);
    public virtual Func`1<T> CreateDefaultConstructor(Type type);
    public virtual Func`2<T, object> CreateGet(PropertyInfo propertyInfo);
    public virtual Func`2<T, object> CreateGet(FieldInfo fieldInfo);
    public virtual Action`2<T, object> CreateSet(FieldInfo fieldInfo);
    public virtual Action`2<T, object> CreateSet(PropertyInfo propertyInfo);
    private Expression EnsureCastExpression(Expression expression, Type targetType, bool allowWidening);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal static class Newtonsoft.Json.Schema.Infrastructure.FormatHelpers : object {
    private static Regex UriTemplateRegex;
    private static Regex JsonPointerRegex;
    private static Regex UriReferenceRegex;
    private static Regex Ipv6Regex;
    private static Regex Ipv6PlusIpv4Regex;
    private static FormatHelpers();
    public static bool ValidateUriTemplate(string text);
    public static bool ValidateJsonPointer(string text);
    public static bool ValidateUriReference(string text);
    public static bool ValidateDuration(string text);
    public static bool ValidateIPv6(string value);
    public static bool ValidateIPv4(string value);
    [CompilerGeneratedAttribute]
internal static bool <ValidateDuration>g__Require|8_0(string text, Int32& index, char requiredChar);
    [CompilerGeneratedAttribute]
internal static bool <ValidateDuration>g__SkipElement|8_1(string text, Int32& index, char expectedElementChar);
}
[NullableContextAttribute("1")]
internal interface Newtonsoft.Json.Schema.Infrastructure.IDownloader {
    public abstract virtual Stream GetStream(Uri uri, ICredentials credentials, Nullable`1<int> timeout, Nullable`1<int> byteLimit);
}
[NullableContextAttribute("2")]
internal interface Newtonsoft.Json.Schema.Infrastructure.IIdentiferScope {
    public Uri ScopeId { get; }
    public bool Root { get; }
    public string DynamicAnchor { get; }
    public abstract virtual Uri get_ScopeId();
    public abstract virtual bool get_Root();
    public abstract virtual string get_DynamicAnchor();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Newtonsoft.Json.Schema.Infrastructure.JSchemaAnnotation : object {
    private static Uri NoScope;
    private Dictionary`2<Uri, JSchema> _schemas;
    private static JSchemaAnnotation();
    public void RegisterSchema(Uri dynamicScope, JSchema schema);
    [NullableContextAttribute("2")]
public JSchema GetSchema(Uri dynamicScope);
    [NullableContextAttribute("2")]
public bool TryGetSingle(JSchema& schema);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Newtonsoft.Json.Schema.Infrastructure.JSchemaConverter : JsonConverter {
    public virtual bool CanConvert(Type objectType);
    public virtual object ReadJson(JsonReader reader, Type objectType, object existingValue, JsonSerializer serializer);
    public virtual void WriteJson(JsonWriter writer, object value, JsonSerializer serializer);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Newtonsoft.Json.Schema.Infrastructure.JSchemaDummyResolver : JSchemaResolver {
    public static JSchemaDummyResolver Instance;
    private static JSchemaDummyResolver();
    public virtual Stream GetSchemaResource(ResolveSchemaContext context, SchemaReference reference);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Newtonsoft.Json.Schema.Infrastructure.JSchemaReader : object {
    internal JSchemaDiscovery _schemaDiscovery;
    internal List`1<IIdentiferScope> _identiferScopeStack;
    private DeferedSchemaCollection _deferedSchemas;
    private DeferedSchemaCollection _resolvedDeferedSchemas;
    private JSchemaResolver _resolver;
    [NullableAttribute("2")]
private Uri _baseUri;
    private bool _validateSchema;
    [NullableAttribute("2")]
private SchemaValidationEventHandler _validationEventHandler;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private List`1<ValidationError> _validationErrors;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private IList`1<JsonValidator> _validators;
    private bool _resolveSchemaReferences;
    [NullableAttribute("2")]
private Uri _versionUri;
    private SchemaVersion _version;
    [NullableAttribute("2")]
private JSchema _validatingSchema;
    private bool _isReentrant;
    [CompilerGeneratedAttribute]
private JSchema <RootSchema>k__BackingField;
    [CompilerGeneratedAttribute]
private Dictionary`2<Uri, JSchema> <Cache>k__BackingField;
    [NullableAttribute("2")]
[CompilerGeneratedAttribute]
private JSchemaReader <Parent>k__BackingField;
    public JSchema RootSchema { get; public set; }
    public Dictionary`2<Uri, JSchema> Cache { get; public set; }
    [NullableAttribute("2")]
public JSchemaReader Parent { get; private set; }
    public JSchemaReader(JSchemaResolver resolver);
    public JSchemaReader(JSchemaReaderSettings settings);
    [CompilerGeneratedAttribute]
public JSchema get_RootSchema();
    [CompilerGeneratedAttribute]
public void set_RootSchema(JSchema value);
    [CompilerGeneratedAttribute]
public Dictionary`2<Uri, JSchema> get_Cache();
    [CompilerGeneratedAttribute]
public void set_Cache(Dictionary`2<Uri, JSchema> value);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public JSchemaReader get_Parent();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
private void set_Parent(JSchemaReader value);
    internal JSchema ReadRoot(JsonReader reader);
    internal JSchema ReadRoot(JsonReader reader, bool resolveDeferedSchemas);
    public void RaiseValidationErrors();
    internal bool EnsureVersion(SchemaVersion minimum, Nullable`1<SchemaVersion> maximum);
    internal JSchema ReadInlineSchema(Action`1<JSchema> setSchema, JToken inlineToken, Uri dynamicScope);
    internal bool AddDeferedSchema(JSchema target, Action`1<JSchema> setSchema, JSchema referenceSchema);
    private static void ResolveReferenceFromSchema(JSchema referenceSchema, string scopeDynamicAnchor, Boolean& isRecursiveReference, Uri& originalReference);
    private void ReadSchemaProperties(JsonReader reader, JSchema target, bool isRoot);
    public void ResolveDeferedSchemas();
    private void ResolveDeferedSchema(DeferedSchema deferedSchema);
    private void ReadSchema(JsonReader reader, JSchema target, string name, Action`1<JSchema> setSchema);
    private void ValidateSchemaStart(JsonReader reader, string name);
    private void EnsureRead(JsonReader reader, string name);
    [NullableContextAttribute("2")]
private void EnsureReadAndToken(JsonReader reader, string name, JsonToken tokenType, string errorMessage);
    [NullableContextAttribute("2")]
private void EnsureToken(JsonReader reader, string name, JsonToken tokenType, string errorMessage);
    private void EnsureToken(JsonReader reader, string name, List`1<JsonToken> tokenTypes, string errorMessage);
    private void EnsureReadAndToken(JsonReader reader, string name, List`1<JsonToken> tokenTypes, string errorMessage);
    private Uri ReadUri(JsonReader reader, string name);
    private Uri ParseUri(JsonReader reader, string id);
    private string ReadString(JsonReader reader, string name);
    private bool ReadBoolean(JsonReader reader, string name);
    private long ReadLong(JsonReader reader, string name);
    private double ReadDouble(JsonReader reader, string name);
    private static double GetDouble(JsonReader reader);
    private void ReadProperties(JsonReader reader, JSchema target, IDictionary`2<string, JSchema> properties);
    private static void SetAtIndex(IList`1<T> list, int index, T value);
    private void ReadItems(JsonReader reader, JSchema target);
    private void ReadSchemaArray(JsonReader reader, JSchema target, string name, JSchemaCollection& schemas);
    private void ReadAdditionalItems(JsonReader reader, JSchema target);
    private void ReadUnevaluatedItems(JsonReader reader, JSchema target);
    private void ReadAdditionalProperties(JsonReader reader, JSchema target);
    private void ReadUnevaluatedProperties(JsonReader reader, JSchema target);
    private void ReadRequired(JsonReader reader, JSchema target);
    private void ReadExtends(JsonReader reader, JSchema target);
    private void ReadTokenArray(JsonReader reader, string name, List`1& values);
    private void ReadStringArray(JsonReader reader, string name, List`1& values);
    private void ReadObjectOfStringArrays(JsonReader reader, string name, IDictionary`2<string, IList`1<string>> result);
    private void ReadDependencies(JsonReader reader, JSchema target);
    private void PopulateSchemaArray(JsonReader reader, JSchema target, string name, IList`1<JSchema> schemas);
    internal Nullable`1<JSchemaType> MapType(JsonReader reader);
    private object ReadType(JsonReader reader, JSchema target, string name);
    private void LoadAndSetSchema(JsonReader reader, JSchema target, Action`1<JSchema> setSchema, bool isRoot);
    private bool AddDeferedSchema(Uri resolvedReference, Uri originalReference, Uri scopeId, string dynamicAnchor, List`1<IIdentiferScope> identiferScopeStack, bool isRecursiveReference, JSchema referenceSchema, JSchema target, Action`1<JSchema> setSchema);
    internal void SetResolvedSchema(JSchema referenceSchema, Action`1<JSchema> setSchema, JSchema resolvedSchema, DeferedSchema deferedSchema);
    private JSchema ResolvedSchema(Uri schemaId, Uri resolvedSchemaId);
    [NullableContextAttribute("2")]
private Uri ResolveScopeId(String& dynamicAnchor);
    private Uri ResolveSchemaReference(Uri scopeId, JSchema schema);
    private void ProcessSchemaName(JsonReader& reader, JSchema target, bool isRoot, string name);
    private void ReadExtensionData(JsonReader reader, JSchema target, string name);
    private void RaiseSchemaValidationError(object sender, SchemaValidationEventArgs e);
    [CompilerGeneratedAttribute]
private void <ReadRoot>b__30_0(JSchema s);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
internal static class Newtonsoft.Json.Schema.Infrastructure.JSchemaTypeHelpers : object {
    private static Dictionary`2<JSchemaType, string> CachedSchemaTypeNames;
    private static JSchemaTypeHelpers();
    [ExtensionAttribute]
public static string GetDisplayText(JSchemaType value);
    internal static bool HasFlag(Nullable`1<JSchemaType> value, JSchemaType flag);
    internal static string MapType(JSchemaType type);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Newtonsoft.Json.Schema.Infrastructure.JSchemaWriter : object {
    private JsonWriter _writer;
    private KnownSchemaCollection _knownSchemas;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private List`1<JSchema> _schemaStack;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private IList`1<ExternalSchema> _externalSchemas;
    private JSchemaWriterReferenceHandling _referenceHandling;
    private SchemaVersion _version;
    [NullableAttribute("2")]
private JSchema _rootSchema;
    public JSchemaWriter(JsonWriter writer);
    public JSchemaWriter(JsonWriter writer, JSchemaWriterSettings settings);
    private void ReferenceOrWriteSchema(JSchema context, JSchema schema, string propertyName, bool isDefinitions);
    private void WriteReference(JSchema context, JSchema schema, string propertyName);
    private Uri ResolveReference(JSchema context, KnownSchema knownSchema);
    private bool ShouldWriteReference(KnownSchema knownSchema, bool isDefinitions);
    private void WriteReferenceObject(Uri reference);
    private void WriteToken(JSchema context, JsonWriter writer, JToken token, bool isDefinitions);
    public void WriteSchema(JSchema schema);
    private void WriteSchemaInternal(JSchema schema);
    private void WriteSchemaObjectInternal(JSchema schema);
    private void WriteRequired(JSchema schema);
    private void WriteSchema(JSchema context, JSchema schema, string name);
    private void WriteSchemas(JSchema context, JSchemaCollection schemas, string name);
    private void WriteItems(JSchema schema);
    private void WriteSchemaDictionaryIfNotNull(JSchema context, JsonWriter writer, string propertyName, IDictionary`2<string, JSchema> properties);
    private void WriteType(string propertyName, JsonWriter writer, JSchemaType type);
    private void WritePropertyIfNotDefault(JsonWriter writer, string propertyName, T value, T defaultValue);
    private void WritePropertyIfNotNull(JsonWriter writer, string propertyName, object value);
    internal bool EnsureVersion(SchemaVersion minimum, Nullable`1<SchemaVersion> maximum);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
internal class Newtonsoft.Json.Schema.Infrastructure.JsonIdentiferScope : object {
    [NullableAttribute("1")]
public static JsonIdentiferScope Empty;
    [CompilerGeneratedAttribute]
private Uri <ScopeId>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <Root>k__BackingField;
    [CompilerGeneratedAttribute]
private string <DynamicAnchor>k__BackingField;
    public Uri ScopeId { get; }
    public bool Root { get; }
    public string DynamicAnchor { get; }
    public JsonIdentiferScope(Uri id, bool root, string dynamicAnchor);
    private static JsonIdentiferScope();
    [CompilerGeneratedAttribute]
public sealed virtual Uri get_ScopeId();
    [CompilerGeneratedAttribute]
public sealed virtual bool get_Root();
    [CompilerGeneratedAttribute]
public sealed virtual string get_DynamicAnchor();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal static class Newtonsoft.Json.Schema.Infrastructure.JsonTokenHelpers : object {
    internal static bool IsPrimitiveToken(JsonToken token);
    internal static bool IsPrimitiveOrEndToken(JsonToken token);
    internal static bool IsPrimitiveOrStartToken(JsonToken token);
    internal static bool Contains(List`1<JToken> enums, JToken value);
    internal static bool ImplicitDeepEquals(JToken t1, JToken t2);
    private static bool ValueTypeEquals(JValue v1, JValue v2);
    private static bool ContentsEqual(IList`1<JToken> t1, IList`1<JToken> t2);
    private static bool ContentsEqual(JObject o1, JObject o2);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Newtonsoft.Json.Schema.Infrastructure.JTokenPathAnnotation : object {
    public string BasePath;
    public JTokenPathAnnotation(string basePath);
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal class Newtonsoft.Json.Schema.Infrastructure.KnownSchemaCollection : KeyedCollection`2<JSchema, KnownSchema> {
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private Dictionary`2<Uri, KnownSchema> _uriKnownSchemaLookup;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private Dictionary`2<JSchema, KnownSchema> _jSchemaKnownSchemaLookup;
    internal Dictionary`2<Uri, KnownSchema> UriKnownSchemaLookup { get; }
    internal Dictionary`2<JSchema, KnownSchema> JSchemaKnownSchemaLookup { get; }
    internal Dictionary`2<Uri, KnownSchema> get_UriKnownSchemaLookup();
    internal Dictionary`2<JSchema, KnownSchema> get_JSchemaKnownSchemaLookup();
    protected virtual void InsertItem(int index, KnownSchema item);
    protected virtual void SetItem(int index, KnownSchema item);
    protected virtual void RemoveItem(int index);
    protected virtual void ClearItems();
    protected virtual JSchema GetKeyForItem(KnownSchema item);
    public KnownSchema GetById(Uri id);
    public KnownSchema GetByJSchema(JSchema jSchema);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Newtonsoft.Json.Schema.Infrastructure.LateBoundReflectionDelegateFactory : ReflectionDelegateFactory {
    private static LateBoundReflectionDelegateFactory _instance;
    internal static ReflectionDelegateFactory Instance { get; }
    private static LateBoundReflectionDelegateFactory();
    internal static ReflectionDelegateFactory get_Instance();
    public virtual ObjectConstructor`1<object> CreateParameterizedConstructor(MethodBase method);
    public virtual MethodCall`2<T, object> CreateMethodCall(MethodBase method);
    public virtual Func`1<T> CreateDefaultConstructor(Type type);
    public virtual Func`2<T, object> CreateGet(PropertyInfo propertyInfo);
    public virtual Func`2<T, object> CreateGet(FieldInfo fieldInfo);
    public virtual Action`2<T, object> CreateSet(FieldInfo fieldInfo);
    public virtual Action`2<T, object> CreateSet(PropertyInfo propertyInfo);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal static class Newtonsoft.Json.Schema.Infrastructure.Licensing.CryptographyHelpers : object {
    private static string PublicKey;
    private static string PublicKeyCsp;
    internal static bool ValidateData(Byte[] data, Byte[] signature);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
internal class Newtonsoft.Json.Schema.Infrastructure.Licensing.LicenseDetails : object {
    [CompilerGeneratedAttribute]
private int <Id>k__BackingField;
    [CompilerGeneratedAttribute]
private DateTime <ExpiryDate>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Type>k__BackingField;
    public int Id { get; public set; }
    public DateTime ExpiryDate { get; public set; }
    public string Type { get; public set; }
    [CompilerGeneratedAttribute]
public int get_Id();
    [CompilerGeneratedAttribute]
public void set_Id(int value);
    [CompilerGeneratedAttribute]
public DateTime get_ExpiryDate();
    [CompilerGeneratedAttribute]
public void set_ExpiryDate(DateTime value);
    [CompilerGeneratedAttribute]
public string get_Type();
    [CompilerGeneratedAttribute]
public void set_Type(string value);
    [NullableContextAttribute("1")]
internal Byte[] GetSignificateData();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
internal static class Newtonsoft.Json.Schema.Infrastructure.Licensing.LicenseHelpers : object {
    private static object Lock;
    private static long _validationCount;
    private static long _generationCount;
    [NullableAttribute("2")]
private static LicenseDetails _registeredLicense;
    [NullableAttribute("2")]
private static Timer _resetTimer;
    private static LicenseHelpers();
    internal static void ResetCounts(object state);
    public static void IncrementAndCheckValidationCount();
    public static void IncrementAndCheckGenerationCount();
    private static void EnsureResetTimer();
    [ExtensionAttribute]
internal static T[] SubArray(T[] data, int index, int length);
    public static bool HasRegisteredLicense();
    public static void RegisterLicense(string license);
    internal static void RegisterLicense(string license, DateTime releaseDate);
    private static LicenseDetails ReadLicenseData(DateTime releaseDate, string licenseBase64, int licenseId);
    private static void SplitLicense(string license, String& licenseBase64, Int32& licenseId);
    private static void SetRegisteredLicense(LicenseDetails license);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal static class Newtonsoft.Json.Schema.Infrastructure.Licensing.LicenseType : object {
    public static string Test;
    public static string JsonSchemaIndie;
    public static string JsonSchemaBusiness;
    public static string JsonSchemaSite;
}
internal class Newtonsoft.Json.Schema.Infrastructure.Licensing.ReleaseDateAttribute : Attribute {
    private DateTime _releaseDate;
    public DateTime ReleaseDate { get; }
    [NullableContextAttribute("1")]
public ReleaseDateAttribute(string releaseDate);
    public DateTime get_ReleaseDate();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Newtonsoft.Json.Schema.Infrastructure.LimitedStream : Stream {
    private Stream _stream;
    private int _byteLimit;
    private int _totalBytesRead;
    public bool CanRead { get; }
    public bool CanSeek { get; }
    public bool CanWrite { get; }
    public long Length { get; }
    public long Position { get; public set; }
    public LimitedStream(Stream stream, int byteLimit);
    public virtual int Read(Byte[] buffer, int offset, int count);
    public virtual bool get_CanRead();
    public virtual bool get_CanSeek();
    public virtual bool get_CanWrite();
    public virtual void Flush();
    public virtual long get_Length();
    public virtual long get_Position();
    public virtual void set_Position(long value);
    public virtual long Seek(long offset, SeekOrigin origin);
    public virtual void SetLength(long value);
    public virtual void Write(Byte[] buffer, int offset, int count);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal static class Newtonsoft.Json.Schema.Infrastructure.MathHelpers : object {
    private static double DecimalDoubleMaxValue;
    private static double DecimalDoubleMinValue;
    private static double DoubleEpsilon;
    private static decimal DecimalEpsilon;
    private static decimal DecimalTolerance;
    private static double DoubleTolerance;
    private static BigInteger BigIntegerDecimalMaxValue;
    private static BigInteger BigIntegerDecimalMinValue;
    private static BigInteger BigIntegerDoubleMaxValue;
    private static MathHelpers();
    public static bool IsIntegerMultiple(object integer, double multipleOf);
    private static bool IsIntegerMultiple(object integer, decimal multipleOf);
    public static bool IsDoubleMultiple(object value, double multipleOf);
    public static bool IsDoubleMultiple(decimal value, decimal multipleOf);
    private static bool IsRemainderMultiple(decimal remainder, decimal multipleOf);
    private static bool IsRemainderMultiple(double remainder, double multipleOf);
    private static bool FitsInDecimal(double d);
    public static bool IsZero(decimal value);
    public static bool IsZero(double value);
}
internal class Newtonsoft.Json.Schema.Infrastructure.MethodCall`2 : MulticastDelegate {
    public MethodCall`2(object object, IntPtr method);
    [NullableContextAttribute("1")]
public virtual TResult Invoke(T target, Object[] args);
    public virtual IAsyncResult BeginInvoke(T target, Object[] args, AsyncCallback callback, object object);
    public virtual TResult EndInvoke(IAsyncResult result);
}
internal class Newtonsoft.Json.Schema.Infrastructure.ObjectConstructor`1 : MulticastDelegate {
    public ObjectConstructor`1(object object, IntPtr method);
    [NullableContextAttribute("1")]
public virtual object Invoke(Object[] args);
    public virtual IAsyncResult BeginInvoke(Object[] args, AsyncCallback callback, object object);
    public virtual object EndInvoke(IAsyncResult result);
}
internal enum Newtonsoft.Json.Schema.Infrastructure.PrimitiveTypeCode : Enum {
    public int value__;
    public static PrimitiveTypeCode Empty;
    public static PrimitiveTypeCode Object;
    public static PrimitiveTypeCode Char;
    public static PrimitiveTypeCode CharNullable;
    public static PrimitiveTypeCode Boolean;
    public static PrimitiveTypeCode BooleanNullable;
    public static PrimitiveTypeCode SByte;
    public static PrimitiveTypeCode SByteNullable;
    public static PrimitiveTypeCode Int16;
    public static PrimitiveTypeCode Int16Nullable;
    public static PrimitiveTypeCode UInt16;
    public static PrimitiveTypeCode UInt16Nullable;
    public static PrimitiveTypeCode Int32;
    public static PrimitiveTypeCode Int32Nullable;
    public static PrimitiveTypeCode Byte;
    public static PrimitiveTypeCode ByteNullable;
    public static PrimitiveTypeCode UInt32;
    public static PrimitiveTypeCode UInt32Nullable;
    public static PrimitiveTypeCode Int64;
    public static PrimitiveTypeCode Int64Nullable;
    public static PrimitiveTypeCode UInt64;
    public static PrimitiveTypeCode UInt64Nullable;
    public static PrimitiveTypeCode Single;
    public static PrimitiveTypeCode SingleNullable;
    public static PrimitiveTypeCode Double;
    public static PrimitiveTypeCode DoubleNullable;
    public static PrimitiveTypeCode DateTime;
    public static PrimitiveTypeCode DateTimeNullable;
    public static PrimitiveTypeCode DateTimeOffset;
    public static PrimitiveTypeCode DateTimeOffsetNullable;
    public static PrimitiveTypeCode Decimal;
    public static PrimitiveTypeCode DecimalNullable;
    public static PrimitiveTypeCode Guid;
    public static PrimitiveTypeCode GuidNullable;
    public static PrimitiveTypeCode TimeSpan;
    public static PrimitiveTypeCode TimeSpanNullable;
    public static PrimitiveTypeCode BigInteger;
    public static PrimitiveTypeCode BigIntegerNullable;
    public static PrimitiveTypeCode Uri;
    public static PrimitiveTypeCode String;
    public static PrimitiveTypeCode Bytes;
    public static PrimitiveTypeCode DBNull;
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal abstract class Newtonsoft.Json.Schema.Infrastructure.ReflectionDelegateFactory : object {
    private static Nullable`1<bool> _dynamicCodeGeneration;
    public static bool DynamicCodeGeneration { get; }
    public static ReflectionDelegateFactory SupportedInstance { get; }
    public static bool get_DynamicCodeGeneration();
    public static ReflectionDelegateFactory get_SupportedInstance();
    public Func`2<T, object> CreateGet(MemberInfo memberInfo);
    public Action`2<T, object> CreateSet(MemberInfo memberInfo);
    public abstract virtual MethodCall`2<T, object> CreateMethodCall(MethodBase method);
    public abstract virtual ObjectConstructor`1<object> CreateParameterizedConstructor(MethodBase method);
    public abstract virtual Func`1<T> CreateDefaultConstructor(Type type);
    public abstract virtual Func`2<T, object> CreateGet(PropertyInfo propertyInfo);
    public abstract virtual Func`2<T, object> CreateGet(FieldInfo fieldInfo);
    public abstract virtual Action`2<T, object> CreateSet(FieldInfo fieldInfo);
    public abstract virtual Action`2<T, object> CreateSet(PropertyInfo propertyInfo);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
internal class Newtonsoft.Json.Schema.Infrastructure.ReflectionMember : object {
    [CompilerGeneratedAttribute]
private Type <MemberType>k__BackingField;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private Func`2<object, object> <Getter>k__BackingField;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private Action`2<object, object> <Setter>k__BackingField;
    public Type MemberType { get; public set; }
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public Func`2<object, object> Getter { get; public set; }
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public Action`2<object, object> Setter { get; public set; }
    [CompilerGeneratedAttribute]
public Type get_MemberType();
    [CompilerGeneratedAttribute]
public void set_MemberType(Type value);
    [CompilerGeneratedAttribute]
public Func`2<object, object> get_Getter();
    [CompilerGeneratedAttribute]
public void set_Getter(Func`2<object, object> value);
    [CompilerGeneratedAttribute]
public Action`2<object, object> get_Setter();
    [CompilerGeneratedAttribute]
public void set_Setter(Action`2<object, object> value);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Newtonsoft.Json.Schema.Infrastructure.ReflectionObject : object {
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private ObjectConstructor`1<object> <Creator>k__BackingField;
    [CompilerGeneratedAttribute]
private IDictionary`2<string, ReflectionMember> <Members>k__BackingField;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ObjectConstructor`1<object> Creator { get; }
    public IDictionary`2<string, ReflectionMember> Members { get; }
    private ReflectionObject(ObjectConstructor`1<object> creator);
    [CompilerGeneratedAttribute]
public ObjectConstructor`1<object> get_Creator();
    [CompilerGeneratedAttribute]
public IDictionary`2<string, ReflectionMember> get_Members();
    public object GetValue(object target, string member);
    public void SetValue(object target, string member, object value);
    public Type GetType(string member);
    public static ReflectionObject Create(Type t, String[] memberNames);
    public static ReflectionObject Create(Type t, MethodBase creator, String[] memberNames);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Newtonsoft.Json.Schema.Infrastructure.ReflectionUtils : object {
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private static ThreadSafeStore`2<Type, Type> AssociatedMetadataTypesCache;
    [NullableAttribute("2")]
private static ReflectionObject _metadataTypeAttributeReflectionObject;
    private static ReflectionUtils();
    public static bool HasDefaultConstructor(Type t, bool nonPublic);
    public static ConstructorInfo GetDefaultConstructor(Type t);
    public static ConstructorInfo GetDefaultConstructor(Type t, bool nonPublic);
    public static bool IsNullable(Type t);
    public static bool IsNullableType(Type t);
    public static T GetAttribute(object attributeProvider);
    public static T GetAttribute(object attributeProvider, bool inherit);
    public static T[] GetAttributes(object attributeProvider, bool inherit);
    public static Attribute[] GetAttributes(object attributeProvider, Type attributeType, bool inherit);
    public static T GetAttribute(Type type);
    private static Type GetAssociatedMetadataType(Type type);
    private static Type GetAssociateMetadataTypeFromAttribute(Type type);
    public static bool CanReadMemberValue(MemberInfo member, bool nonPublic);
    public static bool CanSetMemberValue(MemberInfo member, bool nonPublic, bool canSetReadOnly);
    public static Type GetMemberUnderlyingType(MemberInfo member);
}
internal static class Newtonsoft.Json.Schema.Infrastructure.RegexHelpers : object {
    private static RegexOptions Options;
    [NullableContextAttribute("1")]
public static bool IsMatch(Regex regex, string pattern, string value);
    [NullableContextAttribute("2")]
public static bool TryGetPatternRegex(string pattern, Nullable`1<TimeSpan> matchTimeout, Regex& regex, String& errorMessage);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal static class Newtonsoft.Json.Schema.Infrastructure.SchemaVersionHelpers : object {
    private static SchemaVersionMap[] VersionMap;
    private static ThreadSafeStore`2<string, JSchema> SpecSchemaCache;
    private static SchemaVersionHelpers();
    private static JSchema LoadResourceSchema(string name);
    public static bool EnsureVersion(SchemaVersion currentVersion, SchemaVersion minimum, Nullable`1<SchemaVersion> maximum);
    [NullableContextAttribute("2")]
public static SchemaVersion MapSchemaUri(Uri schemaVersionUri);
    [NullableContextAttribute("2")]
public static JSchema GetSchema(SchemaVersion version);
    [NullableContextAttribute("2")]
public static Uri MapSchemaVersion(Nullable`1<SchemaVersion> schemaVersion);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Newtonsoft.Json.Schema.Infrastructure.SetSchema : object {
    private Action`1<JSchema> _setAction;
    [NullableAttribute("2")]
private JSchema _target;
    public SetSchema(Action`1<JSchema> setAction, JSchema target);
    public void Execute(JSchema schema);
}
internal static class Newtonsoft.Json.Schema.Infrastructure.StreamHelpers : object {
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
internal static class Newtonsoft.Json.Schema.Infrastructure.StringHelpers : object {
    public static string Join(string separator, IEnumerable`1<T> values);
    [ExtensionAttribute]
public static StringBuilder TrimEnd(StringBuilder sb);
    public static bool IsBase64String(string value);
    private static bool IsInvalid(char value);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
internal static class Newtonsoft.Json.Schema.Infrastructure.StringUtils : object {
    [ExtensionAttribute]
public static string FormatWith(string format, IFormatProvider provider, object arg0);
    [ExtensionAttribute]
public static string FormatWith(string format, IFormatProvider provider, object arg0, object arg1);
    [ExtensionAttribute]
public static string FormatWith(string format, IFormatProvider provider, object arg0, object arg1, object arg2);
    [NullableContextAttribute("2")]
[ExtensionAttribute]
public static string FormatWith(string format, IFormatProvider provider, object arg0, object arg1, object arg2, object arg3);
    [ExtensionAttribute]
private static string FormatWith(string format, IFormatProvider provider, Object[] args);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[IsReadOnlyAttribute]
internal class Newtonsoft.Json.Schema.Infrastructure.StructMultiKey`2 : ValueType {
    public T1 Value1;
    public T2 Value2;
    public StructMultiKey`2(T1 v1, T2 v2);
    public virtual int GetHashCode();
    public virtual bool Equals(object obj);
    public sealed virtual bool Equals(StructMultiKey`2<T1, T2> other);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Newtonsoft.Json.Schema.Infrastructure.ThreadSafeStore`2 : object {
    private object _lock;
    private Dictionary`2<TKey, TValue> _store;
    private Func`2<TKey, TValue> _creator;
    public ThreadSafeStore`2(Func`2<TKey, TValue> creator);
    public TValue Get(TKey key);
    private TValue AddValue(TKey key);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
internal static class Newtonsoft.Json.Schema.Infrastructure.TypeExtensions : object {
    [ExtensionAttribute]
public static MethodInfo Method(Delegate d);
    [ExtensionAttribute]
public static MemberTypes MemberType(MemberInfo memberInfo);
    [ExtensionAttribute]
public static bool ContainsGenericParameters(Type type);
    [ExtensionAttribute]
public static bool IsInterface(Type type);
    [ExtensionAttribute]
public static bool IsGenericType(Type type);
    [ExtensionAttribute]
public static bool IsGenericTypeDefinition(Type type);
    [ExtensionAttribute]
public static Type BaseType(Type type);
    [ExtensionAttribute]
public static Assembly Assembly(Type type);
    [ExtensionAttribute]
public static bool IsEnum(Type type);
    [ExtensionAttribute]
public static bool IsClass(Type type);
    [ExtensionAttribute]
public static bool IsSealed(Type type);
    [ExtensionAttribute]
public static bool IsAbstract(Type type);
    [ExtensionAttribute]
public static bool IsVisible(Type type);
    [ExtensionAttribute]
public static bool IsValueType(Type type);
    [ExtensionAttribute]
public static bool IsPrimitive(Type type);
    [ExtensionAttribute]
public static bool AssignableToTypeName(Type type, string fullTypeName, bool searchInterfaces, Type& match);
    [ExtensionAttribute]
public static bool AssignableToTypeName(Type type, string fullTypeName, bool searchInterfaces);
    [ExtensionAttribute]
public static bool ImplementInterface(Type type, Type interfaceType);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Newtonsoft.Json.Schema.Infrastructure.UriComparer : object {
    public static UriComparer Instance;
    private static UriComparer();
    [NullableContextAttribute("2")]
public sealed virtual bool Equals(Uri x, Uri y);
    public sealed virtual int GetHashCode(Uri obj);
    private string ResolveFragment(Uri uri);
}
internal class Newtonsoft.Json.Schema.Infrastructure.Validation.AllOfScope : ConditionalScope {
    [NullableContextAttribute("2")]
protected virtual bool EvaluateTokenCore(JsonToken token, object value, int depth);
}
internal class Newtonsoft.Json.Schema.Infrastructure.Validation.AlwaysFalseScope : SchemaScope {
    [NullableAttribute("1")]
internal static AlwaysFalseScope Instance;
    private static AlwaysFalseScope();
    [NullableContextAttribute("2")]
protected virtual bool EvaluateTokenCore(JsonToken token, object value, int depth);
}
internal class Newtonsoft.Json.Schema.Infrastructure.Validation.AnyOfScope : ConditionalScope {
    [NullableContextAttribute("2")]
protected virtual bool EvaluateTokenCore(JsonToken token, object value, int depth);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Newtonsoft.Json.Schema.Infrastructure.Validation.ArrayScope : SchemaScope {
    private int _index;
    private int _matchCount;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private List`1<JToken> _uniqueArrayItems;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private List`1<ConditionalContext> _containsContexts;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private Dictionary`2<int, UnevaluatedContext> _unevaluatedScopes;
    public void Initialize(ContextBase context, SchemaScope parent, int initialDepth, JSchema schema);
    public virtual bool ShouldValidateUnevaluated();
    protected virtual void OnConditionalScopeValidated(ConditionalScope conditionalScope);
    [NullableContextAttribute("2")]
protected virtual bool EvaluateTokenCore(JsonToken token, object value, int depth);
    private List`1<ValidationError> GetValidationErrors(IList`1<ConditionalContext> contexts);
    [MemberNotNullWhenAttribute("True", "_containsContexts")]
private bool ShouldEvaluateContains();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Newtonsoft.Json.Schema.Infrastructure.Validation.CompositeContext : ContextBase {
    [CompilerGeneratedAttribute]
private List`1<ContextBase> <Contexts>k__BackingField;
    public List`1<ContextBase> Contexts { get; }
    public bool HasErrors { get; }
    public List`1<JSchema> EvaluatedSchemas { get; }
    public bool TrackEvaluatedSchemas { get; }
    public CompositeContext(Validator validator);
    [CompilerGeneratedAttribute]
public List`1<ContextBase> get_Contexts();
    public virtual bool get_HasErrors();
    public virtual void RaiseError(IFormattable message, ErrorType errorType, JSchema schema, object value, IList`1<ValidationError> childErrors);
    public sealed virtual List`1<JSchema> get_EvaluatedSchemas();
    public sealed virtual bool get_TrackEvaluatedSchemas();
    public sealed virtual void TrackEvaluatedSchema(JSchema schema);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Newtonsoft.Json.Schema.Infrastructure.Validation.ConditionalContext : ContextBase {
    [NullableAttribute("2")]
private ISchemaTracker _parentSchemaTracker;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public List`1<ValidationError> Errors;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private List`1<JSchema> <EvaluatedSchemas>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <TrackEvaluatedSchemas>k__BackingField;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public List`1<JSchema> EvaluatedSchemas { get; private set; }
    public bool TrackEvaluatedSchemas { get; }
    [MemberNotNullWhenAttribute("True", "Errors")]
public bool HasErrors { get; }
    public ConditionalContext(Validator validator, ContextBase parentContext, bool trackEvaluatedSchemas);
    [CompilerGeneratedAttribute]
public sealed virtual List`1<JSchema> get_EvaluatedSchemas();
    [CompilerGeneratedAttribute]
private void set_EvaluatedSchemas(List`1<JSchema> value);
    [CompilerGeneratedAttribute]
public sealed virtual bool get_TrackEvaluatedSchemas();
    public virtual void RaiseError(IFormattable message, ErrorType errorType, JSchema schema, object value, IList`1<ValidationError> childErrors);
    public sealed virtual void TrackEvaluatedSchema(JSchema schema);
    public static ConditionalContext Create(ContextBase context, bool trackEvaluatedSchemas);
    [MemberNotNullWhenAttribute("True", "Errors")]
public virtual bool get_HasErrors();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[DebuggerDisplayAttribute("{DebuggerDisplay,nq}")]
internal abstract class Newtonsoft.Json.Schema.Infrastructure.Validation.ConditionalScope : Scope {
    protected ConditionalContext ConditionalContext;
    protected SchemaScope ParentSchemaScope;
    protected List`1<SchemaScope> ChildScopes;
    internal string DebuggerDisplay { get; }
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public List`1<JSchema> EvaluatedSchemas { get; }
    internal string get_DebuggerDisplay();
    public virtual void Initialize(ContextBase context, SchemaScope parent, int initialDepth, ScopeType type);
    public List`1<JSchema> get_EvaluatedSchemas();
    public void InitializeScopes(JsonToken token, List`1<JSchema> schemas, int scopeIndex);
    public void InitializeScope(JsonToken token, int scopeIndex, JSchema schema, ContextBase context);
    protected SchemaScope GetExistingSchemaScope(JSchema schema, Int32& scopeCurrentIndex);
    [NullableContextAttribute("2")]
protected int GetChildrenValidCount(JsonToken token, object value, int depth);
    [NullableContextAttribute("2")]
protected bool GetChildrenAnyValid(JsonToken token, object value, int depth);
    [NullableContextAttribute("2")]
protected bool GetChildrenAllValid(JsonToken token, object value, int depth);
    [NullableContextAttribute("2")]
protected SchemaScope GetSchemaScopeBySchema(JSchema schema, JsonToken token, object value, int depth);
    private void AssertScopeComplete(SchemaScope schemaScope, JsonToken token, object value, int depth);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal abstract class Newtonsoft.Json.Schema.Infrastructure.Validation.ContextBase : object {
    public Validator Validator;
    public List`1<Scope> Scopes { get; }
    [NullableAttribute("2")]
public JTokenWriter TokenWriter { get; public set; }
    public bool HasErrors { get; }
    protected ContextBase(Validator validator);
    [DebuggerStepThroughAttribute]
public List`1<Scope> get_Scopes();
    [NullableContextAttribute("2")]
public JTokenWriter get_TokenWriter();
    [NullableContextAttribute("2")]
public void set_TokenWriter(JTokenWriter value);
    public abstract virtual void RaiseError(IFormattable message, ErrorType errorType, JSchema schema, object value, IList`1<ValidationError> childErrors);
    public abstract virtual bool get_HasErrors();
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
internal class Newtonsoft.Json.Schema.Infrastructure.Validation.IfThenElseScope : ConditionalScope {
    public ConditionalContext ThenContext;
    public ConditionalContext ElseContext;
    public JSchema If;
    public JSchema Then;
    public JSchema Else;
    [NullableContextAttribute("1")]
public virtual void Initialize(ContextBase context, SchemaScope parent, int initialDepth, ScopeType type);
    protected virtual bool EvaluateTokenCore(JsonToken token, object value, int depth);
    public void InitializeScopes(JsonToken token, int scopeIndex);
    [NullableContextAttribute("1")]
private void InitializeScope(JsonToken token, int scopeIndex, JSchema schema, ConditionalContext context);
}
[NullableContextAttribute("1")]
internal interface Newtonsoft.Json.Schema.Infrastructure.Validation.ISchemaTracker {
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public List`1<JSchema> EvaluatedSchemas { get; }
    public bool TrackEvaluatedSchemas { get; }
    public abstract virtual void TrackEvaluatedSchema(JSchema schema);
    public abstract virtual List`1<JSchema> get_EvaluatedSchemas();
    public abstract virtual bool get_TrackEvaluatedSchemas();
}
internal class Newtonsoft.Json.Schema.Infrastructure.Validation.NotScope : ConditionalScope {
    [NullableContextAttribute("2")]
protected virtual bool EvaluateTokenCore(JsonToken token, object value, int depth);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Newtonsoft.Json.Schema.Infrastructure.Validation.ObjectScope : SchemaScope {
    private int _propertyCount;
    [NullableAttribute("2")]
private string _currentPropertyName;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private List`1<string> _requiredProperties;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private List`1<string> _readProperties;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private Dictionary`2<string, SchemaScope> _dependencyScopes;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private Dictionary`2<string, UnevaluatedContext> _unevaluatedScopes;
    public void Initialize(ContextBase context, SchemaScope parent, int initialDepth, JSchema schema);
    public virtual bool ShouldValidateUnevaluated();
    protected virtual void OnConditionalScopeValidated(ConditionalScope conditionalScope);
    [NullableContextAttribute("2")]
protected virtual bool EvaluateTokenCore(JsonToken token, object value, int depth);
    private bool HasDependencies();
    private void ValidateDependantSchema(string readProperty);
    private void ValidateDependantProperties(string readProperty, IList`1<string> requiredProperties);
    private bool IsPropertyDefined(JSchema schema, string propertyName);
    public void InitializeScopes(JsonToken token);
    [NullableContextAttribute("0")]
[CompilerGeneratedAttribute]
private bool <ValidateDependantProperties>b__12_0(string r);
    [NullableContextAttribute("0")]
[CompilerGeneratedAttribute]
private bool <ValidateDependantProperties>b__12_1(string r);
}
internal class Newtonsoft.Json.Schema.Infrastructure.Validation.OneOfScope : ConditionalScope {
    [NullableContextAttribute("2")]
protected virtual bool EvaluateTokenCore(JsonToken token, object value, int depth);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Newtonsoft.Json.Schema.Infrastructure.Validation.PrimativeScope : SchemaScope {
    private static Regex HostnameRegex;
    private static Char[] CaseInsensitiveDateTimeChars;
    private static PrimativeScope();
    public void Initialize(ContextBase context, SchemaScope parent, int initialDepth, JSchema schema);
    [NullableContextAttribute("2")]
protected virtual bool EvaluateTokenCore(JsonToken token, object value, int depth);
    private bool ValidateNull(JSchema schema, object value);
    private bool ValidateBoolean(JSchema schema, object value);
    private bool ValidateInteger(JSchema schema, object value);
    internal static bool ValidateString(SchemaScope scope, JSchema schema, string value);
    private static bool ValidateFormat(string format, string value);
    private bool ValidateNumber(JSchema schema, object value);
}
internal class Newtonsoft.Json.Schema.Infrastructure.Validation.RefScope : ConditionalScope {
    private bool _isReentrant;
    [NullableContextAttribute("2")]
protected virtual bool EvaluateTokenCore(JsonToken token, object value, int depth);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[DebuggerDisplayAttribute("{DebuggerDisplay,nq}")]
internal abstract class Newtonsoft.Json.Schema.Infrastructure.Validation.SchemaScope : Scope {
    public JSchema Schema;
    public bool IsValid;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public List`1<ConditionalScope> ConditionalChildren;
    internal string DebuggerDisplay { get; }
    protected void InitializeSchema(JSchema schema);
    public virtual bool ShouldValidateUnevaluated();
    public ConditionalContext CreateConditionalContext();
    private void AddChildScope(ConditionalScope scope);
    internal string get_DebuggerDisplay();
    public static SchemaScope CreateTokenScope(JsonToken token, JSchema schema, ContextBase context, SchemaScope parent, int depth);
    [NullableContextAttribute("2")]
protected void EnsureValid(object value);
    internal static void EnsureValid(SchemaScope scope, JSchema schema, object value);
    [NullableContextAttribute("2")]
protected void ValidateConditionalChildren(JsonToken token, object value, int depth);
    protected virtual void OnConditionalScopeValidated(ConditionalScope conditionalScope);
    [NullableContextAttribute("2")]
protected void EnsureEnum(JsonToken token, object value);
    protected bool TestType(JSchema currentSchema, JSchemaType currentType);
    [NullableContextAttribute("2")]
protected bool TestType(JSchema currentSchema, JSchemaType currentType, T value);
    internal static bool TestType(SchemaScope scope, JSchema currentSchema, JSchemaType currentType, T value);
    protected SchemaScope CreateScopesAndEvaluateToken(JsonToken token, object value, int depth, JSchema schema);
    protected SchemaScope CreateScopesAndEvaluateToken(JsonToken token, object value, int depth, JSchema schema, SchemaScope parent, ContextBase context);
    internal virtual void RaiseError(IFormattable message, ErrorType errorType, JSchema schema, object value, IList`1<ValidationError> childErrors);
    internal IList`1<ValidationError> GetValidationErrors();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal abstract class Newtonsoft.Json.Schema.Infrastructure.Validation.Scope : object {
    public int InitialDepth;
    public ContextBase Context;
    [NullableAttribute("2")]
public SchemaScope Parent;
    public ScopeType Type;
    public bool Complete;
    public virtual void Initialize(ContextBase context, SchemaScope parent, int initialDepth, ScopeType type);
    internal virtual void RaiseError(IFormattable message, ErrorType errorType, JSchema schema, object value, IList`1<ValidationError> childErrors);
    [NullableContextAttribute("2")]
public void EvaluateToken(JsonToken token, object value, int depth);
    [NullableContextAttribute("2")]
protected abstract virtual bool EvaluateTokenCore(JsonToken token, object value, int depth);
}
internal enum Newtonsoft.Json.Schema.Infrastructure.Validation.ScopeType : Enum {
    public int value__;
    public static ScopeType Object;
    public static ScopeType Array;
    public static ScopeType Primitive;
    public static ScopeType AllOf;
    public static ScopeType AnyOf;
    public static ScopeType OneOf;
    public static ScopeType Not;
    public static ScopeType IfThenElse;
    public static ScopeType Ref;
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Newtonsoft.Json.Schema.Infrastructure.Validation.UnevaluatedContext : object {
    [CompilerGeneratedAttribute]
private SchemaScope <SchemaScope>k__BackingField;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private List`1<JSchema> <ValidScopes>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <Evaluated>k__BackingField;
    public SchemaScope SchemaScope { get; }
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public List`1<JSchema> ValidScopes { get; public set; }
    public bool Evaluated { get; public set; }
    public UnevaluatedContext(SchemaScope schemaScope);
    [CompilerGeneratedAttribute]
public SchemaScope get_SchemaScope();
    [CompilerGeneratedAttribute]
public List`1<JSchema> get_ValidScopes();
    [CompilerGeneratedAttribute]
public void set_ValidScopes(List`1<JSchema> value);
    [CompilerGeneratedAttribute]
public bool get_Evaluated();
    [CompilerGeneratedAttribute]
public void set_Evaluated(bool value);
    public void AddValidScope(JSchema schema);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal abstract class Newtonsoft.Json.Schema.Infrastructure.Validation.Validator : object {
    private List`1<Scope> _scopes;
    private List`1<Scope> _scopesCache;
    private object _publicValidator;
    private ValidatorContext _context;
    private bool _knownSchemasPopulated;
    private Nullable`1<SchemaVersion> _schemaVersion;
    private bool _hasValidatedLicense;
    [NullableAttribute("2")]
public JTokenWriter TokenWriter;
    [NullableAttribute("2")]
public JSchema Schema;
    [NullableAttribute("2")]
[CompilerGeneratedAttribute]
private SchemaValidationEventHandler ValidationEventHandler;
    public Nullable`1<TimeSpan> RegexMatchTimeout;
    public List`1<Scope> Scopes { get; }
    public SchemaVersion SchemaVersion { get; }
    protected Validator(object publicValidator);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public void add_ValidationEventHandler(SchemaValidationEventHandler value);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public void remove_ValidationEventHandler(SchemaValidationEventHandler value);
    [DebuggerStepThroughAttribute]
public List`1<Scope> get_Scopes();
    public abstract virtual ValidationError CreateError(IFormattable message, ErrorType errorType, JSchema schema, object value, IList`1<ValidationError> childErrors);
    public void RaiseError(IFormattable message, ErrorType errorType, JSchema schema, object value, IList`1<ValidationError> childErrors);
    public void RaiseError(ValidationError error);
    public SchemaVersion get_SchemaVersion();
    private void PopulateSchemaId(ValidationError error);
    protected ValidationError CreateError(IFormattable message, ErrorType errorType, JSchema schema, object value, IList`1<ValidationError> childErrors, IJsonLineInfo lineInfo, string path);
    [NullableContextAttribute("2")]
public void ValidateCurrentToken(JsonToken token, object value, int depth);
    private void RemoveCompletedScopes();
    [NullableContextAttribute("0")]
public T GetCachedScope(ScopeType type);
    public void ReturnScopeToCache(Scope scope);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Newtonsoft.Json.Schema.Infrastructure.Validation.ValidatorContext : ContextBase {
    private bool _hasErrors;
    public bool HasErrors { get; }
    public ValidatorContext(Validator validator);
    public virtual void RaiseError(IFormattable message, ErrorType errorType, JSchema schema, object value, IList`1<ValidationError> childErrors);
    public virtual bool get_HasErrors();
}
internal static class Newtonsoft.Json.Schema.Infrastructure.ValidationUtils : object {
    [NullableContextAttribute("1")]
public static void ArgumentNotNull(object value, string parameterName);
    [NullableContextAttribute("2")]
[ConditionalAttribute("DEBUG")]
public static void Assert(bool condition, string message);
}
internal class Newtonsoft.Json.Schema.Infrastructure.WebRequestDownloader : object {
    [NullableContextAttribute("1")]
public sealed virtual Stream GetStream(Uri uri, ICredentials credentials, Nullable`1<int> timeout, Nullable`1<int> byteLimit);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
[JsonConverterAttribute("Newtonsoft.Json.Schema.Infrastructure.JSchemaConverter")]
[DebuggerDisplayAttribute("{DebuggerDisplay,nq}")]
public class Newtonsoft.Json.Schema.JSchema : object {
    [CompilerGeneratedAttribute]
private bool <DeprecatedRequired>k__BackingField;
    [CompilerGeneratedAttribute]
private JSchemaReader <InternalReader>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <HasNonRefContent>k__BackingField;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal Dictionary`2<string, JToken> _extensionData;
    internal JSchemaCollection _items;
    internal JSchemaCollection _anyOf;
    internal JSchemaCollection _allOf;
    internal JSchemaCollection _oneOf;
    internal JSchemaDependencyDictionary _dependencies;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal List`1<JToken> _enum;
    internal JSchemaDictionary _properties;
    internal JSchemaDictionary _patternProperties;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal List`1<string> _required;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal List`1<JsonValidator> _validators;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal Dictionary`2<string, IList`1<string>> _dependentRequired;
    internal JSchemaDictionary _dependentSchemas;
    private int _lineNumber;
    private int _linePosition;
    internal Uri _referencedAs;
    private string _pattern;
    private Regex _patternRegex;
    private string _patternError;
    private Uri _id;
    private string _anchor;
    private bool _itemsPositionValidation;
    private JSchema _ref;
    private JSchema _if;
    private JSchema _then;
    private JSchema _else;
    private JSchema _not;
    private JSchema _contains;
    internal JSchema _propertyNames;
    private JSchema _additionalProperties;
    private JSchema _unevaluatedProperties;
    private JSchema _additionalItems;
    private JSchema _unevaluatedItems;
    private JSchemaPatternDictionary _internalPatternProperties;
    internal Uri BaseUri;
    internal string Path;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private Action`1<JSchema> Changed;
    [NullableAttribute("1")]
internal KnownSchemaCollection KnownSchemas;
    internal JSchemaState State;
    private Nullable`1<double> _multipleOf;
    internal Nullable`1<bool> _allowAdditionalProperties;
    internal Nullable`1<bool> _allowAdditionalItems;
    [CompilerGeneratedAttribute]
private Uri <SchemaVersion>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<bool> <Valid>k__BackingField;
    [CompilerGeneratedAttribute]
private Uri <Reference>k__BackingField;
    [CompilerGeneratedAttribute]
private Uri <RecursiveReference>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<bool> <RecursiveAnchor>k__BackingField;
    [CompilerGeneratedAttribute]
private Uri <ResolvedId>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <Root>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<JSchemaType> <Type>k__BackingField;
    [CompilerGeneratedAttribute]
private JToken <Default>k__BackingField;
    [CompilerGeneratedAttribute]
private JToken <Const>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <UniqueItems>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<long> <MinimumLength>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<long> <MaximumLength>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<double> <Minimum>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<double> <Maximum>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <ExclusiveMinimum>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <ExclusiveMaximum>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<long> <MinimumItems>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<long> <MaximumItems>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<long> <MinimumProperties>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<long> <MaximumProperties>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<long> <MinimumContains>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<long> <MaximumContains>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ContentEncoding>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ContentMediaType>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<bool> <WriteOnly>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<bool> <ReadOnly>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Title>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Description>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<bool> <AllowUnevaluatedProperties>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<bool> <AllowUnevaluatedItems>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Format>k__BackingField;
    internal bool DeprecatedRequired { get; internal set; }
    internal JSchemaReader InternalReader { get; internal set; }
    internal bool HasNonRefContent { get; internal set; }
    public Uri SchemaVersion { get; public set; }
    public Nullable`1<bool> Valid { get; public set; }
    public Uri Reference { get; public set; }
    public JSchema Ref { get; public set; }
    public Uri RecursiveReference { get; public set; }
    internal bool HasReference { get; }
    public Nullable`1<bool> RecursiveAnchor { get; public set; }
    internal Uri ResolvedId { get; private set; }
    internal bool Root { get; internal set; }
    private Uri Newtonsoft.Json.Schema.Infrastructure.IIdentiferScope.ScopeId { get; }
    private bool Newtonsoft.Json.Schema.Infrastructure.IIdentiferScope.Root { get; }
    private string Newtonsoft.Json.Schema.Infrastructure.IIdentiferScope.DynamicAnchor { get; }
    public Uri Id { get; public set; }
    public string Anchor { get; public set; }
    public Nullable`1<JSchemaType> Type { get; public set; }
    public JToken Default { get; public set; }
    [NullableAttribute("1")]
public IDictionary`2<string, JSchema> Properties { get; }
    [NullableAttribute("1")]
public IList`1<JSchema> Items { get; }
    public bool ItemsPositionValidation { get; public set; }
    [NullableAttribute("1")]
public IList`1<string> Required { get; }
    [NullableAttribute("1")]
public IList`1<JSchema> AllOf { get; }
    [NullableAttribute("1")]
public IList`1<JSchema> AnyOf { get; }
    [NullableAttribute("1")]
public IList`1<JSchema> OneOf { get; }
    public JSchema If { get; public set; }
    public JSchema Then { get; public set; }
    public JSchema Else { get; public set; }
    public JSchema Not { get; public set; }
    public JSchema Contains { get; public set; }
    public JSchema PropertyNames { get; public set; }
    [NullableAttribute("1")]
public IList`1<JToken> Enum { get; }
    public JToken Const { get; public set; }
    public bool UniqueItems { get; public set; }
    public Nullable`1<long> MinimumLength { get; public set; }
    public Nullable`1<long> MaximumLength { get; public set; }
    public Nullable`1<double> Minimum { get; public set; }
    public Nullable`1<double> Maximum { get; public set; }
    public bool ExclusiveMinimum { get; public set; }
    public bool ExclusiveMaximum { get; public set; }
    public Nullable`1<long> MinimumItems { get; public set; }
    public Nullable`1<long> MaximumItems { get; public set; }
    public Nullable`1<long> MinimumProperties { get; public set; }
    public Nullable`1<long> MaximumProperties { get; public set; }
    public Nullable`1<long> MinimumContains { get; public set; }
    public Nullable`1<long> MaximumContains { get; public set; }
    public string ContentEncoding { get; public set; }
    public string ContentMediaType { get; public set; }
    public Nullable`1<bool> WriteOnly { get; public set; }
    public Nullable`1<bool> ReadOnly { get; public set; }
    [NullableAttribute("1")]
public IDictionary`2<string, JToken> ExtensionData { get; }
    public string Title { get; public set; }
    public string Description { get; public set; }
    public Nullable`1<double> MultipleOf { get; public set; }
    public string Pattern { get; public set; }
    [NullableAttribute("1")]
public IDictionary`2<string, object> Dependencies { get; }
    [NullableAttribute("1")]
public IDictionary`2<string, IList`1<string>> DependentRequired { get; }
    [NullableAttribute("1")]
public IDictionary`2<string, JSchema> DependentSchemas { get; }
    [NullableAttribute("1")]
public IDictionary`2<string, JSchema> PatternProperties { get; }
    public JSchema AdditionalProperties { get; public set; }
    public bool AllowAdditionalProperties { get; public set; }
    public bool AllowAdditionalPropertiesSpecified { get; public set; }
    internal bool HasAdditionalProperties { get; }
    public JSchema UnevaluatedProperties { get; public set; }
    public Nullable`1<bool> AllowUnevaluatedProperties { get; public set; }
    public JSchema AdditionalItems { get; public set; }
    public bool AllowAdditionalItems { get; public set; }
    public bool AllowAdditionalItemsSpecified { get; public set; }
    internal bool HasAdditionalItems { get; }
    public JSchema UnevaluatedItems { get; public set; }
    public Nullable`1<bool> AllowUnevaluatedItems { get; public set; }
    public string Format { get; public set; }
    [NullableAttribute("1")]
public List`1<JsonValidator> Validators { get; }
    private int Newtonsoft.Json.IJsonLineInfo.LineNumber { get; }
    private int Newtonsoft.Json.IJsonLineInfo.LinePosition { get; }
    [NullableAttribute("1")]
private string DebuggerDisplay { get; }
    [CompilerGeneratedAttribute]
internal bool get_DeprecatedRequired();
    [CompilerGeneratedAttribute]
internal void set_DeprecatedRequired(bool value);
    [CompilerGeneratedAttribute]
internal JSchemaReader get_InternalReader();
    [CompilerGeneratedAttribute]
internal void set_InternalReader(JSchemaReader value);
    [CompilerGeneratedAttribute]
internal bool get_HasNonRefContent();
    [CompilerGeneratedAttribute]
internal void set_HasNonRefContent(bool value);
    [CompilerGeneratedAttribute]
internal void add_Changed(Action`1<JSchema> value);
    [CompilerGeneratedAttribute]
internal void remove_Changed(Action`1<JSchema> value);
    [NullableContextAttribute("1")]
internal void OnChildChanged(JSchema changedSchema);
    internal void OnSelfChanged();
    [NullableContextAttribute("1")]
private void OnChanged(JSchema changedSchema);
    [NullableContextAttribute("1")]
internal IEnumerable`1<PatternSchema> GetPatternSchemas();
    [CompilerGeneratedAttribute]
public Uri get_SchemaVersion();
    [CompilerGeneratedAttribute]
public void set_SchemaVersion(Uri value);
    [CompilerGeneratedAttribute]
public Nullable`1<bool> get_Valid();
    [CompilerGeneratedAttribute]
public void set_Valid(Nullable`1<bool> value);
    [CompilerGeneratedAttribute]
public Uri get_Reference();
    [CompilerGeneratedAttribute]
public void set_Reference(Uri value);
    public JSchema get_Ref();
    public void set_Ref(JSchema value);
    [CompilerGeneratedAttribute]
public Uri get_RecursiveReference();
    [CompilerGeneratedAttribute]
public void set_RecursiveReference(Uri value);
    internal bool get_HasReference();
    [CompilerGeneratedAttribute]
public Nullable`1<bool> get_RecursiveAnchor();
    [CompilerGeneratedAttribute]
public void set_RecursiveAnchor(Nullable`1<bool> value);
    [CompilerGeneratedAttribute]
internal Uri get_ResolvedId();
    [CompilerGeneratedAttribute]
private void set_ResolvedId(Uri value);
    [CompilerGeneratedAttribute]
internal bool get_Root();
    [CompilerGeneratedAttribute]
internal void set_Root(bool value);
    private sealed virtual override Uri Newtonsoft.Json.Schema.Infrastructure.IIdentiferScope.get_ScopeId();
    private sealed virtual override bool Newtonsoft.Json.Schema.Infrastructure.IIdentiferScope.get_Root();
    private sealed virtual override string Newtonsoft.Json.Schema.Infrastructure.IIdentiferScope.get_DynamicAnchor();
    public Uri get_Id();
    public void set_Id(Uri value);
    public string get_Anchor();
    public void set_Anchor(string value);
    [CompilerGeneratedAttribute]
public Nullable`1<JSchemaType> get_Type();
    [CompilerGeneratedAttribute]
public void set_Type(Nullable`1<JSchemaType> value);
    [CompilerGeneratedAttribute]
public JToken get_Default();
    [CompilerGeneratedAttribute]
public void set_Default(JToken value);
    [NullableContextAttribute("1")]
public IDictionary`2<string, JSchema> get_Properties();
    [NullableContextAttribute("1")]
public IList`1<JSchema> get_Items();
    public bool get_ItemsPositionValidation();
    public void set_ItemsPositionValidation(bool value);
    [NullableContextAttribute("1")]
public IList`1<string> get_Required();
    [NullableContextAttribute("1")]
public IList`1<JSchema> get_AllOf();
    [NullableContextAttribute("1")]
public IList`1<JSchema> get_AnyOf();
    [NullableContextAttribute("1")]
public IList`1<JSchema> get_OneOf();
    public JSchema get_If();
    public void set_If(JSchema value);
    public JSchema get_Then();
    public void set_Then(JSchema value);
    public JSchema get_Else();
    public void set_Else(JSchema value);
    public JSchema get_Not();
    public void set_Not(JSchema value);
    public JSchema get_Contains();
    public void set_Contains(JSchema value);
    public JSchema get_PropertyNames();
    public void set_PropertyNames(JSchema value);
    private void SetSchema(JSchema& schema, JSchema newSchema);
    [NullableContextAttribute("1")]
public IList`1<JToken> get_Enum();
    [CompilerGeneratedAttribute]
public JToken get_Const();
    [CompilerGeneratedAttribute]
public void set_Const(JToken value);
    [CompilerGeneratedAttribute]
public bool get_UniqueItems();
    [CompilerGeneratedAttribute]
public void set_UniqueItems(bool value);
    [CompilerGeneratedAttribute]
public Nullable`1<long> get_MinimumLength();
    [CompilerGeneratedAttribute]
public void set_MinimumLength(Nullable`1<long> value);
    [CompilerGeneratedAttribute]
public Nullable`1<long> get_MaximumLength();
    [CompilerGeneratedAttribute]
public void set_MaximumLength(Nullable`1<long> value);
    [CompilerGeneratedAttribute]
public Nullable`1<double> get_Minimum();
    [CompilerGeneratedAttribute]
public void set_Minimum(Nullable`1<double> value);
    [CompilerGeneratedAttribute]
public Nullable`1<double> get_Maximum();
    [CompilerGeneratedAttribute]
public void set_Maximum(Nullable`1<double> value);
    [CompilerGeneratedAttribute]
public bool get_ExclusiveMinimum();
    [CompilerGeneratedAttribute]
public void set_ExclusiveMinimum(bool value);
    [CompilerGeneratedAttribute]
public bool get_ExclusiveMaximum();
    [CompilerGeneratedAttribute]
public void set_ExclusiveMaximum(bool value);
    [CompilerGeneratedAttribute]
public Nullable`1<long> get_MinimumItems();
    [CompilerGeneratedAttribute]
public void set_MinimumItems(Nullable`1<long> value);
    [CompilerGeneratedAttribute]
public Nullable`1<long> get_MaximumItems();
    [CompilerGeneratedAttribute]
public void set_MaximumItems(Nullable`1<long> value);
    [CompilerGeneratedAttribute]
public Nullable`1<long> get_MinimumProperties();
    [CompilerGeneratedAttribute]
public void set_MinimumProperties(Nullable`1<long> value);
    [CompilerGeneratedAttribute]
public Nullable`1<long> get_MaximumProperties();
    [CompilerGeneratedAttribute]
public void set_MaximumProperties(Nullable`1<long> value);
    [CompilerGeneratedAttribute]
public Nullable`1<long> get_MinimumContains();
    [CompilerGeneratedAttribute]
public void set_MinimumContains(Nullable`1<long> value);
    [CompilerGeneratedAttribute]
public Nullable`1<long> get_MaximumContains();
    [CompilerGeneratedAttribute]
public void set_MaximumContains(Nullable`1<long> value);
    [CompilerGeneratedAttribute]
public string get_ContentEncoding();
    [CompilerGeneratedAttribute]
public void set_ContentEncoding(string value);
    [CompilerGeneratedAttribute]
public string get_ContentMediaType();
    [CompilerGeneratedAttribute]
public void set_ContentMediaType(string value);
    [CompilerGeneratedAttribute]
public Nullable`1<bool> get_WriteOnly();
    [CompilerGeneratedAttribute]
public void set_WriteOnly(Nullable`1<bool> value);
    [CompilerGeneratedAttribute]
public Nullable`1<bool> get_ReadOnly();
    [CompilerGeneratedAttribute]
public void set_ReadOnly(Nullable`1<bool> value);
    [NullableContextAttribute("1")]
public IDictionary`2<string, JToken> get_ExtensionData();
    [NullableContextAttribute("1")]
public static JToken op_Implicit(JSchema s);
    [NullableContextAttribute("1")]
public static JSchema op_Explicit(JToken t);
    [NullableContextAttribute("1")]
public void WriteTo(JsonWriter writer);
    [NullableContextAttribute("1")]
public void WriteTo(JsonWriter writer, JSchemaWriterSettings settings);
    [NullableContextAttribute("1")]
private void WriteToInternal(JsonWriter writer, JSchemaWriterSettings settings);
    [NullableContextAttribute("1")]
public virtual string ToString();
    [NullableContextAttribute("1")]
public string ToString(SchemaVersion version);
    [NullableContextAttribute("1")]
public string ToString(JSchemaWriterSettings settings);
    [NullableContextAttribute("1")]
private string ToStringInternal(JSchemaWriterSettings settings);
    [CompilerGeneratedAttribute]
public string get_Title();
    [CompilerGeneratedAttribute]
public void set_Title(string value);
    [CompilerGeneratedAttribute]
public string get_Description();
    [CompilerGeneratedAttribute]
public void set_Description(string value);
    public Nullable`1<double> get_MultipleOf();
    public void set_MultipleOf(Nullable`1<double> value);
    public string get_Pattern();
    public void set_Pattern(string value);
    internal bool TryGetPatternRegex(Nullable`1<TimeSpan> matchTimeout, Regex& regex, String& errorMessage);
    [NullableContextAttribute("1")]
public IDictionary`2<string, object> get_Dependencies();
    [NullableContextAttribute("1")]
public IDictionary`2<string, IList`1<string>> get_DependentRequired();
    [NullableContextAttribute("1")]
public IDictionary`2<string, JSchema> get_DependentSchemas();
    [NullableContextAttribute("1")]
public IDictionary`2<string, JSchema> get_PatternProperties();
    public JSchema get_AdditionalProperties();
    public void set_AdditionalProperties(JSchema value);
    public bool get_AllowAdditionalProperties();
    public void set_AllowAdditionalProperties(bool value);
    public bool get_AllowAdditionalPropertiesSpecified();
    public void set_AllowAdditionalPropertiesSpecified(bool value);
    internal bool get_HasAdditionalProperties();
    public JSchema get_UnevaluatedProperties();
    public void set_UnevaluatedProperties(JSchema value);
    [CompilerGeneratedAttribute]
public Nullable`1<bool> get_AllowUnevaluatedProperties();
    [CompilerGeneratedAttribute]
public void set_AllowUnevaluatedProperties(Nullable`1<bool> value);
    public JSchema get_AdditionalItems();
    public void set_AdditionalItems(JSchema value);
    public bool get_AllowAdditionalItems();
    public void set_AllowAdditionalItems(bool value);
    public bool get_AllowAdditionalItemsSpecified();
    public void set_AllowAdditionalItemsSpecified(bool value);
    internal bool get_HasAdditionalItems();
    public JSchema get_UnevaluatedItems();
    public void set_UnevaluatedItems(JSchema value);
    [CompilerGeneratedAttribute]
public Nullable`1<bool> get_AllowUnevaluatedItems();
    [CompilerGeneratedAttribute]
public void set_AllowUnevaluatedItems(Nullable`1<bool> value);
    [CompilerGeneratedAttribute]
public string get_Format();
    [CompilerGeneratedAttribute]
public void set_Format(string value);
    [NullableContextAttribute("1")]
public List`1<JsonValidator> get_Validators();
    [NullableContextAttribute("1")]
public static JSchema Load(JsonReader reader);
    [NullableContextAttribute("1")]
public static JSchema Load(JsonReader reader, JSchemaResolver resolver);
    [NullableContextAttribute("1")]
public static JSchema Load(JsonReader reader, JSchemaReaderSettings settings);
    [NullableContextAttribute("1")]
public static JSchema Parse(string json);
    [NullableContextAttribute("1")]
public static JSchema Parse(string json, JSchemaResolver resolver);
    [NullableContextAttribute("1")]
public static JSchema Parse(string json, JSchemaReaderSettings settings);
    private sealed virtual override bool Newtonsoft.Json.IJsonLineInfo.HasLineInfo();
    private sealed virtual override int Newtonsoft.Json.IJsonLineInfo.get_LineNumber();
    private sealed virtual override int Newtonsoft.Json.IJsonLineInfo.get_LinePosition();
    [NullableContextAttribute("1")]
internal void SetLineInfo(IJsonLineInfo lineInfo);
    [NullableContextAttribute("1")]
private string get_DebuggerDisplay();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Newtonsoft.Json.Schema.JSchemaException : Exception {
    public JSchemaException(string message);
    public JSchemaException(string message, Exception innerException);
    public JSchemaException(SerializationInfo info, StreamingContext context);
    internal static string FormatMessage(IJsonLineInfo lineInfo, string path, string message);
    internal static string FormatMessage(IJsonLineInfo lineInfo, string path, StringBuilder message);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Newtonsoft.Json.Schema.JSchemaPreloadedResolver : JSchemaResolver {
    private Dictionary`2<Uri, Byte[]> _preloadedData;
    [NullableAttribute("2")]
private JSchemaResolver _resolver;
    public IEnumerable`1<Uri> PreloadedUris { get; }
    public JSchemaPreloadedResolver(JSchemaResolver resolver);
    public IEnumerable`1<Uri> get_PreloadedUris();
    public virtual Stream GetSchemaResource(ResolveSchemaContext context, SchemaReference reference);
    public void Add(Uri uri, Byte[] value);
    public void Add(Uri uri, Stream value);
    public void Add(Uri uri, string value);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
public class Newtonsoft.Json.Schema.JSchemaReaderException : JSchemaException {
    [CompilerGeneratedAttribute]
private int <LineNumber>k__BackingField;
    [CompilerGeneratedAttribute]
private int <LinePosition>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Path>k__BackingField;
    [CompilerGeneratedAttribute]
private Uri <BaseUri>k__BackingField;
    public int LineNumber { get; }
    public int LinePosition { get; }
    public string Path { get; }
    public Uri BaseUri { get; }
    [NullableContextAttribute("1")]
public JSchemaReaderException(string message);
    [NullableContextAttribute("1")]
public JSchemaReaderException(string message, Exception innerException);
    [NullableContextAttribute("1")]
public JSchemaReaderException(SerializationInfo info, StreamingContext context);
    internal JSchemaReaderException(string message, Exception innerException, string path, int lineNumber, int linePosition, Uri baseUri);
    [CompilerGeneratedAttribute]
public int get_LineNumber();
    [CompilerGeneratedAttribute]
public int get_LinePosition();
    [CompilerGeneratedAttribute]
public string get_Path();
    [CompilerGeneratedAttribute]
public Uri get_BaseUri();
    [NullableContextAttribute("1")]
internal static JSchemaReaderException Create(JsonReader reader, Uri baseUri, string message);
    [NullableContextAttribute("1")]
internal static JSchemaReaderException Create(JsonReader reader, Uri baseUri, string message, Exception ex);
    internal static JSchemaReaderException Create(IJsonLineInfo lineInfo, Uri baseUri, string path, string message);
    internal static JSchemaReaderException Create(IJsonLineInfo lineInfo, Uri baseUri, string path, string message, Exception ex);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
public class Newtonsoft.Json.Schema.JSchemaReaderSettings : object {
    private SchemaValidationEventHandler _validationEventHandler;
    [CompilerGeneratedAttribute]
private Uri <BaseUri>k__BackingField;
    [CompilerGeneratedAttribute]
private JSchemaResolver <Resolver>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <ResolveSchemaReferences>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <ValidateVersion>k__BackingField;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private IList`1<JsonValidator> <Validators>k__BackingField;
    public Uri BaseUri { get; public set; }
    public JSchemaResolver Resolver { get; public set; }
    public bool ResolveSchemaReferences { get; public set; }
    public bool ValidateVersion { get; public set; }
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public IList`1<JsonValidator> Validators { get; public set; }
    [CompilerGeneratedAttribute]
public Uri get_BaseUri();
    [CompilerGeneratedAttribute]
public void set_BaseUri(Uri value);
    [CompilerGeneratedAttribute]
public JSchemaResolver get_Resolver();
    [CompilerGeneratedAttribute]
public void set_Resolver(JSchemaResolver value);
    [CompilerGeneratedAttribute]
public bool get_ResolveSchemaReferences();
    [CompilerGeneratedAttribute]
public void set_ResolveSchemaReferences(bool value);
    [CompilerGeneratedAttribute]
public bool get_ValidateVersion();
    [CompilerGeneratedAttribute]
public void set_ValidateVersion(bool value);
    [CompilerGeneratedAttribute]
public IList`1<JsonValidator> get_Validators();
    [CompilerGeneratedAttribute]
public void set_Validators(IList`1<JsonValidator> value);
    [NullableContextAttribute("1")]
public void add_ValidationEventHandler(SchemaValidationEventHandler value);
    [NullableContextAttribute("1")]
public void remove_ValidationEventHandler(SchemaValidationEventHandler value);
    internal SchemaValidationEventHandler GetValidationEventHandler();
    internal void SetValidationEventHandler(SchemaValidationEventHandler handler);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public abstract class Newtonsoft.Json.Schema.JSchemaResolver : object {
    unknown ICredentials Credentials {public set; }
    public abstract virtual Stream GetSchemaResource(ResolveSchemaContext context, SchemaReference reference);
    public virtual SchemaReference ResolveSchemaReference(ResolveSchemaContext context);
    [NullableContextAttribute("2")]
private Uri ResolveBaseUri(ResolveSchemaContext context, String& fragment);
    private Uri RemoveFragment(Uri uri, String& fragment);
    public virtual JSchema GetSubschema(SchemaReference reference, JSchema rootSchema);
    public virtual void set_Credentials(ICredentials value);
}
internal enum Newtonsoft.Json.Schema.JSchemaState : Enum {
    public int value__;
    public static JSchemaState Default;
    public static JSchemaState Loading;
    public static JSchemaState Reentrant;
}
[FlagsAttribute]
public enum Newtonsoft.Json.Schema.JSchemaType : Enum {
    public int value__;
    public static JSchemaType None;
    public static JSchemaType String;
    public static JSchemaType Number;
    public static JSchemaType Integer;
    public static JSchemaType Boolean;
    public static JSchemaType Object;
    public static JSchemaType Array;
    public static JSchemaType Null;
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Newtonsoft.Json.Schema.JSchemaUrlResolver : JSchemaResolver {
    [NullableAttribute("2")]
private ICredentials _credentials;
    private IDownloader _downloader;
    [CompilerGeneratedAttribute]
private Nullable`1<int> <Timeout>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<int> <ByteLimit>k__BackingField;
    public Nullable`1<int> Timeout { get; public set; }
    public Nullable`1<int> ByteLimit { get; public set; }
    unknown ICredentials Credentials {public set; }
    [CompilerGeneratedAttribute]
public Nullable`1<int> get_Timeout();
    [CompilerGeneratedAttribute]
public void set_Timeout(Nullable`1<int> value);
    [CompilerGeneratedAttribute]
public Nullable`1<int> get_ByteLimit();
    [CompilerGeneratedAttribute]
public void set_ByteLimit(Nullable`1<int> value);
    public virtual void set_Credentials(ICredentials value);
    public virtual Stream GetSchemaResource(ResolveSchemaContext context, SchemaReference reference);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Newtonsoft.Json.Schema.JSchemaValidatingReader : JsonReader {
    private JsonReader _reader;
    private ReaderValidator _validator;
    [NullableAttribute("2")]
private object _readAsValue;
    private Nullable`1<JsonToken> _readAsToken;
    internal ReaderValidator Validator { get; }
    public Nullable`1<TimeSpan> RegexMatchTimeout { get; public set; }
    [NullableAttribute("2")]
public object Value { get; }
    public int Depth { get; }
    public string Path { get; }
    public char QuoteChar { get; }
    public JsonToken TokenType { get; }
    [NullableAttribute("2")]
public Type ValueType { get; }
    [NullableAttribute("2")]
public JSchema Schema { get; public set; }
    public JsonReader Reader { get; }
    private int Newtonsoft.Json.IJsonLineInfo.LineNumber { get; }
    private int Newtonsoft.Json.IJsonLineInfo.LinePosition { get; }
    public JSchemaValidatingReader(JsonReader reader);
    internal ReaderValidator get_Validator();
    public void add_ValidationEventHandler(SchemaValidationEventHandler value);
    public void remove_ValidationEventHandler(SchemaValidationEventHandler value);
    public Nullable`1<TimeSpan> get_RegexMatchTimeout();
    public void set_RegexMatchTimeout(Nullable`1<TimeSpan> value);
    [NullableContextAttribute("2")]
public virtual object get_Value();
    public virtual int get_Depth();
    public virtual string get_Path();
    public virtual char get_QuoteChar();
    public virtual JsonToken get_TokenType();
    [NullableContextAttribute("2")]
public virtual Type get_ValueType();
    [NullableContextAttribute("2")]
public JSchema get_Schema();
    [NullableContextAttribute("2")]
public void set_Schema(JSchema value);
    public JsonReader get_Reader();
    private sealed virtual override bool Newtonsoft.Json.IJsonLineInfo.HasLineInfo();
    private sealed virtual override int Newtonsoft.Json.IJsonLineInfo.get_LineNumber();
    private sealed virtual override int Newtonsoft.Json.IJsonLineInfo.get_LinePosition();
    public virtual Nullable`1<int> ReadAsInt32();
    public virtual Nullable`1<bool> ReadAsBoolean();
    [NullableContextAttribute("2")]
public virtual Byte[] ReadAsBytes();
    public virtual Nullable`1<decimal> ReadAsDecimal();
    public virtual Nullable`1<double> ReadAsDouble();
    [NullableContextAttribute("2")]
public virtual string ReadAsString();
    public virtual Nullable`1<DateTime> ReadAsDateTime();
    public virtual Nullable`1<DateTimeOffset> ReadAsDateTimeOffset();
    public virtual bool Read();
    public virtual void Close();
    private void ValidateCurrentToken();
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
public class Newtonsoft.Json.Schema.JSchemaValidatingWriter : JsonWriter {
    [NullableAttribute("1")]
private JsonWriter _writer;
    [NullableAttribute("1")]
private WriterValidator _validator;
    public JSchema Schema { get; public set; }
    public Nullable`1<TimeSpan> RegexMatchTimeout { get; public set; }
    [NullableContextAttribute("1")]
public JSchemaValidatingWriter(JsonWriter writer);
    public JSchema get_Schema();
    public void set_Schema(JSchema value);
    [NullableContextAttribute("1")]
public void add_ValidationEventHandler(SchemaValidationEventHandler value);
    [NullableContextAttribute("1")]
public void remove_ValidationEventHandler(SchemaValidationEventHandler value);
    public Nullable`1<TimeSpan> get_RegexMatchTimeout();
    public void set_RegexMatchTimeout(Nullable`1<TimeSpan> value);
    public virtual void Flush();
    public virtual void WriteComment(string text);
    [NullableContextAttribute("1")]
public virtual void WriteStartConstructor(string name);
    public virtual void WriteRaw(string json);
    public virtual void WriteRawValue(string json);
    public virtual void WriteStartArray();
    public virtual void WriteStartObject();
    [NullableContextAttribute("1")]
public virtual void WritePropertyName(string name);
    public virtual void Close();
    protected virtual void WriteEnd(JsonToken token);
    public virtual void WriteNull();
    public virtual void WriteUndefined();
    public virtual void WriteValue(object value);
    public virtual void WriteValue(string value);
    public virtual void WriteValue(int value);
    [CLSCompliantAttribute("False")]
public virtual void WriteValue(UInt32 value);
    public virtual void WriteValue(long value);
    [CLSCompliantAttribute("False")]
public virtual void WriteValue(ulong value);
    public virtual void WriteValue(float value);
    public virtual void WriteValue(double value);
    public virtual void WriteValue(bool value);
    public virtual void WriteValue(short value);
    [CLSCompliantAttribute("False")]
public virtual void WriteValue(ushort value);
    public virtual void WriteValue(char value);
    public virtual void WriteValue(byte value);
    [CLSCompliantAttribute("False")]
public virtual void WriteValue(sbyte value);
    public virtual void WriteValue(decimal value);
    public virtual void WriteValue(DateTime value);
    public virtual void WriteValue(DateTimeOffset value);
    public virtual void WriteValue(Byte[] value);
    public virtual void WriteValue(Guid value);
    public virtual void WriteValue(TimeSpan value);
    public virtual void WriteValue(Uri value);
    private void ValidateCurrentToken(JsonToken token, object value, int depth);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
public class Newtonsoft.Json.Schema.JSchemaValidationException : JSchemaException {
    [CompilerGeneratedAttribute]
private ValidationError <ValidationError>k__BackingField;
    public int LineNumber { get; }
    public int LinePosition { get; }
    public string Path { get; }
    public ValidationError ValidationError { get; internal set; }
    [NullableContextAttribute("1")]
public JSchemaValidationException(string message);
    [NullableContextAttribute("1")]
public JSchemaValidationException(string message, Exception innerException);
    [NullableContextAttribute("1")]
public JSchemaValidationException(string message, Exception innerException, ValidationError validationError);
    [NullableContextAttribute("1")]
public JSchemaValidationException(SerializationInfo info, StreamingContext context);
    public int get_LineNumber();
    public int get_LinePosition();
    public string get_Path();
    [CompilerGeneratedAttribute]
public ValidationError get_ValidationError();
    [CompilerGeneratedAttribute]
internal void set_ValidationError(ValidationError value);
    [NullableContextAttribute("1")]
internal static JSchemaValidationException Create(ValidationError validationError);
}
public enum Newtonsoft.Json.Schema.JSchemaWriterReferenceHandling : Enum {
    public int value__;
    public static JSchemaWriterReferenceHandling Always;
    public static JSchemaWriterReferenceHandling Never;
    public static JSchemaWriterReferenceHandling Auto;
}
public class Newtonsoft.Json.Schema.JSchemaWriterSettings : object {
    [CompilerGeneratedAttribute]
private Nullable`1<SchemaVersion> <Version>k__BackingField;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private IList`1<ExternalSchema> <ExternalSchemas>k__BackingField;
    [CompilerGeneratedAttribute]
private JSchemaWriterReferenceHandling <ReferenceHandling>k__BackingField;
    public Nullable`1<SchemaVersion> Version { get; public set; }
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public IList`1<ExternalSchema> ExternalSchemas { get; public set; }
    public JSchemaWriterReferenceHandling ReferenceHandling { get; public set; }
    [CompilerGeneratedAttribute]
public Nullable`1<SchemaVersion> get_Version();
    [CompilerGeneratedAttribute]
public void set_Version(Nullable`1<SchemaVersion> value);
    [CompilerGeneratedAttribute]
public IList`1<ExternalSchema> get_ExternalSchemas();
    [CompilerGeneratedAttribute]
public void set_ExternalSchemas(IList`1<ExternalSchema> value);
    [CompilerGeneratedAttribute]
public JSchemaWriterReferenceHandling get_ReferenceHandling();
    [CompilerGeneratedAttribute]
public void set_ReferenceHandling(JSchemaWriterReferenceHandling value);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public abstract class Newtonsoft.Json.Schema.JsonValidator : object {
    public abstract virtual void Validate(JToken value, JsonValidatorContext context);
    public abstract virtual bool CanValidate(JSchema schema);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Newtonsoft.Json.Schema.JsonValidatorContext : object {
    private Scope _scope;
    private JSchema _schema;
    public JSchema Schema { get; }
    internal JsonValidatorContext(Scope scope, JSchema schema);
    public JSchema get_Schema();
    public void RaiseError(string message);
    public void RaiseError(string message, object value);
}
public static class Newtonsoft.Json.Schema.License : object {
    [NullableContextAttribute("1")]
public static void RegisterLicense(string license);
    public static bool HasRegisteredLicense();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Newtonsoft.Json.Schema.ResolveSchemaContext : object {
    [CompilerGeneratedAttribute]
private Uri <SchemaId>k__BackingField;
    [CompilerGeneratedAttribute]
private Uri <ResolvedSchemaId>k__BackingField;
    [NullableAttribute("2")]
[CompilerGeneratedAttribute]
private Uri <ResolverBaseUri>k__BackingField;
    public Uri SchemaId { get; public set; }
    public Uri ResolvedSchemaId { get; public set; }
    [NullableAttribute("2")]
public Uri ResolverBaseUri { get; public set; }
    [CompilerGeneratedAttribute]
public Uri get_SchemaId();
    [CompilerGeneratedAttribute]
public void set_SchemaId(Uri value);
    [CompilerGeneratedAttribute]
public Uri get_ResolvedSchemaId();
    [CompilerGeneratedAttribute]
public void set_ResolvedSchemaId(Uri value);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public Uri get_ResolverBaseUri();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public void set_ResolverBaseUri(Uri value);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
public static class Newtonsoft.Json.Schema.SchemaExtensions : object {
    [ExtensionAttribute]
public static bool IsValid(JToken source, JSchema schema);
    [ExtensionAttribute]
public static bool IsValid(JToken source, JSchema schema, IList`1& errorMessages);
    [ExtensionAttribute]
public static bool IsValid(JToken source, JSchema schema, IList`1& errors);
    [ExtensionAttribute]
public static void Validate(JToken source, JSchema schema);
    [ExtensionAttribute]
public static void Validate(JToken source, JSchema schema, SchemaValidationEventHandler validationEventHandler);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
public class Newtonsoft.Json.Schema.SchemaReference : object {
    [CompilerGeneratedAttribute]
private Uri <BaseUri>k__BackingField;
    [CompilerGeneratedAttribute]
private Uri <SubschemaId>k__BackingField;
    public Uri BaseUri { get; public set; }
    public Uri SubschemaId { get; public set; }
    [CompilerGeneratedAttribute]
public Uri get_BaseUri();
    [CompilerGeneratedAttribute]
public void set_BaseUri(Uri value);
    [CompilerGeneratedAttribute]
public Uri get_SubschemaId();
    [CompilerGeneratedAttribute]
public void set_SubschemaId(Uri value);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Newtonsoft.Json.Schema.SchemaValidationEventArgs : EventArgs {
    private ValidationError _validationError;
    public ValidationError ValidationError { get; }
    public string Path { get; }
    public string Message { get; }
    internal SchemaValidationEventArgs(ValidationError validationError);
    public ValidationError get_ValidationError();
    public string get_Path();
    public string get_Message();
}
public class Newtonsoft.Json.Schema.SchemaValidationEventHandler : MulticastDelegate {
    public SchemaValidationEventHandler(object object, IntPtr method);
    [NullableContextAttribute("1")]
public virtual void Invoke(object sender, SchemaValidationEventArgs e);
    public virtual IAsyncResult BeginInvoke(object sender, SchemaValidationEventArgs e, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
public enum Newtonsoft.Json.Schema.SchemaVersion : Enum {
    public int value__;
    public static SchemaVersion Unset;
    public static SchemaVersion Draft3;
    public static SchemaVersion Draft4;
    public static SchemaVersion Draft6;
    public static SchemaVersion Draft7;
    public static SchemaVersion Draft2019_09;
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
internal static class Newtonsoft.Json.Schema.Utilities.DateTimeUtils : object {
    internal static long InitialJavaScriptDateTicks;
    private static int DaysPer100Years;
    private static int DaysPer400Years;
    private static int DaysPer4Years;
    private static int DaysPerYear;
    private static long TicksPerDay;
    private static Int32[] DaysToMonth365;
    private static Int32[] DaysToMonth366;
    private static DateTimeUtils();
    [ExtensionAttribute]
public static TimeSpan GetUtcOffset(DateTime d);
    internal static void WriteDateTimeString(TextWriter writer, DateTime value, DateFormatHandling format, string formatString, CultureInfo culture);
    internal static int WriteDateTimeString(Char[] chars, int start, DateTime value, Nullable`1<TimeSpan> offset, DateTimeKind kind, DateFormatHandling format);
    internal static int WriteDefaultIsoDate(Char[] chars, int start, DateTime dt);
    private static void CopyIntToCharArray(Char[] chars, int start, int value, int digits);
    internal static int WriteDateTimeOffset(Char[] chars, int start, TimeSpan offset, DateFormatHandling format);
    internal static void WriteDateTimeOffsetString(TextWriter writer, DateTimeOffset value, DateFormatHandling format, string formatString, CultureInfo culture);
    internal static DateTime EnsureDateTime(DateTime value, DateTimeZoneHandling timeZone);
    private static DateTime SwitchToLocalTime(DateTime value);
    private static DateTime SwitchToUtcTime(DateTime value);
    private static long ToUniversalTicks(DateTime dateTime);
    private static long ToUniversalTicks(DateTime dateTime, TimeSpan offset);
    internal static long ConvertDateTimeToJavaScriptTicks(DateTime dateTime, TimeSpan offset);
    internal static long ConvertDateTimeToJavaScriptTicks(DateTime dateTime);
    internal static long ConvertDateTimeToJavaScriptTicks(DateTime dateTime, bool convertToUtc);
    private static long UniversialTicksToJavaScriptTicks(long universialTicks);
    internal static DateTime ConvertJavaScriptTicksToDateTime(long javaScriptTicks);
    private static void GetDateValues(DateTime td, Int32& year, Int32& month, Int32& day);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
[DebuggerDisplayAttribute("{GetExtendedMessage(),nq}")]
public class Newtonsoft.Json.Schema.ValidationError : object {
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal IList`1<ValidationError> _childErrors;
    private IFormattable _formattable;
    private string _message;
    private string _extendedMessage;
    [CompilerGeneratedAttribute]
private int <LineNumber>k__BackingField;
    [CompilerGeneratedAttribute]
private int <LinePosition>k__BackingField;
    [NullableAttribute("1")]
[CompilerGeneratedAttribute]
private string <Path>k__BackingField;
    [CompilerGeneratedAttribute]
private object <Value>k__BackingField;
    [NullableAttribute("1")]
[CompilerGeneratedAttribute]
private JSchema <Schema>k__BackingField;
    [CompilerGeneratedAttribute]
private Uri <SchemaId>k__BackingField;
    [CompilerGeneratedAttribute]
private Uri <SchemaBaseUri>k__BackingField;
    [CompilerGeneratedAttribute]
private ErrorType <ErrorType>k__BackingField;
    [NullableAttribute("1")]
public string Message { get; }
    public int LineNumber { get; private set; }
    public int LinePosition { get; private set; }
    [NullableAttribute("1")]
public string Path { get; private set; }
    public object Value { get; private set; }
    [NullableAttribute("1")]
[JsonIgnoreAttribute]
public JSchema Schema { get; private set; }
    public Uri SchemaId { get; internal set; }
    public Uri SchemaBaseUri { get; private set; }
    [JsonConverterAttribute("Newtonsoft.Json.Converters.StringEnumConverter")]
public ErrorType ErrorType { get; private set; }
    [NullableAttribute("1")]
public IList`1<ValidationError> ChildErrors { get; }
    [NullableContextAttribute("1")]
public string get_Message();
    [CompilerGeneratedAttribute]
public sealed virtual int get_LineNumber();
    [CompilerGeneratedAttribute]
private void set_LineNumber(int value);
    [CompilerGeneratedAttribute]
public sealed virtual int get_LinePosition();
    [CompilerGeneratedAttribute]
private void set_LinePosition(int value);
    [NullableContextAttribute("1")]
[CompilerGeneratedAttribute]
public string get_Path();
    [NullableContextAttribute("1")]
[CompilerGeneratedAttribute]
private void set_Path(string value);
    [CompilerGeneratedAttribute]
public object get_Value();
    [CompilerGeneratedAttribute]
private void set_Value(object value);
    [NullableContextAttribute("1")]
[CompilerGeneratedAttribute]
public JSchema get_Schema();
    [NullableContextAttribute("1")]
[CompilerGeneratedAttribute]
private void set_Schema(JSchema value);
    [CompilerGeneratedAttribute]
public Uri get_SchemaId();
    [CompilerGeneratedAttribute]
internal void set_SchemaId(Uri value);
    [CompilerGeneratedAttribute]
public Uri get_SchemaBaseUri();
    [CompilerGeneratedAttribute]
private void set_SchemaBaseUri(Uri value);
    [CompilerGeneratedAttribute]
public ErrorType get_ErrorType();
    [CompilerGeneratedAttribute]
private void set_ErrorType(ErrorType value);
    [NullableContextAttribute("1")]
public IList`1<ValidationError> get_ChildErrors();
    private sealed virtual override bool Newtonsoft.Json.IJsonLineInfo.HasLineInfo();
    [MemberNotNullAttribute("_message")]
[MemberNotNullAttribute("_extendedMessage")]
private void EnsureMessages();
    [MemberNotNullAttribute("_message")]
[MemberNotNullAttribute("_extendedMessage")]
private void BuildMessages();
    [NullableContextAttribute("1")]
internal string GetExtendedMessage();
    [NullableContextAttribute("1")]
internal static ValidationError CreateValidationError(IFormattable message, ErrorType errorType, JSchema schema, Uri schemaId, object value, IList`1<ValidationError> childErrors, IJsonLineInfo lineInfo, string path);
}
[AttributeUsageAttribute("2432")]
internal class System.Diagnostics.CodeAnalysis.AllowNullAttribute : Attribute {
}
[AttributeUsageAttribute("64")]
internal class System.Diagnostics.CodeAnalysis.DoesNotReturnAttribute : Attribute {
}
[AttributeUsageAttribute("2048")]
internal class System.Diagnostics.CodeAnalysis.DoesNotReturnIfAttribute : Attribute {
    [CompilerGeneratedAttribute]
private bool <ParameterValue>k__BackingField;
    public bool ParameterValue { get; }
    public DoesNotReturnIfAttribute(bool parameterValue);
    [CompilerGeneratedAttribute]
public bool get_ParameterValue();
}
[AttributeUsageAttribute("10624")]
internal class System.Diagnostics.CodeAnalysis.MaybeNullAttribute : Attribute {
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[AttributeUsageAttribute("192")]
internal class System.Diagnostics.CodeAnalysis.MemberNotNullAttribute : Attribute {
    [CompilerGeneratedAttribute]
private String[] <Members>k__BackingField;
    public String[] Members { get; }
    public MemberNotNullAttribute(string member);
    public MemberNotNullAttribute(String[] members);
    [CompilerGeneratedAttribute]
public String[] get_Members();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[AttributeUsageAttribute("192")]
internal class System.Diagnostics.CodeAnalysis.MemberNotNullWhenAttribute : Attribute {
    [CompilerGeneratedAttribute]
private bool <ReturnValue>k__BackingField;
    [CompilerGeneratedAttribute]
private String[] <Members>k__BackingField;
    public bool ReturnValue { get; }
    public String[] Members { get; }
    public MemberNotNullWhenAttribute(bool returnValue, string member);
    public MemberNotNullWhenAttribute(bool returnValue, String[] members);
    [CompilerGeneratedAttribute]
public bool get_ReturnValue();
    [CompilerGeneratedAttribute]
public String[] get_Members();
}
[AttributeUsageAttribute("10688")]
internal class System.Diagnostics.CodeAnalysis.NotNullAttribute : Attribute {
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[AttributeUsageAttribute("10368")]
internal class System.Diagnostics.CodeAnalysis.NotNullIfNotNullAttribute : Attribute {
    [CompilerGeneratedAttribute]
private string <ParameterName>k__BackingField;
    public string ParameterName { get; }
    public NotNullIfNotNullAttribute(string parameterName);
    [CompilerGeneratedAttribute]
public string get_ParameterName();
}
[AttributeUsageAttribute("2048")]
internal class System.Diagnostics.CodeAnalysis.NotNullWhenAttribute : Attribute {
    [CompilerGeneratedAttribute]
private bool <ReturnValue>k__BackingField;
    public bool ReturnValue { get; }
    public NotNullWhenAttribute(bool returnValue);
    [CompilerGeneratedAttribute]
public bool get_ReturnValue();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class System.Runtime.CompilerServices.FormattableString : object {
    private string _format;
    private Object[] _args;
    public string Format { get; }
    public FormattableString(string format, Object[] args);
    public string get_Format();
    public Object[] GetArguments();
    public sealed virtual string ToString(string ignored, IFormatProvider formatProvider);
}
internal static class System.Runtime.CompilerServices.FormattableStringFactory : object {
    [NullableContextAttribute("1")]
public static FormattableString Create(string s, Object[] args);
}
[CompilerGeneratedAttribute]
[EmbeddedAttribute]
internal class System.Runtime.CompilerServices.IsReadOnlyAttribute : Attribute {
}
[CompilerGeneratedAttribute]
[EmbeddedAttribute]
[AttributeUsageAttribute("27524")]
internal class System.Runtime.CompilerServices.NullableAttribute : Attribute {
    public Byte[] NullableFlags;
    public NullableAttribute(byte );
    public NullableAttribute(Byte[] );
}
[CompilerGeneratedAttribute]
[EmbeddedAttribute]
[AttributeUsageAttribute("5196")]
internal class System.Runtime.CompilerServices.NullableContextAttribute : Attribute {
    public byte Flag;
    public NullableContextAttribute(byte );
}
