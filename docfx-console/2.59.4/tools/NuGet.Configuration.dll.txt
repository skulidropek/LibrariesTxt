public class NuGet.Configuration.AddItem : SettingItem {
    [CompilerGeneratedAttribute]
private IReadOnlyCollection`1<string> <RequiredAttributes>k__BackingField;
    [CompilerGeneratedAttribute]
private IReadOnlyDictionary`2<string, IReadOnlyCollection`1<string>> <DisallowedValues>k__BackingField;
    public string ElementName { get; }
    public string Key { get; }
    public string Value { get; public set; }
    public IReadOnlyDictionary`2<string, string> AdditionalAttributes { get; }
    protected IReadOnlyCollection`1<string> RequiredAttributes { get; }
    protected IReadOnlyDictionary`2<string, IReadOnlyCollection`1<string>> DisallowedValues { get; }
    public AddItem(string key, string value);
    internal AddItem(XElement element, SettingsFile origin);
    public AddItem(string key, string value, IReadOnlyDictionary`2<string, string> additionalAttributes);
    public virtual string get_ElementName();
    public string get_Key();
    public virtual string get_Value();
    public virtual void set_Value(string value);
    public IReadOnlyDictionary`2<string, string> get_AdditionalAttributes();
    [CompilerGeneratedAttribute]
protected virtual IReadOnlyCollection`1<string> get_RequiredAttributes();
    [CompilerGeneratedAttribute]
protected virtual IReadOnlyDictionary`2<string, IReadOnlyCollection`1<string>> get_DisallowedValues();
    public virtual string GetValueAsPath();
    public void AddOrUpdateAdditionalAttribute(string attributeName, string value);
    public virtual bool Equals(object other);
    public virtual int GetHashCode();
    public virtual SettingBase Clone();
    internal virtual void Update(SettingItem other);
}
public class NuGet.Configuration.AuthorItem : TrustedSignerItem {
    [CompilerGeneratedAttribute]
private IReadOnlyCollection`1<string> <RequiredAttributes>k__BackingField;
    public string ElementName { get; }
    protected IReadOnlyCollection`1<string> RequiredAttributes { get; }
    public AuthorItem(string name, CertificateItem[] certificates);
    internal AuthorItem(XElement element, SettingsFile origin);
    public virtual string get_ElementName();
    [CompilerGeneratedAttribute]
protected virtual IReadOnlyCollection`1<string> get_RequiredAttributes();
    public virtual SettingBase Clone();
    internal virtual XNode AsXNode();
    public virtual bool Equals(object other);
    public virtual int GetHashCode();
}
public class NuGet.Configuration.CertificateItem : SettingItem {
    [CompilerGeneratedAttribute]
private IReadOnlyCollection`1<string> <RequiredAttributes>k__BackingField;
    public string ElementName { get; }
    public string Fingerprint { get; public set; }
    public HashAlgorithmName HashAlgorithm { get; public set; }
    public bool AllowUntrustedRoot { get; public set; }
    protected IReadOnlyCollection`1<string> RequiredAttributes { get; }
    public CertificateItem(string fingerprint, HashAlgorithmName hashAlgorithm, bool allowUntrustedRoot);
    internal CertificateItem(XElement element, SettingsFile origin);
    public virtual string get_ElementName();
    public string get_Fingerprint();
    public void set_Fingerprint(string value);
    public HashAlgorithmName get_HashAlgorithm();
    public void set_HashAlgorithm(HashAlgorithmName value);
    public bool get_AllowUntrustedRoot();
    public void set_AllowUntrustedRoot(bool value);
    [CompilerGeneratedAttribute]
protected virtual IReadOnlyCollection`1<string> get_RequiredAttributes();
    public virtual SettingBase Clone();
    public virtual bool Equals(object other);
    public virtual int GetHashCode();
}
public class NuGet.Configuration.ClearItem : SettingItem {
    public string ElementName { get; }
    internal ClearItem(XElement element, SettingsFile origin);
    public virtual string get_ElementName();
    public virtual bool IsEmpty();
    public virtual SettingBase Clone();
    public virtual bool Equals(object other);
    public virtual int GetHashCode();
}
public class NuGet.Configuration.ClientCertificateProvider : object {
    private ISettings _settings;
    public ClientCertificateProvider(ISettings settings);
    public sealed virtual void AddOrUpdate(ClientCertItem item);
    public sealed virtual void Remove(IReadOnlyList`1<ClientCertItem> items);
    public sealed virtual IReadOnlyList`1<ClientCertItem> GetClientCertificates();
    public ClientCertItem GetClientCertificate(string packageSourceName);
}
public abstract class NuGet.Configuration.ClientCertItem : SettingItem {
    public string PackageSource { get; }
    protected bool CanHaveChildren { get; }
    protected ClientCertItem(string packageSource);
    internal ClientCertItem(XElement element, SettingsFile origin);
    public string get_PackageSource();
    protected virtual bool get_CanHaveChildren();
    public virtual bool Equals(object other);
    public virtual int GetHashCode();
    public abstract virtual IEnumerable`1<X509Certificate> Search();
    protected void SetPackageSource(string value);
}
public static class NuGet.Configuration.ConfigurationConstants : object {
    public static string ActivePackageSourceSectionName;
    public static string Add;
    public static string AllowUntrustedRoot;
    public static string ApiKeys;
    public static string Author;
    public static string BeginIgnoreMarker;
    public static string BindingRedirectsSection;
    public static string Certificate;
    public static string Clear;
    public static string ClearTextPasswordAttribute;
    public static string ClearTextPasswordToken;
    public static string ClientCertificates;
    public static string Config;
    public static string Configuration;
    public static string ConfigurationDefaultsFile;
    public static string CredentialsSectionName;
    public static string DefaultPackageManagementFormatKey;
    public static string DefaultPushSource;
    public static string DependencyVersion;
    public static string DisabledPackageSources;
    public static string DoNotShowPackageManagementSelectionKey;
    public static string Enabled;
    public static string EndIgnoreMarker;
    public static string FailOnBindingRedirects;
    public static string FallbackPackageFolders;
    public static string FileCertificate;
    public static string FindByAttribute;
    public static string FindValueAttribute;
    public static string Fingerprint;
    public static string FingerprintAlgorithm;
    public static string GlobalPackagesFolder;
    public static string HashAlgorithm;
    public static string HostKey;
    public static string KeyAttribute;
    public static string MaxHttpRequestsPerSource;
    public static string NameAttribute;
    public static string NoProxy;
    public static string Owners;
    public static string PackageManagementSection;
    public static string PackageRestore;
    public static string PackageSourceAttribute;
    public static string PackageSources;
    public static string PasswordAttribute;
    public static string PasswordKey;
    public static string PasswordToken;
    public static string PathAttribute;
    public static string ProtocolVersionAttribute;
    public static string Repository;
    public static string RepositoryPath;
    public static string ServiceIndex;
    public static string SignatureValidationMode;
    public static string SkipBindingRedirectsKey;
    public static string StoreCertificate;
    public static string StoreLocationAttribute;
    public static string StoreNameAttribute;
    public static string TrustedSigners;
    public static string UserKey;
    public static string UsernameToken;
    public static string ValidAuthenticationTypesToken;
    public static string ValueAttribute;
    private static ConfigurationConstants();
}
public class NuGet.Configuration.ConfigurationDefaults : object {
    private ISettings _settingsManager;
    private bool _defaultPackageSourceInitialized;
    private List`1<PackageSource> _defaultPackageSources;
    private string _defaultPushSource;
    [CompilerGeneratedAttribute]
private static ConfigurationDefaults <Instance>k__BackingField;
    public static ConfigurationDefaults Instance { get; }
    public IEnumerable`1<PackageSource> DefaultPackageSources { get; }
    public string DefaultPushSource { get; }
    public string DefaultPackageRestoreConsent { get; }
    internal ConfigurationDefaults(string directory, string configFile);
    private static ConfigurationDefaults();
    private static ConfigurationDefaults InitializeInstance();
    [CompilerGeneratedAttribute]
public static ConfigurationDefaults get_Instance();
    public IEnumerable`1<PackageSource> get_DefaultPackageSources();
    public string get_DefaultPushSource();
    public string get_DefaultPackageRestoreConsent();
}
public enum NuGet.Configuration.CredentialRequestType : Enum {
    public int value__;
    public static CredentialRequestType Proxy;
    public static CredentialRequestType Unauthorized;
    public static CredentialRequestType Forbidden;
}
public class NuGet.Configuration.CredentialsItem : SettingItem {
    private string _elementName;
    [CompilerGeneratedAttribute]
private bool <IsPasswordClearText>k__BackingField;
    internal AddItem _username;
    internal AddItem _password;
    [CompilerGeneratedAttribute]
private AddItem <_validAuthenticationTypes>k__BackingField;
    public string ElementName { get; protected set; }
    public string Username { get; public set; }
    public bool IsPasswordClearText { get; private set; }
    public string Password { get; }
    public string ValidAuthenticationTypes { get; public set; }
    protected bool CanHaveChildren { get; }
    internal AddItem _validAuthenticationTypes { get; internal set; }
    public CredentialsItem(string name, string username, string password, bool isPasswordClearText, string validAuthenticationTypes);
    internal CredentialsItem(XElement element, SettingsFile origin);
    public virtual string get_ElementName();
    protected virtual void set_ElementName(string value);
    public string get_Username();
    public void set_Username(string value);
    [CompilerGeneratedAttribute]
public bool get_IsPasswordClearText();
    [CompilerGeneratedAttribute]
private void set_IsPasswordClearText(bool value);
    public string get_Password();
    public void UpdatePassword(string password, bool isPasswordClearText);
    public string get_ValidAuthenticationTypes();
    public void set_ValidAuthenticationTypes(string value);
    protected virtual bool get_CanHaveChildren();
    public virtual bool IsEmpty();
    [CompilerGeneratedAttribute]
internal AddItem get__validAuthenticationTypes();
    [CompilerGeneratedAttribute]
internal void set__validAuthenticationTypes(AddItem value);
    public virtual SettingBase Clone();
    internal virtual XNode AsXNode();
    public virtual bool Equals(object other);
    public virtual int GetHashCode();
    internal virtual void Update(SettingItem other);
    internal virtual void SetOrigin(SettingsFile origin);
    internal virtual void RemoveFromSettings();
}
public static class NuGet.Configuration.EncryptionUtility : object {
    private static Byte[] _entropyBytes;
    private static EncryptionUtility();
    public static string EncryptString(string value);
    public static string DecryptString(string encryptedString);
}
public class NuGet.Configuration.FileClientCertItem : ClientCertItem {
    [CompilerGeneratedAttribute]
private IReadOnlyCollection`1<string> <AllowedAttributes>k__BackingField;
    [CompilerGeneratedAttribute]
private IReadOnlyCollection`1<string> <RequiredAttributes>k__BackingField;
    public string ElementName { get; }
    public string FilePath { get; }
    public bool IsPasswordIsClearText { get; }
    public string Password { get; }
    protected IReadOnlyCollection`1<string> AllowedAttributes { get; }
    protected IReadOnlyCollection`1<string> RequiredAttributes { get; }
    public FileClientCertItem(string packageSource, string filePath, string password, bool storePasswordInClearText, string settingsFilePath);
    internal FileClientCertItem(string packageSource, string filePath, string password, bool storePasswordInClearText, SettingsFile origin);
    internal FileClientCertItem(XElement element, SettingsFile origin);
    public virtual string get_ElementName();
    public string get_FilePath();
    public bool get_IsPasswordIsClearText();
    public string get_Password();
    [CompilerGeneratedAttribute]
protected virtual IReadOnlyCollection`1<string> get_AllowedAttributes();
    [CompilerGeneratedAttribute]
protected virtual IReadOnlyCollection`1<string> get_RequiredAttributes();
    internal virtual XNode AsXNode();
    public virtual SettingBase Clone();
    public virtual IEnumerable`1<X509Certificate> Search();
    public void Update(string filePath, string password, bool storePasswordInClearText);
    private string FindAbsoluteFilePath();
}
internal static class NuGet.Configuration.FileSystemUtility : object {
    internal static void AddFile(string fullPath, Action`1<Stream> writeToStream);
    internal static bool IsPathAFile(string path);
    internal static bool DoesFileExistIn(string root, string file);
    internal static IEnumerable`1<string> GetFilesRelativeToRoot(string root, string path, String[] filters, SearchOption searchOption);
    internal static string GetRelativePath(string root, string fullPath);
    internal static string EnsureTrailingSlash(string path);
    internal static string EnsureTrailingForwardSlash(string path);
    private static string EnsureTrailingCharacter(string path, char trailingCharacter);
}
public interface NuGet.Configuration.IClientCertificateProvider {
    public abstract virtual void AddOrUpdate(ClientCertItem item);
    public abstract virtual IReadOnlyList`1<ClientCertItem> GetClientCertificates();
    public abstract virtual void Remove(IReadOnlyList`1<ClientCertItem> items);
}
public interface NuGet.Configuration.ICredentialCache {
    public abstract virtual void Add(Uri uri, ICredentials credentials);
    public abstract virtual ICredentials GetCredentials(Uri uri);
}
public interface NuGet.Configuration.ICredentialService {
    public bool HandlesDefaultCredentials { get; }
    public abstract virtual Task`1<ICredentials> GetCredentialsAsync(Uri uri, IWebProxy proxy, CredentialRequestType type, string message, CancellationToken cancellationToken);
    public abstract virtual bool TryGetLastKnownGoodCredentialsFromCache(Uri uri, bool isProxy, ICredentials& credentials);
    public abstract virtual bool get_HandlesDefaultCredentials();
}
public interface NuGet.Configuration.IExtensionLocator {
    public abstract virtual IEnumerable`1<string> FindExtensions();
    public abstract virtual IEnumerable`1<string> FindCredentialProviders();
}
public interface NuGet.Configuration.IMachineWideSettings {
    public ISettings Settings { get; }
    public abstract virtual ISettings get_Settings();
}
internal class NuGet.Configuration.ImmutableSettings : object {
    private ISettings _settings;
    internal ImmutableSettings(ISettings settings);
    public sealed virtual void add_SettingsChanged(EventHandler value);
    public sealed virtual void remove_SettingsChanged(EventHandler value);
    public sealed virtual void AddOrUpdate(string sectionName, SettingItem item);
    public sealed virtual IList`1<string> GetConfigFilePaths();
    public sealed virtual IList`1<string> GetConfigRoots();
    public sealed virtual SettingSection GetSection(string sectionName);
    public sealed virtual void Remove(string sectionName, SettingItem item);
    public sealed virtual void SaveToDisk();
}
public interface NuGet.Configuration.IPackageSourceProvider {
    public string ActivePackageSourceName { get; }
    public string DefaultPushSource { get; }
    public abstract virtual IEnumerable`1<PackageSource> LoadPackageSources();
    public abstract virtual PackageSource GetPackageSourceByName(string name);
    public abstract virtual PackageSource GetPackageSourceBySource(string source);
    [CompilerGeneratedAttribute]
public abstract virtual void add_PackageSourcesChanged(EventHandler value);
    [CompilerGeneratedAttribute]
public abstract virtual void remove_PackageSourcesChanged(EventHandler value);
    public abstract virtual void RemovePackageSource(string name);
    public abstract virtual void EnablePackageSource(string name);
    public abstract virtual void DisablePackageSource(string name);
    public abstract virtual void UpdatePackageSource(PackageSource source, bool updateCredentials, bool updateEnabled);
    public abstract virtual void AddPackageSource(PackageSource source);
    public abstract virtual void SavePackageSources(IEnumerable`1<PackageSource> sources);
    public abstract virtual bool IsPackageSourceEnabled(string name);
    public abstract virtual string get_ActivePackageSourceName();
    public abstract virtual string get_DefaultPushSource();
    public abstract virtual void SaveActivePackageSource(PackageSource source);
}
public interface NuGet.Configuration.IProxyCache {
    public abstract virtual void Add(IWebProxy proxy);
    public abstract virtual IWebProxy GetProxy(Uri uri);
}
public interface NuGet.Configuration.IProxyCredentialCache {
    public Guid Version { get; }
    public abstract virtual Guid get_Version();
    public abstract virtual void UpdateCredential(Uri proxyAddress, NetworkCredential credentials);
}
public interface NuGet.Configuration.ISettings {
    public abstract virtual SettingSection GetSection(string sectionName);
    public abstract virtual void AddOrUpdate(string sectionName, SettingItem item);
    public abstract virtual void Remove(string sectionName, SettingItem item);
    public abstract virtual void SaveToDisk();
    [CompilerGeneratedAttribute]
public abstract virtual void add_SettingsChanged(EventHandler value);
    [CompilerGeneratedAttribute]
public abstract virtual void remove_SettingsChanged(EventHandler value);
    public abstract virtual IList`1<string> GetConfigFilePaths();
    public abstract virtual IList`1<string> GetConfigRoots();
}
internal interface NuGet.Configuration.ISettingsGroup {
    public abstract virtual void Remove(SettingElement setting);
}
internal class NuGet.Configuration.NuGetConfiguration : SettingsGroup`1<SettingSection> {
    public string ElementName { get; }
    internal IReadOnlyDictionary`2<string, SettingSection> Sections { get; }
    protected bool CanBeCleared { get; }
    private NuGetConfiguration(IReadOnlyDictionary`2<string, string> attributes, IEnumerable`1<SettingSection> children);
    internal NuGetConfiguration(SettingSection[] sections);
    internal NuGetConfiguration(SettingsFile origin);
    internal NuGetConfiguration(XElement element, SettingsFile origin);
    public virtual string get_ElementName();
    internal IReadOnlyDictionary`2<string, SettingSection> get_Sections();
    protected virtual bool get_CanBeCleared();
    public void AddOrUpdate(string sectionName, SettingItem item);
    public void Remove(string sectionName, SettingItem item);
    public SettingSection GetSection(string sectionName);
    internal void MergeSectionsInto(Dictionary`2<string, VirtualSettingSection> sectionsContainer);
    public virtual SettingBase Clone();
    public virtual bool Equals(object other);
    public virtual int GetHashCode();
}
public class NuGet.Configuration.NuGetConfigurationException : Exception {
    public NuGetConfigurationException(string message);
    public NuGetConfigurationException(string message, Exception innerException);
}
public static class NuGet.Configuration.NuGetConstants : object {
    public static string NuGetHostName;
    public static string NuGetSymbolHostName;
    public static string V3FeedUrl;
    public static string V2FeedUrl;
    public static string V2LegacyOfficialPackageSourceUrl;
    public static string V2LegacyFeedUrl;
    public static string V1FeedUrl;
    public static string DefaultGalleryServerUrl;
    public static string DefaultSymbolServerUrl;
    public static string ReadmeFileName;
    public static string NuGetSolutionSettingsFolder;
    public static string PackageExtension;
    public static string SnupkgExtension;
    public static string SymbolsExtension;
    public static string ManifestExtension;
    public static string ManifestSymbolsExtension;
    public static string PackageReferenceFile;
    public static string PackageSpecFileName;
    public static string FeedName;
    public static string AddV3TrackFile;
    public static string DefaultConfigContent;
    private static NuGetConstants();
}
public class NuGet.Configuration.NuGetPathContext : object {
    [CompilerGeneratedAttribute]
private IReadOnlyList`1<string> <FallbackPackageFolders>k__BackingField;
    [CompilerGeneratedAttribute]
private string <UserPackageFolder>k__BackingField;
    [CompilerGeneratedAttribute]
private string <HttpCacheFolder>k__BackingField;
    public IReadOnlyList`1<string> FallbackPackageFolders { get; internal set; }
    public string UserPackageFolder { get; internal set; }
    public string HttpCacheFolder { get; internal set; }
    [CompilerGeneratedAttribute]
public sealed virtual IReadOnlyList`1<string> get_FallbackPackageFolders();
    [CompilerGeneratedAttribute]
internal void set_FallbackPackageFolders(IReadOnlyList`1<string> value);
    [CompilerGeneratedAttribute]
public sealed virtual string get_UserPackageFolder();
    [CompilerGeneratedAttribute]
internal void set_UserPackageFolder(string value);
    [CompilerGeneratedAttribute]
public sealed virtual string get_HttpCacheFolder();
    [CompilerGeneratedAttribute]
internal void set_HttpCacheFolder(string value);
    public static NuGetPathContext Create(ISettings settings);
    public static NuGetPathContext Create(string settingsRoot);
}
public class NuGet.Configuration.NullSettings : object {
    [CompilerGeneratedAttribute]
private EventHandler SettingsChanged;
    [CompilerGeneratedAttribute]
private static NullSettings <Instance>k__BackingField;
    public static NullSettings Instance { get; }
    private static NullSettings();
    [CompilerGeneratedAttribute]
public sealed virtual void add_SettingsChanged(EventHandler value);
    [CompilerGeneratedAttribute]
public sealed virtual void remove_SettingsChanged(EventHandler value);
    [CompilerGeneratedAttribute]
public static NullSettings get_Instance();
    public sealed virtual SettingSection GetSection(string sectionName);
    public sealed virtual void AddOrUpdate(string sectionName, SettingItem item);
    public sealed virtual void Remove(string sectionName, SettingItem item);
    public sealed virtual void SaveToDisk();
    public sealed virtual IList`1<string> GetConfigFilePaths();
    public sealed virtual IList`1<string> GetConfigRoots();
}
public class NuGet.Configuration.OwnersItem : SettingItem {
    public static char OwnersListSeparator;
    [CompilerGeneratedAttribute]
private IList`1<string> <Content>k__BackingField;
    private SettingText _content;
    public string ElementName { get; }
    protected bool CanHaveChildren { get; }
    public IList`1<string> Content { get; private set; }
    public OwnersItem(string owners);
    internal OwnersItem(XElement element, SettingsFile origin);
    private static OwnersItem();
    public virtual string get_ElementName();
    protected virtual bool get_CanHaveChildren();
    [CompilerGeneratedAttribute]
public IList`1<string> get_Content();
    [CompilerGeneratedAttribute]
private void set_Content(IList`1<string> value);
    public virtual SettingBase Clone();
    internal virtual XNode AsXNode();
    public virtual bool Equals(object other);
    public virtual int GetHashCode();
    internal virtual void Update(SettingItem other);
}
public class NuGet.Configuration.PackageSource : object {
    public static int DefaultProtocolVersion;
    private int _hashCode;
    private Nullable`1<bool> _isHttp;
    private Nullable`1<bool> _isLocal;
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Source>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsOfficial>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsMachineWide>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsEnabled>k__BackingField;
    [CompilerGeneratedAttribute]
private PackageSourceCredential <Credentials>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Description>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsPersistable>k__BackingField;
    [CompilerGeneratedAttribute]
private int <MaxHttpRequestsPerSource>k__BackingField;
    [CompilerGeneratedAttribute]
private IReadOnlyList`1<X509Certificate> <ClientCertificates>k__BackingField;
    [CompilerGeneratedAttribute]
private int <ProtocolVersion>k__BackingField;
    public string Name { get; private set; }
    public string Source { get; public set; }
    public Uri TrySourceAsUri { get; }
    public Uri SourceUri { get; }
    public bool IsOfficial { get; public set; }
    public bool IsMachineWide { get; public set; }
    public bool IsEnabled { get; public set; }
    public PackageSourceCredential Credentials { get; public set; }
    public string Description { get; public set; }
    public bool IsPersistable { get; private set; }
    public int MaxHttpRequestsPerSource { get; public set; }
    public IReadOnlyList`1<X509Certificate> ClientCertificates { get; public set; }
    public int ProtocolVersion { get; public set; }
    public bool IsHttp { get; }
    public bool IsLocal { get; }
    public PackageSource(string source);
    public PackageSource(string source, string name);
    public PackageSource(string source, string name, bool isEnabled);
    public PackageSource(string source, string name, bool isEnabled, bool isOfficial, bool isPersistable);
    [CompilerGeneratedAttribute]
public string get_Name();
    [CompilerGeneratedAttribute]
private void set_Name(string value);
    [CompilerGeneratedAttribute]
public string get_Source();
    [CompilerGeneratedAttribute]
public void set_Source(string value);
    public Uri get_TrySourceAsUri();
    public Uri get_SourceUri();
    [CompilerGeneratedAttribute]
public bool get_IsOfficial();
    [CompilerGeneratedAttribute]
public void set_IsOfficial(bool value);
    [CompilerGeneratedAttribute]
public bool get_IsMachineWide();
    [CompilerGeneratedAttribute]
public void set_IsMachineWide(bool value);
    [CompilerGeneratedAttribute]
public bool get_IsEnabled();
    [CompilerGeneratedAttribute]
public void set_IsEnabled(bool value);
    [CompilerGeneratedAttribute]
public PackageSourceCredential get_Credentials();
    [CompilerGeneratedAttribute]
public void set_Credentials(PackageSourceCredential value);
    [CompilerGeneratedAttribute]
public string get_Description();
    [CompilerGeneratedAttribute]
public void set_Description(string value);
    [CompilerGeneratedAttribute]
public bool get_IsPersistable();
    [CompilerGeneratedAttribute]
private void set_IsPersistable(bool value);
    [CompilerGeneratedAttribute]
public int get_MaxHttpRequestsPerSource();
    [CompilerGeneratedAttribute]
public void set_MaxHttpRequestsPerSource(int value);
    [CompilerGeneratedAttribute]
public IReadOnlyList`1<X509Certificate> get_ClientCertificates();
    [CompilerGeneratedAttribute]
public void set_ClientCertificates(IReadOnlyList`1<X509Certificate> value);
    [CompilerGeneratedAttribute]
public int get_ProtocolVersion();
    [CompilerGeneratedAttribute]
public void set_ProtocolVersion(int value);
    public bool get_IsHttp();
    public bool get_IsLocal();
    public SourceItem AsSourceItem();
    public sealed virtual bool Equals(PackageSource other);
    public virtual bool Equals(object obj);
    public virtual string ToString();
    public virtual int GetHashCode();
    public PackageSource Clone();
}
public class NuGet.Configuration.PackageSourceCredential : object {
    [CompilerGeneratedAttribute]
private string <Username>k__BackingField;
    [CompilerGeneratedAttribute]
private string <PasswordText>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsPasswordClearText>k__BackingField;
    private Lazy`1<int> _hashCode;
    [CompilerGeneratedAttribute]
private string <ValidAuthenticationTypesText>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Source>k__BackingField;
    public string Username { get; }
    public string PasswordText { get; }
    public bool IsPasswordClearText { get; }
    public IEnumerable`1<string> ValidAuthenticationTypes { get; }
    public string ValidAuthenticationTypesText { get; }
    public string Password { get; }
    public string Source { get; }
    public PackageSourceCredential(string source, string username, string passwordText, bool isPasswordClearText, string validAuthenticationTypesText);
    [CompilerGeneratedAttribute]
public string get_Username();
    [CompilerGeneratedAttribute]
public string get_PasswordText();
    [CompilerGeneratedAttribute]
public bool get_IsPasswordClearText();
    public IEnumerable`1<string> get_ValidAuthenticationTypes();
    [CompilerGeneratedAttribute]
public string get_ValidAuthenticationTypesText();
    public string get_Password();
    [CompilerGeneratedAttribute]
public string get_Source();
    public bool IsValid();
    public static PackageSourceCredential FromUserInput(string source, string username, string password, bool storePasswordInClearText, string validAuthenticationTypesText);
    public ICredentials ToICredentials();
    internal PackageSourceCredential Clone();
    private static IEnumerable`1<string> ParseAuthTypeFilterString(string str);
    public CredentialsItem AsCredentialsItem();
    public sealed virtual bool Equals(PackageSourceCredential other);
    public virtual bool Equals(object other);
    public virtual int GetHashCode();
    [CompilerGeneratedAttribute]
private int <.ctor>b__21_0();
}
public class NuGet.Configuration.PackageSourceProvider : object {
    [CompilerGeneratedAttribute]
private ISettings <Settings>k__BackingField;
    internal static int MaxSupportedProtocolVersion;
    private IEnumerable`1<PackageSource> _configurationDefaultSources;
    [CompilerGeneratedAttribute]
private EventHandler PackageSourcesChanged;
    public ISettings Settings { get; private set; }
    public string DefaultPushSource { get; }
    public string ActivePackageSourceName { get; }
    public PackageSourceProvider(ISettings settings);
    [ObsoleteAttribute("https://github.com/NuGet/Home/issues/8479")]
public PackageSourceProvider(ISettings settings, bool enablePackageSourcesChangedEvent);
    public PackageSourceProvider(ISettings settings, IEnumerable`1<PackageSource> configurationDefaultSources);
    [ObsoleteAttribute("https://github.com/NuGet/Home/issues/8479")]
public PackageSourceProvider(ISettings settings, IEnumerable`1<PackageSource> configurationDefaultSources, bool enablePackageSourcesChangedEvent);
    [CompilerGeneratedAttribute]
public ISettings get_Settings();
    [CompilerGeneratedAttribute]
private void set_Settings(ISettings value);
    private static IEnumerable`1<PackageSource> LoadConfigurationDefaultSources(IEnumerable`1<PackageSource> configurationDefaultSources);
    private static Dictionary`2<string, IndexedPackageSource> LoadPackageSourceLookup(bool byName, ISettings settings);
    private static Dictionary`2<string, IndexedPackageSource> LoadPackageSourceLookupByName(ISettings settings);
    private Dictionary`2<string, IndexedPackageSource> LoadPackageSourceLookupBySource();
    public sealed virtual IEnumerable`1<PackageSource> LoadPackageSources();
    public static IEnumerable`1<PackageSource> LoadPackageSources(ISettings settings);
    private static List`1<PackageSource> LoadPackageSources(ISettings settings, IEnumerable`1<PackageSource> defaultPackageSources);
    private static void AddDefaultPackageSources(List`1<PackageSource> loadedPackageSources, IEnumerable`1<PackageSource> defaultPackageSources);
    private static PackageSource ReadPackageSource(SourceItem setting, bool isEnabled, ISettings settings);
    private static int ReadProtocolVersion(SourceItem setting);
    private static int AddOrUpdateIndexedSource(Dictionary`2<string, IndexedPackageSource> packageSourceLookup, int packageIndex, PackageSource packageSource, string lookupKey);
    private static PackageSourceCredential ReadCredential(string sourceName, ISettings settings);
    private static PackageSourceCredential ReadCredentialFromEnvironment(string sourceName);
    private PackageSource GetPackageSource(string key, Dictionary`2<string, IndexedPackageSource> sourcesLookup);
    public sealed virtual PackageSource GetPackageSourceByName(string name);
    public HashSet`1<string> GetPackageSourceNamesMatchingNamePrefix(string namePrefix);
    public sealed virtual PackageSource GetPackageSourceBySource(string source);
    public sealed virtual void RemovePackageSource(string name);
    private void RemovePackageSource(string name, bool shouldSkipSave, Boolean& isDirty);
    [ObsoleteAttribute("DisablePackageSource(PackageSource source) is deprecated. Please use DisablePackageSource(string name) instead.")]
public void DisablePackageSource(PackageSource source);
    public sealed virtual void DisablePackageSource(string name);
    private void AddDisabledSource(string name, bool shouldSkipSave, Boolean& isDirty);
    public sealed virtual void EnablePackageSource(string name);
    private void RemoveDisabledSource(string name, bool shouldSkipSave, Boolean& isDirty);
    public sealed virtual void UpdatePackageSource(PackageSource source, bool updateCredentials, bool updateEnabled);
    private void UpdatePackageSource(PackageSource newSource, PackageSource existingSource, AddItem existingDisabledSourceItem, CredentialsItem existingCredentialsItem, bool updateEnabled, bool updateCredentials, bool shouldSkipSave, Boolean& isDirty);
    public sealed virtual void AddPackageSource(PackageSource source);
    private void AddPackageSource(PackageSource source, bool shouldSkipSave, Boolean& isDirty);
    public sealed virtual void SavePackageSources(IEnumerable`1<PackageSource> sources);
    private Dictionary`2<string, SourceItem> GetExistingSettingsLookup();
    private void OnPackageSourcesChanged();
    public sealed virtual string get_DefaultPushSource();
    public sealed virtual bool IsPackageSourceEnabled(string name);
    [ObsoleteAttribute("IsPackageSourceEnabled(PackageSource source) is deprecated. Please use IsPackageSourceEnabled(string name) instead.")]
public bool IsPackageSourceEnabled(PackageSource source);
    public sealed virtual string get_ActivePackageSourceName();
    public sealed virtual void SaveActivePackageSource(PackageSource source);
    [CompilerGeneratedAttribute]
public sealed virtual void add_PackageSourcesChanged(EventHandler value);
    [CompilerGeneratedAttribute]
public sealed virtual void remove_PackageSourcesChanged(EventHandler value);
    [CompilerGeneratedAttribute]
private void <.ctor>b__9_0(object _, EventArgs __);
}
internal class NuGet.Configuration.ParsedSettingSection : SettingSection {
    internal ParsedSettingSection(XElement element, SettingsFile origin);
    internal ParsedSettingSection(string name, SettingItem[] children);
    public virtual SettingBase Clone();
}
public class NuGet.Configuration.ProxyCache : object {
    private static IWebProxy _originalSystemProxy;
    private ConcurrentDictionary`2<Uri, ICredentials> _cachedCredentials;
    private ISettings _settings;
    private IEnvironmentVariableReader _environment;
    private static Lazy`1<ProxyCache> _instance;
    [CompilerGeneratedAttribute]
private Guid <Version>k__BackingField;
    public static ProxyCache Instance { get; }
    public Guid Version { get; private set; }
    public ProxyCache(ISettings settings, IEnvironmentVariableReader environment);
    private static ProxyCache();
    private static ProxyCache FromDefaultSettings();
    public static ProxyCache get_Instance();
    [CompilerGeneratedAttribute]
public sealed virtual Guid get_Version();
    [CompilerGeneratedAttribute]
private void set_Version(Guid value);
    public sealed virtual IWebProxy GetProxy(Uri sourceUri);
    private bool TryAddProxyCredentialsToCache(WebProxy configuredProxy);
    public WebProxy GetUserConfiguredProxy();
    public sealed virtual void UpdateCredential(Uri proxyAddress, NetworkCredential credentials);
    public sealed virtual NetworkCredential GetCredential(Uri proxyAddress, string authType);
    [ObsoleteAttribute("Retained for backcompat only. Use UpdateCredential instead")]
public sealed virtual void Add(IWebProxy proxy);
    private static WebProxy GetSystemProxy(Uri uri);
    private static bool IsSystemProxySet(Uri uri);
}
public class NuGet.Configuration.RepositoryItem : TrustedSignerItem {
    private OwnersItem _owners;
    [CompilerGeneratedAttribute]
private IList`1<string> <Owners>k__BackingField;
    [CompilerGeneratedAttribute]
private IReadOnlyCollection`1<string> <RequiredAttributes>k__BackingField;
    public string ElementName { get; }
    public string ServiceIndex { get; }
    public string Name { get; public set; }
    public IList`1<string> Owners { get; private set; }
    protected IReadOnlyCollection`1<string> RequiredAttributes { get; }
    public RepositoryItem(string name, string serviceIndex, CertificateItem[] certificates);
    public RepositoryItem(string name, string serviceIndex, string owners, CertificateItem[] certificates);
    internal RepositoryItem(XElement element, SettingsFile origin);
    public virtual string get_ElementName();
    public string get_ServiceIndex();
    public string get_Name();
    public void set_Name(string value);
    [CompilerGeneratedAttribute]
public IList`1<string> get_Owners();
    [CompilerGeneratedAttribute]
private void set_Owners(IList`1<string> value);
    [CompilerGeneratedAttribute]
protected virtual IReadOnlyCollection`1<string> get_RequiredAttributes();
    public virtual SettingBase Clone();
    internal virtual XNode AsXNode();
    public virtual bool Equals(object other);
    public virtual int GetHashCode();
    internal virtual void SetOrigin(SettingsFile origin);
    internal virtual void RemoveFromSettings();
    internal virtual void Update(SettingItem other);
}
[GeneratedCodeAttribute("System.Resources.Tools.StronglyTypedResourceBuilder", "16.0.0.0")]
[DebuggerNonUserCodeAttribute]
[CompilerGeneratedAttribute]
internal class NuGet.Configuration.Resources : object {
    private static ResourceManager resourceMan;
    private static CultureInfo resourceCulture;
    [EditorBrowsableAttribute("2")]
internal static ResourceManager ResourceManager { get; }
    [EditorBrowsableAttribute("2")]
internal static CultureInfo Culture { get; internal set; }
    internal static string Argument_Cannot_Be_Null_Or_Empty { get; }
    internal static string AttributeNotAllowed { get; }
    internal static string AttributeValueNotAllowed { get; }
    internal static string CannotUpdateDifferentItems { get; }
    internal static string CannotUpdateMachineWide { get; }
    internal static string CannotUpdateNode { get; }
    internal static string CannotUpdateOrigin { get; }
    internal static string CannotUpdateReadOnlyConfig { get; }
    internal static string ClientCertificateDuplicateConfiguration { get; }
    internal static string CredentialsItemMustHaveUsernamePassword { get; }
    internal static string Error_EncryptionUnsupported { get; }
    internal static string Error_InvalidAttribute { get; }
    internal static string Error_MergeTwoDifferentSections { get; }
    internal static string Error_MoreThanOnePassword { get; }
    internal static string Error_MoreThanOneUsername { get; }
    internal static string Error_MoreThanOneValidAuthenticationTypes { get; }
    internal static string Error_NoWritableConfig { get; }
    internal static string Error_StoreCertCertificateNotFound { get; }
    internal static string FileCertItemPasswordAndClearTextPasswordAtSameTime { get; }
    internal static string FileCertItemPasswordCannotBeDecrypted { get; }
    internal static string FileCertItemPathFileNotExist { get; }
    internal static string FileCertItemPathFileNotSet { get; }
    internal static string FileDoesNotExist { get; }
    internal static string InvalidNullSettingsOperation { get; }
    internal static string ItemDoesNotExist { get; }
    internal static string MissingRequiredAttribute { get; }
    internal static string MustContainAbsolutePath { get; }
    internal static string NoAttributesAllowed { get; }
    internal static string NoWritteableConfig { get; }
    internal static string OwnersItemMustHaveAtLeastOneOwner { get; }
    internal static string OwnersMustOnlyHaveContent { get; }
    internal static string PackageSource_Invalid { get; }
    internal static string PropertyCannotBeNullOrEmpty { get; }
    internal static string RelativeEnvVarPath { get; }
    internal static string RepositoryMustHaveOneOwners { get; }
    internal static string SectionDoesNotExist { get; }
    internal static string Settings_FileName_Cannot_Be_A_Path { get; }
    internal static string ShowError_CannotHaveChildren { get; }
    internal static string ShowError_ConfigHasInvalidPackageSource { get; }
    internal static string ShowError_ConfigInvalidOperation { get; }
    internal static string ShowError_ConfigInvalidXml { get; }
    internal static string ShowError_ConfigRootInvalid { get; }
    internal static string ShowError_ConfigUnauthorizedAccess { get; }
    internal static string TextShouldNotBeEmpty { get; }
    internal static string TrustedSignerMustHaveCertificates { get; }
    internal static string Unknown_Config_Exception { get; }
    internal static string UnknownHashAlgorithmNotSupported { get; }
    internal static string UnsupportedDecryptPassword { get; }
    internal static string UnsupportedEncryptPassword { get; }
    internal static string UnsupportedHashAlgorithm { get; }
    internal static string UserSettings_UnableToParseConfigFile { get; }
    internal static ResourceManager get_ResourceManager();
    internal static CultureInfo get_Culture();
    internal static void set_Culture(CultureInfo value);
    internal static string get_Argument_Cannot_Be_Null_Or_Empty();
    internal static string get_AttributeNotAllowed();
    internal static string get_AttributeValueNotAllowed();
    internal static string get_CannotUpdateDifferentItems();
    internal static string get_CannotUpdateMachineWide();
    internal static string get_CannotUpdateNode();
    internal static string get_CannotUpdateOrigin();
    internal static string get_CannotUpdateReadOnlyConfig();
    internal static string get_ClientCertificateDuplicateConfiguration();
    internal static string get_CredentialsItemMustHaveUsernamePassword();
    internal static string get_Error_EncryptionUnsupported();
    internal static string get_Error_InvalidAttribute();
    internal static string get_Error_MergeTwoDifferentSections();
    internal static string get_Error_MoreThanOnePassword();
    internal static string get_Error_MoreThanOneUsername();
    internal static string get_Error_MoreThanOneValidAuthenticationTypes();
    internal static string get_Error_NoWritableConfig();
    internal static string get_Error_StoreCertCertificateNotFound();
    internal static string get_FileCertItemPasswordAndClearTextPasswordAtSameTime();
    internal static string get_FileCertItemPasswordCannotBeDecrypted();
    internal static string get_FileCertItemPathFileNotExist();
    internal static string get_FileCertItemPathFileNotSet();
    internal static string get_FileDoesNotExist();
    internal static string get_InvalidNullSettingsOperation();
    internal static string get_ItemDoesNotExist();
    internal static string get_MissingRequiredAttribute();
    internal static string get_MustContainAbsolutePath();
    internal static string get_NoAttributesAllowed();
    internal static string get_NoWritteableConfig();
    internal static string get_OwnersItemMustHaveAtLeastOneOwner();
    internal static string get_OwnersMustOnlyHaveContent();
    internal static string get_PackageSource_Invalid();
    internal static string get_PropertyCannotBeNullOrEmpty();
    internal static string get_RelativeEnvVarPath();
    internal static string get_RepositoryMustHaveOneOwners();
    internal static string get_SectionDoesNotExist();
    internal static string get_Settings_FileName_Cannot_Be_A_Path();
    internal static string get_ShowError_CannotHaveChildren();
    internal static string get_ShowError_ConfigHasInvalidPackageSource();
    internal static string get_ShowError_ConfigInvalidOperation();
    internal static string get_ShowError_ConfigInvalidXml();
    internal static string get_ShowError_ConfigRootInvalid();
    internal static string get_ShowError_ConfigUnauthorizedAccess();
    internal static string get_TextShouldNotBeEmpty();
    internal static string get_TrustedSignerMustHaveCertificates();
    internal static string get_Unknown_Config_Exception();
    internal static string get_UnknownHashAlgorithmNotSupported();
    internal static string get_UnsupportedDecryptPassword();
    internal static string get_UnsupportedEncryptPassword();
    internal static string get_UnsupportedHashAlgorithm();
    internal static string get_UserSettings_UnableToParseConfigFile();
}
public abstract class NuGet.Configuration.SettingBase : object {
    [CompilerGeneratedAttribute]
private XNode <Node>k__BackingField;
    [CompilerGeneratedAttribute]
private ISettingsGroup <Parent>k__BackingField;
    [CompilerGeneratedAttribute]
private SettingsFile <Origin>k__BackingField;
    internal XNode Node { get; private set; }
    internal ISettingsGroup Parent { get; internal set; }
    internal SettingsFile Origin { get; private set; }
    internal SettingBase(XNode node, SettingsFile origin);
    [CompilerGeneratedAttribute]
internal XNode get_Node();
    [CompilerGeneratedAttribute]
private void set_Node(XNode value);
    [CompilerGeneratedAttribute]
internal ISettingsGroup get_Parent();
    [CompilerGeneratedAttribute]
internal void set_Parent(ISettingsGroup value);
    [CompilerGeneratedAttribute]
internal SettingsFile get_Origin();
    [CompilerGeneratedAttribute]
private void set_Origin(SettingsFile value);
    internal bool IsAbstract();
    internal bool IsCopy();
    public abstract virtual bool IsEmpty();
    internal virtual XNode AsXNode();
    public abstract virtual SettingBase Clone();
    internal void SetNode(XNode node);
    internal virtual void SetOrigin(SettingsFile origin);
    internal virtual void RemoveFromSettings();
}
public abstract class NuGet.Configuration.SettingElement : SettingBase {
    [CompilerGeneratedAttribute]
private string <ElementName>k__BackingField;
    [CompilerGeneratedAttribute]
private IReadOnlyCollection`1<string> <AllowedAttributes>k__BackingField;
    [CompilerGeneratedAttribute]
private IReadOnlyCollection`1<string> <RequiredAttributes>k__BackingField;
    [CompilerGeneratedAttribute]
private IReadOnlyDictionary`2<string, IReadOnlyCollection`1<string>> <AllowedValues>k__BackingField;
    [CompilerGeneratedAttribute]
private IReadOnlyDictionary`2<string, IReadOnlyCollection`1<string>> <DisallowedValues>k__BackingField;
    [CompilerGeneratedAttribute]
private Dictionary`2<string, string> <MutableAttributes>k__BackingField;
    public string ElementName { get; protected set; }
    protected IReadOnlyCollection`1<string> AllowedAttributes { get; }
    protected IReadOnlyCollection`1<string> RequiredAttributes { get; }
    protected IReadOnlyDictionary`2<string, IReadOnlyCollection`1<string>> AllowedValues { get; }
    protected IReadOnlyDictionary`2<string, IReadOnlyCollection`1<string>> DisallowedValues { get; }
    protected Dictionary`2<string, string> MutableAttributes { get; }
    internal IReadOnlyDictionary`2<string, string> Attributes { get; }
    protected SettingElement(IReadOnlyDictionary`2<string, string> attributes);
    internal SettingElement(XElement element, SettingsFile origin);
    [CompilerGeneratedAttribute]
public virtual string get_ElementName();
    [CompilerGeneratedAttribute]
protected virtual void set_ElementName(string value);
    [CompilerGeneratedAttribute]
protected virtual IReadOnlyCollection`1<string> get_AllowedAttributes();
    [CompilerGeneratedAttribute]
protected virtual IReadOnlyCollection`1<string> get_RequiredAttributes();
    [CompilerGeneratedAttribute]
protected virtual IReadOnlyDictionary`2<string, IReadOnlyCollection`1<string>> get_AllowedValues();
    [CompilerGeneratedAttribute]
protected virtual IReadOnlyDictionary`2<string, IReadOnlyCollection`1<string>> get_DisallowedValues();
    [CompilerGeneratedAttribute]
protected Dictionary`2<string, string> get_MutableAttributes();
    internal IReadOnlyDictionary`2<string, string> get_Attributes();
    public virtual bool IsEmpty();
    internal virtual XNode AsXNode();
    protected void AddOrUpdateAttribute(string attributeName, string value);
    internal bool UpdateAttribute(string attributeName, string newValue);
    protected void AddAttribute(string attributeName, string value);
    private bool IsAttributeValid(string attributeName, string value);
    private void ValidateAttributes(XElement element, SettingsFile origin);
}
public enum NuGet.Configuration.SettingElementType : Enum {
    public int value__;
    public static SettingElementType Unknown;
    public static SettingElementType Configuration;
    public static SettingElementType ActivePackageSource;
    public static SettingElementType BindingRedirects;
    public static SettingElementType Config;
    public static SettingElementType PackageManagement;
    public static SettingElementType PackageRestore;
    public static SettingElementType PackageSourceCredentials;
    public static SettingElementType PackageSources;
    public static SettingElementType Add;
    public static SettingElementType Author;
    public static SettingElementType Certificate;
    public static SettingElementType Clear;
    public static SettingElementType Owners;
    public static SettingElementType Repository;
    public static SettingElementType FileCert;
    public static SettingElementType StoreCert;
}
internal static class NuGet.Configuration.SettingFactory : object {
    internal static SettingBase Parse(XNode node, SettingsFile origin);
    internal static IEnumerable`1<T> ParseChildren(XElement xElement, SettingsFile origin, bool canBeCleared);
}
public abstract class NuGet.Configuration.SettingItem : SettingElement {
    [CompilerGeneratedAttribute]
private SettingItem <MergedWith>k__BackingField;
    protected bool CanHaveChildren { get; }
    internal SettingItem MergedWith { get; internal set; }
    protected SettingItem(IReadOnlyDictionary`2<string, string> attributes);
    internal SettingItem(XElement element, SettingsFile origin);
    protected virtual bool get_CanHaveChildren();
    [CompilerGeneratedAttribute]
internal SettingItem get_MergedWith();
    [CompilerGeneratedAttribute]
internal void set_MergedWith(SettingItem value);
    internal virtual void Update(SettingItem setting);
}
public class NuGet.Configuration.Settings : object {
    public static string DefaultSettingsFileName;
    public static String[] OrderedSettingsFileNames;
    public static String[] SupportedMachineWideConfigExtension;
    private Dictionary`2<string, VirtualSettingSection> _computedSections;
    [CompilerGeneratedAttribute]
private EventHandler SettingsChanged;
    [CompilerGeneratedAttribute]
private IList`1<SettingsFile> <SettingsFiles>k__BackingField;
    private IList`1<SettingsFile> SettingsFiles { get; }
    internal IEnumerable`1<SettingsFile> Priority { get; }
    public Settings(string root);
    public Settings(string root, string fileName);
    public Settings(string root, string fileName, bool isMachineWide);
    internal Settings(IList`1<SettingsFile> settingsFiles);
    private static Settings();
    public sealed virtual SettingSection GetSection(string sectionName);
    public sealed virtual void AddOrUpdate(string sectionName, SettingItem item);
    internal void AddOrUpdate(SettingsFile settingsFile, string sectionName, SettingItem item);
    public sealed virtual void Remove(string sectionName, SettingItem item);
    [CompilerGeneratedAttribute]
public sealed virtual void add_SettingsChanged(EventHandler value);
    [CompilerGeneratedAttribute]
public sealed virtual void remove_SettingsChanged(EventHandler value);
    [CompilerGeneratedAttribute]
private IList`1<SettingsFile> get_SettingsFiles();
    private SettingsFile GetOutputSettingFileForSection(string sectionName);
    internal IEnumerable`1<SettingsFile> get_Priority();
    public sealed virtual void SaveToDisk();
    public static ISettings LoadDefaultSettings(string root);
    public static ISettings LoadDefaultSettings(string root, string configFileName, IMachineWideSettings machineWideSettings);
    public static ISettings LoadDefaultSettings(string root, string configFileName, IMachineWideSettings machineWideSettings, SettingsLoadingContext settingsLoadingContext);
    public static ISettings LoadSpecificSettings(string root, string configFileName);
    public static ISettings LoadImmutableSettingsGivenConfigPaths(IList`1<string> configFilePaths, SettingsLoadingContext settingsLoadingContext);
    public static ISettings LoadSettingsGivenConfigPaths(IList`1<string> configFilePaths);
    private static ISettings LoadSettingsGivenSettingsFiles(List`1<SettingsFile> settings);
    internal static ISettings LoadSettings(string root, string configFileName, IMachineWideSettings machineWideSettings, bool loadUserWideSettings, bool useTestingGlobalPath, SettingsLoadingContext settingsLoadingContext);
    internal static ISettings LoadSettings(DirectoryInfo root, IMachineWideSettings machineWideSettings, bool loadUserWideSettings, bool useTestingGlobalPath, SettingsLoadingContext settingsLoadingContext);
    private static ISettings LoadSettingsForSpecificConfigs(string root, string configFileName, List`1<SettingsFile> validSettingFiles, IMachineWideSettings machineWideSettings, bool loadUserWideSettings, bool useTestingGlobalPath, SettingsLoadingContext settingsLoadingContext);
    [IteratorStateMachineAttribute("NuGet.Configuration.Settings/<LoadUserSpecificSettings>d__32")]
internal static IEnumerable`1<SettingsFile> LoadUserSpecificSettings(string root, string configFileName, bool useTestingGlobalPath, SettingsLoadingContext settingsLoadingContext);
    private static string GetUserSettingsDirectory(string rootDirectory, bool useTestingGlobalPath);
    private static string GetAdditionalUserWideConfigurationDirectory(string userSettingsDirectory);
    public static ISettings LoadMachineWideSettings(string root, String[] paths);
    public static string ApplyEnvironmentTransform(string value);
    public static Tuple`2<string, string> GetFileNameAndItsRoot(string root, string settingsPath);
    public sealed virtual IList`1<string> GetConfigFilePaths();
    public sealed virtual IList`1<string> GetConfigRoots();
    internal static string ResolvePathFromOrigin(string originDirectoryPath, string originFilePath, string path);
    private static string ResolveRelativePath(string originDirectoryPath, string originFilePath, string path);
    private static string ResolvePath(string configDirectory, string value);
    private static SettingsFile ReadSettings(string settingsRoot, string settingsPath, bool isMachineWideSettings, bool isAdditionalUserWideConfig, SettingsLoadingContext settingsLoadingContext);
    [IteratorStateMachineAttribute("NuGet.Configuration.Settings/<GetSettingsFilesFullPath>d__44")]
private static IEnumerable`1<string> GetSettingsFilesFullPath(string root);
    private static string GetSettingsFileNameFromDir(string directory);
    [IteratorStateMachineAttribute("NuGet.Configuration.Settings/<GetSettingsFilePaths>d__46")]
private static IEnumerable`1<string> GetSettingsFilePaths(string root);
}
public abstract class NuGet.Configuration.SettingSection : SettingsGroup`1<SettingItem> {
    private string _elementName;
    public string ElementName { get; protected set; }
    public IReadOnlyCollection`1<SettingItem> Items { get; }
    protected SettingSection(string name, IReadOnlyDictionary`2<string, string> attributes, IEnumerable`1<SettingItem> children);
    internal SettingSection(XElement element, SettingsFile origin);
    public virtual string get_ElementName();
    protected virtual void set_ElementName(string value);
    public IReadOnlyCollection`1<SettingItem> get_Items();
    public T GetFirstItemWithAttribute(string attributeName, string expectedAttributeValue);
    internal bool Update(SettingItem item);
    public virtual bool Equals(object other);
    public virtual int GetHashCode();
}
internal class NuGet.Configuration.SettingsFile : object {
    [CompilerGeneratedAttribute]
private string <ConfigFilePath>k__BackingField;
    [CompilerGeneratedAttribute]
private string <DirectoryPath>k__BackingField;
    [CompilerGeneratedAttribute]
private string <FileName>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsDirty>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsMachineWide>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsReadOnly>k__BackingField;
    private XDocument _xDocument;
    private NuGetConfiguration _rootElement;
    internal string ConfigFilePath { get; }
    internal string DirectoryPath { get; }
    internal string FileName { get; }
    internal bool IsDirty { get; internal set; }
    internal bool IsMachineWide { get; }
    internal bool IsReadOnly { get; }
    public SettingsFile(string directoryPath);
    public SettingsFile(string directoryPath, string fileName);
    public SettingsFile(string directoryPath, string fileName, bool isMachineWide, bool isReadOnly);
    [CompilerGeneratedAttribute]
internal string get_ConfigFilePath();
    [CompilerGeneratedAttribute]
internal string get_DirectoryPath();
    [CompilerGeneratedAttribute]
internal string get_FileName();
    [CompilerGeneratedAttribute]
internal bool get_IsDirty();
    [CompilerGeneratedAttribute]
internal void set_IsDirty(bool value);
    [CompilerGeneratedAttribute]
internal bool get_IsMachineWide();
    [CompilerGeneratedAttribute]
internal bool get_IsReadOnly();
    public SettingSection GetSection(string sectionName);
    internal void AddOrUpdate(string sectionName, SettingItem item);
    internal void Remove(string sectionName, SettingItem item);
    internal void SaveToDisk();
    internal bool IsEmpty();
    internal bool TryGetSection(string sectionName, SettingSection& section);
    internal void MergeSectionsInto(Dictionary`2<string, VirtualSettingSection> sectionsContainer);
    private XDocument CreateDefaultConfig();
    private void ExecuteSynchronized(Action ioOperation);
    [CompilerGeneratedAttribute]
private void <SaveToDisk>b__27_0();
}
public abstract class NuGet.Configuration.SettingsGroup`1 : SettingElement {
    [CompilerGeneratedAttribute]
private IList`1<T> <Children>k__BackingField;
    protected IList`1<T> Children { get; private set; }
    protected bool CanBeCleared { get; }
    protected SettingsGroup`1(IReadOnlyDictionary`2<string, string> attributes, IEnumerable`1<T> children);
    internal SettingsGroup`1(XElement element, SettingsFile origin);
    [CompilerGeneratedAttribute]
protected IList`1<T> get_Children();
    [CompilerGeneratedAttribute]
private void set_Children(IList`1<T> value);
    protected virtual bool get_CanBeCleared();
    public virtual bool IsEmpty();
    internal virtual XNode AsXNode();
    internal virtual void SetOrigin(SettingsFile origin);
    internal virtual void RemoveFromSettings();
    internal virtual bool Add(T setting);
    internal virtual void Remove(T setting);
    protected bool TryGetChild(T expectedChild, T& currentChild);
    private sealed virtual override void NuGet.Configuration.ISettingsGroup.Remove(SettingElement setting);
}
public class NuGet.Configuration.SettingsLoadingContext : object {
    private IList`1<Lazy`1<SettingsFile>> _settingsFiles;
    private SemaphoreSlim _semaphore;
    private bool _isDisposed;
    internal SettingsFile GetOrCreateSettingsFile(string filePath, bool isMachineWide, bool isReadOnly);
    public sealed virtual void Dispose();
}
public static class NuGet.Configuration.SettingsUtility : object {
    private static string GlobalPackagesFolderEnvironmentKey;
    private static string FallbackPackagesFolderEnvironmentKey;
    private static string HttpCacheEnvironmentKey;
    private static string PluginsCacheEnvironmentKey;
    public static string DefaultGlobalPackagesFolderPath;
    private static string RevocationModeEnvironmentKey;
    private static SettingsUtility();
    public static string GetValueForAddItem(ISettings settings, string section, string key, bool isPath);
    public static bool DeleteValue(ISettings settings, string section, string attributeKey, string attributeValue);
    public static string GetRepositoryPath(ISettings settings);
    public static int GetMaxHttpRequest(ISettings settings);
    public static SignatureValidationMode GetSignatureValidationMode(ISettings settings);
    public static string GetDecryptedValueForAddItem(ISettings settings, string section, string key, bool isPath);
    public static void SetEncryptedValueForAddItem(ISettings settings, string section, string key, string value);
    public static string GetConfigValue(ISettings settings, string key, bool decrypt, bool isPath);
    public static void SetConfigValue(ISettings settings, string key, string value, bool encrypt);
    public static bool DeleteConfigValue(ISettings settings, string key);
    public static string GetGlobalPackagesFolder(ISettings settings);
    public static IReadOnlyList`1<string> GetFallbackPackageFolders(ISettings settings);
    private static IReadOnlyList`1<string> GetFallbackPackageFoldersFromConfig(ISettings settings);
    public static string GetHttpCacheFolder();
    public static string GetPluginsCacheFolder();
    public static IEnumerable`1<PackageSource> GetEnabledSources(ISettings settings);
    public static string GetDefaultPushSource(ISettings settings);
    public static RevocationMode GetRevocationMode(IEnvironmentVariableReader environmentVariableReader);
    private static void VerifyPathIsRooted(string key, string path);
}
public class NuGet.Configuration.SettingText : SettingBase {
    private string _value;
    public string Value { get; public set; }
    public SettingText(string value);
    internal SettingText(XText text, SettingsFile origin);
    public string get_Value();
    public void set_Value(string value);
    public virtual bool Equals(object other);
    public virtual int GetHashCode();
    public virtual bool IsEmpty();
    public virtual SettingBase Clone();
    internal virtual XNode AsXNode();
}
[ObsoleteAttribute("SettingValue is deprecated. Please use AddItem instead")]
public class NuGet.Configuration.SettingValue : object {
    [CompilerGeneratedAttribute]
private string <Key>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Value>k__BackingField;
    [CompilerGeneratedAttribute]
private string <OriginalValue>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsMachineWide>k__BackingField;
    [CompilerGeneratedAttribute]
private int <Priority>k__BackingField;
    [CompilerGeneratedAttribute]
private ISettings <Origin>k__BackingField;
    [CompilerGeneratedAttribute]
private IDictionary`2<string, string> <AdditionalData>k__BackingField;
    public string Key { get; private set; }
    public string Value { get; public set; }
    public string OriginalValue { get; public set; }
    public bool IsMachineWide { get; public set; }
    public int Priority { get; public set; }
    public ISettings Origin { get; }
    public IDictionary`2<string, string> AdditionalData { get; }
    public SettingValue(string key, string value, bool isMachineWide, int priority);
    public SettingValue(string key, string value, ISettings origin, bool isMachineWide, int priority);
    public SettingValue(string key, string value, ISettings origin, bool isMachineWide, string originalValue, int priority);
    [CompilerGeneratedAttribute]
public string get_Key();
    [CompilerGeneratedAttribute]
private void set_Key(string value);
    [CompilerGeneratedAttribute]
public string get_Value();
    [CompilerGeneratedAttribute]
public void set_Value(string value);
    [CompilerGeneratedAttribute]
public string get_OriginalValue();
    [CompilerGeneratedAttribute]
public void set_OriginalValue(string value);
    [CompilerGeneratedAttribute]
public bool get_IsMachineWide();
    [CompilerGeneratedAttribute]
public void set_IsMachineWide(bool value);
    [CompilerGeneratedAttribute]
public int get_Priority();
    [CompilerGeneratedAttribute]
public void set_Priority(int value);
    [CompilerGeneratedAttribute]
public ISettings get_Origin();
    [CompilerGeneratedAttribute]
public IDictionary`2<string, string> get_AdditionalData();
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
}
public class NuGet.Configuration.SourceItem : AddItem {
    public string ProtocolVersion { get; public set; }
    public SourceItem(string key, string value, string protocolVersion);
    internal SourceItem(XElement element, SettingsFile origin);
    public string get_ProtocolVersion();
    public void set_ProtocolVersion(string value);
    public virtual int GetHashCode();
    public virtual SettingBase Clone();
    public virtual bool Equals(object other);
}
public class NuGet.Configuration.StoreClientCertItem : ClientCertItem {
    private static X509FindType DefaultFindBy;
    private static StoreLocation DefaultStoreLocation;
    private static StoreName DefaultStoreName;
    [CompilerGeneratedAttribute]
private IReadOnlyCollection`1<string> <AllowedAttributes>k__BackingField;
    [CompilerGeneratedAttribute]
private IReadOnlyDictionary`2<string, IReadOnlyCollection`1<string>> <AllowedValues>k__BackingField;
    [CompilerGeneratedAttribute]
private IReadOnlyCollection`1<string> <RequiredAttributes>k__BackingField;
    public string ElementName { get; }
    public X509FindType FindType { get; }
    public string FindValue { get; }
    public StoreLocation StoreLocation { get; }
    public StoreName StoreName { get; }
    protected IReadOnlyCollection`1<string> AllowedAttributes { get; }
    protected IReadOnlyDictionary`2<string, IReadOnlyCollection`1<string>> AllowedValues { get; }
    protected IReadOnlyCollection`1<string> RequiredAttributes { get; }
    public StoreClientCertItem(string packageSource, string findValue, Nullable`1<StoreLocation> storeLocation, Nullable`1<StoreName> storeName, Nullable`1<X509FindType> findBy);
    internal StoreClientCertItem(XElement element, SettingsFile origin);
    public static string GetString(X509FindType type);
    public static string GetString(StoreName storeName);
    public static string GetString(StoreLocation storeLocation);
    public virtual string get_ElementName();
    public X509FindType get_FindType();
    public string get_FindValue();
    public StoreLocation get_StoreLocation();
    public StoreName get_StoreName();
    [CompilerGeneratedAttribute]
protected virtual IReadOnlyCollection`1<string> get_AllowedAttributes();
    [CompilerGeneratedAttribute]
protected virtual IReadOnlyDictionary`2<string, IReadOnlyCollection`1<string>> get_AllowedValues();
    [CompilerGeneratedAttribute]
protected virtual IReadOnlyCollection`1<string> get_RequiredAttributes();
    internal virtual XNode AsXNode();
    public virtual SettingBase Clone();
    public virtual IEnumerable`1<X509Certificate> Search();
    public void Update(string findValue, Nullable`1<StoreLocation> storeLocation, Nullable`1<StoreName> storeName, Nullable`1<X509FindType> findBy);
}
public abstract class NuGet.Configuration.TrustedSignerItem : SettingItem {
    [CompilerGeneratedAttribute]
private IList`1<CertificateItem> <Certificates>k__BackingField;
    internal IEnumerable`1<SettingBase> _parsedDescendants;
    protected bool CanHaveChildren { get; }
    public IList`1<CertificateItem> Certificates { get; }
    public string Name { get; }
    protected TrustedSignerItem(string name, IEnumerable`1<CertificateItem> certificates);
    internal TrustedSignerItem(XElement element, SettingsFile origin);
    protected virtual bool get_CanHaveChildren();
    [CompilerGeneratedAttribute]
public IList`1<CertificateItem> get_Certificates();
    public virtual string get_Name();
    protected void SetName(string value);
    internal virtual void SetOrigin(SettingsFile origin);
    internal virtual void RemoveFromSettings();
    internal virtual void Update(SettingItem other);
}
public class NuGet.Configuration.UnknownItem : SettingItem {
    [CompilerGeneratedAttribute]
private string <ElementName>k__BackingField;
    private Dictionary`2<SettingBase, SettingBase> _mutableChildren;
    public string ElementName { get; protected set; }
    public IReadOnlyList`1<SettingBase> Children { get; }
    public IReadOnlyDictionary`2<string, string> Attributes { get; }
    protected bool CanHaveChildren { get; }
    internal UnknownItem(XElement element, SettingsFile origin);
    public UnknownItem(string name, IReadOnlyDictionary`2<string, string> attributes, IEnumerable`1<SettingBase> children);
    [CompilerGeneratedAttribute]
public virtual string get_ElementName();
    [CompilerGeneratedAttribute]
protected virtual void set_ElementName(string value);
    public IReadOnlyList`1<SettingBase> get_Children();
    public IReadOnlyDictionary`2<string, string> get_Attributes();
    public virtual bool IsEmpty();
    protected virtual bool get_CanHaveChildren();
    public virtual SettingBase Clone();
    internal bool Add(SettingBase setting);
    private sealed virtual override void NuGet.Configuration.ISettingsGroup.Remove(SettingElement setting);
    internal void Remove(SettingBase setting);
    internal virtual XNode AsXNode();
    public virtual bool Equals(object other);
    public virtual int GetHashCode();
    internal virtual void Update(SettingItem setting);
    internal void Merge(UnknownItem item);
    internal virtual void SetOrigin(SettingsFile origin);
    internal virtual void RemoveFromSettings();
}
public class NuGet.Configuration.VirtualSettingSection : SettingSection {
    internal VirtualSettingSection(SettingSection section);
    internal VirtualSettingSection(string name, SettingItem[] children);
    internal VirtualSettingSection(string name, IReadOnlyDictionary`2<string, string> attributes, IEnumerable`1<SettingItem> children);
    internal VirtualSettingSection Merge(SettingSection other);
    internal virtual bool Add(SettingItem setting);
    internal virtual void Remove(SettingItem setting);
    private bool TryRemoveAllMergedWith(SettingItem currentSetting, SettingItem& undeletedItem);
    public virtual SettingBase Clone();
}
public class NuGet.Configuration.WebProxy : object {
    private IReadOnlyList`1<string> _bypassList;
    private Regex[] _regExBypassList;
    [CompilerGeneratedAttribute]
private Uri <ProxyAddress>k__BackingField;
    [CompilerGeneratedAttribute]
private ICredentials <Credentials>k__BackingField;
    public Uri ProxyAddress { get; private set; }
    public ICredentials Credentials { get; public set; }
    public IReadOnlyList`1<string> BypassList { get; public set; }
    public WebProxy(string proxyAddress);
    public WebProxy(Uri proxyAddress);
    [CompilerGeneratedAttribute]
public Uri get_ProxyAddress();
    [CompilerGeneratedAttribute]
private void set_ProxyAddress(Uri value);
    [CompilerGeneratedAttribute]
public sealed virtual ICredentials get_Credentials();
    [CompilerGeneratedAttribute]
public sealed virtual void set_Credentials(ICredentials value);
    public IReadOnlyList`1<string> get_BypassList();
    public void set_BypassList(IReadOnlyList`1<string> value);
    public sealed virtual Uri GetProxy(Uri destination);
    public sealed virtual bool IsBypassed(Uri uri);
    private void UpdateRegExList();
    private static string WildcardToRegex(string pattern);
    private static Uri CreateProxyUri(string address);
}
internal static class NuGet.Configuration.XElementUtility : object {
    internal static string GetOptionalAttributeValue(XElement element, string localName);
    internal static string GetOptionalAttributeValue(XElement element, string localName, string namespaceName);
    internal static void AddIndented(XContainer container, XNode content);
    internal static void RemoveIndented(XNode element);
    private static string ComputeOneLevelOfIndentation(XNode node);
    private static bool IsWhiteSpace(XText textNode);
    private static void IndentChildrenElements(XContainer container, string containerIndent, string oneIndentLevel);
    private static void AddLeadingIndentation(XContainer container, string containerIndent, string oneIndentLevel);
    private static void AddTrailingIndentation(XContainer container, string containerIndent);
}
internal static class NuGet.Configuration.XmlUtility : object {
    internal static XDocument GetOrCreateDocument(XDocument content, string fullPath);
    internal static string GetEncodedXMLName(string name);
    private static XDocument CreateDocument(XDocument content, string fullPath);
    private static XDocument GetDocument(string fullPath);
    private static XDocument LoadSafe(Stream input, LoadOptions options);
    private static XmlReaderSettings CreateSafeSettings(bool ignoreWhiteSpace);
}
public class NuGet.Configuration.XPlatMachineWideSetting : object {
    private Lazy`1<ISettings> _settings;
    public ISettings Settings { get; }
    public sealed virtual ISettings get_Settings();
}
[ExtensionAttribute]
internal static class NuGet.Shared.EqualityUtility : object {
    [ExtensionAttribute]
internal static bool OrderedEquals(IEnumerable`1<TSource> self, IEnumerable`1<TSource> other, Func`2<TSource, TKey> keySelector, IComparer`1<TKey> orderComparer, IEqualityComparer`1<TSource> sequenceComparer);
    [ExtensionAttribute]
internal static bool SequenceEqualWithNullCheck(IEnumerable`1<T> self, IEnumerable`1<T> other, IEqualityComparer`1<T> comparer);
    [ExtensionAttribute]
internal static bool SetEqualsWithNullCheck(ISet`1<T> self, ISet`1<T> other, IEqualityComparer`1<T> comparer);
    internal static bool DictionaryEquals(IDictionary`2<TKey, TValue> self, IDictionary`2<TKey, TValue> other, Func`3<TValue, TValue, bool> compareValues);
    internal static bool DictionaryOfSequenceEquals(IDictionary`2<TKey, IEnumerable`1<TValue>> self, IDictionary`2<TKey, IEnumerable`1<TValue>> other);
    internal static bool EqualsWithNullCheck(T self, T other);
    private static bool TryIdentityEquals(T self, T other, Boolean& equals);
}
[ExtensionAttribute]
internal static class NuGet.Shared.Extensions : object {
    [ExtensionAttribute]
public static List`1<T> AsList(IEnumerable`1<T> enumerable);
    [ExtensionAttribute]
public static HashSet`1<T> AsHashSet(ISet`1<T> enumerable, IEqualityComparer`1<T> comparer);
    [ExtensionAttribute]
public static void ForEach(IEnumerable`1<T> enumeration, Action`1<T> action);
}
internal class NuGet.Shared.HashCodeCombiner : ValueType {
    private static long Seed;
    private bool _initialized;
    private long _combinedHash;
    internal int CombinedHash { get; }
    internal int get_CombinedHash();
    private void AddHashCode(int i);
    internal void AddObject(int i);
    internal void AddObject(TValue o, IEqualityComparer`1<TValue> comparer);
    internal void AddObject(T o);
    internal void AddStringIgnoreCase(string s);
    internal void AddSequence(IEnumerable`1<T> sequence);
    internal void AddSequence(T[] array);
    internal void AddSequence(IList`1<T> list);
    internal void AddSequence(IReadOnlyList`1<T> list);
    internal void AddDictionary(IEnumerable`1<KeyValuePair`2<TKey, TValue>> dictionary);
    internal static int GetHashCode(T1 o1, T2 o2);
    internal static int GetHashCode(T1 o1, T2 o2, T3 o3);
    private void CheckInitialized();
}
