public class NuGet.ProjectModel.AssetsLogMessage : object {
    [CompilerGeneratedAttribute]
private LogLevel <Level>k__BackingField;
    [CompilerGeneratedAttribute]
private NuGetLogCode <Code>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Message>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ProjectPath>k__BackingField;
    [CompilerGeneratedAttribute]
private WarningLevel <WarningLevel>k__BackingField;
    [CompilerGeneratedAttribute]
private string <FilePath>k__BackingField;
    [CompilerGeneratedAttribute]
private string <LibraryId>k__BackingField;
    [CompilerGeneratedAttribute]
private IReadOnlyList`1<string> <TargetGraphs>k__BackingField;
    [CompilerGeneratedAttribute]
private int <StartLineNumber>k__BackingField;
    [CompilerGeneratedAttribute]
private int <StartColumnNumber>k__BackingField;
    [CompilerGeneratedAttribute]
private int <EndLineNumber>k__BackingField;
    [CompilerGeneratedAttribute]
private int <EndColumnNumber>k__BackingField;
    public LogLevel Level { get; }
    public NuGetLogCode Code { get; }
    public string Message { get; }
    public string ProjectPath { get; public set; }
    public WarningLevel WarningLevel { get; public set; }
    public string FilePath { get; public set; }
    public string LibraryId { get; public set; }
    public IReadOnlyList`1<string> TargetGraphs { get; public set; }
    public int StartLineNumber { get; public set; }
    public int StartColumnNumber { get; public set; }
    public int EndLineNumber { get; public set; }
    public int EndColumnNumber { get; public set; }
    public AssetsLogMessage(LogLevel logLevel, NuGetLogCode errorCode, string errorString, string targetGraph);
    public AssetsLogMessage(LogLevel logLevel, NuGetLogCode errorCode, string errorString);
    [CompilerGeneratedAttribute]
public sealed virtual LogLevel get_Level();
    [CompilerGeneratedAttribute]
public sealed virtual NuGetLogCode get_Code();
    [CompilerGeneratedAttribute]
public sealed virtual string get_Message();
    [CompilerGeneratedAttribute]
public sealed virtual string get_ProjectPath();
    [CompilerGeneratedAttribute]
public void set_ProjectPath(string value);
    [CompilerGeneratedAttribute]
public sealed virtual WarningLevel get_WarningLevel();
    [CompilerGeneratedAttribute]
public void set_WarningLevel(WarningLevel value);
    [CompilerGeneratedAttribute]
public sealed virtual string get_FilePath();
    [CompilerGeneratedAttribute]
public void set_FilePath(string value);
    [CompilerGeneratedAttribute]
public sealed virtual string get_LibraryId();
    [CompilerGeneratedAttribute]
public void set_LibraryId(string value);
    [CompilerGeneratedAttribute]
public sealed virtual IReadOnlyList`1<string> get_TargetGraphs();
    [CompilerGeneratedAttribute]
public void set_TargetGraphs(IReadOnlyList`1<string> value);
    [CompilerGeneratedAttribute]
public sealed virtual int get_StartLineNumber();
    [CompilerGeneratedAttribute]
public void set_StartLineNumber(int value);
    [CompilerGeneratedAttribute]
public sealed virtual int get_StartColumnNumber();
    [CompilerGeneratedAttribute]
public void set_StartColumnNumber(int value);
    [CompilerGeneratedAttribute]
public sealed virtual int get_EndLineNumber();
    [CompilerGeneratedAttribute]
public void set_EndLineNumber(int value);
    [CompilerGeneratedAttribute]
public sealed virtual int get_EndColumnNumber();
    [CompilerGeneratedAttribute]
public void set_EndColumnNumber(int value);
    public static IAssetsLogMessage Create(IRestoreLogMessage logMessage);
    public sealed virtual bool Equals(IAssetsLogMessage other);
    public virtual bool Equals(object other);
    public virtual int GetHashCode();
}
public class NuGet.ProjectModel.BuildAction : ValueType {
    private static ConcurrentDictionary`2<string, BuildAction> _knownBuildActions;
    public static BuildAction None;
    public static BuildAction Compile;
    public static BuildAction Content;
    public static BuildAction EmbeddedResource;
    public static BuildAction ApplicationDefinition;
    public static BuildAction Page;
    public static BuildAction Resource;
    public static BuildAction SplashScreen;
    public static BuildAction DesignData;
    public static BuildAction DesignDataWithDesignTimeCreatableTypes;
    public static BuildAction CodeAnalysisDictionary;
    public static BuildAction AndroidAsset;
    public static BuildAction AndroidResource;
    public static BuildAction BundleResource;
    [CompilerGeneratedAttribute]
private string <Value>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsKnown>k__BackingField;
    public string Value { get; }
    public bool IsKnown { get; }
    private BuildAction(string value, bool isKnown);
    private static BuildAction();
    [CompilerGeneratedAttribute]
public string get_Value();
    [CompilerGeneratedAttribute]
public bool get_IsKnown();
    public static BuildAction Parse(string value);
    public virtual string ToString();
    public sealed virtual bool Equals(BuildAction other);
    public virtual bool Equals(object obj);
    public static bool op_Equality(BuildAction left, BuildAction right);
    public static bool op_Inequality(BuildAction left, BuildAction right);
    public virtual int GetHashCode();
    private static BuildAction Define(string name);
}
public class NuGet.ProjectModel.BuildOptions : object {
    [CompilerGeneratedAttribute]
private string <OutputName>k__BackingField;
    public string OutputName { get; public set; }
    [CompilerGeneratedAttribute]
public string get_OutputName();
    [CompilerGeneratedAttribute]
public void set_OutputName(string value);
    public virtual int GetHashCode();
    public virtual bool Equals(object obj);
    public sealed virtual bool Equals(BuildOptions other);
    public BuildOptions Clone();
}
public class NuGet.ProjectModel.CacheFile : object {
    internal static int CurrentVersion;
    [CompilerGeneratedAttribute]
private string <DgSpecHash>k__BackingField;
    [CompilerGeneratedAttribute]
private int <Version>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <Success>k__BackingField;
    [CompilerGeneratedAttribute]
private IList`1<string> <ExpectedPackageFilePaths>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <HasAnyMissingPackageFiles>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ProjectFilePath>k__BackingField;
    [CompilerGeneratedAttribute]
private IList`1<IAssetsLogMessage> <LogMessages>k__BackingField;
    public string DgSpecHash { get; }
    public int Version { get; public set; }
    public bool Success { get; public set; }
    public IList`1<string> ExpectedPackageFilePaths { get; public set; }
    public bool HasAnyMissingPackageFiles { get; public set; }
    public string ProjectFilePath { get; public set; }
    public IList`1<IAssetsLogMessage> LogMessages { get; public set; }
    public bool IsValid { get; }
    public CacheFile(string dgSpecHash);
    [CompilerGeneratedAttribute]
public string get_DgSpecHash();
    [CompilerGeneratedAttribute]
public int get_Version();
    [CompilerGeneratedAttribute]
public void set_Version(int value);
    [CompilerGeneratedAttribute]
public bool get_Success();
    [CompilerGeneratedAttribute]
public void set_Success(bool value);
    [CompilerGeneratedAttribute]
public IList`1<string> get_ExpectedPackageFilePaths();
    [CompilerGeneratedAttribute]
public void set_ExpectedPackageFilePaths(IList`1<string> value);
    [CompilerGeneratedAttribute]
public bool get_HasAnyMissingPackageFiles();
    [CompilerGeneratedAttribute]
public void set_HasAnyMissingPackageFiles(bool value);
    [CompilerGeneratedAttribute]
public string get_ProjectFilePath();
    [CompilerGeneratedAttribute]
public void set_ProjectFilePath(string value);
    [CompilerGeneratedAttribute]
public IList`1<IAssetsLogMessage> get_LogMessages();
    [CompilerGeneratedAttribute]
public void set_LogMessages(IList`1<IAssetsLogMessage> value);
    public bool get_IsValid();
    public sealed virtual bool Equals(CacheFile other);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
}
public class NuGet.ProjectModel.CacheFileFormat : object {
    private static string VersionProperty;
    private static string DGSpecHashProperty;
    private static string SuccessProperty;
    private static string ExpectedPackageFilesProperty;
    private static string ProjectFilePathProperty;
    public static CacheFile Read(Stream stream, ILogger log, string path);
    private static CacheFile Read(TextReader reader, ILogger log, string path);
    public static void Write(string filePath, CacheFile lockFile);
    public static void Write(Stream stream, CacheFile cacheFile);
    private static void Write(TextWriter textWriter, CacheFile cacheFile);
    private static CacheFile ReadCacheFile(JObject cursor);
    private static JObject GetCacheFile(CacheFile cacheFile);
    private static string ReadString(JToken json);
    private static JToken WriteString(string item);
    private static int ReadInt(JToken json);
    private static JToken WriteInt(int item);
    private static bool ReadBool(JToken json);
    private static JToken WriteBool(bool item);
}
public class NuGet.ProjectModel.CentralTransitiveDependencyGroup : object {
    [CompilerGeneratedAttribute]
private string <FrameworkName>k__BackingField;
    [CompilerGeneratedAttribute]
private IEnumerable`1<LibraryDependency> <TransitiveDependencies>k__BackingField;
    public string FrameworkName { get; }
    public IEnumerable`1<LibraryDependency> TransitiveDependencies { get; }
    public CentralTransitiveDependencyGroup(NuGetFramework framework, IEnumerable`1<LibraryDependency> transitiveDependencies);
    [CompilerGeneratedAttribute]
public string get_FrameworkName();
    [CompilerGeneratedAttribute]
public IEnumerable`1<LibraryDependency> get_TransitiveDependencies();
    public sealed virtual bool Equals(CentralTransitiveDependencyGroup other);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
}
internal class NuGet.ProjectModel.CircularMemoryStream : MemoryStream {
    private Byte[] _buffer;
    [CompilerGeneratedAttribute]
private EventHandler`1<ArraySegment`1<byte>> OnFlush;
    internal CircularMemoryStream(Byte[] buffer);
    [CompilerGeneratedAttribute]
internal void add_OnFlush(EventHandler`1<ArraySegment`1<byte>> value);
    [CompilerGeneratedAttribute]
internal void remove_OnFlush(EventHandler`1<ArraySegment`1<byte>> value);
    public virtual void Write(Byte[] buffer, int offset, int count);
    public virtual void WriteByte(byte value);
    public virtual void Flush();
    private void FlushIfFull();
}
public class NuGet.ProjectModel.DependencyGraphSpec : object {
    private static string DGSpecFileNameExtension;
    private SortedSet`1<string> _restore;
    private SortedDictionary`2<string, PackageSpec> _projects;
    private Lazy`1<JObject> _json;
    private static int Version;
    private bool _isReadOnly;
    public IReadOnlyList`1<string> Restore { get; }
    public IReadOnlyList`1<PackageSpec> Projects { get; }
    [ObsoleteAttribute("This property is obsolete and will be removed in a future release.")]
public JObject Json { get; }
    [ObsoleteAttribute("This constructor is obsolete and will be removed in a future release.")]
public DependencyGraphSpec(JObject json);
    public DependencyGraphSpec(bool isReadOnly);
    private DependencyGraphSpec(string filePath);
    public static string GetDGSpecFileName(string projectName);
    public IReadOnlyList`1<string> get_Restore();
    public IReadOnlyList`1<PackageSpec> get_Projects();
    public JObject get_Json();
    public PackageSpec GetProjectSpec(string projectUniqueName);
    public IReadOnlyList`1<string> GetParents(string rootUniqueName);
    public DependencyGraphSpec WithProjectClosure(string projectUniqueName);
    public DependencyGraphSpec CreateFromClosure(string projectUniqueName, IReadOnlyList`1<PackageSpec> closure);
    public IReadOnlyList`1<PackageSpec> GetClosure(string rootUniqueName);
    private static IEnumerable`1<string> GetProjectReferenceNames(PackageSpec spec, Dictionary`2<string, PackageSpec> projectsByUniqueName);
    public void AddRestore(string projectUniqueName);
    public void AddProject(PackageSpec projectSpec);
    private PackageSpec ToPackageSpecWithCentralVersionInformation(PackageSpec spec);
    public static DependencyGraphSpec Union(IEnumerable`1<DependencyGraphSpec> dgSpecs);
    public static DependencyGraphSpec Load(string path);
    [ObsoleteAttribute("This method is obsolete and will be removed in a future release.")]
public static DependencyGraphSpec Load(JObject json);
    public void Save(string path);
    private void ParseJson(JObject json);
    private static JObject ReadJson(string packageSpecPath);
    public string GetHash();
    private void Write(IObjectWriter writer, Action`2<PackageSpec, IObjectWriter> writeAction);
    public static IReadOnlyList`1<PackageSpec> SortPackagesByDependencyOrder(IEnumerable`1<PackageSpec> packages);
    public DependencyGraphSpec WithoutRestores();
    public DependencyGraphSpec WithReplacedSpec(PackageSpec project);
    public DependencyGraphSpec WithoutTools();
    private static string GetPackageSpecId(PackageSpec spec);
    private static String[] GetPackageSpecDependencyIds(PackageSpec spec);
}
public class NuGet.ProjectModel.ExternalProjectReference : object {
    private PackageSpec _packageSpec;
    [CompilerGeneratedAttribute]
private string <UniqueName>k__BackingField;
    [CompilerGeneratedAttribute]
private IReadOnlyList`1<string> <ExternalProjectReferences>k__BackingField;
    [CompilerGeneratedAttribute]
private string <MSBuildProjectPath>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ProjectJsonPath>k__BackingField;
    [CompilerGeneratedAttribute]
private string <PackageSpecProjectName>k__BackingField;
    public string UniqueName { get; }
    public PackageSpec PackageSpec { get; }
    public IReadOnlyList`1<string> ExternalProjectReferences { get; }
    public string MSBuildProjectPath { get; }
    public string ProjectJsonPath { get; }
    public string PackageSpecProjectName { get; }
    public string ProjectName { get; }
    public ExternalProjectReference(string uniqueName, PackageSpec packageSpec, string msbuildProjectPath, IEnumerable`1<string> projectReferences);
    public ExternalProjectReference(string uniqueName, string packageSpecProjectName, string packageSpecPath, string msbuildProjectPath, IEnumerable`1<string> projectReferences);
    [CompilerGeneratedAttribute]
public string get_UniqueName();
    public PackageSpec get_PackageSpec();
    [CompilerGeneratedAttribute]
public IReadOnlyList`1<string> get_ExternalProjectReferences();
    [CompilerGeneratedAttribute]
public string get_MSBuildProjectPath();
    [CompilerGeneratedAttribute]
public string get_ProjectJsonPath();
    [CompilerGeneratedAttribute]
public string get_PackageSpecProjectName();
    public string get_ProjectName();
    public virtual string ToString();
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public sealed virtual bool Equals(ExternalProjectReference other);
    public sealed virtual int CompareTo(ExternalProjectReference other);
}
public class NuGet.ProjectModel.FileFormatException : Exception {
    [CompilerGeneratedAttribute]
private string <Path>k__BackingField;
    [CompilerGeneratedAttribute]
private int <Line>k__BackingField;
    [CompilerGeneratedAttribute]
private int <Column>k__BackingField;
    public string Path { get; private set; }
    public int Line { get; private set; }
    public int Column { get; private set; }
    public FileFormatException(string message);
    public FileFormatException(string message, Exception innerException);
    [CompilerGeneratedAttribute]
public string get_Path();
    [CompilerGeneratedAttribute]
private void set_Path(string value);
    [CompilerGeneratedAttribute]
public int get_Line();
    [CompilerGeneratedAttribute]
private void set_Line(int value);
    [CompilerGeneratedAttribute]
public int get_Column();
    [CompilerGeneratedAttribute]
private void set_Column(int value);
    private FileFormatException WithFilePath(string path);
    private FileFormatException WithLineInfo(JsonReaderException exception);
    private FileFormatException WithLineInfo(int line, int column);
    private FileFormatException WithLineInfo(IJsonLineInfo lineInfo);
    public static FileFormatException Create(Exception exception, JToken value, string path);
    internal static FileFormatException Create(Exception exception, int line, int column, string path);
    public static FileFormatException Create(string message, JToken value, string path);
    internal static FileFormatException Create(string message, int line, int column, string path);
    internal static FileFormatException Create(Exception exception, string path);
}
public class NuGet.ProjectModel.HashObjectWriter : object {
    private static int DefaultBufferSize;
    private Byte[] _buffer;
    private IHashFunction _hashFunc;
    private bool _isDisposed;
    private bool _isReadOnly;
    private int _nestLevel;
    private CircularMemoryStream _stream;
    private StreamWriter _streamWriter;
    private JsonTextWriter _writer;
    public HashObjectWriter(IHashFunction hashFunc);
    public sealed virtual void Dispose();
    public sealed virtual void WriteObjectStart();
    public sealed virtual void WriteObjectStart(string name);
    public sealed virtual void WriteObjectEnd();
    public sealed virtual void WriteNameValue(string name, int value);
    public sealed virtual void WriteNameValue(string name, bool value);
    public sealed virtual void WriteNameValue(string name, string value);
    public sealed virtual void WriteNameArray(string name, IEnumerable`1<string> values);
    public string GetHash();
    public sealed virtual void WriteArrayStart(string name);
    public sealed virtual void WriteArrayEnd();
    private void OnFlush(object sender, ArraySegment`1<byte> bytes);
    private void ThrowIfReadOnly();
    private void ThrowIfDisposed();
}
public interface NuGet.ProjectModel.IAssetsLogMessage {
    public LogLevel Level { get; }
    public NuGetLogCode Code { get; }
    public string Message { get; }
    public string ProjectPath { get; }
    public WarningLevel WarningLevel { get; }
    public string FilePath { get; }
    public int StartLineNumber { get; }
    public int StartColumnNumber { get; }
    public int EndLineNumber { get; }
    public int EndColumnNumber { get; }
    public string LibraryId { get; }
    public IReadOnlyList`1<string> TargetGraphs { get; }
    public abstract virtual LogLevel get_Level();
    public abstract virtual NuGetLogCode get_Code();
    public abstract virtual string get_Message();
    public abstract virtual string get_ProjectPath();
    public abstract virtual WarningLevel get_WarningLevel();
    public abstract virtual string get_FilePath();
    public abstract virtual int get_StartLineNumber();
    public abstract virtual int get_StartColumnNumber();
    public abstract virtual int get_EndLineNumber();
    public abstract virtual int get_EndColumnNumber();
    public abstract virtual string get_LibraryId();
    public abstract virtual IReadOnlyList`1<string> get_TargetGraphs();
}
public interface NuGet.ProjectModel.IExternalProjectReferenceProvider {
    public abstract virtual IReadOnlyList`1<ExternalProjectReference> GetReferences(string entryPointPath);
    public abstract virtual IReadOnlyList`1<ExternalProjectReference> GetEntryPoints();
}
public class NuGet.ProjectModel.IncludeExcludeFiles : object {
    [CompilerGeneratedAttribute]
private IReadOnlyList`1<string> <Include>k__BackingField;
    [CompilerGeneratedAttribute]
private IReadOnlyList`1<string> <Exclude>k__BackingField;
    [CompilerGeneratedAttribute]
private IReadOnlyList`1<string> <IncludeFiles>k__BackingField;
    [CompilerGeneratedAttribute]
private IReadOnlyList`1<string> <ExcludeFiles>k__BackingField;
    public IReadOnlyList`1<string> Include { get; public set; }
    public IReadOnlyList`1<string> Exclude { get; public set; }
    public IReadOnlyList`1<string> IncludeFiles { get; public set; }
    public IReadOnlyList`1<string> ExcludeFiles { get; public set; }
    [CompilerGeneratedAttribute]
public IReadOnlyList`1<string> get_Include();
    [CompilerGeneratedAttribute]
public void set_Include(IReadOnlyList`1<string> value);
    [CompilerGeneratedAttribute]
public IReadOnlyList`1<string> get_Exclude();
    [CompilerGeneratedAttribute]
public void set_Exclude(IReadOnlyList`1<string> value);
    [CompilerGeneratedAttribute]
public IReadOnlyList`1<string> get_IncludeFiles();
    [CompilerGeneratedAttribute]
public void set_IncludeFiles(IReadOnlyList`1<string> value);
    [CompilerGeneratedAttribute]
public IReadOnlyList`1<string> get_ExcludeFiles();
    [CompilerGeneratedAttribute]
public void set_ExcludeFiles(IReadOnlyList`1<string> value);
    public bool HandleIncludeExcludeFiles(JObject jsonObject);
    public virtual int GetHashCode();
    public virtual bool Equals(object obj);
    public sealed virtual bool Equals(IncludeExcludeFiles other);
    public IncludeExcludeFiles Clone();
    private static bool TryGetStringEnumerableFromJArray(JToken token, IReadOnlyList`1& result);
}
public class NuGet.ProjectModel.JsonPackageSpecReader : object {
    private static Char[] DelimitedStringSeparators;
    private static Char[] VersionSeparators;
    public static string RestoreOptions;
    public static string RestoreSettings;
    public static string HideWarningsAndErrors;
    public static string PackOptions;
    public static string PackageType;
    public static string Files;
    private static JsonPackageSpecReader();
    public static PackageSpec GetPackageSpec(string name, string packageSpecPath);
    public static PackageSpec GetPackageSpec(string json, string name, string packageSpecPath);
    [ObsoleteAttribute("This method is obsolete and will be removed in a future release.")]
public static PackageSpec GetPackageSpec(JObject json);
    public static PackageSpec GetPackageSpec(Stream stream, string name, string packageSpecPath, string snapshotValue);
    [ObsoleteAttribute("This method is obsolete and will be removed in a future release.")]
public static PackageSpec GetPackageSpec(JObject rawPackageSpec, string name, string packageSpecPath, string snapshotValue);
    internal static PackageSpec GetPackageSpec(JsonTextReader jsonReader, string packageSpecPath);
    private static PackageSpec GetPackageSpec(JsonTextReader jsonReader, string name, string packageSpecPath, string snapshotValue);
    private static PackageType CreatePackageType(JsonTextReader jsonReader);
    private static void ReadBuildOptions(JsonTextReader jsonReader, PackageSpec packageSpec);
    private static void ReadCentralPackageVersions(JsonTextReader jsonReader, IDictionary`2<string, CentralPackageVersion> centralPackageVersions, string filePath);
    private static CompatibilityProfile ReadCompatibilityProfile(JsonTextReader jsonReader, string profileName);
    [IteratorStateMachineAttribute("NuGet.ProjectModel.JsonPackageSpecReader/<ReadCompatibilitySets>d__19")]
private static IEnumerable`1<FrameworkRuntimePair> ReadCompatibilitySets(JsonTextReader jsonReader, string compatibilitySetName);
    internal static void ReadDependencies(JsonTextReader jsonReader, IList`1<LibraryDependency> results, string packageSpecPath, bool isGacOrFrameworkReference);
    private static void ReadDownloadDependencies(JsonTextReader jsonReader, IList`1<DownloadDependency> downloadDependencies, string packageSpecPath);
    private static IReadOnlyList`1<string> ReadEnumerableOfString(JsonTextReader jsonReader);
    private static void ReadFrameworkReferences(JsonTextReader jsonReader, ISet`1<FrameworkDependency> frameworkReferences, string packageSpecPath);
    private static void ReadFrameworks(JsonTextReader jsonReader, PackageSpec packageSpec);
    private static void ReadImports(PackageSpec packageSpec, JsonTextReader jsonReader, TargetFrameworkInformation targetFrameworkInformation);
    private static void ReadMappings(JsonTextReader jsonReader, string mappingKey, IDictionary`2<string, IncludeExcludeFiles> mappings);
    private static void ReadMSBuildMetadata(JsonTextReader jsonReader, PackageSpec packageSpec);
    private static bool ReadNextTokenAsBoolOrFalse(JsonTextReader jsonReader, string filePath);
    private static void ReadNuGetLogCodes(JsonTextReader jsonReader, HashSet`1<NuGetLogCode> hashCodes);
    private static List`1<NuGetLogCode> ReadNuGetLogCodesList(JsonTextReader jsonReader);
    private static void ReadPackageTypes(PackageSpec packageSpec, JsonTextReader jsonReader);
    private static void ReadPackInclude(JsonTextReader jsonReader, PackageSpec packageSpec);
    private static void ReadPackOptions(JsonTextReader jsonReader, PackageSpec packageSpec, Boolean& isMappingsNull);
    private static bool ReadPackOptionsFiles(PackageSpec packageSpec, JsonTextReader jsonReader, bool wasMappingsRead);
    private static void ReadRestoreSettings(JsonTextReader jsonReader, PackageSpec packageSpec);
    private static RuntimeDependencySet ReadRuntimeDependencySet(JsonTextReader jsonReader, string dependencySetName);
    private static RuntimeDescription ReadRuntimeDescription(JsonTextReader jsonReader, string runtimeName);
    private static List`1<RuntimeDescription> ReadRuntimes(JsonTextReader jsonReader);
    private static void ReadScripts(JsonTextReader jsonReader, PackageSpec packageSpec);
    private static String[] ReadStringArray(JsonTextReader jsonReader);
    private static List`1<CompatibilityProfile> ReadSupports(JsonTextReader jsonReader);
    private static LibraryDependencyTarget ReadTarget(JsonTextReader jsonReader, string packageSpecPath, LibraryDependencyTarget targetFlagsValue);
    private static List`1<ProjectRestoreMetadataFrameworkInfo> ReadTargetFrameworks(JsonTextReader jsonReader);
    private static void ReadTargetFrameworks(PackageSpec packageSpec, JsonTextReader jsonReader, Int32& frameworkLine, Int32& frameworkColumn);
    private static bool ValidateDependencyTarget(LibraryDependencyTarget targetValue);
}
[ExtensionAttribute]
internal static class NuGet.ProjectModel.JsonTextReaderExtensions : object {
    private static Char[] DelimitedStringDelimiters;
    private static JsonTextReaderExtensions();
    [ExtensionAttribute]
internal static IReadOnlyList`1<string> ReadDelimitedString(JsonTextReader reader);
    [ExtensionAttribute]
internal static bool ReadNextToken(JsonTextReader reader);
    [ExtensionAttribute]
internal static string ReadNextTokenAsString(JsonTextReader reader);
    [ExtensionAttribute]
internal static bool ReadObject(JsonTextReader reader, Action`1<string> onProperty);
    [ExtensionAttribute]
internal static bool ReadObject(JsonTextReader reader, Action`1<string> onProperty, Int32& startObjectLine, Int32& startObjectColumn);
    [ExtensionAttribute]
internal static void ReadProperties(JsonTextReader reader, Action`1<string> onProperty);
    [ExtensionAttribute]
internal static List`1<string> ReadStringArrayAsList(JsonTextReader reader);
    [ExtensionAttribute]
internal static IReadOnlyList`1<string> ReadStringOrArrayOfStringsAsReadOnlyList(JsonTextReader reader);
    [ExtensionAttribute]
internal static IReadOnlyList`1<string> ReadStringArrayAsReadOnlyListFromArrayStart(JsonTextReader reader);
    [ExtensionAttribute]
private static string ReadTokenAsString(JsonTextReader reader);
}
internal static class NuGet.ProjectModel.JsonUtility : object {
    internal static Char[] PathSplitChars;
    internal static JsonLoadSettings DefaultLoadSettings;
    private static JsonUtility();
    internal static JObject LoadJson(TextReader reader);
    internal static PackageDependency ReadPackageDependency(string property, JToken json);
    internal static JProperty WritePackageDependency(PackageDependency item);
    internal static TItem ReadProperty(JObject jObject, string propertyName);
    internal static IList`1<TItem> ReadObject(JObject jObject, Func`3<string, JToken, TItem> readItem);
    internal static JObject WriteObject(IEnumerable`1<TItem> items, Func`2<TItem, JProperty> writeItem);
    internal static int ReadInt(JToken cursor, string property, int defaultValue);
    internal static JToken WriteString(string item);
}
[ExtensionAttribute]
public static class NuGet.ProjectModel.JTokenExtensions : object {
    [ExtensionAttribute]
public static T[] ValueAsArray(JToken jToken);
    [ExtensionAttribute]
public static T[] ValueAsArray(JToken jToken, string name);
    [ExtensionAttribute]
public static T GetValue(JToken token, string name);
}
public class NuGet.ProjectModel.LockFile : object {
    public static NuGetFramework ToolFramework;
    public static char DirectorySeparatorChar;
    [CompilerGeneratedAttribute]
private int <Version>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Path>k__BackingField;
    [CompilerGeneratedAttribute]
private IList`1<ProjectFileDependencyGroup> <ProjectFileDependencyGroups>k__BackingField;
    [CompilerGeneratedAttribute]
private IList`1<LockFileLibrary> <Libraries>k__BackingField;
    [CompilerGeneratedAttribute]
private IList`1<LockFileTarget> <Targets>k__BackingField;
    [CompilerGeneratedAttribute]
private IList`1<LockFileItem> <PackageFolders>k__BackingField;
    [CompilerGeneratedAttribute]
private IList`1<IAssetsLogMessage> <LogMessages>k__BackingField;
    [CompilerGeneratedAttribute]
private PackageSpec <PackageSpec>k__BackingField;
    [CompilerGeneratedAttribute]
private IList`1<CentralTransitiveDependencyGroup> <CentralTransitiveDependencyGroups>k__BackingField;
    public int Version { get; public set; }
    public string Path { get; public set; }
    public IList`1<ProjectFileDependencyGroup> ProjectFileDependencyGroups { get; public set; }
    public IList`1<LockFileLibrary> Libraries { get; public set; }
    public IList`1<LockFileTarget> Targets { get; public set; }
    public IList`1<LockFileItem> PackageFolders { get; public set; }
    public IList`1<IAssetsLogMessage> LogMessages { get; public set; }
    public PackageSpec PackageSpec { get; public set; }
    public IList`1<CentralTransitiveDependencyGroup> CentralTransitiveDependencyGroups { get; public set; }
    private static LockFile();
    [CompilerGeneratedAttribute]
public int get_Version();
    [CompilerGeneratedAttribute]
public void set_Version(int value);
    [CompilerGeneratedAttribute]
public string get_Path();
    [CompilerGeneratedAttribute]
public void set_Path(string value);
    [CompilerGeneratedAttribute]
public IList`1<ProjectFileDependencyGroup> get_ProjectFileDependencyGroups();
    [CompilerGeneratedAttribute]
public void set_ProjectFileDependencyGroups(IList`1<ProjectFileDependencyGroup> value);
    [CompilerGeneratedAttribute]
public IList`1<LockFileLibrary> get_Libraries();
    [CompilerGeneratedAttribute]
public void set_Libraries(IList`1<LockFileLibrary> value);
    [CompilerGeneratedAttribute]
public IList`1<LockFileTarget> get_Targets();
    [CompilerGeneratedAttribute]
public void set_Targets(IList`1<LockFileTarget> value);
    [CompilerGeneratedAttribute]
public IList`1<LockFileItem> get_PackageFolders();
    [CompilerGeneratedAttribute]
public void set_PackageFolders(IList`1<LockFileItem> value);
    [CompilerGeneratedAttribute]
public IList`1<IAssetsLogMessage> get_LogMessages();
    [CompilerGeneratedAttribute]
public void set_LogMessages(IList`1<IAssetsLogMessage> value);
    [CompilerGeneratedAttribute]
public PackageSpec get_PackageSpec();
    [CompilerGeneratedAttribute]
public void set_PackageSpec(PackageSpec value);
    [CompilerGeneratedAttribute]
public IList`1<CentralTransitiveDependencyGroup> get_CentralTransitiveDependencyGroups();
    [CompilerGeneratedAttribute]
public void set_CentralTransitiveDependencyGroups(IList`1<CentralTransitiveDependencyGroup> value);
    public bool IsValidForPackageSpec(PackageSpec spec);
    public bool IsValidForPackageSpec(PackageSpec spec, int requestLockFileVersion);
    private bool ValidateDependencies(PackageSpec spec);
    public LockFileTarget GetTarget(NuGetFramework framework, string runtimeIdentifier);
    public LockFileLibrary GetLibrary(string name, NuGetVersion version);
    public sealed virtual bool Equals(LockFile other);
    private bool LogsEqual(IList`1<IAssetsLogMessage> otherLogMessages);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    private static void HashLockFileTargets(HashCodeCombiner combiner, IList`1<LockFileTarget> targets);
    private static void HashProjectFileDependencyGroups(HashCodeCombiner combiner, IList`1<ProjectFileDependencyGroup> groups);
    private static void HashCentralTransitiveDependencyGroups(HashCodeCombiner combiner, IList`1<CentralTransitiveDependencyGroup> groups);
    private static void HashLogMessages(HashCodeCombiner combiner, IList`1<IAssetsLogMessage> logMessages);
}
public class NuGet.ProjectModel.LockFileContentFile : LockFileItem {
    public static string BuildActionProperty;
    public static string CodeLanguageProperty;
    public static string PPOutputPathProperty;
    public static string OutputPathProperty;
    public static string CopyToOutputProperty;
    public string OutputPath { get; public set; }
    public string PPOutputPath { get; public set; }
    public BuildAction BuildAction { get; public set; }
    public string CodeLanguage { get; public set; }
    public bool CopyToOutput { get; public set; }
    public LockFileContentFile(string path);
    private static LockFileContentFile();
    public string get_OutputPath();
    public void set_OutputPath(string value);
    public string get_PPOutputPath();
    public void set_PPOutputPath(string value);
    public BuildAction get_BuildAction();
    public void set_BuildAction(BuildAction value);
    public string get_CodeLanguage();
    public void set_CodeLanguage(string value);
    public bool get_CopyToOutput();
    public void set_CopyToOutput(bool value);
}
public class NuGet.ProjectModel.LockFileDependency : object {
    [CompilerGeneratedAttribute]
private string <Id>k__BackingField;
    [CompilerGeneratedAttribute]
private NuGetVersion <ResolvedVersion>k__BackingField;
    [CompilerGeneratedAttribute]
private VersionRange <RequestedVersion>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ContentHash>k__BackingField;
    [CompilerGeneratedAttribute]
private PackageDependencyType <Type>k__BackingField;
    [CompilerGeneratedAttribute]
private IList`1<PackageDependency> <Dependencies>k__BackingField;
    public string Id { get; public set; }
    public NuGetVersion ResolvedVersion { get; public set; }
    public VersionRange RequestedVersion { get; public set; }
    public string ContentHash { get; public set; }
    public PackageDependencyType Type { get; public set; }
    public IList`1<PackageDependency> Dependencies { get; public set; }
    [CompilerGeneratedAttribute]
public string get_Id();
    [CompilerGeneratedAttribute]
public void set_Id(string value);
    [CompilerGeneratedAttribute]
public NuGetVersion get_ResolvedVersion();
    [CompilerGeneratedAttribute]
public void set_ResolvedVersion(NuGetVersion value);
    [CompilerGeneratedAttribute]
public VersionRange get_RequestedVersion();
    [CompilerGeneratedAttribute]
public void set_RequestedVersion(VersionRange value);
    [CompilerGeneratedAttribute]
public string get_ContentHash();
    [CompilerGeneratedAttribute]
public void set_ContentHash(string value);
    [CompilerGeneratedAttribute]
public PackageDependencyType get_Type();
    [CompilerGeneratedAttribute]
public void set_Type(PackageDependencyType value);
    [CompilerGeneratedAttribute]
public IList`1<PackageDependency> get_Dependencies();
    [CompilerGeneratedAttribute]
public void set_Dependencies(IList`1<PackageDependency> value);
    public sealed virtual bool Equals(LockFileDependency other);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
}
public class NuGet.ProjectModel.LockFileDependencyIdVersionComparer : object {
    [CompilerGeneratedAttribute]
private static LockFileDependencyIdVersionComparer <Default>k__BackingField;
    public static LockFileDependencyIdVersionComparer Default { get; }
    private static LockFileDependencyIdVersionComparer();
    [CompilerGeneratedAttribute]
public static LockFileDependencyIdVersionComparer get_Default();
    public sealed virtual bool Equals(LockFileDependency x, LockFileDependency y);
    public sealed virtual int GetHashCode(LockFileDependency obj);
}
public class NuGet.ProjectModel.LockFileDependencyProvider : object {
    private IDictionary`2<Tuple`2<NuGetFramework, string>, LockFileTargetLibrary> _targetLibraries;
    private IDictionary`2<Tuple`2<string, NuGetVersion>, LockFileLibrary> _libraries;
    public LockFileDependencyProvider(LockFile lockFile);
    public sealed virtual bool SupportsType(LibraryDependencyTarget libraryType);
    public sealed virtual Library GetLibrary(LibraryRange libraryRange, NuGetFramework targetFramework);
    private IList`1<LibraryDependency> GetDependencies(LockFileTargetLibrary library);
}
[ExtensionAttribute]
public static class NuGet.ProjectModel.LockFileExtensions : object {
    [ExtensionAttribute]
public static IEnumerable`1<LockFileTarget> GetTargetGraphs(IAssetsLogMessage message, LockFile assetsFile);
    [ExtensionAttribute]
public static IEnumerable`1<LockFileTargetLibrary> GetTargetLibraries(IAssetsLogMessage message, LockFile assetsFile);
    [ExtensionAttribute]
public static LockFileTargetLibrary GetTargetLibrary(LockFileTarget target, string libraryId);
}
public class NuGet.ProjectModel.LockFileFormat : object {
    public static int Version;
    public static string LockFileName;
    public static string AssetsFileName;
    private static string VersionProperty;
    private static string LibrariesProperty;
    private static string TargetsProperty;
    private static string ProjectFileDependencyGroupsProperty;
    private static string ServicableProperty;
    private static string Sha512Property;
    private static string FilesProperty;
    private static string HasToolsProperty;
    private static string DependenciesProperty;
    private static string FrameworkAssembliesProperty;
    private static string RuntimeProperty;
    private static string CompileProperty;
    private static string NativeProperty;
    private static string BuildProperty;
    private static string BuildMultiTargetingProperty;
    private static string ContentFilesProperty;
    private static string RuntimeTargetsProperty;
    private static string ResourceProperty;
    private static string TypeProperty;
    private static string PathProperty;
    private static string MSBuildProjectProperty;
    private static string FrameworkProperty;
    private static string ToolsProperty;
    private static string PackageFoldersProperty;
    private static string PackageSpecProperty;
    internal static string LogsProperty;
    private static string EmbedProperty;
    private static string FrameworkReferencesProperty;
    private static string CentralTransitiveDependencyGroupsProperty;
    private static LockFileFormat();
    public LockFile Parse(string lockFileContent, string path);
    public LockFile Parse(string lockFileContent, ILogger log, string path);
    public LockFile Read(string filePath);
    public LockFile Read(string filePath, ILogger log);
    public LockFile Read(Stream stream, string path);
    public LockFile Read(Stream stream, ILogger log, string path);
    public LockFile Read(TextReader reader, string path);
    public LockFile Read(TextReader reader, ILogger log, string path);
    public void Write(string filePath, LockFile lockFile);
    public void Write(Stream stream, LockFile lockFile);
    public void Write(TextWriter textWriter, LockFile lockFile);
    public string Render(LockFile lockFile);
    private static LockFile ReadLockFile(JObject cursor);
    private static JObject WriteLockFile(LockFile lockFile);
    private static LockFileLibrary ReadLibrary(string property, JToken json);
    private static JProperty WriteLibrary(LockFileLibrary library);
    private static JProperty WriteTarget(LockFileTarget target);
    private static LockFileTarget ReadTarget(string property, JToken json);
    private static JObject WriteLogMessage(IAssetsLogMessage logMessage, string projectPath);
    private static IAssetsLogMessage ReadLogMessage(JObject json, string projectPath);
    internal static JArray WriteLogMessages(IEnumerable`1<IAssetsLogMessage> logMessages, string projectPath);
    private static LockFileTargetLibrary ReadTargetLibrary(string property, JToken json);
    private static JProperty WriteTargetLibrary(LockFileTargetLibrary library);
    private static LockFileRuntimeTarget ReadRuntimeTarget(string property, JToken json);
    private static LockFileContentFile ReadContentFile(string property, JToken json);
    private static ProjectFileDependencyGroup ReadProjectFileDependencyGroup(string property, JToken json);
    private static PackageSpec ReadPackageSpec(JObject json);
    private static JProperty WriteProjectFileDependencyGroup(ProjectFileDependencyGroup frameworkInfo);
    private static LockFileItem ReadFileItem(string property, JToken json);
    private static T ReadFileItem(string property, JToken json, Func`2<string, T> factory);
    private static JProperty WriteFileItem(LockFileItem item);
    private static IList`1<TItem> ReadArray(JArray json, Func`2<JToken, TItem> readItem);
    internal static IList`1<IAssetsLogMessage> ReadLogMessageArray(JArray json, string projectPath);
    private static IList`1<string> ReadPathArray(JArray json, Func`2<JToken, string> readItem);
    private static void WriteArray(JToken json, string property, IEnumerable`1<TItem> items, Func`2<TItem, JToken> writeItem);
    private static void WritePathArray(JToken json, string property, IEnumerable`1<string> items, Func`2<string, JToken> writeItem);
    private static JArray WriteArray(IEnumerable`1<TItem> items, Func`2<TItem, JToken> writeItem);
    private static JArray WritePathArray(IEnumerable`1<string> items, Func`2<string, JToken> writeItem);
    private static void WriteObject(JToken json, string property, IEnumerable`1<TItem> items, Func`2<TItem, JProperty> writeItem);
    private static bool ReadBool(JToken cursor, string property, bool defaultValue);
    private static string ReadString(JToken json);
    private static SemanticVersion ReadSemanticVersion(JToken json, string property);
    private static void WriteBool(JToken token, string property, bool value);
    private static string GetPathWithForwardSlashes(string path);
    private static string GetPathWithBackSlashes(string path);
    private static JToken WriteCentralTransitiveDependencyGroup(IList`1<CentralTransitiveDependencyGroup> centralTransitiveDependencyGroups);
    private static List`1<CentralTransitiveDependencyGroup> ReadProjectFileTransitiveDependencyGroup(JObject json);
}
public class NuGet.ProjectModel.LockFileItem : object {
    public static string AliasesProperty;
    [CompilerGeneratedAttribute]
private string <Path>k__BackingField;
    [CompilerGeneratedAttribute]
private IDictionary`2<string, string> <Properties>k__BackingField;
    public string Path { get; }
    public IDictionary`2<string, string> Properties { get; }
    public LockFileItem(string path);
    private static LockFileItem();
    [CompilerGeneratedAttribute]
public string get_Path();
    [CompilerGeneratedAttribute]
public IDictionary`2<string, string> get_Properties();
    public virtual string ToString();
    public sealed virtual bool Equals(LockFileItem other);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public static LockFileItem op_Implicit(string path);
    protected string GetProperty(string name);
    protected void SetProperty(string name, string value);
}
public class NuGet.ProjectModel.LockFileLibrary : object {
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Type>k__BackingField;
    [CompilerGeneratedAttribute]
private NuGetVersion <Version>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsServiceable>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Sha512>k__BackingField;
    [CompilerGeneratedAttribute]
private IList`1<string> <Files>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Path>k__BackingField;
    [CompilerGeneratedAttribute]
private string <MSBuildProject>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <HasTools>k__BackingField;
    public string Name { get; public set; }
    public string Type { get; public set; }
    public NuGetVersion Version { get; public set; }
    public bool IsServiceable { get; public set; }
    public string Sha512 { get; public set; }
    public IList`1<string> Files { get; public set; }
    public string Path { get; public set; }
    public string MSBuildProject { get; public set; }
    public bool HasTools { get; public set; }
    [CompilerGeneratedAttribute]
public string get_Name();
    [CompilerGeneratedAttribute]
public void set_Name(string value);
    [CompilerGeneratedAttribute]
public string get_Type();
    [CompilerGeneratedAttribute]
public void set_Type(string value);
    [CompilerGeneratedAttribute]
public NuGetVersion get_Version();
    [CompilerGeneratedAttribute]
public void set_Version(NuGetVersion value);
    [CompilerGeneratedAttribute]
public bool get_IsServiceable();
    [CompilerGeneratedAttribute]
public void set_IsServiceable(bool value);
    [CompilerGeneratedAttribute]
public string get_Sha512();
    [CompilerGeneratedAttribute]
public void set_Sha512(string value);
    [CompilerGeneratedAttribute]
public IList`1<string> get_Files();
    [CompilerGeneratedAttribute]
public void set_Files(IList`1<string> value);
    [CompilerGeneratedAttribute]
public string get_Path();
    [CompilerGeneratedAttribute]
public void set_Path(string value);
    [CompilerGeneratedAttribute]
public string get_MSBuildProject();
    [CompilerGeneratedAttribute]
public void set_MSBuildProject(string value);
    [CompilerGeneratedAttribute]
public bool get_HasTools();
    [CompilerGeneratedAttribute]
public void set_HasTools(bool value);
    public sealed virtual bool Equals(LockFileLibrary other);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public LockFileLibrary Clone();
}
public class NuGet.ProjectModel.LockFileRuntimeTarget : LockFileItem {
    public static string RidProperty;
    public static string AssetTypeProperty;
    public string Runtime { get; public set; }
    public string AssetType { get; public set; }
    public LockFileRuntimeTarget(string path);
    public LockFileRuntimeTarget(string path, string runtime, string assetType);
    private static LockFileRuntimeTarget();
    public string get_Runtime();
    public void set_Runtime(string value);
    public string get_AssetType();
    public void set_AssetType(string value);
}
public class NuGet.ProjectModel.LockFileTarget : object {
    [CompilerGeneratedAttribute]
private NuGetFramework <TargetFramework>k__BackingField;
    [CompilerGeneratedAttribute]
private string <RuntimeIdentifier>k__BackingField;
    [CompilerGeneratedAttribute]
private IList`1<LockFileTargetLibrary> <Libraries>k__BackingField;
    public NuGetFramework TargetFramework { get; public set; }
    public string RuntimeIdentifier { get; public set; }
    public string Name { get; }
    public IList`1<LockFileTargetLibrary> Libraries { get; public set; }
    [CompilerGeneratedAttribute]
public NuGetFramework get_TargetFramework();
    [CompilerGeneratedAttribute]
public void set_TargetFramework(NuGetFramework value);
    [CompilerGeneratedAttribute]
public string get_RuntimeIdentifier();
    [CompilerGeneratedAttribute]
public void set_RuntimeIdentifier(string value);
    public string get_Name();
    [CompilerGeneratedAttribute]
public IList`1<LockFileTargetLibrary> get_Libraries();
    [CompilerGeneratedAttribute]
public void set_Libraries(IList`1<LockFileTargetLibrary> value);
    public sealed virtual bool Equals(LockFileTarget other);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
}
public class NuGet.ProjectModel.LockFileTargetLibrary : object {
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Framework>k__BackingField;
    [CompilerGeneratedAttribute]
private NuGetVersion <Version>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Type>k__BackingField;
    [CompilerGeneratedAttribute]
private IList`1<PackageDependency> <Dependencies>k__BackingField;
    [CompilerGeneratedAttribute]
private IList`1<string> <FrameworkAssemblies>k__BackingField;
    [CompilerGeneratedAttribute]
private IList`1<string> <FrameworkReferences>k__BackingField;
    [CompilerGeneratedAttribute]
private IList`1<LockFileItem> <RuntimeAssemblies>k__BackingField;
    [CompilerGeneratedAttribute]
private IList`1<LockFileItem> <ResourceAssemblies>k__BackingField;
    [CompilerGeneratedAttribute]
private IList`1<LockFileItem> <CompileTimeAssemblies>k__BackingField;
    [CompilerGeneratedAttribute]
private IList`1<LockFileItem> <NativeLibraries>k__BackingField;
    [CompilerGeneratedAttribute]
private IList`1<LockFileItem> <Build>k__BackingField;
    [CompilerGeneratedAttribute]
private IList`1<LockFileItem> <BuildMultiTargeting>k__BackingField;
    [CompilerGeneratedAttribute]
private IList`1<LockFileContentFile> <ContentFiles>k__BackingField;
    [CompilerGeneratedAttribute]
private IList`1<LockFileRuntimeTarget> <RuntimeTargets>k__BackingField;
    [CompilerGeneratedAttribute]
private IList`1<LockFileItem> <ToolsAssemblies>k__BackingField;
    [CompilerGeneratedAttribute]
private IList`1<LockFileItem> <EmbedAssemblies>k__BackingField;
    [CompilerGeneratedAttribute]
private IList`1<PackageType> <PackageType>k__BackingField;
    public string Name { get; public set; }
    public string Framework { get; public set; }
    public NuGetVersion Version { get; public set; }
    public string Type { get; public set; }
    public IList`1<PackageDependency> Dependencies { get; public set; }
    public IList`1<string> FrameworkAssemblies { get; public set; }
    public IList`1<string> FrameworkReferences { get; public set; }
    public IList`1<LockFileItem> RuntimeAssemblies { get; public set; }
    public IList`1<LockFileItem> ResourceAssemblies { get; public set; }
    public IList`1<LockFileItem> CompileTimeAssemblies { get; public set; }
    public IList`1<LockFileItem> NativeLibraries { get; public set; }
    public IList`1<LockFileItem> Build { get; public set; }
    public IList`1<LockFileItem> BuildMultiTargeting { get; public set; }
    public IList`1<LockFileContentFile> ContentFiles { get; public set; }
    public IList`1<LockFileRuntimeTarget> RuntimeTargets { get; public set; }
    public IList`1<LockFileItem> ToolsAssemblies { get; public set; }
    public IList`1<LockFileItem> EmbedAssemblies { get; public set; }
    public IList`1<PackageType> PackageType { get; public set; }
    [CompilerGeneratedAttribute]
public string get_Name();
    [CompilerGeneratedAttribute]
public void set_Name(string value);
    [CompilerGeneratedAttribute]
public string get_Framework();
    [CompilerGeneratedAttribute]
public void set_Framework(string value);
    [CompilerGeneratedAttribute]
public NuGetVersion get_Version();
    [CompilerGeneratedAttribute]
public void set_Version(NuGetVersion value);
    [CompilerGeneratedAttribute]
public string get_Type();
    [CompilerGeneratedAttribute]
public void set_Type(string value);
    [CompilerGeneratedAttribute]
public IList`1<PackageDependency> get_Dependencies();
    [CompilerGeneratedAttribute]
public void set_Dependencies(IList`1<PackageDependency> value);
    [CompilerGeneratedAttribute]
public IList`1<string> get_FrameworkAssemblies();
    [CompilerGeneratedAttribute]
public void set_FrameworkAssemblies(IList`1<string> value);
    [CompilerGeneratedAttribute]
public IList`1<string> get_FrameworkReferences();
    [CompilerGeneratedAttribute]
public void set_FrameworkReferences(IList`1<string> value);
    [CompilerGeneratedAttribute]
public IList`1<LockFileItem> get_RuntimeAssemblies();
    [CompilerGeneratedAttribute]
public void set_RuntimeAssemblies(IList`1<LockFileItem> value);
    [CompilerGeneratedAttribute]
public IList`1<LockFileItem> get_ResourceAssemblies();
    [CompilerGeneratedAttribute]
public void set_ResourceAssemblies(IList`1<LockFileItem> value);
    [CompilerGeneratedAttribute]
public IList`1<LockFileItem> get_CompileTimeAssemblies();
    [CompilerGeneratedAttribute]
public void set_CompileTimeAssemblies(IList`1<LockFileItem> value);
    [CompilerGeneratedAttribute]
public IList`1<LockFileItem> get_NativeLibraries();
    [CompilerGeneratedAttribute]
public void set_NativeLibraries(IList`1<LockFileItem> value);
    [CompilerGeneratedAttribute]
public IList`1<LockFileItem> get_Build();
    [CompilerGeneratedAttribute]
public void set_Build(IList`1<LockFileItem> value);
    [CompilerGeneratedAttribute]
public IList`1<LockFileItem> get_BuildMultiTargeting();
    [CompilerGeneratedAttribute]
public void set_BuildMultiTargeting(IList`1<LockFileItem> value);
    [CompilerGeneratedAttribute]
public IList`1<LockFileContentFile> get_ContentFiles();
    [CompilerGeneratedAttribute]
public void set_ContentFiles(IList`1<LockFileContentFile> value);
    [CompilerGeneratedAttribute]
public IList`1<LockFileRuntimeTarget> get_RuntimeTargets();
    [CompilerGeneratedAttribute]
public void set_RuntimeTargets(IList`1<LockFileRuntimeTarget> value);
    [CompilerGeneratedAttribute]
public IList`1<LockFileItem> get_ToolsAssemblies();
    [CompilerGeneratedAttribute]
public void set_ToolsAssemblies(IList`1<LockFileItem> value);
    [CompilerGeneratedAttribute]
public IList`1<LockFileItem> get_EmbedAssemblies();
    [CompilerGeneratedAttribute]
public void set_EmbedAssemblies(IList`1<LockFileItem> value);
    [CompilerGeneratedAttribute]
public IList`1<PackageType> get_PackageType();
    [CompilerGeneratedAttribute]
public void set_PackageType(IList`1<PackageType> value);
    public sealed virtual bool Equals(LockFileTargetLibrary other);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
}
public static class NuGet.ProjectModel.LockFileUtilities : object {
    public static LockFile GetLockFile(string lockFilePath, ILogger logger);
}
public enum NuGet.ProjectModel.PackageDependencyType : Enum {
    public int value__;
    public static PackageDependencyType Direct;
    public static PackageDependencyType Transitive;
    public static PackageDependencyType Project;
    public static PackageDependencyType CentralTransitive;
}
public class NuGet.ProjectModel.PackagesConfigProjectRestoreMetadata : ProjectRestoreMetadata {
    [CompilerGeneratedAttribute]
private string <PackagesConfigPath>k__BackingField;
    [CompilerGeneratedAttribute]
private string <RepositoryPath>k__BackingField;
    public string PackagesConfigPath { get; public set; }
    public string RepositoryPath { get; public set; }
    [CompilerGeneratedAttribute]
public string get_PackagesConfigPath();
    [CompilerGeneratedAttribute]
public void set_PackagesConfigPath(string value);
    [CompilerGeneratedAttribute]
public string get_RepositoryPath();
    [CompilerGeneratedAttribute]
public void set_RepositoryPath(string value);
    public virtual int GetHashCode();
    public virtual bool Equals(object obj);
    public bool Equals(PackagesConfigProjectRestoreMetadata obj);
    public virtual ProjectRestoreMetadata Clone();
}
public class NuGet.ProjectModel.PackagesLockFile : object {
    [CompilerGeneratedAttribute]
private int <Version>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Path>k__BackingField;
    [CompilerGeneratedAttribute]
private IList`1<PackagesLockFileTarget> <Targets>k__BackingField;
    public int Version { get; public set; }
    public string Path { get; public set; }
    public IList`1<PackagesLockFileTarget> Targets { get; public set; }
    public PackagesLockFile(int version);
    [CompilerGeneratedAttribute]
public int get_Version();
    [CompilerGeneratedAttribute]
public void set_Version(int value);
    [CompilerGeneratedAttribute]
public string get_Path();
    [CompilerGeneratedAttribute]
public void set_Path(string value);
    [CompilerGeneratedAttribute]
public IList`1<PackagesLockFileTarget> get_Targets();
    [CompilerGeneratedAttribute]
public void set_Targets(IList`1<PackagesLockFileTarget> value);
    public sealed virtual bool Equals(PackagesLockFile other);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
}
public class NuGet.ProjectModel.PackagesLockFileFormat : object {
    public static int Version;
    public static int PackagesLockFileVersion;
    public static string LockFileName;
    private static string VersionProperty;
    private static string ResolvedProperty;
    private static string RequestedProperty;
    private static string ContentHashProperty;
    private static string DependenciesProperty;
    private static string TypeProperty;
    private static PackagesLockFileFormat();
    public static PackagesLockFile Parse(string lockFileContent, string path);
    public static PackagesLockFile Parse(string lockFileContent, ILogger log, string path);
    public static PackagesLockFile Read(string filePath);
    public static PackagesLockFile Read(string filePath, ILogger log);
    public static PackagesLockFile Read(Stream stream, ILogger log, string path);
    public static PackagesLockFile Read(TextReader reader, ILogger log, string path);
    private static PackagesLockFile ReadLockFile(JObject cursor);
    public static string Render(PackagesLockFile lockFile);
    public static void Write(string filePath, PackagesLockFile lockFile);
    public static void Write(Stream stream, PackagesLockFile lockFile);
    public static void Write(TextWriter textWriter, PackagesLockFile lockFile);
    private static JObject WriteLockFile(PackagesLockFile lockFile);
    private static PackagesLockFileTarget ReadDependency(string property, JToken json);
    private static LockFileDependency ReadTargetDependency(string property, JToken json);
    private static JProperty WriteTarget(PackagesLockFileTarget target);
    private static JProperty WriteTargetDependency(LockFileDependency dependency);
}
public class NuGet.ProjectModel.PackagesLockFileTarget : object {
    [CompilerGeneratedAttribute]
private NuGetFramework <TargetFramework>k__BackingField;
    [CompilerGeneratedAttribute]
private string <RuntimeIdentifier>k__BackingField;
    [CompilerGeneratedAttribute]
private IList`1<LockFileDependency> <Dependencies>k__BackingField;
    public NuGetFramework TargetFramework { get; public set; }
    public string RuntimeIdentifier { get; public set; }
    public IList`1<LockFileDependency> Dependencies { get; public set; }
    public string Name { get; }
    [CompilerGeneratedAttribute]
public NuGetFramework get_TargetFramework();
    [CompilerGeneratedAttribute]
public void set_TargetFramework(NuGetFramework value);
    [CompilerGeneratedAttribute]
public string get_RuntimeIdentifier();
    [CompilerGeneratedAttribute]
public void set_RuntimeIdentifier(string value);
    [CompilerGeneratedAttribute]
public IList`1<LockFileDependency> get_Dependencies();
    [CompilerGeneratedAttribute]
public void set_Dependencies(IList`1<LockFileDependency> value);
    public string get_Name();
    public sealed virtual bool Equals(PackagesLockFileTarget other);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    private static string GetNameString(string framework, string runtime);
}
public static class NuGet.ProjectModel.PackagesLockFileUtilities : object {
    public static bool IsNuGetLockFileEnabled(PackageSpec project);
    public static string GetNuGetLockFilePath(PackageSpec project);
    public static string GetNuGetLockFilePath(string baseDirectory, string projectName);
    public static bool IsLockFileStillValid(DependencyGraphSpec dgSpec, PackagesLockFile nuGetLockFile);
    public static LockFileValidityWithMatchedResults IsLockFileStillValid(PackagesLockFile expected, PackagesLockFile actual);
    private static bool HasProjectDependencyChanged(IEnumerable`1<LibraryDependency> newDependencies, IEnumerable`1<LockFileDependency> lockFileDependencies);
    private static bool HasP2PDependencyChanged(IEnumerable`1<LibraryDependency> newDependencies, IEnumerable`1<ProjectRestoreReference> projectRestoreReferences, LockFileDependency projectDependency, DependencyGraphSpec dgSpec);
    private static bool HasProjectTransitiveDependencyChanged(IDictionary`2<string, CentralPackageVersion> centralPackageVersions, IList`1<LockFileDependency> lockFileCentralTransitiveDependencies, IList`1<LockFileDependency> lockTransitiveDependencies);
}
[DebuggerDisplayAttribute("{Name}")]
public class NuGet.ProjectModel.PackageSpec : object {
    public static string PackageSpecFileName;
    public static NuGetVersion DefaultVersion;
    [CompilerGeneratedAttribute]
private string <FilePath>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Title>k__BackingField;
    private NuGetVersion _version;
    [CompilerGeneratedAttribute]
private bool <IsDefaultVersion>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <HasVersionSnapshot>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Description>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Summary>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ReleaseNotes>k__BackingField;
    [CompilerGeneratedAttribute]
private String[] <Authors>k__BackingField;
    [CompilerGeneratedAttribute]
private String[] <Owners>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ProjectUrl>k__BackingField;
    [CompilerGeneratedAttribute]
private string <IconUrl>k__BackingField;
    [CompilerGeneratedAttribute]
private string <LicenseUrl>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <RequireLicenseAcceptance>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Copyright>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Language>k__BackingField;
    [CompilerGeneratedAttribute]
private BuildOptions <BuildOptions>k__BackingField;
    [CompilerGeneratedAttribute]
private String[] <Tags>k__BackingField;
    [CompilerGeneratedAttribute]
private IList`1<string> <ContentFiles>k__BackingField;
    [CompilerGeneratedAttribute]
private IList`1<LibraryDependency> <Dependencies>k__BackingField;
    [CompilerGeneratedAttribute]
private IDictionary`2<string, IEnumerable`1<string>> <Scripts>k__BackingField;
    [CompilerGeneratedAttribute]
private IDictionary`2<string, string> <PackInclude>k__BackingField;
    [CompilerGeneratedAttribute]
private PackOptions <PackOptions>k__BackingField;
    [CompilerGeneratedAttribute]
private IList`1<TargetFrameworkInformation> <TargetFrameworks>k__BackingField;
    [CompilerGeneratedAttribute]
private RuntimeGraph <RuntimeGraph>k__BackingField;
    [CompilerGeneratedAttribute]
private ProjectRestoreSettings <RestoreSettings>k__BackingField;
    [CompilerGeneratedAttribute]
private ProjectRestoreMetadata <RestoreMetadata>k__BackingField;
    public string FilePath { get; public set; }
    public string BaseDirectory { get; }
    public string Name { get; public set; }
    public string Title { get; public set; }
    public NuGetVersion Version { get; public set; }
    public bool IsDefaultVersion { get; public set; }
    public bool HasVersionSnapshot { get; public set; }
    public string Description { get; public set; }
    public string Summary { get; public set; }
    public string ReleaseNotes { get; public set; }
    public String[] Authors { get; public set; }
    public String[] Owners { get; public set; }
    public string ProjectUrl { get; public set; }
    public string IconUrl { get; public set; }
    public string LicenseUrl { get; public set; }
    public bool RequireLicenseAcceptance { get; public set; }
    public string Copyright { get; public set; }
    public string Language { get; public set; }
    public BuildOptions BuildOptions { get; public set; }
    public String[] Tags { get; public set; }
    public IList`1<string> ContentFiles { get; public set; }
    public IList`1<LibraryDependency> Dependencies { get; public set; }
    public IDictionary`2<string, IEnumerable`1<string>> Scripts { get; private set; }
    public IDictionary`2<string, string> PackInclude { get; private set; }
    public PackOptions PackOptions { get; public set; }
    public IList`1<TargetFrameworkInformation> TargetFrameworks { get; private set; }
    public RuntimeGraph RuntimeGraph { get; public set; }
    public ProjectRestoreSettings RestoreSettings { get; public set; }
    public ProjectRestoreMetadata RestoreMetadata { get; public set; }
    public PackageSpec(IList`1<TargetFrameworkInformation> frameworks);
    private static PackageSpec();
    [CompilerGeneratedAttribute]
public string get_FilePath();
    [CompilerGeneratedAttribute]
public void set_FilePath(string value);
    public string get_BaseDirectory();
    [CompilerGeneratedAttribute]
public string get_Name();
    [CompilerGeneratedAttribute]
public void set_Name(string value);
    [CompilerGeneratedAttribute]
public string get_Title();
    [CompilerGeneratedAttribute]
public void set_Title(string value);
    public NuGetVersion get_Version();
    public void set_Version(NuGetVersion value);
    [CompilerGeneratedAttribute]
public bool get_IsDefaultVersion();
    [CompilerGeneratedAttribute]
public void set_IsDefaultVersion(bool value);
    [CompilerGeneratedAttribute]
public bool get_HasVersionSnapshot();
    [CompilerGeneratedAttribute]
public void set_HasVersionSnapshot(bool value);
    [CompilerGeneratedAttribute]
public string get_Description();
    [CompilerGeneratedAttribute]
public void set_Description(string value);
    [CompilerGeneratedAttribute]
public string get_Summary();
    [CompilerGeneratedAttribute]
public void set_Summary(string value);
    [CompilerGeneratedAttribute]
public string get_ReleaseNotes();
    [CompilerGeneratedAttribute]
public void set_ReleaseNotes(string value);
    [CompilerGeneratedAttribute]
public String[] get_Authors();
    [CompilerGeneratedAttribute]
public void set_Authors(String[] value);
    [CompilerGeneratedAttribute]
public String[] get_Owners();
    [CompilerGeneratedAttribute]
public void set_Owners(String[] value);
    [CompilerGeneratedAttribute]
public string get_ProjectUrl();
    [CompilerGeneratedAttribute]
public void set_ProjectUrl(string value);
    [CompilerGeneratedAttribute]
public string get_IconUrl();
    [CompilerGeneratedAttribute]
public void set_IconUrl(string value);
    [CompilerGeneratedAttribute]
public string get_LicenseUrl();
    [CompilerGeneratedAttribute]
public void set_LicenseUrl(string value);
    [CompilerGeneratedAttribute]
public bool get_RequireLicenseAcceptance();
    [CompilerGeneratedAttribute]
public void set_RequireLicenseAcceptance(bool value);
    [CompilerGeneratedAttribute]
public string get_Copyright();
    [CompilerGeneratedAttribute]
public void set_Copyright(string value);
    [CompilerGeneratedAttribute]
public string get_Language();
    [CompilerGeneratedAttribute]
public void set_Language(string value);
    [CompilerGeneratedAttribute]
public BuildOptions get_BuildOptions();
    [CompilerGeneratedAttribute]
public void set_BuildOptions(BuildOptions value);
    [CompilerGeneratedAttribute]
public String[] get_Tags();
    [CompilerGeneratedAttribute]
public void set_Tags(String[] value);
    [CompilerGeneratedAttribute]
public IList`1<string> get_ContentFiles();
    [CompilerGeneratedAttribute]
public void set_ContentFiles(IList`1<string> value);
    [CompilerGeneratedAttribute]
public IList`1<LibraryDependency> get_Dependencies();
    [CompilerGeneratedAttribute]
public void set_Dependencies(IList`1<LibraryDependency> value);
    [CompilerGeneratedAttribute]
public IDictionary`2<string, IEnumerable`1<string>> get_Scripts();
    [CompilerGeneratedAttribute]
private void set_Scripts(IDictionary`2<string, IEnumerable`1<string>> value);
    [CompilerGeneratedAttribute]
public IDictionary`2<string, string> get_PackInclude();
    [CompilerGeneratedAttribute]
private void set_PackInclude(IDictionary`2<string, string> value);
    [CompilerGeneratedAttribute]
public PackOptions get_PackOptions();
    [CompilerGeneratedAttribute]
public void set_PackOptions(PackOptions value);
    [CompilerGeneratedAttribute]
public IList`1<TargetFrameworkInformation> get_TargetFrameworks();
    [CompilerGeneratedAttribute]
private void set_TargetFrameworks(IList`1<TargetFrameworkInformation> value);
    [CompilerGeneratedAttribute]
public RuntimeGraph get_RuntimeGraph();
    [CompilerGeneratedAttribute]
public void set_RuntimeGraph(RuntimeGraph value);
    [CompilerGeneratedAttribute]
public ProjectRestoreSettings get_RestoreSettings();
    [CompilerGeneratedAttribute]
public void set_RestoreSettings(ProjectRestoreSettings value);
    [CompilerGeneratedAttribute]
public ProjectRestoreMetadata get_RestoreMetadata();
    [CompilerGeneratedAttribute]
public void set_RestoreMetadata(ProjectRestoreMetadata value);
    public virtual int GetHashCode();
    public virtual bool Equals(object obj);
    public bool Equals(PackageSpec other);
    public PackageSpec Clone();
    private IDictionary`2<string, IEnumerable`1<string>> CloneScripts(IDictionary`2<string, IEnumerable`1<string>> toBeCloned);
}
[ExtensionAttribute]
public static class NuGet.ProjectModel.PackageSpecExtensions : object {
    [ExtensionAttribute]
public static TargetFrameworkInformation GetTargetFramework(PackageSpec project, NuGetFramework targetFramework);
    [ExtensionAttribute]
public static ProjectRestoreMetadataFrameworkInfo GetRestoreMetadataFramework(PackageSpec project, NuGetFramework targetFramework);
}
public static class NuGet.ProjectModel.PackageSpecOperations : object {
    public static void AddOrUpdateDependency(PackageSpec spec, PackageDependency dependency);
    public static void AddOrUpdateDependency(PackageSpec spec, PackageIdentity identity);
    public static bool HasPackage(PackageSpec spec, string packageId);
    public static void AddOrUpdateDependency(PackageSpec spec, PackageDependency dependency, IEnumerable`1<NuGetFramework> frameworksToAdd);
    public static void AddOrUpdateDependency(PackageSpec spec, PackageIdentity identity, IEnumerable`1<NuGetFramework> frameworksToAdd);
    public static void RemoveDependency(PackageSpec spec, string packageId);
    [IteratorStateMachineAttribute("NuGet.ProjectModel.PackageSpecOperations/<GetDependencyLists>d__6")]
private static IEnumerable`1<IList`1<LibraryDependency>> GetDependencyLists(PackageSpec spec, IEnumerable`1<NuGetFramework> frameworksToConsider, bool includeGenericDependencies);
    private static List`1<LibraryDependency> GetExistingDependencies(PackageSpec spec, string packageId);
    private static void AddOrUpdateDependencyInDependencyList(IList`1<LibraryDependency> list, string packageId, VersionRange range);
    private static void AddDependency(IList`1<LibraryDependency> list, string packageId, VersionRange range);
}
public class NuGet.ProjectModel.PackageSpecReferenceDependencyProvider : object {
    private Dictionary`2<string, ExternalProjectReference> _externalProjectsByPath;
    private Dictionary`2<string, ExternalProjectReference> _externalProjectsByUniqueName;
    private ILogger _logger;
    public PackageSpecReferenceDependencyProvider(IEnumerable`1<ExternalProjectReference> externalProjects, ILogger logger);
    public sealed virtual bool SupportsType(LibraryDependencyTarget libraryType);
    public sealed virtual Library GetLibrary(LibraryRange libraryRange, NuGetFramework targetFramework);
    private static void AddLibraryProperties(Library library, PackageSpec packageSpec, NuGetFramework targetFramework, string msbuildPath);
    private List`1<LibraryDependency> GetDependenciesFromSpecRestoreMetadata(PackageSpec packageSpec, NuGetFramework targetFramework);
    private List`1<LibraryDependency> GetDependenciesFromExternalReference(ExternalProjectReference externalReference, PackageSpec packageSpec, NuGetFramework targetFramework);
    internal static List`1<LibraryDependency> GetSpecDependencies(PackageSpec packageSpec, NuGetFramework targetFramework);
    [IteratorStateMachineAttribute("NuGet.ProjectModel.PackageSpecReferenceDependencyProvider/<GetProjectNames>d__10")]
private IEnumerable`1<string> GetProjectNames(IEnumerable`1<LibraryDependency> dependencies);
    private bool IsProject(LibraryDependency dependency);
    private List`1<ExternalProjectReference> GetChildReferences(ExternalProjectReference parent);
}
public static class NuGet.ProjectModel.PackageSpecUtility : object {
    public static NuGetVersion SpecifySnapshot(string version, string snapshotValue);
    public static bool IsSnapshotVersion(string version);
}
public class NuGet.ProjectModel.PackageSpecWriter : object {
    public static void Write(PackageSpec packageSpec, IObjectWriter writer);
    public static void WriteToFile(PackageSpec packageSpec, string filePath);
    private static bool IsMetadataValid(ProjectRestoreMetadata msbuildMetadata);
    private static void SetMSBuildMetadata(IObjectWriter writer, PackageSpec packageSpec);
    private static void WriteMetadataBooleans(IObjectWriter writer, ProjectRestoreMetadata msbuildMetadata);
    private static void WriteNuGetLockFileProperties(IObjectWriter writer, ProjectRestoreMetadata msbuildMetadata);
    private static void WriteMetadataTargetFrameworks(IObjectWriter writer, ProjectRestoreMetadata msbuildMetadata);
    private static void WriteMetadataFiles(IObjectWriter writer, ProjectRestoreMetadata msbuildMetadata);
    private static void WriteMetadataSources(IObjectWriter writer, ProjectRestoreMetadata msbuildMetadata);
    private static void SetWarningProperties(IObjectWriter writer, ProjectRestoreMetadata msbuildMetadata);
    private static void SetPackOptions(IObjectWriter writer, PackageSpec packageSpec);
    private static void SetDependencies(IObjectWriter writer, IList`1<LibraryDependency> libraryDependencies);
    internal static void SetDependencies(IObjectWriter writer, string name, IEnumerable`1<LibraryDependency> libraryDependencies);
    private static void SetImports(IObjectWriter writer, IList`1<NuGetFramework> frameworks);
    private static void SetDownloadDependencies(IObjectWriter writer, IList`1<DownloadDependency> downloadDependencies);
    private static void SetFrameworks(IObjectWriter writer, IList`1<TargetFrameworkInformation> frameworks);
    private static void SetFrameworkReferences(IObjectWriter writer, ISet`1<FrameworkDependency> frameworkReferences);
    private static void SetCentralDependencies(IObjectWriter writer, ICollection`1<CentralPackageVersion> centralPackageVersions);
    private static void SetValueIfTrue(IObjectWriter writer, string name, bool value);
    private static void SetValueIfNotNull(IObjectWriter writer, string name, string value);
    private static void SetValue(IObjectWriter writer, string name, string value);
    private static void SetArrayValue(IObjectWriter writer, string name, IEnumerable`1<string> values);
    private static void SetDictionaryValue(IObjectWriter writer, string name, IDictionary`2<string, string> values);
    private static void SetDictionaryValues(IObjectWriter writer, string name, IDictionary`2<string, IEnumerable`1<string>> values);
}
public class NuGet.ProjectModel.PackOptions : object {
    [CompilerGeneratedAttribute]
private IReadOnlyList`1<PackageType> <PackageType>k__BackingField;
    [CompilerGeneratedAttribute]
private IncludeExcludeFiles <IncludeExcludeFiles>k__BackingField;
    [CompilerGeneratedAttribute]
private IDictionary`2<string, IncludeExcludeFiles> <Mappings>k__BackingField;
    public IReadOnlyList`1<PackageType> PackageType { get; public set; }
    public IncludeExcludeFiles IncludeExcludeFiles { get; public set; }
    public IDictionary`2<string, IncludeExcludeFiles> Mappings { get; public set; }
    [CompilerGeneratedAttribute]
public IReadOnlyList`1<PackageType> get_PackageType();
    [CompilerGeneratedAttribute]
public void set_PackageType(IReadOnlyList`1<PackageType> value);
    [CompilerGeneratedAttribute]
public IncludeExcludeFiles get_IncludeExcludeFiles();
    [CompilerGeneratedAttribute]
public void set_IncludeExcludeFiles(IncludeExcludeFiles value);
    [CompilerGeneratedAttribute]
public IDictionary`2<string, IncludeExcludeFiles> get_Mappings();
    [CompilerGeneratedAttribute]
public void set_Mappings(IDictionary`2<string, IncludeExcludeFiles> value);
    public virtual int GetHashCode();
    public virtual bool Equals(object obj);
    public sealed virtual bool Equals(PackOptions other);
    public PackOptions Clone();
}
public class NuGet.ProjectModel.ProjectFileDependencyGroup : object {
    [CompilerGeneratedAttribute]
private string <FrameworkName>k__BackingField;
    [CompilerGeneratedAttribute]
private IEnumerable`1<string> <Dependencies>k__BackingField;
    public string FrameworkName { get; }
    public IEnumerable`1<string> Dependencies { get; }
    public ProjectFileDependencyGroup(string frameworkName, IEnumerable`1<string> dependencies);
    [CompilerGeneratedAttribute]
public string get_FrameworkName();
    [CompilerGeneratedAttribute]
public IEnumerable`1<string> get_Dependencies();
    public sealed virtual bool Equals(ProjectFileDependencyGroup other);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
}
public class NuGet.ProjectModel.ProjectLockFile.LockFileDependencyComparerWithoutContentHash : object {
    [CompilerGeneratedAttribute]
private static LockFileDependencyComparerWithoutContentHash <Default>k__BackingField;
    public static LockFileDependencyComparerWithoutContentHash Default { get; }
    private static LockFileDependencyComparerWithoutContentHash();
    [CompilerGeneratedAttribute]
public static LockFileDependencyComparerWithoutContentHash get_Default();
    public sealed virtual bool Equals(LockFileDependency x, LockFileDependency y);
    public sealed virtual int GetHashCode(LockFileDependency obj);
}
public class NuGet.ProjectModel.ProjectRestoreMetadata : object {
    [CompilerGeneratedAttribute]
private ProjectStyle <ProjectStyle>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ProjectPath>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ProjectJsonPath>k__BackingField;
    [CompilerGeneratedAttribute]
private string <OutputPath>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ProjectName>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ProjectUniqueName>k__BackingField;
    [CompilerGeneratedAttribute]
private IList`1<PackageSource> <Sources>k__BackingField;
    [CompilerGeneratedAttribute]
private string <PackagesPath>k__BackingField;
    [CompilerGeneratedAttribute]
private string <CacheFilePath>k__BackingField;
    [CompilerGeneratedAttribute]
private IList`1<string> <FallbackFolders>k__BackingField;
    [CompilerGeneratedAttribute]
private IList`1<string> <ConfigFilePaths>k__BackingField;
    [CompilerGeneratedAttribute]
private IList`1<ProjectRestoreMetadataFrameworkInfo> <TargetFrameworks>k__BackingField;
    [CompilerGeneratedAttribute]
private IList`1<string> <OriginalTargetFrameworks>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <CrossTargeting>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <LegacyPackagesDirectory>k__BackingField;
    [CompilerGeneratedAttribute]
private IList`1<ProjectRestoreMetadataFile> <Files>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <ValidateRuntimeAssets>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <SkipContentFileWrite>k__BackingField;
    [CompilerGeneratedAttribute]
private WarningProperties <ProjectWideWarningProperties>k__BackingField;
    [CompilerGeneratedAttribute]
private RestoreLockProperties <RestoreLockProperties>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <CentralPackageVersionsEnabled>k__BackingField;
    public ProjectStyle ProjectStyle { get; public set; }
    public string ProjectPath { get; public set; }
    public string ProjectJsonPath { get; public set; }
    public string OutputPath { get; public set; }
    public string ProjectName { get; public set; }
    public string ProjectUniqueName { get; public set; }
    public IList`1<PackageSource> Sources { get; public set; }
    public string PackagesPath { get; public set; }
    public string CacheFilePath { get; public set; }
    public IList`1<string> FallbackFolders { get; public set; }
    public IList`1<string> ConfigFilePaths { get; public set; }
    public IList`1<ProjectRestoreMetadataFrameworkInfo> TargetFrameworks { get; public set; }
    public IList`1<string> OriginalTargetFrameworks { get; public set; }
    public bool CrossTargeting { get; public set; }
    public bool LegacyPackagesDirectory { get; public set; }
    public IList`1<ProjectRestoreMetadataFile> Files { get; public set; }
    public bool ValidateRuntimeAssets { get; public set; }
    public bool SkipContentFileWrite { get; public set; }
    public WarningProperties ProjectWideWarningProperties { get; public set; }
    public RestoreLockProperties RestoreLockProperties { get; public set; }
    public bool CentralPackageVersionsEnabled { get; public set; }
    [CompilerGeneratedAttribute]
public ProjectStyle get_ProjectStyle();
    [CompilerGeneratedAttribute]
public void set_ProjectStyle(ProjectStyle value);
    [CompilerGeneratedAttribute]
public string get_ProjectPath();
    [CompilerGeneratedAttribute]
public void set_ProjectPath(string value);
    [CompilerGeneratedAttribute]
public string get_ProjectJsonPath();
    [CompilerGeneratedAttribute]
public void set_ProjectJsonPath(string value);
    [CompilerGeneratedAttribute]
public string get_OutputPath();
    [CompilerGeneratedAttribute]
public void set_OutputPath(string value);
    [CompilerGeneratedAttribute]
public string get_ProjectName();
    [CompilerGeneratedAttribute]
public void set_ProjectName(string value);
    [CompilerGeneratedAttribute]
public string get_ProjectUniqueName();
    [CompilerGeneratedAttribute]
public void set_ProjectUniqueName(string value);
    [CompilerGeneratedAttribute]
public IList`1<PackageSource> get_Sources();
    [CompilerGeneratedAttribute]
public void set_Sources(IList`1<PackageSource> value);
    [CompilerGeneratedAttribute]
public string get_PackagesPath();
    [CompilerGeneratedAttribute]
public void set_PackagesPath(string value);
    [CompilerGeneratedAttribute]
public string get_CacheFilePath();
    [CompilerGeneratedAttribute]
public void set_CacheFilePath(string value);
    [CompilerGeneratedAttribute]
public IList`1<string> get_FallbackFolders();
    [CompilerGeneratedAttribute]
public void set_FallbackFolders(IList`1<string> value);
    [CompilerGeneratedAttribute]
public IList`1<string> get_ConfigFilePaths();
    [CompilerGeneratedAttribute]
public void set_ConfigFilePaths(IList`1<string> value);
    [CompilerGeneratedAttribute]
public IList`1<ProjectRestoreMetadataFrameworkInfo> get_TargetFrameworks();
    [CompilerGeneratedAttribute]
public void set_TargetFrameworks(IList`1<ProjectRestoreMetadataFrameworkInfo> value);
    [CompilerGeneratedAttribute]
public IList`1<string> get_OriginalTargetFrameworks();
    [CompilerGeneratedAttribute]
public void set_OriginalTargetFrameworks(IList`1<string> value);
    [CompilerGeneratedAttribute]
public bool get_CrossTargeting();
    [CompilerGeneratedAttribute]
public void set_CrossTargeting(bool value);
    [CompilerGeneratedAttribute]
public bool get_LegacyPackagesDirectory();
    [CompilerGeneratedAttribute]
public void set_LegacyPackagesDirectory(bool value);
    [CompilerGeneratedAttribute]
public IList`1<ProjectRestoreMetadataFile> get_Files();
    [CompilerGeneratedAttribute]
public void set_Files(IList`1<ProjectRestoreMetadataFile> value);
    [CompilerGeneratedAttribute]
public bool get_ValidateRuntimeAssets();
    [CompilerGeneratedAttribute]
public void set_ValidateRuntimeAssets(bool value);
    [CompilerGeneratedAttribute]
public bool get_SkipContentFileWrite();
    [CompilerGeneratedAttribute]
public void set_SkipContentFileWrite(bool value);
    [CompilerGeneratedAttribute]
public WarningProperties get_ProjectWideWarningProperties();
    [CompilerGeneratedAttribute]
public void set_ProjectWideWarningProperties(WarningProperties value);
    [CompilerGeneratedAttribute]
public RestoreLockProperties get_RestoreLockProperties();
    [CompilerGeneratedAttribute]
public void set_RestoreLockProperties(RestoreLockProperties value);
    [CompilerGeneratedAttribute]
public bool get_CentralPackageVersionsEnabled();
    [CompilerGeneratedAttribute]
public void set_CentralPackageVersionsEnabled(bool value);
    public virtual int GetHashCode();
    public virtual bool Equals(object obj);
    public sealed virtual bool Equals(ProjectRestoreMetadata other);
    public virtual ProjectRestoreMetadata Clone();
    protected void FillClone(ProjectRestoreMetadata clone);
}
public class NuGet.ProjectModel.ProjectRestoreMetadataFile : object {
    [CompilerGeneratedAttribute]
private string <PackagePath>k__BackingField;
    [CompilerGeneratedAttribute]
private string <AbsolutePath>k__BackingField;
    public string PackagePath { get; }
    public string AbsolutePath { get; }
    public ProjectRestoreMetadataFile(string packagePath, string absolutePath);
    [CompilerGeneratedAttribute]
public string get_PackagePath();
    [CompilerGeneratedAttribute]
public string get_AbsolutePath();
    public sealed virtual bool Equals(ProjectRestoreMetadataFile other);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public virtual string ToString();
    public sealed virtual int CompareTo(ProjectRestoreMetadataFile other);
    public ProjectRestoreMetadataFile Clone();
}
public class NuGet.ProjectModel.ProjectRestoreMetadataFrameworkInfo : object {
    [CompilerGeneratedAttribute]
private NuGetFramework <FrameworkName>k__BackingField;
    [CompilerGeneratedAttribute]
private IList`1<ProjectRestoreReference> <ProjectReferences>k__BackingField;
    public NuGetFramework FrameworkName { get; public set; }
    public IList`1<ProjectRestoreReference> ProjectReferences { get; public set; }
    public ProjectRestoreMetadataFrameworkInfo(NuGetFramework frameworkName);
    [CompilerGeneratedAttribute]
public NuGetFramework get_FrameworkName();
    [CompilerGeneratedAttribute]
public void set_FrameworkName(NuGetFramework value);
    [CompilerGeneratedAttribute]
public IList`1<ProjectRestoreReference> get_ProjectReferences();
    [CompilerGeneratedAttribute]
public void set_ProjectReferences(IList`1<ProjectRestoreReference> value);
    public virtual string ToString();
    public virtual int GetHashCode();
    public virtual bool Equals(object obj);
    public sealed virtual bool Equals(ProjectRestoreMetadataFrameworkInfo other);
    public ProjectRestoreMetadataFrameworkInfo Clone();
}
public class NuGet.ProjectModel.ProjectRestoreReference : object {
    [CompilerGeneratedAttribute]
private string <ProjectUniqueName>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ProjectPath>k__BackingField;
    [CompilerGeneratedAttribute]
private LibraryIncludeFlags <IncludeAssets>k__BackingField;
    [CompilerGeneratedAttribute]
private LibraryIncludeFlags <ExcludeAssets>k__BackingField;
    [CompilerGeneratedAttribute]
private LibraryIncludeFlags <PrivateAssets>k__BackingField;
    public string ProjectUniqueName { get; public set; }
    public string ProjectPath { get; public set; }
    public LibraryIncludeFlags IncludeAssets { get; public set; }
    public LibraryIncludeFlags ExcludeAssets { get; public set; }
    public LibraryIncludeFlags PrivateAssets { get; public set; }
    [CompilerGeneratedAttribute]
public string get_ProjectUniqueName();
    [CompilerGeneratedAttribute]
public void set_ProjectUniqueName(string value);
    [CompilerGeneratedAttribute]
public string get_ProjectPath();
    [CompilerGeneratedAttribute]
public void set_ProjectPath(string value);
    [CompilerGeneratedAttribute]
public LibraryIncludeFlags get_IncludeAssets();
    [CompilerGeneratedAttribute]
public void set_IncludeAssets(LibraryIncludeFlags value);
    [CompilerGeneratedAttribute]
public LibraryIncludeFlags get_ExcludeAssets();
    [CompilerGeneratedAttribute]
public void set_ExcludeAssets(LibraryIncludeFlags value);
    [CompilerGeneratedAttribute]
public LibraryIncludeFlags get_PrivateAssets();
    [CompilerGeneratedAttribute]
public void set_PrivateAssets(LibraryIncludeFlags value);
    public virtual int GetHashCode();
    public virtual bool Equals(object obj);
    public virtual string ToString();
    public sealed virtual bool Equals(ProjectRestoreReference other);
    public ProjectRestoreReference Clone();
}
public class NuGet.ProjectModel.ProjectRestoreSettings : object {
    [CompilerGeneratedAttribute]
private bool <HideWarningsAndErrors>k__BackingField;
    public bool HideWarningsAndErrors { get; public set; }
    [CompilerGeneratedAttribute]
public bool get_HideWarningsAndErrors();
    [CompilerGeneratedAttribute]
public void set_HideWarningsAndErrors(bool value);
    public ProjectRestoreSettings Clone();
    public virtual bool Equals(object obj);
    public bool Equals(ProjectRestoreSettings other);
    public virtual int GetHashCode();
}
public enum NuGet.ProjectModel.ProjectStyle : Enum {
    public ushort value__;
    public static ProjectStyle Unknown;
    public static ProjectStyle ProjectJson;
    public static ProjectStyle PackageReference;
    public static ProjectStyle DotnetCliTool;
    public static ProjectStyle Standalone;
    public static ProjectStyle PackagesConfig;
    public static ProjectStyle DotnetToolReference;
}
public class NuGet.ProjectModel.RestoreLockProperties : object {
    [CompilerGeneratedAttribute]
private string <RestorePackagesWithLockFile>k__BackingField;
    [CompilerGeneratedAttribute]
private string <NuGetLockFilePath>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <RestoreLockedMode>k__BackingField;
    public string RestorePackagesWithLockFile { get; }
    public string NuGetLockFilePath { get; }
    public bool RestoreLockedMode { get; }
    public RestoreLockProperties(string restorePackagesWithLockFile, string nuGetLockFilePath, bool restoreLockedMode);
    [CompilerGeneratedAttribute]
public string get_RestorePackagesWithLockFile();
    [CompilerGeneratedAttribute]
public string get_NuGetLockFilePath();
    [CompilerGeneratedAttribute]
public bool get_RestoreLockedMode();
    public virtual int GetHashCode();
    public virtual bool Equals(object obj);
    public sealed virtual bool Equals(RestoreLockProperties other);
    public RestoreLockProperties Clone();
}
[GeneratedCodeAttribute("System.Resources.Tools.StronglyTypedResourceBuilder", "4.0.0.0")]
[DebuggerNonUserCodeAttribute]
[CompilerGeneratedAttribute]
internal class NuGet.ProjectModel.Strings : object {
    private static ResourceManager resourceMan;
    private static CultureInfo resourceCulture;
    [EditorBrowsableAttribute("2")]
internal static ResourceManager ResourceManager { get; }
    [EditorBrowsableAttribute("2")]
internal static CultureInfo Culture { get; internal set; }
    internal static string ArgumentNullOrEmpty { get; }
    internal static string InvalidDependencyTarget { get; }
    internal static string InvalidPackageType { get; }
    internal static string Log_ErrorReadingLockFile { get; }
    internal static string Log_ErrorReadingProjectJson { get; }
    internal static string Log_ErrorReadingProjectJsonWithLocation { get; }
    internal static string Log_InvalidImportFramework { get; }
    internal static string Log_ProblemReadingCacheFile { get; }
    internal static string MissingToolName { get; }
    internal static string MissingVersionOnDependency { get; }
    internal static string MissingVersionOnTool { get; }
    internal static ResourceManager get_ResourceManager();
    internal static CultureInfo get_Culture();
    internal static void set_Culture(CultureInfo value);
    internal static string get_ArgumentNullOrEmpty();
    internal static string get_InvalidDependencyTarget();
    internal static string get_InvalidPackageType();
    internal static string get_Log_ErrorReadingLockFile();
    internal static string get_Log_ErrorReadingProjectJson();
    internal static string get_Log_ErrorReadingProjectJsonWithLocation();
    internal static string get_Log_InvalidImportFramework();
    internal static string get_Log_ProblemReadingCacheFile();
    internal static string get_MissingToolName();
    internal static string get_MissingVersionOnDependency();
    internal static string get_MissingVersionOnTool();
}
public class NuGet.ProjectModel.TargetFrameworkInformation : object {
    [CompilerGeneratedAttribute]
private NuGetFramework <FrameworkName>k__BackingField;
    [CompilerGeneratedAttribute]
private IList`1<LibraryDependency> <Dependencies>k__BackingField;
    [CompilerGeneratedAttribute]
private IList`1<NuGetFramework> <Imports>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <AssetTargetFallback>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <Warn>k__BackingField;
    [CompilerGeneratedAttribute]
private IList`1<DownloadDependency> <DownloadDependencies>k__BackingField;
    [CompilerGeneratedAttribute]
private IDictionary`2<string, CentralPackageVersion> <CentralPackageVersions>k__BackingField;
    [CompilerGeneratedAttribute]
private ISet`1<FrameworkDependency> <FrameworkReferences>k__BackingField;
    [CompilerGeneratedAttribute]
private string <RuntimeIdentifierGraphPath>k__BackingField;
    public NuGetFramework FrameworkName { get; public set; }
    public IList`1<LibraryDependency> Dependencies { get; public set; }
    public IList`1<NuGetFramework> Imports { get; public set; }
    public bool AssetTargetFallback { get; public set; }
    public bool Warn { get; public set; }
    public IList`1<DownloadDependency> DownloadDependencies { get; }
    public IDictionary`2<string, CentralPackageVersion> CentralPackageVersions { get; }
    public ISet`1<FrameworkDependency> FrameworkReferences { get; }
    public string RuntimeIdentifierGraphPath { get; public set; }
    [CompilerGeneratedAttribute]
public NuGetFramework get_FrameworkName();
    [CompilerGeneratedAttribute]
public void set_FrameworkName(NuGetFramework value);
    [CompilerGeneratedAttribute]
public IList`1<LibraryDependency> get_Dependencies();
    [CompilerGeneratedAttribute]
public void set_Dependencies(IList`1<LibraryDependency> value);
    [CompilerGeneratedAttribute]
public IList`1<NuGetFramework> get_Imports();
    [CompilerGeneratedAttribute]
public void set_Imports(IList`1<NuGetFramework> value);
    [CompilerGeneratedAttribute]
public bool get_AssetTargetFallback();
    [CompilerGeneratedAttribute]
public void set_AssetTargetFallback(bool value);
    [CompilerGeneratedAttribute]
public bool get_Warn();
    [CompilerGeneratedAttribute]
public void set_Warn(bool value);
    [CompilerGeneratedAttribute]
public IList`1<DownloadDependency> get_DownloadDependencies();
    [CompilerGeneratedAttribute]
public IDictionary`2<string, CentralPackageVersion> get_CentralPackageVersions();
    [CompilerGeneratedAttribute]
public ISet`1<FrameworkDependency> get_FrameworkReferences();
    [CompilerGeneratedAttribute]
public string get_RuntimeIdentifierGraphPath();
    [CompilerGeneratedAttribute]
public void set_RuntimeIdentifierGraphPath(string value);
    public virtual string ToString();
    public virtual int GetHashCode();
    public virtual bool Equals(object obj);
    public sealed virtual bool Equals(TargetFrameworkInformation other);
    public TargetFrameworkInformation Clone();
}
public class NuGet.ProjectModel.ToolPathResolver : object {
    private string _packagesDirectory;
    private bool _isLowercase;
    public ToolPathResolver(string packagesDirectory);
    public ToolPathResolver(string packagesDirectory, bool isLowercase);
    public string GetLockFilePath(string toolDirectory);
    public string GetLockFilePath(string packageId, NuGetVersion version, NuGetFramework framework);
    public string GetToolDirectoryPath(string packageId, NuGetVersion version, NuGetFramework framework);
    private string GetPackagesToolsBasePath();
    public string GetBestToolDirectoryPath(string packageId, VersionRange versionRange, NuGetFramework framework);
    private IEnumerable`1<NuGetVersion> GetAvailableToolVersions(string packageId);
}
public class NuGet.ProjectModel.WarningProperties : object {
    [CompilerGeneratedAttribute]
private ISet`1<NuGetLogCode> <WarningsAsErrors>k__BackingField;
    [CompilerGeneratedAttribute]
private ISet`1<NuGetLogCode> <NoWarn>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <AllWarningsAsErrors>k__BackingField;
    public ISet`1<NuGetLogCode> WarningsAsErrors { get; }
    public ISet`1<NuGetLogCode> NoWarn { get; }
    public bool AllWarningsAsErrors { get; public set; }
    public WarningProperties(ISet`1<NuGetLogCode> warningsAsErrors, ISet`1<NuGetLogCode> noWarn, bool allWarningsAsErrors);
    [CompilerGeneratedAttribute]
public ISet`1<NuGetLogCode> get_WarningsAsErrors();
    [CompilerGeneratedAttribute]
public ISet`1<NuGetLogCode> get_NoWarn();
    [CompilerGeneratedAttribute]
public bool get_AllWarningsAsErrors();
    [CompilerGeneratedAttribute]
public void set_AllWarningsAsErrors(bool value);
    public virtual int GetHashCode();
    public virtual bool Equals(object obj);
    public sealed virtual bool Equals(WarningProperties other);
    public WarningProperties Clone();
    public static WarningProperties GetWarningProperties(string treatWarningsAsErrors, string warningsAsErrors, string noWarn);
    public static WarningProperties GetWarningProperties(string treatWarningsAsErrors, IEnumerable`1<NuGetLogCode> warningsAsErrors, IEnumerable`1<NuGetLogCode> noWarn);
}
[ExtensionAttribute]
internal static class NuGet.Shared.EqualityUtility : object {
    [ExtensionAttribute]
internal static bool OrderedEquals(IEnumerable`1<TSource> self, IEnumerable`1<TSource> other, Func`2<TSource, TKey> keySelector, IComparer`1<TKey> orderComparer, IEqualityComparer`1<TSource> sequenceComparer);
    [ExtensionAttribute]
internal static bool SequenceEqualWithNullCheck(IEnumerable`1<T> self, IEnumerable`1<T> other, IEqualityComparer`1<T> comparer);
    [ExtensionAttribute]
internal static bool SetEqualsWithNullCheck(ISet`1<T> self, ISet`1<T> other, IEqualityComparer`1<T> comparer);
    internal static bool DictionaryEquals(IDictionary`2<TKey, TValue> self, IDictionary`2<TKey, TValue> other, Func`3<TValue, TValue, bool> compareValues);
    internal static bool DictionaryOfSequenceEquals(IDictionary`2<TKey, IEnumerable`1<TValue>> self, IDictionary`2<TKey, IEnumerable`1<TValue>> other);
    internal static bool EqualsWithNullCheck(T self, T other);
    private static bool TryIdentityEquals(T self, T other, Boolean& equals);
}
[ExtensionAttribute]
internal static class NuGet.Shared.Extensions : object {
    [ExtensionAttribute]
public static List`1<T> AsList(IEnumerable`1<T> enumerable);
    [ExtensionAttribute]
public static HashSet`1<T> AsHashSet(ISet`1<T> enumerable, IEqualityComparer`1<T> comparer);
    [ExtensionAttribute]
public static void ForEach(IEnumerable`1<T> enumeration, Action`1<T> action);
}
internal class NuGet.Shared.HashCodeCombiner : ValueType {
    private static long Seed;
    private bool _initialized;
    private long _combinedHash;
    internal int CombinedHash { get; }
    internal int get_CombinedHash();
    private void AddHashCode(int i);
    internal void AddObject(int i);
    internal void AddObject(TValue o, IEqualityComparer`1<TValue> comparer);
    internal void AddObject(T o);
    internal void AddStringIgnoreCase(string s);
    internal void AddSequence(IEnumerable`1<T> sequence);
    internal void AddSequence(T[] array);
    internal void AddSequence(IList`1<T> list);
    internal void AddSequence(IReadOnlyList`1<T> list);
    internal void AddDictionary(IEnumerable`1<KeyValuePair`2<TKey, TValue>> dictionary);
    internal static int GetHashCode(T1 o1, T2 o2);
    internal static int GetHashCode(T1 o1, T2 o2, T3 o3);
    private void CheckInitialized();
}
