public class com.itextpdf.text.pdf.languages.DevanagariLigaturizer : IndicLigaturizer {
    public static char DEVA_MATRA_AA;
    public static char DEVA_MATRA_I;
    public static char DEVA_MATRA_E;
    public static char DEVA_MATRA_AI;
    public static char DEVA_MATRA_HLR;
    public static char DEVA_MATRA_HLRR;
    public static char DEVA_LETTER_A;
    public static char DEVA_LETTER_AU;
    public static char DEVA_LETTER_KA;
    public static char DEVA_LETTER_HA;
    public static char DEVA_HALANTA;
}
public class com.itextpdf.text.pdf.ListBody : object {
    protected PdfName role;
    protected AccessibleElementId id;
    protected Dictionary`2<PdfName, PdfObject> accessibleAttributes;
    protected internal ListItem parentItem;
    protected internal float indentation;
    public PdfName Role { get; public set; }
    public AccessibleElementId ID { get; public set; }
    public bool IsInline { get; }
    protected internal ListBody(ListItem parentItem);
    public ListBody(ListItem parentItem, float indentation);
    public virtual PdfObject GetAccessibleAttribute(PdfName key);
    public virtual void SetAccessibleAttribute(PdfName key, PdfObject value);
    public virtual Dictionary`2<PdfName, PdfObject> GetAccessibleAttributes();
    public virtual PdfName get_Role();
    public virtual void set_Role(PdfName value);
    public virtual AccessibleElementId get_ID();
    public virtual void set_ID(AccessibleElementId value);
    public virtual bool get_IsInline();
}
public class com.itextpdf.text.pdf.ListLabel : ListBody {
    public PdfName Role { get; public set; }
    public float Indentation { get; public set; }
    [ObsoleteAttribute]
public bool TagLabelContent { get; public set; }
    public bool IsInline { get; }
    protected internal ListLabel(ListItem parentItem);
    public virtual PdfObject GetAccessibleProperty(PdfName key);
    public virtual void SetAccessibleProperty(PdfName key, PdfObject value);
    public virtual Dictionary`2<PdfName, PdfObject> GetAccessibleProperties();
    public virtual PdfName get_Role();
    public virtual void set_Role(PdfName value);
    public virtual float get_Indentation();
    public virtual void set_Indentation(float value);
    public virtual bool get_TagLabelContent();
    public virtual void set_TagLabelContent(bool value);
    public virtual bool get_IsInline();
}
public class com.itextpdf.text.pdf.security.ExternalBlankSignatureContainer : object {
    private PdfDictionary sigDic;
    public ExternalBlankSignatureContainer(PdfDictionary sigDic);
    public ExternalBlankSignatureContainer(PdfName filter, PdfName subFilter);
    public virtual Byte[] Sign(Stream data);
    public virtual void ModifySigningDictionary(PdfDictionary signDic);
}
public class iTextSharp.awt.geom.AffineTransform : object {
    public static int TYPE_IDENTITY;
    public static int TYPE_TRANSLATION;
    public static int TYPE_UNIFORM_SCALE;
    public static int TYPE_GENERAL_SCALE;
    public static int TYPE_QUADRANT_ROTATION;
    public static int TYPE_GENERAL_ROTATION;
    public static int TYPE_GENERAL_TRANSFORM;
    public static int TYPE_FLIP;
    public static int TYPE_MASK_SCALE;
    public static int TYPE_MASK_ROTATION;
    private static int TYPE_UNKNOWN;
    private static double ZERO;
    private double m00;
    private double m10;
    private double m01;
    private double m11;
    private double m02;
    private double m12;
    private int type;
    public int Type { get; }
    public AffineTransform(AffineTransform t);
    public AffineTransform(float m00, float m10, float m01, float m11, float m02, float m12);
    public AffineTransform(double m00, double m10, double m01, double m11, double m02, double m12);
    public AffineTransform(Single[] matrix);
    public AffineTransform(Double[] matrix);
    public virtual int get_Type();
    public virtual double GetScaleX();
    public virtual double GetScaleY();
    public virtual double GetShearX();
    public virtual double GetShearY();
    public virtual double GetTranslateX();
    public virtual double GetTranslateY();
    public virtual bool IsIdentity();
    public virtual void GetMatrix(Double[] matrix);
    public virtual double GetDeterminant();
    public virtual void SetTransform(double m00, double m10, double m01, double m11, double m02, double m12);
    public virtual void SetTransform(AffineTransform t);
    public virtual void SetToIdentity();
    public virtual void SetToTranslation(double mx, double my);
    public virtual void SetToScale(double scx, double scy);
    public virtual void SetToShear(double shx, double shy);
    public virtual void SetToRotation(double angle);
    public virtual void SetToRotation(double angle, double px, double py);
    public static AffineTransform GetTranslateInstance(double mx, double my);
    public static AffineTransform GetScaleInstance(double scx, double scY);
    public static AffineTransform GetShearInstance(double shx, double shy);
    public static AffineTransform GetRotateInstance(double angle);
    public static AffineTransform GetRotateInstance(double angle, double x, double y);
    public virtual void Translate(double mx, double my);
    public virtual void Scale(double scx, double scy);
    public virtual void Shear(double shx, double shy);
    public virtual void Rotate(double angle);
    public virtual void Rotate(double angle, double px, double py);
    private AffineTransform Multiply(AffineTransform t1, AffineTransform t2);
    public virtual void Concatenate(AffineTransform t);
    public virtual void preConcatenate(AffineTransform t);
    public virtual AffineTransform CreateInverse();
    public virtual Point2D Transform(Point2D src, Point2D dst);
    public virtual void Transform(Point2D[] src, int srcOff, Point2D[] dst, int dstOff, int length);
    public virtual void Transform(Double[] src, int srcOff, Double[] dst, int dstOff, int length);
    public virtual void Transform(Single[] src, int srcOff, Single[] dst, int dstOff, int length);
    public virtual void Transform(Single[] src, int srcOff, Double[] dst, int dstOff, int length);
    public virtual void Transform(Double[] src, int srcOff, Single[] dst, int dstOff, int length);
    public virtual Point2D DeltaTransform(Point2D src, Point2D dst);
    public virtual void DeltaTransform(Double[] src, int srcOff, Double[] dst, int dstOff, int length);
    public virtual Point2D InverseTransform(Point2D src, Point2D dst);
    public virtual void InverseTransform(Double[] src, int srcOff, Double[] dst, int dstOff, int length);
    public virtual void InverseTransform(Single[] src, int srcOff, Single[] dst, int dstOff, int length);
    public virtual object Clone();
    public virtual string ToString();
}
public class iTextSharp.awt.geom.Point : Point2D {
    public double x;
    public double y;
    public Point(int x, int y);
    public Point(double x, double y);
    public Point(Point p);
    public virtual bool Equals(object obj);
    public virtual string ToString();
    public virtual double GetX();
    public virtual double GetY();
    public virtual Point GetLocation();
    public virtual void SetLocation(Point p);
    public virtual void SetLocation(int x, int y);
    public virtual void SetLocation(double x, double y);
    public virtual void Move(int x, int y);
    public virtual void Move(double x, double y);
    public virtual void Translate(int dx, int dy);
    public virtual void Translate(double dx, double dy);
}
public abstract class iTextSharp.awt.geom.Point2D : object {
    public abstract virtual double GetX();
    public abstract virtual double GetY();
    public abstract virtual void SetLocation(double x, double y);
    public virtual void SetLocation(Point2D p);
    public static double DistanceSq(double x1, double y1, double x2, double y2);
    public virtual double DistanceSq(double px, double py);
    public virtual double DistanceSq(Point2D p);
    public static double Distance(double x1, double y1, double x2, double y2);
    public virtual double Distance(double px, double py);
    public virtual double Distance(Point2D p);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
}
public class iTextSharp.testutils.CompareTool : object {
    private static string gsParams;
    private static string compareParams;
    private static string cannotOpenTarGetDirectory;
    private static string gsFailed;
    private static string unexpectedNumberOfPages;
    private static string differentPages;
    private static string undefinedGsPath;
    private static string ignoredAreasPrefix;
    private string gsExec;
    private string compareExec;
    private string cmpPdf;
    private string cmpPdfName;
    private string cmpImage;
    private string outPdf;
    private string outPdfName;
    private string outImage;
    private IList`1<PdfDictionary> outPages;
    private IList`1<RefKey> outPagesRef;
    private IList`1<PdfDictionary> cmpPages;
    private IList`1<RefKey> cmpPagesRef;
    private int compareByContentErrorsLimit;
    private bool generateCompareByContentXmlReport;
    private string xmlReportName;
    private double floatComparisonError;
    private bool absoluteError;
    private string Compare(string outPath, string differenceImagePrefix, IDictionary`2<int, IList`1<Rectangle>> ignoredAreas);
    private string Compare(string outPath, string differenceImagePrefix, IDictionary`2<int, IList`1<Rectangle>> ignoredAreas, IList`1<int> equalPages);
    public virtual string Compare(string outPdf, string cmpPdf, string outPath, string differenceImagePrefix, IDictionary`2<int, IList`1<Rectangle>> ignoredAreas);
    public virtual string Compare(string outPdf, string cmpPdf, string outPath, string differenceImagePrefix);
    public virtual CompareTool SetCompareByContentErrorsLimit(int compareByContentMaxErrorCount);
    public virtual void SetGenerateCompareByContentXmlReport(bool generateCompareByContentXmlReport);
    public CompareTool SetFloatAbsoluteError(float error);
    public CompareTool SetFloatRelativeError(float error);
    public void SetXmlReportName(string reportName);
    public string GetXmlReportName();
    private string CompareByContent(string outPath, string differenceImagePrefix, IDictionary`2<int, IList`1<Rectangle>> ignoredAreas);
    public virtual string CompareByContent(string outPdf, string cmpPdf, string outPath, string differenceImagePrefix, IDictionary`2<int, IList`1<Rectangle>> ignoredAreas);
    public virtual string CompareByContent(string outPdf, string cmpPdf, string outPath, string differenceImagePrefix);
    private void LoadPagesFromReader(PdfReader reader, IList`1<PdfDictionary> pages, IList`1<RefKey> pagesRef);
    private void AddPagesFromDict(PdfObject dictRef, IList`1<PdfDictionary> pages, IList`1<RefKey> pagesRef);
    private bool CompareObjects(PdfObject outObj, PdfObject cmpObj, ObjectPath currentPath, CompareResult compareResult);
    public bool CompareDictionaries(PdfDictionary outDict, PdfDictionary cmpDict);
    private bool CompareDictionariesExtended(PdfDictionary outDict, PdfDictionary cmpDict, ObjectPath currentPath, CompareResult compareResult);
    public bool CompareContentStreamsByParsing(PdfObject outObj, PdfObject cmpObj);
    public bool CompareContentStreamsByParsing(PdfObject outObj, PdfObject cmpObj, PdfDictionary outResources, PdfDictionary cmpResources);
    private bool CompareContentStreamsByParsingExtended(PdfObject outObj, PdfObject cmpObj, PdfDictionary outResources, PdfDictionary cmpResources, ObjectPath currentPath, CompareResult compareResult);
    private bool CompareInlineImagesExtended(PdfContentParser outPs, PdfContentParser cmpPs, PdfDictionary outDict, PdfDictionary cmpDict, ObjectPath currentPath, CompareResult compareResult);
    public bool CompareStreams(PRStream outStream, PRStream cmpStream);
    private bool CompareStreamsExtended(PRStream outStream, PRStream cmpStream, ObjectPath currentPath, CompareResult compareResult);
    public bool CompareArrays(PdfArray outArray, PdfArray cmpArray);
    private bool CompareArraysExtended(PdfArray outArray, PdfArray cmpArray, ObjectPath currentPath, CompareResult compareResult);
    public bool CompareNames(PdfName outName, PdfName cmpName);
    private bool CompareNamesExtended(PdfName outName, PdfName cmpName, ObjectPath currentPath, CompareResult compareResult);
    public bool CompareNumbers(PdfNumber outNumber, PdfNumber cmpNumber);
    private bool CompareNumbersExtended(PdfNumber outNumber, PdfNumber cmpNumber, ObjectPath currentPath, CompareResult compareResult);
    public bool CompareStrings(PdfString outString, PdfString cmpString);
    private bool CompareStringsExtended(PdfString outString, PdfString cmpString, ObjectPath currentPath, CompareResult compareResult);
    public bool CompareLiterals(PdfLiteral outLiteral, PdfLiteral cmpLiteral);
    private bool CompareLiteralsExtended(PdfLiteral outLiteral, PdfLiteral cmpLiteral, ObjectPath currentPath, CompareResult compareResult);
    public bool CompareBooleans(PdfBoolean outBoolean, PdfBoolean cmpBoolean);
    private bool CompareBooleansExtended(PdfBoolean outBoolean, PdfBoolean cmpBoolean, ObjectPath currentPath, CompareResult compareResult);
    public string CompareXmp(Byte[] xmp1, Byte[] xmp2);
    public string CompareXmp(Byte[] xmp1, Byte[] xmp2, bool ignoreDateAndProducerProperties);
    public string CompareXmp(string outPdf, string cmpPdf);
    public string CompareXmp(string outPdf, string cmpPdf, bool ignoreDateAndProducerProperties);
    public bool CompareXmls(Byte[] xml1, Byte[] xml2);
    private void Init(string outPdf, string cmpPdf);
    private bool CompareStreams(FileStream is1, FileStream is2);
    public virtual string CompareDocumentInfo(string outPdf, string cmpPdf);
    private bool LinksAreSame(PdfImportedLink cmpLink, PdfImportedLink outLink);
    public virtual string CompareLinks(string outPdf, string cmpPdf);
    private String[] ConvertInfo(IDictionary`2<string, string> info);
    private bool PngPredicate(FileSystemInfo pathname);
    private bool CmpPngPredicate(FileSystemInfo pathname);
}
public abstract class iTextSharp.testutils.ITextTest : object {
    public virtual void RunTest();
    protected abstract virtual void MakePdf(string outPdf);
    protected abstract virtual string GetOutPdf();
    protected virtual void AssertPdf(string outPdf);
    protected virtual void ComparePdf(string outPdf, string cmpPdf);
    protected virtual string GetCmpPdf();
    protected virtual void DeleteDirectory(string path);
    protected virtual void DeleteFiles(string path);
}
public class iTextSharp.text.AccessibleElementId : object {
    private static int id_counter;
    private int id;
    private static AccessibleElementId();
    public virtual string ToString();
    public virtual int GetHashCode();
    public virtual bool Equals(object o);
    public virtual int CompareTo(AccessibleElementId elementId);
}
public class iTextSharp.text.Anchor : Phrase {
    protected string name;
    protected string reference;
    public IList`1<Chunk> Chunks { get; }
    public int Type { get; }
    public string Name { get; public set; }
    public string Reference { get; public set; }
    public Uri Url { get; }
    public Anchor(float leading);
    public Anchor(Chunk chunk);
    public Anchor(string str);
    public Anchor(string str, Font font);
    public Anchor(float leading, Chunk chunk);
    public Anchor(float leading, string str);
    public Anchor(float leading, string str, Font font);
    public Anchor(Phrase phrase);
    public virtual bool Process(IElementListener listener);
    public virtual IList`1<Chunk> get_Chunks();
    protected virtual bool ApplyAnchor(Chunk chunk, bool notGotoOK, bool localDestination);
    public virtual int get_Type();
    public virtual string get_Name();
    public virtual void set_Name(string value);
    public virtual string get_Reference();
    public virtual void set_Reference(string value);
    public virtual Uri get_Url();
}
public class iTextSharp.text.Annotation : object {
    public static int TEXT;
    public static int URL_NET;
    public static int URL_AS_STRING;
    public static int FILE_DEST;
    public static int FILE_PAGE;
    public static int NAMED_DEST;
    public static int LAUNCH;
    public static int SCREEN;
    public static string TITLE;
    public static string CONTENT;
    public static string URL;
    public static string FILE;
    public static string DESTINATION;
    public static string PAGE;
    public static string NAMED;
    public static string APPLICATION;
    public static string PARAMETERS;
    public static string OPERATION;
    public static string DEFAULTDIR;
    public static string LLX;
    public static string LLY;
    public static string URX;
    public static string URY;
    public static string MIMETYPE;
    protected int annotationtype;
    protected Dictionary`2<string, object> annotationAttributes;
    private float llx;
    private float lly;
    private float urx;
    private float ury;
    public int Type { get; }
    public IList`1<Chunk> Chunks { get; }
    public int AnnotationType { get; }
    public string Title { get; }
    public string Content { get; }
    public Dictionary`2<string, object> Attributes { get; }
    private Annotation(float llx, float lly, float urx, float ury);
    public Annotation(Annotation an);
    public Annotation(string title, string text);
    public Annotation(string title, string text, float llx, float lly, float urx, float ury);
    public Annotation(float llx, float lly, float urx, float ury, Uri url);
    public Annotation(float llx, float lly, float urx, float ury, string url);
    public Annotation(float llx, float lly, float urx, float ury, string file, string dest);
    public Annotation(float llx, float lly, float urx, float ury, string moviePath, string mimeType, bool showOnDisplay);
    public Annotation(float llx, float lly, float urx, float ury, string file, int page);
    public Annotation(float llx, float lly, float urx, float ury, int named);
    public Annotation(float llx, float lly, float urx, float ury, string application, string parameters, string operation, string defaultdir);
    public virtual int get_Type();
    public virtual bool Process(IElementListener listener);
    public virtual IList`1<Chunk> get_Chunks();
    public virtual void SetDimensions(float llx, float lly, float urx, float ury);
    public virtual float GetLlx();
    public virtual float GetLly();
    public virtual float GetUrx();
    public virtual float GetUry();
    public virtual float GetLlx(float def);
    public virtual float GetLly(float def);
    public virtual float GetUrx(float def);
    public virtual float GetUry(float def);
    public virtual int get_AnnotationType();
    public virtual string get_Title();
    public virtual string get_Content();
    public virtual Dictionary`2<string, object> get_Attributes();
    public virtual bool IsContent();
    public virtual bool IsNestable();
    public virtual string ToString();
}
public interface iTextSharp.text.api.IIndentable {
    public float IndentationLeft { get; public set; }
    public float IndentationRight { get; public set; }
    public abstract virtual float get_IndentationLeft();
    public abstract virtual void set_IndentationLeft(float value);
    public abstract virtual float get_IndentationRight();
    public abstract virtual void set_IndentationRight(float value);
}
public interface iTextSharp.text.api.ISpaceable {
    public float SpacingBefore { get; public set; }
    public float SpacingAfter { get; public set; }
    public float PaddingTop { get; public set; }
    public abstract virtual float get_SpacingBefore();
    public abstract virtual void set_SpacingBefore(float value);
    public abstract virtual float get_SpacingAfter();
    public abstract virtual void set_SpacingAfter(float value);
    public abstract virtual float get_PaddingTop();
    public abstract virtual void set_PaddingTop(float value);
}
public interface iTextSharp.text.api.IWriterOperation {
    public abstract virtual void Write(PdfWriter writer, Document doc);
}
public class iTextSharp.text.BadElementException : DocumentException {
    public BadElementException(string message);
    protected BadElementException(SerializationInfo info, StreamingContext context);
}
public class iTextSharp.text.BaseColor : object {
    private static double FACTOR;
    public static BaseColor WHITE;
    public static BaseColor LIGHT_GRAY;
    public static BaseColor GRAY;
    public static BaseColor DARK_GRAY;
    public static BaseColor BLACK;
    public static BaseColor RED;
    public static BaseColor PINK;
    public static BaseColor ORANGE;
    public static BaseColor YELLOW;
    public static BaseColor GREEN;
    public static BaseColor MAGENTA;
    public static BaseColor CYAN;
    public static BaseColor BLUE;
    private int value;
    public int RGB { get; }
    public int R { get; }
    public int G { get; }
    public int B { get; }
    public int A { get; }
    public BaseColor(int red, int green, int blue, int alpha);
    public BaseColor(int red, int green, int blue);
    public BaseColor(float red, float green, float blue, float alpha);
    public BaseColor(float red, float green, float blue);
    public BaseColor(int argb);
    public BaseColor(Color color);
    private static BaseColor();
    public virtual int get_RGB();
    public virtual int get_R();
    public virtual int get_G();
    public virtual int get_B();
    public virtual int get_A();
    public virtual BaseColor Brighter();
    public virtual BaseColor Darker();
    [ObsoleteAttribute("Use RGB instead")]
public virtual int ToArgb();
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    protected internal virtual void SetValue(int red, int green, int blue, int alpha);
    private static void Validate(int value);
    public virtual string ToString();
}
public class iTextSharp.text.Chapter : Section {
    public int Type { get; }
    public Chapter(int number);
    public Chapter(Paragraph title, int number);
    public Chapter(string title, int number);
    public virtual int get_Type();
    public virtual bool IsNestable();
}
public class iTextSharp.text.ChapterAutoNumber : Chapter {
    protected bool numberSet;
    public ChapterAutoNumber(Paragraph para);
    public ChapterAutoNumber(string title);
    public virtual Section AddSection(string title);
    public virtual Section AddSection(Paragraph title);
    public virtual int SetAutomaticNumber(int number);
}
public class iTextSharp.text.Chunk : object {
    public static string OBJECT_REPLACEMENT_CHARACTER;
    public static string SEPARATOR;
    public static string TAB;
    public static string TABSETTINGS;
    public static string HSCALE;
    public static string UNDERLINE;
    public static string SUBSUPSCRIPT;
    public static string SKEW;
    public static string BACKGROUND;
    public static string TEXTRENDERMODE;
    public static string SPLITCHARACTER;
    public static string HYPHENATION;
    public static string REMOTEGOTO;
    public static string LOCALGOTO;
    public static string LOCALDESTINATION;
    public static string GENERICTAG;
    public static string LINEHEIGHT;
    public static string IMAGE;
    public static string ACTION;
    public static string NEWPAGE;
    public static string PDFANNOTATION;
    public static string COLOR;
    public static string ENCODING;
    public static string CHAR_SPACING;
    public static string WORD_SPACING;
    public static string WHITESPACE;
    public static Chunk NEWLINE;
    public static Chunk NEXTPAGE;
    public static Chunk TABBING;
    public static Chunk SPACETABBING;
    protected StringBuilder content;
    protected Font font;
    protected Dictionary`2<string, object> attributes;
    protected internal PdfName role;
    protected internal Dictionary`2<PdfName, PdfObject> accessibleAttributes;
    protected AccessibleElementId id;
    private string contentWithNoTabs;
    public int Type { get; }
    public IList`1<Chunk> Chunks { get; }
    public Font Font { get; public set; }
    public string Content { get; }
    public Dictionary`2<string, object> Attributes { get; public set; }
    public float HorizontalScaling { get; }
    public PdfName Role { get; public set; }
    public AccessibleElementId ID { get; public set; }
    public bool IsInline { get; }
    private static Chunk();
    public Chunk(Chunk ck);
    public Chunk(string content, Font font);
    public Chunk(string content);
    public Chunk(char c, Font font);
    public Chunk(char c);
    public Chunk(Image image, float offsetX, float offsetY);
    public Chunk(IDrawInterface separator);
    public Chunk(IDrawInterface separator, bool vertical);
    [ObsoleteAttribute]
public Chunk(IDrawInterface separator, float tabPosition);
    [ObsoleteAttribute]
public Chunk(IDrawInterface separator, float tabPosition, bool newline);
    private Chunk(float tabInterval, bool isWhitespace);
    public Chunk(Image image, float offsetX, float offsetY, bool changeLeading);
    public virtual bool Process(IElementListener listener);
    public virtual int get_Type();
    public virtual IList`1<Chunk> get_Chunks();
    public virtual StringBuilder Append(string str);
    public virtual Font get_Font();
    public virtual void set_Font(Font value);
    public virtual string get_Content();
    public virtual string ToString();
    public virtual bool IsEmpty();
    public virtual float GetWidthPoint();
    public virtual bool HasAttributes();
    public bool HasAccessibleAttributes();
    public virtual Dictionary`2<string, object> get_Attributes();
    public virtual void set_Attributes(Dictionary`2<string, object> value);
    private Chunk SetAttribute(string name, object obj);
    public virtual Chunk SetHorizontalScaling(float scale);
    public virtual float get_HorizontalScaling();
    public virtual Chunk SetUnderline(float thickness, float yPosition);
    public virtual Chunk SetUnderline(BaseColor color, float thickness, float thicknessMul, float yPosition, float yPositionMul, int cap);
    public virtual Chunk SetTextRise(float rise);
    public virtual float GetTextRise();
    public virtual Chunk SetSkew(float alpha, float beta);
    public virtual Chunk SetBackground(BaseColor color);
    public virtual Chunk SetBackground(BaseColor color, float extraLeft, float extraBottom, float extraRight, float extraTop);
    public virtual Chunk SetTextRenderMode(int mode, float strokeWidth, BaseColor strokeColor);
    public virtual Chunk SetSplitCharacter(ISplitCharacter splitCharacter);
    public virtual Chunk SetHyphenation(IHyphenationEvent hyphenation);
    public virtual Chunk SetRemoteGoto(string filename, string name);
    public virtual Chunk SetRemoteGoto(string filename, int page);
    public virtual Chunk SetLocalGoto(string name);
    public virtual Chunk SetLocalDestination(string name);
    public virtual Chunk SetGenericTag(string text);
    public virtual Chunk setLineHeight(float lineheight);
    public virtual Image GetImage();
    public virtual Chunk SetAction(PdfAction action);
    public virtual Chunk SetAnchor(Uri url);
    public virtual Chunk SetAnchor(string url);
    public virtual Chunk SetNewPage();
    public virtual Chunk SetAnnotation(PdfAnnotation annotation);
    public virtual bool IsContent();
    public virtual bool IsNestable();
    public virtual IHyphenationEvent GetHyphenation();
    public virtual Chunk SetCharacterSpacing(float charSpace);
    public virtual float GetCharacterSpacing();
    public virtual Chunk SetWordSpacing(float wordSpace);
    public virtual float GetWordSpacing();
    public static Chunk CreateWhitespace(string content);
    public static Chunk CreateWhitespace(string content, bool preserve);
    public virtual bool IsWhitespace();
    [ObsoleteAttribute]
public static Chunk CreateTabspace();
    [ObsoleteAttribute]
public static Chunk CreateTabspace(float spacing);
    [ObsoleteAttribute]
public virtual bool IsTabspace();
    public virtual PdfObject GetAccessibleAttribute(PdfName key);
    public virtual void SetAccessibleAttribute(PdfName key, PdfObject value);
    public virtual Dictionary`2<PdfName, PdfObject> GetAccessibleAttributes();
    public virtual PdfName get_Role();
    public virtual void set_Role(PdfName value);
    public virtual AccessibleElementId get_ID();
    public virtual void set_ID(AccessibleElementId value);
    public virtual bool get_IsInline();
    public virtual string GetTextExpansion();
    public virtual void SetTextExpansion(string value);
}
public class iTextSharp.text.Document : object {
    public static bool Compress;
    public static float WmfFontCorrection;
    protected List`1<IDocListener> listeners;
    protected bool open;
    protected bool close;
    protected Rectangle pageSize;
    protected float marginLeft;
    protected float marginRight;
    protected float marginTop;
    protected float marginBottom;
    protected bool marginMirroring;
    protected bool marginMirroringTopBottom;
    protected string javaScript_onLoad;
    protected string javaScript_onUnLoad;
    protected string htmlStyleClass;
    protected int pageN;
    protected int chapternumber;
    protected PdfName role;
    protected Dictionary`2<PdfName, PdfObject> accessibleAttributes;
    protected AccessibleElementId id;
    unknown int PageCount {public set; }
    public int PageNumber { get; }
    public float LeftMargin { get; }
    public float RightMargin { get; }
    public float TopMargin { get; }
    public float BottomMargin { get; }
    public float Left { get; }
    public float Right { get; }
    public float Top { get; }
    public float Bottom { get; }
    public Rectangle PageSize { get; }
    public string JavaScript_onLoad { get; public set; }
    public string JavaScript_onUnLoad { get; public set; }
    public string HtmlStyleClass { get; public set; }
    public PdfName Role { get; public set; }
    public AccessibleElementId ID { get; public set; }
    public bool IsInline { get; }
    public Document(Rectangle pageSize);
    public Document(Rectangle pageSize, float marginLeft, float marginRight, float marginTop, float marginBottom);
    private static Document();
    public virtual void AddDocListener(IDocListener listener);
    public virtual void RemoveIDocListener(IDocListener listener);
    public virtual bool Add(IElement element);
    public virtual void Open();
    public virtual void OpenDocument();
    public virtual bool SetPageSize(Rectangle pageSize);
    public virtual bool SetMargins(float marginLeft, float marginRight, float marginTop, float marginBottom);
    public virtual bool NewPage();
    public virtual void ResetPageCount();
    public virtual void set_PageCount(int value);
    public virtual int get_PageNumber();
    public virtual void Close();
    public virtual void CloseDocument();
    public virtual bool AddHeader(string name, string content);
    public virtual bool AddTitle(string title);
    public virtual bool AddSubject(string subject);
    public virtual bool AddKeywords(string keywords);
    public virtual bool AddAuthor(string author);
    public virtual bool AddCreator(string creator);
    public virtual bool AddProducer();
    public virtual bool AddLanguage(string language);
    public virtual bool AddCreationDate();
    public virtual float get_LeftMargin();
    public virtual float get_RightMargin();
    public virtual float get_TopMargin();
    public virtual float get_BottomMargin();
    public virtual float get_Left();
    public virtual float get_Right();
    public virtual float get_Top();
    public virtual float get_Bottom();
    public virtual float GetLeft(float margin);
    public virtual float GetRight(float margin);
    public virtual float GetTop(float margin);
    public virtual float GetBottom(float margin);
    public virtual Rectangle get_PageSize();
    public virtual bool IsOpen();
    public virtual string get_JavaScript_onLoad();
    public virtual void set_JavaScript_onLoad(string value);
    public virtual string get_JavaScript_onUnLoad();
    public virtual void set_JavaScript_onUnLoad(string value);
    public virtual string get_HtmlStyleClass();
    public virtual void set_HtmlStyleClass(string value);
    public virtual bool SetMarginMirroring(bool marginMirroring);
    public virtual bool SetMarginMirroringTopBottom(bool marginMirroringTopBottom);
    public virtual bool IsMarginMirroring();
    public virtual void Dispose();
    public virtual PdfObject GetAccessibleAttribute(PdfName key);
    public virtual void SetAccessibleAttribute(PdfName key, PdfObject value);
    public virtual Dictionary`2<PdfName, PdfObject> GetAccessibleAttributes();
    public virtual PdfName get_Role();
    public virtual void set_Role(PdfName value);
    public virtual AccessibleElementId get_ID();
    public virtual void set_ID(AccessibleElementId value);
    public virtual bool get_IsInline();
}
public class iTextSharp.text.DocumentException : Exception {
    public DocumentException(string message);
    protected DocumentException(SerializationInfo info, StreamingContext context);
    public DocumentException(string message, Exception ex);
}
public abstract class iTextSharp.text.DocWriter : object {
    public static byte NEWLINE;
    public static byte TAB;
    public static byte LT;
    public static byte SPACE;
    public static byte EQUALS;
    public static byte QUOTE;
    public static byte GT;
    public static byte FORWARD;
    protected Rectangle pageSize;
    protected Document document;
    protected OutputStreamCounter os;
    protected bool open;
    protected bool pause;
    protected bool closeStream;
    unknown int PageCount {public set; }
    public bool CloseStream { get; public set; }
    protected DocWriter(Document document, Stream os);
    public virtual bool Add(IElement element);
    public virtual void Open();
    public virtual bool SetPageSize(Rectangle pageSize);
    public virtual bool SetMargins(float marginLeft, float marginRight, float marginTop, float marginBottom);
    public virtual bool NewPage();
    public virtual void ResetPageCount();
    public virtual void set_PageCount(int value);
    public virtual void Close();
    public static Byte[] GetISOBytes(string text);
    public virtual void Pause();
    public virtual bool IsPaused();
    public virtual void Resume();
    public virtual void Flush();
    protected virtual void Write(string str);
    protected virtual void AddTabs(int indent);
    protected virtual void Write(string key, string value);
    protected virtual void WriteStart(string tag);
    protected virtual void WriteEnd(string tag);
    protected virtual void WriteEnd();
    protected virtual bool WriteMarkupAttributes(Properties markup);
    public virtual bool get_CloseStream();
    public virtual void set_CloseStream(bool value);
    public virtual bool SetMarginMirroring(bool marginMirroring);
    public virtual bool SetMarginMirroringTopBottom(bool MarginMirroring);
    public virtual void Dispose();
}
public class iTextSharp.text.Element : object {
    public static int HEADER;
    public static int TITLE;
    public static int SUBJECT;
    public static int KEYWORDS;
    public static int AUTHOR;
    public static int PRODUCER;
    public static int CREATIONDATE;
    public static int CREATOR;
    public static int LANGUAGE;
    public static int CHUNK;
    public static int PHRASE;
    public static int PARAGRAPH;
    public static int SECTION;
    public static int LIST;
    public static int LISTITEM;
    public static int CHAPTER;
    public static int ANCHOR;
    public static int PTABLE;
    public static int ANNOTATION;
    public static int RECTANGLE;
    public static int JPEG;
    public static int JPEG2000;
    public static int IMGRAW;
    public static int IMGTEMPLATE;
    public static int JBIG2;
    public static int DIV;
    public static int BODY;
    public static int MARKED;
    public static int YMARK;
    public static int WRITABLE_DIRECT;
    public static int ALIGN_UNDEFINED;
    public static int ALIGN_LEFT;
    public static int ALIGN_CENTER;
    public static int ALIGN_RIGHT;
    public static int ALIGN_JUSTIFIED;
    public static int ALIGN_TOP;
    public static int ALIGN_MIDDLE;
    public static int ALIGN_BOTTOM;
    public static int ALIGN_BASELINE;
    public static int ALIGN_JUSTIFIED_ALL;
    public static int CCITTG4;
    public static int CCITTG3_1D;
    public static int CCITTG3_2D;
    public static int CCITT_BLACKIS1;
    public static int CCITT_ENCODEDBYTEALIGN;
    public static int CCITT_ENDOFLINE;
    public static int CCITT_ENDOFBLOCK;
}
public class iTextSharp.text.error_messages.LocalizedResource : object {
    private static Char[] splt;
    private Properties msgs;
    public LocalizedResource(string resourceRoot, CultureInfo culture, Assembly assembly);
    private static LocalizedResource();
    public virtual string GetMessage(string key);
}
public class iTextSharp.text.error_messages.MessageLocalization : object {
    private static string BASE_PATH;
    private static Dictionary`2<string, string> defaultLanguage;
    private static Dictionary`2<string, string> currentLanguage;
    private static MessageLocalization();
    public static string GetMessage(string key);
    public static string GetMessage(string key, bool useDefaultLanguageIfMessageNotFound);
    public static string GetComposedMessage(string key, Object[] p);
    public static bool SetLanguage(string language, string country);
    public static void SetMessages(TextReader r);
    private static Dictionary`2<string, string> GetLanguageMessages(string language, string country);
    private static Dictionary`2<string, string> ReadLanguageStream(Stream isp);
    private static Dictionary`2<string, string> ReadLanguageStream(TextReader br);
}
public class iTextSharp.text.exceptions.BadPasswordException : IOException {
    public BadPasswordException(string message);
    protected BadPasswordException(SerializationInfo info, StreamingContext context);
}
public class iTextSharp.text.exceptions.IllegalPdfSyntaxException : ArgumentException {
    public IllegalPdfSyntaxException(string message);
    protected IllegalPdfSyntaxException(SerializationInfo info, StreamingContext context);
}
public class iTextSharp.text.exceptions.InvalidImageException : Exception {
    public InvalidImageException(string message);
    public InvalidImageException(string message, Exception innerException);
    protected InvalidImageException(SerializationInfo info, StreamingContext context);
}
public class iTextSharp.text.exceptions.InvalidPdfException : IOException {
    private Exception cause;
    public InvalidPdfException(string message);
    public InvalidPdfException(string message, Exception cause);
    protected InvalidPdfException(SerializationInfo info, StreamingContext context);
}
public class iTextSharp.text.exceptions.UnsupportedPdfException : InvalidPdfException {
    public UnsupportedPdfException(string message);
    protected UnsupportedPdfException(SerializationInfo info, StreamingContext context);
}
public class iTextSharp.text.factories.GreekAlphabetFactory : object {
    public static string GetString(int index);
    public static string GetLowerCaseString(int index);
    public static string GetUpperCaseString(int index);
    public static string GetString(int index, bool lowercase);
}
public class iTextSharp.text.factories.RomanAlphabetFactory : object {
    public static string GetString(int index);
    public static string GetLowerCaseString(int index);
    public static string GetUpperCaseString(int index);
    public static string GetString(int index, bool lowercase);
}
public class iTextSharp.text.factories.RomanNumberFactory : object {
    private static RomanDigit[] roman;
    private static RomanNumberFactory();
    public static string GetString(int index);
    public static string GetLowerCaseString(int index);
    public static string GetUpperCaseString(int index);
    public static string GetString(int index, bool lowercase);
}
public class iTextSharp.text.Font : object {
    public static int NORMAL;
    public static int BOLD;
    public static int ITALIC;
    public static int UNDERLINE;
    public static int STRIKETHRU;
    public static int BOLDITALIC;
    public static int UNDEFINED;
    public static int DEFAULTSIZE;
    private FontFamily family;
    private float size;
    private int style;
    private BaseColor color;
    private BaseFont baseFont;
    public FontFamily Family { get; }
    public string Familyname { get; }
    public float Size { get; public set; }
    public float CalculatedSize { get; }
    public int Style { get; }
    public int CalculatedStyle { get; }
    public BaseColor Color { get; public set; }
    public BaseFont BaseFont { get; }
    public Font(Font other);
    public Font(FontFamily family, float size, int style, BaseColor color);
    public Font(BaseFont bf, float size, int style, BaseColor color);
    public Font(BaseFont bf, float size, int style);
    public Font(BaseFont bf, float size);
    public Font(BaseFont bf);
    public Font(FontFamily family, float size, int style);
    public Font(FontFamily family, float size);
    public Font(FontFamily family);
    public virtual int CompareTo(Font font);
    public virtual FontFamily get_Family();
    public virtual string get_Familyname();
    public virtual void SetFamily(string family);
    public static FontFamily GetFamilyIndex(string family);
    public virtual float get_Size();
    public virtual void set_Size(float value);
    public virtual float get_CalculatedSize();
    public virtual float GetCalculatedLeading(float multipliedLeading);
    public virtual int get_Style();
    public virtual int get_CalculatedStyle();
    public virtual bool IsBold();
    public virtual bool IsItalic();
    public virtual bool IsUnderlined();
    public virtual bool IsStrikethru();
    public virtual void SetStyle(string style);
    public virtual void SetStyle(int style);
    public static int GetStyleValue(string style);
    public virtual BaseColor get_Color();
    public virtual void set_Color(BaseColor value);
    public virtual void SetColor(int red, int green, int blue);
    public virtual BaseFont get_BaseFont();
    public virtual BaseFont GetCalculatedBaseFont(bool specialEncoding);
    public virtual bool IsStandardFont();
    public virtual Font Difference(Font font);
}
public class iTextSharp.text.FontFactory : object {
    public static string COURIER;
    public static string COURIER_BOLD;
    public static string COURIER_OBLIQUE;
    public static string COURIER_BOLDOBLIQUE;
    public static string HELVETICA;
    public static string HELVETICA_BOLD;
    public static string HELVETICA_OBLIQUE;
    public static string HELVETICA_BOLDOBLIQUE;
    public static string SYMBOL;
    public static string TIMES;
    public static string TIMES_ROMAN;
    public static string TIMES_BOLD;
    public static string TIMES_ITALIC;
    public static string TIMES_BOLDITALIC;
    public static string ZAPFDINGBATS;
    private static string defaultEncoding;
    private static bool defaultEmbedding;
    private static FontFactoryImp fontImp;
    public static ICollection`1<string> RegisteredFonts { get; }
    public static ICollection`1<string> RegisteredFamilies { get; }
    public static string DefaultEncoding { get; }
    public static bool DefaultEmbedding { get; }
    public static FontFactoryImp FontImp { get; public set; }
    private static FontFactory();
    public static Font GetFont(string fontname, string encoding, bool embedded, float size, int style, BaseColor color);
    public static Font GetFont(string fontname, string encoding, bool embedded, float size, int style, BaseColor color, bool cached);
    public static Font GetFont(string fontname, string encoding, bool embedded, float size, int style);
    public static Font GetFont(string fontname, string encoding, bool embedded, float size);
    public static Font GetFont(string fontname, string encoding, bool embedded);
    public static Font GetFont(string fontname, string encoding, float size, int style, BaseColor color);
    public static Font GetFont(string fontname, string encoding, float size, int style);
    public static Font GetFont(string fontname, string encoding, float size);
    public static Font GetFont(string fontname, string encoding);
    public static Font GetFont(string fontname, float size, int style, BaseColor color);
    public static Font GetFont(string fontname, float size, BaseColor color);
    public static Font GetFont(string fontname, float size, int style);
    public static Font GetFont(string fontname, float size);
    public static Font GetFont(string fontname);
    public static void RegisterFamily(string familyName, string fullName, string path);
    public static void Register(Properties attributes);
    public static void Register(string path);
    public static void Register(string path, string alias);
    public static int RegisterDirectory(string dir);
    public static int RegisterDirectory(string dir, bool scanSubdirectories);
    public static int RegisterDirectories();
    public static ICollection`1<string> get_RegisteredFonts();
    public static ICollection`1<string> get_RegisteredFamilies();
    public static bool Contains(string fontname);
    public static bool IsRegistered(string fontname);
    public static string get_DefaultEncoding();
    public static bool get_DefaultEmbedding();
    public static FontFactoryImp get_FontImp();
    public static void set_FontImp(FontFactoryImp value);
}
public class iTextSharp.text.FontFactoryImp : object {
    protected static string SystemPath;
    private static ILogger LOGGER;
    private Dictionary`2<string, string> trueTypeFonts;
    private static String[] TTFamilyOrder;
    private Dictionary`2<string, List`1<string>> fontFamilies;
    private string defaultEncoding;
    private bool defaultEmbedding;
    public ICollection`1<string> RegisteredFonts { get; }
    public ICollection`1<string> RegisteredFamilies { get; }
    public string DefaultEncoding { get; public set; }
    public bool DefaultEmbedding { get; public set; }
    private static FontFactoryImp();
    public virtual Font GetFont(string fontname, string encoding, bool embedded, float size, int style, BaseColor color);
    public virtual Font GetFont(string fontname, string encoding, bool embedded, float size, int style, BaseColor color, bool cached);
    protected virtual BaseFont GetBaseFont(string fontname, string encoding, bool embedded, bool cached);
    public virtual Font GetFont(string fontname, string encoding, bool embedded, float size, int style);
    public virtual Font GetFont(string fontname, string encoding, bool embedded, float size);
    public virtual Font GetFont(string fontname, string encoding, bool embedded);
    public virtual Font GetFont(string fontname, string encoding, float size, int style, BaseColor color);
    public virtual Font GetFont(string fontname, string encoding, float size, int style);
    public virtual Font GetFont(string fontname, string encoding, float size);
    public virtual Font GetFont(string fontname, string encoding);
    public virtual Font GetFont(string fontname, float size, int style, BaseColor color);
    public virtual Font GetFont(string fontname, float size, BaseColor color);
    public virtual Font GetFont(string fontname, float size, int style);
    public virtual Font GetFont(string fontname, float size);
    public virtual Font GetFont(string fontname);
    public virtual void RegisterFamily(string familyName, string fullName, string path);
    public virtual void Register(string path);
    public virtual void Register(string path, string alias);
    protected bool SaveCopyOfRegularFont(string regularFontName, string path);
    public virtual int RegisterDirectory(string dir);
    public virtual int RegisterDirectory(string dir, bool scanSubdirectories);
    public virtual int RegisterDirectories();
    public virtual ICollection`1<string> get_RegisteredFonts();
    public virtual ICollection`1<string> get_RegisteredFamilies();
    public virtual bool IsRegistered(string fontname);
    public virtual string get_DefaultEncoding();
    public virtual void set_DefaultEncoding(string value);
    public virtual bool get_DefaultEmbedding();
    public virtual void set_DefaultEmbedding(bool value);
}
public class iTextSharp.text.GreekList : List {
    public GreekList(int symbolIndent);
    public GreekList(bool greeklower, int symbolIndent);
    protected virtual void SetGreekFont();
    public virtual bool Add(IElement o);
    public virtual List CloneShallow();
}
public class iTextSharp.text.Header : Meta {
    private StringBuilder name;
    public string Name { get; }
    public Header(string name, string content);
    public virtual string get_Name();
}
[ObsoleteAttribute]
public static class iTextSharp.text.html.HtmlEncoder : object {
    private static String[] HTML_CODE;
    private static Dictionary`2<string, object> NEWLINETAGS;
    private static HtmlEncoder();
    public static string Encode(string str);
    public static string Encode(BaseColor color);
    public static string GetAlignment(int alignment);
    public static bool IsNewLineTag(string tag);
}
[ObsoleteAttribute]
public static class iTextSharp.text.html.HtmlTags : object {
    public static string A;
    public static string B;
    public static string BODY;
    public static string BLOCKQUOTE;
    public static string BR;
    public static string DIV;
    public static string EM;
    public static string FONT;
    public static string H1;
    public static string H2;
    public static string H3;
    public static string H4;
    public static string H5;
    public static string H6;
    public static string HR;
    public static string I;
    public static string IMG;
    public static string LI;
    public static string OL;
    public static string P;
    public static string PRE;
    public static string S;
    public static string SPAN;
    public static string STRIKE;
    public static string STRONG;
    public static string SUB;
    public static string SUP;
    public static string TABLE;
    public static string TD;
    public static string TH;
    public static string TR;
    public static string U;
    public static string UL;
    public static string ALIGN;
    public static string BGCOLOR;
    public static string BORDER;
    public static string CELLPADDING;
    public static string COLSPAN;
    public static string EXTRAPARASPACE;
    public static string ENCODING;
    public static string FACE;
    public static string HEIGHT;
    public static string HREF;
    public static string HYPHENATION;
    public static string IMAGEPATH;
    public static string INDENT;
    public static string LEADING;
    public static string ROWSPAN;
    public static string SIZE;
    public static string SRC;
    public static string VALIGN;
    public static string WIDTH;
    public static string ALIGN_LEFT;
    public static string ALIGN_CENTER;
    public static string ALIGN_RIGHT;
    public static string ALIGN_JUSTIFY;
    public static string ALIGN_JUSTIFIED_ALL;
    public static string ALIGN_TOP;
    public static string ALIGN_MIDDLE;
    public static string ALIGN_BOTTOM;
    public static string ALIGN_BASELINE;
    public static string STYLE;
    public static string CLASS;
    public static string COLOR;
    public static string FONTFAMILY;
    public static string FONTSIZE;
    public static string FONTSTYLE;
    public static string FONTWEIGHT;
    public static string LINEHEIGHT;
    public static string PADDINGLEFT;
    public static string TEXTALIGN;
    public static string TEXTDECORATION;
    public static string VERTICALALIGN;
    public static string BOLD;
    public static string ITALIC;
    public static string LINETHROUGH;
    public static string NORMAL;
    public static string OBLIQUE;
    public static string UNDERLINE;
    public static string AFTER;
    public static string BEFORE;
}
[ObsoleteAttribute]
public class iTextSharp.text.html.HtmlUtilities : object {
    public static float DEFAULT_FONT_SIZE;
    private static Dictionary`2<string, float> sizes;
    public static Int32[] FONTSIZES;
    private static HtmlUtilities();
    public static float ParseLength(string str);
    public static float ParseLength(string str, float actualFontSize);
    public static BaseColor DecodeColor(string s);
    public static Properties ParseAttributes(string str);
    public static string RemoveComment(string str, string startComment, string endComment);
    public static string EliminateWhiteSpace(string content);
    public static int GetIndexedFontSize(string value, string previous);
    public static int AlignmentValue(string alignment);
}
[ObsoleteAttribute]
public class iTextSharp.text.html.simpleparser.CellWrapper : object {
    private PdfPCell cell;
    private float width;
    private bool percentage;
    public IList`1<Chunk> Chunks { get; }
    public int Type { get; }
    public PdfPCell Cell { get; }
    public float Width { get; }
    public bool IsPercentage { get; }
    public CellWrapper(string tag, ChainedProperties chain);
    public virtual PdfPCell CreatePdfPCell(string tag, ChainedProperties chain);
    public virtual bool Add(IElement o);
    public virtual IList`1<Chunk> get_Chunks();
    public virtual bool Process(IElementListener listener);
    public virtual int get_Type();
    public virtual PdfPCell get_Cell();
    public virtual bool IsContent();
    public virtual bool IsNestable();
    public virtual float get_Width();
    public virtual bool get_IsPercentage();
    public virtual string ToString();
}
[DefaultMemberAttribute("Item")]
[ObsoleteAttribute]
public class iTextSharp.text.html.simpleparser.ChainedProperties : object {
    public IList`1<TagAttributes> chain;
    public string Item { get; }
    public string get_Item(string key);
    public virtual bool HasProperty(string key);
    public virtual void AddToChain(string tag, IDictionary`2<string, string> props);
    public virtual void RemoveChain(string tag);
    protected internal virtual void AdjustFontSize(IDictionary`2<string, string> attrs);
}
[ObsoleteAttribute]
public class iTextSharp.text.html.simpleparser.ElementFactory : object {
    private IFontProvider provider;
    public IFontProvider FontProvider { get; public set; }
    public virtual void set_FontProvider(IFontProvider value);
    public virtual IFontProvider get_FontProvider();
    public virtual Font GetFont(ChainedProperties chain);
    public virtual Chunk CreateChunk(string content, ChainedProperties chain);
    public virtual Paragraph CreateParagraph(ChainedProperties chain);
    public virtual ListItem CreateListItem(ChainedProperties chain);
    protected virtual void UpdateElement(Paragraph paragraph, ChainedProperties chain);
    protected static void SetParagraphLeading(Paragraph paragraph, string leading);
    public virtual IHyphenationEvent GetHyphenation(ChainedProperties chain);
    public virtual LineSeparator CreateLineSeparator(IDictionary`2<string, string> attrs, float offset);
    public virtual Image CreateImage(string src, IDictionary`2<string, string> attrs, ChainedProperties chain, IDocListener document, IImageProvider img_provider, Dictionary`2<string, Image> img_store, string img_baseurl);
    public virtual List CreateList(string tag, ChainedProperties chain);
}
[ObsoleteAttribute]
public class iTextSharp.text.html.simpleparser.HTMLTagProcessors : Dictionary`2<string, IHTMLTagProcessor> {
    public static IHTMLTagProcessor EM_STRONG_STRIKE_SUP_SUP;
    public static IHTMLTagProcessor A;
    public static IHTMLTagProcessor BR;
    public static IHTMLTagProcessor UL_OL;
    public static IHTMLTagProcessor HR;
    public static IHTMLTagProcessor SPAN;
    public static IHTMLTagProcessor H;
    public static IHTMLTagProcessor LI;
    public static IHTMLTagProcessor PRE;
    public static IHTMLTagProcessor DIV;
    public static IHTMLTagProcessor TABLE;
    public static IHTMLTagProcessor TR;
    public static IHTMLTagProcessor TD;
    public static IHTMLTagProcessor IMG;
    private static HTMLTagProcessors();
}
[ObsoleteAttribute]
public class iTextSharp.text.html.simpleparser.HTMLWorker : object {
    public static string IMG_PROVIDER;
    public static string IMG_PROCESSOR;
    public static string IMG_STORE;
    public static string IMG_BASEURL;
    public static string FONT_PROVIDER;
    public static string LINK_PROVIDER;
    private static ILogger LOGGER;
    protected IDocListener document;
    protected internal IDictionary`2<string, IHTMLTagProcessor> tags;
    private StyleSheet style;
    protected Stack`1<IElement> stack;
    protected Paragraph currentParagraph;
    private ChainedProperties chain;
    private IDictionary`2<string, object> providers;
    private ElementFactory factory;
    private Stack`1<Boolean[]> tableState;
    private bool pendingTR;
    private bool pendingTD;
    private bool pendingLI;
    private bool insidePRE;
    protected internal bool skipText;
    protected List`1<IElement> objectList;
    unknown int PageCount {public set; }
    public HTMLWorker(IDocListener document);
    public HTMLWorker(IDocListener document, IDictionary`2<string, IHTMLTagProcessor> tags, StyleSheet style);
    private static HTMLWorker();
    public virtual void SetSupportedTags(IDictionary`2<string, IHTMLTagProcessor> tags);
    public virtual void SetStyleSheet(StyleSheet style);
    public virtual void Parse(TextReader reader);
    public virtual void StartDocument();
    public virtual void StartElement(string tag, IDictionary`2<string, string> attrs);
    public virtual void Text(string content);
    public virtual void EndElement(string tag);
    public virtual void EndDocument();
    public virtual void NewLine();
    public virtual void CarriageReturn();
    public virtual void FlushContent();
    public virtual void PushToStack(IElement element);
    public virtual void UpdateChain(string tag, IDictionary`2<string, string> attrs);
    public virtual void UpdateChain(string tag);
    public virtual void SetProviders(IDictionary`2<string, object> providers);
    public virtual Chunk CreateChunk(string content);
    public virtual Paragraph CreateParagraph();
    public virtual List CreateList(string tag);
    public virtual ListItem CreateListItem();
    public virtual LineSeparator CreateLineSeparator(IDictionary`2<string, string> attrs);
    public virtual Image CreateImage(IDictionary`2<string, string> attrs);
    public virtual CellWrapper CreateCell(string tag);
    public virtual void ProcessLink();
    public virtual void ProcessList();
    public virtual void ProcessListItem();
    public virtual void ProcessImage(Image img, IDictionary`2<string, string> attrs);
    public virtual void ProcessTable();
    public virtual void ProcessRow();
    public virtual void PushTableState();
    public virtual void PopTableState();
    public virtual bool IsPendingTR();
    public virtual void SetPendingTR(bool pendingTR);
    public virtual bool IsPendingTD();
    public virtual void SetPendingTD(bool pendingTD);
    public virtual bool IsPendingLI();
    public virtual void SetPendingLI(bool pendingLI);
    public virtual bool IsInsidePRE();
    public virtual void SetInsidePRE(bool insidePRE);
    public virtual bool IsSkipText();
    public virtual void SetSkipText(bool skipText);
    public static List`1<IElement> ParseToList(TextReader reader, StyleSheet style);
    public static List`1<IElement> ParseToList(TextReader reader, StyleSheet style, Dictionary`2<string, object> providers);
    public static List`1<IElement> ParseToList(TextReader reader, StyleSheet style, IDictionary`2<string, IHTMLTagProcessor> tags, Dictionary`2<string, object> providers);
    public virtual bool Add(IElement element);
    public virtual void Close();
    public virtual bool NewPage();
    public virtual void Open();
    public virtual void ResetPageCount();
    public virtual bool SetMarginMirroring(bool marginMirroring);
    public virtual bool SetMarginMirroringTopBottom(bool marginMirroring);
    public virtual bool SetMargins(float marginLeft, float marginRight, float marginTop, float marginBottom);
    public virtual void set_PageCount(int value);
    public virtual bool SetPageSize(Rectangle pageSize);
    public virtual void SetInterfaceProps(Dictionary`2<string, object> providers);
    public virtual IDictionary`2<string, object> GetInterfaceProps();
    public virtual void Dispose();
}
[ObsoleteAttribute]
public interface iTextSharp.text.html.simpleparser.IHTMLTagProcessor {
    public abstract virtual void StartElement(HTMLWorker worker, string tag, IDictionary`2<string, string> attrs);
    public abstract virtual void EndElement(HTMLWorker worker, string tag);
}
[ObsoleteAttribute]
public interface iTextSharp.text.html.simpleparser.IImageProcessor {
    public abstract virtual bool Process(Image img, IDictionary`2<string, string> attrs, ChainedProperties chain, IDocListener doc);
}
[ObsoleteAttribute]
public interface iTextSharp.text.html.simpleparser.IImageProvider {
    public abstract virtual Image GetImage(string src, IDictionary`2<string, string> attrs, ChainedProperties chain, IDocListener doc);
}
[ObsoleteAttribute]
public interface iTextSharp.text.html.simpleparser.ILinkProcessor {
    public abstract virtual bool Process(Paragraph current, ChainedProperties attrs);
}
[ObsoleteAttribute]
public class iTextSharp.text.html.simpleparser.ImageStore : Dictionary`2<string, Image> {
}
[ObsoleteAttribute]
public class iTextSharp.text.html.simpleparser.StyleSheet : object {
    protected internal IDictionary`2<string, IDictionary`2<string, string>> tagMap;
    protected internal IDictionary`2<string, IDictionary`2<string, string>> classMap;
    public virtual void LoadTagStyle(string tag, IDictionary`2<string, string> attrs);
    public virtual void LoadTagStyle(string tag, string key, string value);
    public virtual void LoadStyle(string className, Dictionary`2<string, string> attrs);
    public virtual void LoadStyle(string className, string key, string value);
    public virtual void ApplyStyle(string tag, IDictionary`2<string, string> attrs);
    public static void ResolveStyleAttribute(IDictionary`2<string, string> h, ChainedProperties chain);
}
[ObsoleteAttribute]
public class iTextSharp.text.html.simpleparser.TableWrapper : object {
    private IDictionary`2<string, string> styles;
    private IList`1<IList`1<PdfPCell>> rows;
    private Single[] colWidths;
    unknown Single[] ColWidths {public set; }
    public int Type { get; }
    public IList`1<Chunk> Chunks { get; }
    public TableWrapper(IDictionary`2<string, string> attrs);
    public virtual void AddRow(IList`1<PdfPCell> row);
    public virtual void set_ColWidths(Single[] value);
    public virtual PdfPTable CreateTable();
    public virtual bool Process(IElementListener listener);
    public virtual int get_Type();
    public virtual bool IsContent();
    public virtual bool IsNestable();
    public virtual IList`1<Chunk> get_Chunks();
}
[ObsoleteAttribute]
public class iTextSharp.text.html.WebColors : Dictionary`2<string, Int32[]> {
    public static WebColors NAMES;
    private static WebColors();
    private static bool MissingHashColorFormat(string colStr);
    public static BaseColor GetRGBColor(string name);
    private static int GetRGBChannelValue(string rgbChannel);
}
public interface iTextSharp.text.IDocListener {
    unknown int PageCount {public set; }
    public abstract virtual void Open();
    public abstract virtual void Close();
    public abstract virtual bool NewPage();
    public abstract virtual bool SetPageSize(Rectangle pageSize);
    public abstract virtual bool SetMargins(float marginLeft, float marginRight, float marginTop, float marginBottom);
    public abstract virtual bool SetMarginMirroring(bool marginMirroring);
    public abstract virtual bool SetMarginMirroringTopBottom(bool marginMirroringTopBottom);
    public abstract virtual void set_PageCount(int value);
    public abstract virtual void ResetPageCount();
}
public interface iTextSharp.text.IElement {
    public int Type { get; }
    public IList`1<Chunk> Chunks { get; }
    public abstract virtual bool Process(IElementListener listener);
    public abstract virtual int get_Type();
    public abstract virtual bool IsContent();
    public abstract virtual bool IsNestable();
    public abstract virtual IList`1<Chunk> get_Chunks();
    public abstract virtual string ToString();
}
public interface iTextSharp.text.IElementListener {
    public abstract virtual bool Add(IElement element);
}
public interface iTextSharp.text.IFontProvider {
    public abstract virtual bool IsRegistered(string fontname);
    public abstract virtual Font GetFont(string fontname, string encoding, bool embedded, float size, int style, BaseColor color);
}
public interface iTextSharp.text.ILargeElement {
    public bool ElementComplete { get; public set; }
    public abstract virtual bool get_ElementComplete();
    public abstract virtual void set_ElementComplete(bool value);
    public abstract virtual void FlushContent();
}
public abstract class iTextSharp.text.Image : Rectangle {
    public static int DEFAULT;
    public static int RIGHT_ALIGN;
    public static int LEFT_ALIGN;
    public static int MIDDLE_ALIGN;
    public static int TEXTWRAP;
    public static int UNDERLYING;
    public static int AX;
    public static int AY;
    public static int BX;
    public static int BY;
    public static int CX;
    public static int CY;
    public static int DX;
    public static int DY;
    public static int ORIGINAL_NONE;
    public static int ORIGINAL_JPEG;
    public static int ORIGINAL_PNG;
    public static int ORIGINAL_GIF;
    public static int ORIGINAL_BMP;
    public static int ORIGINAL_TIFF;
    public static int ORIGINAL_WMF;
    public static int ORIGINAL_JPEG2000;
    public static int ORIGINAL_JBIG2;
    protected bool invert;
    protected int type;
    protected Uri url;
    protected Byte[] rawData;
    protected PdfTemplate[] template;
    protected int alignment;
    protected string alt;
    protected float absoluteX;
    protected float absoluteY;
    protected float plainWidth;
    protected float plainHeight;
    protected float scaledWidth;
    protected float scaledHeight;
    protected int compressionLevel;
    protected float rotationRadians;
    protected int colorspace;
    protected int colortransform;
    protected int bpc;
    protected Int32[] transparency;
    protected float indentationLeft;
    protected float indentationRight;
    protected long mySerialId;
    private static object serialId;
    protected PdfName role;
    protected Dictionary`2<PdfName, PdfObject> accessibleAttributes;
    protected AccessibleElementId id;
    protected int dpiX;
    protected int dpiY;
    protected bool mask;
    protected Image imageMask;
    protected bool interpolation;
    protected Annotation annotation;
    protected ICC_Profile profile;
    protected bool deflated;
    private PdfDictionary additional;
    private bool smask;
    private float xyRatio;
    protected int originalType;
    protected Byte[] originalData;
    protected float spacingBefore;
    protected float spacingAfter;
    protected float paddingTop;
    private float widthPercentage;
    protected IPdfOCG layer;
    private float initialRotation;
    private PdfIndirectReference directReference;
    protected internal bool scaleToFitLineWhenOverflow;
    protected bool scaleToFitHeight;
    unknown float Rotation {public set; }
    unknown float RotationDegrees {public set; }
    public Annotation Annotation { get; public set; }
    public int Bpc { get; }
    public Byte[] RawData { get; }
    public PdfTemplate TemplateData { get; public set; }
    public float AbsoluteX { get; }
    public float AbsoluteY { get; }
    public int Type { get; }
    public Uri Url { get; public set; }
    public int Alignment { get; public set; }
    public string Alt { get; public set; }
    public float ScaledWidth { get; }
    public float ScaledHeight { get; }
    public int Colorspace { get; }
    public int ColorTransform { get; public set; }
    public Int32[] Transparency { get; public set; }
    public float PlainWidth { get; }
    public float PlainHeight { get; }
    public long MySerialId { get; }
    public int DpiX { get; }
    public int DpiY { get; }
    public Image ImageMask { get; public set; }
    public bool Inverted { get; public set; }
    public bool Interpolation { get; public set; }
    public ICC_Profile TagICC { get; public set; }
    public bool Deflated { get; public set; }
    public PdfDictionary Additional { get; public set; }
    public bool Smask { get; public set; }
    public float XYRatio { get; public set; }
    public float IndentationLeft { get; public set; }
    public float IndentationRight { get; public set; }
    public int OriginalType { get; public set; }
    public Byte[] OriginalData { get; public set; }
    public float SpacingBefore { get; public set; }
    public float SpacingAfter { get; public set; }
    public float PaddingTop { get; public set; }
    public float WidthPercentage { get; public set; }
    public bool ScaleToFitLineWhenOverflow { get; public set; }
    public bool ScaleToFitHeight { get; public set; }
    public IPdfOCG Layer { get; public set; }
    public float InitialRotation { get; public set; }
    public PdfIndirectReference DirectReference { get; public set; }
    public int CompressionLevel { get; public set; }
    public PdfName Role { get; public set; }
    public AccessibleElementId ID { get; public set; }
    public bool IsInline { get; }
    public Image(Uri url);
    public Image(Image image);
    private static Image();
    public static Image GetInstance(Image image);
    public static Image GetInstance(Uri url);
    public static Image GetInstance(Uri url, bool recoverFromImageError);
    public static Image GetInstance(Stream s);
    public static Image GetInstance(string filename, bool recoverFromImageError);
    public static Image GetInstance(Byte[] imgb);
    public static Image GetInstance(Byte[] imgb, bool recoverFromImageError);
    public static Image GetInstance(Image image, BaseColor color, bool forceBW);
    public static Image GetInstance(Image image, ImageFormat format);
    public static Image GetInstance(Image image, BaseColor color);
    public static Image GetInstance(string filename);
    public static Image GetInstance(int width, int height, int components, int bpc, Byte[] data);
    public static Image GetInstance(int width, int height, Byte[] data, Byte[] globals);
    public static Image GetInstance(PRIndirectReference iref);
    public static Image GetInstance(PdfTemplate template);
    public static Image GetInstance(int width, int height, bool reverseBits, int typeCCITT, int parameters, Byte[] data);
    public static Image GetInstance(int width, int height, bool reverseBits, int typeCCITT, int parameters, Byte[] data, Int32[] transparency);
    public static Image GetInstance(int width, int height, int components, int bpc, Byte[] data, Int32[] transparency);
    public virtual void SetAbsolutePosition(float absoluteX, float absoluteY);
    public virtual void ScaleAbsolute(Rectangle rectangle);
    public virtual void ScaleAbsolute(float newWidth, float newHeight);
    public virtual void ScaleAbsoluteWidth(float newWidth);
    public virtual void ScaleAbsoluteHeight(float newHeight);
    public virtual void ScalePercent(float percent);
    public virtual void ScalePercent(float percentX, float percentY);
    public virtual void ScaleToFit(Rectangle rectangle);
    public virtual void ScaleToFit(float fitWidth, float fitHeight);
    public virtual float GetImageRotation();
    public void set_Rotation(float value);
    public virtual void set_RotationDegrees(float value);
    public virtual Annotation get_Annotation();
    public virtual void set_Annotation(Annotation value);
    public virtual int get_Bpc();
    public virtual Byte[] get_RawData();
    public virtual PdfTemplate get_TemplateData();
    public virtual void set_TemplateData(PdfTemplate value);
    public virtual bool HasAbsolutePosition();
    public virtual bool HasAbsoluteX();
    public virtual float get_AbsoluteX();
    public virtual float get_AbsoluteY();
    public virtual int get_Type();
    public virtual bool IsNestable();
    public virtual bool IsJpeg();
    public virtual bool IsImgRaw();
    public virtual bool IsImgTemplate();
    public virtual Uri get_Url();
    public virtual void set_Url(Uri value);
    public virtual int get_Alignment();
    public virtual void set_Alignment(int value);
    public virtual string get_Alt();
    public virtual void set_Alt(string value);
    public virtual float get_ScaledWidth();
    public virtual float get_ScaledHeight();
    public virtual int get_Colorspace();
    public virtual int get_ColorTransform();
    public virtual void set_ColorTransform(int value);
    public virtual Single[] GetMatrix();
    public virtual Single[] GetMatrix(float scalePercentage);
    public virtual Int32[] get_Transparency();
    public virtual void set_Transparency(Int32[] value);
    public virtual float get_PlainWidth();
    public virtual float get_PlainHeight();
    protected static long GetSerialId();
    public virtual long get_MySerialId();
    public virtual int get_DpiX();
    public virtual int get_DpiY();
    public virtual void SetDpi(int dpiX, int dpiY);
    public virtual bool IsMaskCandidate();
    public virtual void MakeMask();
    public virtual Image get_ImageMask();
    public virtual void set_ImageMask(Image value);
    public virtual bool IsMask();
    public virtual void set_Inverted(bool value);
    public virtual bool get_Inverted();
    public virtual void set_Interpolation(bool value);
    public virtual bool get_Interpolation();
    public virtual ICC_Profile get_TagICC();
    public virtual void set_TagICC(ICC_Profile value);
    public virtual bool HasICCProfile();
    public virtual bool get_Deflated();
    public virtual void set_Deflated(bool value);
    public virtual PdfDictionary get_Additional();
    public virtual void set_Additional(PdfDictionary value);
    public virtual bool get_Smask();
    public virtual void set_Smask(bool value);
    public virtual float get_XYRatio();
    public virtual void set_XYRatio(float value);
    public virtual float get_IndentationLeft();
    public virtual void set_IndentationLeft(float value);
    public virtual float get_IndentationRight();
    public virtual void set_IndentationRight(float value);
    public virtual int get_OriginalType();
    public virtual void set_OriginalType(int value);
    public virtual Byte[] get_OriginalData();
    public virtual void set_OriginalData(Byte[] value);
    public virtual float get_SpacingBefore();
    public virtual void set_SpacingBefore(float value);
    public virtual float get_SpacingAfter();
    public virtual void set_SpacingAfter(float value);
    public virtual float get_PaddingTop();
    public virtual void set_PaddingTop(float value);
    public virtual float get_WidthPercentage();
    public virtual void set_WidthPercentage(float value);
    public virtual bool get_ScaleToFitLineWhenOverflow();
    public virtual void set_ScaleToFitLineWhenOverflow(bool value);
    public virtual bool get_ScaleToFitHeight();
    public virtual void set_ScaleToFitHeight(bool value);
    public virtual IPdfOCG get_Layer();
    public virtual void set_Layer(IPdfOCG value);
    private PdfObject SimplifyColorspace(PdfArray obj);
    public virtual void SimplifyColorspace();
    public virtual float get_InitialRotation();
    public virtual void set_InitialRotation(float value);
    public virtual void set_DirectReference(PdfIndirectReference value);
    public virtual PdfIndirectReference get_DirectReference();
    public virtual void set_CompressionLevel(int value);
    public virtual int get_CompressionLevel();
    public virtual PdfObject GetAccessibleAttribute(PdfName key);
    public virtual void SetAccessibleAttribute(PdfName key, PdfObject value);
    public virtual Dictionary`2<PdfName, PdfObject> GetAccessibleAttributes();
    public virtual PdfName get_Role();
    public virtual void set_Role(PdfName value);
    public virtual AccessibleElementId get_ID();
    public virtual void set_ID(AccessibleElementId value);
    public virtual bool get_IsInline();
}
public class iTextSharp.text.ImgCCITT : Image {
    public ImgCCITT(Image image);
    public ImgCCITT(int width, int height, bool reverseBits, int typeCCITT, int parameters, Byte[] data);
}
public class iTextSharp.text.ImgJBIG2 : Image {
    private Byte[] global;
    private Byte[] globalHash;
    public Byte[] GlobalBytes { get; }
    public Byte[] GlobalHash { get; }
    private ImgJBIG2(Image image);
    public ImgJBIG2(int width, int height, Byte[] data, Byte[] globals);
    public virtual Byte[] get_GlobalBytes();
    public virtual Byte[] get_GlobalHash();
}
public class iTextSharp.text.ImgRaw : Image {
    public ImgRaw(Image image);
    public ImgRaw(int width, int height, int components, int bpc, Byte[] data);
}
public class iTextSharp.text.ImgTemplate : Image {
    public ImgTemplate(Image image);
    public ImgTemplate(PdfTemplate template);
}
public class iTextSharp.text.ImgWMF : Image {
    public ImgWMF(Image image);
    public ImgWMF(Uri url);
    public ImgWMF(string filename);
    public ImgWMF(Byte[] img);
    private void ProcessParameters();
    public virtual void ReadWMF(PdfTemplate template);
}
internal class iTextSharp.text.io.ArrayRandomAccessSource : object {
    private Byte[] array;
    public long Length { get; }
    public ArrayRandomAccessSource(Byte[] array);
    public virtual int Get(long offset);
    public virtual int Get(long offset, Byte[] bytes, int off, int len);
    public virtual long get_Length();
    public virtual void Close();
    public virtual void Dispose();
}
public class iTextSharp.text.io.GetBufferedRandomAccessSource : object {
    private IRandomAccessSource source;
    private Byte[] getBuffer;
    private long getBufferStart;
    private long getBufferEnd;
    public long Length { get; }
    public GetBufferedRandomAccessSource(IRandomAccessSource source);
    public virtual int Get(long position);
    public virtual int Get(long position, Byte[] bytes, int off, int len);
    public virtual long get_Length();
    public virtual void Close();
    public virtual void Dispose();
}
internal class iTextSharp.text.io.GroupedRandomAccessSource : object {
    private SourceEntry[] sources;
    private SourceEntry currentSourceEntry;
    private long size;
    public long Length { get; }
    public GroupedRandomAccessSource(ICollection`1<IRandomAccessSource> sources);
    protected internal virtual int GetStartingSourceIndex(long offset);
    private SourceEntry GetSourceEntryForOffset(long offset);
    protected internal virtual void SourceReleased(IRandomAccessSource source);
    protected internal virtual void SourceInUse(IRandomAccessSource source);
    public virtual int Get(long position);
    public virtual int Get(long position, Byte[] bytes, int off, int len);
    public virtual long get_Length();
    public virtual void Close();
    public virtual void Dispose();
}
public class iTextSharp.text.io.IndependentRandomAccessSource : object {
    private IRandomAccessSource source;
    public long Length { get; }
    public IndependentRandomAccessSource(IRandomAccessSource source);
    public virtual int Get(long position);
    public virtual int Get(long position, Byte[] bytes, int off, int len);
    public virtual long get_Length();
    public virtual void Close();
    public virtual void Dispose();
}
public interface iTextSharp.text.io.IRandomAccessSource {
    public long Length { get; }
    public abstract virtual int Get(long position);
    public abstract virtual int Get(long position, Byte[] bytes, int off, int len);
    public abstract virtual long get_Length();
    public abstract virtual void Close();
}
internal class iTextSharp.text.io.RAFRandomAccessSource : object {
    private FileStream raf;
    private long length;
    public long Length { get; }
    public RAFRandomAccessSource(FileStream raf);
    public virtual int Get(long position);
    public virtual int Get(long position, Byte[] bytes, int off, int len);
    public virtual long get_Length();
    public virtual void Close();
    public virtual void Dispose();
}
public class iTextSharp.text.io.RandomAccessSourceFactory : object {
    private bool forceRead;
    private bool usePlainRandomAccess;
    private bool exclusivelyLockFile;
    public RandomAccessSourceFactory SetForceRead(bool forceRead);
    public RandomAccessSourceFactory SetExclusivelyLockFile(bool exclusivelyLockFile);
    public IRandomAccessSource CreateSource(Byte[] data);
    public IRandomAccessSource CreateSource(FileStream raf);
    public IRandomAccessSource CreateSource(Uri url);
    public IRandomAccessSource CreateSource(Stream inp);
    public IRandomAccessSource CreateBestSource(string filename);
    public IRandomAccessSource CreateRanged(IRandomAccessSource source, IList`1<long> ranges);
    private IRandomAccessSource CreateByReadingToMemory(string filename);
    private IRandomAccessSource CreateByReadingToMemory(Stream inp);
}
public class iTextSharp.text.io.RASInputStream : Stream {
    private IRandomAccessSource source;
    private long position;
    public bool CanRead { get; }
    public bool CanSeek { get; }
    public bool CanWrite { get; }
    public long Length { get; }
    public long Position { get; public set; }
    public RASInputStream(IRandomAccessSource source);
    public virtual bool get_CanRead();
    public virtual bool get_CanSeek();
    public virtual bool get_CanWrite();
    public virtual void Flush();
    public virtual long get_Length();
    public virtual long get_Position();
    public virtual void set_Position(long value);
    public virtual int Read(Byte[] buffer, int offset, int len);
    public virtual int ReadByte();
    public virtual long Seek(long offset, SeekOrigin origin);
    public virtual void SetLength(long value);
    public virtual void Write(Byte[] buffer, int offset, int count);
}
public static class iTextSharp.text.io.StreamUtil : object {
    internal static List`1<object> resourceSearch;
    private static StreamUtil();
    public static Byte[] InputStreamToArray(Stream inp);
    public static void CopyBytes(IRandomAccessSource source, long start, long length, Stream outs);
    public static void AddToResourceSearch(object obj);
    public static Stream GetResourceStream(string key);
}
public class iTextSharp.text.io.WindowRandomAccessSource : object {
    private IRandomAccessSource source;
    private long offset;
    private long length;
    public long Length { get; }
    public WindowRandomAccessSource(IRandomAccessSource source, long offset);
    public WindowRandomAccessSource(IRandomAccessSource source, long offset, long length);
    public virtual int Get(long position);
    public virtual int Get(long position, Byte[] bytes, int off, int len);
    public virtual long get_Length();
    public virtual void Close();
    public virtual void Dispose();
}
public interface iTextSharp.text.IRtfElementInterface {
}
public interface iTextSharp.text.ISplitCharacter {
    public abstract virtual bool IsSplitCharacter(int start, int current, int end, Char[] cc, PdfChunk[] ck);
}
public interface iTextSharp.text.ITextElementArray {
    public abstract virtual bool Add(IElement o);
}
public class iTextSharp.text.Jpeg : Image {
    public static int NOT_A_MARKER;
    public static int VALID_MARKER;
    public static int UNSUPPORTED_MARKER;
    public static int NOPARAM_MARKER;
    public static int M_APP0;
    public static int M_APP2;
    public static int M_APPE;
    public static int M_APPD;
    public static Int32[] VALID_MARKERS;
    public static Int32[] UNSUPPORTED_MARKERS;
    public static Int32[] NOPARAM_MARKERS;
    public static Byte[] JFIF_ID;
    public static Byte[] PS_8BIM_RESO;
    private Byte[][] icc;
    public Jpeg(Image image);
    public Jpeg(Uri Uri);
    public Jpeg(Byte[] img);
    public Jpeg(Byte[] img, float width, float height);
    private static Jpeg();
    private static int GetShort(Stream istr);
    private static int GetShortInverted(Stream istr);
    private static int MarkerType(int marker);
    private void ProcessParameters();
}
public class iTextSharp.text.Jpeg2000 : Image {
    public static int JP2_JP;
    public static int JP2_IHDR;
    public static int JPIP_JPIP;
    public static int JP2_FTYP;
    public static int JP2_JP2H;
    public static int JP2_COLR;
    public static int JP2_JP2C;
    public static int JP2_URL;
    public static int JP2_DBTL;
    public static int JP2_BPCC;
    public static int JP2_JP2;
    private static int ZERO_BOX_SIZE;
    private Stream inp;
    private int boxLength;
    private int boxType;
    private int numOfComps;
    private List`1<ColorSpecBox> colorSpecBoxes;
    private bool isJp2;
    private Byte[] bpcBoxData;
    public Jpeg2000(Image image);
    public Jpeg2000(Uri url);
    public Jpeg2000(Byte[] img);
    public Jpeg2000(Byte[] img, float width, float height);
    private int Cio_read(int n);
    public virtual void Jp2_read_boxhdr();
    private void ProcessParameters();
    private ColorSpecBox Jp2_read_colr();
    public virtual int GetNumOfComps();
    public virtual Byte[] GetBpcBoxData();
    public virtual List`1<ColorSpecBox> GetColorSpecBoxes();
    public virtual bool IsJp2();
}
public class iTextSharp.text.List : object {
    public static bool ORDERED;
    public static bool UNORDERED;
    public static bool NUMERICAL;
    public static bool ALPHABETICAL;
    public static bool UPPERCASE;
    public static bool LOWERCASE;
    protected List`1<IElement> list;
    protected bool numbered;
    protected bool lettered;
    protected bool lowercase;
    protected bool autoindent;
    protected bool alignindent;
    protected int first;
    protected Chunk symbol;
    protected string preSymbol;
    protected string postSymbol;
    protected float indentationLeft;
    protected float indentationRight;
    protected float symbolIndent;
    protected PdfName role;
    protected Dictionary`2<PdfName, PdfObject> accessibleAttributes;
    protected AccessibleElementId id;
    public int Type { get; }
    public IList`1<Chunk> Chunks { get; }
    public bool Numbered { get; public set; }
    public bool Lettered { get; public set; }
    public bool Lowercase { get; public set; }
    public bool IsLowercase { get; public set; }
    public bool Autoindent { get; public set; }
    public bool Alignindent { get; public set; }
    public int First { get; public set; }
    unknown Chunk ListSymbol {public set; }
    public float IndentationLeft { get; public set; }
    public float IndentationRight { get; public set; }
    public float SymbolIndent { get; public set; }
    public List`1<IElement> Items { get; }
    public int Size { get; }
    public float TotalLeading { get; }
    public Chunk Symbol { get; public set; }
    public string PostSymbol { get; public set; }
    public string PreSymbol { get; public set; }
    public PdfName Role { get; public set; }
    public AccessibleElementId ID { get; public set; }
    public bool IsInline { get; }
    public List(float symbolIndent);
    public List(bool numbered);
    public List(bool numbered, bool lettered);
    public List(bool numbered, float symbolIndent);
    public List(bool numbered, bool lettered, float symbolIndent);
    public virtual bool Process(IElementListener listener);
    public virtual int get_Type();
    public virtual IList`1<Chunk> get_Chunks();
    public virtual bool Add(string s);
    public virtual bool Add(IElement o);
    public virtual List CloneShallow();
    protected void PopulateProperties(List clone);
    public virtual void NormalizeIndentation();
    public virtual void set_Numbered(bool value);
    public virtual bool get_Numbered();
    public virtual void set_Lettered(bool value);
    public virtual bool get_Lettered();
    public virtual void set_Lowercase(bool value);
    public virtual bool get_Lowercase();
    public virtual void set_IsLowercase(bool value);
    public virtual bool get_IsLowercase();
    public virtual void set_Autoindent(bool value);
    public virtual bool get_Autoindent();
    public virtual void set_Alignindent(bool value);
    public virtual bool get_Alignindent();
    public virtual int get_First();
    public virtual void set_First(int value);
    public virtual void set_ListSymbol(Chunk value);
    public virtual void SetListSymbol(string symbol);
    public virtual float get_IndentationLeft();
    public virtual void set_IndentationLeft(float value);
    public virtual float get_IndentationRight();
    public virtual void set_IndentationRight(float value);
    public virtual void set_SymbolIndent(float value);
    public virtual float get_SymbolIndent();
    public virtual bool IsContent();
    public virtual bool IsNestable();
    public virtual List`1<IElement> get_Items();
    public virtual int get_Size();
    public virtual bool IsEmpty();
    public virtual float get_TotalLeading();
    public virtual Chunk get_Symbol();
    public virtual void set_Symbol(Chunk value);
    public virtual string getPostSymbol();
    public virtual void set_PostSymbol(string value);
    public virtual string get_PostSymbol();
    public virtual void set_PreSymbol(string value);
    public virtual string get_PreSymbol();
    public virtual ListItem GetFirstItem();
    public virtual ListItem GetLastItem();
    public virtual PdfObject GetAccessibleAttribute(PdfName key);
    public virtual void SetAccessibleAttribute(PdfName key, PdfObject value);
    public virtual Dictionary`2<PdfName, PdfObject> GetAccessibleAttributes();
    public virtual PdfName get_Role();
    public virtual void set_Role(PdfName value);
    public virtual AccessibleElementId get_ID();
    public virtual void set_ID(AccessibleElementId value);
    public virtual bool get_IsInline();
}
public class iTextSharp.text.ListItem : Paragraph {
    protected Chunk symbol;
    private ListBody listBody;
    private ListLabel listLabel;
    public int Type { get; }
    public Chunk ListSymbol { get; public set; }
    public ListBody ListBody { get; }
    public ListLabel ListLabel { get; }
    public ListItem(float leading);
    public ListItem(Chunk chunk);
    public ListItem(string str);
    public ListItem(string str, Font font);
    public ListItem(float leading, Chunk chunk);
    public ListItem(float leading, string str);
    public ListItem(float leading, string str, Font font);
    public ListItem(Phrase phrase);
    public virtual int get_Type();
    public virtual Paragraph CloneShallow(bool spacingBefore);
    public virtual Chunk get_ListSymbol();
    public virtual void set_ListSymbol(Chunk value);
    public virtual void SetIndentationLeft(float indentation, bool autoindent);
    public virtual void AdjustListSymbolFont();
    public virtual ListBody get_ListBody();
    public virtual ListLabel get_ListLabel();
}
public class iTextSharp.text.log.CounterFactory : object {
    private static CounterFactory myself;
    private ICounter counter;
    private static CounterFactory();
    public static CounterFactory getInstance();
    public static ICounter GetCounter(Type klass);
    public virtual ICounter GetCounter();
    public virtual void SetCounter(ICounter counter);
}
public class iTextSharp.text.log.DefaultCounter : object {
    private int count;
    private int level;
    private Int32[] repeat;
    private int repeat_level;
    private static Byte[] message;
    private static DefaultCounter();
    public sealed virtual ICounter GetCounter(Type klass);
    public sealed virtual void Read(long l);
    public sealed virtual void Written(long l);
    private void PlusOne();
}
public interface iTextSharp.text.log.ICounter {
    public abstract virtual ICounter GetCounter(Type klass);
    public abstract virtual void Read(long l);
    public abstract virtual void Written(long l);
}
public interface iTextSharp.text.log.ILogger {
    public abstract virtual ILogger GetLogger(Type klass);
    public abstract virtual ILogger GetLogger(string name);
    public abstract virtual bool IsLogging(Level level);
    public abstract virtual void Warn(string message);
    public abstract virtual void Trace(string message);
    public abstract virtual void Debug(string message);
    public abstract virtual void Info(string message);
    public abstract virtual void Error(string message);
    public abstract virtual void Error(string message, Exception e);
}
public enum iTextSharp.text.log.Level : Enum {
    public int value__;
    public static Level ERROR;
    public static Level WARN;
    public static Level INFO;
    public static Level DEBUG;
    public static Level TRACE;
}
public class iTextSharp.text.log.LoggerFactory : object {
    private static LoggerFactory myself;
    private ILogger logger;
    private static LoggerFactory();
    public static ILogger GetLogger(Type klass);
    public static ILogger GetLogger(string name);
    public static LoggerFactory GetInstance();
    public virtual void SetLogger(ILogger logger);
    public virtual ILogger Logger();
}
public class iTextSharp.text.log.NoOpCounter : object {
    public virtual ICounter GetCounter(Type klass);
    public virtual void Read(long l);
    public virtual void Written(long l);
}
public class iTextSharp.text.log.NoOpLogger : object {
    public sealed virtual ILogger GetLogger(Type name);
    public sealed virtual void Warn(string message);
    public sealed virtual void Trace(string message);
    public sealed virtual void Debug(string message);
    public sealed virtual void Info(string message);
    public sealed virtual void Error(string message, Exception e);
    public sealed virtual bool IsLogging(Level level);
    public sealed virtual void Error(string message);
    public sealed virtual ILogger GetLogger(string name);
}
public class iTextSharp.text.log.SysoCounter : object {
    protected string name;
    protected SysoCounter(Type klass);
    public virtual ICounter GetCounter(Type klass);
    public virtual void Read(long l);
    public virtual void Written(long l);
}
public class iTextSharp.text.log.SysoLogger : object {
    private string name;
    private int shorten;
    public SysoLogger(int packageReduce);
    protected SysoLogger(string klass, int shorten);
    public virtual ILogger GetLogger(Type klass);
    public virtual ILogger GetLogger(string name);
    public virtual bool IsLogging(Level level);
    public virtual void Warn(string message);
    private string Shorten(string className);
    public virtual void Trace(string message);
    public virtual void Debug(string message);
    public virtual void Info(string message);
    public virtual void Error(string message);
    public virtual void Error(string message, Exception e);
}
[ObsoleteAttribute]
public class iTextSharp.text.MarkedObject : object {
    protected internal IElement element;
    protected internal Properties markupAttributes;
    public IList`1<Chunk> Chunks { get; }
    public int Type { get; }
    public Properties MarkupAttributes { get; }
    public MarkedObject(IElement element);
    public virtual IList`1<Chunk> get_Chunks();
    public virtual bool Process(IElementListener listener);
    public virtual int get_Type();
    public virtual bool IsContent();
    public virtual bool IsNestable();
    public virtual Properties get_MarkupAttributes();
    public virtual void SetMarkupAttribute(string key, string value);
}
[ObsoleteAttribute]
public class iTextSharp.text.MarkedSection : MarkedObject {
    protected MarkedObject title;
    public MarkedObject Title { get; public set; }
    unknown int NumberDepth {public set; }
    public float IndentationLeft { get; public set; }
    public float IndentationRight { get; public set; }
    unknown float Indentation {public set; }
    unknown bool BookmarkOpen {public set; }
    unknown bool TriggerNewPage {public set; }
    unknown string BookmarkTitle {public set; }
    public MarkedSection(Section section);
    public virtual void Add(int index, IElement o);
    public virtual bool Add(IElement o);
    public virtual bool Process(IElementListener listener);
    public virtual bool AddAll(ICollection`1<T> collection);
    public virtual MarkedSection AddSection(float indentation, int numberDepth);
    public virtual MarkedSection AddSection(float indentation);
    public virtual MarkedSection AddSection(int numberDepth);
    public virtual MarkedSection AddSection();
    public virtual void set_Title(MarkedObject value);
    public virtual MarkedObject get_Title();
    public virtual void set_NumberDepth(int value);
    public virtual float get_IndentationLeft();
    public virtual void set_IndentationLeft(float value);
    public virtual float get_IndentationRight();
    public virtual void set_IndentationRight(float value);
    public virtual void set_Indentation(float value);
    public virtual void set_BookmarkOpen(bool value);
    public virtual void set_TriggerNewPage(bool value);
    public virtual void set_BookmarkTitle(string value);
    public virtual void NewPage();
}
public class iTextSharp.text.Meta : object {
    public static string UNKNOWN;
    public static string PRODUCER;
    public static string CREATIONDATE;
    public static string AUTHOR;
    public static string KEYWORDS;
    public static string SUBJECT;
    public static string TITLE;
    private int type;
    private StringBuilder content;
    public int Type { get; }
    public IList`1<Chunk> Chunks { get; }
    public string Content { get; }
    public string Name { get; }
    public Meta(int type, string content);
    public Meta(string tag, string content);
    public virtual bool Process(IElementListener listener);
    public virtual int get_Type();
    public virtual IList`1<Chunk> get_Chunks();
    public virtual bool IsContent();
    public virtual bool IsNestable();
    public virtual StringBuilder Append(string str);
    public virtual string get_Content();
    public virtual string get_Name();
    public static int GetType(string tag);
    public virtual string ToString();
}
public class iTextSharp.text.PageSize : object {
    public static Rectangle LETTER;
    public static Rectangle NOTE;
    public static Rectangle LEGAL;
    public static Rectangle TABLOID;
    public static Rectangle EXECUTIVE;
    public static Rectangle POSTCARD;
    public static Rectangle A0;
    public static Rectangle A1;
    public static Rectangle A2;
    public static Rectangle A3;
    public static Rectangle A4;
    public static Rectangle A5;
    public static Rectangle A6;
    public static Rectangle A7;
    public static Rectangle A8;
    public static Rectangle A9;
    public static Rectangle A10;
    public static Rectangle B0;
    public static Rectangle B1;
    public static Rectangle B2;
    public static Rectangle B3;
    public static Rectangle B4;
    public static Rectangle B5;
    public static Rectangle B6;
    public static Rectangle B7;
    public static Rectangle B8;
    public static Rectangle B9;
    public static Rectangle B10;
    public static Rectangle ARCH_E;
    public static Rectangle ARCH_D;
    public static Rectangle ARCH_C;
    public static Rectangle ARCH_B;
    public static Rectangle ARCH_A;
    public static Rectangle FLSA;
    public static Rectangle FLSE;
    public static Rectangle HALFLETTER;
    public static Rectangle _11X17;
    public static Rectangle ID_1;
    public static Rectangle ID_2;
    public static Rectangle ID_3;
    public static Rectangle LEDGER;
    public static Rectangle CROWN_QUARTO;
    public static Rectangle LARGE_CROWN_QUARTO;
    public static Rectangle DEMY_QUARTO;
    public static Rectangle ROYAL_QUARTO;
    public static Rectangle CROWN_OCTAVO;
    public static Rectangle LARGE_CROWN_OCTAVO;
    public static Rectangle DEMY_OCTAVO;
    public static Rectangle ROYAL_OCTAVO;
    public static Rectangle SMALL_PAPERBACK;
    public static Rectangle PENGUIN_SMALL_PAPERBACK;
    public static Rectangle PENGUIN_LARGE_PAPERBACK;
    [ObsoleteAttribute]
public static Rectangle LETTER_LANDSCAPE;
    [ObsoleteAttribute]
public static Rectangle LEGAL_LANDSCAPE;
    [ObsoleteAttribute]
public static Rectangle A4_LANDSCAPE;
    private static PageSize();
    public static Rectangle GetRectangle(string name);
}
public class iTextSharp.text.Paragraph : Phrase {
    protected int alignment;
    protected float indentationLeft;
    protected float indentationRight;
    private float firstLineIndent;
    protected float spacingBefore;
    protected float spacingAfter;
    private float extraParagraphSpace;
    protected bool keeptogether;
    protected float paddingTop;
    protected PdfName role;
    protected Dictionary`2<PdfName, PdfObject> accessibleAttributes;
    private AccessibleElementId id;
    public int Type { get; }
    public int Alignment { get; public set; }
    public float IndentationLeft { get; public set; }
    public float IndentationRight { get; public set; }
    public float SpacingBefore { get; public set; }
    public float SpacingAfter { get; public set; }
    public bool KeepTogether { get; public set; }
    public float FirstLineIndent { get; public set; }
    public float ExtraParagraphSpace { get; public set; }
    public PdfName Role { get; public set; }
    public AccessibleElementId ID { get; public set; }
    public bool IsInline { get; }
    public float PaddingTop { get; public set; }
    public Paragraph(float leading);
    public Paragraph(Chunk chunk);
    public Paragraph(float leading, Chunk chunk);
    public Paragraph(string str);
    public Paragraph(string str, Font font);
    public Paragraph(float leading, string str);
    public Paragraph(float leading, string str, Font font);
    public Paragraph(Phrase phrase);
    public virtual Paragraph CloneShallow(bool spacingBefore);
    protected void PopulateProperties(Paragraph copy, bool spacingBefore);
    [ObsoleteAttribute]
public virtual Paragraph cloneShallow(bool spacingBefore);
    public virtual IList`1<IElement> BreakUp();
    [ObsoleteAttribute]
public IList`1<IElement> breakUp();
    public virtual int get_Type();
    public virtual bool Add(IElement o);
    public virtual int get_Alignment();
    public virtual void set_Alignment(int value);
    public virtual float get_IndentationLeft();
    public virtual void set_IndentationLeft(float value);
    public virtual float get_IndentationRight();
    public virtual void set_IndentationRight(float value);
    public virtual float get_SpacingBefore();
    public virtual void set_SpacingBefore(float value);
    public virtual float get_SpacingAfter();
    public virtual void set_SpacingAfter(float value);
    public virtual bool get_KeepTogether();
    public virtual void set_KeepTogether(bool value);
    public virtual float get_FirstLineIndent();
    public virtual void set_FirstLineIndent(float value);
    public virtual float get_ExtraParagraphSpace();
    public virtual void set_ExtraParagraphSpace(float value);
    public virtual PdfObject GetAccessibleAttribute(PdfName key);
    public virtual void SetAccessibleAttribute(PdfName key, PdfObject value);
    public virtual Dictionary`2<PdfName, PdfObject> GetAccessibleAttributes();
    public virtual PdfName get_Role();
    public virtual void set_Role(PdfName value);
    public virtual AccessibleElementId get_ID();
    public virtual void set_ID(AccessibleElementId value);
    public virtual bool get_IsInline();
    public virtual float get_PaddingTop();
    public virtual void set_PaddingTop(float value);
}
public class iTextSharp.text.pdf.AcroFields : object {
    public static int DA_FONT;
    public static int DA_SIZE;
    public static int DA_COLOR;
    public static int FIELD_TYPE_NONE;
    public static int FIELD_TYPE_PUSHBUTTON;
    public static int FIELD_TYPE_CHECKBOX;
    public static int FIELD_TYPE_RADIOBUTTON;
    public static int FIELD_TYPE_TEXT;
    public static int FIELD_TYPE_LIST;
    public static int FIELD_TYPE_COMBO;
    public static int FIELD_TYPE_SIGNATURE;
    private static Dictionary`2<string, String[]> stdFieldFontNames;
    internal PdfReader reader;
    internal PdfWriter writer;
    internal IDictionary`2<string, Item> fields;
    private int topFirst;
    private Dictionary`2<string, Int32[]> sigNames;
    private bool append;
    private Dictionary`2<int, BaseFont> extensionFonts;
    private XfaForm xfa;
    private bool lastWasString;
    private bool generateAppearances;
    private Dictionary`2<string, BaseFont> localFonts;
    private float extraMarginLeft;
    private float extraMarginTop;
    private List`1<BaseFont> substitutionFonts;
    private List`1<string> orderedSignatureNames;
    private int totalRevisions;
    private IDictionary`2<string, TextField> fieldCache;
    private static PdfName[] buttonRemove;
    public IDictionary`2<string, Item> Fields { get; }
    public bool GenerateAppearances { get; public set; }
    public int TotalRevisions { get; }
    public IDictionary`2<string, TextField> FieldCache { get; public set; }
    public List`1<BaseFont> SubstitutionFonts { get; public set; }
    public XfaForm Xfa { get; }
    private static AcroFields();
    internal AcroFields(PdfReader reader, PdfWriter writer);
    public static Object[] SplitDAelements(string da);
    private static void ClearSigDic(PdfDictionary dic);
    internal void Fill();
    public virtual String[] GetAppearanceStates(string fieldName);
    private String[] GetListOption(string fieldName, int idx);
    public virtual String[] GetListOptionExport(string fieldName);
    public virtual String[] GetListOptionDisplay(string fieldName);
    public virtual bool SetListOption(string fieldName, String[] exportValues, String[] displayValues);
    public virtual int GetFieldType(string fieldName);
    public virtual void ExportAsFdf(FdfWriter writer);
    public virtual bool RenameField(string oldName, string newName);
    public virtual void DecodeGenericDictionary(PdfDictionary merged, BaseField tx);
    internal PdfAppearance GetAppearance(PdfDictionary merged, String[] values, string fieldName);
    internal PdfAppearance GetAppearance(PdfDictionary merged, string text, string fieldName);
    internal BaseColor GetMKColor(PdfArray ar);
    public virtual string GetFieldRichValue(string name);
    public virtual string GetField(string name);
    public virtual String[] GetListSelection(string name);
    public virtual bool SetFieldProperty(string field, string name, object value, Int32[] inst);
    public virtual bool SetFieldProperty(string field, string name, int value, Int32[] inst);
    public virtual void MergeXfaData(XmlNode n);
    public virtual void SetFields(FdfReader fdf);
    public virtual void SetFields(XfdfReader xfdf);
    public virtual bool RegenerateField(string name);
    public virtual bool SetField(string name, string value);
    public virtual bool SetField(string name, string value, bool saveAppearance);
    public virtual bool SetFieldRichValue(string name, string richValue);
    public virtual bool SetField(string name, string value, string display);
    public virtual bool SetField(string name, string value, string display, bool saveAppearance);
    public virtual bool SetListSelection(string name, String[] value);
    internal bool IsInAP(PdfDictionary nDic, PdfName check);
    public virtual IDictionary`2<string, Item> get_Fields();
    public virtual Item GetFieldItem(string name);
    public virtual string GetTranslatedFieldName(string name);
    public virtual IList`1<FieldPosition> GetFieldPositions(string name);
    private int RemoveRefFromArray(PdfArray array, PdfObject refo);
    public virtual bool RemoveFieldsFromPage(int page);
    public virtual bool RemoveField(string name, int page);
    public virtual bool RemoveField(string name);
    public virtual void set_GenerateAppearances(bool value);
    public virtual bool get_GenerateAppearances();
    public virtual bool ClearSignatureField(string name);
    private void FindSignatureNames();
    public virtual List`1<string> GetSignatureNames();
    public virtual List`1<string> GetBlankSignatureNames();
    public virtual PdfDictionary GetSignatureDictionary(string name);
    public virtual PdfIndirectReference GetNormalAppearance(string name);
    public virtual bool SignatureCoversWholeDocument(string name);
    public virtual PdfPKCS7 VerifySignature(string name);
    private void UpdateByteRange(PdfPKCS7 pkcs7, PdfDictionary v);
    public virtual int get_TotalRevisions();
    public virtual int GetRevision(string field);
    public virtual Stream ExtractRevision(string field);
    public virtual void set_FieldCache(IDictionary`2<string, TextField> value);
    public virtual IDictionary`2<string, TextField> get_FieldCache();
    private void MarkUsed(PdfObject obj);
    public virtual void SetExtraMargin(float extraMarginLeft, float extraMarginTop);
    public virtual void AddSubstitutionFont(BaseFont font);
    public virtual void set_SubstitutionFonts(List`1<BaseFont> value);
    public virtual List`1<BaseFont> get_SubstitutionFonts();
    public virtual XfaForm get_Xfa();
    public virtual void RemoveXfa();
    public virtual PushbuttonField GetNewPushbuttonFromField(string field);
    public virtual PushbuttonField GetNewPushbuttonFromField(string field, int order);
    public virtual bool ReplacePushbuttonField(string field, PdfFormField button);
    public virtual bool ReplacePushbuttonField(string field, PdfFormField button, int order);
    public virtual bool DoesSignatureFieldExist(string name);
}
public class iTextSharp.text.pdf.ArabicLigaturizer : object {
    private static char ALEF;
    private static char ALEFHAMZA;
    private static char ALEFHAMZABELOW;
    private static char ALEFMADDA;
    private static char LAM;
    private static char HAMZA;
    private static char TATWEEL;
    private static char ZWJ;
    private static char HAMZAABOVE;
    private static char HAMZABELOW;
    private static char WAWHAMZA;
    private static char YEHHAMZA;
    private static char WAW;
    private static char ALEFMAKSURA;
    private static char YEH;
    private static char FARSIYEH;
    private static char SHADDA;
    private static char KASRA;
    private static char FATHA;
    private static char DAMMA;
    private static char MADDA;
    private static char LAM_ALEF;
    private static char LAM_ALEFHAMZA;
    private static char LAM_ALEFHAMZABELOW;
    private static char LAM_ALEFMADDA;
    public static int ar_nothing;
    public static int ar_novowel;
    public static int ar_composedtashkeel;
    public static int ar_lig;
    public static int DIGITS_EN2AN;
    public static int DIGITS_AN2EN;
    public static int DIGITS_EN2AN_INIT_LR;
    public static int DIGITS_EN2AN_INIT_AL;
    private static int DIGITS_RESERVED;
    public static int DIGITS_MASK;
    public static int DIGIT_TYPE_AN;
    public static int DIGIT_TYPE_AN_EXTENDED;
    public static int DIGIT_TYPE_MASK;
    private static Dictionary`2<char, Char[]> maptable;
    private static Dictionary`2<char, char> reverseLigatureMapTable;
    private static Char[][] chartable;
    protected int options;
    protected int runDirection;
    private static ArabicLigaturizer();
    public ArabicLigaturizer(int runDirection, int options);
    private static bool IsVowel(char s);
    private static char Charshape(char s, int which);
    private static int Shapecount(char s);
    private static int Ligature(char newchar, Charstruct oldchar);
    private static void Copycstostring(StringBuilder str, Charstruct s, int level);
    internal static void Doublelig(StringBuilder str, int level);
    private static bool Connects_to_left(Charstruct a);
    internal static void Shape(Char[] text, StringBuilder str, int level);
    internal static int Arabic_shape(Char[] src, int srcoffset, int srclength, Char[] dest, int destoffset, int destlength, int level);
    internal static void ProcessNumbers(Char[] text, int offset, int length, int options);
    internal static void ShapeToArabicDigitsWithContext(Char[] dest, int start, int length, char digitBase, bool lastStrongWasAL);
    public static bool TryGetReverseMapping(char key, Char& value);
    public virtual string Process(string s);
    public virtual bool IsRTL();
}
public class iTextSharp.text.pdf.BadPdfFormatException : Exception {
    public BadPdfFormatException(string message);
    protected BadPdfFormatException(SerializationInfo info, StreamingContext context);
}
public abstract class iTextSharp.text.pdf.Barcode : object {
    public static int EAN13;
    public static int EAN8;
    public static int UPCA;
    public static int UPCE;
    public static int SUPP2;
    public static int SUPP5;
    public static int POSTNET;
    public static int PLANET;
    public static int CODE128;
    public static int CODE128_UCC;
    public static int CODE128_RAW;
    public static int CODABAR;
    protected float x;
    protected float n;
    protected BaseFont font;
    protected float size;
    protected float baseline;
    protected float barHeight;
    protected int textAlignment;
    protected bool generateChecksum;
    protected bool checksumText;
    protected bool startStopText;
    protected bool extended;
    protected string code;
    protected bool guardBars;
    protected int codeType;
    protected float inkSpreading;
    protected string altText;
    public float X { get; public set; }
    public float N { get; public set; }
    public BaseFont Font { get; public set; }
    public float Size { get; public set; }
    public float Baseline { get; public set; }
    public float BarHeight { get; public set; }
    public int TextAlignment { get; public set; }
    public bool GenerateChecksum { get; public set; }
    public bool ChecksumText { get; public set; }
    public bool StartStopText { get; public set; }
    public bool Extended { get; public set; }
    public string Code { get; public set; }
    public bool GuardBars { get; public set; }
    public int CodeType { get; public set; }
    public Rectangle BarcodeSize { get; }
    public float InkSpreading { get; public set; }
    public string AltText { get; public set; }
    public virtual float get_X();
    public virtual void set_X(float value);
    public virtual float get_N();
    public virtual void set_N(float value);
    public virtual BaseFont get_Font();
    public virtual void set_Font(BaseFont value);
    public virtual float get_Size();
    public virtual void set_Size(float value);
    public virtual float get_Baseline();
    public virtual void set_Baseline(float value);
    public virtual float get_BarHeight();
    public virtual void set_BarHeight(float value);
    public virtual int get_TextAlignment();
    public virtual void set_TextAlignment(int value);
    public virtual void set_GenerateChecksum(bool value);
    public virtual bool get_GenerateChecksum();
    public virtual void set_ChecksumText(bool value);
    public virtual bool get_ChecksumText();
    public virtual void set_StartStopText(bool value);
    public virtual bool get_StartStopText();
    public virtual void set_Extended(bool value);
    public virtual bool get_Extended();
    public virtual string get_Code();
    public virtual void set_Code(string value);
    public virtual void set_GuardBars(bool value);
    public virtual bool get_GuardBars();
    public virtual int get_CodeType();
    public virtual void set_CodeType(int value);
    public abstract virtual Rectangle get_BarcodeSize();
    public virtual void set_InkSpreading(float value);
    public virtual float get_InkSpreading();
    public abstract virtual Rectangle PlaceBarcode(PdfContentByte cb, BaseColor barColor, BaseColor textColor);
    public virtual PdfTemplate CreateTemplateWithBarcode(PdfContentByte cb, BaseColor barColor, BaseColor textColor);
    public virtual Image CreateImageWithBarcode(PdfContentByte cb, BaseColor barColor, BaseColor textColor);
    public virtual void set_AltText(string value);
    public virtual string get_AltText();
    public abstract virtual Image CreateDrawingImage(Color foreground, Color background);
}
public class iTextSharp.text.pdf.Barcode128 : Barcode {
    public static char CODE_AB_TO_C;
    public static char CODE_AC_TO_B;
    public static char CODE_BC_TO_A;
    public static char FNC1_INDEX;
    public static char START_A;
    public static char START_B;
    public static char START_C;
    public static char FNC1;
    public static char DEL;
    public static char FNC3;
    public static char FNC2;
    public static char SHIFT;
    public static char CODE_C;
    public static char CODE_A;
    public static char FNC4;
    public static char STARTA;
    public static char STARTB;
    public static char STARTC;
    private static Byte[][] BARS;
    private static Byte[] BARS_STOP;
    private static IntHashtable ais;
    private Barcode128CodeSet codeSet;
    public Barcode128CodeSet CodeSet { get; public set; }
    public Rectangle BarcodeSize { get; }
    unknown string Code {public set; }
    private static Barcode128();
    public static char GetStartSymbol(Barcode128CodeSet codeSet);
    public virtual Barcode128CodeSet get_CodeSet();
    public virtual void set_CodeSet(Barcode128CodeSet value);
    public static string RemoveFNC1(string code);
    public static string GetHumanReadableUCCEAN(string code);
    internal static bool IsNextDigits(string text, int textIndex, int numDigits);
    internal static string GetPackedRawDigits(string text, int textIndex, int numDigits);
    public static string GetRawText(string text, bool ucc, Barcode128CodeSet codeSet);
    public static string GetRawText(string text, bool ucc);
    public static Byte[] GetBarsCode128Raw(string text);
    public virtual Rectangle get_BarcodeSize();
    public virtual Rectangle PlaceBarcode(PdfContentByte cb, BaseColor barColor, BaseColor textColor);
    public virtual Image CreateDrawingImage(Color foreground, Color background);
    public virtual void set_Code(string value);
}
public class iTextSharp.text.pdf.Barcode39 : Barcode {
    private static string CHARS;
    private static string EXTENDED;
    private static Byte[][] BARS;
    public Rectangle BarcodeSize { get; }
    private static Barcode39();
    public static Byte[] GetBarsCode39(string text);
    public static string GetCode39Ex(string text);
    internal static char GetChecksum(string text);
    public virtual Rectangle get_BarcodeSize();
    public virtual Rectangle PlaceBarcode(PdfContentByte cb, BaseColor barColor, BaseColor textColor);
    public virtual Image CreateDrawingImage(Color foreground, Color background);
}
public class iTextSharp.text.pdf.BarcodeCodabar : Barcode {
    private static string CHARS;
    private static int START_STOP_IDX;
    private static Byte[][] BARS;
    public Rectangle BarcodeSize { get; }
    private static BarcodeCodabar();
    public static Byte[] GetBarsCodabar(string text);
    public static string CalculateChecksum(string code);
    public virtual Rectangle get_BarcodeSize();
    public virtual Rectangle PlaceBarcode(PdfContentByte cb, BaseColor barColor, BaseColor textColor);
    public virtual Image CreateDrawingImage(Color foreground, Color background);
}
public class iTextSharp.text.pdf.BarcodeDatamatrix : object {
    public static int DM_NO_ERROR;
    public static int DM_ERROR_TEXT_TOO_BIG;
    public static int DM_ERROR_INVALID_SQUARE;
    public static int DM_ERROR_EXTENSION;
    public static int DM_AUTO;
    public static int DM_ASCII;
    public static int DM_C40;
    public static int DM_TEXT;
    public static int DM_B256;
    public static int DM_X12;
    public static int DM_X21;
    public static int DM_EDIFACT;
    public static int DM_RAW;
    public static int DM_EXTENSION;
    public static int DM_TEST;
    private static byte LATCH_B256;
    private static byte LATCH_EDIFACT;
    private static byte LATCH_X12;
    private static byte LATCH_TEXT;
    private static byte LATCH_C40;
    private static byte UNLATCH;
    private static byte EXTENDED_ASCII;
    private static byte PADDING;
    public static string DEFAULT_DATA_MATRIX_ENCODING;
    private static string X12;
    private string encoding;
    private static DmParams[] dmSizes;
    private int extOut;
    private Int16[] place;
    private Byte[] image;
    private int height;
    private int width;
    private int ws;
    private int options;
    private bool forceSquareSize;
    private static Int32[][] f;
    private static Int32[][] switchMode;
    public Byte[] BitImage { get; }
    public int Height { get; public set; }
    public int Width { get; public set; }
    public int Ws { get; public set; }
    public int Options { get; public set; }
    unknown bool ForceSquareSize {public set; }
    public BarcodeDatamatrix(string code);
    public BarcodeDatamatrix(string code, string encoding);
    private static BarcodeDatamatrix();
    private void SetBit(int x, int y, int xByte);
    private void Draw(Byte[] data, int dataSize, DmParams dm);
    private static void MakePadding(Byte[] data, int position, int count);
    private static bool IsDigit(int c);
    private static int AsciiEncodation(Byte[] text, int textOffset, int textLength, Byte[] data, int dataOffset, int dataLength, int symbolIndex, int prevEnc, int origDataOffset);
    private static int B256Encodation(Byte[] text, int textOffset, int textLength, Byte[] data, int dataOffset, int dataLength, int symbolIndex, int prevEnc, int origDataOffset);
    private static void RandomizationAlgorithm255(Byte[] data, int j);
    private static int X12Encodation(Byte[] text, int textOffset, int textLength, Byte[] data, int dataOffset, int dataLength, int symbolIndex, int prevEnc, int origDataOffset);
    private static int EdifactEncodation(Byte[] text, int textOffset, int textLength, Byte[] data, int dataOffset, int dataLength, int symbolIndex, int prevEnc, int origDataOffset, bool sizeFixed);
    private static int C40OrTextEncodation(Byte[] text, int textOffset, int textLength, Byte[] data, int dataOffset, int dataLength, bool c40, int symbolIndex, int prevEnc, int origDataOffset);
    private static int MinValueInColumn(Int32[][] array, int column);
    private static int ValuePositionInColumn(Int32[][] array, int column, int value);
    private static void SolveFAndSwitchMode(Int32[] forMin, int mode, int currIndex);
    private static int GetEncodation(Byte[] text, int textOffset, int textSize, Byte[] data, int dataOffset, int dataSize, int options, bool sizeFixed);
    private static int GetNumber(Byte[] text, int ptrIn, int n);
    private int ProcessExtensions(Byte[] text, int textOffset, int textSize, Byte[] data);
    public virtual int Generate(string text);
    public virtual int Generate(string text, string encoding);
    public virtual int Generate(Byte[] text, int textOffset, int textSize);
    public virtual void PlaceBarcode(PdfContentByte cb, BaseColor foreground, float moduleHeight, float moduleWidth);
    public virtual Image CreateImage();
    public virtual Image CreateDrawingImage(Color foreground, Color background);
    public virtual Byte[] get_BitImage();
    public virtual int get_Height();
    public virtual void set_Height(int value);
    public virtual int get_Width();
    public virtual void set_Width(int value);
    public virtual int get_Ws();
    public virtual void set_Ws(int value);
    public virtual int get_Options();
    public virtual void set_Options(int value);
    public virtual void set_ForceSquareSize(bool value);
}
public class iTextSharp.text.pdf.BarcodeEAN : Barcode {
    private static int TOTALBARS_EAN13;
    private static int TOTALBARS_EAN8;
    private static int TOTALBARS_UPCE;
    private static int TOTALBARS_SUPP2;
    private static int TOTALBARS_SUPP5;
    private static byte ODD;
    private static byte EVEN;
    private static Int32[] GUARD_EMPTY;
    private static Int32[] GUARD_UPCA;
    private static Int32[] GUARD_EAN13;
    private static Int32[] GUARD_EAN8;
    private static Int32[] GUARD_UPCE;
    private static Single[] TEXTPOS_EAN13;
    private static Single[] TEXTPOS_EAN8;
    private static Byte[][] BARS;
    private static Byte[][] PARITY13;
    private static Byte[][] PARITY2;
    private static Byte[][] PARITY5;
    private static Byte[][] PARITYE;
    public Rectangle BarcodeSize { get; }
    private static BarcodeEAN();
    public static int CalculateEANParity(string code);
    public static string ConvertUPCAtoUPCE(string text);
    public static Byte[] GetBarsEAN13(string _code);
    public static Byte[] GetBarsEAN8(string _code);
    public static Byte[] GetBarsUPCE(string _code);
    public static Byte[] GetBarsSupplemental2(string _code);
    public static Byte[] GetBarsSupplemental5(string _code);
    public virtual Rectangle get_BarcodeSize();
    public virtual Rectangle PlaceBarcode(PdfContentByte cb, BaseColor barColor, BaseColor textColor);
    public virtual Image CreateDrawingImage(Color foreground, Color background);
}
public class iTextSharp.text.pdf.BarcodeEANSUPP : Barcode {
    protected Barcode ean;
    protected Barcode supp;
    public Rectangle BarcodeSize { get; }
    public BarcodeEANSUPP(Barcode ean, Barcode supp);
    public virtual Rectangle get_BarcodeSize();
    public virtual Rectangle PlaceBarcode(PdfContentByte cb, BaseColor barColor, BaseColor textColor);
    public virtual Image CreateDrawingImage(Color foreground, Color background);
}
public class iTextSharp.text.pdf.BarcodeInter25 : Barcode {
    private static Byte[][] BARS;
    public Rectangle BarcodeSize { get; }
    private static BarcodeInter25();
    public static string KeepNumbers(string text);
    public static char GetChecksum(string text);
    public static Byte[] GetBarsInter25(string text);
    public virtual Rectangle get_BarcodeSize();
    public virtual Rectangle PlaceBarcode(PdfContentByte cb, BaseColor barColor, BaseColor textColor);
    public virtual Image CreateDrawingImage(Color foreground, Color background);
}
public class iTextSharp.text.pdf.BarcodePDF417 : object {
    public static int PDF417_USE_ASPECT_RATIO;
    public static int PDF417_FIXED_RECTANGLE;
    public static int PDF417_FIXED_COLUMNS;
    public static int PDF417_FIXED_ROWS;
    public static int PDF417_AUTO_ERROR_LEVEL;
    public static int PDF417_USE_ERROR_LEVEL;
    public static int PDF417_FORCE_BINARY;
    public static int PDF417_USE_RAW_CODEWORDS;
    public static int PDF417_INVERT_BITMAP;
    public static int PDF417_USE_MACRO;
    protected static int START_PATTERN;
    protected static int STOP_PATTERN;
    protected static int START_CODE_SIZE;
    protected static int STOP_SIZE;
    protected static int MOD;
    protected static int ALPHA;
    protected static int LOWER;
    protected static int MIXED;
    protected static int PUNCTUATION;
    protected static int ISBYTE;
    protected static int BYTESHIFT;
    protected static int PL;
    protected static int LL;
    protected static int AS;
    protected static int ML;
    protected static int AL;
    protected static int PS;
    protected static int PAL;
    protected static int SPACE;
    protected static int TEXT_MODE;
    protected static int BYTE_MODE_6;
    protected static int BYTE_MODE;
    protected static int NUMERIC_MODE;
    protected static int ABSOLUTE_MAX_TEXT_SIZE;
    protected static int MAX_DATA_CODEWORDS;
    protected static int MACRO_SEGMENT_ID;
    protected static int MACRO_LAST_SEGMENT;
    private static string MIXED_SET;
    private static string PUNCTUATION_SET;
    private int macroSegmentCount;
    private int macroSegmentId;
    private string macroFileId;
    private int macroIndex;
    protected int bitPtr;
    protected int cwPtr;
    protected SegmentList segmentList;
    private static Int32[][] CLUSTERS;
    private static Int32[][] ERROR_LEVEL;
    private Byte[] outBits;
    private int bitColumns;
    private int codeRows;
    private int codeColumns;
    private Int32[] codewords;
    private int lenCodewords;
    private int errorLevel;
    private Byte[] text;
    private int options;
    private float aspectRatio;
    private float yHeight;
    unknown int MacroSegmentId {public set; }
    unknown int MacroSegmentCount {public set; }
    unknown string MacroFileId {public set; }
    public Byte[] OutBits { get; }
    public int BitColumns { get; }
    public int CodeRows { get; public set; }
    public int CodeColumns { get; public set; }
    public Int32[] Codewords { get; }
    public int LenCodewords { get; public set; }
    public int ErrorLevel { get; public set; }
    public Byte[] Text { get; public set; }
    public int Options { get; public set; }
    public float AspectRatio { get; public set; }
    public float YHeight { get; public set; }
    private static BarcodePDF417();
    public virtual void set_MacroSegmentId(int value);
    public virtual void set_MacroSegmentCount(int value);
    public virtual void set_MacroFileId(string value);
    protected virtual bool CheckSegmentType(Segment segment, char type);
    protected virtual int GetSegmentLength(Segment segment);
    public virtual void SetDefaultParameters();
    protected virtual void OutCodeword17(int codeword);
    protected virtual void OutCodeword18(int codeword);
    protected virtual void OutCodeword(int codeword);
    protected virtual void OutStopPattern();
    protected virtual void OutStartPattern();
    protected virtual void OutPaintCode();
    protected virtual void CalculateErrorCorrection(int dest);
    private static int GetTextTypeAndValue(Byte[] input, int maxLength, int idx);
    protected virtual int GetTextTypeAndValue(int maxLength, int idx);
    private void TextCompaction(Byte[] input, int start, int length);
    protected virtual void TextCompaction(int start, int length);
    protected virtual void BasicNumberCompaction(int start, int length);
    private void BasicNumberCompaction(Byte[] input, int start, int length);
    private void NumberCompaction(Byte[] input, int start, int length);
    protected virtual void NumberCompaction(int start, int length);
    protected virtual void ByteCompaction6(int start);
    internal void ByteCompaction(int start, int length);
    internal void BreakString();
    protected virtual void Assemble();
    private void MacroCodes();
    private void Append(int inp, int len);
    private void Append(string s);
    protected static int MaxPossibleErrorLevel(int remain);
    protected virtual void DumpList();
    protected virtual int GetMaxSquare();
    public virtual void PaintCode();
    public virtual Image GetImage();
    public virtual Image CreateDrawingImage(Color foreground, Color background);
    public virtual Byte[] get_OutBits();
    public virtual int get_BitColumns();
    public virtual void set_CodeRows(int value);
    public virtual int get_CodeRows();
    public virtual void set_CodeColumns(int value);
    public virtual int get_CodeColumns();
    public virtual Int32[] get_Codewords();
    public virtual void set_LenCodewords(int value);
    public virtual int get_LenCodewords();
    public virtual void set_ErrorLevel(int value);
    public virtual int get_ErrorLevel();
    public virtual void set_Text(Byte[] value);
    public virtual Byte[] get_Text();
    public virtual void SetText(string s);
    public virtual void set_Options(int value);
    public virtual int get_Options();
    public virtual void set_AspectRatio(float value);
    public virtual float get_AspectRatio();
    public virtual void set_YHeight(float value);
    public virtual float get_YHeight();
    public virtual void PlaceBarcode(PdfContentByte cb, BaseColor foreground, float moduleHeight, float moduleWidth);
    public virtual Rectangle GetBarcodeSize();
}
public class iTextSharp.text.pdf.BarcodePostnet : Barcode {
    private static Byte[][] BARS;
    public Rectangle BarcodeSize { get; }
    private static BarcodePostnet();
    public static Byte[] GetBarsPostnet(string text);
    public virtual Rectangle get_BarcodeSize();
    public virtual Rectangle PlaceBarcode(PdfContentByte cb, BaseColor barColor, BaseColor textColor);
    public virtual Image CreateDrawingImage(Color foreground, Color background);
}
public class iTextSharp.text.pdf.BarcodeQRCode : object {
    private ByteMatrix bm;
    public BarcodeQRCode(string content, int width, int height, IDictionary`2<EncodeHintType, object> hints);
    private Byte[] GetBitMatrix();
    public virtual Image GetImage();
    public void PlaceBarcode(PdfContentByte cb, BaseColor foreground, float moduleSide);
    public Rectangle GetBarcodeSize();
}
public abstract class iTextSharp.text.pdf.BaseField : object {
    public static float BORDER_WIDTH_THIN;
    public static float BORDER_WIDTH_MEDIUM;
    public static float BORDER_WIDTH_THICK;
    public static int VISIBLE;
    public static int HIDDEN;
    public static int VISIBLE_BUT_DOES_NOT_PRINT;
    public static int HIDDEN_BUT_PRINTABLE;
    public static int READ_ONLY;
    public static int REQUIRED;
    public static int MULTILINE;
    public static int DO_NOT_SCROLL;
    public static int PASSWORD;
    public static int FILE_SELECTION;
    public static int DO_NOT_SPELL_CHECK;
    public static int EDIT;
    public static int MULTISELECT;
    public static int COMB;
    protected float borderWidth;
    protected int borderStyle;
    protected BaseColor borderColor;
    protected BaseColor backgroundColor;
    protected BaseColor textColor;
    protected BaseFont font;
    protected float fontSize;
    protected int alignment;
    protected PdfWriter writer;
    protected string text;
    protected Rectangle box;
    protected int rotation;
    protected int visibility;
    protected string fieldName;
    protected int options;
    protected int maxCharacterLength;
    private static Dictionary`2<PdfName, int> fieldKeys;
    protected BaseFont RealFont { get; }
    public float BorderWidth { get; public set; }
    public int BorderStyle { get; public set; }
    public BaseColor BorderColor { get; public set; }
    public BaseColor BackgroundColor { get; public set; }
    public BaseColor TextColor { get; public set; }
    public BaseFont Font { get; public set; }
    public float FontSize { get; public set; }
    public int Alignment { get; public set; }
    public string Text { get; public set; }
    public Rectangle Box { get; public set; }
    public int Rotation { get; public set; }
    public int Visibility { get; public set; }
    public string FieldName { get; public set; }
    public int Options { get; public set; }
    public int MaxCharacterLength { get; public set; }
    public PdfWriter Writer { get; public set; }
    private static BaseField();
    public BaseField(PdfWriter writer, Rectangle box, string fieldName);
    protected virtual BaseFont get_RealFont();
    protected virtual PdfAppearance GetBorderAppearance();
    protected static List`1<string> GetHardBreaks(string text);
    protected static void TrimRight(StringBuilder buf);
    protected static List`1<string> BreakLines(List`1<string> breaks, BaseFont font, float fontSize, float width);
    private void DrawTopFrame(PdfAppearance app);
    private void DrawBottomFrame(PdfAppearance app);
    public virtual void set_BorderWidth(float value);
    public virtual float get_BorderWidth();
    public virtual void set_BorderStyle(int value);
    public virtual int get_BorderStyle();
    public virtual void set_BorderColor(BaseColor value);
    public virtual BaseColor get_BorderColor();
    public virtual void set_BackgroundColor(BaseColor value);
    public virtual BaseColor get_BackgroundColor();
    public virtual void set_TextColor(BaseColor value);
    public virtual BaseColor get_TextColor();
    public virtual void set_Font(BaseFont value);
    public virtual BaseFont get_Font();
    public virtual void set_FontSize(float value);
    public virtual float get_FontSize();
    public virtual void set_Alignment(int value);
    public virtual int get_Alignment();
    public virtual void set_Text(string value);
    public virtual string get_Text();
    public virtual void set_Box(Rectangle value);
    public virtual Rectangle get_Box();
    public virtual void set_Rotation(int value);
    public virtual int get_Rotation();
    public virtual void SetRotationFromPage(Rectangle page);
    public virtual void set_Visibility(int value);
    public virtual int get_Visibility();
    public virtual void set_FieldName(string value);
    public virtual string get_FieldName();
    public virtual void set_Options(int value);
    public virtual int get_Options();
    public virtual void set_MaxCharacterLength(int value);
    public virtual int get_MaxCharacterLength();
    public virtual PdfWriter get_Writer();
    public virtual void set_Writer(PdfWriter value);
    public static void MoveFields(PdfDictionary from, PdfDictionary to);
}
public abstract class iTextSharp.text.pdf.BaseFont : object {
    public static string COURIER;
    public static string COURIER_BOLD;
    public static string COURIER_OBLIQUE;
    public static string COURIER_BOLDOBLIQUE;
    public static string HELVETICA;
    public static string HELVETICA_BOLD;
    public static string HELVETICA_OBLIQUE;
    public static string HELVETICA_BOLDOBLIQUE;
    public static string SYMBOL;
    public static string TIMES_ROMAN;
    public static string TIMES_BOLD;
    public static string TIMES_ITALIC;
    public static string TIMES_BOLDITALIC;
    public static string ZAPFDINGBATS;
    public static int ASCENT;
    public static int CAPHEIGHT;
    public static int DESCENT;
    public static int ITALICANGLE;
    public static int BBOXLLX;
    public static int BBOXLLY;
    public static int BBOXURX;
    public static int BBOXURY;
    public static int AWT_ASCENT;
    public static int AWT_DESCENT;
    public static int AWT_LEADING;
    public static int AWT_MAXADVANCE;
    public static int UNDERLINE_POSITION;
    public static int UNDERLINE_THICKNESS;
    public static int STRIKETHROUGH_POSITION;
    public static int STRIKETHROUGH_THICKNESS;
    public static int SUBSCRIPT_SIZE;
    public static int SUBSCRIPT_OFFSET;
    public static int SUPERSCRIPT_SIZE;
    public static int SUPERSCRIPT_OFFSET;
    public static int WEIGHT_CLASS;
    public static int WIDTH_CLASS;
    public static int FONT_WEIGHT;
    public static int FONT_TYPE_T1;
    public static int FONT_TYPE_TT;
    public static int FONT_TYPE_CJK;
    public static int FONT_TYPE_TTUNI;
    public static int FONT_TYPE_DOCUMENT;
    public static int FONT_TYPE_T3;
    public static string IDENTITY_H;
    public static string IDENTITY_V;
    public static string CP1250;
    public static string CP1252;
    public static string CP1257;
    public static string WINANSI;
    public static string MACROMAN;
    public static bool EMBEDDED;
    public static bool NOT_EMBEDDED;
    public static bool CACHED;
    public static bool NOT_CACHED;
    public static string RESOURCE_PATH;
    public static char CID_NEWLINE;
    public static char PARAGRAPH_SEPARATOR;
    public static string notdef;
    public static Int32[] CHAR_RANGE_LATIN;
    public static Int32[] CHAR_RANGE_ARABIC;
    public static Int32[] CHAR_RANGE_HEBREW;
    public static Int32[] CHAR_RANGE_CYRILLIC;
    public static Double[] DEFAULT_FONT_MATRIX;
    protected List`1<Int32[]> subsetRanges;
    internal int fontType;
    protected Int32[] widths;
    protected String[] differences;
    protected Char[] unicodeDifferences;
    protected Int32[][] charBBoxes;
    protected string encoding;
    protected bool embedded;
    protected int compressionLevel;
    protected bool fontSpecific;
    protected static Dictionary`2<string, BaseFont> fontCache;
    protected static Dictionary`2<string, PdfName> BuiltinFonts14;
    protected bool forceWidthsOutput;
    protected bool directTextToByte;
    protected bool subset;
    protected bool fastWinansi;
    protected IntHashtable specialMap;
    private static Random random;
    protected bool vertical;
    public List`1<Int32[]> SubsetRanges { get; }
    public string Encoding { get; }
    public int FontType { get; public set; }
    public string PostscriptFontName { get; public set; }
    public string Subfamily { get; }
    public String[][] FullFontName { get; }
    public String[][] AllNameEntries { get; }
    public String[][] FamilyFontName { get; }
    public String[] CodePagesSupported { get; }
    public Int32[] Widths { get; }
    public String[] Differences { get; }
    public Char[] UnicodeDifferences { get; }
    public bool ForceWidthsOutput { get; public set; }
    public bool DirectTextToByte { get; public set; }
    public bool Subset { get; public set; }
    public int CompressionLevel { get; public set; }
    private static BaseFont();
    public virtual List`1<Int32[]> get_SubsetRanges();
    public static BaseFont CreateFont();
    public static BaseFont CreateFont(string name, string encoding, bool embedded);
    public static BaseFont CreateFont(string name, string encoding, bool embedded, bool forceRead);
    public static BaseFont CreateFont(string name, string encoding, bool embedded, bool cached, Byte[] ttfAfm, Byte[] pfb);
    public static BaseFont CreateFont(string name, string encoding, bool embedded, bool cached, Byte[] ttfAfm, Byte[] pfb, bool noThrow);
    public static BaseFont CreateFont(string name, string encoding, bool embedded, bool cached, Byte[] ttfAfm, Byte[] pfb, bool noThrow, bool forceRead);
    public static BaseFont CreateFont(PRIndirectReference fontRef);
    public virtual bool IsVertical();
    protected static string GetBaseName(string name);
    protected static string NormalizeEncoding(string enc);
    protected virtual void CreateEncoding();
    internal abstract virtual int GetRawWidth(int c, string name);
    public abstract virtual int GetKerning(int char1, int char2);
    public abstract virtual bool SetKerning(int char1, int char2, int kern);
    public virtual int GetWidth(int char1);
    public virtual int GetWidth(string text);
    public virtual int GetDescent(string text);
    public virtual int GetAscent(string text);
    public virtual float GetDescentPoint(string text, float fontSize);
    public virtual float GetAscentPoint(string text, float fontSize);
    public virtual float GetWidthPointKerned(string text, float fontSize);
    public virtual float GetWidthPoint(string text, float fontSize);
    public virtual float GetWidthPoint(int char1, float fontSize);
    public virtual Byte[] ConvertToBytes(string text);
    internal virtual Byte[] ConvertToBytes(int char1);
    internal abstract virtual void WriteFont(PdfWriter writer, PdfIndirectReference piRef, Object[] oParams);
    public abstract virtual PdfStream GetFullFontStream();
    public virtual string get_Encoding();
    public abstract virtual float GetFontDescriptor(int key, float fontSize);
    public virtual void SetFontDescriptor(int key, float value);
    public virtual int get_FontType();
    public virtual void set_FontType(int value);
    public virtual bool IsEmbedded();
    public virtual bool IsFontSpecific();
    public static string CreateSubsetPrefix();
    internal char GetUnicodeDifferences(int index);
    public abstract virtual string get_PostscriptFontName();
    public abstract virtual void set_PostscriptFontName(string value);
    public virtual string get_Subfamily();
    public abstract virtual String[][] get_FullFontName();
    public abstract virtual String[][] get_AllNameEntries();
    public static String[][] GetFullFontName(string name, string encoding, Byte[] ttfAfm);
    public static Object[] GetAllFontNames(string name, string encoding, Byte[] ttfAfm);
    public static String[][] GetAllNameEntries(string name, string encoding, Byte[] ttfAfm);
    public abstract virtual String[][] get_FamilyFontName();
    public virtual String[] get_CodePagesSupported();
    public static String[] EnumerateTTCNames(string ttcFile);
    public static String[] EnumerateTTCNames(Byte[] ttcArray);
    public virtual Int32[] get_Widths();
    public virtual String[] get_Differences();
    public virtual Char[] get_UnicodeDifferences();
    public virtual void set_ForceWidthsOutput(bool value);
    public virtual bool get_ForceWidthsOutput();
    public virtual void set_DirectTextToByte(bool value);
    public virtual bool get_DirectTextToByte();
    public virtual void set_Subset(bool value);
    public virtual bool get_Subset();
    public virtual int GetUnicodeEquivalent(int c);
    public virtual int GetCidCode(int c);
    public abstract virtual bool HasKernPairs();
    public virtual bool CharExists(int c);
    public virtual bool SetCharAdvance(int c, int advance);
    private static void AddFont(PRIndirectReference fontRef, IntHashtable hits, List`1<Object[]> fonts);
    private static void RecourseFonts(PdfDictionary page, IntHashtable hits, List`1<Object[]> fonts, int level, HashSet2`1<PdfDictionary> visitedResources);
    public static List`1<Object[]> GetDocumentFonts(PdfReader reader);
    public static List`1<Object[]> GetDocumentFonts(PdfReader reader, int page);
    internal static PdfDictionary createBuiltInFontDictionary(string name);
    private static PdfDictionary createBuiltInFontDictionary(PdfName name);
    public virtual Int32[] GetCharBBox(int c);
    public virtual Double[] GetFontMatrix();
    protected abstract virtual Int32[] GetRawCharBBox(int c, string name);
    public virtual void CorrectArabicAdvance();
    public virtual void AddSubsetRange(Int32[] range);
    public virtual void set_CompressionLevel(int value);
    public virtual int get_CompressionLevel();
}
public class iTextSharp.text.pdf.BidiLine : object {
    private static int pieceSizeStart;
    protected int runDirection;
    protected int pieceSize;
    protected Char[] text;
    protected PdfChunk[] detailChunks;
    protected int totalTextLength;
    protected Byte[] orderLevels;
    protected Int32[] indexChars;
    protected internal List`1<PdfChunk> chunks;
    protected int indexChunk;
    protected int indexChunkChar;
    protected int currentChar;
    protected int storedRunDirection;
    protected Char[] storedText;
    protected PdfChunk[] storedDetailChunks;
    protected int storedTotalTextLength;
    protected Byte[] storedOrderLevels;
    protected Int32[] storedIndexChars;
    protected int storedIndexChunk;
    protected int storedIndexChunkChar;
    protected int storedCurrentChar;
    protected bool isWordSplit;
    protected bool shortStore;
    protected static IntHashtable mirrorChars;
    protected int arabicOptions;
    public BidiLine(BidiLine org);
    private static BidiLine();
    public virtual bool IsEmpty();
    public virtual void ClearChunks();
    public virtual bool GetParagraph(int runDirection);
    public virtual void AddChunk(PdfChunk chunk);
    public virtual void AddChunks(List`1<PdfChunk> chunks);
    public virtual void AddPiece(char c, PdfChunk chunk);
    public virtual void Save();
    public virtual void Restore();
    public virtual void MirrorGlyphs();
    public virtual void DoArabicShapping();
    public virtual PdfLine ProcessLine(float leftX, float width, int alignment, int runDirection, int arabicOptions, float minY, float yLine, float descender);
    private float ProcessTabStop(TabStop tabStop, float tabPosition, float originalWidth, float width, float tabStopAnchorPosition, bool isRTL, IList`1<TabStop> rtlTabsToBeAligned);
    public virtual bool IsWordSplit();
    public virtual float GetWidth(int startIdx, int lastIdx);
    public virtual float GetWidth(int startIdx, int lastIdx, float originalWidth);
    public virtual List`1<PdfChunk> CreateArrayOfPdfChunks(int startIdx, int endIdx);
    public virtual List`1<PdfChunk> CreateArrayOfPdfChunks(int startIdx, int endIdx, PdfChunk extraPdfChunk);
    public virtual Int32[] GetWord(int startIdx, int idx);
    public virtual int TrimRight(int startIdx, int endIdx);
    public virtual int TrimLeft(int startIdx, int endIdx);
    public virtual int TrimRightEx(int startIdx, int endIdx);
    public virtual int TrimLeftEx(int startIdx, int endIdx);
    public virtual void Reorder(int start, int end);
    public virtual void Flip(int start, int end);
    public static bool IsWS(char c);
    public static string ProcessLTR(string s, int runDirection, int arabicOptions);
}
public class iTextSharp.text.pdf.BidiOrder : object {
    public static sbyte L;
    public static sbyte LRE;
    public static sbyte LRO;
    public static sbyte R;
    public static sbyte AL;
    public static sbyte RLE;
    public static sbyte RLO;
    public static sbyte PDF;
    public static sbyte EN;
    public static sbyte ES;
    public static sbyte ET;
    public static sbyte AN;
    public static sbyte CS;
    public static sbyte NSM;
    public static sbyte BN;
    public static sbyte B;
    public static sbyte S;
    public static sbyte WS;
    public static sbyte ON;
    public static sbyte TYPE_MIN;
    public static sbyte TYPE_MAX;
    private SByte[] initialTypes;
    private SByte[] embeddings;
    private sbyte paragraphEmbeddingLevel;
    private int textLength;
    private SByte[] resultTypes;
    private SByte[] resultLevels;
    private static SByte[] rtypes;
    private static Char[] baseTypes;
    public BidiOrder(SByte[] types);
    public BidiOrder(SByte[] types, sbyte paragraphEmbeddingLevel);
    public BidiOrder(Char[] text, int offset, int length, sbyte paragraphEmbeddingLevel);
    private static BidiOrder();
    public static sbyte GetDirection(char c);
    private void RunAlgorithm();
    private void DetermineParagraphEmbeddingLevel();
    private void DetermineExplicitEmbeddingLevels();
    private int RemoveExplicitCodes();
    private int ReinsertExplicitCodes(int textLength);
    private static SByte[] ProcessEmbeddings(SByte[] resultTypes, sbyte paragraphEmbeddingLevel);
    private void ResolveWeakTypes(int start, int limit, sbyte level, sbyte sor, sbyte eor);
    private void ResolveNeutralTypes(int start, int limit, sbyte level, sbyte sor, sbyte eor);
    private void ResolveImplicitLevels(int start, int limit, sbyte level, sbyte sor, sbyte eor);
    public Byte[] GetLevels();
    public Byte[] GetLevels(Int32[] linebreaks);
    private static Int32[] ComputeMultilineReordering(SByte[] levels, Int32[] linebreaks);
    private static Int32[] ComputeReordering(SByte[] levels);
    public sbyte GetBaseLevel();
    private static bool IsWhitespace(sbyte biditype);
    private static sbyte TypeForLevel(int level);
    private int FindRunLimit(int index, int limit, SByte[] validSet);
    private int FindRunStart(int index, SByte[] validSet);
    private void SetTypes(int start, int limit, sbyte newType);
    private void SetLevels(int start, int limit, sbyte newLevel);
    private static void ValidateTypes(SByte[] types);
    private static void ValidateParagraphEmbeddingLevel(sbyte paragraphEmbeddingLevel);
    private static void ValidateLineBreaks(Int32[] linebreaks, int textLength);
}
public class iTextSharp.text.pdf.ByteBuffer : Stream {
    public static byte ZERO;
    protected int count;
    protected Byte[] buf;
    private static int byteCacheSize;
    private static Byte[][] byteCache;
    private static Char[] chars;
    private static Byte[] bytes;
    public static bool HIGH_PRECISION;
    public int Size { get; public set; }
    public Byte[] Buffer { get; }
    public bool CanRead { get; }
    public bool CanSeek { get; }
    public bool CanWrite { get; }
    public long Length { get; }
    public long Position { get; public set; }
    public ByteBuffer(int size);
    private static ByteBuffer();
    public static void SetCacheSize(int size);
    public static void FillCache(int decimals);
    private static Byte[] ConvertToBytes(int i);
    public virtual ByteBuffer Append_i(int b);
    public virtual ByteBuffer Append(Byte[] b, int off, int len);
    public virtual ByteBuffer Append(Byte[] b);
    public virtual ByteBuffer Append(string str);
    public virtual ByteBuffer Append(char c);
    public virtual ByteBuffer Append(ByteBuffer buf);
    public virtual ByteBuffer Append(int i);
    public virtual ByteBuffer Append(long i);
    public virtual ByteBuffer Append(byte b);
    public virtual ByteBuffer AppendHex(byte b);
    public virtual ByteBuffer Append(float i);
    public virtual ByteBuffer Append(double d);
    public static string FormatDouble(double d);
    public static string FormatDouble(double d, ByteBuffer buf);
    public virtual void Reset();
    public virtual Byte[] ToByteArray();
    public virtual int get_Size();
    public virtual void set_Size(int value);
    public virtual string ToString();
    public virtual void WriteTo(Stream str);
    private Char[] ConvertToChar(Byte[] buf);
    public virtual Byte[] get_Buffer();
    public virtual bool get_CanRead();
    public virtual bool get_CanSeek();
    public virtual bool get_CanWrite();
    public virtual long get_Length();
    public virtual long get_Position();
    public virtual void set_Position(long value);
    public virtual void Flush();
    public virtual int Read(Byte[] buffer, int offset, int count);
    public virtual long Seek(long offset, SeekOrigin origin);
    public virtual void SetLength(long value);
    public virtual void Write(Byte[] buffer, int offset, int count);
    public virtual void WriteByte(byte value);
}
public class iTextSharp.text.pdf.CFFFont : object {
    internal static String[] operatorNames;
    internal static String[] standardStrings;
    internal int nextIndexOffset;
    protected string key;
    protected Object[] args;
    protected int arg_count;
    protected RandomAccessFileOrArray buf;
    private int offSize;
    protected int nameIndexOffset;
    protected int topdictIndexOffset;
    protected int stringIndexOffset;
    protected int gsubrIndexOffset;
    protected Int32[] nameOffsets;
    protected Int32[] topdictOffsets;
    protected Int32[] stringOffsets;
    protected Int32[] gsubrOffsets;
    protected Font[] fonts;
    public CFFFont(RandomAccessFileOrArray inputbuffer);
    private static CFFFont();
    public virtual string GetString(char sid);
    internal char GetCard8();
    internal char GetCard16();
    internal int GetOffset(int offSize);
    internal void Seek(int offset);
    internal short GetShort();
    internal int GetInt();
    internal int GetPosition();
    internal Int32[] GetIndex(int nextIndexOffset);
    protected virtual void GetDictItem();
    protected virtual RangeItem GetEntireIndexRange(int indexOffset);
    public virtual Byte[] GetCID(string fontName);
    public virtual bool IsCID(string fontName);
    public virtual bool Exists(string fontName);
    public virtual String[] GetNames();
    internal void ReadEncoding(int nextIndexOffset);
}
public class iTextSharp.text.pdf.CFFFontSubset : CFFFont {
    internal static byte ENDCHAR_OP;
    internal static byte RETURN_OP;
    internal static String[] SubrsFunctions;
    internal static String[] SubrsEscapeFuncs;
    internal Dictionary`2<int, Int32[]> GlyphsUsed;
    internal List`1<int> glyphsInList;
    internal Dictionary`2<int, object> FDArrayUsed;
    internal Dictionary`2[] hSubrsUsed;
    internal List`1[] lSubrsUsed;
    internal Dictionary`2<int, Int32[]> hGSubrsUsed;
    internal List`1<int> lGSubrsUsed;
    internal Dictionary`2<int, Int32[]> hSubrsUsedNonCID;
    internal List`1<int> lSubrsUsedNonCID;
    internal Byte[][] NewLSubrsIndex;
    internal Byte[] NewSubrsIndexNonCID;
    internal Byte[] NewGSubrsIndex;
    internal Byte[] NewCharStringsIndex;
    internal int GBias;
    internal List`1<Item> OutputList;
    internal int NumOfHints;
    public CFFFontSubset(RandomAccessFileOrArray rf, Dictionary`2<int, Int32[]> GlyphsUsed);
    private static CFFFontSubset();
    internal int CountCharset(int Offset, int NumofGlyphs);
    private int CountRange(int NumofGlyphs, int Type);
    protected virtual void ReadFDSelect(int Font);
    protected virtual void BuildFDArrayUsed(int Font);
    protected virtual void ReadFDArray(int Font);
    public virtual Byte[] Process(string fontName);
    protected virtual int CalcBias(int Offset, int Font);
    protected virtual void BuildNewCharString(int FontIndex);
    protected virtual void BuildNewLGSubrs(int Font);
    protected virtual void BuildFDSubrsOffsets(int Font, int FD);
    protected virtual void BuildSubrUsed(int Font, int FD, int SubrOffset, Int32[] SubrsOffsets, Dictionary`2<int, Int32[]> hSubr, List`1<int> lSubr);
    protected virtual void BuildGSubrsUsed(int Font);
    protected virtual void ReadASubr(int begin, int end, int GBias, int LBias, Dictionary`2<int, Int32[]> hSubr, List`1<int> lSubr, Int32[] LSubrsOffsets);
    protected virtual void HandelStack();
    protected virtual int StackOpp();
    protected virtual void EmptyStack();
    protected virtual void PopStack();
    protected virtual void PushStack();
    protected virtual void ReadCommand();
    protected virtual int CalcHints(int begin, int end, int LBias, int GBias, Int32[] LSubrsOffsets);
    protected virtual Byte[] BuildNewIndex(Int32[] Offsets, Dictionary`2<int, Int32[]> Used, byte OperatorForUnusedEntries);
    protected virtual Byte[] BuildNewIndexAndCopyAllGSubrs(Int32[] Offsets, byte OperatorForUnusedEntries);
    protected virtual Byte[] AssembleIndex(Int32[] NewOffsets, Byte[] NewObjects);
    protected virtual Byte[] BuildNewFile(int Font);
    protected virtual void CopyHeader();
    protected virtual void BuildIndexHeader(int Count, int Offsize, int First);
    protected virtual void CreateKeys(OffsetItem fdarrayRef, OffsetItem fdselectRef, OffsetItem charsetRef, OffsetItem charstringsRef);
    protected virtual void CreateNewStringIndex(int Font);
    protected virtual void CreateFDSelect(OffsetItem fdselectRef, int nglyphs);
    protected virtual void CreateCharset(OffsetItem charsetRef, int nglyphs);
    protected virtual void CreateFDArray(OffsetItem fdarrayRef, OffsetItem privateRef, int Font);
    private void Reconstruct(int Font);
    private void ReconstructFDArray(int Font, OffsetItem[] fdPrivate);
    internal void ReconstructPrivateDict(int Font, OffsetItem[] fdPrivate, IndexBaseItem[] fdPrivateBase, OffsetItem[] fdSubrs);
    internal void ReconstructPrivateSubrs(int Font, IndexBaseItem[] fdPrivateBase, OffsetItem[] fdSubrs);
    internal int CalcSubrOffsetSize(int Offset, int Size);
    protected virtual int CountEntireIndexRange(int indexOffset);
    internal void CreateNonCIDPrivate(int Font, OffsetItem Subr);
    internal void CreateNonCIDSubrs(int Font, IndexBaseItem PrivateBase, OffsetItem Subrs);
}
internal class iTextSharp.text.pdf.CJKFont : BaseFont {
    internal static string CJK_ENCODING;
    private static int FIRST;
    private static int BRACKET;
    private static int SERIAL;
    private static int V1Y;
    public static string RESOURCE_PATH_CMAP;
    internal static Properties cjkFonts;
    internal static Properties cjkEncodings;
    private static Dictionary`2<string, Dictionary`2<string, object>> allFonts;
    private static bool propertiesLoaded;
    private static Dictionary`2<string, Dictionary`2<string, object>> registryNames;
    private CMapCidByte cidByte;
    private CMapUniCid uniCid;
    private CMapCidUni cidUni;
    private string uniMap;
    private string fontName;
    private string style;
    private string CMap;
    private bool cidDirect;
    private IntHashtable vMetrics;
    private IntHashtable hMetrics;
    private Dictionary`2<string, object> fontDesc;
    private static Char[] cspace;
    internal string UniMap { get; }
    public string PostscriptFontName { get; public set; }
    public String[][] FullFontName { get; }
    public String[][] AllNameEntries { get; }
    public String[][] FamilyFontName { get; }
    internal CJKFont(string fontName, string enc, bool emb);
    private static CJKFont();
    private static void LoadProperties();
    private static void LoadRegistry();
    internal string get_UniMap();
    private void LoadCMaps();
    public static string GetCompatibleFont(string enc);
    public static bool IsCJKFont(string fontName, string enc);
    public virtual int GetWidth(int char1);
    public virtual int GetWidth(string text);
    internal virtual int GetRawWidth(int c, string name);
    public virtual int GetKerning(int char1, int char2);
    private PdfDictionary GetFontDescriptor();
    private PdfDictionary GetCIDFont(PdfIndirectReference fontDescriptor, IntHashtable cjkTag);
    private PdfDictionary GetFontBaseType(PdfIndirectReference CIDFont);
    internal virtual void WriteFont(PdfWriter writer, PdfIndirectReference piref, Object[] parms);
    public virtual PdfStream GetFullFontStream();
    private float GetDescNumber(string name);
    private float GetBBox(int idx);
    public virtual float GetFontDescriptor(int key, float fontSize);
    public virtual string get_PostscriptFontName();
    public virtual void set_PostscriptFontName(string value);
    public virtual String[][] get_FullFontName();
    public virtual String[][] get_AllNameEntries();
    public virtual String[][] get_FamilyFontName();
    internal static IntHashtable CreateMetric(string s);
    internal static string ConvertToHCIDMetrics(Int32[] keys, IntHashtable h);
    internal static string ConvertToVCIDMetrics(Int32[] keys, IntHashtable v, IntHashtable h);
    internal static Dictionary`2<string, object> ReadFontProperties(string name);
    public virtual int GetUnicodeEquivalent(int c);
    public virtual int GetCidCode(int c);
    public virtual bool HasKernPairs();
    public virtual bool CharExists(int c);
    public virtual bool SetCharAdvance(int c, int advance);
    public virtual bool SetKerning(int char1, int char2, int kern);
    public virtual Int32[] GetCharBBox(int c);
    protected virtual Int32[] GetRawCharBBox(int c, string name);
    public virtual Byte[] ConvertToBytes(string text);
    internal virtual Byte[] ConvertToBytes(int char1);
    public virtual bool IsIdentity();
}
public class iTextSharp.text.pdf.CMapAwareDocumentFont : DocumentFont {
    private static ILogger LOGGER;
    private PdfDictionary fontDic;
    private int spaceWidth;
    private CMapToUnicode toUnicodeCmap;
    private CMapByteCid byteCid;
    private CMapCidUni cidUni;
    private Char[] cidbyte2uni;
    private IDictionary`2<int, int> uni2cid;
    public CMapAwareDocumentFont(PdfDictionary font);
    public CMapAwareDocumentFont(PRIndirectReference refFont);
    private static CMapAwareDocumentFont();
    private void InitFont();
    private void ProcessToUnicode();
    private void ProcessUni2Byte();
    private int ComputeAverageWidth();
    public virtual int GetWidth(int char1);
    private string DecodeSingleCID(Byte[] bytes, int offset, int len);
    public virtual string Decode(Byte[] cidbytes, int offset, int len);
    public virtual string DecodeSingleCharacter(Byte[] cidbytes, int offset, int len);
    public virtual string Encode(Byte[] bytes, int offset, int len);
}
public class iTextSharp.text.pdf.CMYKColor : ExtendedColor {
    private float ccyan;
    private float cmagenta;
    private float cyellow;
    private float cblack;
    public float Cyan { get; }
    public float Magenta { get; }
    public float Yellow { get; }
    public float Black { get; }
    public CMYKColor(int intCyan, int intMagenta, int intYellow, int intBlack);
    public CMYKColor(float floatCyan, float floatMagenta, float floatYellow, float floatBlack);
    public virtual float get_Cyan();
    public virtual float get_Magenta();
    public virtual float get_Yellow();
    public virtual float get_Black();
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
}
public class iTextSharp.text.pdf.codec.BitFile : object {
    private Stream output_;
    private Byte[] buffer_;
    private int index_;
    private int bitsLeft_;
    private bool blocks_;
    public BitFile(Stream output, bool blocks);
    public virtual void Flush();
    public virtual void WriteBits(int bits, int numbits);
}
public class iTextSharp.text.pdf.codec.BmpImage : object {
    private static int VERSION_2_1_BIT;
    private static int VERSION_2_4_BIT;
    private static int VERSION_2_8_BIT;
    private static int VERSION_2_24_BIT;
    private static int VERSION_3_1_BIT;
    private static int VERSION_3_4_BIT;
    private static int VERSION_3_8_BIT;
    private static int VERSION_3_24_BIT;
    private static int VERSION_3_NT_16_BIT;
    private static int VERSION_3_NT_32_BIT;
    private static int VERSION_4_1_BIT;
    private static int VERSION_4_4_BIT;
    private static int VERSION_4_8_BIT;
    private static int VERSION_4_16_BIT;
    private static int VERSION_4_24_BIT;
    private static int VERSION_4_32_BIT;
    private static int LCS_CALIBRATED_RGB;
    private static int LCS_sRGB;
    private static int LCS_CMYK;
    private static int BI_RGB;
    private static int BI_RLE8;
    private static int BI_RLE4;
    private static int BI_BITFIELDS;
    private Stream inputStream;
    private long bitmapFileSize;
    private long bitmapOffset;
    private long compression;
    private long imageSize;
    private Byte[] palette;
    private int imageType;
    private int numBands;
    private bool isBottomUp;
    private int bitsPerPixel;
    private int redMask;
    private int greenMask;
    private int blueMask;
    private int alphaMask;
    public Dictionary`2<string, object> properties;
    private long xPelsPerMeter;
    private long yPelsPerMeter;
    private int width;
    private int height;
    internal BmpImage(Stream isp, bool noHeader, int size);
    public static Image GetImage(Uri url);
    public static Image GetImage(Stream isp);
    public static Image GetImage(Stream isp, bool noHeader, int size);
    public static Image GetImage(string file);
    public static Image GetImage(Byte[] data);
    protected virtual void Process(Stream stream, bool noHeader);
    private Byte[] GetPalette(int group);
    private Image GetImage();
    private Image IndexedModel(Byte[] bdata, int bpc, int paletteEntries);
    private void ReadPalette(int sizeOfPalette);
    private Image Read1Bit(int paletteEntries);
    private Image Read4Bit(int paletteEntries);
    private Image Read8Bit(int paletteEntries);
    private void Read24Bit(Byte[] bdata);
    private int FindMask(int mask);
    private int FindShift(int mask);
    private Image Read1632Bit(bool is32);
    private Image ReadRLE8();
    private Image ReadRLE4();
    private Byte[] DecodeRLE(bool is8, Byte[] values);
    private int ReadUnsignedByte(Stream stream);
    private int ReadUnsignedShort(Stream stream);
    private int ReadShort(Stream stream);
    private int ReadWord(Stream stream);
    private long ReadUnsignedInt(Stream stream);
    private int ReadInt(Stream stream);
    private long ReadDWord(Stream stream);
    private int ReadLong(Stream stream);
}
public class iTextSharp.text.pdf.codec.CCITTG4Encoder : object {
    private static int LENGTH;
    private static int CODE;
    private static int RUNLEN;
    private static int EOL;
    private static int G3CODE_EOL;
    private static int G3CODE_INVALID;
    private static int G3CODE_EOF;
    private static int G3CODE_INCOMP;
    private int rowbytes;
    private int rowpixels;
    private int bit;
    private int data;
    private Byte[] refline;
    private ByteBuffer outBuf;
    private Byte[] dataBp;
    private int offsetData;
    private int sizeData;
    private static Byte[] zeroruns;
    private static Byte[] oneruns;
    private Int32[][] TIFFFaxWhiteCodes;
    private Int32[][] TIFFFaxBlackCodes;
    private Int32[] horizcode;
    private Int32[] passcode;
    private Int32[][] vcodes;
    private Int32[] msbmask;
    public CCITTG4Encoder(int width);
    private static CCITTG4Encoder();
    public virtual void Fax4Encode(Byte[] data, int offset, int size);
    public static Byte[] Compress(Byte[] data, int width, int height);
    public virtual void Fax4Encode(Byte[] data, int height);
    private void Putcode(Int32[] table);
    private void Putspan(int span, Int32[][] tab);
    private void PutBits(int bits, int length);
    private void Fax3Encode2DRow();
    private void Fax4PostEncode();
    public virtual Byte[] Close();
    private int Pixel(Byte[] data, int offset, int bit);
    private static int Find1span(Byte[] bp, int offset, int bs, int be);
    private static int Find0span(Byte[] bp, int offset, int bs, int be);
    private static int Finddiff(Byte[] bp, int offset, int bs, int be, int color);
    private static int Finddiff2(Byte[] bp, int offset, int bs, int be, int color);
}
public class iTextSharp.text.pdf.codec.GifImage : object {
    protected static int MaxStackSize;
    protected Stream inp;
    protected int width;
    protected int height;
    protected bool gctFlag;
    protected int bgIndex;
    protected int bgColor;
    protected int pixelAspect;
    protected bool lctFlag;
    protected bool interlace;
    protected int lctSize;
    protected int ix;
    protected int iy;
    protected int iw;
    protected int ih;
    protected Byte[] block;
    protected int blockSize;
    protected int dispose;
    protected bool transparency;
    protected int delay;
    protected int transIndex;
    protected Int16[] prefix;
    protected Byte[] suffix;
    protected Byte[] pixelStack;
    protected Byte[] pixels;
    protected Byte[] m_out;
    protected int m_bpc;
    protected int m_gbpc;
    protected Byte[] m_global_table;
    protected Byte[] m_local_table;
    protected Byte[] m_curr_table;
    protected int m_line_stride;
    protected Byte[] fromData;
    protected Uri fromUrl;
    internal List`1<GifFrame> frames;
    public GifImage(Uri url);
    public GifImage(string file);
    public GifImage(Byte[] data);
    public GifImage(Stream isp);
    public virtual int GetFrameCount();
    public virtual Image GetImage(int frame);
    public virtual Int32[] GetFramePosition(int frame);
    public virtual Int32[] GetLogicalScreen();
    internal void Process(Stream isp);
    protected virtual void ReadHeader();
    protected virtual void ReadLSD();
    protected virtual int ReadShort();
    protected virtual int ReadBlock();
    protected virtual Byte[] ReadColorTable(int bpc);
    protected static int NewBpc(int bpc);
    protected virtual void ReadContents();
    protected virtual void ReadImage();
    protected virtual bool DecodeImageData();
    protected virtual void SetPixel(int x, int y, int v);
    protected virtual void ResetFrame();
    protected virtual void ReadGraphicControlExt();
    protected virtual void Skip();
    private void ReadFully(Byte[] b, int offset, int count);
}
public class iTextSharp.text.pdf.codec.JBIG2Image : object {
    public static Byte[] GetGlobalSegment(RandomAccessFileOrArray ra);
    public static Image GetJbig2Image(RandomAccessFileOrArray ra, int page);
    public static int GetNumberOfPages(RandomAccessFileOrArray ra);
}
public class iTextSharp.text.pdf.codec.JBIG2SegmentReader : object {
    public static int SYMBOL_DICTIONARY;
    public static int INTERMEDIATE_TEXT_REGION;
    public static int IMMEDIATE_TEXT_REGION;
    public static int IMMEDIATE_LOSSLESS_TEXT_REGION;
    public static int PATTERN_DICTIONARY;
    public static int INTERMEDIATE_HALFTONE_REGION;
    public static int IMMEDIATE_HALFTONE_REGION;
    public static int IMMEDIATE_LOSSLESS_HALFTONE_REGION;
    public static int INTERMEDIATE_GENERIC_REGION;
    public static int IMMEDIATE_GENERIC_REGION;
    public static int IMMEDIATE_LOSSLESS_GENERIC_REGION;
    public static int INTERMEDIATE_GENERIC_REFINEMENT_REGION;
    public static int IMMEDIATE_GENERIC_REFINEMENT_REGION;
    public static int IMMEDIATE_LOSSLESS_GENERIC_REFINEMENT_REGION;
    public static int PAGE_INFORMATION;
    public static int END_OF_PAGE;
    public static int END_OF_STRIPE;
    public static int END_OF_FILE;
    public static int PROFILES;
    public static int TABLES;
    public static int EXTENSION;
    private SortedDictionary`2<int, JBIG2Segment> segments;
    private SortedDictionary`2<int, JBIG2Page> pages;
    private SortedDictionary`2<JBIG2Segment, object> globals;
    private RandomAccessFileOrArray ra;
    private bool sequential;
    private bool number_of_pages_known;
    private int number_of_pages;
    private bool read;
    public JBIG2SegmentReader(RandomAccessFileOrArray ra);
    public static Byte[] CopyByteArray(Byte[] b);
    public virtual void Read();
    private void ReadSegment(JBIG2Segment s);
    private JBIG2Segment ReadHeader();
    private void ReadFileHeader();
    public virtual int NumberOfPages();
    public virtual int GetPageHeight(int i);
    public virtual int GetPageWidth(int i);
    public virtual JBIG2Page GetPage(int page);
    public virtual Byte[] GetGlobal(bool for_embedding);
    public virtual string ToString();
}
public class iTextSharp.text.pdf.codec.LZWCompressor : object {
    private int codeSize_;
    private int clearCode_;
    private int endOfInfo_;
    private int numBits_;
    private int limit_;
    private short prefix_;
    private BitFile bf_;
    private LZWStringTable lzss_;
    private bool tiffFudge_;
    public LZWCompressor(Stream outp, int codeSize, bool TIFF);
    public virtual void Compress(Byte[] buf, int offset, int length);
    public virtual void Flush();
}
public class iTextSharp.text.pdf.codec.LZWStringTable : object {
    private static int RES_CODES;
    private static short HASH_FREE;
    private static short NEXT_FIRST;
    private static int MAXBITS;
    private static int MAXSTR;
    private static short HASHSIZE;
    private static short HASHSTEP;
    private Byte[] strChr_;
    private Int16[] strNxt_;
    private Int16[] strHsh_;
    private short numStrings_;
    private Int32[] strLen_;
    public virtual int AddCharString(short index, byte b);
    public virtual short FindCharString(short index, byte b);
    public virtual void ClearTable(int codesize);
    public static int Hash(short index, byte lastbyte);
    public virtual int ExpandCode(Byte[] buf, int offset, short code, int skipHead);
}
public class iTextSharp.text.pdf.codec.PngImage : object {
    public static string IHDR;
    public static string PLTE;
    public static string IDAT;
    public static string IEND;
    public static string tRNS;
    public static string pHYs;
    public static string gAMA;
    public static string cHRM;
    public static string sRGB;
    public static string iCCP;
    private static int TRANSFERSIZE;
    private static int PNG_FILTER_NONE;
    private static int PNG_FILTER_SUB;
    private static int PNG_FILTER_UP;
    private static int PNG_FILTER_AVERAGE;
    private static int PNG_FILTER_PAETH;
    public static Int32[] PNGID;
    private ILogger LOGGER;
    private static PdfName[] intents;
    private Stream isp;
    private Stream dataStream;
    private int width;
    private int height;
    private int bitDepth;
    private int colorType;
    private int compressionMethod;
    private int filterMethod;
    private int interlaceMethod;
    private PdfDictionary additional;
    private Byte[] image;
    private Byte[] smask;
    private Byte[] trans;
    private MemoryStream idat;
    private int dpiX;
    private int dpiY;
    private float XYRatio;
    private bool genBWMask;
    private bool palShades;
    private int transRedGray;
    private int transGreen;
    private int transBlue;
    private int inputBands;
    private int bytesPerPixel;
    private Byte[] colorTable;
    private float gamma;
    private bool hasCHRM;
    private float xW;
    private float yW;
    private float xR;
    private float yR;
    private float xG;
    private float yG;
    private float xB;
    private float yB;
    private PdfName intent;
    private ICC_Profile icc_profile;
    private PngImage(Stream isp);
    private static PngImage();
    public static Image GetImage(Uri url);
    public static Image GetImage(Stream isp);
    public static Image GetImage(string file);
    public static Image GetImage(Byte[] data);
    private static bool CheckMarker(string s);
    private void ReadPng();
    private PdfObject GetColorspace();
    private Image GetImage();
    private void DecodeIdat();
    private void DecodePass(int xOffset, int yOffset, int xStep, int yStep, int passWidth, int passHeight);
    private void ProcessPixels(Byte[] curr, int xOffset, int step, int y, int width);
    private static int GetPixel(Byte[] image, int x, int y, int bitDepth, int bytesPerRow);
    private static void SetPixel(Byte[] image, Int32[] data, int offset, int size, int x, int y, int bitDepth, int bytesPerRow);
    private Int32[] GetPixel(Byte[] curr);
    private int GetExpectedIccNumberOfComponents();
    private void CheckIccProfile();
    private static void DecodeSubFilter(Byte[] curr, int count, int bpp);
    private static void DecodeUpFilter(Byte[] curr, Byte[] prev, int count);
    private static void DecodeAverageFilter(Byte[] curr, Byte[] prev, int count, int bpp);
    private static int PaethPredictor(int a, int b, int c);
    private static void DecodePaethFilter(Byte[] curr, Byte[] prev, int count, int bpp);
    public static int GetInt(Stream isp);
    public static int GetWord(Stream isp);
    public static string GetString(Stream isp);
    private static void ReadFully(Stream inp, Byte[] b, int offset, int count);
}
public class iTextSharp.text.pdf.codec.PngWriter : object {
    private static Byte[] PNG_SIGNTURE;
    private static Byte[] IHDR;
    private static Byte[] PLTE;
    private static Byte[] IDAT;
    private static Byte[] IEND;
    private static Byte[] iCCP;
    private static UInt32[] crc_table;
    private Stream outp;
    public PngWriter(Stream outp);
    private static PngWriter();
    public virtual void WriteHeader(int width, int height, int bitDepth, int colorType);
    public virtual void WriteEnd();
    public virtual void WriteData(Byte[] data, int stride);
    public virtual void WritePalette(Byte[] data);
    public virtual void WriteIccProfile(Byte[] data);
    private static void make_crc_table();
    private static UInt32 update_crc(UInt32 crc, Byte[] buf, int offset, int len);
    private static UInt32 crc(Byte[] buf, int offset, int len);
    private static UInt32 crc(Byte[] buf);
    public virtual void OutputInt(int n);
    public static void OutputInt(int n, Stream s);
    public virtual void WriteChunk(Byte[] chunkType, Byte[] data);
}
public class iTextSharp.text.pdf.codec.TIFFConstants : object {
    public static int TIFFTAG_SUBFILETYPE;
    public static int FILETYPE_REDUCEDIMAGE;
    public static int FILETYPE_PAGE;
    public static int FILETYPE_MASK;
    public static int TIFFTAG_OSUBFILETYPE;
    public static int OFILETYPE_IMAGE;
    public static int OFILETYPE_REDUCEDIMAGE;
    public static int OFILETYPE_PAGE;
    public static int TIFFTAG_IMAGEWIDTH;
    public static int TIFFTAG_IMAGELENGTH;
    public static int TIFFTAG_BITSPERSAMPLE;
    public static int TIFFTAG_COMPRESSION;
    public static int COMPRESSION_NONE;
    public static int COMPRESSION_CCITTRLE;
    public static int COMPRESSION_CCITTFAX3;
    public static int COMPRESSION_CCITTFAX4;
    public static int COMPRESSION_LZW;
    public static int COMPRESSION_OJPEG;
    public static int COMPRESSION_JPEG;
    public static int COMPRESSION_NEXT;
    public static int COMPRESSION_CCITTRLEW;
    public static int COMPRESSION_PACKBITS;
    public static int COMPRESSION_THUNDERSCAN;
    public static int COMPRESSION_IT8CTPAD;
    public static int COMPRESSION_IT8LW;
    public static int COMPRESSION_IT8MP;
    public static int COMPRESSION_IT8BL;
    public static int COMPRESSION_PIXARFILM;
    public static int COMPRESSION_PIXARLOG;
    public static int COMPRESSION_DEFLATE;
    public static int COMPRESSION_ADOBE_DEFLATE;
    public static int COMPRESSION_DCS;
    public static int COMPRESSION_JBIG;
    public static int COMPRESSION_SGILOG;
    public static int COMPRESSION_SGILOG24;
    public static int TIFFTAG_PHOTOMETRIC;
    public static int PHOTOMETRIC_MINISWHITE;
    public static int PHOTOMETRIC_MINISBLACK;
    public static int PHOTOMETRIC_RGB;
    public static int PHOTOMETRIC_PALETTE;
    public static int PHOTOMETRIC_MASK;
    public static int PHOTOMETRIC_SEPARATED;
    public static int PHOTOMETRIC_YCBCR;
    public static int PHOTOMETRIC_CIELAB;
    public static int PHOTOMETRIC_LOGL;
    public static int PHOTOMETRIC_LOGLUV;
    public static int TIFFTAG_THRESHHOLDING;
    public static int THRESHHOLD_BILEVEL;
    public static int THRESHHOLD_HALFTONE;
    public static int THRESHHOLD_ERRORDIFFUSE;
    public static int TIFFTAG_CELLWIDTH;
    public static int TIFFTAG_CELLLENGTH;
    public static int TIFFTAG_FILLORDER;
    public static int FILLORDER_MSB2LSB;
    public static int FILLORDER_LSB2MSB;
    public static int TIFFTAG_DOCUMENTNAME;
    public static int TIFFTAG_IMAGEDESCRIPTION;
    public static int TIFFTAG_MAKE;
    public static int TIFFTAG_MODEL;
    public static int TIFFTAG_STRIPOFFSETS;
    public static int TIFFTAG_ORIENTATION;
    public static int ORIENTATION_TOPLEFT;
    public static int ORIENTATION_TOPRIGHT;
    public static int ORIENTATION_BOTRIGHT;
    public static int ORIENTATION_BOTLEFT;
    public static int ORIENTATION_LEFTTOP;
    public static int ORIENTATION_RIGHTTOP;
    public static int ORIENTATION_RIGHTBOT;
    public static int ORIENTATION_LEFTBOT;
    public static int TIFFTAG_SAMPLESPERPIXEL;
    public static int TIFFTAG_ROWSPERSTRIP;
    public static int TIFFTAG_STRIPBYTECOUNTS;
    public static int TIFFTAG_MINSAMPLEVALUE;
    public static int TIFFTAG_MAXSAMPLEVALUE;
    public static int TIFFTAG_XRESOLUTION;
    public static int TIFFTAG_YRESOLUTION;
    public static int TIFFTAG_PLANARCONFIG;
    public static int PLANARCONFIG_CONTIG;
    public static int PLANARCONFIG_SEPARATE;
    public static int TIFFTAG_PAGENAME;
    public static int TIFFTAG_XPOSITION;
    public static int TIFFTAG_YPOSITION;
    public static int TIFFTAG_FREEOFFSETS;
    public static int TIFFTAG_FREEBYTECOUNTS;
    public static int TIFFTAG_GRAYRESPONSEUNIT;
    public static int GRAYRESPONSEUNIT_10S;
    public static int GRAYRESPONSEUNIT_100S;
    public static int GRAYRESPONSEUNIT_1000S;
    public static int GRAYRESPONSEUNIT_10000S;
    public static int GRAYRESPONSEUNIT_100000S;
    public static int TIFFTAG_GRAYRESPONSECURVE;
    public static int TIFFTAG_GROUP3OPTIONS;
    public static int GROUP3OPT_2DENCODING;
    public static int GROUP3OPT_UNCOMPRESSED;
    public static int GROUP3OPT_FILLBITS;
    public static int TIFFTAG_GROUP4OPTIONS;
    public static int GROUP4OPT_UNCOMPRESSED;
    public static int TIFFTAG_RESOLUTIONUNIT;
    public static int RESUNIT_NONE;
    public static int RESUNIT_INCH;
    public static int RESUNIT_CENTIMETER;
    public static int TIFFTAG_PAGENUMBER;
    public static int TIFFTAG_COLORRESPONSEUNIT;
    public static int COLORRESPONSEUNIT_10S;
    public static int COLORRESPONSEUNIT_100S;
    public static int COLORRESPONSEUNIT_1000S;
    public static int COLORRESPONSEUNIT_10000S;
    public static int COLORRESPONSEUNIT_100000S;
    public static int TIFFTAG_TRANSFERFUNCTION;
    public static int TIFFTAG_SOFTWARE;
    public static int TIFFTAG_DATETIME;
    public static int TIFFTAG_ARTIST;
    public static int TIFFTAG_HOSTCOMPUTER;
    public static int TIFFTAG_PREDICTOR;
    public static int PREDICTOR_NONE;
    public static int PREDICTOR_HORIZONTAL_DIFFERENCING;
    public static int TIFFTAG_WHITEPOINT;
    public static int TIFFTAG_PRIMARYCHROMATICITIES;
    public static int TIFFTAG_COLORMAP;
    public static int TIFFTAG_HALFTONEHINTS;
    public static int TIFFTAG_TILEWIDTH;
    public static int TIFFTAG_TILELENGTH;
    public static int TIFFTAG_TILEOFFSETS;
    public static int TIFFTAG_TILEBYTECOUNTS;
    public static int TIFFTAG_BADFAXLINES;
    public static int TIFFTAG_CLEANFAXDATA;
    public static int CLEANFAXDATA_CLEAN;
    public static int CLEANFAXDATA_REGENERATED;
    public static int CLEANFAXDATA_UNCLEAN;
    public static int TIFFTAG_CONSECUTIVEBADFAXLINES;
    public static int TIFFTAG_SUBIFD;
    public static int TIFFTAG_INKSET;
    public static int INKSET_CMYK;
    public static int TIFFTAG_INKNAMES;
    public static int TIFFTAG_NUMBEROFINKS;
    public static int TIFFTAG_DOTRANGE;
    public static int TIFFTAG_TARGETPRINTER;
    public static int TIFFTAG_EXTRASAMPLES;
    public static int EXTRASAMPLE_UNSPECIFIED;
    public static int EXTRASAMPLE_ASSOCALPHA;
    public static int EXTRASAMPLE_UNASSALPHA;
    public static int TIFFTAG_SAMPLEFORMAT;
    public static int SAMPLEFORMAT_UINT;
    public static int SAMPLEFORMAT_INT;
    public static int SAMPLEFORMAT_IEEEFP;
    public static int SAMPLEFORMAT_VOID;
    public static int SAMPLEFORMAT_COMPLEXINT;
    public static int SAMPLEFORMAT_COMPLEXIEEEFP;
    public static int TIFFTAG_SMINSAMPLEVALUE;
    public static int TIFFTAG_SMAXSAMPLEVALUE;
    public static int TIFFTAG_JPEGTABLES;
    public static int TIFFTAG_JPEGPROC;
    public static int JPEGPROC_BASELINE;
    public static int JPEGPROC_LOSSLESS;
    public static int TIFFTAG_JPEGIFOFFSET;
    public static int TIFFTAG_JPEGIFBYTECOUNT;
    public static int TIFFTAG_JPEGRESTARTINTERVAL;
    public static int TIFFTAG_JPEGLOSSLESSPREDICTORS;
    public static int TIFFTAG_JPEGPOINTTRANSFORM;
    public static int TIFFTAG_JPEGQTABLES;
    public static int TIFFTAG_JPEGDCTABLES;
    public static int TIFFTAG_JPEGACTABLES;
    public static int TIFFTAG_YCBCRCOEFFICIENTS;
    public static int TIFFTAG_YCBCRSUBSAMPLING;
    public static int TIFFTAG_YCBCRPOSITIONING;
    public static int YCBCRPOSITION_CENTERED;
    public static int YCBCRPOSITION_COSITED;
    public static int TIFFTAG_REFERENCEBLACKWHITE;
    public static int TIFFTAG_REFPTS;
    public static int TIFFTAG_REGIONTACKPOINT;
    public static int TIFFTAG_REGIONWARPCORNERS;
    public static int TIFFTAG_REGIONAFFINE;
    public static int TIFFTAG_MATTEING;
    public static int TIFFTAG_DATATYPE;
    public static int TIFFTAG_IMAGEDEPTH;
    public static int TIFFTAG_TILEDEPTH;
    public static int TIFFTAG_PIXAR_IMAGEFULLWIDTH;
    public static int TIFFTAG_PIXAR_IMAGEFULLLENGTH;
    public static int TIFFTAG_PIXAR_TEXTUREFORMAT;
    public static int TIFFTAG_PIXAR_WRAPMODES;
    public static int TIFFTAG_PIXAR_FOVCOT;
    public static int TIFFTAG_PIXAR_MATRIX_WORLDTOSCREEN;
    public static int TIFFTAG_PIXAR_MATRIX_WORLDTOCAMERA;
    public static int TIFFTAG_WRITERSERIALNUMBER;
    public static int TIFFTAG_COPYRIGHT;
    public static int TIFFTAG_RICHTIFFIPTC;
    public static int TIFFTAG_IT8SITE;
    public static int TIFFTAG_IT8COLORSEQUENCE;
    public static int TIFFTAG_IT8HEADER;
    public static int TIFFTAG_IT8RASTERPADDING;
    public static int TIFFTAG_IT8BITSPERRUNLENGTH;
    public static int TIFFTAG_IT8BITSPEREXTENDEDRUNLENGTH;
    public static int TIFFTAG_IT8COLORTABLE;
    public static int TIFFTAG_IT8IMAGECOLORINDICATOR;
    public static int TIFFTAG_IT8BKGCOLORINDICATOR;
    public static int TIFFTAG_IT8IMAGECOLORVALUE;
    public static int TIFFTAG_IT8BKGCOLORVALUE;
    public static int TIFFTAG_IT8PIXELINTENSITYRANGE;
    public static int TIFFTAG_IT8TRANSPARENCYINDICATOR;
    public static int TIFFTAG_IT8COLORCHARACTERIZATION;
    public static int TIFFTAG_FRAMECOUNT;
    public static int TIFFTAG_ICCPROFILE;
    public static int TIFFTAG_PHOTOSHOP;
    public static int TIFFTAG_JBIGOPTIONS;
    public static int TIFFTAG_FAXRECVPARAMS;
    public static int TIFFTAG_FAXSUBADDRESS;
    public static int TIFFTAG_FAXRECVTIME;
    public static int TIFFTAG_STONITS;
    public static int TIFFTAG_FEDEX_EDR;
    public static int TIFFTAG_DCSHUESHIFTVALUES;
}
public class iTextSharp.text.pdf.codec.TIFFDirectory : object {
    private bool isBigEndian;
    private int numEntries;
    private TIFFField[] fields;
    private Dictionary`2<int, int> fieldIndex;
    private long IFDOffset;
    private long nextIFDOffset;
    private static Int32[] sizeOfType;
    public TIFFDirectory(RandomAccessFileOrArray stream, int directory);
    public TIFFDirectory(RandomAccessFileOrArray stream, long ifd_offset, int directory);
    private static TIFFDirectory();
    private static bool IsValidEndianTag(int endian);
    private void Initialize(RandomAccessFileOrArray stream);
    public virtual int GetNumEntries();
    public virtual TIFFField GetField(int tag);
    public virtual bool IsTagPresent(int tag);
    public virtual Int32[] GetTags();
    public virtual TIFFField[] GetFields();
    public virtual byte GetFieldAsByte(int tag, int index);
    public virtual byte GetFieldAsByte(int tag);
    public virtual long GetFieldAsLong(int tag, int index);
    public virtual long GetFieldAsLong(int tag);
    public virtual float GetFieldAsFloat(int tag, int index);
    public virtual float GetFieldAsFloat(int tag);
    public virtual double GetFieldAsDouble(int tag, int index);
    public virtual double GetFieldAsDouble(int tag);
    private short ReadShort(RandomAccessFileOrArray stream);
    private int ReadUnsignedShort(RandomAccessFileOrArray stream);
    private int ReadInt(RandomAccessFileOrArray stream);
    private long ReadUnsignedInt(RandomAccessFileOrArray stream);
    private long ReadLong(RandomAccessFileOrArray stream);
    private float ReadFloat(RandomAccessFileOrArray stream);
    private double ReadDouble(RandomAccessFileOrArray stream);
    private static int ReadUnsignedShort(RandomAccessFileOrArray stream, bool isBigEndian);
    private static long ReadUnsignedInt(RandomAccessFileOrArray stream, bool isBigEndian);
    public static int GetNumDirectories(RandomAccessFileOrArray stream);
    public virtual bool IsBigEndian();
    public virtual long GetIFDOffset();
    public virtual long GetNextIFDOffset();
}
public class iTextSharp.text.pdf.codec.TIFFFaxDecoder : object {
    private int bitPointer;
    private int bytePointer;
    private Byte[] data;
    private int w;
    private int h;
    private long fillOrder;
    private int changingElemSize;
    private Int32[] prevChangingElems;
    private Int32[] currChangingElems;
    private int lastChangingElement;
    private int compression;
    private int uncompressedMode;
    private int fillBits;
    private int oneD;
    private bool recoverFromImageError;
    private static Int32[] table1;
    private static Int32[] table2;
    internal static Byte[] flipTable;
    private static Int16[] white;
    private static Int16[] additionalMakeup;
    private static Int16[] initBlack;
    private static Int16[] twoBitBlack;
    private static Int16[] black;
    private static Byte[] twoDCodes;
    unknown bool RecoverFromImageError {public set; }
    public TIFFFaxDecoder(long fillOrder, int w, int h);
    private static TIFFFaxDecoder();
    public static void ReverseBits(Byte[] b);
    public virtual void Decode1D(Byte[] buffer, Byte[] compData, int startX, int height);
    public virtual void DecodeNextScanline(Byte[] buffer, int lineOffset, int bitOffset);
    public virtual void Decode2D(Byte[] buffer, Byte[] compData, int startX, int height, long tiffT4Options);
    public virtual void DecodeT6(Byte[] buffer, Byte[] compData, int startX, int height, long tiffT6Options);
    private void SetToBlack(Byte[] buffer, int lineOffset, int bitOffset, int numBits);
    private int DecodeWhiteCodeWord();
    private int DecodeBlackCodeWord();
    private int ReadEOL(bool isFirstEOL);
    private void GetNextChangingElement(int a0, bool isWhite, Int32[] ret);
    private int NextNBits(int bitsToGet);
    private int NextLesserThan8Bits(int bitsToGet);
    private void UpdatePointer(int bitsToMoveBack);
    private bool AdvancePointer();
    public virtual void set_RecoverFromImageError(bool value);
}
public class iTextSharp.text.pdf.codec.TIFFFaxDecompressor : object {
    protected int fillOrder;
    protected int compression;
    private int t4Options;
    private int t6Options;
    public int fails;
    protected int uncompressedMode;
    protected int fillBits;
    protected int oneD;
    private Byte[] data;
    private int bitPointer;
    private int bytePointer;
    private Byte[] buffer;
    private int w;
    private int h;
    private int bitsPerScanline;
    private int lineBitNum;
    private int changingElemSize;
    private Int32[] prevChangingElems;
    private Int32[] currChangingElems;
    private int lastChangingElement;
    private static Int32[] table1;
    private static Int32[] table2;
    internal static Byte[] flipTable;
    private static Int16[] white;
    private static Int16[] additionalMakeup;
    private static Int16[] initBlack;
    private static Int16[] twoBitBlack;
    private static Int16[] black;
    private static Byte[] twoDCodes;
    private static TIFFFaxDecompressor();
    public virtual void SetOptions(int fillOrder, int compression, int t4Options, int t6Options);
    public virtual void DecodeRaw(Byte[] buffer, Byte[] compData, int w, int h);
    public virtual void DecodeRLE();
    public virtual void DecodeNextScanline();
    public virtual void DecodeT4();
    public virtual void DecodeT6();
    private void SetToBlack(int bitNum, int numBits);
    private int DecodeWhiteCodeWord();
    private int DecodeBlackCodeWord();
    private int FindNextLine();
    private void GetNextChangingElement(int a0, bool isWhite, Int32[] ret);
    private int NextNBits(int bitsToGet);
    private int NextLesserThan8Bits(int bitsToGet);
    private void UpdatePointer(int bitsToMoveBack);
}
public class iTextSharp.text.pdf.codec.TIFFField : object {
    public static int TIFF_BYTE;
    public static int TIFF_ASCII;
    public static int TIFF_SHORT;
    public static int TIFF_LONG;
    public static int TIFF_RATIONAL;
    public static int TIFF_SBYTE;
    public static int TIFF_UNDEFINED;
    public static int TIFF_SSHORT;
    public static int TIFF_SLONG;
    public static int TIFF_SRATIONAL;
    public static int TIFF_FLOAT;
    public static int TIFF_DOUBLE;
    private int tag;
    private int type;
    private int count;
    private object data;
    public TIFFField(int tag, int type, int count, object data);
    public virtual int GetTag();
    public int GetType();
    public virtual int GetCount();
    public virtual Byte[] GetAsBytes();
    public virtual Char[] GetAsChars();
    public virtual Int16[] GetAsShorts();
    public virtual Int32[] GetAsInts();
    public virtual Int64[] GetAsLongs();
    public virtual Single[] GetAsFloats();
    public virtual Double[] GetAsDoubles();
    public virtual Int32[][] GetAsSRationals();
    public virtual Int64[][] GetAsRationals();
    public virtual int GetAsInt(int index);
    public virtual long GetAsLong(int index);
    public virtual float GetAsFloat(int index);
    public virtual double GetAsDouble(int index);
    public virtual string GetAsString(int index);
    public virtual Int32[] GetAsSRational(int index);
    public virtual Int64[] GetAsRational(int index);
    public virtual int CompareTo(TIFFField o);
}
public class iTextSharp.text.pdf.codec.TiffImage : object {
    public static int GetNumberOfPages(RandomAccessFileOrArray s);
    private static int GetDpi(TIFFField fd, int resolutionUnit);
    public static Image GetTiffImage(RandomAccessFileOrArray s, bool recoverFromImageError, int page, bool direct);
    public static Image GetTiffImage(RandomAccessFileOrArray s, bool recoverFromImageError, int page);
    public static Image GetTiffImage(RandomAccessFileOrArray s, int page);
    public static Image GetTiffImage(RandomAccessFileOrArray s, int page, bool direct);
    protected static Image GetTiffImageColor(TIFFDirectory dir, RandomAccessFileOrArray s);
    private static Image ProcessExtraSamples(ZDeflaterOutputStream zip, ZDeflaterOutputStream mzip, Byte[] outBuf, int samplePerPixel, int bitsPerSample, int width, int height);
    private static Int64[] GetArrayLongShort(TIFFDirectory dir, int tag);
    public static void DecodePackbits(Byte[] data, Byte[] dst);
    public static void Inflate(Byte[] deflated, Byte[] inflated);
    public static void ApplyPredictor(Byte[] uncompData, int predictor, int w, int h, int samplesPerPixel);
}
public class iTextSharp.text.pdf.codec.TIFFLZWDecoder : object {
    private Byte[][] stringTable;
    private Byte[] data;
    private Byte[] uncompData;
    private int tableIndex;
    private int bitsToGet;
    private int bytePointer;
    private int dstIndex;
    private int w;
    private int h;
    private int predictor;
    private int samplesPerPixel;
    private int nextData;
    private int nextBits;
    private Int32[] andTable;
    public TIFFLZWDecoder(int w, int predictor, int samplesPerPixel);
    public virtual Byte[] Decode(Byte[] data, Byte[] uncompData, int h);
    public virtual void InitializeStringTable();
    public virtual void WriteString(Byte[] strn);
    public virtual void AddStringToTable(Byte[] oldString, byte newString);
    public virtual void AddStringToTable(Byte[] strn);
    public virtual Byte[] ComposeString(Byte[] oldString, byte newString);
    public virtual int GetNextCode();
}
public class iTextSharp.text.pdf.codec.TiffWriter : object {
    private SortedDictionary`2<int, FieldBase> ifd;
    public virtual void AddField(FieldBase field);
    public virtual int GetIfdSize();
    public virtual void WriteFile(Stream stream);
    public static void WriteShort(int v, Stream stream);
    public static void WriteLong(int v, Stream stream);
    public static void CompressLZW(Stream stream, int predictor, Byte[] b, int height, int samplesPerPixel, int stride);
}
public class iTextSharp.text.pdf.codec.wmf.InputMeta : object {
    private Stream sr;
    private int length;
    public int Length { get; }
    public InputMeta(Stream istr);
    public virtual int ReadWord();
    public virtual int ReadShort();
    public virtual int ReadInt();
    public virtual int ReadByte();
    public virtual void Skip(int len);
    public virtual int get_Length();
    public virtual BaseColor ReadColor();
}
public class iTextSharp.text.pdf.codec.wmf.MetaBrush : MetaObject {
    public static int BS_SOLID;
    public static int BS_NULL;
    public static int BS_HATCHED;
    public static int BS_PATTERN;
    public static int BS_DIBPATTERN;
    public static int HS_HORIZONTAL;
    public static int HS_VERTICAL;
    public static int HS_FDIAGONAL;
    public static int HS_BDIAGONAL;
    public static int HS_CROSS;
    public static int HS_DIAGCROSS;
    private int style;
    private int hatch;
    private BaseColor color;
    public int Style { get; }
    public int Hatch { get; }
    public BaseColor Color { get; }
    public virtual void Init(InputMeta meta);
    public virtual int get_Style();
    public virtual int get_Hatch();
    public virtual BaseColor get_Color();
}
public class iTextSharp.text.pdf.codec.wmf.MetaDo : object {
    public static int META_SETBKCOLOR;
    public static int META_SETBKMODE;
    public static int META_SETMAPMODE;
    public static int META_SETROP2;
    public static int META_SETRELABS;
    public static int META_SETPOLYFILLMODE;
    public static int META_SETSTRETCHBLTMODE;
    public static int META_SETTEXTCHAREXTRA;
    public static int META_SETTEXTCOLOR;
    public static int META_SETTEXTJUSTIFICATION;
    public static int META_SETWINDOWORG;
    public static int META_SETWINDOWEXT;
    public static int META_SETVIEWPORTORG;
    public static int META_SETVIEWPORTEXT;
    public static int META_OFFSETWINDOWORG;
    public static int META_SCALEWINDOWEXT;
    public static int META_OFFSETVIEWPORTORG;
    public static int META_SCALEVIEWPORTEXT;
    public static int META_LINETO;
    public static int META_MOVETO;
    public static int META_EXCLUDECLIPRECT;
    public static int META_INTERSECTCLIPRECT;
    public static int META_ARC;
    public static int META_ELLIPSE;
    public static int META_FLOODFILL;
    public static int META_PIE;
    public static int META_RECTANGLE;
    public static int META_ROUNDRECT;
    public static int META_PATBLT;
    public static int META_SAVEDC;
    public static int META_SETPIXEL;
    public static int META_OFFSETCLIPRGN;
    public static int META_TEXTOUT;
    public static int META_BITBLT;
    public static int META_STRETCHBLT;
    public static int META_POLYGON;
    public static int META_POLYLINE;
    public static int META_ESCAPE;
    public static int META_RESTOREDC;
    public static int META_FILLREGION;
    public static int META_FRAMEREGION;
    public static int META_INVERTREGION;
    public static int META_PAINTREGION;
    public static int META_SELECTCLIPREGION;
    public static int META_SELECTOBJECT;
    public static int META_SETTEXTALIGN;
    public static int META_CHORD;
    public static int META_SETMAPPERFLAGS;
    public static int META_EXTTEXTOUT;
    public static int META_SETDIBTODEV;
    public static int META_SELECTPALETTE;
    public static int META_REALIZEPALETTE;
    public static int META_ANIMATEPALETTE;
    public static int META_SETPALENTRIES;
    public static int META_POLYPOLYGON;
    public static int META_RESIZEPALETTE;
    public static int META_DIBBITBLT;
    public static int META_DIBSTRETCHBLT;
    public static int META_DIBCREATEPATTERNBRUSH;
    public static int META_STRETCHDIB;
    public static int META_EXTFLOODFILL;
    public static int META_DELETEOBJECT;
    public static int META_CREATEPALETTE;
    public static int META_CREATEPATTERNBRUSH;
    public static int META_CREATEPENINDIRECT;
    public static int META_CREATEFONTINDIRECT;
    public static int META_CREATEBRUSHINDIRECT;
    public static int META_CREATEREGION;
    public PdfContentByte cb;
    public InputMeta meta;
    private int left;
    private int top;
    private int right;
    private int bottom;
    private int inch;
    private MetaState state;
    public MetaDo(Stream meta, PdfContentByte cb);
    public virtual void ReadAll();
    public virtual void OutputText(int x, int y, int flag, int x1, int y1, int x2, int y2, string text);
    public virtual bool IsNullStrokeFill(bool isRectangle);
    public virtual void StrokeAndFill();
    internal static double GetArc(double xCenter, double yCenter, double xDot, double yDot);
    public static Byte[] WrapBMP(Image image);
    public static void WriteWord(Stream os, int v);
    public static void WriteDWord(Stream os, int v);
}
public class iTextSharp.text.pdf.codec.wmf.MetaFont : MetaObject {
    internal static int MARKER_BOLD;
    internal static int MARKER_ITALIC;
    internal static int MARKER_COURIER;
    internal static int MARKER_HELVETICA;
    internal static int MARKER_TIMES;
    internal static int MARKER_SYMBOL;
    internal static int DEFAULT_PITCH;
    internal static int FIXED_PITCH;
    internal static int VARIABLE_PITCH;
    internal static int FF_DONTCARE;
    internal static int FF_ROMAN;
    internal static int FF_SWISS;
    internal static int FF_MODERN;
    internal static int FF_SCRIPT;
    internal static int FF_DECORATIVE;
    internal static int BOLDTHRESHOLD;
    internal static int nameSize;
    internal static int ETO_OPAQUE;
    internal static int ETO_CLIPPED;
    private static String[] fontNames;
    private int height;
    private float angle;
    private int bold;
    private int italic;
    private bool underline;
    private bool strikeout;
    private int charset;
    private int pitchAndFamily;
    private string faceName;
    private BaseFont font;
    public BaseFont Font { get; }
    public float Angle { get; }
    private static MetaFont();
    public virtual void Init(InputMeta meta);
    public virtual BaseFont get_Font();
    public virtual float get_Angle();
    public virtual bool IsUnderline();
    public virtual bool IsStrikeout();
    public virtual float GetFontSize(MetaState state);
}
public class iTextSharp.text.pdf.codec.wmf.MetaObject : object {
    public static int META_NOT_SUPPORTED;
    public static int META_PEN;
    public static int META_BRUSH;
    public static int META_FONT;
    public int type;
    public int Type { get; }
    public MetaObject(int type);
    public virtual int get_Type();
}
public class iTextSharp.text.pdf.codec.wmf.MetaPen : MetaObject {
    public static int PS_SOLID;
    public static int PS_DASH;
    public static int PS_DOT;
    public static int PS_DASHDOT;
    public static int PS_DASHDOTDOT;
    public static int PS_NULL;
    public static int PS_INSIDEFRAME;
    private int style;
    private int penWidth;
    private BaseColor color;
    public int Style { get; }
    public int PenWidth { get; }
    public BaseColor Color { get; }
    public virtual void Init(InputMeta meta);
    public virtual int get_Style();
    public virtual int get_PenWidth();
    public virtual BaseColor get_Color();
}
public class iTextSharp.text.pdf.codec.wmf.MetaState : object {
    public static int TA_NOUPDATECP;
    public static int TA_UPDATECP;
    public static int TA_LEFT;
    public static int TA_RIGHT;
    public static int TA_CENTER;
    public static int TA_TOP;
    public static int TA_BOTTOM;
    public static int TA_BASELINE;
    public static int TRANSPARENT;
    public static int OPAQUE;
    public static int ALTERNATE;
    public static int WINDING;
    public Stack`1<MetaState> savedStates;
    public List`1<MetaObject> MetaObjects;
    public Point currentPoint;
    public MetaPen currentPen;
    public MetaBrush currentBrush;
    public MetaFont currentFont;
    public BaseColor currentBackgroundColor;
    public BaseColor currentTextColor;
    public int backgroundMode;
    public int polyFillMode;
    public int lineJoin;
    public int textAlign;
    public int offsetWx;
    public int offsetWy;
    public int extentWx;
    public int extentWy;
    public float scalingX;
    public float scalingY;
    unknown MetaState metaState {public set; }
    unknown float ScalingX {public set; }
    unknown float ScalingY {public set; }
    unknown int OffsetWx {public set; }
    unknown int OffsetWy {public set; }
    unknown int ExtentWx {public set; }
    unknown int ExtentWy {public set; }
    public Point CurrentPoint { get; public set; }
    public MetaBrush CurrentBrush { get; }
    public MetaPen CurrentPen { get; }
    public MetaFont CurrentFont { get; }
    public BaseColor CurrentBackgroundColor { get; public set; }
    public BaseColor CurrentTextColor { get; public set; }
    public int BackgroundMode { get; public set; }
    public int TextAlign { get; public set; }
    public int PolyFillMode { get; public set; }
    unknown PdfContentByte LineJoinRectangle {public set; }
    unknown PdfContentByte LineJoinPolygon {public set; }
    public bool LineNeutral { get; }
    public MetaState(MetaState state);
    private static MetaState();
    public virtual void set_metaState(MetaState value);
    public virtual void AddMetaObject(MetaObject obj);
    public virtual void SelectMetaObject(int index, PdfContentByte cb);
    public virtual void DeleteMetaObject(int index);
    public virtual void SaveState(PdfContentByte cb);
    public virtual void RestoreState(int index, PdfContentByte cb);
    public virtual void Cleanup(PdfContentByte cb);
    public virtual float TransformX(int x);
    public virtual float TransformY(int y);
    public virtual void set_ScalingX(float value);
    public virtual void set_ScalingY(float value);
    public virtual void set_OffsetWx(int value);
    public virtual void set_OffsetWy(int value);
    public virtual void set_ExtentWx(int value);
    public virtual void set_ExtentWy(int value);
    public virtual float TransformAngle(float angle);
    public virtual Point get_CurrentPoint();
    public virtual void set_CurrentPoint(Point value);
    public virtual MetaBrush get_CurrentBrush();
    public virtual MetaPen get_CurrentPen();
    public virtual MetaFont get_CurrentFont();
    public virtual BaseColor get_CurrentBackgroundColor();
    public virtual void set_CurrentBackgroundColor(BaseColor value);
    public virtual BaseColor get_CurrentTextColor();
    public virtual void set_CurrentTextColor(BaseColor value);
    public virtual int get_BackgroundMode();
    public virtual void set_BackgroundMode(int value);
    public virtual int get_TextAlign();
    public virtual void set_TextAlign(int value);
    public virtual int get_PolyFillMode();
    public virtual void set_PolyFillMode(int value);
    public virtual void set_LineJoinRectangle(PdfContentByte value);
    public virtual void set_LineJoinPolygon(PdfContentByte value);
    public virtual bool get_LineNeutral();
}
public class iTextSharp.text.pdf.codec.wmf.Point : object {
    public int x;
    public int y;
    public Point(int x, int y);
}
public class iTextSharp.text.pdf.collection.PdfCollection : PdfDictionary {
    public static int DETAILS;
    public static int TILE;
    public static int HIDDEN;
    public static int CUSTOM;
    unknown string InitialDocument {public set; }
    public PdfCollectionSchema Schema { get; public set; }
    unknown PdfCollectionSort Sort {public set; }
    public PdfCollection(int type);
    public virtual void set_InitialDocument(string value);
    public virtual void set_Schema(PdfCollectionSchema value);
    public virtual PdfCollectionSchema get_Schema();
    public virtual void set_Sort(PdfCollectionSort value);
}
public class iTextSharp.text.pdf.collection.PdfCollectionField : PdfDictionary {
    public static int TEXT;
    public static int DATE;
    public static int NUMBER;
    public static int FILENAME;
    public static int DESC;
    public static int MODDATE;
    public static int CREATIONDATE;
    public static int SIZE;
    protected internal int fieldType;
    unknown int Order {public set; }
    unknown bool Visible {public set; }
    unknown bool Editable {public set; }
    public PdfCollectionField(string name, int type);
    public virtual void set_Order(int value);
    public virtual void set_Visible(bool value);
    public virtual void set_Editable(bool value);
    public virtual bool IsCollectionItem();
    public virtual PdfObject GetValue(string v);
}
public class iTextSharp.text.pdf.collection.PdfCollectionItem : PdfDictionary {
    internal PdfCollectionSchema schema;
    public PdfCollectionItem(PdfCollectionSchema schema);
    public virtual void AddItem(string key, string value);
    public virtual void AddItem(string key, PdfString value);
    public virtual void AddItem(string key, PdfDate d);
    public virtual void AddItem(string key, PdfNumber n);
    public virtual void AddItem(string key, DateTime c);
    public virtual void AddItem(string key, int i);
    public virtual void AddItem(string key, float f);
    public virtual void AddItem(string key, double d);
    public virtual void SetPrefix(string key, string prefix);
}
public class iTextSharp.text.pdf.collection.PdfCollectionSchema : PdfDictionary {
    public virtual void AddField(string name, PdfCollectionField field);
}
public class iTextSharp.text.pdf.collection.PdfCollectionSort : PdfDictionary {
    public PdfCollectionSort(string key);
    public PdfCollectionSort(String[] keys);
    public virtual void SetSortOrder(bool ascending);
    public virtual void SetSortOrder(Boolean[] ascending);
}
public class iTextSharp.text.pdf.collection.PdfTargetDictionary : PdfDictionary {
    unknown string EmbeddedFileName {public set; }
    unknown string FileAttachmentPagename {public set; }
    unknown int FileAttachmentPage {public set; }
    unknown string FileAttachmentName {public set; }
    unknown int FileAttachmentIndex {public set; }
    unknown PdfTargetDictionary AdditionalPath {public set; }
    public PdfTargetDictionary(PdfTargetDictionary nested);
    public PdfTargetDictionary(bool child);
    public virtual void set_EmbeddedFileName(string value);
    public virtual void set_FileAttachmentPagename(string value);
    public virtual void set_FileAttachmentPage(int value);
    public virtual void set_FileAttachmentName(string value);
    public virtual void set_FileAttachmentIndex(int value);
    public virtual void set_AdditionalPath(PdfTargetDictionary value);
}
public class iTextSharp.text.pdf.ColorDetails : object {
    private PdfIndirectReference indirectReference;
    private PdfName colorSpaceName;
    private ICachedColorSpace colorSpace;
    public PdfIndirectReference IndirectReference { get; }
    internal PdfName ColorSpaceName { get; }
    internal ColorDetails(PdfName colorName, PdfIndirectReference indirectReference, ICachedColorSpace scolor);
    public virtual PdfIndirectReference get_IndirectReference();
    internal virtual PdfName get_ColorSpaceName();
    public virtual PdfObject GetPdfObject(PdfWriter writer);
}
public class iTextSharp.text.pdf.ColumnText : object {
    public static int AR_NOVOWEL;
    public static int AR_COMPOSEDTASHKEEL;
    public static int AR_LIG;
    public static int DIGITS_EN2AN;
    public static int DIGITS_AN2EN;
    public static int DIGITS_EN2AN_INIT_LR;
    public static int DIGITS_EN2AN_INIT_AL;
    public static int DIGIT_TYPE_AN;
    public static int DIGIT_TYPE_AN_EXTENDED;
    public static int NO_MORE_TEXT;
    public static int NO_MORE_COLUMN;
    protected static int LINE_STATUS_OK;
    protected static int LINE_STATUS_OFFLIMITS;
    protected static int LINE_STATUS_NOLINE;
    private ILogger LOGGER;
    protected int runDirection;
    public static float GLOBAL_SPACE_CHAR_RATIO;
    protected float maxY;
    protected float minY;
    protected float leftX;
    protected float rightX;
    protected int alignment;
    protected List`1<Single[]> leftWall;
    protected List`1<Single[]> rightWall;
    protected BidiLine bidiLine;
    protected bool isWordSplit;
    protected float yLine;
    protected float lastX;
    protected float currentLeading;
    protected float fixedLeading;
    protected float multipliedLeading;
    protected PdfContentByte canvas;
    protected PdfContentByte[] canvases;
    protected int lineStatus;
    protected float indent;
    protected float followingIndent;
    protected float rightIndent;
    protected float extraParagraphSpace;
    protected float rectangularWidth;
    protected bool rectangularMode;
    private float spaceCharRatio;
    private bool lastWasNewline;
    private bool repeatFirstLineIndent;
    private int linesWritten;
    private float firstLineY;
    private bool firstLineYDone;
    private int arabicOptions;
    protected float descender;
    protected bool composite;
    protected ColumnText compositeColumn;
    protected internal List`1<IElement> compositeElements;
    protected int listIdx;
    protected int rowIdx;
    private int splittedRow;
    protected Phrase waitPhrase;
    private bool useAscender;
    private bool inheritGraphicState;
    private bool ignoreSpacingBefore;
    private float filledWidth;
    private bool adjustFirstLine;
    public float Leading { get; public set; }
    public float MultipliedLeading { get; }
    public float YLine { get; public set; }
    public int RowsDrawn { get; }
    public int Alignment { get; public set; }
    public float Indent { get; public set; }
    public float FollowingIndent { get; public set; }
    public float RightIndent { get; public set; }
    public float CurrentLeading { get; }
    public bool InheritGraphicState { get; public set; }
    public bool IgnoreSpacingBefore { get; public set; }
    public float ExtraParagraphSpace { get; public set; }
    public float SpaceCharRatio { get; public set; }
    public int RunDirection { get; public set; }
    public int LinesWritten { get; }
    public float LastX { get; }
    public int ArabicOptions { get; public set; }
    public float Descender { get; }
    public PdfContentByte Canvas { get; public set; }
    public PdfContentByte[] Canvases { get; public set; }
    public IList`1<IElement> CompositeElements { get; }
    public bool UseAscender { get; public set; }
    public float FilledWidth { get; public set; }
    public bool AdjustFirstLine { get; public set; }
    public ColumnText(PdfContentByte canvas);
    private static ColumnText();
    public static ColumnText Duplicate(ColumnText org);
    public virtual ColumnText SetACopy(ColumnText org);
    protected internal virtual void SetSimpleVars(ColumnText org);
    private void AddWaitingPhrase();
    public virtual void AddText(Phrase phrase);
    public virtual void SetText(Phrase phrase);
    public virtual void AddText(Chunk chunk);
    public virtual void AddElement(IElement element);
    public static bool isAllowedElement(IElement element);
    protected virtual List`1<Single[]> ConvertColumn(Single[] cLine);
    protected virtual float FindLimitsPoint(List`1<Single[]> wall);
    protected virtual Single[] FindLimitsOneLine();
    protected virtual Single[] FindLimitsTwoLines();
    public virtual void SetColumns(Single[] leftLine, Single[] rightLine);
    public virtual void SetSimpleColumn(Phrase phrase, float llx, float lly, float urx, float ury, float leading, int alignment);
    public virtual void SetSimpleColumn(float llx, float lly, float urx, float ury, float leading, int alignment);
    public virtual void SetSimpleColumn(float llx, float lly, float urx, float ury);
    public virtual void SetSimpleColumn(Rectangle rect);
    public virtual void SetLeading(float fixedLeading, float multipliedLeading);
    public virtual float get_Leading();
    public virtual void set_Leading(float value);
    public virtual float get_MultipliedLeading();
    public virtual float get_YLine();
    public virtual void set_YLine(float value);
    public virtual int get_RowsDrawn();
    public virtual int get_Alignment();
    public virtual void set_Alignment(int value);
    public virtual float get_Indent();
    public virtual void set_Indent(float value);
    public virtual void SetIndent(float indent, bool repeatFirstLineIndent);
    public virtual float get_FollowingIndent();
    public virtual void set_FollowingIndent(float value);
    public virtual float get_RightIndent();
    public virtual void set_RightIndent(float value);
    public virtual float get_CurrentLeading();
    public virtual bool get_InheritGraphicState();
    public virtual void set_InheritGraphicState(bool value);
    public virtual bool get_IgnoreSpacingBefore();
    public virtual void set_IgnoreSpacingBefore(bool value);
    public virtual int Go();
    public virtual int Go(bool simulate);
    public virtual int Go(bool simulate, IElement elementToGo);
    public virtual bool IsWordSplit();
    public virtual float get_ExtraParagraphSpace();
    public virtual void set_ExtraParagraphSpace(float value);
    public virtual void ClearChunks();
    public virtual float get_SpaceCharRatio();
    public virtual void set_SpaceCharRatio(float value);
    public virtual int get_RunDirection();
    public virtual void set_RunDirection(int value);
    public virtual int get_LinesWritten();
    public virtual float get_LastX();
    public virtual void set_ArabicOptions(int value);
    public virtual int get_ArabicOptions();
    public virtual float get_Descender();
    public static float GetWidth(Phrase phrase, int runDirection, int arabicOptions);
    public static float GetWidth(Phrase phrase);
    public static void ShowTextAligned(PdfContentByte canvas, int alignment, Phrase phrase, float x, float y, float rotation, int runDirection, int arabicOptions);
    public static void ShowTextAligned(PdfContentByte canvas, int alignment, Phrase phrase, float x, float y, float rotation);
    public static float FitText(Font font, string text, Rectangle rect, float maxFontSize, int runDirection);
    protected virtual int GoComposite(bool simulate);
    public virtual void set_Canvas(PdfContentByte value);
    public virtual PdfContentByte get_Canvas();
    public virtual void set_Canvases(PdfContentByte[] value);
    public virtual PdfContentByte[] get_Canvases();
    public virtual bool ZeroHeightElement();
    public virtual IList`1<IElement> get_CompositeElements();
    public virtual void set_UseAscender(bool value);
    public virtual bool get_UseAscender();
    public static bool HasMoreText(int status);
    public virtual void set_FilledWidth(float value);
    public virtual float get_FilledWidth();
    public virtual void UpdateFilledWidth(float w);
    public virtual void set_AdjustFirstLine(bool value);
    public virtual bool get_AdjustFirstLine();
    private static bool IsTagged(PdfContentByte canvas);
}
public class iTextSharp.text.pdf.crypto.AESCipher : object {
    private PaddedBufferedBlockCipher bp;
    public AESCipher(bool forEncryption, Byte[] key, Byte[] iv);
    public virtual Byte[] Update(Byte[] inp, int inpOff, int inpLen);
    public virtual Byte[] DoFinal();
}
public class iTextSharp.text.pdf.crypto.AESCipherCBCnoPad : object {
    private IBlockCipher cbc;
    public AESCipherCBCnoPad(bool forEncryption, Byte[] key);
    public virtual Byte[] ProcessBlock(Byte[] inp, int inpOff, int inpLen);
}
public class iTextSharp.text.pdf.crypto.ARCFOUREncryption : object {
    private Byte[] state;
    private int x;
    private int y;
    public virtual void PrepareARCFOURKey(Byte[] key);
    public virtual void PrepareARCFOURKey(Byte[] key, int off, int len);
    public virtual void EncryptARCFOUR(Byte[] dataIn, int off, int len, Byte[] dataOut, int offOut);
    public virtual void EncryptARCFOUR(Byte[] data, int off, int len);
    public virtual void EncryptARCFOUR(Byte[] dataIn, Byte[] dataOut);
    public virtual void EncryptARCFOUR(Byte[] data);
}
public class iTextSharp.text.pdf.crypto.IVGenerator : object {
    private static ARCFOUREncryption rc4;
    private static IVGenerator();
    public static Byte[] GetIV();
    public static Byte[] GetIV(int len);
}
public class iTextSharp.text.pdf.crypto.StandardDecryption : object {
    private static int AES_128;
    private static int AES_256;
    protected ARCFOUREncryption arcfour;
    protected AESCipher cipher;
    private Byte[] key;
    private bool aes;
    private bool initiated;
    private Byte[] iv;
    private int ivptr;
    public StandardDecryption(Byte[] key, int off, int len, int revision);
    public virtual Byte[] Update(Byte[] b, int off, int len);
    public virtual Byte[] Finish();
}
public class iTextSharp.text.pdf.DefaultSplitCharacter : object {
    public static ISplitCharacter DEFAULT;
    protected Char[] characters;
    public DefaultSplitCharacter(char character);
    public DefaultSplitCharacter(Char[] characters);
    private static DefaultSplitCharacter();
    public virtual bool IsSplitCharacter(int start, int current, int end, Char[] cc, PdfChunk[] ck);
    protected virtual char GetCurrentCharacter(int current, Char[] cc, PdfChunk[] ck);
    internal Char[] CheckDatePattern(string data);
}
public class iTextSharp.text.pdf.DeviceNColor : ExtendedColor {
    private PdfDeviceNColor pdfDeviceNColor;
    private Single[] tints;
    public PdfDeviceNColor PdfDeviceNColor { get; }
    public Single[] Tints { get; }
    public DeviceNColor(PdfDeviceNColor pdfDeviceNColor, Single[] tints);
    public virtual PdfDeviceNColor get_PdfDeviceNColor();
    public virtual Single[] get_Tints();
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
}
public class iTextSharp.text.pdf.DocumentFont : BaseFont {
    private Dictionary`2<int, Int32[]> metrics;
    private string fontName;
    private PRIndirectReference refFont;
    private PdfDictionary font;
    private Double[] fontMatrix;
    private IntHashtable uni2byte;
    private IntHashtable byte2uni;
    private IntHashtable diffmap;
    private float Ascender;
    private float CapHeight;
    private float Descender;
    private float ItalicAngle;
    private float fontWeight;
    private float llx;
    private float lly;
    private float urx;
    private float ury;
    protected bool isType0;
    protected int defaultWidth;
    private IntHashtable hMetrics;
    protected internal string cjkEncoding;
    protected internal string uniMap;
    private BaseFont cjkMirror;
    private static Int32[] stdEnc;
    public PdfDictionary FontDictionary { get; }
    public String[][] FamilyFontName { get; }
    public String[][] FullFontName { get; }
    public String[][] AllNameEntries { get; }
    public string PostscriptFontName { get; public set; }
    internal PdfIndirectReference IndirectReference { get; }
    internal IntHashtable Uni2Byte { get; }
    internal IntHashtable Byte2Uni { get; }
    internal IntHashtable Diffmap { get; }
    internal DocumentFont(PdfDictionary font);
    internal DocumentFont(PRIndirectReference refFont);
    internal DocumentFont(PRIndirectReference refFont, PdfDictionary drEncoding);
    private static DocumentFont();
    private void Init();
    public virtual PdfDictionary get_FontDictionary();
    private void ProcessType0(PdfDictionary font);
    private IntHashtable ReadWidths(PdfArray ws);
    private string DecodeString(PdfString ps);
    private void FillMetricsIdentity(IntHashtable widths, int dw);
    private void FillMetrics(Byte[] touni, IntHashtable widths, int dw);
    private void DoType1TT();
    private void FillWidths();
    private void FillDiffMap(PdfDictionary encDic, CMapToUnicode toUnicode);
    private CMapToUnicode ProcessToUnicode();
    private void FillFontDesc(PdfDictionary fontDesc);
    private void FillEncoding(PdfName encoding);
    public virtual String[][] get_FamilyFontName();
    public virtual float GetFontDescriptor(int key, float fontSize);
    public virtual String[][] get_FullFontName();
    public virtual String[][] get_AllNameEntries();
    public virtual int GetKerning(int char1, int char2);
    public virtual string get_PostscriptFontName();
    public virtual void set_PostscriptFontName(string value);
    internal virtual int GetRawWidth(int c, string name);
    public virtual bool HasKernPairs();
    internal virtual void WriteFont(PdfWriter writer, PdfIndirectReference refi, Object[] param);
    public virtual PdfStream GetFullFontStream();
    public virtual int GetWidth(int char1);
    public virtual int GetWidth(string text);
    public virtual Byte[] ConvertToBytes(string text);
    internal virtual Byte[] ConvertToBytes(int char1);
    internal PdfIndirectReference get_IndirectReference();
    public virtual bool CharExists(int c);
    public virtual Double[] GetFontMatrix();
    public virtual bool SetKerning(int char1, int char2, int kern);
    public virtual Int32[] GetCharBBox(int c);
    public virtual bool IsVertical();
    protected virtual Int32[] GetRawCharBBox(int c, string name);
    internal IntHashtable get_Uni2Byte();
    internal IntHashtable get_Byte2Uni();
    internal IntHashtable get_Diffmap();
    private bool IsSymbolic();
}
public class iTextSharp.text.pdf.draw.DottedLineSeparator : LineSeparator {
    protected float gap;
    public float Gap { get; public set; }
    public virtual void Draw(PdfContentByte canvas, float llx, float lly, float urx, float ury, float y);
    public virtual float get_Gap();
    public virtual void set_Gap(float value);
}
public interface iTextSharp.text.pdf.draw.IDrawInterface {
    public abstract virtual void Draw(PdfContentByte canvas, float llx, float lly, float urx, float ury, float y);
}
public class iTextSharp.text.pdf.draw.LineSeparator : VerticalPositionMark {
    protected float lineWidth;
    protected float percentage;
    protected BaseColor lineColor;
    protected int alignment;
    public float LineWidth { get; public set; }
    public float Percentage { get; public set; }
    public BaseColor LineColor { get; public set; }
    public int Alignment { get; public set; }
    public LineSeparator(float lineWidth, float percentage, BaseColor lineColor, int align, float offset);
    public LineSeparator(Font font);
    public virtual void Draw(PdfContentByte canvas, float llx, float lly, float urx, float ury, float y);
    public virtual void DrawLine(PdfContentByte canvas, float leftX, float rightX, float y);
    public virtual float get_LineWidth();
    public virtual void set_LineWidth(float value);
    public virtual float get_Percentage();
    public virtual void set_Percentage(float value);
    public virtual BaseColor get_LineColor();
    public virtual void set_LineColor(BaseColor value);
    public virtual int get_Alignment();
    public virtual void set_Alignment(int value);
}
public class iTextSharp.text.pdf.draw.VerticalPositionMark : object {
    protected IDrawInterface drawInterface;
    protected float offset;
    public int Type { get; }
    public IList`1<Chunk> Chunks { get; }
    public IDrawInterface DrawInterface { get; public set; }
    public float Offset { get; public set; }
    public VerticalPositionMark(IDrawInterface drawInterface, float offset);
    public virtual void Draw(PdfContentByte canvas, float llx, float lly, float urx, float ury, float y);
    public virtual bool Process(IElementListener listener);
    public virtual int get_Type();
    public virtual bool IsContent();
    public virtual bool IsNestable();
    public virtual IList`1<Chunk> get_Chunks();
    public virtual void set_DrawInterface(IDrawInterface value);
    public virtual IDrawInterface get_DrawInterface();
    public virtual void set_Offset(float value);
    public virtual float get_Offset();
}
internal class iTextSharp.text.pdf.EnumerateTTC : TrueTypeFont {
    protected String[] names;
    internal String[] Names { get; }
    internal EnumerateTTC(string ttcFile);
    internal EnumerateTTC(Byte[] ttcArray);
    internal void FindNames();
    internal String[] get_Names();
}
public class iTextSharp.text.pdf.events.FieldPositioningEvents : PdfPageEventHelper {
    protected Dictionary`2<string, PdfFormField> genericChunkFields;
    protected PdfFormField cellField;
    protected PdfWriter fieldWriter;
    protected PdfFormField parent;
    public float padding;
    public float Padding { get; public set; }
    public PdfFormField Parent { get; public set; }
    public FieldPositioningEvents(PdfWriter writer, PdfFormField field);
    public FieldPositioningEvents(PdfFormField parent, PdfFormField field);
    public FieldPositioningEvents(PdfWriter writer, string text);
    public FieldPositioningEvents(PdfWriter writer, PdfFormField parent, string text);
    public virtual void AddField(string text, PdfFormField field);
    public virtual void set_Padding(float value);
    public virtual float get_Padding();
    public virtual void set_Parent(PdfFormField value);
    public virtual PdfFormField get_Parent();
    public virtual void OnGenericTag(PdfWriter writer, Document document, Rectangle rect, string text);
    public virtual void CellLayout(PdfPCell cell, Rectangle rect, PdfContentByte[] canvases);
}
public class iTextSharp.text.pdf.events.IndexEvents : PdfPageEventHelper {
    private Dictionary`2<string, int> indextag;
    private long indexcounter;
    private List`1<Entry> indexentry;
    private IComparer`1<Entry> comparator;
    public virtual void OnGenericTag(PdfWriter writer, Document document, Rectangle rect, string text);
    public virtual Chunk Create(string text, string in1, string in2, string in3);
    public virtual Chunk Create(string text, string in1);
    public virtual Chunk Create(string text, string in1, string in2);
    public virtual void Create(Chunk text, string in1, string in2, string in3);
    public virtual void Create(Chunk text, string in1);
    public virtual void Create(Chunk text, string in1, string in2);
    public virtual void SetComparator(IComparer`1<Entry> aComparator);
    public virtual List`1<Entry> GetSortedEntries();
}
public class iTextSharp.text.pdf.events.PdfPageEventForwarder : object {
    protected List`1<IPdfPageEvent> events;
    public virtual void AddPageEvent(IPdfPageEvent eventa);
    public virtual void OnOpenDocument(PdfWriter writer, Document document);
    public virtual void OnStartPage(PdfWriter writer, Document document);
    public virtual void OnEndPage(PdfWriter writer, Document document);
    public virtual void OnCloseDocument(PdfWriter writer, Document document);
    public virtual void OnParagraph(PdfWriter writer, Document document, float paragraphPosition);
    public virtual void OnParagraphEnd(PdfWriter writer, Document document, float paragraphPosition);
    public virtual void OnChapter(PdfWriter writer, Document document, float paragraphPosition, Paragraph title);
    public virtual void OnChapterEnd(PdfWriter writer, Document document, float position);
    public virtual void OnSection(PdfWriter writer, Document document, float paragraphPosition, int depth, Paragraph title);
    public virtual void OnSectionEnd(PdfWriter writer, Document document, float position);
    public virtual void OnGenericTag(PdfWriter writer, Document document, Rectangle rect, string text);
}
public class iTextSharp.text.pdf.events.PdfPCellEventForwarder : object {
    protected List`1<IPdfPCellEvent> events;
    public virtual void AddCellEvent(IPdfPCellEvent eventa);
    public virtual void CellLayout(PdfPCell cell, Rectangle position, PdfContentByte[] canvases);
}
public class iTextSharp.text.pdf.events.PdfPTableEventForwarder : object {
    protected List`1<IPdfPTableEvent> events;
    public virtual void AddTableEvent(IPdfPTableEvent eventa);
    public virtual void TableLayout(PdfPTable table, Single[][] widths, Single[] heights, int headerRows, int rowStart, PdfContentByte[] canvases);
    public virtual void SplitTable(PdfPTable table);
    public virtual void AfterSplitTable(PdfPTable table, PdfPRow startRow, int startIdx);
}
public abstract class iTextSharp.text.pdf.ExtendedColor : BaseColor {
    public static int TYPE_RGB;
    public static int TYPE_GRAY;
    public static int TYPE_CMYK;
    public static int TYPE_SEPARATION;
    public static int TYPE_PATTERN;
    public static int TYPE_SHADING;
    public static int TYPE_DEVICEN;
    public static int TYPE_LAB;
    protected int type;
    public int Type { get; }
    public ExtendedColor(int type);
    public ExtendedColor(int type, float red, float green, float blue);
    public ExtendedColor(int type, int red, int green, int blue, int alpha);
    public virtual int get_Type();
    public static int GetType(object color);
    internal static float Normalize(float value);
}
public class iTextSharp.text.pdf.FdfReader : PdfReader {
    internal Dictionary`2<string, PdfDictionary> fields;
    internal string fileSpec;
    internal PdfName encoding;
    protected static ICounter COUNTER;
    public Dictionary`2<string, PdfDictionary> Fields { get; }
    public string FileSpec { get; }
    public FdfReader(string filename);
    public FdfReader(Byte[] pdfIn);
    public FdfReader(Uri url);
    public FdfReader(Stream isp);
    private static FdfReader();
    protected virtual ICounter GetCounter();
    protected internal virtual void ReadPdf();
    protected virtual void KidNode(PdfDictionary merged, string name);
    protected virtual void ReadFields();
    public virtual Dictionary`2<string, PdfDictionary> get_Fields();
    public virtual PdfDictionary GetField(string name);
    public virtual Byte[] GetAttachedFile(string name);
    public virtual string GetFieldValue(string name);
    public virtual string get_FileSpec();
}
public class iTextSharp.text.pdf.FdfWriter : object {
    private static Byte[] HEADER_FDF;
    private Dictionary`2<string, object> fields;
    private Wrt wrt;
    private string file;
    private string statusMessage;
    protected ICounter COUNTER;
    public string StatusMessage { get; public set; }
    public string File { get; public set; }
    public FdfWriter(Stream os);
    private static FdfWriter();
    public virtual void WriteTo(Stream os);
    public virtual void Write();
    public virtual string get_StatusMessage();
    public virtual void set_StatusMessage(string value);
    internal bool SetField(string field, PdfObject value);
    internal void IterateFields(Dictionary`2<string, object> values, Dictionary`2<string, object> map, string name);
    public virtual bool RemoveField(string field);
    public virtual Dictionary`2<string, object> GetFields();
    public virtual string GetField(string field);
    public virtual bool SetFieldAsName(string field, string value);
    public virtual bool SetFieldAsString(string field, string value);
    public virtual bool SetFieldAsAction(string field, PdfAction action);
    public virtual bool SetFieldAsTemplate(string field, PdfTemplate template);
    public virtual bool SetFieldAsImage(string field, Image image);
    public virtual bool SetFieldAsJavascript(string field, PdfName jsTrigName, string js);
    public virtual PdfImportedPage GetImportedPage(PdfReader reader, int pageNumber);
    public virtual PdfTemplate CreateTemplate(float width, float height);
    public virtual void SetFields(FdfReader fdf);
    public virtual void SetFields(PdfReader pdf);
    public virtual void SetFields(AcroFields af);
    public virtual string get_File();
    public virtual void set_File(string value);
    protected virtual ICounter GetCounter();
}
public class iTextSharp.text.pdf.FilterHandlers : object {
    private static IDictionary`2<PdfName, IFilterHandler> defaults;
    private static FilterHandlers();
    public static IDictionary`2<PdfName, IFilterHandler> GetDefaultFilterHandlers();
    public static MemoryStream EnableMemoryLimitsAwareHandler(PdfDictionary streamDictionary);
}
public class iTextSharp.text.pdf.FloatLayout : object {
    protected float maxY;
    protected float minY;
    protected float leftX;
    protected float rightX;
    protected float yLine;
    protected float floatLeftX;
    protected float floatRightX;
    protected float filledWidth;
    public ColumnText compositeColumn;
    public List`1<IElement> content;
    protected bool useAscender;
    public float YLine { get; public set; }
    public float FilledWidth { get; public set; }
    public int RunDirection { get; public set; }
    public FloatLayout(List`1<IElement> elements, bool useAscender);
    public virtual float get_YLine();
    public virtual void set_YLine(float value);
    public virtual float get_FilledWidth();
    public virtual void set_FilledWidth(float value);
    public virtual void SetSimpleColumn(float llx, float lly, float urx, float ury);
    public int get_RunDirection();
    public void set_RunDirection(int value);
    public virtual int Layout(PdfContentByte canvas, bool simulate);
    private int FloatingLayout(List`1<IElement> floatingElements, bool simulate);
}
public class iTextSharp.text.pdf.FontDetails : object {
    private PdfIndirectReference indirectReference;
    private PdfName fontName;
    private BaseFont baseFont;
    private TrueTypeFontUnicode ttu;
    private CJKFont cjkFont;
    private Byte[] shortTag;
    private Dictionary`2<int, Int32[]> longTag;
    private IntHashtable cjkTag;
    private int fontType;
    private bool symbolic;
    protected bool subset;
    internal PdfIndirectReference IndirectReference { get; }
    internal PdfName FontName { get; }
    internal BaseFont BaseFont { get; }
    public bool Subset { get; public set; }
    internal FontDetails(PdfName fontName, PdfIndirectReference indirectReference, BaseFont baseFont);
    internal PdfIndirectReference get_IndirectReference();
    internal PdfName get_FontName();
    internal BaseFont get_BaseFont();
    internal virtual Object[] ConvertToBytesGid(string gids);
    internal Byte[] ConvertToBytes(string text);
    public virtual void WriteFont(PdfWriter writer);
    public virtual void set_Subset(bool value);
    public virtual bool get_Subset();
}
public abstract class iTextSharp.text.pdf.fonts.cmaps.AbstractCMap : object {
    private string cmapName;
    private string registry;
    private string ordering;
    private int supplement;
    public int Supplement { get; public set; }
    public string Name { get; public set; }
    public string Ordering { get; public set; }
    public string Registry { get; public set; }
    public virtual int get_Supplement();
    public virtual void set_Supplement(int value);
    public virtual string get_Name();
    public virtual void set_Name(string value);
    public virtual string get_Ordering();
    public virtual void set_Ordering(string value);
    public virtual string get_Registry();
    public virtual void set_Registry(string value);
    internal abstract virtual void AddChar(PdfString mark, PdfObject code);
    internal void AddRange(PdfString from, PdfString to, PdfObject code);
    private static void IntToByteArray(int v, Byte[] b);
    private static int ByteArrayToInt(Byte[] b);
    public static Byte[] DecodeStringToByte(PdfString s);
    public virtual string DecodeStringToUnicode(PdfString ps);
}
public class iTextSharp.text.pdf.fonts.cmaps.CidLocationFromByte : object {
    private Byte[] data;
    public CidLocationFromByte(Byte[] data);
    public virtual PRTokeniser GetLocation(string location);
}
public class iTextSharp.text.pdf.fonts.cmaps.CidResource : object {
    public virtual PRTokeniser GetLocation(string location);
}
public class iTextSharp.text.pdf.fonts.cmaps.CMapByteCid : AbstractCMap {
    private List`1<Char[]> planes;
    internal virtual void AddChar(PdfString mark, PdfObject code);
    private void EncodeSequence(Byte[] seqs, char cid);
    public virtual int DecodeSingle(CMapSequence seq);
    public virtual string DecodeSequence(CMapSequence seq);
}
public class iTextSharp.text.pdf.fonts.cmaps.CMapCache : object {
    private static Dictionary`2<string, CMapUniCid> cacheUniCid;
    private static Dictionary`2<string, CMapCidUni> cacheCidUni;
    private static Dictionary`2<string, CMapCidByte> cacheCidByte;
    private static Dictionary`2<string, CMapByteCid> cacheByteCid;
    private static CMapCache();
    public static CMapUniCid GetCachedCMapUniCid(string name);
    public static CMapCidUni GetCachedCMapCidUni(string name);
    public static CMapCidByte GetCachedCMapCidByte(string name);
    public static CMapByteCid GetCachedCMapByteCid(string name);
}
public class iTextSharp.text.pdf.fonts.cmaps.CMapCidByte : AbstractCMap {
    private Dictionary`2<int, Byte[]> map;
    private static Byte[] EMPTY;
    private static CMapCidByte();
    internal virtual void AddChar(PdfString mark, PdfObject code);
    public virtual Byte[] Lookup(int cid);
}
public class iTextSharp.text.pdf.fonts.cmaps.CMapCidUni : AbstractCMap {
    private IntHashtable map;
    internal virtual void AddChar(PdfString mark, PdfObject code);
    public virtual int Lookup(int character);
}
public class iTextSharp.text.pdf.fonts.cmaps.CMapParserEx : object {
    private static string DEF;
    private static string ENDCIDRANGE;
    private static string ENDCIDCHAR;
    private static string ENDBFRANGE;
    private static string ENDBFCHAR;
    private static string USECMAP;
    private static int MAXLEVEL;
    private static PdfName CMAPNAME;
    private static CMapParserEx();
    public static void ParseCid(string cmapName, AbstractCMap cmap, ICidLocation location);
    private static void ParseCid(string cmapName, AbstractCMap cmap, ICidLocation location, int level);
}
public class iTextSharp.text.pdf.fonts.cmaps.CMapSequence : object {
    public Byte[] seq;
    public int off;
    public int len;
    public CMapSequence(Byte[] seq, int off, int len);
}
public class iTextSharp.text.pdf.fonts.cmaps.CMapToUnicode : AbstractCMap {
    private IDictionary`2<int, string> singleByteMappings;
    private IDictionary`2<int, string> doubleByteMappings;
    private Encoding enc;
    public virtual bool HasOneByteMappings();
    public virtual bool HasTwoByteMappings();
    public virtual string Lookup(Byte[] code, int offset, int length);
    public virtual IDictionary`2<int, int> CreateReverseMapping();
    public virtual IDictionary`2<int, int> CreateDirectMapping();
    private int ConvertToInt(string s);
    internal void AddChar(int cid, string uni);
    internal virtual void AddChar(PdfString mark, PdfObject code);
    private string CreateStringFromBytes(Byte[] bytes);
    public static CMapToUnicode GetIdentity();
}
public class iTextSharp.text.pdf.fonts.cmaps.CMapUniCid : AbstractCMap {
    private IntHashtable map;
    internal virtual void AddChar(PdfString mark, PdfObject code);
    public virtual int Lookup(int character);
    public virtual CMapToUnicode ExportToUnicode();
}
public interface iTextSharp.text.pdf.fonts.cmaps.ICidLocation {
    public abstract virtual PRTokeniser GetLocation(string location);
}
public class iTextSharp.text.pdf.fonts.cmaps.IdentityToUnicode : object {
    private static CMapToUnicode identityCNS;
    private static CMapToUnicode identityJapan;
    private static CMapToUnicode identityKorea;
    private static CMapToUnicode identityGB;
    private static CMapToUnicode identityH;
    public static CMapToUnicode GetMapFromOrdering(string ordering);
}
public class iTextSharp.text.pdf.FontSelector : object {
    private static ILogger LOGGER;
    protected List`1<Font> fonts;
    protected List`1<Font> unsupportedFonts;
    protected Font currentFont;
    private static FontSelector();
    public virtual void AddFont(Font font);
    public virtual Phrase Process(string text);
    protected virtual Chunk ProcessChar(Char[] cc, int k, StringBuilder sb);
    protected int GetSize();
    protected Font GetFont(int i);
    private bool IsSupported(Font font);
}
public class iTextSharp.text.pdf.GlyphList : object {
    private static Dictionary`2<int, string> unicode2names;
    private static Dictionary`2<string, Int32[]> names2unicode;
    private static GlyphList();
    public static Int32[] NameToUnicode(string name);
    public static string UnicodeToName(int num);
}
public class iTextSharp.text.pdf.GrayColor : ExtendedColor {
    private float cgray;
    public static GrayColor GRAYBLACK;
    public static GrayColor GRAYWHITE;
    public float Gray { get; }
    public GrayColor(int intGray);
    public GrayColor(float floatGray);
    private static GrayColor();
    public virtual float get_Gray();
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
}
[DefaultMemberAttribute("Item")]
public class iTextSharp.text.pdf.hyphenation.ByteVector : object {
    private static int DEFAULT_BLOCK_SIZE;
    private int BLOCK_SIZE;
    private Byte[] arr;
    private int n;
    public Byte[] Arr { get; }
    public int Length { get; }
    public int Capacity { get; }
    public byte Item { get; public set; }
    public ByteVector(int capacity);
    public ByteVector(Byte[] a);
    public ByteVector(Byte[] a, int capacity);
    private static ByteVector();
    public virtual Byte[] get_Arr();
    public virtual int get_Length();
    public virtual int get_Capacity();
    public byte get_Item(int index);
    public void set_Item(int index, byte value);
    public virtual int Alloc(int size);
    public virtual void TrimToSize();
}
[DefaultMemberAttribute("Item")]
public class iTextSharp.text.pdf.hyphenation.CharVector : object {
    private static int DEFAULT_BLOCK_SIZE;
    private int BLOCK_SIZE;
    private Char[] array;
    private int n;
    public Char[] Arr { get; }
    public int Length { get; }
    public int Capacity { get; }
    public char Item { get; public set; }
    public CharVector(int capacity);
    public CharVector(Char[] a);
    public CharVector(Char[] a, int capacity);
    private static CharVector();
    public virtual void Clear();
    public virtual object Clone();
    public virtual Char[] get_Arr();
    public virtual int get_Length();
    public virtual int get_Capacity();
    public char get_Item(int index);
    public void set_Item(int index, char value);
    public virtual int Alloc(int size);
    public virtual void TrimToSize();
}
public class iTextSharp.text.pdf.hyphenation.Hyphen : object {
    public string preBreak;
    public string noBreak;
    public string postBreak;
    internal Hyphen(string pre, string no, string post);
    internal Hyphen(string pre);
    public virtual string ToString();
}
public class iTextSharp.text.pdf.hyphenation.Hyphenation : object {
    private Int32[] hyphenPoints;
    private string word;
    private int len;
    public int Length { get; }
    public Int32[] HyphenationPoints { get; }
    public Hyphenation(string word, Int32[] points);
    public virtual int get_Length();
    public virtual string GetPreHyphenText(int index);
    public virtual string GetPostHyphenText(int index);
    public virtual Int32[] get_HyphenationPoints();
    public virtual string ToString();
}
public class iTextSharp.text.pdf.hyphenation.HyphenationException : Exception {
    public HyphenationException(string msg);
    protected HyphenationException(SerializationInfo info, StreamingContext context);
}
public class iTextSharp.text.pdf.hyphenation.HyphenationTree : TernaryTree {
    protected ByteVector vspace;
    protected Dictionary`2<string, List`1<object>> stoplist;
    protected TernaryTree classmap;
    private TernaryTree ivalues;
    protected virtual int PackValues(string values);
    protected virtual string UnpackValues(int k);
    public virtual void LoadSimplePatterns(Stream stream);
    public virtual string FindPattern(string pat);
    protected virtual int Hstrcmp(Char[] s, int si, Char[] t, int ti);
    protected virtual Byte[] GetValues(int k);
    protected virtual void SearchPatterns(Char[] word, int index, Byte[] il);
    public virtual Hyphenation Hyphenate(string word, int remainCharCount, int pushCharCount);
    public virtual Hyphenation Hyphenate(Char[] w, int offset, int len, int remainCharCount, int pushCharCount);
    public virtual void AddClass(string chargroup);
    public virtual void AddException(string word, List`1<object> hyphenatedword);
    public virtual void AddPattern(string pattern, string ivalue);
    public virtual void PrintStats();
}
public class iTextSharp.text.pdf.hyphenation.Hyphenator : object {
    private static string defaultHyphLocation;
    private static Hashtable hyphenTrees;
    private HyphenationTree hyphenTree;
    private int remainCharCount;
    private int pushCharCount;
    public Hyphenator(string lang, string country, int leftMin, int rightMin);
    private static Hyphenator();
    public static HyphenationTree GetHyphenationTree(string lang, string country);
    public static HyphenationTree GetResourceHyphenationTree(string key);
    public static Hyphenation Hyphenate(string lang, string country, string word, int leftMin, int rightMin);
    public static Hyphenation Hyphenate(string lang, string country, Char[] word, int offset, int len, int leftMin, int rightMin);
    public virtual void SetMinRemainCharCount(int min);
    public virtual void SetMinPushCharCount(int min);
    public virtual void SetLanguage(string lang, string country);
    public virtual Hyphenation Hyphenate(Char[] word, int offset, int len);
    public virtual Hyphenation Hyphenate(string word);
}
public interface iTextSharp.text.pdf.hyphenation.IPatternConsumer {
    public abstract virtual void AddClass(string chargroup);
    public abstract virtual void AddException(string word, List`1<object> hyphenatedword);
    public abstract virtual void AddPattern(string pattern, string values);
}
public class iTextSharp.text.pdf.hyphenation.SimplePatternParser : object {
    internal static int ELEM_CLASSES;
    internal static int ELEM_EXCEPTIONS;
    internal static int ELEM_PATTERNS;
    internal static int ELEM_HYPHEN;
    internal int currElement;
    internal IPatternConsumer consumer;
    internal StringBuilder token;
    internal List`1<object> exception;
    internal char hyphenChar;
    public virtual void Parse(Stream stream, IPatternConsumer consumer);
    protected static string GetPattern(string word);
    protected virtual List`1<object> NormalizeException(List`1<object> ex);
    protected virtual string GetExceptionWord(List`1<object> ex);
    protected static string GetInterletterValues(string pat);
    public virtual void EndDocument();
    public virtual void EndElement(string tag);
    public virtual void StartDocument();
    public virtual void StartElement(string tag, IDictionary`2<string, string> h);
    public virtual void Text(string str);
}
public class iTextSharp.text.pdf.hyphenation.TernaryTree : object {
    protected Char[] lo;
    protected Char[] hi;
    protected Char[] eq;
    protected Char[] sc;
    protected CharVector kv;
    protected char root;
    protected char freenode;
    protected int length;
    protected static int BLOCK_SIZE;
    public int Size { get; }
    public Iterator Keys { get; }
    private static TernaryTree();
    protected virtual void Init();
    public virtual void Insert(string key, char val);
    public virtual void Insert(Char[] key, int start, char val);
    private char Insert(char p, Char[] key, int start, char val);
    public static int Strcmp(Char[] a, int startA, Char[] b, int startB);
    public static int Strcmp(string str, Char[] a, int start);
    public static void Strcpy(Char[] dst, int di, Char[] src, int si);
    public static int Strlen(Char[] a, int start);
    public static int Strlen(Char[] a);
    public virtual int Find(string key);
    public virtual int Find(Char[] key, int start);
    public virtual bool Knows(string key);
    private void RedimNodeArrays(int newsize);
    public virtual int get_Size();
    public virtual object Clone();
    protected virtual void InsertBalanced(String[] k, Char[] v, int offset, int n);
    public virtual void Balance();
    public virtual void TrimToSize();
    private void Compact(CharVector kx, TernaryTree map, char p);
    public virtual Iterator get_Keys();
    public virtual void PrintStats();
}
public class iTextSharp.text.pdf.HyphenationAuto : object {
    protected Hyphenator hyphenator;
    protected string post;
    public string HyphenSymbol { get; }
    public string HyphenatedWordPost { get; }
    public HyphenationAuto(string lang, string country, int leftMin, int rightMin);
    public virtual string get_HyphenSymbol();
    public virtual string GetHyphenatedWordPre(string word, BaseFont font, float fontSize, float remainingWidth);
    public virtual string get_HyphenatedWordPost();
}
public interface iTextSharp.text.pdf.ICachedColorSpace {
    public abstract virtual PdfObject GetPdfObject(PdfWriter writer);
    public abstract virtual bool Equals(object obj);
    public abstract virtual int GetHashCode();
}
public class iTextSharp.text.pdf.ICC_Profile : object {
    protected Byte[] data;
    protected int numComponents;
    private static Dictionary`2<string, int> cstags;
    public Byte[] Data { get; }
    public int NumComponents { get; }
    private static ICC_Profile();
    public static ICC_Profile GetInstance(Byte[] data, int numComponents);
    public static ICC_Profile GetInstance(Byte[] data);
    public static ICC_Profile GetInstance(Stream file);
    public static ICC_Profile GetInstance(string fname);
    public virtual Byte[] get_Data();
    public virtual int get_NumComponents();
}
public interface iTextSharp.text.pdf.IExtraEncoding {
    public abstract virtual Byte[] CharToByte(string text, string encoding);
    public abstract virtual Byte[] CharToByte(char char1, string encoding);
    public abstract virtual string ByteToChar(Byte[] b, string encoding);
}
public interface iTextSharp.text.pdf.IHyphenationEvent {
    public string HyphenSymbol { get; }
    public string HyphenatedWordPost { get; }
    public abstract virtual string get_HyphenSymbol();
    public abstract virtual string GetHyphenatedWordPre(string word, BaseFont font, float fontSize, float remainingWidth);
    public abstract virtual string get_HyphenatedWordPost();
}
public interface iTextSharp.text.pdf.interfaces.IAccessibleElement {
    public PdfName Role { get; public set; }
    public AccessibleElementId ID { get; public set; }
    public bool IsInline { get; }
    public abstract virtual PdfObject GetAccessibleAttribute(PdfName key);
    public abstract virtual void SetAccessibleAttribute(PdfName key, PdfObject value);
    public abstract virtual Dictionary`2<PdfName, PdfObject> GetAccessibleAttributes();
    public abstract virtual PdfName get_Role();
    public abstract virtual void set_Role(PdfName value);
    public abstract virtual AccessibleElementId get_ID();
    public abstract virtual void set_ID(AccessibleElementId value);
    public abstract virtual bool get_IsInline();
}
public interface iTextSharp.text.pdf.interfaces.IAlternateDescription {
    public string Alt { get; public set; }
    public abstract virtual string get_Alt();
    public abstract virtual void set_Alt(string value);
}
public interface iTextSharp.text.pdf.interfaces.IPdfAnnotations {
    public PdfAcroForm AcroForm { get; }
    unknown int SigFlags {public set; }
    public abstract virtual PdfAcroForm get_AcroForm();
    public abstract virtual void AddAnnotation(PdfAnnotation annot);
    public abstract virtual void AddCalculationOrder(PdfFormField annot);
    public abstract virtual void set_SigFlags(int value);
}
public interface iTextSharp.text.pdf.interfaces.IPdfDocumentActions {
    public abstract virtual void SetOpenAction(string name);
    public abstract virtual void SetOpenAction(PdfAction action);
    public abstract virtual void SetAdditionalAction(PdfName actionType, PdfAction action);
}
public interface iTextSharp.text.pdf.interfaces.IPdfEncryptionSettings {
    public abstract virtual void SetEncryption(Byte[] userPassword, Byte[] ownerPassword, int permissions, int encryptionType);
    public abstract virtual void SetEncryption(X509Certificate[] certs, Int32[] permissions, int encryptionType);
}
public interface iTextSharp.text.pdf.interfaces.IPdfIsoConformance {
    public abstract virtual bool IsPdfIso();
    public abstract virtual void CheckPdfIsoConformance(int key, object obj1);
}
public interface iTextSharp.text.pdf.interfaces.IPdfPageActions {
    unknown int Duration {public set; }
    unknown PdfTransition Transition {public set; }
    public abstract virtual void SetPageAction(PdfName actionType, PdfAction action);
    public abstract virtual void set_Duration(int value);
    public abstract virtual void set_Transition(PdfTransition value);
}
public interface iTextSharp.text.pdf.interfaces.IPdfRunDirection {
    public int RunDirection { get; public set; }
    public abstract virtual void set_RunDirection(int value);
    public abstract virtual int get_RunDirection();
}
public interface iTextSharp.text.pdf.interfaces.IPdfStructureElement {
    public abstract virtual PdfObject GetAttribute(PdfName name);
    public abstract virtual void SetAttribute(PdfName name, PdfObject obj);
}
public interface iTextSharp.text.pdf.interfaces.IPdfVersion {
    unknown char PdfVersion {public set; }
    public abstract virtual void set_PdfVersion(char value);
    public abstract virtual void SetAtLeastPdfVersion(char version);
    public abstract virtual void SetPdfVersion(PdfName version);
    public abstract virtual void AddDeveloperExtension(PdfDeveloperExtension de);
}
public interface iTextSharp.text.pdf.interfaces.IPdfViewerPreferences {
    unknown int ViewerPreferences {public set; }
    public abstract virtual void set_ViewerPreferences(int value);
    public abstract virtual void AddViewerPreference(PdfName key, PdfObject value);
}
public interface iTextSharp.text.pdf.interfaces.IPdfXConformance {
    public int PDFXConformance { get; public set; }
    public abstract virtual void set_PDFXConformance(int value);
    public abstract virtual int get_PDFXConformance();
    public abstract virtual bool IsPdfX();
}
public class iTextSharp.text.pdf.intern.PdfAnnotationsImp : object {
    protected internal PdfAcroForm acroForm;
    protected internal List`1<PdfAnnotation> annotations;
    protected internal List`1<PdfAnnotation> delayedAnnotations;
    public PdfAcroForm AcroForm { get; }
    unknown int SigFlags {public set; }
    public PdfAnnotationsImp(PdfWriter writer);
    public virtual bool HasValidAcroForm();
    public virtual PdfAcroForm get_AcroForm();
    public virtual void set_SigFlags(int value);
    public virtual void AddCalculationOrder(PdfFormField formField);
    public virtual void AddAnnotation(PdfAnnotation annot);
    public virtual void AddPlainAnnotation(PdfAnnotation annot);
    private void AddFormFieldRaw(PdfFormField field);
    public virtual bool HasUnusedAnnotations();
    public virtual void ResetAnnotations();
    public virtual PdfArray RotateAnnotations(PdfWriter writer, Rectangle pageSize);
    public static PdfAnnotation ConvertAnnotation(PdfWriter writer, Annotation annot, Rectangle defaultRect);
}
public class iTextSharp.text.pdf.intern.PdfIsoKeys : object {
    public static int PDFISOKEY_COLOR;
    public static int PDFISOKEY_CMYK;
    public static int PDFISOKEY_RGB;
    public static int PDFISOKEY_FONT;
    public static int PDFISOKEY_IMAGE;
    public static int PDFISOKEY_GSTATE;
    public static int PDFISOKEY_LAYER;
    public static int PDFISOKEY_TRAILER;
    public static int PDFISOKEY_STREAM;
    public static int PDFISOKEY_FILESPEC;
    public static int PDFISOKEY_OBJECT;
    public static int PDFISOKEY_CANVAS;
    public static int PDFISOKEY_ANNOTATION;
    public static int PDFISOKEY_ACTION;
    public static int PDFISOKEY_FORM;
    public static int PDFISOKEY_STRUCTELEM;
    public static int PDFISOKEY_INLINE_IMAGE;
    public static int PDFISOKEY_GRAY;
    public static int PDFISOKEY_OUTPUTINTENT;
    public static int PDFISOKEY_FORM_XOBJ;
}
public class iTextSharp.text.pdf.intern.PdfVersionImp : object {
    public static Byte[][] HEADER;
    protected bool headerWasWritten;
    protected bool appendmode;
    protected char header_version;
    protected PdfName catalog_version;
    protected char version;
    protected PdfDictionary extensions;
    unknown char PdfVersion {public set; }
    public char Version { get; }
    private static PdfVersionImp();
    public virtual void set_PdfVersion(char value);
    public virtual void SetAtLeastPdfVersion(char version);
    public virtual void SetPdfVersion(PdfName version);
    public virtual void SetAppendmode(bool appendmode);
    public virtual void WriteHeader(OutputStreamCounter os);
    public virtual PdfName GetVersionAsName(char version);
    public virtual Byte[] GetVersionAsByteArray(char version);
    public virtual void AddToCatalog(PdfDictionary catalog);
    public virtual void AddDeveloperExtension(PdfDeveloperExtension de);
    public virtual char get_Version();
}
public class iTextSharp.text.pdf.intern.PdfViewerPreferencesImp : object {
    private static int viewerPreferencesMask;
    public static PdfName[] VIEWER_PREFERENCES;
    public static PdfName[] NONFULLSCREENPAGEMODE_PREFERENCES;
    public static PdfName[] DIRECTION_PREFERENCES;
    public static PdfName[] PAGE_BOUNDARIES;
    public static PdfName[] PRINTSCALING_PREFERENCES;
    public static PdfName[] DUPLEX_PREFERENCES;
    private int pageLayoutAndMode;
    private PdfDictionary viewerPreferences;
    public int PageLayoutAndMode { get; }
    unknown int ViewerPreferences {public set; }
    private static PdfViewerPreferencesImp();
    public virtual int get_PageLayoutAndMode();
    public virtual PdfDictionary GetViewerPreferences();
    public virtual void set_ViewerPreferences(int value);
    private int GetIndex(PdfName key);
    private bool IsPossibleValue(PdfName value, PdfName[] accepted);
    public virtual void AddViewerPreference(PdfName key, PdfObject value);
    public virtual void AddToCatalog(PdfDictionary catalog);
    public static PdfViewerPreferencesImp GetViewerPreferences(PdfDictionary catalog);
}
public class iTextSharp.text.pdf.intern.PdfXConformanceImp : object {
    protected internal int pdfxConformance;
    protected PdfWriter writer;
    public int PDFXConformance { get; public set; }
    public PdfXConformanceImp(PdfWriter writer);
    public virtual void set_PDFXConformance(int value);
    public virtual int get_PDFXConformance();
    public virtual bool IsPdfIso();
    public virtual bool IsPdfX();
    public virtual bool IsPdfX1A2001();
    public virtual bool IsPdfX32002();
    public virtual void CheckPdfIsoConformance(int key, object obj1);
}
[DefaultMemberAttribute("Item")]
public class iTextSharp.text.pdf.IntHashtable : object {
    private IntHashtableEntry[] table;
    private int count;
    private int threshold;
    private float loadFactor;
    public int Size { get; }
    public int Item { get; public set; }
    public IntHashtable(int initialCapacity, float loadFactor);
    public IntHashtable(int initialCapacity);
    public virtual int get_Size();
    public virtual bool IsEmpty();
    public virtual bool Contains(int value);
    public virtual bool ContainsKey(int key);
    public int get_Item(int key);
    public void set_Item(int key, int value);
    protected virtual void Rehash();
    public virtual int Remove(int key);
    public virtual void Clear();
    public virtual IntHashtable Clone();
    public virtual Int32[] ToOrderedKeys();
    public virtual Int32[] GetKeys();
    public virtual IntHashtableIterator GetEntryIterator();
}
public interface iTextSharp.text.pdf.IPdfOCG {
    public PdfIndirectReference Ref { get; }
    public PdfObject PdfObject { get; }
    public abstract virtual PdfIndirectReference get_Ref();
    public abstract virtual PdfObject get_PdfObject();
}
public interface iTextSharp.text.pdf.IPdfPageEvent {
    public abstract virtual void OnOpenDocument(PdfWriter writer, Document document);
    public abstract virtual void OnStartPage(PdfWriter writer, Document document);
    public abstract virtual void OnEndPage(PdfWriter writer, Document document);
    public abstract virtual void OnCloseDocument(PdfWriter writer, Document document);
    public abstract virtual void OnParagraph(PdfWriter writer, Document document, float paragraphPosition);
    public abstract virtual void OnParagraphEnd(PdfWriter writer, Document document, float paragraphPosition);
    public abstract virtual void OnChapter(PdfWriter writer, Document document, float paragraphPosition, Paragraph title);
    public abstract virtual void OnChapterEnd(PdfWriter writer, Document document, float paragraphPosition);
    public abstract virtual void OnSection(PdfWriter writer, Document document, float paragraphPosition, int depth, Paragraph title);
    public abstract virtual void OnSectionEnd(PdfWriter writer, Document document, float paragraphPosition);
    public abstract virtual void OnGenericTag(PdfWriter writer, Document document, Rectangle rect, string text);
}
public interface iTextSharp.text.pdf.IPdfPCellEvent {
    public abstract virtual void CellLayout(PdfPCell cell, Rectangle position, PdfContentByte[] canvases);
}
public interface iTextSharp.text.pdf.IPdfPTableEvent {
    public abstract virtual void TableLayout(PdfPTable table, Single[][] widths, Single[] heights, int headerRows, int rowStart, PdfContentByte[] canvases);
}
public interface iTextSharp.text.pdf.IPdfPTableEventAfterSplit {
    public abstract virtual void AfterSplitTable(PdfPTable table, PdfPRow startRow, int startIdx);
}
public interface iTextSharp.text.pdf.IPdfPTableEventSplit {
    public abstract virtual void SplitTable(PdfPTable table);
}
public interface iTextSharp.text.pdf.IPdfSpecialColorSpace {
    public abstract virtual ColorDetails[] GetColorantDetails(PdfWriter writer);
}
public class iTextSharp.text.pdf.LabColor : ExtendedColor {
    private PdfLabColor labColorSpace;
    private float l;
    private float a;
    private float b;
    public PdfLabColor LabColorSpace { get; }
    public float L { get; }
    public float A { get; }
    public float B { get; }
    public LabColor(PdfLabColor labColorSpace, float l, float a, float b);
    public virtual PdfLabColor get_LabColorSpace();
    public virtual float get_L();
    public virtual float get_A();
    public virtual float get_B();
    public virtual BaseColor ToRgb();
    internal virtual CMYKColor ToCmyk();
}
public class iTextSharp.text.pdf.languages.GujaratiLigaturizer : IndicLigaturizer {
    public static char GUJR_MATRA_AA;
    public static char GUJR_MATRA_I;
    public static char GUJR_MATRA_E;
    public static char GUJR_MATRA_AI;
    public static char GUJR_MATRA_HLR;
    public static char GUJR_MATRA_HLRR;
    public static char GUJR_LETTER_A;
    public static char GUJR_LETTER_AU;
    public static char GUJR_LETTER_KA;
    public static char GUJR_LETTER_HA;
    public static char GUJR_HALANTA;
    private static GujaratiLigaturizer();
}
public class iTextSharp.text.pdf.languages.HebrewProcessor : object {
    protected int runDirection;
    public HebrewProcessor(int runDirection);
    public virtual string Process(string s);
    public virtual bool IsRTL();
}
public interface iTextSharp.text.pdf.languages.ILanguageProcessor {
    public abstract virtual string Process(string s);
    public abstract virtual bool IsRTL();
}
public abstract class iTextSharp.text.pdf.languages.IndicLigaturizer : object {
    public static int MATRA_AA;
    public static int MATRA_I;
    public static int MATRA_E;
    public static int MATRA_AI;
    public static int MATRA_HLR;
    public static int MATRA_HLRR;
    public static int LETTER_A;
    public static int LETTER_AU;
    public static int LETTER_KA;
    public static int LETTER_HA;
    public static int HALANTA;
    protected Char[] langTable;
    private static IndicLigaturizer();
    public virtual string Process(string s);
    public virtual bool IsRTL();
    protected virtual bool IsSwaraLetter(char ch);
    protected virtual bool IsSwaraMatra(char ch);
    protected virtual bool IsVyanjana(char ch);
    private static void Swap(StringBuilder s, int i, int j);
}
[DefaultMemberAttribute("Item")]
public class iTextSharp.text.pdf.LongHashtable : object {
    private LongHashtableEntry[] table;
    private int count;
    private int threshold;
    private float loadFactor;
    public int Size { get; }
    public long Item { get; public set; }
    public LongHashtable(int initialCapacity, float loadFactor);
    public LongHashtable(int initialCapacity);
    public virtual int get_Size();
    public virtual bool IsEmpty();
    public virtual bool Contains(long value);
    public virtual bool ContainsKey(long key);
    public long get_Item(long key);
    public void set_Item(long key, long value);
    protected virtual void Rehash();
    public virtual long Remove(long key);
    public virtual void Clear();
    public virtual LongHashtable Clone();
    public virtual Int64[] ToOrderedKeys();
    public virtual Int64[] GetKeys();
    public virtual LongHashtableIterator GetEntryIterator();
}
public class iTextSharp.text.pdf.LZWDecoder : object {
    private Byte[][] stringTable;
    private Byte[] data;
    private Stream uncompData;
    private int tableIndex;
    private int bitsToGet;
    private int bytePointer;
    private int nextData;
    private int nextBits;
    internal Int32[] andTable;
    public int NextCode { get; }
    public virtual void Decode(Byte[] data, Stream uncompData);
    public virtual void InitializeStringTable();
    public virtual void WriteString(Byte[] str);
    public virtual void AddStringToTable(Byte[] oldstring, byte newstring);
    public virtual void AddStringToTable(Byte[] str);
    public virtual Byte[] ComposeString(Byte[] oldstring, byte newstring);
    public virtual int get_NextCode();
}
public class iTextSharp.text.pdf.MemoryLimitsAwareException : Exception {
    public static string DuringDecompressionMultipleStreamsInSumOccupiedMoreMemoryThanAllowed;
    public static string DuringDecompressionSingleStreamOccupiedMoreMemoryThanAllowed;
    public static string DuringDecompressionSingleStreamOccupiedMoreThanMaxIntegerValue;
    public static string UnknownPdfException;
    public MemoryLimitsAwareException(string message);
    private static MemoryLimitsAwareException();
}
public class iTextSharp.text.pdf.MemoryLimitsAwareHandler : object {
    private static int SINGLE_SCALE_COEFFICIENT;
    private static int SUM_SCALE_COEFFICIENT;
    private static int SINGLE_DECOMPRESSED_PDF_STREAM_MIN_SIZE;
    private static long SUM_OF_DECOMPRESSED_PDF_STREAMW_MIN_SIZE;
    private int MaxSizeOfSingleDecompressedPdfStream;
    private long MaxSizeOfDecompressedPdfStreamsSum;
    private long AllMemoryUsedForDecompression;
    private long MemoryUsedForCurrentPdfStreamDecompression;
    internal bool ConsiderCurrentPdfStream;
    public MemoryLimitsAwareHandler(long documentSize);
    private static MemoryLimitsAwareHandler();
    public int GetMaxSizeOfSingleDecompressedPdfStream();
    public MemoryLimitsAwareHandler SetMaxSizeOfSingleDecompressedPdfStream(int maxSizeOfSingleDecompressedPdfStream);
    public long GetMaxSizeOfDecompressedPdfStreamsSum();
    public MemoryLimitsAwareHandler SetMaxSizeOfDecompressedPdfStreamsSum(long maxSizeOfDecompressedPdfStreamsSum);
    internal MemoryLimitsAwareHandler ConsiderBytesOccupiedByDecompressedPdfStream(long numOfOccupiedBytes);
    internal MemoryLimitsAwareHandler BeginDecompressedPdfStreamProcessing();
    internal MemoryLimitsAwareHandler EndDecompressedPdfStreamProcessing();
    internal long GetAllMemoryUsedForDecompression();
    private static long CalculateDefaultParameter(long documentSize, int scale, long min);
    private void EnsureCurrentStreamIsReset();
}
internal class iTextSharp.text.pdf.MemoryLimitsAwareOutputStream : MemoryStream {
    private static int DEFAULT_MAX_STREAM_SIZE;
    private int maxStreamSize;
    public MemoryLimitsAwareOutputStream(int size);
    private static MemoryLimitsAwareOutputStream();
    public long GetMaxStreamSize();
    public MemoryLimitsAwareOutputStream SetMaxStreamSize(int maxStreamSize);
    public virtual void Write(Byte[] b, int off, int len);
}
public class iTextSharp.text.pdf.NumberArray : PdfArray {
    public NumberArray(Single[] numbers);
    public NumberArray(float n1);
    public NumberArray(float n1, float n2);
    public NumberArray(float n1, float n2, float n3);
    public NumberArray(float n1, float n2, float n3, float n4);
    public NumberArray(float n1, float n2, float n3, float n4, float n5);
    public NumberArray(float n1, float n2, float n3, float n4, float n5, float n6);
    public NumberArray(IList`1<PdfNumber> numbers);
}
public class iTextSharp.text.pdf.OutputStreamCounter : Stream {
    protected Stream outc;
    protected long counter;
    public long Counter { get; }
    public bool CanRead { get; }
    public bool CanSeek { get; }
    public bool CanWrite { get; }
    public long Length { get; }
    public long Position { get; public set; }
    public OutputStreamCounter(Stream _outc);
    public virtual long get_Counter();
    public virtual void ResetCounter();
    public virtual bool get_CanRead();
    public virtual bool get_CanSeek();
    public virtual bool get_CanWrite();
    public virtual long get_Length();
    public virtual long get_Position();
    public virtual void set_Position(long value);
    public virtual void Flush();
    public virtual int Read(Byte[] buffer, int offset, int count);
    public virtual long Seek(long offset, SeekOrigin origin);
    public virtual void SetLength(long value);
    public virtual void Write(Byte[] buffer, int offset, int count);
    public virtual void Close();
}
public class iTextSharp.text.pdf.OutputStreamEncryption : Stream {
    private static int AES_128;
    private static int AES_256;
    protected Stream outc;
    protected ARCFOUREncryption arcfour;
    protected AESCipher cipher;
    private Byte[] buf;
    private bool aes;
    private bool finished;
    public bool CanRead { get; }
    public bool CanSeek { get; }
    public bool CanWrite { get; }
    public long Length { get; }
    public long Position { get; public set; }
    public OutputStreamEncryption(Stream outc, Byte[] key, int off, int len, int revision);
    public OutputStreamEncryption(Stream outc, Byte[] key, int revision);
    public virtual bool get_CanRead();
    public virtual bool get_CanSeek();
    public virtual bool get_CanWrite();
    public virtual long get_Length();
    public virtual long get_Position();
    public virtual void set_Position(long value);
    public virtual void Flush();
    public virtual int Read(Byte[] buffer, int offset, int count);
    public virtual long Seek(long offset, SeekOrigin origin);
    public virtual void SetLength(long value);
    public virtual void Write(Byte[] b, int off, int len);
    public virtual void Close();
    public virtual void WriteByte(byte value);
    public virtual void Finish();
}
public class iTextSharp.text.pdf.PageResources : object {
    protected PdfDictionary fontDictionary;
    protected PdfDictionary xObjectDictionary;
    protected PdfDictionary colorDictionary;
    protected PdfDictionary patternDictionary;
    protected PdfDictionary shadingDictionary;
    protected PdfDictionary extGStateDictionary;
    protected PdfDictionary propertyDictionary;
    protected Dictionary`2<PdfName, object> forbiddenNames;
    protected PdfDictionary originalResources;
    protected Int32[] namePtr;
    protected Dictionary`2<PdfName, PdfName> usedNames;
    internal PdfDictionary Resources { get; }
    internal void SetOriginalResources(PdfDictionary resources, Int32[] newNamePtr);
    internal PdfName TranslateName(PdfName name);
    internal PdfName AddFont(PdfName name, PdfIndirectReference reference);
    internal PdfName AddXObject(PdfName name, PdfIndirectReference reference);
    internal PdfName AddColor(PdfName name, PdfIndirectReference reference);
    internal void AddDefaultColor(PdfName name, PdfObject obj);
    internal void AddDefaultColor(PdfDictionary dic);
    internal void AddDefaultColorDiff(PdfDictionary dic);
    internal PdfName AddShading(PdfName name, PdfIndirectReference reference);
    internal PdfName AddPattern(PdfName name, PdfIndirectReference reference);
    internal PdfName AddExtGState(PdfName name, PdfIndirectReference reference);
    internal PdfName AddProperty(PdfName name, PdfIndirectReference reference);
    internal PdfDictionary get_Resources();
    internal bool HasResources();
}
public class iTextSharp.text.pdf.parser.BezierCurve : object {
    public static double CurveCollinearityEpsilon;
    public static double DistanceToleranceSquare;
    public static double DistanceToleranceManhattan;
    private IList`1<Point2D> controlPoints;
    public BezierCurve(IList`1<Point2D> controlPoints);
    private static BezierCurve();
    public virtual IList`1<Point2D> GetBasePoints();
    public virtual IList`1<Point2D> GetPiecewiseLinearApproximation();
    private void RecursiveApproximation(double x1, double y1, double x2, double y2, double x3, double y3, double x4, double y4, IList`1<Point2D> points);
}
public class iTextSharp.text.pdf.parser.clipper.Clipper : ClipperBase {
    public static int ioReverseSolution;
    public static int ioStrictlySimple;
    public static int ioPreserveCollinear;
    private List`1<OutRec> m_PolyOuts;
    private ClipType m_ClipType;
    private Scanbeam m_Scanbeam;
    private Maxima m_Maxima;
    private TEdge m_ActiveEdges;
    private TEdge m_SortedEdges;
    private List`1<IntersectNode> m_IntersectList;
    private IComparer`1<IntersectNode> m_IntersectNodeComparer;
    private bool m_ExecuteLocked;
    private PolyFillType m_ClipFillType;
    private PolyFillType m_SubjFillType;
    private List`1<Join> m_Joins;
    private List`1<Join> m_GhostJoins;
    private bool m_UsingPolyTree;
    private bool reverseSolution;
    private bool strictlySimple;
    public bool ReverseSolution { get; public set; }
    public bool StrictlySimple { get; public set; }
    public Clipper(int InitOptions);
    private void InsertScanbeam(long Y);
    private void InsertMaxima(long X);
    protected virtual void Reset();
    public bool get_ReverseSolution();
    public void set_ReverseSolution(bool value);
    public bool get_StrictlySimple();
    public void set_StrictlySimple(bool value);
    public bool Execute(ClipType clipType, List`1<List`1<IntPoint>> solution);
    public bool Execute(ClipType clipType, List`1<List`1<IntPoint>> solution, PolyFillType FillType);
    public bool Execute(ClipType clipType, PolyTree polytree);
    public bool Execute(ClipType clipType, PolyTree polytree, PolyFillType FillType);
    public bool Execute(ClipType clipType, List`1<List`1<IntPoint>> solution, PolyFillType subjFillType, PolyFillType clipFillType);
    public bool Execute(ClipType clipType, PolyTree polytree, PolyFillType subjFillType, PolyFillType clipFillType);
    internal void FixHoleLinkage(OutRec outRec);
    private bool ExecuteInternal();
    private long PopScanbeam();
    private void DisposeAllPolyPts();
    private void DisposeOutRec(int index);
    private void AddJoin(OutPt Op1, OutPt Op2, IntPoint OffPt);
    private void AddGhostJoin(OutPt Op, IntPoint OffPt);
    private void InsertLocalMinimaIntoAEL(long botY);
    private void InsertEdgeIntoAEL(TEdge edge, TEdge startEdge);
    private bool E2InsertsBeforeE1(TEdge e1, TEdge e2);
    private bool IsEvenOddFillType(TEdge edge);
    private bool IsEvenOddAltFillType(TEdge edge);
    private bool IsContributing(TEdge edge);
    private void SetWindingCount(TEdge edge);
    private void AddEdgeToSEL(TEdge edge);
    private void CopyAELToSEL();
    private void SwapPositionsInAEL(TEdge edge1, TEdge edge2);
    private void SwapPositionsInSEL(TEdge edge1, TEdge edge2);
    private void AddLocalMaxPoly(TEdge e1, TEdge e2, IntPoint pt);
    private OutPt AddLocalMinPoly(TEdge e1, TEdge e2, IntPoint pt);
    private OutRec CreateOutRec();
    private OutPt AddOutPt(TEdge e, IntPoint pt);
    private OutPt GetLastOutPt(TEdge e);
    internal void SwapPoints(IntPoint& pt1, IntPoint& pt2);
    private bool HorzSegmentsOverlap(long seg1a, long seg1b, long seg2a, long seg2b);
    private void SetHoleState(TEdge e, OutRec outRec);
    private double GetDx(IntPoint pt1, IntPoint pt2);
    private bool FirstIsBottomPt(OutPt btmPt1, OutPt btmPt2);
    private OutPt GetBottomPt(OutPt pp);
    private OutRec GetLowermostRec(OutRec outRec1, OutRec outRec2);
    private bool Param1RightOfParam2(OutRec outRec1, OutRec outRec2);
    private OutRec GetOutRec(int idx);
    private void AppendPolygon(TEdge e1, TEdge e2);
    private void ReversePolyPtLinks(OutPt pp);
    private static void SwapSides(TEdge edge1, TEdge edge2);
    private static void SwapPolyIndexes(TEdge edge1, TEdge edge2);
    private void IntersectEdges(TEdge e1, TEdge e2, IntPoint pt);
    private void DeleteFromAEL(TEdge e);
    private void DeleteFromSEL(TEdge e);
    private void UpdateEdgeIntoAEL(TEdge& e);
    private void ProcessHorizontals();
    private void GetHorzDirection(TEdge HorzEdge, Direction& Dir, Int64& Left, Int64& Right);
    private void ProcessHorizontal(TEdge horzEdge);
    private TEdge GetNextInAEL(TEdge e, Direction Direction);
    private bool IsMinima(TEdge e);
    private bool IsMaxima(TEdge e, double Y);
    private bool IsIntermediate(TEdge e, double Y);
    private TEdge GetMaximaPair(TEdge e);
    private bool ProcessIntersections(long topY);
    private void BuildIntersectList(long topY);
    private bool EdgesAdjacent(IntersectNode inode);
    private static int IntersectNodeSort(IntersectNode node1, IntersectNode node2);
    private bool FixupIntersectionOrder();
    private void ProcessIntersectList();
    internal static long Round(double value);
    private static long TopX(TEdge edge, long currentY);
    private void IntersectPoint(TEdge edge1, TEdge edge2, IntPoint& ip);
    private void ProcessEdgesAtTopOfScanbeam(long topY);
    private void DoMaxima(TEdge e);
    public static void ReversePaths(List`1<List`1<IntPoint>> polys);
    public static bool Orientation(List`1<IntPoint> poly);
    private int PointCount(OutPt pts);
    private void BuildResult(List`1<List`1<IntPoint>> polyg);
    private void BuildResult2(PolyTree polytree);
    private void FixupOutPolyline(OutRec outrec);
    private void FixupOutPolygon(OutRec outRec);
    private OutPt DupOutPt(OutPt outPt, bool InsertAfter);
    private bool GetOverlap(long a1, long a2, long b1, long b2, Int64& Left, Int64& Right);
    private bool JoinHorz(OutPt op1, OutPt op1b, OutPt op2, OutPt op2b, IntPoint Pt, bool DiscardLeft);
    private bool JoinPoints(Join j, OutRec outRec1, OutRec outRec2);
    public static int PointInPolygon(IntPoint pt, List`1<IntPoint> path);
    private static int PointInPolygon(IntPoint pt, OutPt op);
    private static bool Poly2ContainsPoly1(OutPt outPt1, OutPt outPt2);
    private void FixupFirstLefts1(OutRec OldOutRec, OutRec NewOutRec);
    private void FixupFirstLefts2(OutRec OldOutRec, OutRec NewOutRec);
    private static OutRec ParseFirstLeft(OutRec FirstLeft);
    private void JoinCommonEdges();
    private void UpdateOutPtIdxs(OutRec outrec);
    private void DoSimplePolygons();
    public static double Area(List`1<IntPoint> poly);
    private double Area(OutRec outRec);
    public static List`1<List`1<IntPoint>> SimplifyPolygon(List`1<IntPoint> poly);
    public static List`1<List`1<IntPoint>> SimplifyPolygon(List`1<IntPoint> poly, PolyFillType fillType);
    public static List`1<List`1<IntPoint>> SimplifyPolygons(List`1<List`1<IntPoint>> polys);
    public static List`1<List`1<IntPoint>> SimplifyPolygons(List`1<List`1<IntPoint>> polys, PolyFillType fillType);
    private static double DistanceSqrd(IntPoint pt1, IntPoint pt2);
    private static double DistanceFromLineSqrd(IntPoint pt, IntPoint ln1, IntPoint ln2);
    private static bool SlopesNearCollinear(IntPoint pt1, IntPoint pt2, IntPoint pt3, double distSqrd);
    private static bool PointsAreClose(IntPoint pt1, IntPoint pt2, double distSqrd);
    private static OutPt ExcludeOp(OutPt op);
    public static List`1<IntPoint> CleanPolygon(List`1<IntPoint> path);
    public static List`1<IntPoint> CleanPolygon(List`1<IntPoint> path, double distance);
    public static List`1<List`1<IntPoint>> CleanPolygons(List`1<List`1<IntPoint>> polys);
    public static List`1<List`1<IntPoint>> CleanPolygons(List`1<List`1<IntPoint>> polys, double distance);
    internal static List`1<List`1<IntPoint>> Minkowski(List`1<IntPoint> pattern, List`1<IntPoint> path, bool IsSum, bool IsClosed);
    public static List`1<List`1<IntPoint>> MinkowskiSum(List`1<IntPoint> pattern, List`1<IntPoint> path, bool pathIsClosed);
    private static List`1<IntPoint> TranslatePath(List`1<IntPoint> path, IntPoint delta);
    public static List`1<List`1<IntPoint>> MinkowskiSum(List`1<IntPoint> pattern, List`1<List`1<IntPoint>> paths, bool pathIsClosed);
    public static List`1<List`1<IntPoint>> MinkowskiDiff(List`1<IntPoint> poly1, List`1<IntPoint> poly2);
    public static List`1<List`1<IntPoint>> PolyTreeToPaths(PolyTree polytree);
    internal static void AddPolyNodeToPaths(PolyNode polynode, NodeType nt, List`1<List`1<IntPoint>> paths);
    public static List`1<List`1<IntPoint>> OpenPathsFromPolyTree(PolyTree polytree);
    public static List`1<List`1<IntPoint>> ClosedPathsFromPolyTree(PolyTree polytree);
}
public class iTextSharp.text.pdf.parser.clipper.ClipperBase : object {
    protected static double horizontal;
    protected static int Skip;
    protected static int Unassigned;
    protected static double tolerance;
    public static long loRange;
    public static long hiRange;
    internal LocalMinima m_MinimaList;
    internal LocalMinima m_CurrentLM;
    internal List`1<List`1<TEdge>> m_edges;
    internal bool m_UseFullRange;
    internal bool m_HasOpenPaths;
    internal bool preserveCollinear;
    public bool PreserveCollinear { get; public set; }
    internal static bool near_zero(double val);
    public bool get_PreserveCollinear();
    public void set_PreserveCollinear(bool value);
    public void Swap(Int64& val1, Int64& val2);
    internal static bool IsHorizontal(TEdge e);
    internal bool PointIsVertex(IntPoint pt, OutPt pp);
    internal bool PointOnLineSegment(IntPoint pt, IntPoint linePt1, IntPoint linePt2, bool UseFullRange);
    internal bool PointOnPolygon(IntPoint pt, OutPt pp, bool UseFullRange);
    internal static bool SlopesEqual(TEdge e1, TEdge e2, bool UseFullRange);
    protected static bool SlopesEqual(IntPoint pt1, IntPoint pt2, IntPoint pt3, bool UseFullRange);
    protected static bool SlopesEqual(IntPoint pt1, IntPoint pt2, IntPoint pt3, IntPoint pt4, bool UseFullRange);
    public virtual void Clear();
    private void DisposeLocalMinimaList();
    private void RangeTest(IntPoint Pt, Boolean& useFullRange);
    private void InitEdge(TEdge e, TEdge eNext, TEdge ePrev, IntPoint pt);
    private void InitEdge2(TEdge e, PolyType polyType);
    private TEdge FindNextLocMin(TEdge E);
    private TEdge ProcessBound(TEdge E, bool LeftBoundIsForward);
    public bool AddPath(List`1<IntPoint> pg, PolyType polyType, bool Closed);
    public bool AddPaths(List`1<List`1<IntPoint>> ppg, PolyType polyType, bool closed);
    internal bool Pt2IsBetweenPt1AndPt3(IntPoint pt1, IntPoint pt2, IntPoint pt3);
    private TEdge RemoveEdge(TEdge e);
    private void SetDx(TEdge e);
    private void InsertLocalMinima(LocalMinima newLm);
    protected void PopLocalMinima();
    private void ReverseHorizontal(TEdge e);
    protected virtual void Reset();
    public static IntRect GetBounds(List`1<List`1<IntPoint>> paths);
}
internal class iTextSharp.text.pdf.parser.clipper.ClipperException : Exception {
    public ClipperException(string description);
}
public class iTextSharp.text.pdf.parser.clipper.ClipperOffset : object {
    private static double two_pi;
    private static double def_arc_tolerance;
    private List`1<List`1<IntPoint>> m_destPolys;
    private List`1<IntPoint> m_srcPoly;
    private List`1<IntPoint> m_destPoly;
    private List`1<DoublePoint> m_normals;
    private double m_delta;
    private double m_sinA;
    private double m_sin;
    private double m_cos;
    private double m_miterLim;
    private double m_StepsPerRad;
    private double arcTolerance;
    private double miterLimit;
    private IntPoint m_lowest;
    private PolyNode m_polyNodes;
    public double ArcTolerance { get; public set; }
    public double MiterLimit { get; public set; }
    public ClipperOffset(double miterLimit, double arcTolerance);
    public double get_ArcTolerance();
    public void set_ArcTolerance(double value);
    public double get_MiterLimit();
    public void set_MiterLimit(double value);
    public void Clear();
    internal static long Round(double value);
    public void AddPath(List`1<IntPoint> path, JoinType joinType, EndType endType);
    public void AddPaths(List`1<List`1<IntPoint>> paths, JoinType joinType, EndType endType);
    private void FixOrientations();
    internal static DoublePoint GetUnitNormal(IntPoint pt1, IntPoint pt2);
    private void DoOffset(double delta);
    public void Execute(List`1& solution, double delta);
    public void Execute(PolyTree& solution, double delta);
    private void OffsetPoint(int j, Int32& k, JoinType jointype);
    internal void DoSquare(int j, int k, bool addExtra);
    internal void DoMiter(int j, int k, double r);
    internal void DoRound(int j, int k);
}
public enum iTextSharp.text.pdf.parser.clipper.ClipType : Enum {
    public int value__;
    public static ClipType ctIntersection;
    public static ClipType ctUnion;
    public static ClipType ctDifference;
    public static ClipType ctXor;
}
internal enum iTextSharp.text.pdf.parser.clipper.Direction : Enum {
    public int value__;
    public static Direction dRightToLeft;
    public static Direction dLeftToRight;
}
public class iTextSharp.text.pdf.parser.clipper.DoublePoint : ValueType {
    public double X;
    public double Y;
    public DoublePoint(double x, double y);
    public DoublePoint(DoublePoint dp);
    public DoublePoint(IntPoint ip);
}
internal enum iTextSharp.text.pdf.parser.clipper.EdgeSide : Enum {
    public int value__;
    public static EdgeSide esLeft;
    public static EdgeSide esRight;
}
public enum iTextSharp.text.pdf.parser.clipper.EndType : Enum {
    public int value__;
    public static EndType etClosedPolygon;
    public static EndType etClosedLine;
    public static EndType etOpenButt;
    public static EndType etOpenSquare;
    public static EndType etOpenRound;
}
internal class iTextSharp.text.pdf.parser.clipper.Int128 : ValueType {
    private long hi;
    private ulong lo;
    public Int128(long _lo);
    public Int128(long _hi, ulong _lo);
    public Int128(Int128 val);
    public bool IsNegative();
    public static bool op_Equality(Int128 val1, Int128 val2);
    public static bool op_Inequality(Int128 val1, Int128 val2);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public static bool op_GreaterThan(Int128 val1, Int128 val2);
    public static bool op_LessThan(Int128 val1, Int128 val2);
    public static Int128 op_Addition(Int128 lhs, Int128 rhs);
    public static Int128 op_Subtraction(Int128 lhs, Int128 rhs);
    public static Int128 op_UnaryNegation(Int128 val);
    public static double op_Explicit(Int128 val);
    public static Int128 Int128Mul(long lhs, long rhs);
}
public class iTextSharp.text.pdf.parser.clipper.IntersectNode : object {
    internal TEdge Edge1;
    internal TEdge Edge2;
    internal IntPoint Pt;
}
public class iTextSharp.text.pdf.parser.clipper.IntPoint : ValueType {
    public long X;
    public long Y;
    public IntPoint(long X, long Y);
    public IntPoint(double x, double y);
    public IntPoint(IntPoint pt);
    public static bool op_Equality(IntPoint a, IntPoint b);
    public static bool op_Inequality(IntPoint a, IntPoint b);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
}
public class iTextSharp.text.pdf.parser.clipper.IntRect : ValueType {
    public long left;
    public long top;
    public long right;
    public long bottom;
    public IntRect(long l, long t, long r, long b);
    public IntRect(IntRect ir);
}
internal class iTextSharp.text.pdf.parser.clipper.Join : object {
    internal OutPt OutPt1;
    internal OutPt OutPt2;
    internal IntPoint OffPt;
}
public enum iTextSharp.text.pdf.parser.clipper.JoinType : Enum {
    public int value__;
    public static JoinType jtBevel;
    public static JoinType jtRound;
    public static JoinType jtMiter;
}
internal class iTextSharp.text.pdf.parser.clipper.LocalMinima : object {
    internal long Y;
    internal TEdge LeftBound;
    internal TEdge RightBound;
    internal LocalMinima Next;
}
internal class iTextSharp.text.pdf.parser.clipper.Maxima : object {
    internal long X;
    internal Maxima Next;
    internal Maxima Prev;
}
public class iTextSharp.text.pdf.parser.clipper.MyIntersectNodeSort : object {
    public sealed virtual int Compare(IntersectNode node1, IntersectNode node2);
}
internal class iTextSharp.text.pdf.parser.clipper.OutPt : object {
    internal int Idx;
    internal IntPoint Pt;
    internal OutPt Next;
    internal OutPt Prev;
}
internal class iTextSharp.text.pdf.parser.clipper.OutRec : object {
    internal int Idx;
    internal bool IsHole;
    internal bool IsOpen;
    internal OutRec FirstLeft;
    internal OutPt Pts;
    internal OutPt BottomPt;
    internal PolyNode PolyNode;
}
public enum iTextSharp.text.pdf.parser.clipper.PolyFillType : Enum {
    public int value__;
    public static PolyFillType pftEvenOdd;
    public static PolyFillType pftNonZero;
    public static PolyFillType pftPositive;
    public static PolyFillType pftNegative;
}
public class iTextSharp.text.pdf.parser.clipper.PolyNode : object {
    internal PolyNode m_Parent;
    internal List`1<IntPoint> m_polygon;
    internal int m_Index;
    internal JoinType m_jointype;
    internal EndType m_endtype;
    internal List`1<PolyNode> m_Childs;
    internal bool isOpen;
    public int ChildCount { get; }
    public List`1<IntPoint> Contour { get; }
    public List`1<PolyNode> Childs { get; }
    public PolyNode Parent { get; }
    public bool IsHole { get; }
    public bool IsOpen { get; public set; }
    private bool IsHoleNode();
    public int get_ChildCount();
    public List`1<IntPoint> get_Contour();
    internal void AddChild(PolyNode Child);
    public PolyNode GetNext();
    internal PolyNode GetNextSiblingUp();
    public List`1<PolyNode> get_Childs();
    public PolyNode get_Parent();
    public bool get_IsHole();
    public bool get_IsOpen();
    public void set_IsOpen(bool value);
}
public class iTextSharp.text.pdf.parser.clipper.PolyTree : PolyNode {
    internal List`1<PolyNode> m_AllPolys;
    public int Total { get; }
    public void Clear();
    public PolyNode GetFirst();
    public int get_Total();
}
public enum iTextSharp.text.pdf.parser.clipper.PolyType : Enum {
    public int value__;
    public static PolyType ptSubject;
    public static PolyType ptClip;
}
internal class iTextSharp.text.pdf.parser.clipper.Scanbeam : object {
    internal long Y;
    internal Scanbeam Next;
}
internal class iTextSharp.text.pdf.parser.clipper.TEdge : object {
    internal IntPoint Bot;
    internal IntPoint Curr;
    internal IntPoint Top;
    internal IntPoint Delta;
    internal double Dx;
    internal PolyType PolyTyp;
    internal EdgeSide Side;
    internal int WindDelta;
    internal int WindCnt;
    internal int WindCnt2;
    internal int OutIdx;
    internal TEdge Next;
    internal TEdge Prev;
    internal TEdge NextInLML;
    internal TEdge NextInAEL;
    internal TEdge PrevInAEL;
    internal TEdge NextInSEL;
    internal TEdge PrevInSEL;
}
public class iTextSharp.text.pdf.parser.ContentByteUtils : object {
    public static Byte[] GetContentBytesFromContentObject(PdfObject contentObject);
    public static Byte[] GetContentBytesForPage(PdfReader reader, int pageNum);
}
public class iTextSharp.text.pdf.parser.FilteredRenderListener : object {
    private IRenderListener deleg;
    private RenderFilter[] filters;
    public FilteredRenderListener(IRenderListener deleg, RenderFilter[] filters);
    public virtual void RenderText(TextRenderInfo renderInfo);
    public virtual void BeginTextBlock();
    public virtual void EndTextBlock();
    public virtual void RenderImage(ImageRenderInfo renderInfo);
}
public class iTextSharp.text.pdf.parser.FilteredTextRenderListener : FilteredRenderListener {
    private ITextExtractionStrategy deleg;
    public FilteredTextRenderListener(ITextExtractionStrategy deleg, RenderFilter[] filters);
    public virtual string GetResultantText();
}
public class iTextSharp.text.pdf.parser.GlyphRenderListener : object {
    private IRenderListener deleg;
    public GlyphRenderListener(IRenderListener deleg);
    public virtual void BeginTextBlock();
    public virtual void RenderText(TextRenderInfo renderInfo);
    public virtual void EndTextBlock();
    public virtual void RenderImage(ImageRenderInfo renderInfo);
}
public class iTextSharp.text.pdf.parser.GlyphTextRenderListener : GlyphRenderListener {
    private ITextExtractionStrategy deleg;
    public GlyphTextRenderListener(ITextExtractionStrategy deleg);
    public virtual string GetResultantText();
}
public class iTextSharp.text.pdf.parser.GraphicsState : object {
    internal Matrix ctm;
    internal float characterSpacing;
    internal float wordSpacing;
    internal float horizontalScaling;
    internal float leading;
    internal CMapAwareDocumentFont font;
    internal float fontSize;
    internal int renderMode;
    internal float rise;
    internal bool knockout;
    internal PdfName colorSpaceFill;
    internal PdfName colorSpaceStroke;
    internal BaseColor fillColor;
    internal BaseColor strokeColor;
    private float lineWidth;
    private int lineCapStyle;
    private int lineJoinStyle;
    private float miterLimit;
    private LineDashPattern lineDashPattern;
    public float CharacterSpacing { get; }
    public float WordSpacing { get; }
    public float HorizontalScaling { get; }
    public CMapAwareDocumentFont Font { get; }
    public float FontSize { get; }
    public PdfName ColorSpaceFill { get; }
    public PdfName ColorSpaceStroke { get; }
    public BaseColor FillColor { get; }
    public BaseColor StrokeColor { get; }
    public float LineWidth { get; public set; }
    public int LineCapStyle { get; public set; }
    public int LineJoinStyle { get; public set; }
    public float MiterLimit { get; public set; }
    public GraphicsState(GraphicsState source);
    public virtual float get_CharacterSpacing();
    public virtual float get_WordSpacing();
    public virtual float get_HorizontalScaling();
    public virtual CMapAwareDocumentFont get_Font();
    public virtual float get_FontSize();
    public virtual Matrix GetCtm();
    public virtual float GetCharacterSpacing();
    public virtual float GetWordSpacing();
    public virtual float GetHorizontalScaling();
    public virtual float GetLeading();
    public virtual CMapAwareDocumentFont GetFont();
    public virtual float GetFontSize();
    public virtual int GetRenderMode();
    public virtual float GetRise();
    public virtual bool IsKnockout();
    public virtual PdfName get_ColorSpaceFill();
    public virtual PdfName get_ColorSpaceStroke();
    public virtual BaseColor get_FillColor();
    public virtual BaseColor get_StrokeColor();
    public float get_LineWidth();
    public void set_LineWidth(float value);
    public int get_LineCapStyle();
    public void set_LineCapStyle(int value);
    public int get_LineJoinStyle();
    public void set_LineJoinStyle(int value);
    public float get_MiterLimit();
    public void set_MiterLimit(float value);
    public virtual LineDashPattern GetLineDashPattern();
    public virtual void SetLineDashPattern(LineDashPattern lineDashPattern);
}
public interface iTextSharp.text.pdf.parser.IContentOperator {
    public abstract virtual void Invoke(PdfContentStreamProcessor processor, PdfLiteral oper, List`1<PdfObject> operands);
}
public interface iTextSharp.text.pdf.parser.IExtRenderListener {
    public abstract virtual void ModifyPath(PathConstructionRenderInfo renderInfo);
    public abstract virtual Path RenderPath(PathPaintingRenderInfo renderInfo);
    public abstract virtual void ClipPath(int rule);
}
public class iTextSharp.text.pdf.parser.ImageRenderInfo : object {
    private GraphicsState gs;
    private PdfIndirectReference refi;
    private InlineImageInfo inlineImageInfo;
    private PdfDictionary colorSpaceDictionary;
    private PdfImageObject imageObject;
    private ICollection`1<MarkedContentInfo> markedContentInfos;
    private ImageRenderInfo(GraphicsState gs, PdfIndirectReference refi, PdfDictionary colorSpaceDictionary, ICollection markedContentInfos);
    private ImageRenderInfo(GraphicsState gs, InlineImageInfo inlineImageInfo, PdfDictionary colorSpaceDictionary, ICollection markedContentInfos);
    public static ImageRenderInfo CreateForXObject(GraphicsState gs, PdfIndirectReference refi, PdfDictionary colorSpaceDictionary);
    public static ImageRenderInfo CreateForXObject(GraphicsState gs, PdfIndirectReference refi, PdfDictionary colorSpaceDictionary, ICollection markedContentInfos);
    protected internal static ImageRenderInfo CreateForEmbeddedImage(GraphicsState gs, InlineImageInfo inlineImageInfo, PdfDictionary colorSpaceDictionary, ICollection markedContentInfos);
    public virtual PdfImageObject GetImage();
    private void PrepareImageObject();
    public virtual Vector GetStartPoint();
    public virtual Matrix GetImageCTM();
    public virtual float GetArea();
    public virtual PdfIndirectReference GetRef();
    public BaseColor GetCurrentFillColor();
    public virtual bool HasMcid(int mcid);
    public virtual bool HasMcid(int mcid, bool checkTheTopmostLevelOnly);
    public virtual Nullable`1<int> GetMcid();
}
public class iTextSharp.text.pdf.parser.InlineImageInfo : object {
    private Byte[] samples;
    private PdfDictionary imageDictionary;
    public PdfDictionary ImageDictionary { get; }
    public Byte[] Samples { get; }
    public InlineImageInfo(Byte[] samples, PdfDictionary imageDictionary);
    public virtual PdfDictionary get_ImageDictionary();
    public virtual Byte[] get_Samples();
}
public static class iTextSharp.text.pdf.parser.InlineImageUtils : object {
    private static ILogger LOGGER;
    private static IDictionary`2<PdfName, PdfName> inlineImageEntryAbbreviationMap;
    private static IDictionary`2<PdfName, PdfName> inlineImageColorSpaceAbbreviationMap;
    private static IDictionary`2<PdfName, PdfName> inlineImageFilterAbbreviationMap;
    private static InlineImageUtils();
    public static InlineImageInfo ParseInlineImage(PdfContentParser ps, PdfDictionary colorSpaceDic);
    private static PdfDictionary ParseInlineImageDictionary(PdfContentParser ps);
    private static PdfObject GetAlternateValue(PdfName key, PdfObject value);
    private static int GetComponentsPerPixel(PdfName colorSpaceName, PdfDictionary colorSpaceDic);
    private static int ComputeBytesPerRow(PdfDictionary imageDictionary, PdfDictionary colorSpaceDic);
    private static Byte[] ParseUnfilteredSamples(PdfDictionary imageDictionary, PdfDictionary colorSpaceDic, PdfContentParser ps);
    private static Byte[] ParseInlineImageSamples(PdfDictionary imageDictionary, PdfDictionary colorSpaceDic, PdfContentParser ps);
    private static bool InlineImageStreamBytesAreComplete(Byte[] samples, PdfDictionary imageDictionary);
}
public interface iTextSharp.text.pdf.parser.IRenderListener {
    public abstract virtual void BeginTextBlock();
    public abstract virtual void RenderText(TextRenderInfo renderInfo);
    public abstract virtual void EndTextBlock();
    public abstract virtual void RenderImage(ImageRenderInfo renderInfo);
}
public interface iTextSharp.text.pdf.parser.IShape {
    public abstract virtual IList`1<Point2D> GetBasePoints();
}
public interface iTextSharp.text.pdf.parser.ITextExtractionStrategy {
    public abstract virtual string GetResultantText();
}
public interface iTextSharp.text.pdf.parser.IXObjectDoHandler {
    public abstract virtual void HandleXObject(PdfContentStreamProcessor processor, PdfStream stream, PdfIndirectReference refi);
    public abstract virtual void HandleXObject(PdfContentStreamProcessor processor, PdfStream stream, PdfIndirectReference refi, ICollection markedContentInfoStack);
}
public class iTextSharp.text.pdf.parser.Line : object {
    private Point2D p1;
    private Point2D p2;
    public Line(float x1, float y1, float x2, float y2);
    public Line(Point2D p1, Point2D p2);
    public virtual IList`1<Point2D> GetBasePoints();
}
public class iTextSharp.text.pdf.parser.LineDashPattern : object {
    private PdfArray dashArray;
    private float dashPhase;
    private int currentIndex;
    private int elemOrdinalNumber;
    private DashArrayElem currentElem;
    public PdfArray DashArray { get; public set; }
    public float DashPhase { get; public set; }
    public LineDashPattern(PdfArray dashArray, float dashPhase);
    public PdfArray get_DashArray();
    public void set_DashArray(PdfArray value);
    public float get_DashPhase();
    public void set_DashPhase(float value);
    public DashArrayElem Next();
    public bool IsSolid();
    public void Reset();
    private void InitFirst(float phase);
    private bool IsEven(int num);
}
public class iTextSharp.text.pdf.parser.LineSegment : object {
    private Vector startPoint;
    private Vector endPoint;
    public LineSegment(Vector startPoint, Vector endPoint);
    public virtual Vector GetStartPoint();
    public virtual Vector GetEndPoint();
    public virtual float GetLength();
    public virtual RectangleJ GetBoundingRectange();
    public virtual LineSegment TransformBy(Matrix m);
}
public class iTextSharp.text.pdf.parser.LocationTextExtractionStrategy : object {
    public static bool DUMP_STATE;
    private List`1<TextChunk> locationalResult;
    private ITextChunkLocationStrategy tclStrat;
    public LocationTextExtractionStrategy(ITextChunkLocationStrategy strat);
    private static LocationTextExtractionStrategy();
    public virtual void BeginTextBlock();
    public virtual void EndTextBlock();
    private bool StartsWithSpace(string str);
    private bool EndsWithSpace(string str);
    private List`1<TextChunk> filterTextChunks(List`1<TextChunk> textChunks, ITextChunkFilter filter);
    protected virtual bool IsChunkAtWordBoundary(TextChunk chunk, TextChunk previousChunk);
    public virtual string GetResultantText(ITextChunkFilter chunkFilter);
    public virtual string GetResultantText();
    private void DumpState();
    public virtual void RenderText(TextRenderInfo renderInfo);
    private static int CompareInts(int int1, int int2);
    public virtual void RenderImage(ImageRenderInfo renderInfo);
}
public class iTextSharp.text.pdf.parser.MarkedContentInfo : object {
    private PdfName tag;
    private PdfDictionary dictionary;
    public MarkedContentInfo(PdfName tag, PdfDictionary dictionary);
    public virtual PdfName GetTag();
    public virtual bool HasMcid();
    public virtual int GetMcid();
}
public class iTextSharp.text.pdf.parser.MarkedContentRenderFilter : RenderFilter {
    private int mcid;
    public MarkedContentRenderFilter(int mcid);
    public virtual bool AllowText(TextRenderInfo renderInfo);
}
[DefaultMemberAttribute("Item")]
public class iTextSharp.text.pdf.parser.Matrix : object {
    public static int I11;
    public static int I12;
    public static int I13;
    public static int I21;
    public static int I22;
    public static int I23;
    public static int I31;
    public static int I32;
    public static int I33;
    private Single[] vals;
    public float Item { get; }
    public Matrix(float tx, float ty);
    public Matrix(float a, float b, float c, float d, float e, float f);
    public float get_Item(int index);
    public virtual Matrix Multiply(Matrix by);
    public virtual Matrix Subtract(Matrix arg);
    public virtual float GetDeterminant();
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public virtual string ToString();
}
public class iTextSharp.text.pdf.parser.MultiFilteredRenderListener : object {
    private List`1<IRenderListener> delegates;
    private List`1<RenderFilter[]> filters;
    public virtual E AttachRenderListener(E deleg, RenderFilter[] filterSet);
    public virtual void BeginTextBlock();
    public virtual void RenderText(TextRenderInfo renderInfo);
    public virtual void EndTextBlock();
    public virtual void RenderImage(ImageRenderInfo renderInfo);
}
public class iTextSharp.text.pdf.parser.Path : object {
    private static string START_PATH_ERR_MSG;
    private IList`1<Subpath> subpaths;
    private Point2D currentPoint;
    public IList`1<Subpath> Subpaths { get; }
    public Point2D CurrentPoint { get; }
    private Subpath LastSubpath { get; }
    public Path(IList`1<Subpath> subpaths);
    private static Path();
    public virtual IList`1<Subpath> get_Subpaths();
    public void AddSubpath(Subpath subpath);
    public void AddSubpaths(IList`1<Subpath> subpaths);
    public virtual Point2D get_CurrentPoint();
    public virtual void MoveTo(float x, float y);
    public virtual void LineTo(float x, float y);
    public virtual void CurveTo(float x1, float y1, float x2, float y2, float x3, float y3);
    public virtual void CurveTo(float x2, float y2, float x3, float y3);
    public virtual void CurveFromTo(float x1, float y1, float x3, float y3);
    public virtual void Rectangle(float x, float y, float w, float h);
    public virtual void CloseSubpath();
    public virtual void CloseAllSubpaths();
    public virtual IList`1<int> ReplaceCloseWithLine();
    public virtual bool IsEmpty();
    private Subpath get_LastSubpath();
}
public class iTextSharp.text.pdf.parser.PathConstructionRenderInfo : object {
    public static int MOVETO;
    public static int LINETO;
    public static int CURVE_123;
    public static int CURVE_23;
    public static int CURVE_13;
    public static int CLOSE;
    public static int RECT;
    private int operation;
    private IList`1<float> segmentData;
    private Matrix ctm;
    public int Operation { get; }
    public IList`1<float> SegmentData { get; }
    public Matrix Ctm { get; }
    public PathConstructionRenderInfo(int operation, IList`1<float> segmentData, Matrix ctm);
    public PathConstructionRenderInfo(int operation, Matrix ctm);
    public virtual int get_Operation();
    public virtual IList`1<float> get_SegmentData();
    public virtual Matrix get_Ctm();
}
public class iTextSharp.text.pdf.parser.PathPaintingRenderInfo : object {
    public static int NONZERO_WINDING_RULE;
    public static int EVEN_ODD_RULE;
    public static int NO_OP;
    public static int STROKE;
    public static int FILL;
    private int operation;
    private int rule;
    private GraphicsState gs;
    public int Operation { get; }
    public int Rule { get; }
    public Matrix Ctm { get; }
    public float LineWidth { get; }
    public int LineCapStyle { get; }
    public int LineJoinStyle { get; }
    public float MiterLimit { get; }
    public LineDashPattern LineDashPattern { get; }
    public PathPaintingRenderInfo(int operation, int rule, GraphicsState gs);
    public PathPaintingRenderInfo(int operation, GraphicsState gs);
    public virtual int get_Operation();
    public virtual int get_Rule();
    public virtual Matrix get_Ctm();
    public virtual float get_LineWidth();
    public virtual int get_LineCapStyle();
    public virtual int get_LineJoinStyle();
    public virtual float get_MiterLimit();
    public virtual LineDashPattern get_LineDashPattern();
}
public class iTextSharp.text.pdf.parser.PdfContentReaderTool : object {
    public static string GetDictionaryDetail(PdfDictionary dic);
    public static string GetDictionaryDetail(PdfDictionary dic, int depth);
    public static string GetXObjectDetail(PdfDictionary resourceDic);
    public static void ListContentStreamForPage(PdfReader reader, int pageNum, TextWriter outp);
    public static void ListContentStream(string pdfFile, TextWriter outp);
    public static void ListContentStream(string pdfFile, int pageNum, TextWriter outp);
    public static void Main(String[] args);
}
public class iTextSharp.text.pdf.parser.PdfContentStreamProcessor : object {
    public static string DEFAULTOPERATOR;
    private IDictionary`2<string, IContentOperator> operators;
    private ResourceDictionary resources;
    private Stack`1<GraphicsState> gsStack;
    private Matrix textMatrix;
    private Matrix textLineMatrix;
    private IRenderListener renderListener;
    private IDictionary`2<PdfName, IXObjectDoHandler> xobjectDoHandlers;
    private IDictionary`2<int, WeakReference> cachedFonts;
    private Stack`1<MarkedContentInfo> markedContentStack;
    public ICollection`1<string> RegisteredOperatorStrings { get; }
    public IRenderListener RenderListener { get; }
    public PdfContentStreamProcessor(IRenderListener renderListener);
    private void PopulateXObjectDoHandlers();
    public virtual IXObjectDoHandler RegisterXObjectDoHandler(PdfName xobjectSubType, IXObjectDoHandler handler);
    private CMapAwareDocumentFont GetFont(PRIndirectReference ind);
    private CMapAwareDocumentFont GetFont(PdfDictionary fontResource);
    private void PopulateOperators();
    public virtual IContentOperator RegisterContentOperator(string operatorString, IContentOperator oper);
    public virtual ICollection`1<string> get_RegisteredOperatorStrings();
    public virtual void Reset();
    public GraphicsState Gs();
    private void InvokeOperator(PdfLiteral oper, List`1<PdfObject> operands);
    private void BeginMarkedContent(PdfName tag, PdfDictionary dict);
    private void EndMarkedContent();
    private void BeginText();
    private void EndText();
    private void DisplayPdfString(PdfString str);
    private void DisplayXObject(PdfName xobjectName);
    private void PaintPath(int operation, int rule, bool close);
    private void ModifyPath(int operation, IList`1<float> segmentData);
    private void ClipPath(int rule);
    private void ApplyTextAdjust(float tj);
    public virtual void ProcessContent(Byte[] contentBytes, PdfDictionary resources);
    protected virtual void HandleInlineImage(InlineImageInfo info, PdfDictionary colorSpaceDic);
    public virtual IRenderListener get_RenderListener();
    private static BaseColor GetColor(PdfName colorSpace, List`1<PdfObject> operands);
    private static BaseColor GetColor(int nOperands, List`1<PdfObject> operands);
}
public class iTextSharp.text.pdf.parser.PdfImageObject : object {
    private PdfDictionary dictionary;
    private Byte[] imageBytes;
    private PdfDictionary colorSpaceDic;
    private int pngColorType;
    private int pngBitDepth;
    private int width;
    private int height;
    private int bpc;
    private Byte[] palette;
    private Byte[] icc;
    private int stride;
    private ImageBytesType streamContentType;
    public PdfImageObject(PRStream stream);
    public PdfImageObject(PRStream stream, PdfDictionary colorSpaceDic);
    protected internal PdfImageObject(PdfDictionary dictionary, Byte[] samples, PdfDictionary colorSpaceDic);
    public virtual string GetFileType();
    public virtual ImageBytesType GetImageBytesType();
    public virtual PdfObject Get(PdfName key);
    public virtual PdfDictionary GetDictionary();
    private void FindColorspace(PdfObject colorspace, bool allowIndexed);
    private void DecodeImageBytes();
    public virtual Byte[] GetImageAsBytes();
    public Image GetDrawingImage();
}
public class iTextSharp.text.pdf.parser.PdfReaderContentParser : object {
    private PdfReader reader;
    public PdfReaderContentParser(PdfReader reader);
    public virtual E ProcessContent(int pageNumber, E renderListener, IDictionary`2<string, IContentOperator> additionalContentOperators);
    public virtual E ProcessContent(int pageNumber, E renderListener);
}
public static class iTextSharp.text.pdf.parser.PdfTextExtractor : object {
    public static string GetTextFromPage(PdfReader reader, int pageNumber, ITextExtractionStrategy strategy, IDictionary`2<string, IContentOperator> additionalContentOperators);
    public static string GetTextFromPage(PdfReader reader, int pageNumber, ITextExtractionStrategy strategy);
    public static string GetTextFromPage(PdfReader reader, int pageNumber);
}
public class iTextSharp.text.pdf.parser.RegionTextRenderFilter : RenderFilter {
    private RectangleJ filterRect;
    public RegionTextRenderFilter(RectangleJ filterRect);
    public RegionTextRenderFilter(Rectangle filterRect);
    public virtual bool AllowText(TextRenderInfo renderInfo);
}
public abstract class iTextSharp.text.pdf.parser.RenderFilter : object {
    public virtual bool AllowText(TextRenderInfo renderInfo);
    public virtual bool AllowImage(ImageRenderInfo renderInfo);
}
public class iTextSharp.text.pdf.parser.SimpleTextExtractionStrategy : object {
    private Vector lastStart;
    private Vector lastEnd;
    private StringBuilder result;
    public virtual void BeginTextBlock();
    public virtual void EndTextBlock();
    public virtual string GetResultantText();
    protected void AppendTextChunk(string text);
    protected void AppendTextChunk(char text);
    public virtual void RenderText(TextRenderInfo renderInfo);
    public virtual void RenderImage(ImageRenderInfo renderInfo);
}
public class iTextSharp.text.pdf.parser.Subpath : object {
    private Point2D startPoint;
    private IList`1<IShape> segments;
    private bool closed;
    public bool Closed { get; public set; }
    public Subpath(Subpath subpath);
    public Subpath(Point2D startPoint);
    public Subpath(float startPointX, float startPointY);
    public virtual void SetStartPoint(Point2D startPoint);
    public virtual void SetStartPoint(float x, float y);
    public virtual Point2D GetStartPoint();
    public Point2D GetLastPoint();
    public virtual void AddSegment(IShape segment);
    public virtual IList`1<IShape> GetSegments();
    public virtual bool IsEmpty();
    public virtual bool IsSinglePointOpen();
    public virtual bool IsSinglePointClosed();
    public virtual bool get_Closed();
    public virtual void set_Closed(bool value);
    public virtual bool IsDegenerate();
    public virtual IList`1<Point2D> GetPiecewiseLinearApproximation();
}
public class iTextSharp.text.pdf.parser.TaggedPdfReaderTool : object {
    protected internal PdfReader reader;
    protected internal StreamWriter outp;
    public virtual void ConvertToXml(PdfReader reader, Stream os, Encoding encoding);
    public virtual void ConvertToXml(PdfReader reader, Stream os);
    public virtual void InspectChild(PdfObject k);
    public virtual void InspectChildArray(PdfArray k);
    public virtual void InspectChildDictionary(PdfDictionary k);
    public virtual void InspectChildDictionary(PdfDictionary k, bool inspectAttributes);
    protected virtual string XmlName(PdfName name);
    private static string FixTagName(string tag);
    public virtual void ParseTag(string tag, PdfObject obj, PdfDictionary page);
}
public class iTextSharp.text.pdf.parser.TextMarginFinder : object {
    private RectangleJ textRectangle;
    public virtual void RenderText(TextRenderInfo renderInfo);
    public virtual float GetLlx();
    public virtual float GetLly();
    public virtual float GetUrx();
    public virtual float GetUry();
    public virtual float GetWidth();
    public virtual float GetHeight();
    public virtual void BeginTextBlock();
    public virtual void EndTextBlock();
    public virtual void RenderImage(ImageRenderInfo renderInfo);
}
public class iTextSharp.text.pdf.parser.TextRenderInfo : object {
    private PdfString string;
    private string text;
    private Matrix textToUserSpaceTransformMatrix;
    private GraphicsState gs;
    private Nullable`1<float> unscaledWidth;
    private Double[] fontMatrix;
    private static Encoding utf_16BeEncoding;
    private ICollection`1<MarkedContentInfo> markedContentInfos;
    public PdfString PdfString { get; }
    private Encoding Utf_16BeEncoding { get; }
    internal TextRenderInfo(PdfString string, GraphicsState gs, Matrix textMatrix, ICollection markedContentInfo);
    private TextRenderInfo(TextRenderInfo parent, PdfString string, float horizontalOffset);
    public virtual string GetText();
    public virtual PdfString get_PdfString();
    public virtual bool HasMcid(int mcid);
    public virtual bool HasMcid(int mcid, bool checkTheTopmostLevelOnly);
    public virtual Nullable`1<int> GetMcid();
    internal float GetUnscaledWidth();
    public virtual LineSegment GetBaseline();
    public virtual LineSegment GetUnscaledBaseline();
    public virtual LineSegment GetAscentLine();
    public virtual LineSegment GetDescentLine();
    private LineSegment GetUnscaledBaselineWithOffset(float yOffset);
    public virtual DocumentFont GetFont();
    public virtual float GetRise();
    private float ConvertWidthFromTextSpaceToUserSpace(float width);
    private float ConvertHeightFromTextSpaceToUserSpace(float height);
    public virtual float GetSingleSpaceWidth();
    public virtual int GetTextRenderMode();
    public virtual BaseColor GetFillColor();
    public virtual BaseColor GetStrokeColor();
    private float GetUnscaledFontSpaceWidth();
    private float GetStringWidth(string string);
    private float GetPdfStringWidth(PdfString string, bool singleCharString);
    public virtual IList`1<TextRenderInfo> GetCharacterRenderInfos();
    private Single[] GetWidthAndWordSpacing(PdfString string, bool singleCharString);
    private string Decode(PdfString in);
    private string DecodeSingleCharacter(PdfString in);
    private int GetCharCode(string string);
    private PdfString[] SplitString(PdfString string);
    private Encoding get_Utf_16BeEncoding();
}
[DefaultMemberAttribute("Item")]
public class iTextSharp.text.pdf.parser.Vector : object {
    public static int I1;
    public static int I2;
    public static int I3;
    private Single[] vals;
    public float Item { get; }
    public float Length { get; }
    public float LengthSquared { get; }
    public Vector(float x, float y, float z);
    public float get_Item(int index);
    public virtual Vector Cross(Matrix by);
    public virtual Vector Subtract(Vector v);
    public virtual Vector Cross(Vector with);
    public virtual Vector Normalize();
    public virtual Vector Multiply(float by);
    public virtual float Dot(Vector with);
    public virtual float get_Length();
    public virtual float get_LengthSquared();
    public virtual string ToString();
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
}
public class iTextSharp.text.pdf.PatternColor : ExtendedColor {
    private PdfPatternPainter painter;
    public PdfPatternPainter Painter { get; }
    public PatternColor(PdfPatternPainter painter);
    public virtual PdfPatternPainter get_Painter();
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
}
public class iTextSharp.text.pdf.PdfAcroForm : PdfDictionary {
    private PdfWriter writer;
    private Dictionary`2<PdfTemplate, object> fieldTemplates;
    private PdfArray documentFields;
    private PdfArray calculationOrder;
    private int sigFlags;
    unknown bool NeedAppearances {public set; }
    unknown int SigFlags {public set; }
    public PdfAcroForm(PdfWriter writer);
    public virtual void set_NeedAppearances(bool value);
    public virtual void AddFieldTemplates(Dictionary`2<PdfTemplate, object> ft);
    public virtual void AddDocumentField(PdfIndirectReference piref);
    public virtual bool IsValid();
    public virtual void AddCalculationOrder(PdfFormField formField);
    public virtual void set_SigFlags(int value);
    public virtual void AddFormField(PdfFormField formField);
    public virtual PdfFormField AddHtmlPostButton(string name, string caption, string value, string url, BaseFont font, float fontSize, float llx, float lly, float urx, float ury);
    public virtual PdfFormField AddResetButton(string name, string caption, string value, BaseFont font, float fontSize, float llx, float lly, float urx, float ury);
    public virtual PdfFormField AddMap(string name, string value, string url, PdfContentByte appearance, float llx, float lly, float urx, float ury);
    public virtual void SetButtonParams(PdfFormField button, int characteristics, string name, string value);
    public virtual void DrawButton(PdfFormField button, string caption, BaseFont font, float fontSize, float llx, float lly, float urx, float ury);
    public virtual PdfFormField AddHiddenField(string name, string value);
    public virtual PdfFormField AddSingleLineTextField(string name, string text, BaseFont font, float fontSize, float llx, float lly, float urx, float ury);
    public virtual PdfFormField AddMultiLineTextField(string name, string text, BaseFont font, float fontSize, float llx, float lly, float urx, float ury);
    public virtual PdfFormField AddSingleLinePasswordField(string name, string text, BaseFont font, float fontSize, float llx, float lly, float urx, float ury);
    public virtual void SetTextFieldParams(PdfFormField field, string text, string name, float llx, float lly, float urx, float ury);
    public virtual void DrawSingleLineOfText(PdfFormField field, string text, BaseFont font, float fontSize, float llx, float lly, float urx, float ury);
    public virtual void DrawMultiLineOfText(PdfFormField field, string text, BaseFont font, float fontSize, float llx, float lly, float urx, float ury);
    public virtual PdfFormField AddCheckBox(string name, string value, bool status, float llx, float lly, float urx, float ury);
    public virtual void SetCheckBoxParams(PdfFormField field, string name, string value, bool status, float llx, float lly, float urx, float ury);
    public virtual void DrawCheckBoxAppearences(PdfFormField field, string value, float llx, float lly, float urx, float ury);
    public virtual PdfFormField GetRadioGroup(string name, string defaultValue, bool noToggleToOff);
    public virtual void AddRadioGroup(PdfFormField radiogroup);
    public virtual PdfFormField AddRadioButton(PdfFormField radiogroup, string value, float llx, float lly, float urx, float ury);
    public virtual void DrawRadioAppearences(PdfFormField field, string value, float llx, float lly, float urx, float ury);
    public virtual PdfFormField AddSelectList(string name, String[] options, string defaultValue, BaseFont font, float fontSize, float llx, float lly, float urx, float ury);
    public virtual PdfFormField AddSelectList(string name, String[0...,0...] options, string defaultValue, BaseFont font, float fontSize, float llx, float lly, float urx, float ury);
    public virtual PdfFormField AddComboBox(string name, String[] options, string defaultValue, bool editable, BaseFont font, float fontSize, float llx, float lly, float urx, float ury);
    public virtual PdfFormField AddComboBox(string name, String[0...,0...] options, string defaultValue, bool editable, BaseFont font, float fontSize, float llx, float lly, float urx, float ury);
    public virtual void SetChoiceParams(PdfFormField field, string name, string defaultValue, float llx, float lly, float urx, float ury);
    public virtual PdfFormField AddSignature(string name, float llx, float lly, float urx, float ury);
    public virtual void SetSignatureParams(PdfFormField field, string name, float llx, float lly, float urx, float ury);
    public virtual void DrawSignatureAppearences(PdfFormField field, float llx, float lly, float urx, float ury);
    public virtual void ToPdf(PdfWriter writer, Stream os);
}
public class iTextSharp.text.pdf.PdfAction : PdfDictionary {
    public static int FIRSTPAGE;
    public static int PREVPAGE;
    public static int NEXTPAGE;
    public static int LASTPAGE;
    public static int PRINTDIALOG;
    public static int SUBMIT_EXCLUDE;
    public static int SUBMIT_INCLUDE_NO_VALUE_FIELDS;
    public static int SUBMIT_HTML_FORMAT;
    public static int SUBMIT_HTML_GET;
    public static int SUBMIT_COORDINATES;
    public static int SUBMIT_XFDF;
    public static int SUBMIT_INCLUDE_APPEND_SAVES;
    public static int SUBMIT_INCLUDE_ANNOTATIONS;
    public static int SUBMIT_PDF;
    public static int SUBMIT_CANONICAL_FORMAT;
    public static int SUBMIT_EXCL_NON_USER_ANNOTS;
    public static int SUBMIT_EXCL_F_KEY;
    public static int SUBMIT_EMBED_FORM;
    public static int RESET_EXCLUDE;
    public PdfAction(Uri url);
    public PdfAction(Uri url, bool isMap);
    public PdfAction(string url);
    public PdfAction(string url, bool isMap);
    internal PdfAction(PdfIndirectReference destination);
    public PdfAction(string filename, string name);
    public PdfAction(string filename, int page);
    public PdfAction(int named);
    public PdfAction(string application, string parameters, string operation, string defaultDir);
    public static PdfAction CreateLaunch(string application, string parameters, string operation, string defaultDir);
    public static PdfAction Rendition(string file, PdfFileSpecification fs, string mimeType, PdfIndirectReference refi);
    public static PdfAction JavaScript(string code, PdfWriter writer, bool unicode);
    public static PdfAction JavaScript(string code, PdfWriter writer);
    internal static PdfAction CreateHide(PdfObject obj, bool hide);
    public static PdfAction CreateHide(PdfAnnotation annot, bool hide);
    public static PdfAction CreateHide(string name, bool hide);
    internal static PdfArray BuildArray(Object[] names);
    public static PdfAction CreateHide(Object[] names, bool hide);
    public static PdfAction CreateSubmitForm(string file, Object[] names, int flags);
    public static PdfAction CreateResetForm(Object[] names, int flags);
    public static PdfAction CreateImportData(string file);
    public virtual void Next(PdfAction na);
    public static PdfAction GotoLocalPage(int page, PdfDestination dest, PdfWriter writer);
    public static PdfAction GotoLocalPage(string dest, bool isName);
    public static PdfAction GotoRemotePage(string filename, string dest, bool isName, bool newWindow);
    public static PdfAction GotoEmbedded(string filename, PdfTargetDictionary target, string dest, bool isName, bool newWindow);
    public static PdfAction GotoEmbedded(string filename, PdfTargetDictionary target, PdfObject dest, bool newWindow);
    public static PdfAction SetOCGstate(List`1<object> state, bool preserveRB);
    public virtual void ToPdf(PdfWriter writer, Stream os);
}
public class iTextSharp.text.pdf.PdfAnnotation : PdfDictionary {
    public static int FLAGS_INVISIBLE;
    public static int FLAGS_HIDDEN;
    public static int FLAGS_PRINT;
    public static int FLAGS_NOZOOM;
    public static int FLAGS_NOROTATE;
    public static int FLAGS_NOVIEW;
    public static int FLAGS_READONLY;
    public static int FLAGS_LOCKED;
    public static int FLAGS_TOGGLENOVIEW;
    public static int FLAGS_LOCKEDCONTENTS;
    public static int MARKUP_HIGHLIGHT;
    public static int MARKUP_UNDERLINE;
    public static int MARKUP_STRIKEOUT;
    public static int MARKUP_SQUIGGLY;
    public static PdfName HIGHLIGHT_NONE;
    public static PdfName HIGHLIGHT_INVERT;
    public static PdfName HIGHLIGHT_OUTLINE;
    public static PdfName HIGHLIGHT_PUSH;
    public static PdfName HIGHLIGHT_TOGGLE;
    public static PdfName APPEARANCE_NORMAL;
    public static PdfName APPEARANCE_ROLLOVER;
    public static PdfName APPEARANCE_DOWN;
    public static PdfName AA_ENTER;
    public static PdfName AA_EXIT;
    public static PdfName AA_DOWN;
    public static PdfName AA_UP;
    public static PdfName AA_FOCUS;
    public static PdfName AA_BLUR;
    public static PdfName AA_JS_KEY;
    public static PdfName AA_JS_FORMAT;
    public static PdfName AA_JS_CHANGE;
    public static PdfName AA_JS_OTHER_CHANGE;
    protected internal PdfWriter writer;
    protected internal PdfIndirectReference reference;
    protected internal HashSet2`1<PdfTemplate> templates;
    protected internal bool form;
    protected internal bool annotation;
    protected internal bool used;
    private int placeInPage;
    protected PdfName role;
    protected Dictionary`2<PdfName, PdfObject> accessibleAttributes;
    private AccessibleElementId id;
    public PdfIndirectReference IndirectReference { get; }
    unknown PdfContentByte DefaultAppearanceString {public set; }
    unknown int Flags {public set; }
    unknown PdfBorderArray Border {public set; }
    unknown PdfBorderDictionary BorderStyle {public set; }
    unknown string AppearanceState {public set; }
    unknown BaseColor Color {public set; }
    unknown string Title {public set; }
    unknown PdfAnnotation Popup {public set; }
    unknown PdfAction Action {public set; }
    [ObsoleteAttribute("Use GetTemplates() instead")]
public Dictionary`2<PdfTemplate, object> Templates { get; }
    unknown int Page {public set; }
    public int PlaceInPage { get; public set; }
    unknown int Rotate {public set; }
    internal PdfDictionary MK { get; }
    unknown int MKRotation {public set; }
    unknown BaseColor MKBorderColor {public set; }
    unknown BaseColor MKBackgroundColor {public set; }
    unknown string MKNormalCaption {public set; }
    unknown string MKRolloverCaption {public set; }
    unknown string MKAlternateCaption {public set; }
    unknown PdfTemplate MKNormalIcon {public set; }
    unknown PdfTemplate MKRolloverIcon {public set; }
    unknown PdfTemplate MKAlternateIcon {public set; }
    unknown int MKTextPosition {public set; }
    unknown IPdfOCG Layer {public set; }
    unknown string Name {public set; }
    public PdfName Role { get; public set; }
    public AccessibleElementId ID { get; public set; }
    public bool IsInline { get; }
    public PdfAnnotation(PdfWriter writer, Rectangle rect);
    public PdfAnnotation(PdfWriter writer, float llx, float lly, float urx, float ury, PdfString title, PdfString content);
    public PdfAnnotation(PdfWriter writer, float llx, float lly, float urx, float ury, PdfAction action);
    private static PdfAnnotation();
    public static PdfAnnotation CreateScreen(PdfWriter writer, Rectangle rect, string clipTitle, PdfFileSpecification fs, string mimeType, bool playOnDisplay);
    public virtual PdfIndirectReference get_IndirectReference();
    public static PdfAnnotation CreateText(PdfWriter writer, Rectangle rect, string title, string contents, bool open, string icon);
    protected static PdfAnnotation CreateLink(PdfWriter writer, Rectangle rect, PdfName highlight);
    public static PdfAnnotation CreateLink(PdfWriter writer, Rectangle rect, PdfName highlight, PdfAction action);
    public static PdfAnnotation CreateLink(PdfWriter writer, Rectangle rect, PdfName highlight, string namedDestination);
    public static PdfAnnotation CreateLink(PdfWriter writer, Rectangle rect, PdfName highlight, int page, PdfDestination dest);
    public static PdfAnnotation CreateFreeText(PdfWriter writer, Rectangle rect, string contents, PdfContentByte defaultAppearance);
    public static PdfAnnotation CreateLine(PdfWriter writer, Rectangle rect, string contents, float x1, float y1, float x2, float y2);
    public static PdfAnnotation CreateSquareCircle(PdfWriter writer, Rectangle rect, string contents, bool square);
    public static PdfAnnotation CreateMarkup(PdfWriter writer, Rectangle rect, string contents, int type, Single[] quadPoints);
    public static PdfAnnotation CreateStamp(PdfWriter writer, Rectangle rect, string contents, string name);
    public static PdfAnnotation CreateInk(PdfWriter writer, Rectangle rect, string contents, Single[][] inkList);
    public static PdfAnnotation CreateFileAttachment(PdfWriter writer, Rectangle rect, string contents, Byte[] fileStore, string file, string fileDisplay);
    public static PdfAnnotation CreateFileAttachment(PdfWriter writer, Rectangle rect, string contents, PdfFileSpecification fs);
    public static PdfAnnotation CreatePopup(PdfWriter writer, Rectangle rect, string contents, bool open);
    public static PdfAnnotation CreatePolygonPolyline(PdfWriter writer, Rectangle rect, string contents, bool polygon, PdfArray vertices);
    public virtual void set_DefaultAppearanceString(PdfContentByte value);
    public virtual void set_Flags(int value);
    public virtual void set_Border(PdfBorderArray value);
    public virtual void set_BorderStyle(PdfBorderDictionary value);
    public virtual void SetHighlighting(PdfName highlight);
    public virtual void SetAppearance(PdfName ap, PdfTemplate template);
    public virtual void SetAppearance(PdfName ap, string state, PdfTemplate template);
    public virtual void set_AppearanceState(string value);
    public virtual void set_Color(BaseColor value);
    public virtual void set_Title(string value);
    public virtual void set_Popup(PdfAnnotation value);
    public virtual void set_Action(PdfAction value);
    public virtual void SetAdditionalActions(PdfName key, PdfAction action);
    internal virtual bool IsUsed();
    public virtual void SetUsed();
    public virtual Dictionary`2<PdfTemplate, object> get_Templates();
    public virtual HashSet2`1<PdfTemplate> GetTemplates();
    public virtual bool IsForm();
    public virtual bool IsAnnotation();
    public virtual void set_Page(int value);
    public virtual void SetPage();
    public virtual int get_PlaceInPage();
    public virtual void set_PlaceInPage(int value);
    public static PdfAnnotation ShallowDuplicate(PdfAnnotation annot);
    public virtual void set_Rotate(int value);
    internal PdfDictionary get_MK();
    public virtual void set_MKRotation(int value);
    public static PdfArray GetMKColor(BaseColor color);
    public virtual void set_MKBorderColor(BaseColor value);
    public virtual void set_MKBackgroundColor(BaseColor value);
    public virtual void set_MKNormalCaption(string value);
    public virtual void set_MKRolloverCaption(string value);
    public virtual void set_MKAlternateCaption(string value);
    public virtual void set_MKNormalIcon(PdfTemplate value);
    public virtual void set_MKRolloverIcon(PdfTemplate value);
    public virtual void set_MKAlternateIcon(PdfTemplate value);
    public virtual void SetMKIconFit(PdfName scale, PdfName scalingType, float leftoverLeft, float leftoverBottom, bool fitInBounds);
    public virtual void set_MKTextPosition(int value);
    public virtual void set_Layer(IPdfOCG value);
    public virtual void set_Name(string value);
    public virtual void ApplyCTM(AffineTransform ctm);
    [ObsoleteAttribute]
public void ApplyCTM(Matrix ctm);
    public virtual void ToPdf(PdfWriter writer, Stream os);
    public virtual PdfObject GetAccessibleAttribute(PdfName key);
    public virtual void SetAccessibleAttribute(PdfName key, PdfObject value);
    public virtual Dictionary`2<PdfName, PdfObject> GetAccessibleAttributes();
    public virtual PdfName get_Role();
    public virtual void set_Role(PdfName value);
    public virtual AccessibleElementId get_ID();
    public virtual void set_ID(AccessibleElementId value);
    public virtual bool get_IsInline();
}
public class iTextSharp.text.pdf.PdfAppearance : PdfTemplate {
    public static Dictionary`2<string, PdfName> stdFieldFontNames;
    public PdfContentByte Duplicate { get; }
    private static PdfAppearance();
    internal PdfAppearance(PdfIndirectReference iref);
    internal PdfAppearance(PdfWriter wr);
    public static PdfAppearance CreateAppearance(PdfWriter writer, float width, float height);
    internal static PdfAppearance CreateAppearance(PdfWriter writer, float width, float height, PdfName forcedName);
    public virtual void SetFontAndSize(BaseFont bf, float size);
    public virtual PdfContentByte get_Duplicate();
}
[DefaultMemberAttribute("Item")]
public class iTextSharp.text.pdf.PdfArray : PdfObject {
    protected List`1<PdfObject> arrayList;
    public PdfObject Item { get; public set; }
    public List`1<PdfObject> ArrayList { get; }
    public int Size { get; }
    public PdfArray(int capcity);
    public PdfArray(PdfObject obj);
    public PdfArray(Single[] values);
    public PdfArray(Int32[] values);
    public PdfArray(IList`1<PdfObject> l);
    public PdfArray(PdfArray array);
    public virtual void ToPdf(PdfWriter writer, Stream os);
    public PdfObject get_Item(int idx);
    public void set_Item(int idx, PdfObject value);
    public virtual PdfObject GetPdfObject(int idx);
    public virtual PdfObject Set(int idx, PdfObject obj);
    public virtual PdfObject Remove(int idx);
    public virtual List`1<PdfObject> get_ArrayList();
    public virtual int get_Size();
    public virtual bool IsEmpty();
    public virtual bool Add(PdfObject obj);
    public virtual bool Add(Single[] values);
    public virtual bool Add(Int32[] values);
    public virtual void Add(int index, PdfObject element);
    public virtual void AddFirst(PdfObject obj);
    public virtual bool Contains(PdfObject obj);
    public virtual ListIterator`1<PdfObject> GetListIterator();
    public virtual string ToString();
    public virtual PdfObject GetDirectObject(int idx);
    public virtual PdfDictionary GetAsDict(int idx);
    public virtual PdfArray GetAsArray(int idx);
    public virtual PdfStream GetAsStream(int idx);
    public virtual PdfString GetAsString(int idx);
    public virtual PdfNumber GetAsNumber(int idx);
    public virtual PdfName GetAsName(int idx);
    public virtual PdfBoolean GetAsBoolean(int idx);
    public virtual PdfIndirectReference GetAsIndirectObject(int idx);
    public virtual IEnumerator`1<PdfObject> GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    public virtual Int64[] AsLongArray();
    public Double[] AsDoubleArray();
}
public class iTextSharp.text.pdf.PdfArtifact : object {
    protected PdfName role;
    protected Dictionary`2<PdfName, PdfObject> accessibleAttributes;
    protected AccessibleElementId id;
    private static HashSet2`1<string> allowedArtifactTypes;
    public PdfName Role { get; public set; }
    public AccessibleElementId ID { get; public set; }
    public bool IsInline { get; }
    public PdfString Type { get; public set; }
    public PdfArray BBox { get; public set; }
    public PdfArray Attached { get; public set; }
    private static PdfArtifact();
    public virtual PdfObject GetAccessibleAttribute(PdfName key);
    public virtual void SetAccessibleAttribute(PdfName key, PdfObject value);
    public virtual Dictionary`2<PdfName, PdfObject> GetAccessibleAttributes();
    public virtual PdfName get_Role();
    public virtual void set_Role(PdfName value);
    public virtual AccessibleElementId get_ID();
    public virtual void set_ID(AccessibleElementId value);
    public virtual bool get_IsInline();
    public virtual PdfString get_Type();
    public virtual void set_Type(PdfString value);
    public virtual void SetType(ArtifactType type);
    public virtual PdfArray get_BBox();
    public virtual void set_BBox(PdfArray value);
    public virtual PdfArray get_Attached();
    public virtual void set_Attached(PdfArray value);
}
public class iTextSharp.text.pdf.PdfBody : Rectangle {
    public int Type { get; }
    public IList`1<Chunk> Chunks { get; }
    public PdfBody(Rectangle rectangle);
    public virtual bool Process(IElementListener listener);
    public virtual int get_Type();
    public virtual bool IsContent();
    public virtual bool IsNestable();
    public virtual IList`1<Chunk> get_Chunks();
}
public class iTextSharp.text.pdf.PdfBoolean : PdfObject {
    public static string TRUE;
    public static string FALSE;
    public static PdfBoolean PDFTRUE;
    public static PdfBoolean PDFFALSE;
    private bool value;
    public bool BooleanValue { get; }
    public PdfBoolean(bool value);
    public PdfBoolean(string value);
    private static PdfBoolean();
    public virtual bool get_BooleanValue();
    public virtual string ToString();
}
public class iTextSharp.text.pdf.PdfBorderArray : PdfArray {
    public PdfBorderArray(float hRadius, float vRadius, float width);
    public PdfBorderArray(float hRadius, float vRadius, float width, PdfDashPattern dash);
}
public class iTextSharp.text.pdf.PdfBorderDictionary : PdfDictionary {
    public static int STYLE_SOLID;
    public static int STYLE_DASHED;
    public static int STYLE_BEVELED;
    public static int STYLE_INSET;
    public static int STYLE_UNDERLINE;
    public PdfBorderDictionary(float borderWidth, int borderStyle, PdfDashPattern dashes);
    public PdfBorderDictionary(float borderWidth, int borderStyle);
}
public class iTextSharp.text.pdf.PdfChunk : object {
    private static float ITALIC_ANGLE;
    private static string TABSTOP;
    public static float UNDERLINE_THICKNESS;
    public static float UNDERLINE_OFFSET;
    private static Char[] singleSpace;
    private static Dictionary`2<string, object> keysAttributes;
    private static Dictionary`2<string, object> keysNoStroke;
    protected string value;
    protected string encoding;
    protected PdfFont font;
    protected BaseFont baseFont;
    protected ISplitCharacter splitCharacter;
    protected Dictionary`2<string, object> attributes;
    protected Dictionary`2<string, object> noStroke;
    protected bool newlineSplit;
    protected Image image;
    protected float imageScalePercentage;
    protected float offsetX;
    protected float offsetY;
    protected bool changeLeading;
    protected float leading;
    internal IAccessibleElement accessibleElement;
    internal PdfFont Font { get; }
    internal BaseColor Color { get; }
    public float TextRise { get; }
    internal TabStop TabStop { get; internal set; }
    internal Image Image { get; }
    internal float ImageHeight { get; }
    internal float ImageWidth { get; }
    public float ImageScalePercentage { get; public set; }
    internal float ImageOffsetX { get; internal set; }
    internal float ImageOffsetY { get; internal set; }
    unknown string Value {internal set; }
    internal string Encoding { get; }
    internal int Length { get; }
    internal int LengthUtf32 { get; }
    public bool ChangeLeading { get; }
    public float Leading { get; }
    private static PdfChunk();
    internal PdfChunk(string str, PdfChunk other);
    internal PdfChunk(Chunk chunk, PdfAction action);
    internal PdfChunk(Chunk chunk, PdfAction action, TabSettings tabSettings);
    public virtual int GetUnicodeEquivalent(int c);
    protected virtual int GetWord(string text, int start);
    internal PdfChunk Split(float width);
    internal PdfChunk Truncate(float width);
    internal PdfFont get_Font();
    internal BaseColor get_Color();
    internal float Width();
    internal float Width(string str);
    internal float Height();
    public virtual bool IsNewlineSplit();
    public virtual float GetWidthCorrected(float charSpacing, float wordSpacing);
    public virtual float get_TextRise();
    public virtual float TrimLastSpace();
    public virtual float TrimFirstSpace();
    internal object GetAttribute(string name);
    internal bool IsAttribute(string name);
    internal bool IsStroked();
    internal bool IsSeparator();
    internal bool IsHorizontalSeparator();
    internal bool IsTab();
    [ObsoleteAttribute]
internal void AdjustLeft(float newValue);
    internal static TabStop GetTabStop(PdfChunk tab, float tabPosition);
    internal TabStop get_TabStop();
    internal void set_TabStop(TabStop value);
    internal bool IsImage();
    internal Image get_Image();
    internal float get_ImageHeight();
    internal float get_ImageWidth();
    public virtual float get_ImageScalePercentage();
    public virtual void set_ImageScalePercentage(float value);
    internal float get_ImageOffsetX();
    internal void set_ImageOffsetX(float value);
    internal float get_ImageOffsetY();
    internal void set_ImageOffsetY(float value);
    internal void set_Value(string value);
    public virtual string ToString();
    internal bool IsSpecialEncoding();
    internal string get_Encoding();
    internal int get_Length();
    internal int get_LengthUtf32();
    internal bool IsExtSplitCharacter(int start, int current, int end, Char[] cc, PdfChunk[] ck);
    internal string Trim(string str);
    public virtual bool get_ChangeLeading();
    public virtual float get_Leading();
    internal float GetCharWidth(int c);
    public static bool NoPrint(int c);
}
internal class iTextSharp.text.pdf.PdfColor : PdfArray {
    internal PdfColor(int red, int green, int blue);
    internal PdfColor(BaseColor color);
}
public class iTextSharp.text.pdf.PdfConcatenate : object {
    protected internal Document document;
    protected internal PdfCopy copy;
    public PdfCopy Writer { get; }
    public PdfConcatenate(Stream os);
    public PdfConcatenate(Stream os, bool smart);
    public virtual int AddPages(PdfReader reader);
    public virtual PdfCopy get_Writer();
    public virtual void Open();
    public virtual void Close();
}
public class iTextSharp.text.pdf.PdfContentByte : object {
    public static int ALIGN_CENTER;
    public static int ALIGN_LEFT;
    public static int ALIGN_RIGHT;
    public static int LINE_CAP_BUTT;
    public static int LINE_CAP_ROUND;
    public static int LINE_CAP_PROJECTING_SQUARE;
    public static int LINE_JOIN_MITER;
    public static int LINE_JOIN_ROUND;
    public static int LINE_JOIN_BEVEL;
    public static int TEXT_RENDER_MODE_FILL;
    public static int TEXT_RENDER_MODE_STROKE;
    public static int TEXT_RENDER_MODE_FILL_STROKE;
    public static int TEXT_RENDER_MODE_INVISIBLE;
    public static int TEXT_RENDER_MODE_FILL_CLIP;
    public static int TEXT_RENDER_MODE_STROKE_CLIP;
    public static int TEXT_RENDER_MODE_FILL_STROKE_CLIP;
    public static int TEXT_RENDER_MODE_CLIP;
    private static Single[] unitRect;
    protected ByteBuffer content;
    protected int markedContentSize;
    protected internal PdfWriter writer;
    protected internal PdfDocument pdf;
    protected GraphicState state;
    protected List`1<int> layerDepth;
    protected List`1<GraphicState> stateList;
    protected int separator;
    private bool suppressTagging;
    private int mcDepth;
    private bool inText;
    private IList`1<IAccessibleElement> mcElements;
    protected internal PdfContentByte duplicatedFrom;
    private static Dictionary`2<PdfName, string> abrev;
    public bool SuppressTagging { get; public set; }
    public ByteBuffer InternalBuffer { get; }
    public float XTLM { get; }
    public float YTLM { get; }
    public float CharacterSpacing { get; }
    public float WordSpacing { get; }
    public float HorizontalScaling { get; }
    public float Leading { get; }
    internal int Size { get; }
    public PdfOutline RootOutline { get; }
    public PdfWriter PdfWriter { get; }
    public PdfDocument PdfDocument { get; }
    public PdfContentByte Duplicate { get; }
    internal PageResources PageResources { get; }
    protected PdfIndirectReference CurrentPage { get; }
    protected internal bool InText { get; }
    private static PdfContentByte();
    public PdfContentByte(PdfWriter wr);
    public virtual string ToString();
    public bool get_SuppressTagging();
    public void set_SuppressTagging(bool value);
    public virtual bool IsTagged();
    public virtual ByteBuffer get_InternalBuffer();
    public virtual Byte[] ToPdf(PdfWriter writer);
    public virtual void Add(PdfContentByte other);
    public virtual float get_XTLM();
    public virtual float get_YTLM();
    public virtual float get_CharacterSpacing();
    public virtual float get_WordSpacing();
    public virtual float get_HorizontalScaling();
    public virtual float get_Leading();
    public virtual void SetLeading(float v);
    public virtual void SetFlatness(float value);
    public virtual void SetFlatness(double value);
    public virtual void SetLineCap(int value);
    public virtual void SetRenderingIntent(PdfName ri);
    public virtual void SetLineDash(float value);
    public virtual void SetLineDash(double value);
    public virtual void SetLineDash(float unitsOn, float phase);
    public virtual void SetLineDash(double unitsOn, double phase);
    public virtual void SetLineDash(float unitsOn, float unitsOff, float phase);
    public virtual void SetLineDash(double unitsOn, double unitsOff, double phase);
    public void SetLineDash(Single[] array, float phase);
    public void SetLineDash(Double[] array, double phase);
    public virtual void SetLineJoin(int value);
    public virtual void SetLineWidth(float value);
    public virtual void SetLineWidth(double value);
    public virtual void SetMiterLimit(float value);
    public virtual void SetMiterLimit(double value);
    public virtual void Clip();
    public virtual void EoClip();
    public virtual void SetGrayFill(float value);
    public virtual void ResetGrayFill();
    public virtual void SetGrayStroke(float value);
    public virtual void ResetGrayStroke();
    private void HelperRGB(float red, float green, float blue);
    public virtual void SetRGBColorFillF(float red, float green, float blue);
    public virtual void ResetRGBColorFill();
    public virtual void SetRGBColorStrokeF(float red, float green, float blue);
    public virtual void ResetRGBColorStroke();
    private void HelperCMYK(float cyan, float magenta, float yellow, float black);
    public virtual void SetCMYKColorFillF(float cyan, float magenta, float yellow, float black);
    public virtual void ResetCMYKColorFill();
    public virtual void SetCMYKColorStrokeF(float cyan, float magenta, float yellow, float black);
    public virtual void ResetCMYKColorStroke();
    public virtual void MoveTo(float x, float y);
    public virtual void MoveTo(double x, double y);
    public virtual void LineTo(float x, float y);
    public virtual void LineTo(double x, double y);
    public virtual void CurveTo(float x1, float y1, float x2, float y2, float x3, float y3);
    public virtual void CurveTo(double x1, double y1, double x2, double y2, double x3, double y3);
    public virtual void CurveTo(float x2, float y2, float x3, float y3);
    public virtual void CurveTo(double x2, double y2, double x3, double y3);
    public virtual void CurveFromTo(float x1, float y1, float x3, float y3);
    public virtual void CurveFromTo(double x1, double y1, double x3, double y3);
    public virtual void Circle(float x, float y, float r);
    public virtual void Circle(double x, double y, double r);
    public virtual void Rectangle(float x, float y, float w, float h);
    public virtual void Rectangle(double x, double y, double w, double h);
    private bool CompareColors(BaseColor c1, BaseColor c2);
    public virtual void VariableRectangle(Rectangle rect);
    public virtual void Rectangle(Rectangle rectangle);
    public virtual void ClosePath();
    public virtual void NewPath();
    public virtual void Stroke();
    public virtual void ClosePathStroke();
    public virtual void Fill();
    public virtual void EoFill();
    public virtual void FillStroke();
    public virtual void ClosePathFillStroke();
    public virtual void EoFillStroke();
    public virtual void ClosePathEoFillStroke();
    public virtual void AddImage(Image image);
    public virtual void AddImage(Image image, bool inlineImage);
    public virtual void AddImage(Image image, float a, float b, float c, float d, float e, float f);
    public virtual void AddImage(Image image, double a, double b, double c, double d, double e, double f);
    public virtual void AddImage(Image image, AffineTransform transform);
    [ObsoleteAttribute]
public void AddImage(Image image, Matrix transform);
    public virtual void AddImage(Image image, float a, float b, float c, float d, float e, float f, bool inlineImage);
    public virtual void AddImage(Image image, double a, double b, double c, double d, double e, double f, bool inlineImage);
    protected internal void AddImage(Image image, double a, double b, double c, double d, double e, double f, bool inlineImage, bool isMCBlockOpened);
    public virtual void Reset();
    public virtual void Reset(bool validateContent);
    protected internal virtual void BeginText(bool restoreTM);
    public virtual void BeginText();
    public virtual void EndText();
    public virtual void SaveState();
    public virtual void RestoreState();
    public virtual void SetCharacterSpacing(float value);
    public virtual void SetWordSpacing(float value);
    public virtual void SetHorizontalScaling(float value);
    public virtual void SetFontAndSize(BaseFont bf, float size);
    public virtual void SetTextRenderingMode(int value);
    public virtual void SetTextRise(float value);
    public virtual void SetTextRise(double value);
    private void ShowText2(string text);
    public virtual void ShowText(string text);
    public virtual void ShowTextGid(string gids);
    public static PdfTextArray GetKernArray(string text, BaseFont font);
    public virtual void ShowTextKerned(string text);
    public virtual void NewlineShowText(string text);
    public virtual void NewlineShowText(float wordSpacing, float charSpacing, string text);
    public virtual void SetTextMatrix(float a, float b, float c, float d, float x, float y);
    public virtual void SetTextMatrix(AffineTransform transform);
    [ObsoleteAttribute]
public void SetTextMatrix(Matrix transform);
    public virtual void SetTextMatrix(float x, float y);
    public virtual void MoveText(float x, float y);
    public virtual void MoveTextWithLeading(float x, float y);
    public virtual void NewlineText();
    internal int get_Size();
    internal int GetSize(bool includeMarkedContentSize);
    public virtual void AddOutline(PdfOutline outline, string name);
    public virtual PdfOutline get_RootOutline();
    public virtual float GetEffectiveStringWidth(string text, bool kerned);
    private float GetEffectiveStringWidth(string text, bool kerned, float kerning);
    public virtual void ShowTextAligned(int alignment, string text, float x, float y, float rotation);
    private void ShowTextAligned(int alignment, string text, float x, float y, float rotation, bool kerned);
    public virtual void ShowTextAlignedKerned(int alignment, string text, float x, float y, float rotation);
    public virtual void ConcatCTM(float a, float b, float c, float d, float e, float f);
    public virtual void ConcatCTM(double a, double b, double c, double d, double e, double f);
    public virtual void ConcatCTM(AffineTransform transform);
    [ObsoleteAttribute]
public void ConcatCTM(Matrix transform);
    public static List`1<Double[]> BezierArc(float x1, float y1, float x2, float y2, float startAng, float extent);
    public static List`1<Double[]> BezierArc(double x1, double y1, double x2, double y2, double startAng, double extent);
    public virtual void Arc(float x1, float y1, float x2, float y2, float startAng, float extent);
    public virtual void Arc(double x1, double y1, double x2, double y2, double startAng, double extent);
    public virtual void Ellipse(double x1, double y1, double x2, double y2);
    public virtual void Ellipse(float x1, float y1, float x2, float y2);
    public virtual PdfPatternPainter CreatePattern(float width, float height, float xstep, float ystep);
    public virtual PdfPatternPainter CreatePattern(float width, float height);
    public virtual PdfPatternPainter CreatePattern(float width, float height, float xstep, float ystep, BaseColor color);
    public virtual PdfPatternPainter CreatePattern(float width, float height, BaseColor color);
    public virtual PdfTemplate CreateTemplate(float width, float height);
    internal PdfTemplate CreateTemplate(float width, float height, PdfName forcedName);
    public virtual PdfAppearance CreateAppearance(float width, float height);
    internal PdfAppearance CreateAppearance(float width, float height, PdfName forcedName);
    public virtual void AddPSXObject(PdfPSXObject psobject);
    public virtual void AddTemplate(PdfTemplate template, float a, float b, float c, float d, float e, float f);
    public virtual void AddTemplate(PdfTemplate template, double a, double b, double c, double d, double e, double f);
    public virtual void AddTemplate(PdfTemplate template, float a, float b, float c, float d, float e, float f, bool tagContent);
    public virtual void AddTemplate(PdfTemplate template, double a, double b, double c, double d, double e, double f, bool tagContent);
    public virtual void AddTemplate(PdfTemplate template, double a, double b, double c, double d, double e, double f, bool tagTemplate, bool tagContent);
    public virtual PdfName AddFormXObj(PdfStream formXObj, PdfName name, float a, float b, float c, float d, float e, float f);
    public virtual PdfName AddFormXObj(PdfStream formXObj, PdfName name, double a, double b, double c, double d, double e, double f);
    public virtual void AddTemplate(PdfTemplate template, AffineTransform transform);
    public virtual void AddTemplate(PdfTemplate template, AffineTransform transform, bool tagContent);
    [ObsoleteAttribute]
public void AddTemplate(PdfTemplate template, Matrix transform, bool tagContent);
    [ObsoleteAttribute]
public void AddTemplate(PdfTemplate template, Matrix transform);
    internal void AddTemplateReference(PdfIndirectReference template, PdfName name, float a, float b, float c, float d, float e, float f);
    internal void AddTemplateReference(PdfIndirectReference template, PdfName name, double a, double b, double c, double d, double e, double f);
    public virtual void AddTemplate(PdfTemplate template, float x, float y);
    public virtual void AddTemplate(PdfTemplate template, double x, double y);
    public virtual void AddTemplate(PdfTemplate template, float x, float y, bool tagContent);
    public virtual void AddTemplate(PdfTemplate template, double x, double y, bool tagContent);
    public virtual void SetCMYKColorFill(int cyan, int magenta, int yellow, int black);
    public virtual void SetCMYKColorStroke(int cyan, int magenta, int yellow, int black);
    public virtual void SetRGBColorFill(int red, int green, int blue);
    public virtual void SetRGBColorStroke(int red, int green, int blue);
    public virtual void SetColorStroke(BaseColor value);
    public virtual void SetColorFill(BaseColor value);
    public virtual void SetColorFill(PdfSpotColor sp, float tint);
    public virtual void SetColorFill(PdfDeviceNColor dn, Single[] tints);
    public virtual void SetColorFill(PdfLabColor lab, float l, float a, float b);
    public virtual void SetColorStroke(PdfSpotColor sp, float tint);
    public virtual void SetColorStroke(PdfDeviceNColor sp, Single[] tints);
    public virtual void SetColorStroke(PdfLabColor lab, float l, float a, float b);
    public virtual void SetPatternFill(PdfPatternPainter p);
    internal void OutputColorNumbers(BaseColor color, float tint);
    public virtual void SetPatternFill(PdfPatternPainter p, BaseColor color);
    public virtual void SetPatternFill(PdfPatternPainter p, BaseColor color, float tint);
    public virtual void SetPatternStroke(PdfPatternPainter p, BaseColor color);
    public virtual void SetPatternStroke(PdfPatternPainter p, BaseColor color, float tint);
    public virtual void SetPatternStroke(PdfPatternPainter p);
    public virtual void PaintShading(PdfShading shading);
    public virtual void PaintShading(PdfShadingPattern shading);
    public virtual void SetShadingFill(PdfShadingPattern shading);
    public virtual void SetShadingStroke(PdfShadingPattern shading);
    protected virtual void CheckWriter();
    public virtual void ShowText(PdfTextArray text);
    public virtual PdfWriter get_PdfWriter();
    public virtual PdfDocument get_PdfDocument();
    public virtual void LocalGoto(string name, float llx, float lly, float urx, float ury);
    public virtual bool LocalDestination(string name, PdfDestination destination);
    public virtual PdfContentByte get_Duplicate();
    public virtual PdfContentByte GetDuplicate(bool inheritGraphicState);
    public virtual void InheritGraphicState(PdfContentByte parentCanvas);
    public virtual void RemoteGoto(string filename, string name, float llx, float lly, float urx, float ury);
    public virtual void RemoteGoto(string filename, int page, float llx, float lly, float urx, float ury);
    public virtual void RoundRectangle(float x, float y, float w, float h, float r);
    public virtual void RoundRectangle(double x, double y, double w, double h, double r);
    public virtual void SetAction(PdfAction action, float llx, float lly, float urx, float ury);
    public virtual void SetLiteral(string s);
    public virtual void SetLiteral(char c);
    public virtual void SetLiteral(float n);
    internal void CheckNoPattern(PdfTemplate t);
    public virtual void DrawRadioField(float llx, float lly, float urx, float ury, bool on);
    public virtual void DrawRadioField(double llx, double lly, double urx, double ury, bool on);
    public virtual void DrawTextField(float llx, float lly, float urx, float ury);
    public virtual void DrawTextField(double llx, double lly, double urx, double ury);
    public virtual void DrawButton(float llx, float lly, float urx, float ury, string text, BaseFont bf, float size);
    public virtual void DrawButton(double llx, double lly, double urx, double ury, string text, BaseFont bf, float size);
    internal virtual PageResources get_PageResources();
    public virtual void SetGState(PdfGState gstate);
    public virtual void BeginLayer(IPdfOCG layer);
    private void BeginLayer2(IPdfOCG layer);
    public virtual void EndLayer();
    internal virtual void AddAnnotation(PdfAnnotation annot);
    public virtual void AddAnnotation(PdfAnnotation annot, bool applyCTM);
    public virtual void SetDefaultColorspace(PdfName name, PdfObject obj);
    public virtual void Transform(AffineTransform af);
    [ObsoleteAttribute]
public void Transform(Matrix tx);
    public virtual void BeginMarkedContentSequence(PdfStructureElement struc);
    public virtual void BeginMarkedContentSequence(PdfStructureElement struc, string expansion);
    protected virtual PdfIndirectReference get_CurrentPage();
    public virtual void EndMarkedContentSequence();
    public virtual void BeginMarkedContentSequence(PdfName tag, PdfDictionary property, bool inline);
    public virtual void BeginMarkedContentSequence(PdfName tag);
    public virtual void SanityCheck();
    public virtual void OpenMCBlock(IAccessibleElement element);
    private PdfDictionary GetParentStructureElement();
    private PdfStructureElement OpenMCBlockInt(IAccessibleElement element);
    public virtual void CloseMCBlock(IAccessibleElement element);
    private void CloseMCBlockInt(IAccessibleElement element);
    private void EnsureDocumentTagIsOpen();
    internal IList`1<IAccessibleElement> SaveMCBlocks();
    internal void RestoreMCBlocks(IList`1<IAccessibleElement> mcElements);
    internal int GetMcDepth();
    internal void SetMcDepth(int value);
    internal IList`1<IAccessibleElement> GetMcElements();
    internal void SetMcElements(IList`1<IAccessibleElement> value);
    internal void UpdateTx(string text, float Tj);
    private void SaveColor(BaseColor color, bool fill);
    protected internal virtual bool get_InText();
    protected virtual void CheckState();
}
public class iTextSharp.text.pdf.PdfContentParser : object {
    public static int COMMAND_TYPE;
    private PRTokeniser tokeniser;
    public PRTokeniser Tokeniser { get; public set; }
    public PdfContentParser(PRTokeniser tokeniser);
    public virtual List`1<PdfObject> Parse(List`1<PdfObject> ls);
    public virtual PRTokeniser GetTokeniser();
    public virtual void set_Tokeniser(PRTokeniser value);
    public virtual PRTokeniser get_Tokeniser();
    public virtual PdfDictionary ReadDictionary();
    public virtual PdfArray ReadArray();
    public virtual PdfObject ReadPRObject();
    public virtual bool NextValidToken();
}
public class iTextSharp.text.pdf.PdfContents : PdfStream {
    internal static Byte[] SAVESTATE;
    internal static Byte[] RESTORESTATE;
    internal static Byte[] ROTATE90;
    internal static Byte[] ROTATE180;
    internal static Byte[] ROTATE270;
    internal static Byte[] ROTATEFINAL;
    internal PdfContents(PdfContentByte under, PdfContentByte content, PdfContentByte text, PdfContentByte secondContent, Rectangle page);
    private static PdfContents();
}
public class iTextSharp.text.pdf.PdfCopy : PdfWriter {
    private static ILogger LOGGER;
    protected static ICounter COUNTER;
    protected internal Dictionary`2<RefKey, IndirectReferences> indirects;
    protected Dictionary`2<PdfReader, Dictionary`2<RefKey, IndirectReferences>> indirectMap;
    protected Dictionary`2<PdfObject, PdfObject> parentObjects;
    protected HashSet2`1<PdfObject> disableIndirects;
    protected PdfReader reader;
    protected Int32[] namePtr;
    private bool rotateContents;
    protected internal PdfArray fieldArray;
    protected internal HashSet2`1<PdfTemplate> fieldTemplates;
    private PdfStructTreeController structTreeController;
    private int currentStructArrayNumber;
    protected PRIndirectReference structTreeRootReference;
    protected Dictionary`2<RefKey, PdfIndirectObject> indirectObjects;
    protected List`1<PdfIndirectObject> savedObjects;
    protected List`1<ImportedPage> importedPages;
    internal bool updateRootKids;
    private static PdfName annotId;
    private static int annotIdCnt;
    protected bool mergeFields;
    private bool needAppearances;
    private bool hasSignature;
    private PdfIndirectReference acroForm;
    private Dictionary`2<PdfArray, List`1<int>> tabOrder;
    private List`1<object> calculationOrderRefs;
    private PdfDictionary resources;
    protected List`1<AcroFields> fields;
    private List`1<string> calculationOrder;
    private Dictionary`2<string, object> fieldTree;
    private Dictionary`2<int, PdfIndirectObject> unmergedMap;
    private Dictionary`2<RefKey, PdfIndirectObject> unmergedIndirectRefsMap;
    private Dictionary`2<int, PdfIndirectObject> mergedMap;
    private HashSet2`1<PdfIndirectObject> mergedSet;
    private bool mergeFieldsInternalCall;
    private static PdfName iTextTag;
    internal static int zero;
    private HashSet2`1<object> mergedRadioButtons;
    private Dictionary`2<object, PdfString> mergedTextFields;
    private HashSet2`1<PdfReader> readersWithImportedStructureTreeRootKids;
    protected static HashSet2`1<PdfName> widgetKeys;
    protected static HashSet2`1<PdfName> fieldKeys;
    unknown IPdfPageEvent PageEvent {public set; }
    public bool RotateContents { get; public set; }
    public PdfCopy(Document document, Stream os);
    private static PdfCopy();
    protected virtual ICounter GetCounter();
    public virtual void set_PageEvent(IPdfPageEvent value);
    public virtual void set_RotateContents(bool value);
    public virtual bool get_RotateContents();
    public virtual void SetMergeFields();
    public virtual PdfImportedPage GetImportedPage(PdfReader reader, int pageNumber);
    public virtual PdfImportedPage GetImportedPage(PdfReader reader, int pageNumber, bool keepTaggedPdfStructure);
    private void ClearIndirects(PdfReader reader);
    private int CheckStructureTreeRootKids(ImportedPage newPage);
    protected internal virtual void StructureTreeRootKidsForReaderImported(PdfReader reader);
    internal virtual void FixStructureTreeRoot(HashSet2`1<RefKey> activeKeys, HashSet2`1<PdfName> activeClassMaps);
    protected virtual PdfImportedPage GetImportedPageImpl(PdfReader reader, int pageNumber);
    protected internal virtual PdfIndirectReference CopyIndirect(PRIndirectReference inp, bool keepStructure, bool directRootKids);
    protected virtual PdfIndirectReference CopyIndirect(PRIndirectReference inp);
    protected virtual PdfDictionary CopyDictionary(PdfDictionary inp, bool keepStruct, bool directRootKids);
    protected virtual PdfDictionary CopyDictionary(PdfDictionary inp);
    protected virtual PdfStream CopyStream(PRStream inp);
    protected virtual PdfArray CopyArray(PdfArray inp, bool keepStruct, bool directRootKids);
    protected virtual PdfArray CopyArray(PdfArray inp);
    protected internal virtual PdfObject CopyObject(PdfObject inp, bool keepStruct, bool directRootKids);
    protected internal virtual PdfObject CopyObject(PdfObject inp);
    protected virtual int SetFromIPage(PdfImportedPage iPage);
    protected virtual void SetFromReader(PdfReader reader);
    public virtual void AddPage(PdfImportedPage iPage);
    public virtual void AddPage(Rectangle rect, int rotation);
    public virtual void AddDocument(PdfReader reader, List`1<int> pagesToKeep);
    public virtual void CopyDocumentFields(PdfReader reader);
    public virtual void AddDocument(PdfReader reader);
    public virtual PdfIndirectObject AddToBody(PdfObject objecta, PdfIndirectReference refa);
    public virtual PdfIndirectObject AddToBody(PdfObject objecta, PdfIndirectReference refa, bool formBranching);
    protected internal virtual void CacheObject(PdfIndirectObject iobj);
    internal virtual void FlushTaggedObjects();
    internal virtual void FlushAcroFields();
    protected virtual void FixTaggedStructure();
    private void RemoveInactiveReferences(PdfArray array, HashSet2`1<RefKey> activeKeys);
    private bool ContainsInactivePg(PdfDictionary dict, HashSet2`1<RefKey> activeKeys);
    private List`1<PdfIndirectReference> FindActiveParents(HashSet2`1<RefKey> activeKeys);
    private void FixPgKey(List`1<PdfIndirectReference> newRefs, HashSet2`1<RefKey> activeKeys);
    private void FindActives(List`1<PdfIndirectReference> actives, HashSet2`1<RefKey> activeKeys, HashSet2`1<PdfName> activeClassMaps);
    private void FindActivesFromReference(PdfIndirectReference iref, List`1<PdfIndirectReference> actives, HashSet2`1<RefKey> activeKeys);
    private void FindActivesFromArray(PdfArray array, List`1<PdfIndirectReference> actives, HashSet2`1<RefKey> activeKeys, HashSet2`1<PdfName> activeClassMaps);
    private void FindActivesFromDict(PdfDictionary dict, List`1<PdfIndirectReference> actives, HashSet2`1<RefKey> activeKeys, HashSet2`1<PdfName> activeClassMaps);
    protected virtual void FlushIndirectObjects();
    private void WriteObjectToBody(PdfIndirectObject objecta);
    private void UpdateAnnotationReferences(PdfObject obj);
    private void UpdateCalculationOrder(PdfReader reader);
    private static string GetCOName(PdfReader reader, PRIndirectReference refa);
    private void MergeFields();
    private void AddPageOffsetToField(IDictionary`2<string, Item> fd, int pageOffset);
    private void MergeWithMaster(IDictionary`2<string, Item> fd);
    internal void MergeField(string name, Item item);
    private void CreateWidgets(List`1<object> list, Item item);
    private PdfObject Propagate(PdfObject obj);
    private void CreateAcroForms();
    private void UpdateReferences(PdfObject obj);
    private PdfArray BranchForm(Dictionary`2<string, object> level, PdfIndirectReference parent, string fname);
    private void AdjustTabOrder(PdfArray annots, PdfIndirectReference ind, PdfNumber nn);
    protected virtual PdfDictionary GetCatalog(PdfIndirectReference rootObj);
    protected virtual bool IsStructTreeRootReference(PdfIndirectReference prRef);
    private void AddFieldResources(PdfDictionary catalog);
    public virtual void Close();
    public virtual void AddAnnotation(PdfAnnotation annot);
    internal virtual PdfIndirectReference Add(PdfPage page, PdfContents contents);
    public virtual void FreeReader(PdfReader reader);
    protected virtual PdfName GetOffStateName(PdfDictionary widget);
    internal static Nullable`1<int> GetFlags(PdfDictionary field);
    internal static bool IsCheckButton(PdfDictionary field);
    internal static bool IsRadioButton(PdfDictionary field);
    internal static bool IsTextField(PdfDictionary field);
    public virtual PageStamp CreatePageStamp(PdfImportedPage iPage);
}
[ObsoleteAttribute]
public class iTextSharp.text.pdf.PdfCopyFields : object {
    private PdfCopyFieldsImp fc;
    unknown IList`1<Dictionary`2<string, object>> Outlines {public set; }
    public PdfWriter Writer { get; }
    public bool FullCompression { get; }
    unknown int ViewerPreferences {public set; }
    public PdfCopyFields(Stream os);
    public PdfCopyFields(Stream os, char pdfVersion);
    public virtual void AddDocument(PdfReader reader);
    public virtual void AddDocument(PdfReader reader, IList`1<int> pagesToKeep);
    public virtual void AddDocument(PdfReader reader, string ranges);
    public virtual void SetEncryption(Byte[] userPassword, Byte[] ownerPassword, int permissions, bool strength128Bits);
    public virtual void SetEncryption(bool strength, string userPassword, string ownerPassword, int permissions);
    public virtual void Close();
    public virtual void Open();
    public virtual void AddJavaScript(string js);
    public virtual void set_Outlines(IList`1<Dictionary`2<string, object>> value);
    public virtual PdfWriter get_Writer();
    public virtual bool get_FullCompression();
    public virtual void SetFullCompression();
    public virtual void SetEncryption(Byte[] userPassword, Byte[] ownerPassword, int permissions, int encryptionType);
    public virtual void AddViewerPreference(PdfName key, PdfObject value);
    public virtual void set_ViewerPreferences(int value);
    public virtual void SetEncryption(X509Certificate[] certs, Int32[] permissions, int encryptionType);
}
[ObsoleteAttribute]
internal class iTextSharp.text.pdf.PdfCopyFieldsImp : PdfWriter {
    internal static PdfName iTextTag;
    internal static int zero;
    internal List`1<PdfReader> readers;
    internal Dictionary`2<PdfReader, IntHashtable> readers2intrefs;
    internal Dictionary`2<PdfReader, IntHashtable> pages2intrefs;
    internal Dictionary`2<PdfReader, IntHashtable> visited;
    internal List`1<AcroFields> fields;
    internal RandomAccessFileOrArray file;
    internal Dictionary`2<string, object> fieldTree;
    internal List`1<PdfIndirectReference> pageRefs;
    internal List`1<PdfDictionary> pageDics;
    internal PdfDictionary resources;
    internal PdfDictionary form;
    private bool closing;
    internal Document nd;
    private Dictionary`2<PdfArray, List`1<int>> tabOrder;
    private List`1<string> calculationOrder;
    private List`1<object> calculationOrderRefs;
    private bool hasSignature;
    private bool needAppearances;
    private Dictionary`2<object, object> mergedRadioButtons;
    protected ICounter COUNTER;
    protected internal static Dictionary`2<PdfName, int> widgetKeys;
    protected internal static Dictionary`2<PdfName, int> fieldKeys;
    internal PdfCopyFieldsImp(Stream os);
    internal PdfCopyFieldsImp(Stream os, char pdfVersion);
    private static PdfCopyFieldsImp();
    protected virtual ICounter GetCounter();
    internal void AddDocument(PdfReader reader, ICollection`1<int> pagesToKeep);
    internal void AddDocument(PdfReader reader);
    internal static string GetCOName(PdfReader reader, PRIndirectReference refi);
    protected internal virtual void UpdateCalculationOrder(PdfReader reader);
    internal void Propagate(PdfObject obj, PdfIndirectReference refo, bool restricted);
    private void AdjustTabOrder(PdfArray annots, PdfIndirectReference ind, PdfNumber nn);
    protected virtual PdfArray BranchForm(Dictionary`2<string, object> level, PdfIndirectReference parent, string fname);
    protected virtual PdfName GetOffStateName(PdfDictionary widget);
    protected virtual void CreateAcroForms();
    public virtual void Close();
    protected virtual void CloseIt();
    internal void AddPageOffsetToField(IDictionary`2<string, Item> fd, int pageOffset);
    internal void CreateWidgets(List`1<object> list, Item item);
    internal void MergeField(string name, Item item);
    internal void MergeWithMaster(IDictionary`2<string, Item> fd);
    internal virtual void MergeFields();
    public virtual PdfIndirectReference GetPageReference(int page);
    protected virtual PdfDictionary GetCatalog(PdfIndirectReference rootObj);
    protected virtual PdfIndirectReference GetNewReference(PRIndirectReference refi);
    protected internal virtual int GetNewObjectNumber(PdfReader reader, int number, int generation);
    protected internal virtual bool SetVisited(PRIndirectReference refi);
    protected internal virtual bool IsVisited(PRIndirectReference refi);
    protected internal virtual bool IsVisited(PdfReader reader, int number, int generation);
    protected internal virtual bool IsPage(PRIndirectReference refi);
    internal virtual RandomAccessFileOrArray GetReaderFile(PdfReader reader);
    public virtual void OpenDoc();
}
public class iTextSharp.text.pdf.PdfCopyForms : object {
    private PdfCopyFormsImp fc;
    unknown IList`1<Dictionary`2<string, object>> Outlines {public set; }
    public PdfWriter Writer { get; }
    public bool FullCompression { get; }
    unknown int ViewerPreferences {public set; }
    public PdfCopyForms(Stream os);
    public virtual void AddDocument(PdfReader reader);
    public virtual void AddDocument(PdfReader reader, ICollection`1<int> pagesToKeep);
    public virtual void AddDocument(PdfReader reader, string ranges);
    public virtual void CopyDocumentFields(PdfReader reader);
    public virtual void SetEncryption(Byte[] userPassword, Byte[] ownerPassword, int permissions, bool strength128Bits);
    public virtual void SetEncryption(bool strength, string userPassword, string ownerPassword, int permissions);
    public virtual void Close();
    public virtual void Open();
    public virtual void AddJavaScript(string js);
    public virtual void set_Outlines(IList`1<Dictionary`2<string, object>> value);
    public virtual PdfWriter get_Writer();
    public virtual bool get_FullCompression();
    public virtual void SetFullCompression();
    public virtual void SetEncryption(Byte[] userPassword, Byte[] ownerPassword, int permissions, int encryptionType);
    public virtual void AddViewerPreference(PdfName key, PdfObject value);
    public virtual void set_ViewerPreferences(int value);
    public virtual void SetEncryption(X509Certificate[] certs, Int32[] permissions, int encryptionType);
}
internal class iTextSharp.text.pdf.PdfCopyFormsImp : PdfCopyFieldsImp {
    internal PdfCopyFormsImp(Stream os);
    public virtual void CopyDocumentFields(PdfReader reader);
    internal virtual void MergeFields();
}
public class iTextSharp.text.pdf.PdfDashPattern : PdfArray {
    private float dash;
    private float gap;
    private float phase;
    public PdfDashPattern(float dash);
    public PdfDashPattern(float dash, float gap);
    public PdfDashPattern(float dash, float gap, float phase);
    public virtual void Add(float n);
    public virtual void ToPdf(PdfWriter writer, Stream os);
}
public class iTextSharp.text.pdf.PdfDate : PdfString {
    public PdfDate(DateTime d);
    private static string SetLength(int i, int length);
    public virtual string GetW3CDate();
    public static string GetW3CDate(string d);
    public static DateTime Decode(string date);
}
public class iTextSharp.text.pdf.PdfDestination : PdfArray {
    public static int XYZ;
    public static int FIT;
    public static int FITH;
    public static int FITV;
    public static int FITR;
    public static int FITB;
    public static int FITBH;
    public static int FITBV;
    private bool status;
    public PdfDestination(int type);
    public PdfDestination(int type, float parameter);
    public PdfDestination(int type, float left, float top, float zoom);
    public PdfDestination(int type, float left, float bottom, float right, float top);
    public PdfDestination(PdfDestination d);
    public PdfDestination(string dest);
    public virtual bool HasPage();
    public virtual bool AddPage(PdfIndirectReference page);
}
public class iTextSharp.text.pdf.PdfDeveloperExtension : object {
    public static PdfDeveloperExtension ADOBE_1_7_EXTENSIONLEVEL3;
    public static PdfDeveloperExtension ESIC_1_7_EXTENSIONLEVEL2;
    public static PdfDeveloperExtension ESIC_1_7_EXTENSIONLEVEL5;
    protected PdfName prefix;
    protected PdfName baseversion;
    protected int extensionLevel;
    public PdfName Prefix { get; }
    public PdfName Baseversion { get; }
    public int ExtensionLevel { get; }
    public PdfDeveloperExtension(PdfName prefix, PdfName baseversion, int extensionLevel);
    private static PdfDeveloperExtension();
    public virtual PdfName get_Prefix();
    public virtual PdfName get_Baseversion();
    public virtual int get_ExtensionLevel();
    public virtual PdfDictionary GetDeveloperExtensions();
}
public class iTextSharp.text.pdf.PdfDeviceNColor : object {
    private PdfSpotColor[] spotColors;
    private ColorDetails[] colorantsDetails;
    public int NumberOfColorants { get; }
    public PdfSpotColor[] SpotColors { get; }
    public PdfDeviceNColor(PdfSpotColor[] spotColors);
    public virtual int get_NumberOfColorants();
    public virtual PdfSpotColor[] get_SpotColors();
    public virtual ColorDetails[] GetColorantDetails(PdfWriter writer);
    public virtual PdfObject GetPdfObject(PdfWriter writer);
    public virtual bool Equals(object o);
    public virtual int GetHashCode();
}
public class iTextSharp.text.pdf.PdfDictionary : PdfObject {
    public static PdfName FONT;
    public static PdfName OUTLINES;
    public static PdfName PAGE;
    public static PdfName PAGES;
    public static PdfName CATALOG;
    private PdfName dictionaryType;
    protected internal Dictionary`2<PdfName, PdfObject> hashMap;
    public KeyCollection<PdfName, PdfObject> Keys { get; }
    public int Size { get; }
    public PdfDictionary(PdfName type);
    public PdfDictionary(int capacity);
    private static PdfDictionary();
    public virtual void ToPdf(PdfWriter writer, Stream os);
    public virtual void Put(PdfName key, PdfObject value);
    public virtual void PutEx(PdfName key, PdfObject value);
    public virtual void PutAll(PdfDictionary dic);
    public virtual void Remove(PdfName key);
    public virtual void Clear();
    public virtual PdfObject Get(PdfName key);
    public virtual bool IsFont();
    public virtual bool IsPage();
    public virtual bool IsPages();
    public virtual bool IsCatalog();
    public virtual bool IsOutlineTree();
    public virtual bool CheckType(PdfName type);
    public virtual void Merge(PdfDictionary other);
    public virtual void MergeDifferent(PdfDictionary other);
    public virtual KeyCollection<PdfName, PdfObject> get_Keys();
    public virtual int get_Size();
    public virtual bool Contains(PdfName key);
    public virtual Enumerator<PdfName, PdfObject> GetEnumerator();
    public virtual string ToString();
    public virtual PdfObject GetDirectObject(PdfName key);
    public virtual PdfDictionary GetAsDict(PdfName key);
    public virtual PdfArray GetAsArray(PdfName key);
    public virtual PdfStream GetAsStream(PdfName key);
    public virtual PdfString GetAsString(PdfName key);
    public virtual PdfNumber GetAsNumber(PdfName key);
    public virtual PdfName GetAsName(PdfName key);
    public virtual PdfBoolean GetAsBoolean(PdfName key);
    public virtual PdfIndirectReference GetAsIndirectObject(PdfName key);
}
public class iTextSharp.text.pdf.PdfDiv : object {
    private List`1<IElement> content;
    private Nullable`1<float> left;
    private Nullable`1<float> top;
    private Nullable`1<float> right;
    private Nullable`1<float> bottom;
    private Nullable`1<float> width;
    private Nullable`1<float> height;
    private Nullable`1<float> percentageHeight;
    private Nullable`1<float> percentageWidth;
    private float contentWidth;
    private float contentHeight;
    private int textAlignment;
    private float paddingLeft;
    private float paddingRight;
    private float paddingTop;
    private float paddingBottom;
    private BaseColor backgroundColor;
    private Image backgroundImage;
    private Nullable`1<float> backgroundImageWidth;
    private float backgroundImageHeight;
    protected float spacingBefore;
    protected float spacingAfter;
    private FloatType floatType;
    private PositionType position;
    private DisplayType display;
    private FloatLayout floatLayout;
    private BorderTopStyle borderTopStyle;
    private float yLine;
    protected int runDirection;
    protected PdfName role;
    protected Dictionary`2<PdfName, PdfObject> accessibleAttributes;
    protected AccessibleElementId id;
    private bool keepTogether;
    public Nullable`1<float> Left { get; public set; }
    public Nullable`1<float> Top { get; public set; }
    public Nullable`1<float> Right { get; public set; }
    public Nullable`1<float> Bottom { get; public set; }
    public Nullable`1<float> Width { get; public set; }
    public Nullable`1<float> Height { get; public set; }
    public Nullable`1<float> PercentageHeight { get; public set; }
    public Nullable`1<float> PercentageWidth { get; public set; }
    public float ContentWidth { get; public set; }
    public float ContentHeight { get; public set; }
    public int TextAlignment { get; public set; }
    public float PaddingLeft { get; public set; }
    public float PaddingRight { get; public set; }
    public float PaddingTop { get; public set; }
    public float PaddingBottom { get; public set; }
    public FloatType Float { get; public set; }
    public PositionType Position { get; public set; }
    public FloatLayout FloatLayout { get; public set; }
    public DisplayType Display { get; public set; }
    public BaseColor BackgroundColor { get; public set; }
    unknown Image BackgroundImage {public set; }
    public float YLine { get; }
    public int RunDirection { get; public set; }
    public float SpacingBefore { get; public set; }
    public float SpacingAfter { get; public set; }
    public List`1<IElement> Content { get; }
    public BorderTopStyle BorderStyle { get; public set; }
    public bool KeepTogether { get; public set; }
    public IList`1<Chunk> Chunks { get; }
    public int Type { get; }
    public PdfName Role { get; public set; }
    public AccessibleElementId ID { get; public set; }
    public bool IsInline { get; }
    public virtual Nullable`1<float> get_Left();
    public virtual void set_Left(Nullable`1<float> value);
    public virtual Nullable`1<float> get_Top();
    public virtual void set_Top(Nullable`1<float> value);
    public virtual Nullable`1<float> get_Right();
    public virtual void set_Right(Nullable`1<float> value);
    public virtual Nullable`1<float> get_Bottom();
    public virtual void set_Bottom(Nullable`1<float> value);
    public virtual Nullable`1<float> get_Width();
    public virtual void set_Width(Nullable`1<float> value);
    public virtual Nullable`1<float> get_Height();
    public virtual void set_Height(Nullable`1<float> value);
    public virtual Nullable`1<float> get_PercentageHeight();
    public virtual void set_PercentageHeight(Nullable`1<float> value);
    public virtual Nullable`1<float> get_PercentageWidth();
    public virtual void set_PercentageWidth(Nullable`1<float> value);
    public virtual float get_ContentWidth();
    public virtual void set_ContentWidth(float value);
    public virtual float get_ContentHeight();
    public virtual void set_ContentHeight(float value);
    public virtual float getActualHeight();
    public virtual float getActualWidth();
    public virtual int get_TextAlignment();
    public virtual void set_TextAlignment(int value);
    public virtual float get_PaddingLeft();
    public virtual void set_PaddingLeft(float value);
    public virtual float get_PaddingRight();
    public virtual void set_PaddingRight(float value);
    public virtual float get_PaddingTop();
    public virtual void set_PaddingTop(float value);
    public virtual float get_PaddingBottom();
    public virtual void set_PaddingBottom(float value);
    public virtual FloatType get_Float();
    public virtual void set_Float(FloatType value);
    public virtual PositionType get_Position();
    public virtual void set_Position(PositionType value);
    public virtual FloatLayout get_FloatLayout();
    public virtual void set_FloatLayout(FloatLayout value);
    public virtual DisplayType get_Display();
    public virtual void set_Display(DisplayType value);
    public virtual BaseColor get_BackgroundColor();
    public virtual void set_BackgroundColor(BaseColor value);
    public virtual void set_BackgroundImage(Image value);
    public virtual void SetBackgroundImage(Image image, float width, float height);
    public virtual float get_YLine();
    public virtual int get_RunDirection();
    public virtual void set_RunDirection(int value);
    public virtual float get_SpacingBefore();
    public virtual void set_SpacingBefore(float value);
    public virtual float get_SpacingAfter();
    public virtual void set_SpacingAfter(float value);
    public virtual List`1<IElement> get_Content();
    public virtual BorderTopStyle get_BorderStyle();
    public virtual void set_BorderStyle(BorderTopStyle value);
    public virtual bool get_KeepTogether();
    public virtual void set_KeepTogether(bool value);
    public virtual IList`1<Chunk> get_Chunks();
    public virtual int get_Type();
    public virtual bool IsContent();
    public virtual bool IsNestable();
    public virtual bool Process(IElementListener listener);
    public virtual void AddElement(IElement element);
    public virtual int Layout(PdfContentByte canvas, bool useAscender, bool simulate, float llx, float lly, float urx, float ury);
    public virtual PdfObject GetAccessibleAttribute(PdfName key);
    public virtual void SetAccessibleAttribute(PdfName key, PdfObject value);
    public virtual Dictionary`2<PdfName, PdfObject> GetAccessibleAttributes();
    public virtual PdfName get_Role();
    public virtual void set_Role(PdfName value);
    public virtual AccessibleElementId get_ID();
    public virtual void set_ID(AccessibleElementId value);
    public virtual bool get_IsInline();
}
public class iTextSharp.text.pdf.PdfDocument : Document {
    internal static string hangingPunctuation;
    protected internal PdfWriter writer;
    internal Dictionary`2<AccessibleElementId, PdfStructureElement> structElements;
    protected internal bool openMCDocument;
    protected Dictionary`2<object, Int32[]> structParentIndices;
    protected Dictionary`2<object, int> markPoints;
    protected internal PdfContentByte text;
    protected internal PdfContentByte graphics;
    protected internal float leading;
    protected internal float currentHeight;
    protected bool isSectionTitle;
    protected internal int alignment;
    protected internal PdfAction anchorAction;
    protected TabSettings tabSettings;
    private Stack`1<float> leadingStack;
    private PdfBody body;
    protected internal int textEmptySize;
    protected float nextMarginLeft;
    protected float nextMarginRight;
    protected float nextMarginTop;
    protected float nextMarginBottom;
    protected internal bool firstPageEvent;
    protected internal PdfLine line;
    protected internal List`1<PdfLine> lines;
    protected internal int lastElementType;
    protected internal Indentation indentation;
    protected internal PdfInfo info;
    protected internal PdfOutline rootOutline;
    protected internal PdfOutline currentOutline;
    protected PdfViewerPreferencesImp viewerPreferences;
    protected internal PdfPageLabels pageLabels;
    protected internal SortedDictionary`2<string, Destination> localDestinations;
    private int jsCounter;
    protected internal Dictionary`2<string, PdfObject> documentLevelJS;
    protected internal Dictionary`2<string, PdfObject> documentFileAttachment;
    protected internal string openActionName;
    protected internal PdfAction openActionAction;
    protected internal PdfDictionary additionalActions;
    protected internal PdfCollection collection;
    internal PdfAnnotationsImp annotationsImp;
    protected PdfString language;
    protected Rectangle nextPageSize;
    protected Dictionary`2<string, PdfRectangle> thisBoxSize;
    protected Dictionary`2<string, PdfRectangle> boxSize;
    private bool pageEmpty;
    protected PdfDictionary pageAA;
    protected internal PageResources pageResources;
    protected internal bool strictImageSequence;
    protected internal float imageEnd;
    protected internal Image imageWait;
    internal List`1<IElement> floatingElements;
    public float Leading { get; public set; }
    public TabSettings TabSettings { get; public set; }
    unknown Byte[] XmpMetadata {public set; }
    unknown int PageCount {public set; }
    protected internal float IndentLeft { get; }
    protected internal float IndentRight { get; }
    protected internal float IndentTop { get; }
    protected internal float IndentBottom { get; }
    internal PdfInfo Info { get; }
    public PdfOutline RootOutline { get; }
    unknown int ViewerPreferences {internal set; }
    public PdfPageLabels PageLabels { get; internal set; }
    unknown PdfCollection Collection {public set; }
    public PdfAcroForm AcroForm { get; }
    unknown int SigFlags {internal set; }
    unknown Rectangle CropBoxSize {internal set; }
    internal bool PageEmpty { get; internal set; }
    unknown int Duration {internal set; }
    unknown PdfTransition Transition {internal set; }
    unknown Image Thumbnail {internal set; }
    internal PageResources PageResources { get; }
    internal bool StrictImageSequence { get; internal set; }
    public virtual void AddWriter(PdfWriter writer);
    public virtual float get_Leading();
    public virtual void set_Leading(float value);
    protected virtual void PushLeading();
    protected virtual void PopLeading();
    public virtual TabSettings get_TabSettings();
    public virtual void set_TabSettings(TabSettings value);
    public virtual bool Add(IElement element);
    public virtual void Open();
    public virtual void Close();
    public virtual void set_XmpMetadata(Byte[] value);
    public virtual bool NewPage();
    public IList`1<IAccessibleElement> EndPage();
    public virtual bool SetPageSize(Rectangle pageSize);
    public virtual bool SetMargins(float marginLeft, float marginRight, float marginTop, float marginBottom);
    public virtual bool SetMarginMirroring(bool MarginMirroring);
    public virtual bool SetMarginMirroringTopBottom(bool MarginMirroringTopBottom);
    public virtual void set_PageCount(int value);
    public virtual void ResetPageCount();
    protected internal virtual void InitPage();
    protected internal virtual void NewLine();
    protected virtual float CalculateLineHeight();
    protected internal virtual void CarriageReturn();
    public virtual float GetVerticalPosition(bool ensureNewLine);
    protected internal virtual void EnsureNewLine();
    protected internal virtual float FlushLines();
    internal float WriteLineToContent(PdfLine line, PdfContentByte text, PdfContentByte graphics, Object[] currentValues, float ratio);
    protected internal virtual float get_IndentLeft();
    protected internal virtual float get_IndentRight();
    protected internal virtual float get_IndentTop();
    protected internal virtual float get_IndentBottom();
    protected internal virtual void AddSpacing(float extraspace, float oldleading, Font f);
    protected internal virtual void AddSpacing(float extraspace, float oldleading, Font f, bool spacingAfter);
    internal PdfInfo get_Info();
    internal PdfCatalog GetCatalog(PdfIndirectReference pages);
    internal void AddOutline(PdfOutline outline, string name);
    public virtual PdfOutline get_RootOutline();
    internal void CalculateOutlineCount();
    internal void TraverseOutlineCount(PdfOutline outline);
    internal void WriteOutlines();
    internal void OutlineTree(PdfOutline outline);
    internal void set_ViewerPreferences(int value);
    internal void AddViewerPreference(PdfName key, PdfObject value);
    public virtual PdfPageLabels get_PageLabels();
    internal virtual void set_PageLabels(PdfPageLabels value);
    internal void LocalGoto(string name, float llx, float lly, float urx, float ury);
    internal void RemoteGoto(string filename, string name, float llx, float lly, float urx, float ury);
    internal void RemoteGoto(string filename, int page, float llx, float lly, float urx, float ury);
    internal void SetAction(PdfAction action, float llx, float lly, float urx, float ury);
    internal PdfAction GetLocalGotoAction(string name);
    internal bool LocalDestination(string name, PdfDestination destination);
    internal void AddJavaScript(PdfAction js);
    internal void AddJavaScript(string name, PdfAction js);
    internal Dictionary`2<string, PdfObject> GetDocumentLevelJS();
    internal void AddFileAttachment(string description, PdfFileSpecification fs);
    internal Dictionary`2<string, PdfObject> GetDocumentFileAttachment();
    internal void SetOpenAction(string name);
    internal void SetOpenAction(PdfAction action);
    internal void AddAdditionalAction(PdfName actionType, PdfAction action);
    public virtual void set_Collection(PdfCollection value);
    public virtual PdfAcroForm get_AcroForm();
    internal void set_SigFlags(int value);
    internal void AddCalculationOrder(PdfFormField formField);
    internal void AddAnnotation(PdfAnnotation annot);
    internal void SetLanguage(string language);
    internal void set_CropBoxSize(Rectangle value);
    internal void SetBoxSize(string boxName, Rectangle size);
    protected internal virtual void SetNewPageSizeAndMargins();
    internal Rectangle GetBoxSize(string boxName);
    internal void set_PageEmpty(bool value);
    internal bool get_PageEmpty();
    internal void set_Duration(int value);
    internal void set_Transition(PdfTransition value);
    internal void SetPageAction(PdfName actionType, PdfAction action);
    internal void set_Thumbnail(Image value);
    internal PageResources get_PageResources();
    internal void set_StrictImageSequence(bool value);
    internal bool get_StrictImageSequence();
    public virtual void ClearTextWrap();
    public virtual int GetStructParentIndex(object obj);
    public virtual int GetNextMarkPoint(object obj);
    public virtual Int32[] GetStructParentIndexAndNextMarkPoint(object obj);
    protected internal virtual void Add(Image image);
    internal void AddPTable(PdfPTable ptable);
    internal void AddDiv(PdfDiv div);
    internal void FlushFloatingElements();
    internal bool FitsPage(PdfPTable table, float margin);
    private static bool IsTagged(PdfWriter writer);
    private PdfLine GetLastLine();
}
public class iTextSharp.text.pdf.PdfEFStream : PdfStream {
    public PdfEFStream(Stream inp, PdfWriter writer);
    public PdfEFStream(Byte[] fileStore);
    public virtual void ToPdf(PdfWriter writer, Stream os);
}
public class iTextSharp.text.pdf.PdfEncodings : object {
    internal static Char[] winansiByteToChar;
    internal static Char[] pdfEncodingByteToChar;
    internal static IntHashtable winansi;
    internal static IntHashtable pdfEncoding;
    internal static Dictionary`2<string, IExtraEncoding> extraEncodings;
    private static PdfEncodings();
    public static Byte[] ConvertToBytes(string text, string encoding);
    public static Byte[] ConvertToBytes(char char1, string encoding);
    public static string ConvertToString(Byte[] bytes, string encoding);
    public static bool IsPdfDocEncoding(string text);
    public static void AddExtraEncoding(string name, IExtraEncoding enc);
}
public class iTextSharp.text.pdf.PdfEncryption : object {
    public static int STANDARD_ENCRYPTION_40;
    public static int STANDARD_ENCRYPTION_128;
    public static int AES_128;
    public static int AES_256;
    private static int VALIDATION_SALT_OFFSET;
    private static int KEY_SALT_OFFSET;
    private static int SALT_LENGHT;
    private static int OU_LENGHT;
    private static Byte[] pad;
    private static Byte[] salt;
    internal static Byte[] metadataPad;
    internal Byte[] key;
    internal int keySize;
    internal Byte[] mkey;
    internal Byte[] extra;
    internal IDigest md5;
    internal Byte[] ownerKey;
    internal Byte[] userKey;
    internal Byte[] oeKey;
    internal Byte[] ueKey;
    internal Byte[] perms;
    protected PdfPublicKeySecurityHandler publicKeyHandler;
    internal long permissions;
    internal Byte[] documentID;
    internal static long seq;
    private int revision;
    private ARCFOUREncryption rc4;
    private int keyLength;
    private bool encryptMetadata;
    private bool embeddedFilesOnly;
    private int cryptoMode;
    public PdfEncryption(PdfEncryption enc);
    private static PdfEncryption();
    public virtual void SetCryptoMode(int mode, int kl);
    public virtual int GetCryptoMode();
    public virtual bool IsMetadataEncrypted();
    public virtual long GetPermissions();
    public virtual bool IsEmbeddedFilesOnly();
    private Byte[] PadPassword(Byte[] userPassword);
    private Byte[] ComputeOwnerKey(Byte[] userPad, Byte[] ownerPad);
    private void SetupGlobalEncryptionKey(Byte[] documentID, Byte[] userPad, Byte[] ownerKey, long permissions);
    private void SetupUserKey();
    public virtual void SetupAllKeys(Byte[] userPassword, Byte[] ownerPassword, int permissions);
    public virtual bool ReadKey(PdfDictionary enc, Byte[] password);
    private static bool CompareArray(Byte[] a, Byte[] b, int len);
    public static Byte[] CreateDocumentId();
    public virtual void SetupByUserPassword(Byte[] documentID, Byte[] userPassword, Byte[] ownerKey, long permissions);
    private void SetupByUserPad(Byte[] documentID, Byte[] userPad, Byte[] ownerKey, long permissions);
    public virtual void SetupByOwnerPassword(Byte[] documentID, Byte[] ownerPassword, Byte[] userKey, Byte[] ownerKey, long permissions);
    private void SetupByOwnerPad(Byte[] documentID, Byte[] ownerPad, Byte[] userKey, Byte[] ownerKey, long permissions);
    public virtual void SetKey(Byte[] key);
    public virtual void SetupByEncryptionKey(Byte[] key, int keylength);
    public virtual void SetHashKey(int number, int generation);
    public static PdfObject CreateInfoId(Byte[] id, bool modified);
    public virtual PdfDictionary GetEncryptionDictionary();
    public virtual PdfObject GetFileID(bool modified);
    public virtual OutputStreamEncryption GetEncryptionStream(Stream os);
    public virtual int CalculateStreamSize(int n);
    public virtual Byte[] EncryptByteArray(Byte[] b);
    public virtual StandardDecryption GetDecryptor();
    public virtual Byte[] DecryptByteArray(Byte[] b);
    public virtual void AddRecipient(X509Certificate cert, int permission);
    public virtual Byte[] ComputeUserPassword(Byte[] ownerPassword);
}
public class iTextSharp.text.pdf.PdfEncryptor : object {
    public static void Encrypt(PdfReader reader, Stream os, Byte[] userPassword, Byte[] ownerPassword, int permissions, bool strength128Bits);
    public static void Encrypt(PdfReader reader, Stream os, Byte[] userPassword, Byte[] ownerPassword, int permissions, bool strength128Bits, Dictionary`2<string, string> newInfo);
    public static void Encrypt(PdfReader reader, Stream os, bool strength, string userPassword, string ownerPassword, int permissions);
    public static void Encrypt(PdfReader reader, Stream os, bool strength, string userPassword, string ownerPassword, int permissions, Dictionary`2<string, string> newInfo);
    public static void Encrypt(PdfReader reader, Stream os, int type, string userPassword, string ownerPassword, int permissions, Dictionary`2<string, string> newInfo);
    public static void Encrypt(PdfReader reader, Stream os, int type, string userPassword, string ownerPassword, int permissions);
    public static string GetPermissionsVerbose(int permissions);
    public static bool IsPrintingAllowed(int permissions);
    public static bool IsModifyContentsAllowed(int permissions);
    public static bool IsCopyAllowed(int permissions);
    public static bool IsModifyAnnotationsAllowed(int permissions);
    public static bool IsFillInAllowed(int permissions);
    public static bool IsScreenReadersAllowed(int permissions);
    public static bool IsAssemblyAllowed(int permissions);
    public static bool IsDegradedPrintingAllowed(int permissions);
}
public class iTextSharp.text.pdf.PdfException : DocumentException {
    public PdfException(string message);
    protected PdfException(SerializationInfo info, StreamingContext context);
}
public class iTextSharp.text.pdf.PdfFileSpecification : PdfDictionary {
    protected PdfWriter writer;
    protected PdfIndirectReference refi;
    public PdfIndirectReference Reference { get; }
    unknown Byte[] MultiByteFileName {public set; }
    unknown bool Volatile {public set; }
    public static PdfFileSpecification Url(PdfWriter writer, string url);
    public static PdfFileSpecification FileEmbedded(PdfWriter writer, string filePath, string fileDisplay, Byte[] fileStore);
    public static PdfFileSpecification FileEmbedded(PdfWriter writer, string filePath, string fileDisplay, Byte[] fileStore, int compressionLevel);
    public static PdfFileSpecification FileEmbedded(PdfWriter writer, string filePath, string fileDisplay, Byte[] fileStore, bool compress);
    public static PdfFileSpecification FileEmbedded(PdfWriter writer, string filePath, string fileDisplay, Byte[] fileStore, bool compress, string mimeType, PdfDictionary fileParameter);
    public static PdfFileSpecification FileEmbedded(PdfWriter writer, string filePath, string fileDisplay, Byte[] fileStore, string mimeType, PdfDictionary fileParameter, int compressionLevel);
    public static PdfFileSpecification FileExtern(PdfWriter writer, string filePath);
    public virtual PdfIndirectReference get_Reference();
    public virtual void set_MultiByteFileName(Byte[] value);
    public virtual void SetUnicodeFileName(string filename, bool unicode);
    public virtual void set_Volatile(bool value);
    public virtual void AddDescription(string description, bool unicode);
    public virtual void AddCollectionItem(PdfCollectionItem ci);
    public virtual void ToPdf(PdfWriter writer, Stream os);
}
public class iTextSharp.text.pdf.PdfFont : object {
    private BaseFont font;
    private float size;
    protected float hScale;
    internal float Size { get; }
    internal BaseFont Font { get; }
    internal static PdfFont DefaultFont { get; }
    internal float HorizontalScaling { get; internal set; }
    internal PdfFont(BaseFont bf, float size);
    public virtual int CompareTo(PdfFont pdfFont);
    internal float get_Size();
    internal float Width();
    internal float Width(int character);
    internal float Width(string s);
    internal BaseFont get_Font();
    internal static PdfFont get_DefaultFont();
    internal void set_HorizontalScaling(float value);
    internal float get_HorizontalScaling();
}
public class iTextSharp.text.pdf.PdfFormField : PdfAnnotation {
    public static int FF_READ_ONLY;
    public static int FF_REQUIRED;
    public static int FF_NO_EXPORT;
    public static int FF_NO_TOGGLE_TO_OFF;
    public static int FF_RADIO;
    public static int FF_PUSHBUTTON;
    public static int FF_MULTILINE;
    public static int FF_PASSWORD;
    public static int FF_COMBO;
    public static int FF_EDIT;
    public static int FF_FILESELECT;
    public static int FF_MULTISELECT;
    public static int FF_DONOTSPELLCHECK;
    public static int FF_DONOTSCROLL;
    public static int FF_COMB;
    public static int FF_RADIOSINUNISON;
    public static int FF_RICHTEXT;
    public static int Q_LEFT;
    public static int Q_CENTER;
    public static int Q_RIGHT;
    public static int MK_NO_ICON;
    public static int MK_NO_CAPTION;
    public static int MK_CAPTION_BELOW;
    public static int MK_CAPTION_ABOVE;
    public static int MK_CAPTION_RIGHT;
    public static int MK_CAPTION_LEFT;
    public static int MK_CAPTION_OVERLAID;
    public static bool MULTILINE;
    public static bool SINGLELINE;
    public static bool PLAINTEXT;
    public static bool PASSWORD;
    public static PdfName IF_SCALE_ALWAYS;
    public static PdfName IF_SCALE_BIGGER;
    public static PdfName IF_SCALE_SMALLER;
    public static PdfName IF_SCALE_NEVER;
    public static PdfName IF_SCALE_ANAMORPHIC;
    public static PdfName IF_SCALE_PROPORTIONAL;
    public static PdfName[] mergeTarget;
    internal PdfFormField parent;
    internal List`1<PdfFormField> kids;
    unknown int Button {public set; }
    public PdfFormField Parent { get; }
    public List`1<PdfFormField> Kids { get; }
    unknown string ValueAsString {public set; }
    unknown string ValueAsName {public set; }
    unknown PdfSignature ValueAsSig {public set; }
    unknown string RichValue {public set; }
    unknown string DefaultValueAsString {public set; }
    unknown string DefaultValueAsName {public set; }
    unknown string FieldName {public set; }
    unknown string UserName {public set; }
    unknown string MappingName {public set; }
    unknown int Quadding {public set; }
    public PdfFormField(PdfWriter writer, float llx, float lly, float urx, float ury, PdfAction action);
    internal PdfFormField(PdfWriter writer);
    private static PdfFormField();
    public virtual void SetWidget(Rectangle rect, PdfName highlight);
    public static PdfFormField CreateEmpty(PdfWriter writer);
    public virtual void set_Button(int value);
    protected static PdfFormField CreateButton(PdfWriter writer, int flags);
    public static PdfFormField CreatePushButton(PdfWriter writer);
    public static PdfFormField CreateCheckBox(PdfWriter writer);
    public static PdfFormField CreateRadioButton(PdfWriter writer, bool noToggleToOff);
    public static PdfFormField CreateTextField(PdfWriter writer, bool multiline, bool password, int maxLen);
    protected static PdfFormField CreateChoice(PdfWriter writer, int flags, PdfArray options, int topIndex);
    public static PdfFormField CreateList(PdfWriter writer, String[] options, int topIndex);
    public static PdfFormField CreateList(PdfWriter writer, String[0...,0...] options, int topIndex);
    public static PdfFormField CreateCombo(PdfWriter writer, bool edit, String[] options, int topIndex);
    public static PdfFormField CreateCombo(PdfWriter writer, bool edit, String[0...,0...] options, int topIndex);
    protected static PdfArray ProcessOptions(String[] options);
    protected static PdfArray ProcessOptions(String[0...,0...] options);
    public static PdfFormField CreateSignature(PdfWriter writer);
    public virtual PdfFormField get_Parent();
    public virtual void AddKid(PdfFormField field);
    public virtual List`1<PdfFormField> get_Kids();
    public virtual int SetFieldFlags(int flags);
    public virtual void set_ValueAsString(string value);
    public virtual void set_ValueAsName(string value);
    public virtual void set_ValueAsSig(PdfSignature value);
    public virtual void set_RichValue(string value);
    public virtual void set_DefaultValueAsString(string value);
    public virtual void set_DefaultValueAsName(string value);
    public virtual void set_FieldName(string value);
    public virtual void set_UserName(string value);
    public virtual void set_MappingName(string value);
    public virtual void set_Quadding(int value);
    internal static void MergeResources(PdfDictionary result, PdfDictionary source, PdfStamperImp writer);
    internal static void MergeResources(PdfDictionary result, PdfDictionary source);
    public virtual void SetUsed();
}
public class iTextSharp.text.pdf.PdfFormXObject : PdfStream {
    public static PdfNumber ZERO;
    public static PdfNumber ONE;
    public static PdfLiteral MATRIX;
    internal PdfFormXObject(PdfTemplate template, int compressionLevel);
    private static PdfFormXObject();
}
public class iTextSharp.text.pdf.PdfFunction : object {
    protected PdfWriter writer;
    protected PdfIndirectReference reference;
    protected PdfDictionary dictionary;
    internal PdfIndirectReference Reference { get; }
    protected PdfFunction(PdfWriter writer);
    internal PdfIndirectReference get_Reference();
    public static PdfFunction Type0(PdfWriter writer, Single[] domain, Single[] range, Int32[] size, int bitsPerSample, int order, Single[] encode, Single[] decode, Byte[] stream);
    public static PdfFunction Type2(PdfWriter writer, Single[] domain, Single[] range, Single[] c0, Single[] c1, float n);
    public static PdfFunction Type3(PdfWriter writer, Single[] domain, Single[] range, PdfFunction[] functions, Single[] bounds, Single[] encode);
    public static PdfFunction Type4(PdfWriter writer, Single[] domain, Single[] range, string postscript);
}
public class iTextSharp.text.pdf.PdfGState : PdfDictionary {
    public static PdfName BM_NORMAL;
    public static PdfName BM_COMPATIBLE;
    public static PdfName BM_MULTIPLY;
    public static PdfName BM_SCREEN;
    public static PdfName BM_OVERLAY;
    public static PdfName BM_DARKEN;
    public static PdfName BM_LIGHTEN;
    public static PdfName BM_COLORDODGE;
    public static PdfName BM_COLORBURN;
    public static PdfName BM_HARDLIGHT;
    public static PdfName BM_SOFTLIGHT;
    public static PdfName BM_DIFFERENCE;
    public static PdfName BM_EXCLUSION;
    unknown bool OverPrintStroking {public set; }
    unknown bool OverPrintNonStroking {public set; }
    unknown int OverPrintMode {public set; }
    unknown float StrokeOpacity {public set; }
    unknown float FillOpacity {public set; }
    unknown bool AlphaIsShape {public set; }
    unknown bool TextKnockout {public set; }
    unknown PdfName BlendMode {public set; }
    unknown PdfName RenderingIntent {public set; }
    private static PdfGState();
    public virtual void set_OverPrintStroking(bool value);
    public virtual void set_OverPrintNonStroking(bool value);
    public virtual void set_OverPrintMode(int value);
    public virtual void set_StrokeOpacity(float value);
    public virtual void set_FillOpacity(float value);
    public virtual void set_AlphaIsShape(bool value);
    public virtual void set_TextKnockout(bool value);
    public virtual void set_BlendMode(PdfName value);
    public virtual void set_RenderingIntent(PdfName value);
    public virtual void ToPdf(PdfWriter writer, Stream os);
}
public class iTextSharp.text.pdf.PdfICCBased : PdfStream {
    public PdfICCBased(ICC_Profile profile);
    public PdfICCBased(ICC_Profile profile, int compressionLevel);
}
public class iTextSharp.text.pdf.PdfImage : PdfStream {
    internal static int TRANSFERSIZE;
    protected PdfName name;
    protected Image image;
    public PdfName Name { get; }
    public Image Image { get; }
    public PdfImage(Image image, string name, PdfIndirectReference maskRef);
    public virtual PdfName get_Name();
    public virtual Image get_Image();
    internal static void TransferBytes(Stream inp, Stream outp, int len);
    protected virtual void ImportAll(PdfImage dup);
    private void GenerateImgResName(Image img);
}
public class iTextSharp.text.pdf.PdfImportedPage : PdfTemplate {
    internal PdfReaderInstance readerInstance;
    internal int pageNumber;
    internal int rotation;
    protected internal bool toCopy;
    public PdfImportedPage FromReader { get; }
    public int PageNumber { get; }
    public int Rotation { get; }
    public PdfContentByte Duplicate { get; }
    internal PdfObject Resources { get; }
    unknown PdfTransparencyGroup Group {public set; }
    internal PdfReaderInstance PdfReaderInstance { get; }
    internal PdfImportedPage(PdfReaderInstance readerInstance, PdfWriter writer, int pageNumber);
    public virtual PdfImportedPage get_FromReader();
    public virtual int get_PageNumber();
    public virtual int get_Rotation();
    public virtual void AddImage(Image image, float a, float b, float c, float d, float e, float f);
    public virtual void AddTemplate(PdfTemplate template, float a, float b, float c, float d, float e, float f);
    public virtual PdfContentByte get_Duplicate();
    public virtual PdfStream GetFormXObject(int compressionLevel);
    public virtual void SetColorFill(PdfSpotColor sp, float tint);
    public virtual void SetColorStroke(PdfSpotColor sp, float tint);
    internal virtual PdfObject get_Resources();
    public virtual void SetFontAndSize(BaseFont bf, float size);
    public virtual void set_Group(PdfTransparencyGroup value);
    internal void ThrowError();
    internal PdfReaderInstance get_PdfReaderInstance();
    public virtual bool IsToCopy();
    public virtual void SetCopied();
}
public class iTextSharp.text.pdf.PdfIndirectObject : object {
    protected int number;
    protected int generation;
    internal static Byte[] STARTOBJ;
    internal static Byte[] ENDOBJ;
    internal static int SIZEOBJ;
    protected internal PdfObject objecti;
    protected internal PdfWriter writer;
    public int Number { get; }
    public int Generation { get; }
    public PdfIndirectReference IndirectReference { get; }
    public PdfIndirectObject(int number, PdfObject objecti, PdfWriter writer);
    public PdfIndirectObject(PdfIndirectReference refi, PdfObject objecti, PdfWriter writer);
    public PdfIndirectObject(int number, int generation, PdfObject objecti, PdfWriter writer);
    private static PdfIndirectObject();
    public virtual int get_Number();
    public virtual int get_Generation();
    public virtual PdfIndirectReference get_IndirectReference();
    public virtual void WriteTo(Stream os);
    public virtual string ToString();
}
public class iTextSharp.text.pdf.PdfIndirectReference : PdfObject {
    protected int number;
    protected int generation;
    public int Number { get; }
    public int Generation { get; }
    internal PdfIndirectReference(int type, int number, int generation);
    protected internal PdfIndirectReference(int type, int number);
    public virtual int get_Number();
    public virtual int get_Generation();
    public virtual string ToString();
}
public class iTextSharp.text.pdf.PdfIsoConformanceException : Exception {
    private static long serialVersionUID;
    public PdfIsoConformanceException(string s);
    protected PdfIsoConformanceException(SerializationInfo info, StreamingContext context);
}
public class iTextSharp.text.pdf.PdfLabColor : object {
    private Single[] whitePoint;
    private Single[] blackPoint;
    private Single[] range;
    public PdfLabColor(Single[] whitePoint);
    public PdfLabColor(Single[] whitePoint, Single[] blackPoint);
    public PdfLabColor(Single[] whitePoint, Single[] blackPoint, Single[] range);
    public virtual PdfObject GetPdfObject(PdfWriter writer);
    public virtual BaseColor Lab2Rgb(float l, float a, float b);
    internal virtual CMYKColor Lab2Cmyk(float l, float a, float b);
    protected virtual Double[] Lab2RgbLinear(float l, float a, float b);
    public virtual LabColor Rgb2lab(BaseColor baseColor);
    private static double FXyz(double t);
    public virtual bool Equals(object o);
    public virtual int GetHashCode();
}
public class iTextSharp.text.pdf.PdfLayer : PdfDictionary {
    protected PdfIndirectReference refi;
    protected List`1<PdfLayer> children;
    protected PdfLayer parent;
    protected string title;
    private bool on;
    private bool onPanel;
    internal string Title { get; }
    public PdfLayer Parent { get; }
    public List`1<PdfLayer> Children { get; }
    public PdfIndirectReference Ref { get; public set; }
    unknown string Name {public set; }
    public PdfObject PdfObject { get; }
    public bool On { get; public set; }
    private PdfDictionary Usage { get; }
    unknown bool Export {public set; }
    unknown bool View {public set; }
    unknown string PageElement {public set; }
    public bool OnPanel { get; public set; }
    internal PdfLayer(string title);
    public PdfLayer(string name, PdfWriter writer);
    public static PdfLayer CreateTitle(string title, PdfWriter writer);
    internal string get_Title();
    public virtual void AddChild(PdfLayer child);
    public virtual PdfLayer get_Parent();
    public virtual List`1<PdfLayer> get_Children();
    public virtual PdfIndirectReference get_Ref();
    public virtual void set_Ref(PdfIndirectReference value);
    public virtual void set_Name(string value);
    public virtual PdfObject get_PdfObject();
    public virtual bool get_On();
    public virtual void set_On(bool value);
    private PdfDictionary get_Usage();
    public virtual void SetCreatorInfo(string creator, string subtype);
    public virtual void SetLanguage(string lang, bool preferred);
    public virtual void set_Export(bool value);
    public virtual void SetZoom(float min, float max);
    public virtual void SetPrint(string subtype, bool printstate);
    public virtual void set_View(bool value);
    public virtual void set_PageElement(string value);
    public virtual void SetUser(string type, String[] names);
    public virtual bool get_OnPanel();
    public virtual void set_OnPanel(bool value);
}
public class iTextSharp.text.pdf.PdfLayerMembership : PdfDictionary {
    public static PdfName ALLON;
    public static PdfName ANYON;
    public static PdfName ANYOFF;
    public static PdfName ALLOFF;
    internal PdfIndirectReference refi;
    internal PdfArray members;
    internal Dictionary`2<PdfLayer, object> layers;
    public PdfIndirectReference Ref { get; }
    public KeyCollection<PdfLayer, object> Layers { get; }
    unknown PdfName VisibilityPolicy {public set; }
    unknown PdfVisibilityExpression VisibilityExpression {public set; }
    public PdfObject PdfObject { get; }
    public PdfLayerMembership(PdfWriter writer);
    private static PdfLayerMembership();
    public virtual PdfIndirectReference get_Ref();
    public virtual void AddMember(PdfLayer layer);
    public virtual KeyCollection<PdfLayer, object> get_Layers();
    public virtual void set_VisibilityPolicy(PdfName value);
    public virtual void set_VisibilityExpression(PdfVisibilityExpression value);
    public virtual PdfObject get_PdfObject();
}
public class iTextSharp.text.pdf.PdfLine : object {
    protected internal List`1<PdfChunk> line;
    protected internal float left;
    protected internal float width;
    protected internal int alignment;
    protected internal float height;
    protected internal bool newlineSplit;
    protected internal float originalWidth;
    protected internal bool isRTL;
    protected internal ListItem listItem;
    protected TabStop tabStop;
    protected float tabStopAnchorPosition;
    protected float tabPosition;
    public int Size { get; }
    internal float Height { get; }
    internal float IndentLeft { get; }
    internal float WidthLeft { get; }
    internal int NumberOfSpaces { get; }
    public ListItem ListItem { get; public set; }
    public Chunk ListSymbol { get; }
    public float ListIndent { get; }
    public bool NewlineSplit { get; }
    public int LastStrokeChunk { get; }
    public float OriginalWidth { get; }
    internal bool RTL { get; }
    public float Ascender { get; }
    public float Descender { get; }
    internal PdfLine(float left, float right, int alignment, float height);
    internal PdfLine(float left, float originalWidth, float remainingWidth, int alignment, bool newlineSplit, List`1<PdfChunk> line, bool isRTL);
    internal PdfChunk Add(PdfChunk chunk, float currentLeading);
    internal PdfChunk Add(PdfChunk chunk);
    private void AddToLine(PdfChunk chunk);
    public virtual int get_Size();
    public virtual IEnumerator`1<PdfChunk> GetEnumerator();
    internal float get_Height();
    internal float get_IndentLeft();
    public virtual bool HasToBeJustified();
    public virtual void ResetAlignment();
    internal void SetExtraIndent(float extra);
    internal float get_WidthLeft();
    internal int get_NumberOfSpaces();
    public virtual void set_ListItem(ListItem value);
    public virtual ListItem get_ListItem();
    public virtual Chunk get_ListSymbol();
    public virtual float get_ListIndent();
    public virtual string ToString();
    public virtual int GetLineLengthUtf32();
    public virtual bool get_NewlineSplit();
    public virtual int get_LastStrokeChunk();
    public virtual PdfChunk GetChunk(int idx);
    public virtual float get_OriginalWidth();
    internal Single[] GetMaxSize(float fixedLeading, float multipliedLeading);
    internal bool get_RTL();
    internal int GetSeparatorCount();
    public virtual float GetWidthCorrected(float charSpacing, float wordSpacing);
    public virtual float get_Ascender();
    public virtual float get_Descender();
    public virtual void Flush();
}
public class iTextSharp.text.pdf.PdfLiteral : PdfObject {
    private long position;
    public long Position { get; }
    public int PosLength { get; }
    public PdfLiteral(string text);
    public PdfLiteral(Byte[] b);
    public PdfLiteral(int type, string text);
    public PdfLiteral(int type, Byte[] b);
    public PdfLiteral(int size);
    public virtual void ToPdf(PdfWriter writer, Stream os);
    public virtual long get_Position();
    public virtual int get_PosLength();
}
public class iTextSharp.text.pdf.PdfMediaClipData : PdfDictionary {
    internal PdfMediaClipData(string file, PdfFileSpecification fs, string mimeType);
}
public class iTextSharp.text.pdf.PdfName : PdfObject {
    public static PdfName _3D;
    public static PdfName A;
    public static PdfName A85;
    public static PdfName AA;
    public static PdfName ABSOLUTECOLORIMETRIC;
    public static PdfName AC;
    public static PdfName ACROFORM;
    public static PdfName ACTION;
    public static PdfName ACTIVATION;
    public static PdfName ADBE;
    public static PdfName ACTUALTEXT;
    public static PdfName ADBE_PKCS7_DETACHED;
    public static PdfName ADBE_PKCS7_S4;
    public static PdfName ADBE_PKCS7_S5;
    public static PdfName ADBE_PKCS7_SHA1;
    public static PdfName ADBE_X509_RSA_SHA1;
    public static PdfName ADOBE_PPKLITE;
    public static PdfName ADOBE_PPKMS;
    public static PdfName AESV2;
    public static PdfName AESV3;
    public static PdfName AFRELATIONSHIP;
    public static PdfName AHX;
    public static PdfName AIS;
    public static PdfName ALL;
    public static PdfName ALLPAGES;
    public static PdfName ALT;
    public static PdfName ALTERNATE;
    public static PdfName AF;
    public static PdfName ALTERNATEPRESENTATION;
    public static PdfName ALTERNATES;
    public static PdfName AND;
    public static PdfName ANIMATION;
    public static PdfName ANNOT;
    public static PdfName ANNOTS;
    public static PdfName ANTIALIAS;
    public static PdfName AP;
    public static PdfName APP;
    public static PdfName APPDEFAULT;
    public static PdfName ART;
    public static PdfName ARTBOX;
    public static PdfName ARTIFACT;
    public static PdfName ASCENT;
    public static PdfName AS;
    public static PdfName ASCII85DECODE;
    public static PdfName ASCIIHEXDECODE;
    public static PdfName ASSET;
    public static PdfName ASSETS;
    public static PdfName ATTACHED;
    public static PdfName AUTHEVENT;
    public static PdfName AUTHOR;
    public static PdfName B;
    public static PdfName BACKGROUND;
    public static PdfName BACKGROUNDCOLOR;
    public static PdfName BASEENCODING;
    public static PdfName BASEFONT;
    public static PdfName BASEVERSION;
    public static PdfName BBOX;
    public static PdfName BC;
    public static PdfName BG;
    public static PdfName BIBENTRY;
    public static PdfName BIGFIVE;
    public static PdfName BINDING;
    public static PdfName BINDINGMATERIALNAME;
    public static PdfName BITSPERCOMPONENT;
    public static PdfName BITSPERSAMPLE;
    public static PdfName BL;
    public static PdfName BLACKIS1;
    public static PdfName BLACKPOINT;
    public static PdfName BLOCKQUOTE;
    public static PdfName BLEEDBOX;
    public static PdfName BLINDS;
    public static PdfName BM;
    public static PdfName BORDER;
    public static PdfName BOTH;
    public static PdfName BOUNDS;
    public static PdfName BOX;
    public static PdfName BS;
    public static PdfName BTN;
    public static PdfName BYTERANGE;
    public static PdfName C;
    public static PdfName C0;
    public static PdfName C1;
    public static PdfName CA;
    public static PdfName ca;
    public static PdfName CALGRAY;
    public static PdfName CALRGB;
    public static PdfName CAPHEIGHT;
    public static PdfName CARET;
    public static PdfName CAPTION;
    public static PdfName CATALOG;
    public static PdfName CATEGORY;
    public static PdfName CB;
    public static PdfName CCITTFAXDECODE;
    public static PdfName CENTER;
    public static PdfName CENTERWINDOW;
    public static PdfName CERT;
    public static PdfName CERTS;
    public static PdfName CF;
    public static PdfName CFM;
    public static PdfName CH;
    public static PdfName CHARPROCS;
    public static PdfName CHECKSUM;
    public static PdfName CI;
    public static PdfName CIDFONTTYPE0;
    public static PdfName CIDFONTTYPE2;
    public static PdfName CIDSET;
    public static PdfName CIDSYSTEMINFO;
    public static PdfName CIDTOGIDMAP;
    public static PdfName CIRCLE;
    public static PdfName CLASSMAP;
    public static PdfName CLOUD;
    public static PdfName CMD;
    public static PdfName CO;
    public static PdfName CODE;
    public static PdfName COLOR;
    public static PdfName COLORANTS;
    public static PdfName COLORS;
    public static PdfName COLORSPACE;
    public static PdfName COLORTRANSFORM;
    public static PdfName COLLECTION;
    public static PdfName COLLECTIONFIELD;
    public static PdfName COLLECTIONITEM;
    public static PdfName COLLECTIONSCHEMA;
    public static PdfName COLLECTIONSORT;
    public static PdfName COLLECTIONSUBITEM;
    public static PdfName COLSPAN;
    public static PdfName COLUMN;
    public static PdfName COLUMNS;
    public static PdfName CONDITION;
    public static PdfName CONFIGS;
    public static PdfName CONFIGURATION;
    public static PdfName CONFIGURATIONS;
    public static PdfName CONTACTINFO;
    public static PdfName CONTENT;
    public static PdfName CONTENTS;
    public static PdfName COORDS;
    public static PdfName COUNT;
    public static PdfName COURIER;
    public static PdfName COURIER_BOLD;
    public static PdfName COURIER_OBLIQUE;
    public static PdfName COURIER_BOLDOBLIQUE;
    public static PdfName CREATIONDATE;
    public static PdfName CREATOR;
    public static PdfName CREATORINFO;
    public static PdfName CRL;
    public static PdfName CRLS;
    public static PdfName CROPBOX;
    public static PdfName CRYPT;
    public static PdfName CS;
    public static PdfName CUEPOINT;
    public static PdfName CUEPOINTS;
    public static PdfName CYX;
    public static PdfName D;
    public static PdfName DA;
    public static PdfName DATA;
    public static PdfName DC;
    public static PdfName DCS;
    public static PdfName DCTDECODE;
    public static PdfName DECIMAL;
    public static PdfName DEACTIVATION;
    public static PdfName DECODE;
    public static PdfName DECODEPARMS;
    public static PdfName DEFAULT;
    public static PdfName DEFAULTCRYPTFILTER;
    public static PdfName DEFAULTCMYK;
    public static PdfName DEFAULTGRAY;
    public static PdfName DEFAULTRGB;
    public static PdfName DESC;
    public static PdfName DESCENDANTFONTS;
    public static PdfName DESCENT;
    public static PdfName DEST;
    public static PdfName DESTOUTPUTPROFILE;
    public static PdfName DESTS;
    public static PdfName DEVICEGRAY;
    public static PdfName DEVICERGB;
    public static PdfName DEVICECMYK;
    public static PdfName DEVICEN;
    public static PdfName DI;
    public static PdfName DIFFERENCES;
    public static PdfName DISSOLVE;
    public static PdfName DIRECTION;
    public static PdfName DISPLAYDOCTITLE;
    public static PdfName DIV;
    public static PdfName DL;
    public static PdfName DM;
    public static PdfName DOS;
    public static PdfName DOCMDP;
    public static PdfName DOCOPEN;
    public static PdfName DOCTIMESTAMP;
    public static PdfName DOCUMENT;
    public static PdfName DOMAIN;
    public static PdfName DP;
    public static PdfName DR;
    public static PdfName DS;
    public static PdfName DSS;
    public static PdfName DUR;
    public static PdfName DUPLEX;
    public static PdfName DUPLEXFLIPSHORTEDGE;
    public static PdfName DUPLEXFLIPLONGEDGE;
    public static PdfName DV;
    public static PdfName DW;
    public static PdfName E;
    public static PdfName EARLYCHANGE;
    public static PdfName EF;
    public static PdfName EFF;
    public static PdfName EFOPEN;
    public static PdfName EMBEDDED;
    public static PdfName EMBEDDEDFILE;
    public static PdfName EMBEDDEDFILES;
    public static PdfName ENCODE;
    public static PdfName ENCODEDBYTEALIGN;
    public static PdfName ENCODING;
    public static PdfName ENCRYPT;
    public static PdfName ENCRYPTMETADATA;
    public static PdfName END;
    public static PdfName ENDINDENT;
    public static PdfName ENDOFBLOCK;
    public static PdfName ENDOFLINE;
    public static PdfName EPSG;
    public static PdfName ESIC;
    public static PdfName ETSI_CADES_DETACHED;
    public static PdfName ETSI_RFC3161;
    public static PdfName EXCLUDE;
    public static PdfName EXTEND;
    public static PdfName EXTENSIONS;
    public static PdfName EXTENSIONLEVEL;
    public static PdfName EXTGSTATE;
    public static PdfName EXPORT;
    public static PdfName EXPORTSTATE;
    public static PdfName EVENT;
    public static PdfName F;
    public static PdfName FAR;
    public static PdfName FB;
    public static PdfName FD;
    public static PdfName FDECODEPARMS;
    public static PdfName FDF;
    public static PdfName FF;
    public static PdfName FFILTER;
    public static PdfName FG;
    public static PdfName FIELDMDP;
    public static PdfName FIELDS;
    public static PdfName FIGURE;
    public static PdfName FILEATTACHMENT;
    public static PdfName FILESPEC;
    public static PdfName FILTER;
    public static PdfName FIRST;
    public static PdfName FIRSTCHAR;
    public static PdfName FIRSTPAGE;
    public static PdfName FIT;
    public static PdfName FITH;
    public static PdfName FITV;
    public static PdfName FITR;
    public static PdfName FITB;
    public static PdfName FITBH;
    public static PdfName FITBV;
    public static PdfName FITWINDOW;
    public static PdfName FL;
    public static PdfName FLAGS;
    public static PdfName FLASH;
    public static PdfName FLASHVARS;
    public static PdfName FLATEDECODE;
    public static PdfName FO;
    public static PdfName FONT;
    public static PdfName FONTBBOX;
    public static PdfName FONTDESCRIPTOR;
    public static PdfName FONTFAMILY;
    public static PdfName FONTFILE;
    public static PdfName FONTFILE2;
    public static PdfName FONTFILE3;
    public static PdfName FONTMATRIX;
    public static PdfName FONTNAME;
    public static PdfName FONTWEIGHT;
    public static PdfName FOREGROUND;
    public static PdfName FORM;
    public static PdfName FORMTYPE;
    public static PdfName FORMULA;
    public static PdfName FREETEXT;
    public static PdfName FRM;
    public static PdfName FS;
    public static PdfName FT;
    public static PdfName FULLSCREEN;
    public static PdfName FUNCTION;
    public static PdfName FUNCTIONS;
    public static PdfName FUNCTIONTYPE;
    public static PdfName GAMMA;
    public static PdfName GBK;
    public static PdfName GCS;
    public static PdfName GEO;
    public static PdfName GEOGCS;
    public static PdfName GLITTER;
    public static PdfName GOTO;
    public static PdfName GOTO3DVIEW;
    public static PdfName GOTOE;
    public static PdfName GOTOR;
    public static PdfName GPTS;
    public static PdfName GROUP;
    public static PdfName GTS_PDFA1;
    public static PdfName GTS_PDFX;
    public static PdfName GTS_PDFXVERSION;
    public static PdfName H;
    public static PdfName H1;
    public static PdfName H2;
    public static PdfName H3;
    public static PdfName H4;
    public static PdfName H5;
    public static PdfName H6;
    public static PdfName HALFTONENAME;
    public static PdfName HALFTONETYPE;
    public static PdfName HALIGN;
    public static PdfName HEADERS;
    public static PdfName HEIGHT;
    public static PdfName HELV;
    public static PdfName HELVETICA;
    public static PdfName HELVETICA_BOLD;
    public static PdfName HELVETICA_OBLIQUE;
    public static PdfName HELVETICA_BOLDOBLIQUE;
    public static PdfName HF;
    public static PdfName HID;
    public static PdfName HIDE;
    public static PdfName HIDEMENUBAR;
    public static PdfName HIDETOOLBAR;
    public static PdfName HIDEWINDOWUI;
    public static PdfName HIGHLIGHT;
    public static PdfName HOFFSET;
    public static PdfName HT;
    public static PdfName HTP;
    public static PdfName I;
    public static PdfName IC;
    public static PdfName ICCBASED;
    public static PdfName ID;
    public static PdfName IDENTITY;
    public static PdfName IDTREE;
    public static PdfName IF;
    public static PdfName IM;
    public static PdfName IMAGE;
    public static PdfName IMAGEB;
    public static PdfName IMAGEC;
    public static PdfName IMAGEI;
    public static PdfName IMAGEMASK;
    public static PdfName INCLUDE;
    public static PdfName IND;
    public static PdfName INDEX;
    public static PdfName INDEXED;
    public static PdfName INFO;
    public static PdfName INK;
    public static PdfName INKLIST;
    public static PdfName INSTANCES;
    public static PdfName IMPORTDATA;
    public static PdfName INTENT;
    public static PdfName INTERPOLATE;
    public static PdfName ISMAP;
    public static PdfName IRT;
    public static PdfName ITALICANGLE;
    public static PdfName ITXT;
    public static PdfName IX;
    public static PdfName JAVASCRIPT;
    public static PdfName JBIG2DECODE;
    public static PdfName JBIG2GLOBALS;
    public static PdfName JPXDECODE;
    public static PdfName JS;
    public static PdfName JUSTIFY;
    public static PdfName K;
    public static PdfName KEYWORDS;
    public static PdfName KIDS;
    public static PdfName L;
    public static PdfName L2R;
    public static PdfName LAB;
    public static PdfName LANG;
    public static PdfName LANGUAGE;
    public static PdfName LAST;
    public static PdfName LASTCHAR;
    public static PdfName LASTPAGE;
    public static PdfName LAUNCH;
    public static PdfName LAYOUT;
    public static PdfName LBL;
    public static PdfName LBODY;
    public static PdfName LENGTH;
    public static PdfName LENGTH1;
    public static PdfName LI;
    public static PdfName LIMITS;
    public static PdfName LINE;
    public static PdfName LINEAR;
    public static PdfName LINEHEIGHT;
    public static PdfName LINK;
    public static PdfName LIST;
    public static PdfName LISTMODE;
    public static PdfName LISTNUMBERING;
    public static PdfName LOCATION;
    public static PdfName LOCK;
    public static PdfName LOCKED;
    public static PdfName LOWERALPHA;
    public static PdfName LOWERROMAN;
    public static PdfName LPTS;
    public static PdfName LZWDECODE;
    public static PdfName M;
    public static PdfName MAC;
    public static PdfName MATERIAL;
    public static PdfName MATRIX;
    public static PdfName MAC_EXPERT_ENCODING;
    public static PdfName MAC_ROMAN_ENCODING;
    public static PdfName MARKED;
    public static PdfName MARKINFO;
    public static PdfName MASK;
    public static PdfName MAX_LOWER_CASE;
    public static PdfName MAX_CAMEL_CASE;
    public static PdfName MAXLEN;
    public static PdfName MEDIABOX;
    public static PdfName MCID;
    public static PdfName MCR;
    public static PdfName MEASURE;
    public static PdfName METADATA;
    public static PdfName MIN_LOWER_CASE;
    public static PdfName MIN_CAMEL_CASE;
    public static PdfName MK;
    public static PdfName MMTYPE1;
    public static PdfName MODDATE;
    public static PdfName MOVIE;
    public static PdfName N;
    public static PdfName N0;
    public static PdfName N1;
    public static PdfName N2;
    public static PdfName N3;
    public static PdfName N4;
    public static PdfName NAME;
    public static PdfName NAMED;
    public static PdfName NAMES;
    public static PdfName NAVIGATION;
    public static PdfName NAVIGATIONPANE;
    public static PdfName NCHANNEL;
    public static PdfName NEAR;
    public static PdfName NEEDAPPEARANCES;
    public static PdfName NEEDRENDERING;
    public static PdfName NEWWINDOW;
    public static PdfName NEXT;
    public static PdfName NEXTPAGE;
    public static PdfName NM;
    public static PdfName NONE;
    public static PdfName NONFULLSCREENPAGEMODE;
    public static PdfName NONSTRUCT;
    public static PdfName NOT;
    public static PdfName NOTE;
    public static PdfName NUMBERFORMAT;
    public static PdfName NUMCOPIES;
    public static PdfName NUMS;
    public static PdfName O;
    public static PdfName OBJ;
    public static PdfName OBJR;
    public static PdfName OBJSTM;
    public static PdfName OC;
    public static PdfName OCG;
    public static PdfName OCGS;
    public static PdfName OCMD;
    public static PdfName OCPROPERTIES;
    public static PdfName OCSP;
    public static PdfName OCSPS;
    public static PdfName OE;
    public static PdfName Off_;
    public static PdfName OFF;
    public static PdfName ON;
    public static PdfName ONECOLUMN;
    public static PdfName OPEN;
    public static PdfName OPENACTION;
    public static PdfName OP;
    public static PdfName op_;
    public static PdfName OPI;
    public static PdfName OPM;
    public static PdfName OPT;
    public static PdfName OR;
    public static PdfName ORDER;
    public static PdfName ORDERING;
    public static PdfName ORG;
    public static PdfName OSCILLATING;
    public static PdfName OUTLINES;
    public static PdfName OUTPUTCONDITION;
    public static PdfName OUTPUTCONDITIONIDENTIFIER;
    public static PdfName OUTPUTINTENT;
    public static PdfName OUTPUTINTENTS;
    public static PdfName OVERLAYTEXT;
    public static PdfName P;
    public static PdfName PAGE;
    public static PdfName PAGEELEMENT;
    public static PdfName PAGELABELS;
    public static PdfName PAGELAYOUT;
    public static PdfName PAGEMODE;
    public static PdfName PAGES;
    public static PdfName PAINTTYPE;
    public static PdfName PANOSE;
    public static PdfName PARAMS;
    public static PdfName PARENT;
    public static PdfName PARENTTREE;
    public static PdfName PARENTTREENEXTKEY;
    public static PdfName PART;
    public static PdfName PASSCONTEXTCLICK;
    public static PdfName PATTERN;
    public static PdfName PATTERNTYPE;
    public static PdfName PB;
    public static PdfName PC;
    public static PdfName PDF;
    public static PdfName PDFDOCENCODING;
    public static PdfName PDU;
    public static PdfName PERCEPTUAL;
    public static PdfName PERMS;
    public static PdfName PG;
    public static PdfName PI;
    public static PdfName PICKTRAYBYPDFSIZE;
    public static PdfName PIECEINFO;
    public static PdfName PLAYCOUNT;
    public static PdfName PO;
    public static PdfName POLYGON;
    public static PdfName POLYLINE;
    public static PdfName POPUP;
    public static PdfName POSITION;
    public static PdfName PREDICTOR;
    public static PdfName PREFERRED;
    public static PdfName PRESENTATION;
    public static PdfName PRESERVERB;
    public static PdfName PRESSTEPS;
    public static PdfName PREV;
    public static PdfName PREVPAGE;
    public static PdfName PRINT;
    public static PdfName PRINTAREA;
    public static PdfName PRINTCLIP;
    public static PdfName PRINTERMARK;
    public static PdfName PRINTFIELD;
    public static PdfName PRINTPAGERANGE;
    public static PdfName PRINTSCALING;
    public static PdfName PRINTSTATE;
    public static PdfName PRIVATE;
    public static PdfName PROCSET;
    public static PdfName PRODUCER;
    public static PdfName PROJCS;
    public static PdfName PROP_BUILD;
    public static PdfName PROPERTIES;
    public static PdfName PS;
    public static PdfName PTDATA;
    public static PdfName PUBSEC;
    public static PdfName PV;
    public static PdfName Q;
    public static PdfName QUADPOINTS;
    public static PdfName QUOTE;
    public static PdfName R;
    public static PdfName R2L;
    public static PdfName RANGE;
    public static PdfName RB;
    public static PdfName rb;
    public static PdfName RBGROUPS;
    public static PdfName RC;
    public static PdfName RD;
    public static PdfName REASON;
    public static PdfName RECIPIENTS;
    public static PdfName RECT;
    public static PdfName REDACT;
    public static PdfName REFERENCE;
    public static PdfName REGISTRY;
    public static PdfName REGISTRYNAME;
    public static PdfName RELATIVECOLORIMETRIC;
    public static PdfName RENDITION;
    public static PdfName REPEAT;
    public static PdfName REVERSEDCHARS;
    public static PdfName RESETFORM;
    public static PdfName RESOURCES;
    public static PdfName REQUIREMENTS;
    public static PdfName RI;
    public static PdfName RICHMEDIA;
    public static PdfName RICHMEDIAACTIVATION;
    public static PdfName RICHMEDIAANIMATION;
    public static PdfName RICHMEDIACOMMAND;
    public static PdfName RICHMEDIACONFIGURATION;
    public static PdfName RICHMEDIACONTENT;
    public static PdfName RICHMEDIADEACTIVATION;
    public static PdfName RICHMEDIAEXECUTE;
    public static PdfName RICHMEDIAINSTANCE;
    public static PdfName RICHMEDIAPARAMS;
    public static PdfName RICHMEDIAPOSITION;
    public static PdfName RICHMEDIAPRESENTATION;
    public static PdfName RICHMEDIASETTINGS;
    public static PdfName RICHMEDIAWINDOW;
    public static PdfName RL;
    public static PdfName ROLE;
    public static PdfName RO;
    public static PdfName ROLEMAP;
    public static PdfName ROOT;
    public static PdfName ROTATE;
    public static PdfName ROW;
    public static PdfName ROWS;
    public static PdfName ROWSPAN;
    public static PdfName RP;
    public static PdfName RT;
    public static PdfName RUBY;
    public static PdfName RUNLENGTHDECODE;
    public static PdfName RV;
    public static PdfName S;
    public static PdfName SATURATION;
    public static PdfName SCHEMA;
    public static PdfName SCOPE;
    public static PdfName SCREEN;
    public static PdfName SCRIPTS;
    public static PdfName SECT;
    public static PdfName SEPARATION;
    public static PdfName SETOCGSTATE;
    public static PdfName SETTINGS;
    public static PdfName SHADING;
    public static PdfName SHADINGTYPE;
    public static PdfName SHIFT_JIS;
    public static PdfName SIG;
    public static PdfName SIGFIELDLOCK;
    public static PdfName SIGFLAGS;
    public static PdfName SIGREF;
    public static PdfName SIMPLEX;
    public static PdfName SINGLEPAGE;
    public static PdfName SIZE;
    public static PdfName SMASK;
    public static PdfName SMASKINDATA;
    public static PdfName SORT;
    public static PdfName SOUND;
    public static PdfName SPACEAFTER;
    public static PdfName SPACEBEFORE;
    public static PdfName SPAN;
    public static PdfName SPEED;
    public static PdfName SPLIT;
    public static PdfName SQUARE;
    public static PdfName SQUIGGLY;
    public static PdfName SS;
    public static PdfName ST;
    public static PdfName STAMP;
    public static PdfName STANDARD;
    public static PdfName START;
    public static PdfName STARTINDENT;
    public static PdfName STATE;
    public static PdfName STATUS;
    public static PdfName STDCF;
    public static PdfName STEMV;
    public static PdfName STMF;
    public static PdfName STRF;
    public static PdfName STRIKEOUT;
    public static PdfName STRUCTELEM;
    public static PdfName STRUCTPARENT;
    public static PdfName STRUCTPARENTS;
    public static PdfName STRUCTTREEROOT;
    public static PdfName STYLE;
    public static PdfName SUBFILTER;
    public static PdfName SUBJECT;
    public static PdfName SUBMITFORM;
    public static PdfName SUBTYPE;
    public static PdfName SUMMARY;
    public static PdfName SUPPLEMENT;
    public static PdfName SV;
    public static PdfName SW;
    public static PdfName SYMBOL;
    public static PdfName T;
    public static PdfName TA;
    public static PdfName TABLE;
    public static PdfName TABS;
    public static PdfName TBODY;
    public static PdfName TD;
    public static PdfName TR;
    public static PdfName TR2;
    public static PdfName TEXT;
    public static PdfName TEXTALIGN;
    public static PdfName TEXTDECORATIONCOLOR;
    public static PdfName TEXTDECORATIONTHICKNESS;
    public static PdfName TEXTDECORATIONTYPE;
    public static PdfName TEXTINDENT;
    public static PdfName TFOOT;
    public static PdfName TH;
    public static PdfName THEAD;
    public static PdfName THUMB;
    public static PdfName THREADS;
    public static PdfName TI;
    public static PdfName TIME;
    public static PdfName TILINGTYPE;
    public static PdfName TIMES_ROMAN;
    public static PdfName TIMES_BOLD;
    public static PdfName TIMES_ITALIC;
    public static PdfName TIMES_BOLDITALIC;
    public static PdfName TITLE;
    public static PdfName TK;
    public static PdfName TM;
    public static PdfName TOC;
    public static PdfName TOCI;
    public static PdfName TOGGLE;
    public static PdfName TOOLBAR;
    public static PdfName TOUNICODE;
    public static PdfName TP;
    public static PdfName TABLEROW;
    public static PdfName TRANS;
    public static PdfName TRANSFORMPARAMS;
    public static PdfName TRANSFORMMETHOD;
    public static PdfName TRANSPARENCY;
    public static PdfName TRANSPARENT;
    public static PdfName TRAPNET;
    public static PdfName TRAPPED;
    public static PdfName TRIMBOX;
    public static PdfName TRUETYPE;
    public static PdfName TS;
    public static PdfName TTL;
    public static PdfName TU;
    public static PdfName TV;
    public static PdfName TWOCOLUMNLEFT;
    public static PdfName TWOCOLUMNRIGHT;
    public static PdfName TWOPAGELEFT;
    public static PdfName TWOPAGERIGHT;
    public static PdfName TX;
    public static PdfName TYPE;
    public static PdfName TYPE0;
    public static PdfName TYPE1;
    public static PdfName TYPE3;
    public static PdfName U;
    public static PdfName UE;
    public static PdfName UF;
    public static PdfName UHC;
    public static PdfName UNDERLINE;
    public static PdfName UNIX;
    public static PdfName UPPERALPHA;
    public static PdfName UPPERROMAN;
    public static PdfName UR;
    public static PdfName UR3;
    public static PdfName URI;
    public static PdfName URL;
    public static PdfName USAGE;
    public static PdfName USEATTACHMENTS;
    public static PdfName USENONE;
    public static PdfName USEOC;
    public static PdfName USEOUTLINES;
    public static PdfName USER;
    public static PdfName USERPROPERTIES;
    public static PdfName USERUNIT;
    public static PdfName USETHUMBS;
    public static PdfName UTF_8;
    public static PdfName V;
    public static PdfName V2;
    public static PdfName VALIGN;
    public static PdfName VE;
    public static PdfName VERISIGN_PPKVS;
    public static PdfName VERSION;
    public static PdfName VERTICES;
    public static PdfName VIDEO;
    public static PdfName VIEW;
    public static PdfName VIEWS;
    public static PdfName VIEWAREA;
    public static PdfName VIEWCLIP;
    public static PdfName VIEWERPREFERENCES;
    public static PdfName VIEWPORT;
    public static PdfName VIEWSTATE;
    public static PdfName VISIBLEPAGES;
    public static PdfName VOFFSET;
    public static PdfName VP;
    public static PdfName VRI;
    public static PdfName W;
    public static PdfName W2;
    public static PdfName WARICHU;
    public static PdfName WATERMARK;
    public static PdfName WC;
    public static PdfName WIDGET;
    public static PdfName WIDTH;
    public static PdfName WIDTHS;
    public static PdfName WIN;
    public static PdfName WIN_ANSI_ENCODING;
    public static PdfName WINDOW;
    public static PdfName WINDOWED;
    public static PdfName WIPE;
    public static PdfName WHITEPOINT;
    public static PdfName WKT;
    public static PdfName WP;
    public static PdfName WS;
    public static PdfName WT;
    public static PdfName X;
    public static PdfName XA;
    public static PdfName XD;
    public static PdfName XFA;
    public static PdfName XML;
    public static PdfName XOBJECT;
    public static PdfName XPTS;
    public static PdfName XREF;
    public static PdfName XREFSTM;
    public static PdfName XSTEP;
    public static PdfName XYZ;
    public static PdfName YSTEP;
    public static PdfName ZADB;
    public static PdfName ZAPFDINGBATS;
    public static PdfName ZOOM;
    public static Dictionary`2<string, PdfName> staticNames;
    private int hash;
    private static PdfName();
    public PdfName(string name);
    public PdfName(string name, bool lengthCheck);
    public PdfName(Byte[] bytes);
    public virtual int CompareTo(PdfName name);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public static Byte[] EncodeName(string name);
    public static string DecodeName(string name);
}
public class iTextSharp.text.pdf.PdfNameTree : object {
    private static int leafSize;
    public static PdfDictionary WriteTree(Dictionary`2<string, T> items, PdfWriter writer);
    private static PdfString IterateItems(PdfDictionary dic, Dictionary`2<string, PdfObject> items, PdfString leftOverString);
    public static Dictionary`2<string, PdfObject> ReadTree(PdfDictionary dic);
}
public class iTextSharp.text.pdf.PdfNull : PdfObject {
    public static PdfNull PDFNULL;
    private static PdfNull();
    public virtual string ToString();
}
public class iTextSharp.text.pdf.PdfNumber : PdfObject {
    private double value;
    public int IntValue { get; }
    public long LongValue { get; }
    public double DoubleValue { get; }
    public float FloatValue { get; }
    public PdfNumber(string content);
    public PdfNumber(int value);
    public PdfNumber(long value);
    public PdfNumber(double value);
    public PdfNumber(float value);
    public virtual int get_IntValue();
    public virtual long get_LongValue();
    public virtual double get_DoubleValue();
    public virtual float get_FloatValue();
    public virtual void Increment();
}
public class iTextSharp.text.pdf.PdfNumberTree : object {
    private static int leafSize;
    public static PdfDictionary WriteTree(Dictionary`2<int, T> items, PdfWriter writer);
    private static void IterateItems(PdfDictionary dic, Dictionary`2<int, PdfObject> items);
    public static Dictionary`2<int, PdfObject> ReadTree(PdfDictionary dic);
}
public abstract class iTextSharp.text.pdf.PdfObject : object {
    public static int BOOLEAN;
    public static int NUMBER;
    public static int STRING;
    public static int NAME;
    public static int ARRAY;
    public static int DICTIONARY;
    public static int STREAM;
    public static int NULL;
    public static int INDIRECT;
    public static string NOTHING;
    public static string TEXT_PDFDOCENCODING;
    public static string TEXT_UNICODE;
    protected Byte[] bytes;
    protected int type;
    protected PRIndirectReference indRef;
    private int hashCode;
    private static int objCounter;
    private static object locker;
    public int Length { get; }
    unknown string Content {protected set; }
    public int Type { get; }
    public PRIndirectReference IndRef { get; public set; }
    protected PdfObject(int type);
    protected PdfObject(int type, string content);
    protected PdfObject(int type, Byte[] bytes);
    private static PdfObject();
    public virtual void ToPdf(PdfWriter writer, Stream os);
    public virtual Byte[] GetBytes();
    public virtual bool CanBeInObjStm();
    public virtual string ToString();
    public virtual int get_Length();
    protected virtual void set_Content(string value);
    public virtual int get_Type();
    public virtual bool IsNull();
    public virtual bool IsBoolean();
    public virtual bool IsNumber();
    public virtual bool IsString();
    public virtual bool IsName();
    public virtual bool IsArray();
    public virtual bool IsDictionary();
    public virtual bool IsStream();
    public virtual bool IsIndirect();
    public virtual PRIndirectReference get_IndRef();
    public virtual void set_IndRef(PRIndirectReference value);
    public virtual int CompareTo(PdfObject obj);
    public virtual int GetHashCode();
    public virtual bool Equals(object obj);
    private static int IncrementObjCounter();
}
public class iTextSharp.text.pdf.PdfOCProperties : PdfDictionary {
}
public class iTextSharp.text.pdf.PdfOutline : PdfDictionary {
    private PdfIndirectReference reference;
    private int count;
    private PdfOutline parent;
    private PdfDestination destination;
    private PdfAction action;
    protected List`1<PdfOutline> kids;
    protected PdfWriter writer;
    private string tag;
    private bool open;
    private BaseColor color;
    private int style;
    public PdfIndirectReference IndirectReference { get; public set; }
    public PdfOutline Parent { get; }
    public PdfDestination PdfDestination { get; }
    internal int Count { get; internal set; }
    public int Level { get; }
    public List`1<PdfOutline> Kids { get; public set; }
    public string Tag { get; public set; }
    public string Title { get; public set; }
    public bool Open { get; public set; }
    public BaseColor Color { get; public set; }
    public int Style { get; public set; }
    internal PdfOutline(PdfWriter writer);
    public PdfOutline(PdfOutline parent, PdfAction action, string title);
    public PdfOutline(PdfOutline parent, PdfAction action, string title, bool open);
    public PdfOutline(PdfOutline parent, PdfDestination destination, string title);
    public PdfOutline(PdfOutline parent, PdfDestination destination, string title, bool open);
    public PdfOutline(PdfOutline parent, PdfAction action, PdfString title);
    public PdfOutline(PdfOutline parent, PdfAction action, PdfString title, bool open);
    public PdfOutline(PdfOutline parent, PdfDestination destination, PdfString title);
    public PdfOutline(PdfOutline parent, PdfDestination destination, PdfString title, bool open);
    public PdfOutline(PdfOutline parent, PdfAction action, Paragraph title);
    public PdfOutline(PdfOutline parent, PdfAction action, Paragraph title, bool open);
    public PdfOutline(PdfOutline parent, PdfDestination destination, Paragraph title);
    public PdfOutline(PdfOutline parent, PdfDestination destination, Paragraph title, bool open);
    internal void InitOutline(PdfOutline parent, string title, bool open);
    public virtual PdfIndirectReference get_IndirectReference();
    public virtual void set_IndirectReference(PdfIndirectReference value);
    public virtual PdfOutline get_Parent();
    public virtual bool SetDestinationPage(PdfIndirectReference pageReference);
    public virtual PdfDestination get_PdfDestination();
    internal int get_Count();
    internal void set_Count(int value);
    public virtual int get_Level();
    public virtual void ToPdf(PdfWriter writer, Stream os);
    public virtual void AddKid(PdfOutline outline);
    public virtual List`1<PdfOutline> get_Kids();
    public virtual void set_Kids(List`1<PdfOutline> value);
    public virtual string get_Tag();
    public virtual void set_Tag(string value);
    public virtual string get_Title();
    public virtual void set_Title(string value);
    public virtual void set_Open(bool value);
    public virtual bool get_Open();
    public virtual BaseColor get_Color();
    public virtual void set_Color(BaseColor value);
    public virtual int get_Style();
    public virtual void set_Style(int value);
}
public class iTextSharp.text.pdf.PdfPage : PdfDictionary {
    private static String[] boxStrings;
    private static PdfName[] boxNames;
    public static PdfNumber PORTRAIT;
    public static PdfNumber LANDSCAPE;
    public static PdfNumber INVERTEDPORTRAIT;
    public static PdfNumber SEASCAPE;
    private PdfRectangle mediaBox;
    internal PdfRectangle MediaBox { get; }
    internal PdfPage(PdfRectangle mediaBox, Dictionary`2<string, PdfRectangle> boxSize, PdfDictionary resources, int rotate);
    internal PdfPage(PdfRectangle mediaBox, Dictionary`2<string, PdfRectangle> boxSize, PdfDictionary resources);
    private static PdfPage();
    public virtual bool IsParent();
    internal void Add(PdfIndirectReference contents);
    internal PdfRectangle RotateMediaBox();
    internal PdfRectangle get_MediaBox();
}
public class iTextSharp.text.pdf.PdfPageEventHelper : object {
    public virtual void OnOpenDocument(PdfWriter writer, Document document);
    public virtual void OnStartPage(PdfWriter writer, Document document);
    public virtual void OnEndPage(PdfWriter writer, Document document);
    public virtual void OnCloseDocument(PdfWriter writer, Document document);
    public virtual void OnParagraph(PdfWriter writer, Document document, float paragraphPosition);
    public virtual void OnParagraphEnd(PdfWriter writer, Document document, float paragraphPosition);
    public virtual void OnChapter(PdfWriter writer, Document document, float paragraphPosition, Paragraph title);
    public virtual void OnChapterEnd(PdfWriter writer, Document document, float position);
    public virtual void OnSection(PdfWriter writer, Document document, float paragraphPosition, int depth, Paragraph title);
    public virtual void OnSectionEnd(PdfWriter writer, Document document, float position);
    public virtual void OnGenericTag(PdfWriter writer, Document document, Rectangle rect, string text);
}
public class iTextSharp.text.pdf.PdfPageLabels : object {
    public static int DECIMAL_ARABIC_NUMERALS;
    public static int UPPERCASE_ROMAN_NUMERALS;
    public static int LOWERCASE_ROMAN_NUMERALS;
    public static int UPPERCASE_LETTERS;
    public static int LOWERCASE_LETTERS;
    public static int EMPTY;
    internal static PdfName[] numberingStyle;
    internal Dictionary`2<int, PdfDictionary> map;
    private static PdfPageLabels();
    public virtual void AddPageLabel(int page, int numberStyle, string text, int firstPage);
    public void AddPageLabel(int page, int numberStyle, string text, int firstPage, bool includeFirstPage);
    public virtual void AddPageLabel(int page, int numberStyle, string text);
    public virtual void AddPageLabel(int page, int numberStyle);
    public virtual void AddPageLabel(PdfPageLabelFormat format);
    public virtual void RemovePageLabel(int page);
    public virtual PdfDictionary GetDictionary(PdfWriter writer);
    public static String[] GetPageLabels(PdfReader reader);
    public static PdfPageLabelFormat[] GetPageLabelFormats(PdfReader reader);
}
public class iTextSharp.text.pdf.PdfPages : object {
    private List`1<PdfIndirectReference> pages;
    private List`1<PdfIndirectReference> parents;
    private int leafSize;
    private PdfWriter writer;
    private PdfIndirectReference topParent;
    internal PdfIndirectReference TopParent { get; }
    internal PdfPages(PdfWriter writer);
    internal void AddPage(PdfDictionary page);
    internal PdfIndirectReference AddPageRef(PdfIndirectReference pageRef);
    internal PdfIndirectReference WritePageTree();
    internal PdfIndirectReference get_TopParent();
    internal void SetLinearMode(PdfIndirectReference topParent);
    internal void AddPage(PdfIndirectReference page);
    internal int ReorderPages(Int32[] order);
}
public class iTextSharp.text.pdf.PdfPattern : PdfStream {
    internal PdfPattern(PdfPatternPainter painter);
    internal PdfPattern(PdfPatternPainter painter, int compressionLevel);
}
public class iTextSharp.text.pdf.PdfPatternPainter : PdfTemplate {
    internal float xstep;
    internal float ystep;
    internal bool stencil;
    internal BaseColor defaultColor;
    public float XStep { get; public set; }
    public float YStep { get; public set; }
    public PdfContentByte Duplicate { get; }
    public BaseColor DefaultColor { get; }
    internal PdfPatternPainter(PdfWriter wr);
    internal PdfPatternPainter(PdfWriter wr, BaseColor defaultColor);
    public float get_XStep();
    public void set_XStep(float value);
    public float get_YStep();
    public void set_YStep(float value);
    public bool IsStencil();
    public void SetPatternMatrix(float a, float b, float c, float d, float e, float f);
    public PdfPattern GetPattern();
    public PdfPattern GetPattern(int compressionLevel);
    public virtual PdfContentByte get_Duplicate();
    public BaseColor get_DefaultColor();
    public virtual void SetGrayFill(float gray);
    public virtual void ResetGrayFill();
    public virtual void SetGrayStroke(float gray);
    public virtual void ResetGrayStroke();
    public virtual void SetRGBColorFillF(float red, float green, float blue);
    public virtual void ResetRGBColorFill();
    public virtual void SetRGBColorStrokeF(float red, float green, float blue);
    public virtual void ResetRGBColorStroke();
    public virtual void SetCMYKColorFillF(float cyan, float magenta, float yellow, float black);
    public virtual void ResetCMYKColorFill();
    public virtual void SetCMYKColorStrokeF(float cyan, float magenta, float yellow, float black);
    public virtual void ResetCMYKColorStroke();
    public virtual void AddImage(Image image, float a, float b, float c, float d, float e, float f);
    public virtual void SetCMYKColorFill(int cyan, int magenta, int yellow, int black);
    public virtual void SetCMYKColorStroke(int cyan, int magenta, int yellow, int black);
    public virtual void SetRGBColorFill(int red, int green, int blue);
    public virtual void SetRGBColorStroke(int red, int green, int blue);
    public virtual void SetColorStroke(BaseColor color);
    public virtual void SetColorFill(BaseColor color);
    public virtual void SetColorFill(PdfSpotColor sp, float tint);
    public virtual void SetColorStroke(PdfSpotColor sp, float tint);
    public virtual void SetPatternFill(PdfPatternPainter p);
    public virtual void SetPatternFill(PdfPatternPainter p, BaseColor color, float tint);
    public virtual void SetPatternStroke(PdfPatternPainter p, BaseColor color, float tint);
    public virtual void SetPatternStroke(PdfPatternPainter p);
    internal void CheckNoColor();
}
public class iTextSharp.text.pdf.PdfPCell : Rectangle {
    private ColumnText column;
    private int verticalAlignment;
    private float paddingLeft;
    private float paddingRight;
    private float paddingTop;
    private float paddingBottom;
    private float fixedHeight;
    private float calculatedHeight;
    private bool noWrap;
    private PdfPTable table;
    private float minimumHeight;
    private float cachedMaxHeight;
    private int colspan;
    private int rowspan;
    private Image image;
    private IPdfPCellEvent cellEvent;
    private bool useDescender;
    private bool useBorderPadding;
    protected Phrase phrase;
    private int rotation;
    protected PdfName role;
    protected Dictionary`2<PdfName, PdfObject> accessibleAttributes;
    protected internal AccessibleElementId id;
    protected List`1<PdfPHeaderCell> headers;
    public Phrase Phrase { get; public set; }
    public int HorizontalAlignment { get; public set; }
    public int VerticalAlignment { get; public set; }
    public float EffectivePaddingLeft { get; }
    public float PaddingLeft { get; public set; }
    public float EffectivePaddingRight { get; }
    public float PaddingRight { get; public set; }
    public float EffectivePaddingTop { get; }
    public float PaddingTop { get; public set; }
    public float EffectivePaddingBottom { get; }
    public float PaddingBottom { get; public set; }
    unknown float Padding {public set; }
    public bool UseBorderPadding { get; public set; }
    public float Leading { get; }
    public float MultipliedLeading { get; }
    public float Indent { get; public set; }
    public float ExtraParagraphSpace { get; public set; }
    public float CalculatedHeight { get; public set; }
    public float FixedHeight { get; public set; }
    public float CachedMaxHeight { get; }
    public bool NoWrap { get; public set; }
    public PdfPTable Table { get; public set; }
    public float MinimumHeight { get; public set; }
    public int Colspan { get; public set; }
    public int Rowspan { get; public set; }
    public float FollowingIndent { get; public set; }
    public float RightIndent { get; public set; }
    public float SpaceCharRatio { get; public set; }
    public int RunDirection { get; public set; }
    public Image Image { get; public set; }
    public IPdfPCellEvent CellEvent { get; public set; }
    public int ArabicOptions { get; public set; }
    public bool UseAscender { get; public set; }
    public bool UseDescender { get; public set; }
    public ColumnText Column { get; public set; }
    public List`1<IElement> CompositeElements { get; }
    public int Rotation { get; public set; }
    public PdfName Role { get; public set; }
    public AccessibleElementId ID { get; public set; }
    public bool IsInline { get; }
    public List`1<PdfPHeaderCell> Headers { get; }
    public PdfPCell(Phrase phrase);
    public PdfPCell(Image image);
    public PdfPCell(Image image, bool fit);
    public PdfPCell(PdfPTable table);
    public PdfPCell(PdfPTable table, PdfPCell style);
    public PdfPCell(PdfPCell cell);
    public virtual void AddElement(IElement element);
    public virtual Phrase get_Phrase();
    public virtual void set_Phrase(Phrase value);
    public virtual int get_HorizontalAlignment();
    public virtual void set_HorizontalAlignment(int value);
    public virtual int get_VerticalAlignment();
    public virtual void set_VerticalAlignment(int value);
    public virtual float get_EffectivePaddingLeft();
    public virtual float get_PaddingLeft();
    public virtual void set_PaddingLeft(float value);
    public virtual float get_EffectivePaddingRight();
    public virtual float get_PaddingRight();
    public virtual void set_PaddingRight(float value);
    public virtual float get_EffectivePaddingTop();
    public virtual float get_PaddingTop();
    public virtual void set_PaddingTop(float value);
    public virtual float get_EffectivePaddingBottom();
    public virtual float get_PaddingBottom();
    public virtual void set_PaddingBottom(float value);
    public virtual void set_Padding(float value);
    public virtual void set_UseBorderPadding(bool value);
    public virtual bool get_UseBorderPadding();
    public virtual void SetLeading(float fixedLeading, float multipliedLeading);
    public virtual float get_Leading();
    public virtual float get_MultipliedLeading();
    public virtual float get_Indent();
    public virtual void set_Indent(float value);
    public virtual float get_ExtraParagraphSpace();
    public virtual void set_ExtraParagraphSpace(float value);
    public virtual float get_CalculatedHeight();
    public virtual void set_CalculatedHeight(float value);
    public virtual bool HasCalculatedHeight();
    public virtual float get_FixedHeight();
    public virtual void set_FixedHeight(float value);
    public virtual bool HasFixedHeight();
    public float get_CachedMaxHeight();
    public bool HasCachedMaxHeight();
    public virtual void set_NoWrap(bool value);
    public virtual bool get_NoWrap();
    public virtual PdfPTable get_Table();
    public virtual void set_Table(PdfPTable value);
    public virtual float get_MinimumHeight();
    public virtual void set_MinimumHeight(float value);
    public virtual bool HasMinimumHeight();
    public virtual int get_Colspan();
    public virtual void set_Colspan(int value);
    public virtual int get_Rowspan();
    public virtual void set_Rowspan(int value);
    public virtual float get_FollowingIndent();
    public virtual void set_FollowingIndent(float value);
    public virtual float get_RightIndent();
    public virtual void set_RightIndent(float value);
    public virtual float get_SpaceCharRatio();
    public virtual void set_SpaceCharRatio(float value);
    public virtual int get_RunDirection();
    public virtual void set_RunDirection(int value);
    public virtual Image get_Image();
    public virtual void set_Image(Image value);
    public virtual IPdfPCellEvent get_CellEvent();
    public virtual void set_CellEvent(IPdfPCellEvent value);
    public virtual int get_ArabicOptions();
    public virtual void set_ArabicOptions(int value);
    public virtual bool get_UseAscender();
    public virtual void set_UseAscender(bool value);
    public virtual bool get_UseDescender();
    public virtual void set_UseDescender(bool value);
    public virtual ColumnText get_Column();
    public virtual void set_Column(ColumnText value);
    public virtual List`1<IElement> get_CompositeElements();
    public void set_Rotation(int value);
    public int get_Rotation();
    public virtual float GetMaxHeight();
    public virtual PdfObject GetAccessibleAttribute(PdfName key);
    public virtual void SetAccessibleAttribute(PdfName key, PdfObject value);
    public virtual Dictionary`2<PdfName, PdfObject> GetAccessibleAttributes();
    public virtual PdfName get_Role();
    public virtual void set_Role(PdfName value);
    public virtual AccessibleElementId get_ID();
    public virtual void set_ID(AccessibleElementId value);
    public virtual bool get_IsInline();
    public virtual List`1<PdfPHeaderCell> get_Headers();
    public virtual void AddHeader(PdfPHeaderCell header);
}
public class iTextSharp.text.pdf.PdfPHeaderCell : PdfPCell {
    public static int NONE;
    public static int ROW;
    public static int COLUMN;
    public static int BOTH;
    protected int scope;
    protected string name;
    public int Scope { get; public set; }
    public string Name { get; public set; }
    public PdfName Role { get; public set; }
    public PdfPHeaderCell(PdfPHeaderCell headerCell);
    public virtual int get_Scope();
    public virtual void set_Scope(int value);
    public virtual string get_Name();
    public virtual void set_Name(string value);
    public virtual PdfName get_Role();
    public virtual void set_Role(PdfName value);
}
public class iTextSharp.text.pdf.PdfPRow : object {
    public static float BOTTOM_LIMIT;
    public static float RIGHT_LIMIT;
    private ILogger LOGGER;
    public bool mayNotBreak;
    protected PdfPCell[] cells;
    protected Single[] widths;
    protected Single[] extraHeights;
    protected internal float maxHeight;
    protected internal bool calculated;
    protected bool adjusted;
    private Int32[] canvasesPos;
    protected PdfName role;
    protected Dictionary`2<PdfName, PdfObject> accessibleAttributes;
    protected AccessibleElementId id;
    public bool MayNotBreak { get; public set; }
    public float MaxHeights { get; public set; }
    public bool Adjusted { get; public set; }
    public PdfName Role { get; public set; }
    public AccessibleElementId ID { get; public set; }
    public bool IsInline { get; }
    public PdfPRow(PdfPCell[] cells);
    public PdfPRow(PdfPCell[] cells, PdfPRow source);
    public PdfPRow(PdfPRow row);
    public virtual bool SetWidths(Single[] widths);
    protected internal virtual void InitExtraHeights();
    public virtual void SetExtraHeight(int cell, float height);
    protected internal virtual void CalculateHeights();
    public virtual bool get_MayNotBreak();
    public virtual void set_MayNotBreak(bool value);
    public virtual void WriteBorderAndBackground(float xPos, float yPos, float currentMaxHeight, PdfPCell cell, PdfContentByte[] canvases);
    protected virtual void SaveAndRotateCanvases(PdfContentByte[] canvases, float a, float b, float c, float d, float e, float f);
    protected virtual void RestoreCanvases(PdfContentByte[] canvases);
    public static float SetColumn(ColumnText ct, float left, float bottom, float right, float top);
    public virtual void WriteCells(int colStart, int colEnd, float xPos, float yPos, PdfContentByte[] canvases, bool reusable);
    public virtual bool IsCalculated();
    public virtual float get_MaxHeights();
    public virtual void set_MaxHeights(float value);
    internal Single[] GetEventWidth(float xPos, Single[] absoluteWidths);
    public virtual void CopyRowContent(PdfPTable table, int idx);
    public virtual PdfPRow SplitRow(PdfPTable table, int rowIndex, float new_height);
    public virtual float GetMaxRowHeightsWithoutCalculating();
    public virtual void SetFinalMaxHeights(float maxHeight);
    public virtual void SplitRowspans(PdfPTable original, int originalIdx, PdfPTable part, int partIdx);
    public virtual PdfPCell[] GetCells();
    public virtual bool HasRowspan();
    public virtual bool get_Adjusted();
    public virtual void set_Adjusted(bool value);
    public virtual PdfObject GetAccessibleAttribute(PdfName key);
    public virtual void SetAccessibleAttribute(PdfName key, PdfObject value);
    public virtual Dictionary`2<PdfName, PdfObject> GetAccessibleAttributes();
    public virtual PdfName get_Role();
    public virtual void set_Role(PdfName value);
    public virtual AccessibleElementId get_ID();
    public virtual void set_ID(AccessibleElementId value);
    private static bool IsTagged(PdfContentByte canvas);
    public virtual bool get_IsInline();
}
public class iTextSharp.text.pdf.PdfPSXObject : PdfTemplate {
    public PdfContentByte Duplicate { get; }
    public PdfPSXObject(PdfWriter wr);
    public virtual PdfStream GetFormXObject(int compressionLevel);
    public virtual PdfContentByte get_Duplicate();
}
public class iTextSharp.text.pdf.PdfPTable : object {
    public static int BASECANVAS;
    public static int BACKGROUNDCANVAS;
    public static int LINECANVAS;
    public static int TEXTCANVAS;
    private ILogger LOGGER;
    protected List`1<PdfPRow> rows;
    protected float totalHeight;
    protected PdfPCell[] currentRow;
    protected int currentColIdx;
    protected PdfPCell defaultCell;
    protected float totalWidth;
    protected Single[] relativeWidths;
    protected Single[] absoluteWidths;
    protected IPdfPTableEvent tableEvent;
    protected int headerRows;
    protected float widthPercentage;
    private int horizontalAlignment;
    private bool skipFirstHeader;
    private bool skipLastFooter;
    protected bool isColspan;
    protected int runDirection;
    private bool lockedWidth;
    private bool splitRows;
    protected float spacingBefore;
    protected float spacingAfter;
    protected float paddingTop;
    private Boolean[] extendLastRow;
    private bool headersInEvent;
    private bool splitLate;
    private bool keepTogether;
    protected bool complete;
    private int footerRows;
    protected bool rowCompleted;
    protected bool loopCheck;
    protected bool rowsNotChecked;
    protected PdfName role;
    protected Dictionary`2<PdfName, PdfObject> accessibleAttributes;
    protected AccessibleElementId id;
    private PdfPTableHeader header;
    private PdfPTableBody body;
    private PdfPTableFooter footer;
    private int numberOfWrittenRows;
    public bool Complete { get; public set; }
    public float TotalWidth { get; public set; }
    public PdfPCell DefaultCell { get; }
    public int Size { get; }
    public float TotalHeight { get; }
    public float HeaderHeight { get; }
    public float FooterHeight { get; }
    public int NumberOfColumns { get; }
    public int HeaderRows { get; public set; }
    public int FooterRows { get; public set; }
    public IList`1<Chunk> Chunks { get; }
    public int Type { get; }
    public float WidthPercentage { get; public set; }
    public int HorizontalAlignment { get; public set; }
    public List`1<PdfPRow> Rows { get; }
    public IPdfPTableEvent TableEvent { get; public set; }
    public Single[] AbsoluteWidths { get; }
    public bool SkipFirstHeader { get; public set; }
    public bool SkipLastFooter { get; public set; }
    public int RunDirection { get; public set; }
    public bool LockedWidth { get; public set; }
    public bool SplitRows { get; public set; }
    public float SpacingBefore { get; public set; }
    public float SpacingAfter { get; public set; }
    public float PaddingTop { get; public set; }
    public string Summary { get; public set; }
    public bool ExtendLastRow { get; public set; }
    public bool HeadersInEvent { get; public set; }
    public bool SplitLate { get; public set; }
    public bool KeepTogether { get; public set; }
    public bool ElementComplete { get; public set; }
    public bool LoopCheck { get; public set; }
    public PdfName Role { get; public set; }
    public AccessibleElementId ID { get; public set; }
    public bool IsInline { get; }
    public PdfPTable(Single[] relativeWidths);
    public PdfPTable(int numColumns);
    public PdfPTable(PdfPTable table);
    public virtual bool get_Complete();
    public virtual void set_Complete(bool value);
    public virtual void Init();
    public static PdfPTable ShallowCopy(PdfPTable table);
    protected internal virtual void CopyFormat(PdfPTable sourceTable);
    public virtual void SetWidths(Single[] relativeWidths);
    public virtual void SetWidths(Int32[] relativeWidths);
    protected internal virtual void CalculateWidths();
    public virtual void SetTotalWidth(Single[] columnWidth);
    public virtual void SetWidthPercentage(Single[] columnWidth, Rectangle pageSize);
    public virtual float get_TotalWidth();
    public virtual void set_TotalWidth(float value);
    public virtual float CalculateHeights();
    public virtual void ResetColumnCount(int newColCount);
    public virtual PdfPCell get_DefaultCell();
    public virtual PdfPCell AddCell(PdfPCell cell);
    private void SkipColsWithRowspanAbove();
    internal PdfPCell CellAt(int row, int col);
    internal bool RowSpanAbove(int currRow, int currCol);
    public virtual void AddCell(string text);
    public virtual void AddCell(PdfPTable table);
    public virtual void AddCell(Image image);
    public virtual void AddCell(Phrase phrase);
    public virtual float WriteSelectedRows(int rowStart, int rowEnd, float xPos, float yPos, PdfContentByte[] canvases);
    public virtual float WriteSelectedRows(int colStart, int colEnd, int rowStart, int rowEnd, float xPos, float yPos, PdfContentByte[] canvases);
    public virtual float WriteSelectedRows(int colStart, int colEnd, int rowStart, int rowEnd, float xPos, float yPos, PdfContentByte[] canvases, bool reusable);
    private PdfPTableBody OpenTableBlock(PdfPTableBody block, PdfContentByte canvas);
    private PdfPTableBody CloseTableBlock(PdfPTableBody block, PdfContentByte canvas);
    public virtual float WriteSelectedRows(int rowStart, int rowEnd, float xPos, float yPos, PdfContentByte canvas);
    public virtual float WriteSelectedRows(int colStart, int colEnd, int rowStart, int rowEnd, float xPos, float yPos, PdfContentByte canvas);
    public virtual float WriteSelectedRows(int colStart, int colEnd, int rowStart, int rowEnd, float xPos, float yPos, PdfContentByte canvas, bool reusable);
    public static PdfContentByte[] BeginWritingRows(PdfContentByte canvas);
    public static void EndWritingRows(PdfContentByte[] canvases);
    public virtual int get_Size();
    public virtual float get_TotalHeight();
    public virtual float GetRowHeight(int idx);
    protected internal virtual float GetRowHeight(int idx, bool firsttime);
    public virtual float GetRowspanHeight(int rowIndex, int cellIndex);
    public virtual bool HasRowspan(int rowIdx);
    public virtual void NormalizeHeadersFooters();
    public virtual float get_HeaderHeight();
    public virtual float get_FooterHeight();
    public virtual bool DeleteRow(int rowNumber);
    public virtual bool DeleteLastRow();
    public virtual void DeleteBodyRows();
    public virtual int get_NumberOfColumns();
    public virtual int get_HeaderRows();
    public virtual void set_HeaderRows(int value);
    public virtual int get_FooterRows();
    public virtual void set_FooterRows(int value);
    public virtual IList`1<Chunk> get_Chunks();
    public virtual int get_Type();
    public virtual bool IsContent();
    public virtual bool IsNestable();
    public virtual bool Process(IElementListener listener);
    public virtual float get_WidthPercentage();
    public virtual void set_WidthPercentage(float value);
    public virtual int get_HorizontalAlignment();
    public virtual void set_HorizontalAlignment(int value);
    public virtual PdfPRow GetRow(int idx);
    public virtual int getLastCompletedRowIndex();
    public virtual void SetBreakPoints(Int32[] breakPoints);
    public virtual void KeepRowsTogether(Int32[] rows);
    public virtual void KeepRowsTogether(int start, int end);
    public virtual void KeepRowsTogether(int start);
    public virtual List`1<PdfPRow> get_Rows();
    public virtual List`1<PdfPRow> GetRows(int start, int end);
    protected virtual PdfPRow AdjustCellsInRow(int start, int end);
    public virtual IPdfPTableEvent get_TableEvent();
    public virtual void set_TableEvent(IPdfPTableEvent value);
    public virtual Single[] get_AbsoluteWidths();
    internal Single[][] GetEventWidths(float xPos, int firstRow, int lastRow, bool includeHeaders);
    public virtual bool get_SkipFirstHeader();
    public virtual void set_SkipFirstHeader(bool value);
    public virtual bool get_SkipLastFooter();
    public virtual void set_SkipLastFooter(bool value);
    public virtual int get_RunDirection();
    public virtual void set_RunDirection(int value);
    public virtual bool get_LockedWidth();
    public virtual void set_LockedWidth(bool value);
    public virtual bool get_SplitRows();
    public virtual void set_SplitRows(bool value);
    public virtual float get_SpacingBefore();
    public virtual void set_SpacingBefore(float value);
    public virtual float get_SpacingAfter();
    public virtual void set_SpacingAfter(float value);
    public virtual float get_PaddingTop();
    public virtual void set_PaddingTop(float value);
    public virtual string get_Summary();
    public virtual void set_Summary(string value);
    public virtual bool get_ExtendLastRow();
    public virtual void set_ExtendLastRow(bool value);
    public virtual void SetExtendLastRow(bool extendLastRows, bool extendFinalRow);
    public virtual bool IsExtendLastRow(bool newPageFollows);
    public virtual bool get_HeadersInEvent();
    public virtual void set_HeadersInEvent(bool value);
    public virtual bool get_SplitLate();
    public virtual void set_SplitLate(bool value);
    public virtual void set_KeepTogether(bool value);
    public virtual bool get_KeepTogether();
    public virtual void CompleteRow();
    public virtual void FlushContent();
    internal virtual void AddNumberOfRowsWritten(int numberOfWrittenRows);
    public virtual bool get_ElementComplete();
    public virtual void set_ElementComplete(bool value);
    public virtual bool get_LoopCheck();
    public virtual void set_LoopCheck(bool value);
    public virtual PdfObject GetAccessibleAttribute(PdfName key);
    public virtual void SetAccessibleAttribute(PdfName key, PdfObject value);
    public virtual Dictionary`2<PdfName, PdfObject> GetAccessibleAttributes();
    public virtual PdfName get_Role();
    public virtual void set_Role(PdfName value);
    public virtual AccessibleElementId get_ID();
    public virtual void set_ID(AccessibleElementId value);
    public virtual bool get_IsInline();
    public virtual PdfPTableHeader GetHeader();
    public virtual PdfPTableBody GetBody();
    public virtual PdfPTableFooter GetFooter();
    public virtual int GetCellStartRowIndex(int rowIdx, int colIdx);
    public virtual FittingRows GetFittingRows(float availableHeight, int startIdx);
}
public class iTextSharp.text.pdf.PdfPTableBody : object {
    protected AccessibleElementId id;
    protected internal List`1<PdfPRow> rows;
    protected PdfName role;
    protected Dictionary`2<PdfName, PdfObject> accessibleAttributes;
    public PdfName Role { get; public set; }
    public AccessibleElementId ID { get; public set; }
    public bool IsInline { get; }
    public virtual PdfObject GetAccessibleAttribute(PdfName key);
    public virtual void SetAccessibleAttribute(PdfName key, PdfObject value);
    public virtual Dictionary`2<PdfName, PdfObject> GetAccessibleAttributes();
    public virtual PdfName get_Role();
    public virtual void set_Role(PdfName value);
    public virtual AccessibleElementId get_ID();
    public virtual void set_ID(AccessibleElementId value);
    public virtual bool get_IsInline();
}
public class iTextSharp.text.pdf.PdfPTableFooter : PdfPTableBody {
    public PdfName Role { get; public set; }
    public virtual PdfName get_Role();
    public virtual void set_Role(PdfName value);
}
public class iTextSharp.text.pdf.PdfPTableHeader : PdfPTableBody {
    public PdfName Role { get; public set; }
    public virtual PdfName get_Role();
    public virtual void set_Role(PdfName value);
}
public class iTextSharp.text.pdf.PdfPublicKeyRecipient : object {
    private X509Certificate certificate;
    private int permission;
    protected Byte[] cms;
    public X509Certificate Certificate { get; }
    public int Permission { get; }
    protected internal Byte[] Cms { get; protected internal set; }
    public PdfPublicKeyRecipient(X509Certificate certificate, int permission);
    public virtual X509Certificate get_Certificate();
    public virtual int get_Permission();
    protected internal virtual void set_Cms(Byte[] value);
    protected internal virtual Byte[] get_Cms();
}
public class iTextSharp.text.pdf.PdfPublicKeySecurityHandler : object {
    private static int SEED_LENGTH;
    private List`1<PdfPublicKeyRecipient> recipients;
    private Byte[] seed;
    public virtual void AddRecipient(PdfPublicKeyRecipient recipient);
    protected internal virtual Byte[] GetSeed();
    public virtual int GetRecipientsSize();
    public virtual Byte[] GetEncodedRecipient(int index);
    public virtual PdfArray GetEncodedRecipients();
    private Asn1Object CreateDERForRecipient(Byte[] inp, X509Certificate cert);
    private KeyTransRecipientInfo ComputeRecipientInfo(X509Certificate x509certificate, Byte[] abyte0);
}
public class iTextSharp.text.pdf.PdfReader : object {
    public static bool unethicalreading;
    public static bool debugmode;
    private static ILogger LOGGER;
    private static PdfName[] pageInhCandidates;
    private static Byte[] endstream;
    private static Byte[] endobj;
    protected internal PRTokeniser tokens;
    protected internal Int64[] xref;
    protected internal Dictionary`2<int, IntHashtable> objStmMark;
    protected internal LongHashtable objStmToOffset;
    protected internal bool newXrefType;
    protected List`1<PdfObject> xrefObj;
    private PdfDictionary rootPages;
    protected internal PdfDictionary trailer;
    protected internal PdfDictionary catalog;
    protected internal PageRefs pageRefs;
    protected internal PRAcroForm acroForm;
    protected internal bool acroFormParsed;
    protected internal bool encrypted;
    protected internal bool rebuilt;
    protected internal int freeXref;
    protected internal bool tampered;
    protected internal long lastXref;
    protected internal long eofPos;
    protected internal char pdfVersion;
    protected internal PdfEncryption decrypt;
    protected internal Byte[] password;
    protected ICipherParameters certificateKey;
    protected X509Certificate certificate;
    private bool ownerPasswordUsed;
    protected internal List`1<PdfString> strings;
    protected internal bool sharedStreams;
    protected internal bool consolidateNamedDestinations;
    protected bool remoteToLocalNamedDestinations;
    protected internal int rValue;
    protected internal long pValue;
    private int objNum;
    private int objGen;
    private long fileLength;
    private bool hybridXref;
    private int lastXrefPartial;
    private bool partial;
    private PRIndirectReference cryptoRef;
    private PdfViewerPreferencesImp viewerPreferences;
    private bool encryptionError;
    internal MemoryLimitsAwareHandler memoryLimitsAwareHandler;
    private bool appendable;
    protected static ICounter COUNTER;
    private int readDepth;
    public RandomAccessFileOrArray SafeFile { get; }
    public int NumberOfPages { get; }
    public PdfDictionary Catalog { get; }
    public PRAcroForm AcroForm { get; }
    public Dictionary`2<string, string> Info { get; }
    public bool Tampered { get; public set; }
    public Byte[] Metadata { get; }
    public long LastXref { get; }
    public int XrefSize { get; }
    public long EofPos { get; }
    public char PdfVersion { get; }
    public long Permissions { get; }
    public PdfDictionary Trailer { get; }
    internal PdfEncryption Decrypt { get; }
    public AcroFields AcroFields { get; }
    public string JavaScript { get; }
    unknown int ViewerPreferences {public set; }
    public int SimpleViewerPreferences { get; }
    public bool Appendable { get; public set; }
    public long FileLength { get; }
    public bool IsOpenedWithFullPermissions { get; }
    private PdfReader(IRandomAccessSource byteSource, bool partialRead, Byte[] ownerPassword, X509Certificate certificate, ICipherParameters certificateKey, bool closeSourceOnConstructorError);
    private PdfReader(ReaderProperties properties, IRandomAccessSource byteSource);
    public PdfReader(string filename);
    public PdfReader(ReaderProperties properties, string filename);
    public PdfReader(string filename, Byte[] ownerPassword);
    public PdfReader(string filename, Byte[] ownerPassword, bool partial);
    public PdfReader(Byte[] pdfIn);
    public PdfReader(Byte[] pdfIn, Byte[] ownerPassword);
    public PdfReader(string filename, X509Certificate certificate, ICipherParameters certificateKey);
    public PdfReader(Uri url);
    public PdfReader(Uri url, Byte[] ownerPassword);
    public PdfReader(Stream isp, Byte[] ownerPassword);
    public PdfReader(ReaderProperties properties, Stream isp);
    public PdfReader(Stream isp);
    public PdfReader(RandomAccessFileOrArray raf, Byte[] ownerPassword);
    public PdfReader(RandomAccessFileOrArray raf, Byte[] ownerPassword, bool partial);
    public PdfReader(PdfReader reader);
    private static PdfReader();
    protected virtual ICounter GetCounter();
    internal MemoryLimitsAwareHandler GetMemoryLimitsAwareHandler();
    private static PRTokeniser GetOffsetTokeniser(IRandomAccessSource byteSource);
    public virtual RandomAccessFileOrArray get_SafeFile();
    protected internal virtual PdfReaderInstance GetPdfReaderInstance(PdfWriter writer);
    public virtual int get_NumberOfPages();
    public virtual PdfDictionary get_Catalog();
    public virtual PRAcroForm get_AcroForm();
    public virtual int GetPageRotation(int index);
    internal int GetPageRotation(PdfDictionary page);
    public virtual Rectangle GetPageSizeWithRotation(int index);
    public virtual Rectangle GetPageSizeWithRotation(PdfDictionary page);
    public virtual Rectangle GetPageSize(int index);
    public virtual Rectangle GetPageSize(PdfDictionary page);
    public virtual Rectangle GetCropBox(int index);
    public virtual Rectangle GetBoxSize(int index, string boxName);
    public virtual Dictionary`2<string, string> get_Info();
    public static Rectangle GetNormalizedRectangle(PdfArray box);
    public virtual bool IsTagged();
    protected internal virtual void ReadPdf();
    protected internal virtual void ReadPdfPartial();
    private bool EqualsArray(Byte[] ar1, Byte[] ar2, int size);
    private void ReadDecryptedDocObj();
    public static PdfObject GetPdfObjectRelease(PdfObject obj);
    public static PdfObject GetPdfObject(PdfObject obj);
    public static PdfObject GetPdfObjectRelease(PdfObject obj, PdfObject parent);
    public static PdfObject GetPdfObject(PdfObject obj, PdfObject parent);
    public virtual PdfObject GetPdfObjectRelease(int idx);
    public virtual PdfObject GetPdfObject(int idx);
    public virtual void ResetLastXrefPartial();
    public virtual void ReleaseLastXrefPartial();
    public static void ReleaseLastXrefPartial(PdfObject obj);
    private void SetXrefPartialObject(int idx, PdfObject obj);
    public virtual PRIndirectReference AddPdfObject(PdfObject obj);
    protected internal virtual void ReadPages();
    protected internal virtual void ReadDocObjPartial();
    protected internal virtual PdfObject ReadSingleObject(int k);
    protected internal virtual PdfObject ReadOneObjStm(PRStream stream, int idx);
    public virtual double DumpPerc();
    protected internal virtual void ReadDocObj();
    private void CheckPRStreamLength(PRStream stream);
    protected internal virtual void ReadObjStm(PRStream stream, IntHashtable map);
    public static PdfObject KillIndirect(PdfObject obj);
    private void EnsureXrefSize(int size);
    protected internal virtual void ReadXref();
    protected internal virtual PdfDictionary ReadXrefSection();
    protected internal virtual bool ReadXRefStream(long ptr);
    protected internal virtual void RebuildXref();
    protected internal virtual PdfDictionary ReadDictionary();
    protected internal virtual PdfArray ReadArray();
    protected internal virtual PdfObject ReadPRObject();
    public static Byte[] FlateDecode(Byte[] inp);
    internal static Byte[] FlateDecode(Byte[] inp, MemoryStream outS);
    public static Byte[] DecodePredictor(Byte[] inp, PdfObject dicPar);
    public static Byte[] FlateDecode(Byte[] inp, bool strict);
    internal static Byte[] FlateDecode(Byte[] inp, bool strict, MemoryStream outp);
    public static Byte[] ASCIIHexDecode(Byte[] inp);
    internal static Byte[] ASCIIHexDecode(Byte[] inp, MemoryStream outp);
    public static Byte[] ASCII85Decode(Byte[] inp);
    internal static Byte[] ASCII85Decode(Byte[] inp, MemoryStream outp);
    public static Byte[] LZWDecode(Byte[] inp);
    internal static Byte[] LZWDecode(Byte[] inp, MemoryStream outp);
    public virtual bool IsRebuilt();
    public virtual PdfDictionary GetPageN(int pageNum);
    public virtual PdfDictionary GetPageNRelease(int pageNum);
    public virtual void ReleasePage(int pageNum);
    public virtual void ResetReleasePage();
    public virtual PRIndirectReference GetPageOrigRef(int pageNum);
    public virtual Byte[] GetPageContent(int pageNum, RandomAccessFileOrArray file);
    public static Byte[] GetPageContent(PdfDictionary page);
    public virtual PdfDictionary GetPageResources(int pageNum);
    public virtual PdfDictionary GetPageResources(PdfDictionary pageDict);
    public virtual Byte[] GetPageContent(int pageNum);
    protected internal virtual void KillXref(PdfObject obj);
    public virtual void SetPageContent(int pageNum, Byte[] content);
    public virtual void SetPageContent(int pageNum, Byte[] content, int compressionLevel, bool killOldXRefRecursively);
    public static Byte[] DecodeBytes(Byte[] b, PdfDictionary streamDictionary);
    public static Byte[] DecodeBytes(Byte[] b, PdfDictionary streamDictionary, IDictionary`2<PdfName, IFilterHandler> filterHandlers);
    public static Byte[] GetStreamBytes(PRStream stream, RandomAccessFileOrArray file);
    public static Byte[] GetStreamBytes(PRStream stream);
    public static Byte[] GetStreamBytesRaw(PRStream stream, RandomAccessFileOrArray file);
    public static Byte[] GetStreamBytesRaw(PRStream stream);
    public virtual void EliminateSharedStreams();
    public virtual bool get_Tampered();
    public virtual void set_Tampered(bool value);
    public virtual Byte[] get_Metadata();
    public virtual long get_LastXref();
    public virtual int get_XrefSize();
    public virtual long get_EofPos();
    public virtual char get_PdfVersion();
    public virtual bool IsEncrypted();
    public virtual long get_Permissions();
    public virtual bool Is128Key();
    public virtual PdfDictionary get_Trailer();
    internal PdfEncryption get_Decrypt();
    internal static bool Equalsn(Byte[] a1, Byte[] a2);
    internal static bool ExistsName(PdfDictionary dic, PdfName key, PdfName value);
    internal static string GetFontName(PdfDictionary dic);
    internal static string GetSubsetPrefix(PdfDictionary dic);
    public virtual int ShuffleSubsetNames();
    public virtual int CreateFakeFontSubsets();
    private static PdfArray GetNameArray(PdfObject obj);
    public virtual Dictionary`2<object, PdfObject> GetNamedDestination();
    public virtual Dictionary`2<object, PdfObject> GetNamedDestination(bool keepNames);
    public virtual Dictionary`2<string, PdfObject> GetNamedDestinationFromNames();
    public virtual Dictionary`2<object, PdfObject> GetNamedDestinationFromNames(bool keepNames);
    public virtual Dictionary`2<string, PdfObject> GetNamedDestinationFromStrings();
    public virtual void RemoveFields();
    public virtual void RemoveAnnotations();
    public virtual List`1<PdfImportedLink> GetLinks(int page);
    private void IterateBookmarks(PdfObject outlineRef, Dictionary`2<object, PdfObject> names);
    public virtual void MakeRemoteNamedDestinationsLocal();
    private bool ConvertNamedDestination(PdfObject obj, Dictionary`2<object, PdfObject> names);
    public virtual void ConsolidateNamedDestinations();
    private bool ReplaceNamedDestination(PdfObject obj, Dictionary`2<object, PdfObject> names);
    protected internal static PdfDictionary DuplicatePdfDictionary(PdfDictionary original, PdfDictionary copy, PdfReader newReader);
    protected internal static PdfObject DuplicatePdfObject(PdfObject original, PdfReader newReader);
    public virtual void Close();
    protected internal virtual void RemoveUnusedNode(PdfObject obj, Boolean[] hits);
    public virtual int RemoveUnusedObjects();
    public virtual AcroFields get_AcroFields();
    public virtual string GetJavaScript(RandomAccessFileOrArray file);
    public virtual string get_JavaScript();
    public virtual void SelectPages(string ranges);
    public virtual void SelectPages(ICollection`1<int> pagesToKeep);
    internal void SelectPages(ICollection`1<int> pagesToKeep, bool removeUnused);
    public virtual void set_ViewerPreferences(int value);
    public virtual void AddViewerPreference(PdfName key, PdfObject value);
    public virtual void SetViewerPreferences(PdfViewerPreferencesImp vp);
    public virtual int get_SimpleViewerPreferences();
    public virtual void set_Appendable(bool value);
    public virtual bool get_Appendable();
    public virtual bool IsNewXrefType();
    public virtual long get_FileLength();
    public virtual bool IsHybridXref();
    internal PdfIndirectReference GetCryptoRef();
    public virtual bool HasUsageRights();
    public virtual void RemoveUsageRights();
    public virtual int GetCertificationLevel();
    public bool get_IsOpenedWithFullPermissions();
    public virtual int GetCryptoMode();
    public virtual bool IsMetadataEncrypted();
    public virtual Byte[] ComputeUserPassword();
    public virtual void Dispose();
}
public class iTextSharp.text.pdf.PdfReaderInstance : object {
    internal static PdfLiteral IDENTITYMATRIX;
    internal static PdfNumber ONE;
    internal Int32[] myXref;
    internal PdfReader reader;
    internal RandomAccessFileOrArray file;
    internal Dictionary`2<int, PdfImportedPage> importedPages;
    internal PdfWriter writer;
    internal Dictionary`2<int, object> visited;
    internal List`1<int> nextRound;
    internal PdfReader Reader { get; }
    internal RandomAccessFileOrArray ReaderFile { get; }
    internal PdfReaderInstance(PdfReader reader, PdfWriter writer);
    private static PdfReaderInstance();
    internal PdfReader get_Reader();
    internal PdfImportedPage GetImportedPage(int pageNumber);
    internal int GetNewObjectNumber(int number, int generation);
    internal RandomAccessFileOrArray get_ReaderFile();
    internal PdfObject GetResources(int pageNumber);
    internal PdfStream GetFormXObject(int pageNumber, int compressionLevel);
    internal void WriteAllVisited();
    public virtual void WriteAllPages();
}
public class iTextSharp.text.pdf.PdfRectangle : NumberArray {
    private float llx;
    private float lly;
    private float urx;
    private float ury;
    public Rectangle Rectangle { get; }
    public float Left { get; }
    public float Right { get; }
    public float Top { get; }
    public float Bottom { get; }
    public float Width { get; }
    public float Height { get; }
    public PdfRectangle Rotate { get; }
    public PdfRectangle(float llx, float lly, float urx, float ury, int rotation);
    public PdfRectangle(float llx, float lly, float urx, float ury);
    public PdfRectangle(float urx, float ury, int rotation);
    public PdfRectangle(float urx, float ury);
    public PdfRectangle(Rectangle rectangle, int rotation);
    public PdfRectangle(Rectangle rectangle);
    public virtual Rectangle get_Rectangle();
    public virtual bool Add(PdfObject obj);
    public virtual bool Add(Single[] values);
    public virtual bool Add(Int32[] values);
    public virtual void AddFirst(PdfObject obj);
    public virtual float get_Left();
    public virtual float get_Right();
    public virtual float get_Top();
    public virtual float get_Bottom();
    public virtual float GetLeft(int margin);
    public virtual float GetRight(int margin);
    public virtual float GetTop(int margin);
    public virtual float GetBottom(int margin);
    public virtual float get_Width();
    public virtual float get_Height();
    public virtual PdfRectangle get_Rotate();
    [ObsoleteAttribute]
public PdfRectangle Transform(Matrix transform);
    public virtual PdfRectangle Transform(AffineTransform transform);
}
public class iTextSharp.text.pdf.PdfRendition : PdfDictionary {
    public PdfRendition(string file, PdfFileSpecification fs, string mimeType);
}
internal class iTextSharp.text.pdf.PdfResources : PdfDictionary {
    internal void Add(PdfName key, PdfDictionary resource);
}
public class iTextSharp.text.pdf.PdfShading : object {
    protected PdfDictionary shading;
    protected PdfWriter writer;
    protected int shadingType;
    protected ColorDetails colorDetails;
    protected PdfName shadingName;
    protected PdfIndirectReference shadingReference;
    protected Single[] bBox;
    protected bool antiAlias;
    private BaseColor cspace;
    public BaseColor ColorSpace { get; }
    internal PdfName ShadingName { get; }
    internal PdfIndirectReference ShadingReference { get; }
    unknown int Name {internal set; }
    internal PdfWriter Writer { get; }
    internal ColorDetails ColorDetails { get; }
    public Single[] BBox { get; public set; }
    public bool AntiAlias { get; public set; }
    protected PdfShading(PdfWriter writer);
    protected virtual void SetColorSpace(BaseColor color);
    public virtual BaseColor get_ColorSpace();
    public static void ThrowColorSpaceError();
    public static void CheckCompatibleColors(BaseColor c1, BaseColor c2);
    public static Single[] GetColorArray(BaseColor color);
    public static PdfShading Type1(PdfWriter writer, BaseColor colorSpace, Single[] domain, Single[] tMatrix, PdfFunction function);
    public static PdfShading Type2(PdfWriter writer, BaseColor colorSpace, Single[] coords, Single[] domain, PdfFunction function, Boolean[] extend);
    public static PdfShading Type3(PdfWriter writer, BaseColor colorSpace, Single[] coords, Single[] domain, PdfFunction function, Boolean[] extend);
    public static PdfShading SimpleAxial(PdfWriter writer, float x0, float y0, float x1, float y1, BaseColor startColor, BaseColor endColor, bool extendStart, bool extendEnd);
    public static PdfShading SimpleAxial(PdfWriter writer, float x0, float y0, float x1, float y1, BaseColor startColor, BaseColor endColor);
    public static PdfShading SimpleRadial(PdfWriter writer, float x0, float y0, float r0, float x1, float y1, float r1, BaseColor startColor, BaseColor endColor, bool extendStart, bool extendEnd);
    public static PdfShading SimpleRadial(PdfWriter writer, float x0, float y0, float r0, float x1, float y1, float r1, BaseColor startColor, BaseColor endColor);
    internal PdfName get_ShadingName();
    internal PdfIndirectReference get_ShadingReference();
    internal void set_Name(int value);
    public virtual void AddToBody();
    internal PdfWriter get_Writer();
    internal ColorDetails get_ColorDetails();
    public virtual Single[] get_BBox();
    public virtual void set_BBox(Single[] value);
    public virtual void set_AntiAlias(bool value);
    public virtual bool get_AntiAlias();
}
public class iTextSharp.text.pdf.PdfShadingPattern : PdfDictionary {
    protected PdfShading shading;
    protected PdfWriter writer;
    protected Single[] matrix;
    protected PdfName patternName;
    protected PdfIndirectReference patternReference;
    internal PdfName PatternName { get; }
    internal PdfName ShadingName { get; }
    internal PdfIndirectReference PatternReference { get; }
    internal PdfIndirectReference ShadingReference { get; }
    unknown int Name {internal set; }
    public Single[] Matrix { get; public set; }
    public PdfShading Shading { get; }
    internal ColorDetails ColorDetails { get; }
    public PdfShadingPattern(PdfShading shading);
    internal PdfName get_PatternName();
    internal PdfName get_ShadingName();
    internal PdfIndirectReference get_PatternReference();
    internal PdfIndirectReference get_ShadingReference();
    internal void set_Name(int value);
    public virtual void AddToBody();
    public virtual Single[] get_Matrix();
    public virtual void set_Matrix(Single[] value);
    public virtual PdfShading get_Shading();
    internal ColorDetails get_ColorDetails();
}
public class iTextSharp.text.pdf.PdfSigLockDictionary : PdfDictionary {
    public PdfSigLockDictionary(LockPermissions p);
    public PdfSigLockDictionary(LockAction action, String[] fields);
    public PdfSigLockDictionary(LockAction action, LockPermissions p, String[] fields);
}
public class iTextSharp.text.pdf.PdfSignature : PdfDictionary {
    unknown Int32[] ByteRange {public set; }
    unknown Byte[] Contents {public set; }
    unknown Byte[] Cert {public set; }
    unknown string Name {public set; }
    unknown PdfDate Date {public set; }
    unknown string Location {public set; }
    unknown string Reason {public set; }
    unknown string SignatureCreator {public set; }
    private PdfSignatureBuildProperties PdfSignatureBuildProperties { get; }
    unknown string Contact {public set; }
    public PdfSignature(PdfName filter, PdfName subFilter);
    public virtual void set_ByteRange(Int32[] value);
    public virtual void set_Contents(Byte[] value);
    public virtual void set_Cert(Byte[] value);
    public virtual void set_Name(string value);
    public virtual void set_Date(PdfDate value);
    public virtual void set_Location(string value);
    public virtual void set_Reason(string value);
    public virtual void set_SignatureCreator(string value);
    private PdfSignatureBuildProperties get_PdfSignatureBuildProperties();
    public virtual void set_Contact(string value);
}
public class iTextSharp.text.pdf.PdfSignatureAppearance : object {
    public static int NOT_CERTIFIED;
    public static int CERTIFIED_NO_CHANGES_ALLOWED;
    public static int CERTIFIED_FORM_FILLING;
    public static int CERTIFIED_FORM_FILLING_AND_ANNOTATIONS;
    public static string questionMark;
    private static float TOP_SECTION;
    private static float MARGIN;
    private int certificationLevel;
    private string reasonCaption;
    private string locationCaption;
    private string reason;
    private string location;
    private DateTime signDate;
    private string signatureCreator;
    private string contact;
    private FileStream raf;
    private Byte[] bout;
    private Int64[] range;
    private X509Certificate signCertificate;
    private PdfDictionary cryptoDictionary;
    private ISignatureEvent signatureEvent;
    private string fieldName;
    private int page;
    private Rectangle rect;
    private Rectangle pageRect;
    private RenderingMode renderingMode;
    private Image signatureGraphic;
    private bool acro6Layers;
    private PdfTemplate[] app;
    private bool reuseAppearance;
    private Image image;
    private float imageScale;
    private string layer2Text;
    private Font layer2Font;
    private int runDirection;
    private string layer4Text;
    private PdfTemplate frm;
    private PdfStamper stamper;
    private PdfStamperImp writer;
    private ByteBuffer sigout;
    private Stream originalout;
    private string tempFile;
    private Dictionary`2<PdfName, PdfLiteral> exclusionLocations;
    private int boutLen;
    private bool preClosed;
    private PdfSigLockDictionary fieldLock;
    public int CertificationLevel { get; public set; }
    public string Reason { get; public set; }
    unknown string ReasonCaption {public set; }
    public string Location { get; public set; }
    unknown string LocationCaption {public set; }
    public string SignatureCreator { get; public set; }
    public string Contact { get; public set; }
    public DateTime SignDate { get; public set; }
    public PdfDictionary CryptoDictionary { get; public set; }
    public X509Certificate Certificate { get; public set; }
    public ISignatureEvent SignatureEvent { get; public set; }
    public string FieldName { get; }
    public int Page { get; }
    public Rectangle Rect { get; }
    public Rectangle PageRect { get; }
    public RenderingMode SignatureRenderingMode { get; public set; }
    public Image SignatureGraphic { get; public set; }
    public bool Acro6Layers { get; public set; }
    unknown bool ReuseAppearance {public set; }
    public Image Image { get; public set; }
    public float ImageScale { get; public set; }
    public string Layer2Text { get; public set; }
    public Font Layer2Font { get; public set; }
    public int RunDirection { get; public set; }
    public string Layer4Text { get; public set; }
    public PdfStamper Stamper { get; }
    public ByteBuffer Sigout { get; public set; }
    public Stream Originalout { get; public set; }
    public string TempFile { get; }
    public PdfSigLockDictionary FieldLockDict { get; public set; }
    public PdfSignatureAppearance(PdfStamperImp writer);
    public virtual int get_CertificationLevel();
    public virtual void set_CertificationLevel(int value);
    public virtual string get_Reason();
    public virtual void set_Reason(string value);
    public virtual void set_ReasonCaption(string value);
    public virtual string get_Location();
    public virtual void set_Location(string value);
    public virtual void set_LocationCaption(string value);
    public virtual string get_SignatureCreator();
    public virtual void set_SignatureCreator(string value);
    public virtual string get_Contact();
    public virtual void set_Contact(string value);
    public virtual DateTime get_SignDate();
    public virtual void set_SignDate(DateTime value);
    public virtual Stream GetRangeStream();
    private IRandomAccessSource GetUnderlyingSource();
    public virtual void AddDeveloperExtension(PdfDeveloperExtension de);
    public virtual PdfDictionary get_CryptoDictionary();
    public virtual void set_CryptoDictionary(PdfDictionary value);
    public virtual X509Certificate get_Certificate();
    public virtual void set_Certificate(X509Certificate value);
    public virtual ISignatureEvent get_SignatureEvent();
    public virtual void set_SignatureEvent(ISignatureEvent value);
    public virtual string get_FieldName();
    public virtual string GetNewSigName();
    public virtual int get_Page();
    public virtual Rectangle get_Rect();
    public virtual Rectangle get_PageRect();
    public virtual bool IsInvisible();
    public virtual void SetVisibleSignature(Rectangle pageRect, int page, string fieldName);
    public virtual void SetVisibleSignature(string fieldName);
    public virtual RenderingMode get_SignatureRenderingMode();
    public virtual void set_SignatureRenderingMode(RenderingMode value);
    public virtual Image get_SignatureGraphic();
    public virtual void set_SignatureGraphic(Image value);
    public virtual bool get_Acro6Layers();
    public virtual void set_Acro6Layers(bool value);
    public virtual PdfTemplate GetLayer(int layer);
    public virtual void set_ReuseAppearance(bool value);
    public virtual Image get_Image();
    public virtual void set_Image(Image value);
    public virtual float get_ImageScale();
    public virtual void set_ImageScale(float value);
    public virtual string get_Layer2Text();
    public virtual void set_Layer2Text(string value);
    public virtual Font get_Layer2Font();
    public virtual void set_Layer2Font(Font value);
    public virtual void set_RunDirection(int value);
    public virtual int get_RunDirection();
    public virtual string get_Layer4Text();
    public virtual void set_Layer4Text(string value);
    public virtual PdfTemplate GetTopLayer();
    public virtual PdfTemplate GetAppearance();
    private void CreateBlankN0();
    public virtual PdfStamper get_Stamper();
    public virtual void SetStamper(PdfStamper stamper);
    public virtual ByteBuffer get_Sigout();
    public virtual void set_Sigout(ByteBuffer value);
    public virtual Stream get_Originalout();
    public virtual void set_Originalout(Stream value);
    public virtual string get_TempFile();
    public virtual void SetTempFile(string tempFile);
    public virtual PdfSigLockDictionary get_FieldLockDict();
    public virtual void set_FieldLockDict(PdfSigLockDictionary value);
    public virtual bool IsPreClosed();
    public virtual void PreClose(Dictionary`2<PdfName, int> exclusionSizes);
    private void AddDocMDP(PdfDictionary crypto);
    private void AddFieldMDP(PdfDictionary crypto, PdfDictionary fieldLock);
    public virtual void Close(PdfDictionary update);
}
public class iTextSharp.text.pdf.PdfSmartCopy : PdfCopy {
    private static ILogger LOGGER;
    private Dictionary`2<ByteStore, PdfIndirectReference> streamMap;
    private Dictionary`2<RefKey, int> serialized;
    protected ICounter COUNTER;
    public PdfSmartCopy(Document document, Stream os);
    private static PdfSmartCopy();
    protected virtual ICounter GetCounter();
    protected virtual PdfIndirectReference CopyIndirect(PRIndirectReference inp);
    public virtual void FreeReader(PdfReader reader);
    public virtual void AddPage(PdfImportedPage iPage);
}
public class iTextSharp.text.pdf.PdfSpotColor : object {
    public PdfName name;
    public BaseColor altcs;
    public ColorDetails altColorDetails;
    public BaseColor AlternativeCS { get; }
    public PdfName Name { get; }
    public PdfSpotColor(string name, BaseColor altcs);
    public virtual ColorDetails[] GetColorantDetails(PdfWriter writer);
    public virtual BaseColor get_AlternativeCS();
    public virtual PdfName get_Name();
    [ObsoleteAttribute]
protected internal virtual PdfObject GetSpotObject(PdfWriter writer);
    public virtual PdfObject GetPdfObject(PdfWriter writer);
    public virtual bool Equals(object o);
    public virtual int GetHashCode();
}
public class iTextSharp.text.pdf.PdfStamper : object {
    protected PdfStamperImp stamper;
    private IDictionary`2<string, string> moreInfo;
    protected internal bool hasSignature;
    protected PdfSignatureAppearance sigApp;
    protected XmlSignatureAppearance sigXmlApp;
    private LtvVerification verification;
    public IDictionary`2<string, string> MoreInfo { get; public set; }
    public PdfSignatureAppearance SignatureAppearance { get; }
    public XmlSignatureAppearance XmlSignatureAppearance { get; }
    public bool RotateContents { get; public set; }
    public PdfWriter Writer { get; }
    public PdfReader Reader { get; }
    public AcroFields AcroFields { get; }
    unknown bool FormFlattening {public set; }
    unknown bool FreeTextFlattening {public set; }
    unknown bool AnnotationFlattening {public set; }
    unknown IList`1<Dictionary`2<string, object>> Outlines {public set; }
    unknown string JavaScript {public set; }
    unknown int ViewerPreferences {public set; }
    unknown Byte[] XmpMetadata {public set; }
    public XmpWriter XmpWriter { get; }
    public bool FullCompression { get; }
    public LtvVerification LtvVerification { get; }
    public PdfStamper(PdfReader reader, Stream os);
    public PdfStamper(PdfReader reader, Stream os, char pdfVersion);
    public PdfStamper(PdfReader reader, Stream os, char pdfVersion, bool append);
    public virtual void set_MoreInfo(IDictionary`2<string, string> value);
    public virtual IDictionary`2<string, string> get_MoreInfo();
    public virtual void ReplacePage(PdfReader r, int pageImported, int pageReplaced);
    public virtual void InsertPage(int pageNumber, Rectangle mediabox);
    public virtual PdfSignatureAppearance get_SignatureAppearance();
    public virtual XmlSignatureAppearance get_XmlSignatureAppearance();
    public virtual void Close();
    public virtual PdfContentByte GetUnderContent(int pageNum);
    public virtual PdfContentByte GetOverContent(int pageNum);
    public virtual void set_RotateContents(bool value);
    public virtual bool get_RotateContents();
    public virtual void SetEncryption(Byte[] userPassword, Byte[] ownerPassword, int permissions, bool strength128Bits);
    public virtual void SetEncryption(Byte[] userPassword, Byte[] ownerPassword, int permissions, int encryptionType);
    public virtual void SetEncryption(bool strength, string userPassword, string ownerPassword, int permissions);
    public virtual void SetEncryption(int encryptionType, string userPassword, string ownerPassword, int permissions);
    public virtual void SetEncryption(X509Certificate[] certs, Int32[] permissions, int encryptionType);
    public virtual PdfImportedPage GetImportedPage(PdfReader reader, int pageNumber);
    public virtual PdfWriter get_Writer();
    public virtual PdfReader get_Reader();
    public virtual AcroFields get_AcroFields();
    public virtual void set_FormFlattening(bool value);
    public virtual void set_FreeTextFlattening(bool value);
    public virtual void set_AnnotationFlattening(bool value);
    public virtual void AddAnnotation(PdfAnnotation annot, int page);
    public virtual PdfFormField AddSignature(string name, int page, float llx, float lly, float urx, float ury);
    public virtual void AddComments(FdfReader fdf);
    public virtual void set_Outlines(IList`1<Dictionary`2<string, object>> value);
    public virtual void SetThumbnail(Image image, int page);
    public virtual bool PartialFormFlattening(string name);
    public virtual void set_JavaScript(string value);
    public virtual void AddJavaScript(string name, string js);
    public virtual void AddFileAttachment(string description, Byte[] fileStore, string file, string fileDisplay);
    public virtual void AddFileAttachment(string description, PdfFileSpecification fs);
    public virtual void MakePackage(PdfName initialView);
    public virtual void MakePackage(PdfCollection collection);
    public virtual void set_ViewerPreferences(int value);
    public virtual void AddViewerPreference(PdfName key, PdfObject value);
    public virtual void set_XmpMetadata(Byte[] value);
    public virtual void CreateXmpMetadata();
    public virtual XmpWriter get_XmpWriter();
    public virtual bool get_FullCompression();
    public virtual void SetFullCompression();
    public virtual void SetPageAction(PdfName actionType, PdfAction action, int page);
    public virtual void SetDuration(int seconds, int page);
    public virtual void SetTransition(PdfTransition transition, int page);
    public static PdfStamper CreateSignature(PdfReader reader, Stream os, char pdfVersion, string tempFile, bool append);
    public static PdfStamper CreateSignature(PdfReader reader, Stream os, char pdfVersion);
    public static PdfStamper CreateSignature(PdfReader reader, Stream os, char pdfVersion, string tempFile);
    public static PdfStamper createXmlSignature(PdfReader reader, Stream os);
    public virtual Dictionary`2<string, PdfLayer> GetPdfLayers();
    public virtual void Dispose();
    public virtual void MarkUsed(PdfObject obj);
    public virtual LtvVerification get_LtvVerification();
    internal void MergeVerification();
}
public class iTextSharp.text.pdf.PdfStamperImp : PdfWriter {
    internal Dictionary`2<PdfReader, IntHashtable> readers2intrefs;
    internal Dictionary`2<PdfReader, RandomAccessFileOrArray> readers2file;
    protected internal RandomAccessFileOrArray file;
    protected internal PdfReader reader;
    internal IntHashtable myXref;
    internal Dictionary`2<PdfDictionary, PageStamp> pagesToContent;
    protected internal bool closed;
    private bool rotateContents;
    protected AcroFields acroFields;
    protected bool flat;
    protected bool flatFreeText;
    protected bool flatannotations;
    protected Int32[] namePtr;
    protected HashSet2`1<string> partialFlattening;
    protected bool useVp;
    protected PdfViewerPreferencesImp viewerPreferences;
    protected HashSet2`1<PdfTemplate> fieldTemplates;
    protected bool fieldsAdded;
    protected int sigFlags;
    protected internal bool append;
    protected IntHashtable marked;
    protected int initialXrefSize;
    protected PdfAction openAction;
    private Dictionary`2<string, PdfIndirectReference> builtInAnnotationFonts;
    private static Dictionary`2<string, string> fromShortToFullAnnotationFontNames;
    private Double[] DEFAULT_MATRIX;
    protected ICounter COUNTER;
    private ILogger logger;
    private bool originalLayersAreRead;
    internal bool RotateContents { get; internal set; }
    internal bool ContentWritten { get; }
    unknown bool FormFlattening {internal set; }
    unknown bool FreeTextFlattening {internal set; }
    unknown bool FlatAnnotations {public set; }
    unknown int ViewerPreferences {public set; }
    unknown int SigFlags {public set; }
    unknown int Duration {public set; }
    unknown PdfTransition Transition {public set; }
    unknown Image Thumbnail {public set; }
    public PdfContentByte DirectContent { get; }
    public PdfContentByte DirectContentUnder { get; }
    private static PdfStamperImp();
    protected internal PdfStamperImp(PdfReader reader, Stream os, char pdfVersion, bool append);
    protected virtual ICounter GetCounter();
    protected virtual void ReadColorProfile();
    protected virtual void SetViewerPreferences();
    protected internal virtual void Close(IDictionary`2<string, string> moreInfo);
    protected virtual void Close(PdfIndirectReference info, int skipInfo);
    internal void ApplyRotation(PdfDictionary pageN, ByteBuffer out_p);
    protected internal virtual void AlterContents();
    internal void AlterResources(PageStamp ps);
    protected internal virtual int GetNewObjectNumber(PdfReader reader, int number, int generation);
    internal virtual RandomAccessFileOrArray GetReaderFile(PdfReader reader);
    public virtual void RegisterReader(PdfReader reader, bool openFile);
    public virtual void UnRegisterReader(PdfReader reader);
    internal static void FindAllObjects(PdfReader reader, PdfObject obj, IntHashtable hits);
    public virtual void AddComments(FdfReader fdf);
    internal PageStamp GetPageStamp(int pageNum);
    internal PdfContentByte GetUnderContent(int pageNum);
    internal PdfContentByte GetOverContent(int pageNum);
    internal void CorrectAcroFieldPages(int page);
    private static void MoveRectangle(PdfDictionary dic2, PdfReader r, int pageImported, PdfName key, string name);
    internal void ReplacePage(PdfReader r, int pageImported, int pageReplaced);
    internal void InsertPage(int pageNumber, Rectangle mediabox);
    internal void set_RotateContents(bool value);
    internal bool get_RotateContents();
    internal bool get_ContentWritten();
    internal AcroFields GetAcroFields();
    internal void set_FormFlattening(bool value);
    internal void set_FreeTextFlattening(bool value);
    internal bool PartialFormFlattening(string name);
    protected internal virtual void FlatFields();
    internal void EliminateAcroformObjects();
    internal AffineTransform CalculateTemplateTransformationMatrix(AffineTransform currentMatrix, double fieldRotation, Rectangle box);
    internal void SweepKids(PdfObject obj);
    public virtual void set_FlatAnnotations(bool value);
    protected internal virtual void FlattenAnnotations();
    private void FlattenAnnotations(bool flattenFreeTextAnnotations);
    private Rectangle TransformBBoxByMatrix(Rectangle bBox, Double[] matrix);
    private Point TransformPoint(double x, double y, Double[] matrix);
    protected internal virtual void FlatFreeTextFields();
    public virtual PdfIndirectReference GetPageReference(int page);
    public virtual void AddAnnotation(PdfAnnotation annot);
    internal void AddDocumentField(PdfIndirectReference ref_p);
    protected internal virtual void AddFieldResources();
    internal void ExpandFields(PdfFormField field, List`1<PdfAnnotation> allAnnots);
    internal void AddAnnotation(PdfAnnotation annot, PdfDictionary pageN);
    internal virtual void AddAnnotation(PdfAnnotation annot, int page);
    private void OutlineTravel(PRIndirectReference outline);
    internal void DeleteOutlines();
    protected internal virtual void SetJavaScript();
    protected virtual void AddFileAttachments();
    internal void MakePackage(PdfCollection collection);
    protected internal virtual void SetOutlines();
    public virtual void set_ViewerPreferences(int value);
    public virtual void AddViewerPreference(PdfName key, PdfObject value);
    public virtual void set_SigFlags(int value);
    public virtual void SetPageAction(PdfName actionType, PdfAction action);
    internal void SetPageAction(PdfName actionType, PdfAction action, int page);
    public virtual void set_Duration(int value);
    public virtual void set_Transition(PdfTransition value);
    internal void SetDuration(int seconds, int page);
    internal void SetTransition(PdfTransition transition, int page);
    public virtual void MarkUsed(PdfObject obj);
    protected internal virtual void MarkUsed(int num);
    internal bool IsAppend();
    public virtual void SetAdditionalAction(PdfName actionType, PdfAction action);
    public virtual void SetOpenAction(PdfAction action);
    public virtual void SetOpenAction(string name);
    public virtual void set_Thumbnail(Image value);
    internal void SetThumbnail(Image image, int page);
    protected virtual void ReadOCProperties();
    private void AddOrder(PdfLayer parent, PdfArray arr, Dictionary`2<string, PdfLayer> ocgmap);
    public virtual Dictionary`2<string, PdfLayer> GetPdfLayers();
    internal virtual void RegisterLayer(IPdfOCG layer);
    public virtual void CreateXmpMetadata();
    public virtual PdfContentByte get_DirectContent();
    public virtual PdfContentByte get_DirectContentUnder();
    public PdfReader GetPdfReader();
}
public class iTextSharp.text.pdf.PdfStream : PdfDictionary {
    public static int DEFAULT_COMPRESSION;
    public static int NO_COMPRESSION;
    public static int BEST_SPEED;
    public static int BEST_COMPRESSION;
    protected bool compressed;
    protected int compressionLevel;
    protected MemoryStream streamBytes;
    protected Stream inputStream;
    protected PdfIndirectReference iref;
    protected int inputStreamLength;
    protected PdfWriter writer;
    protected int rawLength;
    internal static Byte[] STARTSTREAM;
    internal static Byte[] ENDSTREAM;
    internal static int SIZESTREAM;
    public int RawLength { get; }
    public PdfStream(Byte[] bytes);
    public PdfStream(Stream inputStream, PdfWriter writer);
    private static PdfStream();
    public virtual void WriteLength();
    public virtual int get_RawLength();
    public virtual void FlateCompress();
    public virtual void FlateCompress(int compressionLevel);
    protected virtual void SuperToPdf(PdfWriter writer, Stream os);
    public virtual void ToPdf(PdfWriter writer, Stream os);
    public virtual void WriteContent(Stream os);
    public virtual string ToString();
}
public class iTextSharp.text.pdf.PdfString : PdfObject {
    protected string value;
    protected string originalValue;
    protected string encoding;
    protected int objNum;
    protected int objGen;
    protected bool hexWriting;
    public string Encoding { get; }
    public PdfString(string value);
    public PdfString(string value, string encoding);
    public PdfString(Byte[] bytes);
    public virtual void ToPdf(PdfWriter writer, Stream os);
    public virtual string ToString();
    public virtual string get_Encoding();
    public virtual string ToUnicodeString();
    internal void SetObjNum(int objNum, int objGen);
    internal void Decrypt(PdfReader reader);
    public virtual Byte[] GetBytes();
    public virtual Byte[] GetOriginalBytes();
    public virtual PdfString SetHexWriting(bool hexWriting);
    public virtual bool IsHexWriting();
}
public class iTextSharp.text.pdf.PdfStructTreeController : object {
    private PdfDictionary structTreeRoot;
    private PdfCopy writer;
    private PdfStructureTreeRoot structureTreeRoot;
    private PdfDictionary parentTree;
    protected internal PdfReader reader;
    private PdfDictionary roleMap;
    private PdfDictionary sourceRoleMap;
    private PdfDictionary sourceClassMap;
    private PdfIndirectReference nullReference;
    protected internal PdfStructTreeController(PdfReader reader, PdfCopy writer);
    protected internal virtual void SetReader(PdfReader reader);
    public static bool CheckTagged(PdfReader reader);
    public static PdfObject GetDirectObject(PdfObject obj);
    public virtual void CopyStructTreeForPage(PdfNumber sourceArrayNumber, int newArrayNumber);
    private ReturnType CopyPageMarks(PdfDictionary parentTree, PdfNumber arrayNumber, int newArrayNumber);
    private ReturnType FindAndCopyMarks(PdfArray pages, int arrayNumber, int newArrayNumber);
    protected internal virtual void AttachStructTreeRootKids(PdfObject firstNotNullKid);
    internal static PdfDictionary GetKDict(PdfDictionary obj);
    private void AddKid(PdfObject obj);
    private static PdfArray GetDirectArray(PdfArray input);
    private static PdfDictionary GetDirectDict(PdfDictionary input);
    public static bool CompareObjects(PdfObject value1, PdfObject value2);
    internal void AddClass(PdfObject obj);
    internal void AddRole(PdfName structType);
    protected virtual void AddKid(PdfDictionary parent, PdfObject kid);
}
public class iTextSharp.text.pdf.PdfStructureElement : PdfDictionary {
    private PdfStructureElement parent;
    private PdfStructureTreeRoot top;
    private PdfIndirectReference reference;
    private PdfName structureType;
    public PdfName StructureType { get; }
    public PdfDictionary Parent { get; }
    public PdfIndirectReference Reference { get; }
    public PdfStructureElement(PdfStructureElement parent, PdfName structureType);
    public PdfStructureElement(PdfStructureTreeRoot root, PdfName structureType);
    internal PdfStructureElement(PdfDictionary parent, PdfName structureType);
    public virtual PdfName get_StructureType();
    private void Init(PdfDictionary parent, PdfName structureType);
    public virtual PdfDictionary get_Parent();
    public virtual PdfDictionary GetParent(bool includeStructTreeRoot);
    internal virtual void SetPageMark(int page, int mark);
    internal virtual void SetAnnotation(PdfAnnotation annot, PdfIndirectReference currentPage);
    public virtual PdfIndirectReference get_Reference();
    public virtual PdfObject GetAttribute(PdfName name);
    public virtual void SetAttribute(PdfName name, PdfObject obj);
    public virtual void WriteAttributes(IAccessibleElement element);
    private void WriteAttributes(Chunk chunk);
    private void WriteAttributes(Image image);
    private void WriteAttributes(PdfTemplate template);
    private void WriteAttributes(Paragraph paragraph);
    private void WriteAttributes(List list);
    private void WriteAttributes(ListItem listItem);
    private void WriteAttributes(ListBody listBody);
    private void WriteAttributes(ListLabel listLabel);
    private void WriteAttributes(PdfPTable table);
    private void WriteAttributes(PdfPRow row);
    private void WriteAttributes(PdfPCell cell);
    private void WriteAttributes(PdfPHeaderCell headerCell);
    private void WriteAttributes(PdfPTableHeader header);
    private void WriteAttributes(PdfPTableBody body);
    private void WriteAttributes(PdfPTableFooter footer);
    private void WriteAttributes(PdfDiv div);
    private void WriteAttributes(Document document);
    private bool ColorsEqual(PdfArray parentColor, Single[] color);
    private void SetColorAttribute(BaseColor newColor, PdfObject oldColor, PdfName attributeName);
    private void SetTextAlignAttribute(int elementAlign);
    public virtual void ToPdf(PdfWriter writer, Stream os);
    private PdfObject GetParentAttribute(IPdfStructureElement parent, PdfName name);
}
public class iTextSharp.text.pdf.PdfStructureTreeRoot : PdfDictionary {
    private Dictionary`2<int, PdfObject> parentTree;
    private PdfIndirectReference reference;
    private PdfDictionary classMap;
    internal Dictionary`2<PdfName, PdfObject> classes;
    private Dictionary`2<int, PdfIndirectReference> numTree;
    private Dictionary`2<string, PdfObject> idTreeMap;
    private PdfWriter writer;
    public PdfWriter Writer { get; }
    public Dictionary`2<int, PdfIndirectReference> NumTree { get; }
    public PdfIndirectReference Reference { get; }
    internal PdfStructureTreeRoot(PdfWriter writer);
    private void CreateNumTree();
    public virtual void MapRole(PdfName used, PdfName standard);
    public virtual void MapClass(PdfName name, PdfObject obj);
    internal virtual void PutIDTree(string record, PdfObject reference);
    public virtual PdfObject GetMappedClass(PdfName name);
    public virtual PdfWriter get_Writer();
    public virtual Dictionary`2<int, PdfIndirectReference> get_NumTree();
    public virtual PdfIndirectReference get_Reference();
    internal void SetPageMark(int page, PdfIndirectReference struc);
    internal void SetAnnotationMark(int structParentIndex, PdfIndirectReference struc);
    private void NodeProcess(PdfDictionary struc, PdfIndirectReference reference);
    internal void BuildTree();
    public virtual PdfObject GetAttribute(PdfName name);
    public virtual void SetAttribute(PdfName name, PdfObject obj);
}
public class iTextSharp.text.pdf.PdfTemplate : PdfContentByte {
    public static int TYPE_TEMPLATE;
    public static int TYPE_IMPORTED;
    public static int TYPE_PATTERN;
    protected int type;
    protected PdfIndirectReference thisReference;
    protected PageResources pageResources;
    protected Rectangle bBox;
    protected PdfArray matrix;
    protected PdfTransparencyGroup group;
    protected IPdfOCG layer;
    protected PdfIndirectReference pageReference;
    protected bool contentTagged;
    private PdfDictionary additional;
    protected PdfName role;
    protected Dictionary`2<PdfName, PdfObject> accessibleAttributes;
    private AccessibleElementId id;
    public float Width { get; public set; }
    public float Height { get; public set; }
    public Rectangle BoundingBox { get; public set; }
    public IPdfOCG Layer { get; public set; }
    internal PdfArray Matrix { get; }
    public PdfIndirectReference IndirectReference { get; }
    internal PdfObject Resources { get; }
    public PdfContentByte Duplicate { get; }
    public int Type { get; }
    internal PageResources PageResources { get; }
    public PdfTransparencyGroup Group { get; public set; }
    public PdfDictionary Additional { get; public set; }
    protected PdfIndirectReference CurrentPage { get; }
    public PdfIndirectReference PageReference { get; public set; }
    public bool ContentTagged { get; public set; }
    public PdfName Role { get; public set; }
    public AccessibleElementId ID { get; public set; }
    public bool IsInline { get; }
    internal PdfTemplate(PdfWriter wr);
    public static PdfTemplate CreateTemplate(PdfWriter writer, float width, float height);
    internal static PdfTemplate CreateTemplate(PdfWriter writer, float width, float height, PdfName forcedName);
    public virtual bool IsTagged();
    public virtual float get_Width();
    public virtual void set_Width(float value);
    public virtual float get_Height();
    public virtual void set_Height(float value);
    public virtual Rectangle get_BoundingBox();
    public virtual void set_BoundingBox(Rectangle value);
    public virtual IPdfOCG get_Layer();
    public virtual void set_Layer(IPdfOCG value);
    public virtual void SetMatrix(float a, float b, float c, float d, float e, float f);
    internal PdfArray get_Matrix();
    public virtual PdfIndirectReference get_IndirectReference();
    public virtual void BeginVariableText();
    public virtual void EndVariableText();
    internal virtual PdfObject get_Resources();
    public virtual PdfStream GetFormXObject(int compressionLevel);
    public virtual PdfContentByte get_Duplicate();
    public virtual int get_Type();
    internal virtual PageResources get_PageResources();
    public virtual PdfTransparencyGroup get_Group();
    public virtual void set_Group(PdfTransparencyGroup value);
    public virtual void set_Additional(PdfDictionary value);
    public virtual PdfDictionary get_Additional();
    protected virtual PdfIndirectReference get_CurrentPage();
    public virtual PdfIndirectReference get_PageReference();
    public virtual void set_PageReference(PdfIndirectReference value);
    public virtual bool get_ContentTagged();
    public virtual void set_ContentTagged(bool value);
    public virtual PdfObject GetAccessibleAttribute(PdfName key);
    public virtual void SetAccessibleAttribute(PdfName key, PdfObject value);
    public virtual Dictionary`2<PdfName, PdfObject> GetAccessibleAttributes();
    public virtual PdfName get_Role();
    public virtual void set_Role(PdfName value);
    public virtual AccessibleElementId get_ID();
    public virtual void set_ID(AccessibleElementId value);
    public virtual bool get_IsInline();
}
public class iTextSharp.text.pdf.PdfTextArray : object {
    private List`1<object> arrayList;
    private string lastStr;
    private float lastNum;
    internal List`1<object> ArrayList { get; }
    public PdfTextArray(string str);
    public virtual void Add(PdfNumber number);
    public virtual void Add(float number);
    public virtual void Add(string str);
    internal List`1<object> get_ArrayList();
    private void ReplaceLast(object obj);
}
public class iTextSharp.text.pdf.PdfTransition : object {
    public static int SPLITVOUT;
    public static int SPLITHOUT;
    public static int SPLITVIN;
    public static int SPLITHIN;
    public static int BLINDV;
    public static int BLINDH;
    public static int INBOX;
    public static int OUTBOX;
    public static int LRWIPE;
    public static int RLWIPE;
    public static int BTWIPE;
    public static int TBWIPE;
    public static int DISSOLVE;
    public static int LRGLITTER;
    public static int TBGLITTER;
    public static int DGLITTER;
    protected int duration;
    protected int type;
    public int Duration { get; }
    public int Type { get; }
    public PdfDictionary TransitionDictionary { get; }
    public PdfTransition(int type);
    public PdfTransition(int type, int duration);
    public virtual int get_Duration();
    public virtual int get_Type();
    public virtual PdfDictionary get_TransitionDictionary();
}
public class iTextSharp.text.pdf.PdfTransparencyGroup : PdfDictionary {
    unknown bool Isolated {public set; }
    unknown bool Knockout {public set; }
    public virtual void set_Isolated(bool value);
    public virtual void set_Knockout(bool value);
}
public class iTextSharp.text.pdf.PdfVisibilityExpression : PdfArray {
    public static int OR;
    public static int AND;
    public static int NOT;
    public PdfVisibilityExpression(int type);
    public virtual void Add(int index, PdfObject element);
    public virtual bool Add(PdfObject obj);
    public virtual void AddFirst(PdfObject obj);
    public virtual bool Add(Single[] values);
    public virtual bool Add(Int32[] values);
}
public class iTextSharp.text.pdf.PdfWriter : DocWriter {
    public static int GENERATION_MAX;
    public static char VERSION_1_2;
    public static char VERSION_1_3;
    public static char VERSION_1_4;
    public static char VERSION_1_5;
    public static char VERSION_1_6;
    public static char VERSION_1_7;
    public static int PageLayoutSinglePage;
    public static int PageLayoutOneColumn;
    public static int PageLayoutTwoColumnLeft;
    public static int PageLayoutTwoColumnRight;
    public static int PageLayoutTwoPageLeft;
    public static int PageLayoutTwoPageRight;
    public static int PageModeUseNone;
    public static int PageModeUseOutlines;
    public static int PageModeUseThumbs;
    public static int PageModeFullScreen;
    public static int PageModeUseOC;
    public static int PageModeUseAttachments;
    public static int HideToolbar;
    public static int HideMenubar;
    public static int HideWindowUI;
    public static int FitWindow;
    public static int CenterWindow;
    public static int DisplayDocTitle;
    public static int NonFullScreenPageModeUseNone;
    public static int NonFullScreenPageModeUseOutlines;
    public static int NonFullScreenPageModeUseThumbs;
    public static int NonFullScreenPageModeUseOC;
    public static int DirectionL2R;
    public static int DirectionR2L;
    public static int PrintScalingNone;
    public static int SIGNATURE_EXISTS;
    public static int SIGNATURE_APPEND_ONLY;
    public static int PDFXNONE;
    public static int PDFX1A2001;
    public static int PDFX32002;
    public static int STANDARD_ENCRYPTION_40;
    public static int STANDARD_ENCRYPTION_128;
    public static int ENCRYPTION_AES_128;
    public static int ENCRYPTION_AES_256;
    internal static int ENCRYPTION_MASK;
    public static int DO_NOT_ENCRYPT_METADATA;
    public static int EMBEDDED_FILES_ONLY;
    public static int ALLOW_PRINTING;
    public static int ALLOW_MODIFY_CONTENTS;
    public static int ALLOW_COPY;
    public static int ALLOW_MODIFY_ANNOTATIONS;
    public static int ALLOW_FILL_IN;
    public static int ALLOW_SCREENREADERS;
    public static int ALLOW_ASSEMBLY;
    public static int ALLOW_DEGRADED_PRINTING;
    public static int AllowPrinting;
    public static int AllowModifyContents;
    public static int AllowCopy;
    public static int AllowModifyAnnotations;
    public static int AllowFillIn;
    public static int AllowScreenReaders;
    public static int AllowAssembly;
    public static int AllowDegradedPrinting;
    public static bool STRENGTH40BITS;
    public static bool STRENGTH128BITS;
    public static int markAll;
    public static int markInlineElementsOnly;
    public static float SPACE_CHAR_RATIO_DEFAULT;
    public static float NO_SPACE_CHAR_RATIO;
    public static int RUN_DIRECTION_DEFAULT;
    public static int RUN_DIRECTION_NO_BIDI;
    public static int RUN_DIRECTION_LTR;
    public static int RUN_DIRECTION_RTL;
    protected static ICounter COUNTER;
    protected internal PdfDocument pdf;
    protected PdfContentByte directContent;
    protected PdfContentByte directContentUnder;
    protected internal PdfBody body;
    protected ICC_Profile colorProfile;
    protected internal PdfDictionary extraCatalog;
    protected PdfPages root;
    internal List`1<PdfIndirectReference> pageReferences;
    protected int currentPageNumber;
    protected PdfName tabs;
    protected PdfDictionary pageDictEntries;
    private IPdfPageEvent pageEvent;
    protected long prevxref;
    protected Byte[] originalFileID;
    protected IList`1<Dictionary`2<string, object>> newBookmarks;
    public static PdfName PDF_VERSION_1_2;
    public static PdfName PDF_VERSION_1_3;
    public static PdfName PDF_VERSION_1_4;
    public static PdfName PDF_VERSION_1_5;
    public static PdfName PDF_VERSION_1_6;
    public static PdfName PDF_VERSION_1_7;
    protected PdfVersionImp pdf_version;
    public static PdfName DOCUMENT_CLOSE;
    public static PdfName WILL_SAVE;
    public static PdfName DID_SAVE;
    public static PdfName WILL_PRINT;
    public static PdfName DID_PRINT;
    protected Byte[] xmpMetadata;
    protected XmpWriter xmpWriter;
    protected IPdfIsoConformance pdfIsoConformance;
    protected PdfEncryption crypto;
    internal bool fullCompression;
    protected internal int compressionLevel;
    protected Dictionary`2<BaseFont, FontDetails> documentFonts;
    protected int fontNumber;
    protected Dictionary`2<PdfIndirectReference, Object[]> formXObjects;
    protected int formXObjectsCounter;
    protected Dictionary`2<PdfReader, PdfReaderInstance> readerInstances;
    protected PdfReaderInstance currentPdfReaderInstance;
    protected Dictionary`2<ICachedColorSpace, ColorDetails> documentColors;
    protected int colorNumber;
    protected Dictionary`2<PdfPatternPainter, PdfName> documentPatterns;
    protected int patternNumber;
    protected Dictionary`2<PdfShadingPattern, object> documentShadingPatterns;
    protected Dictionary`2<PdfShading, object> documentShadings;
    protected Dictionary`2<PdfDictionary, PdfObject[]> documentExtGState;
    protected Dictionary`2<object, PdfObject[]> documentProperties;
    protected bool tagged;
    protected int taggingMode;
    protected PdfStructureTreeRoot structureTreeRoot;
    protected Dictionary`2<IPdfOCG, object> documentOCG;
    protected List`1<IPdfOCG> documentOCGorder;
    protected PdfOCProperties vOCProperties;
    protected PdfArray OCGRadioGroup;
    protected PdfArray OCGLocked;
    public static PdfName PAGE_OPEN;
    public static PdfName PAGE_CLOSE;
    protected PdfDictionary group;
    private float spaceCharRatio;
    protected int runDirection;
    protected PdfDictionary defaultColorspace;
    protected Dictionary`2<ColorDetails, ColorDetails> documentSpotPatterns;
    protected ColorDetails patternColorspaceRGB;
    protected ColorDetails patternColorspaceGRAY;
    protected ColorDetails patternColorspaceCMYK;
    protected PdfDictionary imageDictionary;
    private Dictionary`2<long, PdfName> images;
    protected Dictionary`2<PdfStream, PdfIndirectReference> JBIG2Globals;
    private bool userProperties;
    private bool rgbTransparencyBlending;
    protected TtfUnicodeWriter ttfUnicodeWriter;
    private static List`1<PdfName> standardStructElems_1_4;
    private static List`1<PdfName> standardStructElems_1_7;
    internal PdfDocument PdfDocument { get; }
    public PdfDictionary Info { get; }
    unknown float InitialLeading {public set; }
    public PdfContentByte DirectContent { get; }
    public PdfContentByte DirectContentUnder { get; }
    public ICC_Profile ColorProfile { get; }
    public PdfIndirectReference PdfIndirectReference { get; }
    protected internal int IndirectReferenceNumber { get; }
    public OutputStreamCounter Os { get; }
    public PdfDictionary ExtraCatalog { get; }
    public PdfDictionary PageDictEntries { get; }
    public int PageNumber { get; }
    internal PdfIndirectReference CurrentPage { get; }
    public int CurrentPageNumber { get; }
    public PdfName Tabs { get; public set; }
    public IPdfPageEvent PageEvent { get; public set; }
    public PdfOutline RootOutline { get; }
    unknown IList`1<Dictionary`2<string, object>> Outlines {public set; }
    unknown char PdfVersion {public set; }
    unknown int ViewerPreferences {public set; }
    unknown PdfPageLabels PageLabels {public set; }
    unknown PdfCollection Collection {public set; }
    public PdfAcroForm AcroForm { get; }
    unknown int SigFlags {public set; }
    public Byte[] XmpMetadata { get; public set; }
    unknown Byte[] PageXmpMetadata {public set; }
    public XmpWriter XmpWriter { get; }
    public int PDFXConformance { get; public set; }
    internal PdfEncryption Encryption { get; }
    public bool FullCompression { get; }
    public int CompressionLevel { get; public set; }
    public long CurrentDocumentSize { get; }
    public PdfStructureTreeRoot StructureTreeRoot { get; }
    public PdfOCProperties OCProperties { get; }
    public Rectangle PageSize { get; }
    unknown Rectangle CropBoxSize {public set; }
    public bool PageEmpty { get; public set; }
    unknown int Duration {public set; }
    unknown PdfTransition Transition {public set; }
    unknown Image Thumbnail {public set; }
    public PdfDictionary Group { get; public set; }
    public float SpaceCharRatio { get; public set; }
    public int RunDirection { get; public set; }
    unknown float Userunit {public set; }
    public PdfDictionary DefaultColorspace { get; }
    public bool StrictImageSequence { get; public set; }
    public bool UserProperties { get; public set; }
    public bool RgbTransparencyBlending { get; public set; }
    protected PdfWriter(PdfDocument document, Stream os);
    private static PdfWriter();
    protected virtual ICounter GetCounter();
    public static PdfWriter GetInstance(Document document, Stream os);
    public static PdfWriter GetInstance(Document document, Stream os, IDocListener listener);
    internal PdfDocument get_PdfDocument();
    public virtual PdfDictionary get_Info();
    public virtual float GetVerticalPosition(bool ensureNewLine);
    public virtual void set_InitialLeading(float value);
    public virtual PdfContentByte get_DirectContent();
    public virtual PdfContentByte get_DirectContentUnder();
    internal void ResetContent();
    public virtual ICC_Profile get_ColorProfile();
    internal void AddLocalDestinations(SortedDictionary`2<string, Destination> desto);
    public virtual PdfIndirectObject AddToBody(PdfObject objecta);
    public virtual PdfIndirectObject AddToBody(PdfObject objecta, bool inObjStm);
    public virtual PdfIndirectObject AddToBody(PdfObject objecta, PdfIndirectReference refa);
    public virtual PdfIndirectObject AddToBody(PdfObject objecta, PdfIndirectReference refa, bool inObjStm);
    public virtual PdfIndirectObject AddToBody(PdfObject objecta, int refNumber);
    public virtual PdfIndirectObject AddToBody(PdfObject objecta, int refNumber, bool inObjStm);
    protected internal virtual void CacheObject(PdfIndirectObject iobj);
    public virtual PdfIndirectReference get_PdfIndirectReference();
    protected internal virtual int get_IndirectReferenceNumber();
    public virtual OutputStreamCounter get_Os();
    protected virtual PdfDictionary GetCatalog(PdfIndirectReference rootObj);
    protected virtual void BuildStructTreeRootForTagged(PdfDictionary catalog);
    public virtual PdfDictionary get_ExtraCatalog();
    public virtual void AddPageDictEntry(PdfName key, PdfObject obj);
    public virtual PdfDictionary get_PageDictEntries();
    public virtual void ResetPageDictEntries();
    public virtual void SetLinearPageMode();
    public virtual int ReorderPages(Int32[] order);
    public virtual PdfIndirectReference GetPageReference(int page);
    public virtual int get_PageNumber();
    internal virtual PdfIndirectReference get_CurrentPage();
    public virtual int get_CurrentPageNumber();
    public virtual void SetPageViewport(PdfArray vp);
    public virtual PdfName get_Tabs();
    public virtual void set_Tabs(PdfName value);
    internal virtual PdfIndirectReference Add(PdfPage page, PdfContents contents);
    public virtual IPdfPageEvent get_PageEvent();
    public virtual void set_PageEvent(IPdfPageEvent value);
    public virtual void Open();
    public virtual void Close();
    protected virtual void AddXFormsToBody();
    protected virtual void AddSharedObjectsToBody();
    public virtual PdfOutline get_RootOutline();
    public virtual void set_Outlines(IList`1<Dictionary`2<string, object>> value);
    protected internal virtual void WriteOutlines(PdfDictionary catalog, bool namedAsNames);
    public virtual void set_PdfVersion(char value);
    public virtual void SetAtLeastPdfVersion(char version);
    public virtual void SetPdfVersion(PdfName version);
    public virtual void AddDeveloperExtension(PdfDeveloperExtension de);
    internal PdfVersionImp GetPdfVersion();
    public virtual void set_ViewerPreferences(int value);
    public virtual void AddViewerPreference(PdfName key, PdfObject value);
    public virtual void set_PageLabels(PdfPageLabels value);
    public virtual void AddNamedDestinations(IDictionary`2<string, string> map, int page_offset);
    public virtual void AddNamedDestination(string name, int page, PdfDestination dest);
    public virtual void AddJavaScript(PdfAction js);
    public virtual void AddJavaScript(string code, bool unicode);
    public virtual void AddJavaScript(string code);
    public virtual void AddJavaScript(string name, PdfAction js);
    public virtual void AddJavaScript(string name, string code, bool unicode);
    public virtual void AddJavaScript(string name, string code);
    public virtual void AddFileAttachment(string description, Byte[] fileStore, string file, string fileDisplay);
    public virtual void AddFileAttachment(string description, PdfFileSpecification fs);
    public virtual void AddFileAttachment(PdfFileSpecification fs);
    public virtual void SetOpenAction(string name);
    public virtual void SetOpenAction(PdfAction action);
    public virtual void SetAdditionalAction(PdfName actionType, PdfAction action);
    public virtual void set_Collection(PdfCollection value);
    public virtual PdfAcroForm get_AcroForm();
    public virtual void AddAnnotation(PdfAnnotation annot);
    internal virtual void AddAnnotation(PdfAnnotation annot, int page);
    public virtual void AddCalculationOrder(PdfFormField annot);
    public virtual void set_SigFlags(int value);
    public virtual void SetLanguage(string language);
    public virtual void set_XmpMetadata(Byte[] value);
    public virtual Byte[] get_XmpMetadata();
    public virtual void set_PageXmpMetadata(Byte[] value);
    public virtual XmpWriter get_XmpWriter();
    public virtual void CreateXmpMetadata();
    public virtual IPdfIsoConformance InitPdfIsoConformance();
    public virtual void set_PDFXConformance(int value);
    public virtual int get_PDFXConformance();
    public virtual bool IsPdfIso();
    public virtual bool IsPdfX();
    public virtual void SetOutputIntents(string outputConditionIdentifier, string outputCondition, string registryName, string info, ICC_Profile colorProfile);
    public virtual void SetOutputIntents(string outputConditionIdentifier, string outputCondition, string registryName, string info, Byte[] destOutputProfile);
    public virtual bool SetOutputIntents(PdfReader reader, bool checkExistence);
    protected static string GetNameString(PdfDictionary dic, PdfName key);
    internal PdfEncryption get_Encryption();
    public virtual void SetEncryption(Byte[] userPassword, Byte[] ownerPassword, int permissions, int encryptionType);
    public virtual void SetEncryption(X509Certificate[] certs, Int32[] permissions, int encryptionType);
    public virtual void SetEncryption(Byte[] userPassword, Byte[] ownerPassword, int permissions, bool strength128Bits);
    public virtual void SetEncryption(bool strength, string userPassword, string ownerPassword, int permissions);
    public virtual void SetEncryption(int encryptionType, string userPassword, string ownerPassword, int permissions);
    public virtual bool get_FullCompression();
    public virtual void SetFullCompression();
    public virtual void set_CompressionLevel(int value);
    public virtual int get_CompressionLevel();
    internal FontDetails AddSimple(BaseFont bf);
    internal void EliminateFontSubset(PdfDictionary fonts);
    internal PdfName AddDirectTemplateSimple(PdfTemplate template, PdfName forcedName);
    public virtual void ReleaseTemplate(PdfTemplate tp);
    public virtual PdfImportedPage GetImportedPage(PdfReader reader, int pageNumber);
    protected virtual PdfReaderInstance GetPdfReaderInstance(PdfReader reader);
    public virtual void FreeReader(PdfReader reader);
    public virtual long get_CurrentDocumentSize();
    protected internal virtual int GetNewObjectNumber(PdfReader reader, int number, int generation);
    internal virtual RandomAccessFileOrArray GetReaderFile(PdfReader reader);
    internal PdfName GetColorspaceName();
    internal virtual ColorDetails AddSimple(ICachedColorSpace spc);
    internal virtual PdfName AddSimplePattern(PdfPatternPainter painter);
    internal void AddSimpleShadingPattern(PdfShadingPattern shading);
    internal void AddSimpleShading(PdfShading shading);
    internal PdfObject[] AddSimpleExtGState(PdfDictionary gstate);
    internal PdfObject[] AddSimpleProperty(object prop, PdfIndirectReference refi);
    internal bool PropertyExists(object prop);
    public virtual void SetTagged();
    public virtual void SetTagged(int taggingMode);
    public virtual bool NeedToBeMarkedInContent(IAccessibleElement element);
    public virtual void CheckElementRole(IAccessibleElement element, IAccessibleElement parent);
    public virtual bool IsTagged();
    internal virtual void FlushTaggedObjects();
    internal virtual void FlushAcroFields();
    public virtual PdfStructureTreeRoot get_StructureTreeRoot();
    public virtual PdfOCProperties get_OCProperties();
    public virtual void AddOCGRadioGroup(List`1<PdfLayer> group);
    public virtual void LockLayer(PdfLayer layer);
    private static void GetOCGOrder(PdfArray order, PdfLayer layer);
    private void AddASEvent(PdfName eventa, PdfName category);
    protected virtual void FillOCProperties(bool erase);
    internal virtual void RegisterLayer(IPdfOCG layer);
    public virtual Rectangle get_PageSize();
    public virtual void set_CropBoxSize(Rectangle value);
    public virtual void SetBoxSize(string boxName, Rectangle size);
    public virtual Rectangle GetBoxSize(string boxName);
    public virtual Rectangle GetBoxSize(string boxName, Rectangle intersectingRectangle);
    public virtual void set_PageEmpty(bool value);
    public virtual bool get_PageEmpty();
    public virtual void SetPageAction(PdfName actionType, PdfAction action);
    public virtual void set_Duration(int value);
    public virtual void set_Transition(PdfTransition value);
    public virtual void set_Thumbnail(Image value);
    public virtual PdfDictionary get_Group();
    public virtual void set_Group(PdfDictionary value);
    public virtual void set_SpaceCharRatio(float value);
    public virtual float get_SpaceCharRatio();
    public virtual void set_RunDirection(int value);
    public virtual int get_RunDirection();
    public virtual void set_Userunit(float value);
    public virtual PdfDictionary get_DefaultColorspace();
    public virtual void SetDefaultColorspace(PdfName key, PdfObject cs);
    internal ColorDetails AddSimplePatternColorspace(BaseColor color);
    public virtual void set_StrictImageSequence(bool value);
    public virtual bool get_StrictImageSequence();
    public virtual void ClearTextWrap();
    public virtual PdfName AddDirectImageSimple(Image image);
    public virtual PdfName AddDirectImageSimple(Image image, PdfIndirectReference fixedRef);
    internal virtual PdfIndirectReference Add(PdfImage pdfImage, PdfIndirectReference fixedRef);
    internal virtual PdfIndirectReference GetImageReference(PdfName name);
    protected virtual PdfIndirectReference Add(PdfICCBased icc);
    protected internal virtual PdfIndirectReference GetReferenceJBIG2Globals(Byte[] content);
    public virtual void set_UserProperties(bool value);
    public virtual bool get_UserProperties();
    public virtual bool get_RgbTransparencyBlending();
    public virtual void set_RgbTransparencyBlending(bool value);
    protected static void WriteKeyInfo(Stream os);
    protected internal virtual TtfUnicodeWriter GetTtfUnicodeWriter();
    protected internal virtual XmpWriter CreateXmpWriter(MemoryStream baos, PdfDictionary info);
    protected internal virtual XmpWriter CreateXmpWriter(MemoryStream baos, IDictionary`2<string, string> info);
    public virtual PdfAnnotation CreateAnnotation(Rectangle rect, PdfName subtype);
    public virtual PdfAnnotation CreateAnnotation(float llx, float lly, float urx, float ury, PdfString title, PdfString content, PdfName subtype);
    public virtual PdfAnnotation CreateAnnotation(float llx, float lly, float urx, float ury, PdfAction action, PdfName subtype);
    public static void CheckPdfIsoConformance(PdfWriter writer, int key, object obj1);
    public virtual void CheckPdfIsoConformance(int key, object obj1);
    private void CompleteInfoDictionary(PdfDictionary info);
    private void CompleteExtraCatalog(PdfDictionary extraCatalog);
    public virtual List`1<PdfName> GetStandardStructElems();
}
public class iTextSharp.text.pdf.PdfXConformanceException : PdfIsoConformanceException {
    public PdfXConformanceException(string s);
    protected PdfXConformanceException(SerializationInfo info, StreamingContext context);
}
public class iTextSharp.text.pdf.Pfm2afm : object {
    private RandomAccessFileOrArray inp;
    private StreamWriter outp;
    private Encoding encoding;
    private short vers;
    private int h_len;
    private string copyright;
    private short type;
    private short points;
    private short verres;
    private short horres;
    private short ascent;
    private short intleading;
    private short extleading;
    private byte italic;
    private byte uline;
    private byte overs;
    private short weight;
    private byte charset;
    private short pixwidth;
    private short pixheight;
    private byte kind;
    private short avgwidth;
    private short maxwidth;
    private int firstchar;
    private int lastchar;
    private byte defchar;
    private byte brkchar;
    private short widthby;
    private int device;
    private int face;
    private int bits;
    private int bitoff;
    private short extlen;
    private int psext;
    private int chartab;
    private int res1;
    private int kernpairs;
    private int res2;
    private int fontname;
    private short capheight;
    private short xheight;
    private short ascender;
    private short descender;
    private bool isMono;
    private Int32[] Win2PSStd;
    private Int32[] WinClass;
    private String[] WinChars;
    private Pfm2afm(RandomAccessFileOrArray inp, Stream outp);
    public static void Convert(RandomAccessFileOrArray inp, Stream outp);
    private string ReadString(int n);
    private string ReadString();
    private void Outval(int n);
    private void Outchar(int code, int width, string name);
    private void Openpfm();
    private void Putheader();
    private void Putchartab();
    private void Putkerntab();
    private void Puttrailer();
}
public class iTextSharp.text.pdf.PRAcroForm : PdfDictionary {
    internal List`1<FieldInformation> fields;
    internal List`1<PdfDictionary> stack;
    internal Dictionary`2<string, FieldInformation> fieldByName;
    internal PdfReader reader;
    public int Size { get; }
    public List`1<FieldInformation> Fields { get; }
    public PRAcroForm(PdfReader reader);
    public int get_Size();
    public virtual List`1<FieldInformation> get_Fields();
    public virtual FieldInformation GetField(string name);
    public virtual PRIndirectReference GetRefByName(string name);
    public virtual void ReadAcroForm(PdfDictionary root);
    protected virtual void IterateFields(PdfArray fieldlist, PRIndirectReference fieldDict, string parentPath);
    protected virtual PdfDictionary MergeAttrib(PdfDictionary parent, PdfDictionary child);
    protected virtual void PushAttrib(PdfDictionary dict);
}
public class iTextSharp.text.pdf.PRIndirectReference : PdfIndirectReference {
    protected PdfReader reader;
    public PdfReader Reader { get; }
    public PRIndirectReference(PdfReader reader, int number, int generation);
    public PRIndirectReference(PdfReader reader, int number);
    public virtual void ToPdf(PdfWriter writer, Stream os);
    public virtual PdfReader get_Reader();
    public virtual void SetNumber(int number, int generation);
}
public class iTextSharp.text.pdf.PRStream : PdfStream {
    protected PdfReader reader;
    protected long offset;
    protected int length;
    protected int objNum;
    protected int objGen;
    public int Length { get; public set; }
    public long Offset { get; }
    public PdfReader Reader { get; }
    public int ObjNum { get; public set; }
    public int ObjGen { get; public set; }
    public PRStream(PRStream stream, PdfDictionary newDic);
    public PRStream(PRStream stream, PdfDictionary newDic, PdfReader reader);
    public PRStream(PdfReader reader, long offset);
    public PRStream(PdfReader reader, Byte[] conts);
    public PRStream(PdfReader reader, Byte[] conts, int compressionLevel);
    public virtual void SetData(Byte[] data, bool compress);
    public virtual void SetData(Byte[] data, bool compress, int compressionLevel);
    public virtual void SetDataRaw(Byte[] data);
    public virtual void SetData(Byte[] data);
    public void set_Length(int value);
    public int get_Length();
    public virtual long get_Offset();
    public virtual PdfReader get_Reader();
    public Byte[] GetBytes();
    public virtual int get_ObjNum();
    public virtual void set_ObjNum(int value);
    public virtual int get_ObjGen();
    public virtual void set_ObjGen(int value);
    public virtual void ToPdf(PdfWriter writer, Stream os);
}
public class iTextSharp.text.pdf.PRTokeniser : object {
    internal static string EMPTY;
    private RandomAccessFileOrArray file;
    protected TokType type;
    protected string stringValue;
    protected int reference;
    protected int generation;
    protected bool hexString;
    private StringBuilder outBuf;
    public long FilePointer { get; }
    public long Length { get; }
    public RandomAccessFileOrArray SafeFile { get; }
    public RandomAccessFileOrArray File { get; }
    public TokType TokenType { get; }
    public string StringValue { get; }
    public int Reference { get; }
    public int Generation { get; }
    public long LongValue { get; }
    public int IntValue { get; }
    public PRTokeniser(RandomAccessFileOrArray file);
    public virtual void Seek(long pos);
    public virtual long get_FilePointer();
    public virtual void Close();
    public virtual long get_Length();
    public virtual int Read();
    public virtual RandomAccessFileOrArray get_SafeFile();
    public virtual RandomAccessFileOrArray get_File();
    public virtual string ReadString(int size);
    public static bool IsWhitespace(int ch);
    public static bool IsWhitespace(int ch, bool isWhitespace);
    public static bool IsDelimiter(int ch);
    public virtual TokType get_TokenType();
    public virtual string get_StringValue();
    public virtual int get_Reference();
    public virtual int get_Generation();
    public virtual void BackOnePosition(int ch);
    public virtual void ThrowError(string error);
    public virtual int GetHeaderOffset();
    public virtual char CheckPdfHeader();
    public virtual void CheckFdfHeader();
    public virtual long GetStartxref();
    public static int GetHex(int v);
    public virtual void NextValidToken();
    public virtual bool NextToken();
    public virtual long get_LongValue();
    public virtual int get_IntValue();
    public virtual bool ReadLineSegment(Byte[] input);
    public virtual bool ReadLineSegment(Byte[] input, bool isNullWhitespace);
    public static Int64[] CheckObjectStart(Byte[] line);
    public virtual bool IsHexString();
}
public class iTextSharp.text.pdf.PushbuttonField : BaseField {
    public static int LAYOUT_LABEL_ONLY;
    public static int LAYOUT_ICON_ONLY;
    public static int LAYOUT_ICON_TOP_LABEL_BOTTOM;
    public static int LAYOUT_LABEL_TOP_ICON_BOTTOM;
    public static int LAYOUT_ICON_LEFT_LABEL_RIGHT;
    public static int LAYOUT_LABEL_LEFT_ICON_RIGHT;
    public static int LAYOUT_LABEL_OVER_ICON;
    public static int SCALE_ICON_ALWAYS;
    public static int SCALE_ICON_NEVER;
    public static int SCALE_ICON_IS_TOO_BIG;
    public static int SCALE_ICON_IS_TOO_SMALL;
    private int layout;
    private Image image;
    private PdfTemplate template;
    private int scaleIcon;
    private bool proportionalIcon;
    private float iconVerticalAdjustment;
    private float iconHorizontalAdjustment;
    private bool iconFitToBounds;
    private PdfTemplate tp;
    private PRIndirectReference iconReference;
    public int Layout { get; public set; }
    public Image Image { get; public set; }
    public PdfTemplate Template { get; public set; }
    public int ScaleIcon { get; public set; }
    public bool ProportionalIcon { get; public set; }
    public float IconVerticalAdjustment { get; public set; }
    public float IconHorizontalAdjustment { get; public set; }
    public PdfFormField Field { get; }
    public bool IconFitToBounds { get; public set; }
    public PRIndirectReference IconReference { get; public set; }
    public PushbuttonField(PdfWriter writer, Rectangle box, string fieldName);
    public virtual void set_Layout(int value);
    public virtual int get_Layout();
    public virtual Image get_Image();
    public virtual void set_Image(Image value);
    public virtual void set_Template(PdfTemplate value);
    public virtual PdfTemplate get_Template();
    public virtual void set_ScaleIcon(int value);
    public virtual int get_ScaleIcon();
    public virtual bool get_ProportionalIcon();
    public virtual void set_ProportionalIcon(bool value);
    public virtual float get_IconVerticalAdjustment();
    public virtual void set_IconVerticalAdjustment(float value);
    public virtual float get_IconHorizontalAdjustment();
    public virtual void set_IconHorizontalAdjustment(float value);
    private float CalculateFontSize(float w, float h);
    public virtual PdfAppearance GetAppearance();
    public virtual PdfFormField get_Field();
    public virtual bool get_IconFitToBounds();
    public virtual void set_IconFitToBounds(bool value);
    public virtual PRIndirectReference get_IconReference();
    public virtual void set_IconReference(PRIndirectReference value);
}
public class iTextSharp.text.pdf.qrcode.BitArray : object {
    public Int32[] bits;
    public int size;
    public BitArray(int size);
    public int GetSize();
    public bool Get(int i);
    public void Set(int i);
    public void Flip(int i);
    public void SetBulk(int i, int newBits);
    public void Clear();
    public bool IsRange(int start, int end, bool value);
    public Int32[] GetBitArray();
    public void Reverse();
    private static Int32[] MakeArray(int size);
    public virtual string ToString();
}
public class iTextSharp.text.pdf.qrcode.BitMatrix : object {
    public int width;
    public int height;
    public int rowSize;
    public Int32[] bits;
    public BitMatrix(int dimension);
    public BitMatrix(int width, int height);
    public bool Get(int x, int y);
    public void Set(int x, int y);
    public void Flip(int x, int y);
    public void Clear();
    public void SetRegion(int left, int top, int width, int height);
    public BitArray GetRow(int y, BitArray row);
    public int GetWidth();
    public int GetHeight();
    public int GetDimension();
    public virtual string ToString();
}
public class iTextSharp.text.pdf.qrcode.BitVector : object {
    private static int DEFAULT_SIZE_IN_BYTES;
    private int sizeInBits;
    private Byte[] array;
    public int At(int index);
    public int Size();
    public int SizeInBytes();
    public void AppendBit(int bit);
    public void AppendBits(int value, int numBits);
    public void AppendBitVector(BitVector bits);
    public void Xor(BitVector other);
    public virtual string ToString();
    public Byte[] GetArray();
    private void AppendByte(int value);
}
public class iTextSharp.text.pdf.qrcode.BlockPair : object {
    private ByteArray dataBytes;
    private ByteArray errorCorrectionBytes;
    internal BlockPair(ByteArray data, ByteArray errorCorrection);
    public ByteArray GetDataBytes();
    public ByteArray GetErrorCorrectionBytes();
}
public class iTextSharp.text.pdf.qrcode.ByteArray : object {
    private static int INITIAL_SIZE;
    private Byte[] bytes;
    private int size;
    public ByteArray(int size);
    public ByteArray(Byte[] byteArray);
    public int At(int index);
    public void Set(int index, int value);
    public int Size();
    public bool IsEmpty();
    public void AppendByte(int value);
    public void Reserve(int capacity);
    public void Set(Byte[] source, int offset, int count);
}
public class iTextSharp.text.pdf.qrcode.ByteMatrix : object {
    private SByte[][] bytes;
    private int width;
    private int height;
    public ByteMatrix(int width, int height);
    public int GetHeight();
    public int GetWidth();
    public sbyte Get(int x, int y);
    public SByte[][] GetArray();
    public void Set(int x, int y, sbyte value);
    public void Set(int x, int y, int value);
    public void Clear(sbyte value);
    public virtual string ToString();
}
public class iTextSharp.text.pdf.qrcode.CharacterSetECI : object {
    private static Dictionary`2<string, CharacterSetECI> NAME_TO_ECI;
    private string encodingName;
    private int value;
    private CharacterSetECI(int value, string encodingName);
    private static void Initialize();
    public virtual string GetEncodingName();
    public virtual int GetValue();
    private static void AddCharacterSet(int value, string encodingName, Dictionary`2<string, CharacterSetECI> n);
    private static void AddCharacterSet(int value, String[] encodingNames, Dictionary`2<string, CharacterSetECI> n);
    public static CharacterSetECI GetCharacterSetECIByName(string name);
}
public class iTextSharp.text.pdf.qrcode.EncodeHintType : object {
    public static EncodeHintType ERROR_CORRECTION;
    public static EncodeHintType CHARACTER_SET;
    private static EncodeHintType();
}
public class iTextSharp.text.pdf.qrcode.Encoder : object {
    private static string DEFAULT_BYTE_MODE_ENCODING;
    private static Int32[] ALPHANUMERIC_TABLE;
    private static Encoder();
    private static int CalculateMaskPenalty(ByteMatrix matrix);
    public static void Encode(string content, ErrorCorrectionLevel ecLevel, QRCode qrCode);
    public static void Encode(string content, ErrorCorrectionLevel ecLevel, IDictionary`2<EncodeHintType, object> hints, QRCode qrCode);
    private static int GetAlphanumericCode(int code);
    public static Mode ChooseMode(string content);
    public static Mode ChooseMode(string content, string encoding);
    private static bool IsOnlyDoubleByteKanji(string content);
    private static int ChooseMaskPattern(BitVector bits, ErrorCorrectionLevel ecLevel, int version, ByteMatrix matrix);
    private static void InitQRCode(int numInputBytes, ErrorCorrectionLevel ecLevel, Mode mode, QRCode qrCode);
    private static void TerminateBits(int numDataBytes, BitVector bits);
    private static void GetNumDataBytesAndNumECBytesForBlockID(int numTotalBytes, int numDataBytes, int numRSBlocks, int blockID, Int32[] numDataBytesInBlock, Int32[] numECBytesInBlock);
    private static void InterleaveWithECBytes(BitVector bits, int numTotalBytes, int numDataBytes, int numRSBlocks, BitVector result);
    private static ByteArray GenerateECBytes(ByteArray dataBytes, int numEcBytesInBlock);
    private static void AppendModeInfo(Mode mode, BitVector bits);
    private static void AppendLengthInfo(int numLetters, int version, Mode mode, BitVector bits);
    private static void AppendBytes(string content, Mode mode, BitVector bits, string encoding);
    private static void AppendNumericBytes(string content, BitVector bits);
    private static void AppendAlphanumericBytes(string content, BitVector bits);
    private static void Append8BitBytes(string content, BitVector bits, string encoding);
    private static void AppendKanjiBytes(string content, BitVector bits);
    private static void AppendECI(CharacterSetECI eci, BitVector bits);
}
public class iTextSharp.text.pdf.qrcode.ErrorCorrectionLevel : object {
    public static ErrorCorrectionLevel L;
    public static ErrorCorrectionLevel M;
    public static ErrorCorrectionLevel Q;
    public static ErrorCorrectionLevel H;
    private static ErrorCorrectionLevel[] FOR_BITS;
    private int ordinal;
    private int bits;
    private string name;
    private ErrorCorrectionLevel(int ordinal, int bits, string name);
    private static ErrorCorrectionLevel();
    public int Ordinal();
    public int GetBits();
    public string GetName();
    public virtual string ToString();
    public static ErrorCorrectionLevel ForBits(int bits);
}
public class iTextSharp.text.pdf.qrcode.FormatInformation : object {
    private static int FORMAT_INFO_MASK_QR;
    private static Int32[][] FORMAT_INFO_DECODE_LOOKUP;
    private static Int32[] BITS_SET_IN_HALF_BYTE;
    private ErrorCorrectionLevel errorCorrectionLevel;
    private byte dataMask;
    private FormatInformation(int formatInfo);
    private static FormatInformation();
    public static int NumBitsDiffering(int a, int b);
    public static FormatInformation DecodeFormatInformation(int maskedFormatInfo1, int maskedFormatInfo2);
    private static FormatInformation DoDecodeFormatInformation(int maskedFormatInfo1, int maskedFormatInfo2);
    public ErrorCorrectionLevel GetErrorCorrectionLevel();
    public byte GetDataMask();
    public int HashCode();
    public virtual int GetHashCode();
    public virtual bool Equals(object o);
}
public class iTextSharp.text.pdf.qrcode.GF256 : object {
    public static GF256 QR_CODE_FIELD;
    public static GF256 DATA_MATRIX_FIELD;
    private Int32[] expTable;
    private Int32[] logTable;
    private GF256Poly zero;
    private GF256Poly one;
    private GF256(int primitive);
    private static GF256();
    internal GF256Poly GetZero();
    internal GF256Poly GetOne();
    internal GF256Poly BuildMonomial(int degree, int coefficient);
    internal static int AddOrSubtract(int a, int b);
    internal int Exp(int a);
    internal int Log(int a);
    internal int Inverse(int a);
    internal int Multiply(int a, int b);
}
internal class iTextSharp.text.pdf.qrcode.GF256Poly : object {
    private GF256 field;
    private Int32[] coefficients;
    internal GF256Poly(GF256 field, Int32[] coefficients);
    internal Int32[] GetCoefficients();
    internal int GetDegree();
    internal bool IsZero();
    internal int GetCoefficient(int degree);
    internal int EvaluateAt(int a);
    internal GF256Poly AddOrSubtract(GF256Poly other);
    internal GF256Poly Multiply(GF256Poly other);
    internal GF256Poly Multiply(int scalar);
    internal GF256Poly MultiplyByMonomial(int degree, int coefficient);
    internal GF256Poly[] Divide(GF256Poly other);
    public virtual string ToString();
}
public class iTextSharp.text.pdf.qrcode.MaskUtil : object {
    public static int ApplyMaskPenaltyRule1(ByteMatrix matrix);
    public static int ApplyMaskPenaltyRule2(ByteMatrix matrix);
    public static int ApplyMaskPenaltyRule3(ByteMatrix matrix);
    public static int ApplyMaskPenaltyRule4(ByteMatrix matrix);
    public static bool GetDataMaskBit(int maskPattern, int x, int y);
    private static int ApplyMaskPenaltyRule1Internal(ByteMatrix matrix, bool isHorizontal);
}
public class iTextSharp.text.pdf.qrcode.MatrixUtil : object {
    private static int VERSION_INFO_POLY;
    private static int TYPE_INFO_POLY;
    private static int TYPE_INFO_MASK_PATTERN;
    private static Int32[][] POSITION_DETECTION_PATTERN;
    private static Int32[][] HORIZONTAL_SEPARATION_PATTERN;
    private static Int32[][] VERTICAL_SEPARATION_PATTERN;
    private static Int32[][] POSITION_ADJUSTMENT_PATTERN;
    private static Int32[][] POSITION_ADJUSTMENT_PATTERN_COORDINATE_TABLE;
    private static Int32[][] TYPE_INFO_COORDINATES;
    private static MatrixUtil();
    public static void ClearMatrix(ByteMatrix matrix);
    public static void BuildMatrix(BitVector dataBits, ErrorCorrectionLevel ecLevel, int version, int maskPattern, ByteMatrix matrix);
    public static void EmbedBasicPatterns(int version, ByteMatrix matrix);
    public static void EmbedTypeInfo(ErrorCorrectionLevel ecLevel, int maskPattern, ByteMatrix matrix);
    public static void MaybeEmbedVersionInfo(int version, ByteMatrix matrix);
    public static void EmbedDataBits(BitVector dataBits, int maskPattern, ByteMatrix matrix);
    public static int FindMSBSet(int value);
    public static int CalculateBCHCode(int value, int poly);
    public static void MakeTypeInfoBits(ErrorCorrectionLevel ecLevel, int maskPattern, BitVector bits);
    public static void MakeVersionInfoBits(int version, BitVector bits);
    private static bool IsEmpty(int value);
    private static bool IsValidValue(int value);
    private static void EmbedTimingPatterns(ByteMatrix matrix);
    private static void EmbedDarkDotAtLeftBottomCorner(ByteMatrix matrix);
    private static void EmbedHorizontalSeparationPattern(int xStart, int yStart, ByteMatrix matrix);
    private static void EmbedVerticalSeparationPattern(int xStart, int yStart, ByteMatrix matrix);
    private static void EmbedPositionAdjustmentPattern(int xStart, int yStart, ByteMatrix matrix);
    private static void EmbedPositionDetectionPattern(int xStart, int yStart, ByteMatrix matrix);
    private static void EmbedPositionDetectionPatternsAndSeparators(ByteMatrix matrix);
    private static void MaybeEmbedPositionAdjustmentPatterns(int version, ByteMatrix matrix);
}
public class iTextSharp.text.pdf.qrcode.Mode : object {
    public static Mode TERMINATOR;
    public static Mode NUMERIC;
    public static Mode ALPHANUMERIC;
    public static Mode STRUCTURED_APPEND;
    public static Mode BYTE;
    public static Mode ECI;
    public static Mode KANJI;
    public static Mode FNC1_FIRST_POSITION;
    public static Mode FNC1_SECOND_POSITION;
    private Int32[] characterCountBitsForVersions;
    private int bits;
    private string name;
    private Mode(Int32[] characterCountBitsForVersions, int bits, string name);
    private static Mode();
    public static Mode ForBits(int bits);
    public int GetCharacterCountBits(Version version);
    public int GetBits();
    public string GetName();
    public virtual string ToString();
}
public class iTextSharp.text.pdf.qrcode.QRCode : object {
    public static int NUM_MASK_PATTERNS;
    private Mode mode;
    private ErrorCorrectionLevel ecLevel;
    private int version;
    private int matrixWidth;
    private int maskPattern;
    private int numTotalBytes;
    private int numDataBytes;
    private int numECBytes;
    private int numRSBlocks;
    private ByteMatrix matrix;
    public Mode GetMode();
    public ErrorCorrectionLevel GetECLevel();
    public int GetVersion();
    public int GetMatrixWidth();
    public int GetMaskPattern();
    public int GetNumTotalBytes();
    public int GetNumDataBytes();
    public int GetNumECBytes();
    public int GetNumRSBlocks();
    public ByteMatrix GetMatrix();
    public int At(int x, int y);
    public bool IsValid();
    public virtual string ToString();
    public void SetMode(Mode value);
    public void SetECLevel(ErrorCorrectionLevel value);
    public void SetVersion(int value);
    public void SetMatrixWidth(int value);
    public void SetMaskPattern(int value);
    public void SetNumTotalBytes(int value);
    public void SetNumDataBytes(int value);
    public void SetNumECBytes(int value);
    public void SetNumRSBlocks(int value);
    public void SetMatrix(ByteMatrix value);
    public static bool IsValidMaskPattern(int maskPattern);
}
public class iTextSharp.text.pdf.qrcode.QRCodeWriter : object {
    private static int QUIET_ZONE_SIZE;
    public ByteMatrix Encode(string contents, int width, int height);
    public ByteMatrix Encode(string contents, int width, int height, IDictionary`2<EncodeHintType, object> hints);
    private static ByteMatrix RenderResult(QRCode code, int width, int height);
    private static void SetRowColor(SByte[] row, sbyte value);
}
public class iTextSharp.text.pdf.qrcode.ReedSolomonEncoder : object {
    private GF256 field;
    private List`1<GF256Poly> cachedGenerators;
    public ReedSolomonEncoder(GF256 field);
    private GF256Poly BuildGenerator(int degree);
    public void Encode(Int32[] toEncode, int ecBytes);
}
public class iTextSharp.text.pdf.qrcode.ReedSolomonException : Exception {
    public ReedSolomonException(string message);
    protected ReedSolomonException(SerializationInfo info, StreamingContext context);
}
public class iTextSharp.text.pdf.qrcode.Version : object {
    private static Int32[] VERSION_DECODE_INFO;
    private static Version[] VERSIONS;
    private int versionNumber;
    private Int32[] alignmentPatternCenters;
    private ECBlocks[] ecBlocks;
    private int totalCodewords;
    private Version(int versionNumber, Int32[] alignmentPatternCenters, ECBlocks ecBlocks1, ECBlocks ecBlocks2, ECBlocks ecBlocks3, ECBlocks ecBlocks4);
    private static Version();
    public int GetVersionNumber();
    public Int32[] GetAlignmentPatternCenters();
    public int GetTotalCodewords();
    public int GetDimensionForVersion();
    public ECBlocks GetECBlocksForLevel(ErrorCorrectionLevel ecLevel);
    public static Version GetProvisionalVersionForDimension(int dimension);
    public static Version GetVersionForNumber(int versionNumber);
    private static Version DecodeVersionInformation(int versionBits);
    private BitMatrix BuildFunctionPattern();
    public virtual string ToString();
    private static Version[] BuildVersions();
}
public class iTextSharp.text.pdf.qrcode.WriterException : Exception {
    public WriterException(string message);
    protected WriterException(SerializationInfo info, StreamingContext context);
}
public class iTextSharp.text.pdf.RadioCheckField : BaseField {
    public static int TYPE_CHECK;
    public static int TYPE_CIRCLE;
    public static int TYPE_CROSS;
    public static int TYPE_DIAMOND;
    public static int TYPE_SQUARE;
    public static int TYPE_STAR;
    protected static String[] typeChars;
    protected int checkType;
    private string onValue;
    private bool vchecked;
    public int CheckType { get; public set; }
    public string OnValue { get; public set; }
    public bool Checked { get; public set; }
    public PdfFormField RadioField { get; }
    public PdfFormField CheckField { get; }
    public RadioCheckField(PdfWriter writer, Rectangle box, string fieldName, string onValue);
    private static RadioCheckField();
    public virtual int get_CheckType();
    public virtual void set_CheckType(int value);
    public virtual string get_OnValue();
    public virtual void set_OnValue(string value);
    public virtual bool get_Checked();
    public virtual void set_Checked(bool value);
    public virtual PdfAppearance GetAppearance(bool isRadio, bool on);
    public virtual PdfAppearance GetAppearanceRadioCircle(bool on);
    public virtual PdfFormField GetRadioGroup(bool noToggleToOff, bool radiosInUnison);
    public virtual PdfFormField get_RadioField();
    public virtual PdfFormField get_CheckField();
    protected virtual PdfFormField GetField(bool isRadio);
}
public class iTextSharp.text.pdf.RandomAccessFileOrArray : object {
    private IRandomAccessSource byteSource;
    private long byteSourcePosition;
    private byte back;
    private bool isBack;
    public long Length { get; }
    public long FilePointer { get; }
    public RandomAccessFileOrArray(string filename);
    public RandomAccessFileOrArray(RandomAccessFileOrArray source);
    public RandomAccessFileOrArray(IRandomAccessSource byteSource);
    public RandomAccessFileOrArray(string filename, bool forceRead);
    public RandomAccessFileOrArray(Uri url);
    public RandomAccessFileOrArray(Stream inp);
    public RandomAccessFileOrArray(Byte[] arrayIn);
    public virtual RandomAccessFileOrArray CreateView();
    public virtual IRandomAccessSource CreateSourceView();
    protected internal virtual IRandomAccessSource GetByteSource();
    public virtual void PushBack(byte b);
    public virtual int Read();
    public virtual int Read(Byte[] b, int off, int len);
    public virtual int Read(Byte[] b);
    public virtual void ReadFully(Byte[] b);
    public virtual void ReadFully(Byte[] b, int off, int len);
    public virtual long Skip(long n);
    public virtual long SkipBytes(long n);
    public virtual void ReOpen();
    public virtual void Close();
    public virtual long get_Length();
    public virtual void Seek(long pos);
    public virtual void Seek(int pos);
    public virtual long get_FilePointer();
    public virtual bool ReadBoolean();
    public virtual byte ReadByte();
    public virtual int ReadUnsignedByte();
    public virtual short ReadShort();
    public short ReadShortLE();
    public virtual int ReadUnsignedShort();
    public int ReadUnsignedShortLE();
    public virtual char ReadChar();
    public char ReadCharLE();
    public virtual int ReadInt();
    public int ReadIntLE();
    public long ReadUnsignedInt();
    public long ReadUnsignedIntLE();
    public virtual long ReadLong();
    public long ReadLongLE();
    public virtual float ReadFloat();
    public float ReadFloatLE();
    public virtual double ReadDouble();
    public double ReadDoubleLE();
    public virtual string ReadLine();
    public virtual string ReadString(int length, string encoding);
}
public class iTextSharp.text.pdf.ReaderProperties : object {
    internal X509Certificate certificate;
    internal ICipherParameters certificateKey;
    internal Byte[] ownerPassword;
    internal bool partialRead;
    internal bool closeSourceOnconstructorError;
    internal MemoryLimitsAwareHandler memoryLimitsAwareHandler;
    public ReaderProperties SetCertificate(X509Certificate certificate);
    public ReaderProperties SetCertificateKey(ICipherParameters certificateKey);
    public ReaderProperties SetOwnerPassword(Byte[] ownerPassword);
    public ReaderProperties SetPartialRead(bool partialRead);
    public ReaderProperties SetCloseSourceOnconstructorError(bool closeSourceOnconstructorError);
    public ReaderProperties SetMemoryLimitsAwareHandler(MemoryLimitsAwareHandler memoryLimitsAwareHandler);
}
public class iTextSharp.text.pdf.RefKey : object {
    private int num;
    private int gen;
    internal RefKey(int num, int gen);
    public RefKey(PdfIndirectReference referemce);
    internal RefKey(PRIndirectReference reference);
    public virtual int GetHashCode();
    public virtual bool Equals(object o);
    public virtual string ToString();
}
public class iTextSharp.text.pdf.security.AsymmetricAlgorithmSignature : object {
    private AsymmetricAlgorithm algorithm;
    private string hashAlgorithm;
    private string encryptionAlgorithm;
    private AsymmetricAlgorithmSignature(AsymmetricAlgorithm algorithm, string hashAlgorithm);
    public AsymmetricAlgorithmSignature(RSACryptoServiceProvider algorithm, string hashAlgorithm);
    public AsymmetricAlgorithmSignature(DSACryptoServiceProvider algorithm);
    public sealed virtual Byte[] Sign(Byte[] message);
    public sealed virtual string GetHashAlgorithm();
    public sealed virtual string GetEncryptionAlgorithm();
}
public static class iTextSharp.text.pdf.security.CertificateInfo : object {
    public static X509Name GetIssuerFields(X509Certificate cert);
    public static Asn1Object GetIssuer(Byte[] enc);
    public static X509Name GetSubjectFields(X509Certificate cert);
    private static Asn1Object GetSubject(Byte[] enc);
}
public static class iTextSharp.text.pdf.security.CertificateUtil : object {
    public static string GetCRLURL(X509Certificate certificate);
    public static string GetOCSPURL(X509Certificate certificate);
    public static string GetTSAURL(X509Certificate certificate);
    private static Asn1Object GetExtensionValue(X509Certificate cert, string oid);
    private static string GetStringFromGeneralName(Asn1Object names);
}
public static class iTextSharp.text.pdf.security.CertificateVerification : object {
    public static string VerifyCertificate(X509Certificate cert, ICollection`1<X509Crl> crls, DateTime calendar);
    public static IList`1<VerificationException> VerifyCertificates(ICollection`1<X509Certificate> certs, ICollection`1<X509Certificate> keystore, ICollection`1<X509Crl> crls, DateTime calendar);
    public static IList`1<VerificationException> VerifyCertificates(ICollection`1<X509Certificate> certs, ICollection`1<X509Certificate> keystore, DateTime calendar);
    public static bool VerifyOcspCertificates(BasicOcspResp ocsp, ICollection`1<X509Certificate> keystore);
    public static bool VerifyTimestampCertificates(TimeStampToken ts, ICollection`1<X509Certificate> keystore);
}
public class iTextSharp.text.pdf.security.CertificateVerifier : object {
    protected CertificateVerifier verifier;
    protected bool onlineCheckingAllowed;
    unknown bool OnlineCheckingAllowed {public set; }
    public CertificateVerifier(CertificateVerifier verifier);
    public virtual void set_OnlineCheckingAllowed(bool value);
    public virtual List`1<VerificationOK> Verify(X509Certificate signCert, X509Certificate issuerCert, DateTime signDate);
}
public class iTextSharp.text.pdf.security.CrlClientOffline : object {
    private List`1<Byte[]> crls;
    public CrlClientOffline(Byte[] crlEncoded);
    public virtual ICollection`1<Byte[]> GetEncoded(X509Certificate checkCert, string url);
}
public class iTextSharp.text.pdf.security.CrlClientOnline : object {
    private static ILogger LOGGER;
    protected IList`1<string> urls;
    public CrlClientOnline(String[] crls);
    public CrlClientOnline(ICollection`1<X509Certificate> chain);
    private static CrlClientOnline();
    protected virtual void AddUrl(string url);
    public virtual ICollection`1<Byte[]> GetEncoded(X509Certificate checkCert, string url);
}
public class iTextSharp.text.pdf.security.CrlVerifier : RootStoreVerifier {
    private static ILogger LOGGER;
    private List`1<X509Crl> crls;
    public CrlVerifier(CertificateVerifier verifier, List`1<X509Crl> crls);
    private static CrlVerifier();
    public virtual List`1<VerificationOK> Verify(X509Certificate signCert, X509Certificate issuerCert, DateTime signDate);
    public virtual bool Verify(X509Crl crl, X509Certificate signCert, X509Certificate issuerCert, DateTime signDate);
    public virtual X509Crl GetCrl(X509Certificate signCert, X509Certificate issuerCert);
    public virtual bool IsSignatureValid(X509Crl crl, X509Certificate crlIssuer);
}
public enum iTextSharp.text.pdf.security.CryptoStandard : Enum {
    public int value__;
    public static CryptoStandard CMS;
    public static CryptoStandard CADES;
}
public static class iTextSharp.text.pdf.security.DigestAlgorithms : object {
    public static string SHA1;
    public static string SHA256;
    public static string SHA384;
    public static string SHA512;
    public static string RIPEMD160;
    private static Dictionary`2<string, string> digestNames;
    private static Dictionary`2<string, string> allowedDigests;
    private static DigestAlgorithms();
    public static IDigest GetMessageDigestFromOid(string digestOid);
    public static IDigest GetMessageDigest(string hashAlgorithm);
    public static Byte[] Digest(Stream data, string hashAlgorithm);
    public static Byte[] Digest(Stream data, IDigest messageDigest);
    public static string GetDigest(string oid);
    public static string GetAllowedDigests(string name);
    public static Byte[] Digest(string algo, Byte[] b, int offset, int len);
    public static Byte[] Digest(string algo, Byte[] b);
    public static Byte[] Digest(IDigest d, Byte[] b, int offset, int len);
    public static Byte[] Digest(IDigest d, Byte[] b);
}
public static class iTextSharp.text.pdf.security.EncryptionAlgorithms : object {
    private static Dictionary`2<string, string> algorithmNames;
    private static EncryptionAlgorithms();
    public static string GetAlgorithm(string oid);
}
public interface iTextSharp.text.pdf.security.ICrlClient {
    public abstract virtual ICollection`1<Byte[]> GetEncoded(X509Certificate checkCert, string url);
}
public interface iTextSharp.text.pdf.security.IExternalSignature {
    public abstract virtual string GetHashAlgorithm();
    public abstract virtual string GetEncryptionAlgorithm();
    public abstract virtual Byte[] Sign(Byte[] message);
}
public interface iTextSharp.text.pdf.security.IExternalSignatureContainer {
    public abstract virtual Byte[] Sign(Stream data);
    public abstract virtual void ModifySigningDictionary(PdfDictionary signDic);
}
public interface iTextSharp.text.pdf.security.IOcspClient {
    public abstract virtual Byte[] GetEncoded(X509Certificate checkCert, X509Certificate rootCert, string url);
}
public interface iTextSharp.text.pdf.security.ITSAClient {
    public abstract virtual int GetTokenSizeEstimate();
    public abstract virtual IDigest GetMessageDigest();
    public abstract virtual Byte[] GetTimeStampToken(Byte[] imprint);
}
public interface iTextSharp.text.pdf.security.ITSAInfoBouncyCastle {
    public abstract virtual void InspectTimeStampTokenInfo(TimeStampTokenInfo info);
}
public interface iTextSharp.text.pdf.security.IXmlLocator {
    public abstract virtual XmlDocument GetDocument();
    public abstract virtual void SetDocument(XmlDocument document);
    public abstract virtual string GetEncoding();
}
public interface iTextSharp.text.pdf.security.IXpathConstructor {
    public abstract virtual string GetXpathExpression();
    public abstract virtual XmlNamespaceManager GetNamespaceManager();
}
public static class iTextSharp.text.pdf.security.LtvTimestamp : object {
    public static void Timestamp(PdfSignatureAppearance sap, ITSAClient tsa, string signatureName);
}
public class iTextSharp.text.pdf.security.LtvVerification : object {
    private ILogger LOGGER;
    private PdfStamper stp;
    private PdfWriter writer;
    private PdfReader reader;
    private AcroFields acroFields;
    private IDictionary`2<PdfName, ValidationData> validated;
    private bool used;
    public LtvVerification(PdfStamper stp);
    public virtual bool AddVerification(string signatureName, IOcspClient ocsp, ICrlClient crl, CertificateOption certOption, Level level, CertificateInclusion certInclude);
    private X509Certificate GetParent(X509Certificate cert, X509Certificate[] certs);
    public virtual bool AddVerification(string signatureName, ICollection`1<Byte[]> ocsps, ICollection`1<Byte[]> crls, ICollection`1<Byte[]> certs);
    private static Byte[] BuildOCSPResponse(Byte[] BasicOCSPResponse);
    private PdfName GetSignatureHashKey(string signatureName);
    private static Byte[] HashBytesSha1(Byte[] b);
    public virtual void Merge();
    private void UpdateDss();
    private static void DeleteOldReferences(PdfArray all, PdfArray toDelete);
    private void CreateDss();
    private void OutputDss(PdfDictionary dss, PdfDictionary vrim, PdfArray ocsps, PdfArray crls, PdfArray certs);
}
public class iTextSharp.text.pdf.security.LtvVerifier : RootStoreVerifier {
    private static ILogger LOGGER;
    protected CertificateOption option;
    protected bool verifyRootCertificate;
    protected PdfReader reader;
    protected AcroFields fields;
    protected DateTime signDate;
    protected string signatureName;
    protected PdfPKCS7 pkcs7;
    protected bool latestRevision;
    protected PdfDictionary dss;
    unknown CertificateVerifier Verifier {public set; }
    unknown CertificateOption CertificateOption {public set; }
    unknown bool VerifyRootCertificate {public set; }
    public LtvVerifier(PdfReader reader);
    private static LtvVerifier();
    public virtual void set_Verifier(CertificateVerifier value);
    public virtual void set_CertificateOption(CertificateOption value);
    public virtual void set_VerifyRootCertificate(bool value);
    protected virtual PdfPKCS7 CoversWholeDocument();
    public virtual List`1<VerificationOK> Verify(List`1<VerificationOK> result);
    public virtual List`1<VerificationOK> VerifySignature();
    public virtual void VerifyChain(X509Certificate[] chain);
    public virtual List`1<VerificationOK> Verify(X509Certificate signCert, X509Certificate issuerCert, DateTime sigDate);
    public virtual void SwitchToPreviousRevision();
    public virtual List`1<X509Crl> GetCRLsFromDSS();
    public virtual List`1<BasicOcspResp> GetOCSPResponsesFromDSS();
}
public static class iTextSharp.text.pdf.security.MakeSignature : object {
    private static ILogger LOGGER;
    private static MakeSignature();
    public static void SignDetached(PdfSignatureAppearance sap, IExternalSignature externalSignature, ICollection`1<X509Certificate> chain, ICollection`1<ICrlClient> crlList, IOcspClient ocspClient, ITSAClient tsaClient, int estimatedSize, CryptoStandard sigtype);
    public static void SignDetached(PdfSignatureAppearance sap, IExternalSignature externalSignature, ICollection`1<X509Certificate> chain, ICollection`1<ICrlClient> crlList, IOcspClient ocspClient, ITSAClient tsaClient, int estimatedSize, CryptoStandard sigtype, SignaturePolicyInfo signaturePolicy);
    public static void SignDetached(PdfSignatureAppearance sap, IExternalSignature externalSignature, ICollection`1<X509Certificate> chain, ICollection`1<ICrlClient> crlList, IOcspClient ocspClient, ITSAClient tsaClient, int estimatedSize, CryptoStandard sigtype, SignaturePolicyIdentifier signaturePolicy);
    public static ICollection`1<Byte[]> ProcessCrl(X509Certificate cert, ICollection`1<ICrlClient> crlList);
    public static void SignExternalContainer(PdfSignatureAppearance sap, IExternalSignatureContainer externalSignatureContainer, int estimatedSize);
    public static void SignDeferred(PdfReader reader, string fieldName, Stream outs, IExternalSignatureContainer externalSignatureContainer);
}
public class iTextSharp.text.pdf.security.MakeXmlSignature : object {
    public static void SignXmlDSig(XmlSignatureAppearance sap, IExternalSignature externalSignature, KeyInfoClause keyInfo);
    public static void SignXades(XmlSignatureAppearance sap, IExternalSignature externalSignature, X509Certificate[] chain, bool includeSignaturePolicy);
    public static void SignXadesBes(XmlSignatureAppearance sap, IExternalSignature externalSignature, X509Certificate[] chain);
    public static void SignXadesEpes(XmlSignatureAppearance sap, IExternalSignature externalSignature, X509Certificate[] chain);
    public static void SignXmlDSig(XmlSignatureAppearance sap, IExternalSignature externalSignature, X509Certificate[] chain);
    public static void SignXmlDSig(XmlSignatureAppearance sap, IExternalSignature externalSignature, AsymmetricAlgorithm publicKey);
    private static void VerifyArguments(XmlSignatureAppearance sap, IExternalSignature externalSignature);
    private static void NormalizeNamespaces(XPathNavigator src, XPathNavigator dest);
    private static Byte[] CalculateC14nByteRange(XmlDocument doc);
    private static Byte[] CalculateC14nDigest(XmlDocument doc, HashAlgorithm hash);
    private static XmlElement GenerateSignatureElement(IXmlLocator locator, string signatureId, bool isXades);
    private static KeyInfoClause GenerateKeyInfo(X509Certificate[] chain, XmlSignatureAppearance sap);
    private static KeyInfoClause GenerateKeyInfo(AsymmetricAlgorithm publicKey);
    private static string GetRandomId();
    private static XmlElement GenerateXadesObject(XmlSignatureAppearance sap, string signatureId, string contentReferenceId, string signedPropertiesId, String[] signaturePolicy, XmlElement& signedProperty);
    private static string GetX509IssuerName(X509Certificate cert);
    private static string GetX509SerialNumber(X509Certificate cert);
    private static XmlElement GenerateContentReference(XmlDocument doc, XmlSignatureAppearance sap, string referenceId);
    private static XmlElement GenerateCustomReference(XmlDocument doc, XmlElement signedElement, string uri, string type, string id);
    private static void Sign(XmlElement signature, IXmlLocator xmlLocator, IExternalSignature externalSignature, List`1<XmlElement> references, XmlElement dsObject, KeyInfoClause keyInfo);
}
public class iTextSharp.text.pdf.security.OcspClientBouncyCastle : object {
    private static ILogger LOGGER;
    private OcspVerifier verifier;
    public OcspClientBouncyCastle(OcspVerifier verifier);
    private static OcspClientBouncyCastle();
    public virtual BasicOcspResp GetBasicOCSPResp(X509Certificate checkCert, X509Certificate rootCert, string url);
    public sealed virtual Byte[] GetEncoded(X509Certificate checkCert, X509Certificate rootCert, string url);
    private static OcspReq GenerateOCSPRequest(X509Certificate issuerCert, BigInteger serialNumber);
    private OcspResp GetOcspResponse(X509Certificate checkCert, X509Certificate rootCert, string url);
}
public class iTextSharp.text.pdf.security.OcspVerifier : RootStoreVerifier {
    private static ILogger LOGGER;
    protected static string id_kp_OCSPSigning;
    protected List`1<BasicOcspResp> ocsps;
    public OcspVerifier(CertificateVerifier verifier, List`1<BasicOcspResp> ocsps);
    private static OcspVerifier();
    public virtual List`1<VerificationOK> Verify(X509Certificate signCert, X509Certificate issuerCert, DateTime signDate);
    public virtual bool Verify(BasicOcspResp ocspResp, X509Certificate signCert, X509Certificate issuerCert, DateTime signDate);
    public virtual void IsValidResponse(BasicOcspResp ocspResp, X509Certificate issuerCert);
    [ObsoleteAttribute]
public virtual bool VerifyResponse(BasicOcspResp ocspResp, X509Certificate issuerCert);
    public virtual bool IsSignatureValid(BasicOcspResp ocspResp, X509Certificate responderCert);
    public virtual BasicOcspResp GetOcspResponse(X509Certificate signCert, X509Certificate issuerCert);
}
public class iTextSharp.text.pdf.security.PdfPKCS7 : object {
    private SignaturePolicyIdentifier signaturePolicyIdentifier;
    private string signName;
    private string reason;
    private string location;
    private DateTime signDate;
    private int version;
    private int signerversion;
    private string digestAlgorithmOid;
    private IDigest messageDigest;
    private Dictionary`2<string, object> digestalgos;
    private Byte[] digestAttr;
    private PdfName filterSubtype;
    private string digestEncryptionAlgorithmOid;
    private Byte[] externalDigest;
    private Byte[] externalRSAdata;
    private ISigner sig;
    private Byte[] digest;
    private Byte[] RSAdata;
    private Byte[] sigAttr;
    private Byte[] sigAttrDer;
    private IDigest encContDigest;
    private bool verified;
    private bool verifyResult;
    private List`1<X509Certificate> certs;
    private ICollection`1<X509Certificate> signCerts;
    private X509Certificate signCert;
    private ICollection`1<X509Crl> crls;
    private BasicOcspResp basicResp;
    private bool isTsp;
    private bool isCades;
    private TimeStampToken timeStampToken;
    public string SignName { get; public set; }
    public string Reason { get; public set; }
    public string Location { get; public set; }
    public DateTime SignDate { get; public set; }
    public int Version { get; }
    public int SigningInfoVersion { get; }
    public string DigestAlgorithmOid { get; }
    public string DigestEncryptionAlgorithmOid { get; }
    public X509Certificate[] Certificates { get; }
    public X509Certificate[] SignCertificateChain { get; }
    public X509Certificate SigningCertificate { get; }
    public ICollection`1<X509Crl> CRLs { get; }
    public BasicOcspResp Ocsp { get; }
    public bool IsTsp { get; }
    public TimeStampToken TimeStampToken { get; }
    public DateTime TimeStampDate { get; }
    public PdfPKCS7(ICipherParameters privKey, ICollection`1<X509Certificate> certChain, string hashAlgorithm, bool hasRSAdata);
    public PdfPKCS7(Byte[] contentsKey, Byte[] certsKey);
    public PdfPKCS7(Byte[] contentsKey, PdfName filterSubtype);
    internal IDigest GetHashClass();
    public virtual void SetSignaturePolicy(SignaturePolicyInfo signaturePolicy);
    public virtual void SetSignaturePolicy(SignaturePolicyIdentifier signaturePolicy);
    public virtual string get_SignName();
    public virtual void set_SignName(string value);
    public virtual string get_Reason();
    public virtual void set_Reason(string value);
    public virtual string get_Location();
    public virtual void set_Location(string value);
    public virtual DateTime get_SignDate();
    public virtual void set_SignDate(DateTime value);
    public virtual int get_Version();
    public virtual int get_SigningInfoVersion();
    public virtual string get_DigestAlgorithmOid();
    public virtual string GetHashAlgorithm();
    public virtual string get_DigestEncryptionAlgorithmOid();
    public virtual string GetDigestAlgorithm();
    public virtual void SetExternalDigest(Byte[] digest, Byte[] RSAdata, string digestEncryptionAlgorithm);
    private ISigner InitSignature(ICipherParameters key);
    private ISigner InitSignature(AsymmetricKeyParameter key);
    public virtual void Update(Byte[] buf, int off, int len);
    public virtual Byte[] GetEncodedPKCS1();
    public virtual Byte[] GetEncodedPKCS7();
    public virtual Byte[] GetEncodedPKCS7(Byte[] secondDigest);
    public virtual Byte[] GetEncodedPKCS7(Byte[] secondDigest, ITSAClient tsaClient, Byte[] ocsp, ICollection`1<Byte[]> crlBytes, CryptoStandard sigtype);
    private Asn1EncodableVector BuildUnauthenticatedAttributes(Byte[] timeStampToken);
    public virtual Byte[] getAuthenticatedAttributeBytes(Byte[] secondDigest, Byte[] ocsp, ICollection`1<Byte[]> crlBytes, CryptoStandard sigtype);
    private DerSet GetAuthenticatedAttributeSet(Byte[] secondDigest, Byte[] ocsp, ICollection`1<Byte[]> crlBytes, CryptoStandard sigtype);
    public virtual bool Verify();
    private bool VerifySigAttributes(Byte[] attr);
    public virtual bool VerifyTimestampImprint();
    public virtual X509Certificate[] get_Certificates();
    public virtual X509Certificate[] get_SignCertificateChain();
    public virtual X509Certificate get_SigningCertificate();
    private void CalcSignCertificateChain();
    public virtual ICollection`1<X509Crl> get_CRLs();
    private void FindCRL(Asn1Sequence seq);
    public virtual BasicOcspResp get_Ocsp();
    public virtual bool IsRevocationValid();
    private void FindOcsp(Asn1Sequence seq);
    public virtual bool get_IsTsp();
    public virtual TimeStampToken get_TimeStampToken();
    public virtual DateTime get_TimeStampDate();
    public virtual PdfName GetFilterSubtype();
    public virtual string GetEncryptionAlgorithm();
}
internal class iTextSharp.text.pdf.security.PdfSignatureAppDictionary : PdfDictionary {
    unknown string SignatureCreator {public set; }
    public virtual void set_SignatureCreator(string value);
}
internal class iTextSharp.text.pdf.security.PdfSignatureBuildProperties : PdfDictionary {
    unknown string SignatureCreator {public set; }
    public virtual void set_SignatureCreator(string value);
    private PdfSignatureAppDictionary GetPdfSignatureAppProperty();
}
public class iTextSharp.text.pdf.security.PrivateKeySignature : object {
    private ICipherParameters pk;
    private string hashAlgorithm;
    private string encryptionAlgorithm;
    public PrivateKeySignature(ICipherParameters pk, string hashAlgorithm);
    public virtual Byte[] Sign(Byte[] b);
    public virtual string GetHashAlgorithm();
    public virtual string GetEncryptionAlgorithm();
}
public class iTextSharp.text.pdf.security.RootStoreVerifier : CertificateVerifier {
    private static ILogger LOGGER;
    protected List`1<X509Certificate> certificates;
    unknown List`1<X509Certificate> Certificates {public set; }
    public RootStoreVerifier(CertificateVerifier verifier);
    private static RootStoreVerifier();
    public virtual void set_Certificates(List`1<X509Certificate> value);
    public virtual List`1<VerificationOK> Verify(X509Certificate signCert, X509Certificate issuerCert, DateTime signDate);
}
internal class iTextSharp.text.pdf.security.SecurityConstants : object {
    public static string XMLNS;
    public static string XMLNS_XADES;
    public static string XMLNS_URI;
    public static string XMLDSIG_URI;
    public static string XADES_132_URI;
    public static string XMLDSIG_URI_C14N;
    public static string XMLDSIG_URI_RSA_SHA1;
    public static string XMLDSIG_URI_DSA_SHA1;
    public static string XMLDSIG_URI_ENVELOPED;
    public static string XMLDSIG_URI_XPATH_FILTER2;
    public static string XMLDSIG_URI_SHA1;
    public static string SignedProperties_Type;
    public static string OIDAsURN;
    public static string OID_DSA_SHA1;
    public static string OID_DSA_SHA1_DESC;
    public static string OID_RSA_SHA1;
    public static string OID_RSA_SHA1_DESC;
    public static string DSA;
    public static string RSA;
    public static string SHA1;
    public static string DigestMethod;
    public static string DigestValue;
    public static string Signature;
    public static string SignatureValue;
    public static string X509SerialNumber;
    public static string X509IssuerName;
    public static string Algorithm;
    public static string Id;
    public static string ObjectReference;
    public static string Target;
    public static string Qualifier;
    public static string XADES_Encoding;
    public static string XADES_MimeType;
    public static string XADES_Description;
    public static string XADES_DataObjectFormat;
    public static string XADES_SignedDataObjectProperties;
    public static string XADES_IssuerSerial;
    public static string XADES_CertDigest;
    public static string XADES_Cert;
    public static string XADES_SigningCertificate;
    public static string XADES_SigningTime;
    public static string XADES_SignedSignatureProperties;
    public static string XADES_SignedProperties;
    public static string XADES_QualifyingProperties;
    public static string XADES_SignaturePolicyIdentifier;
    public static string XADES_SignaturePolicyId;
    public static string XADES_SigPolicyId;
    public static string XADES_Identifier;
    public static string XADES_SigPolicyHash;
    public static string Reference_;
    public static string SignedProperties_;
    public static string Signature_;
    public static string SigningTimeFormat;
}
public class iTextSharp.text.pdf.security.SecurityIDs : object {
    public static string ID_PKCS7_DATA;
    public static string ID_PKCS7_SIGNED_DATA;
    public static string ID_RSA;
    public static string ID_DSA;
    public static string ID_ECDSA;
    public static string ID_CONTENT_TYPE;
    public static string ID_MESSAGE_DIGEST;
    public static string ID_SIGNING_TIME;
    public static string ID_ADBE_REVOCATION;
    public static string ID_TSA;
    public static string ID_OCSP;
    public static string ID_AA_SIGNING_CERTIFICATE_V1;
    public static string ID_AA_SIGNING_CERTIFICATE_V2;
}
public class iTextSharp.text.pdf.security.SignaturePermissions : object {
    private bool certification;
    private bool fillInAllowed;
    private bool annotationsAllowed;
    private List`1<FieldLock> fieldLocks;
    public bool Certification { get; }
    public bool FillInAllowed { get; }
    public bool AnnotationsAllowed { get; }
    public List`1<FieldLock> FieldLocks { get; }
    public SignaturePermissions(PdfDictionary sigDict, SignaturePermissions previous);
    public virtual bool get_Certification();
    public virtual bool get_FillInAllowed();
    public virtual bool get_AnnotationsAllowed();
    public virtual List`1<FieldLock> get_FieldLocks();
}
public class iTextSharp.text.pdf.security.SignaturePolicyInfo : object {
    private string policyIdentifier;
    private Byte[] policyHash;
    private string policyDigestAlgorithm;
    private string policyUri;
    public string PolicyIdentifier { get; }
    public Byte[] PolicyHash { get; }
    public string PolicyDigestAlgorithm { get; }
    public string PolicyUri { get; }
    public SignaturePolicyInfo(string policyIdentifier, Byte[] policyHash, string policyDigestAlgorithm, string policyUri);
    public SignaturePolicyInfo(string policyIdentifier, string policyHashBase64, string policyDigestAlgorithm, string policyUri);
    public string get_PolicyIdentifier();
    public Byte[] get_PolicyHash();
    public string get_PolicyDigestAlgorithm();
    public string get_PolicyUri();
    protected internal SignaturePolicyIdentifier ToSignaturePolicyIdentifier();
}
public class iTextSharp.text.pdf.security.TSAClientBouncyCastle : object {
    public static int DEFAULTTOKENSIZE;
    public static string DEFAULTHASHALGORITHM;
    private static ILogger LOGGER;
    protected internal string tsaURL;
    protected internal string tsaUsername;
    protected internal string tsaPassword;
    protected ITSAInfoBouncyCastle tsaInfo;
    protected internal int tokenSizeEstimate;
    protected internal string digestAlgorithm;
    private string tsaReqPolicy;
    public TSAClientBouncyCastle(string url);
    public TSAClientBouncyCastle(string url, string username, string password);
    public TSAClientBouncyCastle(string url, string username, string password, int tokSzEstimate, string digestAlgorithm);
    private static TSAClientBouncyCastle();
    public virtual void SetTSAInfo(ITSAInfoBouncyCastle tsaInfo);
    public virtual string GetTSAReqPolicy();
    public virtual void SetTSAReqPolicy(string tsaReqPolicy);
    public virtual int GetTokenSizeEstimate();
    public virtual IDigest GetMessageDigest();
    public virtual Byte[] GetTimeStampToken(Byte[] imprint);
    protected internal virtual Byte[] GetTSAResponse(Byte[] requestBytes);
}
public class iTextSharp.text.pdf.security.VerificationException : GeneralSecurityException {
    public VerificationException(X509Certificate cert, string message);
}
public class iTextSharp.text.pdf.security.VerificationOK : object {
    protected X509Certificate certificate;
    protected CertificateVerifier verifierClass;
    protected string message;
    public VerificationOK(X509Certificate cert, CertificateVerifier verifierClass, string message);
    public virtual string ToString();
}
public class iTextSharp.text.pdf.security.X509Certificate2Signature : object {
    private X509Certificate2 certificate;
    private string hashAlgorithm;
    private string encryptionAlgorithm;
    public X509Certificate2Signature(X509Certificate2 certificate, string hashAlgorithm);
    public virtual Byte[] Sign(Byte[] message);
    public virtual string GetHashAlgorithm();
    public virtual string GetEncryptionAlgorithm();
}
public class iTextSharp.text.pdf.SequenceList : object {
    protected static int COMMA;
    protected static int MINUS;
    protected static int NOT;
    protected static int TEXT;
    protected static int NUMBER;
    protected static int END;
    protected static char EOT;
    private static int FIRST;
    private static int DIGIT;
    private static int OTHER;
    private static int DIGIT2;
    private static string NOT_OTHER;
    protected Char[] text;
    protected int ptr;
    protected int number;
    protected string other;
    protected int low;
    protected int high;
    protected bool odd;
    protected bool even;
    protected bool inverse;
    protected int Type { get; }
    protected SequenceList(string range);
    protected virtual char NextChar();
    protected virtual void PutBack();
    protected virtual int get_Type();
    private void OtherProc();
    protected virtual bool GetAttributes();
    public static ICollection`1<int> Expand(string ranges, int maxNumber);
}
public class iTextSharp.text.pdf.ShadingColor : ExtendedColor {
    private PdfShadingPattern shadingPattern;
    public PdfShadingPattern PdfShadingPattern { get; }
    public ShadingColor(PdfShadingPattern shadingPattern);
    public virtual PdfShadingPattern get_PdfShadingPattern();
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
}
public class iTextSharp.text.pdf.SimpleBookmark : object {
    private List`1<Dictionary`2<string, object>> topList;
    private Stack`1<Dictionary`2<string, object>> attr;
    private static IList`1<Dictionary`2<string, object>> BookmarkDepth(PdfReader reader, PdfDictionary outline, IntHashtable pages, bool processCurrentOutlineOnly);
    private static void MapGotoBookmark(Dictionary`2<string, object> map, PdfObject dest, IntHashtable pages);
    private static string MakeBookmarkParam(PdfArray dest, IntHashtable pages);
    private static int GetNumber(PdfIndirectReference indirect);
    public static IList`1<Dictionary`2<string, object>> GetBookmark(PdfReader reader);
    public static IList`1<Dictionary`2<string, object>> GetBookmark(PdfReader reader, PdfDictionary outline, bool includeRoot);
    public static void EliminatePages(IList`1<Dictionary`2<string, object>> list, Int32[] pageRange);
    public static void ShiftPageNumbers(IList`1<Dictionary`2<string, object>> list, int pageShift, Int32[] pageRange);
    public static string GetVal(Dictionary`2<string, object> map, string key);
    internal static void CreateOutlineAction(PdfDictionary outline, Dictionary`2<string, object> map, PdfWriter writer, bool namedAsNames);
    public static Object[] IterateOutlines(PdfWriter writer, PdfIndirectReference parent, IList`1<Dictionary`2<string, object>> kids, bool namedAsNames);
    public static void ExportToXMLNode(IList`1<Dictionary`2<string, object>> list, TextWriter outp, int indent, bool onlyASCII);
    public static void ExportToXML(IList`1<Dictionary`2<string, object>> list, Stream outp, string encoding, bool onlyASCII);
    public static void ExportToXML(IList`1<Dictionary`2<string, object>> list, TextWriter wrt, string encoding, bool onlyASCII);
    public static IList`1<Dictionary`2<string, object>> ImportFromXML(Stream inp);
    public static IList`1<Dictionary`2<string, object>> ImportFromXML(TextReader inp);
    public static string EscapeBinaryString(string s);
    public static string UnEscapeBinaryString(string s);
    public sealed virtual void EndDocument();
    public sealed virtual void EndElement(string tag);
    public sealed virtual void StartDocument();
    public sealed virtual void StartElement(string tag, IDictionary`2<string, string> h);
    public sealed virtual void Text(string str);
}
public class iTextSharp.text.pdf.SimpleNamedDestination : object {
    private Dictionary`2<string, string> xmlNames;
    private Dictionary`2<string, string> xmlLast;
    public static Dictionary`2<string, string> GetNamedDestination(PdfReader reader, bool fromNames);
    public static void ExportToXML(Dictionary`2<string, string> names, Stream outp, string encoding, bool onlyASCII);
    public static void ExportToXML(Dictionary`2<string, string> names, TextWriter wrt, string encoding, bool onlyASCII);
    public static Dictionary`2<string, string> ImportFromXML(Stream inp);
    public static Dictionary`2<string, string> ImportFromXML(TextReader inp);
    internal static PdfArray CreateDestinationArray(string value, PdfWriter writer);
    public static PdfDictionary OutputNamedDestinationAsNames(Dictionary`2<string, string> names, PdfWriter writer);
    public static PdfDictionary OutputNamedDestinationAsStrings(Dictionary`2<string, string> names, PdfWriter writer);
    public static string EscapeBinaryString(string s);
    public static string UnEscapeBinaryString(string s);
    public sealed virtual void EndDocument();
    public sealed virtual void EndElement(string tag);
    public sealed virtual void StartDocument();
    public sealed virtual void StartElement(string tag, IDictionary`2<string, string> h);
    public sealed virtual void Text(string str);
}
public class iTextSharp.text.pdf.SpotColor : ExtendedColor {
    private PdfSpotColor spot;
    private float tint;
    public PdfSpotColor PdfSpotColor { get; }
    public float Tint { get; }
    public SpotColor(PdfSpotColor spot, float tint);
    public virtual PdfSpotColor get_PdfSpotColor();
    public virtual float get_Tint();
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
}
public class iTextSharp.text.pdf.StampContent : PdfContentByte {
    internal PageStamp ps;
    internal PageResources pageResources;
    public PdfContentByte Duplicate { get; }
    internal PageResources PageResources { get; }
    protected PdfIndirectReference CurrentPage { get; }
    internal StampContent(PdfStamperImp stamper, PageStamp ps);
    public virtual void SetAction(PdfAction action, float llx, float lly, float urx, float ury);
    public virtual PdfContentByte get_Duplicate();
    internal virtual PageResources get_PageResources();
    internal virtual void AddAnnotation(PdfAnnotation annot);
    protected virtual PdfIndirectReference get_CurrentPage();
}
public class iTextSharp.text.pdf.StringUtils : object {
    private static Byte[] r;
    private static Byte[] n;
    private static Byte[] t;
    private static Byte[] b;
    private static Byte[] f;
    private static StringUtils();
    public static Byte[] EscapeString(Byte[] b);
    public static void EscapeString(Byte[] bytes, ByteBuffer content);
    public static Byte[] ConvertCharsToBytes(Char[] chars);
}
public class iTextSharp.text.pdf.TextField : BaseField {
    private string defaultText;
    private String[] choices;
    private String[] choiceExports;
    private List`1<int> choiceSelections;
    private int topFirst;
    private int visibleTopChoice;
    private float extraMarginLeft;
    private float extraMarginTop;
    private List`1<BaseFont> substitutionFonts;
    private BaseFont extensionFont;
    public string DefaultText { get; public set; }
    public String[] Choices { get; public set; }
    public String[] ChoiceExports { get; public set; }
    public int ChoiceSelection { get; public set; }
    public List`1<int> ChoiceSelections { get; public set; }
    public int VisibleTopChoice { get; public set; }
    internal int TopFirst { get; }
    public List`1<BaseFont> SubstitutionFonts { get; public set; }
    public BaseFont ExtensionFont { get; public set; }
    public TextField(PdfWriter writer, Rectangle box, string fieldName);
    private static bool CheckRTL(string text);
    private static void ChangeFontSize(Phrase p, float size);
    private Phrase ComposePhrase(string text, BaseFont ufont, BaseColor color, float fontSize);
    public static string RemoveCRLF(string text);
    public static string ObfuscatePassword(string text);
    public virtual PdfAppearance GetAppearance();
    internal PdfAppearance GetListAppearance();
    public virtual PdfFormField GetTextField();
    public virtual PdfFormField GetComboField();
    public virtual PdfFormField GetListField();
    private int GetTopChoice();
    protected virtual PdfFormField GetChoiceField(bool isList);
    private void WriteMultipleValues(PdfFormField field, String[0...,0...] mix);
    public virtual string get_DefaultText();
    public virtual void set_DefaultText(string value);
    public virtual String[] get_Choices();
    public virtual void set_Choices(String[] value);
    public virtual String[] get_ChoiceExports();
    public virtual void set_ChoiceExports(String[] value);
    public virtual int get_ChoiceSelection();
    public virtual void set_ChoiceSelection(int value);
    public virtual List`1<int> get_ChoiceSelections();
    public virtual void set_ChoiceSelections(List`1<int> value);
    public virtual int get_VisibleTopChoice();
    public virtual void set_VisibleTopChoice(int value);
    public virtual void AddChoiceSelection(int selection);
    internal int get_TopFirst();
    public virtual void SetExtraMargin(float extraMarginLeft, float extraMarginTop);
    public virtual void set_SubstitutionFonts(List`1<BaseFont> value);
    public virtual List`1<BaseFont> get_SubstitutionFonts();
    public virtual void set_ExtensionFont(BaseFont value);
    public virtual BaseFont get_ExtensionFont();
}
public class iTextSharp.text.pdf.TrueTypeFont : BaseFont {
    internal static String[] codePages;
    protected bool justNames;
    protected Dictionary`2<string, Int32[]> tables;
    protected RandomAccessFileOrArray rf;
    protected string fileName;
    protected bool cff;
    protected int cffOffset;
    protected int cffLength;
    protected int directoryOffset;
    protected string ttcIndex;
    protected string style;
    protected FontHeader head;
    protected HorizontalHeader hhea;
    protected WindowsMetrics os_2;
    protected Int32[] glyphWidthsByIndex;
    protected Int32[][] bboxes;
    protected Dictionary`2<int, Int32[]> cmap10;
    protected Dictionary`2<int, Int32[]> cmap31;
    protected Dictionary`2<int, Int32[]> cmapExt;
    protected Int32[] glyphIdToChar;
    protected int maxGlyphId;
    protected IntHashtable kerning;
    protected string fontName;
    protected String[][] subFamily;
    protected String[][] fullName;
    protected String[][] allNameEntries;
    protected String[][] familyName;
    protected double italicAngle;
    protected bool isFixedPitch;
    protected int underlinePosition;
    protected int underlineThickness;
    public RandomAccessFileOrArray Rf { get; }
    public string FileName { get; }
    public bool Cff { get; }
    public int DirectoryOffset { get; }
    internal string BaseFont { get; }
    public string PostscriptFontName { get; public set; }
    public String[] CodePagesSupported { get; }
    public String[][] FullFontName { get; }
    public string Subfamily { get; }
    public String[][] AllNameEntries { get; }
    public String[][] FamilyFontName { get; }
    public int MaxGlyphId { get; }
    internal TrueTypeFont(string ttFile, string enc, bool emb, Byte[] ttfAfm, bool justNames, bool forceRead);
    private static TrueTypeFont();
    public virtual RandomAccessFileOrArray get_Rf();
    public virtual string get_FileName();
    public virtual bool get_Cff();
    public virtual int get_DirectoryOffset();
    protected static string GetTTCName(string name);
    internal void FillTables();
    internal string get_BaseFont();
    internal String[][] GetNames(int id);
    internal String[][] GetAllNames();
    internal void CheckCff();
    internal void Process(Byte[] ttfAfm, bool preload);
    protected virtual string ReadStandardString(int length);
    protected virtual string ReadUnicodeString(int length);
    protected virtual void ReadGlyphWidths();
    protected internal virtual int GetGlyphWidth(int glyph);
    private void ReadBbox();
    internal void ReadCMaps();
    internal Dictionary`2<int, Int32[]> ReadFormat12();
    internal Dictionary`2<int, Int32[]> ReadFormat0();
    internal Dictionary`2<int, Int32[]> ReadFormat4();
    internal Dictionary`2<int, Int32[]> ReadFormat6();
    internal void ReadKerning();
    public virtual int GetKerning(int char1, int char2);
    internal virtual int GetRawWidth(int c, string name);
    public virtual PdfDictionary GetFontDescriptor(PdfIndirectReference fontStream, string subsetPrefix, PdfIndirectReference cidset);
    protected virtual PdfDictionary GetFontBaseType(PdfIndirectReference fontDescriptor, string subsetPrefix, int firstChar, int lastChar, Byte[] shortTag);
    public virtual Byte[] GetFullFont();
    protected internal virtual Byte[] GetSubSet(HashSet2`1<int> glyphs, bool subsetp);
    protected static Int32[] CompactRanges(List`1<Int32[]> ranges);
    public virtual void AddRangeUni(Dictionary`2<int, Int32[]> longTag, bool includeMetrics, bool subsetp);
    internal virtual void WriteFont(PdfWriter writer, PdfIndirectReference piref, Object[] parms);
    public virtual Byte[] ReadCffFont();
    public virtual PdfStream GetFullFontStream();
    public virtual float GetFontDescriptor(int key, float fontSize);
    public virtual Int32[] GetMetricsTT(int c);
    public virtual string get_PostscriptFontName();
    public virtual void set_PostscriptFontName(string value);
    public virtual String[] get_CodePagesSupported();
    public virtual String[][] get_FullFontName();
    public virtual string get_Subfamily();
    public virtual String[][] get_AllNameEntries();
    public virtual String[][] get_FamilyFontName();
    public virtual bool HasKernPairs();
    public virtual bool SetKerning(int char1, int char2, int kern);
    protected virtual Int32[] GetRawCharBBox(int c, string name);
    internal bool IsWinAnsiSupported();
    public int get_MaxGlyphId();
}
public class iTextSharp.text.pdf.TrueTypeFontSubSet : object {
    internal static String[] tableNamesSimple;
    internal static String[] tableNamesCmap;
    internal static String[] tableNamesExtra;
    internal static Int32[] entrySelectors;
    internal static int TABLE_CHECKSUM;
    internal static int TABLE_OFFSET;
    internal static int TABLE_LENGTH;
    internal static int HEAD_LOCA_FORMAT_OFFSET;
    internal static int ARG_1_AND_2_ARE_WORDS;
    internal static int WE_HAVE_A_SCALE;
    internal static int MORE_COMPONENTS;
    internal static int WE_HAVE_AN_X_AND_Y_SCALE;
    internal static int WE_HAVE_A_TWO_BY_TWO;
    protected Dictionary`2<string, Int32[]> tableDirectory;
    protected RandomAccessFileOrArray rf;
    protected string fileName;
    protected bool includeCmap;
    protected bool includeExtras;
    protected bool locaShortTable;
    protected Int32[] locaTable;
    protected HashSet2`1<int> glyphsUsed;
    protected List`1<int> glyphsInList;
    protected int tableGlyphOffset;
    protected Int32[] newLocaTable;
    protected Byte[] newLocaTableOut;
    protected Byte[] newGlyfTable;
    protected int glyfTableRealSize;
    protected int locaTableRealSize;
    protected Byte[] outFont;
    protected int fontPtr;
    protected int directoryOffset;
    public TrueTypeFontSubSet(string fileName, RandomAccessFileOrArray rf, HashSet2`1<int> glyphsUsed, int directoryOffset, bool includeCmap, bool includeExtras);
    private static TrueTypeFontSubSet();
    public virtual Byte[] Process();
    protected virtual void AssembleFont();
    protected virtual void CreateTableDirectory();
    protected virtual void ReadLoca();
    protected virtual void CreateNewGlyphTables();
    protected virtual void LocaTobytes();
    protected virtual void FlatGlyphs();
    protected virtual void CheckGlyphComposite(int glyph);
    protected virtual string ReadStandardString(int length);
    protected virtual void WriteFontShort(int n);
    protected virtual void WriteFontInt(int n);
    protected virtual void WriteFontString(string s);
    protected virtual int CalculateChecksum(Byte[] b);
}
public class iTextSharp.text.pdf.TrueTypeFontUnicode : TrueTypeFont {
    private static Byte[] rotbits;
    internal TrueTypeFontUnicode(string ttFile, string enc, bool emb, Byte[] ttfAfm, bool forceRead);
    private static TrueTypeFontUnicode();
    public virtual int GetWidth(int char1);
    public virtual int GetWidth(string text);
    public virtual PdfStream GetToUnicode(Object[] metrics);
    internal static string ToHex(int n);
    public virtual PdfDictionary GetCIDFontType2(PdfIndirectReference fontDescriptor, string subsetPrefix, Object[] metrics);
    public virtual PdfDictionary GetFontBaseType(PdfIndirectReference descendant, string subsetPrefix, PdfIndirectReference toUnicode);
    public virtual int GetCharFromGlyphId(int gid);
    public virtual int Compare(Int32[] o1, Int32[] o2);
    internal virtual void WriteFont(PdfWriter writer, PdfIndirectReference piref, Object[] parms);
    public virtual PdfStream GetFullFontStream();
    public virtual Byte[] ConvertToBytes(string text);
    internal virtual Byte[] ConvertToBytes(int char1);
    public virtual Int32[] GetMetricsTT(int c);
    public virtual bool CharExists(int c);
    public virtual bool SetCharAdvance(int c, int advance);
    public virtual Int32[] GetCharBBox(int c);
}
public class iTextSharp.text.pdf.TtfUnicodeWriter : object {
    protected PdfWriter writer;
    public TtfUnicodeWriter(PdfWriter writer);
    protected internal virtual void WriteFont(TrueTypeFontUnicode font, PdfIndirectReference refer, Object[] parms, Byte[] rotbits);
}
internal class iTextSharp.text.pdf.Type1Font : BaseFont {
    private object lockObject;
    protected Byte[] pfb;
    private string FontName;
    private string FullName;
    private string FamilyName;
    private string Weight;
    private float ItalicAngle;
    private bool IsFixedPitch;
    private string CharacterSet;
    private int llx;
    private int lly;
    private int urx;
    private int ury;
    private int UnderlinePosition;
    private int UnderlineThickness;
    private string EncodingScheme;
    private int CapHeight;
    private int XHeight;
    private int Ascender;
    private int Descender;
    private int StdHW;
    private int StdVW;
    private Dictionary`2<object, Object[]> CharMetrics;
    private Dictionary`2<string, Object[]> KernPairs;
    private string fileName;
    private bool builtinFont;
    private static Int32[] PFB_TYPES;
    public string PostscriptFontName { get; public set; }
    public String[][] FullFontName { get; }
    public String[][] AllNameEntries { get; }
    public String[][] FamilyFontName { get; }
    internal Type1Font(string afmFile, string enc, bool emb, Byte[] ttfAfm, Byte[] pfb, bool forceRead);
    private static Type1Font();
    internal virtual int GetRawWidth(int c, string name);
    public virtual int GetKerning(int char1, int char2);
    public virtual void Process(RandomAccessFileOrArray rf);
    public virtual PdfStream GetFullFontStream();
    public virtual PdfDictionary GetFontDescriptor(PdfIndirectReference fontStream);
    private PdfDictionary GetFontBaseType(PdfIndirectReference fontDescriptor, int firstChar, int lastChar, Byte[] shortTag);
    internal virtual void WriteFont(PdfWriter writer, PdfIndirectReference piref, Object[] parms);
    public virtual float GetFontDescriptor(int key, float fontSize);
    public virtual void SetFontDescriptor(int key, float value);
    public virtual string get_PostscriptFontName();
    public virtual void set_PostscriptFontName(string value);
    public virtual String[][] get_FullFontName();
    public virtual String[][] get_AllNameEntries();
    public virtual String[][] get_FamilyFontName();
    public virtual bool HasKernPairs();
    public virtual bool SetKerning(int char1, int char2, int kern);
    protected virtual Int32[] GetRawCharBBox(int c, string name);
}
public class iTextSharp.text.pdf.Type3Font : BaseFont {
    private Boolean[] usedSlot;
    private IntHashtable widths3;
    private Dictionary`2<char, Type3Glyph> char2glyph;
    private PdfWriter writer;
    private float llx;
    private float lly;
    private float urx;
    private float ury;
    private PageResources pageResources;
    private bool colorized;
    public String[][] FamilyFontName { get; }
    public String[][] FullFontName { get; }
    public String[][] AllNameEntries { get; }
    public string PostscriptFontName { get; public set; }
    public Type3Font(PdfWriter writer, Char[] chars, bool colorized);
    public Type3Font(PdfWriter writer, bool colorized);
    public virtual PdfContentByte DefineGlyph(char c, float wx, float llx, float lly, float urx, float ury);
    public virtual String[][] get_FamilyFontName();
    public virtual float GetFontDescriptor(int key, float fontSize);
    public virtual String[][] get_FullFontName();
    public virtual String[][] get_AllNameEntries();
    public virtual int GetKerning(int char1, int char2);
    public virtual string get_PostscriptFontName();
    public virtual void set_PostscriptFontName(string value);
    protected virtual Int32[] GetRawCharBBox(int c, string name);
    internal virtual int GetRawWidth(int c, string name);
    public virtual bool HasKernPairs();
    public virtual bool SetKerning(int char1, int char2, int kern);
    internal virtual void WriteFont(PdfWriter writer, PdfIndirectReference piRef, Object[] oParams);
    public virtual PdfStream GetFullFontStream();
    public virtual Byte[] ConvertToBytes(string text);
    internal virtual Byte[] ConvertToBytes(int char1);
    public virtual int GetWidth(int char1);
    public virtual int GetWidth(string text);
    public virtual Int32[] GetCharBBox(int c);
    public virtual bool CharExists(int c);
    public virtual bool SetCharAdvance(int c, int advance);
}
public class iTextSharp.text.pdf.Type3Glyph : PdfContentByte {
    private PageResources pageResources;
    private bool colorized;
    internal PageResources PageResources { get; }
    internal Type3Glyph(PdfWriter writer, PageResources pageResources, float wx, float llx, float lly, float urx, float ury, bool colorized);
    internal virtual PageResources get_PageResources();
    public virtual void AddImage(Image image, float a, float b, float c, float d, float e, float f, bool inlineImage);
    public PdfContentByte GetDuplicate();
}
public class iTextSharp.text.pdf.VerticalText : object {
    public static int NO_MORE_TEXT;
    public static int NO_MORE_COLUMN;
    protected List`1<PdfChunk> chunks;
    protected PdfContentByte text;
    protected int alignment;
    protected int currentChunkMarker;
    protected PdfChunk currentStandbyChunk;
    protected string splittedChunkText;
    protected float leading;
    protected float startX;
    protected float startY;
    protected int maxLines;
    protected float height;
    private float curCharSpace;
    public float Leading { get; public set; }
    public float OriginX { get; }
    public float OriginY { get; }
    public int MaxLines { get; public set; }
    public float Height { get; public set; }
    public int Alignment { get; public set; }
    public VerticalText(PdfContentByte text);
    private static VerticalText();
    public virtual void AddText(Phrase phrase);
    public virtual void AddText(Chunk chunk);
    public virtual void SetVerticalLayout(float startX, float startY, float height, int maxLines, float leading);
    public virtual float get_Leading();
    public virtual void set_Leading(float value);
    protected virtual PdfLine CreateLine(float width);
    protected virtual void ShortenChunkArray();
    public virtual int Go();
    public virtual int Go(bool simulate);
    internal void WriteLine(PdfLine line, PdfContentByte text, PdfContentByte graphics);
    public virtual void SetOrigin(float startX, float startY);
    public virtual float get_OriginX();
    public virtual float get_OriginY();
    public virtual int get_MaxLines();
    public virtual void set_MaxLines(int value);
    public virtual float get_Height();
    public virtual void set_Height(float value);
    public virtual int get_Alignment();
    public virtual void set_Alignment(int value);
}
public class iTextSharp.text.pdf.XfaForm : object {
    public static string XFA_DATA_SCHEMA;
    private Xml2SomTemplate templateSom;
    private XmlNode templateNode;
    private Xml2SomDatasets datasetsSom;
    private AcroFieldsSearch acroFieldsSom;
    private PdfReader reader;
    private bool xfaPresent;
    private XmlDocument domDocument;
    private bool changed;
    private XmlNode datasetsNode;
    public bool XfaPresent { get; public set; }
    public XmlDocument DomDocument { get; public set; }
    public PdfReader Reader { get; public set; }
    public bool Changed { get; public set; }
    public Xml2SomTemplate TemplateSom { get; public set; }
    public Xml2SomDatasets DatasetsSom { get; public set; }
    public AcroFieldsSearch AcroFieldsSom { get; public set; }
    public XmlNode DatasetsNode { get; }
    public XfaForm(PdfReader reader);
    public static PdfObject GetXfaObject(PdfReader reader);
    private void ExtractNodes();
    private XmlNode FindDataNode(XmlNode datasetsNode);
    public static Dictionary`2<string, XmlNode> ExtractXFANodes(XmlDocument domDocument);
    private void CreateDatasetsNode(XmlNode n);
    public static void SetXfa(XfaForm form, PdfReader reader, PdfWriter writer);
    public virtual void SetXfa(PdfWriter writer);
    public static Byte[] SerializeDoc(XmlNode n);
    public virtual bool get_XfaPresent();
    public virtual void set_XfaPresent(bool value);
    public virtual XmlDocument get_DomDocument();
    public virtual void set_DomDocument(XmlDocument value);
    public virtual string FindFieldName(string name, AcroFields af);
    public virtual string FindDatasetsName(string name);
    public virtual XmlNode FindDatasetsNode(string name);
    public static string GetNodeText(XmlNode n);
    private static string GetNodeText(XmlNode n, string name);
    public virtual void SetNodeText(XmlNode n, string text);
    public virtual void set_Reader(PdfReader value);
    public virtual PdfReader get_Reader();
    public virtual bool get_Changed();
    public virtual void set_Changed(bool value);
    public virtual Xml2SomTemplate get_TemplateSom();
    public virtual void set_TemplateSom(Xml2SomTemplate value);
    public virtual Xml2SomDatasets get_DatasetsSom();
    public virtual void set_DatasetsSom(Xml2SomDatasets value);
    public virtual AcroFieldsSearch get_AcroFieldsSom();
    public virtual void set_AcroFieldsSom(AcroFieldsSearch value);
    public virtual XmlNode get_DatasetsNode();
    public virtual void FillXfaForm(string file);
    public virtual void FillXfaForm(Stream stream);
    public virtual void FillXfaForm(Stream stream, bool readOnly);
    public virtual void FillXfaForm(XmlReader reader);
    public virtual void FillXfaForm(XmlReader reader, bool readOnly);
    public virtual void FillXfaForm(XmlNode node);
    public virtual void FillXfaForm(XmlNode node, bool readOnly);
    private XmlNode GetFirstElementNode(XmlNode src);
}
public class iTextSharp.text.pdf.XfaXmlLocator : object {
    private PdfStamper stamper;
    private XfaForm xfaForm;
    private string encoding;
    public XfaXmlLocator(PdfStamper stamper);
    protected virtual void CreateXfaForm();
    public virtual XmlDocument GetDocument();
    public virtual void SetDocument(XmlDocument document);
    public virtual string GetEncoding();
    public virtual void SetEncoding(string encoding);
}
public class iTextSharp.text.pdf.XfaXpathConstructor : object {
    private static string CONFIG;
    private static string CONNECTIONSET;
    private static string DATASETS;
    private static string LOCALESET;
    private static string PDF;
    private static string SOURCESET;
    private static string STYLESHEET;
    private static string TEMPLATE;
    private static string XDC;
    private static string XFDF;
    private static string XMPMETA;
    private string xpathExpression;
    private XmlNamespaceManager namespaceManager;
    public XfaXpathConstructor(XdpPackage xdpPackage);
    public virtual string GetXpathExpression();
    public virtual XmlNamespaceManager GetNamespaceManager();
}
public class iTextSharp.text.pdf.XfdfReader : object {
    private bool foundRoot;
    private Stackr fieldNames;
    private Stackr fieldValues;
    internal Dictionary`2<string, string> fields;
    protected Dictionary`2<string, List`1<string>> listFields;
    internal string fileSpec;
    public Dictionary`2<string, string> Fields { get; }
    public string FileSpec { get; }
    public XfdfReader(string filename);
    public XfdfReader(Byte[] xfdfIn);
    public XfdfReader(Stream isp);
    public virtual Dictionary`2<string, string> get_Fields();
    public virtual string GetField(string name);
    public virtual string GetFieldValue(string name);
    public virtual List`1<string> GetListValues(string name);
    public virtual string get_FileSpec();
    public virtual void StartElement(string tag, IDictionary`2<string, string> h);
    public virtual void EndElement(string tag);
    public virtual void StartDocument();
    public virtual void EndDocument();
    public virtual void Text(string str);
}
public class iTextSharp.text.pdf.XmlSignatureAppearance : object {
    private PdfStamperImp writer;
    private PdfStamper stamper;
    private X509Certificate signCertificate;
    private IXmlLocator xmlLocator;
    private IXpathConstructor xpathConstructor;
    private DateTime signDate;
    private string description;
    private string mimeType;
    internal XmlSignatureAppearance(PdfStamperImp writer);
    public virtual PdfStamperImp GetWriter();
    public virtual PdfStamper GetStamper();
    public virtual void SetStamper(PdfStamper stamper);
    public virtual void SetCertificate(X509Certificate signCertificate);
    public virtual X509Certificate GetCertificate();
    public virtual void SetDescription(string description);
    public virtual string GetDescription();
    public virtual string GetMimeType();
    public virtual void SetMimeType(string mimeType);
    public virtual DateTime GetSignDate();
    public virtual void SetSignDate(DateTime signDate);
    public virtual IXmlLocator GetXmlLocator();
    public virtual void SetXmlLocator(IXmlLocator xmlLocator);
    public virtual IXpathConstructor GetXpathConstructor();
    public virtual void SetXpathConstructor(IXpathConstructor xpathConstructor);
    public virtual void Close();
}
public class iTextSharp.text.Phrase : List`1<IElement> {
    protected float leading;
    protected float multipliedLeading;
    protected Font font;
    protected IHyphenationEvent hyphenation;
    protected TabSettings tabSettings;
    public int Type { get; }
    public IList`1<Chunk> Chunks { get; }
    public float MultipliedLeading { get; public set; }
    public float Leading { get; public set; }
    public float TotalLeading { get; }
    public Font Font { get; public set; }
    public string Content { get; }
    public IHyphenationEvent Hyphenation { get; public set; }
    public TabSettings TabSettings { get; public set; }
    public Phrase(Phrase phrase);
    public Phrase(float leading);
    public Phrase(Chunk chunk);
    public Phrase(float leading, Chunk chunk);
    public Phrase(string str);
    public Phrase(string str, Font font);
    public Phrase(float leading, string str);
    public Phrase(float leading, string str, Font font);
    private Phrase(bool dummy);
    public virtual bool Process(IElementListener listener);
    public virtual int get_Type();
    public virtual IList`1<Chunk> get_Chunks();
    public virtual bool IsContent();
    public virtual bool IsNestable();
    public virtual void Add(int index, IElement element);
    public virtual bool Add(string s);
    public virtual bool Add(IElement element);
    public virtual bool AddAll(ICollection`1<T> collection);
    protected virtual bool AddChunk(Chunk chunk);
    public virtual void AddSpecial(IElement obj);
    public virtual bool IsEmpty();
    public virtual bool HasLeading();
    public virtual void SetLeading(float fixedLeading, float multipliedLeading);
    public virtual float get_MultipliedLeading();
    public virtual void set_MultipliedLeading(float value);
    public virtual float get_Leading();
    public virtual void set_Leading(float value);
    public virtual float get_TotalLeading();
    public virtual Font get_Font();
    public virtual void set_Font(Font value);
    public virtual string get_Content();
    public virtual void set_Hyphenation(IHyphenationEvent value);
    public virtual IHyphenationEvent get_Hyphenation();
    public virtual TabSettings get_TabSettings();
    public virtual void set_TabSettings(TabSettings value);
    public static Phrase GetInstance(string str);
    public static Phrase GetInstance(int leading, string str);
    public static Phrase GetInstance(int leading, string str, Font font);
    public virtual bool Trim();
}
public class iTextSharp.text.Rectangle : Element {
    public static int UNDEFINED;
    public static int TOP_BORDER;
    public static int BOTTOM_BORDER;
    public static int LEFT_BORDER;
    public static int RIGHT_BORDER;
    public static int NO_BORDER;
    public static int BOX;
    protected float llx;
    protected float lly;
    protected float urx;
    protected float ury;
    protected int border;
    protected float borderWidth;
    protected BaseColor borderColor;
    protected BaseColor borderColorLeft;
    protected BaseColor borderColorRight;
    protected BaseColor borderColorTop;
    protected BaseColor borderColorBottom;
    protected float borderWidthLeft;
    protected float borderWidthRight;
    protected float borderWidthTop;
    protected float borderWidthBottom;
    protected bool useVariableBorders;
    protected BaseColor backgroundColor;
    protected int rotation;
    public int Type { get; }
    public IList`1<Chunk> Chunks { get; }
    public float Top { get; public set; }
    public int Border { get; public set; }
    public float GrayFill { get; public set; }
    public float Left { get; public set; }
    public float Right { get; public set; }
    public float Bottom { get; public set; }
    public BaseColor BorderColorBottom { get; public set; }
    public BaseColor BorderColorTop { get; public set; }
    public BaseColor BorderColorLeft { get; public set; }
    public BaseColor BorderColorRight { get; public set; }
    public float Width { get; public set; }
    public float Height { get; }
    public float BorderWidth { get; public set; }
    public BaseColor BorderColor { get; public set; }
    public BaseColor BackgroundColor { get; public set; }
    public int Rotation { get; public set; }
    public float BorderWidthLeft { get; public set; }
    public float BorderWidthRight { get; public set; }
    public float BorderWidthTop { get; public set; }
    public float BorderWidthBottom { get; public set; }
    public bool UseVariableBorders { get; public set; }
    public Rectangle(float llx, float lly, float urx, float ury);
    public Rectangle(float llx, float lly, float urx, float ury, int rotation);
    public Rectangle(float urx, float ury);
    public Rectangle(float urx, float ury, int rotation);
    public Rectangle(Rectangle rect);
    public Rectangle(RectangleJ rect);
    public virtual void CloneNonPositionParameters(Rectangle rect);
    public virtual void SoftCloneNonPositionParameters(Rectangle rect);
    public virtual bool Process(IElementListener listener);
    public virtual int get_Type();
    public virtual IList`1<Chunk> get_Chunks();
    public virtual bool IsContent();
    public virtual bool IsNestable();
    public virtual void Normalize();
    public virtual Rectangle GetRectangle(float top, float bottom);
    public virtual Rectangle Rotate();
    public virtual float get_Top();
    public virtual void set_Top(float value);
    public virtual void EnableBorderSide(int side);
    public virtual void DisableBorderSide(int side);
    public virtual int get_Border();
    public virtual void set_Border(int value);
    public virtual float get_GrayFill();
    public virtual void set_GrayFill(float value);
    public virtual float get_Left();
    public virtual void set_Left(float value);
    public virtual float get_Right();
    public virtual void set_Right(float value);
    public virtual float get_Bottom();
    public virtual void set_Bottom(float value);
    public virtual BaseColor get_BorderColorBottom();
    public virtual void set_BorderColorBottom(BaseColor value);
    public virtual BaseColor get_BorderColorTop();
    public virtual void set_BorderColorTop(BaseColor value);
    public virtual BaseColor get_BorderColorLeft();
    public virtual void set_BorderColorLeft(BaseColor value);
    public virtual BaseColor get_BorderColorRight();
    public virtual void set_BorderColorRight(BaseColor value);
    public virtual float GetLeft(float margin);
    public virtual float GetRight(float margin);
    public virtual float GetTop(float margin);
    public virtual float GetBottom(float margin);
    public virtual float get_Width();
    public virtual void set_Width(float value);
    public virtual float get_Height();
    public virtual bool HasBorders();
    public virtual bool HasBorder(int type);
    public virtual float get_BorderWidth();
    public virtual void set_BorderWidth(float value);
    public virtual BaseColor get_BorderColor();
    public virtual void set_BorderColor(BaseColor value);
    public virtual BaseColor get_BackgroundColor();
    public virtual void set_BackgroundColor(BaseColor value);
    public virtual int get_Rotation();
    public virtual void set_Rotation(int value);
    public virtual float get_BorderWidthLeft();
    public virtual void set_BorderWidthLeft(float value);
    public virtual float get_BorderWidthRight();
    public virtual void set_BorderWidthRight(float value);
    public virtual float get_BorderWidthTop();
    public virtual void set_BorderWidthTop(float value);
    public virtual float get_BorderWidthBottom();
    public virtual void set_BorderWidthBottom(float value);
    private void UpdateBorderBasedOnWidth(float width, int side);
    private float GetVariableBorderWidth(float variableWidthValue, int side);
    public virtual bool get_UseVariableBorders();
    public virtual void set_UseVariableBorders(bool value);
    public virtual string ToString();
    public virtual bool Equals(object obj);
}
public class iTextSharp.text.RectangleReadOnly : Rectangle {
    unknown float Top {public set; }
    unknown int Border {public set; }
    unknown float GrayFill {public set; }
    unknown float Left {public set; }
    unknown float Right {public set; }
    unknown float Bottom {public set; }
    unknown BaseColor BorderColorBottom {public set; }
    unknown BaseColor BorderColorTop {public set; }
    unknown BaseColor BorderColorLeft {public set; }
    unknown BaseColor BorderColorRight {public set; }
    unknown float BorderWidth {public set; }
    unknown BaseColor BorderColor {public set; }
    unknown BaseColor BackgroundColor {public set; }
    unknown int Rotation {public set; }
    unknown float BorderWidthLeft {public set; }
    unknown float BorderWidthRight {public set; }
    unknown float BorderWidthTop {public set; }
    unknown float BorderWidthBottom {public set; }
    unknown bool UseVariableBorders {public set; }
    public RectangleReadOnly(float llx, float lly, float urx, float ury);
    public RectangleReadOnly(float llx, float lly, float urx, float ury, int rotation);
    public RectangleReadOnly(float urx, float ury);
    public RectangleReadOnly(float urx, float ury, int rotation);
    public RectangleReadOnly(Rectangle rect);
    public virtual void CloneNonPositionParameters(Rectangle rect);
    private void ThrowReadOnlyError();
    public virtual void SoftCloneNonPositionParameters(Rectangle rect);
    public virtual void Normalize();
    public virtual void set_Top(float value);
    public virtual void EnableBorderSide(int side);
    public virtual void DisableBorderSide(int side);
    public virtual void set_Border(int value);
    public virtual void set_GrayFill(float value);
    public virtual void set_Left(float value);
    public virtual void set_Right(float value);
    public virtual void set_Bottom(float value);
    public virtual void set_BorderColorBottom(BaseColor value);
    public virtual void set_BorderColorTop(BaseColor value);
    public virtual void set_BorderColorLeft(BaseColor value);
    public virtual void set_BorderColorRight(BaseColor value);
    public virtual void set_BorderWidth(float value);
    public virtual void set_BorderColor(BaseColor value);
    public virtual void set_BackgroundColor(BaseColor value);
    public virtual void set_Rotation(int value);
    public virtual void set_BorderWidthLeft(float value);
    public virtual void set_BorderWidthRight(float value);
    public virtual void set_BorderWidthTop(float value);
    public virtual void set_BorderWidthBottom(float value);
    public virtual void set_UseVariableBorders(bool value);
    public virtual string ToString();
}
public class iTextSharp.text.RomanList : List {
    public RomanList(int symbolIndent);
    public RomanList(bool romanlower, int symbolIndent);
    public virtual bool Add(IElement o);
    public virtual List CloneShallow();
}
public class iTextSharp.text.Section : List`1<IElement> {
    public static int NUMBERSTYLE_DOTTED;
    public static int NUMBERSTYLE_DOTTED_WITHOUT_FINAL_DOT;
    protected Paragraph title;
    protected int numberDepth;
    protected int numberStyle;
    protected float indentationLeft;
    protected float indentationRight;
    protected float indentation;
    protected int subsections;
    protected internal List`1<int> numbers;
    protected bool complete;
    protected bool addedCompletely;
    protected bool notAddedYet;
    protected bool bookmarkOpen;
    protected bool triggerNewPage;
    protected string bookmarkTitle;
    public int Type { get; }
    public IList`1<Chunk> Chunks { get; }
    public Paragraph Title { get; public set; }
    public int NumberStyle { get; public set; }
    public int NumberDepth { get; public set; }
    public float IndentationLeft { get; public set; }
    public float IndentationRight { get; public set; }
    public float Indentation { get; public set; }
    public int Depth { get; }
    public bool BookmarkOpen { get; public set; }
    unknown string BookmarkTitle {public set; }
    public bool TriggerNewPage { get; public set; }
    public bool NotAddedYet { get; public set; }
    protected bool AddedCompletely { get; protected set; }
    public bool ElementComplete { get; public set; }
    public PdfName Role { get; public set; }
    public AccessibleElementId ID { get; public set; }
    public bool IsInline { get; }
    protected internal Section(Paragraph title, int numberDepth);
    private void SetNumbers(int number, List`1<int> numbers);
    public virtual bool Process(IElementListener listener);
    public virtual int get_Type();
    public virtual IList`1<Chunk> get_Chunks();
    public virtual bool IsContent();
    public virtual bool IsNestable();
    public virtual void Add(int index, IElement element);
    public sealed virtual bool Add(IElement element);
    public virtual bool AddAll(ICollection`1<T> collection);
    public virtual Section AddSection(float indentation, Paragraph title, int numberDepth);
    public virtual Section AddSection(float indentation, Paragraph title);
    public virtual Section AddSection(Paragraph title, int numberDepth);
    public virtual MarkedSection AddMarkedSection();
    public virtual Section AddSection(Paragraph title);
    public virtual Section AddSection(float indentation, string title, int numberDepth);
    public virtual Section AddSection(string title, int numberDepth);
    public virtual Section AddSection(float indentation, string title);
    public virtual Section AddSection(string title);
    public virtual Paragraph get_Title();
    public virtual void set_Title(Paragraph value);
    public virtual void set_NumberStyle(int value);
    public virtual int get_NumberStyle();
    public static Paragraph ConstructTitle(Paragraph title, List`1<int> numbers, int numberDepth, int numberStyle);
    public virtual bool IsChapter();
    public virtual bool IsSection();
    public virtual int get_NumberDepth();
    public virtual void set_NumberDepth(int value);
    public virtual float get_IndentationLeft();
    public virtual void set_IndentationLeft(float value);
    public virtual float get_IndentationRight();
    public virtual void set_IndentationRight(float value);
    public virtual float get_Indentation();
    public virtual void set_Indentation(float value);
    public virtual int get_Depth();
    public virtual bool get_BookmarkOpen();
    public virtual void set_BookmarkOpen(bool value);
    public virtual Paragraph GetBookmarkTitle();
    public virtual void set_BookmarkTitle(string value);
    public virtual string ToString();
    public virtual bool get_TriggerNewPage();
    public virtual void set_TriggerNewPage(bool value);
    public virtual void SetChapterNumber(int number);
    public virtual bool get_NotAddedYet();
    public virtual void set_NotAddedYet(bool value);
    protected virtual bool get_AddedCompletely();
    protected virtual void set_AddedCompletely(bool value);
    public virtual void FlushContent();
    public virtual bool get_ElementComplete();
    public virtual void set_ElementComplete(bool value);
    public virtual void NewPage();
    public virtual PdfObject GetAccessibleAttribute(PdfName key);
    public virtual void SetAccessibleAttribute(PdfName key, PdfObject value);
    public virtual Dictionary`2<PdfName, PdfObject> GetAccessibleAttributes();
    public virtual PdfName get_Role();
    public virtual void set_Role(PdfName value);
    public virtual AccessibleElementId get_ID();
    public virtual void set_ID(AccessibleElementId value);
    public virtual bool get_IsInline();
}
public class iTextSharp.text.SpecialSymbol : object {
    public static int Index(string str);
    public static Chunk Get(char c, Font font);
    public static char GetCorrespondingSymbol(char c);
}
public class iTextSharp.text.TabSettings : object {
    public static float DEFAULT_TAB_INTERVAL;
    private List`1<TabStop> tabStops;
    private float tabInterval;
    public List`1<TabStop> TabStops { get; public set; }
    public float TabInterval { get; public set; }
    public TabSettings(List`1<TabStop> tabStops);
    public TabSettings(float tabInterval);
    public TabSettings(List`1<TabStop> tabStops, float tabInterval);
    public static TabStop getTabStopNewInstance(float currentPosition, TabSettings tabSettings);
    public virtual List`1<TabStop> get_TabStops();
    public virtual void set_TabStops(List`1<TabStop> value);
    public virtual float get_TabInterval();
    public virtual void set_TabInterval(float value);
    public virtual TabStop GetTabStopNewInstance(float currentPosition);
}
public class iTextSharp.text.TabSplitCharacter : object {
    public static ISplitCharacter TAB;
    private static TabSplitCharacter();
    public virtual bool IsSplitCharacter(int start, int current, int end, Char[] cc, PdfChunk[] ck);
}
public class iTextSharp.text.TabStop : object {
    protected float position;
    protected Alignment alignment;
    protected IDrawInterface leader;
    protected char anchorChar;
    public float Position { get; public set; }
    public Alignment Align { get; public set; }
    public IDrawInterface Leader { get; public set; }
    public char AnchorChar { get; public set; }
    public TabStop(float position);
    public TabStop(float position, IDrawInterface leader);
    public TabStop(float position, Alignment alignment);
    public TabStop(float position, Alignment alignment, char anchorChar);
    public TabStop(float position, IDrawInterface leader, Alignment alignment);
    public TabStop(float position, IDrawInterface leader, Alignment alignment, char anchorChar);
    public TabStop(TabStop tabStop);
    public static TabStop NewInstance(float currentPosition, float tabInterval);
    public virtual float get_Position();
    public virtual void set_Position(float value);
    public virtual Alignment get_Align();
    public virtual void set_Align(Alignment value);
    public virtual IDrawInterface get_Leader();
    public virtual void set_Leader(IDrawInterface value);
    public virtual char get_AnchorChar();
    public virtual void set_AnchorChar(char value);
    public virtual float GetPosition(float tabPosition, float currentPosition, float anchorPosition);
}
public class iTextSharp.text.Utilities : object {
    private static Byte[] skipBuffer;
    private static Utilities();
    public static ICollection`1<K> GetKeySet(Dictionary`2<K, V> table);
    public static Object[][] AddToArray(Object[][] original, Object[] item);
    public static bool CheckTrueOrFalse(Properties attributes, string key);
    public static Uri ToURL(string filename);
    public static string UnEscapeURL(string src);
    public static void Skip(Stream istr, int size);
    public static float MillimetersToPoints(float value);
    public static float MillimetersToInches(float value);
    public static float PointsToMillimeters(float value);
    public static float PointsToInches(float value);
    public static float InchesToMillimeters(float value);
    public static float InchesToPoints(float value);
    public static bool IsSurrogateHigh(char c);
    public static bool IsSurrogateLow(char c);
    public static bool IsSurrogatePair(string text, int idx);
    public static bool IsSurrogatePair(Char[] text, int idx);
    public static int ConvertToUtf32(char highSurrogate, char lowSurrogate);
    public static int ConvertToUtf32(Char[] text, int idx);
    public static int ConvertToUtf32(string text, int idx);
    public static string ConvertFromUtf32(int codePoint);
    public static string ReadFileToString(string path);
    public static string ConvertToHex(Byte[] bytes);
    public static float ComputeTabSpace(float lx, float rx, float tab);
    public static float ComputeTabSpace(float width, float tab);
    public static float Max(Single[] array);
    public static float Min(Single[] array);
}
public class iTextSharp.text.Version : object {
    private static string iText;
    private static string release;
    private static object staticLock;
    public static string AGPL;
    private static Version modreq(System.Runtime.CompilerServices.IsVolatile) version;
    private string iTextVersion;
    private string key;
    public string Product { get; }
    public string Release { get; }
    public string GetVersion { get; }
    public string Key { get; }
    public static bool IsAGPLVersion { get; }
    private static Version();
    private static Type GetLicenseKeyClass();
    public static Version GetInstance();
    private static bool DependsOnTheOldLicense();
    public string get_Product();
    public string get_Release();
    public string get_GetVersion();
    public string get_Key();
    public static bool get_IsAGPLVersion();
    private static Version AtomicSetVersion(Version newVersion);
}
public abstract class iTextSharp.text.WritableDirectElement : object {
    public static int DIRECT_ELEMENT_TYPE_UNKNOWN;
    public static int DIRECT_ELEMENT_TYPE_HEADER;
    protected int directElementType;
    public int DirectElemenType { get; }
    public int Type { get; }
    public IList`1<Chunk> Chunks { get; }
    public WritableDirectElement(int directElementType);
    private static WritableDirectElement();
    public int get_DirectElemenType();
    public virtual bool Process(IElementListener listener);
    public virtual int get_Type();
    public virtual bool IsContent();
    public virtual bool IsNestable();
    public virtual IList`1<Chunk> get_Chunks();
    public abstract virtual void Write(PdfWriter writer, Document doc);
}
public abstract class iTextSharp.text.xml.ParserBase : object {
    public virtual void Parse(XmlDocument xDoc);
    public virtual void Parse(XmlTextReader reader);
    public virtual void Parse(string url);
    public abstract virtual void StartElement(string uri, string lname, string name, Hashtable attrs);
    public abstract virtual void EndElement(string uri, string lname, string name);
    public abstract virtual void Characters(string content, int start, int length);
}
public class iTextSharp.text.xml.simpleparser.EntitiesToSymbol : object {
    private static Dictionary`2<string, char> map;
    private static EntitiesToSymbol();
    public static Chunk Get(string e, Font font);
    public static char GetCorrespondingSymbol(string name);
}
public class iTextSharp.text.xml.simpleparser.EntitiesToUnicode : object {
    private static Dictionary`2<string, char> map;
    private static EntitiesToUnicode();
    public static char DecodeEntity(string name);
    public static string DecodeString(string s);
}
public class iTextSharp.text.xml.simpleparser.handler.HTMLNewLineHandler : object {
    private Dictionary`2<string, object> newLineTags;
    public virtual bool IsNewLineTag(string tag);
}
public class iTextSharp.text.xml.simpleparser.handler.NeverNewLineHandler : object {
    public virtual bool IsNewLineTag(string tag);
}
public class iTextSharp.text.xml.simpleparser.IanaEncodings : object {
    private static Dictionary`2<string, int> map;
    private static IanaEncodings();
    public static int GetEncodingNumber(string name);
    public static Encoding GetEncodingEncoding(string name);
}
public interface iTextSharp.text.xml.simpleparser.INewLineHandler {
    public abstract virtual bool IsNewLineTag(string tag);
}
public interface iTextSharp.text.xml.simpleparser.ISimpleXMLDocHandler {
    public abstract virtual void StartElement(string tag, IDictionary`2<string, string> h);
    public abstract virtual void EndElement(string tag);
    public abstract virtual void StartDocument();
    public abstract virtual void EndDocument();
    public abstract virtual void Text(string str);
}
public interface iTextSharp.text.xml.simpleparser.ISimpleXMLDocHandlerComment {
    public abstract virtual void Comment(string text);
}
public class iTextSharp.text.xml.simpleparser.SimpleXMLParser : object {
    private static int UNKNOWN;
    private static int TEXT;
    private static int TAG_ENCOUNTERED;
    private static int EXAMIN_TAG;
    private static int TAG_EXAMINED;
    private static int IN_CLOSETAG;
    private static int SINGLE_TAG;
    private static int CDATA;
    private static int COMMENT;
    private static int PI;
    private static int ENTITY;
    private static int QUOTE;
    private static int ATTRIBUTE_KEY;
    private static int ATTRIBUTE_EQUAL;
    private static int ATTRIBUTE_VALUE;
    private Stack`1<int> stack;
    private int character;
    private int previousCharacter;
    private int lines;
    private int columns;
    private bool eol;
    private bool nowhite;
    private int state;
    private bool html;
    private StringBuilder text;
    private StringBuilder entity;
    private string tag;
    private Dictionary`2<string, string> attributes;
    private ISimpleXMLDocHandler doc;
    private ISimpleXMLDocHandlerComment comment;
    private int nested;
    private int quoteCharacter;
    private string attributekey;
    private string attributevalue;
    private INewLineHandler newLineHandler;
    private SimpleXMLParser(ISimpleXMLDocHandler doc, ISimpleXMLDocHandlerComment comment, bool html);
    private void Go(TextReader reader);
    private int RestoreState();
    private void SaveState(int s);
    private void Flush();
    private void InitTag();
    private void DoTag();
    private void ProcessTag(bool start);
    private void ThrowException(string s);
    public static void Parse(ISimpleXMLDocHandler doc, ISimpleXMLDocHandlerComment comment, TextReader r, bool html);
    public static void Parse(ISimpleXMLDocHandler doc, Stream inp);
    private static string GetDeclaredEncoding(string decl);
    public static void Parse(ISimpleXMLDocHandler doc, TextReader r);
    public static string EscapeXML(string s, bool onlyASCII);
}
public class iTextSharp.text.xml.XmlDomWriter : object {
    protected TextWriter fOut;
    protected bool fCanonical;
    protected bool fXML11;
    public XmlDomWriter(bool canonical);
    public virtual void SetCanonical(bool canonical);
    public virtual void SetOutput(Stream stream, string encoding);
    public virtual void SetOutput(TextWriter writer);
    public virtual void Write(XmlNode node);
    protected virtual XmlAttribute[] SortAttributes(XmlAttributeCollection attrs);
    protected virtual void NormalizeAndPrint(string s, bool isAttValue);
    protected virtual void NormalizeAndPrint(char c, bool isAttValue);
}
public class iTextSharp.text.xml.XmlToTxt : object {
    protected internal StringBuilder buf;
    public static string Parse(Stream isp);
    public virtual string ToString();
    public virtual void StartElement(string tag, IDictionary`2<string, string> h);
    public virtual void EndElement(string tag);
    public virtual void StartDocument();
    public virtual void EndDocument();
    public virtual void Text(string str);
}
public static class iTextSharp.text.xml.XMLUtil : object {
    public static string EscapeXML(string s, bool onlyASCII);
    public static string UnescapeXML(string s);
    public static int Unescape(string s);
    public static bool IsValidCharacterValue(string s);
    public static bool IsValidCharacterValue(int c);
    public static int FindInArray(char needle, Char[] haystack, int start);
    public static string GetEncodingName(Byte[] b4);
}
public class iTextSharp.text.xml.xmp.DublinCoreProperties : object {
    public static string CONTRIBUTOR;
    public static string COVERAGE;
    public static string CREATOR;
    public static string DATE;
    public static string DESCRIPTION;
    public static string FORMAT;
    public static string IDENTIFIER;
    public static string LANGUAGE;
    public static string PUBLISHER;
    public static string RELATION;
    public static string RIGHTS;
    public static string SOURCE;
    public static string SUBJECT;
    public static string TITLE;
    public static string TYPE;
    private static DublinCoreProperties();
    public static void AddTitle(IXmpMeta xmpMeta, string title);
    public static void SetTitle(IXmpMeta xmpMeta, string title, string genericLang, string specificLang);
    public static void AddDescription(IXmpMeta xmpMeta, string desc);
    public static void SetDescription(IXmpMeta xmpMeta, string desc, string genericLang, string specificLang);
    public static void AddSubject(IXmpMeta xmpMeta, string subject);
    public static void SetSubject(IXmpMeta xmpMeta, String[] subject);
    public static void AddAuthor(IXmpMeta xmpMeta, string author);
    public static void SetAuthor(IXmpMeta xmpMeta, String[] author);
    public static void AddPublisher(IXmpMeta xmpMeta, string publisher);
    public static void SetPublisher(IXmpMeta xmpMeta, String[] publisher);
}
[ObsoleteAttribute]
public class iTextSharp.text.xml.xmp.DublinCoreSchema : XmpSchema {
    public static string DEFAULT_XPATH_ID;
    public static string DEFAULT_XPATH_URI;
    public static string CONTRIBUTOR;
    public static string COVERAGE;
    public static string CREATOR;
    public static string DATE;
    public static string DESCRIPTION;
    public static string FORMAT;
    public static string IDENTIFIER;
    public static string LANGUAGE;
    public static string PUBLISHER;
    public static string RELATION;
    public static string RIGHTS;
    public static string SOURCE;
    public static string SUBJECT;
    public static string TITLE;
    public static string TYPE;
    public virtual void AddTitle(string title);
    public virtual void AddTitle(LangAlt title);
    public virtual void AddDescription(string desc);
    public virtual void AddDescription(LangAlt desc);
    public virtual void AddSubject(string subject);
    public virtual void AddSubject(String[] subject);
    public virtual void AddAuthor(string author);
    public virtual void AddAuthor(String[] author);
    public virtual void AddPublisher(string publisher);
    public virtual void AddPublisher(String[] publisher);
}
public class iTextSharp.text.xml.xmp.EncodingNoPreamble : Encoding {
    private Encoding encoding;
    private static Byte[] emptyPreamble;
    public string BodyName { get; }
    public int CodePage { get; }
    public string EncodingName { get; }
    public string HeaderName { get; }
    public bool IsBrowserDisplay { get; }
    public bool IsBrowserSave { get; }
    public bool IsMailNewsDisplay { get; }
    public bool IsMailNewsSave { get; }
    public string WebName { get; }
    public int WindowsCodePage { get; }
    public EncodingNoPreamble(Encoding encoding);
    private static EncodingNoPreamble();
    public virtual int GetByteCount(Char[] chars, int index, int count);
    public virtual int GetBytes(Char[] chars, int charIndex, int charCount, Byte[] bytes, int byteIndex);
    public virtual int GetCharCount(Byte[] bytes, int index, int count);
    public virtual int GetChars(Byte[] bytes, int byteIndex, int byteCount, Char[] chars, int charIndex);
    public virtual int GetMaxByteCount(int charCount);
    public virtual int GetMaxCharCount(int byteCount);
    public virtual string get_BodyName();
    public virtual int get_CodePage();
    public virtual string get_EncodingName();
    public virtual string get_HeaderName();
    public virtual bool get_IsBrowserDisplay();
    public virtual bool get_IsBrowserSave();
    public virtual bool get_IsMailNewsDisplay();
    public virtual bool get_IsMailNewsSave();
    public virtual string get_WebName();
    public virtual int get_WindowsCodePage();
    public virtual Decoder GetDecoder();
    public virtual Encoder GetEncoder();
    public virtual Byte[] GetPreamble();
}
[ObsoleteAttribute]
public class iTextSharp.text.xml.xmp.LangAlt : Properties {
    public static string DEFAULT;
    public LangAlt(string defaultValue);
    public virtual void AddLanguage(string language, string value);
    protected internal virtual void Process(StringBuilder buf, string lang);
    public virtual string ToString();
}
public class iTextSharp.text.xml.xmp.PdfProperties : object {
    public static string KEYWORDS;
    public static string VERSION;
    public static string PRODUCER;
    public static string PART;
    private static PdfProperties();
    public static void SetKeywords(IXmpMeta xmpMeta, string keywords);
    public static void SetProducer(IXmpMeta xmpMeta, string producer);
    public static void SetVersion(IXmpMeta xmpMeta, string version);
}
[ObsoleteAttribute]
public class iTextSharp.text.xml.xmp.PdfSchema : XmpSchema {
    public static string DEFAULT_XPATH_ID;
    public static string DEFAULT_XPATH_URI;
    public static string KEYWORDS;
    public static string VERSION;
    public static string PRODUCER;
    public virtual void AddKeywords(string keywords);
    public virtual void AddProducer(string producer);
    public virtual void AddVersion(string version);
}
[ObsoleteAttribute]
public class iTextSharp.text.xml.xmp.XmpArray : List`1<string> {
    public static string UNORDERED;
    public static string ORDERED;
    public static string ALTERNATIVE;
    protected string type;
    public XmpArray(string type);
    public virtual string ToString();
}
public class iTextSharp.text.xml.xmp.XmpBasicProperties : object {
    public static string ADVISORY;
    public static string BASEURL;
    public static string CREATEDATE;
    public static string CREATORTOOL;
    public static string IDENTIFIER;
    public static string METADATADATE;
    public static string MODIFYDATE;
    public static string NICKNAME;
    public static string THUMBNAILS;
    private static XmpBasicProperties();
    public static void SetCreatorTool(IXmpMeta xmpMeta, string creator);
    public static void SetCreateDate(IXmpMeta xmpMeta, string date);
    public static void SetModDate(IXmpMeta xmpMeta, string date);
    public static void SetMetaDataDate(IXmpMeta xmpMeta, string date);
    public static void SetIdentifiers(IXmpMeta xmpMeta, String[] id);
    public static void SetNickname(IXmpMeta xmpMeta, string name);
}
[ObsoleteAttribute]
public class iTextSharp.text.xml.xmp.XmpBasicSchema : XmpSchema {
    public static string DEFAULT_XPATH_ID;
    public static string DEFAULT_XPATH_URI;
    public static string ADVISORY;
    public static string BASEURL;
    public static string CREATEDATE;
    public static string CREATORTOOL;
    public static string IDENTIFIER;
    public static string METADATADATE;
    public static string MODIFYDATE;
    public static string NICKNAME;
    public static string THUMBNAILS;
    public virtual void AddCreatorTool(string creator);
    public virtual void AddCreateDate(string date);
    public virtual void AddModDate(string date);
    public virtual void AddMetaDataDate(string date);
    public virtual void AddIdentifiers(String[] id);
    public virtual void AddNickname(string name);
}
public class iTextSharp.text.xml.xmp.XmpMMProperties : object {
    public static string DERIVEDFROM;
    public static string DOCUMENTID;
    public static string HISTORY;
    public static string MANAGEDFROM;
    public static string MANAGER;
    public static string MANAGETO;
    public static string MANAGEUI;
    public static string MANAGERVARIANT;
    public static string RENDITIONCLASS;
    public static string RENDITIONPARAMS;
    public static string VERSIONID;
    public static string VERSIONS;
    private static XmpMMProperties();
}
[ObsoleteAttribute]
public class iTextSharp.text.xml.xmp.XmpMMSchema : XmpSchema {
    public static string DEFAULT_XPATH_ID;
    public static string DEFAULT_XPATH_URI;
    public static string DERIVEDFROM;
    public static string DOCUMENTID;
    public static string HISTORY;
    public static string MANAGEDFROM;
    public static string MANAGER;
    public static string MANAGETO;
    public static string MANAGEUI;
    public static string MANAGERVARIANT;
    public static string RENDITIONCLASS;
    public static string RENDITIONPARAMS;
    public static string VERSIONID;
    public static string VERSIONS;
}
[ObsoleteAttribute]
public class iTextSharp.text.xml.xmp.XmpReader : object {
    public static string EXTRASPACE;
    public static string XPACKET_PI_BEGIN;
    public static string XPACKET_PI_END_W;
    private XmlDocument domDocument;
    public XmpReader(Byte[] bytes);
    public virtual bool ReplaceNode(string namespaceURI, string localName, string value);
    public virtual bool ReplaceDescriptionAttribute(string namespaceURI, string localName, string value);
    public virtual bool Add(string parent, string namespaceURI, string localName, string value);
    public virtual bool SetNodeText(XmlDocument domDocument, XmlNode n, string value);
    public virtual Byte[] SerializeDoc();
}
[DefaultMemberAttribute("Item")]
[ObsoleteAttribute]
public abstract class iTextSharp.text.xml.xmp.XmpSchema : Properties {
    protected string xmlns;
    public string Xmlns { get; }
    unknown string Item {public set; }
    public XmpSchema(string xmlns);
    public virtual string ToString();
    protected virtual void Process(StringBuilder buf, object p);
    public virtual string get_Xmlns();
    public virtual void AddProperty(string key, string value);
    public virtual void set_Item(string key, string value);
    public virtual void SetProperty(string key, XmpArray value);
    public virtual void SetProperty(string key, LangAlt value);
    public static string Escape(string content);
}
public class iTextSharp.text.xml.xmp.XmpWriter : object {
    public static string UTF8;
    public static string UTF16;
    public static string UTF16BE;
    public static string UTF16LE;
    protected IXmpMeta xmpMeta;
    protected Stream outputStream;
    protected SerializeOptions serializeOptions;
    public IXmpMeta XmpMeta { get; }
    public bool ReadOnly { get; public set; }
    public string About { get; public set; }
    public XmpWriter(Stream os, string utfEncoding, int extraSpace);
    public XmpWriter(Stream os);
    public XmpWriter(Stream os, PdfDictionary info);
    public XmpWriter(Stream os, IDictionary`2<string, string> info);
    private static XmpWriter();
    public virtual IXmpMeta get_XmpMeta();
    public virtual bool get_ReadOnly();
    public virtual void set_ReadOnly(bool value);
    public virtual string get_About();
    public virtual void set_About(string value);
    [ObsoleteAttribute]
public virtual void AddRdfDescription(string xmlns, string content);
    [ObsoleteAttribute]
public virtual void AddRdfDescription(XmpSchema s);
    public virtual void SetProperty(string schemaNS, string propName, object value);
    public virtual void AppendArrayItem(string schemaNS, string arrayName, string value);
    public virtual void AppendOrderedArrayItem(string schemaNS, string arrayName, string value);
    public virtual void AppendAlternateArrayItem(string schemaNS, string arrayName, string value);
    public virtual void Serialize(Stream externalOutputStream);
    public virtual void Close();
    public virtual void AddDocInfoProperty(object key, string value);
}
public class iTextSharp.text.ZapfDingbatsList : List {
    protected int zn;
    public int CharNumber { get; public set; }
    public ZapfDingbatsList(int zn);
    public ZapfDingbatsList(int zn, int symbolIndent);
    public virtual void setDingbatColor(BaseColor zapfDingbatColor);
    public virtual void set_CharNumber(int value);
    public virtual int get_CharNumber();
    public virtual bool Add(IElement o);
    public virtual List CloneShallow();
}
public class iTextSharp.text.ZapfDingbatsNumberList : List {
    protected int type;
    public int NumberType { get; public set; }
    public ZapfDingbatsNumberList(int type);
    public ZapfDingbatsNumberList(int type, int symbolIndent);
    public virtual int get_NumberType();
    public virtual void set_NumberType(int value);
    public virtual bool Add(IElement o);
    public virtual List CloneShallow();
}
public class iTextSharp.xmp.impl.Base64 : object {
    private static byte INVALID;
    private static byte WHITESPACE;
    private static byte EQUAL;
    private static Byte[] base64;
    private static Byte[] Ascii;
    private static Base64();
    public static Byte[] Encode(Byte[] src);
    public static Byte[] Encode(Byte[] src, int lineFeed);
    public static string Encode(string src);
    public static Byte[] Decode(Byte[] src);
    public static string Decode(string src);
    private static Byte[] GetBytes(string str);
    private static string GetString(Byte[] bytes);
}
public class iTextSharp.xmp.impl.ByteBuffer : object {
    private Byte[] _buffer;
    private string _encoding;
    private int _length;
    public Stream ByteStream { get; }
    public int Length { get; }
    public string Encoding { get; }
    public ByteBuffer(int initialCapacity);
    public ByteBuffer(Byte[] buffer);
    public ByteBuffer(Byte[] buffer, int length);
    public ByteBuffer(Stream inp);
    public ByteBuffer(Byte[] buffer, int offset, int length);
    public virtual Stream get_ByteStream();
    public virtual int get_Length();
    public virtual string get_Encoding();
    public virtual byte ByteAt(int index);
    public virtual int CharAt(int index);
    public virtual void Append(byte b);
    public virtual void Append(Byte[] bytes, int offset, int len);
    public virtual void Append(Byte[] bytes);
    public virtual void Append(ByteBuffer anotherBuffer);
    private void EnsureCapacity(int requestedLength);
}
public class iTextSharp.xmp.impl.CountOutputStream : Stream {
    private Stream _outp;
    private int _bytesWritten;
    public int BytesWritten { get; }
    public bool CanRead { get; }
    public bool CanSeek { get; }
    public bool CanWrite { get; }
    public long Length { get; }
    public long Position { get; public set; }
    internal CountOutputStream(Stream outp);
    public int get_BytesWritten();
    public virtual bool get_CanRead();
    public virtual bool get_CanSeek();
    public virtual bool get_CanWrite();
    public virtual long get_Length();
    public virtual long get_Position();
    public virtual void set_Position(long value);
    public virtual void Write(Byte[] buf, int off, int len);
    public void Write(Byte[] buf);
    public void Write(int b);
    public virtual void Flush();
    public virtual long Seek(long offset, SeekOrigin origin);
    public virtual void SetLength(long value);
    public virtual int Read(Byte[] buffer, int offset, int count);
}
public abstract class iTextSharp.xmp.impl.FilterReader : TextReader {
    protected TextReader inp;
    protected FilterReader(TextReader inp);
    public virtual int Read();
    public virtual int Read(Char[] cbuf, int off, int len);
    public virtual void Close();
}
public class iTextSharp.xmp.impl.FixAsciiControlsReader : PushbackReader {
    private static int STATE_START;
    private static int STATE_AMP;
    private static int STATE_HASH;
    private static int STATE_HEX;
    private static int STATE_DIG1;
    private static int STATE_ERROR;
    private static int BUFFER_SIZE;
    private int _control;
    private int _digits;
    private int _state;
    public FixAsciiControlsReader(TextReader inp);
    public virtual int Read(Char[] cbuf, int off, int len);
    private char ProcessChar(char ch);
}
public static class iTextSharp.xmp.impl.Iso8601Converter : object {
    public static IXmpDateTime Parse(string iso8601String);
    public static IXmpDateTime Parse(string iso8601String, IXmpDateTime binValue);
    public static string Render(IXmpDateTime dateTime);
}
public class iTextSharp.xmp.impl.Latin1Converter : object {
    private static int STATE_START;
    private static int STATE_UTF8CHAR;
    public static ByteBuffer Convert(ByteBuffer buffer);
    private static Byte[] ConvertToUtf8(byte ch);
}
internal class iTextSharp.xmp.impl.ParameterAsserts : XmpConst {
    public static void AssertArrayName(string arrayName);
    public static void AssertPropName(string propName);
    public static void AssertSchemaNs(string schemaNs);
    public static void AssertPrefix(string prefix);
    public static void AssertSpecificLang(string specificLang);
    public static void AssertStructName(string structName);
    public static void AssertNotNull(object param);
    public static void AssertImplementation(IXmpMeta xmp);
}
public class iTextSharp.xmp.impl.ParseRdf : XmpConst {
    public static int RDFTERM_OTHER;
    public static int RDFTERM_RDF;
    public static int RDFTERM_ID;
    public static int RDFTERM_ABOUT;
    public static int RDFTERM_PARSE_TYPE;
    public static int RDFTERM_RESOURCE;
    public static int RDFTERM_NODE_ID;
    public static int RDFTERM_DATATYPE;
    public static int RDFTERM_DESCRIPTION;
    public static int RDFTERM_LI;
    public static int RDFTERM_ABOUT_EACH;
    public static int RDFTERM_ABOUT_EACH_PREFIX;
    public static int RDFTERM_BAG_ID;
    public static int RDFTERM_FIRST_CORE;
    public static int RDFTERM_LAST_CORE;
    public static int RDFTERM_FIRST_SYNTAX;
    public static int RDFTERM_LAST_SYNTAX;
    public static int RDFTERM_FIRST_OLD;
    public static int RDFTERM_LAST_OLD;
    public static string DEFAULT_PREFIX;
    internal static XmpMetaImpl Parse(XmlNode xmlRoot);
    internal static void RdfRdf(XmpMetaImpl xmp, XmlNode rdfRdfNode);
    private static void RdfNodeElementList(XmpMetaImpl xmp, XmpNode xmpParent, XmlNode rdfRdfNode);
    private static void RdfNodeElement(XmpMetaImpl xmp, XmpNode xmpParent, XmlNode xmlNode, bool isTopLevel);
    private static void RdfNodeElementAttrs(XmpMetaImpl xmp, XmpNode xmpParent, XmlNode xmlNode, bool isTopLevel);
    private static void RdfPropertyElementList(XmpMetaImpl xmp, XmpNode xmpParent, XmlNode xmlParent, bool isTopLevel);
    private static void RdfPropertyElement(XmpMetaImpl xmp, XmpNode xmpParent, XmlNode xmlNode, bool isTopLevel);
    private static void RdfResourcePropertyElement(XmpMetaImpl xmp, XmpNode xmpParent, XmlNode xmlNode, bool isTopLevel);
    private static void RdfLiteralPropertyElement(XmpMetaImpl xmp, XmpNode xmpParent, XmlNode xmlNode, bool isTopLevel);
    private static void RdfParseTypeLiteralPropertyElement();
    private static void RdfParseTypeResourcePropertyElement(XmpMetaImpl xmp, XmpNode xmpParent, XmlNode xmlNode, bool isTopLevel);
    private static void RdfParseTypeCollectionPropertyElement();
    private static void RdfParseTypeOtherPropertyElement();
    private static void RdfEmptyPropertyElement(XmpMetaImpl xmp, XmpNode xmpParent, XmlNode xmlNode, bool isTopLevel);
    private static XmpNode AddChildNode(XmpMetaImpl xmp, XmpNode xmpParent, XmlNode xmlNode, string value, bool isTopLevel);
    private static XmpNode AddQualifierNode(XmpNode xmpParent, string name, string value);
    private static void FixupQualifiedNode(XmpNode xmpParent);
    private static bool IsWhitespaceNode(XmlNode node);
    private static bool IsPropertyElementName(int term);
    private static bool IsOldTerm(int term);
    private static bool IsCoreSyntaxTerm(int term);
    private static int GetRdfTermKind(XmlNode node);
}
internal class iTextSharp.xmp.impl.ParseState : object {
    private string _str;
    private int _pos;
    public ParseState(string str);
    public virtual int Length();
    public virtual bool HasNext();
    public virtual char Ch(int index);
    public virtual char Ch();
    public virtual void Skip();
    public virtual int Pos();
    public virtual int GatherInt(string errorMsg, int maxValue);
}
public class iTextSharp.xmp.impl.PushbackReader : FilterReader {
    private Char[] _buf;
    private int _pos;
    public PushbackReader(TextReader inp, int size);
    public PushbackReader(TextReader inp);
    private void EnsureOpen();
    public virtual int Read();
    public virtual int Read(Char[] cbuf, int off, int len);
    public virtual void Unread(int c);
    public virtual void Unread(Char[] cbuf, int off, int len);
    public virtual void Unread(Char[] cbuf);
    public virtual void Close();
}
public class iTextSharp.xmp.impl.QName : object {
    private string _localName;
    private string _prefix;
    public string LocalName { get; }
    public string Prefix { get; }
    public QName(string qname);
    public QName(string prefix, string localName);
    public virtual string get_LocalName();
    public virtual string get_Prefix();
    public virtual bool HasPrefix();
}
[DefaultMemberAttribute("Item")]
public class iTextSharp.xmp.impl.ReadOnlyDictionary : object {
    private IDictionary _originalDictionary;
    public bool IsReadOnly { get; }
    public object Item { get; public set; }
    public ICollection Values { get; }
    public ICollection Keys { get; }
    public bool IsFixedSize { get; }
    public bool IsSynchronized { get; }
    public int Count { get; }
    public object SyncRoot { get; }
    private ReadOnlyDictionary(IDictionary original);
    public static ReadOnlyDictionary ReadOnly(IDictionary dictionary);
    private void ReportNotSupported();
    public virtual bool get_IsReadOnly();
    public virtual IDictionaryEnumerator GetEnumerator();
    public sealed virtual object get_Item(object key);
    public sealed virtual void set_Item(object key, object value);
    public virtual void Remove(object key);
    public virtual bool Contains(object key);
    public virtual void Clear();
    public virtual ICollection get_Values();
    public virtual void Add(object key, object value);
    public virtual ICollection get_Keys();
    public virtual bool get_IsFixedSize();
    public virtual bool get_IsSynchronized();
    public virtual int get_Count();
    public virtual void CopyTo(Array array, int index);
    public virtual object get_SyncRoot();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
}
public class iTextSharp.xmp.impl.Utils : XmpConst {
    public static int UUID_SEGMENT_COUNT;
    public static int UUID_LENGTH;
    private static Boolean[] _xmlNameStartChars;
    private static Boolean[] _xmlNameChars;
    private static Utils();
    public static string NormalizeLangValue(string value);
    internal static String[] SplitNameAndValue(string selector);
    internal static bool IsInternalProperty(string schema, string prop);
    internal static bool CheckUuidFormat(string uuid);
    public static bool IsXmlName(string name);
    public static bool IsXmlNameNs(string name);
    internal static bool IsControlChar(char c);
    public static string EscapeXml(string value, bool forAttribute, bool escapeWhitespaces);
    internal static string RemoveControlChars(string value);
    private static bool IsNameStartChar(char ch);
    private static bool IsNameChar(char ch);
    private static void InitCharTables();
}
public class iTextSharp.xmp.impl.XmpDateTimeImpl : object {
    private int _day;
    private bool _hasDate;
    private bool _hasTime;
    private bool _hasTimeZone;
    private int _hour;
    private int _minute;
    private int _month;
    private int _nanoSeconds;
    private int _second;
    private TimeZone _timeZone;
    private int _year;
    public int Year { get; public set; }
    public int Month { get; public set; }
    public int Day { get; public set; }
    public int Hour { get; public set; }
    public int Minute { get; public set; }
    public int Second { get; public set; }
    public int NanoSecond { get; public set; }
    public TimeZone TimeZone { get; public set; }
    public XmpCalendar Calendar { get; }
    public string Iso8601String { get; }
    public XmpDateTimeImpl(XmpCalendar calendar);
    public XmpDateTimeImpl(DateTime date, TimeZone timeZone);
    public XmpDateTimeImpl(string strValue);
    public virtual int get_Year();
    public virtual void set_Year(int value);
    public virtual int get_Month();
    public virtual void set_Month(int value);
    public virtual int get_Day();
    public virtual void set_Day(int value);
    public virtual int get_Hour();
    public virtual void set_Hour(int value);
    public virtual int get_Minute();
    public virtual void set_Minute(int value);
    public virtual int get_Second();
    public virtual void set_Second(int value);
    public virtual int get_NanoSecond();
    public virtual void set_NanoSecond(int value);
    public virtual int CompareTo(object dt);
    public virtual TimeZone get_TimeZone();
    public virtual void set_TimeZone(TimeZone value);
    public virtual bool HasDate();
    public virtual bool HasTime();
    public virtual bool HasTimeZone();
    public virtual XmpCalendar get_Calendar();
    public virtual string get_Iso8601String();
    public virtual string ToString();
}
public class iTextSharp.xmp.impl.XmpIteratorImpl : object {
    private static IList EmptyList;
    private IEnumerator _nodeIterator;
    private IteratorOptions _options;
    private string _baseNs;
    private bool _skipSiblings;
    protected internal bool skipSubtree;
    protected internal IteratorOptions Options { get; }
    protected internal string BaseNs { get; protected internal set; }
    public object Current { get; }
    public XmpIteratorImpl(XmpMetaImpl xmp, string schemaNs, string propPath, IteratorOptions options);
    private static XmpIteratorImpl();
    protected internal virtual IteratorOptions get_Options();
    protected internal virtual string get_BaseNs();
    protected internal virtual void set_BaseNs(string value);
    public virtual void SkipSubtree();
    public virtual void SkipSiblings();
    public virtual bool MoveNext();
    public virtual object get_Current();
    public virtual void Reset();
}
public class iTextSharp.xmp.impl.XmpMetaImpl : XmpConst {
    private static int VALUE_STRING;
    private static int VALUE_BOOLEAN;
    private static int VALUE_INTEGER;
    private static int VALUE_LONG;
    private static int VALUE_DOUBLE;
    private static int VALUE_DATE;
    private static int VALUE_CALENDAR;
    private static int VALUE_BASE64;
    private XmpNode _tree;
    private string _packetHeader;
    public XmpNode Root { get; }
    public string ObjectName { get; public set; }
    public string PacketHeader { get; public set; }
    public XmpMetaImpl(XmpNode tree);
    public virtual XmpNode get_Root();
    public virtual void AppendArrayItem(string schemaNs, string arrayName, PropertyOptions arrayOptions, string itemValue, PropertyOptions itemOptions);
    public virtual void AppendArrayItem(string schemaNs, string arrayName, string itemValue);
    public virtual int CountArrayItems(string schemaNs, string arrayName);
    public virtual void DeleteArrayItem(string schemaNs, string arrayName, int itemIndex);
    public virtual void DeleteProperty(string schemaNs, string propName);
    public virtual void DeleteQualifier(string schemaNs, string propName, string qualNs, string qualName);
    public virtual void DeleteStructField(string schemaNs, string structName, string fieldNs, string fieldName);
    public virtual bool DoesPropertyExist(string schemaNs, string propName);
    public virtual bool DoesArrayItemExist(string schemaNs, string arrayName, int itemIndex);
    public virtual bool DoesStructFieldExist(string schemaNs, string structName, string fieldNs, string fieldName);
    public virtual bool DoesQualifierExist(string schemaNs, string propName, string qualNs, string qualName);
    public virtual IXmpProperty GetArrayItem(string schemaNs, string arrayName, int itemIndex);
    public virtual IXmpProperty GetLocalizedText(string schemaNs, string altTextName, string genericLang, string specificLang);
    public virtual void SetLocalizedText(string schemaNs, string altTextName, string genericLang, string specificLang, string itemValue, PropertyOptions options);
    public virtual void SetLocalizedText(string schemaNs, string altTextName, string genericLang, string specificLang, string itemValue);
    public virtual IXmpProperty GetProperty(string schemaNs, string propName);
    public virtual Nullable`1<bool> GetPropertyBoolean(string schemaNs, string propName);
    public virtual void SetPropertyBoolean(string schemaNs, string propName, bool propValue, PropertyOptions options);
    public virtual void SetPropertyBoolean(string schemaNs, string propName, bool propValue);
    public virtual Nullable`1<int> GetPropertyInteger(string schemaNs, string propName);
    public virtual void SetPropertyInteger(string schemaNs, string propName, int propValue, PropertyOptions options);
    public virtual void SetPropertyInteger(string schemaNs, string propName, int propValue);
    public virtual Nullable`1<long> GetPropertyLong(string schemaNs, string propName);
    public virtual void SetPropertyLong(string schemaNs, string propName, long propValue, PropertyOptions options);
    public virtual void SetPropertyLong(string schemaNs, string propName, long propValue);
    public virtual Nullable`1<double> GetPropertyDouble(string schemaNs, string propName);
    public virtual void SetPropertyDouble(string schemaNs, string propName, double propValue, PropertyOptions options);
    public virtual void SetPropertyDouble(string schemaNs, string propName, double propValue);
    public virtual IXmpDateTime GetPropertyDate(string schemaNs, string propName);
    public virtual void SetPropertyDate(string schemaNs, string propName, IXmpDateTime propValue, PropertyOptions options);
    public virtual void SetPropertyDate(string schemaNs, string propName, IXmpDateTime propValue);
    public virtual DateTime GetPropertyCalendar(string schemaNs, string propName);
    public virtual void SetPropertyCalendar(string schemaNs, string propName, DateTime propValue, PropertyOptions options);
    public virtual void SetPropertyCalendar(string schemaNs, string propName, DateTime propValue);
    public virtual SByte[] GetPropertyBase64(string schemaNs, string propName);
    public virtual string GetPropertyString(string schemaNs, string propName);
    public virtual void SetPropertyBase64(string schemaNs, string propName, SByte[] propValue, PropertyOptions options);
    public virtual void SetPropertyBase64(string schemaNs, string propName, SByte[] propValue);
    public virtual IXmpProperty GetQualifier(string schemaNs, string propName, string qualNs, string qualName);
    public virtual IXmpProperty GetStructField(string schemaNs, string structName, string fieldNs, string fieldName);
    public virtual IXmpIterator Iterator();
    public virtual IXmpIterator Iterator(IteratorOptions options);
    public virtual IXmpIterator Iterator(string schemaNs, string propName, IteratorOptions options);
    public virtual void SetArrayItem(string schemaNs, string arrayName, int itemIndex, string itemValue, PropertyOptions options);
    public virtual void SetArrayItem(string schemaNs, string arrayName, int itemIndex, string itemValue);
    public virtual void InsertArrayItem(string schemaNs, string arrayName, int itemIndex, string itemValue, PropertyOptions options);
    public virtual void InsertArrayItem(string schemaNs, string arrayName, int itemIndex, string itemValue);
    public virtual void SetProperty(string schemaNs, string propName, object propValue, PropertyOptions options);
    public virtual void SetProperty(string schemaNs, string propName, object propValue);
    public virtual void SetQualifier(string schemaNs, string propName, string qualNs, string qualName, string qualValue, PropertyOptions options);
    public virtual void SetQualifier(string schemaNs, string propName, string qualNs, string qualName, string qualValue);
    public virtual void SetStructField(string schemaNs, string structName, string fieldNs, string fieldName, string fieldValue, PropertyOptions options);
    public virtual void SetStructField(string schemaNs, string structName, string fieldNs, string fieldName, string fieldValue);
    public virtual string get_ObjectName();
    public virtual void set_ObjectName(string value);
    public virtual string get_PacketHeader();
    public virtual void set_PacketHeader(string value);
    public virtual object Clone();
    public virtual string DumpObject();
    public virtual void Sort();
    public virtual void Normalize(ParseOptions options);
    protected internal virtual IXmpProperty GetProperty(string schemaNs, string propName, int valueType);
    protected internal virtual object GetPropertyObject(string schemaNs, string propName, int valueType);
    private void DoSetArrayItem(XmpNode arrayNode, int itemIndex, string itemValue, PropertyOptions itemOptions, bool insert);
    internal virtual void SetNode(XmpNode node, object value, PropertyOptions newOptions, bool deleteExisting);
    private object evaluateNodeValue(int valueType, XmpNode propNode);
}
public class iTextSharp.xmp.impl.XmpMetaParser : object {
    private static object XmpRdf;
    private static XmpMetaParser();
    public static IXmpMeta Parse(object input, ParseOptions options);
    private static XmlDocument ParseXml(object input, ParseOptions options);
    private static XmlDocument ParseXmlFromInputStream(Stream stream, ParseOptions options);
    private static XmlDocument ParseXmlFromBytebuffer(ByteBuffer buffer, ParseOptions options);
    private static XmlDocument ParseXmlFromString(string input, ParseOptions options);
    private static Object[] FindRootNode(XmlNode root, bool xmpmetaRequired, Object[] result);
    private static XmlReaderSettings GetSecureReaderSettings();
    private static XmlReader GetSecureXmlReader(Stream stream);
    private static XmlReader GetSecureXmlReader(TextReader textReader);
    private static XmlReader GetSecureXmlReader(string str);
}
public class iTextSharp.xmp.impl.XmpNode : object {
    private static IList EmptyList;
    private bool _alias;
    private IList _children;
    private bool _hasAliases;
    private bool _hasValueChild;
    private bool _implicit;
    private string _name;
    private PropertyOptions _options;
    private XmpNode _parent;
    private IList _qualifier;
    private string _value;
    public XmpNode Parent { get; public set; }
    public int ChildrenLength { get; }
    public int QualifierLength { get; }
    public string Name { get; public set; }
    public string Value { get; public set; }
    public PropertyOptions Options { get; public set; }
    public bool Implicit { get; public set; }
    public bool HasAliases { get; public set; }
    public bool Alias { get; public set; }
    public bool HasValueChild { get; public set; }
    private bool LanguageNode { get; }
    private bool TypeNode { get; }
    internal IList Children { get; }
    public IList UnmodifiableChildren { get; }
    private IList Qualifier { get; }
    public XmpNode(string name, string value, PropertyOptions options);
    public XmpNode(string name, PropertyOptions options);
    private static XmpNode();
    public virtual XmpNode get_Parent();
    public virtual void set_Parent(XmpNode value);
    public virtual int get_ChildrenLength();
    public virtual int get_QualifierLength();
    public virtual string get_Name();
    public virtual void set_Name(string value);
    public virtual string get_Value();
    public virtual void set_Value(string value);
    public virtual PropertyOptions get_Options();
    public virtual void set_Options(PropertyOptions value);
    public virtual bool get_Implicit();
    public virtual void set_Implicit(bool value);
    public virtual bool get_HasAliases();
    public virtual void set_HasAliases(bool value);
    public virtual bool get_Alias();
    public virtual void set_Alias(bool value);
    public virtual bool get_HasValueChild();
    public virtual void set_HasValueChild(bool value);
    private bool get_LanguageNode();
    private bool get_TypeNode();
    internal IList get_Children();
    public virtual IList get_UnmodifiableChildren();
    private IList get_Qualifier();
    public virtual object Clone();
    public virtual int CompareTo(object xmpNode);
    public virtual void Clear();
    public virtual XmpNode GetChild(int index);
    public virtual void AddChild(XmpNode node);
    public virtual void AddChild(int index, XmpNode node);
    public virtual void ReplaceChild(int index, XmpNode node);
    public virtual void RemoveChild(int itemIndex);
    public virtual void RemoveChild(XmpNode node);
    protected internal virtual void CleanupChildren();
    public virtual void RemoveChildren();
    public virtual XmpNode FindChildByName(string expr);
    public virtual XmpNode GetQualifier(int index);
    public virtual void AddQualifier(XmpNode qualNode);
    public virtual void RemoveQualifier(XmpNode qualNode);
    public virtual void RemoveQualifiers();
    public virtual XmpNode FindQualifierByName(string expr);
    public virtual bool HasChildren();
    public virtual IEnumerator IterateChildren();
    public virtual bool HasQualifier();
    public virtual IEnumerator IterateQualifier();
    public virtual void CloneSubtree(XmpNode destination);
    public virtual string DumpNode(bool recursive);
    public virtual void Sort();
    private void DumpNode(StringBuilder result, bool recursive, int indent, int index);
    private XmpNode find(IList list, string expr);
    private void AssertChildNotExisting(string childName);
    private void AssertQualifierNotExisting(string qualifierName);
}
public class iTextSharp.xmp.impl.XmpNodeUtils : XmpConst {
    internal static int CLT_NO_VALUES;
    internal static int CLT_SPECIFIC_MATCH;
    internal static int CLT_SINGLE_GENERIC;
    internal static int CLT_MULTIPLE_GENERIC;
    internal static int CLT_XDEFAULT;
    internal static int CLT_FIRST_ITEM;
    internal static XmpNode FindSchemaNode(XmpNode tree, string namespaceUri, bool createNodes);
    internal static XmpNode FindSchemaNode(XmpNode tree, string namespaceUri, string suggestedPrefix, bool createNodes);
    internal static XmpNode FindChildNode(XmpNode parent, string childName, bool createNodes);
    internal static XmpNode FindNode(XmpNode xmpTree, XmpPath xpath, bool createNodes, PropertyOptions leafOptions);
    internal static void DeleteNode(XmpNode node);
    internal static void SetNodeValue(XmpNode node, object value);
    internal static PropertyOptions VerifySetOptions(PropertyOptions options, object itemValue);
    internal static string SerializeNodeValue(object value);
    private static XmpNode FollowXPathStep(XmpNode parentNode, XmpPathSegment nextStep, bool createNodes);
    private static XmpNode FindQualifierNode(XmpNode parent, string qualName, bool createNodes);
    private static int FindIndexedItem(XmpNode arrayNode, string segment, bool createNodes);
    private static int LookupFieldSelector(XmpNode arrayNode, string fieldName, string fieldValue);
    private static int LookupQualSelector(XmpNode arrayNode, string qualName, string qualValue, UInt32 aliasForm);
    internal static void NormalizeLangArray(XmpNode arrayNode);
    internal static void DetectAltText(XmpNode arrayNode);
    internal static void AppendLangItem(XmpNode arrayNode, string itemLang, string itemValue);
    internal static Object[] ChooseLocalizedText(XmpNode arrayNode, string genericLang, string specificLang);
    internal static int LookupLanguageItem(XmpNode arrayNode, string language);
}
public class iTextSharp.xmp.impl.XmpNormalizer : object {
    private static IDictionary _dcArrayForms;
    private static XmpNormalizer();
    internal static IXmpMeta Process(XmpMetaImpl xmp, ParseOptions options);
    private static void TweakOldXmp(XmpNode tree);
    private static void TouchUpDataModel(XmpMetaImpl xmp);
    private static void NormalizeDcArrays(XmpNode dcSchema);
    private static void RepairAltText(XmpNode arrayNode);
    private static void MoveExplicitAliases(XmpNode tree, ParseOptions options);
    private static void TransplantArrayItemAlias(XmpNode childNode, XmpNode baseArray);
    private static void FixGpsTimeStamp(XmpNode exifSchema);
    private static void DeleteEmptySchemas(XmpNode tree);
    private static void CompareAliasedSubtrees(XmpNode aliasNode, XmpNode baseNode, bool outerCall);
    private static void MigrateAudioCopyright(IXmpMeta xmp, XmpNode dmCopyright);
    private static void InitDcArrays();
}
public class iTextSharp.xmp.impl.XmpSchemaRegistryImpl : XmpConst {
    private IDictionary _aliasMap;
    private IDictionary _namespaceToPrefixMap;
    private IDictionary _prefixToNamespaceMap;
    private Regex _regex;
    public sealed virtual string RegisterNamespace(string namespaceUri, string suggestedPrefix);
    public sealed virtual void DeleteNamespace(string namespaceUri);
    public sealed virtual string GetNamespacePrefix(string namespaceUri);
    public sealed virtual string GetNamespaceUri(string namespacePrefix);
    public sealed virtual IXmpAliasInfo ResolveAlias(string aliasNs, string aliasProp);
    public sealed virtual IXmpAliasInfo FindAlias(string qname);
    public sealed virtual IXmpAliasInfo[] FindAliases(string aliasNs);
    public sealed virtual IDictionary GetNamespaces();
    public sealed virtual IDictionary GetPrefixes();
    public sealed virtual IDictionary GetAliases();
    private void RegisterStandardNamespaces();
    private void RegisterAlias(string aliasNs, string aliasProp, string actualNs, string actualProp, AliasOptions aliasForm);
    private void RegisterStandardAliases();
}
public class iTextSharp.xmp.impl.XmpSerializerHelper : object {
    public static void Serialize(XmpMetaImpl xmp, Stream out, SerializeOptions options);
    public static string SerializeToString(XmpMetaImpl xmp, SerializeOptions options);
    public static Byte[] SerializeToBuffer(XmpMetaImpl xmp, SerializeOptions options);
    private static string GetString(Byte[] bytes);
}
public class iTextSharp.xmp.impl.XmpSerializerRdf : object {
    private static int DEFAULT_PAD;
    private static string RDF_XMPMETA_END;
    private static string RDF_RDF_END;
    private static string RDF_SCHEMA_START;
    private static string RDF_SCHEMA_END;
    private static string RDF_STRUCT_START;
    private static string RDF_STRUCT_END;
    private static string RDF_EMPTY_STRUCT;
    private static string PACKET_HEADER;
    private static string PACKET_TRAILER;
    private static string PACKET_TRAILER2;
    private static string RDF_XMPMETA_START;
    private static string RDF_RDF_START;
    internal static ISet RDF_ATTR_QUALIFIER;
    private SerializeOptions _options;
    private CountOutputStream _outputStream;
    private int _padding;
    private int _unicodeSize;
    private StreamWriter _writer;
    private XmpMetaImpl _xmp;
    private static XmpSerializerRdf();
    public virtual void Serialize(IXmpMeta xmp, Stream out, SerializeOptions options);
    private void AddPadding(int tailLength);
    protected internal virtual void CheckOptionsConsistence();
    private string SerializeAsRdf();
    private void SerializeCanonicalRdfSchemas(int level);
    private void WriteTreeName();
    private void SerializeCompactRdfSchemas(int level);
    private bool SerializeCompactRdfAttrProps(XmpNode parentNode, int indent);
    private void SerializeCompactRdfElementProps(XmpNode parentNode, int indent);
    private Object[] SerializeCompactRdfSimpleProp(XmpNode node);
    private void SerializeCompactRdfArrayProp(XmpNode node, int indent);
    private bool SerializeCompactRdfStructProp(XmpNode node, int indent, bool hasRdfResourceQual);
    private void SerializeCompactRdfGeneralQualifier(int indent, XmpNode node);
    private void SerializeCanonicalRdfSchema(XmpNode schemaNode, int level);
    private void DeclareUsedNamespaces(XmpNode node, ISet usedPrefixes, int indent);
    private void DeclareNamespace(string prefix, string namespace, ISet usedPrefixes, int indent);
    private void StartOuterRdfDescription(XmpNode schemaNode, int level);
    private void EndOuterRdfDescription(int level);
    private void SerializeCanonicalRdfProperty(XmpNode node, bool useCanonicalRdf, bool emitAsRdfValue, int indent);
    private void EmitRdfArrayTag(XmpNode arrayNode, bool isStartTag, int indent);
    private void AppendNodeValue(string value, bool forAttribute);
    private bool canBeRDFAttrProp(XmpNode node);
    private void WriteIndent(int times);
    private void Write(char c);
    private void Write(string str);
    private void WriteChars(int number, char c);
    private void WriteNewline();
}
public class iTextSharp.xmp.impl.XmpUtilsImpl : XmpConst {
    private static int UCK_NORMAL;
    private static int UCK_SPACE;
    private static int UCK_COMMA;
    private static int UCK_SEMICOLON;
    private static int UCK_QUOTE;
    private static int UCK_CONTROL;
    private static string SPACES;
    private static string COMMAS;
    private static string SEMICOLA;
    private static string CONTROLS;
    private static string QUOTES;
    public static string CatenateArrayItems(IXmpMeta xmp, string schemaNs, string arrayName, string separator, string quotes, bool allowCommas);
    public static void SeparateArrayItems(IXmpMeta xmp, string schemaNs, string arrayName, string catedStr, PropertyOptions arrayOptions, bool preserveCommas);
    private static XmpNode SeparateFindCreateArray(string schemaNs, string arrayName, PropertyOptions arrayOptions, XmpMetaImpl xmp);
    public static void RemoveProperties(IXmpMeta xmp, string schemaNs, string propName, bool doAllProperties, bool includeAliases);
    public static void AppendProperties(IXmpMeta source, IXmpMeta destination, bool doAllProperties, bool replaceOldValues, bool deleteEmptyValues);
    private static bool RemoveSchemaChildren(XmpNode schemaNode, bool doAllProperties);
    private static void AppendSubtree(XmpMetaImpl destXmp, XmpNode sourceNode, XmpNode destParent, bool replaceOldValues, bool deleteEmptyValues);
    private static bool ItemValuesMatch(XmpNode leftNode, XmpNode rightNode);
    private static void CheckSeparator(string separator);
    private static char CheckQuotes(string quotes, char openQuote);
    private static int ClassifyCharacter(char ch);
    private static char GetClosingQuote(char openQuote);
    private static string ApplyQuotes(string item, char openQuote, char closeQuote, bool allowCommas);
    private static bool IsSurroundingQuote(char ch, char openQuote, char closeQuote);
    private static bool IsClosingingQuote(char ch, char openQuote, char closeQuote);
}
public class iTextSharp.xmp.impl.xpath.PathPosition : object {
    internal int NameEnd;
    internal int NameStart;
    internal string Path;
    internal int StepBegin;
    internal int StepEnd;
}
public class iTextSharp.xmp.impl.xpath.XmpPath : object {
    public static UInt32 STRUCT_FIELD_STEP;
    public static UInt32 QUALIFIER_STEP;
    public static UInt32 ARRAY_INDEX_STEP;
    public static UInt32 ARRAY_LAST_STEP;
    public static UInt32 QUAL_SELECTOR_STEP;
    public static UInt32 FIELD_SELECTOR_STEP;
    public static UInt32 SCHEMA_NODE;
    public static UInt32 STEP_SCHEMA;
    public static UInt32 STEP_ROOT_PROP;
    private IList _segments;
    public virtual void Add(XmpPathSegment segment);
    public virtual XmpPathSegment GetSegment(int index);
    public virtual int Size();
    public virtual string ToString();
}
public class iTextSharp.xmp.impl.xpath.XmpPathParser : object {
    public static XmpPath ExpandXPath(string schemaNs, string path);
    internal static void SkipPathDelimiter(string path, PathPosition pos);
    internal static XmpPathSegment ParseStructSegment(PathPosition pos);
    internal static XmpPathSegment ParseIndexSegment(PathPosition pos);
    internal static void ParseRootNode(string schemaNs, PathPosition pos, XmpPath expandedXPath);
    internal static void VerifyQualName(string qualName);
    internal static void VerifySimpleXmlName(string name);
    internal static string VerifyXPathRoot(string schemaNs, string rootProp);
}
public class iTextSharp.xmp.impl.xpath.XmpPathSegment : object {
    private bool _alias;
    private UInt32 _aliasForm;
    private UInt32 _kind;
    private string _name;
    public UInt32 Kind { get; public set; }
    public string Name { get; public set; }
    public bool Alias { get; public set; }
    public UInt32 AliasForm { get; public set; }
    public XmpPathSegment(string name);
    public XmpPathSegment(string name, UInt32 kind);
    public virtual UInt32 get_Kind();
    public virtual void set_Kind(UInt32 value);
    public virtual string get_Name();
    public virtual void set_Name(string value);
    public virtual void set_Alias(bool value);
    public virtual bool get_Alias();
    public virtual UInt32 get_AliasForm();
    public virtual void set_AliasForm(UInt32 value);
    public virtual string ToString();
}
public interface iTextSharp.xmp.IXmpDateTime {
    public int Year { get; public set; }
    public int Month { get; public set; }
    public int Day { get; public set; }
    public int Hour { get; public set; }
    public int Minute { get; public set; }
    public int Second { get; public set; }
    public int NanoSecond { get; public set; }
    public TimeZone TimeZone { get; public set; }
    public XmpCalendar Calendar { get; }
    public string Iso8601String { get; }
    public abstract virtual int get_Year();
    public abstract virtual void set_Year(int value);
    public abstract virtual int get_Month();
    public abstract virtual void set_Month(int value);
    public abstract virtual int get_Day();
    public abstract virtual void set_Day(int value);
    public abstract virtual int get_Hour();
    public abstract virtual void set_Hour(int value);
    public abstract virtual int get_Minute();
    public abstract virtual void set_Minute(int value);
    public abstract virtual int get_Second();
    public abstract virtual void set_Second(int value);
    public abstract virtual int get_NanoSecond();
    public abstract virtual void set_NanoSecond(int value);
    public abstract virtual TimeZone get_TimeZone();
    public abstract virtual void set_TimeZone(TimeZone value);
    public abstract virtual XmpCalendar get_Calendar();
    public abstract virtual string get_Iso8601String();
    public abstract virtual bool HasDate();
    public abstract virtual bool HasTime();
    public abstract virtual bool HasTimeZone();
}
public interface iTextSharp.xmp.IXmpIterator {
    public abstract virtual void SkipSubtree();
    public abstract virtual void SkipSiblings();
}
public interface iTextSharp.xmp.IXmpMeta {
    public string ObjectName { get; public set; }
    public string PacketHeader { get; }
    public abstract virtual string get_ObjectName();
    public abstract virtual void set_ObjectName(string value);
    public abstract virtual string get_PacketHeader();
    public abstract virtual IXmpProperty GetProperty(string schemaNs, string propName);
    public abstract virtual IXmpProperty GetArrayItem(string schemaNs, string arrayName, int itemIndex);
    public abstract virtual int CountArrayItems(string schemaNs, string arrayName);
    public abstract virtual IXmpProperty GetStructField(string schemaNs, string structName, string fieldNs, string fieldName);
    public abstract virtual IXmpProperty GetQualifier(string schemaNs, string propName, string qualNs, string qualName);
    public abstract virtual void SetProperty(string schemaNs, string propName, object propValue, PropertyOptions options);
    public abstract virtual void SetProperty(string schemaNs, string propName, object propValue);
    public abstract virtual void SetArrayItem(string schemaNs, string arrayName, int itemIndex, string itemValue, PropertyOptions options);
    public abstract virtual void SetArrayItem(string schemaNs, string arrayName, int itemIndex, string itemValue);
    public abstract virtual void InsertArrayItem(string schemaNs, string arrayName, int itemIndex, string itemValue, PropertyOptions options);
    public abstract virtual void InsertArrayItem(string schemaNs, string arrayName, int itemIndex, string itemValue);
    public abstract virtual void AppendArrayItem(string schemaNs, string arrayName, PropertyOptions arrayOptions, string itemValue, PropertyOptions itemOptions);
    public abstract virtual void AppendArrayItem(string schemaNs, string arrayName, string itemValue);
    public abstract virtual void SetStructField(string schemaNs, string structName, string fieldNs, string fieldName, string fieldValue, PropertyOptions options);
    public abstract virtual void SetStructField(string schemaNs, string structName, string fieldNs, string fieldName, string fieldValue);
    public abstract virtual void SetQualifier(string schemaNs, string propName, string qualNs, string qualName, string qualValue, PropertyOptions options);
    public abstract virtual void SetQualifier(string schemaNs, string propName, string qualNs, string qualName, string qualValue);
    public abstract virtual void DeleteProperty(string schemaNs, string propName);
    public abstract virtual void DeleteArrayItem(string schemaNs, string arrayName, int itemIndex);
    public abstract virtual void DeleteStructField(string schemaNs, string structName, string fieldNs, string fieldName);
    public abstract virtual void DeleteQualifier(string schemaNs, string propName, string qualNs, string qualName);
    public abstract virtual bool DoesPropertyExist(string schemaNs, string propName);
    public abstract virtual bool DoesArrayItemExist(string schemaNs, string arrayName, int itemIndex);
    public abstract virtual bool DoesStructFieldExist(string schemaNs, string structName, string fieldNs, string fieldName);
    public abstract virtual bool DoesQualifierExist(string schemaNs, string propName, string qualNs, string qualName);
    public abstract virtual IXmpProperty GetLocalizedText(string schemaNs, string altTextName, string genericLang, string specificLang);
    public abstract virtual void SetLocalizedText(string schemaNs, string altTextName, string genericLang, string specificLang, string itemValue, PropertyOptions options);
    public abstract virtual void SetLocalizedText(string schemaNs, string altTextName, string genericLang, string specificLang, string itemValue);
    public abstract virtual Nullable`1<bool> GetPropertyBoolean(string schemaNs, string propName);
    public abstract virtual Nullable`1<int> GetPropertyInteger(string schemaNs, string propName);
    public abstract virtual Nullable`1<long> GetPropertyLong(string schemaNs, string propName);
    public abstract virtual Nullable`1<double> GetPropertyDouble(string schemaNs, string propName);
    public abstract virtual IXmpDateTime GetPropertyDate(string schemaNs, string propName);
    public abstract virtual DateTime GetPropertyCalendar(string schemaNs, string propName);
    public abstract virtual SByte[] GetPropertyBase64(string schemaNs, string propName);
    public abstract virtual string GetPropertyString(string schemaNs, string propName);
    public abstract virtual void SetPropertyBoolean(string schemaNs, string propName, bool propValue, PropertyOptions options);
    public abstract virtual void SetPropertyBoolean(string schemaNs, string propName, bool propValue);
    public abstract virtual void SetPropertyInteger(string schemaNs, string propName, int propValue, PropertyOptions options);
    public abstract virtual void SetPropertyInteger(string schemaNs, string propName, int propValue);
    public abstract virtual void SetPropertyLong(string schemaNs, string propName, long propValue, PropertyOptions options);
    public abstract virtual void SetPropertyLong(string schemaNs, string propName, long propValue);
    public abstract virtual void SetPropertyDouble(string schemaNs, string propName, double propValue, PropertyOptions options);
    public abstract virtual void SetPropertyDouble(string schemaNs, string propName, double propValue);
    public abstract virtual void SetPropertyDate(string schemaNs, string propName, IXmpDateTime propValue, PropertyOptions options);
    public abstract virtual void SetPropertyDate(string schemaNs, string propName, IXmpDateTime propValue);
    public abstract virtual void SetPropertyCalendar(string schemaNs, string propName, DateTime propValue, PropertyOptions options);
    public abstract virtual void SetPropertyCalendar(string schemaNs, string propName, DateTime propValue);
    public abstract virtual void SetPropertyBase64(string schemaNs, string propName, SByte[] propValue, PropertyOptions options);
    public abstract virtual void SetPropertyBase64(string schemaNs, string propName, SByte[] propValue);
    public abstract virtual IXmpIterator Iterator();
    public abstract virtual IXmpIterator Iterator(IteratorOptions options);
    public abstract virtual IXmpIterator Iterator(string schemaNs, string propName, IteratorOptions options);
    public abstract virtual void Sort();
    public abstract virtual void Normalize(ParseOptions options);
    public abstract virtual string DumpObject();
}
public interface iTextSharp.xmp.IXmpSchemaRegistry {
    public abstract virtual string RegisterNamespace(string namespaceUri, string suggestedPrefix);
    public abstract virtual string GetNamespacePrefix(string namespaceUri);
    public abstract virtual string GetNamespaceUri(string namespacePrefix);
    public abstract virtual IDictionary GetNamespaces();
    public abstract virtual IDictionary GetPrefixes();
    public abstract virtual void DeleteNamespace(string namespaceUri);
    public abstract virtual IXmpAliasInfo ResolveAlias(string aliasNs, string aliasProp);
    public abstract virtual IXmpAliasInfo[] FindAliases(string aliasNs);
    public abstract virtual IXmpAliasInfo FindAlias(string qname);
    public abstract virtual IDictionary GetAliases();
}
public interface iTextSharp.xmp.IXmpVersionInfo {
    public int Major { get; }
    public int Minor { get; }
    public int Micro { get; }
    public int Build { get; }
    public bool Debug { get; }
    public string Message { get; }
    public abstract virtual int get_Major();
    public abstract virtual int get_Minor();
    public abstract virtual int get_Micro();
    public abstract virtual int get_Build();
    public abstract virtual bool get_Debug();
    public abstract virtual string get_Message();
}
public class iTextSharp.xmp.options.AliasOptions : XmpOptions {
    public static UInt32 PROP_DIRECT;
    public static UInt32 PROP_ARRAY;
    public static UInt32 PROP_ARRAY_ORDERED;
    public static UInt32 PROP_ARRAY_ALTERNATE;
    public static UInt32 PROP_ARRAY_ALT_TEXT;
    public bool Simple { get; }
    public bool Array { get; public set; }
    public bool ArrayOrdered { get; public set; }
    public bool ArrayAlternate { get; public set; }
    public bool ArrayAltText { get; public set; }
    protected internal UInt32 ValidOptions { get; }
    public AliasOptions(UInt32 options);
    public bool get_Simple();
    public bool get_Array();
    public void set_Array(bool value);
    public bool get_ArrayOrdered();
    public void set_ArrayOrdered(bool value);
    public bool get_ArrayAlternate();
    public void set_ArrayAlternate(bool value);
    public bool get_ArrayAltText();
    public void set_ArrayAltText(bool value);
    protected internal virtual UInt32 get_ValidOptions();
    public PropertyOptions ToPropertyOptions();
    protected internal virtual string DefineOptionName(UInt32 option);
}
public class iTextSharp.xmp.options.IteratorOptions : XmpOptions {
    public static UInt32 JUST_CHILDREN;
    public static UInt32 JUST_LEAFNODES;
    public static UInt32 JUST_LEAFNAME;
    public static UInt32 OMIT_QUALIFIERS;
    public bool JustChildren { get; public set; }
    public bool JustLeafname { get; public set; }
    public bool JustLeafnodes { get; public set; }
    public bool OmitQualifiers { get; public set; }
    protected internal UInt32 ValidOptions { get; }
    public bool get_JustChildren();
    public void set_JustChildren(bool value);
    public bool get_JustLeafname();
    public void set_JustLeafname(bool value);
    public bool get_JustLeafnodes();
    public void set_JustLeafnodes(bool value);
    public bool get_OmitQualifiers();
    public void set_OmitQualifiers(bool value);
    protected internal virtual UInt32 get_ValidOptions();
    protected internal virtual string DefineOptionName(UInt32 option);
}
public class iTextSharp.xmp.options.ParseOptions : XmpOptions {
    public static UInt32 REQUIRE_XMP_META;
    public static UInt32 STRICT_ALIASING;
    public static UInt32 FIX_CONTROL_CHARS;
    public static UInt32 ACCEPT_LATIN_1;
    public static UInt32 OMIT_NORMALIZATION;
    public bool RequireXmpMeta { get; public set; }
    public bool StrictAliasing { get; public set; }
    public bool FixControlChars { get; public set; }
    public bool AcceptLatin1 { get; public set; }
    public bool OmitNormalization { get; public set; }
    protected internal UInt32 ValidOptions { get; }
    public bool get_RequireXmpMeta();
    public void set_RequireXmpMeta(bool value);
    public bool get_StrictAliasing();
    public void set_StrictAliasing(bool value);
    public bool get_FixControlChars();
    public void set_FixControlChars(bool value);
    public bool get_AcceptLatin1();
    public void set_AcceptLatin1(bool value);
    public bool get_OmitNormalization();
    public void set_OmitNormalization(bool value);
    protected internal virtual UInt32 get_ValidOptions();
    protected internal virtual string DefineOptionName(UInt32 option);
}
public class iTextSharp.xmp.options.PropertyOptions : XmpOptions {
    public static UInt32 NO_OPTIONS;
    public static UInt32 URI;
    public static UInt32 HAS_QUALIFIERS;
    public static UInt32 QUALIFIER;
    public static UInt32 HAS_LANGUAGE;
    public static UInt32 HAS_TYPE;
    public static UInt32 STRUCT;
    public static UInt32 ARRAY;
    public static UInt32 ARRAY_ORDERED;
    public static UInt32 ARRAY_ALTERNATE;
    public static UInt32 ARRAY_ALT_TEXT;
    public static UInt32 SCHEMA_NODE;
    public static UInt32 DELETE_EXISTING;
    public static int SEPARATE_NODE;
    public bool Uri { get; public set; }
    public bool HasQualifiers { get; public set; }
    public bool Qualifier { get; public set; }
    public bool HasLanguage { get; public set; }
    public bool HasType { get; public set; }
    public bool Struct { get; public set; }
    public bool Array { get; public set; }
    public bool ArrayOrdered { get; public set; }
    public bool ArrayAlternate { get; public set; }
    public bool ArrayAltText { get; public set; }
    public bool SchemaNode { get; public set; }
    public bool CompositeProperty { get; }
    public bool Simple { get; }
    public bool OnlyArrayOptions { get; }
    protected internal UInt32 ValidOptions { get; }
    public PropertyOptions(UInt32 options);
    public bool get_Uri();
    public void set_Uri(bool value);
    public bool get_HasQualifiers();
    public void set_HasQualifiers(bool value);
    public bool get_Qualifier();
    public void set_Qualifier(bool value);
    public bool get_HasLanguage();
    public void set_HasLanguage(bool value);
    public bool get_HasType();
    public void set_HasType(bool value);
    public bool get_Struct();
    public void set_Struct(bool value);
    public bool get_Array();
    public void set_Array(bool value);
    public bool get_ArrayOrdered();
    public void set_ArrayOrdered(bool value);
    public bool get_ArrayAlternate();
    public void set_ArrayAlternate(bool value);
    public bool get_ArrayAltText();
    public void set_ArrayAltText(bool value);
    public bool get_SchemaNode();
    public void set_SchemaNode(bool value);
    public bool get_CompositeProperty();
    public bool get_Simple();
    public bool get_OnlyArrayOptions();
    protected internal virtual UInt32 get_ValidOptions();
    public bool EqualArrayTypes(PropertyOptions options);
    public void MergeWith(PropertyOptions options);
    protected internal virtual string DefineOptionName(UInt32 option);
    protected internal virtual void AssertConsistency(UInt32 options);
}
public class iTextSharp.xmp.options.SerializeOptions : XmpOptions {
    public static UInt32 OMIT_PACKET_WRAPPER;
    public static UInt32 READONLY_PACKET;
    public static UInt32 USE_COMPACT_FORMAT;
    public static UInt32 USE_CANONICAL_FORMAT;
    public static UInt32 INCLUDE_THUMBNAIL_PAD;
    public static UInt32 EXACT_PACKET_LENGTH;
    public static UInt32 OMIT_XMPMETA_ELEMENT;
    public static UInt32 SORT;
    private static UInt32 LITTLEENDIAN_BIT;
    private static UInt32 UTF16_BIT;
    public static UInt32 ENCODE_UTF8;
    public static UInt32 ENCODE_UTF16BE;
    public static UInt32 ENCODE_UTF16LE;
    private static UInt32 ENCODING_MASK;
    private int _baseIndent;
    private string _indent;
    private string _newline;
    private bool _omitVersionAttribute;
    private int _padding;
    public bool OmitPacketWrapper { get; public set; }
    public bool OmitXmpMetaElement { get; public set; }
    public bool ReadOnlyPacket { get; public set; }
    public bool UseCompactFormat { get; public set; }
    public bool UseCanonicalFormat { get; public set; }
    public bool IncludeThumbnailPad { get; public set; }
    public bool ExactPacketLength { get; public set; }
    public bool Sort { get; public set; }
    public bool EncodeUtf16Be { get; public set; }
    public bool EncodeUtf16Le { get; public set; }
    public int BaseIndent { get; public set; }
    public string Indent { get; public set; }
    public string Newline { get; public set; }
    public int Padding { get; public set; }
    public bool OmitVersionAttribute { get; }
    public string Encoding { get; }
    protected internal UInt32 ValidOptions { get; }
    public SerializeOptions(UInt32 options);
    public bool get_OmitPacketWrapper();
    public void set_OmitPacketWrapper(bool value);
    public bool get_OmitXmpMetaElement();
    public void set_OmitXmpMetaElement(bool value);
    public bool get_ReadOnlyPacket();
    public void set_ReadOnlyPacket(bool value);
    public bool get_UseCompactFormat();
    public void set_UseCompactFormat(bool value);
    public bool get_UseCanonicalFormat();
    public void set_UseCanonicalFormat(bool value);
    public bool get_IncludeThumbnailPad();
    public void set_IncludeThumbnailPad(bool value);
    public bool get_ExactPacketLength();
    public void set_ExactPacketLength(bool value);
    public bool get_Sort();
    public void set_Sort(bool value);
    public bool get_EncodeUtf16Be();
    public void set_EncodeUtf16Be(bool value);
    public bool get_EncodeUtf16Le();
    public void set_EncodeUtf16Le(bool value);
    public int get_BaseIndent();
    public void set_BaseIndent(int value);
    public string get_Indent();
    public void set_Indent(string value);
    public string get_Newline();
    public void set_Newline(string value);
    public int get_Padding();
    public void set_Padding(int value);
    public bool get_OmitVersionAttribute();
    public string get_Encoding();
    protected internal virtual UInt32 get_ValidOptions();
    public object Clone();
    protected internal virtual string DefineOptionName(UInt32 option);
}
public abstract class iTextSharp.xmp.options.XmpOptions : object {
    private IDictionary _optionNames;
    private UInt32 _options;
    public UInt32 Options { get; public set; }
    public string OptionsString { get; }
    protected internal UInt32 ValidOptions { get; }
    public XmpOptions(UInt32 options);
    public virtual UInt32 get_Options();
    public virtual void set_Options(UInt32 value);
    public virtual string get_OptionsString();
    protected internal abstract virtual UInt32 get_ValidOptions();
    public virtual void Clear();
    public virtual bool IsExactly(UInt32 optionBits);
    public virtual bool ContainsAllOptions(UInt32 optionBits);
    public virtual bool ContainsOneOf(UInt32 optionBits);
    protected internal virtual bool GetOption(UInt32 optionBit);
    public virtual void SetOption(UInt32 optionBits, bool value);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public virtual string ToString();
    protected internal abstract virtual string DefineOptionName(UInt32 option);
    protected internal virtual void AssertConsistency(UInt32 options);
    private void AssertOptionsValid(UInt32 options);
    private string GetOptionName(UInt32 option);
    private IDictionary ProcureOptionNames();
}
public interface iTextSharp.xmp.properties.IXmpAliasInfo {
    public string Namespace { get; }
    public string Prefix { get; }
    public string PropName { get; }
    public AliasOptions AliasForm { get; }
    public abstract virtual string get_Namespace();
    public abstract virtual string get_Prefix();
    public abstract virtual string get_PropName();
    public abstract virtual AliasOptions get_AliasForm();
}
public interface iTextSharp.xmp.properties.IXmpProperty {
    public string Value { get; }
    public PropertyOptions Options { get; }
    public string Language { get; }
    public abstract virtual string get_Value();
    public abstract virtual PropertyOptions get_Options();
    public abstract virtual string get_Language();
}
public interface iTextSharp.xmp.properties.IXmpPropertyInfo {
    public string Namespace { get; }
    public string Path { get; }
    public abstract virtual string get_Namespace();
    public abstract virtual string get_Path();
}
public class iTextSharp.xmp.XmpCalendar : object {
    private DateTime _dateTime;
    private TimeZone _timeZone;
    public DateTime DateTime { get; public set; }
    public TimeZone TimeZone { get; public set; }
    public long TimeInMillis { get; public set; }
    public XmpCalendar(DateTime dt, TimeZone tz);
    public XmpCalendar(DateTime dt);
    public XmpCalendar(TimeZone tz);
    public virtual DateTime get_DateTime();
    public virtual void set_DateTime(DateTime value);
    public virtual TimeZone get_TimeZone();
    public virtual void set_TimeZone(TimeZone value);
    public virtual long get_TimeInMillis();
    public virtual void set_TimeInMillis(long value);
}
public class iTextSharp.xmp.XmpConst : object {
    public static string NS_XML;
    public static string NS_RDF;
    public static string NS_DC;
    public static string NS_IPTCCORE;
    public static string NS_IPTCEXT;
    public static string NS_DICOM;
    public static string NS_PLUS;
    public static string NS_X;
    public static string NS_IX;
    public static string NS_XMP;
    public static string NS_XMP_RIGHTS;
    public static string NS_XMP_MM;
    public static string NS_XMP_BJ;
    public static string NS_XMP_NOTE;
    public static string NS_PDF;
    public static string NS_PDFX;
    public static string NS_PDFX_ID;
    public static string NS_PDFA_SCHEMA;
    public static string NS_PDFA_PROPERTY;
    public static string NS_PDFA_TYPE;
    public static string NS_PDFA_FIELD;
    public static string NS_PDFA_ID;
    public static string NS_PDFUA_ID;
    public static string NS_PDFA_EXTENSION;
    public static string NS_PHOTOSHOP;
    public static string NS_PSALBUM;
    public static string NS_EXIF;
    public static string NS_EXIFX;
    public static string NS_EXIF_AUX;
    public static string NS_TIFF;
    public static string NS_PNG;
    public static string NS_JPEG;
    public static string NS_JP2K;
    public static string NS_CAMERARAW;
    public static string NS_ADOBESTOCKPHOTO;
    public static string NS_CREATOR_ATOM;
    public static string NS_ASF;
    public static string NS_WAV;
    public static string NS_BWF;
    public static string NS_RIFFINFO;
    public static string NS_SCRIPT;
    public static string NS_TXMP;
    public static string NS_SWF;
    public static string NS_DM;
    public static string NS_TRANSIENT;
    public static string NS_DC_DEPRECATED;
    public static string TYPE_IDENTIFIERQUAL;
    public static string TYPE_DIMENSIONS;
    public static string TYPE_TEXT;
    public static string TYPE_PAGEDFILE;
    public static string TYPE_GRAPHICS;
    public static string TYPE_IMAGE;
    public static string TYPE_FONT;
    public static string TYPE_RESOURCEEVENT;
    public static string TYPE_RESOURCEREF;
    public static string TYPE_ST_VERSION;
    public static string TYPE_ST_JOB;
    public static string TYPE_MANIFESTITEM;
    public static string TRUESTR;
    public static string FALSESTR;
    public static int ARRAY_LAST_ITEM;
    public static string ARRAY_ITEM_NAME;
    public static string X_DEFAULT;
    public static string XML_LANG;
    public static string RDF_TYPE;
    public static string XMP_PI;
    public static string TAG_XMPMETA;
    public static string TAG_XAPMETA;
}
public static class iTextSharp.xmp.XmpDateTimeFactory : object {
    public static IXmpDateTime CurrentDateTime { get; }
    public static IXmpDateTime get_CurrentDateTime();
    public static IXmpDateTime CreateFromCalendar(XmpCalendar calendar);
    public static IXmpDateTime Create();
    public static IXmpDateTime Create(int year, int month, int day);
    public static IXmpDateTime Create(int year, int month, int day, int hour, int minute, int second, int nanoSecond);
    public static IXmpDateTime CreateFromIso8601(string strValue);
    public static IXmpDateTime SetLocalTimeZone(IXmpDateTime dateTime);
    public static IXmpDateTime ConvertToUtcTime(IXmpDateTime dateTime);
    public static IXmpDateTime ConvertToLocalTime(IXmpDateTime dateTime);
}
public class iTextSharp.xmp.XmpError : object {
    public static int UNKNOWN;
    public static int BADPARAM;
    public static int BADVALUE;
    public static int INTERNALFAILURE;
    public static int BADSCHEMA;
    public static int BADXPATH;
    public static int BADOPTIONS;
    public static int BADINDEX;
    public static int BADSERIALIZE;
    public static int BADXML;
    public static int BADRDF;
    public static int BADXMP;
    public static int BADSTREAM;
}
public class iTextSharp.xmp.XmpException : Exception {
    private int _errorCode;
    public int ErrorCode { get; }
    public XmpException(string message, int errorCode);
    public XmpException(string message, int errorCode, Exception t);
    public virtual int get_ErrorCode();
}
public static class iTextSharp.xmp.XmpMetaFactory : object {
    private static IXmpSchemaRegistry _schema;
    private static IXmpVersionInfo _versionInfo;
    public static IXmpSchemaRegistry SchemaRegistry { get; }
    private static XmpMetaFactory();
    public static IXmpSchemaRegistry get_SchemaRegistry();
    public static IXmpMeta Create();
    public static IXmpMeta Parse(Stream in);
    public static IXmpMeta Parse(Stream in, ParseOptions options);
    public static IXmpMeta ParseFromString(string packet);
    public static IXmpMeta ParseFromString(string packet, ParseOptions options);
    public static IXmpMeta ParseFromBuffer(Byte[] buffer);
    public static IXmpMeta ParseFromBuffer(Byte[] buffer, ParseOptions options);
    public static void Serialize(IXmpMeta xmp, Stream out);
    public static void Serialize(IXmpMeta xmp, Stream out, SerializeOptions options);
    public static Byte[] SerializeToBuffer(IXmpMeta xmp, SerializeOptions options);
    public static string SerializeToString(IXmpMeta xmp, SerializeOptions options);
    private static void AssertImplementation(IXmpMeta xmp);
    public static void Reset();
    public static IXmpVersionInfo GetVersionInfo();
}
public static class iTextSharp.xmp.XmpPathFactory : object {
    public static string ComposeArrayItemPath(string arrayName, int itemIndex);
    public static string ComposeStructFieldPath(string fieldNs, string fieldName);
    public static string ComposeQualifierPath(string qualNs, string qualName);
    public static string ComposeLangSelector(string arrayName, string langName);
    public static string ComposeFieldSelector(string arrayName, string fieldNs, string fieldName, string fieldValue);
    private static void AssertQualNs(string qualNs);
    private static void AssertQualName(string qualName);
    private static void AssertFieldNs(string fieldNs);
    private static void AssertFieldName(string fieldName);
}
public class iTextSharp.xmp.XmpUtils : object {
    public static string CatenateArrayItems(IXmpMeta xmp, string schemaNs, string arrayName, string separator, string quotes, bool allowCommas);
    public static void SeparateArrayItems(IXmpMeta xmp, string schemaNs, string arrayName, string catedStr, PropertyOptions arrayOptions, bool preserveCommas);
    public static void RemoveProperties(IXmpMeta xmp, string schemaNs, string propName, bool doAllProperties, bool includeAliases);
    public static void AppendProperties(IXmpMeta source, IXmpMeta dest, bool doAllProperties, bool replaceOldValues);
    public static void AppendProperties(IXmpMeta source, IXmpMeta dest, bool doAllProperties, bool replaceOldValues, bool deleteEmptyValues);
    public static bool ConvertToBoolean(string value);
    public static string ConvertFromBoolean(bool value);
    public static int ConvertToInteger(string rawValue);
    public static string ConvertFromInteger(int value);
    public static long ConvertToLong(string rawValue);
    public static string ConvertFromLong(long value);
    public static double ConvertToDouble(string rawValue);
    public static string ConvertFromDouble(double value);
    public static IXmpDateTime ConvertToDate(string rawValue);
    public static string ConvertFromDate(IXmpDateTime value);
    public static string EncodeBase64(Byte[] buffer);
    public static Byte[] DecodeBase64(string base64String);
    private static Byte[] GetBytes(string str);
    private static string GetString(Byte[] bytes);
}
public class Org.BouncyCastle.Apache.Bzip2.BZip2Constants : object {
    public static int baseBlockSize;
    public static int MAX_ALPHA_SIZE;
    public static int MAX_CODE_LEN;
    public static int RUNA;
    public static int RUNB;
    public static int N_GROUPS;
    public static int G_SIZE;
    public static int N_ITERS;
    public static int MAX_SELECTORS;
    public static int NUM_OVERSHOOT_BYTES;
    public static Int32[] rNums;
    private static BZip2Constants();
}
public class Org.BouncyCastle.Apache.Bzip2.CBZip2InputStream : Stream {
    private static int START_BLOCK_STATE;
    private static int RAND_PART_A_STATE;
    private static int RAND_PART_B_STATE;
    private static int RAND_PART_C_STATE;
    private static int NO_RAND_PART_A_STATE;
    private static int NO_RAND_PART_B_STATE;
    private static int NO_RAND_PART_C_STATE;
    private int last;
    private int origPtr;
    private int blockSize100k;
    private bool blockRandomised;
    private int bsBuff;
    private int bsLive;
    private CRC mCrc;
    private Boolean[] inUse;
    private int nInUse;
    private Char[] seqToUnseq;
    private Char[] unseqToSeq;
    private Char[] selector;
    private Char[] selectorMtf;
    private Int32[] tt;
    private Char[] ll8;
    private Int32[] unzftab;
    private Int32[][] limit;
    private Int32[][] basev;
    private Int32[][] perm;
    private Int32[] minLens;
    private Stream bsStream;
    private bool streamEnd;
    private int currentChar;
    private int currentState;
    private int storedBlockCRC;
    private int storedCombinedCRC;
    private int computedBlockCRC;
    private int computedCombinedCRC;
    private int i2;
    private int count;
    private int chPrev;
    private int ch2;
    private int i;
    private int tPos;
    private int rNToGo;
    private int rTPos;
    private int j2;
    private char z;
    public bool CanRead { get; }
    public bool CanSeek { get; }
    public bool CanWrite { get; }
    public long Length { get; }
    public long Position { get; public set; }
    public CBZip2InputStream(Stream zStream);
    private static void Cadvise();
    private static void BadBGLengths();
    private static void BitStreamEOF();
    private static void CompressedStreamEOF();
    private void MakeMaps();
    internal static Int32[][] InitIntArray(int n1, int n2);
    internal static Char[][] InitCharArray(int n1, int n2);
    public virtual int ReadByte();
    private void Initialize();
    private void InitBlock();
    private void EndBlock();
    private void Complete();
    private static void BlockOverrun();
    private static void BadBlockHeader();
    private static void CrcError();
    private void BsFinishedWithStream();
    private void BsSetStream(Stream f);
    private int BsR(int n);
    private char BsGetUChar();
    private int BsGetint();
    private int BsGetIntVS(int numBits);
    private int BsGetInt32();
    private void HbCreateDecodeTables(Int32[] limit, Int32[] basev, Int32[] perm, Char[] length, int minLen, int maxLen, int alphaSize);
    private void RecvDecodingTables();
    private void GetAndMoveToFrontDecode();
    private void SetupBlock();
    private void SetupRandPartA();
    private void SetupNoRandPartA();
    private void SetupRandPartB();
    private void SetupRandPartC();
    private void SetupNoRandPartB();
    private void SetupNoRandPartC();
    private void SetDecompressStructureSizes(int newSize100k);
    public virtual void Flush();
    public virtual int Read(Byte[] buffer, int offset, int count);
    public virtual long Seek(long offset, SeekOrigin origin);
    public virtual void SetLength(long value);
    public virtual void Write(Byte[] buffer, int offset, int count);
    public virtual bool get_CanRead();
    public virtual bool get_CanSeek();
    public virtual bool get_CanWrite();
    public virtual long get_Length();
    public virtual long get_Position();
    public virtual void set_Position(long value);
}
public class Org.BouncyCastle.Apache.Bzip2.CBZip2OutputStream : Stream {
    protected static int SETMASK;
    protected static int CLEARMASK;
    protected static int GREATER_ICOST;
    protected static int LESSER_ICOST;
    protected static int SMALL_THRESH;
    protected static int DEPTH_THRESH;
    protected static int QSORT_STACK_SIZE;
    private bool finished;
    private int last;
    private int origPtr;
    private int blockSize100k;
    private bool blockRandomised;
    private int bytesOut;
    private int bsBuff;
    private int bsLive;
    private CRC mCrc;
    private Boolean[] inUse;
    private int nInUse;
    private Char[] seqToUnseq;
    private Char[] unseqToSeq;
    private Char[] selector;
    private Char[] selectorMtf;
    private Char[] block;
    private Int32[] quadrant;
    private Int32[] zptr;
    private Int16[] szptr;
    private Int32[] ftab;
    private int nMTF;
    private Int32[] mtfFreq;
    private int workFactor;
    private int workDone;
    private int workLimit;
    private bool firstAttempt;
    private int nBlocksRandomised;
    private int currentChar;
    private int runLength;
    private bool closed;
    private int blockCRC;
    private int combinedCRC;
    private int allowableBlockSize;
    private Stream bsStream;
    private Int32[] incs;
    public bool CanRead { get; }
    public bool CanSeek { get; }
    public bool CanWrite { get; }
    public long Length { get; }
    public long Position { get; public set; }
    public CBZip2OutputStream(Stream inStream);
    public CBZip2OutputStream(Stream inStream, int inBlockSize);
    private static void Panic();
    private void MakeMaps();
    protected static void HbMakeCodeLengths(Char[] len, Int32[] freq, int alphaSize, int maxLen);
    public virtual void WriteByte(byte bv);
    private void WriteRun();
    protected virtual void Finalize();
    public virtual void Close();
    public void Finish();
    public virtual void Flush();
    private void Initialize();
    private void InitBlock();
    private void EndBlock();
    private void EndCompression();
    private void HbAssignCodes(Int32[] code, Char[] length, int minLen, int maxLen, int alphaSize);
    private void BsSetStream(Stream f);
    private void BsFinishedWithStream();
    private void BsW(int n, int v);
    private void BsPutUChar(int c);
    private void BsPutint(int u);
    private void BsPutIntVS(int numBits, int c);
    private void SendMTFValues();
    private void MoveToFrontCodeAndSend();
    private void SimpleSort(int lo, int hi, int d);
    private void Vswap(int p1, int p2, int n);
    private char Med3(char a, char b, char c);
    private void QSort3(int loSt, int hiSt, int dSt);
    private void MainSort();
    private void RandomiseBlock();
    private void DoReversibleTransformation();
    private bool FullGtU(int i1, int i2);
    private void AllocateCompressStructures();
    private void GenerateMTFValues();
    public virtual int Read(Byte[] buffer, int offset, int count);
    public virtual long Seek(long offset, SeekOrigin origin);
    public virtual void SetLength(long value);
    public virtual void Write(Byte[] buffer, int offset, int count);
    public virtual bool get_CanRead();
    public virtual bool get_CanSeek();
    public virtual bool get_CanWrite();
    public virtual long get_Length();
    public virtual long get_Position();
    public virtual void set_Position(long value);
}
internal class Org.BouncyCastle.Apache.Bzip2.CRC : object {
    public static Int32[] crc32Table;
    internal int globalCrc;
    private static CRC();
    internal void InitialiseCRC();
    internal int GetFinalCRC();
    internal int GetGlobalCRC();
    internal void SetGlobalCRC(int newCrc);
    internal void UpdateCRC(int inCh);
}
public abstract class Org.BouncyCastle.Asn1.Asn1Encodable : object {
    public static string Der;
    public static string Ber;
    public Byte[] GetEncoded();
    public Byte[] GetEncoded(string encoding);
    public Byte[] GetDerEncoded();
    public sealed virtual int GetHashCode();
    public sealed virtual bool Equals(object obj);
    public abstract virtual Asn1Object ToAsn1Object();
}
[DefaultMemberAttribute("Item")]
public class Org.BouncyCastle.Asn1.Asn1EncodableVector : object {
    private IList v;
    public Asn1Encodable Item { get; }
    [ObsoleteAttribute("Use 'Count' property instead")]
public int Size { get; }
    public int Count { get; }
    public Asn1EncodableVector(Asn1Encodable[] v);
    public static Asn1EncodableVector FromEnumerable(IEnumerable e);
    public void Add(Asn1Encodable[] objs);
    public void AddOptional(Asn1Encodable[] objs);
    public Asn1Encodable get_Item(int index);
    [ObsoleteAttribute("Use 'object[index]' syntax instead")]
public Asn1Encodable Get(int index);
    public int get_Size();
    public int get_Count();
    public sealed virtual IEnumerator GetEnumerator();
}
public class Org.BouncyCastle.Asn1.Asn1Exception : IOException {
    public Asn1Exception(string message);
    public Asn1Exception(string message, Exception exception);
}
public abstract class Org.BouncyCastle.Asn1.Asn1Generator : object {
    private Stream _out;
    protected Stream Out { get; }
    protected Asn1Generator(Stream outStream);
    protected Stream get_Out();
    public abstract virtual void AddObject(Asn1Encodable obj);
    public abstract virtual Stream GetRawOutputStream();
    public abstract virtual void Close();
}
public class Org.BouncyCastle.Asn1.Asn1InputStream : FilterStream {
    private int limit;
    private Byte[][] tmpBuffers;
    public Asn1InputStream(Stream inputStream);
    public Asn1InputStream(Stream inputStream, int limit);
    public Asn1InputStream(Byte[] input);
    internal static int FindLimit(Stream input);
    private Asn1Object BuildObject(int tag, int tagNo, int length);
    internal Asn1EncodableVector BuildEncodableVector();
    internal virtual Asn1EncodableVector BuildDerEncodableVector(DefiniteLengthInputStream dIn);
    internal virtual DerSequence CreateDerSequence(DefiniteLengthInputStream dIn);
    internal virtual DerSet CreateDerSet(DefiniteLengthInputStream dIn);
    public Asn1Object ReadObject();
    internal static int ReadTagNumber(Stream s, int tag);
    internal static int ReadLength(Stream s, int limit);
    internal static Byte[] GetBuffer(DefiniteLengthInputStream defIn, Byte[][] tmpBuffers);
    internal static Asn1Object CreatePrimitiveDerObject(int tagNo, DefiniteLengthInputStream defIn, Byte[][] tmpBuffers);
}
public abstract class Org.BouncyCastle.Asn1.Asn1Null : Asn1Object {
    public virtual string ToString();
}
public abstract class Org.BouncyCastle.Asn1.Asn1Object : Asn1Encodable {
    public static Asn1Object FromByteArray(Byte[] data);
    public static Asn1Object FromStream(Stream inStr);
    public sealed virtual Asn1Object ToAsn1Object();
    internal abstract virtual void Encode(DerOutputStream derOut);
    protected abstract virtual bool Asn1Equals(Asn1Object asn1Object);
    protected abstract virtual int Asn1GetHashCode();
    internal bool CallAsn1Equals(Asn1Object obj);
    internal int CallAsn1GetHashCode();
}
public abstract class Org.BouncyCastle.Asn1.Asn1OctetString : Asn1Object {
    internal Byte[] str;
    public Asn1OctetStringParser Parser { get; }
    internal Asn1OctetString(Byte[] str);
    internal Asn1OctetString(Asn1Encodable obj);
    public static Asn1OctetString GetInstance(Asn1TaggedObject obj, bool isExplicit);
    public static Asn1OctetString GetInstance(object obj);
    public sealed virtual Stream GetOctetStream();
    public Asn1OctetStringParser get_Parser();
    public virtual Byte[] GetOctets();
    protected virtual int Asn1GetHashCode();
    protected virtual bool Asn1Equals(Asn1Object asn1Object);
    public virtual string ToString();
}
public interface Org.BouncyCastle.Asn1.Asn1OctetStringParser {
    public abstract virtual Stream GetOctetStream();
}
public class Org.BouncyCastle.Asn1.Asn1OutputStream : DerOutputStream {
    public Asn1OutputStream(Stream os);
    [ObsoleteAttribute("Use version taking an Asn1Encodable arg instead")]
public virtual void WriteObject(object obj);
}
public class Org.BouncyCastle.Asn1.Asn1ParsingException : InvalidOperationException {
    public Asn1ParsingException(string message);
    public Asn1ParsingException(string message, Exception exception);
}
[DefaultMemberAttribute("Item")]
public abstract class Org.BouncyCastle.Asn1.Asn1Sequence : Asn1Object {
    private IList seq;
    public Asn1SequenceParser Parser { get; }
    public Asn1Encodable Item { get; }
    [ObsoleteAttribute("Use 'Count' property instead")]
public int Size { get; }
    public int Count { get; }
    protected internal Asn1Sequence(int capacity);
    public static Asn1Sequence GetInstance(object obj);
    public static Asn1Sequence GetInstance(Asn1TaggedObject obj, bool explicitly);
    public virtual IEnumerator GetEnumerator();
    [ObsoleteAttribute("Use GetEnumerator() instead")]
public IEnumerator GetObjects();
    public virtual Asn1SequenceParser get_Parser();
    public virtual Asn1Encodable get_Item(int index);
    [ObsoleteAttribute("Use 'object[index]' syntax instead")]
public Asn1Encodable GetObjectAt(int index);
    public int get_Size();
    public virtual int get_Count();
    protected virtual int Asn1GetHashCode();
    protected virtual bool Asn1Equals(Asn1Object asn1Object);
    private Asn1Encodable GetCurrent(IEnumerator e);
    protected internal void AddObject(Asn1Encodable obj);
    public virtual string ToString();
}
public interface Org.BouncyCastle.Asn1.Asn1SequenceParser {
    public abstract virtual IAsn1Convertible ReadObject();
}
[DefaultMemberAttribute("Item")]
public abstract class Org.BouncyCastle.Asn1.Asn1Set : Asn1Object {
    private IList _set;
    public Asn1Encodable Item { get; }
    [ObsoleteAttribute("Use 'Count' property instead")]
public int Size { get; }
    public int Count { get; }
    public Asn1SetParser Parser { get; }
    protected internal Asn1Set(int capacity);
    public static Asn1Set GetInstance(object obj);
    public static Asn1Set GetInstance(Asn1TaggedObject obj, bool explicitly);
    public virtual IEnumerator GetEnumerator();
    [ObsoleteAttribute("Use GetEnumerator() instead")]
public IEnumerator GetObjects();
    public virtual Asn1Encodable get_Item(int index);
    [ObsoleteAttribute("Use 'object[index]' syntax instead")]
public Asn1Encodable GetObjectAt(int index);
    public int get_Size();
    public virtual int get_Count();
    public virtual Asn1Encodable[] ToArray();
    public Asn1SetParser get_Parser();
    protected virtual int Asn1GetHashCode();
    protected virtual bool Asn1Equals(Asn1Object asn1Object);
    private Asn1Encodable GetCurrent(IEnumerator e);
    private bool LessThanOrEqual(Byte[] a, Byte[] b);
    protected internal void Sort();
    protected internal void AddObject(Asn1Encodable obj);
    public virtual string ToString();
}
public interface Org.BouncyCastle.Asn1.Asn1SetParser {
    public abstract virtual IAsn1Convertible ReadObject();
}
public class Org.BouncyCastle.Asn1.Asn1StreamParser : object {
    private Stream _in;
    private int _limit;
    private Byte[][] tmpBuffers;
    public Asn1StreamParser(Stream inStream);
    public Asn1StreamParser(Stream inStream, int limit);
    public Asn1StreamParser(Byte[] encoding);
    internal IAsn1Convertible ReadIndef(int tagValue);
    internal IAsn1Convertible ReadImplicit(bool constructed, int tag);
    internal Asn1Object ReadTaggedObject(bool constructed, int tag);
    public virtual IAsn1Convertible ReadObject();
    private void Set00Check(bool enabled);
    internal Asn1EncodableVector ReadVector();
}
public abstract class Org.BouncyCastle.Asn1.Asn1TaggedObject : Asn1Object {
    internal int tagNo;
    internal bool explicitly;
    internal Asn1Encodable obj;
    public int TagNo { get; }
    protected Asn1TaggedObject(int tagNo, Asn1Encodable obj);
    protected Asn1TaggedObject(bool explicitly, int tagNo, Asn1Encodable obj);
    public static Asn1TaggedObject GetInstance(Asn1TaggedObject obj, bool explicitly);
    public static Asn1TaggedObject GetInstance(object obj);
    protected virtual bool Asn1Equals(Asn1Object asn1Object);
    protected virtual int Asn1GetHashCode();
    public sealed virtual int get_TagNo();
    public bool IsExplicit();
    public bool IsEmpty();
    public Asn1Object GetObject();
    public sealed virtual IAsn1Convertible GetObjectParser(int tag, bool isExplicit);
    public virtual string ToString();
}
public interface Org.BouncyCastle.Asn1.Asn1TaggedObjectParser {
    public int TagNo { get; }
    public abstract virtual int get_TagNo();
    public abstract virtual IAsn1Convertible GetObjectParser(int tag, bool isExplicit);
}
public class Org.BouncyCastle.Asn1.Asn1Tags : object {
    public static int Boolean;
    public static int Integer;
    public static int BitString;
    public static int OctetString;
    public static int Null;
    public static int ObjectIdentifier;
    public static int External;
    public static int Enumerated;
    public static int Sequence;
    public static int SequenceOf;
    public static int Set;
    public static int SetOf;
    public static int NumericString;
    public static int PrintableString;
    public static int T61String;
    public static int VideotexString;
    public static int IA5String;
    public static int UtcTime;
    public static int GeneralizedTime;
    public static int GraphicString;
    public static int VisibleString;
    public static int GeneralString;
    public static int UniversalString;
    public static int BmpString;
    public static int Utf8String;
    public static int Constructed;
    public static int Application;
    public static int Tagged;
}
public abstract class Org.BouncyCastle.Asn1.BC.BCObjectIdentifiers : object {
    public static DerObjectIdentifier bc;
    public static DerObjectIdentifier bc_pbe;
    public static DerObjectIdentifier bc_pbe_sha1;
    public static DerObjectIdentifier bc_pbe_sha256;
    public static DerObjectIdentifier bc_pbe_sha384;
    public static DerObjectIdentifier bc_pbe_sha512;
    public static DerObjectIdentifier bc_pbe_sha224;
    public static DerObjectIdentifier bc_pbe_sha1_pkcs5;
    public static DerObjectIdentifier bc_pbe_sha1_pkcs12;
    public static DerObjectIdentifier bc_pbe_sha256_pkcs5;
    public static DerObjectIdentifier bc_pbe_sha256_pkcs12;
    public static DerObjectIdentifier bc_pbe_sha1_pkcs12_aes128_cbc;
    public static DerObjectIdentifier bc_pbe_sha1_pkcs12_aes192_cbc;
    public static DerObjectIdentifier bc_pbe_sha1_pkcs12_aes256_cbc;
    public static DerObjectIdentifier bc_pbe_sha256_pkcs12_aes128_cbc;
    public static DerObjectIdentifier bc_pbe_sha256_pkcs12_aes192_cbc;
    public static DerObjectIdentifier bc_pbe_sha256_pkcs12_aes256_cbc;
    private static BCObjectIdentifiers();
}
public class Org.BouncyCastle.Asn1.BerApplicationSpecific : DerApplicationSpecific {
    public BerApplicationSpecific(int tagNo, Asn1EncodableVector vec);
}
public class Org.BouncyCastle.Asn1.BerApplicationSpecificParser : object {
    private int tag;
    private Asn1StreamParser parser;
    internal BerApplicationSpecificParser(int tag, Asn1StreamParser parser);
    public sealed virtual IAsn1Convertible ReadObject();
    public sealed virtual Asn1Object ToAsn1Object();
}
public class Org.BouncyCastle.Asn1.BerGenerator : Asn1Generator {
    private bool _tagged;
    private bool _isExplicit;
    private int _tagNo;
    protected BerGenerator(Stream outStream);
    public BerGenerator(Stream outStream, int tagNo, bool isExplicit);
    public virtual void AddObject(Asn1Encodable obj);
    public virtual Stream GetRawOutputStream();
    public virtual void Close();
    private void WriteHdr(int tag);
    protected void WriteBerHeader(int tag);
    protected void WriteBerBody(Stream contentStream);
    protected void WriteBerEnd();
}
public class Org.BouncyCastle.Asn1.BerNull : DerNull {
    public static BerNull Instance;
    private BerNull(int dummy);
    private static BerNull();
    internal virtual void Encode(DerOutputStream derOut);
}
public class Org.BouncyCastle.Asn1.BerOctetString : DerOctetString {
    private static int MaxLength;
    private IEnumerable octs;
    public BerOctetString(Byte[] str);
    public BerOctetString(IEnumerable octets);
    public BerOctetString(Asn1Object obj);
    public BerOctetString(Asn1Encodable obj);
    public static BerOctetString FromSequence(Asn1Sequence seq);
    private static Byte[] ToBytes(IEnumerable octs);
    public virtual Byte[] GetOctets();
    public sealed virtual IEnumerator GetEnumerator();
    [ObsoleteAttribute("Use GetEnumerator() instead")]
public IEnumerator GetObjects();
    private IList GenerateOcts();
    internal virtual void Encode(DerOutputStream derOut);
}
public class Org.BouncyCastle.Asn1.BerOctetStringGenerator : BerGenerator {
    public BerOctetStringGenerator(Stream outStream);
    public BerOctetStringGenerator(Stream outStream, int tagNo, bool isExplicit);
    public Stream GetOctetOutputStream();
    public Stream GetOctetOutputStream(int bufSize);
    public Stream GetOctetOutputStream(Byte[] buf);
}
public class Org.BouncyCastle.Asn1.BerOctetStringParser : object {
    private Asn1StreamParser _parser;
    internal BerOctetStringParser(Asn1StreamParser parser);
    public sealed virtual Stream GetOctetStream();
    public sealed virtual Asn1Object ToAsn1Object();
}
public class Org.BouncyCastle.Asn1.BerOutputStream : DerOutputStream {
    public BerOutputStream(Stream os);
    [ObsoleteAttribute("Use version taking an Asn1Encodable arg instead")]
public virtual void WriteObject(object obj);
}
public class Org.BouncyCastle.Asn1.BerSequence : DerSequence {
    public static BerSequence Empty;
    public BerSequence(Asn1Encodable obj);
    public BerSequence(Asn1Encodable[] v);
    public BerSequence(Asn1EncodableVector v);
    private static BerSequence();
    public static BerSequence FromVector(Asn1EncodableVector v);
    internal virtual void Encode(DerOutputStream derOut);
}
public class Org.BouncyCastle.Asn1.BerSequenceGenerator : BerGenerator {
    public BerSequenceGenerator(Stream outStream);
    public BerSequenceGenerator(Stream outStream, int tagNo, bool isExplicit);
}
public class Org.BouncyCastle.Asn1.BerSequenceParser : object {
    private Asn1StreamParser _parser;
    internal BerSequenceParser(Asn1StreamParser parser);
    public sealed virtual IAsn1Convertible ReadObject();
    public sealed virtual Asn1Object ToAsn1Object();
}
public class Org.BouncyCastle.Asn1.BerSet : DerSet {
    public static BerSet Empty;
    public BerSet(Asn1Encodable obj);
    public BerSet(Asn1EncodableVector v);
    internal BerSet(Asn1EncodableVector v, bool needsSorting);
    private static BerSet();
    public static BerSet FromVector(Asn1EncodableVector v);
    internal static BerSet FromVector(Asn1EncodableVector v, bool needsSorting);
    internal virtual void Encode(DerOutputStream derOut);
}
public class Org.BouncyCastle.Asn1.BerSetGenerator : BerGenerator {
    public BerSetGenerator(Stream outStream);
    public BerSetGenerator(Stream outStream, int tagNo, bool isExplicit);
}
public class Org.BouncyCastle.Asn1.BerSetParser : object {
    private Asn1StreamParser _parser;
    internal BerSetParser(Asn1StreamParser parser);
    public sealed virtual IAsn1Convertible ReadObject();
    public sealed virtual Asn1Object ToAsn1Object();
}
public class Org.BouncyCastle.Asn1.BerTaggedObject : DerTaggedObject {
    public BerTaggedObject(int tagNo, Asn1Encodable obj);
    public BerTaggedObject(bool explicitly, int tagNo, Asn1Encodable obj);
    public BerTaggedObject(int tagNo);
    internal virtual void Encode(DerOutputStream derOut);
}
public class Org.BouncyCastle.Asn1.BerTaggedObjectParser : object {
    private bool _constructed;
    private int _tagNumber;
    private Asn1StreamParser _parser;
    public bool IsConstructed { get; }
    public int TagNo { get; }
    [ObsoleteAttribute]
internal BerTaggedObjectParser(int baseTag, int tagNumber, Stream contentStream);
    internal BerTaggedObjectParser(bool constructed, int tagNumber, Asn1StreamParser parser);
    public bool get_IsConstructed();
    public sealed virtual int get_TagNo();
    public sealed virtual IAsn1Convertible GetObjectParser(int tag, bool isExplicit);
    public sealed virtual Asn1Object ToAsn1Object();
}
public class Org.BouncyCastle.Asn1.Cmp.CAKeyUpdAnnContent : Asn1Encodable {
    private CmpCertificate oldWithNew;
    private CmpCertificate newWithOld;
    private CmpCertificate newWithNew;
    public CmpCertificate OldWithNew { get; }
    public CmpCertificate NewWithOld { get; }
    public CmpCertificate NewWithNew { get; }
    private CAKeyUpdAnnContent(Asn1Sequence seq);
    public static CAKeyUpdAnnContent GetInstance(object obj);
    public virtual CmpCertificate get_OldWithNew();
    public virtual CmpCertificate get_NewWithOld();
    public virtual CmpCertificate get_NewWithNew();
    public virtual Asn1Object ToAsn1Object();
}
public class Org.BouncyCastle.Asn1.Cmp.CertConfirmContent : Asn1Encodable {
    private Asn1Sequence content;
    private CertConfirmContent(Asn1Sequence seq);
    public static CertConfirmContent GetInstance(object obj);
    public virtual CertStatus[] ToCertStatusArray();
    public virtual Asn1Object ToAsn1Object();
}
public class Org.BouncyCastle.Asn1.Cmp.CertifiedKeyPair : Asn1Encodable {
    private CertOrEncCert certOrEncCert;
    private EncryptedValue privateKey;
    private PkiPublicationInfo publicationInfo;
    public CertOrEncCert CertOrEncCert { get; }
    public EncryptedValue PrivateKey { get; }
    public PkiPublicationInfo PublicationInfo { get; }
    private CertifiedKeyPair(Asn1Sequence seq);
    public CertifiedKeyPair(CertOrEncCert certOrEncCert);
    public CertifiedKeyPair(CertOrEncCert certOrEncCert, EncryptedValue privateKey, PkiPublicationInfo publicationInfo);
    public static CertifiedKeyPair GetInstance(object obj);
    public virtual CertOrEncCert get_CertOrEncCert();
    public virtual EncryptedValue get_PrivateKey();
    public virtual PkiPublicationInfo get_PublicationInfo();
    public virtual Asn1Object ToAsn1Object();
}
public class Org.BouncyCastle.Asn1.Cmp.CertOrEncCert : Asn1Encodable {
    private CmpCertificate certificate;
    private EncryptedValue encryptedCert;
    public CmpCertificate Certificate { get; }
    public EncryptedValue EncryptedCert { get; }
    private CertOrEncCert(Asn1TaggedObject tagged);
    public CertOrEncCert(CmpCertificate certificate);
    public CertOrEncCert(EncryptedValue encryptedCert);
    public static CertOrEncCert GetInstance(object obj);
    public virtual CmpCertificate get_Certificate();
    public virtual EncryptedValue get_EncryptedCert();
    public virtual Asn1Object ToAsn1Object();
}
public class Org.BouncyCastle.Asn1.Cmp.CertRepMessage : Asn1Encodable {
    private Asn1Sequence caPubs;
    private Asn1Sequence response;
    private CertRepMessage(Asn1Sequence seq);
    public CertRepMessage(CmpCertificate[] caPubs, CertResponse[] response);
    public static CertRepMessage GetInstance(object obj);
    public virtual CmpCertificate[] GetCAPubs();
    public virtual CertResponse[] GetResponse();
    public virtual Asn1Object ToAsn1Object();
}
public class Org.BouncyCastle.Asn1.Cmp.CertResponse : Asn1Encodable {
    private DerInteger certReqId;
    private PkiStatusInfo status;
    private CertifiedKeyPair certifiedKeyPair;
    private Asn1OctetString rspInfo;
    public DerInteger CertReqID { get; }
    public PkiStatusInfo Status { get; }
    public CertifiedKeyPair CertifiedKeyPair { get; }
    private CertResponse(Asn1Sequence seq);
    public CertResponse(DerInteger certReqId, PkiStatusInfo status);
    public CertResponse(DerInteger certReqId, PkiStatusInfo status, CertifiedKeyPair certifiedKeyPair, Asn1OctetString rspInfo);
    public static CertResponse GetInstance(object obj);
    public virtual DerInteger get_CertReqID();
    public virtual PkiStatusInfo get_Status();
    public virtual CertifiedKeyPair get_CertifiedKeyPair();
    public virtual Asn1Object ToAsn1Object();
}
public class Org.BouncyCastle.Asn1.Cmp.CertStatus : Asn1Encodable {
    private Asn1OctetString certHash;
    private DerInteger certReqId;
    private PkiStatusInfo statusInfo;
    public Asn1OctetString CertHash { get; }
    public DerInteger CertReqID { get; }
    public PkiStatusInfo StatusInfo { get; }
    private CertStatus(Asn1Sequence seq);
    public CertStatus(Byte[] certHash, BigInteger certReqId);
    public CertStatus(Byte[] certHash, BigInteger certReqId, PkiStatusInfo statusInfo);
    public static CertStatus GetInstance(object obj);
    public virtual Asn1OctetString get_CertHash();
    public virtual DerInteger get_CertReqID();
    public virtual PkiStatusInfo get_StatusInfo();
    public virtual Asn1Object ToAsn1Object();
}
public class Org.BouncyCastle.Asn1.Cmp.Challenge : Asn1Encodable {
    private AlgorithmIdentifier owf;
    private Asn1OctetString witness;
    private Asn1OctetString challenge;
    public AlgorithmIdentifier Owf { get; }
    private Challenge(Asn1Sequence seq);
    public static Challenge GetInstance(object obj);
    public virtual AlgorithmIdentifier get_Owf();
    public virtual Asn1Object ToAsn1Object();
}
public class Org.BouncyCastle.Asn1.Cmp.CmpCertificate : Asn1Encodable {
    private X509CertificateStructure x509v3PKCert;
    private AttributeCertificate x509v2AttrCert;
    public bool IsX509v3PKCert { get; }
    public X509CertificateStructure X509v3PKCert { get; }
    public AttributeCertificate X509v2AttrCert { get; }
    public CmpCertificate(AttributeCertificate x509v2AttrCert);
    public CmpCertificate(X509CertificateStructure x509v3PKCert);
    public static CmpCertificate GetInstance(object obj);
    public virtual bool get_IsX509v3PKCert();
    public virtual X509CertificateStructure get_X509v3PKCert();
    public virtual AttributeCertificate get_X509v2AttrCert();
    public virtual Asn1Object ToAsn1Object();
}
public abstract class Org.BouncyCastle.Asn1.Cmp.CmpObjectIdentifiers : object {
    public static DerObjectIdentifier passwordBasedMac;
    public static DerObjectIdentifier dhBasedMac;
    public static DerObjectIdentifier it_caProtEncCert;
    public static DerObjectIdentifier it_signKeyPairTypes;
    public static DerObjectIdentifier it_encKeyPairTypes;
    public static DerObjectIdentifier it_preferredSymAlg;
    public static DerObjectIdentifier it_caKeyUpdateInfo;
    public static DerObjectIdentifier it_currentCRL;
    public static DerObjectIdentifier it_unsupportedOIDs;
    public static DerObjectIdentifier it_keyPairParamReq;
    public static DerObjectIdentifier it_keyPairParamRep;
    public static DerObjectIdentifier it_revPassphrase;
    public static DerObjectIdentifier it_implicitConfirm;
    public static DerObjectIdentifier it_confirmWaitTime;
    public static DerObjectIdentifier it_origPKIMessage;
    public static DerObjectIdentifier it_suppLangTags;
    public static DerObjectIdentifier regCtrl_regToken;
    public static DerObjectIdentifier regCtrl_authenticator;
    public static DerObjectIdentifier regCtrl_pkiPublicationInfo;
    public static DerObjectIdentifier regCtrl_pkiArchiveOptions;
    public static DerObjectIdentifier regCtrl_oldCertID;
    public static DerObjectIdentifier regCtrl_protocolEncrKey;
    public static DerObjectIdentifier regCtrl_altCertTemplate;
    public static DerObjectIdentifier regInfo_utf8Pairs;
    public static DerObjectIdentifier regInfo_certReq;
    public static DerObjectIdentifier ct_encKeyWithID;
    private static CmpObjectIdentifiers();
}
public class Org.BouncyCastle.Asn1.Cmp.CrlAnnContent : Asn1Encodable {
    private Asn1Sequence content;
    private CrlAnnContent(Asn1Sequence seq);
    public static CrlAnnContent GetInstance(object obj);
    public virtual CertificateList[] ToCertificateListArray();
    public virtual Asn1Object ToAsn1Object();
}
public class Org.BouncyCastle.Asn1.Cmp.ErrorMsgContent : Asn1Encodable {
    private PkiStatusInfo pkiStatusInfo;
    private DerInteger errorCode;
    private PkiFreeText errorDetails;
    public PkiStatusInfo PkiStatusInfo { get; }
    public DerInteger ErrorCode { get; }
    public PkiFreeText ErrorDetails { get; }
    private ErrorMsgContent(Asn1Sequence seq);
    public ErrorMsgContent(PkiStatusInfo pkiStatusInfo);
    public ErrorMsgContent(PkiStatusInfo pkiStatusInfo, DerInteger errorCode, PkiFreeText errorDetails);
    public static ErrorMsgContent GetInstance(object obj);
    public virtual PkiStatusInfo get_PkiStatusInfo();
    public virtual DerInteger get_ErrorCode();
    public virtual PkiFreeText get_ErrorDetails();
    public virtual Asn1Object ToAsn1Object();
}
public class Org.BouncyCastle.Asn1.Cmp.GenMsgContent : Asn1Encodable {
    private Asn1Sequence content;
    private GenMsgContent(Asn1Sequence seq);
    public GenMsgContent(InfoTypeAndValue[] itv);
    public static GenMsgContent GetInstance(object obj);
    public virtual InfoTypeAndValue[] ToInfoTypeAndValueArray();
    public virtual Asn1Object ToAsn1Object();
}
public class Org.BouncyCastle.Asn1.Cmp.GenRepContent : Asn1Encodable {
    private Asn1Sequence content;
    private GenRepContent(Asn1Sequence seq);
    public GenRepContent(InfoTypeAndValue[] itv);
    public static GenRepContent GetInstance(object obj);
    public virtual InfoTypeAndValue[] ToInfoTypeAndValueArray();
    public virtual Asn1Object ToAsn1Object();
}
public class Org.BouncyCastle.Asn1.Cmp.InfoTypeAndValue : Asn1Encodable {
    private DerObjectIdentifier infoType;
    private Asn1Encodable infoValue;
    public DerObjectIdentifier InfoType { get; }
    public Asn1Encodable InfoValue { get; }
    private InfoTypeAndValue(Asn1Sequence seq);
    public InfoTypeAndValue(DerObjectIdentifier infoType);
    public InfoTypeAndValue(DerObjectIdentifier infoType, Asn1Encodable optionalValue);
    public static InfoTypeAndValue GetInstance(object obj);
    public virtual DerObjectIdentifier get_InfoType();
    public virtual Asn1Encodable get_InfoValue();
    public virtual Asn1Object ToAsn1Object();
}
public class Org.BouncyCastle.Asn1.Cmp.KeyRecRepContent : Asn1Encodable {
    private PkiStatusInfo status;
    private CmpCertificate newSigCert;
    private Asn1Sequence caCerts;
    private Asn1Sequence keyPairHist;
    public PkiStatusInfo Status { get; }
    public CmpCertificate NewSigCert { get; }
    private KeyRecRepContent(Asn1Sequence seq);
    public static KeyRecRepContent GetInstance(object obj);
    public virtual PkiStatusInfo get_Status();
    public virtual CmpCertificate get_NewSigCert();
    public virtual CmpCertificate[] GetCACerts();
    public virtual CertifiedKeyPair[] GetKeyPairHist();
    public virtual Asn1Object ToAsn1Object();
    private void AddOptional(Asn1EncodableVector v, int tagNo, Asn1Encodable obj);
}
public class Org.BouncyCastle.Asn1.Cmp.OobCertHash : Asn1Encodable {
    private AlgorithmIdentifier hashAlg;
    private CertId certId;
    private DerBitString hashVal;
    public AlgorithmIdentifier HashAlg { get; }
    public CertId CertID { get; }
    private OobCertHash(Asn1Sequence seq);
    public static OobCertHash GetInstance(object obj);
    public virtual AlgorithmIdentifier get_HashAlg();
    public virtual CertId get_CertID();
    public virtual Asn1Object ToAsn1Object();
    private void AddOptional(Asn1EncodableVector v, int tagNo, Asn1Encodable obj);
}
public class Org.BouncyCastle.Asn1.Cmp.PbmParameter : Asn1Encodable {
    private Asn1OctetString salt;
    private AlgorithmIdentifier owf;
    private DerInteger iterationCount;
    private AlgorithmIdentifier mac;
    public Asn1OctetString Salt { get; }
    public AlgorithmIdentifier Owf { get; }
    public DerInteger IterationCount { get; }
    public AlgorithmIdentifier Mac { get; }
    private PbmParameter(Asn1Sequence seq);
    public PbmParameter(Byte[] salt, AlgorithmIdentifier owf, int iterationCount, AlgorithmIdentifier mac);
    public PbmParameter(Asn1OctetString salt, AlgorithmIdentifier owf, DerInteger iterationCount, AlgorithmIdentifier mac);
    public static PbmParameter GetInstance(object obj);
    public virtual Asn1OctetString get_Salt();
    public virtual AlgorithmIdentifier get_Owf();
    public virtual DerInteger get_IterationCount();
    public virtual AlgorithmIdentifier get_Mac();
    public virtual Asn1Object ToAsn1Object();
}
public class Org.BouncyCastle.Asn1.Cmp.PkiBody : Asn1Encodable {
    public static int TYPE_INIT_REQ;
    public static int TYPE_INIT_REP;
    public static int TYPE_CERT_REQ;
    public static int TYPE_CERT_REP;
    public static int TYPE_P10_CERT_REQ;
    public static int TYPE_POPO_CHALL;
    public static int TYPE_POPO_REP;
    public static int TYPE_KEY_UPDATE_REQ;
    public static int TYPE_KEY_UPDATE_REP;
    public static int TYPE_KEY_RECOVERY_REQ;
    public static int TYPE_KEY_RECOVERY_REP;
    public static int TYPE_REVOCATION_REQ;
    public static int TYPE_REVOCATION_REP;
    public static int TYPE_CROSS_CERT_REQ;
    public static int TYPE_CROSS_CERT_REP;
    public static int TYPE_CA_KEY_UPDATE_ANN;
    public static int TYPE_CERT_ANN;
    public static int TYPE_REVOCATION_ANN;
    public static int TYPE_CRL_ANN;
    public static int TYPE_CONFIRM;
    public static int TYPE_NESTED;
    public static int TYPE_GEN_MSG;
    public static int TYPE_GEN_REP;
    public static int TYPE_ERROR;
    public static int TYPE_CERT_CONFIRM;
    public static int TYPE_POLL_REQ;
    public static int TYPE_POLL_REP;
    private int tagNo;
    private Asn1Encodable body;
    public int Type { get; }
    public Asn1Encodable Content { get; }
    private PkiBody(Asn1TaggedObject tagged);
    public PkiBody(int type, Asn1Encodable content);
    public static PkiBody GetInstance(object obj);
    private static Asn1Encodable GetBodyForType(int type, Asn1Encodable o);
    public virtual int get_Type();
    public virtual Asn1Encodable get_Content();
    public virtual Asn1Object ToAsn1Object();
}
public class Org.BouncyCastle.Asn1.Cmp.PkiConfirmContent : Asn1Encodable {
    public static PkiConfirmContent GetInstance(object obj);
    public virtual Asn1Object ToAsn1Object();
}
public class Org.BouncyCastle.Asn1.Cmp.PkiFailureInfo : DerBitString {
    public static int BadAlg;
    public static int BadMessageCheck;
    public static int BadRequest;
    public static int BadTime;
    public static int BadCertId;
    public static int BadDataFormat;
    public static int WrongAuthority;
    public static int IncorrectData;
    public static int MissingTimeStamp;
    public static int BadPop;
    public static int TimeNotAvailable;
    public static int UnacceptedPolicy;
    public static int UnacceptedExtension;
    public static int AddInfoNotAvailable;
    public static int SystemFailure;
    public PkiFailureInfo(int info);
    public PkiFailureInfo(DerBitString info);
    public virtual string ToString();
}
[DefaultMemberAttribute("Item")]
public class Org.BouncyCastle.Asn1.Cmp.PkiFreeText : Asn1Encodable {
    internal Asn1Sequence strings;
    [ObsoleteAttribute("Use 'Count' property instead")]
public int Size { get; }
    public int Count { get; }
    public DerUtf8String Item { get; }
    public PkiFreeText(Asn1Sequence seq);
    public PkiFreeText(DerUtf8String p);
    public static PkiFreeText GetInstance(Asn1TaggedObject obj, bool isExplicit);
    public static PkiFreeText GetInstance(object obj);
    public int get_Size();
    public int get_Count();
    public DerUtf8String get_Item(int index);
    [ObsoleteAttribute("Use 'object[index]' syntax instead")]
public DerUtf8String GetStringAt(int index);
    public virtual Asn1Object ToAsn1Object();
}
public class Org.BouncyCastle.Asn1.Cmp.PkiHeader : Asn1Encodable {
    public static GeneralName NULL_NAME;
    public static int CMP_1999;
    public static int CMP_2000;
    private DerInteger pvno;
    private GeneralName sender;
    private GeneralName recipient;
    private DerGeneralizedTime messageTime;
    private AlgorithmIdentifier protectionAlg;
    private Asn1OctetString senderKID;
    private Asn1OctetString recipKID;
    private Asn1OctetString transactionID;
    private Asn1OctetString senderNonce;
    private Asn1OctetString recipNonce;
    private PkiFreeText freeText;
    private Asn1Sequence generalInfo;
    public DerInteger Pvno { get; }
    public GeneralName Sender { get; }
    public GeneralName Recipient { get; }
    public DerGeneralizedTime MessageTime { get; }
    public AlgorithmIdentifier ProtectionAlg { get; }
    public Asn1OctetString SenderKID { get; }
    public Asn1OctetString RecipKID { get; }
    public Asn1OctetString TransactionID { get; }
    public Asn1OctetString SenderNonce { get; }
    public Asn1OctetString RecipNonce { get; }
    public PkiFreeText FreeText { get; }
    private PkiHeader(Asn1Sequence seq);
    public PkiHeader(int pvno, GeneralName sender, GeneralName recipient);
    private PkiHeader(DerInteger pvno, GeneralName sender, GeneralName recipient);
    private static PkiHeader();
    public static PkiHeader GetInstance(object obj);
    public virtual DerInteger get_Pvno();
    public virtual GeneralName get_Sender();
    public virtual GeneralName get_Recipient();
    public virtual DerGeneralizedTime get_MessageTime();
    public virtual AlgorithmIdentifier get_ProtectionAlg();
    public virtual Asn1OctetString get_SenderKID();
    public virtual Asn1OctetString get_RecipKID();
    public virtual Asn1OctetString get_TransactionID();
    public virtual Asn1OctetString get_SenderNonce();
    public virtual Asn1OctetString get_RecipNonce();
    public virtual PkiFreeText get_FreeText();
    public virtual InfoTypeAndValue[] GetGeneralInfo();
    public virtual Asn1Object ToAsn1Object();
    private static void AddOptional(Asn1EncodableVector v, int tagNo, Asn1Encodable obj);
}
public class Org.BouncyCastle.Asn1.Cmp.PkiHeaderBuilder : object {
    private DerInteger pvno;
    private GeneralName sender;
    private GeneralName recipient;
    private DerGeneralizedTime messageTime;
    private AlgorithmIdentifier protectionAlg;
    private Asn1OctetString senderKID;
    private Asn1OctetString recipKID;
    private Asn1OctetString transactionID;
    private Asn1OctetString senderNonce;
    private Asn1OctetString recipNonce;
    private PkiFreeText freeText;
    private Asn1Sequence generalInfo;
    public PkiHeaderBuilder(int pvno, GeneralName sender, GeneralName recipient);
    private PkiHeaderBuilder(DerInteger pvno, GeneralName sender, GeneralName recipient);
    public virtual PkiHeaderBuilder SetMessageTime(DerGeneralizedTime time);
    public virtual PkiHeaderBuilder SetProtectionAlg(AlgorithmIdentifier aid);
    public virtual PkiHeaderBuilder SetSenderKID(Byte[] kid);
    public virtual PkiHeaderBuilder SetSenderKID(Asn1OctetString kid);
    public virtual PkiHeaderBuilder SetRecipKID(Byte[] kid);
    public virtual PkiHeaderBuilder SetRecipKID(DerOctetString kid);
    public virtual PkiHeaderBuilder SetTransactionID(Byte[] tid);
    public virtual PkiHeaderBuilder SetTransactionID(Asn1OctetString tid);
    public virtual PkiHeaderBuilder SetSenderNonce(Byte[] nonce);
    public virtual PkiHeaderBuilder SetSenderNonce(Asn1OctetString nonce);
    public virtual PkiHeaderBuilder SetRecipNonce(Byte[] nonce);
    public virtual PkiHeaderBuilder SetRecipNonce(Asn1OctetString nonce);
    public virtual PkiHeaderBuilder SetFreeText(PkiFreeText text);
    public virtual PkiHeaderBuilder SetGeneralInfo(InfoTypeAndValue genInfo);
    public virtual PkiHeaderBuilder SetGeneralInfo(InfoTypeAndValue[] genInfos);
    public virtual PkiHeaderBuilder SetGeneralInfo(Asn1Sequence seqOfInfoTypeAndValue);
    private static Asn1Sequence MakeGeneralInfoSeq(InfoTypeAndValue generalInfo);
    private static Asn1Sequence MakeGeneralInfoSeq(InfoTypeAndValue[] generalInfos);
    public virtual PkiHeader Build();
    private void AddOptional(Asn1EncodableVector v, int tagNo, Asn1Encodable obj);
}
public class Org.BouncyCastle.Asn1.Cmp.PkiMessage : Asn1Encodable {
    private PkiHeader header;
    private PkiBody body;
    private DerBitString protection;
    private Asn1Sequence extraCerts;
    public PkiHeader Header { get; }
    public PkiBody Body { get; }
    public DerBitString Protection { get; }
    private PkiMessage(Asn1Sequence seq);
    public PkiMessage(PkiHeader header, PkiBody body, DerBitString protection, CmpCertificate[] extraCerts);
    public PkiMessage(PkiHeader header, PkiBody body, DerBitString protection);
    public PkiMessage(PkiHeader header, PkiBody body);
    public static PkiMessage GetInstance(object obj);
    public virtual PkiHeader get_Header();
    public virtual PkiBody get_Body();
    public virtual DerBitString get_Protection();
    public virtual CmpCertificate[] GetExtraCerts();
    public virtual Asn1Object ToAsn1Object();
    private static void AddOptional(Asn1EncodableVector v, int tagNo, Asn1Encodable obj);
}
public class Org.BouncyCastle.Asn1.Cmp.PkiMessages : Asn1Encodable {
    private Asn1Sequence content;
    private PkiMessages(Asn1Sequence seq);
    public PkiMessages(PkiMessage[] msgs);
    public static PkiMessages GetInstance(object obj);
    public virtual PkiMessage[] ToPkiMessageArray();
    public virtual Asn1Object ToAsn1Object();
}
public enum Org.BouncyCastle.Asn1.Cmp.PkiStatus : Enum {
    public int value__;
    public static PkiStatus Granted;
    public static PkiStatus GrantedWithMods;
    public static PkiStatus Rejection;
    public static PkiStatus Waiting;
    public static PkiStatus RevocationWarning;
    public static PkiStatus RevocationNotification;
    public static PkiStatus KeyUpdateWarning;
}
public class Org.BouncyCastle.Asn1.Cmp.PkiStatusEncodable : Asn1Encodable {
    public static PkiStatusEncodable granted;
    public static PkiStatusEncodable grantedWithMods;
    public static PkiStatusEncodable rejection;
    public static PkiStatusEncodable waiting;
    public static PkiStatusEncodable revocationWarning;
    public static PkiStatusEncodable revocationNotification;
    public static PkiStatusEncodable keyUpdateWaiting;
    private DerInteger status;
    public BigInteger Value { get; }
    private PkiStatusEncodable(PkiStatus status);
    private PkiStatusEncodable(DerInteger status);
    private static PkiStatusEncodable();
    public static PkiStatusEncodable GetInstance(object obj);
    public virtual BigInteger get_Value();
    public virtual Asn1Object ToAsn1Object();
}
public class Org.BouncyCastle.Asn1.Cmp.PkiStatusInfo : Asn1Encodable {
    private DerInteger status;
    private PkiFreeText statusString;
    private DerBitString failInfo;
    public BigInteger Status { get; }
    public PkiFreeText StatusString { get; }
    public DerBitString FailInfo { get; }
    public PkiStatusInfo(Asn1Sequence seq);
    public PkiStatusInfo(int status);
    public PkiStatusInfo(int status, PkiFreeText statusString);
    public PkiStatusInfo(int status, PkiFreeText statusString, PkiFailureInfo failInfo);
    public static PkiStatusInfo GetInstance(Asn1TaggedObject obj, bool isExplicit);
    public static PkiStatusInfo GetInstance(object obj);
    public BigInteger get_Status();
    public PkiFreeText get_StatusString();
    public DerBitString get_FailInfo();
    public virtual Asn1Object ToAsn1Object();
}
public class Org.BouncyCastle.Asn1.Cmp.PollRepContent : Asn1Encodable {
    private DerInteger certReqId;
    private DerInteger checkAfter;
    private PkiFreeText reason;
    public DerInteger CertReqID { get; }
    public DerInteger CheckAfter { get; }
    public PkiFreeText Reason { get; }
    private PollRepContent(Asn1Sequence seq);
    public static PollRepContent GetInstance(object obj);
    public virtual DerInteger get_CertReqID();
    public virtual DerInteger get_CheckAfter();
    public virtual PkiFreeText get_Reason();
    public virtual Asn1Object ToAsn1Object();
}
public class Org.BouncyCastle.Asn1.Cmp.PollReqContent : Asn1Encodable {
    private Asn1Sequence content;
    private PollReqContent(Asn1Sequence seq);
    public static PollReqContent GetInstance(object obj);
    public virtual DerInteger[][] GetCertReqIDs();
    private static DerInteger[] SequenceToDerIntegerArray(Asn1Sequence seq);
    public virtual Asn1Object ToAsn1Object();
}
public class Org.BouncyCastle.Asn1.Cmp.PopoDecKeyChallContent : Asn1Encodable {
    private Asn1Sequence content;
    private PopoDecKeyChallContent(Asn1Sequence seq);
    public static PopoDecKeyChallContent GetInstance(object obj);
    public virtual Challenge[] ToChallengeArray();
    public virtual Asn1Object ToAsn1Object();
}
public class Org.BouncyCastle.Asn1.Cmp.PopoDecKeyRespContent : Asn1Encodable {
    private Asn1Sequence content;
    private PopoDecKeyRespContent(Asn1Sequence seq);
    public static PopoDecKeyRespContent GetInstance(object obj);
    public virtual DerInteger[] ToDerIntegerArray();
    public virtual Asn1Object ToAsn1Object();
}
public class Org.BouncyCastle.Asn1.Cmp.ProtectedPart : Asn1Encodable {
    private PkiHeader header;
    private PkiBody body;
    public PkiHeader Header { get; }
    public PkiBody Body { get; }
    private ProtectedPart(Asn1Sequence seq);
    public ProtectedPart(PkiHeader header, PkiBody body);
    public static ProtectedPart GetInstance(object obj);
    public virtual PkiHeader get_Header();
    public virtual PkiBody get_Body();
    public virtual Asn1Object ToAsn1Object();
}
public class Org.BouncyCastle.Asn1.Cmp.RevAnnContent : Asn1Encodable {
    private PkiStatusEncodable status;
    private CertId certId;
    private DerGeneralizedTime willBeRevokedAt;
    private DerGeneralizedTime badSinceDate;
    private X509Extensions crlDetails;
    public PkiStatusEncodable Status { get; }
    public CertId CertID { get; }
    public DerGeneralizedTime WillBeRevokedAt { get; }
    public DerGeneralizedTime BadSinceDate { get; }
    public X509Extensions CrlDetails { get; }
    private RevAnnContent(Asn1Sequence seq);
    public static RevAnnContent GetInstance(object obj);
    public virtual PkiStatusEncodable get_Status();
    public virtual CertId get_CertID();
    public virtual DerGeneralizedTime get_WillBeRevokedAt();
    public virtual DerGeneralizedTime get_BadSinceDate();
    public virtual X509Extensions get_CrlDetails();
    public virtual Asn1Object ToAsn1Object();
}
public class Org.BouncyCastle.Asn1.Cmp.RevDetails : Asn1Encodable {
    private CertTemplate certDetails;
    private X509Extensions crlEntryDetails;
    public CertTemplate CertDetails { get; }
    public X509Extensions CrlEntryDetails { get; }
    private RevDetails(Asn1Sequence seq);
    public RevDetails(CertTemplate certDetails);
    public RevDetails(CertTemplate certDetails, X509Extensions crlEntryDetails);
    public static RevDetails GetInstance(object obj);
    public virtual CertTemplate get_CertDetails();
    public virtual X509Extensions get_CrlEntryDetails();
    public virtual Asn1Object ToAsn1Object();
}
public class Org.BouncyCastle.Asn1.Cmp.RevRepContent : Asn1Encodable {
    private Asn1Sequence status;
    private Asn1Sequence revCerts;
    private Asn1Sequence crls;
    private RevRepContent(Asn1Sequence seq);
    public static RevRepContent GetInstance(object obj);
    public virtual PkiStatusInfo[] GetStatus();
    public virtual CertId[] GetRevCerts();
    public virtual CertificateList[] GetCrls();
    public virtual Asn1Object ToAsn1Object();
    private void AddOptional(Asn1EncodableVector v, int tagNo, Asn1Encodable obj);
}
public class Org.BouncyCastle.Asn1.Cmp.RevRepContentBuilder : object {
    private Asn1EncodableVector status;
    private Asn1EncodableVector revCerts;
    private Asn1EncodableVector crls;
    public virtual RevRepContentBuilder Add(PkiStatusInfo status);
    public virtual RevRepContentBuilder Add(PkiStatusInfo status, CertId certId);
    public virtual RevRepContentBuilder AddCrl(CertificateList crl);
    public virtual RevRepContent Build();
}
public class Org.BouncyCastle.Asn1.Cmp.RevReqContent : Asn1Encodable {
    private Asn1Sequence content;
    private RevReqContent(Asn1Sequence seq);
    public RevReqContent(RevDetails[] revDetails);
    public static RevReqContent GetInstance(object obj);
    public virtual RevDetails[] ToRevDetailsArray();
    public virtual Asn1Object ToAsn1Object();
}
public class Org.BouncyCastle.Asn1.Cms.Attribute : Asn1Encodable {
    private DerObjectIdentifier attrType;
    private Asn1Set attrValues;
    public DerObjectIdentifier AttrType { get; }
    public Asn1Set AttrValues { get; }
    public Attribute(Asn1Sequence seq);
    public Attribute(DerObjectIdentifier attrType, Asn1Set attrValues);
    public static Attribute GetInstance(object obj);
    public DerObjectIdentifier get_AttrType();
    public Asn1Set get_AttrValues();
    public virtual Asn1Object ToAsn1Object();
}
public class Org.BouncyCastle.Asn1.Cms.Attributes : Asn1Encodable {
    private Asn1Set attributes;
    private Attributes(Asn1Set attributes);
    public Attributes(Asn1EncodableVector v);
    public static Attributes GetInstance(object obj);
    public virtual Attribute[] GetAttributes();
    public virtual Asn1Object ToAsn1Object();
}
[DefaultMemberAttribute("Item")]
public class Org.BouncyCastle.Asn1.Cms.AttributeTable : object {
    private IDictionary attributes;
    public Attribute Item { get; }
    public int Count { get; }
    [ObsoleteAttribute]
public AttributeTable(Hashtable attrs);
    public AttributeTable(IDictionary attrs);
    public AttributeTable(Asn1EncodableVector v);
    public AttributeTable(Asn1Set s);
    public AttributeTable(Attributes attrs);
    private void AddAttribute(Attribute a);
    public Attribute get_Item(DerObjectIdentifier oid);
    [ObsoleteAttribute("Use 'object[oid]' syntax instead")]
public Attribute Get(DerObjectIdentifier oid);
    public Asn1EncodableVector GetAll(DerObjectIdentifier oid);
    public int get_Count();
    public IDictionary ToDictionary();
    [ObsoleteAttribute("Use 'ToDictionary' instead")]
public Hashtable ToHashtable();
    public Asn1EncodableVector ToAsn1EncodableVector();
    public Attributes ToAttributes();
    public AttributeTable Add(DerObjectIdentifier attrType, Asn1Encodable attrValue);
    public AttributeTable Remove(DerObjectIdentifier attrType);
}
public class Org.BouncyCastle.Asn1.Cms.AuthenticatedData : Asn1Encodable {
    private DerInteger version;
    private OriginatorInfo originatorInfo;
    private Asn1Set recipientInfos;
    private AlgorithmIdentifier macAlgorithm;
    private AlgorithmIdentifier digestAlgorithm;
    private ContentInfo encapsulatedContentInfo;
    private Asn1Set authAttrs;
    private Asn1OctetString mac;
    private Asn1Set unauthAttrs;
    public DerInteger Version { get; }
    public OriginatorInfo OriginatorInfo { get; }
    public Asn1Set RecipientInfos { get; }
    public AlgorithmIdentifier MacAlgorithm { get; }
    public AlgorithmIdentifier DigestAlgorithm { get; }
    public ContentInfo EncapsulatedContentInfo { get; }
    public Asn1Set AuthAttrs { get; }
    public Asn1OctetString Mac { get; }
    public Asn1Set UnauthAttrs { get; }
    public AuthenticatedData(OriginatorInfo originatorInfo, Asn1Set recipientInfos, AlgorithmIdentifier macAlgorithm, AlgorithmIdentifier digestAlgorithm, ContentInfo encapsulatedContent, Asn1Set authAttrs, Asn1OctetString mac, Asn1Set unauthAttrs);
    private AuthenticatedData(Asn1Sequence seq);
    public static AuthenticatedData GetInstance(Asn1TaggedObject obj, bool isExplicit);
    public static AuthenticatedData GetInstance(object obj);
    public DerInteger get_Version();
    public OriginatorInfo get_OriginatorInfo();
    public Asn1Set get_RecipientInfos();
    public AlgorithmIdentifier get_MacAlgorithm();
    public AlgorithmIdentifier get_DigestAlgorithm();
    public ContentInfo get_EncapsulatedContentInfo();
    public Asn1Set get_AuthAttrs();
    public Asn1OctetString get_Mac();
    public Asn1Set get_UnauthAttrs();
    public virtual Asn1Object ToAsn1Object();
    public static int CalculateVersion(OriginatorInfo origInfo);
}
public class Org.BouncyCastle.Asn1.Cms.AuthenticatedDataParser : object {
    private Asn1SequenceParser seq;
    private DerInteger version;
    private IAsn1Convertible nextObject;
    private bool originatorInfoCalled;
    public DerInteger Version { get; }
    public AuthenticatedDataParser(Asn1SequenceParser seq);
    public DerInteger get_Version();
    public OriginatorInfo GetOriginatorInfo();
    public Asn1SetParser GetRecipientInfos();
    public AlgorithmIdentifier GetMacAlgorithm();
    public AlgorithmIdentifier GetDigestAlgorithm();
    public ContentInfoParser GetEnapsulatedContentInfo();
    public Asn1SetParser GetAuthAttrs();
    public Asn1OctetString GetMac();
    public Asn1SetParser GetUnauthAttrs();
}
public class Org.BouncyCastle.Asn1.Cms.AuthEnvelopedData : Asn1Encodable {
    private DerInteger version;
    private OriginatorInfo originatorInfo;
    private Asn1Set recipientInfos;
    private EncryptedContentInfo authEncryptedContentInfo;
    private Asn1Set authAttrs;
    private Asn1OctetString mac;
    private Asn1Set unauthAttrs;
    public DerInteger Version { get; }
    public OriginatorInfo OriginatorInfo { get; }
    public Asn1Set RecipientInfos { get; }
    public EncryptedContentInfo AuthEncryptedContentInfo { get; }
    public Asn1Set AuthAttrs { get; }
    public Asn1OctetString Mac { get; }
    public Asn1Set UnauthAttrs { get; }
    public AuthEnvelopedData(OriginatorInfo originatorInfo, Asn1Set recipientInfos, EncryptedContentInfo authEncryptedContentInfo, Asn1Set authAttrs, Asn1OctetString mac, Asn1Set unauthAttrs);
    private AuthEnvelopedData(Asn1Sequence seq);
    public static AuthEnvelopedData GetInstance(Asn1TaggedObject obj, bool isExplicit);
    public static AuthEnvelopedData GetInstance(object obj);
    public DerInteger get_Version();
    public OriginatorInfo get_OriginatorInfo();
    public Asn1Set get_RecipientInfos();
    public EncryptedContentInfo get_AuthEncryptedContentInfo();
    public Asn1Set get_AuthAttrs();
    public Asn1OctetString get_Mac();
    public Asn1Set get_UnauthAttrs();
    public virtual Asn1Object ToAsn1Object();
}
public class Org.BouncyCastle.Asn1.Cms.AuthEnvelopedDataParser : object {
    private Asn1SequenceParser seq;
    private DerInteger version;
    private IAsn1Convertible nextObject;
    private bool originatorInfoCalled;
    public DerInteger Version { get; }
    public AuthEnvelopedDataParser(Asn1SequenceParser seq);
    public DerInteger get_Version();
    public OriginatorInfo GetOriginatorInfo();
    public Asn1SetParser GetRecipientInfos();
    public EncryptedContentInfoParser GetAuthEncryptedContentInfo();
    public Asn1SetParser GetAuthAttrs();
    public Asn1OctetString GetMac();
    public Asn1SetParser GetUnauthAttrs();
}
public abstract class Org.BouncyCastle.Asn1.Cms.CmsAttributes : object {
    public static DerObjectIdentifier ContentType;
    public static DerObjectIdentifier MessageDigest;
    public static DerObjectIdentifier SigningTime;
    public static DerObjectIdentifier CounterSignature;
    public static DerObjectIdentifier ContentHint;
    private static CmsAttributes();
}
public abstract class Org.BouncyCastle.Asn1.Cms.CmsObjectIdentifiers : object {
    public static DerObjectIdentifier Data;
    public static DerObjectIdentifier SignedData;
    public static DerObjectIdentifier EnvelopedData;
    public static DerObjectIdentifier SignedAndEnvelopedData;
    public static DerObjectIdentifier DigestedData;
    public static DerObjectIdentifier EncryptedData;
    public static DerObjectIdentifier AuthenticatedData;
    public static DerObjectIdentifier CompressedData;
    public static DerObjectIdentifier AuthEnvelopedData;
    public static DerObjectIdentifier timestampedData;
    public static DerObjectIdentifier id_ri;
    public static DerObjectIdentifier id_ri_ocsp_response;
    public static DerObjectIdentifier id_ri_scvp;
    private static CmsObjectIdentifiers();
}
public class Org.BouncyCastle.Asn1.Cms.CompressedData : Asn1Encodable {
    private DerInteger version;
    private AlgorithmIdentifier compressionAlgorithm;
    private ContentInfo encapContentInfo;
    public DerInteger Version { get; }
    public AlgorithmIdentifier CompressionAlgorithmIdentifier { get; }
    public ContentInfo EncapContentInfo { get; }
    public CompressedData(AlgorithmIdentifier compressionAlgorithm, ContentInfo encapContentInfo);
    public CompressedData(Asn1Sequence seq);
    public static CompressedData GetInstance(Asn1TaggedObject ato, bool explicitly);
    public static CompressedData GetInstance(object obj);
    public DerInteger get_Version();
    public AlgorithmIdentifier get_CompressionAlgorithmIdentifier();
    public ContentInfo get_EncapContentInfo();
    public virtual Asn1Object ToAsn1Object();
}
public class Org.BouncyCastle.Asn1.Cms.CompressedDataParser : object {
    private DerInteger _version;
    private AlgorithmIdentifier _compressionAlgorithm;
    private ContentInfoParser _encapContentInfo;
    public DerInteger Version { get; }
    public AlgorithmIdentifier CompressionAlgorithmIdentifier { get; }
    public CompressedDataParser(Asn1SequenceParser seq);
    public DerInteger get_Version();
    public AlgorithmIdentifier get_CompressionAlgorithmIdentifier();
    public ContentInfoParser GetEncapContentInfo();
}
public class Org.BouncyCastle.Asn1.Cms.ContentInfo : Asn1Encodable {
    private DerObjectIdentifier contentType;
    private Asn1Encodable content;
    public DerObjectIdentifier ContentType { get; }
    public Asn1Encodable Content { get; }
    private ContentInfo(Asn1Sequence seq);
    public ContentInfo(DerObjectIdentifier contentType, Asn1Encodable content);
    public static ContentInfo GetInstance(object obj);
    public static ContentInfo GetInstance(Asn1TaggedObject obj, bool isExplicit);
    public DerObjectIdentifier get_ContentType();
    public Asn1Encodable get_Content();
    public virtual Asn1Object ToAsn1Object();
}
public class Org.BouncyCastle.Asn1.Cms.ContentInfoParser : object {
    private DerObjectIdentifier contentType;
    private Asn1TaggedObjectParser content;
    public DerObjectIdentifier ContentType { get; }
    public ContentInfoParser(Asn1SequenceParser seq);
    public DerObjectIdentifier get_ContentType();
    public IAsn1Convertible GetContent(int tag);
}
public class Org.BouncyCastle.Asn1.Cms.Ecc.MQVuserKeyingMaterial : Asn1Encodable {
    private OriginatorPublicKey ephemeralPublicKey;
    private Asn1OctetString addedukm;
    public OriginatorPublicKey EphemeralPublicKey { get; }
    public Asn1OctetString AddedUkm { get; }
    public MQVuserKeyingMaterial(OriginatorPublicKey ephemeralPublicKey, Asn1OctetString addedukm);
    private MQVuserKeyingMaterial(Asn1Sequence seq);
    public static MQVuserKeyingMaterial GetInstance(Asn1TaggedObject obj, bool isExplicit);
    public static MQVuserKeyingMaterial GetInstance(object obj);
    public OriginatorPublicKey get_EphemeralPublicKey();
    public Asn1OctetString get_AddedUkm();
    public virtual Asn1Object ToAsn1Object();
}
public class Org.BouncyCastle.Asn1.Cms.EncryptedContentInfo : Asn1Encodable {
    private DerObjectIdentifier contentType;
    private AlgorithmIdentifier contentEncryptionAlgorithm;
    private Asn1OctetString encryptedContent;
    public DerObjectIdentifier ContentType { get; }
    public AlgorithmIdentifier ContentEncryptionAlgorithm { get; }
    public Asn1OctetString EncryptedContent { get; }
    public EncryptedContentInfo(DerObjectIdentifier contentType, AlgorithmIdentifier contentEncryptionAlgorithm, Asn1OctetString encryptedContent);
    public EncryptedContentInfo(Asn1Sequence seq);
    public static EncryptedContentInfo GetInstance(object obj);
    public DerObjectIdentifier get_ContentType();
    public AlgorithmIdentifier get_ContentEncryptionAlgorithm();
    public Asn1OctetString get_EncryptedContent();
    public virtual Asn1Object ToAsn1Object();
}
public class Org.BouncyCastle.Asn1.Cms.EncryptedContentInfoParser : object {
    private DerObjectIdentifier _contentType;
    private AlgorithmIdentifier _contentEncryptionAlgorithm;
    private Asn1TaggedObjectParser _encryptedContent;
    public DerObjectIdentifier ContentType { get; }
    public AlgorithmIdentifier ContentEncryptionAlgorithm { get; }
    public EncryptedContentInfoParser(Asn1SequenceParser seq);
    public DerObjectIdentifier get_ContentType();
    public AlgorithmIdentifier get_ContentEncryptionAlgorithm();
    public IAsn1Convertible GetEncryptedContent(int tag);
}
public class Org.BouncyCastle.Asn1.Cms.EncryptedData : Asn1Encodable {
    private DerInteger version;
    private EncryptedContentInfo encryptedContentInfo;
    private Asn1Set unprotectedAttrs;
    public DerInteger Version { get; }
    public EncryptedContentInfo EncryptedContentInfo { get; }
    public Asn1Set UnprotectedAttrs { get; }
    public EncryptedData(EncryptedContentInfo encInfo);
    public EncryptedData(EncryptedContentInfo encInfo, Asn1Set unprotectedAttrs);
    private EncryptedData(Asn1Sequence seq);
    public static EncryptedData GetInstance(object obj);
    public virtual DerInteger get_Version();
    public virtual EncryptedContentInfo get_EncryptedContentInfo();
    public virtual Asn1Set get_UnprotectedAttrs();
    public virtual Asn1Object ToAsn1Object();
}
public class Org.BouncyCastle.Asn1.Cms.EnvelopedData : Asn1Encodable {
    private DerInteger version;
    private OriginatorInfo originatorInfo;
    private Asn1Set recipientInfos;
    private EncryptedContentInfo encryptedContentInfo;
    private Asn1Set unprotectedAttrs;
    public DerInteger Version { get; }
    public OriginatorInfo OriginatorInfo { get; }
    public Asn1Set RecipientInfos { get; }
    public EncryptedContentInfo EncryptedContentInfo { get; }
    public Asn1Set UnprotectedAttrs { get; }
    public EnvelopedData(OriginatorInfo originatorInfo, Asn1Set recipientInfos, EncryptedContentInfo encryptedContentInfo, Asn1Set unprotectedAttrs);
    public EnvelopedData(OriginatorInfo originatorInfo, Asn1Set recipientInfos, EncryptedContentInfo encryptedContentInfo, Attributes unprotectedAttrs);
    [ObsoleteAttribute("Use 'GetInstance' instead")]
public EnvelopedData(Asn1Sequence seq);
    public static EnvelopedData GetInstance(Asn1TaggedObject obj, bool explicitly);
    public static EnvelopedData GetInstance(object obj);
    public DerInteger get_Version();
    public OriginatorInfo get_OriginatorInfo();
    public Asn1Set get_RecipientInfos();
    public EncryptedContentInfo get_EncryptedContentInfo();
    public Asn1Set get_UnprotectedAttrs();
    public virtual Asn1Object ToAsn1Object();
    public static int CalculateVersion(OriginatorInfo originatorInfo, Asn1Set recipientInfos, Asn1Set unprotectedAttrs);
}
public class Org.BouncyCastle.Asn1.Cms.EnvelopedDataParser : object {
    private Asn1SequenceParser _seq;
    private DerInteger _version;
    private IAsn1Convertible _nextObject;
    private bool _originatorInfoCalled;
    public DerInteger Version { get; }
    public EnvelopedDataParser(Asn1SequenceParser seq);
    public DerInteger get_Version();
    public OriginatorInfo GetOriginatorInfo();
    public Asn1SetParser GetRecipientInfos();
    public EncryptedContentInfoParser GetEncryptedContentInfo();
    public Asn1SetParser GetUnprotectedAttrs();
}
public class Org.BouncyCastle.Asn1.Cms.Evidence : Asn1Encodable {
    private TimeStampTokenEvidence tstEvidence;
    public TimeStampTokenEvidence TstEvidence { get; }
    public Evidence(TimeStampTokenEvidence tstEvidence);
    private Evidence(Asn1TaggedObject tagged);
    public static Evidence GetInstance(object obj);
    public virtual TimeStampTokenEvidence get_TstEvidence();
    public virtual Asn1Object ToAsn1Object();
}
public class Org.BouncyCastle.Asn1.Cms.IssuerAndSerialNumber : Asn1Encodable {
    private X509Name name;
    private DerInteger serialNumber;
    public X509Name Name { get; }
    public DerInteger SerialNumber { get; }
    [ObsoleteAttribute("Use GetInstance() instead")]
public IssuerAndSerialNumber(Asn1Sequence seq);
    public IssuerAndSerialNumber(X509Name name, BigInteger serialNumber);
    public IssuerAndSerialNumber(X509Name name, DerInteger serialNumber);
    public static IssuerAndSerialNumber GetInstance(object obj);
    public X509Name get_Name();
    public DerInteger get_SerialNumber();
    public virtual Asn1Object ToAsn1Object();
}
public class Org.BouncyCastle.Asn1.Cms.KekIdentifier : Asn1Encodable {
    private Asn1OctetString keyIdentifier;
    private DerGeneralizedTime date;
    private OtherKeyAttribute other;
    public Asn1OctetString KeyIdentifier { get; }
    public DerGeneralizedTime Date { get; }
    public OtherKeyAttribute Other { get; }
    public KekIdentifier(Byte[] keyIdentifier, DerGeneralizedTime date, OtherKeyAttribute other);
    public KekIdentifier(Asn1Sequence seq);
    public static KekIdentifier GetInstance(Asn1TaggedObject obj, bool explicitly);
    public static KekIdentifier GetInstance(object obj);
    public Asn1OctetString get_KeyIdentifier();
    public DerGeneralizedTime get_Date();
    public OtherKeyAttribute get_Other();
    public virtual Asn1Object ToAsn1Object();
}
public class Org.BouncyCastle.Asn1.Cms.KekRecipientInfo : Asn1Encodable {
    private DerInteger version;
    private KekIdentifier kekID;
    private AlgorithmIdentifier keyEncryptionAlgorithm;
    private Asn1OctetString encryptedKey;
    public DerInteger Version { get; }
    public KekIdentifier KekID { get; }
    public AlgorithmIdentifier KeyEncryptionAlgorithm { get; }
    public Asn1OctetString EncryptedKey { get; }
    public KekRecipientInfo(KekIdentifier kekID, AlgorithmIdentifier keyEncryptionAlgorithm, Asn1OctetString encryptedKey);
    public KekRecipientInfo(Asn1Sequence seq);
    public static KekRecipientInfo GetInstance(Asn1TaggedObject obj, bool explicitly);
    public static KekRecipientInfo GetInstance(object obj);
    public DerInteger get_Version();
    public KekIdentifier get_KekID();
    public AlgorithmIdentifier get_KeyEncryptionAlgorithm();
    public Asn1OctetString get_EncryptedKey();
    public virtual Asn1Object ToAsn1Object();
}
public class Org.BouncyCastle.Asn1.Cms.KeyAgreeRecipientIdentifier : Asn1Encodable {
    private IssuerAndSerialNumber issuerSerial;
    private RecipientKeyIdentifier rKeyID;
    public IssuerAndSerialNumber IssuerAndSerialNumber { get; }
    public RecipientKeyIdentifier RKeyID { get; }
    public KeyAgreeRecipientIdentifier(IssuerAndSerialNumber issuerSerial);
    public KeyAgreeRecipientIdentifier(RecipientKeyIdentifier rKeyID);
    public static KeyAgreeRecipientIdentifier GetInstance(Asn1TaggedObject obj, bool isExplicit);
    public static KeyAgreeRecipientIdentifier GetInstance(object obj);
    public IssuerAndSerialNumber get_IssuerAndSerialNumber();
    public RecipientKeyIdentifier get_RKeyID();
    public virtual Asn1Object ToAsn1Object();
}
public class Org.BouncyCastle.Asn1.Cms.KeyAgreeRecipientInfo : Asn1Encodable {
    private DerInteger version;
    private OriginatorIdentifierOrKey originator;
    private Asn1OctetString ukm;
    private AlgorithmIdentifier keyEncryptionAlgorithm;
    private Asn1Sequence recipientEncryptedKeys;
    public DerInteger Version { get; }
    public OriginatorIdentifierOrKey Originator { get; }
    public Asn1OctetString UserKeyingMaterial { get; }
    public AlgorithmIdentifier KeyEncryptionAlgorithm { get; }
    public Asn1Sequence RecipientEncryptedKeys { get; }
    public KeyAgreeRecipientInfo(OriginatorIdentifierOrKey originator, Asn1OctetString ukm, AlgorithmIdentifier keyEncryptionAlgorithm, Asn1Sequence recipientEncryptedKeys);
    public KeyAgreeRecipientInfo(Asn1Sequence seq);
    public static KeyAgreeRecipientInfo GetInstance(Asn1TaggedObject obj, bool explicitly);
    public static KeyAgreeRecipientInfo GetInstance(object obj);
    public DerInteger get_Version();
    public OriginatorIdentifierOrKey get_Originator();
    public Asn1OctetString get_UserKeyingMaterial();
    public AlgorithmIdentifier get_KeyEncryptionAlgorithm();
    public Asn1Sequence get_RecipientEncryptedKeys();
    public virtual Asn1Object ToAsn1Object();
}
public class Org.BouncyCastle.Asn1.Cms.KeyTransRecipientInfo : Asn1Encodable {
    private DerInteger version;
    private RecipientIdentifier rid;
    private AlgorithmIdentifier keyEncryptionAlgorithm;
    private Asn1OctetString encryptedKey;
    public DerInteger Version { get; }
    public RecipientIdentifier RecipientIdentifier { get; }
    public AlgorithmIdentifier KeyEncryptionAlgorithm { get; }
    public Asn1OctetString EncryptedKey { get; }
    public KeyTransRecipientInfo(RecipientIdentifier rid, AlgorithmIdentifier keyEncryptionAlgorithm, Asn1OctetString encryptedKey);
    public KeyTransRecipientInfo(Asn1Sequence seq);
    public static KeyTransRecipientInfo GetInstance(object obj);
    public DerInteger get_Version();
    public RecipientIdentifier get_RecipientIdentifier();
    public AlgorithmIdentifier get_KeyEncryptionAlgorithm();
    public Asn1OctetString get_EncryptedKey();
    public virtual Asn1Object ToAsn1Object();
}
public class Org.BouncyCastle.Asn1.Cms.MetaData : Asn1Encodable {
    private DerBoolean hashProtected;
    private DerUtf8String fileName;
    private DerIA5String mediaType;
    private Attributes otherMetaData;
    public bool IsHashProtected { get; }
    public DerUtf8String FileName { get; }
    public DerIA5String MediaType { get; }
    public Attributes OtherMetaData { get; }
    public MetaData(DerBoolean hashProtected, DerUtf8String fileName, DerIA5String mediaType, Attributes otherMetaData);
    private MetaData(Asn1Sequence seq);
    public static MetaData GetInstance(object obj);
    public virtual Asn1Object ToAsn1Object();
    public virtual bool get_IsHashProtected();
    public virtual DerUtf8String get_FileName();
    public virtual DerIA5String get_MediaType();
    public virtual Attributes get_OtherMetaData();
}
public class Org.BouncyCastle.Asn1.Cms.OriginatorIdentifierOrKey : Asn1Encodable {
    private Asn1Encodable id;
    public Asn1Encodable ID { get; }
    public IssuerAndSerialNumber IssuerAndSerialNumber { get; }
    public SubjectKeyIdentifier SubjectKeyIdentifier { get; }
    [ObsoleteAttribute("Use 'OriginatorPublicKey' property")]
public OriginatorPublicKey OriginatorKey { get; }
    public OriginatorPublicKey OriginatorPublicKey { get; }
    public OriginatorIdentifierOrKey(IssuerAndSerialNumber id);
    [ObsoleteAttribute("Use version taking a 'SubjectKeyIdentifier'")]
public OriginatorIdentifierOrKey(Asn1OctetString id);
    public OriginatorIdentifierOrKey(SubjectKeyIdentifier id);
    public OriginatorIdentifierOrKey(OriginatorPublicKey id);
    [ObsoleteAttribute("Use more specific version")]
public OriginatorIdentifierOrKey(Asn1Object id);
    private OriginatorIdentifierOrKey(Asn1TaggedObject id);
    public static OriginatorIdentifierOrKey GetInstance(Asn1TaggedObject o, bool explicitly);
    public static OriginatorIdentifierOrKey GetInstance(object o);
    public Asn1Encodable get_ID();
    public IssuerAndSerialNumber get_IssuerAndSerialNumber();
    public SubjectKeyIdentifier get_SubjectKeyIdentifier();
    public OriginatorPublicKey get_OriginatorKey();
    public OriginatorPublicKey get_OriginatorPublicKey();
    public virtual Asn1Object ToAsn1Object();
}
public class Org.BouncyCastle.Asn1.Cms.OriginatorInfo : Asn1Encodable {
    private Asn1Set certs;
    private Asn1Set crls;
    public Asn1Set Certificates { get; }
    public Asn1Set Crls { get; }
    public OriginatorInfo(Asn1Set certs, Asn1Set crls);
    public OriginatorInfo(Asn1Sequence seq);
    public static OriginatorInfo GetInstance(Asn1TaggedObject obj, bool explicitly);
    public static OriginatorInfo GetInstance(object obj);
    public Asn1Set get_Certificates();
    public Asn1Set get_Crls();
    public virtual Asn1Object ToAsn1Object();
}
public class Org.BouncyCastle.Asn1.Cms.OriginatorPublicKey : Asn1Encodable {
    private AlgorithmIdentifier algorithm;
    private DerBitString publicKey;
    public AlgorithmIdentifier Algorithm { get; }
    public DerBitString PublicKey { get; }
    public OriginatorPublicKey(AlgorithmIdentifier algorithm, Byte[] publicKey);
    public OriginatorPublicKey(Asn1Sequence seq);
    public static OriginatorPublicKey GetInstance(Asn1TaggedObject obj, bool explicitly);
    public static OriginatorPublicKey GetInstance(object obj);
    public AlgorithmIdentifier get_Algorithm();
    public DerBitString get_PublicKey();
    public virtual Asn1Object ToAsn1Object();
}
public class Org.BouncyCastle.Asn1.Cms.OtherKeyAttribute : Asn1Encodable {
    private DerObjectIdentifier keyAttrId;
    private Asn1Encodable keyAttr;
    public DerObjectIdentifier KeyAttrId { get; }
    public Asn1Encodable KeyAttr { get; }
    public OtherKeyAttribute(Asn1Sequence seq);
    public OtherKeyAttribute(DerObjectIdentifier keyAttrId, Asn1Encodable keyAttr);
    public static OtherKeyAttribute GetInstance(object obj);
    public DerObjectIdentifier get_KeyAttrId();
    public Asn1Encodable get_KeyAttr();
    public virtual Asn1Object ToAsn1Object();
}
public class Org.BouncyCastle.Asn1.Cms.OtherRecipientInfo : Asn1Encodable {
    private DerObjectIdentifier oriType;
    private Asn1Encodable oriValue;
    public DerObjectIdentifier OriType { get; }
    public Asn1Encodable OriValue { get; }
    public OtherRecipientInfo(DerObjectIdentifier oriType, Asn1Encodable oriValue);
    [ObsoleteAttribute("Use GetInstance() instead")]
public OtherRecipientInfo(Asn1Sequence seq);
    public static OtherRecipientInfo GetInstance(Asn1TaggedObject obj, bool explicitly);
    public static OtherRecipientInfo GetInstance(object obj);
    public virtual DerObjectIdentifier get_OriType();
    public virtual Asn1Encodable get_OriValue();
    public virtual Asn1Object ToAsn1Object();
}
public class Org.BouncyCastle.Asn1.Cms.OtherRevocationInfoFormat : Asn1Encodable {
    private DerObjectIdentifier otherRevInfoFormat;
    private Asn1Encodable otherRevInfo;
    public DerObjectIdentifier InfoFormat { get; }
    public Asn1Encodable Info { get; }
    public OtherRevocationInfoFormat(DerObjectIdentifier otherRevInfoFormat, Asn1Encodable otherRevInfo);
    private OtherRevocationInfoFormat(Asn1Sequence seq);
    public static OtherRevocationInfoFormat GetInstance(Asn1TaggedObject obj, bool isExplicit);
    public static OtherRevocationInfoFormat GetInstance(object obj);
    public virtual DerObjectIdentifier get_InfoFormat();
    public virtual Asn1Encodable get_Info();
    public virtual Asn1Object ToAsn1Object();
}
public class Org.BouncyCastle.Asn1.Cms.PasswordRecipientInfo : Asn1Encodable {
    private DerInteger version;
    private AlgorithmIdentifier keyDerivationAlgorithm;
    private AlgorithmIdentifier keyEncryptionAlgorithm;
    private Asn1OctetString encryptedKey;
    public DerInteger Version { get; }
    public AlgorithmIdentifier KeyDerivationAlgorithm { get; }
    public AlgorithmIdentifier KeyEncryptionAlgorithm { get; }
    public Asn1OctetString EncryptedKey { get; }
    public PasswordRecipientInfo(AlgorithmIdentifier keyEncryptionAlgorithm, Asn1OctetString encryptedKey);
    public PasswordRecipientInfo(AlgorithmIdentifier keyDerivationAlgorithm, AlgorithmIdentifier keyEncryptionAlgorithm, Asn1OctetString encryptedKey);
    public PasswordRecipientInfo(Asn1Sequence seq);
    public static PasswordRecipientInfo GetInstance(Asn1TaggedObject obj, bool explicitly);
    public static PasswordRecipientInfo GetInstance(object obj);
    public DerInteger get_Version();
    public AlgorithmIdentifier get_KeyDerivationAlgorithm();
    public AlgorithmIdentifier get_KeyEncryptionAlgorithm();
    public Asn1OctetString get_EncryptedKey();
    public virtual Asn1Object ToAsn1Object();
}
public class Org.BouncyCastle.Asn1.Cms.RecipientEncryptedKey : Asn1Encodable {
    private KeyAgreeRecipientIdentifier identifier;
    private Asn1OctetString encryptedKey;
    public KeyAgreeRecipientIdentifier Identifier { get; }
    public Asn1OctetString EncryptedKey { get; }
    private RecipientEncryptedKey(Asn1Sequence seq);
    public RecipientEncryptedKey(KeyAgreeRecipientIdentifier id, Asn1OctetString encryptedKey);
    public static RecipientEncryptedKey GetInstance(Asn1TaggedObject obj, bool isExplicit);
    public static RecipientEncryptedKey GetInstance(object obj);
    public KeyAgreeRecipientIdentifier get_Identifier();
    public Asn1OctetString get_EncryptedKey();
    public virtual Asn1Object ToAsn1Object();
}
public class Org.BouncyCastle.Asn1.Cms.RecipientIdentifier : Asn1Encodable {
    private Asn1Encodable id;
    public bool IsTagged { get; }
    public Asn1Encodable ID { get; }
    public RecipientIdentifier(IssuerAndSerialNumber id);
    public RecipientIdentifier(Asn1OctetString id);
    public RecipientIdentifier(Asn1Object id);
    public static RecipientIdentifier GetInstance(object o);
    public bool get_IsTagged();
    public Asn1Encodable get_ID();
    public virtual Asn1Object ToAsn1Object();
}
public class Org.BouncyCastle.Asn1.Cms.RecipientInfo : Asn1Encodable {
    internal Asn1Encodable info;
    public DerInteger Version { get; }
    public bool IsTagged { get; }
    public Asn1Encodable Info { get; }
    public RecipientInfo(KeyTransRecipientInfo info);
    public RecipientInfo(KeyAgreeRecipientInfo info);
    public RecipientInfo(KekRecipientInfo info);
    public RecipientInfo(PasswordRecipientInfo info);
    public RecipientInfo(OtherRecipientInfo info);
    public RecipientInfo(Asn1Object info);
    public static RecipientInfo GetInstance(object o);
    public DerInteger get_Version();
    public bool get_IsTagged();
    public Asn1Encodable get_Info();
    private KekRecipientInfo GetKekInfo(Asn1TaggedObject o);
    public virtual Asn1Object ToAsn1Object();
}
public class Org.BouncyCastle.Asn1.Cms.RecipientKeyIdentifier : Asn1Encodable {
    private Asn1OctetString subjectKeyIdentifier;
    private DerGeneralizedTime date;
    private OtherKeyAttribute other;
    public Asn1OctetString SubjectKeyIdentifier { get; }
    public DerGeneralizedTime Date { get; }
    public OtherKeyAttribute OtherKeyAttribute { get; }
    public RecipientKeyIdentifier(Asn1OctetString subjectKeyIdentifier, DerGeneralizedTime date, OtherKeyAttribute other);
    public RecipientKeyIdentifier(Byte[] subjectKeyIdentifier);
    public RecipientKeyIdentifier(Byte[] subjectKeyIdentifier, DerGeneralizedTime date, OtherKeyAttribute other);
    public RecipientKeyIdentifier(Asn1Sequence seq);
    public static RecipientKeyIdentifier GetInstance(Asn1TaggedObject ato, bool explicitly);
    public static RecipientKeyIdentifier GetInstance(object obj);
    public Asn1OctetString get_SubjectKeyIdentifier();
    public DerGeneralizedTime get_Date();
    public OtherKeyAttribute get_OtherKeyAttribute();
    public virtual Asn1Object ToAsn1Object();
}
public class Org.BouncyCastle.Asn1.Cms.ScvpReqRes : Asn1Encodable {
    private ContentInfo request;
    private ContentInfo response;
    public ContentInfo Request { get; }
    public ContentInfo Response { get; }
    private ScvpReqRes(Asn1Sequence seq);
    public ScvpReqRes(ContentInfo response);
    public ScvpReqRes(ContentInfo request, ContentInfo response);
    public static ScvpReqRes GetInstance(object obj);
    public virtual ContentInfo get_Request();
    public virtual ContentInfo get_Response();
    public virtual Asn1Object ToAsn1Object();
}
public class Org.BouncyCastle.Asn1.Cms.SignedData : Asn1Encodable {
    private static DerInteger Version1;
    private static DerInteger Version3;
    private static DerInteger Version4;
    private static DerInteger Version5;
    private DerInteger version;
    private Asn1Set digestAlgorithms;
    private ContentInfo contentInfo;
    private Asn1Set certificates;
    private Asn1Set crls;
    private Asn1Set signerInfos;
    private bool certsBer;
    private bool crlsBer;
    public DerInteger Version { get; }
    public Asn1Set DigestAlgorithms { get; }
    public ContentInfo EncapContentInfo { get; }
    public Asn1Set Certificates { get; }
    public Asn1Set CRLs { get; }
    public Asn1Set SignerInfos { get; }
    public SignedData(Asn1Set digestAlgorithms, ContentInfo contentInfo, Asn1Set certificates, Asn1Set crls, Asn1Set signerInfos);
    private SignedData(Asn1Sequence seq);
    private static SignedData();
    public static SignedData GetInstance(object obj);
    private DerInteger CalculateVersion(DerObjectIdentifier contentOid, Asn1Set certs, Asn1Set crls, Asn1Set signerInfs);
    private bool CheckForVersion3(Asn1Set signerInfs);
    public DerInteger get_Version();
    public Asn1Set get_DigestAlgorithms();
    public ContentInfo get_EncapContentInfo();
    public Asn1Set get_Certificates();
    public Asn1Set get_CRLs();
    public Asn1Set get_SignerInfos();
    public virtual Asn1Object ToAsn1Object();
}
public class Org.BouncyCastle.Asn1.Cms.SignedDataParser : object {
    private Asn1SequenceParser _seq;
    private DerInteger _version;
    private object _nextObject;
    private bool _certsCalled;
    private bool _crlsCalled;
    public DerInteger Version { get; }
    public SignedDataParser(Asn1SequenceParser seq);
    public static SignedDataParser GetInstance(object o);
    public DerInteger get_Version();
    public Asn1SetParser GetDigestAlgorithms();
    public ContentInfoParser GetEncapContentInfo();
    public Asn1SetParser GetCertificates();
    public Asn1SetParser GetCrls();
    public Asn1SetParser GetSignerInfos();
}
public class Org.BouncyCastle.Asn1.Cms.SignerIdentifier : Asn1Encodable {
    private Asn1Encodable id;
    public bool IsTagged { get; }
    public Asn1Encodable ID { get; }
    public SignerIdentifier(IssuerAndSerialNumber id);
    public SignerIdentifier(Asn1OctetString id);
    public SignerIdentifier(Asn1Object id);
    public static SignerIdentifier GetInstance(object o);
    public bool get_IsTagged();
    public Asn1Encodable get_ID();
    public virtual Asn1Object ToAsn1Object();
}
public class Org.BouncyCastle.Asn1.Cms.SignerInfo : Asn1Encodable {
    private DerInteger version;
    private SignerIdentifier sid;
    private AlgorithmIdentifier digAlgorithm;
    private Asn1Set authenticatedAttributes;
    private AlgorithmIdentifier digEncryptionAlgorithm;
    private Asn1OctetString encryptedDigest;
    private Asn1Set unauthenticatedAttributes;
    public DerInteger Version { get; }
    public SignerIdentifier SignerID { get; }
    public Asn1Set AuthenticatedAttributes { get; }
    public AlgorithmIdentifier DigestAlgorithm { get; }
    public Asn1OctetString EncryptedDigest { get; }
    public AlgorithmIdentifier DigestEncryptionAlgorithm { get; }
    public Asn1Set UnauthenticatedAttributes { get; }
    public SignerInfo(SignerIdentifier sid, AlgorithmIdentifier digAlgorithm, Asn1Set authenticatedAttributes, AlgorithmIdentifier digEncryptionAlgorithm, Asn1OctetString encryptedDigest, Asn1Set unauthenticatedAttributes);
    public SignerInfo(SignerIdentifier sid, AlgorithmIdentifier digAlgorithm, Attributes authenticatedAttributes, AlgorithmIdentifier digEncryptionAlgorithm, Asn1OctetString encryptedDigest, Attributes unauthenticatedAttributes);
    [ObsoleteAttribute("Use 'GetInstance' instead")]
public SignerInfo(Asn1Sequence seq);
    public static SignerInfo GetInstance(object obj);
    public DerInteger get_Version();
    public SignerIdentifier get_SignerID();
    public Asn1Set get_AuthenticatedAttributes();
    public AlgorithmIdentifier get_DigestAlgorithm();
    public Asn1OctetString get_EncryptedDigest();
    public AlgorithmIdentifier get_DigestEncryptionAlgorithm();
    public Asn1Set get_UnauthenticatedAttributes();
    public virtual Asn1Object ToAsn1Object();
}
public class Org.BouncyCastle.Asn1.Cms.Time : Asn1Encodable {
    private Asn1Object time;
    public string TimeString { get; }
    public DateTime Date { get; }
    public Time(Asn1Object time);
    public Time(DateTime date);
    public static Time GetInstance(Asn1TaggedObject obj, bool explicitly);
    public static Time GetInstance(object obj);
    public string get_TimeString();
    public DateTime get_Date();
    public virtual Asn1Object ToAsn1Object();
}
public class Org.BouncyCastle.Asn1.Cms.TimeStampAndCrl : Asn1Encodable {
    private ContentInfo timeStamp;
    private CertificateList crl;
    public ContentInfo TimeStampToken { get; }
    public CertificateList Crl { get; }
    public TimeStampAndCrl(ContentInfo timeStamp);
    private TimeStampAndCrl(Asn1Sequence seq);
    public static TimeStampAndCrl GetInstance(object obj);
    public virtual ContentInfo get_TimeStampToken();
    public virtual CertificateList get_Crl();
    public virtual Asn1Object ToAsn1Object();
}
public class Org.BouncyCastle.Asn1.Cms.TimeStampedData : Asn1Encodable {
    private DerInteger version;
    private DerIA5String dataUri;
    private MetaData metaData;
    private Asn1OctetString content;
    private Evidence temporalEvidence;
    public DerIA5String DataUri { get; }
    public MetaData MetaData { get; }
    public Asn1OctetString Content { get; }
    public Evidence TemporalEvidence { get; }
    public TimeStampedData(DerIA5String dataUri, MetaData metaData, Asn1OctetString content, Evidence temporalEvidence);
    private TimeStampedData(Asn1Sequence seq);
    public static TimeStampedData GetInstance(object obj);
    public virtual DerIA5String get_DataUri();
    public MetaData get_MetaData();
    public Asn1OctetString get_Content();
    public Evidence get_TemporalEvidence();
    public virtual Asn1Object ToAsn1Object();
}
public class Org.BouncyCastle.Asn1.Cms.TimeStampedDataParser : object {
    private DerInteger version;
    private DerIA5String dataUri;
    private MetaData metaData;
    private Asn1OctetStringParser content;
    private Evidence temporalEvidence;
    private Asn1SequenceParser parser;
    public DerIA5String DataUri { get; }
    public MetaData MetaData { get; }
    public Asn1OctetStringParser Content { get; }
    private TimeStampedDataParser(Asn1SequenceParser parser);
    public static TimeStampedDataParser GetInstance(object obj);
    public virtual DerIA5String get_DataUri();
    public virtual MetaData get_MetaData();
    public virtual Asn1OctetStringParser get_Content();
    public virtual Evidence GetTemporalEvidence();
}
public class Org.BouncyCastle.Asn1.Cms.TimeStampTokenEvidence : Asn1Encodable {
    private TimeStampAndCrl[] timeStampAndCrls;
    public TimeStampTokenEvidence(TimeStampAndCrl[] timeStampAndCrls);
    public TimeStampTokenEvidence(TimeStampAndCrl timeStampAndCrl);
    private TimeStampTokenEvidence(Asn1Sequence seq);
    public static TimeStampTokenEvidence GetInstance(Asn1TaggedObject tagged, bool isExplicit);
    public static TimeStampTokenEvidence GetInstance(object obj);
    public virtual TimeStampAndCrl[] ToTimeStampAndCrlArray();
    public virtual Asn1Object ToAsn1Object();
}
internal class Org.BouncyCastle.Asn1.ConstructedOctetStream : BaseInputStream {
    private Asn1StreamParser _parser;
    private bool _first;
    private Stream _currentStream;
    internal ConstructedOctetStream(Asn1StreamParser parser);
    public virtual int Read(Byte[] buffer, int offset, int count);
    public virtual int ReadByte();
}
public class Org.BouncyCastle.Asn1.Crmf.AttributeTypeAndValue : Asn1Encodable {
    private DerObjectIdentifier type;
    private Asn1Encodable value;
    public DerObjectIdentifier Type { get; }
    public Asn1Encodable Value { get; }
    private AttributeTypeAndValue(Asn1Sequence seq);
    public AttributeTypeAndValue(string oid, Asn1Encodable value);
    public AttributeTypeAndValue(DerObjectIdentifier type, Asn1Encodable value);
    public static AttributeTypeAndValue GetInstance(object obj);
    public virtual DerObjectIdentifier get_Type();
    public virtual Asn1Encodable get_Value();
    public virtual Asn1Object ToAsn1Object();
}
public class Org.BouncyCastle.Asn1.Crmf.CertId : Asn1Encodable {
    private GeneralName issuer;
    private DerInteger serialNumber;
    public GeneralName Issuer { get; }
    public DerInteger SerialNumber { get; }
    private CertId(Asn1Sequence seq);
    public static CertId GetInstance(object obj);
    public static CertId GetInstance(Asn1TaggedObject obj, bool isExplicit);
    public virtual GeneralName get_Issuer();
    public virtual DerInteger get_SerialNumber();
    public virtual Asn1Object ToAsn1Object();
}
public class Org.BouncyCastle.Asn1.Crmf.CertReqMessages : Asn1Encodable {
    private Asn1Sequence content;
    private CertReqMessages(Asn1Sequence seq);
    public CertReqMessages(CertReqMsg[] msgs);
    public static CertReqMessages GetInstance(object obj);
    public virtual CertReqMsg[] ToCertReqMsgArray();
    public virtual Asn1Object ToAsn1Object();
}
public class Org.BouncyCastle.Asn1.Crmf.CertReqMsg : Asn1Encodable {
    private CertRequest certReq;
    private ProofOfPossession popo;
    private Asn1Sequence regInfo;
    public CertRequest CertReq { get; }
    public ProofOfPossession Popo { get; }
    private CertReqMsg(Asn1Sequence seq);
    public CertReqMsg(CertRequest certReq, ProofOfPossession popo, AttributeTypeAndValue[] regInfo);
    public static CertReqMsg GetInstance(object obj);
    public virtual CertRequest get_CertReq();
    public virtual ProofOfPossession get_Popo();
    public virtual AttributeTypeAndValue[] GetRegInfo();
    public virtual Asn1Object ToAsn1Object();
}
public class Org.BouncyCastle.Asn1.Crmf.CertRequest : Asn1Encodable {
    private DerInteger certReqId;
    private CertTemplate certTemplate;
    private Controls controls;
    public DerInteger CertReqID { get; }
    public CertTemplate CertTemplate { get; }
    public Controls Controls { get; }
    private CertRequest(Asn1Sequence seq);
    public CertRequest(int certReqId, CertTemplate certTemplate, Controls controls);
    public CertRequest(DerInteger certReqId, CertTemplate certTemplate, Controls controls);
    public static CertRequest GetInstance(object obj);
    public virtual DerInteger get_CertReqID();
    public virtual CertTemplate get_CertTemplate();
    public virtual Controls get_Controls();
    public virtual Asn1Object ToAsn1Object();
}
public class Org.BouncyCastle.Asn1.Crmf.CertTemplate : Asn1Encodable {
    private Asn1Sequence seq;
    private DerInteger version;
    private DerInteger serialNumber;
    private AlgorithmIdentifier signingAlg;
    private X509Name issuer;
    private OptionalValidity validity;
    private X509Name subject;
    private SubjectPublicKeyInfo publicKey;
    private DerBitString issuerUID;
    private DerBitString subjectUID;
    private X509Extensions extensions;
    public int Version { get; }
    public DerInteger SerialNumber { get; }
    public AlgorithmIdentifier SigningAlg { get; }
    public X509Name Issuer { get; }
    public OptionalValidity Validity { get; }
    public X509Name Subject { get; }
    public SubjectPublicKeyInfo PublicKey { get; }
    public DerBitString IssuerUID { get; }
    public DerBitString SubjectUID { get; }
    public X509Extensions Extensions { get; }
    private CertTemplate(Asn1Sequence seq);
    public static CertTemplate GetInstance(object obj);
    public virtual int get_Version();
    public virtual DerInteger get_SerialNumber();
    public virtual AlgorithmIdentifier get_SigningAlg();
    public virtual X509Name get_Issuer();
    public virtual OptionalValidity get_Validity();
    public virtual X509Name get_Subject();
    public virtual SubjectPublicKeyInfo get_PublicKey();
    public virtual DerBitString get_IssuerUID();
    public virtual DerBitString get_SubjectUID();
    public virtual X509Extensions get_Extensions();
    public virtual Asn1Object ToAsn1Object();
}
public class Org.BouncyCastle.Asn1.Crmf.CertTemplateBuilder : object {
    private DerInteger version;
    private DerInteger serialNumber;
    private AlgorithmIdentifier signingAlg;
    private X509Name issuer;
    private OptionalValidity validity;
    private X509Name subject;
    private SubjectPublicKeyInfo publicKey;
    private DerBitString issuerUID;
    private DerBitString subjectUID;
    private X509Extensions extensions;
    public virtual CertTemplateBuilder SetVersion(int ver);
    public virtual CertTemplateBuilder SetSerialNumber(DerInteger ser);
    public virtual CertTemplateBuilder SetSigningAlg(AlgorithmIdentifier aid);
    public virtual CertTemplateBuilder SetIssuer(X509Name name);
    public virtual CertTemplateBuilder SetValidity(OptionalValidity v);
    public virtual CertTemplateBuilder SetSubject(X509Name name);
    public virtual CertTemplateBuilder SetPublicKey(SubjectPublicKeyInfo spki);
    public virtual CertTemplateBuilder SetIssuerUID(DerBitString uid);
    public virtual CertTemplateBuilder SetSubjectUID(DerBitString uid);
    public virtual CertTemplateBuilder SetExtensions(X509Extensions extens);
    public virtual CertTemplate Build();
    private void AddOptional(Asn1EncodableVector v, int tagNo, bool isExplicit, Asn1Encodable obj);
}
public class Org.BouncyCastle.Asn1.Crmf.Controls : Asn1Encodable {
    private Asn1Sequence content;
    private Controls(Asn1Sequence seq);
    public Controls(AttributeTypeAndValue[] atvs);
    public static Controls GetInstance(object obj);
    public virtual AttributeTypeAndValue[] ToAttributeTypeAndValueArray();
    public virtual Asn1Object ToAsn1Object();
}
public abstract class Org.BouncyCastle.Asn1.Crmf.CrmfObjectIdentifiers : object {
    public static DerObjectIdentifier id_pkix;
    public static DerObjectIdentifier id_pkip;
    public static DerObjectIdentifier id_regCtrl;
    public static DerObjectIdentifier id_regCtrl_regToken;
    public static DerObjectIdentifier id_regCtrl_authenticator;
    public static DerObjectIdentifier id_regCtrl_pkiPublicationInfo;
    public static DerObjectIdentifier id_regCtrl_pkiArchiveOptions;
    public static DerObjectIdentifier id_ct_encKeyWithID;
    private static CrmfObjectIdentifiers();
}
public class Org.BouncyCastle.Asn1.Crmf.EncKeyWithID : Asn1Encodable {
    private PrivateKeyInfo privKeyInfo;
    private Asn1Encodable identifier;
    public PrivateKeyInfo PrivateKey { get; }
    public bool HasIdentifier { get; }
    public bool IsIdentifierUtf8String { get; }
    public Asn1Encodable Identifier { get; }
    private EncKeyWithID(Asn1Sequence seq);
    public EncKeyWithID(PrivateKeyInfo privKeyInfo);
    public EncKeyWithID(PrivateKeyInfo privKeyInfo, DerUtf8String str);
    public EncKeyWithID(PrivateKeyInfo privKeyInfo, GeneralName generalName);
    public static EncKeyWithID GetInstance(object obj);
    public virtual PrivateKeyInfo get_PrivateKey();
    public virtual bool get_HasIdentifier();
    public virtual bool get_IsIdentifierUtf8String();
    public virtual Asn1Encodable get_Identifier();
    public virtual Asn1Object ToAsn1Object();
}
public class Org.BouncyCastle.Asn1.Crmf.EncryptedKey : Asn1Encodable {
    private EnvelopedData envelopedData;
    private EncryptedValue encryptedValue;
    public bool IsEncryptedValue { get; }
    public Asn1Encodable Value { get; }
    public EncryptedKey(EnvelopedData envelopedData);
    public EncryptedKey(EncryptedValue encryptedValue);
    public static EncryptedKey GetInstance(object o);
    public virtual bool get_IsEncryptedValue();
    public virtual Asn1Encodable get_Value();
    public virtual Asn1Object ToAsn1Object();
}
public class Org.BouncyCastle.Asn1.Crmf.EncryptedValue : Asn1Encodable {
    private AlgorithmIdentifier intendedAlg;
    private AlgorithmIdentifier symmAlg;
    private DerBitString encSymmKey;
    private AlgorithmIdentifier keyAlg;
    private Asn1OctetString valueHint;
    private DerBitString encValue;
    public AlgorithmIdentifier IntendedAlg { get; }
    public AlgorithmIdentifier SymmAlg { get; }
    public DerBitString EncSymmKey { get; }
    public AlgorithmIdentifier KeyAlg { get; }
    public Asn1OctetString ValueHint { get; }
    public DerBitString EncValue { get; }
    private EncryptedValue(Asn1Sequence seq);
    public EncryptedValue(AlgorithmIdentifier intendedAlg, AlgorithmIdentifier symmAlg, DerBitString encSymmKey, AlgorithmIdentifier keyAlg, Asn1OctetString valueHint, DerBitString encValue);
    public static EncryptedValue GetInstance(object obj);
    public virtual AlgorithmIdentifier get_IntendedAlg();
    public virtual AlgorithmIdentifier get_SymmAlg();
    public virtual DerBitString get_EncSymmKey();
    public virtual AlgorithmIdentifier get_KeyAlg();
    public virtual Asn1OctetString get_ValueHint();
    public virtual DerBitString get_EncValue();
    public virtual Asn1Object ToAsn1Object();
    private void AddOptional(Asn1EncodableVector v, int tagNo, Asn1Encodable obj);
}
public class Org.BouncyCastle.Asn1.Crmf.OptionalValidity : Asn1Encodable {
    private Time notBefore;
    private Time notAfter;
    public Time NotBefore { get; }
    public Time NotAfter { get; }
    private OptionalValidity(Asn1Sequence seq);
    public static OptionalValidity GetInstance(object obj);
    public virtual Time get_NotBefore();
    public virtual Time get_NotAfter();
    public virtual Asn1Object ToAsn1Object();
}
public class Org.BouncyCastle.Asn1.Crmf.PkiArchiveOptions : Asn1Encodable {
    public static int encryptedPrivKey;
    public static int keyGenParameters;
    public static int archiveRemGenPrivKey;
    private Asn1Encodable value;
    public int Type { get; }
    public Asn1Encodable Value { get; }
    private PkiArchiveOptions(Asn1TaggedObject tagged);
    public PkiArchiveOptions(EncryptedKey encKey);
    public PkiArchiveOptions(Asn1OctetString keyGenParameters);
    public PkiArchiveOptions(bool archiveRemGenPrivKey);
    public static PkiArchiveOptions GetInstance(object obj);
    public virtual int get_Type();
    public virtual Asn1Encodable get_Value();
    public virtual Asn1Object ToAsn1Object();
}
public class Org.BouncyCastle.Asn1.Crmf.PkiPublicationInfo : Asn1Encodable {
    private DerInteger action;
    private Asn1Sequence pubInfos;
    public DerInteger Action { get; }
    private PkiPublicationInfo(Asn1Sequence seq);
    public static PkiPublicationInfo GetInstance(object obj);
    public virtual DerInteger get_Action();
    public virtual SinglePubInfo[] GetPubInfos();
    public virtual Asn1Object ToAsn1Object();
}
public class Org.BouncyCastle.Asn1.Crmf.PKMacValue : Asn1Encodable {
    private AlgorithmIdentifier algID;
    private DerBitString macValue;
    public AlgorithmIdentifier AlgID { get; }
    public DerBitString MacValue { get; }
    private PKMacValue(Asn1Sequence seq);
    public PKMacValue(PbmParameter pbmParams, DerBitString macValue);
    public PKMacValue(AlgorithmIdentifier algID, DerBitString macValue);
    public static PKMacValue GetInstance(object obj);
    public static PKMacValue GetInstance(Asn1TaggedObject obj, bool isExplicit);
    public virtual AlgorithmIdentifier get_AlgID();
    public virtual DerBitString get_MacValue();
    public virtual Asn1Object ToAsn1Object();
}
public class Org.BouncyCastle.Asn1.Crmf.PopoPrivKey : Asn1Encodable {
    public static int thisMessage;
    public static int subsequentMessage;
    public static int dhMAC;
    public static int agreeMAC;
    public static int encryptedKey;
    private int tagNo;
    private Asn1Encodable obj;
    public int Type { get; }
    public Asn1Encodable Value { get; }
    private PopoPrivKey(Asn1TaggedObject obj);
    public PopoPrivKey(SubsequentMessage msg);
    public static PopoPrivKey GetInstance(Asn1TaggedObject tagged, bool isExplicit);
    public virtual int get_Type();
    public virtual Asn1Encodable get_Value();
    public virtual Asn1Object ToAsn1Object();
}
public class Org.BouncyCastle.Asn1.Crmf.PopoSigningKey : Asn1Encodable {
    private PopoSigningKeyInput poposkInput;
    private AlgorithmIdentifier algorithmIdentifier;
    private DerBitString signature;
    public PopoSigningKeyInput PoposkInput { get; }
    public AlgorithmIdentifier AlgorithmIdentifier { get; }
    public DerBitString Signature { get; }
    private PopoSigningKey(Asn1Sequence seq);
    public PopoSigningKey(PopoSigningKeyInput poposkIn, AlgorithmIdentifier aid, DerBitString signature);
    public static PopoSigningKey GetInstance(object obj);
    public static PopoSigningKey GetInstance(Asn1TaggedObject obj, bool isExplicit);
    public virtual PopoSigningKeyInput get_PoposkInput();
    public virtual AlgorithmIdentifier get_AlgorithmIdentifier();
    public virtual DerBitString get_Signature();
    public virtual Asn1Object ToAsn1Object();
}
public class Org.BouncyCastle.Asn1.Crmf.PopoSigningKeyInput : Asn1Encodable {
    private GeneralName sender;
    private PKMacValue publicKeyMac;
    private SubjectPublicKeyInfo publicKey;
    public GeneralName Sender { get; }
    public PKMacValue PublicKeyMac { get; }
    public SubjectPublicKeyInfo PublicKey { get; }
    private PopoSigningKeyInput(Asn1Sequence seq);
    public PopoSigningKeyInput(GeneralName sender, SubjectPublicKeyInfo spki);
    public PopoSigningKeyInput(PKMacValue pkmac, SubjectPublicKeyInfo spki);
    public static PopoSigningKeyInput GetInstance(object obj);
    public virtual GeneralName get_Sender();
    public virtual PKMacValue get_PublicKeyMac();
    public virtual SubjectPublicKeyInfo get_PublicKey();
    public virtual Asn1Object ToAsn1Object();
}
public class Org.BouncyCastle.Asn1.Crmf.ProofOfPossession : Asn1Encodable {
    public static int TYPE_RA_VERIFIED;
    public static int TYPE_SIGNING_KEY;
    public static int TYPE_KEY_ENCIPHERMENT;
    public static int TYPE_KEY_AGREEMENT;
    private int tagNo;
    private Asn1Encodable obj;
    public int Type { get; }
    public Asn1Encodable Object { get; }
    private ProofOfPossession(Asn1TaggedObject tagged);
    public ProofOfPossession(PopoSigningKey Poposk);
    public ProofOfPossession(int type, PopoPrivKey privkey);
    public static ProofOfPossession GetInstance(object obj);
    public virtual int get_Type();
    public virtual Asn1Encodable get_Object();
    public virtual Asn1Object ToAsn1Object();
}
public class Org.BouncyCastle.Asn1.Crmf.SinglePubInfo : Asn1Encodable {
    private DerInteger pubMethod;
    private GeneralName pubLocation;
    public GeneralName PubLocation { get; }
    private SinglePubInfo(Asn1Sequence seq);
    public static SinglePubInfo GetInstance(object obj);
    public virtual GeneralName get_PubLocation();
    public virtual Asn1Object ToAsn1Object();
}
public class Org.BouncyCastle.Asn1.Crmf.SubsequentMessage : DerInteger {
    public static SubsequentMessage encrCert;
    public static SubsequentMessage challengeResp;
    private SubsequentMessage(int value);
    private static SubsequentMessage();
    public static SubsequentMessage ValueOf(int value);
}
public abstract class Org.BouncyCastle.Asn1.CryptoPro.CryptoProObjectIdentifiers : object {
    public static string GostID;
    public static DerObjectIdentifier GostR3411;
    public static DerObjectIdentifier GostR3411Hmac;
    public static DerObjectIdentifier GostR28147Cbc;
    public static DerObjectIdentifier ID_Gost28147_89_CryptoPro_A_ParamSet;
    public static DerObjectIdentifier GostR3410x94;
    public static DerObjectIdentifier GostR3410x2001;
    public static DerObjectIdentifier GostR3411x94WithGostR3410x94;
    public static DerObjectIdentifier GostR3411x94WithGostR3410x2001;
    public static DerObjectIdentifier GostR3411x94CryptoProParamSet;
    public static DerObjectIdentifier GostR3410x94CryptoProA;
    public static DerObjectIdentifier GostR3410x94CryptoProB;
    public static DerObjectIdentifier GostR3410x94CryptoProC;
    public static DerObjectIdentifier GostR3410x94CryptoProD;
    public static DerObjectIdentifier GostR3410x94CryptoProXchA;
    public static DerObjectIdentifier GostR3410x94CryptoProXchB;
    public static DerObjectIdentifier GostR3410x94CryptoProXchC;
    public static DerObjectIdentifier GostR3410x2001CryptoProA;
    public static DerObjectIdentifier GostR3410x2001CryptoProB;
    public static DerObjectIdentifier GostR3410x2001CryptoProC;
    public static DerObjectIdentifier GostR3410x2001CryptoProXchA;
    public static DerObjectIdentifier GostR3410x2001CryptoProXchB;
    public static DerObjectIdentifier GostElSgDH3410Default;
    public static DerObjectIdentifier GostElSgDH3410x1;
    private static CryptoProObjectIdentifiers();
}
public class Org.BouncyCastle.Asn1.CryptoPro.ECGost3410NamedCurves : object {
    internal static IDictionary objIds;
    internal static IDictionary parameters;
    internal static IDictionary names;
    public static IEnumerable Names { get; }
    private static ECGost3410NamedCurves();
    public static ECDomainParameters GetByOid(DerObjectIdentifier oid);
    public static IEnumerable get_Names();
    public static ECDomainParameters GetByName(string name);
    public static string GetName(DerObjectIdentifier oid);
    public static DerObjectIdentifier GetOid(string name);
}
public class Org.BouncyCastle.Asn1.CryptoPro.ECGost3410ParamSetParameters : Asn1Encodable {
    internal DerInteger p;
    internal DerInteger q;
    internal DerInteger a;
    internal DerInteger b;
    internal DerInteger x;
    internal DerInteger y;
    public BigInteger P { get; }
    public BigInteger Q { get; }
    public BigInteger A { get; }
    public ECGost3410ParamSetParameters(BigInteger a, BigInteger b, BigInteger p, BigInteger q, int x, BigInteger y);
    public ECGost3410ParamSetParameters(Asn1Sequence seq);
    public static ECGost3410ParamSetParameters GetInstance(Asn1TaggedObject obj, bool explicitly);
    public static ECGost3410ParamSetParameters GetInstance(object obj);
    public BigInteger get_P();
    public BigInteger get_Q();
    public BigInteger get_A();
    public virtual Asn1Object ToAsn1Object();
}
public class Org.BouncyCastle.Asn1.CryptoPro.Gost28147Parameters : Asn1Encodable {
    private Asn1OctetString iv;
    private DerObjectIdentifier paramSet;
    private Gost28147Parameters(Asn1Sequence seq);
    public static Gost28147Parameters GetInstance(Asn1TaggedObject obj, bool explicitly);
    public static Gost28147Parameters GetInstance(object obj);
    public virtual Asn1Object ToAsn1Object();
}
public class Org.BouncyCastle.Asn1.CryptoPro.Gost3410NamedParameters : object {
    private static IDictionary objIds;
    private static IDictionary parameters;
    private static Gost3410ParamSetParameters cryptoProA;
    private static Gost3410ParamSetParameters cryptoProB;
    private static Gost3410ParamSetParameters cryptoProXchA;
    public static IEnumerable Names { get; }
    private static Gost3410NamedParameters();
    public static Gost3410ParamSetParameters GetByOid(DerObjectIdentifier oid);
    public static IEnumerable get_Names();
    public static Gost3410ParamSetParameters GetByName(string name);
    public static DerObjectIdentifier GetOid(string name);
}
public class Org.BouncyCastle.Asn1.CryptoPro.Gost3410ParamSetParameters : Asn1Encodable {
    private int keySize;
    private DerInteger p;
    private DerInteger q;
    private DerInteger a;
    public int KeySize { get; }
    public BigInteger P { get; }
    public BigInteger Q { get; }
    public BigInteger A { get; }
    public Gost3410ParamSetParameters(int keySize, BigInteger p, BigInteger q, BigInteger a);
    private Gost3410ParamSetParameters(Asn1Sequence seq);
    public static Gost3410ParamSetParameters GetInstance(Asn1TaggedObject obj, bool explicitly);
    public static Gost3410ParamSetParameters GetInstance(object obj);
    public int get_KeySize();
    public BigInteger get_P();
    public BigInteger get_Q();
    public BigInteger get_A();
    public virtual Asn1Object ToAsn1Object();
}
public class Org.BouncyCastle.Asn1.CryptoPro.Gost3410PublicKeyAlgParameters : Asn1Encodable {
    private DerObjectIdentifier publicKeyParamSet;
    private DerObjectIdentifier digestParamSet;
    private DerObjectIdentifier encryptionParamSet;
    public DerObjectIdentifier PublicKeyParamSet { get; }
    public DerObjectIdentifier DigestParamSet { get; }
    public DerObjectIdentifier EncryptionParamSet { get; }
    public Gost3410PublicKeyAlgParameters(DerObjectIdentifier publicKeyParamSet, DerObjectIdentifier digestParamSet);
    public Gost3410PublicKeyAlgParameters(DerObjectIdentifier publicKeyParamSet, DerObjectIdentifier digestParamSet, DerObjectIdentifier encryptionParamSet);
    public Gost3410PublicKeyAlgParameters(Asn1Sequence seq);
    public static Gost3410PublicKeyAlgParameters GetInstance(Asn1TaggedObject obj, bool explicitly);
    public static Gost3410PublicKeyAlgParameters GetInstance(object obj);
    public DerObjectIdentifier get_PublicKeyParamSet();
    public DerObjectIdentifier get_DigestParamSet();
    public DerObjectIdentifier get_EncryptionParamSet();
    public virtual Asn1Object ToAsn1Object();
}
internal class Org.BouncyCastle.Asn1.DefiniteLengthInputStream : LimitedInputStream {
    private static Byte[] EmptyBytes;
    private int _originalLength;
    private int _remaining;
    internal int Remaining { get; }
    internal DefiniteLengthInputStream(Stream inStream, int length);
    private static DefiniteLengthInputStream();
    internal int get_Remaining();
    public virtual int ReadByte();
    public virtual int Read(Byte[] buf, int off, int len);
    internal void ReadAllIntoByteArray(Byte[] buf);
    internal Byte[] ToArray();
}
public class Org.BouncyCastle.Asn1.DerApplicationSpecific : Asn1Object {
    private bool isConstructed;
    private int tag;
    private Byte[] octets;
    public int ApplicationTag { get; }
    internal DerApplicationSpecific(bool isConstructed, int tag, Byte[] octets);
    public DerApplicationSpecific(int tag, Byte[] octets);
    public DerApplicationSpecific(int tag, Asn1Encodable obj);
    public DerApplicationSpecific(bool isExplicit, int tag, Asn1Encodable obj);
    public DerApplicationSpecific(int tagNo, Asn1EncodableVector vec);
    private int GetLengthOfHeader(Byte[] data);
    public bool IsConstructed();
    public Byte[] GetContents();
    public int get_ApplicationTag();
    public Asn1Object GetObject();
    public Asn1Object GetObject(int derTagNo);
    internal virtual void Encode(DerOutputStream derOut);
    protected virtual bool Asn1Equals(Asn1Object asn1Object);
    protected virtual int Asn1GetHashCode();
    private Byte[] ReplaceTagNumber(int newTag, Byte[] input);
}
public class Org.BouncyCastle.Asn1.DerBitString : DerStringBase {
    private static Char[] table;
    private Byte[] data;
    private int padBits;
    public int PadBits { get; }
    public int IntValue { get; }
    internal DerBitString(byte data, int padBits);
    public DerBitString(Byte[] data, int padBits);
    public DerBitString(Byte[] data);
    public DerBitString(Asn1Encodable obj);
    private static DerBitString();
    internal static int GetPadBits(int bitString);
    internal static Byte[] GetBytes(int bitString);
    public static DerBitString GetInstance(object obj);
    public static DerBitString GetInstance(Asn1TaggedObject obj, bool isExplicit);
    public Byte[] GetBytes();
    public int get_PadBits();
    public int get_IntValue();
    internal virtual void Encode(DerOutputStream derOut);
    protected virtual int Asn1GetHashCode();
    protected virtual bool Asn1Equals(Asn1Object asn1Object);
    public virtual string GetString();
    internal static DerBitString FromAsn1Octets(Byte[] octets);
}
public class Org.BouncyCastle.Asn1.DerBmpString : DerStringBase {
    private string str;
    public DerBmpString(Byte[] str);
    public DerBmpString(string str);
    public static DerBmpString GetInstance(object obj);
    public static DerBmpString GetInstance(Asn1TaggedObject obj, bool isExplicit);
    public virtual string GetString();
    protected virtual bool Asn1Equals(Asn1Object asn1Object);
    internal virtual void Encode(DerOutputStream derOut);
}
public class Org.BouncyCastle.Asn1.DerBoolean : Asn1Object {
    private byte value;
    public static DerBoolean False;
    public static DerBoolean True;
    public bool IsTrue { get; }
    public DerBoolean(Byte[] val);
    private DerBoolean(bool value);
    private static DerBoolean();
    public static DerBoolean GetInstance(object obj);
    public static DerBoolean GetInstance(bool value);
    public static DerBoolean GetInstance(Asn1TaggedObject obj, bool isExplicit);
    public bool get_IsTrue();
    internal virtual void Encode(DerOutputStream derOut);
    protected virtual bool Asn1Equals(Asn1Object asn1Object);
    protected virtual int Asn1GetHashCode();
    public virtual string ToString();
}
public class Org.BouncyCastle.Asn1.DerEnumerated : Asn1Object {
    private Byte[] bytes;
    public BigInteger Value { get; }
    public DerEnumerated(int val);
    public DerEnumerated(BigInteger val);
    public DerEnumerated(Byte[] bytes);
    public static DerEnumerated GetInstance(object obj);
    public static DerEnumerated GetInstance(Asn1TaggedObject obj, bool isExplicit);
    public BigInteger get_Value();
    internal virtual void Encode(DerOutputStream derOut);
    protected virtual bool Asn1Equals(Asn1Object asn1Object);
    protected virtual int Asn1GetHashCode();
}
public class Org.BouncyCastle.Asn1.DerExternal : Asn1Object {
    private DerObjectIdentifier directReference;
    private DerInteger indirectReference;
    private Asn1Object dataValueDescriptor;
    private int encoding;
    private Asn1Object externalContent;
    public Asn1Object DataValueDescriptor { get; public set; }
    public DerObjectIdentifier DirectReference { get; public set; }
    public int Encoding { get; public set; }
    public Asn1Object ExternalContent { get; public set; }
    public DerInteger IndirectReference { get; public set; }
    public DerExternal(Asn1EncodableVector vector);
    public DerExternal(DerObjectIdentifier directReference, DerInteger indirectReference, Asn1Object dataValueDescriptor, DerTaggedObject externalData);
    public DerExternal(DerObjectIdentifier directReference, DerInteger indirectReference, Asn1Object dataValueDescriptor, int encoding, Asn1Object externalData);
    internal virtual void Encode(DerOutputStream derOut);
    protected virtual int Asn1GetHashCode();
    protected virtual bool Asn1Equals(Asn1Object asn1Object);
    public Asn1Object get_DataValueDescriptor();
    public void set_DataValueDescriptor(Asn1Object value);
    public DerObjectIdentifier get_DirectReference();
    public void set_DirectReference(DerObjectIdentifier value);
    public int get_Encoding();
    public void set_Encoding(int value);
    public Asn1Object get_ExternalContent();
    public void set_ExternalContent(Asn1Object value);
    public DerInteger get_IndirectReference();
    public void set_IndirectReference(DerInteger value);
    private static Asn1Object GetObjFromVector(Asn1EncodableVector v, int index);
    private static void WriteEncodable(MemoryStream ms, Asn1Encodable e);
}
public class Org.BouncyCastle.Asn1.DerExternalParser : Asn1Encodable {
    private Asn1StreamParser _parser;
    public DerExternalParser(Asn1StreamParser parser);
    public IAsn1Convertible ReadObject();
    public virtual Asn1Object ToAsn1Object();
}
public class Org.BouncyCastle.Asn1.DerGeneralizedTime : Asn1Object {
    private string time;
    public string TimeString { get; }
    private bool HasFractionalSeconds { get; }
    public DerGeneralizedTime(string time);
    public DerGeneralizedTime(DateTime time);
    internal DerGeneralizedTime(Byte[] bytes);
    public static DerGeneralizedTime GetInstance(object obj);
    public static DerGeneralizedTime GetInstance(Asn1TaggedObject obj, bool isExplicit);
    public string get_TimeString();
    public string GetTime();
    private string CalculateGmtOffset();
    private static string Convert(int time);
    public DateTime ToDateTime();
    private string FString(int count);
    private DateTime ParseDateString(string dateStr, string formatStr, bool makeUniversal);
    private bool get_HasFractionalSeconds();
    private Byte[] GetOctets();
    internal virtual void Encode(DerOutputStream derOut);
    protected virtual bool Asn1Equals(Asn1Object asn1Object);
    protected virtual int Asn1GetHashCode();
}
public class Org.BouncyCastle.Asn1.DerGeneralString : DerStringBase {
    private string str;
    public DerGeneralString(Byte[] str);
    public DerGeneralString(string str);
    public static DerGeneralString GetInstance(object obj);
    public static DerGeneralString GetInstance(Asn1TaggedObject obj, bool isExplicit);
    public virtual string GetString();
    public Byte[] GetOctets();
    internal virtual void Encode(DerOutputStream derOut);
    protected virtual bool Asn1Equals(Asn1Object asn1Object);
}
public abstract class Org.BouncyCastle.Asn1.DerGenerator : Asn1Generator {
    private bool _tagged;
    private bool _isExplicit;
    private int _tagNo;
    protected DerGenerator(Stream outStream);
    protected DerGenerator(Stream outStream, int tagNo, bool isExplicit);
    private static void WriteLength(Stream outStr, int length);
    internal static void WriteDerEncoded(Stream outStream, int tag, Byte[] bytes);
    internal void WriteDerEncoded(int tag, Byte[] bytes);
    internal static void WriteDerEncoded(Stream outStr, int tag, Stream inStr);
}
public class Org.BouncyCastle.Asn1.DerIA5String : DerStringBase {
    private string str;
    public DerIA5String(Byte[] str);
    public DerIA5String(string str);
    public DerIA5String(string str, bool validate);
    public static DerIA5String GetInstance(object obj);
    public static DerIA5String GetInstance(Asn1TaggedObject obj, bool isExplicit);
    public virtual string GetString();
    public Byte[] GetOctets();
    internal virtual void Encode(DerOutputStream derOut);
    protected virtual int Asn1GetHashCode();
    protected virtual bool Asn1Equals(Asn1Object asn1Object);
    public static bool IsIA5String(string str);
}
public class Org.BouncyCastle.Asn1.DerInteger : Asn1Object {
    private Byte[] bytes;
    public BigInteger Value { get; }
    public BigInteger PositiveValue { get; }
    public DerInteger(int value);
    public DerInteger(BigInteger value);
    public DerInteger(Byte[] bytes);
    public static DerInteger GetInstance(object obj);
    public static DerInteger GetInstance(Asn1TaggedObject obj, bool isExplicit);
    public BigInteger get_Value();
    public BigInteger get_PositiveValue();
    internal virtual void Encode(DerOutputStream derOut);
    protected virtual int Asn1GetHashCode();
    protected virtual bool Asn1Equals(Asn1Object asn1Object);
    public virtual string ToString();
}
public class Org.BouncyCastle.Asn1.DerNull : Asn1Null {
    public static DerNull Instance;
    private Byte[] zeroBytes;
    protected internal DerNull(int dummy);
    private static DerNull();
    internal virtual void Encode(DerOutputStream derOut);
    protected virtual bool Asn1Equals(Asn1Object asn1Object);
    protected virtual int Asn1GetHashCode();
}
public class Org.BouncyCastle.Asn1.DerNumericString : DerStringBase {
    private string str;
    public DerNumericString(Byte[] str);
    public DerNumericString(string str);
    public DerNumericString(string str, bool validate);
    public static DerNumericString GetInstance(object obj);
    public static DerNumericString GetInstance(Asn1TaggedObject obj, bool isExplicit);
    public virtual string GetString();
    public Byte[] GetOctets();
    internal virtual void Encode(DerOutputStream derOut);
    protected virtual bool Asn1Equals(Asn1Object asn1Object);
    public static bool IsNumericString(string str);
}
public class Org.BouncyCastle.Asn1.DerObjectIdentifier : Asn1Object {
    private static long LONG_LIMIT;
    private string identifier;
    private Byte[] body;
    private static DerObjectIdentifier[] cache;
    public string Id { get; }
    public DerObjectIdentifier(string identifier);
    internal DerObjectIdentifier(DerObjectIdentifier oid, string branchID);
    internal DerObjectIdentifier(Byte[] bytes);
    private static DerObjectIdentifier();
    public static DerObjectIdentifier GetInstance(object obj);
    public static DerObjectIdentifier GetInstance(Asn1TaggedObject obj, bool explicitly);
    public string get_Id();
    public virtual DerObjectIdentifier Branch(string branchID);
    public virtual bool On(DerObjectIdentifier stem);
    private void WriteField(Stream outputStream, long fieldValue);
    private void WriteField(Stream outputStream, BigInteger fieldValue);
    private void DoOutput(MemoryStream bOut);
    internal Byte[] GetBody();
    internal virtual void Encode(DerOutputStream derOut);
    protected virtual int Asn1GetHashCode();
    protected virtual bool Asn1Equals(Asn1Object asn1Object);
    public virtual string ToString();
    private static bool IsValidBranchID(string branchID, int start);
    private static bool IsValidIdentifier(string identifier);
    private static string MakeOidStringFromBytes(Byte[] bytes);
    internal static DerObjectIdentifier FromOctetString(Byte[] enc);
}
public class Org.BouncyCastle.Asn1.DerOctetString : Asn1OctetString {
    public DerOctetString(Byte[] str);
    public DerOctetString(Asn1Encodable obj);
    internal virtual void Encode(DerOutputStream derOut);
    internal static void Encode(DerOutputStream derOut, Byte[] bytes, int offset, int length);
}
public class Org.BouncyCastle.Asn1.DerOctetStringParser : object {
    private DefiniteLengthInputStream stream;
    internal DerOctetStringParser(DefiniteLengthInputStream stream);
    public sealed virtual Stream GetOctetStream();
    public sealed virtual Asn1Object ToAsn1Object();
}
public class Org.BouncyCastle.Asn1.DerOutputStream : FilterStream {
    public DerOutputStream(Stream os);
    private void WriteLength(int length);
    internal void WriteEncoded(int tag, Byte[] bytes);
    internal void WriteEncoded(int tag, Byte[] bytes, int offset, int length);
    internal void WriteTag(int flags, int tagNo);
    internal void WriteEncoded(int flags, int tagNo, Byte[] bytes);
    protected void WriteNull();
    [ObsoleteAttribute("Use version taking an Asn1Encodable arg instead")]
public virtual void WriteObject(object obj);
    public virtual void WriteObject(Asn1Encodable obj);
    public virtual void WriteObject(Asn1Object obj);
}
public class Org.BouncyCastle.Asn1.DerPrintableString : DerStringBase {
    private string str;
    public DerPrintableString(Byte[] str);
    public DerPrintableString(string str);
    public DerPrintableString(string str, bool validate);
    public static DerPrintableString GetInstance(object obj);
    public static DerPrintableString GetInstance(Asn1TaggedObject obj, bool isExplicit);
    public virtual string GetString();
    public Byte[] GetOctets();
    internal virtual void Encode(DerOutputStream derOut);
    protected virtual bool Asn1Equals(Asn1Object asn1Object);
    public static bool IsPrintableString(string str);
}
public class Org.BouncyCastle.Asn1.DerSequence : Asn1Sequence {
    public static DerSequence Empty;
    public DerSequence(Asn1Encodable obj);
    public DerSequence(Asn1Encodable[] v);
    public DerSequence(Asn1EncodableVector v);
    private static DerSequence();
    public static DerSequence FromVector(Asn1EncodableVector v);
    internal virtual void Encode(DerOutputStream derOut);
}
public class Org.BouncyCastle.Asn1.DerSequenceGenerator : DerGenerator {
    private MemoryStream _bOut;
    public DerSequenceGenerator(Stream outStream);
    public DerSequenceGenerator(Stream outStream, int tagNo, bool isExplicit);
    public virtual void AddObject(Asn1Encodable obj);
    public virtual Stream GetRawOutputStream();
    public virtual void Close();
}
public class Org.BouncyCastle.Asn1.DerSequenceParser : object {
    private Asn1StreamParser _parser;
    internal DerSequenceParser(Asn1StreamParser parser);
    public sealed virtual IAsn1Convertible ReadObject();
    public sealed virtual Asn1Object ToAsn1Object();
}
public class Org.BouncyCastle.Asn1.DerSet : Asn1Set {
    public static DerSet Empty;
    public DerSet(Asn1Encodable obj);
    public DerSet(Asn1Encodable[] v);
    public DerSet(Asn1EncodableVector v);
    internal DerSet(Asn1EncodableVector v, bool needsSorting);
    private static DerSet();
    public static DerSet FromVector(Asn1EncodableVector v);
    internal static DerSet FromVector(Asn1EncodableVector v, bool needsSorting);
    internal virtual void Encode(DerOutputStream derOut);
}
public class Org.BouncyCastle.Asn1.DerSetGenerator : DerGenerator {
    private MemoryStream _bOut;
    public DerSetGenerator(Stream outStream);
    public DerSetGenerator(Stream outStream, int tagNo, bool isExplicit);
    public virtual void AddObject(Asn1Encodable obj);
    public virtual Stream GetRawOutputStream();
    public virtual void Close();
}
public class Org.BouncyCastle.Asn1.DerSetParser : object {
    private Asn1StreamParser _parser;
    internal DerSetParser(Asn1StreamParser parser);
    public sealed virtual IAsn1Convertible ReadObject();
    public sealed virtual Asn1Object ToAsn1Object();
}
public abstract class Org.BouncyCastle.Asn1.DerStringBase : Asn1Object {
    public abstract virtual string GetString();
    public virtual string ToString();
    protected virtual int Asn1GetHashCode();
}
public class Org.BouncyCastle.Asn1.DerT61String : DerStringBase {
    private string str;
    public DerT61String(Byte[] str);
    public DerT61String(string str);
    public static DerT61String GetInstance(object obj);
    public static DerT61String GetInstance(Asn1TaggedObject obj, bool isExplicit);
    public virtual string GetString();
    internal virtual void Encode(DerOutputStream derOut);
    public Byte[] GetOctets();
    protected virtual bool Asn1Equals(Asn1Object asn1Object);
}
public class Org.BouncyCastle.Asn1.DerTaggedObject : Asn1TaggedObject {
    public DerTaggedObject(int tagNo, Asn1Encodable obj);
    public DerTaggedObject(bool explicitly, int tagNo, Asn1Encodable obj);
    public DerTaggedObject(int tagNo);
    internal virtual void Encode(DerOutputStream derOut);
}
public class Org.BouncyCastle.Asn1.DerUniversalString : DerStringBase {
    private static Char[] table;
    private Byte[] str;
    public DerUniversalString(Byte[] str);
    private static DerUniversalString();
    public static DerUniversalString GetInstance(object obj);
    public static DerUniversalString GetInstance(Asn1TaggedObject obj, bool isExplicit);
    public virtual string GetString();
    public Byte[] GetOctets();
    internal virtual void Encode(DerOutputStream derOut);
    protected virtual bool Asn1Equals(Asn1Object asn1Object);
}
public class Org.BouncyCastle.Asn1.DerUnknownTag : Asn1Object {
    private bool isConstructed;
    private int tag;
    private Byte[] data;
    public bool IsConstructed { get; }
    public int Tag { get; }
    public DerUnknownTag(int tag, Byte[] data);
    public DerUnknownTag(bool isConstructed, int tag, Byte[] data);
    public bool get_IsConstructed();
    public int get_Tag();
    public Byte[] GetData();
    internal virtual void Encode(DerOutputStream derOut);
    protected virtual bool Asn1Equals(Asn1Object asn1Object);
    protected virtual int Asn1GetHashCode();
}
public class Org.BouncyCastle.Asn1.DerUtcTime : Asn1Object {
    private string time;
    public string TimeString { get; }
    [ObsoleteAttribute("Use 'AdjustedTimeString' property instead")]
public string AdjustedTime { get; }
    public string AdjustedTimeString { get; }
    public DerUtcTime(string time);
    public DerUtcTime(DateTime time);
    internal DerUtcTime(Byte[] bytes);
    public static DerUtcTime GetInstance(object obj);
    public static DerUtcTime GetInstance(Asn1TaggedObject obj, bool isExplicit);
    public DateTime ToDateTime();
    public DateTime ToAdjustedDateTime();
    private DateTime ParseDateString(string dateStr, string formatStr);
    public string get_TimeString();
    public string get_AdjustedTime();
    public string get_AdjustedTimeString();
    private Byte[] GetOctets();
    internal virtual void Encode(DerOutputStream derOut);
    protected virtual bool Asn1Equals(Asn1Object asn1Object);
    protected virtual int Asn1GetHashCode();
    public virtual string ToString();
}
public class Org.BouncyCastle.Asn1.DerUtf8String : DerStringBase {
    private string str;
    public DerUtf8String(Byte[] str);
    public DerUtf8String(string str);
    public static DerUtf8String GetInstance(object obj);
    public static DerUtf8String GetInstance(Asn1TaggedObject obj, bool isExplicit);
    public virtual string GetString();
    protected virtual bool Asn1Equals(Asn1Object asn1Object);
    internal virtual void Encode(DerOutputStream derOut);
}
public class Org.BouncyCastle.Asn1.DerVisibleString : DerStringBase {
    private string str;
    public DerVisibleString(Byte[] str);
    public DerVisibleString(string str);
    public static DerVisibleString GetInstance(object obj);
    public static DerVisibleString GetInstance(Asn1TaggedObject obj, bool explicitly);
    public virtual string GetString();
    public Byte[] GetOctets();
    internal virtual void Encode(DerOutputStream derOut);
    protected virtual bool Asn1Equals(Asn1Object asn1Object);
    protected virtual int Asn1GetHashCode();
}
public abstract class Org.BouncyCastle.Asn1.Eac.EacObjectIdentifiers : object {
    public static DerObjectIdentifier bsi_de;
    public static DerObjectIdentifier id_PK;
    public static DerObjectIdentifier id_PK_DH;
    public static DerObjectIdentifier id_PK_ECDH;
    public static DerObjectIdentifier id_CA;
    public static DerObjectIdentifier id_CA_DH;
    public static DerObjectIdentifier id_CA_DH_3DES_CBC_CBC;
    public static DerObjectIdentifier id_CA_ECDH;
    public static DerObjectIdentifier id_CA_ECDH_3DES_CBC_CBC;
    public static DerObjectIdentifier id_TA;
    public static DerObjectIdentifier id_TA_RSA;
    public static DerObjectIdentifier id_TA_RSA_v1_5_SHA_1;
    public static DerObjectIdentifier id_TA_RSA_v1_5_SHA_256;
    public static DerObjectIdentifier id_TA_RSA_PSS_SHA_1;
    public static DerObjectIdentifier id_TA_RSA_PSS_SHA_256;
    public static DerObjectIdentifier id_TA_ECDSA;
    public static DerObjectIdentifier id_TA_ECDSA_SHA_1;
    public static DerObjectIdentifier id_TA_ECDSA_SHA_224;
    public static DerObjectIdentifier id_TA_ECDSA_SHA_256;
    public static DerObjectIdentifier id_TA_ECDSA_SHA_384;
    public static DerObjectIdentifier id_TA_ECDSA_SHA_512;
    private static EacObjectIdentifiers();
}
public class Org.BouncyCastle.Asn1.Esf.CertificateValues : Asn1Encodable {
    private Asn1Sequence certificates;
    private CertificateValues(Asn1Sequence seq);
    public CertificateValues(X509CertificateStructure[] certificates);
    public CertificateValues(IEnumerable certificates);
    public static CertificateValues GetInstance(object obj);
    public X509CertificateStructure[] GetCertificates();
    public virtual Asn1Object ToAsn1Object();
}
public abstract class Org.BouncyCastle.Asn1.Esf.CommitmentTypeIdentifier : object {
    public static DerObjectIdentifier ProofOfOrigin;
    public static DerObjectIdentifier ProofOfReceipt;
    public static DerObjectIdentifier ProofOfDelivery;
    public static DerObjectIdentifier ProofOfSender;
    public static DerObjectIdentifier ProofOfApproval;
    public static DerObjectIdentifier ProofOfCreation;
    private static CommitmentTypeIdentifier();
}
public class Org.BouncyCastle.Asn1.Esf.CommitmentTypeIndication : Asn1Encodable {
    private DerObjectIdentifier commitmentTypeId;
    private Asn1Sequence commitmentTypeQualifier;
    public DerObjectIdentifier CommitmentTypeID { get; }
    public Asn1Sequence CommitmentTypeQualifier { get; }
    public CommitmentTypeIndication(Asn1Sequence seq);
    public CommitmentTypeIndication(DerObjectIdentifier commitmentTypeId);
    public CommitmentTypeIndication(DerObjectIdentifier commitmentTypeId, Asn1Sequence commitmentTypeQualifier);
    public static CommitmentTypeIndication GetInstance(object obj);
    public DerObjectIdentifier get_CommitmentTypeID();
    public Asn1Sequence get_CommitmentTypeQualifier();
    public virtual Asn1Object ToAsn1Object();
}
public class Org.BouncyCastle.Asn1.Esf.CommitmentTypeQualifier : Asn1Encodable {
    private DerObjectIdentifier commitmentTypeIdentifier;
    private Asn1Object qualifier;
    public DerObjectIdentifier CommitmentTypeIdentifier { get; }
    public Asn1Object Qualifier { get; }
    public CommitmentTypeQualifier(DerObjectIdentifier commitmentTypeIdentifier);
    public CommitmentTypeQualifier(DerObjectIdentifier commitmentTypeIdentifier, Asn1Encodable qualifier);
    public CommitmentTypeQualifier(Asn1Sequence seq);
    public static CommitmentTypeQualifier GetInstance(object obj);
    public DerObjectIdentifier get_CommitmentTypeIdentifier();
    public Asn1Object get_Qualifier();
    public virtual Asn1Object ToAsn1Object();
}
public class Org.BouncyCastle.Asn1.Esf.CompleteCertificateRefs : Asn1Encodable {
    private Asn1Sequence otherCertIDs;
    private CompleteCertificateRefs(Asn1Sequence seq);
    public CompleteCertificateRefs(OtherCertID[] otherCertIDs);
    public CompleteCertificateRefs(IEnumerable otherCertIDs);
    public static CompleteCertificateRefs GetInstance(object obj);
    public OtherCertID[] GetOtherCertIDs();
    public virtual Asn1Object ToAsn1Object();
}
public class Org.BouncyCastle.Asn1.Esf.CompleteRevocationRefs : Asn1Encodable {
    private Asn1Sequence crlOcspRefs;
    private CompleteRevocationRefs(Asn1Sequence seq);
    public CompleteRevocationRefs(CrlOcspRef[] crlOcspRefs);
    public CompleteRevocationRefs(IEnumerable crlOcspRefs);
    public static CompleteRevocationRefs GetInstance(object obj);
    public CrlOcspRef[] GetCrlOcspRefs();
    public virtual Asn1Object ToAsn1Object();
}
public class Org.BouncyCastle.Asn1.Esf.CrlIdentifier : Asn1Encodable {
    private X509Name crlIssuer;
    private DerUtcTime crlIssuedTime;
    private DerInteger crlNumber;
    public X509Name CrlIssuer { get; }
    public DateTime CrlIssuedTime { get; }
    public BigInteger CrlNumber { get; }
    private CrlIdentifier(Asn1Sequence seq);
    public CrlIdentifier(X509Name crlIssuer, DateTime crlIssuedTime);
    public CrlIdentifier(X509Name crlIssuer, DateTime crlIssuedTime, BigInteger crlNumber);
    public static CrlIdentifier GetInstance(object obj);
    public X509Name get_CrlIssuer();
    public DateTime get_CrlIssuedTime();
    public BigInteger get_CrlNumber();
    public virtual Asn1Object ToAsn1Object();
}
public class Org.BouncyCastle.Asn1.Esf.CrlListID : Asn1Encodable {
    private Asn1Sequence crls;
    private CrlListID(Asn1Sequence seq);
    public CrlListID(CrlValidatedID[] crls);
    public CrlListID(IEnumerable crls);
    public static CrlListID GetInstance(object obj);
    public CrlValidatedID[] GetCrls();
    public virtual Asn1Object ToAsn1Object();
}
public class Org.BouncyCastle.Asn1.Esf.CrlOcspRef : Asn1Encodable {
    private CrlListID crlids;
    private OcspListID ocspids;
    private OtherRevRefs otherRev;
    public CrlListID CrlIDs { get; }
    public OcspListID OcspIDs { get; }
    public OtherRevRefs OtherRev { get; }
    private CrlOcspRef(Asn1Sequence seq);
    public CrlOcspRef(CrlListID crlids, OcspListID ocspids, OtherRevRefs otherRev);
    public static CrlOcspRef GetInstance(object obj);
    public CrlListID get_CrlIDs();
    public OcspListID get_OcspIDs();
    public OtherRevRefs get_OtherRev();
    public virtual Asn1Object ToAsn1Object();
}
public class Org.BouncyCastle.Asn1.Esf.CrlValidatedID : Asn1Encodable {
    private OtherHash crlHash;
    private CrlIdentifier crlIdentifier;
    public OtherHash CrlHash { get; }
    public CrlIdentifier CrlIdentifier { get; }
    private CrlValidatedID(Asn1Sequence seq);
    public CrlValidatedID(OtherHash crlHash);
    public CrlValidatedID(OtherHash crlHash, CrlIdentifier crlIdentifier);
    public static CrlValidatedID GetInstance(object obj);
    public OtherHash get_CrlHash();
    public CrlIdentifier get_CrlIdentifier();
    public virtual Asn1Object ToAsn1Object();
}
public abstract class Org.BouncyCastle.Asn1.Esf.EsfAttributes : object {
    public static DerObjectIdentifier SigPolicyId;
    public static DerObjectIdentifier CommitmentType;
    public static DerObjectIdentifier SignerLocation;
    public static DerObjectIdentifier SignerAttr;
    public static DerObjectIdentifier OtherSigCert;
    public static DerObjectIdentifier ContentTimestamp;
    public static DerObjectIdentifier CertificateRefs;
    public static DerObjectIdentifier RevocationRefs;
    public static DerObjectIdentifier CertValues;
    public static DerObjectIdentifier RevocationValues;
    public static DerObjectIdentifier EscTimeStamp;
    public static DerObjectIdentifier CertCrlTimestamp;
    public static DerObjectIdentifier ArchiveTimestamp;
    public static DerObjectIdentifier ArchiveTimestampV2;
    private static EsfAttributes();
}
public class Org.BouncyCastle.Asn1.Esf.OcspIdentifier : Asn1Encodable {
    private ResponderID ocspResponderID;
    private DerGeneralizedTime producedAt;
    public ResponderID OcspResponderID { get; }
    public DateTime ProducedAt { get; }
    private OcspIdentifier(Asn1Sequence seq);
    public OcspIdentifier(ResponderID ocspResponderID, DateTime producedAt);
    public static OcspIdentifier GetInstance(object obj);
    public ResponderID get_OcspResponderID();
    public DateTime get_ProducedAt();
    public virtual Asn1Object ToAsn1Object();
}
public class Org.BouncyCastle.Asn1.Esf.OcspListID : Asn1Encodable {
    private Asn1Sequence ocspResponses;
    private OcspListID(Asn1Sequence seq);
    public OcspListID(OcspResponsesID[] ocspResponses);
    public OcspListID(IEnumerable ocspResponses);
    public static OcspListID GetInstance(object obj);
    public OcspResponsesID[] GetOcspResponses();
    public virtual Asn1Object ToAsn1Object();
}
public class Org.BouncyCastle.Asn1.Esf.OcspResponsesID : Asn1Encodable {
    private OcspIdentifier ocspIdentifier;
    private OtherHash ocspRepHash;
    public OcspIdentifier OcspIdentifier { get; }
    public OtherHash OcspRepHash { get; }
    private OcspResponsesID(Asn1Sequence seq);
    public OcspResponsesID(OcspIdentifier ocspIdentifier);
    public OcspResponsesID(OcspIdentifier ocspIdentifier, OtherHash ocspRepHash);
    public static OcspResponsesID GetInstance(object obj);
    public OcspIdentifier get_OcspIdentifier();
    public OtherHash get_OcspRepHash();
    public virtual Asn1Object ToAsn1Object();
}
public class Org.BouncyCastle.Asn1.Esf.OtherCertID : Asn1Encodable {
    private OtherHash otherCertHash;
    private IssuerSerial issuerSerial;
    public OtherHash OtherCertHash { get; }
    public IssuerSerial IssuerSerial { get; }
    private OtherCertID(Asn1Sequence seq);
    public OtherCertID(OtherHash otherCertHash);
    public OtherCertID(OtherHash otherCertHash, IssuerSerial issuerSerial);
    public static OtherCertID GetInstance(object obj);
    public OtherHash get_OtherCertHash();
    public IssuerSerial get_IssuerSerial();
    public virtual Asn1Object ToAsn1Object();
}
public class Org.BouncyCastle.Asn1.Esf.OtherHash : Asn1Encodable {
    private Asn1OctetString sha1Hash;
    private OtherHashAlgAndValue otherHash;
    public AlgorithmIdentifier HashAlgorithm { get; }
    public OtherHash(Byte[] sha1Hash);
    public OtherHash(Asn1OctetString sha1Hash);
    public OtherHash(OtherHashAlgAndValue otherHash);
    public static OtherHash GetInstance(object obj);
    public AlgorithmIdentifier get_HashAlgorithm();
    public Byte[] GetHashValue();
    public virtual Asn1Object ToAsn1Object();
}
public class Org.BouncyCastle.Asn1.Esf.OtherHashAlgAndValue : Asn1Encodable {
    private AlgorithmIdentifier hashAlgorithm;
    private Asn1OctetString hashValue;
    public AlgorithmIdentifier HashAlgorithm { get; }
    private OtherHashAlgAndValue(Asn1Sequence seq);
    public OtherHashAlgAndValue(AlgorithmIdentifier hashAlgorithm, Byte[] hashValue);
    public OtherHashAlgAndValue(AlgorithmIdentifier hashAlgorithm, Asn1OctetString hashValue);
    public static OtherHashAlgAndValue GetInstance(object obj);
    public AlgorithmIdentifier get_HashAlgorithm();
    public Byte[] GetHashValue();
    public virtual Asn1Object ToAsn1Object();
}
public class Org.BouncyCastle.Asn1.Esf.OtherRevRefs : Asn1Encodable {
    private DerObjectIdentifier otherRevRefType;
    private Asn1Object otherRevRefs;
    public DerObjectIdentifier OtherRevRefType { get; }
    public Asn1Object OtherRevRefsObject { get; }
    private OtherRevRefs(Asn1Sequence seq);
    public OtherRevRefs(DerObjectIdentifier otherRevRefType, Asn1Encodable otherRevRefs);
    public static OtherRevRefs GetInstance(object obj);
    public DerObjectIdentifier get_OtherRevRefType();
    public Asn1Object get_OtherRevRefsObject();
    public virtual Asn1Object ToAsn1Object();
}
public class Org.BouncyCastle.Asn1.Esf.OtherRevVals : Asn1Encodable {
    private DerObjectIdentifier otherRevValType;
    private Asn1Object otherRevVals;
    public DerObjectIdentifier OtherRevValType { get; }
    public Asn1Object OtherRevValsObject { get; }
    private OtherRevVals(Asn1Sequence seq);
    public OtherRevVals(DerObjectIdentifier otherRevValType, Asn1Encodable otherRevVals);
    public static OtherRevVals GetInstance(object obj);
    public DerObjectIdentifier get_OtherRevValType();
    public Asn1Object get_OtherRevValsObject();
    public virtual Asn1Object ToAsn1Object();
}
public class Org.BouncyCastle.Asn1.Esf.OtherSigningCertificate : Asn1Encodable {
    private Asn1Sequence certs;
    private Asn1Sequence policies;
    private OtherSigningCertificate(Asn1Sequence seq);
    public OtherSigningCertificate(OtherCertID[] certs);
    public OtherSigningCertificate(OtherCertID[] certs, PolicyInformation[] policies);
    public OtherSigningCertificate(IEnumerable certs);
    public OtherSigningCertificate(IEnumerable certs, IEnumerable policies);
    public static OtherSigningCertificate GetInstance(object obj);
    public OtherCertID[] GetCerts();
    public PolicyInformation[] GetPolicies();
    public virtual Asn1Object ToAsn1Object();
}
public class Org.BouncyCastle.Asn1.Esf.RevocationValues : Asn1Encodable {
    private Asn1Sequence crlVals;
    private Asn1Sequence ocspVals;
    private OtherRevVals otherRevVals;
    public OtherRevVals OtherRevVals { get; }
    private RevocationValues(Asn1Sequence seq);
    public RevocationValues(CertificateList[] crlVals, BasicOcspResponse[] ocspVals, OtherRevVals otherRevVals);
    public RevocationValues(IEnumerable crlVals, IEnumerable ocspVals, OtherRevVals otherRevVals);
    public static RevocationValues GetInstance(object obj);
    public CertificateList[] GetCrlVals();
    public BasicOcspResponse[] GetOcspVals();
    public OtherRevVals get_OtherRevVals();
    public virtual Asn1Object ToAsn1Object();
}
public class Org.BouncyCastle.Asn1.Esf.SignaturePolicyId : Asn1Encodable {
    private DerObjectIdentifier sigPolicyIdentifier;
    private OtherHashAlgAndValue sigPolicyHash;
    private Asn1Sequence sigPolicyQualifiers;
    public DerObjectIdentifier SigPolicyIdentifier { get; }
    public OtherHashAlgAndValue SigPolicyHash { get; }
    private SignaturePolicyId(Asn1Sequence seq);
    public SignaturePolicyId(DerObjectIdentifier sigPolicyIdentifier, OtherHashAlgAndValue sigPolicyHash);
    public SignaturePolicyId(DerObjectIdentifier sigPolicyIdentifier, OtherHashAlgAndValue sigPolicyHash, SigPolicyQualifierInfo[] sigPolicyQualifiers);
    public SignaturePolicyId(DerObjectIdentifier sigPolicyIdentifier, OtherHashAlgAndValue sigPolicyHash, IEnumerable sigPolicyQualifiers);
    public static SignaturePolicyId GetInstance(object obj);
    public DerObjectIdentifier get_SigPolicyIdentifier();
    public OtherHashAlgAndValue get_SigPolicyHash();
    public SigPolicyQualifierInfo[] GetSigPolicyQualifiers();
    public virtual Asn1Object ToAsn1Object();
}
public class Org.BouncyCastle.Asn1.Esf.SignaturePolicyIdentifier : Asn1Encodable {
    private SignaturePolicyId sigPolicy;
    public SignaturePolicyId SignaturePolicyId { get; }
    public SignaturePolicyIdentifier(SignaturePolicyId signaturePolicyId);
    public static SignaturePolicyIdentifier GetInstance(object obj);
    public SignaturePolicyId get_SignaturePolicyId();
    public virtual Asn1Object ToAsn1Object();
}
public class Org.BouncyCastle.Asn1.Esf.SignerAttribute : Asn1Encodable {
    private Asn1Sequence claimedAttributes;
    private AttributeCertificate certifiedAttributes;
    public Asn1Sequence ClaimedAttributes { get; }
    public AttributeCertificate CertifiedAttributes { get; }
    private SignerAttribute(object obj);
    public SignerAttribute(Asn1Sequence claimedAttributes);
    public SignerAttribute(AttributeCertificate certifiedAttributes);
    public static SignerAttribute GetInstance(object obj);
    public virtual Asn1Sequence get_ClaimedAttributes();
    public virtual AttributeCertificate get_CertifiedAttributes();
    public virtual Asn1Object ToAsn1Object();
}
public class Org.BouncyCastle.Asn1.Esf.SignerLocation : Asn1Encodable {
    private DerUtf8String countryName;
    private DerUtf8String localityName;
    private Asn1Sequence postalAddress;
    public DerUtf8String CountryName { get; }
    public DerUtf8String LocalityName { get; }
    public Asn1Sequence PostalAddress { get; }
    public SignerLocation(Asn1Sequence seq);
    public SignerLocation(DerUtf8String countryName, DerUtf8String localityName, Asn1Sequence postalAddress);
    public static SignerLocation GetInstance(object obj);
    public DerUtf8String get_CountryName();
    public DerUtf8String get_LocalityName();
    public Asn1Sequence get_PostalAddress();
    public virtual Asn1Object ToAsn1Object();
}
public class Org.BouncyCastle.Asn1.Esf.SigPolicyQualifierInfo : Asn1Encodable {
    private DerObjectIdentifier sigPolicyQualifierId;
    private Asn1Object sigQualifier;
    public DerObjectIdentifier SigPolicyQualifierId { get; }
    public Asn1Object SigQualifier { get; }
    private SigPolicyQualifierInfo(Asn1Sequence seq);
    public SigPolicyQualifierInfo(DerObjectIdentifier sigPolicyQualifierId, Asn1Encodable sigQualifier);
    public static SigPolicyQualifierInfo GetInstance(object obj);
    public DerObjectIdentifier get_SigPolicyQualifierId();
    public Asn1Object get_SigQualifier();
    public virtual Asn1Object ToAsn1Object();
}
public class Org.BouncyCastle.Asn1.Ess.ContentHints : Asn1Encodable {
    private DerUtf8String contentDescription;
    private DerObjectIdentifier contentType;
    public DerObjectIdentifier ContentType { get; }
    public DerUtf8String ContentDescription { get; }
    private ContentHints(Asn1Sequence seq);
    public ContentHints(DerObjectIdentifier contentType);
    public ContentHints(DerObjectIdentifier contentType, DerUtf8String contentDescription);
    public static ContentHints GetInstance(object o);
    public DerObjectIdentifier get_ContentType();
    public DerUtf8String get_ContentDescription();
    public virtual Asn1Object ToAsn1Object();
}
public class Org.BouncyCastle.Asn1.Ess.ContentIdentifier : Asn1Encodable {
    private Asn1OctetString value;
    public Asn1OctetString Value { get; }
    public ContentIdentifier(Asn1OctetString value);
    public ContentIdentifier(Byte[] value);
    public static ContentIdentifier GetInstance(object o);
    public Asn1OctetString get_Value();
    public virtual Asn1Object ToAsn1Object();
}
public class Org.BouncyCastle.Asn1.Ess.EssCertID : Asn1Encodable {
    private Asn1OctetString certHash;
    private IssuerSerial issuerSerial;
    public IssuerSerial IssuerSerial { get; }
    public EssCertID(Asn1Sequence seq);
    public EssCertID(Byte[] hash);
    public EssCertID(Byte[] hash, IssuerSerial issuerSerial);
    public static EssCertID GetInstance(object o);
    public Byte[] GetCertHash();
    public IssuerSerial get_IssuerSerial();
    public virtual Asn1Object ToAsn1Object();
}
public class Org.BouncyCastle.Asn1.Ess.EssCertIDv2 : Asn1Encodable {
    private AlgorithmIdentifier hashAlgorithm;
    private Byte[] certHash;
    private IssuerSerial issuerSerial;
    private static AlgorithmIdentifier DefaultAlgID;
    public AlgorithmIdentifier HashAlgorithm { get; }
    public IssuerSerial IssuerSerial { get; }
    private EssCertIDv2(Asn1Sequence seq);
    public EssCertIDv2(Byte[] certHash);
    public EssCertIDv2(AlgorithmIdentifier algId, Byte[] certHash);
    public EssCertIDv2(Byte[] certHash, IssuerSerial issuerSerial);
    public EssCertIDv2(AlgorithmIdentifier algId, Byte[] certHash, IssuerSerial issuerSerial);
    private static EssCertIDv2();
    public static EssCertIDv2 GetInstance(object obj);
    public AlgorithmIdentifier get_HashAlgorithm();
    public Byte[] GetCertHash();
    public IssuerSerial get_IssuerSerial();
    public virtual Asn1Object ToAsn1Object();
}
[ObsoleteAttribute("Use version in Asn1.Esf instead")]
public class Org.BouncyCastle.Asn1.Ess.OtherCertID : Asn1Encodable {
    private Asn1Encodable otherCertHash;
    private IssuerSerial issuerSerial;
    public AlgorithmIdentifier AlgorithmHash { get; }
    public IssuerSerial IssuerSerial { get; }
    public OtherCertID(Asn1Sequence seq);
    public OtherCertID(AlgorithmIdentifier algId, Byte[] digest);
    public OtherCertID(AlgorithmIdentifier algId, Byte[] digest, IssuerSerial issuerSerial);
    public static OtherCertID GetInstance(object o);
    public AlgorithmIdentifier get_AlgorithmHash();
    public Byte[] GetCertHash();
    public IssuerSerial get_IssuerSerial();
    public virtual Asn1Object ToAsn1Object();
}
[ObsoleteAttribute("Use version in Asn1.Esf instead")]
public class Org.BouncyCastle.Asn1.Ess.OtherSigningCertificate : Asn1Encodable {
    private Asn1Sequence certs;
    private Asn1Sequence policies;
    public OtherSigningCertificate(Asn1Sequence seq);
    public OtherSigningCertificate(OtherCertID otherCertID);
    public static OtherSigningCertificate GetInstance(object o);
    public OtherCertID[] GetCerts();
    public PolicyInformation[] GetPolicies();
    public virtual Asn1Object ToAsn1Object();
}
public class Org.BouncyCastle.Asn1.Ess.SigningCertificate : Asn1Encodable {
    private Asn1Sequence certs;
    private Asn1Sequence policies;
    public SigningCertificate(Asn1Sequence seq);
    public SigningCertificate(EssCertID essCertID);
    public static SigningCertificate GetInstance(object o);
    public EssCertID[] GetCerts();
    public PolicyInformation[] GetPolicies();
    public virtual Asn1Object ToAsn1Object();
}
public class Org.BouncyCastle.Asn1.Ess.SigningCertificateV2 : Asn1Encodable {
    private Asn1Sequence certs;
    private Asn1Sequence policies;
    private SigningCertificateV2(Asn1Sequence seq);
    public SigningCertificateV2(EssCertIDv2 cert);
    public SigningCertificateV2(EssCertIDv2[] certs);
    public SigningCertificateV2(EssCertIDv2[] certs, PolicyInformation[] policies);
    public static SigningCertificateV2 GetInstance(object o);
    public EssCertIDv2[] GetCerts();
    public PolicyInformation[] GetPolicies();
    public virtual Asn1Object ToAsn1Object();
}
public abstract class Org.BouncyCastle.Asn1.Gnu.GnuObjectIdentifiers : object {
    public static DerObjectIdentifier Gnu;
    public static DerObjectIdentifier GnuPG;
    public static DerObjectIdentifier Notation;
    public static DerObjectIdentifier PkaAddress;
    public static DerObjectIdentifier GnuRadar;
    public static DerObjectIdentifier DigestAlgorithm;
    public static DerObjectIdentifier Tiger192;
    public static DerObjectIdentifier EncryptionAlgorithm;
    public static DerObjectIdentifier Serpent;
    public static DerObjectIdentifier Serpent128Ecb;
    public static DerObjectIdentifier Serpent128Cbc;
    public static DerObjectIdentifier Serpent128Ofb;
    public static DerObjectIdentifier Serpent128Cfb;
    public static DerObjectIdentifier Serpent192Ecb;
    public static DerObjectIdentifier Serpent192Cbc;
    public static DerObjectIdentifier Serpent192Ofb;
    public static DerObjectIdentifier Serpent192Cfb;
    public static DerObjectIdentifier Serpent256Ecb;
    public static DerObjectIdentifier Serpent256Cbc;
    public static DerObjectIdentifier Serpent256Ofb;
    public static DerObjectIdentifier Serpent256Cfb;
    public static DerObjectIdentifier Crc;
    public static DerObjectIdentifier Crc32;
    private static GnuObjectIdentifiers();
}
public abstract class Org.BouncyCastle.Asn1.Iana.IanaObjectIdentifiers : object {
    public static DerObjectIdentifier IsakmpOakley;
    public static DerObjectIdentifier HmacMD5;
    public static DerObjectIdentifier HmacSha1;
    public static DerObjectIdentifier HmacTiger;
    public static DerObjectIdentifier HmacRipeMD160;
    private static IanaObjectIdentifiers();
}
public interface Org.BouncyCastle.Asn1.IAsn1ApplicationSpecificParser {
    public abstract virtual IAsn1Convertible ReadObject();
}
public interface Org.BouncyCastle.Asn1.IAsn1Choice {
}
public interface Org.BouncyCastle.Asn1.IAsn1Convertible {
    public abstract virtual Asn1Object ToAsn1Object();
}
public interface Org.BouncyCastle.Asn1.IAsn1String {
    public abstract virtual string GetString();
}
public class Org.BouncyCastle.Asn1.Icao.CscaMasterList : Asn1Encodable {
    private DerInteger version;
    private X509CertificateStructure[] certList;
    public int Version { get; }
    private CscaMasterList(Asn1Sequence seq);
    public CscaMasterList(X509CertificateStructure[] certStructs);
    public static CscaMasterList GetInstance(object obj);
    public virtual int get_Version();
    public X509CertificateStructure[] GetCertStructs();
    private static X509CertificateStructure[] CopyCertList(X509CertificateStructure[] orig);
    public virtual Asn1Object ToAsn1Object();
}
public class Org.BouncyCastle.Asn1.Icao.DataGroupHash : Asn1Encodable {
    private DerInteger dataGroupNumber;
    private Asn1OctetString dataGroupHashValue;
    public int DataGroupNumber { get; }
    public Asn1OctetString DataGroupHashValue { get; }
    private DataGroupHash(Asn1Sequence seq);
    public DataGroupHash(int dataGroupNumber, Asn1OctetString dataGroupHashValue);
    public static DataGroupHash GetInstance(object obj);
    public int get_DataGroupNumber();
    public Asn1OctetString get_DataGroupHashValue();
    public virtual Asn1Object ToAsn1Object();
}
public abstract class Org.BouncyCastle.Asn1.Icao.IcaoObjectIdentifiers : object {
    public static DerObjectIdentifier IdIcao;
    public static DerObjectIdentifier IdIcaoMrtd;
    public static DerObjectIdentifier IdIcaoMrtdSecurity;
    public static DerObjectIdentifier IdIcaoLdsSecurityObject;
    public static DerObjectIdentifier IdIcaoCscaMasterList;
    public static DerObjectIdentifier IdIcaoCscaMasterListSigningKey;
    public static DerObjectIdentifier IdIcaoDocumentTypeList;
    public static DerObjectIdentifier IdIcaoAAProtocolObject;
    public static DerObjectIdentifier IdIcaoExtensions;
    public static DerObjectIdentifier IdIcaoExtensionsNamechangekeyrollover;
    private static IcaoObjectIdentifiers();
}
public class Org.BouncyCastle.Asn1.Icao.LdsSecurityObject : Asn1Encodable {
    public static int UBDataGroups;
    private DerInteger version;
    private AlgorithmIdentifier digestAlgorithmIdentifier;
    private DataGroupHash[] datagroupHash;
    private LdsVersionInfo versionInfo;
    public BigInteger Version { get; }
    public AlgorithmIdentifier DigestAlgorithmIdentifier { get; }
    public LdsVersionInfo VersionInfo { get; }
    private LdsSecurityObject(Asn1Sequence seq);
    public LdsSecurityObject(AlgorithmIdentifier digestAlgorithmIdentifier, DataGroupHash[] datagroupHash);
    public LdsSecurityObject(AlgorithmIdentifier digestAlgorithmIdentifier, DataGroupHash[] datagroupHash, LdsVersionInfo versionInfo);
    public static LdsSecurityObject GetInstance(object obj);
    private void CheckDatagroupHashSeqSize(int size);
    public BigInteger get_Version();
    public AlgorithmIdentifier get_DigestAlgorithmIdentifier();
    public DataGroupHash[] GetDatagroupHash();
    public LdsVersionInfo get_VersionInfo();
    public virtual Asn1Object ToAsn1Object();
}
public class Org.BouncyCastle.Asn1.Icao.LdsVersionInfo : Asn1Encodable {
    private DerPrintableString ldsVersion;
    private DerPrintableString unicodeVersion;
    public LdsVersionInfo(string ldsVersion, string unicodeVersion);
    private LdsVersionInfo(Asn1Sequence seq);
    public static LdsVersionInfo GetInstance(object obj);
    public virtual string GetLdsVersion();
    public virtual string GetUnicodeVersion();
    public virtual Asn1Object ToAsn1Object();
}
internal class Org.BouncyCastle.Asn1.IndefiniteLengthInputStream : LimitedInputStream {
    private int _lookAhead;
    private bool _eofOn00;
    internal IndefiniteLengthInputStream(Stream inStream, int limit);
    internal void SetEofOn00(bool eofOn00);
    private bool CheckForEof();
    public virtual int Read(Byte[] buffer, int offset, int count);
    public virtual int ReadByte();
    private int RequireByte();
}
public abstract class Org.BouncyCastle.Asn1.IsisMtt.IsisMttObjectIdentifiers : object {
    public static DerObjectIdentifier IdIsisMtt;
    public static DerObjectIdentifier IdIsisMttCP;
    public static DerObjectIdentifier IdIsisMttCPAccredited;
    public static DerObjectIdentifier IdIsisMttAT;
    public static DerObjectIdentifier IdIsisMttATDateOfCertGen;
    public static DerObjectIdentifier IdIsisMttATProcuration;
    public static DerObjectIdentifier IdIsisMttATAdmission;
    public static DerObjectIdentifier IdIsisMttATMonetaryLimit;
    public static DerObjectIdentifier IdIsisMttATDeclarationOfMajority;
    public static DerObjectIdentifier IdIsisMttATIccsn;
    public static DerObjectIdentifier IdIsisMttATPKReference;
    public static DerObjectIdentifier IdIsisMttATRestriction;
    public static DerObjectIdentifier IdIsisMttATRetrieveIfAllowed;
    public static DerObjectIdentifier IdIsisMttATRequestedCertificate;
    public static DerObjectIdentifier IdIsisMttATNamingAuthorities;
    public static DerObjectIdentifier IdIsisMttATCertInDirSince;
    public static DerObjectIdentifier IdIsisMttATCertHash;
    public static DerObjectIdentifier IdIsisMttATNameAtBirth;
    public static DerObjectIdentifier IdIsisMttATAdditionalInformation;
    public static DerObjectIdentifier IdIsisMttATLiabilityLimitationFlag;
    private static IsisMttObjectIdentifiers();
}
public class Org.BouncyCastle.Asn1.IsisMtt.Ocsp.CertHash : Asn1Encodable {
    private AlgorithmIdentifier hashAlgorithm;
    private Byte[] certificateHash;
    public AlgorithmIdentifier HashAlgorithm { get; }
    public Byte[] CertificateHash { get; }
    private CertHash(Asn1Sequence seq);
    public CertHash(AlgorithmIdentifier hashAlgorithm, Byte[] certificateHash);
    public static CertHash GetInstance(object obj);
    public AlgorithmIdentifier get_HashAlgorithm();
    public Byte[] get_CertificateHash();
    public virtual Asn1Object ToAsn1Object();
}
public class Org.BouncyCastle.Asn1.IsisMtt.Ocsp.RequestedCertificate : Asn1Encodable {
    private X509CertificateStructure cert;
    private Byte[] publicKeyCert;
    private Byte[] attributeCert;
    public Choice Type { get; }
    private RequestedCertificate(Asn1TaggedObject tagged);
    public RequestedCertificate(X509CertificateStructure certificate);
    public RequestedCertificate(Choice type, Byte[] certificateOctets);
    public static RequestedCertificate GetInstance(object obj);
    public static RequestedCertificate GetInstance(Asn1TaggedObject obj, bool isExplicit);
    public Choice get_Type();
    public Byte[] GetCertificateBytes();
    public virtual Asn1Object ToAsn1Object();
}
public class Org.BouncyCastle.Asn1.IsisMtt.X509.AdditionalInformationSyntax : Asn1Encodable {
    private DirectoryString information;
    public DirectoryString Information { get; }
    private AdditionalInformationSyntax(DirectoryString information);
    public AdditionalInformationSyntax(string information);
    public static AdditionalInformationSyntax GetInstance(object obj);
    public virtual DirectoryString get_Information();
    public virtual Asn1Object ToAsn1Object();
}
public class Org.BouncyCastle.Asn1.IsisMtt.X509.Admissions : Asn1Encodable {
    private GeneralName admissionAuthority;
    private NamingAuthority namingAuthority;
    private Asn1Sequence professionInfos;
    public GeneralName AdmissionAuthority { get; }
    public NamingAuthority NamingAuthority { get; }
    private Admissions(Asn1Sequence seq);
    public Admissions(GeneralName admissionAuthority, NamingAuthority namingAuthority, ProfessionInfo[] professionInfos);
    public static Admissions GetInstance(object obj);
    public virtual GeneralName get_AdmissionAuthority();
    public virtual NamingAuthority get_NamingAuthority();
    public ProfessionInfo[] GetProfessionInfos();
    public virtual Asn1Object ToAsn1Object();
}
public class Org.BouncyCastle.Asn1.IsisMtt.X509.AdmissionSyntax : Asn1Encodable {
    private GeneralName admissionAuthority;
    private Asn1Sequence contentsOfAdmissions;
    public GeneralName AdmissionAuthority { get; }
    private AdmissionSyntax(Asn1Sequence seq);
    public AdmissionSyntax(GeneralName admissionAuthority, Asn1Sequence contentsOfAdmissions);
    public static AdmissionSyntax GetInstance(object obj);
    public virtual Asn1Object ToAsn1Object();
    public virtual GeneralName get_AdmissionAuthority();
    public virtual Admissions[] GetContentsOfAdmissions();
}
public class Org.BouncyCastle.Asn1.IsisMtt.X509.DeclarationOfMajority : Asn1Encodable {
    private Asn1TaggedObject declaration;
    public Choice Type { get; }
    public int NotYoungerThan { get; }
    public Asn1Sequence FullAgeAtCountry { get; }
    public DerGeneralizedTime DateOfBirth { get; }
    public DeclarationOfMajority(int notYoungerThan);
    public DeclarationOfMajority(bool fullAge, string country);
    public DeclarationOfMajority(DerGeneralizedTime dateOfBirth);
    private DeclarationOfMajority(Asn1TaggedObject o);
    public static DeclarationOfMajority GetInstance(object obj);
    public virtual Asn1Object ToAsn1Object();
    public Choice get_Type();
    public virtual int get_NotYoungerThan();
    public virtual Asn1Sequence get_FullAgeAtCountry();
    public virtual DerGeneralizedTime get_DateOfBirth();
}
public class Org.BouncyCastle.Asn1.IsisMtt.X509.MonetaryLimit : Asn1Encodable {
    private DerPrintableString currency;
    private DerInteger amount;
    private DerInteger exponent;
    public string Currency { get; }
    public BigInteger Amount { get; }
    public BigInteger Exponent { get; }
    private MonetaryLimit(Asn1Sequence seq);
    public MonetaryLimit(string currency, int amount, int exponent);
    public static MonetaryLimit GetInstance(object obj);
    public virtual string get_Currency();
    public virtual BigInteger get_Amount();
    public virtual BigInteger get_Exponent();
    public virtual Asn1Object ToAsn1Object();
}
public class Org.BouncyCastle.Asn1.IsisMtt.X509.NamingAuthority : Asn1Encodable {
    public static DerObjectIdentifier IdIsisMttATNamingAuthoritiesRechtWirtschaftSteuern;
    private DerObjectIdentifier namingAuthorityID;
    private string namingAuthorityUrl;
    private DirectoryString namingAuthorityText;
    public DerObjectIdentifier NamingAuthorityID { get; }
    public DirectoryString NamingAuthorityText { get; }
    public string NamingAuthorityUrl { get; }
    private NamingAuthority(Asn1Sequence seq);
    public NamingAuthority(DerObjectIdentifier namingAuthorityID, string namingAuthorityUrl, DirectoryString namingAuthorityText);
    private static NamingAuthority();
    public static NamingAuthority GetInstance(object obj);
    public static NamingAuthority GetInstance(Asn1TaggedObject obj, bool isExplicit);
    public virtual DerObjectIdentifier get_NamingAuthorityID();
    public virtual DirectoryString get_NamingAuthorityText();
    public virtual string get_NamingAuthorityUrl();
    public virtual Asn1Object ToAsn1Object();
}
public class Org.BouncyCastle.Asn1.IsisMtt.X509.ProcurationSyntax : Asn1Encodable {
    private string country;
    private DirectoryString typeOfSubstitution;
    private GeneralName thirdPerson;
    private IssuerSerial certRef;
    public string Country { get; }
    public DirectoryString TypeOfSubstitution { get; }
    public GeneralName ThirdPerson { get; }
    public IssuerSerial CertRef { get; }
    private ProcurationSyntax(Asn1Sequence seq);
    public ProcurationSyntax(string country, DirectoryString typeOfSubstitution, IssuerSerial certRef);
    public ProcurationSyntax(string country, DirectoryString typeOfSubstitution, GeneralName thirdPerson);
    public static ProcurationSyntax GetInstance(object obj);
    public virtual string get_Country();
    public virtual DirectoryString get_TypeOfSubstitution();
    public virtual GeneralName get_ThirdPerson();
    public virtual IssuerSerial get_CertRef();
    public virtual Asn1Object ToAsn1Object();
}
public class Org.BouncyCastle.Asn1.IsisMtt.X509.ProfessionInfo : Asn1Encodable {
    public static DerObjectIdentifier Rechtsanwltin;
    public static DerObjectIdentifier Rechtsanwalt;
    public static DerObjectIdentifier Rechtsbeistand;
    public static DerObjectIdentifier Steuerberaterin;
    public static DerObjectIdentifier Steuerberater;
    public static DerObjectIdentifier Steuerbevollmchtigte;
    public static DerObjectIdentifier Steuerbevollmchtigter;
    public static DerObjectIdentifier Notarin;
    public static DerObjectIdentifier Notar;
    public static DerObjectIdentifier Notarvertreterin;
    public static DerObjectIdentifier Notarvertreter;
    public static DerObjectIdentifier Notariatsverwalterin;
    public static DerObjectIdentifier Notariatsverwalter;
    public static DerObjectIdentifier Wirtschaftsprferin;
    public static DerObjectIdentifier Wirtschaftsprfer;
    public static DerObjectIdentifier VereidigteBuchprferin;
    public static DerObjectIdentifier VereidigterBuchprfer;
    public static DerObjectIdentifier Patentanwltin;
    public static DerObjectIdentifier Patentanwalt;
    private NamingAuthority namingAuthority;
    private Asn1Sequence professionItems;
    private Asn1Sequence professionOids;
    private string registrationNumber;
    private Asn1OctetString addProfessionInfo;
    public Asn1OctetString AddProfessionInfo { get; }
    public NamingAuthority NamingAuthority { get; }
    public string RegistrationNumber { get; }
    private ProfessionInfo(Asn1Sequence seq);
    public ProfessionInfo(NamingAuthority namingAuthority, DirectoryString[] professionItems, DerObjectIdentifier[] professionOids, string registrationNumber, Asn1OctetString addProfessionInfo);
    private static ProfessionInfo();
    public static ProfessionInfo GetInstance(object obj);
    public virtual Asn1Object ToAsn1Object();
    public virtual Asn1OctetString get_AddProfessionInfo();
    public virtual NamingAuthority get_NamingAuthority();
    public virtual DirectoryString[] GetProfessionItems();
    public virtual DerObjectIdentifier[] GetProfessionOids();
    public virtual string get_RegistrationNumber();
}
public class Org.BouncyCastle.Asn1.IsisMtt.X509.Restriction : Asn1Encodable {
    private DirectoryString restriction;
    public DirectoryString RestrictionString { get; }
    private Restriction(DirectoryString restriction);
    public Restriction(string restriction);
    public static Restriction GetInstance(object obj);
    public virtual DirectoryString get_RestrictionString();
    public virtual Asn1Object ToAsn1Object();
}
public abstract class Org.BouncyCastle.Asn1.Kisa.KisaObjectIdentifiers : object {
    public static DerObjectIdentifier IdSeedCbc;
    public static DerObjectIdentifier IdNpkiAppCmsSeedWrap;
    private static KisaObjectIdentifiers();
}
public class Org.BouncyCastle.Asn1.LazyAsn1InputStream : Asn1InputStream {
    public LazyAsn1InputStream(Byte[] input);
    public LazyAsn1InputStream(Stream inputStream);
    internal virtual DerSequence CreateDerSequence(DefiniteLengthInputStream dIn);
    internal virtual DerSet CreateDerSet(DefiniteLengthInputStream dIn);
}
[DefaultMemberAttribute("Item")]
internal class Org.BouncyCastle.Asn1.LazyDerSequence : DerSequence {
    private Byte[] encoded;
    public Asn1Encodable Item { get; }
    public int Count { get; }
    internal LazyDerSequence(Byte[] encoded);
    private void Parse();
    public virtual Asn1Encodable get_Item(int index);
    public virtual IEnumerator GetEnumerator();
    public virtual int get_Count();
    internal virtual void Encode(DerOutputStream derOut);
}
[DefaultMemberAttribute("Item")]
internal class Org.BouncyCastle.Asn1.LazyDerSet : DerSet {
    private Byte[] encoded;
    public Asn1Encodable Item { get; }
    public int Count { get; }
    internal LazyDerSet(Byte[] encoded);
    private void Parse();
    public virtual Asn1Encodable get_Item(int index);
    public virtual IEnumerator GetEnumerator();
    public virtual int get_Count();
    internal virtual void Encode(DerOutputStream derOut);
}
internal abstract class Org.BouncyCastle.Asn1.LimitedInputStream : BaseInputStream {
    protected Stream _in;
    private int _limit;
    internal LimitedInputStream(Stream inStream, int limit);
    internal virtual int GetRemaining();
    protected virtual void SetParentEofDetect(bool on);
}
public abstract class Org.BouncyCastle.Asn1.Microsoft.MicrosoftObjectIdentifiers : object {
    public static DerObjectIdentifier Microsoft;
    public static DerObjectIdentifier MicrosoftCertTemplateV1;
    public static DerObjectIdentifier MicrosoftCAVersion;
    public static DerObjectIdentifier MicrosoftPrevCACertHash;
    public static DerObjectIdentifier MicrosoftCertTemplateV2;
    public static DerObjectIdentifier MicrosoftAppPolicies;
    private static MicrosoftObjectIdentifiers();
}
public class Org.BouncyCastle.Asn1.Misc.Cast5CbcParameters : Asn1Encodable {
    private DerInteger keyLength;
    private Asn1OctetString iv;
    public int KeyLength { get; }
    public Cast5CbcParameters(Byte[] iv, int keyLength);
    private Cast5CbcParameters(Asn1Sequence seq);
    public static Cast5CbcParameters GetInstance(object o);
    public Byte[] GetIV();
    public int get_KeyLength();
    public virtual Asn1Object ToAsn1Object();
}
public class Org.BouncyCastle.Asn1.Misc.IdeaCbcPar : Asn1Encodable {
    internal Asn1OctetString iv;
    public IdeaCbcPar(Byte[] iv);
    private IdeaCbcPar(Asn1Sequence seq);
    public static IdeaCbcPar GetInstance(object o);
    public Byte[] GetIV();
    public virtual Asn1Object ToAsn1Object();
}
public abstract class Org.BouncyCastle.Asn1.Misc.MiscObjectIdentifiers : object {
    internal static string Verisign;
    public static DerObjectIdentifier Netscape;
    public static DerObjectIdentifier NetscapeCertType;
    public static DerObjectIdentifier NetscapeBaseUrl;
    public static DerObjectIdentifier NetscapeRevocationUrl;
    public static DerObjectIdentifier NetscapeCARevocationUrl;
    public static DerObjectIdentifier NetscapeRenewalUrl;
    public static DerObjectIdentifier NetscapeCAPolicyUrl;
    public static DerObjectIdentifier NetscapeSslServerName;
    public static DerObjectIdentifier NetscapeCertComment;
    public static DerObjectIdentifier VerisignCzagExtension;
    public static DerObjectIdentifier VerisignDnbDunsNumber;
    public static string Novell;
    public static DerObjectIdentifier NovellSecurityAttribs;
    public static string Entrust;
    public static DerObjectIdentifier EntrustVersionExtension;
    private static MiscObjectIdentifiers();
}
public class Org.BouncyCastle.Asn1.Misc.NetscapeCertType : DerBitString {
    public static int SslClient;
    public static int SslServer;
    public static int Smime;
    public static int ObjectSigning;
    public static int Reserved;
    public static int SslCA;
    public static int SmimeCA;
    public static int ObjectSigningCA;
    public NetscapeCertType(int usage);
    public NetscapeCertType(DerBitString usage);
    public virtual string ToString();
}
public class Org.BouncyCastle.Asn1.Misc.NetscapeRevocationUrl : DerIA5String {
    public NetscapeRevocationUrl(DerIA5String str);
    public virtual string ToString();
}
public class Org.BouncyCastle.Asn1.Misc.VerisignCzagExtension : DerIA5String {
    public VerisignCzagExtension(DerIA5String str);
    public virtual string ToString();
}
public class Org.BouncyCastle.Asn1.Mozilla.PublicKeyAndChallenge : Asn1Encodable {
    private Asn1Sequence pkacSeq;
    private SubjectPublicKeyInfo spki;
    private DerIA5String challenge;
    public SubjectPublicKeyInfo SubjectPublicKeyInfo { get; }
    public DerIA5String Challenge { get; }
    public PublicKeyAndChallenge(Asn1Sequence seq);
    public static PublicKeyAndChallenge GetInstance(object obj);
    public virtual Asn1Object ToAsn1Object();
    public SubjectPublicKeyInfo get_SubjectPublicKeyInfo();
    public DerIA5String get_Challenge();
}
public class Org.BouncyCastle.Asn1.Nist.NistNamedCurves : object {
    private static IDictionary objIds;
    private static IDictionary names;
    public static IEnumerable Names { get; }
    private static NistNamedCurves();
    private static void DefineCurve(string name, DerObjectIdentifier oid);
    public static X9ECParameters GetByName(string name);
    public static X9ECParameters GetByOid(DerObjectIdentifier oid);
    public static DerObjectIdentifier GetOid(string name);
    public static string GetName(DerObjectIdentifier oid);
    public static IEnumerable get_Names();
}
public class Org.BouncyCastle.Asn1.Nist.NistObjectIdentifiers : object {
    public static DerObjectIdentifier NistAlgorithm;
    public static DerObjectIdentifier HashAlgs;
    public static DerObjectIdentifier IdSha256;
    public static DerObjectIdentifier IdSha384;
    public static DerObjectIdentifier IdSha512;
    public static DerObjectIdentifier IdSha224;
    public static DerObjectIdentifier IdSha512_224;
    public static DerObjectIdentifier IdSha512_256;
    public static DerObjectIdentifier Aes;
    public static DerObjectIdentifier IdAes128Ecb;
    public static DerObjectIdentifier IdAes128Cbc;
    public static DerObjectIdentifier IdAes128Ofb;
    public static DerObjectIdentifier IdAes128Cfb;
    public static DerObjectIdentifier IdAes128Wrap;
    public static DerObjectIdentifier IdAes128Gcm;
    public static DerObjectIdentifier IdAes128Ccm;
    public static DerObjectIdentifier IdAes192Ecb;
    public static DerObjectIdentifier IdAes192Cbc;
    public static DerObjectIdentifier IdAes192Ofb;
    public static DerObjectIdentifier IdAes192Cfb;
    public static DerObjectIdentifier IdAes192Wrap;
    public static DerObjectIdentifier IdAes192Gcm;
    public static DerObjectIdentifier IdAes192Ccm;
    public static DerObjectIdentifier IdAes256Ecb;
    public static DerObjectIdentifier IdAes256Cbc;
    public static DerObjectIdentifier IdAes256Ofb;
    public static DerObjectIdentifier IdAes256Cfb;
    public static DerObjectIdentifier IdAes256Wrap;
    public static DerObjectIdentifier IdAes256Gcm;
    public static DerObjectIdentifier IdAes256Ccm;
    public static DerObjectIdentifier IdDsaWithSha2;
    public static DerObjectIdentifier DsaWithSha224;
    public static DerObjectIdentifier DsaWithSha256;
    public static DerObjectIdentifier DsaWithSha384;
    public static DerObjectIdentifier DsaWithSha512;
    private static NistObjectIdentifiers();
}
public abstract class Org.BouncyCastle.Asn1.Ntt.NttObjectIdentifiers : object {
    public static DerObjectIdentifier IdCamellia128Cbc;
    public static DerObjectIdentifier IdCamellia192Cbc;
    public static DerObjectIdentifier IdCamellia256Cbc;
    public static DerObjectIdentifier IdCamellia128Wrap;
    public static DerObjectIdentifier IdCamellia192Wrap;
    public static DerObjectIdentifier IdCamellia256Wrap;
    private static NttObjectIdentifiers();
}
public class Org.BouncyCastle.Asn1.Ocsp.BasicOcspResponse : Asn1Encodable {
    private ResponseData tbsResponseData;
    private AlgorithmIdentifier signatureAlgorithm;
    private DerBitString signature;
    private Asn1Sequence certs;
    public ResponseData TbsResponseData { get; }
    public AlgorithmIdentifier SignatureAlgorithm { get; }
    public DerBitString Signature { get; }
    public Asn1Sequence Certs { get; }
    public BasicOcspResponse(ResponseData tbsResponseData, AlgorithmIdentifier signatureAlgorithm, DerBitString signature, Asn1Sequence certs);
    private BasicOcspResponse(Asn1Sequence seq);
    public static BasicOcspResponse GetInstance(Asn1TaggedObject obj, bool explicitly);
    public static BasicOcspResponse GetInstance(object obj);
    [ObsoleteAttribute("Use TbsResponseData property instead")]
public ResponseData GetTbsResponseData();
    public ResponseData get_TbsResponseData();
    [ObsoleteAttribute("Use SignatureAlgorithm property instead")]
public AlgorithmIdentifier GetSignatureAlgorithm();
    public AlgorithmIdentifier get_SignatureAlgorithm();
    [ObsoleteAttribute("Use Signature property instead")]
public DerBitString GetSignature();
    public DerBitString get_Signature();
    [ObsoleteAttribute("Use Certs property instead")]
public Asn1Sequence GetCerts();
    public Asn1Sequence get_Certs();
    public virtual Asn1Object ToAsn1Object();
}
public class Org.BouncyCastle.Asn1.Ocsp.CertID : Asn1Encodable {
    private AlgorithmIdentifier hashAlgorithm;
    private Asn1OctetString issuerNameHash;
    private Asn1OctetString issuerKeyHash;
    private DerInteger serialNumber;
    public AlgorithmIdentifier HashAlgorithm { get; }
    public Asn1OctetString IssuerNameHash { get; }
    public Asn1OctetString IssuerKeyHash { get; }
    public DerInteger SerialNumber { get; }
    public CertID(AlgorithmIdentifier hashAlgorithm, Asn1OctetString issuerNameHash, Asn1OctetString issuerKeyHash, DerInteger serialNumber);
    private CertID(Asn1Sequence seq);
    public static CertID GetInstance(Asn1TaggedObject obj, bool explicitly);
    public static CertID GetInstance(object obj);
    public AlgorithmIdentifier get_HashAlgorithm();
    public Asn1OctetString get_IssuerNameHash();
    public Asn1OctetString get_IssuerKeyHash();
    public DerInteger get_SerialNumber();
    public virtual Asn1Object ToAsn1Object();
}
public class Org.BouncyCastle.Asn1.Ocsp.CertStatus : Asn1Encodable {
    private int tagNo;
    private Asn1Encodable value;
    public int TagNo { get; }
    public Asn1Encodable Status { get; }
    public CertStatus(RevokedInfo info);
    public CertStatus(int tagNo, Asn1Encodable value);
    public CertStatus(Asn1TaggedObject choice);
    public static CertStatus GetInstance(object obj);
    public int get_TagNo();
    public Asn1Encodable get_Status();
    public virtual Asn1Object ToAsn1Object();
}
public class Org.BouncyCastle.Asn1.Ocsp.CrlID : Asn1Encodable {
    private DerIA5String crlUrl;
    private DerInteger crlNum;
    private DerGeneralizedTime crlTime;
    public DerIA5String CrlUrl { get; }
    public DerInteger CrlNum { get; }
    public DerGeneralizedTime CrlTime { get; }
    public CrlID(Asn1Sequence seq);
    public DerIA5String get_CrlUrl();
    public DerInteger get_CrlNum();
    public DerGeneralizedTime get_CrlTime();
    public virtual Asn1Object ToAsn1Object();
}
public abstract class Org.BouncyCastle.Asn1.Ocsp.OcspObjectIdentifiers : object {
    internal static string PkixOcspId;
    public static DerObjectIdentifier PkixOcsp;
    public static DerObjectIdentifier PkixOcspBasic;
    public static DerObjectIdentifier PkixOcspNonce;
    public static DerObjectIdentifier PkixOcspCrl;
    public static DerObjectIdentifier PkixOcspResponse;
    public static DerObjectIdentifier PkixOcspNocheck;
    public static DerObjectIdentifier PkixOcspArchiveCutoff;
    public static DerObjectIdentifier PkixOcspServiceLocator;
    private static OcspObjectIdentifiers();
}
public class Org.BouncyCastle.Asn1.Ocsp.OcspRequest : Asn1Encodable {
    private TbsRequest tbsRequest;
    private Signature optionalSignature;
    public TbsRequest TbsRequest { get; }
    public Signature OptionalSignature { get; }
    public OcspRequest(TbsRequest tbsRequest, Signature optionalSignature);
    private OcspRequest(Asn1Sequence seq);
    public static OcspRequest GetInstance(Asn1TaggedObject obj, bool explicitly);
    public static OcspRequest GetInstance(object obj);
    public TbsRequest get_TbsRequest();
    public Signature get_OptionalSignature();
    public virtual Asn1Object ToAsn1Object();
}
public class Org.BouncyCastle.Asn1.Ocsp.OcspResponse : Asn1Encodable {
    private OcspResponseStatus responseStatus;
    private ResponseBytes responseBytes;
    public OcspResponseStatus ResponseStatus { get; }
    public ResponseBytes ResponseBytes { get; }
    public OcspResponse(OcspResponseStatus responseStatus, ResponseBytes responseBytes);
    private OcspResponse(Asn1Sequence seq);
    public static OcspResponse GetInstance(Asn1TaggedObject obj, bool explicitly);
    public static OcspResponse GetInstance(object obj);
    public OcspResponseStatus get_ResponseStatus();
    public ResponseBytes get_ResponseBytes();
    public virtual Asn1Object ToAsn1Object();
}
public class Org.BouncyCastle.Asn1.Ocsp.OcspResponseStatus : DerEnumerated {
    public static int Successful;
    public static int MalformedRequest;
    public static int InternalError;
    public static int TryLater;
    public static int SignatureRequired;
    public static int Unauthorized;
    public OcspResponseStatus(int value);
    public OcspResponseStatus(DerEnumerated value);
}
public class Org.BouncyCastle.Asn1.Ocsp.Request : Asn1Encodable {
    private CertID reqCert;
    private X509Extensions singleRequestExtensions;
    public CertID ReqCert { get; }
    public X509Extensions SingleRequestExtensions { get; }
    public Request(CertID reqCert, X509Extensions singleRequestExtensions);
    private Request(Asn1Sequence seq);
    public static Request GetInstance(Asn1TaggedObject obj, bool explicitly);
    public static Request GetInstance(object obj);
    public CertID get_ReqCert();
    public X509Extensions get_SingleRequestExtensions();
    public virtual Asn1Object ToAsn1Object();
}
public class Org.BouncyCastle.Asn1.Ocsp.ResponderID : Asn1Encodable {
    private Asn1Encodable id;
    public X509Name Name { get; }
    public ResponderID(Asn1OctetString id);
    public ResponderID(X509Name id);
    public static ResponderID GetInstance(object obj);
    public static ResponderID GetInstance(Asn1TaggedObject obj, bool isExplicit);
    public virtual Byte[] GetKeyHash();
    public virtual X509Name get_Name();
    public virtual Asn1Object ToAsn1Object();
}
public class Org.BouncyCastle.Asn1.Ocsp.ResponseBytes : Asn1Encodable {
    private DerObjectIdentifier responseType;
    private Asn1OctetString response;
    public DerObjectIdentifier ResponseType { get; }
    public Asn1OctetString Response { get; }
    public ResponseBytes(DerObjectIdentifier responseType, Asn1OctetString response);
    private ResponseBytes(Asn1Sequence seq);
    public static ResponseBytes GetInstance(Asn1TaggedObject obj, bool explicitly);
    public static ResponseBytes GetInstance(object obj);
    public DerObjectIdentifier get_ResponseType();
    public Asn1OctetString get_Response();
    public virtual Asn1Object ToAsn1Object();
}
public class Org.BouncyCastle.Asn1.Ocsp.ResponseData : Asn1Encodable {
    private static DerInteger V1;
    private bool versionPresent;
    private DerInteger version;
    private ResponderID responderID;
    private DerGeneralizedTime producedAt;
    private Asn1Sequence responses;
    private X509Extensions responseExtensions;
    public DerInteger Version { get; }
    public ResponderID ResponderID { get; }
    public DerGeneralizedTime ProducedAt { get; }
    public Asn1Sequence Responses { get; }
    public X509Extensions ResponseExtensions { get; }
    public ResponseData(DerInteger version, ResponderID responderID, DerGeneralizedTime producedAt, Asn1Sequence responses, X509Extensions responseExtensions);
    public ResponseData(ResponderID responderID, DerGeneralizedTime producedAt, Asn1Sequence responses, X509Extensions responseExtensions);
    private ResponseData(Asn1Sequence seq);
    private static ResponseData();
    public static ResponseData GetInstance(Asn1TaggedObject obj, bool explicitly);
    public static ResponseData GetInstance(object obj);
    public DerInteger get_Version();
    public ResponderID get_ResponderID();
    public DerGeneralizedTime get_ProducedAt();
    public Asn1Sequence get_Responses();
    public X509Extensions get_ResponseExtensions();
    public virtual Asn1Object ToAsn1Object();
}
public class Org.BouncyCastle.Asn1.Ocsp.RevokedInfo : Asn1Encodable {
    private DerGeneralizedTime revocationTime;
    private CrlReason revocationReason;
    public DerGeneralizedTime RevocationTime { get; }
    public CrlReason RevocationReason { get; }
    public RevokedInfo(DerGeneralizedTime revocationTime);
    public RevokedInfo(DerGeneralizedTime revocationTime, CrlReason revocationReason);
    private RevokedInfo(Asn1Sequence seq);
    public static RevokedInfo GetInstance(Asn1TaggedObject obj, bool explicitly);
    public static RevokedInfo GetInstance(object obj);
    public DerGeneralizedTime get_RevocationTime();
    public CrlReason get_RevocationReason();
    public virtual Asn1Object ToAsn1Object();
}
public class Org.BouncyCastle.Asn1.Ocsp.ServiceLocator : Asn1Encodable {
    private X509Name issuer;
    private Asn1Object locator;
    public X509Name Issuer { get; }
    public Asn1Object Locator { get; }
    public ServiceLocator(X509Name issuer);
    public ServiceLocator(X509Name issuer, Asn1Object locator);
    private ServiceLocator(Asn1Sequence seq);
    public static ServiceLocator GetInstance(Asn1TaggedObject obj, bool explicitly);
    public static ServiceLocator GetInstance(object obj);
    public X509Name get_Issuer();
    public Asn1Object get_Locator();
    public virtual Asn1Object ToAsn1Object();
}
public class Org.BouncyCastle.Asn1.Ocsp.Signature : Asn1Encodable {
    internal AlgorithmIdentifier signatureAlgorithm;
    internal DerBitString signatureValue;
    internal Asn1Sequence certs;
    public AlgorithmIdentifier SignatureAlgorithm { get; }
    public DerBitString SignatureValue { get; }
    public Asn1Sequence Certs { get; }
    public Signature(AlgorithmIdentifier signatureAlgorithm, DerBitString signatureValue);
    public Signature(AlgorithmIdentifier signatureAlgorithm, DerBitString signatureValue, Asn1Sequence certs);
    private Signature(Asn1Sequence seq);
    public static Signature GetInstance(Asn1TaggedObject obj, bool explicitly);
    public static Signature GetInstance(object obj);
    public AlgorithmIdentifier get_SignatureAlgorithm();
    public DerBitString get_SignatureValue();
    public Asn1Sequence get_Certs();
    public virtual Asn1Object ToAsn1Object();
}
public class Org.BouncyCastle.Asn1.Ocsp.SingleResponse : Asn1Encodable {
    private CertID certID;
    private CertStatus certStatus;
    private DerGeneralizedTime thisUpdate;
    private DerGeneralizedTime nextUpdate;
    private X509Extensions singleExtensions;
    public CertID CertId { get; }
    public CertStatus CertStatus { get; }
    public DerGeneralizedTime ThisUpdate { get; }
    public DerGeneralizedTime NextUpdate { get; }
    public X509Extensions SingleExtensions { get; }
    public SingleResponse(CertID certID, CertStatus certStatus, DerGeneralizedTime thisUpdate, DerGeneralizedTime nextUpdate, X509Extensions singleExtensions);
    public SingleResponse(Asn1Sequence seq);
    public static SingleResponse GetInstance(Asn1TaggedObject obj, bool explicitly);
    public static SingleResponse GetInstance(object obj);
    public CertID get_CertId();
    public CertStatus get_CertStatus();
    public DerGeneralizedTime get_ThisUpdate();
    public DerGeneralizedTime get_NextUpdate();
    public X509Extensions get_SingleExtensions();
    public virtual Asn1Object ToAsn1Object();
}
public class Org.BouncyCastle.Asn1.Ocsp.TbsRequest : Asn1Encodable {
    private static DerInteger V1;
    private DerInteger version;
    private GeneralName requestorName;
    private Asn1Sequence requestList;
    private X509Extensions requestExtensions;
    private bool versionSet;
    public DerInteger Version { get; }
    public GeneralName RequestorName { get; }
    public Asn1Sequence RequestList { get; }
    public X509Extensions RequestExtensions { get; }
    public TbsRequest(GeneralName requestorName, Asn1Sequence requestList, X509Extensions requestExtensions);
    private TbsRequest(Asn1Sequence seq);
    private static TbsRequest();
    public static TbsRequest GetInstance(Asn1TaggedObject obj, bool explicitly);
    public static TbsRequest GetInstance(object obj);
    public DerInteger get_Version();
    public GeneralName get_RequestorName();
    public Asn1Sequence get_RequestList();
    public X509Extensions get_RequestExtensions();
    public virtual Asn1Object ToAsn1Object();
}
public class Org.BouncyCastle.Asn1.OidTokenizer : object {
    private string oid;
    private int index;
    public bool HasMoreTokens { get; }
    public OidTokenizer(string oid);
    public bool get_HasMoreTokens();
    public string NextToken();
}
public class Org.BouncyCastle.Asn1.Oiw.ElGamalParameter : Asn1Encodable {
    internal DerInteger p;
    internal DerInteger g;
    public BigInteger P { get; }
    public BigInteger G { get; }
    public ElGamalParameter(BigInteger p, BigInteger g);
    public ElGamalParameter(Asn1Sequence seq);
    public BigInteger get_P();
    public BigInteger get_G();
    public virtual Asn1Object ToAsn1Object();
}
public abstract class Org.BouncyCastle.Asn1.Oiw.OiwObjectIdentifiers : object {
    public static DerObjectIdentifier MD4WithRsa;
    public static DerObjectIdentifier MD5WithRsa;
    public static DerObjectIdentifier MD4WithRsaEncryption;
    public static DerObjectIdentifier DesEcb;
    public static DerObjectIdentifier DesCbc;
    public static DerObjectIdentifier DesOfb;
    public static DerObjectIdentifier DesCfb;
    public static DerObjectIdentifier DesEde;
    public static DerObjectIdentifier IdSha1;
    public static DerObjectIdentifier DsaWithSha1;
    public static DerObjectIdentifier Sha1WithRsa;
    public static DerObjectIdentifier ElGamalAlgorithm;
    private static OiwObjectIdentifiers();
}
public class Org.BouncyCastle.Asn1.Pkcs.AttributePkcs : Asn1Encodable {
    private DerObjectIdentifier attrType;
    private Asn1Set attrValues;
    public DerObjectIdentifier AttrType { get; }
    public Asn1Set AttrValues { get; }
    private AttributePkcs(Asn1Sequence seq);
    public AttributePkcs(DerObjectIdentifier attrType, Asn1Set attrValues);
    public static AttributePkcs GetInstance(object obj);
    public DerObjectIdentifier get_AttrType();
    public Asn1Set get_AttrValues();
    public virtual Asn1Object ToAsn1Object();
}
public class Org.BouncyCastle.Asn1.Pkcs.AuthenticatedSafe : Asn1Encodable {
    private ContentInfo[] info;
    public AuthenticatedSafe(Asn1Sequence seq);
    public AuthenticatedSafe(ContentInfo[] info);
    public ContentInfo[] GetContentInfo();
    public virtual Asn1Object ToAsn1Object();
}
public class Org.BouncyCastle.Asn1.Pkcs.CertBag : Asn1Encodable {
    private DerObjectIdentifier certID;
    private Asn1Object certValue;
    public DerObjectIdentifier CertID { get; }
    public Asn1Object CertValue { get; }
    public CertBag(Asn1Sequence seq);
    public CertBag(DerObjectIdentifier certID, Asn1Object certValue);
    public DerObjectIdentifier get_CertID();
    public Asn1Object get_CertValue();
    public virtual Asn1Object ToAsn1Object();
}
public class Org.BouncyCastle.Asn1.Pkcs.CertificationRequest : Asn1Encodable {
    protected CertificationRequestInfo reqInfo;
    protected AlgorithmIdentifier sigAlgId;
    protected DerBitString sigBits;
    public AlgorithmIdentifier SignatureAlgorithm { get; }
    public DerBitString Signature { get; }
    public CertificationRequest(CertificationRequestInfo requestInfo, AlgorithmIdentifier algorithm, DerBitString signature);
    public CertificationRequest(Asn1Sequence seq);
    public static CertificationRequest GetInstance(object obj);
    public CertificationRequestInfo GetCertificationRequestInfo();
    public AlgorithmIdentifier get_SignatureAlgorithm();
    public DerBitString get_Signature();
    public virtual Asn1Object ToAsn1Object();
}
public class Org.BouncyCastle.Asn1.Pkcs.CertificationRequestInfo : Asn1Encodable {
    internal DerInteger version;
    internal X509Name subject;
    internal SubjectPublicKeyInfo subjectPKInfo;
    internal Asn1Set attributes;
    public DerInteger Version { get; }
    public X509Name Subject { get; }
    public SubjectPublicKeyInfo SubjectPublicKeyInfo { get; }
    public Asn1Set Attributes { get; }
    public CertificationRequestInfo(X509Name subject, SubjectPublicKeyInfo pkInfo, Asn1Set attributes);
    private CertificationRequestInfo(Asn1Sequence seq);
    public static CertificationRequestInfo GetInstance(object obj);
    public DerInteger get_Version();
    public X509Name get_Subject();
    public SubjectPublicKeyInfo get_SubjectPublicKeyInfo();
    public Asn1Set get_Attributes();
    public virtual Asn1Object ToAsn1Object();
}
public class Org.BouncyCastle.Asn1.Pkcs.ContentInfo : Asn1Encodable {
    private DerObjectIdentifier contentType;
    private Asn1Encodable content;
    public DerObjectIdentifier ContentType { get; }
    public Asn1Encodable Content { get; }
    private ContentInfo(Asn1Sequence seq);
    public ContentInfo(DerObjectIdentifier contentType, Asn1Encodable content);
    public static ContentInfo GetInstance(object obj);
    public DerObjectIdentifier get_ContentType();
    public Asn1Encodable get_Content();
    public virtual Asn1Object ToAsn1Object();
}
public class Org.BouncyCastle.Asn1.Pkcs.DHParameter : Asn1Encodable {
    internal DerInteger p;
    internal DerInteger g;
    internal DerInteger l;
    public BigInteger P { get; }
    public BigInteger G { get; }
    public BigInteger L { get; }
    public DHParameter(BigInteger p, BigInteger g, int l);
    public DHParameter(Asn1Sequence seq);
    public BigInteger get_P();
    public BigInteger get_G();
    public BigInteger get_L();
    public virtual Asn1Object ToAsn1Object();
}
public class Org.BouncyCastle.Asn1.Pkcs.EncryptedData : Asn1Encodable {
    private Asn1Sequence data;
    public DerObjectIdentifier ContentType { get; }
    public AlgorithmIdentifier EncryptionAlgorithm { get; }
    public Asn1OctetString Content { get; }
    private EncryptedData(Asn1Sequence seq);
    public EncryptedData(DerObjectIdentifier contentType, AlgorithmIdentifier encryptionAlgorithm, Asn1Encodable content);
    public static EncryptedData GetInstance(object obj);
    public DerObjectIdentifier get_ContentType();
    public AlgorithmIdentifier get_EncryptionAlgorithm();
    public Asn1OctetString get_Content();
    public virtual Asn1Object ToAsn1Object();
}
public class Org.BouncyCastle.Asn1.Pkcs.EncryptedPrivateKeyInfo : Asn1Encodable {
    private AlgorithmIdentifier algId;
    private Asn1OctetString data;
    public AlgorithmIdentifier EncryptionAlgorithm { get; }
    private EncryptedPrivateKeyInfo(Asn1Sequence seq);
    public EncryptedPrivateKeyInfo(AlgorithmIdentifier algId, Byte[] encoding);
    public static EncryptedPrivateKeyInfo GetInstance(object obj);
    public AlgorithmIdentifier get_EncryptionAlgorithm();
    public Byte[] GetEncryptedData();
    public virtual Asn1Object ToAsn1Object();
}
public class Org.BouncyCastle.Asn1.Pkcs.EncryptionScheme : AlgorithmIdentifier {
    public Asn1Object Asn1Object { get; }
    public EncryptionScheme(DerObjectIdentifier objectID, Asn1Encodable parameters);
    internal EncryptionScheme(Asn1Sequence seq);
    public static EncryptionScheme GetInstance(object obj);
    public Asn1Object get_Asn1Object();
    public virtual Asn1Object ToAsn1Object();
}
public class Org.BouncyCastle.Asn1.Pkcs.IssuerAndSerialNumber : Asn1Encodable {
    private X509Name name;
    private DerInteger certSerialNumber;
    public X509Name Name { get; }
    public DerInteger CertificateSerialNumber { get; }
    private IssuerAndSerialNumber(Asn1Sequence seq);
    public IssuerAndSerialNumber(X509Name name, BigInteger certSerialNumber);
    public IssuerAndSerialNumber(X509Name name, DerInteger certSerialNumber);
    public static IssuerAndSerialNumber GetInstance(object obj);
    public X509Name get_Name();
    public DerInteger get_CertificateSerialNumber();
    public virtual Asn1Object ToAsn1Object();
}
public class Org.BouncyCastle.Asn1.Pkcs.KeyDerivationFunc : AlgorithmIdentifier {
    internal KeyDerivationFunc(Asn1Sequence seq);
    public KeyDerivationFunc(DerObjectIdentifier id, Asn1Encodable parameters);
}
public class Org.BouncyCastle.Asn1.Pkcs.MacData : Asn1Encodable {
    internal DigestInfo digInfo;
    internal Byte[] salt;
    internal BigInteger iterationCount;
    public DigestInfo Mac { get; }
    public BigInteger IterationCount { get; }
    private MacData(Asn1Sequence seq);
    public MacData(DigestInfo digInfo, Byte[] salt, int iterationCount);
    public static MacData GetInstance(object obj);
    public DigestInfo get_Mac();
    public Byte[] GetSalt();
    public BigInteger get_IterationCount();
    public virtual Asn1Object ToAsn1Object();
}
public class Org.BouncyCastle.Asn1.Pkcs.PbeParameter : Asn1Encodable {
    private Asn1OctetString salt;
    private DerInteger iterationCount;
    public BigInteger IterationCount { get; }
    private PbeParameter(Asn1Sequence seq);
    public PbeParameter(Byte[] salt, int iterationCount);
    public static PbeParameter GetInstance(object obj);
    public Byte[] GetSalt();
    public BigInteger get_IterationCount();
    public virtual Asn1Object ToAsn1Object();
}
public class Org.BouncyCastle.Asn1.Pkcs.PbeS2Parameters : Asn1Encodable {
    private KeyDerivationFunc func;
    private EncryptionScheme scheme;
    public KeyDerivationFunc KeyDerivationFunc { get; }
    public EncryptionScheme EncryptionScheme { get; }
    public PbeS2Parameters(KeyDerivationFunc keyDevFunc, EncryptionScheme encScheme);
    [ObsoleteAttribute("Use GetInstance() instead")]
public PbeS2Parameters(Asn1Sequence seq);
    public static PbeS2Parameters GetInstance(object obj);
    public KeyDerivationFunc get_KeyDerivationFunc();
    public EncryptionScheme get_EncryptionScheme();
    public virtual Asn1Object ToAsn1Object();
}
public class Org.BouncyCastle.Asn1.Pkcs.Pbkdf2Params : Asn1Encodable {
    private Asn1OctetString octStr;
    private DerInteger iterationCount;
    private DerInteger keyLength;
    public BigInteger IterationCount { get; }
    public BigInteger KeyLength { get; }
    public Pbkdf2Params(Asn1Sequence seq);
    public Pbkdf2Params(Byte[] salt, int iterationCount);
    public Pbkdf2Params(Byte[] salt, int iterationCount, int keyLength);
    public static Pbkdf2Params GetInstance(object obj);
    public Byte[] GetSalt();
    public BigInteger get_IterationCount();
    public BigInteger get_KeyLength();
    public virtual Asn1Object ToAsn1Object();
}
public class Org.BouncyCastle.Asn1.Pkcs.Pfx : Asn1Encodable {
    private ContentInfo contentInfo;
    private MacData macData;
    public ContentInfo AuthSafe { get; }
    public MacData MacData { get; }
    public Pfx(Asn1Sequence seq);
    public Pfx(ContentInfo contentInfo, MacData macData);
    public ContentInfo get_AuthSafe();
    public MacData get_MacData();
    public virtual Asn1Object ToAsn1Object();
}
public class Org.BouncyCastle.Asn1.Pkcs.Pkcs12PbeParams : Asn1Encodable {
    private DerInteger iterations;
    private Asn1OctetString iv;
    public BigInteger Iterations { get; }
    public Pkcs12PbeParams(Byte[] salt, int iterations);
    private Pkcs12PbeParams(Asn1Sequence seq);
    public static Pkcs12PbeParams GetInstance(object obj);
    public BigInteger get_Iterations();
    public Byte[] GetIV();
    public virtual Asn1Object ToAsn1Object();
}
public abstract class Org.BouncyCastle.Asn1.Pkcs.PkcsObjectIdentifiers : object {
    public static string Pkcs1;
    public static string Pkcs3;
    public static string Pkcs5;
    public static string EncryptionAlgorithm;
    public static string DigestAlgorithm;
    public static string Pkcs7;
    public static string Pkcs9;
    public static string CertTypes;
    public static string CrlTypes;
    public static string IdCT;
    public static string IdCti;
    public static string IdAA;
    public static string IdSpq;
    public static string Pkcs12;
    public static string BagTypes;
    public static string Pkcs12PbeIds;
    public static DerObjectIdentifier RsaEncryption;
    public static DerObjectIdentifier MD2WithRsaEncryption;
    public static DerObjectIdentifier MD4WithRsaEncryption;
    public static DerObjectIdentifier MD5WithRsaEncryption;
    public static DerObjectIdentifier Sha1WithRsaEncryption;
    public static DerObjectIdentifier SrsaOaepEncryptionSet;
    public static DerObjectIdentifier IdRsaesOaep;
    public static DerObjectIdentifier IdMgf1;
    public static DerObjectIdentifier IdPSpecified;
    public static DerObjectIdentifier IdRsassaPss;
    public static DerObjectIdentifier Sha256WithRsaEncryption;
    public static DerObjectIdentifier Sha384WithRsaEncryption;
    public static DerObjectIdentifier Sha512WithRsaEncryption;
    public static DerObjectIdentifier Sha224WithRsaEncryption;
    public static DerObjectIdentifier DhKeyAgreement;
    public static DerObjectIdentifier PbeWithMD2AndDesCbc;
    public static DerObjectIdentifier PbeWithMD2AndRC2Cbc;
    public static DerObjectIdentifier PbeWithMD5AndDesCbc;
    public static DerObjectIdentifier PbeWithMD5AndRC2Cbc;
    public static DerObjectIdentifier PbeWithSha1AndDesCbc;
    public static DerObjectIdentifier PbeWithSha1AndRC2Cbc;
    public static DerObjectIdentifier IdPbeS2;
    public static DerObjectIdentifier IdPbkdf2;
    public static DerObjectIdentifier DesEde3Cbc;
    public static DerObjectIdentifier RC2Cbc;
    public static DerObjectIdentifier MD2;
    public static DerObjectIdentifier MD4;
    public static DerObjectIdentifier MD5;
    public static DerObjectIdentifier IdHmacWithSha1;
    public static DerObjectIdentifier IdHmacWithSha224;
    public static DerObjectIdentifier IdHmacWithSha256;
    public static DerObjectIdentifier IdHmacWithSha384;
    public static DerObjectIdentifier IdHmacWithSha512;
    public static DerObjectIdentifier Data;
    public static DerObjectIdentifier SignedData;
    public static DerObjectIdentifier EnvelopedData;
    public static DerObjectIdentifier SignedAndEnvelopedData;
    public static DerObjectIdentifier DigestedData;
    public static DerObjectIdentifier EncryptedData;
    public static DerObjectIdentifier Pkcs9AtEmailAddress;
    public static DerObjectIdentifier Pkcs9AtUnstructuredName;
    public static DerObjectIdentifier Pkcs9AtContentType;
    public static DerObjectIdentifier Pkcs9AtMessageDigest;
    public static DerObjectIdentifier Pkcs9AtSigningTime;
    public static DerObjectIdentifier Pkcs9AtCounterSignature;
    public static DerObjectIdentifier Pkcs9AtChallengePassword;
    public static DerObjectIdentifier Pkcs9AtUnstructuredAddress;
    public static DerObjectIdentifier Pkcs9AtExtendedCertificateAttributes;
    public static DerObjectIdentifier Pkcs9AtSigningDescription;
    public static DerObjectIdentifier Pkcs9AtExtensionRequest;
    public static DerObjectIdentifier Pkcs9AtSmimeCapabilities;
    public static DerObjectIdentifier Pkcs9AtFriendlyName;
    public static DerObjectIdentifier Pkcs9AtLocalKeyID;
    [ObsoleteAttribute("Use X509Certificate instead")]
public static DerObjectIdentifier X509CertType;
    public static DerObjectIdentifier X509Certificate;
    public static DerObjectIdentifier SdsiCertificate;
    public static DerObjectIdentifier X509Crl;
    public static DerObjectIdentifier IdAlgPwriKek;
    public static DerObjectIdentifier PreferSignedData;
    public static DerObjectIdentifier CannotDecryptAny;
    public static DerObjectIdentifier SmimeCapabilitiesVersions;
    public static DerObjectIdentifier IdAAReceiptRequest;
    public static DerObjectIdentifier IdCTAuthData;
    public static DerObjectIdentifier IdCTTstInfo;
    public static DerObjectIdentifier IdCTCompressedData;
    public static DerObjectIdentifier IdCTAuthEnvelopedData;
    public static DerObjectIdentifier IdCTTimestampedData;
    public static DerObjectIdentifier IdCtiEtsProofOfOrigin;
    public static DerObjectIdentifier IdCtiEtsProofOfReceipt;
    public static DerObjectIdentifier IdCtiEtsProofOfDelivery;
    public static DerObjectIdentifier IdCtiEtsProofOfSender;
    public static DerObjectIdentifier IdCtiEtsProofOfApproval;
    public static DerObjectIdentifier IdCtiEtsProofOfCreation;
    public static DerObjectIdentifier IdAAContentHint;
    public static DerObjectIdentifier IdAAMsgSigDigest;
    public static DerObjectIdentifier IdAAContentReference;
    public static DerObjectIdentifier IdAAEncrypKeyPref;
    public static DerObjectIdentifier IdAASigningCertificate;
    public static DerObjectIdentifier IdAASigningCertificateV2;
    public static DerObjectIdentifier IdAAContentIdentifier;
    public static DerObjectIdentifier IdAASignatureTimeStampToken;
    public static DerObjectIdentifier IdAAEtsSigPolicyID;
    public static DerObjectIdentifier IdAAEtsCommitmentType;
    public static DerObjectIdentifier IdAAEtsSignerLocation;
    public static DerObjectIdentifier IdAAEtsSignerAttr;
    public static DerObjectIdentifier IdAAEtsOtherSigCert;
    public static DerObjectIdentifier IdAAEtsContentTimestamp;
    public static DerObjectIdentifier IdAAEtsCertificateRefs;
    public static DerObjectIdentifier IdAAEtsRevocationRefs;
    public static DerObjectIdentifier IdAAEtsCertValues;
    public static DerObjectIdentifier IdAAEtsRevocationValues;
    public static DerObjectIdentifier IdAAEtsEscTimeStamp;
    public static DerObjectIdentifier IdAAEtsCertCrlTimestamp;
    public static DerObjectIdentifier IdAAEtsArchiveTimestamp;
    [ObsoleteAttribute("Use 'IdAAEtsSigPolicyID' instead")]
public static DerObjectIdentifier IdAASigPolicyID;
    [ObsoleteAttribute("Use 'IdAAEtsCommitmentType' instead")]
public static DerObjectIdentifier IdAACommitmentType;
    [ObsoleteAttribute("Use 'IdAAEtsSignerLocation' instead")]
public static DerObjectIdentifier IdAASignerLocation;
    [ObsoleteAttribute("Use 'IdAAEtsOtherSigCert' instead")]
public static DerObjectIdentifier IdAAOtherSigCert;
    public static DerObjectIdentifier IdSpqEtsUri;
    public static DerObjectIdentifier IdSpqEtsUNotice;
    public static DerObjectIdentifier KeyBag;
    public static DerObjectIdentifier Pkcs8ShroudedKeyBag;
    public static DerObjectIdentifier CertBag;
    public static DerObjectIdentifier CrlBag;
    public static DerObjectIdentifier SecretBag;
    public static DerObjectIdentifier SafeContentsBag;
    public static DerObjectIdentifier PbeWithShaAnd128BitRC4;
    public static DerObjectIdentifier PbeWithShaAnd40BitRC4;
    public static DerObjectIdentifier PbeWithShaAnd3KeyTripleDesCbc;
    public static DerObjectIdentifier PbeWithShaAnd2KeyTripleDesCbc;
    public static DerObjectIdentifier PbeWithShaAnd128BitRC2Cbc;
    public static DerObjectIdentifier PbewithShaAnd40BitRC2Cbc;
    public static DerObjectIdentifier IdAlgCms3DesWrap;
    public static DerObjectIdentifier IdAlgCmsRC2Wrap;
    private static PkcsObjectIdentifiers();
}
public class Org.BouncyCastle.Asn1.Pkcs.PrivateKeyInfo : Asn1Encodable {
    private Asn1Object privKey;
    private AlgorithmIdentifier algID;
    private Asn1Set attributes;
    public AlgorithmIdentifier AlgorithmID { get; }
    public Asn1Object PrivateKey { get; }
    public Asn1Set Attributes { get; }
    public PrivateKeyInfo(AlgorithmIdentifier algID, Asn1Object privateKey);
    public PrivateKeyInfo(AlgorithmIdentifier algID, Asn1Object privateKey, Asn1Set attributes);
    private PrivateKeyInfo(Asn1Sequence seq);
    public static PrivateKeyInfo GetInstance(object obj);
    public AlgorithmIdentifier get_AlgorithmID();
    public Asn1Object get_PrivateKey();
    public Asn1Set get_Attributes();
    public virtual Asn1Object ToAsn1Object();
}
public class Org.BouncyCastle.Asn1.Pkcs.RC2CbcParameter : Asn1Encodable {
    internal DerInteger version;
    internal Asn1OctetString iv;
    public BigInteger RC2ParameterVersion { get; }
    public RC2CbcParameter(Byte[] iv);
    public RC2CbcParameter(int parameterVersion, Byte[] iv);
    private RC2CbcParameter(Asn1Sequence seq);
    public static RC2CbcParameter GetInstance(object obj);
    public BigInteger get_RC2ParameterVersion();
    public Byte[] GetIV();
    public virtual Asn1Object ToAsn1Object();
}
public class Org.BouncyCastle.Asn1.Pkcs.RsaesOaepParameters : Asn1Encodable {
    private AlgorithmIdentifier hashAlgorithm;
    private AlgorithmIdentifier maskGenAlgorithm;
    private AlgorithmIdentifier pSourceAlgorithm;
    public static AlgorithmIdentifier DefaultHashAlgorithm;
    public static AlgorithmIdentifier DefaultMaskGenFunction;
    public static AlgorithmIdentifier DefaultPSourceAlgorithm;
    public AlgorithmIdentifier HashAlgorithm { get; }
    public AlgorithmIdentifier MaskGenAlgorithm { get; }
    public AlgorithmIdentifier PSourceAlgorithm { get; }
    public RsaesOaepParameters(AlgorithmIdentifier hashAlgorithm, AlgorithmIdentifier maskGenAlgorithm, AlgorithmIdentifier pSourceAlgorithm);
    public RsaesOaepParameters(Asn1Sequence seq);
    private static RsaesOaepParameters();
    public static RsaesOaepParameters GetInstance(object obj);
    public AlgorithmIdentifier get_HashAlgorithm();
    public AlgorithmIdentifier get_MaskGenAlgorithm();
    public AlgorithmIdentifier get_PSourceAlgorithm();
    public virtual Asn1Object ToAsn1Object();
}
public class Org.BouncyCastle.Asn1.Pkcs.RsaPrivateKeyStructure : Asn1Encodable {
    private BigInteger modulus;
    private BigInteger publicExponent;
    private BigInteger privateExponent;
    private BigInteger prime1;
    private BigInteger prime2;
    private BigInteger exponent1;
    private BigInteger exponent2;
    private BigInteger coefficient;
    public BigInteger Modulus { get; }
    public BigInteger PublicExponent { get; }
    public BigInteger PrivateExponent { get; }
    public BigInteger Prime1 { get; }
    public BigInteger Prime2 { get; }
    public BigInteger Exponent1 { get; }
    public BigInteger Exponent2 { get; }
    public BigInteger Coefficient { get; }
    public RsaPrivateKeyStructure(BigInteger modulus, BigInteger publicExponent, BigInteger privateExponent, BigInteger prime1, BigInteger prime2, BigInteger exponent1, BigInteger exponent2, BigInteger coefficient);
    public RsaPrivateKeyStructure(Asn1Sequence seq);
    public BigInteger get_Modulus();
    public BigInteger get_PublicExponent();
    public BigInteger get_PrivateExponent();
    public BigInteger get_Prime1();
    public BigInteger get_Prime2();
    public BigInteger get_Exponent1();
    public BigInteger get_Exponent2();
    public BigInteger get_Coefficient();
    public virtual Asn1Object ToAsn1Object();
}
public class Org.BouncyCastle.Asn1.Pkcs.RsassaPssParameters : Asn1Encodable {
    private AlgorithmIdentifier hashAlgorithm;
    private AlgorithmIdentifier maskGenAlgorithm;
    private DerInteger saltLength;
    private DerInteger trailerField;
    public static AlgorithmIdentifier DefaultHashAlgorithm;
    public static AlgorithmIdentifier DefaultMaskGenFunction;
    public static DerInteger DefaultSaltLength;
    public static DerInteger DefaultTrailerField;
    public AlgorithmIdentifier HashAlgorithm { get; }
    public AlgorithmIdentifier MaskGenAlgorithm { get; }
    public DerInteger SaltLength { get; }
    public DerInteger TrailerField { get; }
    public RsassaPssParameters(AlgorithmIdentifier hashAlgorithm, AlgorithmIdentifier maskGenAlgorithm, DerInteger saltLength, DerInteger trailerField);
    public RsassaPssParameters(Asn1Sequence seq);
    private static RsassaPssParameters();
    public static RsassaPssParameters GetInstance(object obj);
    public AlgorithmIdentifier get_HashAlgorithm();
    public AlgorithmIdentifier get_MaskGenAlgorithm();
    public DerInteger get_SaltLength();
    public DerInteger get_TrailerField();
    public virtual Asn1Object ToAsn1Object();
}
public class Org.BouncyCastle.Asn1.Pkcs.SafeBag : Asn1Encodable {
    private DerObjectIdentifier bagID;
    private Asn1Object bagValue;
    private Asn1Set bagAttributes;
    public DerObjectIdentifier BagID { get; }
    public Asn1Object BagValue { get; }
    public Asn1Set BagAttributes { get; }
    public SafeBag(DerObjectIdentifier oid, Asn1Object obj);
    public SafeBag(DerObjectIdentifier oid, Asn1Object obj, Asn1Set bagAttributes);
    public SafeBag(Asn1Sequence seq);
    public DerObjectIdentifier get_BagID();
    public Asn1Object get_BagValue();
    public Asn1Set get_BagAttributes();
    public virtual Asn1Object ToAsn1Object();
}
public class Org.BouncyCastle.Asn1.Pkcs.SignedData : Asn1Encodable {
    private DerInteger version;
    private Asn1Set digestAlgorithms;
    private ContentInfo contentInfo;
    private Asn1Set certificates;
    private Asn1Set crls;
    private Asn1Set signerInfos;
    public DerInteger Version { get; }
    public Asn1Set DigestAlgorithms { get; }
    public ContentInfo ContentInfo { get; }
    public Asn1Set Certificates { get; }
    public Asn1Set Crls { get; }
    public Asn1Set SignerInfos { get; }
    public SignedData(DerInteger _version, Asn1Set _digestAlgorithms, ContentInfo _contentInfo, Asn1Set _certificates, Asn1Set _crls, Asn1Set _signerInfos);
    private SignedData(Asn1Sequence seq);
    public static SignedData GetInstance(object obj);
    public DerInteger get_Version();
    public Asn1Set get_DigestAlgorithms();
    public ContentInfo get_ContentInfo();
    public Asn1Set get_Certificates();
    public Asn1Set get_Crls();
    public Asn1Set get_SignerInfos();
    public virtual Asn1Object ToAsn1Object();
}
public class Org.BouncyCastle.Asn1.Pkcs.SignerInfo : Asn1Encodable {
    private DerInteger version;
    private IssuerAndSerialNumber issuerAndSerialNumber;
    private AlgorithmIdentifier digAlgorithm;
    private Asn1Set authenticatedAttributes;
    private AlgorithmIdentifier digEncryptionAlgorithm;
    private Asn1OctetString encryptedDigest;
    private Asn1Set unauthenticatedAttributes;
    public DerInteger Version { get; }
    public IssuerAndSerialNumber IssuerAndSerialNumber { get; }
    public Asn1Set AuthenticatedAttributes { get; }
    public AlgorithmIdentifier DigestAlgorithm { get; }
    public Asn1OctetString EncryptedDigest { get; }
    public AlgorithmIdentifier DigestEncryptionAlgorithm { get; }
    public Asn1Set UnauthenticatedAttributes { get; }
    public SignerInfo(DerInteger version, IssuerAndSerialNumber issuerAndSerialNumber, AlgorithmIdentifier digAlgorithm, Asn1Set authenticatedAttributes, AlgorithmIdentifier digEncryptionAlgorithm, Asn1OctetString encryptedDigest, Asn1Set unauthenticatedAttributes);
    public SignerInfo(Asn1Sequence seq);
    public static SignerInfo GetInstance(object obj);
    public DerInteger get_Version();
    public IssuerAndSerialNumber get_IssuerAndSerialNumber();
    public Asn1Set get_AuthenticatedAttributes();
    public AlgorithmIdentifier get_DigestAlgorithm();
    public Asn1OctetString get_EncryptedDigest();
    public AlgorithmIdentifier get_DigestEncryptionAlgorithm();
    public Asn1Set get_UnauthenticatedAttributes();
    public virtual Asn1Object ToAsn1Object();
}
public class Org.BouncyCastle.Asn1.Sec.ECPrivateKeyStructure : Asn1Encodable {
    private Asn1Sequence seq;
    public ECPrivateKeyStructure(Asn1Sequence seq);
    public ECPrivateKeyStructure(BigInteger key);
    public ECPrivateKeyStructure(BigInteger key, Asn1Encodable parameters);
    public ECPrivateKeyStructure(BigInteger key, DerBitString publicKey, Asn1Encodable parameters);
    public BigInteger GetKey();
    public DerBitString GetPublicKey();
    public Asn1Object GetParameters();
    private Asn1Object GetObjectInTag(int tagNo);
    public virtual Asn1Object ToAsn1Object();
}
public class Org.BouncyCastle.Asn1.Sec.SecNamedCurves : object {
    private static IDictionary objIds;
    private static IDictionary curves;
    private static IDictionary names;
    public static IEnumerable Names { get; }
    private static SecNamedCurves();
    private static BigInteger FromHex(string hex);
    private static void DefineCurve(string name, DerObjectIdentifier oid, X9ECParametersHolder holder);
    public static X9ECParameters GetByName(string name);
    public static X9ECParameters GetByOid(DerObjectIdentifier oid);
    public static DerObjectIdentifier GetOid(string name);
    public static string GetName(DerObjectIdentifier oid);
    public static IEnumerable get_Names();
}
public abstract class Org.BouncyCastle.Asn1.Sec.SecObjectIdentifiers : object {
    public static DerObjectIdentifier EllipticCurve;
    public static DerObjectIdentifier SecT163k1;
    public static DerObjectIdentifier SecT163r1;
    public static DerObjectIdentifier SecT239k1;
    public static DerObjectIdentifier SecT113r1;
    public static DerObjectIdentifier SecT113r2;
    public static DerObjectIdentifier SecP112r1;
    public static DerObjectIdentifier SecP112r2;
    public static DerObjectIdentifier SecP160r1;
    public static DerObjectIdentifier SecP160k1;
    public static DerObjectIdentifier SecP256k1;
    public static DerObjectIdentifier SecT163r2;
    public static DerObjectIdentifier SecT283k1;
    public static DerObjectIdentifier SecT283r1;
    public static DerObjectIdentifier SecT131r1;
    public static DerObjectIdentifier SecT131r2;
    public static DerObjectIdentifier SecT193r1;
    public static DerObjectIdentifier SecT193r2;
    public static DerObjectIdentifier SecT233k1;
    public static DerObjectIdentifier SecT233r1;
    public static DerObjectIdentifier SecP128r1;
    public static DerObjectIdentifier SecP128r2;
    public static DerObjectIdentifier SecP160r2;
    public static DerObjectIdentifier SecP192k1;
    public static DerObjectIdentifier SecP224k1;
    public static DerObjectIdentifier SecP224r1;
    public static DerObjectIdentifier SecP384r1;
    public static DerObjectIdentifier SecP521r1;
    public static DerObjectIdentifier SecT409k1;
    public static DerObjectIdentifier SecT409r1;
    public static DerObjectIdentifier SecT571k1;
    public static DerObjectIdentifier SecT571r1;
    public static DerObjectIdentifier SecP192r1;
    public static DerObjectIdentifier SecP256r1;
    private static SecObjectIdentifiers();
}
public abstract class Org.BouncyCastle.Asn1.Smime.SmimeAttributes : object {
    public static DerObjectIdentifier SmimeCapabilities;
    public static DerObjectIdentifier EncrypKeyPref;
    private static SmimeAttributes();
}
public class Org.BouncyCastle.Asn1.Smime.SmimeCapabilities : Asn1Encodable {
    public static DerObjectIdentifier PreferSignedData;
    public static DerObjectIdentifier CannotDecryptAny;
    public static DerObjectIdentifier SmimeCapabilitesVersions;
    public static DerObjectIdentifier DesCbc;
    public static DerObjectIdentifier DesEde3Cbc;
    public static DerObjectIdentifier RC2Cbc;
    private Asn1Sequence capabilities;
    public SmimeCapabilities(Asn1Sequence seq);
    private static SmimeCapabilities();
    public static SmimeCapabilities GetInstance(object obj);
    [ObsoleteAttribute("Use 'GetCapabilitiesForOid' instead")]
public ArrayList GetCapabilities(DerObjectIdentifier capability);
    public IList GetCapabilitiesForOid(DerObjectIdentifier capability);
    private void DoGetCapabilitiesForOid(DerObjectIdentifier capability, IList list);
    public virtual Asn1Object ToAsn1Object();
}
public class Org.BouncyCastle.Asn1.Smime.SmimeCapabilitiesAttribute : AttributeX509 {
    public SmimeCapabilitiesAttribute(SmimeCapabilityVector capabilities);
}
public class Org.BouncyCastle.Asn1.Smime.SmimeCapability : Asn1Encodable {
    public static DerObjectIdentifier PreferSignedData;
    public static DerObjectIdentifier CannotDecryptAny;
    public static DerObjectIdentifier SmimeCapabilitiesVersions;
    public static DerObjectIdentifier DesCbc;
    public static DerObjectIdentifier DesEde3Cbc;
    public static DerObjectIdentifier RC2Cbc;
    private DerObjectIdentifier capabilityID;
    private Asn1Object parameters;
    public DerObjectIdentifier CapabilityID { get; }
    public Asn1Object Parameters { get; }
    public SmimeCapability(Asn1Sequence seq);
    public SmimeCapability(DerObjectIdentifier capabilityID, Asn1Encodable parameters);
    private static SmimeCapability();
    public static SmimeCapability GetInstance(object obj);
    public DerObjectIdentifier get_CapabilityID();
    public Asn1Object get_Parameters();
    public virtual Asn1Object ToAsn1Object();
}
public class Org.BouncyCastle.Asn1.Smime.SmimeCapabilityVector : object {
    private Asn1EncodableVector capabilities;
    public void AddCapability(DerObjectIdentifier capability);
    public void AddCapability(DerObjectIdentifier capability, int value);
    public void AddCapability(DerObjectIdentifier capability, Asn1Encodable parameters);
    public Asn1EncodableVector ToAsn1EncodableVector();
}
public class Org.BouncyCastle.Asn1.Smime.SmimeEncryptionKeyPreferenceAttribute : AttributeX509 {
    public SmimeEncryptionKeyPreferenceAttribute(IssuerAndSerialNumber issAndSer);
    public SmimeEncryptionKeyPreferenceAttribute(RecipientKeyIdentifier rKeyID);
    public SmimeEncryptionKeyPreferenceAttribute(Asn1OctetString sKeyID);
}
public class Org.BouncyCastle.Asn1.TeleTrust.TeleTrusTNamedCurves : object {
    private static IDictionary objIds;
    private static IDictionary curves;
    private static IDictionary names;
    public static IEnumerable Names { get; }
    private static TeleTrusTNamedCurves();
    private static void DefineCurve(string name, DerObjectIdentifier oid, X9ECParametersHolder holder);
    public static X9ECParameters GetByName(string name);
    public static X9ECParameters GetByOid(DerObjectIdentifier oid);
    public static DerObjectIdentifier GetOid(string name);
    public static string GetName(DerObjectIdentifier oid);
    public static IEnumerable get_Names();
    public static DerObjectIdentifier GetOid(short curvesize, bool twisted);
}
public class Org.BouncyCastle.Asn1.TeleTrust.TeleTrusTObjectIdentifiers : object {
    public static DerObjectIdentifier TeleTrusTAlgorithm;
    public static DerObjectIdentifier RipeMD160;
    public static DerObjectIdentifier RipeMD128;
    public static DerObjectIdentifier RipeMD256;
    public static DerObjectIdentifier TeleTrusTRsaSignatureAlgorithm;
    public static DerObjectIdentifier RsaSignatureWithRipeMD160;
    public static DerObjectIdentifier RsaSignatureWithRipeMD128;
    public static DerObjectIdentifier RsaSignatureWithRipeMD256;
    public static DerObjectIdentifier ECSign;
    public static DerObjectIdentifier ECSignWithSha1;
    public static DerObjectIdentifier ECSignWithRipeMD160;
    public static DerObjectIdentifier EccBrainpool;
    public static DerObjectIdentifier EllipticCurve;
    public static DerObjectIdentifier VersionOne;
    public static DerObjectIdentifier BrainpoolP160R1;
    public static DerObjectIdentifier BrainpoolP160T1;
    public static DerObjectIdentifier BrainpoolP192R1;
    public static DerObjectIdentifier BrainpoolP192T1;
    public static DerObjectIdentifier BrainpoolP224R1;
    public static DerObjectIdentifier BrainpoolP224T1;
    public static DerObjectIdentifier BrainpoolP256R1;
    public static DerObjectIdentifier BrainpoolP256T1;
    public static DerObjectIdentifier BrainpoolP320R1;
    public static DerObjectIdentifier BrainpoolP320T1;
    public static DerObjectIdentifier BrainpoolP384R1;
    public static DerObjectIdentifier BrainpoolP384T1;
    public static DerObjectIdentifier BrainpoolP512R1;
    public static DerObjectIdentifier BrainpoolP512T1;
    private static TeleTrusTObjectIdentifiers();
}
public class Org.BouncyCastle.Asn1.Tsp.Accuracy : Asn1Encodable {
    protected static int MinMillis;
    protected static int MaxMillis;
    protected static int MinMicros;
    protected static int MaxMicros;
    private DerInteger seconds;
    private DerInteger millis;
    private DerInteger micros;
    public DerInteger Seconds { get; }
    public DerInteger Millis { get; }
    public DerInteger Micros { get; }
    public Accuracy(DerInteger seconds, DerInteger millis, DerInteger micros);
    private Accuracy(Asn1Sequence seq);
    public static Accuracy GetInstance(object o);
    public DerInteger get_Seconds();
    public DerInteger get_Millis();
    public DerInteger get_Micros();
    public virtual Asn1Object ToAsn1Object();
}
public class Org.BouncyCastle.Asn1.Tsp.MessageImprint : Asn1Encodable {
    private AlgorithmIdentifier hashAlgorithm;
    private Byte[] hashedMessage;
    public AlgorithmIdentifier HashAlgorithm { get; }
    private MessageImprint(Asn1Sequence seq);
    public MessageImprint(AlgorithmIdentifier hashAlgorithm, Byte[] hashedMessage);
    public static MessageImprint GetInstance(object o);
    public AlgorithmIdentifier get_HashAlgorithm();
    public Byte[] GetHashedMessage();
    public virtual Asn1Object ToAsn1Object();
}
public class Org.BouncyCastle.Asn1.Tsp.TimeStampReq : Asn1Encodable {
    private DerInteger version;
    private MessageImprint messageImprint;
    private DerObjectIdentifier tsaPolicy;
    private DerInteger nonce;
    private DerBoolean certReq;
    private X509Extensions extensions;
    public DerInteger Version { get; }
    public MessageImprint MessageImprint { get; }
    public DerObjectIdentifier ReqPolicy { get; }
    public DerInteger Nonce { get; }
    public DerBoolean CertReq { get; }
    public X509Extensions Extensions { get; }
    private TimeStampReq(Asn1Sequence seq);
    public TimeStampReq(MessageImprint messageImprint, DerObjectIdentifier tsaPolicy, DerInteger nonce, DerBoolean certReq, X509Extensions extensions);
    public static TimeStampReq GetInstance(object o);
    public DerInteger get_Version();
    public MessageImprint get_MessageImprint();
    public DerObjectIdentifier get_ReqPolicy();
    public DerInteger get_Nonce();
    public DerBoolean get_CertReq();
    public X509Extensions get_Extensions();
    public virtual Asn1Object ToAsn1Object();
}
public class Org.BouncyCastle.Asn1.Tsp.TimeStampResp : Asn1Encodable {
    private PkiStatusInfo pkiStatusInfo;
    private ContentInfo timeStampToken;
    public PkiStatusInfo Status { get; }
    public ContentInfo TimeStampToken { get; }
    private TimeStampResp(Asn1Sequence seq);
    public TimeStampResp(PkiStatusInfo pkiStatusInfo, ContentInfo timeStampToken);
    public static TimeStampResp GetInstance(object o);
    public PkiStatusInfo get_Status();
    public ContentInfo get_TimeStampToken();
    public virtual Asn1Object ToAsn1Object();
}
public class Org.BouncyCastle.Asn1.Tsp.TstInfo : Asn1Encodable {
    private DerInteger version;
    private DerObjectIdentifier tsaPolicyId;
    private MessageImprint messageImprint;
    private DerInteger serialNumber;
    private DerGeneralizedTime genTime;
    private Accuracy accuracy;
    private DerBoolean ordering;
    private DerInteger nonce;
    private GeneralName tsa;
    private X509Extensions extensions;
    public DerInteger Version { get; }
    public MessageImprint MessageImprint { get; }
    public DerObjectIdentifier Policy { get; }
    public DerInteger SerialNumber { get; }
    public Accuracy Accuracy { get; }
    public DerGeneralizedTime GenTime { get; }
    public DerBoolean Ordering { get; }
    public DerInteger Nonce { get; }
    public GeneralName Tsa { get; }
    public X509Extensions Extensions { get; }
    private TstInfo(Asn1Sequence seq);
    public TstInfo(DerObjectIdentifier tsaPolicyId, MessageImprint messageImprint, DerInteger serialNumber, DerGeneralizedTime genTime, Accuracy accuracy, DerBoolean ordering, DerInteger nonce, GeneralName tsa, X509Extensions extensions);
    public static TstInfo GetInstance(object o);
    public DerInteger get_Version();
    public MessageImprint get_MessageImprint();
    public DerObjectIdentifier get_Policy();
    public DerInteger get_SerialNumber();
    public Accuracy get_Accuracy();
    public DerGeneralizedTime get_GenTime();
    public DerBoolean get_Ordering();
    public DerInteger get_Nonce();
    public GeneralName get_Tsa();
    public X509Extensions get_Extensions();
    public virtual Asn1Object ToAsn1Object();
}
public class Org.BouncyCastle.Asn1.Utilities.Asn1Dump : object {
    private static string Tab;
    private static int SampleSize;
    private static string NewLine;
    private static Asn1Dump();
    private static void AsString(string indent, bool verbose, Asn1Object obj, StringBuilder buf);
    private static string outputApplicationSpecific(string type, string indent, bool verbose, DerApplicationSpecific app);
    [ObsoleteAttribute("Use version accepting Asn1Encodable")]
public static string DumpAsString(object obj);
    public static string DumpAsString(Asn1Encodable obj);
    public static string DumpAsString(Asn1Encodable obj, bool verbose);
    private static string dumpBinaryDataAsString(string indent, Byte[] bytes);
    private static string calculateAscString(Byte[] bytes, int off, int len);
}
public class Org.BouncyCastle.Asn1.Utilities.Dump : object {
    public static void Main(String[] args);
}
public class Org.BouncyCastle.Asn1.Utilities.FilterStream : Stream {
    protected Stream s;
    public bool CanRead { get; }
    public bool CanSeek { get; }
    public bool CanWrite { get; }
    public long Length { get; }
    public long Position { get; public set; }
    public FilterStream(Stream s);
    public virtual bool get_CanRead();
    public virtual bool get_CanSeek();
    public virtual bool get_CanWrite();
    public virtual long get_Length();
    public virtual long get_Position();
    public virtual void set_Position(long value);
    public virtual void Close();
    public virtual void Flush();
    public virtual long Seek(long offset, SeekOrigin origin);
    public virtual void SetLength(long value);
    public virtual int Read(Byte[] buffer, int offset, int count);
    public virtual int ReadByte();
    public virtual void Write(Byte[] buffer, int offset, int count);
    public virtual void WriteByte(byte value);
}
public class Org.BouncyCastle.Asn1.X500.DirectoryString : Asn1Encodable {
    private DerStringBase str;
    private DirectoryString(DerStringBase str);
    public DirectoryString(string str);
    public static DirectoryString GetInstance(object obj);
    public static DirectoryString GetInstance(Asn1TaggedObject obj, bool isExplicit);
    public sealed virtual string GetString();
    public virtual Asn1Object ToAsn1Object();
}
public class Org.BouncyCastle.Asn1.X509.AccessDescription : Asn1Encodable {
    public static DerObjectIdentifier IdADCAIssuers;
    public static DerObjectIdentifier IdADOcsp;
    private DerObjectIdentifier accessMethod;
    private GeneralName accessLocation;
    public DerObjectIdentifier AccessMethod { get; }
    public GeneralName AccessLocation { get; }
    private AccessDescription(Asn1Sequence seq);
    public AccessDescription(DerObjectIdentifier oid, GeneralName location);
    private static AccessDescription();
    public static AccessDescription GetInstance(object obj);
    public DerObjectIdentifier get_AccessMethod();
    public GeneralName get_AccessLocation();
    public virtual Asn1Object ToAsn1Object();
    public virtual string ToString();
}
public class Org.BouncyCastle.Asn1.X509.AlgorithmIdentifier : Asn1Encodable {
    private DerObjectIdentifier objectID;
    private Asn1Encodable parameters;
    private bool parametersDefined;
    public DerObjectIdentifier ObjectID { get; }
    public Asn1Encodable Parameters { get; }
    public AlgorithmIdentifier(DerObjectIdentifier objectID);
    public AlgorithmIdentifier(string objectID);
    public AlgorithmIdentifier(DerObjectIdentifier objectID, Asn1Encodable parameters);
    internal AlgorithmIdentifier(Asn1Sequence seq);
    public static AlgorithmIdentifier GetInstance(Asn1TaggedObject obj, bool explicitly);
    public static AlgorithmIdentifier GetInstance(object obj);
    public virtual DerObjectIdentifier get_ObjectID();
    public Asn1Encodable get_Parameters();
    public virtual Asn1Object ToAsn1Object();
}
public class Org.BouncyCastle.Asn1.X509.AttCertIssuer : Asn1Encodable {
    internal Asn1Encodable obj;
    internal Asn1Object choiceObj;
    public Asn1Encodable Issuer { get; }
    public AttCertIssuer(GeneralNames names);
    public AttCertIssuer(V2Form v2Form);
    public static AttCertIssuer GetInstance(object obj);
    public static AttCertIssuer GetInstance(Asn1TaggedObject obj, bool isExplicit);
    public Asn1Encodable get_Issuer();
    public virtual Asn1Object ToAsn1Object();
}
public class Org.BouncyCastle.Asn1.X509.AttCertValidityPeriod : Asn1Encodable {
    private DerGeneralizedTime notBeforeTime;
    private DerGeneralizedTime notAfterTime;
    public DerGeneralizedTime NotBeforeTime { get; }
    public DerGeneralizedTime NotAfterTime { get; }
    private AttCertValidityPeriod(Asn1Sequence seq);
    public AttCertValidityPeriod(DerGeneralizedTime notBeforeTime, DerGeneralizedTime notAfterTime);
    public static AttCertValidityPeriod GetInstance(object obj);
    public static AttCertValidityPeriod GetInstance(Asn1TaggedObject obj, bool explicitly);
    public DerGeneralizedTime get_NotBeforeTime();
    public DerGeneralizedTime get_NotAfterTime();
    public virtual Asn1Object ToAsn1Object();
}
public class Org.BouncyCastle.Asn1.X509.AttributeCertificate : Asn1Encodable {
    private AttributeCertificateInfo acinfo;
    private AlgorithmIdentifier signatureAlgorithm;
    private DerBitString signatureValue;
    public AttributeCertificateInfo ACInfo { get; }
    public AlgorithmIdentifier SignatureAlgorithm { get; }
    public DerBitString SignatureValue { get; }
    public AttributeCertificate(AttributeCertificateInfo acinfo, AlgorithmIdentifier signatureAlgorithm, DerBitString signatureValue);
    private AttributeCertificate(Asn1Sequence seq);
    public static AttributeCertificate GetInstance(object obj);
    public AttributeCertificateInfo get_ACInfo();
    public AlgorithmIdentifier get_SignatureAlgorithm();
    public DerBitString get_SignatureValue();
    public virtual Asn1Object ToAsn1Object();
}
public class Org.BouncyCastle.Asn1.X509.AttributeCertificateInfo : Asn1Encodable {
    internal DerInteger version;
    internal Holder holder;
    internal AttCertIssuer issuer;
    internal AlgorithmIdentifier signature;
    internal DerInteger serialNumber;
    internal AttCertValidityPeriod attrCertValidityPeriod;
    internal Asn1Sequence attributes;
    internal DerBitString issuerUniqueID;
    internal X509Extensions extensions;
    public DerInteger Version { get; }
    public Holder Holder { get; }
    public AttCertIssuer Issuer { get; }
    public AlgorithmIdentifier Signature { get; }
    public DerInteger SerialNumber { get; }
    public AttCertValidityPeriod AttrCertValidityPeriod { get; }
    public Asn1Sequence Attributes { get; }
    public DerBitString IssuerUniqueID { get; }
    public X509Extensions Extensions { get; }
    private AttributeCertificateInfo(Asn1Sequence seq);
    public static AttributeCertificateInfo GetInstance(Asn1TaggedObject obj, bool isExplicit);
    public static AttributeCertificateInfo GetInstance(object obj);
    public DerInteger get_Version();
    public Holder get_Holder();
    public AttCertIssuer get_Issuer();
    public AlgorithmIdentifier get_Signature();
    public DerInteger get_SerialNumber();
    public AttCertValidityPeriod get_AttrCertValidityPeriod();
    public Asn1Sequence get_Attributes();
    public DerBitString get_IssuerUniqueID();
    public X509Extensions get_Extensions();
    public virtual Asn1Object ToAsn1Object();
}
public class Org.BouncyCastle.Asn1.X509.AttributeTable : object {
    private IDictionary attributes;
    public AttributeTable(IDictionary attrs);
    [ObsoleteAttribute]
public AttributeTable(Hashtable attrs);
    public AttributeTable(Asn1EncodableVector v);
    public AttributeTable(Asn1Set s);
    public AttributeX509 Get(DerObjectIdentifier oid);
    [ObsoleteAttribute("Use 'ToDictionary' instead")]
public Hashtable ToHashtable();
    public IDictionary ToDictionary();
}
public class Org.BouncyCastle.Asn1.X509.AttributeX509 : Asn1Encodable {
    private DerObjectIdentifier attrType;
    private Asn1Set attrValues;
    public DerObjectIdentifier AttrType { get; }
    public Asn1Set AttrValues { get; }
    private AttributeX509(Asn1Sequence seq);
    public AttributeX509(DerObjectIdentifier attrType, Asn1Set attrValues);
    public static AttributeX509 GetInstance(object obj);
    public DerObjectIdentifier get_AttrType();
    public Asn1Encodable[] GetAttributeValues();
    public Asn1Set get_AttrValues();
    public virtual Asn1Object ToAsn1Object();
}
public class Org.BouncyCastle.Asn1.X509.AuthorityInformationAccess : Asn1Encodable {
    private AccessDescription[] descriptions;
    private AuthorityInformationAccess(Asn1Sequence seq);
    [ObsoleteAttribute("Use version taking an AccessDescription instead")]
public AuthorityInformationAccess(DerObjectIdentifier oid, GeneralName location);
    public AuthorityInformationAccess(AccessDescription description);
    public static AuthorityInformationAccess GetInstance(object obj);
    public AccessDescription[] GetAccessDescriptions();
    public virtual Asn1Object ToAsn1Object();
    public virtual string ToString();
}
public class Org.BouncyCastle.Asn1.X509.AuthorityKeyIdentifier : Asn1Encodable {
    internal Asn1OctetString keyidentifier;
    internal GeneralNames certissuer;
    internal DerInteger certserno;
    public GeneralNames AuthorityCertIssuer { get; }
    public BigInteger AuthorityCertSerialNumber { get; }
    protected internal AuthorityKeyIdentifier(Asn1Sequence seq);
    public AuthorityKeyIdentifier(SubjectPublicKeyInfo spki);
    public AuthorityKeyIdentifier(SubjectPublicKeyInfo spki, GeneralNames name, BigInteger serialNumber);
    public AuthorityKeyIdentifier(GeneralNames name, BigInteger serialNumber);
    public AuthorityKeyIdentifier(Byte[] keyIdentifier);
    public AuthorityKeyIdentifier(Byte[] keyIdentifier, GeneralNames name, BigInteger serialNumber);
    public static AuthorityKeyIdentifier GetInstance(Asn1TaggedObject obj, bool explicitly);
    public static AuthorityKeyIdentifier GetInstance(object obj);
    public Byte[] GetKeyIdentifier();
    public GeneralNames get_AuthorityCertIssuer();
    public BigInteger get_AuthorityCertSerialNumber();
    public virtual Asn1Object ToAsn1Object();
    public virtual string ToString();
}
public class Org.BouncyCastle.Asn1.X509.BasicConstraints : Asn1Encodable {
    private DerBoolean cA;
    private DerInteger pathLenConstraint;
    public BigInteger PathLenConstraint { get; }
    private BasicConstraints(Asn1Sequence seq);
    public BasicConstraints(bool cA);
    public BasicConstraints(int pathLenConstraint);
    public static BasicConstraints GetInstance(Asn1TaggedObject obj, bool explicitly);
    public static BasicConstraints GetInstance(object obj);
    public bool IsCA();
    public BigInteger get_PathLenConstraint();
    public virtual Asn1Object ToAsn1Object();
    public virtual string ToString();
}
public class Org.BouncyCastle.Asn1.X509.CertificateList : Asn1Encodable {
    private TbsCertificateList tbsCertList;
    private AlgorithmIdentifier sigAlgID;
    private DerBitString sig;
    public TbsCertificateList TbsCertList { get; }
    public AlgorithmIdentifier SignatureAlgorithm { get; }
    public DerBitString Signature { get; }
    public int Version { get; }
    public X509Name Issuer { get; }
    public Time ThisUpdate { get; }
    public Time NextUpdate { get; }
    private CertificateList(Asn1Sequence seq);
    public static CertificateList GetInstance(Asn1TaggedObject obj, bool explicitly);
    public static CertificateList GetInstance(object obj);
    public TbsCertificateList get_TbsCertList();
    public CrlEntry[] GetRevokedCertificates();
    public IEnumerable GetRevokedCertificateEnumeration();
    public AlgorithmIdentifier get_SignatureAlgorithm();
    public DerBitString get_Signature();
    public int get_Version();
    public X509Name get_Issuer();
    public Time get_ThisUpdate();
    public Time get_NextUpdate();
    public virtual Asn1Object ToAsn1Object();
}
public class Org.BouncyCastle.Asn1.X509.CertificatePair : Asn1Encodable {
    private X509CertificateStructure forward;
    private X509CertificateStructure reverse;
    public X509CertificateStructure Forward { get; }
    public X509CertificateStructure Reverse { get; }
    private CertificatePair(Asn1Sequence seq);
    public CertificatePair(X509CertificateStructure forward, X509CertificateStructure reverse);
    public static CertificatePair GetInstance(object obj);
    public virtual Asn1Object ToAsn1Object();
    public X509CertificateStructure get_Forward();
    public X509CertificateStructure get_Reverse();
}
public class Org.BouncyCastle.Asn1.X509.CertificatePolicies : Asn1Encodable {
    private PolicyInformation[] policyInformation;
    public CertificatePolicies(PolicyInformation name);
    public CertificatePolicies(PolicyInformation[] policyInformation);
    private CertificatePolicies(Asn1Sequence seq);
    public static CertificatePolicies GetInstance(object obj);
    public static CertificatePolicies GetInstance(Asn1TaggedObject obj, bool isExplicit);
    public virtual PolicyInformation[] GetPolicyInformation();
    public virtual Asn1Object ToAsn1Object();
    public virtual string ToString();
}
public class Org.BouncyCastle.Asn1.X509.CertPolicyID : DerObjectIdentifier {
    public CertPolicyID(string id);
}
public class Org.BouncyCastle.Asn1.X509.CrlDistPoint : Asn1Encodable {
    internal Asn1Sequence seq;
    private CrlDistPoint(Asn1Sequence seq);
    public CrlDistPoint(DistributionPoint[] points);
    public static CrlDistPoint GetInstance(Asn1TaggedObject obj, bool explicitly);
    public static CrlDistPoint GetInstance(object obj);
    public DistributionPoint[] GetDistributionPoints();
    public virtual Asn1Object ToAsn1Object();
    public virtual string ToString();
}
public class Org.BouncyCastle.Asn1.X509.CrlEntry : Asn1Encodable {
    internal Asn1Sequence seq;
    internal DerInteger userCertificate;
    internal Time revocationDate;
    internal X509Extensions crlEntryExtensions;
    public DerInteger UserCertificate { get; }
    public Time RevocationDate { get; }
    public X509Extensions Extensions { get; }
    public CrlEntry(Asn1Sequence seq);
    public DerInteger get_UserCertificate();
    public Time get_RevocationDate();
    public X509Extensions get_Extensions();
    public virtual Asn1Object ToAsn1Object();
}
public class Org.BouncyCastle.Asn1.X509.CrlNumber : DerInteger {
    public BigInteger Number { get; }
    public CrlNumber(BigInteger number);
    public BigInteger get_Number();
    public virtual string ToString();
}
public class Org.BouncyCastle.Asn1.X509.CrlReason : DerEnumerated {
    public static int Unspecified;
    public static int KeyCompromise;
    public static int CACompromise;
    public static int AffiliationChanged;
    public static int Superseded;
    public static int CessationOfOperation;
    public static int CertificateHold;
    public static int RemoveFromCrl;
    public static int PrivilegeWithdrawn;
    public static int AACompromise;
    private static String[] ReasonString;
    public CrlReason(int reason);
    public CrlReason(DerEnumerated reason);
    private static CrlReason();
    public virtual string ToString();
}
public class Org.BouncyCastle.Asn1.X509.DigestInfo : Asn1Encodable {
    private Byte[] digest;
    private AlgorithmIdentifier algID;
    public AlgorithmIdentifier AlgorithmID { get; }
    public DigestInfo(AlgorithmIdentifier algID, Byte[] digest);
    private DigestInfo(Asn1Sequence seq);
    public static DigestInfo GetInstance(Asn1TaggedObject obj, bool explicitly);
    public static DigestInfo GetInstance(object obj);
    public AlgorithmIdentifier get_AlgorithmID();
    public Byte[] GetDigest();
    public virtual Asn1Object ToAsn1Object();
}
public class Org.BouncyCastle.Asn1.X509.DisplayText : Asn1Encodable {
    public static int ContentTypeIA5String;
    public static int ContentTypeBmpString;
    public static int ContentTypeUtf8String;
    public static int ContentTypeVisibleString;
    public static int DisplayTextMaximumSize;
    internal int contentType;
    internal IAsn1String contents;
    public DisplayText(int type, string text);
    public DisplayText(string text);
    public DisplayText(IAsn1String contents);
    public static DisplayText GetInstance(object obj);
    public virtual Asn1Object ToAsn1Object();
    public string GetString();
}
public class Org.BouncyCastle.Asn1.X509.DistributionPoint : Asn1Encodable {
    internal DistributionPointName distributionPoint;
    internal ReasonFlags reasons;
    internal GeneralNames cRLIssuer;
    public DistributionPointName DistributionPointName { get; }
    public ReasonFlags Reasons { get; }
    public GeneralNames CrlIssuer { get; }
    private DistributionPoint(Asn1Sequence seq);
    public DistributionPoint(DistributionPointName distributionPointName, ReasonFlags reasons, GeneralNames crlIssuer);
    public static DistributionPoint GetInstance(Asn1TaggedObject obj, bool explicitly);
    public static DistributionPoint GetInstance(object obj);
    public DistributionPointName get_DistributionPointName();
    public ReasonFlags get_Reasons();
    public GeneralNames get_CrlIssuer();
    public virtual Asn1Object ToAsn1Object();
    public virtual string ToString();
    private void appendObject(StringBuilder buf, string sep, string name, string val);
}
public class Org.BouncyCastle.Asn1.X509.DistributionPointName : Asn1Encodable {
    public static int FullName;
    public static int NameRelativeToCrlIssuer;
    internal Asn1Encodable name;
    internal int type;
    public int PointType { get; }
    public Asn1Encodable Name { get; }
    public DistributionPointName(int type, Asn1Encodable name);
    public DistributionPointName(GeneralNames name);
    public DistributionPointName(Asn1TaggedObject obj);
    public static DistributionPointName GetInstance(Asn1TaggedObject obj, bool explicitly);
    public static DistributionPointName GetInstance(object obj);
    public int get_PointType();
    public Asn1Encodable get_Name();
    public virtual Asn1Object ToAsn1Object();
    public virtual string ToString();
    private void appendObject(StringBuilder buf, string sep, string name, string val);
}
public class Org.BouncyCastle.Asn1.X509.DsaParameter : Asn1Encodable {
    internal DerInteger p;
    internal DerInteger q;
    internal DerInteger g;
    public BigInteger P { get; }
    public BigInteger Q { get; }
    public BigInteger G { get; }
    public DsaParameter(BigInteger p, BigInteger q, BigInteger g);
    private DsaParameter(Asn1Sequence seq);
    public static DsaParameter GetInstance(Asn1TaggedObject obj, bool explicitly);
    public static DsaParameter GetInstance(object obj);
    public BigInteger get_P();
    public BigInteger get_Q();
    public BigInteger get_G();
    public virtual Asn1Object ToAsn1Object();
}
public class Org.BouncyCastle.Asn1.X509.ExtendedKeyUsage : Asn1Encodable {
    internal IDictionary usageTable;
    internal Asn1Sequence seq;
    public int Count { get; }
    private ExtendedKeyUsage(Asn1Sequence seq);
    public ExtendedKeyUsage(KeyPurposeID[] usages);
    [ObsoleteAttribute]
public ExtendedKeyUsage(ArrayList usages);
    public ExtendedKeyUsage(IEnumerable usages);
    public static ExtendedKeyUsage GetInstance(Asn1TaggedObject obj, bool explicitly);
    public static ExtendedKeyUsage GetInstance(object obj);
    public bool HasKeyPurposeId(KeyPurposeID keyPurposeId);
    [ObsoleteAttribute("Use 'GetAllUsages'")]
public ArrayList GetUsages();
    public IList GetAllUsages();
    public int get_Count();
    public virtual Asn1Object ToAsn1Object();
}
public class Org.BouncyCastle.Asn1.X509.GeneralName : Asn1Encodable {
    public static int OtherName;
    public static int Rfc822Name;
    public static int DnsName;
    public static int X400Address;
    public static int DirectoryName;
    public static int EdiPartyName;
    public static int UniformResourceIdentifier;
    public static int IPAddress;
    public static int RegisteredID;
    internal Asn1Encodable obj;
    internal int tag;
    public int TagNo { get; }
    public Asn1Encodable Name { get; }
    public GeneralName(X509Name directoryName);
    public GeneralName(Asn1Object name, int tag);
    public GeneralName(int tag, Asn1Encodable name);
    public GeneralName(int tag, string name);
    public static GeneralName GetInstance(object obj);
    public static GeneralName GetInstance(Asn1TaggedObject tagObj, bool explicitly);
    public int get_TagNo();
    public Asn1Encodable get_Name();
    public virtual string ToString();
    private Byte[] toGeneralNameEncoding(string ip);
    private void parseIPv4Mask(string mask, Byte[] addr, int offset);
    private void parseIPv4(string ip, Byte[] addr, int offset);
    private Int32[] parseMask(string mask);
    private void copyInts(Int32[] parsedIp, Byte[] addr, int offSet);
    private Int32[] parseIPv6(string ip);
    public virtual Asn1Object ToAsn1Object();
}
public class Org.BouncyCastle.Asn1.X509.GeneralNames : Asn1Encodable {
    private GeneralName[] names;
    public GeneralNames(GeneralName name);
    public GeneralNames(GeneralName[] names);
    private GeneralNames(Asn1Sequence seq);
    public static GeneralNames GetInstance(object obj);
    public static GeneralNames GetInstance(Asn1TaggedObject obj, bool explicitly);
    public GeneralName[] GetNames();
    public virtual Asn1Object ToAsn1Object();
    public virtual string ToString();
}
public class Org.BouncyCastle.Asn1.X509.GeneralSubtree : Asn1Encodable {
    private GeneralName baseName;
    private DerInteger minimum;
    private DerInteger maximum;
    public GeneralName Base { get; }
    public BigInteger Minimum { get; }
    public BigInteger Maximum { get; }
    private GeneralSubtree(Asn1Sequence seq);
    public GeneralSubtree(GeneralName baseName, BigInteger minimum, BigInteger maximum);
    public GeneralSubtree(GeneralName baseName);
    public static GeneralSubtree GetInstance(Asn1TaggedObject o, bool isExplicit);
    public static GeneralSubtree GetInstance(object obj);
    public GeneralName get_Base();
    public BigInteger get_Minimum();
    public BigInteger get_Maximum();
    public virtual Asn1Object ToAsn1Object();
}
public class Org.BouncyCastle.Asn1.X509.Holder : Asn1Encodable {
    internal IssuerSerial baseCertificateID;
    internal GeneralNames entityName;
    internal ObjectDigestInfo objectDigestInfo;
    private int version;
    public int Version { get; }
    public IssuerSerial BaseCertificateID { get; }
    public GeneralNames EntityName { get; }
    public ObjectDigestInfo ObjectDigestInfo { get; }
    public Holder(Asn1TaggedObject tagObj);
    private Holder(Asn1Sequence seq);
    public Holder(IssuerSerial baseCertificateID);
    public Holder(IssuerSerial baseCertificateID, int version);
    public Holder(GeneralNames entityName);
    public Holder(GeneralNames entityName, int version);
    public Holder(ObjectDigestInfo objectDigestInfo);
    public static Holder GetInstance(object obj);
    public int get_Version();
    public IssuerSerial get_BaseCertificateID();
    public GeneralNames get_EntityName();
    public ObjectDigestInfo get_ObjectDigestInfo();
    public virtual Asn1Object ToAsn1Object();
}
public class Org.BouncyCastle.Asn1.X509.IetfAttrSyntax : Asn1Encodable {
    public static int ValueOctets;
    public static int ValueOid;
    public static int ValueUtf8;
    internal GeneralNames policyAuthority;
    internal Asn1EncodableVector values;
    internal int valueChoice;
    public GeneralNames PolicyAuthority { get; }
    public int ValueType { get; }
    public IetfAttrSyntax(Asn1Sequence seq);
    public GeneralNames get_PolicyAuthority();
    public int get_ValueType();
    public Object[] GetValues();
    public virtual Asn1Object ToAsn1Object();
}
public class Org.BouncyCastle.Asn1.X509.IssuerSerial : Asn1Encodable {
    internal GeneralNames issuer;
    internal DerInteger serial;
    internal DerBitString issuerUid;
    public GeneralNames Issuer { get; }
    public DerInteger Serial { get; }
    public DerBitString IssuerUid { get; }
    private IssuerSerial(Asn1Sequence seq);
    public IssuerSerial(GeneralNames issuer, DerInteger serial);
    public static IssuerSerial GetInstance(object obj);
    public static IssuerSerial GetInstance(Asn1TaggedObject obj, bool explicitly);
    public GeneralNames get_Issuer();
    public DerInteger get_Serial();
    public DerBitString get_IssuerUid();
    public virtual Asn1Object ToAsn1Object();
}
public class Org.BouncyCastle.Asn1.X509.IssuingDistributionPoint : Asn1Encodable {
    private DistributionPointName _distributionPoint;
    private bool _onlyContainsUserCerts;
    private bool _onlyContainsCACerts;
    private ReasonFlags _onlySomeReasons;
    private bool _indirectCRL;
    private bool _onlyContainsAttributeCerts;
    private Asn1Sequence seq;
    public bool OnlyContainsUserCerts { get; }
    public bool OnlyContainsCACerts { get; }
    public bool IsIndirectCrl { get; }
    public bool OnlyContainsAttributeCerts { get; }
    public DistributionPointName DistributionPoint { get; }
    public ReasonFlags OnlySomeReasons { get; }
    public IssuingDistributionPoint(DistributionPointName distributionPoint, bool onlyContainsUserCerts, bool onlyContainsCACerts, ReasonFlags onlySomeReasons, bool indirectCRL, bool onlyContainsAttributeCerts);
    private IssuingDistributionPoint(Asn1Sequence seq);
    public static IssuingDistributionPoint GetInstance(Asn1TaggedObject obj, bool explicitly);
    public static IssuingDistributionPoint GetInstance(object obj);
    public bool get_OnlyContainsUserCerts();
    public bool get_OnlyContainsCACerts();
    public bool get_IsIndirectCrl();
    public bool get_OnlyContainsAttributeCerts();
    public DistributionPointName get_DistributionPoint();
    public ReasonFlags get_OnlySomeReasons();
    public virtual Asn1Object ToAsn1Object();
    public virtual string ToString();
    private void appendObject(StringBuilder buf, string sep, string name, string val);
}
public class Org.BouncyCastle.Asn1.X509.KeyPurposeID : DerObjectIdentifier {
    private static string IdKP;
    public static KeyPurposeID AnyExtendedKeyUsage;
    public static KeyPurposeID IdKPServerAuth;
    public static KeyPurposeID IdKPClientAuth;
    public static KeyPurposeID IdKPCodeSigning;
    public static KeyPurposeID IdKPEmailProtection;
    public static KeyPurposeID IdKPIpsecEndSystem;
    public static KeyPurposeID IdKPIpsecTunnel;
    public static KeyPurposeID IdKPIpsecUser;
    public static KeyPurposeID IdKPTimeStamping;
    public static KeyPurposeID IdKPOcspSigning;
    public static KeyPurposeID IdKPSmartCardLogon;
    private KeyPurposeID(string id);
    private static KeyPurposeID();
}
public class Org.BouncyCastle.Asn1.X509.KeyUsage : DerBitString {
    public static int DigitalSignature;
    public static int NonRepudiation;
    public static int KeyEncipherment;
    public static int DataEncipherment;
    public static int KeyAgreement;
    public static int KeyCertSign;
    public static int CrlSign;
    public static int EncipherOnly;
    public static int DecipherOnly;
    public KeyUsage(int usage);
    private KeyUsage(DerBitString usage);
    public static KeyUsage GetInstance(object obj);
    public virtual string ToString();
}
public class Org.BouncyCastle.Asn1.X509.NameConstraints : Asn1Encodable {
    private Asn1Sequence permitted;
    private Asn1Sequence excluded;
    public Asn1Sequence PermittedSubtrees { get; }
    public Asn1Sequence ExcludedSubtrees { get; }
    public NameConstraints(Asn1Sequence seq);
    public NameConstraints(ArrayList permitted, ArrayList excluded);
    public NameConstraints(IList permitted, IList excluded);
    public static NameConstraints GetInstance(object obj);
    private DerSequence CreateSequence(IList subtrees);
    public Asn1Sequence get_PermittedSubtrees();
    public Asn1Sequence get_ExcludedSubtrees();
    public virtual Asn1Object ToAsn1Object();
}
public class Org.BouncyCastle.Asn1.X509.NoticeReference : Asn1Encodable {
    internal DisplayText organization;
    internal Asn1Sequence noticeNumbers;
    [ObsoleteAttribute]
public NoticeReference(string orgName, ArrayList numbers);
    public NoticeReference(string orgName, IList numbers);
    public NoticeReference(string orgName, Asn1Sequence numbers);
    public NoticeReference(int displayTextType, string orgName, Asn1Sequence numbers);
    private NoticeReference(Asn1Sequence seq);
    public static NoticeReference GetInstance(object obj);
    public virtual Asn1Object ToAsn1Object();
}
public class Org.BouncyCastle.Asn1.X509.ObjectDigestInfo : Asn1Encodable {
    public static int PublicKey;
    public static int PublicKeyCert;
    public static int OtherObjectDigest;
    internal DerEnumerated digestedObjectType;
    internal DerObjectIdentifier otherObjectTypeID;
    internal AlgorithmIdentifier digestAlgorithm;
    internal DerBitString objectDigest;
    public DerEnumerated DigestedObjectType { get; }
    public DerObjectIdentifier OtherObjectTypeID { get; }
    public AlgorithmIdentifier DigestAlgorithm { get; }
    public DerBitString ObjectDigest { get; }
    public ObjectDigestInfo(int digestedObjectType, string otherObjectTypeID, AlgorithmIdentifier digestAlgorithm, Byte[] objectDigest);
    private ObjectDigestInfo(Asn1Sequence seq);
    public static ObjectDigestInfo GetInstance(object obj);
    public static ObjectDigestInfo GetInstance(Asn1TaggedObject obj, bool isExplicit);
    public DerEnumerated get_DigestedObjectType();
    public DerObjectIdentifier get_OtherObjectTypeID();
    public AlgorithmIdentifier get_DigestAlgorithm();
    public DerBitString get_ObjectDigest();
    public virtual Asn1Object ToAsn1Object();
}
public class Org.BouncyCastle.Asn1.X509.PolicyInformation : Asn1Encodable {
    private DerObjectIdentifier policyIdentifier;
    private Asn1Sequence policyQualifiers;
    public DerObjectIdentifier PolicyIdentifier { get; }
    public Asn1Sequence PolicyQualifiers { get; }
    private PolicyInformation(Asn1Sequence seq);
    public PolicyInformation(DerObjectIdentifier policyIdentifier);
    public PolicyInformation(DerObjectIdentifier policyIdentifier, Asn1Sequence policyQualifiers);
    public static PolicyInformation GetInstance(object obj);
    public DerObjectIdentifier get_PolicyIdentifier();
    public Asn1Sequence get_PolicyQualifiers();
    public virtual Asn1Object ToAsn1Object();
}
public class Org.BouncyCastle.Asn1.X509.PolicyMappings : Asn1Encodable {
    private Asn1Sequence seq;
    public PolicyMappings(Asn1Sequence seq);
    public PolicyMappings(Hashtable mappings);
    public PolicyMappings(IDictionary mappings);
    public virtual Asn1Object ToAsn1Object();
}
public class Org.BouncyCastle.Asn1.X509.PolicyQualifierID : DerObjectIdentifier {
    private static string IdQt;
    public static PolicyQualifierID IdQtCps;
    public static PolicyQualifierID IdQtUnotice;
    private PolicyQualifierID(string id);
    private static PolicyQualifierID();
}
public class Org.BouncyCastle.Asn1.X509.PolicyQualifierInfo : Asn1Encodable {
    internal DerObjectIdentifier policyQualifierId;
    internal Asn1Encodable qualifier;
    public DerObjectIdentifier PolicyQualifierId { get; }
    public Asn1Encodable Qualifier { get; }
    public PolicyQualifierInfo(DerObjectIdentifier policyQualifierId, Asn1Encodable qualifier);
    public PolicyQualifierInfo(string cps);
    private PolicyQualifierInfo(Asn1Sequence seq);
    public static PolicyQualifierInfo GetInstance(object obj);
    public virtual DerObjectIdentifier get_PolicyQualifierId();
    public virtual Asn1Encodable get_Qualifier();
    public virtual Asn1Object ToAsn1Object();
}
public class Org.BouncyCastle.Asn1.X509.PrivateKeyUsagePeriod : Asn1Encodable {
    private DerGeneralizedTime _notBefore;
    private DerGeneralizedTime _notAfter;
    public DerGeneralizedTime NotBefore { get; }
    public DerGeneralizedTime NotAfter { get; }
    private PrivateKeyUsagePeriod(Asn1Sequence seq);
    public static PrivateKeyUsagePeriod GetInstance(object obj);
    public DerGeneralizedTime get_NotBefore();
    public DerGeneralizedTime get_NotAfter();
    public virtual Asn1Object ToAsn1Object();
}
public class Org.BouncyCastle.Asn1.X509.Qualified.BiometricData : Asn1Encodable {
    private TypeOfBiometricData typeOfBiometricData;
    private AlgorithmIdentifier hashAlgorithm;
    private Asn1OctetString biometricDataHash;
    private DerIA5String sourceDataUri;
    public TypeOfBiometricData TypeOfBiometricData { get; }
    public AlgorithmIdentifier HashAlgorithm { get; }
    public Asn1OctetString BiometricDataHash { get; }
    public DerIA5String SourceDataUri { get; }
    private BiometricData(Asn1Sequence seq);
    public BiometricData(TypeOfBiometricData typeOfBiometricData, AlgorithmIdentifier hashAlgorithm, Asn1OctetString biometricDataHash, DerIA5String sourceDataUri);
    public BiometricData(TypeOfBiometricData typeOfBiometricData, AlgorithmIdentifier hashAlgorithm, Asn1OctetString biometricDataHash);
    public static BiometricData GetInstance(object obj);
    public TypeOfBiometricData get_TypeOfBiometricData();
    public AlgorithmIdentifier get_HashAlgorithm();
    public Asn1OctetString get_BiometricDataHash();
    public DerIA5String get_SourceDataUri();
    public virtual Asn1Object ToAsn1Object();
}
public abstract class Org.BouncyCastle.Asn1.X509.Qualified.EtsiQCObjectIdentifiers : object {
    public static DerObjectIdentifier IdEtsiQcs;
    public static DerObjectIdentifier IdEtsiQcsQcCompliance;
    public static DerObjectIdentifier IdEtsiQcsLimitValue;
    public static DerObjectIdentifier IdEtsiQcsRetentionPeriod;
    public static DerObjectIdentifier IdEtsiQcsQcSscd;
    private static EtsiQCObjectIdentifiers();
}
public class Org.BouncyCastle.Asn1.X509.Qualified.Iso4217CurrencyCode : Asn1Encodable {
    internal static int AlphabeticMaxSize;
    internal static int NumericMinSize;
    internal static int NumericMaxSize;
    internal Asn1Encodable obj;
    public bool IsAlphabetic { get; }
    public string Alphabetic { get; }
    public int Numeric { get; }
    public Iso4217CurrencyCode(int numeric);
    public Iso4217CurrencyCode(string alphabetic);
    public static Iso4217CurrencyCode GetInstance(object obj);
    public bool get_IsAlphabetic();
    public string get_Alphabetic();
    public int get_Numeric();
    public virtual Asn1Object ToAsn1Object();
}
public class Org.BouncyCastle.Asn1.X509.Qualified.MonetaryValue : Asn1Encodable {
    internal Iso4217CurrencyCode currency;
    internal DerInteger amount;
    internal DerInteger exponent;
    public Iso4217CurrencyCode Currency { get; }
    public BigInteger Amount { get; }
    public BigInteger Exponent { get; }
    private MonetaryValue(Asn1Sequence seq);
    public MonetaryValue(Iso4217CurrencyCode currency, int amount, int exponent);
    public static MonetaryValue GetInstance(object obj);
    public Iso4217CurrencyCode get_Currency();
    public BigInteger get_Amount();
    public BigInteger get_Exponent();
    public virtual Asn1Object ToAsn1Object();
}
public class Org.BouncyCastle.Asn1.X509.Qualified.QCStatement : Asn1Encodable {
    private DerObjectIdentifier qcStatementId;
    private Asn1Encodable qcStatementInfo;
    public DerObjectIdentifier StatementId { get; }
    public Asn1Encodable StatementInfo { get; }
    private QCStatement(Asn1Sequence seq);
    public QCStatement(DerObjectIdentifier qcStatementId);
    public QCStatement(DerObjectIdentifier qcStatementId, Asn1Encodable qcStatementInfo);
    public static QCStatement GetInstance(object obj);
    public DerObjectIdentifier get_StatementId();
    public Asn1Encodable get_StatementInfo();
    public virtual Asn1Object ToAsn1Object();
}
public class Org.BouncyCastle.Asn1.X509.Qualified.Rfc3739QCObjectIdentifiers : object {
    public static DerObjectIdentifier IdQcs;
    public static DerObjectIdentifier IdQcsPkixQCSyntaxV1;
    public static DerObjectIdentifier IdQcsPkixQCSyntaxV2;
    private static Rfc3739QCObjectIdentifiers();
}
public class Org.BouncyCastle.Asn1.X509.Qualified.SemanticsInformation : Asn1Encodable {
    private DerObjectIdentifier semanticsIdentifier;
    private GeneralName[] nameRegistrationAuthorities;
    public DerObjectIdentifier SemanticsIdentifier { get; }
    public SemanticsInformation(Asn1Sequence seq);
    public SemanticsInformation(DerObjectIdentifier semanticsIdentifier, GeneralName[] generalNames);
    public SemanticsInformation(DerObjectIdentifier semanticsIdentifier);
    public SemanticsInformation(GeneralName[] generalNames);
    public static SemanticsInformation GetInstance(object obj);
    public DerObjectIdentifier get_SemanticsIdentifier();
    public GeneralName[] GetNameRegistrationAuthorities();
    public virtual Asn1Object ToAsn1Object();
}
public class Org.BouncyCastle.Asn1.X509.Qualified.TypeOfBiometricData : Asn1Encodable {
    public static int Picture;
    public static int HandwrittenSignature;
    internal Asn1Encodable obj;
    public bool IsPredefined { get; }
    public int PredefinedBiometricType { get; }
    public DerObjectIdentifier BiometricDataOid { get; }
    public TypeOfBiometricData(int predefinedBiometricType);
    public TypeOfBiometricData(DerObjectIdentifier biometricDataOid);
    public static TypeOfBiometricData GetInstance(object obj);
    public bool get_IsPredefined();
    public int get_PredefinedBiometricType();
    public DerObjectIdentifier get_BiometricDataOid();
    public virtual Asn1Object ToAsn1Object();
}
public class Org.BouncyCastle.Asn1.X509.ReasonFlags : DerBitString {
    public static int Unused;
    public static int KeyCompromise;
    public static int CACompromise;
    public static int AffiliationChanged;
    public static int Superseded;
    public static int CessationOfOperation;
    public static int CertificateHold;
    public static int PrivilegeWithdrawn;
    public static int AACompromise;
    public ReasonFlags(int reasons);
    public ReasonFlags(DerBitString reasons);
}
public class Org.BouncyCastle.Asn1.X509.RoleSyntax : Asn1Encodable {
    private GeneralNames roleAuthority;
    private GeneralName roleName;
    public GeneralNames RoleAuthority { get; }
    public GeneralName RoleName { get; }
    public RoleSyntax(GeneralNames roleAuthority, GeneralName roleName);
    public RoleSyntax(GeneralName roleName);
    public RoleSyntax(string roleName);
    private RoleSyntax(Asn1Sequence seq);
    public static RoleSyntax GetInstance(object obj);
    public GeneralNames get_RoleAuthority();
    public GeneralName get_RoleName();
    public string GetRoleNameAsString();
    public String[] GetRoleAuthorityAsString();
    public virtual Asn1Object ToAsn1Object();
    public virtual string ToString();
}
public class Org.BouncyCastle.Asn1.X509.RsaPublicKeyStructure : Asn1Encodable {
    private BigInteger modulus;
    private BigInteger publicExponent;
    public BigInteger Modulus { get; }
    public BigInteger PublicExponent { get; }
    public RsaPublicKeyStructure(BigInteger modulus, BigInteger publicExponent);
    private RsaPublicKeyStructure(Asn1Sequence seq);
    public static RsaPublicKeyStructure GetInstance(Asn1TaggedObject obj, bool explicitly);
    public static RsaPublicKeyStructure GetInstance(object obj);
    public BigInteger get_Modulus();
    public BigInteger get_PublicExponent();
    public virtual Asn1Object ToAsn1Object();
}
public class Org.BouncyCastle.Asn1.X509.SigI.NameOrPseudonym : Asn1Encodable {
    private DirectoryString pseudonym;
    private DirectoryString surname;
    private Asn1Sequence givenName;
    public DirectoryString Pseudonym { get; }
    public DirectoryString Surname { get; }
    public NameOrPseudonym(DirectoryString pseudonym);
    private NameOrPseudonym(Asn1Sequence seq);
    public NameOrPseudonym(string pseudonym);
    public NameOrPseudonym(DirectoryString surname, Asn1Sequence givenName);
    public static NameOrPseudonym GetInstance(object obj);
    public DirectoryString get_Pseudonym();
    public DirectoryString get_Surname();
    public DirectoryString[] GetGivenName();
    public virtual Asn1Object ToAsn1Object();
}
public class Org.BouncyCastle.Asn1.X509.SigI.PersonalData : Asn1Encodable {
    private NameOrPseudonym nameOrPseudonym;
    private BigInteger nameDistinguisher;
    private DerGeneralizedTime dateOfBirth;
    private DirectoryString placeOfBirth;
    private string gender;
    private DirectoryString postalAddress;
    public NameOrPseudonym NameOrPseudonym { get; }
    public BigInteger NameDistinguisher { get; }
    public DerGeneralizedTime DateOfBirth { get; }
    public DirectoryString PlaceOfBirth { get; }
    public string Gender { get; }
    public DirectoryString PostalAddress { get; }
    private PersonalData(Asn1Sequence seq);
    public PersonalData(NameOrPseudonym nameOrPseudonym, BigInteger nameDistinguisher, DerGeneralizedTime dateOfBirth, DirectoryString placeOfBirth, string gender, DirectoryString postalAddress);
    public static PersonalData GetInstance(object obj);
    public NameOrPseudonym get_NameOrPseudonym();
    public BigInteger get_NameDistinguisher();
    public DerGeneralizedTime get_DateOfBirth();
    public DirectoryString get_PlaceOfBirth();
    public string get_Gender();
    public DirectoryString get_PostalAddress();
    public virtual Asn1Object ToAsn1Object();
}
public class Org.BouncyCastle.Asn1.X509.SigI.SigIObjectIdentifiers : object {
    public static DerObjectIdentifier IdSigI;
    public static DerObjectIdentifier IdSigIKP;
    public static DerObjectIdentifier IdSigICP;
    public static DerObjectIdentifier IdSigION;
    public static DerObjectIdentifier IdSigIKPDirectoryService;
    public static DerObjectIdentifier IdSigIONPersonalData;
    public static DerObjectIdentifier IdSigICPSigConform;
    private static SigIObjectIdentifiers();
}
public class Org.BouncyCastle.Asn1.X509.SubjectDirectoryAttributes : Asn1Encodable {
    private IList attributes;
    public IEnumerable Attributes { get; }
    private SubjectDirectoryAttributes(Asn1Sequence seq);
    [ObsoleteAttribute]
public SubjectDirectoryAttributes(ArrayList attributes);
    public SubjectDirectoryAttributes(IList attributes);
    public static SubjectDirectoryAttributes GetInstance(object obj);
    public virtual Asn1Object ToAsn1Object();
    public IEnumerable get_Attributes();
}
public class Org.BouncyCastle.Asn1.X509.SubjectKeyIdentifier : Asn1Encodable {
    private Byte[] keyIdentifier;
    public SubjectKeyIdentifier(Byte[] keyID);
    public SubjectKeyIdentifier(Asn1OctetString keyID);
    public SubjectKeyIdentifier(SubjectPublicKeyInfo spki);
    public static SubjectKeyIdentifier GetInstance(Asn1TaggedObject obj, bool explicitly);
    public static SubjectKeyIdentifier GetInstance(object obj);
    public Byte[] GetKeyIdentifier();
    public virtual Asn1Object ToAsn1Object();
    public static SubjectKeyIdentifier CreateSha1KeyIdentifier(SubjectPublicKeyInfo keyInfo);
    public static SubjectKeyIdentifier CreateTruncatedSha1KeyIdentifier(SubjectPublicKeyInfo keyInfo);
    private static Byte[] GetDigest(SubjectPublicKeyInfo spki);
}
public class Org.BouncyCastle.Asn1.X509.SubjectPublicKeyInfo : Asn1Encodable {
    private AlgorithmIdentifier algID;
    private DerBitString keyData;
    public AlgorithmIdentifier AlgorithmID { get; }
    public DerBitString PublicKeyData { get; }
    public SubjectPublicKeyInfo(AlgorithmIdentifier algID, Asn1Encodable publicKey);
    public SubjectPublicKeyInfo(AlgorithmIdentifier algID, Byte[] publicKey);
    private SubjectPublicKeyInfo(Asn1Sequence seq);
    public static SubjectPublicKeyInfo GetInstance(Asn1TaggedObject obj, bool explicitly);
    public static SubjectPublicKeyInfo GetInstance(object obj);
    public AlgorithmIdentifier get_AlgorithmID();
    public Asn1Object GetPublicKey();
    public DerBitString get_PublicKeyData();
    public virtual Asn1Object ToAsn1Object();
}
public class Org.BouncyCastle.Asn1.X509.Target : Asn1Encodable {
    private GeneralName targetName;
    private GeneralName targetGroup;
    public GeneralName TargetGroup { get; }
    public GeneralName TargetName { get; }
    private Target(Asn1TaggedObject tagObj);
    public Target(Choice type, GeneralName name);
    public static Target GetInstance(object obj);
    public virtual GeneralName get_TargetGroup();
    public virtual GeneralName get_TargetName();
    public virtual Asn1Object ToAsn1Object();
}
public class Org.BouncyCastle.Asn1.X509.TargetInformation : Asn1Encodable {
    private Asn1Sequence targets;
    private TargetInformation(Asn1Sequence targets);
    public TargetInformation(Targets targets);
    public TargetInformation(Target[] targets);
    public static TargetInformation GetInstance(object obj);
    public virtual Targets[] GetTargetsObjects();
    public virtual Asn1Object ToAsn1Object();
}
public class Org.BouncyCastle.Asn1.X509.Targets : Asn1Encodable {
    private Asn1Sequence targets;
    private Targets(Asn1Sequence targets);
    public Targets(Target[] targets);
    public static Targets GetInstance(object obj);
    public virtual Target[] GetTargets();
    public virtual Asn1Object ToAsn1Object();
}
public class Org.BouncyCastle.Asn1.X509.TbsCertificateList : Asn1Encodable {
    internal Asn1Sequence seq;
    internal DerInteger version;
    internal AlgorithmIdentifier signature;
    internal X509Name issuer;
    internal Time thisUpdate;
    internal Time nextUpdate;
    internal Asn1Sequence revokedCertificates;
    internal X509Extensions crlExtensions;
    public int Version { get; }
    public DerInteger VersionNumber { get; }
    public AlgorithmIdentifier Signature { get; }
    public X509Name Issuer { get; }
    public Time ThisUpdate { get; }
    public Time NextUpdate { get; }
    public X509Extensions Extensions { get; }
    internal TbsCertificateList(Asn1Sequence seq);
    public static TbsCertificateList GetInstance(Asn1TaggedObject obj, bool explicitly);
    public static TbsCertificateList GetInstance(object obj);
    public int get_Version();
    public DerInteger get_VersionNumber();
    public AlgorithmIdentifier get_Signature();
    public X509Name get_Issuer();
    public Time get_ThisUpdate();
    public Time get_NextUpdate();
    public CrlEntry[] GetRevokedCertificates();
    public IEnumerable GetRevokedCertificateEnumeration();
    public X509Extensions get_Extensions();
    public virtual Asn1Object ToAsn1Object();
}
public class Org.BouncyCastle.Asn1.X509.TbsCertificateStructure : Asn1Encodable {
    internal Asn1Sequence seq;
    internal DerInteger version;
    internal DerInteger serialNumber;
    internal AlgorithmIdentifier signature;
    internal X509Name issuer;
    internal Time startDate;
    internal Time endDate;
    internal X509Name subject;
    internal SubjectPublicKeyInfo subjectPublicKeyInfo;
    internal DerBitString issuerUniqueID;
    internal DerBitString subjectUniqueID;
    internal X509Extensions extensions;
    public int Version { get; }
    public DerInteger VersionNumber { get; }
    public DerInteger SerialNumber { get; }
    public AlgorithmIdentifier Signature { get; }
    public X509Name Issuer { get; }
    public Time StartDate { get; }
    public Time EndDate { get; }
    public X509Name Subject { get; }
    public SubjectPublicKeyInfo SubjectPublicKeyInfo { get; }
    public DerBitString IssuerUniqueID { get; }
    public DerBitString SubjectUniqueID { get; }
    public X509Extensions Extensions { get; }
    internal TbsCertificateStructure(Asn1Sequence seq);
    public static TbsCertificateStructure GetInstance(Asn1TaggedObject obj, bool explicitly);
    public static TbsCertificateStructure GetInstance(object obj);
    public int get_Version();
    public DerInteger get_VersionNumber();
    public DerInteger get_SerialNumber();
    public AlgorithmIdentifier get_Signature();
    public X509Name get_Issuer();
    public Time get_StartDate();
    public Time get_EndDate();
    public X509Name get_Subject();
    public SubjectPublicKeyInfo get_SubjectPublicKeyInfo();
    public DerBitString get_IssuerUniqueID();
    public DerBitString get_SubjectUniqueID();
    public X509Extensions get_Extensions();
    public virtual Asn1Object ToAsn1Object();
}
public class Org.BouncyCastle.Asn1.X509.Time : Asn1Encodable {
    internal Asn1Object time;
    public Time(Asn1Object time);
    public Time(DateTime date);
    public static Time GetInstance(Asn1TaggedObject obj, bool explicitly);
    public static Time GetInstance(object obj);
    public string GetTime();
    public DateTime ToDateTime();
    public virtual Asn1Object ToAsn1Object();
    public virtual string ToString();
}
public class Org.BouncyCastle.Asn1.X509.UserNotice : Asn1Encodable {
    internal NoticeReference noticeRef;
    internal DisplayText explicitText;
    public UserNotice(NoticeReference noticeRef, DisplayText explicitText);
    public UserNotice(NoticeReference noticeRef, string str);
    public UserNotice(Asn1Sequence seq);
    public virtual Asn1Object ToAsn1Object();
}
public class Org.BouncyCastle.Asn1.X509.V1TbsCertificateGenerator : object {
    internal DerTaggedObject version;
    internal DerInteger serialNumber;
    internal AlgorithmIdentifier signature;
    internal X509Name issuer;
    internal Time startDate;
    internal Time endDate;
    internal X509Name subject;
    internal SubjectPublicKeyInfo subjectPublicKeyInfo;
    public void SetSerialNumber(DerInteger serialNumber);
    public void SetSignature(AlgorithmIdentifier signature);
    public void SetIssuer(X509Name issuer);
    public void SetStartDate(Time startDate);
    public void SetStartDate(DerUtcTime startDate);
    public void SetEndDate(Time endDate);
    public void SetEndDate(DerUtcTime endDate);
    public void SetSubject(X509Name subject);
    public void SetSubjectPublicKeyInfo(SubjectPublicKeyInfo pubKeyInfo);
    public TbsCertificateStructure GenerateTbsCertificate();
}
public class Org.BouncyCastle.Asn1.X509.V2AttributeCertificateInfoGenerator : object {
    internal DerInteger version;
    internal Holder holder;
    internal AttCertIssuer issuer;
    internal AlgorithmIdentifier signature;
    internal DerInteger serialNumber;
    internal Asn1EncodableVector attributes;
    internal DerBitString issuerUniqueID;
    internal X509Extensions extensions;
    internal DerGeneralizedTime startDate;
    internal DerGeneralizedTime endDate;
    public void SetHolder(Holder holder);
    public void AddAttribute(string oid, Asn1Encodable value);
    public void AddAttribute(AttributeX509 attribute);
    public void SetSerialNumber(DerInteger serialNumber);
    public void SetSignature(AlgorithmIdentifier signature);
    public void SetIssuer(AttCertIssuer issuer);
    public void SetStartDate(DerGeneralizedTime startDate);
    public void SetEndDate(DerGeneralizedTime endDate);
    public void SetIssuerUniqueID(DerBitString issuerUniqueID);
    public void SetExtensions(X509Extensions extensions);
    public AttributeCertificateInfo GenerateAttributeCertificateInfo();
}
public class Org.BouncyCastle.Asn1.X509.V2Form : Asn1Encodable {
    internal GeneralNames issuerName;
    internal IssuerSerial baseCertificateID;
    internal ObjectDigestInfo objectDigestInfo;
    public GeneralNames IssuerName { get; }
    public IssuerSerial BaseCertificateID { get; }
    public ObjectDigestInfo ObjectDigestInfo { get; }
    public V2Form(GeneralNames issuerName);
    public V2Form(GeneralNames issuerName, IssuerSerial baseCertificateID);
    public V2Form(GeneralNames issuerName, ObjectDigestInfo objectDigestInfo);
    public V2Form(GeneralNames issuerName, IssuerSerial baseCertificateID, ObjectDigestInfo objectDigestInfo);
    private V2Form(Asn1Sequence seq);
    public static V2Form GetInstance(Asn1TaggedObject obj, bool explicitly);
    public static V2Form GetInstance(object obj);
    public GeneralNames get_IssuerName();
    public IssuerSerial get_BaseCertificateID();
    public ObjectDigestInfo get_ObjectDigestInfo();
    public virtual Asn1Object ToAsn1Object();
}
public class Org.BouncyCastle.Asn1.X509.V2TbsCertListGenerator : object {
    private DerInteger version;
    private AlgorithmIdentifier signature;
    private X509Name issuer;
    private Time thisUpdate;
    private Time nextUpdate;
    private X509Extensions extensions;
    private IList crlEntries;
    public void SetSignature(AlgorithmIdentifier signature);
    public void SetIssuer(X509Name issuer);
    public void SetThisUpdate(DerUtcTime thisUpdate);
    public void SetNextUpdate(DerUtcTime nextUpdate);
    public void SetThisUpdate(Time thisUpdate);
    public void SetNextUpdate(Time nextUpdate);
    public void AddCrlEntry(Asn1Sequence crlEntry);
    public void AddCrlEntry(DerInteger userCertificate, DerUtcTime revocationDate, int reason);
    public void AddCrlEntry(DerInteger userCertificate, Time revocationDate, int reason);
    public void AddCrlEntry(DerInteger userCertificate, Time revocationDate, int reason, DerGeneralizedTime invalidityDate);
    public void AddCrlEntry(DerInteger userCertificate, Time revocationDate, X509Extensions extensions);
    public void SetExtensions(X509Extensions extensions);
    public TbsCertificateList GenerateTbsCertList();
}
public class Org.BouncyCastle.Asn1.X509.V3TbsCertificateGenerator : object {
    internal DerTaggedObject version;
    internal DerInteger serialNumber;
    internal AlgorithmIdentifier signature;
    internal X509Name issuer;
    internal Time startDate;
    internal Time endDate;
    internal X509Name subject;
    internal SubjectPublicKeyInfo subjectPublicKeyInfo;
    internal X509Extensions extensions;
    private bool altNamePresentAndCritical;
    private DerBitString issuerUniqueID;
    private DerBitString subjectUniqueID;
    public void SetSerialNumber(DerInteger serialNumber);
    public void SetSignature(AlgorithmIdentifier signature);
    public void SetIssuer(X509Name issuer);
    public void SetStartDate(DerUtcTime startDate);
    public void SetStartDate(Time startDate);
    public void SetEndDate(DerUtcTime endDate);
    public void SetEndDate(Time endDate);
    public void SetSubject(X509Name subject);
    public void SetIssuerUniqueID(DerBitString uniqueID);
    public void SetSubjectUniqueID(DerBitString uniqueID);
    public void SetSubjectPublicKeyInfo(SubjectPublicKeyInfo pubKeyInfo);
    public void SetExtensions(X509Extensions extensions);
    public TbsCertificateStructure GenerateTbsCertificate();
}
public class Org.BouncyCastle.Asn1.X509.X509Attributes : object {
    public static DerObjectIdentifier RoleSyntax;
    private static X509Attributes();
}
public class Org.BouncyCastle.Asn1.X509.X509CertificateStructure : Asn1Encodable {
    private TbsCertificateStructure tbsCert;
    private AlgorithmIdentifier sigAlgID;
    private DerBitString sig;
    public TbsCertificateStructure TbsCertificate { get; }
    public int Version { get; }
    public DerInteger SerialNumber { get; }
    public X509Name Issuer { get; }
    public Time StartDate { get; }
    public Time EndDate { get; }
    public X509Name Subject { get; }
    public SubjectPublicKeyInfo SubjectPublicKeyInfo { get; }
    public AlgorithmIdentifier SignatureAlgorithm { get; }
    public DerBitString Signature { get; }
    public X509CertificateStructure(TbsCertificateStructure tbsCert, AlgorithmIdentifier sigAlgID, DerBitString sig);
    private X509CertificateStructure(Asn1Sequence seq);
    public static X509CertificateStructure GetInstance(Asn1TaggedObject obj, bool explicitly);
    public static X509CertificateStructure GetInstance(object obj);
    public TbsCertificateStructure get_TbsCertificate();
    public int get_Version();
    public DerInteger get_SerialNumber();
    public X509Name get_Issuer();
    public Time get_StartDate();
    public Time get_EndDate();
    public X509Name get_Subject();
    public SubjectPublicKeyInfo get_SubjectPublicKeyInfo();
    public AlgorithmIdentifier get_SignatureAlgorithm();
    public DerBitString get_Signature();
    public virtual Asn1Object ToAsn1Object();
}
public class Org.BouncyCastle.Asn1.X509.X509DefaultEntryConverter : X509NameEntryConverter {
    public virtual Asn1Object GetConvertedValue(DerObjectIdentifier oid, string value);
}
public class Org.BouncyCastle.Asn1.X509.X509Extension : object {
    internal bool critical;
    internal Asn1OctetString value;
    public bool IsCritical { get; }
    public Asn1OctetString Value { get; }
    public X509Extension(DerBoolean critical, Asn1OctetString value);
    public X509Extension(bool critical, Asn1OctetString value);
    public bool get_IsCritical();
    public Asn1OctetString get_Value();
    public Asn1Encodable GetParsedValue();
    public virtual int GetHashCode();
    public virtual bool Equals(object obj);
    public static Asn1Object ConvertValueToObject(X509Extension ext);
}
public class Org.BouncyCastle.Asn1.X509.X509Extensions : Asn1Encodable {
    public static DerObjectIdentifier SubjectDirectoryAttributes;
    public static DerObjectIdentifier SubjectKeyIdentifier;
    public static DerObjectIdentifier KeyUsage;
    public static DerObjectIdentifier PrivateKeyUsagePeriod;
    public static DerObjectIdentifier SubjectAlternativeName;
    public static DerObjectIdentifier IssuerAlternativeName;
    public static DerObjectIdentifier BasicConstraints;
    public static DerObjectIdentifier CrlNumber;
    public static DerObjectIdentifier ReasonCode;
    public static DerObjectIdentifier InstructionCode;
    public static DerObjectIdentifier InvalidityDate;
    public static DerObjectIdentifier DeltaCrlIndicator;
    public static DerObjectIdentifier IssuingDistributionPoint;
    public static DerObjectIdentifier CertificateIssuer;
    public static DerObjectIdentifier NameConstraints;
    public static DerObjectIdentifier CrlDistributionPoints;
    public static DerObjectIdentifier CertificatePolicies;
    public static DerObjectIdentifier PolicyMappings;
    public static DerObjectIdentifier AuthorityKeyIdentifier;
    public static DerObjectIdentifier PolicyConstraints;
    public static DerObjectIdentifier ExtendedKeyUsage;
    public static DerObjectIdentifier FreshestCrl;
    public static DerObjectIdentifier InhibitAnyPolicy;
    public static DerObjectIdentifier AuthorityInfoAccess;
    public static DerObjectIdentifier SubjectInfoAccess;
    public static DerObjectIdentifier LogoType;
    public static DerObjectIdentifier BiometricInfo;
    public static DerObjectIdentifier QCStatements;
    public static DerObjectIdentifier AuditIdentity;
    public static DerObjectIdentifier NoRevAvail;
    public static DerObjectIdentifier TargetInformation;
    private IDictionary extensions;
    private IList ordering;
    public IEnumerable ExtensionOids { get; }
    private X509Extensions(Asn1Sequence seq);
    public X509Extensions(IDictionary extensions);
    public X509Extensions(IList ordering, IDictionary extensions);
    public X509Extensions(IList oids, IList values);
    [ObsoleteAttribute]
public X509Extensions(Hashtable extensions);
    [ObsoleteAttribute]
public X509Extensions(ArrayList ordering, Hashtable extensions);
    [ObsoleteAttribute]
public X509Extensions(ArrayList oids, ArrayList values);
    private static X509Extensions();
    public static X509Extensions GetInstance(Asn1TaggedObject obj, bool explicitly);
    public static X509Extensions GetInstance(object obj);
    [ObsoleteAttribute("Use ExtensionOids IEnumerable property")]
public IEnumerator Oids();
    public IEnumerable get_ExtensionOids();
    public X509Extension GetExtension(DerObjectIdentifier oid);
    public virtual Asn1Object ToAsn1Object();
    public bool Equivalent(X509Extensions other);
    public DerObjectIdentifier[] GetExtensionOids();
    public DerObjectIdentifier[] GetNonCriticalExtensionOids();
    public DerObjectIdentifier[] GetCriticalExtensionOids();
    private DerObjectIdentifier[] GetExtensionOids(bool isCritical);
    private static DerObjectIdentifier[] ToOidArray(IList oids);
}
public class Org.BouncyCastle.Asn1.X509.X509ExtensionsGenerator : object {
    private IDictionary extensions;
    private IList extOrdering;
    public bool IsEmpty { get; }
    public void Reset();
    public void AddExtension(DerObjectIdentifier oid, bool critical, Asn1Encodable extValue);
    public void AddExtension(DerObjectIdentifier oid, bool critical, Byte[] extValue);
    public bool get_IsEmpty();
    public X509Extensions Generate();
}
public class Org.BouncyCastle.Asn1.X509.X509Name : Asn1Encodable {
    public static DerObjectIdentifier C;
    public static DerObjectIdentifier O;
    public static DerObjectIdentifier OU;
    public static DerObjectIdentifier T;
    public static DerObjectIdentifier CN;
    public static DerObjectIdentifier Street;
    public static DerObjectIdentifier SerialNumber;
    public static DerObjectIdentifier L;
    public static DerObjectIdentifier ST;
    public static DerObjectIdentifier Surname;
    public static DerObjectIdentifier GivenName;
    public static DerObjectIdentifier Initials;
    public static DerObjectIdentifier Generation;
    public static DerObjectIdentifier UniqueIdentifier;
    public static DerObjectIdentifier BusinessCategory;
    public static DerObjectIdentifier PostalCode;
    public static DerObjectIdentifier DnQualifier;
    public static DerObjectIdentifier Pseudonym;
    public static DerObjectIdentifier DateOfBirth;
    public static DerObjectIdentifier PlaceOfBirth;
    public static DerObjectIdentifier Gender;
    public static DerObjectIdentifier CountryOfCitizenship;
    public static DerObjectIdentifier CountryOfResidence;
    public static DerObjectIdentifier NameAtBirth;
    public static DerObjectIdentifier PostalAddress;
    public static DerObjectIdentifier DmdName;
    public static DerObjectIdentifier TelephoneNumber;
    public static DerObjectIdentifier Name;
    public static DerObjectIdentifier EmailAddress;
    public static DerObjectIdentifier UnstructuredName;
    public static DerObjectIdentifier UnstructuredAddress;
    public static DerObjectIdentifier E;
    public static DerObjectIdentifier DC;
    public static DerObjectIdentifier UID;
    private static Boolean[] defaultReverse;
    public static Hashtable DefaultSymbols;
    public static Hashtable RFC2253Symbols;
    public static Hashtable RFC1779Symbols;
    public static Hashtable DefaultLookup;
    private IList ordering;
    private X509NameEntryConverter converter;
    private IList values;
    private IList added;
    private Asn1Sequence seq;
    public static bool DefaultReverse { get; public set; }
    private static X509Name();
    protected X509Name(Asn1Sequence seq);
    [ObsoleteAttribute]
public X509Name(ArrayList ordering, Hashtable attributes);
    public X509Name(IList ordering, IDictionary attributes);
    [ObsoleteAttribute]
public X509Name(ArrayList ordering, Hashtable attributes, X509NameEntryConverter converter);
    public X509Name(IList ordering, IDictionary attributes, X509NameEntryConverter converter);
    [ObsoleteAttribute]
public X509Name(ArrayList oids, ArrayList values);
    public X509Name(IList oids, IList values);
    [ObsoleteAttribute]
public X509Name(ArrayList oids, ArrayList values, X509NameEntryConverter converter);
    public X509Name(IList oids, IList values, X509NameEntryConverter converter);
    public X509Name(string dirName);
    public X509Name(string dirName, X509NameEntryConverter converter);
    public X509Name(bool reverse, string dirName);
    public X509Name(bool reverse, string dirName, X509NameEntryConverter converter);
    [ObsoleteAttribute]
public X509Name(bool reverse, Hashtable lookUp, string dirName);
    public X509Name(bool reverse, IDictionary lookUp, string dirName);
    public X509Name(bool reverse, IDictionary lookUp, string dirName, X509NameEntryConverter converter);
    public static bool get_DefaultReverse();
    public static void set_DefaultReverse(bool value);
    public static X509Name GetInstance(Asn1TaggedObject obj, bool explicitly);
    public static X509Name GetInstance(object obj);
    private DerObjectIdentifier DecodeOid(string name, IDictionary lookUp);
    [ObsoleteAttribute("Use 'GetOidList' instead")]
public ArrayList GetOids();
    public IList GetOidList();
    [ObsoleteAttribute("Use 'GetValueList' instead")]
public ArrayList GetValues();
    public IList GetValueList();
    public ArrayList GetValues(DerObjectIdentifier oid);
    public IList GetValueList(DerObjectIdentifier oid);
    private void DoGetValueList(DerObjectIdentifier oid, IList v);
    public virtual Asn1Object ToAsn1Object();
    public bool Equivalent(X509Name other, bool inOrder);
    public bool Equivalent(X509Name other);
    private static bool equivalentStrings(string s1, string s2);
    private static string canonicalize(string s);
    private static Asn1Object decodeObject(string v);
    private static string stripInternalSpaces(string str);
    private void AppendValue(StringBuilder buf, IDictionary oidSymbols, DerObjectIdentifier oid, string val);
    [ObsoleteAttribute]
public string ToString(bool reverse, Hashtable oidSymbols);
    public string ToString(bool reverse, IDictionary oidSymbols);
    public virtual string ToString();
}
public abstract class Org.BouncyCastle.Asn1.X509.X509NameEntryConverter : object {
    protected Asn1Object ConvertHexEncoded(string hexString, int offset);
    protected bool CanBePrintable(string str);
    public abstract virtual Asn1Object GetConvertedValue(DerObjectIdentifier oid, string value);
}
public class Org.BouncyCastle.Asn1.X509.X509NameTokenizer : object {
    private string value;
    private int index;
    private char separator;
    private StringBuilder buffer;
    public X509NameTokenizer(string oid);
    public X509NameTokenizer(string oid, char separator);
    public bool HasMoreTokens();
    public string NextToken();
}
public abstract class Org.BouncyCastle.Asn1.X509.X509ObjectIdentifiers : object {
    internal static string ID;
    public static DerObjectIdentifier CommonName;
    public static DerObjectIdentifier CountryName;
    public static DerObjectIdentifier LocalityName;
    public static DerObjectIdentifier StateOrProvinceName;
    public static DerObjectIdentifier Organization;
    public static DerObjectIdentifier OrganizationalUnitName;
    public static DerObjectIdentifier id_at_telephoneNumber;
    public static DerObjectIdentifier id_at_name;
    public static DerObjectIdentifier IdSha1;
    public static DerObjectIdentifier RipeMD160;
    public static DerObjectIdentifier RipeMD160WithRsaEncryption;
    public static DerObjectIdentifier IdEARsa;
    public static DerObjectIdentifier IdPkix;
    public static DerObjectIdentifier IdPE;
    public static DerObjectIdentifier IdAD;
    public static DerObjectIdentifier IdADCAIssuers;
    public static DerObjectIdentifier IdADOcsp;
    public static DerObjectIdentifier OcspAccessMethod;
    public static DerObjectIdentifier CrlAccessMethod;
    private static X509ObjectIdentifiers();
}
public class Org.BouncyCastle.Asn1.X9.DHDomainParameters : Asn1Encodable {
    private DerInteger p;
    private DerInteger g;
    private DerInteger q;
    private DerInteger j;
    private DHValidationParms validationParms;
    public DerInteger P { get; }
    public DerInteger G { get; }
    public DerInteger Q { get; }
    public DerInteger J { get; }
    public DHValidationParms ValidationParms { get; }
    public DHDomainParameters(DerInteger p, DerInteger g, DerInteger q, DerInteger j, DHValidationParms validationParms);
    private DHDomainParameters(Asn1Sequence seq);
    public static DHDomainParameters GetInstance(Asn1TaggedObject obj, bool isExplicit);
    public static DHDomainParameters GetInstance(object obj);
    private static Asn1Encodable GetNext(IEnumerator e);
    public DerInteger get_P();
    public DerInteger get_G();
    public DerInteger get_Q();
    public DerInteger get_J();
    public DHValidationParms get_ValidationParms();
    public virtual Asn1Object ToAsn1Object();
}
public class Org.BouncyCastle.Asn1.X9.DHPublicKey : Asn1Encodable {
    private DerInteger y;
    public DerInteger Y { get; }
    public DHPublicKey(DerInteger y);
    public static DHPublicKey GetInstance(Asn1TaggedObject obj, bool isExplicit);
    public static DHPublicKey GetInstance(object obj);
    public DerInteger get_Y();
    public virtual Asn1Object ToAsn1Object();
}
public class Org.BouncyCastle.Asn1.X9.DHValidationParms : Asn1Encodable {
    private DerBitString seed;
    private DerInteger pgenCounter;
    public DerBitString Seed { get; }
    public DerInteger PgenCounter { get; }
    public DHValidationParms(DerBitString seed, DerInteger pgenCounter);
    private DHValidationParms(Asn1Sequence seq);
    public static DHValidationParms GetInstance(Asn1TaggedObject obj, bool isExplicit);
    public static DHValidationParms GetInstance(object obj);
    public DerBitString get_Seed();
    public DerInteger get_PgenCounter();
    public virtual Asn1Object ToAsn1Object();
}
public class Org.BouncyCastle.Asn1.X9.KeySpecificInfo : Asn1Encodable {
    private DerObjectIdentifier algorithm;
    private Asn1OctetString counter;
    public DerObjectIdentifier Algorithm { get; }
    public Asn1OctetString Counter { get; }
    public KeySpecificInfo(DerObjectIdentifier algorithm, Asn1OctetString counter);
    public KeySpecificInfo(Asn1Sequence seq);
    public DerObjectIdentifier get_Algorithm();
    public Asn1OctetString get_Counter();
    public virtual Asn1Object ToAsn1Object();
}
public class Org.BouncyCastle.Asn1.X9.OtherInfo : Asn1Encodable {
    private KeySpecificInfo keyInfo;
    private Asn1OctetString partyAInfo;
    private Asn1OctetString suppPubInfo;
    public KeySpecificInfo KeyInfo { get; }
    public Asn1OctetString PartyAInfo { get; }
    public Asn1OctetString SuppPubInfo { get; }
    public OtherInfo(KeySpecificInfo keyInfo, Asn1OctetString partyAInfo, Asn1OctetString suppPubInfo);
    public OtherInfo(Asn1Sequence seq);
    public KeySpecificInfo get_KeyInfo();
    public Asn1OctetString get_PartyAInfo();
    public Asn1OctetString get_SuppPubInfo();
    public virtual Asn1Object ToAsn1Object();
}
public class Org.BouncyCastle.Asn1.X9.X962NamedCurves : object {
    private static IDictionary objIds;
    private static IDictionary curves;
    private static IDictionary names;
    public static IEnumerable Names { get; }
    private static X962NamedCurves();
    private static void DefineCurve(string name, DerObjectIdentifier oid, X9ECParametersHolder holder);
    public static X9ECParameters GetByName(string name);
    public static X9ECParameters GetByOid(DerObjectIdentifier oid);
    public static DerObjectIdentifier GetOid(string name);
    public static string GetName(DerObjectIdentifier oid);
    public static IEnumerable get_Names();
}
public class Org.BouncyCastle.Asn1.X9.X962Parameters : Asn1Encodable {
    private Asn1Object _params;
    public bool IsNamedCurve { get; }
    public Asn1Object Parameters { get; }
    public X962Parameters(X9ECParameters ecParameters);
    public X962Parameters(DerObjectIdentifier namedCurve);
    public X962Parameters(Asn1Object obj);
    public bool get_IsNamedCurve();
    public Asn1Object get_Parameters();
    public virtual Asn1Object ToAsn1Object();
}
public class Org.BouncyCastle.Asn1.X9.X9Curve : Asn1Encodable {
    private ECCurve curve;
    private Byte[] seed;
    private DerObjectIdentifier fieldIdentifier;
    public ECCurve Curve { get; }
    public X9Curve(ECCurve curve);
    public X9Curve(ECCurve curve, Byte[] seed);
    public X9Curve(X9FieldID fieldID, Asn1Sequence seq);
    public ECCurve get_Curve();
    public Byte[] GetSeed();
    public virtual Asn1Object ToAsn1Object();
}
public class Org.BouncyCastle.Asn1.X9.X9ECParameters : Asn1Encodable {
    private X9FieldID fieldID;
    private ECCurve curve;
    private ECPoint g;
    private BigInteger n;
    private BigInteger h;
    private Byte[] seed;
    public ECCurve Curve { get; }
    public ECPoint G { get; }
    public BigInteger N { get; }
    public BigInteger H { get; }
    public X9ECParameters(Asn1Sequence seq);
    public X9ECParameters(ECCurve curve, ECPoint g, BigInteger n);
    public X9ECParameters(ECCurve curve, ECPoint g, BigInteger n, BigInteger h);
    public X9ECParameters(ECCurve curve, ECPoint g, BigInteger n, BigInteger h, Byte[] seed);
    public ECCurve get_Curve();
    public ECPoint get_G();
    public BigInteger get_N();
    public BigInteger get_H();
    public Byte[] GetSeed();
    public virtual Asn1Object ToAsn1Object();
}
public abstract class Org.BouncyCastle.Asn1.X9.X9ECParametersHolder : object {
    private X9ECParameters parameters;
    public X9ECParameters Parameters { get; }
    public X9ECParameters get_Parameters();
    protected abstract virtual X9ECParameters CreateParameters();
}
public class Org.BouncyCastle.Asn1.X9.X9ECPoint : Asn1Encodable {
    private ECPoint p;
    public ECPoint Point { get; }
    public X9ECPoint(ECPoint p);
    public X9ECPoint(ECCurve c, Asn1OctetString s);
    public ECPoint get_Point();
    public virtual Asn1Object ToAsn1Object();
}
public class Org.BouncyCastle.Asn1.X9.X9FieldElement : Asn1Encodable {
    private ECFieldElement f;
    public ECFieldElement Value { get; }
    public X9FieldElement(ECFieldElement f);
    public X9FieldElement(BigInteger p, Asn1OctetString s);
    public X9FieldElement(int m, int k1, int k2, int k3, Asn1OctetString s);
    public ECFieldElement get_Value();
    public virtual Asn1Object ToAsn1Object();
}
public class Org.BouncyCastle.Asn1.X9.X9FieldID : Asn1Encodable {
    private DerObjectIdentifier id;
    private Asn1Object parameters;
    public DerObjectIdentifier Identifier { get; }
    public Asn1Object Parameters { get; }
    public X9FieldID(BigInteger primeP);
    public X9FieldID(int m, int k1, int k2, int k3);
    internal X9FieldID(Asn1Sequence seq);
    public DerObjectIdentifier get_Identifier();
    public Asn1Object get_Parameters();
    public virtual Asn1Object ToAsn1Object();
}
public class Org.BouncyCastle.Asn1.X9.X9IntegerConverter : object {
    public static int GetByteLength(ECFieldElement fe);
    public static int GetByteLength(ECCurve c);
    public static Byte[] IntegerToBytes(BigInteger s, int qLength);
}
public abstract class Org.BouncyCastle.Asn1.X9.X9ObjectIdentifiers : object {
    internal static string AnsiX962;
    [ObsoleteAttribute("Use 'id_ecSigType' instead")]
public static string IdECSigType;
    [ObsoleteAttribute("Use 'id_publicKeyType' instead")]
public static string IdPublicKeyType;
    public static DerObjectIdentifier ansi_X9_62;
    public static DerObjectIdentifier IdFieldType;
    public static DerObjectIdentifier PrimeField;
    public static DerObjectIdentifier CharacteristicTwoField;
    public static DerObjectIdentifier GNBasis;
    public static DerObjectIdentifier TPBasis;
    public static DerObjectIdentifier PPBasis;
    public static DerObjectIdentifier id_ecSigType;
    public static DerObjectIdentifier ECDsaWithSha1;
    public static DerObjectIdentifier id_publicKeyType;
    public static DerObjectIdentifier IdECPublicKey;
    public static DerObjectIdentifier ECDsaWithSha2;
    public static DerObjectIdentifier ECDsaWithSha224;
    public static DerObjectIdentifier ECDsaWithSha256;
    public static DerObjectIdentifier ECDsaWithSha384;
    public static DerObjectIdentifier ECDsaWithSha512;
    public static DerObjectIdentifier EllipticCurve;
    public static DerObjectIdentifier CTwoCurve;
    public static DerObjectIdentifier C2Pnb163v1;
    public static DerObjectIdentifier C2Pnb163v2;
    public static DerObjectIdentifier C2Pnb163v3;
    public static DerObjectIdentifier C2Pnb176w1;
    public static DerObjectIdentifier C2Tnb191v1;
    public static DerObjectIdentifier C2Tnb191v2;
    public static DerObjectIdentifier C2Tnb191v3;
    public static DerObjectIdentifier C2Onb191v4;
    public static DerObjectIdentifier C2Onb191v5;
    public static DerObjectIdentifier C2Pnb208w1;
    public static DerObjectIdentifier C2Tnb239v1;
    public static DerObjectIdentifier C2Tnb239v2;
    public static DerObjectIdentifier C2Tnb239v3;
    public static DerObjectIdentifier C2Onb239v4;
    public static DerObjectIdentifier C2Onb239v5;
    public static DerObjectIdentifier C2Pnb272w1;
    public static DerObjectIdentifier C2Pnb304w1;
    public static DerObjectIdentifier C2Tnb359v1;
    public static DerObjectIdentifier C2Pnb368w1;
    public static DerObjectIdentifier C2Tnb431r1;
    public static DerObjectIdentifier PrimeCurve;
    public static DerObjectIdentifier Prime192v1;
    public static DerObjectIdentifier Prime192v2;
    public static DerObjectIdentifier Prime192v3;
    public static DerObjectIdentifier Prime239v1;
    public static DerObjectIdentifier Prime239v2;
    public static DerObjectIdentifier Prime239v3;
    public static DerObjectIdentifier Prime256v1;
    public static DerObjectIdentifier IdDsa;
    public static DerObjectIdentifier IdDsaWithSha1;
    public static DerObjectIdentifier X9x63Scheme;
    public static DerObjectIdentifier DHSinglePassStdDHSha1KdfScheme;
    public static DerObjectIdentifier DHSinglePassCofactorDHSha1KdfScheme;
    public static DerObjectIdentifier MqvSinglePassSha1KdfScheme;
    public static DerObjectIdentifier ansi_x9_42;
    public static DerObjectIdentifier DHPublicNumber;
    public static DerObjectIdentifier X9x42Schemes;
    public static DerObjectIdentifier DHStatic;
    public static DerObjectIdentifier DHEphem;
    public static DerObjectIdentifier DHOneFlow;
    public static DerObjectIdentifier DHHybrid1;
    public static DerObjectIdentifier DHHybrid2;
    public static DerObjectIdentifier DHHybridOneFlow;
    public static DerObjectIdentifier Mqv2;
    public static DerObjectIdentifier Mqv1;
    private static X9ObjectIdentifiers();
}
public class Org.BouncyCastle.Bcpg.ArmoredInputStream : BaseInputStream {
    private static Byte[] decodingTable;
    private Stream input;
    private bool start;
    private Int32[] outBuf;
    private int bufPtr;
    private Crc24 crc;
    private bool crcFound;
    private bool hasHeaders;
    private string header;
    private bool newLineFound;
    private bool clearText;
    private bool restart;
    private IList headerList;
    private int lastC;
    private bool isEndOfStream;
    private static ArmoredInputStream();
    public ArmoredInputStream(Stream input);
    public ArmoredInputStream(Stream input, bool hasHeaders);
    private int Decode(int in0, int in1, int in2, int in3, Int32[] result);
    private bool ParseHeaders();
    public bool IsClearText();
    public bool IsEndOfStream();
    public string GetArmorHeaderLine();
    public String[] GetArmorHeaders();
    private int ReadIgnoreSpace();
    private int ReadIgnoreWhitespace();
    private int ReadByteClearText();
    private int ReadClearText(Byte[] buffer, int offset, int count);
    private int DoReadByte();
    public virtual int ReadByte();
    public virtual int Read(Byte[] buffer, int offset, int count);
    public virtual void Close();
}
public class Org.BouncyCastle.Bcpg.ArmoredOutputStream : BaseOutputStream {
    private static Byte[] encodingTable;
    private Stream outStream;
    private Int32[] buf;
    private int bufPtr;
    private Crc24 crc;
    private int chunkCount;
    private int lastb;
    private bool start;
    private bool clearText;
    private bool newLine;
    private string type;
    private static string nl;
    private static string headerStart;
    private static string headerTail;
    private static string footerStart;
    private static string footerTail;
    private static string version;
    private IDictionary headers;
    public ArmoredOutputStream(Stream outStream);
    public ArmoredOutputStream(Stream outStream, IDictionary headers);
    private static ArmoredOutputStream();
    private static void Encode(Stream outStream, Int32[] data, int len);
    public void SetHeader(string name, string v);
    public void ResetHeaders();
    public void BeginClearText(HashAlgorithmTag hashAlgorithm);
    public void EndClearText();
    public virtual void WriteByte(byte b);
    public virtual void Close();
    private void WriteHeaderEntry(string name, string v);
    private void DoWrite(string s);
}
public class Org.BouncyCastle.Bcpg.Attr.ImageAttrib : UserAttributeSubpacket {
    private static Byte[] Zeroes;
    private int hdrLength;
    private int _version;
    private int _encoding;
    private Byte[] imageData;
    public int Version { get; }
    public int Encoding { get; }
    public ImageAttrib(Byte[] data);
    public ImageAttrib(Format imageType, Byte[] imageData);
    private static ImageAttrib();
    private static Byte[] ToByteArray(Format imageType, Byte[] imageData);
    public int get_Version();
    public int get_Encoding();
    public Byte[] GetImageData();
}
public class Org.BouncyCastle.Bcpg.BcpgInputStream : BaseInputStream {
    private Stream m_in;
    private bool next;
    private int nextB;
    private BcpgInputStream(Stream inputStream);
    internal static BcpgInputStream Wrap(Stream inStr);
    public virtual int ReadByte();
    public virtual int Read(Byte[] buffer, int offset, int count);
    public Byte[] ReadAll();
    public void ReadFully(Byte[] buffer, int off, int len);
    public void ReadFully(Byte[] buffer);
    public PacketTag NextPacketTag();
    public Packet ReadPacket();
    public virtual void Close();
}
public abstract class Org.BouncyCastle.Bcpg.BcpgObject : object {
    public virtual Byte[] GetEncoded();
    public abstract virtual void Encode(BcpgOutputStream bcpgOut);
}
public class Org.BouncyCastle.Bcpg.BcpgOutputStream : BaseOutputStream {
    private static int BufferSizePower;
    private Stream outStr;
    private Byte[] partialBuffer;
    private int partialBufferLength;
    private int partialPower;
    private int partialOffset;
    public BcpgOutputStream(Stream outStr);
    public BcpgOutputStream(Stream outStr, PacketTag tag);
    public BcpgOutputStream(Stream outStr, PacketTag tag, long length, bool oldFormat);
    public BcpgOutputStream(Stream outStr, PacketTag tag, long length);
    public BcpgOutputStream(Stream outStr, PacketTag tag, Byte[] buffer);
    internal static BcpgOutputStream Wrap(Stream outStr);
    private void WriteNewPacketLength(long bodyLen);
    private void WriteHeader(PacketTag tag, bool oldPackets, bool partial, long bodyLen);
    private void PartialFlush(bool isLast);
    private void WritePartial(byte b);
    private void WritePartial(Byte[] buffer, int off, int len);
    public virtual void WriteByte(byte value);
    public virtual void Write(Byte[] buffer, int offset, int count);
    internal virtual void WriteShort(short n);
    internal virtual void WriteInt(int n);
    internal virtual void WriteLong(long n);
    public void WritePacket(ContainedPacket p);
    internal void WritePacket(PacketTag tag, Byte[] body, bool oldFormat);
    public void WriteObject(BcpgObject bcpgObject);
    public void WriteObjects(BcpgObject[] v);
    public virtual void Flush();
    public void Finish();
    public virtual void Close();
}
public class Org.BouncyCastle.Bcpg.CompressedDataPacket : InputStreamPacket {
    private CompressionAlgorithmTag algorithm;
    public CompressionAlgorithmTag Algorithm { get; }
    internal CompressedDataPacket(BcpgInputStream bcpgIn);
    public CompressionAlgorithmTag get_Algorithm();
}
public enum Org.BouncyCastle.Bcpg.CompressionAlgorithmTag : Enum {
    public int value__;
    public static CompressionAlgorithmTag Uncompressed;
    public static CompressionAlgorithmTag Zip;
    public static CompressionAlgorithmTag ZLib;
    public static CompressionAlgorithmTag BZip2;
}
public abstract class Org.BouncyCastle.Bcpg.ContainedPacket : Packet {
    public Byte[] GetEncoded();
    public abstract virtual void Encode(BcpgOutputStream bcpgOut);
}
public class Org.BouncyCastle.Bcpg.Crc24 : object {
    private static int Crc24Init;
    private static int Crc24Poly;
    private int crc;
    public int Value { get; }
    public void Update(int b);
    [ObsoleteAttribute("Use 'Value' property instead")]
public int GetValue();
    public int get_Value();
    public void Reset();
}
public class Org.BouncyCastle.Bcpg.DsaPublicBcpgKey : BcpgObject {
    private MPInteger p;
    private MPInteger q;
    private MPInteger g;
    private MPInteger y;
    public string Format { get; }
    public BigInteger G { get; }
    public BigInteger P { get; }
    public BigInteger Q { get; }
    public BigInteger Y { get; }
    public DsaPublicBcpgKey(BcpgInputStream bcpgIn);
    public DsaPublicBcpgKey(BigInteger p, BigInteger q, BigInteger g, BigInteger y);
    public sealed virtual string get_Format();
    public virtual Byte[] GetEncoded();
    public virtual void Encode(BcpgOutputStream bcpgOut);
    public BigInteger get_G();
    public BigInteger get_P();
    public BigInteger get_Q();
    public BigInteger get_Y();
}
public class Org.BouncyCastle.Bcpg.DsaSecretBcpgKey : BcpgObject {
    internal MPInteger x;
    public string Format { get; }
    public BigInteger X { get; }
    public DsaSecretBcpgKey(BcpgInputStream bcpgIn);
    public DsaSecretBcpgKey(BigInteger x);
    public sealed virtual string get_Format();
    public virtual Byte[] GetEncoded();
    public virtual void Encode(BcpgOutputStream bcpgOut);
    public BigInteger get_X();
}
public class Org.BouncyCastle.Bcpg.ElGamalPublicBcpgKey : BcpgObject {
    internal MPInteger p;
    internal MPInteger g;
    internal MPInteger y;
    public string Format { get; }
    public BigInteger P { get; }
    public BigInteger G { get; }
    public BigInteger Y { get; }
    public ElGamalPublicBcpgKey(BcpgInputStream bcpgIn);
    public ElGamalPublicBcpgKey(BigInteger p, BigInteger g, BigInteger y);
    public sealed virtual string get_Format();
    public virtual Byte[] GetEncoded();
    public BigInteger get_P();
    public BigInteger get_G();
    public BigInteger get_Y();
    public virtual void Encode(BcpgOutputStream bcpgOut);
}
public class Org.BouncyCastle.Bcpg.ElGamalSecretBcpgKey : BcpgObject {
    internal MPInteger x;
    public string Format { get; }
    public BigInteger X { get; }
    public ElGamalSecretBcpgKey(BcpgInputStream bcpgIn);
    public ElGamalSecretBcpgKey(BigInteger x);
    public sealed virtual string get_Format();
    public BigInteger get_X();
    public virtual Byte[] GetEncoded();
    public virtual void Encode(BcpgOutputStream bcpgOut);
}
public class Org.BouncyCastle.Bcpg.ExperimentalPacket : ContainedPacket {
    private PacketTag tag;
    private Byte[] contents;
    public PacketTag Tag { get; }
    internal ExperimentalPacket(PacketTag tag, BcpgInputStream bcpgIn);
    public PacketTag get_Tag();
    public Byte[] GetContents();
    public virtual void Encode(BcpgOutputStream bcpgOut);
}
public enum Org.BouncyCastle.Bcpg.HashAlgorithmTag : Enum {
    public int value__;
    public static HashAlgorithmTag MD5;
    public static HashAlgorithmTag Sha1;
    public static HashAlgorithmTag RipeMD160;
    public static HashAlgorithmTag DoubleSha;
    public static HashAlgorithmTag MD2;
    public static HashAlgorithmTag Tiger192;
    public static HashAlgorithmTag Haval5pass160;
    public static HashAlgorithmTag Sha256;
    public static HashAlgorithmTag Sha384;
    public static HashAlgorithmTag Sha512;
    public static HashAlgorithmTag Sha224;
}
public interface Org.BouncyCastle.Bcpg.IBcpgKey {
    public string Format { get; }
    public abstract virtual string get_Format();
}
public class Org.BouncyCastle.Bcpg.InputStreamPacket : Packet {
    private BcpgInputStream bcpgIn;
    public InputStreamPacket(BcpgInputStream bcpgIn);
    public BcpgInputStream GetInputStream();
}
public class Org.BouncyCastle.Bcpg.LiteralDataPacket : InputStreamPacket {
    private int format;
    private Byte[] fileName;
    private long modDate;
    public int Format { get; }
    public long ModificationTime { get; }
    public string FileName { get; }
    internal LiteralDataPacket(BcpgInputStream bcpgIn);
    public int get_Format();
    public long get_ModificationTime();
    public string get_FileName();
    public Byte[] GetRawFileName();
}
public class Org.BouncyCastle.Bcpg.MarkerPacket : ContainedPacket {
    private Byte[] marker;
    public MarkerPacket(BcpgInputStream bcpgIn);
    public virtual void Encode(BcpgOutputStream bcpgOut);
}
public class Org.BouncyCastle.Bcpg.ModDetectionCodePacket : ContainedPacket {
    private Byte[] digest;
    internal ModDetectionCodePacket(BcpgInputStream bcpgIn);
    public ModDetectionCodePacket(Byte[] digest);
    public Byte[] GetDigest();
    public virtual void Encode(BcpgOutputStream bcpgOut);
}
public class Org.BouncyCastle.Bcpg.MPInteger : BcpgObject {
    private BigInteger val;
    public BigInteger Value { get; }
    public MPInteger(BcpgInputStream bcpgIn);
    public MPInteger(BigInteger val);
    public BigInteger get_Value();
    public virtual void Encode(BcpgOutputStream bcpgOut);
    internal static void Encode(BcpgOutputStream bcpgOut, BigInteger val);
}
public class Org.BouncyCastle.Bcpg.OnePassSignaturePacket : ContainedPacket {
    private int version;
    private int sigType;
    private HashAlgorithmTag hashAlgorithm;
    private PublicKeyAlgorithmTag keyAlgorithm;
    private long keyId;
    private int nested;
    public int SignatureType { get; }
    public PublicKeyAlgorithmTag KeyAlgorithm { get; }
    public HashAlgorithmTag HashAlgorithm { get; }
    public long KeyId { get; }
    internal OnePassSignaturePacket(BcpgInputStream bcpgIn);
    public OnePassSignaturePacket(int sigType, HashAlgorithmTag hashAlgorithm, PublicKeyAlgorithmTag keyAlgorithm, long keyId, bool isNested);
    public int get_SignatureType();
    public PublicKeyAlgorithmTag get_KeyAlgorithm();
    public HashAlgorithmTag get_HashAlgorithm();
    public long get_KeyId();
    public virtual void Encode(BcpgOutputStream bcpgOut);
}
public interface Org.BouncyCastle.Bcpg.OpenPgp.IStreamGenerator {
    public abstract virtual void Close();
}
public class Org.BouncyCastle.Bcpg.OpenPgp.PgpCompressedData : PgpObject {
    private CompressedDataPacket data;
    public CompressionAlgorithmTag Algorithm { get; }
    public PgpCompressedData(BcpgInputStream bcpgInput);
    public CompressionAlgorithmTag get_Algorithm();
    public Stream GetInputStream();
    public Stream GetDataStream();
}
public class Org.BouncyCastle.Bcpg.OpenPgp.PgpCompressedDataGenerator : object {
    private CompressionAlgorithmTag algorithm;
    private int compression;
    private Stream dOut;
    private BcpgOutputStream pkOut;
    public PgpCompressedDataGenerator(CompressionAlgorithmTag algorithm);
    public PgpCompressedDataGenerator(CompressionAlgorithmTag algorithm, int compression);
    public Stream Open(Stream outStr);
    public Stream Open(Stream outStr, Byte[] buffer);
    private void doOpen();
    public sealed virtual void Close();
}
public class Org.BouncyCastle.Bcpg.OpenPgp.PgpDataValidationException : PgpException {
    public PgpDataValidationException(string message);
    public PgpDataValidationException(string message, Exception exception);
}
public abstract class Org.BouncyCastle.Bcpg.OpenPgp.PgpEncryptedData : object {
    internal InputStreamPacket encData;
    internal Stream encStream;
    internal TruncatedStream truncStream;
    internal PgpEncryptedData(InputStreamPacket encData);
    public virtual Stream GetInputStream();
    public bool IsIntegrityProtected();
    public bool Verify();
}
public class Org.BouncyCastle.Bcpg.OpenPgp.PgpEncryptedDataGenerator : object {
    private BcpgOutputStream pOut;
    private CipherStream cOut;
    private IBufferedCipher c;
    private bool withIntegrityPacket;
    private bool oldFormat;
    private DigestStream digestOut;
    private IList methods;
    private SymmetricKeyAlgorithmTag defAlgorithm;
    private SecureRandom rand;
    public PgpEncryptedDataGenerator(SymmetricKeyAlgorithmTag encAlgorithm);
    public PgpEncryptedDataGenerator(SymmetricKeyAlgorithmTag encAlgorithm, bool withIntegrityPacket);
    public PgpEncryptedDataGenerator(SymmetricKeyAlgorithmTag encAlgorithm, SecureRandom rand);
    public PgpEncryptedDataGenerator(SymmetricKeyAlgorithmTag encAlgorithm, bool withIntegrityPacket, SecureRandom rand);
    public PgpEncryptedDataGenerator(SymmetricKeyAlgorithmTag encAlgorithm, SecureRandom rand, bool oldFormat);
    public void AddMethod(Char[] passPhrase);
    public void AddMethod(Char[] passPhrase, HashAlgorithmTag s2kDigest);
    public void AddMethod(PgpPublicKey key);
    private void AddCheckSum(Byte[] sessionInfo);
    private Byte[] CreateSessionInfo(SymmetricKeyAlgorithmTag algorithm, KeyParameter key);
    private Stream Open(Stream outStr, long length, Byte[] buffer);
    public Stream Open(Stream outStr, long length);
    public Stream Open(Stream outStr, Byte[] buffer);
    public sealed virtual void Close();
}
[DefaultMemberAttribute("Item")]
public class Org.BouncyCastle.Bcpg.OpenPgp.PgpEncryptedDataList : PgpObject {
    private IList list;
    private InputStreamPacket data;
    public PgpEncryptedData Item { get; }
    [ObsoleteAttribute("Use 'Count' property instead")]
public int Size { get; }
    public int Count { get; }
    public bool IsEmpty { get; }
    public PgpEncryptedDataList(BcpgInputStream bcpgInput);
    public PgpEncryptedData get_Item(int index);
    [ObsoleteAttribute("Use 'object[index]' syntax instead")]
public object Get(int index);
    public int get_Size();
    public int get_Count();
    public bool get_IsEmpty();
    public IEnumerable GetEncryptedDataObjects();
}
public class Org.BouncyCastle.Bcpg.OpenPgp.PgpException : Exception {
    [ObsoleteAttribute("Use InnerException property")]
public Exception UnderlyingException { get; }
    public PgpException(string message);
    public PgpException(string message, Exception exception);
    public Exception get_UnderlyingException();
}
public class Org.BouncyCastle.Bcpg.OpenPgp.PgpExperimental : PgpObject {
    private ExperimentalPacket p;
    public PgpExperimental(BcpgInputStream bcpgIn);
}
public abstract class Org.BouncyCastle.Bcpg.OpenPgp.PgpKeyFlags : object {
    public static int CanCertify;
    public static int CanSign;
    public static int CanEncryptCommunications;
    public static int CanEncryptStorage;
    public static int MaybeSplit;
    public static int MaybeShared;
}
public class Org.BouncyCastle.Bcpg.OpenPgp.PgpKeyPair : object {
    private PgpPublicKey pub;
    private PgpPrivateKey priv;
    public long KeyId { get; }
    public PgpPublicKey PublicKey { get; }
    public PgpPrivateKey PrivateKey { get; }
    public PgpKeyPair(PublicKeyAlgorithmTag algorithm, AsymmetricCipherKeyPair keyPair, DateTime time);
    public PgpKeyPair(PublicKeyAlgorithmTag algorithm, AsymmetricKeyParameter pubKey, AsymmetricKeyParameter privKey, DateTime time);
    public PgpKeyPair(PgpPublicKey pub, PgpPrivateKey priv);
    public long get_KeyId();
    public PgpPublicKey get_PublicKey();
    public PgpPrivateKey get_PrivateKey();
}
public abstract class Org.BouncyCastle.Bcpg.OpenPgp.PgpKeyRing : PgpObject {
    internal static TrustPacket ReadOptionalTrustPacket(BcpgInputStream bcpgInput);
    internal static IList ReadSignaturesAndTrust(BcpgInputStream bcpgInput);
    internal static void ReadUserIDs(BcpgInputStream bcpgInput, IList& ids, IList& idTrusts, IList& idSigs);
}
public class Org.BouncyCastle.Bcpg.OpenPgp.PgpKeyRingGenerator : object {
    private IList keys;
    private string id;
    private SymmetricKeyAlgorithmTag encAlgorithm;
    private int certificationLevel;
    private Char[] passPhrase;
    private bool useSha1;
    private PgpKeyPair masterKey;
    private PgpSignatureSubpacketVector hashedPacketVector;
    private PgpSignatureSubpacketVector unhashedPacketVector;
    private SecureRandom rand;
    public PgpKeyRingGenerator(int certificationLevel, PgpKeyPair masterKey, string id, SymmetricKeyAlgorithmTag encAlgorithm, Char[] passPhrase, PgpSignatureSubpacketVector hashedPackets, PgpSignatureSubpacketVector unhashedPackets, SecureRandom rand);
    public PgpKeyRingGenerator(int certificationLevel, PgpKeyPair masterKey, string id, SymmetricKeyAlgorithmTag encAlgorithm, Char[] passPhrase, bool useSha1, PgpSignatureSubpacketVector hashedPackets, PgpSignatureSubpacketVector unhashedPackets, SecureRandom rand);
    public void AddSubKey(PgpKeyPair keyPair);
    public void AddSubKey(PgpKeyPair keyPair, PgpSignatureSubpacketVector hashedPackets, PgpSignatureSubpacketVector unhashedPackets);
    public PgpSecretKeyRing GenerateSecretKeyRing();
    public PgpPublicKeyRing GeneratePublicKeyRing();
}
public class Org.BouncyCastle.Bcpg.OpenPgp.PgpKeyValidationException : PgpException {
    public PgpKeyValidationException(string message);
    public PgpKeyValidationException(string message, Exception exception);
}
public class Org.BouncyCastle.Bcpg.OpenPgp.PgpLiteralData : PgpObject {
    public static char Binary;
    public static char Text;
    public static char Utf8;
    public static string Console;
    private LiteralDataPacket data;
    public int Format { get; }
    public string FileName { get; }
    public DateTime ModificationTime { get; }
    public PgpLiteralData(BcpgInputStream bcpgInput);
    public int get_Format();
    public string get_FileName();
    public Byte[] GetRawFileName();
    public DateTime get_ModificationTime();
    public Stream GetInputStream();
    public Stream GetDataStream();
}
public class Org.BouncyCastle.Bcpg.OpenPgp.PgpLiteralDataGenerator : object {
    public static char Binary;
    public static char Text;
    public static char Utf8;
    public static string Console;
    private BcpgOutputStream pkOut;
    private bool oldFormat;
    public PgpLiteralDataGenerator(bool oldFormat);
    private void WriteHeader(BcpgOutputStream outStr, char format, Byte[] encName, long modificationTime);
    public Stream Open(Stream outStr, char format, string name, long length, DateTime modificationTime);
    public Stream Open(Stream outStr, char format, string name, DateTime modificationTime, Byte[] buffer);
    public Stream Open(Stream outStr, char format, FileInfo file);
    public sealed virtual void Close();
}
public class Org.BouncyCastle.Bcpg.OpenPgp.PgpMarker : PgpObject {
    private MarkerPacket p;
    public PgpMarker(BcpgInputStream bcpgIn);
}
public abstract class Org.BouncyCastle.Bcpg.OpenPgp.PgpObject : object {
}
public class Org.BouncyCastle.Bcpg.OpenPgp.PgpObjectFactory : object {
    private BcpgInputStream bcpgIn;
    public PgpObjectFactory(Stream inputStream);
    public PgpObjectFactory(Byte[] bytes);
    public PgpObject NextPgpObject();
    [ObsoleteAttribute("Use NextPgpObject() instead")]
public object NextObject();
    public IList AllPgpObjects();
}
public class Org.BouncyCastle.Bcpg.OpenPgp.PgpOnePassSignature : object {
    private OnePassSignaturePacket sigPack;
    private int signatureType;
    private ISigner sig;
    private byte lastb;
    public long KeyId { get; }
    public int SignatureType { get; }
    public HashAlgorithmTag HashAlgorithm { get; }
    public PublicKeyAlgorithmTag KeyAlgorithm { get; }
    internal PgpOnePassSignature(BcpgInputStream bcpgInput);
    internal PgpOnePassSignature(OnePassSignaturePacket sigPack);
    public void InitVerify(PgpPublicKey pubKey);
    public void Update(byte b);
    private void doCanonicalUpdateByte(byte b);
    private void doUpdateCRLF();
    public void Update(Byte[] bytes);
    public void Update(Byte[] bytes, int off, int length);
    public bool Verify(PgpSignature pgpSig);
    public long get_KeyId();
    public int get_SignatureType();
    public HashAlgorithmTag get_HashAlgorithm();
    public PublicKeyAlgorithmTag get_KeyAlgorithm();
    public Byte[] GetEncoded();
    public void Encode(Stream outStr);
}
[DefaultMemberAttribute("Item")]
public class Org.BouncyCastle.Bcpg.OpenPgp.PgpOnePassSignatureList : PgpObject {
    private PgpOnePassSignature[] sigs;
    public PgpOnePassSignature Item { get; }
    [ObsoleteAttribute("Use 'Count' property instead")]
public int Size { get; }
    public int Count { get; }
    public bool IsEmpty { get; }
    public PgpOnePassSignatureList(PgpOnePassSignature[] sigs);
    public PgpOnePassSignatureList(PgpOnePassSignature sig);
    public PgpOnePassSignature get_Item(int index);
    [ObsoleteAttribute("Use 'object[index]' syntax instead")]
public PgpOnePassSignature Get(int index);
    public int get_Size();
    public int get_Count();
    public bool get_IsEmpty();
}
public class Org.BouncyCastle.Bcpg.OpenPgp.PgpPbeEncryptedData : PgpEncryptedData {
    private SymmetricKeyEncSessionPacket keyData;
    internal PgpPbeEncryptedData(SymmetricKeyEncSessionPacket keyData, InputStreamPacket encData);
    public virtual Stream GetInputStream();
    public Stream GetDataStream(Char[] passPhrase);
    private IBufferedCipher CreateStreamCipher(SymmetricKeyAlgorithmTag keyAlgorithm);
}
public class Org.BouncyCastle.Bcpg.OpenPgp.PgpPrivateKey : object {
    private long keyId;
    private AsymmetricKeyParameter privateKey;
    public long KeyId { get; }
    public AsymmetricKeyParameter Key { get; }
    public PgpPrivateKey(AsymmetricKeyParameter privateKey, long keyId);
    public long get_KeyId();
    public AsymmetricKeyParameter get_Key();
}
public class Org.BouncyCastle.Bcpg.OpenPgp.PgpPublicKey : object {
    private static Int32[] MasterKeyCertificationTypes;
    private long keyId;
    private Byte[] fingerprint;
    private int keyStrength;
    internal PublicKeyPacket publicPk;
    internal TrustPacket trustPk;
    internal IList keySigs;
    internal IList ids;
    internal IList idTrusts;
    internal IList idSigs;
    internal IList subSigs;
    public int Version { get; }
    public DateTime CreationTime { get; }
    public int ValidDays { get; }
    public long KeyId { get; }
    public bool IsEncryptionKey { get; }
    public bool IsMasterKey { get; }
    public PublicKeyAlgorithmTag Algorithm { get; }
    public int BitStrength { get; }
    public PgpPublicKey(PublicKeyAlgorithmTag algorithm, AsymmetricKeyParameter pubKey, DateTime time);
    internal PgpPublicKey(PublicKeyPacket publicPk, TrustPacket trustPk, IList sigs);
    internal PgpPublicKey(PgpPublicKey key, TrustPacket trust, IList subSigs);
    internal PgpPublicKey(PgpPublicKey pubKey);
    internal PgpPublicKey(PublicKeyPacket publicPk, TrustPacket trustPk, IList keySigs, IList ids, IList idTrusts, IList idSigs);
    internal PgpPublicKey(PublicKeyPacket publicPk, IList ids, IList idSigs);
    private static PgpPublicKey();
    private void Init();
    public int get_Version();
    public DateTime get_CreationTime();
    public int get_ValidDays();
    public Byte[] GetTrustData();
    public long GetValidSeconds();
    private long GetExpirationTimeFromSig(bool selfSigned, int signatureType);
    public long get_KeyId();
    public Byte[] GetFingerprint();
    public bool get_IsEncryptionKey();
    public bool get_IsMasterKey();
    public PublicKeyAlgorithmTag get_Algorithm();
    public int get_BitStrength();
    public AsymmetricKeyParameter GetKey();
    public IEnumerable GetUserIds();
    public IEnumerable GetUserAttributes();
    public IEnumerable GetSignaturesForId(string id);
    public IEnumerable GetSignaturesForUserAttribute(PgpUserAttributeSubpacketVector userAttributes);
    public IEnumerable GetSignaturesOfType(int signatureType);
    public IEnumerable GetSignatures();
    public Byte[] GetEncoded();
    public void Encode(Stream outStr);
    public bool IsRevoked();
    public static PgpPublicKey AddCertification(PgpPublicKey key, string id, PgpSignature certification);
    public static PgpPublicKey AddCertification(PgpPublicKey key, PgpUserAttributeSubpacketVector userAttributes, PgpSignature certification);
    private static PgpPublicKey AddCert(PgpPublicKey key, object id, PgpSignature certification);
    public static PgpPublicKey RemoveCertification(PgpPublicKey key, PgpUserAttributeSubpacketVector userAttributes);
    public static PgpPublicKey RemoveCertification(PgpPublicKey key, string id);
    private static PgpPublicKey RemoveCert(PgpPublicKey key, object id);
    public static PgpPublicKey RemoveCertification(PgpPublicKey key, string id, PgpSignature certification);
    public static PgpPublicKey RemoveCertification(PgpPublicKey key, PgpUserAttributeSubpacketVector userAttributes, PgpSignature certification);
    private static PgpPublicKey RemoveCert(PgpPublicKey key, object id, PgpSignature certification);
    public static PgpPublicKey AddCertification(PgpPublicKey key, PgpSignature certification);
    public static PgpPublicKey RemoveCertification(PgpPublicKey key, PgpSignature certification);
}
public class Org.BouncyCastle.Bcpg.OpenPgp.PgpPublicKeyEncryptedData : PgpEncryptedData {
    private PublicKeyEncSessionPacket keyData;
    public long KeyId { get; }
    internal PgpPublicKeyEncryptedData(PublicKeyEncSessionPacket keyData, InputStreamPacket encData);
    private static IBufferedCipher GetKeyCipher(PublicKeyAlgorithmTag algorithm);
    private bool ConfirmCheckSum(Byte[] sessionInfo);
    public long get_KeyId();
    public SymmetricKeyAlgorithmTag GetSymmetricAlgorithm(PgpPrivateKey privKey);
    public Stream GetDataStream(PgpPrivateKey privKey);
    private Byte[] fetchSymmetricKeyData(PgpPrivateKey privKey);
}
public class Org.BouncyCastle.Bcpg.OpenPgp.PgpPublicKeyRing : PgpKeyRing {
    private IList keys;
    public PgpPublicKeyRing(Byte[] encoding);
    internal PgpPublicKeyRing(IList pubKeys);
    public PgpPublicKeyRing(Stream inputStream);
    public PgpPublicKey GetPublicKey();
    public PgpPublicKey GetPublicKey(long keyId);
    public IEnumerable GetPublicKeys();
    public Byte[] GetEncoded();
    public void Encode(Stream outStr);
    public static PgpPublicKeyRing InsertPublicKey(PgpPublicKeyRing pubRing, PgpPublicKey pubKey);
    public static PgpPublicKeyRing RemovePublicKey(PgpPublicKeyRing pubRing, PgpPublicKey pubKey);
    internal static PgpPublicKey ReadSubkey(BcpgInputStream bcpgInput);
}
public class Org.BouncyCastle.Bcpg.OpenPgp.PgpPublicKeyRingBundle : object {
    private IDictionary pubRings;
    private IList order;
    [ObsoleteAttribute("Use 'Count' property instead")]
public int Size { get; }
    public int Count { get; }
    private PgpPublicKeyRingBundle(IDictionary pubRings, IList order);
    public PgpPublicKeyRingBundle(Byte[] encoding);
    public PgpPublicKeyRingBundle(Stream inputStream);
    public PgpPublicKeyRingBundle(IEnumerable e);
    public int get_Size();
    public int get_Count();
    public IEnumerable GetKeyRings();
    public IEnumerable GetKeyRings(string userId);
    public IEnumerable GetKeyRings(string userId, bool matchPartial);
    public IEnumerable GetKeyRings(string userId, bool matchPartial, bool ignoreCase);
    public PgpPublicKey GetPublicKey(long keyId);
    public PgpPublicKeyRing GetPublicKeyRing(long keyId);
    public bool Contains(long keyID);
    public Byte[] GetEncoded();
    public void Encode(Stream outStr);
    public static PgpPublicKeyRingBundle AddPublicKeyRing(PgpPublicKeyRingBundle bundle, PgpPublicKeyRing publicKeyRing);
    public static PgpPublicKeyRingBundle RemovePublicKeyRing(PgpPublicKeyRingBundle bundle, PgpPublicKeyRing publicKeyRing);
}
public class Org.BouncyCastle.Bcpg.OpenPgp.PgpSecretKey : object {
    private SecretKeyPacket secret;
    private PgpPublicKey pub;
    public bool IsSigningKey { get; }
    public bool IsMasterKey { get; }
    public SymmetricKeyAlgorithmTag KeyEncryptionAlgorithm { get; }
    public long KeyId { get; }
    public PgpPublicKey PublicKey { get; }
    public IEnumerable UserIds { get; }
    public IEnumerable UserAttributes { get; }
    internal PgpSecretKey(SecretKeyPacket secret, PgpPublicKey pub);
    internal PgpSecretKey(PgpPrivateKey privKey, PgpPublicKey pubKey, SymmetricKeyAlgorithmTag encAlgorithm, Char[] passPhrase, bool useSha1, SecureRandom rand);
    internal PgpSecretKey(PgpPrivateKey privKey, PgpPublicKey pubKey, SymmetricKeyAlgorithmTag encAlgorithm, Char[] passPhrase, bool useSha1, SecureRandom rand, bool isMasterKey);
    public PgpSecretKey(int certificationLevel, PgpKeyPair keyPair, string id, SymmetricKeyAlgorithmTag encAlgorithm, Char[] passPhrase, PgpSignatureSubpacketVector hashedPackets, PgpSignatureSubpacketVector unhashedPackets, SecureRandom rand);
    public PgpSecretKey(int certificationLevel, PgpKeyPair keyPair, string id, SymmetricKeyAlgorithmTag encAlgorithm, Char[] passPhrase, bool useSha1, PgpSignatureSubpacketVector hashedPackets, PgpSignatureSubpacketVector unhashedPackets, SecureRandom rand);
    public PgpSecretKey(int certificationLevel, PublicKeyAlgorithmTag algorithm, AsymmetricKeyParameter pubKey, AsymmetricKeyParameter privKey, DateTime time, string id, SymmetricKeyAlgorithmTag encAlgorithm, Char[] passPhrase, PgpSignatureSubpacketVector hashedPackets, PgpSignatureSubpacketVector unhashedPackets, SecureRandom rand);
    public PgpSecretKey(int certificationLevel, PublicKeyAlgorithmTag algorithm, AsymmetricKeyParameter pubKey, AsymmetricKeyParameter privKey, DateTime time, string id, SymmetricKeyAlgorithmTag encAlgorithm, Char[] passPhrase, bool useSha1, PgpSignatureSubpacketVector hashedPackets, PgpSignatureSubpacketVector unhashedPackets, SecureRandom rand);
    private static PgpPublicKey certifiedPublicKey(int certificationLevel, PgpKeyPair keyPair, string id, PgpSignatureSubpacketVector hashedPackets, PgpSignatureSubpacketVector unhashedPackets);
    public bool get_IsSigningKey();
    public bool get_IsMasterKey();
    public SymmetricKeyAlgorithmTag get_KeyEncryptionAlgorithm();
    public long get_KeyId();
    public PgpPublicKey get_PublicKey();
    public IEnumerable get_UserIds();
    public IEnumerable get_UserAttributes();
    private Byte[] ExtractKeyData(Char[] passPhrase);
    public PgpPrivateKey ExtractPrivateKey(Char[] passPhrase);
    private static Byte[] Checksum(bool useSha1, Byte[] bytes, int length);
    public Byte[] GetEncoded();
    public void Encode(Stream outStr);
    public static PgpSecretKey CopyWithNewPassword(PgpSecretKey key, Char[] oldPassPhrase, Char[] newPassPhrase, SymmetricKeyAlgorithmTag newEncAlgorithm, SecureRandom rand);
    public static PgpSecretKey ReplacePublicKey(PgpSecretKey secretKey, PgpPublicKey publicKey);
    private static Byte[] EncryptKeyData(Byte[] rawKeyData, SymmetricKeyAlgorithmTag encAlgorithm, Char[] passPhrase, SecureRandom random, S2k& s2k, Byte[]& iv);
}
public class Org.BouncyCastle.Bcpg.OpenPgp.PgpSecretKeyRing : PgpKeyRing {
    private IList keys;
    private IList extraPubKeys;
    internal PgpSecretKeyRing(IList keys);
    private PgpSecretKeyRing(IList keys, IList extraPubKeys);
    public PgpSecretKeyRing(Byte[] encoding);
    public PgpSecretKeyRing(Stream inputStream);
    public PgpPublicKey GetPublicKey();
    public PgpSecretKey GetSecretKey();
    public IEnumerable GetSecretKeys();
    public PgpSecretKey GetSecretKey(long keyId);
    public IEnumerable GetExtraPublicKeys();
    public Byte[] GetEncoded();
    public void Encode(Stream outStr);
    public static PgpSecretKeyRing ReplacePublicKeys(PgpSecretKeyRing secretRing, PgpPublicKeyRing publicRing);
    public static PgpSecretKeyRing CopyWithNewPassword(PgpSecretKeyRing ring, Char[] oldPassPhrase, Char[] newPassPhrase, SymmetricKeyAlgorithmTag newEncAlgorithm, SecureRandom rand);
    public static PgpSecretKeyRing InsertSecretKey(PgpSecretKeyRing secRing, PgpSecretKey secKey);
    public static PgpSecretKeyRing RemoveSecretKey(PgpSecretKeyRing secRing, PgpSecretKey secKey);
}
public class Org.BouncyCastle.Bcpg.OpenPgp.PgpSecretKeyRingBundle : object {
    private IDictionary secretRings;
    private IList order;
    [ObsoleteAttribute("Use 'Count' property instead")]
public int Size { get; }
    public int Count { get; }
    private PgpSecretKeyRingBundle(IDictionary secretRings, IList order);
    public PgpSecretKeyRingBundle(Byte[] encoding);
    public PgpSecretKeyRingBundle(Stream inputStream);
    public PgpSecretKeyRingBundle(IEnumerable e);
    public int get_Size();
    public int get_Count();
    public IEnumerable GetKeyRings();
    public IEnumerable GetKeyRings(string userId);
    public IEnumerable GetKeyRings(string userId, bool matchPartial);
    public IEnumerable GetKeyRings(string userId, bool matchPartial, bool ignoreCase);
    public PgpSecretKey GetSecretKey(long keyId);
    public PgpSecretKeyRing GetSecretKeyRing(long keyId);
    public bool Contains(long keyID);
    public Byte[] GetEncoded();
    public void Encode(Stream outStr);
    public static PgpSecretKeyRingBundle AddSecretKeyRing(PgpSecretKeyRingBundle bundle, PgpSecretKeyRing secretKeyRing);
    public static PgpSecretKeyRingBundle RemoveSecretKeyRing(PgpSecretKeyRingBundle bundle, PgpSecretKeyRing secretKeyRing);
}
public class Org.BouncyCastle.Bcpg.OpenPgp.PgpSignature : object {
    public static int BinaryDocument;
    public static int CanonicalTextDocument;
    public static int StandAlone;
    public static int DefaultCertification;
    public static int NoCertification;
    public static int CasualCertification;
    public static int PositiveCertification;
    public static int SubkeyBinding;
    public static int PrimaryKeyBinding;
    public static int DirectKey;
    public static int KeyRevocation;
    public static int SubkeyRevocation;
    public static int CertificationRevocation;
    public static int Timestamp;
    private SignaturePacket sigPck;
    private int signatureType;
    private TrustPacket trustPck;
    private ISigner sig;
    private byte lastb;
    public int Version { get; }
    public PublicKeyAlgorithmTag KeyAlgorithm { get; }
    public HashAlgorithmTag HashAlgorithm { get; }
    public int SignatureType { get; }
    public long KeyId { get; }
    public DateTime CreationTime { get; }
    public bool HasSubpackets { get; }
    internal PgpSignature(BcpgInputStream bcpgInput);
    internal PgpSignature(SignaturePacket sigPacket);
    internal PgpSignature(SignaturePacket sigPacket, TrustPacket trustPacket);
    private void GetSig();
    public int get_Version();
    public PublicKeyAlgorithmTag get_KeyAlgorithm();
    public HashAlgorithmTag get_HashAlgorithm();
    public void InitVerify(PgpPublicKey pubKey);
    public void Update(byte b);
    private void doCanonicalUpdateByte(byte b);
    private void doUpdateCRLF();
    public void Update(Byte[] bytes);
    public void Update(Byte[] bytes, int off, int length);
    public bool Verify();
    private void UpdateWithIdData(int header, Byte[] idBytes);
    private void UpdateWithPublicKey(PgpPublicKey key);
    public bool VerifyCertification(PgpUserAttributeSubpacketVector userAttributes, PgpPublicKey key);
    public bool VerifyCertification(string id, PgpPublicKey key);
    public bool VerifyCertification(PgpPublicKey masterKey, PgpPublicKey pubKey);
    public bool VerifyCertification(PgpPublicKey pubKey);
    public int get_SignatureType();
    public long get_KeyId();
    [ObsoleteAttribute("Use 'CreationTime' property instead")]
public DateTime GetCreationTime();
    public DateTime get_CreationTime();
    public Byte[] GetSignatureTrailer();
    public bool get_HasSubpackets();
    public PgpSignatureSubpacketVector GetHashedSubPackets();
    public PgpSignatureSubpacketVector GetUnhashedSubPackets();
    private PgpSignatureSubpacketVector createSubpacketVector(SignatureSubpacket[] pcks);
    public Byte[] GetSignature();
    public Byte[] GetEncoded();
    public void Encode(Stream outStream);
    private Byte[] GetEncodedPublicKey(PgpPublicKey pubKey);
}
public class Org.BouncyCastle.Bcpg.OpenPgp.PgpSignatureGenerator : object {
    private static SignatureSubpacket[] EmptySignatureSubpackets;
    private PublicKeyAlgorithmTag keyAlgorithm;
    private HashAlgorithmTag hashAlgorithm;
    private PgpPrivateKey privKey;
    private ISigner sig;
    private IDigest dig;
    private int signatureType;
    private byte lastb;
    private SignatureSubpacket[] unhashed;
    private SignatureSubpacket[] hashed;
    public PgpSignatureGenerator(PublicKeyAlgorithmTag keyAlgorithm, HashAlgorithmTag hashAlgorithm);
    private static PgpSignatureGenerator();
    public void InitSign(int sigType, PgpPrivateKey key);
    public void InitSign(int sigType, PgpPrivateKey key, SecureRandom random);
    public void Update(byte b);
    private void doCanonicalUpdateByte(byte b);
    private void doUpdateCRLF();
    private void doUpdateByte(byte b);
    public void Update(Byte[] b);
    public void Update(Byte[] b, int off, int len);
    public void SetHashedSubpackets(PgpSignatureSubpacketVector hashedPackets);
    public void SetUnhashedSubpackets(PgpSignatureSubpacketVector unhashedPackets);
    public PgpOnePassSignature GenerateOnePassVersion(bool isNested);
    public PgpSignature Generate();
    public PgpSignature GenerateCertification(string id, PgpPublicKey pubKey);
    public PgpSignature GenerateCertification(PgpUserAttributeSubpacketVector userAttributes, PgpPublicKey pubKey);
    public PgpSignature GenerateCertification(PgpPublicKey masterKey, PgpPublicKey pubKey);
    public PgpSignature GenerateCertification(PgpPublicKey pubKey);
    private Byte[] GetEncodedPublicKey(PgpPublicKey pubKey);
    private bool packetPresent(SignatureSubpacket[] packets, SignatureSubpacketTag type);
    private SignatureSubpacket[] insertSubpacket(SignatureSubpacket[] packets, SignatureSubpacket subpacket);
    private void UpdateWithIdData(int header, Byte[] idBytes);
    private void UpdateWithPublicKey(PgpPublicKey key);
}
[DefaultMemberAttribute("Item")]
public class Org.BouncyCastle.Bcpg.OpenPgp.PgpSignatureList : PgpObject {
    private PgpSignature[] sigs;
    public PgpSignature Item { get; }
    [ObsoleteAttribute("Use 'Count' property instead")]
public int Size { get; }
    public int Count { get; }
    public bool IsEmpty { get; }
    public PgpSignatureList(PgpSignature[] sigs);
    public PgpSignatureList(PgpSignature sig);
    public PgpSignature get_Item(int index);
    [ObsoleteAttribute("Use 'object[index]' syntax instead")]
public PgpSignature Get(int index);
    public int get_Size();
    public int get_Count();
    public bool get_IsEmpty();
}
public class Org.BouncyCastle.Bcpg.OpenPgp.PgpSignatureSubpacketGenerator : object {
    private IList list;
    public void SetRevocable(bool isCritical, bool isRevocable);
    public void SetExportable(bool isCritical, bool isExportable);
    public void SetTrust(bool isCritical, int depth, int trustAmount);
    public void SetKeyExpirationTime(bool isCritical, long seconds);
    public void SetSignatureExpirationTime(bool isCritical, long seconds);
    public void SetSignatureCreationTime(bool isCritical, DateTime date);
    public void SetPreferredHashAlgorithms(bool isCritical, Int32[] algorithms);
    public void SetPreferredSymmetricAlgorithms(bool isCritical, Int32[] algorithms);
    public void SetPreferredCompressionAlgorithms(bool isCritical, Int32[] algorithms);
    public void SetKeyFlags(bool isCritical, int flags);
    public void SetSignerUserId(bool isCritical, string userId);
    public void SetEmbeddedSignature(bool isCritical, PgpSignature pgpSignature);
    public void SetPrimaryUserId(bool isCritical, bool isPrimaryUserId);
    public void SetNotationData(bool isCritical, bool isHumanReadable, string notationName, string notationValue);
    public void SetRevocationReason(bool isCritical, RevocationReasonTag reason, string description);
    public void SetRevocationKey(bool isCritical, PublicKeyAlgorithmTag keyAlgorithm, Byte[] fingerprint);
    public void SetIssuerKeyID(bool isCritical, long keyID);
    public PgpSignatureSubpacketVector Generate();
}
public class Org.BouncyCastle.Bcpg.OpenPgp.PgpSignatureSubpacketVector : object {
    private SignatureSubpacket[] packets;
    [ObsoleteAttribute("Use 'Count' property instead")]
public int Size { get; }
    public int Count { get; }
    internal PgpSignatureSubpacketVector(SignatureSubpacket[] packets);
    public SignatureSubpacket GetSubpacket(SignatureSubpacketTag type);
    public bool HasSubpacket(SignatureSubpacketTag type);
    public SignatureSubpacket[] GetSubpackets(SignatureSubpacketTag type);
    public NotationData[] GetNotationDataOccurences();
    public long GetIssuerKeyId();
    public bool HasSignatureCreationTime();
    public DateTime GetSignatureCreationTime();
    public long GetSignatureExpirationTime();
    public long GetKeyExpirationTime();
    public Int32[] GetPreferredHashAlgorithms();
    public Int32[] GetPreferredSymmetricAlgorithms();
    public Int32[] GetPreferredCompressionAlgorithms();
    public int GetKeyFlags();
    public string GetSignerUserId();
    public bool IsPrimaryUserId();
    public SignatureSubpacketTag[] GetCriticalTags();
    public int get_Size();
    public int get_Count();
    internal SignatureSubpacket[] ToSubpacketArray();
}
public class Org.BouncyCastle.Bcpg.OpenPgp.PgpUserAttributeSubpacketVector : object {
    private UserAttributeSubpacket[] packets;
    internal PgpUserAttributeSubpacketVector(UserAttributeSubpacket[] packets);
    public UserAttributeSubpacket GetSubpacket(UserAttributeSubpacketTag type);
    public ImageAttrib GetImageAttribute();
    internal UserAttributeSubpacket[] ToSubpacketArray();
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
}
public class Org.BouncyCastle.Bcpg.OpenPgp.PgpUserAttributeSubpacketVectorGenerator : object {
    private IList list;
    public virtual void SetImageAttribute(Format imageType, Byte[] imageData);
    public virtual PgpUserAttributeSubpacketVector Generate();
}
public class Org.BouncyCastle.Bcpg.OpenPgp.PgpUtilities : object {
    private static int ReadAhead;
    public static MPInteger[] DsaSigToMpi(Byte[] encoding);
    public static MPInteger[] RsaSigToMpi(Byte[] encoding);
    public static string GetDigestName(HashAlgorithmTag hashAlgorithm);
    public static string GetSignatureName(PublicKeyAlgorithmTag keyAlgorithm, HashAlgorithmTag hashAlgorithm);
    public static string GetSymmetricCipherName(SymmetricKeyAlgorithmTag algorithm);
    public static int GetKeySize(SymmetricKeyAlgorithmTag algorithm);
    public static KeyParameter MakeKey(SymmetricKeyAlgorithmTag algorithm, Byte[] keyBytes);
    public static KeyParameter MakeRandomKey(SymmetricKeyAlgorithmTag algorithm, SecureRandom random);
    public static KeyParameter MakeKeyFromPassPhrase(SymmetricKeyAlgorithmTag algorithm, S2k s2k, Char[] passPhrase);
    public static void WriteFileToLiteralData(Stream output, char fileType, FileInfo file);
    public static void WriteFileToLiteralData(Stream output, char fileType, FileInfo file, Byte[] buffer);
    private static void PipeFileContents(FileInfo file, Stream pOut, int bufSize);
    private static bool IsPossiblyBase64(int ch);
    public static Stream GetDecoderStream(Stream inputStream);
}
public class Org.BouncyCastle.Bcpg.OpenPgp.PgpV3SignatureGenerator : object {
    private PublicKeyAlgorithmTag keyAlgorithm;
    private HashAlgorithmTag hashAlgorithm;
    private PgpPrivateKey privKey;
    private ISigner sig;
    private IDigest dig;
    private int signatureType;
    private byte lastb;
    public PgpV3SignatureGenerator(PublicKeyAlgorithmTag keyAlgorithm, HashAlgorithmTag hashAlgorithm);
    public void InitSign(int sigType, PgpPrivateKey key);
    public void InitSign(int sigType, PgpPrivateKey key, SecureRandom random);
    public void Update(byte b);
    private void doCanonicalUpdateByte(byte b);
    private void doUpdateCRLF();
    private void doUpdateByte(byte b);
    public void Update(Byte[] b);
    public void Update(Byte[] b, int off, int len);
    public PgpOnePassSignature GenerateOnePassVersion(bool isNested);
    public PgpSignature Generate();
}
public class Org.BouncyCastle.Bcpg.OpenPgp.WrappedGeneratorStream : FilterStream {
    private IStreamGenerator gen;
    public WrappedGeneratorStream(IStreamGenerator gen, Stream str);
    public virtual void Close();
}
public abstract class Org.BouncyCastle.Bcpg.OutputStreamPacket : object {
    private BcpgOutputStream bcpgOut;
    internal OutputStreamPacket(BcpgOutputStream bcpgOut);
    public abstract virtual BcpgOutputStream Open();
    public abstract virtual void Close();
}
public class Org.BouncyCastle.Bcpg.Packet : object {
}
public enum Org.BouncyCastle.Bcpg.PacketTag : Enum {
    public int value__;
    public static PacketTag Reserved;
    public static PacketTag PublicKeyEncryptedSession;
    public static PacketTag Signature;
    public static PacketTag SymmetricKeyEncryptedSessionKey;
    public static PacketTag OnePassSignature;
    public static PacketTag SecretKey;
    public static PacketTag PublicKey;
    public static PacketTag SecretSubkey;
    public static PacketTag CompressedData;
    public static PacketTag SymmetricKeyEncrypted;
    public static PacketTag Marker;
    public static PacketTag LiteralData;
    public static PacketTag Trust;
    public static PacketTag UserId;
    public static PacketTag PublicSubkey;
    public static PacketTag UserAttribute;
    public static PacketTag SymmetricEncryptedIntegrityProtected;
    public static PacketTag ModificationDetectionCode;
    public static PacketTag Experimental1;
    public static PacketTag Experimental2;
    public static PacketTag Experimental3;
    public static PacketTag Experimental4;
}
public enum Org.BouncyCastle.Bcpg.PublicKeyAlgorithmTag : Enum {
    public int value__;
    public static PublicKeyAlgorithmTag RsaGeneral;
    public static PublicKeyAlgorithmTag RsaEncrypt;
    public static PublicKeyAlgorithmTag RsaSign;
    public static PublicKeyAlgorithmTag ElGamalEncrypt;
    public static PublicKeyAlgorithmTag Dsa;
    public static PublicKeyAlgorithmTag EC;
    public static PublicKeyAlgorithmTag ECDsa;
    public static PublicKeyAlgorithmTag ElGamalGeneral;
    public static PublicKeyAlgorithmTag DiffieHellman;
    public static PublicKeyAlgorithmTag Experimental_1;
    public static PublicKeyAlgorithmTag Experimental_2;
    public static PublicKeyAlgorithmTag Experimental_3;
    public static PublicKeyAlgorithmTag Experimental_4;
    public static PublicKeyAlgorithmTag Experimental_5;
    public static PublicKeyAlgorithmTag Experimental_6;
    public static PublicKeyAlgorithmTag Experimental_7;
    public static PublicKeyAlgorithmTag Experimental_8;
    public static PublicKeyAlgorithmTag Experimental_9;
    public static PublicKeyAlgorithmTag Experimental_10;
    public static PublicKeyAlgorithmTag Experimental_11;
}
public class Org.BouncyCastle.Bcpg.PublicKeyEncSessionPacket : ContainedPacket {
    private int version;
    private long keyId;
    private PublicKeyAlgorithmTag algorithm;
    private BigInteger[] data;
    public int Version { get; }
    public long KeyId { get; }
    public PublicKeyAlgorithmTag Algorithm { get; }
    internal PublicKeyEncSessionPacket(BcpgInputStream bcpgIn);
    public PublicKeyEncSessionPacket(long keyId, PublicKeyAlgorithmTag algorithm, BigInteger[] data);
    public int get_Version();
    public long get_KeyId();
    public PublicKeyAlgorithmTag get_Algorithm();
    public BigInteger[] GetEncSessionKey();
    public virtual void Encode(BcpgOutputStream bcpgOut);
}
public class Org.BouncyCastle.Bcpg.PublicKeyPacket : ContainedPacket {
    private int version;
    private long time;
    private int validDays;
    private PublicKeyAlgorithmTag algorithm;
    private IBcpgKey key;
    public int Version { get; }
    public PublicKeyAlgorithmTag Algorithm { get; }
    public int ValidDays { get; }
    public IBcpgKey Key { get; }
    internal PublicKeyPacket(BcpgInputStream bcpgIn);
    public PublicKeyPacket(PublicKeyAlgorithmTag algorithm, DateTime time, IBcpgKey key);
    public int get_Version();
    public PublicKeyAlgorithmTag get_Algorithm();
    public int get_ValidDays();
    public DateTime GetTime();
    public IBcpgKey get_Key();
    public Byte[] GetEncodedContents();
    public virtual void Encode(BcpgOutputStream bcpgOut);
}
public class Org.BouncyCastle.Bcpg.PublicSubkeyPacket : PublicKeyPacket {
    internal PublicSubkeyPacket(BcpgInputStream bcpgIn);
    public PublicSubkeyPacket(PublicKeyAlgorithmTag algorithm, DateTime time, IBcpgKey key);
    public virtual void Encode(BcpgOutputStream bcpgOut);
}
public class Org.BouncyCastle.Bcpg.RevocationKey : SignatureSubpacket {
    public RevocationKeyTag SignatureClass { get; }
    public PublicKeyAlgorithmTag Algorithm { get; }
    public RevocationKey(bool isCritical, Byte[] data);
    public RevocationKey(bool isCritical, RevocationKeyTag signatureClass, PublicKeyAlgorithmTag keyAlgorithm, Byte[] fingerprint);
    private static Byte[] CreateData(RevocationKeyTag signatureClass, PublicKeyAlgorithmTag keyAlgorithm, Byte[] fingerprint);
    public virtual RevocationKeyTag get_SignatureClass();
    public virtual PublicKeyAlgorithmTag get_Algorithm();
    public virtual Byte[] GetFingerprint();
}
public enum Org.BouncyCastle.Bcpg.RevocationKeyTag : Enum {
    public byte value__;
    public static RevocationKeyTag ClassDefault;
    public static RevocationKeyTag ClassSensitive;
}
public class Org.BouncyCastle.Bcpg.RevocationReason : SignatureSubpacket {
    public RevocationReason(bool isCritical, Byte[] data);
    public RevocationReason(bool isCritical, RevocationReasonTag reason, string description);
    private static Byte[] CreateData(RevocationReasonTag reason, string description);
    public virtual RevocationReasonTag GetRevocationReason();
    public virtual string GetRevocationDescription();
}
public enum Org.BouncyCastle.Bcpg.RevocationReasonTag : Enum {
    public byte value__;
    public static RevocationReasonTag NoReason;
    public static RevocationReasonTag KeySuperseded;
    public static RevocationReasonTag KeyCompromised;
    public static RevocationReasonTag KeyRetired;
    public static RevocationReasonTag UserNoLongerValid;
}
public class Org.BouncyCastle.Bcpg.RsaPublicBcpgKey : BcpgObject {
    private MPInteger n;
    private MPInteger e;
    public BigInteger PublicExponent { get; }
    public BigInteger Modulus { get; }
    public string Format { get; }
    public RsaPublicBcpgKey(BcpgInputStream bcpgIn);
    public RsaPublicBcpgKey(BigInteger n, BigInteger e);
    public BigInteger get_PublicExponent();
    public BigInteger get_Modulus();
    public sealed virtual string get_Format();
    public virtual Byte[] GetEncoded();
    public virtual void Encode(BcpgOutputStream bcpgOut);
}
public class Org.BouncyCastle.Bcpg.RsaSecretBcpgKey : BcpgObject {
    private MPInteger d;
    private MPInteger p;
    private MPInteger q;
    private MPInteger u;
    private BigInteger expP;
    private BigInteger expQ;
    private BigInteger crt;
    public BigInteger Modulus { get; }
    public BigInteger PrivateExponent { get; }
    public BigInteger PrimeP { get; }
    public BigInteger PrimeQ { get; }
    public BigInteger PrimeExponentP { get; }
    public BigInteger PrimeExponentQ { get; }
    public BigInteger CrtCoefficient { get; }
    public string Format { get; }
    public RsaSecretBcpgKey(BcpgInputStream bcpgIn);
    public RsaSecretBcpgKey(BigInteger d, BigInteger p, BigInteger q);
    public BigInteger get_Modulus();
    public BigInteger get_PrivateExponent();
    public BigInteger get_PrimeP();
    public BigInteger get_PrimeQ();
    public BigInteger get_PrimeExponentP();
    public BigInteger get_PrimeExponentQ();
    public BigInteger get_CrtCoefficient();
    public sealed virtual string get_Format();
    public virtual Byte[] GetEncoded();
    public virtual void Encode(BcpgOutputStream bcpgOut);
}
public class Org.BouncyCastle.Bcpg.S2k : BcpgObject {
    private static int ExpBias;
    public static int Simple;
    public static int Salted;
    public static int SaltedAndIterated;
    public static int GnuDummyS2K;
    internal int type;
    internal HashAlgorithmTag algorithm;
    internal Byte[] iv;
    internal int itCount;
    internal int protectionMode;
    public int Type { get; }
    public HashAlgorithmTag HashAlgorithm { get; }
    public long IterationCount { get; }
    public int ProtectionMode { get; }
    internal S2k(Stream inStr);
    public S2k(HashAlgorithmTag algorithm);
    public S2k(HashAlgorithmTag algorithm, Byte[] iv);
    public S2k(HashAlgorithmTag algorithm, Byte[] iv, int itCount);
    public int get_Type();
    public HashAlgorithmTag get_HashAlgorithm();
    public Byte[] GetIV();
    [ObsoleteAttribute("Use 'IterationCount' property instead")]
public long GetIterationCount();
    public long get_IterationCount();
    public int get_ProtectionMode();
    public virtual void Encode(BcpgOutputStream bcpgOut);
}
public class Org.BouncyCastle.Bcpg.SecretKeyPacket : ContainedPacket {
    public static int UsageNone;
    public static int UsageChecksum;
    public static int UsageSha1;
    private PublicKeyPacket pubKeyPacket;
    private Byte[] secKeyData;
    private int s2kUsage;
    private SymmetricKeyAlgorithmTag encAlgorithm;
    private S2k s2k;
    private Byte[] iv;
    public SymmetricKeyAlgorithmTag EncAlgorithm { get; }
    public int S2kUsage { get; }
    public S2k S2k { get; }
    public PublicKeyPacket PublicKeyPacket { get; }
    internal SecretKeyPacket(BcpgInputStream bcpgIn);
    public SecretKeyPacket(PublicKeyPacket pubKeyPacket, SymmetricKeyAlgorithmTag encAlgorithm, S2k s2k, Byte[] iv, Byte[] secKeyData);
    public SecretKeyPacket(PublicKeyPacket pubKeyPacket, SymmetricKeyAlgorithmTag encAlgorithm, int s2kUsage, S2k s2k, Byte[] iv, Byte[] secKeyData);
    public SymmetricKeyAlgorithmTag get_EncAlgorithm();
    public int get_S2kUsage();
    public Byte[] GetIV();
    public S2k get_S2k();
    public PublicKeyPacket get_PublicKeyPacket();
    public Byte[] GetSecretKeyData();
    public Byte[] GetEncodedContents();
    public virtual void Encode(BcpgOutputStream bcpgOut);
}
public class Org.BouncyCastle.Bcpg.SecretSubkeyPacket : SecretKeyPacket {
    internal SecretSubkeyPacket(BcpgInputStream bcpgIn);
    public SecretSubkeyPacket(PublicKeyPacket pubKeyPacket, SymmetricKeyAlgorithmTag encAlgorithm, S2k s2k, Byte[] iv, Byte[] secKeyData);
    public SecretSubkeyPacket(PublicKeyPacket pubKeyPacket, SymmetricKeyAlgorithmTag encAlgorithm, int s2kUsage, S2k s2k, Byte[] iv, Byte[] secKeyData);
    public virtual void Encode(BcpgOutputStream bcpgOut);
}
public class Org.BouncyCastle.Bcpg.Sig.EmbeddedSignature : SignatureSubpacket {
    public EmbeddedSignature(bool critical, Byte[] data);
}
public class Org.BouncyCastle.Bcpg.Sig.Exportable : SignatureSubpacket {
    public Exportable(bool critical, Byte[] data);
    public Exportable(bool critical, bool isExportable);
    private static Byte[] BooleanToByteArray(bool val);
    public bool IsExportable();
}
public class Org.BouncyCastle.Bcpg.Sig.IssuerKeyId : SignatureSubpacket {
    public long KeyId { get; }
    public IssuerKeyId(bool critical, Byte[] data);
    public IssuerKeyId(bool critical, long keyId);
    protected static Byte[] KeyIdToBytes(long keyId);
    public long get_KeyId();
}
public class Org.BouncyCastle.Bcpg.Sig.KeyExpirationTime : SignatureSubpacket {
    public long Time { get; }
    public KeyExpirationTime(bool critical, Byte[] data);
    public KeyExpirationTime(bool critical, long seconds);
    protected static Byte[] TimeToBytes(long t);
    public long get_Time();
}
public class Org.BouncyCastle.Bcpg.Sig.KeyFlags : SignatureSubpacket {
    public static int CertifyOther;
    public static int SignData;
    public static int EncryptComms;
    public static int EncryptStorage;
    public static int Split;
    public static int Authentication;
    public static int Shared;
    public int Flags { get; }
    public KeyFlags(bool critical, Byte[] data);
    public KeyFlags(bool critical, int flags);
    private static Byte[] IntToByteArray(int v);
    public int get_Flags();
}
public class Org.BouncyCastle.Bcpg.Sig.NotationData : SignatureSubpacket {
    public static int HeaderFlagLength;
    public static int HeaderNameLength;
    public static int HeaderValueLength;
    public bool IsHumanReadable { get; }
    public NotationData(bool critical, Byte[] data);
    public NotationData(bool critical, bool humanReadable, string notationName, string notationValue);
    private static Byte[] createData(bool humanReadable, string notationName, string notationValue);
    public bool get_IsHumanReadable();
    public string GetNotationName();
    public string GetNotationValue();
    public Byte[] GetNotationValueBytes();
}
public class Org.BouncyCastle.Bcpg.Sig.PreferredAlgorithms : SignatureSubpacket {
    public PreferredAlgorithms(SignatureSubpacketTag type, bool critical, Byte[] data);
    public PreferredAlgorithms(SignatureSubpacketTag type, bool critical, Int32[] preferences);
    private static Byte[] IntToByteArray(Int32[] v);
    public Int32[] GetPreferences();
}
public class Org.BouncyCastle.Bcpg.Sig.PrimaryUserId : SignatureSubpacket {
    public PrimaryUserId(bool critical, Byte[] data);
    public PrimaryUserId(bool critical, bool isPrimaryUserId);
    private static Byte[] BooleanToByteArray(bool val);
    public bool IsPrimaryUserId();
}
public class Org.BouncyCastle.Bcpg.Sig.Revocable : SignatureSubpacket {
    public Revocable(bool critical, Byte[] data);
    public Revocable(bool critical, bool isRevocable);
    private static Byte[] BooleanToByteArray(bool value);
    public bool IsRevocable();
}
public class Org.BouncyCastle.Bcpg.Sig.SignatureCreationTime : SignatureSubpacket {
    public SignatureCreationTime(bool critical, Byte[] data);
    public SignatureCreationTime(bool critical, DateTime date);
    protected static Byte[] TimeToBytes(DateTime time);
    public DateTime GetTime();
}
public class Org.BouncyCastle.Bcpg.Sig.SignatureExpirationTime : SignatureSubpacket {
    public long Time { get; }
    public SignatureExpirationTime(bool critical, Byte[] data);
    public SignatureExpirationTime(bool critical, long seconds);
    protected static Byte[] TimeToBytes(long t);
    public long get_Time();
}
public class Org.BouncyCastle.Bcpg.Sig.SignerUserId : SignatureSubpacket {
    public SignerUserId(bool critical, Byte[] data);
    public SignerUserId(bool critical, string userId);
    private static Byte[] UserIdToBytes(string id);
    public string GetId();
}
public class Org.BouncyCastle.Bcpg.Sig.TrustSignature : SignatureSubpacket {
    public int Depth { get; }
    public int TrustAmount { get; }
    public TrustSignature(bool critical, Byte[] data);
    public TrustSignature(bool critical, int depth, int trustAmount);
    private static Byte[] IntToByteArray(int v1, int v2);
    public int get_Depth();
    public int get_TrustAmount();
}
public class Org.BouncyCastle.Bcpg.SignaturePacket : ContainedPacket {
    private int version;
    private int signatureType;
    private long creationTime;
    private long keyId;
    private PublicKeyAlgorithmTag keyAlgorithm;
    private HashAlgorithmTag hashAlgorithm;
    private MPInteger[] signature;
    private Byte[] fingerprint;
    private SignatureSubpacket[] hashedData;
    private SignatureSubpacket[] unhashedData;
    private Byte[] signatureEncoding;
    public int Version { get; }
    public int SignatureType { get; }
    public long KeyId { get; }
    public PublicKeyAlgorithmTag KeyAlgorithm { get; }
    public HashAlgorithmTag HashAlgorithm { get; }
    public long CreationTime { get; }
    internal SignaturePacket(BcpgInputStream bcpgIn);
    public SignaturePacket(int signatureType, long keyId, PublicKeyAlgorithmTag keyAlgorithm, HashAlgorithmTag hashAlgorithm, SignatureSubpacket[] hashedData, SignatureSubpacket[] unhashedData, Byte[] fingerprint, MPInteger[] signature);
    public SignaturePacket(int version, int signatureType, long keyId, PublicKeyAlgorithmTag keyAlgorithm, HashAlgorithmTag hashAlgorithm, long creationTime, Byte[] fingerprint, MPInteger[] signature);
    public SignaturePacket(int version, int signatureType, long keyId, PublicKeyAlgorithmTag keyAlgorithm, HashAlgorithmTag hashAlgorithm, SignatureSubpacket[] hashedData, SignatureSubpacket[] unhashedData, Byte[] fingerprint, MPInteger[] signature);
    public int get_Version();
    public int get_SignatureType();
    public long get_KeyId();
    public Byte[] GetSignatureTrailer();
    public PublicKeyAlgorithmTag get_KeyAlgorithm();
    public HashAlgorithmTag get_HashAlgorithm();
    public MPInteger[] GetSignature();
    public Byte[] GetSignatureBytes();
    public SignatureSubpacket[] GetHashedSubPackets();
    public SignatureSubpacket[] GetUnhashedSubPackets();
    public long get_CreationTime();
    public virtual void Encode(BcpgOutputStream bcpgOut);
    private static void EncodeLengthAndData(BcpgOutputStream pOut, Byte[] data);
    private static Byte[] GetEncodedSubpackets(SignatureSubpacket[] ps);
    private void setCreationTime();
}
public class Org.BouncyCastle.Bcpg.SignatureSubpacket : object {
    private SignatureSubpacketTag type;
    private bool critical;
    internal Byte[] data;
    public SignatureSubpacketTag SubpacketType { get; }
    protected internal SignatureSubpacket(SignatureSubpacketTag type, bool critical, Byte[] data);
    public SignatureSubpacketTag get_SubpacketType();
    public bool IsCritical();
    public Byte[] GetData();
    public void Encode(Stream os);
}
public class Org.BouncyCastle.Bcpg.SignatureSubpacketsParser : object {
    private Stream input;
    public SignatureSubpacketsParser(Stream input);
    public SignatureSubpacket ReadPacket();
}
public enum Org.BouncyCastle.Bcpg.SignatureSubpacketTag : Enum {
    public int value__;
    public static SignatureSubpacketTag CreationTime;
    public static SignatureSubpacketTag ExpireTime;
    public static SignatureSubpacketTag Exportable;
    public static SignatureSubpacketTag TrustSig;
    public static SignatureSubpacketTag RegExp;
    public static SignatureSubpacketTag Revocable;
    public static SignatureSubpacketTag KeyExpireTime;
    public static SignatureSubpacketTag Placeholder;
    public static SignatureSubpacketTag PreferredSymmetricAlgorithms;
    public static SignatureSubpacketTag RevocationKey;
    public static SignatureSubpacketTag IssuerKeyId;
    public static SignatureSubpacketTag NotationData;
    public static SignatureSubpacketTag PreferredHashAlgorithms;
    public static SignatureSubpacketTag PreferredCompressionAlgorithms;
    public static SignatureSubpacketTag KeyServerPreferences;
    public static SignatureSubpacketTag PreferredKeyServer;
    public static SignatureSubpacketTag PrimaryUserId;
    public static SignatureSubpacketTag PolicyUrl;
    public static SignatureSubpacketTag KeyFlags;
    public static SignatureSubpacketTag SignerUserId;
    public static SignatureSubpacketTag RevocationReason;
    public static SignatureSubpacketTag Features;
    public static SignatureSubpacketTag SignatureTarget;
    public static SignatureSubpacketTag EmbeddedSignature;
}
public class Org.BouncyCastle.Bcpg.SymmetricEncDataPacket : InputStreamPacket {
    public SymmetricEncDataPacket(BcpgInputStream bcpgIn);
}
public class Org.BouncyCastle.Bcpg.SymmetricEncIntegrityPacket : InputStreamPacket {
    internal int version;
    internal SymmetricEncIntegrityPacket(BcpgInputStream bcpgIn);
}
public enum Org.BouncyCastle.Bcpg.SymmetricKeyAlgorithmTag : Enum {
    public int value__;
    public static SymmetricKeyAlgorithmTag Null;
    public static SymmetricKeyAlgorithmTag Idea;
    public static SymmetricKeyAlgorithmTag TripleDes;
    public static SymmetricKeyAlgorithmTag Cast5;
    public static SymmetricKeyAlgorithmTag Blowfish;
    public static SymmetricKeyAlgorithmTag Safer;
    public static SymmetricKeyAlgorithmTag Des;
    public static SymmetricKeyAlgorithmTag Aes128;
    public static SymmetricKeyAlgorithmTag Aes192;
    public static SymmetricKeyAlgorithmTag Aes256;
    public static SymmetricKeyAlgorithmTag Twofish;
}
public class Org.BouncyCastle.Bcpg.SymmetricKeyEncSessionPacket : ContainedPacket {
    private int version;
    private SymmetricKeyAlgorithmTag encAlgorithm;
    private S2k s2k;
    private Byte[] secKeyData;
    public SymmetricKeyAlgorithmTag EncAlgorithm { get; }
    public S2k S2k { get; }
    public int Version { get; }
    public SymmetricKeyEncSessionPacket(BcpgInputStream bcpgIn);
    public SymmetricKeyEncSessionPacket(SymmetricKeyAlgorithmTag encAlgorithm, S2k s2k, Byte[] secKeyData);
    public SymmetricKeyAlgorithmTag get_EncAlgorithm();
    public S2k get_S2k();
    public Byte[] GetSecKeyData();
    public int get_Version();
    public virtual void Encode(BcpgOutputStream bcpgOut);
}
public class Org.BouncyCastle.Bcpg.TrustPacket : ContainedPacket {
    private Byte[] levelAndTrustAmount;
    public TrustPacket(BcpgInputStream bcpgIn);
    public TrustPacket(int trustCode);
    public Byte[] GetLevelAndTrustAmount();
    public virtual void Encode(BcpgOutputStream bcpgOut);
}
public class Org.BouncyCastle.Bcpg.UserAttributePacket : ContainedPacket {
    private UserAttributeSubpacket[] subpackets;
    public UserAttributePacket(BcpgInputStream bcpgIn);
    public UserAttributePacket(UserAttributeSubpacket[] subpackets);
    public UserAttributeSubpacket[] GetSubpackets();
    public virtual void Encode(BcpgOutputStream bcpgOut);
}
public class Org.BouncyCastle.Bcpg.UserAttributeSubpacket : object {
    private UserAttributeSubpacketTag type;
    private Byte[] data;
    public UserAttributeSubpacketTag SubpacketType { get; }
    internal UserAttributeSubpacket(UserAttributeSubpacketTag type, Byte[] data);
    public UserAttributeSubpacketTag get_SubpacketType();
    public Byte[] GetData();
    public void Encode(Stream os);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
}
public class Org.BouncyCastle.Bcpg.UserAttributeSubpacketsParser : object {
    private Stream input;
    public UserAttributeSubpacketsParser(Stream input);
    public UserAttributeSubpacket ReadPacket();
}
public enum Org.BouncyCastle.Bcpg.UserAttributeSubpacketTag : Enum {
    public int value__;
    public static UserAttributeSubpacketTag ImageAttribute;
}
public class Org.BouncyCastle.Bcpg.UserIdPacket : ContainedPacket {
    private Byte[] idData;
    public UserIdPacket(BcpgInputStream bcpgIn);
    public UserIdPacket(string id);
    public string GetId();
    public virtual void Encode(BcpgOutputStream bcpgOut);
}
internal class Org.BouncyCastle.Cms.BaseDigestCalculator : object {
    private Byte[] digest;
    internal BaseDigestCalculator(Byte[] digest);
    public sealed virtual Byte[] GetDigest();
}
public class Org.BouncyCastle.Cms.CmsAttributeTableGenerationException : CmsException {
    public CmsAttributeTableGenerationException(string name);
    public CmsAttributeTableGenerationException(string name, Exception e);
}
public interface Org.BouncyCastle.Cms.CmsAttributeTableGenerator {
    public abstract virtual AttributeTable GetAttributes(IDictionary parameters);
}
public enum Org.BouncyCastle.Cms.CmsAttributeTableParameter : Enum {
    public int value__;
    public static CmsAttributeTableParameter ContentType;
    public static CmsAttributeTableParameter Digest;
    public static CmsAttributeTableParameter Signature;
    public static CmsAttributeTableParameter DigestAlgorithmIdentifier;
}
public class Org.BouncyCastle.Cms.CmsAuthenticatedData : object {
    internal RecipientInformationStore recipientInfoStore;
    internal ContentInfo contentInfo;
    private AlgorithmIdentifier macAlg;
    private Asn1Set authAttrs;
    private Asn1Set unauthAttrs;
    private Byte[] mac;
    public AlgorithmIdentifier MacAlgorithmID { get; }
    public string MacAlgOid { get; }
    public ContentInfo ContentInfo { get; }
    public CmsAuthenticatedData(Byte[] authData);
    public CmsAuthenticatedData(Stream authData);
    public CmsAuthenticatedData(ContentInfo contentInfo);
    public Byte[] GetMac();
    public AlgorithmIdentifier get_MacAlgorithmID();
    public string get_MacAlgOid();
    public RecipientInformationStore GetRecipientInfos();
    public ContentInfo get_ContentInfo();
    public AttributeTable GetAuthAttrs();
    public AttributeTable GetUnauthAttrs();
    public Byte[] GetEncoded();
}
public class Org.BouncyCastle.Cms.CmsAuthenticatedDataGenerator : CmsAuthenticatedGenerator {
    public CmsAuthenticatedDataGenerator(SecureRandom rand);
    private CmsAuthenticatedData Generate(CmsProcessable content, string macOid, CipherKeyGenerator keyGen);
    public CmsAuthenticatedData Generate(CmsProcessable content, string encryptionOid);
}
public class Org.BouncyCastle.Cms.CmsAuthenticatedDataParser : CmsContentInfoParser {
    internal RecipientInformationStore _recipientInfoStore;
    internal AuthenticatedDataParser authData;
    private AlgorithmIdentifier macAlg;
    private Byte[] mac;
    private AttributeTable authAttrs;
    private AttributeTable unauthAttrs;
    private bool authAttrNotRead;
    private bool unauthAttrNotRead;
    public AlgorithmIdentifier MacAlgorithmID { get; }
    public string MacAlgOid { get; }
    public Asn1Object MacAlgParams { get; }
    public CmsAuthenticatedDataParser(Byte[] envelopedData);
    public CmsAuthenticatedDataParser(Stream envelopedData);
    public AlgorithmIdentifier get_MacAlgorithmID();
    public string get_MacAlgOid();
    public Asn1Object get_MacAlgParams();
    public RecipientInformationStore GetRecipientInfos();
    public Byte[] GetMac();
    public AttributeTable GetAuthAttrs();
    public AttributeTable GetUnauthAttrs();
}
public class Org.BouncyCastle.Cms.CmsAuthenticatedDataStreamGenerator : CmsAuthenticatedGenerator {
    private int _bufferSize;
    private bool _berEncodeRecipientSet;
    public CmsAuthenticatedDataStreamGenerator(SecureRandom rand);
    public void SetBufferSize(int bufferSize);
    public void SetBerEncodeRecipients(bool berEncodeRecipientSet);
    private Stream Open(Stream outStr, string macOid, CipherKeyGenerator keyGen);
    protected Stream Open(Stream outStr, AlgorithmIdentifier macAlgId, ICipherParameters cipherParameters, Asn1EncodableVector recipientInfos);
    public Stream Open(Stream outStr, string encryptionOid);
    public Stream Open(Stream outStr, string encryptionOid, int keySize);
}
public class Org.BouncyCastle.Cms.CmsAuthenticatedGenerator : CmsEnvelopedGenerator {
    public CmsAuthenticatedGenerator(SecureRandom rand);
}
internal class Org.BouncyCastle.Cms.CmsAuthEnvelopedData : object {
    internal RecipientInformationStore recipientInfoStore;
    internal ContentInfo contentInfo;
    private OriginatorInfo originator;
    private AlgorithmIdentifier authEncAlg;
    private Asn1Set authAttrs;
    private Byte[] mac;
    private Asn1Set unauthAttrs;
    public CmsAuthEnvelopedData(Byte[] authEnvData);
    public CmsAuthEnvelopedData(Stream authEnvData);
    public CmsAuthEnvelopedData(ContentInfo contentInfo);
}
internal class Org.BouncyCastle.Cms.CmsAuthEnvelopedGenerator : object {
    public static string Aes128Ccm;
    public static string Aes192Ccm;
    public static string Aes256Ccm;
    public static string Aes128Gcm;
    public static string Aes192Gcm;
    public static string Aes256Gcm;
    private static CmsAuthEnvelopedGenerator();
}
public class Org.BouncyCastle.Cms.CmsCompressedData : object {
    internal ContentInfo contentInfo;
    public ContentInfo ContentInfo { get; }
    public CmsCompressedData(Byte[] compressedData);
    public CmsCompressedData(Stream compressedDataStream);
    public CmsCompressedData(ContentInfo contentInfo);
    public Byte[] GetContent();
    public Byte[] GetContent(int limit);
    public ContentInfo get_ContentInfo();
    public Byte[] GetEncoded();
}
public class Org.BouncyCastle.Cms.CmsCompressedDataGenerator : object {
    public static string ZLib;
    public CmsCompressedData Generate(CmsProcessable content, string compressionOid);
}
public class Org.BouncyCastle.Cms.CmsCompressedDataParser : CmsContentInfoParser {
    public CmsCompressedDataParser(Byte[] compressedData);
    public CmsCompressedDataParser(Stream compressedData);
    public CmsTypedStream GetContent();
}
public class Org.BouncyCastle.Cms.CmsCompressedDataStreamGenerator : object {
    public static string ZLib;
    private int _bufferSize;
    public void SetBufferSize(int bufferSize);
    public Stream Open(Stream outStream, string compressionOID);
    public Stream Open(Stream outStream, string contentOID, string compressionOID);
}
public class Org.BouncyCastle.Cms.CmsContentInfoParser : object {
    protected ContentInfoParser contentInfo;
    protected Stream data;
    protected CmsContentInfoParser(Stream data);
    public void Close();
}
public class Org.BouncyCastle.Cms.CmsEnvelopedData : object {
    internal RecipientInformationStore recipientInfoStore;
    internal ContentInfo contentInfo;
    private AlgorithmIdentifier encAlg;
    private Asn1Set unprotectedAttributes;
    public AlgorithmIdentifier EncryptionAlgorithmID { get; }
    public string EncryptionAlgOid { get; }
    public ContentInfo ContentInfo { get; }
    public CmsEnvelopedData(Byte[] envelopedData);
    public CmsEnvelopedData(Stream envelopedData);
    public CmsEnvelopedData(ContentInfo contentInfo);
    public AlgorithmIdentifier get_EncryptionAlgorithmID();
    public string get_EncryptionAlgOid();
    public RecipientInformationStore GetRecipientInfos();
    public ContentInfo get_ContentInfo();
    public AttributeTable GetUnprotectedAttributes();
    public Byte[] GetEncoded();
}
public class Org.BouncyCastle.Cms.CmsEnvelopedDataGenerator : CmsEnvelopedGenerator {
    public CmsEnvelopedDataGenerator(SecureRandom rand);
    private CmsEnvelopedData Generate(CmsProcessable content, string encryptionOid, CipherKeyGenerator keyGen);
    public CmsEnvelopedData Generate(CmsProcessable content, string encryptionOid);
    public CmsEnvelopedData Generate(CmsProcessable content, string encryptionOid, int keySize);
}
public class Org.BouncyCastle.Cms.CmsEnvelopedDataParser : CmsContentInfoParser {
    internal RecipientInformationStore recipientInfoStore;
    internal EnvelopedDataParser envelopedData;
    private AlgorithmIdentifier _encAlg;
    private AttributeTable _unprotectedAttributes;
    private bool _attrNotRead;
    public AlgorithmIdentifier EncryptionAlgorithmID { get; }
    public string EncryptionAlgOid { get; }
    public Asn1Object EncryptionAlgParams { get; }
    public CmsEnvelopedDataParser(Byte[] envelopedData);
    public CmsEnvelopedDataParser(Stream envelopedData);
    public AlgorithmIdentifier get_EncryptionAlgorithmID();
    public string get_EncryptionAlgOid();
    public Asn1Object get_EncryptionAlgParams();
    public RecipientInformationStore GetRecipientInfos();
    public AttributeTable GetUnprotectedAttributes();
}
public class Org.BouncyCastle.Cms.CmsEnvelopedDataStreamGenerator : CmsEnvelopedGenerator {
    private object _originatorInfo;
    private object _unprotectedAttributes;
    private int _bufferSize;
    private bool _berEncodeRecipientSet;
    private DerInteger Version { get; }
    public CmsEnvelopedDataStreamGenerator(SecureRandom rand);
    public void SetBufferSize(int bufferSize);
    public void SetBerEncodeRecipients(bool berEncodeRecipientSet);
    private DerInteger get_Version();
    private Stream Open(Stream outStream, string encryptionOid, CipherKeyGenerator keyGen);
    private Stream Open(Stream outStream, AlgorithmIdentifier encAlgID, ICipherParameters cipherParameters, Asn1EncodableVector recipientInfos);
    public Stream Open(Stream outStream, string encryptionOid);
    public Stream Open(Stream outStream, string encryptionOid, int keySize);
}
public class Org.BouncyCastle.Cms.CmsEnvelopedGenerator : object {
    public static string IdeaCbc;
    public static string Cast5Cbc;
    internal static Int16[] rc2Table;
    public static string DesEde3Cbc;
    public static string RC2Cbc;
    public static string Aes128Cbc;
    public static string Aes192Cbc;
    public static string Aes256Cbc;
    public static string Camellia128Cbc;
    public static string Camellia192Cbc;
    public static string Camellia256Cbc;
    public static string SeedCbc;
    public static string DesEde3Wrap;
    public static string Aes128Wrap;
    public static string Aes192Wrap;
    public static string Aes256Wrap;
    public static string Camellia128Wrap;
    public static string Camellia192Wrap;
    public static string Camellia256Wrap;
    public static string SeedWrap;
    public static string ECDHSha1Kdf;
    public static string ECMqvSha1Kdf;
    internal IList recipientInfoGenerators;
    internal SecureRandom rand;
    internal CmsAttributeTableGenerator unprotectedAttributeGenerator;
    public CmsAttributeTableGenerator UnprotectedAttributeGenerator { get; public set; }
    public CmsEnvelopedGenerator(SecureRandom rand);
    private static CmsEnvelopedGenerator();
    public CmsAttributeTableGenerator get_UnprotectedAttributeGenerator();
    public void set_UnprotectedAttributeGenerator(CmsAttributeTableGenerator value);
    public void AddKeyTransRecipient(X509Certificate cert);
    public void AddKeyTransRecipient(AsymmetricKeyParameter pubKey, Byte[] subKeyId);
    public void AddKekRecipient(string keyAlgorithm, KeyParameter key, Byte[] keyIdentifier);
    public void AddKekRecipient(string keyAlgorithm, KeyParameter key, KekIdentifier kekIdentifier);
    public void AddPasswordRecipient(CmsPbeKey pbeKey, string kekAlgorithmOid);
    public void AddKeyAgreementRecipient(string agreementAlgorithm, AsymmetricKeyParameter senderPrivateKey, AsymmetricKeyParameter senderPublicKey, X509Certificate recipientCert, string cekWrapAlgorithm);
    public void AddKeyAgreementRecipients(string agreementAlgorithm, AsymmetricKeyParameter senderPrivateKey, AsymmetricKeyParameter senderPublicKey, ICollection recipientCerts, string cekWrapAlgorithm);
    protected internal virtual AlgorithmIdentifier GetAlgorithmIdentifier(string encryptionOid, KeyParameter encKey, Asn1Encodable asn1Params, ICipherParameters& cipherParameters);
    protected internal virtual Asn1Encodable GenerateAsn1Parameters(string encryptionOid, Byte[] encKeyBytes);
}
internal class Org.BouncyCastle.Cms.CmsEnvelopedHelper : object {
    internal static CmsEnvelopedHelper Instance;
    private static IDictionary KeySizes;
    private static IDictionary BaseCipherNames;
    private static CmsEnvelopedHelper();
    private string GetAsymmetricEncryptionAlgName(string encryptionAlgOid);
    internal IBufferedCipher CreateAsymmetricCipher(string encryptionOid);
    internal IWrapper CreateWrapper(string encryptionOid);
    internal string GetRfc3211WrapperName(string oid);
    internal int GetKeySize(string oid);
    internal static RecipientInformationStore BuildRecipientInformationStore(Asn1Set recipientInfos, CmsSecureReadable secureReadable);
    private static void ReadRecipientInfo(IList infos, RecipientInfo info, CmsSecureReadable secureReadable);
}
public class Org.BouncyCastle.Cms.CmsException : Exception {
    public CmsException(string msg);
    public CmsException(string msg, Exception e);
}
public abstract class Org.BouncyCastle.Cms.CmsPbeKey : object {
    internal Char[] password;
    internal Byte[] salt;
    internal int iterationCount;
    [ObsoleteAttribute("Will be removed")]
public string Password { get; }
    public Byte[] Salt { get; }
    public int IterationCount { get; }
    public string Algorithm { get; }
    public string Format { get; }
    [ObsoleteAttribute("Use version taking 'char[]' instead")]
public CmsPbeKey(string password, Byte[] salt, int iterationCount);
    [ObsoleteAttribute("Use version taking 'char[]' instead")]
public CmsPbeKey(string password, AlgorithmIdentifier keyDerivationAlgorithm);
    public CmsPbeKey(Char[] password, Byte[] salt, int iterationCount);
    public CmsPbeKey(Char[] password, AlgorithmIdentifier keyDerivationAlgorithm);
    protected virtual void Finalize();
    public string get_Password();
    public Byte[] get_Salt();
    [ObsoleteAttribute("Use 'Salt' property instead")]
public Byte[] GetSalt();
    public int get_IterationCount();
    public string get_Algorithm();
    public string get_Format();
    public Byte[] GetEncoded();
    internal abstract virtual KeyParameter GetEncoded(string algorithmOid);
}
public interface Org.BouncyCastle.Cms.CmsProcessable {
    public abstract virtual void Write(Stream outStream);
    [ObsoleteAttribute]
public abstract virtual object GetContent();
}
public class Org.BouncyCastle.Cms.CmsProcessableByteArray : object {
    private Byte[] bytes;
    public CmsProcessableByteArray(Byte[] bytes);
    public sealed virtual Stream GetInputStream();
    public virtual void Write(Stream zOut);
    public virtual object GetContent();
}
public class Org.BouncyCastle.Cms.CmsProcessableFile : object {
    private static int DefaultBufSize;
    private FileInfo _file;
    private int _bufSize;
    public CmsProcessableFile(FileInfo file);
    public CmsProcessableFile(FileInfo file, int bufSize);
    public virtual Stream GetInputStream();
    public virtual void Write(Stream zOut);
    [ObsoleteAttribute]
public virtual object GetContent();
}
public class Org.BouncyCastle.Cms.CmsProcessableInputStream : object {
    private Stream input;
    private bool used;
    public CmsProcessableInputStream(Stream input);
    public sealed virtual Stream GetInputStream();
    public sealed virtual void Write(Stream output);
    [ObsoleteAttribute]
public sealed virtual object GetContent();
    private void CheckSingleUsage();
}
internal interface Org.BouncyCastle.Cms.CmsReadable {
    public abstract virtual Stream GetInputStream();
}
internal interface Org.BouncyCastle.Cms.CmsSecureReadable {
    public AlgorithmIdentifier Algorithm { get; }
    public object CryptoObject { get; }
    public abstract virtual AlgorithmIdentifier get_Algorithm();
    public abstract virtual object get_CryptoObject();
    public abstract virtual CmsReadable GetReadable(KeyParameter key);
}
public class Org.BouncyCastle.Cms.CmsSignedData : object {
    private static CmsSignedHelper Helper;
    private CmsProcessable signedContent;
    private SignedData signedData;
    private ContentInfo contentInfo;
    private SignerInformationStore signerInfoStore;
    private IX509Store attrCertStore;
    private IX509Store certificateStore;
    private IX509Store crlStore;
    private IDictionary hashes;
    public int Version { get; }
    [ObsoleteAttribute("Use 'SignedContentType' property instead.")]
public string SignedContentTypeOid { get; }
    public DerObjectIdentifier SignedContentType { get; }
    public CmsProcessable SignedContent { get; }
    public ContentInfo ContentInfo { get; }
    private CmsSignedData(CmsSignedData c);
    public CmsSignedData(Byte[] sigBlock);
    public CmsSignedData(CmsProcessable signedContent, Byte[] sigBlock);
    public CmsSignedData(IDictionary hashes, Byte[] sigBlock);
    public CmsSignedData(CmsProcessable signedContent, Stream sigData);
    public CmsSignedData(Stream sigData);
    public CmsSignedData(CmsProcessable signedContent, ContentInfo sigData);
    public CmsSignedData(IDictionary hashes, ContentInfo sigData);
    public CmsSignedData(ContentInfo sigData);
    private static CmsSignedData();
    public int get_Version();
    public SignerInformationStore GetSignerInfos();
    public IX509Store GetAttributeCertificates(string type);
    public IX509Store GetCertificates(string type);
    public IX509Store GetCrls(string type);
    public string get_SignedContentTypeOid();
    public DerObjectIdentifier get_SignedContentType();
    public CmsProcessable get_SignedContent();
    public ContentInfo get_ContentInfo();
    public Byte[] GetEncoded();
    public static CmsSignedData ReplaceSigners(CmsSignedData signedData, SignerInformationStore signerInformationStore);
    public static CmsSignedData ReplaceCertificatesAndCrls(CmsSignedData signedData, IX509Store x509Certs, IX509Store x509Crls, IX509Store x509AttrCerts);
}
public class Org.BouncyCastle.Cms.CmsSignedDataGenerator : CmsSignedGenerator {
    private static CmsSignedHelper Helper;
    private IList signerInfs;
    public CmsSignedDataGenerator(SecureRandom rand);
    private static CmsSignedDataGenerator();
    public void AddSigner(AsymmetricKeyParameter privateKey, X509Certificate cert, string digestOID);
    public void AddSigner(AsymmetricKeyParameter privateKey, X509Certificate cert, string encryptionOID, string digestOID);
    public void AddSigner(AsymmetricKeyParameter privateKey, Byte[] subjectKeyID, string digestOID);
    public void AddSigner(AsymmetricKeyParameter privateKey, Byte[] subjectKeyID, string encryptionOID, string digestOID);
    public void AddSigner(AsymmetricKeyParameter privateKey, X509Certificate cert, string digestOID, AttributeTable signedAttr, AttributeTable unsignedAttr);
    public void AddSigner(AsymmetricKeyParameter privateKey, X509Certificate cert, string encryptionOID, string digestOID, AttributeTable signedAttr, AttributeTable unsignedAttr);
    public void AddSigner(AsymmetricKeyParameter privateKey, Byte[] subjectKeyID, string digestOID, AttributeTable signedAttr, AttributeTable unsignedAttr);
    public void AddSigner(AsymmetricKeyParameter privateKey, Byte[] subjectKeyID, string encryptionOID, string digestOID, AttributeTable signedAttr, AttributeTable unsignedAttr);
    public void AddSigner(AsymmetricKeyParameter privateKey, X509Certificate cert, string digestOID, CmsAttributeTableGenerator signedAttrGen, CmsAttributeTableGenerator unsignedAttrGen);
    public void AddSigner(AsymmetricKeyParameter privateKey, X509Certificate cert, string encryptionOID, string digestOID, CmsAttributeTableGenerator signedAttrGen, CmsAttributeTableGenerator unsignedAttrGen);
    public void AddSigner(AsymmetricKeyParameter privateKey, Byte[] subjectKeyID, string digestOID, CmsAttributeTableGenerator signedAttrGen, CmsAttributeTableGenerator unsignedAttrGen);
    public void AddSigner(AsymmetricKeyParameter privateKey, Byte[] subjectKeyID, string encryptionOID, string digestOID, CmsAttributeTableGenerator signedAttrGen, CmsAttributeTableGenerator unsignedAttrGen);
    private void doAddSigner(AsymmetricKeyParameter privateKey, SignerIdentifier signerIdentifier, string encryptionOID, string digestOID, CmsAttributeTableGenerator signedAttrGen, CmsAttributeTableGenerator unsignedAttrGen, AttributeTable baseSignedTable);
    public CmsSignedData Generate(CmsProcessable content);
    public CmsSignedData Generate(string signedContentType, CmsProcessable content, bool encapsulate);
    public CmsSignedData Generate(CmsProcessable content, bool encapsulate);
    public SignerInformationStore GenerateCounterSigners(SignerInformation signer);
}
public class Org.BouncyCastle.Cms.CmsSignedDataParser : CmsContentInfoParser {
    private static CmsSignedHelper Helper;
    private SignedDataParser _signedData;
    private DerObjectIdentifier _signedContentType;
    private CmsTypedStream _signedContent;
    private IDictionary _digests;
    private ISet _digestOids;
    private SignerInformationStore _signerInfoStore;
    private Asn1Set _certSet;
    private Asn1Set _crlSet;
    private bool _isCertCrlParsed;
    private IX509Store _attributeStore;
    private IX509Store _certificateStore;
    private IX509Store _crlStore;
    public int Version { get; }
    public ISet DigestOids { get; }
    public DerObjectIdentifier SignedContentType { get; }
    public CmsSignedDataParser(Byte[] sigBlock);
    public CmsSignedDataParser(CmsTypedStream signedContent, Byte[] sigBlock);
    public CmsSignedDataParser(Stream sigData);
    public CmsSignedDataParser(CmsTypedStream signedContent, Stream sigData);
    private static CmsSignedDataParser();
    public int get_Version();
    public ISet get_DigestOids();
    public SignerInformationStore GetSignerInfos();
    public IX509Store GetAttributeCertificates(string type);
    public IX509Store GetCertificates(string type);
    public IX509Store GetCrls(string type);
    private void PopulateCertCrlSets();
    public DerObjectIdentifier get_SignedContentType();
    public CmsTypedStream GetSignedContent();
    public static Stream ReplaceSigners(Stream original, SignerInformationStore signerInformationStore, Stream outStr);
    public static Stream ReplaceCertificatesAndCrls(Stream original, IX509Store x509Certs, IX509Store x509Crls, IX509Store x509AttrCerts, Stream outStr);
    private static Asn1Set GetAsn1Set(Asn1SetParser asn1SetParser);
}
public class Org.BouncyCastle.Cms.CmsSignedDataStreamGenerator : CmsSignedGenerator {
    private static CmsSignedHelper Helper;
    private IList _signerInfs;
    private ISet _messageDigestOids;
    private IDictionary _messageDigests;
    private IDictionary _messageHashes;
    private bool _messageDigestsLocked;
    private int _bufferSize;
    public CmsSignedDataStreamGenerator(SecureRandom rand);
    private static CmsSignedDataStreamGenerator();
    public void SetBufferSize(int bufferSize);
    public void AddDigests(String[] digestOids);
    public void AddDigests(IEnumerable digestOids);
    public void AddSigner(AsymmetricKeyParameter privateKey, X509Certificate cert, string digestOid);
    public void AddSigner(AsymmetricKeyParameter privateKey, X509Certificate cert, string encryptionOid, string digestOid);
    public void AddSigner(AsymmetricKeyParameter privateKey, X509Certificate cert, string digestOid, AttributeTable signedAttr, AttributeTable unsignedAttr);
    public void AddSigner(AsymmetricKeyParameter privateKey, X509Certificate cert, string encryptionOid, string digestOid, AttributeTable signedAttr, AttributeTable unsignedAttr);
    public void AddSigner(AsymmetricKeyParameter privateKey, X509Certificate cert, string digestOid, CmsAttributeTableGenerator signedAttrGenerator, CmsAttributeTableGenerator unsignedAttrGenerator);
    public void AddSigner(AsymmetricKeyParameter privateKey, X509Certificate cert, string encryptionOid, string digestOid, CmsAttributeTableGenerator signedAttrGenerator, CmsAttributeTableGenerator unsignedAttrGenerator);
    public void AddSigner(AsymmetricKeyParameter privateKey, Byte[] subjectKeyID, string digestOid);
    public void AddSigner(AsymmetricKeyParameter privateKey, Byte[] subjectKeyID, string encryptionOid, string digestOid);
    public void AddSigner(AsymmetricKeyParameter privateKey, Byte[] subjectKeyID, string digestOid, AttributeTable signedAttr, AttributeTable unsignedAttr);
    public void AddSigner(AsymmetricKeyParameter privateKey, Byte[] subjectKeyID, string digestOid, CmsAttributeTableGenerator signedAttrGenerator, CmsAttributeTableGenerator unsignedAttrGenerator);
    public void AddSigner(AsymmetricKeyParameter privateKey, Byte[] subjectKeyID, string encryptionOid, string digestOid, CmsAttributeTableGenerator signedAttrGenerator, CmsAttributeTableGenerator unsignedAttrGenerator);
    private void DoAddSigner(AsymmetricKeyParameter privateKey, SignerIdentifier signerIdentifier, string encryptionOid, string digestOid, CmsAttributeTableGenerator signedAttrGenerator, CmsAttributeTableGenerator unsignedAttrGenerator);
    internal virtual void AddSignerCallback(SignerInformation si);
    public Stream Open(Stream outStream);
    public Stream Open(Stream outStream, bool encapsulate);
    public Stream Open(Stream outStream, bool encapsulate, Stream dataOutputStream);
    public Stream Open(Stream outStream, string signedContentType, bool encapsulate);
    public Stream Open(Stream outStream, string signedContentType, bool encapsulate, Stream dataOutputStream);
    private void RegisterDigestOid(string digestOid);
    private void ConfigureDigest(string digestOid);
    internal void Generate(Stream outStream, string eContentType, bool encapsulate, Stream dataOutputStream, CmsProcessable content);
    private DerInteger CalculateVersion(DerObjectIdentifier contentOid);
    private bool CheckForVersion3(IList signerInfos);
    private static Stream AttachDigestsToOutputStream(ICollection digests, Stream s);
    private static Stream GetSafeOutputStream(Stream s);
    private static Stream GetSafeTeeOutputStream(Stream s1, Stream s2);
}
public class Org.BouncyCastle.Cms.CmsSignedGenerator : object {
    public static string Data;
    public static string DigestSha1;
    public static string DigestSha224;
    public static string DigestSha256;
    public static string DigestSha384;
    public static string DigestSha512;
    public static string DigestMD5;
    public static string DigestGost3411;
    public static string DigestRipeMD128;
    public static string DigestRipeMD160;
    public static string DigestRipeMD256;
    public static string EncryptionRsa;
    public static string EncryptionDsa;
    public static string EncryptionECDsa;
    public static string EncryptionRsaPss;
    public static string EncryptionGost3410;
    public static string EncryptionECGost3410;
    private static string EncryptionECDsaWithSha1;
    private static string EncryptionECDsaWithSha224;
    private static string EncryptionECDsaWithSha256;
    private static string EncryptionECDsaWithSha384;
    private static string EncryptionECDsaWithSha512;
    private static ISet noParams;
    private static IDictionary ecAlgorithms;
    internal IList _certs;
    internal IList _crls;
    internal IList _signers;
    internal IDictionary _digests;
    protected SecureRandom rand;
    private static CmsSignedGenerator();
    protected CmsSignedGenerator(SecureRandom rand);
    protected string GetEncOid(AsymmetricKeyParameter key, string digestOID);
    internal static AlgorithmIdentifier GetEncAlgorithmIdentifier(DerObjectIdentifier encOid, Asn1Encodable sigX509Parameters);
    protected internal virtual IDictionary GetBaseParameters(DerObjectIdentifier contentType, AlgorithmIdentifier digAlgId, Byte[] hash);
    protected internal virtual Asn1Set GetAttributeSet(AttributeTable attr);
    public void AddCertificates(IX509Store certStore);
    public void AddCrls(IX509Store crlStore);
    public void AddAttributeCertificates(IX509Store store);
    public void AddSigners(SignerInformationStore signerStore);
    public IDictionary GetGeneratedDigests();
    internal virtual void AddSignerCallback(SignerInformation si);
    internal static SignerIdentifier GetSignerIdentifier(X509Certificate cert);
    internal static SignerIdentifier GetSignerIdentifier(Byte[] subjectKeyIdentifier);
}
internal class Org.BouncyCastle.Cms.CmsSignedHelper : object {
    internal static CmsSignedHelper Instance;
    private static IDictionary encryptionAlgs;
    private static IDictionary digestAlgs;
    private static IDictionary digestAliases;
    private static CmsSignedHelper();
    private static void AddEntries(DerObjectIdentifier oid, string digest, string encryption);
    internal string GetDigestAlgName(string digestAlgOid);
    internal String[] GetDigestAliases(string algName);
    internal string GetEncryptionAlgName(string encryptionAlgOid);
    internal IDigest GetDigestInstance(string algorithm);
    internal ISigner GetSignatureInstance(string algorithm);
    internal IX509Store CreateAttributeStore(string type, Asn1Set certSet);
    internal IX509Store CreateCertificateStore(string type, Asn1Set certSet);
    internal IX509Store CreateCrlStore(string type, Asn1Set crlSet);
    private void AddCertsFromSet(IList certs, Asn1Set certSet);
    private void AddCrlsFromSet(IList crls, Asn1Set crlSet);
    internal AlgorithmIdentifier FixAlgID(AlgorithmIdentifier algId);
}
public class Org.BouncyCastle.Cms.CmsStreamException : IOException {
    public CmsStreamException(string name);
    public CmsStreamException(string name, Exception e);
}
public class Org.BouncyCastle.Cms.CmsTypedStream : object {
    private static int BufferSize;
    private string _oid;
    private Stream _in;
    public string ContentType { get; }
    public Stream ContentStream { get; }
    public CmsTypedStream(Stream inStream);
    public CmsTypedStream(string oid, Stream inStream);
    public CmsTypedStream(string oid, Stream inStream, int bufSize);
    public string get_ContentType();
    public Stream get_ContentStream();
    public void Drain();
}
internal class Org.BouncyCastle.Cms.CmsUtilities : object {
    internal static int MaximumMemory { get; }
    internal static int get_MaximumMemory();
    internal static ContentInfo ReadContentInfo(Byte[] input);
    internal static ContentInfo ReadContentInfo(Stream input);
    private static ContentInfo ReadContentInfo(Asn1InputStream aIn);
    public static Byte[] StreamToByteArray(Stream inStream);
    public static Byte[] StreamToByteArray(Stream inStream, int limit);
    public static IList GetCertificatesFromStore(IX509Store certStore);
    public static IList GetCrlsFromStore(IX509Store crlStore);
    public static Asn1Set CreateBerSetFromList(IList berObjects);
    public static Asn1Set CreateDerSetFromList(IList derObjects);
    internal static Stream CreateBerOctetOutputStream(Stream s, int tagNo, bool isExplicit, int bufferSize);
    internal static TbsCertificateStructure GetTbsCertificateStructure(X509Certificate cert);
    internal static IssuerAndSerialNumber GetIssuerAndSerialNumber(X509Certificate cert);
}
internal class Org.BouncyCastle.Cms.CounterSignatureDigestCalculator : object {
    private string alg;
    private Byte[] data;
    internal CounterSignatureDigestCalculator(string alg, Byte[] data);
    public sealed virtual Byte[] GetDigest();
}
public class Org.BouncyCastle.Cms.DefaultAuthenticatedAttributeTableGenerator : object {
    private IDictionary table;
    public DefaultAuthenticatedAttributeTableGenerator(AttributeTable attributeTable);
    protected virtual IDictionary CreateStandardAttributeTable(IDictionary parameters);
    public virtual AttributeTable GetAttributes(IDictionary parameters);
}
public class Org.BouncyCastle.Cms.DefaultSignedAttributeTableGenerator : object {
    private IDictionary table;
    public DefaultSignedAttributeTableGenerator(AttributeTable attributeTable);
    protected virtual Hashtable createStandardAttributeTable(IDictionary parameters);
    private void DoCreateStandardAttributeTable(IDictionary parameters, IDictionary std);
    public virtual AttributeTable GetAttributes(IDictionary parameters);
}
internal class Org.BouncyCastle.Cms.DigOutputStream : BaseOutputStream {
    private IDigest dig;
    internal DigOutputStream(IDigest dig);
    public virtual void WriteByte(byte b);
    public virtual void Write(Byte[] b, int off, int len);
}
internal interface Org.BouncyCastle.Cms.IDigestCalculator {
    public abstract virtual Byte[] GetDigest();
}
internal class Org.BouncyCastle.Cms.KekRecipientInfoGenerator : object {
    private static CmsEnvelopedHelper Helper;
    private KeyParameter keyEncryptionKey;
    private string keyEncryptionKeyOID;
    private KekIdentifier kekIdentifier;
    private AlgorithmIdentifier keyEncryptionAlgorithm;
    unknown KekIdentifier KekIdentifier {internal set; }
    unknown KeyParameter KeyEncryptionKey {internal set; }
    unknown string KeyEncryptionKeyOID {internal set; }
    private static KekRecipientInfoGenerator();
    internal void set_KekIdentifier(KekIdentifier value);
    internal void set_KeyEncryptionKey(KeyParameter value);
    internal void set_KeyEncryptionKeyOID(string value);
    public sealed virtual RecipientInfo Generate(KeyParameter contentEncryptionKey, SecureRandom random);
    private static AlgorithmIdentifier DetermineKeyEncAlg(string algorithm, KeyParameter key);
}
public class Org.BouncyCastle.Cms.KekRecipientInformation : RecipientInformation {
    private KekRecipientInfo info;
    internal KekRecipientInformation(KekRecipientInfo info, CmsSecureReadable secureReadable);
    public virtual CmsTypedStream GetContentStream(ICipherParameters key);
}
internal class Org.BouncyCastle.Cms.KeyAgreeRecipientInfoGenerator : object {
    private static CmsEnvelopedHelper Helper;
    private DerObjectIdentifier keyAgreementOID;
    private DerObjectIdentifier keyEncryptionOID;
    private IList recipientCerts;
    private AsymmetricCipherKeyPair senderKeyPair;
    unknown DerObjectIdentifier KeyAgreementOID {internal set; }
    unknown DerObjectIdentifier KeyEncryptionOID {internal set; }
    unknown ICollection RecipientCerts {internal set; }
    unknown AsymmetricCipherKeyPair SenderKeyPair {internal set; }
    private static KeyAgreeRecipientInfoGenerator();
    internal void set_KeyAgreementOID(DerObjectIdentifier value);
    internal void set_KeyEncryptionOID(DerObjectIdentifier value);
    internal void set_RecipientCerts(ICollection value);
    internal void set_SenderKeyPair(AsymmetricCipherKeyPair value);
    public sealed virtual RecipientInfo Generate(KeyParameter contentEncryptionKey, SecureRandom random);
    private static OriginatorPublicKey CreateOriginatorPublicKey(AsymmetricKeyParameter publicKey);
}
public class Org.BouncyCastle.Cms.KeyAgreeRecipientInformation : RecipientInformation {
    private KeyAgreeRecipientInfo info;
    private Asn1OctetString encryptedKey;
    internal KeyAgreeRecipientInformation(KeyAgreeRecipientInfo info, RecipientID rid, Asn1OctetString encryptedKey, CmsSecureReadable secureReadable);
    internal static void ReadRecipientInfo(IList infos, KeyAgreeRecipientInfo info, CmsSecureReadable secureReadable);
    private AsymmetricKeyParameter GetSenderPublicKey(AsymmetricKeyParameter receiverPrivateKey, OriginatorIdentifierOrKey originator);
    private AsymmetricKeyParameter GetPublicKeyFromOriginatorPublicKey(AsymmetricKeyParameter receiverPrivateKey, OriginatorPublicKey originatorPublicKey);
    private AsymmetricKeyParameter GetPublicKeyFromOriginatorID(OriginatorID origID);
    private KeyParameter CalculateAgreedWrapKey(string wrapAlg, AsymmetricKeyParameter senderPublicKey, AsymmetricKeyParameter receiverPrivateKey);
    private KeyParameter UnwrapSessionKey(string wrapAlg, KeyParameter agreedKey);
    internal KeyParameter GetSessionKey(AsymmetricKeyParameter receiverPrivateKey);
    public virtual CmsTypedStream GetContentStream(ICipherParameters key);
}
internal class Org.BouncyCastle.Cms.KeyTransRecipientInfoGenerator : object {
    private static CmsEnvelopedHelper Helper;
    private TbsCertificateStructure recipientTbsCert;
    private AsymmetricKeyParameter recipientPublicKey;
    private Asn1OctetString subjectKeyIdentifier;
    private SubjectPublicKeyInfo info;
    unknown X509Certificate RecipientCert {internal set; }
    unknown AsymmetricKeyParameter RecipientPublicKey {internal set; }
    unknown Asn1OctetString SubjectKeyIdentifier {internal set; }
    private static KeyTransRecipientInfoGenerator();
    internal void set_RecipientCert(X509Certificate value);
    internal void set_RecipientPublicKey(AsymmetricKeyParameter value);
    internal void set_SubjectKeyIdentifier(Asn1OctetString value);
    public sealed virtual RecipientInfo Generate(KeyParameter contentEncryptionKey, SecureRandom random);
}
public class Org.BouncyCastle.Cms.KeyTransRecipientInformation : RecipientInformation {
    private KeyTransRecipientInfo info;
    internal KeyTransRecipientInformation(KeyTransRecipientInfo info, CmsSecureReadable secureReadable);
    private string GetExchangeEncryptionAlgorithmName(DerObjectIdentifier oid);
    internal KeyParameter UnwrapKey(ICipherParameters key);
    public virtual CmsTypedStream GetContentStream(ICipherParameters key);
}
internal class Org.BouncyCastle.Cms.MacOutputStream : BaseOutputStream {
    private IMac mac;
    internal MacOutputStream(IMac mac);
    public virtual void Write(Byte[] b, int off, int len);
    public virtual void WriteByte(byte b);
}
internal class Org.BouncyCastle.Cms.NullOutputStream : BaseOutputStream {
    public virtual void WriteByte(byte b);
    public virtual void Write(Byte[] buffer, int offset, int count);
}
public class Org.BouncyCastle.Cms.OriginatorID : X509CertStoreSelector {
    public virtual int GetHashCode();
    public virtual bool Equals(object obj);
}
public class Org.BouncyCastle.Cms.OriginatorInfoGenerator : object {
    private IList origCerts;
    private IList origCrls;
    public OriginatorInfoGenerator(X509Certificate origCert);
    public OriginatorInfoGenerator(IX509Store origCerts);
    public OriginatorInfoGenerator(IX509Store origCerts, IX509Store origCrls);
    public virtual OriginatorInfo Generate();
}
public class Org.BouncyCastle.Cms.OriginatorInformation : object {
    private OriginatorInfo originatorInfo;
    internal OriginatorInformation(OriginatorInfo originatorInfo);
    public virtual IX509Store GetCertificates();
    public virtual IX509Store GetCrls();
    public virtual OriginatorInfo ToAsn1Structure();
}
internal class Org.BouncyCastle.Cms.PasswordRecipientInfoGenerator : object {
    private static CmsEnvelopedHelper Helper;
    private AlgorithmIdentifier keyDerivationAlgorithm;
    private KeyParameter keyEncryptionKey;
    private string keyEncryptionKeyOID;
    unknown AlgorithmIdentifier KeyDerivationAlgorithm {internal set; }
    unknown KeyParameter KeyEncryptionKey {internal set; }
    unknown string KeyEncryptionKeyOID {internal set; }
    private static PasswordRecipientInfoGenerator();
    internal void set_KeyDerivationAlgorithm(AlgorithmIdentifier value);
    internal void set_KeyEncryptionKey(KeyParameter value);
    internal void set_KeyEncryptionKeyOID(string value);
    public sealed virtual RecipientInfo Generate(KeyParameter contentEncryptionKey, SecureRandom random);
}
public class Org.BouncyCastle.Cms.PasswordRecipientInformation : RecipientInformation {
    private PasswordRecipientInfo info;
    public AlgorithmIdentifier KeyDerivationAlgorithm { get; }
    internal PasswordRecipientInformation(PasswordRecipientInfo info, CmsSecureReadable secureReadable);
    public virtual AlgorithmIdentifier get_KeyDerivationAlgorithm();
    public virtual CmsTypedStream GetContentStream(ICipherParameters key);
}
public class Org.BouncyCastle.Cms.Pkcs5Scheme2PbeKey : CmsPbeKey {
    [ObsoleteAttribute("Use version taking 'char[]' instead")]
public Pkcs5Scheme2PbeKey(string password, Byte[] salt, int iterationCount);
    [ObsoleteAttribute("Use version taking 'char[]' instead")]
public Pkcs5Scheme2PbeKey(string password, AlgorithmIdentifier keyDerivationAlgorithm);
    public Pkcs5Scheme2PbeKey(Char[] password, Byte[] salt, int iterationCount);
    public Pkcs5Scheme2PbeKey(Char[] password, AlgorithmIdentifier keyDerivationAlgorithm);
    internal virtual KeyParameter GetEncoded(string algorithmOid);
}
public class Org.BouncyCastle.Cms.Pkcs5Scheme2Utf8PbeKey : CmsPbeKey {
    [ObsoleteAttribute("Use version taking 'char[]' instead")]
public Pkcs5Scheme2Utf8PbeKey(string password, Byte[] salt, int iterationCount);
    [ObsoleteAttribute("Use version taking 'char[]' instead")]
public Pkcs5Scheme2Utf8PbeKey(string password, AlgorithmIdentifier keyDerivationAlgorithm);
    public Pkcs5Scheme2Utf8PbeKey(Char[] password, Byte[] salt, int iterationCount);
    public Pkcs5Scheme2Utf8PbeKey(Char[] password, AlgorithmIdentifier keyDerivationAlgorithm);
    internal virtual KeyParameter GetEncoded(string algorithmOid);
}
public class Org.BouncyCastle.Cms.RecipientID : X509CertStoreSelector {
    private Byte[] keyIdentifier;
    public Byte[] KeyIdentifier { get; public set; }
    public Byte[] get_KeyIdentifier();
    public void set_KeyIdentifier(Byte[] value);
    public virtual int GetHashCode();
    public virtual bool Equals(object obj);
}
internal interface Org.BouncyCastle.Cms.RecipientInfoGenerator {
    public abstract virtual RecipientInfo Generate(KeyParameter contentEncryptionKey, SecureRandom random);
}
public abstract class Org.BouncyCastle.Cms.RecipientInformation : object {
    internal RecipientID rid;
    internal AlgorithmIdentifier keyEncAlg;
    internal CmsSecureReadable secureReadable;
    private Byte[] resultMac;
    public RecipientID RecipientID { get; }
    public AlgorithmIdentifier KeyEncryptionAlgorithmID { get; }
    public string KeyEncryptionAlgOid { get; }
    public Asn1Object KeyEncryptionAlgParams { get; }
    internal RecipientInformation(AlgorithmIdentifier keyEncAlg, CmsSecureReadable secureReadable);
    internal string GetContentAlgorithmName();
    public RecipientID get_RecipientID();
    public AlgorithmIdentifier get_KeyEncryptionAlgorithmID();
    public string get_KeyEncryptionAlgOid();
    public Asn1Object get_KeyEncryptionAlgParams();
    internal CmsTypedStream GetContentFromSessionKey(KeyParameter sKey);
    public Byte[] GetContent(ICipherParameters key);
    public Byte[] GetMac();
    public abstract virtual CmsTypedStream GetContentStream(ICipherParameters key);
}
[DefaultMemberAttribute("Item")]
public class Org.BouncyCastle.Cms.RecipientInformationStore : object {
    private IList all;
    private IDictionary table;
    public RecipientInformation Item { get; }
    public int Count { get; }
    public RecipientInformationStore(ICollection recipientInfos);
    public RecipientInformation get_Item(RecipientID selector);
    public RecipientInformation GetFirstRecipient(RecipientID selector);
    public int get_Count();
    public ICollection GetRecipients();
    public ICollection GetRecipients(RecipientID selector);
}
public class Org.BouncyCastle.Cms.SignerID : X509CertStoreSelector {
    public virtual int GetHashCode();
    public virtual bool Equals(object obj);
}
internal interface Org.BouncyCastle.Cms.SignerInfoGenerator {
    public abstract virtual SignerInfo Generate(DerObjectIdentifier contentType, AlgorithmIdentifier digestAlgorithm, Byte[] calculatedDigest);
}
public class Org.BouncyCastle.Cms.SignerInformation : object {
    private static CmsSignedHelper Helper;
    private SignerID sid;
    private SignerInfo info;
    private AlgorithmIdentifier digestAlgorithm;
    private AlgorithmIdentifier encryptionAlgorithm;
    private Asn1Set signedAttributeSet;
    private Asn1Set unsignedAttributeSet;
    private CmsProcessable content;
    private Byte[] signature;
    private DerObjectIdentifier contentType;
    private IDigestCalculator digestCalculator;
    private Byte[] resultDigest;
    private AttributeTable signedAttributeTable;
    private AttributeTable unsignedAttributeTable;
    private bool isCounterSignature;
    public bool IsCounterSignature { get; }
    public DerObjectIdentifier ContentType { get; }
    public SignerID SignerID { get; }
    public int Version { get; }
    public AlgorithmIdentifier DigestAlgorithmID { get; }
    public string DigestAlgOid { get; }
    public Asn1Object DigestAlgParams { get; }
    public AlgorithmIdentifier EncryptionAlgorithmID { get; }
    public string EncryptionAlgOid { get; }
    public Asn1Object EncryptionAlgParams { get; }
    public AttributeTable SignedAttributes { get; }
    public AttributeTable UnsignedAttributes { get; }
    internal SignerInformation(SignerInfo info, DerObjectIdentifier contentType, CmsProcessable content, IDigestCalculator digestCalculator);
    private static SignerInformation();
    public bool get_IsCounterSignature();
    public DerObjectIdentifier get_ContentType();
    public SignerID get_SignerID();
    public int get_Version();
    public AlgorithmIdentifier get_DigestAlgorithmID();
    public string get_DigestAlgOid();
    public Asn1Object get_DigestAlgParams();
    public Byte[] GetContentDigest();
    public AlgorithmIdentifier get_EncryptionAlgorithmID();
    public string get_EncryptionAlgOid();
    public Asn1Object get_EncryptionAlgParams();
    public AttributeTable get_SignedAttributes();
    public AttributeTable get_UnsignedAttributes();
    public Byte[] GetSignature();
    public SignerInformationStore GetCounterSignatures();
    public Byte[] GetEncodedSignedAttributes();
    private bool DoVerify(AsymmetricKeyParameter key);
    private bool IsNull(Asn1Encodable o);
    private DigestInfo DerDecode(Byte[] encoding);
    private bool VerifyDigest(Byte[] digest, AsymmetricKeyParameter key, Byte[] signature);
    public bool Verify(AsymmetricKeyParameter pubKey);
    public bool Verify(X509Certificate cert);
    public SignerInfo ToSignerInfo();
    private Asn1Object GetSingleValuedSignedAttribute(DerObjectIdentifier attrOID, string printableName);
    private Time GetSigningTime();
    public static SignerInformation ReplaceUnsignedAttributes(SignerInformation signerInformation, AttributeTable unsignedAttributes);
    public static SignerInformation AddCounterSigners(SignerInformation signerInformation, SignerInformationStore counterSigners);
}
public class Org.BouncyCastle.Cms.SignerInformationStore : object {
    private IList all;
    private IDictionary table;
    public int Count { get; }
    public SignerInformationStore(ICollection signerInfos);
    public SignerInformation GetFirstSigner(SignerID selector);
    public int get_Count();
    public ICollection GetSigners();
    public ICollection GetSigners(SignerID selector);
}
internal class Org.BouncyCastle.Cms.SigOutputStream : BaseOutputStream {
    private ISigner sig;
    internal SigOutputStream(ISigner sig);
    public virtual void WriteByte(byte b);
    public virtual void Write(Byte[] b, int off, int len);
}
public class Org.BouncyCastle.Cms.SimpleAttributeTableGenerator : object {
    private AttributeTable attributes;
    public SimpleAttributeTableGenerator(AttributeTable attributes);
    public virtual AttributeTable GetAttributes(IDictionary parameters);
}
public class Org.BouncyCastle.Crypto.Agreement.DHAgreement : object {
    private DHPrivateKeyParameters key;
    private DHParameters dhParams;
    private BigInteger privateValue;
    private SecureRandom random;
    public void Init(ICipherParameters parameters);
    public BigInteger CalculateMessage();
    public BigInteger CalculateAgreement(DHPublicKeyParameters pub, BigInteger message);
}
public class Org.BouncyCastle.Crypto.Agreement.DHBasicAgreement : object {
    private DHPrivateKeyParameters key;
    private DHParameters dhParams;
    public virtual void Init(ICipherParameters parameters);
    public virtual int GetFieldSize();
    public virtual BigInteger CalculateAgreement(ICipherParameters pubKey);
}
public class Org.BouncyCastle.Crypto.Agreement.ECDHBasicAgreement : object {
    protected internal ECPrivateKeyParameters privKey;
    public virtual void Init(ICipherParameters parameters);
    public virtual int GetFieldSize();
    public virtual BigInteger CalculateAgreement(ICipherParameters pubKey);
}
public class Org.BouncyCastle.Crypto.Agreement.ECDHCBasicAgreement : object {
    private ECPrivateKeyParameters key;
    public virtual void Init(ICipherParameters parameters);
    public virtual int GetFieldSize();
    public virtual BigInteger CalculateAgreement(ICipherParameters pubKey);
}
public class Org.BouncyCastle.Crypto.Agreement.ECDHWithKdfBasicAgreement : ECDHBasicAgreement {
    private string algorithm;
    private IDerivationFunction kdf;
    public ECDHWithKdfBasicAgreement(string algorithm, IDerivationFunction kdf);
    public virtual BigInteger CalculateAgreement(ICipherParameters pubKey);
    private Byte[] bigIntToBytes(BigInteger r);
}
public class Org.BouncyCastle.Crypto.Agreement.ECMqvBasicAgreement : object {
    protected internal MqvPrivateParameters privParams;
    public virtual void Init(ICipherParameters parameters);
    public virtual int GetFieldSize();
    public virtual BigInteger CalculateAgreement(ICipherParameters pubKey);
    private static ECPoint calculateMqvAgreement(ECDomainParameters parameters, ECPrivateKeyParameters d1U, ECPrivateKeyParameters d2U, ECPublicKeyParameters Q2U, ECPublicKeyParameters Q1V, ECPublicKeyParameters Q2V);
}
public class Org.BouncyCastle.Crypto.Agreement.ECMqvWithKdfBasicAgreement : ECMqvBasicAgreement {
    private string algorithm;
    private IDerivationFunction kdf;
    public ECMqvWithKdfBasicAgreement(string algorithm, IDerivationFunction kdf);
    public virtual BigInteger CalculateAgreement(ICipherParameters pubKey);
    private Byte[] bigIntToBytes(BigInteger r);
}
public class Org.BouncyCastle.Crypto.Agreement.Kdf.DHKdfParameters : object {
    private DerObjectIdentifier algorithm;
    private int keySize;
    private Byte[] z;
    private Byte[] extraInfo;
    public DerObjectIdentifier Algorithm { get; }
    public int KeySize { get; }
    public DHKdfParameters(DerObjectIdentifier algorithm, int keySize, Byte[] z);
    public DHKdfParameters(DerObjectIdentifier algorithm, int keySize, Byte[] z, Byte[] extraInfo);
    public DerObjectIdentifier get_Algorithm();
    public int get_KeySize();
    public Byte[] GetZ();
    public Byte[] GetExtraInfo();
}
public class Org.BouncyCastle.Crypto.Agreement.Kdf.DHKekGenerator : object {
    private IDigest digest;
    private DerObjectIdentifier algorithm;
    private int keySize;
    private Byte[] z;
    private Byte[] partyAInfo;
    public IDigest Digest { get; }
    public DHKekGenerator(IDigest digest);
    public virtual void Init(IDerivationParameters param);
    public virtual IDigest get_Digest();
    public virtual int GenerateBytes(Byte[] outBytes, int outOff, int len);
}
public class Org.BouncyCastle.Crypto.Agreement.Kdf.ECDHKekGenerator : object {
    private IDerivationFunction kdf;
    private DerObjectIdentifier algorithm;
    private int keySize;
    private Byte[] z;
    public IDigest Digest { get; }
    public ECDHKekGenerator(IDigest digest);
    public virtual void Init(IDerivationParameters param);
    public virtual IDigest get_Digest();
    public virtual int GenerateBytes(Byte[] outBytes, int outOff, int len);
}
public class Org.BouncyCastle.Crypto.Agreement.Srp.Srp6Client : object {
    protected BigInteger N;
    protected BigInteger g;
    protected BigInteger privA;
    protected BigInteger pubA;
    protected BigInteger B;
    protected BigInteger x;
    protected BigInteger u;
    protected BigInteger S;
    protected IDigest digest;
    protected SecureRandom random;
    public virtual void Init(BigInteger N, BigInteger g, IDigest digest, SecureRandom random);
    public virtual BigInteger GenerateClientCredentials(Byte[] salt, Byte[] identity, Byte[] password);
    public virtual BigInteger CalculateSecret(BigInteger serverB);
    protected virtual BigInteger SelectPrivateValue();
    private BigInteger CalculateS();
}
public class Org.BouncyCastle.Crypto.Agreement.Srp.Srp6Server : object {
    protected BigInteger N;
    protected BigInteger g;
    protected BigInteger v;
    protected SecureRandom random;
    protected IDigest digest;
    protected BigInteger A;
    protected BigInteger privB;
    protected BigInteger pubB;
    protected BigInteger u;
    protected BigInteger S;
    public virtual void Init(BigInteger N, BigInteger g, BigInteger v, IDigest digest, SecureRandom random);
    public virtual BigInteger GenerateServerCredentials();
    public virtual BigInteger CalculateSecret(BigInteger clientA);
    protected virtual BigInteger SelectPrivateValue();
    private BigInteger CalculateS();
}
public class Org.BouncyCastle.Crypto.Agreement.Srp.Srp6Utilities : object {
    public static BigInteger CalculateK(IDigest digest, BigInteger N, BigInteger g);
    public static BigInteger CalculateU(IDigest digest, BigInteger N, BigInteger A, BigInteger B);
    public static BigInteger CalculateX(IDigest digest, BigInteger N, Byte[] salt, Byte[] identity, Byte[] password);
    public static BigInteger GeneratePrivateValue(IDigest digest, BigInteger N, BigInteger g, SecureRandom random);
    public static BigInteger ValidatePublicValue(BigInteger N, BigInteger val);
    private static BigInteger HashPaddedPair(IDigest digest, BigInteger N, BigInteger n1, BigInteger n2);
    private static Byte[] GetPadded(BigInteger n, int length);
}
public class Org.BouncyCastle.Crypto.Agreement.Srp.Srp6VerifierGenerator : object {
    protected BigInteger N;
    protected BigInteger g;
    protected IDigest digest;
    public virtual void Init(BigInteger N, BigInteger g, IDigest digest);
    public virtual BigInteger GenerateVerifier(Byte[] salt, Byte[] identity, Byte[] password);
}
public class Org.BouncyCastle.Crypto.AsymmetricCipherKeyPair : object {
    private AsymmetricKeyParameter publicParameter;
    private AsymmetricKeyParameter privateParameter;
    public AsymmetricKeyParameter Public { get; }
    public AsymmetricKeyParameter Private { get; }
    public AsymmetricCipherKeyPair(AsymmetricKeyParameter publicParameter, AsymmetricKeyParameter privateParameter);
    public AsymmetricKeyParameter get_Public();
    public AsymmetricKeyParameter get_Private();
}
public abstract class Org.BouncyCastle.Crypto.AsymmetricKeyParameter : object {
    private bool privateKey;
    public bool IsPrivate { get; }
    protected AsymmetricKeyParameter(bool privateKey);
    public bool get_IsPrivate();
    public virtual bool Equals(object obj);
    protected bool Equals(AsymmetricKeyParameter other);
    public virtual int GetHashCode();
}
public class Org.BouncyCastle.Crypto.BufferedAeadBlockCipher : BufferedCipherBase {
    private IAeadBlockCipher cipher;
    public string AlgorithmName { get; }
    public BufferedAeadBlockCipher(IAeadBlockCipher cipher);
    public virtual string get_AlgorithmName();
    public virtual void Init(bool forEncryption, ICipherParameters parameters);
    public virtual int GetBlockSize();
    public virtual int GetUpdateOutputSize(int length);
    public virtual int GetOutputSize(int length);
    public virtual int ProcessByte(byte input, Byte[] output, int outOff);
    public virtual Byte[] ProcessByte(byte input);
    public virtual Byte[] ProcessBytes(Byte[] input, int inOff, int length);
    public virtual int ProcessBytes(Byte[] input, int inOff, int length, Byte[] output, int outOff);
    public virtual Byte[] DoFinal();
    public virtual Byte[] DoFinal(Byte[] input, int inOff, int inLen);
    public virtual int DoFinal(Byte[] output, int outOff);
    public virtual void Reset();
}
public class Org.BouncyCastle.Crypto.BufferedAsymmetricBlockCipher : BufferedCipherBase {
    private IAsymmetricBlockCipher cipher;
    private Byte[] buffer;
    private int bufOff;
    public string AlgorithmName { get; }
    public BufferedAsymmetricBlockCipher(IAsymmetricBlockCipher cipher);
    internal int GetBufferPosition();
    public virtual string get_AlgorithmName();
    public virtual int GetBlockSize();
    public virtual int GetOutputSize(int length);
    public virtual int GetUpdateOutputSize(int length);
    public virtual void Init(bool forEncryption, ICipherParameters parameters);
    public virtual Byte[] ProcessByte(byte input);
    public virtual Byte[] ProcessBytes(Byte[] input, int inOff, int length);
    public virtual Byte[] DoFinal();
    public virtual Byte[] DoFinal(Byte[] input, int inOff, int length);
    public virtual void Reset();
}
public class Org.BouncyCastle.Crypto.BufferedBlockCipher : BufferedCipherBase {
    internal Byte[] buf;
    internal int bufOff;
    internal bool forEncryption;
    internal IBlockCipher cipher;
    public string AlgorithmName { get; }
    public BufferedBlockCipher(IBlockCipher cipher);
    public virtual string get_AlgorithmName();
    public virtual void Init(bool forEncryption, ICipherParameters parameters);
    public virtual int GetBlockSize();
    public virtual int GetUpdateOutputSize(int length);
    public virtual int GetOutputSize(int length);
    public virtual int ProcessByte(byte input, Byte[] output, int outOff);
    public virtual Byte[] ProcessByte(byte input);
    public virtual Byte[] ProcessBytes(Byte[] input, int inOff, int length);
    public virtual int ProcessBytes(Byte[] input, int inOff, int length, Byte[] output, int outOff);
    public virtual Byte[] DoFinal();
    public virtual Byte[] DoFinal(Byte[] input, int inOff, int inLen);
    public virtual int DoFinal(Byte[] output, int outOff);
    public virtual void Reset();
}
public abstract class Org.BouncyCastle.Crypto.BufferedCipherBase : object {
    protected static Byte[] EmptyBuffer;
    public string AlgorithmName { get; }
    private static BufferedCipherBase();
    public abstract virtual string get_AlgorithmName();
    public abstract virtual void Init(bool forEncryption, ICipherParameters parameters);
    public abstract virtual int GetBlockSize();
    public abstract virtual int GetOutputSize(int inputLen);
    public abstract virtual int GetUpdateOutputSize(int inputLen);
    public abstract virtual Byte[] ProcessByte(byte input);
    public virtual int ProcessByte(byte input, Byte[] output, int outOff);
    public virtual Byte[] ProcessBytes(Byte[] input);
    public abstract virtual Byte[] ProcessBytes(Byte[] input, int inOff, int length);
    public virtual int ProcessBytes(Byte[] input, Byte[] output, int outOff);
    public virtual int ProcessBytes(Byte[] input, int inOff, int length, Byte[] output, int outOff);
    public abstract virtual Byte[] DoFinal();
    public virtual Byte[] DoFinal(Byte[] input);
    public abstract virtual Byte[] DoFinal(Byte[] input, int inOff, int length);
    public virtual int DoFinal(Byte[] output, int outOff);
    public virtual int DoFinal(Byte[] input, Byte[] output, int outOff);
    public virtual int DoFinal(Byte[] input, int inOff, int length, Byte[] output, int outOff);
    public abstract virtual void Reset();
}
public class Org.BouncyCastle.Crypto.BufferedIesCipher : BufferedCipherBase {
    private IesEngine engine;
    private bool forEncryption;
    private MemoryStream buffer;
    public string AlgorithmName { get; }
    public BufferedIesCipher(IesEngine engine);
    public virtual string get_AlgorithmName();
    public virtual void Init(bool forEncryption, ICipherParameters parameters);
    public virtual int GetBlockSize();
    public virtual int GetOutputSize(int inputLen);
    public virtual int GetUpdateOutputSize(int inputLen);
    public virtual Byte[] ProcessByte(byte input);
    public virtual Byte[] ProcessBytes(Byte[] input, int inOff, int length);
    public virtual Byte[] DoFinal();
    public virtual Byte[] DoFinal(Byte[] input, int inOff, int length);
    public virtual void Reset();
}
public class Org.BouncyCastle.Crypto.BufferedStreamCipher : BufferedCipherBase {
    private IStreamCipher cipher;
    public string AlgorithmName { get; }
    public BufferedStreamCipher(IStreamCipher cipher);
    public virtual string get_AlgorithmName();
    public virtual void Init(bool forEncryption, ICipherParameters parameters);
    public virtual int GetBlockSize();
    public virtual int GetOutputSize(int inputLen);
    public virtual int GetUpdateOutputSize(int inputLen);
    public virtual Byte[] ProcessByte(byte input);
    public virtual int ProcessByte(byte input, Byte[] output, int outOff);
    public virtual Byte[] ProcessBytes(Byte[] input, int inOff, int length);
    public virtual int ProcessBytes(Byte[] input, int inOff, int length, Byte[] output, int outOff);
    public virtual Byte[] DoFinal();
    public virtual Byte[] DoFinal(Byte[] input, int inOff, int length);
    public virtual void Reset();
}
public class Org.BouncyCastle.Crypto.CipherKeyGenerator : object {
    protected internal SecureRandom random;
    protected internal int strength;
    private bool uninitialised;
    private int defaultStrength;
    public int DefaultStrength { get; }
    internal CipherKeyGenerator(int defaultStrength);
    public int get_DefaultStrength();
    public void Init(KeyGenerationParameters parameters);
    protected virtual void engineInit(KeyGenerationParameters parameters);
    public Byte[] GenerateKey();
    protected virtual Byte[] engineGenerateKey();
}
public class Org.BouncyCastle.Crypto.CryptoException : Exception {
    public CryptoException(string message);
    public CryptoException(string message, Exception exception);
}
public class Org.BouncyCastle.Crypto.DataLengthException : CryptoException {
    public DataLengthException(string message);
    public DataLengthException(string message, Exception exception);
}
public abstract class Org.BouncyCastle.Crypto.Digests.GeneralDigest : object {
    private static int BYTE_LENGTH;
    private Byte[] xBuf;
    private int xBufOff;
    private long byteCount;
    public string AlgorithmName { get; }
    internal GeneralDigest(GeneralDigest t);
    public sealed virtual void Update(byte input);
    public sealed virtual void BlockUpdate(Byte[] input, int inOff, int length);
    public void Finish();
    public virtual void Reset();
    public sealed virtual int GetByteLength();
    internal abstract virtual void ProcessWord(Byte[] input, int inOff);
    internal abstract virtual void ProcessLength(long bitLength);
    internal abstract virtual void ProcessBlock();
    public abstract virtual string get_AlgorithmName();
    public abstract virtual int GetDigestSize();
    public abstract virtual int DoFinal(Byte[] output, int outOff);
}
public class Org.BouncyCastle.Crypto.Digests.Gost3411Digest : object {
    private static int DIGEST_LENGTH;
    private Byte[] H;
    private Byte[] L;
    private Byte[] M;
    private Byte[] Sum;
    private Byte[][] C;
    private Byte[] xBuf;
    private int xBufOff;
    private ulong byteCount;
    private IBlockCipher cipher;
    private Byte[] sBox;
    private Byte[] K;
    private Byte[] a;
    internal Int16[] wS;
    internal Int16[] w_S;
    internal Byte[] S;
    internal Byte[] U;
    internal Byte[] V;
    internal Byte[] W;
    private static Byte[] C2;
    public string AlgorithmName { get; }
    public Gost3411Digest(Byte[] sBoxParam);
    public Gost3411Digest(Gost3411Digest t);
    private static Gost3411Digest();
    private static Byte[][] MakeC();
    public sealed virtual string get_AlgorithmName();
    public sealed virtual int GetDigestSize();
    public sealed virtual void Update(byte input);
    public sealed virtual void BlockUpdate(Byte[] input, int inOff, int length);
    private Byte[] P(Byte[] input);
    private Byte[] A(Byte[] input);
    private void E(Byte[] key, Byte[] s, int sOff, Byte[] input, int inOff);
    private void fw(Byte[] input);
    private void processBlock(Byte[] input, int inOff);
    private void finish();
    public sealed virtual int DoFinal(Byte[] output, int outOff);
    public sealed virtual void Reset();
    private void sumByteArray(Byte[] input);
    private static void cpyBytesToShort(Byte[] S, Int16[] wS);
    private static void cpyShortToBytes(Int16[] wS, Byte[] S);
    public sealed virtual int GetByteLength();
}
public abstract class Org.BouncyCastle.Crypto.Digests.LongDigest : object {
    private int MyByteLength;
    private Byte[] xBuf;
    private int xBufOff;
    private long byteCount1;
    private long byteCount2;
    internal ulong H1;
    internal ulong H2;
    internal ulong H3;
    internal ulong H4;
    internal ulong H5;
    internal ulong H6;
    internal ulong H7;
    internal ulong H8;
    private UInt64[] W;
    private int wOff;
    internal static UInt64[] K;
    public string AlgorithmName { get; }
    internal LongDigest(LongDigest t);
    private static LongDigest();
    public sealed virtual void Update(byte input);
    public sealed virtual void BlockUpdate(Byte[] input, int inOff, int length);
    public void Finish();
    public virtual void Reset();
    internal void ProcessWord(Byte[] input, int inOff);
    private void AdjustByteCounts();
    internal void ProcessLength(long lowW, long hiW);
    internal void ProcessBlock();
    private static ulong Ch(ulong x, ulong y, ulong z);
    private static ulong Maj(ulong x, ulong y, ulong z);
    private static ulong Sum0(ulong x);
    private static ulong Sum1(ulong x);
    private static ulong Sigma0(ulong x);
    private static ulong Sigma1(ulong x);
    public sealed virtual int GetByteLength();
    public abstract virtual string get_AlgorithmName();
    public abstract virtual int GetDigestSize();
    public abstract virtual int DoFinal(Byte[] output, int outOff);
}
public class Org.BouncyCastle.Crypto.Digests.MD2Digest : object {
    private static int DigestLength;
    private static int BYTE_LENGTH;
    private Byte[] X;
    private int xOff;
    private Byte[] M;
    private int mOff;
    private Byte[] C;
    private int COff;
    private static Byte[] S;
    public string AlgorithmName { get; }
    public MD2Digest(MD2Digest t);
    private static MD2Digest();
    public sealed virtual string get_AlgorithmName();
    public sealed virtual int GetDigestSize();
    public sealed virtual int GetByteLength();
    public sealed virtual int DoFinal(Byte[] output, int outOff);
    public sealed virtual void Reset();
    public sealed virtual void Update(byte input);
    public sealed virtual void BlockUpdate(Byte[] input, int inOff, int length);
    internal void ProcessChecksum(Byte[] m);
    internal void ProcessBlock(Byte[] m);
}
public class Org.BouncyCastle.Crypto.Digests.MD4Digest : GeneralDigest {
    private static int DigestLength;
    private static int S11;
    private static int S12;
    private static int S13;
    private static int S14;
    private static int S21;
    private static int S22;
    private static int S23;
    private static int S24;
    private static int S31;
    private static int S32;
    private static int S33;
    private static int S34;
    private int H1;
    private int H2;
    private int H3;
    private int H4;
    private Int32[] X;
    private int xOff;
    public string AlgorithmName { get; }
    public MD4Digest(MD4Digest t);
    public virtual string get_AlgorithmName();
    public virtual int GetDigestSize();
    internal virtual void ProcessWord(Byte[] input, int inOff);
    internal virtual void ProcessLength(long bitLength);
    private void UnpackWord(int word, Byte[] outBytes, int outOff);
    public virtual int DoFinal(Byte[] output, int outOff);
    public virtual void Reset();
    private int RotateLeft(int x, int n);
    private int F(int u, int v, int w);
    private int G(int u, int v, int w);
    private int H(int u, int v, int w);
    internal virtual void ProcessBlock();
}
public class Org.BouncyCastle.Crypto.Digests.MD5Digest : GeneralDigest {
    private static int DigestLength;
    private UInt32 H1;
    private UInt32 H2;
    private UInt32 H3;
    private UInt32 H4;
    private UInt32[] X;
    private int xOff;
    private static int S11;
    private static int S12;
    private static int S13;
    private static int S14;
    private static int S21;
    private static int S22;
    private static int S23;
    private static int S24;
    private static int S31;
    private static int S32;
    private static int S33;
    private static int S34;
    private static int S41;
    private static int S42;
    private static int S43;
    private static int S44;
    public string AlgorithmName { get; }
    public MD5Digest(MD5Digest t);
    private static MD5Digest();
    public virtual string get_AlgorithmName();
    public virtual int GetDigestSize();
    internal virtual void ProcessWord(Byte[] input, int inOff);
    internal virtual void ProcessLength(long bitLength);
    public virtual int DoFinal(Byte[] output, int outOff);
    public virtual void Reset();
    private static UInt32 RotateLeft(UInt32 x, int n);
    private static UInt32 F(UInt32 u, UInt32 v, UInt32 w);
    private static UInt32 G(UInt32 u, UInt32 v, UInt32 w);
    private static UInt32 H(UInt32 u, UInt32 v, UInt32 w);
    private static UInt32 K(UInt32 u, UInt32 v, UInt32 w);
    internal virtual void ProcessBlock();
}
public class Org.BouncyCastle.Crypto.Digests.NullDigest : object {
    private MemoryStream bOut;
    public string AlgorithmName { get; }
    public sealed virtual string get_AlgorithmName();
    public sealed virtual int GetByteLength();
    public sealed virtual int GetDigestSize();
    public sealed virtual void Update(byte b);
    public sealed virtual void BlockUpdate(Byte[] inBytes, int inOff, int len);
    public sealed virtual int DoFinal(Byte[] outBytes, int outOff);
    public sealed virtual void Reset();
}
public class Org.BouncyCastle.Crypto.Digests.RipeMD128Digest : GeneralDigest {
    private static int DigestLength;
    private int H0;
    private int H1;
    private int H2;
    private int H3;
    private Int32[] X;
    private int xOff;
    public string AlgorithmName { get; }
    public RipeMD128Digest(RipeMD128Digest t);
    public virtual string get_AlgorithmName();
    public virtual int GetDigestSize();
    internal virtual void ProcessWord(Byte[] input, int inOff);
    internal virtual void ProcessLength(long bitLength);
    private void UnpackWord(int word, Byte[] outBytes, int outOff);
    public virtual int DoFinal(Byte[] output, int outOff);
    public virtual void Reset();
    private int RL(int x, int n);
    private int F1(int x, int y, int z);
    private int F2(int x, int y, int z);
    private int F3(int x, int y, int z);
    private int F4(int x, int y, int z);
    private int F1(int a, int b, int c, int d, int x, int s);
    private int F2(int a, int b, int c, int d, int x, int s);
    private int F3(int a, int b, int c, int d, int x, int s);
    private int F4(int a, int b, int c, int d, int x, int s);
    private int FF1(int a, int b, int c, int d, int x, int s);
    private int FF2(int a, int b, int c, int d, int x, int s);
    private int FF3(int a, int b, int c, int d, int x, int s);
    private int FF4(int a, int b, int c, int d, int x, int s);
    internal virtual void ProcessBlock();
}
public class Org.BouncyCastle.Crypto.Digests.RipeMD160Digest : GeneralDigest {
    private static int DigestLength;
    private int H0;
    private int H1;
    private int H2;
    private int H3;
    private int H4;
    private Int32[] X;
    private int xOff;
    public string AlgorithmName { get; }
    public RipeMD160Digest(RipeMD160Digest t);
    public virtual string get_AlgorithmName();
    public virtual int GetDigestSize();
    internal virtual void ProcessWord(Byte[] input, int inOff);
    internal virtual void ProcessLength(long bitLength);
    private void UnpackWord(int word, Byte[] outBytes, int outOff);
    public virtual int DoFinal(Byte[] output, int outOff);
    public virtual void Reset();
    private int RL(int x, int n);
    private int F1(int x, int y, int z);
    private int F2(int x, int y, int z);
    private int F3(int x, int y, int z);
    private int F4(int x, int y, int z);
    private int F5(int x, int y, int z);
    internal virtual void ProcessBlock();
}
public class Org.BouncyCastle.Crypto.Digests.RipeMD256Digest : GeneralDigest {
    private static int DigestLength;
    private int H0;
    private int H1;
    private int H2;
    private int H3;
    private int H4;
    private int H5;
    private int H6;
    private int H7;
    private Int32[] X;
    private int xOff;
    public string AlgorithmName { get; }
    public RipeMD256Digest(RipeMD256Digest t);
    public virtual string get_AlgorithmName();
    public virtual int GetDigestSize();
    internal virtual void ProcessWord(Byte[] input, int inOff);
    internal virtual void ProcessLength(long bitLength);
    private void UnpackWord(int word, Byte[] outBytes, int outOff);
    public virtual int DoFinal(Byte[] output, int outOff);
    public virtual void Reset();
    private int RL(int x, int n);
    private int F1(int x, int y, int z);
    private int F2(int x, int y, int z);
    private int F3(int x, int y, int z);
    private int F4(int x, int y, int z);
    private int F1(int a, int b, int c, int d, int x, int s);
    private int F2(int a, int b, int c, int d, int x, int s);
    private int F3(int a, int b, int c, int d, int x, int s);
    private int F4(int a, int b, int c, int d, int x, int s);
    private int FF1(int a, int b, int c, int d, int x, int s);
    private int FF2(int a, int b, int c, int d, int x, int s);
    private int FF3(int a, int b, int c, int d, int x, int s);
    private int FF4(int a, int b, int c, int d, int x, int s);
    internal virtual void ProcessBlock();
}
public class Org.BouncyCastle.Crypto.Digests.RipeMD320Digest : GeneralDigest {
    private static int DigestLength;
    private int H0;
    private int H1;
    private int H2;
    private int H3;
    private int H4;
    private int H5;
    private int H6;
    private int H7;
    private int H8;
    private int H9;
    private Int32[] X;
    private int xOff;
    public string AlgorithmName { get; }
    public RipeMD320Digest(RipeMD320Digest t);
    public virtual string get_AlgorithmName();
    public virtual int GetDigestSize();
    internal virtual void ProcessWord(Byte[] input, int inOff);
    internal virtual void ProcessLength(long bitLength);
    private void UnpackWord(int word, Byte[] outBytes, int outOff);
    public virtual int DoFinal(Byte[] output, int outOff);
    public virtual void Reset();
    private int RL(int x, int n);
    private int F1(int x, int y, int z);
    private int F2(int x, int y, int z);
    private int F3(int x, int y, int z);
    private int F4(int x, int y, int z);
    private int F5(int x, int y, int z);
    internal virtual void ProcessBlock();
}
public class Org.BouncyCastle.Crypto.Digests.Sha1Digest : GeneralDigest {
    private static int DigestLength;
    private static UInt32 Y1;
    private static UInt32 Y2;
    private static UInt32 Y3;
    private static UInt32 Y4;
    private UInt32 H1;
    private UInt32 H2;
    private UInt32 H3;
    private UInt32 H4;
    private UInt32 H5;
    private UInt32[] X;
    private int xOff;
    public string AlgorithmName { get; }
    public Sha1Digest(Sha1Digest t);
    public virtual string get_AlgorithmName();
    public virtual int GetDigestSize();
    internal virtual void ProcessWord(Byte[] input, int inOff);
    internal virtual void ProcessLength(long bitLength);
    public virtual int DoFinal(Byte[] output, int outOff);
    public virtual void Reset();
    private static UInt32 F(UInt32 u, UInt32 v, UInt32 w);
    private static UInt32 H(UInt32 u, UInt32 v, UInt32 w);
    private static UInt32 G(UInt32 u, UInt32 v, UInt32 w);
    internal virtual void ProcessBlock();
}
public class Org.BouncyCastle.Crypto.Digests.Sha224Digest : GeneralDigest {
    private static int DigestLength;
    private UInt32 H1;
    private UInt32 H2;
    private UInt32 H3;
    private UInt32 H4;
    private UInt32 H5;
    private UInt32 H6;
    private UInt32 H7;
    private UInt32 H8;
    private UInt32[] X;
    private int xOff;
    internal static UInt32[] K;
    public string AlgorithmName { get; }
    public Sha224Digest(Sha224Digest t);
    private static Sha224Digest();
    public virtual string get_AlgorithmName();
    public virtual int GetDigestSize();
    internal virtual void ProcessWord(Byte[] input, int inOff);
    internal virtual void ProcessLength(long bitLength);
    public virtual int DoFinal(Byte[] output, int outOff);
    public virtual void Reset();
    internal virtual void ProcessBlock();
    private static UInt32 Ch(UInt32 x, UInt32 y, UInt32 z);
    private static UInt32 Maj(UInt32 x, UInt32 y, UInt32 z);
    private static UInt32 Sum0(UInt32 x);
    private static UInt32 Sum1(UInt32 x);
    private static UInt32 Theta0(UInt32 x);
    private static UInt32 Theta1(UInt32 x);
}
public class Org.BouncyCastle.Crypto.Digests.Sha256Digest : GeneralDigest {
    private static int DigestLength;
    private UInt32 H1;
    private UInt32 H2;
    private UInt32 H3;
    private UInt32 H4;
    private UInt32 H5;
    private UInt32 H6;
    private UInt32 H7;
    private UInt32 H8;
    private UInt32[] X;
    private int xOff;
    private static UInt32[] K;
    public string AlgorithmName { get; }
    public Sha256Digest(Sha256Digest t);
    private static Sha256Digest();
    public virtual string get_AlgorithmName();
    public virtual int GetDigestSize();
    internal virtual void ProcessWord(Byte[] input, int inOff);
    internal virtual void ProcessLength(long bitLength);
    public virtual int DoFinal(Byte[] output, int outOff);
    public virtual void Reset();
    private void initHs();
    internal virtual void ProcessBlock();
    private static UInt32 Sum1Ch(UInt32 x, UInt32 y, UInt32 z);
    private static UInt32 Sum0Maj(UInt32 x, UInt32 y, UInt32 z);
    private static UInt32 Theta0(UInt32 x);
    private static UInt32 Theta1(UInt32 x);
}
public class Org.BouncyCastle.Crypto.Digests.Sha384Digest : LongDigest {
    private static int DigestLength;
    public string AlgorithmName { get; }
    public Sha384Digest(Sha384Digest t);
    public virtual string get_AlgorithmName();
    public virtual int GetDigestSize();
    public virtual int DoFinal(Byte[] output, int outOff);
    public virtual void Reset();
}
public class Org.BouncyCastle.Crypto.Digests.Sha3Digest : object {
    private static UInt64[] KeccakRoundConstants;
    private static Int32[] KeccakRhoOffsets;
    private Byte[] state;
    private Byte[] dataQueue;
    private int rate;
    private int bitsInQueue;
    private int fixedOutputLength;
    private bool squeezing;
    private int bitsAvailableForSqueezing;
    private Byte[] chunk;
    private Byte[] oneByte;
    private UInt64[] C;
    private UInt64[] tempA;
    private UInt64[] chiC;
    public string AlgorithmName { get; }
    public Sha3Digest(int bitLength);
    public Sha3Digest(Sha3Digest source);
    private static Sha3Digest();
    private static UInt64[] KeccakInitializeRoundConstants();
    private static Int32[] KeccakInitializeRhoOffsets();
    private void ClearDataQueueSection(int off, int len);
    public virtual string get_AlgorithmName();
    public virtual int GetDigestSize();
    public virtual void Update(byte input);
    public virtual void BlockUpdate(Byte[] input, int inOff, int len);
    public virtual int DoFinal(Byte[] output, int outOff);
    public virtual void Reset();
    public virtual int GetByteLength();
    private void Init(int bitLength);
    private void DoUpdate(Byte[] data, int off, long databitlen);
    private void InitSponge(int rate, int capacity);
    private void AbsorbQueue();
    private void Absorb(Byte[] data, int off, long databitlen);
    private void PadAndSwitchToSqueezingPhase();
    private void Squeeze(Byte[] output, int offset, long outputLength);
    private static void FromBytesToWords(UInt64[] stateAsWords, Byte[] state);
    private static void FromWordsToBytes(Byte[] state, UInt64[] stateAsWords);
    private void KeccakPermutation(Byte[] state);
    private void KeccakPermutationAfterXor(Byte[] state, Byte[] data, int dataLengthInBytes);
    private void KeccakPermutationOnWords(UInt64[] state);
    private void Theta(UInt64[] A);
    private void Rho(UInt64[] A);
    private void Pi(UInt64[] A);
    private void Chi(UInt64[] A);
    private static void Iota(UInt64[] A, int indexRound);
    private void KeccakAbsorb(Byte[] byteState, Byte[] data, int dataInBytes);
    private void KeccakExtract1024bits(Byte[] byteState, Byte[] data);
    private void KeccakExtract(Byte[] byteState, Byte[] data, int laneCount);
}
public class Org.BouncyCastle.Crypto.Digests.Sha512Digest : LongDigest {
    private static int DigestLength;
    public string AlgorithmName { get; }
    public Sha512Digest(Sha512Digest t);
    public virtual string get_AlgorithmName();
    public virtual int GetDigestSize();
    public virtual int DoFinal(Byte[] output, int outOff);
    public virtual void Reset();
}
public class Org.BouncyCastle.Crypto.Digests.Sha512tDigest : LongDigest {
    private static ulong A5;
    private int digestLength;
    private ulong H1t;
    private ulong H2t;
    private ulong H3t;
    private ulong H4t;
    private ulong H5t;
    private ulong H6t;
    private ulong H7t;
    private ulong H8t;
    public string AlgorithmName { get; }
    public Sha512tDigest(int bitLength);
    public Sha512tDigest(Sha512tDigest t);
    public virtual string get_AlgorithmName();
    public virtual int GetDigestSize();
    public virtual int DoFinal(Byte[] output, int outOff);
    public virtual void Reset();
    private void tIvGenerate(int bitLength);
    private static void UInt64_To_BE(ulong n, Byte[] bs, int off, int max);
    private static void UInt32_To_BE(UInt32 n, Byte[] bs, int off, int max);
}
public class Org.BouncyCastle.Crypto.Digests.ShortenedDigest : object {
    private IDigest baseDigest;
    private int length;
    public string AlgorithmName { get; }
    public ShortenedDigest(IDigest baseDigest, int length);
    public sealed virtual string get_AlgorithmName();
    public sealed virtual int GetDigestSize();
    public sealed virtual void Update(byte input);
    public sealed virtual void BlockUpdate(Byte[] input, int inOff, int length);
    public sealed virtual int DoFinal(Byte[] output, int outOff);
    public sealed virtual void Reset();
    public sealed virtual int GetByteLength();
}
public class Org.BouncyCastle.Crypto.Digests.TigerDigest : object {
    private static int MyByteLength;
    private static int DigestLength;
    private static Int64[] t1;
    private static Int64[] t2;
    private static Int64[] t3;
    private static Int64[] t4;
    private long a;
    private long b;
    private long c;
    private long byteCount;
    private Byte[] Buffer;
    private int bOff;
    private Int64[] x;
    private int xOff;
    public string AlgorithmName { get; }
    public TigerDigest(TigerDigest t);
    private static TigerDigest();
    public sealed virtual string get_AlgorithmName();
    public sealed virtual int GetDigestSize();
    public sealed virtual int GetByteLength();
    private void ProcessWord(Byte[] b, int off);
    public sealed virtual void Update(byte input);
    public sealed virtual void BlockUpdate(Byte[] input, int inOff, int length);
    private void RoundABC(long x, long mul);
    private void RoundBCA(long x, long mul);
    private void RoundCAB(long x, long mul);
    private void KeySchedule();
    private void ProcessBlock();
    private void UnpackWord(long r, Byte[] output, int outOff);
    private void ProcessLength(long bitLength);
    private void Finish();
    public sealed virtual int DoFinal(Byte[] output, int outOff);
    public sealed virtual void Reset();
}
public class Org.BouncyCastle.Crypto.Digests.WhirlpoolDigest : object {
    private static int BYTE_LENGTH;
    private static int DIGEST_LENGTH_BYTES;
    private static int ROUNDS;
    private static int REDUCTION_POLYNOMIAL;
    private static int BITCOUNT_ARRAY_SIZE;
    private static Int32[] SBOX;
    private static Int64[] C0;
    private static Int64[] C1;
    private static Int64[] C2;
    private static Int64[] C3;
    private static Int64[] C4;
    private static Int64[] C5;
    private static Int64[] C6;
    private static Int64[] C7;
    private Int64[] _rc;
    private static Int16[] EIGHT;
    private Byte[] _buffer;
    private int _bufferPos;
    private Int16[] _bitCount;
    private Int64[] _hash;
    private Int64[] _K;
    private Int64[] _L;
    private Int64[] _block;
    private Int64[] _state;
    public string AlgorithmName { get; }
    private static WhirlpoolDigest();
    public WhirlpoolDigest(WhirlpoolDigest originalDigest);
    private static long packIntoLong(int b7, int b6, int b5, int b4, int b3, int b2, int b1, int b0);
    private static int maskWithReductionPolynomial(int input);
    public sealed virtual string get_AlgorithmName();
    public sealed virtual int GetDigestSize();
    public sealed virtual int DoFinal(Byte[] output, int outOff);
    public sealed virtual void Reset();
    private void processFilledBuffer();
    private static long bytesToLongFromBuffer(Byte[] buffer, int startPos);
    private static void convertLongToByteArray(long inputLong, Byte[] outputArray, int offSet);
    private void processBlock();
    public sealed virtual void Update(byte input);
    private void increment();
    public sealed virtual void BlockUpdate(Byte[] input, int inOff, int length);
    private void finish();
    private Byte[] copyBitLength();
    public sealed virtual int GetByteLength();
}
public class Org.BouncyCastle.Crypto.Encodings.ISO9796d1Encoding : object {
    private static BigInteger Sixteen;
    private static BigInteger Six;
    private static Byte[] shadows;
    private static Byte[] inverse;
    private IAsymmetricBlockCipher engine;
    private bool forEncryption;
    private int bitSize;
    private int padBits;
    private BigInteger modulus;
    public string AlgorithmName { get; }
    public ISO9796d1Encoding(IAsymmetricBlockCipher cipher);
    private static ISO9796d1Encoding();
    public sealed virtual string get_AlgorithmName();
    public IAsymmetricBlockCipher GetUnderlyingCipher();
    public sealed virtual void Init(bool forEncryption, ICipherParameters parameters);
    public sealed virtual int GetInputBlockSize();
    public sealed virtual int GetOutputBlockSize();
    public void SetPadBits(int padBits);
    public int GetPadBits();
    public sealed virtual Byte[] ProcessBlock(Byte[] input, int inOff, int length);
    private Byte[] EncodeBlock(Byte[] input, int inOff, int inLen);
    private Byte[] DecodeBlock(Byte[] input, int inOff, int inLen);
}
public class Org.BouncyCastle.Crypto.Encodings.OaepEncoding : object {
    private Byte[] defHash;
    private IDigest hash;
    private IDigest mgf1Hash;
    private IAsymmetricBlockCipher engine;
    private SecureRandom random;
    private bool forEncryption;
    public string AlgorithmName { get; }
    public OaepEncoding(IAsymmetricBlockCipher cipher);
    public OaepEncoding(IAsymmetricBlockCipher cipher, IDigest hash);
    public OaepEncoding(IAsymmetricBlockCipher cipher, IDigest hash, Byte[] encodingParams);
    public OaepEncoding(IAsymmetricBlockCipher cipher, IDigest hash, IDigest mgf1Hash, Byte[] encodingParams);
    public IAsymmetricBlockCipher GetUnderlyingCipher();
    public sealed virtual string get_AlgorithmName();
    public sealed virtual void Init(bool forEncryption, ICipherParameters param);
    public sealed virtual int GetInputBlockSize();
    public sealed virtual int GetOutputBlockSize();
    public sealed virtual Byte[] ProcessBlock(Byte[] inBytes, int inOff, int inLen);
    private Byte[] EncodeBlock(Byte[] inBytes, int inOff, int inLen);
    private Byte[] DecodeBlock(Byte[] inBytes, int inOff, int inLen);
    private void ItoOSP(int i, Byte[] sp);
    private Byte[] maskGeneratorFunction1(Byte[] Z, int zOff, int zLen, int length);
}
public class Org.BouncyCastle.Crypto.Encodings.Pkcs1Encoding : object {
    public static string StrictLengthEnabledProperty;
    private static int HeaderLength;
    private static Boolean[] strictLengthEnabled;
    private SecureRandom random;
    private IAsymmetricBlockCipher engine;
    private bool forEncryption;
    private bool forPrivateKey;
    private bool useStrictLength;
    public static bool StrictLengthEnabled { get; public set; }
    public string AlgorithmName { get; }
    private static Pkcs1Encoding();
    public Pkcs1Encoding(IAsymmetricBlockCipher cipher);
    public static bool get_StrictLengthEnabled();
    public static void set_StrictLengthEnabled(bool value);
    public IAsymmetricBlockCipher GetUnderlyingCipher();
    public sealed virtual string get_AlgorithmName();
    public sealed virtual void Init(bool forEncryption, ICipherParameters parameters);
    public sealed virtual int GetInputBlockSize();
    public sealed virtual int GetOutputBlockSize();
    public sealed virtual Byte[] ProcessBlock(Byte[] input, int inOff, int length);
    private Byte[] EncodeBlock(Byte[] input, int inOff, int inLen);
    private Byte[] DecodeBlock(Byte[] input, int inOff, int inLen);
}
public class Org.BouncyCastle.Crypto.Engines.AesEngine : object {
    private static UInt32 m1;
    private static UInt32 m2;
    private static UInt32 m3;
    private static int BLOCK_SIZE;
    private static Byte[] S;
    private static Byte[] Si;
    private static Byte[] rcon;
    private static UInt32[] T0;
    private static UInt32[] Tinv0;
    private int ROUNDS;
    private UInt32[][] WorkingKey;
    private UInt32 C0;
    private UInt32 C1;
    private UInt32 C2;
    private UInt32 C3;
    private bool forEncryption;
    public string AlgorithmName { get; }
    public bool IsPartialBlockOkay { get; }
    private static AesEngine();
    private static UInt32 Shift(UInt32 r, int shift);
    private static UInt32 FFmulX(UInt32 x);
    private static UInt32 Inv_Mcol(UInt32 x);
    private static UInt32 SubWord(UInt32 x);
    private UInt32[][] GenerateWorkingKey(Byte[] key, bool forEncryption);
    public sealed virtual void Init(bool forEncryption, ICipherParameters parameters);
    public sealed virtual string get_AlgorithmName();
    public sealed virtual bool get_IsPartialBlockOkay();
    public sealed virtual int GetBlockSize();
    public sealed virtual int ProcessBlock(Byte[] input, int inOff, Byte[] output, int outOff);
    public sealed virtual void Reset();
    private void UnPackBlock(Byte[] bytes, int off);
    private void PackBlock(Byte[] bytes, int off);
    private void EncryptBlock();
    private void DecryptBlock();
}
public class Org.BouncyCastle.Crypto.Engines.AesFastEngine : object {
    private static UInt32 m1;
    private static UInt32 m2;
    private static UInt32 m3;
    private static int BLOCK_SIZE;
    private static Byte[] S;
    private static Byte[] Si;
    private static Byte[] rcon;
    private static UInt32[] T0;
    private static UInt32[] T1;
    private static UInt32[] T2;
    private static UInt32[] T3;
    private static UInt32[] Tinv0;
    private static UInt32[] Tinv1;
    private static UInt32[] Tinv2;
    private static UInt32[] Tinv3;
    private int ROUNDS;
    private UInt32[][] WorkingKey;
    private UInt32 C0;
    private UInt32 C1;
    private UInt32 C2;
    private UInt32 C3;
    private bool forEncryption;
    public string AlgorithmName { get; }
    public bool IsPartialBlockOkay { get; }
    private static AesFastEngine();
    private static UInt32 Shift(UInt32 r, int shift);
    private static UInt32 FFmulX(UInt32 x);
    private static UInt32 Inv_Mcol(UInt32 x);
    private static UInt32 SubWord(UInt32 x);
    private UInt32[][] GenerateWorkingKey(Byte[] key, bool forEncryption);
    public sealed virtual void Init(bool forEncryption, ICipherParameters parameters);
    public sealed virtual string get_AlgorithmName();
    public sealed virtual bool get_IsPartialBlockOkay();
    public sealed virtual int GetBlockSize();
    public sealed virtual int ProcessBlock(Byte[] input, int inOff, Byte[] output, int outOff);
    public sealed virtual void Reset();
    private void UnPackBlock(Byte[] bytes, int off);
    private void PackBlock(Byte[] bytes, int off);
    private void EncryptBlock();
    private void DecryptBlock();
}
public class Org.BouncyCastle.Crypto.Engines.AesLightEngine : object {
    private static UInt32 m1;
    private static UInt32 m2;
    private static UInt32 m3;
    private static int BLOCK_SIZE;
    private static Byte[] S;
    private static Byte[] Si;
    private static Byte[] rcon;
    private int ROUNDS;
    private UInt32[][] WorkingKey;
    private UInt32 C0;
    private UInt32 C1;
    private UInt32 C2;
    private UInt32 C3;
    private bool forEncryption;
    public string AlgorithmName { get; }
    public bool IsPartialBlockOkay { get; }
    private static AesLightEngine();
    private static UInt32 Shift(UInt32 r, int shift);
    private static UInt32 FFmulX(UInt32 x);
    private static UInt32 Mcol(UInt32 x);
    private static UInt32 Inv_Mcol(UInt32 x);
    private static UInt32 SubWord(UInt32 x);
    private UInt32[][] GenerateWorkingKey(Byte[] key, bool forEncryption);
    public sealed virtual void Init(bool forEncryption, ICipherParameters parameters);
    public sealed virtual string get_AlgorithmName();
    public sealed virtual bool get_IsPartialBlockOkay();
    public sealed virtual int GetBlockSize();
    public sealed virtual int ProcessBlock(Byte[] input, int inOff, Byte[] output, int outOff);
    public sealed virtual void Reset();
    private void UnPackBlock(Byte[] bytes, int off);
    private void PackBlock(Byte[] bytes, int off);
    private void EncryptBlock();
    private void DecryptBlock();
}
public class Org.BouncyCastle.Crypto.Engines.AesWrapEngine : Rfc3394WrapEngine {
}
public class Org.BouncyCastle.Crypto.Engines.BlowfishEngine : object {
    private static int BLOCK_SIZE;
    private static UInt32[] KP;
    private static UInt32[] KS0;
    private static UInt32[] KS1;
    private static UInt32[] KS2;
    private static UInt32[] KS3;
    private static int ROUNDS;
    private static int SBOX_SK;
    private static int P_SZ;
    private UInt32[] S0;
    private UInt32[] S1;
    private UInt32[] S2;
    private UInt32[] S3;
    private UInt32[] P;
    private bool encrypting;
    private Byte[] workingKey;
    public string AlgorithmName { get; }
    public bool IsPartialBlockOkay { get; }
    private static BlowfishEngine();
    public sealed virtual void Init(bool forEncryption, ICipherParameters parameters);
    public sealed virtual string get_AlgorithmName();
    public sealed virtual bool get_IsPartialBlockOkay();
    public sealed virtual int ProcessBlock(Byte[] input, int inOff, Byte[] output, int outOff);
    public sealed virtual void Reset();
    public sealed virtual int GetBlockSize();
    private UInt32 F(UInt32 x);
    private void ProcessTable(UInt32 xl, UInt32 xr, UInt32[] table);
    private void SetKey(Byte[] key);
    private void EncryptBlock(Byte[] src, int srcIndex, Byte[] dst, int dstIndex);
    private void DecryptBlock(Byte[] src, int srcIndex, Byte[] dst, int dstIndex);
}
public class Org.BouncyCastle.Crypto.Engines.CamelliaEngine : object {
    private static int BLOCK_SIZE;
    private bool initialised;
    private bool _keyIs128;
    private UInt32[] subkey;
    private UInt32[] kw;
    private UInt32[] ke;
    private UInt32[] state;
    private static UInt32[] SIGMA;
    private static UInt32[] SBOX1_1110;
    private static UInt32[] SBOX4_4404;
    private static UInt32[] SBOX2_0222;
    private static UInt32[] SBOX3_3033;
    public string AlgorithmName { get; }
    public bool IsPartialBlockOkay { get; }
    private static CamelliaEngine();
    private static UInt32 rightRotate(UInt32 x, int s);
    private static UInt32 leftRotate(UInt32 x, int s);
    private static void roldq(int rot, UInt32[] ki, int ioff, UInt32[] ko, int ooff);
    private static void decroldq(int rot, UInt32[] ki, int ioff, UInt32[] ko, int ooff);
    private static void roldqo32(int rot, UInt32[] ki, int ioff, UInt32[] ko, int ooff);
    private static void decroldqo32(int rot, UInt32[] ki, int ioff, UInt32[] ko, int ooff);
    private static UInt32 bytes2uint(Byte[] src, int offset);
    private static void uint2bytes(UInt32 word, Byte[] dst, int offset);
    private static void camelliaF2(UInt32[] s, UInt32[] skey, int keyoff);
    private static void camelliaFLs(UInt32[] s, UInt32[] fkey, int keyoff);
    private void setKey(bool forEncryption, Byte[] key);
    private int processBlock128(Byte[] input, int inOff, Byte[] output, int outOff);
    private int processBlock192or256(Byte[] input, int inOff, Byte[] output, int outOff);
    public sealed virtual void Init(bool forEncryption, ICipherParameters parameters);
    public sealed virtual string get_AlgorithmName();
    public sealed virtual bool get_IsPartialBlockOkay();
    public sealed virtual int GetBlockSize();
    public sealed virtual int ProcessBlock(Byte[] input, int inOff, Byte[] output, int outOff);
    public sealed virtual void Reset();
}
public class Org.BouncyCastle.Crypto.Engines.CamelliaLightEngine : object {
    private static int BLOCK_SIZE;
    private bool initialised;
    private bool _keyis128;
    private UInt32[] subkey;
    private UInt32[] kw;
    private UInt32[] ke;
    private UInt32[] state;
    private static UInt32[] SIGMA;
    private static Byte[] SBOX1;
    public string AlgorithmName { get; }
    public bool IsPartialBlockOkay { get; }
    private static CamelliaLightEngine();
    private static UInt32 rightRotate(UInt32 x, int s);
    private static UInt32 leftRotate(UInt32 x, int s);
    private static void roldq(int rot, UInt32[] ki, int ioff, UInt32[] ko, int ooff);
    private static void decroldq(int rot, UInt32[] ki, int ioff, UInt32[] ko, int ooff);
    private static void roldqo32(int rot, UInt32[] ki, int ioff, UInt32[] ko, int ooff);
    private static void decroldqo32(int rot, UInt32[] ki, int ioff, UInt32[] ko, int ooff);
    private static UInt32 bytes2uint(Byte[] src, int offset);
    private static void uint2bytes(UInt32 word, Byte[] dst, int offset);
    private byte lRot8(byte v, int rot);
    private UInt32 sbox2(int x);
    private UInt32 sbox3(int x);
    private UInt32 sbox4(int x);
    private void camelliaF2(UInt32[] s, UInt32[] skey, int keyoff);
    private void camelliaFLs(UInt32[] s, UInt32[] fkey, int keyoff);
    private void setKey(bool forEncryption, Byte[] key);
    private int processBlock128(Byte[] input, int inOff, Byte[] output, int outOff);
    private int processBlock192or256(Byte[] input, int inOff, Byte[] output, int outOff);
    public sealed virtual string get_AlgorithmName();
    public sealed virtual bool get_IsPartialBlockOkay();
    public sealed virtual int GetBlockSize();
    public sealed virtual void Init(bool forEncryption, ICipherParameters parameters);
    public sealed virtual int ProcessBlock(Byte[] input, int inOff, Byte[] output, int outOff);
    public sealed virtual void Reset();
}
public class Org.BouncyCastle.Crypto.Engines.CamelliaWrapEngine : Rfc3394WrapEngine {
}
public class Org.BouncyCastle.Crypto.Engines.Cast5Engine : object {
    private static int BLOCK_SIZE;
    internal static UInt32[] S1;
    internal static UInt32[] S2;
    internal static UInt32[] S3;
    internal static UInt32[] S4;
    internal static UInt32[] S5;
    internal static UInt32[] S6;
    internal static UInt32[] S7;
    internal static UInt32[] S8;
    internal static int MAX_ROUNDS;
    internal static int RED_ROUNDS;
    private Int32[] _Kr;
    private UInt32[] _Km;
    private bool _encrypting;
    private Byte[] _workingKey;
    private int _rounds;
    public string AlgorithmName { get; }
    public bool IsPartialBlockOkay { get; }
    private static Cast5Engine();
    public sealed virtual void Init(bool forEncryption, ICipherParameters parameters);
    public virtual string get_AlgorithmName();
    public virtual bool get_IsPartialBlockOkay();
    public virtual int ProcessBlock(Byte[] input, int inOff, Byte[] output, int outOff);
    public virtual void Reset();
    public virtual int GetBlockSize();
    internal virtual void SetKey(Byte[] key);
    internal virtual int EncryptBlock(Byte[] src, int srcIndex, Byte[] dst, int dstIndex);
    internal virtual int DecryptBlock(Byte[] src, int srcIndex, Byte[] dst, int dstIndex);
    internal static UInt32 F1(UInt32 D, UInt32 Kmi, int Kri);
    internal static UInt32 F2(UInt32 D, UInt32 Kmi, int Kri);
    internal static UInt32 F3(UInt32 D, UInt32 Kmi, int Kri);
    internal void CAST_Encipher(UInt32 L0, UInt32 R0, UInt32[] result);
    internal void CAST_Decipher(UInt32 L16, UInt32 R16, UInt32[] result);
    internal static void Bits32ToInts(UInt32 inData, Int32[] b, int offset);
    internal static UInt32 IntsTo32bits(Int32[] b, int i);
}
public class Org.BouncyCastle.Crypto.Engines.Cast6Engine : Cast5Engine {
    private static int ROUNDS;
    private static int BLOCK_SIZE;
    private Int32[] _Kr;
    private UInt32[] _Km;
    private Int32[] _Tr;
    private UInt32[] _Tm;
    private UInt32[] _workingKey;
    public string AlgorithmName { get; }
    public virtual string get_AlgorithmName();
    public virtual void Reset();
    public virtual int GetBlockSize();
    internal virtual void SetKey(Byte[] key);
    internal virtual int EncryptBlock(Byte[] src, int srcIndex, Byte[] dst, int dstIndex);
    internal virtual int DecryptBlock(Byte[] src, int srcIndex, Byte[] dst, int dstIndex);
    private void CAST_Encipher(UInt32 A, UInt32 B, UInt32 C, UInt32 D, UInt32[] result);
    private void CAST_Decipher(UInt32 A, UInt32 B, UInt32 C, UInt32 D, UInt32[] result);
}
public class Org.BouncyCastle.Crypto.Engines.DesEdeEngine : DesEngine {
    private Int32[] workingKey1;
    private Int32[] workingKey2;
    private Int32[] workingKey3;
    private bool forEncryption;
    public string AlgorithmName { get; }
    public virtual void Init(bool forEncryption, ICipherParameters parameters);
    public virtual string get_AlgorithmName();
    public virtual int GetBlockSize();
    public virtual int ProcessBlock(Byte[] input, int inOff, Byte[] output, int outOff);
    public virtual void Reset();
}
public class Org.BouncyCastle.Crypto.Engines.DesEdeWrapEngine : object {
    private CbcBlockCipher engine;
    private KeyParameter param;
    private ParametersWithIV paramPlusIV;
    private Byte[] iv;
    private bool forWrapping;
    private static Byte[] IV2;
    private IDigest sha1;
    private Byte[] digest;
    public string AlgorithmName { get; }
    private static DesEdeWrapEngine();
    public sealed virtual void Init(bool forWrapping, ICipherParameters parameters);
    public sealed virtual string get_AlgorithmName();
    public sealed virtual Byte[] Wrap(Byte[] input, int inOff, int length);
    public sealed virtual Byte[] Unwrap(Byte[] input, int inOff, int length);
    private Byte[] CalculateCmsKeyChecksum(Byte[] key);
    private bool CheckCmsKeyChecksum(Byte[] key, Byte[] checksum);
    private static Byte[] reverse(Byte[] bs);
}
public class Org.BouncyCastle.Crypto.Engines.DesEngine : object {
    internal static int BLOCK_SIZE;
    private Int32[] workingKey;
    private static Int16[] bytebit;
    private static Int32[] bigbyte;
    private static Byte[] pc1;
    private static Byte[] totrot;
    private static Byte[] pc2;
    private static UInt32[] SP1;
    private static UInt32[] SP2;
    private static UInt32[] SP3;
    private static UInt32[] SP4;
    private static UInt32[] SP5;
    private static UInt32[] SP6;
    private static UInt32[] SP7;
    private static UInt32[] SP8;
    public string AlgorithmName { get; }
    public bool IsPartialBlockOkay { get; }
    private static DesEngine();
    public virtual Int32[] GetWorkingKey();
    public virtual void Init(bool forEncryption, ICipherParameters parameters);
    public virtual string get_AlgorithmName();
    public sealed virtual bool get_IsPartialBlockOkay();
    public virtual int GetBlockSize();
    public virtual int ProcessBlock(Byte[] input, int inOff, Byte[] output, int outOff);
    public virtual void Reset();
    protected static Int32[] GenerateWorkingKey(bool encrypting, Byte[] key);
    internal static void DesFunc(Int32[] wKey, Byte[] input, int inOff, Byte[] outBytes, int outOff);
}
public class Org.BouncyCastle.Crypto.Engines.ElGamalEngine : object {
    private ElGamalKeyParameters key;
    private SecureRandom random;
    private bool forEncryption;
    private int bitSize;
    public string AlgorithmName { get; }
    public sealed virtual string get_AlgorithmName();
    public sealed virtual void Init(bool forEncryption, ICipherParameters parameters);
    public sealed virtual int GetInputBlockSize();
    public sealed virtual int GetOutputBlockSize();
    public sealed virtual Byte[] ProcessBlock(Byte[] input, int inOff, int length);
}
public class Org.BouncyCastle.Crypto.Engines.Gost28147Engine : object {
    private static int BlockSize;
    private Int32[] workingKey;
    private bool forEncryption;
    private Byte[] S;
    private static Byte[] Sbox_Default;
    private static Byte[] ESbox_Test;
    private static Byte[] ESbox_A;
    private static Byte[] ESbox_B;
    private static Byte[] ESbox_C;
    private static Byte[] ESbox_D;
    private static Byte[] DSbox_Test;
    private static Byte[] DSbox_A;
    private static IDictionary sBoxes;
    public string AlgorithmName { get; }
    public bool IsPartialBlockOkay { get; }
    private static Gost28147Engine();
    private static void AddSBox(string sBoxName, Byte[] sBox);
    public sealed virtual void Init(bool forEncryption, ICipherParameters parameters);
    public sealed virtual string get_AlgorithmName();
    public sealed virtual bool get_IsPartialBlockOkay();
    public sealed virtual int GetBlockSize();
    public sealed virtual int ProcessBlock(Byte[] input, int inOff, Byte[] output, int outOff);
    public sealed virtual void Reset();
    private Int32[] generateWorkingKey(bool forEncryption, Byte[] userKey);
    private int Gost28147_mainStep(int n1, int key);
    private void Gost28147Func(Int32[] workingKey, Byte[] inBytes, int inOff, Byte[] outBytes, int outOff);
    private static int bytesToint(Byte[] inBytes, int inOff);
    private static void intTobytes(int num, Byte[] outBytes, int outOff);
    public static Byte[] GetSBox(string sBoxName);
}
public class Org.BouncyCastle.Crypto.Engines.HC128Engine : object {
    private UInt32[] p;
    private UInt32[] q;
    private UInt32 cnt;
    private Byte[] key;
    private Byte[] iv;
    private bool initialised;
    private Byte[] buf;
    private int idx;
    public string AlgorithmName { get; }
    private static UInt32 F1(UInt32 x);
    private static UInt32 F2(UInt32 x);
    private UInt32 G1(UInt32 x, UInt32 y, UInt32 z);
    private UInt32 G2(UInt32 x, UInt32 y, UInt32 z);
    private static UInt32 RotateLeft(UInt32 x, int bits);
    private static UInt32 RotateRight(UInt32 x, int bits);
    private UInt32 H1(UInt32 x);
    private UInt32 H2(UInt32 x);
    private static UInt32 Mod1024(UInt32 x);
    private static UInt32 Mod512(UInt32 x);
    private static UInt32 Dim(UInt32 x, UInt32 y);
    private UInt32 Step();
    private void Init();
    public sealed virtual string get_AlgorithmName();
    public sealed virtual void Init(bool forEncryption, ICipherParameters parameters);
    private byte GetByte();
    public sealed virtual void ProcessBytes(Byte[] input, int inOff, int len, Byte[] output, int outOff);
    public sealed virtual void Reset();
    public sealed virtual byte ReturnByte(byte input);
}
public class Org.BouncyCastle.Crypto.Engines.HC256Engine : object {
    private UInt32[] p;
    private UInt32[] q;
    private UInt32 cnt;
    private Byte[] key;
    private Byte[] iv;
    private bool initialised;
    private Byte[] buf;
    private int idx;
    public string AlgorithmName { get; }
    private UInt32 Step();
    private void Init();
    public sealed virtual string get_AlgorithmName();
    public sealed virtual void Init(bool forEncryption, ICipherParameters parameters);
    private byte GetByte();
    public sealed virtual void ProcessBytes(Byte[] input, int inOff, int len, Byte[] output, int outOff);
    public sealed virtual void Reset();
    public sealed virtual byte ReturnByte(byte input);
    private static UInt32 RotateRight(UInt32 x, int bits);
}
public class Org.BouncyCastle.Crypto.Engines.IesEngine : object {
    private IBasicAgreement agree;
    private IDerivationFunction kdf;
    private IMac mac;
    private BufferedBlockCipher cipher;
    private Byte[] macBuf;
    private bool forEncryption;
    private ICipherParameters privParam;
    private ICipherParameters pubParam;
    private IesParameters param;
    public IesEngine(IBasicAgreement agree, IDerivationFunction kdf, IMac mac);
    public IesEngine(IBasicAgreement agree, IDerivationFunction kdf, IMac mac, BufferedBlockCipher cipher);
    public void Init(bool forEncryption, ICipherParameters privParameters, ICipherParameters pubParameters, ICipherParameters iesParameters);
    private Byte[] DecryptBlock(Byte[] in_enc, int inOff, int inLen, Byte[] z);
    private Byte[] EncryptBlock(Byte[] input, int inOff, int inLen, Byte[] z);
    private Byte[] GenerateKdfBytes(KdfParameters kParam, int length);
    public Byte[] ProcessBlock(Byte[] input, int inOff, int inLen);
}
public class Org.BouncyCastle.Crypto.Engines.IsaacEngine : object {
    private static int sizeL;
    private static int stateArraySize;
    private UInt32[] engineState;
    private UInt32[] results;
    private UInt32 a;
    private UInt32 b;
    private UInt32 c;
    private int index;
    private Byte[] keyStream;
    private Byte[] workingKey;
    private bool initialised;
    public string AlgorithmName { get; }
    private static IsaacEngine();
    public sealed virtual void Init(bool forEncryption, ICipherParameters parameters);
    public sealed virtual byte ReturnByte(byte input);
    public sealed virtual void ProcessBytes(Byte[] input, int inOff, int len, Byte[] output, int outOff);
    public sealed virtual string get_AlgorithmName();
    public sealed virtual void Reset();
    private void setKey(Byte[] keyBytes);
    private void isaac();
    private void mix(UInt32[] x);
}
public class Org.BouncyCastle.Crypto.Engines.NaccacheSternEngine : object {
    private bool forEncryption;
    private NaccacheSternKeyParameters key;
    private IList[] lookup;
    private bool debug;
    public string AlgorithmName { get; }
    unknown bool Debug {public set; }
    public sealed virtual string get_AlgorithmName();
    public sealed virtual void Init(bool forEncryption, ICipherParameters parameters);
    public void set_Debug(bool value);
    public sealed virtual int GetInputBlockSize();
    public sealed virtual int GetOutputBlockSize();
    public sealed virtual Byte[] ProcessBlock(Byte[] inBytes, int inOff, int length);
    public Byte[] Encrypt(BigInteger plain);
    public Byte[] AddCryptedBlocks(Byte[] block1, Byte[] block2);
    public Byte[] ProcessData(Byte[] data);
    private static BigInteger chineseRemainder(IList congruences, IList primes);
}
public class Org.BouncyCastle.Crypto.Engines.NoekeonEngine : object {
    private static int GenericSize;
    private static UInt32[] nullVector;
    private static UInt32[] roundConstants;
    private UInt32[] state;
    private UInt32[] subKeys;
    private UInt32[] decryptKeys;
    private bool _initialised;
    private bool _forEncryption;
    public string AlgorithmName { get; }
    public bool IsPartialBlockOkay { get; }
    private static NoekeonEngine();
    public sealed virtual string get_AlgorithmName();
    public sealed virtual bool get_IsPartialBlockOkay();
    public sealed virtual int GetBlockSize();
    public sealed virtual void Init(bool forEncryption, ICipherParameters parameters);
    public sealed virtual int ProcessBlock(Byte[] input, int inOff, Byte[] output, int outOff);
    public sealed virtual void Reset();
    private void setKey(Byte[] key);
    private int encryptBlock(Byte[] input, int inOff, Byte[] output, int outOff);
    private int decryptBlock(Byte[] input, int inOff, Byte[] output, int outOff);
    private void gamma(UInt32[] a);
    private void theta(UInt32[] a, UInt32[] k);
    private void pi1(UInt32[] a);
    private void pi2(UInt32[] a);
    private UInt32 rotl(UInt32 x, int y);
}
public class Org.BouncyCastle.Crypto.Engines.NullEngine : object {
    private static int BlockSize;
    private bool initialised;
    public string AlgorithmName { get; }
    public bool IsPartialBlockOkay { get; }
    public sealed virtual void Init(bool forEncryption, ICipherParameters parameters);
    public sealed virtual string get_AlgorithmName();
    public sealed virtual bool get_IsPartialBlockOkay();
    public sealed virtual int GetBlockSize();
    public sealed virtual int ProcessBlock(Byte[] input, int inOff, Byte[] output, int outOff);
    public sealed virtual void Reset();
}
public class Org.BouncyCastle.Crypto.Engines.RC2Engine : object {
    private static int BLOCK_SIZE;
    private static Byte[] piTable;
    private Int32[] workingKey;
    private bool encrypting;
    public string AlgorithmName { get; }
    public bool IsPartialBlockOkay { get; }
    private static RC2Engine();
    private Int32[] GenerateWorkingKey(Byte[] key, int bits);
    public sealed virtual void Init(bool forEncryption, ICipherParameters parameters);
    public sealed virtual void Reset();
    public sealed virtual string get_AlgorithmName();
    public sealed virtual bool get_IsPartialBlockOkay();
    public sealed virtual int GetBlockSize();
    public sealed virtual int ProcessBlock(Byte[] input, int inOff, Byte[] output, int outOff);
    private int RotateWordLeft(int x, int y);
    private void EncryptBlock(Byte[] input, int inOff, Byte[] outBytes, int outOff);
    private void DecryptBlock(Byte[] input, int inOff, Byte[] outBytes, int outOff);
}
public class Org.BouncyCastle.Crypto.Engines.RC2WrapEngine : object {
    private CbcBlockCipher engine;
    private ICipherParameters parameters;
    private ParametersWithIV paramPlusIV;
    private Byte[] iv;
    private bool forWrapping;
    private SecureRandom sr;
    private static Byte[] IV2;
    private IDigest sha1;
    private Byte[] digest;
    public string AlgorithmName { get; }
    private static RC2WrapEngine();
    public sealed virtual void Init(bool forWrapping, ICipherParameters parameters);
    public sealed virtual string get_AlgorithmName();
    public sealed virtual Byte[] Wrap(Byte[] input, int inOff, int length);
    public sealed virtual Byte[] Unwrap(Byte[] input, int inOff, int length);
    private Byte[] CalculateCmsKeyChecksum(Byte[] key);
    private bool CheckCmsKeyChecksum(Byte[] key, Byte[] checksum);
}
public class Org.BouncyCastle.Crypto.Engines.RC4Engine : object {
    private static int STATE_LENGTH;
    private Byte[] engineState;
    private int x;
    private int y;
    private Byte[] workingKey;
    public string AlgorithmName { get; }
    private static RC4Engine();
    public sealed virtual void Init(bool forEncryption, ICipherParameters parameters);
    public sealed virtual string get_AlgorithmName();
    public sealed virtual byte ReturnByte(byte input);
    public sealed virtual void ProcessBytes(Byte[] input, int inOff, int length, Byte[] output, int outOff);
    public sealed virtual void Reset();
    private void SetKey(Byte[] keyBytes);
}
public class Org.BouncyCastle.Crypto.Engines.RC532Engine : object {
    private int _noRounds;
    private Int32[] _S;
    private static int P32;
    private static int Q32;
    private bool forEncryption;
    public string AlgorithmName { get; }
    public bool IsPartialBlockOkay { get; }
    private static RC532Engine();
    public sealed virtual string get_AlgorithmName();
    public sealed virtual bool get_IsPartialBlockOkay();
    public sealed virtual int GetBlockSize();
    public sealed virtual void Init(bool forEncryption, ICipherParameters parameters);
    public sealed virtual int ProcessBlock(Byte[] input, int inOff, Byte[] output, int outOff);
    public sealed virtual void Reset();
    private void SetKey(Byte[] key);
    private int EncryptBlock(Byte[] input, int inOff, Byte[] outBytes, int outOff);
    private int DecryptBlock(Byte[] input, int inOff, Byte[] outBytes, int outOff);
    private int RotateLeft(int x, int y);
    private int RotateRight(int x, int y);
    private int BytesToWord(Byte[] src, int srcOff);
    private void WordToBytes(int word, Byte[] dst, int dstOff);
}
public class Org.BouncyCastle.Crypto.Engines.RC564Engine : object {
    private static int wordSize;
    private static int bytesPerWord;
    private int _noRounds;
    private Int64[] _S;
    private static long P64;
    private static long Q64;
    private bool forEncryption;
    public string AlgorithmName { get; }
    public bool IsPartialBlockOkay { get; }
    private static RC564Engine();
    public sealed virtual string get_AlgorithmName();
    public sealed virtual bool get_IsPartialBlockOkay();
    public sealed virtual int GetBlockSize();
    public sealed virtual void Init(bool forEncryption, ICipherParameters parameters);
    public sealed virtual int ProcessBlock(Byte[] input, int inOff, Byte[] output, int outOff);
    public sealed virtual void Reset();
    private void SetKey(Byte[] key);
    private int EncryptBlock(Byte[] input, int inOff, Byte[] outBytes, int outOff);
    private int DecryptBlock(Byte[] input, int inOff, Byte[] outBytes, int outOff);
    private long RotateLeft(long x, long y);
    private long RotateRight(long x, long y);
    private long BytesToWord(Byte[] src, int srcOff);
    private void WordToBytes(long word, Byte[] dst, int dstOff);
}
public class Org.BouncyCastle.Crypto.Engines.RC6Engine : object {
    private static int wordSize;
    private static int bytesPerWord;
    private static int _noRounds;
    private Int32[] _S;
    private static int P32;
    private static int Q32;
    private static int LGW;
    private bool forEncryption;
    public string AlgorithmName { get; }
    public bool IsPartialBlockOkay { get; }
    private static RC6Engine();
    public sealed virtual string get_AlgorithmName();
    public sealed virtual bool get_IsPartialBlockOkay();
    public sealed virtual int GetBlockSize();
    public sealed virtual void Init(bool forEncryption, ICipherParameters parameters);
    public sealed virtual int ProcessBlock(Byte[] input, int inOff, Byte[] output, int outOff);
    public sealed virtual void Reset();
    private void SetKey(Byte[] key);
    private int EncryptBlock(Byte[] input, int inOff, Byte[] outBytes, int outOff);
    private int DecryptBlock(Byte[] input, int inOff, Byte[] outBytes, int outOff);
    private int RotateLeft(int x, int y);
    private int RotateRight(int x, int y);
    private int BytesToWord(Byte[] src, int srcOff);
    private void WordToBytes(int word, Byte[] dst, int dstOff);
}
public class Org.BouncyCastle.Crypto.Engines.Rfc3211WrapEngine : object {
    private CbcBlockCipher engine;
    private ParametersWithIV param;
    private bool forWrapping;
    private SecureRandom rand;
    public string AlgorithmName { get; }
    public Rfc3211WrapEngine(IBlockCipher engine);
    public sealed virtual void Init(bool forWrapping, ICipherParameters param);
    public sealed virtual string get_AlgorithmName();
    public sealed virtual Byte[] Wrap(Byte[] inBytes, int inOff, int inLen);
    public sealed virtual Byte[] Unwrap(Byte[] inBytes, int inOff, int inLen);
}
public class Org.BouncyCastle.Crypto.Engines.Rfc3394WrapEngine : object {
    private IBlockCipher engine;
    private KeyParameter param;
    private bool forWrapping;
    private Byte[] iv;
    public string AlgorithmName { get; }
    public Rfc3394WrapEngine(IBlockCipher engine);
    public sealed virtual void Init(bool forWrapping, ICipherParameters parameters);
    public sealed virtual string get_AlgorithmName();
    public sealed virtual Byte[] Wrap(Byte[] input, int inOff, int inLen);
    public sealed virtual Byte[] Unwrap(Byte[] input, int inOff, int inLen);
}
public class Org.BouncyCastle.Crypto.Engines.RijndaelEngine : object {
    private static int MAXROUNDS;
    private static int MAXKC;
    private static Byte[] Logtable;
    private static Byte[] Alogtable;
    private static Byte[] S;
    private static Byte[] Si;
    private static Byte[] rcon;
    private static Byte[][] shifts0;
    private static Byte[][] shifts1;
    private int BC;
    private long BC_MASK;
    private int ROUNDS;
    private int blockBits;
    private Int64[][] workingKey;
    private long A0;
    private long A1;
    private long A2;
    private long A3;
    private bool forEncryption;
    private Byte[] shifts0SC;
    private Byte[] shifts1SC;
    public string AlgorithmName { get; }
    public bool IsPartialBlockOkay { get; }
    public RijndaelEngine(int blockBits);
    private static RijndaelEngine();
    private byte Mul0x2(int b);
    private byte Mul0x3(int b);
    private byte Mul0x9(int b);
    private byte Mul0xb(int b);
    private byte Mul0xd(int b);
    private byte Mul0xe(int b);
    private void KeyAddition(Int64[] rk);
    private long Shift(long r, int shift);
    private void ShiftRow(Byte[] shiftsSC);
    private long ApplyS(long r, Byte[] box);
    private void Substitution(Byte[] box);
    private void MixColumn();
    private void InvMixColumn();
    private Int64[][] GenerateWorkingKey(Byte[] key);
    public sealed virtual void Init(bool forEncryption, ICipherParameters parameters);
    public sealed virtual string get_AlgorithmName();
    public sealed virtual bool get_IsPartialBlockOkay();
    public sealed virtual int GetBlockSize();
    public sealed virtual int ProcessBlock(Byte[] input, int inOff, Byte[] output, int outOff);
    public sealed virtual void Reset();
    private void UnPackBlock(Byte[] bytes, int off);
    private void PackBlock(Byte[] bytes, int off);
    private void EncryptBlock(Int64[][] rk);
    private void DecryptBlock(Int64[][] rk);
}
public class Org.BouncyCastle.Crypto.Engines.RsaBlindedEngine : object {
    private RsaCoreEngine core;
    private RsaKeyParameters key;
    private SecureRandom random;
    public string AlgorithmName { get; }
    public sealed virtual string get_AlgorithmName();
    public sealed virtual void Init(bool forEncryption, ICipherParameters param);
    public sealed virtual int GetInputBlockSize();
    public sealed virtual int GetOutputBlockSize();
    public sealed virtual Byte[] ProcessBlock(Byte[] inBuf, int inOff, int inLen);
}
public class Org.BouncyCastle.Crypto.Engines.RsaBlindingEngine : object {
    private RsaCoreEngine core;
    private RsaKeyParameters key;
    private BigInteger blindingFactor;
    private bool forEncryption;
    public string AlgorithmName { get; }
    public sealed virtual string get_AlgorithmName();
    public sealed virtual void Init(bool forEncryption, ICipherParameters param);
    public sealed virtual int GetInputBlockSize();
    public sealed virtual int GetOutputBlockSize();
    public sealed virtual Byte[] ProcessBlock(Byte[] inBuf, int inOff, int inLen);
    private BigInteger BlindMessage(BigInteger msg);
    private BigInteger UnblindMessage(BigInteger blindedMsg);
}
internal class Org.BouncyCastle.Crypto.Engines.RsaCoreEngine : object {
    private RsaKeyParameters key;
    private bool forEncryption;
    private int bitSize;
    public void Init(bool forEncryption, ICipherParameters parameters);
    public int GetInputBlockSize();
    public int GetOutputBlockSize();
    public BigInteger ConvertInput(Byte[] inBuf, int inOff, int inLen);
    public Byte[] ConvertOutput(BigInteger result);
    public BigInteger ProcessBlock(BigInteger input);
}
public class Org.BouncyCastle.Crypto.Engines.RsaEngine : object {
    private RsaCoreEngine core;
    public string AlgorithmName { get; }
    public sealed virtual string get_AlgorithmName();
    public sealed virtual void Init(bool forEncryption, ICipherParameters parameters);
    public sealed virtual int GetInputBlockSize();
    public sealed virtual int GetOutputBlockSize();
    public sealed virtual Byte[] ProcessBlock(Byte[] inBuf, int inOff, int inLen);
}
public class Org.BouncyCastle.Crypto.Engines.Salsa20Engine : object {
    private static int StateSize;
    private static Byte[] sigma;
    private static Byte[] tau;
    private int index;
    private UInt32[] engineState;
    private UInt32[] x;
    private Byte[] keyStream;
    private Byte[] workingKey;
    private Byte[] workingIV;
    private bool initialised;
    private UInt32 cW0;
    private UInt32 cW1;
    private UInt32 cW2;
    public string AlgorithmName { get; }
    private static Salsa20Engine();
    public sealed virtual void Init(bool forEncryption, ICipherParameters parameters);
    public sealed virtual string get_AlgorithmName();
    public sealed virtual byte ReturnByte(byte input);
    public sealed virtual void ProcessBytes(Byte[] inBytes, int inOff, int len, Byte[] outBytes, int outOff);
    public sealed virtual void Reset();
    private void SetKey(Byte[] keyBytes, Byte[] ivBytes);
    private void GenerateKeyStream(Byte[] output);
    internal static void SalsaCore(int rounds, UInt32[] state, UInt32[] x);
    private static UInt32 R(UInt32 x, int y);
    private void ResetCounter();
    private bool LimitExceeded();
    private bool LimitExceeded(UInt32 len);
}
public class Org.BouncyCastle.Crypto.Engines.SeedEngine : object {
    private static int BlockSize;
    private static UInt32[] SS0;
    private static UInt32[] SS1;
    private static UInt32[] SS2;
    private static UInt32[] SS3;
    private static UInt32[] KC;
    private Int32[] wKey;
    private bool forEncryption;
    public string AlgorithmName { get; }
    public bool IsPartialBlockOkay { get; }
    private static SeedEngine();
    public sealed virtual void Init(bool forEncryption, ICipherParameters parameters);
    public sealed virtual string get_AlgorithmName();
    public sealed virtual bool get_IsPartialBlockOkay();
    public sealed virtual int GetBlockSize();
    public sealed virtual int ProcessBlock(Byte[] inBuf, int inOff, Byte[] outBuf, int outOff);
    public sealed virtual void Reset();
    private Int32[] createWorkingKey(Byte[] inKey);
    private int extractW1(long lVal);
    private int extractW0(long lVal);
    private long rotateLeft8(long x);
    private long rotateRight8(long x);
    private long bytesToLong(Byte[] src, int srcOff);
    private void longToBytes(Byte[] dest, int destOff, long value);
    private int G(int x);
    private long F(int ki0, int ki1, long r);
    private int phaseCalc1(int r0, int ki0, int r1, int ki1);
    private int phaseCalc2(int r0, int ki0, int r1, int ki1);
}
public class Org.BouncyCastle.Crypto.Engines.SeedWrapEngine : Rfc3394WrapEngine {
}
public class Org.BouncyCastle.Crypto.Engines.SerpentEngine : object {
    private static int BLOCK_SIZE;
    private static int ROUNDS;
    private static int PHI;
    private bool encrypting;
    private Int32[] wKey;
    private int X0;
    private int X1;
    private int X2;
    private int X3;
    public string AlgorithmName { get; }
    public bool IsPartialBlockOkay { get; }
    private static SerpentEngine();
    public sealed virtual void Init(bool forEncryption, ICipherParameters parameters);
    public sealed virtual string get_AlgorithmName();
    public sealed virtual bool get_IsPartialBlockOkay();
    public sealed virtual int GetBlockSize();
    public sealed virtual int ProcessBlock(Byte[] input, int inOff, Byte[] output, int outOff);
    public sealed virtual void Reset();
    private Int32[] MakeWorkingKey(Byte[] key);
    private int RotateLeft(int x, int bits);
    private int RotateRight(int x, int bits);
    private int BytesToWord(Byte[] src, int srcOff);
    private void WordToBytes(int word, Byte[] dst, int dstOff);
    private void EncryptBlock(Byte[] input, int inOff, Byte[] outBytes, int outOff);
    private void DecryptBlock(Byte[] input, int inOff, Byte[] outBytes, int outOff);
    private void Sb0(int a, int b, int c, int d);
    private void Ib0(int a, int b, int c, int d);
    private void Sb1(int a, int b, int c, int d);
    private void Ib1(int a, int b, int c, int d);
    private void Sb2(int a, int b, int c, int d);
    private void Ib2(int a, int b, int c, int d);
    private void Sb3(int a, int b, int c, int d);
    private void Ib3(int a, int b, int c, int d);
    private void Sb4(int a, int b, int c, int d);
    private void Ib4(int a, int b, int c, int d);
    private void Sb5(int a, int b, int c, int d);
    private void Ib5(int a, int b, int c, int d);
    private void Sb6(int a, int b, int c, int d);
    private void Ib6(int a, int b, int c, int d);
    private void Sb7(int a, int b, int c, int d);
    private void Ib7(int a, int b, int c, int d);
    private void LT();
    private void InverseLT();
}
public class Org.BouncyCastle.Crypto.Engines.SkipjackEngine : object {
    private static int BLOCK_SIZE;
    private static Int16[] ftable;
    private Int32[] key0;
    private Int32[] key1;
    private Int32[] key2;
    private Int32[] key3;
    private bool encrypting;
    public string AlgorithmName { get; }
    public bool IsPartialBlockOkay { get; }
    private static SkipjackEngine();
    public sealed virtual void Init(bool forEncryption, ICipherParameters parameters);
    public sealed virtual string get_AlgorithmName();
    public sealed virtual bool get_IsPartialBlockOkay();
    public sealed virtual int GetBlockSize();
    public sealed virtual int ProcessBlock(Byte[] input, int inOff, Byte[] output, int outOff);
    public sealed virtual void Reset();
    private int G(int k, int w);
    public int EncryptBlock(Byte[] input, int inOff, Byte[] outBytes, int outOff);
    private int H(int k, int w);
    public int DecryptBlock(Byte[] input, int inOff, Byte[] outBytes, int outOff);
}
public class Org.BouncyCastle.Crypto.Engines.TeaEngine : object {
    private static int rounds;
    private static int block_size;
    private static UInt32 delta;
    private static UInt32 d_sum;
    private UInt32 _a;
    private UInt32 _b;
    private UInt32 _c;
    private UInt32 _d;
    private bool _initialised;
    private bool _forEncryption;
    public string AlgorithmName { get; }
    public bool IsPartialBlockOkay { get; }
    public sealed virtual string get_AlgorithmName();
    public sealed virtual bool get_IsPartialBlockOkay();
    public sealed virtual int GetBlockSize();
    public sealed virtual void Init(bool forEncryption, ICipherParameters parameters);
    public sealed virtual int ProcessBlock(Byte[] inBytes, int inOff, Byte[] outBytes, int outOff);
    public sealed virtual void Reset();
    private void setKey(Byte[] key);
    private int encryptBlock(Byte[] inBytes, int inOff, Byte[] outBytes, int outOff);
    private int decryptBlock(Byte[] inBytes, int inOff, Byte[] outBytes, int outOff);
}
public class Org.BouncyCastle.Crypto.Engines.TwofishEngine : object {
    private static int P_00;
    private static int P_01;
    private static int P_02;
    private static int P_03;
    private static int P_04;
    private static int P_10;
    private static int P_11;
    private static int P_12;
    private static int P_13;
    private static int P_14;
    private static int P_20;
    private static int P_21;
    private static int P_22;
    private static int P_23;
    private static int P_24;
    private static int P_30;
    private static int P_31;
    private static int P_32;
    private static int P_33;
    private static int P_34;
    private static int GF256_FDBK;
    private static int GF256_FDBK_2;
    private static int GF256_FDBK_4;
    private static int RS_GF_FDBK;
    private static int ROUNDS;
    private static int MAX_ROUNDS;
    private static int BLOCK_SIZE;
    private static int MAX_KEY_BITS;
    private static int INPUT_WHITEN;
    private static int OUTPUT_WHITEN;
    private static int ROUND_SUBKEYS;
    private static int TOTAL_SUBKEYS;
    private static int SK_STEP;
    private static int SK_BUMP;
    private static int SK_ROTL;
    private static Byte[0...,0...] P;
    private bool encrypting;
    private Int32[] gMDS0;
    private Int32[] gMDS1;
    private Int32[] gMDS2;
    private Int32[] gMDS3;
    private Int32[] gSubKeys;
    private Int32[] gSBox;
    private int k64Cnt;
    private Byte[] workingKey;
    public string AlgorithmName { get; }
    public bool IsPartialBlockOkay { get; }
    private static TwofishEngine();
    public sealed virtual void Init(bool forEncryption, ICipherParameters parameters);
    public sealed virtual string get_AlgorithmName();
    public sealed virtual bool get_IsPartialBlockOkay();
    public sealed virtual int ProcessBlock(Byte[] input, int inOff, Byte[] output, int outOff);
    public sealed virtual void Reset();
    public sealed virtual int GetBlockSize();
    private void SetKey(Byte[] key);
    private void EncryptBlock(Byte[] src, int srcIndex, Byte[] dst, int dstIndex);
    private void DecryptBlock(Byte[] src, int srcIndex, Byte[] dst, int dstIndex);
    private int F32(int x, Int32[] k32);
    private int RS_MDS_Encode(int k0, int k1);
    private int RS_rem(int x);
    private int LFSR1(int x);
    private int LFSR2(int x);
    private int Mx_X(int x);
    private int Mx_Y(int x);
    private int M_b0(int x);
    private int M_b1(int x);
    private int M_b2(int x);
    private int M_b3(int x);
    private int Fe32_0(int x);
    private int Fe32_3(int x);
    private int BytesTo32Bits(Byte[] b, int p);
    private void Bits32ToBytes(int inData, Byte[] b, int offset);
}
public class Org.BouncyCastle.Crypto.Engines.VmpcEngine : object {
    protected byte n;
    protected Byte[] P;
    protected byte s;
    protected Byte[] workingIV;
    protected Byte[] workingKey;
    public string AlgorithmName { get; }
    public virtual string get_AlgorithmName();
    public virtual void Init(bool forEncryption, ICipherParameters parameters);
    protected virtual void InitKey(Byte[] keyBytes, Byte[] ivBytes);
    public virtual void ProcessBytes(Byte[] input, int inOff, int len, Byte[] output, int outOff);
    public virtual void Reset();
    public virtual byte ReturnByte(byte input);
}
public class Org.BouncyCastle.Crypto.Engines.VmpcKsa3Engine : VmpcEngine {
    public string AlgorithmName { get; }
    public virtual string get_AlgorithmName();
    protected virtual void InitKey(Byte[] keyBytes, Byte[] ivBytes);
}
public class Org.BouncyCastle.Crypto.Engines.XteaEngine : object {
    private static int rounds;
    private static int block_size;
    private static int delta;
    private UInt32[] _S;
    private UInt32[] _sum0;
    private UInt32[] _sum1;
    private bool _initialised;
    private bool _forEncryption;
    public string AlgorithmName { get; }
    public bool IsPartialBlockOkay { get; }
    public sealed virtual string get_AlgorithmName();
    public sealed virtual bool get_IsPartialBlockOkay();
    public sealed virtual int GetBlockSize();
    public sealed virtual void Init(bool forEncryption, ICipherParameters parameters);
    public sealed virtual int ProcessBlock(Byte[] inBytes, int inOff, Byte[] outBytes, int outOff);
    public sealed virtual void Reset();
    private void setKey(Byte[] key);
    private int encryptBlock(Byte[] inBytes, int inOff, Byte[] outBytes, int outOff);
    private int decryptBlock(Byte[] inBytes, int inOff, Byte[] outBytes, int outOff);
}
public class Org.BouncyCastle.Crypto.Generators.BaseKdfBytesGenerator : object {
    private int counterStart;
    private IDigest digest;
    private Byte[] shared;
    private Byte[] iv;
    public IDigest Digest { get; }
    public BaseKdfBytesGenerator(int counterStart, IDigest digest);
    public virtual void Init(IDerivationParameters parameters);
    public virtual IDigest get_Digest();
    public virtual int GenerateBytes(Byte[] output, int outOff, int length);
}
public class Org.BouncyCastle.Crypto.Generators.DesEdeKeyGenerator : DesKeyGenerator {
    internal DesEdeKeyGenerator(int defaultStrength);
    protected virtual void engineInit(KeyGenerationParameters parameters);
    protected virtual Byte[] engineGenerateKey();
}
public class Org.BouncyCastle.Crypto.Generators.DesKeyGenerator : CipherKeyGenerator {
    internal DesKeyGenerator(int defaultStrength);
    protected virtual void engineInit(KeyGenerationParameters parameters);
    protected virtual Byte[] engineGenerateKey();
}
public class Org.BouncyCastle.Crypto.Generators.DHBasicKeyPairGenerator : object {
    private DHKeyGenerationParameters param;
    public virtual void Init(KeyGenerationParameters parameters);
    public virtual AsymmetricCipherKeyPair GenerateKeyPair();
}
internal class Org.BouncyCastle.Crypto.Generators.DHKeyGeneratorHelper : object {
    internal static DHKeyGeneratorHelper Instance;
    private static DHKeyGeneratorHelper();
    internal BigInteger CalculatePrivate(DHParameters dhParams, SecureRandom random);
    internal BigInteger CalculatePublic(DHParameters dhParams, BigInteger x);
}
public class Org.BouncyCastle.Crypto.Generators.DHKeyPairGenerator : object {
    private DHKeyGenerationParameters param;
    public virtual void Init(KeyGenerationParameters parameters);
    public virtual AsymmetricCipherKeyPair GenerateKeyPair();
}
public class Org.BouncyCastle.Crypto.Generators.DHParametersGenerator : object {
    private int size;
    private int certainty;
    private SecureRandom random;
    public virtual void Init(int size, int certainty, SecureRandom random);
    public virtual DHParameters GenerateParameters();
}
internal class Org.BouncyCastle.Crypto.Generators.DHParametersHelper : object {
    private static BigInteger Six;
    private static Int32[][] primeLists;
    private static Int32[] primeProducts;
    private static BigInteger[] BigPrimeProducts;
    private static DHParametersHelper();
    private static BigInteger[] ConstructBigPrimeProducts(Int32[] primeProducts);
    internal static BigInteger[] GenerateSafePrimes(int size, int certainty, SecureRandom random);
    internal static BigInteger SelectGenerator(BigInteger p, BigInteger q, SecureRandom random);
}
public class Org.BouncyCastle.Crypto.Generators.DsaKeyPairGenerator : object {
    private DsaKeyGenerationParameters param;
    public sealed virtual void Init(KeyGenerationParameters parameters);
    public sealed virtual AsymmetricCipherKeyPair GenerateKeyPair();
    private static BigInteger GeneratePrivateKey(BigInteger q, SecureRandom random);
    private static BigInteger CalculatePublicKey(BigInteger p, BigInteger g, BigInteger x);
}
public class Org.BouncyCastle.Crypto.Generators.DsaParametersGenerator : object {
    private IDigest digest;
    private int L;
    private int N;
    private int certainty;
    private SecureRandom random;
    private bool use186_3;
    private int usageIndex;
    public DsaParametersGenerator(IDigest digest);
    public virtual void Init(int size, int certainty, SecureRandom random);
    public virtual void Init(DsaParameterGenerationParameters parameters);
    public virtual DsaParameters GenerateParameters();
    protected virtual DsaParameters GenerateParameters_FIPS186_2();
    protected virtual BigInteger CalculateGenerator_FIPS186_2(BigInteger p, BigInteger q, SecureRandom r);
    protected virtual DsaParameters GenerateParameters_FIPS186_3();
    protected virtual BigInteger CalculateGenerator_FIPS186_3_Unverifiable(BigInteger p, BigInteger q, SecureRandom r);
    protected virtual BigInteger CalculateGenerator_FIPS186_3_Verifiable(IDigest d, BigInteger p, BigInteger q, Byte[] seed, int index);
    private static bool IsValidDsaStrength(int strength);
    protected static void Hash(IDigest d, Byte[] input, Byte[] output);
    private static int GetDefaultN(int L);
    protected static void Inc(Byte[] buf);
}
public class Org.BouncyCastle.Crypto.Generators.ECKeyPairGenerator : object {
    private string algorithm;
    private ECDomainParameters parameters;
    private DerObjectIdentifier publicKeyParamSet;
    private SecureRandom random;
    public ECKeyPairGenerator(string algorithm);
    public sealed virtual void Init(KeyGenerationParameters parameters);
    public sealed virtual AsymmetricCipherKeyPair GenerateKeyPair();
    internal static X9ECParameters FindECCurveByOid(DerObjectIdentifier oid);
    internal static ECPublicKeyParameters GetCorrespondingPublicKey(ECPrivateKeyParameters privKey);
}
public class Org.BouncyCastle.Crypto.Generators.ElGamalKeyPairGenerator : object {
    private ElGamalKeyGenerationParameters param;
    public sealed virtual void Init(KeyGenerationParameters parameters);
    public sealed virtual AsymmetricCipherKeyPair GenerateKeyPair();
}
public class Org.BouncyCastle.Crypto.Generators.ElGamalParametersGenerator : object {
    private int size;
    private int certainty;
    private SecureRandom random;
    public void Init(int size, int certainty, SecureRandom random);
    public ElGamalParameters GenerateParameters();
}
public class Org.BouncyCastle.Crypto.Generators.Gost3410KeyPairGenerator : object {
    private Gost3410KeyGenerationParameters param;
    public sealed virtual void Init(KeyGenerationParameters parameters);
    public sealed virtual AsymmetricCipherKeyPair GenerateKeyPair();
}
public class Org.BouncyCastle.Crypto.Generators.Gost3410ParametersGenerator : object {
    private int size;
    private int typeproc;
    private SecureRandom init_random;
    public void Init(int size, int typeProcedure, SecureRandom random);
    private int procedure_A(int x0, int c, BigInteger[] pq, int size);
    private long procedure_Aa(long x0, long c, BigInteger[] pq, int size);
    private void procedure_B(int x0, int c, BigInteger[] pq);
    private void procedure_Bb(long x0, long c, BigInteger[] pq);
    private BigInteger procedure_C(BigInteger p, BigInteger q);
    public Gost3410Parameters GenerateParameters();
}
public class Org.BouncyCastle.Crypto.Generators.Kdf1BytesGenerator : BaseKdfBytesGenerator {
    public Kdf1BytesGenerator(IDigest digest);
}
public class Org.BouncyCastle.Crypto.Generators.Kdf2BytesGenerator : BaseKdfBytesGenerator {
    public Kdf2BytesGenerator(IDigest digest);
}
public class Org.BouncyCastle.Crypto.Generators.Mgf1BytesGenerator : object {
    private IDigest digest;
    private Byte[] seed;
    private int hLen;
    public IDigest Digest { get; }
    public Mgf1BytesGenerator(IDigest digest);
    public sealed virtual void Init(IDerivationParameters parameters);
    public sealed virtual IDigest get_Digest();
    private void ItoOSP(int i, Byte[] sp);
    public sealed virtual int GenerateBytes(Byte[] output, int outOff, int length);
}
public class Org.BouncyCastle.Crypto.Generators.NaccacheSternKeyPairGenerator : object {
    private static Int32[] smallPrimes;
    private NaccacheSternKeyGenerationParameters param;
    private static NaccacheSternKeyPairGenerator();
    public sealed virtual void Init(KeyGenerationParameters parameters);
    public sealed virtual AsymmetricCipherKeyPair GenerateKeyPair();
    private static BigInteger generatePrime(int bitLength, int certainty, SecureRandom rand);
    private static IList permuteList(IList arr, SecureRandom rand);
    private static IList findFirstPrimes(int count);
}
public class Org.BouncyCastle.Crypto.Generators.OpenSslPbeParametersGenerator : PbeParametersGenerator {
    private IDigest digest;
    public virtual void Init(Byte[] password, Byte[] salt, int iterationCount);
    public virtual void Init(Byte[] password, Byte[] salt);
    private Byte[] GenerateDerivedKey(int bytesNeeded);
    [ObsoleteAttribute("Use version with 'algorithm' parameter")]
public virtual ICipherParameters GenerateDerivedParameters(int keySize);
    public virtual ICipherParameters GenerateDerivedParameters(string algorithm, int keySize);
    [ObsoleteAttribute("Use version with 'algorithm' parameter")]
public virtual ICipherParameters GenerateDerivedParameters(int keySize, int ivSize);
    public virtual ICipherParameters GenerateDerivedParameters(string algorithm, int keySize, int ivSize);
    public virtual ICipherParameters GenerateDerivedMacParameters(int keySize);
}
public class Org.BouncyCastle.Crypto.Generators.Pkcs12ParametersGenerator : PbeParametersGenerator {
    public static int KeyMaterial;
    public static int IVMaterial;
    public static int MacMaterial;
    private IDigest digest;
    private int u;
    private int v;
    public Pkcs12ParametersGenerator(IDigest digest);
    private void Adjust(Byte[] a, int aOff, Byte[] b);
    private Byte[] GenerateDerivedKey(int idByte, int n);
    [ObsoleteAttribute("Use version with 'algorithm' parameter")]
public virtual ICipherParameters GenerateDerivedParameters(int keySize);
    public virtual ICipherParameters GenerateDerivedParameters(string algorithm, int keySize);
    [ObsoleteAttribute("Use version with 'algorithm' parameter")]
public virtual ICipherParameters GenerateDerivedParameters(int keySize, int ivSize);
    public virtual ICipherParameters GenerateDerivedParameters(string algorithm, int keySize, int ivSize);
    public virtual ICipherParameters GenerateDerivedMacParameters(int keySize);
}
public class Org.BouncyCastle.Crypto.Generators.Pkcs5S1ParametersGenerator : PbeParametersGenerator {
    private IDigest digest;
    public Pkcs5S1ParametersGenerator(IDigest digest);
    private Byte[] GenerateDerivedKey();
    [ObsoleteAttribute("Use version with 'algorithm' parameter")]
public virtual ICipherParameters GenerateDerivedParameters(int keySize);
    public virtual ICipherParameters GenerateDerivedParameters(string algorithm, int keySize);
    [ObsoleteAttribute("Use version with 'algorithm' parameter")]
public virtual ICipherParameters GenerateDerivedParameters(int keySize, int ivSize);
    public virtual ICipherParameters GenerateDerivedParameters(string algorithm, int keySize, int ivSize);
    public virtual ICipherParameters GenerateDerivedMacParameters(int keySize);
}
public class Org.BouncyCastle.Crypto.Generators.Pkcs5S2ParametersGenerator : PbeParametersGenerator {
    private IMac hMac;
    private Byte[] state;
    public Pkcs5S2ParametersGenerator(IDigest digest);
    private void F(Byte[] S, int c, Byte[] iBuf, Byte[] outBytes, int outOff);
    private Byte[] GenerateDerivedKey(int dkLen);
    [ObsoleteAttribute("Use version with 'algorithm' parameter")]
public virtual ICipherParameters GenerateDerivedParameters(int keySize);
    public virtual ICipherParameters GenerateDerivedParameters(string algorithm, int keySize);
    [ObsoleteAttribute("Use version with 'algorithm' parameter")]
public virtual ICipherParameters GenerateDerivedParameters(int keySize, int ivSize);
    public virtual ICipherParameters GenerateDerivedParameters(string algorithm, int keySize, int ivSize);
    public virtual ICipherParameters GenerateDerivedMacParameters(int keySize);
}
public class Org.BouncyCastle.Crypto.Generators.RsaBlindingFactorGenerator : object {
    private RsaKeyParameters key;
    private SecureRandom random;
    public void Init(ICipherParameters param);
    public BigInteger GenerateBlindingFactor();
}
public class Org.BouncyCastle.Crypto.Generators.RsaKeyPairGenerator : object {
    private static int DefaultTests;
    private static BigInteger DefaultPublicExponent;
    private RsaKeyGenerationParameters param;
    private static RsaKeyPairGenerator();
    public sealed virtual void Init(KeyGenerationParameters parameters);
    public sealed virtual AsymmetricCipherKeyPair GenerateKeyPair();
}
public class Org.BouncyCastle.Crypto.Generators.SCrypt : object {
    public static Byte[] Generate(Byte[] P, Byte[] S, int N, int r, int p, int dkLen);
    private static Byte[] MFcrypt(Byte[] P, Byte[] S, int N, int r, int p, int dkLen);
    private static Byte[] SingleIterationPBKDF2(Byte[] P, Byte[] S, int dkLen);
    private static void SMix(UInt32[] B, int BOff, int N, int r);
    private static void BlockMix(UInt32[] B, UInt32[] X1, UInt32[] X2, UInt32[] Y, int r);
    private static void Xor(UInt32[] a, UInt32[] b, int bOff, UInt32[] output);
    private static void Clear(Array array);
    private static void ClearAll(Array[] arrays);
}
public interface Org.BouncyCastle.Crypto.IAsymmetricBlockCipher {
    public string AlgorithmName { get; }
    public abstract virtual string get_AlgorithmName();
    public abstract virtual void Init(bool forEncryption, ICipherParameters parameters);
    public abstract virtual int GetInputBlockSize();
    public abstract virtual int GetOutputBlockSize();
    public abstract virtual Byte[] ProcessBlock(Byte[] inBuf, int inOff, int inLen);
}
public interface Org.BouncyCastle.Crypto.IAsymmetricCipherKeyPairGenerator {
    public abstract virtual void Init(KeyGenerationParameters parameters);
    public abstract virtual AsymmetricCipherKeyPair GenerateKeyPair();
}
public interface Org.BouncyCastle.Crypto.IBasicAgreement {
    public abstract virtual void Init(ICipherParameters parameters);
    public abstract virtual int GetFieldSize();
    public abstract virtual BigInteger CalculateAgreement(ICipherParameters pubKey);
}
public interface Org.BouncyCastle.Crypto.IBlockCipher {
    public string AlgorithmName { get; }
    public bool IsPartialBlockOkay { get; }
    public abstract virtual string get_AlgorithmName();
    public abstract virtual void Init(bool forEncryption, ICipherParameters parameters);
    public abstract virtual int GetBlockSize();
    public abstract virtual bool get_IsPartialBlockOkay();
    public abstract virtual int ProcessBlock(Byte[] inBuf, int inOff, Byte[] outBuf, int outOff);
    public abstract virtual void Reset();
}
public interface Org.BouncyCastle.Crypto.IBufferedCipher {
    public string AlgorithmName { get; }
    public abstract virtual string get_AlgorithmName();
    public abstract virtual void Init(bool forEncryption, ICipherParameters parameters);
    public abstract virtual int GetBlockSize();
    public abstract virtual int GetOutputSize(int inputLen);
    public abstract virtual int GetUpdateOutputSize(int inputLen);
    public abstract virtual Byte[] ProcessByte(byte input);
    public abstract virtual int ProcessByte(byte input, Byte[] output, int outOff);
    public abstract virtual Byte[] ProcessBytes(Byte[] input);
    public abstract virtual Byte[] ProcessBytes(Byte[] input, int inOff, int length);
    public abstract virtual int ProcessBytes(Byte[] input, Byte[] output, int outOff);
    public abstract virtual int ProcessBytes(Byte[] input, int inOff, int length, Byte[] output, int outOff);
    public abstract virtual Byte[] DoFinal();
    public abstract virtual Byte[] DoFinal(Byte[] input);
    public abstract virtual Byte[] DoFinal(Byte[] input, int inOff, int length);
    public abstract virtual int DoFinal(Byte[] output, int outOff);
    public abstract virtual int DoFinal(Byte[] input, Byte[] output, int outOff);
    public abstract virtual int DoFinal(Byte[] input, int inOff, int length, Byte[] output, int outOff);
    public abstract virtual void Reset();
}
public interface Org.BouncyCastle.Crypto.ICipherParameters {
}
public interface Org.BouncyCastle.Crypto.IDerivationFunction {
    public IDigest Digest { get; }
    public abstract virtual void Init(IDerivationParameters parameters);
    public abstract virtual IDigest get_Digest();
    public abstract virtual int GenerateBytes(Byte[] output, int outOff, int length);
}
public interface Org.BouncyCastle.Crypto.IDerivationParameters {
}
public interface Org.BouncyCastle.Crypto.IDigest {
    public string AlgorithmName { get; }
    public abstract virtual string get_AlgorithmName();
    public abstract virtual int GetDigestSize();
    public abstract virtual int GetByteLength();
    public abstract virtual void Update(byte input);
    public abstract virtual void BlockUpdate(Byte[] input, int inOff, int length);
    public abstract virtual int DoFinal(Byte[] output, int outOff);
    public abstract virtual void Reset();
}
public interface Org.BouncyCastle.Crypto.IDsa {
    public string AlgorithmName { get; }
    public abstract virtual string get_AlgorithmName();
    public abstract virtual void Init(bool forSigning, ICipherParameters parameters);
    public abstract virtual BigInteger[] GenerateSignature(Byte[] message);
    public abstract virtual bool VerifySignature(Byte[] message, BigInteger r, BigInteger s);
}
public interface Org.BouncyCastle.Crypto.IMac {
    public string AlgorithmName { get; }
    public abstract virtual void Init(ICipherParameters parameters);
    public abstract virtual string get_AlgorithmName();
    public abstract virtual int GetMacSize();
    public abstract virtual void Update(byte input);
    public abstract virtual void BlockUpdate(Byte[] input, int inOff, int len);
    public abstract virtual int DoFinal(Byte[] output, int outOff);
    public abstract virtual void Reset();
}
public class Org.BouncyCastle.Crypto.InvalidCipherTextException : CryptoException {
    public InvalidCipherTextException(string message);
    public InvalidCipherTextException(string message, Exception exception);
}
public class Org.BouncyCastle.Crypto.IO.CipherStream : Stream {
    internal Stream stream;
    internal IBufferedCipher inCipher;
    internal IBufferedCipher outCipher;
    private Byte[] mInBuf;
    private int mInPos;
    private bool inStreamEnded;
    public IBufferedCipher ReadCipher { get; }
    public IBufferedCipher WriteCipher { get; }
    public bool CanRead { get; }
    public bool CanWrite { get; }
    public bool CanSeek { get; }
    public long Length { get; }
    public long Position { get; public set; }
    public CipherStream(Stream stream, IBufferedCipher readCipher, IBufferedCipher writeCipher);
    public IBufferedCipher get_ReadCipher();
    public IBufferedCipher get_WriteCipher();
    public virtual int ReadByte();
    public virtual int Read(Byte[] buffer, int offset, int count);
    private bool FillInBuf();
    private Byte[] ReadAndProcessBlock();
    public virtual void Write(Byte[] buffer, int offset, int count);
    public virtual void WriteByte(byte b);
    public virtual bool get_CanRead();
    public virtual bool get_CanWrite();
    public virtual bool get_CanSeek();
    public sealed virtual long get_Length();
    public sealed virtual long get_Position();
    public sealed virtual void set_Position(long value);
    public virtual void Close();
    public virtual void Flush();
    public sealed virtual long Seek(long offset, SeekOrigin origin);
    public sealed virtual void SetLength(long length);
}
public class Org.BouncyCastle.Crypto.IO.DigestStream : Stream {
    protected Stream stream;
    protected IDigest inDigest;
    protected IDigest outDigest;
    public bool CanRead { get; }
    public bool CanWrite { get; }
    public bool CanSeek { get; }
    public long Length { get; }
    public long Position { get; public set; }
    public DigestStream(Stream stream, IDigest readDigest, IDigest writeDigest);
    public virtual IDigest ReadDigest();
    public virtual IDigest WriteDigest();
    public virtual int Read(Byte[] buffer, int offset, int count);
    public virtual int ReadByte();
    public virtual void Write(Byte[] buffer, int offset, int count);
    public virtual void WriteByte(byte b);
    public virtual bool get_CanRead();
    public virtual bool get_CanWrite();
    public virtual bool get_CanSeek();
    public virtual long get_Length();
    public virtual long get_Position();
    public virtual void set_Position(long value);
    public virtual void Close();
    public virtual void Flush();
    public virtual long Seek(long offset, SeekOrigin origin);
    public virtual void SetLength(long length);
}
public class Org.BouncyCastle.Crypto.IO.MacStream : Stream {
    protected Stream stream;
    protected IMac inMac;
    protected IMac outMac;
    public bool CanRead { get; }
    public bool CanWrite { get; }
    public bool CanSeek { get; }
    public long Length { get; }
    public long Position { get; public set; }
    public MacStream(Stream stream, IMac readMac, IMac writeMac);
    public virtual IMac ReadMac();
    public virtual IMac WriteMac();
    public virtual int Read(Byte[] buffer, int offset, int count);
    public virtual int ReadByte();
    public virtual void Write(Byte[] buffer, int offset, int count);
    public virtual void WriteByte(byte b);
    public virtual bool get_CanRead();
    public virtual bool get_CanWrite();
    public virtual bool get_CanSeek();
    public virtual long get_Length();
    public virtual long get_Position();
    public virtual void set_Position(long value);
    public virtual void Close();
    public virtual void Flush();
    public virtual long Seek(long offset, SeekOrigin origin);
    public virtual void SetLength(long length);
}
public class Org.BouncyCastle.Crypto.IO.SignerStream : Stream {
    protected Stream stream;
    protected ISigner inSigner;
    protected ISigner outSigner;
    public bool CanRead { get; }
    public bool CanWrite { get; }
    public bool CanSeek { get; }
    public long Length { get; }
    public long Position { get; public set; }
    public SignerStream(Stream stream, ISigner readSigner, ISigner writeSigner);
    public virtual ISigner ReadSigner();
    public virtual ISigner WriteSigner();
    public virtual int Read(Byte[] buffer, int offset, int count);
    public virtual int ReadByte();
    public virtual void Write(Byte[] buffer, int offset, int count);
    public virtual void WriteByte(byte b);
    public virtual bool get_CanRead();
    public virtual bool get_CanWrite();
    public virtual bool get_CanSeek();
    public virtual long get_Length();
    public virtual long get_Position();
    public virtual void set_Position(long value);
    public virtual void Close();
    public virtual void Flush();
    public virtual long Seek(long offset, SeekOrigin origin);
    public virtual void SetLength(long length);
}
public interface Org.BouncyCastle.Crypto.ISigner {
    public string AlgorithmName { get; }
    public abstract virtual string get_AlgorithmName();
    public abstract virtual void Init(bool forSigning, ICipherParameters parameters);
    public abstract virtual void Update(byte input);
    public abstract virtual void BlockUpdate(Byte[] input, int inOff, int length);
    public abstract virtual Byte[] GenerateSignature();
    public abstract virtual bool VerifySignature(Byte[] signature);
    public abstract virtual void Reset();
}
public interface Org.BouncyCastle.Crypto.ISignerWithRecovery {
    public abstract virtual bool HasFullMessage();
    public abstract virtual Byte[] GetRecoveredMessage();
    public abstract virtual void UpdateWithRecoveredMessage(Byte[] signature);
}
public interface Org.BouncyCastle.Crypto.IStreamCipher {
    public string AlgorithmName { get; }
    public abstract virtual string get_AlgorithmName();
    public abstract virtual void Init(bool forEncryption, ICipherParameters parameters);
    public abstract virtual byte ReturnByte(byte input);
    public abstract virtual void ProcessBytes(Byte[] input, int inOff, int length, Byte[] output, int outOff);
    public abstract virtual void Reset();
}
public interface Org.BouncyCastle.Crypto.IWrapper {
    public string AlgorithmName { get; }
    public abstract virtual string get_AlgorithmName();
    public abstract virtual void Init(bool forWrapping, ICipherParameters parameters);
    public abstract virtual Byte[] Wrap(Byte[] input, int inOff, int length);
    public abstract virtual Byte[] Unwrap(Byte[] input, int inOff, int length);
}
public class Org.BouncyCastle.Crypto.KeyGenerationParameters : object {
    private SecureRandom random;
    private int strength;
    public SecureRandom Random { get; }
    public int Strength { get; }
    public KeyGenerationParameters(SecureRandom random, int strength);
    public SecureRandom get_Random();
    public int get_Strength();
}
public class Org.BouncyCastle.Crypto.Macs.CbcBlockCipherMac : object {
    private Byte[] buf;
    private int bufOff;
    private IBlockCipher cipher;
    private IBlockCipherPadding padding;
    private int macSize;
    public string AlgorithmName { get; }
    public CbcBlockCipherMac(IBlockCipher cipher);
    public CbcBlockCipherMac(IBlockCipher cipher, IBlockCipherPadding padding);
    public CbcBlockCipherMac(IBlockCipher cipher, int macSizeInBits);
    public CbcBlockCipherMac(IBlockCipher cipher, int macSizeInBits, IBlockCipherPadding padding);
    public sealed virtual string get_AlgorithmName();
    public sealed virtual void Init(ICipherParameters parameters);
    public sealed virtual int GetMacSize();
    public sealed virtual void Update(byte input);
    public sealed virtual void BlockUpdate(Byte[] input, int inOff, int len);
    public sealed virtual int DoFinal(Byte[] output, int outOff);
    public sealed virtual void Reset();
}
public class Org.BouncyCastle.Crypto.Macs.CfbBlockCipherMac : object {
    private Byte[] mac;
    private Byte[] Buffer;
    private int bufOff;
    private MacCFBBlockCipher cipher;
    private IBlockCipherPadding padding;
    private int macSize;
    public string AlgorithmName { get; }
    public CfbBlockCipherMac(IBlockCipher cipher);
    public CfbBlockCipherMac(IBlockCipher cipher, IBlockCipherPadding padding);
    public CfbBlockCipherMac(IBlockCipher cipher, int cfbBitSize, int macSizeInBits);
    public CfbBlockCipherMac(IBlockCipher cipher, int cfbBitSize, int macSizeInBits, IBlockCipherPadding padding);
    public sealed virtual string get_AlgorithmName();
    public sealed virtual void Init(ICipherParameters parameters);
    public sealed virtual int GetMacSize();
    public sealed virtual void Update(byte input);
    public sealed virtual void BlockUpdate(Byte[] input, int inOff, int len);
    public sealed virtual int DoFinal(Byte[] output, int outOff);
    public sealed virtual void Reset();
}
public class Org.BouncyCastle.Crypto.Macs.CMac : object {
    private static byte CONSTANT_128;
    private static byte CONSTANT_64;
    private Byte[] ZEROES;
    private Byte[] mac;
    private Byte[] buf;
    private int bufOff;
    private IBlockCipher cipher;
    private int macSize;
    private Byte[] L;
    private Byte[] Lu;
    private Byte[] Lu2;
    public string AlgorithmName { get; }
    public CMac(IBlockCipher cipher);
    public CMac(IBlockCipher cipher, int macSizeInBits);
    public sealed virtual string get_AlgorithmName();
    private static Byte[] doubleLu(Byte[] inBytes);
    public sealed virtual void Init(ICipherParameters parameters);
    public sealed virtual int GetMacSize();
    public sealed virtual void Update(byte input);
    public sealed virtual void BlockUpdate(Byte[] inBytes, int inOff, int len);
    public sealed virtual int DoFinal(Byte[] outBytes, int outOff);
    public sealed virtual void Reset();
}
public class Org.BouncyCastle.Crypto.Macs.Gost28147Mac : object {
    private static int blockSize;
    private static int macSize;
    private int bufOff;
    private Byte[] buf;
    private Byte[] mac;
    private bool firstStep;
    private Int32[] workingKey;
    private Byte[] S;
    public string AlgorithmName { get; }
    private static Int32[] generateWorkingKey(Byte[] userKey);
    public sealed virtual void Init(ICipherParameters parameters);
    public sealed virtual string get_AlgorithmName();
    public sealed virtual int GetMacSize();
    private int gost28147_mainStep(int n1, int key);
    private void gost28147MacFunc(Int32[] workingKey, Byte[] input, int inOff, Byte[] output, int outOff);
    private static int bytesToint(Byte[] input, int inOff);
    private static void intTobytes(int num, Byte[] output, int outOff);
    private static Byte[] CM5func(Byte[] buf, int bufOff, Byte[] mac);
    public sealed virtual void Update(byte input);
    public sealed virtual void BlockUpdate(Byte[] input, int inOff, int len);
    public sealed virtual int DoFinal(Byte[] output, int outOff);
    public sealed virtual void Reset();
}
public class Org.BouncyCastle.Crypto.Macs.HMac : object {
    private static byte IPAD;
    private static byte OPAD;
    private IDigest digest;
    private int digestSize;
    private int blockLength;
    private Byte[] inputPad;
    private Byte[] outputBuf;
    public string AlgorithmName { get; }
    public HMac(IDigest digest);
    public virtual string get_AlgorithmName();
    public virtual IDigest GetUnderlyingDigest();
    public virtual void Init(ICipherParameters parameters);
    public virtual int GetMacSize();
    public virtual void Update(byte input);
    public virtual void BlockUpdate(Byte[] input, int inOff, int len);
    public virtual int DoFinal(Byte[] output, int outOff);
    public virtual void Reset();
    private static void XorPad(Byte[] pad, int len, byte n);
}
public class Org.BouncyCastle.Crypto.Macs.ISO9797Alg3Mac : object {
    private Byte[] mac;
    private Byte[] buf;
    private int bufOff;
    private IBlockCipher cipher;
    private IBlockCipherPadding padding;
    private int macSize;
    private KeyParameter lastKey2;
    private KeyParameter lastKey3;
    public string AlgorithmName { get; }
    public ISO9797Alg3Mac(IBlockCipher cipher);
    public ISO9797Alg3Mac(IBlockCipher cipher, IBlockCipherPadding padding);
    public ISO9797Alg3Mac(IBlockCipher cipher, int macSizeInBits);
    public ISO9797Alg3Mac(IBlockCipher cipher, int macSizeInBits, IBlockCipherPadding padding);
    public sealed virtual string get_AlgorithmName();
    public sealed virtual void Init(ICipherParameters parameters);
    public sealed virtual int GetMacSize();
    public sealed virtual void Update(byte input);
    public sealed virtual void BlockUpdate(Byte[] input, int inOff, int len);
    public sealed virtual int DoFinal(Byte[] output, int outOff);
    public sealed virtual void Reset();
}
internal class Org.BouncyCastle.Crypto.Macs.MacCFBBlockCipher : object {
    private Byte[] IV;
    private Byte[] cfbV;
    private Byte[] cfbOutV;
    private int blockSize;
    private IBlockCipher cipher;
    public string AlgorithmName { get; }
    public bool IsPartialBlockOkay { get; }
    public MacCFBBlockCipher(IBlockCipher cipher, int bitBlockSize);
    public sealed virtual void Init(bool forEncryption, ICipherParameters parameters);
    public sealed virtual string get_AlgorithmName();
    public sealed virtual bool get_IsPartialBlockOkay();
    public sealed virtual int GetBlockSize();
    public sealed virtual int ProcessBlock(Byte[] input, int inOff, Byte[] outBytes, int outOff);
    public sealed virtual void Reset();
    public void GetMacBlock(Byte[] mac);
}
public class Org.BouncyCastle.Crypto.Macs.SipHash : object {
    protected int c;
    protected int d;
    protected long k0;
    protected long k1;
    protected long v0;
    protected long v1;
    protected long v2;
    protected long v3;
    protected long v4;
    protected Byte[] buf;
    protected int bufPos;
    protected int wordCount;
    public string AlgorithmName { get; }
    public SipHash(int c, int d);
    public virtual string get_AlgorithmName();
    public virtual int GetMacSize();
    public virtual void Init(ICipherParameters parameters);
    public virtual void Update(byte input);
    public virtual void BlockUpdate(Byte[] input, int offset, int length);
    public virtual long DoFinal();
    public virtual int DoFinal(Byte[] output, int outOff);
    public virtual void Reset();
    protected virtual void ProcessMessageWord();
    protected virtual void ApplySipRounds(int n);
    protected static long RotateLeft(long x, int n);
}
public class Org.BouncyCastle.Crypto.Macs.VmpcMac : object {
    private byte g;
    private byte n;
    private Byte[] P;
    private byte s;
    private Byte[] T;
    private Byte[] workingIV;
    private Byte[] workingKey;
    private byte x1;
    private byte x2;
    private byte x3;
    private byte x4;
    public string AlgorithmName { get; }
    public virtual int DoFinal(Byte[] output, int outOff);
    public virtual string get_AlgorithmName();
    public virtual int GetMacSize();
    public virtual void Init(ICipherParameters parameters);
    private void initKey(Byte[] keyBytes, Byte[] ivBytes);
    public virtual void Reset();
    public virtual void Update(byte input);
    public virtual void BlockUpdate(Byte[] input, int inOff, int len);
}
public class Org.BouncyCastle.Crypto.MaxBytesExceededException : CryptoException {
    public MaxBytesExceededException(string message);
    public MaxBytesExceededException(string message, Exception e);
}
public class Org.BouncyCastle.Crypto.Modes.CbcBlockCipher : object {
    private Byte[] IV;
    private Byte[] cbcV;
    private Byte[] cbcNextV;
    private int blockSize;
    private IBlockCipher cipher;
    private bool encrypting;
    public string AlgorithmName { get; }
    public bool IsPartialBlockOkay { get; }
    public CbcBlockCipher(IBlockCipher cipher);
    public IBlockCipher GetUnderlyingCipher();
    public sealed virtual void Init(bool forEncryption, ICipherParameters parameters);
    public sealed virtual string get_AlgorithmName();
    public sealed virtual bool get_IsPartialBlockOkay();
    public sealed virtual int GetBlockSize();
    public sealed virtual int ProcessBlock(Byte[] input, int inOff, Byte[] output, int outOff);
    public sealed virtual void Reset();
    private int EncryptBlock(Byte[] input, int inOff, Byte[] outBytes, int outOff);
    private int DecryptBlock(Byte[] input, int inOff, Byte[] outBytes, int outOff);
}
public class Org.BouncyCastle.Crypto.Modes.CcmBlockCipher : object {
    private static int BlockSize;
    private IBlockCipher cipher;
    private Byte[] macBlock;
    private bool forEncryption;
    private Byte[] nonce;
    private Byte[] initialAssociatedText;
    private int macSize;
    private ICipherParameters keyParam;
    private MemoryStream associatedText;
    private MemoryStream data;
    public string AlgorithmName { get; }
    public CcmBlockCipher(IBlockCipher cipher);
    private static CcmBlockCipher();
    public virtual IBlockCipher GetUnderlyingCipher();
    public virtual void Init(bool forEncryption, ICipherParameters parameters);
    public virtual string get_AlgorithmName();
    public virtual int GetBlockSize();
    public virtual void ProcessAadByte(byte input);
    public virtual void ProcessAadBytes(Byte[] inBytes, int inOff, int len);
    public virtual int ProcessByte(byte input, Byte[] outBytes, int outOff);
    public virtual int ProcessBytes(Byte[] inBytes, int inOff, int inLen, Byte[] outBytes, int outOff);
    public virtual int DoFinal(Byte[] outBytes, int outOff);
    public virtual void Reset();
    public virtual Byte[] GetMac();
    public virtual int GetUpdateOutputSize(int len);
    public sealed virtual int GetOutputSize(int len);
    public Byte[] ProcessPacket(Byte[] input, int inOff, int inLen);
    private int calculateMac(Byte[] data, int dataOff, int dataLen, Byte[] macBlock);
    private int GetAssociatedTextLength();
    private bool HasAssociatedText();
}
public class Org.BouncyCastle.Crypto.Modes.CfbBlockCipher : object {
    private Byte[] IV;
    private Byte[] cfbV;
    private Byte[] cfbOutV;
    private bool encrypting;
    private int blockSize;
    private IBlockCipher cipher;
    public string AlgorithmName { get; }
    public bool IsPartialBlockOkay { get; }
    public CfbBlockCipher(IBlockCipher cipher, int bitBlockSize);
    public IBlockCipher GetUnderlyingCipher();
    public sealed virtual void Init(bool forEncryption, ICipherParameters parameters);
    public sealed virtual string get_AlgorithmName();
    public sealed virtual bool get_IsPartialBlockOkay();
    public sealed virtual int GetBlockSize();
    public sealed virtual int ProcessBlock(Byte[] input, int inOff, Byte[] output, int outOff);
    public int EncryptBlock(Byte[] input, int inOff, Byte[] outBytes, int outOff);
    public int DecryptBlock(Byte[] input, int inOff, Byte[] outBytes, int outOff);
    public sealed virtual void Reset();
}
public class Org.BouncyCastle.Crypto.Modes.CtsBlockCipher : BufferedBlockCipher {
    private int blockSize;
    public CtsBlockCipher(IBlockCipher cipher);
    public virtual int GetUpdateOutputSize(int length);
    public virtual int GetOutputSize(int length);
    public virtual int ProcessByte(byte input, Byte[] output, int outOff);
    public virtual int ProcessBytes(Byte[] input, int inOff, int length, Byte[] output, int outOff);
    public virtual int DoFinal(Byte[] output, int outOff);
}
public class Org.BouncyCastle.Crypto.Modes.EaxBlockCipher : object {
    private SicBlockCipher cipher;
    private bool forEncryption;
    private int blockSize;
    private IMac mac;
    private Byte[] nonceMac;
    private Byte[] associatedTextMac;
    private Byte[] macBlock;
    private int macSize;
    private Byte[] bufBlock;
    private int bufOff;
    private bool cipherInitialized;
    private Byte[] initialAssociatedText;
    public string AlgorithmName { get; }
    public EaxBlockCipher(IBlockCipher cipher);
    public virtual string get_AlgorithmName();
    public virtual int GetBlockSize();
    public virtual void Init(bool forEncryption, ICipherParameters parameters);
    private void InitCipher();
    private void CalculateMac();
    public virtual void Reset();
    private void Reset(bool clearMac);
    public virtual void ProcessAadByte(byte input);
    public sealed virtual void ProcessAadBytes(Byte[] inBytes, int inOff, int len);
    public virtual int ProcessByte(byte input, Byte[] outBytes, int outOff);
    public virtual int ProcessBytes(Byte[] inBytes, int inOff, int len, Byte[] outBytes, int outOff);
    public virtual int DoFinal(Byte[] outBytes, int outOff);
    public virtual Byte[] GetMac();
    public virtual int GetUpdateOutputSize(int len);
    public virtual int GetOutputSize(int len);
    private int Process(byte b, Byte[] outBytes, int outOff);
    private bool VerifyMac(Byte[] mac, int off);
}
public class Org.BouncyCastle.Crypto.Modes.Gcm.BasicGcmExponentiator : object {
    private Byte[] x;
    public sealed virtual void Init(Byte[] x);
    public sealed virtual void ExponentiateX(long pow, Byte[] output);
}
public class Org.BouncyCastle.Crypto.Modes.Gcm.BasicGcmMultiplier : object {
    private Byte[] H;
    public sealed virtual void Init(Byte[] H);
    public sealed virtual void MultiplyH(Byte[] x);
}
internal abstract class Org.BouncyCastle.Crypto.Modes.Gcm.GcmUtilities : object {
    internal static Byte[] OneAsBytes();
    internal static UInt32[] OneAsUints();
    internal static UInt32[] AsUints(Byte[] bs);
    internal static void AsUints(Byte[] bs, UInt32[] output);
    internal static void Multiply(Byte[] block, Byte[] val);
    internal static void MultiplyP(UInt32[] x);
    internal static void MultiplyP(UInt32[] x, UInt32[] output);
    internal static void MultiplyP8(UInt32[] x);
    internal static void MultiplyP8(UInt32[] x, UInt32[] output);
    internal static void ShiftRight(Byte[] block);
    private static void ShiftRight(Byte[] block, Byte[] output);
    internal static void ShiftRight(UInt32[] block);
    internal static void ShiftRight(UInt32[] block, UInt32[] output);
    internal static void ShiftRightN(UInt32[] block, int n);
    internal static void ShiftRightN(UInt32[] block, int n, UInt32[] output);
    internal static void Xor(Byte[] block, Byte[] val);
    internal static void Xor(Byte[] block, Byte[] val, int off, int len);
    internal static void Xor(Byte[] block, Byte[] val, Byte[] output);
    internal static void Xor(UInt32[] block, UInt32[] val);
    internal static void Xor(UInt32[] block, UInt32[] val, UInt32[] output);
}
public interface Org.BouncyCastle.Crypto.Modes.Gcm.IGcmExponentiator {
    public abstract virtual void Init(Byte[] x);
    public abstract virtual void ExponentiateX(long pow, Byte[] output);
}
public interface Org.BouncyCastle.Crypto.Modes.Gcm.IGcmMultiplier {
    public abstract virtual void Init(Byte[] H);
    public abstract virtual void MultiplyH(Byte[] x);
}
public class Org.BouncyCastle.Crypto.Modes.Gcm.Tables1kGcmExponentiator : object {
    private IList lookupPowX2;
    public sealed virtual void Init(Byte[] x);
    public sealed virtual void ExponentiateX(long pow, Byte[] output);
    private void EnsureAvailable(int bit);
}
public class Org.BouncyCastle.Crypto.Modes.Gcm.Tables64kGcmMultiplier : object {
    private Byte[] H;
    private UInt32[][][] M;
    public sealed virtual void Init(Byte[] H);
    public sealed virtual void MultiplyH(Byte[] x);
}
public class Org.BouncyCastle.Crypto.Modes.Gcm.Tables8kGcmMultiplier : object {
    private Byte[] H;
    private UInt32[][][] M;
    public sealed virtual void Init(Byte[] H);
    public sealed virtual void MultiplyH(Byte[] x);
}
public class Org.BouncyCastle.Crypto.Modes.GcmBlockCipher : object {
    private static int BlockSize;
    private IBlockCipher cipher;
    private IGcmMultiplier multiplier;
    private IGcmExponentiator exp;
    private bool forEncryption;
    private int macSize;
    private Byte[] nonce;
    private Byte[] initialAssociatedText;
    private Byte[] H;
    private Byte[] J0;
    private Byte[] bufBlock;
    private Byte[] macBlock;
    private Byte[] S;
    private Byte[] S_at;
    private Byte[] S_atPre;
    private Byte[] counter;
    private int bufOff;
    private ulong totalLength;
    private Byte[] atBlock;
    private int atBlockPos;
    private ulong atLength;
    private ulong atLengthPre;
    public string AlgorithmName { get; }
    public GcmBlockCipher(IBlockCipher c);
    public GcmBlockCipher(IBlockCipher c, IGcmMultiplier m);
    public virtual string get_AlgorithmName();
    public virtual int GetBlockSize();
    public virtual void Init(bool forEncryption, ICipherParameters parameters);
    public virtual Byte[] GetMac();
    public virtual int GetOutputSize(int len);
    public virtual int GetUpdateOutputSize(int len);
    public virtual void ProcessAadByte(byte input);
    public virtual void ProcessAadBytes(Byte[] inBytes, int inOff, int len);
    private void InitCipher();
    public virtual int ProcessByte(byte input, Byte[] output, int outOff);
    public virtual int ProcessBytes(Byte[] input, int inOff, int len, Byte[] output, int outOff);
    private void OutputBlock(Byte[] output, int offset);
    public sealed virtual int DoFinal(Byte[] output, int outOff);
    public virtual void Reset();
    private void Reset(bool clearMac);
    private void gCTRBlock(Byte[] block, Byte[] output, int outOff);
    private void gCTRPartial(Byte[] buf, int off, int len, Byte[] output, int outOff);
    private void gHASH(Byte[] Y, Byte[] b, int len);
    private void gHASHBlock(Byte[] Y, Byte[] b);
    private void gHASHPartial(Byte[] Y, Byte[] b, int off, int len);
    private Byte[] GetNextCounterBlock();
}
public class Org.BouncyCastle.Crypto.Modes.GOfbBlockCipher : object {
    private static int C1;
    private static int C2;
    private Byte[] IV;
    private Byte[] ofbV;
    private Byte[] ofbOutV;
    private int blockSize;
    private IBlockCipher cipher;
    private bool firstStep;
    private int N3;
    private int N4;
    public string AlgorithmName { get; }
    public bool IsPartialBlockOkay { get; }
    public GOfbBlockCipher(IBlockCipher cipher);
    public IBlockCipher GetUnderlyingCipher();
    public sealed virtual void Init(bool forEncryption, ICipherParameters parameters);
    public sealed virtual string get_AlgorithmName();
    public sealed virtual bool get_IsPartialBlockOkay();
    public sealed virtual int GetBlockSize();
    public sealed virtual int ProcessBlock(Byte[] input, int inOff, Byte[] output, int outOff);
    public sealed virtual void Reset();
    private int bytesToint(Byte[] inBytes, int inOff);
    private void intTobytes(int num, Byte[] outBytes, int outOff);
}
public interface Org.BouncyCastle.Crypto.Modes.IAeadBlockCipher {
    public string AlgorithmName { get; }
    public abstract virtual string get_AlgorithmName();
    public abstract virtual void Init(bool forEncryption, ICipherParameters parameters);
    public abstract virtual int GetBlockSize();
    public abstract virtual void ProcessAadByte(byte input);
    public abstract virtual void ProcessAadBytes(Byte[] inBytes, int inOff, int len);
    public abstract virtual int ProcessByte(byte input, Byte[] outBytes, int outOff);
    public abstract virtual int ProcessBytes(Byte[] inBytes, int inOff, int len, Byte[] outBytes, int outOff);
    public abstract virtual int DoFinal(Byte[] outBytes, int outOff);
    public abstract virtual Byte[] GetMac();
    public abstract virtual int GetUpdateOutputSize(int len);
    public abstract virtual int GetOutputSize(int len);
    public abstract virtual void Reset();
}
public class Org.BouncyCastle.Crypto.Modes.OcbBlockCipher : object {
    private static int BLOCK_SIZE;
    private IBlockCipher hashCipher;
    private IBlockCipher mainCipher;
    private bool forEncryption;
    private int macSize;
    private Byte[] initialAssociatedText;
    private IList L;
    private Byte[] L_Asterisk;
    private Byte[] L_Dollar;
    private Byte[] OffsetMAIN_0;
    private Byte[] hashBlock;
    private Byte[] mainBlock;
    private int hashBlockPos;
    private int mainBlockPos;
    private long hashBlockCount;
    private long mainBlockCount;
    private Byte[] OffsetHASH;
    private Byte[] Sum;
    private Byte[] OffsetMAIN;
    private Byte[] Checksum;
    private Byte[] macBlock;
    public string AlgorithmName { get; }
    public OcbBlockCipher(IBlockCipher hashCipher, IBlockCipher mainCipher);
    public virtual IBlockCipher GetUnderlyingCipher();
    public virtual string get_AlgorithmName();
    public virtual void Init(bool forEncryption, ICipherParameters parameters);
    public virtual int GetBlockSize();
    public virtual Byte[] GetMac();
    public virtual int GetOutputSize(int len);
    public virtual int GetUpdateOutputSize(int len);
    public virtual void ProcessAadByte(byte input);
    public virtual void ProcessAadBytes(Byte[] input, int off, int len);
    public virtual int ProcessByte(byte input, Byte[] output, int outOff);
    public virtual int ProcessBytes(Byte[] input, int inOff, int len, Byte[] output, int outOff);
    public virtual int DoFinal(Byte[] output, int outOff);
    public virtual void Reset();
    protected virtual void Clear(Byte[] bs);
    protected virtual Byte[] GetLSub(int n);
    protected virtual void ProcessHashBlock();
    protected virtual void ProcessMainBlock(Byte[] output, int outOff);
    protected virtual void Reset(bool clearMac);
    protected virtual void UpdateHASH(Byte[] LSub);
    protected static Byte[] OCB_double(Byte[] block);
    protected static void OCB_extend(Byte[] block, int pos);
    protected static int OCB_ntz(long x);
    protected static int ShiftLeft(Byte[] block, Byte[] output);
    protected static void Xor(Byte[] block, Byte[] val);
}
public class Org.BouncyCastle.Crypto.Modes.OfbBlockCipher : object {
    private Byte[] IV;
    private Byte[] ofbV;
    private Byte[] ofbOutV;
    private int blockSize;
    private IBlockCipher cipher;
    public string AlgorithmName { get; }
    public bool IsPartialBlockOkay { get; }
    public OfbBlockCipher(IBlockCipher cipher, int blockSize);
    public IBlockCipher GetUnderlyingCipher();
    public sealed virtual void Init(bool forEncryption, ICipherParameters parameters);
    public sealed virtual string get_AlgorithmName();
    public sealed virtual bool get_IsPartialBlockOkay();
    public sealed virtual int GetBlockSize();
    public sealed virtual int ProcessBlock(Byte[] input, int inOff, Byte[] output, int outOff);
    public sealed virtual void Reset();
}
public class Org.BouncyCastle.Crypto.Modes.OpenPgpCfbBlockCipher : object {
    private Byte[] IV;
    private Byte[] FR;
    private Byte[] FRE;
    private IBlockCipher cipher;
    private int blockSize;
    private int count;
    private bool forEncryption;
    public string AlgorithmName { get; }
    public bool IsPartialBlockOkay { get; }
    public OpenPgpCfbBlockCipher(IBlockCipher cipher);
    public IBlockCipher GetUnderlyingCipher();
    public sealed virtual string get_AlgorithmName();
    public sealed virtual bool get_IsPartialBlockOkay();
    public sealed virtual int GetBlockSize();
    public sealed virtual int ProcessBlock(Byte[] input, int inOff, Byte[] output, int outOff);
    public sealed virtual void Reset();
    public sealed virtual void Init(bool forEncryption, ICipherParameters parameters);
    private byte EncryptByte(byte data, int blockOff);
    private int EncryptBlock(Byte[] input, int inOff, Byte[] outBytes, int outOff);
    private int DecryptBlock(Byte[] input, int inOff, Byte[] outBytes, int outOff);
}
public class Org.BouncyCastle.Crypto.Modes.SicBlockCipher : object {
    private IBlockCipher cipher;
    private int blockSize;
    private Byte[] IV;
    private Byte[] counter;
    private Byte[] counterOut;
    public string AlgorithmName { get; }
    public bool IsPartialBlockOkay { get; }
    public SicBlockCipher(IBlockCipher cipher);
    public IBlockCipher GetUnderlyingCipher();
    public sealed virtual void Init(bool forEncryption, ICipherParameters parameters);
    public sealed virtual string get_AlgorithmName();
    public sealed virtual bool get_IsPartialBlockOkay();
    public sealed virtual int GetBlockSize();
    public sealed virtual int ProcessBlock(Byte[] input, int inOff, Byte[] output, int outOff);
    public sealed virtual void Reset();
}
public interface Org.BouncyCastle.Crypto.Paddings.IBlockCipherPadding {
    public string PaddingName { get; }
    public abstract virtual void Init(SecureRandom random);
    public abstract virtual string get_PaddingName();
    public abstract virtual int AddPadding(Byte[] input, int inOff);
    public abstract virtual int PadCount(Byte[] input);
}
public class Org.BouncyCastle.Crypto.Paddings.ISO10126d2Padding : object {
    private SecureRandom random;
    public string PaddingName { get; }
    public sealed virtual void Init(SecureRandom random);
    public sealed virtual string get_PaddingName();
    public sealed virtual int AddPadding(Byte[] input, int inOff);
    public sealed virtual int PadCount(Byte[] input);
}
public class Org.BouncyCastle.Crypto.Paddings.ISO7816d4Padding : object {
    public string PaddingName { get; }
    public sealed virtual void Init(SecureRandom random);
    public sealed virtual string get_PaddingName();
    public sealed virtual int AddPadding(Byte[] input, int inOff);
    public sealed virtual int PadCount(Byte[] input);
}
public class Org.BouncyCastle.Crypto.Paddings.PaddedBufferedBlockCipher : BufferedBlockCipher {
    private IBlockCipherPadding padding;
    public PaddedBufferedBlockCipher(IBlockCipher cipher, IBlockCipherPadding padding);
    public PaddedBufferedBlockCipher(IBlockCipher cipher);
    public virtual void Init(bool forEncryption, ICipherParameters parameters);
    public virtual int GetOutputSize(int length);
    public virtual int GetUpdateOutputSize(int length);
    public virtual int ProcessByte(byte input, Byte[] output, int outOff);
    public virtual int ProcessBytes(Byte[] input, int inOff, int length, Byte[] output, int outOff);
    public virtual int DoFinal(Byte[] output, int outOff);
}
public class Org.BouncyCastle.Crypto.Paddings.Pkcs7Padding : object {
    public string PaddingName { get; }
    public sealed virtual void Init(SecureRandom random);
    public sealed virtual string get_PaddingName();
    public sealed virtual int AddPadding(Byte[] input, int inOff);
    public sealed virtual int PadCount(Byte[] input);
}
public class Org.BouncyCastle.Crypto.Paddings.TbcPadding : object {
    public string PaddingName { get; }
    public sealed virtual string get_PaddingName();
    public virtual void Init(SecureRandom random);
    public virtual int AddPadding(Byte[] input, int inOff);
    public virtual int PadCount(Byte[] input);
}
public class Org.BouncyCastle.Crypto.Paddings.X923Padding : object {
    private SecureRandom random;
    public string PaddingName { get; }
    public sealed virtual void Init(SecureRandom random);
    public sealed virtual string get_PaddingName();
    public sealed virtual int AddPadding(Byte[] input, int inOff);
    public sealed virtual int PadCount(Byte[] input);
}
public class Org.BouncyCastle.Crypto.Paddings.ZeroBytePadding : object {
    public string PaddingName { get; }
    public sealed virtual string get_PaddingName();
    public sealed virtual void Init(SecureRandom random);
    public sealed virtual int AddPadding(Byte[] input, int inOff);
    public sealed virtual int PadCount(Byte[] input);
}
public class Org.BouncyCastle.Crypto.Parameters.AeadParameters : object {
    private Byte[] associatedText;
    private Byte[] nonce;
    private KeyParameter key;
    private int macSize;
    public KeyParameter Key { get; }
    public int MacSize { get; }
    public AeadParameters(KeyParameter key, int macSize, Byte[] nonce);
    public AeadParameters(KeyParameter key, int macSize, Byte[] nonce, Byte[] associatedText);
    public virtual KeyParameter get_Key();
    public virtual int get_MacSize();
    public virtual Byte[] GetAssociatedText();
    public virtual Byte[] GetNonce();
}
[ObsoleteAttribute("Use AeadParameters")]
public class Org.BouncyCastle.Crypto.Parameters.CcmParameters : AeadParameters {
    public CcmParameters(KeyParameter key, int macSize, Byte[] nonce, Byte[] associatedText);
}
public class Org.BouncyCastle.Crypto.Parameters.DesEdeParameters : DesParameters {
    public static int DesEdeKeyLength;
    public DesEdeParameters(Byte[] key);
    public DesEdeParameters(Byte[] key, int keyOff, int keyLen);
    private static Byte[] FixKey(Byte[] key, int keyOff, int keyLen);
    public static bool IsWeakKey(Byte[] key, int offset, int length);
    public static bool IsWeakKey(Byte[] key, int offset);
    public static bool IsWeakKey(Byte[] key);
}
public class Org.BouncyCastle.Crypto.Parameters.DesParameters : KeyParameter {
    public static int DesKeyLength;
    private static int N_DES_WEAK_KEYS;
    private static Byte[] DES_weak_keys;
    public DesParameters(Byte[] key);
    public DesParameters(Byte[] key, int keyOff, int keyLen);
    private static DesParameters();
    public static bool IsWeakKey(Byte[] key, int offset);
    public static bool IsWeakKey(Byte[] key);
    public static void SetOddParity(Byte[] bytes);
}
public class Org.BouncyCastle.Crypto.Parameters.DHKeyGenerationParameters : KeyGenerationParameters {
    private DHParameters parameters;
    public DHParameters Parameters { get; }
    public DHKeyGenerationParameters(SecureRandom random, DHParameters parameters);
    public DHParameters get_Parameters();
    internal static int GetStrength(DHParameters parameters);
}
public class Org.BouncyCastle.Crypto.Parameters.DHKeyParameters : AsymmetricKeyParameter {
    private DHParameters parameters;
    private DerObjectIdentifier algorithmOid;
    public DHParameters Parameters { get; }
    public DerObjectIdentifier AlgorithmOid { get; }
    protected DHKeyParameters(bool isPrivate, DHParameters parameters);
    protected DHKeyParameters(bool isPrivate, DHParameters parameters, DerObjectIdentifier algorithmOid);
    public DHParameters get_Parameters();
    public DerObjectIdentifier get_AlgorithmOid();
    public virtual bool Equals(object obj);
    protected bool Equals(DHKeyParameters other);
    public virtual int GetHashCode();
}
public class Org.BouncyCastle.Crypto.Parameters.DHParameters : object {
    private static int DefaultMinimumLength;
    private BigInteger p;
    private BigInteger g;
    private BigInteger q;
    private BigInteger j;
    private int m;
    private int l;
    private DHValidationParameters validation;
    public BigInteger P { get; }
    public BigInteger G { get; }
    public BigInteger Q { get; }
    public BigInteger J { get; }
    public int M { get; }
    public int L { get; }
    public DHValidationParameters ValidationParameters { get; }
    public DHParameters(BigInteger p, BigInteger g);
    public DHParameters(BigInteger p, BigInteger g, BigInteger q);
    public DHParameters(BigInteger p, BigInteger g, BigInteger q, int l);
    public DHParameters(BigInteger p, BigInteger g, BigInteger q, int m, int l);
    public DHParameters(BigInteger p, BigInteger g, BigInteger q, BigInteger j, DHValidationParameters validation);
    public DHParameters(BigInteger p, BigInteger g, BigInteger q, int m, int l, BigInteger j, DHValidationParameters validation);
    private static int GetDefaultMParam(int lParam);
    public BigInteger get_P();
    public BigInteger get_G();
    public BigInteger get_Q();
    public BigInteger get_J();
    public int get_M();
    public int get_L();
    public DHValidationParameters get_ValidationParameters();
    public virtual bool Equals(object obj);
    protected bool Equals(DHParameters other);
    public virtual int GetHashCode();
}
public class Org.BouncyCastle.Crypto.Parameters.DHPrivateKeyParameters : DHKeyParameters {
    private BigInteger x;
    public BigInteger X { get; }
    public DHPrivateKeyParameters(BigInteger x, DHParameters parameters);
    public DHPrivateKeyParameters(BigInteger x, DHParameters parameters, DerObjectIdentifier algorithmOid);
    public BigInteger get_X();
    public virtual bool Equals(object obj);
    protected bool Equals(DHPrivateKeyParameters other);
    public virtual int GetHashCode();
}
public class Org.BouncyCastle.Crypto.Parameters.DHPublicKeyParameters : DHKeyParameters {
    private BigInteger y;
    public BigInteger Y { get; }
    public DHPublicKeyParameters(BigInteger y, DHParameters parameters);
    public DHPublicKeyParameters(BigInteger y, DHParameters parameters, DerObjectIdentifier algorithmOid);
    public BigInteger get_Y();
    public virtual bool Equals(object obj);
    protected bool Equals(DHPublicKeyParameters other);
    public virtual int GetHashCode();
}
public class Org.BouncyCastle.Crypto.Parameters.DHValidationParameters : object {
    private Byte[] seed;
    private int counter;
    public int Counter { get; }
    public DHValidationParameters(Byte[] seed, int counter);
    public Byte[] GetSeed();
    public int get_Counter();
    public virtual bool Equals(object obj);
    protected bool Equals(DHValidationParameters other);
    public virtual int GetHashCode();
}
public class Org.BouncyCastle.Crypto.Parameters.DsaKeyGenerationParameters : KeyGenerationParameters {
    private DsaParameters parameters;
    public DsaParameters Parameters { get; }
    public DsaKeyGenerationParameters(SecureRandom random, DsaParameters parameters);
    public DsaParameters get_Parameters();
}
public abstract class Org.BouncyCastle.Crypto.Parameters.DsaKeyParameters : AsymmetricKeyParameter {
    private DsaParameters parameters;
    public DsaParameters Parameters { get; }
    protected DsaKeyParameters(bool isPrivate, DsaParameters parameters);
    public DsaParameters get_Parameters();
    public virtual bool Equals(object obj);
    protected bool Equals(DsaKeyParameters other);
    public virtual int GetHashCode();
}
public class Org.BouncyCastle.Crypto.Parameters.DsaParameterGenerationParameters : object {
    public static int DigitalSignatureUsage;
    public static int KeyEstablishmentUsage;
    private int l;
    private int n;
    private int certainty;
    private SecureRandom random;
    private int usageIndex;
    public int L { get; }
    public int N { get; }
    public int UsageIndex { get; }
    public int Certainty { get; }
    public SecureRandom Random { get; }
    public DsaParameterGenerationParameters(int L, int N, int certainty, SecureRandom random);
    public DsaParameterGenerationParameters(int L, int N, int certainty, SecureRandom random, int usageIndex);
    public virtual int get_L();
    public virtual int get_N();
    public virtual int get_UsageIndex();
    public virtual int get_Certainty();
    public virtual SecureRandom get_Random();
}
public class Org.BouncyCastle.Crypto.Parameters.DsaParameters : object {
    private BigInteger p;
    private BigInteger q;
    private BigInteger g;
    private DsaValidationParameters validation;
    public BigInteger P { get; }
    public BigInteger Q { get; }
    public BigInteger G { get; }
    public DsaValidationParameters ValidationParameters { get; }
    public DsaParameters(BigInteger p, BigInteger q, BigInteger g);
    public DsaParameters(BigInteger p, BigInteger q, BigInteger g, DsaValidationParameters parameters);
    public BigInteger get_P();
    public BigInteger get_Q();
    public BigInteger get_G();
    public DsaValidationParameters get_ValidationParameters();
    public virtual bool Equals(object obj);
    protected bool Equals(DsaParameters other);
    public virtual int GetHashCode();
}
public class Org.BouncyCastle.Crypto.Parameters.DsaPrivateKeyParameters : DsaKeyParameters {
    private BigInteger x;
    public BigInteger X { get; }
    public DsaPrivateKeyParameters(BigInteger x, DsaParameters parameters);
    public BigInteger get_X();
    public virtual bool Equals(object obj);
    protected bool Equals(DsaPrivateKeyParameters other);
    public virtual int GetHashCode();
}
public class Org.BouncyCastle.Crypto.Parameters.DsaPublicKeyParameters : DsaKeyParameters {
    private BigInteger y;
    public BigInteger Y { get; }
    public DsaPublicKeyParameters(BigInteger y, DsaParameters parameters);
    public BigInteger get_Y();
    public virtual bool Equals(object obj);
    protected bool Equals(DsaPublicKeyParameters other);
    public virtual int GetHashCode();
}
public class Org.BouncyCastle.Crypto.Parameters.DsaValidationParameters : object {
    private Byte[] seed;
    private int counter;
    private int usageIndex;
    public int Counter { get; }
    public int UsageIndex { get; }
    public DsaValidationParameters(Byte[] seed, int counter);
    public DsaValidationParameters(Byte[] seed, int counter, int usageIndex);
    public virtual Byte[] GetSeed();
    public virtual int get_Counter();
    public virtual int get_UsageIndex();
    public virtual bool Equals(object obj);
    protected virtual bool Equals(DsaValidationParameters other);
    public virtual int GetHashCode();
}
public class Org.BouncyCastle.Crypto.Parameters.ECDomainParameters : object {
    internal ECCurve curve;
    internal Byte[] seed;
    internal ECPoint g;
    internal BigInteger n;
    internal BigInteger h;
    public ECCurve Curve { get; }
    public ECPoint G { get; }
    public BigInteger N { get; }
    public BigInteger H { get; }
    public ECDomainParameters(ECCurve curve, ECPoint g, BigInteger n);
    public ECDomainParameters(ECCurve curve, ECPoint g, BigInteger n, BigInteger h);
    public ECDomainParameters(ECCurve curve, ECPoint g, BigInteger n, BigInteger h, Byte[] seed);
    public ECCurve get_Curve();
    public ECPoint get_G();
    public BigInteger get_N();
    public BigInteger get_H();
    public Byte[] GetSeed();
    public virtual bool Equals(object obj);
    protected bool Equals(ECDomainParameters other);
    public virtual int GetHashCode();
}
public class Org.BouncyCastle.Crypto.Parameters.ECKeyGenerationParameters : KeyGenerationParameters {
    private ECDomainParameters domainParams;
    private DerObjectIdentifier publicKeyParamSet;
    public ECDomainParameters DomainParameters { get; }
    public DerObjectIdentifier PublicKeyParamSet { get; }
    public ECKeyGenerationParameters(ECDomainParameters domainParameters, SecureRandom random);
    public ECKeyGenerationParameters(DerObjectIdentifier publicKeyParamSet, SecureRandom random);
    public ECDomainParameters get_DomainParameters();
    public DerObjectIdentifier get_PublicKeyParamSet();
}
public abstract class Org.BouncyCastle.Crypto.Parameters.ECKeyParameters : AsymmetricKeyParameter {
    private static String[] algorithms;
    private string algorithm;
    private ECDomainParameters parameters;
    private DerObjectIdentifier publicKeyParamSet;
    public string AlgorithmName { get; }
    public ECDomainParameters Parameters { get; }
    public DerObjectIdentifier PublicKeyParamSet { get; }
    protected ECKeyParameters(string algorithm, bool isPrivate, ECDomainParameters parameters);
    protected ECKeyParameters(string algorithm, bool isPrivate, DerObjectIdentifier publicKeyParamSet);
    private static ECKeyParameters();
    public string get_AlgorithmName();
    public ECDomainParameters get_Parameters();
    public DerObjectIdentifier get_PublicKeyParamSet();
    public virtual bool Equals(object obj);
    protected bool Equals(ECKeyParameters other);
    public virtual int GetHashCode();
    internal ECKeyGenerationParameters CreateKeyGenerationParameters(SecureRandom random);
    internal static string VerifyAlgorithmName(string algorithm);
    internal static ECDomainParameters LookupParameters(DerObjectIdentifier publicKeyParamSet);
}
public class Org.BouncyCastle.Crypto.Parameters.ECPrivateKeyParameters : ECKeyParameters {
    private BigInteger d;
    public BigInteger D { get; }
    public ECPrivateKeyParameters(BigInteger d, ECDomainParameters parameters);
    [ObsoleteAttribute("Use version with explicit 'algorithm' parameter")]
public ECPrivateKeyParameters(BigInteger d, DerObjectIdentifier publicKeyParamSet);
    public ECPrivateKeyParameters(string algorithm, BigInteger d, ECDomainParameters parameters);
    public ECPrivateKeyParameters(string algorithm, BigInteger d, DerObjectIdentifier publicKeyParamSet);
    public BigInteger get_D();
    public virtual bool Equals(object obj);
    protected bool Equals(ECPrivateKeyParameters other);
    public virtual int GetHashCode();
}
public class Org.BouncyCastle.Crypto.Parameters.ECPublicKeyParameters : ECKeyParameters {
    private ECPoint q;
    public ECPoint Q { get; }
    public ECPublicKeyParameters(ECPoint q, ECDomainParameters parameters);
    [ObsoleteAttribute("Use version with explicit 'algorithm' parameter")]
public ECPublicKeyParameters(ECPoint q, DerObjectIdentifier publicKeyParamSet);
    public ECPublicKeyParameters(string algorithm, ECPoint q, ECDomainParameters parameters);
    public ECPublicKeyParameters(string algorithm, ECPoint q, DerObjectIdentifier publicKeyParamSet);
    public ECPoint get_Q();
    public virtual bool Equals(object obj);
    protected bool Equals(ECPublicKeyParameters other);
    public virtual int GetHashCode();
}
public class Org.BouncyCastle.Crypto.Parameters.ElGamalKeyGenerationParameters : KeyGenerationParameters {
    private ElGamalParameters parameters;
    public ElGamalParameters Parameters { get; }
    public ElGamalKeyGenerationParameters(SecureRandom random, ElGamalParameters parameters);
    public ElGamalParameters get_Parameters();
    internal static int GetStrength(ElGamalParameters parameters);
}
public class Org.BouncyCastle.Crypto.Parameters.ElGamalKeyParameters : AsymmetricKeyParameter {
    private ElGamalParameters parameters;
    public ElGamalParameters Parameters { get; }
    protected ElGamalKeyParameters(bool isPrivate, ElGamalParameters parameters);
    public ElGamalParameters get_Parameters();
    public virtual bool Equals(object obj);
    protected bool Equals(ElGamalKeyParameters other);
    public virtual int GetHashCode();
}
public class Org.BouncyCastle.Crypto.Parameters.ElGamalParameters : object {
    private BigInteger p;
    private BigInteger g;
    private int l;
    public BigInteger P { get; }
    public BigInteger G { get; }
    public int L { get; }
    public ElGamalParameters(BigInteger p, BigInteger g);
    public ElGamalParameters(BigInteger p, BigInteger g, int l);
    public BigInteger get_P();
    public BigInteger get_G();
    public int get_L();
    public virtual bool Equals(object obj);
    protected bool Equals(ElGamalParameters other);
    public virtual int GetHashCode();
}
public class Org.BouncyCastle.Crypto.Parameters.ElGamalPrivateKeyParameters : ElGamalKeyParameters {
    private BigInteger x;
    public BigInteger X { get; }
    public ElGamalPrivateKeyParameters(BigInteger x, ElGamalParameters parameters);
    public BigInteger get_X();
    public virtual bool Equals(object obj);
    protected bool Equals(ElGamalPrivateKeyParameters other);
    public virtual int GetHashCode();
}
public class Org.BouncyCastle.Crypto.Parameters.ElGamalPublicKeyParameters : ElGamalKeyParameters {
    private BigInteger y;
    public BigInteger Y { get; }
    public ElGamalPublicKeyParameters(BigInteger y, ElGamalParameters parameters);
    public BigInteger get_Y();
    public virtual bool Equals(object obj);
    protected bool Equals(ElGamalPublicKeyParameters other);
    public virtual int GetHashCode();
}
public class Org.BouncyCastle.Crypto.Parameters.Gost3410KeyGenerationParameters : KeyGenerationParameters {
    private Gost3410Parameters parameters;
    private DerObjectIdentifier publicKeyParamSet;
    public Gost3410Parameters Parameters { get; }
    public DerObjectIdentifier PublicKeyParamSet { get; }
    public Gost3410KeyGenerationParameters(SecureRandom random, Gost3410Parameters parameters);
    public Gost3410KeyGenerationParameters(SecureRandom random, DerObjectIdentifier publicKeyParamSet);
    public Gost3410Parameters get_Parameters();
    public DerObjectIdentifier get_PublicKeyParamSet();
    private static Gost3410Parameters LookupParameters(DerObjectIdentifier publicKeyParamSet);
}
public abstract class Org.BouncyCastle.Crypto.Parameters.Gost3410KeyParameters : AsymmetricKeyParameter {
    private Gost3410Parameters parameters;
    private DerObjectIdentifier publicKeyParamSet;
    public Gost3410Parameters Parameters { get; }
    public DerObjectIdentifier PublicKeyParamSet { get; }
    protected Gost3410KeyParameters(bool isPrivate, Gost3410Parameters parameters);
    protected Gost3410KeyParameters(bool isPrivate, DerObjectIdentifier publicKeyParamSet);
    public Gost3410Parameters get_Parameters();
    public DerObjectIdentifier get_PublicKeyParamSet();
    private static Gost3410Parameters LookupParameters(DerObjectIdentifier publicKeyParamSet);
}
public class Org.BouncyCastle.Crypto.Parameters.Gost3410Parameters : object {
    private BigInteger p;
    private BigInteger q;
    private BigInteger a;
    private Gost3410ValidationParameters validation;
    public BigInteger P { get; }
    public BigInteger Q { get; }
    public BigInteger A { get; }
    public Gost3410ValidationParameters ValidationParameters { get; }
    public Gost3410Parameters(BigInteger p, BigInteger q, BigInteger a);
    public Gost3410Parameters(BigInteger p, BigInteger q, BigInteger a, Gost3410ValidationParameters validation);
    public BigInteger get_P();
    public BigInteger get_Q();
    public BigInteger get_A();
    public Gost3410ValidationParameters get_ValidationParameters();
    public virtual bool Equals(object obj);
    protected bool Equals(Gost3410Parameters other);
    public virtual int GetHashCode();
}
public class Org.BouncyCastle.Crypto.Parameters.Gost3410PrivateKeyParameters : Gost3410KeyParameters {
    private BigInteger x;
    public BigInteger X { get; }
    public Gost3410PrivateKeyParameters(BigInteger x, Gost3410Parameters parameters);
    public Gost3410PrivateKeyParameters(BigInteger x, DerObjectIdentifier publicKeyParamSet);
    public BigInteger get_X();
}
public class Org.BouncyCastle.Crypto.Parameters.Gost3410PublicKeyParameters : Gost3410KeyParameters {
    private BigInteger y;
    public BigInteger Y { get; }
    public Gost3410PublicKeyParameters(BigInteger y, Gost3410Parameters parameters);
    public Gost3410PublicKeyParameters(BigInteger y, DerObjectIdentifier publicKeyParamSet);
    public BigInteger get_Y();
}
public class Org.BouncyCastle.Crypto.Parameters.Gost3410ValidationParameters : object {
    private int x0;
    private int c;
    private long x0L;
    private long cL;
    public int C { get; }
    public int X0 { get; }
    public long CL { get; }
    public long X0L { get; }
    public Gost3410ValidationParameters(int x0, int c);
    public Gost3410ValidationParameters(long x0L, long cL);
    public int get_C();
    public int get_X0();
    public long get_CL();
    public long get_X0L();
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
}
public class Org.BouncyCastle.Crypto.Parameters.IesParameters : object {
    private Byte[] derivation;
    private Byte[] encoding;
    private int macKeySize;
    public int MacKeySize { get; }
    public IesParameters(Byte[] derivation, Byte[] encoding, int macKeySize);
    public Byte[] GetDerivationV();
    public Byte[] GetEncodingV();
    public int get_MacKeySize();
}
public class Org.BouncyCastle.Crypto.Parameters.IesWithCipherParameters : IesParameters {
    private int cipherKeySize;
    public int CipherKeySize { get; }
    public IesWithCipherParameters(Byte[] derivation, Byte[] encoding, int macKeySize, int cipherKeySize);
    public int get_CipherKeySize();
}
public class Org.BouncyCastle.Crypto.Parameters.Iso18033KdfParameters : object {
    private Byte[] seed;
    public Iso18033KdfParameters(Byte[] seed);
    public Byte[] GetSeed();
}
public class Org.BouncyCastle.Crypto.Parameters.KdfParameters : object {
    private Byte[] iv;
    private Byte[] shared;
    public KdfParameters(Byte[] shared, Byte[] iv);
    public Byte[] GetSharedSecret();
    public Byte[] GetIV();
}
public class Org.BouncyCastle.Crypto.Parameters.KeyParameter : object {
    private Byte[] key;
    public KeyParameter(Byte[] key);
    public KeyParameter(Byte[] key, int keyOff, int keyLen);
    public Byte[] GetKey();
}
public class Org.BouncyCastle.Crypto.Parameters.MgfParameters : object {
    private Byte[] seed;
    public MgfParameters(Byte[] seed);
    public MgfParameters(Byte[] seed, int off, int len);
    public Byte[] GetSeed();
}
public class Org.BouncyCastle.Crypto.Parameters.MqvPrivateParameters : object {
    private ECPrivateKeyParameters staticPrivateKey;
    private ECPrivateKeyParameters ephemeralPrivateKey;
    private ECPublicKeyParameters ephemeralPublicKey;
    public ECPrivateKeyParameters StaticPrivateKey { get; }
    public ECPrivateKeyParameters EphemeralPrivateKey { get; }
    public ECPublicKeyParameters EphemeralPublicKey { get; }
    public MqvPrivateParameters(ECPrivateKeyParameters staticPrivateKey, ECPrivateKeyParameters ephemeralPrivateKey);
    public MqvPrivateParameters(ECPrivateKeyParameters staticPrivateKey, ECPrivateKeyParameters ephemeralPrivateKey, ECPublicKeyParameters ephemeralPublicKey);
    public ECPrivateKeyParameters get_StaticPrivateKey();
    public ECPrivateKeyParameters get_EphemeralPrivateKey();
    public ECPublicKeyParameters get_EphemeralPublicKey();
}
public class Org.BouncyCastle.Crypto.Parameters.MqvPublicParameters : object {
    private ECPublicKeyParameters staticPublicKey;
    private ECPublicKeyParameters ephemeralPublicKey;
    public ECPublicKeyParameters StaticPublicKey { get; }
    public ECPublicKeyParameters EphemeralPublicKey { get; }
    public MqvPublicParameters(ECPublicKeyParameters staticPublicKey, ECPublicKeyParameters ephemeralPublicKey);
    public ECPublicKeyParameters get_StaticPublicKey();
    public ECPublicKeyParameters get_EphemeralPublicKey();
}
public class Org.BouncyCastle.Crypto.Parameters.NaccacheSternKeyGenerationParameters : KeyGenerationParameters {
    private int certainty;
    private int countSmallPrimes;
    private bool debug;
    public int Certainty { get; }
    public int CountSmallPrimes { get; }
    public bool IsDebug { get; }
    public NaccacheSternKeyGenerationParameters(SecureRandom random, int strength, int certainty, int countSmallPrimes);
    public NaccacheSternKeyGenerationParameters(SecureRandom random, int strength, int certainty, int countSmallPrimes, bool debug);
    public int get_Certainty();
    public int get_CountSmallPrimes();
    public bool get_IsDebug();
}
public class Org.BouncyCastle.Crypto.Parameters.NaccacheSternKeyParameters : AsymmetricKeyParameter {
    private BigInteger g;
    private BigInteger n;
    private int lowerSigmaBound;
    public BigInteger G { get; }
    public int LowerSigmaBound { get; }
    public BigInteger Modulus { get; }
    public NaccacheSternKeyParameters(bool privateKey, BigInteger g, BigInteger n, int lowerSigmaBound);
    public BigInteger get_G();
    public int get_LowerSigmaBound();
    public BigInteger get_Modulus();
}
public class Org.BouncyCastle.Crypto.Parameters.NaccacheSternPrivateKeyParameters : NaccacheSternKeyParameters {
    private BigInteger phiN;
    private IList smallPrimes;
    public BigInteger PhiN { get; }
    [ObsoleteAttribute("Use 'SmallPrimesList' instead")]
public ArrayList SmallPrimes { get; }
    public IList SmallPrimesList { get; }
    [ObsoleteAttribute]
public NaccacheSternPrivateKeyParameters(BigInteger g, BigInteger n, int lowerSigmaBound, ArrayList smallPrimes, BigInteger phiN);
    public NaccacheSternPrivateKeyParameters(BigInteger g, BigInteger n, int lowerSigmaBound, IList smallPrimes, BigInteger phiN);
    public BigInteger get_PhiN();
    public ArrayList get_SmallPrimes();
    public IList get_SmallPrimesList();
}
public class Org.BouncyCastle.Crypto.Parameters.ParametersWithIV : object {
    private ICipherParameters parameters;
    private Byte[] iv;
    public ICipherParameters Parameters { get; }
    public ParametersWithIV(ICipherParameters parameters, Byte[] iv);
    public ParametersWithIV(ICipherParameters parameters, Byte[] iv, int ivOff, int ivLen);
    public Byte[] GetIV();
    public ICipherParameters get_Parameters();
}
public class Org.BouncyCastle.Crypto.Parameters.ParametersWithRandom : object {
    private ICipherParameters parameters;
    private SecureRandom random;
    public SecureRandom Random { get; }
    public ICipherParameters Parameters { get; }
    public ParametersWithRandom(ICipherParameters parameters, SecureRandom random);
    public ParametersWithRandom(ICipherParameters parameters);
    [ObsoleteAttribute("Use Random property instead")]
public SecureRandom GetRandom();
    public SecureRandom get_Random();
    public ICipherParameters get_Parameters();
}
public class Org.BouncyCastle.Crypto.Parameters.ParametersWithSalt : object {
    private Byte[] salt;
    private ICipherParameters parameters;
    public ICipherParameters Parameters { get; }
    public ParametersWithSalt(ICipherParameters parameters, Byte[] salt);
    public ParametersWithSalt(ICipherParameters parameters, Byte[] salt, int saltOff, int saltLen);
    public Byte[] GetSalt();
    public ICipherParameters get_Parameters();
}
public class Org.BouncyCastle.Crypto.Parameters.ParametersWithSBox : object {
    private ICipherParameters parameters;
    private Byte[] sBox;
    public ICipherParameters Parameters { get; }
    public ParametersWithSBox(ICipherParameters parameters, Byte[] sBox);
    public Byte[] GetSBox();
    public ICipherParameters get_Parameters();
}
public class Org.BouncyCastle.Crypto.Parameters.RC2Parameters : KeyParameter {
    private int bits;
    public int EffectiveKeyBits { get; }
    public RC2Parameters(Byte[] key);
    public RC2Parameters(Byte[] key, int keyOff, int keyLen);
    public RC2Parameters(Byte[] key, int bits);
    public RC2Parameters(Byte[] key, int keyOff, int keyLen, int bits);
    public int get_EffectiveKeyBits();
}
public class Org.BouncyCastle.Crypto.Parameters.RC5Parameters : KeyParameter {
    private int rounds;
    public int Rounds { get; }
    public RC5Parameters(Byte[] key, int rounds);
    public int get_Rounds();
}
public class Org.BouncyCastle.Crypto.Parameters.RsaBlindingParameters : object {
    private RsaKeyParameters publicKey;
    private BigInteger blindingFactor;
    public RsaKeyParameters PublicKey { get; }
    public BigInteger BlindingFactor { get; }
    public RsaBlindingParameters(RsaKeyParameters publicKey, BigInteger blindingFactor);
    public RsaKeyParameters get_PublicKey();
    public BigInteger get_BlindingFactor();
}
public class Org.BouncyCastle.Crypto.Parameters.RsaKeyGenerationParameters : KeyGenerationParameters {
    private BigInteger publicExponent;
    private int certainty;
    public BigInteger PublicExponent { get; }
    public int Certainty { get; }
    public RsaKeyGenerationParameters(BigInteger publicExponent, SecureRandom random, int strength, int certainty);
    public BigInteger get_PublicExponent();
    public int get_Certainty();
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
}
public class Org.BouncyCastle.Crypto.Parameters.RsaKeyParameters : AsymmetricKeyParameter {
    private BigInteger modulus;
    private BigInteger exponent;
    public BigInteger Modulus { get; }
    public BigInteger Exponent { get; }
    public RsaKeyParameters(bool isPrivate, BigInteger modulus, BigInteger exponent);
    public BigInteger get_Modulus();
    public BigInteger get_Exponent();
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
}
public class Org.BouncyCastle.Crypto.Parameters.RsaPrivateCrtKeyParameters : RsaKeyParameters {
    private BigInteger e;
    private BigInteger p;
    private BigInteger q;
    private BigInteger dP;
    private BigInteger dQ;
    private BigInteger qInv;
    public BigInteger PublicExponent { get; }
    public BigInteger P { get; }
    public BigInteger Q { get; }
    public BigInteger DP { get; }
    public BigInteger DQ { get; }
    public BigInteger QInv { get; }
    public RsaPrivateCrtKeyParameters(BigInteger modulus, BigInteger publicExponent, BigInteger privateExponent, BigInteger p, BigInteger q, BigInteger dP, BigInteger dQ, BigInteger qInv);
    public BigInteger get_PublicExponent();
    public BigInteger get_P();
    public BigInteger get_Q();
    public BigInteger get_DP();
    public BigInteger get_DQ();
    public BigInteger get_QInv();
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    private static void ValidateValue(BigInteger x, string name, string desc);
}
public abstract class Org.BouncyCastle.Crypto.PbeParametersGenerator : object {
    protected Byte[] mPassword;
    protected Byte[] mSalt;
    protected int mIterationCount;
    public Byte[] Password { get; }
    public Byte[] Salt { get; }
    public int IterationCount { get; }
    public virtual void Init(Byte[] password, Byte[] salt, int iterationCount);
    public virtual Byte[] get_Password();
    [ObsoleteAttribute("Use 'Password' property")]
public Byte[] GetPassword();
    public virtual Byte[] get_Salt();
    [ObsoleteAttribute("Use 'Salt' property")]
public Byte[] GetSalt();
    public virtual int get_IterationCount();
    [ObsoleteAttribute("Use version with 'algorithm' parameter")]
public abstract virtual ICipherParameters GenerateDerivedParameters(int keySize);
    public abstract virtual ICipherParameters GenerateDerivedParameters(string algorithm, int keySize);
    [ObsoleteAttribute("Use version with 'algorithm' parameter")]
public abstract virtual ICipherParameters GenerateDerivedParameters(int keySize, int ivSize);
    public abstract virtual ICipherParameters GenerateDerivedParameters(string algorithm, int keySize, int ivSize);
    public abstract virtual ICipherParameters GenerateDerivedMacParameters(int keySize);
    public static Byte[] Pkcs5PasswordToBytes(Char[] password);
    [ObsoleteAttribute("Use version taking 'char[]' instead")]
public static Byte[] Pkcs5PasswordToBytes(string password);
    public static Byte[] Pkcs5PasswordToUtf8Bytes(Char[] password);
    [ObsoleteAttribute("Use version taking 'char[]' instead")]
public static Byte[] Pkcs5PasswordToUtf8Bytes(string password);
    public static Byte[] Pkcs12PasswordToBytes(Char[] password);
    public static Byte[] Pkcs12PasswordToBytes(Char[] password, bool wrongPkcs12Zero);
}
public class Org.BouncyCastle.Crypto.Prng.CryptoApiRandomGenerator : object {
    private RandomNumberGenerator rndProv;
    public CryptoApiRandomGenerator(RandomNumberGenerator rng);
    public virtual void AddSeedMaterial(Byte[] seed);
    public virtual void AddSeedMaterial(long seed);
    public virtual void NextBytes(Byte[] bytes);
    public virtual void NextBytes(Byte[] bytes, int start, int len);
}
public class Org.BouncyCastle.Crypto.Prng.DigestRandomGenerator : object {
    private static long CYCLE_COUNT;
    private long stateCounter;
    private long seedCounter;
    private IDigest digest;
    private Byte[] state;
    private Byte[] seed;
    public DigestRandomGenerator(IDigest digest);
    public sealed virtual void AddSeedMaterial(Byte[] inSeed);
    public sealed virtual void AddSeedMaterial(long rSeed);
    public sealed virtual void NextBytes(Byte[] bytes);
    public sealed virtual void NextBytes(Byte[] bytes, int start, int len);
    private void CycleSeed();
    private void GenerateState();
    private void DigestAddCounter(long seedVal);
    private void DigestUpdate(Byte[] inSeed);
    private void DigestDoFinal(Byte[] result);
}
public interface Org.BouncyCastle.Crypto.Prng.IRandomGenerator {
    public abstract virtual void AddSeedMaterial(Byte[] seed);
    public abstract virtual void AddSeedMaterial(long seed);
    public abstract virtual void NextBytes(Byte[] bytes);
    public abstract virtual void NextBytes(Byte[] bytes, int start, int len);
}
public class Org.BouncyCastle.Crypto.Prng.ReversedWindowGenerator : object {
    private IRandomGenerator generator;
    private Byte[] window;
    private int windowCount;
    public ReversedWindowGenerator(IRandomGenerator generator, int windowSize);
    public virtual void AddSeedMaterial(Byte[] seed);
    public virtual void AddSeedMaterial(long seed);
    public virtual void NextBytes(Byte[] bytes);
    public virtual void NextBytes(Byte[] bytes, int start, int len);
    private void doNextBytes(Byte[] bytes, int start, int len);
}
public class Org.BouncyCastle.Crypto.Prng.ThreadedSeedGenerator : object {
    public Byte[] GenerateSeed(int numBytes, bool fast);
}
public class Org.BouncyCastle.Crypto.Prng.VmpcRandomGenerator : object {
    private byte n;
    private Byte[] P;
    private byte s;
    public virtual void AddSeedMaterial(Byte[] seed);
    public virtual void AddSeedMaterial(long seed);
    public virtual void NextBytes(Byte[] bytes);
    public virtual void NextBytes(Byte[] bytes, int start, int len);
}
public class Org.BouncyCastle.Crypto.Signers.DsaDigestSigner : object {
    private IDigest digest;
    private IDsa dsaSigner;
    private bool forSigning;
    public string AlgorithmName { get; }
    public DsaDigestSigner(IDsa signer, IDigest digest);
    public sealed virtual string get_AlgorithmName();
    public sealed virtual void Init(bool forSigning, ICipherParameters parameters);
    public sealed virtual void Update(byte input);
    public sealed virtual void BlockUpdate(Byte[] input, int inOff, int length);
    public sealed virtual Byte[] GenerateSignature();
    public sealed virtual bool VerifySignature(Byte[] signature);
    public sealed virtual void Reset();
    private Byte[] DerEncode(BigInteger r, BigInteger s);
    private BigInteger[] DerDecode(Byte[] encoding);
}
public class Org.BouncyCastle.Crypto.Signers.DsaSigner : object {
    private DsaKeyParameters key;
    private SecureRandom random;
    public string AlgorithmName { get; }
    public sealed virtual string get_AlgorithmName();
    public sealed virtual void Init(bool forSigning, ICipherParameters parameters);
    public sealed virtual BigInteger[] GenerateSignature(Byte[] message);
    public sealed virtual bool VerifySignature(Byte[] message, BigInteger r, BigInteger s);
    private BigInteger calculateE(BigInteger n, Byte[] message);
}
public class Org.BouncyCastle.Crypto.Signers.ECDsaSigner : object {
    private ECKeyParameters key;
    private SecureRandom random;
    public string AlgorithmName { get; }
    public sealed virtual string get_AlgorithmName();
    public sealed virtual void Init(bool forSigning, ICipherParameters parameters);
    public sealed virtual BigInteger[] GenerateSignature(Byte[] message);
    public sealed virtual bool VerifySignature(Byte[] message, BigInteger r, BigInteger s);
    private BigInteger calculateE(BigInteger n, Byte[] message);
}
public class Org.BouncyCastle.Crypto.Signers.ECGost3410Signer : object {
    private ECKeyParameters key;
    private SecureRandom random;
    public string AlgorithmName { get; }
    public sealed virtual string get_AlgorithmName();
    public sealed virtual void Init(bool forSigning, ICipherParameters parameters);
    public sealed virtual BigInteger[] GenerateSignature(Byte[] message);
    public sealed virtual bool VerifySignature(Byte[] message, BigInteger r, BigInteger s);
}
public class Org.BouncyCastle.Crypto.Signers.ECNRSigner : object {
    private bool forSigning;
    private ECKeyParameters key;
    private SecureRandom random;
    public string AlgorithmName { get; }
    public sealed virtual string get_AlgorithmName();
    public sealed virtual void Init(bool forSigning, ICipherParameters parameters);
    public sealed virtual BigInteger[] GenerateSignature(Byte[] message);
    public sealed virtual bool VerifySignature(Byte[] message, BigInteger r, BigInteger s);
}
public class Org.BouncyCastle.Crypto.Signers.GenericSigner : object {
    private IAsymmetricBlockCipher engine;
    private IDigest digest;
    private bool forSigning;
    public string AlgorithmName { get; }
    public GenericSigner(IAsymmetricBlockCipher engine, IDigest digest);
    public sealed virtual string get_AlgorithmName();
    public sealed virtual void Init(bool forSigning, ICipherParameters parameters);
    public sealed virtual void Update(byte input);
    public sealed virtual void BlockUpdate(Byte[] input, int inOff, int length);
    public sealed virtual Byte[] GenerateSignature();
    public sealed virtual bool VerifySignature(Byte[] signature);
    public sealed virtual void Reset();
}
public class Org.BouncyCastle.Crypto.Signers.Gost3410DigestSigner : object {
    private IDigest digest;
    private IDsa dsaSigner;
    private bool forSigning;
    public string AlgorithmName { get; }
    public Gost3410DigestSigner(IDsa signer, IDigest digest);
    public sealed virtual string get_AlgorithmName();
    public sealed virtual void Init(bool forSigning, ICipherParameters parameters);
    public sealed virtual void Update(byte input);
    public sealed virtual void BlockUpdate(Byte[] input, int inOff, int length);
    public sealed virtual Byte[] GenerateSignature();
    public sealed virtual bool VerifySignature(Byte[] signature);
    public sealed virtual void Reset();
}
public class Org.BouncyCastle.Crypto.Signers.Gost3410Signer : object {
    private Gost3410KeyParameters key;
    private SecureRandom random;
    public string AlgorithmName { get; }
    public sealed virtual string get_AlgorithmName();
    public sealed virtual void Init(bool forSigning, ICipherParameters parameters);
    public sealed virtual BigInteger[] GenerateSignature(Byte[] message);
    public sealed virtual bool VerifySignature(Byte[] message, BigInteger r, BigInteger s);
}
public class Org.BouncyCastle.Crypto.Signers.Iso9796d2PssSigner : object {
    public static int TrailerImplicit;
    public static int TrailerRipeMD160;
    public static int TrailerRipeMD128;
    public static int TrailerSha1;
    public static int TrailerSha256;
    public static int TrailerSha512;
    public static int TrailerSha384;
    public static int TrailerWhirlpool;
    private static IDictionary trailerMap;
    private IDigest digest;
    private IAsymmetricBlockCipher cipher;
    private SecureRandom random;
    private Byte[] standardSalt;
    private int hLen;
    private int trailer;
    private int keyBits;
    private Byte[] block;
    private Byte[] mBuf;
    private int messageLength;
    private int saltLength;
    private bool fullMessage;
    private Byte[] recoveredMessage;
    private Byte[] preSig;
    private Byte[] preBlock;
    private int preMStart;
    private int preTLength;
    public string AlgorithmName { get; }
    private static Iso9796d2PssSigner();
    public Iso9796d2PssSigner(IAsymmetricBlockCipher cipher, IDigest digest, int saltLength, bool isImplicit);
    public Iso9796d2PssSigner(IAsymmetricBlockCipher cipher, IDigest digest, int saltLength);
    public sealed virtual Byte[] GetRecoveredMessage();
    public sealed virtual string get_AlgorithmName();
    public virtual void Init(bool forSigning, ICipherParameters parameters);
    private bool IsSameAs(Byte[] a, Byte[] b);
    private void ClearBlock(Byte[] block);
    public virtual void UpdateWithRecoveredMessage(Byte[] signature);
    public virtual void Update(byte input);
    public virtual void BlockUpdate(Byte[] input, int inOff, int length);
    public virtual void Reset();
    public sealed virtual Byte[] GenerateSignature();
    public virtual bool VerifySignature(Byte[] signature);
    public virtual bool HasFullMessage();
    private void ItoOSP(int i, Byte[] sp);
    private void LtoOSP(long l, Byte[] sp);
    private Byte[] MaskGeneratorFunction1(Byte[] Z, int zOff, int zLen, int length);
}
public class Org.BouncyCastle.Crypto.Signers.Iso9796d2Signer : object {
    public static int TrailerImplicit;
    public static int TrailerRipeMD160;
    public static int TrailerRipeMD128;
    public static int TrailerSha1;
    public static int TrailerSha256;
    public static int TrailerSha512;
    public static int TrailerSha384;
    public static int TrailerWhirlpool;
    private static IDictionary trailerMap;
    private IDigest digest;
    private IAsymmetricBlockCipher cipher;
    private int trailer;
    private int keyBits;
    private Byte[] block;
    private Byte[] mBuf;
    private int messageLength;
    private bool fullMessage;
    private Byte[] recoveredMessage;
    private Byte[] preSig;
    private Byte[] preBlock;
    public string AlgorithmName { get; }
    private static Iso9796d2Signer();
    public Iso9796d2Signer(IAsymmetricBlockCipher cipher, IDigest digest, bool isImplicit);
    public Iso9796d2Signer(IAsymmetricBlockCipher cipher, IDigest digest);
    public sealed virtual Byte[] GetRecoveredMessage();
    public sealed virtual string get_AlgorithmName();
    public virtual void Init(bool forSigning, ICipherParameters parameters);
    private bool IsSameAs(Byte[] a, Byte[] b);
    private void ClearBlock(Byte[] block);
    public virtual void UpdateWithRecoveredMessage(Byte[] signature);
    public sealed virtual void Update(byte input);
    public sealed virtual void BlockUpdate(Byte[] input, int inOff, int length);
    public virtual void Reset();
    public virtual Byte[] GenerateSignature();
    public virtual bool VerifySignature(Byte[] signature);
    private bool ReturnFalse(Byte[] block);
    public virtual bool HasFullMessage();
}
public class Org.BouncyCastle.Crypto.Signers.PssSigner : object {
    public static byte TrailerImplicit;
    private IDigest contentDigest1;
    private IDigest contentDigest2;
    private IDigest mgfDigest;
    private IAsymmetricBlockCipher cipher;
    private SecureRandom random;
    private int hLen;
    private int mgfhLen;
    private int sLen;
    private int emBits;
    private Byte[] salt;
    private Byte[] mDash;
    private Byte[] block;
    private byte trailer;
    public string AlgorithmName { get; }
    public PssSigner(IAsymmetricBlockCipher cipher, IDigest digest);
    public PssSigner(IAsymmetricBlockCipher cipher, IDigest digest, int saltLen);
    public PssSigner(IAsymmetricBlockCipher cipher, IDigest contentDigest, IDigest mgfDigest, int saltLen);
    public PssSigner(IAsymmetricBlockCipher cipher, IDigest digest, int saltLen, byte trailer);
    public PssSigner(IAsymmetricBlockCipher cipher, IDigest contentDigest, IDigest mgfDigest, int saltLen, byte trailer);
    private PssSigner(IAsymmetricBlockCipher cipher, IDigest contentDigest1, IDigest contentDigest2, IDigest mgfDigest, int saltLen, byte trailer);
    public static PssSigner CreateRawSigner(IAsymmetricBlockCipher cipher, IDigest digest);
    public static PssSigner CreateRawSigner(IAsymmetricBlockCipher cipher, IDigest contentDigest, IDigest mgfDigest, int saltLen, byte trailer);
    public sealed virtual string get_AlgorithmName();
    public virtual void Init(bool forSigning, ICipherParameters parameters);
    private void ClearBlock(Byte[] block);
    public virtual void Update(byte input);
    public virtual void BlockUpdate(Byte[] input, int inOff, int length);
    public virtual void Reset();
    public virtual Byte[] GenerateSignature();
    public virtual bool VerifySignature(Byte[] signature);
    private void ItoOSP(int i, Byte[] sp);
    private Byte[] MaskGeneratorFunction1(Byte[] Z, int zOff, int zLen, int length);
}
public class Org.BouncyCastle.Crypto.Signers.RsaDigestSigner : object {
    private IAsymmetricBlockCipher rsaEngine;
    private AlgorithmIdentifier algId;
    private IDigest digest;
    private bool forSigning;
    private static IDictionary oidMap;
    public string AlgorithmName { get; }
    private static RsaDigestSigner();
    public RsaDigestSigner(IDigest digest);
    public sealed virtual string get_AlgorithmName();
    public sealed virtual void Init(bool forSigning, ICipherParameters parameters);
    public sealed virtual void Update(byte input);
    public sealed virtual void BlockUpdate(Byte[] input, int inOff, int length);
    public sealed virtual Byte[] GenerateSignature();
    public sealed virtual bool VerifySignature(Byte[] signature);
    public sealed virtual void Reset();
    private Byte[] DerEncode(Byte[] hash);
}
public class Org.BouncyCastle.Crypto.StreamBlockCipher : object {
    private IBlockCipher cipher;
    private Byte[] oneByte;
    public string AlgorithmName { get; }
    public StreamBlockCipher(IBlockCipher cipher);
    public sealed virtual void Init(bool forEncryption, ICipherParameters parameters);
    public sealed virtual string get_AlgorithmName();
    public sealed virtual byte ReturnByte(byte input);
    public sealed virtual void ProcessBytes(Byte[] input, int inOff, int length, Byte[] output, int outOff);
    public sealed virtual void Reset();
}
public enum Org.BouncyCastle.Crypto.Tls.AlertDescription : Enum {
    public byte value__;
    public static AlertDescription close_notify;
    public static AlertDescription unexpected_message;
    public static AlertDescription bad_record_mac;
    public static AlertDescription decryption_failed;
    public static AlertDescription record_overflow;
    public static AlertDescription decompression_failure;
    public static AlertDescription handshake_failure;
    public static AlertDescription bad_certificate;
    public static AlertDescription unsupported_certificate;
    public static AlertDescription certificate_revoked;
    public static AlertDescription certificate_expired;
    public static AlertDescription certificate_unknown;
    public static AlertDescription illegal_parameter;
    public static AlertDescription unknown_ca;
    public static AlertDescription access_denied;
    public static AlertDescription decode_error;
    public static AlertDescription decrypt_error;
    public static AlertDescription export_restriction;
    public static AlertDescription protocol_version;
    public static AlertDescription insufficient_security;
    public static AlertDescription internal_error;
    public static AlertDescription user_canceled;
    public static AlertDescription no_renegotiation;
    public static AlertDescription unsupported_extension;
    public static AlertDescription certificate_unobtainable;
    public static AlertDescription unrecognized_name;
    public static AlertDescription bad_certificate_status_response;
    public static AlertDescription bad_certificate_hash_value;
    public static AlertDescription unknown_psk_identity;
}
public enum Org.BouncyCastle.Crypto.Tls.AlertLevel : Enum {
    public byte value__;
    public static AlertLevel warning;
    public static AlertLevel fatal;
}
[ObsoleteAttribute("Perform certificate verification in TlsAuthentication implementation")]
public class Org.BouncyCastle.Crypto.Tls.AlwaysValidVerifyer : object {
    public sealed virtual bool IsValid(X509CertificateStructure[] certs);
}
public class Org.BouncyCastle.Crypto.Tls.ByteQueue : object {
    private static int DefaultCapacity;
    private Byte[] databuf;
    private int skipped;
    private int available;
    public int Available { get; }
    public ByteQueue(int capacity);
    public static int NextTwoPow(int i);
    public void Read(Byte[] buf, int offset, int len, int skip);
    public void AddData(Byte[] data, int offset, int len);
    public void RemoveData(int i);
    public void RemoveData(Byte[] buf, int off, int len, int skip);
    public Byte[] RemoveData(int len, int skip);
    public int get_Available();
}
public class Org.BouncyCastle.Crypto.Tls.Certificate : object {
    public static Certificate EmptyChain;
    internal X509CertificateStructure[] certs;
    public bool IsEmpty { get; }
    public Certificate(X509CertificateStructure[] certs);
    private static Certificate();
    internal static Certificate Parse(Stream inStr);
    internal void Encode(Stream outStr);
    public X509CertificateStructure[] GetCerts();
    public bool get_IsEmpty();
}
public class Org.BouncyCastle.Crypto.Tls.CertificateRequest : object {
    private ClientCertificateType[] certificateTypes;
    private IList certificateAuthorities;
    public ClientCertificateType[] CertificateTypes { get; }
    public IList CertificateAuthorities { get; }
    public CertificateRequest(ClientCertificateType[] certificateTypes, IList certificateAuthorities);
    public ClientCertificateType[] get_CertificateTypes();
    public IList get_CertificateAuthorities();
}
public enum Org.BouncyCastle.Crypto.Tls.CipherSuite : Enum {
    public int value__;
    public static CipherSuite TLS_NULL_WITH_NULL_NULL;
    public static CipherSuite TLS_RSA_WITH_NULL_MD5;
    public static CipherSuite TLS_RSA_WITH_NULL_SHA;
    public static CipherSuite TLS_RSA_EXPORT_WITH_RC4_40_MD5;
    public static CipherSuite TLS_RSA_WITH_RC4_128_MD5;
    public static CipherSuite TLS_RSA_WITH_RC4_128_SHA;
    public static CipherSuite TLS_RSA_EXPORT_WITH_RC2_CBC_40_MD5;
    public static CipherSuite TLS_RSA_WITH_IDEA_CBC_SHA;
    public static CipherSuite TLS_RSA_EXPORT_WITH_DES40_CBC_SHA;
    public static CipherSuite TLS_RSA_WITH_DES_CBC_SHA;
    public static CipherSuite TLS_RSA_WITH_3DES_EDE_CBC_SHA;
    public static CipherSuite TLS_DH_DSS_EXPORT_WITH_DES40_CBC_SHA;
    public static CipherSuite TLS_DH_DSS_WITH_DES_CBC_SHA;
    public static CipherSuite TLS_DH_DSS_WITH_3DES_EDE_CBC_SHA;
    public static CipherSuite TLS_DH_RSA_EXPORT_WITH_DES40_CBC_SHA;
    public static CipherSuite TLS_DH_RSA_WITH_DES_CBC_SHA;
    public static CipherSuite TLS_DH_RSA_WITH_3DES_EDE_CBC_SHA;
    public static CipherSuite TLS_DHE_DSS_EXPORT_WITH_DES40_CBC_SHA;
    public static CipherSuite TLS_DHE_DSS_WITH_DES_CBC_SHA;
    public static CipherSuite TLS_DHE_DSS_WITH_3DES_EDE_CBC_SHA;
    public static CipherSuite TLS_DHE_RSA_EXPORT_WITH_DES40_CBC_SHA;
    public static CipherSuite TLS_DHE_RSA_WITH_DES_CBC_SHA;
    public static CipherSuite TLS_DHE_RSA_WITH_3DES_EDE_CBC_SHA;
    public static CipherSuite TLS_DH_anon_EXPORT_WITH_RC4_40_MD5;
    public static CipherSuite TLS_DH_anon_WITH_RC4_128_MD5;
    public static CipherSuite TLS_DH_anon_EXPORT_WITH_DES40_CBC_SHA;
    public static CipherSuite TLS_DH_anon_WITH_DES_CBC_SHA;
    public static CipherSuite TLS_DH_anon_WITH_3DES_EDE_CBC_SHA;
    public static CipherSuite TLS_RSA_WITH_AES_128_CBC_SHA;
    public static CipherSuite TLS_DH_DSS_WITH_AES_128_CBC_SHA;
    public static CipherSuite TLS_DH_RSA_WITH_AES_128_CBC_SHA;
    public static CipherSuite TLS_DHE_DSS_WITH_AES_128_CBC_SHA;
    public static CipherSuite TLS_DHE_RSA_WITH_AES_128_CBC_SHA;
    public static CipherSuite TLS_DH_anon_WITH_AES_128_CBC_SHA;
    public static CipherSuite TLS_RSA_WITH_AES_256_CBC_SHA;
    public static CipherSuite TLS_DH_DSS_WITH_AES_256_CBC_SHA;
    public static CipherSuite TLS_DH_RSA_WITH_AES_256_CBC_SHA;
    public static CipherSuite TLS_DHE_DSS_WITH_AES_256_CBC_SHA;
    public static CipherSuite TLS_DHE_RSA_WITH_AES_256_CBC_SHA;
    public static CipherSuite TLS_DH_anon_WITH_AES_256_CBC_SHA;
    public static CipherSuite TLS_PSK_WITH_RC4_128_SHA;
    public static CipherSuite TLS_PSK_WITH_3DES_EDE_CBC_SHA;
    public static CipherSuite TLS_PSK_WITH_AES_128_CBC_SHA;
    public static CipherSuite TLS_PSK_WITH_AES_256_CBC_SHA;
    public static CipherSuite TLS_DHE_PSK_WITH_RC4_128_SHA;
    public static CipherSuite TLS_DHE_PSK_WITH_3DES_EDE_CBC_SHA;
    public static CipherSuite TLS_DHE_PSK_WITH_AES_128_CBC_SHA;
    public static CipherSuite TLS_DHE_PSK_WITH_AES_256_CBC_SHA;
    public static CipherSuite TLS_RSA_PSK_WITH_RC4_128_SHA;
    public static CipherSuite TLS_RSA_PSK_WITH_3DES_EDE_CBC_SHA;
    public static CipherSuite TLS_RSA_PSK_WITH_AES_128_CBC_SHA;
    public static CipherSuite TLS_RSA_PSK_WITH_AES_256_CBC_SHA;
    public static CipherSuite TLS_ECDH_ECDSA_WITH_NULL_SHA;
    public static CipherSuite TLS_ECDH_ECDSA_WITH_RC4_128_SHA;
    public static CipherSuite TLS_ECDH_ECDSA_WITH_3DES_EDE_CBC_SHA;
    public static CipherSuite TLS_ECDH_ECDSA_WITH_AES_128_CBC_SHA;
    public static CipherSuite TLS_ECDH_ECDSA_WITH_AES_256_CBC_SHA;
    public static CipherSuite TLS_ECDHE_ECDSA_WITH_NULL_SHA;
    public static CipherSuite TLS_ECDHE_ECDSA_WITH_RC4_128_SHA;
    public static CipherSuite TLS_ECDHE_ECDSA_WITH_3DES_EDE_CBC_SHA;
    public static CipherSuite TLS_ECDHE_ECDSA_WITH_AES_128_CBC_SHA;
    public static CipherSuite TLS_ECDHE_ECDSA_WITH_AES_256_CBC_SHA;
    public static CipherSuite TLS_ECDH_RSA_WITH_NULL_SHA;
    public static CipherSuite TLS_ECDH_RSA_WITH_RC4_128_SHA;
    public static CipherSuite TLS_ECDH_RSA_WITH_3DES_EDE_CBC_SHA;
    public static CipherSuite TLS_ECDH_RSA_WITH_AES_128_CBC_SHA;
    public static CipherSuite TLS_ECDH_RSA_WITH_AES_256_CBC_SHA;
    public static CipherSuite TLS_ECDHE_RSA_WITH_NULL_SHA;
    public static CipherSuite TLS_ECDHE_RSA_WITH_RC4_128_SHA;
    public static CipherSuite TLS_ECDHE_RSA_WITH_3DES_EDE_CBC_SHA;
    public static CipherSuite TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA;
    public static CipherSuite TLS_ECDHE_RSA_WITH_AES_256_CBC_SHA;
    public static CipherSuite TLS_ECDH_anon_WITH_NULL_SHA;
    public static CipherSuite TLS_ECDH_anon_WITH_RC4_128_SHA;
    public static CipherSuite TLS_ECDH_anon_WITH_3DES_EDE_CBC_SHA;
    public static CipherSuite TLS_ECDH_anon_WITH_AES_128_CBC_SHA;
    public static CipherSuite TLS_ECDH_anon_WITH_AES_256_CBC_SHA;
    public static CipherSuite TLS_SRP_SHA_WITH_3DES_EDE_CBC_SHA;
    public static CipherSuite TLS_SRP_SHA_RSA_WITH_3DES_EDE_CBC_SHA;
    public static CipherSuite TLS_SRP_SHA_DSS_WITH_3DES_EDE_CBC_SHA;
    public static CipherSuite TLS_SRP_SHA_WITH_AES_128_CBC_SHA;
    public static CipherSuite TLS_SRP_SHA_RSA_WITH_AES_128_CBC_SHA;
    public static CipherSuite TLS_SRP_SHA_DSS_WITH_AES_128_CBC_SHA;
    public static CipherSuite TLS_SRP_SHA_WITH_AES_256_CBC_SHA;
    public static CipherSuite TLS_SRP_SHA_RSA_WITH_AES_256_CBC_SHA;
    public static CipherSuite TLS_SRP_SHA_DSS_WITH_AES_256_CBC_SHA;
    public static CipherSuite TLS_ECDHE_ECDSA_WITH_AES_128_CBC_SHA256;
    public static CipherSuite TLS_ECDHE_ECDSA_WITH_AES_256_CBC_SHA384;
    public static CipherSuite TLS_ECDH_ECDSA_WITH_AES_128_CBC_SHA256;
    public static CipherSuite TLS_ECDH_ECDSA_WITH_AES_256_CBC_SHA384;
    public static CipherSuite TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA256;
    public static CipherSuite TLS_ECDHE_RSA_WITH_AES_256_CBC_SHA384;
    public static CipherSuite TLS_ECDH_RSA_WITH_AES_128_CBC_SHA256;
    public static CipherSuite TLS_ECDH_RSA_WITH_AES_256_CBC_SHA384;
    public static CipherSuite TLS_ECDHE_ECDSA_WITH_AES_128_GCM_SHA256;
    public static CipherSuite TLS_ECDHE_ECDSA_WITH_AES_256_GCM_SHA384;
    public static CipherSuite TLS_ECDH_ECDSA_WITH_AES_128_GCM_SHA256;
    public static CipherSuite TLS_ECDH_ECDSA_WITH_AES_256_GCM_SHA384;
    public static CipherSuite TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256;
    public static CipherSuite TLS_ECDHE_RSA_WITH_AES_256_GCM_SHA384;
    public static CipherSuite TLS_ECDH_RSA_WITH_AES_128_GCM_SHA256;
    public static CipherSuite TLS_ECDH_RSA_WITH_AES_256_GCM_SHA384;
    public static CipherSuite TLS_EMPTY_RENEGOTIATION_INFO_SCSV;
}
public enum Org.BouncyCastle.Crypto.Tls.ClientCertificateType : Enum {
    public byte value__;
    public static ClientCertificateType rsa_sign;
    public static ClientCertificateType dss_sign;
    public static ClientCertificateType rsa_fixed_dh;
    public static ClientCertificateType dss_fixed_dh;
    public static ClientCertificateType ecdsa_sign;
    public static ClientCertificateType rsa_fixed_ecdh;
    public static ClientCertificateType ecdsa_fixed_ecdh;
}
internal class Org.BouncyCastle.Crypto.Tls.CombinedHash : object {
    private MD5Digest md5;
    private Sha1Digest sha1;
    public string AlgorithmName { get; }
    internal CombinedHash(CombinedHash t);
    public sealed virtual string get_AlgorithmName();
    public sealed virtual int GetByteLength();
    public sealed virtual int GetDigestSize();
    public sealed virtual void Update(byte input);
    public sealed virtual void BlockUpdate(Byte[] input, int inOff, int len);
    public sealed virtual int DoFinal(Byte[] output, int outOff);
    public sealed virtual void Reset();
}
public enum Org.BouncyCastle.Crypto.Tls.CompressionMethod : Enum {
    public byte value__;
    public static CompressionMethod NULL;
    public static CompressionMethod DEFLATE;
}
public enum Org.BouncyCastle.Crypto.Tls.ContentType : Enum {
    public byte value__;
    public static ContentType change_cipher_spec;
    public static ContentType alert;
    public static ContentType handshake;
    public static ContentType application_data;
}
public class Org.BouncyCastle.Crypto.Tls.DefaultTlsAgreementCredentials : object {
    protected Certificate clientCert;
    protected AsymmetricKeyParameter clientPrivateKey;
    protected IBasicAgreement basicAgreement;
    protected bool truncateAgreement;
    public Certificate Certificate { get; }
    public DefaultTlsAgreementCredentials(Certificate clientCertificate, AsymmetricKeyParameter clientPrivateKey);
    public virtual Certificate get_Certificate();
    public virtual Byte[] GenerateAgreement(AsymmetricKeyParameter serverPublicKey);
}
public class Org.BouncyCastle.Crypto.Tls.DefaultTlsCipherFactory : object {
    public virtual TlsCipher CreateCipher(TlsClientContext context, EncryptionAlgorithm encryptionAlgorithm, DigestAlgorithm digestAlgorithm);
    protected virtual TlsCipher CreateRC4Cipher(TlsClientContext context, int cipherKeySize, DigestAlgorithm digestAlgorithm);
    protected virtual TlsCipher CreateAesCipher(TlsClientContext context, int cipherKeySize, DigestAlgorithm digestAlgorithm);
    protected virtual TlsCipher CreateDesEdeCipher(TlsClientContext context, int cipherKeySize, DigestAlgorithm digestAlgorithm);
    protected virtual IStreamCipher CreateRC4StreamCipher();
    protected virtual IBlockCipher CreateAesBlockCipher();
    protected virtual IBlockCipher CreateDesEdeBlockCipher();
    protected virtual IDigest CreateDigest(DigestAlgorithm digestAlgorithm);
}
public abstract class Org.BouncyCastle.Crypto.Tls.DefaultTlsClient : object {
    protected TlsCipherFactory cipherFactory;
    protected TlsClientContext context;
    protected CompressionMethod selectedCompressionMethod;
    protected CipherSuite selectedCipherSuite;
    public DefaultTlsClient(TlsCipherFactory cipherFactory);
    public virtual void Init(TlsClientContext context);
    public virtual CipherSuite[] GetCipherSuites();
    public virtual CompressionMethod[] GetCompressionMethods();
    public virtual IDictionary GetClientExtensions();
    public virtual void NotifySessionID(Byte[] sessionID);
    public virtual void NotifySelectedCipherSuite(CipherSuite selectedCipherSuite);
    public virtual void NotifySelectedCompressionMethod(CompressionMethod selectedCompressionMethod);
    public virtual void NotifySecureRenegotiation(bool secureRenegotiation);
    public virtual void ProcessServerExtensions(IDictionary serverExtensions);
    public virtual TlsKeyExchange GetKeyExchange();
    public abstract virtual TlsAuthentication GetAuthentication();
    public virtual TlsCompression GetCompression();
    public virtual TlsCipher GetCipher();
    protected virtual TlsKeyExchange CreateDHKeyExchange(KeyExchangeAlgorithm keyExchange);
    protected virtual TlsKeyExchange CreateDheKeyExchange(KeyExchangeAlgorithm keyExchange);
    protected virtual TlsKeyExchange CreateECDHKeyExchange(KeyExchangeAlgorithm keyExchange);
    protected virtual TlsKeyExchange CreateECDheKeyExchange(KeyExchangeAlgorithm keyExchange);
    protected virtual TlsKeyExchange CreateRsaKeyExchange();
}
public class Org.BouncyCastle.Crypto.Tls.DefaultTlsSignerCredentials : object {
    protected TlsClientContext context;
    protected Certificate clientCert;
    protected AsymmetricKeyParameter clientPrivateKey;
    protected TlsSigner clientSigner;
    public Certificate Certificate { get; }
    public DefaultTlsSignerCredentials(TlsClientContext context, Certificate clientCertificate, AsymmetricKeyParameter clientPrivateKey);
    public virtual Certificate get_Certificate();
    public virtual Byte[] GenerateCertificateSignature(Byte[] md5andsha1);
}
public enum Org.BouncyCastle.Crypto.Tls.DigestAlgorithm : Enum {
    public int value__;
    public static DigestAlgorithm NULL;
    public static DigestAlgorithm MD5;
    public static DigestAlgorithm SHA;
    public static DigestAlgorithm SHA256;
    public static DigestAlgorithm SHA384;
}
public enum Org.BouncyCastle.Crypto.Tls.ECCurveType : Enum {
    public byte value__;
    public static ECCurveType explicit_prime;
    public static ECCurveType explicit_char2;
    public static ECCurveType named_curve;
}
public enum Org.BouncyCastle.Crypto.Tls.ECPointFormat : Enum {
    public byte value__;
    public static ECPointFormat uncompressed;
    public static ECPointFormat ansiX962_compressed_prime;
    public static ECPointFormat ansiX962_compressed_char2;
}
public enum Org.BouncyCastle.Crypto.Tls.EncryptionAlgorithm : Enum {
    public int value__;
    public static EncryptionAlgorithm NULL;
    public static EncryptionAlgorithm RC4_40;
    public static EncryptionAlgorithm RC4_128;
    public static EncryptionAlgorithm RC2_CBC_40;
    public static EncryptionAlgorithm IDEA_CBC;
    public static EncryptionAlgorithm DES40_CBC;
    public static EncryptionAlgorithm DES_CBC;
    public static EncryptionAlgorithm cls_3DES_EDE_CBC;
    public static EncryptionAlgorithm AES_128_CBC;
    public static EncryptionAlgorithm AES_256_CBC;
    public static EncryptionAlgorithm AES_128_GCM;
    public static EncryptionAlgorithm AES_256_GCM;
}
public enum Org.BouncyCastle.Crypto.Tls.ExtensionType : Enum {
    public int value__;
    public static ExtensionType server_name;
    public static ExtensionType max_fragment_length;
    public static ExtensionType client_certificate_url;
    public static ExtensionType trusted_ca_keys;
    public static ExtensionType truncated_hmac;
    public static ExtensionType status_request;
    public static ExtensionType elliptic_curves;
    public static ExtensionType ec_point_formats;
    public static ExtensionType srp;
    public static ExtensionType renegotiation_info;
}
public enum Org.BouncyCastle.Crypto.Tls.HandshakeType : Enum {
    public byte value__;
    public static HandshakeType hello_request;
    public static HandshakeType client_hello;
    public static HandshakeType server_hello;
    public static HandshakeType certificate;
    public static HandshakeType server_key_exchange;
    public static HandshakeType certificate_request;
    public static HandshakeType server_hello_done;
    public static HandshakeType certificate_verify;
    public static HandshakeType client_key_exchange;
    public static HandshakeType finished;
}
[ObsoleteAttribute("Perform certificate verification in TlsAuthentication implementation")]
public interface Org.BouncyCastle.Crypto.Tls.ICertificateVerifyer {
    public abstract virtual bool IsValid(X509CertificateStructure[] certs);
}
public enum Org.BouncyCastle.Crypto.Tls.KeyExchangeAlgorithm : Enum {
    public int value__;
    public static KeyExchangeAlgorithm NULL;
    public static KeyExchangeAlgorithm RSA;
    public static KeyExchangeAlgorithm RSA_EXPORT;
    public static KeyExchangeAlgorithm DHE_DSS;
    public static KeyExchangeAlgorithm DHE_DSS_EXPORT;
    public static KeyExchangeAlgorithm DHE_RSA;
    public static KeyExchangeAlgorithm DHE_RSA_EXPORT;
    public static KeyExchangeAlgorithm DH_DSS;
    public static KeyExchangeAlgorithm DH_DSS_EXPORT;
    public static KeyExchangeAlgorithm DH_RSA;
    public static KeyExchangeAlgorithm DH_RSA_EXPORT;
    public static KeyExchangeAlgorithm DH_anon;
    public static KeyExchangeAlgorithm DH_anon_export;
    public static KeyExchangeAlgorithm PSK;
    public static KeyExchangeAlgorithm DHE_PSK;
    public static KeyExchangeAlgorithm RSA_PSK;
    public static KeyExchangeAlgorithm ECDH_ECDSA;
    public static KeyExchangeAlgorithm ECDHE_ECDSA;
    public static KeyExchangeAlgorithm ECDH_RSA;
    public static KeyExchangeAlgorithm ECDHE_RSA;
    public static KeyExchangeAlgorithm ECDH_anon;
    public static KeyExchangeAlgorithm SRP;
    public static KeyExchangeAlgorithm SRP_DSS;
    public static KeyExchangeAlgorithm SRP_RSA;
}
[ObsoleteAttribute]
public class Org.BouncyCastle.Crypto.Tls.LegacyTlsAuthentication : object {
    protected ICertificateVerifyer verifyer;
    public LegacyTlsAuthentication(ICertificateVerifyer verifyer);
    public virtual void NotifyServerCertificate(Certificate serverCertificate);
    public virtual TlsCredentials GetClientCredentials(CertificateRequest certificateRequest);
}
[ObsoleteAttribute]
public class Org.BouncyCastle.Crypto.Tls.LegacyTlsClient : DefaultTlsClient {
    [ObsoleteAttribute]
protected ICertificateVerifyer verifyer;
    [ObsoleteAttribute]
public LegacyTlsClient(ICertificateVerifyer verifyer);
    public virtual TlsAuthentication GetAuthentication();
}
public enum Org.BouncyCastle.Crypto.Tls.NamedCurve : Enum {
    public int value__;
    public static NamedCurve sect163k1;
    public static NamedCurve sect163r1;
    public static NamedCurve sect163r2;
    public static NamedCurve sect193r1;
    public static NamedCurve sect193r2;
    public static NamedCurve sect233k1;
    public static NamedCurve sect233r1;
    public static NamedCurve sect239k1;
    public static NamedCurve sect283k1;
    public static NamedCurve sect283r1;
    public static NamedCurve sect409k1;
    public static NamedCurve sect409r1;
    public static NamedCurve sect571k1;
    public static NamedCurve sect571r1;
    public static NamedCurve secp160k1;
    public static NamedCurve secp160r1;
    public static NamedCurve secp160r2;
    public static NamedCurve secp192k1;
    public static NamedCurve secp192r1;
    public static NamedCurve secp224k1;
    public static NamedCurve secp224r1;
    public static NamedCurve secp256k1;
    public static NamedCurve secp256r1;
    public static NamedCurve secp384r1;
    public static NamedCurve secp521r1;
    public static NamedCurve arbitrary_explicit_prime_curves;
    public static NamedCurve arbitrary_explicit_char2_curves;
}
internal class Org.BouncyCastle.Crypto.Tls.NamedCurveHelper : object {
    internal static ECDomainParameters GetECParameters(NamedCurve namedCurve);
}
public abstract class Org.BouncyCastle.Crypto.Tls.PskTlsClient : object {
    protected TlsCipherFactory cipherFactory;
    protected TlsPskIdentity pskIdentity;
    protected TlsClientContext context;
    protected CompressionMethod selectedCompressionMethod;
    protected CipherSuite selectedCipherSuite;
    public PskTlsClient(TlsPskIdentity pskIdentity);
    public PskTlsClient(TlsCipherFactory cipherFactory, TlsPskIdentity pskIdentity);
    public virtual void Init(TlsClientContext context);
    public virtual CipherSuite[] GetCipherSuites();
    public virtual IDictionary GetClientExtensions();
    public virtual CompressionMethod[] GetCompressionMethods();
    public virtual void NotifySessionID(Byte[] sessionID);
    public virtual void NotifySelectedCipherSuite(CipherSuite selectedCipherSuite);
    public virtual void NotifySelectedCompressionMethod(CompressionMethod selectedCompressionMethod);
    public virtual void NotifySecureRenegotiation(bool secureRenegotiation);
    public virtual void ProcessServerExtensions(IDictionary serverExtensions);
    public virtual TlsKeyExchange GetKeyExchange();
    public abstract virtual TlsAuthentication GetAuthentication();
    public virtual TlsCompression GetCompression();
    public virtual TlsCipher GetCipher();
    protected virtual TlsKeyExchange CreatePskKeyExchange(KeyExchangeAlgorithm keyExchange);
}
internal class Org.BouncyCastle.Crypto.Tls.RecordStream : object {
    private TlsProtocolHandler handler;
    private Stream inStr;
    private Stream outStr;
    private CombinedHash hash;
    private TlsCompression readCompression;
    private TlsCompression writeCompression;
    private TlsCipher readCipher;
    private TlsCipher writeCipher;
    private MemoryStream buffer;
    internal RecordStream(TlsProtocolHandler handler, Stream inStr, Stream outStr);
    internal void ClientCipherSpecDecided(TlsCompression tlsCompression, TlsCipher tlsCipher);
    internal void ServerClientSpecReceived();
    public void ReadData();
    internal Byte[] DecodeAndVerify(ContentType type, Stream inStr, int len);
    internal void WriteMessage(ContentType type, Byte[] message, int offset, int len);
    internal void UpdateHandshakeData(Byte[] message, int offset, int len);
    internal Byte[] GetCurrentHash();
    internal void Close();
    internal void Flush();
    private static Byte[] DoFinal(CombinedHash ch);
}
public class Org.BouncyCastle.Crypto.Tls.SecurityParameters : object {
    internal Byte[] clientRandom;
    internal Byte[] serverRandom;
    internal Byte[] masterSecret;
    public Byte[] ClientRandom { get; }
    public Byte[] ServerRandom { get; }
    public Byte[] MasterSecret { get; }
    public Byte[] get_ClientRandom();
    public Byte[] get_ServerRandom();
    public Byte[] get_MasterSecret();
}
public abstract class Org.BouncyCastle.Crypto.Tls.SrpTlsClient : object {
    protected TlsCipherFactory cipherFactory;
    protected Byte[] identity;
    protected Byte[] password;
    protected TlsClientContext context;
    protected CompressionMethod selectedCompressionMethod;
    protected CipherSuite selectedCipherSuite;
    public SrpTlsClient(Byte[] identity, Byte[] password);
    public SrpTlsClient(TlsCipherFactory cipherFactory, Byte[] identity, Byte[] password);
    public virtual void Init(TlsClientContext context);
    public virtual CipherSuite[] GetCipherSuites();
    public virtual IDictionary GetClientExtensions();
    public virtual CompressionMethod[] GetCompressionMethods();
    public virtual void NotifySessionID(Byte[] sessionID);
    public virtual void NotifySelectedCipherSuite(CipherSuite selectedCipherSuite);
    public virtual void NotifySelectedCompressionMethod(CompressionMethod selectedCompressionMethod);
    public virtual void NotifySecureRenegotiation(bool secureRenegotiation);
    public virtual void ProcessServerExtensions(IDictionary serverExtensions);
    public virtual TlsKeyExchange GetKeyExchange();
    public abstract virtual TlsAuthentication GetAuthentication();
    public virtual TlsCompression GetCompression();
    public virtual TlsCipher GetCipher();
    protected virtual TlsKeyExchange CreateSrpKeyExchange(KeyExchangeAlgorithm keyExchange);
}
public class Org.BouncyCastle.Crypto.Tls.Ssl3Mac : object {
    private static byte IPAD;
    private static byte OPAD;
    internal static Byte[] MD5_IPAD;
    internal static Byte[] MD5_OPAD;
    internal static Byte[] SHA1_IPAD;
    internal static Byte[] SHA1_OPAD;
    private IDigest digest;
    private Byte[] secret;
    private Byte[] ipad;
    private Byte[] opad;
    public string AlgorithmName { get; }
    public Ssl3Mac(IDigest digest);
    private static Ssl3Mac();
    public virtual string get_AlgorithmName();
    public virtual void Init(ICipherParameters parameters);
    public virtual int GetMacSize();
    public virtual void Update(byte input);
    public virtual void BlockUpdate(Byte[] input, int inOff, int len);
    public virtual int DoFinal(Byte[] output, int outOff);
    public virtual void Reset();
    private static Byte[] GenPad(byte b, int count);
}
public interface Org.BouncyCastle.Crypto.Tls.TlsAgreementCredentials {
    public abstract virtual Byte[] GenerateAgreement(AsymmetricKeyParameter serverPublicKey);
}
public interface Org.BouncyCastle.Crypto.Tls.TlsAuthentication {
    public abstract virtual void NotifyServerCertificate(Certificate serverCertificate);
    public abstract virtual TlsCredentials GetClientCredentials(CertificateRequest certificateRequest);
}
public class Org.BouncyCastle.Crypto.Tls.TlsBlockCipher : object {
    protected TlsClientContext context;
    protected Byte[] randomData;
    protected IBlockCipher encryptCipher;
    protected IBlockCipher decryptCipher;
    protected TlsMac wMac;
    protected TlsMac rMac;
    public TlsMac WriteMac { get; }
    public TlsMac ReadMac { get; }
    public TlsBlockCipher(TlsClientContext context, IBlockCipher encryptCipher, IBlockCipher decryptCipher, IDigest writeDigest, IDigest readDigest, int cipherKeySize);
    public virtual TlsMac get_WriteMac();
    public virtual TlsMac get_ReadMac();
    protected virtual TlsMac CreateTlsMac(IDigest digest, Byte[] buf, Int32& off);
    protected virtual KeyParameter CreateKeyParameter(Byte[] buf, Int32& off, int len);
    protected virtual ParametersWithIV CreateParametersWithIV(KeyParameter key, Byte[] buf, Int32& off, int len);
    public virtual Byte[] EncodePlaintext(ContentType type, Byte[] plaintext, int offset, int len);
    public virtual Byte[] DecodeCiphertext(ContentType type, Byte[] ciphertext, int offset, int len);
    protected virtual int CheckPaddingConstantTime(Byte[] buf, int off, int len, int blockSize, int macSize);
    protected virtual int ChooseExtraPadBlocks(SecureRandom r, int max);
    private int LowestBitSet(UInt32 x);
}
public interface Org.BouncyCastle.Crypto.Tls.TlsCipher {
    public abstract virtual Byte[] EncodePlaintext(ContentType type, Byte[] plaintext, int offset, int len);
    public abstract virtual Byte[] DecodeCiphertext(ContentType type, Byte[] ciphertext, int offset, int len);
}
public interface Org.BouncyCastle.Crypto.Tls.TlsCipherFactory {
    public abstract virtual TlsCipher CreateCipher(TlsClientContext context, EncryptionAlgorithm encryptionAlgorithm, DigestAlgorithm digestAlgorithm);
}
public interface Org.BouncyCastle.Crypto.Tls.TlsClient {
    public abstract virtual void Init(TlsClientContext context);
    public abstract virtual CipherSuite[] GetCipherSuites();
    public abstract virtual CompressionMethod[] GetCompressionMethods();
    public abstract virtual IDictionary GetClientExtensions();
    public abstract virtual void NotifySessionID(Byte[] sessionID);
    public abstract virtual void NotifySelectedCipherSuite(CipherSuite selectedCipherSuite);
    public abstract virtual void NotifySelectedCompressionMethod(CompressionMethod selectedCompressionMethod);
    public abstract virtual void NotifySecureRenegotiation(bool secureRenegotiation);
    public abstract virtual void ProcessServerExtensions(IDictionary serverExtensions);
    public abstract virtual TlsKeyExchange GetKeyExchange();
    public abstract virtual TlsAuthentication GetAuthentication();
    public abstract virtual TlsCompression GetCompression();
    public abstract virtual TlsCipher GetCipher();
}
public interface Org.BouncyCastle.Crypto.Tls.TlsClientContext {
    public SecureRandom SecureRandom { get; }
    public SecurityParameters SecurityParameters { get; }
    public object UserObject { get; public set; }
    public abstract virtual SecureRandom get_SecureRandom();
    public abstract virtual SecurityParameters get_SecurityParameters();
    public abstract virtual object get_UserObject();
    public abstract virtual void set_UserObject(object value);
}
internal class Org.BouncyCastle.Crypto.Tls.TlsClientContextImpl : object {
    private SecureRandom secureRandom;
    private SecurityParameters securityParameters;
    private object userObject;
    public SecureRandom SecureRandom { get; }
    public SecurityParameters SecurityParameters { get; }
    public object UserObject { get; public set; }
    internal TlsClientContextImpl(SecureRandom secureRandom, SecurityParameters securityParameters);
    public virtual SecureRandom get_SecureRandom();
    public virtual SecurityParameters get_SecurityParameters();
    public virtual object get_UserObject();
    public virtual void set_UserObject(object value);
}
public interface Org.BouncyCastle.Crypto.Tls.TlsCompression {
    public abstract virtual Stream Compress(Stream output);
    public abstract virtual Stream Decompress(Stream output);
}
public interface Org.BouncyCastle.Crypto.Tls.TlsCredentials {
    public Certificate Certificate { get; }
    public abstract virtual Certificate get_Certificate();
}
public class Org.BouncyCastle.Crypto.Tls.TlsDeflateCompression : object {
    public static int LEVEL_NONE;
    public static int LEVEL_FASTEST;
    public static int LEVEL_SMALLEST;
    public static int LEVEL_DEFAULT;
    protected ZStream zIn;
    protected ZStream zOut;
    public TlsDeflateCompression(int level);
    public virtual Stream Compress(Stream output);
    public virtual Stream Decompress(Stream output);
}
internal class Org.BouncyCastle.Crypto.Tls.TlsDheKeyExchange : TlsDHKeyExchange {
    internal TlsDheKeyExchange(TlsClientContext context, KeyExchangeAlgorithm keyExchange);
    public virtual void SkipServerKeyExchange();
    public virtual void ProcessServerKeyExchange(Stream input);
    protected virtual ISigner InitSigner(TlsSigner tlsSigner, SecurityParameters securityParameters);
}
internal class Org.BouncyCastle.Crypto.Tls.TlsDHKeyExchange : object {
    protected TlsClientContext context;
    protected KeyExchangeAlgorithm keyExchange;
    protected TlsSigner tlsSigner;
    protected AsymmetricKeyParameter serverPublicKey;
    protected DHPublicKeyParameters dhAgreeServerPublicKey;
    protected TlsAgreementCredentials agreementCredentials;
    protected DHPrivateKeyParameters dhAgreeClientPrivateKey;
    internal TlsDHKeyExchange(TlsClientContext context, KeyExchangeAlgorithm keyExchange);
    public virtual void SkipServerCertificate();
    public virtual void ProcessServerCertificate(Certificate serverCertificate);
    public virtual void SkipServerKeyExchange();
    public virtual void ProcessServerKeyExchange(Stream input);
    public virtual void ValidateCertificateRequest(CertificateRequest certificateRequest);
    public virtual void SkipClientCredentials();
    public virtual void ProcessClientCredentials(TlsCredentials clientCredentials);
    public virtual void GenerateClientKeyExchange(Stream output);
    public virtual Byte[] GeneratePremasterSecret();
    protected virtual bool AreCompatibleParameters(DHParameters a, DHParameters b);
    protected virtual Byte[] CalculateDHBasicAgreement(DHPublicKeyParameters publicKey, DHPrivateKeyParameters privateKey);
    protected virtual AsymmetricCipherKeyPair GenerateDHKeyPair(DHParameters dhParams);
    protected virtual void GenerateEphemeralClientKeyExchange(DHParameters dhParams, Stream output);
    protected virtual DHPublicKeyParameters ValidateDHPublicKey(DHPublicKeyParameters key);
}
public abstract class Org.BouncyCastle.Crypto.Tls.TlsDHUtilities : object {
    public static Byte[] CalculateDHBasicAgreement(DHPublicKeyParameters publicKey, DHPrivateKeyParameters privateKey);
    public static AsymmetricCipherKeyPair GenerateDHKeyPair(SecureRandom random, DHParameters dhParams);
    public static DHPrivateKeyParameters GenerateEphemeralClientKeyExchange(SecureRandom random, DHParameters dhParams, Stream output);
    public static DHPublicKeyParameters ValidateDHPublicKey(DHPublicKeyParameters key);
}
internal abstract class Org.BouncyCastle.Crypto.Tls.TlsDsaSigner : object {
    public virtual Byte[] GenerateRawSignature(SecureRandom random, AsymmetricKeyParameter privateKey, Byte[] md5andsha1);
    public sealed virtual bool VerifyRawSignature(Byte[] sigBytes, AsymmetricKeyParameter publicKey, Byte[] md5andsha1);
    public virtual ISigner CreateSigner(SecureRandom random, AsymmetricKeyParameter privateKey);
    public virtual ISigner CreateVerifyer(AsymmetricKeyParameter publicKey);
    public abstract virtual bool IsValidPublicKey(AsymmetricKeyParameter publicKey);
    protected virtual ISigner MakeSigner(IDigest d, bool forSigning, ICipherParameters cp);
    protected abstract virtual IDsa CreateDsaImpl();
}
internal class Org.BouncyCastle.Crypto.Tls.TlsDssSigner : TlsDsaSigner {
    public virtual bool IsValidPublicKey(AsymmetricKeyParameter publicKey);
    protected virtual IDsa CreateDsaImpl();
}
internal class Org.BouncyCastle.Crypto.Tls.TlsECDheKeyExchange : TlsECDHKeyExchange {
    internal TlsECDheKeyExchange(TlsClientContext context, KeyExchangeAlgorithm keyExchange);
    public virtual void SkipServerKeyExchange();
    public virtual void ProcessServerKeyExchange(Stream input);
    public virtual void ValidateCertificateRequest(CertificateRequest certificateRequest);
    public virtual void ProcessClientCredentials(TlsCredentials clientCredentials);
    protected virtual ISigner InitSigner(TlsSigner tlsSigner, SecurityParameters securityParameters);
}
internal class Org.BouncyCastle.Crypto.Tls.TlsECDHKeyExchange : object {
    protected TlsClientContext context;
    protected KeyExchangeAlgorithm keyExchange;
    protected TlsSigner tlsSigner;
    protected AsymmetricKeyParameter serverPublicKey;
    protected ECPublicKeyParameters ecAgreeServerPublicKey;
    protected TlsAgreementCredentials agreementCredentials;
    protected ECPrivateKeyParameters ecAgreeClientPrivateKey;
    internal TlsECDHKeyExchange(TlsClientContext context, KeyExchangeAlgorithm keyExchange);
    public virtual void SkipServerCertificate();
    public virtual void ProcessServerCertificate(Certificate serverCertificate);
    public virtual void SkipServerKeyExchange();
    public virtual void ProcessServerKeyExchange(Stream input);
    public virtual void ValidateCertificateRequest(CertificateRequest certificateRequest);
    public virtual void SkipClientCredentials();
    public virtual void ProcessClientCredentials(TlsCredentials clientCredentials);
    public virtual void GenerateClientKeyExchange(Stream output);
    public virtual Byte[] GeneratePremasterSecret();
    protected virtual bool AreOnSameCurve(ECDomainParameters a, ECDomainParameters b);
    protected virtual Byte[] ExternalizeKey(ECPublicKeyParameters keyParameters);
    protected virtual AsymmetricCipherKeyPair GenerateECKeyPair(ECDomainParameters ecParams);
    protected virtual void GenerateEphemeralClientKeyExchange(ECDomainParameters ecParams, Stream output);
    protected virtual Byte[] CalculateECDHBasicAgreement(ECPublicKeyParameters publicKey, ECPrivateKeyParameters privateKey);
    protected virtual ECPublicKeyParameters ValidateECPublicKey(ECPublicKeyParameters key);
}
internal class Org.BouncyCastle.Crypto.Tls.TlsECDsaSigner : TlsDsaSigner {
    public virtual bool IsValidPublicKey(AsymmetricKeyParameter publicKey);
    protected virtual IDsa CreateDsaImpl();
}
public class Org.BouncyCastle.Crypto.Tls.TlsException : Exception {
    public TlsException(string message);
    public TlsException(string message, Exception exception);
}
public class Org.BouncyCastle.Crypto.Tls.TlsFatalAlert : IOException {
    private AlertDescription alertDescription;
    public AlertDescription AlertDescription { get; }
    public TlsFatalAlert(AlertDescription alertDescription);
    public AlertDescription get_AlertDescription();
}
public interface Org.BouncyCastle.Crypto.Tls.TlsKeyExchange {
    public abstract virtual void SkipServerCertificate();
    public abstract virtual void ProcessServerCertificate(Certificate serverCertificate);
    public abstract virtual void SkipServerKeyExchange();
    public abstract virtual void ProcessServerKeyExchange(Stream input);
    public abstract virtual void ValidateCertificateRequest(CertificateRequest certificateRequest);
    public abstract virtual void SkipClientCredentials();
    public abstract virtual void ProcessClientCredentials(TlsCredentials clientCredentials);
    public abstract virtual void GenerateClientKeyExchange(Stream output);
    public abstract virtual Byte[] GeneratePremasterSecret();
}
public class Org.BouncyCastle.Crypto.Tls.TlsMac : object {
    protected long seqNo;
    protected Byte[] secret;
    protected HMac mac;
    public long SequenceNumber { get; }
    public int Size { get; }
    public TlsMac(IDigest digest, Byte[] key_block, int offset, int len);
    public virtual Byte[] GetMacSecret();
    public virtual long get_SequenceNumber();
    public virtual void IncSequenceNumber();
    public virtual int get_Size();
    public virtual Byte[] CalculateMac(ContentType type, Byte[] message, int offset, int len);
    public virtual Byte[] CalculateMacConstantTime(ContentType type, Byte[] message, int offset, int len, int fullLength, Byte[] dummyData);
}
public class Org.BouncyCastle.Crypto.Tls.TlsNullCipher : object {
    public virtual Byte[] EncodePlaintext(ContentType type, Byte[] plaintext, int offset, int len);
    public virtual Byte[] DecodeCiphertext(ContentType type, Byte[] ciphertext, int offset, int len);
    protected virtual Byte[] CopyData(Byte[] text, int offset, int len);
}
public class Org.BouncyCastle.Crypto.Tls.TlsNullCompression : object {
    public virtual Stream Compress(Stream output);
    public virtual Stream Decompress(Stream output);
}
public class Org.BouncyCastle.Crypto.Tls.TlsProtocolHandler : object {
    private static short CS_CLIENT_HELLO_SEND;
    private static short CS_SERVER_HELLO_RECEIVED;
    private static short CS_SERVER_CERTIFICATE_RECEIVED;
    private static short CS_SERVER_KEY_EXCHANGE_RECEIVED;
    private static short CS_CERTIFICATE_REQUEST_RECEIVED;
    private static short CS_SERVER_HELLO_DONE_RECEIVED;
    private static short CS_CLIENT_KEY_EXCHANGE_SEND;
    private static short CS_CERTIFICATE_VERIFY_SEND;
    private static short CS_CLIENT_CHANGE_CIPHER_SPEC_SEND;
    private static short CS_CLIENT_FINISHED_SEND;
    private static short CS_SERVER_CHANGE_CIPHER_SPEC_RECEIVED;
    private static short CS_DONE;
    private static Byte[] emptybuf;
    private static string TLS_ERROR_MESSAGE;
    private ByteQueue applicationDataQueue;
    private ByteQueue alertQueue;
    private ByteQueue handshakeQueue;
    private RecordStream rs;
    private SecureRandom random;
    private TlsStream tlsStream;
    private bool closed;
    private bool failedWithError;
    private bool appDataReady;
    private IDictionary clientExtensions;
    private SecurityParameters securityParameters;
    private TlsClientContextImpl tlsClientContext;
    private TlsClient tlsClient;
    private CipherSuite[] offeredCipherSuites;
    private CompressionMethod[] offeredCompressionMethods;
    private TlsKeyExchange keyExchange;
    private TlsAuthentication authentication;
    private CertificateRequest certificateRequest;
    private short connection_state;
    [ObsoleteAttribute("Use 'Stream' property instead")]
public Stream OutputStream { get; }
    [ObsoleteAttribute("Use 'Stream' property instead")]
public Stream InputStream { get; }
    public Stream Stream { get; }
    internal bool IsClosed { get; }
    public TlsProtocolHandler(Stream s);
    public TlsProtocolHandler(Stream s, SecureRandom sr);
    public TlsProtocolHandler(Stream inStr, Stream outStr);
    public TlsProtocolHandler(Stream inStr, Stream outStr, SecureRandom sr);
    private static TlsProtocolHandler();
    private static SecureRandom CreateSecureRandom();
    internal void ProcessData(ContentType protocol, Byte[] buf, int offset, int len);
    private void ProcessHandshake();
    private void ProcessHandshakeMessage(HandshakeType type, Byte[] buf);
    private void ProcessApplicationData();
    private void ProcessAlert();
    private void ProcessChangeCipherSpec(Byte[] buf, int off, int len);
    private void SendClientCertificate(Certificate clientCert);
    private void SendClientKeyExchange();
    private void SendCertificateVerify(Byte[] data);
    [ObsoleteAttribute("Use version taking TlsClient")]
public virtual void Connect(ICertificateVerifyer verifyer);
    public virtual void Connect(TlsClient tlsClient);
    internal int ReadApplicationData(Byte[] buf, int offset, int len);
    private void SafeReadData();
    private void SafeWriteMessage(ContentType type, Byte[] buf, int offset, int len);
    internal void WriteData(Byte[] buf, int offset, int len);
    public virtual Stream get_OutputStream();
    public virtual Stream get_InputStream();
    public virtual Stream get_Stream();
    private void FailWithError(AlertLevel alertLevel, AlertDescription alertDescription);
    internal void SendAlert(AlertLevel alertLevel, AlertDescription alertDescription);
    public virtual void Close();
    protected virtual void HandleClose(bool user_canceled);
    internal void AssertEmpty(MemoryStream inStr);
    internal void Flush();
    internal bool get_IsClosed();
    private static bool ArrayContains(CipherSuite[] a, CipherSuite n);
    private static bool ArrayContains(CompressionMethod[] a, CompressionMethod n);
    private static Byte[] CreateRenegotiationInfo(Byte[] renegotiated_connection);
    private static void WriteExtension(Stream output, ExtensionType extType, Byte[] extValue);
}
public interface Org.BouncyCastle.Crypto.Tls.TlsPskIdentity {
    public abstract virtual void SkipIdentityHint();
    public abstract virtual void NotifyIdentityHint(Byte[] psk_identity_hint);
    public abstract virtual Byte[] GetPskIdentity();
    public abstract virtual Byte[] GetPsk();
}
internal class Org.BouncyCastle.Crypto.Tls.TlsPskKeyExchange : object {
    protected TlsClientContext context;
    protected KeyExchangeAlgorithm keyExchange;
    protected TlsPskIdentity pskIdentity;
    protected Byte[] psk_identity_hint;
    protected DHPublicKeyParameters dhAgreeServerPublicKey;
    protected DHPrivateKeyParameters dhAgreeClientPrivateKey;
    protected AsymmetricKeyParameter serverPublicKey;
    protected RsaKeyParameters rsaServerPublicKey;
    protected Byte[] premasterSecret;
    internal TlsPskKeyExchange(TlsClientContext context, KeyExchangeAlgorithm keyExchange, TlsPskIdentity pskIdentity);
    public virtual void SkipServerCertificate();
    public virtual void ProcessServerCertificate(Certificate serverCertificate);
    public virtual void SkipServerKeyExchange();
    public virtual void ProcessServerKeyExchange(Stream input);
    public virtual void ValidateCertificateRequest(CertificateRequest certificateRequest);
    public virtual void SkipClientCredentials();
    public virtual void ProcessClientCredentials(TlsCredentials clientCredentials);
    public virtual void GenerateClientKeyExchange(Stream output);
    public virtual Byte[] GeneratePremasterSecret();
    protected virtual Byte[] GenerateOtherSecret(int pskLength);
    protected virtual RsaKeyParameters ValidateRsaPublicKey(RsaKeyParameters key);
}
internal class Org.BouncyCastle.Crypto.Tls.TlsRsaKeyExchange : object {
    protected TlsClientContext context;
    protected AsymmetricKeyParameter serverPublicKey;
    protected RsaKeyParameters rsaServerPublicKey;
    protected Byte[] premasterSecret;
    internal TlsRsaKeyExchange(TlsClientContext context);
    public virtual void SkipServerCertificate();
    public virtual void ProcessServerCertificate(Certificate serverCertificate);
    public virtual void SkipServerKeyExchange();
    public virtual void ProcessServerKeyExchange(Stream input);
    public virtual void ValidateCertificateRequest(CertificateRequest certificateRequest);
    public virtual void SkipClientCredentials();
    public virtual void ProcessClientCredentials(TlsCredentials clientCredentials);
    public virtual void GenerateClientKeyExchange(Stream output);
    public virtual Byte[] GeneratePremasterSecret();
    protected virtual RsaKeyParameters ValidateRsaPublicKey(RsaKeyParameters key);
}
internal class Org.BouncyCastle.Crypto.Tls.TlsRsaSigner : object {
    public virtual Byte[] GenerateRawSignature(SecureRandom random, AsymmetricKeyParameter privateKey, Byte[] md5AndSha1);
    public virtual bool VerifyRawSignature(Byte[] sigBytes, AsymmetricKeyParameter publicKey, Byte[] md5AndSha1);
    public virtual ISigner CreateSigner(SecureRandom random, AsymmetricKeyParameter privateKey);
    public virtual ISigner CreateVerifyer(AsymmetricKeyParameter publicKey);
    public virtual bool IsValidPublicKey(AsymmetricKeyParameter publicKey);
    protected virtual ISigner MakeSigner(IDigest d, bool forSigning, ICipherParameters cp);
    protected virtual IAsymmetricBlockCipher CreateRsaImpl();
}
public abstract class Org.BouncyCastle.Crypto.Tls.TlsRsaUtilities : object {
    public static Byte[] GenerateEncryptedPreMasterSecret(SecureRandom random, RsaKeyParameters rsaServerPublicKey, Stream output);
}
public interface Org.BouncyCastle.Crypto.Tls.TlsSigner {
    public abstract virtual Byte[] GenerateRawSignature(SecureRandom random, AsymmetricKeyParameter privateKey, Byte[] md5andsha1);
    public abstract virtual bool VerifyRawSignature(Byte[] sigBytes, AsymmetricKeyParameter publicKey, Byte[] md5andsha1);
    public abstract virtual ISigner CreateSigner(SecureRandom random, AsymmetricKeyParameter privateKey);
    public abstract virtual ISigner CreateVerifyer(AsymmetricKeyParameter publicKey);
    public abstract virtual bool IsValidPublicKey(AsymmetricKeyParameter publicKey);
}
public interface Org.BouncyCastle.Crypto.Tls.TlsSignerCredentials {
    public abstract virtual Byte[] GenerateCertificateSignature(Byte[] md5andsha1);
}
internal class Org.BouncyCastle.Crypto.Tls.TlsSrpKeyExchange : object {
    protected TlsClientContext context;
    protected KeyExchangeAlgorithm keyExchange;
    protected TlsSigner tlsSigner;
    protected Byte[] identity;
    protected Byte[] password;
    protected AsymmetricKeyParameter serverPublicKey;
    protected Byte[] s;
    protected BigInteger B;
    protected Srp6Client srpClient;
    internal TlsSrpKeyExchange(TlsClientContext context, KeyExchangeAlgorithm keyExchange, Byte[] identity, Byte[] password);
    public virtual void SkipServerCertificate();
    public virtual void ProcessServerCertificate(Certificate serverCertificate);
    public virtual void SkipServerKeyExchange();
    public virtual void ProcessServerKeyExchange(Stream input);
    public virtual void ValidateCertificateRequest(CertificateRequest certificateRequest);
    public virtual void SkipClientCredentials();
    public virtual void ProcessClientCredentials(TlsCredentials clientCredentials);
    public virtual void GenerateClientKeyExchange(Stream output);
    public virtual Byte[] GeneratePremasterSecret();
    protected virtual ISigner InitSigner(TlsSigner tlsSigner, SecurityParameters securityParameters);
}
internal class Org.BouncyCastle.Crypto.Tls.TlsStream : Stream {
    private TlsProtocolHandler handler;
    public bool CanRead { get; }
    public bool CanSeek { get; }
    public bool CanWrite { get; }
    public long Length { get; }
    public long Position { get; public set; }
    internal TlsStream(TlsProtocolHandler handler);
    public virtual bool get_CanRead();
    public virtual bool get_CanSeek();
    public virtual bool get_CanWrite();
    public virtual void Close();
    public virtual void Flush();
    public virtual long get_Length();
    public virtual long get_Position();
    public virtual void set_Position(long value);
    public virtual int Read(Byte[] buf, int off, int len);
    public virtual int ReadByte();
    public virtual long Seek(long offset, SeekOrigin origin);
    public virtual void SetLength(long value);
    public virtual void Write(Byte[] buf, int off, int len);
    public virtual void WriteByte(byte b);
}
public class Org.BouncyCastle.Crypto.Tls.TlsStreamCipher : object {
    protected TlsClientContext context;
    protected IStreamCipher encryptCipher;
    protected IStreamCipher decryptCipher;
    protected TlsMac writeMac;
    protected TlsMac readMac;
    public TlsStreamCipher(TlsClientContext context, IStreamCipher encryptCipher, IStreamCipher decryptCipher, IDigest writeDigest, IDigest readDigest, int cipherKeySize);
    public sealed virtual Byte[] EncodePlaintext(ContentType type, Byte[] plaintext, int offset, int len);
    public sealed virtual Byte[] DecodeCiphertext(ContentType type, Byte[] ciphertext, int offset, int len);
    protected virtual TlsMac CreateTlsMac(IDigest digest, Byte[] buf, Int32& off);
    protected virtual KeyParameter CreateKeyParameter(Byte[] buf, Int32& off, int len);
    protected virtual Byte[] CopyData(Byte[] text, int offset, int len);
}
public class Org.BouncyCastle.Crypto.Tls.TlsUtilities : object {
    internal static void WriteUint8(byte i, Stream os);
    internal static void WriteUint8(byte i, Byte[] buf, int offset);
    internal static void WriteUint16(int i, Stream os);
    internal static void WriteUint16(int i, Byte[] buf, int offset);
    internal static void WriteUint24(int i, Stream os);
    internal static void WriteUint24(int i, Byte[] buf, int offset);
    internal static void WriteUint64(long i, Stream os);
    internal static void WriteUint64(long i, Byte[] buf, int offset);
    internal static void WriteOpaque8(Byte[] buf, Stream os);
    internal static void WriteOpaque16(Byte[] buf, Stream os);
    internal static void WriteOpaque24(Byte[] buf, Stream os);
    internal static void WriteUint8Array(Byte[] uints, Stream os);
    internal static void WriteUint16Array(Int32[] uints, Stream os);
    internal static byte ReadUint8(Stream inStr);
    internal static int ReadUint16(Stream inStr);
    internal static int ReadUint24(Stream inStr);
    internal static void ReadFully(Byte[] buf, Stream inStr);
    internal static Byte[] ReadOpaque8(Stream inStr);
    internal static Byte[] ReadOpaque16(Stream inStr);
    internal static void CheckVersion(Byte[] readVersion);
    internal static void CheckVersion(Stream inStr);
    internal static void WriteGmtUnixTime(Byte[] buf, int offset);
    internal static void WriteVersion(Stream os);
    internal static void WriteVersion(Byte[] buf, int offset);
    private static void hmac_hash(IDigest digest, Byte[] secret, Byte[] seed, Byte[] output);
    internal static Byte[] PRF(Byte[] secret, string asciiLabel, Byte[] seed, int size);
    internal static Byte[] PRF_1_2(IDigest digest, Byte[] secret, string asciiLabel, Byte[] seed, int size);
    internal static Byte[] Concat(Byte[] a, Byte[] b);
    internal static void ValidateKeyUsage(X509CertificateStructure c, int keyUsageBits);
}
internal class Org.BouncyCastle.Crypto.Utilities.Pack : object {
    internal static void UInt16_To_BE(ushort n, Byte[] bs);
    internal static void UInt16_To_BE(ushort n, Byte[] bs, int off);
    internal static ushort BE_To_UInt16(Byte[] bs);
    internal static ushort BE_To_UInt16(Byte[] bs, int off);
    internal static Byte[] UInt32_To_BE(UInt32 n);
    internal static void UInt32_To_BE(UInt32 n, Byte[] bs);
    internal static void UInt32_To_BE(UInt32 n, Byte[] bs, int off);
    internal static Byte[] UInt32_To_BE(UInt32[] ns);
    internal static void UInt32_To_BE(UInt32[] ns, Byte[] bs, int off);
    internal static UInt32 BE_To_UInt32(Byte[] bs);
    internal static UInt32 BE_To_UInt32(Byte[] bs, int off);
    internal static void BE_To_UInt32(Byte[] bs, int off, UInt32[] ns);
    internal static Byte[] UInt64_To_BE(ulong n);
    internal static void UInt64_To_BE(ulong n, Byte[] bs);
    internal static void UInt64_To_BE(ulong n, Byte[] bs, int off);
    internal static ulong BE_To_UInt64(Byte[] bs);
    internal static ulong BE_To_UInt64(Byte[] bs, int off);
    internal static void UInt16_To_LE(ushort n, Byte[] bs);
    internal static void UInt16_To_LE(ushort n, Byte[] bs, int off);
    internal static ushort LE_To_UInt16(Byte[] bs);
    internal static ushort LE_To_UInt16(Byte[] bs, int off);
    internal static Byte[] UInt32_To_LE(UInt32 n);
    internal static void UInt32_To_LE(UInt32 n, Byte[] bs);
    internal static void UInt32_To_LE(UInt32 n, Byte[] bs, int off);
    internal static Byte[] UInt32_To_LE(UInt32[] ns);
    internal static void UInt32_To_LE(UInt32[] ns, Byte[] bs, int off);
    internal static UInt32 LE_To_UInt32(Byte[] bs);
    internal static UInt32 LE_To_UInt32(Byte[] bs, int off);
    internal static void LE_To_UInt32(Byte[] bs, int off, UInt32[] ns);
    internal static Byte[] UInt64_To_LE(ulong n);
    internal static void UInt64_To_LE(ulong n, Byte[] bs);
    internal static void UInt64_To_LE(ulong n, Byte[] bs, int off);
    internal static ulong LE_To_UInt64(Byte[] bs);
    internal static ulong LE_To_UInt64(Byte[] bs, int off);
}
public class Org.BouncyCastle.Math.BigInteger : object {
    private static long IMASK;
    private static ulong UIMASK;
    private static int chunk2;
    private static int chunk8;
    private static int chunk10;
    private static int chunk16;
    private static int BitsPerByte;
    private static int BitsPerInt;
    private static int BytesPerInt;
    internal static Int32[][] primeLists;
    internal static Int32[] primeProducts;
    private static Int32[] ZeroMagnitude;
    private static Byte[] ZeroEncoding;
    private static BigInteger[] SMALL_CONSTANTS;
    public static BigInteger Zero;
    public static BigInteger One;
    public static BigInteger Two;
    public static BigInteger Three;
    public static BigInteger Ten;
    private static Byte[] BitLengthTable;
    private static BigInteger radix2;
    private static BigInteger radix2E;
    private static BigInteger radix8;
    private static BigInteger radix8E;
    private static BigInteger radix10;
    private static BigInteger radix10E;
    private static BigInteger radix16;
    private static BigInteger radix16E;
    private static Random RandomSource;
    private static Int32[] ExpWindowThresholds;
    private Int32[] magnitude;
    private int sign;
    private int nBits;
    private int nBitLength;
    private int mQuote;
    public int BitCount { get; }
    public int BitLength { get; }
    public int IntValue { get; }
    public long LongValue { get; }
    public int SignValue { get; }
    private static BigInteger();
    private BigInteger(int signum, Int32[] mag, bool checkMag);
    public BigInteger(string value);
    public BigInteger(string str, int radix);
    public BigInteger(Byte[] bytes);
    public BigInteger(Byte[] bytes, int offset, int length);
    public BigInteger(int sign, Byte[] bytes);
    public BigInteger(int sign, Byte[] bytes, int offset, int length);
    public BigInteger(int sizeInBits, Random random);
    public BigInteger(int bitLength, int certainty, Random random);
    private static int GetByteLength(int nBits);
    private static Int32[] MakeMagnitude(Byte[] bytes, int offset, int length);
    public BigInteger Abs();
    private static Int32[] AddMagnitudes(Int32[] a, Int32[] b);
    public BigInteger Add(BigInteger value);
    private BigInteger AddToMagnitude(Int32[] magToAdd);
    public BigInteger And(BigInteger value);
    public BigInteger AndNot(BigInteger val);
    public int get_BitCount();
    public static int BitCnt(int i);
    private static int CalcBitLength(int sign, int indx, Int32[] mag);
    public int get_BitLength();
    private static int BitLen(int w);
    private bool QuickPow2Check();
    public int CompareTo(object obj);
    private static int CompareTo(int xIndx, Int32[] x, int yIndx, Int32[] y);
    private static int CompareNoLeadingZeroes(int xIndx, Int32[] x, int yIndx, Int32[] y);
    public int CompareTo(BigInteger value);
    private Int32[] Divide(Int32[] x, Int32[] y);
    public BigInteger Divide(BigInteger val);
    public BigInteger[] DivideAndRemainder(BigInteger val);
    public virtual bool Equals(object obj);
    private bool IsEqualMagnitude(BigInteger x);
    public BigInteger Gcd(BigInteger value);
    public virtual int GetHashCode();
    private BigInteger Inc();
    public int get_IntValue();
    public bool IsProbablePrime(int certainty);
    private bool CheckProbablePrime(int certainty, Random random);
    public bool RabinMillerTest(int certainty, Random random);
    public long get_LongValue();
    public BigInteger Max(BigInteger value);
    public BigInteger Min(BigInteger value);
    public BigInteger Mod(BigInteger m);
    public BigInteger ModInverse(BigInteger m);
    private BigInteger ModInversePow2(BigInteger m);
    private static int ModInverse32(int d);
    private static long ModInverse64(long d);
    private static BigInteger ExtEuclid(BigInteger a, BigInteger b, BigInteger& u1Out);
    private static void ZeroOut(Int32[] x);
    public BigInteger ModPow(BigInteger e, BigInteger m);
    private static BigInteger ModPowBarrett(BigInteger b, BigInteger e, BigInteger m);
    private static BigInteger ReduceBarrett(BigInteger x, BigInteger m, BigInteger mr, BigInteger yu);
    private static BigInteger ModPowMonty(BigInteger b, BigInteger e, BigInteger m, bool convert);
    private static Int32[] GetWindowList(Int32[] mag, int extraBits);
    private static int CreateWindowEntry(int mult, int zeroes);
    private static Int32[] Square(Int32[] w, Int32[] x);
    private static Int32[] Multiply(Int32[] x, Int32[] y, Int32[] z);
    private int GetMQuote();
    private static void MontgomeryReduce(Int32[] x, Int32[] m, UInt32 mDash);
    private static void MultiplyMonty(Int32[] a, Int32[] x, Int32[] y, Int32[] m, UInt32 mDash, bool smallMontyModulus);
    private static void SquareMonty(Int32[] a, Int32[] x, Int32[] m, UInt32 mDash, bool smallMontyModulus);
    private static UInt32 MultiplyMontyNIsOne(UInt32 x, UInt32 y, UInt32 m, UInt32 mDash);
    public BigInteger Multiply(BigInteger val);
    public BigInteger Square();
    public BigInteger Negate();
    public BigInteger NextProbablePrime();
    public BigInteger Not();
    public BigInteger Pow(int exp);
    public static BigInteger ProbablePrime(int bitLength, Random random);
    private int Remainder(int m);
    private static Int32[] Remainder(Int32[] x, Int32[] y);
    public BigInteger Remainder(BigInteger n);
    private Int32[] LastNBits(int n);
    private BigInteger DivideWords(int w);
    private BigInteger RemainderWords(int w);
    private static Int32[] ShiftLeft(Int32[] mag, int n);
    private static int ShiftLeftOneInPlace(Int32[] x, int carry);
    public BigInteger ShiftLeft(int n);
    private static void ShiftRightInPlace(int start, Int32[] mag, int n);
    private static void ShiftRightOneInPlace(int start, Int32[] mag);
    public BigInteger ShiftRight(int n);
    public int get_SignValue();
    private static Int32[] Subtract(int xStart, Int32[] x, int yStart, Int32[] y);
    public BigInteger Subtract(BigInteger n);
    private static Int32[] doSubBigLil(Int32[] bigMag, Int32[] lilMag);
    public Byte[] ToByteArray();
    public Byte[] ToByteArrayUnsigned();
    private Byte[] ToByteArray(bool unsigned);
    public virtual string ToString();
    public string ToString(int radix);
    private static void AppendZeroExtendedString(StringBuilder sb, string s, int minLength);
    private static BigInteger CreateUValueOf(ulong value);
    private static BigInteger CreateValueOf(long value);
    public static BigInteger ValueOf(long value);
    public int GetLowestSetBit();
    private int GetLowestSetBitMaskFirst(int firstWordMask);
    public bool TestBit(int n);
    public BigInteger Or(BigInteger value);
    public BigInteger Xor(BigInteger value);
    public BigInteger SetBit(int n);
    public BigInteger ClearBit(int n);
    public BigInteger FlipBit(int n);
    private BigInteger FlipExistingBit(int n);
}
internal class Org.BouncyCastle.Math.EC.Abc.SimpleBigDecimal : object {
    private BigInteger bigInt;
    private int scale;
    public int IntValue { get; }
    public long LongValue { get; }
    public int Scale { get; }
    public SimpleBigDecimal(BigInteger bigInt, int scale);
    private SimpleBigDecimal(SimpleBigDecimal limBigDec);
    public static SimpleBigDecimal GetInstance(BigInteger val, int scale);
    private void CheckScale(SimpleBigDecimal b);
    public SimpleBigDecimal AdjustScale(int newScale);
    public SimpleBigDecimal Add(SimpleBigDecimal b);
    public SimpleBigDecimal Add(BigInteger b);
    public SimpleBigDecimal Negate();
    public SimpleBigDecimal Subtract(SimpleBigDecimal b);
    public SimpleBigDecimal Subtract(BigInteger b);
    public SimpleBigDecimal Multiply(SimpleBigDecimal b);
    public SimpleBigDecimal Multiply(BigInteger b);
    public SimpleBigDecimal Divide(SimpleBigDecimal b);
    public SimpleBigDecimal Divide(BigInteger b);
    public SimpleBigDecimal ShiftLeft(int n);
    public int CompareTo(SimpleBigDecimal val);
    public int CompareTo(BigInteger val);
    public BigInteger Floor();
    public BigInteger Round();
    public int get_IntValue();
    public long get_LongValue();
    public int get_Scale();
    public virtual string ToString();
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
}
internal class Org.BouncyCastle.Math.EC.Abc.Tnaf : object {
    public static sbyte Width;
    public static sbyte Pow2Width;
    private static BigInteger MinusOne;
    private static BigInteger MinusTwo;
    private static BigInteger MinusThree;
    private static BigInteger Four;
    public static ZTauElement[] Alpha0;
    public static SByte[][] Alpha0Tnaf;
    public static ZTauElement[] Alpha1;
    public static SByte[][] Alpha1Tnaf;
    private static Tnaf();
    public static BigInteger Norm(sbyte mu, ZTauElement lambda);
    public static SimpleBigDecimal Norm(sbyte mu, SimpleBigDecimal u, SimpleBigDecimal v);
    public static ZTauElement Round(SimpleBigDecimal lambda0, SimpleBigDecimal lambda1, sbyte mu);
    public static SimpleBigDecimal ApproximateDivisionByN(BigInteger k, BigInteger s, BigInteger vm, sbyte a, int m, int c);
    public static SByte[] TauAdicNaf(sbyte mu, ZTauElement lambda);
    public static F2mPoint Tau(F2mPoint p);
    public static sbyte GetMu(F2mCurve curve);
    public static BigInteger[] GetLucas(sbyte mu, int k, bool doV);
    public static BigInteger GetTw(sbyte mu, int w);
    public static BigInteger[] GetSi(F2mCurve curve);
    public static ZTauElement PartModReduction(BigInteger k, int m, sbyte a, BigInteger[] s, sbyte mu, sbyte c);
    public static F2mPoint MultiplyRTnaf(F2mPoint p, BigInteger k);
    public static F2mPoint MultiplyTnaf(F2mPoint p, ZTauElement lambda);
    public static F2mPoint MultiplyFromTnaf(F2mPoint p, SByte[] u);
    public static SByte[] TauAdicWNaf(sbyte mu, ZTauElement lambda, sbyte width, BigInteger pow2w, BigInteger tw, ZTauElement[] alpha);
    public static F2mPoint[] GetPreComp(F2mPoint p, sbyte a);
}
internal class Org.BouncyCastle.Math.EC.Abc.ZTauElement : object {
    public BigInteger u;
    public BigInteger v;
    public ZTauElement(BigInteger u, BigInteger v);
}
public class Org.BouncyCastle.Math.EC.ECAlgorithms : object {
    public static ECPoint SumOfTwoMultiplies(ECPoint P, BigInteger a, ECPoint Q, BigInteger b);
    public static ECPoint ShamirsTrick(ECPoint P, BigInteger k, ECPoint Q, BigInteger l);
    private static ECPoint ImplShamirsTrick(ECPoint P, BigInteger k, ECPoint Q, BigInteger l);
}
public abstract class Org.BouncyCastle.Math.EC.ECCurve : object {
    internal ECFieldElement a;
    internal ECFieldElement b;
    public int FieldSize { get; }
    public ECPoint Infinity { get; }
    public ECFieldElement A { get; }
    public ECFieldElement B { get; }
    public abstract virtual int get_FieldSize();
    public abstract virtual ECFieldElement FromBigInteger(BigInteger x);
    public abstract virtual ECPoint CreatePoint(BigInteger x, BigInteger y, bool withCompression);
    public abstract virtual ECPoint get_Infinity();
    public ECFieldElement get_A();
    public ECFieldElement get_B();
    public virtual bool Equals(object obj);
    protected bool Equals(ECCurve other);
    public virtual int GetHashCode();
    protected abstract virtual ECPoint DecompressPoint(int yTilde, BigInteger X1);
    public virtual ECPoint DecodePoint(Byte[] encoded);
}
public abstract class Org.BouncyCastle.Math.EC.ECFieldElement : object {
    public string FieldName { get; }
    public int FieldSize { get; }
    public abstract virtual BigInteger ToBigInteger();
    public abstract virtual string get_FieldName();
    public abstract virtual int get_FieldSize();
    public abstract virtual ECFieldElement Add(ECFieldElement b);
    public abstract virtual ECFieldElement Subtract(ECFieldElement b);
    public abstract virtual ECFieldElement Multiply(ECFieldElement b);
    public abstract virtual ECFieldElement Divide(ECFieldElement b);
    public abstract virtual ECFieldElement Negate();
    public abstract virtual ECFieldElement Square();
    public abstract virtual ECFieldElement Invert();
    public abstract virtual ECFieldElement Sqrt();
    public virtual bool Equals(object obj);
    protected bool Equals(ECFieldElement other);
    public virtual int GetHashCode();
    public virtual string ToString();
}
public abstract class Org.BouncyCastle.Math.EC.ECPoint : object {
    internal ECCurve curve;
    internal ECFieldElement x;
    internal ECFieldElement y;
    internal bool withCompression;
    internal ECMultiplier multiplier;
    internal PreCompInfo preCompInfo;
    public ECCurve Curve { get; }
    public ECFieldElement X { get; }
    public ECFieldElement Y { get; }
    public bool IsInfinity { get; }
    public bool IsCompressed { get; }
    protected internal ECPoint(ECCurve curve, ECFieldElement x, ECFieldElement y, bool withCompression);
    public ECCurve get_Curve();
    public ECFieldElement get_X();
    public ECFieldElement get_Y();
    public bool get_IsInfinity();
    public bool get_IsCompressed();
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    internal void SetPreCompInfo(PreCompInfo preCompInfo);
    public virtual Byte[] GetEncoded();
    public abstract virtual Byte[] GetEncoded(bool compressed);
    public abstract virtual ECPoint Add(ECPoint b);
    public abstract virtual ECPoint Subtract(ECPoint b);
    public abstract virtual ECPoint Negate();
    public abstract virtual ECPoint Twice();
    public abstract virtual ECPoint Multiply(BigInteger b);
    internal virtual void AssertECMultiplier();
}
public abstract class Org.BouncyCastle.Math.EC.ECPointBase : ECPoint {
    protected internal bool YTilde { get; }
    protected internal ECPointBase(ECCurve curve, ECFieldElement x, ECFieldElement y, bool withCompression);
    protected internal abstract virtual bool get_YTilde();
    public virtual Byte[] GetEncoded(bool compressed);
    public virtual ECPoint Multiply(BigInteger k);
}
public class Org.BouncyCastle.Math.EC.F2mCurve : ECCurve {
    private int m;
    private int k1;
    private int k2;
    private int k3;
    private BigInteger n;
    private BigInteger h;
    private F2mPoint infinity;
    private sbyte mu;
    private BigInteger[] si;
    public ECPoint Infinity { get; }
    public int FieldSize { get; }
    public bool IsKoblitz { get; }
    public int M { get; }
    public int K1 { get; }
    public int K2 { get; }
    public int K3 { get; }
    public BigInteger N { get; }
    public BigInteger H { get; }
    public F2mCurve(int m, int k, BigInteger a, BigInteger b);
    public F2mCurve(int m, int k, BigInteger a, BigInteger b, BigInteger n, BigInteger h);
    public F2mCurve(int m, int k1, int k2, int k3, BigInteger a, BigInteger b);
    public F2mCurve(int m, int k1, int k2, int k3, BigInteger a, BigInteger b, BigInteger n, BigInteger h);
    public virtual ECPoint get_Infinity();
    public virtual int get_FieldSize();
    public virtual ECFieldElement FromBigInteger(BigInteger x);
    public bool get_IsKoblitz();
    internal sbyte GetMu();
    internal BigInteger[] GetSi();
    public virtual ECPoint CreatePoint(BigInteger X1, BigInteger Y1, bool withCompression);
    protected virtual ECPoint DecompressPoint(int yTilde, BigInteger X1);
    private ECFieldElement solveQuadradicEquation(ECFieldElement beta);
    public virtual bool Equals(object obj);
    protected bool Equals(F2mCurve other);
    public virtual int GetHashCode();
    public int get_M();
    public bool IsTrinomial();
    public int get_K1();
    public int get_K2();
    public int get_K3();
    public BigInteger get_N();
    public BigInteger get_H();
}
public class Org.BouncyCastle.Math.EC.F2mFieldElement : ECFieldElement {
    public static int Gnb;
    public static int Tpb;
    public static int Ppb;
    private int representation;
    private int m;
    private int k1;
    private int k2;
    private int k3;
    private IntArray x;
    private int t;
    public string FieldName { get; }
    public int FieldSize { get; }
    public int Representation { get; }
    public int M { get; }
    public int K1 { get; }
    public int K2 { get; }
    public int K3 { get; }
    public F2mFieldElement(int m, int k1, int k2, int k3, BigInteger x);
    public F2mFieldElement(int m, int k, BigInteger x);
    private F2mFieldElement(int m, int k1, int k2, int k3, IntArray x);
    public virtual BigInteger ToBigInteger();
    public virtual string get_FieldName();
    public virtual int get_FieldSize();
    public static void CheckFieldElements(ECFieldElement a, ECFieldElement b);
    public virtual ECFieldElement Add(ECFieldElement b);
    public virtual ECFieldElement Subtract(ECFieldElement b);
    public virtual ECFieldElement Multiply(ECFieldElement b);
    public virtual ECFieldElement Divide(ECFieldElement b);
    public virtual ECFieldElement Negate();
    public virtual ECFieldElement Square();
    public virtual ECFieldElement Invert();
    public virtual ECFieldElement Sqrt();
    public int get_Representation();
    public int get_M();
    public int get_K1();
    public int get_K2();
    public int get_K3();
    public virtual bool Equals(object obj);
    protected bool Equals(F2mFieldElement other);
    public virtual int GetHashCode();
}
public class Org.BouncyCastle.Math.EC.F2mPoint : ECPointBase {
    protected internal bool YTilde { get; }
    public F2mPoint(ECCurve curve, ECFieldElement x, ECFieldElement y);
    public F2mPoint(ECCurve curve, ECFieldElement x, ECFieldElement y, bool withCompression);
    [ObsoleteAttribute("Use ECCurve.Infinity property")]
public F2mPoint(ECCurve curve);
    protected internal virtual bool get_YTilde();
    private static void CheckPoints(ECPoint a, ECPoint b);
    public virtual ECPoint Add(ECPoint b);
    internal F2mPoint AddSimple(F2mPoint b);
    public virtual ECPoint Subtract(ECPoint b);
    internal F2mPoint SubtractSimple(F2mPoint b);
    public virtual ECPoint Twice();
    public virtual ECPoint Negate();
    internal virtual void AssertECMultiplier();
}
public class Org.BouncyCastle.Math.EC.FpCurve : ECCurve {
    private BigInteger q;
    private FpPoint infinity;
    public BigInteger Q { get; }
    public ECPoint Infinity { get; }
    public int FieldSize { get; }
    public FpCurve(BigInteger q, BigInteger a, BigInteger b);
    public BigInteger get_Q();
    public virtual ECPoint get_Infinity();
    public virtual int get_FieldSize();
    public virtual ECFieldElement FromBigInteger(BigInteger x);
    public virtual ECPoint CreatePoint(BigInteger X1, BigInteger Y1, bool withCompression);
    protected virtual ECPoint DecompressPoint(int yTilde, BigInteger X1);
    public virtual bool Equals(object obj);
    protected bool Equals(FpCurve other);
    public virtual int GetHashCode();
}
public class Org.BouncyCastle.Math.EC.FpFieldElement : ECFieldElement {
    private BigInteger q;
    private BigInteger x;
    public string FieldName { get; }
    public int FieldSize { get; }
    public BigInteger Q { get; }
    public FpFieldElement(BigInteger q, BigInteger x);
    public virtual BigInteger ToBigInteger();
    public virtual string get_FieldName();
    public virtual int get_FieldSize();
    public BigInteger get_Q();
    public virtual ECFieldElement Add(ECFieldElement b);
    public virtual ECFieldElement Subtract(ECFieldElement b);
    public virtual ECFieldElement Multiply(ECFieldElement b);
    public virtual ECFieldElement Divide(ECFieldElement b);
    public virtual ECFieldElement Negate();
    public virtual ECFieldElement Square();
    public virtual ECFieldElement Invert();
    public virtual ECFieldElement Sqrt();
    private static BigInteger[] fastLucasSequence(BigInteger p, BigInteger P, BigInteger Q, BigInteger k);
    public virtual bool Equals(object obj);
    protected bool Equals(FpFieldElement other);
    public virtual int GetHashCode();
}
public class Org.BouncyCastle.Math.EC.FpPoint : ECPointBase {
    protected internal bool YTilde { get; }
    public FpPoint(ECCurve curve, ECFieldElement x, ECFieldElement y);
    public FpPoint(ECCurve curve, ECFieldElement x, ECFieldElement y, bool withCompression);
    protected internal virtual bool get_YTilde();
    public virtual ECPoint Add(ECPoint b);
    public virtual ECPoint Twice();
    public virtual ECPoint Subtract(ECPoint b);
    public virtual ECPoint Negate();
    internal virtual void AssertECMultiplier();
}
internal class Org.BouncyCastle.Math.EC.IntArray : object {
    private Int32[] m_ints;
    public int BitLength { get; }
    public int Length { get; }
    public IntArray(int intLen);
    private IntArray(Int32[] ints);
    public IntArray(BigInteger bigInt);
    public IntArray(BigInteger bigInt, int minIntLen);
    public int GetUsedLength();
    public int get_BitLength();
    private Int32[] resizedInts(int newLen);
    public BigInteger ToBigInteger();
    public void ShiftLeft();
    public IntArray ShiftLeft(int n);
    public void AddShifted(IntArray other, int shift);
    public int get_Length();
    public bool TestBit(int n);
    public void FlipBit(int n);
    public void SetBit(int n);
    public IntArray Multiply(IntArray other, int m);
    public void Reduce(int m, Int32[] redPol);
    public IntArray Square(int m);
    public virtual bool Equals(object o);
    public virtual int GetHashCode();
    internal IntArray Copy();
    public virtual string ToString();
}
internal interface Org.BouncyCastle.Math.EC.Multiplier.ECMultiplier {
    public abstract virtual ECPoint Multiply(ECPoint p, BigInteger k, PreCompInfo preCompInfo);
}
internal class Org.BouncyCastle.Math.EC.Multiplier.FpNafMultiplier : object {
    public sealed virtual ECPoint Multiply(ECPoint p, BigInteger k, PreCompInfo preCompInfo);
}
internal interface Org.BouncyCastle.Math.EC.Multiplier.PreCompInfo {
}
internal class Org.BouncyCastle.Math.EC.Multiplier.ReferenceMultiplier : object {
    public sealed virtual ECPoint Multiply(ECPoint p, BigInteger k, PreCompInfo preCompInfo);
}
internal class Org.BouncyCastle.Math.EC.Multiplier.WNafMultiplier : object {
    public SByte[] WindowNaf(sbyte width, BigInteger k);
    public sealed virtual ECPoint Multiply(ECPoint p, BigInteger k, PreCompInfo preCompInfo);
}
internal class Org.BouncyCastle.Math.EC.Multiplier.WNafPreCompInfo : object {
    private ECPoint[] preComp;
    private ECPoint twiceP;
    internal ECPoint[] GetPreComp();
    internal void SetPreComp(ECPoint[] preComp);
    internal ECPoint GetTwiceP();
    internal void SetTwiceP(ECPoint twiceThis);
}
internal class Org.BouncyCastle.Math.EC.Multiplier.WTauNafMultiplier : object {
    public sealed virtual ECPoint Multiply(ECPoint point, BigInteger k, PreCompInfo preCompInfo);
    private F2mPoint MultiplyWTnaf(F2mPoint p, ZTauElement lambda, PreCompInfo preCompInfo, sbyte a, sbyte mu);
    private static F2mPoint MultiplyFromWTnaf(F2mPoint p, SByte[] u, PreCompInfo preCompInfo);
}
internal class Org.BouncyCastle.Math.EC.Multiplier.WTauNafPreCompInfo : object {
    private F2mPoint[] preComp;
    internal WTauNafPreCompInfo(F2mPoint[] preComp);
    internal F2mPoint[] GetPreComp();
}
public class Org.BouncyCastle.Ocsp.BasicOcspResp : X509ExtensionBase {
    private BasicOcspResponse resp;
    private ResponseData data;
    public int Version { get; }
    public RespID ResponderId { get; }
    public DateTime ProducedAt { get; }
    public SingleResp[] Responses { get; }
    public X509Extensions ResponseExtensions { get; }
    public string SignatureAlgName { get; }
    public string SignatureAlgOid { get; }
    public BasicOcspResp(BasicOcspResponse resp);
    public Byte[] GetTbsResponseData();
    public int get_Version();
    public RespID get_ResponderId();
    public DateTime get_ProducedAt();
    public SingleResp[] get_Responses();
    public X509Extensions get_ResponseExtensions();
    protected virtual X509Extensions GetX509Extensions();
    public string get_SignatureAlgName();
    public string get_SignatureAlgOid();
    [ObsoleteAttribute("RespData class is no longer required as all functionality is available on this class")]
public RespData GetResponseData();
    public Byte[] GetSignature();
    private IList GetCertList();
    public X509Certificate[] GetCerts();
    public IX509Store GetCertificates(string type);
    public bool Verify(AsymmetricKeyParameter publicKey);
    public Byte[] GetEncoded();
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
}
public class Org.BouncyCastle.Ocsp.BasicOcspRespGenerator : object {
    private IList list;
    private X509Extensions responseExtensions;
    private RespID responderID;
    public IEnumerable SignatureAlgNames { get; }
    public BasicOcspRespGenerator(RespID responderID);
    public BasicOcspRespGenerator(AsymmetricKeyParameter publicKey);
    public void AddResponse(CertificateID certID, CertificateStatus certStatus);
    public void AddResponse(CertificateID certID, CertificateStatus certStatus, X509Extensions singleExtensions);
    public void AddResponse(CertificateID certID, CertificateStatus certStatus, DateTime nextUpdate, X509Extensions singleExtensions);
    public void AddResponse(CertificateID certID, CertificateStatus certStatus, DateTime thisUpdate, DateTime nextUpdate, X509Extensions singleExtensions);
    public void SetResponseExtensions(X509Extensions responseExtensions);
    private BasicOcspResp GenerateResponse(string signatureName, AsymmetricKeyParameter privateKey, X509Certificate[] chain, DateTime producedAt, SecureRandom random);
    public BasicOcspResp Generate(string signingAlgorithm, AsymmetricKeyParameter privateKey, X509Certificate[] chain, DateTime thisUpdate);
    public BasicOcspResp Generate(string signingAlgorithm, AsymmetricKeyParameter privateKey, X509Certificate[] chain, DateTime producedAt, SecureRandom random);
    public IEnumerable get_SignatureAlgNames();
}
public class Org.BouncyCastle.Ocsp.CertificateID : object {
    public static string HashSha1;
    private CertID id;
    public string HashAlgOid { get; }
    public BigInteger SerialNumber { get; }
    public CertificateID(CertID id);
    public CertificateID(string hashAlgorithm, X509Certificate issuerCert, BigInteger serialNumber);
    public string get_HashAlgOid();
    public Byte[] GetIssuerNameHash();
    public Byte[] GetIssuerKeyHash();
    public BigInteger get_SerialNumber();
    public bool MatchesIssuer(X509Certificate issuerCert);
    public CertID ToAsn1Object();
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public static CertificateID DeriveCertificateID(CertificateID original, BigInteger newSerialNumber);
    private static CertID CreateCertID(AlgorithmIdentifier hashAlg, X509Certificate issuerCert, DerInteger serialNumber);
}
public abstract class Org.BouncyCastle.Ocsp.CertificateStatus : object {
    public static CertificateStatus Good;
    private static CertificateStatus();
}
[ObsoleteAttribute("Use version with correct spelling 'OcspRespStatus'")]
public abstract class Org.BouncyCastle.Ocsp.OcscpRespStatus : OcspRespStatus {
}
public class Org.BouncyCastle.Ocsp.OcspException : Exception {
    public OcspException(string message);
    public OcspException(string message, Exception e);
}
public class Org.BouncyCastle.Ocsp.OcspReq : X509ExtensionBase {
    private OcspRequest req;
    public int Version { get; }
    public GeneralName RequestorName { get; }
    public X509Extensions RequestExtensions { get; }
    public string SignatureAlgOid { get; }
    public bool IsSigned { get; }
    public OcspReq(OcspRequest req);
    public OcspReq(Byte[] req);
    public OcspReq(Stream inStr);
    private OcspReq(Asn1InputStream aIn);
    public Byte[] GetTbsRequest();
    public int get_Version();
    public GeneralName get_RequestorName();
    public Req[] GetRequestList();
    public X509Extensions get_RequestExtensions();
    protected virtual X509Extensions GetX509Extensions();
    public string get_SignatureAlgOid();
    public Byte[] GetSignature();
    private IList GetCertList();
    public X509Certificate[] GetCerts();
    public IX509Store GetCertificates(string type);
    public bool get_IsSigned();
    public bool Verify(AsymmetricKeyParameter publicKey);
    public Byte[] GetEncoded();
}
public class Org.BouncyCastle.Ocsp.OcspReqGenerator : object {
    private IList list;
    private GeneralName requestorName;
    private X509Extensions requestExtensions;
    public IEnumerable SignatureAlgNames { get; }
    public void AddRequest(CertificateID certId);
    public void AddRequest(CertificateID certId, X509Extensions singleRequestExtensions);
    public void SetRequestorName(X509Name requestorName);
    public void SetRequestorName(GeneralName requestorName);
    public void SetRequestExtensions(X509Extensions requestExtensions);
    private OcspReq GenerateRequest(DerObjectIdentifier signingAlgorithm, AsymmetricKeyParameter privateKey, X509Certificate[] chain, SecureRandom random);
    public OcspReq Generate();
    public OcspReq Generate(string signingAlgorithm, AsymmetricKeyParameter privateKey, X509Certificate[] chain);
    public OcspReq Generate(string signingAlgorithm, AsymmetricKeyParameter privateKey, X509Certificate[] chain, SecureRandom random);
    public IEnumerable get_SignatureAlgNames();
}
public class Org.BouncyCastle.Ocsp.OcspResp : object {
    private OcspResponse resp;
    public int Status { get; }
    public OcspResp(OcspResponse resp);
    public OcspResp(Byte[] resp);
    public OcspResp(Stream inStr);
    private OcspResp(Asn1InputStream aIn);
    public int get_Status();
    public object GetResponseObject();
    public Byte[] GetEncoded();
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
}
public class Org.BouncyCastle.Ocsp.OCSPRespGenerator : object {
    public static int Successful;
    public static int MalformedRequest;
    public static int InternalError;
    public static int TryLater;
    public static int SigRequired;
    public static int Unauthorized;
    public OcspResp Generate(int status, object response);
}
public abstract class Org.BouncyCastle.Ocsp.OcspRespStatus : object {
    public static int Successful;
    public static int MalformedRequest;
    public static int InternalError;
    public static int TryLater;
    public static int SigRequired;
    public static int Unauthorized;
}
internal class Org.BouncyCastle.Ocsp.OcspUtilities : object {
    private static IDictionary algorithms;
    private static IDictionary oids;
    private static ISet noParams;
    internal static IEnumerable AlgNames { get; }
    private static OcspUtilities();
    internal static DerObjectIdentifier GetAlgorithmOid(string algorithmName);
    internal static string GetAlgorithmName(DerObjectIdentifier oid);
    internal static AlgorithmIdentifier GetSigAlgID(DerObjectIdentifier sigOid);
    internal static IEnumerable get_AlgNames();
}
public class Org.BouncyCastle.Ocsp.Req : X509ExtensionBase {
    private Request req;
    public X509Extensions SingleRequestExtensions { get; }
    public Req(Request req);
    public CertificateID GetCertID();
    public X509Extensions get_SingleRequestExtensions();
    protected virtual X509Extensions GetX509Extensions();
}
public class Org.BouncyCastle.Ocsp.RespData : X509ExtensionBase {
    internal ResponseData data;
    public int Version { get; }
    public DateTime ProducedAt { get; }
    public X509Extensions ResponseExtensions { get; }
    public RespData(ResponseData data);
    public int get_Version();
    public RespID GetResponderId();
    public DateTime get_ProducedAt();
    public SingleResp[] GetResponses();
    public X509Extensions get_ResponseExtensions();
    protected virtual X509Extensions GetX509Extensions();
}
public class Org.BouncyCastle.Ocsp.RespID : object {
    internal ResponderID id;
    public RespID(ResponderID id);
    public RespID(X509Name name);
    public RespID(AsymmetricKeyParameter publicKey);
    public ResponderID ToAsn1Object();
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
}
public class Org.BouncyCastle.Ocsp.RevokedStatus : CertificateStatus {
    internal RevokedInfo info;
    public DateTime RevocationTime { get; }
    public bool HasRevocationReason { get; }
    public int RevocationReason { get; }
    public RevokedStatus(RevokedInfo info);
    public RevokedStatus(DateTime revocationDate, int reason);
    public DateTime get_RevocationTime();
    public bool get_HasRevocationReason();
    public int get_RevocationReason();
}
public class Org.BouncyCastle.Ocsp.SingleResp : X509ExtensionBase {
    internal SingleResponse resp;
    public DateTime ThisUpdate { get; }
    public DateTimeObject NextUpdate { get; }
    public X509Extensions SingleExtensions { get; }
    public SingleResp(SingleResponse resp);
    public CertificateID GetCertID();
    public object GetCertStatus();
    public DateTime get_ThisUpdate();
    public DateTimeObject get_NextUpdate();
    public X509Extensions get_SingleExtensions();
    protected virtual X509Extensions GetX509Extensions();
}
public class Org.BouncyCastle.Ocsp.UnknownStatus : CertificateStatus {
}
public interface Org.BouncyCastle.OpenSsl.IPasswordFinder {
    public abstract virtual Char[] GetPassword();
}
public class Org.BouncyCastle.OpenSsl.MiscPemGenerator : object {
    private object obj;
    private string algorithm;
    private Char[] password;
    private SecureRandom random;
    public MiscPemGenerator(object obj);
    public MiscPemGenerator(object obj, string algorithm, Char[] password, SecureRandom random);
    private static PemObject CreatePemObject(object obj);
    private static PemObject CreatePemObject(object obj, string algorithm, Char[] password, SecureRandom random);
    private static Byte[] EncodePrivateKey(AsymmetricKeyParameter akp, String& keyType);
    public sealed virtual PemObject Generate();
}
public class Org.BouncyCastle.OpenSsl.PemException : IOException {
    public PemException(string message);
    public PemException(string message, Exception exception);
}
public class Org.BouncyCastle.OpenSsl.PemReader : PemReader {
    private IPasswordFinder pFinder;
    private static PemReader();
    public PemReader(TextReader reader);
    public PemReader(TextReader reader, IPasswordFinder pFinder);
    public object ReadObject();
    private AsymmetricKeyParameter ReadRsaPublicKey(PemObject pemObject);
    private AsymmetricKeyParameter ReadPublicKey(PemObject pemObject);
    private X509Certificate ReadCertificate(PemObject pemObject);
    private X509Crl ReadCrl(PemObject pemObject);
    private Pkcs10CertificationRequest ReadCertificateRequest(PemObject pemObject);
    private IX509AttributeCertificate ReadAttributeCertificate(PemObject pemObject);
    private ContentInfo ReadPkcs7(PemObject pemObject);
    private object ReadPrivateKey(PemObject pemObject);
    private static X9ECParameters GetCurveParameters(string name);
}
internal class Org.BouncyCastle.OpenSsl.PemUtilities : object {
    private static PemUtilities();
    private static void ParseDekAlgName(string dekAlgName, PemBaseAlg& baseAlg, PemMode& mode);
    internal static Byte[] Crypt(bool encrypt, Byte[] bytes, Char[] password, string dekAlgName, Byte[] iv);
    private static ICipherParameters GetCipherParameters(Char[] password, PemBaseAlg baseAlg, Byte[] salt);
}
public class Org.BouncyCastle.OpenSsl.PemWriter : PemWriter {
    public PemWriter(TextWriter writer);
    public void WriteObject(object obj);
    public void WriteObject(object obj, string algorithm, Char[] password, SecureRandom random);
}
public class Org.BouncyCastle.OpenSsl.Pkcs8Generator : object {
    public static string PbeSha1_RC4_128;
    public static string PbeSha1_RC4_40;
    public static string PbeSha1_3DES;
    public static string PbeSha1_2DES;
    public static string PbeSha1_RC2_128;
    public static string PbeSha1_RC2_40;
    private Char[] password;
    private string algorithm;
    private int iterationCount;
    private AsymmetricKeyParameter privKey;
    private SecureRandom random;
    unknown SecureRandom SecureRandom {public set; }
    unknown Char[] Password {public set; }
    unknown int IterationCount {public set; }
    public Pkcs8Generator(AsymmetricKeyParameter privKey);
    public Pkcs8Generator(AsymmetricKeyParameter privKey, string algorithm);
    private static Pkcs8Generator();
    public void set_SecureRandom(SecureRandom value);
    public void set_Password(Char[] value);
    public void set_IterationCount(int value);
    public sealed virtual PemObject Generate();
}
public class Org.BouncyCastle.Pkcs.AsymmetricKeyEntry : Pkcs12Entry {
    private AsymmetricKeyParameter key;
    public AsymmetricKeyParameter Key { get; }
    public AsymmetricKeyEntry(AsymmetricKeyParameter key);
    [ObsoleteAttribute]
public AsymmetricKeyEntry(AsymmetricKeyParameter key, Hashtable attributes);
    public AsymmetricKeyEntry(AsymmetricKeyParameter key, IDictionary attributes);
    public AsymmetricKeyParameter get_Key();
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
}
public class Org.BouncyCastle.Pkcs.EncryptedPrivateKeyInfoFactory : object {
    public static EncryptedPrivateKeyInfo CreateEncryptedPrivateKeyInfo(DerObjectIdentifier algorithm, Char[] passPhrase, Byte[] salt, int iterationCount, AsymmetricKeyParameter key);
    public static EncryptedPrivateKeyInfo CreateEncryptedPrivateKeyInfo(string algorithm, Char[] passPhrase, Byte[] salt, int iterationCount, AsymmetricKeyParameter key);
    public static EncryptedPrivateKeyInfo CreateEncryptedPrivateKeyInfo(string algorithm, Char[] passPhrase, Byte[] salt, int iterationCount, PrivateKeyInfo keyInfo);
}
public class Org.BouncyCastle.Pkcs.Pkcs10CertificationRequest : CertificationRequest {
    protected static IDictionary algorithms;
    protected static IDictionary exParams;
    protected static IDictionary keyAlgorithms;
    protected static IDictionary oids;
    protected static ISet noParams;
    private static Pkcs10CertificationRequest();
    public Pkcs10CertificationRequest(Byte[] encoded);
    public Pkcs10CertificationRequest(Asn1Sequence seq);
    public Pkcs10CertificationRequest(Stream input);
    public Pkcs10CertificationRequest(string signatureAlgorithm, X509Name subject, AsymmetricKeyParameter publicKey, Asn1Set attributes, AsymmetricKeyParameter signingKey);
    private static RsassaPssParameters CreatePssParams(AlgorithmIdentifier hashAlgId, int saltSize);
    public AsymmetricKeyParameter GetPublicKey();
    public bool Verify();
    public bool Verify(AsymmetricKeyParameter publicKey);
    private void SetSignatureParameters(ISigner signature, Asn1Encodable asn1Params);
    internal static string GetSignatureName(AlgorithmIdentifier sigAlgId);
    private static string GetDigestAlgName(DerObjectIdentifier digestAlgOID);
}
public class Org.BouncyCastle.Pkcs.Pkcs10CertificationRequestDelaySigned : Pkcs10CertificationRequest {
    public Pkcs10CertificationRequestDelaySigned(Byte[] encoded);
    public Pkcs10CertificationRequestDelaySigned(Asn1Sequence seq);
    public Pkcs10CertificationRequestDelaySigned(Stream input);
    public Pkcs10CertificationRequestDelaySigned(string signatureAlgorithm, X509Name subject, AsymmetricKeyParameter publicKey, Asn1Set attributes, AsymmetricKeyParameter signingKey);
    public Pkcs10CertificationRequestDelaySigned(string signatureAlgorithm, X509Name subject, AsymmetricKeyParameter publicKey, Asn1Set attributes);
    public Byte[] GetDataToSign();
    public void SignRequest(Byte[] signedData);
    public void SignRequest(DerBitString signedData);
}
[DefaultMemberAttribute("Item")]
public abstract class Org.BouncyCastle.Pkcs.Pkcs12Entry : object {
    private IDictionary attributes;
    public Asn1Encodable Item { get; }
    public Asn1Encodable Item { get; }
    public IEnumerable BagAttributeKeys { get; }
    protected internal Pkcs12Entry(IDictionary attributes);
    [ObsoleteAttribute("Use 'object[index]' syntax instead")]
public Asn1Encodable GetBagAttribute(DerObjectIdentifier oid);
    [ObsoleteAttribute("Use 'object[index]' syntax instead")]
public Asn1Encodable GetBagAttribute(string oid);
    [ObsoleteAttribute("Use 'BagAttributeKeys' property")]
public IEnumerator GetBagAttributeKeys();
    public Asn1Encodable get_Item(DerObjectIdentifier oid);
    public Asn1Encodable get_Item(string oid);
    public IEnumerable get_BagAttributeKeys();
}
public class Org.BouncyCastle.Pkcs.Pkcs12Store : object {
    private static int MinIterations;
    private static int SaltSize;
    private IgnoresCaseHashtable keys;
    private IDictionary localIds;
    private IgnoresCaseHashtable certs;
    private IDictionary chainCerts;
    private IDictionary keyCerts;
    private DerObjectIdentifier keyAlgorithm;
    private DerObjectIdentifier certAlgorithm;
    private bool useDerEncoding;
    public IEnumerable Aliases { get; }
    public int Count { get; }
    internal Pkcs12Store(DerObjectIdentifier keyAlgorithm, DerObjectIdentifier certAlgorithm, bool useDerEncoding);
    public Pkcs12Store(Stream input, Char[] password);
    private static SubjectKeyIdentifier CreateSubjectKeyID(AsymmetricKeyParameter pubKey);
    public void Load(Stream input, Char[] password);
    public AsymmetricKeyEntry GetKey(string alias);
    public bool IsCertificateEntry(string alias);
    public bool IsKeyEntry(string alias);
    private IDictionary GetAliasesTable();
    public IEnumerable get_Aliases();
    public bool ContainsAlias(string alias);
    public X509CertificateEntry GetCertificate(string alias);
    public string GetCertificateAlias(X509Certificate cert);
    public X509CertificateEntry[] GetCertificateChain(string alias);
    public void SetCertificateEntry(string alias, X509CertificateEntry certEntry);
    public void SetKeyEntry(string alias, AsymmetricKeyEntry keyEntry, X509CertificateEntry[] chain);
    public void DeleteEntry(string alias);
    public bool IsEntryOfType(string alias, Type entryType);
    [ObsoleteAttribute("Use 'Count' property instead")]
public int Size();
    public int get_Count();
    public void Save(Stream stream, Char[] password, SecureRandom random);
    internal static Byte[] CalculatePbeMac(DerObjectIdentifier oid, Byte[] salt, int itCount, Char[] password, bool wrongPkcs12Zero, Byte[] data);
    private static Byte[] CryptPbeData(bool forEncryption, AlgorithmIdentifier algId, Char[] password, bool wrongPkcs12Zero, Byte[] data);
}
public class Org.BouncyCastle.Pkcs.Pkcs12StoreBuilder : object {
    private DerObjectIdentifier keyAlgorithm;
    private DerObjectIdentifier certAlgorithm;
    private bool useDerEncoding;
    public Pkcs12Store Build();
    public Pkcs12StoreBuilder SetCertAlgorithm(DerObjectIdentifier certAlgorithm);
    public Pkcs12StoreBuilder SetKeyAlgorithm(DerObjectIdentifier keyAlgorithm);
    public Pkcs12StoreBuilder SetUseDerEncoding(bool useDerEncoding);
}
public class Org.BouncyCastle.Pkcs.Pkcs12Utilities : object {
    public static Byte[] ConvertToDefiniteLength(Byte[] berPkcs12File);
    public static Byte[] ConvertToDefiniteLength(Byte[] berPkcs12File, Char[] passwd);
}
public class Org.BouncyCastle.Pkcs.PrivateKeyInfoFactory : object {
    public static PrivateKeyInfo CreatePrivateKeyInfo(AsymmetricKeyParameter key);
    public static PrivateKeyInfo CreatePrivateKeyInfo(Char[] passPhrase, EncryptedPrivateKeyInfo encInfo);
    public static PrivateKeyInfo CreatePrivateKeyInfo(Char[] passPhrase, bool wrongPkcs12Zero, EncryptedPrivateKeyInfo encInfo);
}
public class Org.BouncyCastle.Pkcs.X509CertificateEntry : Pkcs12Entry {
    private X509Certificate cert;
    public X509Certificate Certificate { get; }
    public X509CertificateEntry(X509Certificate cert);
    [ObsoleteAttribute]
public X509CertificateEntry(X509Certificate cert, Hashtable attributes);
    public X509CertificateEntry(X509Certificate cert, IDictionary attributes);
    public X509Certificate get_Certificate();
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
}
public class Org.BouncyCastle.Pkix.CertStatus : object {
    public static int Unrevoked;
    public static int Undetermined;
    private int status;
    private DateTimeObject revocationDate;
    public DateTimeObject RevocationDate { get; public set; }
    public int Status { get; public set; }
    public DateTimeObject get_RevocationDate();
    public void set_RevocationDate(DateTimeObject value);
    public int get_Status();
    public void set_Status(int value);
}
public abstract class Org.BouncyCastle.Pkix.PkixAttrCertChecker : object {
    public abstract virtual ISet GetSupportedExtensions();
    public abstract virtual void Check(IX509AttributeCertificate attrCert, PkixCertPath certPath, PkixCertPath holderCertPath, ICollection unresolvedCritExts);
    public abstract virtual PkixAttrCertChecker Clone();
}
public class Org.BouncyCastle.Pkix.PkixAttrCertPathBuilder : object {
    private Exception certPathException;
    public virtual PkixCertPathBuilderResult Build(PkixBuilderParameters pkixParams);
    private PkixCertPathBuilderResult Build(IX509AttributeCertificate attrCert, X509Certificate tbvCert, PkixBuilderParameters pkixParams, IList tbvPath);
}
public class Org.BouncyCastle.Pkix.PkixAttrCertPathValidator : object {
    public virtual PkixCertPathValidatorResult Validate(PkixCertPath certPath, PkixParameters pkixParams);
}
public class Org.BouncyCastle.Pkix.PkixBuilderParameters : PkixParameters {
    private int maxPathLength;
    private ISet excludedCerts;
    public int MaxPathLength { get; public set; }
    public PkixBuilderParameters(ISet trustAnchors, IX509Selector targetConstraints);
    public static PkixBuilderParameters GetInstance(PkixParameters pkixParams);
    public virtual int get_MaxPathLength();
    public virtual void set_MaxPathLength(int value);
    public virtual ISet GetExcludedCerts();
    public virtual void SetExcludedCerts(ISet excludedCerts);
    protected virtual void SetParams(PkixParameters parameters);
    public virtual object Clone();
    public virtual string ToString();
}
public class Org.BouncyCastle.Pkix.PkixCertPath : object {
    internal static IList certPathEncodings;
    private IList certificates;
    public IEnumerable Encodings { get; }
    public IList Certificates { get; }
    private static PkixCertPath();
    public PkixCertPath(ICollection certificates);
    public PkixCertPath(Stream inStream);
    public PkixCertPath(Stream inStream, string encoding);
    private static IList SortCerts(IList certs);
    public virtual IEnumerable get_Encodings();
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public virtual Byte[] GetEncoded();
    public virtual Byte[] GetEncoded(string encoding);
    public virtual IList get_Certificates();
    private Asn1Object ToAsn1Object(X509Certificate cert);
    private Byte[] ToDerEncoded(Asn1Encodable obj);
}
public class Org.BouncyCastle.Pkix.PkixCertPathBuilder : object {
    private Exception certPathException;
    public virtual PkixCertPathBuilderResult Build(PkixBuilderParameters pkixParams);
    protected virtual PkixCertPathBuilderResult Build(X509Certificate tbvCert, PkixBuilderParameters pkixParams, IList tbvPath);
}
public class Org.BouncyCastle.Pkix.PkixCertPathBuilderException : GeneralSecurityException {
    public PkixCertPathBuilderException(string message);
    public PkixCertPathBuilderException(string message, Exception exception);
}
public class Org.BouncyCastle.Pkix.PkixCertPathBuilderResult : PkixCertPathValidatorResult {
    private PkixCertPath certPath;
    public PkixCertPath CertPath { get; }
    public PkixCertPathBuilderResult(PkixCertPath certPath, TrustAnchor trustAnchor, PkixPolicyNode policyTree, AsymmetricKeyParameter subjectPublicKey);
    public PkixCertPath get_CertPath();
    public virtual string ToString();
}
public abstract class Org.BouncyCastle.Pkix.PkixCertPathChecker : object {
    public abstract virtual void Init(bool forward);
    public abstract virtual bool IsForwardCheckingSupported();
    public abstract virtual ISet GetSupportedExtensions();
    public abstract virtual void Check(X509Certificate cert, ICollection unresolvedCritExts);
    public virtual object Clone();
}
public class Org.BouncyCastle.Pkix.PkixCertPathValidator : object {
    public virtual PkixCertPathValidatorResult Validate(PkixCertPath certPath, PkixParameters paramsPkix);
}
public class Org.BouncyCastle.Pkix.PkixCertPathValidatorException : GeneralSecurityException {
    private Exception cause;
    private PkixCertPath certPath;
    private int index;
    public string Message { get; }
    public PkixCertPath CertPath { get; }
    public int Index { get; }
    public PkixCertPathValidatorException(string message);
    public PkixCertPathValidatorException(string message, Exception cause);
    public PkixCertPathValidatorException(string message, Exception cause, PkixCertPath certPath, int index);
    public virtual string get_Message();
    public PkixCertPath get_CertPath();
    public int get_Index();
}
public class Org.BouncyCastle.Pkix.PkixCertPathValidatorResult : object {
    private TrustAnchor trustAnchor;
    private PkixPolicyNode policyTree;
    private AsymmetricKeyParameter subjectPublicKey;
    public PkixPolicyNode PolicyTree { get; }
    public TrustAnchor TrustAnchor { get; }
    public AsymmetricKeyParameter SubjectPublicKey { get; }
    public PkixCertPathValidatorResult(TrustAnchor trustAnchor, PkixPolicyNode policyTree, AsymmetricKeyParameter subjectPublicKey);
    public PkixPolicyNode get_PolicyTree();
    public TrustAnchor get_TrustAnchor();
    public AsymmetricKeyParameter get_SubjectPublicKey();
    public object Clone();
    public virtual string ToString();
}
public class Org.BouncyCastle.Pkix.PkixCertPathValidatorUtilities : object {
    private static PkixCrlUtilities CrlUtilities;
    internal static string ANY_POLICY;
    internal static string CRL_NUMBER;
    internal static int KEY_CERT_SIGN;
    internal static int CRL_SIGN;
    internal static String[] crlReasons;
    private static PkixCertPathValidatorUtilities();
    internal static TrustAnchor FindTrustAnchor(X509Certificate cert, ISet trustAnchors);
    internal static void AddAdditionalStoresFromAltNames(X509Certificate cert, PkixParameters pkixParams);
    internal static DateTime GetValidDate(PkixParameters paramsPKIX);
    internal static X509Name GetIssuerPrincipal(object cert);
    internal static bool IsSelfIssued(X509Certificate cert);
    internal static AlgorithmIdentifier GetAlgorithmIdentifier(AsymmetricKeyParameter key);
    internal static bool IsAnyPolicy(ISet policySet);
    internal static void AddAdditionalStoreFromLocation(string location, PkixParameters pkixParams);
    private static BigInteger GetSerialNumber(object cert);
    internal static ISet GetQualifierSet(Asn1Sequence qualifiers);
    internal static PkixPolicyNode RemovePolicyNode(PkixPolicyNode validPolicyTree, IList[] policyNodes, PkixPolicyNode _node);
    private static void RemovePolicyNodeRecurse(IList[] policyNodes, PkixPolicyNode _node);
    internal static void PrepareNextCertB1(int i, IList[] policyNodes, string id_p, IDictionary m_idp, X509Certificate cert);
    internal static PkixPolicyNode PrepareNextCertB2(int i, IList[] policyNodes, string id_p, PkixPolicyNode validPolicyTree);
    internal static void GetCertStatus(DateTime validDate, X509Crl crl, object cert, CertStatus certStatus);
    internal static AsymmetricKeyParameter GetNextWorkingKey(IList certs, int index);
    internal static DateTime GetValidCertDateFromValidityModel(PkixParameters paramsPkix, PkixCertPath certPath, int index);
    internal static ICollection FindCertificates(X509CertStoreSelector certSelect, IList certStores);
    internal static void GetCrlIssuersFromDistributionPoint(DistributionPoint dp, ICollection issuerPrincipals, X509CrlStoreSelector selector, PkixParameters pkixParams);
    internal static ISet GetCompleteCrls(DistributionPoint dp, object cert, DateTime currentDate, PkixParameters paramsPKIX);
    internal static ISet GetDeltaCrls(DateTime currentDate, PkixParameters paramsPKIX, X509Crl completeCRL);
    private static bool isDeltaCrl(X509Crl crl);
    internal static ICollection FindCertificates(X509AttrCertStoreSelector certSelect, IList certStores);
    internal static void AddAdditionalStoresFromCrlDistributionPoint(CrlDistPoint crldp, PkixParameters pkixParams);
    internal static bool ProcessCertD1i(int index, IList[] policyNodes, DerObjectIdentifier pOid, ISet pq);
    internal static void ProcessCertD1ii(int index, IList[] policyNodes, DerObjectIdentifier _poid, ISet _pq);
    internal static ICollection FindIssuerCerts(X509Certificate cert, PkixBuilderParameters pkixParams);
    internal static Asn1Object GetExtensionValue(IX509Extension ext, DerObjectIdentifier oid);
}
public class Org.BouncyCastle.Pkix.PkixCrlUtilities : object {
    public virtual ISet FindCrls(X509CrlStoreSelector crlselect, PkixParameters paramsPkix, DateTime currentDate);
    public virtual ISet FindCrls(X509CrlStoreSelector crlselect, PkixParameters paramsPkix);
    private ICollection FindCrls(X509CrlStoreSelector crlSelect, IList crlStores);
}
public class Org.BouncyCastle.Pkix.PkixNameConstraintValidator : object {
    private ISet excludedSubtreesDN;
    private ISet excludedSubtreesDNS;
    private ISet excludedSubtreesEmail;
    private ISet excludedSubtreesURI;
    private ISet excludedSubtreesIP;
    private ISet permittedSubtreesDN;
    private ISet permittedSubtreesDNS;
    private ISet permittedSubtreesEmail;
    private ISet permittedSubtreesURI;
    private ISet permittedSubtreesIP;
    private static bool WithinDNSubtree(Asn1Sequence dns, Asn1Sequence subtree);
    public void CheckPermittedDN(Asn1Sequence dns);
    public void CheckExcludedDN(Asn1Sequence dns);
    private void CheckPermittedDN(ISet permitted, Asn1Sequence dns);
    private void CheckExcludedDN(ISet excluded, Asn1Sequence dns);
    private ISet IntersectDN(ISet permitted, ISet dns);
    private ISet UnionDN(ISet excluded, Asn1Sequence dn);
    private ISet IntersectEmail(ISet permitted, ISet emails);
    private ISet UnionEmail(ISet excluded, string email);
    private ISet IntersectIP(ISet permitted, ISet ips);
    private ISet UnionIP(ISet excluded, Byte[] ip);
    private ISet UnionIPRange(Byte[] ipWithSubmask1, Byte[] ipWithSubmask2);
    private ISet IntersectIPRange(Byte[] ipWithSubmask1, Byte[] ipWithSubmask2);
    private Byte[] IpWithSubnetMask(Byte[] ip, Byte[] subnetMask);
    private Byte[][] ExtractIPsAndSubnetMasks(Byte[] ipWithSubmask1, Byte[] ipWithSubmask2);
    private Byte[][] MinMaxIPs(Byte[] ip1, Byte[] subnetmask1, Byte[] ip2, Byte[] subnetmask2);
    private void CheckPermittedEmail(ISet permitted, string email);
    private void CheckExcludedEmail(ISet excluded, string email);
    private void CheckPermittedIP(ISet permitted, Byte[] ip);
    private void checkExcludedIP(ISet excluded, Byte[] ip);
    private bool IsIPConstrained(Byte[] ip, Byte[] constraint);
    private bool EmailIsConstrained(string email, string constraint);
    private bool WithinDomain(string testDomain, string domain);
    private void CheckPermittedDNS(ISet permitted, string dns);
    private void checkExcludedDNS(ISet excluded, string dns);
    private void unionEmail(string email1, string email2, ISet union);
    private void unionURI(string email1, string email2, ISet union);
    private ISet intersectDNS(ISet permitted, ISet dnss);
    protected ISet unionDNS(ISet excluded, string dns);
    private void intersectEmail(string email1, string email2, ISet intersect);
    private void checkExcludedURI(ISet excluded, string uri);
    private ISet intersectURI(ISet permitted, ISet uris);
    private ISet unionURI(ISet excluded, string uri);
    private void intersectURI(string email1, string email2, ISet intersect);
    private void CheckPermittedURI(ISet permitted, string uri);
    private bool IsUriConstrained(string uri, string constraint);
    private static string ExtractHostFromURL(string url);
    public void checkPermitted(GeneralName name);
    public void checkExcluded(GeneralName name);
    public void IntersectPermittedSubtree(Asn1Sequence permitted);
    private string ExtractNameAsString(GeneralName name);
    public void IntersectEmptyPermittedSubtree(int nameType);
    public void AddExcludedSubtree(GeneralSubtree subtree);
    private static Byte[] Max(Byte[] ip1, Byte[] ip2);
    private static Byte[] Min(Byte[] ip1, Byte[] ip2);
    private static int CompareTo(Byte[] ip1, Byte[] ip2);
    private static Byte[] Or(Byte[] ip1, Byte[] ip2);
    [ObsoleteAttribute("Use GetHashCode instead")]
public int HashCode();
    public virtual int GetHashCode();
    private int HashCollection(ICollection coll);
    public virtual bool Equals(object o);
    private bool CollectionsAreEqual(ICollection coll1, ICollection coll2);
    private bool SpecialEquals(object o1, object o2);
    private string StringifyIP(Byte[] ip);
    private string StringifyIPCollection(ISet ips);
    public virtual string ToString();
}
public class Org.BouncyCastle.Pkix.PkixNameConstraintValidatorException : Exception {
    public PkixNameConstraintValidatorException(string msg);
}
public class Org.BouncyCastle.Pkix.PkixParameters : object {
    public static int PkixValidityModel;
    public static int ChainValidityModel;
    private ISet trustAnchors;
    private DateTimeObject date;
    private IList certPathCheckers;
    private bool revocationEnabled;
    private ISet initialPolicies;
    private bool explicitPolicyRequired;
    private bool anyPolicyInhibited;
    private bool policyMappingInhibited;
    private bool policyQualifiersRejected;
    private IX509Selector certSelector;
    private IList stores;
    private IX509Selector selector;
    private bool additionalLocationsEnabled;
    private IList additionalStores;
    private ISet trustedACIssuers;
    private ISet necessaryACAttributes;
    private ISet prohibitedACAttributes;
    private ISet attrCertCheckers;
    private int validityModel;
    private bool useDeltas;
    public bool IsRevocationEnabled { get; public set; }
    public bool IsExplicitPolicyRequired { get; public set; }
    public bool IsAnyPolicyInhibited { get; public set; }
    public bool IsPolicyMappingInhibited { get; public set; }
    public bool IsPolicyQualifiersRejected { get; public set; }
    public DateTimeObject Date { get; public set; }
    public bool IsUseDeltasEnabled { get; public set; }
    public int ValidityModel { get; public set; }
    public bool IsAdditionalLocationsEnabled { get; }
    public PkixParameters(ISet trustAnchors);
    public virtual bool get_IsRevocationEnabled();
    public virtual void set_IsRevocationEnabled(bool value);
    public virtual bool get_IsExplicitPolicyRequired();
    public virtual void set_IsExplicitPolicyRequired(bool value);
    public virtual bool get_IsAnyPolicyInhibited();
    public virtual void set_IsAnyPolicyInhibited(bool value);
    public virtual bool get_IsPolicyMappingInhibited();
    public virtual void set_IsPolicyMappingInhibited(bool value);
    public virtual bool get_IsPolicyQualifiersRejected();
    public virtual void set_IsPolicyQualifiersRejected(bool value);
    public virtual DateTimeObject get_Date();
    public virtual void set_Date(DateTimeObject value);
    public virtual ISet GetTrustAnchors();
    public virtual void SetTrustAnchors(ISet tas);
    public virtual X509CertStoreSelector GetTargetCertConstraints();
    public virtual void SetTargetCertConstraints(IX509Selector selector);
    public virtual ISet GetInitialPolicies();
    public virtual void SetInitialPolicies(ISet initialPolicies);
    public virtual void SetCertPathCheckers(IList checkers);
    public virtual IList GetCertPathCheckers();
    public virtual void AddCertPathChecker(PkixCertPathChecker checker);
    public virtual object Clone();
    protected virtual void SetParams(PkixParameters parameters);
    public virtual bool get_IsUseDeltasEnabled();
    public virtual void set_IsUseDeltasEnabled(bool value);
    public virtual int get_ValidityModel();
    public virtual void set_ValidityModel(int value);
    public virtual void SetStores(IList stores);
    public virtual void AddStore(IX509Store store);
    public virtual void AddAdditionalStore(IX509Store store);
    public virtual IList GetAdditionalStores();
    public virtual IList GetStores();
    public virtual bool get_IsAdditionalLocationsEnabled();
    public virtual void SetAdditionalLocationsEnabled(bool enabled);
    public virtual IX509Selector GetTargetConstraints();
    public virtual void SetTargetConstraints(IX509Selector selector);
    public virtual ISet GetTrustedACIssuers();
    public virtual void SetTrustedACIssuers(ISet trustedACIssuers);
    public virtual ISet GetNecessaryACAttributes();
    public virtual void SetNecessaryACAttributes(ISet necessaryACAttributes);
    public virtual ISet GetProhibitedACAttributes();
    public virtual void SetProhibitedACAttributes(ISet prohibitedACAttributes);
    public virtual ISet GetAttrCertCheckers();
    public virtual void SetAttrCertCheckers(ISet attrCertCheckers);
}
public class Org.BouncyCastle.Pkix.PkixPolicyNode : object {
    protected IList mChildren;
    protected int mDepth;
    protected ISet mExpectedPolicies;
    protected PkixPolicyNode mParent;
    protected ISet mPolicyQualifiers;
    protected string mValidPolicy;
    protected bool mCritical;
    public int Depth { get; }
    public IEnumerable Children { get; }
    public bool IsCritical { get; public set; }
    public ISet PolicyQualifiers { get; }
    public string ValidPolicy { get; }
    public bool HasChildren { get; }
    public ISet ExpectedPolicies { get; public set; }
    public PkixPolicyNode Parent { get; public set; }
    public PkixPolicyNode(IList children, int depth, ISet expectedPolicies, PkixPolicyNode parent, ISet policyQualifiers, string validPolicy, bool critical);
    public virtual int get_Depth();
    public virtual IEnumerable get_Children();
    public virtual bool get_IsCritical();
    public virtual void set_IsCritical(bool value);
    public virtual ISet get_PolicyQualifiers();
    public virtual string get_ValidPolicy();
    public virtual bool get_HasChildren();
    public virtual ISet get_ExpectedPolicies();
    public virtual void set_ExpectedPolicies(ISet value);
    public virtual PkixPolicyNode get_Parent();
    public virtual void set_Parent(PkixPolicyNode value);
    public virtual void AddChild(PkixPolicyNode child);
    public virtual void RemoveChild(PkixPolicyNode child);
    public virtual string ToString();
    public virtual string ToString(string indent);
    public virtual object Clone();
    public virtual PkixPolicyNode Copy();
}
internal class Org.BouncyCastle.Pkix.ReasonsMask : object {
    private int _reasons;
    internal static ReasonsMask AllReasons;
    internal bool IsAllReasons { get; }
    public ReasonFlags Reasons { get; }
    internal ReasonsMask(int reasons);
    private static ReasonsMask();
    internal void AddReasons(ReasonsMask mask);
    internal bool get_IsAllReasons();
    internal ReasonsMask Intersect(ReasonsMask mask);
    internal bool HasNewReasons(ReasonsMask mask);
    public ReasonFlags get_Reasons();
}
public class Org.BouncyCastle.Pkix.Rfc3280CertPathUtilities : object {
    private static PkixCrlUtilities CrlUtilities;
    internal static string ANY_POLICY;
    internal static int KEY_CERT_SIGN;
    internal static int CRL_SIGN;
    internal static String[] CrlReasons;
    private static Rfc3280CertPathUtilities();
    internal static void ProcessCrlB2(DistributionPoint dp, object cert, X509Crl crl);
    internal static void ProcessCertBC(PkixCertPath certPath, int index, PkixNameConstraintValidator nameConstraintValidator);
    internal static void PrepareNextCertA(PkixCertPath certPath, int index);
    internal static PkixPolicyNode ProcessCertD(PkixCertPath certPath, int index, ISet acceptablePolicies, PkixPolicyNode validPolicyTree, IList[] policyNodes, int inhibitAnyPolicy);
    internal static void ProcessCrlB1(DistributionPoint dp, object cert, X509Crl crl);
    internal static ReasonsMask ProcessCrlD(X509Crl crl, DistributionPoint dp);
    internal static ISet ProcessCrlF(X509Crl crl, object cert, X509Certificate defaultCRLSignCert, AsymmetricKeyParameter defaultCRLSignKey, PkixParameters paramsPKIX, IList certPathCerts);
    internal static AsymmetricKeyParameter ProcessCrlG(X509Crl crl, ISet keys);
    internal static X509Crl ProcessCrlH(ISet deltaCrls, AsymmetricKeyParameter key);
    private static void CheckCrl(DistributionPoint dp, PkixParameters paramsPKIX, X509Certificate cert, DateTime validDate, X509Certificate defaultCRLSignCert, AsymmetricKeyParameter defaultCRLSignKey, CertStatus certStatus, ReasonsMask reasonMask, IList certPathCerts);
    protected static void CheckCrls(PkixParameters paramsPKIX, X509Certificate cert, DateTime validDate, X509Certificate sign, AsymmetricKeyParameter workingPublicKey, IList certPathCerts);
    internal static PkixPolicyNode PrepareCertB(PkixCertPath certPath, int index, IList[] policyNodes, PkixPolicyNode validPolicyTree, int policyMapping);
    internal static ISet[] ProcessCrlA1ii(DateTime currentDate, PkixParameters paramsPKIX, X509Certificate cert, X509Crl crl);
    internal static ISet ProcessCrlA1i(DateTime currentDate, PkixParameters paramsPKIX, X509Certificate cert, X509Crl crl);
    internal static void ProcessCertF(PkixCertPath certPath, int index, PkixPolicyNode validPolicyTree, int explicitPolicy);
    internal static void ProcessCertA(PkixCertPath certPath, PkixParameters paramsPKIX, int index, AsymmetricKeyParameter workingPublicKey, X509Name workingIssuerName, X509Certificate sign);
    internal static int PrepareNextCertI1(PkixCertPath certPath, int index, int explicitPolicy);
    internal static int PrepareNextCertI2(PkixCertPath certPath, int index, int policyMapping);
    internal static void PrepareNextCertG(PkixCertPath certPath, int index, PkixNameConstraintValidator nameConstraintValidator);
    internal static int PrepareNextCertJ(PkixCertPath certPath, int index, int inhibitAnyPolicy);
    internal static void PrepareNextCertK(PkixCertPath certPath, int index);
    internal static int PrepareNextCertL(PkixCertPath certPath, int index, int maxPathLength);
    internal static int PrepareNextCertM(PkixCertPath certPath, int index, int maxPathLength);
    internal static void PrepareNextCertN(PkixCertPath certPath, int index);
    internal static void PrepareNextCertO(PkixCertPath certPath, int index, ISet criticalExtensions, IList pathCheckers);
    internal static int PrepareNextCertH1(PkixCertPath certPath, int index, int explicitPolicy);
    internal static int PrepareNextCertH2(PkixCertPath certPath, int index, int policyMapping);
    internal static int PrepareNextCertH3(PkixCertPath certPath, int index, int inhibitAnyPolicy);
    internal static int WrapupCertA(int explicitPolicy, X509Certificate cert);
    internal static int WrapupCertB(PkixCertPath certPath, int index, int explicitPolicy);
    internal static void WrapupCertF(PkixCertPath certPath, int index, IList pathCheckers, ISet criticalExtensions);
    internal static PkixPolicyNode WrapupCertG(PkixCertPath certPath, PkixParameters paramsPKIX, ISet userInitialPolicySet, int index, IList[] policyNodes, PkixPolicyNode validPolicyTree, ISet acceptablePolicies);
    internal static void ProcessCrlC(X509Crl deltaCRL, X509Crl completeCRL, PkixParameters pkixParams);
    internal static void ProcessCrlI(DateTime validDate, X509Crl deltacrl, object cert, CertStatus certStatus, PkixParameters pkixParams);
    internal static void ProcessCrlJ(DateTime validDate, X509Crl completecrl, object cert, CertStatus certStatus);
    internal static PkixPolicyNode ProcessCertE(PkixCertPath certPath, int index, PkixPolicyNode validPolicyTree);
}
internal class Org.BouncyCastle.Pkix.Rfc3281CertPathUtilities : object {
    internal static void ProcessAttrCert7(IX509AttributeCertificate attrCert, PkixCertPath certPath, PkixCertPath holderCertPath, PkixParameters pkixParams);
    internal static void CheckCrls(IX509AttributeCertificate attrCert, PkixParameters paramsPKIX, X509Certificate issuerCert, DateTime validDate, IList certPathCerts);
    internal static void AdditionalChecks(IX509AttributeCertificate attrCert, PkixParameters pkixParams);
    internal static void ProcessAttrCert5(IX509AttributeCertificate attrCert, PkixParameters pkixParams);
    internal static void ProcessAttrCert4(X509Certificate acIssuerCert, PkixParameters pkixParams);
    internal static void ProcessAttrCert3(X509Certificate acIssuerCert, PkixParameters pkixParams);
    internal static PkixCertPathValidatorResult ProcessAttrCert2(PkixCertPath certPath, PkixParameters pkixParams);
    internal static PkixCertPath ProcessAttrCert1(IX509AttributeCertificate attrCert, PkixParameters pkixParams);
    private static void CheckCrl(DistributionPoint dp, IX509AttributeCertificate attrCert, PkixParameters paramsPKIX, DateTime validDate, X509Certificate issuerCert, CertStatus certStatus, ReasonsMask reasonMask, IList certPathCerts);
}
public class Org.BouncyCastle.Pkix.TrustAnchor : object {
    private AsymmetricKeyParameter pubKey;
    private string caName;
    private X509Name caPrincipal;
    private X509Certificate trustedCert;
    private Byte[] ncBytes;
    private NameConstraints nc;
    public X509Certificate TrustedCert { get; }
    public X509Name CA { get; }
    public string CAName { get; }
    public AsymmetricKeyParameter CAPublicKey { get; }
    public Byte[] GetNameConstraints { get; }
    public TrustAnchor(X509Certificate trustedCert, Byte[] nameConstraints);
    public TrustAnchor(X509Name caPrincipal, AsymmetricKeyParameter pubKey, Byte[] nameConstraints);
    public TrustAnchor(string caName, AsymmetricKeyParameter pubKey, Byte[] nameConstraints);
    public X509Certificate get_TrustedCert();
    public X509Name get_CA();
    public string get_CAName();
    public AsymmetricKeyParameter get_CAPublicKey();
    private void setNameConstraints(Byte[] bytes);
    public Byte[] get_GetNameConstraints();
    public virtual string ToString();
}
public class Org.BouncyCastle.Security.AgreementUtilities : object {
    private static IDictionary algorithms;
    private static AgreementUtilities();
    public static IBasicAgreement GetBasicAgreement(DerObjectIdentifier oid);
    public static IBasicAgreement GetBasicAgreement(string algorithm);
    public static IBasicAgreement GetBasicAgreementWithKdf(DerObjectIdentifier oid, string wrapAlgorithm);
    public static IBasicAgreement GetBasicAgreementWithKdf(string agreeAlgorithm, string wrapAlgorithm);
    public static string GetAlgorithmName(DerObjectIdentifier oid);
}
public class Org.BouncyCastle.Security.Certificates.CertificateEncodingException : CertificateException {
    public CertificateEncodingException(string msg);
    public CertificateEncodingException(string msg, Exception e);
}
public class Org.BouncyCastle.Security.Certificates.CertificateException : GeneralSecurityException {
    public CertificateException(string message);
    public CertificateException(string message, Exception exception);
}
public class Org.BouncyCastle.Security.Certificates.CertificateExpiredException : CertificateException {
    public CertificateExpiredException(string message);
    public CertificateExpiredException(string message, Exception exception);
}
public class Org.BouncyCastle.Security.Certificates.CertificateNotYetValidException : CertificateException {
    public CertificateNotYetValidException(string message);
    public CertificateNotYetValidException(string message, Exception exception);
}
public class Org.BouncyCastle.Security.Certificates.CertificateParsingException : CertificateException {
    public CertificateParsingException(string message);
    public CertificateParsingException(string message, Exception exception);
}
public class Org.BouncyCastle.Security.Certificates.CrlException : GeneralSecurityException {
    public CrlException(string msg);
    public CrlException(string msg, Exception e);
}
public class Org.BouncyCastle.Security.CipherUtilities : object {
    private static IDictionary algorithms;
    private static IDictionary oids;
    public static ICollection Algorithms { get; }
    private static CipherUtilities();
    public static DerObjectIdentifier GetObjectIdentifier(string mechanism);
    public static ICollection get_Algorithms();
    public static IBufferedCipher GetCipher(DerObjectIdentifier oid);
    public static IBufferedCipher GetCipher(string algorithm);
    public static string GetAlgorithmName(DerObjectIdentifier oid);
    private static int GetDigitIndex(string s);
    private static IBlockCipher CreateBlockCipher(CipherAlgorithm cipherAlgorithm);
}
public class Org.BouncyCastle.Security.DigestUtilities : object {
    private static IDictionary algorithms;
    private static IDictionary oids;
    public static ICollection Algorithms { get; }
    private static DigestUtilities();
    public static DerObjectIdentifier GetObjectIdentifier(string mechanism);
    public static ICollection get_Algorithms();
    public static IDigest GetDigest(DerObjectIdentifier id);
    public static IDigest GetDigest(string algorithm);
    public static string GetAlgorithmName(DerObjectIdentifier oid);
    public static Byte[] CalculateDigest(string algorithm, Byte[] input);
    public static Byte[] DoFinal(IDigest digest);
    public static Byte[] DoFinal(IDigest digest, Byte[] input);
}
public class Org.BouncyCastle.Security.DotNetUtilities : object {
    public static X509Certificate ToX509Certificate(X509CertificateStructure x509Struct);
    public static X509Certificate ToX509Certificate(X509Certificate x509Cert);
    public static X509Certificate FromX509Certificate(X509Certificate x509Cert);
    public static AsymmetricCipherKeyPair GetDsaKeyPair(DSA dsa);
    public static AsymmetricCipherKeyPair GetDsaKeyPair(DSAParameters dp);
    public static DsaPublicKeyParameters GetDsaPublicKey(DSA dsa);
    public static DsaPublicKeyParameters GetDsaPublicKey(DSAParameters dp);
    public static AsymmetricCipherKeyPair GetRsaKeyPair(RSA rsa);
    public static AsymmetricCipherKeyPair GetRsaKeyPair(RSAParameters rp);
    public static RsaKeyParameters GetRsaPublicKey(RSA rsa);
    public static RsaKeyParameters GetRsaPublicKey(RSAParameters rp);
    public static AsymmetricCipherKeyPair GetKeyPair(AsymmetricAlgorithm privateKey);
    public static RSA ToRSA(RsaKeyParameters rsaKey);
    public static RSA ToRSA(RsaPrivateCrtKeyParameters privKey);
    public static RSAParameters ToRSAParameters(RsaKeyParameters rsaKey);
    public static RSAParameters ToRSAParameters(RsaPrivateCrtKeyParameters privKey);
    private static Byte[] ConvertRSAParametersField(BigInteger n, int size);
}
public class Org.BouncyCastle.Security.EncryptionException : IOException {
    public EncryptionException(string message);
    public EncryptionException(string message, Exception exception);
}
public class Org.BouncyCastle.Security.GeneralSecurityException : Exception {
    public GeneralSecurityException(string message);
    public GeneralSecurityException(string message, Exception exception);
}
public class Org.BouncyCastle.Security.GeneratorUtilities : object {
    private static IDictionary kgAlgorithms;
    private static IDictionary kpgAlgorithms;
    private static IDictionary defaultKeySizes;
    private static GeneratorUtilities();
    private static void AddDefaultKeySizeEntries(int size, String[] algorithms);
    private static void AddKgAlgorithm(string canonicalName, Object[] aliases);
    private static void AddKpgAlgorithm(string canonicalName, Object[] aliases);
    private static void AddHMacKeyGenerator(string algorithm, Object[] aliases);
    internal static string GetCanonicalKeyGeneratorAlgorithm(string algorithm);
    internal static string GetCanonicalKeyPairGeneratorAlgorithm(string algorithm);
    public static CipherKeyGenerator GetKeyGenerator(DerObjectIdentifier oid);
    public static CipherKeyGenerator GetKeyGenerator(string algorithm);
    public static IAsymmetricCipherKeyPairGenerator GetKeyPairGenerator(DerObjectIdentifier oid);
    public static IAsymmetricCipherKeyPairGenerator GetKeyPairGenerator(string algorithm);
    internal static int GetDefaultKeySize(DerObjectIdentifier oid);
    internal static int GetDefaultKeySize(string algorithm);
    private static int FindDefaultKeySize(string canonicalName);
}
public class Org.BouncyCastle.Security.InvalidKeyException : KeyException {
    public InvalidKeyException(string message);
    public InvalidKeyException(string message, Exception exception);
}
public class Org.BouncyCastle.Security.InvalidParameterException : KeyException {
    public InvalidParameterException(string message);
    public InvalidParameterException(string message, Exception exception);
}
public class Org.BouncyCastle.Security.KeyException : GeneralSecurityException {
    public KeyException(string message);
    public KeyException(string message, Exception exception);
}
public class Org.BouncyCastle.Security.MacUtilities : object {
    private static IDictionary algorithms;
    private static MacUtilities();
    public static IMac GetMac(DerObjectIdentifier id);
    public static IMac GetMac(string algorithm);
    public static string GetAlgorithmName(DerObjectIdentifier oid);
    public static Byte[] DoFinal(IMac mac);
}
[ObsoleteAttribute("Never thrown")]
public class Org.BouncyCastle.Security.NoSuchAlgorithmException : GeneralSecurityException {
    public NoSuchAlgorithmException(string message);
    public NoSuchAlgorithmException(string message, Exception exception);
}
public class Org.BouncyCastle.Security.ParameterUtilities : object {
    private static IDictionary algorithms;
    private static IDictionary basicIVSizes;
    private static ParameterUtilities();
    private static void AddAlgorithm(string canonicalName, Object[] aliases);
    private static void AddBasicIVSizeEntries(int size, String[] algorithms);
    public static string GetCanonicalAlgorithmName(string algorithm);
    public static KeyParameter CreateKeyParameter(DerObjectIdentifier algOid, Byte[] keyBytes);
    public static KeyParameter CreateKeyParameter(string algorithm, Byte[] keyBytes);
    public static KeyParameter CreateKeyParameter(DerObjectIdentifier algOid, Byte[] keyBytes, int offset, int length);
    public static KeyParameter CreateKeyParameter(string algorithm, Byte[] keyBytes, int offset, int length);
    public static ICipherParameters GetCipherParameters(DerObjectIdentifier algOid, ICipherParameters key, Asn1Object asn1Params);
    public static ICipherParameters GetCipherParameters(string algorithm, ICipherParameters key, Asn1Object asn1Params);
    public static Asn1Encodable GenerateParameters(DerObjectIdentifier algID, SecureRandom random);
    public static Asn1Encodable GenerateParameters(string algorithm, SecureRandom random);
    private static Asn1OctetString CreateIVOctetString(SecureRandom random, int ivLength);
    private static Byte[] CreateIV(SecureRandom random, int ivLength);
    private static int FindBasicIVSize(string canonicalName);
}
public class Org.BouncyCastle.Security.PasswordException : IOException {
    public PasswordException(string message);
    public PasswordException(string message, Exception exception);
}
public class Org.BouncyCastle.Security.PbeUtilities : object {
    private static string Pkcs5S1;
    private static string Pkcs5S2;
    private static string Pkcs12;
    private static string OpenSsl;
    private static IDictionary algorithms;
    private static IDictionary algorithmType;
    private static IDictionary oids;
    public static ICollection Algorithms { get; }
    private static PbeUtilities();
    private static PbeParametersGenerator MakePbeGenerator(string type, IDigest digest, Byte[] key, Byte[] salt, int iterationCount);
    public static DerObjectIdentifier GetObjectIdentifier(string mechanism);
    public static ICollection get_Algorithms();
    public static bool IsPkcs12(string algorithm);
    public static bool IsPkcs5Scheme1(string algorithm);
    public static bool IsPkcs5Scheme2(string algorithm);
    public static bool IsOpenSsl(string algorithm);
    public static bool IsPbeAlgorithm(string algorithm);
    public static Asn1Encodable GenerateAlgorithmParameters(DerObjectIdentifier algorithmOid, Byte[] salt, int iterationCount);
    public static Asn1Encodable GenerateAlgorithmParameters(string algorithm, Byte[] salt, int iterationCount);
    public static ICipherParameters GenerateCipherParameters(DerObjectIdentifier algorithmOid, Char[] password, Asn1Encodable pbeParameters);
    public static ICipherParameters GenerateCipherParameters(DerObjectIdentifier algorithmOid, Char[] password, bool wrongPkcs12Zero, Asn1Encodable pbeParameters);
    public static ICipherParameters GenerateCipherParameters(AlgorithmIdentifier algID, Char[] password);
    public static ICipherParameters GenerateCipherParameters(AlgorithmIdentifier algID, Char[] password, bool wrongPkcs12Zero);
    public static ICipherParameters GenerateCipherParameters(string algorithm, Char[] password, Asn1Encodable pbeParameters);
    public static ICipherParameters GenerateCipherParameters(string algorithm, Char[] password, bool wrongPkcs12Zero, Asn1Encodable pbeParameters);
    public static object CreateEngine(DerObjectIdentifier algorithmOid);
    public static object CreateEngine(AlgorithmIdentifier algID);
    public static object CreateEngine(string algorithm);
    public static string GetEncodingName(DerObjectIdentifier oid);
    private static ICipherParameters FixDesParity(string mechanism, ICipherParameters parameters);
}
public class Org.BouncyCastle.Security.PrivateKeyFactory : object {
    public static AsymmetricKeyParameter CreateKey(Byte[] privateKeyInfoData);
    public static AsymmetricKeyParameter CreateKey(Stream inStr);
    public static AsymmetricKeyParameter CreateKey(PrivateKeyInfo keyInfo);
    public static AsymmetricKeyParameter DecryptKey(Char[] passPhrase, EncryptedPrivateKeyInfo encInfo);
    public static AsymmetricKeyParameter DecryptKey(Char[] passPhrase, Byte[] encryptedPrivateKeyInfoData);
    public static AsymmetricKeyParameter DecryptKey(Char[] passPhrase, Stream encryptedPrivateKeyInfoStream);
    private static AsymmetricKeyParameter DecryptKey(Char[] passPhrase, Asn1Object asn1Object);
    public static Byte[] EncryptKey(DerObjectIdentifier algorithm, Char[] passPhrase, Byte[] salt, int iterationCount, AsymmetricKeyParameter key);
    public static Byte[] EncryptKey(string algorithm, Char[] passPhrase, Byte[] salt, int iterationCount, AsymmetricKeyParameter key);
}
public class Org.BouncyCastle.Security.PublicKeyFactory : object {
    public static AsymmetricKeyParameter CreateKey(Byte[] keyInfoData);
    public static AsymmetricKeyParameter CreateKey(Stream inStr);
    public static AsymmetricKeyParameter CreateKey(SubjectPublicKeyInfo keyInfo);
    private static bool IsPkcsDHParam(Asn1Sequence seq);
    private static DHPublicKeyParameters ReadPkcsDHParam(DerObjectIdentifier algOid, BigInteger y, Asn1Sequence seq);
}
public class Org.BouncyCastle.Security.SecureRandom : Random {
    private static IRandomGenerator sha1Generator;
    private static IRandomGenerator sha256Generator;
    private static SecureRandom[] master;
    protected IRandomGenerator generator;
    private static double DoubleScale;
    private static SecureRandom Master { get; }
    public SecureRandom(Byte[] inSeed);
    public SecureRandom(IRandomGenerator generator);
    private static SecureRandom();
    private static SecureRandom get_Master();
    public static SecureRandom GetInstance(string algorithm);
    public static Byte[] GetSeed(int length);
    public virtual Byte[] GenerateSeed(int length);
    public virtual void SetSeed(Byte[] inSeed);
    public virtual void SetSeed(long seed);
    public virtual int Next();
    public virtual int Next(int maxValue);
    public virtual int Next(int minValue, int maxValue);
    public virtual void NextBytes(Byte[] buffer);
    public virtual void NextBytes(Byte[] buffer, int start, int length);
    public virtual double NextDouble();
    public virtual int NextInt();
    public virtual long NextLong();
}
public class Org.BouncyCastle.Security.SecurityUtilityException : Exception {
    public SecurityUtilityException(string message);
    public SecurityUtilityException(string message, Exception exception);
}
public class Org.BouncyCastle.Security.SignatureException : GeneralSecurityException {
    public SignatureException(string message);
    public SignatureException(string message, Exception exception);
}
public class Org.BouncyCastle.Security.SignerUtilities : object {
    internal static IDictionary algorithms;
    internal static IDictionary oids;
    public static ICollection Algorithms { get; }
    private static SignerUtilities();
    public static DerObjectIdentifier GetObjectIdentifier(string mechanism);
    public static ICollection get_Algorithms();
    public static Asn1Encodable GetDefaultX509Parameters(DerObjectIdentifier id);
    public static Asn1Encodable GetDefaultX509Parameters(string algorithm);
    private static Asn1Encodable GetPssX509Parameters(string digestName);
    public static ISigner GetSigner(DerObjectIdentifier id);
    public static ISigner GetSigner(string algorithm);
    public static string GetEncodingName(DerObjectIdentifier oid);
}
public class Org.BouncyCastle.Security.WrapperUtilities : object {
    private static IDictionary algorithms;
    private static WrapperUtilities();
    public static IWrapper GetWrapper(DerObjectIdentifier oid);
    public static IWrapper GetWrapper(string algorithm);
    public static string GetAlgorithmName(DerObjectIdentifier oid);
}
public class Org.BouncyCastle.Tsp.GenTimeAccuracy : object {
    private Accuracy accuracy;
    public int Seconds { get; }
    public int Millis { get; }
    public int Micros { get; }
    public GenTimeAccuracy(Accuracy accuracy);
    public int get_Seconds();
    public int get_Millis();
    public int get_Micros();
    private int GetTimeComponent(DerInteger time);
    public virtual string ToString();
}
public class Org.BouncyCastle.Tsp.TimeStampRequest : X509ExtensionBase {
    private TimeStampReq req;
    private X509Extensions extensions;
    public int Version { get; }
    public string MessageImprintAlgOid { get; }
    public string ReqPolicy { get; }
    public BigInteger Nonce { get; }
    public bool CertReq { get; }
    internal X509Extensions Extensions { get; }
    public bool HasExtensions { get; }
    public TimeStampRequest(TimeStampReq req);
    public TimeStampRequest(Byte[] req);
    public TimeStampRequest(Stream input);
    private TimeStampRequest(Asn1InputStream str);
    public int get_Version();
    public string get_MessageImprintAlgOid();
    public Byte[] GetMessageImprintDigest();
    public string get_ReqPolicy();
    public BigInteger get_Nonce();
    public bool get_CertReq();
    public void Validate(IList algorithms, IList policies, IList extensions);
    public Byte[] GetEncoded();
    internal X509Extensions get_Extensions();
    public virtual bool get_HasExtensions();
    public virtual X509Extension GetExtension(DerObjectIdentifier oid);
    public virtual IList GetExtensionOids();
    protected virtual X509Extensions GetX509Extensions();
}
public class Org.BouncyCastle.Tsp.TimeStampRequestGenerator : object {
    private DerObjectIdentifier reqPolicy;
    private DerBoolean certReq;
    private IDictionary extensions;
    private IList extOrdering;
    public void SetReqPolicy(string reqPolicy);
    public void SetCertReq(bool certReq);
    [ObsoleteAttribute("Use method taking DerObjectIdentifier")]
public void AddExtension(string oid, bool critical, Asn1Encodable value);
    [ObsoleteAttribute("Use method taking DerObjectIdentifier")]
public void AddExtension(string oid, bool critical, Byte[] value);
    public virtual void AddExtension(DerObjectIdentifier oid, bool critical, Asn1Encodable extValue);
    public virtual void AddExtension(DerObjectIdentifier oid, bool critical, Byte[] extValue);
    public TimeStampRequest Generate(string digestAlgorithm, Byte[] digest);
    public TimeStampRequest Generate(string digestAlgorithmOid, Byte[] digest, BigInteger nonce);
    public virtual TimeStampRequest Generate(DerObjectIdentifier digestAlgorithm, Byte[] digest);
    public virtual TimeStampRequest Generate(DerObjectIdentifier digestAlgorithm, Byte[] digest, BigInteger nonce);
}
public class Org.BouncyCastle.Tsp.TimeStampResponse : object {
    private TimeStampResp resp;
    private TimeStampToken timeStampToken;
    public int Status { get; }
    public TimeStampToken TimeStampToken { get; }
    public TimeStampResponse(TimeStampResp resp);
    public TimeStampResponse(Byte[] resp);
    public TimeStampResponse(Stream input);
    private static TimeStampResp readTimeStampResp(Asn1InputStream input);
    public int get_Status();
    public string GetStatusString();
    public PkiFailureInfo GetFailInfo();
    public TimeStampToken get_TimeStampToken();
    public void Validate(TimeStampRequest request);
    public Byte[] GetEncoded();
}
public class Org.BouncyCastle.Tsp.TimeStampResponseGenerator : object {
    private PkiStatus status;
    private Asn1EncodableVector statusStrings;
    private int failInfo;
    private TimeStampTokenGenerator tokenGenerator;
    private IList acceptedAlgorithms;
    private IList acceptedPolicies;
    private IList acceptedExtensions;
    public TimeStampResponseGenerator(TimeStampTokenGenerator tokenGenerator, IList acceptedAlgorithms);
    public TimeStampResponseGenerator(TimeStampTokenGenerator tokenGenerator, IList acceptedAlgorithms, IList acceptedPolicy);
    public TimeStampResponseGenerator(TimeStampTokenGenerator tokenGenerator, IList acceptedAlgorithms, IList acceptedPolicies, IList acceptedExtensions);
    private void AddStatusString(string statusString);
    private void SetFailInfoField(int field);
    private PkiStatusInfo GetPkiStatusInfo();
    public TimeStampResponse Generate(TimeStampRequest request, BigInteger serialNumber, DateTime genTime);
    public TimeStampResponse Generate(TimeStampRequest request, BigInteger serialNumber, DateTimeObject genTime);
    public TimeStampResponse GenerateFailResponse(PkiStatus status, int failInfoField, string statusString);
}
public class Org.BouncyCastle.Tsp.TimeStampToken : object {
    private CmsSignedData tsToken;
    private SignerInformation tsaSignerInfo;
    private TimeStampTokenInfo tstInfo;
    private CertID certID;
    public TimeStampTokenInfo TimeStampInfo { get; }
    public SignerID SignerID { get; }
    public AttributeTable SignedAttributes { get; }
    public AttributeTable UnsignedAttributes { get; }
    public TimeStampToken(ContentInfo contentInfo);
    public TimeStampToken(CmsSignedData signedData);
    public TimeStampTokenInfo get_TimeStampInfo();
    public SignerID get_SignerID();
    public AttributeTable get_SignedAttributes();
    public AttributeTable get_UnsignedAttributes();
    public IX509Store GetCertificates(string type);
    public IX509Store GetCrls(string type);
    public IX509Store GetAttributeCertificates(string type);
    public void Validate(X509Certificate cert);
    public CmsSignedData ToCmsSignedData();
    public Byte[] GetEncoded();
}
public class Org.BouncyCastle.Tsp.TimeStampTokenGenerator : object {
    private int accuracySeconds;
    private int accuracyMillis;
    private int accuracyMicros;
    private bool ordering;
    private GeneralName tsa;
    private string tsaPolicyOID;
    private AsymmetricKeyParameter key;
    private X509Certificate cert;
    private string digestOID;
    private AttributeTable signedAttr;
    private AttributeTable unsignedAttr;
    private IX509Store x509Certs;
    private IX509Store x509Crls;
    public TimeStampTokenGenerator(AsymmetricKeyParameter key, X509Certificate cert, string digestOID, string tsaPolicyOID);
    public TimeStampTokenGenerator(AsymmetricKeyParameter key, X509Certificate cert, string digestOID, string tsaPolicyOID, AttributeTable signedAttr, AttributeTable unsignedAttr);
    public void SetCertificates(IX509Store certificates);
    public void SetCrls(IX509Store crls);
    public void SetAccuracySeconds(int accuracySeconds);
    public void SetAccuracyMillis(int accuracyMillis);
    public void SetAccuracyMicros(int accuracyMicros);
    public void SetOrdering(bool ordering);
    public void SetTsa(GeneralName tsa);
    public TimeStampToken Generate(TimeStampRequest request, BigInteger serialNumber, DateTime genTime);
}
public class Org.BouncyCastle.Tsp.TimeStampTokenInfo : object {
    private TstInfo tstInfo;
    private DateTime genTime;
    public bool IsOrdered { get; }
    public Accuracy Accuracy { get; }
    public DateTime GenTime { get; }
    public GenTimeAccuracy GenTimeAccuracy { get; }
    public string Policy { get; }
    public BigInteger SerialNumber { get; }
    public GeneralName Tsa { get; }
    public BigInteger Nonce { get; }
    public AlgorithmIdentifier HashAlgorithm { get; }
    public string MessageImprintAlgOid { get; }
    public TstInfo TstInfo { get; }
    public TimeStampTokenInfo(TstInfo tstInfo);
    public bool get_IsOrdered();
    public Accuracy get_Accuracy();
    public DateTime get_GenTime();
    public GenTimeAccuracy get_GenTimeAccuracy();
    public string get_Policy();
    public BigInteger get_SerialNumber();
    public GeneralName get_Tsa();
    public BigInteger get_Nonce();
    public AlgorithmIdentifier get_HashAlgorithm();
    public string get_MessageImprintAlgOid();
    public Byte[] GetMessageImprintDigest();
    public Byte[] GetEncoded();
    public TstInfo get_TstInfo();
}
public abstract class Org.BouncyCastle.Tsp.TspAlgorithms : object {
    public static string MD5;
    public static string Sha1;
    public static string Sha224;
    public static string Sha256;
    public static string Sha384;
    public static string Sha512;
    public static string RipeMD128;
    public static string RipeMD160;
    public static string RipeMD256;
    public static string Gost3411;
    public static IList Allowed;
    private static TspAlgorithms();
}
public class Org.BouncyCastle.Tsp.TspException : Exception {
    public TspException(string message);
    public TspException(string message, Exception e);
}
public class Org.BouncyCastle.Tsp.TspUtil : object {
    private static ISet EmptySet;
    private static IList EmptyList;
    private static IDictionary digestLengths;
    private static IDictionary digestNames;
    private static TspUtil();
    public static ICollection GetSignatureTimestamps(SignerInformation signerInfo);
    public static void ValidateCertificate(X509Certificate cert);
    internal static string GetDigestAlgName(string digestAlgOID);
    internal static int GetDigestLength(string digestAlgOID);
    internal static IDigest CreateDigestInstance(string digestAlgOID);
    internal static ISet GetCriticalExtensionOids(X509Extensions extensions);
    internal static ISet GetNonCriticalExtensionOids(X509Extensions extensions);
    internal static IList GetExtensionOids(X509Extensions extensions);
}
public class Org.BouncyCastle.Tsp.TspValidationException : TspException {
    private int failureCode;
    public int FailureCode { get; }
    public TspValidationException(string message);
    public TspValidationException(string message, int failureCode);
    public int get_FailureCode();
}
public class Org.BouncyCastle.Utilities.Arrays : object {
    public static bool AreEqual(Boolean[] a, Boolean[] b);
    public static bool AreEqual(Char[] a, Char[] b);
    public static bool AreEqual(Byte[] a, Byte[] b);
    [ObsoleteAttribute("Use 'AreEqual' method instead")]
public static bool AreSame(Byte[] a, Byte[] b);
    public static bool ConstantTimeAreEqual(Byte[] a, Byte[] b);
    public static bool AreEqual(Int32[] a, Int32[] b);
    private static bool HaveSameContents(Boolean[] a, Boolean[] b);
    private static bool HaveSameContents(Char[] a, Char[] b);
    private static bool HaveSameContents(Byte[] a, Byte[] b);
    private static bool HaveSameContents(Int32[] a, Int32[] b);
    public static string ToString(Object[] a);
    public static int GetHashCode(Byte[] data);
    public static Byte[] Clone(Byte[] data);
    public static Int32[] Clone(Int32[] data);
    public static void Fill(Byte[] buf, byte b);
    public static Byte[] Copy(Byte[] data, int off, int len);
}
public class Org.BouncyCastle.Utilities.BigIntegers : object {
    private static int MaxIterations;
    public static Byte[] AsUnsignedByteArray(BigInteger n);
    public static Byte[] AsUnsignedByteArray(int length, BigInteger n);
    public static BigInteger CreateRandomInRange(BigInteger min, BigInteger max, SecureRandom random);
}
public class Org.BouncyCastle.Utilities.Collections.CollectionUtilities : object {
    public static void AddRange(IList to, ICollection range);
    public static bool CheckElementsAreOfType(IEnumerable e, Type t);
    public static IDictionary ReadOnly(IDictionary d);
    public static IList ReadOnly(IList l);
    public static ISet ReadOnly(ISet s);
    public static string ToString(IEnumerable c);
}
public class Org.BouncyCastle.Utilities.Collections.EmptyEnumerable : object {
    public static IEnumerable Instance;
    private static EmptyEnumerable();
    public sealed virtual IEnumerator GetEnumerator();
}
public class Org.BouncyCastle.Utilities.Collections.EmptyEnumerator : object {
    public static IEnumerator Instance;
    public object Current { get; }
    private static EmptyEnumerator();
    public sealed virtual bool MoveNext();
    public sealed virtual void Reset();
    public sealed virtual object get_Current();
}
public class Org.BouncyCastle.Utilities.Collections.EnumerableProxy : object {
    private IEnumerable inner;
    public EnumerableProxy(IEnumerable inner);
    public sealed virtual IEnumerator GetEnumerator();
}
public class Org.BouncyCastle.Utilities.Collections.HashSet : object {
    private IDictionary impl;
    public int Count { get; }
    public bool IsEmpty { get; }
    public bool IsFixedSize { get; }
    public bool IsReadOnly { get; }
    public bool IsSynchronized { get; }
    public object SyncRoot { get; }
    public HashSet(IEnumerable s);
    public virtual void Add(object o);
    public virtual void AddAll(IEnumerable e);
    public virtual void Clear();
    public virtual bool Contains(object o);
    public virtual void CopyTo(Array array, int index);
    public virtual int get_Count();
    public virtual IEnumerator GetEnumerator();
    public virtual bool get_IsEmpty();
    public virtual bool get_IsFixedSize();
    public virtual bool get_IsReadOnly();
    public virtual bool get_IsSynchronized();
    public virtual void Remove(object o);
    public virtual void RemoveAll(IEnumerable e);
    public virtual object get_SyncRoot();
}
public interface Org.BouncyCastle.Utilities.Collections.ISet {
    public bool IsEmpty { get; }
    public bool IsFixedSize { get; }
    public bool IsReadOnly { get; }
    public abstract virtual void Add(object o);
    public abstract virtual void AddAll(IEnumerable e);
    public abstract virtual void Clear();
    public abstract virtual bool Contains(object o);
    public abstract virtual bool get_IsEmpty();
    public abstract virtual bool get_IsFixedSize();
    public abstract virtual bool get_IsReadOnly();
    public abstract virtual void Remove(object o);
    public abstract virtual void RemoveAll(IEnumerable e);
}
[DefaultMemberAttribute("Item")]
public class Org.BouncyCastle.Utilities.Collections.LinkedDictionary : object {
    internal IDictionary hash;
    internal IList keys;
    public int Count { get; }
    public bool IsFixedSize { get; }
    public bool IsReadOnly { get; }
    public bool IsSynchronized { get; }
    public object SyncRoot { get; }
    public ICollection Keys { get; }
    public ICollection Values { get; }
    public object Item { get; public set; }
    public virtual void Add(object k, object v);
    public virtual void Clear();
    public virtual bool Contains(object k);
    public virtual void CopyTo(Array array, int index);
    public virtual int get_Count();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    public virtual IDictionaryEnumerator GetEnumerator();
    public virtual void Remove(object k);
    public virtual bool get_IsFixedSize();
    public virtual bool get_IsReadOnly();
    public virtual bool get_IsSynchronized();
    public virtual object get_SyncRoot();
    public virtual ICollection get_Keys();
    public virtual ICollection get_Values();
    public virtual object get_Item(object k);
    public virtual void set_Item(object k, object value);
}
internal class Org.BouncyCastle.Utilities.Collections.LinkedDictionaryEnumerator : object {
    private LinkedDictionary parent;
    private int pos;
    public object Current { get; }
    public DictionaryEntry Entry { get; }
    public object Key { get; }
    public object Value { get; }
    private object CurrentKey { get; }
    internal LinkedDictionaryEnumerator(LinkedDictionary parent);
    public virtual object get_Current();
    public virtual DictionaryEntry get_Entry();
    public virtual object get_Key();
    public virtual bool MoveNext();
    public virtual void Reset();
    public virtual object get_Value();
    private object get_CurrentKey();
}
[DefaultMemberAttribute("Item")]
public abstract class Org.BouncyCastle.Utilities.Collections.UnmodifiableDictionary : object {
    public int Count { get; }
    public bool IsFixedSize { get; }
    public bool IsReadOnly { get; }
    public bool IsSynchronized { get; }
    public object SyncRoot { get; }
    public ICollection Keys { get; }
    public ICollection Values { get; }
    public object Item { get; public set; }
    public virtual void Add(object k, object v);
    public virtual void Clear();
    public abstract virtual bool Contains(object k);
    public abstract virtual void CopyTo(Array array, int index);
    public abstract virtual int get_Count();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    public abstract virtual IDictionaryEnumerator GetEnumerator();
    public virtual void Remove(object k);
    public abstract virtual bool get_IsFixedSize();
    public virtual bool get_IsReadOnly();
    public abstract virtual bool get_IsSynchronized();
    public abstract virtual object get_SyncRoot();
    public abstract virtual ICollection get_Keys();
    public abstract virtual ICollection get_Values();
    public virtual object get_Item(object k);
    public virtual void set_Item(object k, object value);
    protected abstract virtual object GetValue(object k);
}
public class Org.BouncyCastle.Utilities.Collections.UnmodifiableDictionaryProxy : UnmodifiableDictionary {
    private IDictionary d;
    public int Count { get; }
    public bool IsFixedSize { get; }
    public bool IsSynchronized { get; }
    public object SyncRoot { get; }
    public ICollection Keys { get; }
    public ICollection Values { get; }
    public UnmodifiableDictionaryProxy(IDictionary d);
    public virtual bool Contains(object k);
    public virtual void CopyTo(Array array, int index);
    public virtual int get_Count();
    public virtual IDictionaryEnumerator GetEnumerator();
    public virtual bool get_IsFixedSize();
    public virtual bool get_IsSynchronized();
    public virtual object get_SyncRoot();
    public virtual ICollection get_Keys();
    public virtual ICollection get_Values();
    protected virtual object GetValue(object k);
}
[DefaultMemberAttribute("Item")]
public abstract class Org.BouncyCastle.Utilities.Collections.UnmodifiableList : object {
    public int Count { get; }
    public bool IsFixedSize { get; }
    public bool IsReadOnly { get; }
    public bool IsSynchronized { get; }
    public object SyncRoot { get; }
    public object Item { get; public set; }
    public virtual int Add(object o);
    public virtual void Clear();
    public abstract virtual bool Contains(object o);
    public abstract virtual void CopyTo(Array array, int index);
    public abstract virtual int get_Count();
    public abstract virtual IEnumerator GetEnumerator();
    public abstract virtual int IndexOf(object o);
    public virtual void Insert(int i, object o);
    public abstract virtual bool get_IsFixedSize();
    public virtual bool get_IsReadOnly();
    public abstract virtual bool get_IsSynchronized();
    public virtual void Remove(object o);
    public virtual void RemoveAt(int i);
    public abstract virtual object get_SyncRoot();
    public virtual object get_Item(int i);
    public virtual void set_Item(int i, object value);
    protected abstract virtual object GetValue(int i);
}
public class Org.BouncyCastle.Utilities.Collections.UnmodifiableListProxy : UnmodifiableList {
    private IList l;
    public int Count { get; }
    public bool IsFixedSize { get; }
    public bool IsSynchronized { get; }
    public object SyncRoot { get; }
    public UnmodifiableListProxy(IList l);
    public virtual bool Contains(object o);
    public virtual void CopyTo(Array array, int index);
    public virtual int get_Count();
    public virtual IEnumerator GetEnumerator();
    public virtual int IndexOf(object o);
    public virtual bool get_IsFixedSize();
    public virtual bool get_IsSynchronized();
    public virtual object get_SyncRoot();
    protected virtual object GetValue(int i);
}
public abstract class Org.BouncyCastle.Utilities.Collections.UnmodifiableSet : object {
    public int Count { get; }
    public bool IsEmpty { get; }
    public bool IsFixedSize { get; }
    public bool IsReadOnly { get; }
    public bool IsSynchronized { get; }
    public object SyncRoot { get; }
    public virtual void Add(object o);
    public virtual void AddAll(IEnumerable e);
    public virtual void Clear();
    public abstract virtual bool Contains(object o);
    public abstract virtual void CopyTo(Array array, int index);
    public abstract virtual int get_Count();
    public abstract virtual IEnumerator GetEnumerator();
    public abstract virtual bool get_IsEmpty();
    public abstract virtual bool get_IsFixedSize();
    public virtual bool get_IsReadOnly();
    public abstract virtual bool get_IsSynchronized();
    public abstract virtual object get_SyncRoot();
    public virtual void Remove(object o);
    public virtual void RemoveAll(IEnumerable e);
}
public class Org.BouncyCastle.Utilities.Collections.UnmodifiableSetProxy : UnmodifiableSet {
    private ISet s;
    public int Count { get; }
    public bool IsEmpty { get; }
    public bool IsFixedSize { get; }
    public bool IsSynchronized { get; }
    public object SyncRoot { get; }
    public UnmodifiableSetProxy(ISet s);
    public virtual bool Contains(object o);
    public virtual void CopyTo(Array array, int index);
    public virtual int get_Count();
    public virtual IEnumerator GetEnumerator();
    public virtual bool get_IsEmpty();
    public virtual bool get_IsFixedSize();
    public virtual bool get_IsSynchronized();
    public virtual object get_SyncRoot();
}
public class Org.BouncyCastle.Utilities.Date.DateTimeObject : object {
    private DateTime dt;
    public DateTime Value { get; }
    public DateTimeObject(DateTime dt);
    public DateTime get_Value();
    public virtual string ToString();
}
public class Org.BouncyCastle.Utilities.Date.DateTimeUtilities : object {
    public static DateTime UnixEpoch;
    private static DateTimeUtilities();
    public static long DateTimeToUnixMs(DateTime dateTime);
    public static DateTime UnixMsToDateTime(long unixMs);
    public static long CurrentUnixMs();
}
public class Org.BouncyCastle.Utilities.Encoders.Base64 : object {
    public static string ToBase64String(Byte[] data);
    public static string ToBase64String(Byte[] data, int off, int length);
    public static Byte[] Encode(Byte[] data);
    public static Byte[] Encode(Byte[] data, int off, int length);
    public static int Encode(Byte[] data, Stream outStream);
    public static int Encode(Byte[] data, int off, int length, Stream outStream);
    public static Byte[] Decode(Byte[] data);
    public static Byte[] Decode(string data);
    public static int Decode(string data, Stream outStream);
}
public class Org.BouncyCastle.Utilities.Encoders.Base64Encoder : object {
    protected Byte[] encodingTable;
    protected byte padding;
    protected Byte[] decodingTable;
    protected void InitialiseDecodingTable();
    public sealed virtual int Encode(Byte[] data, int off, int length, Stream outStream);
    private bool ignore(char c);
    public sealed virtual int Decode(Byte[] data, int off, int length, Stream outStream);
    private int nextI(Byte[] data, int i, int finish);
    public sealed virtual int DecodeString(string data, Stream outStream);
    private int decodeLastBlock(Stream outStream, char c1, char c2, char c3, char c4);
    private int nextI(string data, int i, int finish);
}
public class Org.BouncyCastle.Utilities.Encoders.BufferedDecoder : object {
    internal Byte[] buffer;
    internal int bufOff;
    internal ITranslator translator;
    public BufferedDecoder(ITranslator translator, int bufferSize);
    public int ProcessByte(byte input, Byte[] output, int outOff);
    public int ProcessBytes(Byte[] input, int inOff, int len, Byte[] outBytes, int outOff);
}
public class Org.BouncyCastle.Utilities.Encoders.BufferedEncoder : object {
    internal Byte[] Buffer;
    internal int bufOff;
    internal ITranslator translator;
    public BufferedEncoder(ITranslator translator, int bufferSize);
    public int ProcessByte(byte input, Byte[] outBytes, int outOff);
    public int ProcessBytes(Byte[] input, int inOff, int len, Byte[] outBytes, int outOff);
}
public class Org.BouncyCastle.Utilities.Encoders.Hex : object {
    private static IEncoder encoder;
    private static Hex();
    public static string ToHexString(Byte[] data);
    public static string ToHexString(Byte[] data, int off, int length);
    public static Byte[] Encode(Byte[] data);
    public static Byte[] Encode(Byte[] data, int off, int length);
    public static int Encode(Byte[] data, Stream outStream);
    public static int Encode(Byte[] data, int off, int length, Stream outStream);
    public static Byte[] Decode(Byte[] data);
    public static Byte[] Decode(string data);
    public static int Decode(string data, Stream outStream);
}
public class Org.BouncyCastle.Utilities.Encoders.HexEncoder : object {
    private static Byte[] encodingTable;
    private static Byte[] decodingTable;
    private static HexEncoder();
    private static Byte[] ConstructDecodingTable(Byte[] et);
    public sealed virtual int Encode(Byte[] data, int off, int length, Stream outStream);
    private static bool Ignore(char c);
    public sealed virtual int Decode(Byte[] data, int off, int length, Stream outStream);
    public sealed virtual int DecodeString(string data, Stream outStream);
}
public class Org.BouncyCastle.Utilities.Encoders.HexTranslator : object {
    private static Byte[] hexTable;
    private static HexTranslator();
    public sealed virtual int GetEncodedBlockSize();
    public sealed virtual int Encode(Byte[] input, int inOff, int length, Byte[] outBytes, int outOff);
    public sealed virtual int GetDecodedBlockSize();
    public sealed virtual int Decode(Byte[] input, int inOff, int length, Byte[] outBytes, int outOff);
}
public interface Org.BouncyCastle.Utilities.Encoders.IEncoder {
    public abstract virtual int Encode(Byte[] data, int off, int length, Stream outStream);
    public abstract virtual int Decode(Byte[] data, int off, int length, Stream outStream);
    public abstract virtual int DecodeString(string data, Stream outStream);
}
public interface Org.BouncyCastle.Utilities.Encoders.ITranslator {
    public abstract virtual int GetEncodedBlockSize();
    public abstract virtual int Encode(Byte[] input, int inOff, int length, Byte[] outBytes, int outOff);
    public abstract virtual int GetDecodedBlockSize();
    public abstract virtual int Decode(Byte[] input, int inOff, int length, Byte[] outBytes, int outOff);
}
public class Org.BouncyCastle.Utilities.Encoders.UrlBase64 : object {
    private static IEncoder encoder;
    private static UrlBase64();
    public static Byte[] Encode(Byte[] data);
    public static int Encode(Byte[] data, Stream outStr);
    public static Byte[] Decode(Byte[] data);
    public static int Decode(Byte[] data, Stream outStr);
    public static Byte[] Decode(string data);
    public static int Decode(string data, Stream outStr);
}
public class Org.BouncyCastle.Utilities.Encoders.UrlBase64Encoder : Base64Encoder {
}
internal class Org.BouncyCastle.Utilities.Enums : object {
    internal static Enum GetEnumValue(Type enumType, string s);
    internal static Array GetEnumValues(Type enumType);
    internal static Enum GetArbitraryValue(Type enumType);
}
public abstract class Org.BouncyCastle.Utilities.IO.BaseInputStream : Stream {
    private bool closed;
    public bool CanRead { get; }
    public bool CanSeek { get; }
    public bool CanWrite { get; }
    public long Length { get; }
    public long Position { get; public set; }
    public sealed virtual bool get_CanRead();
    public sealed virtual bool get_CanSeek();
    public sealed virtual bool get_CanWrite();
    public virtual void Close();
    public sealed virtual void Flush();
    public sealed virtual long get_Length();
    public sealed virtual long get_Position();
    public sealed virtual void set_Position(long value);
    public virtual int Read(Byte[] buffer, int offset, int count);
    public sealed virtual long Seek(long offset, SeekOrigin origin);
    public sealed virtual void SetLength(long value);
    public sealed virtual void Write(Byte[] buffer, int offset, int count);
}
public abstract class Org.BouncyCastle.Utilities.IO.BaseOutputStream : Stream {
    private bool closed;
    public bool CanRead { get; }
    public bool CanSeek { get; }
    public bool CanWrite { get; }
    public long Length { get; }
    public long Position { get; public set; }
    public sealed virtual bool get_CanRead();
    public sealed virtual bool get_CanSeek();
    public sealed virtual bool get_CanWrite();
    public virtual void Close();
    public virtual void Flush();
    public sealed virtual long get_Length();
    public sealed virtual long get_Position();
    public sealed virtual void set_Position(long value);
    public sealed virtual int Read(Byte[] buffer, int offset, int count);
    public sealed virtual long Seek(long offset, SeekOrigin origin);
    public sealed virtual void SetLength(long value);
    public virtual void Write(Byte[] buffer, int offset, int count);
    public virtual void Write(Byte[] buffer);
}
public class Org.BouncyCastle.Utilities.IO.Pem.PemGenerationException : Exception {
    public PemGenerationException(string message);
    public PemGenerationException(string message, Exception exception);
}
public class Org.BouncyCastle.Utilities.IO.Pem.PemHeader : object {
    private string name;
    private string val;
    public string Name { get; }
    public string Value { get; }
    public PemHeader(string name, string val);
    public virtual string get_Name();
    public virtual string get_Value();
    public virtual int GetHashCode();
    public virtual bool Equals(object obj);
    private int GetHashCode(string s);
}
public class Org.BouncyCastle.Utilities.IO.Pem.PemObject : object {
    private string type;
    private IList headers;
    private Byte[] content;
    public string Type { get; }
    public IList Headers { get; }
    public Byte[] Content { get; }
    public PemObject(string type, Byte[] content);
    public PemObject(string type, IList headers, Byte[] content);
    public string get_Type();
    public IList get_Headers();
    public Byte[] get_Content();
    public sealed virtual PemObject Generate();
}
public interface Org.BouncyCastle.Utilities.IO.Pem.PemObjectGenerator {
    public abstract virtual PemObject Generate();
}
public interface Org.BouncyCastle.Utilities.IO.Pem.PemObjectParser {
    public abstract virtual object ParseObject(PemObject obj);
}
public class Org.BouncyCastle.Utilities.IO.Pem.PemReader : object {
    private static string BeginString;
    private static string EndString;
    private TextReader reader;
    public TextReader Reader { get; }
    public PemReader(TextReader reader);
    public TextReader get_Reader();
    public PemObject ReadPemObject();
    private PemObject LoadObject(string type);
}
public class Org.BouncyCastle.Utilities.IO.Pem.PemWriter : object {
    private static int LineLength;
    private TextWriter writer;
    private int nlLength;
    private Char[] buf;
    public TextWriter Writer { get; }
    public PemWriter(TextWriter writer);
    public TextWriter get_Writer();
    public int GetOutputSize(PemObject obj);
    public void WriteObject(PemObjectGenerator objGen);
    private void WriteEncoded(Byte[] bytes);
    private void WritePreEncapsulationBoundary(string type);
    private void WritePostEncapsulationBoundary(string type);
}
public class Org.BouncyCastle.Utilities.IO.PushbackStream : FilterStream {
    private int buf;
    public PushbackStream(Stream s);
    public virtual int ReadByte();
    public virtual int Read(Byte[] buffer, int offset, int count);
    public virtual void Unread(int b);
}
public class Org.BouncyCastle.Utilities.IO.StreamOverflowException : IOException {
    public StreamOverflowException(string message);
    public StreamOverflowException(string message, Exception exception);
}
public class Org.BouncyCastle.Utilities.IO.Streams : object {
    private static int BufferSize;
    public static void Drain(Stream inStr);
    public static Byte[] ReadAll(Stream inStr);
    public static Byte[] ReadAllLimited(Stream inStr, int limit);
    public static int ReadFully(Stream inStr, Byte[] buf);
    public static int ReadFully(Stream inStr, Byte[] buf, int off, int len);
    public static void PipeAll(Stream inStr, Stream outStr);
    public static long PipeAllLimited(Stream inStr, long limit, Stream outStr);
}
public class Org.BouncyCastle.Utilities.IO.TeeInputStream : BaseInputStream {
    private Stream input;
    private Stream tee;
    public TeeInputStream(Stream input, Stream tee);
    public virtual void Close();
    public virtual int Read(Byte[] buf, int off, int len);
    public virtual int ReadByte();
}
public class Org.BouncyCastle.Utilities.IO.TeeOutputStream : BaseOutputStream {
    private Stream output;
    private Stream tee;
    public TeeOutputStream(Stream output, Stream tee);
    public virtual void Close();
    public virtual void Write(Byte[] buffer, int offset, int count);
    public virtual void WriteByte(byte b);
}
public class Org.BouncyCastle.Utilities.Net.IPAddress : object {
    public static bool IsValid(string address);
    public static bool IsValidWithNetMask(string address);
    public static bool IsValidIPv4(string address);
    private static bool unsafeIsValidIPv4(string address);
    public static bool IsValidIPv4WithNetmask(string address);
    public static bool IsValidIPv6WithNetmask(string address);
    private static bool IsMaskValue(string component, int size);
    public static bool IsValidIPv6(string address);
    private static bool unsafeIsValidIPv6(string address);
}
internal class Org.BouncyCastle.Utilities.Platform : object {
    internal static string NewLine;
    private static Platform();
    private static string GetNewLine();
    internal static int CompareIgnoreCase(string a, string b);
    internal static string GetEnvironmentVariable(string variable);
    internal static Exception CreateNotImplementedException(string message);
    internal static IList CreateArrayList();
    internal static IList CreateArrayList(int capacity);
    internal static IList CreateArrayList(ICollection collection);
    internal static IList CreateArrayList(IEnumerable collection);
    internal static IDictionary CreateHashtable();
    internal static IDictionary CreateHashtable(int capacity);
    internal static IDictionary CreateHashtable(IDictionary dictionary);
    internal static string ToLowerInvariant(string s);
    internal static string ToUpperInvariant(string s);
}
public class Org.BouncyCastle.Utilities.Strings : object {
    internal static bool IsOneOf(string s, String[] candidates);
    public static string FromByteArray(Byte[] bs);
    public static Byte[] ToByteArray(Char[] cs);
    public static Byte[] ToByteArray(string s);
    public static string FromAsciiByteArray(Byte[] bytes);
    public static Byte[] ToAsciiByteArray(Char[] cs);
    public static Byte[] ToAsciiByteArray(string s);
    public static string FromUtf8ByteArray(Byte[] bytes);
    public static Byte[] ToUtf8ByteArray(Char[] cs);
    public static Byte[] ToUtf8ByteArray(string s);
}
internal class Org.BouncyCastle.Utilities.Zlib.Adler32 : object {
    private static int BASE;
    private static int NMAX;
    internal long adler32(long adler, Byte[] buf, int index, int len);
}
public class Org.BouncyCastle.Utilities.Zlib.Deflate : object {
    private static int MAX_MEM_LEVEL;
    private static int Z_DEFAULT_COMPRESSION;
    private static int MAX_WBITS;
    private static int DEF_MEM_LEVEL;
    private static int STORED;
    private static int FAST;
    private static int SLOW;
    private static int NeedMore;
    private static int BlockDone;
    private static int FinishStarted;
    private static int FinishDone;
    private static int PRESET_DICT;
    private static int Z_FILTERED;
    private static int Z_HUFFMAN_ONLY;
    private static int Z_DEFAULT_STRATEGY;
    private static int Z_NO_FLUSH;
    private static int Z_PARTIAL_FLUSH;
    private static int Z_SYNC_FLUSH;
    private static int Z_FULL_FLUSH;
    private static int Z_FINISH;
    private static int Z_OK;
    private static int Z_STREAM_END;
    private static int Z_NEED_DICT;
    private static int Z_ERRNO;
    private static int Z_STREAM_ERROR;
    private static int Z_DATA_ERROR;
    private static int Z_MEM_ERROR;
    private static int Z_BUF_ERROR;
    private static int Z_VERSION_ERROR;
    private static int INIT_STATE;
    private static int BUSY_STATE;
    private static int FINISH_STATE;
    private static int Z_DEFLATED;
    private static int STORED_BLOCK;
    private static int STATIC_TREES;
    private static int DYN_TREES;
    private static int Z_BINARY;
    private static int Z_ASCII;
    private static int Z_UNKNOWN;
    private static int Buf_size;
    private static int REP_3_6;
    private static int REPZ_3_10;
    private static int REPZ_11_138;
    private static int MIN_MATCH;
    private static int MAX_MATCH;
    private static int MIN_LOOKAHEAD;
    private static int MAX_BITS;
    private static int D_CODES;
    private static int BL_CODES;
    private static int LENGTH_CODES;
    private static int LITERALS;
    private static int L_CODES;
    private static int HEAP_SIZE;
    private static int END_BLOCK;
    private static Config[] config_table;
    private static String[] z_errmsg;
    internal ZStream strm;
    internal int status;
    internal Byte[] pending_buf;
    internal int pending_buf_size;
    internal int pending_out;
    internal int pending;
    internal int noheader;
    internal byte data_type;
    internal byte method;
    internal int last_flush;
    internal int w_size;
    internal int w_bits;
    internal int w_mask;
    internal Byte[] window;
    internal int window_size;
    internal Int16[] prev;
    internal Int16[] head;
    internal int ins_h;
    internal int hash_size;
    internal int hash_bits;
    internal int hash_mask;
    internal int hash_shift;
    internal int block_start;
    internal int match_length;
    internal int prev_match;
    internal int match_available;
    internal int strstart;
    internal int match_start;
    internal int lookahead;
    internal int prev_length;
    internal int max_chain_length;
    internal int max_lazy_match;
    internal int level;
    internal int strategy;
    internal int good_match;
    internal int nice_match;
    internal Int16[] dyn_ltree;
    internal Int16[] dyn_dtree;
    internal Int16[] bl_tree;
    internal Tree l_desc;
    internal Tree d_desc;
    internal Tree bl_desc;
    internal Int16[] bl_count;
    internal Int32[] heap;
    internal int heap_len;
    internal int heap_max;
    internal Byte[] depth;
    internal int l_buf;
    internal int lit_bufsize;
    internal int last_lit;
    internal int d_buf;
    internal int opt_len;
    internal int static_len;
    internal int matches;
    internal int last_eob_len;
    internal UInt32 bi_buf;
    internal int bi_valid;
    private static Deflate();
    internal void lm_init();
    internal void tr_init();
    internal void init_block();
    internal void pqdownheap(Int16[] tree, int k);
    internal static bool smaller(Int16[] tree, int n, int m, Byte[] depth);
    internal void scan_tree(Int16[] tree, int max_code);
    internal int build_bl_tree();
    internal void send_all_trees(int lcodes, int dcodes, int blcodes);
    internal void send_tree(Int16[] tree, int max_code);
    internal void put_byte(Byte[] p, int start, int len);
    internal void put_byte(byte c);
    internal void put_short(int w);
    internal void putShortMSB(int b);
    internal void send_code(int c, Int16[] tree);
    internal void send_bits(int val, int length);
    internal void _tr_align();
    internal bool _tr_tally(int dist, int lc);
    internal void compress_block(Int16[] ltree, Int16[] dtree);
    internal void set_data_type();
    internal void bi_flush();
    internal void bi_windup();
    internal void copy_block(int buf, int len, bool header);
    internal void flush_block_only(bool eof);
    internal int deflate_stored(int flush);
    internal void _tr_stored_block(int buf, int stored_len, bool eof);
    internal void _tr_flush_block(int buf, int stored_len, bool eof);
    internal void fill_window();
    internal int deflate_fast(int flush);
    internal int deflate_slow(int flush);
    internal int longest_match(int cur_match);
    internal int deflateInit(ZStream strm, int level, int bits);
    internal int deflateInit(ZStream strm, int level);
    internal int deflateInit2(ZStream strm, int level, int method, int windowBits, int memLevel, int strategy);
    internal int deflateReset(ZStream strm);
    internal int deflateEnd();
    internal int deflateParams(ZStream strm, int _level, int _strategy);
    internal int deflateSetDictionary(ZStream strm, Byte[] dictionary, int dictLength);
    internal int deflate(ZStream strm, int flush);
}
internal class Org.BouncyCastle.Utilities.Zlib.InfBlocks : object {
    private static int MANY;
    private static int Z_OK;
    private static int Z_STREAM_END;
    private static int Z_NEED_DICT;
    private static int Z_ERRNO;
    private static int Z_STREAM_ERROR;
    private static int Z_DATA_ERROR;
    private static int Z_MEM_ERROR;
    private static int Z_BUF_ERROR;
    private static int Z_VERSION_ERROR;
    private static int TYPE;
    private static int LENS;
    private static int STORED;
    private static int TABLE;
    private static int BTREE;
    private static int DTREE;
    private static int CODES;
    private static int DRY;
    private static int DONE;
    private static int BAD;
    private static Int32[] inflate_mask;
    private static Int32[] border;
    internal int mode;
    internal int left;
    internal int table;
    internal int index;
    internal Int32[] blens;
    internal Int32[] bb;
    internal Int32[] tb;
    internal InfCodes codes;
    private int last;
    internal int bitk;
    internal int bitb;
    internal Int32[] hufts;
    internal Byte[] window;
    internal int end;
    internal int read;
    internal int write;
    internal object checkfn;
    internal long check;
    internal InfTree inftree;
    internal InfBlocks(ZStream z, object checkfn, int w);
    private static InfBlocks();
    internal void reset(ZStream z, Int64[] c);
    internal int proc(ZStream z, int r);
    internal void free(ZStream z);
    internal void set_dictionary(Byte[] d, int start, int n);
    internal int sync_point();
    internal int inflate_flush(ZStream z, int r);
}
internal class Org.BouncyCastle.Utilities.Zlib.InfCodes : object {
    private static int Z_OK;
    private static int Z_STREAM_END;
    private static int Z_NEED_DICT;
    private static int Z_ERRNO;
    private static int Z_STREAM_ERROR;
    private static int Z_DATA_ERROR;
    private static int Z_MEM_ERROR;
    private static int Z_BUF_ERROR;
    private static int Z_VERSION_ERROR;
    private static int START;
    private static int LEN;
    private static int LENEXT;
    private static int DIST;
    private static int DISTEXT;
    private static int COPY;
    private static int LIT;
    private static int WASH;
    private static int END;
    private static int BADCODE;
    private static Int32[] inflate_mask;
    private int mode;
    private int len;
    private Int32[] tree;
    private int tree_index;
    private int need;
    private int lit;
    private int get;
    private int dist;
    private byte lbits;
    private byte dbits;
    private Int32[] ltree;
    private int ltree_index;
    private Int32[] dtree;
    private int dtree_index;
    private static InfCodes();
    internal void init(int bl, int bd, Int32[] tl, int tl_index, Int32[] td, int td_index, ZStream z);
    internal int proc(InfBlocks s, ZStream z, int r);
    internal void free(ZStream z);
    internal int inflate_fast(int bl, int bd, Int32[] tl, int tl_index, Int32[] td, int td_index, InfBlocks s, ZStream z);
}
internal class Org.BouncyCastle.Utilities.Zlib.Inflate : object {
    private static int MAX_WBITS;
    private static int PRESET_DICT;
    internal static int Z_NO_FLUSH;
    internal static int Z_PARTIAL_FLUSH;
    internal static int Z_SYNC_FLUSH;
    internal static int Z_FULL_FLUSH;
    internal static int Z_FINISH;
    private static int Z_DEFLATED;
    private static int Z_OK;
    private static int Z_STREAM_END;
    private static int Z_NEED_DICT;
    private static int Z_ERRNO;
    private static int Z_STREAM_ERROR;
    private static int Z_DATA_ERROR;
    private static int Z_MEM_ERROR;
    private static int Z_BUF_ERROR;
    private static int Z_VERSION_ERROR;
    private static int METHOD;
    private static int FLAG;
    private static int DICT4;
    private static int DICT3;
    private static int DICT2;
    private static int DICT1;
    private static int DICT0;
    private static int BLOCKS;
    private static int CHECK4;
    private static int CHECK3;
    private static int CHECK2;
    private static int CHECK1;
    private static int DONE;
    private static int BAD;
    internal int mode;
    internal int method;
    internal Int64[] was;
    internal long need;
    internal int marker;
    internal int nowrap;
    internal int wbits;
    internal InfBlocks blocks;
    private static Byte[] mark;
    private static Inflate();
    internal int inflateReset(ZStream z);
    internal int inflateEnd(ZStream z);
    internal int inflateInit(ZStream z, int w);
    internal int inflate(ZStream z, int f);
    internal int inflateSetDictionary(ZStream z, Byte[] dictionary, int dictLength);
    internal int inflateSync(ZStream z);
    internal int inflateSyncPoint(ZStream z);
}
internal class Org.BouncyCastle.Utilities.Zlib.InfTree : object {
    private static int MANY;
    private static int Z_OK;
    private static int Z_STREAM_END;
    private static int Z_NEED_DICT;
    private static int Z_ERRNO;
    private static int Z_STREAM_ERROR;
    private static int Z_DATA_ERROR;
    private static int Z_MEM_ERROR;
    private static int Z_BUF_ERROR;
    private static int Z_VERSION_ERROR;
    private static int fixed_bl;
    private static int fixed_bd;
    private static int BMAX;
    private static Int32[] fixed_tl;
    private static Int32[] fixed_td;
    private static Int32[] cplens;
    private static Int32[] cplext;
    private static Int32[] cpdist;
    private static Int32[] cpdext;
    private Int32[] hn;
    private Int32[] v;
    private Int32[] c;
    private Int32[] r;
    private Int32[] u;
    private Int32[] x;
    private static InfTree();
    private int huft_build(Int32[] b, int bindex, int n, int s, Int32[] d, Int32[] e, Int32[] t, Int32[] m, Int32[] hp, Int32[] hn, Int32[] v);
    internal int inflate_trees_bits(Int32[] c, Int32[] bb, Int32[] tb, Int32[] hp, ZStream z);
    internal int inflate_trees_dynamic(int nl, int nd, Int32[] c, Int32[] bl, Int32[] bd, Int32[] tl, Int32[] td, Int32[] hp, ZStream z);
    internal static int inflate_trees_fixed(Int32[] bl, Int32[] bd, Int32[][] tl, Int32[][] td, ZStream z);
    private void initWorkArea(int vsize);
}
public class Org.BouncyCastle.Utilities.Zlib.JZlib : object {
    private static string _version;
    public static int Z_NO_COMPRESSION;
    public static int Z_BEST_SPEED;
    public static int Z_BEST_COMPRESSION;
    public static int Z_DEFAULT_COMPRESSION;
    public static int Z_FILTERED;
    public static int Z_HUFFMAN_ONLY;
    public static int Z_DEFAULT_STRATEGY;
    public static int Z_NO_FLUSH;
    public static int Z_PARTIAL_FLUSH;
    public static int Z_SYNC_FLUSH;
    public static int Z_FULL_FLUSH;
    public static int Z_FINISH;
    public static int Z_OK;
    public static int Z_STREAM_END;
    public static int Z_NEED_DICT;
    public static int Z_ERRNO;
    public static int Z_STREAM_ERROR;
    public static int Z_DATA_ERROR;
    public static int Z_MEM_ERROR;
    public static int Z_BUF_ERROR;
    public static int Z_VERSION_ERROR;
    public static string version();
}
internal class Org.BouncyCastle.Utilities.Zlib.StaticTree : object {
    private static int MAX_BITS;
    private static int BL_CODES;
    private static int D_CODES;
    private static int LITERALS;
    private static int LENGTH_CODES;
    private static int L_CODES;
    internal static int MAX_BL_BITS;
    internal static Int16[] static_ltree;
    internal static Int16[] static_dtree;
    internal static StaticTree static_l_desc;
    internal static StaticTree static_d_desc;
    internal static StaticTree static_bl_desc;
    internal Int16[] static_tree;
    internal Int32[] extra_bits;
    internal int extra_base;
    internal int elems;
    internal int max_length;
    internal StaticTree(Int16[] static_tree, Int32[] extra_bits, int extra_base, int elems, int max_length);
    private static StaticTree();
}
internal class Org.BouncyCastle.Utilities.Zlib.Tree : object {
    private static int MAX_BITS;
    private static int BL_CODES;
    private static int D_CODES;
    private static int LITERALS;
    private static int LENGTH_CODES;
    private static int L_CODES;
    private static int HEAP_SIZE;
    internal static int MAX_BL_BITS;
    internal static int END_BLOCK;
    internal static int REP_3_6;
    internal static int REPZ_3_10;
    internal static int REPZ_11_138;
    internal static int Buf_size;
    internal static int DIST_CODE_LEN;
    internal static Int32[] extra_lbits;
    internal static Int32[] extra_dbits;
    internal static Int32[] extra_blbits;
    internal static Byte[] bl_order;
    internal static Byte[] _dist_code;
    internal static Byte[] _length_code;
    internal static Int32[] base_length;
    internal static Int32[] base_dist;
    internal Int16[] dyn_tree;
    internal int max_code;
    internal StaticTree stat_desc;
    private static Tree();
    internal static int d_code(int dist);
    internal void gen_bitlen(Deflate s);
    internal void build_tree(Deflate s);
    internal static void gen_codes(Int16[] tree, int max_code, Int16[] bl_count);
    internal static int bi_reverse(int code, int len);
}
[ObsoleteAttribute("Use 'ZOutputStream' instead")]
public class Org.BouncyCastle.Utilities.Zlib.ZDeflaterOutputStream : Stream {
    private static int BUFSIZE;
    protected ZStream z;
    protected int flushLevel;
    protected Byte[] buf;
    private Byte[] buf1;
    protected Stream outp;
    public bool CanRead { get; }
    public bool CanSeek { get; }
    public bool CanWrite { get; }
    public long Length { get; }
    public long Position { get; public set; }
    public ZDeflaterOutputStream(Stream outp);
    public ZDeflaterOutputStream(Stream outp, int level);
    public ZDeflaterOutputStream(Stream outp, int level, bool nowrap);
    public virtual bool get_CanRead();
    public virtual bool get_CanSeek();
    public virtual bool get_CanWrite();
    public virtual long get_Length();
    public virtual long get_Position();
    public virtual void set_Position(long value);
    public virtual void Write(Byte[] b, int off, int len);
    public virtual long Seek(long offset, SeekOrigin origin);
    public virtual void SetLength(long value);
    public virtual int Read(Byte[] buffer, int offset, int count);
    public virtual void Flush();
    public virtual void WriteByte(byte b);
    public void Finish();
    public void End();
    public virtual void Close();
}
[ObsoleteAttribute("Use 'ZInputStream' instead")]
public class Org.BouncyCastle.Utilities.Zlib.ZInflaterInputStream : Stream {
    private static int BUFSIZE;
    protected ZStream z;
    protected int flushLevel;
    protected Byte[] buf;
    private Byte[] buf1;
    protected Stream inp;
    private bool nomoreinput;
    public bool CanRead { get; }
    public bool CanSeek { get; }
    public bool CanWrite { get; }
    public long Length { get; }
    public long Position { get; public set; }
    public ZInflaterInputStream(Stream inp);
    public ZInflaterInputStream(Stream inp, bool nowrap);
    public virtual bool get_CanRead();
    public virtual bool get_CanSeek();
    public virtual bool get_CanWrite();
    public virtual long get_Length();
    public virtual long get_Position();
    public virtual void set_Position(long value);
    public virtual void Write(Byte[] b, int off, int len);
    public virtual long Seek(long offset, SeekOrigin origin);
    public virtual void SetLength(long value);
    public virtual int Read(Byte[] b, int off, int len);
    public virtual void Flush();
    public virtual void WriteByte(byte b);
    public virtual void Close();
    public virtual int ReadByte();
}
public class Org.BouncyCastle.Utilities.Zlib.ZInputStream : Stream {
    private static int BufferSize;
    protected ZStream z;
    protected int flushLevel;
    protected Byte[] buf;
    protected Byte[] buf1;
    protected bool compress;
    protected Stream input;
    protected bool closed;
    private bool nomoreinput;
    public bool CanRead { get; }
    public bool CanSeek { get; }
    public bool CanWrite { get; }
    public int FlushMode { get; public set; }
    public long Length { get; }
    public long Position { get; public set; }
    public long TotalIn { get; }
    public long TotalOut { get; }
    public ZInputStream(Stream input);
    public ZInputStream(Stream input, bool nowrap);
    public ZInputStream(Stream input, int level);
    public sealed virtual bool get_CanRead();
    public sealed virtual bool get_CanSeek();
    public sealed virtual bool get_CanWrite();
    public virtual void Close();
    public sealed virtual void Flush();
    public virtual int get_FlushMode();
    public virtual void set_FlushMode(int value);
    public sealed virtual long get_Length();
    public sealed virtual long get_Position();
    public sealed virtual void set_Position(long value);
    public virtual int Read(Byte[] b, int off, int len);
    public virtual int ReadByte();
    public sealed virtual long Seek(long offset, SeekOrigin origin);
    public sealed virtual void SetLength(long value);
    public virtual long get_TotalIn();
    public virtual long get_TotalOut();
    public sealed virtual void Write(Byte[] buffer, int offset, int count);
}
public class Org.BouncyCastle.Utilities.Zlib.ZOutputStream : Stream {
    private static int BufferSize;
    protected ZStream z;
    protected int flushLevel;
    protected Byte[] buf;
    protected Byte[] buf1;
    protected bool compress;
    protected Stream output;
    protected bool closed;
    public bool CanRead { get; }
    public bool CanSeek { get; }
    public bool CanWrite { get; }
    public int FlushMode { get; public set; }
    public long Length { get; }
    public long Position { get; public set; }
    public long TotalIn { get; }
    public long TotalOut { get; }
    public ZOutputStream(Stream output);
    public ZOutputStream(Stream output, ZStream z);
    public ZOutputStream(Stream output, int level);
    public ZOutputStream(Stream output, int level, bool nowrap);
    public sealed virtual bool get_CanRead();
    public sealed virtual bool get_CanSeek();
    public sealed virtual bool get_CanWrite();
    public virtual void Close();
    public virtual void End();
    public virtual void Finish();
    public virtual void Flush();
    public virtual int get_FlushMode();
    public virtual void set_FlushMode(int value);
    public sealed virtual long get_Length();
    public sealed virtual long get_Position();
    public sealed virtual void set_Position(long value);
    public sealed virtual int Read(Byte[] buffer, int offset, int count);
    public sealed virtual long Seek(long offset, SeekOrigin origin);
    public sealed virtual void SetLength(long value);
    public virtual long get_TotalIn();
    public virtual long get_TotalOut();
    public virtual void Write(Byte[] b, int off, int len);
    public virtual void WriteByte(byte b);
}
public class Org.BouncyCastle.Utilities.Zlib.ZStream : object {
    private static int MAX_WBITS;
    private static int DEF_WBITS;
    private static int Z_NO_FLUSH;
    private static int Z_PARTIAL_FLUSH;
    private static int Z_SYNC_FLUSH;
    private static int Z_FULL_FLUSH;
    private static int Z_FINISH;
    private static int MAX_MEM_LEVEL;
    private static int Z_OK;
    private static int Z_STREAM_END;
    private static int Z_NEED_DICT;
    private static int Z_ERRNO;
    private static int Z_STREAM_ERROR;
    private static int Z_DATA_ERROR;
    private static int Z_MEM_ERROR;
    private static int Z_BUF_ERROR;
    private static int Z_VERSION_ERROR;
    public Byte[] next_in;
    public int next_in_index;
    public int avail_in;
    public long total_in;
    public Byte[] next_out;
    public int next_out_index;
    public int avail_out;
    public long total_out;
    public string msg;
    internal Deflate dstate;
    internal Inflate istate;
    internal int data_type;
    public long adler;
    internal Adler32 _adler;
    public int inflateInit();
    public int inflateInit(bool nowrap);
    public int inflateInit(int w);
    public int inflateInit(int w, bool nowrap);
    public int inflate(int f);
    public int inflateEnd();
    public int inflateSync();
    public int inflateSetDictionary(Byte[] dictionary, int dictLength);
    public int deflateInit(int level);
    public int deflateInit(int level, bool nowrap);
    public int deflateInit(int level, int bits);
    public int deflateInit(int level, int bits, bool nowrap);
    public int deflate(int flush);
    public int deflateEnd();
    public int deflateParams(int level, int strategy);
    public int deflateSetDictionary(Byte[] dictionary, int dictLength);
    internal void flush_pending();
    internal int read_buf(Byte[] buf, int start, int size);
    public void free();
}
public class Org.BouncyCastle.X509.AttributeCertificateHolder : object {
    internal Holder holder;
    public int DigestedObjectType { get; }
    public string DigestAlgorithm { get; }
    public string OtherObjectTypeID { get; }
    public BigInteger SerialNumber { get; }
    internal AttributeCertificateHolder(Asn1Sequence seq);
    public AttributeCertificateHolder(X509Name issuerName, BigInteger serialNumber);
    public AttributeCertificateHolder(X509Certificate cert);
    public AttributeCertificateHolder(X509Name principal);
    public AttributeCertificateHolder(int digestedObjectType, string digestAlgorithm, string otherObjectTypeID, Byte[] objectDigest);
    public int get_DigestedObjectType();
    public string get_DigestAlgorithm();
    public Byte[] GetObjectDigest();
    public string get_OtherObjectTypeID();
    private GeneralNames GenerateGeneralNames(X509Name principal);
    private bool MatchesDN(X509Name subject, GeneralNames targets);
    private Object[] GetNames(GeneralName[] names);
    private X509Name[] GetPrincipals(GeneralNames names);
    public X509Name[] GetEntityNames();
    public X509Name[] GetIssuer();
    public BigInteger get_SerialNumber();
    public sealed virtual object Clone();
    public bool Match(X509Certificate x509Cert);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public sealed virtual bool Match(object obj);
}
public class Org.BouncyCastle.X509.AttributeCertificateIssuer : object {
    internal Asn1Encodable form;
    public AttributeCertificateIssuer(AttCertIssuer issuer);
    public AttributeCertificateIssuer(X509Name principal);
    private Object[] GetNames();
    public X509Name[] GetPrincipals();
    private bool MatchesDN(X509Name subject, GeneralNames targets);
    public sealed virtual object Clone();
    public bool Match(X509Certificate x509Cert);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public sealed virtual bool Match(object obj);
}
public class Org.BouncyCastle.X509.Extension.AuthorityKeyIdentifierStructure : AuthorityKeyIdentifier {
    public AuthorityKeyIdentifierStructure(Asn1OctetString encodedValue);
    public AuthorityKeyIdentifierStructure(X509Certificate certificate);
    public AuthorityKeyIdentifierStructure(AsymmetricKeyParameter pubKey);
    private static Asn1Sequence FromCertificate(X509Certificate certificate);
    private static Asn1Sequence FromKey(AsymmetricKeyParameter pubKey);
}
public class Org.BouncyCastle.X509.Extension.SubjectKeyIdentifierStructure : SubjectKeyIdentifier {
    public SubjectKeyIdentifierStructure(Asn1OctetString encodedValue);
    public SubjectKeyIdentifierStructure(AsymmetricKeyParameter pubKey);
    private static Asn1OctetString FromPublicKey(AsymmetricKeyParameter pubKey);
}
public class Org.BouncyCastle.X509.Extension.X509ExtensionUtilities : object {
    public static Asn1Object FromExtensionValue(Asn1OctetString extensionValue);
    public static ICollection GetIssuerAlternativeNames(X509Certificate cert);
    public static ICollection GetSubjectAlternativeNames(X509Certificate cert);
    private static ICollection GetAlternativeName(Asn1OctetString extVal);
}
public interface Org.BouncyCastle.X509.IX509AttributeCertificate {
    public int Version { get; }
    public BigInteger SerialNumber { get; }
    public DateTime NotBefore { get; }
    public DateTime NotAfter { get; }
    public AttributeCertificateHolder Holder { get; }
    public AttributeCertificateIssuer Issuer { get; }
    public bool IsValidNow { get; }
    public abstract virtual int get_Version();
    public abstract virtual BigInteger get_SerialNumber();
    public abstract virtual DateTime get_NotBefore();
    public abstract virtual DateTime get_NotAfter();
    public abstract virtual AttributeCertificateHolder get_Holder();
    public abstract virtual AttributeCertificateIssuer get_Issuer();
    public abstract virtual X509Attribute[] GetAttributes();
    public abstract virtual X509Attribute[] GetAttributes(string oid);
    public abstract virtual Boolean[] GetIssuerUniqueID();
    public abstract virtual bool get_IsValidNow();
    public abstract virtual bool IsValid(DateTime date);
    public abstract virtual void CheckValidity();
    public abstract virtual void CheckValidity(DateTime date);
    public abstract virtual Byte[] GetSignature();
    public abstract virtual void Verify(AsymmetricKeyParameter publicKey);
    public abstract virtual Byte[] GetEncoded();
}
public interface Org.BouncyCastle.X509.IX509Extension {
    public abstract virtual ISet GetCriticalExtensionOids();
    public abstract virtual ISet GetNonCriticalExtensionOids();
    [ObsoleteAttribute("Use version taking a DerObjectIdentifier instead")]
public abstract virtual Asn1OctetString GetExtensionValue(string oid);
    public abstract virtual Asn1OctetString GetExtensionValue(DerObjectIdentifier oid);
}
internal class Org.BouncyCastle.X509.PemParser : object {
    private string _header1;
    private string _header2;
    private string _footer1;
    private string _footer2;
    internal PemParser(string type);
    private string ReadLine(Stream inStream);
    internal Asn1Sequence ReadPemObject(Stream inStream);
}
public class Org.BouncyCastle.X509.PrincipalUtilities : object {
    public static X509Name GetIssuerX509Principal(X509Certificate cert);
    public static X509Name GetSubjectX509Principal(X509Certificate cert);
    public static X509Name GetIssuerX509Principal(X509Crl crl);
}
public interface Org.BouncyCastle.X509.Store.IX509Selector {
    public abstract virtual bool Match(object obj);
}
public interface Org.BouncyCastle.X509.Store.IX509Store {
    public abstract virtual ICollection GetMatches(IX509Selector selector);
}
public interface Org.BouncyCastle.X509.Store.IX509StoreParameters {
}
public class Org.BouncyCastle.X509.Store.NoSuchStoreException : X509StoreException {
    public NoSuchStoreException(string message);
    public NoSuchStoreException(string message, Exception e);
}
public class Org.BouncyCastle.X509.Store.X509AttrCertStoreSelector : object {
    private IX509AttributeCertificate attributeCert;
    private DateTimeObject attributeCertificateValid;
    private AttributeCertificateHolder holder;
    private AttributeCertificateIssuer issuer;
    private BigInteger serialNumber;
    private ISet targetNames;
    private ISet targetGroups;
    public IX509AttributeCertificate AttributeCert { get; public set; }
    [ObsoleteAttribute("Use AttributeCertificateValid instead")]
public DateTimeObject AttribueCertificateValid { get; public set; }
    public DateTimeObject AttributeCertificateValid { get; public set; }
    public AttributeCertificateHolder Holder { get; public set; }
    public AttributeCertificateIssuer Issuer { get; public set; }
    public BigInteger SerialNumber { get; public set; }
    private X509AttrCertStoreSelector(X509AttrCertStoreSelector o);
    public sealed virtual bool Match(object obj);
    public sealed virtual object Clone();
    public IX509AttributeCertificate get_AttributeCert();
    public void set_AttributeCert(IX509AttributeCertificate value);
    public DateTimeObject get_AttribueCertificateValid();
    public void set_AttribueCertificateValid(DateTimeObject value);
    public DateTimeObject get_AttributeCertificateValid();
    public void set_AttributeCertificateValid(DateTimeObject value);
    public AttributeCertificateHolder get_Holder();
    public void set_Holder(AttributeCertificateHolder value);
    public AttributeCertificateIssuer get_Issuer();
    public void set_Issuer(AttributeCertificateIssuer value);
    public BigInteger get_SerialNumber();
    public void set_SerialNumber(BigInteger value);
    public void AddTargetName(GeneralName name);
    public void AddTargetName(Byte[] name);
    public void SetTargetNames(IEnumerable names);
    public IEnumerable GetTargetNames();
    public void AddTargetGroup(GeneralName group);
    public void AddTargetGroup(Byte[] name);
    public void SetTargetGroups(IEnumerable names);
    public IEnumerable GetTargetGroups();
    private ISet ExtractGeneralNames(IEnumerable names);
}
public class Org.BouncyCastle.X509.Store.X509CertPairStoreSelector : object {
    private X509CertificatePair certPair;
    private X509CertStoreSelector forwardSelector;
    private X509CertStoreSelector reverseSelector;
    public X509CertificatePair CertPair { get; public set; }
    public X509CertStoreSelector ForwardSelector { get; public set; }
    public X509CertStoreSelector ReverseSelector { get; public set; }
    private X509CertPairStoreSelector(X509CertPairStoreSelector o);
    private static X509CertStoreSelector CloneSelector(X509CertStoreSelector s);
    public X509CertificatePair get_CertPair();
    public void set_CertPair(X509CertificatePair value);
    public X509CertStoreSelector get_ForwardSelector();
    public void set_ForwardSelector(X509CertStoreSelector value);
    public X509CertStoreSelector get_ReverseSelector();
    public void set_ReverseSelector(X509CertStoreSelector value);
    public sealed virtual bool Match(object obj);
    public sealed virtual object Clone();
}
public class Org.BouncyCastle.X509.Store.X509CertStoreSelector : object {
    private Byte[] authorityKeyIdentifier;
    private int basicConstraints;
    private X509Certificate certificate;
    private DateTimeObject certificateValid;
    private ISet extendedKeyUsage;
    private X509Name issuer;
    private Boolean[] keyUsage;
    private ISet policy;
    private DateTimeObject privateKeyValid;
    private BigInteger serialNumber;
    private X509Name subject;
    private Byte[] subjectKeyIdentifier;
    private SubjectPublicKeyInfo subjectPublicKey;
    private DerObjectIdentifier subjectPublicKeyAlgID;
    public Byte[] AuthorityKeyIdentifier { get; public set; }
    public int BasicConstraints { get; public set; }
    public X509Certificate Certificate { get; public set; }
    public DateTimeObject CertificateValid { get; public set; }
    public ISet ExtendedKeyUsage { get; public set; }
    public X509Name Issuer { get; public set; }
    [ObsoleteAttribute("Avoid working with X509Name objects in string form")]
public string IssuerAsString { get; }
    public Boolean[] KeyUsage { get; public set; }
    public ISet Policy { get; public set; }
    public DateTimeObject PrivateKeyValid { get; public set; }
    public BigInteger SerialNumber { get; public set; }
    public X509Name Subject { get; public set; }
    public string SubjectAsString { get; }
    public Byte[] SubjectKeyIdentifier { get; public set; }
    public SubjectPublicKeyInfo SubjectPublicKey { get; public set; }
    public DerObjectIdentifier SubjectPublicKeyAlgID { get; public set; }
    public X509CertStoreSelector(X509CertStoreSelector o);
    public virtual object Clone();
    public Byte[] get_AuthorityKeyIdentifier();
    public void set_AuthorityKeyIdentifier(Byte[] value);
    public int get_BasicConstraints();
    public void set_BasicConstraints(int value);
    public X509Certificate get_Certificate();
    public void set_Certificate(X509Certificate value);
    public DateTimeObject get_CertificateValid();
    public void set_CertificateValid(DateTimeObject value);
    public ISet get_ExtendedKeyUsage();
    public void set_ExtendedKeyUsage(ISet value);
    public X509Name get_Issuer();
    public void set_Issuer(X509Name value);
    public string get_IssuerAsString();
    public Boolean[] get_KeyUsage();
    public void set_KeyUsage(Boolean[] value);
    public ISet get_Policy();
    public void set_Policy(ISet value);
    public DateTimeObject get_PrivateKeyValid();
    public void set_PrivateKeyValid(DateTimeObject value);
    public BigInteger get_SerialNumber();
    public void set_SerialNumber(BigInteger value);
    public X509Name get_Subject();
    public void set_Subject(X509Name value);
    public string get_SubjectAsString();
    public Byte[] get_SubjectKeyIdentifier();
    public void set_SubjectKeyIdentifier(Byte[] value);
    public SubjectPublicKeyInfo get_SubjectPublicKey();
    public void set_SubjectPublicKey(SubjectPublicKeyInfo value);
    public DerObjectIdentifier get_SubjectPublicKeyAlgID();
    public void set_SubjectPublicKeyAlgID(DerObjectIdentifier value);
    public virtual bool Match(object obj);
    internal static bool IssuersMatch(X509Name a, X509Name b);
    private static Boolean[] CopyBoolArray(Boolean[] b);
    private static ISet CopySet(ISet s);
    private static SubjectPublicKeyInfo GetSubjectPublicKey(X509Certificate c);
    private static bool MatchExtension(Byte[] b, X509Certificate c, DerObjectIdentifier oid);
}
internal class Org.BouncyCastle.X509.Store.X509CollectionStore : object {
    private ICollection _local;
    internal X509CollectionStore(ICollection collection);
    public sealed virtual ICollection GetMatches(IX509Selector selector);
}
public class Org.BouncyCastle.X509.Store.X509CollectionStoreParameters : object {
    private IList collection;
    public X509CollectionStoreParameters(ICollection collection);
    public ICollection GetCollection();
    public virtual string ToString();
}
public class Org.BouncyCastle.X509.Store.X509CrlStoreSelector : object {
    private X509Certificate certificateChecking;
    private DateTimeObject dateAndTime;
    private ICollection issuers;
    private BigInteger maxCrlNumber;
    private BigInteger minCrlNumber;
    private IX509AttributeCertificate attrCertChecking;
    private bool completeCrlEnabled;
    private bool deltaCrlIndicatorEnabled;
    private Byte[] issuingDistributionPoint;
    private bool issuingDistributionPointEnabled;
    private BigInteger maxBaseCrlNumber;
    public X509Certificate CertificateChecking { get; public set; }
    public DateTimeObject DateAndTime { get; public set; }
    public ICollection Issuers { get; public set; }
    public BigInteger MaxCrlNumber { get; public set; }
    public BigInteger MinCrlNumber { get; public set; }
    public IX509AttributeCertificate AttrCertChecking { get; public set; }
    public bool CompleteCrlEnabled { get; public set; }
    public bool DeltaCrlIndicatorEnabled { get; public set; }
    public Byte[] IssuingDistributionPoint { get; public set; }
    public bool IssuingDistributionPointEnabled { get; public set; }
    public BigInteger MaxBaseCrlNumber { get; public set; }
    public X509CrlStoreSelector(X509CrlStoreSelector o);
    public virtual object Clone();
    public X509Certificate get_CertificateChecking();
    public void set_CertificateChecking(X509Certificate value);
    public DateTimeObject get_DateAndTime();
    public void set_DateAndTime(DateTimeObject value);
    public ICollection get_Issuers();
    public void set_Issuers(ICollection value);
    public BigInteger get_MaxCrlNumber();
    public void set_MaxCrlNumber(BigInteger value);
    public BigInteger get_MinCrlNumber();
    public void set_MinCrlNumber(BigInteger value);
    public IX509AttributeCertificate get_AttrCertChecking();
    public void set_AttrCertChecking(IX509AttributeCertificate value);
    public bool get_CompleteCrlEnabled();
    public void set_CompleteCrlEnabled(bool value);
    public bool get_DeltaCrlIndicatorEnabled();
    public void set_DeltaCrlIndicatorEnabled(bool value);
    public Byte[] get_IssuingDistributionPoint();
    public void set_IssuingDistributionPoint(Byte[] value);
    public bool get_IssuingDistributionPointEnabled();
    public void set_IssuingDistributionPointEnabled(bool value);
    public BigInteger get_MaxBaseCrlNumber();
    public void set_MaxBaseCrlNumber(BigInteger value);
    public virtual bool Match(object obj);
}
public class Org.BouncyCastle.X509.Store.X509StoreException : Exception {
    public X509StoreException(string message);
    public X509StoreException(string message, Exception e);
}
public class Org.BouncyCastle.X509.Store.X509StoreFactory : object {
    public static IX509Store Create(string type, IX509StoreParameters parameters);
    private static void checkCorrectType(ICollection coll, Type t);
}
public class Org.BouncyCastle.X509.SubjectPublicKeyInfoFactory : object {
    public static SubjectPublicKeyInfo CreateSubjectPublicKeyInfo(AsymmetricKeyParameter key);
    private static void ExtractBytes(Byte[] encKey, int offset, BigInteger bI);
}
public class Org.BouncyCastle.X509.X509AttrCertParser : object {
    private static PemParser PemAttrCertParser;
    private Asn1Set sData;
    private int sDataObjectCount;
    private Stream currentStream;
    private static X509AttrCertParser();
    private IX509AttributeCertificate ReadDerCertificate(Asn1InputStream dIn);
    private IX509AttributeCertificate GetCertificate();
    private IX509AttributeCertificate ReadPemCertificate(Stream inStream);
    public IX509AttributeCertificate ReadAttrCert(Byte[] input);
    public ICollection ReadAttrCerts(Byte[] input);
    public IX509AttributeCertificate ReadAttrCert(Stream inStream);
    public ICollection ReadAttrCerts(Stream inStream);
}
public class Org.BouncyCastle.X509.X509Attribute : Asn1Encodable {
    private AttributeX509 attr;
    public string Oid { get; }
    internal X509Attribute(Asn1Encodable at);
    public X509Attribute(string oid, Asn1Encodable value);
    public X509Attribute(string oid, Asn1EncodableVector value);
    public string get_Oid();
    public Asn1Encodable[] GetValues();
    public virtual Asn1Object ToAsn1Object();
}
public class Org.BouncyCastle.X509.X509Certificate : X509ExtensionBase {
    private X509CertificateStructure c;
    private BasicConstraints basicConstraints;
    private Boolean[] keyUsage;
    private bool hashValueSet;
    private int hashValue;
    public X509CertificateStructure CertificateStructure { get; }
    public bool IsValidNow { get; }
    public int Version { get; }
    public BigInteger SerialNumber { get; }
    public X509Name IssuerDN { get; }
    public X509Name SubjectDN { get; }
    public DateTime NotBefore { get; }
    public DateTime NotAfter { get; }
    public string SigAlgName { get; }
    public string SigAlgOid { get; }
    public DerBitString IssuerUniqueID { get; }
    public DerBitString SubjectUniqueID { get; }
    public X509Certificate(X509CertificateStructure c);
    public virtual X509CertificateStructure get_CertificateStructure();
    public virtual bool get_IsValidNow();
    public virtual bool IsValid(DateTime time);
    public virtual void CheckValidity();
    public virtual void CheckValidity(DateTime time);
    public virtual int get_Version();
    public virtual BigInteger get_SerialNumber();
    public virtual X509Name get_IssuerDN();
    public virtual X509Name get_SubjectDN();
    public virtual DateTime get_NotBefore();
    public virtual DateTime get_NotAfter();
    public virtual Byte[] GetTbsCertificate();
    public virtual Byte[] GetSignature();
    public virtual string get_SigAlgName();
    public virtual string get_SigAlgOid();
    public virtual Byte[] GetSigAlgParams();
    public virtual DerBitString get_IssuerUniqueID();
    public virtual DerBitString get_SubjectUniqueID();
    public virtual Boolean[] GetKeyUsage();
    public virtual IList GetExtendedKeyUsage();
    public virtual int GetBasicConstraints();
    public virtual ICollection GetSubjectAlternativeNames();
    public virtual ICollection GetIssuerAlternativeNames();
    protected virtual ICollection GetAlternativeNames(string oid);
    protected virtual X509Extensions GetX509Extensions();
    public virtual AsymmetricKeyParameter GetPublicKey();
    public virtual Byte[] GetEncoded();
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public virtual string ToString();
    public virtual void Verify(AsymmetricKeyParameter key);
    protected virtual void CheckSignature(AsymmetricKeyParameter publicKey, ISigner signature);
    private static bool IsAlgIDEqual(AlgorithmIdentifier id1, AlgorithmIdentifier id2);
}
public class Org.BouncyCastle.X509.X509CertificatePair : object {
    private X509Certificate forward;
    private X509Certificate reverse;
    public X509Certificate Forward { get; }
    public X509Certificate Reverse { get; }
    public X509CertificatePair(X509Certificate forward, X509Certificate reverse);
    public X509CertificatePair(CertificatePair pair);
    public Byte[] GetEncoded();
    public X509Certificate get_Forward();
    public X509Certificate get_Reverse();
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
}
public class Org.BouncyCastle.X509.X509CertificateParser : object {
    private static PemParser PemCertParser;
    private Asn1Set sData;
    private int sDataObjectCount;
    private Stream currentStream;
    private static X509CertificateParser();
    private X509Certificate ReadDerCertificate(Asn1InputStream dIn);
    private X509Certificate GetCertificate();
    private X509Certificate ReadPemCertificate(Stream inStream);
    protected virtual X509Certificate CreateX509Certificate(X509CertificateStructure c);
    public X509Certificate ReadCertificate(Byte[] input);
    public ICollection ReadCertificates(Byte[] input);
    public X509Certificate ReadCertificate(Stream inStream);
    public ICollection ReadCertificates(Stream inStream);
}
public class Org.BouncyCastle.X509.X509CertPairParser : object {
    private Stream currentStream;
    private X509CertificatePair ReadDerCrossCertificatePair(Stream inStream);
    public X509CertificatePair ReadCertPair(Byte[] input);
    public ICollection ReadCertPairs(Byte[] input);
    public X509CertificatePair ReadCertPair(Stream inStream);
    public ICollection ReadCertPairs(Stream inStream);
}
public class Org.BouncyCastle.X509.X509Crl : X509ExtensionBase {
    private CertificateList c;
    private string sigAlgName;
    private Byte[] sigAlgParams;
    private bool isIndirect;
    public int Version { get; }
    public X509Name IssuerDN { get; }
    public DateTime ThisUpdate { get; }
    public DateTimeObject NextUpdate { get; }
    public string SigAlgName { get; }
    public string SigAlgOid { get; }
    protected bool IsIndirectCrl { get; }
    public X509Crl(CertificateList c);
    protected virtual X509Extensions GetX509Extensions();
    public virtual Byte[] GetEncoded();
    public virtual void Verify(AsymmetricKeyParameter publicKey);
    public virtual int get_Version();
    public virtual X509Name get_IssuerDN();
    public virtual DateTime get_ThisUpdate();
    public virtual DateTimeObject get_NextUpdate();
    private ISet LoadCrlEntries();
    public virtual X509CrlEntry GetRevokedCertificate(BigInteger serialNumber);
    public virtual ISet GetRevokedCertificates();
    public virtual Byte[] GetTbsCertList();
    public virtual Byte[] GetSignature();
    public virtual string get_SigAlgName();
    public virtual string get_SigAlgOid();
    public virtual Byte[] GetSigAlgParams();
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public virtual string ToString();
    public virtual bool IsRevoked(X509Certificate cert);
    protected virtual bool get_IsIndirectCrl();
}
public class Org.BouncyCastle.X509.X509CrlEntry : X509ExtensionBase {
    private CrlEntry c;
    private bool isIndirect;
    private X509Name previousCertificateIssuer;
    private X509Name certificateIssuer;
    public BigInteger SerialNumber { get; }
    public DateTime RevocationDate { get; }
    public bool HasExtensions { get; }
    public X509CrlEntry(CrlEntry c);
    public X509CrlEntry(CrlEntry c, bool isIndirect, X509Name previousCertificateIssuer);
    private X509Name loadCertificateIssuer();
    public X509Name GetCertificateIssuer();
    protected virtual X509Extensions GetX509Extensions();
    public Byte[] GetEncoded();
    public BigInteger get_SerialNumber();
    public DateTime get_RevocationDate();
    public bool get_HasExtensions();
    public virtual string ToString();
}
public class Org.BouncyCastle.X509.X509CrlParser : object {
    private static PemParser PemCrlParser;
    private bool lazyAsn1;
    private Asn1Set sCrlData;
    private int sCrlDataObjectCount;
    private Stream currentCrlStream;
    public X509CrlParser(bool lazyAsn1);
    private static X509CrlParser();
    private X509Crl ReadPemCrl(Stream inStream);
    private X509Crl ReadDerCrl(Asn1InputStream dIn);
    private X509Crl GetCrl();
    protected virtual X509Crl CreateX509Crl(CertificateList c);
    public X509Crl ReadCrl(Byte[] input);
    public ICollection ReadCrls(Byte[] input);
    public X509Crl ReadCrl(Stream inStream);
    public ICollection ReadCrls(Stream inStream);
}
public abstract class Org.BouncyCastle.X509.X509ExtensionBase : object {
    protected abstract virtual X509Extensions GetX509Extensions();
    protected virtual ISet GetExtensionOids(bool critical);
    public virtual ISet GetNonCriticalExtensionOids();
    public virtual ISet GetCriticalExtensionOids();
    [ObsoleteAttribute("Use version taking a DerObjectIdentifier instead")]
public sealed virtual Asn1OctetString GetExtensionValue(string oid);
    public virtual Asn1OctetString GetExtensionValue(DerObjectIdentifier oid);
}
public class Org.BouncyCastle.X509.X509KeyUsage : Asn1Encodable {
    public static int DigitalSignature;
    public static int NonRepudiation;
    public static int KeyEncipherment;
    public static int DataEncipherment;
    public static int KeyAgreement;
    public static int KeyCertSign;
    public static int CrlSign;
    public static int EncipherOnly;
    public static int DecipherOnly;
    private int usage;
    public X509KeyUsage(int usage);
    public virtual Asn1Object ToAsn1Object();
}
internal class Org.BouncyCastle.X509.X509SignatureUtilities : object {
    private static Asn1Null derNull;
    private static X509SignatureUtilities();
    internal static void SetSignatureParameters(ISigner signature, Asn1Encodable parameters);
    internal static string GetSignatureName(AlgorithmIdentifier sigAlgId);
    private static string GetDigestAlgName(DerObjectIdentifier digestAlgOID);
}
internal class Org.BouncyCastle.X509.X509Utilities : object {
    private static IDictionary algorithms;
    private static IDictionary exParams;
    private static ISet noParams;
    private static X509Utilities();
    private static RsassaPssParameters CreatePssParams(AlgorithmIdentifier hashAlgId, int saltSize);
    internal static DerObjectIdentifier GetAlgorithmOid(string algorithmName);
    internal static AlgorithmIdentifier GetSigAlgID(DerObjectIdentifier sigOid, string algorithmName);
    internal static IEnumerable GetAlgNames();
    internal static Byte[] GetSignatureForObject(DerObjectIdentifier sigOid, string sigName, AsymmetricKeyParameter privateKey, SecureRandom random, Asn1Encodable ae);
}
public class Org.BouncyCastle.X509.X509V1CertificateGenerator : object {
    private V1TbsCertificateGenerator tbsGen;
    private DerObjectIdentifier sigOID;
    private AlgorithmIdentifier sigAlgId;
    private string signatureAlgorithm;
    public IEnumerable SignatureAlgNames { get; }
    public void Reset();
    public void SetSerialNumber(BigInteger serialNumber);
    public void SetIssuerDN(X509Name issuer);
    public void SetNotBefore(DateTime date);
    public void SetNotAfter(DateTime date);
    public void SetSubjectDN(X509Name subject);
    public void SetPublicKey(AsymmetricKeyParameter publicKey);
    public void SetSignatureAlgorithm(string signatureAlgorithm);
    public X509Certificate Generate(AsymmetricKeyParameter privateKey);
    public X509Certificate Generate(AsymmetricKeyParameter privateKey, SecureRandom random);
    private X509Certificate GenerateJcaObject(TbsCertificateStructure tbsCert, Byte[] signature);
    public IEnumerable get_SignatureAlgNames();
}
public class Org.BouncyCastle.X509.X509V2AttributeCertificate : X509ExtensionBase {
    private AttributeCertificate cert;
    private DateTime notBefore;
    private DateTime notAfter;
    public int Version { get; }
    public BigInteger SerialNumber { get; }
    public AttributeCertificateHolder Holder { get; }
    public AttributeCertificateIssuer Issuer { get; }
    public DateTime NotBefore { get; }
    public DateTime NotAfter { get; }
    public bool IsValidNow { get; }
    public X509V2AttributeCertificate(Stream encIn);
    public X509V2AttributeCertificate(Byte[] encoded);
    internal X509V2AttributeCertificate(AttributeCertificate cert);
    private static AttributeCertificate GetObject(Stream input);
    public virtual int get_Version();
    public virtual BigInteger get_SerialNumber();
    public virtual AttributeCertificateHolder get_Holder();
    public virtual AttributeCertificateIssuer get_Issuer();
    public virtual DateTime get_NotBefore();
    public virtual DateTime get_NotAfter();
    public virtual Boolean[] GetIssuerUniqueID();
    public virtual bool get_IsValidNow();
    public virtual bool IsValid(DateTime date);
    public virtual void CheckValidity();
    public virtual void CheckValidity(DateTime date);
    public virtual Byte[] GetSignature();
    public virtual void Verify(AsymmetricKeyParameter publicKey);
    public virtual Byte[] GetEncoded();
    protected virtual X509Extensions GetX509Extensions();
    public virtual X509Attribute[] GetAttributes();
    public virtual X509Attribute[] GetAttributes(string oid);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
}
public class Org.BouncyCastle.X509.X509V2AttributeCertificateGenerator : object {
    private X509ExtensionsGenerator extGenerator;
    private V2AttributeCertificateInfoGenerator acInfoGen;
    private DerObjectIdentifier sigOID;
    private AlgorithmIdentifier sigAlgId;
    private string signatureAlgorithm;
    public IEnumerable SignatureAlgNames { get; }
    public void Reset();
    public void SetHolder(AttributeCertificateHolder holder);
    public void SetIssuer(AttributeCertificateIssuer issuer);
    public void SetSerialNumber(BigInteger serialNumber);
    public void SetNotBefore(DateTime date);
    public void SetNotAfter(DateTime date);
    public void SetSignatureAlgorithm(string signatureAlgorithm);
    public void AddAttribute(X509Attribute attribute);
    public void SetIssuerUniqueId(Boolean[] iui);
    public void AddExtension(string oid, bool critical, Asn1Encodable extensionValue);
    public void AddExtension(string oid, bool critical, Byte[] extensionValue);
    public IX509AttributeCertificate Generate(AsymmetricKeyParameter publicKey);
    public IX509AttributeCertificate Generate(AsymmetricKeyParameter publicKey, SecureRandom random);
    public IEnumerable get_SignatureAlgNames();
}
public class Org.BouncyCastle.X509.X509V2CrlGenerator : object {
    private X509ExtensionsGenerator extGenerator;
    private V2TbsCertListGenerator tbsGen;
    private DerObjectIdentifier sigOID;
    private AlgorithmIdentifier sigAlgId;
    private string signatureAlgorithm;
    public IEnumerable SignatureAlgNames { get; }
    public void Reset();
    public void SetIssuerDN(X509Name issuer);
    public void SetThisUpdate(DateTime date);
    public void SetNextUpdate(DateTime date);
    public void AddCrlEntry(BigInteger userCertificate, DateTime revocationDate, int reason);
    public void AddCrlEntry(BigInteger userCertificate, DateTime revocationDate, int reason, DateTime invalidityDate);
    public void AddCrlEntry(BigInteger userCertificate, DateTime revocationDate, X509Extensions extensions);
    public void AddCrl(X509Crl other);
    public void SetSignatureAlgorithm(string signatureAlgorithm);
    public void AddExtension(string oid, bool critical, Asn1Encodable extensionValue);
    public void AddExtension(DerObjectIdentifier oid, bool critical, Asn1Encodable extensionValue);
    public void AddExtension(string oid, bool critical, Byte[] extensionValue);
    public void AddExtension(DerObjectIdentifier oid, bool critical, Byte[] extensionValue);
    public X509Crl Generate(AsymmetricKeyParameter privateKey);
    public X509Crl Generate(AsymmetricKeyParameter privateKey, SecureRandom random);
    private TbsCertificateList GenerateCertList();
    private X509Crl GenerateJcaObject(TbsCertificateList tbsCrl, Byte[] signature);
    public IEnumerable get_SignatureAlgNames();
}
public class Org.BouncyCastle.X509.X509V3CertificateGenerator : object {
    private X509ExtensionsGenerator extGenerator;
    private V3TbsCertificateGenerator tbsGen;
    private DerObjectIdentifier sigOid;
    private AlgorithmIdentifier sigAlgId;
    private string signatureAlgorithm;
    public IEnumerable SignatureAlgNames { get; }
    public void Reset();
    public void SetSerialNumber(BigInteger serialNumber);
    public void SetIssuerDN(X509Name issuer);
    public void SetNotBefore(DateTime date);
    public void SetNotAfter(DateTime date);
    public void SetSubjectDN(X509Name subject);
    public void SetPublicKey(AsymmetricKeyParameter publicKey);
    public void SetSignatureAlgorithm(string signatureAlgorithm);
    public void SetSubjectUniqueID(Boolean[] uniqueID);
    public void SetIssuerUniqueID(Boolean[] uniqueID);
    private DerBitString booleanToBitString(Boolean[] id);
    public void AddExtension(string oid, bool critical, Asn1Encodable extensionValue);
    public void AddExtension(DerObjectIdentifier oid, bool critical, Asn1Encodable extensionValue);
    public void AddExtension(string oid, bool critical, Byte[] extensionValue);
    public void AddExtension(DerObjectIdentifier oid, bool critical, Byte[] extensionValue);
    public void CopyAndAddExtension(string oid, bool critical, X509Certificate cert);
    public void CopyAndAddExtension(DerObjectIdentifier oid, bool critical, X509Certificate cert);
    public X509Certificate Generate(AsymmetricKeyParameter privateKey);
    public X509Certificate Generate(AsymmetricKeyParameter privateKey, SecureRandom random);
    private TbsCertificateStructure GenerateTbsCert();
    private X509Certificate GenerateJcaObject(TbsCertificateStructure tbsCert, Byte[] signature);
    public IEnumerable get_SignatureAlgNames();
}
public class System.util.collections.HashSet2`1 : object {
    private Dictionary`2<T, object> set;
    public int Count { get; }
    public bool IsReadOnly { get; }
    internal Dictionary`2<T, object> InternalSet { get; }
    public HashSet2`1(IEnumerable`1<T> set);
    public virtual IEnumerator`1<T> GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    public bool AddAndCheck(T item);
    public virtual void Add(T item);
    public virtual void AddAll(IEnumerable`1<T> set);
    public virtual void Clear();
    public virtual bool Contains(T item);
    public virtual void CopyTo(T[] array, int arrayIndex);
    public virtual bool Remove(T item);
    public virtual int get_Count();
    public virtual bool IsEmpty();
    public virtual bool get_IsReadOnly();
    public virtual bool RetainAll(ICollection`1<T> collection);
    internal virtual Dictionary`2<T, object> get_InternalSet();
}
[DefaultMemberAttribute("Item")]
public class System.util.collections.LinkedDictionary`2 : object {
    private Dictionary`2<TKey, LinkedListNode`1<KeyValuePair`2<TKey, TValue>>> dic;
    private LinkedList`1<KeyValuePair`2<TKey, TValue>> link;
    public ICollection`1<TKey> Keys { get; }
    public ICollection`1<TValue> Values { get; }
    public TValue Item { get; public set; }
    private int System.Collections.Generic.ICollection<System.Collections.Generic.KeyValuePair<TKey,TValue>>.Count { get; }
    private bool System.Collections.Generic.ICollection<System.Collections.Generic.KeyValuePair<TKey,TValue>>.IsReadOnly { get; }
    public virtual void Add(TKey key, TValue value);
    public virtual bool ContainsKey(TKey key);
    public virtual ICollection`1<TKey> get_Keys();
    public virtual bool Remove(TKey key);
    public virtual bool TryGetValue(TKey key, TValue& value);
    public virtual ICollection`1<TValue> get_Values();
    public sealed virtual TValue get_Item(TKey key);
    public sealed virtual void set_Item(TKey key, TValue value);
    private sealed virtual override void System.Collections.Generic.ICollection<System.Collections.Generic.KeyValuePair<TKey,TValue>>.Add(KeyValuePair`2<TKey, TValue> item);
    private sealed virtual override void System.Collections.Generic.ICollection<System.Collections.Generic.KeyValuePair<TKey,TValue>>.Clear();
    private sealed virtual override bool System.Collections.Generic.ICollection<System.Collections.Generic.KeyValuePair<TKey,TValue>>.Contains(KeyValuePair`2<TKey, TValue> item);
    private sealed virtual override void System.Collections.Generic.ICollection<System.Collections.Generic.KeyValuePair<TKey,TValue>>.CopyTo(KeyValuePair`2[] array, int arrayIndex);
    private sealed virtual override int System.Collections.Generic.ICollection<System.Collections.Generic.KeyValuePair<TKey,TValue>>.get_Count();
    private sealed virtual override bool System.Collections.Generic.ICollection<System.Collections.Generic.KeyValuePair<TKey,TValue>>.get_IsReadOnly();
    private sealed virtual override bool System.Collections.Generic.ICollection<System.Collections.Generic.KeyValuePair<TKey,TValue>>.Remove(KeyValuePair`2<TKey, TValue> item);
    private sealed virtual override IEnumerator`1<KeyValuePair`2<TKey, TValue>> System.Collections.Generic.IEnumerable<System.Collections.Generic.KeyValuePair<TKey,TValue>>.GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
}
[DefaultMemberAttribute("Item")]
public class System.util.collections.OrderedTree : object {
    private int intCount;
    private OrderedTreeNode rbTree;
    private OrderedTreeNode sentinelNode;
    private OrderedTreeNode lastNodeFound;
    public object Item { get; public set; }
    public OrderedTreeEnumerator Keys { get; }
    public OrderedTreeEnumerator Values { get; }
    public int Count { get; }
    public object get_Item(IComparable key);
    public void set_Item(IComparable key, object value);
    public virtual void Add(IComparable key, object data);
    private void RestoreAfterInsert(OrderedTreeNode x);
    public virtual void RotateLeft(OrderedTreeNode x);
    public virtual void RotateRight(OrderedTreeNode x);
    public virtual bool ContainsKey(IComparable key);
    public virtual object GetData(IComparable key);
    public virtual IComparable GetMinKey();
    public virtual IComparable GetMaxKey();
    public virtual object GetMinValue();
    public virtual object GetMaxValue();
    public virtual OrderedTreeEnumerator GetEnumerator();
    public virtual OrderedTreeEnumerator get_Keys();
    public virtual OrderedTreeEnumerator KeyElements(bool ascending);
    public virtual OrderedTreeEnumerator get_Values();
    public virtual OrderedTreeEnumerator Elements();
    public virtual OrderedTreeEnumerator Elements(bool ascending);
    public virtual bool IsEmpty();
    public virtual void Remove(IComparable key);
    private void Delete(OrderedTreeNode z);
    private void RestoreAfterDelete(OrderedTreeNode x);
    public virtual void RemoveMin();
    public virtual void RemoveMax();
    public virtual void Clear();
    public virtual int get_Count();
}
public class System.util.collections.OrderedTreeEnumerator : object {
    private Stack stack;
    private bool keys;
    private bool ascending;
    private OrderedTreeNode tnode;
    private OrderedTreeNode sentinelNode;
    private bool pre;
    private IComparable ordKey;
    private object objValue;
    public IComparable Key { get; public set; }
    public object Value { get; public set; }
    public object Current { get; }
    public OrderedTreeEnumerator(OrderedTreeNode tnode, bool keys, bool ascending, OrderedTreeNode sentinelNode);
    public virtual IComparable get_Key();
    public virtual void set_Key(IComparable value);
    public virtual object get_Value();
    public virtual void set_Value(object value);
    public virtual void Reset();
    public virtual object get_Current();
    public virtual bool HasMoreElements();
    public virtual object NextElement();
    public virtual bool MoveNext();
    public virtual OrderedTreeEnumerator GetEnumerator();
}
public class System.util.collections.OrderedTreeNode : object {
    public static bool RED;
    public static bool BLACK;
    private IComparable ordKey;
    private object objData;
    private bool intColor;
    private OrderedTreeNode rbnLeft;
    private OrderedTreeNode rbnRight;
    private OrderedTreeNode rbnParent;
    public IComparable Key { get; public set; }
    public object Data { get; public set; }
    public bool Color { get; public set; }
    public OrderedTreeNode Left { get; public set; }
    public OrderedTreeNode Right { get; public set; }
    public OrderedTreeNode Parent { get; public set; }
    public virtual IComparable get_Key();
    public virtual void set_Key(IComparable value);
    public virtual object get_Data();
    public virtual void set_Data(object value);
    public virtual bool get_Color();
    public virtual void set_Color(bool value);
    public virtual OrderedTreeNode get_Left();
    public virtual void set_Left(OrderedTreeNode value);
    public virtual OrderedTreeNode get_Right();
    public virtual void set_Right(OrderedTreeNode value);
    public virtual OrderedTreeNode get_Parent();
    public virtual void set_Parent(OrderedTreeNode value);
}
[DefaultMemberAttribute("Item")]
public class System.util.collections.ReadOnlyDictionary`2 : object {
    private IDictionary`2<TKey, TValue> source;
    private object syncRoot;
    public int Count { get; }
    public ICollection`1<TKey> Keys { get; }
    public ICollection`1<TValue> Values { get; }
    private bool System.Collections.Generic.ICollection<System.Collections.Generic.KeyValuePair<TKey,TValue>>.IsReadOnly { get; }
    private bool System.Collections.ICollection.IsSynchronized { get; }
    private object System.Collections.ICollection.SyncRoot { get; }
    public TValue Item { get; public set; }
    public ReadOnlyDictionary`2(IDictionary`2<TKey, TValue> dictionaryToWrap);
    public virtual int get_Count();
    public virtual ICollection`1<TKey> get_Keys();
    public virtual ICollection`1<TValue> get_Values();
    private sealed virtual override bool System.Collections.Generic.ICollection<System.Collections.Generic.KeyValuePair<TKey,TValue>>.get_IsReadOnly();
    private sealed virtual override bool System.Collections.ICollection.get_IsSynchronized();
    private sealed virtual override object System.Collections.ICollection.get_SyncRoot();
    public sealed virtual TValue get_Item(TKey key);
    public sealed virtual void set_Item(TKey key, TValue value);
    private sealed virtual override void System.Collections.Generic.IDictionary<TKey,TValue>.Add(TKey key, TValue value);
    public virtual bool ContainsKey(TKey key);
    private sealed virtual override bool System.Collections.Generic.IDictionary<TKey,TValue>.Remove(TKey key);
    public virtual bool TryGetValue(TKey key, TValue& value);
    private sealed virtual override void System.Collections.Generic.ICollection<System.Collections.Generic.KeyValuePair<TKey,TValue>>.Add(KeyValuePair`2<TKey, TValue> item);
    private sealed virtual override void System.Collections.Generic.ICollection<System.Collections.Generic.KeyValuePair<TKey,TValue>>.Clear();
    private sealed virtual override bool System.Collections.Generic.ICollection<System.Collections.Generic.KeyValuePair<TKey,TValue>>.Contains(KeyValuePair`2<TKey, TValue> item);
    private sealed virtual override void System.Collections.Generic.ICollection<System.Collections.Generic.KeyValuePair<TKey,TValue>>.CopyTo(KeyValuePair`2[] array, int arrayIndex);
    private sealed virtual override bool System.Collections.Generic.ICollection<System.Collections.Generic.KeyValuePair<TKey,TValue>>.Remove(KeyValuePair`2<TKey, TValue> item);
    private sealed virtual override IEnumerator`1<KeyValuePair`2<TKey, TValue>> System.Collections.Generic.IEnumerable<System.Collections.Generic.KeyValuePair<TKey,TValue>>.GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    private sealed virtual override void System.Collections.ICollection.CopyTo(Array array, int index);
    private static void ThrowNotSupportedException();
}
public class System.util.FilterStream : Stream {
    private Stream s;
    public bool CanRead { get; }
    public bool CanSeek { get; }
    public bool CanWrite { get; }
    public long Length { get; }
    public long Position { get; public set; }
    public FilterStream(Stream s);
    public virtual bool get_CanRead();
    public virtual bool get_CanSeek();
    public virtual bool get_CanWrite();
    public virtual long get_Length();
    public virtual long get_Position();
    public virtual void set_Position(long value);
    public virtual void Close();
    public virtual void Flush();
    public virtual long Seek(long offset, SeekOrigin origin);
    public virtual void SetLength(long value);
    public virtual int Read(Byte[] buffer, int offset, int count);
    public virtual int ReadByte();
    public virtual void Write(Byte[] buffer, int offset, int count);
    public virtual void WriteByte(byte value);
}
public class System.util.ListIterator`1 : object {
    private IList`1<T> col;
    private int cursor;
    private int lastRet;
    public ListIterator`1(IList`1<T> col);
    public virtual bool HasNext();
    public virtual T Next();
    public virtual T Previous();
    public virtual void Remove();
}
[DefaultMemberAttribute("Item")]
public class System.util.Properties : object {
    private static string whiteSpaceChars;
    private static string keyValueSeparators;
    private static string strictKeyValueSeparators;
    private Dictionary`2<string, string> _col;
    public int Count { get; }
    public string Item { get; public set; }
    public KeyCollection<string, string> Keys { get; }
    public virtual string Remove(string key);
    public virtual Enumerator<string, string> GetEnumerator();
    public virtual bool ContainsKey(string key);
    public virtual void Add(string key, string value);
    public virtual void AddAll(Properties col);
    public virtual int get_Count();
    public virtual string get_Item(string key);
    public virtual void set_Item(string key, string value);
    public virtual KeyCollection<string, string> get_Keys();
    public virtual void Clear();
    public virtual void Load(Stream inStream);
    private string LoadConvert(string theString);
    private bool ContinueLine(string line);
}
public class System.util.PushbackStream : FilterStream {
    private int buf;
    public PushbackStream(Stream s);
    public virtual int ReadByte();
    public virtual int Read(Byte[] buffer, int offset, int count);
    public virtual void Unread(int b);
}
public class System.util.RectangleJ : object {
    public static int OUT_LEFT;
    public static int OUT_TOP;
    public static int OUT_RIGHT;
    public static int OUT_BOTTOM;
    private float x;
    private float y;
    private float width;
    private float height;
    public float X { get; public set; }
    public float Y { get; public set; }
    public float Width { get; public set; }
    public float Height { get; public set; }
    public RectangleJ(float x, float y, float width, float height);
    public RectangleJ(Rectangle rect);
    public virtual float get_X();
    public virtual void set_X(float value);
    public virtual float get_Y();
    public virtual void set_Y(float value);
    public virtual float get_Width();
    public virtual void set_Width(float value);
    public virtual float get_Height();
    public virtual void set_Height(float value);
    public virtual void Add(RectangleJ rect);
    public virtual int Outcode(double x, double y);
    public virtual bool IntersectsLine(double x1, double y1, double x2, double y2);
    public virtual RectangleJ Intersection(RectangleJ r);
    public virtual bool IsEmpty();
    public virtual bool Contains(Point2D point);
    public virtual bool Contains(double x, double y);
}
public class System.util.StringTokenizer : object {
    private int pos;
    private string str;
    private int len;
    private string delim;
    private bool retDelims;
    public StringTokenizer(string str);
    public StringTokenizer(string str, string delim);
    public StringTokenizer(string str, string delim, bool retDelims);
    public virtual bool HasMoreTokens();
    public virtual string NextToken(string delim);
    public virtual string NextToken();
    public virtual int CountTokens();
}
public static class System.util.Util : object {
    public static int USR(int op1, int op2);
    public static bool EqualsIgnoreCase(string s1, string s2);
    public static int CompareToIgnoreCase(string s1, string s2);
    public static CultureInfo GetStandartEnUSLocale();
    public static int GetArrayHashCode(T[] a);
    public static int Compare(float f1, float f2);
    public static bool ArraysAreEqual(T[] a, T[] b);
    public static bool AreEqual(Stack`1<T> s1, Stack`1<T> s2);
    public static T Min(T[] array);
    public static T Max(T[] array);
    public static void AddAll(ICollection`1<T> dest, IEnumerable`1<T> source, int srcStartFrom);
    public static void AddAll(ICollection`1<T> dest, IEnumerable`1<T> source);
    public static void AddAll(Queue`1<T> to, IEnumerable`1<T> from);
}
internal class System.util.zlib.Adler32 : object {
    private static int BASE;
    private static int NMAX;
    internal long adler32(long adler, Byte[] buf, int index, int len);
}
public class System.util.zlib.Deflate : object {
    private static int MAX_MEM_LEVEL;
    private static int Z_DEFAULT_COMPRESSION;
    private static int MAX_WBITS;
    private static int DEF_MEM_LEVEL;
    private static int STORED;
    private static int FAST;
    private static int SLOW;
    private static int NeedMore;
    private static int BlockDone;
    private static int FinishStarted;
    private static int FinishDone;
    private static int PRESET_DICT;
    private static int Z_FILTERED;
    private static int Z_HUFFMAN_ONLY;
    private static int Z_DEFAULT_STRATEGY;
    private static int Z_NO_FLUSH;
    private static int Z_PARTIAL_FLUSH;
    private static int Z_SYNC_FLUSH;
    private static int Z_FULL_FLUSH;
    private static int Z_FINISH;
    private static int Z_OK;
    private static int Z_STREAM_END;
    private static int Z_NEED_DICT;
    private static int Z_ERRNO;
    private static int Z_STREAM_ERROR;
    private static int Z_DATA_ERROR;
    private static int Z_MEM_ERROR;
    private static int Z_BUF_ERROR;
    private static int Z_VERSION_ERROR;
    private static int INIT_STATE;
    private static int BUSY_STATE;
    private static int FINISH_STATE;
    private static int Z_DEFLATED;
    private static int STORED_BLOCK;
    private static int STATIC_TREES;
    private static int DYN_TREES;
    private static int Z_BINARY;
    private static int Z_ASCII;
    private static int Z_UNKNOWN;
    private static int Buf_size;
    private static int REP_3_6;
    private static int REPZ_3_10;
    private static int REPZ_11_138;
    private static int MIN_MATCH;
    private static int MAX_MATCH;
    private static int MIN_LOOKAHEAD;
    private static int MAX_BITS;
    private static int D_CODES;
    private static int BL_CODES;
    private static int LENGTH_CODES;
    private static int LITERALS;
    private static int L_CODES;
    private static int HEAP_SIZE;
    private static int END_BLOCK;
    private static Config[] config_table;
    private static String[] z_errmsg;
    internal ZStream strm;
    internal int status;
    internal Byte[] pending_buf;
    internal int pending_buf_size;
    internal int pending_out;
    internal int pending;
    internal int noheader;
    internal byte data_type;
    internal byte method;
    internal int last_flush;
    internal int w_size;
    internal int w_bits;
    internal int w_mask;
    internal Byte[] window;
    internal int window_size;
    internal Int16[] prev;
    internal Int16[] head;
    internal int ins_h;
    internal int hash_size;
    internal int hash_bits;
    internal int hash_mask;
    internal int hash_shift;
    internal int block_start;
    internal int match_length;
    internal int prev_match;
    internal int match_available;
    internal int strstart;
    internal int match_start;
    internal int lookahead;
    internal int prev_length;
    internal int max_chain_length;
    internal int max_lazy_match;
    internal int level;
    internal int strategy;
    internal int good_match;
    internal int nice_match;
    internal Int16[] dyn_ltree;
    internal Int16[] dyn_dtree;
    internal Int16[] bl_tree;
    internal Tree l_desc;
    internal Tree d_desc;
    internal Tree bl_desc;
    internal Int16[] bl_count;
    internal Int32[] heap;
    internal int heap_len;
    internal int heap_max;
    internal Byte[] depth;
    internal int l_buf;
    internal int lit_bufsize;
    internal int last_lit;
    internal int d_buf;
    internal int opt_len;
    internal int static_len;
    internal int matches;
    internal int last_eob_len;
    internal UInt32 bi_buf;
    internal int bi_valid;
    private static Deflate();
    internal void lm_init();
    internal void tr_init();
    internal void init_block();
    internal void pqdownheap(Int16[] tree, int k);
    internal static bool smaller(Int16[] tree, int n, int m, Byte[] depth);
    internal void scan_tree(Int16[] tree, int max_code);
    internal int build_bl_tree();
    internal void send_all_trees(int lcodes, int dcodes, int blcodes);
    internal void send_tree(Int16[] tree, int max_code);
    internal void put_byte(Byte[] p, int start, int len);
    internal void put_byte(byte c);
    internal void put_short(int w);
    internal void putShortMSB(int b);
    internal void send_code(int c, Int16[] tree);
    internal void send_bits(int val, int length);
    internal void _tr_align();
    internal bool _tr_tally(int dist, int lc);
    internal void compress_block(Int16[] ltree, Int16[] dtree);
    internal void set_data_type();
    internal void bi_flush();
    internal void bi_windup();
    internal void copy_block(int buf, int len, bool header);
    internal void flush_block_only(bool eof);
    internal int deflate_stored(int flush);
    internal void _tr_stored_block(int buf, int stored_len, bool eof);
    internal void _tr_flush_block(int buf, int stored_len, bool eof);
    internal void fill_window();
    internal int deflate_fast(int flush);
    internal int deflate_slow(int flush);
    internal int longest_match(int cur_match);
    internal int deflateInit(ZStream strm, int level, int bits);
    internal int deflateInit(ZStream strm, int level);
    internal int deflateInit2(ZStream strm, int level, int method, int windowBits, int memLevel, int strategy);
    internal int deflateReset(ZStream strm);
    internal int deflateEnd();
    internal int deflateParams(ZStream strm, int _level, int _strategy);
    internal int deflateSetDictionary(ZStream strm, Byte[] dictionary, int dictLength);
    internal int deflate(ZStream strm, int flush);
}
internal class System.util.zlib.InfBlocks : object {
    private static int MANY;
    private static int Z_OK;
    private static int Z_STREAM_END;
    private static int Z_NEED_DICT;
    private static int Z_ERRNO;
    private static int Z_STREAM_ERROR;
    private static int Z_DATA_ERROR;
    private static int Z_MEM_ERROR;
    private static int Z_BUF_ERROR;
    private static int Z_VERSION_ERROR;
    private static int TYPE;
    private static int LENS;
    private static int STORED;
    private static int TABLE;
    private static int BTREE;
    private static int DTREE;
    private static int CODES;
    private static int DRY;
    private static int DONE;
    private static int BAD;
    private static Int32[] inflate_mask;
    private static Int32[] border;
    internal int mode;
    internal int left;
    internal int table;
    internal int index;
    internal Int32[] blens;
    internal Int32[] bb;
    internal Int32[] tb;
    internal InfCodes codes;
    private int last;
    internal int bitk;
    internal int bitb;
    internal Int32[] hufts;
    internal Byte[] window;
    internal int end;
    internal int read;
    internal int write;
    internal object checkfn;
    internal long check;
    internal InfTree inftree;
    internal InfBlocks(ZStream z, object checkfn, int w);
    private static InfBlocks();
    internal void reset(ZStream z, Int64[] c);
    internal int proc(ZStream z, int r);
    internal void free(ZStream z);
    internal void set_dictionary(Byte[] d, int start, int n);
    internal int sync_point();
    internal int inflate_flush(ZStream z, int r);
}
internal class System.util.zlib.InfCodes : object {
    private static int Z_OK;
    private static int Z_STREAM_END;
    private static int Z_NEED_DICT;
    private static int Z_ERRNO;
    private static int Z_STREAM_ERROR;
    private static int Z_DATA_ERROR;
    private static int Z_MEM_ERROR;
    private static int Z_BUF_ERROR;
    private static int Z_VERSION_ERROR;
    private static int START;
    private static int LEN;
    private static int LENEXT;
    private static int DIST;
    private static int DISTEXT;
    private static int COPY;
    private static int LIT;
    private static int WASH;
    private static int END;
    private static int BADCODE;
    private static Int32[] inflate_mask;
    private int mode;
    private int len;
    private Int32[] tree;
    private int tree_index;
    private int need;
    private int lit;
    private int get;
    private int dist;
    private byte lbits;
    private byte dbits;
    private Int32[] ltree;
    private int ltree_index;
    private Int32[] dtree;
    private int dtree_index;
    private static InfCodes();
    internal void init(int bl, int bd, Int32[] tl, int tl_index, Int32[] td, int td_index, ZStream z);
    internal int proc(InfBlocks s, ZStream z, int r);
    internal void free(ZStream z);
    internal int inflate_fast(int bl, int bd, Int32[] tl, int tl_index, Int32[] td, int td_index, InfBlocks s, ZStream z);
}
internal class System.util.zlib.Inflate : object {
    private static int MAX_WBITS;
    private static int PRESET_DICT;
    internal static int Z_NO_FLUSH;
    internal static int Z_PARTIAL_FLUSH;
    internal static int Z_SYNC_FLUSH;
    internal static int Z_FULL_FLUSH;
    internal static int Z_FINISH;
    private static int Z_DEFLATED;
    private static int Z_OK;
    private static int Z_STREAM_END;
    private static int Z_NEED_DICT;
    private static int Z_ERRNO;
    private static int Z_STREAM_ERROR;
    private static int Z_DATA_ERROR;
    private static int Z_MEM_ERROR;
    private static int Z_BUF_ERROR;
    private static int Z_VERSION_ERROR;
    private static int METHOD;
    private static int FLAG;
    private static int DICT4;
    private static int DICT3;
    private static int DICT2;
    private static int DICT1;
    private static int DICT0;
    private static int BLOCKS;
    private static int CHECK4;
    private static int CHECK3;
    private static int CHECK2;
    private static int CHECK1;
    private static int DONE;
    private static int BAD;
    internal int mode;
    internal int method;
    internal Int64[] was;
    internal long need;
    internal int marker;
    internal int nowrap;
    internal int wbits;
    internal InfBlocks blocks;
    private static Byte[] mark;
    private static Inflate();
    internal int inflateReset(ZStream z);
    internal int inflateEnd(ZStream z);
    internal int inflateInit(ZStream z, int w);
    internal int inflate(ZStream z, int f);
    internal int inflateSetDictionary(ZStream z, Byte[] dictionary, int dictLength);
    internal int inflateSync(ZStream z);
    internal int inflateSyncPoint(ZStream z);
}
internal class System.util.zlib.InfTree : object {
    private static int MANY;
    private static int Z_OK;
    private static int Z_STREAM_END;
    private static int Z_NEED_DICT;
    private static int Z_ERRNO;
    private static int Z_STREAM_ERROR;
    private static int Z_DATA_ERROR;
    private static int Z_MEM_ERROR;
    private static int Z_BUF_ERROR;
    private static int Z_VERSION_ERROR;
    private static int fixed_bl;
    private static int fixed_bd;
    private static int BMAX;
    private static Int32[] fixed_tl;
    private static Int32[] fixed_td;
    private static Int32[] cplens;
    private static Int32[] cplext;
    private static Int32[] cpdist;
    private static Int32[] cpdext;
    private Int32[] hn;
    private Int32[] v;
    private Int32[] c;
    private Int32[] r;
    private Int32[] u;
    private Int32[] x;
    private static InfTree();
    private int huft_build(Int32[] b, int bindex, int n, int s, Int32[] d, Int32[] e, Int32[] t, Int32[] m, Int32[] hp, Int32[] hn, Int32[] v);
    internal int inflate_trees_bits(Int32[] c, Int32[] bb, Int32[] tb, Int32[] hp, ZStream z);
    internal int inflate_trees_dynamic(int nl, int nd, Int32[] c, Int32[] bl, Int32[] bd, Int32[] tl, Int32[] td, Int32[] hp, ZStream z);
    internal static int inflate_trees_fixed(Int32[] bl, Int32[] bd, Int32[][] tl, Int32[][] td, ZStream z);
    private void initWorkArea(int vsize);
}
public class System.util.zlib.JZlib : object {
    private static string _version;
    public static int Z_NO_COMPRESSION;
    public static int Z_BEST_SPEED;
    public static int Z_BEST_COMPRESSION;
    public static int Z_DEFAULT_COMPRESSION;
    public static int Z_FILTERED;
    public static int Z_HUFFMAN_ONLY;
    public static int Z_DEFAULT_STRATEGY;
    public static int Z_NO_FLUSH;
    public static int Z_PARTIAL_FLUSH;
    public static int Z_SYNC_FLUSH;
    public static int Z_FULL_FLUSH;
    public static int Z_FINISH;
    public static int Z_OK;
    public static int Z_STREAM_END;
    public static int Z_NEED_DICT;
    public static int Z_ERRNO;
    public static int Z_STREAM_ERROR;
    public static int Z_DATA_ERROR;
    public static int Z_MEM_ERROR;
    public static int Z_BUF_ERROR;
    public static int Z_VERSION_ERROR;
    public static string version();
}
internal class System.util.zlib.StaticTree : object {
    private static int MAX_BITS;
    private static int BL_CODES;
    private static int D_CODES;
    private static int LITERALS;
    private static int LENGTH_CODES;
    private static int L_CODES;
    internal static int MAX_BL_BITS;
    internal static Int16[] static_ltree;
    internal static Int16[] static_dtree;
    internal static StaticTree static_l_desc;
    internal static StaticTree static_d_desc;
    internal static StaticTree static_bl_desc;
    internal Int16[] static_tree;
    internal Int32[] extra_bits;
    internal int extra_base;
    internal int elems;
    internal int max_length;
    internal StaticTree(Int16[] static_tree, Int32[] extra_bits, int extra_base, int elems, int max_length);
    private static StaticTree();
}
internal class System.util.zlib.Tree : object {
    private static int MAX_BITS;
    private static int BL_CODES;
    private static int D_CODES;
    private static int LITERALS;
    private static int LENGTH_CODES;
    private static int L_CODES;
    private static int HEAP_SIZE;
    internal static int MAX_BL_BITS;
    internal static int END_BLOCK;
    internal static int REP_3_6;
    internal static int REPZ_3_10;
    internal static int REPZ_11_138;
    internal static int Buf_size;
    internal static int DIST_CODE_LEN;
    internal static Int32[] extra_lbits;
    internal static Int32[] extra_dbits;
    internal static Int32[] extra_blbits;
    internal static Byte[] bl_order;
    internal static Byte[] _dist_code;
    internal static Byte[] _length_code;
    internal static Int32[] base_length;
    internal static Int32[] base_dist;
    internal Int16[] dyn_tree;
    internal int max_code;
    internal StaticTree stat_desc;
    private static Tree();
    internal static int d_code(int dist);
    internal void gen_bitlen(Deflate s);
    internal void build_tree(Deflate s);
    internal static void gen_codes(Int16[] tree, int max_code, Int16[] bl_count);
    internal static int bi_reverse(int code, int len);
}
public class System.util.zlib.ZDeflaterOutputStream : Stream {
    private static int BUFSIZE;
    protected ZStream z;
    protected int flushLevel;
    protected Byte[] buf;
    private Byte[] buf1;
    protected Stream outp;
    public bool CanRead { get; }
    public bool CanSeek { get; }
    public bool CanWrite { get; }
    public long Length { get; }
    public long Position { get; public set; }
    public ZDeflaterOutputStream(Stream outp);
    public ZDeflaterOutputStream(Stream outp, int level);
    public ZDeflaterOutputStream(Stream outp, int level, bool nowrap);
    public virtual bool get_CanRead();
    public virtual bool get_CanSeek();
    public virtual bool get_CanWrite();
    public virtual long get_Length();
    public virtual long get_Position();
    public virtual void set_Position(long value);
    public virtual void Write(Byte[] b, int off, int len);
    public virtual long Seek(long offset, SeekOrigin origin);
    public virtual void SetLength(long value);
    public virtual int Read(Byte[] buffer, int offset, int count);
    public virtual void Flush();
    public virtual void WriteByte(byte b);
    public virtual void Finish();
    public virtual void End();
    public virtual void Close();
}
public class System.util.zlib.ZInflaterInputStream : Stream {
    private static int BUFSIZE;
    protected ZStream z;
    protected int flushLevel;
    protected Byte[] buf;
    private Byte[] buf1;
    protected Stream inp;
    private bool nomoreinput;
    public bool CanRead { get; }
    public bool CanSeek { get; }
    public bool CanWrite { get; }
    public long Length { get; }
    public long Position { get; public set; }
    public ZInflaterInputStream(Stream inp);
    public ZInflaterInputStream(Stream inp, bool nowrap);
    public virtual bool get_CanRead();
    public virtual bool get_CanSeek();
    public virtual bool get_CanWrite();
    public virtual long get_Length();
    public virtual long get_Position();
    public virtual void set_Position(long value);
    public virtual void Write(Byte[] b, int off, int len);
    public virtual long Seek(long offset, SeekOrigin origin);
    public virtual void SetLength(long value);
    public virtual int Read(Byte[] b, int off, int len);
    public virtual void Flush();
    public virtual void WriteByte(byte b);
    public virtual void Close();
    public virtual int ReadByte();
}
public class System.util.zlib.ZInputStream : Stream {
    private static int BufferSize;
    protected ZStream z;
    protected int flushLevel;
    protected Byte[] buf;
    protected Byte[] buf1;
    protected bool compress;
    protected Stream input;
    protected bool closed;
    private bool nomoreinput;
    public bool CanRead { get; }
    public bool CanSeek { get; }
    public bool CanWrite { get; }
    public int FlushMode { get; public set; }
    public long Length { get; }
    public long Position { get; public set; }
    public long TotalIn { get; }
    public long TotalOut { get; }
    public ZInputStream(Stream input);
    public ZInputStream(Stream input, bool nowrap);
    public ZInputStream(Stream input, int level);
    public sealed virtual bool get_CanRead();
    public sealed virtual bool get_CanSeek();
    public sealed virtual bool get_CanWrite();
    public virtual void Close();
    public sealed virtual void Flush();
    public virtual int get_FlushMode();
    public virtual void set_FlushMode(int value);
    public sealed virtual long get_Length();
    public sealed virtual long get_Position();
    public sealed virtual void set_Position(long value);
    public virtual int Read(Byte[] b, int off, int len);
    public virtual int ReadByte();
    public sealed virtual long Seek(long offset, SeekOrigin origin);
    public sealed virtual void SetLength(long value);
    public virtual long get_TotalIn();
    public virtual long get_TotalOut();
    public sealed virtual void Write(Byte[] buffer, int offset, int count);
}
public class System.util.zlib.ZOutputStream : Stream {
    private static int BufferSize;
    protected ZStream z;
    protected int flushLevel;
    protected Byte[] buf;
    protected Byte[] buf1;
    protected bool compress;
    protected Stream output;
    protected bool closed;
    public bool CanRead { get; }
    public bool CanSeek { get; }
    public bool CanWrite { get; }
    public int FlushMode { get; public set; }
    public long Length { get; }
    public long Position { get; public set; }
    public long TotalIn { get; }
    public long TotalOut { get; }
    public ZOutputStream(Stream output);
    public ZOutputStream(Stream output, int level);
    public ZOutputStream(Stream output, int level, bool nowrap);
    public sealed virtual bool get_CanRead();
    public sealed virtual bool get_CanSeek();
    public sealed virtual bool get_CanWrite();
    public virtual void Close();
    public virtual void End();
    public virtual void Finish();
    public virtual void Flush();
    public virtual int get_FlushMode();
    public virtual void set_FlushMode(int value);
    public sealed virtual long get_Length();
    public sealed virtual long get_Position();
    public sealed virtual void set_Position(long value);
    public sealed virtual int Read(Byte[] buffer, int offset, int count);
    public sealed virtual long Seek(long offset, SeekOrigin origin);
    public sealed virtual void SetLength(long value);
    public virtual long get_TotalIn();
    public virtual long get_TotalOut();
    public virtual void Write(Byte[] b, int off, int len);
    public virtual void WriteByte(byte b);
}
public class System.util.zlib.ZStream : object {
    private static int MAX_WBITS;
    private static int DEF_WBITS;
    private static int Z_NO_FLUSH;
    private static int Z_PARTIAL_FLUSH;
    private static int Z_SYNC_FLUSH;
    private static int Z_FULL_FLUSH;
    private static int Z_FINISH;
    private static int MAX_MEM_LEVEL;
    private static int Z_OK;
    private static int Z_STREAM_END;
    private static int Z_NEED_DICT;
    private static int Z_ERRNO;
    private static int Z_STREAM_ERROR;
    private static int Z_DATA_ERROR;
    private static int Z_MEM_ERROR;
    private static int Z_BUF_ERROR;
    private static int Z_VERSION_ERROR;
    public Byte[] next_in;
    public int next_in_index;
    public int avail_in;
    public long total_in;
    public Byte[] next_out;
    public int next_out_index;
    public int avail_out;
    public long total_out;
    public string msg;
    internal Deflate dstate;
    internal Inflate istate;
    internal int data_type;
    public long adler;
    internal Adler32 _adler;
    public int inflateInit();
    public int inflateInit(bool nowrap);
    public int inflateInit(int w);
    public int inflateInit(int w, bool nowrap);
    public int inflate(int f);
    public int inflateEnd();
    public int inflateSync();
    public int inflateSetDictionary(Byte[] dictionary, int dictLength);
    public int deflateInit(int level);
    public int deflateInit(int level, bool nowrap);
    public int deflateInit(int level, int bits);
    public int deflateInit(int level, int bits, bool nowrap);
    public int deflate(int flush);
    public int deflateEnd();
    public int deflateParams(int level, int strategy);
    public int deflateSetDictionary(Byte[] dictionary, int dictLength);
    internal void flush_pending();
    internal int read_buf(Byte[] buf, int start, int size);
    public void free();
}
[AttributeUsageAttribute("1")]
internal class Versions.Attributes.KeyVersionAttribute : Attribute {
    private string keyVersion;
    internal string KeyVersion { get; private set; }
    internal KeyVersionAttribute(string keyVersion);
    internal string get_KeyVersion();
    private void set_KeyVersion(string value);
}
