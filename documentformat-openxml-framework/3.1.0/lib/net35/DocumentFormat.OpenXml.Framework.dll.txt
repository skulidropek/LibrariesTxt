[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class DocumentFormat.OpenXml.AlternateContent : OpenXmlCompositeElement {
    internal static OpenXmlQualifiedName InternalQName;
    public static string MarkupCompatibilityNamespace { get; }
    public static string TagName { get; }
    public string LocalName { get; }
    public AlternateContent(IEnumerable`1<OpenXmlElement> childElements);
    public AlternateContent(OpenXmlElement[] childElements);
    public AlternateContent(string outerXml);
    private static AlternateContent();
    public static string get_MarkupCompatibilityNamespace();
    public static string get_TagName();
    public virtual string get_LocalName();
    public AlternateContentChoice AppendNewAlternateContentChoice();
    public AlternateContentFallback AppendNewAlternateContentFallback();
    public virtual OpenXmlElement CloneNode(bool deep);
    internal virtual void ConfigureMetadata(Builder builder);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class DocumentFormat.OpenXml.AlternateContentChoice : OpenXmlCompositeElement {
    private static string Name;
    internal static OpenXmlQualifiedName InternalQName { get; }
    public static string TagName { get; }
    public string LocalName { get; }
    [NullableAttribute("2")]
public StringValue Requires { get; public set; }
    public AlternateContentChoice(IEnumerable`1<OpenXmlElement> childElements);
    public AlternateContentChoice(OpenXmlElement[] childElements);
    public AlternateContentChoice(string outerXml);
    internal static OpenXmlQualifiedName get_InternalQName();
    public static string get_TagName();
    public virtual string get_LocalName();
    [NullableContextAttribute("2")]
public StringValue get_Requires();
    [NullableContextAttribute("2")]
public void set_Requires(StringValue value);
    [NullableContextAttribute("2")]
internal virtual OpenXmlElement ElementFactory(OpenXmlQualifiedName& modreq(System.Runtime.InteropServices.InAttribute) qname);
    public virtual OpenXmlElement CloneNode(bool deep);
    internal virtual void ConfigureMetadata(Builder builder);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class DocumentFormat.OpenXml.AlternateContentFallback : OpenXmlCompositeElement {
    private static string Name;
    internal static OpenXmlQualifiedName InternalQName { get; }
    public static string TagName { get; }
    public AlternateContentFallback(IEnumerable`1<OpenXmlElement> childElements);
    public AlternateContentFallback(OpenXmlElement[] childElements);
    public AlternateContentFallback(string outerXml);
    internal static OpenXmlQualifiedName get_InternalQName();
    public static string get_TagName();
    [NullableContextAttribute("2")]
internal virtual OpenXmlElement ElementFactory(OpenXmlQualifiedName& modreq(System.Runtime.InteropServices.InAttribute) qname);
    public virtual OpenXmlElement CloneNode(bool deep);
    internal virtual void ConfigureMetadata(Builder builder);
}
[FlagsAttribute]
internal enum DocumentFormat.OpenXml.ApplicationType : Enum {
    public int value__;
    public static ApplicationType None;
    public static ApplicationType Word;
    public static ApplicationType Excel;
    public static ApplicationType PowerPoint;
    public static ApplicationType All;
}
internal enum DocumentFormat.OpenXml.AttributeAction : Enum {
    public int value__;
    public static AttributeAction Normal;
    public static AttributeAction Ignore;
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[DebuggerDisplayAttribute("{InnerText}")]
public class DocumentFormat.OpenXml.Base64BinaryValue : StringValue {
    [NullableAttribute("2")]
public string Value { get; public set; }
    internal bool IsValid { get; }
    internal int Length { get; }
    [NullableContextAttribute("2")]
public Base64BinaryValue(string base64Binary);
    public Base64BinaryValue(Base64BinaryValue source);
    [NullableContextAttribute("2")]
public virtual string get_Value();
    [NullableContextAttribute("2")]
public virtual void set_Value(string value);
    internal virtual bool get_IsValid();
    internal virtual int get_Length();
    [NullableContextAttribute("2")]
public static string op_Implicit(Base64BinaryValue value);
    public static Base64BinaryValue op_Implicit(string value);
    public static Base64BinaryValue FromString(string value);
    public static string ToString(Base64BinaryValue value);
    private protected virtual OpenXmlSimpleType CloneImpl();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[DebuggerDisplayAttribute("{InnerText}")]
public class DocumentFormat.OpenXml.BooleanValue : OpenXmlComparableSimpleValue`1<bool> {
    public BooleanValue(bool value);
    public BooleanValue(BooleanValue source);
    private protected virtual string GetText(bool input);
    private protected virtual bool Parse(string input);
    public static bool op_Implicit(BooleanValue value);
    public static BooleanValue op_Implicit(bool value);
    public static BooleanValue FromBoolean(bool value);
    public static bool ToBoolean(BooleanValue value);
    private protected virtual OpenXmlSimpleType CloneImpl();
}
[NullableContextAttribute("1")]
[ExperimentalAttribute("OOXML0002")]
[ObsoleteAttribute("This is an experimental APIs and is subject to change")]
internal interface DocumentFormat.OpenXml.Builder.IPackageBuilder`1 {
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public IDictionary`2<string, object> Properties { get; }
    public abstract virtual IDictionary`2<string, object> get_Properties();
    public abstract virtual IPackageBuilder`1<TPackage> Use(Func`2<PackageInitializerDelegate`1<TPackage>, PackageInitializerDelegate`1<TPackage>> configure);
    public abstract virtual IPackageBuilder`1<TPackage> Clone();
    public abstract virtual IPackageFactory`1<TPackage> Build();
}
[NullableContextAttribute("1")]
[ExperimentalAttribute("OOXML0002")]
[ObsoleteAttribute("This is an experimental APIs and is subject to change")]
internal interface DocumentFormat.OpenXml.Builder.IPackageFactory`1 {
    public abstract virtual TPackage Create(IPackageInitializer initializer);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal abstract class DocumentFormat.OpenXml.Builder.OpenXmlPackageBuilder`1 : object {
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private Dictionary`2<string, object> _properties;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private PackageInitializerDelegate`1<TPackage> _pipeline;
    private bool _isLocked;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private List`1<Func`2<PackageInitializerDelegate`1<TPackage>, PackageInitializerDelegate`1<TPackage>>> _middleware;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public IDictionary`2<string, object> Properties { get; }
    internal OpenXmlPackageBuilder`1(OpenXmlPackageBuilder`1<TPackage> parent);
    public sealed virtual IDictionary`2<string, object> get_Properties();
    public sealed virtual IPackageBuilder`1<TPackage> Use(Func`2<PackageInitializerDelegate`1<TPackage>, PackageInitializerDelegate`1<TPackage>> configure);
    public abstract virtual IPackageBuilder`1<TPackage> Clone();
    public abstract virtual TPackage Create();
    public sealed virtual IPackageFactory`1<TPackage> Build();
    [MemberNotNullAttribute("_pipeline")]
private PackageInitializerDelegate`1<TPackage> BuildPipeline();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
[ExperimentalAttribute("OOXML0002")]
[ObsoleteAttribute("This is an experimental APIs and is subject to change")]
internal static class DocumentFormat.OpenXml.Builder.OpenXmlPackageBuilderExtensions : object {
    [ExtensionAttribute]
public static TPackage Open(IPackageFactory`1<TPackage> builder, Stream stream, PackageOpenMode mode);
    [ExtensionAttribute]
public static TPackage Open(IPackageFactory`1<TPackage> builder, string file, PackageOpenMode mode);
    [ExtensionAttribute]
public static TPackage Open(IPackageFactory`1<TPackage> builder, Package package);
    [ExtensionAttribute]
internal static TPackage Open(IPackageFactory`1<TPackage> builder, string file, bool isEditing);
    [ExtensionAttribute]
internal static TPackage Open(IPackageFactory`1<TPackage> builder, Stream stream, bool isEditing);
    [ExtensionAttribute]
internal static TPackage Open(IPackageFactory`1<TPackage> builder);
    [ExtensionAttribute]
internal static TPackage Use(TPackage package, PackageInitializerDelegate`1<TPackage> action);
    [ExtensionAttribute]
internal static IPackageBuilder`1<TPackage> Use(IPackageBuilder`1<TPackage> builder, PackageInitializerDelegate`1<TPackage> action);
    [ExtensionAttribute]
public static IPackageBuilder`1<TPackage> Use(IPackageBuilder`1<TPackage> builder, Action`2<TPackage, PackageInitializerDelegate`1<TPackage>> middleware);
    [ExtensionAttribute]
internal static IPackageBuilder`1<TPackage> UseSettings(IPackageBuilder`1<TPackage> builder, OpenSettings settings);
    [ExtensionAttribute]
internal static IPackageBuilder`1<TPackage> UseDefaultBehaviorAndLockBuilder(IPackageBuilder`1<TPackage> builder);
    private static void ValidateSettings(OpenXmlPackage package);
}
internal class DocumentFormat.OpenXml.Builder.PackageInitializerDelegate`1 : MulticastDelegate {
    public PackageInitializerDelegate`1(object object, IntPtr method);
    [NullableContextAttribute("1")]
public virtual void Invoke(TPackage package);
    public virtual IAsyncResult BeginInvoke(TPackage package, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
[ExperimentalAttribute("OOXML0002")]
[ObsoleteAttribute("This is an experimental APIs and is subject to change")]
internal enum DocumentFormat.OpenXml.Builder.PackageOpenMode : Enum {
    public int value__;
    public static PackageOpenMode Create;
    public static PackageOpenMode Read;
    public static PackageOpenMode ReadWrite;
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
[ExperimentalAttribute("OOXML0003")]
[ObsoleteAttribute("This is an experimental APIs and is subject to change")]
internal static class DocumentFormat.OpenXml.Builder.SchemaTrackingExtensions : object {
    private static string Key;
    [ExtensionAttribute]
public static IPackageBuilder`1<T> UseSchemaTracker(IPackageBuilder`1<T> builder);
    [ExtensionAttribute]
public static ISchemaTrackingFeature GetSchemaTracker(IPackageBuilder`1<T> builder);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
internal static class DocumentFormat.OpenXml.Builder.StorageBuilderExtensions : object {
    [ExtensionAttribute]
public static TPackage WithStorage(TPackage package, Stream stream, PackageOpenMode mode);
    [ExtensionAttribute]
public static TPackage WithStorage(TPackage oPackage, Package package);
    [ExtensionAttribute]
public static TPackage WithStorage(TPackage package, string path, PackageOpenMode mode);
    [ExtensionAttribute]
private static void SetPackageFeatures(OpenXmlPackage package, PackageFeatureBase packageFeature);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
[ExperimentalAttribute("OOXML0002")]
[ObsoleteAttribute("This is an experimental APIs and is subject to change")]
internal static class DocumentFormat.OpenXml.Builder.TemplateBuilderExtensions : object {
    [ExtensionAttribute]
public static IPackageBuilder`1<TPackage> UseTemplate(IPackageBuilder`1<TPackage> builder, string path, TType type);
    [ExtensionAttribute]
internal static IPackageBuilder`1<TPackage> CreateTemplateBuilder(IPackageBuilder`1<TPackage> builder, Func`2<IPackageFactory`1<TPackage>, TPackage> templateFactory, Action`1<TPackage> onLoad);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[DebuggerDisplayAttribute("{InnerText}")]
public class DocumentFormat.OpenXml.ByteValue : OpenXmlComparableSimpleValue`1<byte> {
    public ByteValue(byte value);
    public ByteValue(ByteValue source);
    private protected virtual string GetText(byte input);
    private protected virtual byte Parse(string input);
    public static byte op_Implicit(ByteValue value);
    public static ByteValue op_Implicit(byte value);
    public static ByteValue FromByte(byte value);
    public static byte ToByte(ByteValue value);
    private protected virtual OpenXmlSimpleType CloneImpl();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[DebuggerDisplayAttribute("{InnerText}")]
public class DocumentFormat.OpenXml.DateTimeValue : OpenXmlComparableSimpleValue`1<DateTime> {
    public DateTimeValue(DateTime value);
    public DateTimeValue(DateTimeValue source);
    private protected virtual string GetText(DateTime input);
    private protected virtual DateTime Parse(string input);
    public static DateTime op_Implicit(DateTimeValue value);
    public static DateTimeValue op_Implicit(DateTime value);
    public static DateTimeValue FromDateTime(DateTime value);
    public static DateTime ToDateTime(DateTimeValue value);
    private protected virtual OpenXmlSimpleType CloneImpl();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[DebuggerDisplayAttribute("{InnerText}")]
public class DocumentFormat.OpenXml.DecimalValue : OpenXmlComparableSimpleValue`1<decimal> {
    public DecimalValue(decimal value);
    public DecimalValue(DecimalValue source);
    private protected virtual string GetText(decimal input);
    private protected virtual decimal Parse(string input);
    public static decimal op_Implicit(DecimalValue value);
    public static DecimalValue op_Implicit(decimal value);
    public static DecimalValue FromDecimal(decimal value);
    public static decimal ToDecimal(DecimalValue value);
    private protected virtual OpenXmlSimpleType CloneImpl();
}
[ExtensionAttribute]
internal static class DocumentFormat.OpenXml.DictionaryExtensions : object {
    [NullableContextAttribute("1")]
[ExtensionAttribute]
public static bool TryAdd(Dictionary`2<TKey, TValue> dict, TKey key, TValue value);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[DebuggerDisplayAttribute("{InnerText}")]
public class DocumentFormat.OpenXml.DoubleValue : OpenXmlComparableSimpleValue`1<double> {
    public DoubleValue(double value);
    public DoubleValue(DoubleValue source);
    private protected virtual string GetText(double input);
    private protected virtual double Parse(string input);
    public static double op_Implicit(DoubleValue value);
    public static DoubleValue op_Implicit(double value);
    public static DoubleValue FromDouble(double value);
    public static double ToDouble(DoubleValue value);
    private protected virtual OpenXmlSimpleType CloneImpl();
}
internal enum DocumentFormat.OpenXml.ElementAction : Enum {
    public int value__;
    public static ElementAction Normal;
    public static ElementAction Ignore;
    public static ElementAction ProcessContent;
    public static ElementAction ACBlock;
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class DocumentFormat.OpenXml.ElementEventArgs : EventArgs {
    [CompilerGeneratedAttribute]
private OpenXmlElement <Element>k__BackingField;
    [CompilerGeneratedAttribute]
private OpenXmlElement <ParentElement>k__BackingField;
    public OpenXmlElement Element { get; }
    public OpenXmlElement ParentElement { get; }
    public ElementEventArgs(OpenXmlElement element, OpenXmlElement parentElement);
    [CompilerGeneratedAttribute]
public OpenXmlElement get_Element();
    [CompilerGeneratedAttribute]
public OpenXmlElement get_ParentElement();
}
internal enum DocumentFormat.OpenXml.ElementState : Enum {
    public int value__;
    public static ElementState Null;
    public static ElementState Start;
    public static ElementState End;
    public static ElementState LeafStart;
    public static ElementState LeafEnd;
    public static ElementState LoadEnd;
    public static ElementState MiscNode;
    public static ElementState EOF;
}
[ExtensionAttribute]
internal static class DocumentFormat.OpenXml.EnumExtensions : object {
    [ExtensionAttribute]
public static bool HasFlagFast(T e, T value);
}
internal static class DocumentFormat.OpenXml.EnumHelper : object {
    public static bool TryParse(string value, TEnum& result);
}
[DebuggerDisplayAttribute("{InnerText}")]
public class DocumentFormat.OpenXml.EnumValue`1 : OpenXmlSimpleValue`1<T> {
    internal bool IsEnum { get; }
    public EnumValue`1(T value);
    public EnumValue`1(EnumValue`1<T> source);
    internal virtual bool get_IsEnum();
    public static T op_Implicit(EnumValue`1<T> value);
    public static EnumValue`1<T> op_Implicit(T value);
    [NullableContextAttribute("2")]
public static string op_Implicit(EnumValue`1<T> value);
    [NullableContextAttribute("1")]
private protected virtual OpenXmlSimpleType CloneImpl();
    internal virtual bool IsInVersion(FileFormatVersions fileFormat);
    [NullableContextAttribute("2")]
private protected virtual bool ShouldParse(string value);
    private protected virtual void ValidateSet(T value);
    private protected virtual string GetText(T input);
    private protected virtual bool TryParse(string input, T& value);
    private protected virtual T Parse(string input);
}
[GeneratedCodeAttribute("System.Resources.Tools.StronglyTypedResourceBuilder", "17.0.0.0")]
[DebuggerNonUserCodeAttribute]
[CompilerGeneratedAttribute]
internal class DocumentFormat.OpenXml.ExceptionMessages : object {
    private static ResourceManager resourceMan;
    private static CultureInfo resourceCulture;
    [EditorBrowsableAttribute("2")]
internal static ResourceManager ResourceManager { get; }
    [EditorBrowsableAttribute("2")]
internal static CultureInfo Culture { get; internal set; }
    internal static string AddedPartIsNotAllowed { get; }
    internal static string AnyParticleTypeNotSupported { get; }
    internal static string CannotChangeDocumentType { get; }
    internal static string CannotChangeDocumentTypeSerious { get; }
    internal static string CannotFindAttribute { get; }
    internal static string CannotLoadRootElement { get; }
    internal static string CannotReloadDomTreeWithoutAssociatedPart { get; }
    internal static string CannotSaveDomTreeWithoutAssociatedPart { get; }
    internal static string CannotSetAttribute { get; }
    internal static string CannotValidateAcbElement { get; }
    internal static string CannotValidateMiscNode { get; }
    internal static string CannotValidateUnknownElement { get; }
    internal static string CycleReference { get; }
    internal static string DataPartIsInUse { get; }
    internal static string DataPartReferenceIsNotAllowed { get; }
    internal static string DocumentFileFormatVersionMismatch { get; }
    internal static string DocumentTooBig { get; }
    internal static string DuplicatedPrefix { get; }
    internal static string ElementIsNotChild { get; }
    internal static string ElementIsNotInOfficeVersion { get; }
    internal static string ElementIsPartOfTree { get; }
    internal static string EmptyCollection { get; }
    internal static string ErrorContentType { get; }
    internal static string ExtendedPartIsOpenXmlPart { get; }
    internal static string ExtendedPartNotAllowed { get; }
    internal static string ExternalRelationshipIsNotReferenced { get; }
    internal static string FailedToOpenPackage { get; }
    internal static string FeatureNotRegistered { get; }
    internal static string FileFormatNotSupported { get; }
    internal static string FileNotFound { get; }
    internal static string Fmt_PartRootIsInvalid { get; }
    internal static string ForeignDataPart { get; }
    internal static string ForeignMediaDataPart { get; }
    internal static string ForeignOpenXmlPart { get; }
    internal static string HyperlinkRelationshipIsNotReferenced { get; }
    internal static string ImplicitConversionExceptionOnNull { get; }
    internal static string InnerXmlCannotBeSet { get; }
    internal static string InvalidContentTypePart { get; }
    internal static string InvalidEnumValue { get; }
    internal static string InvalidMainPartContentType { get; }
    internal static string InvalidMCMode { get; }
    internal static string InvalidOuterXml { get; }
    internal static string InvalidOuterXmlForMiscNode { get; }
    internal static string InvalidPackageType { get; }
    internal static string InvalidPartContentType { get; }
    internal static string InvalidWriteStringCall { get; }
    internal static string InvalidXmlIDStringException { get; }
    internal static string LeafElementInnerXmlCannotBeSet { get; }
    internal static string LocalNameIsNull { get; }
    internal static string MainPartIsDifferent { get; }
    internal static string MalformedUri { get; }
    internal static string MediaDataPartShouldNotReferenceOtherParts { get; }
    internal static string MultipleRelationshipsToSamePart { get; }
    internal static string NamespaceIdNotAvailable { get; }
    internal static string NoMainPart { get; }
    internal static string NonCompositeNoChild { get; }
    internal static string NonImplemented { get; }
    internal static string NoSpecifiedExternalRelationship { get; }
    internal static string NoSpecifiedHyperlinkRelationship { get; }
    internal static string NoSpecifiedReferenceRelationship { get; }
    internal static string NsNotUnderStand { get; }
    internal static string OnlyOnePartAllowed { get; }
    internal static string PackageAccessModeIsReadonly { get; }
    internal static string PackageMustCanBeRead { get; }
    internal static string PackageRelatedArgumentNullException { get; }
    internal static string ParentIsNull { get; }
    internal static string PartExistsWithDifferentRelationshipId { get; }
    internal static string PartIsDestroyed { get; }
    internal static string PartIsEmpty { get; }
    internal static string PartIsNotAllowed { get; }
    internal static string PartIsNotInOfficeVersion { get; }
    internal static string PartNotInSamePackage { get; }
    internal static string PartRootAlreadyHasAssociation { get; }
    internal static string PartUnknown { get; }
    internal static string PropertyMutualExclusive { get; }
    internal static string ReaderInEndState { get; }
    internal static string ReaderInEofState { get; }
    internal static string ReaderInNullState { get; }
    internal static string ReferenceRelationshipIsNotReferenced { get; }
    internal static string RelationshipIdConflict { get; }
    internal static string RequiredPartDoNotExist { get; }
    internal static string RootElementIsNull { get; }
    internal static string SamePartWithDifferentRelationshipType { get; }
    internal static string StreamAccessModeShouldBeWrite { get; }
    internal static string StreamAccessModeShouldRead { get; }
    internal static string StrictReadOnly { get; }
    internal static string StringArgumentEmptyException { get; }
    internal static string StringIsEmpty { get; }
    internal static string TextIsInvalidEnumValue { get; }
    internal static string TextIsInvalidOnOffValue { get; }
    internal static string TextIsInvalidTrueFalseBlankValue { get; }
    internal static string TextIsInvalidTrueFalseValue { get; }
    internal static string UnexpectedReentrancy { get; }
    internal static string UnknowMCContent { get; }
    internal static string UnknownError { get; }
    internal static string UnknownPackage { get; }
    internal static string UseAddHyperlinkRelationship { get; }
    internal static string ValidationException { get; }
    internal static ResourceManager get_ResourceManager();
    internal static CultureInfo get_Culture();
    internal static void set_Culture(CultureInfo value);
    internal static string get_AddedPartIsNotAllowed();
    internal static string get_AnyParticleTypeNotSupported();
    internal static string get_CannotChangeDocumentType();
    internal static string get_CannotChangeDocumentTypeSerious();
    internal static string get_CannotFindAttribute();
    internal static string get_CannotLoadRootElement();
    internal static string get_CannotReloadDomTreeWithoutAssociatedPart();
    internal static string get_CannotSaveDomTreeWithoutAssociatedPart();
    internal static string get_CannotSetAttribute();
    internal static string get_CannotValidateAcbElement();
    internal static string get_CannotValidateMiscNode();
    internal static string get_CannotValidateUnknownElement();
    internal static string get_CycleReference();
    internal static string get_DataPartIsInUse();
    internal static string get_DataPartReferenceIsNotAllowed();
    internal static string get_DocumentFileFormatVersionMismatch();
    internal static string get_DocumentTooBig();
    internal static string get_DuplicatedPrefix();
    internal static string get_ElementIsNotChild();
    internal static string get_ElementIsNotInOfficeVersion();
    internal static string get_ElementIsPartOfTree();
    internal static string get_EmptyCollection();
    internal static string get_ErrorContentType();
    internal static string get_ExtendedPartIsOpenXmlPart();
    internal static string get_ExtendedPartNotAllowed();
    internal static string get_ExternalRelationshipIsNotReferenced();
    internal static string get_FailedToOpenPackage();
    internal static string get_FeatureNotRegistered();
    internal static string get_FileFormatNotSupported();
    internal static string get_FileNotFound();
    internal static string get_Fmt_PartRootIsInvalid();
    internal static string get_ForeignDataPart();
    internal static string get_ForeignMediaDataPart();
    internal static string get_ForeignOpenXmlPart();
    internal static string get_HyperlinkRelationshipIsNotReferenced();
    internal static string get_ImplicitConversionExceptionOnNull();
    internal static string get_InnerXmlCannotBeSet();
    internal static string get_InvalidContentTypePart();
    internal static string get_InvalidEnumValue();
    internal static string get_InvalidMainPartContentType();
    internal static string get_InvalidMCMode();
    internal static string get_InvalidOuterXml();
    internal static string get_InvalidOuterXmlForMiscNode();
    internal static string get_InvalidPackageType();
    internal static string get_InvalidPartContentType();
    internal static string get_InvalidWriteStringCall();
    internal static string get_InvalidXmlIDStringException();
    internal static string get_LeafElementInnerXmlCannotBeSet();
    internal static string get_LocalNameIsNull();
    internal static string get_MainPartIsDifferent();
    internal static string get_MalformedUri();
    internal static string get_MediaDataPartShouldNotReferenceOtherParts();
    internal static string get_MultipleRelationshipsToSamePart();
    internal static string get_NamespaceIdNotAvailable();
    internal static string get_NoMainPart();
    internal static string get_NonCompositeNoChild();
    internal static string get_NonImplemented();
    internal static string get_NoSpecifiedExternalRelationship();
    internal static string get_NoSpecifiedHyperlinkRelationship();
    internal static string get_NoSpecifiedReferenceRelationship();
    internal static string get_NsNotUnderStand();
    internal static string get_OnlyOnePartAllowed();
    internal static string get_PackageAccessModeIsReadonly();
    internal static string get_PackageMustCanBeRead();
    internal static string get_PackageRelatedArgumentNullException();
    internal static string get_ParentIsNull();
    internal static string get_PartExistsWithDifferentRelationshipId();
    internal static string get_PartIsDestroyed();
    internal static string get_PartIsEmpty();
    internal static string get_PartIsNotAllowed();
    internal static string get_PartIsNotInOfficeVersion();
    internal static string get_PartNotInSamePackage();
    internal static string get_PartRootAlreadyHasAssociation();
    internal static string get_PartUnknown();
    internal static string get_PropertyMutualExclusive();
    internal static string get_ReaderInEndState();
    internal static string get_ReaderInEofState();
    internal static string get_ReaderInNullState();
    internal static string get_ReferenceRelationshipIsNotReferenced();
    internal static string get_RelationshipIdConflict();
    internal static string get_RequiredPartDoNotExist();
    internal static string get_RootElementIsNull();
    internal static string get_SamePartWithDifferentRelationshipType();
    internal static string get_StreamAccessModeShouldBeWrite();
    internal static string get_StreamAccessModeShouldRead();
    internal static string get_StrictReadOnly();
    internal static string get_StringArgumentEmptyException();
    internal static string get_StringIsEmpty();
    internal static string get_TextIsInvalidEnumValue();
    internal static string get_TextIsInvalidOnOffValue();
    internal static string get_TextIsInvalidTrueFalseBlankValue();
    internal static string get_TextIsInvalidTrueFalseValue();
    internal static string get_UnexpectedReentrancy();
    internal static string get_UnknowMCContent();
    internal static string get_UnknownError();
    internal static string get_UnknownPackage();
    internal static string get_UseAddHyperlinkRelationship();
    internal static string get_ValidationException();
}
[ExtensionAttribute]
[ExperimentalAttribute("OOXML0001")]
[ObsoleteAttribute("This is an experimental APIs and is subject to change")]
public static class DocumentFormat.OpenXml.Experimental.PackageExtensions : object {
    [NullableContextAttribute("1")]
[ExtensionAttribute]
public static IPackage GetPackage(OpenXmlPackage package);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal static class DocumentFormat.OpenXml.ExperimentalApis : object {
    internal static string Message;
    internal static string UrlFormat;
    public static string IPackage;
    public static string PackageBuilder;
    public static string AOT;
    public static string Framework;
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class DocumentFormat.OpenXml.Features.AnnotationsFeature : object {
    [NullableAttribute("2")]
private object _annotations;
    public void AddAnnotation(object annotation);
    public T Annotation();
    public object Annotation(Type type);
    public IEnumerable`1<T> Annotations();
    public IEnumerable`1<object> Annotations(Type type);
    public void RemoveAnnotations();
    public void RemoveAnnotations(Type type);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[DefaultMemberAttribute("Item")]
internal class DocumentFormat.OpenXml.Features.DefaultFeatures : object {
    [NullableAttribute("2")]
private IOpenXmlNamespaceResolver _openXmlNamespaceResolver;
    [NullableAttribute("2")]
private IElementMetadataFactoryFeature _elementMetadata;
    [CompilerGeneratedAttribute]
private static IFeatureCollection <Shared>k__BackingField;
    [NullableAttribute("2")]
public object Item { get; public set; }
    public static IFeatureCollection Shared { get; }
    public bool IsReadOnly { get; }
    public int Revision { get; }
    private static DefaultFeatures();
    public sealed virtual object get_Item(Type key);
    public sealed virtual void set_Item(Type key, object value);
    [CompilerGeneratedAttribute]
public static IFeatureCollection get_Shared();
    public sealed virtual bool get_IsReadOnly();
    public sealed virtual int get_Revision();
    public sealed virtual IEnumerator`1<KeyValuePair`2<Type, object>> GetEnumerator();
    [NullableContextAttribute("2")]
private KeyValuePair`2<Type, object> GetPair();
    [NullableContextAttribute("2")]
public sealed virtual void Set(TFeature instance);
    [NullableContextAttribute("2")]
public sealed virtual TFeature Get();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
}
[ExtensionAttribute]
public static class DocumentFormat.OpenXml.Features.DisposableFeatureExtensions : object {
    [NullableContextAttribute("1")]
[ExtensionAttribute]
public static void Register(IDisposableFeature feature, IDisposable disposable);
}
public enum DocumentFormat.OpenXml.Features.EventType : Enum {
    public int value__;
    public static EventType None;
    public static EventType Closed;
    public static EventType Closing;
    public static EventType Deleting;
    public static EventType Deleted;
    public static EventType Creating;
    public static EventType Created;
    public static EventType Removing;
    public static EventType Removed;
    public static EventType Reloading;
    public static EventType Reloaded;
    public static EventType Saved;
    public static EventType Saving;
    public static EventType Adding;
    public static EventType Added;
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[DefaultMemberAttribute("Item")]
[DebuggerDisplayAttribute("Count = {GetCount()}")]
[DebuggerTypeProxyAttribute("DocumentFormat.OpenXml.Packaging.FeatureCollectionDebugView")]
public class DocumentFormat.OpenXml.Features.FeatureCollection : object {
    [NullableAttribute("2")]
private IFeatureCollection _defaults;
    private FeatureContainer _container;
    [CompilerGeneratedAttribute]
private bool <IsReadOnly>k__BackingField;
    public int Revision { get; }
    public bool IsReadOnly { get; }
    internal static IFeatureCollection Default { get; }
    [NullableAttribute("2")]
public object Item { get; public set; }
    public FeatureCollection(int initialCapacity);
    public FeatureCollection(IFeatureCollection defaults, bool isReadOnly);
    public virtual int get_Revision();
    [CompilerGeneratedAttribute]
public sealed virtual bool get_IsReadOnly();
    [NullableContextAttribute("2")]
public sealed virtual TFeature Get();
    [NullableContextAttribute("2")]
public sealed virtual void Set(TFeature instance);
    public sealed virtual IEnumerator`1<KeyValuePair`2<Type, object>> GetEnumerator();
    private int GetCount();
    internal static IEnumerator`1<KeyValuePair`2<Type, object>> CreateEnumerator(IFeatureCollection features, IEnumerable`1<Type> types, FeatureContainer container, IFeatureCollection[] others);
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    internal static IFeatureCollection get_Default();
    public sealed virtual object get_Item(Type key);
    public sealed virtual void set_Item(Type key, object value);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[DefaultMemberAttribute("Item")]
internal class DocumentFormat.OpenXml.Features.FeatureContainer : ValueType {
    private int _initialCapacity;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private Dictionary`2<Type, object> _features;
    private Int32 modreq(System.Runtime.CompilerServices.IsVolatile) _containerRevision;
    public int Revision { get; }
    public IEnumerable`1<Type> Types { get; }
    [NullableAttribute("2")]
public object Item { get; public set; }
    public FeatureContainer(int initialCapacity);
    public int get_Revision();
    public IEnumerable`1<Type> get_Types();
    public object get_Item(Type key);
    public void set_Item(Type key, object value);
    [NullableContextAttribute("2")]
public TFeature Get();
    [NullableContextAttribute("2")]
public void Set(TFeature instance);
}
internal abstract class DocumentFormat.OpenXml.Features.FeatureEvent`1 : object {
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private Action`1<FeatureEventArgs`1<TArg>> Change;
    [CompilerGeneratedAttribute]
public sealed virtual void add_Change(Action`1<FeatureEventArgs`1<TArg>> value);
    [CompilerGeneratedAttribute]
public sealed virtual void remove_Change(Action`1<FeatureEventArgs`1<TArg>> value);
    [NullableContextAttribute("1")]
public sealed virtual void OnChange(EventType type, TArg arg);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[IsReadOnlyAttribute]
public class DocumentFormat.OpenXml.Features.FeatureEventArgs`1 : ValueType {
    [CompilerGeneratedAttribute]
private EventType <Type>k__BackingField;
    [CompilerGeneratedAttribute]
private TArg <Argument>k__BackingField;
    public EventType Type { get; }
    public TArg Argument { get; }
    public FeatureEventArgs`1(EventType type, TArg arg);
    [CompilerGeneratedAttribute]
public EventType get_Type();
    [CompilerGeneratedAttribute]
public TArg get_Argument();
    [NullableContextAttribute("2")]
public virtual bool Equals(object obj);
    public sealed virtual bool Equals(FeatureEventArgs`1<TArg> other);
    public virtual int GetHashCode();
    public static bool op_Equality(FeatureEventArgs`1<TArg> left, FeatureEventArgs`1<TArg> right);
    public static bool op_Inequality(FeatureEventArgs`1<TArg> left, FeatureEventArgs`1<TArg> right);
}
[ExtensionAttribute]
public static class DocumentFormat.OpenXml.Features.FeatureExtensions : object {
    [NullableContextAttribute("1")]
[ExtensionAttribute]
public static TFeature GetRequired(IFeatureCollection features);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class DocumentFormat.OpenXml.Features.FilePackageFeature : StreamPackageFeature {
    private string _path;
    public FilePackageFeature(string path, PackageOpenMode mode);
    private static FileStream CreateStream(string path, PackageOpenMode openMode);
    protected virtual Stream GetStream(FileMode mode, FileAccess access);
}
internal interface DocumentFormat.OpenXml.Features.IApplicationTypeFeature {
    public ApplicationType Type { get; }
    public abstract virtual ApplicationType get_Type();
}
internal interface DocumentFormat.OpenXml.Features.IContainerDisposableFeature {
    public abstract virtual void Dispose();
}
internal interface DocumentFormat.OpenXml.Features.IContentTypeFeature {
    public bool IsConstant { get; }
    public abstract virtual bool get_IsConstant();
}
[NullableContextAttribute("1")]
internal interface DocumentFormat.OpenXml.Features.IDataPartsFeature {
    public int Count { get; }
    public IEnumerable`1<DataPart> Parts { get; }
    public abstract virtual bool TryGetDataPart(Uri uri, DataPart& dataPart);
    public abstract virtual void Add(DataPart dataPart);
    public abstract virtual int get_Count();
    public abstract virtual bool Remove(DataPart dataPart);
    public abstract virtual IEnumerable`1<DataPart> get_Parts();
}
[NullableContextAttribute("1")]
public interface DocumentFormat.OpenXml.Features.IDisposableFeature {
    public abstract virtual void Register(Action disposable);
}
public interface DocumentFormat.OpenXml.Features.IDocumentTypeFeature`1 {
    public TDocumentType Current { get; public set; }
    public abstract virtual TDocumentType get_Current();
    public abstract virtual void set_Current(TDocumentType value);
    public abstract virtual string GetContentType(TDocumentType type);
    public abstract virtual Nullable`1<TDocumentType> GetDocumentType(string contentPart);
    public abstract virtual void ChangeDocumentType(TDocumentType newType);
}
[NullableContextAttribute("1")]
internal interface DocumentFormat.OpenXml.Features.IElementMetadataFactoryFeature {
    public abstract virtual IElementMetadata GetMetadata(OpenXmlElement element);
}
[NullableContextAttribute("2")]
[DefaultMemberAttribute("Item")]
public interface DocumentFormat.OpenXml.Features.IFeatureCollection {
    public bool IsReadOnly { get; }
    public int Revision { get; }
    public object Item { get; public set; }
    public abstract virtual bool get_IsReadOnly();
    public abstract virtual int get_Revision();
    [NullableContextAttribute("1")]
public abstract virtual object get_Item(Type key);
    [NullableContextAttribute("1")]
public abstract virtual void set_Item(Type key, object value);
    public abstract virtual TFeature Get();
    public abstract virtual void Set(TFeature instance);
}
[NullableContextAttribute("2")]
public interface DocumentFormat.OpenXml.Features.IFeatureEvent`1 {
    [CompilerGeneratedAttribute]
public abstract virtual void add_Change(Action`1<FeatureEventArgs`1<TArg>> value);
    [CompilerGeneratedAttribute]
public abstract virtual void remove_Change(Action`1<FeatureEventArgs`1<TArg>> value);
}
[NullableContextAttribute("1")]
internal interface DocumentFormat.OpenXml.Features.IKnownDataPartFeature {
    public abstract virtual bool IsKnown(string relationshipId);
}
[NullableContextAttribute("1")]
internal interface DocumentFormat.OpenXml.Features.ILockFeature {
    public object SyncLock { get; }
    public abstract virtual object get_SyncLock();
}
[NullableContextAttribute("1")]
internal interface DocumentFormat.OpenXml.Features.IMainPartFeature {
    public string RelationshipType { get; }
    public string ContentType { get; }
    [NullableAttribute("2")]
public OpenXmlPart Part { get; }
    public abstract virtual string get_RelationshipType();
    public abstract virtual string get_ContentType();
    [NullableContextAttribute("2")]
public abstract virtual OpenXmlPart get_Part();
}
internal interface DocumentFormat.OpenXml.Features.IOpenXmlNamespaceResolver {
    public abstract virtual FileFormatVersions GetVersion(OpenXmlNamespace ns);
    public abstract virtual bool TryGetTransitionalNamespace(OpenXmlNamespace ns, OpenXmlNamespace& transitionalNamespace);
    public abstract virtual bool TryGetTransitionalRelationship(OpenXmlNamespace ns, OpenXmlNamespace& transitionalRelationship);
    public abstract virtual bool TryGetExtendedNamespace(OpenXmlNamespace ns, OpenXmlNamespace& extNamespaceUri);
}
public interface DocumentFormat.OpenXml.Features.IPackageEventsFeature {
}
[NullableContextAttribute("1")]
internal interface DocumentFormat.OpenXml.Features.IPackageFactoryFeature`1 {
    public abstract virtual IPackageBuilder`1<TPackage> Create();
}
[NullableContextAttribute("1")]
internal interface DocumentFormat.OpenXml.Features.IPackageFeature {
    public IPackage Package { get; }
    public PackageCapabilities Capabilities { get; }
    public abstract virtual IPackage get_Package();
    public abstract virtual PackageCapabilities get_Capabilities();
    public abstract virtual void Reload(Nullable`1<FileMode> mode, Nullable`1<FileAccess> access);
}
[NullableContextAttribute("1")]
[ExperimentalAttribute("OOXML0002")]
[ObsoleteAttribute("This is an experimental APIs and is subject to change")]
internal interface DocumentFormat.OpenXml.Features.IPackageInitializer {
    public abstract virtual void Initialize(OpenXmlPackage package);
}
[NullableContextAttribute("1")]
internal interface DocumentFormat.OpenXml.Features.IPackagePartFeature {
    public IPackagePart Part { get; }
    public abstract virtual IPackagePart get_Part();
}
[NullableContextAttribute("1")]
internal interface DocumentFormat.OpenXml.Features.IPackageStreamFeature {
    public Stream Stream { get; public set; }
    public abstract virtual Stream get_Stream();
    public abstract virtual void set_Stream(Stream value);
}
[NullableContextAttribute("1")]
internal interface DocumentFormat.OpenXml.Features.IPartConstraintFeature {
    public IEnumerable`1<PartConstraintRule> Rules { get; }
    public abstract virtual bool TryGetRule(string relationshipId, PartConstraintRule& rule);
    public abstract virtual IEnumerable`1<PartConstraintRule> get_Rules();
}
public interface DocumentFormat.OpenXml.Features.IPartEventsFeature {
}
[NullableContextAttribute("1")]
public interface DocumentFormat.OpenXml.Features.IPartExtensionFeature {
    public abstract virtual void Register(string contentType, string extension);
    public abstract virtual bool TryGetExtension(string contentType, String& extension);
}
[NullableContextAttribute("1")]
internal interface DocumentFormat.OpenXml.Features.IPartFactoryFeature {
    public abstract virtual OpenXmlPart Create(string relationshipType);
}
[NullableContextAttribute("1")]
internal interface DocumentFormat.OpenXml.Features.IPartRelationshipsFeature {
    public int Count { get; }
    public IEnumerable`1<OpenXmlPart> Parts { get; }
    public abstract virtual void Add(OpenXmlPart part, string id);
    public abstract virtual bool Contains(string id);
    public abstract virtual bool Contains(OpenXmlPart part);
    public abstract virtual int get_Count();
    public abstract virtual IEnumerable`1<OpenXmlPart> get_Parts();
    public abstract virtual void Remove(string id);
    public abstract virtual void Clear();
    public abstract virtual bool TryGetPart(string id, OpenXmlPart& part);
}
public interface DocumentFormat.OpenXml.Features.IPartRootEventsFeature {
}
[NullableContextAttribute("1")]
internal interface DocumentFormat.OpenXml.Features.IPartsFeature {
    public abstract virtual bool TryGetPart(Uri uri, OpenXmlPart& part);
    public abstract virtual void Add(Uri uri, OpenXmlPart part);
    public abstract virtual bool Contains(Uri uri);
}
[NullableContextAttribute("1")]
internal interface DocumentFormat.OpenXml.Features.IPartUriFeature {
    public abstract virtual Uri CreatePartUri(string contentType, Uri parentUri, string targetPath, string targetName, string targetExt, bool forceUnique);
    public abstract virtual Uri EnsureUniquePartUri(string contentType, Uri parentUri, Uri targetUri);
    public abstract virtual void ReserveUri(string contentType, Uri partUri);
}
[NullableContextAttribute("1")]
internal interface DocumentFormat.OpenXml.Features.IProgrammaticIdentifierFeature {
    public string ProgramId { get; }
    public abstract virtual string get_ProgramId();
}
[NullableContextAttribute("1")]
public interface DocumentFormat.OpenXml.Features.IRaiseFeatureEvent`1 {
    public abstract virtual void OnChange(EventType type, TArg arg);
}
[NullableContextAttribute("1")]
internal interface DocumentFormat.OpenXml.Features.IReferenceRelationshipsFeature {
    public IEnumerable`1<ReferenceRelationship> Relationships { get; }
    public abstract virtual bool Remove(string id);
    public abstract virtual bool TryGetRelationship(string id, ReferenceRelationship& relationship);
    public abstract virtual HyperlinkRelationship CreateHyperLink(Uri uri, bool isExternal, string id);
    public abstract virtual DataPartReferenceRelationship CreateDataPartRelationship(string relationshipType, DataPart dataPart, string id);
    public abstract virtual ExternalRelationship CreateExternalRelationship(string relationshipType, Uri externalUri, string id);
    public abstract virtual IEnumerable`1<ReferenceRelationship> get_Relationships();
}
[NullableContextAttribute("1")]
internal interface DocumentFormat.OpenXml.Features.IRelationshipFilterFeature {
    public abstract virtual void AddFilter(Action`1<PackageRelationshipBuilder> action);
}
[NullableContextAttribute("2")]
internal interface DocumentFormat.OpenXml.Features.IRootElementFeature {
    public abstract virtual bool TryCreate(OpenXmlQualifiedName& modreq(System.Runtime.InteropServices.InAttribute) qname, OpenXmlElement& element);
}
[NullableContextAttribute("1")]
internal interface DocumentFormat.OpenXml.Features.ISaveFeature {
    public abstract virtual void Save(OpenXmlPartContainer container);
    public abstract virtual void Register(Action`1<OpenXmlPartContainer> container);
}
[NullableContextAttribute("1")]
[ExperimentalAttribute("OOXML0003")]
[ObsoleteAttribute("This is an experimental APIs and is subject to change")]
internal interface DocumentFormat.OpenXml.Features.ISchemaTrackingFeature {
    public ICollection`1<OpenXmlQualifiedName> RootElements { get; }
    public ICollection`1<string> Relationships { get; }
    public abstract virtual ICollection`1<OpenXmlQualifiedName> get_RootElements();
    public abstract virtual ICollection`1<string> get_Relationships();
}
internal interface DocumentFormat.OpenXml.Features.IStrictNamespaceFeature {
    public bool Found { get; }
    public abstract virtual bool get_Found();
}
[NullableContextAttribute("1")]
internal interface DocumentFormat.OpenXml.Features.ITargetFeature {
    public string Path { get; }
    public string Extension { get; }
    public string Name { get; }
    public abstract virtual string get_Path();
    public abstract virtual string get_Extension();
    public abstract virtual string get_Name();
}
internal interface DocumentFormat.OpenXml.Features.ITypedPartFactoryFeature {
    public abstract virtual T Create();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class DocumentFormat.OpenXml.Features.OpenXmlNamespaceResolver : object {
    private Dictionary`2<OpenXmlNamespace, OpenXmlNamespace> _extendedNamespaces;
    private Dictionary`2<OpenXmlNamespace, OpenXmlNamespace> _strictTransitionalNamespaces;
    private Dictionary`2<OpenXmlNamespace, OpenXmlNamespace> _strictTransitionalRelationshipPairs;
    private Dictionary`2<string, string> _urlToPrefix;
    private Dictionary`2<string, string> _prefixToUrl;
    private Dictionary`2<string, FileFormatVersions> _prefixToVersion;
    private string NormalizeNamespace(OpenXmlNamespace& ns);
    public sealed virtual IDictionary`2<string, string> GetNamespacesInScope(XmlNamespaceScope scope);
    public sealed virtual string LookupNamespace(string prefix);
    public sealed virtual string LookupPrefix(string namespaceName);
    public sealed virtual bool TryGetTransitionalNamespace(OpenXmlNamespace ns, OpenXmlNamespace& transitionalNamespace);
    public sealed virtual bool TryGetTransitionalRelationship(OpenXmlNamespace ns, OpenXmlNamespace& transitionalRelationship);
    public sealed virtual bool TryGetExtendedNamespace(OpenXmlNamespace ns, OpenXmlNamespace& extNamespaceUri);
    public sealed virtual FileFormatVersions GetVersion(OpenXmlNamespace ns);
}
[FlagsAttribute]
internal enum DocumentFormat.OpenXml.Features.PackageCapabilities : Enum {
    public int value__;
    public static PackageCapabilities None;
    public static PackageCapabilities Save;
    public static PackageCapabilities Reload;
    public static PackageCapabilities Cached;
    public static PackageCapabilities LargePartStreams;
    public static PackageCapabilities MalformedUri;
}
[ExtensionAttribute]
public static class DocumentFormat.OpenXml.Features.PackageEventExtensions : object {
    [NullableContextAttribute("1")]
[ExtensionAttribute]
public static void AddPackageEventsFeature(OpenXmlPackage package);
    [NullableContextAttribute("1")]
[ExtensionAttribute]
internal static void OnChange(IPackageEventsFeature events, OpenXmlPackage package, EventType type);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
internal abstract class DocumentFormat.OpenXml.Features.PackageFeatureBase : object {
    private RelationshipCollection _relationships;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private Action`1<PackageRelationshipBuilder> _relationshipFilter;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private Dictionary`2<Uri, PackagePart> _parts;
    [NullableAttribute("1")]
protected Package Package { get; }
    private FileAccess DocumentFormat.OpenXml.Packaging.IPackage.FileOpenAccess { get; }
    [NullableAttribute("1")]
public PackageProperties PackageProperties { get; }
    [NullableAttribute("1")]
private IPackage DocumentFormat.OpenXml.Features.IPackageFeature.Package { get; }
    public PackageCapabilities Capabilities { get; }
    [NullableAttribute("1")]
private IRelationshipCollection DocumentFormat.OpenXml.Packaging.IPackage.Relationships { get; }
    [NullableAttribute("1")]
private IPackageProperties DocumentFormat.OpenXml.Packaging.IPackage.PackageProperties { get; }
    private string DocumentFormat.OpenXml.Packaging.IPackageProperties.Title { get; private set; }
    private string DocumentFormat.OpenXml.Packaging.IPackageProperties.Subject { get; private set; }
    private string DocumentFormat.OpenXml.Packaging.IPackageProperties.Creator { get; private set; }
    private string DocumentFormat.OpenXml.Packaging.IPackageProperties.Keywords { get; private set; }
    private string DocumentFormat.OpenXml.Packaging.IPackageProperties.Description { get; private set; }
    private string DocumentFormat.OpenXml.Packaging.IPackageProperties.LastModifiedBy { get; private set; }
    private string DocumentFormat.OpenXml.Packaging.IPackageProperties.Revision { get; private set; }
    private Nullable`1<DateTime> DocumentFormat.OpenXml.Packaging.IPackageProperties.LastPrinted { get; private set; }
    private Nullable`1<DateTime> DocumentFormat.OpenXml.Packaging.IPackageProperties.Created { get; private set; }
    private Nullable`1<DateTime> DocumentFormat.OpenXml.Packaging.IPackageProperties.Modified { get; private set; }
    private string DocumentFormat.OpenXml.Packaging.IPackageProperties.Category { get; private set; }
    private string DocumentFormat.OpenXml.Packaging.IPackageProperties.Identifier { get; private set; }
    private string DocumentFormat.OpenXml.Packaging.IPackageProperties.ContentType { get; private set; }
    private string DocumentFormat.OpenXml.Packaging.IPackageProperties.Language { get; private set; }
    private string DocumentFormat.OpenXml.Packaging.IPackageProperties.Version { get; private set; }
    private string DocumentFormat.OpenXml.Packaging.IPackageProperties.ContentStatus { get; private set; }
    [NullableContextAttribute("1")]
protected abstract virtual Package get_Package();
    [NullableContextAttribute("1")]
private PackagePart GetOrCreatePart(PackagePart part);
    protected void UpdateCachedItems();
    private sealed virtual override FileAccess DocumentFormat.OpenXml.Packaging.IPackage.get_FileOpenAccess();
    [NullableContextAttribute("1")]
public PackageProperties get_PackageProperties();
    [NullableContextAttribute("1")]
private sealed virtual override IEnumerable`1<IPackagePart> DocumentFormat.OpenXml.Packaging.IPackage.GetParts();
    [NullableContextAttribute("1")]
private sealed virtual override IPackagePart DocumentFormat.OpenXml.Packaging.IPackage.GetPart(Uri uriTarget);
    [NullableContextAttribute("1")]
private sealed virtual override bool DocumentFormat.OpenXml.Packaging.IPackage.PartExists(Uri partUri);
    private sealed virtual override void DocumentFormat.OpenXml.Packaging.IPackage.Save();
    [NullableContextAttribute("1")]
public sealed virtual IPackagePart CreatePart(Uri partUri, string contentType, CompressionOption compressionOption);
    [NullableContextAttribute("1")]
public sealed virtual void DeletePart(Uri uri);
    [NullableContextAttribute("1")]
private sealed virtual override IPackage DocumentFormat.OpenXml.Features.IPackageFeature.get_Package();
    public virtual PackageCapabilities get_Capabilities();
    [NullableContextAttribute("1")]
private sealed virtual override IRelationshipCollection DocumentFormat.OpenXml.Packaging.IPackage.get_Relationships();
    private static bool GetSupportsMalformedUri();
    public virtual void Reload(Nullable`1<FileMode> mode, Nullable`1<FileAccess> access);
    [NullableContextAttribute("1")]
internal void RunFilter(PackageRelationshipBuilder relationship);
    [NullableContextAttribute("1")]
private sealed virtual override void DocumentFormat.OpenXml.Features.IRelationshipFilterFeature.AddFilter(Action`1<PackageRelationshipBuilder> action);
    [NullableContextAttribute("1")]
protected virtual void Register(IFeatureCollection features);
    [NullableContextAttribute("1")]
private sealed virtual override void DocumentFormat.OpenXml.Features.IPackageInitializer.Initialize(OpenXmlPackage package);
    [NullableContextAttribute("1")]
private sealed virtual override IPackageProperties DocumentFormat.OpenXml.Packaging.IPackage.get_PackageProperties();
    private sealed virtual override string DocumentFormat.OpenXml.Packaging.IPackageProperties.get_Title();
    private sealed virtual override void DocumentFormat.OpenXml.Packaging.IPackageProperties.set_Title(string value);
    private sealed virtual override string DocumentFormat.OpenXml.Packaging.IPackageProperties.get_Subject();
    private sealed virtual override void DocumentFormat.OpenXml.Packaging.IPackageProperties.set_Subject(string value);
    private sealed virtual override string DocumentFormat.OpenXml.Packaging.IPackageProperties.get_Creator();
    private sealed virtual override void DocumentFormat.OpenXml.Packaging.IPackageProperties.set_Creator(string value);
    private sealed virtual override string DocumentFormat.OpenXml.Packaging.IPackageProperties.get_Keywords();
    private sealed virtual override void DocumentFormat.OpenXml.Packaging.IPackageProperties.set_Keywords(string value);
    private sealed virtual override string DocumentFormat.OpenXml.Packaging.IPackageProperties.get_Description();
    private sealed virtual override void DocumentFormat.OpenXml.Packaging.IPackageProperties.set_Description(string value);
    private sealed virtual override string DocumentFormat.OpenXml.Packaging.IPackageProperties.get_LastModifiedBy();
    private sealed virtual override void DocumentFormat.OpenXml.Packaging.IPackageProperties.set_LastModifiedBy(string value);
    private sealed virtual override string DocumentFormat.OpenXml.Packaging.IPackageProperties.get_Revision();
    private sealed virtual override void DocumentFormat.OpenXml.Packaging.IPackageProperties.set_Revision(string value);
    private sealed virtual override Nullable`1<DateTime> DocumentFormat.OpenXml.Packaging.IPackageProperties.get_LastPrinted();
    private sealed virtual override void DocumentFormat.OpenXml.Packaging.IPackageProperties.set_LastPrinted(Nullable`1<DateTime> value);
    private sealed virtual override Nullable`1<DateTime> DocumentFormat.OpenXml.Packaging.IPackageProperties.get_Created();
    private sealed virtual override void DocumentFormat.OpenXml.Packaging.IPackageProperties.set_Created(Nullable`1<DateTime> value);
    private sealed virtual override Nullable`1<DateTime> DocumentFormat.OpenXml.Packaging.IPackageProperties.get_Modified();
    private sealed virtual override void DocumentFormat.OpenXml.Packaging.IPackageProperties.set_Modified(Nullable`1<DateTime> value);
    private sealed virtual override string DocumentFormat.OpenXml.Packaging.IPackageProperties.get_Category();
    private sealed virtual override void DocumentFormat.OpenXml.Packaging.IPackageProperties.set_Category(string value);
    private sealed virtual override string DocumentFormat.OpenXml.Packaging.IPackageProperties.get_Identifier();
    private sealed virtual override void DocumentFormat.OpenXml.Packaging.IPackageProperties.set_Identifier(string value);
    private sealed virtual override string DocumentFormat.OpenXml.Packaging.IPackageProperties.get_ContentType();
    private sealed virtual override void DocumentFormat.OpenXml.Packaging.IPackageProperties.set_ContentType(string value);
    private sealed virtual override string DocumentFormat.OpenXml.Packaging.IPackageProperties.get_Language();
    private sealed virtual override void DocumentFormat.OpenXml.Packaging.IPackageProperties.set_Language(string value);
    private sealed virtual override string DocumentFormat.OpenXml.Packaging.IPackageProperties.get_Version();
    private sealed virtual override void DocumentFormat.OpenXml.Packaging.IPackageProperties.set_Version(string value);
    private sealed virtual override string DocumentFormat.OpenXml.Packaging.IPackageProperties.get_ContentStatus();
    private sealed virtual override void DocumentFormat.OpenXml.Packaging.IPackageProperties.set_ContentStatus(string value);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class DocumentFormat.OpenXml.Features.PackagePartFeature : object {
    [CompilerGeneratedAttribute]
private IPackagePart <Part>k__BackingField;
    public IPackagePart Part { get; }
    public PackagePartFeature(IPackagePart part);
    [CompilerGeneratedAttribute]
public sealed virtual IPackagePart get_Part();
}
[ExtensionAttribute]
public static class DocumentFormat.OpenXml.Features.PartEventFeatureExtensions : object {
    [NullableContextAttribute("1")]
[ExtensionAttribute]
public static void AddPartEventsFeature(OpenXmlPackage package);
    [NullableContextAttribute("1")]
[ExtensionAttribute]
internal static void OnChange(IPartEventsFeature events, OpenXmlPart part, EventType type);
}
[ExtensionAttribute]
public static class DocumentFormat.OpenXml.Features.PartRootEventExtensions : object {
    [NullableContextAttribute("1")]
[ExtensionAttribute]
public static void AddPartRootEventsFeature(OpenXmlPartContainer container);
    [NullableContextAttribute("1")]
[ExtensionAttribute]
internal static void OnChange(IPartRootEventsFeature events, EventType type, OpenXmlPart part);
}
[ExtensionAttribute]
internal static class DocumentFormat.OpenXml.Features.RelationshipFilterExtensions : object {
    [NullableContextAttribute("1")]
[ExtensionAttribute]
internal static void IgnoreRelationship(OpenXmlPackage package, string relationshipType);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class DocumentFormat.OpenXml.Features.StreamPackageFeature : PackageFeatureBase {
    private Package _package;
    private Stream _stream;
    private bool _disposedValue;
    private bool _isOwned;
    [CompilerGeneratedAttribute]
private FileAccess <Access>k__BackingField;
    [CompilerGeneratedAttribute]
private FileMode <Mode>k__BackingField;
    protected FileAccess Access { get; }
    protected FileMode Mode { get; }
    public Stream Stream { get; public set; }
    protected Package Package { get; }
    public PackageCapabilities Capabilities { get; }
    public StreamPackageFeature(Stream stream, PackageOpenMode openMode, bool isOwned);
    [CompilerGeneratedAttribute]
protected FileAccess get_Access();
    [CompilerGeneratedAttribute]
protected FileMode get_Mode();
    public sealed virtual Stream get_Stream();
    public sealed virtual void set_Stream(Stream value);
    [MemberNotNullAttribute("_stream")]
private bool SetStream(Stream stream);
    protected void DisposeStreamIfOwned();
    protected virtual Stream GetStream(FileMode mode, FileAccess access);
    [MemberNotNullAttribute("_package")]
private void InitializePackage(Nullable`1<FileMode> mode, Nullable`1<FileAccess> access);
    protected virtual Package get_Package();
    public virtual PackageCapabilities get_Capabilities();
    public virtual void Reload(Nullable`1<FileMode> mode, Nullable`1<FileAccess> access);
    protected virtual void Dispose(bool disposing);
    public sealed virtual void Dispose();
    protected virtual void Register(IFeatureCollection features);
}
[ExtensionAttribute]
internal static class DocumentFormat.OpenXml.Features.StrictNamespaceExtensions : object {
    [NullableContextAttribute("1")]
[ExtensionAttribute]
internal static void UseTransitionalRelationshipNamespaces(OpenXmlPackage package, bool save);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
internal static class DocumentFormat.OpenXml.FileFormatVersionExtensions : object {
    [CompilerGeneratedAttribute]
private static FileFormatVersions[] <AllVersions>k__BackingField;
    public static FileFormatVersions[] AllVersions { get; }
    private static FileFormatVersionExtensions();
    [CompilerGeneratedAttribute]
public static FileFormatVersions[] get_AllVersions();
    [ExtensionAttribute]
public static bool Any(FileFormatVersions version);
    [ExtensionAttribute]
public static bool All(FileFormatVersions version);
    [ExtensionAttribute]
public static FileFormatVersions AndLater(FileFormatVersions version);
    [ExtensionAttribute]
public static void ThrowIfNotInVersion(FileFormatVersions version, OpenXmlPart part);
    [ExtensionAttribute]
public static void ThrowIfNotInVersion(FileFormatVersions version, OpenXmlElement element);
    [ExtensionAttribute]
public static bool AtLeast(FileFormatVersions version, FileFormatVersions minimum);
    [ExtensionAttribute]
internal static bool Includes(FileFormatVersions source, FileFormatVersions target);
    [ExtensionAttribute]
internal static void ThrowExceptionIfFileFormatNotSupported(FileFormatVersions fileFormat, string parameterName);
    [ExtensionAttribute]
private static string GetOfficeYear(FileFormatVersions version);
    [CompilerGeneratedAttribute]
internal static int <AtLeast>g__MapToInteger|8_0(FileFormatVersions v, string name);
}
[FlagsAttribute]
public enum DocumentFormat.OpenXml.FileFormatVersions : Enum {
    public int value__;
    public static FileFormatVersions None;
    public static FileFormatVersions Office2007;
    public static FileFormatVersions Office2010;
    public static FileFormatVersions Office2013;
    public static FileFormatVersions Office2016;
    public static FileFormatVersions Office2019;
    public static FileFormatVersions Office2021;
    public static FileFormatVersions Microsoft365;
}
internal static class DocumentFormat.OpenXml.Framework.Cached : object {
    [NullableContextAttribute("1")]
public static T[] Array();
    [NullableContextAttribute("1")]
public static ReadOnlyCollection`1<T> ReadOnlyCollection();
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
internal class DocumentFormat.OpenXml.Framework.CompiledParticle : object {
    [NullableAttribute("1")]
private Lazy`1<LookupItem[]> _lookup;
    [CompilerGeneratedAttribute]
private ParticleConstraint <Particle>k__BackingField;
    [NullableAttribute("0")]
public ReadOnlyArray`1<LookupItem> Lookup { get; }
    public ParticleConstraint Particle { get; }
    public CompiledParticle(ParticleConstraint particle);
    [NullableContextAttribute("0")]
public ReadOnlyArray`1<LookupItem> get_Lookup();
    [CompilerGeneratedAttribute]
public ParticleConstraint get_Particle();
    public ParticlePath Find(object obj);
    public ParticlePath Find(Type type);
    public sealed virtual int Compare(OpenXmlElement x, OpenXmlElement y);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[AttributeUsageAttribute("4")]
internal class DocumentFormat.OpenXml.Framework.ContentTypeAttribute : Attribute {
    [CompilerGeneratedAttribute]
private string <ContentType>k__BackingField;
    public string ContentType { get; }
    public ContentTypeAttribute(string contentType);
    [CompilerGeneratedAttribute]
public string get_ContentType();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal abstract class DocumentFormat.OpenXml.Framework.DelegatingStream : Stream {
    private Stream _innerStream;
    public bool CanRead { get; }
    public bool CanSeek { get; }
    public bool CanWrite { get; }
    public long Length { get; }
    public long Position { get; public set; }
    public int ReadTimeout { get; public set; }
    public bool CanTimeout { get; }
    public int WriteTimeout { get; public set; }
    protected DelegatingStream(Stream innerStream);
    public virtual bool get_CanRead();
    public virtual bool get_CanSeek();
    public virtual bool get_CanWrite();
    public virtual long get_Length();
    public virtual long get_Position();
    public virtual void set_Position(long value);
    public virtual int get_ReadTimeout();
    public virtual void set_ReadTimeout(int value);
    public virtual bool get_CanTimeout();
    public virtual int get_WriteTimeout();
    public virtual void set_WriteTimeout(int value);
    protected virtual void Dispose(bool disposing);
    public virtual long Seek(long offset, SeekOrigin origin);
    public virtual int Read(Byte[] buffer, int offset, int count);
    public virtual int ReadByte();
    public virtual void Flush();
    public virtual void SetLength(long value);
    public virtual void Write(Byte[] buffer, int offset, int count);
    public virtual void WriteByte(byte value);
    public virtual IAsyncResult BeginWrite(Byte[] buffer, int offset, int count, AsyncCallback callback, object state);
    public virtual void EndWrite(IAsyncResult asyncResult);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class DocumentFormat.OpenXml.Framework.EnumValidator : VersionedValidator {
    [CompilerGeneratedAttribute]
private static IValidator <Instance>k__BackingField;
    public static IValidator Instance { get; }
    private static EnumValidator();
    [CompilerGeneratedAttribute]
public static IValidator get_Instance();
    protected virtual void ValidateVersion(ValidationContext context);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class DocumentFormat.OpenXml.Framework.HashCode : ValueType {
    private static int Seed;
    private static int Combinator;
    private int _code;
    [NullableContextAttribute("2")]
public void Add(T item);
    [NullableContextAttribute("2")]
public void Add(T item, IEqualityComparer`1<T> comparer);
    public int ToHashCode();
    public static int Combine(T1 t1, T2 t2);
    public static int Combine(T1 t1, T2 t2, T3 t3);
    public static int Combine(T1 t1, T2 t2, T3 t3, T4 t4);
    private void Add(int value);
}
[NullableContextAttribute("2")]
internal interface DocumentFormat.OpenXml.Framework.INameProvider {
    public XmlQualifiedName QName { get; }
    public abstract virtual XmlQualifiedName get_QName();
}
[NullableContextAttribute("1")]
internal interface DocumentFormat.OpenXml.Framework.IValidator {
    public abstract virtual void Validate(ValidationContext context);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class DocumentFormat.OpenXml.Framework.ListValidator : object {
    [CompilerGeneratedAttribute]
private static IValidator <Instance>k__BackingField;
    public static IValidator Instance { get; }
    private static ListValidator();
    [CompilerGeneratedAttribute]
public static IValidator get_Instance();
    public sealed virtual void Validate(ValidationContext context);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[IsReadOnlyAttribute]
[DebuggerDisplayAttribute("[{Type}] - {Path}")]
internal class DocumentFormat.OpenXml.Framework.LookupItem : ValueType {
    [CompilerGeneratedAttribute]
private Type <Type>k__BackingField;
    [CompilerGeneratedAttribute]
private ParticlePath <Path>k__BackingField;
    public Type Type { get; }
    public ParticlePath Path { get; }
    public LookupItem(Type type, ParticlePath path);
    [CompilerGeneratedAttribute]
public Type get_Type();
    [CompilerGeneratedAttribute]
public ParticlePath get_Path();
    public void Deconstruct(Type& type, ParticlePath& path);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[IsReadOnlyAttribute]
[DefaultMemberAttribute("Item")]
internal class DocumentFormat.OpenXml.Framework.Metadata.AttributeCollection : ValueType {
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private OpenXmlSimpleType[] _data;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private ReadOnlyArray`1<AttributeMetadata> _attributes;
    public bool IsEmpty { get; }
    public AttributeEntry Item { get; }
    public AttributeEntry Item { get; }
    public int Length { get; }
    public AttributeCollection(ReadOnlyArray`1<AttributeMetadata> tags);
    public bool get_IsEmpty();
    public bool Any();
    public AttributeEntry GetProperty(string propertyName);
    public AttributeEntry get_Item(int index);
    public AttributeEntry get_Item(OpenXmlQualifiedName& qname);
    public int get_Length();
    private int GetIndex(OpenXmlQualifiedName& qname);
    private int GetIndex(string propertyName);
    public Enumerator GetEnumerator();
    private sealed virtual override IEnumerator`1<AttributeEntry> System.Collections.Generic.IEnumerable<DocumentFormat.OpenXml.Framework.Metadata.AttributeCollection.AttributeEntry>.GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal abstract class DocumentFormat.OpenXml.Framework.Metadata.AttributeMetadata : object {
    public XmlQualifiedName TypeName { get; }
    public string PropertyName { get; }
    public OpenXmlQualifiedName QName { get; }
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ReadOnlyArray`1<IValidator> Validators { get; }
    public Type Type { get; }
    public XmlQualifiedName get_TypeName();
    public abstract virtual string get_PropertyName();
    public abstract virtual OpenXmlQualifiedName get_QName();
    public abstract virtual ReadOnlyArray`1<IValidator> get_Validators();
    public abstract virtual OpenXmlSimpleType CreateNew();
    public abstract virtual Type get_Type();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[DebuggerDisplayAttribute("{Namespace}:{Name}")]
internal class DocumentFormat.OpenXml.Framework.Metadata.ElementFactory : object {
    private Func`1<OpenXmlElement> _factory;
    [NullableAttribute("2")]
[CompilerGeneratedAttribute]
private Type <Type>k__BackingField;
    [CompilerGeneratedAttribute]
private OpenXmlQualifiedName <QName>k__BackingField;
    [NullableAttribute("2")]
public Type Type { get; }
    public OpenXmlQualifiedName QName { get; }
    public ElementFactory(Type type, OpenXmlQualifiedName& qname, Func`1<OpenXmlElement> factory);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public Type get_Type();
    [CompilerGeneratedAttribute]
public OpenXmlQualifiedName get_QName();
    public OpenXmlElement Create();
    public static ElementFactory Create();
    public static ElementFactory Create(Type type, Func`1<OpenXmlElement> factory);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class DocumentFormat.OpenXml.Framework.Metadata.ElementFactoryCollection : object {
    public static ElementFactoryCollection Empty;
    private ElementFactory[] _data;
    public int Count { get; }
    public IEnumerable`1<ElementFactory> Elements { get; }
    public ElementFactoryCollection(IEnumerable`1<ElementFactory> lookup);
    private static ElementFactoryCollection();
    public int get_Count();
    public IEnumerable`1<ElementFactory> get_Elements();
    [NullableContextAttribute("2")]
public OpenXmlElement Create(OpenXmlQualifiedName& qname);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class DocumentFormat.OpenXml.Framework.Metadata.ElementMetadata : object {
    public static ElementMetadata None;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private Lazy`1<ElementFactoryCollection> _children;
    [CompilerGeneratedAttribute]
private Type <Type>k__BackingField;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private ReadOnlyArray`1<AttributeMetadata> <Attributes>k__BackingField;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private ReadOnlyArray`1<IValidator> <Validators>k__BackingField;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private ReadOnlyArray`1<IValidator> <Constraints>k__BackingField;
    [CompilerGeneratedAttribute]
private FileFormatVersions <Availability>k__BackingField;
    [NullableAttribute("2")]
[CompilerGeneratedAttribute]
private CompiledParticle <Particle>k__BackingField;
    [CompilerGeneratedAttribute]
private OpenXmlQualifiedName <QName>k__BackingField;
    public Type Type { get; }
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ReadOnlyArray`1<AttributeMetadata> Attributes { get; }
    public ElementFactoryCollection Children { get; }
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ReadOnlyArray`1<IValidator> Validators { get; }
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ReadOnlyArray`1<IValidator> Constraints { get; }
    public FileFormatVersions Availability { get; }
    [NullableAttribute("2")]
public CompiledParticle Particle { get; }
    public OpenXmlQualifiedName QName { get; }
    internal ElementMetadata(Type type, ReadOnlyArray`1<AttributeMetadata> attributes, ReadOnlyArray`1<IValidator> validators, ReadOnlyArray`1<IValidator> constraints, FileFormatVersions version, OpenXmlQualifiedName qname, CompiledParticle particle, Lazy`1<ElementFactoryCollection> lookup);
    internal ElementMetadata(Type type);
    private static ElementMetadata();
    [CompilerGeneratedAttribute]
public sealed virtual Type get_Type();
    [CompilerGeneratedAttribute]
public sealed virtual ReadOnlyArray`1<AttributeMetadata> get_Attributes();
    public sealed virtual ElementFactoryCollection get_Children();
    [CompilerGeneratedAttribute]
public sealed virtual ReadOnlyArray`1<IValidator> get_Validators();
    [CompilerGeneratedAttribute]
public sealed virtual ReadOnlyArray`1<IValidator> get_Constraints();
    [CompilerGeneratedAttribute]
public sealed virtual FileFormatVersions get_Availability();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public sealed virtual CompiledParticle get_Particle();
    [CompilerGeneratedAttribute]
public sealed virtual OpenXmlQualifiedName get_QName();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class DocumentFormat.OpenXml.Framework.Metadata.ElementMetadataFactoryFeature : object {
    private ConcurrentDictionary`2<Type, ElementMetadata> _lookup;
    public sealed virtual IElementMetadata GetMetadata(OpenXmlElement element);
    private static ElementMetadata CreateMetadata(OpenXmlElement element);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[IsReadOnlyAttribute]
internal class DocumentFormat.OpenXml.Framework.Metadata.ElementState : ValueType {
    [CompilerGeneratedAttribute]
private AttributeCollection <Attributes>k__BackingField;
    [CompilerGeneratedAttribute]
private IElementMetadata <Metadata>k__BackingField;
    public bool IsEmpty { get; }
    public AttributeCollection Attributes { get; }
    public IElementMetadata Metadata { get; }
    public ElementState(IElementMetadata metadata);
    public bool get_IsEmpty();
    [CompilerGeneratedAttribute]
public AttributeCollection get_Attributes();
    [CompilerGeneratedAttribute]
public IElementMetadata get_Metadata();
}
[NullableContextAttribute("1")]
internal interface DocumentFormat.OpenXml.Framework.Metadata.IElementMetadata {
    public Type Type { get; }
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ReadOnlyArray`1<AttributeMetadata> Attributes { get; }
    public FileFormatVersions Availability { get; }
    public ElementFactoryCollection Children { get; }
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ReadOnlyArray`1<IValidator> Constraints { get; }
    [NullableAttribute("2")]
public CompiledParticle Particle { get; }
    public OpenXmlQualifiedName QName { get; }
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ReadOnlyArray`1<IValidator> Validators { get; }
    public abstract virtual Type get_Type();
    public abstract virtual ReadOnlyArray`1<AttributeMetadata> get_Attributes();
    public abstract virtual FileFormatVersions get_Availability();
    public abstract virtual ElementFactoryCollection get_Children();
    public abstract virtual ReadOnlyArray`1<IValidator> get_Constraints();
    [NullableContextAttribute("2")]
public abstract virtual CompiledParticle get_Particle();
    public abstract virtual OpenXmlQualifiedName get_QName();
    public abstract virtual ReadOnlyArray`1<IValidator> get_Validators();
}
[NullableContextAttribute("1")]
internal interface DocumentFormat.OpenXml.Framework.Metadata.IMetadataBuilder`1 {
    public abstract virtual T Build();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class DocumentFormat.OpenXml.Framework.Metadata.ValidatorBuilder : object {
    private List`1<IValidator> _validators;
    public void AddValidator(IValidator validator);
    public void AddValidator(IValidator validator);
    public void InsertValidator(int index, IValidator validator);
    protected IValidator[] GetValidators();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class DocumentFormat.OpenXml.Framework.NameProviderValidator : object {
    private IValidator _other;
    [CompilerGeneratedAttribute]
private XmlQualifiedName <QName>k__BackingField;
    public XmlQualifiedName QName { get; }
    public NameProviderValidator(IValidator other, XmlQualifiedName qname);
    [CompilerGeneratedAttribute]
public sealed virtual XmlQualifiedName get_QName();
    public sealed virtual void Validate(ValidationContext context);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class DocumentFormat.OpenXml.Framework.NumberValidator : VersionedValidator {
    [CompilerGeneratedAttribute]
private static IValidator <Instance>k__BackingField;
    private static XmlQualifiedName _positiveQname;
    private static XmlQualifiedName _nonNegativeQname;
    private Nullable`1<long> _minInclusive;
    private Nullable`1<long> _maxInclusive;
    private Nullable`1<long> _minExclusive;
    private Nullable`1<long> _maxExclusive;
    [CompilerGeneratedAttribute]
private bool <IsNonNegative>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsPositive>k__BackingField;
    public static IValidator Instance { get; }
    public long MinInclusive { get; public set; }
    public long MaxInclusive { get; public set; }
    public long MinExclusive { get; public set; }
    public long MaxExclusive { get; public set; }
    public bool IsNonNegative { get; public set; }
    public bool IsPositive { get; public set; }
    [NullableAttribute("2")]
public XmlQualifiedName QName { get; }
    private static NumberValidator();
    [CompilerGeneratedAttribute]
public static IValidator get_Instance();
    public long get_MinInclusive();
    public void set_MinInclusive(long value);
    public long get_MaxInclusive();
    public void set_MaxInclusive(long value);
    public long get_MinExclusive();
    public void set_MinExclusive(long value);
    public long get_MaxExclusive();
    public void set_MaxExclusive(long value);
    [CompilerGeneratedAttribute]
public bool get_IsNonNegative();
    [CompilerGeneratedAttribute]
public void set_IsNonNegative(bool value);
    [CompilerGeneratedAttribute]
public bool get_IsPositive();
    [CompilerGeneratedAttribute]
public void set_IsPositive(bool value);
    [NullableContextAttribute("2")]
public sealed virtual XmlQualifiedName get_QName();
    protected virtual void ValidateVersion(ValidationContext context);
    private static bool TryGetValue(OpenXmlSimpleType simpleType, Double& value);
    private static bool IsValidNumber(double value);
}
internal class DocumentFormat.OpenXml.Framework.OfficeVersionValidator : object {
    [CompilerGeneratedAttribute]
private FileFormatVersions <OfficeVersion>k__BackingField;
    public FileFormatVersions OfficeVersion { get; }
    public OfficeVersionValidator(FileFormatVersions officeVersion);
    [CompilerGeneratedAttribute]
public FileFormatVersions get_OfficeVersion();
    [NullableContextAttribute("1")]
public sealed virtual void Validate(ValidationContext context);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[IsReadOnlyAttribute]
[ExperimentalAttribute("OOXML0004")]
[ObsoleteAttribute("This is an experimental APIs and is subject to change")]
internal class DocumentFormat.OpenXml.Framework.OpenXmlNamespace : ValueType {
    [NullableAttribute("2")]
private string _uri;
    public string Uri { get; }
    public bool IsEmpty { get; }
    public OpenXmlNamespace(string nsUri);
    public string get_Uri();
    public bool get_IsEmpty();
    [NullableContextAttribute("2")]
public virtual bool Equals(object obj);
    public sealed virtual bool Equals(OpenXmlNamespace other);
    public virtual int GetHashCode();
    public virtual string ToString();
    public sealed virtual int CompareTo(OpenXmlNamespace other);
    public static OpenXmlNamespace op_Implicit(string nsUri);
    public static bool op_Equality(OpenXmlNamespace left, OpenXmlNamespace right);
    public static bool op_Inequality(OpenXmlNamespace left, OpenXmlNamespace right);
    public static bool op_LessThan(OpenXmlNamespace left, OpenXmlNamespace right);
    public static bool op_LessThanOrEqual(OpenXmlNamespace left, OpenXmlNamespace right);
    public static bool op_GreaterThan(OpenXmlNamespace left, OpenXmlNamespace right);
    public static bool op_GreaterThanOrEqual(OpenXmlNamespace left, OpenXmlNamespace right);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[IsReadOnlyAttribute]
[ExperimentalAttribute("OOXML0004")]
[ObsoleteAttribute("This is an experimental APIs and is subject to change")]
internal class DocumentFormat.OpenXml.Framework.OpenXmlQualifiedName : ValueType {
    [CompilerGeneratedAttribute]
private OpenXmlNamespace <Namespace>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    public OpenXmlNamespace Namespace { get; }
    public string Name { get; }
    internal OpenXmlQualifiedName(OpenXmlNamespace& ns, string name);
    [CompilerGeneratedAttribute]
public OpenXmlNamespace get_Namespace();
    [CompilerGeneratedAttribute]
public string get_Name();
    [NullableContextAttribute("2")]
public virtual bool Equals(object obj);
    public sealed virtual int CompareTo(OpenXmlQualifiedName other);
    public virtual string ToString();
    public sealed virtual bool Equals(OpenXmlQualifiedName other);
    public virtual int GetHashCode();
    public static bool op_Equality(OpenXmlQualifiedName left, OpenXmlQualifiedName right);
    public static bool op_Inequality(OpenXmlQualifiedName left, OpenXmlQualifiedName right);
    public static bool op_LessThan(OpenXmlQualifiedName left, OpenXmlQualifiedName right);
    public static bool op_LessThanOrEqual(OpenXmlQualifiedName left, OpenXmlQualifiedName right);
    public static bool op_GreaterThan(OpenXmlQualifiedName left, OpenXmlQualifiedName right);
    public static bool op_GreaterThanOrEqual(OpenXmlQualifiedName left, OpenXmlQualifiedName right);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
internal static class DocumentFormat.OpenXml.Framework.OpenXmlSimpleTypeExtensions : object {
    private static Dictionary`2<Type, XmlQualifiedName> _simpleTypeMapping;
    private static OpenXmlSimpleTypeExtensions();
    [ExtensionAttribute]
public static XmlQualifiedName GetSimpleTypeQualifiedName(Type type);
    [ExtensionAttribute]
public static XmlQualifiedName GetSimpleTypeQualifiedName(ReadOnlyArray`1<IValidator> validators, Type type);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[IsReadOnlyAttribute]
internal class DocumentFormat.OpenXml.Framework.PartConstraintRule : ValueType {
    [CompilerGeneratedAttribute]
private string <RelationshipType>k__BackingField;
    [NullableAttribute("2")]
[CompilerGeneratedAttribute]
private string <ContentType>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <MinOccursIsNonZero>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <MaxOccursGreatThanOne>k__BackingField;
    [CompilerGeneratedAttribute]
private FileFormatVersions <FileFormat>k__BackingField;
    public string RelationshipType { get; }
    [NullableAttribute("2")]
public string ContentType { get; }
    public bool MinOccursIsNonZero { get; }
    public bool MaxOccursGreatThanOne { get; }
    public FileFormatVersions FileFormat { get; }
    public PartConstraintRule(string relationship, string contentType, bool minOccursIsNonZero, bool maxOccursGreatThanOne, FileFormatVersions version);
    [CompilerGeneratedAttribute]
public string get_RelationshipType();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public string get_ContentType();
    [CompilerGeneratedAttribute]
public bool get_MinOccursIsNonZero();
    [CompilerGeneratedAttribute]
public bool get_MaxOccursGreatThanOne();
    [CompilerGeneratedAttribute]
public FileFormatVersions get_FileFormat();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
internal static class DocumentFormat.OpenXml.Framework.ParticleExtensions : object {
    [ExtensionAttribute]
public static ParticleCollection GetCollection(CompiledParticle compiled, OpenXmlCompositeElement element);
    [ExtensionAttribute]
public static TElement Get(CompiledParticle compiled, OpenXmlCompositeElement element);
    [ExtensionAttribute]
public static bool Set(CompiledParticle compiled, OpenXmlCompositeElement parent, T value);
    [NullableContextAttribute("2")]
[ExtensionAttribute]
public static bool Set(CompiledParticle compiled, OpenXmlCompositeElement parent, OpenXmlElement value, Type type);
    [ExtensionAttribute]
public static CompiledParticle Compile(Builder builder);
    [ExtensionAttribute]
public static CompiledParticle Compile(ParticleConstraint particle);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[IsReadOnlyAttribute]
[DefaultMemberAttribute("Item")]
[DebuggerDisplayAttribute("Length = {Length}")]
internal class DocumentFormat.OpenXml.Framework.ReadOnlyArray`1 : ValueType {
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[DebuggerBrowsableAttribute("3")]
private T[] _array;
    public bool IsNull { get; }
    public T& Item { get; }
    public int Length { get; }
    private ReadOnlyArray`1(T[] array);
    public bool get_IsNull();
    public bool Any();
    public T& get_Item(int index);
    public int get_Length();
    [NullableContextAttribute("0")]
public Enumerator<T> GetEnumerator();
    private sealed virtual override IEnumerator`1<T> System.Collections.Generic.IEnumerable<T>.GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    public static ReadOnlyArray`1<T> op_Implicit(T[] array);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class DocumentFormat.OpenXml.Framework.ReadOnlyStream : DelegatingStream {
    public bool CanWrite { get; }
    public int WriteTimeout { get; public set; }
    public ReadOnlyStream(Stream innerStream);
    public virtual bool get_CanWrite();
    public virtual void Flush();
    public virtual void SetLength(long value);
    public virtual void Write(Byte[] buffer, int offset, int count);
    public virtual void WriteByte(byte value);
    public virtual int get_WriteTimeout();
    public virtual void set_WriteTimeout(int value);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[AttributeUsageAttribute("4")]
internal class DocumentFormat.OpenXml.Framework.RelationshipTypeAttribute : Attribute {
    [CompilerGeneratedAttribute]
private string <RelationshipType>k__BackingField;
    public string RelationshipType { get; }
    public RelationshipTypeAttribute(string relationshipType);
    [CompilerGeneratedAttribute]
public string get_RelationshipType();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class DocumentFormat.OpenXml.Framework.RequiredValidator : VersionedValidator {
    [CompilerGeneratedAttribute]
private static IValidator <Instance>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsRequired>k__BackingField;
    public static IValidator Instance { get; }
    public bool IsRequired { get; public set; }
    private static RequiredValidator();
    [CompilerGeneratedAttribute]
public static IValidator get_Instance();
    [CompilerGeneratedAttribute]
public bool get_IsRequired();
    [CompilerGeneratedAttribute]
public void set_IsRequired(bool value);
    protected virtual void ValidateVersion(ValidationContext context);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
internal static class DocumentFormat.OpenXml.Framework.ReservedElementTypeIds : object {
    [ExtensionAttribute]
internal static bool IsStrongTypedElement(OpenXmlElement element);
    [ExtensionAttribute]
internal static bool IsReservedElement(OpenXmlElement element);
    [ExtensionAttribute]
public static bool IsAlternateContent(OpenXmlElement element);
    [ExtensionAttribute]
public static bool IsAlternateContentChoice(OpenXmlElement element);
    [ExtensionAttribute]
public static bool IsAlternateContentFallback(OpenXmlElement element);
    [ExtensionAttribute]
public static bool IsUnknown(OpenXmlElement element);
    [ExtensionAttribute]
public static bool IsMiscNode(OpenXmlElement element);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[IsReadOnlyAttribute]
internal class DocumentFormat.OpenXml.Framework.Schema.ParticleCollection : ValueType {
    private Type _type;
    private OpenXmlCompositeElement _element;
    private CompiledParticle _compiled;
    [NullableAttribute("2")]
private ParticlePath _elementPath;
    public bool IsNil { get; }
    internal ParticleCollection(Type type, CompiledParticle compiled, OpenXmlCompositeElement element);
    public void Clear();
    public bool get_IsNil();
    public bool Add(OpenXmlElement value);
    public bool Contains(OpenXmlElement item);
    [NullableContextAttribute("2")]
private OpenXmlElement GetNode();
    public Enumerator GetEnumerator();
    private sealed virtual override IEnumerator`1<OpenXmlElement> System.Collections.Generic.IEnumerable<DocumentFormat.OpenXml.OpenXmlElement>.GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class DocumentFormat.OpenXml.Framework.Schema.ParticleCompiler : object {
    private Stack`1<ParticlePathItem> _values;
    private List`1<LookupItem> _path;
    public static LookupItem[] Compile(ParticleConstraint particle);
    private void Visit(ParticleConstraint particle);
    private void Visit(ElementParticle element);
    private void VisitComposite(CompositeParticle seq);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
internal class DocumentFormat.OpenXml.Framework.Schema.ParticlePath : object {
    [NullableAttribute("1")]
private ParticlePathItem[] _values;
    public ParticleType Type { get; }
    [NullableContextAttribute("1")]
private ParticlePath(ParticlePathItem[] values);
    [NullableContextAttribute("1")]
public static ParticlePath Create(ParticlePathItem[] values);
    public ParticleType get_Type();
    public sealed virtual int CompareTo(ParticlePath other);
    [NullableContextAttribute("1")]
public virtual string ToString();
    private int CompareTo(ParticlePath other, bool isCompare);
    public bool IsSibling(ParticlePath other);
    public virtual bool Equals(object obj);
    public sealed virtual bool Equals(ParticlePath other);
    public virtual int GetHashCode();
    private bool Equals(ParticlePath other, int length);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class DocumentFormat.OpenXml.Framework.Schema.ParticlePathItem : object {
    [CompilerGeneratedAttribute]
private ParticleType <Type>k__BackingField;
    [CompilerGeneratedAttribute]
private byte <Index>k__BackingField;
    public ParticleType Type { get; }
    public byte Index { get; }
    public ParticlePathItem(ParticleType type, byte index);
    [CompilerGeneratedAttribute]
public ParticleType get_Type();
    [CompilerGeneratedAttribute]
public byte get_Index();
    public void Deconstruct(ParticleType& type, Byte& index);
    [NullableContextAttribute("2")]
public virtual bool Equals(object obj);
    public virtual string ToString();
    [NullableContextAttribute("2")]
public sealed virtual bool Equals(ParticlePathItem other);
    public virtual int GetHashCode();
    public static ParticlePathItem Create(ParticleConstraint particle, byte index);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class DocumentFormat.OpenXml.Framework.SimpleTypeValidator`1 : object {
    private IValidator _other;
    public SimpleTypeValidator`1(IValidator other);
    public sealed virtual void Validate(ValidationContext context);
    private static bool TryTransformValue(ValidationElement& current, OpenXmlSimpleType& type);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class DocumentFormat.OpenXml.Framework.StringValidator : VersionedValidator {
    [CompilerGeneratedAttribute]
private static IValidator <Instance>k__BackingField;
    private static XmlQualifiedName _anyUri;
    private static XmlQualifiedName _token;
    private static XmlQualifiedName _id;
    private static XmlQualifiedName _ncName;
    private static XmlQualifiedName _qname;
    private Nullable`1<long> _minLength;
    private Nullable`1<long> _maxLength;
    private Nullable`1<long> _length;
    [NullableAttribute("2")]
private Regex _regex;
    [NullableAttribute("2")]
[CompilerGeneratedAttribute]
private string <Pattern>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsToken>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsQName>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsNcName>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsId>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsUri>k__BackingField;
    internal static IValidator Instance { get; }
    [NullableAttribute("2")]
public XmlQualifiedName QName { get; }
    public Regex Regex { get; }
    [NullableAttribute("2")]
public string Pattern { get; public set; }
    public bool IsToken { get; public set; }
    public bool IsQName { get; public set; }
    public bool IsNcName { get; public set; }
    public bool IsId { get; public set; }
    public bool IsUri { get; public set; }
    public long MinLength { get; public set; }
    public long MaxLength { get; public set; }
    public long Length { get; public set; }
    private static StringValidator();
    [CompilerGeneratedAttribute]
internal static IValidator get_Instance();
    [NullableContextAttribute("2")]
public sealed virtual XmlQualifiedName get_QName();
    public Regex get_Regex();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public string get_Pattern();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public void set_Pattern(string value);
    [CompilerGeneratedAttribute]
public bool get_IsToken();
    [CompilerGeneratedAttribute]
public void set_IsToken(bool value);
    [CompilerGeneratedAttribute]
public bool get_IsQName();
    [CompilerGeneratedAttribute]
public void set_IsQName(bool value);
    [CompilerGeneratedAttribute]
public bool get_IsNcName();
    [CompilerGeneratedAttribute]
public void set_IsNcName(bool value);
    [CompilerGeneratedAttribute]
public bool get_IsId();
    [CompilerGeneratedAttribute]
public void set_IsId(bool value);
    [CompilerGeneratedAttribute]
public bool get_IsUri();
    [CompilerGeneratedAttribute]
public void set_IsUri(bool value);
    public long get_MinLength();
    public void set_MinLength(long value);
    public long get_MaxLength();
    public void set_MaxLength(long value);
    public long get_Length();
    public void set_Length(long value);
    protected virtual void ValidateVersion(ValidationContext context);
    private void Validate(StringValue str, ValidationContext context, ValidationElement& current, bool includeDetails);
    private static void InvalidEmpty(ValidationContext context, ValidationElement& current, string id, string description);
    [NullableContextAttribute("2")]
private static bool IsValidNcName(OpenXmlSimpleType attributeValue);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class DocumentFormat.OpenXml.Framework.UnionValidator : object {
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private ReadOnlyArray`1<IValidator> _others;
    [CompilerGeneratedAttribute]
private byte <Id>k__BackingField;
    public byte Id { get; }
    public IEnumerable`1<IValidator> Validators { get; }
    public UnionValidator(ReadOnlyArray`1<IValidator> others, byte id);
    [CompilerGeneratedAttribute]
public byte get_Id();
    public IEnumerable`1<IValidator> get_Validators();
    public sealed virtual void Validate(ValidationContext context);
}
internal abstract class DocumentFormat.OpenXml.Framework.VersionedValidator : object {
    private Nullable`1<FileFormatVersions> _version;
    private Nullable`1<FileFormatVersions> _initialVersion;
    public FileFormatVersions Version { get; public set; }
    public FileFormatVersions InitialVersion { get; public set; }
    public FileFormatVersions get_Version();
    public void set_Version(FileFormatVersions value);
    public FileFormatVersions get_InitialVersion();
    public void set_InitialVersion(FileFormatVersions value);
    [NullableContextAttribute("1")]
public sealed virtual void Validate(ValidationContext context);
    private bool IsValid(FileFormatVersions version);
    [NullableContextAttribute("1")]
protected abstract virtual void ValidateVersion(ValidationContext context);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
internal static class DocumentFormat.OpenXml.FrameworkExtensions : object {
    [NullableContextAttribute("2")]
[ExtensionAttribute]
public static bool IsNullOrEmpty(string str);
    [ExtensionAttribute]
public static MemoryStream CopyToMemoryStream(Stream stream);
    [ExtensionAttribute]
public static MemoryStream CopyToMemoryStream(OpenXmlPart part);
}
[AttributeUsageAttribute("4")]
internal class DocumentFormat.OpenXml.Generator.OpenXmlPackageAttribute : Attribute {
    public OpenXmlPackageAttribute(string packageType);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[DebuggerDisplayAttribute("{InnerText}")]
public class DocumentFormat.OpenXml.HexBinaryValue : StringValue {
    internal bool IsValid { get; }
    internal int Length { get; }
    [NullableAttribute("2")]
public string Value { get; public set; }
    [NullableContextAttribute("2")]
public HexBinaryValue(string hexBinary);
    public HexBinaryValue(HexBinaryValue source);
    internal virtual bool get_IsValid();
    internal virtual int get_Length();
    [NullableContextAttribute("2")]
public virtual string get_Value();
    [NullableContextAttribute("2")]
public virtual void set_Value(string value);
    public bool TryGetBytes(Byte[]& bytes);
    [NullableContextAttribute("0")]
internal bool TryWriteBytes(Span`1<byte> bytes);
    [NullableContextAttribute("0")]
internal static HexBinaryValue Create(ReadOnlySpan`1<byte> bytes);
    public static HexBinaryValue Create(Byte[] bytes);
    [NullableContextAttribute("2")]
public static string op_Implicit(HexBinaryValue value);
    public static HexBinaryValue op_Implicit(string value);
    public static HexBinaryValue FromString(string value);
    public static string ToString(HexBinaryValue value);
    private protected virtual OpenXmlSimpleType CloneImpl();
    [CompilerGeneratedAttribute]
internal static bool <get_IsValid>g__IsLetterBetween|4_0(char check, char lower, char upper);
}
internal static class DocumentFormat.OpenXml.HexStringFactory : object {
    internal static string Create(ReadOnlySpan`1<byte> bytes);
    [NullableContextAttribute("1")]
public static string Create(Byte[] bytes);
    [CompilerGeneratedAttribute]
internal static char <Create>g__ToCharUpper|0_0(int value);
}
[NullableContextAttribute("1")]
public interface DocumentFormat.OpenXml.IEnumValue {
    public bool IsValid { get; }
    public FileFormatVersions Version { get; }
    public string Value { get; }
    public abstract virtual bool get_IsValid();
    public abstract virtual FileFormatVersions get_Version();
    public abstract virtual string get_Value();
}
[NullableContextAttribute("1")]
public interface DocumentFormat.OpenXml.IEnumValueFactory`1 {
    public abstract virtual T Create(string value);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[DebuggerDisplayAttribute("{InnerText}")]
public class DocumentFormat.OpenXml.Int16Value : OpenXmlComparableSimpleValue`1<short> {
    public Int16Value(short value);
    public Int16Value(Int16Value source);
    private protected virtual string GetText(short input);
    private protected virtual short Parse(string input);
    public static short op_Implicit(Int16Value value);
    public static Int16Value op_Implicit(short value);
    public static Int16Value FromInt16(short value);
    public static short ToInt16(Int16Value value);
    private protected virtual OpenXmlSimpleType CloneImpl();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[DebuggerDisplayAttribute("{InnerText}")]
public class DocumentFormat.OpenXml.Int32Value : OpenXmlComparableSimpleValue`1<int> {
    public Int32Value(int value);
    public Int32Value(Int32Value source);
    private protected virtual string GetText(int input);
    private protected virtual int Parse(string input);
    public static int op_Implicit(Int32Value value);
    public static Int32Value op_Implicit(int value);
    public static Int32Value FromInt32(int value);
    public static int ToInt32(Int32Value value);
    private protected virtual OpenXmlSimpleType CloneImpl();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[DebuggerDisplayAttribute("{InnerText}")]
public class DocumentFormat.OpenXml.Int64Value : OpenXmlComparableSimpleValue`1<long> {
    public Int64Value(long value);
    public Int64Value(Int64Value source);
    private protected virtual string GetText(long input);
    private protected virtual long Parse(string input);
    public static long op_Implicit(Int64Value value);
    public static Int64Value op_Implicit(long value);
    public static Int64Value FromInt64(long value);
    public static long ToInt64(Int64Value value);
    private protected virtual OpenXmlSimpleType CloneImpl();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[DebuggerDisplayAttribute("{InnerText}")]
public class DocumentFormat.OpenXml.IntegerValue : OpenXmlComparableSimpleValue`1<long> {
    public IntegerValue(long value);
    public IntegerValue(IntegerValue source);
    private protected virtual string GetText(long input);
    private protected virtual long Parse(string input);
    public static long op_Implicit(IntegerValue value);
    public static IntegerValue op_Implicit(long value);
    public static IntegerValue FromInt64(long value);
    public static long ToInt64(IntegerValue value);
    private protected virtual OpenXmlSimpleType CloneImpl();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class DocumentFormat.OpenXml.InvalidMCContentException : Exception {
    public InvalidMCContentException(string message);
    private InvalidMCContentException(SerializationInfo info, StreamingContext context);
    public InvalidMCContentException(string message, Exception innerException);
}
internal interface DocumentFormat.OpenXml.IReadOnlyCollection`1 {
    public int Count { get; }
    public abstract virtual int get_Count();
}
[NullableContextAttribute("1")]
[DefaultMemberAttribute("Item")]
internal interface DocumentFormat.OpenXml.IReadOnlyDictionary`2 {
    public TValue Item { get; }
    public IEnumerable`1<TKey> Keys { get; }
    public IEnumerable`1<TValue> Values { get; }
    public abstract virtual TValue get_Item(TKey key);
    public abstract virtual IEnumerable`1<TKey> get_Keys();
    public abstract virtual IEnumerable`1<TValue> get_Values();
    public abstract virtual bool ContainsKey(TKey key);
    public abstract virtual bool TryGetValue(TKey key, TValue& value);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class DocumentFormat.OpenXml.Lazy`1 : object {
    private object _sync;
    [NullableAttribute("2")]
private T _value;
    [NullableAttribute("2")]
private Func`1<T> _factory;
    private bool _isValueCreated;
    public bool IsValueCreated { get; }
    public T Value { get; }
    public Lazy`1(Func`1<T> factory, bool isThreadSafe);
    public Lazy`1(Func`1<T> factory);
    public bool get_IsValueCreated();
    public T get_Value();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[DebuggerDisplayAttribute("{InnerText}")]
public class DocumentFormat.OpenXml.ListValue`1 : OpenXmlSimpleType {
    [DebuggerBrowsableAttribute("0")]
private static string _listSeparator;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private ObservableCollection`1<T> _list;
    internal bool IsValid { get; }
    public bool HasValue { get; }
    public ICollection`1<T> Items { get; }
    [NullableAttribute("2")]
public string InnerText { get; public set; }
    public ListValue`1(IEnumerable`1<T> list);
    public ListValue`1(ListValue`1<T> list);
    internal virtual bool get_IsValid();
    public virtual bool get_HasValue();
    public ICollection`1<T> get_Items();
    private void Parse();
    private bool TryParse();
    [NullableContextAttribute("2")]
public virtual string get_InnerText();
    [NullableContextAttribute("2")]
public virtual void set_InnerText(string value);
    private protected virtual OpenXmlSimpleType CloneImpl();
    private void CollectionChanged(object sender, NotifyCollectionChangedEventArgs e);
    public sealed virtual IEnumerator`1<T> GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
public class DocumentFormat.OpenXml.MarkupCompatibilityAttributes : object {
    [CompilerGeneratedAttribute]
private StringValue <Ignorable>k__BackingField;
    [CompilerGeneratedAttribute]
private StringValue <ProcessContent>k__BackingField;
    [CompilerGeneratedAttribute]
private StringValue <PreserveElements>k__BackingField;
    [CompilerGeneratedAttribute]
private StringValue <PreserveAttributes>k__BackingField;
    [CompilerGeneratedAttribute]
private StringValue <MustUnderstand>k__BackingField;
    public StringValue Ignorable { get; public set; }
    public StringValue ProcessContent { get; public set; }
    public StringValue PreserveElements { get; public set; }
    public StringValue PreserveAttributes { get; public set; }
    public StringValue MustUnderstand { get; public set; }
    [CompilerGeneratedAttribute]
public StringValue get_Ignorable();
    [CompilerGeneratedAttribute]
public void set_Ignorable(StringValue value);
    [CompilerGeneratedAttribute]
public StringValue get_ProcessContent();
    [CompilerGeneratedAttribute]
public void set_ProcessContent(StringValue value);
    [CompilerGeneratedAttribute]
public StringValue get_PreserveElements();
    [CompilerGeneratedAttribute]
public void set_PreserveElements(StringValue value);
    [CompilerGeneratedAttribute]
public StringValue get_PreserveAttributes();
    [CompilerGeneratedAttribute]
public void set_PreserveAttributes(StringValue value);
    [CompilerGeneratedAttribute]
public StringValue get_MustUnderstand();
    [CompilerGeneratedAttribute]
public void set_MustUnderstand(StringValue value);
    public virtual bool Equals(object obj);
    public sealed virtual bool Equals(MarkupCompatibilityAttributes other);
    public virtual int GetHashCode();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class DocumentFormat.OpenXml.MCConsts : object {
    internal static string Ignorable;
    internal static string ProcessContent;
    internal static string PreserveElements;
    internal static string PreserveAttributes;
    internal static string MustUnderstand;
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class DocumentFormat.OpenXml.MCContext : object {
    private static Char[] Separator;
    private IOpenXmlNamespaceResolver _resolver;
    private Stack`1<string> _currentIgnorable;
    private Stack`1<XmlQualifiedName> _currentPreserveAttr;
    private Stack`1<XmlQualifiedName> _currentPreserveEle;
    private Stack`1<XmlQualifiedName> _currentProcessContent;
    private Stack`1<int> _pushedIgnor;
    private Stack`1<int> _pushedPA;
    private Stack`1<int> _pushedPE;
    private Stack`1<int> _pushedPC;
    private bool _noExceptionOnError;
    [NullableAttribute("2")]
[CompilerGeneratedAttribute]
private LookupNamespace <LookupNamespaceDelegate>k__BackingField;
    [NullableAttribute("2")]
internal LookupNamespace LookupNamespaceDelegate { get; internal set; }
    internal MCContext(IOpenXmlNamespaceResolver resolver);
    internal MCContext(IOpenXmlNamespaceResolver resolver, bool exceptionOnError);
    private static MCContext();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
internal LookupNamespace get_LookupNamespaceDelegate();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
internal void set_LookupNamespaceDelegate(LookupNamespace value);
    internal void PushMCAttributes(MarkupCompatibilityAttributes attr);
    internal void PopMCAttributes();
    internal void PushMCAttributes2(MarkupCompatibilityAttributes attr, LookupNamespace lookupNamespaceDelegate);
    internal void PopMCAttributes2();
    internal static String[] GetPrefixes(string value);
    internal IEnumerable`1<string> ParsePrefixList(string ignorable, OnInvalidValue onInvalidPrefix);
    internal IEnumerable`1<XmlQualifiedName> ParseQNameList(string qnameList, OnInvalidValue onInvalidQName);
    internal bool HasIgnorable();
    internal bool IsIgnorableNs(OpenXmlNamespace& ns);
    internal bool IsPreservedAttribute(OpenXmlQualifiedName& qname);
    internal bool IsPreservedElement(OpenXmlQualifiedName& qname);
    internal bool IsProcessContent(OpenXmlQualifiedName& qname);
    internal bool IsProcessContent(OpenXmlElement element);
    internal AttributeAction GetAttributeAction(OpenXmlQualifiedName& qname, FileFormatVersions format);
    internal ElementAction GetElementAction(OpenXmlElement element, FileFormatVersions format);
    private static bool ContainsQName(OpenXmlQualifiedName& input, Stack`1<XmlQualifiedName> stack);
    private bool OnMcContextError(string value);
    [NullableContextAttribute("2")]
private int PushIgnorable(MarkupCompatibilityAttributes attr);
    private int PushQName(Stack`1<XmlQualifiedName> stack, string value);
    private int PushPreserveAttribute(MarkupCompatibilityAttributes attr);
    private int PushPreserveElement(MarkupCompatibilityAttributes attr);
    [NullableContextAttribute("2")]
private int PushProcessContent(MarkupCompatibilityAttributes attr);
    private void PopIgnorable(int count);
    private void PopPreserveAttribute(int count);
    private void PopPreserveElement(int count);
    private void PopProcessContent(int count);
    internal OpenXmlCompositeElement GetContentFromACBlock(AlternateContent acblk, FileFormatVersions format);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
internal class DocumentFormat.OpenXml.MiscAttrContainer : object {
    [CompilerGeneratedAttribute]
private List`1<OpenXmlAttribute> <ExtendedAttributesField>k__BackingField;
    [CompilerGeneratedAttribute]
private MarkupCompatibilityAttributes <McAttributes>k__BackingField;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private List`1<KeyValuePair`2<string, string>> <NsMappings>k__BackingField;
    internal List`1<OpenXmlAttribute> ExtendedAttributesField { get; internal set; }
    internal MarkupCompatibilityAttributes McAttributes { get; internal set; }
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal List`1<KeyValuePair`2<string, string>> NsMappings { get; internal set; }
    [CompilerGeneratedAttribute]
internal List`1<OpenXmlAttribute> get_ExtendedAttributesField();
    [CompilerGeneratedAttribute]
internal void set_ExtendedAttributesField(List`1<OpenXmlAttribute> value);
    [CompilerGeneratedAttribute]
internal MarkupCompatibilityAttributes get_McAttributes();
    [CompilerGeneratedAttribute]
internal void set_McAttributes(MarkupCompatibilityAttributes value);
    [CompilerGeneratedAttribute]
internal List`1<KeyValuePair`2<string, string>> get_NsMappings();
    [CompilerGeneratedAttribute]
internal void set_NsMappings(List`1<KeyValuePair`2<string, string>> value);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
internal static class DocumentFormat.OpenXml.NamespaceExtensions : object {
    [ExtensionAttribute]
public static IOpenXmlNamespaceResolver GetNamespaceResolver(IFeatureCollection features);
    [ExtensionAttribute]
public static bool IsKnown(IOpenXmlNamespaceResolver resolver, OpenXmlNamespace ns);
    [ExtensionAttribute]
public static bool HasVersion(IOpenXmlNamespaceResolver resolver, OpenXmlNamespace ns, FileFormatVersions version);
    [ExtensionAttribute]
public static OpenXmlQualifiedName ParseQName(IOpenXmlNamespaceResolver resolver, string name, string nsUri);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class DocumentFormat.OpenXml.NamespaceNotUnderstandException : Exception {
    public NamespaceNotUnderstandException(string message);
    private NamespaceNotUnderstandException(SerializationInfo info, StreamingContext context);
    public NamespaceNotUnderstandException(string message, Exception innerException);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[DebuggerDisplayAttribute("{InnerText}")]
public class DocumentFormat.OpenXml.OnOffValue : OpenXmlComparableSimpleValue`1<bool> {
    public OnOffValue(bool value);
    public OnOffValue(OnOffValue source);
    [NullableContextAttribute("2")]
private protected virtual bool Parse(string textValue);
    [NullableContextAttribute("2")]
private protected virtual bool ShouldParse(string value);
    private protected virtual string GetText(bool boolValue);
    private protected virtual OpenXmlSimpleType CloneImpl();
    public static bool op_Implicit(OnOffValue value);
    public static OnOffValue op_Implicit(bool value);
    public static OnOffValue FromBoolean(bool value);
    public static bool ToBoolean(OnOffValue value);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[IsReadOnlyAttribute]
public class DocumentFormat.OpenXml.OpenXmlAttribute : ValueType {
    [CompilerGeneratedAttribute]
private string <Prefix>k__BackingField;
    [NullableAttribute("2")]
[CompilerGeneratedAttribute]
private string <Value>k__BackingField;
    [CompilerGeneratedAttribute]
private OpenXmlQualifiedName <QName>k__BackingField;
    public string NamespaceUri { get; }
    public string LocalName { get; }
    public string Prefix { get; }
    [NullableAttribute("2")]
public string Value { get; }
    public XmlQualifiedName XmlQualifiedName { get; }
    public XName XName { get; }
    internal OpenXmlQualifiedName QName { get; }
    internal OpenXmlAttribute(OpenXmlQualifiedName& qname, string prefix, string value);
    public OpenXmlAttribute(string qualifiedName, string namespaceUri, string value);
    public OpenXmlAttribute(string prefix, string localName, string namespaceUri, string value);
    public string get_NamespaceUri();
    public string get_LocalName();
    [CompilerGeneratedAttribute]
public string get_Prefix();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public string get_Value();
    public XmlQualifiedName get_XmlQualifiedName();
    public XName get_XName();
    [CompilerGeneratedAttribute]
internal OpenXmlQualifiedName get_QName();
    public sealed virtual bool Equals(OpenXmlAttribute other);
    public static bool op_Equality(OpenXmlAttribute attribute1, OpenXmlAttribute attribute2);
    public static bool op_Inequality(OpenXmlAttribute attribute1, OpenXmlAttribute attribute2);
    [NullableContextAttribute("2")]
public virtual bool Equals(object obj);
    public virtual int GetHashCode();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public abstract class DocumentFormat.OpenXml.OpenXmlComparableSimpleReference`1 : OpenXmlSimpleType {
    [NullableAttribute("2")]
public T Value { get; public set; }
    private protected OpenXmlComparableSimpleReference`1(OpenXmlComparableSimpleReference`1<T> source);
    [NullableContextAttribute("2")]
public abstract virtual T get_Value();
    [NullableContextAttribute("2")]
public abstract virtual void set_Value(T value);
    [NullableContextAttribute("2")]
public sealed virtual int CompareTo(object obj);
    public sealed virtual int CompareTo(OpenXmlComparableSimpleReference`1<T> other);
    public sealed virtual bool Equals(OpenXmlComparableSimpleReference`1<T> other);
    [NullableContextAttribute("2")]
public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public static bool op_Equality(OpenXmlComparableSimpleReference`1<T> left, OpenXmlComparableSimpleReference`1<T> right);
    public static bool op_Inequality(OpenXmlComparableSimpleReference`1<T> left, OpenXmlComparableSimpleReference`1<T> right);
    public static bool op_LessThan(OpenXmlComparableSimpleReference`1<T> left, OpenXmlComparableSimpleReference`1<T> right);
    public static bool op_LessThanOrEqual(OpenXmlComparableSimpleReference`1<T> left, OpenXmlComparableSimpleReference`1<T> right);
    public static bool op_GreaterThan(OpenXmlComparableSimpleReference`1<T> left, OpenXmlComparableSimpleReference`1<T> right);
    public static bool op_GreaterThanOrEqual(OpenXmlComparableSimpleReference`1<T> left, OpenXmlComparableSimpleReference`1<T> right);
}
public abstract class DocumentFormat.OpenXml.OpenXmlComparableSimpleValue`1 : OpenXmlSimpleValue`1<T> {
    private protected OpenXmlComparableSimpleValue`1(T value);
    private protected OpenXmlComparableSimpleValue`1(OpenXmlComparableSimpleValue`1<T> source);
    [NullableContextAttribute("2")]
public sealed virtual int CompareTo(object obj);
    public sealed virtual int CompareTo(T other);
    public sealed virtual int CompareTo(OpenXmlComparableSimpleValue`1<T> other);
    public sealed virtual bool Equals(T other);
    public sealed virtual bool Equals(OpenXmlComparableSimpleValue`1<T> other);
    [NullableContextAttribute("2")]
public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public static bool op_Equality(OpenXmlComparableSimpleValue`1<T> left, OpenXmlComparableSimpleValue`1<T> right);
    public static bool op_Inequality(OpenXmlComparableSimpleValue`1<T> left, OpenXmlComparableSimpleValue`1<T> right);
    public static bool op_LessThan(OpenXmlComparableSimpleValue`1<T> left, OpenXmlComparableSimpleValue`1<T> right);
    public static bool op_LessThanOrEqual(OpenXmlComparableSimpleValue`1<T> left, OpenXmlComparableSimpleValue`1<T> right);
    public static bool op_GreaterThan(OpenXmlComparableSimpleValue`1<T> left, OpenXmlComparableSimpleValue`1<T> right);
    public static bool op_GreaterThanOrEqual(OpenXmlComparableSimpleValue`1<T> left, OpenXmlComparableSimpleValue`1<T> right);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public abstract class DocumentFormat.OpenXml.OpenXmlCompositeElement : OpenXmlElement {
    private protected static string UseGenericVersion;
    [NullableAttribute("2")]
private OpenXmlElement _lastChild;
    [NullableAttribute("2")]
public OpenXmlElement FirstChild { get; }
    [NullableAttribute("2")]
public OpenXmlElement LastChild { get; }
    public bool HasChildren { get; }
    public string InnerText { get; }
    unknown string InnerXml {public set; }
    protected OpenXmlCompositeElement(string outerXml);
    protected OpenXmlCompositeElement(IEnumerable`1<OpenXmlElement> childrenElements);
    protected OpenXmlCompositeElement(OpenXmlElement[] childrenElements);
    [NullableContextAttribute("2")]
public virtual OpenXmlElement get_FirstChild();
    [NullableContextAttribute("2")]
public virtual OpenXmlElement get_LastChild();
    public virtual bool get_HasChildren();
    public virtual string get_InnerText();
    public virtual void set_InnerXml(string value);
    public bool AddChild(OpenXmlElement newChild, bool throwOnError);
    [NullableContextAttribute("2")]
public virtual T AppendChild(T newChild);
    [NullableContextAttribute("2")]
public virtual T InsertAfter(T newChild, OpenXmlElement referenceChild);
    [NullableContextAttribute("2")]
public virtual T InsertBefore(T newChild, OpenXmlElement referenceChild);
    [NullableContextAttribute("2")]
public virtual T InsertAt(T newChild, int index);
    [NullableContextAttribute("2")]
public virtual T PrependChild(T newChild);
    [NullableContextAttribute("2")]
public virtual T RemoveChild(T oldChild);
    public virtual void RemoveAllChildren();
    public virtual T ReplaceChild(OpenXmlElement newChild, T oldChild);
    internal virtual void WriteContentTo(XmlWriter w);
    private void ElementInsertingEvent(OpenXmlElement element);
    private void ElementInsertedEvent(OpenXmlElement element);
    private void ElementRemovingEvent(OpenXmlElement element);
    private void ElementRemovedEvent(OpenXmlElement element);
    private protected virtual void Populate(XmlReader xmlReader, OpenXmlLoadMode loadMode);
    private static void RemoveUnnecessaryExtAttr(OpenXmlElement node, OpenXmlElement newnode);
    [NullableContextAttribute("0")]
private protected TElement GetElement();
    [NullableContextAttribute("0")]
private protected bool SetElement(TElement value);
    private void AddANode(OpenXmlElement node);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class DocumentFormat.OpenXml.OpenXmlDomReader : OpenXmlReader {
    private Stack`1<OpenXmlElement> _elementStack;
    private OpenXmlElement _rootElement;
    private ElementState _elementState;
    public ReadOnlyCollection`1<OpenXmlAttribute> Attributes { get; }
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public IEnumerable`1<KeyValuePair`2<string, string>> NamespaceDeclarations { get; }
    public Type ElementType { get; }
    public bool IsMiscNode { get; }
    public bool IsStartElement { get; }
    public bool IsEndElement { get; }
    public int Depth { get; }
    public bool EOF { get; }
    public string LocalName { get; }
    public string NamespaceUri { get; }
    public string Prefix { get; }
    public OpenXmlDomReader(OpenXmlElement openXmlElement);
    public OpenXmlDomReader(OpenXmlElement openXmlElement, bool readMiscNodes);
    public virtual ReadOnlyCollection`1<OpenXmlAttribute> get_Attributes();
    public virtual IEnumerable`1<KeyValuePair`2<string, string>> get_NamespaceDeclarations();
    public virtual Type get_ElementType();
    public virtual bool get_IsMiscNode();
    public virtual bool get_IsStartElement();
    public virtual bool get_IsEndElement();
    public virtual int get_Depth();
    public virtual bool get_EOF();
    public virtual string get_LocalName();
    public virtual string get_NamespaceUri();
    public virtual string get_Prefix();
    public virtual bool Read();
    public virtual bool ReadFirstChild();
    public virtual bool ReadNextSibling();
    public virtual void Skip();
    private bool MoveToNextElement();
    private bool MoveToFirstChild();
    private bool MoveToNextSibling();
    private void InnerSkip();
    public virtual OpenXmlElement LoadCurrentElement();
    public virtual string GetText();
    public virtual void Close();
    private bool ReadRoot();
    private void ThrowIfNull();
    private void ThrowIfEof();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public abstract class DocumentFormat.OpenXml.OpenXmlElement : object {
    [NullableAttribute("2")]
private IFeatureCollection _features;
    private string _rawOuterXml;
    [NullableAttribute("2")]
[CompilerGeneratedAttribute]
private MiscAttrContainer <MiscAttrContainer>k__BackingField;
    [NullableAttribute("2")]
[CompilerGeneratedAttribute]
private OpenXmlElement <Next>k__BackingField;
    private ElementState _state;
    [NullableAttribute("2")]
[CompilerGeneratedAttribute]
private OpenXmlElement <Parent>k__BackingField;
    [NullableAttribute("2")]
internal MiscAttrContainer MiscAttrContainer { get; internal set; }
    [NullableAttribute("2")]
private List`1<OpenXmlAttribute> ExtendedAttributesField { get; private set; }
    public IFeatureCollection Features { get; }
    [NullableAttribute("2")]
private MarkupCompatibilityAttributes McAttributesFiled { get; private set; }
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal List`1<KeyValuePair`2<string, string>> NamespaceDeclField { get; internal set; }
    [NullableAttribute("2")]
internal OpenXmlElement Next { get; internal set; }
    internal bool XmlParsed { get; }
    internal string RawOuterXml { get; internal set; }
    private protected ElementState RawState { get; }
    internal IElementMetadata Metadata { get; }
    internal ElementState ParsedState { get; }
    [NullableAttribute("2")]
public OpenXmlElementContext OpenXmlElementContext { get; }
    [NullableAttribute("2")]
internal OpenXmlElementContext RootElementContext { get; }
    [NullableAttribute("2")]
public OpenXmlElement FirstChild { get; }
    [NullableAttribute("2")]
public OpenXmlElement LastChild { get; }
    public bool HasAttributes { get; }
    public IEnumerable`1<OpenXmlAttribute> ExtendedAttributes { get; }
    public bool HasChildren { get; }
    public OpenXmlElementList ChildElements { get; }
    [NullableAttribute("2")]
public OpenXmlElement Parent { get; internal set; }
    public string NamespaceUri { get; }
    public string LocalName { get; }
    internal OpenXmlQualifiedName QName { get; }
    public string Prefix { get; }
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public IEnumerable`1<KeyValuePair`2<string, string>> NamespaceDeclarations { get; }
    public XmlQualifiedName XmlQualifiedName { get; }
    public XName XName { get; }
    public string InnerText { get; protected set; }
    public string InnerXml { get; public set; }
    public string OuterXml { get; internal set; }
    internal FileFormatVersions InitialVersion { get; }
    [NullableAttribute("2")]
public MarkupCompatibilityAttributes MCAttributes { get; public set; }
    private string MCPrefix { get; }
    protected OpenXmlElement(string outerXml);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
internal MiscAttrContainer get_MiscAttrContainer();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
internal void set_MiscAttrContainer(MiscAttrContainer value);
    [NullableContextAttribute("2")]
private List`1<OpenXmlAttribute> get_ExtendedAttributesField();
    [NullableContextAttribute("2")]
private void set_ExtendedAttributesField(List`1<OpenXmlAttribute> value);
    public IFeatureCollection get_Features();
    private protected virtual IFeatureCollection CreateFeatures();
    [NullableContextAttribute("2")]
private MarkupCompatibilityAttributes get_McAttributesFiled();
    [NullableContextAttribute("2")]
private void set_McAttributesFiled(MarkupCompatibilityAttributes value);
    internal List`1<KeyValuePair`2<string, string>> get_NamespaceDeclField();
    internal void set_NamespaceDeclField(List`1<KeyValuePair`2<string, string>> value);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
internal OpenXmlElement get_Next();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
internal void set_Next(OpenXmlElement value);
    internal bool get_XmlParsed();
    internal string get_RawOuterXml();
    internal void set_RawOuterXml(string value);
    private protected ElementState get_RawState();
    internal IElementMetadata get_Metadata();
    internal ElementState get_ParsedState();
    internal virtual void ConfigureMetadata(Builder builder);
    private protected virtual void SetAttribute(TSimpleType value, string propertyName);
    private protected TSimpleType GetAttribute(string propertyName);
    [NullableContextAttribute("2")]
public OpenXmlElementContext get_OpenXmlElementContext();
    [NullableContextAttribute("2")]
internal virtual OpenXmlElementContext get_RootElementContext();
    [NullableContextAttribute("2")]
public virtual OpenXmlElement get_FirstChild();
    [NullableContextAttribute("2")]
public virtual OpenXmlElement get_LastChild();
    public bool get_HasAttributes();
    public IEnumerable`1<OpenXmlAttribute> get_ExtendedAttributes();
    public abstract virtual bool get_HasChildren();
    public OpenXmlElementList get_ChildElements();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public OpenXmlElement get_Parent();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
internal void set_Parent(OpenXmlElement value);
    public virtual string get_NamespaceUri();
    public virtual string get_LocalName();
    internal OpenXmlQualifiedName get_QName();
    public virtual string get_Prefix();
    public IEnumerable`1<KeyValuePair`2<string, string>> get_NamespaceDeclarations();
    public virtual XmlQualifiedName get_XmlQualifiedName();
    public virtual XName get_XName();
    public virtual string get_InnerText();
    protected virtual void set_InnerText(string value);
    public virtual string get_InnerXml();
    public virtual void set_InnerXml(string value);
    public string get_OuterXml();
    internal void set_OuterXml(string value);
    public OpenXmlAttribute GetAttribute(string localName, string namespaceUri);
    private OpenXmlAttribute GetAttribute(OpenXmlQualifiedName& qname);
    public IList`1<OpenXmlAttribute> GetAttributes();
    public void SetAttribute(OpenXmlAttribute openXmlAttribute);
    public void RemoveAttribute(string localName, string namespaceUri);
    private void RemoveAttribute(OpenXmlQualifiedName& qname);
    public void SetAttributes(IEnumerable`1<OpenXmlAttribute> openXmlAttributes);
    public void ClearAllAttributes();
    public void AddNamespaceDeclaration(string prefix, string uri);
    public void RemoveNamespaceDeclaration(string prefix);
    [NullableContextAttribute("0")]
public T GetFirstChild();
    [NullableContextAttribute("2")]
public OpenXmlElement PreviousSibling();
    [NullableContextAttribute("0")]
public T PreviousSibling();
    [NullableContextAttribute("2")]
public OpenXmlElement NextSibling();
    [NullableContextAttribute("0")]
public T NextSibling();
    public IEnumerable`1<OpenXmlElement> Ancestors();
    public IEnumerable`1<T> Ancestors();
    public IEnumerable`1<T> Elements();
    public IEnumerable`1<OpenXmlElement> Elements();
    public IEnumerable`1<T> Descendants();
    public IEnumerable`1<OpenXmlElement> Descendants();
    public IEnumerable`1<OpenXmlElement> ElementsBefore();
    public IEnumerable`1<OpenXmlElement> ElementsAfter();
    public virtual OpenXmlElement CloneNode(bool deep);
    public virtual void WriteTo(XmlWriter xmlWriter);
    public void Append(IEnumerable`1<OpenXmlElement> newChildren);
    public void Append(OpenXmlElement[] newChildren);
    [NullableContextAttribute("2")]
public virtual T AppendChild(T newChild);
    [NullableContextAttribute("2")]
public virtual T InsertAfter(T newChild, OpenXmlElement referenceChild);
    [NullableContextAttribute("2")]
public virtual T InsertBefore(T newChild, OpenXmlElement referenceChild);
    public T InsertAfterSelf(T newElement);
    public T InsertBeforeSelf(T newElement);
    [NullableContextAttribute("2")]
public virtual T InsertAt(T newChild, int index);
    [NullableContextAttribute("2")]
public virtual T PrependChild(T newChild);
    [NullableContextAttribute("2")]
public virtual T RemoveChild(T oldChild);
    public virtual T ReplaceChild(OpenXmlElement newChild, T oldChild);
    public abstract virtual void RemoveAllChildren();
    [NullableContextAttribute("0")]
public void RemoveAllChildren();
    public void Remove();
    public bool IsAfter(OpenXmlElement element);
    public bool IsBefore(OpenXmlElement element);
    private static ElementOrder GetOrder(OpenXmlElement element1, OpenXmlElement element2);
    private static ElementOrder GetSiblingOrder(OpenXmlElement element1, OpenXmlElement element2);
    private protected virtual void WriteAttributesTo(XmlWriter xmlWriter);
    internal abstract virtual void WriteContentTo(XmlWriter w);
    [NullableContextAttribute("2")]
private protected virtual bool StrictTranslateAttribute(OpenXmlQualifiedName& modreq(System.Runtime.InteropServices.InAttribute) qname, string value);
    [NullableContextAttribute("2")]
private protected virtual bool TrySetFixedAttribute(OpenXmlQualifiedName& modreq(System.Runtime.InteropServices.InAttribute) qname, string value, bool strictRelationshipFound);
    internal virtual void LoadAttributes(XmlReader xmlReader);
    private protected bool PushMcContext(XmlReader xmlReader);
    private protected void PopMcContext();
    private protected void CheckMustUnderstandAttr(XmlReader reader, MarkupCompatibilityAttributes mcAttributes, MarkupCompatibilityProcessSettings mcSettings);
    internal void CheckMustUnderstandAttr();
    internal void Load(XmlReader xmlReader, OpenXmlLoadMode loadMode);
    internal void MakeSureParsed();
    private protected virtual void LazyLoad(XmlReader xmlReader);
    private protected abstract virtual void Populate(XmlReader xmlReader, OpenXmlLoadMode loadMode);
    private protected virtual void ParseXml();
    private protected XmlReader CreateXmlReader();
    private protected XmlReader CreateXmlReader(string outerXml);
    internal OpenXmlElement ElementFactory(XmlReader xmlReader);
    internal OpenXmlElement CreateElement(OpenXmlQualifiedName& qname, string prefix);
    [NullableContextAttribute("2")]
internal virtual OpenXmlElement ElementFactory(OpenXmlQualifiedName& modreq(System.Runtime.InteropServices.InAttribute) qname);
    internal virtual T CloneImp(bool deep);
    private protected void CopyAttributes(OpenXmlElement container);
    private static MarkupCompatibilityAttributes CloneMCAttributes(MarkupCompatibilityAttributes source);
    internal void CopyChildren(OpenXmlElement container, bool deep);
    internal FileFormatVersions get_InitialVersion();
    public void AddAnnotation(object annotation);
    public T Annotation();
    public object Annotation(Type type);
    public IEnumerable`1<T> Annotations();
    public IEnumerable`1<object> Annotations(Type type);
    public void RemoveAnnotations();
    public void RemoveAnnotations(Type type);
    private sealed virtual override IEnumerator`1<OpenXmlElement> System.Collections.Generic.IEnumerable<DocumentFormat.OpenXml.OpenXmlElement>.GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    public sealed virtual object Clone();
    internal bool IsXmlnsUri(string nsUri);
    internal static bool IsKnownElement(OpenXmlElement element);
    private bool ValidOuterXml(string outerXml, string namespaceURI, string localName);
    [NullableContextAttribute("2")]
public MarkupCompatibilityAttributes get_MCAttributes();
    [NullableContextAttribute("2")]
public void set_MCAttributes(MarkupCompatibilityAttributes value);
    private bool LoadMCAttribute(string localName, string value);
    private static MarkupCompatibilityAttributes LoadMCAttribute(XmlReader xmlReader);
    private bool RemoveMCAttribute(string localName);
    private void AddMCAttributes(List`1<OpenXmlAttribute> attributes);
    private OpenXmlAttribute GetMCAttribute(string localName);
    private void WriteMCAttribute(XmlWriter xmlWriter);
    private string get_MCPrefix();
    private int MCAttributeCount();
    internal void RemoveAttributesBasedonMC();
    internal string LookupNamespaceLocal(string prefix);
    internal string LookupPrefixLocal(string uri);
    public string LookupNamespace(string prefix);
    public string LookupPrefix(string namespaceUri);
    [NullableContextAttribute("2")]
internal OpenXmlElement GetNextNonMiscElementSibling();
    [NullableContextAttribute("2")]
internal OpenXmlElement GetFirstNonMiscElementChild();
    [NullableContextAttribute("2")]
internal OpenXmlPartRootElement GetPartRootElement();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public static class DocumentFormat.OpenXml.OpenXmlElementComparers : object {
    [CompilerGeneratedAttribute]
private static IEqualityComparer`1<OpenXmlElement> <Default>k__BackingField;
    public static IEqualityComparer`1<OpenXmlElement> Default { get; }
    private static OpenXmlElementComparers();
    [CompilerGeneratedAttribute]
public static IEqualityComparer`1<OpenXmlElement> get_Default();
    public static IEqualityComparer`1<OpenXmlElement> Create(OpenXmlElementEqualityOptions openXmlElementEqualityOptions);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class DocumentFormat.OpenXml.OpenXmlElementContext : object {
    internal static string XmlnsUri;
    internal static string XmlnsPrefix;
    [NullableAttribute("2")]
private MarkupCompatibilityProcessSettings _mcSettings;
    [CompilerGeneratedAttribute]
private XmlReaderSettings <XmlReaderSettings>k__BackingField;
    [CompilerGeneratedAttribute]
private OpenXmlLoadMode <LoadMode>k__BackingField;
    [CompilerGeneratedAttribute]
private MCContext <MCContext>k__BackingField;
    [CompilerGeneratedAttribute]
private UInt32 <ACBlockLevel>k__BackingField;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private EventHandler`1<ElementEventArgs> ElementInserting;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private EventHandler`1<ElementEventArgs> ElementInserted;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private EventHandler`1<ElementEventArgs> ElementRemoving;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private EventHandler`1<ElementEventArgs> ElementRemoved;
    internal MarkupCompatibilityProcessSettings MCSettings { get; internal set; }
    internal XmlReaderSettings XmlReaderSettings { get; }
    internal OpenXmlLoadMode LoadMode { get; internal set; }
    internal static int LazySteps { get; }
    internal MCContext MCContext { get; }
    internal UInt32 ACBlockLevel { get; internal set; }
    internal OpenXmlElementContext(IOpenXmlNamespaceResolver resolver);
    internal MarkupCompatibilityProcessSettings get_MCSettings();
    internal void set_MCSettings(MarkupCompatibilityProcessSettings value);
    [CompilerGeneratedAttribute]
internal XmlReaderSettings get_XmlReaderSettings();
    [CompilerGeneratedAttribute]
internal OpenXmlLoadMode get_LoadMode();
    [CompilerGeneratedAttribute]
internal void set_LoadMode(OpenXmlLoadMode value);
    internal static int get_LazySteps();
    [CompilerGeneratedAttribute]
internal MCContext get_MCContext();
    [CompilerGeneratedAttribute]
internal UInt32 get_ACBlockLevel();
    [CompilerGeneratedAttribute]
internal void set_ACBlockLevel(UInt32 value);
    internal static XmlReaderSettings CreateDefaultXmlReaderSettings();
    internal bool IsXmlnsUri(string nsUri);
    internal void ElementInsertingEvent(OpenXmlElement element, OpenXmlElement parent);
    internal void ElementInsertedEvent(OpenXmlElement element, OpenXmlElement parent);
    internal void ElementRemovingEvent(OpenXmlElement element, OpenXmlElement parent);
    internal void ElementRemovedEvent(OpenXmlElement element, OpenXmlElement parent);
    [CompilerGeneratedAttribute]
public void add_ElementInserting(EventHandler`1<ElementEventArgs> value);
    [CompilerGeneratedAttribute]
public void remove_ElementInserting(EventHandler`1<ElementEventArgs> value);
    [CompilerGeneratedAttribute]
public void add_ElementInserted(EventHandler`1<ElementEventArgs> value);
    [CompilerGeneratedAttribute]
public void remove_ElementInserted(EventHandler`1<ElementEventArgs> value);
    [CompilerGeneratedAttribute]
public void add_ElementRemoving(EventHandler`1<ElementEventArgs> value);
    [CompilerGeneratedAttribute]
public void remove_ElementRemoving(EventHandler`1<ElementEventArgs> value);
    [CompilerGeneratedAttribute]
public void add_ElementRemoved(EventHandler`1<ElementEventArgs> value);
    [CompilerGeneratedAttribute]
public void remove_ElementRemoved(EventHandler`1<ElementEventArgs> value);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class DocumentFormat.OpenXml.OpenXmlElementEqualityComparer : object {
    [CompilerGeneratedAttribute]
private OpenXmlElementEqualityOptions <Options>k__BackingField;
    internal OpenXmlElementEqualityOptions Options { get; }
    internal OpenXmlElementEqualityComparer(OpenXmlElementEqualityOptions options);
    [CompilerGeneratedAttribute]
internal OpenXmlElementEqualityOptions get_Options();
    [NullableContextAttribute("2")]
public sealed virtual bool Equals(OpenXmlElement x, OpenXmlElement y);
    private bool CheckAndEquateSpecialOptions(OpenXmlElement x, OpenXmlElement y);
    public sealed virtual int GetHashCode(OpenXmlElement obj);
    private static bool PrefixAndQNameEqual(OpenXmlElement x, OpenXmlElement y, OpenXmlElementEqualityOptions options);
    private static bool MoveNextAndTrackCount(Enumerator& e1, Enumerator& e2, Int32& e1ctr, Int32& e2ctr);
}
public class DocumentFormat.OpenXml.OpenXmlElementEqualityOptions : object {
    [CompilerGeneratedAttribute]
private bool <IncludeExtendedAttributes>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IncludeMCAttributes>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <SkipPrefixComparison>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <RequireParsed>k__BackingField;
    public bool IncludeExtendedAttributes { get; public set; }
    public bool IncludeMCAttributes { get; public set; }
    public bool SkipPrefixComparison { get; public set; }
    public bool RequireParsed { get; public set; }
    [CompilerGeneratedAttribute]
public bool get_IncludeExtendedAttributes();
    [CompilerGeneratedAttribute]
public void set_IncludeExtendedAttributes(bool value);
    [CompilerGeneratedAttribute]
public bool get_IncludeMCAttributes();
    [CompilerGeneratedAttribute]
public void set_IncludeMCAttributes(bool value);
    [CompilerGeneratedAttribute]
public bool get_SkipPrefixComparison();
    [CompilerGeneratedAttribute]
public void set_SkipPrefixComparison(bool value);
    [CompilerGeneratedAttribute]
public bool get_RequireParsed();
    [CompilerGeneratedAttribute]
public void set_RequireParsed(bool value);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
internal static class DocumentFormat.OpenXml.OpenXmlElementExtensionMethods : object {
    [ExtensionAttribute]
internal static int GetXPathIndex(OpenXmlElement element);
    [ExtensionAttribute]
internal static OpenXmlPart GetPart(OpenXmlElement element);
    [ExtensionAttribute]
internal static Uri GetPartUri(OpenXmlElement element);
    [ExtensionAttribute]
internal static string GetAttributeValueEx(OpenXmlElement element, string localName, string namespaceUri);
    [ExtensionAttribute]
internal static bool CanContainChild(OpenXmlElement parent, OpenXmlElement child);
    [ExtensionAttribute]
internal static OpenXmlElement TryCreateValidChild(OpenXmlElement parent, FileFormatVersions fileFormat, string namespaceUri, string localName);
    [ExtensionAttribute]
internal static bool IsInVersion(OpenXmlElement element, FileFormatVersions version);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
public static class DocumentFormat.OpenXml.OpenXmlElementFunctionalExtensions : object {
    [ExtensionAttribute]
public static TElement With(TElement element, Object[] content);
    [ExtensionAttribute]
public static TElement With(TElement element, object content);
    private static void AddContent(OpenXmlElement element, object content);
}
[IsReadOnlyAttribute]
[DefaultMemberAttribute("Item")]
public class DocumentFormat.OpenXml.OpenXmlElementList : ValueType {
    [NullableAttribute("1")]
private OpenXmlElement _container;
    [NullableAttribute("1")]
public OpenXmlElement Item { get; }
    public int Count { get; }
    [NullableContextAttribute("1")]
public OpenXmlElementList(OpenXmlElement container);
    [NullableContextAttribute("1")]
public OpenXmlElement get_Item(int index);
    public int get_Count();
    public Enumerator GetEnumerator();
    public T First();
    public sealed virtual bool Equals(OpenXmlElementList other);
    public virtual int GetHashCode();
    [NullableContextAttribute("1")]
private sealed virtual override IEnumerator`1<OpenXmlElement> System.Collections.Generic.IEnumerable<DocumentFormat.OpenXml.OpenXmlElement>.GetEnumerator();
    [NullableContextAttribute("1")]
private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    [CompilerGeneratedAttribute]
public virtual string ToString();
    [CompilerGeneratedAttribute]
private bool PrintMembers(StringBuilder builder);
    [CompilerGeneratedAttribute]
public static bool op_Inequality(OpenXmlElementList left, OpenXmlElementList right);
    [CompilerGeneratedAttribute]
public static bool op_Equality(OpenXmlElementList left, OpenXmlElementList right);
    [CompilerGeneratedAttribute]
public virtual bool Equals(object obj);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public abstract class DocumentFormat.OpenXml.OpenXmlLeafElement : OpenXmlElement {
    [NullableAttribute("2")]
[CompilerGeneratedAttribute]
private OpenXmlElement <ShadowElement>k__BackingField;
    [NullableAttribute("2")]
internal OpenXmlElement ShadowElement { get; internal set; }
    public bool HasChildren { get; }
    public string InnerXml { get; public set; }
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
internal OpenXmlElement get_ShadowElement();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
internal void set_ShadowElement(OpenXmlElement value);
    public virtual bool get_HasChildren();
    public virtual string get_InnerXml();
    public virtual void set_InnerXml(string value);
    internal virtual void WriteContentTo(XmlWriter w);
    public virtual void RemoveAllChildren();
    private protected virtual void Populate(XmlReader xmlReader, OpenXmlLoadMode loadMode);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[DebuggerDisplayAttribute("{Text}")]
public abstract class DocumentFormat.OpenXml.OpenXmlLeafTextElement : OpenXmlLeafElement {
    [NullableAttribute("2")]
[CompilerGeneratedAttribute]
private string <RawInnerText>k__BackingField;
    [NullableAttribute("2")]
internal string RawInnerText { get; internal set; }
    public bool HasChildren { get; }
    public string InnerText { get; protected set; }
    public string InnerXml { get; public set; }
    public string Text { get; public set; }
    protected OpenXmlLeafTextElement(string text);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
internal string get_RawInnerText();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
internal void set_RawInnerText(string value);
    internal virtual OpenXmlSimpleType InnerTextToValue(string text);
    public virtual bool get_HasChildren();
    public virtual string get_InnerText();
    protected virtual void set_InnerText(string value);
    public virtual string get_InnerXml();
    public virtual void set_InnerXml(string value);
    public virtual string get_Text();
    public virtual void set_Text(string value);
    internal virtual void WriteContentTo(XmlWriter w);
    public virtual void RemoveAllChildren();
    private protected virtual void Populate(XmlReader xmlReader, OpenXmlLoadMode loadMode);
    internal virtual T CloneImp(bool deep);
}
internal enum DocumentFormat.OpenXml.OpenXmlLoadMode : Enum {
    public int value__;
    public static OpenXmlLoadMode Full;
    public static OpenXmlLoadMode Lazy;
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class DocumentFormat.OpenXml.OpenXmlMiscNode : OpenXmlElement {
    private static string StrCDataSectionName;
    private static string StrCommentName;
    private static string StrTextName;
    private static string StrNonSignificantWhitespaceName;
    private static string StrSignificantWhitespaceName;
    private static string StrXmlDeclaration;
    [CompilerGeneratedAttribute]
private XmlNodeType <XmlNodeType>k__BackingField;
    public XmlNodeType XmlNodeType { get; private set; }
    public bool HasChildren { get; }
    public string LocalName { get; }
    public string NamespaceUri { get; }
    public string Prefix { get; }
    public XmlQualifiedName XmlQualifiedName { get; }
    public string InnerXml { get; public set; }
    public OpenXmlMiscNode(XmlNodeType nodeType);
    public OpenXmlMiscNode(XmlNodeType nodeType, string outerXml);
    [CompilerGeneratedAttribute]
public XmlNodeType get_XmlNodeType();
    [CompilerGeneratedAttribute]
private void set_XmlNodeType(XmlNodeType value);
    public virtual bool get_HasChildren();
    public virtual string get_LocalName();
    public virtual string get_NamespaceUri();
    public virtual string get_Prefix();
    public virtual XmlQualifiedName get_XmlQualifiedName();
    public virtual string get_InnerXml();
    public virtual void set_InnerXml(string value);
    public virtual OpenXmlElement CloneNode(bool deep);
    public virtual void RemoveAllChildren();
    internal virtual void WriteContentTo(XmlWriter w);
    public virtual void WriteTo(XmlWriter xmlWriter);
    private protected virtual void LazyLoad(XmlReader xmlReader);
    private protected virtual void ParseXml();
    internal void LoadOuterXml(XmlReader xmlReader);
    internal virtual void LoadAttributes(XmlReader xmlReader);
    private protected virtual void Populate(XmlReader xmlReader, OpenXmlLoadMode loadMode);
    internal static OpenXmlMiscNode CreateFromText(string text);
    internal static OpenXmlMiscNode CreateFromCdata(string value);
    internal static OpenXmlMiscNode CreateFromSignificantWhitespace(string whitespace);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class DocumentFormat.OpenXml.OpenXmlPartReader : OpenXmlReader {
    private IRootElementFeature _rootElements;
    private IOpenXmlNamespaceResolver _resolver;
    private XmlReader _xmlReader;
    private List`1<OpenXmlAttribute> _attributeList;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private List`1<KeyValuePair`2<string, string>> _nsDecls;
    private Stack`1<OpenXmlElement> _elementStack;
    [NullableAttribute("2")]
[DebuggerBrowsableAttribute("0")]
private string _encoding;
    [DebuggerBrowsableAttribute("0")]
private Nullable`1<bool> _standalone;
    private ElementState _elementState;
    [NullableAttribute("2")]
public string Encoding { get; }
    public Nullable`1<bool> StandaloneXml { get; }
    public ReadOnlyCollection`1<OpenXmlAttribute> Attributes { get; }
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public IEnumerable`1<KeyValuePair`2<string, string>> NamespaceDeclarations { get; }
    public Type ElementType { get; }
    public bool IsMiscNode { get; }
    public bool IsStartElement { get; }
    public bool IsEndElement { get; }
    public int Depth { get; }
    public bool EOF { get; }
    public string LocalName { get; }
    public string NamespaceUri { get; }
    public string Prefix { get; }
    public OpenXmlPartReader(OpenXmlPart openXmlPart);
    public OpenXmlPartReader(OpenXmlPart openXmlPart, OpenXmlPartReaderOptions options);
    public OpenXmlPartReader(OpenXmlPart openXmlPart, bool readMiscNodes);
    public OpenXmlPartReader(OpenXmlPart openXmlPart, bool readMiscNodes, bool ignoreWhitespace);
    public OpenXmlPartReader(Stream partStream, IFeatureCollection features, OpenXmlPartReaderOptions options);
    private static Stream GetPartStream(OpenXmlPart openXmlPart);
    [NullableContextAttribute("2")]
public virtual string get_Encoding();
    public virtual Nullable`1<bool> get_StandaloneXml();
    public virtual ReadOnlyCollection`1<OpenXmlAttribute> get_Attributes();
    public virtual IEnumerable`1<KeyValuePair`2<string, string>> get_NamespaceDeclarations();
    public virtual Type get_ElementType();
    public virtual bool get_IsMiscNode();
    public virtual bool get_IsStartElement();
    public virtual bool get_IsEndElement();
    public virtual int get_Depth();
    public virtual bool get_EOF();
    public virtual string get_LocalName();
    public virtual string get_NamespaceUri();
    public virtual string get_Prefix();
    public virtual bool Read();
    public virtual bool ReadFirstChild();
    public virtual bool ReadNextSibling();
    public virtual void Skip();
    public virtual IXmlLineInfo GetLineInfo();
    private bool MoveToNextElement();
    private bool MoveToFirstChild();
    private bool MoveToNextSibling();
    private void InnerSkip();
    [NullableContextAttribute("2")]
public virtual OpenXmlElement LoadCurrentElement();
    public virtual string GetText();
    public virtual void Close();
    private XmlReader CreateReader(Stream partStream, bool closeInput, long maxCharactersInPart, bool ignoreWhitespace, Nullable`1& standalone, String& encoding);
    private bool ReadRoot();
    private OpenXmlElement CreateElement(OpenXmlQualifiedName& qname);
    private void LoadAttributes();
    private void GetElementInformation();
    private OpenXmlElement CreateChildElement();
    private void ThrowIfNull();
    private void ThrowIfEof();
}
public class DocumentFormat.OpenXml.OpenXmlPartReaderOptions : ValueType {
    [CompilerGeneratedAttribute]
private bool <ReadMiscellaneousNodes>k__BackingField;
    [CompilerGeneratedAttribute]
private long <MaxCharactersInPart>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IgnoreWhitespace>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <CloseStream>k__BackingField;
    public bool ReadMiscellaneousNodes { get; public set; }
    public long MaxCharactersInPart { get; public set; }
    public bool IgnoreWhitespace { get; public set; }
    public bool CloseStream { get; public set; }
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public bool get_ReadMiscellaneousNodes();
    [CompilerGeneratedAttribute]
public void set_ReadMiscellaneousNodes(bool value);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public long get_MaxCharactersInPart();
    [CompilerGeneratedAttribute]
public void set_MaxCharactersInPart(long value);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public bool get_IgnoreWhitespace();
    [CompilerGeneratedAttribute]
public void set_IgnoreWhitespace(bool value);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public bool get_CloseStream();
    [CompilerGeneratedAttribute]
public void set_CloseStream(bool value);
    [NullableContextAttribute("1")]
internal OpenXmlPartReaderOptions UpdateForPart(OpenXmlPart part);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public abstract class DocumentFormat.OpenXml.OpenXmlPartRootElement : OpenXmlCompositeElement {
    [NullableAttribute("2")]
private OpenXmlElementContext _context;
    private Nullable`1<bool> _standaloneDeclaration;
    [NullableAttribute("2")]
[CompilerGeneratedAttribute]
private OpenXmlPart <OpenXmlPart>k__BackingField;
    internal OpenXmlElementContext RootElementContext { get; }
    [NullableAttribute("2")]
public OpenXmlPart OpenXmlPart { get; internal set; }
    internal bool WriteAllNamespaceOnRoot { get; }
    protected OpenXmlPartRootElement(OpenXmlPart openXmlPart);
    protected OpenXmlPartRootElement(string outerXml);
    protected OpenXmlPartRootElement(IEnumerable`1<OpenXmlElement> childElements);
    protected OpenXmlPartRootElement(OpenXmlElement[] childElements);
    internal virtual OpenXmlElementContext get_RootElementContext();
    internal void LoadFromPart(OpenXmlPart openXmlPart);
    internal bool LoadFromPart(OpenXmlPart openXmlPart, Stream partStream);
    internal void SaveToPart(OpenXmlPart openXmlPart);
    public void Save(Stream stream);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public OpenXmlPart get_OpenXmlPart();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
internal void set_OpenXmlPart(OpenXmlPart value);
    public void Save();
    public void Reload();
    public virtual void WriteTo(XmlWriter xmlWriter);
    private void WriteNamespaceAtributes(XmlWriter xmlWrite);
    internal virtual bool get_WriteAllNamespaceOnRoot();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class DocumentFormat.OpenXml.OpenXmlPartWriter : OpenXmlWriter {
    private XmlWriter _xmlWriter;
    private bool _isLeafTextElementStart;
    public OpenXmlPartWriter(OpenXmlPart openXmlPart);
    public OpenXmlPartWriter(OpenXmlPart openXmlPart, Encoding encoding);
    public OpenXmlPartWriter(Stream partStream);
    public OpenXmlPartWriter(Stream partStream, Encoding encoding);
    public virtual void WriteStartDocument();
    public virtual void WriteStartDocument(bool standalone);
    public virtual void WriteStartElement(OpenXmlReader elementReader);
    public virtual void WriteStartElement(OpenXmlReader elementReader, IEnumerable`1<OpenXmlAttribute> attributes);
    public virtual void WriteStartElement(OpenXmlReader elementReader, IEnumerable`1<OpenXmlAttribute> attributes, IEnumerable`1<KeyValuePair`2<string, string>> namespaceDeclarations);
    public virtual void WriteStartElement(OpenXmlElement elementObject);
    public virtual void WriteStartElement(OpenXmlElement elementObject, IEnumerable`1<OpenXmlAttribute> attributes);
    public virtual void WriteStartElement(OpenXmlElement elementObject, IEnumerable`1<OpenXmlAttribute> attributes, IEnumerable`1<KeyValuePair`2<string, string>> namespaceDeclarations);
    public virtual void WriteEndElement();
    public virtual void WriteString(string text);
    public virtual void WriteElement(OpenXmlElement elementObject);
    public virtual void Close();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public abstract class DocumentFormat.OpenXml.OpenXmlReader : object {
    private bool _readMiscNodes;
    private bool _disposed;
    public bool ReadMiscNodes { get; }
    [NullableAttribute("2")]
public string Encoding { get; }
    public Nullable`1<bool> StandaloneXml { get; }
    public bool HasAttributes { get; }
    public ReadOnlyCollection`1<OpenXmlAttribute> Attributes { get; }
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public IEnumerable`1<KeyValuePair`2<string, string>> NamespaceDeclarations { get; }
    public Type ElementType { get; }
    public bool IsMiscNode { get; }
    public bool IsStartElement { get; }
    public bool IsEndElement { get; }
    public int Depth { get; }
    public bool EOF { get; }
    public string LocalName { get; }
    public string NamespaceUri { get; }
    public string Prefix { get; }
    protected OpenXmlReader(bool readMiscNodes);
    public static OpenXmlReader Create(OpenXmlPart openXmlPart);
    public static OpenXmlReader Create(OpenXmlPart openXmlPart, bool readMiscNodes);
    public static OpenXmlReader Create(OpenXmlPart openXmlPart, bool readMiscNodes, bool ignoreWhitespace);
    public static OpenXmlReader Create(OpenXmlElement openXmlElement);
    public static OpenXmlReader Create(OpenXmlElement openXmlElement, bool readMiscNodes);
    public bool get_ReadMiscNodes();
    [NullableContextAttribute("2")]
public virtual string get_Encoding();
    public virtual Nullable`1<bool> get_StandaloneXml();
    public virtual bool get_HasAttributes();
    public abstract virtual ReadOnlyCollection`1<OpenXmlAttribute> get_Attributes();
    public abstract virtual IEnumerable`1<KeyValuePair`2<string, string>> get_NamespaceDeclarations();
    public abstract virtual Type get_ElementType();
    public abstract virtual bool get_IsMiscNode();
    public abstract virtual bool get_IsStartElement();
    public abstract virtual bool get_IsEndElement();
    public abstract virtual int get_Depth();
    public abstract virtual bool get_EOF();
    public abstract virtual string get_LocalName();
    public abstract virtual string get_NamespaceUri();
    public abstract virtual string get_Prefix();
    public virtual IXmlLineInfo GetLineInfo();
    public abstract virtual bool Read();
    public abstract virtual bool ReadFirstChild();
    public abstract virtual bool ReadNextSibling();
    public abstract virtual void Skip();
    [NullableContextAttribute("2")]
public abstract virtual OpenXmlElement LoadCurrentElement();
    public abstract virtual string GetText();
    public abstract virtual void Close();
    protected virtual void ThrowIfObjectDisposed();
    protected virtual void Dispose(bool disposing);
    public sealed virtual void Dispose();
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
public abstract class DocumentFormat.OpenXml.OpenXmlSimpleType : object {
    [CompilerGeneratedAttribute]
private string <TextValue>k__BackingField;
    private protected string TextValue { get; private protected set; }
    public bool HasValue { get; }
    internal bool IsValid { get; }
    public string InnerText { get; public set; }
    internal bool IsEnum { get; }
    [NullableContextAttribute("1")]
protected OpenXmlSimpleType(OpenXmlSimpleType source);
    [CompilerGeneratedAttribute]
private protected string get_TextValue();
    [CompilerGeneratedAttribute]
private protected void set_TextValue(string value);
    public virtual bool get_HasValue();
    internal abstract virtual bool get_IsValid();
    public virtual string get_InnerText();
    public virtual void set_InnerText(string value);
    internal virtual bool get_IsEnum();
    public virtual string ToString();
    [NullableContextAttribute("1")]
public sealed virtual object Clone();
    [NullableContextAttribute("1")]
private protected abstract virtual OpenXmlSimpleType CloneImpl();
    public static string op_Implicit(OpenXmlSimpleType xmlAttribute);
    internal virtual bool IsInVersion(FileFormatVersions fileFormat);
}
[DebuggerDisplayAttribute("{InnerText}")]
public abstract class DocumentFormat.OpenXml.OpenXmlSimpleValue`1 : OpenXmlSimpleType {
    [CompilerGeneratedAttribute]
private Nullable`1<T> <InnerValue>k__BackingField;
    private protected Nullable`1<T> InnerValue { get; private protected set; }
    public bool HasValue { get; }
    public T Value { get; public set; }
    [NullableAttribute("2")]
public string InnerText { get; public set; }
    internal bool IsValid { get; }
    protected OpenXmlSimpleValue`1(T value);
    protected OpenXmlSimpleValue`1(OpenXmlSimpleValue`1<T> source);
    [CompilerGeneratedAttribute]
private protected Nullable`1<T> get_InnerValue();
    [CompilerGeneratedAttribute]
private protected void set_InnerValue(Nullable`1<T> value);
    public virtual bool get_HasValue();
    public T get_Value();
    public void set_Value(T value);
    [NullableContextAttribute("2")]
public virtual string get_InnerText();
    [NullableContextAttribute("2")]
public virtual void set_InnerText(string value);
    [NullableContextAttribute("2")]
private protected virtual bool ShouldParse(string value);
    private protected virtual void ValidateSet(T value);
    private protected abstract virtual string GetText(T input);
    private protected abstract virtual T Parse(string input);
    internal sealed virtual bool get_IsValid();
    private protected virtual bool TryParse(string input, T& value);
    public static T op_Implicit(OpenXmlSimpleValue`1<T> xmlAttribute);
    [NullableContextAttribute("2")]
public virtual bool Equals(object obj);
    public virtual int GetHashCode();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class DocumentFormat.OpenXml.OpenXmlUnknownElement : OpenXmlCompositeElement {
    private string _namespaceUri;
    private string _tagName;
    private string _prefix;
    private string _text;
    public string LocalName { get; }
    public string NamespaceUri { get; }
    public string Prefix { get; }
    public XmlQualifiedName XmlQualifiedName { get; }
    public string InnerText { get; }
    public string Text { get; }
    public OpenXmlUnknownElement(string name);
    public OpenXmlUnknownElement(string qualifiedName, string namespaceUri);
    internal OpenXmlUnknownElement(OpenXmlQualifiedName& qname, string prefix);
    public OpenXmlUnknownElement(string prefix, string localName, string namespaceUri);
    public virtual string get_LocalName();
    public virtual string get_NamespaceUri();
    public virtual string get_Prefix();
    public virtual XmlQualifiedName get_XmlQualifiedName();
    public virtual string get_InnerText();
    public string get_Text();
    public virtual OpenXmlElement CloneNode(bool deep);
    internal virtual void WriteContentTo(XmlWriter w);
    public virtual void WriteTo(XmlWriter xmlWriter);
    private protected virtual void LazyLoad(XmlReader xmlReader);
    private protected virtual void Populate(XmlReader xmlReader, OpenXmlLoadMode loadMode);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
public static class DocumentFormat.OpenXml.OpenXmlUnknownElementExtensions : object {
    [ExtensionAttribute]
public static OpenXmlUnknownElement CreateUnknownElement(OpenXmlPartContainer container, string outerXml);
    internal static OpenXmlUnknownElement CreateOpenXmlUnknownElement(IFeatureCollection features, string outerXml);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public abstract class DocumentFormat.OpenXml.OpenXmlWriter : object {
    private bool _disposed;
    public static OpenXmlWriter Create(OpenXmlPart openXmlPart);
    public static OpenXmlWriter Create(OpenXmlPart openXmlPart, Encoding encoding);
    public static OpenXmlWriter Create(Stream partStream);
    public static OpenXmlWriter Create(Stream partStream, Encoding encoding);
    public abstract virtual void WriteStartDocument();
    public abstract virtual void WriteStartDocument(bool standalone);
    public abstract virtual void WriteStartElement(OpenXmlReader elementReader);
    public abstract virtual void WriteStartElement(OpenXmlReader elementReader, IEnumerable`1<OpenXmlAttribute> attributes);
    public abstract virtual void WriteStartElement(OpenXmlReader elementReader, IEnumerable`1<OpenXmlAttribute> attributes, IEnumerable`1<KeyValuePair`2<string, string>> namespaceDeclarations);
    public abstract virtual void WriteStartElement(OpenXmlElement elementObject);
    public abstract virtual void WriteStartElement(OpenXmlElement elementObject, IEnumerable`1<OpenXmlAttribute> attributes);
    public abstract virtual void WriteStartElement(OpenXmlElement elementObject, IEnumerable`1<OpenXmlAttribute> attributes, IEnumerable`1<KeyValuePair`2<string, string>> namespaceDeclarations);
    public abstract virtual void WriteEndElement();
    public abstract virtual void WriteElement(OpenXmlElement elementObject);
    public abstract virtual void WriteString(string text);
    public abstract virtual void Close();
    protected virtual void ThrowIfObjectDisposed();
    protected virtual void Dispose(bool disposing);
    public sealed virtual void Dispose();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[RelationshipTypeAttribute("http://schemas.openxmlformats.org/officeDocument/2006/relationships/audio")]
public class DocumentFormat.OpenXml.Packaging.AudioReferenceRelationship : DataPartReferenceRelationship {
    internal static string RelationshipTypeConst;
    public static string AudioReferenceRelationshipType { get; }
    public string RelationshipType { get; }
    protected internal AudioReferenceRelationship(MediaDataPart mediaDataPart, string id);
    public static string get_AudioReferenceRelationshipType();
    public virtual string get_RelationshipType();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal abstract class DocumentFormat.OpenXml.Packaging.Builder.DelegatingPackageFeature : object {
    [CompilerGeneratedAttribute]
private IPackageFeature <Feature>k__BackingField;
    protected IPackage Package { get; }
    protected IPackageFeature Feature { get; }
    public FileAccess FileOpenAccess { get; }
    public IPackageProperties PackageProperties { get; }
    private IPackage DocumentFormat.OpenXml.Features.IPackageFeature.Package { get; }
    public PackageCapabilities Capabilities { get; }
    public IRelationshipCollection Relationships { get; }
    protected DelegatingPackageFeature(IPackageFeature package);
    protected IPackage get_Package();
    [CompilerGeneratedAttribute]
protected IPackageFeature get_Feature();
    public virtual FileAccess get_FileOpenAccess();
    public virtual IPackageProperties get_PackageProperties();
    private sealed virtual override IPackage DocumentFormat.OpenXml.Features.IPackageFeature.get_Package();
    public virtual IPackagePart CreatePart(Uri partUri, string contentType, CompressionOption compressionOption);
    public virtual void DeletePart(Uri uri);
    public virtual IPackagePart GetPart(Uri uriTarget);
    public virtual IEnumerable`1<IPackagePart> GetParts();
    public virtual bool PartExists(Uri partUri);
    public virtual void Save();
    public virtual PackageCapabilities get_Capabilities();
    public virtual IRelationshipCollection get_Relationships();
    public sealed virtual void Reload(Nullable`1<FileMode> mode, Nullable`1<FileAccess> access);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal abstract class DocumentFormat.OpenXml.Packaging.Builder.DelegatingPackagePart : object {
    [CompilerGeneratedAttribute]
private IPackagePart <OriginalPart>k__BackingField;
    [CompilerGeneratedAttribute]
private IPackage <Package>k__BackingField;
    public IPackagePart OriginalPart { get; }
    public IPackage Package { get; }
    public Uri Uri { get; }
    public string ContentType { get; }
    public IRelationshipCollection Relationships { get; }
    protected DelegatingPackagePart(IPackage package, IPackagePart part);
    [CompilerGeneratedAttribute]
public IPackagePart get_OriginalPart();
    [CompilerGeneratedAttribute]
public sealed virtual IPackage get_Package();
    public virtual Uri get_Uri();
    public virtual string get_ContentType();
    public virtual IRelationshipCollection get_Relationships();
    public virtual Stream GetStream(FileMode open, FileAccess write);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class DocumentFormat.OpenXml.Packaging.Builder.PackageRelationshipBuilder : object {
    [CompilerGeneratedAttribute]
private Uri <PartUri>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Id>k__BackingField;
    [CompilerGeneratedAttribute]
private string <RelationshipType>k__BackingField;
    [CompilerGeneratedAttribute]
private Uri <SourceUri>k__BackingField;
    [CompilerGeneratedAttribute]
private TargetMode <TargetMode>k__BackingField;
    [CompilerGeneratedAttribute]
private Uri <TargetUri>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsRemoved>k__BackingField;
    public Uri PartUri { get; }
    public string Id { get; public set; }
    public string RelationshipType { get; public set; }
    public Uri SourceUri { get; public set; }
    public TargetMode TargetMode { get; public set; }
    public Uri TargetUri { get; public set; }
    internal bool IsRemoved { get; internal set; }
    internal PackageRelationshipBuilder(Uri partUri, PackageRelationship relationship);
    [CompilerGeneratedAttribute]
public Uri get_PartUri();
    [CompilerGeneratedAttribute]
public sealed virtual string get_Id();
    [CompilerGeneratedAttribute]
public void set_Id(string value);
    [CompilerGeneratedAttribute]
public sealed virtual string get_RelationshipType();
    [CompilerGeneratedAttribute]
public void set_RelationshipType(string value);
    [CompilerGeneratedAttribute]
public sealed virtual Uri get_SourceUri();
    [CompilerGeneratedAttribute]
public void set_SourceUri(Uri value);
    [CompilerGeneratedAttribute]
public sealed virtual TargetMode get_TargetMode();
    [CompilerGeneratedAttribute]
public void set_TargetMode(TargetMode value);
    [CompilerGeneratedAttribute]
public sealed virtual Uri get_TargetUri();
    [CompilerGeneratedAttribute]
public void set_TargetUri(Uri value);
    [CompilerGeneratedAttribute]
internal bool get_IsRemoved();
    [CompilerGeneratedAttribute]
internal void set_IsRemoved(bool value);
}
[ExtensionAttribute]
internal static class DocumentFormat.OpenXml.Packaging.Builder.SavePackageExtensions : object {
    [NullableContextAttribute("1")]
[ExtensionAttribute]
public static void EnableSavePackage(OpenXmlPackage package);
    [NullableContextAttribute("1")]
[ExtensionAttribute]
internal static IFeatureCollection EnableSavePackage(IFeatureCollection features);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
public static class DocumentFormat.OpenXml.Packaging.CloneableExtensions : object {
    [ExtensionAttribute]
public static TPackage Clone(TPackage openXmlPackage);
    [ExtensionAttribute]
public static TPackage Clone(TPackage openXmlPackage, Stream stream);
    [ExtensionAttribute]
public static TPackage Clone(TPackage openXmlPackage, Stream stream, bool isEditable);
    [ExtensionAttribute]
public static TPackage Clone(TPackage openXmlPackage, Stream stream, bool isEditable, OpenSettings openSettings);
    [ExtensionAttribute]
internal static void Clone(TPackage source, TPackage destination);
    [ExtensionAttribute]
public static TPackage Clone(TPackage openXmlPackage, string path);
    [ExtensionAttribute]
public static TPackage Clone(TPackage openXmlPackage, string path, bool isEditable);
    [ExtensionAttribute]
public static TPackage Clone(TPackage openXmlPackage, string path, bool isEditable, OpenSettings openSettings);
    [ExtensionAttribute]
public static TPackage Clone(TPackage openXmlPackage, Package package);
    [ExtensionAttribute]
public static TPackage Clone(TPackage openXmlPackage, Package package, OpenSettings openSettings);
    [ExtensionAttribute]
private static TPackage CopyFrom(TPackage destination, TPackage source, OpenSettings settings);
    [ExtensionAttribute]
internal static TPackage Reload(TPackage openXmlPackage, Nullable`1<bool> isEditable);
}
public enum DocumentFormat.OpenXml.Packaging.CompatibilityLevel : Enum {
    public int value__;
    public static CompatibilityLevel Default;
    public static CompatibilityLevel Version_2_20;
    public static CompatibilityLevel Version_3_0;
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class DocumentFormat.OpenXml.Packaging.DataPart : object {
    private static string DefaultTargetPart;
    private static string DefaultTargetName;
    private static string DefaultTargetExt;
    [DebuggerBrowsableAttribute("0")]
private IPackagePart _metroPart;
    [DebuggerBrowsableAttribute("0")]
private Uri _uri;
    [NullableAttribute("2")]
[DebuggerBrowsableAttribute("0")]
private OpenXmlPackage _openXmlPackage;
    public OpenXmlPackage OpenXmlPackage { get; }
    public Uri Uri { get; }
    public string ContentType { get; }
    internal IPackagePart PackagePart { get; }
    internal string TargetPath { get; }
    internal string TargetName { get; }
    internal string TargetFileExtension { get; }
    private protected DataPart(OpenXmlPackage openXmlPackage, IPackagePart packagePart);
    private protected DataPart(OpenXmlPackage openXmlPackage, string contentType, string extension);
    private protected DataPart(OpenXmlPackage openXmlPackage, MediaDataPartType mediaDataPartType);
    private protected DataPart(OpenXmlPackage openXmlPackage, string contentType, Uri partUri);
    public OpenXmlPackage get_OpenXmlPackage();
    public Uri get_Uri();
    public IEnumerable`1<DataPartReferenceRelationship> GetDataPartReferenceRelationships();
    public Stream GetStream();
    public Stream GetStream(FileMode mode);
    public Stream GetStream(FileMode mode, FileAccess access);
    public void FeedData(Stream sourceStream);
    public virtual string get_ContentType();
    internal IPackagePart get_PackagePart();
    internal virtual string get_TargetPath();
    internal virtual string get_TargetName();
    internal virtual string get_TargetFileExtension();
    private Uri NewPartUri(OpenXmlPackage openXmlPackage, string contentType, string extension);
    internal void Destroy();
    [MemberNotNullAttribute("_openXmlPackage")]
protected void ThrowIfObjectDisposed();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class DocumentFormat.OpenXml.Packaging.DataPartReferenceRelationship : ReferenceRelationship {
    [CompilerGeneratedAttribute]
private DataPart <DataPart>k__BackingField;
    public DataPart DataPart { get; private set; }
    protected internal DataPartReferenceRelationship(DataPart dataPart, string relationshipType, string id);
    internal DataPartReferenceRelationship(OpenXmlPartContainer containter, DataPart dataPart, string relationshipType, string id);
    [CompilerGeneratedAttribute]
public virtual DataPart get_DataPart();
    [CompilerGeneratedAttribute]
private void set_DataPart(DataPart value);
    internal static bool IsDataPartReferenceRelationship(string relationshipType);
    internal static DataPartReferenceRelationship Create(OpenXmlPartContainer container, DataPart dataPart, string relationshipType, string id);
    internal static string GetRelationshipType();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class DocumentFormat.OpenXml.Packaging.ExtendedPart : OpenXmlPart {
    [CompilerGeneratedAttribute]
private string <RelationshipType>k__BackingField;
    public string RelationshipType { get; }
    public IFeatureCollection Features { get; }
    internal ExtendedPart(string relationshipType);
    [CompilerGeneratedAttribute]
public virtual string get_RelationshipType();
    internal virtual bool IsInVersion(FileFormatVersions version);
    internal virtual OpenXmlPart AddPartFrom(OpenXmlPart subPart, string rId);
    internal virtual void InitPart(OpenXmlPart newPart, string contentType, string id);
    public virtual IFeatureCollection get_Features();
}
public class DocumentFormat.OpenXml.Packaging.ExternalRelationship : ReferenceRelationship {
    [NullableContextAttribute("1")]
protected internal ExternalRelationship(Uri externalUri, string relationshipType, string id);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[DefaultMemberAttribute("Item")]
[DebuggerDisplayAttribute("Count = {GetCount()}")]
[DebuggerTypeProxyAttribute("DocumentFormat.OpenXml.Packaging.FeatureCollectionDebugView")]
internal abstract class DocumentFormat.OpenXml.Packaging.FeatureCollectionBase : object {
    private static HashSet`1<Type> Ignored;
    private FeatureContainer _container;
    [NullableAttribute("2")]
[CompilerGeneratedAttribute]
private IFeatureCollection <Parent>k__BackingField;
    [NullableAttribute("2")]
protected IFeatureCollection Parent { get; }
    [NullableAttribute("2")]
public object Item { get; public set; }
    protected IEnumerable`1<Type> KnownTypes { get; }
    public bool IsReadOnly { get; }
    public int Revision { get; }
    private IEnumerable`1<Type> FeatureTypes { get; }
    [NullableContextAttribute("2")]
public FeatureCollectionBase(IFeatureCollection parent);
    private static FeatureCollectionBase();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
protected virtual IFeatureCollection get_Parent();
    public sealed virtual object get_Item(Type key);
    public sealed virtual void set_Item(Type key, object value);
    protected virtual object GetKnown(Type key);
    protected virtual IEnumerable`1<Type> get_KnownTypes();
    public sealed virtual bool get_IsReadOnly();
    public sealed virtual int get_Revision();
    [NullableContextAttribute("2")]
public sealed virtual TFeature Get();
    public sealed virtual IEnumerator`1<KeyValuePair`2<Type, object>> GetEnumerator();
    [NullableContextAttribute("2")]
public sealed virtual void Set(TFeature instance);
    private IEnumerable`1<Type> get_FeatureTypes();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    private int GetCount();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class DocumentFormat.OpenXml.Packaging.FeatureCollectionDebugView : object {
    private IFeatureCollection _features;
    public bool IsReadOnly { get; }
    public int Revision { get; }
    [DebuggerBrowsableAttribute("3")]
public FeatureItem[] Items { get; }
    public FeatureCollectionDebugView(IFeatureCollection features);
    public bool get_IsReadOnly();
    public int get_Revision();
    public FeatureItem[] get_Items();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
public static class DocumentFormat.OpenXml.Packaging.FlatOpcExtensions : object {
    private static string RelationshipContentType;
    private static string AltChunkRelationshipType;
    private static XNamespace Pkg;
    private static XNamespace Rel;
    private static FlatOpcExtensions();
    [ExtensionAttribute]
public static string ToFlatOpcString(OpenXmlPackage package);
    [ExtensionAttribute]
public static XDocument ToFlatOpcDocument(OpenXmlPackage openXmlPackage);
    private static XElement GetContentsAsXml(IPackagePart part, HashSet`1<Uri> altChunkPartUris);
    private static XElement GetBinaryPartContentsAsXml(IPackagePart part);
    private static string ToChunkedBase64String(IPackagePart part);
    private static string ToChunkedBase64String(Byte[] byteArray);
    [ExtensionAttribute]
internal static IPackageBuilder`1<TPackage> UseFlatOpcTemplate(IPackageBuilder`1<TPackage> builder, string text, Nullable`1<bool> isEditable);
    [ExtensionAttribute]
internal static IPackageBuilder`1<TPackage> UseFlatOpcTemplate(IPackageBuilder`1<TPackage> builder, XDocument document, Nullable`1<bool> isEditable);
    private static void AddPackageParts(XElement flatOpcPackage, IPackage package);
    private static void AddXmlPackagePart(XElement flatOpcPart, IPackage package);
    private static void AddBinaryPackagePart(XElement flatOpcPart, IPackage package);
    private static IPackagePart CreatePackagePart(XElement flatOpcPart, IPackage package);
    private static Byte[] FromChunkedBase64String(string chunkedBase64String);
    private static void AddPackageRelationships(XElement flatOpcPackage, IPackage package);
    private static void AddPackageLevelRelationships(XElement flatOpcRelationshipPart, IPackage package);
    private static void AddPartLevelRelationships(XElement flatOpcRelationshipPart, IPackage package);
    private static IPackagePart GetSourcePart(XElement flatOpcRelationshipPart, IPackage package);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class DocumentFormat.OpenXml.Packaging.HyperlinkRelationship : ReferenceRelationship {
    internal static string RelationshipTypeConst;
    public string RelationshipType { get; }
    protected internal HyperlinkRelationship(Uri hyperlinkUri, bool isExternal, string id);
    public virtual string get_RelationshipType();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[IsReadOnlyAttribute]
public class DocumentFormat.OpenXml.Packaging.IdPartPair : ValueType {
    [CompilerGeneratedAttribute]
private string <RelationshipId>k__BackingField;
    [CompilerGeneratedAttribute]
private OpenXmlPart <OpenXmlPart>k__BackingField;
    public string RelationshipId { get; }
    public OpenXmlPart OpenXmlPart { get; }
    public IdPartPair(string id, OpenXmlPart part);
    [CompilerGeneratedAttribute]
public string get_RelationshipId();
    [CompilerGeneratedAttribute]
public OpenXmlPart get_OpenXmlPart();
    [NullableContextAttribute("2")]
public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public sealed virtual bool Equals(IdPartPair other);
    public static bool op_Equality(IdPartPair left, IdPartPair right);
    public static bool op_Inequality(IdPartPair left, IdPartPair right);
}
public interface DocumentFormat.OpenXml.Packaging.IFixedContentTypePart {
}
[NullableContextAttribute("1")]
[ExperimentalAttribute("OOXML0001")]
[ObsoleteAttribute("This is an experimental APIs and is subject to change")]
public interface DocumentFormat.OpenXml.Packaging.IPackage {
    public FileAccess FileOpenAccess { get; }
    public IPackageProperties PackageProperties { get; }
    public IRelationshipCollection Relationships { get; }
    public abstract virtual FileAccess get_FileOpenAccess();
    public abstract virtual IPackageProperties get_PackageProperties();
    public abstract virtual IEnumerable`1<IPackagePart> GetParts();
    public abstract virtual IPackagePart GetPart(Uri uriTarget);
    public abstract virtual bool PartExists(Uri partUri);
    public abstract virtual void Save();
    public abstract virtual IPackagePart CreatePart(Uri partUri, string contentType, CompressionOption compressionOption);
    public abstract virtual void DeletePart(Uri uri);
    public abstract virtual IRelationshipCollection get_Relationships();
}
[NullableContextAttribute("1")]
[ExperimentalAttribute("OOXML0001")]
[ObsoleteAttribute("This is an experimental APIs and is subject to change")]
public interface DocumentFormat.OpenXml.Packaging.IPackagePart {
    public IPackage Package { get; }
    public Uri Uri { get; }
    public string ContentType { get; }
    public IRelationshipCollection Relationships { get; }
    public abstract virtual IPackage get_Package();
    public abstract virtual Uri get_Uri();
    public abstract virtual string get_ContentType();
    public abstract virtual IRelationshipCollection get_Relationships();
    public abstract virtual Stream GetStream(FileMode open, FileAccess write);
}
[NullableContextAttribute("2")]
[ExperimentalAttribute("OOXML0001")]
[ObsoleteAttribute("This is an experimental APIs and is subject to change")]
public interface DocumentFormat.OpenXml.Packaging.IPackageProperties {
    public string Title { get; public set; }
    public string Subject { get; public set; }
    public string Creator { get; public set; }
    public string Keywords { get; public set; }
    public string Description { get; public set; }
    public string LastModifiedBy { get; public set; }
    public string Revision { get; public set; }
    public Nullable`1<DateTime> LastPrinted { get; public set; }
    public Nullable`1<DateTime> Created { get; public set; }
    public Nullable`1<DateTime> Modified { get; public set; }
    public string Category { get; public set; }
    public string Identifier { get; public set; }
    public string ContentType { get; public set; }
    public string Language { get; public set; }
    public string Version { get; public set; }
    public string ContentStatus { get; public set; }
    public abstract virtual string get_Title();
    public abstract virtual void set_Title(string value);
    public abstract virtual string get_Subject();
    public abstract virtual void set_Subject(string value);
    public abstract virtual string get_Creator();
    public abstract virtual void set_Creator(string value);
    public abstract virtual string get_Keywords();
    public abstract virtual void set_Keywords(string value);
    public abstract virtual string get_Description();
    public abstract virtual void set_Description(string value);
    public abstract virtual string get_LastModifiedBy();
    public abstract virtual void set_LastModifiedBy(string value);
    public abstract virtual string get_Revision();
    public abstract virtual void set_Revision(string value);
    public abstract virtual Nullable`1<DateTime> get_LastPrinted();
    public abstract virtual void set_LastPrinted(Nullable`1<DateTime> value);
    public abstract virtual Nullable`1<DateTime> get_Created();
    public abstract virtual void set_Created(Nullable`1<DateTime> value);
    public abstract virtual Nullable`1<DateTime> get_Modified();
    public abstract virtual void set_Modified(Nullable`1<DateTime> value);
    public abstract virtual string get_Category();
    public abstract virtual void set_Category(string value);
    public abstract virtual string get_Identifier();
    public abstract virtual void set_Identifier(string value);
    public abstract virtual string get_ContentType();
    public abstract virtual void set_ContentType(string value);
    public abstract virtual string get_Language();
    public abstract virtual void set_Language(string value);
    public abstract virtual string get_Version();
    public abstract virtual void set_Version(string value);
    public abstract virtual string get_ContentStatus();
    public abstract virtual void set_ContentStatus(string value);
}
[NullableContextAttribute("1")]
[ExperimentalAttribute("OOXML0001")]
[ObsoleteAttribute("This is an experimental APIs and is subject to change")]
public interface DocumentFormat.OpenXml.Packaging.IPackageRelationship {
    public string Id { get; }
    public string RelationshipType { get; }
    public Uri SourceUri { get; }
    public TargetMode TargetMode { get; }
    public Uri TargetUri { get; }
    public abstract virtual string get_Id();
    public abstract virtual string get_RelationshipType();
    public abstract virtual Uri get_SourceUri();
    public abstract virtual TargetMode get_TargetMode();
    public abstract virtual Uri get_TargetUri();
}
[NullableContextAttribute("1")]
[DefaultMemberAttribute("Item")]
[ExperimentalAttribute("OOXML0001")]
[ObsoleteAttribute("This is an experimental APIs and is subject to change")]
public interface DocumentFormat.OpenXml.Packaging.IRelationshipCollection {
    public IPackageRelationship Item { get; }
    public int Count { get; }
    public abstract virtual IPackageRelationship Create(Uri targetUri, TargetMode targetMode, string relationshipType, string id);
    public abstract virtual void Remove(string id);
    public abstract virtual IPackageRelationship get_Item(string id);
    public abstract virtual int get_Count();
    public abstract virtual bool Contains(string id);
}
public interface DocumentFormat.OpenXml.Packaging.ISupportedRelationship`1 {
}
public enum DocumentFormat.OpenXml.Packaging.MarkupCompatibilityProcessMode : Enum {
    public int value__;
    public static MarkupCompatibilityProcessMode NoProcess;
    public static MarkupCompatibilityProcessMode ProcessLoadedPartsOnly;
    public static MarkupCompatibilityProcessMode ProcessAllParts;
}
public class DocumentFormat.OpenXml.Packaging.MarkupCompatibilityProcessSettings : object {
    [CompilerGeneratedAttribute]
private MarkupCompatibilityProcessMode <ProcessMode>k__BackingField;
    [CompilerGeneratedAttribute]
private FileFormatVersions <TargetFileFormatVersions>k__BackingField;
    public MarkupCompatibilityProcessMode ProcessMode { get; internal set; }
    public FileFormatVersions TargetFileFormatVersions { get; internal set; }
    public MarkupCompatibilityProcessSettings(MarkupCompatibilityProcessMode processMode, FileFormatVersions targetFileFormatVersions);
    [CompilerGeneratedAttribute]
public MarkupCompatibilityProcessMode get_ProcessMode();
    [CompilerGeneratedAttribute]
internal void set_ProcessMode(MarkupCompatibilityProcessMode value);
    [CompilerGeneratedAttribute]
public FileFormatVersions get_TargetFileFormatVersions();
    [CompilerGeneratedAttribute]
internal void set_TargetFileFormatVersions(FileFormatVersions value);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class DocumentFormat.OpenXml.Packaging.MediaDataPart : DataPart {
    private static string DefaultTargetPart;
    private static string DefaultTargetName;
    private static string DefaultTargetExt;
    internal string TargetPath { get; }
    internal string TargetName { get; }
    internal string TargetFileExtension { get; }
    internal MediaDataPart(OpenXmlPackage openXmlPackage, IPackagePart packagePart);
    internal MediaDataPart(OpenXmlPackage openXmlPackage, string contentType, string extension);
    internal MediaDataPart(OpenXmlPackage openXmlPackage, MediaDataPartType mediaDataPartType);
    internal MediaDataPart(OpenXmlPackage openXmlPackage, string contentType, Uri partUri);
    internal virtual string get_TargetPath();
    internal virtual string get_TargetName();
    internal virtual string get_TargetFileExtension();
}
public enum DocumentFormat.OpenXml.Packaging.MediaDataPartType : Enum {
    public int value__;
    public static MediaDataPartType Aiff;
    public static MediaDataPartType Midi;
    public static MediaDataPartType Mp3;
    public static MediaDataPartType MpegUrl;
    public static MediaDataPartType Wav;
    public static MediaDataPartType Wma;
    public static MediaDataPartType MpegAudio;
    public static MediaDataPartType OggAudio;
    public static MediaDataPartType Asx;
    public static MediaDataPartType Avi;
    public static MediaDataPartType Mpg;
    public static MediaDataPartType MpegVideo;
    public static MediaDataPartType Wmv;
    public static MediaDataPartType Wmx;
    public static MediaDataPartType Wvx;
    public static MediaDataPartType Quicktime;
    public static MediaDataPartType OggVideo;
    public static MediaDataPartType VC1;
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
internal static class DocumentFormat.OpenXml.Packaging.MediaDataPartTypeInfo : object {
    [ExtensionAttribute]
internal static string GetContentType(MediaDataPartType mediaDataPartType);
    [ExtensionAttribute]
internal static string GetTargetExtension(MediaDataPartType mediaDataPartType);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[RelationshipTypeAttribute("http://schemas.microsoft.com/office/2007/relationships/media")]
public class DocumentFormat.OpenXml.Packaging.MediaReferenceRelationship : DataPartReferenceRelationship {
    internal static string RelationshipTypeConst;
    public static string MediaReferenceRelationshipType { get; }
    public string RelationshipType { get; }
    protected internal MediaReferenceRelationship(MediaDataPart mediaDataPart, string id);
    public static string get_MediaReferenceRelationshipType();
    public virtual string get_RelationshipType();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class DocumentFormat.OpenXml.Packaging.OpenSettings : object {
    [NullableAttribute("2")]
private MarkupCompatibilityProcessSettings _mcSettings;
    private CompatibilityLevel _compatibilityLevel;
    [CompilerGeneratedAttribute]
private bool <AutoSave>k__BackingField;
    [CompilerGeneratedAttribute]
private long <MaxCharactersInPart>k__BackingField;
    public bool AutoSave { get; public set; }
    public CompatibilityLevel CompatibilityLevel { get; public set; }
    public MarkupCompatibilityProcessSettings MarkupCompatibilityProcessSettings { get; public set; }
    public long MaxCharactersInPart { get; public set; }
    [NullableContextAttribute("2")]
internal OpenSettings(OpenSettings other);
    [CompilerGeneratedAttribute]
public bool get_AutoSave();
    [CompilerGeneratedAttribute]
public void set_AutoSave(bool value);
    public CompatibilityLevel get_CompatibilityLevel();
    public void set_CompatibilityLevel(CompatibilityLevel value);
    public MarkupCompatibilityProcessSettings get_MarkupCompatibilityProcessSettings();
    public void set_MarkupCompatibilityProcessSettings(MarkupCompatibilityProcessSettings value);
    [CompilerGeneratedAttribute]
public long get_MaxCharactersInPart();
    [CompilerGeneratedAttribute]
public void set_MaxCharactersInPart(long value);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public abstract class DocumentFormat.OpenXml.Packaging.OpenXmlPackage : OpenXmlPartContainer {
    [CompilerGeneratedAttribute]
private static Uri <Uri>k__BackingField;
    private bool _isDisposed;
    [NullableAttribute("2")]
private OpenSettings _settings;
    [CompilerGeneratedAttribute]
private CompressionOption <CompressionOption>k__BackingField;
    internal static Uri Uri { get; }
    [NullableAttribute("2")]
public OpenXmlPart RootPart { get; }
    internal OpenSettings OpenSettings { get; internal set; }
    public bool StrictRelationshipFound { get; }
    internal IPackage Package { get; }
    public IPackageProperties PackageProperties { get; }
    public FileAccess FileOpenAccess { get; }
    public CompressionOption CompressionOption { get; public set; }
    internal IPartExtensionFeature PartExtensions { get; }
    public long MaxCharactersInPart { get; }
    public bool CanSave { get; }
    public IEnumerable`1<DataPart> DataParts { get; }
    public MarkupCompatibilityProcessSettings MarkupCompatibilityProcessSettings { get; }
    public bool AutoSave { get; }
    internal string MainPartContentType { get; }
    internal OpenXmlPackage InternalOpenXmlPackage { get; }
    [NullableAttribute("2")]
internal OpenXmlPart ThisOpenXmlPart { get; }
    internal IRelationshipCollection Relationships { get; }
    public IFeatureCollection Features { get; }
    private static OpenXmlPackage();
    [CompilerGeneratedAttribute]
internal static Uri get_Uri();
    [NullableContextAttribute("2")]
public virtual OpenXmlPart get_RootPart();
    internal OpenSettings get_OpenSettings();
    internal void set_OpenSettings(OpenSettings value);
    public bool get_StrictRelationshipFound();
    internal IPackage get_Package();
    public IPackageProperties get_PackageProperties();
    public FileAccess get_FileOpenAccess();
    [CompilerGeneratedAttribute]
public CompressionOption get_CompressionOption();
    [CompilerGeneratedAttribute]
public void set_CompressionOption(CompressionOption value);
    internal IPartExtensionFeature get_PartExtensions();
    public long get_MaxCharactersInPart();
    public bool get_CanSave();
    public IEnumerable`1<DataPart> get_DataParts();
    internal void LoadAllParts();
    public virtual T AddPart(T part);
    [NullableContextAttribute("0")]
public void DeletePartsRecursivelyOfType();
    public MediaDataPart CreateMediaDataPart(string contentType);
    public MediaDataPart CreateMediaDataPart(string contentType, string extension);
    public MediaDataPart CreateMediaDataPart(MediaDataPartType mediaDataPartType);
    public bool DeletePart(DataPart dataPart);
    protected virtual void ThrowIfObjectDisposed();
    protected virtual void Dispose(bool disposing);
    public sealed virtual void Dispose();
    public MarkupCompatibilityProcessSettings get_MarkupCompatibilityProcessSettings();
    public bool get_AutoSave();
    private void SavePartContents(bool save);
    private static void TrySavePartContent(OpenXmlPart part);
    private static bool IsPartContentChanged(OpenXmlPart part);
    internal string get_MainPartContentType();
    internal void ChangeDocumentTypeInternal(T newMainPart);
    internal sealed virtual OpenXmlPackage get_InternalOpenXmlPackage();
    [NullableContextAttribute("2")]
internal sealed virtual OpenXmlPart get_ThisOpenXmlPart();
    internal virtual IRelationshipCollection get_Relationships();
    internal sealed virtual void FindAllReachableParts(IDictionary`2<OpenXmlPart, bool> reachableParts);
    internal IPackagePart CreateMetroPart(Uri partUri, string contentType);
    private static bool IsOrphanDataPart(DataPart dataPart);
    private void DeleteUnusedDataPartOnClose();
    internal DataPart AddDataPartToList(DataPart dataPart);
    public void Save();
    public virtual IFeatureCollection get_Features();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class DocumentFormat.OpenXml.Packaging.OpenXmlPackageException : Exception {
    public OpenXmlPackageException(string message);
    private OpenXmlPackageException(SerializationInfo info, StreamingContext context);
    public OpenXmlPackageException(string message, Exception innerException);
}
[ExtensionAttribute]
public static class DocumentFormat.OpenXml.Packaging.OpenXmlPackageExtensions : object {
    [NullableContextAttribute("1")]
[ExtensionAttribute]
public static IEnumerable`1<OpenXmlPart> GetAllParts(OpenXmlPackage package);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
internal class DocumentFormat.OpenXml.Packaging.OpenXmlPackageValidationResult : object {
    private string _message;
    [CompilerGeneratedAttribute]
private string <RelationshipType>k__BackingField;
    [CompilerGeneratedAttribute]
private OpenXmlPart <SubPart>k__BackingField;
    [CompilerGeneratedAttribute]
private OpenXmlPart <Part>k__BackingField;
    [CompilerGeneratedAttribute]
private string <MessageId>k__BackingField;
    [CompilerGeneratedAttribute]
private DataPartReferenceRelationship <DataPartReferenceRelationship>k__BackingField;
    [NullableAttribute("1")]
public string Message { get; public set; }
    public string RelationshipType { get; public set; }
    public OpenXmlPart SubPart { get; internal set; }
    public OpenXmlPart Part { get; internal set; }
    internal string MessageId { get; internal set; }
    internal DataPartReferenceRelationship DataPartReferenceRelationship { get; internal set; }
    [NullableContextAttribute("1")]
public string get_Message();
    [NullableContextAttribute("1")]
public void set_Message(string value);
    [CompilerGeneratedAttribute]
public string get_RelationshipType();
    [CompilerGeneratedAttribute]
public void set_RelationshipType(string value);
    [CompilerGeneratedAttribute]
public OpenXmlPart get_SubPart();
    [CompilerGeneratedAttribute]
internal void set_SubPart(OpenXmlPart value);
    [CompilerGeneratedAttribute]
public OpenXmlPart get_Part();
    [CompilerGeneratedAttribute]
internal void set_Part(OpenXmlPart value);
    [CompilerGeneratedAttribute]
internal string get_MessageId();
    [CompilerGeneratedAttribute]
internal void set_MessageId(string value);
    [CompilerGeneratedAttribute]
internal DataPartReferenceRelationship get_DataPartReferenceRelationship();
    [CompilerGeneratedAttribute]
internal void set_DataPartReferenceRelationship(DataPartReferenceRelationship value);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public abstract class DocumentFormat.OpenXml.Packaging.OpenXmlPart : OpenXmlPartContainer {
    [NullableAttribute("2")]
internal OpenXmlPackage _openXmlPackage;
    private bool _isLoading;
    [NullableAttribute("2")]
[CompilerGeneratedAttribute]
private MarkupCompatibilityProcessSettings <MCSettings>k__BackingField;
    public OpenXmlPackage OpenXmlPackage { get; }
    public Uri Uri { get; }
    public string ContentType { get; }
    public string RelationshipType { get; }
    [NullableAttribute("2")]
public OpenXmlPartRootElement RootElement { get; }
    internal IPackagePart PackagePart { get; }
    internal long MaxCharactersInPart { get; }
    internal bool IsContentTypeFixed { get; }
    [NullableAttribute("2")]
private protected OpenXmlPartRootElement InternalRootElement { get; private protected set; }
    [NullableAttribute("2")]
internal OpenXmlPartRootElement PartRootElement { get; }
    [MemberNotNullWhenAttribute("True", "RootElement")]
public bool IsRootElementLoaded { get; }
    internal IRelationshipCollection Relationships { get; }
    internal OpenXmlPackage InternalOpenXmlPackage { get; }
    internal OpenXmlPart ThisOpenXmlPart { get; }
    public IFeatureCollection Features { get; }
    [NullableAttribute("2")]
internal MarkupCompatibilityProcessSettings MCSettings { get; internal set; }
    internal void Load(OpenXmlPackage openXmlPackage, OpenXmlPart parent, Uri uriTarget, string id);
    [NullableContextAttribute("2")]
internal void CreateInternal(OpenXmlPackage openXmlPackage, OpenXmlPart parent, string contentType, string targetExt);
    internal void CreateInternal(OpenXmlPackage openXmlPackage, OpenXmlPart parent, string contentType, Uri partUri);
    private void CreatePart(OpenXmlPackage package, Uri uri, string contentType);
    [NullableContextAttribute("2")]
[MemberNotNullAttribute("_openXmlPackage")]
private void SetPackage(OpenXmlPackage openXmlPackage, OpenXmlPart parent);
    private static void RegisterForDisposal(OpenXmlPackage package, OpenXmlPart part);
    private ITargetFeature GetAndVerifyTargetFeature(string contentType, string targetExt);
    public OpenXmlPackage get_OpenXmlPackage();
    public Uri get_Uri();
    public IEnumerable`1<OpenXmlPart> GetParentParts();
    public Stream GetStream();
    public Stream GetStream(FileMode mode);
    public Stream GetStream(FileMode mode, FileAccess access);
    public void FeedData(Stream sourceStream);
    [NullableContextAttribute("2")]
public OpenXmlPartRootElement UnloadRootElement();
    public virtual string get_ContentType();
    public abstract virtual string get_RelationshipType();
    [NullableContextAttribute("2")]
public OpenXmlPartRootElement get_RootElement();
    internal IPackagePart get_PackagePart();
    internal long get_MaxCharactersInPart();
    internal bool get_IsContentTypeFixed();
    private protected virtual bool IsValidContentType(IPackagePart part);
    internal sealed virtual void FindAllReachableParts(IDictionary`2<OpenXmlPart, bool> reachableParts);
    [NullableContextAttribute("2")]
private protected virtual OpenXmlPartRootElement get_InternalRootElement();
    [NullableContextAttribute("2")]
private protected virtual void set_InternalRootElement(OpenXmlPartRootElement value);
    [NullableContextAttribute("2")]
internal virtual OpenXmlPartRootElement get_PartRootElement();
    internal virtual bool IsInVersion(FileFormatVersions version);
    [MemberNotNullWhenAttribute("True", "RootElement")]
public bool get_IsRootElementLoaded();
    [NullableContextAttribute("0")]
internal void LoadDomTree();
    internal void SetDomTree(OpenXmlPartRootElement partRootElement);
    internal void CleanUp();
    internal void Destroy();
    [MemberNotNullAttribute("_openXmlPackage")]
protected sealed virtual void ThrowIfObjectDisposed();
    internal virtual IRelationshipCollection get_Relationships();
    internal sealed virtual OpenXmlPackage get_InternalOpenXmlPackage();
    internal sealed virtual OpenXmlPart get_ThisOpenXmlPart();
    public virtual IFeatureCollection get_Features();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
internal MarkupCompatibilityProcessSettings get_MCSettings();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
internal void set_MCSettings(MarkupCompatibilityProcessSettings value);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public abstract class DocumentFormat.OpenXml.Packaging.OpenXmlPartContainer : object {
    [NullableAttribute("2")]
private protected IFeatureCollection _features;
    internal IPartRelationshipsFeature ChildrenRelationshipParts { get; }
    public IEnumerable`1<ExternalRelationship> ExternalRelationships { get; }
    public IEnumerable`1<HyperlinkRelationship> HyperlinkRelationships { get; }
    public IEnumerable`1<DataPartReferenceRelationship> DataPartReferenceRelationships { get; }
    public IEnumerable`1<IdPartPair> Parts { get; }
    internal OpenXmlPackage InternalOpenXmlPackage { get; }
    [NullableAttribute("2")]
internal OpenXmlPart ThisOpenXmlPart { get; }
    internal IRelationshipCollection Relationships { get; }
    public IFeatureCollection Features { get; }
    internal IPartRelationshipsFeature get_ChildrenRelationshipParts();
    public void DeleteReferenceRelationship(ReferenceRelationship referenceRelationship);
    public void DeleteReferenceRelationship(string id);
    public ReferenceRelationship GetReferenceRelationship(string id);
    public IEnumerable`1<ExternalRelationship> get_ExternalRelationships();
    public ExternalRelationship AddExternalRelationship(string relationshipType, Uri externalUri);
    public ExternalRelationship AddExternalRelationship(string relationshipType, Uri externalUri, string id);
    public void DeleteExternalRelationship(ExternalRelationship externalRelationship);
    public void DeleteExternalRelationship(string id);
    public ExternalRelationship GetExternalRelationship(string id);
    private T GetRelationship(string id, string errorMessage);
    public IEnumerable`1<HyperlinkRelationship> get_HyperlinkRelationships();
    public HyperlinkRelationship AddHyperlinkRelationship(Uri hyperlinkUri, bool isExternal);
    public HyperlinkRelationship AddHyperlinkRelationship(Uri hyperlinkUri, bool isExternal, string id);
    public IEnumerable`1<DataPartReferenceRelationship> get_DataPartReferenceRelationships();
    internal T AddDataPartReferenceRelationship(MediaDataPart mediaDataPart);
    internal T AddDataPartReferenceRelationship(MediaDataPart mediaDataPart, string id);
    private T AddDataPartReferenceRelationshipInternal(MediaDataPart mediaDataPart, string id);
    internal DataPartReferenceRelationship AddDataPartReferenceRelationship(DataPartReferenceRelationship dataPartReferenceRelationship);
    public IEnumerable`1<IdPartPair> get_Parts();
    public OpenXmlPart GetPartById(string id);
    public bool TryGetPartById(string id, OpenXmlPart& part);
    public string GetIdOfPart(OpenXmlPart part);
    public string ChangeIdOfPart(OpenXmlPart part, string newRelationshipId);
    public virtual T AddPart(T part);
    public virtual T AddPart(T part, string id);
    public string CreateRelationshipToPart(OpenXmlPart targetPart);
    public string CreateRelationshipToPart(OpenXmlPart targetPart, string id);
    public T AddNewPart();
    public T AddNewPart(string id);
    public virtual T AddNewPart(string contentType, string id);
    public ExtendedPart AddExtendedPart(string relationshipType, string contentType, string targetExt);
    public ExtendedPart AddExtendedPart(string relationshipType, string contentType, string targetExt, string rId);
    public bool DeletePart(string id);
    public bool DeletePart(OpenXmlPart part);
    public void DeleteParts(IEnumerable`1<T> partsToBeDeleted);
    public void AddAnnotation(object annotation);
    public T Annotation();
    public object Annotation(Type type);
    public IEnumerable`1<T> Annotations();
    public IEnumerable`1<object> Annotations(Type type);
    public void RemoveAnnotations();
    public void RemoveAnnotations(Type type);
    public IEnumerable`1<T> GetPartsOfType();
    internal T AddNewPartInternal();
    internal T AddNewPartInternal(string contentType, string id);
    internal void InitPart(OpenXmlPart newPart, string contentType);
    internal virtual void InitPart(OpenXmlPart newPart, string contentType, string id);
    internal virtual OpenXmlPart AddPartFrom(OpenXmlPart subPart, string rId);
    internal OpenXmlPart SetSubPart(OpenXmlPart part, string rId);
    internal OpenXmlPart AddSubPart(OpenXmlPart part, string rId);
    internal OpenXmlPart AddSubPartFromOtherPackage(OpenXmlPart part, bool keepIdAndUri, string rId);
    private OpenXmlPart AddSubPartFromOtherPackage(OpenXmlPart part, IDictionary`2<OpenXmlPart, OpenXmlPart> partDictionary, Dictionary`2<DataPart, DataPart> dataPartsDictionary, bool keepIdAndUri, string rId);
    private void UpdateDataParts(Dictionary`2<DataPart, DataPart> dataPartsDictionary);
    internal bool DeletePartCore(string id);
    [NullableContextAttribute("0")]
internal void DeletePartsOfType();
    [NullableContextAttribute("0")]
internal void DeletePartsRecursivelyOfTypeBase();
    internal void DeleteAllParts(Dictionary`2<OpenXmlPart, bool> processedParts, Dictionary`2<OpenXmlPart, bool> toBeDeletedParts);
    internal OpenXmlPart GetSubPart(string relationshipType);
    [NullableContextAttribute("0")]
internal T GetSubPartOfType();
    internal OpenXmlPart GetPart(string relationshipType);
    internal bool IsChildPart(OpenXmlPart part);
    internal OpenXmlPart CreateOpenXmlPart(string relationshipType);
    internal abstract virtual OpenXmlPackage get_InternalOpenXmlPackage();
    [NullableContextAttribute("2")]
internal abstract virtual OpenXmlPart get_ThisOpenXmlPart();
    protected abstract virtual void ThrowIfObjectDisposed();
    internal abstract virtual IRelationshipCollection get_Relationships();
    internal abstract virtual void FindAllReachableParts(IDictionary`2<OpenXmlPart, bool> reachableParts);
    private bool IsInSamePackage(OpenXmlPart targetPart);
    public virtual IFeatureCollection get_Features();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
internal static class DocumentFormat.OpenXml.Packaging.PackageAbstractionExtensions : object {
    [ExtensionAttribute]
public static Stream GetStream(IPackagePart part);
    [ExtensionAttribute]
public static Stream GetStream(IPackagePart part, FileMode mode);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class DocumentFormat.OpenXml.Packaging.PackageFeature : PackageFeatureBase {
    [CompilerGeneratedAttribute]
private Package <Package>k__BackingField;
    protected Package Package { get; }
    public PackageFeature(Package package);
    [CompilerGeneratedAttribute]
protected virtual Package get_Package();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class DocumentFormat.OpenXml.Packaging.PackageFeatureCollection : FeatureCollectionBase {
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private Action`1<OpenXmlPartContainer> _save;
    [NullableAttribute("2")]
private Action _disposable;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private LinkedList`1<DataPart> _dataParts;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private Dictionary`2<Uri, OpenXmlPart> _parts;
    [NullableAttribute("2")]
private IPartUriFeature _partUriFeature;
    [NullableAttribute("2")]
private AnnotationsFeature _annotationFeature;
    [NullableAttribute("2")]
private IPartExtensionFeature _partExtensionFeature;
    private static Type[] _known;
    [CompilerGeneratedAttribute]
private OpenXmlPackage <Package>k__BackingField;
    [CompilerGeneratedAttribute]
private object <DocumentFormat.OpenXml.Features.ILockFeature.SyncLock>k__BackingField;
    protected OpenXmlPackage Package { get; }
    private ApplicationType DocumentFormat.OpenXml.Features.IApplicationTypeFeature.Type { get; }
    protected IEnumerable`1<Type> KnownTypes { get; }
    private IEnumerable`1<DataPart> DocumentFormat.OpenXml.Features.IDataPartsFeature.Parts { get; }
    private int DocumentFormat.OpenXml.Features.IDataPartsFeature.Count { get; }
    private object DocumentFormat.OpenXml.Features.ILockFeature.SyncLock { get; }
    public PackageFeatureCollection(OpenXmlPackage package);
    private static PackageFeatureCollection();
    [CompilerGeneratedAttribute]
protected OpenXmlPackage get_Package();
    private sealed virtual override ApplicationType DocumentFormat.OpenXml.Features.IApplicationTypeFeature.get_Type();
    protected virtual object GetKnown(Type key);
    protected virtual IEnumerable`1<Type> get_KnownTypes();
    private sealed virtual override OpenXmlPart DocumentFormat.OpenXml.Features.IPartFactoryFeature.Create(string relationshipType);
    private sealed virtual override void DocumentFormat.OpenXml.Features.IDisposableFeature.Register(Action disposable);
    private sealed virtual override void DocumentFormat.OpenXml.Features.IContainerDisposableFeature.Dispose();
    private sealed virtual override void DocumentFormat.OpenXml.Features.ISaveFeature.Save(OpenXmlPartContainer container);
    private sealed virtual override void DocumentFormat.OpenXml.Features.ISaveFeature.Register(Action`1<OpenXmlPartContainer> container);
    private sealed virtual override bool DocumentFormat.OpenXml.Features.IDataPartsFeature.TryGetDataPart(Uri uri, DataPart& dataPart);
    private sealed virtual override IEnumerable`1<DataPart> DocumentFormat.OpenXml.Features.IDataPartsFeature.get_Parts();
    private sealed virtual override int DocumentFormat.OpenXml.Features.IDataPartsFeature.get_Count();
    [CompilerGeneratedAttribute]
private sealed virtual override object DocumentFormat.OpenXml.Features.ILockFeature.get_SyncLock();
    private sealed virtual override void DocumentFormat.OpenXml.Features.IDataPartsFeature.Add(DataPart dataPart);
    private sealed virtual override bool DocumentFormat.OpenXml.Features.IPartsFeature.TryGetPart(Uri uri, OpenXmlPart& part);
    private sealed virtual override void DocumentFormat.OpenXml.Features.IPartsFeature.Add(Uri uri, OpenXmlPart part);
    private sealed virtual override bool DocumentFormat.OpenXml.Features.IDataPartsFeature.Remove(DataPart dataPart);
    private sealed virtual override bool DocumentFormat.OpenXml.Features.IPartsFeature.Contains(Uri uri);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class DocumentFormat.OpenXml.Packaging.PackagePartUriHelper : object {
    private PartUriHelper _other;
    private IPackage _package;
    public PackagePartUriHelper(IPackage package);
    public sealed virtual Uri CreatePartUri(string contentType, Uri parentUri, string targetPath, string targetName, string targetExt, bool forceUnique);
    public sealed virtual Uri EnsureUniquePartUri(string contentType, Uri parentUri, Uri targetUri);
    public sealed virtual void ReserveUri(string contentType, Uri partUri);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
internal static class DocumentFormat.OpenXml.Packaging.PackageUriHandlingExtensions : object {
    private static string RelationshipsTagName;
    private static string RelationshipTagName;
    private static string RelationshipNamespaceUri;
    private static string TargetAttributeName;
    private static string TargetModeAttributeName;
    private static string IdAttributeName;
    [ExtensionAttribute]
public static void EnableUriHandling(OpenXmlPackage package);
    [ExtensionAttribute]
internal static IFeatureCollection EnableUriHandling(IFeatureCollection features);
    private static XDocument WalkRelationships(IPackagePart part, RewrittenUriCollection uris, bool isDisposing);
    private static bool Update(XElement child, RewrittenUriCollection uris, bool isDisposing);
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal class DocumentFormat.OpenXml.Packaging.PartExtensionProvider : Dictionary`2<string, string> {
    public sealed virtual void Register(string contentType, string extension);
    public sealed virtual bool TryGetExtension(string contentType, String& extension);
    private void AddKnownExtensions();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class DocumentFormat.OpenXml.Packaging.PartFeatureCollection : FeatureCollectionBase {
    private OpenXmlPart _part;
    [NullableAttribute("2")]
private Action _disposable;
    [NullableAttribute("2")]
private AnnotationsFeature _annotationsFeature;
    [NullableAttribute("2")]
protected IFeatureCollection Parent { get; }
    private string DocumentFormat.OpenXml.Features.ITargetFeature.Path { get; }
    private string DocumentFormat.OpenXml.Features.ITargetFeature.Extension { get; }
    private string DocumentFormat.OpenXml.Features.ITargetFeature.Name { get; }
    protected IEnumerable`1<Type> KnownTypes { get; }
    private IEnumerable`1<PartConstraintRule> DocumentFormat.OpenXml.Features.IPartConstraintFeature.Rules { get; }
    private bool DocumentFormat.OpenXml.Features.IContentTypeFeature.IsConstant { get; }
    public PartFeatureCollection(OpenXmlPart part);
    [NullableContextAttribute("2")]
protected virtual IFeatureCollection get_Parent();
    private sealed virtual override string DocumentFormat.OpenXml.Features.ITargetFeature.get_Path();
    private sealed virtual override string DocumentFormat.OpenXml.Features.ITargetFeature.get_Extension();
    private sealed virtual override string DocumentFormat.OpenXml.Features.ITargetFeature.get_Name();
    protected virtual object GetKnown(Type key);
    protected virtual IEnumerable`1<Type> get_KnownTypes();
    private sealed virtual override IEnumerable`1<PartConstraintRule> DocumentFormat.OpenXml.Features.IPartConstraintFeature.get_Rules();
    private sealed virtual override bool DocumentFormat.OpenXml.Features.IContentTypeFeature.get_IsConstant();
    private sealed virtual override bool DocumentFormat.OpenXml.Features.IPartConstraintFeature.TryGetRule(string relationshipId, PartConstraintRule& rule);
    private sealed virtual override bool DocumentFormat.OpenXml.Features.IKnownDataPartFeature.IsKnown(string relationshipId);
    private sealed virtual override void DocumentFormat.OpenXml.Features.IDisposableFeature.Register(Action disposable);
    private sealed virtual override void DocumentFormat.OpenXml.Features.IContainerDisposableFeature.Dispose();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class DocumentFormat.OpenXml.Packaging.PartRelationshipsFeature : object {
    private OpenXmlPartContainer _owner;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private Dictionary`2<string, OpenXmlPart> _parts;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private Dictionary`2<string, ReferenceRelationship> _referenceRelationships;
    [NullableAttribute("2")]
private IPartEventsFeature Events { get; }
    private IEnumerable`1<OpenXmlPart> DocumentFormat.OpenXml.Features.IPartRelationshipsFeature.Parts { get; }
    private IDataPartsFeature LoadedDataParts { get; }
    private IPartsFeature LoadedParts { get; }
    private int DocumentFormat.OpenXml.Features.IPartRelationshipsFeature.Count { get; }
    private Dictionary`2<string, OpenXmlPart> RelationshipMap { get; }
    private Dictionary`2<string, ReferenceRelationship> ReferenceRelationships { get; }
    private IEnumerable`1<ReferenceRelationship> DocumentFormat.OpenXml.Features.IReferenceRelationshipsFeature.Relationships { get; }
    public PartRelationshipsFeature(OpenXmlPartContainer owner);
    [NullableContextAttribute("2")]
private IPartEventsFeature get_Events();
    private sealed virtual override IEnumerable`1<OpenXmlPart> DocumentFormat.OpenXml.Features.IPartRelationshipsFeature.get_Parts();
    private IDataPartsFeature get_LoadedDataParts();
    private IPartsFeature get_LoadedParts();
    private sealed virtual override void DocumentFormat.OpenXml.Features.IPartRelationshipsFeature.Add(OpenXmlPart part, string id);
    private void Add(Dictionary`2<string, OpenXmlPart> parts, string uri, OpenXmlPart part);
    private sealed virtual override void DocumentFormat.OpenXml.Features.IPartRelationshipsFeature.Clear();
    private sealed virtual override int DocumentFormat.OpenXml.Features.IPartRelationshipsFeature.get_Count();
    private sealed virtual override bool DocumentFormat.OpenXml.Features.IPartRelationshipsFeature.Contains(OpenXmlPart part);
    private sealed virtual override bool DocumentFormat.OpenXml.Features.IPartRelationshipsFeature.Contains(string id);
    private sealed virtual override bool DocumentFormat.OpenXml.Features.IPartRelationshipsFeature.TryGetPart(string id, OpenXmlPart& part);
    private Dictionary`2<string, OpenXmlPart> get_RelationshipMap();
    public sealed virtual IEnumerator`1<KeyValuePair`2<string, OpenXmlPart>> GetEnumerator();
    private sealed virtual override void DocumentFormat.OpenXml.Features.IPartRelationshipsFeature.Remove(string id);
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    [MemberNotNullAttribute("_parts")]
[MemberNotNullAttribute("_referenceRelationships")]
internal void LoadReferencedPartsAndRelationships();
    private OpenXmlPart CreateOpenXmlPart(string relationshipType);
    private Dictionary`2<string, ReferenceRelationship> get_ReferenceRelationships();
    private sealed virtual override bool DocumentFormat.OpenXml.Features.IReferenceRelationshipsFeature.Remove(string id);
    private sealed virtual override bool DocumentFormat.OpenXml.Features.IReferenceRelationshipsFeature.TryGetRelationship(string id, ReferenceRelationship& relationship);
    private sealed virtual override HyperlinkRelationship DocumentFormat.OpenXml.Features.IReferenceRelationshipsFeature.CreateHyperLink(Uri uri, bool isExternal, string id);
    private sealed virtual override IEnumerable`1<ReferenceRelationship> DocumentFormat.OpenXml.Features.IReferenceRelationshipsFeature.get_Relationships();
    private sealed virtual override ExternalRelationship DocumentFormat.OpenXml.Features.IReferenceRelationshipsFeature.CreateExternalRelationship(string relationshipType, Uri externalUri, string id);
    private IPackageRelationship CreateRelationship(string relationshipType, Uri externalUri, TargetMode mode, string id);
    private bool DeleteRelationship(string id);
    private sealed virtual override DataPartReferenceRelationship DocumentFormat.OpenXml.Features.IReferenceRelationshipsFeature.CreateDataPartRelationship(string relationshipType, DataPart dataPart, string id);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[IsReadOnlyAttribute]
public class DocumentFormat.OpenXml.Packaging.PartTypeInfo : ValueType {
    [CompilerGeneratedAttribute]
private string <ContentType>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Extension>k__BackingField;
    public string ContentType { get; }
    public string Extension { get; }
    public PartTypeInfo(string contentType, string extension);
    [CompilerGeneratedAttribute]
public string get_ContentType();
    [CompilerGeneratedAttribute]
public string get_Extension();
    [NullableContextAttribute("0")]
[CompilerGeneratedAttribute]
public virtual string ToString();
    [NullableContextAttribute("0")]
[CompilerGeneratedAttribute]
private bool PrintMembers(StringBuilder builder);
    [CompilerGeneratedAttribute]
public static bool op_Inequality(PartTypeInfo left, PartTypeInfo right);
    [CompilerGeneratedAttribute]
public static bool op_Equality(PartTypeInfo left, PartTypeInfo right);
    [CompilerGeneratedAttribute]
public virtual int GetHashCode();
    [NullableContextAttribute("0")]
[CompilerGeneratedAttribute]
public virtual bool Equals(object obj);
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(PartTypeInfo other);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class DocumentFormat.OpenXml.Packaging.PartUriHelper : object {
    private static HashSet`1<string> _numberedContentTypes;
    private Dictionary`2<string, int> _sequenceNumbers;
    private Dictionary`2<Uri, int> _reservedUri;
    private static PartUriHelper();
    public sealed virtual void ReserveUri(string contentType, Uri partUri);
    public sealed virtual Uri CreatePartUri(string contentType, Uri parentUri, string targetPath, string targetName, string targetExt, bool forceUnique);
    public sealed virtual Uri EnsureUniquePartUri(string contentType, Uri parentUri, Uri targetUri);
    private void AddToReserveUri(Uri partUri);
    private string GetNextSequenceNumber(string contentType);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public abstract class DocumentFormat.OpenXml.Packaging.ReferenceRelationship : object {
    [NullableAttribute("2")]
[CompilerGeneratedAttribute]
private OpenXmlPartContainer <Container>k__BackingField;
    [CompilerGeneratedAttribute]
private string <RelationshipType>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsExternal>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Id>k__BackingField;
    [CompilerGeneratedAttribute]
private Uri <Uri>k__BackingField;
    [NullableAttribute("2")]
public OpenXmlPartContainer Container { get; internal set; }
    public string RelationshipType { get; private set; }
    public bool IsExternal { get; private set; }
    public string Id { get; private set; }
    public Uri Uri { get; private set; }
    protected internal ReferenceRelationship(PackageRelationship packageRelationship);
    protected internal ReferenceRelationship(Uri targetUri, bool isExternal, string relationshipType, string id);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public OpenXmlPartContainer get_Container();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
internal void set_Container(OpenXmlPartContainer value);
    [CompilerGeneratedAttribute]
public virtual string get_RelationshipType();
    [CompilerGeneratedAttribute]
private void set_RelationshipType(string value);
    [CompilerGeneratedAttribute]
public virtual bool get_IsExternal();
    [CompilerGeneratedAttribute]
private void set_IsExternal(bool value);
    [CompilerGeneratedAttribute]
public virtual string get_Id();
    [CompilerGeneratedAttribute]
private void set_Id(string value);
    [CompilerGeneratedAttribute]
public virtual Uri get_Uri();
    [CompilerGeneratedAttribute]
private void set_Uri(Uri value);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[RelationshipTypeAttribute("http://schemas.openxmlformats.org/officeDocument/2006/relationships/video")]
public class DocumentFormat.OpenXml.Packaging.VideoReferenceRelationship : DataPartReferenceRelationship {
    internal static string RelationshipTypeConst;
    public static string VideoReferenceRelationshipType { get; }
    public string RelationshipType { get; }
    protected internal VideoReferenceRelationship(MediaDataPart mediaDataPart, string id);
    public static string get_VideoReferenceRelationshipType();
    public virtual string get_RelationshipType();
}
[ExtensionAttribute]
internal static class DocumentFormat.OpenXml.Packaging.WriteableStreamExtensions : object {
    private static int DefaultBufferSize;
    [NullableContextAttribute("1")]
[ExtensionAttribute]
public static bool EnableWriteableStream(IFeatureCollection features);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[IsReadOnlyAttribute]
internal class DocumentFormat.OpenXml.PrefixName : ValueType {
    [CompilerGeneratedAttribute]
private string <Prefix>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    public string Prefix { get; }
    public string Name { get; }
    public PrefixName(string prefix, string name);
    [CompilerGeneratedAttribute]
public string get_Prefix();
    [CompilerGeneratedAttribute]
public string get_Name();
    public static PrefixName Parse(string name);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[IsReadOnlyAttribute]
[DefaultMemberAttribute("Item")]
internal class DocumentFormat.OpenXml.ReadOnlySpan`1 : ValueType {
    private T[] _array;
    private int _start;
    [CompilerGeneratedAttribute]
private int <Length>k__BackingField;
    public int Length { get; }
    public T Item { get; }
    public ReadOnlySpan`1(T[] array);
    public ReadOnlySpan`1(T[] array, int start, int length);
    public ReadOnlySpan`1<T> Slice(int start, int length);
    [CompilerGeneratedAttribute]
public int get_Length();
    public T get_Item(int index);
    [NullableContextAttribute("0")]
public Enumerator<T> GetEnumerator();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[CLSCompliantAttribute("False")]
[DebuggerDisplayAttribute("{InnerText}")]
public class DocumentFormat.OpenXml.SByteValue : OpenXmlComparableSimpleValue`1<sbyte> {
    public SByteValue(sbyte value);
    public SByteValue(SByteValue source);
    private protected virtual string GetText(sbyte input);
    private protected virtual sbyte Parse(string input);
    public static sbyte op_Implicit(SByteValue value);
    public static SByteValue op_Implicit(sbyte value);
    public static SByteValue FromSByte(sbyte value);
    public static sbyte ToSByte(SByteValue value);
    private protected virtual OpenXmlSimpleType CloneImpl();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[DebuggerDisplayAttribute("{InnerText}")]
public class DocumentFormat.OpenXml.SingleValue : OpenXmlComparableSimpleValue`1<float> {
    public SingleValue(float value);
    public SingleValue(SingleValue source);
    private protected virtual string GetText(float input);
    private protected virtual float Parse(string input);
    public static float op_Implicit(SingleValue value);
    public static SingleValue op_Implicit(float value);
    public static SingleValue FromSingle(float value);
    public static float ToSingle(SingleValue value);
    private protected virtual OpenXmlSimpleType CloneImpl();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[IsReadOnlyAttribute]
[DefaultMemberAttribute("Item")]
internal class DocumentFormat.OpenXml.Span`1 : ValueType {
    private T[] _array;
    private int _start;
    [CompilerGeneratedAttribute]
private int <Length>k__BackingField;
    public int Length { get; }
    public T Item { get; public set; }
    public Span`1(T[] array);
    [CompilerGeneratedAttribute]
public int get_Length();
    public T get_Item(int index);
    public void set_Item(int index, T value);
    public static ReadOnlySpan`1<T> op_Implicit(Span`1<T> span);
}
[ExtensionAttribute]
internal static class DocumentFormat.OpenXml.SpanExtensions : object {
    [ExtensionAttribute]
public static Span`1<byte> AsSpan(Byte[] bytes);
    [NullableContextAttribute("1")]
[ExtensionAttribute]
public static string AsSpan(string str);
    [NullableContextAttribute("1")]
[ExtensionAttribute]
public static string Slice(string str, int start, int length);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal static class DocumentFormat.OpenXml.SR : object {
    public static string Format(string str, Object[] args);
    public static string Format(string str, object arg0);
    public static string Format(string str, object arg0, object arg1);
    [NullableContextAttribute("2")]
public static string Format(string str, object arg0, object arg1, object arg2);
}
[ExtensionAttribute]
internal static class DocumentFormat.OpenXml.StreamCopyExtensions : object {
    [NullableContextAttribute("1")]
[ExtensionAttribute]
public static void CopyTo(Stream source, Stream destination);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
internal static class DocumentFormat.OpenXml.StringExtensions : object {
    [ExtensionAttribute]
public static bool Contains(string str, string value, StringComparison comparison);
    [ExtensionAttribute]
public static bool Contains(string str, char c);
    [ExtensionAttribute]
public static int IndexOf(string str, char c, StringComparison comparison);
    [ExtensionAttribute]
public static bool StartsWith(string str, char c);
    [ExtensionAttribute]
public static bool EndsWith(string str, char c);
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[DebuggerDisplayAttribute("{InnerText}")]
public class DocumentFormat.OpenXml.StringValue : OpenXmlComparableSimpleReference`1<string> {
    internal bool IsValid { get; }
    internal int Length { get; }
    [NullableAttribute("2")]
public string Value { get; public set; }
    [NullableContextAttribute("2")]
public StringValue(string value);
    public StringValue(StringValue source);
    internal virtual bool get_IsValid();
    internal virtual int get_Length();
    [NullableContextAttribute("2")]
public virtual string get_Value();
    [NullableContextAttribute("2")]
public virtual void set_Value(string value);
    [NullableContextAttribute("2")]
public static string op_Implicit(StringValue value);
    public static StringValue op_Implicit(string value);
    public static StringValue FromString(string value);
    public static string ToString(StringValue value);
    private protected virtual OpenXmlSimpleType CloneImpl();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[DebuggerDisplayAttribute("{InnerText}")]
public class DocumentFormat.OpenXml.TrueFalseBlankValue : OpenXmlComparableSimpleValue`1<bool> {
    public TrueFalseBlankValue(bool value);
    public TrueFalseBlankValue(TrueFalseBlankValue source);
    public static bool op_Implicit(TrueFalseBlankValue value);
    public static TrueFalseBlankValue op_Implicit(bool value);
    public static TrueFalseBlankValue FromBoolean(bool value);
    public static bool ToBoolean(TrueFalseBlankValue value);
    private protected virtual OpenXmlSimpleType CloneImpl();
    [NullableContextAttribute("2")]
private protected virtual bool ShouldParse(string value);
    [NullableContextAttribute("2")]
private protected virtual bool Parse(string textValue);
    private protected virtual string GetText(bool boolValue);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[DebuggerDisplayAttribute("{InnerText}")]
public class DocumentFormat.OpenXml.TrueFalseValue : OpenXmlComparableSimpleValue`1<bool> {
    public TrueFalseValue(bool value);
    public TrueFalseValue(TrueFalseValue source);
    public static bool op_Implicit(TrueFalseValue value);
    public static TrueFalseValue op_Implicit(bool value);
    public static TrueFalseValue FromBoolean(bool value);
    public static bool ToBoolean(TrueFalseValue value);
    private protected virtual OpenXmlSimpleType CloneImpl();
    [NullableContextAttribute("2")]
private protected virtual bool ShouldParse(string value);
    [NullableContextAttribute("2")]
private protected virtual bool Parse(string textValue);
    private protected virtual string GetText(bool boolValue);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
internal static class DocumentFormat.OpenXml.TypeExtensions : object {
    [ExtensionAttribute]
public static Type GetTypeInfo(Type type);
    [ExtensionAttribute]
public static Attribute GetCustomAttribute(MemberInfo element, Type attributeType);
    [ExtensionAttribute]
public static T GetCustomAttribute(MemberInfo element);
    [ExtensionAttribute]
public static IEnumerable`1<Attribute> GetCustomAttributes(MemberInfo element, Type attributeType);
    [ExtensionAttribute]
public static IEnumerable`1<T> GetCustomAttributes(MemberInfo element);
    [ExtensionAttribute]
public static IEnumerable`1<Attribute> GetCustomAttributes(MemberInfo element, Type attributeType, bool inherit);
    [ExtensionAttribute]
public static IEnumerable`1<T> GetCustomAttributes(MemberInfo element, bool inherit);
    [ExtensionAttribute]
public static FieldInfo GetDeclaredField(Type type, string name);
    [ExtensionAttribute]
public static IEnumerable`1<PropertyInfo> GetRuntimeProperties(Type type);
    [ExtensionAttribute]
public static PropertyInfo GetRuntimeProperty(Type type, string name);
    [NullableContextAttribute("2")]
[ExtensionAttribute]
public static object GetValue(PropertyInfo property, object obj);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[CLSCompliantAttribute("False")]
[DebuggerDisplayAttribute("{InnerText}")]
public class DocumentFormat.OpenXml.UInt16Value : OpenXmlComparableSimpleValue`1<ushort> {
    public UInt16Value(ushort value);
    public UInt16Value(UInt16Value source);
    private protected virtual string GetText(ushort input);
    private protected virtual ushort Parse(string input);
    public static ushort op_Implicit(UInt16Value value);
    public static UInt16Value op_Implicit(ushort value);
    public static UInt16Value FromUInt16(ushort value);
    public static ushort ToUInt16(UInt16Value value);
    private protected virtual OpenXmlSimpleType CloneImpl();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[CLSCompliantAttribute("False")]
[DebuggerDisplayAttribute("{InnerText}")]
public class DocumentFormat.OpenXml.UInt32Value : OpenXmlComparableSimpleValue`1<UInt32> {
    public UInt32Value(UInt32 value);
    public UInt32Value(UInt32Value source);
    private protected virtual string GetText(UInt32 input);
    private protected virtual UInt32 Parse(string input);
    public static UInt32 op_Implicit(UInt32Value value);
    public static UInt32Value op_Implicit(UInt32 value);
    public static UInt32Value FromUInt32(UInt32 value);
    public static UInt32 ToUInt32(UInt32Value value);
    private protected virtual OpenXmlSimpleType CloneImpl();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[CLSCompliantAttribute("False")]
[DebuggerDisplayAttribute("{InnerText}")]
public class DocumentFormat.OpenXml.UInt64Value : OpenXmlComparableSimpleValue`1<ulong> {
    public UInt64Value(ulong value);
    public UInt64Value(UInt64Value source);
    private protected virtual string GetText(ulong input);
    private protected virtual ulong Parse(string input);
    public static ulong op_Implicit(UInt64Value value);
    public static UInt64Value op_Implicit(ulong value);
    public static UInt64Value FromUInt64(ulong value);
    public static ulong ToUInt64(UInt64Value value);
    private protected virtual OpenXmlSimpleType CloneImpl();
}
internal static class DocumentFormat.OpenXml.UriHelper : object {
    public static UriKind RelativeOrAbsolute;
    private static UriHelper();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class DocumentFormat.OpenXml.Validation.DocumentValidator : object {
    private ValidationCache _cache;
    public DocumentValidator(ValidationCache cache);
    public List`1<ValidationErrorInfo> Validate(OpenXmlPackage document, ValidationSettings settings, CancellationToken token);
    public List`1<ValidationErrorInfo> Validate(OpenXmlPart part, ValidationSettings settings, CancellationToken token);
    private void ValidatePart(OpenXmlPart part, ValidationContext context);
    public void Validate(ValidationContext validationContext);
    private IEnumerable`1<OpenXmlPart> PartsToBeValidated(OpenXmlPackage package);
    private static void ValidatePackageStructure(OpenXmlPackage document, ValidationContext context);
    private static string GetPartNameAndUri(OpenXmlPart part);
    private static string GetPartUri(OpenXmlPart part);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class DocumentFormat.OpenXml.Validation.OpenXmlValidator : object {
    private ValidationSettings _settings;
    private ValidationCache _cache;
    private DocumentValidator _documentValidator;
    public FileFormatVersions FileFormat { get; }
    public int MaxNumberOfErrors { get; public set; }
    public OpenXmlValidator(FileFormatVersions fileFormat);
    public FileFormatVersions get_FileFormat();
    public int get_MaxNumberOfErrors();
    public void set_MaxNumberOfErrors(int value);
    public IEnumerable`1<ValidationErrorInfo> Validate(OpenXmlPackage openXmlPackage);
    private IEnumerable`1<ValidationErrorInfo> Validate(OpenXmlPackage openXmlPackage, CancellationToken token);
    public IEnumerable`1<ValidationErrorInfo> Validate(OpenXmlPart openXmlPart);
    private IEnumerable`1<ValidationErrorInfo> Validate(OpenXmlPart openXmlPart, CancellationToken token);
    public IEnumerable`1<ValidationErrorInfo> Validate(OpenXmlElement openXmlElement);
    private IEnumerable`1<ValidationErrorInfo> Validate(OpenXmlElement openXmlElement, CancellationToken token);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class DocumentFormat.OpenXml.Validation.PackageValidator : ValueType {
    private OpenXmlPackage _package;
    public PackageValidator(OpenXmlPackage package);
    public IEnumerable`1<OpenXmlPackageValidationResult> Validate(FileFormatVersions version);
    private static IEnumerable`1<OpenXmlPackageValidationResult> ValidateInternal(OpenXmlPartContainer container, FileFormatVersions version, Dictionary`2<OpenXmlPart, bool> processedParts);
    private static IEnumerable`1<OpenXmlPackageValidationResult> ValidateDataPartReferenceRelationships(OpenXmlPartContainer container, FileFormatVersions version);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class DocumentFormat.OpenXml.Validation.Schema.AllParticleValidator : CompositeParticleValidator {
    private Dictionary`2<Type, bool> _childrenParticles;
    internal AllParticleValidator(CompositeParticle particleConstraint);
    public virtual void TryMatch(ParticleMatchInfo particleMatchInfo, ValidationContext validationContext);
    public virtual void TryMatchOnce(ParticleMatchInfo particleMatchInfo, ValidationContext validationContext);
    protected virtual void EmitInvalidElementError(ValidationContext validationContext, ParticleMatchInfo particleMatchInfo);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class DocumentFormat.OpenXml.Validation.Schema.AlternateContentValidator : object {
    internal static void Validate(ValidationContext validationContext);
    private static void ValidateMcAttributesOnAcb(ValidationContext validationContext, OpenXmlElement acElement);
    internal static bool IsXmlSpaceOrXmlLangAttribue(OpenXmlAttribute attribute);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[DebuggerDisplayAttribute("NamespaceValue={NamespaceValue}")]
internal class DocumentFormat.OpenXml.Validation.Schema.AnyParticle : ParticleConstraint {
    private IParticleValidator _particleValidator;
    [CompilerGeneratedAttribute]
private XsdAny <NamespaceValue>k__BackingField;
    public XsdAny NamespaceValue { get; }
    internal IParticleValidator ParticleValidator { get; }
    internal AnyParticle(XsdAny xsdAnyValue, int minOccurs, int maxOccurs, FileFormatVersions version);
    internal AnyParticle(int minOccurs, int maxOccurs, FileFormatVersions version);
    [CompilerGeneratedAttribute]
public XsdAny get_NamespaceValue();
    internal virtual IParticleValidator get_ParticleValidator();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class DocumentFormat.OpenXml.Validation.Schema.AnyParticleValidator : object {
    private AnyParticle _particleConstraint;
    internal ParticleConstraint ParticleConstraint { get; }
    internal AnyParticleValidator(AnyParticle particleConstraint);
    internal virtual ParticleConstraint get_ParticleConstraint();
    public virtual void TryMatchOnce(ParticleMatchInfo particleMatchInfo, ValidationContext validationContext);
    public sealed virtual void TryMatch(ParticleMatchInfo particleMatchInfo, ValidationContext validationContext);
    [NullableContextAttribute("2")]
public virtual bool GetRequiredElements(ExpectedChildren result);
    public sealed virtual ExpectedChildren GetRequiredElements();
    public virtual bool GetExpectedElements(ExpectedChildren result);
    public sealed virtual ExpectedChildren GetExpectedElements();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class DocumentFormat.OpenXml.Validation.Schema.ChoiceParticleValidator : CompositeParticleValidator {
    internal ChoiceParticleValidator(CompositeParticle particleConstraint);
    public virtual void TryMatchOnce(ParticleMatchInfo particleMatchInfo, ValidationContext validationContext);
    [NullableContextAttribute("2")]
public virtual bool GetRequiredElements(ExpectedChildren result);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal static class DocumentFormat.OpenXml.Validation.Schema.CompatibilityRuleAttributesValidator : object {
    internal static void ValidateMcAttributes(ValidationContext validationContext);
    internal static string ValidateQNameList(string qnameList, HashSet`1<string> ignorableNamespaces, ValidationContext validationContext);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[DebuggerDisplayAttribute("ParticleType={ParticleType}")]
internal class DocumentFormat.OpenXml.Validation.Schema.CompositeParticle : ParticleConstraint {
    [NullableAttribute("2")]
private IParticleValidator _particleValidator;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private ReadOnlyArray`1<ParticleConstraint> <ChildrenParticles>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <RequireFilter>k__BackingField;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ReadOnlyArray`1<ParticleConstraint> ChildrenParticles { get; }
    public bool RequireFilter { get; }
    internal IParticleValidator ParticleValidator { get; }
    public CompositeParticle(ParticleType particleType, int minOccurs, int maxOccurs, bool requireFilter, FileFormatVersions version, ReadOnlyArray`1& children);
    [CompilerGeneratedAttribute]
public ReadOnlyArray`1<ParticleConstraint> get_ChildrenParticles();
    [CompilerGeneratedAttribute]
public bool get_RequireFilter();
    [NullableContextAttribute("2")]
public virtual ParticleConstraint Build(FileFormatVersions version);
    internal virtual IParticleValidator get_ParticleValidator();
    private ParticleValidator CreateParticleValidator();
    [NullableContextAttribute("2")]
public virtual bool Equals(object obj);
    public virtual int GetHashCode();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal abstract class DocumentFormat.OpenXml.Validation.Schema.CompositeParticleValidator : ParticleValidator {
    [CompilerGeneratedAttribute]
private CompositeParticle <ParticleConstraint>k__BackingField;
    protected CompositeParticle ParticleConstraint { get; }
    protected CompositeParticleValidator(CompositeParticle particleConstraint);
    [CompilerGeneratedAttribute]
protected CompositeParticle get_ParticleConstraint();
    internal virtual void Validate(ValidationContext validationContext);
    public virtual void TryMatch(ParticleMatchInfo particleMatchInfo, ValidationContext validationContext);
    [NullableContextAttribute("2")]
public virtual bool GetRequiredElements(ExpectedChildren result);
    public virtual bool GetExpectedElements(ExpectedChildren result);
    protected virtual void EmitInvalidElementError(ValidationContext validationContext, ParticleMatchInfo particleMatchInfo);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[DebuggerDisplayAttribute("ElementId={ElementId}")]
internal class DocumentFormat.OpenXml.Validation.Schema.ElementParticle : ParticleConstraint {
    [CompilerGeneratedAttribute]
private Type <ElementType>k__BackingField;
    public Type ElementType { get; }
    internal IParticleValidator ParticleValidator { get; }
    public ElementParticle(Type elementType, int minOccurs, int maxOccurs, FileFormatVersions version);
    [CompilerGeneratedAttribute]
public Type get_ElementType();
    internal virtual IParticleValidator get_ParticleValidator();
    public sealed virtual void TryMatchOnce(ParticleMatchInfo particleMatchInfo, ValidationContext validationContext);
    public sealed virtual void TryMatch(ParticleMatchInfo particleMatchInfo, ValidationContext validationContext);
    [NullableContextAttribute("2")]
public sealed virtual bool GetRequiredElements(ExpectedChildren result);
    public sealed virtual ExpectedChildren GetRequiredElements();
    public sealed virtual bool GetExpectedElements(ExpectedChildren result);
    public sealed virtual ExpectedChildren GetExpectedElements();
    [NullableContextAttribute("2")]
public virtual bool Equals(object obj);
    public virtual int GetHashCode();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class DocumentFormat.OpenXml.Validation.Schema.ExpectedChildren : object {
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private List`1<Type> _elementTypes;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private List`1<string> _xsdanyNamespaces;
    internal int Count { get; }
    public void Add(Type elementType);
    public void Add(string namesapceForXsdany);
    internal void Add(ExpectedChildren expectedChildren);
    internal int get_Count();
    internal string GetExpectedChildrenMessage(OpenXmlElement parent);
    internal void Clear();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class DocumentFormat.OpenXml.Validation.Schema.GroupParticleValidator : CompositeParticleValidator {
    internal GroupParticleValidator(CompositeParticle particleConstraint);
    public virtual void TryMatchOnce(ParticleMatchInfo particleMatchInfo, ValidationContext validationContext);
}
[NullableContextAttribute("1")]
internal interface DocumentFormat.OpenXml.Validation.Schema.IParticleValidator {
    public abstract virtual void TryMatchOnce(ParticleMatchInfo particleMatchInfo, ValidationContext validationContext);
    public abstract virtual void TryMatch(ParticleMatchInfo particleMatchInfo, ValidationContext validationContext);
    [NullableContextAttribute("2")]
public abstract virtual bool GetRequiredElements(ExpectedChildren result);
    public abstract virtual ExpectedChildren GetRequiredElements();
    public abstract virtual bool GetExpectedElements(ExpectedChildren result);
    public abstract virtual ExpectedChildren GetExpectedElements();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
internal static class DocumentFormat.OpenXml.Validation.Schema.OpenXmlElementExtensionMethods : object {
    [ExtensionAttribute]
internal static OpenXmlElement GetFirstChildMc(OpenXmlElement parent, MCContext mcContext, FileFormatVersions format);
    [ExtensionAttribute]
internal static OpenXmlElement GetNextChildMc(OpenXmlElement parent, OpenXmlElement child, MCContext mcContext, FileFormatVersions format);
    [ExtensionAttribute]
private static OpenXmlElement GetChildMc(OpenXmlElement parent, OpenXmlElement child, MCContext mcContext, FileFormatVersions format);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
internal abstract class DocumentFormat.OpenXml.Validation.Schema.ParticleConstraint : object {
    [CompilerGeneratedAttribute]
private ParticleType <ParticleType>k__BackingField;
    [CompilerGeneratedAttribute]
private int <MinOccurs>k__BackingField;
    [CompilerGeneratedAttribute]
private int <MaxOccurs>k__BackingField;
    [CompilerGeneratedAttribute]
private FileFormatVersions <Version>k__BackingField;
    public ParticleType ParticleType { get; }
    public int MinOccurs { get; }
    public int MaxOccurs { get; }
    public FileFormatVersions Version { get; }
    internal bool UnboundedMaxOccurs { get; }
    internal bool CanOccursMoreThanOne { get; }
    internal IParticleValidator ParticleValidator { get; }
    protected ParticleConstraint(ParticleType type, int minOccurs, int maxOccurs, FileFormatVersions version);
    [CompilerGeneratedAttribute]
public ParticleType get_ParticleType();
    [CompilerGeneratedAttribute]
public int get_MinOccurs();
    [CompilerGeneratedAttribute]
public int get_MaxOccurs();
    [CompilerGeneratedAttribute]
public FileFormatVersions get_Version();
    internal bool get_UnboundedMaxOccurs();
    internal bool get_CanOccursMoreThanOne();
    internal bool MaxOccursGreaterThan(int count);
    internal virtual IParticleValidator get_ParticleValidator();
    public virtual ParticleConstraint Build(FileFormatVersions version);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
}
internal enum DocumentFormat.OpenXml.Validation.Schema.ParticleMatch : Enum {
    public int value__;
    public static ParticleMatch Nomatch;
    public static ParticleMatch Partial;
    public static ParticleMatch Matched;
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
[DebuggerDisplayAttribute("Match={Match}")]
internal class DocumentFormat.OpenXml.Validation.Schema.ParticleMatchInfo : object {
    private ExpectedChildren _expectedChildren;
    [CompilerGeneratedAttribute]
private ParticleMatch <Match>k__BackingField;
    [CompilerGeneratedAttribute]
private OpenXmlElement <StartElement>k__BackingField;
    [CompilerGeneratedAttribute]
private OpenXmlElement <LastMatchedElement>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ErrorMessage>k__BackingField;
    internal ParticleMatch Match { get; internal set; }
    internal OpenXmlElement StartElement { get; private set; }
    internal OpenXmlElement LastMatchedElement { get; internal set; }
    internal string ErrorMessage { get; internal set; }
    [NullableAttribute("1")]
internal ExpectedChildren ExpectedChildren { get; }
    [NullableContextAttribute("1")]
internal ParticleMatchInfo(OpenXmlElement startElement);
    [CompilerGeneratedAttribute]
internal ParticleMatch get_Match();
    [CompilerGeneratedAttribute]
internal void set_Match(ParticleMatch value);
    [CompilerGeneratedAttribute]
internal OpenXmlElement get_StartElement();
    [CompilerGeneratedAttribute]
private void set_StartElement(OpenXmlElement value);
    [CompilerGeneratedAttribute]
internal OpenXmlElement get_LastMatchedElement();
    [CompilerGeneratedAttribute]
internal void set_LastMatchedElement(OpenXmlElement value);
    [CompilerGeneratedAttribute]
internal string get_ErrorMessage();
    [CompilerGeneratedAttribute]
internal void set_ErrorMessage(string value);
    [NullableContextAttribute("1")]
internal ExpectedChildren get_ExpectedChildren();
    [NullableContextAttribute("1")]
internal void SetExpectedChildren(ExpectedChildren expectedChildren);
    internal void Reset(OpenXmlElement startElement);
}
internal enum DocumentFormat.OpenXml.Validation.Schema.ParticleType : Enum {
    public byte value__;
    public static ParticleType Element;
    public static ParticleType All;
    public static ParticleType Any;
    public static ParticleType Choice;
    public static ParticleType Group;
    public static ParticleType Sequence;
    public static ParticleType AnyWithUri;
    public static ParticleType Invalid;
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal abstract class DocumentFormat.OpenXml.Validation.Schema.ParticleValidator : object {
    internal abstract virtual void Validate(ValidationContext validationContext);
    public virtual void TryMatchOnce(ParticleMatchInfo particleMatchInfo, ValidationContext validationContext);
    public virtual void TryMatch(ParticleMatchInfo particleMatchInfo, ValidationContext validationContext);
    [NullableContextAttribute("2")]
public virtual bool GetRequiredElements(ExpectedChildren result);
    public sealed virtual ExpectedChildren GetRequiredElements();
    public virtual bool GetExpectedElements(ExpectedChildren result);
    public sealed virtual ExpectedChildren GetExpectedElements();
    internal static string GetExpectedChildrenMessage(OpenXmlElement parent, ExpectedChildren expectedChildrenIds);
}
internal class DocumentFormat.OpenXml.Validation.Schema.Restrictions.AnyUriRestriction : object {
    [NullableAttribute("1")]
[DebuggerBrowsableAttribute("0")]
private static Char[] _whitespaceChars;
    private static AnyUriRestriction();
    [NullableContextAttribute("2")]
public static bool Validate(string uriString);
}
internal class DocumentFormat.OpenXml.Validation.Schema.Restrictions.QnameRestriction : object {
    [NullableContextAttribute("2")]
public static bool IsValidQName(string qname);
}
internal static class DocumentFormat.OpenXml.Validation.Schema.Restrictions.TokenRestriction : object {
    [NullableAttribute("1")]
private static Char[] _crt;
    private static TokenRestriction();
    [NullableContextAttribute("2")]
public static bool VerifyTOKEN(string token);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class DocumentFormat.OpenXml.Validation.Schema.SchemaTypeValidator : object {
    public static void Validate(ValidationContext validationContext);
    private static void ValidateAttributes(ValidationContext validationContext);
    private static void ValidateValue(ValidationContext validationContext, ReadOnlyArray`1<IValidator> validators, OpenXmlSimpleType value, AttributeMetadata state, bool isAttribute);
    private static void ValidateEmptyComplexType(ValidationContext validationContext);
    private static void ValidateEmptyRootComplexType(ValidationContext validationContext);
    private static void ValidateSimpleContextComplexType(ValidationContext validationContext);
    private static void ValidateCompositeComplexType(ValidationContext validationContext);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class DocumentFormat.OpenXml.Validation.Schema.SequenceParticleValidator : CompositeParticleValidator {
    internal SequenceParticleValidator(CompositeParticle particleConstraint);
    public virtual void TryMatchOnce(ParticleMatchInfo particleMatchInfo, ValidationContext validationContext);
    [NullableContextAttribute("2")]
public virtual bool GetRequiredElements(ExpectedChildren result);
    public virtual bool GetExpectedElements(ExpectedChildren result);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
internal static class DocumentFormat.OpenXml.Validation.Schema.ValidationContextExtension : object {
    [ExtensionAttribute]
internal static ValidationErrorInfo ComposeSchemaValidationError(ValidationContext validationContext, OpenXmlElement element, OpenXmlElement child, string messageId, Object[] args);
    [ExtensionAttribute]
internal static ValidationErrorInfo ComposeMcValidationError(ValidationContext validationContext, OpenXmlElement element, string messageId, Object[] args);
    [ExtensionAttribute]
internal static ValidationErrorInfo ComposeValidationError(ValidationContext validationContext, ValidationErrorType errorType, OpenXmlElement element, OpenXmlElement child, string messageId, Object[] args);
}
internal enum DocumentFormat.OpenXml.Validation.Schema.XsdAny : Enum {
    public int value__;
    public static XsdAny Any;
    public static XsdAny Other;
    public static XsdAny Local;
    public static XsdAny TargetNamespace;
}
[ExtensionAttribute]
internal static class DocumentFormat.OpenXml.Validation.Schema.XsdAnyExtensions : object {
    [NullableContextAttribute("1")]
[ExtensionAttribute]
public static string GetNamespaceString(XsdAny value);
}
internal enum DocumentFormat.OpenXml.Validation.Schema.XsdType : Enum {
    public byte value__;
    public static XsdType AnySimpleType;
    public static XsdType String;
    public static XsdType NormalizedString;
    public static XsdType Token;
    public static XsdType Base64Binary;
    public static XsdType HexBinary;
    public static XsdType Integer;
    public static XsdType PositiveInteger;
    public static XsdType NegativeInteger;
    public static XsdType NonNegativeInteger;
    public static XsdType NonPositiveInteger;
    public static XsdType Long;
    public static XsdType UnsignedLong;
    public static XsdType Int;
    public static XsdType UnsignedInt;
    public static XsdType Short;
    public static XsdType UnsignedShort;
    public static XsdType Byte;
    public static XsdType UnsignedByte;
    public static XsdType Decimal;
    public static XsdType Float;
    public static XsdType Double;
    public static XsdType Boolean;
    public static XsdType Duration;
    public static XsdType DateTime;
    public static XsdType Date;
    public static XsdType Time;
    public static XsdType GYear;
    public static XsdType GYearMonth;
    public static XsdType GMonth;
    public static XsdType GMonthDay;
    public static XsdType GDay;
    public static XsdType Name;
    public static XsdType QName;
    public static XsdType NCName;
    public static XsdType AnyURI;
    public static XsdType Language;
    public static XsdType ID;
    public static XsdType IDREF;
    public static XsdType IDREFS;
    public static XsdType ENTITY;
    public static XsdType ENTITIES;
    public static XsdType NOTATION;
    public static XsdType NMTOKEN;
    public static XsdType NMTOKENS;
    public static XsdType Enum;
    public static XsdType List;
    public static XsdType Union;
    public static XsdType Redirected;
    public static XsdType SpecialBoolean;
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class DocumentFormat.OpenXml.Validation.Semantic.AttributeAbsentConditionToNonValue : SemanticConstraint {
    private OpenXmlQualifiedName _absentAttribute;
    private OpenXmlQualifiedName _conditionAttribute;
    private String[] _values;
    public AttributeAbsentConditionToNonValue(OpenXmlQualifiedName absentAttribute, OpenXmlQualifiedName conditionAttribute, String[] values);
    public virtual ValidationErrorInfo ValidateCore(ValidationContext context);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class DocumentFormat.OpenXml.Validation.Semantic.AttributeAbsentConditionToValue : SemanticConstraint {
    private OpenXmlQualifiedName _absentAttribute;
    private OpenXmlQualifiedName _conditionAttribute;
    private String[] _values;
    public AttributeAbsentConditionToValue(OpenXmlQualifiedName absentAttribute, OpenXmlQualifiedName conditionAttribute, String[] values);
    public virtual ValidationErrorInfo ValidateCore(ValidationContext context);
}
internal class DocumentFormat.OpenXml.Validation.Semantic.AttributeCannotOmitConstraint : SemanticConstraint {
    private OpenXmlQualifiedName _attribute;
    public AttributeCannotOmitConstraint(OpenXmlQualifiedName attribute);
    [NullableContextAttribute("1")]
public virtual ValidationErrorInfo ValidateCore(ValidationContext context);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class DocumentFormat.OpenXml.Validation.Semantic.AttributeMinMaxConstraint : SemanticConstraint {
    private string _minAttributeLocalName;
    private string _minAttributeNamesapce;
    private string _maxAttributeLocalName;
    private string _maxAttributeNamesapce;
    public AttributeMinMaxConstraint(string minAttributeNamespace, string minAttributeLocalName, string maxAttributeNamespace, string maxAttributeLocalName);
    public virtual ValidationErrorInfo ValidateCore(ValidationContext context);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class DocumentFormat.OpenXml.Validation.Semantic.AttributeMutualExclusive : SemanticConstraint {
    private OpenXmlQualifiedName[] _attributes;
    public AttributeMutualExclusive(OpenXmlQualifiedName attribute);
    public AttributeMutualExclusive(OpenXmlQualifiedName attribute1, OpenXmlQualifiedName attribute2);
    public AttributeMutualExclusive(OpenXmlQualifiedName attribute1, OpenXmlQualifiedName attribute2, OpenXmlQualifiedName attribute3);
    public AttributeMutualExclusive(OpenXmlQualifiedName attribute1, OpenXmlQualifiedName attribute2, OpenXmlQualifiedName attribute3, OpenXmlQualifiedName attribute4);
    public AttributeMutualExclusive(OpenXmlQualifiedName attribute1, OpenXmlQualifiedName attribute2, OpenXmlQualifiedName attribute3, OpenXmlQualifiedName attribute4, OpenXmlQualifiedName attribute5);
    public AttributeMutualExclusive(OpenXmlQualifiedName attribute1, OpenXmlQualifiedName attribute2, OpenXmlQualifiedName attribute3, OpenXmlQualifiedName attribute4, OpenXmlQualifiedName attribute5, OpenXmlQualifiedName attribute6);
    private AttributeMutualExclusive(OpenXmlQualifiedName[] attributes);
    public virtual ValidationErrorInfo ValidateCore(ValidationContext context);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class DocumentFormat.OpenXml.Validation.Semantic.AttributePairConstraint : SemanticConstraint {
    private string _attribute1LocalName;
    private string _attribute1Namespace;
    private string _attribute2LocalName;
    private string _attribute2Namespace;
    public AttributePairConstraint(string attribute1Namespace, string attribute1LocalName, string attribute2Namespace, string attribute2LocalName);
    public virtual ValidationErrorInfo ValidateCore(ValidationContext context);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class DocumentFormat.OpenXml.Validation.Semantic.AttributeRequiredConditionToValue : SemanticConstraint {
    private string _value;
    private OpenXmlQualifiedName _requiredAttribute;
    private OpenXmlQualifiedName _conditionAttribute;
    public AttributeRequiredConditionToValue(OpenXmlQualifiedName requiredAttribute, OpenXmlQualifiedName conditionAttribute, string value);
    public virtual ValidationErrorInfo ValidateCore(ValidationContext context);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class DocumentFormat.OpenXml.Validation.Semantic.AttributeValueConditionToAnother : SemanticConstraint {
    private OpenXmlQualifiedName _attribute;
    private OpenXmlQualifiedName _conditionAttribute;
    private String[] _values;
    private String[] _otherValues;
    public AttributeValueConditionToAnother(OpenXmlQualifiedName attribute, OpenXmlQualifiedName conditionAttribute, String[] values, String[] otherValues);
    public virtual ValidationErrorInfo ValidateCore(ValidationContext context);
}
internal class DocumentFormat.OpenXml.Validation.Semantic.AttributeValueLengthConstraint : SemanticConstraint {
    private OpenXmlQualifiedName _attribute;
    private int _minLength;
    private int _maxLength;
    public AttributeValueLengthConstraint(OpenXmlQualifiedName attribute, int minLength, int maxLength);
    [NullableContextAttribute("1")]
public virtual ValidationErrorInfo ValidateCore(ValidationContext context);
}
internal class DocumentFormat.OpenXml.Validation.Semantic.AttributeValueLessEqualToAnother : SemanticConstraint {
    private OpenXmlQualifiedName _attribute;
    private OpenXmlQualifiedName _otherAttribute;
    private bool _canEqual;
    public AttributeValueLessEqualToAnother(OpenXmlQualifiedName attribute, OpenXmlQualifiedName otherAttribute, bool canEqual);
    [NullableContextAttribute("1")]
public virtual ValidationErrorInfo ValidateCore(ValidationContext context);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class DocumentFormat.OpenXml.Validation.Semantic.AttributeValuePatternConstraint : SemanticConstraint {
    private OpenXmlQualifiedName _attribute;
    private Regex _pattern;
    public AttributeValuePatternConstraint(OpenXmlQualifiedName attribute, string pattern);
    public virtual ValidationErrorInfo ValidateCore(ValidationContext context);
}
internal class DocumentFormat.OpenXml.Validation.Semantic.AttributeValueRangeConstraint : SemanticConstraint {
    private OpenXmlQualifiedName _attribute;
    private bool _isValidRange;
    private double _minValue;
    private double _maxValue;
    private bool _minInclusive;
    private bool _maxInclusive;
    public AttributeValueRangeConstraint(OpenXmlQualifiedName attribute, bool isValid, double minValue, bool minInclusive, double maxValue, bool maxInclusive);
    [NullableContextAttribute("1")]
public virtual ValidationErrorInfo ValidateCore(ValidationContext context);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class DocumentFormat.OpenXml.Validation.Semantic.AttributeValueSetConstraint : SemanticConstraint {
    private OpenXmlQualifiedName _attribute;
    private bool _isValidValueSet;
    private String[] _valueSet;
    public AttributeValueSetConstraint(OpenXmlQualifiedName attribute, bool isValid, String[] valueSet);
    public virtual ValidationErrorInfo ValidateCore(ValidationContext context);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class DocumentFormat.OpenXml.Validation.Semantic.IndexReferenceConstraint : SemanticConstraint {
    private OpenXmlQualifiedName _attribute;
    private string _refPartType;
    private Nullable`1<OpenXmlQualifiedName> _refElementParent;
    private OpenXmlQualifiedName _refElement;
    private int _indexBase;
    public SemanticValidationLevel StateScope { get; }
    public IndexReferenceConstraint(OpenXmlQualifiedName attribute, string referencedPart, Nullable`1<OpenXmlQualifiedName> referencedElementParent, OpenXmlQualifiedName referencedElement, string referencedElementName, int indexBase);
    public virtual SemanticValidationLevel get_StateScope();
    public virtual ValidationErrorInfo ValidateCore(ValidationContext context);
    [NullableContextAttribute("0")]
private PartHolder`1<int> GetRefElementCount(ValidationContext context);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class DocumentFormat.OpenXml.Validation.Semantic.ParentTypeConstraint : SemanticConstraint {
    private Type _parentType;
    private bool _isValid;
    public ParentTypeConstraint(Type parent, bool valid);
    public virtual ValidationErrorInfo ValidateCore(ValidationContext context);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class DocumentFormat.OpenXml.Validation.Semantic.ReferenceExistConstraint : SemanticConstraint {
    private OpenXmlQualifiedName _refAttribute;
    private string _partPath;
    private OpenXmlQualifiedName _element;
    private string _elementName;
    private OpenXmlQualifiedName _attribute;
    public SemanticValidationLevel StateScope { get; }
    public ReferenceExistConstraint(OpenXmlQualifiedName refAttribute, string part, OpenXmlQualifiedName element, string elementName, OpenXmlQualifiedName attribute);
    public virtual SemanticValidationLevel get_StateScope();
    public virtual ValidationErrorInfo ValidateCore(ValidationContext context);
    private PartHolder`1<ICollection`1<string>> GetReferencedAttributes(ValidationContext context);
}
internal class DocumentFormat.OpenXml.Validation.Semantic.RelationshipExistConstraint : SemanticConstraint {
    private OpenXmlQualifiedName _attribute;
    public RelationshipExistConstraint(OpenXmlQualifiedName attribute);
    [NullableContextAttribute("1")]
public virtual ValidationErrorInfo ValidateCore(ValidationContext context);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class DocumentFormat.OpenXml.Validation.Semantic.RelationshipTypeConstraint : SemanticConstraint {
    private OpenXmlQualifiedName _attribute;
    private string _type;
    public RelationshipTypeConstraint(OpenXmlQualifiedName attribute, string type);
    public virtual ValidationErrorInfo ValidateCore(ValidationContext context);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal abstract class DocumentFormat.OpenXml.Validation.Semantic.SemanticConstraint : object {
    [CompilerGeneratedAttribute]
private SemanticValidationLevel <SemanticValidationLevel>k__BackingField;
    [CompilerGeneratedAttribute]
private ApplicationType <Application>k__BackingField;
    [CompilerGeneratedAttribute]
private FileFormatVersions <Version>k__BackingField;
    public SemanticValidationLevel SemanticValidationLevel { get; }
    public SemanticValidationLevel StateScope { get; }
    public ApplicationType Application { get; public set; }
    public FileFormatVersions Version { get; public set; }
    public SemanticConstraint(SemanticValidationLevel level);
    [CompilerGeneratedAttribute]
public SemanticValidationLevel get_SemanticValidationLevel();
    public virtual SemanticValidationLevel get_StateScope();
    [CompilerGeneratedAttribute]
public ApplicationType get_Application();
    [CompilerGeneratedAttribute]
public void set_Application(ApplicationType value);
    [CompilerGeneratedAttribute]
public FileFormatVersions get_Version();
    [CompilerGeneratedAttribute]
public void set_Version(FileFormatVersions value);
    protected static bool TryFindAttribute(OpenXmlElement element, OpenXmlQualifiedName attribute, AttributeEntry& result);
    public sealed virtual void Validate(ValidationContext context);
    public abstract virtual ValidationErrorInfo ValidateCore(ValidationContext context);
    private static void Get(ValidationContext context, SemanticValidationLevel& level, ApplicationType& type);
    protected static OpenXmlPart GetReferencedPart(ValidationContext context, string path);
    protected static OpenXmlQualifiedName GetAttributeQualifiedName(OpenXmlElement element, byte attributeID);
    private static bool CompareBooleanValue(bool value1, string value2);
    protected static bool AttributeValueEquals(OpenXmlSimpleType type, string value, bool ignoreCase);
    protected static bool GetAttrNumVal(OpenXmlSimpleType attributeValue, Double& value);
    private static OpenXmlPart GetPartThroughPartPath(IEnumerable`1<IdPartPair> pairs, String[] path);
}
[FlagsAttribute]
internal enum DocumentFormat.OpenXml.Validation.Semantic.SemanticValidationLevel : Enum {
    public int value__;
    public static SemanticValidationLevel PackageOnly;
    public static SemanticValidationLevel PartOnly;
    public static SemanticValidationLevel ElementOnly;
    public static SemanticValidationLevel Package;
    public static SemanticValidationLevel Part;
    public static SemanticValidationLevel Element;
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class DocumentFormat.OpenXml.Validation.Semantic.UniqueAttributeValueConstraint : SemanticConstraint {
    private OpenXmlQualifiedName _attribute;
    private Nullable`1<OpenXmlQualifiedName> _parent;
    private StringComparer _comparer;
    public UniqueAttributeValueConstraint(OpenXmlQualifiedName attribute, bool caseSensitive, Nullable`1<OpenXmlQualifiedName> parent);
    public virtual ValidationErrorInfo ValidateCore(ValidationContext context);
    private OpenXmlElement GetRoot(OpenXmlElement element);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class DocumentFormat.OpenXml.Validation.StateManager : object {
    private ValidationContext _context;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private Dictionary`2<object, object> _state;
    public StateManager(ValidationContext context);
    public TValue GetOrCreate(TKey key, Func`3<TKey, ValidationContext, TValue> factory);
}
[FlagsAttribute]
internal enum DocumentFormat.OpenXml.Validation.TraversalOptions : Enum {
    public int value__;
    public static TraversalOptions None;
    public static TraversalOptions SelectAlternateContent;
}
internal class DocumentFormat.OpenXml.Validation.ValidationCache : object {
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private ConcurrentDictionary`2<ParticleConstraint, ParticleConstraint> _constraints;
    [CompilerGeneratedAttribute]
private FileFormatVersions <Version>k__BackingField;
    public FileFormatVersions Version { get; }
    public ValidationCache(FileFormatVersions version);
    [CompilerGeneratedAttribute]
public FileFormatVersions get_Version();
    [NullableContextAttribute("1")]
public ParticleConstraint GetConstraint(OpenXmlElement element);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class DocumentFormat.OpenXml.Validation.ValidationContext : object {
    private CancellationToken _token;
    [CompilerGeneratedAttribute]
private ValidationCache <Cache>k__BackingField;
    [CompilerGeneratedAttribute]
private ValidationSettings <Settings>k__BackingField;
    [CompilerGeneratedAttribute]
private List`1<ValidationErrorInfo> <Errors>k__BackingField;
    [CompilerGeneratedAttribute]
private StateManager <State>k__BackingField;
    [CompilerGeneratedAttribute]
private MCContext <McContext>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <CollectExpectedChildren>k__BackingField;
    [CompilerGeneratedAttribute]
private ValidationStack <Stack>k__BackingField;
    public ValidationCache Cache { get; }
    public ValidationSettings Settings { get; }
    public List`1<ValidationErrorInfo> Errors { get; }
    public FileFormatVersions FileFormat { get; }
    public bool Valid { get; }
    public StateManager State { get; }
    internal MCContext McContext { get; }
    internal bool CollectExpectedChildren { get; internal set; }
    public int MaxNumberOfErrors { get; }
    public ValidationStack Stack { get; }
    public ValidationContext(IOpenXmlNamespaceResolver resolver, FileFormatVersions version);
    public ValidationContext(IOpenXmlNamespaceResolver resolver, ValidationSettings settings, ValidationCache cache, CancellationToken token);
    [CompilerGeneratedAttribute]
public ValidationCache get_Cache();
    [CompilerGeneratedAttribute]
public ValidationSettings get_Settings();
    [CompilerGeneratedAttribute]
public List`1<ValidationErrorInfo> get_Errors();
    public FileFormatVersions get_FileFormat();
    public bool get_Valid();
    public bool CheckIfCancelled();
    public void Clear();
    [CompilerGeneratedAttribute]
public StateManager get_State();
    [CompilerGeneratedAttribute]
internal MCContext get_McContext();
    [CompilerGeneratedAttribute]
internal bool get_CollectExpectedChildren();
    [CompilerGeneratedAttribute]
internal void set_CollectExpectedChildren(bool value);
    [NullableContextAttribute("2")]
internal OpenXmlElement GetFirstChildMc();
    [NullableContextAttribute("2")]
internal OpenXmlElement GetNextChildMc(OpenXmlElement child);
    public int get_MaxNumberOfErrors();
    [CompilerGeneratedAttribute]
public ValidationStack get_Stack();
    [NullableContextAttribute("2")]
public ParticleConstraint GetParticleConstraint();
    public void AddError(ValidationErrorInfo error);
    public void CreateError(string id, ValidationErrorType errorType, string description);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
internal class DocumentFormat.OpenXml.Validation.ValidationElement : object {
    [CompilerGeneratedAttribute]
private OpenXmlPackage <Package>k__BackingField;
    [CompilerGeneratedAttribute]
private OpenXmlPart <Part>k__BackingField;
    [CompilerGeneratedAttribute]
private OpenXmlElement <Element>k__BackingField;
    [CompilerGeneratedAttribute]
private OpenXmlSimpleType <Value>k__BackingField;
    [CompilerGeneratedAttribute]
private AttributeMetadata <Property>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsAttribute>k__BackingField;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private Action`1<ValidationErrorInfo> <AddError>k__BackingField;
    public OpenXmlPackage Package { get; internal set; }
    public OpenXmlPart Part { get; internal set; }
    public OpenXmlElement Element { get; internal set; }
    public OpenXmlSimpleType Value { get; internal set; }
    public AttributeMetadata Property { get; internal set; }
    public bool IsAttribute { get; internal set; }
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public Action`1<ValidationErrorInfo> AddError { get; internal set; }
    [CompilerGeneratedAttribute]
public OpenXmlPackage get_Package();
    [CompilerGeneratedAttribute]
internal void set_Package(OpenXmlPackage value);
    [CompilerGeneratedAttribute]
public OpenXmlPart get_Part();
    [CompilerGeneratedAttribute]
internal void set_Part(OpenXmlPart value);
    [CompilerGeneratedAttribute]
public OpenXmlElement get_Element();
    [CompilerGeneratedAttribute]
internal void set_Element(OpenXmlElement value);
    [CompilerGeneratedAttribute]
public OpenXmlSimpleType get_Value();
    [CompilerGeneratedAttribute]
internal void set_Value(OpenXmlSimpleType value);
    [CompilerGeneratedAttribute]
public AttributeMetadata get_Property();
    [CompilerGeneratedAttribute]
internal void set_Property(AttributeMetadata value);
    [CompilerGeneratedAttribute]
public bool get_IsAttribute();
    [CompilerGeneratedAttribute]
internal void set_IsAttribute(bool value);
    [CompilerGeneratedAttribute]
public Action`1<ValidationErrorInfo> get_AddError();
    [CompilerGeneratedAttribute]
internal void set_AddError(Action`1<ValidationErrorInfo> value);
    internal void Clear();
    internal void CopyFrom(ValidationElement current);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class DocumentFormat.OpenXml.Validation.ValidationErrorEventArgs : EventArgs {
    [CompilerGeneratedAttribute]
private ValidationErrorInfo <ValidationErrorInfo>k__BackingField;
    internal ValidationErrorInfo ValidationErrorInfo { get; internal set; }
    internal ValidationErrorEventArgs(ValidationErrorInfo validatoinError);
    [CompilerGeneratedAttribute]
internal ValidationErrorInfo get_ValidationErrorInfo();
    [CompilerGeneratedAttribute]
internal void set_ValidationErrorInfo(ValidationErrorInfo value);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
[DebuggerDisplayAttribute("Description={Description}")]
public class DocumentFormat.OpenXml.Validation.ValidationErrorInfo : object {
    private XmlPath _xmlPath;
    private OpenXmlElement _element;
    private OpenXmlPart _part;
    [NullableAttribute("1")]
[CompilerGeneratedAttribute]
private string <Id>k__BackingField;
    [CompilerGeneratedAttribute]
private ValidationErrorType <ErrorType>k__BackingField;
    [NullableAttribute("1")]
[CompilerGeneratedAttribute]
private string <Description>k__BackingField;
    [CompilerGeneratedAttribute]
private OpenXmlElement <RelatedNode>k__BackingField;
    [CompilerGeneratedAttribute]
private OpenXmlPart <RelatedPart>k__BackingField;
    [NullableAttribute("1")]
public string Id { get; internal set; }
    public ValidationErrorType ErrorType { get; internal set; }
    [NullableAttribute("1")]
public string Description { get; internal set; }
    public XmlPath Path { get; }
    public OpenXmlElement Node { get; internal set; }
    public OpenXmlPart Part { get; internal set; }
    public OpenXmlElement RelatedNode { get; internal set; }
    public OpenXmlPart RelatedPart { get; internal set; }
    [NullableContextAttribute("1")]
[CompilerGeneratedAttribute]
public string get_Id();
    [NullableContextAttribute("1")]
[CompilerGeneratedAttribute]
internal void set_Id(string value);
    [CompilerGeneratedAttribute]
public ValidationErrorType get_ErrorType();
    [CompilerGeneratedAttribute]
internal void set_ErrorType(ValidationErrorType value);
    [NullableContextAttribute("1")]
[CompilerGeneratedAttribute]
public string get_Description();
    [NullableContextAttribute("1")]
[CompilerGeneratedAttribute]
internal void set_Description(string value);
    public XmlPath get_Path();
    public OpenXmlElement get_Node();
    internal void set_Node(OpenXmlElement value);
    public OpenXmlPart get_Part();
    internal void set_Part(OpenXmlPart value);
    [CompilerGeneratedAttribute]
public OpenXmlElement get_RelatedNode();
    [CompilerGeneratedAttribute]
internal void set_RelatedNode(OpenXmlElement value);
    [CompilerGeneratedAttribute]
public OpenXmlPart get_RelatedPart();
    [CompilerGeneratedAttribute]
internal void set_RelatedPart(OpenXmlPart value);
}
public enum DocumentFormat.OpenXml.Validation.ValidationErrorType : Enum {
    public int value__;
    public static ValidationErrorType Schema;
    public static ValidationErrorType Semantic;
    public static ValidationErrorType Package;
    public static ValidationErrorType MarkupCompatibility;
}
[GeneratedCodeAttribute("System.Resources.Tools.StronglyTypedResourceBuilder", "17.0.0.0")]
[DebuggerNonUserCodeAttribute]
[CompilerGeneratedAttribute]
internal class DocumentFormat.OpenXml.Validation.ValidationResources : object {
    private static ResourceManager resourceMan;
    private static CultureInfo resourceCulture;
    [EditorBrowsableAttribute("2")]
internal static ResourceManager ResourceManager { get; }
    [EditorBrowsableAttribute("2")]
internal static CultureInfo Culture { get; internal set; }
    internal static string ExceptionError { get; }
    internal static string Fmt_AnyElementInNamespace { get; }
    internal static string Fmt_ElementName { get; }
    internal static string Fmt_ElementNameSeparator { get; }
    internal static string Fmt_ListOfPossibleElements { get; }
    internal static string MC_ErrorOnUnprefixedAttributeName { get; }
    internal static string MC_InvalidIgnorableAttribute { get; }
    internal static string MC_InvalidMustUnderstandAttribute { get; }
    internal static string MC_InvalidPreserveAttributesAttribute { get; }
    internal static string MC_InvalidPreserveElementsAttribute { get; }
    internal static string MC_InvalidProcessContentAttribute { get; }
    internal static string MC_InvalidRequiresAttribute { get; }
    internal static string MC_InvalidXmlAttribute { get; }
    internal static string MC_InvalidXmlAttributeWithProcessContent { get; }
    internal static string MC_MissedRequiresAttribute { get; }
    internal static string MC_ShallContainChoice { get; }
    internal static string MC_ShallNotContainAlternateContent { get; }
    internal static string MoreThanOnePartForOneUri { get; }
    internal static string Pkg_DataPartReferenceIsNotAllowed { get; }
    internal static string Pkg_ExtendedPartIsOpenXmlPart { get; }
    internal static string Pkg_OnlyOnePartAllowed { get; }
    internal static string Pkg_PartIsNotAllowed { get; }
    internal static string Pkg_RequiredPartDoNotExist { get; }
    internal static string Sch_AllElement { get; }
    internal static string Sch_AttributeUnionFailedEx { get; }
    internal static string Sch_AttributeValueDataTypeDetailed { get; }
    internal static string Sch_ElementUnionFailedEx { get; }
    internal static string Sch_ElementValueDataTypeDetailed { get; }
    internal static string Sch_EmptyAttributeValue { get; }
    internal static string Sch_EmptyElementValue { get; }
    internal static string Sch_EnumerationConstraintFailed { get; }
    internal static string Sch_IncompleteContentExpectingComplex { get; }
    internal static string Sch_InvalidChildinLeafElement { get; }
    internal static string Sch_InvalidElementContentExpectingComplex { get; }
    internal static string Sch_InvalidElementContentWrongType { get; }
    internal static string Sch_LengthConstraintFailed { get; }
    internal static string Sch_MaxExclusiveConstraintFailed { get; }
    internal static string Sch_MaxInclusiveConstraintFailed { get; }
    internal static string Sch_MaxLengthConstraintFailed { get; }
    internal static string Sch_MinExclusiveConstraintFailed { get; }
    internal static string Sch_MinInclusiveConstraintFailed { get; }
    internal static string Sch_MinLengthConstraintFailed { get; }
    internal static string Sch_MissRequiredAttribute { get; }
    internal static string Sch_PatternConstraintFailed { get; }
    internal static string Sch_StringIsNotValidValue { get; }
    internal static string Sch_TotalDigitsConstraintFailed { get; }
    internal static string Sch_UndeclaredAttribute { get; }
    internal static string Sch_UnexpectedElementContentExpectingComplex { get; }
    internal static string Sem_AttributeAbsentConditionToNonValue { get; }
    internal static string Sem_AttributeAbsentConditionToValue { get; }
    internal static string Sem_AttributeMutualExclusive { get; }
    internal static string Sem_AttributeRequiredConditionToValue { get; }
    internal static string Sem_AttributeValueConditionToAnother { get; }
    internal static string Sem_AttributeValueDataTypeDetailed { get; }
    internal static string Sem_AttributeValueLessEqualToAnother { get; }
    internal static string Sem_AttributeValueLessEqualToAnotherEx { get; }
    internal static string Sem_AttributeValueUniqueInDocument { get; }
    internal static string Sem_CellValue { get; }
    internal static string Sem_IncorrectRelationshipType { get; }
    internal static string Sem_InvalidRelationshipId { get; }
    internal static string Sem_MaxLengthConstraintFailed { get; }
    internal static string Sem_MinLengthConstraintFailed { get; }
    internal static string Sem_MissingIndexedElement { get; }
    internal static string Sem_MissingReferenceElement { get; }
    internal static string Sem_UniqueAttributeValue { get; }
    internal static string TypeName_base64Binary { get; }
    internal static string TypeName_hexBinary { get; }
    internal static string TypeName_ID { get; }
    internal static string TypeName_Integer { get; }
    internal static string TypeName_language { get; }
    internal static string TypeName_NCName { get; }
    internal static string TypeName_nonNegativeInteger { get; }
    internal static string TypeName_positiveInteger { get; }
    internal static string TypeName_QName { get; }
    internal static string TypeName_token { get; }
    internal static ResourceManager get_ResourceManager();
    internal static CultureInfo get_Culture();
    internal static void set_Culture(CultureInfo value);
    internal static string get_ExceptionError();
    internal static string get_Fmt_AnyElementInNamespace();
    internal static string get_Fmt_ElementName();
    internal static string get_Fmt_ElementNameSeparator();
    internal static string get_Fmt_ListOfPossibleElements();
    internal static string get_MC_ErrorOnUnprefixedAttributeName();
    internal static string get_MC_InvalidIgnorableAttribute();
    internal static string get_MC_InvalidMustUnderstandAttribute();
    internal static string get_MC_InvalidPreserveAttributesAttribute();
    internal static string get_MC_InvalidPreserveElementsAttribute();
    internal static string get_MC_InvalidProcessContentAttribute();
    internal static string get_MC_InvalidRequiresAttribute();
    internal static string get_MC_InvalidXmlAttribute();
    internal static string get_MC_InvalidXmlAttributeWithProcessContent();
    internal static string get_MC_MissedRequiresAttribute();
    internal static string get_MC_ShallContainChoice();
    internal static string get_MC_ShallNotContainAlternateContent();
    internal static string get_MoreThanOnePartForOneUri();
    internal static string get_Pkg_DataPartReferenceIsNotAllowed();
    internal static string get_Pkg_ExtendedPartIsOpenXmlPart();
    internal static string get_Pkg_OnlyOnePartAllowed();
    internal static string get_Pkg_PartIsNotAllowed();
    internal static string get_Pkg_RequiredPartDoNotExist();
    internal static string get_Sch_AllElement();
    internal static string get_Sch_AttributeUnionFailedEx();
    internal static string get_Sch_AttributeValueDataTypeDetailed();
    internal static string get_Sch_ElementUnionFailedEx();
    internal static string get_Sch_ElementValueDataTypeDetailed();
    internal static string get_Sch_EmptyAttributeValue();
    internal static string get_Sch_EmptyElementValue();
    internal static string get_Sch_EnumerationConstraintFailed();
    internal static string get_Sch_IncompleteContentExpectingComplex();
    internal static string get_Sch_InvalidChildinLeafElement();
    internal static string get_Sch_InvalidElementContentExpectingComplex();
    internal static string get_Sch_InvalidElementContentWrongType();
    internal static string get_Sch_LengthConstraintFailed();
    internal static string get_Sch_MaxExclusiveConstraintFailed();
    internal static string get_Sch_MaxInclusiveConstraintFailed();
    internal static string get_Sch_MaxLengthConstraintFailed();
    internal static string get_Sch_MinExclusiveConstraintFailed();
    internal static string get_Sch_MinInclusiveConstraintFailed();
    internal static string get_Sch_MinLengthConstraintFailed();
    internal static string get_Sch_MissRequiredAttribute();
    internal static string get_Sch_PatternConstraintFailed();
    internal static string get_Sch_StringIsNotValidValue();
    internal static string get_Sch_TotalDigitsConstraintFailed();
    internal static string get_Sch_UndeclaredAttribute();
    internal static string get_Sch_UnexpectedElementContentExpectingComplex();
    internal static string get_Sem_AttributeAbsentConditionToNonValue();
    internal static string get_Sem_AttributeAbsentConditionToValue();
    internal static string get_Sem_AttributeMutualExclusive();
    internal static string get_Sem_AttributeRequiredConditionToValue();
    internal static string get_Sem_AttributeValueConditionToAnother();
    internal static string get_Sem_AttributeValueDataTypeDetailed();
    internal static string get_Sem_AttributeValueLessEqualToAnother();
    internal static string get_Sem_AttributeValueLessEqualToAnotherEx();
    internal static string get_Sem_AttributeValueUniqueInDocument();
    internal static string get_Sem_CellValue();
    internal static string get_Sem_IncorrectRelationshipType();
    internal static string get_Sem_InvalidRelationshipId();
    internal static string get_Sem_MaxLengthConstraintFailed();
    internal static string get_Sem_MinLengthConstraintFailed();
    internal static string get_Sem_MissingIndexedElement();
    internal static string get_Sem_MissingReferenceElement();
    internal static string get_Sem_UniqueAttributeValue();
    internal static string get_TypeName_base64Binary();
    internal static string get_TypeName_hexBinary();
    internal static string get_TypeName_ID();
    internal static string get_TypeName_Integer();
    internal static string get_TypeName_language();
    internal static string get_TypeName_NCName();
    internal static string get_TypeName_nonNegativeInteger();
    internal static string get_TypeName_positiveInteger();
    internal static string get_TypeName_QName();
    internal static string get_TypeName_token();
}
internal class DocumentFormat.OpenXml.Validation.ValidationSettings : object {
    private static int _defaultMaxNumberOfErrorsReturned;
    [CompilerGeneratedAttribute]
private FileFormatVersions <FileFormat>k__BackingField;
    [CompilerGeneratedAttribute]
private int <MaxNumberOfErrors>k__BackingField;
    public FileFormatVersions FileFormat { get; }
    public int MaxNumberOfErrors { get; public set; }
    public ValidationSettings(FileFormatVersions fileFormat);
    [CompilerGeneratedAttribute]
public FileFormatVersions get_FileFormat();
    [CompilerGeneratedAttribute]
public int get_MaxNumberOfErrors();
    [CompilerGeneratedAttribute]
public void set_MaxNumberOfErrors(int value);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class DocumentFormat.OpenXml.Validation.ValidationStack : object {
    private ValidationContextDisposable _popDisposable;
    private Stack`1<ValidationElement> _elements;
    private Stack`1<ValidationElement> _available;
    [NullableAttribute("2")]
public ValidationElement Current { get; }
    [NullableContextAttribute("2")]
public ValidationElement get_Current();
    [NullableContextAttribute("2")]
public IDisposable Push(OpenXmlPackage package, OpenXmlPart part, OpenXmlElement element);
    public IDisposable Push(OpenXmlSimpleType value);
    public IDisposable Push(OpenXmlSimpleType value, AttributeMetadata property, bool isAttribute);
    public IDisposable Push(Action`1<ValidationErrorInfo> addError);
    private ValidationElement GetOrCreateElement();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
internal static class DocumentFormat.OpenXml.Validation.ValidationTraverser : object {
    [ExtensionAttribute]
public static IEnumerable`1<OpenXmlElement> Descendants(OpenXmlElement element, FileFormatVersions version, TraversalOptions options);
    internal static void ValidatingTraverse(ValidationContext validationContext, Action`1<ValidationContext> validateAction);
    private static IEnumerable`1<OpenXmlElement> ValidatingTraverse(OpenXmlElement inElement, MCContext mcContext, FileFormatVersions version);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[DefaultMemberAttribute("Item")]
internal class DocumentFormat.OpenXml.XmlConvertingReader : XmlReader {
    private IOpenXmlNamespaceResolver _resolver;
    [CompilerGeneratedAttribute]
private XmlReader <BaseReader>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <StrictRelationshipFound>k__BackingField;
    protected XmlReader BaseReader { get; }
    public bool StrictRelationshipFound { get; }
    public int AttributeCount { get; }
    public string BaseURI { get; }
    public bool CanReadBinaryContent { get; }
    public bool CanReadValueChunk { get; }
    public bool CanResolveEntity { get; }
    public int Depth { get; }
    public bool EOF { get; }
    public bool HasValue { get; }
    public bool IsDefault { get; }
    public bool IsEmptyElement { get; }
    public string Item { get; }
    [NullableAttribute("2")]
public string Item { get; }
    [NullableAttribute("2")]
public string Item { get; }
    public string LocalName { get; }
    public string Name { get; }
    public string NamespaceURI { get; }
    public XmlNameTable NameTable { get; }
    public XmlNodeType NodeType { get; }
    public string Prefix { get; }
    public char QuoteChar { get; }
    public ReadState ReadState { get; }
    public string Value { get; }
    public string XmlLang { get; }
    public XmlSpace XmlSpace { get; }
    private int System.Xml.IXmlLineInfo.LineNumber { get; }
    private int System.Xml.IXmlLineInfo.LinePosition { get; }
    public XmlConvertingReader(XmlReader baseReader, IOpenXmlNamespaceResolver resolver, bool strictRelationshipFound);
    [CompilerGeneratedAttribute]
protected XmlReader get_BaseReader();
    [CompilerGeneratedAttribute]
public bool get_StrictRelationshipFound();
    public virtual void Close();
    protected virtual void Dispose(bool disposing);
    public virtual bool Read();
    public virtual string GetAttribute(int index);
    public virtual string GetAttribute(string name);
    [NullableContextAttribute("2")]
public virtual string GetAttribute(string localName, string namespaceURI);
    public virtual string LookupNamespace(string prefix);
    public virtual void MoveToAttribute(int index);
    public virtual bool MoveToAttribute(string name);
    public virtual bool MoveToAttribute(string localName, string namespaceURI);
    public virtual bool MoveToElement();
    public virtual bool MoveToFirstAttribute();
    public virtual bool MoveToNextAttribute();
    public virtual bool ReadAttributeValue();
    public virtual void ResolveEntity();
    public virtual int ReadValueChunk(Char[] buffer, int index, int count);
    public virtual int get_AttributeCount();
    public virtual string get_BaseURI();
    public virtual bool get_CanReadBinaryContent();
    public virtual bool get_CanReadValueChunk();
    public virtual bool get_CanResolveEntity();
    public virtual int get_Depth();
    public virtual bool get_EOF();
    public virtual bool get_HasValue();
    public virtual bool get_IsDefault();
    public virtual bool get_IsEmptyElement();
    public virtual string get_Item(int index);
    public virtual string get_Item(string name);
    [NullableContextAttribute("2")]
public virtual string get_Item(string name, string namespaceURI);
    public virtual string get_LocalName();
    public virtual string get_Name();
    public virtual string get_NamespaceURI();
    public virtual XmlNameTable get_NameTable();
    public virtual XmlNodeType get_NodeType();
    public virtual string get_Prefix();
    public virtual char get_QuoteChar();
    public virtual ReadState get_ReadState();
    public virtual string get_Value();
    public virtual string get_XmlLang();
    public virtual XmlSpace get_XmlSpace();
    private sealed virtual override int System.Xml.IXmlLineInfo.get_LineNumber();
    private sealed virtual override int System.Xml.IXmlLineInfo.get_LinePosition();
    private sealed virtual override bool System.Xml.IXmlLineInfo.HasLineInfo();
    private string ApplyStrictTranslation(OpenXmlNamespace ns);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal static class DocumentFormat.OpenXml.XmlConvertingReaderFactory : object {
    public static XmlReader Create(Stream partStream, IOpenXmlNamespaceResolver resolver, XmlReaderSettings settings);
    public static XmlReader Create(Stream partStream, IOpenXmlNamespaceResolver resolver, XmlReaderSettings settings, bool strictRelationshipFound);
    public static XmlReader Create(TextReader textReader, IOpenXmlNamespaceResolver resolver, XmlReaderSettings settings);
    public static XmlReader Create(TextReader textReader, IOpenXmlNamespaceResolver resolver);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
internal class DocumentFormat.OpenXml.XmlDOMTextWriter : XmlWriter {
    [NullableAttribute("1")]
private XmlWriter _writer;
    public WriteState WriteState { get; }
    public XmlWriterSettings Settings { get; }
    public string XmlLang { get; }
    public XmlSpace XmlSpace { get; }
    [NullableContextAttribute("1")]
public XmlDOMTextWriter(TextWriter w);
    public virtual WriteState get_WriteState();
    public virtual void Flush();
    [NullableContextAttribute("1")]
public virtual string LookupPrefix(string ns);
    [NullableContextAttribute("1")]
public virtual void WriteBase64(Byte[] buffer, int index, int count);
    public virtual void WriteCData(string text);
    public virtual void WriteCharEntity(char ch);
    [NullableContextAttribute("1")]
public virtual void WriteChars(Char[] buffer, int index, int count);
    public virtual void WriteComment(string text);
    public virtual void WriteDocType(string name, string pubid, string sysid, string subset);
    public virtual void WriteEndAttribute();
    public virtual void WriteEndDocument();
    public virtual void WriteEndElement();
    [NullableContextAttribute("1")]
public virtual void WriteEntityRef(string name);
    public virtual void WriteFullEndElement();
    [NullableContextAttribute("1")]
public virtual void WriteProcessingInstruction(string name, string text);
    [NullableContextAttribute("1")]
public virtual void WriteRaw(string data);
    [NullableContextAttribute("1")]
public virtual void WriteRaw(Char[] buffer, int index, int count);
    public virtual void WriteStartAttribute(string prefix, string localName, string ns);
    public virtual void WriteStartDocument();
    public virtual void WriteStartDocument(bool standalone);
    public virtual void WriteStartElement(string prefix, string localName, string ns);
    public virtual void WriteString(string text);
    public virtual void WriteSurrogateCharEntity(char lowChar, char highChar);
    public virtual void WriteWhitespace(string ws);
    public virtual XmlWriterSettings get_Settings();
    public virtual string get_XmlLang();
    public virtual XmlSpace get_XmlSpace();
    public virtual void Close();
    protected virtual void Dispose(bool disposing);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class DocumentFormat.OpenXml.XmlLineInfo : object {
    [CompilerGeneratedAttribute]
private static IXmlLineInfo <Empty>k__BackingField;
    public static IXmlLineInfo Empty { get; }
    public int LineNumber { get; }
    public int LinePosition { get; }
    private static XmlLineInfo();
    [CompilerGeneratedAttribute]
public static IXmlLineInfo get_Empty();
    public static IXmlLineInfo Get(object obj);
    public sealed virtual int get_LineNumber();
    public sealed virtual int get_LinePosition();
    public sealed virtual bool HasLineInfo();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[DebuggerDisplayAttribute("{XPath,nq}")]
public class DocumentFormat.OpenXml.XmlPath : object {
    [CompilerGeneratedAttribute]
private IXmlNamespaceResolver <Namespaces>k__BackingField;
    [CompilerGeneratedAttribute]
private string <XPath>k__BackingField;
    [NullableAttribute("2")]
[CompilerGeneratedAttribute]
private Uri <PartUri>k__BackingField;
    public IXmlNamespaceResolver Namespaces { get; }
    public string XPath { get; }
    [NullableAttribute("2")]
public Uri PartUri { get; }
    public XmlPath(OpenXmlElement element);
    public XmlPath(OpenXmlPart part);
    [CompilerGeneratedAttribute]
public IXmlNamespaceResolver get_Namespaces();
    [CompilerGeneratedAttribute]
public string get_XPath();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public Uri get_PartUri();
    [NullableContextAttribute("2")]
internal static XmlPath GetXPath(OpenXmlElement element);
    [NullableContextAttribute("2")]
internal static XmlPath GetXPath(OpenXmlPart part);
    private static string TryBuildXPath(Stack`1<OpenXmlElement> elements, XmlNamespaceManager& namespaces);
    private static Stack`1<OpenXmlElement> GetElements(OpenXmlElement element);
}
[CompilerGeneratedAttribute]
[EmbeddedAttribute]
internal class Microsoft.CodeAnalysis.EmbeddedAttribute : Attribute {
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class System.Collections.Concurrent.ConcurrentDictionary`2 : object {
    private Dictionary`2<TKey, TValue> _dictionary;
    public ConcurrentDictionary`2(IEnumerable`1<KeyValuePair`2<TKey, TValue>> values);
    public TValue GetOrAdd(TKey type, Func`2<TKey, TValue> create);
    public bool TryGetValue(TKey key, TValue& value);
    public void TryAdd(TKey key, TValue value);
}
[AttributeUsageAttribute("2432")]
internal class System.Diagnostics.CodeAnalysis.AllowNullAttribute : Attribute {
}
[AttributeUsageAttribute("2432")]
internal class System.Diagnostics.CodeAnalysis.DisallowNullAttribute : Attribute {
}
[AttributeUsageAttribute("64")]
internal class System.Diagnostics.CodeAnalysis.DoesNotReturnAttribute : Attribute {
}
[AttributeUsageAttribute("2048")]
internal class System.Diagnostics.CodeAnalysis.DoesNotReturnIfAttribute : Attribute {
    [CompilerGeneratedAttribute]
private bool <ParameterValue>k__BackingField;
    public bool ParameterValue { get; }
    public DoesNotReturnIfAttribute(bool parameterValue);
    [CompilerGeneratedAttribute]
public bool get_ParameterValue();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[AttributeUsageAttribute("6143")]
internal class System.Diagnostics.CodeAnalysis.ExperimentalAttribute : Attribute {
    [CompilerGeneratedAttribute]
private string <DiagnosticId>k__BackingField;
    [NullableAttribute("2")]
[CompilerGeneratedAttribute]
private string <UrlFormat>k__BackingField;
    public string DiagnosticId { get; }
    [NullableAttribute("2")]
public string UrlFormat { get; public set; }
    public ExperimentalAttribute(string diagnosticId);
    [CompilerGeneratedAttribute]
public string get_DiagnosticId();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public string get_UrlFormat();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public void set_UrlFormat(string value);
}
[AttributeUsageAttribute("10624")]
internal class System.Diagnostics.CodeAnalysis.MaybeNullAttribute : Attribute {
}
[AttributeUsageAttribute("2048")]
internal class System.Diagnostics.CodeAnalysis.MaybeNullWhenAttribute : Attribute {
    [CompilerGeneratedAttribute]
private bool <ReturnValue>k__BackingField;
    public bool ReturnValue { get; }
    public MaybeNullWhenAttribute(bool returnValue);
    [CompilerGeneratedAttribute]
public bool get_ReturnValue();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[AttributeUsageAttribute("192")]
internal class System.Diagnostics.CodeAnalysis.MemberNotNullAttribute : Attribute {
    [CompilerGeneratedAttribute]
private String[] <Members>k__BackingField;
    public String[] Members { get; }
    public MemberNotNullAttribute(string member);
    public MemberNotNullAttribute(String[] members);
    [CompilerGeneratedAttribute]
public String[] get_Members();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[AttributeUsageAttribute("192")]
internal class System.Diagnostics.CodeAnalysis.MemberNotNullWhenAttribute : Attribute {
    [CompilerGeneratedAttribute]
private bool <ReturnValue>k__BackingField;
    [CompilerGeneratedAttribute]
private String[] <Members>k__BackingField;
    public bool ReturnValue { get; }
    public String[] Members { get; }
    public MemberNotNullWhenAttribute(bool returnValue, string member);
    public MemberNotNullWhenAttribute(bool returnValue, String[] members);
    [CompilerGeneratedAttribute]
public bool get_ReturnValue();
    [CompilerGeneratedAttribute]
public String[] get_Members();
}
[AttributeUsageAttribute("10624")]
internal class System.Diagnostics.CodeAnalysis.NotNullAttribute : Attribute {
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[AttributeUsageAttribute("10368")]
internal class System.Diagnostics.CodeAnalysis.NotNullIfNotNullAttribute : Attribute {
    [CompilerGeneratedAttribute]
private string <ParameterName>k__BackingField;
    public string ParameterName { get; }
    public NotNullIfNotNullAttribute(string parameterName);
    [CompilerGeneratedAttribute]
public string get_ParameterName();
}
[AttributeUsageAttribute("2048")]
internal class System.Diagnostics.CodeAnalysis.NotNullWhenAttribute : Attribute {
    [CompilerGeneratedAttribute]
private bool <ReturnValue>k__BackingField;
    public bool ReturnValue { get; }
    public NotNullWhenAttribute(bool returnValue);
    [CompilerGeneratedAttribute]
public bool get_ReturnValue();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class System.FormattableString : object {
    private string _format;
    private Object[] _arguments;
    public FormattableString(string format, Object[] arguments);
    private sealed virtual override string System.IFormattable.ToString(string format, IFormatProvider formatProvider);
    public string ToString(IFormatProvider formatProvider);
    public static string Invariant(FormattableString formattable);
    public virtual string ToString();
}
[ExtensionAttribute]
internal static class System.IO.StreamReadExtensions : object {
    [NullableContextAttribute("1")]
[ExtensionAttribute]
public static void ReadExactly(Stream source, Byte[] destination);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
[AttributeUsageAttribute("6140")]
internal class System.ObsoleteAttribute : Attribute {
    [CompilerGeneratedAttribute]
private string <Message>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsError>k__BackingField;
    [CompilerGeneratedAttribute]
private string <DiagnosticId>k__BackingField;
    [CompilerGeneratedAttribute]
private string <UrlFormat>k__BackingField;
    public string Message { get; }
    public bool IsError { get; }
    public string DiagnosticId { get; public set; }
    public string UrlFormat { get; public set; }
    public ObsoleteAttribute(string message);
    public ObsoleteAttribute(string message, bool error);
    [CompilerGeneratedAttribute]
public string get_Message();
    [CompilerGeneratedAttribute]
public bool get_IsError();
    [CompilerGeneratedAttribute]
public string get_DiagnosticId();
    [CompilerGeneratedAttribute]
public void set_DiagnosticId(string value);
    [CompilerGeneratedAttribute]
public string get_UrlFormat();
    [CompilerGeneratedAttribute]
public void set_UrlFormat(string value);
}
[AttributeUsageAttribute("2048")]
internal class System.Runtime.CompilerServices.CallerMemberNameAttribute : Attribute {
}
internal static class System.Runtime.CompilerServices.FormattableStringFactory : object {
    [NullableContextAttribute("1")]
public static FormattableString Create(string format, Object[] arguments);
}
[CompilerGeneratedAttribute]
[EmbeddedAttribute]
internal class System.Runtime.CompilerServices.IsByRefLikeAttribute : Attribute {
}
[CompilerGeneratedAttribute]
[EmbeddedAttribute]
internal class System.Runtime.CompilerServices.IsReadOnlyAttribute : Attribute {
}
[CompilerGeneratedAttribute]
[EmbeddedAttribute]
[AttributeUsageAttribute("27524")]
internal class System.Runtime.CompilerServices.NullableAttribute : Attribute {
    public Byte[] NullableFlags;
    public NullableAttribute(byte );
    public NullableAttribute(Byte[] );
}
[CompilerGeneratedAttribute]
[EmbeddedAttribute]
[AttributeUsageAttribute("5196")]
internal class System.Runtime.CompilerServices.NullableContextAttribute : Attribute {
    public byte Flag;
    public NullableContextAttribute(byte );
}
[CompilerGeneratedAttribute]
[EmbeddedAttribute]
[AttributeUsageAttribute("2")]
internal class System.Runtime.CompilerServices.RefSafetyRulesAttribute : Attribute {
    public int Version;
    public RefSafetyRulesAttribute(int );
}
[IsReadOnlyAttribute]
internal class System.Threading.CancellationToken : ValueType {
    public void ThrowIfCancellationRequested();
}
[ExtensionAttribute]
internal static class System.Xml.Linq.XDocumentExtensions : object {
    [NullableContextAttribute("1")]
[ExtensionAttribute]
public static void Save(XDocument doc, Stream stream);
}
