public class DotLiquid.ActivatorTagFactory : object {
    private Type _tagType;
    private string _tagName;
    public string TagName { get; }
    public ActivatorTagFactory(Type tagType, string tagName);
    public sealed virtual string get_TagName();
    public sealed virtual Tag Create();
}
public class DotLiquid.Block : Tag {
    private static Regex IsTag;
    private static Regex IsVariable;
    private static Regex ContentOfVariable;
    internal static Regex FullToken;
    protected string BlockDelimiter { get; }
    private string BlockName { get; }
    private static Block();
    protected virtual void Parse(List`1<string> tokens);
    public virtual void EndTag();
    public virtual void UnknownTag(string tag, string markup, List`1<string> tokens);
    protected virtual string get_BlockDelimiter();
    private string get_BlockName();
    public Variable CreateVariable(string token);
    public virtual void Render(Context context, TextWriter result);
    protected virtual void AssertMissingDelimitation();
    protected void RenderAll(List`1<object> list, Context context, TextWriter result);
}
public class DotLiquid.Condition : object {
    public static Dictionary`2<string, ConditionOperatorDelegate> Operators;
    private string _childRelation;
    private Condition _childCondition;
    [CompilerGeneratedAttribute]
private string <Left>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Operator>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Right>k__BackingField;
    [CompilerGeneratedAttribute]
private List`1<object> <Attachment>k__BackingField;
    public string Left { get; public set; }
    public string Operator { get; public set; }
    public string Right { get; public set; }
    public List`1<object> Attachment { get; private set; }
    public bool IsElse { get; }
    public Condition(string left, string operator, string right);
    private static Condition();
    private static bool Any(IEnumerable enumerable, Func`2<object, bool> condition);
    [CompilerGeneratedAttribute]
public string get_Left();
    [CompilerGeneratedAttribute]
public void set_Left(string value);
    [CompilerGeneratedAttribute]
public string get_Operator();
    [CompilerGeneratedAttribute]
public void set_Operator(string value);
    [CompilerGeneratedAttribute]
public string get_Right();
    [CompilerGeneratedAttribute]
public void set_Right(string value);
    [CompilerGeneratedAttribute]
public List`1<object> get_Attachment();
    [CompilerGeneratedAttribute]
private void set_Attachment(List`1<object> value);
    public virtual bool get_IsElse();
    public virtual bool Evaluate(Context context, IFormatProvider formatProvider);
    public void Or(Condition condition);
    public void And(Condition condition);
    public List`1<object> Attach(List`1<object> attachment);
    public virtual string ToString();
    private static bool EqualVariables(object left, object right);
    private static bool InterpretCondition(string left, string right, string op, Context context);
}
public class DotLiquid.ConditionOperatorDelegate : MulticastDelegate {
    public ConditionOperatorDelegate(object object, IntPtr method);
    public virtual bool Invoke(object left, object right);
    public virtual IAsyncResult BeginInvoke(object left, object right, AsyncCallback callback, object object);
    public virtual bool EndInvoke(IAsyncResult result);
}
[DefaultMemberAttribute("Item")]
public class DotLiquid.Context : object {
    private static HashSet`1<char> SpecialCharsSet;
    private static Regex SingleQuotedRegex;
    private static Regex DoubleQuotedRegex;
    private static Regex IntegerRegex;
    private static Regex RangeRegex;
    private static Regex NumericRegex;
    private static Regex VariableParserRegex;
    private ErrorsOutputMode _errorsOutputMode;
    [CompilerGeneratedAttribute]
private SyntaxCompatibility <SyntaxCompatibilityLevel>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <UseRubyDateFormat>k__BackingField;
    private int _maxIterations;
    private Strainer _strainer;
    [CompilerGeneratedAttribute]
private List`1<Hash> <Environments>k__BackingField;
    [CompilerGeneratedAttribute]
private List`1<Hash> <Scopes>k__BackingField;
    [CompilerGeneratedAttribute]
private Hash <Registers>k__BackingField;
    [CompilerGeneratedAttribute]
private List`1<Exception> <Errors>k__BackingField;
    [CompilerGeneratedAttribute]
private IFormatProvider <FormatProvider>k__BackingField;
    private int _timeout;
    private Stopwatch _stopwatch;
    private CancellationToken _cancellationToken;
    public SyntaxCompatibility SyntaxCompatibilityLevel { get; public set; }
    public bool UseRubyDateFormat { get; public set; }
    public CultureInfo CurrentCulture { get; public set; }
    public int MaxIterations { get; }
    public List`1<Hash> Environments { get; private set; }
    public List`1<Hash> Scopes { get; private set; }
    public Hash Registers { get; private set; }
    public List`1<Exception> Errors { get; private set; }
    public Strainer Strainer { get; }
    public object Item { get; public set; }
    public IFormatProvider FormatProvider { get; private set; }
    [ObsoleteAttribute("The method with timeout argument is deprecated. Please use the one with CancellationToken.")]
public Context(List`1<Hash> environments, Hash outerScope, Hash registers, ErrorsOutputMode errorsOutputMode, int maxIterations, int timeout, IFormatProvider formatProvider);
    public Context(List`1<Hash> environments, Hash outerScope, Hash registers, ErrorsOutputMode errorsOutputMode, int maxIterations, IFormatProvider formatProvider, CancellationToken cancellationToken);
    public Context(IFormatProvider formatProvider);
    private static Context();
    [CompilerGeneratedAttribute]
public SyntaxCompatibility get_SyntaxCompatibilityLevel();
    [CompilerGeneratedAttribute]
public void set_SyntaxCompatibilityLevel(SyntaxCompatibility value);
    [CompilerGeneratedAttribute]
public bool get_UseRubyDateFormat();
    [CompilerGeneratedAttribute]
public void set_UseRubyDateFormat(bool value);
    public CultureInfo get_CurrentCulture();
    public void set_CurrentCulture(CultureInfo value);
    public int get_MaxIterations();
    [CompilerGeneratedAttribute]
public List`1<Hash> get_Environments();
    [CompilerGeneratedAttribute]
private void set_Environments(List`1<Hash> value);
    [CompilerGeneratedAttribute]
public List`1<Hash> get_Scopes();
    [CompilerGeneratedAttribute]
private void set_Scopes(List`1<Hash> value);
    [CompilerGeneratedAttribute]
public Hash get_Registers();
    [CompilerGeneratedAttribute]
private void set_Registers(Hash value);
    [CompilerGeneratedAttribute]
public List`1<Exception> get_Errors();
    [CompilerGeneratedAttribute]
private void set_Errors(List`1<Exception> value);
    public Strainer get_Strainer();
    public void AddFilter(string filterName, Func`2<TIn, TOut> func);
    public void AddFilter(string filterName, Func`3<TIn, TIn2, TOut> func);
    public void AddFilters(IEnumerable`1<Type> filters);
    public void AddFilters(Type[] filters);
    public string HandleError(Exception ex);
    public object Invoke(string method, List`1<object> args);
    public void Push(Hash newScope);
    public void Merge(Hash newScopes);
    public Hash Pop();
    public void Stack(Hash newScope, Action callback);
    public void Stack(Action callback);
    public void ClearInstanceAssigns();
    public object get_Item(string key, bool notifyNotFound);
    public void set_Item(string key, bool notifyNotFound, object value);
    public bool HasKey(string key);
    private object Resolve(string key, bool notifyNotFound);
    [CompilerGeneratedAttribute]
public IFormatProvider get_FormatProvider();
    [CompilerGeneratedAttribute]
private void set_FormatProvider(IFormatProvider value);
    private bool TryFindVariable(string key, Object& variable);
    private object Variable(string markup, bool notifyNotFound);
    private bool TryGetVariable(IEnumerator`1<string> partsEnumerator, Object& variable);
    private bool TryEvaluateHashOrArrayLikeObject(object obj, object key, Object& value);
    private static object Liquidize(object obj);
    private static bool IsKeyValuePair(object obj);
    private void SquashInstanceAssignsWithEnvironments();
    public void RestartTimeout();
    public void CheckTimeout();
}
public class DotLiquid.Document : Block {
    protected string BlockDelimiter { get; }
    public virtual void Initialize(string tagName, string markup, List`1<string> tokens);
    protected virtual string get_BlockDelimiter();
    protected virtual void AssertMissingDelimitation();
    public virtual void Render(Context context, TextWriter result);
}
public abstract class DotLiquid.Drop : DropBase {
    internal virtual object GetObject();
    internal virtual TypeResolution CreateTypeResolution(Type type);
}
[DefaultMemberAttribute("Item")]
public abstract class DotLiquid.DropBase : object {
    [CompilerGeneratedAttribute]
private Context <Context>k__BackingField;
    internal TypeResolution TypeResolution { get; }
    public Context Context { get; public set; }
    public object Item { get; }
    internal TypeResolution get_TypeResolution();
    [CompilerGeneratedAttribute]
public Context get_Context();
    [CompilerGeneratedAttribute]
public sealed virtual void set_Context(Context value);
    public virtual object get_Item(object method);
    public virtual bool ContainsKey(object name);
    public virtual object ToLiquid();
    internal abstract virtual object GetObject();
    internal abstract virtual TypeResolution CreateTypeResolution(Type type);
    public virtual object BeforeMethod(string method);
    public object InvokeDrop(object name);
}
public class DotLiquid.DropProxy : DropBase {
    private String[] _allowedMembers;
    private object _proxiedObject;
    private Func`2<object, object> _value;
    private bool _allowAllMembers;
    public DropProxy(object obj, String[] allowedMembers);
    public DropProxy(object obj, String[] allowedMembers, Func`2<object, object> value);
    public virtual object ConvertToValueType();
    internal virtual object GetObject();
    internal virtual TypeResolution CreateTypeResolution(Type type);
    [CompilerGeneratedAttribute]
private bool <CreateTypeResolution>b__8_0(MemberInfo mi);
}
public class DotLiquid.ElseCondition : Condition {
    public bool IsElse { get; }
    public virtual bool get_IsElse();
    public virtual bool Evaluate(Context context, IFormatProvider formatProvider);
}
public enum DotLiquid.ErrorsOutputMode : Enum {
    public int value__;
    public static ErrorsOutputMode Rethrow;
    public static ErrorsOutputMode Suppress;
    public static ErrorsOutputMode Display;
}
public class DotLiquid.Exceptions.ArgumentException : LiquidException {
    public ArgumentException(string message, String[] args);
}
public class DotLiquid.Exceptions.BreakInterrupt : InterruptException {
}
public class DotLiquid.Exceptions.ContextException : LiquidException {
    public ContextException(string message, String[] args);
}
public class DotLiquid.Exceptions.ContinueInterrupt : InterruptException {
}
public class DotLiquid.Exceptions.FileSystemException : LiquidException {
    public FileSystemException(string message, String[] args);
}
public class DotLiquid.Exceptions.FilterNotFoundException : LiquidException {
    public FilterNotFoundException(string message, FilterNotFoundException innerException);
    public FilterNotFoundException(string message, String[] args);
    public FilterNotFoundException(string message);
}
public class DotLiquid.Exceptions.InterruptException : LiquidException {
    public InterruptException(string message);
}
public abstract class DotLiquid.Exceptions.LiquidException : Exception {
    protected LiquidException(string message, Exception innerException);
    protected LiquidException(string message);
}
internal class DotLiquid.Exceptions.MaximumIterationsExceededException : RenderException {
    public MaximumIterationsExceededException(string message, String[] args);
}
public abstract class DotLiquid.Exceptions.RenderException : Exception {
    protected RenderException(string message, Exception innerException);
    protected RenderException(string message);
}
public class DotLiquid.Exceptions.StackLevelException : LiquidException {
    public StackLevelException(string message);
}
public class DotLiquid.Exceptions.SyntaxException : LiquidException {
    public SyntaxException(string message, String[] args);
    private static string formatMessage(string message, String[] args);
}
public class DotLiquid.Exceptions.VariableNotFoundException : LiquidException {
    public VariableNotFoundException(string message, String[] args);
    public VariableNotFoundException(string message);
}
public static class DotLiquid.ExtendedFilters : object {
    public static string Titleize(Context context, string input);
    public static string UpcaseFirst(Context context, string input);
    public static string RegexReplace(string input, string pattern, string replacement);
}
public class DotLiquid.FileSystems.BlankFileSystem : object {
    public sealed virtual string ReadTemplateFile(Context context, string templateName);
}
public class DotLiquid.FileSystems.EmbeddedFileSystem : object {
    [CompilerGeneratedAttribute]
private Assembly <Assembly>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Root>k__BackingField;
    protected Assembly Assembly { get; private set; }
    public string Root { get; private set; }
    public EmbeddedFileSystem(Assembly assembly, string root);
    [CompilerGeneratedAttribute]
protected Assembly get_Assembly();
    [CompilerGeneratedAttribute]
private void set_Assembly(Assembly value);
    [CompilerGeneratedAttribute]
public string get_Root();
    [CompilerGeneratedAttribute]
private void set_Root(string value);
    public sealed virtual string ReadTemplateFile(Context context, string templateName);
    public string FullPath(string templatePath);
}
public interface DotLiquid.FileSystems.IFileSystem {
    public abstract virtual string ReadTemplateFile(Context context, string templateName);
}
public interface DotLiquid.FileSystems.ITemplateFileSystem {
    public abstract virtual Template GetTemplate(Context context, string templateName);
}
public class DotLiquid.FileSystems.LocalFileSystem : object {
    [CompilerGeneratedAttribute]
private string <Root>k__BackingField;
    public string Root { get; public set; }
    public LocalFileSystem(string root);
    [CompilerGeneratedAttribute]
public string get_Root();
    [CompilerGeneratedAttribute]
public void set_Root(string value);
    public sealed virtual string ReadTemplateFile(Context context, string templateName);
    public string FullPath(string templatePath);
}
[DefaultMemberAttribute("Item")]
public class DotLiquid.Hash : object {
    private static ConcurrentDictionary`2<string, Action`2<object, Hash>> mapperCache;
    private Func`3<Hash, string, object> _lambda;
    private Dictionary`2<string, object> _nestedDictionary;
    private object _defaultValue;
    private object System.Collections.IDictionary.Item { get; private set; }
    public int Count { get; }
    public object SyncRoot { get; }
    public bool IsSynchronized { get; }
    private ICollection System.Collections.IDictionary.Values { get; }
    public bool IsReadOnly { get; }
    public bool IsFixedSize { get; }
    public object Item { get; public set; }
    public ICollection`1<string> Keys { get; }
    private ICollection System.Collections.IDictionary.Keys { get; }
    public ICollection`1<object> Values { get; }
    public Hash(object defaultValue);
    public Hash(Func`3<Hash, string, object> lambda);
    private static Hash();
    public static Hash FromAnonymousObject(object anonymousObject, bool includeBaseClassProperties);
    private static void FromAnonymousObject(object anonymousObject, Hash hash, bool includeBaseClassProperties);
    private static Action`2<object, Hash> GetObjToDictionaryMapper(Type type, bool includeBaseClassProperties);
    private static void AddBaseClassProperties(Type type, List`1<PropertyInfo> propertyList);
    private static Action`2<object, Hash> GenerateMapper(Type type, bool includeBaseClassProperties);
    public static Hash FromDictionary(IDictionary`2<string, object> dictionary);
    public void Merge(IDictionary`2<string, object> otherValues);
    protected virtual object GetValue(string key);
    public T Get(string key);
    public sealed virtual IEnumerator`1<KeyValuePair`2<string, object>> GetEnumerator();
    public sealed virtual void Remove(object key);
    private sealed virtual override object System.Collections.IDictionary.get_Item(object key);
    private sealed virtual override void System.Collections.IDictionary.set_Item(object key, object value);
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    public sealed virtual void Add(KeyValuePair`2<string, object> item);
    public virtual bool Contains(object key);
    public sealed virtual void Add(object key, object value);
    public sealed virtual void Clear();
    private sealed virtual override IDictionaryEnumerator System.Collections.IDictionary.GetEnumerator();
    public sealed virtual bool Contains(KeyValuePair`2<string, object> item);
    public sealed virtual void CopyTo(KeyValuePair`2[] array, int arrayIndex);
    public sealed virtual bool Remove(KeyValuePair`2<string, object> item);
    public sealed virtual void CopyTo(Array array, int index);
    public sealed virtual int get_Count();
    public sealed virtual object get_SyncRoot();
    public sealed virtual bool get_IsSynchronized();
    private sealed virtual override ICollection System.Collections.IDictionary.get_Values();
    public sealed virtual bool get_IsReadOnly();
    public sealed virtual bool get_IsFixedSize();
    public sealed virtual bool ContainsKey(string key);
    public sealed virtual void Add(string key, object value);
    public sealed virtual bool Remove(string key);
    public sealed virtual bool TryGetValue(string key, Object& value);
    public sealed virtual object get_Item(string key);
    public sealed virtual void set_Item(string key, object value);
    public sealed virtual ICollection`1<string> get_Keys();
    private sealed virtual override ICollection System.Collections.IDictionary.get_Keys();
    public sealed virtual ICollection`1<object> get_Values();
}
public interface DotLiquid.IContextAware {
    unknown Context Context {public set; }
    public abstract virtual void set_Context(Context value);
}
[DefaultMemberAttribute("Item")]
public interface DotLiquid.IIndexable {
    public object Item { get; }
    public abstract virtual object get_Item(object key);
    public abstract virtual bool ContainsKey(object key);
}
public interface DotLiquid.ILiquidizable {
    public abstract virtual object ToLiquid();
}
internal interface DotLiquid.IRenderable {
    public abstract virtual void Render(Context context, TextWriter result);
}
public interface DotLiquid.ITagFactory {
    public string TagName { get; }
    public abstract virtual string get_TagName();
    public abstract virtual Tag Create();
}
public interface DotLiquid.IValueTypeConvertible {
    public abstract virtual object ConvertToValueType();
}
public static class DotLiquid.Liquid : object {
    internal static ResourceManager ResourceManager;
    public static string FilterSeparator;
    public static string ArgumentSeparator;
    public static string FilterArgumentSeparator;
    public static string VariableAttributeSeparator;
    public static string TagStart;
    public static string TagEnd;
    public static string VariableSignature;
    public static string VariableSegment;
    public static string VariableStart;
    public static string VariableEnd;
    public static string QuotedString;
    public static string QuotedFragment;
    public static string QuotedAssignFragment;
    public static string TagAttributes;
    public static string AnyStartingTag;
    public static string VariableParser;
    public static string LiteralShorthand;
    public static string CommentShorthand;
    public static bool UseRubyDateFormat;
    internal static string DirectorySeparators;
    internal static string LimitRelativePath;
    private static Lazy`1<Regex> LazyDirectorySeparatorsRegex;
    private static Lazy`1<Regex> LazyLimitRelativePathRegex;
    private static Lazy`1<Regex> LazyVariableSegmentRegex;
    internal static Regex DirectorySeparatorsRegex { get; }
    internal static Regex LimitRelativePathRegex { get; }
    internal static Regex VariableSegmentRegex { get; }
    private static Liquid();
    internal static Regex get_DirectorySeparatorsRegex();
    internal static Regex get_LimitRelativePathRegex();
    internal static Regex get_VariableSegmentRegex();
}
[AttributeUsageAttribute("4")]
public class DotLiquid.LiquidTypeAttribute : Attribute {
    [CompilerGeneratedAttribute]
private String[] <AllowedMembers>k__BackingField;
    public String[] AllowedMembers { get; private set; }
    public LiquidTypeAttribute(String[] allowedMembers);
    [CompilerGeneratedAttribute]
public String[] get_AllowedMembers();
    [CompilerGeneratedAttribute]
private void set_AllowedMembers(String[] value);
}
public class DotLiquid.NamingConventions.CSharpNamingConvention : object {
    public StringComparer StringComparer { get; }
    public sealed virtual StringComparer get_StringComparer();
    public sealed virtual string GetMemberName(string name);
    public sealed virtual bool OperatorEquals(string testedOperator, string referenceOperator);
    private static string UpperFirstLetter(string word);
    private static string LowerFirstLetter(string word);
}
public interface DotLiquid.NamingConventions.INamingConvention {
    public StringComparer StringComparer { get; }
    public abstract virtual StringComparer get_StringComparer();
    public abstract virtual string GetMemberName(string name);
    public abstract virtual bool OperatorEquals(string testedOperator, string referenceOperator);
}
public class DotLiquid.NamingConventions.RubyNamingConvention : object {
    private static Regex _regex1;
    private static Regex _regex2;
    public StringComparer StringComparer { get; }
    private static RubyNamingConvention();
    public sealed virtual StringComparer get_StringComparer();
    public sealed virtual string GetMemberName(string name);
    public sealed virtual bool OperatorEquals(string testedOperator, string referenceOperator);
}
public class DotLiquid.Proc : MulticastDelegate {
    public Proc(object object, IntPtr method);
    public virtual object Invoke(Context context);
    public virtual IAsyncResult BeginInvoke(Context context, AsyncCallback callback, object object);
    public virtual object EndInvoke(IAsyncResult result);
}
[GeneratedCodeAttribute("System.Resources.Tools.StronglyTypedResourceBuilder", "4.0.0.0")]
[DebuggerNonUserCodeAttribute]
[CompilerGeneratedAttribute]
internal class DotLiquid.Properties.Resources : object {
    private static ResourceManager resourceMan;
    private static CultureInfo resourceCulture;
    [EditorBrowsableAttribute("2")]
internal static ResourceManager ResourceManager { get; }
    [EditorBrowsableAttribute("2")]
internal static CultureInfo Culture { get; internal set; }
    internal static string AssignTagSyntaxException { get; }
    internal static string BlankFileSystemDoesNotAllowIncludesException { get; }
    internal static string BlockTagAlreadyDefinedException { get; }
    internal static string BlockTagNoElseException { get; }
    internal static string BlockTagNoEndException { get; }
    internal static string BlockTagNotClosedException { get; }
    internal static string BlockTagNotTerminatedException { get; }
    internal static string BlockTagSyntaxException { get; }
    internal static string BlockUnknownTagException { get; }
    internal static string BlockVariableNotTerminatedException { get; }
    internal static string CaptureTagSyntaxException { get; }
    internal static string CaseTagElseSyntaxException { get; }
    internal static string CaseTagSyntaxException { get; }
    internal static string CaseTagWhenSyntaxException { get; }
    internal static string ConditionUnknownOperatorException { get; }
    internal static string ContextLiquidError { get; }
    internal static string ContextLiquidSyntaxError { get; }
    internal static string ContextObjectInvalidException { get; }
    internal static string ContextStackException { get; }
    internal static string CycleTagSyntaxException { get; }
    internal static string DropWrongNamingConventionMessage { get; }
    internal static string ExtendsTagCanBeUsedOneException { get; }
    internal static string ExtendsTagMustBeFirstTagException { get; }
    internal static string ExtendsTagSyntaxException { get; }
    internal static string ExtendsTagUnallowedTagsException { get; }
    internal static string ForTagSyntaxException { get; }
    internal static string IfTagSyntaxException { get; }
    internal static string IncludeTagSyntaxException { get; }
    internal static string LocalFileSystemIllegalTemplateNameException { get; }
    internal static string LocalFileSystemIllegalTemplatePathException { get; }
    internal static string LocalFileSystemTemplateNotFoundException { get; }
    internal static string StrainerFilterHasNoValueException { get; }
    internal static string TableRowTagSyntaxException { get; }
    internal static string VariableFilterNotFoundException { get; }
    internal static string VariableNotFoundException { get; }
    internal static string WeakTableKeyNotFoundException { get; }
    internal static ResourceManager get_ResourceManager();
    internal static CultureInfo get_Culture();
    internal static void set_Culture(CultureInfo value);
    internal static string get_AssignTagSyntaxException();
    internal static string get_BlankFileSystemDoesNotAllowIncludesException();
    internal static string get_BlockTagAlreadyDefinedException();
    internal static string get_BlockTagNoElseException();
    internal static string get_BlockTagNoEndException();
    internal static string get_BlockTagNotClosedException();
    internal static string get_BlockTagNotTerminatedException();
    internal static string get_BlockTagSyntaxException();
    internal static string get_BlockUnknownTagException();
    internal static string get_BlockVariableNotTerminatedException();
    internal static string get_CaptureTagSyntaxException();
    internal static string get_CaseTagElseSyntaxException();
    internal static string get_CaseTagSyntaxException();
    internal static string get_CaseTagWhenSyntaxException();
    internal static string get_ConditionUnknownOperatorException();
    internal static string get_ContextLiquidError();
    internal static string get_ContextLiquidSyntaxError();
    internal static string get_ContextObjectInvalidException();
    internal static string get_ContextStackException();
    internal static string get_CycleTagSyntaxException();
    internal static string get_DropWrongNamingConventionMessage();
    internal static string get_ExtendsTagCanBeUsedOneException();
    internal static string get_ExtendsTagMustBeFirstTagException();
    internal static string get_ExtendsTagSyntaxException();
    internal static string get_ExtendsTagUnallowedTagsException();
    internal static string get_ForTagSyntaxException();
    internal static string get_IfTagSyntaxException();
    internal static string get_IncludeTagSyntaxException();
    internal static string get_LocalFileSystemIllegalTemplateNameException();
    internal static string get_LocalFileSystemIllegalTemplatePathException();
    internal static string get_LocalFileSystemTemplateNotFoundException();
    internal static string get_StrainerFilterHasNoValueException();
    internal static string get_TableRowTagSyntaxException();
    internal static string get_VariableFilterNotFoundException();
    internal static string get_VariableNotFoundException();
    internal static string get_WeakTableKeyNotFoundException();
}
public class DotLiquid.RawBlock : Block {
    protected string BlockDelimiter { get; }
    protected sealed virtual string get_BlockDelimiter();
    public virtual void Initialize(string tagName, string markup, List`1<string> tokens);
    protected virtual void Parse(List`1<string> tokens);
}
public class DotLiquid.RenderParameters : object {
    [CompilerGeneratedAttribute]
private Context <Context>k__BackingField;
    [CompilerGeneratedAttribute]
private Hash <LocalVariables>k__BackingField;
    [CompilerGeneratedAttribute]
private IEnumerable`1<Type> <Filters>k__BackingField;
    [CompilerGeneratedAttribute]
private Hash <Registers>k__BackingField;
    private ErrorsOutputMode _erorsOutputMode;
    [CompilerGeneratedAttribute]
private SyntaxCompatibility <SyntaxCompatibilityLevel>k__BackingField;
    private int _maxIterations;
    private int _timeout;
    [CompilerGeneratedAttribute]
private IFormatProvider <FormatProvider>k__BackingField;
    public Context Context { get; public set; }
    public Hash LocalVariables { get; public set; }
    public IEnumerable`1<Type> Filters { get; public set; }
    public Hash Registers { get; public set; }
    [ObsoleteAttribute("Use ErrorsOutputMode instead")]
public bool RethrowErrors { get; public set; }
    public ErrorsOutputMode ErrorsOutputMode { get; public set; }
    public SyntaxCompatibility SyntaxCompatibilityLevel { get; public set; }
    public int MaxIterations { get; public set; }
    public IFormatProvider FormatProvider { get; }
    public int Timeout { get; public set; }
    public RenderParameters(IFormatProvider formatProvider);
    [CompilerGeneratedAttribute]
public Context get_Context();
    [CompilerGeneratedAttribute]
public void set_Context(Context value);
    [CompilerGeneratedAttribute]
public Hash get_LocalVariables();
    [CompilerGeneratedAttribute]
public void set_LocalVariables(Hash value);
    [CompilerGeneratedAttribute]
public IEnumerable`1<Type> get_Filters();
    [CompilerGeneratedAttribute]
public void set_Filters(IEnumerable`1<Type> value);
    [CompilerGeneratedAttribute]
public Hash get_Registers();
    [CompilerGeneratedAttribute]
public void set_Registers(Hash value);
    public bool get_RethrowErrors();
    public void set_RethrowErrors(bool value);
    public ErrorsOutputMode get_ErrorsOutputMode();
    public void set_ErrorsOutputMode(ErrorsOutputMode value);
    [CompilerGeneratedAttribute]
public SyntaxCompatibility get_SyntaxCompatibilityLevel();
    [CompilerGeneratedAttribute]
public void set_SyntaxCompatibilityLevel(SyntaxCompatibility value);
    public int get_MaxIterations();
    public void set_MaxIterations(int value);
    [CompilerGeneratedAttribute]
public IFormatProvider get_FormatProvider();
    public int get_Timeout();
    public void set_Timeout(int value);
    internal void Evaluate(Template template, Context& context, Hash& registers, IEnumerable`1& filters);
    public static RenderParameters FromContext(Context context, IFormatProvider formatProvider);
}
public static class DotLiquid.ShopifyFilters : object {
    public static string Md5(string input);
    public static string Sha1(string input);
    public static string Sha256(string input);
    public static string HmacSha1(string input, string secretKey);
    public static string HmacSha256(string input, string secretKey);
    private static string ComputeHash(HashAlgorithm hashAlgorithm, string input);
}
[ExtensionAttribute]
public static class DotLiquid.StandardFilters : object {
    private static Lazy`1<Regex> StripHtmlBlocks;
    private static Lazy`1<Regex> StripHtmlTags;
    private static StandardFilters();
    public static int Size(object input);
    public static object Slice(Context context, object input, int offset, int length);
    private static string SliceString(string input, long start, long len);
    public static string Downcase(string input);
    public static string Upcase(string input);
    public static string UrlEncode(string input);
    public static string UrlDecode(string input);
    public static string Capitalize(Context context, string input);
    public static string Escape(string input);
    public static string EscapeOnce(string input);
    public static string H(string input);
    public static string Truncate(string input, int length, string truncateString);
    public static string TruncateWords(string input, int words, string truncateString);
    public static String[] Split(string input, string pattern);
    public static string StripHtml(string input);
    public static string Strip(string input);
    public static string Lstrip(string input);
    public static string Rstrip(string input);
    public static string Currency(Context context, object input, string languageTag);
    public static string StripNewlines(string input);
    public static string Join(IEnumerable input, string glue);
    public static IEnumerable Sort(Context context, object input, string property);
    public static IEnumerable SortNatural(object input, string property);
    private static IEnumerable SortInternal(StringComparer stringComparer, object input, string property);
    public static IEnumerable Map(IEnumerable enumerableInput, string property);
    public static string Replace(Context context, string input, string string, string replacement);
    public static string ReplaceFirst(Context context, string input, string string, string replacement);
    public static string Remove(string input, string string);
    public static string RemoveFirst(Context context, string input, string string);
    public static string Append(string input, string string);
    public static string Prepend(string input, string string);
    public static string NewlineToBr(string input);
    public static string Date(Context context, object input, string format);
    private static string DateLegacyParsing(Context context, string value, string format);
    public static object First(IEnumerable array);
    public static object Last(IEnumerable array);
    public static object Plus(Context context, object input, object operand);
    public static object Minus(Context context, object input, object operand);
    public static object Times(Context context, object input, object operand);
    public static object Round(object input, object places);
    public static object Ceil(Context context, object input);
    public static object Floor(Context context, object input);
    public static object DividedBy(Context context, object input, object operand);
    public static object Modulo(Context context, object input, object operand);
    public static string Default(string input, string defaultValue);
    private static bool IsReal(object o);
    private static object DoMathsOperation(Context context, object input, object operand, Func`3<Expression, Expression, BinaryExpression> operation);
    public static IEnumerable Uniq(object input);
    public static double Abs(Context context, object input);
    public static object AtLeast(Context context, object input, object atLeast);
    public static object AtMost(Context context, object input, object atMost);
    public static IEnumerable Compact(object input);
    public static IEnumerable Where(IEnumerable input, string propertyName, object targetValue);
    [ExtensionAttribute]
private static bool HasMatchingProperty(object any, string propertyName, object targetValue);
    [ExtensionAttribute]
private static object ResolveObjectPropertyValue(object obj, string propertyName);
    public static IEnumerable Concat(IEnumerable left, IEnumerable right);
    public static IEnumerable Reverse(IEnumerable input);
}
public class DotLiquid.Strainer : object {
    private static Dictionary`2<string, Type> Filters;
    private static Dictionary`2<string, Tuple`2<object, MethodInfo>> FilterFuncs;
    private Context _context;
    private Dictionary`2<string, IList`1<Tuple`2<object, MethodInfo>>> _methods;
    public IEnumerable`1<MethodInfo> Methods { get; }
    public Strainer(Context context);
    private static Strainer();
    public static void GlobalFilter(Type filter);
    public static void GlobalFilter(string rawName, object target, MethodInfo methodInfo);
    public static Strainer Create(Context context);
    public IEnumerable`1<MethodInfo> get_Methods();
    public void Extend(Type type);
    public void AddFunction(string rawName, Func`2<TIn, TOut> func);
    public void AddFunction(string rawName, Func`3<TIn, TIn2, TOut> func);
    public void AddMethodInfo(string rawName, object target, MethodInfo method);
    public bool RespondTo(string method);
    public object Invoke(string method, List`1<object> args);
}
[ExtensionAttribute]
internal static class DotLiquid.StringExtensions : object {
    [ExtensionAttribute]
public static bool IsNullOrWhiteSpace(string s);
}
public enum DotLiquid.SyntaxCompatibility : Enum {
    public int value__;
    public static SyntaxCompatibility DotLiquid20;
    public static SyntaxCompatibility DotLiquid21;
    public static SyntaxCompatibility DotLiquid22;
    public static SyntaxCompatibility DotLiquid22a;
}
public class DotLiquid.Tag : object {
    [CompilerGeneratedAttribute]
private List`1<object> <NodeList>k__BackingField;
    [CompilerGeneratedAttribute]
private string <TagName>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Markup>k__BackingField;
    public List`1<object> NodeList { get; protected set; }
    protected string TagName { get; private set; }
    protected string Markup { get; private set; }
    public string Name { get; }
    [CompilerGeneratedAttribute]
public List`1<object> get_NodeList();
    [CompilerGeneratedAttribute]
protected void set_NodeList(List`1<object> value);
    [CompilerGeneratedAttribute]
protected string get_TagName();
    [CompilerGeneratedAttribute]
private void set_TagName(string value);
    [CompilerGeneratedAttribute]
protected string get_Markup();
    [CompilerGeneratedAttribute]
private void set_Markup(string value);
    internal virtual void AssertTagRulesViolation(List`1<object> rootNodeList);
    public virtual void Initialize(string tagName, string markup, List`1<string> tokens);
    protected virtual void Parse(List`1<string> tokens);
    public string get_Name();
    public virtual void Render(Context context, TextWriter result);
    internal string Render(Context context);
    internal static IDictionary`2<string, T> GetRegister(Context context, string registerName);
}
public class DotLiquid.Tags.Assign : Tag {
    private static Regex Syntax;
    private string _to;
    private Variable _from;
    private static Assign();
    public virtual void Initialize(string tagName, string markup, List`1<string> tokens);
    public virtual void Render(Context context, TextWriter result);
}
public class DotLiquid.Tags.Block : Block {
    private static Regex Syntax;
    [CompilerGeneratedAttribute]
private string <BlockName>k__BackingField;
    internal string BlockName { get; internal set; }
    private static Block();
    [CompilerGeneratedAttribute]
internal string get_BlockName();
    [CompilerGeneratedAttribute]
internal void set_BlockName(string value);
    public virtual void Initialize(string tagName, string markup, List`1<string> tokens);
    internal virtual void AssertTagRulesViolation(List`1<object> rootNodeList);
    public virtual void Render(Context context, TextWriter result);
    internal List`1<object> GetNodeList(BlockRenderState blockState);
    public void AddParent(Dictionary`2<Block, Block> parents, List`1<object> nodeList);
    public void CallSuper(Context context, TextWriter result);
}
public class DotLiquid.Tags.BlockDrop : Drop {
    private Block _block;
    private TextWriter _result;
    public BlockDrop(Block block, TextWriter result);
    public void Super();
}
internal class DotLiquid.Tags.BlockRenderState : object {
    [CompilerGeneratedAttribute]
private Dictionary`2<Block, Block> <Parents>k__BackingField;
    [CompilerGeneratedAttribute]
private Dictionary`2<Block, List`1<object>> <NodeLists>k__BackingField;
    public Dictionary`2<Block, Block> Parents { get; private set; }
    public Dictionary`2<Block, List`1<object>> NodeLists { get; private set; }
    [CompilerGeneratedAttribute]
public Dictionary`2<Block, Block> get_Parents();
    [CompilerGeneratedAttribute]
private void set_Parents(Dictionary`2<Block, Block> value);
    [CompilerGeneratedAttribute]
public Dictionary`2<Block, List`1<object>> get_NodeLists();
    [CompilerGeneratedAttribute]
private void set_NodeLists(Dictionary`2<Block, List`1<object>> value);
    public List`1<object> GetNodeList(Block block);
    public static BlockRenderState Find(Context context);
}
public class DotLiquid.Tags.Break : Tag {
    public virtual void Render(Context context, TextWriter result);
}
public class DotLiquid.Tags.Capture : Block {
    private string _to;
    public virtual void Initialize(string tagName, string markup, List`1<string> tokens);
    public virtual void Render(Context context, TextWriter result);
}
public class DotLiquid.Tags.Case : Block {
    private static Regex Syntax;
    private static Regex WhenSyntax;
    private List`1<Condition> _blocks;
    private string _left;
    private static Case();
    public virtual void Initialize(string tagName, string markup, List`1<string> tokens);
    public virtual void UnknownTag(string tag, string markup, List`1<string> tokens);
    public virtual void Render(Context context, TextWriter result);
    private void RecordWhenCondition(string markup);
    private void RecordElseCondition(string markup);
}
public class DotLiquid.Tags.Comment : RawBlock {
    private static Regex ShortHandRegex;
    private static Comment();
    public static string FromShortHand(string string);
    public virtual void Render(Context context, TextWriter result);
}
public class DotLiquid.Tags.Continue : Tag {
    public virtual void Render(Context context, TextWriter result);
}
public class DotLiquid.Tags.Cycle : Tag {
    private static Regex SimpleSyntax;
    private static Regex NamedSyntax;
    private static Regex QuotedFragmentRegex;
    private String[] _variables;
    private string _name;
    private static Cycle();
    public virtual void Initialize(string tagName, string markup, List`1<string> tokens);
    private static String[] VariablesFromString(string markup);
    public virtual void Render(Context context, TextWriter result);
}
public class DotLiquid.Tags.Decrement : Tag {
    private string _variable;
    public virtual void Initialize(string tagName, string markup, List`1<string> tokens);
    public virtual void Render(Context context, TextWriter result);
    private void Decrement32(Context context, TextWriter result, object current);
    private void Decrement64(Context context, TextWriter result, object current);
}
public class DotLiquid.Tags.Extends : Block {
    private static Regex Syntax;
    private string _templateName;
    private static Extends();
    public virtual void Initialize(string tagName, string markup, List`1<string> tokens);
    internal virtual void AssertTagRulesViolation(List`1<object> rootNodeList);
    protected virtual void AssertMissingDelimitation();
    public virtual void Render(Context context, TextWriter result);
    public bool IsExtending(Template template);
    private List`1<Block> FindBlocks(object node, List`1<Block> blocks);
}
public class DotLiquid.Tags.For : Block {
    private static Regex Syntax;
    private static string ForTagMaxIterationsExceededException;
    private string _variableName;
    private string _collectionName;
    private string _name;
    private bool _reversed;
    private Dictionary`2<string, string> _attributes;
    [CompilerGeneratedAttribute]
private List`1<object> <ForBlock>k__BackingField;
    [CompilerGeneratedAttribute]
private Condition <ElseBlock>k__BackingField;
    private List`1<object> ForBlock { get; private set; }
    private Condition ElseBlock { get; private set; }
    private static For();
    [CompilerGeneratedAttribute]
private List`1<object> get_ForBlock();
    [CompilerGeneratedAttribute]
private void set_ForBlock(List`1<object> value);
    [CompilerGeneratedAttribute]
private Condition get_ElseBlock();
    [CompilerGeneratedAttribute]
private void set_ElseBlock(Condition value);
    public virtual void Initialize(string tagName, string markup, List`1<string> tokens);
    public virtual void UnknownTag(string tag, string markup, List`1<string> tokens);
    public virtual void Render(Context context, TextWriter result);
    private static List`1<object> SliceCollectionUsingEach(Context context, IEnumerable collection, int from, Nullable`1<int> to);
    [CompilerGeneratedAttribute]
private void <Initialize>b__15_0(string key, string value);
}
public class DotLiquid.Tags.Html.TableRow : Block {
    private static Regex Syntax;
    private string _variableName;
    private string _collectionName;
    private Dictionary`2<string, string> _attributes;
    private static TableRow();
    public virtual void Initialize(string tagName, string markup, List`1<string> tokens);
    public virtual void Render(Context context, TextWriter result);
    [CompilerGeneratedAttribute]
private void <Initialize>b__4_0(string key, string value);
}
public class DotLiquid.Tags.If : Block {
    private string SyntaxHelp;
    private string TooMuchConditionsHelp;
    private static Regex Syntax;
    private static string ExpressionsAndOperators;
    private static Regex ExpressionsAndOperatorsRegex;
    [CompilerGeneratedAttribute]
private List`1<Condition> <Blocks>k__BackingField;
    protected List`1<Condition> Blocks { get; private set; }
    private static If();
    [CompilerGeneratedAttribute]
protected List`1<Condition> get_Blocks();
    [CompilerGeneratedAttribute]
private void set_Blocks(List`1<Condition> value);
    public virtual void Initialize(string tagName, string markup, List`1<string> tokens);
    public virtual void UnknownTag(string tag, string markup, List`1<string> tokens);
    public virtual void Render(Context context, TextWriter result);
    private void PushBlock(string tag, string markup);
}
public class DotLiquid.Tags.IfChanged : Block {
    public virtual void Render(Context context, TextWriter result);
}
public class DotLiquid.Tags.Include : Block {
    private static Regex Syntax;
    private string _templateName;
    private string _variableName;
    private Dictionary`2<string, string> _attributes;
    private static Include();
    public virtual void Initialize(string tagName, string markup, List`1<string> tokens);
    protected virtual void Parse(List`1<string> tokens);
    public virtual void Render(Context context, TextWriter result);
    [CompilerGeneratedAttribute]
private void <Initialize>b__4_0(string key, string value);
}
public class DotLiquid.Tags.Increment : Tag {
    private string _variable;
    public virtual void Initialize(string tagName, string markup, List`1<string> tokens);
    public virtual void Render(Context context, TextWriter result);
    private void Increment32(Context context, TextWriter result, object current);
    private void Increment64(Context context, TextWriter result, object current);
}
internal class DotLiquid.Tags.LegacyKeyValueDrop : Drop {
    private string key;
    private IDictionary`2<string, object> value;
    public LegacyKeyValueDrop(string key, IDictionary`2<string, object> value);
    public virtual object BeforeMethod(string method);
    public virtual bool ContainsKey(object name);
}
public class DotLiquid.Tags.Literal : Block {
    private static Regex LiteralRegex;
    private static Literal();
    public static string FromShortHand(string string);
    protected virtual void Parse(List`1<string> tokens);
}
public class DotLiquid.Tags.Param : Tag {
    private static Regex Syntax;
    private static Dictionary`2<string, ParamDelegate> Params;
    private ParamDelegate param;
    private string paramValue;
    private static Param();
    public virtual void Initialize(string tagName, string markup, List`1<string> tokens);
    public virtual void Render(Context context, TextWriter _);
    private static void SetDateFormat(Context context, string value);
    private static void SetCulture(Context context, string value);
    private static void SetSyntax(Context context, string value);
    private static void AddUsing(Context context, string value);
}
public class DotLiquid.Tags.Raw : RawBlock {
}
public class DotLiquid.Tags.Unless : If {
    public virtual void Render(Context context, TextWriter result);
}
public class DotLiquid.Template : object {
    [CompilerGeneratedAttribute]
private static INamingConvention <NamingConvention>k__BackingField;
    [CompilerGeneratedAttribute]
private static IFileSystem <FileSystem>k__BackingField;
    [CompilerGeneratedAttribute]
private static SyntaxCompatibility <DefaultSyntaxCompatibilityLevel>k__BackingField;
    [CompilerGeneratedAttribute]
private static bool <DefaultIsThreadSafe>k__BackingField;
    [CompilerGeneratedAttribute]
private static Dictionary`2<string, Tuple`2<ITagFactory, Type>> <Tags>k__BackingField;
    [CompilerGeneratedAttribute]
private static TimeSpan <RegexTimeOut>k__BackingField;
    private static Dictionary`2<Type, Func`2<object, object>> SafeTypeTransformers;
    private static Dictionary`2<Type, Func`2<object, object>> ValueTypeTransformers;
    private static ConcurrentDictionary`2<Type, Func`2<object, object>> ValueTypeTransformerCache;
    private static IDictionary`2<string, Type> SafelistedFilters;
    private Hash _registers;
    private Hash _assigns;
    private Hash _instanceAssigns;
    private List`1<Exception> _errors;
    private Nullable`1<bool> _isThreadSafe;
    [CompilerGeneratedAttribute]
private Document <Root>k__BackingField;
    public static INamingConvention NamingConvention { get; public set; }
    public static IFileSystem FileSystem { get; public set; }
    public static SyntaxCompatibility DefaultSyntaxCompatibilityLevel { get; public set; }
    public static bool DefaultIsThreadSafe { get; public set; }
    private static Dictionary`2<string, Tuple`2<ITagFactory, Type>> Tags { get; private set; }
    public static TimeSpan RegexTimeOut { get; public set; }
    public Document Root { get; public set; }
    public Hash Registers { get; }
    public Hash Assigns { get; }
    public Hash InstanceAssigns { get; }
    public List`1<Exception> Errors { get; }
    public bool IsThreadSafe { get; }
    private static Template();
    [CompilerGeneratedAttribute]
public static INamingConvention get_NamingConvention();
    [CompilerGeneratedAttribute]
public static void set_NamingConvention(INamingConvention value);
    [CompilerGeneratedAttribute]
public static IFileSystem get_FileSystem();
    [CompilerGeneratedAttribute]
public static void set_FileSystem(IFileSystem value);
    [CompilerGeneratedAttribute]
public static SyntaxCompatibility get_DefaultSyntaxCompatibilityLevel();
    [CompilerGeneratedAttribute]
public static void set_DefaultSyntaxCompatibilityLevel(SyntaxCompatibility value);
    [CompilerGeneratedAttribute]
public static bool get_DefaultIsThreadSafe();
    [CompilerGeneratedAttribute]
public static void set_DefaultIsThreadSafe(bool value);
    [CompilerGeneratedAttribute]
private static Dictionary`2<string, Tuple`2<ITagFactory, Type>> get_Tags();
    [CompilerGeneratedAttribute]
private static void set_Tags(Dictionary`2<string, Tuple`2<ITagFactory, Type>> value);
    [CompilerGeneratedAttribute]
public static TimeSpan get_RegexTimeOut();
    [CompilerGeneratedAttribute]
public static void set_RegexTimeOut(TimeSpan value);
    public static void RegisterTag(string name);
    public static void RegisterTagFactory(ITagFactory tagFactory);
    public static Type GetTagType(string name);
    internal static bool IsRawTag(string name);
    internal static Tag CreateTag(string name);
    public static void RegisterFilter(Type filter);
    public static void RegisterSafeType(Type type, String[] allowedMembers);
    public static void RegisterSafeType(Type type, String[] allowedMembers, Func`2<object, object> func);
    public static void RegisterSafeType(Type type, Func`2<object, object> func);
    public static void RegisterValueTypeTransformer(Type type, Func`2<object, object> func);
    public static Func`2<object, object> GetValueTypeTransformer(Type type);
    public static Func`2<object, object> GetSafeTypeTransformer(Type type);
    public static void SafelistFilter(Type filterClassType, string alias);
    public static bool TryGetSafelistedFilter(string alias, Type& filterClassType);
    public static ICollection`1<string> GetSafelistedFilterAliases();
    public static Template Parse(string source);
    public static Template Parse(string source, SyntaxCompatibility syntaxCompatibilityLevel);
    [CompilerGeneratedAttribute]
public Document get_Root();
    [CompilerGeneratedAttribute]
public void set_Root(Document value);
    public Hash get_Registers();
    public Hash get_Assigns();
    public Hash get_InstanceAssigns();
    public List`1<Exception> get_Errors();
    public bool get_IsThreadSafe();
    internal Template ParseInternal(string source, SyntaxCompatibility syntaxCompatibilityLevel);
    public void MakeThreadSafe();
    public string Render(IFormatProvider formatProvider);
    public string Render(Hash localVariables, IFormatProvider formatProvider);
    public string Render(RenderParameters parameters);
    public string Render(TextWriter writer, RenderParameters parameters);
    public void Render(Stream stream, RenderParameters parameters);
    private void RenderInternal(TextWriter result, RenderParameters parameters);
}
internal static class DotLiquid.Tokenizer : object {
    private static HashSet`1<char> SearchVariableEnd;
    private static char BracketEnd;
    private static HashSet`1<char> SearchQuoteOrVariableEnd;
    private static HashSet`1<char> SearchQuoteOrTagEnd;
    private static Char[] WhitespaceCharsV20;
    private static Char[] WhitespaceCharsV22;
    private static Regex LiquidAnyStartingTagRegex;
    private static Regex TagNameRegex;
    private static Regex VariableSegmentRegex;
    private static ConcurrentDictionary`2<string, Regex> EndTagRegexes;
    private static Tokenizer();
    internal static List`1<string> Tokenize(string source, SyntaxCompatibility syntaxCompatibilityLevel);
    [IteratorStateMachineAttribute("DotLiquid.Tokenizer/<GetVariableEnumerator>d__11")]
internal static IEnumerator`1<string> GetVariableEnumerator(string source);
    private static string ReadChars(CharEnumerator markupEnumerator, int markupLength);
    private static bool ReadToEndOfTag(StringBuilder sb, CharEnumerator markupEnumerator, HashSet`1<char> searchChars, SyntaxCompatibility syntaxCompatibilityLevel);
    private static bool ReadToChar(StringBuilder sb, CharEnumerator markupEnumerator, char endChar);
    private static bool ReadToEndOfVariable(StringBuilder sb, CharEnumerator markupEnumerator);
    private static bool ReadWordChar(StringBuilder sb, CharEnumerator markupEnumerator);
}
internal class DotLiquid.TypeResolution : object {
    [CompilerGeneratedAttribute]
private Dictionary`2<string, MethodInfo> <CachedMethods>k__BackingField;
    [CompilerGeneratedAttribute]
private Dictionary`2<string, PropertyInfo> <CachedProperties>k__BackingField;
    public Dictionary`2<string, MethodInfo> CachedMethods { get; private set; }
    public Dictionary`2<string, PropertyInfo> CachedProperties { get; private set; }
    public TypeResolution(Type type, Func`2<MemberInfo, bool> filterMemberCallback);
    [CompilerGeneratedAttribute]
public Dictionary`2<string, MethodInfo> get_CachedMethods();
    [CompilerGeneratedAttribute]
private void set_CachedMethods(Dictionary`2<string, MethodInfo> value);
    [CompilerGeneratedAttribute]
public Dictionary`2<string, PropertyInfo> get_CachedProperties();
    [CompilerGeneratedAttribute]
private void set_CachedProperties(Dictionary`2<string, PropertyInfo> value);
    private Dictionary`2<string, T> GetMemberDictionary(IEnumerable`1<T> members);
    private static IEnumerable`1<PropertyInfo> GetPropertiesWithoutDuplicateNames(Type type, Func`2<PropertyInfo, bool> predicate);
    private static IEnumerable`1<MethodInfo> GetMethodsWithoutDuplicateNames(Type type, Func`2<MethodInfo, bool> predicate);
    private static IEnumerable`1<MemberInfo> GetMembersWithoutDuplicateNames(ICollection`1<MemberInfo> members);
}
internal static class DotLiquid.TypeResolutionCache : object {
    [ThreadStaticAttribute]
private static WeakTable`2<Type, TypeResolution> _cache;
    public static WeakTable`2<Type, TypeResolution> Instance { get; }
    public static WeakTable`2<Type, TypeResolution> get_Instance();
}
internal class DotLiquid.Util.CharEnumerator : object {
    private string str;
    private int index;
    private object System.Collections.IEnumerator.Current { get; }
    public char Current { get; }
    public char Previous { get; }
    public char Next { get; }
    public int Remaining { get; }
    public int Position { get; }
    internal CharEnumerator(string str);
    public sealed virtual bool MoveNext();
    public bool AppendNext(StringBuilder sb);
    public bool HasNext();
    private sealed virtual override object System.Collections.IEnumerator.get_Current();
    public sealed virtual char get_Current();
    public char get_Previous();
    public char get_Next();
    public int get_Remaining();
    public int get_Position();
    public sealed virtual void Reset();
    public sealed virtual void Dispose();
    protected virtual void Dispose(bool disposing);
}
[ExtensionAttribute]
public static class DotLiquid.Util.DictionaryExtensionMethods : object {
    [ExtensionAttribute]
public static V TryAdd(IDictionary`2<K, V> dic, K key, Func`1<V> factory);
}
[ExtensionAttribute]
public static class DotLiquid.Util.EnumerableExtensionMethods : object {
    [IteratorStateMachineAttribute("DotLiquid.Util.EnumerableExtensionMethods/<Flatten>d__0")]
[ExtensionAttribute]
public static IEnumerable Flatten(IEnumerable array);
    [ExtensionAttribute]
public static void EachWithIndex(IEnumerable`1<object> array, Action`2<object, int> callback);
    [ExtensionAttribute]
public static bool Any(IEnumerable source);
}
public static class DotLiquid.Util.ExpressionUtility : object {
    private static Dictionary`2<Type, Type[]> NumericTypePromotions;
    private static ExpressionUtility();
    internal static Type BinaryNumericResultType(Type left, Type right);
    private static void Cast(Expression lhs, Expression rhs, Type leftType, Type rightType, Type resultType, Expression& castLhs, Expression& castRhs);
    public static Delegate CreateExpression(Func`3<Expression, Expression, BinaryExpression> body, Type leftType, Type rightType);
    [CompilerGeneratedAttribute]
internal static void <.cctor>g__Add|1_0(Type key, Type[] types);
}
[ExtensionAttribute]
public static class DotLiquid.Util.ListExtensionMethods : object {
    [ExtensionAttribute]
public static T TryGetAtIndex(List`1<T> list, int index);
    [ExtensionAttribute]
public static T TryGetAtIndexReverse(List`1<T> list, int rindex);
    [ExtensionAttribute]
public static T Shift(List`1<T> list);
    [ExtensionAttribute]
public static T Pop(List`1<T> list);
}
[ExtensionAttribute]
public static class DotLiquid.Util.MethodInfoExtensionMethods : object {
    [ExtensionAttribute]
public static int GetNonContextParameterCount(MethodInfo method);
    [ExtensionAttribute]
public static bool MatchesMethod(MethodInfo method, KeyValuePair`2<string, IList`1<Tuple`2<object, MethodInfo>>> compareMethod);
}
[ExtensionAttribute]
public static class DotLiquid.Util.ObjectExtensionMethods : object {
    private static HashSet`1<HashSet`1<Type>> _BackCompatComparableTypeBoundaries;
    private static ObjectExtensionMethods();
    [ExtensionAttribute]
public static bool RespondTo(object value, string member, bool ensureNoParameters);
    [ExtensionAttribute]
public static object Send(object value, string member, Object[] parameters);
    [ExtensionAttribute]
public static object GetPropertyValue(object object, string propertyName);
    [ExtensionAttribute]
public static bool BackCompatSafeTypeInsensitiveEqual(object value, object otherValue);
    [ExtensionAttribute]
public static bool SafeTypeInsensitiveEqual(object value, object otherValue);
    [ExtensionAttribute]
public static bool IsTruthy(object any);
    [ExtensionAttribute]
public static bool IsFalsy(object any);
}
public static class DotLiquid.Util.R : object {
    public static string Q(string regex);
    public static Regex B(string format, String[] args);
    public static Regex C(string pattern, RegexOptions options);
    public static List`1<string> Scan(string input, Regex regex);
    [ObsoleteAttribute("Use Scan(string, Regex) instead.")]
public static List`1<string> Scan(string input, string pattern);
    public static void Scan(string input, string pattern, Action`2<string, string> callback);
}
internal static class DotLiquid.Util.Range : object {
    internal static long Succ(long val);
    internal static int Succ(int val);
    internal static short Succ(short val);
    internal static sbyte Succ(sbyte val);
    internal static ulong Succ(ulong val);
    internal static UInt32 Succ(UInt32 val);
    internal static ushort Succ(ushort val);
    internal static byte Succ(byte val);
    internal static char Succ(char val);
    internal static DateTime Succ(DateTime val);
    internal static string Succ(string val);
    internal static string Succ(string val, int length);
    [IteratorStateMachineAttribute("DotLiquid.Util.Range/<Inclusive>d__12`1")]
public static IEnumerable`1<T> Inclusive(T start, T finish, Func`2<T, T> succ, Comparison`1<T> comp);
    internal static int Comp(T a, T b);
    public static IEnumerable`1<T> Inclusive(T start, T finish, Func`2<T, T> succ);
    public static IEnumerable`1<DateTime> Inclusive(DateTime start, DateTime finish);
    public static IEnumerable`1<string> Inclusive(string start, string finish);
    public static IEnumerable`1<int> Inclusive(int start, int finish);
}
internal class DotLiquid.Util.ReflectionCacheValue : object {
    private static TypeAttributes AnonymousTypeAttributes;
    private Type _type;
    private Lazy`1<bool> _isAnonymous;
    public bool IsAnonymous { get; }
    public ReflectionCacheValue(Type type);
    public bool get_IsAnonymous();
    private bool IsAnonymousInternal();
    [CompilerGeneratedAttribute]
private bool <.ctor>b__3_0();
}
[ExtensionAttribute]
public static class DotLiquid.Util.StrFTime : object {
    private static string GROUP_FLAGS;
    private static string GROUP_WIDTH;
    private static string GROUP_DIRECTIVE;
    private static string SPECIFIER_REGEX;
    private static Dictionary`2<string, DateTimeDelegate> Formats;
    private static Dictionary`2<string, DateTimeOffsetDelegate> OffsetFormats;
    private static StrFTime();
    [ExtensionAttribute]
public static string ToStrFTime(DateTime dateTime, string format, CultureInfo culture);
    [ExtensionAttribute]
public static string ToStrFTime(DateTimeOffset dateTimeOffset, string format, CultureInfo culture);
    private static string SpecifierEvaluator(string specifier, IEnumerable`1<string> flags, Nullable`1<int> width, string directive, object source, CultureInfo culture);
    private static string PreProcessDirective(string directive, IEnumerable`1<string> flags, Nullable`1<int> width);
    private static string ApplyFlag(string flag, int padwidth, string str);
    [ExtensionAttribute]
private static string GetIso8601WeekOfYear(DateTime dateTime, string directive, CultureInfo culture);
}
internal class DotLiquid.Util.Symbol : object {
    [CompilerGeneratedAttribute]
private Func`2<object, bool> <EvaluationFunction>k__BackingField;
    public Func`2<object, bool> EvaluationFunction { get; public set; }
    public Symbol(Func`2<object, bool> evaluationFunction);
    [CompilerGeneratedAttribute]
public Func`2<object, bool> get_EvaluationFunction();
    [CompilerGeneratedAttribute]
public void set_EvaluationFunction(Func`2<object, bool> value);
}
internal static class DotLiquid.Util.TypeUtility : object {
    private static ConditionalWeakTable`2<Type, ReflectionCacheValue> _cache;
    private static TypeUtility();
    public static bool IsAnonymousType(Type t);
}
[DefaultMemberAttribute("Item")]
internal class DotLiquid.Util.WeakTable`2 : object {
    private Bucket[] _buckets;
    public TValue Item { get; public set; }
    public WeakTable`2(int size);
    public TValue get_Item(TKey key);
    public void set_Item(TKey key, TValue value);
    public bool TryGetValue(TKey key, TValue& value);
    public void Remove(TKey key);
}
public class DotLiquid.Variable : object {
    private static Regex FilterParserRegex;
    private static Regex FilterArgRegex;
    private static Regex QuotedAssignFragmentRegex;
    private static Regex FilterSeparatorRegex;
    private static Regex FilterNameRegex;
    [CompilerGeneratedAttribute]
private List`1<Filter> <Filters>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    private string _markup;
    public List`1<Filter> Filters { get; public set; }
    public string Name { get; public set; }
    public Variable(string markup);
    private static Variable();
    [CompilerGeneratedAttribute]
public List`1<Filter> get_Filters();
    [CompilerGeneratedAttribute]
public void set_Filters(List`1<Filter> value);
    [CompilerGeneratedAttribute]
public string get_Name();
    [CompilerGeneratedAttribute]
public void set_Name(string value);
    public sealed virtual void Render(Context context, TextWriter result);
    private object RenderInternal(Context context);
    internal object Render(Context context);
    [CompilerGeneratedAttribute]
internal static string <Render>g__ToFormattedString|15_0(object obj, IFormatProvider formatProvider);
}
