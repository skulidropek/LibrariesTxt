[CompilerGeneratedAttribute]
[EmbeddedAttribute]
internal class Microsoft.CodeAnalysis.EmbeddedAttribute : Attribute {
}
internal class Microsoft.Diagnostics.NETCore.Client.BackendStreamTimeoutException : TimeoutException {
    public BackendStreamTimeoutException(int TimeoutMs);
}
[ExtensionAttribute]
internal static class Microsoft.Diagnostics.NETCore.Client.BinaryWriterExtensions : object {
    [ExtensionAttribute]
public static void WriteString(BinaryWriter this, string value);
}
internal class Microsoft.Diagnostics.NETCore.Client.DiagnosticPortIpcEndpoint : IpcEndpoint {
    private IpcEndpointConfig _config;
    public DiagnosticPortIpcEndpoint(string diagnosticPort);
    public DiagnosticPortIpcEndpoint(IpcEndpointConfig config);
    public virtual Stream Connect(TimeSpan timeout);
    [AsyncStateMachineAttribute("Microsoft.Diagnostics.NETCore.Client.DiagnosticPortIpcEndpoint/<ConnectAsync>d__4")]
public virtual Task`1<Stream> ConnectAsync(CancellationToken token);
    public virtual void WaitForConnection(TimeSpan timeout);
    [AsyncStateMachineAttribute("Microsoft.Diagnostics.NETCore.Client.DiagnosticPortIpcEndpoint/<WaitForConnectionAsync>d__6")]
public virtual Task WaitForConnectionAsync(CancellationToken token);
    public virtual bool Equals(object obj);
    public bool Equals(DiagnosticPortIpcEndpoint other);
    public virtual int GetHashCode();
}
public class Microsoft.Diagnostics.NETCore.Client.DiagnosticsClient : object {
    private static int DefaultCircularBufferMB;
    private IpcEndpoint _endpoint;
    public DiagnosticsClient(int processId);
    internal DiagnosticsClient(IpcEndpointConfig config);
    internal DiagnosticsClient(IpcEndpoint endpoint);
    internal void WaitForConnection(TimeSpan timeout);
    internal Task WaitForConnectionAsync(CancellationToken token);
    public EventPipeSession StartEventPipeSession(IEnumerable`1<EventPipeProvider> providers, bool requestRundown, int circularBufferMB);
    public EventPipeSession StartEventPipeSession(EventPipeProvider provider, bool requestRundown, int circularBufferMB);
    public EventPipeSession StartEventPipeSession(EventPipeSessionConfiguration config);
    public Task`1<EventPipeSession> StartEventPipeSessionAsync(IEnumerable`1<EventPipeProvider> providers, bool requestRundown, int circularBufferMB, CancellationToken token);
    public Task`1<EventPipeSession> StartEventPipeSessionAsync(EventPipeProvider provider, bool requestRundown, int circularBufferMB, CancellationToken token);
    public Task`1<EventPipeSession> StartEventPipeSessionAsync(EventPipeSessionConfiguration configuration, CancellationToken token);
    public void WriteDump(DumpType dumpType, string dumpPath, bool logDumpGeneration);
    public void WriteDump(DumpType dumpType, string dumpPath, WriteDumpFlags flags);
    public Task WriteDumpAsync(DumpType dumpType, string dumpPath, bool logDumpGeneration, CancellationToken token);
    [AsyncStateMachineAttribute("Microsoft.Diagnostics.NETCore.Client.DiagnosticsClient/<WriteDumpAsync>d__16")]
public Task WriteDumpAsync(DumpType dumpType, string dumpPath, WriteDumpFlags flags, CancellationToken token);
    public void AttachProfiler(TimeSpan attachTimeout, Guid profilerGuid, string profilerPath, Byte[] additionalData);
    [AsyncStateMachineAttribute("Microsoft.Diagnostics.NETCore.Client.DiagnosticsClient/<AttachProfilerAsync>d__18")]
internal Task AttachProfilerAsync(TimeSpan attachTimeout, Guid profilerGuid, string profilerPath, Byte[] additionalData, CancellationToken token);
    public void SetStartupProfiler(Guid profilerGuid, string profilerPath);
    [AsyncStateMachineAttribute("Microsoft.Diagnostics.NETCore.Client.DiagnosticsClient/<SetStartupProfilerAsync>d__20")]
internal Task SetStartupProfilerAsync(Guid profilerGuid, string profilerPath, CancellationToken token);
    public void ResumeRuntime();
    [AsyncStateMachineAttribute("Microsoft.Diagnostics.NETCore.Client.DiagnosticsClient/<ResumeRuntimeAsync>d__22")]
internal Task ResumeRuntimeAsync(CancellationToken token);
    public void SetEnvironmentVariable(string name, string value);
    [AsyncStateMachineAttribute("Microsoft.Diagnostics.NETCore.Client.DiagnosticsClient/<SetEnvironmentVariableAsync>d__24")]
internal Task SetEnvironmentVariableAsync(string name, string value, CancellationToken token);
    public Dictionary`2<string, string> GetProcessEnvironment();
    [AsyncStateMachineAttribute("Microsoft.Diagnostics.NETCore.Client.DiagnosticsClient/<GetProcessEnvironmentAsync>d__26")]
internal Task`1<Dictionary`2<string, string>> GetProcessEnvironmentAsync(CancellationToken token);
    internal void ApplyStartupHook(string startupHookPath);
    [AsyncStateMachineAttribute("Microsoft.Diagnostics.NETCore.Client.DiagnosticsClient/<ApplyStartupHookAsync>d__28")]
internal Task ApplyStartupHookAsync(string startupHookPath, CancellationToken token);
    public void EnablePerfMap(PerfMapType type);
    [AsyncStateMachineAttribute("Microsoft.Diagnostics.NETCore.Client.DiagnosticsClient/<EnablePerfMapAsync>d__30")]
internal Task EnablePerfMapAsync(PerfMapType type, CancellationToken token);
    public void DisablePerfMap();
    [AsyncStateMachineAttribute("Microsoft.Diagnostics.NETCore.Client.DiagnosticsClient/<DisablePerfMapAsync>d__32")]
internal Task DisablePerfMapAsync(CancellationToken token);
    public static IEnumerable`1<int> GetPublishedProcesses();
    internal ProcessInfo GetProcessInfo();
    [AsyncStateMachineAttribute("Microsoft.Diagnostics.NETCore.Client.DiagnosticsClient/<GetProcessInfoAsync>d__35")]
internal Task`1<ProcessInfo> GetProcessInfoAsync(CancellationToken token);
    private ProcessInfo TryGetProcessInfo2();
    [AsyncStateMachineAttribute("Microsoft.Diagnostics.NETCore.Client.DiagnosticsClient/<TryGetProcessInfo2Async>d__37")]
private Task`1<ProcessInfo> TryGetProcessInfo2Async(CancellationToken token);
    private ProcessInfo TryGetProcessInfo3();
    [AsyncStateMachineAttribute("Microsoft.Diagnostics.NETCore.Client.DiagnosticsClient/<TryGetProcessInfo3Async>d__39")]
private Task`1<ProcessInfo> TryGetProcessInfo3Async(CancellationToken token);
    private static Byte[] SerializePayload(T arg);
    private static Byte[] SerializePayload(T1 arg1, T2 arg2);
    private static Byte[] SerializePayload(T1 arg1, T2 arg2, T3 arg3);
    private static Byte[] SerializePayload(T1 arg1, T2 arg2, T3 arg3, T4 arg4);
    private static void SerializePayloadArgument(T obj, BinaryWriter writer);
    private static IpcMessage CreateAttachProfilerMessage(TimeSpan attachTimeout, Guid profilerGuid, string profilerPath, Byte[] additionalData);
    private static IpcMessage CreateProcessEnvironmentMessage();
    private static IpcMessage CreateProcessInfoMessage();
    private static IpcMessage CreateProcessInfo2Message();
    private static IpcMessage CreateProcessInfo3Message();
    private static IpcMessage CreateResumeRuntimeMessage();
    private static IpcMessage CreateSetEnvironmentVariableMessage(string name, string value);
    private static IpcMessage CreateSetStartupProfilerMessage(Guid profilerGuid, string profilerPath);
    private static IpcMessage CreateWriteDumpMessage(DumpType dumpType, string dumpPath, bool logDumpGeneration);
    private static IpcMessage CreateWriteDumpMessage(DumpCommandId command, DumpType dumpType, string dumpPath, WriteDumpFlags flags);
    private static IpcMessage CreateApplyStartupHookMessage(string startupHookPath);
    private static IpcMessage CreateEnablePerfMapMessage(PerfMapType type);
    private static IpcMessage CreateDisablePerfMapMessage();
    private static ProcessInfo GetProcessInfoFromResponse(IpcResponse response, string operationName);
    private static ProcessInfo TryGetProcessInfo2FromResponse(IpcResponse response, string operationName);
    private static ProcessInfo TryGetProcessInfo3FromResponse(IpcResponse response, string operationName);
    internal static bool ValidateResponseMessage(IpcMessage responseMessage, string operationName, ValidateResponseOptions options);
    [IteratorStateMachineAttribute("Microsoft.Diagnostics.NETCore.Client.DiagnosticsClient/<<GetPublishedProcesses>g__GetAllPublishedProcesses|33_0>d")]
[CompilerGeneratedAttribute]
internal static IEnumerable`1<int> <GetPublishedProcesses>g__GetAllPublishedProcesses|33_0(String[] files);
}
public class Microsoft.Diagnostics.NETCore.Client.DiagnosticsClientException : Exception {
    public DiagnosticsClientException(string msg);
    public DiagnosticsClientException(string msg, Exception exception);
}
internal enum Microsoft.Diagnostics.NETCore.Client.DiagnosticsIpcError : Enum {
    public UInt32 value__;
    public static DiagnosticsIpcError Fail;
    public static DiagnosticsIpcError InvalidArgument;
    public static DiagnosticsIpcError NotSupported;
    public static DiagnosticsIpcError ProfilerAlreadyActive;
    public static DiagnosticsIpcError BadEncoding;
    public static DiagnosticsIpcError UnknownCommand;
    public static DiagnosticsIpcError UnknownMagic;
    public static DiagnosticsIpcError UnknownError;
}
internal enum Microsoft.Diagnostics.NETCore.Client.DiagnosticsMessageType : Enum {
    public UInt32 value__;
    public static DiagnosticsMessageType GenerateCoreDump;
    public static DiagnosticsMessageType StartEventPipeTracing;
    public static DiagnosticsMessageType StopEventPipeTracing;
    public static DiagnosticsMessageType CollectEventPipeTracing;
    public static DiagnosticsMessageType AttachProfiler;
}
internal enum Microsoft.Diagnostics.NETCore.Client.DiagnosticsServerCommandSet : Enum {
    public byte value__;
    public static DiagnosticsServerCommandSet Dump;
    public static DiagnosticsServerCommandSet EventPipe;
    public static DiagnosticsServerCommandSet Profiler;
    public static DiagnosticsServerCommandSet Process;
    public static DiagnosticsServerCommandSet Server;
}
internal enum Microsoft.Diagnostics.NETCore.Client.DiagnosticsServerResponseId : Enum {
    public byte value__;
    public static DiagnosticsServerResponseId OK;
    public static DiagnosticsServerResponseId Error;
}
internal class Microsoft.Diagnostics.NETCore.Client.DiagnosticsServerRouterFactory : object {
    [CompilerGeneratedAttribute]
private int <IsStreamConnectedTimeoutMs>k__BackingField;
    [CompilerGeneratedAttribute]
private string <IpcAddress>k__BackingField;
    [CompilerGeneratedAttribute]
private string <TcpAddress>k__BackingField;
    [CompilerGeneratedAttribute]
private ILogger <Logger>k__BackingField;
    private int IsStreamConnectedTimeoutMs { get; private set; }
    public string IpcAddress { get; }
    public string TcpAddress { get; }
    public ILogger Logger { get; }
    [CompilerGeneratedAttribute]
private int get_IsStreamConnectedTimeoutMs();
    [CompilerGeneratedAttribute]
private void set_IsStreamConnectedTimeoutMs(int value);
    [CompilerGeneratedAttribute]
public virtual string get_IpcAddress();
    [CompilerGeneratedAttribute]
public virtual string get_TcpAddress();
    [CompilerGeneratedAttribute]
public virtual ILogger get_Logger();
    public virtual Task Start(CancellationToken token);
    public virtual Task Stop();
    public virtual void Reset();
    public virtual Task`1<Router> CreateRouterAsync(CancellationToken token);
    protected static bool IsStreamConnected(Stream stream);
    [AsyncStateMachineAttribute("Microsoft.Diagnostics.NETCore.Client.DiagnosticsServerRouterFactory/<IsStreamConnectedAsync>d__18")]
protected Task IsStreamConnectedAsync(Stream stream, CancellationToken token);
    protected static bool IsCompletedSuccessfully(Task t);
}
internal static class Microsoft.Diagnostics.NETCore.Client.DiagnosticsServerRouterRunner : object {
    [AsyncStateMachineAttribute("Microsoft.Diagnostics.NETCore.Client.DiagnosticsServerRouterRunner/<runIpcClientTcpServerRouter>d__1")]
public static Task`1<int> runIpcClientTcpServerRouter(CancellationToken token, string ipcClient, string tcpServer, int runtimeTimeoutMs, CreateInstanceDelegate tcpServerRouterFactory, ILogger logger, ICallbacks callbacks);
    [AsyncStateMachineAttribute("Microsoft.Diagnostics.NETCore.Client.DiagnosticsServerRouterRunner/<runIpcServerTcpServerRouter>d__2")]
public static Task`1<int> runIpcServerTcpServerRouter(CancellationToken token, string ipcServer, string tcpServer, int runtimeTimeoutMs, CreateInstanceDelegate tcpServerRouterFactory, ILogger logger, ICallbacks callbacks);
    [AsyncStateMachineAttribute("Microsoft.Diagnostics.NETCore.Client.DiagnosticsServerRouterRunner/<runIpcServerTcpClientRouter>d__3")]
public static Task`1<int> runIpcServerTcpClientRouter(CancellationToken token, string ipcServer, string tcpClient, int runtimeTimeoutMs, CreateInstanceDelegate tcpClientRouterFactory, ILogger logger, ICallbacks callbacks);
    [AsyncStateMachineAttribute("Microsoft.Diagnostics.NETCore.Client.DiagnosticsServerRouterRunner/<runIpcClientTcpClientRouter>d__4")]
public static Task`1<int> runIpcClientTcpClientRouter(CancellationToken token, string ipcClient, string tcpClient, int runtimeTimeoutMs, CreateInstanceDelegate tcpClientRouterFactory, ILogger logger, ICallbacks callbacks);
    public static bool isLoopbackOnly(string address);
    [AsyncStateMachineAttribute("Microsoft.Diagnostics.NETCore.Client.DiagnosticsServerRouterRunner/<runRouter>d__6")]
private static Task`1<int> runRouter(CancellationToken token, DiagnosticsServerRouterFactory routerFactory, ICallbacks callbacks);
    private static bool IsRouterDead(Router router);
}
internal enum Microsoft.Diagnostics.NETCore.Client.DumpCommandId : Enum {
    public byte value__;
    public static DumpCommandId GenerateCoreDump;
    public static DumpCommandId GenerateCoreDump2;
    public static DumpCommandId GenerateCoreDump3;
}
public enum Microsoft.Diagnostics.NETCore.Client.DumpType : Enum {
    public int value__;
    public static DumpType Normal;
    public static DumpType WithHeap;
    public static DumpType Triage;
    public static DumpType Full;
}
internal enum Microsoft.Diagnostics.NETCore.Client.EventPipeCommandId : Enum {
    public byte value__;
    public static EventPipeCommandId StopTracing;
    public static EventPipeCommandId CollectTracing;
    public static EventPipeCommandId CollectTracing2;
    public static EventPipeCommandId CollectTracing3;
    public static EventPipeCommandId CollectTracing4;
}
public class Microsoft.Diagnostics.NETCore.Client.EventPipeProvider : object {
    [CompilerGeneratedAttribute]
private long <Keywords>k__BackingField;
    [CompilerGeneratedAttribute]
private EventLevel <EventLevel>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    [CompilerGeneratedAttribute]
private IDictionary`2<string, string> <Arguments>k__BackingField;
    public long Keywords { get; }
    public EventLevel EventLevel { get; }
    public string Name { get; }
    public IDictionary`2<string, string> Arguments { get; }
    public EventPipeProvider(string name, EventLevel eventLevel, long keywords, IDictionary`2<string, string> arguments);
    [CompilerGeneratedAttribute]
public long get_Keywords();
    [CompilerGeneratedAttribute]
public EventLevel get_EventLevel();
    [CompilerGeneratedAttribute]
public string get_Name();
    [CompilerGeneratedAttribute]
public IDictionary`2<string, string> get_Arguments();
    public virtual string ToString();
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public static bool op_Equality(EventPipeProvider left, EventPipeProvider right);
    public static bool op_Inequality(EventPipeProvider left, EventPipeProvider right);
    internal string GetArgumentString();
}
internal enum Microsoft.Diagnostics.NETCore.Client.EventPipeSerializationFormat : Enum {
    public int value__;
    public static EventPipeSerializationFormat NetPerf;
    public static EventPipeSerializationFormat NetTrace;
}
public class Microsoft.Diagnostics.NETCore.Client.EventPipeSession : object {
    internal static long DefaultRundownKeyword;
    private ulong _sessionId;
    private IpcEndpoint _endpoint;
    private bool _disposedValue;
    private bool _stopped;
    private IpcResponse _response;
    public Stream EventStream { get; }
    private EventPipeSession(IpcEndpoint endpoint, IpcResponse response, ulong sessionId);
    public Stream get_EventStream();
    internal static EventPipeSession Start(IpcEndpoint endpoint, EventPipeSessionConfiguration config);
    [AsyncStateMachineAttribute("Microsoft.Diagnostics.NETCore.Client.EventPipeSession/<StartAsync>d__10")]
internal static Task`1<EventPipeSession> StartAsync(IpcEndpoint endpoint, EventPipeSessionConfiguration config, CancellationToken cancellationToken);
    public void Stop();
    [AsyncStateMachineAttribute("Microsoft.Diagnostics.NETCore.Client.EventPipeSession/<StopAsync>d__12")]
public Task StopAsync(CancellationToken cancellationToken);
    private static IpcMessage CreateStartMessage(EventPipeSessionConfiguration config);
    private static EventPipeSession CreateSessionFromResponse(IpcEndpoint endpoint, Nullable`1& response, string operationName);
    private bool TryCreateStopMessage(IpcMessage& stopMessage);
    protected virtual void Dispose(bool disposing);
    public sealed virtual void Dispose();
}
public class Microsoft.Diagnostics.NETCore.Client.EventPipeSessionConfiguration : object {
    [CompilerGeneratedAttribute]
private int <CircularBufferSizeInMB>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <RequestStackwalk>k__BackingField;
    [CompilerGeneratedAttribute]
private long <RundownKeyword>k__BackingField;
    private List`1<EventPipeProvider> _providers;
    [CompilerGeneratedAttribute]
private EventPipeSerializationFormat <Format>k__BackingField;
    public bool RequestRundown { get; }
    public int CircularBufferSizeInMB { get; }
    public bool RequestStackwalk { get; }
    public long RundownKeyword { get; internal set; }
    public IReadOnlyCollection`1<EventPipeProvider> Providers { get; }
    internal EventPipeSerializationFormat Format { get; }
    public EventPipeSessionConfiguration(IEnumerable`1<EventPipeProvider> providers, int circularBufferSizeMB, bool requestRundown, bool requestStackwalk);
    public EventPipeSessionConfiguration(IEnumerable`1<EventPipeProvider> providers, int circularBufferSizeMB, long rundownKeyword, bool requestStackwalk);
    private EventPipeSessionConfiguration(int circularBufferSizeMB, EventPipeSerializationFormat format, IEnumerable`1<EventPipeProvider> providers, bool requestStackwalk, long rundownKeyword);
    public bool get_RequestRundown();
    [CompilerGeneratedAttribute]
public int get_CircularBufferSizeInMB();
    [CompilerGeneratedAttribute]
public bool get_RequestStackwalk();
    [CompilerGeneratedAttribute]
public long get_RundownKeyword();
    [CompilerGeneratedAttribute]
internal void set_RundownKeyword(long value);
    public IReadOnlyCollection`1<EventPipeProvider> get_Providers();
    [CompilerGeneratedAttribute]
internal EventPipeSerializationFormat get_Format();
}
[ExtensionAttribute]
internal static class Microsoft.Diagnostics.NETCore.Client.EventPipeSessionConfigurationExtensions : object {
    [ExtensionAttribute]
public static Byte[] SerializeV2(EventPipeSessionConfiguration config);
    [ExtensionAttribute]
public static Byte[] SerializeV3(EventPipeSessionConfiguration config);
    [ExtensionAttribute]
public static Byte[] SerializeV4(EventPipeSessionConfiguration config);
    private static void SerializeProviders(EventPipeSessionConfiguration config, BinaryWriter writer);
}
internal class Microsoft.Diagnostics.NETCore.Client.ExposedSocketNetworkStream : NetworkStream {
    public Socket Socket { get; }
    public ExposedSocketNetworkStream(Socket socket, bool ownsSocket);
    public Socket get_Socket();
}
internal class Microsoft.Diagnostics.NETCore.Client.HandleableCollection`1 : object {
    private static Handler<T> DefaultHandler;
    private List`1<T> _items;
    private List`1<Tuple`2<TaskCompletionSource`1<T>, Handler<T>>> _handlers;
    private bool _disposed;
    private static HandleableCollection`1();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    private sealed virtual override IEnumerator`1<T> System.Collections.Generic.IEnumerable<T>.GetEnumerator();
    public sealed virtual void Dispose();
    public void Add(T& item);
    public T Handle(TimeSpan timeout);
    public T Handle(Handler<T> handler, TimeSpan timeout);
    public Task`1<T> HandleAsync(CancellationToken token);
    [AsyncStateMachineAttribute("Microsoft.Diagnostics.NETCore.Client.HandleableCollection`1/<HandleAsync>d__12")]
public Task`1<T> HandleAsync(Handler<T> handler, CancellationToken token);
    private void RunOrQueueHandler(Handler<T> handler, TaskCompletionSource`1<T> completionSource);
    private static bool TryHandler(T& item, Handler<T> handler, TaskCompletionSource`1<T> completionSource, Boolean& removeItem);
    public void ClearItems();
    private void RemoveAndDisposeItems();
    private void VerifyNotDisposed();
    protected virtual void OnHandlerBegin();
}
internal interface Microsoft.Diagnostics.NETCore.Client.IIpcServerTransportCallbackInternal {
    public abstract virtual void CreatedNewServer(EndPoint localEP);
}
internal class Microsoft.Diagnostics.NETCore.Client.IpcAdvertise : object {
    private static int IpcAdvertiseV1SizeInBytes;
    [CompilerGeneratedAttribute]
private static int <V1SizeInBytes>k__BackingField;
    [CompilerGeneratedAttribute]
private ushort <Future>k__BackingField;
    [CompilerGeneratedAttribute]
private Byte[] <Magic>k__BackingField;
    [CompilerGeneratedAttribute]
private ulong <ProcessId>k__BackingField;
    [CompilerGeneratedAttribute]
private Guid <RuntimeInstanceCookie>k__BackingField;
    private static Byte[] Magic_V1 { get; }
    public static int V1SizeInBytes { get; }
    private ushort Future { get; }
    public Byte[] Magic { get; }
    public ulong ProcessId { get; }
    public Guid RuntimeInstanceCookie { get; }
    private IpcAdvertise(Byte[] magic, Guid cookie, ulong pid, ushort future);
    private static IpcAdvertise();
    private static Byte[] get_Magic_V1();
    [CompilerGeneratedAttribute]
public static int get_V1SizeInBytes();
    [AsyncStateMachineAttribute("Microsoft.Diagnostics.NETCore.Client.IpcAdvertise/<ParseAsync>d__7")]
public static Task`1<IpcAdvertise> ParseAsync(Stream stream, CancellationToken token);
    [AsyncStateMachineAttribute("Microsoft.Diagnostics.NETCore.Client.IpcAdvertise/<SerializeAsync>d__8")]
public static Task SerializeAsync(Stream stream, Guid runtimeInstanceCookie, ulong processId, CancellationToken token);
    public virtual string ToString();
    [CompilerGeneratedAttribute]
private ushort get_Future();
    [CompilerGeneratedAttribute]
public Byte[] get_Magic();
    [CompilerGeneratedAttribute]
public ulong get_ProcessId();
    [CompilerGeneratedAttribute]
public Guid get_RuntimeInstanceCookie();
}
internal static class Microsoft.Diagnostics.NETCore.Client.IpcClient : object {
    internal static TimeSpan ConnectTimeout;
    private static IpcClient();
    public static IpcMessage SendMessage(IpcEndpoint endpoint, IpcMessage message);
    public static IpcResponse SendMessageGetContinuation(IpcEndpoint endpoint, IpcMessage message);
    [AsyncStateMachineAttribute("Microsoft.Diagnostics.NETCore.Client.IpcClient/<SendMessageAsync>d__3")]
public static Task`1<IpcMessage> SendMessageAsync(IpcEndpoint endpoint, IpcMessage message, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.Diagnostics.NETCore.Client.IpcClient/<SendMessageGetContinuationAsync>d__4")]
public static Task`1<IpcResponse> SendMessageGetContinuationAsync(IpcEndpoint endpoint, IpcMessage message, CancellationToken cancellationToken);
    private static void Write(Stream stream, IpcMessage message);
    private static Task WriteAsync(Stream stream, IpcMessage message, CancellationToken cancellationToken);
    private static IpcMessage Read(Stream stream);
    private static Task`1<IpcMessage> ReadAsync(Stream stream, CancellationToken cancellationToken);
    private static Stream Release(Stream& stream1);
}
internal class Microsoft.Diagnostics.NETCore.Client.IpcClientRouterFactory : object {
    private ILogger _logger;
    private string _ipcClientPath;
    [CompilerGeneratedAttribute]
private int <IpcClientTimeoutMs>k__BackingField;
    [CompilerGeneratedAttribute]
private int <IpcClientRetryTimeoutMs>k__BackingField;
    private int IpcClientTimeoutMs { get; private set; }
    private int IpcClientRetryTimeoutMs { get; private set; }
    public string IpcClientPath { get; }
    public IpcClientRouterFactory(string ipcClient, ILogger logger);
    [CompilerGeneratedAttribute]
private int get_IpcClientTimeoutMs();
    [CompilerGeneratedAttribute]
private void set_IpcClientTimeoutMs(int value);
    [CompilerGeneratedAttribute]
private int get_IpcClientRetryTimeoutMs();
    [CompilerGeneratedAttribute]
private void set_IpcClientRetryTimeoutMs(int value);
    public string get_IpcClientPath();
    [AsyncStateMachineAttribute("Microsoft.Diagnostics.NETCore.Client.IpcClientRouterFactory/<ConnectIpcStreamAsync>d__13")]
public Task`1<Stream> ConnectIpcStreamAsync(CancellationToken token);
}
internal class Microsoft.Diagnostics.NETCore.Client.IpcClientTcpClientRouterFactory : DiagnosticsServerRouterFactory {
    private bool _updateRuntimeInfo;
    private Guid _runtimeInstanceId;
    private ulong _runtimeProcessId;
    private ILogger _logger;
    private IpcClientRouterFactory _ipcClientRouterFactory;
    private TcpClientRouterFactory _tcpClientRouterFactory;
    public string IpcAddress { get; }
    public string TcpAddress { get; }
    public ILogger Logger { get; }
    public IpcClientTcpClientRouterFactory(string ipcClient, string tcpClient, int runtimeTimeoutMs, CreateInstanceDelegate factory, ILogger logger);
    public virtual string get_IpcAddress();
    public virtual string get_TcpAddress();
    public virtual ILogger get_Logger();
    public virtual Task Start(CancellationToken token);
    public virtual Task Stop();
    [AsyncStateMachineAttribute("Microsoft.Diagnostics.NETCore.Client.IpcClientTcpClientRouterFactory/<CreateRouterAsync>d__15")]
public virtual Task`1<Router> CreateRouterAsync(CancellationToken token);
    [AsyncStateMachineAttribute("Microsoft.Diagnostics.NETCore.Client.IpcClientTcpClientRouterFactory/<InitFrontendReadBackendWrite>d__16")]
private Task`1<int> InitFrontendReadBackendWrite(Stream ipcClientStream, Stream tcpClientStream, CancellationToken token);
    [AsyncStateMachineAttribute("Microsoft.Diagnostics.NETCore.Client.IpcClientTcpClientRouterFactory/<UpdateRuntimeInfo>d__17")]
private Task UpdateRuntimeInfo(CancellationToken token);
}
internal class Microsoft.Diagnostics.NETCore.Client.IpcClientTcpServerRouterFactory : DiagnosticsServerRouterFactory {
    private ILogger _logger;
    private IpcClientRouterFactory _ipcClientRouterFactory;
    private NetServerRouterFactory _tcpServerRouterFactory;
    public string IpcAddress { get; }
    public string TcpAddress { get; }
    public ILogger Logger { get; }
    public IpcClientTcpServerRouterFactory(string ipcClient, string tcpServer, int runtimeTimeoutMs, CreateInstanceDelegate factory, ILogger logger);
    public virtual string get_IpcAddress();
    public virtual string get_TcpAddress();
    public virtual ILogger get_Logger();
    public virtual Task Start(CancellationToken token);
    public virtual Task Stop();
    public virtual void Reset();
    [AsyncStateMachineAttribute("Microsoft.Diagnostics.NETCore.Client.IpcClientTcpServerRouterFactory/<CreateRouterAsync>d__13")]
public virtual Task`1<Router> CreateRouterAsync(CancellationToken token);
}
internal abstract class Microsoft.Diagnostics.NETCore.Client.IpcEndpoint : object {
    public abstract virtual Stream Connect(TimeSpan timeout);
    public abstract virtual Task`1<Stream> ConnectAsync(CancellationToken token);
    public abstract virtual void WaitForConnection(TimeSpan timeout);
    public abstract virtual Task WaitForConnectionAsync(CancellationToken token);
}
internal class Microsoft.Diagnostics.NETCore.Client.IpcEndpointConfig : object {
    private PortType _portType;
    private TransportType _transportType;
    [CompilerGeneratedAttribute]
private string <Address>k__BackingField;
    private static string NamedPipeSchema;
    private static string UnixDomainSocketSchema;
    private static string NamedPipeDefaultIPCRoot;
    private static string NamedPipeSchemaDefaultIPCRootPath;
    public string Address { get; }
    public bool IsConnectConfig { get; }
    public bool IsListenConfig { get; }
    public TransportType Transport { get; }
    public IpcEndpointConfig(string address, TransportType transportType, PortType portType);
    [CompilerGeneratedAttribute]
public string get_Address();
    public bool get_IsConnectConfig();
    public bool get_IsListenConfig();
    public TransportType get_Transport();
    public static bool TryParse(string config, IpcEndpointConfig& result);
    public static IpcEndpointConfig Parse(string config);
}
internal static class Microsoft.Diagnostics.NETCore.Client.IpcEndpointHelper : object {
    public static Stream Connect(IpcEndpointConfig config, TimeSpan timeout);
    [AsyncStateMachineAttribute("Microsoft.Diagnostics.NETCore.Client.IpcEndpointHelper/<ConnectAsync>d__1")]
public static Task`1<Stream> ConnectAsync(IpcEndpointConfig config, CancellationToken token);
}
[DebuggerDisplayAttribute("{DebuggerDisplay,nq}")]
internal class Microsoft.Diagnostics.NETCore.Client.IpcEndpointInfo : ValueType {
    [CompilerGeneratedAttribute]
private IpcEndpoint <Endpoint>k__BackingField;
    [CompilerGeneratedAttribute]
private int <ProcessId>k__BackingField;
    [CompilerGeneratedAttribute]
private Guid <RuntimeInstanceCookie>k__BackingField;
    public IpcEndpoint Endpoint { get; }
    public int ProcessId { get; }
    public Guid RuntimeInstanceCookie { get; }
    internal string DebuggerDisplay { get; }
    internal IpcEndpointInfo(IpcEndpoint endpoint, int processId, Guid runtimeInstanceCookie);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public IpcEndpoint get_Endpoint();
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public int get_ProcessId();
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public Guid get_RuntimeInstanceCookie();
    internal string get_DebuggerDisplay();
}
internal class Microsoft.Diagnostics.NETCore.Client.IpcHeader : object {
    public static ushort HeaderSizeInBytes;
    private static ushort MagicSizeInBytes;
    public Byte[] Magic;
    public ushort Size;
    public byte CommandSet;
    public byte CommandId;
    public ushort Reserved;
    public static Byte[] DotnetIpcV1 { get; }
    public IpcHeader(DiagnosticsServerCommandSet commandSet, byte commandId);
    public static Byte[] get_DotnetIpcV1();
    public Byte[] Serialize();
    public static IpcHeader Parse(BinaryReader reader);
    [AsyncStateMachineAttribute("Microsoft.Diagnostics.NETCore.Client.IpcHeader/<ParseAsync>d__13")]
public static Task`1<IpcHeader> ParseAsync(Stream stream, CancellationToken cancellationToken);
    public virtual string ToString();
}
internal static class Microsoft.Diagnostics.NETCore.Client.IpcHelpers : object {
    public static string ReadString(Byte[] buffer, Int32& index);
}
internal class Microsoft.Diagnostics.NETCore.Client.IpcMessage : object {
    [CompilerGeneratedAttribute]
private Byte[] <Payload>k__BackingField;
    [CompilerGeneratedAttribute]
private IpcHeader <Header>k__BackingField;
    public Byte[] Payload { get; private set; }
    public IpcHeader Header { get; private set; }
    public IpcMessage(IpcHeader header, Byte[] payload);
    public IpcMessage(DiagnosticsServerCommandSet commandSet, byte commandId, Byte[] payload);
    [CompilerGeneratedAttribute]
public Byte[] get_Payload();
    [CompilerGeneratedAttribute]
private void set_Payload(Byte[] value);
    [CompilerGeneratedAttribute]
public IpcHeader get_Header();
    [CompilerGeneratedAttribute]
private void set_Header(IpcHeader value);
    public Byte[] Serialize();
    public static IpcMessage Parse(Stream stream);
    [AsyncStateMachineAttribute("Microsoft.Diagnostics.NETCore.Client.IpcMessage/<ParseAsync>d__13")]
public static Task`1<IpcMessage> ParseAsync(Stream stream, CancellationToken cancellationToken);
}
internal class Microsoft.Diagnostics.NETCore.Client.IpcResponse : ValueType {
    public IpcMessage Message;
    public Stream Continuation;
    public IpcResponse(IpcMessage message, Stream continuation);
    public sealed virtual void Dispose();
}
internal class Microsoft.Diagnostics.NETCore.Client.IpcServerRouterFactory : object {
    private ILogger _logger;
    private string _ipcServerPath;
    private IpcServerTransport _ipcServer;
    [CompilerGeneratedAttribute]
private int <IpcServerTimeoutMs>k__BackingField;
    private int IpcServerTimeoutMs { get; private set; }
    public string IpcServerPath { get; }
    public IpcServerRouterFactory(string ipcServer, ILogger logger);
    [CompilerGeneratedAttribute]
private int get_IpcServerTimeoutMs();
    [CompilerGeneratedAttribute]
private void set_IpcServerTimeoutMs(int value);
    public string get_IpcServerPath();
    public static void Start();
    public void Stop();
    [AsyncStateMachineAttribute("Microsoft.Diagnostics.NETCore.Client.IpcServerRouterFactory/<AcceptIpcStreamAsync>d__12")]
public Task`1<Stream> AcceptIpcStreamAsync(CancellationToken token);
}
internal class Microsoft.Diagnostics.NETCore.Client.IpcServerTcpClientRouterFactory : DiagnosticsServerRouterFactory {
    private ILogger _logger;
    private IpcServerRouterFactory _ipcServerRouterFactory;
    private TcpClientRouterFactory _tcpClientRouterFactory;
    public string IpcAddress { get; }
    public string TcpAddress { get; }
    public ILogger Logger { get; }
    public IpcServerTcpClientRouterFactory(string ipcServer, string tcpClient, int runtimeTimeoutMs, CreateInstanceDelegate factory, ILogger logger);
    public virtual string get_IpcAddress();
    public virtual string get_TcpAddress();
    public virtual ILogger get_Logger();
    public virtual Task Start(CancellationToken token);
    public virtual Task Stop();
    [AsyncStateMachineAttribute("Microsoft.Diagnostics.NETCore.Client.IpcServerTcpClientRouterFactory/<CreateRouterAsync>d__12")]
public virtual Task`1<Router> CreateRouterAsync(CancellationToken token);
}
internal class Microsoft.Diagnostics.NETCore.Client.IpcServerTcpServerRouterFactory : DiagnosticsServerRouterFactory {
    private ILogger _logger;
    private NetServerRouterFactory _netServerRouterFactory;
    private IpcServerRouterFactory _ipcServerRouterFactory;
    public string IpcAddress { get; }
    public string TcpAddress { get; }
    public ILogger Logger { get; }
    public IpcServerTcpServerRouterFactory(string ipcServer, string tcpServer, int runtimeTimeoutMs, CreateInstanceDelegate factory, ILogger logger);
    public virtual string get_IpcAddress();
    public virtual string get_TcpAddress();
    public virtual ILogger get_Logger();
    public virtual Task Start(CancellationToken token);
    public virtual Task Stop();
    public virtual void Reset();
    [AsyncStateMachineAttribute("Microsoft.Diagnostics.NETCore.Client.IpcServerTcpServerRouterFactory/<CreateRouterAsync>d__13")]
public virtual Task`1<Router> CreateRouterAsync(CancellationToken token);
}
internal abstract class Microsoft.Diagnostics.NETCore.Client.IpcServerTransport : object {
    private IIpcServerTransportCallbackInternal _callback;
    private bool _disposed;
    public static int MaxAllowedConnections { get; }
    protected IpcServerTransport(IIpcServerTransportCallbackInternal transportCallback);
    public static IpcServerTransport Create(string address, int maxConnections, Kind kind, IIpcServerTransportCallbackInternal transportCallback);
    public sealed virtual void Dispose();
    protected virtual void Dispose(bool disposing);
    public abstract virtual Task`1<Stream> AcceptAsync(CancellationToken token);
    public static int get_MaxAllowedConnections();
    protected void VerifyNotDisposed();
    internal void SetCallback(IIpcServerTransportCallbackInternal callback);
    protected void OnCreateNewServer(EndPoint localEP);
}
internal class Microsoft.Diagnostics.NETCore.Client.IpcSocket : Socket {
    public IpcSocket(SocketType socketType, ProtocolType protocolType);
    public IpcSocket(AddressFamily addressFamily, SocketType socketType, ProtocolType protocolType);
    public virtual void Connect(EndPoint remoteEP, TimeSpan timeout);
}
internal abstract class Microsoft.Diagnostics.NETCore.Client.IpcSocketServerTransport : IpcServerTransport {
    private CancellationTokenSource _cancellation;
    protected IpcSocket _socket;
    protected IpcSocketServerTransport(IIpcServerTransportCallbackInternal transportCallback);
    protected virtual void Dispose(bool disposing);
    [AsyncStateMachineAttribute("Microsoft.Diagnostics.NETCore.Client.IpcSocketServerTransport/<AcceptAsync>d__4")]
public virtual Task`1<Stream> AcceptAsync(CancellationToken token);
    internal abstract virtual bool OnAccept(Socket socket);
    internal abstract virtual IpcSocket CreateNewSocketServer();
}
internal class Microsoft.Diagnostics.NETCore.Client.IpcTcpSocketEndPoint : object {
    [CompilerGeneratedAttribute]
private bool <DualMode>k__BackingField;
    [CompilerGeneratedAttribute]
private IPEndPoint <EndPoint>k__BackingField;
    public bool DualMode { get; }
    public IPEndPoint EndPoint { get; }
    public IpcTcpSocketEndPoint(string endPoint);
    [CompilerGeneratedAttribute]
public bool get_DualMode();
    [CompilerGeneratedAttribute]
public IPEndPoint get_EndPoint();
    public static bool IsTcpIpEndPoint(string endPoint);
    public static string NormalizeTcpIpEndPoint(string endPoint);
    public static EndPoint op_Implicit(IpcTcpSocketEndPoint endPoint);
    private static void ParseTcpIpEndPoint(string endPoint, String& host, Int32& port);
    private static IPEndPoint CreateEndPoint(string host, int port);
}
internal class Microsoft.Diagnostics.NETCore.Client.IpcTcpSocketServerTransport : IpcSocketServerTransport {
    private int _backlog;
    private IpcTcpSocketEndPoint _endPoint;
    public IpcTcpSocketServerTransport(string address, int backlog, IIpcServerTransportCallbackInternal transportCallback);
    internal virtual bool OnAccept(Socket socket);
    internal virtual IpcSocket CreateNewSocketServer();
}
internal class Microsoft.Diagnostics.NETCore.Client.IpcUnixDomainSocket : IpcSocket {
    private bool _ownsSocketFile;
    private string _path;
    public void Bind(IpcUnixDomainSocketEndPoint localEP);
    public virtual void Connect(EndPoint localEP, TimeSpan timeout);
    protected virtual void Dispose(bool disposing);
}
internal class Microsoft.Diagnostics.NETCore.Client.IpcUnixDomainSocketEndPoint : object {
    [CompilerGeneratedAttribute]
private string <Path>k__BackingField;
    [CompilerGeneratedAttribute]
private EndPoint <EndPoint>k__BackingField;
    public string Path { get; }
    public EndPoint EndPoint { get; }
    public IpcUnixDomainSocketEndPoint(string endPoint);
    [CompilerGeneratedAttribute]
public string get_Path();
    [CompilerGeneratedAttribute]
public EndPoint get_EndPoint();
    public static EndPoint op_Implicit(IpcUnixDomainSocketEndPoint endPoint);
    private static EndPoint CreateEndPoint(string endPoint);
}
internal class Microsoft.Diagnostics.NETCore.Client.IpcUnixDomainSocketServerTransport : IpcSocketServerTransport {
    private int _backlog;
    private IpcUnixDomainSocketEndPoint _endPoint;
    public IpcUnixDomainSocketServerTransport(string path, int backlog, IIpcServerTransportCallbackInternal transportCallback);
    internal virtual bool OnAccept(Socket socket);
    internal virtual IpcSocket CreateNewSocketServer();
}
internal class Microsoft.Diagnostics.NETCore.Client.IpcWebSocketServerTransport : IpcServerTransport {
    public IpcWebSocketServerTransport(IIpcServerTransportCallbackInternal transportCallback);
    protected virtual void Dispose(bool disposing);
    [AsyncStateMachineAttribute("Microsoft.Diagnostics.NETCore.Client.IpcWebSocketServerTransport/<AcceptAsync>d__2")]
public virtual Task`1<Stream> AcceptAsync(CancellationToken token);
}
internal class Microsoft.Diagnostics.NETCore.Client.IpcWindowsNamedPipeServerTransport : IpcServerTransport {
    private static string PipePrefix;
    private NamedPipeServerStream _stream;
    private CancellationTokenSource _cancellation;
    private string _pipeName;
    private int _maxInstances;
    public IpcWindowsNamedPipeServerTransport(string pipeName, int maxInstances, IIpcServerTransportCallbackInternal transportCallback);
    protected virtual void Dispose(bool disposing);
    [AsyncStateMachineAttribute("Microsoft.Diagnostics.NETCore.Client.IpcWindowsNamedPipeServerTransport/<AcceptAsync>d__7")]
public virtual Task`1<Stream> AcceptAsync(CancellationToken token);
    private NamedPipeServerStream CreateNewNamedPipeServer(string pipeName, int maxInstances);
}
internal class Microsoft.Diagnostics.NETCore.Client.MessageHeader : ValueType {
    public DiagnosticsMessageType RequestType;
    public UInt32 Pid;
}
internal static class Microsoft.Diagnostics.NETCore.Client.NativeMethods : object {
    internal static bool PeekNamedPipe(SafePipeHandle hNamedPipe, Byte[] lpBuffer, int bufferSize, IntPtr lpBytesRead, IntPtr lpTotalBytesAvail, IntPtr lpBytesLeftThisMessage);
}
internal abstract class Microsoft.Diagnostics.NETCore.Client.NetServerRouterFactory : object {
    private ILogger _logger;
    private IpcEndpointInfo _netServerEndpointInfo;
    [CompilerGeneratedAttribute]
private int <RuntimeTimeoutMs>k__BackingField;
    [CompilerGeneratedAttribute]
private int <NetServerTimeoutMs>k__BackingField;
    private bool _auto_shutdown;
    protected ILogger Logger { get; }
    protected int RuntimeTimeoutMs { get; private set; }
    protected int NetServerTimeoutMs { get; protected set; }
    protected bool IsAutoShutdown { get; }
    protected IpcEndpointInfo NetServerEndpointInfo { get; private set; }
    protected IpcEndpoint Endpoint { get; }
    public Guid RuntimeInstanceId { get; }
    public int RuntimeProcessId { get; }
    public string ServerAddress { get; }
    public string ServerTransportName { get; }
    protected NetServerRouterFactory(int runtimeTimeoutMs, ILogger logger);
    public abstract virtual void CreatedNewServer(EndPoint localEP);
    protected ILogger get_Logger();
    [CompilerGeneratedAttribute]
protected int get_RuntimeTimeoutMs();
    [CompilerGeneratedAttribute]
private void set_RuntimeTimeoutMs(int value);
    [CompilerGeneratedAttribute]
protected int get_NetServerTimeoutMs();
    [CompilerGeneratedAttribute]
protected void set_NetServerTimeoutMs(int value);
    protected bool get_IsAutoShutdown();
    protected IpcEndpointInfo get_NetServerEndpointInfo();
    private void set_NetServerEndpointInfo(IpcEndpointInfo value);
    protected IpcEndpoint get_Endpoint();
    public Guid get_RuntimeInstanceId();
    public int get_RuntimeProcessId();
    protected void ResetEnpointInfo();
    public abstract virtual string get_ServerAddress();
    public abstract virtual string get_ServerTransportName();
    protected abstract virtual Task`1<IpcEndpointInfo> AcceptAsyncImpl(CancellationToken token);
    public abstract virtual void Start();
    public abstract virtual Task Stop();
    public abstract virtual void Reset();
    [AsyncStateMachineAttribute("Microsoft.Diagnostics.NETCore.Client.NetServerRouterFactory/<AcceptNetStreamAsync>d__36")]
public Task`1<Stream> AcceptNetStreamAsync(CancellationToken token);
}
public enum Microsoft.Diagnostics.NETCore.Client.PerfMapType : Enum {
    public int value__;
    public static PerfMapType None;
    public static PerfMapType All;
    public static PerfMapType JitDump;
    public static PerfMapType PerfMap;
}
internal class Microsoft.Diagnostics.NETCore.Client.PidIpcEndpoint : IpcEndpoint {
    [CompilerGeneratedAttribute]
private static string <IpcRootPath>k__BackingField;
    [CompilerGeneratedAttribute]
private static string <DiagnosticsPortPattern>k__BackingField;
    private int _pid;
    private IpcEndpointConfig _config;
    public static string IpcRootPath { get; }
    public static string DiagnosticsPortPattern { get; }
    public PidIpcEndpoint(int pid);
    private static PidIpcEndpoint();
    [CompilerGeneratedAttribute]
public static string get_IpcRootPath();
    [CompilerGeneratedAttribute]
public static string get_DiagnosticsPortPattern();
    public virtual Stream Connect(TimeSpan timeout);
    [AsyncStateMachineAttribute("Microsoft.Diagnostics.NETCore.Client.PidIpcEndpoint/<ConnectAsync>d__10")]
public virtual Task`1<Stream> ConnectAsync(CancellationToken token);
    public virtual void WaitForConnection(TimeSpan timeout);
    [AsyncStateMachineAttribute("Microsoft.Diagnostics.NETCore.Client.PidIpcEndpoint/<WaitForConnectionAsync>d__12")]
public virtual Task WaitForConnectionAsync(CancellationToken token);
    private string GetDefaultAddress();
    private static bool TryGetDefaultAddress(int pid, String& defaultAddress);
    public static string GetDefaultAddress(int pid);
    public static bool IsDefaultAddressDSRouter(int pid, string address);
    public virtual bool Equals(object obj);
    public bool Equals(PidIpcEndpoint other);
    public virtual int GetHashCode();
}
internal enum Microsoft.Diagnostics.NETCore.Client.ProcessCommandId : Enum {
    public byte value__;
    public static ProcessCommandId GetProcessInfo;
    public static ProcessCommandId ResumeRuntime;
    public static ProcessCommandId GetProcessEnvironment;
    public static ProcessCommandId SetEnvironmentVariable;
    public static ProcessCommandId GetProcessInfo2;
    public static ProcessCommandId EnablePerfMap;
    public static ProcessCommandId DisablePerfMap;
    public static ProcessCommandId ApplyStartupHook;
    public static ProcessCommandId GetProcessInfo3;
}
internal class Microsoft.Diagnostics.NETCore.Client.ProcessEnvironmentHelper : object {
    private static int CopyBufferSize;
    [CompilerGeneratedAttribute]
private UInt32 <ExpectedSizeInBytes>k__BackingField;
    [CompilerGeneratedAttribute]
private ushort <Future>k__BackingField;
    private UInt32 ExpectedSizeInBytes { get; private set; }
    private ushort Future { get; private set; }
    public static ProcessEnvironmentHelper Parse(Byte[] payload);
    public Dictionary`2<string, string> ReadEnvironment(Stream continuation);
    [AsyncStateMachineAttribute("Microsoft.Diagnostics.NETCore.Client.ProcessEnvironmentHelper/<ReadEnvironmentAsync>d__4")]
public Task`1<Dictionary`2<string, string>> ReadEnvironmentAsync(Stream continuation, CancellationToken token);
    private Dictionary`2<string, string> ReadEnvironmentCore(MemoryStream stream);
    [CompilerGeneratedAttribute]
private UInt32 get_ExpectedSizeInBytes();
    [CompilerGeneratedAttribute]
private void set_ExpectedSizeInBytes(UInt32 value);
    [CompilerGeneratedAttribute]
private ushort get_Future();
    [CompilerGeneratedAttribute]
private void set_Future(ushort value);
}
internal class Microsoft.Diagnostics.NETCore.Client.ProcessInfo : object {
    private static int GuidSizeInBytes;
    [CompilerGeneratedAttribute]
private ulong <ProcessId>k__BackingField;
    [CompilerGeneratedAttribute]
private Guid <RuntimeInstanceCookie>k__BackingField;
    [CompilerGeneratedAttribute]
private string <CommandLine>k__BackingField;
    [CompilerGeneratedAttribute]
private string <OperatingSystem>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ProcessArchitecture>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ManagedEntrypointAssemblyName>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ClrProductVersionString>k__BackingField;
    [CompilerGeneratedAttribute]
private string <PortableRuntimeIdentifier>k__BackingField;
    public ulong ProcessId { get; private set; }
    public Guid RuntimeInstanceCookie { get; private set; }
    public string CommandLine { get; private set; }
    public string OperatingSystem { get; private set; }
    public string ProcessArchitecture { get; private set; }
    public string ManagedEntrypointAssemblyName { get; private set; }
    public string ClrProductVersionString { get; private set; }
    public string PortableRuntimeIdentifier { get; private set; }
    internal static ProcessInfo ParseV1(Byte[] payload);
    internal static ProcessInfo ParseV2(Byte[] payload);
    internal static ProcessInfo ParseV3(Byte[] payload);
    private static ProcessInfo ParseCommon(Byte[] payload, Int32& index);
    internal bool TryGetProcessClrVersion(Version& version);
    private static ProcessInfo ParseCommon2(Byte[] payload, Int32& index);
    [CompilerGeneratedAttribute]
public ulong get_ProcessId();
    [CompilerGeneratedAttribute]
private void set_ProcessId(ulong value);
    [CompilerGeneratedAttribute]
public Guid get_RuntimeInstanceCookie();
    [CompilerGeneratedAttribute]
private void set_RuntimeInstanceCookie(Guid value);
    [CompilerGeneratedAttribute]
public string get_CommandLine();
    [CompilerGeneratedAttribute]
private void set_CommandLine(string value);
    [CompilerGeneratedAttribute]
public string get_OperatingSystem();
    [CompilerGeneratedAttribute]
private void set_OperatingSystem(string value);
    [CompilerGeneratedAttribute]
public string get_ProcessArchitecture();
    [CompilerGeneratedAttribute]
private void set_ProcessArchitecture(string value);
    [CompilerGeneratedAttribute]
public string get_ManagedEntrypointAssemblyName();
    [CompilerGeneratedAttribute]
private void set_ManagedEntrypointAssemblyName(string value);
    [CompilerGeneratedAttribute]
public string get_ClrProductVersionString();
    [CompilerGeneratedAttribute]
private void set_ClrProductVersionString(string value);
    [CompilerGeneratedAttribute]
public string get_PortableRuntimeIdentifier();
    [CompilerGeneratedAttribute]
private void set_PortableRuntimeIdentifier(string value);
}
public class Microsoft.Diagnostics.NETCore.Client.ProfilerAlreadyActiveException : ServerErrorException {
    public ProfilerAlreadyActiveException(string msg);
}
internal enum Microsoft.Diagnostics.NETCore.Client.ProfilerCommandId : Enum {
    public byte value__;
    public static ProfilerCommandId AttachProfiler;
    public static ProfilerCommandId StartupProfiler;
}
internal class Microsoft.Diagnostics.NETCore.Client.ReversedDiagnosticsServer : object {
    private static TimeSpan ParseAdvertiseTimeout;
    private CancellationTokenSource _disposalSource;
    private HandleableCollection`1<IpcEndpointInfo> _endpointInfos;
    private ConcurrentDictionary`2<Guid, HandleableCollection`1<Stream>> _streamCollections;
    private string _address;
    private bool _disposed;
    private Task _acceptTransportTask;
    private IpcServerTransport _transport;
    private Kind _kind;
    public static int MaxAllowedConnections;
    [CompilerGeneratedAttribute]
private IIpcServerTransportCallbackInternal <TransportCallback>k__BackingField;
    private bool IsStarted { get; }
    internal IIpcServerTransportCallbackInternal TransportCallback { get; internal set; }
    public ReversedDiagnosticsServer(string address);
    public ReversedDiagnosticsServer(string address, Kind kind);
    private static ReversedDiagnosticsServer();
    [AsyncStateMachineAttribute("Microsoft.Diagnostics.NETCore.Client.ReversedDiagnosticsServer/<DisposeAsync>d__12")]
public sealed virtual ValueTask DisposeAsync();
    public void Start();
    public void Start(int maxConnections);
    public IpcEndpointInfo Accept(TimeSpan timeout);
    public Task`1<IpcEndpointInfo> AcceptAsync(CancellationToken token);
    public bool RemoveConnection(Guid runtimeCookie);
    private void VerifyNotDisposed();
    private void VerifyIsStarted();
    [AsyncStateMachineAttribute("Microsoft.Diagnostics.NETCore.Client.ReversedDiagnosticsServer/<AcceptTransportAsync>d__20")]
private Task AcceptTransportAsync(IpcServerTransport transport, CancellationToken token);
    private HandleableCollection`1<Stream> GetStreams(Guid runtimeCookie);
    internal Stream Connect(Guid runtimeInstanceCookie, TimeSpan timeout);
    internal Task`1<Stream> ConnectAsync(Guid runtimeInstanceCookie, CancellationToken token);
    internal void WaitForConnection(Guid runtimeInstanceCookie, TimeSpan timeout);
    [AsyncStateMachineAttribute("Microsoft.Diagnostics.NETCore.Client.ReversedDiagnosticsServer/<WaitForConnectionAsync>d__25")]
internal Task WaitForConnectionAsync(Guid runtimeInstanceCookie, CancellationToken token);
    private static bool WaitForConnectionHandler(Stream item, Boolean& removeItem);
    private static bool TestStream(Stream stream);
    private bool get_IsStarted();
    [CompilerGeneratedAttribute]
internal IIpcServerTransportCallbackInternal get_TransportCallback();
    [CompilerGeneratedAttribute]
internal void set_TransportCallback(IIpcServerTransportCallbackInternal value);
}
internal class Microsoft.Diagnostics.NETCore.Client.Router : object {
    private ILogger _logger;
    private Stream _frontendStream;
    private Stream _backendStream;
    private Task _backendReadFrontendWriteTask;
    private Task _frontendReadBackendWriteTask;
    private CancellationTokenSource _cancelRouterTokenSource;
    private bool _disposed;
    private ulong _backendToFrontendByteTransfer;
    private ulong _frontendToBackendByteTransfer;
    private static int s_routerInstanceCount;
    [CompilerGeneratedAttribute]
private TaskCompletionSource`1<bool> <RouterTaskCompleted>k__BackingField;
    public TaskCompletionSource`1<bool> RouterTaskCompleted { get; }
    public bool IsRunning { get; }
    public Router(Stream frontendStream, Stream backendStream, ILogger logger, ulong initBackendToFrontendByteTransfer, ulong initFrontendToBackendByteTransfer);
    [CompilerGeneratedAttribute]
public TaskCompletionSource`1<bool> get_RouterTaskCompleted();
    public void Start();
    [AsyncStateMachineAttribute("Microsoft.Diagnostics.NETCore.Client.Router/<Stop>d__15")]
public void Stop();
    public bool get_IsRunning();
    public sealed virtual void Dispose();
    [AsyncStateMachineAttribute("Microsoft.Diagnostics.NETCore.Client.Router/<BackendReadFrontendWrite>d__19")]
private Task BackendReadFrontendWrite(CancellationToken token);
    [AsyncStateMachineAttribute("Microsoft.Diagnostics.NETCore.Client.Router/<FrontendReadBackendWrite>d__20")]
private Task FrontendReadBackendWrite(CancellationToken token);
}
internal class Microsoft.Diagnostics.NETCore.Client.RuntimeTimeoutException : TimeoutException {
    public RuntimeTimeoutException(int TimeoutMs);
}
public class Microsoft.Diagnostics.NETCore.Client.ServerErrorException : DiagnosticsClientException {
    public ServerErrorException(string msg);
}
internal class Microsoft.Diagnostics.NETCore.Client.ServerIpcEndpoint : IpcEndpoint {
    private Guid _runtimeId;
    private ReversedDiagnosticsServer _server;
    public ServerIpcEndpoint(ReversedDiagnosticsServer server, Guid runtimeId);
    public virtual Stream Connect(TimeSpan timeout);
    public virtual Task`1<Stream> ConnectAsync(CancellationToken token);
    public virtual void WaitForConnection(TimeSpan timeout);
    public virtual Task WaitForConnectionAsync(CancellationToken token);
    public virtual bool Equals(object obj);
    public bool Equals(ServerIpcEndpoint other);
    public virtual int GetHashCode();
}
public class Microsoft.Diagnostics.NETCore.Client.ServerNotAvailableException : DiagnosticsClientException {
    public ServerNotAvailableException(string msg);
}
[ExtensionAttribute]
internal static class Microsoft.Diagnostics.NETCore.Client.StreamExtensions : object {
    [AsyncStateMachineAttribute("Microsoft.Diagnostics.NETCore.Client.StreamExtensions/<ReadBytesAsync>d__0")]
[ExtensionAttribute]
public static Task`1<Byte[]> ReadBytesAsync(Stream stream, int length, CancellationToken cancellationToken);
}
internal class Microsoft.Diagnostics.NETCore.Client.TcpClientRouterFactory : object {
    protected ILogger _logger;
    protected string _tcpClientAddress;
    protected bool _auto_shutdown;
    [CompilerGeneratedAttribute]
private int <TcpClientTimeoutMs>k__BackingField;
    [CompilerGeneratedAttribute]
private int <TcpClientRetryTimeoutMs>k__BackingField;
    protected int TcpClientTimeoutMs { get; protected set; }
    protected int TcpClientRetryTimeoutMs { get; protected set; }
    protected ILogger Logger { get; }
    public string TcpClientAddress { get; }
    public TcpClientRouterFactory(string tcpClient, int runtimeTimeoutMs, ILogger logger);
    [CompilerGeneratedAttribute]
protected int get_TcpClientTimeoutMs();
    [CompilerGeneratedAttribute]
protected void set_TcpClientTimeoutMs(int value);
    [CompilerGeneratedAttribute]
protected int get_TcpClientRetryTimeoutMs();
    [CompilerGeneratedAttribute]
protected void set_TcpClientRetryTimeoutMs(int value);
    protected ILogger get_Logger();
    public static TcpClientRouterFactory CreateDefaultInstance(string tcpClient, int runtimeTimeoutMs, ILogger logger);
    public string get_TcpClientAddress();
    [AsyncStateMachineAttribute("Microsoft.Diagnostics.NETCore.Client.TcpClientRouterFactory/<ConnectTcpStreamAsync>d__18")]
public virtual Task`1<Stream> ConnectTcpStreamAsync(CancellationToken token);
    [AsyncStateMachineAttribute("Microsoft.Diagnostics.NETCore.Client.TcpClientRouterFactory/<ConnectTcpStreamAsync>d__19")]
public virtual Task`1<Stream> ConnectTcpStreamAsync(CancellationToken token, bool retry);
    public virtual void Start();
    public virtual void Stop();
    [AsyncStateMachineAttribute("Microsoft.Diagnostics.NETCore.Client.TcpClientRouterFactory/<ConnectTcpStreamAsyncInternal>d__22")]
private Task`1<Stream> ConnectTcpStreamAsyncInternal(CancellationToken token, bool retry);
    [AsyncStateMachineAttribute("Microsoft.Diagnostics.NETCore.Client.TcpClientRouterFactory/<ConnectAsyncInternal>d__23")]
private Task ConnectAsyncInternal(Socket clientSocket, EndPoint remoteEP, CancellationToken token);
}
internal class Microsoft.Diagnostics.NETCore.Client.TcpServerRouterFactory : NetServerRouterFactory {
    private string _tcpServerAddress;
    private ReversedDiagnosticsServer _tcpServer;
    public string TcpServerAddress { get; }
    public string ServerAddress { get; }
    public string ServerTransportName { get; }
    public TcpServerRouterFactory(string tcpServer, int runtimeTimeoutMs, ILogger logger);
    public string get_TcpServerAddress();
    public static TcpServerRouterFactory CreateDefaultInstance(string tcpServer, int runtimeTimeoutMs, ILogger logger);
    public virtual void Start();
    [AsyncStateMachineAttribute("Microsoft.Diagnostics.NETCore.Client.TcpServerRouterFactory/<Stop>d__7")]
public virtual Task Stop();
    public virtual void Reset();
    protected virtual Task`1<IpcEndpointInfo> AcceptAsyncImpl(CancellationToken token);
    public virtual string get_ServerAddress();
    public virtual string get_ServerTransportName();
    public virtual void CreatedNewServer(EndPoint localEP);
}
public class Microsoft.Diagnostics.NETCore.Client.UnsupportedCommandException : ServerErrorException {
    public UnsupportedCommandException(string msg);
}
public class Microsoft.Diagnostics.NETCore.Client.UnsupportedProtocolException : DiagnosticsClientException {
    public UnsupportedProtocolException(string msg);
}
internal interface Microsoft.Diagnostics.NETCore.Client.WebSocketServer.IWebSocketServer {
    public abstract virtual Task`1<Stream> AcceptConnection(CancellationToken cancellationToken);
}
internal interface Microsoft.Diagnostics.NETCore.Client.WebSocketServer.IWebSocketStreamAdapter {
    public bool IsConnected { get; }
    public abstract virtual bool get_IsConnected();
}
internal static class Microsoft.Diagnostics.NETCore.Client.WebSocketServer.WebSocketServerProvider : object {
    private static Func`1<IWebSocketServer> _provider;
    internal static void SetProvider(Func`1<IWebSocketServer> provider);
    internal static IWebSocketServer GetWebSocketServerInstance();
}
internal class Microsoft.Diagnostics.NETCore.Client.WebSocketServerRouterFactory : NetServerRouterFactory {
    private string _webSocketURL;
    private ReversedDiagnosticsServer _webSocketServer;
    public string WebSocketURL { get; }
    public string ServerAddress { get; }
    public string ServerTransportName { get; }
    public WebSocketServerRouterFactory(string webSocketURL, int runtimeTimeoutMs, ILogger logger);
    public string get_WebSocketURL();
    public static WebSocketServerRouterFactory CreateDefaultInstance(string webSocketURL, int runtimeTimeoutMs, ILogger logger);
    public virtual void Start();
    [AsyncStateMachineAttribute("Microsoft.Diagnostics.NETCore.Client.WebSocketServerRouterFactory/<Stop>d__7")]
public virtual Task Stop();
    public virtual void Reset();
    protected virtual Task`1<IpcEndpointInfo> AcceptAsyncImpl(CancellationToken token);
    public virtual string get_ServerAddress();
    public virtual string get_ServerTransportName();
    public virtual void CreatedNewServer(EndPoint localEP);
}
public enum Microsoft.Diagnostics.NETCore.Client.WriteDumpFlags : Enum {
    public int value__;
    public static WriteDumpFlags None;
    public static WriteDumpFlags LoggingEnabled;
    public static WriteDumpFlags VerboseLoggingEnabled;
    public static WriteDumpFlags CrashReportEnabled;
}
[CompilerGeneratedAttribute]
[EmbeddedAttribute]
[AttributeUsageAttribute("2")]
internal class System.Runtime.CompilerServices.RefSafetyRulesAttribute : Attribute {
    public int Version;
    public RefSafetyRulesAttribute(int );
}
