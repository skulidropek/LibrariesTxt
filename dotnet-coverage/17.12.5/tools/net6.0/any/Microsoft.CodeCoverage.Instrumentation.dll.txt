[CompilerGeneratedAttribute]
[EmbeddedAttribute]
internal class Microsoft.CodeAnalysis.EmbeddedAttribute : Attribute {
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.CodeCoverage.Instrumentation.AppDomainCoverageModuleDataReader : object {
    private static int SizeOfWriteStreamMessage;
    private IAppDomainDataReader _internalReader;
    private ICoverageMessagesReader _coverageMessagesReader;
    private IMutexFactory _mutexFactory;
    public AppDomainCoverageModuleDataReader(ICoverageMessagesReader coverageMessagesReader, IAppDomainDataReader internalReader, IMutexFactory mutexFactory);
    [IteratorStateMachineAttribute("Microsoft.CodeCoverage.Instrumentation.AppDomainCoverageModuleDataReader/<Read>d__5")]
public sealed virtual IEnumerable`1<ValueTuple`3<ModuleMessages, Byte[], bool>> Read(CancellationToken cancellationToken);
    [IteratorStateMachineAttribute("Microsoft.CodeCoverage.Instrumentation.AppDomainCoverageModuleDataReader/<InternalRead>d__6`1")]
public IEnumerable`1<ValueTuple`3<ModuleMessages, Byte[], bool>> InternalRead(string dataName, string dataMutexName, Func`3<T, int, Byte[]> streamCreator, CancellationToken cancellationToken);
    private Byte[] GenerateBuffer(MemoryMappedFile memoryMappedFile, int bufferSize);
    [CompilerGeneratedAttribute]
private Byte[] <Read>b__5_1(MemoryMappedFile file, int bufferSize);
}
internal class Microsoft.CodeCoverage.Instrumentation.AppDomainDataReader : object {
    [NullableContextAttribute("1")]
public sealed virtual object GetData(string name);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.CodeCoverage.Instrumentation.AssemblySourceFileRootResolver : object {
    private ISourceRootResolver _globalResolver;
    private IDictionary`2<string, string> _mappings;
    public AssemblySourceFileRootResolver(ISourceRootResolver globalResolver);
    public sealed virtual ValueTuple`3<string, string, string> ResolveFilePath(string path);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.CodeCoverage.Instrumentation.CecilPdbReader : object {
    private UnmanagedMemoryStream _stream;
    private ModuleDefinition _moduleDefinition;
    private ISourceRootResolver _sourceRootResolver;
    private ISet`1<string> _sources;
    private bool _disposed;
    [CompilerGeneratedAttribute]
private Byte[] <IdBytes>k__BackingField;
    [CompilerGeneratedAttribute]
private string <PdbPath>k__BackingField;
    public Byte[] IdBytes { get; }
    public string PdbPath { get; }
    public bool IsSourcesPreLoadSupported { get; }
    public CecilPdbReader(PEMemoryBlock entireImage, string pdbPath, Byte[] idBytes, ISourceRootResolver sourceRootResolver);
    [CompilerGeneratedAttribute]
public sealed virtual Byte[] get_IdBytes();
    [CompilerGeneratedAttribute]
public sealed virtual string get_PdbPath();
    public sealed virtual bool get_IsSourcesPreLoadSupported();
    [IteratorStateMachineAttribute("Microsoft.CodeCoverage.Instrumentation.CecilPdbReader/<GetSequencePoints>d__14")]
public sealed virtual IEnumerable`1<SequencePointMetadata> GetSequencePoints(MethodDefinitionHandle handle);
    [IteratorStateMachineAttribute("Microsoft.CodeCoverage.Instrumentation.CecilPdbReader/<GetSourceFiles>d__15")]
public sealed virtual IEnumerable`1<string> GetSourceFiles(MethodDefinitionHandle handle);
    public sealed virtual int GetStateMachineKickoffMethod(MethodDefinitionHandle handle);
    public sealed virtual void Dispose();
    protected virtual void Dispose(bool disposing);
    public sealed virtual IEnumerable`1<string> GetSources();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
internal static class Microsoft.CodeCoverage.Instrumentation.CoberturaReportHelper : object {
    [ExtensionAttribute]
public static void PopulateCoverageStatus(CoberturaPackage package, Byte[] coverageBuffer);
    [ExtensionAttribute]
public static CoberturaPackage ToCoberturaPackage(AssemblyMetadata assemblyMetadata);
    [ExtensionAttribute]
public static CoberturaPackage ToCoberturaPackage(ModuleMessages moduleMessages);
    private static CoberturaClass[] ParsePackageMethods(AssemblyMetadata assemblyMetadata);
    private static CoberturaClass[] ParsePackageMethods(ModuleMessages moduleMessages);
    private static ValueTuple`2<MinimalSequencePointsFinder`1<string>, int> BuildMinimalSequencePointsFinderAndCalculateMaxNumberOfMethods(AssemblyMetadata assemblyMetadata);
    private static ValueTuple`2<MinimalSequencePointsFinder`1<UInt32>, int> BuildMinimalSequencePointsFinderAndCalculateMaxNumberOfMethods(ModuleMessages moduleMessages);
    private static void AddMethod(MethodMetadata method, UInt32 offset, CoberturaPackageBuilder packageBuilder, MinimalSequencePointsFinder`1<string> minimalSequencePointsFinder, ReusableCollections reusableCollections);
    private static void AddMethod(FunctionInstrumentedMessage functionMessage, CoberturaPackageBuilder packageBuilder, MinimalSequencePointsFinder`1<UInt32> minimalSequencePointsFinder, IDictionary`2<UInt32, string> sourceFiles, ReusableCollections reusableCollections);
    private static CoberturaLine[] CalculateLines(MethodMetadata method, string sourceFilePath, UInt32 offset, MinimalSequencePointsFinder`1<string> minimalSequencePointsFinder, IDictionary`2<int, MethodBlock> instructionBlockMap, ReusableCollections reusableCollections);
    private static CoberturaLine[] CalculateLines(BlockLineDataMessage[] lineData, UInt32 sourceId, MinimalSequencePointsFinder`1<UInt32> minimalSequencePointsFinder, ReusableCollections reusableCollections);
    private static void AddCoberturaConditions(MethodMetadata method, UInt32 offset, int i, SequencePointMetadata sequencePoint, IList`1<CoberturaCondition> coberturaConditions, ISet`1<int> conditionsAlreadyInserted, IDictionary`2<int, MethodBlock> instructionBlockMap);
    private static CoberturaCondition CreateCoberturaCondition(UInt32 offset, SequencePointMetadata sequencePoint, int number, IDictionary`2<int, MethodBlock> instructionBlockMap, Instruction instruction);
    private static void StoreCoberturaConditions(int lineNumber, IList`1<CoberturaCondition> coberturaConditions, IDictionary`2<int, CoberturaLine> lineMethodDictionary);
    private static void RestoreCoberturaConditions(IList`1<CoberturaCondition> coberturaConditions, CoberturaLine coberturaLine);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal static class Microsoft.CodeCoverage.Instrumentation.CompilerGeneratedFieldsMetadataTokensProvider : object {
    private static Regex s_compilerGeneratedFieldNameRegex;
    private static CompilerGeneratedFieldsMetadataTokensProvider();
    public static HashSet`1<int> GetCompilerGeneratedFieldsMetadataTokens(AssemblyMetadata assemblyMetadata);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal static class Microsoft.CodeCoverage.Instrumentation.Constants : object {
    public static string CompilerGeneratedAttribute;
    public static string AnyCpu;
    public static string X86;
    public static string X64;
    public static string Debug;
    public static string PrefixSeparator;
    public static string ManagedPrefix;
    public static string UnmanagedPrefix;
    public static string EntrypointPrefix;
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.CodeCoverage.Instrumentation.DiaSymPdbReader : object {
    private ISymUnmanagedReader5 _symUnmanagedReader5;
    private ISourceRootResolver _sourceRootResolver;
    private IDictionary`2<string, SourceDocumentData> _sourceFiles;
    [CompilerGeneratedAttribute]
private Byte[] <IdBytes>k__BackingField;
    [CompilerGeneratedAttribute]
private string <PdbPath>k__BackingField;
    public Byte[] IdBytes { get; }
    public string PdbPath { get; }
    public bool IsSourcesPreLoadSupported { get; }
    private DiaSymPdbReader(ISymUnmanagedReader5 symUnmanagedReader5, string pdbPath, Byte[] idBytes, ISourceRootResolver sourceRootResolver);
    [CompilerGeneratedAttribute]
public sealed virtual Byte[] get_IdBytes();
    [CompilerGeneratedAttribute]
public sealed virtual string get_PdbPath();
    public sealed virtual bool get_IsSourcesPreLoadSupported();
    [IteratorStateMachineAttribute("Microsoft.CodeCoverage.Instrumentation.DiaSymPdbReader/<GetSequencePoints>d__12")]
public sealed virtual IEnumerable`1<SequencePointMetadata> GetSequencePoints(MethodDefinitionHandle handle);
    [IteratorStateMachineAttribute("Microsoft.CodeCoverage.Instrumentation.DiaSymPdbReader/<GetSourceFiles>d__13")]
public sealed virtual IEnumerable`1<string> GetSourceFiles(MethodDefinitionHandle handle);
    public sealed virtual int GetStateMachineKickoffMethod(MethodDefinitionHandle handle);
    public sealed virtual IEnumerable`1<string> GetSources();
    public sealed virtual void Dispose();
    private void InitializeSources();
    public static DiaSymPdbReader Create(DebugDirectoryEntry entry, CodeViewDebugDirectoryData data, string pdbPath, Stream stream, Byte[] idBytes, ISourceRootResolver sourceRootResolver);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.CodeCoverage.Instrumentation.DynamicInstrumentationModuleDefinitionManager : object {
    [NullableAttribute("2")]
private ModuleDefinition _moduleDefinition;
    [NullableAttribute("2")]
private Stream _stream;
    [NullableAttribute("2")]
private IAssemblyResolver _assemblyResolver;
    private IAssemblyResolverFactory _assemblyResolverFactory;
    private ILogger _logger;
    public DynamicInstrumentationModuleDefinitionManager(IAssemblyResolverFactory assemblyResolverFactory, ILogger logger);
    public sealed virtual ModuleDefinition Create(string modulePath, string _);
    public sealed virtual void Dispose();
}
internal class Microsoft.CodeCoverage.Instrumentation.EmptyNoReturnMethodMetadataTokensProvider : object {
    [NullableContextAttribute("1")]
public sealed virtual ISet`1<UInt32> GetMetadataTokens(AssemblyMetadata assemblyMetadata);
}
internal class Microsoft.CodeCoverage.Instrumentation.EmptySourceRootResolver : object {
    [NullableContextAttribute("1")]
public sealed virtual ValueTuple`3<string, string, string> ResolveFilePath(string path);
}
internal class Microsoft.CodeCoverage.Instrumentation.EmptySourceRootResolverFactory : object {
    [NullableContextAttribute("1")]
public sealed virtual ISourceRootResolver Create(ISourceRootTranslator sourceRootTranslator);
}
internal class Microsoft.CodeCoverage.Instrumentation.EmptySymReaderMetadataProvider : object {
    public sealed virtual bool TryGetStandaloneSignature(int standaloneSignatureToken, Byte*& signature, Int32& length);
    [NullableContextAttribute("1")]
public sealed virtual bool TryGetTypeDefinitionInfo(int typeDefinitionToken, String& namespaceName, String& typeName, TypeAttributes& attributes);
    [NullableContextAttribute("1")]
public sealed virtual bool TryGetTypeReferenceInfo(int typeReferenceToken, String& namespaceName, String& typeName);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
internal static class Microsoft.CodeCoverage.Instrumentation.Helper : object {
    private static MethodAttributes NoMethodBodyAttributes;
    private static MethodImplAttributes NoMethodBodyImplementationAttributes;
    [ExtensionAttribute]
public static bool HasBody(MethodDefinition methodDefinition);
    public static IList`1<EventMetadata> GetEvents(ReflectionContainer reflectionContainer, EventDefinitionHandleCollection handles, TypeMetadata parent);
    public static EventMetadata GetEvent(ReflectionContainer reflectionContainer, EventDefinitionHandle handle, TypeMetadata parent);
    public static IList`1<PropertyMetadata> GetProperties(ReflectionContainer reflectionContainer, PropertyDefinitionHandleCollection handles, TypeMetadata parent);
    public static PropertyMetadata GetProperty(ReflectionContainer reflectionContainer, PropertyDefinitionHandle handle, TypeMetadata parent);
    public static IList`1<MethodMetadata> GetMethods(ReflectionContainer reflectionContainer, PropertyAccessors accessors, TypeMetadata parent);
    public static IList`1<MethodMetadata> GetMethods(ReflectionContainer reflectionContainer, EventAccessors accessors, TypeMetadata parent);
    public static IList`1<MethodMetadata> GetMethods(ReflectionContainer reflectionContainer, MethodDefinitionHandleCollection handles, TypeMetadata parent);
    public static MethodMetadata GetMethod(ReflectionContainer reflectionContainer, MethodDefinitionHandle handle, TypeMetadata parent);
    public static string RemoveTypeParameter(string name);
    public static string GetParametersString(ReflectionContainer reflectionContainer, MethodDefinition definition);
    public static string GetParametersString(ReflectionContainer reflectionContainer, TypeDefinition definition);
    [NullableContextAttribute("0")]
internal static Byte[] CalculatePublicKeyToken(ImmutableArray`1<byte> publicKey);
    private static void AddGenericParameters(MethodDefinition methodDefinition, StringBuilder stringBuilder, SignatureVisualizer visualizer, MethodSignature`1<string> signature);
    private static void AddParameters(ReflectionContainer reflectionContainer, StringBuilder stringBuilder, ParameterHandleCollection parameterHandles, MethodSignature`1<string> signature);
    public static IList`1<CustomAttributeMetadata> GetCustomAttributes(ReflectionContainer reflectionContainer, CustomAttributeHandleCollection handles);
    internal static CustomAttributeMetadata GetCustomAttribute(MetadataReader metadataReader, CustomAttribute customAttribute);
    [IteratorStateMachineAttribute("Microsoft.CodeCoverage.Instrumentation.Helper/<GenerateBatchedPipeMessages>d__19")]
public static IEnumerable`1<Byte[]> GenerateBatchedPipeMessages(int capacity, IEnumerable`1<Action`1<BinaryWriter>> writeMessageRecipes, Action`1<BinaryWriter> writeInitMessage);
}
internal interface Microsoft.CodeCoverage.Instrumentation.IAppDomainCoverageModuleDataReader {
    public abstract virtual IEnumerable`1<ValueTuple`3<ModuleMessages, Byte[], bool>> Read(CancellationToken cancellationToken);
}
[NullableContextAttribute("1")]
internal interface Microsoft.CodeCoverage.Instrumentation.IAppDomainDataReader {
    public abstract virtual object GetData(string name);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
internal static class Microsoft.CodeCoverage.Instrumentation.IL.Extensions : object {
    private static ILOpCodeInfo None;
    private static ILOpCodeInfo Byte;
    private static ILOpCodeInfo ByteBranch;
    private static ILOpCodeInfo Int;
    private static ILOpCodeInfo IntBranch;
    private static ILOpCodeInfo Token;
    private static ILOpCodeInfo Long;
    private static ILOpCodeInfo Single;
    private static ILOpCodeInfo Double;
    private static ILOpCodeInfo Switch;
    private static ILOpCodeInfo TwoNone;
    private static ILOpCodeInfo TwoToken;
    private static ILOpCodeInfo TwoUShort;
    private static ILOpCodeInfo TwoByte;
    private static Extensions();
    [ExtensionAttribute]
public static ILOpCode DecodeOpCode(BlobReader& blob);
    [ExtensionAttribute]
public static InstructionTerminationType GetInstructionTerminationType(ILOpCode opCode);
    [ExtensionAttribute]
public static bool IsShortBranch(ILOpCode opCode);
    [ExtensionAttribute]
public static bool IsDirectBranch(InstructionTerminationType instructionTerminationType);
    [ExtensionAttribute]
public static bool IsIndirectBranch(InstructionTerminationType instructionTerminationType);
    [ExtensionAttribute]
public static bool IsConditionalBranch(InstructionTerminationType instructionTerminationType);
    [ExtensionAttribute]
public static bool IsSwitch(InstructionTerminationType instructionTerminationType);
    [ExtensionAttribute]
public static ILOpCodeInfo GetILOpCodeInfo(ILOpCode opCode);
}
internal enum Microsoft.CodeCoverage.Instrumentation.IL.ILOpCodeFlags : Enum {
    public int value__;
    public static ILOpCodeFlags None;
    public static ILOpCodeFlags Meta;
    public static ILOpCodeFlags Unused;
    public static ILOpCodeFlags Branch;
}
internal class Microsoft.CodeCoverage.Instrumentation.IL.ILOpCodeInfo : object {
    [CompilerGeneratedAttribute]
private int <OpCodeLength>k__BackingField;
    [CompilerGeneratedAttribute]
private int <OperandLength>k__BackingField;
    [CompilerGeneratedAttribute]
private ILOperandType <OperandType>k__BackingField;
    [CompilerGeneratedAttribute]
private ILOpCodeFlags <OpCodeFlags>k__BackingField;
    public int OpCodeLength { get; public set; }
    public int OperandLength { get; public set; }
    public ILOperandType OperandType { get; public set; }
    public ILOpCodeFlags OpCodeFlags { get; public set; }
    public ILOpCodeInfo(int opCodeLength, int operandLength, ILOperandType operandType, ILOpCodeFlags opCodeFlags);
    [CompilerGeneratedAttribute]
public int get_OpCodeLength();
    [CompilerGeneratedAttribute]
public void set_OpCodeLength(int value);
    [CompilerGeneratedAttribute]
public int get_OperandLength();
    [CompilerGeneratedAttribute]
public void set_OperandLength(int value);
    [CompilerGeneratedAttribute]
public ILOperandType get_OperandType();
    [CompilerGeneratedAttribute]
public void set_OperandType(ILOperandType value);
    [CompilerGeneratedAttribute]
public ILOpCodeFlags get_OpCodeFlags();
    [CompilerGeneratedAttribute]
public void set_OpCodeFlags(ILOpCodeFlags value);
}
internal enum Microsoft.CodeCoverage.Instrumentation.IL.ILOperandType : Enum {
    public int value__;
    public static ILOperandType None;
    public static ILOperandType Byte;
    public static ILOperandType Int;
    public static ILOperandType UShort;
    public static ILOperandType Long;
    public static ILOperandType Single;
    public static ILOperandType Double;
    public static ILOperandType Token;
    public static ILOperandType Switch;
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.CodeCoverage.Instrumentation.IL.Instruction : ValueType {
    [CompilerGeneratedAttribute]
private ILOpCode <OpCode>k__BackingField;
    [CompilerGeneratedAttribute]
private InstructionTerminationType <TerminationType>k__BackingField;
    [CompilerGeneratedAttribute]
private int <Offset>k__BackingField;
    [CompilerGeneratedAttribute]
private Int32[] <TargetOffsets>k__BackingField;
    public ILOpCode OpCode { get; public set; }
    public InstructionTerminationType TerminationType { get; public set; }
    public int Offset { get; public set; }
    public Int32[] TargetOffsets { get; public set; }
    public Instruction(ILOpCode OpCode, InstructionTerminationType TerminationType, int Offset, Int32[] TargetOffsets);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public ILOpCode get_OpCode();
    [CompilerGeneratedAttribute]
public void set_OpCode(ILOpCode value);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public InstructionTerminationType get_TerminationType();
    [CompilerGeneratedAttribute]
public void set_TerminationType(InstructionTerminationType value);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public int get_Offset();
    [CompilerGeneratedAttribute]
public void set_Offset(int value);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public Int32[] get_TargetOffsets();
    [CompilerGeneratedAttribute]
public void set_TargetOffsets(Int32[] value);
    [IsReadOnlyAttribute]
[NullableContextAttribute("0")]
[CompilerGeneratedAttribute]
public virtual string ToString();
    [IsReadOnlyAttribute]
[NullableContextAttribute("0")]
[CompilerGeneratedAttribute]
private bool PrintMembers(StringBuilder builder);
    [CompilerGeneratedAttribute]
public static bool op_Inequality(Instruction left, Instruction right);
    [CompilerGeneratedAttribute]
public static bool op_Equality(Instruction left, Instruction right);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public virtual int GetHashCode();
    [IsReadOnlyAttribute]
[NullableContextAttribute("0")]
[CompilerGeneratedAttribute]
public virtual bool Equals(object obj);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public sealed virtual bool Equals(Instruction other);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public void Deconstruct(ILOpCode& OpCode, InstructionTerminationType& TerminationType, Int32& Offset, Int32[]& TargetOffsets);
}
internal enum Microsoft.CodeCoverage.Instrumentation.IL.InstructionTerminationType : Enum {
    public int value__;
    public static InstructionTerminationType FallThrough;
    public static InstructionTerminationType Branch;
    public static InstructionTerminationType ConditionalBranch;
    public static InstructionTerminationType Throw;
    public static InstructionTerminationType Switch;
    public static InstructionTerminationType Call;
    public static InstructionTerminationType IndirectCall;
    public static InstructionTerminationType Return;
    public static InstructionTerminationType Trap;
}
[NullableContextAttribute("1")]
internal interface Microsoft.CodeCoverage.Instrumentation.ILibraryHelper {
    public abstract virtual LibraryInfo GetLibraryInfo(string path);
    public abstract virtual int GetTimeDateStamp(string path);
    public abstract virtual string GetAssemblyName(string path);
    public abstract virtual ImmutableArray`1<byte> GetSection(string path, string sectionName);
}
[NullableContextAttribute("1")]
internal interface Microsoft.CodeCoverage.Instrumentation.IModuleCoverageContainer {
    [NullableAttribute("2")]
public string PdbPath { get; }
    public UInt32 BlockSize { get; }
    public Guid Identifier { get; }
    [NullableAttribute("2")]
public string BufferName { get; }
    [NullableAttribute("2")]
public string BufferNameEnvironmentVariable { get; }
    public int BufferSize { get; }
    public bool IsSkipped { get; }
    public ModuleSkipReason ModuleSkipReason { get; }
    public ModuleInstrumentedMessage ModuleInstrumentedMessage { get; }
    public IList`1<InstrumentedFunctionMessage> InstrumentedFunctionMessages { get; }
    public IList`1<FunctionInstrumentedMessage> FunctionInstrumentedMessages { get; }
    public IList`1<FunctionSkippedMessage> FunctionSkippedMessages { get; }
    public IList`1<SourceFileDataMessage> SourceFileDataMessages { get; }
    public bool IsMixed { get; }
    public bool IsPortablePdb { get; }
    [NullableAttribute("2")]
public string TargetFramework { get; }
    public bool HasSecurityAttributes { get; }
    [NullableContextAttribute("2")]
public abstract virtual string get_PdbPath();
    public abstract virtual UInt32 get_BlockSize();
    public abstract virtual Guid get_Identifier();
    [NullableContextAttribute("2")]
public abstract virtual string get_BufferName();
    [NullableContextAttribute("2")]
public abstract virtual string get_BufferNameEnvironmentVariable();
    public abstract virtual int get_BufferSize();
    public abstract virtual bool get_IsSkipped();
    public abstract virtual ModuleSkipReason get_ModuleSkipReason();
    public abstract virtual ModuleInstrumentedMessage get_ModuleInstrumentedMessage();
    public abstract virtual IList`1<InstrumentedFunctionMessage> get_InstrumentedFunctionMessages();
    public abstract virtual IList`1<FunctionInstrumentedMessage> get_FunctionInstrumentedMessages();
    public abstract virtual IList`1<FunctionSkippedMessage> get_FunctionSkippedMessages();
    public abstract virtual IList`1<SourceFileDataMessage> get_SourceFileDataMessages();
    public abstract virtual bool get_IsMixed();
    public abstract virtual bool get_IsPortablePdb();
    [NullableContextAttribute("2")]
public abstract virtual string get_TargetFramework();
    public abstract virtual bool get_HasSecurityAttributes();
}
internal interface Microsoft.CodeCoverage.Instrumentation.IModuleDefinitionManager {
    [NullableContextAttribute("1")]
public abstract virtual ModuleDefinition Create(string modulePath, string pdbPath);
}
[NullableContextAttribute("1")]
internal interface Microsoft.CodeCoverage.Instrumentation.IMsdiaPdbReaderFactory {
    public abstract virtual IPdbReader Create(DebugDirectoryEntry entry, CodeViewDebugDirectoryData data, string pdbPath, Byte[] idBytes, ISourceRootResolver sourceRootResolver);
}
[NullableContextAttribute("1")]
internal interface Microsoft.CodeCoverage.Instrumentation.INoReturnMethodMetadataTokensProvider {
    public abstract virtual ISet`1<UInt32> GetMetadataTokens(AssemblyMetadata assemblyMetadata);
}
[NullableContextAttribute("1")]
public interface Microsoft.CodeCoverage.Instrumentation.IPdbReader {
    public Byte[] IdBytes { get; }
    [NullableAttribute("2")]
public string PdbPath { get; }
    public bool IsSourcesPreLoadSupported { get; }
    public abstract virtual Byte[] get_IdBytes();
    [NullableContextAttribute("2")]
public abstract virtual string get_PdbPath();
    public abstract virtual IEnumerable`1<SequencePointMetadata> GetSequencePoints(MethodDefinitionHandle handle);
    public abstract virtual IEnumerable`1<string> GetSourceFiles(MethodDefinitionHandle handle);
    public abstract virtual int GetStateMachineKickoffMethod(MethodDefinitionHandle handle);
    public abstract virtual IEnumerable`1<string> GetSources();
    public abstract virtual bool get_IsSourcesPreLoadSupported();
}
[NullableContextAttribute("1")]
internal interface Microsoft.CodeCoverage.Instrumentation.IPdbReaderProvider {
    public abstract virtual Task`1<IPdbReader> GetPdbDataProviderAsync(string path, PEReader reader);
}
[NullableContextAttribute("1")]
internal interface Microsoft.CodeCoverage.Instrumentation.ISourceRootResolver {
    public abstract virtual ValueTuple`3<string, string, string> ResolveFilePath(string path);
}
[NullableContextAttribute("1")]
internal interface Microsoft.CodeCoverage.Instrumentation.ISourceRootResolverFactory {
    public abstract virtual ISourceRootResolver Create(ISourceRootTranslator sourceRootTranslator);
}
internal interface Microsoft.CodeCoverage.Instrumentation.ISourceRootTranslator {
    [NullableContextAttribute("1")]
public abstract virtual bool Exists(string path);
}
[NullableContextAttribute("1")]
internal interface Microsoft.CodeCoverage.Instrumentation.ISourceRootTranslatorFactory {
    public abstract virtual SourceRootTranslator Create(ILogger logger);
    public abstract virtual SourceRootTranslator Create(IEnumerable`1<string> sources, ILogger logger);
}
[NullableContextAttribute("1")]
internal interface Microsoft.CodeCoverage.Instrumentation.ISourcesReader {
    public abstract virtual IReadOnlyCollection`1<string> GetSourcePaths(string executable);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.CodeCoverage.Instrumentation.LibraryHelper : object {
    private String[] _staticInternalInstrumentationSections;
    private String[] _staticExternalInstrumentationSections;
    public sealed virtual LibraryInfo GetLibraryInfo(string path);
    public sealed virtual int GetTimeDateStamp(string path);
    public sealed virtual string GetAssemblyName(string path);
    public sealed virtual ImmutableArray`1<byte> GetSection(string path, string sectionName);
    public string GetPdbPath(string path);
    private string GetAssemblyName(PEReader reader);
    private string GetPdbPath(PEReader reader);
    private static bool ContainsAnySection(PEReader reader, IEnumerable`1<string> sectionNames);
    private static T OpenAndExecute(string path, Func`2<PEReader, T> function);
    private static bool IsNative(PEReader reader);
    [NullableContextAttribute("0")]
[CompilerGeneratedAttribute]
private LibraryInfo <GetLibraryInfo>b__2_0(PEReader r);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.CodeCoverage.Instrumentation.LibraryInfo : object {
    [CompilerGeneratedAttribute]
private bool <IsNative>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsManaged>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsExecutable>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsInstrumented>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsInternallyInstrumented>k__BackingField;
    [CompilerGeneratedAttribute]
private string <PdbPath>k__BackingField;
    [CompilerGeneratedAttribute]
protected Type EqualityContract { get; }
    public bool IsNative { get; public set; }
    public bool IsManaged { get; public set; }
    public bool IsExecutable { get; public set; }
    public bool IsInstrumented { get; public set; }
    public bool IsInternallyInstrumented { get; public set; }
    public string PdbPath { get; public set; }
    public LibraryInfo(bool IsNative, bool IsManaged, bool IsExecutable, bool IsInstrumented, bool IsInternallyInstrumented, string PdbPath);
    [CompilerGeneratedAttribute]
protected LibraryInfo(LibraryInfo original);
    [CompilerGeneratedAttribute]
protected virtual Type get_EqualityContract();
    [CompilerGeneratedAttribute]
public bool get_IsNative();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_IsNative(bool value);
    [CompilerGeneratedAttribute]
public bool get_IsManaged();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_IsManaged(bool value);
    [CompilerGeneratedAttribute]
public bool get_IsExecutable();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_IsExecutable(bool value);
    [CompilerGeneratedAttribute]
public bool get_IsInstrumented();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_IsInstrumented(bool value);
    [CompilerGeneratedAttribute]
public bool get_IsInternallyInstrumented();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_IsInternallyInstrumented(bool value);
    [CompilerGeneratedAttribute]
public string get_PdbPath();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_PdbPath(string value);
    [CompilerGeneratedAttribute]
public virtual string ToString();
    [CompilerGeneratedAttribute]
protected virtual bool PrintMembers(StringBuilder builder);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public static bool op_Inequality(LibraryInfo left, LibraryInfo right);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public static bool op_Equality(LibraryInfo left, LibraryInfo right);
    [CompilerGeneratedAttribute]
public virtual int GetHashCode();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public virtual bool Equals(object obj);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public virtual bool Equals(LibraryInfo other);
    [CompilerGeneratedAttribute]
public virtual LibraryInfo <Clone>$();
    [CompilerGeneratedAttribute]
public void Deconstruct(Boolean& IsNative, Boolean& IsManaged, Boolean& IsExecutable, Boolean& IsInstrumented, Boolean& IsInternallyInstrumented, String& PdbPath);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal static class Microsoft.CodeCoverage.Instrumentation.MessageGenerator : object {
    public static ModuleInstrumentedMessage CreateModuleInstrumentedMessage(AssemblyMetadata assemblyMetadata);
    public static ValueTuple`3<IList`1<FunctionInstrumentedMessage>, IList`1<FunctionSkippedMessage>, IList`1<SourceFileDataMessage>> CreateFunctionMessages(AssemblyMetadata assemblyMetadata);
    public static FunctionSkippedMessage CreateSkippedFunctionMessage(MethodMetadata method);
    public static InstrumentedFunctionMessage CreateInstrumentedFunctionMessage(MethodMetadata method, UInt32 offset);
    private static FunctionInstrumentedMessage CreateFunctionInstrumentedMessage(MethodMetadata method, UInt32 offset, IDictionary`2<string, SourceFileDataMessage> sourceFilesMap);
    private static UInt32 AddSourceFileDataMessage(SequencePointMetadata sequencePoint, IDictionary`2<string, SourceFileDataMessage> sourceFilesMap);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
internal class Microsoft.CodeCoverage.Instrumentation.Metadata.AssemblyMetadata : object {
    [CompilerGeneratedAttribute]
private PEReader <Reader>k__BackingField;
    [CompilerGeneratedAttribute]
private IPdbReader <PdbReader>k__BackingField;
    [NullableAttribute("1")]
[CompilerGeneratedAttribute]
private string <ModuleId>k__BackingField;
    [NullableAttribute("1")]
[CompilerGeneratedAttribute]
private string <Path>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Id>k__BackingField;
    [CompilerGeneratedAttribute]
private Byte[] <IdBytes>k__BackingField;
    [CompilerGeneratedAttribute]
private Guid <Identifier>k__BackingField;
    [CompilerGeneratedAttribute]
private UInt32 <ImageLinkTime>k__BackingField;
    [CompilerGeneratedAttribute]
private UInt32 <ImageSize>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsCodeCoverageEnabled>k__BackingField;
    [CompilerGeneratedAttribute]
private ModuleSkipReason <ModuleSkipReason>k__BackingField;
    [CompilerGeneratedAttribute]
private string <DetailedReason>k__BackingField;
    [CompilerGeneratedAttribute]
private string <TargetFramework>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Architecture>k__BackingField;
    [NullableAttribute("1")]
[CompilerGeneratedAttribute]
private string <Configuration>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsMixed>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <HasSecurityAttributes>k__BackingField;
    [NullableAttribute("1")]
[CompilerGeneratedAttribute]
private IDictionary`2<TypeDefinitionHandle, TypeMetadata> <TypesDictionary>k__BackingField;
    internal PEReader Reader { get; }
    internal IPdbReader PdbReader { get; }
    [NullableAttribute("1")]
public string ModuleId { get; }
    [NullableAttribute("1")]
public string Path { get; }
    public string Id { get; }
    public Byte[] IdBytes { get; }
    public Guid Identifier { get; }
    public UInt32 ImageLinkTime { get; }
    public UInt32 ImageSize { get; }
    public bool IsCodeCoverageEnabled { get; public set; }
    public ModuleSkipReason ModuleSkipReason { get; public set; }
    public string DetailedReason { get; }
    public string TargetFramework { get; }
    public string Architecture { get; }
    [NullableAttribute("1")]
public string Configuration { get; }
    public bool IsMixed { get; }
    public bool HasSecurityAttributes { get; }
    [NullableAttribute("1")]
public IDictionary`2<TypeDefinitionHandle, TypeMetadata> TypesDictionary { get; }
    [NullableAttribute("1")]
public ICollection`1<TypeMetadata> Types { get; }
    private AssemblyMetadata(string path, bool isCodeCoverageEnabled, ModuleSkipReason moduleSkipReason, string detailedReason, PEReader reader, UInt32 imageSize, UInt32 imageLinkTime, bool isMixed, string targetFramework, string architecture, string configuration, bool hasSecurityAttributes, IPdbReader pdbReader, Byte[] idBytes, Guid identifier, string id, IDictionary`2<TypeDefinitionHandle, TypeMetadata> types);
    [NullableContextAttribute("1")]
public static AssemblyMetadata CreateExcluded(string path, ModuleSkipReason moduleSkipReason, string detailedReason);
    [NullableContextAttribute("1")]
public static AssemblyMetadata CreateExcluded(string path, ModuleSkipReason moduleSkipReason, PEReader reader, UInt32 imageSize, UInt32 imageLinkTime, bool isMixed, string targetFramework, string architecture, string configuration, bool hasSecurityAttributes, IPdbReader pdbReader);
    [NullableContextAttribute("1")]
public static AssemblyMetadata CreateExcluded(string path, ModuleSkipReason moduleSkipReason, PEReader reader, UInt32 imageSize, UInt32 imageLinkTime, bool isMixed, string targetFramework, string architecture, string configuration, bool hasSecurityAttributes, IPdbReader pdbReader, Byte[] idBytes, Guid identifier, string id, IDictionary`2<TypeDefinitionHandle, TypeMetadata> types);
    [NullableContextAttribute("1")]
public static AssemblyMetadata Create(string path, PEReader reader, UInt32 imageSize, UInt32 imageLinkTime, bool isMixed, string targetFramework, string architecture, string configuration, bool hasSecurityAttributes, IPdbReader pdbReader, Byte[] idBytes, Guid identifier, string id, IDictionary`2<TypeDefinitionHandle, TypeMetadata> types);
    [CompilerGeneratedAttribute]
internal PEReader get_Reader();
    [CompilerGeneratedAttribute]
internal IPdbReader get_PdbReader();
    [NullableContextAttribute("1")]
[CompilerGeneratedAttribute]
public string get_ModuleId();
    [NullableContextAttribute("1")]
[CompilerGeneratedAttribute]
public string get_Path();
    [CompilerGeneratedAttribute]
public string get_Id();
    [CompilerGeneratedAttribute]
public Byte[] get_IdBytes();
    [CompilerGeneratedAttribute]
public Guid get_Identifier();
    [CompilerGeneratedAttribute]
public UInt32 get_ImageLinkTime();
    [CompilerGeneratedAttribute]
public UInt32 get_ImageSize();
    [CompilerGeneratedAttribute]
public bool get_IsCodeCoverageEnabled();
    [CompilerGeneratedAttribute]
public void set_IsCodeCoverageEnabled(bool value);
    [CompilerGeneratedAttribute]
public ModuleSkipReason get_ModuleSkipReason();
    [CompilerGeneratedAttribute]
public void set_ModuleSkipReason(ModuleSkipReason value);
    [CompilerGeneratedAttribute]
public string get_DetailedReason();
    [CompilerGeneratedAttribute]
public string get_TargetFramework();
    [CompilerGeneratedAttribute]
public string get_Architecture();
    [NullableContextAttribute("1")]
[CompilerGeneratedAttribute]
public string get_Configuration();
    [CompilerGeneratedAttribute]
public bool get_IsMixed();
    [CompilerGeneratedAttribute]
public bool get_HasSecurityAttributes();
    [NullableContextAttribute("1")]
[CompilerGeneratedAttribute]
public IDictionary`2<TypeDefinitionHandle, TypeMetadata> get_TypesDictionary();
    [NullableContextAttribute("1")]
public ICollection`1<TypeMetadata> get_Types();
    public sealed virtual void Dispose();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.CodeCoverage.Instrumentation.Metadata.AssemblyMetadataFactory : object {
    private static string Release;
    private static string GeneratedCodeAttribute;
    private static string DebuggableAttribute;
    private static string SystemSecurityNamespace;
    private IPdbReaderProvider _pdbReaderProvider;
    private ILogger _logger;
    private DataCollectorConfiguration _configuration;
    public AssemblyMetadataFactory(IPdbReaderProvider pdbReaderProvider, ILogger logger, DataCollectorConfiguration configuration);
    [AsyncStateMachineAttribute("Microsoft.CodeCoverage.Instrumentation.Metadata.AssemblyMetadataFactory/<CreateAsync>d__8")]
public sealed virtual Task`1<AssemblyMetadata> CreateAsync(string path, bool forceMetadataInitialization);
    private Nullable`1<ModuleSkipReason> IsExcluded(string path);
    private Nullable`1<ModuleSkipReason> IsExcludedByConfig(string path, MetadataReader metadataReader, String& configuration, Boolean& hasSecurityAttributes);
    private static string GetArchitecture(PEReader reader);
    private static Dictionary`2<TypeDefinitionHandle, TypeMetadata> GetTypes(ReflectionContainer reflectionContainer, TypeDefinitionHandleCollection handles);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.CodeCoverage.Instrumentation.Metadata.AssemblyMetadataProcessor : object {
    private ISourceRootTranslator _sourceRootTranslator;
    private DataCollectorConfiguration _configuration;
    private ILogger _logger;
    public AssemblyMetadataProcessor(ISourceRootTranslator sourceRootTranslator, ILogger logger, DataCollectorConfiguration configuration);
    public sealed virtual UInt32 Process(AssemblyMetadata assemblyMetadata, IModuleDefinitionManager moduleDefinitionManager, CancellationToken token);
    private bool IsIncludedBySources(AssemblyMetadata assemblyMetadata, IPdbReader pdbReader);
    private INoReturnMethodMetadataTokensProvider CreateNoReturnMethodMetadataTokensProvider(IModuleDefinitionManager moduleDefinitionManager);
    [NullableContextAttribute("0")]
[CompilerGeneratedAttribute]
private bool <IsIncludedBySources>b__5_0(string source);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Microsoft.CodeCoverage.Instrumentation.Metadata.CustomAttributeMetadata : object {
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Namespace>k__BackingField;
    [CompilerGeneratedAttribute]
private string <FullName>k__BackingField;
    public string Name { get; }
    public string Namespace { get; }
    public string FullName { get; }
    public CustomAttributeMetadata(MetadataReader metadataReader, TypeReference definition);
    public CustomAttributeMetadata(MetadataReader metadataReader, TypeDefinition definition);
    [CompilerGeneratedAttribute]
public string get_Name();
    [CompilerGeneratedAttribute]
public string get_Namespace();
    [CompilerGeneratedAttribute]
public string get_FullName();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.CodeCoverage.Instrumentation.Metadata.EventMetadata : MetadataBase`2<EventDefinition, EventDefinitionHandle> {
    private TypeMetadata _parent;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private IList`1<MethodMetadata> _methods;
    public IList`1<MethodMetadata> Methods { get; }
    public EventMetadata(ReflectionContainer reflectionContainer, EventDefinition definition, EventDefinitionHandle handle, TypeMetadata parent);
    public IList`1<MethodMetadata> get_Methods();
    protected virtual CustomAttributeHandleCollection GetCustomAttributes();
}
[NullableContextAttribute("1")]
internal interface Microsoft.CodeCoverage.Instrumentation.Metadata.IAssemblyMetadataFactory {
    public abstract virtual Task`1<AssemblyMetadata> CreateAsync(string path, bool forceMetadataInitialization);
}
[NullableContextAttribute("1")]
internal interface Microsoft.CodeCoverage.Instrumentation.Metadata.IAssemblyMetadataProcessor {
    public abstract virtual UInt32 Process(AssemblyMetadata assemblyMetadata, IModuleDefinitionManager moduleDefinitionManager, CancellationToken token);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal abstract class Microsoft.CodeCoverage.Instrumentation.Metadata.MetadataBase`2 : object {
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private IList`1<CustomAttributeMetadata> _customAttributes;
    private Nullable`1<bool> _isCompilerGenerated;
    [CompilerGeneratedAttribute]
private ReflectionContainer <ReflectionContainer>k__BackingField;
    [CompilerGeneratedAttribute]
private TDefinition <Definition>k__BackingField;
    [CompilerGeneratedAttribute]
private THandle <Handle>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    public ReflectionContainer ReflectionContainer { get; }
    public PEReader Reader { get; }
    public MetadataReader MetadataReader { get; }
    public IPdbReader PdbReader { get; }
    public TDefinition Definition { get; }
    public THandle Handle { get; }
    public string Name { get; protected set; }
    public IList`1<CustomAttributeMetadata> CustomAttributes { get; }
    public bool IsCompilerGenerated { get; }
    protected MetadataBase`2(ReflectionContainer reflectionContainer, TDefinition definition, THandle handle);
    [CompilerGeneratedAttribute]
public ReflectionContainer get_ReflectionContainer();
    public PEReader get_Reader();
    public MetadataReader get_MetadataReader();
    public IPdbReader get_PdbReader();
    [CompilerGeneratedAttribute]
public TDefinition get_Definition();
    [CompilerGeneratedAttribute]
public THandle get_Handle();
    [CompilerGeneratedAttribute]
public virtual string get_Name();
    [CompilerGeneratedAttribute]
protected virtual void set_Name(string value);
    public IList`1<CustomAttributeMetadata> get_CustomAttributes();
    public bool get_IsCompilerGenerated();
    protected abstract virtual CustomAttributeHandleCollection GetCustomAttributes();
}
[ExtensionAttribute]
internal static class Microsoft.CodeCoverage.Instrumentation.Metadata.MetadataReaderExtensions : object {
    [NullableAttribute("1")]
private static string PathPattern;
    private static MetadataReaderExtensions();
    [NullableContextAttribute("2")]
[ExtensionAttribute]
public static string DetectTargetFrameworkId(MetadataReader metadata, string assemblyPath);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.CodeCoverage.Instrumentation.Metadata.MethodBlock : ValueType {
    [CompilerGeneratedAttribute]
private int <Index>k__BackingField;
    [CompilerGeneratedAttribute]
private Instruction[] <Instructions>k__BackingField;
    public int Index { get; public set; }
    public Instruction[] Instructions { get; public set; }
    public int Offset { get; }
    public MethodBlock(int Index, Instruction[] Instructions);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public int get_Index();
    [CompilerGeneratedAttribute]
public void set_Index(int value);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public Instruction[] get_Instructions();
    [CompilerGeneratedAttribute]
public void set_Instructions(Instruction[] value);
    public int get_Offset();
    [NullableContextAttribute("0")]
[CompilerGeneratedAttribute]
public virtual string ToString();
    [NullableContextAttribute("0")]
[CompilerGeneratedAttribute]
private bool PrintMembers(StringBuilder builder);
    [CompilerGeneratedAttribute]
public static bool op_Inequality(MethodBlock left, MethodBlock right);
    [CompilerGeneratedAttribute]
public static bool op_Equality(MethodBlock left, MethodBlock right);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public virtual int GetHashCode();
    [IsReadOnlyAttribute]
[NullableContextAttribute("0")]
[CompilerGeneratedAttribute]
public virtual bool Equals(object obj);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public sealed virtual bool Equals(MethodBlock other);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public void Deconstruct(Int32& Index, Instruction[]& Instructions);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.CodeCoverage.Instrumentation.Metadata.MethodMetadata : MetadataBase`2<MethodDefinition, MethodDefinitionHandle> {
    private static int JustMyCodeWithNoSource;
    private TypeMetadata _parent;
    [NullableAttribute("2")]
private MethodBlock[] _methodBlocks;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private SequencePointMetadata[] _sequencePoints;
    private string _fullName;
    private string _parametersString;
    private string _qualifiedName;
    private string _sourceFile;
    [CompilerGeneratedAttribute]
private UInt32 <Id>k__BackingField;
    [CompilerGeneratedAttribute]
private UInt32 <MetadataToken>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsConstructor>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <HasSymbolicInformation>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsCodeCoverageEnabled>k__BackingField;
    [CompilerGeneratedAttribute]
private FunctionSkipReason <FunctionSkipReason>k__BackingField;
    [NullableAttribute("2")]
[CompilerGeneratedAttribute]
private SequencePointMetadata <FirstSequencePoint>k__BackingField;
    [NullableAttribute("2")]
[CompilerGeneratedAttribute]
private SequencePointMetadata <LastSequencePoint>k__BackingField;
    [NullableAttribute("2")]
[CompilerGeneratedAttribute]
private HashSet`1<int> <ExcludedBlockIndices>k__BackingField;
    public UInt32 Id { get; }
    public UInt32 MetadataToken { get; }
    public string FullName { get; }
    public string ParametersString { get; }
    public string QualifiedName { get; }
    public string TypeName { get; }
    public string NamespaceName { get; }
    public bool IsConstructor { get; private set; }
    public bool HasSymbolicInformation { get; private set; }
    public bool IsCodeCoverageEnabled { get; private set; }
    public FunctionSkipReason FunctionSkipReason { get; private set; }
    public MethodBlock[] MethodBlocks { get; }
    public SequencePointMetadata[] SequencePoints { get; }
    [NullableAttribute("2")]
internal SequencePointMetadata FirstSequencePoint { get; private set; }
    [NullableAttribute("2")]
internal SequencePointMetadata LastSequencePoint { get; private set; }
    [NullableAttribute("2")]
internal HashSet`1<int> ExcludedBlockIndices { get; private set; }
    public MethodMetadata(ReflectionContainer reflectionContainer, MethodDefinition definition, MethodDefinitionHandle handle, TypeMetadata parent);
    [CompilerGeneratedAttribute]
public UInt32 get_Id();
    [CompilerGeneratedAttribute]
public UInt32 get_MetadataToken();
    public string get_FullName();
    public string get_ParametersString();
    public string get_QualifiedName();
    public string get_TypeName();
    public string get_NamespaceName();
    [CompilerGeneratedAttribute]
public bool get_IsConstructor();
    [CompilerGeneratedAttribute]
private void set_IsConstructor(bool value);
    [CompilerGeneratedAttribute]
public bool get_HasSymbolicInformation();
    [CompilerGeneratedAttribute]
private void set_HasSymbolicInformation(bool value);
    [CompilerGeneratedAttribute]
public bool get_IsCodeCoverageEnabled();
    [CompilerGeneratedAttribute]
private void set_IsCodeCoverageEnabled(bool value);
    [CompilerGeneratedAttribute]
public FunctionSkipReason get_FunctionSkipReason();
    [CompilerGeneratedAttribute]
private void set_FunctionSkipReason(FunctionSkipReason value);
    public MethodBlock[] get_MethodBlocks();
    public SequencePointMetadata[] get_SequencePoints();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
internal SequencePointMetadata get_FirstSequencePoint();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
private void set_FirstSequencePoint(SequencePointMetadata value);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
internal SequencePointMetadata get_LastSequencePoint();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
private void set_LastSequencePoint(SequencePointMetadata value);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
internal HashSet`1<int> get_ExcludedBlockIndices();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
private void set_ExcludedBlockIndices(HashSet`1<int> value);
    private void PopulateName();
    internal void DisassembleFunction(ReusableCollections reusableContainers, IList`1<SequencePointMetadata> rawSequencePoints, ISet`1<UInt32> nonReturnMethodMetadataTokens, ISet`1<int> compilerGeneratedFieldMetadataTokens);
    [NullableContextAttribute("2")]
private void CalculateBlocks(ReusableCollections reusableContainers, ISet`1<UInt32> nonReturnMethodMetadataTokens, ISet`1<int> compilerGeneratedFieldMetadataTokens);
    private void CalculateInstructions(IList`1<Instruction> instructions, ISet`1<int> offsetsStartingBlocks, IDictionary`2<int, List`1<int>> tryOffsetToHandlerOffsets, ISet`1<int> offsetsOfNonReturnMethodsCalls, IDictionary`2<int, UInt32> staticFieldOffsetToMetadataToken, ISet`1<UInt32> noReturnMethodMetadataTokens, ISet`1<int> compilerGeneratedFieldMetadataTokens);
    private static void CalculateInstructions(IList`1<Instruction> instructions, MethodBodyBlock methodBody, ISet`1<int> offsetsOfNonReturnMethodsCalls, IDictionary`2<int, UInt32> staticFieldOffsetToMetadataToken, ISet`1<UInt32> nonReturnMethodMetadataTokens, ISet`1<int> compilerGeneratedFieldMetadataTokens);
    private static ValueTuple`2<Instruction, int> GetInstructionAndSize(BlobReader blob, ISet`1<int> offsetsOfNonReturnMethodsCalls, IDictionary`2<int, UInt32> staticFieldOffsetToMetadataToken, ISet`1<UInt32> nonReturnMethodMetadataTokens, ISet`1<int> compilerGeneratedFieldMetadataTokens);
    [NullableContextAttribute("0")]
private static ValueTuple`2<Instruction, int> GetSwitchInstruction(BlobReader blob, InstructionTerminationType terminationType, ILOpCodeInfo info, int offset);
    [NullableContextAttribute("0")]
private static ValueTuple`2<Instruction, int> GetBranchInstruction(BlobReader blob, ILOpCode opCode, InstructionTerminationType terminationType, ILOpCodeInfo info, int offset);
    private static ValueTuple`2<Instruction, int> GetCallInstruction(BlobReader blob, ILOpCode opCode, InstructionTerminationType terminationType, ILOpCodeInfo info, int startingOffset, ISet`1<int> offsetsOfNonReturnMethodsCalls, ISet`1<UInt32> noReturnMethodMetadataTokens);
    private static ValueTuple`2<Instruction, int> GetStaticFieldInstruction(BlobReader blob, ILOpCode opCode, InstructionTerminationType terminationType, ILOpCodeInfo info, int startingOffset, IDictionary`2<int, UInt32> staticFieldOffsetToMetadataToken, ISet`1<int> compilerGeneratedFieldMetadataTokens);
    private static void MarkTargetInstructionsAsBlockStarters(IList`1<Instruction> instructions, ISet`1<int> offsetsStartingBlocks);
    private static void MarkExceptionRegionsAsBlockStarters(MethodBodyBlock methodBody, ISet`1<int> offsetsStartingBlocks, IDictionary`2<int, List`1<int>> tryOffsetToHandlerOffsets, ISet`1<int> offsetsOfNonReturnMethodsCalls);
    private void CalculateBlocks(ReusableCollections reusableContainers, IList`1<Instruction> instructions, ISet`1<int> offsetsStartingBlocks, IDictionary`2<int, List`1<int>> tryOffsetToHandlerOffsets, ISet`1<int> offsetsOfNonReturnMethodsCalls, ISet`1<int> reachableOffsets, IDictionary`2<int, UInt32> staticFieldOffsetToMetadataToken);
    private void ProcessBlocks(ReusableCollections reusableContainers, IList`1<Instruction> instructions, ISet`1<int> offsetsStartingBlocks, IDictionary`2<int, List`1<int>> tryOffsetToHandlerOffsets, ISet`1<int> offsetsOfNonReturnMethodsCalls, ISet`1<int> reachableOffsets, IDictionary`2<int, UInt32> staticFieldOffsetToMetadataToken);
    private void PopulateSequencePoints(ReusableCollections reusableContainers, IList`1<SequencePointMetadata> rawSequencePoints);
    private void PopulateSequencePointForOtherBlocks(IList`1<SequencePointMetadata> sequencePoints, SequencePointMetadata point, int upperBound, ISet`1<int> alreadyClearedBlocks);
    private void AppendSequencePoint(IList`1<SequencePointMetadata> sequencePoints, SequencePointMetadata sequencePoint, ISet`1<int> alreadyClearedBlocks);
    protected virtual CustomAttributeHandleCollection GetCustomAttributes();
    [NullableContextAttribute("2")]
internal void Process(ReusableCollections reusableContainers, ISet`1<UInt32> nonReturnMethodMetadataTokens, ISet`1<int> compilerGeneratedFieldMetadataTokens);
    [NullableContextAttribute("2")]
private bool InternalProcess(ReusableCollections reusableContainers, ISet`1<UInt32> nonReturnMethodMetadataTokens, ISet`1<int> compilerGeneratedFieldMetadataTokens);
    private bool AreSourcesPartOfOtherMethodSources(MethodMetadata other);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.CodeCoverage.Instrumentation.Metadata.PropertyMetadata : MetadataBase`2<PropertyDefinition, PropertyDefinitionHandle> {
    private TypeMetadata _parent;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private IList`1<MethodMetadata> _methods;
    public IList`1<MethodMetadata> Methods { get; }
    public PropertyMetadata(ReflectionContainer reflectionContainer, PropertyDefinition definition, PropertyDefinitionHandle handle, TypeMetadata parent);
    public IList`1<MethodMetadata> get_Methods();
    protected virtual CustomAttributeHandleCollection GetCustomAttributes();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.CodeCoverage.Instrumentation.Metadata.ReflectionContainer : object {
    [CompilerGeneratedAttribute]
private PEReader <Reader>k__BackingField;
    [CompilerGeneratedAttribute]
private MetadataReader <MetadataReader>k__BackingField;
    [CompilerGeneratedAttribute]
private IPdbReader <PdbReader>k__BackingField;
    [CompilerGeneratedAttribute]
private SignatureVisualizer <SignatureVisualizer>k__BackingField;
    [CompilerGeneratedAttribute]
private CodeCoverageConfig <CodeCoverageConfig>k__BackingField;
    public PEReader Reader { get; }
    public MetadataReader MetadataReader { get; }
    public IPdbReader PdbReader { get; }
    internal SignatureVisualizer SignatureVisualizer { get; }
    public CodeCoverageConfig CodeCoverageConfig { get; }
    public ReflectionContainer(PEReader reader, MetadataReader metadataReader, IPdbReader pdbReaderProvider, CodeCoverageConfig codeCoverageConfig);
    [CompilerGeneratedAttribute]
public PEReader get_Reader();
    [CompilerGeneratedAttribute]
public MetadataReader get_MetadataReader();
    [CompilerGeneratedAttribute]
public IPdbReader get_PdbReader();
    [CompilerGeneratedAttribute]
internal SignatureVisualizer get_SignatureVisualizer();
    [CompilerGeneratedAttribute]
public CodeCoverageConfig get_CodeCoverageConfig();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Microsoft.CodeCoverage.Instrumentation.Metadata.SequencePointMetadata : object {
    [CompilerGeneratedAttribute]
private int <Offset>k__BackingField;
    [CompilerGeneratedAttribute]
private int <StartLine>k__BackingField;
    [CompilerGeneratedAttribute]
private int <StartColumn>k__BackingField;
    [CompilerGeneratedAttribute]
private int <EndLine>k__BackingField;
    [CompilerGeneratedAttribute]
private int <EndColumn>k__BackingField;
    [CompilerGeneratedAttribute]
private string <SourceFilePath>k__BackingField;
    [CompilerGeneratedAttribute]
private Byte[] <Checksum>k__BackingField;
    [CompilerGeneratedAttribute]
private Guid <ChecksumAlgorithm>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsHidden>k__BackingField;
    [CompilerGeneratedAttribute]
private int <CurrentBlockOffset>k__BackingField;
    [CompilerGeneratedAttribute]
private int <NextBlockOffset>k__BackingField;
    [CompilerGeneratedAttribute]
protected Type EqualityContract { get; }
    public int Offset { get; public set; }
    public int StartLine { get; public set; }
    public int StartColumn { get; public set; }
    public int EndLine { get; public set; }
    public int EndColumn { get; public set; }
    public string SourceFilePath { get; public set; }
    public Byte[] Checksum { get; public set; }
    public Guid ChecksumAlgorithm { get; public set; }
    public bool IsHidden { get; public set; }
    public int CurrentBlockOffset { get; public set; }
    public int NextBlockOffset { get; public set; }
    public SequencePointMetadata(int Offset, int StartLine, int StartColumn, int EndLine, int EndColumn, string SourceFilePath, Byte[] Checksum, Guid ChecksumAlgorithm, bool IsHidden);
    [CompilerGeneratedAttribute]
protected SequencePointMetadata(SequencePointMetadata original);
    [CompilerGeneratedAttribute]
protected virtual Type get_EqualityContract();
    [CompilerGeneratedAttribute]
public int get_Offset();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_Offset(int value);
    [CompilerGeneratedAttribute]
public int get_StartLine();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_StartLine(int value);
    [CompilerGeneratedAttribute]
public int get_StartColumn();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_StartColumn(int value);
    [CompilerGeneratedAttribute]
public int get_EndLine();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_EndLine(int value);
    [CompilerGeneratedAttribute]
public int get_EndColumn();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_EndColumn(int value);
    [CompilerGeneratedAttribute]
public string get_SourceFilePath();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_SourceFilePath(string value);
    [CompilerGeneratedAttribute]
public Byte[] get_Checksum();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_Checksum(Byte[] value);
    [CompilerGeneratedAttribute]
public Guid get_ChecksumAlgorithm();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_ChecksumAlgorithm(Guid value);
    [CompilerGeneratedAttribute]
public bool get_IsHidden();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_IsHidden(bool value);
    [CompilerGeneratedAttribute]
public int get_CurrentBlockOffset();
    [CompilerGeneratedAttribute]
public void set_CurrentBlockOffset(int value);
    [CompilerGeneratedAttribute]
public int get_NextBlockOffset();
    [CompilerGeneratedAttribute]
public void set_NextBlockOffset(int value);
    [CompilerGeneratedAttribute]
public virtual string ToString();
    [CompilerGeneratedAttribute]
protected virtual bool PrintMembers(StringBuilder builder);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public static bool op_Inequality(SequencePointMetadata left, SequencePointMetadata right);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public static bool op_Equality(SequencePointMetadata left, SequencePointMetadata right);
    [CompilerGeneratedAttribute]
public virtual int GetHashCode();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public virtual bool Equals(object obj);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public virtual bool Equals(SequencePointMetadata other);
    [CompilerGeneratedAttribute]
public virtual SequencePointMetadata <Clone>$();
    [CompilerGeneratedAttribute]
public void Deconstruct(Int32& Offset, Int32& StartLine, Int32& StartColumn, Int32& EndLine, Int32& EndColumn, String& SourceFilePath, Byte[]& Checksum, Guid& ChecksumAlgorithm, Boolean& IsHidden);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.CodeCoverage.Instrumentation.Metadata.TypeMetadata : MetadataBase`2<TypeDefinition, TypeDefinitionHandle> {
    [NullableAttribute("2")]
private TypeMetadata _parentType;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private IList`1<PropertyMetadata> _properties;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private IList`1<EventMetadata> _events;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private IList`1<MethodMetadata> _methods;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private IDictionary`2<UInt32, MethodMetadata> _methodsExcludedByAttribute;
    private string _name;
    private string _namespaceName;
    private string _fullName;
    private string _constructorName;
    private Nullable`1<bool> _isCodeCoverageEnabled;
    private bool _metadataPopulated;
    public string Name { get; }
    public string ConstructorName { get; }
    public string FullName { get; }
    public string NamespaceName { get; }
    public bool IsCodeCoverageEnabled { get; }
    public IList`1<PropertyMetadata> Properties { get; }
    public IList`1<EventMetadata> Events { get; }
    public IList`1<MethodMetadata> Methods { get; }
    public IEnumerable`1<MethodMetadata> MethodsExcludedByAttribute { get; }
    public TypeMetadata(ReflectionContainer reflectionContainer, TypeDefinition definition, TypeDefinitionHandle handle);
    public void PopulateMetadata(Dictionary`2<TypeDefinitionHandle, TypeMetadata> types);
    public virtual string get_Name();
    public string get_ConstructorName();
    public string get_FullName();
    public string get_NamespaceName();
    public bool get_IsCodeCoverageEnabled();
    protected virtual CustomAttributeHandleCollection GetCustomAttributes();
    public IList`1<PropertyMetadata> get_Properties();
    public IList`1<EventMetadata> get_Events();
    public IList`1<MethodMetadata> get_Methods();
    public IEnumerable`1<MethodMetadata> get_MethodsExcludedByAttribute();
    public bool IsMethodExcludedByAttribute(UInt32 metadataToken);
    internal void AddMethodExcludedByAttribute(MethodMetadata methodMetadata);
    private bool IsIncluded();
    private static ValueTuple`2<string, string> GetNameAndNamespaceName(TypeDefinition definition, string postfix, MetadataReader metadataReader, Dictionary`2<TypeDefinitionHandle, TypeMetadata> types);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.CodeCoverage.Instrumentation.MonoCecilNoReturnMethodMetadataTokensProvider : object {
    private IModuleDefinitionManager _moduleDefinitionManager;
    private ILogger _logger;
    private static string DoesNotReturnAttribute;
    public MonoCecilNoReturnMethodMetadataTokensProvider(IModuleDefinitionManager moduleDefinitionManager, ILogger logger);
    public sealed virtual ISet`1<UInt32> GetMetadataTokens(AssemblyMetadata assemblyMetadata);
    private ImmutableHashSet`1<MetadataToken> CreateForModule(ModuleDefinition module, String[] doesNotReturnAttributes);
    private static bool IsCall(Instruction instruction, MethodReference& method);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.CodeCoverage.Instrumentation.MsdiaPdbReader : object {
    private IDictionary`2<UInt32, SourceDocumentData> _sourceFiles;
    private IDictionary`2<UInt32, FunctionSequencePointsMessage> _functions;
    [CompilerGeneratedAttribute]
private Byte[] <IdBytes>k__BackingField;
    [CompilerGeneratedAttribute]
private string <PdbPath>k__BackingField;
    public Byte[] IdBytes { get; }
    public string PdbPath { get; }
    public bool IsSourcesPreLoadSupported { get; }
    public MsdiaPdbReader(string pdbPath, Byte[] idBytes, IDictionary`2<UInt32, SourceDocumentData> sourceFiles, IDictionary`2<UInt32, FunctionSequencePointsMessage> functions);
    [CompilerGeneratedAttribute]
public sealed virtual Byte[] get_IdBytes();
    [CompilerGeneratedAttribute]
public sealed virtual string get_PdbPath();
    public sealed virtual bool get_IsSourcesPreLoadSupported();
    [IteratorStateMachineAttribute("Microsoft.CodeCoverage.Instrumentation.MsdiaPdbReader/<GetSequencePoints>d__11")]
public sealed virtual IEnumerable`1<SequencePointMetadata> GetSequencePoints(MethodDefinitionHandle handle);
    [IteratorStateMachineAttribute("Microsoft.CodeCoverage.Instrumentation.MsdiaPdbReader/<GetSourceFiles>d__12")]
public sealed virtual IEnumerable`1<string> GetSourceFiles(MethodDefinitionHandle handle);
    public sealed virtual int GetStateMachineKickoffMethod(MethodDefinitionHandle handle);
    public sealed virtual IEnumerable`1<string> GetSources();
    public sealed virtual void Dispose();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.CodeCoverage.Instrumentation.MsdiaPdbReaderFactory : object {
    private static string LoadSymbolsName;
    private static string GetSymbolsName;
    private static string DisposeSymbolsName;
    private IEnvironment _environment;
    private IProfilersLocationProvider _profilersLocationProvider;
    private INativeHelper _nativeHelper;
    private INativeFunctionLoader _nativeFunctionLoader;
    private IFileHelper _fileHelper;
    private ILogger _logger;
    private DataCollectorConfiguration _configuration;
    public MsdiaPdbReaderFactory(IEnvironment environment, IProfilersLocationProvider profilersLocationProvider, INativeHelper nativeHelper, INativeFunctionLoader nativeFunctionLoader, IFileHelper fileHelper, ILogger logger, DataCollectorConfiguration configuration);
    public sealed virtual IPdbReader Create(DebugDirectoryEntry entry, CodeViewDebugDirectoryData data, string pdbPath, Byte[] idBytes, ISourceRootResolver sourceRootResolver);
    private ValueTuple`2<Byte[], long> GetNativeData(DebugDirectoryEntry entry, CodeViewDebugDirectoryData data, string pdbPath);
    private long GetNativeDataSize(string correlationId, IntPtr libraryModule, DebugDirectoryEntry entry, CodeViewDebugDirectoryData data, string pdbPath);
    private bool ReadNativeData(string correlationId, IntPtr libraryModule, Byte[] buffer, long dataSize);
    private void DisposeNativeData(string correlationId, IntPtr libraryModule);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.CodeCoverage.Instrumentation.MsdiaSourcesReader : object {
    private static string LoadSourcesName;
    private static string GetSourcesName;
    private static string DisposeSourcesName;
    private IEnvironment _environment;
    private IProfilersLocationProvider _profilersLocationProvider;
    private INativeHelper _nativeHelper;
    private INativeFunctionLoader _nativeFunctionLoader;
    private IFileHelper _fileHelper;
    private ILogger _logger;
    private DataCollectorConfiguration _configuration;
    public MsdiaSourcesReader(IEnvironment environment, IProfilersLocationProvider profilersLocationProvider, INativeHelper nativeHelper, INativeFunctionLoader nativeFunctionLoader, IFileHelper fileHelper, ILogger logger, DataCollectorConfiguration configuration);
    public sealed virtual IReadOnlyCollection`1<string> GetSourcePaths(string executable);
    private ValueTuple`2<Byte[], long> GetNativeData(string executable);
    private long GetNativeDataSize(string correlationId, IntPtr libraryModule, string executable);
    private bool ReadNativeData(string correlationId, IntPtr libraryModule, Byte[] buffer, long dataSize);
    private void DisposeNativeData(string correlationId, IntPtr libraryModule);
}
internal enum Microsoft.CodeCoverage.Instrumentation.PdbLocation : Enum {
    public int value__;
    public static PdbLocation None;
    public static PdbLocation AssemblyLocation;
    public static PdbLocation SymbolsSearchPaths;
    public static PdbLocation OriginalLocation;
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.CodeCoverage.Instrumentation.PdbReaderProvider : object {
    private IMsdiaPdbReaderFactory _msdiaPdbReaderFactory;
    private ISourceRootTranslator _sourceRootTranslator;
    private ISourceRootResolverFactory _sourceRootResolverFactory;
    private ILogger _logger;
    private DataCollectorConfiguration _configuration;
    public PdbReaderProvider(IMsdiaPdbReaderFactory msdiaPdbReaderFactory, ISourceRootTranslator sourceRootTranslator, ISourceRootResolverFactory sourceRootResolverFactory, ILogger logger, DataCollectorConfiguration configuration);
    [AsyncStateMachineAttribute("Microsoft.CodeCoverage.Instrumentation.PdbReaderProvider/<GetPdbDataProviderAsync>d__6")]
public sealed virtual Task`1<IPdbReader> GetPdbDataProviderAsync(string path, PEReader reader);
    private bool LoadPortablePdbReader(string path, PEReader reader, DebugDirectoryEntry entry, MetadataReaderProvider& provider, String& pdbPath);
    [IteratorStateMachineAttribute("Microsoft.CodeCoverage.Instrumentation.PdbReaderProvider/<TryFindPdbPath>d__8")]
private IEnumerable`1<string> TryFindPdbPath(string path, PEReader reader, DebugDirectoryEntry entry);
    [IteratorStateMachineAttribute("Microsoft.CodeCoverage.Instrumentation.PdbReaderProvider/<SearchPdbFileName>d__9")]
private IEnumerable`1<string> SearchPdbFileName(string pdbFileName, string path);
    [AsyncStateMachineAttribute("Microsoft.CodeCoverage.Instrumentation.PdbReaderProvider/<OpenStreamAsync>d__10")]
private static Task`1<Stream> OpenStreamAsync(string path);
    private static Stream OpenStream(string path);
    private static Byte[] GetIdBytes(PEReader reader, DebugDirectoryEntry entry);
    private static bool IsLegacyPdb(string pdbPath);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.CodeCoverage.Instrumentation.PortablePdbReader : object {
    private MetadataReader _metadataReader;
    private MetadataReaderProvider _metadataReaderProvider;
    private ISourceRootResolver _sourceRootResolver;
    private IDictionary`2<DocumentHandle, SourceDocumentData> _sourceFiles;
    private bool _disposed;
    [NullableAttribute("2")]
[CompilerGeneratedAttribute]
private string <PdbPath>k__BackingField;
    [CompilerGeneratedAttribute]
private Byte[] <IdBytes>k__BackingField;
    [NullableAttribute("2")]
public string PdbPath { get; }
    public Byte[] IdBytes { get; }
    public bool IsSourcesPreLoadSupported { get; }
    public PortablePdbReader(MetadataReaderProvider metadataReaderProvider, MetadataReaderOptions options, string pdbPath, ISourceRootResolver sourceRootResolver);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public sealed virtual string get_PdbPath();
    [CompilerGeneratedAttribute]
public sealed virtual Byte[] get_IdBytes();
    public sealed virtual bool get_IsSourcesPreLoadSupported();
    [IteratorStateMachineAttribute("Microsoft.CodeCoverage.Instrumentation.PortablePdbReader/<GetSequencePoints>d__14")]
public sealed virtual IEnumerable`1<SequencePointMetadata> GetSequencePoints(MethodDefinitionHandle handle);
    [IteratorStateMachineAttribute("Microsoft.CodeCoverage.Instrumentation.PortablePdbReader/<GetSourceFiles>d__15")]
public sealed virtual IEnumerable`1<string> GetSourceFiles(MethodDefinitionHandle handle);
    public sealed virtual int GetStateMachineKickoffMethod(MethodDefinitionHandle handle);
    public sealed virtual void Dispose();
    protected virtual void Dispose(bool disposing);
    [IteratorStateMachineAttribute("Microsoft.CodeCoverage.Instrumentation.PortablePdbReader/<GetSources>d__19")]
public sealed virtual IEnumerable`1<string> GetSources();
    private void InitializeSources();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal static class Microsoft.CodeCoverage.Instrumentation.ReachabilityHelper : object {
    public static bool AreInstructionsUnreachable(Instruction[] instructions, int blockIndex, IDictionary`2<int, List`1<int>> tryOffsetToHandlerOffsets, ISet`1<int> reachableOffsets, ISet`1<int> offsetsOfNonReturnMethodsCalls, Boolean& hasNonReturnMethodCall, Int32& callInstructionBlockIndex);
    public static bool HasCompilerGeneratedBranch(MethodBlock currentBlock, MethodBlock previousBlock, MethodBlock nextBlock, IDictionary`2<int, UInt32> staticFieldOffsetToMetadataToken);
    [NullableContextAttribute("0")]
private static ValueTuple`2<bool, UInt32> ContainsLoadStaticFieldInstruction(MethodBlock methodBlock, IDictionary`2<int, UInt32> staticFieldOffsetToMetadataToken);
    private static bool EndsWithConditionalBranchInstruction(MethodBlock methodBlock);
    private static bool EndsWithNewObjInstruction(MethodBlock methodBlock);
    private static bool EndsWithReplaceStaticFieldInstruction(MethodBlock methodBlock, UInt32 staticFieldMetadataToken, IDictionary`2<int, UInt32> staticFieldOffsetToMetadataToken);
    public static bool IsPartOfExpressionBreakpointsPattern(MethodBlock currentBlock, MethodBlock previousBlock, MethodBlock nextBlock);
    private static bool IsExpressionBreakpointsPattern(Instruction instruction1, Instruction instruction2, Instruction instruction3);
}
internal class Microsoft.CodeCoverage.Instrumentation.ReflectionMetadataNoReturnMethodMetadataTokensProvider : object {
    [NullableAttribute("1")]
private static string DoesNotReturnAttribute;
    [NullableContextAttribute("1")]
public sealed virtual ISet`1<UInt32> GetMetadataTokens(AssemblyMetadata assemblyMetadata);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.CodeCoverage.Instrumentation.SignatureVisualizer : object {
    private MetadataReader _metadataReader;
    private ConcurrentDictionary`2<EntityHandle, string> _handleNameDictionary;
    public SignatureVisualizer(MetadataReader metadataReader);
    public sealed virtual string GetPrimitiveType(PrimitiveTypeCode typeCode);
    private string RowId(EntityHandle handle);
    public sealed virtual string GetTypeFromDefinition(MetadataReader reader, TypeDefinitionHandle handle, byte rawTypeKind);
    public sealed virtual string GetTypeFromReference(MetadataReader reader, TypeReferenceHandle handle, byte rawTypeKind);
    public sealed virtual string GetTypeFromSpecification(MetadataReader reader, MethodDefinition genericContext, TypeSpecificationHandle handle, byte rawTypeKind);
    private string GetFullTypeName(MetadataReader reader, TypeDefinitionHandle handle);
    private string GetFullTypeName(MetadataReader reader, TypeReferenceHandle handle);
    private string GetFullTypeName(string name, string namespaceName, EntityHandle handle);
    public sealed virtual string GetSZArrayType(string elementType);
    public sealed virtual string GetPointerType(string elementType);
    public sealed virtual string GetByReferenceType(string elementType);
    public sealed virtual string GetGenericMethodParameter(MethodDefinition genericContext, int index);
    public sealed virtual string GetGenericTypeParameter(MethodDefinition genericContext, int index);
    public sealed virtual string GetPinnedType(string elementType);
    public sealed virtual string GetGenericInstantiation(string genericType, ImmutableArray`1<string> typeArguments);
    public sealed virtual string GetModifiedType(string modifierType, string unmodifiedType, bool isRequired);
    public sealed virtual string GetArrayType(string elementType, ArrayShape shape);
    public sealed virtual string GetFunctionPointerType(MethodSignature`1<string> signature);
    private static string MethodSignature(MethodSignature`1<string> signature);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.CodeCoverage.Instrumentation.SourceDocumentData : ValueType {
    [CompilerGeneratedAttribute]
private string <Path>k__BackingField;
    [CompilerGeneratedAttribute]
private Byte[] <Checksum>k__BackingField;
    [CompilerGeneratedAttribute]
private Guid <ChecksumAlgorithm>k__BackingField;
    public string Path { get; public set; }
    public Byte[] Checksum { get; public set; }
    public Guid ChecksumAlgorithm { get; public set; }
    public SourceDocumentData(string Path, Byte[] Checksum, Guid ChecksumAlgorithm);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public string get_Path();
    [CompilerGeneratedAttribute]
public void set_Path(string value);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public Byte[] get_Checksum();
    [CompilerGeneratedAttribute]
public void set_Checksum(Byte[] value);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public Guid get_ChecksumAlgorithm();
    [CompilerGeneratedAttribute]
public void set_ChecksumAlgorithm(Guid value);
    [IsReadOnlyAttribute]
[NullableContextAttribute("0")]
[CompilerGeneratedAttribute]
public virtual string ToString();
    [IsReadOnlyAttribute]
[NullableContextAttribute("0")]
[CompilerGeneratedAttribute]
private bool PrintMembers(StringBuilder builder);
    [CompilerGeneratedAttribute]
public static bool op_Inequality(SourceDocumentData left, SourceDocumentData right);
    [CompilerGeneratedAttribute]
public static bool op_Equality(SourceDocumentData left, SourceDocumentData right);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public virtual int GetHashCode();
    [IsReadOnlyAttribute]
[NullableContextAttribute("0")]
[CompilerGeneratedAttribute]
public virtual bool Equals(object obj);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public sealed virtual bool Equals(SourceDocumentData other);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public void Deconstruct(String& Path, Byte[]& Checksum, Guid& ChecksumAlgorithm);
}
internal class Microsoft.CodeCoverage.Instrumentation.SourceRootResolverFactory : object {
    [NullableContextAttribute("1")]
public sealed virtual ISourceRootResolver Create(ISourceRootTranslator sourceRootTranslator);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.CodeCoverage.Instrumentation.SourceRootTranslator : object {
    private ILogger _logger;
    private IFileHelper _fileHelper;
    private IInclusionChecker _inclusionChecker;
    private IReadOnlyDictionary`2<string, Dictionary`2<string, List`1<string>>> _sourceRootMapping;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private ConcurrentDictionary`2<string, ValueTuple`3<string, string, string>> _cachedMappings;
    private ConcurrentDictionary`2<string, bool> _cachedPaths;
    public SourceRootTranslator(ILogger logger, IFileHelper fileHelper, IInclusionChecker inclusionChecker, IReadOnlyDictionary`2<string, Dictionary`2<string, List`1<string>>> sourceRootMapping);
    public sealed virtual ValueTuple`3<string, string, string> ResolveFilePath(string path);
    public sealed virtual bool Exists(string path);
    private bool InternalResolveFilePath(string path);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.CodeCoverage.Instrumentation.SourceRootTranslatorFactory : object {
    private static String[] Prefixes;
    private IFileHelper _fileHelper;
    private IDirectoryHelper _directoryHelper;
    private ILibraryHelper _libraryHelper;
    private IInclusionChecker _inclusionChecker;
    public SourceRootTranslatorFactory(IFileHelper fileHelper, IDirectoryHelper directoryHelper, ILibraryHelper libraryHelper, IInclusionChecker inclusionChecker);
    private static SourceRootTranslatorFactory();
    public sealed virtual SourceRootTranslator Create(ILogger logger);
    public sealed virtual SourceRootTranslator Create(IEnumerable`1<string> sources, ILogger logger);
    private IReadOnlyDictionary`2<string, Dictionary`2<string, List`1<string>>> LoadSourceRootMapping(IEnumerable`1<string> paths, ILogger logger);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.CodeCoverage.Instrumentation.SourceRootTranslatorFileHelper : object {
    private IFileHelper _innerFileHelper;
    private IDirectoryHelper _directoryHelper;
    private ConcurrentDictionary`2<string, bool> _directoriesCache;
    public SourceRootTranslatorFileHelper(IFileHelper innerFileHelper, IDirectoryHelper directoryHelper);
    public sealed virtual void Copy(string sourceFileName, string destFileName, bool overwrite);
    public sealed virtual void Delete(string path);
    public sealed virtual bool Exists(string path);
    public sealed virtual bool Exists(FileInfo fileInfo);
    public sealed virtual void Move(string sourceFileName, string destFileName);
    public sealed virtual Stream OpenRead(string path);
    public sealed virtual String[] ReadAllLines(string path);
    public sealed virtual string ReadAllText(string path);
    public sealed virtual void WriteAllText(string path, string contents);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.CodeCoverage.Instrumentation.Static.AssemblyResolverFactory : object {
    private IDirectoryHelper _directoryHelper;
    private IAssemblyResolver _netStandardAssemblyResolver;
    public AssemblyResolverFactory(IDirectoryHelper directoryHelper);
    public sealed virtual IAssemblyResolver Create(string modulePath, ILogger logger);
    public sealed virtual void Dispose();
    private IAssemblyResolver CreateMonoCecilAssemblyResolver(string modulePath);
    private IAssemblyResolver CreateDependencyAssemblyResolver(string modulePath, ILogger logger);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.CodeCoverage.Instrumentation.Static.AssemblyResolversAggregator : object {
    private IAssemblyResolver[] _assemblyResolvers;
    public AssemblyResolversAggregator(IAssemblyResolver[] assemblyResolvers);
    public sealed virtual AssemblyDefinition Resolve(AssemblyNameReference name);
    public sealed virtual AssemblyDefinition Resolve(AssemblyNameReference name, ReaderParameters parameters);
    private AssemblyDefinition InternalResolve(AssemblyNameReference name, Func`2<IAssemblyResolver, AssemblyDefinition> resolver);
    public sealed virtual void Dispose();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.CodeCoverage.Instrumentation.Static.ConfigurationInclusionChecker : object {
    private DataCollectorConfiguration _configuration;
    public ConfigurationInclusionChecker(DataCollectorConfiguration configuration);
    public sealed virtual bool IsIncluded(string path);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.CodeCoverage.Instrumentation.Static.CoverageStaticArgumentsProvider : object {
    private string _session;
    public CoverageStaticArgumentsProvider(string session);
    public sealed virtual string GetBufferEnvironmentVariable(string path);
    public sealed virtual string GetCtsConfigurationPath();
    public sealed virtual string GetSession();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.CodeCoverage.Instrumentation.Static.DependencyAssemblyResolver : object {
    private string _searchDirectory;
    private ILogger _logger;
    private IDirectoryHelper _directoryHelper;
    private Lazy`1<CompositeCompilationAssemblyResolver> _compositeResolver;
    public DependencyAssemblyResolver(string modulePath, ILogger logger, IDirectoryHelper directoryHelper);
    public sealed virtual AssemblyDefinition Resolve(AssemblyNameReference name);
    public sealed virtual AssemblyDefinition Resolve(AssemblyNameReference name, ReaderParameters parameters);
    public sealed virtual void Dispose();
}
internal class Microsoft.CodeCoverage.Instrumentation.Static.EmptyInclusionChecker : object {
    [NullableContextAttribute("1")]
public sealed virtual bool IsIncluded(string path);
}
internal interface Microsoft.CodeCoverage.Instrumentation.Static.IAssemblyResolverFactory {
    [NullableContextAttribute("1")]
public abstract virtual IAssemblyResolver Create(string modulePath, ILogger logger);
}
[NullableContextAttribute("1")]
internal interface Microsoft.CodeCoverage.Instrumentation.Static.IStaticArgumentsProvider {
    public abstract virtual string GetSession();
    public abstract virtual string GetCtsConfigurationPath();
    public abstract virtual string GetBufferEnvironmentVariable(string path);
}
[NullableContextAttribute("1")]
internal interface Microsoft.CodeCoverage.Instrumentation.Static.IStaticInstrumenter {
    public abstract virtual Task`1<StaticInstrumentationResult> InstrumentAsync(IReadOnlyCollection`1<IncludeDirectory> includeDirectories, IEnumerable`1<string> additionalFiles);
}
[NullableContextAttribute("1")]
internal interface Microsoft.CodeCoverage.Instrumentation.Static.IStaticInstrumenterFilesFinder {
    public abstract virtual IDictionary`2<string, StaticInstrumenterFileCheckResult> Find(IReadOnlyCollection`1<IncludeDirectory> includeDirectories, IEnumerable`1<string> additionalFiles, IEnumerable`1<string> excludedFiles);
}
[NullableContextAttribute("1")]
internal interface Microsoft.CodeCoverage.Instrumentation.Static.IStaticInstrumenterFilesFinderFactory {
    public abstract virtual IStaticInstrumenterFilesFinder Create(ILogger logger, DataCollectorConfiguration configuration);
}
[NullableContextAttribute("2")]
internal interface Microsoft.CodeCoverage.Instrumentation.Static.IStaticManagedInstrumenter {
    public abstract virtual Task`1<IModuleCoverageContainer> InstrumentAsync(string path, string targetPath, string sessionId, ICollection`1<IModuleCoverageContainer> dependencies);
}
[NullableContextAttribute("1")]
internal interface Microsoft.CodeCoverage.Instrumentation.Static.IStaticManagedInstrumenterFactory {
    public abstract virtual IStaticManagedInstrumenter Create(string path, ILogger logger, DataCollectorConfiguration configuration, IStaticManagedModuleHolder holder);
}
[NullableContextAttribute("1")]
internal interface Microsoft.CodeCoverage.Instrumentation.Static.IStaticManagedModuleHolder {
    public abstract virtual IModuleCoverageContainer Store(AssemblyMetadata assemblyMetadata, UInt32 blockSize);
    public abstract virtual bool TryInitialize(string path);
}
[NullableContextAttribute("1")]
internal interface Microsoft.CodeCoverage.Instrumentation.Static.IStaticRestorer {
    public abstract virtual void Restore(StaticInstrumentationResult result);
    public abstract virtual void RestoreNative(string path);
    public abstract virtual void RestoreManaged(string path, string pdbPath);
}
[NullableContextAttribute("1")]
internal interface Microsoft.CodeCoverage.Instrumentation.Static.IStaticRestorerFactory {
    public abstract virtual IStaticRestorer Create(ILogger logger, DataCollectorConfiguration configuration);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.CodeCoverage.Instrumentation.Static.MonoCecilDefaultAssemblyResolver : BaseAssemblyResolver {
    private ConcurrentDictionary`2<string, AssemblyDefinition> cache;
    public virtual AssemblyDefinition Resolve(AssemblyNameReference name);
    protected void RegisterAssembly(AssemblyDefinition assembly);
    protected virtual void Dispose(bool disposing);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.CodeCoverage.Instrumentation.Static.NetstandardAssemblyResolver : object {
    [NullableAttribute("2")]
private Assembly _netStandardAssembly;
    [NullableAttribute("2")]
private string _netStandardAssemblyName;
    [NullableAttribute("2")]
private Byte[] _netStandardAssemblyPublicKeyToken;
    [NullableAttribute("2")]
private AssemblyDefinition _netStandardAssemblyDefinition;
    private IAssemblyResolver _assemblyResolver;
    public sealed virtual AssemblyDefinition Resolve(AssemblyNameReference name);
    public sealed virtual AssemblyDefinition Resolve(AssemblyNameReference name, ReaderParameters parameters);
    public sealed virtual void Dispose();
    private bool CheckIfSearchingNetstandard(AssemblyNameReference name);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.CodeCoverage.Instrumentation.Static.SingleStaticInstrumentationResult : object {
    [CompilerGeneratedAttribute]
private string <Path>k__BackingField;
    [CompilerGeneratedAttribute]
private UInt32 <ResultCode>k__BackingField;
    [CompilerGeneratedAttribute]
private TimeSpan <Elapsed>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsManaged>k__BackingField;
    [CompilerGeneratedAttribute]
protected Type EqualityContract { get; }
    public string Path { get; public set; }
    public UInt32 ResultCode { get; public set; }
    public TimeSpan Elapsed { get; public set; }
    public bool IsManaged { get; public set; }
    public SingleStaticInstrumentationResult(string Path, UInt32 ResultCode, TimeSpan Elapsed, bool IsManaged);
    [CompilerGeneratedAttribute]
protected SingleStaticInstrumentationResult(SingleStaticInstrumentationResult original);
    [CompilerGeneratedAttribute]
protected virtual Type get_EqualityContract();
    [CompilerGeneratedAttribute]
public string get_Path();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_Path(string value);
    [CompilerGeneratedAttribute]
public UInt32 get_ResultCode();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_ResultCode(UInt32 value);
    [CompilerGeneratedAttribute]
public TimeSpan get_Elapsed();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_Elapsed(TimeSpan value);
    [CompilerGeneratedAttribute]
public bool get_IsManaged();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_IsManaged(bool value);
    [CompilerGeneratedAttribute]
public virtual string ToString();
    [CompilerGeneratedAttribute]
protected virtual bool PrintMembers(StringBuilder builder);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public static bool op_Inequality(SingleStaticInstrumentationResult left, SingleStaticInstrumentationResult right);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public static bool op_Equality(SingleStaticInstrumentationResult left, SingleStaticInstrumentationResult right);
    [CompilerGeneratedAttribute]
public virtual int GetHashCode();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public virtual bool Equals(object obj);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public virtual bool Equals(SingleStaticInstrumentationResult other);
    [CompilerGeneratedAttribute]
public virtual SingleStaticInstrumentationResult <Clone>$();
    [CompilerGeneratedAttribute]
public void Deconstruct(String& Path, UInt32& ResultCode, TimeSpan& Elapsed, Boolean& IsManaged);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.CodeCoverage.Instrumentation.Static.StaticInstrumentationResult : object {
    [CompilerGeneratedAttribute]
private IReadOnlyCollection`1<SingleStaticInstrumentationResult> <InstrumentationResults>k__BackingField;
    [CompilerGeneratedAttribute]
private IReadOnlyCollection`1<string> <NativeInstrumented>k__BackingField;
    [CompilerGeneratedAttribute]
private IReadOnlyCollection`1<string> <NativeSkipped>k__BackingField;
    [CompilerGeneratedAttribute]
private IReadOnlyCollection`1<IModuleCoverageContainer> <ManagedInstrumented>k__BackingField;
    [CompilerGeneratedAttribute]
private IReadOnlyCollection`1<string> <ManagedSkipped>k__BackingField;
    [CompilerGeneratedAttribute]
private IReadOnlyCollection`1<string> <CopiedRuntimeFiles>k__BackingField;
    [CompilerGeneratedAttribute]
protected Type EqualityContract { get; }
    public IReadOnlyCollection`1<SingleStaticInstrumentationResult> InstrumentationResults { get; public set; }
    public IReadOnlyCollection`1<string> NativeInstrumented { get; public set; }
    public IReadOnlyCollection`1<string> NativeSkipped { get; public set; }
    public IReadOnlyCollection`1<IModuleCoverageContainer> ManagedInstrumented { get; public set; }
    public IReadOnlyCollection`1<string> ManagedSkipped { get; public set; }
    public IReadOnlyCollection`1<string> CopiedRuntimeFiles { get; public set; }
    public StaticInstrumentationResult(IReadOnlyCollection`1<SingleStaticInstrumentationResult> InstrumentationResults, IReadOnlyCollection`1<string> NativeInstrumented, IReadOnlyCollection`1<string> NativeSkipped, IReadOnlyCollection`1<IModuleCoverageContainer> ManagedInstrumented, IReadOnlyCollection`1<string> ManagedSkipped, IReadOnlyCollection`1<string> CopiedRuntimeFiles);
    [CompilerGeneratedAttribute]
protected StaticInstrumentationResult(StaticInstrumentationResult original);
    [CompilerGeneratedAttribute]
protected virtual Type get_EqualityContract();
    [CompilerGeneratedAttribute]
public IReadOnlyCollection`1<SingleStaticInstrumentationResult> get_InstrumentationResults();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_InstrumentationResults(IReadOnlyCollection`1<SingleStaticInstrumentationResult> value);
    [CompilerGeneratedAttribute]
public IReadOnlyCollection`1<string> get_NativeInstrumented();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_NativeInstrumented(IReadOnlyCollection`1<string> value);
    [CompilerGeneratedAttribute]
public IReadOnlyCollection`1<string> get_NativeSkipped();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_NativeSkipped(IReadOnlyCollection`1<string> value);
    [CompilerGeneratedAttribute]
public IReadOnlyCollection`1<IModuleCoverageContainer> get_ManagedInstrumented();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_ManagedInstrumented(IReadOnlyCollection`1<IModuleCoverageContainer> value);
    [CompilerGeneratedAttribute]
public IReadOnlyCollection`1<string> get_ManagedSkipped();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_ManagedSkipped(IReadOnlyCollection`1<string> value);
    [CompilerGeneratedAttribute]
public IReadOnlyCollection`1<string> get_CopiedRuntimeFiles();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_CopiedRuntimeFiles(IReadOnlyCollection`1<string> value);
    [CompilerGeneratedAttribute]
public virtual string ToString();
    [CompilerGeneratedAttribute]
protected virtual bool PrintMembers(StringBuilder builder);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public static bool op_Inequality(StaticInstrumentationResult left, StaticInstrumentationResult right);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public static bool op_Equality(StaticInstrumentationResult left, StaticInstrumentationResult right);
    [CompilerGeneratedAttribute]
public virtual int GetHashCode();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public virtual bool Equals(object obj);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public virtual bool Equals(StaticInstrumentationResult other);
    [CompilerGeneratedAttribute]
public virtual StaticInstrumentationResult <Clone>$();
    [CompilerGeneratedAttribute]
public void Deconstruct(IReadOnlyCollection`1& InstrumentationResults, IReadOnlyCollection`1& NativeInstrumented, IReadOnlyCollection`1& NativeSkipped, IReadOnlyCollection`1& ManagedInstrumented, IReadOnlyCollection`1& ManagedSkipped, IReadOnlyCollection`1& CopiedRuntimeFiles);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.CodeCoverage.Instrumentation.Static.StaticInstrumenter : object {
    private static ParallelOptions ParallelOptions;
    [NullableAttribute("2")]
private IStaticNativeInstrumenter _nativeInstrumenter;
    private IStaticNativeRuntimeProvider _nativeRuntimeProvider;
    private IStaticManagedInstrumenter _managedInstrumenter;
    private IStaticInstrumenterFilesFinder _staticInstrumenterFilesFinder;
    private ILogger _logger;
    private IEnvironment _environment;
    private IStaticArgumentsProvider _argumentsProvider;
    private DataCollectorConfiguration _dataCollectorConfiguration;
    public StaticInstrumenter(IStaticNativeInstrumenter nativeInstrumenter, IStaticNativeRuntimeProvider nativeRuntimeProvider, IStaticManagedInstrumenter managedInstrumenter, IStaticInstrumenterFilesFinder staticInstrumenterFilesFinder, ILogger logger, IEnvironment environment, DataCollectorConfiguration dataCollectorConfiguration, IStaticArgumentsProvider argumentsProvider);
    private static StaticInstrumenter();
    [AsyncStateMachineAttribute("Microsoft.CodeCoverage.Instrumentation.Static.StaticInstrumenter/<InstrumentAsync>d__10")]
public sealed virtual Task`1<StaticInstrumentationResult> InstrumentAsync(IReadOnlyCollection`1<IncludeDirectory> includeDirectories, IEnumerable`1<string> additionalFiles);
    private IReadOnlyCollection`1<string> InstrumentNativeModules(ConcurrentList`1<SingleStaticInstrumentationResult> instrumentationResults, String[] nativeFilesToBeInstrumented);
    private IReadOnlyCollection`1<string> CopyNativeRuntimes(IReadOnlyCollection`1<string> nativeInstrumented, IReadOnlyCollection`1<string> nativeAlreadyInstrumented, IReadOnlyCollection`1<IncludeDirectory> includeDirectories);
    [AsyncStateMachineAttribute("Microsoft.CodeCoverage.Instrumentation.Static.StaticInstrumenter/<InstrumentManagedModulesAsync>d__13")]
private Task`1<ValueTuple`2<IReadOnlyCollection`1<IModuleCoverageContainer>, IReadOnlyCollection`1<string>>> InstrumentManagedModulesAsync(ConcurrentList`1<SingleStaticInstrumentationResult> instrumentationResults, String[] managedFilesToBeInstrumented);
    [MemberNotNullWhenAttribute("True", "_nativeInstrumenter")]
private bool IsStaticNativeInstrumentationEnabled();
    private bool IsStaticManagedInstrumentationEnabled();
}
internal enum Microsoft.CodeCoverage.Instrumentation.Static.StaticInstrumenterFileCheckResult : Enum {
    public int value__;
    public static StaticInstrumenterFileCheckResult Native;
    public static StaticInstrumenterFileCheckResult Managed;
    public static StaticInstrumenterFileCheckResult Excluded;
    public static StaticInstrumenterFileCheckResult ManuallyExcluded;
    public static StaticInstrumenterFileCheckResult NativeAlreadyInstrumented;
    public static StaticInstrumenterFileCheckResult NativeAppHost;
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.CodeCoverage.Instrumentation.Static.StaticInstrumenterFilesFinder : object {
    private static string AppHostPdbFileName;
    private ILibraryHelper _libraryHelper;
    private IInclusionChecker _inclusionChecker;
    private IDirectoryHelper _directoryHelper;
    private ILogger _logger;
    public StaticInstrumenterFilesFinder(ILibraryHelper libraryHelper, IInclusionChecker inclusionChecker, IDirectoryHelper directoryHelper, ILogger logger);
    public sealed virtual IDictionary`2<string, StaticInstrumenterFileCheckResult> Find(IReadOnlyCollection`1<IncludeDirectory> includeDirectories, IEnumerable`1<string> additionalFiles, IEnumerable`1<string> excludedFiles);
    private void ProcessDirectories(IReadOnlyCollection`1<IncludeDirectory> includeDirectories, IDictionary`2<string, StaticInstrumenterFileCheckResult> filesToBeInstrumentedMap);
    private void ProcessFiles(IEnumerable`1<string> candidates, IDictionary`2<string, StaticInstrumenterFileCheckResult> filesToBeInstrumentedMap);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.CodeCoverage.Instrumentation.Static.StaticInstrumenterFilesFinderFactory : object {
    private ILibraryHelper _libraryHelper;
    private IDirectoryHelper _directoryHelper;
    public StaticInstrumenterFilesFinderFactory(ILibraryHelper libraryHelper, IDirectoryHelper directoryHelper);
    public sealed virtual IStaticInstrumenterFilesFinder Create(ILogger logger, DataCollectorConfiguration configuration);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.CodeCoverage.Instrumentation.Static.StaticManagedInstrumenter : object {
    private static string NetCoreAppTargetFrameworkPrefix;
    private static string TrackerNamespace;
    private IFileHelper _fileHelper;
    private IStaticManagedModuleHolder _managedModuleHolder;
    private ILogger _logger;
    private IAssemblyResolverFactory _assemblyResolverFactory;
    private IStaticRestorer _staticRestorer;
    private IEnvironment _environment;
    private IAssemblyMetadataFactory _assemblyMetadataFactory;
    private IAssemblyMetadataProcessor _assemblyMetadataProcessor;
    private DataCollectorConfiguration _configuration;
    private WriteStreamMessage _writeStreamMessageTemplate;
    private CloseStreamMessage _closeStreamMessageTemplate;
    private TestCoverageDataMessage _testCoverageDataMessageTemplate;
    public StaticManagedInstrumenter(IFileHelper fileHelper, IStaticManagedModuleHolder managedModuleHolder, ILogger logger, IAssemblyResolverFactory assemblyResolverFactory, IStaticRestorer staticRestorer, IEnvironment environment, IAssemblyMetadataFactory assemblyMetadataFactory, IAssemblyMetadataProcessor assemblyMetadataProcessor, DataCollectorConfiguration configuration);
    [NullableContextAttribute("2")]
[AsyncStateMachineAttribute("Microsoft.CodeCoverage.Instrumentation.Static.StaticManagedInstrumenter/<InstrumentAsync>d__15")]
public sealed virtual Task`1<IModuleCoverageContainer> InstrumentAsync(string originPath, string targetPath, string sessionId, ICollection`1<IModuleCoverageContainer> dependencies);
    [AsyncStateMachineAttribute("Microsoft.CodeCoverage.Instrumentation.Static.StaticManagedInstrumenter/<ProcessAndStoreManagedModuleDataAsync>d__16")]
private Task`1<IModuleCoverageContainer> ProcessAndStoreManagedModuleDataAsync(string path, bool forceInitialization, IModuleDefinitionManager moduleDefinitionManager);
    private ValueTuple`2<TypeDefinition, TypeDefinition> AddCustomTrackersToModule(ModuleDefinition module, string sessionId, IModuleCoverageContainer moduleCoverageContainer, bool useVerifiableProbes, ICollection`1<IModuleCoverageContainer> dependencies);
    private void InstrumentCustomModuleTrackerConstructor(ModuleDefinition module, IModuleCoverageContainer moduleCoverageContainer, TypeDefinition customTrackerTypeDef, bool useVerifiableProbes);
    private void InstrumentDataStoreTrackerConstructor(ModuleDefinition module, TypeDefinition dataStoreTypeDef, ICollection`1<IModuleCoverageContainer> moduleCoverageContainers);
    private static void InstrumentCustomModuleTrackerModuleLoadedMethod(IModuleCoverageContainer moduleCoverageContainer, TypeDefinition customTrackerTypeDef, bool useVerifiableProbes);
    private void InstrumentCustomModuleTrackerInitializeBufferNameMethod(ModuleDefinition module, string sessionId, IModuleCoverageContainer moduleCoverageContainer, AssemblyDefinition coverageInstrumentationAssembly, TypeDefinition customTrackerTypeDef);
    private TypeDefinition AddPipeHelperToModule(ModuleDefinition module, AssemblyDefinition originAssemblyDef, string identifier, IModuleCoverageContainer moduleCoverageContainer);
    private static void InitializeSessionNameInPipeHelperConstructor(string identifier, TypeDefinition pipeHelperTypeDef, ILProcessor ilProcessor, Instruction lastInstr);
    private void InitializeCreateStreamMessageInPipeHelperConstructor(IModuleCoverageContainer moduleCoverageContainer, TypeDefinition pipeHelperTypeDef, ILProcessor ilProcessor, Instruction lastInstr);
    private void InitializeCreateBufferMessageInPipeHelperConstructor(IModuleCoverageContainer moduleCoverageContainer, TypeDefinition pipeHelperTypeDef, ILProcessor ilProcessor, Instruction lastInstr);
    private void InitializeCloseStreamMessageInPipeHelperConstructor(TypeDefinition pipeHelperTypeDef, ILProcessor ilProcessor, Instruction lastInstr);
    private void InitializeMessagesInPipeHelperConstructor(ModuleDefinition module, IModuleCoverageContainer moduleCoverageContainer, TypeDefinition pipeHelperTypeDef, ILProcessor ilProcessor, Instruction lastInstr);
    private void InitializeArrayOfStrings(ModuleDefinition module, ILProcessor ilProcessor, Instruction lastInstr, int size, IEnumerable`1<string> values);
    private void InitializeArrayOfInts(ModuleDefinition module, TypeDefinition typeDefinition, ILProcessor ilProcessor, Instruction lastInstr, string fieldName, int size, IEnumerable`1<int> values);
    private void InitializeStatisticsMessageInPipeHelperConstructor(IModuleCoverageContainer moduleCoverageContainer, TypeDefinition pipeHelperTypeDef, ILProcessor ilProcessor, Instruction lastInstr);
    private IEnumerable`1<string> GenerateAllStreamMessages(IModuleCoverageContainer moduleCoverageContainer);
    [IteratorStateMachineAttribute("Microsoft.CodeCoverage.Instrumentation.Static.StaticManagedInstrumenter/<GenerateAllStreamMessagesRecipes>d__32")]
private IEnumerable`1<Action`1<BinaryWriter>> GenerateAllStreamMessagesRecipes(IModuleCoverageContainer moduleCoverageContainer);
    private string GenerateMessageAsString(Action`1<BinaryWriter> messageWriter);
    private Byte[] GenerateMessage(Action`1<BinaryWriter> messageWriter);
    private void InstrumentOrAddModuleInitializer(ModuleDefinition moduleDefinition, MethodReference[] methodReferences);
    private static void Instrument(MethodDefinition method, FieldReference beginFieldReference, MethodReference hitMethodReference, IList`1<int> blocks, int offset, bool useVerifiableProbes, IDictionary`2<int, Instruction> targetsMap);
    private static Instruction AddNonVerifiableProbe(ILProcessor processor, Instruction currentInstruction, FieldReference beginFieldReference, int offset, Int32& index);
    private static Instruction AddVerifiableProbe(ILProcessor processor, Instruction currentInstruction, MethodReference hitMethodReference, int offset, Int32& index);
    private static void ReplaceTargetInstructions(ILProcessor processor, IDictionary`2<int, Instruction> targetsMap);
    private static void ReplaceExceptionHandlerBoundaries(ILProcessor processor, IDictionary`2<int, Instruction> targetsMap);
    private static bool IsMovable(IModuleCoverageContainer container);
    private static bool IsCollectorBufferInitialized(IModuleCoverageContainer container);
    private static bool IsEnvVarBufferInitialized(IModuleCoverageContainer container);
    private static bool IsNetCoreApp(IModuleCoverageContainer container);
    private static int CalculateMethodOffset(IModuleCoverageContainer container, InstrumentedFunctionMessage instrumentedFunctionMessage);
    [CompilerGeneratedAttribute]
private void <InitializeCloseStreamMessageInPipeHelperConstructor>b__26_1(BinaryWriter writer);
    [CompilerGeneratedAttribute]
private void <GenerateAllStreamMessages>b__31_0(BinaryWriter writer);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.CodeCoverage.Instrumentation.Static.StaticManagedInstrumenterFactory : object {
    private IFileHelper _fileHelper;
    private IStaticNativeRuntimeProviderFactory _staticNativeRuntimeProviderFactory;
    private IAssemblyResolverFactory _assemblyResolverFactory;
    private IEnvironment _environment;
    private ISourceRootTranslatorFactory _sourceRootTranslatorFactory;
    private IProfilersLocationProvider _profilersLocationProvider;
    private INativeHelper _nativeHelper;
    public StaticManagedInstrumenterFactory(IFileHelper fileHelper, IStaticNativeRuntimeProviderFactory staticNativeRuntimeProviderFactory, IAssemblyResolverFactory assemblyResolverFactory, IEnvironment environment, ISourceRootTranslatorFactory sourceRootTranslatorFactory, IProfilersLocationProvider profilersLocationProvider, INativeHelper nativeHelper);
    public sealed virtual IStaticManagedInstrumenter Create(string path, ILogger logger, DataCollectorConfiguration configuration, IStaticManagedModuleHolder holder);
}
internal static class Microsoft.CodeCoverage.Instrumentation.Static.StaticManagedTypeCloner : object {
    [NullableContextAttribute("1")]
public static TypeDefinition Clone(ModuleDefinition targetModule, AssemblyDefinition originAssemblyDef, string originNamespace, string originTypeName, string identifier);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.CodeCoverage.Instrumentation.Static.StaticNativeRuntimeProvider : object {
    private static ParallelOptions ParallelOptions;
    private ILogger _logger;
    private IFileHelper _fileHelper;
    private IProfilersLocationProvider _profilersLocationProvider;
    private ILibraryHelper _libraryHelper;
    private DataCollectorConfiguration _configuration;
    public StaticNativeRuntimeProvider(ILogger logger, IFileHelper fileHelper, IProfilersLocationProvider profilersLocationProvider, ILibraryHelper libraryHelper, DataCollectorConfiguration configuration);
    private static StaticNativeRuntimeProvider();
    public sealed virtual IReadOnlyCollection`1<string> CopyRuntime(IEnumerable`1<string> directoriesIterator);
    public sealed virtual void RemoveRuntime(IEnumerable`1<string> copiedFiles);
    private void CopyRuntime(String[] directories, string libraryPath, string libraryName, ConcurrentQueue`1<string> copiedFiles);
    [NullableContextAttribute("2")]
public sealed virtual string UpdatePathEnvironmentVariable(string pathEnvironmentVariable);
    private static string AppendPathIfNeeded(string updatedPathEnvironmentVariable, string originalPathEnvironmentVariable, string directory);
    private static string AppendPath(string pathEnvironmentVariable, string directory);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.CodeCoverage.Instrumentation.Static.StaticNativeRuntimeProviderFactory : object {
    private IProfilersLocationProvider _profilersLocationProvider;
    private IFileHelper _fileHelper;
    private ILibraryHelper _libraryHelper;
    public StaticNativeRuntimeProviderFactory(IProfilersLocationProvider profilersLocationProvider, IFileHelper fileHelper, ILibraryHelper libraryHelper);
    public sealed virtual IStaticNativeRuntimeProvider Create(ILogger logger, DataCollectorConfiguration configuration);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.CodeCoverage.Instrumentation.Static.StaticRestorer : object {
    private IStaticNativeRuntimeProvider _nativeRuntimeProvider;
    private IFileHelper _fileHelper;
    private ILogger _logger;
    private DataCollectorConfiguration _dataCollectorConfiguration;
    public StaticRestorer(IStaticNativeRuntimeProvider nativeRuntimeProvider, IFileHelper fileHelper, ILogger logger, DataCollectorConfiguration dataCollectorConfiguration);
    public sealed virtual void Restore(StaticInstrumentationResult staticInstrumentationResult);
    public sealed virtual void RestoreNative(string path);
    public sealed virtual void RestoreManaged(string path, string pdbPath);
    private void RestoreOrigFile(string instrumentedFile);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.CodeCoverage.Instrumentation.Static.StaticRestorerFactory : object {
    private IFileHelper _fileHelper;
    private IStaticNativeRuntimeProviderFactory _staticNativeRuntimeProviderFactory;
    public StaticRestorerFactory(IFileHelper fileHelper, IStaticNativeRuntimeProviderFactory staticNativeRuntimeProviderFactory);
    public sealed virtual IStaticRestorer Create(ILogger logger, DataCollectorConfiguration configuration);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.CodeCoverage.Instrumentation.StaticInstrumentationModuleDefinitionManager : object {
    [NullableAttribute("2")]
private ModuleDefinition _moduleDefinition;
    [NullableAttribute("2")]
private Stream _stream;
    [NullableAttribute("2")]
private IAssemblyResolver _assemblyResolver;
    [NullableAttribute("2")]
private string _targetPath;
    private IAssemblyResolverFactory _assemblyResolverFactory;
    private IFileHelper _fileHelper;
    private ILogger _logger;
    public StaticInstrumentationModuleDefinitionManager(string targetPath, IAssemblyResolverFactory assemblyResolverFactory, IFileHelper fileHelper, ILogger logger);
    public sealed virtual ModuleDefinition Create(string modulePath, string pdbPath);
    public sealed virtual void Dispose();
}
internal static class System.Runtime.CompilerServices.IsExternalInit : object {
}
[CompilerGeneratedAttribute]
[EmbeddedAttribute]
[AttributeUsageAttribute("27524")]
internal class System.Runtime.CompilerServices.NullableAttribute : Attribute {
    public Byte[] NullableFlags;
    public NullableAttribute(byte );
    public NullableAttribute(Byte[] );
}
[CompilerGeneratedAttribute]
[EmbeddedAttribute]
[AttributeUsageAttribute("5196")]
internal class System.Runtime.CompilerServices.NullableContextAttribute : Attribute {
    public byte Flag;
    public NullableContextAttribute(byte );
}
[CompilerGeneratedAttribute]
[EmbeddedAttribute]
[AttributeUsageAttribute("2")]
internal class System.Runtime.CompilerServices.RefSafetyRulesAttribute : Attribute {
    public int Version;
    public RefSafetyRulesAttribute(int );
}
