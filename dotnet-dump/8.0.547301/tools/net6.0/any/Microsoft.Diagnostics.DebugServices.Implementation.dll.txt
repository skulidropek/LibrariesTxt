[CompilerGeneratedAttribute]
[EmbeddedAttribute]
internal class Microsoft.CodeAnalysis.EmbeddedAttribute : Attribute {
}
public static class Microsoft.Diagnostics.DebugServices.Implementation.AssemblyResolver : object {
    private static string _defaultAssembliesPath;
    private static bool _initialized;
    private static AssemblyResolver();
    public static void Enable();
    private static Assembly CurrentDomain_AssemblyResolve(object sender, ResolveEventArgs args);
    private static bool Probe(string filePath, Version minimumVersion, Assembly& assembly);
}
public class Microsoft.Diagnostics.DebugServices.Implementation.CaptureConsoleService : object {
    private CharToLineConverter _charToLineConverter;
    private List`1<string> _builder;
    [CompilerGeneratedAttribute]
private CancellationToken <CancellationToken>k__BackingField;
    public IReadOnlyList`1<string> OutputLines { get; }
    public bool SupportsDml { get; }
    public CancellationToken CancellationToken { get; public set; }
    private int Microsoft.Diagnostics.DebugServices.IConsoleService.WindowWidth { get; }
    public void Clear();
    public IReadOnlyList`1<string> get_OutputLines();
    public virtual string ToString();
    public sealed virtual void Write(string text);
    public sealed virtual void WriteWarning(string text);
    public sealed virtual void WriteError(string text);
    public sealed virtual bool get_SupportsDml();
    public sealed virtual void WriteDml(string text);
    public sealed virtual void WriteDmlExec(string text, string _);
    [CompilerGeneratedAttribute]
public sealed virtual CancellationToken get_CancellationToken();
    [CompilerGeneratedAttribute]
public sealed virtual void set_CancellationToken(CancellationToken value);
    private sealed virtual override int Microsoft.Diagnostics.DebugServices.IConsoleService.get_WindowWidth();
    [CompilerGeneratedAttribute]
private void <.ctor>b__2_0(string line);
}
public class Microsoft.Diagnostics.DebugServices.Implementation.CharToLineConverter : object {
    private Action`1<string> m_callback;
    private StringBuilder m_text;
    public CharToLineConverter(Action`1<string> callback);
    public void Input(Byte[] buffer, int offset, int count);
    public void Input(string text);
    public void Flush();
}
public class Microsoft.Diagnostics.DebugServices.Implementation.CommandService : object {
    private List`1<CommandGroup> _commandGroups;
    private string _commandPrompt;
    [TupleElementNamesAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public IEnumerable`1<ValueTuple`3<string, string, IEnumerable`1<string>>> Commands { get; }
    public CommandService(string commandPrompt);
    public IReadOnlyList`1<string> ExecuteAndCapture(string commandLine, IServiceProvider services);
    public void Execute(string commandLine, IServiceProvider services);
    public void Execute(string commandName, string commandArguments, IServiceProvider services);
    private void Execute(string commandName, String[] commandLineArray, IServiceProvider services);
    public sealed virtual IEnumerable`1<ValueTuple`2<string, string>> GetAllCommandHelp(IServiceProvider services);
    public sealed virtual string GetDetailedHelp(string commandName, IServiceProvider services, int consoleWidth);
    public sealed virtual IEnumerable`1<ValueTuple`3<string, string, IEnumerable`1<string>>> get_Commands();
    public sealed virtual void AddCommands(Type type);
    public void AddCommands(Type type, Func`2<IServiceProvider, object> factory);
}
public class Microsoft.Diagnostics.DebugServices.Implementation.ContextService : object {
    protected IHost _host;
    protected ServiceContainer _serviceContainer;
    private ITarget _currentTarget;
    private IThread _currentThread;
    private IRuntime _currentRuntime;
    [CompilerGeneratedAttribute]
private IServiceEvent <OnContextChange>k__BackingField;
    public IServiceProvider Services { get; }
    public IServiceEvent OnContextChange { get; }
    protected IThreadService ThreadService { get; }
    protected IRuntimeService RuntimeService { get; }
    public ContextService(IHost host);
    public sealed virtual IServiceProvider get_Services();
    [CompilerGeneratedAttribute]
public sealed virtual IServiceEvent get_OnContextChange();
    public sealed virtual void SetCurrentTarget(int targetId);
    public sealed virtual void ClearCurrentTarget();
    public sealed virtual void SetCurrentThread(UInt32 threadId);
    public sealed virtual void ClearCurrentThread();
    public sealed virtual void SetCurrentRuntime(int runtimeId);
    public sealed virtual void ClearCurrentRuntime();
    protected virtual ITarget GetCurrentTarget();
    private void ClearCurrentTarget(ITarget target);
    public virtual void SetCurrentTarget(ITarget target);
    protected virtual IThread GetCurrentThread();
    public virtual void SetCurrentThread(IThread thread);
    protected virtual IRuntime GetCurrentRuntime();
    public virtual void SetCurrentRuntime(IRuntime runtime);
    protected bool IsTargetEqual(ITarget left, ITarget right);
    protected bool IsThreadEqual(IThread left, IThread right);
    protected bool IsRuntimeEqual(IRuntime left, IRuntime right);
    protected IThreadService get_ThreadService();
    protected IRuntimeService get_RuntimeService();
    [CompilerGeneratedAttribute]
private void <.ctor>b__5_0(ITarget target);
}
public class Microsoft.Diagnostics.DebugServices.Implementation.CrashInfoService : object {
    public static UInt32 STATUS_STACK_BUFFER_OVERRUN;
    public static UInt32 FAST_FAIL_EXCEPTION_DOTNET_AOT;
    private IException _exception;
    [CompilerGeneratedAttribute]
private UInt32 <ThreadId>k__BackingField;
    [CompilerGeneratedAttribute]
private UInt32 <HResult>k__BackingField;
    [CompilerGeneratedAttribute]
private CrashReason <CrashReason>k__BackingField;
    [CompilerGeneratedAttribute]
private ulong <RuntimeBaseAddress>k__BackingField;
    [CompilerGeneratedAttribute]
private RuntimeType <RuntimeType>k__BackingField;
    [CompilerGeneratedAttribute]
private string <RuntimeVersion>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Message>k__BackingField;
    public UInt32 ThreadId { get; }
    public UInt32 HResult { get; }
    public CrashReason CrashReason { get; }
    public ulong RuntimeBaseAddress { get; }
    public RuntimeType RuntimeType { get; }
    public string RuntimeVersion { get; }
    public string Message { get; }
    private CrashInfoService(UInt32 threadId, UInt32 hresult, CrashInfoJson crashInfo, IModuleService moduleService);
    public static ICrashInfoService Create(UInt32 hresult, ReadOnlySpan`1<byte> triageBuffer, IModuleService moduleService);
    [CompilerGeneratedAttribute]
public sealed virtual UInt32 get_ThreadId();
    [CompilerGeneratedAttribute]
public sealed virtual UInt32 get_HResult();
    [CompilerGeneratedAttribute]
public sealed virtual CrashReason get_CrashReason();
    [CompilerGeneratedAttribute]
public sealed virtual ulong get_RuntimeBaseAddress();
    [CompilerGeneratedAttribute]
public sealed virtual RuntimeType get_RuntimeType();
    [CompilerGeneratedAttribute]
public sealed virtual string get_RuntimeVersion();
    [CompilerGeneratedAttribute]
public sealed virtual string get_Message();
    public sealed virtual IException GetException(ulong address);
    public sealed virtual IException GetThreadException(UInt32 threadId);
    public sealed virtual IEnumerable`1<IException> GetNestedExceptions(UInt32 threadId);
    [CompilerGeneratedAttribute]
internal static void <GetNestedExceptions>g__AddExceptions|36_0(IEnumerable`1<IException> inner, <>c__DisplayClass36_0& );
}
[ServiceExportAttribute]
public class Microsoft.Diagnostics.DebugServices.Implementation.DataReader : object {
    private ITarget _target;
    private IEnumerable`1<ModuleInfo> _modules;
    [CompilerGeneratedAttribute]
private IModuleService <ModuleService>k__BackingField;
    [CompilerGeneratedAttribute]
private IMemoryService <MemoryService>k__BackingField;
    [CompilerGeneratedAttribute]
private IThreadService <ThreadService>k__BackingField;
    [ServiceImportAttribute]
private IModuleService ModuleService { get; private set; }
    [ServiceImportAttribute]
private IMemoryService MemoryService { get; private set; }
    [ServiceImportAttribute]
private IThreadService ThreadService { get; private set; }
    private string Microsoft.Diagnostics.Runtime.IDataReader.DisplayName { get; }
    private bool Microsoft.Diagnostics.Runtime.IDataReader.IsThreadSafe { get; }
    private OSPlatform Microsoft.Diagnostics.Runtime.IDataReader.TargetPlatform { get; }
    private Architecture Microsoft.Diagnostics.Runtime.IDataReader.Architecture { get; }
    private int Microsoft.Diagnostics.Runtime.IDataReader.ProcessId { get; }
    private int Microsoft.Diagnostics.Runtime.IMemoryReader.PointerSize { get; }
    public DataReader(ITarget target);
    [CompilerGeneratedAttribute]
private IModuleService get_ModuleService();
    [CompilerGeneratedAttribute]
private void set_ModuleService(IModuleService value);
    [CompilerGeneratedAttribute]
private IMemoryService get_MemoryService();
    [CompilerGeneratedAttribute]
private void set_MemoryService(IMemoryService value);
    [CompilerGeneratedAttribute]
private IThreadService get_ThreadService();
    [CompilerGeneratedAttribute]
private void set_ThreadService(IThreadService value);
    private sealed virtual override string Microsoft.Diagnostics.Runtime.IDataReader.get_DisplayName();
    private sealed virtual override bool Microsoft.Diagnostics.Runtime.IDataReader.get_IsThreadSafe();
    private sealed virtual override OSPlatform Microsoft.Diagnostics.Runtime.IDataReader.get_TargetPlatform();
    private sealed virtual override Architecture Microsoft.Diagnostics.Runtime.IDataReader.get_Architecture();
    private sealed virtual override int Microsoft.Diagnostics.Runtime.IDataReader.get_ProcessId();
    private sealed virtual override IEnumerable`1<ModuleInfo> Microsoft.Diagnostics.Runtime.IDataReader.EnumerateModules();
    private sealed virtual override bool Microsoft.Diagnostics.Runtime.IDataReader.GetThreadContext(UInt32 threadId, UInt32 contextFlags, Span`1<byte> context);
    private sealed virtual override void Microsoft.Diagnostics.Runtime.IDataReader.FlushCachedData();
    private sealed virtual override int Microsoft.Diagnostics.Runtime.IMemoryReader.get_PointerSize();
    private sealed virtual override int Microsoft.Diagnostics.Runtime.IMemoryReader.Read(ulong address, Span`1<byte> buffer);
    private sealed virtual override bool Microsoft.Diagnostics.Runtime.IMemoryReader.Read(ulong address, T& value);
    private sealed virtual override T Microsoft.Diagnostics.Runtime.IMemoryReader.Read(ulong address);
    private sealed virtual override bool Microsoft.Diagnostics.Runtime.IMemoryReader.ReadPointer(ulong address, UInt64& value);
    private sealed virtual override ulong Microsoft.Diagnostics.Runtime.IMemoryReader.ReadPointer(ulong address);
    [CompilerGeneratedAttribute]
private void <.ctor>b__14_0();
    [CompilerGeneratedAttribute]
private DataReaderModule <Microsoft.Diagnostics.Runtime.IDataReader.EnumerateModules>b__25_0(IModule module);
}
public class Microsoft.Diagnostics.DebugServices.Implementation.ELFModule : object {
    private IModule _module;
    private ISymbolService _symbolService;
    private IDisposable _onChangeEvent;
    private ELFFile _elfFile;
    private ELFModule(IModule module, ISymbolService symbolService);
    [ServiceExportAttribute]
public static ELFModule CreateELFModule(IModule module, ISymbolService symbolService);
    public ELFFile GetELFFile();
    public sealed virtual void Dispose();
    [CompilerGeneratedAttribute]
private void <.ctor>b__5_0();
}
public class Microsoft.Diagnostics.DebugServices.Implementation.FileLoggingConsoleService : object {
    private IConsoleService _consoleService;
    private List`1<StreamWriter> _writers;
    private FileStream _consoleStream;
    public string FilePath { get; }
    public bool SupportsDml { get; }
    public CancellationToken CancellationToken { get; public set; }
    public int WindowWidth { get; }
    public FileLoggingConsoleService(IConsoleService consoleService);
    public sealed virtual void Dispose();
    public sealed virtual string get_FilePath();
    public sealed virtual void Enable(string filePath);
    public sealed virtual void Disable();
    public sealed virtual void AddStream(Stream stream);
    public sealed virtual void RemoveStream(Stream stream);
    public sealed virtual void Write(string text);
    public sealed virtual void WriteWarning(string text);
    public sealed virtual void WriteError(string text);
    public sealed virtual bool get_SupportsDml();
    public sealed virtual void WriteDml(string text);
    public sealed virtual void WriteDmlExec(string text, string action);
    public sealed virtual CancellationToken get_CancellationToken();
    public sealed virtual void set_CancellationToken(CancellationToken value);
    public sealed virtual int get_WindowWidth();
}
public class Microsoft.Diagnostics.DebugServices.Implementation.ImageMappingMemoryService : object {
    private ServiceContainer _serviceContainer;
    private IMemoryService _memoryService;
    private IModuleService _moduleService;
    private MemoryCache _memoryCache;
    private IDisposable _onChangeEvent;
    private HashSet`1<ulong> _recursionProtection;
    public int PointerSize { get; }
    public ImageMappingMemoryService(ServiceContainer container, IMemoryService memoryService, bool managed);
    public sealed virtual void Dispose();
    protected void Flush();
    public sealed virtual int get_PointerSize();
    public sealed virtual bool ReadMemory(ulong address, Span`1<byte> buffer, Int32& bytesRead);
    public sealed virtual bool WriteMemory(ulong address, Span`1<byte> buffer, Int32& bytesWritten);
    private Byte[] ReadMemoryFromModule(ulong address, int bytesRequested);
    private static void ApplyRelocations(IModule module, PEReader reader, int dataVA, Byte[] data);
}
public class Microsoft.Diagnostics.DebugServices.Implementation.LinkedListNode : object {
    private LinkedListNode _previous;
    private LinkedListNode _next;
    public LinkedListNode Next { get; }
    public LinkedListNode Previous { get; }
    public LinkedListNode get_Next();
    public LinkedListNode get_Previous();
    public T Cast();
    public void InsertAfter(LinkedListNode node);
    public void InsertBefore(LinkedListNode node);
    public void Remove();
    public IEnumerable`1<T> GetValues();
}
public class Microsoft.Diagnostics.DebugServices.Implementation.MachOModule : object {
    private IModule _module;
    private ISymbolService _symbolService;
    private IDisposable _onChangeEvent;
    private MachOFile _machOFile;
    private MachOModule(IModule module, ISymbolService symbolService);
    [ServiceExportAttribute]
public static MachOModule CreateMachOModule(ISymbolService symbolService, IModule module);
    public MachOFile GetMachOFile();
    public sealed virtual void Dispose();
    [CompilerGeneratedAttribute]
private void <.ctor>b__5_0();
}
public class Microsoft.Diagnostics.DebugServices.Implementation.ManagedImageMappingModuleService : ModuleService {
    private IRuntimeService _runtimeService;
    public ManagedImageMappingModuleService(IServiceProvider services);
    protected virtual Dictionary`2<ulong, IModule> GetModulesInner();
}
public class Microsoft.Diagnostics.DebugServices.Implementation.MemoryCache : object {
    private static int CacheSizeLimit;
    private Dictionary`2<ulong, Cluster> _map;
    private ReadMemoryDelegate _readMemory;
    [CompilerGeneratedAttribute]
private long <CacheSize>k__BackingField;
    public long CacheSize { get; private set; }
    public MemoryCache(ReadMemoryDelegate readMemory);
    [CompilerGeneratedAttribute]
public long get_CacheSize();
    [CompilerGeneratedAttribute]
private void set_CacheSize(long value);
    public void FlushCache();
    public bool ReadMemory(ulong address, Span`1<byte> buffer, Int32& bytesRead);
    private Cluster GetCluster(ulong address);
}
public class Microsoft.Diagnostics.DebugServices.Implementation.MemoryServiceFromDataReader : object {
    private IDataReader _dataReader;
    public int PointerSize { get; }
    public MemoryServiceFromDataReader(IDataReader dataReader);
    public sealed virtual int get_PointerSize();
    public sealed virtual bool ReadMemory(ulong address, Span`1<byte> buffer, Int32& bytesRead);
    public sealed virtual bool WriteMemory(ulong address, Span`1<byte> buffer, Int32& bytesWritten);
}
public class Microsoft.Diagnostics.DebugServices.Implementation.MetadataMappingMemoryService : object {
    private ServiceContainer _serviceContainer;
    private IMemoryService _memoryService;
    private IRuntimeService _runtimeService;
    private ISymbolService _symbolService;
    private IDisposable _onChangeEvent;
    private bool _regionInitialized;
    private ImmutableArray`1<MetadataRegion> _regions;
    public int PointerSize { get; }
    public MetadataMappingMemoryService(ServiceContainer container, IMemoryService memoryService);
    public sealed virtual void Dispose();
    private void Flush();
    public sealed virtual int get_PointerSize();
    public sealed virtual bool ReadMemory(ulong address, Span`1<byte> buffer, Int32& bytesRead);
    public sealed virtual bool WriteMemory(ulong address, Span`1<byte> buffer, Int32& bytesWritten);
    private MetadataRegion FindRegion(ulong address);
    private ImmutableArray`1<byte> GetMetaDataFromAssembly(ClrModule module);
    [CompilerGeneratedAttribute]
private MetadataRegion <FindRegion>b__14_1(ClrModule module);
}
public abstract class Microsoft.Diagnostics.DebugServices.Implementation.Module : object {
    private Flags _flags;
    private IEnumerable`1<PdbFileInfo> _pdbFileInfos;
    private string _symbolFileName;
    protected ImmutableArray`1<byte> _buildId;
    protected ServiceContainer _serviceContainer;
    [CompilerGeneratedAttribute]
private int <ModuleIndex>k__BackingField;
    [CompilerGeneratedAttribute]
private string <FileName>k__BackingField;
    [CompilerGeneratedAttribute]
private ulong <ImageBase>k__BackingField;
    [CompilerGeneratedAttribute]
private ulong <ImageSize>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<UInt32> <IndexFileSize>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<UInt32> <IndexTimeStamp>k__BackingField;
    public ITarget Target { get; }
    public IServiceProvider Services { get; }
    public int ModuleIndex { get; protected set; }
    public string FileName { get; protected set; }
    public ulong ImageBase { get; protected set; }
    public ulong ImageSize { get; protected set; }
    public Nullable`1<UInt32> IndexFileSize { get; protected set; }
    public Nullable`1<UInt32> IndexTimeStamp { get; protected set; }
    public bool IsPEImage { get; }
    public bool IsManaged { get; }
    public Nullable`1<bool> IsFileLayout { get; }
    public ImmutableArray`1<byte> BuildId { get; }
    protected ModuleService ModuleService { get; }
    public Module(IServiceProvider services);
    public virtual void Dispose();
    public sealed virtual ITarget get_Target();
    public sealed virtual IServiceProvider get_Services();
    [CompilerGeneratedAttribute]
public virtual int get_ModuleIndex();
    [CompilerGeneratedAttribute]
protected virtual void set_ModuleIndex(int value);
    [CompilerGeneratedAttribute]
public virtual string get_FileName();
    [CompilerGeneratedAttribute]
protected virtual void set_FileName(string value);
    [CompilerGeneratedAttribute]
public virtual ulong get_ImageBase();
    [CompilerGeneratedAttribute]
protected virtual void set_ImageBase(ulong value);
    [CompilerGeneratedAttribute]
public virtual ulong get_ImageSize();
    [CompilerGeneratedAttribute]
protected virtual void set_ImageSize(ulong value);
    [CompilerGeneratedAttribute]
public virtual Nullable`1<UInt32> get_IndexFileSize();
    [CompilerGeneratedAttribute]
protected virtual void set_IndexFileSize(Nullable`1<UInt32> value);
    [CompilerGeneratedAttribute]
public virtual Nullable`1<UInt32> get_IndexTimeStamp();
    [CompilerGeneratedAttribute]
protected virtual void set_IndexTimeStamp(Nullable`1<UInt32> value);
    public sealed virtual bool get_IsPEImage();
    public sealed virtual bool get_IsManaged();
    public sealed virtual Nullable`1<bool> get_IsFileLayout();
    public virtual ImmutableArray`1<byte> get_BuildId();
    public sealed virtual IEnumerable`1<PdbFileInfo> GetPdbFileInfos();
    public sealed virtual string GetSymbolFileName();
    public abstract virtual Version GetVersionData();
    public abstract virtual string GetVersionString();
    public abstract virtual string LoadSymbols();
    private sealed virtual override bool Microsoft.Diagnostics.DebugServices.IExportSymbols.TryGetSymbolAddress(string name, UInt64& address);
    protected virtual bool TryGetSymbolAddressInner(string name, UInt64& address);
    protected Version GetVersionInner();
    protected string GetVersionStringInner();
    protected bool InitializeValue(Flags flag);
    protected abstract virtual ModuleService get_ModuleService();
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public virtual string ToString();
    [CompilerGeneratedAttribute]
private object <.ctor>b__6_0(IServiceProvider services);
}
public class Microsoft.Diagnostics.DebugServices.Implementation.ModuleFromAddress : Module {
    private Version _version;
    private string _versionString;
    [CompilerGeneratedAttribute]
private ModuleService <ModuleService>k__BackingField;
    public Nullable`1<UInt32> IndexTimeStamp { get; }
    public Nullable`1<UInt32> IndexFileSize { get; }
    protected ModuleService ModuleService { get; }
    public ModuleFromAddress(ModuleService moduleService, int moduleIndex, ulong imageBase, ulong imageSize, string imageName);
    public virtual Nullable`1<UInt32> get_IndexTimeStamp();
    public virtual Nullable`1<UInt32> get_IndexFileSize();
    public virtual Version GetVersionData();
    public virtual string GetVersionString();
    public virtual string LoadSymbols();
    [CompilerGeneratedAttribute]
protected virtual ModuleService get_ModuleService();
}
public abstract class Microsoft.Diagnostics.DebugServices.Implementation.ModuleService : object {
    private static UInt32 VmProtWrite;
    private IMemoryService _memoryService;
    private ISymbolService _symbolService;
    private ReadVirtualCache _versionCache;
    private Dictionary`2<ulong, IModule> _modules;
    private IModule[] _sortedByBaseAddress;
    private static Byte[] s_versionString;
    private static int s_versionLength;
    protected internal IServiceProvider Services;
    protected internal ITarget Target;
    protected internal IMemoryService MemoryService { get; }
    protected internal ISymbolService SymbolService { get; }
    public ModuleService(IServiceProvider services);
    private static ModuleService();
    public sealed virtual void Dispose();
    private void Flush();
    private sealed virtual override IEnumerable`1<IModule> Microsoft.Diagnostics.DebugServices.IModuleService.EnumerateModules();
    private sealed virtual override IModule Microsoft.Diagnostics.DebugServices.IModuleService.GetModuleFromIndex(int moduleIndex);
    private sealed virtual override IModule Microsoft.Diagnostics.DebugServices.IModuleService.GetModuleFromBaseAddress(ulong baseAddress);
    private sealed virtual override IModule Microsoft.Diagnostics.DebugServices.IModuleService.GetModuleFromAddress(ulong address);
    [IteratorStateMachineAttribute("Microsoft.Diagnostics.DebugServices.Implementation.ModuleService/<Microsoft-Diagnostics-DebugServices-IModuleService-GetModuleFromModuleName>d__18")]
private sealed virtual override IEnumerable`1<IModule> Microsoft.Diagnostics.DebugServices.IModuleService.GetModuleFromModuleName(string moduleName);
    private Dictionary`2<ulong, IModule> GetModules();
    private IModule[] GetSortedModules();
    protected abstract virtual Dictionary`2<ulong, IModule> GetModulesInner();
    internal PEFile GetPEInfo(ulong address, ulong size, IEnumerable`1& pdbFileInfos, Flags& moduleFlags);
    private PEFile GetPEInfo(bool isVirtual, ulong address, ulong size, List`1& pdbs, Flags& flags);
    internal Byte[] GetBuildId(ulong address);
    internal string GetVersionString(IModule module);
    private bool SearchVersionString(ulong address, long size, String& fileVersion);
    private bool IsModuleEqual(IModule module, string moduleName);
    protected internal IMemoryService get_MemoryService();
    protected internal ISymbolService get_SymbolService();
}
public class Microsoft.Diagnostics.DebugServices.Implementation.ModuleServiceFromDataReader : ModuleService {
    private IDataReader _dataReader;
    public ModuleServiceFromDataReader(IServiceProvider services, IDataReader dataReader);
    protected virtual Dictionary`2<ulong, IModule> GetModulesInner();
}
public class Microsoft.Diagnostics.DebugServices.Implementation.PEModule : object {
    private IModule _module;
    private ISymbolService _symbolService;
    private IDisposable _onChangeEvent;
    private PEReader _reader;
    private PEModule(IModule module, ISymbolService symbolService);
    [ServiceExportAttribute]
public static PEModule CreatePEModule(IModule module, ISymbolService symbolService);
    public PEReader GetPEReader();
    public sealed virtual void Dispose();
    [CompilerGeneratedAttribute]
private void <.ctor>b__6_0();
}
public class Microsoft.Diagnostics.DebugServices.Implementation.Runtime : object {
    private ClrInfo _clrInfo;
    private ISymbolService _symbolService;
    private Version _runtimeVersion;
    private ClrRuntime _clrRuntime;
    private string _dacFilePath;
    private string _dbiFilePath;
    protected ServiceContainer _serviceContainer;
    [CompilerGeneratedAttribute]
private int <Id>k__BackingField;
    [CompilerGeneratedAttribute]
private ITarget <Target>k__BackingField;
    [CompilerGeneratedAttribute]
private RuntimeType <RuntimeType>k__BackingField;
    [CompilerGeneratedAttribute]
private IModule <RuntimeModule>k__BackingField;
    [CompilerGeneratedAttribute]
private string <RuntimeModuleDirectory>k__BackingField;
    private static String[] s_runtimeTypeNames;
    public int Id { get; }
    public ITarget Target { get; }
    public IServiceProvider Services { get; }
    public RuntimeType RuntimeType { get; }
    public IModule RuntimeModule { get; }
    public string RuntimeModuleDirectory { get; public set; }
    public Version RuntimeVersion { get; }
    public Runtime(IServiceProvider services, int id, ClrInfo clrInfo);
    private static Runtime();
    private sealed virtual override void System.IDisposable.Dispose();
    [CompilerGeneratedAttribute]
public sealed virtual int get_Id();
    [CompilerGeneratedAttribute]
public sealed virtual ITarget get_Target();
    public sealed virtual IServiceProvider get_Services();
    [CompilerGeneratedAttribute]
public sealed virtual RuntimeType get_RuntimeType();
    [CompilerGeneratedAttribute]
public sealed virtual IModule get_RuntimeModule();
    [CompilerGeneratedAttribute]
public sealed virtual string get_RuntimeModuleDirectory();
    [CompilerGeneratedAttribute]
public sealed virtual void set_RuntimeModuleDirectory(string value);
    public sealed virtual Version get_RuntimeVersion();
    public sealed virtual string GetDacFilePath();
    public sealed virtual string GetDbiFilePath();
    private ClrRuntime CreateRuntime();
    private string GetLibraryPath(DebugLibraryKind kind);
    private string GetLocalPath(string fileName);
    private string DownloadFile(DebugLibraryInfo libraryInfo);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public virtual string ToString();
    [CompilerGeneratedAttribute]
private object <.ctor>b__7_0(IServiceProvider services);
}
[ProviderExportAttribute]
public class Microsoft.Diagnostics.DebugServices.Implementation.RuntimeProvider : object {
    private IServiceProvider _services;
    public RuntimeProvider(IServiceProvider services);
    [IteratorStateMachineAttribute("Microsoft.Diagnostics.DebugServices.Implementation.RuntimeProvider/<EnumerateRuntimes>d__2")]
public sealed virtual IEnumerable`1<IRuntime> EnumerateRuntimes(int startingRuntimeId, RuntimeEnumerationFlags flags);
}
[ServiceExportAttribute]
public class Microsoft.Diagnostics.DebugServices.Implementation.RuntimeService : object {
    private IServiceProvider _services;
    private IServiceManager _serviceManager;
    private List`1<IRuntime> _runtimes;
    public RuntimeService(IServiceProvider services, ITarget target);
    private sealed virtual override void System.IDisposable.Dispose();
    private void Flush();
    public sealed virtual IEnumerable`1<IRuntime> EnumerateRuntimes(RuntimeEnumerationFlags flags);
}
public class Microsoft.Diagnostics.DebugServices.Implementation.ServiceEvent : object {
    private LinkedListNode _events;
    public sealed virtual IDisposable Register(Action callback);
    public sealed virtual IDisposable RegisterOneShot(Action callback);
    private IDisposable Register(bool oneshot, Action callback);
    public sealed virtual void Fire();
}
public class Microsoft.Diagnostics.DebugServices.Implementation.ServiceEvent`1 : object {
    private LinkedListNode _events;
    public sealed virtual IDisposable Register(Action`1<T> callback);
    public sealed virtual IDisposable RegisterOneShot(Action`1<T> callback);
    private IDisposable Register(bool oneshot, Action`1<T> callback);
    public sealed virtual void Fire(T parameter);
}
public class Microsoft.Diagnostics.DebugServices.Implementation.ServiceManager : object {
    private Dictionary`2[] _factories;
    private Dictionary`2<Type, List`1<ServiceFactory>> _providerFactories;
    private List`1<object> _extensions;
    private bool _finalized;
    [CompilerGeneratedAttribute]
private IServiceEvent`1<Assembly> <NotifyExtensionLoad>k__BackingField;
    [CompilerGeneratedAttribute]
private IServiceEvent`1<Exception> <NotifyExtensionLoadFailure>k__BackingField;
    public IServiceEvent`1<Assembly> NotifyExtensionLoad { get; }
    public IServiceEvent`1<Exception> NotifyExtensionLoadFailure { get; }
    private static ServiceManager();
    [CompilerGeneratedAttribute]
public IServiceEvent`1<Assembly> get_NotifyExtensionLoad();
    [CompilerGeneratedAttribute]
public IServiceEvent`1<Exception> get_NotifyExtensionLoadFailure();
    public sealed virtual ServiceContainerFactory CreateServiceContainerFactory(ServiceScope scope, IServiceProvider parent);
    public sealed virtual IEnumerable`1<ServiceFactory> EnumerateProviderFactories(Type providerType);
    public void RegisterExportedServices(Assembly assembly);
    public void RegisterExportedServices(Type serviceType);
    public void RegisterAssembly(Assembly assembly);
    public void AddServiceFactory(ServiceScope scope, ServiceFactory factory);
    public void AddServiceFactory(ServiceScope scope, Type serviceType, ServiceFactory factory);
    public void AddProviderFactory(Type providerType, ServiceFactory factory);
    public void FinalizeServices();
    public void LoadExtensions();
    public void LoadExtension(string extensionPath);
    private Assembly UseAssemblyLoadContext(string extensionPath);
}
public class Microsoft.Diagnostics.DebugServices.Implementation.SpecialDiagInfo : object {
    private static Byte[] SPECIAL_DIAGINFO_SIGNATURE;
    private static int SPECIAL_DIAGINFO_VERSION;
    private static ulong SpecialDiagInfoAddressMacOS64;
    private static ulong SpecialDiagInfoAddress64;
    private static ulong SpecialDiagInfoAddress32;
    private ITarget _target;
    private IMemoryService _memoryService;
    private ulong SpecialDiagInfoAddress { get; }
    public SpecialDiagInfo(ITarget target, IMemoryService memoryService);
    private static SpecialDiagInfo();
    private ulong get_SpecialDiagInfoAddress();
    public static ICrashInfoService CreateCrashInfoService(IServiceProvider services);
    internal EXCEPTION_RECORD64 GetExceptionRecord();
}
internal class Microsoft.Diagnostics.DebugServices.Implementation.SymbolFile : object {
    private MetadataReaderProvider _provider;
    private MetadataReader _reader;
    public SymbolFile(MetadataReaderProvider provider, MetadataReader reader);
    public sealed virtual void Dispose();
    public sealed virtual bool ResolveSequencePoint(string filePath, int lineNumber, Int32& methodToken, Int32& ilOffset);
    public sealed virtual bool GetSourceLineByILOffset(int methodToken, long ilOffset, Int32& lineNumber, String& fileName);
    public sealed virtual bool GetLocalVariableByIndex(int methodToken, int localIndex, String& localVarName);
}
public class Microsoft.Diagnostics.DebugServices.Implementation.SymbolService : object {
    public static string MsdlSymbolServer;
    public static string SymwebSymbolServer;
    private static string _symwebHost;
    private IHost _host;
    private string _defaultSymbolCache;
    private SymbolStore _symbolStore;
    [CompilerGeneratedAttribute]
private IServiceEvent <OnChangeEvent>k__BackingField;
    [CompilerGeneratedAttribute]
private string <DefaultSymbolPath>k__BackingField;
    [CompilerGeneratedAttribute]
private int <DefaultTimeout>k__BackingField;
    [CompilerGeneratedAttribute]
private int <DefaultRetryCount>k__BackingField;
    public IServiceEvent OnChangeEvent { get; }
    public bool IsSymbolStoreEnabled { get; }
    public string DefaultSymbolPath { get; public set; }
    public string DefaultSymbolCache { get; public set; }
    public int DefaultTimeout { get; public set; }
    public int DefaultRetryCount { get; public set; }
    public SymbolService(IHost host);
    private static SymbolService();
    [CompilerGeneratedAttribute]
public sealed virtual IServiceEvent get_OnChangeEvent();
    public sealed virtual bool get_IsSymbolStoreEnabled();
    [CompilerGeneratedAttribute]
public sealed virtual string get_DefaultSymbolPath();
    [CompilerGeneratedAttribute]
public void set_DefaultSymbolPath(string value);
    public sealed virtual string get_DefaultSymbolCache();
    public void set_DefaultSymbolCache(string value);
    [CompilerGeneratedAttribute]
public sealed virtual int get_DefaultTimeout();
    [CompilerGeneratedAttribute]
public void set_DefaultTimeout(int value);
    [CompilerGeneratedAttribute]
public sealed virtual int get_DefaultRetryCount();
    [CompilerGeneratedAttribute]
public void set_DefaultRetryCount(int value);
    public sealed virtual void Reset();
    public sealed virtual bool ParseSymbolPath(string symbolPath);
    public sealed virtual bool AddSymwebSymbolServer(bool includeInteractiveCredentials, Nullable`1<int> timeoutInMinutes, Nullable`1<int> retryCount);
    public sealed virtual bool AddAuthenticatedSymbolServer(string accessToken, string symbolServerPath, Nullable`1<int> timeoutInMinutes, Nullable`1<int> retryCount);
    public sealed virtual bool AddSymbolServer(string symbolServerPath, Nullable`1<int> timeoutInMinutes, Nullable`1<int> retryCount);
    public bool AddSymbolServer(string symbolServerPath, Nullable`1<int> timeoutInMinutes, Nullable`1<int> retryCount, Func`2<CancellationToken, ValueTask`1<AuthenticationHeaderValue>> authenticationFunc);
    public sealed virtual void AddCachePath(string symbolCachePath);
    public sealed virtual void AddDirectoryPath(string symbolDirectoryPath);
    public sealed virtual void DisableSymbolStore();
    public sealed virtual string DownloadModuleFile(IModule module);
    public sealed virtual string DownloadSymbolFile(IModule module);
    public sealed virtual string DownloadFile(string index, string file);
    public sealed virtual ImmutableArray`1<byte> GetMetadata(string imagePath, UInt32 imageTimestamp, UInt32 imageSize);
    public sealed virtual ISymbolFile OpenSymbolFile(string assemblyPath, bool isFileLayout, Stream peStream);
    public sealed virtual ISymbolFile OpenSymbolFile(Stream pdbStream);
    private string DownloadPE(IModule module, KeyTypeFlags flags);
    private string DownloadELF(IModule module, KeyTypeFlags flags);
    private string DownloadMachO(IModule module, KeyTypeFlags flags);
    private string DownloadFile(SymbolStoreKey key);
    private static void ReadPortableDebugTableEntries(PEReader peReader, DebugDirectoryEntry& codeViewEntry, DebugDirectoryEntry& embeddedPdbEntry);
    private SymbolFile TryOpenReaderFromCodeView(PEReader peReader, DebugDirectoryEntry codeViewEntry, string assemblyPath);
    private static SymbolFile TryOpenReaderFromEmbeddedPdb(PEReader peReader, DebugDirectoryEntry embeddedPdbEntry);
    public virtual string ToString();
    private static bool IsSymweb(string server);
    private SymbolStoreFile GetSymbolStoreFile(SymbolStoreKey key);
    private void SetSymbolStore(SymbolStore store);
    private static bool IsDuplicateSymbolStore(SymbolStore symbolStore, Func`2<T, bool> match);
    public void ForEachSymbolStore(Action`1<T> callback);
    internal static string GetFileName(string pathName);
    private static bool IsPathEqual(string path1, string path2);
    [CompilerGeneratedAttribute]
private void <ParseSymbolPath>g__ParseServer|28_0(int start, <>c__DisplayClass28_0& , <>c__DisplayClass28_1& );
}
public abstract class Microsoft.Diagnostics.DebugServices.Implementation.Target : object {
    private string _dumpPath;
    private string _tempDirectory;
    private ServiceContainer _serviceContainer;
    protected ServiceContainerFactory _serviceContainerFactory;
    [CompilerGeneratedAttribute]
private IHost <Host>k__BackingField;
    [CompilerGeneratedAttribute]
private int <Id>k__BackingField;
    [CompilerGeneratedAttribute]
private OSPlatform <OperatingSystem>k__BackingField;
    [CompilerGeneratedAttribute]
private Architecture <Architecture>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsDump>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<UInt32> <ProcessId>k__BackingField;
    [CompilerGeneratedAttribute]
private IServiceEvent <OnFlushEvent>k__BackingField;
    [CompilerGeneratedAttribute]
private IServiceEvent <OnDestroyEvent>k__BackingField;
    public IHost Host { get; }
    public int Id { get; }
    public OSPlatform OperatingSystem { get; protected set; }
    public Architecture Architecture { get; protected set; }
    public bool IsDump { get; protected set; }
    public Nullable`1<UInt32> ProcessId { get; protected set; }
    public IServiceProvider Services { get; }
    public IServiceEvent OnFlushEvent { get; }
    public IServiceEvent OnDestroyEvent { get; }
    public Target(IHost host, int id, string dumpPath);
    protected void Finished();
    protected void FlushService();
    [CompilerGeneratedAttribute]
public sealed virtual IHost get_Host();
    [CompilerGeneratedAttribute]
public sealed virtual int get_Id();
    [CompilerGeneratedAttribute]
public sealed virtual OSPlatform get_OperatingSystem();
    [CompilerGeneratedAttribute]
protected void set_OperatingSystem(OSPlatform value);
    [CompilerGeneratedAttribute]
public sealed virtual Architecture get_Architecture();
    [CompilerGeneratedAttribute]
protected void set_Architecture(Architecture value);
    [CompilerGeneratedAttribute]
public sealed virtual bool get_IsDump();
    [CompilerGeneratedAttribute]
protected void set_IsDump(bool value);
    [CompilerGeneratedAttribute]
public sealed virtual Nullable`1<UInt32> get_ProcessId();
    [CompilerGeneratedAttribute]
protected void set_ProcessId(Nullable`1<UInt32> value);
    public sealed virtual string GetTempDirectory();
    public sealed virtual IServiceProvider get_Services();
    [CompilerGeneratedAttribute]
public sealed virtual IServiceEvent get_OnFlushEvent();
    public sealed virtual void Flush();
    [CompilerGeneratedAttribute]
public sealed virtual IServiceEvent get_OnDestroyEvent();
    public sealed virtual void Destroy();
    private static Reader CreateReader(IServiceProvider services);
    private void CleanupTempDirectory();
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public virtual string ToString();
    [CompilerGeneratedAttribute]
private object <.ctor>b__4_0(IServiceProvider _);
}
public class Microsoft.Diagnostics.DebugServices.Implementation.TargetFromDataReader : Target {
    private IDataReader _dataReader;
    public TargetFromDataReader(IDataReader dataReader, OSPlatform targetOS, IHost host, int id, string dumpPath);
}
public class Microsoft.Diagnostics.DebugServices.Implementation.Thread : object {
    private ThreadService _threadService;
    private Byte[] _threadContext;
    private Nullable`1<ulong> _teb;
    protected ServiceContainer _serviceContainer;
    [CompilerGeneratedAttribute]
private int <ThreadIndex>k__BackingField;
    [CompilerGeneratedAttribute]
private UInt32 <ThreadId>k__BackingField;
    public int ThreadIndex { get; }
    public UInt32 ThreadId { get; }
    public ITarget Target { get; }
    public IServiceProvider Services { get; }
    public Thread(ThreadService threadService, int index, UInt32 id);
    private sealed virtual override void System.IDisposable.Dispose();
    [CompilerGeneratedAttribute]
public sealed virtual int get_ThreadIndex();
    [CompilerGeneratedAttribute]
public sealed virtual UInt32 get_ThreadId();
    public sealed virtual ITarget get_Target();
    public sealed virtual IServiceProvider get_Services();
    public sealed virtual bool TryGetRegisterValue(int index, UInt64& value);
    public sealed virtual Byte[] GetThreadContext();
    public sealed virtual ulong GetThreadTeb();
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public virtual string ToString();
}
public abstract class Microsoft.Diagnostics.DebugServices.Implementation.ThreadService : object {
    private int _contextSize;
    private UInt32 _contextFlags;
    private Dictionary`2<string, RegisterInfo> _lookupByName;
    private Dictionary`2<int, RegisterInfo> _lookupByIndex;
    private Dictionary`2<UInt32, IThread> _threads;
    protected internal IServiceProvider Services;
    protected internal ITarget Target;
    [CompilerGeneratedAttribute]
private IEnumerable`1<RegisterInfo> <Registers>k__BackingField;
    [CompilerGeneratedAttribute]
private int <InstructionPointerIndex>k__BackingField;
    [CompilerGeneratedAttribute]
private int <FramePointerIndex>k__BackingField;
    [CompilerGeneratedAttribute]
private int <StackPointerIndex>k__BackingField;
    public IEnumerable`1<RegisterInfo> Registers { get; }
    public int InstructionPointerIndex { get; }
    public int FramePointerIndex { get; }
    public int StackPointerIndex { get; }
    public ThreadService(IServiceProvider services);
    private sealed virtual override void System.IDisposable.Dispose();
    private void Flush();
    [CompilerGeneratedAttribute]
public sealed virtual IEnumerable`1<RegisterInfo> get_Registers();
    [CompilerGeneratedAttribute]
public sealed virtual int get_InstructionPointerIndex();
    [CompilerGeneratedAttribute]
public sealed virtual int get_FramePointerIndex();
    [CompilerGeneratedAttribute]
public sealed virtual int get_StackPointerIndex();
    public sealed virtual bool TryGetRegisterIndexByName(string name, Int32& registerIndex);
    public sealed virtual bool TryGetRegisterInfo(int registerIndex, RegisterInfo& info);
    public sealed virtual IEnumerable`1<IThread> EnumerateThreads();
    public sealed virtual IThread GetThreadFromIndex(int threadIndex);
    public sealed virtual IThread GetThreadFromId(UInt32 threadId);
    internal Byte[] GetThreadContext(Thread thread);
    internal ulong GetThreadTeb(Thread thread);
    private Dictionary`2<UInt32, IThread> GetThreads();
    protected abstract virtual IEnumerable`1<IThread> GetThreadsInner();
    protected abstract virtual bool GetThreadContext(UInt32 threadId, UInt32 contextFlags, UInt32 contextSize, Byte[] context);
    protected abstract virtual ulong GetThreadTeb(UInt32 threadId);
}
public class Microsoft.Diagnostics.DebugServices.Implementation.ThreadServiceFromDataReader : ThreadService {
    private IDataReader _dataReader;
    private IThreadReader _threadReader;
    public ThreadServiceFromDataReader(IServiceProvider services, IDataReader dataReader);
    protected virtual bool GetThreadContext(UInt32 threadId, UInt32 contextFlags, UInt32 contextSize, Byte[] context);
    protected virtual IEnumerable`1<IThread> GetThreadsInner();
    protected virtual ulong GetThreadTeb(UInt32 threadId);
    [CompilerGeneratedAttribute]
private Thread <GetThreadsInner>b__4_0(UInt32 id, int index);
}
public class Microsoft.Diagnostics.DebugServices.Implementation.Tracer : object {
    [CompilerGeneratedAttribute]
private static bool <Enable>k__BackingField;
    [CompilerGeneratedAttribute]
private static ITracer <Instance>k__BackingField;
    public static bool Enable { get; public set; }
    public static ITracer Instance { get; }
    private static Tracer();
    [CompilerGeneratedAttribute]
public static bool get_Enable();
    [CompilerGeneratedAttribute]
public static void set_Enable(bool value);
    [CompilerGeneratedAttribute]
public static ITracer get_Instance();
    public sealed virtual void WriteLine(string message);
    public sealed virtual void WriteLine(string format, Object[] arguments);
    public sealed virtual void Information(string message);
    public sealed virtual void Information(string format, Object[] arguments);
    public sealed virtual void Warning(string message);
    public sealed virtual void Warning(string format, Object[] arguments);
    public sealed virtual void Error(string message);
    public sealed virtual void Error(string format, Object[] arguments);
    public sealed virtual void Verbose(string message);
    public sealed virtual void Verbose(string format, Object[] arguments);
}
[ExtensionAttribute]
public static class Microsoft.Diagnostics.DebugServices.Implementation.Utilities : object {
    public static Version EmptyVersion;
    private static Utilities();
    [ExtensionAttribute]
public static string ToHex(ImmutableArray`1<byte> array);
    public static int CombineHashCodes(int hashCode0, int hashCode1);
    [ExtensionAttribute]
public static Version ToVersion(VsFixedFileInfo fileInfo);
    public static Version ParseVersionString(string versionString);
    [ExtensionAttribute]
public static PdbFileInfo ToPdbFileInfo(PEPdbRecord pdbInfo);
    public static PEReader OpenPEReader(string filePath);
    public static ELFFile OpenELFFile(string filePath);
    public static MachOFile OpenMachOFile(string filePath);
    [ServiceExportAttribute]
public static ELFFile CreateELFFile(IMemoryService memoryService, IModule module);
    [ServiceExportAttribute]
public static MachOFile CreateMachOFile(IMemoryService memoryService, IModule module);
    public static Stream TryOpenFile(string path);
    public static string GetDotNetHomeDirectory();
    public static object CreateInstance(Type type, IServiceProvider provider);
    public static object CreateInstance(MethodBase method, IServiceProvider provider);
    public static void ImportServices(object instance, IServiceProvider provider);
    public static object InvokeConstructor(Type type, IServiceProvider provider);
    public static object Invoke(MethodBase method, object instance, IServiceProvider provider);
    private static Object[] BuildArguments(MethodBase methodBase, IServiceProvider services);
}
public class Microsoft.Diagnostics.ExtensionCommands.DiagnosticLoggingService : object {
    private static string ListenerName;
    private IConsoleService _consoleService;
    private IConsoleFileLoggingService _fileLoggingService;
    private StreamWriter _writer;
    [CompilerGeneratedAttribute]
private static DiagnosticLoggingService <Instance>k__BackingField;
    public static DiagnosticLoggingService Instance { get; }
    public bool IsEnabled { get; }
    public string FilePath { get; }
    private static DiagnosticLoggingService();
    [CompilerGeneratedAttribute]
public static DiagnosticLoggingService get_Instance();
    public sealed virtual bool get_IsEnabled();
    public sealed virtual string get_FilePath();
    public sealed virtual void Enable(string filePath);
    public sealed virtual void Disable();
    public static void Initialize(string logfile);
    public void SetConsole(IConsoleService consoleService, IConsoleFileLoggingService fileLoggingService);
    private void CloseLogging();
}
[CompilerGeneratedAttribute]
[EmbeddedAttribute]
internal class System.Runtime.CompilerServices.IsUnmanagedAttribute : Attribute {
}
[CompilerGeneratedAttribute]
[EmbeddedAttribute]
[AttributeUsageAttribute("2")]
internal class System.Runtime.CompilerServices.RefSafetyRulesAttribute : Attribute {
    public int Version;
    public RefSafetyRulesAttribute(int );
}
