[CompilerGeneratedAttribute]
[EmbeddedAttribute]
internal class Microsoft.CodeAnalysis.EmbeddedAttribute : Attribute {
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
public class Microsoft.Diagnostics.Runtime.AbstractDac.AppDomainInfo : ValueType {
    [CompilerGeneratedAttribute]
private ulong <Address>k__BackingField;
    [CompilerGeneratedAttribute]
private AppDomainKind <Kind>k__BackingField;
    [CompilerGeneratedAttribute]
private int <Id>k__BackingField;
    [NullableAttribute("1")]
[CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ConfigFile>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ApplicationBase>k__BackingField;
    [CompilerGeneratedAttribute]
private ulong <LoaderAllocator>k__BackingField;
    public ulong Address { get; public set; }
    public AppDomainKind Kind { get; public set; }
    public int Id { get; public set; }
    [NullableAttribute("1")]
public string Name { get; public set; }
    public string ConfigFile { get; public set; }
    public string ApplicationBase { get; public set; }
    public ulong LoaderAllocator { get; public set; }
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public ulong get_Address();
    [CompilerGeneratedAttribute]
public void set_Address(ulong value);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public AppDomainKind get_Kind();
    [CompilerGeneratedAttribute]
public void set_Kind(AppDomainKind value);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public int get_Id();
    [CompilerGeneratedAttribute]
public void set_Id(int value);
    [IsReadOnlyAttribute]
[NullableContextAttribute("1")]
[CompilerGeneratedAttribute]
public string get_Name();
    [NullableContextAttribute("1")]
[CompilerGeneratedAttribute]
public void set_Name(string value);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public string get_ConfigFile();
    [CompilerGeneratedAttribute]
public void set_ConfigFile(string value);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public string get_ApplicationBase();
    [CompilerGeneratedAttribute]
public void set_ApplicationBase(string value);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public ulong get_LoaderAllocator();
    [CompilerGeneratedAttribute]
public void set_LoaderAllocator(ulong value);
}
public enum Microsoft.Diagnostics.Runtime.AbstractDac.AppDomainKind : Enum {
    public int value__;
    public static AppDomainKind Normal;
    public static AppDomainKind System;
    public static AppDomainKind Shared;
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Microsoft.Diagnostics.Runtime.AbstractDac.CcwInfo : ValueType {
    [CompilerGeneratedAttribute]
private ulong <Object>k__BackingField;
    [CompilerGeneratedAttribute]
private ulong <Address>k__BackingField;
    [CompilerGeneratedAttribute]
private ulong <IUnknown>k__BackingField;
    [CompilerGeneratedAttribute]
private ulong <Handle>k__BackingField;
    [CompilerGeneratedAttribute]
private int <RefCount>k__BackingField;
    [CompilerGeneratedAttribute]
private int <JupiterRefCount>k__BackingField;
    [CompilerGeneratedAttribute]
private ComInterfaceEntry[] <Interfaces>k__BackingField;
    public ulong Object { get; public set; }
    public ulong Address { get; public set; }
    public ulong IUnknown { get; public set; }
    public ulong Handle { get; public set; }
    public int RefCount { get; public set; }
    public int JupiterRefCount { get; public set; }
    public ComInterfaceEntry[] Interfaces { get; public set; }
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public ulong get_Object();
    [CompilerGeneratedAttribute]
public void set_Object(ulong value);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public ulong get_Address();
    [CompilerGeneratedAttribute]
public void set_Address(ulong value);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public ulong get_IUnknown();
    [CompilerGeneratedAttribute]
public void set_IUnknown(ulong value);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public ulong get_Handle();
    [CompilerGeneratedAttribute]
public void set_Handle(ulong value);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public int get_RefCount();
    [CompilerGeneratedAttribute]
public void set_RefCount(int value);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public int get_JupiterRefCount();
    [CompilerGeneratedAttribute]
public void set_JupiterRefCount(int value);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public ComInterfaceEntry[] get_Interfaces();
    [CompilerGeneratedAttribute]
public void set_Interfaces(ComInterfaceEntry[] value);
}
public class Microsoft.Diagnostics.Runtime.AbstractDac.ClrHandleInfo : ValueType {
    [CompilerGeneratedAttribute]
private ulong <Address>k__BackingField;
    [CompilerGeneratedAttribute]
private ulong <Object>k__BackingField;
    [CompilerGeneratedAttribute]
private ClrHandleKind <Kind>k__BackingField;
    [CompilerGeneratedAttribute]
private ulong <AppDomain>k__BackingField;
    [CompilerGeneratedAttribute]
private ulong <DependentTarget>k__BackingField;
    [CompilerGeneratedAttribute]
private UInt32 <RefCount>k__BackingField;
    public ulong Address { get; public set; }
    public ulong Object { get; public set; }
    public ClrHandleKind Kind { get; public set; }
    public ulong AppDomain { get; public set; }
    public ulong DependentTarget { get; public set; }
    public UInt32 RefCount { get; public set; }
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public ulong get_Address();
    [CompilerGeneratedAttribute]
public void set_Address(ulong value);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public ulong get_Object();
    [CompilerGeneratedAttribute]
public void set_Object(ulong value);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public ClrHandleKind get_Kind();
    [CompilerGeneratedAttribute]
public void set_Kind(ClrHandleKind value);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public ulong get_AppDomain();
    [CompilerGeneratedAttribute]
public void set_AppDomain(ulong value);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public ulong get_DependentTarget();
    [CompilerGeneratedAttribute]
public void set_DependentTarget(ulong value);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public UInt32 get_RefCount();
    [CompilerGeneratedAttribute]
public void set_RefCount(UInt32 value);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
public class Microsoft.Diagnostics.Runtime.AbstractDac.ClrModuleInfo : ValueType {
    [CompilerGeneratedAttribute]
private ulong <Address>k__BackingField;
    [CompilerGeneratedAttribute]
private ulong <ImageBase>k__BackingField;
    [CompilerGeneratedAttribute]
private ulong <Id>k__BackingField;
    [CompilerGeneratedAttribute]
private ulong <Index>k__BackingField;
    [CompilerGeneratedAttribute]
private ulong <Assembly>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsPEFile>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsDynamic>k__BackingField;
    [CompilerGeneratedAttribute]
private ulong <MetadataAddress>k__BackingField;
    [CompilerGeneratedAttribute]
private ulong <MetadataSize>k__BackingField;
    [CompilerGeneratedAttribute]
private ulong <ThunkHeap>k__BackingField;
    [CompilerGeneratedAttribute]
private ulong <LoaderAllocator>k__BackingField;
    [CompilerGeneratedAttribute]
private string <AssemblyName>k__BackingField;
    [CompilerGeneratedAttribute]
private string <FileName>k__BackingField;
    [CompilerGeneratedAttribute]
private ModuleLayout <Layout>k__BackingField;
    [CompilerGeneratedAttribute]
private ulong <Size>k__BackingField;
    public ulong Address { get; public set; }
    public ulong ImageBase { get; public set; }
    public ulong Id { get; public set; }
    public ulong Index { get; public set; }
    public ulong Assembly { get; public set; }
    public bool IsPEFile { get; public set; }
    public bool IsDynamic { get; public set; }
    public ulong MetadataAddress { get; public set; }
    public ulong MetadataSize { get; public set; }
    public ulong ThunkHeap { get; public set; }
    public ulong LoaderAllocator { get; public set; }
    public string AssemblyName { get; public set; }
    public string FileName { get; public set; }
    public ModuleLayout Layout { get; public set; }
    public ulong Size { get; public set; }
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public ulong get_Address();
    [CompilerGeneratedAttribute]
public void set_Address(ulong value);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public ulong get_ImageBase();
    [CompilerGeneratedAttribute]
public void set_ImageBase(ulong value);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public ulong get_Id();
    [CompilerGeneratedAttribute]
public void set_Id(ulong value);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public ulong get_Index();
    [CompilerGeneratedAttribute]
public void set_Index(ulong value);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public ulong get_Assembly();
    [CompilerGeneratedAttribute]
public void set_Assembly(ulong value);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public bool get_IsPEFile();
    [CompilerGeneratedAttribute]
public void set_IsPEFile(bool value);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public bool get_IsDynamic();
    [CompilerGeneratedAttribute]
public void set_IsDynamic(bool value);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public ulong get_MetadataAddress();
    [CompilerGeneratedAttribute]
public void set_MetadataAddress(ulong value);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public ulong get_MetadataSize();
    [CompilerGeneratedAttribute]
public void set_MetadataSize(ulong value);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public ulong get_ThunkHeap();
    [CompilerGeneratedAttribute]
public void set_ThunkHeap(ulong value);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public ulong get_LoaderAllocator();
    [CompilerGeneratedAttribute]
public void set_LoaderAllocator(ulong value);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public string get_AssemblyName();
    [CompilerGeneratedAttribute]
public void set_AssemblyName(string value);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public string get_FileName();
    [CompilerGeneratedAttribute]
public void set_FileName(string value);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public ModuleLayout get_Layout();
    [CompilerGeneratedAttribute]
public void set_Layout(ModuleLayout value);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public ulong get_Size();
    [CompilerGeneratedAttribute]
public void set_Size(ulong value);
}
public class Microsoft.Diagnostics.Runtime.AbstractDac.ClrThreadInfo : ValueType {
    [CompilerGeneratedAttribute]
private ulong <Address>k__BackingField;
    [CompilerGeneratedAttribute]
private ulong <AppDomain>k__BackingField;
    [CompilerGeneratedAttribute]
private UInt32 <OSThreadId>k__BackingField;
    [CompilerGeneratedAttribute]
private int <ManagedThreadId>k__BackingField;
    [CompilerGeneratedAttribute]
private UInt32 <LockCount>k__BackingField;
    [CompilerGeneratedAttribute]
private ulong <Teb>k__BackingField;
    [CompilerGeneratedAttribute]
private ulong <StackBase>k__BackingField;
    [CompilerGeneratedAttribute]
private ulong <StackLimit>k__BackingField;
    [CompilerGeneratedAttribute]
private ulong <ExceptionInFlight>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsFinalizer>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsGC>k__BackingField;
    [CompilerGeneratedAttribute]
private GCMode <GCMode>k__BackingField;
    [CompilerGeneratedAttribute]
private ClrThreadState <State>k__BackingField;
    public ulong Address { get; public set; }
    public ulong AppDomain { get; public set; }
    public UInt32 OSThreadId { get; public set; }
    public int ManagedThreadId { get; public set; }
    public UInt32 LockCount { get; public set; }
    public ulong Teb { get; public set; }
    public ulong StackBase { get; public set; }
    public ulong StackLimit { get; public set; }
    public ulong ExceptionInFlight { get; public set; }
    public bool IsFinalizer { get; public set; }
    public bool IsGC { get; public set; }
    public GCMode GCMode { get; public set; }
    public ClrThreadState State { get; public set; }
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public ulong get_Address();
    [CompilerGeneratedAttribute]
public void set_Address(ulong value);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public ulong get_AppDomain();
    [CompilerGeneratedAttribute]
public void set_AppDomain(ulong value);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public UInt32 get_OSThreadId();
    [CompilerGeneratedAttribute]
public void set_OSThreadId(UInt32 value);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public int get_ManagedThreadId();
    [CompilerGeneratedAttribute]
public void set_ManagedThreadId(int value);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public UInt32 get_LockCount();
    [CompilerGeneratedAttribute]
public void set_LockCount(UInt32 value);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public ulong get_Teb();
    [CompilerGeneratedAttribute]
public void set_Teb(ulong value);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public ulong get_StackBase();
    [CompilerGeneratedAttribute]
public void set_StackBase(ulong value);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public ulong get_StackLimit();
    [CompilerGeneratedAttribute]
public void set_StackLimit(ulong value);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public ulong get_ExceptionInFlight();
    [CompilerGeneratedAttribute]
public void set_ExceptionInFlight(ulong value);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public bool get_IsFinalizer();
    [CompilerGeneratedAttribute]
public void set_IsFinalizer(bool value);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public bool get_IsGC();
    [CompilerGeneratedAttribute]
public void set_IsGC(bool value);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public GCMode get_GCMode();
    [CompilerGeneratedAttribute]
public void set_GCMode(GCMode value);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public ClrThreadState get_State();
    [CompilerGeneratedAttribute]
public void set_State(ClrThreadState value);
}
public class Microsoft.Diagnostics.Runtime.AbstractDac.ComInterfaceEntry : ValueType {
    [CompilerGeneratedAttribute]
private ulong <MethodTable>k__BackingField;
    [CompilerGeneratedAttribute]
private ulong <InterfacePointer>k__BackingField;
    public ulong MethodTable { get; public set; }
    public ulong InterfacePointer { get; public set; }
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public ulong get_MethodTable();
    [CompilerGeneratedAttribute]
public void set_MethodTable(ulong value);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public ulong get_InterfacePointer();
    [CompilerGeneratedAttribute]
public void set_InterfacePointer(ulong value);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
public class Microsoft.Diagnostics.Runtime.AbstractDac.FieldDefInfo : ValueType {
    [CompilerGeneratedAttribute]
private int <Token>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    [CompilerGeneratedAttribute]
private FieldAttributes <Attributes>k__BackingField;
    [NativeIntegerAttribute]
[CompilerGeneratedAttribute]
private IntPtr <Signature>k__BackingField;
    [CompilerGeneratedAttribute]
private int <SignatureSize>k__BackingField;
    [CompilerGeneratedAttribute]
private int <Type>k__BackingField;
    [NativeIntegerAttribute]
[CompilerGeneratedAttribute]
private IntPtr <ValuePointer>k__BackingField;
    public int Token { get; public set; }
    public string Name { get; public set; }
    public FieldAttributes Attributes { get; public set; }
    [NativeIntegerAttribute]
public IntPtr Signature { get; public set; }
    public int SignatureSize { get; public set; }
    public int Type { get; public set; }
    [NativeIntegerAttribute]
public IntPtr ValuePointer { get; public set; }
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public int get_Token();
    [CompilerGeneratedAttribute]
public void set_Token(int value);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public string get_Name();
    [CompilerGeneratedAttribute]
public void set_Name(string value);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public FieldAttributes get_Attributes();
    [CompilerGeneratedAttribute]
public void set_Attributes(FieldAttributes value);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public IntPtr get_Signature();
    [CompilerGeneratedAttribute]
public void set_Signature(IntPtr value);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public int get_SignatureSize();
    [CompilerGeneratedAttribute]
public void set_SignatureSize(int value);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public int get_Type();
    [CompilerGeneratedAttribute]
public void set_Type(int value);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public IntPtr get_ValuePointer();
    [CompilerGeneratedAttribute]
public void set_ValuePointer(IntPtr value);
}
public class Microsoft.Diagnostics.Runtime.AbstractDac.FieldInfo : ValueType {
    [CompilerGeneratedAttribute]
private ulong <FieldDesc>k__BackingField;
    [CompilerGeneratedAttribute]
private int <Token>k__BackingField;
    [CompilerGeneratedAttribute]
private ulong <MethodTable>k__BackingField;
    [CompilerGeneratedAttribute]
private ClrElementType <ElementType>k__BackingField;
    [CompilerGeneratedAttribute]
private int <Offset>k__BackingField;
    [CompilerGeneratedAttribute]
private FieldKind <Kind>k__BackingField;
    public ulong FieldDesc { get; public set; }
    public int Token { get; public set; }
    public ulong MethodTable { get; public set; }
    public ClrElementType ElementType { get; public set; }
    public int Offset { get; public set; }
    public FieldKind Kind { get; public set; }
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public ulong get_FieldDesc();
    [CompilerGeneratedAttribute]
public void set_FieldDesc(ulong value);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public int get_Token();
    [CompilerGeneratedAttribute]
public void set_Token(int value);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public ulong get_MethodTable();
    [CompilerGeneratedAttribute]
public void set_MethodTable(ulong value);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public ClrElementType get_ElementType();
    [CompilerGeneratedAttribute]
public void set_ElementType(ClrElementType value);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public int get_Offset();
    [CompilerGeneratedAttribute]
public void set_Offset(int value);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public FieldKind get_Kind();
    [CompilerGeneratedAttribute]
public void set_Kind(FieldKind value);
}
public enum Microsoft.Diagnostics.Runtime.AbstractDac.FieldKind : Enum {
    public int value__;
    public static FieldKind Unsupported;
    public static FieldKind Instance;
    public static FieldKind Static;
    public static FieldKind ThreadStatic;
}
public enum Microsoft.Diagnostics.Runtime.AbstractDac.GCKind : Enum {
    public int value__;
    public static GCKind Unknown;
    public static GCKind Workstation;
    public static GCKind Server;
}
public class Microsoft.Diagnostics.Runtime.AbstractDac.GCState : ValueType {
    [CompilerGeneratedAttribute]
private GCKind <Kind>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <AreGCStructuresValid>k__BackingField;
    [CompilerGeneratedAttribute]
private int <HeapCount>k__BackingField;
    [CompilerGeneratedAttribute]
private int <MaxGeneration>k__BackingField;
    [CompilerGeneratedAttribute]
private ulong <StringMethodTable>k__BackingField;
    [CompilerGeneratedAttribute]
private ulong <ObjectMethodTable>k__BackingField;
    [CompilerGeneratedAttribute]
private ulong <ExceptionMethodTable>k__BackingField;
    [CompilerGeneratedAttribute]
private ulong <FreeMethodTable>k__BackingField;
    public GCKind Kind { get; public set; }
    public bool AreGCStructuresValid { get; public set; }
    public int HeapCount { get; public set; }
    public int MaxGeneration { get; public set; }
    public ulong StringMethodTable { get; public set; }
    public ulong ObjectMethodTable { get; public set; }
    public ulong ExceptionMethodTable { get; public set; }
    public ulong FreeMethodTable { get; public set; }
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public GCKind get_Kind();
    [CompilerGeneratedAttribute]
public void set_Kind(GCKind value);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public bool get_AreGCStructuresValid();
    [CompilerGeneratedAttribute]
public void set_AreGCStructuresValid(bool value);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public int get_HeapCount();
    [CompilerGeneratedAttribute]
public void set_HeapCount(int value);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public int get_MaxGeneration();
    [CompilerGeneratedAttribute]
public void set_MaxGeneration(int value);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public ulong get_StringMethodTable();
    [CompilerGeneratedAttribute]
public void set_StringMethodTable(ulong value);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public ulong get_ObjectMethodTable();
    [CompilerGeneratedAttribute]
public void set_ObjectMethodTable(ulong value);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public ulong get_ExceptionMethodTable();
    [CompilerGeneratedAttribute]
public void set_ExceptionMethodTable(ulong value);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public ulong get_FreeMethodTable();
    [CompilerGeneratedAttribute]
public void set_FreeMethodTable(ulong value);
}
public class Microsoft.Diagnostics.Runtime.AbstractDac.GenerationInfo : ValueType {
    [CompilerGeneratedAttribute]
private ulong <StartSegment>k__BackingField;
    [CompilerGeneratedAttribute]
private ulong <AllocationStart>k__BackingField;
    [CompilerGeneratedAttribute]
private ulong <AllocationContextPointer>k__BackingField;
    [CompilerGeneratedAttribute]
private ulong <AllocationContextLimit>k__BackingField;
    public ulong StartSegment { get; public set; }
    public ulong AllocationStart { get; public set; }
    public ulong AllocationContextPointer { get; public set; }
    public ulong AllocationContextLimit { get; public set; }
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public ulong get_StartSegment();
    [CompilerGeneratedAttribute]
public void set_StartSegment(ulong value);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public ulong get_AllocationStart();
    [CompilerGeneratedAttribute]
public void set_AllocationStart(ulong value);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public ulong get_AllocationContextPointer();
    [CompilerGeneratedAttribute]
public void set_AllocationContextPointer(ulong value);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public ulong get_AllocationContextLimit();
    [CompilerGeneratedAttribute]
public void set_AllocationContextLimit(ulong value);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
public class Microsoft.Diagnostics.Runtime.AbstractDac.GenericParameterInfo : ValueType {
    [CompilerGeneratedAttribute]
private int <Token>k__BackingField;
    [CompilerGeneratedAttribute]
private int <Index>k__BackingField;
    [CompilerGeneratedAttribute]
private GenericParameterAttributes <Attributes>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    public int Token { get; public set; }
    public int Index { get; public set; }
    public GenericParameterAttributes Attributes { get; public set; }
    public string Name { get; public set; }
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public int get_Token();
    [CompilerGeneratedAttribute]
public void set_Token(int value);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public int get_Index();
    [CompilerGeneratedAttribute]
public void set_Index(int value);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public GenericParameterAttributes get_Attributes();
    [CompilerGeneratedAttribute]
public void set_Attributes(GenericParameterAttributes value);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public string get_Name();
    [CompilerGeneratedAttribute]
public void set_Name(string value);
}
public enum Microsoft.Diagnostics.Runtime.AbstractDac.HeapMarkState : Enum {
    public int value__;
    public static HeapMarkState Marking;
    public static HeapMarkState Planning;
    public static HeapMarkState Free;
}
[NullableContextAttribute("1")]
public interface Microsoft.Diagnostics.Runtime.AbstractDac.IAbstractClrNativeHeaps {
    public abstract virtual IEnumerable`1<ClrNativeHeapInfo> EnumerateGCFreeRegions();
    public abstract virtual IEnumerable`1<ClrNativeHeapInfo> EnumerateHandleTableRegions();
    public abstract virtual IEnumerable`1<ClrNativeHeapInfo> EnumerateGCBookkeepingRegions();
    public abstract virtual IEnumerable`1<ClrSyncBlockCleanupData> EnumerateSyncBlockCleanupData();
    public abstract virtual IEnumerable`1<ClrNativeHeapInfo> EnumerateDomainHeaps(ulong domain);
    public abstract virtual IEnumerable`1<ClrNativeHeapInfo> EnumerateJitManagerHeaps(ulong jitManager);
    public abstract virtual IEnumerable`1<ClrNativeHeapInfo> EnumerateLoaderAllocatorNativeHeaps(ulong loaderAllocator);
    public abstract virtual IEnumerable`1<ClrNativeHeapInfo> EnumerateThunkHeaps(ulong thunkHeapAddress);
}
[NullableContextAttribute("1")]
public interface Microsoft.Diagnostics.Runtime.AbstractDac.IAbstractComHelpers {
    public abstract virtual IEnumerable`1<ClrRcwCleanupData> EnumerateRcwCleanupData();
    public abstract virtual bool GetCcwInfo(ulong obj, CcwInfo& info);
    public abstract virtual bool GetRcwInfo(ulong obj, RcwInfo& info);
}
public interface Microsoft.Diagnostics.Runtime.AbstractDac.IAbstractDacController {
    public bool IsThreadSafe { get; }
    public bool CanFlush { get; }
    public abstract virtual bool get_IsThreadSafe();
    public abstract virtual bool get_CanFlush();
    public abstract virtual void Flush();
}
[NullableContextAttribute("1")]
public interface Microsoft.Diagnostics.Runtime.AbstractDac.IAbstractHeap {
    [IsReadOnlyAttribute]
public GCState& modreq(System.Runtime.InteropServices.InAttribute) State { get; }
    public abstract virtual GCState& modreq(System.Runtime.InteropServices.InAttribute) get_State();
    public abstract virtual IEnumerable`1<MemoryRange> EnumerateThreadAllocationContexts();
    public abstract virtual IEnumerable`1<ValueTuple`2<ulong, ulong>> EnumerateDependentHandles();
    public abstract virtual IEnumerable`1<SyncBlockInfo> EnumerateSyncBlocks();
    public abstract virtual IEnumerable`1<SubHeapInfo> EnumerateSubHeaps();
    [NullableContextAttribute("0")]
public abstract virtual ValueTuple`2<ulong, int> GetThinLock(UInt32 header);
    public abstract virtual bool IsValidMethodTable(ulong mt);
    public abstract virtual MemoryRange GetInternalRootArray(ulong subHeapAddress);
    public abstract virtual bool GetOOMInfo(ulong subHeapAddress, OomInfo& oomInfo);
}
public interface Microsoft.Diagnostics.Runtime.AbstractDac.IAbstractLegacyThreadPool {
    public abstract virtual bool GetLegacyThreadPoolData(LegacyThreadPoolInfo& data);
    public abstract virtual bool GetLegacyWorkRequestData(ulong workRequest, LegacyWorkRequestInfo& workRequestData);
}
[NullableContextAttribute("1")]
public interface Microsoft.Diagnostics.Runtime.AbstractDac.IAbstractMetadataReader {
    public abstract virtual bool GetFieldDefInfo(int token, FieldDefInfo& info);
    public abstract virtual bool GetTypeDefInfo(int typeDef, TypeDefInfo& info);
    [NullableContextAttribute("2")]
public abstract virtual string GetTypeRefName(int typeRef);
    public abstract virtual bool GetNestedClassToken(int typeDef, Int32& parent);
    public abstract virtual bool GetMethodAttributes(int methodDef, MethodAttributes& attributes);
    [NullableContextAttribute("0")]
public abstract virtual int GetCustomAttributeData(int token, string name, Span`1<byte> buffer);
    public abstract virtual UInt32 GetRva(int metadataToken);
    public abstract virtual IEnumerable`1<GenericParameterInfo> EnumerateGenericParameters(int typeDef);
    public abstract virtual IEnumerable`1<InterfaceInfo> EnumerateInterfaces(int typeDef);
    public abstract virtual IEnumerable`1<FieldDefInfo> EnumerateFields(int typeDef);
}
public interface Microsoft.Diagnostics.Runtime.AbstractDac.IAbstractMethodLocator {
    public abstract virtual ulong GetMethodHandleContainingType(ulong methodDesc);
    public abstract virtual ulong GetMethodHandleByInstructionPointer(ulong ip);
    public abstract virtual bool GetMethodInfo(ulong methodDesc, MethodInfo& methodInfo);
}
[NullableContextAttribute("2")]
public interface Microsoft.Diagnostics.Runtime.AbstractDac.IAbstractModuleHelpers {
    public abstract virtual ClrModuleInfo GetModuleInfo(ulong module);
    public abstract virtual IAbstractMetadataReader GetMetadataReader(ulong module);
    public abstract virtual IEnumerable`1<ValueTuple`2<ulong, int>> EnumerateTypeDefMap(ulong module);
    public abstract virtual IEnumerable`1<ValueTuple`2<ulong, int>> EnumerateTypeRefMap(ulong module);
}
[NullableContextAttribute("1")]
public interface Microsoft.Diagnostics.Runtime.AbstractDac.IAbstractRuntime {
    public abstract virtual IEnumerable`1<ClrThreadInfo> EnumerateThreads();
    public abstract virtual IEnumerable`1<AppDomainInfo> EnumerateAppDomains();
    public abstract virtual IEnumerable`1<ulong> GetModuleList(ulong appDomain);
    public abstract virtual IEnumerable`1<ClrHandleInfo> EnumerateHandles();
    public abstract virtual IEnumerable`1<JitManagerInfo> EnumerateClrJitManagers();
    [NullableContextAttribute("2")]
public abstract virtual string GetJitHelperFunctionName(ulong address);
}
[NullableContextAttribute("1")]
public interface Microsoft.Diagnostics.Runtime.AbstractDac.IAbstractThreadHelpers {
    public abstract virtual IEnumerable`1<StackRootInfo> EnumerateStackRoots(UInt32 osThreadId, bool traceErrors);
    public abstract virtual IEnumerable`1<StackFrameInfo> EnumerateStackTrace(UInt32 osThreadId, bool includeContext, bool traceErrors);
}
[NullableContextAttribute("1")]
public interface Microsoft.Diagnostics.Runtime.AbstractDac.IAbstractTypeHelpers {
    public abstract virtual bool GetTypeInfo(ulong methodTable, TypeInfo& info);
    [NullableContextAttribute("2")]
public abstract virtual string GetTypeName(ulong module, ulong methodTable, int token);
    public abstract virtual ulong GetLoaderAllocatorHandle(ulong mt);
    public abstract virtual ulong GetAssemblyLoadContextAddress(ulong mt);
    public abstract virtual bool GetObjectArrayInformation(ulong objRef, ObjectArrayInformation& data);
    public abstract virtual IEnumerable`1<MethodInfo> EnumerateMethodsForType(ulong methodTable);
    public abstract virtual IEnumerable`1<FieldInfo> EnumerateFields(TypeInfo type, int baseFieldCount);
    [NullableContextAttribute("2")]
public abstract virtual string GetMethodSignature(ulong methodDesc);
    [NullableContextAttribute("0")]
public abstract virtual ImmutableArray`1<ILToNativeMap> GetILMap(ulong ip, HotColdRegions& modreq(System.Runtime.InteropServices.InAttribute) hotCold);
    public abstract virtual ulong GetILForModule(ulong address, UInt32 rva);
    public abstract virtual ulong GetStaticFieldAddress(AppDomainInfo& modreq(System.Runtime.InteropServices.InAttribute) appDomain, ClrModuleInfo& modreq(System.Runtime.InteropServices.InAttribute) module, TypeInfo& modreq(System.Runtime.InteropServices.InAttribute) typeInfo, FieldInfo& modreq(System.Runtime.InteropServices.InAttribute) field);
    public abstract virtual ulong GetThreadStaticFieldAddress(ulong threadAddress, ClrModuleInfo& modreq(System.Runtime.InteropServices.InAttribute) module, TypeInfo& modreq(System.Runtime.InteropServices.InAttribute) typeInfo, FieldInfo& modreq(System.Runtime.InteropServices.InAttribute) field);
}
public class Microsoft.Diagnostics.Runtime.AbstractDac.InterfaceInfo : ValueType {
    [CompilerGeneratedAttribute]
private int <Token>k__BackingField;
    [CompilerGeneratedAttribute]
private int <InterfaceToken>k__BackingField;
    public int Token { get; public set; }
    public int InterfaceToken { get; public set; }
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public int get_Token();
    [CompilerGeneratedAttribute]
public void set_Token(int value);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public int get_InterfaceToken();
    [CompilerGeneratedAttribute]
public void set_InterfaceToken(int value);
}
public class Microsoft.Diagnostics.Runtime.AbstractDac.JitManagerInfo : ValueType {
    [CompilerGeneratedAttribute]
private ulong <Address>k__BackingField;
    [CompilerGeneratedAttribute]
private CodeHeapKind <Kind>k__BackingField;
    [CompilerGeneratedAttribute]
private ulong <HeapList>k__BackingField;
    public ulong Address { get; public set; }
    public CodeHeapKind Kind { get; public set; }
    public ulong HeapList { get; public set; }
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public ulong get_Address();
    [CompilerGeneratedAttribute]
public void set_Address(ulong value);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public CodeHeapKind get_Kind();
    [CompilerGeneratedAttribute]
public void set_Kind(CodeHeapKind value);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public ulong get_HeapList();
    [CompilerGeneratedAttribute]
public void set_HeapList(ulong value);
}
public class Microsoft.Diagnostics.Runtime.AbstractDac.LegacyThreadPoolInfo : ValueType {
    [CompilerGeneratedAttribute]
private int <CpuUtilization>k__BackingField;
    [CompilerGeneratedAttribute]
private int <NumIdleWorkerThreads>k__BackingField;
    [CompilerGeneratedAttribute]
private int <NumWorkingWorkerThreads>k__BackingField;
    [CompilerGeneratedAttribute]
private int <NumRetiredWorkerThreads>k__BackingField;
    [CompilerGeneratedAttribute]
private int <MinLimitTotalWorkerThreads>k__BackingField;
    [CompilerGeneratedAttribute]
private int <MaxLimitTotalWorkerThreads>k__BackingField;
    [CompilerGeneratedAttribute]
private ulong <FirstUnmanagedWorkRequest>k__BackingField;
    [CompilerGeneratedAttribute]
private ulong <HillClimbingLog>k__BackingField;
    [CompilerGeneratedAttribute]
private UInt32 <HillClimbingLogFirstIndex>k__BackingField;
    [CompilerGeneratedAttribute]
private UInt32 <HillClimbingLogSize>k__BackingField;
    [CompilerGeneratedAttribute]
private int <NumTimers>k__BackingField;
    [CompilerGeneratedAttribute]
private int <NumCPThreads>k__BackingField;
    [CompilerGeneratedAttribute]
private int <NumFreeCPThreads>k__BackingField;
    [CompilerGeneratedAttribute]
private int <MaxFreeCPThreads>k__BackingField;
    [CompilerGeneratedAttribute]
private int <NumRetiredCPThreads>k__BackingField;
    [CompilerGeneratedAttribute]
private int <MaxLimitTotalCPThreads>k__BackingField;
    [CompilerGeneratedAttribute]
private int <CurrentLimitTotalCPThreads>k__BackingField;
    [CompilerGeneratedAttribute]
private int <MinLimitTotalCPThreads>k__BackingField;
    [CompilerGeneratedAttribute]
private ulong <AsyncTimerCallbackCompletionFPtr>k__BackingField;
    public int CpuUtilization { get; public set; }
    public int NumIdleWorkerThreads { get; public set; }
    public int NumWorkingWorkerThreads { get; public set; }
    public int NumRetiredWorkerThreads { get; public set; }
    public int MinLimitTotalWorkerThreads { get; public set; }
    public int MaxLimitTotalWorkerThreads { get; public set; }
    public ulong FirstUnmanagedWorkRequest { get; public set; }
    public ulong HillClimbingLog { get; public set; }
    public UInt32 HillClimbingLogFirstIndex { get; public set; }
    public UInt32 HillClimbingLogSize { get; public set; }
    public int NumTimers { get; public set; }
    public int NumCPThreads { get; public set; }
    public int NumFreeCPThreads { get; public set; }
    public int MaxFreeCPThreads { get; public set; }
    public int NumRetiredCPThreads { get; public set; }
    public int MaxLimitTotalCPThreads { get; public set; }
    public int CurrentLimitTotalCPThreads { get; public set; }
    public int MinLimitTotalCPThreads { get; public set; }
    public ulong AsyncTimerCallbackCompletionFPtr { get; public set; }
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public int get_CpuUtilization();
    [CompilerGeneratedAttribute]
public void set_CpuUtilization(int value);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public int get_NumIdleWorkerThreads();
    [CompilerGeneratedAttribute]
public void set_NumIdleWorkerThreads(int value);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public int get_NumWorkingWorkerThreads();
    [CompilerGeneratedAttribute]
public void set_NumWorkingWorkerThreads(int value);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public int get_NumRetiredWorkerThreads();
    [CompilerGeneratedAttribute]
public void set_NumRetiredWorkerThreads(int value);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public int get_MinLimitTotalWorkerThreads();
    [CompilerGeneratedAttribute]
public void set_MinLimitTotalWorkerThreads(int value);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public int get_MaxLimitTotalWorkerThreads();
    [CompilerGeneratedAttribute]
public void set_MaxLimitTotalWorkerThreads(int value);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public ulong get_FirstUnmanagedWorkRequest();
    [CompilerGeneratedAttribute]
public void set_FirstUnmanagedWorkRequest(ulong value);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public ulong get_HillClimbingLog();
    [CompilerGeneratedAttribute]
public void set_HillClimbingLog(ulong value);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public UInt32 get_HillClimbingLogFirstIndex();
    [CompilerGeneratedAttribute]
public void set_HillClimbingLogFirstIndex(UInt32 value);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public UInt32 get_HillClimbingLogSize();
    [CompilerGeneratedAttribute]
public void set_HillClimbingLogSize(UInt32 value);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public int get_NumTimers();
    [CompilerGeneratedAttribute]
public void set_NumTimers(int value);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public int get_NumCPThreads();
    [CompilerGeneratedAttribute]
public void set_NumCPThreads(int value);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public int get_NumFreeCPThreads();
    [CompilerGeneratedAttribute]
public void set_NumFreeCPThreads(int value);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public int get_MaxFreeCPThreads();
    [CompilerGeneratedAttribute]
public void set_MaxFreeCPThreads(int value);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public int get_NumRetiredCPThreads();
    [CompilerGeneratedAttribute]
public void set_NumRetiredCPThreads(int value);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public int get_MaxLimitTotalCPThreads();
    [CompilerGeneratedAttribute]
public void set_MaxLimitTotalCPThreads(int value);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public int get_CurrentLimitTotalCPThreads();
    [CompilerGeneratedAttribute]
public void set_CurrentLimitTotalCPThreads(int value);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public int get_MinLimitTotalCPThreads();
    [CompilerGeneratedAttribute]
public void set_MinLimitTotalCPThreads(int value);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public ulong get_AsyncTimerCallbackCompletionFPtr();
    [CompilerGeneratedAttribute]
public void set_AsyncTimerCallbackCompletionFPtr(ulong value);
}
public class Microsoft.Diagnostics.Runtime.AbstractDac.LegacyWorkRequestInfo : ValueType {
    [CompilerGeneratedAttribute]
private ulong <Function>k__BackingField;
    [CompilerGeneratedAttribute]
private ulong <Context>k__BackingField;
    [CompilerGeneratedAttribute]
private ulong <NextWorkRequest>k__BackingField;
    public ulong Function { get; public set; }
    public ulong Context { get; public set; }
    public ulong NextWorkRequest { get; public set; }
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public ulong get_Function();
    [CompilerGeneratedAttribute]
public void set_Function(ulong value);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public ulong get_Context();
    [CompilerGeneratedAttribute]
public void set_Context(ulong value);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public ulong get_NextWorkRequest();
    [CompilerGeneratedAttribute]
public void set_NextWorkRequest(ulong value);
}
public class Microsoft.Diagnostics.Runtime.AbstractDac.MethodInfo : ValueType {
    [CompilerGeneratedAttribute]
private ulong <MethodDesc>k__BackingField;
    [CompilerGeneratedAttribute]
private int <Token>k__BackingField;
    [CompilerGeneratedAttribute]
private MethodCompilationType <CompilationType>k__BackingField;
    [CompilerGeneratedAttribute]
private HotColdRegions <HotCold>k__BackingField;
    public ulong MethodDesc { get; public set; }
    public int Token { get; public set; }
    public MethodCompilationType CompilationType { get; public set; }
    public HotColdRegions HotCold { get; public set; }
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public ulong get_MethodDesc();
    [CompilerGeneratedAttribute]
public void set_MethodDesc(ulong value);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public int get_Token();
    [CompilerGeneratedAttribute]
public void set_Token(int value);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public MethodCompilationType get_CompilationType();
    [CompilerGeneratedAttribute]
public void set_CompilationType(MethodCompilationType value);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public HotColdRegions get_HotCold();
    [CompilerGeneratedAttribute]
public void set_HotCold(HotColdRegions value);
}
public class Microsoft.Diagnostics.Runtime.AbstractDac.ObjectArrayInformation : ValueType {
    [CompilerGeneratedAttribute]
private ulong <ComponentType>k__BackingField;
    [CompilerGeneratedAttribute]
private ClrElementType <ComponentElementType>k__BackingField;
    [CompilerGeneratedAttribute]
private int <DataPointer>k__BackingField;
    public ulong ComponentType { get; public set; }
    public ClrElementType ComponentElementType { get; public set; }
    public int DataPointer { get; public set; }
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public ulong get_ComponentType();
    [CompilerGeneratedAttribute]
public void set_ComponentType(ulong value);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public ClrElementType get_ComponentElementType();
    [CompilerGeneratedAttribute]
public void set_ComponentElementType(ClrElementType value);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public int get_DataPointer();
    [CompilerGeneratedAttribute]
public void set_DataPointer(int value);
}
public class Microsoft.Diagnostics.Runtime.AbstractDac.OomInfo : ValueType {
    [CompilerGeneratedAttribute]
private OutOfMemoryReason <Reason>k__BackingField;
    [CompilerGeneratedAttribute]
private ulong <AllocSize>k__BackingField;
    [CompilerGeneratedAttribute]
private ulong <AvailablePageFileMB>k__BackingField;
    [CompilerGeneratedAttribute]
private ulong <GCIndex>k__BackingField;
    [CompilerGeneratedAttribute]
private GetMemoryFailureReason <GetMemoryFailure>k__BackingField;
    [CompilerGeneratedAttribute]
private ulong <Size>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsLOH>k__BackingField;
    public OutOfMemoryReason Reason { get; public set; }
    public ulong AllocSize { get; public set; }
    public ulong AvailablePageFileMB { get; public set; }
    public ulong GCIndex { get; public set; }
    public GetMemoryFailureReason GetMemoryFailure { get; public set; }
    public ulong Size { get; public set; }
    public bool IsLOH { get; public set; }
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public OutOfMemoryReason get_Reason();
    [CompilerGeneratedAttribute]
public void set_Reason(OutOfMemoryReason value);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public ulong get_AllocSize();
    [CompilerGeneratedAttribute]
public void set_AllocSize(ulong value);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public ulong get_AvailablePageFileMB();
    [CompilerGeneratedAttribute]
public void set_AvailablePageFileMB(ulong value);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public ulong get_GCIndex();
    [CompilerGeneratedAttribute]
public void set_GCIndex(ulong value);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public GetMemoryFailureReason get_GetMemoryFailure();
    [CompilerGeneratedAttribute]
public void set_GetMemoryFailure(GetMemoryFailureReason value);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public ulong get_Size();
    [CompilerGeneratedAttribute]
public void set_Size(ulong value);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public bool get_IsLOH();
    [CompilerGeneratedAttribute]
public void set_IsLOH(bool value);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Microsoft.Diagnostics.Runtime.AbstractDac.RcwInfo : ValueType {
    [CompilerGeneratedAttribute]
private ulong <Object>k__BackingField;
    [CompilerGeneratedAttribute]
private ulong <Address>k__BackingField;
    [CompilerGeneratedAttribute]
private ulong <IUnknown>k__BackingField;
    [CompilerGeneratedAttribute]
private ulong <VTablePointer>k__BackingField;
    [CompilerGeneratedAttribute]
private int <RefCount>k__BackingField;
    [CompilerGeneratedAttribute]
private ulong <CreatorThread>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsDisconnected>k__BackingField;
    [CompilerGeneratedAttribute]
private ComInterfaceEntry[] <Interfaces>k__BackingField;
    public ulong Object { get; public set; }
    public ulong Address { get; public set; }
    public ulong IUnknown { get; public set; }
    public ulong VTablePointer { get; public set; }
    public int RefCount { get; public set; }
    public ulong CreatorThread { get; public set; }
    public bool IsDisconnected { get; public set; }
    public ComInterfaceEntry[] Interfaces { get; public set; }
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public ulong get_Object();
    [CompilerGeneratedAttribute]
public void set_Object(ulong value);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public ulong get_Address();
    [CompilerGeneratedAttribute]
public void set_Address(ulong value);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public ulong get_IUnknown();
    [CompilerGeneratedAttribute]
public void set_IUnknown(ulong value);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public ulong get_VTablePointer();
    [CompilerGeneratedAttribute]
public void set_VTablePointer(ulong value);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public int get_RefCount();
    [CompilerGeneratedAttribute]
public void set_RefCount(int value);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public ulong get_CreatorThread();
    [CompilerGeneratedAttribute]
public void set_CreatorThread(ulong value);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public bool get_IsDisconnected();
    [CompilerGeneratedAttribute]
public void set_IsDisconnected(bool value);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public ComInterfaceEntry[] get_Interfaces();
    [CompilerGeneratedAttribute]
public void set_Interfaces(ComInterfaceEntry[] value);
}
public class Microsoft.Diagnostics.Runtime.AbstractDac.SegmentInfo : ValueType {
    [CompilerGeneratedAttribute]
private ulong <Address>k__BackingField;
    [CompilerGeneratedAttribute]
private GCSegmentKind <Kind>k__BackingField;
    [CompilerGeneratedAttribute]
private MemoryRange <ObjectRange>k__BackingField;
    [CompilerGeneratedAttribute]
private MemoryRange <CommittedMemory>k__BackingField;
    [CompilerGeneratedAttribute]
private MemoryRange <ReservedMemory>k__BackingField;
    [CompilerGeneratedAttribute]
private MemoryRange <Generation0>k__BackingField;
    [CompilerGeneratedAttribute]
private MemoryRange <Generation1>k__BackingField;
    [CompilerGeneratedAttribute]
private MemoryRange <Generation2>k__BackingField;
    [CompilerGeneratedAttribute]
private ClrSegmentFlags <Flags>k__BackingField;
    [CompilerGeneratedAttribute]
private ulong <BackgroundAllocated>k__BackingField;
    [CompilerGeneratedAttribute]
private ulong <Next>k__BackingField;
    public ulong Address { get; public set; }
    public GCSegmentKind Kind { get; public set; }
    public MemoryRange ObjectRange { get; public set; }
    public MemoryRange CommittedMemory { get; public set; }
    public MemoryRange ReservedMemory { get; public set; }
    public MemoryRange Generation0 { get; public set; }
    public MemoryRange Generation1 { get; public set; }
    public MemoryRange Generation2 { get; public set; }
    public ClrSegmentFlags Flags { get; public set; }
    public ulong BackgroundAllocated { get; public set; }
    public ulong Next { get; public set; }
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public ulong get_Address();
    [CompilerGeneratedAttribute]
public void set_Address(ulong value);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public GCSegmentKind get_Kind();
    [CompilerGeneratedAttribute]
public void set_Kind(GCSegmentKind value);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public MemoryRange get_ObjectRange();
    [CompilerGeneratedAttribute]
public void set_ObjectRange(MemoryRange value);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public MemoryRange get_CommittedMemory();
    [CompilerGeneratedAttribute]
public void set_CommittedMemory(MemoryRange value);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public MemoryRange get_ReservedMemory();
    [CompilerGeneratedAttribute]
public void set_ReservedMemory(MemoryRange value);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public MemoryRange get_Generation0();
    [CompilerGeneratedAttribute]
public void set_Generation0(MemoryRange value);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public MemoryRange get_Generation1();
    [CompilerGeneratedAttribute]
public void set_Generation1(MemoryRange value);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public MemoryRange get_Generation2();
    [CompilerGeneratedAttribute]
public void set_Generation2(MemoryRange value);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public ClrSegmentFlags get_Flags();
    [CompilerGeneratedAttribute]
public void set_Flags(ClrSegmentFlags value);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public ulong get_BackgroundAllocated();
    [CompilerGeneratedAttribute]
public void set_BackgroundAllocated(ulong value);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public ulong get_Next();
    [CompilerGeneratedAttribute]
public void set_Next(ulong value);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
public class Microsoft.Diagnostics.Runtime.AbstractDac.StackFrameInfo : ValueType {
    [CompilerGeneratedAttribute]
private ulong <InstructionPointer>k__BackingField;
    [CompilerGeneratedAttribute]
private ulong <StackPointer>k__BackingField;
    [CompilerGeneratedAttribute]
private ulong <InternalFrameVTable>k__BackingField;
    [CompilerGeneratedAttribute]
private string <InternalFrameName>k__BackingField;
    [CompilerGeneratedAttribute]
private ulong <InnerMethodMethodHandle>k__BackingField;
    [CompilerGeneratedAttribute]
private Byte[] <Context>k__BackingField;
    public ulong InstructionPointer { get; public set; }
    public ulong StackPointer { get; public set; }
    public bool IsInternalFrame { get; }
    public ulong InternalFrameVTable { get; public set; }
    public string InternalFrameName { get; public set; }
    public ulong InnerMethodMethodHandle { get; public set; }
    public Byte[] Context { get; public set; }
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public ulong get_InstructionPointer();
    [CompilerGeneratedAttribute]
public void set_InstructionPointer(ulong value);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public ulong get_StackPointer();
    [CompilerGeneratedAttribute]
public void set_StackPointer(ulong value);
    [IsReadOnlyAttribute]
public bool get_IsInternalFrame();
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public ulong get_InternalFrameVTable();
    [CompilerGeneratedAttribute]
public void set_InternalFrameVTable(ulong value);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public string get_InternalFrameName();
    [CompilerGeneratedAttribute]
public void set_InternalFrameName(string value);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public ulong get_InnerMethodMethodHandle();
    [CompilerGeneratedAttribute]
public void set_InnerMethodMethodHandle(ulong value);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public Byte[] get_Context();
    [CompilerGeneratedAttribute]
public void set_Context(Byte[] value);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
public class Microsoft.Diagnostics.Runtime.AbstractDac.StackRootInfo : ValueType {
    [CompilerGeneratedAttribute]
private ulong <InstructionPointer>k__BackingField;
    [CompilerGeneratedAttribute]
private ulong <StackPointer>k__BackingField;
    [CompilerGeneratedAttribute]
private ulong <InternalFrame>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsInterior>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsPinned>k__BackingField;
    [CompilerGeneratedAttribute]
private ulong <Address>k__BackingField;
    [CompilerGeneratedAttribute]
private ulong <Object>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsEnregistered>k__BackingField;
    [CompilerGeneratedAttribute]
private string <RegisterName>k__BackingField;
    [CompilerGeneratedAttribute]
private int <RegisterOffset>k__BackingField;
    public ulong InstructionPointer { get; public set; }
    public ulong StackPointer { get; public set; }
    public ulong InternalFrame { get; public set; }
    public bool IsInterior { get; public set; }
    public bool IsPinned { get; public set; }
    public ulong Address { get; public set; }
    public ulong Object { get; public set; }
    public bool IsEnregistered { get; public set; }
    public string RegisterName { get; public set; }
    public int RegisterOffset { get; public set; }
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public ulong get_InstructionPointer();
    [CompilerGeneratedAttribute]
public void set_InstructionPointer(ulong value);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public ulong get_StackPointer();
    [CompilerGeneratedAttribute]
public void set_StackPointer(ulong value);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public ulong get_InternalFrame();
    [CompilerGeneratedAttribute]
public void set_InternalFrame(ulong value);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public bool get_IsInterior();
    [CompilerGeneratedAttribute]
public void set_IsInterior(bool value);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public bool get_IsPinned();
    [CompilerGeneratedAttribute]
public void set_IsPinned(bool value);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public ulong get_Address();
    [CompilerGeneratedAttribute]
public void set_Address(ulong value);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public ulong get_Object();
    [CompilerGeneratedAttribute]
public void set_Object(ulong value);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public bool get_IsEnregistered();
    [CompilerGeneratedAttribute]
public void set_IsEnregistered(bool value);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public string get_RegisterName();
    [CompilerGeneratedAttribute]
public void set_RegisterName(string value);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public int get_RegisterOffset();
    [CompilerGeneratedAttribute]
public void set_RegisterOffset(int value);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Microsoft.Diagnostics.Runtime.AbstractDac.SubHeapInfo : ValueType {
    [CompilerGeneratedAttribute]
private ulong <Address>k__BackingField;
    [CompilerGeneratedAttribute]
private int <HeapIndex>k__BackingField;
    [CompilerGeneratedAttribute]
private ulong <Allocated>k__BackingField;
    [CompilerGeneratedAttribute]
private ulong <MarkArray>k__BackingField;
    [CompilerGeneratedAttribute]
private HeapMarkState <State>k__BackingField;
    [CompilerGeneratedAttribute]
private ulong <CurrentSweepPosition>k__BackingField;
    [CompilerGeneratedAttribute]
private ulong <SavedSweepEphemeralSegment>k__BackingField;
    [CompilerGeneratedAttribute]
private ulong <SavedSweepEphemeralStart>k__BackingField;
    [CompilerGeneratedAttribute]
private ulong <BackgroundSavedLowestAddress>k__BackingField;
    [CompilerGeneratedAttribute]
private ulong <BackgroundSavedHighestAddress>k__BackingField;
    [CompilerGeneratedAttribute]
private ulong <EphemeralHeapSegment>k__BackingField;
    [CompilerGeneratedAttribute]
private ulong <LowestAddress>k__BackingField;
    [CompilerGeneratedAttribute]
private ulong <HighestAddress>k__BackingField;
    [CompilerGeneratedAttribute]
private ulong <CardTable>k__BackingField;
    [CompilerGeneratedAttribute]
private ulong <EphemeralAllocContextPointer>k__BackingField;
    [CompilerGeneratedAttribute]
private ulong <EphemeralAllocContextLimit>k__BackingField;
    [CompilerGeneratedAttribute]
private SegmentInfo[] <Segments>k__BackingField;
    [CompilerGeneratedAttribute]
private GenerationInfo[] <Generations>k__BackingField;
    [CompilerGeneratedAttribute]
private UInt64[] <FinalizationPointers>k__BackingField;
    public ulong Address { get; public set; }
    public int HeapIndex { get; public set; }
    public ulong Allocated { get; public set; }
    public ulong MarkArray { get; public set; }
    public HeapMarkState State { get; public set; }
    public ulong CurrentSweepPosition { get; public set; }
    public ulong SavedSweepEphemeralSegment { get; public set; }
    public ulong SavedSweepEphemeralStart { get; public set; }
    public ulong BackgroundSavedLowestAddress { get; public set; }
    public ulong BackgroundSavedHighestAddress { get; public set; }
    public ulong EphemeralHeapSegment { get; public set; }
    public ulong LowestAddress { get; public set; }
    public ulong HighestAddress { get; public set; }
    public ulong CardTable { get; public set; }
    public ulong EphemeralAllocContextPointer { get; public set; }
    public ulong EphemeralAllocContextLimit { get; public set; }
    public SegmentInfo[] Segments { get; public set; }
    public GenerationInfo[] Generations { get; public set; }
    public UInt64[] FinalizationPointers { get; public set; }
    public bool HasRegions { get; }
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public ulong get_Address();
    [CompilerGeneratedAttribute]
public void set_Address(ulong value);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public int get_HeapIndex();
    [CompilerGeneratedAttribute]
public void set_HeapIndex(int value);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public ulong get_Allocated();
    [CompilerGeneratedAttribute]
public void set_Allocated(ulong value);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public ulong get_MarkArray();
    [CompilerGeneratedAttribute]
public void set_MarkArray(ulong value);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public HeapMarkState get_State();
    [CompilerGeneratedAttribute]
public void set_State(HeapMarkState value);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public ulong get_CurrentSweepPosition();
    [CompilerGeneratedAttribute]
public void set_CurrentSweepPosition(ulong value);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public ulong get_SavedSweepEphemeralSegment();
    [CompilerGeneratedAttribute]
public void set_SavedSweepEphemeralSegment(ulong value);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public ulong get_SavedSweepEphemeralStart();
    [CompilerGeneratedAttribute]
public void set_SavedSweepEphemeralStart(ulong value);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public ulong get_BackgroundSavedLowestAddress();
    [CompilerGeneratedAttribute]
public void set_BackgroundSavedLowestAddress(ulong value);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public ulong get_BackgroundSavedHighestAddress();
    [CompilerGeneratedAttribute]
public void set_BackgroundSavedHighestAddress(ulong value);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public ulong get_EphemeralHeapSegment();
    [CompilerGeneratedAttribute]
public void set_EphemeralHeapSegment(ulong value);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public ulong get_LowestAddress();
    [CompilerGeneratedAttribute]
public void set_LowestAddress(ulong value);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public ulong get_HighestAddress();
    [CompilerGeneratedAttribute]
public void set_HighestAddress(ulong value);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public ulong get_CardTable();
    [CompilerGeneratedAttribute]
public void set_CardTable(ulong value);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public ulong get_EphemeralAllocContextPointer();
    [CompilerGeneratedAttribute]
public void set_EphemeralAllocContextPointer(ulong value);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public ulong get_EphemeralAllocContextLimit();
    [CompilerGeneratedAttribute]
public void set_EphemeralAllocContextLimit(ulong value);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public SegmentInfo[] get_Segments();
    [CompilerGeneratedAttribute]
public void set_Segments(SegmentInfo[] value);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public GenerationInfo[] get_Generations();
    [CompilerGeneratedAttribute]
public void set_Generations(GenerationInfo[] value);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public UInt64[] get_FinalizationPointers();
    [CompilerGeneratedAttribute]
public void set_FinalizationPointers(UInt64[] value);
    [IsReadOnlyAttribute]
public bool get_HasRegions();
}
public class Microsoft.Diagnostics.Runtime.AbstractDac.SyncBlockInfo : ValueType {
    [CompilerGeneratedAttribute]
private int <Index>k__BackingField;
    [CompilerGeneratedAttribute]
private ulong <Address>k__BackingField;
    [CompilerGeneratedAttribute]
private ulong <Object>k__BackingField;
    [CompilerGeneratedAttribute]
private SyncBlockComFlags <COMFlags>k__BackingField;
    [CompilerGeneratedAttribute]
private int <MonitorHeldCount>k__BackingField;
    [CompilerGeneratedAttribute]
private int <Recursion>k__BackingField;
    [CompilerGeneratedAttribute]
private ulong <HoldingThread>k__BackingField;
    [CompilerGeneratedAttribute]
private int <AdditionalThreadCount>k__BackingField;
    [CompilerGeneratedAttribute]
private ulong <AppDomain>k__BackingField;
    public int Index { get; public set; }
    public ulong Address { get; public set; }
    public ulong Object { get; public set; }
    public SyncBlockComFlags COMFlags { get; public set; }
    public int MonitorHeldCount { get; public set; }
    public int Recursion { get; public set; }
    public ulong HoldingThread { get; public set; }
    public int AdditionalThreadCount { get; public set; }
    public ulong AppDomain { get; public set; }
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public int get_Index();
    [CompilerGeneratedAttribute]
public void set_Index(int value);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public ulong get_Address();
    [CompilerGeneratedAttribute]
public void set_Address(ulong value);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public ulong get_Object();
    [CompilerGeneratedAttribute]
public void set_Object(ulong value);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public SyncBlockComFlags get_COMFlags();
    [CompilerGeneratedAttribute]
public void set_COMFlags(SyncBlockComFlags value);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public int get_MonitorHeldCount();
    [CompilerGeneratedAttribute]
public void set_MonitorHeldCount(int value);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public int get_Recursion();
    [CompilerGeneratedAttribute]
public void set_Recursion(int value);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public ulong get_HoldingThread();
    [CompilerGeneratedAttribute]
public void set_HoldingThread(ulong value);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public int get_AdditionalThreadCount();
    [CompilerGeneratedAttribute]
public void set_AdditionalThreadCount(int value);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public ulong get_AppDomain();
    [CompilerGeneratedAttribute]
public void set_AppDomain(ulong value);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
public class Microsoft.Diagnostics.Runtime.AbstractDac.TypeDefInfo : ValueType {
    [CompilerGeneratedAttribute]
private int <Token>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    [CompilerGeneratedAttribute]
private TypeAttributes <Attributes>k__BackingField;
    [CompilerGeneratedAttribute]
private int <Parent>k__BackingField;
    public int Token { get; public set; }
    public string Name { get; public set; }
    public TypeAttributes Attributes { get; public set; }
    public int Parent { get; public set; }
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public int get_Token();
    [CompilerGeneratedAttribute]
public void set_Token(int value);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public string get_Name();
    [CompilerGeneratedAttribute]
public void set_Name(string value);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public TypeAttributes get_Attributes();
    [CompilerGeneratedAttribute]
public void set_Attributes(TypeAttributes value);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public int get_Parent();
    [CompilerGeneratedAttribute]
public void set_Parent(int value);
}
public class Microsoft.Diagnostics.Runtime.AbstractDac.TypeInfo : ValueType {
    [CompilerGeneratedAttribute]
private ulong <MethodTable>k__BackingField;
    [CompilerGeneratedAttribute]
private ulong <ModuleAddress>k__BackingField;
    [CompilerGeneratedAttribute]
private ulong <ParentMethodTable>k__BackingField;
    [CompilerGeneratedAttribute]
private int <MetadataToken>k__BackingField;
    [CompilerGeneratedAttribute]
private int <StaticSize>k__BackingField;
    [CompilerGeneratedAttribute]
private int <ComponentSize>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsShared>k__BackingField;
    [CompilerGeneratedAttribute]
private int <MethodCount>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <ContainsPointers>k__BackingField;
    public ulong MethodTable { get; public set; }
    public ulong ModuleAddress { get; public set; }
    public ulong ParentMethodTable { get; public set; }
    public int MetadataToken { get; public set; }
    public int StaticSize { get; public set; }
    public int ComponentSize { get; public set; }
    public bool IsShared { get; public set; }
    public int MethodCount { get; public set; }
    public bool ContainsPointers { get; public set; }
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public ulong get_MethodTable();
    [CompilerGeneratedAttribute]
public void set_MethodTable(ulong value);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public ulong get_ModuleAddress();
    [CompilerGeneratedAttribute]
public void set_ModuleAddress(ulong value);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public ulong get_ParentMethodTable();
    [CompilerGeneratedAttribute]
public void set_ParentMethodTable(ulong value);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public int get_MetadataToken();
    [CompilerGeneratedAttribute]
public void set_MetadataToken(int value);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public int get_StaticSize();
    [CompilerGeneratedAttribute]
public void set_StaticSize(int value);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public int get_ComponentSize();
    [CompilerGeneratedAttribute]
public void set_ComponentSize(int value);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public bool get_IsShared();
    [CompilerGeneratedAttribute]
public void set_IsShared(bool value);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public int get_MethodCount();
    [CompilerGeneratedAttribute]
public void set_MethodCount(int value);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public bool get_ContainsPointers();
    [CompilerGeneratedAttribute]
public void set_ContainsPointers(bool value);
}
public class Microsoft.Diagnostics.Runtime.AMD64Context : ValueType {
    public static UInt32 Context;
    public static UInt32 ContextControl;
    public static UInt32 ContextInteger;
    public static UInt32 ContextSegments;
    public static UInt32 ContextFloatingPoint;
    public static UInt32 ContextDebugRegisters;
    public ulong P1Home;
    public ulong P2Home;
    public ulong P3Home;
    public ulong P4Home;
    public ulong P5Home;
    public ulong P6Home;
    public UInt32 ContextFlags;
    public UInt32 MxCsr;
    [RegisterAttribute("3")]
public ushort Cs;
    [RegisterAttribute("3")]
public ushort Ds;
    [RegisterAttribute("3")]
public ushort Es;
    [RegisterAttribute("3")]
public ushort Fs;
    [RegisterAttribute("3")]
public ushort Gs;
    [RegisterAttribute("3")]
public ushort Ss;
    [RegisterAttribute("1")]
public int EFlags;
    [RegisterAttribute("5")]
public ulong Dr0;
    [RegisterAttribute("5")]
public ulong Dr1;
    [RegisterAttribute("5")]
public ulong Dr2;
    [RegisterAttribute("5")]
public ulong Dr3;
    [RegisterAttribute("5")]
public ulong Dr6;
    [RegisterAttribute("5")]
public ulong Dr7;
    [RegisterAttribute("1")]
public ulong Rax;
    [RegisterAttribute("1")]
public ulong Rcx;
    [RegisterAttribute("1")]
public ulong Rdx;
    [RegisterAttribute("1")]
public ulong Rbx;
    [RegisterAttribute("34")]
public ulong Rsp;
    [RegisterAttribute("66")]
public ulong Rbp;
    [RegisterAttribute("1")]
public ulong Rsi;
    [RegisterAttribute("1")]
public ulong Rdi;
    [RegisterAttribute("1")]
public ulong R8;
    [RegisterAttribute("1")]
public ulong R9;
    [RegisterAttribute("1")]
public ulong R10;
    [RegisterAttribute("1")]
public ulong R11;
    [RegisterAttribute("1")]
public ulong R12;
    [RegisterAttribute("1")]
public ulong R13;
    [RegisterAttribute("1")]
public ulong R14;
    [RegisterAttribute("1")]
public ulong R15;
    [RegisterAttribute("18")]
public ulong Rip;
    [RegisterAttribute("5")]
public ulong DebugControl;
    [RegisterAttribute("5")]
public ulong LastBranchToRip;
    [RegisterAttribute("5")]
public ulong LastBranchFromRip;
    [RegisterAttribute("5")]
public ulong LastExceptionToRip;
    [RegisterAttribute("5")]
public ulong LastExceptionFromRip;
    public static int Size { get; }
    public static int get_Size();
}
public class Microsoft.Diagnostics.Runtime.Arm64Context : ValueType {
    public static UInt32 Context;
    public static UInt32 ContextControl;
    public static UInt32 ContextInteger;
    public static UInt32 ContextFloatingPoint;
    public static UInt32 ContextDebugRegisters;
    public UInt32 ContextFlags;
    [RegisterAttribute("1")]
public UInt32 Cpsr;
    [RegisterAttribute("1")]
public ulong X0;
    [RegisterAttribute("1")]
public ulong X1;
    [RegisterAttribute("1")]
public ulong X2;
    [RegisterAttribute("1")]
public ulong X3;
    [RegisterAttribute("1")]
public ulong X4;
    [RegisterAttribute("1")]
public ulong X5;
    [RegisterAttribute("1")]
public ulong X6;
    [RegisterAttribute("1")]
public ulong X7;
    [RegisterAttribute("1")]
public ulong X8;
    [RegisterAttribute("1")]
public ulong X9;
    [RegisterAttribute("1")]
public ulong X10;
    [RegisterAttribute("1")]
public ulong X11;
    [RegisterAttribute("1")]
public ulong X12;
    [RegisterAttribute("1")]
public ulong X13;
    [RegisterAttribute("1")]
public ulong X14;
    [RegisterAttribute("1")]
public ulong X15;
    [RegisterAttribute("1")]
public ulong X16;
    [RegisterAttribute("1")]
public ulong X17;
    [RegisterAttribute("1")]
public ulong X18;
    [RegisterAttribute("1")]
public ulong X19;
    [RegisterAttribute("1")]
public ulong X20;
    [RegisterAttribute("1")]
public ulong X21;
    [RegisterAttribute("1")]
public ulong X22;
    [RegisterAttribute("1")]
public ulong X23;
    [RegisterAttribute("1")]
public ulong X24;
    [RegisterAttribute("1")]
public ulong X25;
    [RegisterAttribute("1")]
public ulong X26;
    [RegisterAttribute("1")]
public ulong X27;
    [RegisterAttribute("1")]
public ulong X28;
    [RegisterAttribute("66")]
public ulong Fp;
    [RegisterAttribute("2")]
public ulong Lr;
    [RegisterAttribute("34")]
public ulong Sp;
    [RegisterAttribute("18")]
public ulong Pc;
    [FixedBufferAttribute("System.UInt64", "64")]
[RegisterAttribute("4")]
public <V>e__FixedBuffer V;
    [RegisterAttribute("4")]
public UInt32 Fpcr;
    [RegisterAttribute("4")]
public UInt32 Fpsr;
    private static int ARM64_MAX_BREAKPOINTS;
    private static int ARM64_MAX_WATCHPOINTS;
    [FixedBufferAttribute("System.UInt32", "8")]
[RegisterAttribute("5")]
public <Bcr>e__FixedBuffer Bcr;
    [FixedBufferAttribute("System.UInt64", "8")]
[RegisterAttribute("5")]
public <Bvr>e__FixedBuffer Bvr;
    [FixedBufferAttribute("System.UInt32", "2")]
[RegisterAttribute("5")]
public <Wcr>e__FixedBuffer Wcr;
    [FixedBufferAttribute("System.UInt64", "2")]
[RegisterAttribute("5")]
public <Wvr>e__FixedBuffer Wvr;
    public static int Size { get; }
    public static int get_Size();
}
public class Microsoft.Diagnostics.Runtime.ArmContext : ValueType {
    public static UInt32 Context;
    public static UInt32 ContextControl;
    public static UInt32 ContextInteger;
    public static UInt32 ContextFloatingPoint;
    public static UInt32 ContextDebugRegisters;
    public UInt32 ContextFlags;
    [RegisterAttribute("1")]
public UInt32 R0;
    [RegisterAttribute("1")]
public UInt32 R1;
    [RegisterAttribute("1")]
public UInt32 R2;
    [RegisterAttribute("1")]
public UInt32 R3;
    [RegisterAttribute("1")]
public UInt32 R4;
    [RegisterAttribute("1")]
public UInt32 R5;
    [RegisterAttribute("1")]
public UInt32 R6;
    [RegisterAttribute("1")]
public UInt32 R7;
    [RegisterAttribute("1")]
public UInt32 R8;
    [RegisterAttribute("1")]
public UInt32 R9;
    [RegisterAttribute("1")]
public UInt32 R10;
    [RegisterAttribute("65")]
public UInt32 R11;
    [RegisterAttribute("1")]
public UInt32 R12;
    [RegisterAttribute("34")]
public UInt32 Sp;
    [RegisterAttribute("2")]
public UInt32 Lr;
    [RegisterAttribute("18")]
public UInt32 Pc;
    [RegisterAttribute("1")]
public UInt32 Cpsr;
    [RegisterAttribute("4")]
public UInt32 Fpscr;
    [RegisterAttribute("4")]
public M128A Q0;
    [RegisterAttribute("4")]
public M128A Q1;
    [RegisterAttribute("4")]
public M128A Q2;
    [RegisterAttribute("4")]
public M128A Q3;
    [RegisterAttribute("4")]
public M128A Q4;
    [RegisterAttribute("4")]
public M128A Q5;
    [RegisterAttribute("4")]
public M128A Q6;
    [RegisterAttribute("4")]
public M128A Q7;
    [RegisterAttribute("4")]
public M128A Q8;
    [RegisterAttribute("4")]
public M128A Q9;
    [RegisterAttribute("4")]
public M128A Q10;
    [RegisterAttribute("4")]
public M128A Q11;
    [RegisterAttribute("4")]
public M128A Q12;
    [RegisterAttribute("4")]
public M128A Q13;
    [RegisterAttribute("4")]
public M128A Q14;
    [RegisterAttribute("4")]
public M128A Q15;
    [FixedBufferAttribute("System.UInt32", "8")]
[RegisterAttribute("5")]
public <Bvr>e__FixedBuffer Bvr;
    [FixedBufferAttribute("System.UInt32", "8")]
[RegisterAttribute("5")]
public <Bcr>e__FixedBuffer Bcr;
    [FixedBufferAttribute("System.UInt32", "1")]
[RegisterAttribute("5")]
public <Wvr>e__FixedBuffer Wvr;
    [FixedBufferAttribute("System.UInt32", "1")]
[RegisterAttribute("5")]
public <Wcr>e__FixedBuffer Wcr;
    public ulong Padding;
    public static int Size { get; }
    public static int get_Size();
}
internal class Microsoft.Diagnostics.Runtime.AssertionException : Exception {
    [NullableContextAttribute("1")]
public AssertionException(string msg);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
internal static class Microsoft.Diagnostics.Runtime.BinarySearchExtensions : object {
    [ExtensionAttribute]
public static int Search(Kind[] list, Key key, Func`3<Kind, Key, int> compareTo);
    [ExtensionAttribute]
public static int Search(ImmutableArray`1<Kind> list, Key key, Func`3<Kind, Key, int> compareTo);
}
public class Microsoft.Diagnostics.Runtime.CacheOptions : object {
    [CompilerGeneratedAttribute]
private bool <CacheTypes>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <CacheFields>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <CacheMethods>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <CacheStackTraces>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <CacheStackRoots>k__BackingField;
    [CompilerGeneratedAttribute]
private StringCaching <CacheTypeNames>k__BackingField;
    [CompilerGeneratedAttribute]
private StringCaching <CacheFieldNames>k__BackingField;
    [CompilerGeneratedAttribute]
private StringCaching <CacheMethodNames>k__BackingField;
    [CompilerGeneratedAttribute]
private long <MaxDumpCacheSize>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <UseOSMemoryFeatures>k__BackingField;
    public bool CacheTypes { get; public set; }
    public bool CacheFields { get; public set; }
    public bool CacheMethods { get; public set; }
    public bool CacheStackTraces { get; public set; }
    public bool CacheStackRoots { get; public set; }
    public StringCaching CacheTypeNames { get; public set; }
    public StringCaching CacheFieldNames { get; public set; }
    public StringCaching CacheMethodNames { get; public set; }
    public long MaxDumpCacheSize { get; public set; }
    public bool UseOSMemoryFeatures { get; public set; }
    [CompilerGeneratedAttribute]
public bool get_CacheTypes();
    [CompilerGeneratedAttribute]
public void set_CacheTypes(bool value);
    [CompilerGeneratedAttribute]
public bool get_CacheFields();
    [CompilerGeneratedAttribute]
public void set_CacheFields(bool value);
    [CompilerGeneratedAttribute]
public bool get_CacheMethods();
    [CompilerGeneratedAttribute]
public void set_CacheMethods(bool value);
    [CompilerGeneratedAttribute]
public bool get_CacheStackTraces();
    [CompilerGeneratedAttribute]
public void set_CacheStackTraces(bool value);
    [CompilerGeneratedAttribute]
public bool get_CacheStackRoots();
    [CompilerGeneratedAttribute]
public void set_CacheStackRoots(bool value);
    [CompilerGeneratedAttribute]
public StringCaching get_CacheTypeNames();
    [CompilerGeneratedAttribute]
public void set_CacheTypeNames(StringCaching value);
    [CompilerGeneratedAttribute]
public StringCaching get_CacheFieldNames();
    [CompilerGeneratedAttribute]
public void set_CacheFieldNames(StringCaching value);
    [CompilerGeneratedAttribute]
public StringCaching get_CacheMethodNames();
    [CompilerGeneratedAttribute]
public void set_CacheMethodNames(StringCaching value);
    [CompilerGeneratedAttribute]
public long get_MaxDumpCacheSize();
    [CompilerGeneratedAttribute]
public void set_MaxDumpCacheSize(long value);
    [CompilerGeneratedAttribute]
public bool get_UseOSMemoryFeatures();
    [CompilerGeneratedAttribute]
public void set_UseOSMemoryFeatures(bool value);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
public class Microsoft.Diagnostics.Runtime.ClrAppDomain : object {
    private IAbstractClrNativeHeaps _nativeHeapHelpers;
    [CompilerGeneratedAttribute]
private AppDomainInfo <AppDomainInfo>k__BackingField;
    [NullableAttribute("1")]
[CompilerGeneratedAttribute]
private ClrRuntime <Runtime>k__BackingField;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private ImmutableArray`1<ClrModule> <Modules>k__BackingField;
    internal AppDomainInfo AppDomainInfo { get; }
    [NullableAttribute("1")]
public ClrRuntime Runtime { get; }
    [NullableAttribute("1")]
private IClrRuntime Microsoft.Diagnostics.Runtime.Interfaces.IClrAppDomain.Runtime { get; }
    public ulong Address { get; }
    public int Id { get; }
    public string Name { get; }
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ImmutableArray`1<ClrModule> Modules { get; internal set; }
    public string ConfigurationFile { get; }
    public string ApplicationBase { get; }
    public ulong LoaderAllocator { get; }
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private ImmutableArray`1<IClrModule> Microsoft.Diagnostics.Runtime.Interfaces.IClrAppDomain.Modules { get; }
    [NullableContextAttribute("1")]
internal ClrAppDomain(ClrRuntime runtime, AppDomainInfo info, IAbstractClrNativeHeaps nativeHeapHelpers);
    [CompilerGeneratedAttribute]
internal AppDomainInfo get_AppDomainInfo();
    public sealed virtual bool Equals(IClrAppDomain other);
    public bool Equals(ClrAppDomain other);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    [NullableContextAttribute("1")]
[CompilerGeneratedAttribute]
public ClrRuntime get_Runtime();
    [NullableContextAttribute("1")]
private sealed virtual override IClrRuntime Microsoft.Diagnostics.Runtime.Interfaces.IClrAppDomain.get_Runtime();
    public sealed virtual ulong get_Address();
    public sealed virtual int get_Id();
    public sealed virtual string get_Name();
    [CompilerGeneratedAttribute]
public ImmutableArray`1<ClrModule> get_Modules();
    [CompilerGeneratedAttribute]
internal void set_Modules(ImmutableArray`1<ClrModule> value);
    public sealed virtual string get_ConfigurationFile();
    public sealed virtual string get_ApplicationBase();
    public sealed virtual ulong get_LoaderAllocator();
    [NullableContextAttribute("1")]
public sealed virtual IEnumerable`1<ClrNativeHeapInfo> EnumerateLoaderAllocatorHeaps();
    public virtual string ToString();
    private sealed virtual override ImmutableArray`1<IClrModule> Microsoft.Diagnostics.Runtime.Interfaces.IClrAppDomain.get_Modules();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Microsoft.Diagnostics.Runtime.ClrArray : ValueType {
    [CompilerGeneratedAttribute]
private ulong <Address>k__BackingField;
    [CompilerGeneratedAttribute]
private ClrType <Type>k__BackingField;
    private int _length;
    public ulong Address { get; }
    public ClrType Type { get; }
    public int Length { get; }
    public int Rank { get; }
    private bool IsMultiDimensional { get; }
    private int MultiDimensionalRank { get; }
    private IClrType Microsoft.Diagnostics.Runtime.Interfaces.IClrArray.Type { get; }
    internal ClrArray(ulong address, ClrType type);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public sealed virtual ulong get_Address();
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public ClrType get_Type();
    public sealed virtual int get_Length();
    [IsReadOnlyAttribute]
public sealed virtual int get_Rank();
    [IsReadOnlyAttribute]
private bool get_IsMultiDimensional();
    [IsReadOnlyAttribute]
private int get_MultiDimensionalRank();
    private sealed virtual override IClrType Microsoft.Diagnostics.Runtime.Interfaces.IClrArray.get_Type();
    [NullableContextAttribute("0")]
public sealed virtual T[] ReadValues(int start, int count);
    [IsReadOnlyAttribute]
[NullableContextAttribute("2")]
public virtual bool Equals(object obj);
    public sealed virtual bool Equals(ClrArray other);
    [IsReadOnlyAttribute]
public virtual int GetHashCode();
    public sealed virtual int GetLength(int dimension);
    [IsReadOnlyAttribute]
public sealed virtual int GetLowerBound(int dimension);
    public sealed virtual int GetUpperBound(int dimension);
    [NullableContextAttribute("0")]
public sealed virtual T GetValue(int index);
    [NullableContextAttribute("0")]
public sealed virtual T GetValue(Int32[] indices);
    public ClrValueType GetStructValue(int index);
    public ClrValueType GetStructValue(Int32[] indices);
    public ClrObject GetObjectValue(int index);
    public ClrObject GetObjectValue(Int32[] indices);
    [NullableContextAttribute("0")]
private T ReadValue(int index);
    [NullableContextAttribute("0")]
private T ReadValue(Int32[] indices);
    private ulong GetElementAddress(int elementSize, int index);
    private ulong GetElementAddress(int elementSize, Int32[] indices);
    [IsReadOnlyAttribute]
private int GetMultiDimensionalBound(int offset);
    private sealed virtual override IClrValue Microsoft.Diagnostics.Runtime.Interfaces.IClrArray.GetObjectValue(int index);
    private sealed virtual override IClrValue Microsoft.Diagnostics.Runtime.Interfaces.IClrArray.GetObjectValue(Int32[] indices);
    private sealed virtual override IClrValue Microsoft.Diagnostics.Runtime.Interfaces.IClrArray.GetStructValue(int index);
    private sealed virtual override IClrValue Microsoft.Diagnostics.Runtime.Interfaces.IClrArray.GetStructValue(Int32[] indices);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Microsoft.Diagnostics.Runtime.ClrDelegate : ValueType {
    internal static string DelegateType;
    [CompilerGeneratedAttribute]
private ClrObject <Object>k__BackingField;
    public bool HasMultipleTargets { get; }
    public ClrObject Object { get; }
    private IClrValue Microsoft.Diagnostics.Runtime.Interfaces.IClrDelegate.Object { get; }
    internal ClrDelegate(ClrObject obj);
    public sealed virtual bool get_HasMultipleTargets();
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public ClrObject get_Object();
    private sealed virtual override IClrValue Microsoft.Diagnostics.Runtime.Interfaces.IClrDelegate.get_Object();
    [NullableContextAttribute("2")]
public ClrDelegateTarget GetDelegateTarget();
    private bool Validate();
    [IteratorStateMachineAttribute("Microsoft.Diagnostics.Runtime.ClrDelegate/<EnumerateDelegateTargets>d__11")]
public IEnumerable`1<ClrDelegateTarget> EnumerateDelegateTargets();
    private sealed virtual override IEnumerable`1<IClrDelegateTarget> Microsoft.Diagnostics.Runtime.Interfaces.IClrDelegate.EnumerateDelegateTargets();
    [NullableContextAttribute("2")]
private sealed virtual override IClrDelegateTarget Microsoft.Diagnostics.Runtime.Interfaces.IClrDelegate.GetDelegateTarget();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Microsoft.Diagnostics.Runtime.ClrDelegateTarget : object {
    [CompilerGeneratedAttribute]
private ClrDelegate <Parent>k__BackingField;
    [CompilerGeneratedAttribute]
private ClrObject <TargetObject>k__BackingField;
    [CompilerGeneratedAttribute]
private ClrMethod <Method>k__BackingField;
    public ClrDelegate Parent { get; }
    public ClrObject TargetObject { get; }
    public ClrMethod Method { get; }
    private IClrMethod Microsoft.Diagnostics.Runtime.Interfaces.IClrDelegateTarget.Method { get; }
    private IClrDelegate Microsoft.Diagnostics.Runtime.Interfaces.IClrDelegateTarget.Parent { get; }
    private IClrValue Microsoft.Diagnostics.Runtime.Interfaces.IClrDelegateTarget.TargetObject { get; }
    internal ClrDelegateTarget(ClrDelegate del, ClrObject target, ClrMethod method);
    [CompilerGeneratedAttribute]
public ClrDelegate get_Parent();
    [CompilerGeneratedAttribute]
public ClrObject get_TargetObject();
    [CompilerGeneratedAttribute]
public ClrMethod get_Method();
    private sealed virtual override IClrMethod Microsoft.Diagnostics.Runtime.Interfaces.IClrDelegateTarget.get_Method();
    private sealed virtual override IClrDelegate Microsoft.Diagnostics.Runtime.Interfaces.IClrDelegateTarget.get_Parent();
    private sealed virtual override IClrValue Microsoft.Diagnostics.Runtime.Interfaces.IClrDelegateTarget.get_TargetObject();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Microsoft.Diagnostics.Runtime.ClrDiagnosticsException : Exception {
    public ClrDiagnosticsException(string message);
    public ClrDiagnosticsException(string message, Exception innerException);
    public ClrDiagnosticsException(string message, int hr);
    public virtual void GetObjectData(SerializationInfo info, StreamingContext context);
}
public enum Microsoft.Diagnostics.Runtime.ClrElementType : Enum {
    public int value__;
    public static ClrElementType Unknown;
    public static ClrElementType Void;
    public static ClrElementType Boolean;
    public static ClrElementType Char;
    public static ClrElementType Int8;
    public static ClrElementType UInt8;
    public static ClrElementType Int16;
    public static ClrElementType UInt16;
    public static ClrElementType Int32;
    public static ClrElementType UInt32;
    public static ClrElementType Int64;
    public static ClrElementType UInt64;
    public static ClrElementType Float;
    public static ClrElementType Double;
    public static ClrElementType String;
    public static ClrElementType Pointer;
    public static ClrElementType ByRef;
    public static ClrElementType Struct;
    public static ClrElementType Class;
    public static ClrElementType Var;
    public static ClrElementType Array;
    public static ClrElementType GenericInstantiation;
    public static ClrElementType NativeInt;
    public static ClrElementType NativeUInt;
    public static ClrElementType FunctionPointer;
    public static ClrElementType Object;
    public static ClrElementType MVar;
    public static ClrElementType SZArray;
}
[ExtensionAttribute]
internal static class Microsoft.Diagnostics.Runtime.ClrElementTypeExtensions : object {
    [ExtensionAttribute]
public static bool IsPrimitive(ClrElementType cet);
    [ExtensionAttribute]
public static bool IsValueType(ClrElementType cet);
    [ExtensionAttribute]
public static bool IsObjectReference(ClrElementType cet);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Microsoft.Diagnostics.Runtime.ClrEnum : object {
    [CompilerGeneratedAttribute]
private ClrType <Type>k__BackingField;
    [CompilerGeneratedAttribute]
private ClrElementType <ElementType>k__BackingField;
    [TupleElementNamesAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private ValueTuple`2[] _values;
    public ClrType Type { get; }
    private IClrType Microsoft.Diagnostics.Runtime.Interfaces.IClrEnum.Type { get; }
    public ClrElementType ElementType { get; }
    internal ClrEnum(ClrType type);
    [CompilerGeneratedAttribute]
public ClrType get_Type();
    private sealed virtual override IClrType Microsoft.Diagnostics.Runtime.Interfaces.IClrEnum.get_Type();
    [CompilerGeneratedAttribute]
public sealed virtual ClrElementType get_ElementType();
    [NullableContextAttribute("0")]
public sealed virtual T GetEnumValue(string name);
    public sealed virtual IEnumerable`1<string> GetEnumNames();
    public sealed virtual IEnumerable`1<ValueTuple`2<string, object>> EnumerateValues();
    private ValueTuple`2[] EnumerateValues(IAbstractMetadataReader import, ClrElementType& elementType);
    [NullableContextAttribute("2")]
private object GetValueForPointer(ClrElementType pdwCPlusTypeFlag, IntPtr ppValue);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
public class Microsoft.Diagnostics.Runtime.ClrException : object {
    private ClrObject _object;
    [CompilerGeneratedAttribute]
private ClrThread <Thread>k__BackingField;
    public ClrThread Thread { get; }
    public ulong Address { get; }
    [NullableAttribute("1")]
public ClrType Type { get; }
    public string Message { get; }
    public ClrException Inner { get; }
    public int HResult { get; }
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ImmutableArray`1<ClrStackFrame> StackTrace { get; }
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private ImmutableArray`1<IClrStackFrame> Microsoft.Diagnostics.Runtime.Interfaces.IClrException.StackTrace { get; }
    private IClrException Microsoft.Diagnostics.Runtime.Interfaces.IClrException.Inner { get; }
    private IClrThread Microsoft.Diagnostics.Runtime.Interfaces.IClrException.Thread { get; }
    [NullableAttribute("1")]
private IClrType Microsoft.Diagnostics.Runtime.Interfaces.IClrException.Type { get; }
    internal ClrException(ClrThread thread, ClrObject obj);
    [CompilerGeneratedAttribute]
public ClrThread get_Thread();
    public ClrObject AsObject();
    [NullableContextAttribute("1")]
private sealed virtual override IClrValue Microsoft.Diagnostics.Runtime.Interfaces.IClrException.AsObject();
    public sealed virtual ulong get_Address();
    [NullableContextAttribute("1")]
public ClrType get_Type();
    public sealed virtual string get_Message();
    public ClrException get_Inner();
    public sealed virtual int get_HResult();
    public ImmutableArray`1<ClrStackFrame> get_StackTrace();
    private sealed virtual override ImmutableArray`1<IClrStackFrame> Microsoft.Diagnostics.Runtime.Interfaces.IClrException.get_StackTrace();
    private sealed virtual override IClrException Microsoft.Diagnostics.Runtime.Interfaces.IClrException.get_Inner();
    private sealed virtual override IClrThread Microsoft.Diagnostics.Runtime.Interfaces.IClrException.get_Thread();
    [NullableContextAttribute("1")]
private sealed virtual override IClrType Microsoft.Diagnostics.Runtime.Interfaces.IClrException.get_Type();
    [NullableContextAttribute("1")]
public virtual string ToString();
    [NullableContextAttribute("1")]
private UInt32 GetStackTraceOffset(ClrType type);
    [NullableContextAttribute("1")]
private UInt32 GetInnerExceptionOffset(ClrType type);
    [NullableContextAttribute("1")]
private UInt32 GetHResultOffset(ClrType type);
    [NullableContextAttribute("1")]
private UInt32 GetMessageOffset(ClrType type);
    private ImmutableArray`1<ClrStackFrame> GetExceptionStackTrace();
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
public abstract class Microsoft.Diagnostics.Runtime.ClrField : object {
    private string _name;
    [NullableAttribute("1")]
internal IAbstractTypeHelpers _helpers;
    private ClrType _type;
    private int _attributes;
    [CompilerGeneratedAttribute]
private FieldInfo <FieldInfo>k__BackingField;
    [NullableAttribute("1")]
[CompilerGeneratedAttribute]
private ClrType <ContainingType>k__BackingField;
    internal FieldInfo FieldInfo { get; }
    [NullableAttribute("1")]
public ClrType ContainingType { get; }
    [NullableAttribute("1")]
private IClrType Microsoft.Diagnostics.Runtime.Interfaces.IClrField.ContainingType { get; }
    public string Name { get; }
    public int Token { get; }
    public ClrType Type { get; }
    private IClrType Microsoft.Diagnostics.Runtime.Interfaces.IClrField.Type { get; }
    public ClrElementType ElementType { get; }
    public bool IsPrimitive { get; }
    public bool IsValueType { get; }
    public bool IsObjectReference { get; }
    public int Size { get; }
    public FieldAttributes Attributes { get; }
    public int Offset { get; }
    [NullableContextAttribute("1")]
internal ClrField(ClrType containingType, ClrType type, IAbstractTypeHelpers helpers, FieldInfo data);
    [CompilerGeneratedAttribute]
internal FieldInfo get_FieldInfo();
    [ConditionalAttribute("DEBUG")]
private void DebugOnlyLoadLazyValues();
    [NullableContextAttribute("1")]
[CompilerGeneratedAttribute]
public ClrType get_ContainingType();
    [NullableContextAttribute("1")]
private sealed virtual override IClrType Microsoft.Diagnostics.Runtime.Interfaces.IClrField.get_ContainingType();
    public sealed virtual string get_Name();
    public sealed virtual int get_Token();
    public virtual ClrType get_Type();
    private void InitData(bool forName);
    private sealed virtual override IClrType Microsoft.Diagnostics.Runtime.Interfaces.IClrField.get_Type();
    public sealed virtual ClrElementType get_ElementType();
    public sealed virtual bool get_IsPrimitive();
    public sealed virtual bool get_IsValueType();
    public sealed virtual bool get_IsObjectReference();
    public sealed virtual int get_Size();
    public sealed virtual FieldAttributes get_Attributes();
    public sealed virtual int get_Offset();
    public virtual string ToString();
    internal static int GetSize(ClrType type, ClrElementType cet);
}
public enum Microsoft.Diagnostics.Runtime.ClrFlavor : Enum {
    public int value__;
    public static ClrFlavor Desktop;
    public static ClrFlavor Core;
    public static ClrFlavor NativeAOT;
}
public class Microsoft.Diagnostics.Runtime.ClrGenerationData : object {
    [CompilerGeneratedAttribute]
private ulong <StartSegment>k__BackingField;
    [CompilerGeneratedAttribute]
private ulong <AllocationStart>k__BackingField;
    [CompilerGeneratedAttribute]
private ulong <AllocationContextPointer>k__BackingField;
    [CompilerGeneratedAttribute]
private ulong <AllocationContextLimit>k__BackingField;
    public ulong StartSegment { get; }
    public ulong AllocationStart { get; }
    public ulong AllocationContextPointer { get; }
    public ulong AllocationContextLimit { get; }
    internal ClrGenerationData(GenerationInfo& generationData);
    [CompilerGeneratedAttribute]
public sealed virtual ulong get_StartSegment();
    [CompilerGeneratedAttribute]
public sealed virtual ulong get_AllocationStart();
    [CompilerGeneratedAttribute]
public sealed virtual ulong get_AllocationContextPointer();
    [CompilerGeneratedAttribute]
public sealed virtual ulong get_AllocationContextLimit();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[IsReadOnlyAttribute]
public class Microsoft.Diagnostics.Runtime.ClrGenericParameter : ValueType {
    [CompilerGeneratedAttribute]
private int <MetadataToken>k__BackingField;
    [CompilerGeneratedAttribute]
private int <Index>k__BackingField;
    [CompilerGeneratedAttribute]
private GenericParameterAttributes <Attributes>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    public int MetadataToken { get; }
    public int Index { get; }
    public GenericParameterAttributes Attributes { get; }
    public string Name { get; }
    public ClrGenericParameter(int metadataToken, int index, GenericParameterAttributes attributes, string name);
    [CompilerGeneratedAttribute]
public int get_MetadataToken();
    [CompilerGeneratedAttribute]
public int get_Index();
    [CompilerGeneratedAttribute]
public GenericParameterAttributes get_Attributes();
    [CompilerGeneratedAttribute]
public string get_Name();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Microsoft.Diagnostics.Runtime.ClrHandle : ClrRoot {
    [CompilerGeneratedAttribute]
private ClrHandleKind <HandleKind>k__BackingField;
    [CompilerGeneratedAttribute]
private UInt32 <ReferenceCount>k__BackingField;
    [CompilerGeneratedAttribute]
private ClrObject <Dependent>k__BackingField;
    [CompilerGeneratedAttribute]
private ClrAppDomain <AppDomain>k__BackingField;
    public ClrHandleKind HandleKind { get; }
    public UInt32 ReferenceCount { get; }
    public ClrObject Dependent { get; }
    public ClrAppDomain AppDomain { get; }
    public bool IsStrong { get; }
    private IClrAppDomain Microsoft.Diagnostics.Runtime.Interfaces.IClrHandle.AppDomain { get; }
    private IClrValue Microsoft.Diagnostics.Runtime.Interfaces.IClrHandle.Dependent { get; }
    internal ClrHandle(ClrAppDomain parent, ulong address, ClrObject obj, ClrHandleKind kind, UInt32 referenceCount);
    internal ClrHandle(ClrRuntime runtime, ClrHandleInfo& handle);
    [CompilerGeneratedAttribute]
public sealed virtual ClrHandleKind get_HandleKind();
    [CompilerGeneratedAttribute]
public virtual UInt32 get_ReferenceCount();
    [CompilerGeneratedAttribute]
public virtual ClrObject get_Dependent();
    [CompilerGeneratedAttribute]
public ClrAppDomain get_AppDomain();
    public sealed virtual bool get_IsStrong();
    private sealed virtual override IClrAppDomain Microsoft.Diagnostics.Runtime.Interfaces.IClrHandle.get_AppDomain();
    private sealed virtual override IClrValue Microsoft.Diagnostics.Runtime.Interfaces.IClrHandle.get_Dependent();
    public virtual string ToString();
}
public enum Microsoft.Diagnostics.Runtime.ClrHandleKind : Enum {
    public int value__;
    public static ClrHandleKind WeakShort;
    public static ClrHandleKind WeakLong;
    public static ClrHandleKind Strong;
    public static ClrHandleKind Pinned;
    public static ClrHandleKind RefCounted;
    public static ClrHandleKind Dependent;
    public static ClrHandleKind AsyncPinned;
    public static ClrHandleKind SizedRef;
    public static ClrHandleKind WeakWinRT;
}
[ExtensionAttribute]
internal static class Microsoft.Diagnostics.Runtime.ClrHandleKindExtension : object {
    [NullableContextAttribute("1")]
[ExtensionAttribute]
public static string GetName(ClrHandleKind kind);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Microsoft.Diagnostics.Runtime.ClrHeap : object {
    private static UInt32 SyncBlockHashOrSyncBlockIndex;
    private static UInt32 SyncBlockHashCodeIndex;
    private static int EnumerateBufferSize;
    private static int MaxGen2ObjectSize;
    private static int SyncBlockIndexBits;
    private static UInt32 SyncBlockIndexMask;
    private UInt32 _firstChar;
    private UInt32 _stringLength;
    private ClrTypeFactory _typeFactory;
    private IMemoryReader _memoryReader;
    [NullableAttribute("2")]
private Dictionary`2 modreq(System.Runtime.CompilerServices.IsVolatile) _allocationContexts;
    [TupleElementNamesAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private ValueTuple`2[] modreq(System.Runtime.CompilerServices.IsVolatile) _dependentHandles;
    [NullableAttribute("2")]
private SyncBlockContainer modreq(System.Runtime.CompilerServices.IsVolatile) _syncBlocks;
    [NullableAttribute("2")]
private ClrSegment modreq(System.Runtime.CompilerServices.IsVolatile) _currSegment;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private ArrayPool`1 modreq(System.Runtime.CompilerServices.IsVolatile) _objectCorruptionPool;
    private ulong _lastComFlags;
    [CompilerGeneratedAttribute]
private IAbstractHeap <Helpers>k__BackingField;
    [CompilerGeneratedAttribute]
private ClrRuntime <Runtime>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <CanWalkHeap>k__BackingField;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private ImmutableArray`1<ClrSubHeap> <SubHeaps>k__BackingField;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private ImmutableArray`1<ClrSegment> <Segments>k__BackingField;
    [CompilerGeneratedAttribute]
private ClrType <FreeType>k__BackingField;
    [CompilerGeneratedAttribute]
private ClrType <StringType>k__BackingField;
    [CompilerGeneratedAttribute]
private ClrType <ObjectType>k__BackingField;
    [CompilerGeneratedAttribute]
private ClrType <ExceptionType>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsServer>k__BackingField;
    private static UInt32 MarkBitPitch;
    private static UInt32 MarkWordWidth;
    private static UInt32 MarkWordSize;
    private static UInt32 DtGcPageSize;
    private static UInt32 CardWordWidth;
    internal ClrType ErrorType { get; }
    internal IAbstractHeap Helpers { get; }
    public ClrRuntime Runtime { get; }
    public bool CanWalkHeap { get; }
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ImmutableArray`1<ClrSubHeap> SubHeaps { get; }
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ImmutableArray`1<ClrSegment> Segments { get; }
    public ClrType FreeType { get; }
    public ClrType StringType { get; }
    public ClrType ObjectType { get; }
    public ClrType ExceptionType { get; }
    public bool IsServer { get; }
    private IClrType Microsoft.Diagnostics.Runtime.Interfaces.IClrHeap.ExceptionType { get; }
    private IClrType Microsoft.Diagnostics.Runtime.Interfaces.IClrHeap.FreeType { get; }
    private IClrType Microsoft.Diagnostics.Runtime.Interfaces.IClrHeap.ObjectType { get; }
    private IClrRuntime Microsoft.Diagnostics.Runtime.Interfaces.IClrHeap.Runtime { get; }
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private ImmutableArray`1<IClrSegment> Microsoft.Diagnostics.Runtime.Interfaces.IClrHeap.Segments { get; }
    private IClrType Microsoft.Diagnostics.Runtime.Interfaces.IClrHeap.StringType { get; }
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private ImmutableArray`1<IClrSubHeap> Microsoft.Diagnostics.Runtime.Interfaces.IClrHeap.SubHeaps { get; }
    private UInt32 CardSize { get; }
    internal ClrHeap(ClrRuntime runtime, IMemoryReader memoryReader, IAbstractHeap helpers, IAbstractTypeHelpers typeHelpers);
    internal ClrType get_ErrorType();
    [CompilerGeneratedAttribute]
internal IAbstractHeap get_Helpers();
    [CompilerGeneratedAttribute]
public ClrRuntime get_Runtime();
    [CompilerGeneratedAttribute]
public sealed virtual bool get_CanWalkHeap();
    [CompilerGeneratedAttribute]
public ImmutableArray`1<ClrSubHeap> get_SubHeaps();
    [CompilerGeneratedAttribute]
public ImmutableArray`1<ClrSegment> get_Segments();
    [CompilerGeneratedAttribute]
public ClrType get_FreeType();
    [CompilerGeneratedAttribute]
public ClrType get_StringType();
    [CompilerGeneratedAttribute]
public ClrType get_ObjectType();
    [CompilerGeneratedAttribute]
public ClrType get_ExceptionType();
    [CompilerGeneratedAttribute]
public sealed virtual bool get_IsServer();
    private sealed virtual override IClrType Microsoft.Diagnostics.Runtime.Interfaces.IClrHeap.get_ExceptionType();
    private sealed virtual override IClrType Microsoft.Diagnostics.Runtime.Interfaces.IClrHeap.get_FreeType();
    private sealed virtual override IClrType Microsoft.Diagnostics.Runtime.Interfaces.IClrHeap.get_ObjectType();
    private sealed virtual override IClrRuntime Microsoft.Diagnostics.Runtime.Interfaces.IClrHeap.get_Runtime();
    private sealed virtual override ImmutableArray`1<IClrSegment> Microsoft.Diagnostics.Runtime.Interfaces.IClrHeap.get_Segments();
    private sealed virtual override IClrType Microsoft.Diagnostics.Runtime.Interfaces.IClrHeap.get_StringType();
    private sealed virtual override ImmutableArray`1<IClrSubHeap> Microsoft.Diagnostics.Runtime.Interfaces.IClrHeap.get_SubHeaps();
    public ClrObject GetObject(ulong objRef);
    public ClrObject GetObject(ulong objRef, ClrType type);
    [NullableContextAttribute("2")]
public ClrType GetObjectType(ulong objRef);
    public IEnumerable`1<ClrObject> EnumerateObjects();
    [IteratorStateMachineAttribute("Microsoft.Diagnostics.Runtime.ClrHeap/<EnumerateObjects>d__67")]
public IEnumerable`1<ClrObject> EnumerateObjects(bool carefully);
    [IteratorStateMachineAttribute("Microsoft.Diagnostics.Runtime.ClrHeap/<EnumerateObjects>d__68")]
public IEnumerable`1<ClrObject> EnumerateObjects(MemoryRange range, bool carefully);
    internal IEnumerable`1<ClrObject> EnumerateObjects(ClrSegment segment, bool carefully);
    [NullableContextAttribute("2")]
public bool IsObjectCorrupted(ulong objAddr, ObjectCorruption& result);
    public bool FullyVerifyObject(ulong objAddr, IEnumerable`1& detectedCorruption);
    private void ReturnObjectCorruptionArray(ObjectCorruption[] result);
    private ObjectCorruption[] RentObjectCorruptionArray();
    [NullableContextAttribute("2")]
private sealed virtual override bool Microsoft.Diagnostics.Runtime.Interfaces.IClrHeap.IsObjectCorrupted(ulong obj, IObjectCorruption& result);
    private sealed virtual override bool Microsoft.Diagnostics.Runtime.Interfaces.IClrHeap.IsObjectCorrupted(IClrValue obj, IObjectCorruption& result);
    public IEnumerable`1<ObjectCorruption> VerifyHeap();
    private sealed virtual override IEnumerable`1<IObjectCorruption> Microsoft.Diagnostics.Runtime.Interfaces.IClrHeap.VerifyHeap();
    [IteratorStateMachineAttribute("Microsoft.Diagnostics.Runtime.ClrHeap/<VerifyHeap>d__78")]
public IEnumerable`1<ObjectCorruption> VerifyHeap(IEnumerable`1<ClrObject> objects);
    [IteratorStateMachineAttribute("Microsoft.Diagnostics.Runtime.ClrHeap/<Microsoft-Diagnostics-Runtime-Interfaces-IClrHeap-VerifyHeap>d__79")]
private sealed virtual override IEnumerable`1<IObjectCorruption> Microsoft.Diagnostics.Runtime.Interfaces.IClrHeap.VerifyHeap(IEnumerable`1<IClrValue> objects);
    [IteratorStateMachineAttribute("Microsoft.Diagnostics.Runtime.ClrHeap/<EnumerateObjects>d__80")]
internal IEnumerable`1<ClrObject> EnumerateObjects(ClrSegment segment, ulong startAddress, bool carefully);
    private static void SetMarkerIndex(ClrSegment segment, ulong obj);
    private static int GetMarkerIndex(ClrSegment segment, ulong startAddress);
    private static ulong GetValidObjectForAddress(ClrSegment segment, ulong address, bool previous);
    private ulong FindNextValidObject(ClrSegment segment, UInt32 pointerSize, ulong address, MemoryCache cache);
    public ClrObject FindNextObjectOnSegment(ulong address, bool carefully);
    public ClrObject FindPreviousObjectOnSegment(ulong address, bool carefully);
    private ulong SkipAllocationContext(ClrSegment seg, ulong address);
    private static ulong Align(ulong size, ClrSegment seg);
    private sealed virtual override IEnumerable`1<IClrRoot> Microsoft.Diagnostics.Runtime.Interfaces.IClrHeap.EnumerateRoots();
    [IteratorStateMachineAttribute("Microsoft.Diagnostics.Runtime.ClrHeap/<EnumerateRoots>d__91")]
public IEnumerable`1<ClrRoot> EnumerateRoots();
    [NullableContextAttribute("0")]
private ValueTuple`2<ulong, ClrObject> GetObjectAndAddress(ClrObject containing, string fieldName);
    [NullableContextAttribute("2")]
public ClrSegment GetSegmentByAddress(ulong address);
    public IEnumerable`1<ClrObject> EnumerateFinalizableObjects();
    public IEnumerable`1<ClrRoot> EnumerateFinalizerRoots();
    private sealed virtual override IEnumerable`1<IClrRoot> Microsoft.Diagnostics.Runtime.Interfaces.IClrHeap.EnumerateFinalizerRoots();
    [IteratorStateMachineAttribute("Microsoft.Diagnostics.Runtime.ClrHeap/<EnumerateAllocationContexts>d__97")]
public sealed virtual IEnumerable`1<MemoryRange> EnumerateAllocationContexts();
    public sealed virtual IEnumerable`1<SyncBlock> EnumerateSyncBlocks();
    [NullableContextAttribute("2")]
internal SyncBlock GetSyncBlock(ulong obj);
    private SyncBlockContainer GetSyncBlocks();
    [NullableContextAttribute("2")]
internal ClrThinLock GetThinlock(ulong address);
    public virtual string ToString();
    internal SyncBlockComFlags GetComFlags(ulong obj);
    internal ulong GetObjectSize(ulong objRef, ClrType type);
    [IteratorStateMachineAttribute("Microsoft.Diagnostics.Runtime.ClrHeap/<EnumerateObjectReferences>d__105")]
internal IEnumerable`1<ClrObject> EnumerateObjectReferences(ulong obj, ClrType type, bool carefully, bool considerDependantHandles);
    [IteratorStateMachineAttribute("Microsoft.Diagnostics.Runtime.ClrHeap/<EnumerateReferencesWithFields>d__106")]
internal IEnumerable`1<ClrReference> EnumerateReferencesWithFields(ulong obj, ClrType type, bool carefully, bool considerDependantHandles);
    [IteratorStateMachineAttribute("Microsoft.Diagnostics.Runtime.ClrHeap/<EnumerateReferenceAddresses>d__107")]
internal IEnumerable`1<ulong> EnumerateReferenceAddresses(ulong obj, ClrType type, bool carefully, bool considerDependantHandles);
    private Dictionary`2<ulong, ulong> GetAllocationContexts();
    private ValueTuple`2[] GetDependentHandles();
    [IteratorStateMachineAttribute("Microsoft.Diagnostics.Runtime.ClrHeap/<EnumerateFinalizers>d__110")]
private IEnumerable`1<ClrRoot> EnumerateFinalizers(IEnumerable`1<MemoryRange> memoryRanges);
    internal ClrType GetOrCreateTypeFromSignature(ClrModule module, SigParser sigParser, IEnumerable`1<ClrGenericParameter> typeParameters, IEnumerable`1<ClrGenericParameter> methodParameters);
    [NullableContextAttribute("2")]
public ClrType GetTypeByMethodTable(ulong methodTable);
    public ClrType GetTypeByName(string name);
    public ClrType GetTypeByName(ClrModule module, string name);
    private ClrType FindTypeName(ulong moduleAddress, IEnumerable`1<ValueTuple`2<ulong, int>> map, string name);
    [NullableContextAttribute("2")]
internal ClrException GetExceptionObject(ulong objAddress, ClrThread thread);
    private sealed virtual override IEnumerable`1<IClrValue> Microsoft.Diagnostics.Runtime.Interfaces.IClrHeap.EnumerateFinalizableObjects();
    private sealed virtual override IEnumerable`1<IClrValue> Microsoft.Diagnostics.Runtime.Interfaces.IClrHeap.EnumerateObjects(bool carefully);
    private sealed virtual override IEnumerable`1<IClrValue> Microsoft.Diagnostics.Runtime.Interfaces.IClrHeap.EnumerateObjects();
    private sealed virtual override IEnumerable`1<IClrValue> Microsoft.Diagnostics.Runtime.Interfaces.IClrHeap.EnumerateObjects(MemoryRange range, bool carefully);
    private sealed virtual override IClrValue Microsoft.Diagnostics.Runtime.Interfaces.IClrHeap.FindNextObjectOnSegment(ulong address, bool carefully);
    private sealed virtual override IClrValue Microsoft.Diagnostics.Runtime.Interfaces.IClrHeap.FindPreviousObjectOnSegment(ulong address, bool carefully);
    private sealed virtual override IClrValue Microsoft.Diagnostics.Runtime.Interfaces.IClrHeap.GetObject(ulong objRef);
    [NullableContextAttribute("2")]
private sealed virtual override IClrType Microsoft.Diagnostics.Runtime.Interfaces.IClrHeap.GetObjectType(ulong objRef);
    [NullableContextAttribute("2")]
private sealed virtual override IClrSegment Microsoft.Diagnostics.Runtime.Interfaces.IClrHeap.GetSegmentByAddress(ulong address);
    [NullableContextAttribute("2")]
private sealed virtual override IClrType Microsoft.Diagnostics.Runtime.Interfaces.IClrHeap.GetTypeByMethodTable(ulong methodTable);
    private sealed virtual override IClrType Microsoft.Diagnostics.Runtime.Interfaces.IClrHeap.GetTypeByName(string name);
    private sealed virtual override IClrType Microsoft.Diagnostics.Runtime.Interfaces.IClrHeap.GetTypeByName(IClrModule module, string name);
    [NullableContextAttribute("2")]
internal string ReadString(ulong stringPtr, int maxLength);
    private int VerifyObject(SyncBlockContainer syncBlocks, ClrSegment seg, ClrObject obj, Span`1<ObjectCorruption> result);
    private static bool AddCorruptionAndContinue(Span`1<ObjectCorruption> result, Int32& curr, ObjectCorruption objectCorruption);
    private bool ShouldVerifyMembers(ClrSegment seg, ClrObject obj);
    private bool FgcShouldConsiderObject(ClrSegment seg, ClrObject obj, bool considerBgcMark, bool checkCurrentSweep, bool checkSavedSweep);
    private UInt32 get_CardSize();
    private static void ShouldCheckBgcMark(ClrSegment seg, Boolean& considerBgcMark, Boolean& checkCurrentSweep, Boolean& checkSavedSweep);
    private bool BackgroundObjectMarked(ClrSubHeap heap, ClrObject obj);
    private bool MarkArrayMarked(ClrSubHeap heap, ClrObject obj);
    private static int MarkBitOf(ulong address);
    private static ulong MarkWordOf(ulong address);
    [NullableContextAttribute("0")]
[CompilerGeneratedAttribute]
private ClrSubHeap <.ctor>b__16_0(SubHeapInfo r);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Microsoft.Diagnostics.Runtime.ClrInfo : object {
    [CompilerGeneratedAttribute]
private DataTarget <DataTarget>k__BackingField;
    [CompilerGeneratedAttribute]
private IClrInfoProvider <ClrInfoProvider>k__BackingField;
    [CompilerGeneratedAttribute]
private Version <Version>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsSingleFile>k__BackingField;
    [CompilerGeneratedAttribute]
private ClrFlavor <Flavor>k__BackingField;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private ImmutableArray`1<DebugLibraryInfo> <DebuggingLibraries>k__BackingField;
    [CompilerGeneratedAttribute]
private ModuleInfo <ModuleInfo>k__BackingField;
    [CompilerGeneratedAttribute]
private int <IndexTimeStamp>k__BackingField;
    [CompilerGeneratedAttribute]
private int <IndexFileSize>k__BackingField;
    [NullableAttribute("0")]
[CompilerGeneratedAttribute]
private ImmutableArray`1<byte> <BuildId>k__BackingField;
    public DataTarget DataTarget { get; }
    internal IClrInfoProvider ClrInfoProvider { get; }
    private IDataTarget Microsoft.Diagnostics.Runtime.Interfaces.IClrInfo.DataTarget { get; }
    public Version Version { get; }
    public bool IsSingleFile { get; public set; }
    public ClrFlavor Flavor { get; public set; }
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ImmutableArray`1<DebugLibraryInfo> DebuggingLibraries { get; public set; }
    public ModuleInfo ModuleInfo { get; }
    public int IndexTimeStamp { get; public set; }
    public int IndexFileSize { get; public set; }
    [NullableAttribute("0")]
public ImmutableArray`1<byte> BuildId { get; public set; }
    internal ClrInfo(DataTarget dt, ModuleInfo module, Version clrVersion, IClrInfoProvider provider);
    [CompilerGeneratedAttribute]
public DataTarget get_DataTarget();
    [CompilerGeneratedAttribute]
internal IClrInfoProvider get_ClrInfoProvider();
    private sealed virtual override IDataTarget Microsoft.Diagnostics.Runtime.Interfaces.IClrInfo.get_DataTarget();
    [CompilerGeneratedAttribute]
public sealed virtual Version get_Version();
    [CompilerGeneratedAttribute]
public sealed virtual bool get_IsSingleFile();
    [CompilerGeneratedAttribute]
public void set_IsSingleFile(bool value);
    [CompilerGeneratedAttribute]
public sealed virtual ClrFlavor get_Flavor();
    [CompilerGeneratedAttribute]
public void set_Flavor(ClrFlavor value);
    [CompilerGeneratedAttribute]
public sealed virtual ImmutableArray`1<DebugLibraryInfo> get_DebuggingLibraries();
    [CompilerGeneratedAttribute]
public void set_DebuggingLibraries(ImmutableArray`1<DebugLibraryInfo> value);
    [CompilerGeneratedAttribute]
public sealed virtual ModuleInfo get_ModuleInfo();
    [CompilerGeneratedAttribute]
public sealed virtual int get_IndexTimeStamp();
    [CompilerGeneratedAttribute]
public void set_IndexTimeStamp(int value);
    [CompilerGeneratedAttribute]
public sealed virtual int get_IndexFileSize();
    [CompilerGeneratedAttribute]
public void set_IndexFileSize(int value);
    [NullableContextAttribute("0")]
[CompilerGeneratedAttribute]
public sealed virtual ImmutableArray`1<byte> get_BuildId();
    [NullableContextAttribute("0")]
[CompilerGeneratedAttribute]
public void set_BuildId(ImmutableArray`1<byte> value);
    public virtual string ToString();
    public ClrRuntime CreateRuntime(string dacPath);
    public ClrRuntime CreateRuntime(string dacPath, bool ignoreMismatch);
    public ClrRuntime CreateRuntime();
    private ClrRuntime CreateRuntimeWorker(string dacPath, bool ignoreMismatch);
    private sealed virtual override IClrRuntime Microsoft.Diagnostics.Runtime.Interfaces.IClrInfo.CreateRuntime();
    private sealed virtual override IClrRuntime Microsoft.Diagnostics.Runtime.Interfaces.IClrInfo.CreateRuntime(string dacPath);
    private sealed virtual override IClrRuntime Microsoft.Diagnostics.Runtime.Interfaces.IClrInfo.CreateRuntime(string dacPath, bool ignoreMismatch);
}
public class Microsoft.Diagnostics.Runtime.ClrInstanceField : ClrField {
    [NullableContextAttribute("1")]
internal ClrInstanceField(ClrType containingType, ClrType type, IAbstractTypeHelpers helpers, FieldInfo& data);
    public sealed virtual T Read(ulong objRef, bool interior);
    public ClrObject ReadObject(ulong objRef, bool interior);
    [NullableContextAttribute("1")]
private sealed virtual override IClrValue Microsoft.Diagnostics.Runtime.Interfaces.IClrInstanceField.ReadObject(ulong objRef, bool interior);
    public ClrValueType ReadStruct(ulong objRef, bool interior);
    [NullableContextAttribute("1")]
private sealed virtual override IClrValue Microsoft.Diagnostics.Runtime.Interfaces.IClrInstanceField.ReadStruct(ulong objRef, bool interior);
    [NullableContextAttribute("2")]
public sealed virtual string ReadString(ulong objRef, bool interior);
    public sealed virtual ulong GetAddress(ulong objRef);
    public sealed virtual ulong GetAddress(ulong objRef, bool interior);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
public class Microsoft.Diagnostics.Runtime.ClrInterface : object {
    [NullableAttribute("1")]
[CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    [CompilerGeneratedAttribute]
private ClrInterface <BaseInterface>k__BackingField;
    [NullableAttribute("1")]
public string Name { get; }
    public ClrInterface BaseInterface { get; }
    [NullableContextAttribute("1")]
public ClrInterface(string name, ClrInterface baseInterface);
    [NullableContextAttribute("1")]
[CompilerGeneratedAttribute]
public string get_Name();
    [CompilerGeneratedAttribute]
public ClrInterface get_BaseInterface();
    [NullableContextAttribute("1")]
public virtual string ToString();
    public virtual bool Equals(object obj);
    public sealed virtual bool Equals(ClrInterface other);
    public virtual int GetHashCode();
    public static bool op_Equality(ClrInterface left, ClrInterface right);
    public static bool op_Inequality(ClrInterface left, ClrInterface right);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Microsoft.Diagnostics.Runtime.ClrJitManager : object {
    [NullableAttribute("2")]
private IAbstractClrNativeHeaps _helpers;
    [CompilerGeneratedAttribute]
private ClrRuntime <Runtime>k__BackingField;
    [CompilerGeneratedAttribute]
private ulong <Address>k__BackingField;
    [CompilerGeneratedAttribute]
private CodeHeapKind <Kind>k__BackingField;
    public ClrRuntime Runtime { get; }
    private IClrRuntime Microsoft.Diagnostics.Runtime.Interfaces.IClrJitManager.Runtime { get; }
    public ulong Address { get; }
    public CodeHeapKind Kind { get; }
    internal ClrJitManager(ClrRuntime runtime, JitManagerInfo& info, IAbstractClrNativeHeaps helpers);
    [CompilerGeneratedAttribute]
public ClrRuntime get_Runtime();
    private sealed virtual override IClrRuntime Microsoft.Diagnostics.Runtime.Interfaces.IClrJitManager.get_Runtime();
    [CompilerGeneratedAttribute]
public sealed virtual ulong get_Address();
    [CompilerGeneratedAttribute]
public sealed virtual CodeHeapKind get_Kind();
    public sealed virtual IEnumerable`1<ClrNativeHeapInfo> EnumerateNativeHeaps();
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
public class Microsoft.Diagnostics.Runtime.ClrMethod : object {
    [NullableAttribute("1")]
private IAbstractTypeHelpers _helpers;
    private string _signature;
    private Nullable`1<MethodAttributes> _attributes;
    [CompilerGeneratedAttribute]
private ulong <MethodDesc>k__BackingField;
    [CompilerGeneratedAttribute]
private HotColdRegions <HotColdInfo>k__BackingField;
    [CompilerGeneratedAttribute]
private MethodCompilationType <CompilationType>k__BackingField;
    [CompilerGeneratedAttribute]
private int <MetadataToken>k__BackingField;
    [NullableAttribute("1")]
[CompilerGeneratedAttribute]
private ClrType <Type>k__BackingField;
    public ulong MethodDesc { get; }
    public string Name { get; }
    public string Signature { get; }
    public ulong NativeCode { get; }
    public HotColdRegions HotColdInfo { get; }
    public MethodCompilationType CompilationType { get; }
    [NullableAttribute("0")]
public ImmutableArray`1<ILToNativeMap> ILOffsetMap { get; }
    public int MetadataToken { get; }
    [NullableAttribute("1")]
public ClrType Type { get; }
    [NullableAttribute("1")]
private IClrType Microsoft.Diagnostics.Runtime.Interfaces.IClrMethod.Type { get; }
    public MethodAttributes Attributes { get; }
    public bool IsConstructor { get; }
    public bool IsClassConstructor { get; }
    [NullableContextAttribute("1")]
internal ClrMethod(IAbstractTypeHelpers helpers, ClrType type, MethodInfo& info);
    [CompilerGeneratedAttribute]
public sealed virtual ulong get_MethodDesc();
    public sealed virtual string get_Name();
    public sealed virtual string get_Signature();
    public sealed virtual ulong get_NativeCode();
    public sealed virtual int GetILOffset(ulong addr);
    public sealed virtual ILInfo GetILInfo();
    [CompilerGeneratedAttribute]
public sealed virtual HotColdRegions get_HotColdInfo();
    [CompilerGeneratedAttribute]
public sealed virtual MethodCompilationType get_CompilationType();
    [NullableContextAttribute("0")]
public sealed virtual ImmutableArray`1<ILToNativeMap> get_ILOffsetMap();
    [CompilerGeneratedAttribute]
public sealed virtual int get_MetadataToken();
    [NullableContextAttribute("1")]
[CompilerGeneratedAttribute]
public ClrType get_Type();
    [NullableContextAttribute("1")]
private sealed virtual override IClrType Microsoft.Diagnostics.Runtime.Interfaces.IClrMethod.get_Type();
    public sealed virtual MethodAttributes get_Attributes();
    public sealed virtual bool get_IsConstructor();
    public sealed virtual bool get_IsClassConstructor();
    public virtual bool Equals(object obj);
    public sealed virtual bool Equals(ClrMethod other);
    public virtual int GetHashCode();
    public static bool op_Equality(ClrMethod left, ClrMethod right);
    public static bool op_Inequality(ClrMethod left, ClrMethod right);
    public virtual string ToString();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Microsoft.Diagnostics.Runtime.ClrModule : object {
    private IAbstractModuleHelpers _helpers;
    [NullableAttribute("2")]
private IAbstractClrNativeHeaps _nativeHeapHelpers;
    [NullableAttribute("2")]
private IAbstractMetadataReader _metadata;
    private int _debugMode;
    [NullableAttribute("2")]
private PdbInfo _pdb;
    [TupleElementNamesAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private ValueTuple`2[] _typeDefMap;
    [TupleElementNamesAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private ValueTuple`2[] _typeRefMap;
    [NullableAttribute("2")]
private ClrHeap _heap;
    private ulong _moduleAddress;
    private Lazy`1<ClrModuleInfo> _moduleInfo;
    [CompilerGeneratedAttribute]
private IDataReader <DataReader>k__BackingField;
    [CompilerGeneratedAttribute]
private ClrAppDomain <AppDomain>k__BackingField;
    internal ClrModuleInfo ModuleInfo { get; }
    internal ClrHeap Heap { get; }
    internal IDataReader DataReader { get; }
    public ulong Address { get; }
    public ClrAppDomain AppDomain { get; }
    private IClrAppDomain Microsoft.Diagnostics.Runtime.Interfaces.IClrModule.AppDomain { get; }
    [NullableAttribute("2")]
public string AssemblyName { get; }
    public ulong AssemblyAddress { get; }
    [NullableAttribute("2")]
public string Name { get; }
    public bool IsDynamic { get; }
    public bool IsPEFile { get; }
    public ulong ImageBase { get; }
    public ModuleLayout Layout { get; }
    public ulong Size { get; }
    public ulong MetadataAddress { get; }
    public ulong MetadataLength { get; }
    [NullableAttribute("2")]
internal IAbstractMetadataReader MetadataReader { get; }
    public ulong ThunkHeap { get; }
    public ulong LoaderAllocator { get; }
    public DebuggingModes DebuggingMode { get; }
    [NullableAttribute("2")]
public PdbInfo Pdb { get; }
    internal ClrModule(ClrAppDomain domain, ulong moduleAddress, IAbstractModuleHelpers moduleHelpers, IAbstractClrNativeHeaps nativeHeapHelpers, IDataReader dataReader);
    internal ClrModuleInfo get_ModuleInfo();
    internal ClrHeap get_Heap();
    [CompilerGeneratedAttribute]
internal IDataReader get_DataReader();
    public sealed virtual ulong get_Address();
    [CompilerGeneratedAttribute]
public ClrAppDomain get_AppDomain();
    private sealed virtual override IClrAppDomain Microsoft.Diagnostics.Runtime.Interfaces.IClrModule.get_AppDomain();
    [NullableContextAttribute("2")]
public sealed virtual string get_AssemblyName();
    public sealed virtual ulong get_AssemblyAddress();
    [NullableContextAttribute("2")]
public sealed virtual string get_Name();
    public sealed virtual bool get_IsDynamic();
    public sealed virtual bool get_IsPEFile();
    public sealed virtual ulong get_ImageBase();
    public sealed virtual ModuleLayout get_Layout();
    public sealed virtual ulong get_Size();
    public sealed virtual ulong get_MetadataAddress();
    public sealed virtual ulong get_MetadataLength();
    [NullableContextAttribute("2")]
internal IAbstractMetadataReader get_MetadataReader();
    public sealed virtual ulong get_ThunkHeap();
    public sealed virtual ulong get_LoaderAllocator();
    public sealed virtual IEnumerable`1<ClrNativeHeapInfo> EnumerateThunkHeap();
    public sealed virtual IEnumerable`1<ClrNativeHeapInfo> EnumerateLoaderAllocatorHeaps();
    public sealed virtual DebuggingModes get_DebuggingMode();
    private int GetDebugAttribute();
    public sealed virtual IEnumerable`1<ValueTuple`2<ulong, int>> EnumerateTypeDefToMethodTableMap();
    public sealed virtual IEnumerable`1<ValueTuple`2<ulong, int>> EnumerateTypeRefToMethodTableMap();
    public ClrType GetTypeByName(string name);
    private sealed virtual override IClrType Microsoft.Diagnostics.Runtime.Interfaces.IClrModule.GetTypeByName(string name);
    [NullableContextAttribute("2")]
public virtual string ToString();
    [NullableContextAttribute("2")]
public sealed virtual PdbInfo get_Pdb();
    private ulong GetSize();
    private PEImage GetPEImage();
    [NullableContextAttribute("2")]
public virtual bool Equals(object obj);
    [NullableContextAttribute("2")]
public bool Equals(ClrModule other);
    [NullableContextAttribute("2")]
public sealed virtual bool Equals(IClrModule other);
    public virtual int GetHashCode();
    [NullableContextAttribute("2")]
public static bool op_Equality(ClrModule left, ClrModule right);
    [NullableContextAttribute("2")]
public static bool op_Inequality(ClrModule left, ClrModule right);
    [CompilerGeneratedAttribute]
private ClrModuleInfo <.ctor>b__17_0();
}
public class Microsoft.Diagnostics.Runtime.ClrNativeHeapInfo : object {
    [CompilerGeneratedAttribute]
private MemoryRange <MemoryRange>k__BackingField;
    [CompilerGeneratedAttribute]
private NativeHeapKind <Kind>k__BackingField;
    [CompilerGeneratedAttribute]
private ClrNativeHeapState <State>k__BackingField;
    [CompilerGeneratedAttribute]
private int <GCHeap>k__BackingField;
    public MemoryRange MemoryRange { get; }
    public NativeHeapKind Kind { get; }
    public ClrNativeHeapState State { get; }
    public int GCHeap { get; }
    public ClrNativeHeapInfo(MemoryRange memory, NativeHeapKind kind, ClrNativeHeapState state);
    public ClrNativeHeapInfo(MemoryRange memory, NativeHeapKind kind, ClrNativeHeapState state, int heap);
    [CompilerGeneratedAttribute]
public MemoryRange get_MemoryRange();
    [CompilerGeneratedAttribute]
public NativeHeapKind get_Kind();
    [CompilerGeneratedAttribute]
public ClrNativeHeapState get_State();
    [CompilerGeneratedAttribute]
public int get_GCHeap();
    [NullableContextAttribute("1")]
public virtual string ToString();
}
public enum Microsoft.Diagnostics.Runtime.ClrNativeHeapState : Enum {
    public int value__;
    public static ClrNativeHeapState None;
    public static ClrNativeHeapState Active;
    public static ClrNativeHeapState Inactive;
    public static ClrNativeHeapState RegionOfRegions;
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[IsReadOnlyAttribute]
public class Microsoft.Diagnostics.Runtime.ClrObject : ValueType {
    internal static string RuntimeTypeName;
    [NullableAttribute("2")]
private ClrType _type;
    [CompilerGeneratedAttribute]
private ulong <Address>k__BackingField;
    private IAbstractTypeHelpers Helpers { get; }
    private IDataReader DataReader { get; }
    public bool IsBoxedValue { get; }
    public bool IsException { get; }
    public ulong Address { get; }
    [NullableAttribute("2")]
public ClrType Type { get; }
    [NullableAttribute("2")]
private IClrType Microsoft.Diagnostics.Runtime.Interfaces.IClrValue.Type { get; }
    public bool IsFree { get; }
    public bool IsValid { get; }
    public bool IsNull { get; }
    public ulong Size { get; }
    [NullableAttribute("2")]
public SyncBlock SyncBlock { get; }
    public bool IsComClassFactory { get; }
    public bool HasComCallableWrapper { get; }
    public bool HasRuntimeCallableWrapper { get; }
    public bool ContainsPointers { get; }
    public bool IsArray { get; }
    public bool IsRuntimeType { get; }
    public bool IsDelegate { get; }
    [NullableContextAttribute("2")]
internal ClrObject(ulong address, ClrType type);
    private IAbstractTypeHelpers get_Helpers();
    private IDataReader get_DataReader();
    public IEnumerable`1<ClrObject> EnumerateReferences(bool carefully, bool considerDependantHandles);
    public IEnumerable`1<ClrReference> EnumerateReferencesWithFields(bool carefully, bool considerDependantHandles);
    public sealed virtual IEnumerable`1<ulong> EnumerateReferenceAddresses(bool carefully, bool considerDependantHandles);
    public sealed virtual bool get_IsBoxedValue();
    [NullableContextAttribute("0")]
public sealed virtual T ReadBoxedValue();
    public sealed virtual bool get_IsException();
    [NullableContextAttribute("2")]
public ClrException AsException();
    [CompilerGeneratedAttribute]
public sealed virtual ulong get_Address();
    [NullableContextAttribute("2")]
public ClrType get_Type();
    [NullableContextAttribute("2")]
private sealed virtual override IClrType Microsoft.Diagnostics.Runtime.Interfaces.IClrValue.get_Type();
    public sealed virtual bool get_IsFree();
    public sealed virtual bool get_IsValid();
    public sealed virtual bool get_IsNull();
    public sealed virtual ulong get_Size();
    [NullableContextAttribute("2")]
public sealed virtual SyncBlock get_SyncBlock();
    [NullableContextAttribute("2")]
public ClrThinLock GetThinLock();
    public sealed virtual bool get_IsComClassFactory();
    public sealed virtual bool get_HasComCallableWrapper();
    public sealed virtual bool get_HasRuntimeCallableWrapper();
    [NullableContextAttribute("2")]
public ComCallableWrapper GetComCallableWrapper();
    [NullableContextAttribute("2")]
public RuntimeCallableWrapper GetRuntimeCallableWrapper();
    public sealed virtual bool get_ContainsPointers();
    public sealed virtual bool get_IsArray();
    public ClrArray AsArray();
    private sealed virtual override IClrArray Microsoft.Diagnostics.Runtime.Interfaces.IClrValue.AsArray();
    [NullableContextAttribute("2")]
public static string op_Explicit(ClrObject obj);
    public static ulong op_Implicit(ClrObject clrObject);
    public bool TryReadObjectField(string fieldName, ClrObject& result);
    public sealed virtual bool TryReadStringField(string fieldName, Nullable`1<int> maxLength, String& result);
    public ClrObject ReadObjectField(string fieldName);
    public ClrValueType ReadValueTypeField(string fieldName);
    public bool TryReadValueTypeField(string fieldName, ClrValueType& result);
    [NullableContextAttribute("0")]
public sealed virtual T ReadField(string fieldName);
    [NullableContextAttribute("0")]
public sealed virtual bool TryReadField(string fieldName, T& result);
    public sealed virtual bool get_IsRuntimeType();
    [NullableContextAttribute("2")]
public ClrType AsRuntimeType();
    public sealed virtual bool get_IsDelegate();
    public ClrDelegate AsDelegate();
    private sealed virtual override IClrDelegate Microsoft.Diagnostics.Runtime.Interfaces.IClrValue.AsDelegate();
    public sealed virtual string ReadStringField(string fieldName, int maxLength);
    [NullableContextAttribute("2")]
public sealed virtual string AsString(int maxLength);
    private ulong GetFieldAddress(string fieldName, ClrElementType element, string typeName);
    private ClrType GetTypeOrThrow();
    public sealed virtual bool Equals(ClrObject other);
    public sealed virtual bool Equals(ClrValueType other);
    [NullableContextAttribute("2")]
public sealed virtual bool Equals(IClrValue other);
    [NullableContextAttribute("2")]
public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public static bool op_Equality(ClrObject left, ClrObject right);
    public static bool op_Inequality(ClrObject left, ClrObject right);
    public virtual string ToString();
    [NullableContextAttribute("2")]
private sealed virtual override IClrException Microsoft.Diagnostics.Runtime.Interfaces.IClrValue.AsException();
    [NullableContextAttribute("2")]
private sealed virtual override IClrType Microsoft.Diagnostics.Runtime.Interfaces.IClrValue.AsRuntimeType();
    private sealed virtual override IEnumerable`1<IClrValue> Microsoft.Diagnostics.Runtime.Interfaces.IClrValue.EnumerateReferences(bool carefully, bool considerDependantHandles);
    private sealed virtual override IEnumerable`1<IClrReference> Microsoft.Diagnostics.Runtime.Interfaces.IClrValue.EnumerateReferencesWithFields(bool carefully, bool considerDependantHandles);
    [NullableContextAttribute("2")]
private sealed virtual override IComCallableWrapper Microsoft.Diagnostics.Runtime.Interfaces.IClrValue.GetComCallableWrapper();
    [NullableContextAttribute("2")]
private sealed virtual override IRuntimeCallableWrapper Microsoft.Diagnostics.Runtime.Interfaces.IClrValue.GetRuntimeCallableWrapper();
    private sealed virtual override IClrValue Microsoft.Diagnostics.Runtime.Interfaces.IClrValue.ReadObjectField(string fieldName);
    private sealed virtual override IClrValue Microsoft.Diagnostics.Runtime.Interfaces.IClrValue.ReadValueTypeField(string fieldName);
    private sealed virtual override bool Microsoft.Diagnostics.Runtime.Interfaces.IClrValue.TryReadObjectField(string fieldName, IClrValue& result);
    private sealed virtual override bool Microsoft.Diagnostics.Runtime.Interfaces.IClrValue.TryReadValueTypeField(string fieldName, IClrValue& result);
}
public class Microsoft.Diagnostics.Runtime.ClrOutOfMemoryInfo : object {
    [CompilerGeneratedAttribute]
private OutOfMemoryReason <Reason>k__BackingField;
    [CompilerGeneratedAttribute]
private GetMemoryFailureReason <GetMemoryFailure>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsLargeObjectHeap>k__BackingField;
    [CompilerGeneratedAttribute]
private ulong <AllocSize>k__BackingField;
    [CompilerGeneratedAttribute]
private ulong <AvailablePageFileMB>k__BackingField;
    [CompilerGeneratedAttribute]
private ulong <GCIndex>k__BackingField;
    [CompilerGeneratedAttribute]
private ulong <Size>k__BackingField;
    public OutOfMemoryReason Reason { get; }
    public GetMemoryFailureReason GetMemoryFailure { get; }
    public bool IsLargeObjectHeap { get; }
    public ulong AllocSize { get; }
    public ulong AvailablePageFileMB { get; }
    public ulong GCIndex { get; }
    public ulong Size { get; }
    internal ClrOutOfMemoryInfo(OomInfo& oomData);
    [CompilerGeneratedAttribute]
public sealed virtual OutOfMemoryReason get_Reason();
    [CompilerGeneratedAttribute]
public sealed virtual GetMemoryFailureReason get_GetMemoryFailure();
    [CompilerGeneratedAttribute]
public sealed virtual bool get_IsLargeObjectHeap();
    [CompilerGeneratedAttribute]
public sealed virtual ulong get_AllocSize();
    [CompilerGeneratedAttribute]
public sealed virtual ulong get_AvailablePageFileMB();
    [CompilerGeneratedAttribute]
public sealed virtual ulong get_GCIndex();
    [CompilerGeneratedAttribute]
public sealed virtual ulong get_Size();
}
public class Microsoft.Diagnostics.Runtime.ClrRcwCleanupData : object {
    [CompilerGeneratedAttribute]
private ulong <Rcw>k__BackingField;
    [CompilerGeneratedAttribute]
private ulong <Context>k__BackingField;
    [CompilerGeneratedAttribute]
private ulong <Thread>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsFreeThreaded>k__BackingField;
    public ulong Rcw { get; }
    public ulong Context { get; }
    public ulong Thread { get; }
    public bool IsFreeThreaded { get; }
    public ClrRcwCleanupData(ulong rcw, ulong context, ulong thread, bool isFreeThreaded);
    [CompilerGeneratedAttribute]
public ulong get_Rcw();
    [CompilerGeneratedAttribute]
public ulong get_Context();
    [CompilerGeneratedAttribute]
public ulong get_Thread();
    [CompilerGeneratedAttribute]
public bool get_IsFreeThreaded();
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
[IsReadOnlyAttribute]
public class Microsoft.Diagnostics.Runtime.ClrReference : ValueType {
    private static ulong OffsetFlag;
    private static ulong DependentFlag;
    private ulong _offsetOrHandle;
    [CompilerGeneratedAttribute]
private ClrObject <Object>k__BackingField;
    [CompilerGeneratedAttribute]
private ClrInstanceField <Field>k__BackingField;
    public ClrObject Object { get; }
    public int Offset { get; }
    public Nullable`1<ClrReference> InnerField { get; }
    public ClrInstanceField Field { get; }
    public bool IsDependentHandle { get; }
    public bool IsField { get; }
    public bool IsArrayElement { get; }
    private IClrInstanceField Microsoft.Diagnostics.Runtime.Interfaces.IClrReference.Field { get; }
    private IClrReference Microsoft.Diagnostics.Runtime.Interfaces.IClrReference.InnerField { get; }
    [NullableAttribute("1")]
private IClrValue Microsoft.Diagnostics.Runtime.Interfaces.IClrReference.Object { get; }
    private ClrReference(ClrObject obj, ClrInstanceField field, ulong offsetOrHandleValue);
    [CompilerGeneratedAttribute]
public ClrObject get_Object();
    public sealed virtual int get_Offset();
    public Nullable`1<ClrReference> get_InnerField();
    [CompilerGeneratedAttribute]
public ClrInstanceField get_Field();
    public sealed virtual bool get_IsDependentHandle();
    public sealed virtual bool get_IsField();
    public sealed virtual bool get_IsArrayElement();
    private sealed virtual override IClrInstanceField Microsoft.Diagnostics.Runtime.Interfaces.IClrReference.get_Field();
    private sealed virtual override IClrReference Microsoft.Diagnostics.Runtime.Interfaces.IClrReference.get_InnerField();
    [NullableContextAttribute("1")]
private sealed virtual override IClrValue Microsoft.Diagnostics.Runtime.Interfaces.IClrReference.get_Object();
    public static ClrReference CreateFromDependentHandle(ClrObject reference);
    [NullableContextAttribute("1")]
public static ClrReference CreateFromFieldOrArray(ClrObject reference, ClrType containingType, int offset);
    private static ClrInstanceField FindField(ImmutableArray`1<ClrInstanceField> fields, int offset);
    [NullableContextAttribute("1")]
public virtual string ToString();
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
public class Microsoft.Diagnostics.Runtime.ClrRoot : object {
    [CompilerGeneratedAttribute]
private ulong <Address>k__BackingField;
    [CompilerGeneratedAttribute]
private ClrObject <Object>k__BackingField;
    [CompilerGeneratedAttribute]
private ClrRootKind <RootKind>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsInterior>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsPinned>k__BackingField;
    public ulong Address { get; }
    public ClrObject Object { get; }
    [NullableAttribute("1")]
private IClrValue Microsoft.Diagnostics.Runtime.Interfaces.IClrRoot.Object { get; }
    public ClrRootKind RootKind { get; protected set; }
    public bool IsInterior { get; }
    public bool IsPinned { get; }
    private IClrStackFrame Microsoft.Diagnostics.Runtime.Interfaces.IClrRoot.StackFrame { get; }
    private string Microsoft.Diagnostics.Runtime.Interfaces.IClrRoot.RegisterName { get; }
    private int Microsoft.Diagnostics.Runtime.Interfaces.IClrRoot.RegisterOffset { get; }
    public ClrRoot(ulong address, ClrObject obj, ClrRootKind rootKind, bool isInterior, bool isPinned);
    public sealed virtual bool Equals(IClrRoot other);
    public sealed virtual bool Equals(ClrRoot other);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    [CompilerGeneratedAttribute]
public sealed virtual ulong get_Address();
    [CompilerGeneratedAttribute]
public virtual ClrObject get_Object();
    [NullableContextAttribute("1")]
private sealed virtual override IClrValue Microsoft.Diagnostics.Runtime.Interfaces.IClrRoot.get_Object();
    [CompilerGeneratedAttribute]
public sealed virtual ClrRootKind get_RootKind();
    [CompilerGeneratedAttribute]
protected void set_RootKind(ClrRootKind value);
    [CompilerGeneratedAttribute]
public sealed virtual bool get_IsInterior();
    [CompilerGeneratedAttribute]
public sealed virtual bool get_IsPinned();
    private sealed virtual override IClrStackFrame Microsoft.Diagnostics.Runtime.Interfaces.IClrRoot.get_StackFrame();
    private sealed virtual override string Microsoft.Diagnostics.Runtime.Interfaces.IClrRoot.get_RegisterName();
    private sealed virtual override int Microsoft.Diagnostics.Runtime.Interfaces.IClrRoot.get_RegisterOffset();
}
public enum Microsoft.Diagnostics.Runtime.ClrRootKind : Enum {
    public int value__;
    public static ClrRootKind None;
    public static ClrRootKind FinalizerQueue;
    public static ClrRootKind StrongHandle;
    public static ClrRootKind PinnedHandle;
    public static ClrRootKind Stack;
    public static ClrRootKind RefCountedHandle;
    public static ClrRootKind AsyncPinnedHandle;
    public static ClrRootKind SizedRefHandle;
}
[ExtensionAttribute]
internal static class Microsoft.Diagnostics.Runtime.ClrRootKindExtension : object {
    [NullableContextAttribute("1")]
[ExtensionAttribute]
public static string GetName(ClrRootKind kind);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Microsoft.Diagnostics.Runtime.ClrRuntime : object {
    private IServiceProvider _services;
    [NullableAttribute("2")]
private ClrHeap modreq(System.Runtime.CompilerServices.IsVolatile) _heap;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private ImmutableArray`1<ClrThread> _threads;
    [NullableAttribute("2")]
private DomainAndModules modreq(System.Runtime.CompilerServices.IsVolatile) _domainAndModules;
    [NullableAttribute("2")]
private IAbstractRuntime _runtime;
    [NullableAttribute("2")]
private IAbstractComHelpers _comHelpers;
    [NullableAttribute("2")]
private IAbstractMethodLocator _methodLocator;
    [NullableAttribute("2")]
private IAbstractDacController _controller;
    [CompilerGeneratedAttribute]
private ClrInfo <ClrInfo>k__BackingField;
    [CompilerGeneratedAttribute]
private DataTarget <DataTarget>k__BackingField;
    public bool CanFlushData { get; }
    public ClrInfo ClrInfo { get; }
    public DataTarget DataTarget { get; }
    public bool IsThreadSafe { get; }
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ImmutableArray`1<ClrAppDomain> AppDomains { get; }
    [NullableAttribute("2")]
public ClrAppDomain SystemDomain { get; }
    [NullableAttribute("2")]
public ClrAppDomain SharedDomain { get; }
    public ClrModule BaseClassLibrary { get; }
    [NullableAttribute("2")]
public ClrThreadPool ThreadPool { get; }
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ImmutableArray`1<ClrThread> Threads { get; }
    public ClrHeap Heap { get; }
    [NullableAttribute("2")]
private IClrThreadPool Microsoft.Diagnostics.Runtime.Interfaces.IClrRuntime.ThreadPool { get; }
    private IClrHeap Microsoft.Diagnostics.Runtime.Interfaces.IClrRuntime.Heap { get; }
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private ImmutableArray`1<IClrAppDomain> Microsoft.Diagnostics.Runtime.Interfaces.IClrRuntime.AppDomains { get; }
    [NullableAttribute("2")]
private IClrAppDomain Microsoft.Diagnostics.Runtime.Interfaces.IClrRuntime.SharedDomain { get; }
    [NullableAttribute("2")]
private IClrAppDomain Microsoft.Diagnostics.Runtime.Interfaces.IClrRuntime.SystemDomain { get; }
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private ImmutableArray`1<IClrThread> Microsoft.Diagnostics.Runtime.Interfaces.IClrRuntime.Threads { get; }
    private IClrInfo Microsoft.Diagnostics.Runtime.Interfaces.IClrRuntime.ClrInfo { get; }
    private IDataTarget Microsoft.Diagnostics.Runtime.Interfaces.IClrRuntime.DataTarget { get; }
    private IClrModule Microsoft.Diagnostics.Runtime.Interfaces.IClrRuntime.BaseClassLibrary { get; }
    internal ClrRuntime(ClrInfo clrInfo, IServiceProvider services);
    public sealed virtual void FlushCachedData();
    public bool get_CanFlushData();
    internal T GetService();
    internal T GetServiceOrThrow();
    private IAbstractRuntime GetDacRuntime();
    [NullableContextAttribute("2")]
private IAbstractComHelpers TryGetComHelpers();
    [NullableContextAttribute("2")]
private IAbstractMethodLocator TryGetMethodLocator();
    [CompilerGeneratedAttribute]
public ClrInfo get_ClrInfo();
    [CompilerGeneratedAttribute]
public DataTarget get_DataTarget();
    public sealed virtual bool get_IsThreadSafe();
    public ImmutableArray`1<ClrAppDomain> get_AppDomains();
    [NullableContextAttribute("2")]
public ClrAppDomain get_SystemDomain();
    [NullableContextAttribute("2")]
public ClrAppDomain get_SharedDomain();
    public ClrModule get_BaseClassLibrary();
    [NullableContextAttribute("2")]
public ClrThreadPool get_ThreadPool();
    public ImmutableArray`1<ClrThread> get_Threads();
    [NullableContextAttribute("2")]
public ClrAppDomain GetAppDomainByAddress(ulong appDomain);
    [NullableContextAttribute("2")]
public ClrMethod GetMethodByHandle(ulong methodHandle);
    [NullableContextAttribute("2")]
public ClrType GetTypeByMethodTable(ulong methodTable);
    public IEnumerable`1<ClrHandle> EnumerateHandles();
    public ClrHeap get_Heap();
    [NullableContextAttribute("2")]
private sealed virtual override IClrThreadPool Microsoft.Diagnostics.Runtime.Interfaces.IClrRuntime.get_ThreadPool();
    private sealed virtual override IClrHeap Microsoft.Diagnostics.Runtime.Interfaces.IClrRuntime.get_Heap();
    private sealed virtual override ImmutableArray`1<IClrAppDomain> Microsoft.Diagnostics.Runtime.Interfaces.IClrRuntime.get_AppDomains();
    [NullableContextAttribute("2")]
private sealed virtual override IClrAppDomain Microsoft.Diagnostics.Runtime.Interfaces.IClrRuntime.get_SharedDomain();
    [NullableContextAttribute("2")]
private sealed virtual override IClrAppDomain Microsoft.Diagnostics.Runtime.Interfaces.IClrRuntime.get_SystemDomain();
    private sealed virtual override ImmutableArray`1<IClrThread> Microsoft.Diagnostics.Runtime.Interfaces.IClrRuntime.get_Threads();
    private sealed virtual override IClrInfo Microsoft.Diagnostics.Runtime.Interfaces.IClrRuntime.get_ClrInfo();
    private sealed virtual override IDataTarget Microsoft.Diagnostics.Runtime.Interfaces.IClrRuntime.get_DataTarget();
    private sealed virtual override IClrModule Microsoft.Diagnostics.Runtime.Interfaces.IClrRuntime.get_BaseClassLibrary();
    [NullableContextAttribute("2")]
public ClrMethod GetMethodByInstructionPointer(ulong ip);
    public IEnumerable`1<ClrModule> EnumerateModules();
    [IteratorStateMachineAttribute("Microsoft.Diagnostics.Runtime.ClrRuntime/<EnumerateClrNativeHeaps>d__63")]
public sealed virtual IEnumerable`1<ClrNativeHeapInfo> EnumerateClrNativeHeaps();
    public sealed virtual IEnumerable`1<ClrSyncBlockCleanupData> EnumerateSyncBlockCleanupData();
    public sealed virtual IEnumerable`1<ClrRcwCleanupData> EnumerateRcwCleanupData();
    [NullableContextAttribute("2")]
internal RuntimeCallableWrapper CreateRCWForObject(ulong obj);
    [NullableContextAttribute("2")]
internal ComCallableWrapper CreateCCWForObject(ulong obj);
    public IEnumerable`1<ClrJitManager> EnumerateJitManagers();
    [NullableContextAttribute("2")]
public sealed virtual string GetJitHelperFunctionName(ulong address);
    public sealed virtual void Dispose();
    private DomainAndModules GetAppDomainData();
    private DomainAndModules InitAppDomainData();
    private sealed virtual override IEnumerable`1<IClrRoot> Microsoft.Diagnostics.Runtime.Interfaces.IClrRuntime.EnumerateHandles();
    private sealed virtual override IEnumerable`1<IClrJitManager> Microsoft.Diagnostics.Runtime.Interfaces.IClrRuntime.EnumerateJitManagers();
    private sealed virtual override IEnumerable`1<IClrModule> Microsoft.Diagnostics.Runtime.Interfaces.IClrRuntime.EnumerateModules();
    [NullableContextAttribute("2")]
private sealed virtual override IClrMethod Microsoft.Diagnostics.Runtime.Interfaces.IClrRuntime.GetMethodByHandle(ulong methodHandle);
    [NullableContextAttribute("2")]
private sealed virtual override IClrMethod Microsoft.Diagnostics.Runtime.Interfaces.IClrRuntime.GetMethodByInstructionPointer(ulong ip);
    [NullableContextAttribute("2")]
private sealed virtual override IClrType Microsoft.Diagnostics.Runtime.Interfaces.IClrRuntime.GetTypeByMethodTable(ulong methodTable);
    [NullableContextAttribute("0")]
[CompilerGeneratedAttribute]
private ClrHandle <EnumerateHandles>b__40_0(ClrHandleInfo r);
    [NullableContextAttribute("0")]
[CompilerGeneratedAttribute]
private ClrJitManager <EnumerateJitManagers>b__68_0(JitManagerInfo info);
}
internal class Microsoft.Diagnostics.Runtime.ClrRuntimeInfo : ValueType {
    [NullableAttribute("1")]
public static string SymbolValue;
    public static int SignatureValueLength;
    [FixedBufferAttribute("System.Byte", "18")]
private <_signature>e__FixedBuffer _signature;
    private int _version;
    [FixedBufferAttribute("System.Byte", "24")]
private <_runtimeModuleIndex>e__FixedBuffer _runtimeModuleIndex;
    [FixedBufferAttribute("System.Byte", "24")]
private <_dacModuleIndex>e__FixedBuffer _dacModuleIndex;
    [FixedBufferAttribute("System.Byte", "24")]
private <_dbiModuleIndex>e__FixedBuffer _dbiModuleIndex;
    public bool IsValid { get; }
    [TupleElementNamesAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ValueTuple`2<int, int> RuntimePEProperties { get; }
    [TupleElementNamesAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ValueTuple`2<int, int> DacPEProperties { get; }
    [TupleElementNamesAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ValueTuple`2<int, int> DbiPEProperties { get; }
    public ImmutableArray`1<byte> RuntimeBuildId { get; }
    public ImmutableArray`1<byte> DacBuildId { get; }
    public ImmutableArray`1<byte> DbiBuildId { get; }
    [NullableContextAttribute("1")]
public static bool TryReadClrRuntimeInfo(IDataReader reader, ulong address, ClrRuntimeInfo& header, Version& version);
    public bool get_IsValid();
    public ValueTuple`2<int, int> get_RuntimePEProperties();
    public ValueTuple`2<int, int> get_DacPEProperties();
    public ValueTuple`2<int, int> get_DbiPEProperties();
    private ValueTuple`2<int, int> GetProperties(Byte* ptr);
    public ImmutableArray`1<byte> get_RuntimeBuildId();
    public ImmutableArray`1<byte> get_DacBuildId();
    public ImmutableArray`1<byte> get_DbiBuildId();
    private ImmutableArray`1<byte> GetBuildId(Byte* ptr);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Microsoft.Diagnostics.Runtime.ClrSegment : object {
    [NullableAttribute("2")]
private UInt32[] _markers;
    [CompilerGeneratedAttribute]
private ulong <Address>k__BackingField;
    [CompilerGeneratedAttribute]
private MemoryRange <ObjectRange>k__BackingField;
    [CompilerGeneratedAttribute]
private ClrSubHeap <SubHeap>k__BackingField;
    [CompilerGeneratedAttribute]
private ClrSegmentFlags <Flags>k__BackingField;
    [CompilerGeneratedAttribute]
private MemoryRange <ReservedMemory>k__BackingField;
    [CompilerGeneratedAttribute]
private MemoryRange <CommittedMemory>k__BackingField;
    [CompilerGeneratedAttribute]
private GCSegmentKind <Kind>k__BackingField;
    [CompilerGeneratedAttribute]
private MemoryRange <Generation0>k__BackingField;
    [CompilerGeneratedAttribute]
private MemoryRange <Generation1>k__BackingField;
    [CompilerGeneratedAttribute]
private MemoryRange <Generation2>k__BackingField;
    [CompilerGeneratedAttribute]
private ulong <BackgroundAllocated>k__BackingField;
    public ulong Address { get; internal set; }
    public MemoryRange ObjectRange { get; internal set; }
    public ulong Start { get; }
    public ulong End { get; }
    public ulong Length { get; }
    public ClrSubHeap SubHeap { get; }
    public ClrSegmentFlags Flags { get; internal set; }
    public MemoryRange ReservedMemory { get; internal set; }
    public MemoryRange CommittedMemory { get; internal set; }
    public ulong FirstObjectAddress { get; }
    public GCSegmentKind Kind { get; internal set; }
    public bool IsPinned { get; }
    public MemoryRange Generation0 { get; internal set; }
    public MemoryRange Generation1 { get; internal set; }
    public MemoryRange Generation2 { get; internal set; }
    internal ulong MaxObjectSize { get; }
    internal UInt32[] ObjectMarkers { get; }
    private IClrSubHeap Microsoft.Diagnostics.Runtime.Interfaces.IClrSegment.SubHeap { get; }
    internal ulong BackgroundAllocated { get; internal set; }
    internal ClrSegment(ClrSubHeap subHeap, SegmentInfo& segInfo);
    [NullableContextAttribute("2")]
public sealed virtual bool Equals(IClrSegment other);
    [NullableContextAttribute("2")]
public sealed virtual bool Equals(ClrSegment other);
    [NullableContextAttribute("2")]
public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    [CompilerGeneratedAttribute]
public sealed virtual ulong get_Address();
    [CompilerGeneratedAttribute]
internal void set_Address(ulong value);
    [CompilerGeneratedAttribute]
public sealed virtual MemoryRange get_ObjectRange();
    [CompilerGeneratedAttribute]
internal void set_ObjectRange(MemoryRange value);
    public sealed virtual ulong get_Start();
    public sealed virtual ulong get_End();
    public sealed virtual ulong get_Length();
    [CompilerGeneratedAttribute]
public ClrSubHeap get_SubHeap();
    [CompilerGeneratedAttribute]
public sealed virtual ClrSegmentFlags get_Flags();
    [CompilerGeneratedAttribute]
internal void set_Flags(ClrSegmentFlags value);
    [CompilerGeneratedAttribute]
public sealed virtual MemoryRange get_ReservedMemory();
    [CompilerGeneratedAttribute]
internal void set_ReservedMemory(MemoryRange value);
    [CompilerGeneratedAttribute]
public sealed virtual MemoryRange get_CommittedMemory();
    [CompilerGeneratedAttribute]
internal void set_CommittedMemory(MemoryRange value);
    public sealed virtual ulong get_FirstObjectAddress();
    [CompilerGeneratedAttribute]
public sealed virtual GCSegmentKind get_Kind();
    [CompilerGeneratedAttribute]
internal void set_Kind(GCSegmentKind value);
    public sealed virtual bool get_IsPinned();
    [CompilerGeneratedAttribute]
public sealed virtual MemoryRange get_Generation0();
    [CompilerGeneratedAttribute]
internal void set_Generation0(MemoryRange value);
    [CompilerGeneratedAttribute]
public sealed virtual MemoryRange get_Generation1();
    [CompilerGeneratedAttribute]
internal void set_Generation1(MemoryRange value);
    [CompilerGeneratedAttribute]
public sealed virtual MemoryRange get_Generation2();
    [CompilerGeneratedAttribute]
internal void set_Generation2(MemoryRange value);
    public IEnumerable`1<ClrObject> EnumerateObjects(bool carefully);
    [IteratorStateMachineAttribute("Microsoft.Diagnostics.Runtime.ClrSegment/<EnumerateObjects>d__56")]
public IEnumerable`1<ClrObject> EnumerateObjects(MemoryRange range, bool carefully);
    internal ulong get_MaxObjectSize();
    public sealed virtual Generation GetGeneration(ulong obj);
    public virtual string ToString();
    private sealed virtual override IEnumerable`1<IClrValue> Microsoft.Diagnostics.Runtime.Interfaces.IClrSegment.EnumerateObjects(bool carefully);
    private sealed virtual override IEnumerable`1<IClrValue> Microsoft.Diagnostics.Runtime.Interfaces.IClrSegment.EnumerateObjects(MemoryRange range, bool carefully);
    internal UInt32[] get_ObjectMarkers();
    private sealed virtual override IClrSubHeap Microsoft.Diagnostics.Runtime.Interfaces.IClrSegment.get_SubHeap();
    [CompilerGeneratedAttribute]
internal ulong get_BackgroundAllocated();
    [CompilerGeneratedAttribute]
internal void set_BackgroundAllocated(ulong value);
}
public enum Microsoft.Diagnostics.Runtime.ClrSegmentFlags : Enum {
    public ulong value__;
    public static ClrSegmentFlags None;
    public static ClrSegmentFlags ReadOnly;
    public static ClrSegmentFlags Swept;
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
public class Microsoft.Diagnostics.Runtime.ClrStackFrame : object {
    private Byte[] _context;
    [CompilerGeneratedAttribute]
private ClrThread <Thread>k__BackingField;
    [CompilerGeneratedAttribute]
private ulong <InstructionPointer>k__BackingField;
    [CompilerGeneratedAttribute]
private ulong <StackPointer>k__BackingField;
    [CompilerGeneratedAttribute]
private ClrStackFrameKind <Kind>k__BackingField;
    [CompilerGeneratedAttribute]
private ClrMethod <Method>k__BackingField;
    [CompilerGeneratedAttribute]
private string <FrameName>k__BackingField;
    public ClrThread Thread { get; }
    private IClrThread Microsoft.Diagnostics.Runtime.Interfaces.IClrStackFrame.Thread { get; }
    [NullableAttribute("0")]
public ReadOnlySpan`1<byte> Context { get; }
    public ulong InstructionPointer { get; }
    public ulong StackPointer { get; }
    public ClrStackFrameKind Kind { get; }
    public ClrMethod Method { get; }
    private IClrMethod Microsoft.Diagnostics.Runtime.Interfaces.IClrStackFrame.Method { get; }
    public string FrameName { get; }
    public ClrStackFrame(ClrThread thread, Byte[] context, ulong ip, ulong sp, ClrStackFrameKind kind, ClrMethod method, string frameName);
    [CompilerGeneratedAttribute]
public ClrThread get_Thread();
    private sealed virtual override IClrThread Microsoft.Diagnostics.Runtime.Interfaces.IClrStackFrame.get_Thread();
    [NullableContextAttribute("0")]
public sealed virtual ReadOnlySpan`1<byte> get_Context();
    [CompilerGeneratedAttribute]
public sealed virtual ulong get_InstructionPointer();
    [CompilerGeneratedAttribute]
public sealed virtual ulong get_StackPointer();
    [CompilerGeneratedAttribute]
public sealed virtual ClrStackFrameKind get_Kind();
    [CompilerGeneratedAttribute]
public ClrMethod get_Method();
    private sealed virtual override IClrMethod Microsoft.Diagnostics.Runtime.Interfaces.IClrStackFrame.get_Method();
    [CompilerGeneratedAttribute]
public sealed virtual string get_FrameName();
    public virtual string ToString();
}
public enum Microsoft.Diagnostics.Runtime.ClrStackFrameKind : Enum {
    public int value__;
    public static ClrStackFrameKind Unknown;
    public static ClrStackFrameKind ManagedMethod;
    public static ClrStackFrameKind Runtime;
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
public class Microsoft.Diagnostics.Runtime.ClrStackRoot : ClrRoot {
    [NullableAttribute("1")]
private ClrHeap _heap;
    private ClrObject _object;
    [CompilerGeneratedAttribute]
private ClrStackFrame <StackFrame>k__BackingField;
    [CompilerGeneratedAttribute]
private string <RegisterName>k__BackingField;
    [CompilerGeneratedAttribute]
private int <RegisterOffset>k__BackingField;
    private IClrStackFrame Microsoft.Diagnostics.Runtime.Interfaces.IClrRoot.StackFrame { get; }
    public ClrStackFrame StackFrame { get; }
    public string RegisterName { get; }
    public int RegisterOffset { get; }
    public ClrObject Object { get; }
    internal ClrStackRoot(ulong address, ClrObject obj, bool isInterior, bool isPinned, ClrHeap heap, ClrStackFrame frame, string regName, int regOffset);
    private sealed virtual override IClrStackFrame Microsoft.Diagnostics.Runtime.Interfaces.IClrRoot.get_StackFrame();
    [CompilerGeneratedAttribute]
public ClrStackFrame get_StackFrame();
    [CompilerGeneratedAttribute]
public sealed virtual string get_RegisterName();
    [CompilerGeneratedAttribute]
public sealed virtual int get_RegisterOffset();
    public virtual ClrObject get_Object();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Microsoft.Diagnostics.Runtime.ClrStaticField : ClrField {
    internal ClrStaticField(ClrType containingType, ClrType type, IAbstractTypeHelpers helpers, FieldInfo& data);
    public bool IsInitialized(ClrAppDomain appDomain);
    private sealed virtual override bool Microsoft.Diagnostics.Runtime.Interfaces.IClrStaticField.IsInitialized(IClrAppDomain appDomain);
    public ulong GetAddress(ClrAppDomain appDomain);
    public sealed virtual ulong GetAddress(IClrAppDomain appDomain);
    [NullableContextAttribute("0")]
public T Read(ClrAppDomain appDomain);
    [NullableContextAttribute("0")]
private sealed virtual override T Microsoft.Diagnostics.Runtime.Interfaces.IClrStaticField.Read(IClrAppDomain appDomain);
    public ClrObject ReadObject(ClrAppDomain appDomain);
    private sealed virtual override IClrValue Microsoft.Diagnostics.Runtime.Interfaces.IClrStaticField.ReadObject(IClrAppDomain appDomain);
    public ClrValueType ReadStruct(ClrAppDomain appDomain);
    private sealed virtual override IClrValue Microsoft.Diagnostics.Runtime.Interfaces.IClrStaticField.ReadStruct(IClrAppDomain appDomain);
    public string ReadString(ClrAppDomain appDomain);
    private sealed virtual override string Microsoft.Diagnostics.Runtime.Interfaces.IClrStaticField.ReadString(IClrAppDomain appDomain);
}
public class Microsoft.Diagnostics.Runtime.ClrSubHeap : object {
    [NullableAttribute("1")]
[CompilerGeneratedAttribute]
private ClrHeap <Heap>k__BackingField;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private ImmutableArray`1<ClrSegment> <Segments>k__BackingField;
    [CompilerGeneratedAttribute]
private MemoryRange <FinalizerQueueRoots>k__BackingField;
    [CompilerGeneratedAttribute]
private MemoryRange <FinalizerQueueObjects>k__BackingField;
    [CompilerGeneratedAttribute]
private ImmutableArray`1<MemoryRange> <GenerationalFinalizableObjects>k__BackingField;
    [CompilerGeneratedAttribute]
private MemoryRange <AllocationContext>k__BackingField;
    [CompilerGeneratedAttribute]
private int <Index>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <HasPinnedObjectHeap>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <HasRegions>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <HasBackgroundGC>k__BackingField;
    [CompilerGeneratedAttribute]
private ulong <Address>k__BackingField;
    [CompilerGeneratedAttribute]
private ulong <Allocated>k__BackingField;
    [CompilerGeneratedAttribute]
private ulong <MarkArray>k__BackingField;
    [CompilerGeneratedAttribute]
private HeapMarkState <State>k__BackingField;
    [CompilerGeneratedAttribute]
private ulong <CurrentSweepPosition>k__BackingField;
    [CompilerGeneratedAttribute]
private ulong <SavedSweepEphemeralSegment>k__BackingField;
    [CompilerGeneratedAttribute]
private ulong <SavedSweepEphemeralStart>k__BackingField;
    [CompilerGeneratedAttribute]
private ulong <BackgroundSavedLowestAddress>k__BackingField;
    [CompilerGeneratedAttribute]
private ulong <BackgroundSavedHighestAddress>k__BackingField;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private ImmutableArray`1<ClrGenerationData> <GenerationTable>k__BackingField;
    [CompilerGeneratedAttribute]
private ulong <EphemeralHeapSegment>k__BackingField;
    [CompilerGeneratedAttribute]
private ImmutableArray`1<ulong> <FinalizationPointers>k__BackingField;
    [CompilerGeneratedAttribute]
private ulong <LowestAddress>k__BackingField;
    [CompilerGeneratedAttribute]
private ulong <HighestAddress>k__BackingField;
    [CompilerGeneratedAttribute]
private ulong <CardTable>k__BackingField;
    [NullableAttribute("1")]
public ClrHeap Heap { get; }
    [NullableAttribute("1")]
private IClrHeap Microsoft.Diagnostics.Runtime.Interfaces.IClrSubHeap.Heap { get; }
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ImmutableArray`1<ClrSegment> Segments { get; }
    public MemoryRange FinalizerQueueRoots { get; }
    public MemoryRange FinalizerQueueObjects { get; }
    public ImmutableArray`1<MemoryRange> GenerationalFinalizableObjects { get; }
    public MemoryRange AllocationContext { get; }
    public int Index { get; }
    public bool HasPinnedObjectHeap { get; }
    public bool HasRegions { get; }
    public bool HasBackgroundGC { get; }
    public ulong Address { get; }
    public ulong Allocated { get; }
    public ulong MarkArray { get; }
    internal HeapMarkState State { get; }
    internal ulong CurrentSweepPosition { get; }
    public ulong SavedSweepEphemeralSegment { get; }
    public ulong SavedSweepEphemeralStart { get; }
    internal ulong BackgroundSavedLowestAddress { get; }
    internal ulong BackgroundSavedHighestAddress { get; }
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ImmutableArray`1<ClrGenerationData> GenerationTable { get; }
    public ulong EphemeralHeapSegment { get; }
    public ImmutableArray`1<ulong> FinalizationPointers { get; }
    public ulong LowestAddress { get; }
    public ulong HighestAddress { get; }
    public ulong CardTable { get; }
    [NullableAttribute("2")]
public ClrOutOfMemoryInfo OomInfo { get; }
    public MemoryRange InternalRootArray { get; }
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private ImmutableArray`1<IClrSegment> Microsoft.Diagnostics.Runtime.Interfaces.IClrSubHeap.Segments { get; }
    [NullableAttribute("2")]
private IClrOutOfMemoryInfo Microsoft.Diagnostics.Runtime.Interfaces.IClrSubHeap.OomInfo { get; }
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private ImmutableArray`1<IClrGenerationData> Microsoft.Diagnostics.Runtime.Interfaces.IClrSubHeap.GenerationTable { get; }
    [NullableContextAttribute("1")]
internal ClrSubHeap(ClrHeap clrHeap, SubHeapInfo& subHeap);
    private static MemoryRange CreateMemoryRangeCarefully(ulong start, ulong stop);
    [NullableContextAttribute("1")]
[CompilerGeneratedAttribute]
public ClrHeap get_Heap();
    [NullableContextAttribute("1")]
private sealed virtual override IClrHeap Microsoft.Diagnostics.Runtime.Interfaces.IClrSubHeap.get_Heap();
    [CompilerGeneratedAttribute]
public ImmutableArray`1<ClrSegment> get_Segments();
    [CompilerGeneratedAttribute]
public sealed virtual MemoryRange get_FinalizerQueueRoots();
    [CompilerGeneratedAttribute]
public sealed virtual MemoryRange get_FinalizerQueueObjects();
    [CompilerGeneratedAttribute]
public sealed virtual ImmutableArray`1<MemoryRange> get_GenerationalFinalizableObjects();
    [CompilerGeneratedAttribute]
public sealed virtual MemoryRange get_AllocationContext();
    [CompilerGeneratedAttribute]
public sealed virtual int get_Index();
    [CompilerGeneratedAttribute]
public sealed virtual bool get_HasPinnedObjectHeap();
    [CompilerGeneratedAttribute]
public sealed virtual bool get_HasRegions();
    [CompilerGeneratedAttribute]
public sealed virtual bool get_HasBackgroundGC();
    [CompilerGeneratedAttribute]
public sealed virtual ulong get_Address();
    [CompilerGeneratedAttribute]
public sealed virtual ulong get_Allocated();
    [CompilerGeneratedAttribute]
public sealed virtual ulong get_MarkArray();
    [CompilerGeneratedAttribute]
internal HeapMarkState get_State();
    [CompilerGeneratedAttribute]
internal ulong get_CurrentSweepPosition();
    [CompilerGeneratedAttribute]
public sealed virtual ulong get_SavedSweepEphemeralSegment();
    [CompilerGeneratedAttribute]
public sealed virtual ulong get_SavedSweepEphemeralStart();
    [CompilerGeneratedAttribute]
internal ulong get_BackgroundSavedLowestAddress();
    [CompilerGeneratedAttribute]
internal ulong get_BackgroundSavedHighestAddress();
    [CompilerGeneratedAttribute]
public ImmutableArray`1<ClrGenerationData> get_GenerationTable();
    [CompilerGeneratedAttribute]
public sealed virtual ulong get_EphemeralHeapSegment();
    [CompilerGeneratedAttribute]
public ImmutableArray`1<ulong> get_FinalizationPointers();
    [CompilerGeneratedAttribute]
public sealed virtual ulong get_LowestAddress();
    [CompilerGeneratedAttribute]
public sealed virtual ulong get_HighestAddress();
    [CompilerGeneratedAttribute]
public sealed virtual ulong get_CardTable();
    [NullableContextAttribute("2")]
public ClrOutOfMemoryInfo get_OomInfo();
    public sealed virtual MemoryRange get_InternalRootArray();
    private sealed virtual override ImmutableArray`1<IClrSegment> Microsoft.Diagnostics.Runtime.Interfaces.IClrSubHeap.get_Segments();
    [NullableContextAttribute("2")]
private sealed virtual override IClrOutOfMemoryInfo Microsoft.Diagnostics.Runtime.Interfaces.IClrSubHeap.get_OomInfo();
    private sealed virtual override ImmutableArray`1<IClrGenerationData> Microsoft.Diagnostics.Runtime.Interfaces.IClrSubHeap.get_GenerationTable();
    [CompilerGeneratedAttribute]
private ClrSegment <.ctor>b__0_1(SegmentInfo r);
}
public class Microsoft.Diagnostics.Runtime.ClrSyncBlockCleanupData : object {
    [CompilerGeneratedAttribute]
private ulong <SyncBlock>k__BackingField;
    [CompilerGeneratedAttribute]
private ulong <Rcw>k__BackingField;
    [CompilerGeneratedAttribute]
private ulong <Ccw>k__BackingField;
    [CompilerGeneratedAttribute]
private ulong <ClassFactory>k__BackingField;
    public ulong SyncBlock { get; }
    public ulong Rcw { get; }
    public ulong Ccw { get; }
    public ulong ClassFactory { get; }
    public ClrSyncBlockCleanupData(ulong syncBlockPointer, ulong blockRCW, ulong blockCCW, ulong blockClassFactory);
    [CompilerGeneratedAttribute]
public ulong get_SyncBlock();
    [CompilerGeneratedAttribute]
public ulong get_Rcw();
    [CompilerGeneratedAttribute]
public ulong get_Ccw();
    [CompilerGeneratedAttribute]
public ulong get_ClassFactory();
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
public class Microsoft.Diagnostics.Runtime.ClrThinLock : object {
    [CompilerGeneratedAttribute]
private ClrThread <Thread>k__BackingField;
    [CompilerGeneratedAttribute]
private int <Recursion>k__BackingField;
    public ClrThread Thread { get; }
    public int Recursion { get; }
    internal ClrThinLock(ClrThread thread, int recursion);
    [CompilerGeneratedAttribute]
public ClrThread get_Thread();
    [CompilerGeneratedAttribute]
public int get_Recursion();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Microsoft.Diagnostics.Runtime.ClrThread : object {
    private static int MaxFrameDefault;
    private IDataReader _dataReader;
    [NullableAttribute("2")]
private IAbstractThreadHelpers _threadHelpers;
    private ulong _exceptionInFlight;
    [NullableAttribute("2")]
private ClrException _lastThrownException;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private Cache`1 modreq(System.Runtime.CompilerServices.IsVolatile) _frameCache;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private Cache`1 modreq(System.Runtime.CompilerServices.IsVolatile) _rootCache;
    [CompilerGeneratedAttribute]
private ClrRuntime <Runtime>k__BackingField;
    [CompilerGeneratedAttribute]
private GCMode <GCMode>k__BackingField;
    [CompilerGeneratedAttribute]
private ulong <Address>k__BackingField;
    [CompilerGeneratedAttribute]
private ClrThreadState <State>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsFinalizer>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsGc>k__BackingField;
    [CompilerGeneratedAttribute]
private UInt32 <OSThreadId>k__BackingField;
    [CompilerGeneratedAttribute]
private int <ManagedThreadId>k__BackingField;
    [NullableAttribute("2")]
[CompilerGeneratedAttribute]
private ClrAppDomain <CurrentAppDomain>k__BackingField;
    [CompilerGeneratedAttribute]
private UInt32 <LockCount>k__BackingField;
    [CompilerGeneratedAttribute]
private ulong <StackBase>k__BackingField;
    [CompilerGeneratedAttribute]
private ulong <StackLimit>k__BackingField;
    public ClrRuntime Runtime { get; }
    private IClrRuntime Microsoft.Diagnostics.Runtime.Interfaces.IClrThread.Runtime { get; }
    public GCMode GCMode { get; }
    public ulong Address { get; }
    public ClrThreadState State { get; }
    public bool IsAlive { get; }
    public bool IsFinalizer { get; }
    public bool IsGc { get; }
    public UInt32 OSThreadId { get; }
    public int ManagedThreadId { get; }
    [NullableAttribute("2")]
public ClrAppDomain CurrentAppDomain { get; }
    [NullableAttribute("2")]
private IClrAppDomain Microsoft.Diagnostics.Runtime.Interfaces.IClrThread.CurrentAppDomain { get; }
    public UInt32 LockCount { get; }
    public ulong StackBase { get; }
    public ulong StackLimit { get; }
    [NullableAttribute("2")]
public ClrException CurrentException { get; }
    [NullableAttribute("2")]
private IClrException Microsoft.Diagnostics.Runtime.Interfaces.IClrThread.CurrentException { get; }
    internal ClrThread(IDataReader dataReader, ClrRuntime runtime, IAbstractThreadHelpers helpers, ClrThreadInfo& threadInfo);
    [CompilerGeneratedAttribute]
public ClrRuntime get_Runtime();
    private sealed virtual override IClrRuntime Microsoft.Diagnostics.Runtime.Interfaces.IClrThread.get_Runtime();
    [CompilerGeneratedAttribute]
public sealed virtual GCMode get_GCMode();
    [CompilerGeneratedAttribute]
public sealed virtual ulong get_Address();
    [CompilerGeneratedAttribute]
public sealed virtual ClrThreadState get_State();
    public sealed virtual bool get_IsAlive();
    [CompilerGeneratedAttribute]
public sealed virtual bool get_IsFinalizer();
    [CompilerGeneratedAttribute]
public sealed virtual bool get_IsGc();
    [CompilerGeneratedAttribute]
public sealed virtual UInt32 get_OSThreadId();
    [CompilerGeneratedAttribute]
public sealed virtual int get_ManagedThreadId();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public ClrAppDomain get_CurrentAppDomain();
    [NullableContextAttribute("2")]
private sealed virtual override IClrAppDomain Microsoft.Diagnostics.Runtime.Interfaces.IClrThread.get_CurrentAppDomain();
    [CompilerGeneratedAttribute]
public sealed virtual UInt32 get_LockCount();
    [CompilerGeneratedAttribute]
public sealed virtual ulong get_StackBase();
    [CompilerGeneratedAttribute]
public sealed virtual ulong get_StackLimit();
    public IEnumerable`1<ClrStackRoot> EnumerateStackRoots();
    [IteratorStateMachineAttribute("Microsoft.Diagnostics.Runtime.ClrThread/<CacheAndReturnRoots>d__51")]
private IEnumerable`1<ClrStackRoot> CacheAndReturnRoots(IEnumerable`1<ClrStackRoot> roots);
    private ClrStackFrame[] GetFramesForRoots();
    private ClrStackRoot CreateClrStackRoot(ClrHeap heap, ClrStackFrame[] stack, StackRootInfo stackRef);
    private sealed virtual override IEnumerable`1<IClrRoot> Microsoft.Diagnostics.Runtime.Interfaces.IClrThread.EnumerateStackRoots();
    public IEnumerable`1<ClrStackFrame> EnumerateStackTrace(bool includeContext);
    public IEnumerable`1<ClrStackFrame> EnumerateStackTrace(bool includeContext, int maxFrames);
    [IteratorStateMachineAttribute("Microsoft.Diagnostics.Runtime.ClrThread/<CacheAndReturnFrames>d__57")]
private IEnumerable`1<ClrStackFrame> CacheAndReturnFrames(bool includeContext, IEnumerable`1<ClrStackFrame> frames);
    private ClrStackFrame CreateClrStackFrame(StackFrameInfo& frame);
    private sealed virtual override IEnumerable`1<IClrStackFrame> Microsoft.Diagnostics.Runtime.Interfaces.IClrThread.EnumerateStackTrace(bool includeContext);
    [NullableContextAttribute("2")]
public sealed virtual bool Equals(IClrThread other);
    [NullableContextAttribute("2")]
public sealed virtual bool Equals(ClrThread other);
    [NullableContextAttribute("2")]
public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    [NullableContextAttribute("2")]
public ClrException get_CurrentException();
    [NullableContextAttribute("2")]
private sealed virtual override IClrException Microsoft.Diagnostics.Runtime.Interfaces.IClrThread.get_CurrentException();
    [NullableContextAttribute("0")]
[CompilerGeneratedAttribute]
private ClrStackFrame <GetFramesForRoots>b__52_0(StackFrameInfo r);
    [NullableContextAttribute("0")]
[CompilerGeneratedAttribute]
private ClrStackFrame <EnumerateStackTrace>b__56_0(StackFrameInfo r);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Microsoft.Diagnostics.Runtime.ClrThreadPool : object {
    private ClrRuntime _runtime;
    [NullableAttribute("2")]
private IAbstractLegacyThreadPool _legacyData;
    private ulong _nativeLogAddress;
    private UInt32 _nativeLogStart;
    private UInt32 _nativeLogSize;
    [CompilerGeneratedAttribute]
private bool <Initialized>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <UsingPortableThreadPool>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <UsingWindowsThreadPool>k__BackingField;
    [CompilerGeneratedAttribute]
private int <CpuUtilization>k__BackingField;
    [CompilerGeneratedAttribute]
private int <MinThreads>k__BackingField;
    [CompilerGeneratedAttribute]
private int <MaxThreads>k__BackingField;
    [CompilerGeneratedAttribute]
private int <IdleWorkerThreads>k__BackingField;
    [CompilerGeneratedAttribute]
private int <ActiveWorkerThreads>k__BackingField;
    [CompilerGeneratedAttribute]
private int <WindowsThreadPoolThreadCount>k__BackingField;
    [CompilerGeneratedAttribute]
private int <TotalCompletionPorts>k__BackingField;
    [CompilerGeneratedAttribute]
private int <FreeCompletionPorts>k__BackingField;
    [CompilerGeneratedAttribute]
private int <MaxFreeCompletionPorts>k__BackingField;
    [CompilerGeneratedAttribute]
private int <CompletionPortCurrentLimit>k__BackingField;
    [CompilerGeneratedAttribute]
private int <MinCompletionPorts>k__BackingField;
    [CompilerGeneratedAttribute]
private int <MaxCompletionPorts>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <HasLegacyData>k__BackingField;
    [CompilerGeneratedAttribute]
private int <RetiredWorkerThreads>k__BackingField;
    private ClrDataAddress _firstLegacyWorkRequest;
    private ClrDataAddress _asyncTimerFunction;
    internal bool Initialized { get; }
    public bool UsingPortableThreadPool { get; }
    public bool UsingWindowsThreadPool { get; }
    public int CpuUtilization { get; }
    public int MinThreads { get; }
    public int MaxThreads { get; }
    public int IdleWorkerThreads { get; }
    public int ActiveWorkerThreads { get; }
    public int WindowsThreadPoolThreadCount { get; }
    public int TotalCompletionPorts { get; }
    public int FreeCompletionPorts { get; }
    public int MaxFreeCompletionPorts { get; }
    public int CompletionPortCurrentLimit { get; }
    public int MinCompletionPorts { get; }
    public int MaxCompletionPorts { get; }
    public bool HasLegacyData { get; }
    public int RetiredWorkerThreads { get; }
    internal ClrThreadPool(ClrRuntime runtime, IAbstractLegacyThreadPool helpers);
    [CompilerGeneratedAttribute]
internal bool get_Initialized();
    [CompilerGeneratedAttribute]
public sealed virtual bool get_UsingPortableThreadPool();
    [CompilerGeneratedAttribute]
public sealed virtual bool get_UsingWindowsThreadPool();
    [CompilerGeneratedAttribute]
public sealed virtual int get_CpuUtilization();
    [CompilerGeneratedAttribute]
public sealed virtual int get_MinThreads();
    [CompilerGeneratedAttribute]
public sealed virtual int get_MaxThreads();
    [CompilerGeneratedAttribute]
public sealed virtual int get_IdleWorkerThreads();
    [CompilerGeneratedAttribute]
public sealed virtual int get_ActiveWorkerThreads();
    [CompilerGeneratedAttribute]
public sealed virtual int get_WindowsThreadPoolThreadCount();
    [CompilerGeneratedAttribute]
public sealed virtual int get_TotalCompletionPorts();
    [CompilerGeneratedAttribute]
public sealed virtual int get_FreeCompletionPorts();
    [CompilerGeneratedAttribute]
public sealed virtual int get_MaxFreeCompletionPorts();
    [CompilerGeneratedAttribute]
public sealed virtual int get_CompletionPortCurrentLimit();
    [CompilerGeneratedAttribute]
public sealed virtual int get_MinCompletionPorts();
    [CompilerGeneratedAttribute]
public sealed virtual int get_MaxCompletionPorts();
    [CompilerGeneratedAttribute]
public sealed virtual bool get_HasLegacyData();
    [CompilerGeneratedAttribute]
public sealed virtual int get_RetiredWorkerThreads();
    [IteratorStateMachineAttribute("Microsoft.Diagnostics.Runtime.ClrThreadPool/<EnumerateLegacyWorkRequests>d__59")]
public sealed virtual IEnumerable`1<LegacyThreadPoolWorkRequest> EnumerateLegacyWorkRequests();
    [IteratorStateMachineAttribute("Microsoft.Diagnostics.Runtime.ClrThreadPool/<EnumerateHillClimbingLog>d__60")]
public sealed virtual IEnumerable`1<HillClimbingLogEntry> EnumerateHillClimbingLog();
    private void GetPortableOrWindowsThreadPoolInfo(ClrAppDomain domain, Boolean& usingPortableThreadPool, ClrObject& portableThreadPool, Boolean& usingWindowsThreadPool, ClrType& windowsThreadPoolType);
    private ClrAppDomain GetDomain();
}
[FlagsAttribute]
public enum Microsoft.Diagnostics.Runtime.ClrThreadState : Enum {
    public int value__;
    public static ClrThreadState TS_AbortRequested;
    public static ClrThreadState TS_GCSuspendPending;
    public static ClrThreadState TS_UserSuspendPending;
    public static ClrThreadState TS_DebugSuspendPending;
    public static ClrThreadState TS_Background;
    public static ClrThreadState TS_Unstarted;
    public static ClrThreadState TS_Dead;
    public static ClrThreadState TS_CoInitialized;
    public static ClrThreadState TS_InSTA;
    public static ClrThreadState TS_InMTA;
    public static ClrThreadState TS_Aborted;
    public static ClrThreadState TS_TPWorkerThread;
    public static ClrThreadState TS_CompletionPortThread;
    public static ClrThreadState TS_AbortInitiated;
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Microsoft.Diagnostics.Runtime.ClrThreadStaticField : ClrField {
    internal ClrThreadStaticField(ClrType containingType, ClrType type, IAbstractTypeHelpers helpers, FieldInfo& data);
    public bool IsInitialized(ClrThread thread);
    public ulong GetAddress(ClrThread thread);
    [NullableContextAttribute("0")]
public T Read(ClrThread thread);
    public ClrObject ReadObject(ClrThread thread);
    public ClrValueType ReadStruct(ClrThread thread);
    public string ReadString(ClrThread thread);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public abstract class Microsoft.Diagnostics.Runtime.ClrType : object {
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
protected ImmutableArray`1<ClrInstanceField> _fields;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
protected ImmutableArray`1<ClrStaticField> _staticFields;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
protected ImmutableArray`1<ClrThreadStaticField> _threadStaticFields;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
protected ImmutableArray`1<ClrMethod> _methods;
    private Dictionary`2<ulong, ClrMethod> _constructedMethods;
    [CompilerGeneratedAttribute]
private IAbstractTypeHelpers <Helpers>k__BackingField;
    [CompilerGeneratedAttribute]
private TypeInfo <TypeInfo>k__BackingField;
    [CompilerGeneratedAttribute]
private ClrModule <Module>k__BackingField;
    internal IAbstractTypeHelpers Helpers { get; }
    internal TypeInfo TypeInfo { get; }
    public GCDesc GCDesc { get; }
    public ulong MethodTable { get; }
    public int MetadataToken { get; }
    [NullableAttribute("2")]
public string Name { get; }
    public bool ContainsPointers { get; }
    public bool IsCollectible { get; }
    public ulong LoaderAllocatorHandle { get; }
    public ulong AssemblyLoadContextAddress { get; }
    public ClrHeap Heap { get; }
    public ClrModule Module { get; }
    public ClrElementType ElementType { get; }
    public bool IsPrimitive { get; }
    public bool IsValueType { get; }
    public bool IsObjectReference { get; }
    public bool IsFinalizable { get; }
    public TypeAttributes TypeAttributes { get; }
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ImmutableArray`1<ClrInstanceField> Fields { get; }
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ImmutableArray`1<ClrStaticField> StaticFields { get; }
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ImmutableArray`1<ClrThreadStaticField> ThreadStaticFields { get; }
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ImmutableArray`1<ClrMethod> Methods { get; }
    [NullableAttribute("2")]
public ClrType BaseType { get; }
    public bool IsPointer { get; }
    [NullableAttribute("2")]
public ClrType ComponentType { get; }
    public bool IsArray { get; }
    public int StaticSize { get; }
    public int ComponentSize { get; }
    public bool IsString { get; }
    public bool IsFree { get; }
    public bool IsException { get; }
    public bool IsEnum { get; }
    public bool IsShared { get; }
    [NullableAttribute("2")]
private IClrType Microsoft.Diagnostics.Runtime.Interfaces.IClrType.BaseType { get; }
    [NullableAttribute("2")]
private IClrType Microsoft.Diagnostics.Runtime.Interfaces.IClrType.ComponentType { get; }
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private ImmutableArray`1<IClrInstanceField> Microsoft.Diagnostics.Runtime.Interfaces.IClrType.Fields { get; }
    private IClrHeap Microsoft.Diagnostics.Runtime.Interfaces.IClrType.Heap { get; }
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private ImmutableArray`1<IClrMethod> Microsoft.Diagnostics.Runtime.Interfaces.IClrType.Methods { get; }
    private IClrModule Microsoft.Diagnostics.Runtime.Interfaces.IClrType.Module { get; }
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private ImmutableArray`1<IClrStaticField> Microsoft.Diagnostics.Runtime.Interfaces.IClrType.StaticFields { get; }
    internal ClrType(ClrModule module, TypeInfo& info, IAbstractTypeHelpers helpers);
    [CompilerGeneratedAttribute]
internal IAbstractTypeHelpers get_Helpers();
    [CompilerGeneratedAttribute]
internal TypeInfo get_TypeInfo();
    public abstract virtual GCDesc get_GCDesc();
    public sealed virtual ulong get_MethodTable();
    public sealed virtual int get_MetadataToken();
    [NullableContextAttribute("2")]
public abstract virtual string get_Name();
    public sealed virtual bool get_ContainsPointers();
    public virtual bool get_IsCollectible();
    public virtual ulong get_LoaderAllocatorHandle();
    public virtual ulong get_AssemblyLoadContextAddress();
    public abstract virtual ClrHeap get_Heap();
    [CompilerGeneratedAttribute]
public ClrModule get_Module();
    public abstract virtual ClrElementType get_ElementType();
    public virtual bool get_IsPrimitive();
    public virtual bool get_IsValueType();
    public virtual bool get_IsObjectReference();
    public virtual IEnumerable`1<ClrGenericParameter> EnumerateGenericParameters();
    [IteratorStateMachineAttribute("Microsoft.Diagnostics.Runtime.ClrType/<EnumerateInterfaces>d__42")]
public sealed virtual IEnumerable`1<ClrInterface> EnumerateInterfaces();
    private static ClrInterface GetInterface(IAbstractMetadataReader import, int mdIFace);
    public abstract virtual bool IsFinalizeSuppressed(ulong obj);
    public abstract virtual bool get_IsFinalizable();
    public abstract virtual TypeAttributes get_TypeAttributes();
    public virtual ImmutableArray`1<ClrInstanceField> get_Fields();
    internal CacheOptions GetCacheOptions();
    public virtual ImmutableArray`1<ClrStaticField> get_StaticFields();
    public virtual ImmutableArray`1<ClrThreadStaticField> get_ThreadStaticFields();
    internal ClrMethod GetOrCreateMethod(MethodInfo methodInfo);
    private void CacheFields(ImmutableArray`1& fields, ImmutableArray`1& staticFields, ImmutableArray`1& threadStaticFields);
    public virtual ImmutableArray`1<ClrMethod> get_Methods();
    public abstract virtual ClrInstanceField GetFieldByName(string name);
    public abstract virtual ClrStaticField GetStaticFieldByName(string name);
    [NullableContextAttribute("2")]
public abstract virtual ClrType get_BaseType();
    public virtual bool get_IsPointer();
    [NullableContextAttribute("2")]
public abstract virtual ClrType get_ComponentType();
    public abstract virtual bool get_IsArray();
    public abstract virtual ulong GetArrayElementAddress(ulong objRef, int index);
    [NullableContextAttribute("0")]
public abstract virtual T[] ReadArrayElements(ulong objRef, int start, int count);
    public sealed virtual int get_StaticSize();
    public sealed virtual int get_ComponentSize();
    public virtual bool get_IsString();
    public virtual bool get_IsFree();
    public virtual bool get_IsException();
    public abstract virtual bool get_IsEnum();
    public abstract virtual ClrEnum AsEnum();
    private sealed virtual override IClrEnum Microsoft.Diagnostics.Runtime.Interfaces.IClrType.AsEnum();
    public sealed virtual bool get_IsShared();
    [NullableContextAttribute("2")]
public virtual string ToString();
    [NullableContextAttribute("2")]
private sealed virtual override IClrType Microsoft.Diagnostics.Runtime.Interfaces.IClrType.get_BaseType();
    [NullableContextAttribute("2")]
private sealed virtual override IClrType Microsoft.Diagnostics.Runtime.Interfaces.IClrType.get_ComponentType();
    private sealed virtual override ImmutableArray`1<IClrInstanceField> Microsoft.Diagnostics.Runtime.Interfaces.IClrType.get_Fields();
    private sealed virtual override IClrHeap Microsoft.Diagnostics.Runtime.Interfaces.IClrType.get_Heap();
    private sealed virtual override ImmutableArray`1<IClrMethod> Microsoft.Diagnostics.Runtime.Interfaces.IClrType.get_Methods();
    private sealed virtual override IClrModule Microsoft.Diagnostics.Runtime.Interfaces.IClrType.get_Module();
    private sealed virtual override ImmutableArray`1<IClrStaticField> Microsoft.Diagnostics.Runtime.Interfaces.IClrType.get_StaticFields();
    [NullableContextAttribute("2")]
public virtual bool Equals(object obj);
    [NullableContextAttribute("2")]
public sealed virtual bool Equals(ClrType other);
    public virtual int GetHashCode();
    private sealed virtual override IClrInstanceField Microsoft.Diagnostics.Runtime.Interfaces.IClrType.GetFieldByName(string name);
    private sealed virtual override IClrStaticField Microsoft.Diagnostics.Runtime.Interfaces.IClrType.GetStaticFieldByName(string name);
    [NullableContextAttribute("2")]
private sealed virtual override bool System.IEquatable<Microsoft.Diagnostics.Runtime.Interfaces.IClrType>.Equals(IClrType other);
    [NullableContextAttribute("2")]
public static bool op_Equality(ClrType left, ClrType right);
    [NullableContextAttribute("2")]
public static bool op_Inequality(ClrType left, ClrType right);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[IsReadOnlyAttribute]
public class Microsoft.Diagnostics.Runtime.ClrValueType : ValueType {
    private bool _interior;
    [CompilerGeneratedAttribute]
private ulong <Address>k__BackingField;
    [NullableAttribute("2")]
[CompilerGeneratedAttribute]
private ClrType <Type>k__BackingField;
    private IDataReader DataReader { get; }
    public ulong Address { get; }
    [NullableAttribute("2")]
public ClrType Type { get; }
    public bool IsValid { get; }
    public bool ContainsPointers { get; }
    public ulong Size { get; }
    private bool Microsoft.Diagnostics.Runtime.Interfaces.IClrValue.HasComCallableWrapper { get; }
    private bool Microsoft.Diagnostics.Runtime.Interfaces.IClrValue.HasRuntimeCallableWrapper { get; }
    private bool Microsoft.Diagnostics.Runtime.Interfaces.IClrValue.IsArray { get; }
    private bool Microsoft.Diagnostics.Runtime.Interfaces.IClrValue.IsBoxedValue { get; }
    private bool Microsoft.Diagnostics.Runtime.Interfaces.IClrValue.IsComClassFactory { get; }
    private bool Microsoft.Diagnostics.Runtime.Interfaces.IClrValue.IsDelegate { get; }
    private bool Microsoft.Diagnostics.Runtime.Interfaces.IClrValue.IsException { get; }
    private bool Microsoft.Diagnostics.Runtime.Interfaces.IClrValue.IsFree { get; }
    private bool Microsoft.Diagnostics.Runtime.Interfaces.IClrValue.IsNull { get; }
    private bool Microsoft.Diagnostics.Runtime.Interfaces.IClrValue.IsRuntimeType { get; }
    [NullableAttribute("2")]
private SyncBlock Microsoft.Diagnostics.Runtime.Interfaces.IClrValue.SyncBlock { get; }
    [NullableAttribute("2")]
private IClrType Microsoft.Diagnostics.Runtime.Interfaces.IClrValue.Type { get; }
    [NullableContextAttribute("2")]
internal ClrValueType(ulong address, ClrType type, bool interior);
    private IDataReader get_DataReader();
    [CompilerGeneratedAttribute]
public sealed virtual ulong get_Address();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public ClrType get_Type();
    public sealed virtual bool get_IsValid();
    public static ClrValueType FromAddress(ulong address, ClrType type);
    public sealed virtual bool Equals(ClrObject obj);
    public sealed virtual bool Equals(ClrValueType other);
    [NullableContextAttribute("2")]
public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public ClrObject ReadObjectField(string fieldName);
    [NullableContextAttribute("0")]
public sealed virtual T ReadField(string fieldName);
    public ClrValueType ReadValueTypeField(string fieldName);
    public sealed virtual string ReadStringField(string fieldName, int maxLength);
    public sealed virtual bool TryReadStringField(string fieldName, Nullable`1<int> maxLength, String& result);
    private ulong GetFieldAddress(string fieldName, ClrElementType element, string typeName);
    [NullableContextAttribute("2")]
public sealed virtual bool Equals(IClrValue other);
    private ClrType GetTypeOrThrow();
    public sealed virtual bool get_ContainsPointers();
    public sealed virtual ulong get_Size();
    private sealed virtual override bool Microsoft.Diagnostics.Runtime.Interfaces.IClrValue.get_HasComCallableWrapper();
    private sealed virtual override bool Microsoft.Diagnostics.Runtime.Interfaces.IClrValue.get_HasRuntimeCallableWrapper();
    private sealed virtual override bool Microsoft.Diagnostics.Runtime.Interfaces.IClrValue.get_IsArray();
    private sealed virtual override bool Microsoft.Diagnostics.Runtime.Interfaces.IClrValue.get_IsBoxedValue();
    private sealed virtual override bool Microsoft.Diagnostics.Runtime.Interfaces.IClrValue.get_IsComClassFactory();
    private sealed virtual override bool Microsoft.Diagnostics.Runtime.Interfaces.IClrValue.get_IsDelegate();
    private sealed virtual override bool Microsoft.Diagnostics.Runtime.Interfaces.IClrValue.get_IsException();
    private sealed virtual override bool Microsoft.Diagnostics.Runtime.Interfaces.IClrValue.get_IsFree();
    private sealed virtual override bool Microsoft.Diagnostics.Runtime.Interfaces.IClrValue.get_IsNull();
    private sealed virtual override bool Microsoft.Diagnostics.Runtime.Interfaces.IClrValue.get_IsRuntimeType();
    [NullableContextAttribute("2")]
private sealed virtual override SyncBlock Microsoft.Diagnostics.Runtime.Interfaces.IClrValue.get_SyncBlock();
    [NullableContextAttribute("2")]
private sealed virtual override IClrType Microsoft.Diagnostics.Runtime.Interfaces.IClrValue.get_Type();
    private sealed virtual override IClrArray Microsoft.Diagnostics.Runtime.Interfaces.IClrValue.AsArray();
    private sealed virtual override IClrDelegate Microsoft.Diagnostics.Runtime.Interfaces.IClrValue.AsDelegate();
    [NullableContextAttribute("2")]
private sealed virtual override IClrException Microsoft.Diagnostics.Runtime.Interfaces.IClrValue.AsException();
    [NullableContextAttribute("2")]
private sealed virtual override IClrType Microsoft.Diagnostics.Runtime.Interfaces.IClrValue.AsRuntimeType();
    [NullableContextAttribute("2")]
private sealed virtual override string Microsoft.Diagnostics.Runtime.Interfaces.IClrValue.AsString(int maxLength);
    private sealed virtual override IEnumerable`1<ulong> Microsoft.Diagnostics.Runtime.Interfaces.IClrValue.EnumerateReferenceAddresses(bool carefully, bool considerDependantHandles);
    private sealed virtual override IEnumerable`1<IClrValue> Microsoft.Diagnostics.Runtime.Interfaces.IClrValue.EnumerateReferences(bool carefully, bool considerDependantHandles);
    private sealed virtual override IEnumerable`1<IClrReference> Microsoft.Diagnostics.Runtime.Interfaces.IClrValue.EnumerateReferencesWithFields(bool carefully, bool considerDependantHandles);
    [NullableContextAttribute("2")]
private sealed virtual override IComCallableWrapper Microsoft.Diagnostics.Runtime.Interfaces.IClrValue.GetComCallableWrapper();
    [NullableContextAttribute("2")]
private sealed virtual override IRuntimeCallableWrapper Microsoft.Diagnostics.Runtime.Interfaces.IClrValue.GetRuntimeCallableWrapper();
    [NullableContextAttribute("0")]
private sealed virtual override T Microsoft.Diagnostics.Runtime.Interfaces.IClrValue.ReadBoxedValue();
    private sealed virtual override IClrValue Microsoft.Diagnostics.Runtime.Interfaces.IClrValue.ReadObjectField(string fieldName);
    [NullableContextAttribute("0")]
private sealed virtual override bool Microsoft.Diagnostics.Runtime.Interfaces.IClrValue.TryReadField(string fieldName, T& result);
    private sealed virtual override bool Microsoft.Diagnostics.Runtime.Interfaces.IClrValue.TryReadObjectField(string fieldName, IClrValue& result);
    private sealed virtual override bool Microsoft.Diagnostics.Runtime.Interfaces.IClrValue.TryReadValueTypeField(string fieldName, IClrValue& result);
    private sealed virtual override IClrValue Microsoft.Diagnostics.Runtime.Interfaces.IClrValue.ReadValueTypeField(string fieldName);
    public static bool op_Equality(ClrValueType left, ClrValueType right);
    public static bool op_Inequality(ClrValueType left, ClrValueType right);
}
public enum Microsoft.Diagnostics.Runtime.CodeHeapKind : Enum {
    public int value__;
    public static CodeHeapKind Loader;
    public static CodeHeapKind Host;
    public static CodeHeapKind Unknown;
}
public class Microsoft.Diagnostics.Runtime.ComCallableWrapper : object {
    [CompilerGeneratedAttribute]
private ulong <Address>k__BackingField;
    [CompilerGeneratedAttribute]
private ulong <IUnknown>k__BackingField;
    [CompilerGeneratedAttribute]
private ulong <Object>k__BackingField;
    [CompilerGeneratedAttribute]
private ulong <Handle>k__BackingField;
    [CompilerGeneratedAttribute]
private int <RefCount>k__BackingField;
    [CompilerGeneratedAttribute]
private ImmutableArray`1<ComInterfaceData> <Interfaces>k__BackingField;
    public ulong Address { get; }
    public ulong IUnknown { get; }
    public ulong Object { get; }
    public ulong Handle { get; }
    public int RefCount { get; }
    public ImmutableArray`1<ComInterfaceData> Interfaces { get; }
    [NullableContextAttribute("1")]
internal ComCallableWrapper(ClrRuntime runtime, CcwInfo& ccw);
    [CompilerGeneratedAttribute]
public sealed virtual ulong get_Address();
    [CompilerGeneratedAttribute]
public sealed virtual ulong get_IUnknown();
    [CompilerGeneratedAttribute]
public sealed virtual ulong get_Object();
    [CompilerGeneratedAttribute]
public sealed virtual ulong get_Handle();
    [CompilerGeneratedAttribute]
public sealed virtual int get_RefCount();
    [CompilerGeneratedAttribute]
public sealed virtual ImmutableArray`1<ComInterfaceData> get_Interfaces();
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
[IsReadOnlyAttribute]
public class Microsoft.Diagnostics.Runtime.ComInterfaceData : ValueType {
    [CompilerGeneratedAttribute]
private ClrType <Type>k__BackingField;
    [CompilerGeneratedAttribute]
private ulong <InterfacePointer>k__BackingField;
    public ClrType Type { get; }
    public ulong InterfacePointer { get; }
    internal ComInterfaceData(ClrType type, ulong pointer);
    [CompilerGeneratedAttribute]
public ClrType get_Type();
    [CompilerGeneratedAttribute]
public ulong get_InterfacePointer();
}
internal abstract class Microsoft.Diagnostics.Runtime.CommonMemoryReader : object {
    public int PointerSize { get; }
    public virtual int get_PointerSize();
    public abstract virtual int Read(ulong address, Span`1<byte> buffer);
    public sealed virtual bool Read(ulong address, T& value);
    public sealed virtual T Read(ulong address);
    public sealed virtual bool ReadPointer(ulong address, UInt64& value);
    public sealed virtual ulong ReadPointer(ulong address);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.Diagnostics.Runtime.CoredumpReader : CommonMemoryReader {
    private ElfCoreFile _core;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private Dictionary`2<UInt32, IElfPRStatus> _threads;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private List`1<ModuleInfo> _modules;
    [CompilerGeneratedAttribute]
private string <DisplayName>k__BackingField;
    [CompilerGeneratedAttribute]
private Architecture <Architecture>k__BackingField;
    [CompilerGeneratedAttribute]
private int <PointerSize>k__BackingField;
    public string DisplayName { get; }
    public OSPlatform TargetPlatform { get; }
    public bool IsThreadSafe { get; }
    public int ProcessId { get; }
    public Architecture Architecture { get; }
    public int PointerSize { get; }
    public CoredumpReader(string path, Stream stream, bool leaveOpen);
    [CompilerGeneratedAttribute]
public sealed virtual string get_DisplayName();
    public sealed virtual OSPlatform get_TargetPlatform();
    public sealed virtual bool get_IsThreadSafe();
    public sealed virtual void Dispose();
    public sealed virtual int get_ProcessId();
    public sealed virtual IEnumerable`1<ModuleInfo> EnumerateModules();
    private ModuleInfo CreateModuleInfo(ElfLoadedImage image);
    public sealed virtual void FlushCachedData();
    [CompilerGeneratedAttribute]
public sealed virtual Architecture get_Architecture();
    [CompilerGeneratedAttribute]
public virtual int get_PointerSize();
    [IteratorStateMachineAttribute("Microsoft.Diagnostics.Runtime.CoredumpReader/<EnumerateOSThreadIds>d__23")]
public sealed virtual IEnumerable`1<UInt32> EnumerateOSThreadIds();
    public sealed virtual ulong GetThreadTeb(UInt32 osThreadId);
    [NullableContextAttribute("0")]
public sealed virtual bool GetThreadContext(UInt32 threadID, UInt32 contextFlags, Span`1<byte> context);
    [NullableContextAttribute("0")]
public virtual int Read(ulong address, Span`1<byte> buffer);
    private Dictionary`2<UInt32, IElfPRStatus> LoadThreads();
}
internal abstract class Microsoft.Diagnostics.Runtime.CoreFunctions : PlatformFunctions {
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
public class Microsoft.Diagnostics.Runtime.CustomDataTarget : object {
    [NullableAttribute("1")]
public static string TraceSymbolsEnvVariable;
    [NullableAttribute("1")]
[CompilerGeneratedAttribute]
private IDataReader <DataReader>k__BackingField;
    [CompilerGeneratedAttribute]
private CacheOptions <CacheOptions>k__BackingField;
    [CompilerGeneratedAttribute]
private IFileLocator <FileLocator>k__BackingField;
    [CompilerGeneratedAttribute]
private string <DefaultSymbolPath>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <ForceCompleteRuntimeEnumeration>k__BackingField;
    [CompilerGeneratedAttribute]
private TokenCredential <SymbolTokenCredential>k__BackingField;
    [NullableAttribute("1")]
public IDataReader DataReader { get; public set; }
    public CacheOptions CacheOptions { get; public set; }
    public IFileLocator FileLocator { get; public set; }
    public string DefaultSymbolPath { get; public set; }
    public bool ForceCompleteRuntimeEnumeration { get; public set; }
    public TokenCredential SymbolTokenCredential { get; public set; }
    [NullableContextAttribute("1")]
public CustomDataTarget(IDataReader reader, TokenCredential symbolCredential);
    [NullableContextAttribute("1")]
[CompilerGeneratedAttribute]
public IDataReader get_DataReader();
    [NullableContextAttribute("1")]
[CompilerGeneratedAttribute]
public void set_DataReader(IDataReader value);
    [CompilerGeneratedAttribute]
public CacheOptions get_CacheOptions();
    [CompilerGeneratedAttribute]
public void set_CacheOptions(CacheOptions value);
    [CompilerGeneratedAttribute]
public IFileLocator get_FileLocator();
    [CompilerGeneratedAttribute]
public void set_FileLocator(IFileLocator value);
    [CompilerGeneratedAttribute]
public string get_DefaultSymbolPath();
    [CompilerGeneratedAttribute]
public void set_DefaultSymbolPath(string value);
    [CompilerGeneratedAttribute]
public bool get_ForceCompleteRuntimeEnumeration();
    [CompilerGeneratedAttribute]
public void set_ForceCompleteRuntimeEnumeration(bool value);
    [CompilerGeneratedAttribute]
public TokenCredential get_SymbolTokenCredential();
    [CompilerGeneratedAttribute]
public void set_SymbolTokenCredential(TokenCredential value);
    public sealed virtual void Dispose();
    protected virtual override void Finalize();
    protected virtual void Dispose(bool disposing);
    internal static bool GetTraceEnvironmentVariable();
    [NullableContextAttribute("1")]
public virtual string ToString();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.Diagnostics.Runtime.DacImplementation.DacComHelpers : object {
    private SOSDac _sos;
    public DacComHelpers(SOSDac sos);
    public sealed virtual IEnumerable`1<ClrRcwCleanupData> EnumerateRcwCleanupData();
    public sealed virtual bool GetCcwInfo(ulong obj, CcwInfo& info);
    public sealed virtual bool GetRcwInfo(ulong obj, RcwInfo& info);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.Diagnostics.Runtime.DacImplementation.DacHeap : object {
    private SOSDac _sos;
    [NullableAttribute("2")]
private SOSDac8 _sos8;
    [NullableAttribute("2")]
private SosDac12 _sos12;
    private IMemoryReader _memoryReader;
    private GCState _gcState;
    [NullableAttribute("2")]
private HashSet`1<ulong> _validMethodTables;
    private static UInt32 SyncBlockRecLevelMask;
    private static int SyncBlockRecLevelShift;
    private static UInt32 SyncBlockThreadIdMask;
    private static UInt32 SyncBlockSpinLock;
    private static UInt32 SyncBlockHashOrSyncBlockIndex;
    [IsReadOnlyAttribute]
public GCState& modreq(System.Runtime.InteropServices.InAttribute) State { get; }
    public DacHeap(SOSDac sos, SOSDac8 sos8, SosDac12 sos12, IMemoryReader reader, GCInfo& gcInfo, CommonMethodTables& commonMethodTables);
    public sealed virtual GCState& modreq(System.Runtime.InteropServices.InAttribute) get_State();
    [IteratorStateMachineAttribute("Microsoft.Diagnostics.Runtime.DacImplementation.DacHeap/<EnumerateThreadAllocationContexts>d__14")]
public sealed virtual IEnumerable`1<MemoryRange> EnumerateThreadAllocationContexts();
    [IteratorStateMachineAttribute("Microsoft.Diagnostics.Runtime.DacImplementation.DacHeap/<EnumerateDependentHandles>d__15")]
public sealed virtual IEnumerable`1<ValueTuple`2<ulong, ulong>> EnumerateDependentHandles();
    [IteratorStateMachineAttribute("Microsoft.Diagnostics.Runtime.DacImplementation.DacHeap/<EnumerateSyncBlocks>d__16")]
public sealed virtual IEnumerable`1<SyncBlockInfo> EnumerateSyncBlocks();
    [IteratorStateMachineAttribute("Microsoft.Diagnostics.Runtime.DacImplementation.DacHeap/<EnumerateSubHeaps>d__17")]
public sealed virtual IEnumerable`1<SubHeapInfo> EnumerateSubHeaps();
    private SubHeapInfo CreateSubHeapInfo(ulong address, int i, HeapDetails heapData);
    private static GenerationInfo[] ConvertGenerations(GenerationData[] genData);
    private IEnumerable`1<SegmentInfo> EnumerateSegments(SubHeapInfo& heap);
    [IteratorStateMachineAttribute("Microsoft.Diagnostics.Runtime.DacImplementation.DacHeap/<EnumerateSegments>d__21")]
private IEnumerable`1<SegmentInfo> EnumerateSegments(SubHeapInfo heap, int generation, HashSet`1<ulong> seen);
    private bool TryCreateSegment(SubHeapInfo subHeap, ulong address, int generation, SegmentInfo& segInfo);
    [NullableContextAttribute("0")]
public sealed virtual ValueTuple`2<ulong, int> GetThinLock(UInt32 header);
    private static bool HasThinlock(UInt32 header);
    [NullableContextAttribute("0")]
private static ValueTuple`2<UInt32, UInt32> GetThinlockData(UInt32 header);
    public sealed virtual bool IsValidMethodTable(ulong mt);
    public sealed virtual MemoryRange GetInternalRootArray(ulong subHeapAddress);
    public sealed virtual bool GetOOMInfo(ulong subHeapAddress, OomInfo& oomInfo);
}
internal class Microsoft.Diagnostics.Runtime.DacImplementation.DacLegacyThreadPool : object {
    [NullableAttribute("1")]
private SOSDac _sos;
    [NullableContextAttribute("1")]
public DacLegacyThreadPool(SOSDac sos);
    public sealed virtual bool GetLegacyThreadPoolData(LegacyThreadPoolInfo& result);
    public sealed virtual bool GetLegacyWorkRequestData(ulong workRequest, LegacyWorkRequestInfo& workRequestInfo);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.Diagnostics.Runtime.DacImplementation.DacMetadataReader : object {
    private MetadataImport _import;
    private bool _disposed;
    public DacMetadataReader(MetadataImport import);
    public sealed virtual void Dispose();
    public sealed virtual bool GetMethodAttributes(int methodDef, MethodAttributes& attributes);
    public sealed virtual bool GetFieldDefInfo(int token, FieldDefInfo& info);
    public sealed virtual bool GetTypeDefInfo(int typeDef, TypeDefInfo& info);
    [NullableContextAttribute("2")]
public sealed virtual string GetTypeRefName(int typeRef);
    public sealed virtual bool GetNestedClassToken(int typeDef, Int32& parent);
    [IteratorStateMachineAttribute("Microsoft.Diagnostics.Runtime.DacImplementation.DacMetadataReader/<EnumerateFields>d__9")]
public sealed virtual IEnumerable`1<FieldDefInfo> EnumerateFields(int typeDef);
    [IteratorStateMachineAttribute("Microsoft.Diagnostics.Runtime.DacImplementation.DacMetadataReader/<EnumerateGenericParameters>d__10")]
public sealed virtual IEnumerable`1<GenericParameterInfo> EnumerateGenericParameters(int typeDef);
    [IteratorStateMachineAttribute("Microsoft.Diagnostics.Runtime.DacImplementation.DacMetadataReader/<EnumerateInterfaces>d__11")]
public sealed virtual IEnumerable`1<InterfaceInfo> EnumerateInterfaces(int typeDef);
    [NullableContextAttribute("0")]
public sealed virtual int GetCustomAttributeData(int token, string name, Span`1<byte> buffer);
    public sealed virtual UInt32 GetRva(int metadataToken);
}
internal class Microsoft.Diagnostics.Runtime.DacImplementation.DacMethodLocator : object {
    [NullableAttribute("1")]
private SOSDac _sos;
    [NullableContextAttribute("1")]
public DacMethodLocator(SOSDac sos);
    public sealed virtual ulong GetMethodHandleContainingType(ulong methodDesc);
    public sealed virtual ulong GetMethodHandleByInstructionPointer(ulong ip);
    public sealed virtual bool GetMethodInfo(ulong methodDesc, MethodInfo& methodInfo);
}
internal class Microsoft.Diagnostics.Runtime.DacImplementation.DacModuleHelpers : object {
    private static int mdtTypeDef;
    private static int mdtTypeRef;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private Dictionary`2<ulong, DacMetadataReader> _imports;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private Dictionary`2<ulong, ClrDataModule> _modules;
    [NullableAttribute("1")]
private SOSDac _sos;
    [NullableContextAttribute("1")]
public DacModuleHelpers(SOSDac sos);
    public sealed virtual ClrModuleInfo GetModuleInfo(ulong moduleAddress);
    public sealed virtual IEnumerable`1<ValueTuple`2<ulong, int>> EnumerateTypeDefMap(ulong module);
    public sealed virtual IEnumerable`1<ValueTuple`2<ulong, int>> EnumerateTypeRefMap(ulong module);
    private List`1<ValueTuple`2<ulong, int>> GetModuleMap(ulong module, ModuleMapTraverseKind kind);
    [NullableContextAttribute("2")]
public sealed virtual IAbstractMetadataReader GetMetadataReader(ulong moduleAddress);
    [NullableContextAttribute("2")]
private ClrDataModule GetClrDataModule(ulong moduleAddress);
    public sealed virtual void Dispose();
    public void Flush();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.Diagnostics.Runtime.DacImplementation.DacNativeHeaps : object {
    [NullableAttribute("2")]
private NativeHeapKind[] _heapNativeTypes;
    private ClrInfo _clrInfo;
    private SOSDac _sos;
    [NullableAttribute("2")]
private ISOSDac13 _sos13;
    private IDataReader _dataReader;
    public DacNativeHeaps(ClrInfo clrInfo, SOSDac sos, ISOSDac13 sos13, IDataReader dataReader);
    [IteratorStateMachineAttribute("Microsoft.Diagnostics.Runtime.DacImplementation.DacNativeHeaps/<EnumerateGCFreeRegions>d__6")]
public sealed virtual IEnumerable`1<ClrNativeHeapInfo> EnumerateGCFreeRegions();
    [IteratorStateMachineAttribute("Microsoft.Diagnostics.Runtime.DacImplementation.DacNativeHeaps/<EnumerateHandleTableRegions>d__7")]
public sealed virtual IEnumerable`1<ClrNativeHeapInfo> EnumerateHandleTableRegions();
    [IteratorStateMachineAttribute("Microsoft.Diagnostics.Runtime.DacImplementation.DacNativeHeaps/<EnumerateGCBookkeepingRegions>d__8")]
public sealed virtual IEnumerable`1<ClrNativeHeapInfo> EnumerateGCBookkeepingRegions();
    [IteratorStateMachineAttribute("Microsoft.Diagnostics.Runtime.DacImplementation.DacNativeHeaps/<EnumerateSyncBlockCleanupData>d__9")]
public sealed virtual IEnumerable`1<ClrSyncBlockCleanupData> EnumerateSyncBlockCleanupData();
    private NativeHeapKind[] GetNativeHeaps();
    [IteratorStateMachineAttribute("Microsoft.Diagnostics.Runtime.DacImplementation.DacNativeHeaps/<EnumerateJitManagerHeaps>d__11")]
public sealed virtual IEnumerable`1<ClrNativeHeapInfo> EnumerateJitManagerHeaps(ulong jitManager);
    [IteratorStateMachineAttribute("Microsoft.Diagnostics.Runtime.DacImplementation.DacNativeHeaps/<EnumerateDomainHeaps>d__12")]
public sealed virtual IEnumerable`1<ClrNativeHeapInfo> EnumerateDomainHeaps(ulong domain);
    [IteratorStateMachineAttribute("Microsoft.Diagnostics.Runtime.DacImplementation.DacNativeHeaps/<EnumerateLoaderAllocatorNativeHeaps>d__13")]
public sealed virtual IEnumerable`1<ClrNativeHeapInfo> EnumerateLoaderAllocatorNativeHeaps(ulong loaderAllocator);
    [IteratorStateMachineAttribute("Microsoft.Diagnostics.Runtime.DacImplementation.DacNativeHeaps/<LegacyEnumerateStubHeaps>d__14")]
private IEnumerable`1<ClrNativeHeapInfo> LegacyEnumerateStubHeaps(ulong domain);
    private void TraverseOneStubKind(ulong domain, List`1<ClrNativeHeapInfo> result, VCSHeapType vcsType, NativeHeapKind heapKind);
    private IEnumerable`1<ClrNativeHeapInfo> LegacyEnumerateLoaderAllocatorHeaps(ulong loaderHeap, LoaderHeapKind loaderHeapKind, NativeHeapKind nativeHeapKind);
    private ulong FixupHeapAddress(ulong loaderHeap, LoaderHeapKind loaderHeapKind, bool normalNeedsAdjustment);
    public sealed virtual IEnumerable`1<ClrNativeHeapInfo> EnumerateThunkHeaps(ulong thunkHeapAddress);
    internal static ulong SanitizeSize(IntPtr size);
    private HResult TraverseLoaderHeap(ulong address, LoaderHeapKind kind, LoaderHeapTraverse callback);
    private static HResult TraverseLoaderHeap(ClrInfo clrInfo, SOSDac sos, ISOSDac13 sos13, ulong address, LoaderHeapKind kind, UInt32 pointerSize, LoaderHeapTraverse callback);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.Diagnostics.Runtime.DacImplementation.DacRuntime : object {
    private IDataReader _dataReader;
    private ClrDataProcess _dac;
    private SOSDac _sos;
    [NullableAttribute("2")]
private ISOSDac13 _sos13;
    public DacRuntime(ClrInfo clrInfo, ClrDataProcess dac, SOSDac sos, ISOSDac13 sos13);
    [IteratorStateMachineAttribute("Microsoft.Diagnostics.Runtime.DacImplementation.DacRuntime/<EnumerateThreads>d__5")]
public sealed virtual IEnumerable`1<ClrThreadInfo> EnumerateThreads();
    [IteratorStateMachineAttribute("Microsoft.Diagnostics.Runtime.DacImplementation.DacRuntime/<EnumerateAppDomains>d__6")]
public sealed virtual IEnumerable`1<AppDomainInfo> EnumerateAppDomains();
    private AppDomainInfo CreateAppDomainInfo(ulong address, AppDomainKind kind, string name);
    public sealed virtual IEnumerable`1<ulong> GetModuleList(ulong domain);
    [IteratorStateMachineAttribute("Microsoft.Diagnostics.Runtime.DacImplementation.DacRuntime/<EnumerateHandles>d__9")]
public sealed virtual IEnumerable`1<ClrHandleInfo> EnumerateHandles();
    [IteratorStateMachineAttribute("Microsoft.Diagnostics.Runtime.DacImplementation.DacRuntime/<EnumerateClrJitManagers>d__10")]
public sealed virtual IEnumerable`1<JitManagerInfo> EnumerateClrJitManagers();
    [NullableContextAttribute("2")]
public sealed virtual string GetJitHelperFunctionName(ulong address);
    [CompilerGeneratedAttribute]
private IEnumerable`1<ClrDataAddress> <GetModuleList>b__8_0(ClrDataAddress assembly);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
internal class Microsoft.Diagnostics.Runtime.DacImplementation.DacServiceProvider : object {
    [NullableAttribute("1")]
private ClrInfo _clrInfo;
    [NullableAttribute("1")]
private IDataReader _dataReader;
    [NullableAttribute("1")]
private DacLibrary _dac;
    [NullableAttribute("1")]
private ClrDataProcess _process;
    [NullableAttribute("1")]
private SOSDac _sos;
    private SOSDac6 _sos6;
    private SOSDac8 _sos8;
    private SosDac12 _sos12;
    private ISOSDac13 _sos13;
    private SosDac14 _sos14;
    private IAbstractClrNativeHeaps _nativeHeaps;
    private IAbstractComHelpers _com;
    private IAbstractHeap _heapHelper;
    private IAbstractLegacyThreadPool _threadPool;
    private IAbstractMethodLocator _methodLocator;
    private DacModuleHelpers _moduleHelper;
    private IAbstractRuntime _runtime;
    private IAbstractThreadHelpers _threadHelper;
    private IAbstractTypeHelpers _typeHelper;
    private bool _disposed;
    [CompilerGeneratedAttribute]
private bool <IsThreadSafe>k__BackingField;
    public bool IsThreadSafe { get; }
    public bool CanFlush { get; }
    [NullableContextAttribute("1")]
public DacServiceProvider(ClrInfo clrInfo, DacLibrary library);
    public sealed virtual void Dispose();
    [NullableContextAttribute("1")]
public sealed virtual object GetService(Type serviceType);
    [CompilerGeneratedAttribute]
public sealed virtual bool get_IsThreadSafe();
    public sealed virtual bool get_CanFlush();
    public sealed virtual void Flush();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.Diagnostics.Runtime.DacImplementation.DacThreadHelpers : object {
    private ClrDataProcess _dac;
    private SOSDac _sos;
    private IDataReader _dataReader;
    public DacThreadHelpers(ClrDataProcess dac, SOSDac sos, IDataReader reader);
    [IteratorStateMachineAttribute("Microsoft.Diagnostics.Runtime.DacImplementation.DacThreadHelpers/<EnumerateStackRoots>d__4")]
public sealed virtual IEnumerable`1<StackRootInfo> EnumerateStackRoots(UInt32 osThreadId, bool traceErrors);
    [IteratorStateMachineAttribute("Microsoft.Diagnostics.Runtime.DacImplementation.DacThreadHelpers/<EnumerateStackTrace>d__5")]
public sealed virtual IEnumerable`1<StackFrameInfo> EnumerateStackTrace(UInt32 osThreadId, bool includeContext, bool traceErrors);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.Diagnostics.Runtime.DacImplementation.DacTypeHelpers : object {
    private string UnloadedTypeName;
    private ClrDataProcess _clrDataProcess;
    private SOSDac _sos;
    [NullableAttribute("2")]
private SOSDac6 _sos6;
    [NullableAttribute("2")]
private SOSDac8 _sos8;
    [NullableAttribute("2")]
private SosDac14 _sos14;
    private IDataReader _dataReader;
    private DacModuleHelpers _moduleHelpers;
    public DacTypeHelpers(ClrDataProcess clrDataProcess, SOSDac sos, SOSDac6 sos6, SOSDac8 sos8, SosDac14 sos14, IDataReader dataReader, DacModuleHelpers moduleHelpers);
    public sealed virtual bool GetTypeInfo(ulong methodTable, TypeInfo& info);
    [NullableContextAttribute("2")]
public sealed virtual string GetTypeName(ulong module, ulong methodTable, int token);
    [NullableContextAttribute("2")]
public string GetTypeByToken(ulong module, int token);
    private static string GetNameFromToken(IAbstractMetadataReader import, int token);
    public sealed virtual ulong GetLoaderAllocatorHandle(ulong mt);
    public sealed virtual ulong GetAssemblyLoadContextAddress(ulong mt);
    public sealed virtual bool GetObjectArrayInformation(ulong objRef, ObjectArrayInformation& data);
    [IteratorStateMachineAttribute("Microsoft.Diagnostics.Runtime.DacImplementation.DacTypeHelpers/<EnumerateMethodsForType>d__16")]
public sealed virtual IEnumerable`1<MethodInfo> EnumerateMethodsForType(ulong methodTable);
    [IteratorStateMachineAttribute("Microsoft.Diagnostics.Runtime.DacImplementation.DacTypeHelpers/<EnumerateFields>d__17")]
public sealed virtual IEnumerable`1<FieldInfo> EnumerateFields(TypeInfo type, int baseFieldCount);
    public ulong GetStaticFieldAddress(AppDomainInfo& appDomain, ClrModuleInfo& module, TypeInfo& type, FieldInfo& field);
    public ulong GetThreadStaticFieldAddress(ulong threadAddress, ClrModuleInfo& module, TypeInfo& type, FieldInfo& field);
    private bool IsInitialized(DomainLocalModuleData& data, int token);
    [NullableContextAttribute("2")]
public sealed virtual string GetMethodSignature(ulong methodDesc);
    public sealed virtual ulong GetILForModule(ulong address, UInt32 rva);
    [NullableContextAttribute("0")]
public ImmutableArray`1<ILToNativeMap> GetILMap(ulong ip, HotColdRegions& hotCold);
    private static ulong FindEnd(HotColdRegions& reg, ulong address);
    private sealed virtual override ImmutableArray`1<ILToNativeMap> Microsoft.Diagnostics.Runtime.AbstractDac.IAbstractTypeHelpers.GetILMap(ulong ip, HotColdRegions& modreq(System.Runtime.InteropServices.InAttribute) hotCold);
    private sealed virtual override ulong Microsoft.Diagnostics.Runtime.AbstractDac.IAbstractTypeHelpers.GetStaticFieldAddress(AppDomainInfo& modreq(System.Runtime.InteropServices.InAttribute) appDomain, ClrModuleInfo& modreq(System.Runtime.InteropServices.InAttribute) module, TypeInfo& modreq(System.Runtime.InteropServices.InAttribute) typeInfo, FieldInfo& modreq(System.Runtime.InteropServices.InAttribute) field);
    private sealed virtual override ulong Microsoft.Diagnostics.Runtime.AbstractDac.IAbstractTypeHelpers.GetThreadStaticFieldAddress(ulong threadAddress, ClrModuleInfo& modreq(System.Runtime.InteropServices.InAttribute) module, TypeInfo& modreq(System.Runtime.InteropServices.InAttribute) typeInfo, FieldInfo& modreq(System.Runtime.InteropServices.InAttribute) field);
}
[IsReadOnlyAttribute]
internal class Microsoft.Diagnostics.Runtime.DacInterface.AppDomainData : ValueType {
    public ClrDataAddress Address;
    public ClrDataAddress SecurityDescriptor;
    public ClrDataAddress LowFrequencyHeap;
    public ClrDataAddress HighFrequencyHeap;
    public ClrDataAddress StubHeap;
    public ClrDataAddress DomainLocalBlock;
    public ClrDataAddress DomainLocalModules;
    public int Id;
    public int AssemblyCount;
    public int FailedAssemblyCount;
    public int Stage;
}
[IsReadOnlyAttribute]
internal class Microsoft.Diagnostics.Runtime.DacInterface.AppDomainStoreData : ValueType {
    public ClrDataAddress SharedDomain;
    public ClrDataAddress SystemDomain;
    public int AppDomainCount;
}
[IsReadOnlyAttribute]
internal class Microsoft.Diagnostics.Runtime.DacInterface.AssemblyData : ValueType {
    public ClrDataAddress Address;
    public ClrDataAddress ClassLoader;
    public ClrDataAddress ParentDomain;
    public ClrDataAddress AppDomain;
    public ClrDataAddress AssemblySecurityDescriptor;
    public int Dynamic;
    public int ModuleCount;
    public UInt32 LoadContext;
    public int IsDomainNeutral;
    public UInt32 LocationFlags;
}
[IsReadOnlyAttribute]
internal class Microsoft.Diagnostics.Runtime.DacInterface.CcwData : ValueType {
    public ClrDataAddress OuterIUnknown;
    public ClrDataAddress ManagedObject;
    public ClrDataAddress Handle;
    public ClrDataAddress CCWAddress;
    public int RefCount;
    public int InterfaceCount;
    public UInt32 IsNeutered;
    public int JupiterRefCount;
    public UInt32 IsPegged;
    public UInt32 IsGlobalPegged;
    public UInt32 HasStrongRef;
    public UInt32 IsExtendsCOMObject;
    public UInt32 HasWeakReference;
    public UInt32 IsAggregated;
}
[IsReadOnlyAttribute]
[DebuggerDisplayAttribute("{AsUInt64()}")]
internal class Microsoft.Diagnostics.Runtime.DacInterface.ClrDataAddress : ValueType {
    [CompilerGeneratedAttribute]
private long <Value>k__BackingField;
    public long Value { get; }
    public ClrDataAddress(long value);
    [CompilerGeneratedAttribute]
public long get_Value();
    public static ulong op_Implicit(ClrDataAddress cda);
    public static ClrDataAddress op_Implicit(ulong value);
    private ulong AsUInt64();
}
internal class Microsoft.Diagnostics.Runtime.DacInterface.ClrDataMethod : CallableCOMWrapper {
    private static Guid IID_IXCLRDataMethodInstance;
    [IsReadOnlyAttribute]
private IXCLRDataMethodInstanceVTable& modreq(System.Runtime.InteropServices.InAttribute) VTable { get; }
    [NullableContextAttribute("1")]
public ClrDataMethod(DacLibrary library, IntPtr pUnk);
    private static ClrDataMethod();
    private IXCLRDataMethodInstanceVTable& modreq(System.Runtime.InteropServices.InAttribute) get_VTable();
    [NullableContextAttribute("2")]
public ILToNativeMap[] GetILToNativeMap();
}
internal class Microsoft.Diagnostics.Runtime.DacInterface.ClrDataModule : CallableCOMWrapper {
    private static UInt32 DACDATAMODULEPRIV_REQUEST_GET_MODULEDATA;
    private static Guid IID_IXCLRDataModule;
    [IsReadOnlyAttribute]
private IClrDataModuleVTable& modreq(System.Runtime.InteropServices.InAttribute) VTable { get; }
    [NullableContextAttribute("1")]
public ClrDataModule(DacLibrary library, IntPtr pUnknown);
    private static ClrDataModule();
    private IClrDataModuleVTable& modreq(System.Runtime.InteropServices.InAttribute) get_VTable();
    public HResult GetModuleData(ExtendedModuleData& data);
    [NullableContextAttribute("2")]
public string GetName();
    [NullableContextAttribute("2")]
public string GetFileName();
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
internal class Microsoft.Diagnostics.Runtime.DacInterface.ClrDataProcess : CallableCOMWrapper {
    private static Guid IID_IXCLRDataProcess;
    [NullableAttribute("1")]
private DacLibrary _library;
    [IsReadOnlyAttribute]
private IXCLRDataProcessVTable& modreq(System.Runtime.InteropServices.InAttribute) VTable { get; }
    [NullableContextAttribute("1")]
public ClrDataProcess(DacLibrary library, IntPtr pUnknown);
    [NullableContextAttribute("1")]
public ClrDataProcess(DacLibrary library, CallableCOMWrapper toClone);
    private static ClrDataProcess();
    private IXCLRDataProcessVTable& modreq(System.Runtime.InteropServices.InAttribute) get_VTable();
    public SOSDac CreateSOSDacInterface();
    public SOSDac6 CreateSOSDacInterface6();
    public SOSDac8 CreateSOSDacInterface8();
    public SosDac12 CreateSOSDacInterface12();
    public ISOSDac13 CreateSOSDacInterface13();
    public SosDac14 CreateSOSDacInterface14();
    public void Flush();
    [NullableContextAttribute("0")]
public HResult Request(UInt32 reqCode, ReadOnlySpan`1<byte> input, Span`1<byte> output);
    public ClrStackWalk CreateStackWalk(UInt32 id, UInt32 flags);
    [NullableContextAttribute("1")]
public IEnumerable`1<ClrDataMethod> EnumerateMethodInstancesByAddress(ClrDataAddress addr);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.Diagnostics.Runtime.DacInterface.ClrDataTask : CallableCOMWrapper {
    private static Guid IID_IXCLRDataTask;
    [IsReadOnlyAttribute]
private ClrDataTaskVTable& modreq(System.Runtime.InteropServices.InAttribute) VTable { get; }
    public ClrDataTask(DacLibrary library, IntPtr pUnk);
    private static ClrDataTask();
    private ClrDataTaskVTable& modreq(System.Runtime.InteropServices.InAttribute) get_VTable();
    public ClrStackWalk CreateStackWalk(DacLibrary library, UInt32 flags);
}
[IsReadOnlyAttribute]
internal class Microsoft.Diagnostics.Runtime.DacInterface.ClrDataTaskVTable : ValueType {
    private IntPtr GetProcess;
    private IntPtr GetCurrentAppDomain;
    private IntPtr GetUniqueID;
    private IntPtr GetFlags;
    private IntPtr IsSameObject;
    private IntPtr GetManagedObject;
    private IntPtr GetDesiredExecutionState;
    private IntPtr SetDesiredExecutionState;
    public method CreateStackWalk;
    private IntPtr GetOSThreadID;
    private IntPtr GetContext;
    private IntPtr SetContext;
    private IntPtr GetCurrentExceptionState;
    private IntPtr Request;
    private IntPtr GetName;
    private IntPtr GetLastExceptionState;
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.Diagnostics.Runtime.DacInterface.ClrStackWalk : CallableCOMWrapper {
    private static Guid IID_IXCLRDataStackWalk;
    [IsReadOnlyAttribute]
private IXCLRDataStackWalkVTable& modreq(System.Runtime.InteropServices.InAttribute) VTable { get; }
    public ClrStackWalk(DacLibrary library, IntPtr pUnk);
    private static ClrStackWalk();
    private IXCLRDataStackWalkVTable& modreq(System.Runtime.InteropServices.InAttribute) get_VTable();
    public ClrDataAddress GetFrameVtable();
    public HResult Next();
    public HResult GetContext(UInt32 contextFlags, int contextBufSize, Int32& contextSize, Byte[] buffer);
}
[IsReadOnlyAttribute]
internal class Microsoft.Diagnostics.Runtime.DacInterface.CodeHeaderData : ValueType {
    public ClrDataAddress GCInfo;
    public UInt32 JITType;
    public ClrDataAddress MethodDesc;
    public ClrDataAddress MethodStart;
    public UInt32 MethodSize;
    public ClrDataAddress ColdRegionStart;
    public UInt32 ColdRegionSize;
    public UInt32 HotRegionSize;
}
[IsReadOnlyAttribute]
internal class Microsoft.Diagnostics.Runtime.DacInterface.COMInterfacePointerData : ValueType {
    public ClrDataAddress MethodTable;
    public ClrDataAddress InterfacePointer;
    public ClrDataAddress ComContext;
}
[IsReadOnlyAttribute]
internal class Microsoft.Diagnostics.Runtime.DacInterface.CommonMethodTables : ValueType {
    public ClrDataAddress ArrayMethodTable;
    public ClrDataAddress StringMethodTable;
    public ClrDataAddress ObjectMethodTable;
    public ClrDataAddress ExceptionMethodTable;
    public ClrDataAddress FreeMethodTable;
}
internal class Microsoft.Diagnostics.Runtime.DacInterface.DacDataTarget : object {
    internal static Guid IID_IDacDataTarget;
    internal static Guid IID_IMetadataLocator;
    internal static Guid IID_ICLRRuntimeLocator;
    public static ulong MagicCallbackConstant;
    [NullableAttribute("1")]
private DataTarget _dataTarget;
    [NullableAttribute("1")]
private IDataReader _dataReader;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private ModuleInfo[] modreq(System.Runtime.CompilerServices.IsVolatile) _modules;
    [NullableAttribute("2")]
private Action _callback;
    private Int32 modreq(System.Runtime.CompilerServices.IsVolatile) _callbackContext;
    [CompilerGeneratedAttribute]
private ulong <RuntimeBaseAddress>k__BackingField;
    public ulong RuntimeBaseAddress { get; }
    public IMAGE_FILE_MACHINE MachineType { get; }
    public int PointerSize { get; }
    [NullableContextAttribute("1")]
public DacDataTarget(DataTarget dataTarget, ulong runtimeBaseAddress);
    private static DacDataTarget();
    [CompilerGeneratedAttribute]
public ulong get_RuntimeBaseAddress();
    public void EnterMagicCallbackContext();
    public void ExitMagicCallbackContext();
    [NullableContextAttribute("1")]
public void SetMagicCallback(Action flushCallback);
    public IMAGE_FILE_MACHINE get_MachineType();
    public int get_PointerSize();
    public void Flush();
    [NullableContextAttribute("1")]
private ModuleInfo[] GetModules();
    [NullableContextAttribute("2")]
private ModuleInfo GetModule(ulong address);
    [NullableContextAttribute("1")]
public ulong GetImageBase(string imagePath);
    public bool ReadVirtual(ClrDataAddress cda, IntPtr buffer, int bytesRequested, Int32& bytesRead);
    public bool GetThreadContext(UInt32 threadID, UInt32 contextFlags, int contextSize, IntPtr context);
    public int GetMetadata(string fileName, int imageTimestamp, int imageSize, IntPtr mvid, UInt32 mdRva, UInt32 flags, UInt32 bufferSize, IntPtr buffer, Int32* pDataSize);
}
internal class Microsoft.Diagnostics.Runtime.DacInterface.DacDataTargetCOM : ComWrappers {
    private static ComInterfaceEntry* s_wrapperEntry;
    [NullableAttribute("1")]
[CompilerGeneratedAttribute]
private static DacDataTargetCOM <Instance>k__BackingField;
    [NullableAttribute("1")]
public static DacDataTargetCOM Instance { get; }
    private static DacDataTargetCOM();
    [NullableContextAttribute("1")]
[CompilerGeneratedAttribute]
public static DacDataTargetCOM get_Instance();
    [NullableContextAttribute("1")]
public static IntPtr CreateIDacDataTarget(DacDataTarget dacData);
    private static ComInterfaceEntry* InitializeComInterfaceEntry();
    protected virtual ComInterfaceEntry* ComputeVtables(object obj, CreateComInterfaceFlags flags, Int32& count);
    [NullableContextAttribute("2")]
protected virtual object CreateObject(IntPtr externalComObject, CreateObjectFlags flags);
    [NullableContextAttribute("1")]
protected virtual void ReleaseObjects(IEnumerable objects);
}
[IsReadOnlyAttribute]
internal class Microsoft.Diagnostics.Runtime.DacInterface.DacHeapAnalyzeData : ValueType {
    public ClrDataAddress HeapAddress;
    public ClrDataAddress InternalRootArray;
    public ulong InternalRootArrayIndex;
    public bool HeapAnalyzeSuccess;
}
[IsReadOnlyAttribute]
internal class Microsoft.Diagnostics.Runtime.DacInterface.DacOOMData : ValueType {
    public OutOfMemoryReason Reason;
    public ulong AllocSize;
    public ulong AvailablePageFileMB;
    public ulong GCIndex;
    public GetMemoryFailureReason GetMemoryFailure;
    public ulong Size;
    public int IsLOH;
}
[IsReadOnlyAttribute]
internal class Microsoft.Diagnostics.Runtime.DacInterface.DomainLocalModuleData : ValueType {
    public ClrDataAddress AppDomainAddress;
    public ulong ModuleID;
    public ClrDataAddress ClassData;
    public ClrDataAddress DynamicClassTable;
    public ClrDataAddress GCStaticDataStart;
    public ClrDataAddress NonGCStaticDataStart;
}
internal class Microsoft.Diagnostics.Runtime.DacInterface.ExtendedModuleData : ValueType {
    public int IsDynamic;
    public int IsInMemory;
    public int IsFlatLayout;
    public ClrDataAddress PEFile;
    public ClrDataAddress LoadedPEAddress;
    public ulong LoadedPESize;
    public ClrDataAddress InMemoryPdbAddress;
    public ulong InMemoryPdbSize;
}
[IsReadOnlyAttribute]
internal class Microsoft.Diagnostics.Runtime.DacInterface.FieldData : ValueType {
    public UInt32 ElementType;
    public UInt32 SigType;
    public ClrDataAddress TypeMethodTable;
    public ClrDataAddress TypeModule;
    public UInt32 TypeToken;
    public UInt32 FieldToken;
    public ClrDataAddress MTOfEnclosingClass;
    public UInt32 Offset;
    public UInt32 IsThreadLocal;
    public UInt32 IsContextLocal;
    public UInt32 IsStatic;
    public ClrDataAddress NextField;
}
[IsReadOnlyAttribute]
internal class Microsoft.Diagnostics.Runtime.DacInterface.GCInfo : ValueType {
    public int ServerMode;
    public int GCStructuresValid;
    public int HeapCount;
    public int MaxGeneration;
}
[IsReadOnlyAttribute]
internal class Microsoft.Diagnostics.Runtime.DacInterface.GenerationData : ValueType {
    public ClrDataAddress StartSegment;
    public ClrDataAddress AllocationStart;
    public ClrDataAddress AllocationContextPointer;
    public ClrDataAddress AllocationContextLimit;
}
[IsReadOnlyAttribute]
internal class Microsoft.Diagnostics.Runtime.DacInterface.HandleData : ValueType {
    public ClrDataAddress AppDomain;
    public ClrDataAddress Handle;
    public ClrDataAddress Secondary;
    public UInt32 Type;
    public UInt32 StrongReference;
    public UInt32 RefCount;
    public UInt32 JupiterRefCount;
    public UInt32 IsPegged;
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[IsReadOnlyAttribute]
internal class Microsoft.Diagnostics.Runtime.DacInterface.HeapDetails : ValueType {
    public ClrDataAddress Address;
    public ClrDataAddress Allocated;
    public ClrDataAddress MarkArray;
    public ClrDataAddress CurrentGCState;
    public ClrDataAddress NextSweepObj;
    public ClrDataAddress SavedSweepEphemeralSeg;
    public ClrDataAddress SavedSweepEphemeralStart;
    public ClrDataAddress BackgroundSavedLowestAddress;
    public ClrDataAddress BackgroundSavedHighestAddress;
    public GenerationData[] GenerationTable;
    public ClrDataAddress EphemeralHeapSegment;
    public ClrDataAddress[] FinalizationFillPointers;
    public ClrDataAddress LowestAddress;
    public ClrDataAddress HighestAddress;
    public ClrDataAddress CardTable;
    public ulong EphemeralAllocContextPtr { get; }
    public ulong EphemeralAllocContextLimit { get; }
    public ulong get_EphemeralAllocContextPtr();
    public ulong get_EphemeralAllocContextLimit();
}
[IsReadOnlyAttribute]
internal class Microsoft.Diagnostics.Runtime.DacInterface.IMetaDataImportVTable : ValueType {
    public method CloseEnum;
    private IntPtr CountEnum;
    private IntPtr ResetEnum;
    private IntPtr EnumTypeDefs;
    public method EnumInterfaceImpls;
    private IntPtr EnumTypeRefs;
    private IntPtr FindTypeDefByName;
    private IntPtr GetScopeProps;
    private IntPtr GetModuleFromScope;
    public method GetTypeDefProps;
    public method GetInterfaceImplProps;
    public method GetTypeRefProps;
    private IntPtr ResolveTypeRef;
    private IntPtr EnumMembers;
    private IntPtr EnumMembersWithName;
    private IntPtr EnumMethods;
    private IntPtr EnumMethodsWithName;
    public method EnumFields;
    private IntPtr EnumFieldsWithName;
    private IntPtr EnumParams;
    private IntPtr EnumMemberRefs;
    private IntPtr EnumMethodImpls;
    private IntPtr EnumPermissionSets;
    private IntPtr FindMember;
    private IntPtr FindMethod;
    private IntPtr FindField;
    private IntPtr FindMemberRef;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public method GetMethodProps;
    private IntPtr GetMemberRefProps;
    private IntPtr EnumProperties;
    private IntPtr EnumEvents;
    private IntPtr GetEventProps;
    private IntPtr EnumMethodSemantics;
    private IntPtr GetMethodSemantics;
    private IntPtr GetClassLayout;
    private IntPtr GetFieldMarshal;
    public method GetRVA;
    private IntPtr GetPermissionSetProps;
    public method GetSigFromToken;
    private IntPtr GetModuleRefProps;
    private IntPtr EnumModuleRefs;
    private IntPtr GetTypeSpecFromToken;
    private IntPtr GetNameFromToken;
    private IntPtr EnumUnresolvedMethods;
    private IntPtr GetUserString;
    private IntPtr GetPinvokeMap;
    private IntPtr EnumSignatures;
    private IntPtr EnumTypeSpecs;
    private IntPtr EnumUserStrings;
    private IntPtr GetParamForMethodIndex;
    private IntPtr EnumCustomAttributes;
    private IntPtr GetCustomAttributeProps;
    private IntPtr FindTypeRef;
    private IntPtr GetMemberProps;
    public method GetFieldProps;
    private IntPtr GetPropertyProps;
    private IntPtr GetParamProps;
    public method GetCustomAttributeByName;
    private IntPtr IsValidToken;
    public method GetNestedClassProps;
    private IntPtr GetNativeCallConvFromSig;
    private IntPtr IsGlobal;
    public method EnumGenericParams;
    public method GetGenericParamProps;
    private IntPtr GetMethodSpecProps;
    private IntPtr EnumGenericParamConstraints;
    private IntPtr GetGenericParamConstraintProps;
    private IntPtr GetPEKind;
    private IntPtr GetVersionString;
    private IntPtr EnumMethodSpecs;
}
[NullableContextAttribute("2")]
internal interface Microsoft.Diagnostics.Runtime.DacInterface.ISOSDac13 {
    public abstract virtual ClrDataAddress GetDomainLoaderAllocator(ClrDataAddress domainAddress);
    public abstract virtual SosMemoryEnum GetGCBookkeepingMemoryRegions();
    public abstract virtual SosMemoryEnum GetGCFreeRegions();
    public abstract virtual SosMemoryEnum GetHandleTableRegions();
    [NullableContextAttribute("1")]
public abstract virtual String[] GetLoaderAllocatorHeapNames();
    public abstract virtual ValueTuple`2[] GetLoaderAllocatorHeaps(ClrDataAddress loaderAllocator);
    public abstract virtual bool LockedFlush();
    [NullableContextAttribute("1")]
public abstract virtual HResult TraverseLoaderHeap(ulong heap, LoaderHeapKind kind, LoaderHeapTraverse callback);
}
[IsReadOnlyAttribute]
internal class Microsoft.Diagnostics.Runtime.DacInterface.ISOSDac6VTable : ValueType {
    public method GetMethodTableCollectibleData;
}
[IsReadOnlyAttribute]
internal class Microsoft.Diagnostics.Runtime.DacInterface.ISOSDacVTable : ValueType {
    public method GetThreadStoreData;
    public method GetAppDomainStoreData;
    public method GetAppDomainList;
    public method GetAppDomainData;
    public method GetAppDomainName;
    public IntPtr GetDomainFromContext;
    public method GetAssemblyList;
    public method GetAssemblyData;
    public method GetAssemblyName;
    public method GetModule;
    public method GetModuleData;
    public method TraverseModuleMap;
    public method GetAssemblyModuleList;
    public method GetILForModule;
    public method GetThreadData;
    public method GetThreadFromThinlockID;
    public IntPtr GetStackLimits;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public method GetMethodDescData;
    public method GetMethodDescPtrFromIP;
    public method GetMethodDescName;
    public method GetMethodDescPtrFromFrame;
    public method GetMethodDescFromToken;
    private IntPtr GetMethodDescTransparencyData;
    public method GetCodeHeaderData;
    public method GetJitManagerList;
    public method GetJitHelperFunctionName;
    private IntPtr GetJumpThunkTarget;
    public method GetThreadpoolData;
    public method GetWorkRequestData;
    private IntPtr GetHillClimbingLogEntry;
    public method GetObjectData;
    public IntPtr GetObjectStringData;
    public IntPtr GetObjectClassName;
    public method GetMethodTableName;
    public method GetMethodTableData;
    public method GetMethodTableSlot;
    public method GetMethodTableFieldData;
    private IntPtr GetMethodTableTransparencyData;
    public method GetMethodTableForEEClass;
    public method GetFieldDescData;
    public method GetFrameName;
    public IntPtr GetPEFileBase;
    public method GetPEFileName;
    public method GetGCHeapData;
    public method GetGCHeapList;
    public method GetGCHeapDetails;
    public method GetGCHeapStaticData;
    public method GetHeapSegmentData;
    public method GetOOMData;
    public method GetOOMStaticData;
    public method GetHeapAnalyzeData;
    public method GetHeapAnalyzeStaticData;
    private IntPtr GetDomainLocalModuleData;
    public method GetDomainLocalModuleDataFromAppDomain;
    public method GetDomainLocalModuleDataFromModule;
    public method GetThreadLocalModuleData;
    public method GetSyncBlockData;
    public method GetSyncBlockCleanupData;
    public method GetHandleEnum;
    public method GetHandleEnumForTypes;
    private IntPtr GetHandleEnumForGC;
    private IntPtr TraverseEHInfo;
    private IntPtr GetNestedExceptionData;
    public IntPtr GetStressLogAddress;
    public method TraverseLoaderHeap;
    public method GetCodeHeapList;
    public method TraverseVirtCallStubHeap;
    public method GetUsefulGlobals;
    public IntPtr GetClrWatsonBuckets;
    public method GetTLSIndex;
    public IntPtr GetDacModuleHandle;
    public method GetRCWData;
    public method GetRCWInterfaces;
    public method GetCCWData;
    public method GetCCWInterfaces;
    [NativeIntegerAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public method TraverseRCWCleanupList;
    public method GetStackReferences;
    public method GetRegisterName;
    public IntPtr GetThreadAllocData;
    public IntPtr GetHeapAllocData;
    public IntPtr GetFailedAssemblyList;
    public IntPtr GetPrivateBinPaths;
    public IntPtr GetAssemblyLocation;
    public method GetAppDomainConfigFile;
    public method GetApplicationBase;
    public IntPtr GetFailedAssemblyData;
    public IntPtr GetFailedAssemblyLocation;
    public IntPtr GetFailedAssemblyDisplayName;
}
[IsReadOnlyAttribute]
internal class Microsoft.Diagnostics.Runtime.DacInterface.ISOSHandleEnumVTable : ValueType {
    private IntPtr Skip;
    private IntPtr Reset;
    private IntPtr GetCount;
    public method Next;
}
[IsReadOnlyAttribute]
internal class Microsoft.Diagnostics.Runtime.DacInterface.ISOSStackRefEnumVTable : ValueType {
    private IntPtr Skip;
    private IntPtr Reset;
    public method GetCount;
    public method Next;
}
[IsReadOnlyAttribute]
internal class Microsoft.Diagnostics.Runtime.DacInterface.IXCLRDataMethodInstanceVTable : ValueType {
    private IntPtr GetTypeInstance;
    private IntPtr GetDefinition;
    private IntPtr GetTokenAndScope;
    private IntPtr GetName;
    private IntPtr GetFlags;
    private IntPtr IsSameObject;
    private IntPtr GetEnCVersion;
    private IntPtr GetNumTypeArguments;
    private IntPtr GetTypeArgumentByIndex;
    private IntPtr GetILOffsetsByAddress;
    private IntPtr GetAddressRangesByILOffset;
    public method GetILAddressMap;
    private IntPtr StartEnumExtents;
    private IntPtr EnumExtent;
    private IntPtr EndEnumExtents;
    private IntPtr Request;
    private IntPtr GetRepresentativeEntryAddress;
}
[IsReadOnlyAttribute]
internal class Microsoft.Diagnostics.Runtime.DacInterface.IXCLRDataProcessVTable : ValueType {
    public method Flush;
    private IntPtr Unused_StartEnumTasks;
    private IntPtr EnumTask;
    private IntPtr EndEnumTasks;
    public method GetTaskByOSThreadID;
    private IntPtr GetTaskByUniqueID;
    private IntPtr GetFlags;
    private IntPtr IsSameObject;
    private IntPtr GetManagedObject;
    private IntPtr GetDesiredExecutionState;
    private IntPtr SetDesiredExecutionState;
    private IntPtr GetAddressType;
    private IntPtr GetRuntimeNameByAddress;
    private IntPtr StartEnumAppDomains;
    private IntPtr EnumAppDomain;
    private IntPtr EndEnumAppDomains;
    private IntPtr GetAppDomainByUniqueID;
    private IntPtr StartEnumAssemblie;
    private IntPtr EnumAssembly;
    private IntPtr EndEnumAssemblies;
    private IntPtr StartEnumModules;
    private IntPtr EnumModule;
    private IntPtr EndEnumModules;
    private IntPtr GetModuleByAddress;
    public method StartEnumMethodInstancesByAddress;
    public method EnumMethodInstanceByAddress;
    public method EndEnumMethodInstancesByAddress;
    private IntPtr GetDataByAddress;
    private IntPtr GetExceptionStateByExceptionRecord;
    private IntPtr TranslateExceptionRecordToNotification;
    public method Request;
}
[IsReadOnlyAttribute]
internal class Microsoft.Diagnostics.Runtime.DacInterface.IXCLRDataStackWalkVTable : ValueType {
    public method GetContext;
    private IntPtr GetContext2;
    public method Next;
    private IntPtr GetStackSizeSkipped;
    private IntPtr GetFrameType;
    public IntPtr GetFrame;
    public method Request;
    private IntPtr SetContext2;
}
[IsReadOnlyAttribute]
internal class Microsoft.Diagnostics.Runtime.DacInterface.JitCodeHeapInfo : ValueType {
    public CodeHeapKind Kind;
    public ClrDataAddress Address;
    public ClrDataAddress CurrentAddress;
}
[IsReadOnlyAttribute]
internal class Microsoft.Diagnostics.Runtime.DacInterface.JitManagerData : ValueType {
    public ClrDataAddress Address;
    public CodeHeapKind Kind;
    public ClrDataAddress HeapList;
}
[RequiresDynamicCodeAttribute("Requires dynamic code generation to build interfaces.")]
internal class Microsoft.Diagnostics.Runtime.DacInterface.LegacyDacDataTargetWrapper : COMCallableIUnknown {
    [NullableAttribute("1")]
private DacDataTarget _dacDataTarget;
    [CompilerGeneratedAttribute]
private IntPtr <IDacDataTarget>k__BackingField;
    public IntPtr IDacDataTarget { get; }
    [NullableContextAttribute("1")]
public LegacyDacDataTargetWrapper(DacDataTarget dacDataTarget, bool implementRuntimeLocator);
    [CompilerGeneratedAttribute]
public IntPtr get_IDacDataTarget();
    private int GetMachineType(IntPtr self, IMAGE_FILE_MACHINE& machineType);
    private int GetPointerSize(IntPtr _, Int32& pointerSize);
    [NullableContextAttribute("1")]
private int GetImageBase(IntPtr _, string imagePath, UInt64& baseAddress);
    private int ReadVirtual(IntPtr _, ClrDataAddress cda, IntPtr buffer, int bytesRequested, Int32& bytesRead);
    private int WriteVirtual(IntPtr self, ClrDataAddress address, IntPtr buffer, UInt32 bytesRequested, UInt32& bytesWritten);
    private int GetTLSValue(IntPtr self, UInt32 threadID, UInt32 index, UInt64& value);
    private int SetTLSValue(IntPtr self, UInt32 threadID, UInt32 index, ClrDataAddress value);
    private int GetCurrentThreadID(IntPtr self, UInt32& threadID);
    private int GetThreadContext(IntPtr self, UInt32 threadID, UInt32 contextFlags, int contextSize, IntPtr context);
    private int SetThreadContext(IntPtr self, UInt32 threadID, UInt32 contextSize, IntPtr context);
    private int Request(IntPtr self, UInt32 reqCode, UInt32 inBufferSize, IntPtr inBuffer, IntPtr outBufferSize, IntPtr& outBuffer);
    private int GetMetadata(IntPtr self, string fileName, int imageTimestamp, int imageSize, IntPtr mvid, UInt32 mdRva, UInt32 flags, UInt32 bufferSize, IntPtr buffer, Int32* pDataSize);
    private int GetRuntimeBase(IntPtr _, UInt64& address);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.Diagnostics.Runtime.DacInterface.MetadataImport : CallableCOMWrapper {
    public static Guid IID_IMetaDataImport;
    [IsReadOnlyAttribute]
private IMetaDataImportVTable& modreq(System.Runtime.InteropServices.InAttribute) VTable { get; }
    [NullableContextAttribute("2")]
public MetadataImport(RefCountedFreeLibrary library, IntPtr pUnknown);
    public MetadataImport(DacLibrary library, IntPtr pUnknown);
    private static MetadataImport();
    private IMetaDataImportVTable& modreq(System.Runtime.InteropServices.InAttribute) get_VTable();
    [IteratorStateMachineAttribute("Microsoft.Diagnostics.Runtime.DacInterface.MetadataImport/<EnumerateInterfaceImpls>d__5")]
public IEnumerable`1<int> EnumerateInterfaceImpls(int token);
    public bool GetMethodAttributes(int token, MethodAttributes& attrs);
    public UInt32 GetRva(int token);
    [NullableContextAttribute("2")]
public HResult GetTypeDefProperties(int token, String& name, TypeAttributes& attributes, Int32& mdParent);
    [NullableContextAttribute("2")]
public string GetTypeRefName(int token);
    public HResult GetCustomAttributeByName(int token, string name, IntPtr& data, UInt32& cbData);
    [NullableContextAttribute("2")]
public HResult GetFieldProps(int token, String& name, FieldAttributes& attrs, IntPtr& ppvSigBlob, Int32& pcbSigBlob, Int32& pdwCPlusTypeFlag, IntPtr& ppValue);
    [IteratorStateMachineAttribute("Microsoft.Diagnostics.Runtime.DacInterface.MetadataImport/<EnumerateFields>d__12")]
public IEnumerable`1<int> EnumerateFields(int token);
    internal HResult GetTypeDefAttributes(int token, TypeAttributes& attrs);
    public HResult GetNestedClassProperties(int token, Int32& enclosing);
    public HResult GetInterfaceImplProps(int token, Int32& mdClass, Int32& mdInterface);
    private void CloseEnum(IntPtr handle);
    [IteratorStateMachineAttribute("Microsoft.Diagnostics.Runtime.DacInterface.MetadataImport/<EnumerateGenericParams>d__17")]
public IEnumerable`1<int> EnumerateGenericParams(int token);
    [NullableContextAttribute("2")]
public bool GetGenericParamProps(int token, Int32& index, GenericParameterAttributes& attributes, String& name);
    public SigParser GetSigFromToken(int token);
    [CompilerGeneratedAttribute]
private bool <EnumerateInterfaceImpls>g__Enum|5_0(IntPtr& handle, int token, Int32[] tokens, int length, Int32& count);
    [CompilerGeneratedAttribute]
private bool <EnumerateFields>g__Enum|12_0(IntPtr& handle, int token, Int32[] tokens, int length, Int32& count);
    [CompilerGeneratedAttribute]
private bool <EnumerateGenericParams>g__Enum|17_0(IntPtr& handle, int token, Int32[] tokens, int length, Int32& count);
}
[IsReadOnlyAttribute]
internal class Microsoft.Diagnostics.Runtime.DacInterface.MethodDescData : ValueType {
    public UInt32 HasNativeCode;
    public UInt32 IsDynamic;
    public ushort SlotNumber;
    public ClrDataAddress NativeCodeAddr;
    public ClrDataAddress AddressOfNativeCodeSlot;
    public ClrDataAddress MethodDesc;
    public ClrDataAddress MethodTable;
    public ClrDataAddress Module;
    public UInt32 MDToken;
    public ClrDataAddress GCInfo;
    public ClrDataAddress GCStressCodeCopy;
    public ClrDataAddress ManagedDynamicMethodObject;
    public ClrDataAddress RequestedIP;
    public RejitData RejitDataCurrent;
    public RejitData RejitDataRequested;
    public UInt32 JittedRejitVersions;
}
[IsReadOnlyAttribute]
internal class Microsoft.Diagnostics.Runtime.DacInterface.MethodTableCollectibleData : ValueType {
    public ClrDataAddress LoaderAllocatorObjectHandle;
    public UInt32 Collectible;
}
[IsReadOnlyAttribute]
internal class Microsoft.Diagnostics.Runtime.DacInterface.MethodTableData : ValueType {
    public UInt32 IsFree;
    public ClrDataAddress Module;
    public ClrDataAddress EEClass;
    public ClrDataAddress ParentMethodTable;
    public ushort NumInterfaces;
    public ushort NumMethods;
    public ushort NumVtableSlots;
    public ushort NumVirtuals;
    public UInt32 BaseSize;
    public UInt32 ComponentSize;
    public UInt32 Token;
    public UInt32 AttrClass;
    public UInt32 Shared;
    public UInt32 Dynamic;
    public UInt32 ContainsPointers;
}
[IsReadOnlyAttribute]
internal class Microsoft.Diagnostics.Runtime.DacInterface.MethodTableFieldInfo : ValueType {
    public short NumInstanceFields;
    public short NumStaticFields;
    public short NumThreadStaticFields;
    public ClrDataAddress FirstFieldAddress;
    public short ContextStaticOffset;
    public short ContextStaticsSize;
}
internal enum Microsoft.Diagnostics.Runtime.DacInterface.MethodTableInitializationFlags : Enum {
    public int value__;
    public static MethodTableInitializationFlags Unknown;
    public static MethodTableInitializationFlags MethodTableInitialized;
    public static MethodTableInitializationFlags MethodTableInitializationFailed;
}
[IsReadOnlyAttribute]
internal class Microsoft.Diagnostics.Runtime.DacInterface.ModuleData : ValueType {
    public ClrDataAddress Address;
    public ClrDataAddress PEFile;
    public ClrDataAddress ILBase;
    public ClrDataAddress MetadataStart;
    public ulong MetadataSize;
    public ClrDataAddress Assembly;
    public UInt32 IsReflection;
    public UInt32 IsPEFile;
    public ulong BaseClassIndex;
    public ulong ModuleID;
    public UInt32 TransientFlags;
    public ClrDataAddress TypeDefToMethodTableMap;
    public ClrDataAddress TypeRefToMethodTableMap;
    public ClrDataAddress MethodDefToDescMap;
    public ClrDataAddress FieldDefToDescMap;
    public ClrDataAddress MemberRefToDescMap;
    public ClrDataAddress FileReferencesMap;
    public ClrDataAddress ManifestModuleReferencesMap;
    public ClrDataAddress LoaderAllocator;
    public ClrDataAddress ThunkHeap;
    public ulong ModuleIndex;
}
[IsReadOnlyAttribute]
internal class Microsoft.Diagnostics.Runtime.DacInterface.ObjectData : ValueType {
    public ClrDataAddress MethodTable;
    public UInt32 ObjectType;
    public ulong Size;
    public ClrDataAddress ElementTypeHandle;
    public UInt32 ElementType;
    public UInt32 Rank;
    public ulong NumComponents;
    public ulong ComponentSize;
    public ClrDataAddress ArrayDataPointer;
    public ClrDataAddress ArrayBoundsPointer;
    public ClrDataAddress ArrayLowerBoundsPointer;
    public ClrDataAddress RCW;
    public ClrDataAddress CCW;
}
[IsReadOnlyAttribute]
internal class Microsoft.Diagnostics.Runtime.DacInterface.RcwData : ValueType {
    public ClrDataAddress IdentityPointer;
    public ClrDataAddress IUnknownPointer;
    public ClrDataAddress ManagedObject;
    public ClrDataAddress JupiterObject;
    public ClrDataAddress VTablePointer;
    public ClrDataAddress CreatorThread;
    public ClrDataAddress CTXCookie;
    public int RefCount;
    public int InterfaceCount;
    public UInt32 IsJupiterObject;
    public UInt32 SupportsIInspectable;
    public UInt32 IsAggregated;
    public UInt32 IsContained;
    public UInt32 IsFreeThreaded;
    public UInt32 IsDisconnected;
}
[IsReadOnlyAttribute]
internal class Microsoft.Diagnostics.Runtime.DacInterface.RejitData : ValueType {
    private ClrDataAddress RejitID;
    private UInt32 Flags;
    private ClrDataAddress NativeCodeAddr;
}
[IsReadOnlyAttribute]
internal class Microsoft.Diagnostics.Runtime.DacInterface.SegmentData : ValueType {
    public ClrDataAddress Address;
    public ClrDataAddress Allocated;
    public ClrDataAddress Committed;
    public ClrDataAddress Reserved;
    public ClrDataAddress Used;
    public ClrDataAddress Start;
    public ClrDataAddress Next;
    public ClrDataAddress Heap;
    public ClrDataAddress HighAllocMark;
    public IntPtr Flags;
    public ClrDataAddress BackgroundAllocated;
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.Diagnostics.Runtime.DacInterface.SOSDac : CallableCOMWrapper {
    internal static Guid IID_ISOSDac;
    private DacLibrary _library;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private Dictionary`2 modreq(System.Runtime.CompilerServices.IsVolatile) _regNames;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private Dictionary`2 modreq(System.Runtime.CompilerServices.IsVolatile) _frameNames;
    [IsReadOnlyAttribute]
private ISOSDacVTable& modreq(System.Runtime.InteropServices.InAttribute) VTable { get; }
    [NullableContextAttribute("2")]
public SOSDac(DacLibrary library, IntPtr ptr);
    public SOSDac(DacLibrary lib, CallableCOMWrapper toClone);
    private static SOSDac();
    private ISOSDacVTable& modreq(System.Runtime.InteropServices.InAttribute) get_VTable();
    public RejitData[] GetRejitData(ulong md, ulong ip);
    public HResult GetMethodDescData(ulong md, ulong ip, MethodDescData& data);
    public HResult GetThreadStoreData(ThreadStoreData& data);
    [NullableContextAttribute("2")]
public string GetRegisterName(int index);
    public UInt32 GetTlsIndex();
    public ClrDataAddress GetThreadFromThinlockId(UInt32 id);
    [NullableContextAttribute("2")]
public string GetMethodDescName(ulong md);
    public ulong GetMethodTableSlot(ulong mt, UInt32 slot);
    public HResult GetThreadLocalModuleData(ulong thread, UInt32 index, ThreadLocalModuleData& data);
    public ulong GetILForModule(ulong moduleAddr, UInt32 rva);
    [NullableContextAttribute("2")]
public COMInterfacePointerData[] GetCCWInterfaces(ulong ccw, int count);
    [NullableContextAttribute("2")]
public COMInterfacePointerData[] GetRCWInterfaces(ulong ccw, int count);
    public HResult GetDomainLocalModuleDataFromModule(ulong module, DomainLocalModuleData& data);
    public HResult GetDomainLocalModuleDataFromAppDomain(ulong appDomain, int id, DomainLocalModuleData& data);
    public HResult GetWorkRequestData(ulong request, WorkRequestData& data);
    public HResult GetThreadPoolData(ThreadPoolData& data);
    public HResult GetSyncBlockData(int index, SyncBlockData& data);
    [NullableContextAttribute("2")]
public string GetAppBase(ulong domain);
    [NullableContextAttribute("2")]
public string GetConfigFile(ulong domain);
    public HResult GetCodeHeaderData(ulong ip, CodeHeaderData& codeHeaderData);
    public ClrDataAddress GetMethodDescPtrFromFrame(ulong frame);
    public ClrDataAddress GetMethodDescPtrFromIP(ulong frame);
    public string GetFrameName(ulong vtable);
    public HResult GetFieldInfo(ulong mt, MethodTableFieldInfo& data);
    public HResult GetFieldData(ulong fieldDesc, FieldData& data);
    public HResult GetObjectData(ulong obj, ObjectData& data);
    public HResult GetCCWData(ulong ccw, CcwData& data);
    public HResult GetRCWData(ulong rcw, RcwData& data);
    public IEnumerable`1<ValueTuple`4<ulong, ulong, ulong, bool>> EnumerateRCWCleanup(ulong cleanupList);
    public HResult GetSyncBlockCleanupData(ulong syncBlockCleanupPointer, SyncBlockCleanupData& data);
    [NullableContextAttribute("2")]
public ClrDataModule GetClrDataModule(ulong module);
    [NullableContextAttribute("2")]
public MetadataImport GetMetadataImport(ulong module);
    public HResult GetCommonMethodTables(CommonMethodTables& commonMTs);
    public ClrDataAddress[] GetAssemblyList(ulong appDomain);
    public ClrDataAddress[] GetAssemblyList(ulong appDomain, int count);
    public ClrDataAddress[] GetModuleList(ulong assembly);
    public ClrDataAddress[] GetModuleList(ulong assembly, int count);
    public HResult GetAssemblyData(ulong domain, ulong assembly, AssemblyData& data);
    public HResult GetAppDomainData(ulong addr, AppDomainData& data);
    [NullableContextAttribute("2")]
public string GetAppDomainName(ulong appDomain);
    [NullableContextAttribute("2")]
public string GetAssemblyName(ulong assembly);
    public HResult GetAppDomainStoreData(AppDomainStoreData& data);
    public HResult GetMethodTableData(ulong addr, MethodTableData& data);
    [NullableContextAttribute("2")]
public string GetMethodTableName(ulong mt);
    [NullableContextAttribute("2")]
public string GetJitHelperFunctionName(ulong addr);
    [NullableContextAttribute("2")]
public string GetPEFileName(ulong pefile);
    [NullableContextAttribute("0")]
private string GetString(method func, ulong addr, bool skipNull);
    [NullableContextAttribute("0")]
private string GetAsciiString(method func, ulong addr);
    public ClrDataAddress GetMethodTableByEEClass(ulong eeclass);
    public HResult GetModuleData(ulong module, ModuleData& data);
    [NullableContextAttribute("0")]
private ClrDataAddress[] GetModuleOrAssembly(ulong address, int count, method func);
    public ClrDataAddress[] GetAppDomainList(int count);
    public HResult GetThreadData(ulong address, ThreadData& data);
    public HResult GetGCHeapData(GCInfo& data);
    public HResult GetOOMData(DacOOMData& oomData);
    public HResult GetOOMData(ulong address, DacOOMData& oomData);
    public HResult GetHeapAnalyzeData(DacHeapAnalyzeData& analyzeData);
    public HResult GetHeapAnalyzeData(ulong address, DacHeapAnalyzeData& analyzeData);
    public HResult GetSegmentData(ulong addr, SegmentData& data);
    public ClrDataAddress[] GetHeapList(int heapCount);
    public HResult GetServerHeapDetails(ulong addr, HeapDetails& data);
    public HResult GetWksHeapDetails(HeapDetails& data);
    public JitManagerData[] GetJitManagers();
    public JitCodeHeapInfo[] GetCodeHeapList(ulong jitManager);
    public HResult TraverseModuleMap(ModuleMapTraverseKind mt, ulong module, ModuleMapTraverse traverse);
    public HResult TraverseLoaderHeap(ulong heap, LoaderHeapTraverse callback);
    public HResult TraverseStubHeap(ulong heap, VCSHeapType type, LoaderHeapTraverse callback);
    public SOSHandleEnum EnumerateHandles(ClrHandleKind[] types);
    [NullableContextAttribute("2")]
public SOSHandleEnum EnumerateHandles();
    [NullableContextAttribute("2")]
public SOSStackRefEnum EnumerateStackRefs(UInt32 osThreadId);
    public ulong GetMethodDescFromToken(ulong module, int token);
}
internal class Microsoft.Diagnostics.Runtime.DacInterface.SosDac12 : CallableCOMWrapper {
    internal static Guid IID_ISOSDac12;
    [IsReadOnlyAttribute]
private ISOSDac12VTable& modreq(System.Runtime.InteropServices.InAttribute) VTable { get; }
    [NullableContextAttribute("1")]
public SosDac12(DacLibrary library, IntPtr ptr);
    private static SosDac12();
    private ISOSDac12VTable& modreq(System.Runtime.InteropServices.InAttribute) get_VTable();
    public HResult GetGlobalAllocationContext(UInt64& allocPtr, UInt64& allocLimit);
}
internal class Microsoft.Diagnostics.Runtime.DacInterface.SOSDac13 : CallableCOMWrapper {
    [NullableAttribute("1")]
private DacLibrary _library;
    internal static Guid IID_ISOSDac13;
    [IsReadOnlyAttribute]
private ISOSDac13VTable& modreq(System.Runtime.InteropServices.InAttribute) VTable { get; }
    [NullableContextAttribute("1")]
public SOSDac13(DacLibrary library, IntPtr ptr);
    private static SOSDac13();
    private ISOSDac13VTable& modreq(System.Runtime.InteropServices.InAttribute) get_VTable();
    [NullableContextAttribute("1")]
public sealed virtual HResult TraverseLoaderHeap(ulong heap, LoaderHeapKind kind, LoaderHeapTraverse callback);
    public sealed virtual ClrDataAddress GetDomainLoaderAllocator(ClrDataAddress domainAddress);
    [NullableContextAttribute("1")]
public sealed virtual String[] GetLoaderAllocatorHeapNames();
    public sealed virtual ValueTuple`2[] GetLoaderAllocatorHeaps(ClrDataAddress loaderAllocator);
    [NullableContextAttribute("2")]
public sealed virtual SosMemoryEnum GetHandleTableRegions();
    [NullableContextAttribute("2")]
public sealed virtual SosMemoryEnum GetGCBookkeepingMemoryRegions();
    [NullableContextAttribute("2")]
public sealed virtual SosMemoryEnum GetGCFreeRegions();
    public void LockedFlush();
    private sealed virtual override bool Microsoft.Diagnostics.Runtime.DacInterface.ISOSDac13.LockedFlush();
}
internal class Microsoft.Diagnostics.Runtime.DacInterface.SOSDac13Old : CallableCOMWrapper {
    internal static Guid IID_ISOSDac13;
    [IsReadOnlyAttribute]
private ISOSDac13VTable& modreq(System.Runtime.InteropServices.InAttribute) VTable { get; }
    [NullableContextAttribute("1")]
public SOSDac13Old(DacLibrary library, IntPtr ptr);
    private static SOSDac13Old();
    private ISOSDac13VTable& modreq(System.Runtime.InteropServices.InAttribute) get_VTable();
    [NullableContextAttribute("1")]
public sealed virtual HResult TraverseLoaderHeap(ulong heap, LoaderHeapKind kind, LoaderHeapTraverse callback);
    public sealed virtual ClrDataAddress GetDomainLoaderAllocator(ClrDataAddress domainAddress);
    [NullableContextAttribute("1")]
public sealed virtual String[] GetLoaderAllocatorHeapNames();
    public sealed virtual ValueTuple`2[] GetLoaderAllocatorHeaps(ClrDataAddress loaderAllocator);
    [NullableContextAttribute("2")]
private sealed virtual override SosMemoryEnum Microsoft.Diagnostics.Runtime.DacInterface.ISOSDac13.GetGCBookkeepingMemoryRegions();
    [NullableContextAttribute("2")]
private sealed virtual override SosMemoryEnum Microsoft.Diagnostics.Runtime.DacInterface.ISOSDac13.GetGCFreeRegions();
    [NullableContextAttribute("2")]
private sealed virtual override SosMemoryEnum Microsoft.Diagnostics.Runtime.DacInterface.ISOSDac13.GetHandleTableRegions();
    private sealed virtual override bool Microsoft.Diagnostics.Runtime.DacInterface.ISOSDac13.LockedFlush();
}
internal class Microsoft.Diagnostics.Runtime.DacInterface.SosDac14 : CallableCOMWrapper {
    [NullableAttribute("1")]
private DacLibrary _library;
    internal static Guid IID_ISOSDac14;
    [IsReadOnlyAttribute]
private ISOSDac14VTable& modreq(System.Runtime.InteropServices.InAttribute) VTable { get; }
    [NullableContextAttribute("1")]
public SosDac14(DacLibrary library, IntPtr ptr);
    private static SosDac14();
    private ISOSDac14VTable& modreq(System.Runtime.InteropServices.InAttribute) get_VTable();
    public ValueTuple`2<ulong, ulong> GetStaticBaseAddress(ClrDataAddress methodTable);
    public ValueTuple`2<ulong, ulong> GetThreadStaticBaseAddress(ClrDataAddress methodTable, ClrDataAddress thread);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.Diagnostics.Runtime.DacInterface.SOSDac6 : CallableCOMWrapper {
    internal static Guid IID_ISOSDac6;
    [IsReadOnlyAttribute]
private ISOSDac6VTable& modreq(System.Runtime.InteropServices.InAttribute) VTable { get; }
    public SOSDac6(DacLibrary library, IntPtr ptr);
    public SOSDac6(CallableCOMWrapper toClone);
    private static SOSDac6();
    private ISOSDac6VTable& modreq(System.Runtime.InteropServices.InAttribute) get_VTable();
    public HResult GetMethodTableCollectibleData(ulong mt, MethodTableCollectibleData& data);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
internal class Microsoft.Diagnostics.Runtime.DacInterface.SOSDac8 : CallableCOMWrapper {
    internal static Guid IID_ISOSDac8;
    [IsReadOnlyAttribute]
private ISOSDac8VTable& modreq(System.Runtime.InteropServices.InAttribute) VTable { get; }
    public int GenerationCount { get; }
    [NullableContextAttribute("1")]
public SOSDac8(DacLibrary library, IntPtr ptr);
    private static SOSDac8();
    private ISOSDac8VTable& modreq(System.Runtime.InteropServices.InAttribute) get_VTable();
    public HResult GetAssemblyLoadContext(ClrDataAddress methodTable, ClrDataAddress& assemblyLoadContext);
    public int get_GenerationCount();
    public GenerationData[] GetGenerationTable();
    public GenerationData[] GetGenerationTable(ulong heap);
    public ClrDataAddress[] GetFinalizationFillPointers();
    public ClrDataAddress[] GetFinalizationFillPointers(ulong heap);
}
internal class Microsoft.Diagnostics.Runtime.DacInterface.SOSHandleEnum : CallableCOMWrapper {
    [NativeIntegerAttribute]
[NullableAttribute("1")]
private List`1<IntPtr> _data;
    private static Guid IID_ISOSHandleEnum;
    [IsReadOnlyAttribute]
private ISOSHandleEnumVTable& modreq(System.Runtime.InteropServices.InAttribute) VTable { get; }
    [NullableContextAttribute("1")]
public SOSHandleEnum(DacLibrary library, IntPtr pUnk);
    private static SOSHandleEnum();
    protected virtual void Dispose(bool disposing);
    private Span`1<HandleData> Read();
    private Span`1<HandleData> CreateStorage();
    private ISOSHandleEnumVTable& modreq(System.Runtime.InteropServices.InAttribute) get_VTable();
    [NullableContextAttribute("1")]
public IEnumerable`1<HandleData> ReadHandles();
}
internal class Microsoft.Diagnostics.Runtime.DacInterface.SosMemoryEnum : CallableCOMWrapper {
    public static Guid IID_ISOSMemoryEnum;
    [IsReadOnlyAttribute]
private ISOSMemoryEnumVtable& modreq(System.Runtime.InteropServices.InAttribute) VTable { get; }
    [NullableContextAttribute("1")]
public SosMemoryEnum(DacLibrary library, IntPtr pUnk);
    private static SosMemoryEnum();
    private ISOSMemoryEnumVtable& modreq(System.Runtime.InteropServices.InAttribute) get_VTable();
    private void Reset();
    [NullableContextAttribute("1")]
[IteratorStateMachineAttribute("Microsoft.Diagnostics.Runtime.DacInterface.SosMemoryEnum/<GetEnumerator>d__5")]
public sealed virtual IEnumerator`1<SosMemoryRegion> GetEnumerator();
    private int Read(Span`1<SosMemoryRegion> regions);
    [NullableContextAttribute("1")]
private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
}
[IsReadOnlyAttribute]
internal class Microsoft.Diagnostics.Runtime.DacInterface.SosMemoryRegion : ValueType {
    public ClrDataAddress Start;
    public ClrDataAddress Length;
    public ClrDataAddress ExtraData;
    public int Heap;
}
internal class Microsoft.Diagnostics.Runtime.DacInterface.SOSStackRefEnum : CallableCOMWrapper {
    [NativeIntegerAttribute]
[NullableAttribute("1")]
private List`1<IntPtr> _data;
    private static Guid IID_ISOSStackRefEnum;
    [IsReadOnlyAttribute]
private ISOSStackRefEnumVTable& modreq(System.Runtime.InteropServices.InAttribute) VTable { get; }
    [NullableContextAttribute("1")]
public SOSStackRefEnum(DacLibrary library, IntPtr pUnk);
    private static SOSStackRefEnum();
    protected virtual void Dispose(bool disposing);
    private ISOSStackRefEnumVTable& modreq(System.Runtime.InteropServices.InAttribute) get_VTable();
    [NullableContextAttribute("1")]
public IEnumerable`1<StackRefData> ReadStackRefs();
    private Span`1<StackRefData> Read();
    private Span`1<StackRefData> CreateStorage();
}
[IsReadOnlyAttribute]
internal class Microsoft.Diagnostics.Runtime.DacInterface.StackRefData : ValueType {
    public UInt32 HasRegisterInformation;
    public int Register;
    public int Offset;
    public ClrDataAddress Address;
    public ClrDataAddress Object;
    public UInt32 Flags;
    public UInt32 SourceType;
    public ClrDataAddress Source;
    public ClrDataAddress StackPointer;
}
[IsReadOnlyAttribute]
internal class Microsoft.Diagnostics.Runtime.DacInterface.SyncBlockCleanupData : ValueType {
    public ClrDataAddress SyncBlockPointer;
    public ClrDataAddress NextSyncBlock;
    public ClrDataAddress BlockRCW;
    public ClrDataAddress BlockClassFactory;
    public ClrDataAddress BlockCCW;
}
[IsReadOnlyAttribute]
internal class Microsoft.Diagnostics.Runtime.DacInterface.SyncBlockData : ValueType {
    public ClrDataAddress Object;
    public UInt32 Free;
    public ClrDataAddress Address;
    public UInt32 COMFlags;
    public UInt32 MonitorHeld;
    public UInt32 Recursion;
    public ClrDataAddress HoldingThread;
    public UInt32 AdditionalThreadCount;
    public ClrDataAddress AppDomain;
    public UInt32 TotalSyncBlockCount;
}
internal class Microsoft.Diagnostics.Runtime.DacInterface.ThreadData : ValueType {
    public UInt32 ManagedThreadId;
    public UInt32 OSThreadId;
    public int State;
    public UInt32 PreemptiveGCDisabled;
    public ClrDataAddress AllocationContextPointer;
    public ClrDataAddress AllocationContextLimit;
    public ClrDataAddress Context;
    public ClrDataAddress Domain;
    public ClrDataAddress Frame;
    public UInt32 LockCount;
    public ClrDataAddress FirstNestedException;
    public ClrDataAddress Teb;
    public ClrDataAddress FiberData;
    public ClrDataAddress LastThrownObjectHandle;
    public ClrDataAddress NextThread;
}
[IsReadOnlyAttribute]
internal class Microsoft.Diagnostics.Runtime.DacInterface.ThreadLocalModuleData : ValueType {
    public ClrDataAddress ThreadAddress;
    public ClrDataAddress ModuleIndex;
    public ClrDataAddress ClassData;
    public ClrDataAddress DynamicClassTable;
    public ClrDataAddress GCStaticDataStart;
    public ClrDataAddress NonGCStaticDataStart;
}
[IsReadOnlyAttribute]
internal class Microsoft.Diagnostics.Runtime.DacInterface.ThreadPoolData : ValueType {
    public int CpuUtilization;
    public int NumIdleWorkerThreads;
    public int NumWorkingWorkerThreads;
    public int NumRetiredWorkerThreads;
    public int MinLimitTotalWorkerThreads;
    public int MaxLimitTotalWorkerThreads;
    public ClrDataAddress FirstUnmanagedWorkRequest;
    public ClrDataAddress HillClimbingLog;
    public UInt32 HillClimbingLogFirstIndex;
    public UInt32 HillClimbingLogSize;
    public int NumTimers;
    public int NumCPThreads;
    public int NumFreeCPThreads;
    public int MaxFreeCPThreads;
    public int NumRetiredCPThreads;
    public int MaxLimitTotalCPThreads;
    public int CurrentLimitTotalCPThreads;
    public int MinLimitTotalCPThreads;
    public ClrDataAddress AsyncTimerCallbackCompletionFPtr;
}
[IsReadOnlyAttribute]
internal class Microsoft.Diagnostics.Runtime.DacInterface.ThreadStoreData : ValueType {
    public int ThreadCount;
    public int UnstartedThreadCount;
    public int BackgroundThreadCount;
    public int PendingThreadCount;
    public int DeadThreadCount;
    public ClrDataAddress FirstThread;
    public ClrDataAddress FinalizerThread;
    public ClrDataAddress GCThread;
    public UInt32 HostConfig;
}
[IsReadOnlyAttribute]
internal class Microsoft.Diagnostics.Runtime.DacInterface.WorkRequestData : ValueType {
    public ClrDataAddress Function;
    public ClrDataAddress Context;
    public ClrDataAddress NextWorkRequest;
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.Diagnostics.Runtime.DacLibrary : object {
    private bool _disposed;
    private ClrDataProcess _clrDataProcess;
    [CompilerGeneratedAttribute]
private DacDataTarget <DacDataTarget>k__BackingField;
    [NullableAttribute("2")]
[CompilerGeneratedAttribute]
private RefCountedFreeLibrary <OwningLibrary>k__BackingField;
    public DacDataTarget DacDataTarget { get; }
    [NullableAttribute("2")]
public RefCountedFreeLibrary OwningLibrary { get; }
    public DacLibrary(DataTarget dataTarget, string dacPath, ulong runtimeBaseAddress);
    [CompilerGeneratedAttribute]
public DacDataTarget get_DacDataTarget();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public RefCountedFreeLibrary get_OwningLibrary();
    public ClrDataProcess CreateClrDataProcess();
    public sealed virtual void Dispose();
    protected virtual override void Finalize();
    private void Dispose(bool _);
}
[NullableContextAttribute("1")]
public interface Microsoft.Diagnostics.Runtime.DataReaders.Implementation.IThreadReader {
    public abstract virtual IEnumerable`1<UInt32> EnumerateOSThreadIds();
    public abstract virtual ulong GetThreadTeb(UInt32 osThreadId);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.Diagnostics.Runtime.DataReaders.Windows.WindowsThreadSuspender : CriticalFinalizerObject {
    private object _sync;
    private int _pid;
    [NullableAttribute("2")]
private Int32[] modreq(System.Runtime.CompilerServices.IsVolatile) _suspendedThreads;
    public WindowsThreadSuspender(int pid);
    private Int32[] SuspendThreads();
    private void ResumeThreads(IEnumerable`1<int> suspendedThreads);
    protected virtual override void Finalize();
    public sealed virtual void Dispose();
    private void Dispose(bool _);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Microsoft.Diagnostics.Runtime.DataTarget : object {
    private static List`1<IClrInfoProvider> s_clrInfoProviders;
    private CustomDataTarget _target;
    private bool _disposed;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private ImmutableArray`1<ClrInfo> _clrs;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private ModuleInfo[] _modules;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private Dictionary`2<string, PEImage> _pefileCache;
    [CompilerGeneratedAttribute]
private IDataReader <DataReader>k__BackingField;
    [CompilerGeneratedAttribute]
private CacheOptions <CacheOptions>k__BackingField;
    [CompilerGeneratedAttribute]
private static PlatformFunctions <PlatformFunctions>k__BackingField;
    public IDataReader DataReader { get; }
    public CacheOptions CacheOptions { get; }
    [NullableAttribute("2")]
public IFileLocator FileLocator { get; public set; }
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ImmutableArray`1<ClrInfo> ClrVersions { get; }
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private ImmutableArray`1<IClrInfo> Microsoft.Diagnostics.Runtime.Interfaces.IDataTarget.ClrVersions { get; }
    public static PlatformFunctions PlatformFunctions { get; }
    public DataTarget(CustomDataTarget customTarget);
    private static DataTarget();
    public static void AddClrInfoProvider(IClrInfoProvider clrInfoProvider);
    [CompilerGeneratedAttribute]
public sealed virtual IDataReader get_DataReader();
    [CompilerGeneratedAttribute]
public sealed virtual CacheOptions get_CacheOptions();
    [NullableContextAttribute("2")]
public sealed virtual IFileLocator get_FileLocator();
    [NullableContextAttribute("2")]
public sealed virtual void set_FileLocator(IFileLocator value);
    public sealed virtual void SetSymbolPath(string symbolPath);
    public sealed virtual void Dispose();
    internal PEImage LoadPEImage(string fileName, int timeStamp, int fileSize, bool checkProperties, ulong imageBase);
    [ConditionalAttribute("DEBUG")]
private void DebugOnlyLoadLazyValues();
    public ImmutableArray`1<ClrInfo> get_ClrVersions();
    private sealed virtual override ImmutableArray`1<IClrInfo> Microsoft.Diagnostics.Runtime.Interfaces.IDataTarget.get_ClrVersions();
    private ImmutableArray`1<ClrInfo> GetOrCreateClrVersions();
    public sealed virtual IEnumerable`1<ModuleInfo> EnumerateModules();
    [CompilerGeneratedAttribute]
public static PlatformFunctions get_PlatformFunctions();
    public static DataTarget LoadDump(string displayName, Stream stream, CacheOptions cacheOptions, bool leaveOpen, TokenCredential symbolCredential);
    public static DataTarget LoadDump(string filePath, TokenCredential symbolCredential);
    public static DataTarget LoadDump(string filePath, CacheOptions cacheOptions, TokenCredential symbolCredential);
    private static DumpFileFormat ReadFileFormat(Stream stream);
    public static DataTarget AttachToProcess(int processId, bool suspend, TokenCredential symbolCredential);
    public static DataTarget CreateSnapshotAndAttach(int processId, TokenCredential symbolCredential);
    public static DataTarget CreateFromDbgEng(IntPtr pDebugClient, TokenCredential symbolCredential);
    private static PlatformNotSupportedException GetPlatformException(string method);
    [NullableContextAttribute("0")]
[CompilerGeneratedAttribute]
private IEnumerable`1<ClrInfo> <GetOrCreateClrVersions>b__25_0(ModuleInfo module);
}
internal enum Microsoft.Diagnostics.Runtime.DbgEng.DEBUG_CLASS_QUALIFIER : Enum {
    public UInt32 value__;
    public static DEBUG_CLASS_QUALIFIER KERNEL_CONNECTION;
    public static DEBUG_CLASS_QUALIFIER KERNEL_LOCAL;
    public static DEBUG_CLASS_QUALIFIER KERNEL_EXDI_DRIVER;
    public static DEBUG_CLASS_QUALIFIER KERNEL_IDNA;
    public static DEBUG_CLASS_QUALIFIER KERNEL_SMALL_DUMP;
    public static DEBUG_CLASS_QUALIFIER KERNEL_DUMP;
    public static DEBUG_CLASS_QUALIFIER KERNEL_FULL_DUMP;
    public static DEBUG_CLASS_QUALIFIER USER_WINDOWS_PROCESS;
    public static DEBUG_CLASS_QUALIFIER USER_WINDOWS_PROCESS_SERVER;
    public static DEBUG_CLASS_QUALIFIER USER_WINDOWS_IDNA;
    public static DEBUG_CLASS_QUALIFIER USER_WINDOWS_SMALL_DUMP;
    public static DEBUG_CLASS_QUALIFIER USER_WINDOWS_DUMP;
}
[FlagsAttribute]
internal enum Microsoft.Diagnostics.Runtime.DbgEng.DEBUG_FORMAT : Enum {
    public UInt32 value__;
    public static DEBUG_FORMAT DEFAULT;
    public static DEBUG_FORMAT CAB_SECONDARY_ALL_IMAGES;
    public static DEBUG_FORMAT WRITE_CAB;
    public static DEBUG_FORMAT CAB_SECONDARY_FILES;
    public static DEBUG_FORMAT NO_OVERWRITE;
    public static DEBUG_FORMAT USER_SMALL_FULL_MEMORY;
    public static DEBUG_FORMAT USER_SMALL_HANDLE_DATA;
    public static DEBUG_FORMAT USER_SMALL_UNLOADED_MODULES;
    public static DEBUG_FORMAT USER_SMALL_INDIRECT_MEMORY;
    public static DEBUG_FORMAT USER_SMALL_DATA_SEGMENTS;
    public static DEBUG_FORMAT USER_SMALL_FILTER_MEMORY;
    public static DEBUG_FORMAT USER_SMALL_FILTER_PATHS;
    public static DEBUG_FORMAT USER_SMALL_PROCESS_THREAD_DATA;
    public static DEBUG_FORMAT USER_SMALL_PRIVATE_READ_WRITE_MEMORY;
    public static DEBUG_FORMAT USER_SMALL_NO_OPTIONAL_DATA;
    public static DEBUG_FORMAT USER_SMALL_FULL_MEMORY_INFO;
    public static DEBUG_FORMAT USER_SMALL_THREAD_INFO;
    public static DEBUG_FORMAT USER_SMALL_CODE_SEGMENTS;
    public static DEBUG_FORMAT USER_SMALL_NO_AUXILIARY_STATE;
    public static DEBUG_FORMAT USER_SMALL_FULL_AUXILIARY_STATE;
    public static DEBUG_FORMAT USER_SMALL_IGNORE_INACCESSIBLE_MEM;
}
internal class Microsoft.Diagnostics.Runtime.DbgEng.DEBUG_MODULE_PARAMETERS : ValueType {
    public ulong Base;
    public int Size;
    public int TimeDateStamp;
    public UInt32 Checksum;
    public UInt32 Flags;
    public UInt32 SymbolType;
    public UInt32 ImageNameSize;
    public UInt32 ModuleNameSize;
    public UInt32 LoadedImageNameSize;
    public UInt32 SymbolFileNameSize;
    public UInt32 MappedImageNameSize;
    [FixedBufferAttribute("System.UInt64", "2")]
public <Reserved>e__FixedBuffer Reserved;
}
internal class Microsoft.Diagnostics.Runtime.DbgEng.DebugAdvanced : CallableCOMWrapper {
    internal static Guid IID_IDebugAdvanced;
    [NullableAttribute("1")]
private DebugSystemObjects _sys;
    [IsReadOnlyAttribute]
private IDebugAdvancedVTable& modreq(System.Runtime.InteropServices.InAttribute) VTable { get; }
    [NullableContextAttribute("1")]
public DebugAdvanced(RefCountedFreeLibrary library, IntPtr pUnk, DebugSystemObjects sys);
    private static DebugAdvanced();
    private IDebugAdvancedVTable& modreq(System.Runtime.InteropServices.InAttribute) get_VTable();
    public HResult GetThreadContext(Span`1<byte> context);
}
[FlagsAttribute]
internal enum Microsoft.Diagnostics.Runtime.DbgEng.DebugAttach : Enum {
    public UInt32 value__;
    public static DebugAttach Default;
    public static DebugAttach NonInvasive;
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.Diagnostics.Runtime.DbgEng.DebugClient : CallableCOMWrapper {
    internal static Guid IID_IDebugClient;
    private DebugSystemObjects _sys;
    [IsReadOnlyAttribute]
private IDebugClientVTable& modreq(System.Runtime.InteropServices.InAttribute) VTable { get; }
    public DebugClient(RefCountedFreeLibrary library, IntPtr pUnk, DebugSystemObjects system);
    private static DebugClient();
    private IDebugClientVTable& modreq(System.Runtime.InteropServices.InAttribute) get_VTable();
    public void EndSession(DebugEnd mode);
    public void DetachProcesses();
    public HResult AttachProcess(UInt32 pid, DebugAttach flags);
    public HResult OpenDumpFile(string dumpFile);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.Diagnostics.Runtime.DbgEng.DebugControl : CallableCOMWrapper {
    public static int INITIAL_BREAK;
    internal static Guid IID_IDebugControl2;
    private DebugSystemObjects _sys;
    [IsReadOnlyAttribute]
private IDebugControlVTable& modreq(System.Runtime.InteropServices.InAttribute) VTable { get; }
    public DebugControl(RefCountedFreeLibrary library, IntPtr pUnk, DebugSystemObjects sys);
    private static DebugControl();
    private IDebugControlVTable& modreq(System.Runtime.InteropServices.InAttribute) get_VTable();
    public IMAGE_FILE_MACHINE GetEffectiveProcessorType();
    public bool IsPointer64Bit();
    public HResult WaitForEvent(UInt32 timeout);
    public HResult AddEngineOptions(int options);
    public DEBUG_FORMAT GetDumpFormat();
    public DEBUG_CLASS_QUALIFIER GetDebuggeeClassQualifier();
}
internal class Microsoft.Diagnostics.Runtime.DbgEng.DebugDataSpaces : CallableCOMWrapper {
    internal static Guid IID_IDebugDataSpaces2;
    [NullableAttribute("1")]
private DebugSystemObjects _sys;
    [IsReadOnlyAttribute]
private IDebugDataSpacesVTable& modreq(System.Runtime.InteropServices.InAttribute) VTable { get; }
    [NullableContextAttribute("1")]
public DebugDataSpaces(RefCountedFreeLibrary library, IntPtr pUnk, DebugSystemObjects sys);
    private static DebugDataSpaces();
    private IDebugDataSpacesVTable& modreq(System.Runtime.InteropServices.InAttribute) get_VTable();
    public int ReadVirtual(ulong address, Span`1<byte> buffer);
    public HResult QueryVirtual(ulong address, MEMORY_BASIC_INFORMATION64& info);
}
internal enum Microsoft.Diagnostics.Runtime.DbgEng.DebugEnd : Enum {
    public int value__;
    public static DebugEnd Passive;
    public static DebugEnd ActiveTerminate;
    public static DebugEnd ActiveDetach;
    public static DebugEnd EndReentrant;
    public static DebugEnd EndDisconnect;
}
internal enum Microsoft.Diagnostics.Runtime.DbgEng.DebugModuleName : Enum {
    public UInt32 value__;
    public static DebugModuleName Image;
    public static DebugModuleName Module;
    public static DebugModuleName LoadedImage;
    public static DebugModuleName SymbolFile;
    public static DebugModuleName MappedImage;
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.Diagnostics.Runtime.DbgEng.DebugSymbols : CallableCOMWrapper {
    internal static Guid IID_IDebugSymbols3;
    private DebugSystemObjects _sys;
    [IsReadOnlyAttribute]
private IDebugSymbols3VTable& modreq(System.Runtime.InteropServices.InAttribute) VTable { get; }
    public DebugSymbols(RefCountedFreeLibrary library, IntPtr pUnk, DebugSystemObjects sys);
    private static DebugSymbols();
    private IDebugSymbols3VTable& modreq(System.Runtime.InteropServices.InAttribute) get_VTable();
    [NullableContextAttribute("2")]
public string GetModuleNameStringWide(DebugModuleName which, int index, ulong imageBase);
    public int GetNumberModules();
    public ulong GetModuleByIndex(int i);
    public HResult GetModuleParameters(UInt64[] bases, DEBUG_MODULE_PARAMETERS[]& parameters);
    public Version GetModuleVersionInformation(int index, ulong imgBase);
    public HResult GetModuleByOffset(ulong address, int index, Int32& outIndex, UInt64& imgBase);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.Diagnostics.Runtime.DbgEng.DebugSystemObjects : CallableCOMWrapper {
    internal static Guid IID_DebugSystemObjects3;
    private int _systemId;
    [IsReadOnlyAttribute]
private IDebugSystemObjects3VTable& modreq(System.Runtime.InteropServices.InAttribute) VTable { get; }
    public DebugSystemObjects(RefCountedFreeLibrary library, IntPtr pUnk);
    private static DebugSystemObjects();
    private IDebugSystemObjects3VTable& modreq(System.Runtime.InteropServices.InAttribute) get_VTable();
    public IDisposable Enter();
    public UInt32 GetProcessId();
    private HResult SetCurrentSystemId(int id);
    public HResult SetCurrentThread(UInt32 id);
    public UInt32 GetCurrentThread();
    public int GetNumberThreads();
    public ulong GetThreadTeb(UInt32 osThreadId);
    internal void Init();
    public UInt32[] GetThreadIds();
    public UInt32 GetThreadIdBySystemId(UInt32 sysId);
}
[IsReadOnlyAttribute]
internal class Microsoft.Diagnostics.Runtime.DbgEng.IDebugAdvancedVTable : ValueType {
    public method GetThreadContext;
    public IntPtr SetThreadContext;
}
[IsReadOnlyAttribute]
internal class Microsoft.Diagnostics.Runtime.DbgEng.IDebugClientVTable : ValueType {
    public IntPtr AttachKernel;
    public IntPtr GetKernelConnectionOptions;
    public IntPtr SetKernelConnectionOptions;
    public IntPtr StartProcessServer;
    public IntPtr ConnectProcessServer;
    public IntPtr DisconnectProcessServer;
    public IntPtr GetRunningProcessSystemIds;
    public IntPtr GetRunningProcessSystemIdByExecutableName;
    public IntPtr GetRunningProcessDescription;
    public method AttachProcess;
    public IntPtr CreateProcess;
    public IntPtr CreateProcessAndAttach;
    public IntPtr GetProcessOptions;
    public IntPtr AddProcessOptions;
    public IntPtr RemoveProcessOptions;
    public IntPtr SetProcessOptions;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public method OpenDumpFile;
    public IntPtr WriteDumpFile;
    public IntPtr ConnectSession;
    public IntPtr StartServer;
    public IntPtr OutputServer;
    public IntPtr TerminateProcesses;
    public method DetachProcesses;
    public method EndSession;
    public IntPtr GetExitCode;
    public IntPtr DispatchCallbacks;
    public IntPtr ExitDispatch;
    public IntPtr CreateClient;
    public IntPtr GetInputCallbacks;
    public IntPtr SetInputCallbacks;
    public IntPtr GetOutputCallbacks;
    public IntPtr SetOutputCallbacks;
    public IntPtr GetOutputMask;
    public IntPtr SetOutputMask;
    public IntPtr GetOtherOutputMask;
    public IntPtr SetOtherOutputMask;
    public IntPtr GetOutputWidth;
    public IntPtr SetOutputWidth;
    public IntPtr GetOutputLinePrefix;
    public IntPtr SetOutputLinePrefix;
    public IntPtr GetIdentity;
    public IntPtr OutputIdentity;
    public IntPtr GetEventCallbacks;
    public IntPtr SetEventCallbacks;
    public IntPtr FlushCallbacks;
}
[IsReadOnlyAttribute]
internal class Microsoft.Diagnostics.Runtime.DbgEng.IDebugControlVTable : ValueType {
    public IntPtr GetInterrupt;
    public IntPtr SetInterrupt;
    public IntPtr GetInterruptTimeout;
    public IntPtr SetInterruptTimeout;
    public IntPtr GetLogFile;
    public IntPtr OpenLogFile;
    public IntPtr CloseLogFile;
    public IntPtr GetLogMask;
    public IntPtr SetLogMask;
    public IntPtr Input;
    public IntPtr ReturnInput;
    public IntPtr Output;
    public IntPtr OutputVaList;
    public IntPtr ControlledOutput;
    public IntPtr ControlledOutputVaList;
    public IntPtr OutputPrompt;
    public IntPtr OutputPromptVaList;
    public IntPtr GetPromptText;
    public IntPtr OutputCurrentState;
    public IntPtr OutputVersionInformation;
    public IntPtr GetNotifyEventHandle;
    public IntPtr SetNotifyEventHandle;
    public IntPtr Assemble;
    public IntPtr Disassemble;
    public IntPtr GetDisassembleEffectiveOffset;
    public IntPtr OutputDisassembly;
    public IntPtr OutputDisassemblyLines;
    public IntPtr GetNearInstruction;
    public IntPtr GetStackTrace;
    public IntPtr GetReturnOffset;
    public IntPtr OutputStackTrace;
    public method GetDebuggeeType;
    public IntPtr GetActualProcessorType;
    public IntPtr GetExecutingProcessorType;
    public IntPtr GetNumberPossibleExecutingProcessorTypes;
    public IntPtr GetPossibleExecutingProcessorTypes;
    public IntPtr GetNumberProcessors;
    public IntPtr GetSystemVersion;
    public IntPtr GetPageSize;
    public method IsPointer64Bit;
    public IntPtr ReadBugCheckData;
    public IntPtr GetNumberSupportedProcessorTypes;
    public IntPtr GetSupportedProcessorTypes;
    public IntPtr GetProcessorTypeNames;
    public method GetEffectiveProcessorType;
    public IntPtr SetEffectiveProcessorType;
    public IntPtr GetExecutionStatus;
    public IntPtr SetExecutionStatus;
    public IntPtr GetCodeLevel;
    public IntPtr SetCodeLevel;
    public IntPtr GetEngineOptions;
    public method AddEngineOptions;
    public IntPtr RemoveEngineOptions;
    public IntPtr SetEngineOptions;
    public IntPtr GetSystemErrorControl;
    public IntPtr SetSystemErrorControl;
    public IntPtr GetTextMacro;
    public IntPtr SetTextMacro;
    public IntPtr GetRadix;
    public IntPtr SetRadix;
    public IntPtr Evaluate;
    public IntPtr CoerceValue;
    public IntPtr CoerceValues;
    public IntPtr Execute;
    public IntPtr ExecuteCommandFile;
    public IntPtr GetNumberBreakpoints;
    public IntPtr GetBreakpointByIndex;
    public IntPtr GetBreakpointById;
    public IntPtr GetBreakpointParameters;
    public IntPtr AddBreakpoint;
    public IntPtr RemoveBreakpoint;
    public IntPtr AddExtension;
    public IntPtr RemoveExtension;
    public IntPtr GetExtensionByPath;
    public IntPtr CallExtension;
    public IntPtr GetExtensionFunction;
    public IntPtr GetWindbgExtensionApis32;
    public IntPtr GetWindbgExtensionApis64;
    public IntPtr GetNumberEventFilters;
    public IntPtr GetEventFilterText;
    public IntPtr GetEventFilterCommand;
    public IntPtr SetEventFilterCommand;
    public IntPtr GetSpecificFilterParameters;
    public IntPtr SetSpecificFilterParameters;
    public IntPtr GetSpecificEventFilterArgument;
    public IntPtr SetSpecificEventFilterArgument;
    public IntPtr GetExceptionFilterParameters;
    public IntPtr SetExceptionFilterParameters;
    public IntPtr GetExceptionFilterSecondCommand;
    public IntPtr SetExceptionFilterSecondCommand;
    public method WaitForEvent;
    public IntPtr GetLastEventInformation;
    public IntPtr GetCurrentTimeDate;
    public IntPtr GetCurrentSystemUpTime;
    public method GetDumpFormatFlags;
    public IntPtr GetNumberTextReplacements;
    public IntPtr GetTextReplacement;
    public IntPtr SetTextReplacement;
    public IntPtr RemoveTextReplacements;
    public IntPtr OutputTextReplacements;
}
[IsReadOnlyAttribute]
internal class Microsoft.Diagnostics.Runtime.DbgEng.IDebugDataSpacesVTable : ValueType {
    public method ReadVirtual;
    public IntPtr WriteVirtual;
    public IntPtr SearchVirtual;
    public IntPtr ReadVirtualUncached;
    public IntPtr WriteVirtualUncached;
    public IntPtr ReadPointersVirtual;
    public IntPtr WritePointersVirtual;
    public IntPtr ReadPhysical;
    public IntPtr WritePhysical;
    public IntPtr ReadControl;
    public IntPtr WriteControl;
    public IntPtr ReadIo;
    public IntPtr WriteIo;
    public IntPtr ReadMsr;
    public IntPtr WriteMsr;
    public IntPtr ReadBusData;
    public IntPtr WriteBusData;
    public IntPtr CheckLowMemory;
    public IntPtr ReadDebuggerData;
    public IntPtr ReadProcessorSystemData;
    public IntPtr VirtualToPhysical;
    public IntPtr GetVirtualTranslationPhysicalOffsets;
    public IntPtr ReadHandleData;
    public IntPtr FillVirtual;
    public IntPtr FillPhysical;
    public method QueryVirtual;
}
[IsReadOnlyAttribute]
internal class Microsoft.Diagnostics.Runtime.DbgEng.IDebugSymbols3VTable : ValueType {
    public IntPtr GetSymbolOptions;
    public IntPtr AddSymbolOptions;
    public IntPtr RemoveSymbolOptions;
    public IntPtr SetSymbolOptions;
    public IntPtr GetNameByOffset;
    public IntPtr GetOffsetByName;
    public IntPtr GetNearNameByOffset;
    public IntPtr GetLineByOffset;
    public IntPtr GetOffsetByLine;
    public method GetNumberModules;
    public method GetModuleByIndex;
    public IntPtr GetModuleByModuleName;
    public method GetModuleByOffset;
    public IntPtr GetModuleNames;
    public method GetModuleParameters;
    public IntPtr GetSymbolModule;
    public IntPtr GetTypeName;
    public IntPtr GetTypeId;
    public IntPtr GetTypeSize;
    public IntPtr GetFieldOffset;
    public IntPtr GetSymbolTypeId;
    public IntPtr GetOffsetTypeId;
    public IntPtr ReadTypedDataVirtual;
    public IntPtr WriteTypedDataVirtual;
    public IntPtr OutputTypedDataVirtual;
    public IntPtr ReadTypedDataPhysical;
    public IntPtr WriteTypedDataPhysical;
    public IntPtr OutputTypedDataPhysical;
    public IntPtr GetScope;
    public IntPtr SetScope;
    public IntPtr ResetScope;
    public IntPtr GetScopeSymbolGroup;
    public IntPtr CreateSymbolGroup;
    public IntPtr StartSymbolMatch;
    public IntPtr GetNextSymbolMatch;
    public IntPtr EndSymbolMatch;
    public IntPtr Reload;
    public IntPtr GetSymbolPath;
    public IntPtr SetSymbolPath;
    public IntPtr AppendSymbolPath;
    public IntPtr GetImagePath;
    public IntPtr SetImagePath;
    public IntPtr AppendImagePath;
    public IntPtr GetSourcePath;
    public IntPtr GetSourcePathElement;
    public IntPtr SetSourcePath;
    public IntPtr AppendSourcePath;
    public IntPtr FindSourceFile;
    public IntPtr GetSourceFileLineOffsets;
    public method GetModuleVersionInformation;
    public IntPtr GetModuleNameString;
    public IntPtr GetConstantName;
    public IntPtr GetFieldName;
    public IntPtr GetTypeOptions;
    public IntPtr AddTypeOptions;
    public IntPtr RemoveTypeOptions;
    public IntPtr SetTypeOptions;
    public IntPtr GetNameByOffsetWide;
    public IntPtr GetOffsetByNameWide;
    public IntPtr GetNearNameByOffsetWide;
    public IntPtr GetLineByOffsetWide;
    public IntPtr GetOffsetByLineWide;
    public IntPtr GetModuleByModuleNameWide;
    public IntPtr GetSymbolModuleWide;
    public IntPtr GetTypeNameWide;
    public IntPtr GetTypeIdWide;
    public IntPtr GetFieldOffsetWide;
    public IntPtr GetSymbolTypeIdWide;
    public IntPtr GetScopeSymbolGroup2;
    public IntPtr CreateSymbolGroup2;
    public IntPtr StartSymbolMatchWide;
    public IntPtr GetNextSymbolMatchWide;
    public IntPtr ReloadWide;
    public IntPtr GetSymbolPathWide;
    public IntPtr SetSymbolPathWide;
    public IntPtr AppendSymbolPathWide;
    public IntPtr GetImagePathWide;
    public IntPtr SetImagePathWide;
    public IntPtr AppendImagePathWide;
    public IntPtr GetSourcePathWide;
    public IntPtr GetSourcePathElementWide;
    public IntPtr SetSourcePathWide;
    public IntPtr AppendSourcePathWide;
    public IntPtr FindSourceFileWide;
    public IntPtr GetSourceFileLineOffsetsWide;
    public IntPtr GetModuleVersionInformationWide;
    public method GetModuleNameStringWide;
    public IntPtr GetConstantNameWide;
    public IntPtr GetFieldNameWide;
    public IntPtr IsManagedModule;
    public IntPtr GetModuleByModuleName2;
    public IntPtr GetModuleByModuleName2Wide;
    public IntPtr GetModuleByOffset2;
    public IntPtr AddSyntheticModule;
    public IntPtr AddSyntheticModuleWide;
    public IntPtr RemoveSyntheticModule;
    public IntPtr GetCurrentScopeFrameIndex;
    public IntPtr SetScopeFrameByIndex;
    public IntPtr SetScopeFromJitDebugInfo;
    public IntPtr SetScopeFromStoredEvent;
    public IntPtr OutputSymbolByOffset;
    public IntPtr GetFunctionEntryByOffset;
    public IntPtr GetFieldTypeAndOffset;
    public IntPtr GetFieldTypeAndOffsetWide;
    public IntPtr AddSyntheticSymbol;
    public IntPtr AddSyntheticSymbolWide;
    public IntPtr RemoveSyntheticSymbol;
    public IntPtr GetSymbolEntriesByOffset;
    public IntPtr GetSymbolEntriesByName;
    public IntPtr GetSymbolEntriesByNameWide;
    public IntPtr GetSymbolEntryByToken;
    public IntPtr GetSymbolEntryInformation;
    public IntPtr GetSymbolEntryString;
    public IntPtr GetSymbolEntryStringWide;
    public IntPtr GetSymbolEntryOffsetRegions;
    public IntPtr GetSymbolEntryBySymbolEntry;
    public IntPtr GetSourceEntriesByOffset;
    public IntPtr GetSourceEntriesByLine;
    public IntPtr GetSourceEntriesByLineWide;
    public IntPtr GetSourceEntryString;
    public IntPtr GetSourceEntryStringWide;
    public IntPtr GetSourceEntryOffsetRegions;
    public IntPtr GetSourceEntryBySourceEntry;
}
[IsReadOnlyAttribute]
internal class Microsoft.Diagnostics.Runtime.DbgEng.IDebugSystemObjects3VTable : ValueType {
    public IntPtr GetEventThread;
    public IntPtr GetEventProcess;
    public method GetCurrentThreadId;
    public method SetCurrentThreadId;
    public IntPtr GetCurrentProcessId;
    public IntPtr SetCurrentProcessId;
    public method GetNumberThreads;
    public IntPtr GetTotalNumberThreads;
    public method GetThreadIdsByIndex;
    public IntPtr GetThreadIdByProcessor;
    public IntPtr GetCurrentThreadDataOffset;
    public IntPtr GetThreadIdByDataOffset;
    public method GetCurrentThreadTeb;
    public IntPtr GetThreadIdByTeb;
    public IntPtr GetCurrentThreadSystemId;
    public method GetThreadIdBySystemId;
    public IntPtr GetCurrentThreadHandle;
    public IntPtr GetThreadIdByHandle;
    public IntPtr GetNumberProcesses;
    public IntPtr GetProcessIdsByIndex;
    public IntPtr GetCurrentProcessDataOffset;
    public IntPtr GetProcessIdByDataOffset;
    public IntPtr GetCurrentProcessPeb;
    public IntPtr GetProcessIdByPeb;
    public method GetCurrentProcessSystemId;
    public IntPtr GetProcessIdBySystemId;
    public IntPtr GetCurrentProcessHandle;
    public IntPtr GetProcessIdByHandle;
    public IntPtr GetCurrentProcessExecutableName;
    public IntPtr GetCurrentProcessUpTime;
    public IntPtr GetImplicitThreadDataOffset;
    public IntPtr SetImplicitThreadDataOffset;
    public IntPtr GetImplicitProcessDataOffset;
    public IntPtr SetImplicitProcessDataOffset;
    public IntPtr GetEventSystem;
    public method GetCurrentSystemId;
    public method SetCurrentSystemId;
    public IntPtr GetNumberSystems;
    public IntPtr GetSystemIdsByIndex;
    public IntPtr GetTotalNumberThreadsAndProcesses;
    public IntPtr GetCurrentSystemServer;
    public IntPtr GetSystemByServer;
    public IntPtr GetCurrentSystemServerName;
}
[FlagsAttribute]
internal enum Microsoft.Diagnostics.Runtime.DbgEng.MEM : Enum {
    public UInt32 value__;
    public static MEM COMMIT;
    public static MEM RESERVE;
    public static MEM DECOMMIT;
    public static MEM RELEASE;
    public static MEM FREE;
    public static MEM PRIVATE;
    public static MEM MAPPED;
    public static MEM RESET;
    public static MEM TOP_DOWN;
    public static MEM WRITE_WATCH;
    public static MEM PHYSICAL;
    public static MEM ROTATE;
    public static MEM LARGE_PAGES;
    public static MEM FOURMB_PAGES;
    public static MEM IMAGE;
}
internal class Microsoft.Diagnostics.Runtime.DbgEng.MEMORY_BASIC_INFORMATION64 : ValueType {
    public ulong BaseAddress;
    public ulong AllocationBase;
    public PAGE AllocationProtect;
    public UInt32 __alignment1;
    public ulong RegionSize;
    public MEM State;
    public PAGE Protect;
    public MEM Type;
    public UInt32 __alignment2;
}
[FlagsAttribute]
internal enum Microsoft.Diagnostics.Runtime.DbgEng.PAGE : Enum {
    public UInt32 value__;
    public static PAGE NOACCESS;
    public static PAGE READONLY;
    public static PAGE READWRITE;
    public static PAGE WRITECOPY;
    public static PAGE EXECUTE;
    public static PAGE EXECUTE_READ;
    public static PAGE EXECUTE_READWRITE;
    public static PAGE EXECUTE_WRITECOPY;
    public static PAGE GUARD;
    public static PAGE NOCACHE;
    public static PAGE WRITECOMBINE;
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.Diagnostics.Runtime.DbgEngDataReader : CommonMemoryReader {
    private static int s_totalInstanceCount;
    private DebugClient _client;
    private DebugControl _control;
    private DebugDataSpaces _spaces;
    private DebugAdvanced _advanced;
    private DebugSymbols _symbols;
    private DebugSystemObjects _systemObjects;
    private bool _disposed;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private List`1<ModuleInfo> _modules;
    private Nullable`1<int> _pointerSize;
    private Nullable`1<Architecture> _architecture;
    private static RefCountedFreeLibrary _library;
    [CompilerGeneratedAttribute]
private string <DisplayName>k__BackingField;
    public string DisplayName { get; }
    public OSPlatform TargetPlatform { get; }
    public bool IsThreadSafe { get; }
    public int ProcessId { get; }
    public Architecture Architecture { get; }
    public int PointerSize { get; }
    public DbgEngDataReader(string displayName, Stream stream, bool leaveOpen);
    public DbgEngDataReader(IntPtr pDebugClient);
    public DbgEngDataReader(string dumpFile);
    public DbgEngDataReader(int processId, bool invasive, UInt32 msecTimeout);
    private static DbgEngDataReader();
    [CompilerGeneratedAttribute]
public sealed virtual string get_DisplayName();
    public sealed virtual OSPlatform get_TargetPlatform();
    protected virtual override void Finalize();
    public sealed virtual bool get_IsThreadSafe();
    public sealed virtual int get_ProcessId();
    public sealed virtual Architecture get_Architecture();
    [DefaultDllImportSearchPathsAttribute("0")]
public static int DebugCreate(Guid& InterfaceId, IntPtr& Interface);
    public virtual int get_PointerSize();
    public sealed virtual void FlushCachedData();
    [NullableContextAttribute("0")]
public sealed virtual bool GetThreadContext(UInt32 threadID, UInt32 contextFlags, Span`1<byte> context);
    private UInt64[] GetImageBases();
    public sealed virtual IEnumerable`1<ModuleInfo> EnumerateModules();
    private static IntPtr CreateIDebugClient();
    private void CreateClient(IntPtr ptr);
    [NullableContextAttribute("0")]
public virtual int Read(ulong address, Span`1<byte> buffer);
    [NullableContextAttribute("2")]
public Version GetVersionInfo(ulong baseAddress);
    private bool FindModuleIndex(ulong baseAddr, Int32& index);
    public sealed virtual IEnumerable`1<UInt32> EnumerateOSThreadIds();
    public sealed virtual ulong GetThreadTeb(UInt32 osThreadId);
    public sealed virtual void Dispose();
    private void Dispose(bool disposing);
}
public class Microsoft.Diagnostics.Runtime.DebugLibraryInfo : object {
    [CompilerGeneratedAttribute]
private DebugLibraryKind <Kind>k__BackingField;
    [NullableAttribute("1")]
[CompilerGeneratedAttribute]
private string <FileName>k__BackingField;
    [CompilerGeneratedAttribute]
private Architecture <TargetArchitecture>k__BackingField;
    [CompilerGeneratedAttribute]
private SymbolProperties <ArchivedUnder>k__BackingField;
    [CompilerGeneratedAttribute]
private int <IndexFileSize>k__BackingField;
    [CompilerGeneratedAttribute]
private int <IndexTimeStamp>k__BackingField;
    [CompilerGeneratedAttribute]
private ImmutableArray`1<byte> <IndexBuildId>k__BackingField;
    [CompilerGeneratedAttribute]
private OSPlatform <Platform>k__BackingField;
    public DebugLibraryKind Kind { get; }
    [NullableAttribute("1")]
public string FileName { get; }
    public Architecture TargetArchitecture { get; }
    public SymbolProperties ArchivedUnder { get; }
    public int IndexFileSize { get; }
    public int IndexTimeStamp { get; }
    public ImmutableArray`1<byte> IndexBuildId { get; }
    public OSPlatform Platform { get; }
    public DebugLibraryInfo(DebugLibraryKind kind, string fileName, Architecture targetArch, OSPlatform platform, SymbolProperties archivedUnder, ImmutableArray`1<byte> clrBuildId);
    [NullableContextAttribute("1")]
public DebugLibraryInfo(DebugLibraryKind kind, string fileName, Architecture targetArch, SymbolProperties archivedUnder, int fileSize, int timestamp);
    [CompilerGeneratedAttribute]
public DebugLibraryKind get_Kind();
    [NullableContextAttribute("1")]
[CompilerGeneratedAttribute]
public string get_FileName();
    [CompilerGeneratedAttribute]
public Architecture get_TargetArchitecture();
    [CompilerGeneratedAttribute]
public SymbolProperties get_ArchivedUnder();
    [CompilerGeneratedAttribute]
public int get_IndexFileSize();
    [CompilerGeneratedAttribute]
public int get_IndexTimeStamp();
    [CompilerGeneratedAttribute]
public ImmutableArray`1<byte> get_IndexBuildId();
    [CompilerGeneratedAttribute]
public OSPlatform get_Platform();
    public virtual int GetHashCode();
    [NullableContextAttribute("2")]
public virtual bool Equals(object obj);
    [NullableContextAttribute("1")]
public virtual string ToString();
}
public enum Microsoft.Diagnostics.Runtime.DebugLibraryKind : Enum {
    public int value__;
    public static DebugLibraryKind Dac;
    public static DebugLibraryKind Dbi;
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal static class Microsoft.Diagnostics.Runtime.DebugOnly : object {
    [ConditionalAttribute("DEBUG")]
public static void Assert(bool mustBeTrue);
    [ConditionalAttribute("DEBUG")]
public static void Assert(bool mustBeTrue, string msg);
    [ConditionalAttribute("DEBUG")]
public static void Fail(string message);
}
internal enum Microsoft.Diagnostics.Runtime.DumpFileFormat : Enum {
    public int value__;
    public static DumpFileFormat Unknown;
    public static DumpFileFormat Minidump;
    public static DumpFileFormat Userdump64;
    public static DumpFileFormat ElfCoredump;
    public static DumpFileFormat CompressedArchive;
    public static DumpFileFormat MachOCoredump;
}
[ExtensionAttribute]
internal static class Microsoft.Diagnostics.Runtime.ExceptionExtensions : object {
    [NullableContextAttribute("1")]
[ExtensionAttribute]
public static Exception AddData(Exception exception, string name, object value);
}
[ExtensionAttribute]
internal static class Microsoft.Diagnostics.Runtime.Extensions.UnsignedToSigned : object {
    [ExtensionAttribute]
public static int ToSigned(UInt32 unsigned);
}
[IsReadOnlyAttribute]
public class Microsoft.Diagnostics.Runtime.Float80 : ValueType {
    public ulong Mantissa;
    public ushort Exponent;
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[IsReadOnlyAttribute]
public class Microsoft.Diagnostics.Runtime.GCDesc : ValueType {
    private static int s_GCDescSize;
    private Byte[] _data;
    public bool IsEmpty { get; }
    public GCDesc(Byte[] data);
    private static GCDesc();
    public bool get_IsEmpty();
    [IteratorStateMachineAttribute("Microsoft.Diagnostics.Runtime.GCDesc/<WalkObject>d__5")]
public IEnumerable`1<ValueTuple`2<ulong, int>> WalkObject(Byte[] buffer, int size);
    private int GetPointers(int curr, int i);
    private int GetSkip(int curr, int i);
    private int GetSeriesSize(int curr);
    private long GetSeriesOffset(int curr);
    private int GetHighestSeries();
    private int GetLowestSeries();
    private static int ComputeSize(int series);
    private int GetNumSeries();
}
public enum Microsoft.Diagnostics.Runtime.GCMode : Enum {
    public int value__;
    public static GCMode Cooperative;
    public static GCMode Preemptive;
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Microsoft.Diagnostics.Runtime.GCRoot : object {
    private ClrHeap _heap;
    private HashSet`1<ulong> _seen;
    private Dictionary`2<ulong, ChainLink> _found;
    [NullableAttribute("2")]
private Predicate`1<ClrObject> _targetPredicate;
    public GCRoot(ClrHeap heap, IEnumerable`1<ulong> targets);
    public GCRoot(ClrHeap heap, Predicate`1<ClrObject> isTarget);
    public IEnumerable`1<ValueTuple`2<ClrRoot, ChainLink>> EnumerateRootPaths();
    [IteratorStateMachineAttribute("Microsoft.Diagnostics.Runtime.GCRoot/<EnumerateRootPaths>d__7")]
public IEnumerable`1<ValueTuple`2<ClrRoot, ChainLink>> EnumerateRootPaths(CancellationToken cancellation);
    [IteratorStateMachineAttribute("Microsoft.Diagnostics.Runtime.GCRoot/<EnumerateRootsMultithreaded>d__8")]
private IEnumerable`1<ClrRoot> EnumerateRootsMultithreaded();
    private void WorkerThread(CancellationToken token, BlockingCollection`1<ClrRoot> queue);
    [NullableContextAttribute("2")]
public ChainLink FindPathFrom(ClrObject start);
    [NullableContextAttribute("2")]
public ChainLink FindPathFrom(ClrObject start, CancellationToken cancellation);
    private ChainLink CleanupAndGetResult(List`1<Byte[]> stack, ChainLink link, ReferenceList currStorage);
    private ChainLink AddLink(ChainLink curr, ulong obj);
    private ChainLink WalkObject(List`1<Byte[]> stack, ulong parent, ulong curr, CancellationToken cancellation);
    [ConditionalAttribute("GCROOT_TRACE")]
private static void TraceReference(ClrObject obj, ulong reference);
    [ConditionalAttribute("GCROOT_TRACE")]
private static void TraceSeen(ulong reference);
    [ConditionalAttribute("GCROOT_TRACE")]
private static void TraceFound(ulong reference, ChainLink link);
    [ConditionalAttribute("GCROOT_TRACE")]
private static void TraceFound(ClrObject obj);
    [ConditionalAttribute("GCROOT_TRACE")]
public static void TraceConsidering(ulong curr, ulong child);
    [ConditionalAttribute("GCROOT_TRACE")]
public static void TraceWalkObject(ClrObject obj);
}
public enum Microsoft.Diagnostics.Runtime.GCSegmentKind : Enum {
    public int value__;
    public static GCSegmentKind Generation0;
    public static GCSegmentKind Generation1;
    public static GCSegmentKind Generation2;
    public static GCSegmentKind Large;
    public static GCSegmentKind Pinned;
    public static GCSegmentKind Frozen;
    public static GCSegmentKind Ephemeral;
}
public enum Microsoft.Diagnostics.Runtime.Generation : Enum {
    public int value__;
    public static Generation Generation0;
    public static Generation Generation1;
    public static Generation Generation2;
    public static Generation Large;
    public static Generation Pinned;
    public static Generation Frozen;
    public static Generation Unknown;
}
public enum Microsoft.Diagnostics.Runtime.GetMemoryFailureReason : Enum {
    public int value__;
    public static GetMemoryFailureReason None;
    public static GetMemoryFailureReason ReserveSegment;
    public static GetMemoryFailureReason CommitSegmentBegin;
    public static GetMemoryFailureReason CommitEphemeralSegment;
    public static GetMemoryFailureReason GrowTable;
    public static GetMemoryFailureReason CommitTable;
}
public class Microsoft.Diagnostics.Runtime.HillClimbingLogEntry : object {
    [CompilerGeneratedAttribute]
private int <TickCount>k__BackingField;
    [CompilerGeneratedAttribute]
private HillClimbingTransition <StateOrTransition>k__BackingField;
    [CompilerGeneratedAttribute]
private int <NewThreadCount>k__BackingField;
    [CompilerGeneratedAttribute]
private int <SampleCount>k__BackingField;
    [CompilerGeneratedAttribute]
private float <Throughput>k__BackingField;
    public int TickCount { get; }
    public HillClimbingTransition StateOrTransition { get; }
    public int NewThreadCount { get; }
    public int SampleCount { get; }
    public float Throughput { get; }
    public HillClimbingLogEntry(int tickCount, HillClimbingTransition stateOrTransition, int newThreadCount, int sampleCount, float throughput);
    internal HillClimbingLogEntry(NativeHillClimbingLogEntry entry);
    [CompilerGeneratedAttribute]
public int get_TickCount();
    [CompilerGeneratedAttribute]
public HillClimbingTransition get_StateOrTransition();
    [CompilerGeneratedAttribute]
public int get_NewThreadCount();
    [CompilerGeneratedAttribute]
public int get_SampleCount();
    [CompilerGeneratedAttribute]
public float get_Throughput();
}
public enum Microsoft.Diagnostics.Runtime.HillClimbingTransition : Enum {
    public int value__;
    public static HillClimbingTransition Warmup;
    public static HillClimbingTransition Initializing;
    public static HillClimbingTransition RandomMove;
    public static HillClimbingTransition ClimbingMove;
    public static HillClimbingTransition ChangePoint;
    public static HillClimbingTransition Stabilizing;
    public static HillClimbingTransition Starvation;
    public static HillClimbingTransition ThreadTimedOut;
    public static HillClimbingTransition CooperativeBlocking;
    public static HillClimbingTransition Undefined;
}
[IsReadOnlyAttribute]
public class Microsoft.Diagnostics.Runtime.HotColdRegions : ValueType {
    [CompilerGeneratedAttribute]
private ulong <HotStart>k__BackingField;
    [CompilerGeneratedAttribute]
private UInt32 <HotSize>k__BackingField;
    [CompilerGeneratedAttribute]
private ulong <ColdStart>k__BackingField;
    [CompilerGeneratedAttribute]
private UInt32 <ColdSize>k__BackingField;
    public ulong HotStart { get; }
    public UInt32 HotSize { get; }
    public ulong ColdStart { get; }
    public UInt32 ColdSize { get; }
    public HotColdRegions(ulong hotStart, UInt32 hotSize, ulong coldStart, UInt32 coldSize);
    [CompilerGeneratedAttribute]
public ulong get_HotStart();
    [CompilerGeneratedAttribute]
public UInt32 get_HotSize();
    [CompilerGeneratedAttribute]
public ulong get_ColdStart();
    [CompilerGeneratedAttribute]
public UInt32 get_ColdSize();
}
[NullableContextAttribute("1")]
public interface Microsoft.Diagnostics.Runtime.IClrInfoProvider {
    public abstract virtual ClrInfo ProvideClrInfoForModule(DataTarget dataTarget, ModuleInfo module);
    public abstract virtual IServiceProvider GetDacServices(ClrInfo clrInfo, string providedPath, bool ignorePathMismatch);
}
[NullableContextAttribute("1")]
public interface Microsoft.Diagnostics.Runtime.IDataReader {
    public string DisplayName { get; }
    public bool IsThreadSafe { get; }
    public OSPlatform TargetPlatform { get; }
    public Architecture Architecture { get; }
    public int ProcessId { get; }
    public abstract virtual string get_DisplayName();
    public abstract virtual bool get_IsThreadSafe();
    public abstract virtual OSPlatform get_TargetPlatform();
    public abstract virtual Architecture get_Architecture();
    public abstract virtual int get_ProcessId();
    public abstract virtual IEnumerable`1<ModuleInfo> EnumerateModules();
    [NullableContextAttribute("0")]
public abstract virtual bool GetThreadContext(UInt32 threadID, UInt32 contextFlags, Span`1<byte> context);
    public abstract virtual void FlushCachedData();
}
public interface Microsoft.Diagnostics.Runtime.IDumpInfoProvider {
    public bool IsMiniOrTriage { get; }
    public abstract virtual bool get_IsMiniOrTriage();
}
public interface Microsoft.Diagnostics.Runtime.IFileLocator {
    [NullableContextAttribute("1")]
public abstract virtual string FindPEImage(string fileName, int buildTimeStamp, int imageSize, bool checkProperties);
    public abstract virtual string FindPEImage(string fileName, SymbolProperties archivedUnder, ImmutableArray`1<byte> buildIdOrUUID, OSPlatform originalPlatform, bool checkProperties);
    public abstract virtual string FindElfImage(string fileName, SymbolProperties archivedUnder, ImmutableArray`1<byte> buildId, bool checkProperties);
    public abstract virtual string FindMachOImage(string fileName, SymbolProperties archivedUnder, ImmutableArray`1<byte> uuid, bool checkProperties);
}
public class Microsoft.Diagnostics.Runtime.ILInfo : object {
    [CompilerGeneratedAttribute]
private ulong <Address>k__BackingField;
    [CompilerGeneratedAttribute]
private int <Length>k__BackingField;
    [CompilerGeneratedAttribute]
private UInt32 <Flags>k__BackingField;
    [CompilerGeneratedAttribute]
private UInt32 <LocalVarSignatureToken>k__BackingField;
    public ulong Address { get; }
    public int Length { get; }
    public UInt32 Flags { get; }
    public UInt32 LocalVarSignatureToken { get; }
    internal ILInfo(ulong address, int len, UInt32 flags, UInt32 localVarSignatureToken);
    [CompilerGeneratedAttribute]
public ulong get_Address();
    [CompilerGeneratedAttribute]
public int get_Length();
    [CompilerGeneratedAttribute]
public UInt32 get_Flags();
    [CompilerGeneratedAttribute]
public UInt32 get_LocalVarSignatureToken();
}
public class Microsoft.Diagnostics.Runtime.ILToNativeMap : ValueType {
    public int ILOffset;
    public ulong StartAddress;
    public ulong EndAddress;
    private int _reserved;
    [NullableContextAttribute("1")]
public virtual string ToString();
}
public interface Microsoft.Diagnostics.Runtime.IMemoryReader {
    public int PointerSize { get; }
    public abstract virtual int get_PointerSize();
    public abstract virtual int Read(ulong address, Span`1<byte> buffer);
    public abstract virtual bool Read(ulong address, T& value);
    public abstract virtual T Read(ulong address);
    public abstract virtual bool ReadPointer(ulong address, UInt64& value);
    public abstract virtual ulong ReadPointer(ulong address);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
internal static class Microsoft.Diagnostics.Runtime.ImmutableArrayExtensions : object {
    [ExtensionAttribute]
internal static ImmutableArray`1<T> AsImmutableArray(T[] array);
    [ExtensionAttribute]
internal static ImmutableArray`1<T> MoveOrCopyToImmutable(Builder<T> builder);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.Diagnostics.Runtime.Implementation.ClrConstructedType : ClrType {
    private int _ranks;
    [CompilerGeneratedAttribute]
private ClrType <ComponentType>k__BackingField;
    [CompilerGeneratedAttribute]
private ClrElementType <ElementType>k__BackingField;
    public ClrHeap Heap { get; }
    public ClrType ComponentType { get; }
    public string Name { get; }
    public bool IsEnum { get; }
    public ClrElementType ElementType { get; }
    public bool IsPointer { get; }
    public bool IsFinalizable { get; }
    [NullableAttribute("2")]
public ClrType BaseType { get; }
    public GCDesc GCDesc { get; }
    public bool IsArray { get; }
    public TypeAttributes TypeAttributes { get; }
    public ClrConstructedType(ClrType componentType, int ranks, bool pointer);
    public virtual ClrHeap get_Heap();
    [CompilerGeneratedAttribute]
public virtual ClrType get_ComponentType();
    public virtual string get_Name();
    public virtual bool get_IsEnum();
    public virtual ClrEnum AsEnum();
    [CompilerGeneratedAttribute]
public virtual ClrElementType get_ElementType();
    public virtual bool IsFinalizeSuppressed(ulong obj);
    public virtual bool get_IsPointer();
    public virtual bool get_IsFinalizable();
    public virtual ClrInstanceField GetFieldByName(string name);
    public virtual ClrStaticField GetStaticFieldByName(string name);
    [NullableContextAttribute("2")]
public virtual ClrType get_BaseType();
    public virtual ulong GetArrayElementAddress(ulong objRef, int index);
    [NullableContextAttribute("0")]
public virtual T[] ReadArrayElements(ulong objRef, int start, int count);
    public virtual GCDesc get_GCDesc();
    public virtual bool get_IsArray();
    public virtual TypeAttributes get_TypeAttributes();
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
internal class Microsoft.Diagnostics.Runtime.Implementation.ClrDacType : ClrType {
    private string _name;
    private TypeAttributes _attributes;
    private ulong _loaderAllocatorHandle;
    private ulong _assemblyLoadContextHandle;
    private ClrElementType _elementType;
    private GCDesc _gcDesc;
    private ClrType _componentType;
    private int _baseArrayOffset;
    [NullableAttribute("1")]
[CompilerGeneratedAttribute]
private ClrHeap <Heap>k__BackingField;
    [CompilerGeneratedAttribute]
private ClrType <BaseType>k__BackingField;
    private static UInt32 FinalizationSuppressedFlag;
    public string Name { get; }
    public ClrType ComponentType { get; }
    public GCDesc GCDesc { get; }
    public ClrElementType ElementType { get; }
    [NullableAttribute("1")]
public ClrHeap Heap { get; }
    public ClrType BaseType { get; }
    public bool IsException { get; }
    public bool IsEnum { get; }
    public bool IsFree { get; }
    public bool IsFinalizable { get; }
    public bool IsArray { get; }
    public bool IsCollectible { get; }
    public ulong LoaderAllocatorHandle { get; }
    public ulong AssemblyLoadContextAddress { get; }
    public bool IsString { get; }
    public TypeAttributes TypeAttributes { get; }
    [NullableContextAttribute("1")]
public ClrDacType(IAbstractTypeHelpers helpers, ClrHeap heap, ClrType baseType, ClrType componentType, ClrModule module, TypeInfo& data, string name);
    [NullableContextAttribute("1")]
[IteratorStateMachineAttribute("Microsoft.Diagnostics.Runtime.Implementation.ClrDacType/<EnumerateGenericParameters>d__8")]
public virtual IEnumerable`1<ClrGenericParameter> EnumerateGenericParameters();
    public virtual string get_Name();
    public virtual ClrType get_ComponentType();
    public virtual GCDesc get_GCDesc();
    public virtual ClrElementType get_ElementType();
    [NullableContextAttribute("1")]
[CompilerGeneratedAttribute]
public virtual ClrHeap get_Heap();
    [CompilerGeneratedAttribute]
public virtual ClrType get_BaseType();
    [ConditionalAttribute("DEBUG")]
private void DebugOnlyLoadLazyValues();
    public void SetComponentType(ClrType type);
    private GCDesc GetOrCreateGCDesc();
    private ClrElementType GetElementType();
    public virtual bool get_IsException();
    public virtual bool get_IsEnum();
    [NullableContextAttribute("1")]
public virtual ClrEnum AsEnum();
    public virtual bool get_IsFree();
    public virtual bool IsFinalizeSuppressed(ulong obj);
    public virtual bool get_IsFinalizable();
    public virtual bool get_IsArray();
    public virtual bool get_IsCollectible();
    public virtual ulong get_LoaderAllocatorHandle();
    public virtual ulong get_AssemblyLoadContextAddress();
    public virtual bool get_IsString();
    [NullableContextAttribute("1")]
public virtual ClrStaticField GetStaticFieldByName(string name);
    [NullableContextAttribute("1")]
public virtual ClrInstanceField GetFieldByName(string name);
    public virtual ulong GetArrayElementAddress(ulong objRef, int index);
    [NullableContextAttribute("0")]
public virtual T[] ReadArrayElements(ulong objRef, int start, int count);
    public static string FixGenerics(string name);
    private void InitFlags();
    public virtual TypeAttributes get_TypeAttributes();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.Diagnostics.Runtime.Implementation.ClrGenericType : ClrType {
    [CompilerGeneratedAttribute]
private ClrGenericParameter <GenericParameter>k__BackingField;
    [CompilerGeneratedAttribute]
private ClrHeap <Heap>k__BackingField;
    public ClrGenericParameter GenericParameter { get; }
    public GCDesc GCDesc { get; }
    [NullableAttribute("2")]
public string Name { get; }
    public ClrHeap Heap { get; }
    public ClrElementType ElementType { get; }
    public bool IsFinalizable { get; }
    public TypeAttributes TypeAttributes { get; }
    [NullableAttribute("2")]
public ClrType BaseType { get; }
    [NullableAttribute("2")]
public ClrType ComponentType { get; }
    public bool IsArray { get; }
    public bool IsEnum { get; }
    public ClrGenericType(IAbstractTypeHelpers helpers, ClrHeap heap, ClrModule module, ClrGenericParameter clrGenericParameter);
    [CompilerGeneratedAttribute]
public ClrGenericParameter get_GenericParameter();
    public virtual GCDesc get_GCDesc();
    [NullableContextAttribute("2")]
public virtual string get_Name();
    [CompilerGeneratedAttribute]
public virtual ClrHeap get_Heap();
    public virtual ClrElementType get_ElementType();
    public virtual bool get_IsFinalizable();
    public virtual TypeAttributes get_TypeAttributes();
    [NullableContextAttribute("2")]
public virtual ClrType get_BaseType();
    [NullableContextAttribute("2")]
public virtual ClrType get_ComponentType();
    public virtual bool get_IsArray();
    public virtual bool get_IsEnum();
    public virtual ClrEnum AsEnum();
    public virtual ulong GetArrayElementAddress(ulong objRef, int index);
    public virtual ClrInstanceField GetFieldByName(string name);
    public virtual ClrStaticField GetStaticFieldByName(string name);
    public virtual bool IsFinalizeSuppressed(ulong obj);
    [NullableContextAttribute("0")]
public virtual T[] ReadArrayElements(ulong objRef, int start, int count);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.Diagnostics.Runtime.Implementation.ClrPrimitiveType : ClrType {
    [CompilerGeneratedAttribute]
private ClrElementType <ElementType>k__BackingField;
    [CompilerGeneratedAttribute]
private ClrHeap <Heap>k__BackingField;
    public bool IsEnum { get; }
    public ClrElementType ElementType { get; }
    [NullableAttribute("2")]
public ClrType BaseType { get; }
    public ClrHeap Heap { get; }
    public bool IsFinalizable { get; }
    public TypeAttributes TypeAttributes { get; }
    public string Name { get; }
    public GCDesc GCDesc { get; }
    [NullableAttribute("2")]
public ClrType ComponentType { get; }
    public bool IsArray { get; }
    public ClrPrimitiveType(IAbstractTypeHelpers helpers, ClrModule module, ClrHeap heap, ClrElementType type);
    public virtual bool get_IsEnum();
    public virtual ClrEnum AsEnum();
    [CompilerGeneratedAttribute]
public virtual ClrElementType get_ElementType();
    [NullableContextAttribute("2")]
public virtual ClrType get_BaseType();
    [CompilerGeneratedAttribute]
public virtual ClrHeap get_Heap();
    public virtual bool get_IsFinalizable();
    public virtual TypeAttributes get_TypeAttributes();
    public virtual string get_Name();
    public virtual ulong GetArrayElementAddress(ulong objRef, int index);
    [NullableContextAttribute("0")]
public virtual T[] ReadArrayElements(ulong objRef, int start, int count);
    public virtual ClrInstanceField GetFieldByName(string name);
    public virtual ClrStaticField GetStaticFieldByName(string name);
    public virtual bool IsFinalizeSuppressed(ulong obj);
    public virtual GCDesc get_GCDesc();
    [NullableContextAttribute("2")]
public virtual ClrType get_ComponentType();
    public virtual bool get_IsArray();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.Diagnostics.Runtime.Implementation.ClrStringType : ClrType {
    [CompilerGeneratedAttribute]
private ClrHeap <Heap>k__BackingField;
    private static UInt32 FinalizationSuppressedFlag;
    public GCDesc GCDesc { get; }
    [NullableAttribute("2")]
public string Name { get; }
    public ClrHeap Heap { get; }
    public ClrElementType ElementType { get; }
    public bool IsFinalizable { get; }
    public TypeAttributes TypeAttributes { get; }
    [NullableAttribute("2")]
public ClrType BaseType { get; }
    [NullableAttribute("2")]
public ClrType ComponentType { get; }
    public bool IsArray { get; }
    public bool IsEnum { get; }
    public bool IsString { get; }
    public ClrStringType(ClrModule module, IAbstractTypeHelpers helpers, ClrHeap heap, TypeInfo& typeInfo);
    public virtual GCDesc get_GCDesc();
    [NullableContextAttribute("2")]
public virtual string get_Name();
    [CompilerGeneratedAttribute]
public virtual ClrHeap get_Heap();
    public virtual ClrElementType get_ElementType();
    public virtual bool get_IsFinalizable();
    public virtual TypeAttributes get_TypeAttributes();
    [NullableContextAttribute("2")]
public virtual ClrType get_BaseType();
    [NullableContextAttribute("2")]
public virtual ClrType get_ComponentType();
    public virtual bool get_IsArray();
    public virtual bool get_IsEnum();
    public virtual bool get_IsString();
    public virtual ClrEnum AsEnum();
    public virtual ulong GetArrayElementAddress(ulong objRef, int index);
    [NullableContextAttribute("0")]
public virtual T[] ReadArrayElements(ulong objRef, int start, int count);
    public virtual ClrStaticField GetStaticFieldByName(string name);
    public virtual ClrInstanceField GetFieldByName(string name);
    public virtual bool IsFinalizeSuppressed(ulong obj);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.Diagnostics.Runtime.Implementation.ClrTypeFactory : object {
    private static int mdtTypeDef;
    private static int mdtTypeRef;
    private ClrHeap _heap;
    private IAbstractTypeHelpers _typeHelpers;
    private CacheOptions _options;
    private GCState _gcInfo;
    [NullableAttribute("2")]
private ClrType[] modreq(System.Runtime.CompilerServices.IsVolatile) _basicTypes;
    private Dictionary`2<ulong, ClrType> _types;
    private ClrType _objectType;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private Dictionary`2<ulong, ClrModule> _modules;
    [NullableAttribute("2")]
private ClrModule _errorModule;
    [NullableAttribute("2")]
private ClrType _errorType;
    public ClrType ObjectType { get; }
    public ClrType ErrorType { get; }
    public ClrTypeFactory(ClrHeap heap, IAbstractTypeHelpers typeHelpers, GCState& gcInfo);
    public ClrType CreateFreeType();
    public ClrType CreateStringType();
    [NullableContextAttribute("2")]
public string GetTypeName(ulong module, ulong mt, int token);
    public ClrType get_ObjectType();
    public ClrType CreateExceptionType();
    public ClrType get_ErrorType();
    public ClrType CreateSystemType(ClrHeap heap, ClrModule bcl, ulong mt, string typeName);
    [NullableContextAttribute("2")]
public ClrType GetOrCreateType(ulong mt, ulong obj);
    [NullableContextAttribute("2")]
public ClrType TryGetType(ulong mt);
    public ClrType GetOrCreateTypeFromSignature(ClrModule module, SigParser parser, IEnumerable`1<ClrGenericParameter> typeParameters, IEnumerable`1<ClrGenericParameter> methodParameters);
    [NullableContextAttribute("2")]
public ClrType GetOrCreateTypeFromToken(ClrModule module, int token);
    public ClrType GetOrCreateArrayType(ClrType innerType, int ranks);
    public ClrType GetOrCreatePointerType(ClrType innerType, int depth);
    [NullableContextAttribute("2")]
private ClrType TryGetComponentType(ulong obj);
    public ClrType GetOrCreateBasicType(ClrElementType basicType);
    private ClrModule GetModule(ulong moduleAddress);
}
internal class Microsoft.Diagnostics.Runtime.Implementation.ComSyncBlock : SyncBlock {
    [CompilerGeneratedAttribute]
private SyncBlockComFlags <ComFlags>k__BackingField;
    public SyncBlockComFlags ComFlags { get; }
    public bool IsComCallWrapper { get; }
    public bool IsRuntimeCallWrapper { get; }
    public bool IsComClassFactory { get; }
    public ComSyncBlock(ulong obj, int index, SyncBlockComFlags comFlags);
    [CompilerGeneratedAttribute]
public virtual SyncBlockComFlags get_ComFlags();
    public virtual bool get_IsComCallWrapper();
    public virtual bool get_IsRuntimeCallWrapper();
    public virtual bool get_IsComClassFactory();
}
internal static class Microsoft.Diagnostics.Runtime.Implementation.DacNameParser : object {
    private static char GenericAritySpecifier;
    private static char ArgSeparator;
    private static char NestedClassSpecifier;
    private static char GenericArgListAssemblyQualifiedTypeNameOrArrayStartSpecifier;
    private static char GenericArgListAssemblyQualifiedTypeNameOrArrayEndSpecifier;
    [NullableContextAttribute("2")]
public static string Parse(string name);
    [NullableContextAttribute("1")]
private static int ManuallyCalculateArity(string name, int startPos);
    [NullableContextAttribute("1")]
private static int MoveCurPosPastWhitespaceOrFail(string name, int curPos);
    [NullableContextAttribute("2")]
private static bool ResolveParsedGenericList(int parsingGenericArgListDepth, List`1<TypeNameSegment> nameSegments, List`1<TypeNameSegment> genericArgs);
    [NullableContextAttribute("1")]
private static bool TryPatchUnfulfilledGenericArgs(int genericTargetIndex, List`1<TypeNameSegment> genericArgs);
    [NullableContextAttribute("1")]
private static void UnifyNestedClasses(int parsingGenericArgListDepth, List`1<TypeNameSegment> genericArgs);
    private static bool ShouldContinueParsing(ParsingState state);
    [NullableContextAttribute("2")]
private static bool ReturnOriginalDACString(int curPos, int inputStringLength, List`1<TypeNameSegment> queuedNameSegments);
    private static ValueTuple`2<int, int> GetTypeNameExtent(string name, int cur, bool parsingGenericArgList);
    private static ValueTuple`2<int, int> ParseGenericArityCountFromStringInPlace(string input, int curPos);
    private static ValueTuple`2<ParsingState, int> DetermineNextStateAndPos(string name, int curPos);
    [NullableContextAttribute("2")]
private static bool DoAnyArgsOrTypeNamesHaveUnfulfilledGenericArguments(List`1<TypeNameSegment> nameSegments, List`1<TypeNameSegment> genericArgs);
    [CompilerGeneratedAttribute]
internal static void <Parse>g__EnsureNameSegmentList|5_0(<>c__DisplayClass5_1& );
    [CompilerGeneratedAttribute]
internal static void <Parse>g__EnsureGenericArgList|5_1(<>c__DisplayClass5_1& );
    [NullableContextAttribute("1")]
[CompilerGeneratedAttribute]
internal static string <Parse>g__ParseTypeNameNoStateAdvance|5_2(<>c__DisplayClass5_0& , <>c__DisplayClass5_1& );
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
internal static bool <DoAnyArgsOrTypeNamesHaveUnfulfilledGenericArguments>g__DoAnyArgsOrTypeNamesHaveUnfulfilledGenericArgumentsWorker|16_0(List`1<TypeNameSegment> current);
}
internal class Microsoft.Diagnostics.Runtime.Implementation.DacRequests : object {
    internal static UInt32 VERSION;
    internal static UInt32 THREAD_STORE_DATA;
    internal static UInt32 APPDOMAIN_STORE_DATA;
    internal static UInt32 APPDOMAIN_LIST;
    internal static UInt32 APPDOMAIN_DATA;
    internal static UInt32 APPDOMAIN_NAME;
    internal static UInt32 APPDOMAIN_APP_BASE;
    internal static UInt32 APPDOMAIN_PRIVATE_BIN_PATHS;
    internal static UInt32 APPDOMAIN_CONFIG_FILE;
    internal static UInt32 ASSEMBLY_LIST;
    internal static UInt32 FAILED_ASSEMBLY_LIST;
    internal static UInt32 ASSEMBLY_DATA;
    internal static UInt32 ASSEMBLY_NAME;
    internal static UInt32 ASSEMBLY_DISPLAY_NAME;
    internal static UInt32 ASSEMBLY_LOCATION;
    internal static UInt32 FAILED_ASSEMBLY_DATA;
    internal static UInt32 FAILED_ASSEMBLY_DISPLAY_NAME;
    internal static UInt32 FAILED_ASSEMBLY_LOCATION;
    internal static UInt32 THREAD_DATA;
    internal static UInt32 THREAD_THINLOCK_DATA;
    internal static UInt32 CONTEXT_DATA;
    internal static UInt32 METHODDESC_DATA;
    internal static UInt32 METHODDESC_IP_DATA;
    internal static UInt32 METHODDESC_NAME;
    internal static UInt32 METHODDESC_FRAME_DATA;
    internal static UInt32 CODEHEADER_DATA;
    internal static UInt32 THREADPOOL_DATA;
    internal static UInt32 WORKREQUEST_DATA;
    internal static UInt32 OBJECT_DATA;
    internal static UInt32 FRAME_NAME;
    internal static UInt32 OBJECT_STRING_DATA;
    internal static UInt32 OBJECT_CLASS_NAME;
    internal static UInt32 METHODTABLE_NAME;
    internal static UInt32 METHODTABLE_DATA;
    internal static UInt32 EECLASS_DATA;
    internal static UInt32 FIELDDESC_DATA;
    internal static UInt32 MANAGEDSTATICADDR;
    internal static UInt32 MODULE_DATA;
    internal static UInt32 MODULEMAP_TRAVERSE;
    internal static UInt32 MODULETOKEN_DATA;
    internal static UInt32 PEFILE_DATA;
    internal static UInt32 PEFILE_NAME;
    internal static UInt32 ASSEMBLYMODULE_LIST;
    internal static UInt32 GCHEAP_DATA;
    internal static UInt32 GCHEAP_LIST;
    internal static UInt32 GCHEAPDETAILS_DATA;
    internal static UInt32 GCHEAPDETAILS_STATIC_DATA;
    internal static UInt32 HEAPSEGMENT_DATA;
    internal static UInt32 UNITTEST_DATA;
    internal static UInt32 ISSTUB;
    internal static UInt32 DOMAINLOCALMODULE_DATA;
    internal static UInt32 DOMAINLOCALMODULEFROMAPPDOMAIN_DATA;
    internal static UInt32 DOMAINLOCALMODULE_DATA_FROM_MODULE;
    internal static UInt32 SYNCBLOCK_DATA;
    internal static UInt32 SYNCBLOCK_CLEANUP_DATA;
    internal static UInt32 HANDLETABLE_TRAVERSE;
    internal static UInt32 RCWCLEANUP_TRAVERSE;
    internal static UInt32 EHINFO_TRAVERSE;
    internal static UInt32 STRESSLOG_DATA;
    internal static UInt32 JITLIST;
    internal static UInt32 JIT_HELPER_FUNCTION_NAME;
    internal static UInt32 JUMP_THUNK_TARGET;
    internal static UInt32 LOADERHEAP_TRAVERSE;
    internal static UInt32 MANAGER_LIST;
    internal static UInt32 JITHEAPLIST;
    internal static UInt32 CODEHEAP_LIST;
    internal static UInt32 METHODTABLE_SLOT;
    internal static UInt32 VIRTCALLSTUBHEAP_TRAVERSE;
    internal static UInt32 NESTEDEXCEPTION_DATA;
    internal static UInt32 USEFULGLOBALS;
    internal static UInt32 CLRTLSDATA_INDEX;
    internal static UInt32 MODULE_FINDIL;
    internal static UInt32 CLR_WATSON_BUCKETS;
    internal static UInt32 OOM_DATA;
    internal static UInt32 OOM_STATIC_DATA;
    internal static UInt32 GCHEAP_HEAPANALYZE_DATA;
    internal static UInt32 GCHEAP_HEAPANALYZE_STATIC_DATA;
    internal static UInt32 HANDLETABLE_FILTERED_TRAVERSE;
    internal static UInt32 METHODDESC_TRANSPARENCY_DATA;
    internal static UInt32 EECLASS_TRANSPARENCY_DATA;
    internal static UInt32 THREAD_STACK_BOUNDS;
    internal static UInt32 HILL_CLIMBING_LOG_ENTRY;
    internal static UInt32 THREADPOOL_DATA_2;
    internal static UInt32 THREADLOCALMODULE_DAT;
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.Diagnostics.Runtime.Implementation.DotNetClrInfoProvider : object {
    private static string c_desktopModuleName;
    private static string c_coreModuleName;
    private static string c_linuxCoreModuleName;
    private static string c_macOSCoreModuleName;
    private static string c_desktopDacFileNameBase;
    private static string c_coreDacFileNameBase;
    private static string c_desktopDacFileName;
    private static string c_coreDacFileName;
    private static string c_linuxCoreDacFileName;
    private static string c_macOSCoreDacFileName;
    private static string c_windowsDbiFileName;
    private static string c_linuxCoreDbiFileName;
    private static string c_macOSCoreDbiFileName;
    public sealed virtual IServiceProvider GetDacServices(ClrInfo clrInfo, string providedPath, bool ignoreMismatch);
    private static DacLibrary GetDacLibraryFromPath(ClrInfo clrInfo, string dacPath, bool ignoreMismatch);
    private static DacLibrary CreateDacFromPath(ClrInfo clrInfo, string dacPath, bool ignoreMismatch);
    public virtual ClrInfo ProvideClrInfoForModule(DataTarget dataTarget, ModuleInfo module);
    protected ClrInfo CreateClrInfo(DataTarget dataTarget, ModuleInfo module, ulong runtimeInfo, ClrFlavor flavor);
    [IteratorStateMachineAttribute("Microsoft.Diagnostics.Runtime.Implementation.DotNetClrInfoProvider/<EnumerateUnique>d__18")]
private static IEnumerable`1<DebugLibraryInfo> EnumerateUnique(List`1<DebugLibraryInfo> artifacts);
    private static string GetWindowsLongNameDac(ClrFlavor flavor, Architecture currentArchitecture, Architecture targetArchitecture, Version version);
    private static string ArchitectureToName(Architecture arch);
    [NullableContextAttribute("2")]
private static string GetDbiFileName(ClrFlavor flavor, OSPlatform targetPlatform);
    [NullableContextAttribute("2")]
private static string GetDacFileName(ClrFlavor flavor, OSPlatform targetPlatform);
    private static bool IsSupportedRuntime(ModuleInfo module, ClrFlavor& flavor);
    private static OSPlatform GetCurrentPlatform();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.Diagnostics.Runtime.Implementation.ElfModuleInfo : ModuleInfo {
    private IDataReader _reader;
    [NullableAttribute("2")]
private ElfFile _elf;
    [NullableAttribute("2")]
private object _buildId;
    [NullableAttribute("2")]
private Version _version;
    [CompilerGeneratedAttribute]
private long <ImageSize>k__BackingField;
    public ModuleKind Kind { get; }
    public long ImageSize { get; }
    [NullableAttribute("0")]
public ImmutableArray`1<byte> BuildId { get; }
    public Version Version { get; }
    public ElfModuleInfo(IDataReader reader, ElfFile elf, ulong imageBase, long size, string fileName);
    public virtual ModuleKind get_Kind();
    [CompilerGeneratedAttribute]
public virtual long get_ImageSize();
    [NullableContextAttribute("0")]
public virtual ImmutableArray`1<byte> get_BuildId();
    public virtual ulong GetExportSymbolAddress(string symbol);
    public virtual Version get_Version();
}
internal abstract class Microsoft.Diagnostics.Runtime.Implementation.FileLocatorBase : object {
    [NullableAttribute("1")]
private static string MachOPlatformKey;
    [NullableAttribute("1")]
private static string ElfPlatformKey;
    public virtual string FindElfImage(string fileName, SymbolProperties archivedUnder, ImmutableArray`1<byte> buildId, bool checkProperties);
    public virtual string FindMachOImage(string fileName, SymbolProperties archivedUnder, ImmutableArray`1<byte> uuid, bool checkProperties);
    public virtual string FindPEImage(string fileName, SymbolProperties archivedUnder, ImmutableArray`1<byte> buildIdOrUUID, OSPlatform originalPlatform, bool checkProperties);
    [NullableContextAttribute("1")]
public virtual string FindPEImage(string fileName, int buildTimeStamp, int imageSize, bool checkProperties);
    [NullableContextAttribute("1")]
private static string GetUnixKey(string osKey, string fileName, SymbolProperties archivedUnder, ImmutableArray`1<byte> buildId);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.Diagnostics.Runtime.Implementation.FileSymbolCache : FileLocatorBase {
    private Dictionary`2<string, Task> _writingTo;
    [CompilerGeneratedAttribute]
private string <Location>k__BackingField;
    public static bool IsCaseInsensitiveFileSystem { get; }
    public string Location { get; }
    public FileSymbolCache(string cacheLocation);
    public static bool get_IsCaseInsensitiveFileSystem();
    private static StringComparer GetEqualityComparer();
    [CompilerGeneratedAttribute]
public string get_Location();
    [NullableContextAttribute("0")]
public virtual string FindElfImage(string fileName, SymbolProperties archivedUnder, ImmutableArray`1<byte> buildId, bool checkProperties);
    [NullableContextAttribute("0")]
public virtual string FindMachOImage(string fileName, SymbolProperties archivedUnder, ImmutableArray`1<byte> uuid, bool checkProperties);
    public virtual string FindPEImage(string fileName, int buildTimeStamp, int imageSize, bool checkProperties);
    [NullableContextAttribute("0")]
public virtual string FindPEImage(string fileName, SymbolProperties archivedUnder, ImmutableArray`1<byte> buildIdOrUUID, OSPlatform platform, bool checkProperties);
    [NullableContextAttribute("2")]
private string FindImage(string key);
    internal string Store(Stream stream, string key);
}
internal class Microsoft.Diagnostics.Runtime.Implementation.FullSyncBlock : SyncBlock {
    [CompilerGeneratedAttribute]
private SyncBlockComFlags <ComFlags>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsMonitorHeld>k__BackingField;
    [CompilerGeneratedAttribute]
private ulong <HoldingThreadAddress>k__BackingField;
    [CompilerGeneratedAttribute]
private int <RecursionCount>k__BackingField;
    [CompilerGeneratedAttribute]
private int <WaitingThreadCount>k__BackingField;
    public SyncBlockComFlags ComFlags { get; }
    public bool IsComCallWrapper { get; }
    public bool IsRuntimeCallWrapper { get; }
    public bool IsComClassFactory { get; }
    public bool IsMonitorHeld { get; }
    public ulong HoldingThreadAddress { get; }
    public int RecursionCount { get; }
    public int WaitingThreadCount { get; }
    public FullSyncBlock(SyncBlockInfo& syncBlk);
    [CompilerGeneratedAttribute]
public virtual SyncBlockComFlags get_ComFlags();
    public virtual bool get_IsComCallWrapper();
    public virtual bool get_IsRuntimeCallWrapper();
    public virtual bool get_IsComClassFactory();
    [CompilerGeneratedAttribute]
public virtual bool get_IsMonitorHeld();
    [CompilerGeneratedAttribute]
public virtual ulong get_HoldingThreadAddress();
    [CompilerGeneratedAttribute]
public virtual int get_RecursionCount();
    [CompilerGeneratedAttribute]
public virtual int get_WaitingThreadCount();
}
internal class Microsoft.Diagnostics.Runtime.Implementation.IMAGE_COR_ILMETHOD : ValueType {
    public UInt32 FlagsSizeStack;
    public UInt32 CodeSize;
    public UInt32 LocalVarSignatureToken;
    public static UInt32 FormatShift;
    public static UInt32 FormatMask;
    public static UInt32 TinyFormat;
    public static UInt32 mdSignatureNil;
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
internal class Microsoft.Diagnostics.Runtime.Implementation.PEModuleInfo : ModuleInfo {
    [NullableAttribute("1")]
private IDataReader _dataReader;
    private bool _isVirtual;
    private int _timestamp;
    private int _filesize;
    private bool _loaded;
    private PdbInfo _pdb;
    private Nullable`1<bool> _isManaged;
    private PEImage _peImage;
    private Version _version;
    public ModuleKind Kind { get; }
    [NullableAttribute("1")]
public Version Version { get; }
    public PdbInfo Pdb { get; }
    public bool IsManaged { get; }
    public int IndexFileSize { get; }
    public int IndexTimeStamp { get; }
    public IResourceNode ResourceRoot { get; }
    [NullableContextAttribute("1")]
public PEModuleInfo(IDataReader dataReader, ulong imageBase, string fileName, bool isVirtualHint);
    [NullableContextAttribute("1")]
public PEModuleInfo(IDataReader dataReader, ulong imageBase, string fileName, bool isVirtual, int timestamp, int filesize, Version version);
    public virtual ModuleKind get_Kind();
    internal PEImage GetPEImage();
    [NullableContextAttribute("1")]
public virtual Version get_Version();
    public virtual PdbInfo get_Pdb();
    public virtual bool get_IsManaged();
    public virtual int get_IndexFileSize();
    public virtual int get_IndexTimeStamp();
    [NullableContextAttribute("1")]
public virtual ulong GetExportSymbolAddress(string symbol);
    protected virtual void TrySetProperties(int indexFileSize, int indexTimeStamp, Version version);
    public virtual IResourceNode get_ResourceRoot();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.Diagnostics.Runtime.Implementation.ReadVirtualStream : Stream {
    private long _pos;
    private long _disp;
    private long _len;
    private IDataReader _dataReader;
    public bool CanRead { get; }
    public bool CanSeek { get; }
    public bool CanWrite { get; }
    public long Length { get; }
    public long Position { get; public set; }
    public ReadVirtualStream(IDataReader dataReader, long displacement, long len);
    public virtual bool get_CanRead();
    public virtual bool get_CanSeek();
    public virtual bool get_CanWrite();
    public virtual void Flush();
    public virtual long get_Length();
    public virtual long get_Position();
    public virtual void set_Position(long value);
    public virtual int Read(Byte[] buffer, int offset, int count);
    public virtual long Seek(long offset, SeekOrigin origin);
    public virtual void SetLength(long value);
    public virtual void Write(Byte[] buffer, int offset, int count);
}
internal class Microsoft.Diagnostics.Runtime.Implementation.SafeWin32Handle : SafeHandleZeroOrMinusOneIsInvalid {
    public SafeWin32Handle(IntPtr handle);
    public SafeWin32Handle(IntPtr handle, bool ownsHandle);
    protected virtual bool ReleaseHandle();
    public static bool CloseHandle(IntPtr handle);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.Diagnostics.Runtime.Implementation.SymbolGroup : object {
    private static string s_defaultCacheLocation;
    [NullableAttribute("2")]
private static FileSymbolCache modreq(System.Runtime.CompilerServices.IsVolatile) s_cache;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private ImmutableArray`1<IFileLocator> _groups;
    public SymbolGroup(IEnumerable`1<IFileLocator> groups);
    private static SymbolGroup();
    public sealed virtual string FindPEImage(string fileName, int buildTimeStamp, int imageSize, bool checkProperties);
    [NullableContextAttribute("0")]
public sealed virtual string FindPEImage(string fileName, SymbolProperties archivedUnder, ImmutableArray`1<byte> buildIdOrUUID, OSPlatform originalPlatform, bool checkProperties);
    [NullableContextAttribute("0")]
public sealed virtual string FindElfImage(string fileName, SymbolProperties archivedUnder, ImmutableArray`1<byte> buildId, bool checkProperties);
    [NullableContextAttribute("0")]
public sealed virtual string FindMachOImage(string fileName, SymbolProperties archivedUnder, ImmutableArray`1<byte> uuid, bool checkProperties);
    private static FileSymbolCache GetDefaultCache();
    public static IFileLocator CreateFromSymbolPath(string symbolPath, bool trace, TokenCredential credential);
    internal static ValueTuple`2<string, String[]> EnumerateEntries(string part);
    [IteratorStateMachineAttribute("Microsoft.Diagnostics.Runtime.Implementation.SymbolGroup/<EnumerateParts>d__11")]
private static IEnumerable`1<string> EnumerateParts(string path);
    private static bool IsUrl(string path);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.Diagnostics.Runtime.Implementation.SymbolServer : FileLocatorBase {
    public static string Msdl;
    private static string SymwebHost;
    [NullableAttribute("2")]
private TokenCredential _tokenCredential;
    private AccessToken _accessToken;
    private FileSymbolCache _cache;
    private bool _trace;
    private HttpClient _http;
    [CompilerGeneratedAttribute]
private string <Server>k__BackingField;
    public string Server { get; private set; }
    internal SymbolServer(FileSymbolCache cache, string server, bool trace, TokenCredential credential);
    [CompilerGeneratedAttribute]
public string get_Server();
    [CompilerGeneratedAttribute]
private void set_Server(string value);
    private static bool IsSymweb(string server);
    [NullableContextAttribute("0")]
public virtual string FindElfImage(string fileName, SymbolProperties archivedUnder, ImmutableArray`1<byte> buildId, bool checkProperties);
    [NullableContextAttribute("0")]
public virtual string FindMachOImage(string fileName, SymbolProperties archivedUnder, ImmutableArray`1<byte> uuid, bool checkProperties);
    public virtual string FindPEImage(string fileName, int buildTimeStamp, int imageSize, bool checkProperties);
    [NullableContextAttribute("0")]
public virtual string FindPEImage(string fileName, SymbolProperties archivedUnder, ImmutableArray`1<byte> buildIdOrUUID, OSPlatform originalPlatform, bool checkProperties);
    [AsyncStateMachineAttribute("Microsoft.Diagnostics.Runtime.Implementation.SymbolServer/<FindFileOnServer>d__17")]
private Task`1<Stream> FindFileOnServer(string key);
    [AsyncStateMachineAttribute("Microsoft.Diagnostics.Runtime.Implementation.SymbolServer/<GetAccessTokenAsync>d__18")]
private Task`1<string> GetAccessTokenAsync();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[DefaultMemberAttribute("Item")]
internal class Microsoft.Diagnostics.Runtime.Implementation.SyncBlockContainer : object {
    private SyncBlock[] _syncBlocks;
    private Dictionary`2<ulong, SyncBlock> _mapping;
    public int Count { get; }
    public SyncBlock Item { get; }
    public SyncBlock Item { get; }
    public SyncBlockContainer(IEnumerable`1<SyncBlockInfo> syncBlocks);
    public int get_Count();
    public SyncBlock get_Item(int index);
    public SyncBlock get_Item(UInt32 index);
    private SyncBlock CreateSyncBlock(SyncBlockInfo data);
    [NullableContextAttribute("2")]
public SyncBlock TryGetSyncBlock(ulong obj);
    public sealed virtual IEnumerator`1<SyncBlock> GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
}
[NullableContextAttribute("2")]
public interface Microsoft.Diagnostics.Runtime.Interfaces.IClrAppDomain {
    public ulong Address { get; }
    public string ApplicationBase { get; }
    public string ConfigurationFile { get; }
    public int Id { get; }
    public ulong LoaderAllocator { get; }
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ImmutableArray`1<IClrModule> Modules { get; }
    public string Name { get; }
    [NullableAttribute("1")]
public IClrRuntime Runtime { get; }
    public abstract virtual ulong get_Address();
    public abstract virtual string get_ApplicationBase();
    public abstract virtual string get_ConfigurationFile();
    public abstract virtual int get_Id();
    public abstract virtual ulong get_LoaderAllocator();
    public abstract virtual ImmutableArray`1<IClrModule> get_Modules();
    public abstract virtual string get_Name();
    [NullableContextAttribute("1")]
public abstract virtual IClrRuntime get_Runtime();
    [NullableContextAttribute("1")]
public abstract virtual IEnumerable`1<ClrNativeHeapInfo> EnumerateLoaderAllocatorHeaps();
}
[NullableContextAttribute("1")]
public interface Microsoft.Diagnostics.Runtime.Interfaces.IClrArray {
    public ulong Address { get; }
    public int Length { get; }
    public int Rank { get; }
    public IClrType Type { get; }
    public abstract virtual ulong get_Address();
    public abstract virtual int get_Length();
    public abstract virtual int get_Rank();
    public abstract virtual IClrType get_Type();
    [NullableContextAttribute("2")]
public abstract virtual bool Equals(object obj);
    public abstract virtual int GetLength(int dimension);
    public abstract virtual int GetLowerBound(int dimension);
    public abstract virtual IClrValue GetObjectValue(int index);
    public abstract virtual IClrValue GetObjectValue(Int32[] indices);
    public abstract virtual IClrValue GetStructValue(int index);
    public abstract virtual IClrValue GetStructValue(Int32[] indices);
    public abstract virtual int GetUpperBound(int dimension);
    [NullableContextAttribute("0")]
public abstract virtual T GetValue(int index);
    [NullableContextAttribute("0")]
public abstract virtual T GetValue(Int32[] indices);
    [NullableContextAttribute("0")]
public abstract virtual T[] ReadValues(int start, int count);
}
[NullableContextAttribute("1")]
public interface Microsoft.Diagnostics.Runtime.Interfaces.IClrDelegate {
    public bool HasMultipleTargets { get; }
    public IClrValue Object { get; }
    public abstract virtual bool get_HasMultipleTargets();
    public abstract virtual IClrValue get_Object();
    public abstract virtual IEnumerable`1<IClrDelegateTarget> EnumerateDelegateTargets();
    [NullableContextAttribute("2")]
public abstract virtual IClrDelegateTarget GetDelegateTarget();
}
[NullableContextAttribute("1")]
public interface Microsoft.Diagnostics.Runtime.Interfaces.IClrDelegateTarget {
    public IClrMethod Method { get; }
    public IClrDelegate Parent { get; }
    public IClrValue TargetObject { get; }
    public abstract virtual IClrMethod get_Method();
    public abstract virtual IClrDelegate get_Parent();
    public abstract virtual IClrValue get_TargetObject();
}
[NullableContextAttribute("1")]
public interface Microsoft.Diagnostics.Runtime.Interfaces.IClrEnum {
    public ClrElementType ElementType { get; }
    public IClrType Type { get; }
    public abstract virtual ClrElementType get_ElementType();
    public abstract virtual IClrType get_Type();
    public abstract virtual IEnumerable`1<ValueTuple`2<string, object>> EnumerateValues();
    public abstract virtual IEnumerable`1<string> GetEnumNames();
    [NullableContextAttribute("0")]
public abstract virtual T GetEnumValue(string name);
}
[NullableContextAttribute("2")]
public interface Microsoft.Diagnostics.Runtime.Interfaces.IClrException {
    public ulong Address { get; }
    public int HResult { get; }
    public IClrException Inner { get; }
    public string Message { get; }
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ImmutableArray`1<IClrStackFrame> StackTrace { get; }
    public IClrThread Thread { get; }
    [NullableAttribute("1")]
public IClrType Type { get; }
    public abstract virtual ulong get_Address();
    public abstract virtual int get_HResult();
    public abstract virtual IClrException get_Inner();
    public abstract virtual string get_Message();
    public abstract virtual ImmutableArray`1<IClrStackFrame> get_StackTrace();
    public abstract virtual IClrThread get_Thread();
    [NullableContextAttribute("1")]
public abstract virtual IClrType get_Type();
    [NullableContextAttribute("1")]
public abstract virtual IClrValue AsObject();
    [NullableContextAttribute("1")]
public abstract virtual string ToString();
}
[NullableContextAttribute("2")]
public interface Microsoft.Diagnostics.Runtime.Interfaces.IClrField {
    public FieldAttributes Attributes { get; }
    [NullableAttribute("1")]
public IClrType ContainingType { get; }
    public ClrElementType ElementType { get; }
    public bool IsObjectReference { get; }
    public bool IsPrimitive { get; }
    public bool IsValueType { get; }
    public string Name { get; }
    public int Offset { get; }
    public int Size { get; }
    public int Token { get; }
    public IClrType Type { get; }
    public abstract virtual FieldAttributes get_Attributes();
    [NullableContextAttribute("1")]
public abstract virtual IClrType get_ContainingType();
    public abstract virtual ClrElementType get_ElementType();
    public abstract virtual bool get_IsObjectReference();
    public abstract virtual bool get_IsPrimitive();
    public abstract virtual bool get_IsValueType();
    public abstract virtual string get_Name();
    public abstract virtual int get_Offset();
    public abstract virtual int get_Size();
    public abstract virtual int get_Token();
    public abstract virtual IClrType get_Type();
    public abstract virtual string ToString();
}
public interface Microsoft.Diagnostics.Runtime.Interfaces.IClrGenerationData {
    public ulong StartSegment { get; }
    public ulong AllocationStart { get; }
    public ulong AllocationContextPointer { get; }
    public ulong AllocationContextLimit { get; }
    public abstract virtual ulong get_StartSegment();
    public abstract virtual ulong get_AllocationStart();
    public abstract virtual ulong get_AllocationContextPointer();
    public abstract virtual ulong get_AllocationContextLimit();
}
[NullableContextAttribute("1")]
public interface Microsoft.Diagnostics.Runtime.Interfaces.IClrHandle {
    public IClrAppDomain AppDomain { get; }
    public IClrValue Dependent { get; }
    public ClrHandleKind HandleKind { get; }
    public bool IsStrong { get; }
    public UInt32 ReferenceCount { get; }
    public abstract virtual IClrAppDomain get_AppDomain();
    public abstract virtual IClrValue get_Dependent();
    public abstract virtual ClrHandleKind get_HandleKind();
    public abstract virtual bool get_IsStrong();
    public abstract virtual UInt32 get_ReferenceCount();
}
[NullableContextAttribute("1")]
public interface Microsoft.Diagnostics.Runtime.Interfaces.IClrHeap {
    public bool CanWalkHeap { get; }
    public IClrType ExceptionType { get; }
    public IClrType FreeType { get; }
    public bool IsServer { get; }
    public IClrType ObjectType { get; }
    public IClrRuntime Runtime { get; }
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ImmutableArray`1<IClrSegment> Segments { get; }
    public IClrType StringType { get; }
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ImmutableArray`1<IClrSubHeap> SubHeaps { get; }
    public abstract virtual bool get_CanWalkHeap();
    public abstract virtual IClrType get_ExceptionType();
    public abstract virtual IClrType get_FreeType();
    public abstract virtual bool get_IsServer();
    public abstract virtual IClrType get_ObjectType();
    public abstract virtual IClrRuntime get_Runtime();
    public abstract virtual ImmutableArray`1<IClrSegment> get_Segments();
    public abstract virtual IClrType get_StringType();
    public abstract virtual ImmutableArray`1<IClrSubHeap> get_SubHeaps();
    public abstract virtual IEnumerable`1<MemoryRange> EnumerateAllocationContexts();
    public abstract virtual IEnumerable`1<IClrValue> EnumerateFinalizableObjects();
    public abstract virtual IEnumerable`1<IClrRoot> EnumerateFinalizerRoots();
    public abstract virtual IEnumerable`1<IClrValue> EnumerateObjects();
    public abstract virtual IEnumerable`1<IClrValue> EnumerateObjects(bool carefully);
    public abstract virtual IEnumerable`1<IClrValue> EnumerateObjects(MemoryRange range, bool carefully);
    public abstract virtual IEnumerable`1<IClrRoot> EnumerateRoots();
    public abstract virtual IEnumerable`1<SyncBlock> EnumerateSyncBlocks();
    public abstract virtual IClrValue FindNextObjectOnSegment(ulong address, bool carefully);
    public abstract virtual IClrValue FindPreviousObjectOnSegment(ulong address, bool carefully);
    public abstract virtual IClrValue GetObject(ulong objRef);
    [NullableContextAttribute("2")]
public abstract virtual IClrType GetObjectType(ulong objRef);
    [NullableContextAttribute("2")]
public abstract virtual IClrSegment GetSegmentByAddress(ulong address);
    [NullableContextAttribute("2")]
public abstract virtual IClrType GetTypeByMethodTable(ulong methodTable);
    public abstract virtual IClrType GetTypeByName(IClrModule module, string name);
    public abstract virtual IClrType GetTypeByName(string name);
    [NullableContextAttribute("2")]
public abstract virtual bool IsObjectCorrupted(ulong objAddr, IObjectCorruption& result);
    public abstract virtual bool IsObjectCorrupted(IClrValue obj, IObjectCorruption& result);
    public abstract virtual IEnumerable`1<IObjectCorruption> VerifyHeap();
    public abstract virtual IEnumerable`1<IObjectCorruption> VerifyHeap(IEnumerable`1<IClrValue> objects);
}
[NullableContextAttribute("1")]
public interface Microsoft.Diagnostics.Runtime.Interfaces.IClrInfo {
    [NullableAttribute("0")]
public ImmutableArray`1<byte> BuildId { get; }
    public IDataTarget DataTarget { get; }
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ImmutableArray`1<DebugLibraryInfo> DebuggingLibraries { get; }
    public ClrFlavor Flavor { get; }
    public int IndexFileSize { get; }
    public int IndexTimeStamp { get; }
    public bool IsSingleFile { get; }
    public ModuleInfo ModuleInfo { get; }
    public Version Version { get; }
    [NullableContextAttribute("0")]
public abstract virtual ImmutableArray`1<byte> get_BuildId();
    public abstract virtual IDataTarget get_DataTarget();
    public abstract virtual ImmutableArray`1<DebugLibraryInfo> get_DebuggingLibraries();
    public abstract virtual ClrFlavor get_Flavor();
    public abstract virtual int get_IndexFileSize();
    public abstract virtual int get_IndexTimeStamp();
    public abstract virtual bool get_IsSingleFile();
    public abstract virtual ModuleInfo get_ModuleInfo();
    public abstract virtual Version get_Version();
    public abstract virtual IClrRuntime CreateRuntime();
    public abstract virtual IClrRuntime CreateRuntime(string dacPath);
    public abstract virtual IClrRuntime CreateRuntime(string dacPath, bool ignoreMismatch);
}
public interface Microsoft.Diagnostics.Runtime.Interfaces.IClrInstanceField {
    public abstract virtual ulong GetAddress(ulong objRef);
    public abstract virtual ulong GetAddress(ulong objRef, bool interior);
    public abstract virtual T Read(ulong objRef, bool interior);
    [NullableContextAttribute("1")]
public abstract virtual IClrValue ReadObject(ulong objRef, bool interior);
    [NullableContextAttribute("2")]
public abstract virtual string ReadString(ulong objRef, bool interior);
    [NullableContextAttribute("1")]
public abstract virtual IClrValue ReadStruct(ulong objRef, bool interior);
}
[NullableContextAttribute("1")]
public interface Microsoft.Diagnostics.Runtime.Interfaces.IClrJitManager {
    public ulong Address { get; }
    public CodeHeapKind Kind { get; }
    public IClrRuntime Runtime { get; }
    public abstract virtual ulong get_Address();
    public abstract virtual CodeHeapKind get_Kind();
    public abstract virtual IClrRuntime get_Runtime();
    public abstract virtual IEnumerable`1<ClrNativeHeapInfo> EnumerateNativeHeaps();
}
[NullableContextAttribute("2")]
public interface Microsoft.Diagnostics.Runtime.Interfaces.IClrMethod {
    public MethodAttributes Attributes { get; }
    public MethodCompilationType CompilationType { get; }
    public HotColdRegions HotColdInfo { get; }
    [NullableAttribute("0")]
public ImmutableArray`1<ILToNativeMap> ILOffsetMap { get; }
    public bool IsClassConstructor { get; }
    public bool IsConstructor { get; }
    public int MetadataToken { get; }
    public ulong MethodDesc { get; }
    public string Name { get; }
    public ulong NativeCode { get; }
    public string Signature { get; }
    [NullableAttribute("1")]
public IClrType Type { get; }
    public abstract virtual MethodAttributes get_Attributes();
    public abstract virtual MethodCompilationType get_CompilationType();
    public abstract virtual HotColdRegions get_HotColdInfo();
    [NullableContextAttribute("0")]
public abstract virtual ImmutableArray`1<ILToNativeMap> get_ILOffsetMap();
    public abstract virtual bool get_IsClassConstructor();
    public abstract virtual bool get_IsConstructor();
    public abstract virtual int get_MetadataToken();
    public abstract virtual ulong get_MethodDesc();
    public abstract virtual string get_Name();
    public abstract virtual ulong get_NativeCode();
    public abstract virtual string get_Signature();
    [NullableContextAttribute("1")]
public abstract virtual IClrType get_Type();
    public abstract virtual ILInfo GetILInfo();
    public abstract virtual int GetILOffset(ulong addr);
}
[NullableContextAttribute("2")]
public interface Microsoft.Diagnostics.Runtime.Interfaces.IClrModule {
    public ulong Address { get; }
    [NullableAttribute("1")]
public IClrAppDomain AppDomain { get; }
    public ulong AssemblyAddress { get; }
    public string AssemblyName { get; }
    public DebuggingModes DebuggingMode { get; }
    public ulong ImageBase { get; }
    public bool IsDynamic { get; }
    public bool IsPEFile { get; }
    public ModuleLayout Layout { get; }
    public ulong LoaderAllocator { get; }
    public ulong MetadataAddress { get; }
    public ulong MetadataLength { get; }
    public string Name { get; }
    public PdbInfo Pdb { get; }
    public ulong Size { get; }
    public ulong ThunkHeap { get; }
    public abstract virtual ulong get_Address();
    [NullableContextAttribute("1")]
public abstract virtual IClrAppDomain get_AppDomain();
    public abstract virtual ulong get_AssemblyAddress();
    public abstract virtual string get_AssemblyName();
    public abstract virtual DebuggingModes get_DebuggingMode();
    public abstract virtual ulong get_ImageBase();
    public abstract virtual bool get_IsDynamic();
    public abstract virtual bool get_IsPEFile();
    public abstract virtual ModuleLayout get_Layout();
    public abstract virtual ulong get_LoaderAllocator();
    public abstract virtual ulong get_MetadataAddress();
    public abstract virtual ulong get_MetadataLength();
    public abstract virtual string get_Name();
    public abstract virtual PdbInfo get_Pdb();
    public abstract virtual ulong get_Size();
    public abstract virtual ulong get_ThunkHeap();
    [NullableContextAttribute("1")]
public abstract virtual IEnumerable`1<ClrNativeHeapInfo> EnumerateLoaderAllocatorHeaps();
    [NullableContextAttribute("1")]
public abstract virtual IEnumerable`1<ClrNativeHeapInfo> EnumerateThunkHeap();
    public abstract virtual IEnumerable`1<ValueTuple`2<ulong, int>> EnumerateTypeDefToMethodTableMap();
    public abstract virtual IEnumerable`1<ValueTuple`2<ulong, int>> EnumerateTypeRefToMethodTableMap();
    [NullableContextAttribute("1")]
public abstract virtual IClrType GetTypeByName(string name);
}
public interface Microsoft.Diagnostics.Runtime.Interfaces.IClrOutOfMemoryInfo {
    public OutOfMemoryReason Reason { get; }
    public GetMemoryFailureReason GetMemoryFailure { get; }
    public bool IsLargeObjectHeap { get; }
    public ulong AllocSize { get; }
    public ulong AvailablePageFileMB { get; }
    public ulong GCIndex { get; }
    public ulong Size { get; }
    public abstract virtual OutOfMemoryReason get_Reason();
    public abstract virtual GetMemoryFailureReason get_GetMemoryFailure();
    public abstract virtual bool get_IsLargeObjectHeap();
    public abstract virtual ulong get_AllocSize();
    public abstract virtual ulong get_AvailablePageFileMB();
    public abstract virtual ulong get_GCIndex();
    public abstract virtual ulong get_Size();
}
[NullableContextAttribute("2")]
public interface Microsoft.Diagnostics.Runtime.Interfaces.IClrReference {
    public IClrInstanceField Field { get; }
    public IClrReference InnerField { get; }
    public bool IsArrayElement { get; }
    public bool IsDependentHandle { get; }
    public bool IsField { get; }
    [NullableAttribute("1")]
public IClrValue Object { get; }
    public int Offset { get; }
    public abstract virtual IClrInstanceField get_Field();
    public abstract virtual IClrReference get_InnerField();
    public abstract virtual bool get_IsArrayElement();
    public abstract virtual bool get_IsDependentHandle();
    public abstract virtual bool get_IsField();
    [NullableContextAttribute("1")]
public abstract virtual IClrValue get_Object();
    public abstract virtual int get_Offset();
}
[NullableContextAttribute("2")]
public interface Microsoft.Diagnostics.Runtime.Interfaces.IClrRoot {
    public ulong Address { get; }
    public bool IsInterior { get; }
    public bool IsPinned { get; }
    [NullableAttribute("1")]
public IClrValue Object { get; }
    public ClrRootKind RootKind { get; }
    public IClrStackFrame StackFrame { get; }
    public string RegisterName { get; }
    public int RegisterOffset { get; }
    public abstract virtual ulong get_Address();
    public abstract virtual bool get_IsInterior();
    public abstract virtual bool get_IsPinned();
    [NullableContextAttribute("1")]
public abstract virtual IClrValue get_Object();
    public abstract virtual ClrRootKind get_RootKind();
    public abstract virtual IClrStackFrame get_StackFrame();
    public abstract virtual string get_RegisterName();
    public abstract virtual int get_RegisterOffset();
}
[NullableContextAttribute("1")]
public interface Microsoft.Diagnostics.Runtime.Interfaces.IClrRuntime {
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ImmutableArray`1<IClrAppDomain> AppDomains { get; }
    public IClrModule BaseClassLibrary { get; }
    public IClrInfo ClrInfo { get; }
    public IDataTarget DataTarget { get; }
    public IClrHeap Heap { get; }
    public bool IsThreadSafe { get; }
    [NullableAttribute("2")]
public IClrAppDomain SharedDomain { get; }
    [NullableAttribute("2")]
public IClrAppDomain SystemDomain { get; }
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ImmutableArray`1<IClrThread> Threads { get; }
    [NullableAttribute("2")]
public IClrThreadPool ThreadPool { get; }
    public abstract virtual ImmutableArray`1<IClrAppDomain> get_AppDomains();
    public abstract virtual IClrModule get_BaseClassLibrary();
    public abstract virtual IClrInfo get_ClrInfo();
    public abstract virtual IDataTarget get_DataTarget();
    public abstract virtual IClrHeap get_Heap();
    public abstract virtual bool get_IsThreadSafe();
    [NullableContextAttribute("2")]
public abstract virtual IClrAppDomain get_SharedDomain();
    [NullableContextAttribute("2")]
public abstract virtual IClrAppDomain get_SystemDomain();
    public abstract virtual ImmutableArray`1<IClrThread> get_Threads();
    public abstract virtual IEnumerable`1<ClrNativeHeapInfo> EnumerateClrNativeHeaps();
    public abstract virtual IEnumerable`1<IClrRoot> EnumerateHandles();
    public abstract virtual IEnumerable`1<IClrJitManager> EnumerateJitManagers();
    public abstract virtual IEnumerable`1<IClrModule> EnumerateModules();
    public abstract virtual void FlushCachedData();
    [NullableContextAttribute("2")]
public abstract virtual string GetJitHelperFunctionName(ulong address);
    [NullableContextAttribute("2")]
public abstract virtual IClrMethod GetMethodByHandle(ulong methodHandle);
    [NullableContextAttribute("2")]
public abstract virtual IClrMethod GetMethodByInstructionPointer(ulong ip);
    [NullableContextAttribute("2")]
public abstract virtual IClrType GetTypeByMethodTable(ulong methodTable);
    public abstract virtual IEnumerable`1<ClrSyncBlockCleanupData> EnumerateSyncBlockCleanupData();
    public abstract virtual IEnumerable`1<ClrRcwCleanupData> EnumerateRcwCleanupData();
    [NullableContextAttribute("2")]
public abstract virtual IClrThreadPool get_ThreadPool();
}
[NullableContextAttribute("1")]
public interface Microsoft.Diagnostics.Runtime.Interfaces.IClrSegment {
    public ulong Address { get; }
    public MemoryRange CommittedMemory { get; }
    public ulong End { get; }
    public ulong FirstObjectAddress { get; }
    public MemoryRange Generation0 { get; }
    public MemoryRange Generation1 { get; }
    public MemoryRange Generation2 { get; }
    public bool IsPinned { get; }
    public GCSegmentKind Kind { get; }
    public ClrSegmentFlags Flags { get; }
    public ulong Length { get; }
    public MemoryRange ObjectRange { get; }
    public MemoryRange ReservedMemory { get; }
    public ulong Start { get; }
    public IClrSubHeap SubHeap { get; }
    public abstract virtual ulong get_Address();
    public abstract virtual MemoryRange get_CommittedMemory();
    public abstract virtual ulong get_End();
    public abstract virtual ulong get_FirstObjectAddress();
    public abstract virtual MemoryRange get_Generation0();
    public abstract virtual MemoryRange get_Generation1();
    public abstract virtual MemoryRange get_Generation2();
    public abstract virtual bool get_IsPinned();
    public abstract virtual GCSegmentKind get_Kind();
    public abstract virtual ClrSegmentFlags get_Flags();
    public abstract virtual ulong get_Length();
    public abstract virtual MemoryRange get_ObjectRange();
    public abstract virtual MemoryRange get_ReservedMemory();
    public abstract virtual ulong get_Start();
    public abstract virtual IClrSubHeap get_SubHeap();
    public abstract virtual IEnumerable`1<IClrValue> EnumerateObjects(bool carefully);
    public abstract virtual IEnumerable`1<IClrValue> EnumerateObjects(MemoryRange range, bool carefully);
    public abstract virtual Generation GetGeneration(ulong obj);
}
[NullableContextAttribute("2")]
public interface Microsoft.Diagnostics.Runtime.Interfaces.IClrStackFrame {
    [NullableAttribute("0")]
public ReadOnlySpan`1<byte> Context { get; }
    public string FrameName { get; }
    public ulong InstructionPointer { get; }
    public ClrStackFrameKind Kind { get; }
    public IClrMethod Method { get; }
    public ulong StackPointer { get; }
    public IClrThread Thread { get; }
    [NullableContextAttribute("0")]
public abstract virtual ReadOnlySpan`1<byte> get_Context();
    public abstract virtual string get_FrameName();
    public abstract virtual ulong get_InstructionPointer();
    public abstract virtual ClrStackFrameKind get_Kind();
    public abstract virtual IClrMethod get_Method();
    public abstract virtual ulong get_StackPointer();
    public abstract virtual IClrThread get_Thread();
}
[NullableContextAttribute("1")]
public interface Microsoft.Diagnostics.Runtime.Interfaces.IClrStaticField {
    public abstract virtual ulong GetAddress(IClrAppDomain appDomain);
    public abstract virtual bool IsInitialized(IClrAppDomain appDomain);
    [NullableContextAttribute("0")]
public abstract virtual T Read(IClrAppDomain appDomain);
    public abstract virtual IClrValue ReadObject(IClrAppDomain appDomain);
    public abstract virtual string ReadString(IClrAppDomain appDomain);
    public abstract virtual IClrValue ReadStruct(IClrAppDomain appDomain);
}
public interface Microsoft.Diagnostics.Runtime.Interfaces.IClrSubHeap {
    public ulong Address { get; }
    public ulong Allocated { get; }
    public ulong MarkArray { get; }
    public MemoryRange AllocationContext { get; }
    public bool HasBackgroundGC { get; }
    public bool HasPinnedObjectHeap { get; }
    public bool HasRegions { get; }
    [NullableAttribute("1")]
public IClrHeap Heap { get; }
    public int Index { get; }
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ImmutableArray`1<IClrSegment> Segments { get; }
    public MemoryRange FinalizerQueueRoots { get; }
    public MemoryRange FinalizerQueueObjects { get; }
    public ulong SavedSweepEphemeralSegment { get; }
    public ulong SavedSweepEphemeralStart { get; }
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ImmutableArray`1<IClrGenerationData> GenerationTable { get; }
    public ulong EphemeralHeapSegment { get; }
    public ulong LowestAddress { get; }
    public ulong HighestAddress { get; }
    public ulong CardTable { get; }
    [NullableAttribute("2")]
public IClrOutOfMemoryInfo OomInfo { get; }
    public MemoryRange InternalRootArray { get; }
    public ImmutableArray`1<MemoryRange> GenerationalFinalizableObjects { get; }
    public abstract virtual ulong get_Address();
    public abstract virtual ulong get_Allocated();
    public abstract virtual ulong get_MarkArray();
    public abstract virtual MemoryRange get_AllocationContext();
    public abstract virtual bool get_HasBackgroundGC();
    public abstract virtual bool get_HasPinnedObjectHeap();
    public abstract virtual bool get_HasRegions();
    [NullableContextAttribute("1")]
public abstract virtual IClrHeap get_Heap();
    public abstract virtual int get_Index();
    public abstract virtual ImmutableArray`1<IClrSegment> get_Segments();
    public abstract virtual MemoryRange get_FinalizerQueueRoots();
    public abstract virtual MemoryRange get_FinalizerQueueObjects();
    public abstract virtual ulong get_SavedSweepEphemeralSegment();
    public abstract virtual ulong get_SavedSweepEphemeralStart();
    public abstract virtual ImmutableArray`1<IClrGenerationData> get_GenerationTable();
    public abstract virtual ulong get_EphemeralHeapSegment();
    public abstract virtual ulong get_LowestAddress();
    public abstract virtual ulong get_HighestAddress();
    public abstract virtual ulong get_CardTable();
    [NullableContextAttribute("2")]
public abstract virtual IClrOutOfMemoryInfo get_OomInfo();
    public abstract virtual MemoryRange get_InternalRootArray();
    public abstract virtual ImmutableArray`1<MemoryRange> get_GenerationalFinalizableObjects();
}
[NullableContextAttribute("1")]
public interface Microsoft.Diagnostics.Runtime.Interfaces.IClrThread {
    public ulong Address { get; }
    [NullableAttribute("2")]
public IClrAppDomain CurrentAppDomain { get; }
    [NullableAttribute("2")]
public IClrException CurrentException { get; }
    public GCMode GCMode { get; }
    public bool IsAlive { get; }
    public UInt32 LockCount { get; }
    public int ManagedThreadId { get; }
    public UInt32 OSThreadId { get; }
    public IClrRuntime Runtime { get; }
    public ulong StackBase { get; }
    public ulong StackLimit { get; }
    public ClrThreadState State { get; }
    public bool IsFinalizer { get; }
    public bool IsGc { get; }
    public abstract virtual ulong get_Address();
    [NullableContextAttribute("2")]
public abstract virtual IClrAppDomain get_CurrentAppDomain();
    [NullableContextAttribute("2")]
public abstract virtual IClrException get_CurrentException();
    public abstract virtual GCMode get_GCMode();
    public abstract virtual bool get_IsAlive();
    public abstract virtual UInt32 get_LockCount();
    public abstract virtual int get_ManagedThreadId();
    public abstract virtual UInt32 get_OSThreadId();
    public abstract virtual IClrRuntime get_Runtime();
    public abstract virtual ulong get_StackBase();
    public abstract virtual ulong get_StackLimit();
    public abstract virtual ClrThreadState get_State();
    public abstract virtual bool get_IsFinalizer();
    public abstract virtual bool get_IsGc();
    public abstract virtual IEnumerable`1<IClrRoot> EnumerateStackRoots();
    public abstract virtual IEnumerable`1<IClrStackFrame> EnumerateStackTrace(bool includeContext);
}
[NullableContextAttribute("1")]
public interface Microsoft.Diagnostics.Runtime.Interfaces.IClrThreadPool {
    public bool UsingPortableThreadPool { get; }
    public bool UsingWindowsThreadPool { get; }
    public int CpuUtilization { get; }
    public int MinThreads { get; }
    public int MaxThreads { get; }
    public int IdleWorkerThreads { get; }
    public int ActiveWorkerThreads { get; }
    public int WindowsThreadPoolThreadCount { get; }
    public int TotalCompletionPorts { get; }
    public int FreeCompletionPorts { get; }
    public int MaxFreeCompletionPorts { get; }
    public int CompletionPortCurrentLimit { get; }
    public int MinCompletionPorts { get; }
    public int MaxCompletionPorts { get; }
    public bool HasLegacyData { get; }
    public int RetiredWorkerThreads { get; }
    public abstract virtual bool get_UsingPortableThreadPool();
    public abstract virtual bool get_UsingWindowsThreadPool();
    public abstract virtual int get_CpuUtilization();
    public abstract virtual int get_MinThreads();
    public abstract virtual int get_MaxThreads();
    public abstract virtual int get_IdleWorkerThreads();
    public abstract virtual int get_ActiveWorkerThreads();
    public abstract virtual int get_WindowsThreadPoolThreadCount();
    public abstract virtual int get_TotalCompletionPorts();
    public abstract virtual int get_FreeCompletionPorts();
    public abstract virtual int get_MaxFreeCompletionPorts();
    public abstract virtual int get_CompletionPortCurrentLimit();
    public abstract virtual int get_MinCompletionPorts();
    public abstract virtual int get_MaxCompletionPorts();
    public abstract virtual bool get_HasLegacyData();
    public abstract virtual int get_RetiredWorkerThreads();
    public abstract virtual IEnumerable`1<LegacyThreadPoolWorkRequest> EnumerateLegacyWorkRequests();
    public abstract virtual IEnumerable`1<HillClimbingLogEntry> EnumerateHillClimbingLog();
}
[NullableContextAttribute("1")]
public interface Microsoft.Diagnostics.Runtime.Interfaces.IClrType {
    public ulong AssemblyLoadContextAddress { get; }
    [NullableAttribute("2")]
public IClrType BaseType { get; }
    public int ComponentSize { get; }
    [NullableAttribute("2")]
public IClrType ComponentType { get; }
    public bool ContainsPointers { get; }
    public ClrElementType ElementType { get; }
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ImmutableArray`1<IClrInstanceField> Fields { get; }
    public GCDesc GCDesc { get; }
    public IClrHeap Heap { get; }
    public bool IsArray { get; }
    public bool IsCollectible { get; }
    public bool IsEnum { get; }
    public bool IsException { get; }
    public bool IsFinalizable { get; }
    public bool IsFree { get; }
    public bool IsObjectReference { get; }
    public bool IsPointer { get; }
    public bool IsPrimitive { get; }
    public bool IsShared { get; }
    public bool IsString { get; }
    public bool IsValueType { get; }
    public ulong LoaderAllocatorHandle { get; }
    public int MetadataToken { get; }
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ImmutableArray`1<IClrMethod> Methods { get; }
    public ulong MethodTable { get; }
    public IClrModule Module { get; }
    [NullableAttribute("2")]
public string Name { get; }
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ImmutableArray`1<IClrStaticField> StaticFields { get; }
    public int StaticSize { get; }
    public TypeAttributes TypeAttributes { get; }
    public abstract virtual ulong get_AssemblyLoadContextAddress();
    [NullableContextAttribute("2")]
public abstract virtual IClrType get_BaseType();
    public abstract virtual int get_ComponentSize();
    [NullableContextAttribute("2")]
public abstract virtual IClrType get_ComponentType();
    public abstract virtual bool get_ContainsPointers();
    public abstract virtual ClrElementType get_ElementType();
    public abstract virtual ImmutableArray`1<IClrInstanceField> get_Fields();
    public abstract virtual GCDesc get_GCDesc();
    public abstract virtual IClrHeap get_Heap();
    public abstract virtual bool get_IsArray();
    public abstract virtual bool get_IsCollectible();
    public abstract virtual bool get_IsEnum();
    public abstract virtual bool get_IsException();
    public abstract virtual bool get_IsFinalizable();
    public abstract virtual bool get_IsFree();
    public abstract virtual bool get_IsObjectReference();
    public abstract virtual bool get_IsPointer();
    public abstract virtual bool get_IsPrimitive();
    public abstract virtual bool get_IsShared();
    public abstract virtual bool get_IsString();
    public abstract virtual bool get_IsValueType();
    public abstract virtual ulong get_LoaderAllocatorHandle();
    public abstract virtual int get_MetadataToken();
    public abstract virtual ImmutableArray`1<IClrMethod> get_Methods();
    public abstract virtual ulong get_MethodTable();
    public abstract virtual IClrModule get_Module();
    [NullableContextAttribute("2")]
public abstract virtual string get_Name();
    public abstract virtual ImmutableArray`1<IClrStaticField> get_StaticFields();
    public abstract virtual int get_StaticSize();
    public abstract virtual TypeAttributes get_TypeAttributes();
    public abstract virtual IClrEnum AsEnum();
    public abstract virtual IEnumerable`1<ClrGenericParameter> EnumerateGenericParameters();
    public abstract virtual IEnumerable`1<ClrInterface> EnumerateInterfaces();
    public abstract virtual ulong GetArrayElementAddress(ulong objRef, int index);
    public abstract virtual IClrInstanceField GetFieldByName(string name);
    public abstract virtual int GetHashCode();
    public abstract virtual IClrStaticField GetStaticFieldByName(string name);
    public abstract virtual bool IsFinalizeSuppressed(ulong obj);
    [NullableContextAttribute("0")]
public abstract virtual T[] ReadArrayElements(ulong objRef, int start, int count);
}
[NullableContextAttribute("1")]
public interface Microsoft.Diagnostics.Runtime.Interfaces.IClrValue {
    public ulong Address { get; }
    public bool ContainsPointers { get; }
    public bool HasComCallableWrapper { get; }
    public bool HasRuntimeCallableWrapper { get; }
    public bool IsArray { get; }
    public bool IsBoxedValue { get; }
    public bool IsComClassFactory { get; }
    public bool IsDelegate { get; }
    public bool IsException { get; }
    public bool IsFree { get; }
    public bool IsNull { get; }
    public bool IsRuntimeType { get; }
    public bool IsValid { get; }
    public ulong Size { get; }
    [NullableAttribute("2")]
public SyncBlock SyncBlock { get; }
    [NullableAttribute("2")]
public IClrType Type { get; }
    public abstract virtual ulong get_Address();
    public abstract virtual bool get_ContainsPointers();
    public abstract virtual bool get_HasComCallableWrapper();
    public abstract virtual bool get_HasRuntimeCallableWrapper();
    public abstract virtual bool get_IsArray();
    public abstract virtual bool get_IsBoxedValue();
    public abstract virtual bool get_IsComClassFactory();
    public abstract virtual bool get_IsDelegate();
    public abstract virtual bool get_IsException();
    public abstract virtual bool get_IsFree();
    public abstract virtual bool get_IsNull();
    public abstract virtual bool get_IsRuntimeType();
    public abstract virtual bool get_IsValid();
    public abstract virtual ulong get_Size();
    [NullableContextAttribute("2")]
public abstract virtual SyncBlock get_SyncBlock();
    [NullableContextAttribute("2")]
public abstract virtual IClrType get_Type();
    public abstract virtual IClrArray AsArray();
    public abstract virtual IClrDelegate AsDelegate();
    [NullableContextAttribute("2")]
public abstract virtual IClrException AsException();
    [NullableContextAttribute("2")]
public abstract virtual IClrType AsRuntimeType();
    [NullableContextAttribute("2")]
public abstract virtual string AsString(int maxLength);
    public abstract virtual IEnumerable`1<ulong> EnumerateReferenceAddresses(bool carefully, bool considerDependantHandles);
    public abstract virtual IEnumerable`1<IClrValue> EnumerateReferences(bool carefully, bool considerDependantHandles);
    public abstract virtual IEnumerable`1<IClrReference> EnumerateReferencesWithFields(bool carefully, bool considerDependantHandles);
    [NullableContextAttribute("2")]
public abstract virtual IComCallableWrapper GetComCallableWrapper();
    [NullableContextAttribute("2")]
public abstract virtual IRuntimeCallableWrapper GetRuntimeCallableWrapper();
    [NullableContextAttribute("0")]
public abstract virtual T ReadBoxedValue();
    [NullableContextAttribute("0")]
public abstract virtual T ReadField(string fieldName);
    public abstract virtual IClrValue ReadObjectField(string fieldName);
    public abstract virtual string ReadStringField(string fieldName, int maxLength);
    public abstract virtual IClrValue ReadValueTypeField(string fieldName);
    public abstract virtual bool TryReadStringField(string fieldName, Nullable`1<int> maxLength, String& result);
    [NullableContextAttribute("0")]
public abstract virtual bool TryReadField(string fieldName, T& result);
    public abstract virtual bool TryReadObjectField(string fieldName, IClrValue& result);
    public abstract virtual bool TryReadValueTypeField(string fieldName, IClrValue& result);
}
public interface Microsoft.Diagnostics.Runtime.Interfaces.IComCallableWrapper {
    public ulong Address { get; }
    public ulong Handle { get; }
    public ImmutableArray`1<ComInterfaceData> Interfaces { get; }
    public ulong IUnknown { get; }
    public ulong Object { get; }
    public int RefCount { get; }
    public abstract virtual ulong get_Address();
    public abstract virtual ulong get_Handle();
    public abstract virtual ImmutableArray`1<ComInterfaceData> get_Interfaces();
    public abstract virtual ulong get_IUnknown();
    public abstract virtual ulong get_Object();
    public abstract virtual int get_RefCount();
}
[NullableContextAttribute("1")]
public interface Microsoft.Diagnostics.Runtime.Interfaces.IDataTarget {
    public CacheOptions CacheOptions { get; }
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ImmutableArray`1<IClrInfo> ClrVersions { get; }
    public IDataReader DataReader { get; }
    [NullableAttribute("2")]
public IFileLocator FileLocator { get; public set; }
    public abstract virtual CacheOptions get_CacheOptions();
    public abstract virtual ImmutableArray`1<IClrInfo> get_ClrVersions();
    public abstract virtual IDataReader get_DataReader();
    [NullableContextAttribute("2")]
public abstract virtual IFileLocator get_FileLocator();
    [NullableContextAttribute("2")]
public abstract virtual void set_FileLocator(IFileLocator value);
    public abstract virtual IEnumerable`1<ModuleInfo> EnumerateModules();
    public abstract virtual void SetSymbolPath(string symbolPath);
}
[NullableContextAttribute("1")]
public interface Microsoft.Diagnostics.Runtime.Interfaces.IObjectCorruption {
    public IClrValue Object { get; }
    public int Offset { get; }
    public ObjectCorruptionKind Kind { get; }
    public int SyncBlockIndex { get; }
    public abstract virtual IClrValue get_Object();
    public abstract virtual int get_Offset();
    public abstract virtual ObjectCorruptionKind get_Kind();
    public abstract virtual int get_SyncBlockIndex();
}
internal interface Microsoft.Diagnostics.Runtime.IRegion {
    public ulong BeginAddress { get; }
    public ulong EndAddress { get; }
    public bool IsReadable { get; }
    public abstract virtual ulong get_BeginAddress();
    public abstract virtual ulong get_EndAddress();
    public abstract virtual bool get_IsReadable();
}
public interface Microsoft.Diagnostics.Runtime.IResourceNode {
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ImmutableArray`1<IResourceNode> Children { get; }
    [NullableAttribute("2")]
public string Name { get; }
    public int Size { get; }
    public abstract virtual ImmutableArray`1<IResourceNode> get_Children();
    [NullableContextAttribute("2")]
public abstract virtual string get_Name();
    public abstract virtual int get_Size();
    public abstract virtual int Read(Span`1<byte> buffer, int offset);
    public abstract virtual T Read(int offset);
    [NullableContextAttribute("1")]
public abstract virtual IResourceNode GetChild(string name);
}
public interface Microsoft.Diagnostics.Runtime.IRuntimeCallableWrapper {
    public ulong Address { get; }
    public ulong CreatorThreadAddress { get; }
    public ImmutableArray`1<ComInterfaceData> Interfaces { get; }
    public bool IsDisconnected { get; }
    public ulong IUnknown { get; }
    public ulong Object { get; }
    public int RefCount { get; }
    public ulong VTablePointer { get; }
    public ulong WinRTObject { get; }
    public abstract virtual ulong get_Address();
    public abstract virtual ulong get_CreatorThreadAddress();
    public abstract virtual ImmutableArray`1<ComInterfaceData> get_Interfaces();
    public abstract virtual bool get_IsDisconnected();
    public abstract virtual ulong get_IUnknown();
    public abstract virtual ulong get_Object();
    public abstract virtual int get_RefCount();
    public abstract virtual ulong get_VTablePointer();
    public abstract virtual ulong get_WinRTObject();
}
public class Microsoft.Diagnostics.Runtime.LegacyThreadPoolWorkRequest : ValueType {
    [CompilerGeneratedAttribute]
private bool <IsAsyncTimerCallback>k__BackingField;
    [CompilerGeneratedAttribute]
private ulong <Context>k__BackingField;
    [CompilerGeneratedAttribute]
private ulong <Function>k__BackingField;
    public bool IsAsyncTimerCallback { get; internal set; }
    public ulong Context { get; internal set; }
    public ulong Function { get; internal set; }
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public bool get_IsAsyncTimerCallback();
    [CompilerGeneratedAttribute]
internal void set_IsAsyncTimerCallback(bool value);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public ulong get_Context();
    [CompilerGeneratedAttribute]
internal void set_Context(ulong value);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public ulong get_Function();
    [CompilerGeneratedAttribute]
internal void set_Function(ulong value);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.Diagnostics.Runtime.LinuxFunctions : CoreFunctions {
    private Func`3<string, int, IntPtr> _dlopen;
    private Func`1<IntPtr> _dlerror;
    private Func`2<IntPtr, int> _dlclose;
    private Func`3<IntPtr, string, IntPtr> _dlsym;
    internal virtual bool GetFileVersion(string dll, Int32& major, Int32& minor, Int32& revision, Int32& patch);
    public virtual bool TryGetWow64(IntPtr proc, Boolean& result);
    public virtual IntPtr LoadLibrary(string libraryPath);
    public virtual bool FreeLibrary(IntPtr handle);
    public virtual IntPtr GetLibraryExport(IntPtr handle, string name);
    public static int symlink(string file, string symlink);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.Diagnostics.Runtime.LinuxSnapshotTarget : CustomDataTarget {
    private int _pid;
    private string _filename;
    public LinuxSnapshotTarget(IDataReader reader, int pid, string filename, TokenCredential credential);
    protected virtual void Dispose(bool disposing);
    public virtual string ToString();
    public static LinuxSnapshotTarget CreateSnapshotFromProcess(int pid);
}
public class Microsoft.Diagnostics.Runtime.LoongArch64Context : ValueType {
    public static UInt32 Context;
    public static UInt32 ContextControl;
    public static UInt32 ContextInteger;
    public static UInt32 ContextFloatingPoint;
    public static UInt32 ContextDebugRegisters;
    public UInt32 ContextFlags;
    [RegisterAttribute("1")]
public ulong R0;
    [RegisterAttribute("1")]
public ulong Ra;
    [RegisterAttribute("2")]
public ulong Tp;
    [RegisterAttribute("33")]
public ulong Sp;
    [RegisterAttribute("1")]
public ulong A0;
    [RegisterAttribute("1")]
public ulong A1;
    [RegisterAttribute("1")]
public ulong A2;
    [RegisterAttribute("1")]
public ulong A3;
    [RegisterAttribute("2")]
public ulong A4;
    [RegisterAttribute("1")]
public ulong A5;
    [RegisterAttribute("1")]
public ulong A6;
    [RegisterAttribute("1")]
public ulong A7;
    [RegisterAttribute("1")]
public ulong T0;
    [RegisterAttribute("1")]
public ulong T1;
    [RegisterAttribute("1")]
public ulong T2;
    [RegisterAttribute("1")]
public ulong T3;
    [RegisterAttribute("1")]
public ulong T4;
    [RegisterAttribute("1")]
public ulong T5;
    [RegisterAttribute("1")]
public ulong T6;
    [RegisterAttribute("1")]
public ulong T7;
    [RegisterAttribute("1")]
public ulong T8;
    [RegisterAttribute("1")]
public ulong X0;
    [RegisterAttribute("65")]
public ulong Fp;
    [RegisterAttribute("1")]
public ulong S0;
    [RegisterAttribute("1")]
public ulong S1;
    [RegisterAttribute("1")]
public ulong S2;
    [RegisterAttribute("1")]
public ulong S3;
    [RegisterAttribute("1")]
public ulong S4;
    [RegisterAttribute("1")]
public ulong S5;
    [RegisterAttribute("1")]
public ulong S6;
    [RegisterAttribute("1")]
public ulong S7;
    [RegisterAttribute("1")]
public ulong S8;
    [RegisterAttribute("18")]
public ulong Pc;
    [FixedBufferAttribute("System.UInt64", "128")]
[RegisterAttribute("4")]
public <F>e__FixedBuffer F;
    [RegisterAttribute("4")]
public ulong Fcc;
    [RegisterAttribute("4")]
public UInt32 Fcsr;
    public static int Size { get; }
    public static int get_Size();
}
public class Microsoft.Diagnostics.Runtime.M128A : ValueType {
    public ulong Low;
    public ulong High;
    public void Clear();
    public static bool op_Equality(M128A left, M128A right);
    public static bool op_Inequality(M128A left, M128A right);
    [NullableContextAttribute("2")]
public virtual bool Equals(object obj);
    public sealed virtual bool Equals(M128A other);
    public virtual int GetHashCode();
}
[IsReadOnlyAttribute]
internal class Microsoft.Diagnostics.Runtime.MacOS.MachHeader64 : ValueType {
    public static UInt32 Magic64;
    [CompilerGeneratedAttribute]
private UInt32 <Magic>k__BackingField;
    [CompilerGeneratedAttribute]
private MachOCpuType <CpuType>k__BackingField;
    [CompilerGeneratedAttribute]
private int <MachOCpuSubType>k__BackingField;
    [CompilerGeneratedAttribute]
private MachOFileType <FileType>k__BackingField;
    [CompilerGeneratedAttribute]
private UInt32 <NumberCommands>k__BackingField;
    [CompilerGeneratedAttribute]
private UInt32 <SizeOfCommands>k__BackingField;
    [CompilerGeneratedAttribute]
private MachOFlags <Flags>k__BackingField;
    [CompilerGeneratedAttribute]
private UInt32 <Reserved>k__BackingField;
    public static UInt32 Size { get; }
    public UInt32 Magic { get; }
    public MachOCpuType CpuType { get; }
    public int MachOCpuSubType { get; }
    public MachOFileType FileType { get; }
    public UInt32 NumberCommands { get; }
    public UInt32 SizeOfCommands { get; }
    public MachOFlags Flags { get; }
    public UInt32 Reserved { get; }
    public static UInt32 get_Size();
    [CompilerGeneratedAttribute]
public UInt32 get_Magic();
    [CompilerGeneratedAttribute]
public MachOCpuType get_CpuType();
    [CompilerGeneratedAttribute]
public int get_MachOCpuSubType();
    [CompilerGeneratedAttribute]
public MachOFileType get_FileType();
    [CompilerGeneratedAttribute]
public UInt32 get_NumberCommands();
    [CompilerGeneratedAttribute]
public UInt32 get_SizeOfCommands();
    [CompilerGeneratedAttribute]
public MachOFlags get_Flags();
    [CompilerGeneratedAttribute]
public UInt32 get_Reserved();
}
[IsReadOnlyAttribute]
internal class Microsoft.Diagnostics.Runtime.MacOS.MachOCommand : ValueType {
    internal MachOCommandType Command;
    internal int CommandSize;
}
internal enum Microsoft.Diagnostics.Runtime.MacOS.MachOCommandType : Enum {
    public int value__;
    public static MachOCommandType Segment64;
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.Diagnostics.Runtime.MacOS.MachOCoreDump : object {
    private static UInt32 X86_THREAD_STATE64;
    private static UInt32 ARM_THREAD_STATE64;
    private object _sync;
    private Stream _stream;
    private bool _leaveOpen;
    private MachHeader64 _header;
    private MachOSegment[] _segments;
    [NullableAttribute("2")]
private MachOModule _dylinker;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private Dictionary`2 modreq(System.Runtime.CompilerServices.IsVolatile) _modules;
    [CompilerGeneratedAttribute]
private ImmutableDictionary`2<UInt32, thread_state_t> <Threads>k__BackingField;
    [CompilerGeneratedAttribute]
private UInt32 <ProcessId>k__BackingField;
    [CompilerGeneratedAttribute]
private MachOCoreReader <Parent>k__BackingField;
    public ImmutableDictionary`2<UInt32, thread_state_t> Threads { get; }
    public UInt32 ProcessId { get; }
    public Architecture Architecture { get; }
    public MachOCoreReader Parent { get; }
    public MachOCoreDump(MachOCoreReader parent, Stream stream, bool leaveOpen, string displayName);
    [CompilerGeneratedAttribute]
public ImmutableDictionary`2<UInt32, thread_state_t> get_Threads();
    [CompilerGeneratedAttribute]
public UInt32 get_ProcessId();
    public Architecture get_Architecture();
    [CompilerGeneratedAttribute]
public MachOCoreReader get_Parent();
    [NullableContextAttribute("0")]
private static T Read(Stream stream);
    [NullableContextAttribute("2")]
public MachOModule GetModuleByBaseAddress(ulong baseAddress);
    public IEnumerable`1<MachOModule> EnumerateModules();
    [NullableContextAttribute("0")]
public T ReadMemory(ulong address);
    [NullableContextAttribute("0")]
public int ReadMemory(ulong address, Span`1<byte> buffer);
    internal string ReadAscii(ulong address);
    private Dictionary`2<ulong, MachOModule> ReadModules();
    [NullableContextAttribute("2")]
private MachOModule FindDylinker(bool firstPass);
    private bool FindSegmentContaining(ulong address, MachOSegment& seg);
    public sealed virtual void Dispose();
}
internal class Microsoft.Diagnostics.Runtime.MacOS.MachOCoreReader : CommonMemoryReader {
    [NullableAttribute("1")]
private MachOCoreDump _core;
    [NullableAttribute("1")]
[CompilerGeneratedAttribute]
private string <DisplayName>k__BackingField;
    [CompilerGeneratedAttribute]
private int <ProcessId>k__BackingField;
    [NullableAttribute("1")]
public string DisplayName { get; }
    public bool IsThreadSafe { get; }
    public OSPlatform TargetPlatform { get; }
    public Architecture Architecture { get; }
    public int ProcessId { get; }
    [NullableContextAttribute("1")]
public MachOCoreReader(string displayName, Stream stream, bool leaveOpen);
    [NullableContextAttribute("1")]
[CompilerGeneratedAttribute]
public sealed virtual string get_DisplayName();
    public sealed virtual bool get_IsThreadSafe();
    public sealed virtual OSPlatform get_TargetPlatform();
    public sealed virtual Architecture get_Architecture();
    [CompilerGeneratedAttribute]
public sealed virtual int get_ProcessId();
    [NullableContextAttribute("1")]
public sealed virtual IEnumerable`1<ModuleInfo> EnumerateModules();
    public sealed virtual void FlushCachedData();
    [NullableContextAttribute("1")]
public sealed virtual IEnumerable`1<UInt32> EnumerateOSThreadIds();
    public sealed virtual ulong GetThreadTeb(UInt32 _);
    public sealed virtual bool GetThreadContext(UInt32 threadID, UInt32 contextFlags, Span`1<byte> context);
    public virtual int Read(ulong address, Span`1<byte> buffer);
    public sealed virtual void Dispose();
}
internal enum Microsoft.Diagnostics.Runtime.MacOS.MachOCpuArch : Enum {
    public int value__;
    public static MachOCpuArch Abi64;
}
internal enum Microsoft.Diagnostics.Runtime.MacOS.MachOCpuType : Enum {
    public int value__;
    public static MachOCpuType X86;
    public static MachOCpuType X86_64;
    public static MachOCpuType ARM;
    public static MachOCpuType ARM64;
}
[IsReadOnlyAttribute]
internal class Microsoft.Diagnostics.Runtime.MacOS.MachOFileReader : ValueType {
    [NullableAttribute("1")]
private Stream _stream;
    [NullableContextAttribute("1")]
internal MachOFileReader(Stream stream);
    internal int Read(long position, Span`1<byte> buffer);
    internal T Read();
}
internal enum Microsoft.Diagnostics.Runtime.MacOS.MachOFileType : Enum {
    public int value__;
    public static MachOFileType Object;
    public static MachOFileType Execute;
    public static MachOFileType FVMLib;
    public static MachOFileType Core;
    public static MachOFileType Preload;
    public static MachOFileType Dylib;
    public static MachOFileType Dylinker;
    public static MachOFileType Bundle;
    public static MachOFileType DylibStub;
    public static MachOFileType DSym;
    public static MachOFileType KExtBundle;
}
[FlagsAttribute]
internal enum Microsoft.Diagnostics.Runtime.MacOS.MachOFlags : Enum {
    public int value__;
    public static MachOFlags NoUndefs;
    public static MachOFlags IncrLink;
    public static MachOFlags DylDlink;
    public static MachOFlags BindatLoad;
    public static MachOFlags Prebound;
    public static MachOFlags SplitSegs;
    public static MachOFlags LaxyInit;
    public static MachOFlags TwoLevel;
    public static MachOFlags ForceFlag;
    public static MachOFlags NoMultidefs;
    public static MachOFlags NoPrefixPrebinding;
    public static MachOFlags Prebindable;
    public static MachOFlags AllModsBound;
    public static MachOFlags SubsectionsViaSymbols;
    public static MachOFlags Canonical;
    public static MachOFlags WeakDefines;
    public static MachOFlags BindsToWeak;
    public static MachOFlags AllowStackExecution;
    public static MachOFlags RootSafe;
    public static MachOFlags SetuidSafe;
    public static MachOFlags NoReExportedDylibs;
    public static MachOFlags PIE;
    public static MachOFlags DeadStrippableDylib;
    public static MachOFlags HasTlvDescriptors;
    public static MachOFlags NoHeapExecution;
}
[IsReadOnlyAttribute]
internal class Microsoft.Diagnostics.Runtime.MacOS.MachOHeader64 : ValueType {
    internal static int ExpectedMagic;
    internal int Magic;
    internal MachOCpuType CpuType;
    internal int CpuSubtype;
    internal int FileType;
    internal int NumberOfCommands;
    internal int SizeOfCommands;
    internal int Flags;
    internal int Reserved;
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.Diagnostics.Runtime.MacOS.MachOModule : object {
    [NullableAttribute("2")]
[CompilerGeneratedAttribute]
private MachOCoreDump <Parent>k__BackingField;
    [CompilerGeneratedAttribute]
private ulong <BaseAddress>k__BackingField;
    [CompilerGeneratedAttribute]
private ulong <ImageSize>k__BackingField;
    [CompilerGeneratedAttribute]
private string <FileName>k__BackingField;
    [CompilerGeneratedAttribute]
private ulong <LoadBias>k__BackingField;
    [NullableAttribute("0")]
[CompilerGeneratedAttribute]
private ImmutableArray`1<byte> <BuildId>k__BackingField;
    [CompilerGeneratedAttribute]
private IDataReader <DataReader>k__BackingField;
    private MachHeader64 _header;
    private SymtabLoadCommand _symtab;
    private DysymtabLoadCommand _dysymtab;
    private MachOSegment[] _segments;
    private ulong _stringTableAddress;
    [NullableAttribute("2")]
private NList64[] modreq(System.Runtime.CompilerServices.IsVolatile) _symTable;
    [NullableAttribute("2")]
public MachOCoreDump Parent { get; }
    public ulong BaseAddress { get; }
    public ulong ImageSize { get; }
    public string FileName { get; }
    public ulong LoadBias { get; }
    [NullableAttribute("0")]
public ImmutableArray`1<byte> BuildId { get; }
    public IDataReader DataReader { get; }
    public MachOModule(IDataReader reader, ulong address, string path);
    public MachOModule(MachOCoreDump parent, ulong address, string path);
    private MachOModule(MachOCoreDump parent, IDataReader reader, MachHeader64& header, ulong address, string path);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public MachOCoreDump get_Parent();
    [CompilerGeneratedAttribute]
public ulong get_BaseAddress();
    [CompilerGeneratedAttribute]
public ulong get_ImageSize();
    [CompilerGeneratedAttribute]
public string get_FileName();
    [CompilerGeneratedAttribute]
public ulong get_LoadBias();
    [NullableContextAttribute("0")]
[CompilerGeneratedAttribute]
public ImmutableArray`1<byte> get_BuildId();
    [CompilerGeneratedAttribute]
public IDataReader get_DataReader();
    public bool TryLookupSymbol(string symbol, UInt64& address);
    private bool TryLookupSymbol(UInt32 start, UInt32 nsyms, string symbol, UInt64& address);
    private string GetSymbolName(NList64 tableEntry, int max);
    internal string ReadAscii(ulong address, int max);
    [NullableContextAttribute("2")]
private NList64[] ReadSymbolTable();
    private ulong GetAddressFromFileOffset(UInt32 fileOffset);
    [IteratorStateMachineAttribute("Microsoft.Diagnostics.Runtime.MacOS.MachOModule/<EnumerateSegments>d__36")]
public IEnumerable`1<Segment64LoadCommand> EnumerateSegments();
}
internal class Microsoft.Diagnostics.Runtime.MacOS.MachOModuleInfo : ModuleInfo {
    [NullableAttribute("2")]
private MachOModule _module;
    [NullableAttribute("2")]
private Version _version;
    private ulong _imageSize;
    public ModuleKind Kind { get; }
    public long ImageSize { get; }
    [NullableAttribute("1")]
public Version Version { get; }
    public ImmutableArray`1<byte> BuildId { get; }
    [NullableContextAttribute("2")]
public MachOModuleInfo(MachOModule module, ulong imageBase, string fileName, Version version, ulong imageSize);
    public virtual ModuleKind get_Kind();
    public virtual long get_ImageSize();
    [NullableContextAttribute("1")]
public virtual Version get_Version();
    public virtual ImmutableArray`1<byte> get_BuildId();
    [NullableContextAttribute("1")]
public virtual ulong GetExportSymbolAddress(string symbol);
}
internal class Microsoft.Diagnostics.Runtime.MacOS.MachOSection64 : ValueType {
    [FixedBufferAttribute("System.Byte", "16")]
internal <SectionName>e__FixedBuffer SectionName;
    [FixedBufferAttribute("System.Byte", "16")]
internal <SegmentName>e__FixedBuffer SegmentName;
    internal long Address;
    internal long Size;
    internal int Offset;
    internal int Alignment;
    internal int RelocOffset;
    internal int NumberOfReloc;
    internal int Flags;
    internal int Reserved1;
    internal int Reserved2;
    internal int Reserved3;
}
[IsReadOnlyAttribute]
internal class Microsoft.Diagnostics.Runtime.MacOS.MachOSegment : ValueType {
    [CompilerGeneratedAttribute]
private ulong <Address>k__BackingField;
    [CompilerGeneratedAttribute]
private ulong <Size>k__BackingField;
    [CompilerGeneratedAttribute]
private ulong <FileOffset>k__BackingField;
    [CompilerGeneratedAttribute]
private ulong <FileSize>k__BackingField;
    public ulong Address { get; }
    public ulong Size { get; }
    public ulong FileOffset { get; }
    public ulong FileSize { get; }
    public MachOSegment(Segment64LoadCommand& cmd);
    [CompilerGeneratedAttribute]
public ulong get_Address();
    [CompilerGeneratedAttribute]
public ulong get_Size();
    [CompilerGeneratedAttribute]
public ulong get_FileOffset();
    [CompilerGeneratedAttribute]
public ulong get_FileSize();
}
internal class Microsoft.Diagnostics.Runtime.MacOS.MachOSegmentCommand64 : ValueType {
    [FixedBufferAttribute("System.Byte", "16")]
internal <SegmentName>e__FixedBuffer SegmentName;
    internal long VMAddress;
    internal long VMSize;
    internal long FileOffset;
    internal long FileSize;
    internal int MaximumProtection;
    internal int InitialProtection;
    internal int NumberOfSections;
    internal int Flags;
}
internal class Microsoft.Diagnostics.Runtime.MacOS.MacOSProcessDataReader : CommonMemoryReader {
    private int _task;
    [NullableAttribute("1")]
private Builder<MemoryRegion> _memoryRegions;
    [NullableAttribute("1")]
private Dictionary`2<ulong, UInt32> _threadActs;
    private bool _suspended;
    private bool _disposed;
    private int _machTaskSelf;
    [CompilerGeneratedAttribute]
private Architecture <Architecture>k__BackingField;
    [CompilerGeneratedAttribute]
private int <ProcessId>k__BackingField;
    [NullableAttribute("1")]
public string DisplayName { get; }
    public bool IsThreadSafe { get; }
    public OSPlatform TargetPlatform { get; }
    public Architecture Architecture { get; }
    public int ProcessId { get; }
    public MacOSProcessDataReader(int processId, bool suspend);
    protected virtual override void Finalize();
    [NullableContextAttribute("1")]
public sealed virtual string get_DisplayName();
    public sealed virtual bool get_IsThreadSafe();
    public sealed virtual OSPlatform get_TargetPlatform();
    [CompilerGeneratedAttribute]
public sealed virtual Architecture get_Architecture();
    [CompilerGeneratedAttribute]
public sealed virtual int get_ProcessId();
    public sealed virtual void Dispose();
    private void Dispose(bool disposing);
    public sealed virtual void FlushCachedData();
    [NullableContextAttribute("1")]
[IteratorStateMachineAttribute("Microsoft.Diagnostics.Runtime.MacOS.MacOSProcessDataReader/<EnumerateModules>d__23")]
public sealed virtual IEnumerable`1<ModuleInfo> EnumerateModules();
    [NullableContextAttribute("2")]
public Version GetVersionInfo(ulong baseAddress);
    public virtual int Read(ulong address, Span`1<byte> buffer);
    private T Read(UInt64& address);
    [NullableContextAttribute("1")]
public sealed virtual IEnumerable`1<UInt32> EnumerateOSThreadIds();
    public sealed virtual ulong GetThreadTeb(UInt32 _);
    public sealed virtual bool GetThreadContext(UInt32 threadID, UInt32 contextFlags, Span`1<byte> context);
    private void LoadThreads();
    [NullableContextAttribute("1")]
private Builder<MemoryRegion> LoadMemoryRegions();
    [CompilerGeneratedAttribute]
private T <EnumerateModules>g__Read|23_0(ulong address, UInt32 index);
    [NullableContextAttribute("1")]
[CompilerGeneratedAttribute]
private string <EnumerateModules>g__ReadNullTerminatedAscii|23_1(ulong address);
}
[IsReadOnlyAttribute]
internal class Microsoft.Diagnostics.Runtime.MacOS.Structs.DyldAllImageInfos : ValueType {
    [CompilerGeneratedAttribute]
private UInt32 <version>k__BackingField;
    [CompilerGeneratedAttribute]
private UInt32 <infoArrayCount>k__BackingField;
    [CompilerGeneratedAttribute]
private UIntPtr <infoArray>k__BackingField;
    [CompilerGeneratedAttribute]
private IntPtr <notification>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <processDetachedFromSharedRegion>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <libSystemInitialized>k__BackingField;
    [CompilerGeneratedAttribute]
private IntPtr <dyldImageLoadAddress>k__BackingField;
    [CompilerGeneratedAttribute]
private IntPtr <jitInfo>k__BackingField;
    [CompilerGeneratedAttribute]
private IntPtr <dyldVersion>k__BackingField;
    [CompilerGeneratedAttribute]
private IntPtr <errorMessage>k__BackingField;
    [CompilerGeneratedAttribute]
private IntPtr <terminationFlags>k__BackingField;
    [CompilerGeneratedAttribute]
private IntPtr <coreSymbolicationShmPage>k__BackingField;
    [CompilerGeneratedAttribute]
private IntPtr <systemOrderFlag>k__BackingField;
    [CompilerGeneratedAttribute]
private IntPtr <uuidArrayCount>k__BackingField;
    [CompilerGeneratedAttribute]
private IntPtr <uuidArray>k__BackingField;
    [CompilerGeneratedAttribute]
private IntPtr <dyldAllImageInfosAddress>k__BackingField;
    [CompilerGeneratedAttribute]
private IntPtr <initialImageCount>k__BackingField;
    [CompilerGeneratedAttribute]
private IntPtr <errorKind>k__BackingField;
    [CompilerGeneratedAttribute]
private IntPtr <errorClientOfDylibPath>k__BackingField;
    [CompilerGeneratedAttribute]
private IntPtr <errorTargetDylibPath>k__BackingField;
    [CompilerGeneratedAttribute]
private IntPtr <errorSymbol>k__BackingField;
    [CompilerGeneratedAttribute]
private IntPtr <sharedCacheSlide>k__BackingField;
    public UInt32 version { get; }
    public UInt32 infoArrayCount { get; }
    public UIntPtr infoArray { get; }
    public IntPtr notification { get; }
    public bool processDetachedFromSharedRegion { get; }
    public bool libSystemInitialized { get; }
    public IntPtr dyldImageLoadAddress { get; }
    public IntPtr jitInfo { get; }
    public IntPtr dyldVersion { get; }
    public IntPtr errorMessage { get; }
    public IntPtr terminationFlags { get; }
    public IntPtr coreSymbolicationShmPage { get; }
    public IntPtr systemOrderFlag { get; }
    public IntPtr uuidArrayCount { get; }
    public IntPtr uuidArray { get; }
    public IntPtr dyldAllImageInfosAddress { get; }
    public IntPtr initialImageCount { get; }
    public IntPtr errorKind { get; }
    public IntPtr errorClientOfDylibPath { get; }
    public IntPtr errorTargetDylibPath { get; }
    public IntPtr errorSymbol { get; }
    public IntPtr sharedCacheSlide { get; }
    [CompilerGeneratedAttribute]
public UInt32 get_version();
    [CompilerGeneratedAttribute]
public UInt32 get_infoArrayCount();
    [CompilerGeneratedAttribute]
public UIntPtr get_infoArray();
    [CompilerGeneratedAttribute]
public IntPtr get_notification();
    [CompilerGeneratedAttribute]
public bool get_processDetachedFromSharedRegion();
    [CompilerGeneratedAttribute]
public bool get_libSystemInitialized();
    [CompilerGeneratedAttribute]
public IntPtr get_dyldImageLoadAddress();
    [CompilerGeneratedAttribute]
public IntPtr get_jitInfo();
    [CompilerGeneratedAttribute]
public IntPtr get_dyldVersion();
    [CompilerGeneratedAttribute]
public IntPtr get_errorMessage();
    [CompilerGeneratedAttribute]
public IntPtr get_terminationFlags();
    [CompilerGeneratedAttribute]
public IntPtr get_coreSymbolicationShmPage();
    [CompilerGeneratedAttribute]
public IntPtr get_systemOrderFlag();
    [CompilerGeneratedAttribute]
public IntPtr get_uuidArrayCount();
    [CompilerGeneratedAttribute]
public IntPtr get_uuidArray();
    [CompilerGeneratedAttribute]
public IntPtr get_dyldAllImageInfosAddress();
    [CompilerGeneratedAttribute]
public IntPtr get_initialImageCount();
    [CompilerGeneratedAttribute]
public IntPtr get_errorKind();
    [CompilerGeneratedAttribute]
public IntPtr get_errorClientOfDylibPath();
    [CompilerGeneratedAttribute]
public IntPtr get_errorTargetDylibPath();
    [CompilerGeneratedAttribute]
public IntPtr get_errorSymbol();
    [CompilerGeneratedAttribute]
public IntPtr get_sharedCacheSlide();
}
[IsReadOnlyAttribute]
internal class Microsoft.Diagnostics.Runtime.MacOS.Structs.DyldImageInfo : ValueType {
    [CompilerGeneratedAttribute]
private UIntPtr <ImageLoadAddress>k__BackingField;
    [CompilerGeneratedAttribute]
private UIntPtr <ImageFilePath>k__BackingField;
    [CompilerGeneratedAttribute]
private UIntPtr <ImageFileModDate>k__BackingField;
    public UIntPtr ImageLoadAddress { get; }
    public UIntPtr ImageFilePath { get; }
    public UIntPtr ImageFileModDate { get; }
    [CompilerGeneratedAttribute]
public UIntPtr get_ImageLoadAddress();
    [CompilerGeneratedAttribute]
public UIntPtr get_ImageFilePath();
    [CompilerGeneratedAttribute]
public UIntPtr get_ImageFileModDate();
}
[IsReadOnlyAttribute]
internal class Microsoft.Diagnostics.Runtime.MacOS.Structs.DysymtabLoadCommand : ValueType {
    [CompilerGeneratedAttribute]
private LoadCommandHeader <Header>k__BackingField;
    [CompilerGeneratedAttribute]
private UInt32 <ilocalsym>k__BackingField;
    [CompilerGeneratedAttribute]
private UInt32 <nlocalsym>k__BackingField;
    [CompilerGeneratedAttribute]
private UInt32 <iextdefsym>k__BackingField;
    [CompilerGeneratedAttribute]
private UInt32 <nextdefsym>k__BackingField;
    [CompilerGeneratedAttribute]
private UInt32 <iundefsym>k__BackingField;
    [CompilerGeneratedAttribute]
private UInt32 <nundefsym>k__BackingField;
    [CompilerGeneratedAttribute]
private UInt32 <tocoff>k__BackingField;
    [CompilerGeneratedAttribute]
private UInt32 <ntoc>k__BackingField;
    [CompilerGeneratedAttribute]
private UInt32 <modtaboff>k__BackingField;
    [CompilerGeneratedAttribute]
private UInt32 <nmodtab>k__BackingField;
    [CompilerGeneratedAttribute]
private UInt32 <extrefsymoff>k__BackingField;
    [CompilerGeneratedAttribute]
private UInt32 <nextrefsyms>k__BackingField;
    [CompilerGeneratedAttribute]
private UInt32 <indirectsymoff>k__BackingField;
    [CompilerGeneratedAttribute]
private UInt32 <nindirectsyms>k__BackingField;
    [CompilerGeneratedAttribute]
private UInt32 <extreloff>k__BackingField;
    [CompilerGeneratedAttribute]
private UInt32 <nextrel>k__BackingField;
    [CompilerGeneratedAttribute]
private UInt32 <locreloff>k__BackingField;
    [CompilerGeneratedAttribute]
private UInt32 <nlocrel>k__BackingField;
    public LoadCommandHeader Header { get; }
    public UInt32 ilocalsym { get; }
    public UInt32 nlocalsym { get; }
    public UInt32 iextdefsym { get; }
    public UInt32 nextdefsym { get; }
    public UInt32 iundefsym { get; }
    public UInt32 nundefsym { get; }
    public UInt32 tocoff { get; }
    public UInt32 ntoc { get; }
    public UInt32 modtaboff { get; }
    public UInt32 nmodtab { get; }
    public UInt32 extrefsymoff { get; }
    public UInt32 nextrefsyms { get; }
    public UInt32 indirectsymoff { get; }
    public UInt32 nindirectsyms { get; }
    public UInt32 extreloff { get; }
    public UInt32 nextrel { get; }
    public UInt32 locreloff { get; }
    public UInt32 nlocrel { get; }
    [CompilerGeneratedAttribute]
public LoadCommandHeader get_Header();
    [CompilerGeneratedAttribute]
public UInt32 get_ilocalsym();
    [CompilerGeneratedAttribute]
public UInt32 get_nlocalsym();
    [CompilerGeneratedAttribute]
public UInt32 get_iextdefsym();
    [CompilerGeneratedAttribute]
public UInt32 get_nextdefsym();
    [CompilerGeneratedAttribute]
public UInt32 get_iundefsym();
    [CompilerGeneratedAttribute]
public UInt32 get_nundefsym();
    [CompilerGeneratedAttribute]
public UInt32 get_tocoff();
    [CompilerGeneratedAttribute]
public UInt32 get_ntoc();
    [CompilerGeneratedAttribute]
public UInt32 get_modtaboff();
    [CompilerGeneratedAttribute]
public UInt32 get_nmodtab();
    [CompilerGeneratedAttribute]
public UInt32 get_extrefsymoff();
    [CompilerGeneratedAttribute]
public UInt32 get_nextrefsyms();
    [CompilerGeneratedAttribute]
public UInt32 get_indirectsymoff();
    [CompilerGeneratedAttribute]
public UInt32 get_nindirectsyms();
    [CompilerGeneratedAttribute]
public UInt32 get_extreloff();
    [CompilerGeneratedAttribute]
public UInt32 get_nextrel();
    [CompilerGeneratedAttribute]
public UInt32 get_locreloff();
    [CompilerGeneratedAttribute]
public UInt32 get_nlocrel();
}
[IsReadOnlyAttribute]
internal class Microsoft.Diagnostics.Runtime.MacOS.Structs.LoadCommandHeader : ValueType {
    [CompilerGeneratedAttribute]
private LoadCommandType <Kind>k__BackingField;
    [CompilerGeneratedAttribute]
private UInt32 <Size>k__BackingField;
    public static UInt32 HeaderSize { get; }
    public LoadCommandType Kind { get; }
    public UInt32 Size { get; }
    public static UInt32 get_HeaderSize();
    [CompilerGeneratedAttribute]
public LoadCommandType get_Kind();
    [CompilerGeneratedAttribute]
public UInt32 get_Size();
}
internal enum Microsoft.Diagnostics.Runtime.MacOS.Structs.LoadCommandType : Enum {
    public int value__;
    public static LoadCommandType Segment;
    public static LoadCommandType SymTab;
    public static LoadCommandType SymSeg;
    public static LoadCommandType Thread;
    public static LoadCommandType UnixThread;
    public static LoadCommandType LoadFVMLib;
    public static LoadCommandType IDFVMLib;
    public static LoadCommandType Ident;
    public static LoadCommandType FVMFile;
    public static LoadCommandType PrePage;
    public static LoadCommandType DysymTab;
    public static LoadCommandType LoadDylib;
    public static LoadCommandType IdDylib;
    public static LoadCommandType LoadDylinker;
    public static LoadCommandType IdDylinker;
    public static LoadCommandType PreboundDylib;
    public static LoadCommandType Routines;
    public static LoadCommandType SubFramework;
    public static LoadCommandType SubUmbrella;
    public static LoadCommandType SubClient;
    public static LoadCommandType SubLibrary;
    public static LoadCommandType TwoLevelHints;
    public static LoadCommandType PrebindChksum;
    public static LoadCommandType Segment64;
    public static LoadCommandType Uuid;
}
[IsReadOnlyAttribute]
internal class Microsoft.Diagnostics.Runtime.MacOS.Structs.NList64 : ValueType {
    [CompilerGeneratedAttribute]
private UInt32 <n_strx>k__BackingField;
    [CompilerGeneratedAttribute]
private byte <n_type>k__BackingField;
    [CompilerGeneratedAttribute]
private byte <n_sect>k__BackingField;
    [CompilerGeneratedAttribute]
private ushort <n_desc>k__BackingField;
    [CompilerGeneratedAttribute]
private ulong <n_value>k__BackingField;
    public UInt32 n_strx { get; }
    public byte n_type { get; }
    public byte n_sect { get; }
    public ushort n_desc { get; }
    public ulong n_value { get; }
    [CompilerGeneratedAttribute]
public UInt32 get_n_strx();
    [CompilerGeneratedAttribute]
public byte get_n_type();
    [CompilerGeneratedAttribute]
public byte get_n_sect();
    [CompilerGeneratedAttribute]
public ushort get_n_desc();
    [CompilerGeneratedAttribute]
public ulong get_n_value();
}
internal class Microsoft.Diagnostics.Runtime.MacOS.Structs.Segment64LoadCommand : ValueType {
    public static UInt32 VmProtWrite;
    [FixedBufferAttribute("System.Byte", "16")]
private <SegName>e__FixedBuffer SegName;
    [CompilerGeneratedAttribute]
private ulong <VMAddr>k__BackingField;
    [CompilerGeneratedAttribute]
private ulong <VMSize>k__BackingField;
    [CompilerGeneratedAttribute]
private ulong <FileOffset>k__BackingField;
    [CompilerGeneratedAttribute]
private ulong <FileSize>k__BackingField;
    [CompilerGeneratedAttribute]
private UInt32 <MaxProt>k__BackingField;
    [CompilerGeneratedAttribute]
private UInt32 <InitProt>k__BackingField;
    [CompilerGeneratedAttribute]
private UInt32 <NumberSections>k__BackingField;
    [CompilerGeneratedAttribute]
private UInt32 <Flags>k__BackingField;
    public ulong VMAddr { get; }
    public ulong VMSize { get; }
    public ulong FileOffset { get; }
    public ulong FileSize { get; }
    public UInt32 MaxProt { get; }
    public UInt32 InitProt { get; }
    public UInt32 NumberSections { get; }
    public UInt32 Flags { get; }
    [NullableAttribute("1")]
public string Name { get; }
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public ulong get_VMAddr();
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public ulong get_VMSize();
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public ulong get_FileOffset();
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public ulong get_FileSize();
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public UInt32 get_MaxProt();
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public UInt32 get_InitProt();
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public UInt32 get_NumberSections();
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public UInt32 get_Flags();
    [NullableContextAttribute("1")]
public string get_Name();
}
[IsReadOnlyAttribute]
internal class Microsoft.Diagnostics.Runtime.MacOS.Structs.SpecialThreadInfoEntry : ValueType {
    [CompilerGeneratedAttribute]
private UInt32 <ThreadId>k__BackingField;
    [CompilerGeneratedAttribute]
private ulong <StackPointer>k__BackingField;
    public UInt32 ThreadId { get; }
    public ulong StackPointer { get; }
    [CompilerGeneratedAttribute]
public UInt32 get_ThreadId();
    [CompilerGeneratedAttribute]
public ulong get_StackPointer();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.Diagnostics.Runtime.MacOS.Structs.SpecialThreadInfoHeader : ValueType {
    public static string SpecialThreadInfoSignature;
    public static ulong SpecialThreadInfoAddress;
    [NullableAttribute("0")]
[FixedBufferAttribute("System.Byte", "16")]
private <_signature>e__FixedBuffer _signature;
    [CompilerGeneratedAttribute]
private UInt32 <ProcessId>k__BackingField;
    [CompilerGeneratedAttribute]
private UInt32 <NumberThreadEntries>k__BackingField;
    public string Signature { get; }
    public UInt32 ProcessId { get; }
    public UInt32 NumberThreadEntries { get; }
    public string get_Signature();
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public UInt32 get_ProcessId();
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public UInt32 get_NumberThreadEntries();
}
[IsReadOnlyAttribute]
internal class Microsoft.Diagnostics.Runtime.MacOS.Structs.SymtabLoadCommand : ValueType {
    [CompilerGeneratedAttribute]
private LoadCommandHeader <Header>k__BackingField;
    [CompilerGeneratedAttribute]
private UInt32 <SymOff>k__BackingField;
    [CompilerGeneratedAttribute]
private UInt32 <NSyms>k__BackingField;
    [CompilerGeneratedAttribute]
private UInt32 <StrOff>k__BackingField;
    [CompilerGeneratedAttribute]
private UInt32 <StrSize>k__BackingField;
    public LoadCommandHeader Header { get; }
    public UInt32 SymOff { get; }
    public UInt32 NSyms { get; }
    public UInt32 StrOff { get; }
    public UInt32 StrSize { get; }
    [CompilerGeneratedAttribute]
public LoadCommandHeader get_Header();
    [CompilerGeneratedAttribute]
public UInt32 get_SymOff();
    [CompilerGeneratedAttribute]
public UInt32 get_NSyms();
    [CompilerGeneratedAttribute]
public UInt32 get_StrOff();
    [CompilerGeneratedAttribute]
public UInt32 get_StrSize();
}
internal class Microsoft.Diagnostics.Runtime.MacOS.Structs.UuidLoadCommand : ValueType {
    public LoadCommandHeader Header;
    [FixedBufferAttribute("System.Byte", "16")]
public <Uuid>e__FixedBuffer Uuid;
    [NullableAttribute("1")]
public Byte[] BuildId { get; }
    [NullableContextAttribute("1")]
public Byte[] get_BuildId();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.Diagnostics.Runtime.MacOSFunctions : CoreFunctions {
    public virtual bool TryGetWow64(IntPtr proc, Boolean& result);
    internal virtual bool GetFileVersion(string dll, Int32& major, Int32& minor, Int32& revision, Int32& patch);
    public virtual bool FreeLibrary(IntPtr handle);
    public virtual IntPtr GetLibraryExport(IntPtr handle, string name);
    public virtual IntPtr LoadLibrary(string libraryPath);
}
internal class Microsoft.Diagnostics.Runtime.MEMORY_BASIC_INFORMATION : ValueType {
    public IntPtr Address;
    public IntPtr AllocationBase;
    public UInt32 AllocationProtect;
    public IntPtr RegionSize;
    public UInt32 State;
    public UInt32 Protect;
    public UInt32 Type;
    public ulong BaseAddress { get; }
    public ulong Size { get; }
    public ulong get_BaseAddress();
    public ulong get_Size();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
internal static class Microsoft.Diagnostics.Runtime.MemoryExtensions : object {
    [NullableContextAttribute("0")]
[ExtensionAttribute]
public static ulong SearchMemory(IMemoryReader reader, ulong startAddress, int length, ReadOnlySpan`1<byte> searchFor);
    [ExtensionAttribute]
public static string ConvertToHumanReadable(ulong totalBytes);
    [ExtensionAttribute]
public static string ConvertToHumanReadable(long totalBytes);
    [ExtensionAttribute]
public static string ConvertToHumanReadable(double totalBytes);
}
[IsReadOnlyAttribute]
public class Microsoft.Diagnostics.Runtime.MemoryRange : ValueType {
    [CompilerGeneratedAttribute]
private ulong <Start>k__BackingField;
    [CompilerGeneratedAttribute]
private ulong <End>k__BackingField;
    public ulong Start { get; }
    public ulong End { get; }
    public ulong Length { get; }
    public MemoryRange(ulong start, ulong end);
    public static MemoryRange CreateFromLength(ulong start, ulong length);
    [CompilerGeneratedAttribute]
public ulong get_Start();
    [CompilerGeneratedAttribute]
public ulong get_End();
    public ulong get_Length();
    public bool Contains(ulong address);
    public bool Overlaps(MemoryRange other);
    public bool Contains(MemoryRange other);
    [NullableContextAttribute("1")]
public virtual string ToString();
    public int CompareTo(ulong address);
}
public enum Microsoft.Diagnostics.Runtime.MethodCompilationType : Enum {
    public int value__;
    public static MethodCompilationType None;
    public static MethodCompilationType Jit;
    public static MethodCompilationType Ngen;
}
internal class Microsoft.Diagnostics.Runtime.MinidumpReader : object {
    [NullableAttribute("1")]
private Minidump _minidump;
    [NullableAttribute("2")]
private IMemoryReader _readerCached;
    [NullableAttribute("1")]
[CompilerGeneratedAttribute]
private string <DisplayName>k__BackingField;
    [CompilerGeneratedAttribute]
private Architecture <Architecture>k__BackingField;
    [CompilerGeneratedAttribute]
private int <PointerSize>k__BackingField;
    public OSPlatform TargetPlatform { get; }
    [NullableAttribute("1")]
public string DisplayName { get; }
    [NullableAttribute("1")]
public IMemoryReader MemoryReader { get; }
    public bool IsThreadSafe { get; }
    public Architecture Architecture { get; }
    public int ProcessId { get; }
    public int PointerSize { get; }
    public bool IsMiniOrTriage { get; }
    [NullableContextAttribute("1")]
public MinidumpReader(string displayName, Stream stream, CacheOptions cacheOptions, bool leaveOpen);
    public sealed virtual OSPlatform get_TargetPlatform();
    [NullableContextAttribute("1")]
[CompilerGeneratedAttribute]
public sealed virtual string get_DisplayName();
    [NullableContextAttribute("1")]
public IMemoryReader get_MemoryReader();
    public sealed virtual bool get_IsThreadSafe();
    [CompilerGeneratedAttribute]
public sealed virtual Architecture get_Architecture();
    public sealed virtual int get_ProcessId();
    [CompilerGeneratedAttribute]
public sealed virtual int get_PointerSize();
    public sealed virtual bool get_IsMiniOrTriage();
    public sealed virtual void Dispose();
    [NullableContextAttribute("1")]
public sealed virtual IEnumerable`1<ModuleInfo> EnumerateModules();
    public sealed virtual void FlushCachedData();
    [NullableContextAttribute("1")]
public sealed virtual IEnumerable`1<UInt32> EnumerateOSThreadIds();
    public sealed virtual ulong GetThreadTeb(UInt32 osThreadId);
    public sealed virtual bool GetThreadContext(UInt32 threadID, UInt32 contextFlags, Span`1<byte> context);
    public sealed virtual int Read(ulong address, Span`1<byte> buffer);
    public sealed virtual bool Read(ulong address, T& value);
    public sealed virtual T Read(ulong address);
    public sealed virtual bool ReadPointer(ulong address, UInt64& value);
    public sealed virtual ulong ReadPointer(ulong address);
    [CompilerGeneratedAttribute]
private PEModuleInfo <EnumerateModules>b__23_0(MinidumpModuleInfo module);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public abstract class Microsoft.Diagnostics.Runtime.ModuleInfo : object {
    [CompilerGeneratedAttribute]
private ulong <ImageBase>k__BackingField;
    [CompilerGeneratedAttribute]
private string <FileName>k__BackingField;
    public ModuleKind Kind { get; }
    public ulong ImageBase { get; }
    public string FileName { get; }
    public long ImageSize { get; }
    public int IndexFileSize { get; }
    public int IndexTimeStamp { get; }
    public Version Version { get; }
    [NullableAttribute("0")]
public ImmutableArray`1<byte> BuildId { get; }
    [NullableAttribute("2")]
public PdbInfo Pdb { get; }
    public bool IsManaged { get; }
    [NullableAttribute("2")]
public IResourceNode ResourceRoot { get; }
    public ModuleInfo(ulong imageBase, string fileName);
    public static ModuleInfo TryCreate(IDataReader reader, ulong baseAddress, string name);
    public static ModuleInfo TryCreate(IDataReader reader, ulong baseAddress, string name, int indexFileSize, int indexTimeStamp, Version version);
    public static IResourceNode TryCreateResourceRoot(IDataReader reader, ulong imageBase, ulong imageSize, bool isFileLayout);
    [NullableContextAttribute("2")]
protected virtual void TrySetProperties(int indexFileSize, int indexTimeStamp, Version version);
    public abstract virtual ModuleKind get_Kind();
    [CompilerGeneratedAttribute]
public ulong get_ImageBase();
    [CompilerGeneratedAttribute]
public string get_FileName();
    public virtual long get_ImageSize();
    public virtual int get_IndexFileSize();
    public virtual int get_IndexTimeStamp();
    public virtual Version get_Version();
    [NullableContextAttribute("0")]
public virtual ImmutableArray`1<byte> get_BuildId();
    [NullableContextAttribute("2")]
public virtual PdbInfo get_Pdb();
    public virtual bool get_IsManaged();
    public virtual ulong GetExportSymbolAddress(string symbol);
    [NullableContextAttribute("2")]
public virtual IResourceNode get_ResourceRoot();
    public virtual string ToString();
}
public enum Microsoft.Diagnostics.Runtime.ModuleKind : Enum {
    public int value__;
    public static ModuleKind Unknown;
    public static ModuleKind Other;
    public static ModuleKind PortableExecutable;
    public static ModuleKind Elf;
    public static ModuleKind MachO;
}
public enum Microsoft.Diagnostics.Runtime.ModuleLayout : Enum {
    public int value__;
    public static ModuleLayout Unknown;
    public static ModuleLayout Mapped;
    public static ModuleLayout Flat;
    public static ModuleLayout Loaded;
}
public enum Microsoft.Diagnostics.Runtime.NativeHeapKind : Enum {
    public int value__;
    public static NativeHeapKind Unknown;
    public static NativeHeapKind IndirectionCellHeap;
    public static NativeHeapKind LookupHeap;
    public static NativeHeapKind ResolveHeap;
    public static NativeHeapKind DispatchHeap;
    public static NativeHeapKind CacheEntryHeap;
    public static NativeHeapKind VtableHeap;
    public static NativeHeapKind LoaderCodeHeap;
    public static NativeHeapKind HostCodeHeap;
    public static NativeHeapKind StubHeap;
    public static NativeHeapKind HighFrequencyHeap;
    public static NativeHeapKind LowFrequencyHeap;
    public static NativeHeapKind ExecutableHeap;
    public static NativeHeapKind FixupPrecodeHeap;
    public static NativeHeapKind NewStubPrecodeHeap;
    public static NativeHeapKind ThunkHeap;
    public static NativeHeapKind HandleTable;
    public static NativeHeapKind GCBookkeeping;
    public static NativeHeapKind GCFreeRegion;
    public static NativeHeapKind GCFreeGlobalHugeRegion;
    public static NativeHeapKind GCFreeGlobalRegion;
    public static NativeHeapKind GCFreeSohSegment;
    public static NativeHeapKind GCFreeUohSegment;
}
[IsReadOnlyAttribute]
internal class Microsoft.Diagnostics.Runtime.NativeHillClimbingLogEntry : ValueType {
    public int TickCount;
    public HillClimbingTransition Transition;
    public int NewControlSetting;
    public int LastHistoryCount;
    public float LastHistoryMean;
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Microsoft.Diagnostics.Runtime.ObjectCorruption : object {
    [CompilerGeneratedAttribute]
private ClrObject <Object>k__BackingField;
    [CompilerGeneratedAttribute]
private int <Offset>k__BackingField;
    [CompilerGeneratedAttribute]
private ObjectCorruptionKind <Kind>k__BackingField;
    [CompilerGeneratedAttribute]
private int <SyncBlockIndex>k__BackingField;
    [CompilerGeneratedAttribute]
private int <ClrSyncBlockIndex>k__BackingField;
    public ClrObject Object { get; }
    public int Offset { get; }
    public ObjectCorruptionKind Kind { get; }
    public int SyncBlockIndex { get; }
    public int ClrSyncBlockIndex { get; }
    private IClrValue Microsoft.Diagnostics.Runtime.Interfaces.IObjectCorruption.Object { get; }
    public ObjectCorruption(ClrObject obj, int offset, ObjectCorruptionKind kind);
    public ObjectCorruption(ClrObject obj, int offset, ObjectCorruptionKind kind, int syncBlockIndex, int clrSyncBlockIndex);
    [CompilerGeneratedAttribute]
public ClrObject get_Object();
    [CompilerGeneratedAttribute]
public sealed virtual int get_Offset();
    [CompilerGeneratedAttribute]
public sealed virtual ObjectCorruptionKind get_Kind();
    [CompilerGeneratedAttribute]
public sealed virtual int get_SyncBlockIndex();
    [CompilerGeneratedAttribute]
public int get_ClrSyncBlockIndex();
    private sealed virtual override IClrValue Microsoft.Diagnostics.Runtime.Interfaces.IObjectCorruption.get_Object();
    public virtual string ToString();
}
public enum Microsoft.Diagnostics.Runtime.ObjectCorruptionKind : Enum {
    public int value__;
    public static ObjectCorruptionKind None;
    public static ObjectCorruptionKind ObjectNotOnTheHeap;
    public static ObjectCorruptionKind ObjectNotPointerAligned;
    public static ObjectCorruptionKind ObjectTooLarge;
    public static ObjectCorruptionKind InvalidMethodTable;
    public static ObjectCorruptionKind InvalidThinlock;
    public static ObjectCorruptionKind SyncBlockMismatch;
    public static ObjectCorruptionKind SyncBlockZero;
    public static ObjectCorruptionKind ObjectReferenceNotPointerAligned;
    public static ObjectCorruptionKind InvalidObjectReference;
    public static ObjectCorruptionKind FreeObjectReference;
    public static ObjectCorruptionKind CouldNotReadMethodTable;
    public static ObjectCorruptionKind CouldNotReadCardTable;
    public static ObjectCorruptionKind CouldNotReadObject;
    public static ObjectCorruptionKind CouldNotReadGCDesc;
}
public enum Microsoft.Diagnostics.Runtime.OutOfMemoryReason : Enum {
    public int value__;
    public static OutOfMemoryReason None;
    public static OutOfMemoryReason Budget;
    public static OutOfMemoryReason CantCommit;
    public static OutOfMemoryReason CantReserve;
    public static OutOfMemoryReason LOH;
    public static OutOfMemoryReason LowMem;
    public static OutOfMemoryReason UnproductiveFullGC;
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Microsoft.Diagnostics.Runtime.PdbInfo : object {
    [CompilerGeneratedAttribute]
private Guid <Guid>k__BackingField;
    [CompilerGeneratedAttribute]
private int <Revision>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Path>k__BackingField;
    public Guid Guid { get; }
    public int Revision { get; }
    public string Path { get; }
    public PdbInfo(string path, Guid guid, int rev);
    [CompilerGeneratedAttribute]
public Guid get_Guid();
    [CompilerGeneratedAttribute]
public int get_Revision();
    [CompilerGeneratedAttribute]
public string get_Path();
    public virtual int GetHashCode();
    [NullableContextAttribute("2")]
public virtual bool Equals(object obj);
    [NullableContextAttribute("2")]
public sealed virtual bool Equals(PdbInfo other);
    public virtual string ToString();
    [NullableContextAttribute("2")]
public static bool op_Equality(PdbInfo left, PdbInfo right);
    [NullableContextAttribute("2")]
public static bool op_Inequality(PdbInfo left, PdbInfo right);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public abstract class Microsoft.Diagnostics.Runtime.PlatformFunctions : object {
    internal static Byte[] s_versionString;
    internal static int s_versionLength;
    private static PlatformFunctions();
    internal abstract virtual bool GetFileVersion(string dll, Int32& major, Int32& minor, Int32& revision, Int32& patch);
    public abstract virtual bool TryGetWow64(IntPtr proc, Boolean& result);
    public abstract virtual IntPtr LoadLibrary(string libraryPath);
    public abstract virtual bool FreeLibrary(IntPtr handle);
    public abstract virtual IntPtr GetLibraryExport(IntPtr handle, string name);
    public virtual bool IsEqualFileVersion(string file, Version version);
}
[ExtensionAttribute]
internal static class Microsoft.Diagnostics.Runtime.PointerHelpers : object {
    [ExtensionAttribute]
public static IntPtr AsIntPtr(ulong address);
}
[ExtensionAttribute]
internal static class Microsoft.Diagnostics.Runtime.ProcessReaderExtensions : object {
    [NullableContextAttribute("1")]
[ExtensionAttribute]
internal static int GetReadableBytesCount(CommonMemoryReader _, Builder<TRegion> regions, ulong address, int bytesToRead);
    private static int GetRegionContaining(Builder<TRegion> regions, ulong address);
}
[FlagsAttribute]
internal enum Microsoft.Diagnostics.Runtime.PSS_CAPTURE_FLAGS : Enum {
    public UInt32 value__;
    public static PSS_CAPTURE_FLAGS PSS_CAPTURE_NONE;
    public static PSS_CAPTURE_FLAGS PSS_CAPTURE_VA_CLONE;
    public static PSS_CAPTURE_FLAGS PSS_CAPTURE_RESERVED_00000002;
    public static PSS_CAPTURE_FLAGS PSS_CAPTURE_HANDLES;
    public static PSS_CAPTURE_FLAGS PSS_CAPTURE_HANDLE_NAME_INFORMATION;
    public static PSS_CAPTURE_FLAGS PSS_CAPTURE_HANDLE_BASIC_INFORMATION;
    public static PSS_CAPTURE_FLAGS PSS_CAPTURE_HANDLE_TYPE_SPECIFIC_INFORMATION;
    public static PSS_CAPTURE_FLAGS PSS_CAPTURE_HANDLE_TRACE;
    public static PSS_CAPTURE_FLAGS PSS_CAPTURE_THREADS;
    public static PSS_CAPTURE_FLAGS PSS_CAPTURE_THREAD_CONTEXT;
    public static PSS_CAPTURE_FLAGS PSS_CAPTURE_THREAD_CONTEXT_EXTENDED;
    public static PSS_CAPTURE_FLAGS PSS_CAPTURE_RESERVED_00000400;
    public static PSS_CAPTURE_FLAGS PSS_CAPTURE_VA_SPACE;
    public static PSS_CAPTURE_FLAGS PSS_CAPTURE_VA_SPACE_SECTION_INFORMATION;
    public static PSS_CAPTURE_FLAGS PSS_CREATE_BREAKAWAY_OPTIONAL;
    public static PSS_CAPTURE_FLAGS PSS_CREATE_BREAKAWAY;
    public static PSS_CAPTURE_FLAGS PSS_CREATE_FORCE_BREAKAWAY;
    public static PSS_CAPTURE_FLAGS PSS_CREATE_USE_VM_ALLOCATIONS;
    public static PSS_CAPTURE_FLAGS PSS_CREATE_MEASURE_PERFORMANCE;
    public static PSS_CAPTURE_FLAGS PSS_CREATE_RELEASE_SECTION;
}
internal enum Microsoft.Diagnostics.Runtime.PSS_QUERY_INFORMATION_CLASS : Enum {
    public int value__;
    public static PSS_QUERY_INFORMATION_CLASS PSS_QUERY_PROCESS_INFORMATION;
    public static PSS_QUERY_INFORMATION_CLASS PSS_QUERY_VA_CLONE_INFORMATION;
    public static PSS_QUERY_INFORMATION_CLASS PSS_QUERY_AUXILIARY_PAGES_INFORMATION;
    public static PSS_QUERY_INFORMATION_CLASS PSS_QUERY_VA_SPACE_INFORMATION;
    public static PSS_QUERY_INFORMATION_CLASS PSS_QUERY_HANDLE_INFORMATION;
    public static PSS_QUERY_INFORMATION_CLASS PSS_QUERY_THREAD_INFORMATION;
    public static PSS_QUERY_INFORMATION_CLASS PSS_QUERY_HANDLE_TRACE_INFORMATION;
    public static PSS_QUERY_INFORMATION_CLASS PSS_QUERY_PERFORMANCE_COUNTERS;
}
public class Microsoft.Diagnostics.Runtime.RefCountedFreeLibrary : object {
    private IntPtr _library;
    private int _refCount;
    public RefCountedFreeLibrary(IntPtr library);
    public int AddRef();
    public int Release();
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
[AttributeUsageAttribute("384")]
public class Microsoft.Diagnostics.Runtime.RegisterAttribute : Attribute {
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    [CompilerGeneratedAttribute]
private RegisterType <RegisterType>k__BackingField;
    public string Name { get; public set; }
    public RegisterType RegisterType { get; }
    public RegisterAttribute(RegisterType registerType);
    [CompilerGeneratedAttribute]
public string get_Name();
    [CompilerGeneratedAttribute]
public void set_Name(string value);
    [CompilerGeneratedAttribute]
public RegisterType get_RegisterType();
}
[FlagsAttribute]
public enum Microsoft.Diagnostics.Runtime.RegisterType : Enum {
    public byte value__;
    public static RegisterType General;
    public static RegisterType Control;
    public static RegisterType Segments;
    public static RegisterType FloatingPoint;
    public static RegisterType Debug;
    public static RegisterType TypeMask;
    public static RegisterType ProgramCounter;
    public static RegisterType StackPointer;
    public static RegisterType FramePointer;
}
public class Microsoft.Diagnostics.Runtime.RiscV64Context : ValueType {
    public static UInt32 Context;
    public static UInt32 ContextControl;
    public static UInt32 ContextInteger;
    public static UInt32 ContextFloatingPoint;
    public static UInt32 ContextDebugRegisters;
    public UInt32 ContextFlags;
    [RegisterAttribute("1")]
public ulong R0;
    [RegisterAttribute("1")]
public ulong Ra;
    [RegisterAttribute("34")]
public ulong Sp;
    [RegisterAttribute("1")]
public ulong Gp;
    [RegisterAttribute("1")]
public ulong Tp;
    [RegisterAttribute("1")]
public ulong T0;
    [RegisterAttribute("1")]
public ulong T1;
    [RegisterAttribute("1")]
public ulong T2;
    [RegisterAttribute("66")]
public ulong Fp;
    [RegisterAttribute("1")]
public ulong S1;
    [RegisterAttribute("1")]
public ulong A0;
    [RegisterAttribute("1")]
public ulong A1;
    [RegisterAttribute("1")]
public ulong A2;
    [RegisterAttribute("1")]
public ulong A3;
    [RegisterAttribute("1")]
public ulong A4;
    [RegisterAttribute("1")]
public ulong A5;
    [RegisterAttribute("1")]
public ulong A6;
    [RegisterAttribute("1")]
public ulong A7;
    [RegisterAttribute("1")]
public ulong S2;
    [RegisterAttribute("1")]
public ulong S3;
    [RegisterAttribute("1")]
public ulong S4;
    [RegisterAttribute("1")]
public ulong S5;
    [RegisterAttribute("1")]
public ulong S6;
    [RegisterAttribute("1")]
public ulong S7;
    [RegisterAttribute("1")]
public ulong S8;
    [RegisterAttribute("1")]
public ulong S9;
    [RegisterAttribute("1")]
public ulong S10;
    [RegisterAttribute("1")]
public ulong S11;
    [RegisterAttribute("1")]
public ulong T3;
    [RegisterAttribute("1")]
public ulong T4;
    [RegisterAttribute("1")]
public ulong T5;
    [RegisterAttribute("1")]
public ulong T6;
    [RegisterAttribute("18")]
public ulong Pc;
    [FixedBufferAttribute("System.UInt64", "32")]
[RegisterAttribute("4")]
public <F>e__FixedBuffer F;
    [RegisterAttribute("4")]
public UInt32 Fcsr;
    public static int Size { get; }
    public static int get_Size();
}
public class Microsoft.Diagnostics.Runtime.RuntimeCallableWrapper : object {
    [CompilerGeneratedAttribute]
private ulong <Address>k__BackingField;
    [CompilerGeneratedAttribute]
private ulong <IUnknown>k__BackingField;
    [CompilerGeneratedAttribute]
private ulong <VTablePointer>k__BackingField;
    [CompilerGeneratedAttribute]
private int <RefCount>k__BackingField;
    [CompilerGeneratedAttribute]
private ulong <Object>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsDisconnected>k__BackingField;
    [CompilerGeneratedAttribute]
private ulong <CreatorThreadAddress>k__BackingField;
    [CompilerGeneratedAttribute]
private ulong <WinRTObject>k__BackingField;
    [CompilerGeneratedAttribute]
private ImmutableArray`1<ComInterfaceData> <Interfaces>k__BackingField;
    public ulong Address { get; }
    public ulong IUnknown { get; }
    public ulong VTablePointer { get; }
    public int RefCount { get; }
    public ulong Object { get; }
    public bool IsDisconnected { get; }
    public ulong CreatorThreadAddress { get; }
    public ulong WinRTObject { get; }
    public ImmutableArray`1<ComInterfaceData> Interfaces { get; }
    [NullableContextAttribute("1")]
internal RuntimeCallableWrapper(ClrRuntime runtime, RcwInfo& rcw);
    [CompilerGeneratedAttribute]
public sealed virtual ulong get_Address();
    [CompilerGeneratedAttribute]
public sealed virtual ulong get_IUnknown();
    [CompilerGeneratedAttribute]
public sealed virtual ulong get_VTablePointer();
    [CompilerGeneratedAttribute]
public sealed virtual int get_RefCount();
    [CompilerGeneratedAttribute]
public sealed virtual ulong get_Object();
    [CompilerGeneratedAttribute]
public sealed virtual bool get_IsDisconnected();
    [CompilerGeneratedAttribute]
public sealed virtual ulong get_CreatorThreadAddress();
    [CompilerGeneratedAttribute]
public sealed virtual ulong get_WinRTObject();
    [CompilerGeneratedAttribute]
public sealed virtual ImmutableArray`1<ComInterfaceData> get_Interfaces();
}
internal class Microsoft.Diagnostics.Runtime.SingleFileClrInfoProvider : DotNetClrInfoProvider {
    [NullableContextAttribute("1")]
public virtual ClrInfo ProvideClrInfoForModule(DataTarget dataTarget, ModuleInfo module);
}
[ExtensionAttribute]
internal static class Microsoft.Diagnostics.Runtime.SpanExtensions : object {
    [ExtensionAttribute]
public static ulong AsPointer(Span`1<byte> span);
    [ExtensionAttribute]
public static ulong AsPointer(Span`1<byte> span, int offset);
    [ExtensionAttribute]
public static ulong AsPointer(Span`1<byte> span, ulong offset);
    [ExtensionAttribute]
public static int AsInt32(Span`1<byte> span, int offset);
    [ExtensionAttribute]
public static UInt32 AsUInt32(Span`1<byte> span, int offset);
    [ExtensionAttribute]
public static UInt32 AsUInt32(Span`1<byte> span, ulong offset);
    [ExtensionAttribute]
public static UInt32 AsUInt32(Span`1<byte> span);
    [NullableContextAttribute("1")]
[ExtensionAttribute]
public static bool Contains(string source, string value, StringComparison comparisonType);
}
internal class Microsoft.Diagnostics.Runtime.SpecialDiagInfo : ValueType {
    [NullableAttribute("1")]
private static Byte[] SPECIAL_DIAGINFO_SIGNATURE;
    private static int SPECIAL_DIAGINFO_RUNTIME_BASEADDRESS;
    private static int SPECIAL_DIAGINFO_LATEST;
    private static ulong SpecialDiagInfoAddressMacOS64;
    private static ulong SpecialDiagInfoAddress64;
    private static ulong SpecialDiagInfoAddress32;
    private static int SignatureSize;
    [FixedBufferAttribute("System.Byte", "16")]
private <_signature>e__FixedBuffer _signature;
    private int _version;
    private ulong _exceptionRecordAddress;
    private ulong _runtimeBaseAddress;
    public bool IsValid { get; }
    public ulong ExceptionRecordAddress { get; }
    public ulong RuntimeBaseAddress { get; }
    private static SpecialDiagInfo();
    [NullableContextAttribute("1")]
public static bool TryReadSpecialDiagInfo(IDataReader reader, SpecialDiagInfo& info);
    public bool get_IsValid();
    public ulong get_ExceptionRecordAddress();
    public ulong get_RuntimeBaseAddress();
}
public enum Microsoft.Diagnostics.Runtime.StringCaching : Enum {
    public int value__;
    public static StringCaching None;
    public static StringCaching Cache;
    public static StringCaching Intern;
}
public enum Microsoft.Diagnostics.Runtime.SymbolProperties : Enum {
    public int value__;
    public static SymbolProperties Self;
    public static SymbolProperties Coreclr;
}
public class Microsoft.Diagnostics.Runtime.SyncBlock : object {
    [CompilerGeneratedAttribute]
private ulong <Object>k__BackingField;
    [CompilerGeneratedAttribute]
private int <Index>k__BackingField;
    public ulong Object { get; }
    public int Index { get; }
    public SyncBlockComFlags ComFlags { get; }
    public bool IsComCallWrapper { get; }
    public bool IsRuntimeCallWrapper { get; }
    public bool IsComClassFactory { get; }
    public bool IsMonitorHeld { get; }
    public ulong HoldingThreadAddress { get; }
    public int RecursionCount { get; }
    public int WaitingThreadCount { get; }
    public SyncBlock(ulong obj, int index);
    [CompilerGeneratedAttribute]
public ulong get_Object();
    [CompilerGeneratedAttribute]
public int get_Index();
    public virtual SyncBlockComFlags get_ComFlags();
    public virtual bool get_IsComCallWrapper();
    public virtual bool get_IsRuntimeCallWrapper();
    public virtual bool get_IsComClassFactory();
    public virtual bool get_IsMonitorHeld();
    public virtual ulong get_HoldingThreadAddress();
    public virtual int get_RecursionCount();
    public virtual int get_WaitingThreadCount();
}
[FlagsAttribute]
public enum Microsoft.Diagnostics.Runtime.SyncBlockComFlags : Enum {
    public byte value__;
    public static SyncBlockComFlags None;
    public static SyncBlockComFlags ComCallableWrapper;
    public static SyncBlockComFlags RuntimeCallableWrapper;
    public static SyncBlockComFlags ComClassFactory;
}
internal enum Microsoft.Diagnostics.Runtime.ThreadAccess : Enum {
    public int value__;
    public static ThreadAccess SUSPEND_RESUME;
    public static ThreadAccess THREAD_ALL_ACCESS;
}
[ExtensionAttribute]
internal static class Microsoft.Diagnostics.Runtime.UnixDataReaderExtensions : object {
    [NullableContextAttribute("1")]
[ExtensionAttribute]
internal static bool GetVersionInfo(IDataReader dataReader, ulong baseAddress, ElfFile loadedFile, Version& version);
    [NullableContextAttribute("1")]
[ExtensionAttribute]
internal static bool GetVersionInfo(IDataReader dataReader, ulong startAddress, ulong size, Version& version);
    private static Version ParseAsciiVersion(ReadOnlySpan`1<byte> span);
}
internal class Microsoft.Diagnostics.Runtime.Utilities.arm_thread_state64_t : ValueType {
    [FixedBufferAttribute("System.UInt64", "29")]
public <__x>e__FixedBuffer __x;
    public ulong __fp;
    public ulong __lr;
    public ulong __sp;
    public ulong __pc;
    public UInt32 __cpsr;
    public UInt32 __pad;
    public bool CopyContext(Span`1<byte> context);
}
public class Microsoft.Diagnostics.Runtime.Utilities.CallableCOMWrapper : COMHelper {
    private bool _disposed;
    [CompilerGeneratedAttribute]
private IntPtr <Self>k__BackingField;
    private IUnknownVTable* _unknownVTable;
    [NullableAttribute("2")]
[CompilerGeneratedAttribute]
private RefCountedFreeLibrary <Library>k__BackingField;
    protected IntPtr Self { get; }
    [NullableAttribute("2")]
public RefCountedFreeLibrary Library { get; }
    protected Void* _vtable { get; }
    [NullableContextAttribute("1")]
protected CallableCOMWrapper(CallableCOMWrapper toClone);
    [NullableContextAttribute("2")]
protected CallableCOMWrapper(RefCountedFreeLibrary library, Guid& desiredInterface, IntPtr pUnknown);
    [CompilerGeneratedAttribute]
protected IntPtr get_Self();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public RefCountedFreeLibrary get_Library();
    protected Void* get__vtable();
    public int AddRef();
    public void SuppressRelease();
    public int Release();
    public IntPtr QueryInterface(Guid& riid);
    protected virtual void Dispose(bool disposing);
    protected virtual override void Finalize();
    public sealed virtual void Dispose();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Microsoft.Diagnostics.Runtime.Utilities.COMCallableIUnknown : COMHelper {
    private GCHandle _handle;
    private int _refCount;
    private Dictionary`2<Guid, IntPtr> _interfaces;
    private List`1<Delegate> _delegates;
    [CompilerGeneratedAttribute]
private IntPtr <IUnknownObject>k__BackingField;
    public IntPtr IUnknownObject { get; }
    public IUnknownVTable IUnknown { get; }
    [CompilerGeneratedAttribute]
public IntPtr get_IUnknownObject();
    public IUnknownVTable get_IUnknown();
    public int AddRef();
    public int Release();
    [RequiresDynamicCodeAttribute("This class uses reflection over delegates to generate code.  If used for NativeAOT, consider building a VTable with [UnmanagedCallersOnly] and native delegates instead.")]
public VTableBuilder AddInterface(Guid guid, bool validate);
    internal void RegisterInterface(Guid guid, IntPtr clsPtr, List`1<Delegate> keepAlive);
    private int QueryInterfaceImpl(IntPtr _, Guid& guid, IntPtr& ptr);
    private int ReleaseImpl(IntPtr self);
    private int AddRefImpl(IntPtr self);
    protected virtual void Destroy();
}
public abstract class Microsoft.Diagnostics.Runtime.Utilities.COMHelper : object {
    protected static Guid IUnknownGuid;
    private static COMHelper();
    public static int Release(IntPtr pUnk);
    public static HResult QueryInterface(IntPtr pUnk, Guid& riid, IntPtr& result);
}
internal class Microsoft.Diagnostics.Runtime.Utilities.CvInfoPdb70 : ValueType {
    public static int PDB70CvSignature;
    public int CvSignature;
    public Guid Signature;
    public int Age;
    [FixedBufferAttribute("System.Byte", "1")]
public <bytePdbFileName>e__FixedBuffer bytePdbFileName;
    [NullableAttribute("1")]
public string PdbFileName { get; }
    [NullableContextAttribute("1")]
public string get_PdbFileName();
}
[IsReadOnlyAttribute]
internal class Microsoft.Diagnostics.Runtime.Utilities.ElfAuxv32 : ValueType {
    public UInt32 Type;
    public UInt32 Value;
}
[IsReadOnlyAttribute]
internal class Microsoft.Diagnostics.Runtime.Utilities.ElfAuxv64 : ValueType {
    public ulong Type;
    public ulong Value;
}
internal enum Microsoft.Diagnostics.Runtime.Utilities.ElfAuxvType : Enum {
    public int value__;
    public static ElfAuxvType Null;
    public static ElfAuxvType Base;
}
internal enum Microsoft.Diagnostics.Runtime.Utilities.ElfClass : Enum {
    public byte value__;
    public static ElfClass None;
    public static ElfClass Class32;
    public static ElfClass Class64;
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.Diagnostics.Runtime.Utilities.ElfCoreFile : object {
    private Stream _stream;
    private bool _leaveOpen;
    private Reader _reader;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private ImmutableDictionary`2<ulong, ElfLoadedImage> _loadedImages;
    private Dictionary`2<ulong, ulong> _auxvEntries;
    [NullableAttribute("2")]
private ElfVirtualAddressSpace _virtualAddressSpace;
    [CompilerGeneratedAttribute]
private ElfFile <ElfFile>k__BackingField;
    public ElfFile ElfFile { get; }
    public ImmutableDictionary`2<ulong, ElfLoadedImage> LoadedImages { get; }
    public ElfCoreFile(string coredump);
    public ElfCoreFile(Stream stream, bool leaveOpen);
    [CompilerGeneratedAttribute]
public ElfFile get_ElfFile();
    public IEnumerable`1<IElfPRStatus> EnumeratePRStatus();
    public ulong GetAuxvValue(ElfAuxvType type);
    public ImmutableDictionary`2<ulong, ElfLoadedImage> get_LoadedImages();
    [NullableContextAttribute("0")]
public int ReadMemory(ulong address, Span`1<byte> buffer);
    private IEnumerable`1<ElfNote> GetNotes(ElfNoteType type);
    private void LoadAuxvTable();
    private ImmutableDictionary`2<ulong, ElfLoadedImage> LoadFileTable();
    public sealed virtual void Dispose();
}
internal enum Microsoft.Diagnostics.Runtime.Utilities.ElfData : Enum {
    public byte value__;
    public static ElfData None;
    public static ElfData LittleEndian;
    public static ElfData BigEndian;
}
internal class Microsoft.Diagnostics.Runtime.Utilities.ElfDynamicEntry32 : ValueType {
    public int Tag;
    public UInt32 Ptr;
}
internal class Microsoft.Diagnostics.Runtime.Utilities.ElfDynamicEntry64 : ValueType {
    public long Tag;
    public ulong Ptr;
}
internal enum Microsoft.Diagnostics.Runtime.Utilities.ElfDynamicEntryTag : Enum {
    public int value__;
    public static ElfDynamicEntryTag Null;
    public static ElfDynamicEntryTag Hash;
    public static ElfDynamicEntryTag StrTab;
    public static ElfDynamicEntryTag SymTab;
    public static ElfDynamicEntryTag StrSz;
    public static ElfDynamicEntryTag SymEnt;
    public static ElfDynamicEntryTag GnuHash;
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
internal class Microsoft.Diagnostics.Runtime.Utilities.ElfDynamicSection : object {
    [CompilerGeneratedAttribute]
private ulong <GnuHashTableVA>k__BackingField;
    [CompilerGeneratedAttribute]
private ElfSymbolGnuHash <GnuHash>k__BackingField;
    [CompilerGeneratedAttribute]
private ulong <StringTableVA>k__BackingField;
    [CompilerGeneratedAttribute]
private ulong <StringTableSize>k__BackingField;
    [CompilerGeneratedAttribute]
private ElfStringTable <StringTable>k__BackingField;
    [CompilerGeneratedAttribute]
private ulong <SymbolTableVA>k__BackingField;
    [CompilerGeneratedAttribute]
private ElfSymbolTable <SymbolTable>k__BackingField;
    public ulong GnuHashTableVA { get; }
    public ElfSymbolGnuHash GnuHash { get; }
    public ulong StringTableVA { get; }
    public ulong StringTableSize { get; }
    public ElfStringTable StringTable { get; }
    public ulong SymbolTableVA { get; }
    public ElfSymbolTable SymbolTable { get; }
    [NullableContextAttribute("1")]
public ElfDynamicSection(Reader reader, bool is64Bit, ulong address, ulong size);
    [CompilerGeneratedAttribute]
public ulong get_GnuHashTableVA();
    [CompilerGeneratedAttribute]
public ElfSymbolGnuHash get_GnuHash();
    [CompilerGeneratedAttribute]
public ulong get_StringTableVA();
    [CompilerGeneratedAttribute]
public ulong get_StringTableSize();
    [CompilerGeneratedAttribute]
public ElfStringTable get_StringTable();
    [CompilerGeneratedAttribute]
public ulong get_SymbolTableVA();
    [CompilerGeneratedAttribute]
public ElfSymbolTable get_SymbolTable();
    [NullableContextAttribute("1")]
public bool TryLookupSymbol(string symbolName, ElfSymbol& symbol);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.Diagnostics.Runtime.Utilities.ElfFile : object {
    private ulong _position;
    private bool _virtual;
    [NullableAttribute("2")]
private Stream _stream;
    private bool _leaveOpen;
    [NullableAttribute("2")]
private Reader _virtualAddressReader;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private ImmutableArray`1<ElfNote> _notes;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private ImmutableArray`1<ElfProgramHeader> _programHeaders;
    [NullableAttribute("0")]
private ImmutableArray`1<byte> _buildId;
    [NullableAttribute("2")]
private ElfDynamicSection _dynamicSection;
    [CompilerGeneratedAttribute]
private Reader <Reader>k__BackingField;
    [CompilerGeneratedAttribute]
private IElfHeader <Header>k__BackingField;
    internal Reader Reader { get; }
    public IElfHeader Header { get; }
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ImmutableArray`1<ElfNote> Notes { get; }
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ImmutableArray`1<ElfProgramHeader> ProgramHeaders { get; }
    internal Reader VirtualAddressReader { get; }
    [NullableAttribute("2")]
internal ElfDynamicSection DynamicSection { get; }
    [NullableAttribute("0")]
public ImmutableArray`1<byte> BuildId { get; }
    public ElfFile(string filename);
    public ElfFile(Stream stream, bool leaveOpen);
    public ElfFile(Stream stream, ulong position, bool leaveOpen, bool isVirtual);
    public ElfFile(IDataReader reader, ulong position);
    internal ElfFile(Reader reader, ulong position, bool isVirtual);
    internal ElfFile(IElfHeader header, Reader reader, ulong position, bool isVirtual);
    [CompilerGeneratedAttribute]
internal Reader get_Reader();
    [CompilerGeneratedAttribute]
public IElfHeader get_Header();
    public ImmutableArray`1<ElfNote> get_Notes();
    public ImmutableArray`1<ElfProgramHeader> get_ProgramHeaders();
    internal Reader get_VirtualAddressReader();
    public bool TryGetExportSymbol(string symbolName, UInt64& offset);
    [NullableContextAttribute("2")]
internal ElfDynamicSection get_DynamicSection();
    [NullableContextAttribute("0")]
public ImmutableArray`1<byte> get_BuildId();
    private void CreateVirtualAddressReader();
    private void LoadNotes();
    private void LoadProgramHeaders();
    public sealed virtual void Dispose();
}
internal class Microsoft.Diagnostics.Runtime.Utilities.ElfFileTableEntryPointers32 : ValueType {
    public UInt32 Start;
    public UInt32 Stop;
    public UInt32 PageOffset;
}
internal class Microsoft.Diagnostics.Runtime.Utilities.ElfFileTableEntryPointers64 : ValueType {
    public ulong Start;
    public ulong Stop;
    public ulong PageOffset;
}
internal class Microsoft.Diagnostics.Runtime.Utilities.ElfFileTableHeader32 : ValueType {
    public UInt32 EntryCount;
    public UInt32 PageSize;
}
internal class Microsoft.Diagnostics.Runtime.Utilities.ElfFileTableHeader64 : ValueType {
    public ulong EntryCount;
    public ulong PageSize;
}
[IsReadOnlyAttribute]
internal class Microsoft.Diagnostics.Runtime.Utilities.ElfHeader32 : ValueType {
    private ElfHeaderCommon _common;
    private UInt32 _entry;
    private UInt32 _programHeaderOffset;
    private UInt32 _sectionHeaderOffset;
    private UInt32 _flags;
    private ushort _ehSize;
    private ushort _programHeaderEntrySize;
    private ushort _programHeaderCount;
    private ushort _sectionHeaderEntrySize;
    private ushort _sectionHeaderCount;
    private ushort _sectionHeaderStringIndex;
    public bool Is64Bit { get; }
    public bool IsValid { get; }
    public ElfHeaderType Type { get; }
    public ElfMachine Architecture { get; }
    public ElfClass Class { get; }
    public ElfData Data { get; }
    public ulong ProgramHeaderOffset { get; }
    public ulong SectionHeaderOffset { get; }
    public ushort ProgramHeaderEntrySize { get; }
    public ushort ProgramHeaderCount { get; }
    public ushort SectionHeaderEntrySize { get; }
    public ushort SectionHeaderCount { get; }
    public ushort SectionHeaderStringIndex { get; }
    public sealed virtual bool get_Is64Bit();
    public sealed virtual bool get_IsValid();
    public sealed virtual ElfHeaderType get_Type();
    public sealed virtual ElfMachine get_Architecture();
    public ElfClass get_Class();
    public ElfData get_Data();
    public sealed virtual ulong get_ProgramHeaderOffset();
    public sealed virtual ulong get_SectionHeaderOffset();
    public sealed virtual ushort get_ProgramHeaderEntrySize();
    public sealed virtual ushort get_ProgramHeaderCount();
    public sealed virtual ushort get_SectionHeaderEntrySize();
    public sealed virtual ushort get_SectionHeaderCount();
    public sealed virtual ushort get_SectionHeaderStringIndex();
}
[IsReadOnlyAttribute]
internal class Microsoft.Diagnostics.Runtime.Utilities.ElfHeader64 : ValueType {
    private ElfHeaderCommon _common;
    private ulong _entry;
    private ulong _programHeaderOffset;
    private ulong _sectionHeaderOffset;
    private UInt32 _flags;
    private ushort _ehSize;
    private ushort _programHeaderEntrySize;
    private ushort _programHeaderCount;
    private ushort _sectionHeaderEntrySize;
    private ushort _sectionHeaderCount;
    private ushort _sectionHeaderStringIndex;
    public bool Is64Bit { get; }
    public bool IsValid { get; }
    public ElfHeaderType Type { get; }
    public ElfMachine Architecture { get; }
    public ulong ProgramHeaderOffset { get; }
    public ulong SectionHeaderOffset { get; }
    public ushort ProgramHeaderEntrySize { get; }
    public ushort ProgramHeaderCount { get; }
    public ushort SectionHeaderEntrySize { get; }
    public ushort SectionHeaderCount { get; }
    public ushort SectionHeaderStringIndex { get; }
    public sealed virtual bool get_Is64Bit();
    public sealed virtual bool get_IsValid();
    public sealed virtual ElfHeaderType get_Type();
    public sealed virtual ElfMachine get_Architecture();
    public sealed virtual ulong get_ProgramHeaderOffset();
    public sealed virtual ulong get_SectionHeaderOffset();
    public sealed virtual ushort get_ProgramHeaderEntrySize();
    public sealed virtual ushort get_ProgramHeaderCount();
    public sealed virtual ushort get_SectionHeaderEntrySize();
    public sealed virtual ushort get_SectionHeaderCount();
    public sealed virtual ushort get_SectionHeaderStringIndex();
}
[IsReadOnlyAttribute]
internal class Microsoft.Diagnostics.Runtime.Utilities.ElfHeaderCommon : ValueType {
    private static int EI_NIDENT;
    internal static UInt32 Magic;
    private UInt32 _magic;
    private byte _class;
    private byte _data;
    private byte _unused0;
    private byte _unused1;
    private UInt32 _unused2;
    private UInt32 _unused3;
    private ElfHeaderType _type;
    private ushort _machine;
    private UInt32 _version;
    public bool IsValid { get; }
    public ElfHeaderType Type { get; }
    public ElfMachine Architecture { get; }
    public ElfClass Class { get; }
    public ElfData Data { get; }
    public bool get_IsValid();
    public ElfHeaderType get_Type();
    public ElfMachine get_Architecture();
    public ElfClass get_Class();
    public ElfData get_Data();
    [NullableContextAttribute("1")]
public IElfHeader GetHeader(Reader reader, ulong position);
}
internal enum Microsoft.Diagnostics.Runtime.Utilities.ElfHeaderType : Enum {
    public ushort value__;
    public static ElfHeaderType Relocatable;
    public static ElfHeaderType Executable;
    public static ElfHeaderType Shared;
    public static ElfHeaderType Core;
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.Diagnostics.Runtime.Utilities.ElfLoadedImage : object {
    private Reader _vaReader;
    private bool _is64bit;
    private ulong _baseAddress;
    private ulong _minimumPointer;
    private ulong _end;
    [CompilerGeneratedAttribute]
private string <FileName>k__BackingField;
    public string FileName { get; }
    public ulong BaseAddress { get; }
    public ulong Size { get; }
    internal ElfLoadedImage(Reader virtualAddressReader, bool is64bit, string path);
    [CompilerGeneratedAttribute]
public string get_FileName();
    public ulong get_BaseAddress();
    public ulong get_Size();
    [NullableContextAttribute("2")]
public ElfFile Open();
    internal ReaderStream AsStream();
    internal void AddTableEntryPointers(ElfFileTableEntryPointers64 pointers);
    public virtual string ToString();
}
internal enum Microsoft.Diagnostics.Runtime.Utilities.ElfMachine : Enum {
    public ushort value__;
    public static ElfMachine EM_NONE;
    public static ElfMachine EM_386;
    public static ElfMachine EM_PARISC;
    public static ElfMachine EM_SPARC32PLUS;
    public static ElfMachine EM_PPC;
    public static ElfMachine EM_PPC64;
    public static ElfMachine EM_SPU;
    public static ElfMachine EM_ARM;
    public static ElfMachine EM_SH;
    public static ElfMachine EM_SPARCV9;
    public static ElfMachine EM_IA_64;
    public static ElfMachine EM_X86_64;
    public static ElfMachine EM_S390;
    public static ElfMachine EM_CRIS;
    public static ElfMachine EM_V850;
    public static ElfMachine EM_M32R;
    public static ElfMachine EM_H8_300;
    public static ElfMachine EM_MN10300;
    public static ElfMachine EM_BLACKFIN;
    public static ElfMachine EM_AARCH64;
    public static ElfMachine EM_RISCV;
    public static ElfMachine EM_LOONGARCH;
    public static ElfMachine EM_FRV;
    public static ElfMachine EM_AVR32;
}
internal class Microsoft.Diagnostics.Runtime.Utilities.ElfNote : object {
    [NullableAttribute("1")]
private Reader _reader;
    private ulong _position;
    [NullableAttribute("2")]
private string _name;
    [CompilerGeneratedAttribute]
private ElfNoteHeader <Header>k__BackingField;
    internal ElfNoteHeader Header { get; }
    public int ContentSize { get; }
    public ElfNoteType Type { get; }
    [NullableAttribute("1")]
public string Name { get; }
    internal ulong TotalSize { get; }
    private static UInt32 HeaderSize { get; }
    [NullableContextAttribute("1")]
internal ElfNote(Reader reader, ulong position);
    [CompilerGeneratedAttribute]
internal ElfNoteHeader get_Header();
    public int get_ContentSize();
    public ElfNoteType get_Type();
    [NullableContextAttribute("1")]
public string get_Name();
    internal ulong get_TotalSize();
    private static UInt32 get_HeaderSize();
    public int ReadContents(ulong position, Span`1<byte> buffer);
    internal T ReadContents(UInt64& position);
    public T ReadContents(ulong position);
    private static UInt32 Align4(UInt32 x);
}
internal class Microsoft.Diagnostics.Runtime.Utilities.ElfNoteHeader : ValueType {
    public UInt32 NameSize;
    public UInt32 ContentSize;
    public ElfNoteType Type;
}
internal enum Microsoft.Diagnostics.Runtime.Utilities.ElfNoteType : Enum {
    public UInt32 value__;
    public static ElfNoteType PrpsStatus;
    public static ElfNoteType PrpsFpreg;
    public static ElfNoteType PrpsInfo;
    public static ElfNoteType TASKSTRUCT;
    public static ElfNoteType Aux;
    public static ElfNoteType File;
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.Diagnostics.Runtime.Utilities.ElfProgramHeader : object {
    private ElfProgramHeaderAttributes _attributes;
    [CompilerGeneratedAttribute]
private IAddressSpace <AddressSpace>k__BackingField;
    [CompilerGeneratedAttribute]
private ElfProgramHeaderType <Type>k__BackingField;
    [CompilerGeneratedAttribute]
private ulong <VirtualAddress>k__BackingField;
    [CompilerGeneratedAttribute]
private ulong <VirtualSize>k__BackingField;
    [CompilerGeneratedAttribute]
private ulong <FileOffset>k__BackingField;
    [CompilerGeneratedAttribute]
private ulong <FileSize>k__BackingField;
    internal IAddressSpace AddressSpace { get; }
    public ElfProgramHeaderType Type { get; }
    public ulong VirtualAddress { get; }
    public ulong VirtualSize { get; }
    public ulong FileOffset { get; }
    public ulong FileSize { get; }
    public bool IsExecutable { get; }
    public bool IsWritable { get; }
    internal ElfProgramHeader(Reader reader, bool is64bit, ulong headerPositon, long loadBias, bool isVirtual);
    [CompilerGeneratedAttribute]
internal IAddressSpace get_AddressSpace();
    [CompilerGeneratedAttribute]
public ElfProgramHeaderType get_Type();
    [CompilerGeneratedAttribute]
public ulong get_VirtualAddress();
    [CompilerGeneratedAttribute]
public ulong get_VirtualSize();
    [CompilerGeneratedAttribute]
public ulong get_FileOffset();
    [CompilerGeneratedAttribute]
public ulong get_FileSize();
    public bool get_IsExecutable();
    public bool get_IsWritable();
}
internal class Microsoft.Diagnostics.Runtime.Utilities.ElfProgramHeader32 : ValueType {
    public ElfProgramHeaderType Type;
    public UInt32 FileOffset;
    public UInt32 VirtualAddress;
    public UInt32 PhysicalAddress;
    public UInt32 FileSize;
    public UInt32 VirtualSize;
    public UInt32 Flags;
    public UInt32 Alignment;
}
internal class Microsoft.Diagnostics.Runtime.Utilities.ElfProgramHeader64 : ValueType {
    public ElfProgramHeaderType Type;
    public UInt32 Flags;
    public ulong FileOffset;
    public ulong VirtualAddress;
    public ulong PhysicalAddress;
    public ulong FileSize;
    public ulong VirtualSize;
    public ulong Alignment;
}
[FlagsAttribute]
internal enum Microsoft.Diagnostics.Runtime.Utilities.ElfProgramHeaderAttributes : Enum {
    public UInt32 value__;
    public static ElfProgramHeaderAttributes Executable;
    public static ElfProgramHeaderAttributes Writable;
    public static ElfProgramHeaderAttributes Readable;
    public static ElfProgramHeaderAttributes OSMask;
    public static ElfProgramHeaderAttributes ProcessorMask;
}
internal enum Microsoft.Diagnostics.Runtime.Utilities.ElfProgramHeaderType : Enum {
    public UInt32 value__;
    public static ElfProgramHeaderType Null;
    public static ElfProgramHeaderType Load;
    public static ElfProgramHeaderType Dynamic;
    public static ElfProgramHeaderType Interp;
    public static ElfProgramHeaderType Note;
    public static ElfProgramHeaderType Shlib;
    public static ElfProgramHeaderType Phdr;
}
internal class Microsoft.Diagnostics.Runtime.Utilities.ElfPRStatusArm : ValueType {
    public ElfSignalInfo SignalInfo;
    public short CurrentSignal;
    private ushort Padding;
    public UInt32 SignalsPending;
    public UInt32 SignalsHeld;
    public UInt32 Pid;
    public UInt32 PPid;
    public UInt32 PGrp;
    public UInt32 Sid;
    public TimeVal32 UserTime;
    public TimeVal32 SystemTime;
    public TimeVal32 CUserTime;
    public TimeVal32 CSystemTime;
    public RegSetArm RegisterSet;
    public int FPValid;
    public UInt32 ProcessId { get; }
    public UInt32 ThreadId { get; }
    public sealed virtual UInt32 get_ProcessId();
    public sealed virtual UInt32 get_ThreadId();
    public sealed virtual bool CopyRegistersAsContext(Span`1<byte> context);
}
internal class Microsoft.Diagnostics.Runtime.Utilities.ElfPRStatusArm64 : ValueType {
    public ElfSignalInfo SignalInfo;
    public short CurrentSignal;
    private ushort Padding;
    public ulong SignalsPending;
    public ulong SignalsHeld;
    public UInt32 Pid;
    public UInt32 PPid;
    public UInt32 PGrp;
    public UInt32 Sid;
    public TimeVal64 UserTime;
    public TimeVal64 SystemTime;
    public TimeVal64 CUserTime;
    public TimeVal64 CSystemTime;
    public RegSetArm64 RegisterSet;
    public int FPValid;
    public UInt32 ProcessId { get; }
    public UInt32 ThreadId { get; }
    public sealed virtual UInt32 get_ProcessId();
    public sealed virtual UInt32 get_ThreadId();
    public sealed virtual bool CopyRegistersAsContext(Span`1<byte> context);
}
internal class Microsoft.Diagnostics.Runtime.Utilities.ElfPRStatusLoongArch64 : ValueType {
    public ElfSignalInfo SignalInfo;
    public short CurrentSignal;
    private ushort Padding;
    public ulong SignalsPending;
    public ulong SignalsHeld;
    public UInt32 Pid;
    public UInt32 PPid;
    public UInt32 PGrp;
    public UInt32 Sid;
    public TimeVal64 UserTime;
    public TimeVal64 SystemTime;
    public TimeVal64 CUserTime;
    public TimeVal64 CSystemTime;
    public RegSetLoongArch64 RegisterSet;
    public int FPValid;
    public UInt32 ProcessId { get; }
    public UInt32 ThreadId { get; }
    public sealed virtual UInt32 get_ProcessId();
    public sealed virtual UInt32 get_ThreadId();
    public sealed virtual bool CopyRegistersAsContext(Span`1<byte> context);
}
internal class Microsoft.Diagnostics.Runtime.Utilities.ElfPRStatusRiscV64 : ValueType {
    public ElfSignalInfo SignalInfo;
    public short CurrentSignal;
    private ushort Padding;
    public ulong SignalsPending;
    public ulong SignalsHeld;
    public UInt32 Pid;
    public UInt32 PPid;
    public UInt32 PGrp;
    public UInt32 Sid;
    public TimeVal64 UserTime;
    public TimeVal64 SystemTime;
    public TimeVal64 CUserTime;
    public TimeVal64 CSystemTime;
    public RegSetRiscV64 RegisterSet;
    public int FPValid;
    public UInt32 ProcessId { get; }
    public UInt32 ThreadId { get; }
    public sealed virtual UInt32 get_ProcessId();
    public sealed virtual UInt32 get_ThreadId();
    public sealed virtual bool CopyRegistersAsContext(Span`1<byte> context);
}
internal class Microsoft.Diagnostics.Runtime.Utilities.ElfPRStatusX64 : ValueType {
    public ElfSignalInfo SignalInfo;
    public short CurrentSignal;
    private ushort Padding;
    public ulong SignalsPending;
    public ulong SignalsHeld;
    public UInt32 Pid;
    public UInt32 PPid;
    public UInt32 PGrp;
    public UInt32 Sid;
    public TimeVal64 UserTime;
    public TimeVal64 SystemTime;
    public TimeVal64 CUserTime;
    public TimeVal64 CSystemTime;
    public RegSetX64 RegisterSet;
    public int FPValid;
    public UInt32 ProcessId { get; }
    public UInt32 ThreadId { get; }
    public sealed virtual UInt32 get_ProcessId();
    public sealed virtual UInt32 get_ThreadId();
    public sealed virtual bool CopyRegistersAsContext(Span`1<byte> context);
}
internal class Microsoft.Diagnostics.Runtime.Utilities.ElfPRStatusX86 : ValueType {
    public ElfSignalInfo SignalInfo;
    public short CurrentSignal;
    private ushort Padding;
    public UInt32 SignalsPending;
    public UInt32 SignalsHeld;
    public UInt32 Pid;
    public UInt32 PPid;
    public UInt32 PGrp;
    public UInt32 Sid;
    public TimeVal32 UserTime;
    public TimeVal32 SystemTime;
    public TimeVal32 CUserTime;
    public TimeVal32 CSystemTime;
    public RegSetX86 RegisterSet;
    public int FPValid;
    public UInt32 ProcessId { get; }
    public UInt32 ThreadId { get; }
    public sealed virtual UInt32 get_ProcessId();
    public sealed virtual UInt32 get_ThreadId();
    public sealed virtual bool CopyRegistersAsContext(Span`1<byte> context);
}
internal class Microsoft.Diagnostics.Runtime.Utilities.ElfSectionHeader : object {
    [CompilerGeneratedAttribute]
private ElfSectionHeaderType <Type>k__BackingField;
    [CompilerGeneratedAttribute]
private UInt32 <NameIndex>k__BackingField;
    [CompilerGeneratedAttribute]
private ulong <VirtualAddress>k__BackingField;
    [CompilerGeneratedAttribute]
private ulong <FileOffset>k__BackingField;
    [CompilerGeneratedAttribute]
private ulong <FileSize>k__BackingField;
    public ElfSectionHeaderType Type { get; }
    public UInt32 NameIndex { get; }
    public ulong VirtualAddress { get; }
    public ulong FileOffset { get; }
    public ulong FileSize { get; }
    [NullableContextAttribute("1")]
public ElfSectionHeader(Reader reader, bool is64bit, ulong headerPositon);
    [CompilerGeneratedAttribute]
public ElfSectionHeaderType get_Type();
    [CompilerGeneratedAttribute]
public UInt32 get_NameIndex();
    [CompilerGeneratedAttribute]
public ulong get_VirtualAddress();
    [CompilerGeneratedAttribute]
public ulong get_FileOffset();
    [CompilerGeneratedAttribute]
public ulong get_FileSize();
}
internal class Microsoft.Diagnostics.Runtime.Utilities.ElfSectionHeader32 : ValueType {
    public UInt32 NameIndex;
    public ElfSectionHeaderType Type;
    public UInt32 Flags;
    public UInt32 VirtualAddress;
    public UInt32 FileOffset;
    public UInt32 FileSize;
    public UInt32 Link;
    public UInt32 Info;
    public UInt32 Alignment;
    public UInt32 EntrySize;
}
internal class Microsoft.Diagnostics.Runtime.Utilities.ElfSectionHeader64 : ValueType {
    public UInt32 NameIndex;
    public ElfSectionHeaderType Type;
    public ulong Flags;
    public ulong VirtualAddress;
    public ulong FileOffset;
    public ulong FileSize;
    public UInt32 Link;
    public UInt32 Info;
    public ulong Alignment;
    public ulong EntrySize;
}
internal enum Microsoft.Diagnostics.Runtime.Utilities.ElfSectionHeaderType : Enum {
    public UInt32 value__;
    public static ElfSectionHeaderType Null;
    public static ElfSectionHeaderType ProgBits;
    public static ElfSectionHeaderType SymTab;
    public static ElfSectionHeaderType StrTab;
    public static ElfSectionHeaderType Rela;
    public static ElfSectionHeaderType Hash;
    public static ElfSectionHeaderType Dynamic;
    public static ElfSectionHeaderType Note;
    public static ElfSectionHeaderType NoBits;
    public static ElfSectionHeaderType Rel;
    public static ElfSectionHeaderType ShLib;
    public static ElfSectionHeaderType DynSym;
    public static ElfSectionHeaderType InitArray;
    public static ElfSectionHeaderType FiniArray;
    public static ElfSectionHeaderType PreInitArray;
    public static ElfSectionHeaderType Group;
    public static ElfSectionHeaderType SymTabIndexes;
    public static ElfSectionHeaderType Num;
    public static ElfSectionHeaderType GnuAttributes;
    public static ElfSectionHeaderType GnuHash;
    public static ElfSectionHeaderType GnuLibList;
    public static ElfSectionHeaderType CheckSum;
    public static ElfSectionHeaderType GnuVerDef;
    public static ElfSectionHeaderType GnuVerNeed;
    public static ElfSectionHeaderType GnuVerSym;
}
internal class Microsoft.Diagnostics.Runtime.Utilities.ElfSignalInfo : ValueType {
    public int Number;
    public int Code;
    public int Errno;
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.Diagnostics.Runtime.Utilities.ElfStringTable : object {
    private Reader _reader;
    public ElfStringTable(Reader reader, ulong address, ulong size);
    public string GetStringAtIndex(UInt32 index);
    internal static ElfStringTable Create(Reader reader, ulong stringTableVA, ulong stringTableSize);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.Diagnostics.Runtime.Utilities.ElfSymbol : object {
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    [CompilerGeneratedAttribute]
private ElfSymbolBind <Bind>k__BackingField;
    [CompilerGeneratedAttribute]
private ElfSymbolType <Type>k__BackingField;
    [CompilerGeneratedAttribute]
private long <Value>k__BackingField;
    [CompilerGeneratedAttribute]
private long <Size>k__BackingField;
    public string Name { get; }
    public ElfSymbolBind Bind { get; }
    public ElfSymbolType Type { get; }
    public long Value { get; }
    public long Size { get; }
    public ElfSymbol(string name, ElfSymbolBind bind, ElfSymbolType type, long value, long size);
    [CompilerGeneratedAttribute]
public string get_Name();
    [CompilerGeneratedAttribute]
public ElfSymbolBind get_Bind();
    [CompilerGeneratedAttribute]
public ElfSymbolType get_Type();
    [CompilerGeneratedAttribute]
public long get_Value();
    [CompilerGeneratedAttribute]
public long get_Size();
}
internal class Microsoft.Diagnostics.Runtime.Utilities.ElfSymbol32 : ValueType {
    public UInt32 Name;
    public ulong Value;
    public UInt32 Size;
    public byte Info;
    public byte Other;
    public ushort Shndx;
}
internal class Microsoft.Diagnostics.Runtime.Utilities.ElfSymbol64 : ValueType {
    public UInt32 Name;
    public byte Info;
    public byte Other;
    public ushort Shndx;
    public UInt32 Value;
    public ulong Size;
}
internal enum Microsoft.Diagnostics.Runtime.Utilities.ElfSymbolBind : Enum {
    public byte value__;
    public static ElfSymbolBind Local;
    public static ElfSymbolBind Global;
    public static ElfSymbolBind Weak;
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.Diagnostics.Runtime.Utilities.ElfSymbolGnuHash : object {
    private Reader _reader;
    private ulong _chainsAddress;
    [CompilerGeneratedAttribute]
private int <BucketCount>k__BackingField;
    [CompilerGeneratedAttribute]
private int <SymbolOffset>k__BackingField;
    [CompilerGeneratedAttribute]
private int <BloomSize>k__BackingField;
    [CompilerGeneratedAttribute]
private int <BloomShift>k__BackingField;
    [CompilerGeneratedAttribute]
private Int32[] <Buckets>k__BackingField;
    public int BucketCount { get; }
    public int SymbolOffset { get; }
    public int BloomSize { get; }
    public int BloomShift { get; }
    public Int32[] Buckets { get; }
    private ElfSymbolGnuHash(Reader reader, bool is64Bit, ulong address);
    internal static ElfSymbolGnuHash Create(Reader reader, bool is64Bit, ulong address);
    [CompilerGeneratedAttribute]
public int get_BucketCount();
    [CompilerGeneratedAttribute]
public int get_SymbolOffset();
    [CompilerGeneratedAttribute]
public int get_BloomSize();
    [CompilerGeneratedAttribute]
public int get_BloomShift();
    [CompilerGeneratedAttribute]
public Int32[] get_Buckets();
    [IteratorStateMachineAttribute("Microsoft.Diagnostics.Runtime.Utilities.ElfSymbolGnuHash/<GetPossibleSymbolIndex>d__19")]
public IEnumerable`1<int> GetPossibleSymbolIndex(string symbolName);
    private static UInt32 Hash(string symbolName);
    private int GetChain(int index);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.Diagnostics.Runtime.Utilities.ElfSymbolTable : object {
    private Reader _reader;
    private ulong _address;
    private bool _is64Bit;
    private ElfStringTable _stringTable;
    private UInt32 _symSize;
    public ElfSymbolTable(Reader reader, bool is64Bit, ulong address, ElfStringTable stringTable);
    public ElfSymbol GetSymbol(UInt32 index);
    [NullableContextAttribute("2")]
internal static ElfSymbolTable Create(Reader reader, bool is64Bit, ulong symbolTableVA, ElfStringTable stringTable);
}
internal enum Microsoft.Diagnostics.Runtime.Utilities.ElfSymbolType : Enum {
    public byte value__;
    public static ElfSymbolType NoType;
    public static ElfSymbolType Object;
    public static ElfSymbolType Func;
    public static ElfSymbolType Section;
    public static ElfSymbolType File;
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.Diagnostics.Runtime.Utilities.ElfVirtualAddressSpace : object {
    private ElfProgramHeader[] _segments;
    private IAddressSpace _addressSpace;
    [CompilerGeneratedAttribute]
private ulong <Length>k__BackingField;
    public string Name { get; }
    public ulong Length { get; }
    public ElfVirtualAddressSpace(ImmutableArray`1<ElfProgramHeader> segments, IAddressSpace addressSpace);
    public sealed virtual string get_Name();
    [CompilerGeneratedAttribute]
public sealed virtual ulong get_Length();
    [NullableContextAttribute("0")]
public sealed virtual int Read(ulong address, Span`1<byte> buffer);
    private int GetFirstSegmentContaining(ulong address);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
internal class Microsoft.Diagnostics.Runtime.Utilities.FileVersionInfo : object {
    [CompilerGeneratedAttribute]
private string <FileVersion>k__BackingField;
    [CompilerGeneratedAttribute]
private Version <Version>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Comments>k__BackingField;
    public string FileVersion { get; }
    public Version Version { get; }
    public string Comments { get; }
    [NullableContextAttribute("0")]
internal FileVersionInfo(ReadOnlySpan`1<byte> data);
    [CompilerGeneratedAttribute]
public string get_FileVersion();
    [CompilerGeneratedAttribute]
public Version get_Version();
    [CompilerGeneratedAttribute]
public string get_Comments();
    [NullableContextAttribute("0")]
private static Version GetVersionInfo(ReadOnlySpan`1<char> dataAsString);
    [NullableContextAttribute("0")]
private static string GetDataString(ReadOnlySpan`1<char> dataAsString, ReadOnlySpan`1<char> fileVersionKey);
    public virtual string ToString();
}
[ExtensionAttribute]
internal static class Microsoft.Diagnostics.Runtime.Utilities.HelperExtensions : object {
    [NullableContextAttribute("1")]
[ExtensionAttribute]
public static string GetFilename(Stream stream);
}
public class Microsoft.Diagnostics.Runtime.Utilities.HResult : ValueType {
    public static int S_OK;
    public static int S_FALSE;
    public static int E_FAIL;
    public static int E_INVALIDARG;
    public static int E_NOTIMPL;
    public static int E_NOINTERFACE;
    [CompilerGeneratedAttribute]
private int <Value>k__BackingField;
    public bool IsOK { get; }
    public int Value { get; public set; }
    public HResult(int hr);
    public bool get_IsOK();
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public int get_Value();
    [CompilerGeneratedAttribute]
public void set_Value(int value);
    public static HResult op_Implicit(int hr);
    public static int op_Implicit(HResult hr);
    public static bool op_Implicit(HResult hr);
    [NullableContextAttribute("1")]
public virtual string ToString();
}
[NullableContextAttribute("1")]
internal interface Microsoft.Diagnostics.Runtime.Utilities.IAddressSpace {
    public ulong Length { get; }
    public string Name { get; }
    [NullableContextAttribute("0")]
public abstract virtual int Read(ulong position, Span`1<byte> buffer);
    public abstract virtual ulong get_Length();
    public abstract virtual string get_Name();
}
internal interface Microsoft.Diagnostics.Runtime.Utilities.IElfHeader {
    public bool Is64Bit { get; }
    public bool IsValid { get; }
    public ElfHeaderType Type { get; }
    public ElfMachine Architecture { get; }
    public ulong ProgramHeaderOffset { get; }
    public ulong SectionHeaderOffset { get; }
    public ushort ProgramHeaderEntrySize { get; }
    public ushort ProgramHeaderCount { get; }
    public ushort SectionHeaderEntrySize { get; }
    public ushort SectionHeaderCount { get; }
    public ushort SectionHeaderStringIndex { get; }
    public abstract virtual bool get_Is64Bit();
    public abstract virtual bool get_IsValid();
    public abstract virtual ElfHeaderType get_Type();
    public abstract virtual ElfMachine get_Architecture();
    public abstract virtual ulong get_ProgramHeaderOffset();
    public abstract virtual ulong get_SectionHeaderOffset();
    public abstract virtual ushort get_ProgramHeaderEntrySize();
    public abstract virtual ushort get_ProgramHeaderCount();
    public abstract virtual ushort get_SectionHeaderEntrySize();
    public abstract virtual ushort get_SectionHeaderCount();
    public abstract virtual ushort get_SectionHeaderStringIndex();
}
internal interface Microsoft.Diagnostics.Runtime.Utilities.IElfPRStatus {
    public UInt32 ProcessId { get; }
    public UInt32 ThreadId { get; }
    public abstract virtual UInt32 get_ProcessId();
    public abstract virtual UInt32 get_ThreadId();
    public abstract virtual bool CopyRegistersAsContext(Span`1<byte> context);
}
internal enum Microsoft.Diagnostics.Runtime.Utilities.IMAGE_FILE_MACHINE : Enum {
    public UInt32 value__;
    public static IMAGE_FILE_MACHINE UNKNOWN;
    public static IMAGE_FILE_MACHINE I386;
    public static IMAGE_FILE_MACHINE R3000;
    public static IMAGE_FILE_MACHINE R4000;
    public static IMAGE_FILE_MACHINE R10000;
    public static IMAGE_FILE_MACHINE WCEMIPSV2;
    public static IMAGE_FILE_MACHINE ALPHA;
    public static IMAGE_FILE_MACHINE SH3;
    public static IMAGE_FILE_MACHINE SH3DSP;
    public static IMAGE_FILE_MACHINE SH3E;
    public static IMAGE_FILE_MACHINE SH4;
    public static IMAGE_FILE_MACHINE SH5;
    public static IMAGE_FILE_MACHINE ARM;
    public static IMAGE_FILE_MACHINE THUMB;
    public static IMAGE_FILE_MACHINE THUMB2;
    public static IMAGE_FILE_MACHINE AM33;
    public static IMAGE_FILE_MACHINE POWERPC;
    public static IMAGE_FILE_MACHINE POWERPCFP;
    public static IMAGE_FILE_MACHINE IA64;
    public static IMAGE_FILE_MACHINE MIPS16;
    public static IMAGE_FILE_MACHINE ALPHA64;
    public static IMAGE_FILE_MACHINE MIPSFPU;
    public static IMAGE_FILE_MACHINE MIPSFPU16;
    public static IMAGE_FILE_MACHINE TRICORE;
    public static IMAGE_FILE_MACHINE CEF;
    public static IMAGE_FILE_MACHINE EBC;
    public static IMAGE_FILE_MACHINE LOONGARCH64;
    public static IMAGE_FILE_MACHINE AMD64;
    public static IMAGE_FILE_MACHINE M32R;
    public static IMAGE_FILE_MACHINE ARM64;
    public static IMAGE_FILE_MACHINE RISCV64;
    public static IMAGE_FILE_MACHINE CEE;
}
internal class Microsoft.Diagnostics.Runtime.Utilities.IMAGE_RESOURCE_DIRECTORY : ValueType {
    public int Characteristics;
    public int TimeDateStamp;
    public short MajorVersion;
    public short MinorVersion;
    public ushort NumberOfNamedEntries;
    public ushort NumberOfIdEntries;
}
internal class Microsoft.Diagnostics.Runtime.Utilities.ImageCor20Header : ValueType {
    public UInt32 cb;
    public ushort MajorRuntimeVersion;
    public ushort MinorRuntimeVersion;
    public ImageDataDirectory MetaData;
    public UInt32 Flags;
    public ImageCor20HeaderEntrypoint EntryPoint;
    public ImageDataDirectory Resources;
    public ImageDataDirectory StrongNameSignature;
    public ImageDataDirectory CodeManagerTable;
    public ImageDataDirectory VTableFixups;
    public ImageDataDirectory ExportAddressTableJumps;
    public ImageDataDirectory ManagedNativeHeader;
}
[IsReadOnlyAttribute]
internal class Microsoft.Diagnostics.Runtime.Utilities.ImageCor20HeaderEntrypoint : ValueType {
    public UInt32 Token;
    public UInt32 RVA;
}
internal class Microsoft.Diagnostics.Runtime.Utilities.ImageDataDirectory : ValueType {
    public int VirtualAddress;
    public int Size;
}
internal class Microsoft.Diagnostics.Runtime.Utilities.ImageDebugDirectory : ValueType {
    public int Characteristics;
    public int TimeDateStamp;
    public short MajorVersion;
    public short MinorVersion;
    public ImageDebugType Type;
    public int SizeOfData;
    public int AddressOfRawData;
    public int PointerToRawData;
}
internal enum Microsoft.Diagnostics.Runtime.Utilities.ImageDebugType : Enum {
    public int value__;
    public static ImageDebugType UNKNOWN;
    public static ImageDebugType COFF;
    public static ImageDebugType CODEVIEW;
    public static ImageDebugType FPO;
    public static ImageDebugType MISC;
    public static ImageDebugType BBT;
}
internal class Microsoft.Diagnostics.Runtime.Utilities.ImageExportDirectory : ValueType {
    public int Characteristics;
    public int TimeDateStamp;
    public short MajorVersion;
    public short MinorVersion;
    public int Name;
    public int Base;
    public int NumberOfFunctions;
    public int NumberOfNames;
    public int AddressOfFunctions;
    public int AddressOfNames;
    public int AddressOfNameOrdinals;
}
internal class Microsoft.Diagnostics.Runtime.Utilities.ImageFileHeader : ValueType {
    public ushort Machine;
    public ushort NumberOfSections;
    public int TimeDateStamp;
    public UInt32 PointerToSymbolTable;
    public UInt32 NumberOfSymbols;
    public ushort SizeOfOptionalHeader;
    public ushort Characteristics;
}
internal class Microsoft.Diagnostics.Runtime.Utilities.ImageOptionalHeader : ValueType {
    public ushort Magic;
    public byte MajorLinkerVersion;
    public byte MinorLinkerVersion;
    public UInt32 SizeOfCode;
    public UInt32 SizeOfInitializedData;
    public UInt32 SizeOfUninitializedData;
    public UInt32 AddressOfEntryPoint;
    public UInt32 BaseOfCode;
    public ulong ImageBase64;
    public UInt32 BaseOfData;
    public UInt32 ImageBase;
    public UInt32 SectionAlignment;
    public UInt32 FileAlignment;
    public ushort MajorOperatingSystemVersion;
    public ushort MinorOperatingSystemVersion;
    public ushort MajorImageVersion;
    public ushort MinorImageVersion;
    public ushort MajorSubsystemVersion;
    public ushort MinorSubsystemVersion;
    public UInt32 Win32VersionValue;
    public int SizeOfImage;
    public UInt32 SizeOfHeaders;
    public UInt32 CheckSum;
    public ushort Subsystem;
    public ushort DllCharacteristics;
}
internal class Microsoft.Diagnostics.Runtime.Utilities.ImageRelocation : ValueType {
    public int pageRVA;
    public int blockSize;
}
internal class Microsoft.Diagnostics.Runtime.Utilities.ImageResourceDataEntry : ValueType {
    public int RvaToData;
    public int Size;
    public int CodePage;
    public int Reserved;
}
[IsReadOnlyAttribute]
internal class Microsoft.Diagnostics.Runtime.Utilities.ImageResourceDirectoryEntry : ValueType {
    private int _nameOffsetAndFlag;
    private int _dataOffsetAndFlag;
    public bool IsStringName { get; }
    public int NameOffset { get; }
    public bool IsLeaf { get; }
    public int DataOffset { get; }
    public int Id { get; }
    public bool get_IsStringName();
    public int get_NameOffset();
    public bool get_IsLeaf();
    public int get_DataOffset();
    public int get_Id();
    [NullableContextAttribute("1")]
internal static string GetTypeNameForTypeId(int typeId);
}
internal class Microsoft.Diagnostics.Runtime.Utilities.ImageSectionHeader : ValueType {
    [FixedBufferAttribute("System.Byte", "8")]
public <NameBytes>e__FixedBuffer NameBytes;
    public UInt32 VirtualSize;
    public UInt32 VirtualAddress;
    public UInt32 SizeOfRawData;
    public UInt32 PointerToRawData;
    public UInt32 PointerToRelocations;
    public UInt32 PointerToLinenumbers;
    public ushort NumberOfRelocations;
    public ushort NumberOfLinenumbers;
    public UInt32 Characteristics;
    [NullableAttribute("1")]
public string Name { get; }
    [NullableContextAttribute("1")]
public string get_Name();
}
public class Microsoft.Diagnostics.Runtime.Utilities.IUnknownVTable : ValueType {
    public method QueryInterface;
    public method AddRef;
    public method Release;
}
internal class Microsoft.Diagnostics.Runtime.Utilities.LinuxLiveDataReader : CommonMemoryReader {
    [NullableAttribute("1")]
private Builder<MemoryMapEntry> _memoryMapEntries;
    [NullableAttribute("1")]
private List`1<UInt32> _threadIDs;
    private bool _suspended;
    private bool _disposed;
    [NullableAttribute("2")]
private FileStream _fileStream;
    [CompilerGeneratedAttribute]
private int <ProcessId>k__BackingField;
    [CompilerGeneratedAttribute]
private Architecture <Architecture>k__BackingField;
    private static int EPERM;
    private static int ESRCH;
    [NullableAttribute("1")]
private static string LibC;
    private static int PTRACE_GETREGS;
    private static int PTRACE_ATTACH;
    private static int PTRACE_DETACH;
    [NullableAttribute("1")]
public string DisplayName { get; }
    public OSPlatform TargetPlatform { get; }
    public int ProcessId { get; }
    public bool IsThreadSafe { get; }
    public Architecture Architecture { get; }
    public LinuxLiveDataReader(int processId, bool suspend);
    [NullableContextAttribute("1")]
public sealed virtual string get_DisplayName();
    public sealed virtual OSPlatform get_TargetPlatform();
    protected virtual override void Finalize();
    [CompilerGeneratedAttribute]
public sealed virtual int get_ProcessId();
    public sealed virtual bool get_IsThreadSafe();
    public sealed virtual void Dispose();
    private void Dispose(bool _);
    public sealed virtual void FlushCachedData();
    [CompilerGeneratedAttribute]
public sealed virtual Architecture get_Architecture();
    [NullableContextAttribute("1")]
public sealed virtual IEnumerable`1<ModuleInfo> EnumerateModules();
    [NullableContextAttribute("1")]
private ModuleInfo GetModuleInfo(IDataReader reader, ulong baseAddress, string filePath, bool isVirtual);
    [NullableContextAttribute("2")]
private ElfFile GetElfFile(ulong baseAddress);
    public virtual int Read(ulong address, Span`1<byte> buffer);
    private int ReadMemoryProc(ulong address, Span`1<byte> buffer);
    private int ReadMemoryReadv(ulong address, Span`1<byte> buffer);
    [NullableContextAttribute("1")]
public sealed virtual IEnumerable`1<UInt32> EnumerateOSThreadIds();
    public sealed virtual ulong GetThreadTeb(UInt32 _);
    public sealed virtual bool GetThreadContext(UInt32 threadID, UInt32 contextFlags, Span`1<byte> context);
    private void LoadThreadsAndAttach();
    private void LoadThreads();
    [NullableContextAttribute("1")]
[IteratorStateMachineAttribute("Microsoft.Diagnostics.Runtime.Utilities.LinuxLiveDataReader/<GetThreads>d__33")]
private static IEnumerable`1<UInt32> GetThreads(int pid);
    [NullableContextAttribute("1")]
private Builder<MemoryMapEntry> LoadMemoryMaps();
    [NullableContextAttribute("1")]
private static int ParsePermission(string permission);
    private static int kill(int pid, int sig);
    private static IntPtr ptrace(int request, int pid, IntPtr addr, IntPtr data);
    private static IntPtr process_vm_readv(int pid, IOVEC* local_iov, UIntPtr liovcnt, IOVEC* remote_iov, UIntPtr riovcnt, UIntPtr flags);
    private static int waitpid(int pid, IntPtr status, int options);
    [CompilerGeneratedAttribute]
private ModuleInfo <EnumerateModules>b__22_5(<>f__AnonymousType3`2<<>f__AnonymousType2`2<<>f__AnonymousType1`2<IGrouping`2<string, MemoryMapEntry>, string>, bool>, ulong> <>h__TransparentIdentifier2);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
internal class Microsoft.Diagnostics.Runtime.Utilities.MemoryMapEntry : ValueType {
    [CompilerGeneratedAttribute]
private ulong <BeginAddress>k__BackingField;
    [CompilerGeneratedAttribute]
private ulong <EndAddress>k__BackingField;
    [CompilerGeneratedAttribute]
private string <FilePath>k__BackingField;
    [CompilerGeneratedAttribute]
private int <Permission>k__BackingField;
    public ulong BeginAddress { get; public set; }
    public ulong EndAddress { get; public set; }
    public string FilePath { get; public set; }
    public int Permission { get; public set; }
    public bool IsReadable { get; }
    public bool IsExecutable { get; }
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public sealed virtual ulong get_BeginAddress();
    [CompilerGeneratedAttribute]
public void set_BeginAddress(ulong value);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public sealed virtual ulong get_EndAddress();
    [CompilerGeneratedAttribute]
public void set_EndAddress(ulong value);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public string get_FilePath();
    [CompilerGeneratedAttribute]
public void set_FilePath(string value);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public int get_Permission();
    [CompilerGeneratedAttribute]
public void set_Permission(int value);
    public sealed virtual bool get_IsReadable();
    public bool get_IsExecutable();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.Diagnostics.Runtime.Utilities.MemoryVirtualAddressSpace : object {
    private IDataReader _dataReader;
    public ulong Length { get; }
    public string Name { get; }
    public MemoryVirtualAddressSpace(IDataReader dataReader);
    public sealed virtual ulong get_Length();
    public sealed virtual string get_Name();
    [NullableContextAttribute("0")]
public sealed virtual int Read(ulong position, Span`1<byte> buffer);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.Diagnostics.Runtime.Utilities.PEImage : object {
    private static ushort ExpectedDosHeaderMagic;
    private static int PESignatureOffsetLocation;
    private static UInt32 ExpectedPESignature;
    private static int ImageDataDirectoryCount;
    private static int OptionalMagic32;
    private ulong _imageBase;
    private ulong _loadedImageBase;
    [NullableAttribute("2")]
private Int32[] _relocations;
    private Stream _stream;
    private int _offset;
    private bool _leaveOpen;
    private bool _isVirtual;
    private int _peHeaderOffset;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private ImmutableArray`1<PdbInfo> _pdbs;
    [NullableAttribute("2")]
private ResourceEntry _resources;
    private ImageDataDirectory[] _directories;
    private int _sectionCount;
    [NullableAttribute("2")]
private ImageSectionHeader[] _sections;
    [NullableAttribute("2")]
private object _metadata;
    private bool _disposed;
    [CompilerGeneratedAttribute]
private bool <IsValid>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsPE64>k__BackingField;
    [CompilerGeneratedAttribute]
private int <IndexTimeStamp>k__BackingField;
    [CompilerGeneratedAttribute]
private int <IndexFileSize>k__BackingField;
    private int HeaderOffset { get; }
    private int OptionalHeaderOffset { get; }
    internal int SpecificHeaderOffset { get; }
    private int DataDirectoryOffset { get; }
    private int ImageDataDirectoryOffset { get; }
    internal int ResourceVirtualAddress { get; }
    public ResourceEntry Resources { get; }
    public bool IsValid { get; }
    public bool IsPE64 { get; }
    public bool IsManaged { get; }
    private ImageDataDirectory ExportDirectory { get; }
    private ImageDataDirectory RelocationDataDirectory { get; }
    private ImageDataDirectory DebugDataDirectory { get; }
    private ImageDataDirectory ComDescriptorDirectory { get; }
    internal ImageDataDirectory MetadataDirectory { get; }
    private ImageDataDirectory ResourceDirectory { get; }
    public int IndexTimeStamp { get; }
    public int IndexFileSize { get; }
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ImmutableArray`1<PdbInfo> Pdbs { get; }
    [NullableAttribute("2")]
public PdbInfo DefaultPdb { get; }
    public PEImage(FileStream stream, bool leaveOpen, ulong loadedImageBase);
    public PEImage(ReadVirtualStream stream, bool leaveOpen, bool isVirtual);
    public PEImage(ReaderStream stream, bool leaveOpen, bool isVirtual);
    private PEImage(Stream stream, bool leaveOpen, bool isVirtual, ulong loadedImageBase);
    private int get_HeaderOffset();
    private int get_OptionalHeaderOffset();
    internal int get_SpecificHeaderOffset();
    private int get_DataDirectoryOffset();
    private int get_ImageDataDirectoryOffset();
    internal int get_ResourceVirtualAddress();
    public ResourceEntry get_Resources();
    [CompilerGeneratedAttribute]
public bool get_IsValid();
    [CompilerGeneratedAttribute]
public bool get_IsPE64();
    public bool get_IsManaged();
    private ImageDataDirectory get_ExportDirectory();
    private ImageDataDirectory get_RelocationDataDirectory();
    private ImageDataDirectory get_DebugDataDirectory();
    private ImageDataDirectory get_ComDescriptorDirectory();
    internal ImageDataDirectory get_MetadataDirectory();
    private ImageDataDirectory get_ResourceDirectory();
    [CompilerGeneratedAttribute]
public int get_IndexTimeStamp();
    [CompilerGeneratedAttribute]
public int get_IndexFileSize();
    public ImmutableArray`1<PdbInfo> get_Pdbs();
    [NullableContextAttribute("2")]
public PdbInfo get_DefaultPdb();
    public sealed virtual void Dispose();
    public int RvaToOffset(int virtualAddress);
    [NullableContextAttribute("0")]
private int DoRead(Int32& offset, Span`1<byte> dest);
    [NullableContextAttribute("0")]
public int Read(int virtualAddress, Span`1<byte> dest);
    [NullableContextAttribute("0")]
internal int ReadFromOffset(int offset, Span`1<byte> dest);
    [NullableContextAttribute("2")]
public FileVersionInfo GetFileVersionInfo();
    public bool TryGetExportSymbol(string symbolName, UInt64& offset);
    private string ReadNullTerminatedAscii(int rva, int maxLength);
    private ResourceEntry CreateResourceRoot();
    [NullableContextAttribute("0")]
internal T Read(int offset);
    [NullableContextAttribute("0")]
internal T Read(Int32& offset);
    [NullableContextAttribute("0")]
internal bool TryRead(Int32& offset, T& result);
    [NullableContextAttribute("0")]
internal bool TryRead(int offset, T& result);
    [NullableContextAttribute("0")]
internal bool TryRead(T& result);
    [NullableContextAttribute("0")]
internal T Read();
    private void SeekTo(int offset);
    private ImageSectionHeader[] ReadSections();
    private bool Read64Bit();
    private ImmutableArray`1<PdbInfo> ReadPdbs();
    [NullableContextAttribute("2")]
private string ReadString(int len);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.Diagnostics.Runtime.Utilities.Reader : object {
    [CompilerGeneratedAttribute]
private IAddressSpace <DataSource>k__BackingField;
    public IAddressSpace DataSource { get; }
    public Reader(IAddressSpace source);
    [CompilerGeneratedAttribute]
public IAddressSpace get_DataSource();
    [NullableContextAttribute("0")]
public Nullable`1<T> TryRead(ulong position);
    [NullableContextAttribute("0")]
public T Read(ulong position);
    [NullableContextAttribute("0")]
public T Read(UInt64& position);
    [NullableContextAttribute("0")]
public int ReadBytes(ulong position, Span`1<byte> buffer);
    public string ReadNullTerminatedAscii(ulong position);
    public string ReadNullTerminatedAscii(ulong position, int length);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.Diagnostics.Runtime.Utilities.ReaderStream : Stream {
    private Reader _reader;
    private ulong _baseAddress;
    private ulong _length;
    private long _position;
    public bool CanRead { get; }
    public bool CanSeek { get; }
    public bool CanWrite { get; }
    public long Length { get; }
    public long Position { get; public set; }
    public ReaderStream(ulong baseAddress, ulong length, Reader reader);
    public virtual bool get_CanRead();
    public virtual bool get_CanSeek();
    public virtual bool get_CanWrite();
    public virtual long get_Length();
    public virtual long get_Position();
    public virtual void set_Position(long value);
    public virtual void Flush();
    public virtual int Read(Byte[] buffer, int offset, int count);
    public virtual long Seek(long offset, SeekOrigin origin);
    public virtual void SetLength(long value);
    public virtual void Write(Byte[] buffer, int offset, int count);
}
internal class Microsoft.Diagnostics.Runtime.Utilities.RegSetArm : ValueType {
    public UInt32 r0;
    public UInt32 r1;
    public UInt32 r2;
    public UInt32 r3;
    public UInt32 r4;
    public UInt32 r5;
    public UInt32 r6;
    public UInt32 r7;
    public UInt32 r8;
    public UInt32 r9;
    public UInt32 r10;
    public UInt32 fp;
    public UInt32 ip;
    public UInt32 sp;
    public UInt32 lr;
    public UInt32 pc;
    public UInt32 cpsr;
    public UInt32 orig_r0;
    public bool CopyContext(Span`1<byte> context);
}
internal class Microsoft.Diagnostics.Runtime.Utilities.RegSetArm64 : ValueType {
    [FixedBufferAttribute("System.UInt64", "31")]
public <regs>e__FixedBuffer regs;
    public ulong sp;
    public ulong pc;
    public ulong pstate;
    public bool CopyContext(Span`1<byte> context);
}
internal class Microsoft.Diagnostics.Runtime.Utilities.RegSetLoongArch64 : ValueType {
    public ulong R0;
    public ulong Ra;
    public ulong Tp;
    public ulong Sp;
    public ulong A0;
    public ulong A1;
    public ulong A2;
    public ulong A3;
    public ulong A4;
    public ulong A5;
    public ulong A6;
    public ulong A7;
    public ulong T0;
    public ulong T1;
    public ulong T2;
    public ulong T3;
    public ulong T4;
    public ulong T5;
    public ulong T6;
    public ulong T7;
    public ulong T8;
    public ulong X0;
    public ulong Fp;
    public ulong S0;
    public ulong S1;
    public ulong S2;
    public ulong S3;
    public ulong S4;
    public ulong S5;
    public ulong S6;
    public ulong S7;
    public ulong S8;
    public ulong Pc;
    public bool CopyContext(Span`1<byte> context);
}
internal class Microsoft.Diagnostics.Runtime.Utilities.RegSetRiscV64 : ValueType {
    public ulong R0;
    public ulong Ra;
    public ulong Sp;
    public ulong Gp;
    public ulong Tp;
    public ulong T0;
    public ulong T1;
    public ulong T2;
    public ulong Fp;
    public ulong S1;
    public ulong A0;
    public ulong A1;
    public ulong A2;
    public ulong A3;
    public ulong A4;
    public ulong A5;
    public ulong A6;
    public ulong A7;
    public ulong S2;
    public ulong S3;
    public ulong S4;
    public ulong S5;
    public ulong S6;
    public ulong S7;
    public ulong S8;
    public ulong S9;
    public ulong S10;
    public ulong S11;
    public ulong T3;
    public ulong T4;
    public ulong T5;
    public ulong T6;
    public ulong Pc;
    public bool CopyContext(Span`1<byte> context);
}
[IsReadOnlyAttribute]
internal class Microsoft.Diagnostics.Runtime.Utilities.RegSetX64 : ValueType {
    public ulong R15;
    public ulong R14;
    public ulong R13;
    public ulong R12;
    public ulong Rbp;
    public ulong Rbx;
    public ulong R11;
    public ulong R10;
    public ulong R8;
    public ulong R9;
    public ulong Rax;
    public ulong Rcx;
    public ulong Rdx;
    public ulong Rsi;
    public ulong Rdi;
    public ulong OrigRax;
    public ulong Rip;
    public ulong CS;
    public ulong EFlags;
    public ulong Rsp;
    public ulong SS;
    public ulong FSBase;
    public ulong GSBase;
    public ulong DS;
    public ulong ES;
    public ulong FS;
    public ulong GS;
    public bool CopyContext(Span`1<byte> context);
}
[IsReadOnlyAttribute]
internal class Microsoft.Diagnostics.Runtime.Utilities.RegSetX86 : ValueType {
    public UInt32 Ebx;
    public UInt32 Ecx;
    public UInt32 Edx;
    public UInt32 Esi;
    public UInt32 Edi;
    public UInt32 Ebp;
    public UInt32 Eax;
    public UInt32 Xds;
    public UInt32 Xes;
    public UInt32 Xfs;
    public UInt32 Xgs;
    public UInt32 OrigEax;
    public UInt32 Eip;
    public UInt32 Xcs;
    public UInt32 EFlags;
    public UInt32 Esp;
    public UInt32 Xss;
    public bool CopyContext(Span`1<byte> context);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.Diagnostics.Runtime.Utilities.RelativeAddressSpace : object {
    private IAddressSpace _baseAddressSpace;
    private ulong _baseStart;
    private ulong _length;
    private long _baseToRelativeShift;
    private string _name;
    public string Name { get; }
    public ulong Length { get; }
    public RelativeAddressSpace(IAddressSpace baseAddressSpace, string name, ulong startOffset, ulong length);
    public RelativeAddressSpace(IAddressSpace baseAddressSpace, string name, ulong startOffset, ulong length, long baseToRelativeShift);
    public sealed virtual string get_Name();
    [NullableContextAttribute("0")]
public sealed virtual int Read(ulong position, Span`1<byte> buffer);
    public sealed virtual ulong get_Length();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.Diagnostics.Runtime.Utilities.ResourceEntry : object {
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private ImmutableArray`1<IResourceNode> _children;
    private int _offset;
    [CompilerGeneratedAttribute]
private static int <MaxChildrenCount>k__BackingField;
    [CompilerGeneratedAttribute]
private static int <MaxNameLength>k__BackingField;
    [CompilerGeneratedAttribute]
private PEImage <Image>k__BackingField;
    [NullableAttribute("2")]
[CompilerGeneratedAttribute]
private ResourceEntry <Parent>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsLeaf>k__BackingField;
    public static int MaxChildrenCount { get; public set; }
    public static int MaxNameLength { get; public set; }
    public PEImage Image { get; }
    [NullableAttribute("2")]
public ResourceEntry Parent { get; }
    public string Name { get; }
    public bool IsLeaf { get; }
    public int Size { get; }
    public int ChildCount { get; }
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ImmutableArray`1<IResourceNode> Children { get; }
    internal ResourceEntry(PEImage image, ResourceEntry parent, string name, bool leaf, int offset);
    private static ResourceEntry();
    [CompilerGeneratedAttribute]
public static int get_MaxChildrenCount();
    [CompilerGeneratedAttribute]
public static void set_MaxChildrenCount(int value);
    [CompilerGeneratedAttribute]
public static int get_MaxNameLength();
    [CompilerGeneratedAttribute]
public static void set_MaxNameLength(int value);
    [CompilerGeneratedAttribute]
public PEImage get_Image();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public ResourceEntry get_Parent();
    [CompilerGeneratedAttribute]
public sealed virtual string get_Name();
    [CompilerGeneratedAttribute]
public bool get_IsLeaf();
    public sealed virtual int get_Size();
    public int get_ChildCount();
    public sealed virtual IResourceNode GetChild(string name);
    [NullableContextAttribute("0")]
public sealed virtual int Read(Span`1<byte> span, int offset);
    [NullableContextAttribute("0")]
public sealed virtual T Read(int offset);
    public sealed virtual ImmutableArray`1<IResourceNode> get_Children();
    [NullableContextAttribute("0")]
private ValueTuple`2<int, IMAGE_RESOURCE_DIRECTORY> GetHeader();
    private string GetName(int nameOffset, int resourceStartFileOffset);
    private void GetDataVaAndSize(Int32& va, Int32& size);
    public virtual string ToString();
}
public class Microsoft.Diagnostics.Runtime.Utilities.SigParser : ValueType {
    private Byte* _sig;
    private int _len;
    private int _offs;
    private static int mdtTypeRef;
    private static int mdtTypeDef;
    private static int mdtTypeSpec;
    private static int mdtBaseType;
    [NullableAttribute("1")]
private static Int32[] s_tkCorEncodeToken;
    public static int IMAGE_CEE_CS_CALLCONV_VARARG;
    public static int IMAGE_CEE_CS_CALLCONV_FIELD;
    public static int IMAGE_CEE_CS_CALLCONV_LOCAL_SIG;
    public static int IMAGE_CEE_CS_CALLCONV_PROPERTY;
    public static int IMAGE_CEE_CS_CALLCONV_UNMGD;
    public static int IMAGE_CEE_CS_CALLCONV_GENERICINST;
    public static int IMAGE_CEE_CS_CALLCONV_NATIVEVARARG;
    public static int IMAGE_CEE_CS_CALLCONV_MAX;
    public static int IMAGE_CEE_CS_CALLCONV_MASK;
    public static int IMAGE_CEE_CS_CALLCONV_HASTHIS;
    public static int IMAGE_CEE_CS_CALLCONV_EXPLICITTHIS;
    public static int IMAGE_CEE_CS_CALLCONV_GENERIC;
    private static int ELEMENT_TYPE_END;
    private static int ELEMENT_TYPE_VOID;
    private static int ELEMENT_TYPE_BOOLEAN;
    private static int ELEMENT_TYPE_CHAR;
    private static int ELEMENT_TYPE_I1;
    private static int ELEMENT_TYPE_U1;
    private static int ELEMENT_TYPE_I2;
    private static int ELEMENT_TYPE_U2;
    private static int ELEMENT_TYPE_I4;
    private static int ELEMENT_TYPE_U4;
    private static int ELEMENT_TYPE_I8;
    private static int ELEMENT_TYPE_U8;
    private static int ELEMENT_TYPE_R4;
    private static int ELEMENT_TYPE_R8;
    private static int ELEMENT_TYPE_STRING;
    private static int ELEMENT_TYPE_PTR;
    private static int ELEMENT_TYPE_BYREF;
    private static int ELEMENT_TYPE_VALUETYPE;
    private static int ELEMENT_TYPE_CLASS;
    private static int ELEMENT_TYPE_VAR;
    private static int ELEMENT_TYPE_ARRAY;
    private static int ELEMENT_TYPE_GENERICINST;
    private static int ELEMENT_TYPE_TYPEDBYREF;
    private static int ELEMENT_TYPE_I;
    private static int ELEMENT_TYPE_U;
    private static int ELEMENT_TYPE_FNPTR;
    private static int ELEMENT_TYPE_OBJECT;
    private static int ELEMENT_TYPE_SZARRAY;
    private static int ELEMENT_TYPE_MVAR;
    private static int ELEMENT_TYPE_CMOD_REQD;
    private static int ELEMENT_TYPE_CMOD_OPT;
    private static int ELEMENT_TYPE_INTERNAL;
    private static int ELEMENT_TYPE_MAX;
    private static int ELEMENT_TYPE_MODIFIER;
    private static int ELEMENT_TYPE_SENTINEL;
    private static int ELEMENT_TYPE_PINNED;
    public SigParser(SigParser rhs);
    public SigParser(IntPtr sig, int len);
    private static SigParser();
    public bool IsNull();
    private void CopyFrom(SigParser rhs);
    private void SkipBytes(int bytes);
    private bool SkipInt();
    public bool GetData(Int32& data);
    private bool GetByte(Byte& data);
    private bool PeekByte(Byte& data);
    private bool GetElemTypeSlow(Int32& etype);
    public bool GetElemType(ClrElementType& etype);
    public bool GetElemType(Int32& etype);
    public bool PeekCallingConvInfo(Int32& data);
    public bool GetCallingConvInfo(Int32& data);
    private bool GetCallingConv(Int32& data);
    private bool PeekData(Int32& data);
    private bool PeekElemTypeSlow(Int32& etype);
    public bool PeekElemType(ClrElementType& etype);
    public bool PeekElemType(Int32& etype);
    private bool PeekElemTypeSize(Int32& pSize);
    private bool AtSentinel();
    public bool GetToken(Int32& token);
    public bool SkipCustomModifiers();
    private bool SkipFunkyAndCustomModifiers();
    private bool SkipAnyVASentinel();
    public bool SkipExactlyOne();
    private bool SkipMethodHeaderSignature(Int32& pcArgs);
    private bool SkipSignature();
    private bool UncompressToken(Int32& token, Int32& size);
    private byte GetSig(int offs);
    private bool UncompressData(Int32& pDataOut, Int32& pDataLen);
    private bool PeekByte(Int32& data);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.Diagnostics.Runtime.Utilities.StreamAddressSpace : object {
    private object _sync;
    private Stream _stream;
    public ulong Length { get; }
    public string Name { get; }
    public StreamAddressSpace(Stream stream);
    public sealed virtual ulong get_Length();
    public sealed virtual string get_Name();
    [NullableContextAttribute("0")]
public sealed virtual int Read(ulong position, Span`1<byte> buffer);
}
internal class Microsoft.Diagnostics.Runtime.Utilities.thread_state_t : ValueType {
    public x86_thread_state64_t x64;
    public arm_thread_state64_t arm;
}
internal class Microsoft.Diagnostics.Runtime.Utilities.TimeVal32 : ValueType {
    public int Seconds;
    public int Milliseconds;
}
internal class Microsoft.Diagnostics.Runtime.Utilities.TimeVal64 : ValueType {
    public long Seconds;
    public long Milliseconds;
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[RequiresDynamicCodeAttribute("This class uses reflection over delegates to generate code.  If used for NativeAOT, consider building a VTable with [UnmanagedCallersOnly] and native delegates instead.")]
public class Microsoft.Diagnostics.Runtime.Utilities.VTableBuilder : object {
    private Guid _guid;
    private COMCallableIUnknown _wrapper;
    private bool _forceValidation;
    private List`1<Delegate> _delegates;
    private bool _complete;
    internal VTableBuilder(COMCallableIUnknown wrapper, Guid guid, bool forceValidation);
    public void AddMethod(Delegate func, bool validate);
    public IntPtr Complete();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.Diagnostics.Runtime.Utilities.WindowsFunctions : CoreFunctions {
    internal static bool IsProcessRunning(int processId);
    internal virtual bool GetFileVersion(string dll, Int32& major, Int32& minor, Int32& revision, Int32& patch);
    public virtual IntPtr LoadLibrary(string libraryPath);
    public virtual bool FreeLibrary(IntPtr handle);
    public virtual IntPtr GetLibraryExport(IntPtr handle, string name);
    public virtual bool TryGetWow64(IntPtr proc, Boolean& result);
}
[IsReadOnlyAttribute]
internal class Microsoft.Diagnostics.Runtime.Utilities.x86_thread_state64_t : ValueType {
    public ulong __rax;
    public ulong __rbx;
    public ulong __rcx;
    public ulong __rdx;
    public ulong __rdi;
    public ulong __rsi;
    public ulong __rbp;
    public ulong __rsp;
    public ulong __r8;
    public ulong __r9;
    public ulong __r10;
    public ulong __r11;
    public ulong __r12;
    public ulong __r13;
    public ulong __r14;
    public ulong __r15;
    public ulong __rip;
    public ulong __rflags;
    public ulong __cs;
    public ulong __fs;
    public ulong __gs;
    public bool CopyContext(Span`1<byte> context);
}
public class Microsoft.Diagnostics.Runtime.VectorRegisterArea : ValueType {
    public static int VectorRegisterSize;
    [NullableAttribute("2")]
public M128A[] VectorRegister;
    public ulong VectorControl;
    public VectorRegisterArea(VectorRegisterArea other);
    public void Clear();
}
internal class Microsoft.Diagnostics.Runtime.Windows.ArrayPoolBasedCacheEntry : CacheEntryBase`1<Byte[]> {
    private static UInt32 SystemPageSize;
    private MemoryMappedFile _mappedFile;
    protected UInt32 EntryPageSize { get; }
    internal ArrayPoolBasedCacheEntry(MemoryMappedFile mappedFile, MinidumpSegment segmentData, Action`1<UInt32> updateOwningCacheForAddedChunk);
    private static ArrayPoolBasedCacheEntry();
    public virtual long PageOutData();
    protected virtual UInt32 get_EntryPageSize();
    protected virtual ValueTuple`2<Byte[], ulong> GetPageDataAtOffset(ulong pageAlignedOffset);
    protected virtual UInt32 InvokeCallbackWithDataPtr(CachePage`1<Byte[]> page, Func`3<UIntPtr, ulong, UInt32> callback);
    protected virtual UInt32 CopyDataFromPage(CachePage`1<Byte[]> page, IntPtr buffer, ulong inPageOffset, UInt32 byteCount);
    protected virtual void Dispose(bool disposing);
    private ValueTuple`2<ulong, UInt32> TryRemoveAllPagesFromCache(bool disposeLocks);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.Diagnostics.Runtime.Windows.ArrayPoolBasedCacheEntryFactory : SegmentCacheEntryFactory {
    private MemoryMappedFile _mappedFile;
    internal ArrayPoolBasedCacheEntryFactory(FileStream stream, bool leaveOpen);
    public virtual SegmentCacheEntry CreateEntryForSegment(MinidumpSegment segmentData, Action`1<UInt32> updateOwningCacheForSizeChangeCallback);
    public sealed virtual void Dispose();
}
internal class Microsoft.Diagnostics.Runtime.Windows.AWEBasedCacheEntry : CacheEntryBase`1<UIntPtr> {
    private static UInt32 VirtualAllocPageSize;
    private static int SystemPageSize;
    private UIntPtr _pageFrameArray;
    private int _pageFrameArrayItemCount;
    protected UInt32 EntryPageSize { get; }
    internal AWEBasedCacheEntry(MinidumpSegment segmentData, Action`1<UInt32> updateOwningCacheForSizeChangeCallback, UIntPtr pageFrameArray, int pageFrameArrayItemCount);
    private static AWEBasedCacheEntry();
    private static UInt32 InitVirtualAllocPageSize();
    protected virtual UInt32 get_EntryPageSize();
    public virtual long PageOutData();
    protected virtual UInt32 InvokeCallbackWithDataPtr(CachePage`1<UIntPtr> page, Func`3<UIntPtr, ulong, UInt32> callback);
    protected virtual UInt32 CopyDataFromPage(CachePage`1<UIntPtr> page, IntPtr buffer, ulong inPageOffset, UInt32 byteCount);
    protected virtual ValueTuple`2<UIntPtr, ulong> GetPageDataAtOffset(ulong pageAlignedOffset);
    protected virtual void Dispose(bool disposing);
}
internal class Microsoft.Diagnostics.Runtime.Windows.AWEBasedCacheEntryFactory : SegmentCacheEntryFactory {
    private IntPtr _dumpFileHandle;
    private UIntPtr _sharedSegment;
    internal AWEBasedCacheEntryFactory(IntPtr dumpFileHandle);
    internal void CreateSharedSegment(UInt32 size);
    internal void DeleteSharedSegment();
    [NullableContextAttribute("1")]
public virtual SegmentCacheEntry CreateEntryForSegment(MinidumpSegment segmentData, Action`1<UInt32> updateOwningCacheForSizeChangeCallback);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.Diagnostics.Runtime.Windows.CachedMemoryReader : MinidumpMemoryReader {
    [NullableAttribute("0")]
private ImmutableArray`1<MinidumpSegment> _segments;
    private bool _leaveOpen;
    private HeapSegmentDataCache _cachedMemorySegments;
    [TupleElementNamesAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[NullableAttribute("0")]
[ThreadStaticAttribute]
private static ValueTuple`2<MinidumpSegment, int> _lastAccessed;
    private object _rvaLock;
    [NullableAttribute("2")]
private Stream _rvaStream;
    [CompilerGeneratedAttribute]
private string <DumpPath>k__BackingField;
    [CompilerGeneratedAttribute]
private int <PointerSize>k__BackingField;
    [CompilerGeneratedAttribute]
private CacheTechnology <CacheTechnology>k__BackingField;
    [CompilerGeneratedAttribute]
private long <MaxCacheSize>k__BackingField;
    public static int MinimumCacheSize;
    public string DumpPath { get; }
    public int PointerSize { get; }
    public CacheTechnology CacheTechnology { get; }
    public long MaxCacheSize { get; }
    public CachedMemoryReader(ImmutableArray`1<MinidumpSegment> segments, string dumpPath, FileStream stream, long maxCacheSize, CacheTechnology cacheTechnology, int pointerSize, bool leaveOpen);
    [CompilerGeneratedAttribute]
public string get_DumpPath();
    [CompilerGeneratedAttribute]
public virtual int get_PointerSize();
    [CompilerGeneratedAttribute]
public CacheTechnology get_CacheTechnology();
    [CompilerGeneratedAttribute]
public long get_MaxCacheSize();
    [NullableContextAttribute("0")]
public virtual int ReadFromRva(ulong rva, Span`1<byte> buffer);
    [NullableContextAttribute("0")]
public virtual int Read(ulong address, Span`1<byte> buffer);
    internal int TryReadMemory(ulong address, int byteCount, IntPtr buffer);
    private SegmentCacheEntry GetCacheEntryForMemorySegment(MinidumpSegment memorySegment);
    private void ReadBytesFromSegment(MinidumpSegment segment, ulong startAddress, int byteCount, IntPtr buffer, Int32& bytesRead);
    public virtual void Dispose();
}
internal abstract class Microsoft.Diagnostics.Runtime.Windows.CacheEntryBase`1 : SegmentCacheEntry {
    protected CachePage`1[] _pages;
    protected ReaderWriterLockSlim[] _pageLocks;
    protected MinidumpSegment _segmentData;
    protected Int32 modreq(System.Runtime.CompilerServices.IsVolatile) _entrySize;
    private int _lastAccessTimestamp;
    private int _minSize;
    private Action`1<UInt32> _updateOwningCacheForAddedChunk;
    protected UInt32 EntryPageSize { get; }
    public int CurrentSize { get; }
    public int MinSize { get; }
    public int LastAccessTimestamp { get; }
    internal CacheEntryBase`1(MinidumpSegment segmentData, int derivedMinSize, Action`1<UInt32> updateOwningCacheForAddedChunk);
    protected abstract virtual UInt32 get_EntryPageSize();
    public virtual int get_CurrentSize();
    public virtual int get_MinSize();
    public virtual int get_LastAccessTimestamp();
    public virtual void GetDataForAddress(ulong address, UInt32 byteCount, IntPtr buffer, UInt32& bytesRead);
    public virtual bool GetDataFromAddressUntil(ulong address, Byte[] terminatingSequence, Byte[]& result);
    public virtual void UpdateLastAccessTimstamp();
    public sealed virtual void Dispose();
    protected abstract virtual void Dispose(bool disposing);
    protected void ThrowIfDisposed();
    private void ReadPageDataFromOffset(ulong segmentOffset, IntPtr buffer, UInt32 byteCount, UInt32 entryPageSize, UInt64& bytesRead);
    protected abstract virtual UInt32 InvokeCallbackWithDataPtr(CachePage`1<T> page, Func`3<UIntPtr, ulong, UInt32> callback);
    protected abstract virtual UInt32 CopyDataFromPage(CachePage`1<T> page, IntPtr buffer, ulong inPageOffset, UInt32 byteCount);
    protected abstract virtual ValueTuple`2<T, ulong> GetPageDataAtOffset(ulong pageAlignedOffset);
    private ulong ReadPageDataFromOffset(int pageIndex, ulong inPageOffset, UInt32 byteCount, IntPtr buffer, Func`3<UIntPtr, ulong, UInt32> dataReader);
    private bool ReadPageDataFromOffsetUntil(UInt32 segmentOffset, Byte[] terminatingSequence, List`1<byte> bytesRead);
    private static UInt32 ProcessPageForSequenceTerminatingRead(UIntPtr data, ulong dataLength, ulong inPageOffset, Byte[] terminatingSequence, List`1<byte> bytesRead, List`1& trailingBytes, Boolean& sawTerminatingSequence);
}
internal static class Microsoft.Diagnostics.Runtime.Windows.CacheNativeMethods : object {
}
internal class Microsoft.Diagnostics.Runtime.Windows.CachePage`1 : object {
    [CompilerGeneratedAttribute]
private T <Data>k__BackingField;
    [CompilerGeneratedAttribute]
private ulong <DataExtent>k__BackingField;
    public T Data { get; }
    public ulong DataExtent { get; }
    internal CachePage`1(T data, ulong dataExtent);
    [CompilerGeneratedAttribute]
public T get_Data();
    [CompilerGeneratedAttribute]
public ulong get_DataExtent();
}
internal enum Microsoft.Diagnostics.Runtime.Windows.CacheTechnology : Enum {
    public byte value__;
    public static CacheTechnology ArrayPool;
    public static CacheTechnology AWE;
}
[IsReadOnlyAttribute]
internal class Microsoft.Diagnostics.Runtime.Windows.FixedFileInfo : ValueType {
    public UInt32 Signature;
    public UInt32 StrucVersion;
    public ushort Minor;
    public ushort Major;
    public ushort Patch;
    public ushort Revision;
    public UInt32 ProductVersionMS;
    public UInt32 ProductVersionLS;
    public UInt32 FileFlagsMask;
    public UInt32 FileFlags;
    public UInt32 FileOS;
    public UInt32 FileType;
    public UInt32 FileSubtype;
    public UInt32 FileDateMS;
    public UInt32 FileDateLS;
    [NullableContextAttribute("1")]
public Version AsVersionInfo();
}
[EventSourceAttribute]
internal class Microsoft.Diagnostics.Runtime.Windows.HeapSegmentCacheEventSource : EventSource {
    [NullableAttribute("1")]
internal static HeapSegmentCacheEventSource Instance;
    private static int PageInDataEventStart;
    private static int PageInDataEventFailed;
    private static int PageInDataEventEnd;
    private static int PageOutDataEventStart;
    private static int PageOutDataEventEnd;
    private static HeapSegmentCacheEventSource();
    [EventAttribute("1")]
public void PageInDataStart(long requestedAddress, long dataSize);
    [NullableContextAttribute("1")]
[EventAttribute("2")]
public void PageInDataFailed(string exceptionMessage);
    [EventAttribute("3")]
public void PageInDataEnd(int dataRead);
    [EventAttribute("4")]
public void PageOutDataStart();
    [EventAttribute("5")]
public void PageOutDataEnd(long amountRemoved);
}
internal class Microsoft.Diagnostics.Runtime.Windows.HeapSegmentDataCache : object {
    private ReaderWriterLockSlim _cacheLock;
    private Dictionary`2<ulong, SegmentCacheEntry> _cache;
    private SegmentCacheEntryFactory _entryFactory;
    private long _cacheSize;
    private long _maxSize;
    private UInt32 _entryCountWhenFull;
    private bool _cacheIsComplete;
    private bool _cacheIsFullyPopulatedBeforeUse;
    public HeapSegmentDataCache(SegmentCacheEntryFactory entryFactory, UInt32 entryCountWhenFull, bool cacheIsFullyPopulatedBeforeUse, long maxSize);
    public SegmentCacheEntry CreateAndAddEntry(MinidumpSegment segment);
    public bool TryGetCacheEntry(ulong baseAddress, SegmentCacheEntry& entry);
    public sealed virtual void Dispose();
    private void UpdateOverallCacheSizeForAddedChunk(UInt32 chunkSize);
    private void TrimCacheIfOverLimit();
    private IList`1<ValueTuple`2<KeyValuePair`2<ulong, SegmentCacheEntry>, int>> SnapshotNonMinSizeCacheItems();
    private void ThrowIfDisposed();
}
internal class Microsoft.Diagnostics.Runtime.Windows.Minidump : object {
    private static int MiniDumpWithFullMemory;
    private static int MiniDumpWithPrivateReadWriteMemory;
    private static int MiniDumpWithPrivateWriteCopyMemory;
    [NullableAttribute("1")]
private string _displayName;
    [NullableAttribute("1")]
private MinidumpDirectory[] _directories;
    [NullableAttribute("1")]
private Task`1<ThreadReadResult> _threadTask;
    [NullableAttribute("2")]
private MemoryMappedFile _file;
    private ImmutableArray`1<MinidumpContextData> _contextsCached;
    [NullableAttribute("1")]
[CompilerGeneratedAttribute]
private MinidumpMemoryReader <MemoryReader>k__BackingField;
    [CompilerGeneratedAttribute]
private ImmutableArray`1<MinidumpModule> <Modules>k__BackingField;
    [CompilerGeneratedAttribute]
private MinidumpProcessorArchitecture <Architecture>k__BackingField;
    [CompilerGeneratedAttribute]
private int <ProcessId>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsMiniDump>k__BackingField;
    [NullableAttribute("1")]
public MinidumpMemoryReader MemoryReader { get; }
    public ImmutableArray`1<MinidumpContextData> ContextData { get; }
    public ImmutableArray`1<UInt32> OrderedThreads { get; }
    [NullableAttribute("1")]
public ImmutableDictionary`2<UInt32, ulong> Tebs { get; }
    public ImmutableArray`1<MinidumpModule> Modules { get; }
    public MinidumpProcessorArchitecture Architecture { get; }
    public int ProcessId { get; }
    public int PointerSize { get; }
    public bool IsMiniDump { get; }
    [NullableContextAttribute("1")]
public Minidump(string displayName, Stream stream, CacheOptions cacheOptions, bool leaveOpen);
    [NullableContextAttribute("1")]
[CompilerGeneratedAttribute]
public MinidumpMemoryReader get_MemoryReader();
    public ImmutableArray`1<MinidumpContextData> get_ContextData();
    public ImmutableArray`1<UInt32> get_OrderedThreads();
    [NullableContextAttribute("1")]
public ImmutableDictionary`2<UInt32, ulong> get_Tebs();
    [CompilerGeneratedAttribute]
public ImmutableArray`1<MinidumpModule> get_Modules();
    [CompilerGeneratedAttribute]
public MinidumpProcessorArchitecture get_Architecture();
    [CompilerGeneratedAttribute]
public int get_ProcessId();
    public int get_PointerSize();
    [CompilerGeneratedAttribute]
public bool get_IsMiniDump();
    public sealed virtual void Dispose();
    [NullableContextAttribute("1")]
public IEnumerable`1<MinidumpModuleInfo> EnumerateModuleInfo();
    private ValueTuple`3<int, int, int> FindImportantStreams(string crashDump);
    [NullableContextAttribute("1")]
[AsyncStateMachineAttribute("Microsoft.Diagnostics.Runtime.Windows.Minidump/<ReadThreadData>d__35")]
private Task`1<ThreadReadResult> ReadThreadData(Stream stream);
    [NullableContextAttribute("1")]
[AsyncStateMachineAttribute("Microsoft.Diagnostics.Runtime.Windows.Minidump/<ReadAsync>d__36")]
private static Task`1<int> ReadAsync(Stream stream, Byte[] buffer, int count);
    private ImmutableArray`1<MinidumpSegment> GetSegments(Stream stream);
    [NullableContextAttribute("1")]
private static void AddSegments(List`1<MinidumpSegment> segments, Byte[] buffer, int byteCount);
    [NullableContextAttribute("1")]
private static void AddSegments(List`1<MinidumpSegment> segments, ulong rva, Byte[] buffer, int byteCount);
    private static int ResizeBytesForArray(ulong count, Byte[]& buffer);
    [NullableContextAttribute("1")]
[AsyncStateMachineAttribute("Microsoft.Diagnostics.Runtime.Windows.Minidump/<ReadAsync>d__41`1")]
private static Task`1<T> ReadAsync(Stream stream, Byte[] buffer, long offset);
    private static int SizeOf();
    private static T Read(Stream stream, long offset);
    private static T Read(Stream stream);
    private static bool Read(Stream stream, long offset, T[] array);
    private static bool Read(Stream stream, T[] array);
    [NullableContextAttribute("1")]
public virtual string ToString();
    [CompilerGeneratedAttribute]
private MinidumpModuleInfo <EnumerateModuleInfo>b__33_0(MinidumpModule m);
}
[IsReadOnlyAttribute]
internal class Microsoft.Diagnostics.Runtime.Windows.MinidumpContextData : ValueType {
    public UInt32 ThreadId;
    public UInt32 ContextRva;
    public UInt32 ContextBytes;
    public MinidumpContextData(UInt32 threadId, UInt32 contextRva, UInt32 contextBytes);
}
[IsReadOnlyAttribute]
internal class Microsoft.Diagnostics.Runtime.Windows.MinidumpDirectory : ValueType {
    public MinidumpStreamType StreamType;
    public UInt32 DataSize;
    public UInt32 Rva;
}
[IsReadOnlyAttribute]
internal class Microsoft.Diagnostics.Runtime.Windows.MinidumpHeader : ValueType {
    public static int ExpectedMagic1;
    public static int ExpectedMagic2;
    public UInt32 Magic1;
    public ushort Magic2;
    public ushort Version;
    public UInt32 NumberOfStreams;
    public UInt32 StreamDirectoryRva;
    public UInt32 CheckSum;
    public UInt32 TimeDateStamp;
    public ulong Flags;
    public bool IsValid { get; }
    public bool get_IsValid();
}
[IsReadOnlyAttribute]
internal class Microsoft.Diagnostics.Runtime.Windows.MinidumpLocationDescriptor : ValueType {
    public UInt32 DataSize;
    public UInt32 Rva;
}
[IsReadOnlyAttribute]
internal class Microsoft.Diagnostics.Runtime.Windows.MinidumpMemory64List : ValueType {
    public ulong NumberOfMemoryRanges;
    public ulong Rva;
}
[IsReadOnlyAttribute]
internal class Microsoft.Diagnostics.Runtime.Windows.MinidumpMemoryDescriptor : ValueType {
    public ClrDataAddress StartAddress;
    public ClrDataAddress DataSize64;
    public UInt32 DataSize32;
    public UInt32 Rva;
}
internal abstract class Microsoft.Diagnostics.Runtime.Windows.MinidumpMemoryReader : CommonMemoryReader {
    public abstract virtual void Dispose();
    public abstract virtual int ReadFromRva(ulong rva, Span`1<byte> buffer);
    [NullableContextAttribute("2")]
public string ReadCountedUnicode(ulong rva);
}
[IsReadOnlyAttribute]
internal class Microsoft.Diagnostics.Runtime.Windows.MinidumpModule : ValueType {
    public ulong BaseOfImage;
    public int SizeOfImage;
    public UInt32 CheckSum;
    public int DateTimeStamp;
    public UInt32 ModuleNameRva;
    public FixedFileInfo VersionInfo;
    public MinidumpLocationDescriptor CvRecord;
    public MinidumpLocationDescriptor MiscRecord;
    private ulong _reserved0;
    private ulong _reserved1;
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
internal class Microsoft.Diagnostics.Runtime.Windows.MinidumpModuleInfo : object {
    [CompilerGeneratedAttribute]
private ulong <BaseOfImage>k__BackingField;
    [CompilerGeneratedAttribute]
private int <SizeOfImage>k__BackingField;
    [CompilerGeneratedAttribute]
private int <DateTimeStamp>k__BackingField;
    [CompilerGeneratedAttribute]
private FixedFileInfo <VersionInfo>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ModuleName>k__BackingField;
    public ulong BaseOfImage { get; }
    public int SizeOfImage { get; }
    public int DateTimeStamp { get; }
    public FixedFileInfo VersionInfo { get; }
    public string ModuleName { get; }
    [NullableContextAttribute("1")]
public MinidumpModuleInfo(MinidumpMemoryReader reader, MinidumpModule& module);
    [CompilerGeneratedAttribute]
public ulong get_BaseOfImage();
    [CompilerGeneratedAttribute]
public int get_SizeOfImage();
    [CompilerGeneratedAttribute]
public int get_DateTimeStamp();
    [CompilerGeneratedAttribute]
public FixedFileInfo get_VersionInfo();
    [CompilerGeneratedAttribute]
public string get_ModuleName();
}
internal enum Microsoft.Diagnostics.Runtime.Windows.MinidumpProcessorArchitecture : Enum {
    public ushort value__;
    public static MinidumpProcessorArchitecture Intel;
    public static MinidumpProcessorArchitecture Mips;
    public static MinidumpProcessorArchitecture Alpha;
    public static MinidumpProcessorArchitecture Ppc;
    public static MinidumpProcessorArchitecture Shx;
    public static MinidumpProcessorArchitecture Arm;
    public static MinidumpProcessorArchitecture Ia64;
    public static MinidumpProcessorArchitecture Alpha64;
    public static MinidumpProcessorArchitecture Msil;
    public static MinidumpProcessorArchitecture Amd64;
    public static MinidumpProcessorArchitecture Ia32OnWin64;
    public static MinidumpProcessorArchitecture Arm64;
    public static MinidumpProcessorArchitecture Unknown;
}
[IsReadOnlyAttribute]
internal class Microsoft.Diagnostics.Runtime.Windows.MinidumpSegment : ValueType {
    [CompilerGeneratedAttribute]
private ulong <FileOffset>k__BackingField;
    [CompilerGeneratedAttribute]
private ulong <VirtualAddress>k__BackingField;
    [CompilerGeneratedAttribute]
private ulong <Size>k__BackingField;
    public ulong FileOffset { get; }
    public ulong VirtualAddress { get; }
    public ulong Size { get; }
    public ulong End { get; }
    public MinidumpSegment(ulong offset, ulong startAddress, ulong size);
    [NullableContextAttribute("1")]
public virtual string ToString();
    public bool Contains(ulong address);
    [CompilerGeneratedAttribute]
public ulong get_FileOffset();
    [CompilerGeneratedAttribute]
public ulong get_VirtualAddress();
    [CompilerGeneratedAttribute]
public ulong get_Size();
    public ulong get_End();
}
internal enum Microsoft.Diagnostics.Runtime.Windows.MinidumpStreamType : Enum {
    public int value__;
    public static MinidumpStreamType UnusedStream;
    public static MinidumpStreamType ReservedStream0;
    public static MinidumpStreamType ReservedStream1;
    public static MinidumpStreamType ThreadListStream;
    public static MinidumpStreamType ModuleListStream;
    public static MinidumpStreamType MemoryListStream;
    public static MinidumpStreamType ExceptionStream;
    public static MinidumpStreamType SystemInfoStream;
    public static MinidumpStreamType ThreadExListStream;
    public static MinidumpStreamType Memory64ListStream;
    public static MinidumpStreamType CommentStreamA;
    public static MinidumpStreamType CommentStreamW;
    public static MinidumpStreamType HandleDataStream;
    public static MinidumpStreamType FunctionTableStream;
    public static MinidumpStreamType UnloadedModuleListStream;
    public static MinidumpStreamType MiscInfoStream;
    public static MinidumpStreamType MemoryInfoListStream;
    public static MinidumpStreamType ThreadInfoListStream;
    public static MinidumpStreamType LastReservedStream;
}
[IsReadOnlyAttribute]
internal class Microsoft.Diagnostics.Runtime.Windows.MinidumpThread : ValueType {
    public UInt32 ThreadId;
    public UInt32 SuspendCount;
    public UInt32 PriorityClass;
    public UInt32 Priority;
    public ulong Teb;
    public MinidumpMemoryDescriptor Stack;
    public MinidumpLocationDescriptor ThreadContext;
}
[IsReadOnlyAttribute]
internal class Microsoft.Diagnostics.Runtime.Windows.MinidumpThreadEx : ValueType {
    public UInt32 ThreadId;
    public UInt32 SuspendCount;
    public UInt32 PriorityClass;
    public UInt32 Priority;
    public ulong Teb;
    public MinidumpMemoryDescriptor Stack;
    public MinidumpLocationDescriptor ThreadContext;
    public MinidumpMemoryDescriptor BackingStore;
}
[IsReadOnlyAttribute]
internal class Microsoft.Diagnostics.Runtime.Windows.MinidumpThreadInfo : ValueType {
    public UInt32 ThreadId;
    public UInt32 DumpFlags;
    public UInt32 DumpError;
    public UInt32 ExitStatus;
    public ulong CreateTime;
    public ulong ExitTime;
    public ulong KernelTime;
    public ulong UserTime;
    public ulong StartAddress;
    public ulong Affinity;
}
[IsReadOnlyAttribute]
internal class Microsoft.Diagnostics.Runtime.Windows.MinidumpThreadInfoList : ValueType {
    public int SizeOfHeader;
    public int SizeOfEntry;
    public int NumberOfEntries;
}
internal abstract class Microsoft.Diagnostics.Runtime.Windows.SegmentCacheEntry : object {
    public int CurrentSize { get; }
    public int MinSize { get; }
    public int LastAccessTimestamp { get; }
    public abstract virtual int get_CurrentSize();
    public abstract virtual int get_MinSize();
    public abstract virtual int get_LastAccessTimestamp();
    public abstract virtual long PageOutData();
    public abstract virtual void UpdateLastAccessTimstamp();
    public abstract virtual void GetDataForAddress(ulong address, UInt32 byteCount, IntPtr buffer, UInt32& bytesRead);
    [NullableContextAttribute("1")]
public abstract virtual bool GetDataFromAddressUntil(ulong address, Byte[] terminatingSequence, Byte[]& result);
}
internal abstract class Microsoft.Diagnostics.Runtime.Windows.SegmentCacheEntryFactory : object {
    [NullableContextAttribute("1")]
public abstract virtual SegmentCacheEntry CreateEntryForSegment(MinidumpSegment segmentData, Action`1<UInt32> updateOwningCacheForSizeChangeCallback);
}
[FlagsAttribute]
internal enum Microsoft.Diagnostics.Runtime.Windows.TokenAccessLevels : Enum {
    public int value__;
    public static TokenAccessLevels AssignPrimary;
    public static TokenAccessLevels Duplicate;
    public static TokenAccessLevels Impersonate;
    public static TokenAccessLevels Query;
    public static TokenAccessLevels QuerySource;
    public static TokenAccessLevels AdjustPrivileges;
    public static TokenAccessLevels AdjustGroups;
    public static TokenAccessLevels AdjustDefault;
    public static TokenAccessLevels AdjustSessionId;
    public static TokenAccessLevels Read;
    public static TokenAccessLevels Write;
    public static TokenAccessLevels AllAccess;
    public static TokenAccessLevels MaximumAllowed;
}
internal class Microsoft.Diagnostics.Runtime.Windows.UncachedMemoryReader : MinidumpMemoryReader {
    private ImmutableArray`1<MinidumpSegment> _segments;
    [NullableAttribute("1")]
private Stream _stream;
    [NullableAttribute("1")]
private object _sync;
    private bool _leaveOpen;
    [CompilerGeneratedAttribute]
private int <PointerSize>k__BackingField;
    public int PointerSize { get; }
    public UncachedMemoryReader(ImmutableArray`1<MinidumpSegment> segments, Stream stream, int pointerSize, bool leaveOpen);
    public virtual void Dispose();
    [CompilerGeneratedAttribute]
public virtual int get_PointerSize();
    public virtual int ReadFromRva(ulong rva, Span`1<byte> buffer);
    public virtual int Read(ulong address, Span`1<byte> buffer);
    private int GetFirstSegmentContaining(ulong address);
}
internal class Microsoft.Diagnostics.Runtime.WindowsProcessDataReader : CommonMemoryReader {
    private bool _disposed;
    [NullableAttribute("2")]
private WindowsThreadSuspender _suspension;
    private int _originalPid;
    private IntPtr _snapshotHandle;
    private IntPtr _cloneHandle;
    private IntPtr _process;
    private static int PROCESS_VM_READ;
    private static int PROCESS_QUERY_INFORMATION;
    [CompilerGeneratedAttribute]
private int <ProcessId>k__BackingField;
    [NullableAttribute("1")]
private static string Kernel32LibraryName;
    [NullableAttribute("1")]
public string DisplayName { get; }
    public OSPlatform TargetPlatform { get; }
    public int ProcessId { get; }
    public bool IsThreadSafe { get; }
    public Architecture Architecture { get; }
    public WindowsProcessDataReader(int processId, WindowsProcessDataReaderMode mode);
    [NullableContextAttribute("1")]
public sealed virtual string get_DisplayName();
    public sealed virtual OSPlatform get_TargetPlatform();
    private void Dispose(bool _);
    public sealed virtual void Dispose();
    protected virtual override void Finalize();
    [CompilerGeneratedAttribute]
public sealed virtual int get_ProcessId();
    public sealed virtual bool get_IsThreadSafe();
    public sealed virtual void FlushCachedData();
    public sealed virtual Architecture get_Architecture();
    [NullableContextAttribute("1")]
public sealed virtual IEnumerable`1<ModuleInfo> EnumerateModules();
    public virtual int Read(ulong address, Span`1<byte> buffer);
    public sealed virtual bool GetThreadContext(UInt32 threadID, UInt32 contextFlags, Span`1<byte> context);
    private void GetFileProperties(ulong moduleBase, Int32& filesize, Int32& timestamp);
    [NullableContextAttribute("2")]
public static bool EnumProcessModules(IntPtr hProcess, IntPtr[] lphModule, UInt32 cb, UInt32& lpcbNeeded);
    [NullableContextAttribute("1")]
public static UInt32 GetModuleFileNameEx(IntPtr hProcess, IntPtr hModule, Char[] lpFilename, int nSize);
    private static int ReadProcessMemory(IntPtr hProcess, IntPtr lpBaseAddress, Byte* lpBuffer, IntPtr dwSize, IntPtr& lpNumberOfBytesRead);
    internal static int VirtualQueryEx(IntPtr hProcess, IntPtr lpAddress, MEMORY_BASIC_INFORMATION& lpBuffer, IntPtr dwLength);
    private static bool GetThreadContext(IntPtr hThread, IntPtr lpContext);
    [NullableContextAttribute("1")]
internal static SafeWin32Handle OpenThread(ThreadAccess dwDesiredAccess, bool bInheritHandle, UInt32 dwThreadId);
    internal static int SuspendThread(IntPtr hThread);
    internal static int ResumeThread(IntPtr hThread);
    private static int PssCaptureSnapshot(IntPtr ProcessHandle, PSS_CAPTURE_FLAGS CaptureFlags, int ThreadContextFlags, IntPtr& SnapshotHandle);
    private static int PssFreeSnapshot(IntPtr ProcessHandle, IntPtr SnapshotHandle);
    private static int PssQuerySnapshot(IntPtr SnapshotHandle, PSS_QUERY_INFORMATION_CLASS InformationClass, IntPtr& Buffer, int BufferLength);
    private static int GetProcessId(IntPtr hObject);
}
internal enum Microsoft.Diagnostics.Runtime.WindowsProcessDataReaderMode : Enum {
    public int value__;
    public static WindowsProcessDataReaderMode Suspend;
    public static WindowsProcessDataReaderMode Snapshot;
    public static WindowsProcessDataReaderMode Passive;
}
public class Microsoft.Diagnostics.Runtime.X86Context : ValueType {
    public static UInt32 Context;
    public static UInt32 ContextControl;
    public static UInt32 ContextInteger;
    public static UInt32 ContextSegments;
    public static UInt32 ContextFloatingPoint;
    public static UInt32 ContextDebugRegisters;
    public UInt32 ContextFlags;
    [RegisterAttribute("5")]
public UInt32 Dr0;
    [RegisterAttribute("5")]
public UInt32 Dr1;
    [RegisterAttribute("5")]
public UInt32 Dr2;
    [RegisterAttribute("5")]
public UInt32 Dr3;
    [RegisterAttribute("5")]
public UInt32 Dr6;
    [RegisterAttribute("5")]
public UInt32 Dr7;
    [RegisterAttribute("4")]
public UInt32 ControlWord;
    [RegisterAttribute("4")]
public UInt32 StatusWord;
    [RegisterAttribute("4")]
public UInt32 TagWord;
    [RegisterAttribute("4")]
public UInt32 ErrorOffset;
    [RegisterAttribute("4")]
public UInt32 ErrorSelector;
    [RegisterAttribute("4")]
public UInt32 DataOffset;
    [RegisterAttribute("4")]
public UInt32 DataSelector;
    [RegisterAttribute("4")]
public Float80 ST0;
    [RegisterAttribute("4")]
public Float80 ST1;
    [RegisterAttribute("4")]
public Float80 ST2;
    [RegisterAttribute("4")]
public Float80 ST3;
    [RegisterAttribute("4")]
public Float80 ST4;
    [RegisterAttribute("4")]
public Float80 ST5;
    [RegisterAttribute("4")]
public Float80 ST6;
    [RegisterAttribute("4")]
public Float80 ST7;
    [RegisterAttribute("4")]
public UInt32 Cr0NpxState;
    [RegisterAttribute("3")]
public UInt32 Gs;
    [RegisterAttribute("3")]
public UInt32 Fs;
    [RegisterAttribute("3")]
public UInt32 Es;
    [RegisterAttribute("3")]
public UInt32 Ds;
    [RegisterAttribute("1")]
public UInt32 Edi;
    [RegisterAttribute("1")]
public UInt32 Esi;
    [RegisterAttribute("1")]
public UInt32 Ebx;
    [RegisterAttribute("1")]
public UInt32 Edx;
    [RegisterAttribute("1")]
public UInt32 Ecx;
    [RegisterAttribute("1")]
public UInt32 Eax;
    [RegisterAttribute("66")]
public UInt32 Ebp;
    [RegisterAttribute("18")]
public UInt32 Eip;
    [RegisterAttribute("3")]
public UInt32 Cs;
    [RegisterAttribute("1")]
public UInt32 EFlags;
    [RegisterAttribute("34")]
public UInt32 Esp;
    [RegisterAttribute("3")]
public UInt32 Ss;
    [FixedBufferAttribute("System.Byte", "512")]
public <ExtendedRegisters>e__FixedBuffer ExtendedRegisters;
    public static int Size { get; }
    public static int get_Size();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Microsoft.Diagnostics.Runtime.XmmSaveArea : ValueType {
    public static int HeaderSize;
    public static int LegacySize;
    public M128A[] Header;
    public M128A[] Legacy;
    public M128A Xmm0;
    public M128A Xmm1;
    public M128A Xmm2;
    public M128A Xmm3;
    public M128A Xmm4;
    public M128A Xmm5;
    public M128A Xmm6;
    public M128A Xmm7;
    public M128A Xmm8;
    public M128A Xmm9;
    public M128A Xmm10;
    public M128A Xmm11;
    public M128A Xmm12;
    public M128A Xmm13;
    public M128A Xmm14;
    public M128A Xmm15;
}
[AttributeUsageAttribute("100")]
internal class System.Diagnostics.CodeAnalysis.RequiresDynamicCodeAttribute : Attribute {
    [NullableContextAttribute("1")]
public RequiresDynamicCodeAttribute(string message);
}
[CompilerGeneratedAttribute]
[EmbeddedAttribute]
internal class System.Runtime.CompilerServices.IsUnmanagedAttribute : Attribute {
}
[CompilerGeneratedAttribute]
[EmbeddedAttribute]
[AttributeUsageAttribute("27524")]
internal class System.Runtime.CompilerServices.NativeIntegerAttribute : Attribute {
    public Boolean[] TransformFlags;
    public NativeIntegerAttribute(Boolean[] );
}
[CompilerGeneratedAttribute]
[EmbeddedAttribute]
[AttributeUsageAttribute("27524")]
internal class System.Runtime.CompilerServices.NullableAttribute : Attribute {
    public Byte[] NullableFlags;
    public NullableAttribute(byte );
    public NullableAttribute(Byte[] );
}
[CompilerGeneratedAttribute]
[EmbeddedAttribute]
[AttributeUsageAttribute("5196")]
internal class System.Runtime.CompilerServices.NullableContextAttribute : Attribute {
    public byte Flag;
    public NullableContextAttribute(byte );
}
[CompilerGeneratedAttribute]
[EmbeddedAttribute]
[AttributeUsageAttribute("2")]
internal class System.Runtime.CompilerServices.RefSafetyRulesAttribute : Attribute {
    public int Version;
    public RefSafetyRulesAttribute(int );
}
