[IsByRefLikeAttribute]
[ObsoleteAttribute("Types with embedded references are not supported in this version of your compiler.", "True")]
internal class MessagePack.BufferWriter : ValueType {
    private IBufferWriter`1<byte> _output;
    private Span`1<byte> _span;
    private ArraySegment`1<byte> _segment;
    private int _buffered;
    private long _bytesCommitted;
    private SequencePool _sequencePool;
    private Rental _rental;
    public Span`1<byte> Span { get; }
    public long BytesCommitted { get; }
    internal IBufferWriter`1<byte> UnderlyingWriter { get; }
    internal Rental SequenceRental { get; }
    public BufferWriter(IBufferWriter`1<byte> output);
    internal BufferWriter(SequencePool sequencePool, Byte[] array);
    public Span`1<byte> get_Span();
    public long get_BytesCommitted();
    internal IBufferWriter`1<byte> get_UnderlyingWriter();
    internal Rental get_SequenceRental();
    public Span`1<byte> GetSpan(int sizeHint);
    public Byte& GetPointer(int sizeHint);
    public void Commit();
    public void Advance(int count);
    public void Write(ReadOnlySpan`1<byte> source);
    public void Ensure(int count);
    internal bool TryGetUncommittedSpan(ReadOnlySpan`1& span);
    private void EnsureMore(int count);
    private void WriteMultiBuffer(ReadOnlySpan`1<byte> source);
    private void MigrateToSequence();
}
public class MessagePack.ExtensionHeader : ValueType {
    [CompilerGeneratedAttribute]
private sbyte <TypeCode>k__BackingField;
    [CompilerGeneratedAttribute]
private UInt32 <Length>k__BackingField;
    public sbyte TypeCode { get; private set; }
    public UInt32 Length { get; private set; }
    public ExtensionHeader(sbyte typeCode, UInt32 length);
    public ExtensionHeader(sbyte typeCode, int length);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public sbyte get_TypeCode();
    [CompilerGeneratedAttribute]
private void set_TypeCode(sbyte value);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public UInt32 get_Length();
    [CompilerGeneratedAttribute]
private void set_Length(UInt32 value);
    public sealed virtual bool Equals(ExtensionHeader other);
}
public class MessagePack.ExtensionResult : ValueType {
    [CompilerGeneratedAttribute]
private sbyte <TypeCode>k__BackingField;
    [CompilerGeneratedAttribute]
private ReadOnlySequence`1<byte> <Data>k__BackingField;
    public sbyte TypeCode { get; private set; }
    public ReadOnlySequence`1<byte> Data { get; private set; }
    public ExtensionHeader Header { get; }
    public ExtensionResult(sbyte typeCode, Memory`1<byte> data);
    public ExtensionResult(sbyte typeCode, ReadOnlySequence`1<byte> data);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public sbyte get_TypeCode();
    [CompilerGeneratedAttribute]
private void set_TypeCode(sbyte value);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public ReadOnlySequence`1<byte> get_Data();
    [CompilerGeneratedAttribute]
private void set_Data(ReadOnlySequence`1<byte> value);
    public ExtensionHeader get_Header();
}
public class MessagePack.FormatterNotRegisteredException : MessagePackSerializationException {
    public FormatterNotRegisteredException(string message);
}
[ExtensionAttribute]
public static class MessagePack.FormatterResolverExtensions : object {
    private static ThreadsafeTypeKeyHashTable`1<Func`2<IFormatterResolver, IMessagePackFormatter>> FormatterGetters;
    private static MethodInfo GetFormatterRuntimeMethod;
    private static FormatterResolverExtensions();
    [ExtensionAttribute]
public static IMessagePackFormatter`1<T> GetFormatterWithVerify(IFormatterResolver resolver);
    private static void Throw(TypeInitializationException ex);
    private static void Throw(Type t, IFormatterResolver resolver);
    [ExtensionAttribute]
public static object GetFormatterDynamic(IFormatterResolver resolver, Type type);
    [ExtensionAttribute]
internal static object GetFormatterDynamicWithVerify(IFormatterResolver resolver, Type type);
}
public class MessagePack.Formatters.ArrayFormatter`1 : object {
    public sealed virtual void Serialize(MessagePackWriter& writer, T[] value, MessagePackSerializerOptions options);
    public sealed virtual T[] Deserialize(MessagePackReader& reader, MessagePackSerializerOptions options);
}
public class MessagePack.Formatters.ArraySegmentFormatter`1 : object {
    public sealed virtual void Serialize(MessagePackWriter& writer, ArraySegment`1<T> value, MessagePackSerializerOptions options);
    public sealed virtual ArraySegment`1<T> Deserialize(MessagePackReader& reader, MessagePackSerializerOptions options);
}
public class MessagePack.Formatters.BigIntegerFormatter : object {
    public static IMessagePackFormatter`1<BigInteger> Instance;
    private static BigIntegerFormatter();
    public sealed virtual void Serialize(MessagePackWriter& writer, BigInteger value, MessagePackSerializerOptions options);
    public sealed virtual BigInteger Deserialize(MessagePackReader& reader, MessagePackSerializerOptions options);
}
public class MessagePack.Formatters.BitArrayFormatter : object {
    public static IMessagePackFormatter`1<BitArray> Instance;
    private static BitArrayFormatter();
    public sealed virtual void Serialize(MessagePackWriter& writer, BitArray value, MessagePackSerializerOptions options);
    public sealed virtual BitArray Deserialize(MessagePackReader& reader, MessagePackSerializerOptions options);
}
public class MessagePack.Formatters.BooleanArrayFormatter : object {
    public static BooleanArrayFormatter Instance;
    private static BooleanArrayFormatter();
    public sealed virtual void Serialize(MessagePackWriter& writer, Boolean[] value, MessagePackSerializerOptions options);
    public sealed virtual Boolean[] Deserialize(MessagePackReader& reader, MessagePackSerializerOptions options);
}
public class MessagePack.Formatters.BooleanFormatter : object {
    public static BooleanFormatter Instance;
    private static BooleanFormatter();
    public sealed virtual void Serialize(MessagePackWriter& writer, bool value, MessagePackSerializerOptions options);
    public sealed virtual bool Deserialize(MessagePackReader& reader, MessagePackSerializerOptions options);
}
public class MessagePack.Formatters.ByteArrayFormatter : object {
    public static ByteArrayFormatter Instance;
    private static ByteArrayFormatter();
    public sealed virtual void Serialize(MessagePackWriter& writer, Byte[] value, MessagePackSerializerOptions options);
    public sealed virtual Byte[] Deserialize(MessagePackReader& reader, MessagePackSerializerOptions options);
}
public class MessagePack.Formatters.ByteArraySegmentFormatter : object {
    public static ByteArraySegmentFormatter Instance;
    private static ByteArraySegmentFormatter();
    public sealed virtual void Serialize(MessagePackWriter& writer, ArraySegment`1<byte> value, MessagePackSerializerOptions options);
    public sealed virtual ArraySegment`1<byte> Deserialize(MessagePackReader& reader, MessagePackSerializerOptions options);
}
public class MessagePack.Formatters.ByteFormatter : object {
    public static ByteFormatter Instance;
    private static ByteFormatter();
    public sealed virtual void Serialize(MessagePackWriter& writer, byte value, MessagePackSerializerOptions options);
    public sealed virtual byte Deserialize(MessagePackReader& reader, MessagePackSerializerOptions options);
}
public class MessagePack.Formatters.CharArrayFormatter : object {
    public static CharArrayFormatter Instance;
    private static CharArrayFormatter();
    public sealed virtual void Serialize(MessagePackWriter& writer, Char[] value, MessagePackSerializerOptions options);
    public sealed virtual Char[] Deserialize(MessagePackReader& reader, MessagePackSerializerOptions options);
}
public class MessagePack.Formatters.CharFormatter : object {
    public static CharFormatter Instance;
    private static CharFormatter();
    public sealed virtual void Serialize(MessagePackWriter& writer, char value, MessagePackSerializerOptions options);
    public sealed virtual char Deserialize(MessagePackReader& reader, MessagePackSerializerOptions options);
}
public abstract class MessagePack.Formatters.CollectionFormatterBase`2 : CollectionFormatterBase`3<TElement, TCollection, TCollection> {
    protected sealed virtual TCollection Complete(TCollection intermediateCollection);
}
public abstract class MessagePack.Formatters.CollectionFormatterBase`3 : CollectionFormatterBase`4<TElement, TIntermediate, IEnumerator`1<TElement>, TCollection> {
    protected virtual IEnumerator`1<TElement> GetSourceEnumerator(TCollection source);
}
public abstract class MessagePack.Formatters.CollectionFormatterBase`4 : object {
    public sealed virtual void Serialize(MessagePackWriter& writer, TCollection value, MessagePackSerializerOptions options);
    public sealed virtual TCollection Deserialize(MessagePackReader& reader, MessagePackSerializerOptions options);
    protected virtual Nullable`1<int> GetCount(TCollection sequence);
    protected abstract virtual TEnumerator GetSourceEnumerator(TCollection source);
    protected abstract virtual TIntermediate Create(int count, MessagePackSerializerOptions options);
    protected abstract virtual void Add(TIntermediate collection, int index, TElement value, MessagePackSerializerOptions options);
    protected abstract virtual TCollection Complete(TIntermediate intermediateCollection);
}
internal static class MessagePack.Formatters.CollectionHelpers`2 : object {
    private static Func`3<int, TEqualityComparer, TCollection> collectionCreator;
    private static CollectionHelpers`2();
    internal static TCollection CreateHashCollection(int count, TEqualityComparer equalityComparer);
}
public class MessagePack.Formatters.ComplexFormatter : object {
    public static IMessagePackFormatter`1<Complex> Instance;
    private static ComplexFormatter();
    public sealed virtual void Serialize(MessagePackWriter& writer, Complex value, MessagePackSerializerOptions options);
    public sealed virtual Complex Deserialize(MessagePackReader& reader, MessagePackSerializerOptions options);
}
public class MessagePack.Formatters.ConcurrentBagFormatter`1 : CollectionFormatterBase`2<T, ConcurrentBag`1<T>> {
    protected virtual Nullable`1<int> GetCount(ConcurrentBag`1<T> sequence);
    protected virtual void Add(ConcurrentBag`1<T> collection, int index, T value, MessagePackSerializerOptions options);
    protected virtual ConcurrentBag`1<T> Create(int count, MessagePackSerializerOptions options);
}
public class MessagePack.Formatters.ConcurrentDictionaryFormatter`2 : DictionaryFormatterBase`3<TKey, TValue, ConcurrentDictionary`2<TKey, TValue>> {
    protected virtual void Add(ConcurrentDictionary`2<TKey, TValue> collection, int index, TKey key, TValue value, MessagePackSerializerOptions options);
    protected virtual ConcurrentDictionary`2<TKey, TValue> Create(int count, MessagePackSerializerOptions options);
}
public class MessagePack.Formatters.ConcurrentQueueFormatter`1 : CollectionFormatterBase`2<T, ConcurrentQueue`1<T>> {
    protected virtual Nullable`1<int> GetCount(ConcurrentQueue`1<T> sequence);
    protected virtual void Add(ConcurrentQueue`1<T> collection, int index, T value, MessagePackSerializerOptions options);
    protected virtual ConcurrentQueue`1<T> Create(int count, MessagePackSerializerOptions options);
}
public class MessagePack.Formatters.ConcurrentStackFormatter`1 : CollectionFormatterBase`3<T, T[], ConcurrentStack`1<T>> {
    protected virtual Nullable`1<int> GetCount(ConcurrentStack`1<T> sequence);
    protected virtual void Add(T[] collection, int index, T value, MessagePackSerializerOptions options);
    protected virtual T[] Create(int count, MessagePackSerializerOptions options);
    protected virtual ConcurrentStack`1<T> Complete(T[] intermediateCollection);
}
public class MessagePack.Formatters.DateTimeArrayFormatter : object {
    public static DateTimeArrayFormatter Instance;
    private static DateTimeArrayFormatter();
    public sealed virtual void Serialize(MessagePackWriter& writer, DateTime[] value, MessagePackSerializerOptions options);
    public sealed virtual DateTime[] Deserialize(MessagePackReader& reader, MessagePackSerializerOptions options);
}
public class MessagePack.Formatters.DateTimeFormatter : object {
    public static DateTimeFormatter Instance;
    private static DateTimeFormatter();
    public sealed virtual void Serialize(MessagePackWriter& writer, DateTime value, MessagePackSerializerOptions options);
    public sealed virtual DateTime Deserialize(MessagePackReader& reader, MessagePackSerializerOptions options);
}
public class MessagePack.Formatters.DateTimeOffsetFormatter : object {
    public static IMessagePackFormatter`1<DateTimeOffset> Instance;
    private static DateTimeOffsetFormatter();
    public sealed virtual void Serialize(MessagePackWriter& writer, DateTimeOffset value, MessagePackSerializerOptions options);
    public sealed virtual DateTimeOffset Deserialize(MessagePackReader& reader, MessagePackSerializerOptions options);
}
public class MessagePack.Formatters.DecimalFormatter : object {
    public static DecimalFormatter Instance;
    private static DecimalFormatter();
    public sealed virtual void Serialize(MessagePackWriter& writer, decimal value, MessagePackSerializerOptions options);
    public sealed virtual decimal Deserialize(MessagePackReader& reader, MessagePackSerializerOptions options);
}
public class MessagePack.Formatters.DictionaryFormatter`2 : DictionaryFormatterBase`5<TKey, TValue, Dictionary`2<TKey, TValue>, Enumerator<TKey, TValue>, Dictionary`2<TKey, TValue>> {
    protected virtual void Add(Dictionary`2<TKey, TValue> collection, int index, TKey key, TValue value, MessagePackSerializerOptions options);
    protected virtual Dictionary`2<TKey, TValue> Complete(Dictionary`2<TKey, TValue> intermediateCollection);
    protected virtual Dictionary`2<TKey, TValue> Create(int count, MessagePackSerializerOptions options);
    protected virtual Enumerator<TKey, TValue> GetSourceEnumerator(Dictionary`2<TKey, TValue> source);
}
public abstract class MessagePack.Formatters.DictionaryFormatterBase`3 : DictionaryFormatterBase`4<TKey, TValue, TDictionary, TDictionary> {
    protected virtual TDictionary Complete(TDictionary intermediateCollection);
}
public abstract class MessagePack.Formatters.DictionaryFormatterBase`4 : DictionaryFormatterBase`5<TKey, TValue, TIntermediate, IEnumerator`1<KeyValuePair`2<TKey, TValue>>, TDictionary> {
    protected virtual IEnumerator`1<KeyValuePair`2<TKey, TValue>> GetSourceEnumerator(TDictionary source);
}
public abstract class MessagePack.Formatters.DictionaryFormatterBase`5 : object {
    public sealed virtual void Serialize(MessagePackWriter& writer, TDictionary value, MessagePackSerializerOptions options);
    public sealed virtual TDictionary Deserialize(MessagePackReader& reader, MessagePackSerializerOptions options);
    protected abstract virtual TEnumerator GetSourceEnumerator(TDictionary source);
    protected abstract virtual TIntermediate Create(int count, MessagePackSerializerOptions options);
    protected abstract virtual void Add(TIntermediate collection, int index, TKey key, TValue value, MessagePackSerializerOptions options);
    protected abstract virtual TDictionary Complete(TIntermediate intermediateCollection);
}
public class MessagePack.Formatters.DoubleArrayFormatter : object {
    public static DoubleArrayFormatter Instance;
    private static DoubleArrayFormatter();
    public sealed virtual void Serialize(MessagePackWriter& writer, Double[] value, MessagePackSerializerOptions options);
    public sealed virtual Double[] Deserialize(MessagePackReader& reader, MessagePackSerializerOptions options);
}
public class MessagePack.Formatters.DoubleFormatter : object {
    public static DoubleFormatter Instance;
    private static DoubleFormatter();
    public sealed virtual void Serialize(MessagePackWriter& writer, double value, MessagePackSerializerOptions options);
    public sealed virtual double Deserialize(MessagePackReader& reader, MessagePackSerializerOptions options);
}
public class MessagePack.Formatters.DynamicObjectTypeFallbackFormatter : object {
    public static IMessagePackFormatter`1<object> Instance;
    private static ThreadsafeTypeKeyHashTable`1<SerializeMethod> SerializerDelegates;
    private static DynamicObjectTypeFallbackFormatter();
    public sealed virtual void Serialize(MessagePackWriter& writer, object value, MessagePackSerializerOptions options);
    public sealed virtual object Deserialize(MessagePackReader& reader, MessagePackSerializerOptions options);
}
public class MessagePack.Formatters.EnumAsStringFormatter`1 : object {
    private IReadOnlyDictionary`2<string, T> nameValueMapping;
    private IReadOnlyDictionary`2<T, string> valueNameMapping;
    private IReadOnlyDictionary`2<string, string> clrToSerializationName;
    private IReadOnlyDictionary`2<string, string> serializationToClrName;
    private bool enumMemberOverridesPresent;
    private bool isFlags;
    public sealed virtual void Serialize(MessagePackWriter& writer, T value, MessagePackSerializerOptions options);
    public sealed virtual T Deserialize(MessagePackReader& reader, MessagePackSerializerOptions options);
    private string GetClrNames(string serializedNames);
    private string GetSerializedNames(string clrNames);
    private static string Translate(string items, IReadOnlyDictionary`2<string, string> mapping);
}
public class MessagePack.Formatters.ForceByteBlockFormatter : object {
    public static ForceByteBlockFormatter Instance;
    private static ForceByteBlockFormatter();
    public sealed virtual void Serialize(MessagePackWriter& writer, byte value, MessagePackSerializerOptions options);
    public sealed virtual byte Deserialize(MessagePackReader& reader, MessagePackSerializerOptions options);
}
public class MessagePack.Formatters.ForceInt16BlockArrayFormatter : object {
    public static ForceInt16BlockArrayFormatter Instance;
    private static ForceInt16BlockArrayFormatter();
    public sealed virtual void Serialize(MessagePackWriter& writer, Int16[] value, MessagePackSerializerOptions options);
    public sealed virtual Int16[] Deserialize(MessagePackReader& reader, MessagePackSerializerOptions options);
}
public class MessagePack.Formatters.ForceInt16BlockFormatter : object {
    public static ForceInt16BlockFormatter Instance;
    private static ForceInt16BlockFormatter();
    public sealed virtual void Serialize(MessagePackWriter& writer, short value, MessagePackSerializerOptions options);
    public sealed virtual short Deserialize(MessagePackReader& reader, MessagePackSerializerOptions options);
}
public class MessagePack.Formatters.ForceInt32BlockArrayFormatter : object {
    public static ForceInt32BlockArrayFormatter Instance;
    private static ForceInt32BlockArrayFormatter();
    public sealed virtual void Serialize(MessagePackWriter& writer, Int32[] value, MessagePackSerializerOptions options);
    public sealed virtual Int32[] Deserialize(MessagePackReader& reader, MessagePackSerializerOptions options);
}
public class MessagePack.Formatters.ForceInt32BlockFormatter : object {
    public static ForceInt32BlockFormatter Instance;
    private static ForceInt32BlockFormatter();
    public sealed virtual void Serialize(MessagePackWriter& writer, int value, MessagePackSerializerOptions options);
    public sealed virtual int Deserialize(MessagePackReader& reader, MessagePackSerializerOptions options);
}
public class MessagePack.Formatters.ForceInt64BlockArrayFormatter : object {
    public static ForceInt64BlockArrayFormatter Instance;
    private static ForceInt64BlockArrayFormatter();
    public sealed virtual void Serialize(MessagePackWriter& writer, Int64[] value, MessagePackSerializerOptions options);
    public sealed virtual Int64[] Deserialize(MessagePackReader& reader, MessagePackSerializerOptions options);
}
public class MessagePack.Formatters.ForceInt64BlockFormatter : object {
    public static ForceInt64BlockFormatter Instance;
    private static ForceInt64BlockFormatter();
    public sealed virtual void Serialize(MessagePackWriter& writer, long value, MessagePackSerializerOptions options);
    public sealed virtual long Deserialize(MessagePackReader& reader, MessagePackSerializerOptions options);
}
public class MessagePack.Formatters.ForceSByteBlockArrayFormatter : object {
    public static ForceSByteBlockArrayFormatter Instance;
    private static ForceSByteBlockArrayFormatter();
    public sealed virtual void Serialize(MessagePackWriter& writer, SByte[] value, MessagePackSerializerOptions options);
    public sealed virtual SByte[] Deserialize(MessagePackReader& reader, MessagePackSerializerOptions options);
}
public class MessagePack.Formatters.ForceSByteBlockFormatter : object {
    public static ForceSByteBlockFormatter Instance;
    private static ForceSByteBlockFormatter();
    public sealed virtual void Serialize(MessagePackWriter& writer, sbyte value, MessagePackSerializerOptions options);
    public sealed virtual sbyte Deserialize(MessagePackReader& reader, MessagePackSerializerOptions options);
}
public class MessagePack.Formatters.ForceUInt16BlockArrayFormatter : object {
    public static ForceUInt16BlockArrayFormatter Instance;
    private static ForceUInt16BlockArrayFormatter();
    public sealed virtual void Serialize(MessagePackWriter& writer, UInt16[] value, MessagePackSerializerOptions options);
    public sealed virtual UInt16[] Deserialize(MessagePackReader& reader, MessagePackSerializerOptions options);
}
public class MessagePack.Formatters.ForceUInt16BlockFormatter : object {
    public static ForceUInt16BlockFormatter Instance;
    private static ForceUInt16BlockFormatter();
    public sealed virtual void Serialize(MessagePackWriter& writer, ushort value, MessagePackSerializerOptions options);
    public sealed virtual ushort Deserialize(MessagePackReader& reader, MessagePackSerializerOptions options);
}
public class MessagePack.Formatters.ForceUInt32BlockArrayFormatter : object {
    public static ForceUInt32BlockArrayFormatter Instance;
    private static ForceUInt32BlockArrayFormatter();
    public sealed virtual void Serialize(MessagePackWriter& writer, UInt32[] value, MessagePackSerializerOptions options);
    public sealed virtual UInt32[] Deserialize(MessagePackReader& reader, MessagePackSerializerOptions options);
}
public class MessagePack.Formatters.ForceUInt32BlockFormatter : object {
    public static ForceUInt32BlockFormatter Instance;
    private static ForceUInt32BlockFormatter();
    public sealed virtual void Serialize(MessagePackWriter& writer, UInt32 value, MessagePackSerializerOptions options);
    public sealed virtual UInt32 Deserialize(MessagePackReader& reader, MessagePackSerializerOptions options);
}
public class MessagePack.Formatters.ForceUInt64BlockArrayFormatter : object {
    public static ForceUInt64BlockArrayFormatter Instance;
    private static ForceUInt64BlockArrayFormatter();
    public sealed virtual void Serialize(MessagePackWriter& writer, UInt64[] value, MessagePackSerializerOptions options);
    public sealed virtual UInt64[] Deserialize(MessagePackReader& reader, MessagePackSerializerOptions options);
}
public class MessagePack.Formatters.ForceUInt64BlockFormatter : object {
    public static ForceUInt64BlockFormatter Instance;
    private static ForceUInt64BlockFormatter();
    public sealed virtual void Serialize(MessagePackWriter& writer, ulong value, MessagePackSerializerOptions options);
    public sealed virtual ulong Deserialize(MessagePackReader& reader, MessagePackSerializerOptions options);
}
public class MessagePack.Formatters.FourDimensionalArrayFormatter`1 : object {
    private static int ArrayLength;
    public sealed virtual void Serialize(MessagePackWriter& writer, T[0...,0...,0...,0...] value, MessagePackSerializerOptions options);
    public sealed virtual T[0...,0...,0...,0...] Deserialize(MessagePackReader& reader, MessagePackSerializerOptions options);
}
public class MessagePack.Formatters.GenericCollectionFormatter`2 : CollectionFormatterBase`2<TElement, TCollection> {
    protected virtual TCollection Create(int count, MessagePackSerializerOptions options);
    protected virtual void Add(TCollection collection, int index, TElement value, MessagePackSerializerOptions options);
}
public class MessagePack.Formatters.GenericDictionaryFormatter`3 : DictionaryFormatterBase`3<TKey, TValue, TDictionary> {
    protected virtual void Add(TDictionary collection, int index, TKey key, TValue value, MessagePackSerializerOptions options);
    protected virtual TDictionary Create(int count, MessagePackSerializerOptions options);
}
public class MessagePack.Formatters.GenericEnumFormatter`1 : object {
    private EnumSerialize<T> serializer;
    private EnumDeserialize<T> deserializer;
    public sealed virtual void Serialize(MessagePackWriter& writer, T value, MessagePackSerializerOptions options);
    public sealed virtual T Deserialize(MessagePackReader& reader, MessagePackSerializerOptions options);
}
internal class MessagePack.Formatters.Grouping`2 : object {
    private TKey key;
    private IEnumerable`1<TElement> elements;
    public TKey Key { get; }
    public Grouping`2(TKey key, IEnumerable`1<TElement> elements);
    public sealed virtual TKey get_Key();
    public sealed virtual IEnumerator`1<TElement> GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
}
public class MessagePack.Formatters.GuidFormatter : object {
    public static IMessagePackFormatter`1<Guid> Instance;
    private static GuidFormatter();
    public sealed virtual void Serialize(MessagePackWriter& writer, Guid value, MessagePackSerializerOptions options);
    public sealed virtual Guid Deserialize(MessagePackReader& reader, MessagePackSerializerOptions options);
}
public class MessagePack.Formatters.HashSetFormatter`1 : CollectionFormatterBase`4<T, HashSet`1<T>, Enumerator<T>, HashSet`1<T>> {
    protected virtual Nullable`1<int> GetCount(HashSet`1<T> sequence);
    protected virtual void Add(HashSet`1<T> collection, int index, T value, MessagePackSerializerOptions options);
    protected virtual HashSet`1<T> Complete(HashSet`1<T> intermediateCollection);
    protected virtual HashSet`1<T> Create(int count, MessagePackSerializerOptions options);
    protected virtual Enumerator<T> GetSourceEnumerator(HashSet`1<T> source);
}
public class MessagePack.Formatters.IgnoreFormatter`1 : object {
    public sealed virtual void Serialize(MessagePackWriter& writer, T value, MessagePackSerializerOptions options);
    public sealed virtual T Deserialize(MessagePackReader& reader, MessagePackSerializerOptions options);
}
[EditorBrowsableAttribute("1")]
public interface MessagePack.Formatters.IMessagePackFormatter {
}
public interface MessagePack.Formatters.IMessagePackFormatter`1 {
    public abstract virtual void Serialize(MessagePackWriter& writer, T value, MessagePackSerializerOptions options);
    public abstract virtual T Deserialize(MessagePackReader& reader, MessagePackSerializerOptions options);
}
public class MessagePack.Formatters.Int16ArrayFormatter : object {
    public static Int16ArrayFormatter Instance;
    private static Int16ArrayFormatter();
    public sealed virtual void Serialize(MessagePackWriter& writer, Int16[] value, MessagePackSerializerOptions options);
    public sealed virtual Int16[] Deserialize(MessagePackReader& reader, MessagePackSerializerOptions options);
}
public class MessagePack.Formatters.Int16Formatter : object {
    public static Int16Formatter Instance;
    private static Int16Formatter();
    public sealed virtual void Serialize(MessagePackWriter& writer, short value, MessagePackSerializerOptions options);
    public sealed virtual short Deserialize(MessagePackReader& reader, MessagePackSerializerOptions options);
}
public class MessagePack.Formatters.Int32ArrayFormatter : object {
    public static Int32ArrayFormatter Instance;
    private static Int32ArrayFormatter();
    public sealed virtual void Serialize(MessagePackWriter& writer, Int32[] value, MessagePackSerializerOptions options);
    public sealed virtual Int32[] Deserialize(MessagePackReader& reader, MessagePackSerializerOptions options);
}
public class MessagePack.Formatters.Int32Formatter : object {
    public static Int32Formatter Instance;
    private static Int32Formatter();
    public sealed virtual void Serialize(MessagePackWriter& writer, int value, MessagePackSerializerOptions options);
    public sealed virtual int Deserialize(MessagePackReader& reader, MessagePackSerializerOptions options);
}
public class MessagePack.Formatters.Int64ArrayFormatter : object {
    public static Int64ArrayFormatter Instance;
    private static Int64ArrayFormatter();
    public sealed virtual void Serialize(MessagePackWriter& writer, Int64[] value, MessagePackSerializerOptions options);
    public sealed virtual Int64[] Deserialize(MessagePackReader& reader, MessagePackSerializerOptions options);
}
public class MessagePack.Formatters.Int64Formatter : object {
    public static Int64Formatter Instance;
    private static Int64Formatter();
    public sealed virtual void Serialize(MessagePackWriter& writer, long value, MessagePackSerializerOptions options);
    public sealed virtual long Deserialize(MessagePackReader& reader, MessagePackSerializerOptions options);
}
[ObsoleteAttribute("Use InterfaceCollectionFormatter2 instead.")]
public class MessagePack.Formatters.InterfaceCollectionFormatter`1 : CollectionFormatterBase`3<T, T[], ICollection`1<T>> {
    protected virtual void Add(T[] collection, int index, T value, MessagePackSerializerOptions options);
    protected virtual T[] Create(int count, MessagePackSerializerOptions options);
    protected virtual ICollection`1<T> Complete(T[] intermediateCollection);
}
public class MessagePack.Formatters.InterfaceCollectionFormatter2`1 : CollectionFormatterBase`3<T, List`1<T>, ICollection`1<T>> {
    protected virtual void Add(List`1<T> collection, int index, T value, MessagePackSerializerOptions options);
    protected virtual List`1<T> Create(int count, MessagePackSerializerOptions options);
    protected virtual ICollection`1<T> Complete(List`1<T> intermediateCollection);
}
public class MessagePack.Formatters.InterfaceDictionaryFormatter`2 : DictionaryFormatterBase`4<TKey, TValue, Dictionary`2<TKey, TValue>, IDictionary`2<TKey, TValue>> {
    protected virtual void Add(Dictionary`2<TKey, TValue> collection, int index, TKey key, TValue value, MessagePackSerializerOptions options);
    protected virtual Dictionary`2<TKey, TValue> Create(int count, MessagePackSerializerOptions options);
    protected virtual IDictionary`2<TKey, TValue> Complete(Dictionary`2<TKey, TValue> intermediateCollection);
}
public class MessagePack.Formatters.InterfaceEnumerableFormatter`1 : CollectionFormatterBase`3<T, T[], IEnumerable`1<T>> {
    protected virtual void Add(T[] collection, int index, T value, MessagePackSerializerOptions options);
    protected virtual T[] Create(int count, MessagePackSerializerOptions options);
    protected virtual IEnumerable`1<T> Complete(T[] intermediateCollection);
}
public class MessagePack.Formatters.InterfaceGroupingFormatter`2 : object {
    public sealed virtual void Serialize(MessagePackWriter& writer, IGrouping`2<TKey, TElement> value, MessagePackSerializerOptions options);
    public sealed virtual IGrouping`2<TKey, TElement> Deserialize(MessagePackReader& reader, MessagePackSerializerOptions options);
}
[ObsoleteAttribute("Use InterfaceListFormatter2 instead.")]
public class MessagePack.Formatters.InterfaceListFormatter`1 : CollectionFormatterBase`3<T, T[], IList`1<T>> {
    protected virtual void Add(T[] collection, int index, T value, MessagePackSerializerOptions options);
    protected virtual T[] Create(int count, MessagePackSerializerOptions options);
    protected virtual IList`1<T> Complete(T[] intermediateCollection);
}
public class MessagePack.Formatters.InterfaceListFormatter2`1 : CollectionFormatterBase`3<T, List`1<T>, IList`1<T>> {
    protected virtual void Add(List`1<T> collection, int index, T value, MessagePackSerializerOptions options);
    protected virtual List`1<T> Create(int count, MessagePackSerializerOptions options);
    protected virtual IList`1<T> Complete(List`1<T> intermediateCollection);
}
public class MessagePack.Formatters.InterfaceLookupFormatter`2 : CollectionFormatterBase`3<IGrouping`2<TKey, TElement>, Dictionary`2<TKey, IGrouping`2<TKey, TElement>>, ILookup`2<TKey, TElement>> {
    protected virtual void Add(Dictionary`2<TKey, IGrouping`2<TKey, TElement>> collection, int index, IGrouping`2<TKey, TElement> value, MessagePackSerializerOptions options);
    protected virtual ILookup`2<TKey, TElement> Complete(Dictionary`2<TKey, IGrouping`2<TKey, TElement>> intermediateCollection);
    protected virtual Dictionary`2<TKey, IGrouping`2<TKey, TElement>> Create(int count, MessagePackSerializerOptions options);
}
public class MessagePack.Formatters.InterfaceReadOnlyCollectionFormatter`1 : CollectionFormatterBase`3<T, T[], IReadOnlyCollection`1<T>> {
    protected virtual void Add(T[] collection, int index, T value, MessagePackSerializerOptions options);
    protected virtual T[] Create(int count, MessagePackSerializerOptions options);
    protected virtual IReadOnlyCollection`1<T> Complete(T[] intermediateCollection);
}
public class MessagePack.Formatters.InterfaceReadOnlyDictionaryFormatter`2 : DictionaryFormatterBase`4<TKey, TValue, Dictionary`2<TKey, TValue>, IReadOnlyDictionary`2<TKey, TValue>> {
    protected virtual void Add(Dictionary`2<TKey, TValue> collection, int index, TKey key, TValue value, MessagePackSerializerOptions options);
    protected virtual IReadOnlyDictionary`2<TKey, TValue> Complete(Dictionary`2<TKey, TValue> intermediateCollection);
    protected virtual Dictionary`2<TKey, TValue> Create(int count, MessagePackSerializerOptions options);
}
public class MessagePack.Formatters.InterfaceReadOnlyListFormatter`1 : CollectionFormatterBase`3<T, T[], IReadOnlyList`1<T>> {
    protected virtual void Add(T[] collection, int index, T value, MessagePackSerializerOptions options);
    protected virtual T[] Create(int count, MessagePackSerializerOptions options);
    protected virtual IReadOnlyList`1<T> Complete(T[] intermediateCollection);
}
public class MessagePack.Formatters.InterfaceSetFormatter`1 : CollectionFormatterBase`3<T, HashSet`1<T>, ISet`1<T>> {
    protected virtual void Add(HashSet`1<T> collection, int index, T value, MessagePackSerializerOptions options);
    protected virtual ISet`1<T> Complete(HashSet`1<T> intermediateCollection);
    protected virtual HashSet`1<T> Create(int count, MessagePackSerializerOptions options);
}
public class MessagePack.Formatters.KeyValuePairFormatter`2 : object {
    public sealed virtual void Serialize(MessagePackWriter& writer, KeyValuePair`2<TKey, TValue> value, MessagePackSerializerOptions options);
    public sealed virtual KeyValuePair`2<TKey, TValue> Deserialize(MessagePackReader& reader, MessagePackSerializerOptions options);
}
public class MessagePack.Formatters.LazyFormatter`1 : object {
    public sealed virtual void Serialize(MessagePackWriter& writer, Lazy`1<T> value, MessagePackSerializerOptions options);
    public sealed virtual Lazy`1<T> Deserialize(MessagePackReader& reader, MessagePackSerializerOptions options);
}
public class MessagePack.Formatters.LinkedListFormatter`1 : CollectionFormatterBase`4<T, LinkedList`1<T>, Enumerator<T>, LinkedList`1<T>> {
    protected virtual void Add(LinkedList`1<T> collection, int index, T value, MessagePackSerializerOptions options);
    protected virtual LinkedList`1<T> Complete(LinkedList`1<T> intermediateCollection);
    protected virtual LinkedList`1<T> Create(int count, MessagePackSerializerOptions options);
    protected virtual Enumerator<T> GetSourceEnumerator(LinkedList`1<T> source);
}
public class MessagePack.Formatters.ListFormatter`1 : object {
    public sealed virtual void Serialize(MessagePackWriter& writer, List`1<T> value, MessagePackSerializerOptions options);
    public sealed virtual List`1<T> Deserialize(MessagePackReader& reader, MessagePackSerializerOptions options);
}
[DefaultMemberAttribute("Item")]
internal class MessagePack.Formatters.Lookup`2 : object {
    private Dictionary`2<TKey, IGrouping`2<TKey, TElement>> groupings;
    public IEnumerable`1<TElement> Item { get; }
    public int Count { get; }
    public Lookup`2(Dictionary`2<TKey, IGrouping`2<TKey, TElement>> groupings);
    public sealed virtual IEnumerable`1<TElement> get_Item(TKey key);
    public sealed virtual int get_Count();
    public sealed virtual bool Contains(TKey key);
    public sealed virtual IEnumerator`1<IGrouping`2<TKey, TElement>> GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
}
public class MessagePack.Formatters.NativeDateTimeArrayFormatter : object {
    public static NativeDateTimeArrayFormatter Instance;
    private static NativeDateTimeArrayFormatter();
    public sealed virtual void Serialize(MessagePackWriter& writer, DateTime[] value, MessagePackSerializerOptions options);
    public sealed virtual DateTime[] Deserialize(MessagePackReader& reader, MessagePackSerializerOptions options);
}
public class MessagePack.Formatters.NativeDateTimeFormatter : object {
    public static NativeDateTimeFormatter Instance;
    private static NativeDateTimeFormatter();
    public sealed virtual void Serialize(MessagePackWriter& writer, DateTime value, MessagePackSerializerOptions options);
    public sealed virtual DateTime Deserialize(MessagePackReader& reader, MessagePackSerializerOptions options);
}
public class MessagePack.Formatters.NativeDecimalFormatter : object {
    public static IMessagePackFormatter`1<decimal> Instance;
    private static NativeDecimalFormatter();
    public sealed virtual void Serialize(MessagePackWriter& writer, decimal value, MessagePackSerializerOptions options);
    public sealed virtual decimal Deserialize(MessagePackReader& reader, MessagePackSerializerOptions options);
}
public class MessagePack.Formatters.NativeGuidFormatter : object {
    public static IMessagePackFormatter`1<Guid> Instance;
    private static NativeGuidFormatter();
    public sealed virtual void Serialize(MessagePackWriter& writer, Guid value, MessagePackSerializerOptions options);
    public sealed virtual Guid Deserialize(MessagePackReader& reader, MessagePackSerializerOptions options);
}
public class MessagePack.Formatters.NilFormatter : object {
    public static IMessagePackFormatter`1<Nil> Instance;
    private static NilFormatter();
    public sealed virtual void Serialize(MessagePackWriter& writer, Nil value, MessagePackSerializerOptions options);
    public sealed virtual Nil Deserialize(MessagePackReader& reader, MessagePackSerializerOptions options);
}
public class MessagePack.Formatters.NonGenericDictionaryFormatter`1 : object {
    public sealed virtual void Serialize(MessagePackWriter& writer, T value, MessagePackSerializerOptions options);
    public sealed virtual T Deserialize(MessagePackReader& reader, MessagePackSerializerOptions options);
}
public class MessagePack.Formatters.NonGenericInterfaceDictionaryFormatter : object {
    public static IMessagePackFormatter`1<IDictionary> Instance;
    private static NonGenericInterfaceDictionaryFormatter();
    public sealed virtual void Serialize(MessagePackWriter& writer, IDictionary value, MessagePackSerializerOptions options);
    public sealed virtual IDictionary Deserialize(MessagePackReader& reader, MessagePackSerializerOptions options);
}
public class MessagePack.Formatters.NonGenericInterfaceListFormatter : object {
    public static IMessagePackFormatter`1<IList> Instance;
    private static NonGenericInterfaceListFormatter();
    public sealed virtual void Serialize(MessagePackWriter& writer, IList value, MessagePackSerializerOptions options);
    public sealed virtual IList Deserialize(MessagePackReader& reader, MessagePackSerializerOptions options);
}
public class MessagePack.Formatters.NonGenericListFormatter`1 : object {
    public sealed virtual void Serialize(MessagePackWriter& writer, T value, MessagePackSerializerOptions options);
    public sealed virtual T Deserialize(MessagePackReader& reader, MessagePackSerializerOptions options);
}
public class MessagePack.Formatters.NullableBooleanFormatter : object {
    public static NullableBooleanFormatter Instance;
    private static NullableBooleanFormatter();
    public sealed virtual void Serialize(MessagePackWriter& writer, Nullable`1<bool> value, MessagePackSerializerOptions options);
    public sealed virtual Nullable`1<bool> Deserialize(MessagePackReader& reader, MessagePackSerializerOptions options);
}
public class MessagePack.Formatters.NullableByteFormatter : object {
    public static NullableByteFormatter Instance;
    private static NullableByteFormatter();
    public sealed virtual void Serialize(MessagePackWriter& writer, Nullable`1<byte> value, MessagePackSerializerOptions options);
    public sealed virtual Nullable`1<byte> Deserialize(MessagePackReader& reader, MessagePackSerializerOptions options);
}
public class MessagePack.Formatters.NullableCharFormatter : object {
    public static NullableCharFormatter Instance;
    private static NullableCharFormatter();
    public sealed virtual void Serialize(MessagePackWriter& writer, Nullable`1<char> value, MessagePackSerializerOptions options);
    public sealed virtual Nullable`1<char> Deserialize(MessagePackReader& reader, MessagePackSerializerOptions options);
}
public class MessagePack.Formatters.NullableDateTimeFormatter : object {
    public static NullableDateTimeFormatter Instance;
    private static NullableDateTimeFormatter();
    public sealed virtual void Serialize(MessagePackWriter& writer, Nullable`1<DateTime> value, MessagePackSerializerOptions options);
    public sealed virtual Nullable`1<DateTime> Deserialize(MessagePackReader& reader, MessagePackSerializerOptions options);
}
public class MessagePack.Formatters.NullableDoubleFormatter : object {
    public static NullableDoubleFormatter Instance;
    private static NullableDoubleFormatter();
    public sealed virtual void Serialize(MessagePackWriter& writer, Nullable`1<double> value, MessagePackSerializerOptions options);
    public sealed virtual Nullable`1<double> Deserialize(MessagePackReader& reader, MessagePackSerializerOptions options);
}
public class MessagePack.Formatters.NullableForceByteBlockFormatter : object {
    public static NullableForceByteBlockFormatter Instance;
    private static NullableForceByteBlockFormatter();
    public sealed virtual void Serialize(MessagePackWriter& writer, Nullable`1<byte> value, MessagePackSerializerOptions options);
    public sealed virtual Nullable`1<byte> Deserialize(MessagePackReader& reader, MessagePackSerializerOptions options);
}
public class MessagePack.Formatters.NullableForceInt16BlockFormatter : object {
    public static NullableForceInt16BlockFormatter Instance;
    private static NullableForceInt16BlockFormatter();
    public sealed virtual void Serialize(MessagePackWriter& writer, Nullable`1<short> value, MessagePackSerializerOptions options);
    public sealed virtual Nullable`1<short> Deserialize(MessagePackReader& reader, MessagePackSerializerOptions options);
}
public class MessagePack.Formatters.NullableForceInt32BlockFormatter : object {
    public static NullableForceInt32BlockFormatter Instance;
    private static NullableForceInt32BlockFormatter();
    public sealed virtual void Serialize(MessagePackWriter& writer, Nullable`1<int> value, MessagePackSerializerOptions options);
    public sealed virtual Nullable`1<int> Deserialize(MessagePackReader& reader, MessagePackSerializerOptions options);
}
public class MessagePack.Formatters.NullableForceInt64BlockFormatter : object {
    public static NullableForceInt64BlockFormatter Instance;
    private static NullableForceInt64BlockFormatter();
    public sealed virtual void Serialize(MessagePackWriter& writer, Nullable`1<long> value, MessagePackSerializerOptions options);
    public sealed virtual Nullable`1<long> Deserialize(MessagePackReader& reader, MessagePackSerializerOptions options);
}
public class MessagePack.Formatters.NullableForceSByteBlockFormatter : object {
    public static NullableForceSByteBlockFormatter Instance;
    private static NullableForceSByteBlockFormatter();
    public sealed virtual void Serialize(MessagePackWriter& writer, Nullable`1<sbyte> value, MessagePackSerializerOptions options);
    public sealed virtual Nullable`1<sbyte> Deserialize(MessagePackReader& reader, MessagePackSerializerOptions options);
}
public class MessagePack.Formatters.NullableForceUInt16BlockFormatter : object {
    public static NullableForceUInt16BlockFormatter Instance;
    private static NullableForceUInt16BlockFormatter();
    public sealed virtual void Serialize(MessagePackWriter& writer, Nullable`1<ushort> value, MessagePackSerializerOptions options);
    public sealed virtual Nullable`1<ushort> Deserialize(MessagePackReader& reader, MessagePackSerializerOptions options);
}
public class MessagePack.Formatters.NullableForceUInt32BlockFormatter : object {
    public static NullableForceUInt32BlockFormatter Instance;
    private static NullableForceUInt32BlockFormatter();
    public sealed virtual void Serialize(MessagePackWriter& writer, Nullable`1<UInt32> value, MessagePackSerializerOptions options);
    public sealed virtual Nullable`1<UInt32> Deserialize(MessagePackReader& reader, MessagePackSerializerOptions options);
}
public class MessagePack.Formatters.NullableForceUInt64BlockFormatter : object {
    public static NullableForceUInt64BlockFormatter Instance;
    private static NullableForceUInt64BlockFormatter();
    public sealed virtual void Serialize(MessagePackWriter& writer, Nullable`1<ulong> value, MessagePackSerializerOptions options);
    public sealed virtual Nullable`1<ulong> Deserialize(MessagePackReader& reader, MessagePackSerializerOptions options);
}
public class MessagePack.Formatters.NullableFormatter`1 : object {
    public sealed virtual void Serialize(MessagePackWriter& writer, Nullable`1<T> value, MessagePackSerializerOptions options);
    public sealed virtual Nullable`1<T> Deserialize(MessagePackReader& reader, MessagePackSerializerOptions options);
}
public class MessagePack.Formatters.NullableInt16Formatter : object {
    public static NullableInt16Formatter Instance;
    private static NullableInt16Formatter();
    public sealed virtual void Serialize(MessagePackWriter& writer, Nullable`1<short> value, MessagePackSerializerOptions options);
    public sealed virtual Nullable`1<short> Deserialize(MessagePackReader& reader, MessagePackSerializerOptions options);
}
public class MessagePack.Formatters.NullableInt32Formatter : object {
    public static NullableInt32Formatter Instance;
    private static NullableInt32Formatter();
    public sealed virtual void Serialize(MessagePackWriter& writer, Nullable`1<int> value, MessagePackSerializerOptions options);
    public sealed virtual Nullable`1<int> Deserialize(MessagePackReader& reader, MessagePackSerializerOptions options);
}
public class MessagePack.Formatters.NullableInt64Formatter : object {
    public static NullableInt64Formatter Instance;
    private static NullableInt64Formatter();
    public sealed virtual void Serialize(MessagePackWriter& writer, Nullable`1<long> value, MessagePackSerializerOptions options);
    public sealed virtual Nullable`1<long> Deserialize(MessagePackReader& reader, MessagePackSerializerOptions options);
}
public class MessagePack.Formatters.NullableNilFormatter : object {
    public static IMessagePackFormatter`1<Nullable`1<Nil>> Instance;
    private static NullableNilFormatter();
    public sealed virtual void Serialize(MessagePackWriter& writer, Nullable`1<Nil> value, MessagePackSerializerOptions options);
    public sealed virtual Nullable`1<Nil> Deserialize(MessagePackReader& reader, MessagePackSerializerOptions options);
}
public class MessagePack.Formatters.NullableSByteFormatter : object {
    public static NullableSByteFormatter Instance;
    private static NullableSByteFormatter();
    public sealed virtual void Serialize(MessagePackWriter& writer, Nullable`1<sbyte> value, MessagePackSerializerOptions options);
    public sealed virtual Nullable`1<sbyte> Deserialize(MessagePackReader& reader, MessagePackSerializerOptions options);
}
public class MessagePack.Formatters.NullableSingleFormatter : object {
    public static NullableSingleFormatter Instance;
    private static NullableSingleFormatter();
    public sealed virtual void Serialize(MessagePackWriter& writer, Nullable`1<float> value, MessagePackSerializerOptions options);
    public sealed virtual Nullable`1<float> Deserialize(MessagePackReader& reader, MessagePackSerializerOptions options);
}
public class MessagePack.Formatters.NullableStringArrayFormatter : object {
    public static NullableStringArrayFormatter Instance;
    private static NullableStringArrayFormatter();
    public sealed virtual void Serialize(MessagePackWriter& writer, String[] value, MessagePackSerializerOptions options);
    public sealed virtual String[] Deserialize(MessagePackReader& reader, MessagePackSerializerOptions options);
}
public class MessagePack.Formatters.NullableStringFormatter : object {
    public static NullableStringFormatter Instance;
    private static NullableStringFormatter();
    public sealed virtual void Serialize(MessagePackWriter& writer, string value, MessagePackSerializerOptions options);
    public sealed virtual string Deserialize(MessagePackReader& reader, MessagePackSerializerOptions options);
}
public class MessagePack.Formatters.NullableUInt16Formatter : object {
    public static NullableUInt16Formatter Instance;
    private static NullableUInt16Formatter();
    public sealed virtual void Serialize(MessagePackWriter& writer, Nullable`1<ushort> value, MessagePackSerializerOptions options);
    public sealed virtual Nullable`1<ushort> Deserialize(MessagePackReader& reader, MessagePackSerializerOptions options);
}
public class MessagePack.Formatters.NullableUInt32Formatter : object {
    public static NullableUInt32Formatter Instance;
    private static NullableUInt32Formatter();
    public sealed virtual void Serialize(MessagePackWriter& writer, Nullable`1<UInt32> value, MessagePackSerializerOptions options);
    public sealed virtual Nullable`1<UInt32> Deserialize(MessagePackReader& reader, MessagePackSerializerOptions options);
}
public class MessagePack.Formatters.NullableUInt64Formatter : object {
    public static NullableUInt64Formatter Instance;
    private static NullableUInt64Formatter();
    public sealed virtual void Serialize(MessagePackWriter& writer, Nullable`1<ulong> value, MessagePackSerializerOptions options);
    public sealed virtual Nullable`1<ulong> Deserialize(MessagePackReader& reader, MessagePackSerializerOptions options);
}
public class MessagePack.Formatters.ObservableCollectionFormatter`1 : CollectionFormatterBase`2<T, ObservableCollection`1<T>> {
    protected virtual void Add(ObservableCollection`1<T> collection, int index, T value, MessagePackSerializerOptions options);
    protected virtual ObservableCollection`1<T> Create(int count, MessagePackSerializerOptions options);
}
public class MessagePack.Formatters.PrimitiveObjectFormatter : object {
    public static IMessagePackFormatter`1<object> Instance;
    private static Dictionary`2<Type, int> TypeToJumpCode;
    private static PrimitiveObjectFormatter();
    public static bool IsSupportedType(Type type, TypeInfo typeInfo, object value);
    public sealed virtual void Serialize(MessagePackWriter& writer, object value, MessagePackSerializerOptions options);
    public sealed virtual object Deserialize(MessagePackReader& reader, MessagePackSerializerOptions options);
}
public class MessagePack.Formatters.QueueFormatter`1 : CollectionFormatterBase`4<T, Queue`1<T>, Enumerator<T>, Queue`1<T>> {
    protected virtual Nullable`1<int> GetCount(Queue`1<T> sequence);
    protected virtual void Add(Queue`1<T> collection, int index, T value, MessagePackSerializerOptions options);
    protected virtual Queue`1<T> Create(int count, MessagePackSerializerOptions options);
    protected virtual Enumerator<T> GetSourceEnumerator(Queue`1<T> source);
    protected virtual Queue`1<T> Complete(Queue`1<T> intermediateCollection);
}
public class MessagePack.Formatters.ReadOnlyCollectionFormatter`1 : CollectionFormatterBase`3<T, T[], ReadOnlyCollection`1<T>> {
    protected virtual void Add(T[] collection, int index, T value, MessagePackSerializerOptions options);
    protected virtual ReadOnlyCollection`1<T> Complete(T[] intermediateCollection);
    protected virtual T[] Create(int count, MessagePackSerializerOptions options);
}
public class MessagePack.Formatters.ReadOnlyDictionaryFormatter`2 : DictionaryFormatterBase`4<TKey, TValue, Dictionary`2<TKey, TValue>, ReadOnlyDictionary`2<TKey, TValue>> {
    protected virtual void Add(Dictionary`2<TKey, TValue> collection, int index, TKey key, TValue value, MessagePackSerializerOptions options);
    protected virtual ReadOnlyDictionary`2<TKey, TValue> Complete(Dictionary`2<TKey, TValue> intermediateCollection);
    protected virtual Dictionary`2<TKey, TValue> Create(int count, MessagePackSerializerOptions options);
}
public class MessagePack.Formatters.ReadOnlyObservableCollectionFormatter`1 : CollectionFormatterBase`3<T, ObservableCollection`1<T>, ReadOnlyObservableCollection`1<T>> {
    protected virtual void Add(ObservableCollection`1<T> collection, int index, T value, MessagePackSerializerOptions options);
    protected virtual ObservableCollection`1<T> Create(int count, MessagePackSerializerOptions options);
    protected virtual ReadOnlyObservableCollection`1<T> Complete(ObservableCollection`1<T> intermediateCollection);
}
public class MessagePack.Formatters.SByteArrayFormatter : object {
    public static SByteArrayFormatter Instance;
    private static SByteArrayFormatter();
    public sealed virtual void Serialize(MessagePackWriter& writer, SByte[] value, MessagePackSerializerOptions options);
    public sealed virtual SByte[] Deserialize(MessagePackReader& reader, MessagePackSerializerOptions options);
}
public class MessagePack.Formatters.SByteFormatter : object {
    public static SByteFormatter Instance;
    private static SByteFormatter();
    public sealed virtual void Serialize(MessagePackWriter& writer, sbyte value, MessagePackSerializerOptions options);
    public sealed virtual sbyte Deserialize(MessagePackReader& reader, MessagePackSerializerOptions options);
}
public class MessagePack.Formatters.SingleArrayFormatter : object {
    public static SingleArrayFormatter Instance;
    private static SingleArrayFormatter();
    public sealed virtual void Serialize(MessagePackWriter& writer, Single[] value, MessagePackSerializerOptions options);
    public sealed virtual Single[] Deserialize(MessagePackReader& reader, MessagePackSerializerOptions options);
}
public class MessagePack.Formatters.SingleFormatter : object {
    public static SingleFormatter Instance;
    private static SingleFormatter();
    public sealed virtual void Serialize(MessagePackWriter& writer, float value, MessagePackSerializerOptions options);
    public sealed virtual float Deserialize(MessagePackReader& reader, MessagePackSerializerOptions options);
}
public class MessagePack.Formatters.SortedDictionaryFormatter`2 : DictionaryFormatterBase`5<TKey, TValue, SortedDictionary`2<TKey, TValue>, Enumerator<TKey, TValue>, SortedDictionary`2<TKey, TValue>> {
    protected virtual void Add(SortedDictionary`2<TKey, TValue> collection, int index, TKey key, TValue value, MessagePackSerializerOptions options);
    protected virtual SortedDictionary`2<TKey, TValue> Complete(SortedDictionary`2<TKey, TValue> intermediateCollection);
    protected virtual SortedDictionary`2<TKey, TValue> Create(int count, MessagePackSerializerOptions options);
    protected virtual Enumerator<TKey, TValue> GetSourceEnumerator(SortedDictionary`2<TKey, TValue> source);
}
public class MessagePack.Formatters.SortedListFormatter`2 : DictionaryFormatterBase`3<TKey, TValue, SortedList`2<TKey, TValue>> {
    protected virtual void Add(SortedList`2<TKey, TValue> collection, int index, TKey key, TValue value, MessagePackSerializerOptions options);
    protected virtual SortedList`2<TKey, TValue> Create(int count, MessagePackSerializerOptions options);
}
public class MessagePack.Formatters.StackFormatter`1 : CollectionFormatterBase`4<T, T[], Enumerator<T>, Stack`1<T>> {
    protected virtual Nullable`1<int> GetCount(Stack`1<T> sequence);
    protected virtual void Add(T[] collection, int index, T value, MessagePackSerializerOptions options);
    protected virtual T[] Create(int count, MessagePackSerializerOptions options);
    protected virtual Enumerator<T> GetSourceEnumerator(Stack`1<T> source);
    protected virtual Stack`1<T> Complete(T[] intermediateCollection);
}
public class MessagePack.Formatters.StaticNullableFormatter`1 : object {
    private IMessagePackFormatter`1<T> underlyingFormatter;
    public StaticNullableFormatter`1(IMessagePackFormatter`1<T> underlyingFormatter);
    public sealed virtual void Serialize(MessagePackWriter& writer, Nullable`1<T> value, MessagePackSerializerOptions options);
    public sealed virtual Nullable`1<T> Deserialize(MessagePackReader& reader, MessagePackSerializerOptions options);
}
public class MessagePack.Formatters.StringBuilderFormatter : object {
    public static IMessagePackFormatter`1<StringBuilder> Instance;
    private static StringBuilderFormatter();
    public sealed virtual void Serialize(MessagePackWriter& writer, StringBuilder value, MessagePackSerializerOptions options);
    public sealed virtual StringBuilder Deserialize(MessagePackReader& reader, MessagePackSerializerOptions options);
}
public class MessagePack.Formatters.ThreeDimensionalArrayFormatter`1 : object {
    private static int ArrayLength;
    public sealed virtual void Serialize(MessagePackWriter& writer, T[0...,0...,0...] value, MessagePackSerializerOptions options);
    public sealed virtual T[0...,0...,0...] Deserialize(MessagePackReader& reader, MessagePackSerializerOptions options);
}
public class MessagePack.Formatters.TimeSpanFormatter : object {
    public static IMessagePackFormatter`1<TimeSpan> Instance;
    private static TimeSpanFormatter();
    public sealed virtual void Serialize(MessagePackWriter& writer, TimeSpan value, MessagePackSerializerOptions options);
    public sealed virtual TimeSpan Deserialize(MessagePackReader& reader, MessagePackSerializerOptions options);
}
public class MessagePack.Formatters.TupleFormatter`1 : object {
    public sealed virtual void Serialize(MessagePackWriter& writer, Tuple`1<T1> value, MessagePackSerializerOptions options);
    public sealed virtual Tuple`1<T1> Deserialize(MessagePackReader& reader, MessagePackSerializerOptions options);
}
public class MessagePack.Formatters.TupleFormatter`2 : object {
    public sealed virtual void Serialize(MessagePackWriter& writer, Tuple`2<T1, T2> value, MessagePackSerializerOptions options);
    public sealed virtual Tuple`2<T1, T2> Deserialize(MessagePackReader& reader, MessagePackSerializerOptions options);
}
public class MessagePack.Formatters.TupleFormatter`3 : object {
    public sealed virtual void Serialize(MessagePackWriter& writer, Tuple`3<T1, T2, T3> value, MessagePackSerializerOptions options);
    public sealed virtual Tuple`3<T1, T2, T3> Deserialize(MessagePackReader& reader, MessagePackSerializerOptions options);
}
public class MessagePack.Formatters.TupleFormatter`4 : object {
    public sealed virtual void Serialize(MessagePackWriter& writer, Tuple`4<T1, T2, T3, T4> value, MessagePackSerializerOptions options);
    public sealed virtual Tuple`4<T1, T2, T3, T4> Deserialize(MessagePackReader& reader, MessagePackSerializerOptions options);
}
public class MessagePack.Formatters.TupleFormatter`5 : object {
    public sealed virtual void Serialize(MessagePackWriter& writer, Tuple`5<T1, T2, T3, T4, T5> value, MessagePackSerializerOptions options);
    public sealed virtual Tuple`5<T1, T2, T3, T4, T5> Deserialize(MessagePackReader& reader, MessagePackSerializerOptions options);
}
public class MessagePack.Formatters.TupleFormatter`6 : object {
    public sealed virtual void Serialize(MessagePackWriter& writer, Tuple`6<T1, T2, T3, T4, T5, T6> value, MessagePackSerializerOptions options);
    public sealed virtual Tuple`6<T1, T2, T3, T4, T5, T6> Deserialize(MessagePackReader& reader, MessagePackSerializerOptions options);
}
public class MessagePack.Formatters.TupleFormatter`7 : object {
    public sealed virtual void Serialize(MessagePackWriter& writer, Tuple`7<T1, T2, T3, T4, T5, T6, T7> value, MessagePackSerializerOptions options);
    public sealed virtual Tuple`7<T1, T2, T3, T4, T5, T6, T7> Deserialize(MessagePackReader& reader, MessagePackSerializerOptions options);
}
public class MessagePack.Formatters.TupleFormatter`8 : object {
    public sealed virtual void Serialize(MessagePackWriter& writer, Tuple`8<T1, T2, T3, T4, T5, T6, T7, TRest> value, MessagePackSerializerOptions options);
    public sealed virtual Tuple`8<T1, T2, T3, T4, T5, T6, T7, TRest> Deserialize(MessagePackReader& reader, MessagePackSerializerOptions options);
}
public class MessagePack.Formatters.TwoDimensionalArrayFormatter`1 : object {
    private static int ArrayLength;
    public sealed virtual void Serialize(MessagePackWriter& writer, T[0...,0...] value, MessagePackSerializerOptions options);
    public sealed virtual T[0...,0...] Deserialize(MessagePackReader& reader, MessagePackSerializerOptions options);
}
public class MessagePack.Formatters.TypelessFormatter : object {
    public static IMessagePackFormatter`1<object> Instance;
    private ThreadsafeTypeKeyHashTable`1<SerializeMethod> serializers;
    private ThreadsafeTypeKeyHashTable`1<DeserializeMethod> deserializers;
    private ThreadsafeTypeKeyHashTable`1<Byte[]> fullTypeNameCache;
    private ThreadsafeTypeKeyHashTable`1<Byte[]> shortenedTypeNameCache;
    private AsymmetricKeyHashTable`3<Byte[], ArraySegment`1<byte>, Type> typeCache;
    private static HashSet`1<Type> UseBuiltinTypes;
    private static bool IsMscorlib;
    private static TypelessFormatter();
    private string BuildTypeName(Type type, MessagePackSerializerOptions options);
    public sealed virtual void Serialize(MessagePackWriter& writer, object value, MessagePackSerializerOptions options);
    public sealed virtual object Deserialize(MessagePackReader& reader, MessagePackSerializerOptions options);
    private object DeserializeByTypeName(ArraySegment`1<byte> typeName, MessagePackReader& byteSequence, MessagePackSerializerOptions options);
}
public class MessagePack.Formatters.UInt16ArrayFormatter : object {
    public static UInt16ArrayFormatter Instance;
    private static UInt16ArrayFormatter();
    public sealed virtual void Serialize(MessagePackWriter& writer, UInt16[] value, MessagePackSerializerOptions options);
    public sealed virtual UInt16[] Deserialize(MessagePackReader& reader, MessagePackSerializerOptions options);
}
public class MessagePack.Formatters.UInt16Formatter : object {
    public static UInt16Formatter Instance;
    private static UInt16Formatter();
    public sealed virtual void Serialize(MessagePackWriter& writer, ushort value, MessagePackSerializerOptions options);
    public sealed virtual ushort Deserialize(MessagePackReader& reader, MessagePackSerializerOptions options);
}
public class MessagePack.Formatters.UInt32ArrayFormatter : object {
    public static UInt32ArrayFormatter Instance;
    private static UInt32ArrayFormatter();
    public sealed virtual void Serialize(MessagePackWriter& writer, UInt32[] value, MessagePackSerializerOptions options);
    public sealed virtual UInt32[] Deserialize(MessagePackReader& reader, MessagePackSerializerOptions options);
}
public class MessagePack.Formatters.UInt32Formatter : object {
    public static UInt32Formatter Instance;
    private static UInt32Formatter();
    public sealed virtual void Serialize(MessagePackWriter& writer, UInt32 value, MessagePackSerializerOptions options);
    public sealed virtual UInt32 Deserialize(MessagePackReader& reader, MessagePackSerializerOptions options);
}
public class MessagePack.Formatters.UInt64ArrayFormatter : object {
    public static UInt64ArrayFormatter Instance;
    private static UInt64ArrayFormatter();
    public sealed virtual void Serialize(MessagePackWriter& writer, UInt64[] value, MessagePackSerializerOptions options);
    public sealed virtual UInt64[] Deserialize(MessagePackReader& reader, MessagePackSerializerOptions options);
}
public class MessagePack.Formatters.UInt64Formatter : object {
    public static UInt64Formatter Instance;
    private static UInt64Formatter();
    public sealed virtual void Serialize(MessagePackWriter& writer, ulong value, MessagePackSerializerOptions options);
    public sealed virtual ulong Deserialize(MessagePackReader& reader, MessagePackSerializerOptions options);
}
public class MessagePack.Formatters.UriFormatter : object {
    public static IMessagePackFormatter`1<Uri> Instance;
    private static UriFormatter();
    public sealed virtual void Serialize(MessagePackWriter& writer, Uri value, MessagePackSerializerOptions options);
    public sealed virtual Uri Deserialize(MessagePackReader& reader, MessagePackSerializerOptions options);
}
public class MessagePack.Formatters.ValueTupleFormatter`1 : object {
    public sealed virtual void Serialize(MessagePackWriter& writer, ValueTuple`1<T1> value, MessagePackSerializerOptions options);
    public sealed virtual ValueTuple`1<T1> Deserialize(MessagePackReader& reader, MessagePackSerializerOptions options);
}
public class MessagePack.Formatters.ValueTupleFormatter`2 : object {
    public sealed virtual void Serialize(MessagePackWriter& writer, ValueTuple`2<T1, T2> value, MessagePackSerializerOptions options);
    public sealed virtual ValueTuple`2<T1, T2> Deserialize(MessagePackReader& reader, MessagePackSerializerOptions options);
}
public class MessagePack.Formatters.ValueTupleFormatter`3 : object {
    public sealed virtual void Serialize(MessagePackWriter& writer, ValueTuple`3<T1, T2, T3> value, MessagePackSerializerOptions options);
    public sealed virtual ValueTuple`3<T1, T2, T3> Deserialize(MessagePackReader& reader, MessagePackSerializerOptions options);
}
public class MessagePack.Formatters.ValueTupleFormatter`4 : object {
    public sealed virtual void Serialize(MessagePackWriter& writer, ValueTuple`4<T1, T2, T3, T4> value, MessagePackSerializerOptions options);
    public sealed virtual ValueTuple`4<T1, T2, T3, T4> Deserialize(MessagePackReader& reader, MessagePackSerializerOptions options);
}
public class MessagePack.Formatters.ValueTupleFormatter`5 : object {
    public sealed virtual void Serialize(MessagePackWriter& writer, ValueTuple`5<T1, T2, T3, T4, T5> value, MessagePackSerializerOptions options);
    public sealed virtual ValueTuple`5<T1, T2, T3, T4, T5> Deserialize(MessagePackReader& reader, MessagePackSerializerOptions options);
}
public class MessagePack.Formatters.ValueTupleFormatter`6 : object {
    public sealed virtual void Serialize(MessagePackWriter& writer, ValueTuple`6<T1, T2, T3, T4, T5, T6> value, MessagePackSerializerOptions options);
    public sealed virtual ValueTuple`6<T1, T2, T3, T4, T5, T6> Deserialize(MessagePackReader& reader, MessagePackSerializerOptions options);
}
public class MessagePack.Formatters.ValueTupleFormatter`7 : object {
    public sealed virtual void Serialize(MessagePackWriter& writer, ValueTuple`7<T1, T2, T3, T4, T5, T6, T7> value, MessagePackSerializerOptions options);
    public sealed virtual ValueTuple`7<T1, T2, T3, T4, T5, T6, T7> Deserialize(MessagePackReader& reader, MessagePackSerializerOptions options);
}
public class MessagePack.Formatters.ValueTupleFormatter`8 : object {
    public sealed virtual void Serialize(MessagePackWriter& writer, ValueTuple`8<T1, T2, T3, T4, T5, T6, T7, TRest> value, MessagePackSerializerOptions options);
    public sealed virtual ValueTuple`8<T1, T2, T3, T4, T5, T6, T7, TRest> Deserialize(MessagePackReader& reader, MessagePackSerializerOptions options);
}
public class MessagePack.Formatters.VersionFormatter : object {
    public static IMessagePackFormatter`1<Version> Instance;
    private static VersionFormatter();
    public sealed virtual void Serialize(MessagePackWriter& writer, Version value, MessagePackSerializerOptions options);
    public sealed virtual Version Deserialize(MessagePackReader& reader, MessagePackSerializerOptions options);
}
public interface MessagePack.IFormatterResolver {
    public abstract virtual IMessagePackFormatter`1<T> GetFormatter();
}
internal class MessagePack.Internal.AnonymousDeserializeFunc`1 : MulticastDelegate {
    public AnonymousDeserializeFunc`1(object object, IntPtr method);
    public virtual T Invoke(Object[] customFormatters, MessagePackReader& reader, MessagePackSerializerOptions options);
    public virtual IAsyncResult BeginInvoke(Object[] customFormatters, MessagePackReader& reader, MessagePackSerializerOptions options, AsyncCallback callback, object object);
    public virtual T EndInvoke(MessagePackReader& reader, IAsyncResult result);
}
internal class MessagePack.Internal.AnonymousSerializableFormatter`1 : object {
    private Byte[][] stringByteKeysField;
    private Object[] serializeCustomFormatters;
    private Object[] deserializeCustomFormatters;
    private AnonymousSerializeFunc`1<T> serialize;
    private AnonymousDeserializeFunc`1<T> deserialize;
    public AnonymousSerializableFormatter`1(Byte[][] stringByteKeysField, Object[] serializeCustomFormatters, Object[] deserializeCustomFormatters, AnonymousSerializeFunc`1<T> serialize, AnonymousDeserializeFunc`1<T> deserialize);
    public sealed virtual void Serialize(MessagePackWriter& writer, T value, MessagePackSerializerOptions options);
    public sealed virtual T Deserialize(MessagePackReader& reader, MessagePackSerializerOptions options);
}
internal class MessagePack.Internal.AnonymousSerializeFunc`1 : MulticastDelegate {
    public AnonymousSerializeFunc`1(object object, IntPtr method);
    public virtual void Invoke(Byte[][] stringByteKeysField, Object[] customFormatters, MessagePackWriter& writer, T value, MessagePackSerializerOptions options);
    public virtual IAsyncResult BeginInvoke(Byte[][] stringByteKeysField, Object[] customFormatters, MessagePackWriter& writer, T value, MessagePackSerializerOptions options, AsyncCallback callback, object object);
    public virtual void EndInvoke(MessagePackWriter& writer, IAsyncResult result);
}
internal class MessagePack.Internal.ArgumentField : ValueType {
    private int i;
    private bool ref;
    private ILGenerator il;
    public ArgumentField(ILGenerator il, int i, bool ref);
    public ArgumentField(ILGenerator il, int i, Type type);
    public void EmitLoad();
    public void EmitLdarg();
    public void EmitLdarga();
    public void EmitStore();
}
internal class MessagePack.Internal.AsymmetricKeyHashTable`3 : object {
    private Entry[] buckets;
    private int size;
    private object writerLock;
    private float loadFactor;
    private IAsymmetricEqualityComparer`2<TKey1, TKey2> comparer;
    public AsymmetricKeyHashTable`3(IAsymmetricEqualityComparer`2<TKey1, TKey2> comparer);
    public AsymmetricKeyHashTable`3(int capacity, float loadFactor, IAsymmetricEqualityComparer`2<TKey1, TKey2> comparer);
    public TValue AddOrGet(TKey1 key1, Func`2<TKey1, TValue> valueFactory);
    public bool TryAdd(TKey1 key, TValue value);
    public bool TryAdd(TKey1 key, Func`2<TKey1, TValue> valueFactory);
    private bool TryAddInternal(TKey1 key, Func`2<TKey1, TValue> valueFactory, TValue& resultingValue);
    private bool AddToBuckets(Entry[] buckets, TKey1 newKey, Entry<TKey1, TKey2, TValue> newEntryOrNull, Func`2<TKey1, TValue> valueFactory, TValue& resultingValue);
    public bool TryGetValue(TKey2 key, TValue& value);
    private static int CalculateCapacity(int collectionSize, float loadFactor);
    private static void VolatileWrite(Entry& location, Entry<TKey1, TKey2, TValue> value);
    private static void VolatileWrite(Entry[]& location, Entry[] value);
}
public class MessagePack.Internal.AutomataDictionary : object {
    private AutomataNode root;
    public void Add(string str, int value);
    public bool TryGetValue(ReadOnlySequence`1& bytes, Int32& value);
    public bool TryGetValue(ReadOnlySpan`1<byte> bytes, Int32& value);
    public virtual string ToString();
    private static void ToStringCore(IEnumerable`1<AutomataNode> nexts, StringBuilder sb, int depth);
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    public sealed virtual IEnumerator`1<KeyValuePair`2<string, int>> GetEnumerator();
    [IteratorStateMachineAttribute("MessagePack.Internal.AutomataDictionary/<YieldCore>d__9")]
private static IEnumerable`1<KeyValuePair`2<string, int>> YieldCore(IEnumerable`1<AutomataNode> nexts);
    public void EmitMatch(ILGenerator il, LocalBuilder bytesSpan, LocalBuilder key, Action`1<KeyValuePair`2<string, int>> onFound, Action onNotFound);
}
public static class MessagePack.Internal.AutomataKeyGen : object {
    public static MethodInfo GetKeyMethod;
    private static AutomataKeyGen();
    public static ulong GetKey(ReadOnlySpan`1& span);
}
internal static class MessagePack.Internal.BuiltinResolverGetFormatterHelper : object {
    private static Dictionary`2<Type, object> FormatterMap;
    private static BuiltinResolverGetFormatterHelper();
    internal static object GetFormatter(Type t);
}
public class MessagePack.Internal.ByteArrayStringHashTable : object {
    private Entry[][] buckets;
    private ulong indexFor;
    private static bool Is32Bit;
    public ByteArrayStringHashTable(int capacity);
    public ByteArrayStringHashTable(int capacity, float loadFactor);
    private static ByteArrayStringHashTable();
    public void Add(string key, int value);
    public void Add(Byte[] key, int value);
    private bool TryAddInternal(Byte[] key, int value);
    public bool TryGetValue(ReadOnlySequence`1& key, Int32& value);
    public bool TryGetValue(ReadOnlySpan`1<byte> key, Int32& value);
    private bool TryGetValueSlow(ReadOnlySpan`1<byte> key, Entry[] entry, Int32& value);
    private static ulong ByteArrayGetHashCode(ReadOnlySpan`1<byte> x);
    private static int CalculateCapacity(int collectionSize, float loadFactor);
    [IteratorStateMachineAttribute("MessagePack.Internal.ByteArrayStringHashTable/<GetEnumerator>d__13")]
public sealed virtual IEnumerator`1<KeyValuePair`2<string, int>> GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
}
[EditorBrowsableAttribute("1")]
public static class MessagePack.Internal.CodeGenHelpers : object {
    public static Byte[] GetEncodedStringBytes(string value);
    public static ReadOnlySpan`1<byte> GetSpanFromSequence(ReadOnlySequence`1& sequence);
    public static ReadOnlySpan`1<byte> ReadStringSpan(MessagePackReader& reader);
    public static Byte[] GetArrayFromNullableSequence(Nullable`1& sequence);
    private static ReadOnlySpan`1<byte> GetSpanFromSequence(Nullable`1& sequence);
}
internal static class MessagePack.Internal.DateTimeConstants : object {
    internal static long BclSecondsAtUnixEpoch;
    internal static int NanosecondsPerTick;
    internal static DateTime UnixEpoch;
    private static DateTimeConstants();
}
internal class MessagePack.Internal.DynamicAssembly : object {
    private AssemblyBuilder assemblyBuilder;
    private ModuleBuilder moduleBuilder;
    private object gate;
    public DynamicAssembly(string moduleName);
    public TypeBuilder DefineType(string name, TypeAttributes attr);
    public TypeBuilder DefineType(string name, TypeAttributes attr, Type parent);
    public TypeBuilder DefineType(string name, TypeAttributes attr, Type parent, Type[] interfaces);
}
internal static class MessagePack.Internal.DynamicGenericResolverGetFormatterHelper : object {
    private static Dictionary`2<Type, Type> FormatterMap;
    private static DynamicGenericResolverGetFormatterHelper();
    internal static object GetFormatter(Type t);
    private static object CreateInstance(Type genericType, Type[] genericTypeArguments, Object[] arguments);
}
internal static class MessagePack.Internal.DynamicObjectTypeBuilder : object {
    private static Regex SubtractFullNameRegex;
    private static int nameSequence;
    private static HashSet`1<Type> ignoreTypes;
    private static Type refMessagePackReader;
    private static MethodInfo ReadOnlySpanFromByteArray;
    private static MethodInfo ReadStringSpan;
    private static MethodInfo ArrayFromNullableReadOnlySequence;
    private static MethodInfo getFormatterWithVerify;
    private static MethodInfo getResolverFromOptions;
    private static MethodInfo getSecurityFromOptions;
    private static MethodInfo securityDepthStep;
    private static MethodInfo readerDepthGet;
    private static MethodInfo readerDepthSet;
    private static Func`2<Type, MethodInfo> getSerialize;
    private static Func`2<Type, MethodInfo> getDeserialize;
    private static ConstructorInfo messagePackSerializationExceptionMessageOnlyConstructor;
    private static MethodInfo onBeforeSerialize;
    private static MethodInfo onAfterDeserialize;
    private static ConstructorInfo objectCtor;
    private static DynamicObjectTypeBuilder();
    public static TypeInfo BuildType(DynamicAssembly assembly, Type type, bool forceStringKey, bool contractless);
    public static object BuildFormatterToDynamicMethod(Type type, bool forceStringKey, bool contractless, bool allowPrivate);
    private static void BuildConstructor(Type type, ObjectSerializationInfo info, ConstructorInfo method, FieldBuilder stringByteKeysField, ILGenerator il);
    private static Dictionary`2<EmittableMember, FieldInfo> BuildCustomFormatterField(TypeBuilder builder, ObjectSerializationInfo info, ILGenerator il);
    private static void BuildSerialize(Type type, ObjectSerializationInfo info, ILGenerator il, Action emitStringByteKeys, Func`3<int, EmittableMember, Action> tryEmitLoadCustomFormatter, int firstArgIndex);
    private static void EmitSerializeValue(ILGenerator il, TypeInfo type, EmittableMember member, int index, Func`3<int, EmittableMember, Action> tryEmitLoadCustomFormatter, ArgumentField argWriter, ArgumentField argValue, ArgumentField argOptions, LocalBuilder localResolver);
    private static void BuildDeserialize(Type type, ObjectSerializationInfo info, ILGenerator il, Func`3<int, EmittableMember, Action> tryEmitLoadCustomFormatter, int firstArgIndex);
    private static void EmitDeserializeValue(ILGenerator il, DeserializeInfo info, int index, Func`3<int, EmittableMember, Action> tryEmitLoadCustomFormatter, ArgumentField argReader, ArgumentField argOptions, LocalBuilder localResolver);
    private static LocalBuilder EmitNewObject(ILGenerator il, Type type, ObjectSerializationInfo info, DeserializeInfo[] members);
    private static bool IsOptimizeTargetType(Type type);
    private static bool Matches(MethodInfo m, int parameterIndex, Type desiredType);
}
internal static class MessagePack.Internal.ExpressionUtility : object {
    private static MethodInfo GetMethodInfoCore(LambdaExpression expression);
    public static MethodInfo GetMethodInfo(Expression`1<Func`1<T>> expression);
    public static MethodInfo GetMethodInfo(Expression`1<Action> expression);
    public static MethodInfo GetMethodInfo(Expression`1<Func`2<T, TR>> expression);
    public static MethodInfo GetMethodInfo(Expression`1<Action`1<T>> expression);
    public static MethodInfo GetMethodInfo(Expression`1<Func`3<T, TArg1, TR>> expression);
    private static MemberInfo GetMemberInfoCore(Expression`1<T> source);
    public static PropertyInfo GetPropertyInfo(Expression`1<Func`2<T, TR>> expression);
    public static FieldInfo GetFieldInfo(Expression`1<Func`2<T, TR>> expression);
}
internal static class MessagePack.Internal.FarmHash : object {
    private static UInt32 c1;
    private static UInt32 c2;
    private static ulong k0;
    private static ulong k1;
    private static ulong k2;
    public static UInt32 Hash32(ReadOnlySpan`1<byte> bytes);
    private static UInt32 Fetch32(Byte* p);
    private static UInt32 Rotate32(UInt32 val, int shift);
    private static UInt32 fmix(UInt32 h);
    private static UInt32 Mur(UInt32 a, UInt32 h);
    private static UInt32 Hash32Len0to4(ReadOnlySpan`1<byte> s);
    private static UInt32 Hash32Len5to12(Byte* s, UInt32 len);
    private static UInt32 Hash32Len13to24(Byte* s, UInt32 len);
    private static UInt32 Hash32(Byte* s, UInt32 len);
    public static ulong Hash64(ReadOnlySpan`1<byte> bytes);
    private static void swap(UInt64& x, UInt64& z);
    private static ulong Fetch64(Byte* p);
    private static ulong Rotate64(ulong val, int shift);
    private static ulong ShiftMix(ulong val);
    private static ulong HashLen16(ulong u, ulong v, ulong mul);
    private static ulong Hash64(Byte* s, UInt32 len);
    private static ulong HashLen0to16(Byte* s, UInt32 len);
    private static ulong HashLen17to32(Byte* s, UInt32 len);
    private static ulong H32(Byte* s, UInt32 len, ulong mul, ulong seed0, ulong seed1);
    private static ulong HashLen33to64(Byte* s, UInt32 len);
    private static ulong HashLen65to96(Byte* s, UInt32 len);
    private static void WeakHashLen32WithSeeds(ulong w, ulong x, ulong y, ulong z, ulong a, ulong b, UInt64& first, UInt64& second);
    private static void WeakHashLen32WithSeeds(Byte* s, ulong a, ulong b, UInt64& first, UInt64& second);
    private static ulong Hash64NA(Byte* s, UInt32 len);
    private static ulong H(ulong x, ulong y, ulong mul, int r);
    private static ulong Hash64UO(Byte* s, UInt32 len);
}
internal class MessagePack.Internal.GuidBits : ValueType {
    public Guid Value;
    public byte Byte0;
    public byte Byte1;
    public byte Byte2;
    public byte Byte3;
    public byte Byte4;
    public byte Byte5;
    public byte Byte6;
    public byte Byte7;
    public byte Byte8;
    public byte Byte9;
    public byte Byte10;
    public byte Byte11;
    public byte Byte12;
    public byte Byte13;
    public byte Byte14;
    public byte Byte15;
    private static Byte[] byteToHexStringHigh;
    private static Byte[] byteToHexStringLow;
    public GuidBits(Guid& value);
    public GuidBits(ReadOnlySpan`1<byte> utf8string);
    private static GuidBits();
    private static byte Parse(ReadOnlySpan`1<byte> bytes, int highOffset);
    private static byte SwitchParse(byte b);
    public void Write(Span`1<byte> buffer);
}
internal interface MessagePack.Internal.IAsymmetricEqualityComparer`2 {
    public abstract virtual int GetHashCode(TKey1 key1);
    public abstract virtual int GetHashCode(TKey2 key2);
    public abstract virtual bool Equals(TKey1 x, TKey1 y);
    public abstract virtual bool Equals(TKey1 x, TKey2 y);
}
[ExtensionAttribute]
internal static class MessagePack.Internal.ILGeneratorExtensions : object {
    [ExtensionAttribute]
public static void EmitLdloc(ILGenerator il, int index);
    [ExtensionAttribute]
public static void EmitLdloc(ILGenerator il, LocalBuilder local);
    [ExtensionAttribute]
public static void EmitStloc(ILGenerator il, int index);
    [ExtensionAttribute]
public static void EmitStloc(ILGenerator il, LocalBuilder local);
    [ExtensionAttribute]
public static void EmitLdloca(ILGenerator il, int index);
    [ExtensionAttribute]
public static void EmitLdloca(ILGenerator il, LocalBuilder local);
    [ExtensionAttribute]
public static void EmitTrue(ILGenerator il);
    [ExtensionAttribute]
public static void EmitFalse(ILGenerator il);
    [ExtensionAttribute]
public static void EmitBoolean(ILGenerator il, bool value);
    [ExtensionAttribute]
public static void EmitLdc_I4(ILGenerator il, int value);
    [ExtensionAttribute]
public static void EmitUnboxOrCast(ILGenerator il, Type type);
    [ExtensionAttribute]
public static void EmitBoxOrDoNothing(ILGenerator il, Type type);
    [ExtensionAttribute]
public static void EmitLdarg(ILGenerator il, int index);
    [ExtensionAttribute]
public static void EmitLoadThis(ILGenerator il);
    [ExtensionAttribute]
public static void EmitLdarga(ILGenerator il, int index);
    [ExtensionAttribute]
public static void EmitStarg(ILGenerator il, int index);
    [ExtensionAttribute]
public static void EmitPop(ILGenerator il, int count);
    [ExtensionAttribute]
public static void EmitCall(ILGenerator il, MethodInfo methodInfo);
    [ExtensionAttribute]
public static void EmitLdfld(ILGenerator il, FieldInfo fieldInfo);
    [ExtensionAttribute]
public static void EmitLdsfld(ILGenerator il, FieldInfo fieldInfo);
    [ExtensionAttribute]
public static void EmitRet(ILGenerator il);
    [ExtensionAttribute]
public static void EmitIntZeroReturn(ILGenerator il);
    [ExtensionAttribute]
public static void EmitNullReturn(ILGenerator il);
    [ExtensionAttribute]
public static void EmitULong(ILGenerator il, ulong value);
    [ExtensionAttribute]
public static void EmitThrowNotimplemented(ILGenerator il);
    [ExtensionAttribute]
public static void EmitIncrementFor(ILGenerator il, LocalBuilder conditionGreater, Action`1<LocalBuilder> emitBody);
}
internal class MessagePack.Internal.MessagePackDynamicObjectResolverException : MessagePackSerializationException {
    public MessagePackDynamicObjectResolverException(string message);
}
internal static class MessagePack.Internal.NativeDateTimeResolverGetFormatterHelper : object {
    internal static object GetFormatter(Type t);
}
internal class MessagePack.Internal.ObjectSerializationInfo : object {
    [CompilerGeneratedAttribute]
private Type <Type>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsIntKey>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsClass>k__BackingField;
    [CompilerGeneratedAttribute]
private ConstructorInfo <BestmatchConstructor>k__BackingField;
    [CompilerGeneratedAttribute]
private EmittableMember[] <ConstructorParameters>k__BackingField;
    [CompilerGeneratedAttribute]
private EmittableMember[] <Members>k__BackingField;
    public Type Type { get; public set; }
    public bool IsIntKey { get; public set; }
    public bool IsStringKey { get; }
    public bool IsClass { get; public set; }
    public bool IsStruct { get; }
    public ConstructorInfo BestmatchConstructor { get; public set; }
    public EmittableMember[] ConstructorParameters { get; public set; }
    public EmittableMember[] Members { get; public set; }
    [CompilerGeneratedAttribute]
public Type get_Type();
    [CompilerGeneratedAttribute]
public void set_Type(Type value);
    [CompilerGeneratedAttribute]
public bool get_IsIntKey();
    [CompilerGeneratedAttribute]
public void set_IsIntKey(bool value);
    public bool get_IsStringKey();
    [CompilerGeneratedAttribute]
public bool get_IsClass();
    [CompilerGeneratedAttribute]
public void set_IsClass(bool value);
    public bool get_IsStruct();
    [CompilerGeneratedAttribute]
public ConstructorInfo get_BestmatchConstructor();
    [CompilerGeneratedAttribute]
public void set_BestmatchConstructor(ConstructorInfo value);
    [CompilerGeneratedAttribute]
public EmittableMember[] get_ConstructorParameters();
    [CompilerGeneratedAttribute]
public void set_ConstructorParameters(EmittableMember[] value);
    [CompilerGeneratedAttribute]
public EmittableMember[] get_Members();
    [CompilerGeneratedAttribute]
public void set_Members(EmittableMember[] value);
    public static ObjectSerializationInfo CreateOrNull(Type type, bool forceStringKey, bool contractless, bool allowPrivate);
    [IteratorStateMachineAttribute("MessagePack.Internal.ObjectSerializationInfo/<GetAllFields>d__30")]
private static IEnumerable`1<FieldInfo> GetAllFields(Type type);
    [IteratorStateMachineAttribute("MessagePack.Internal.ObjectSerializationInfo/<GetAllProperties>d__31")]
private static IEnumerable`1<PropertyInfo> GetAllProperties(Type type);
    private static bool TryGetNextConstructor(IEnumerator`1<ConstructorInfo> ctorEnumerator, ConstructorInfo& ctor);
}
[ExtensionAttribute]
internal static class MessagePack.Internal.ReflectionExtensions : object {
    [ExtensionAttribute]
public static bool IsNullable(TypeInfo type);
    [ExtensionAttribute]
public static bool IsPublic(TypeInfo type);
    [ExtensionAttribute]
public static bool IsAnonymous(TypeInfo type);
    [ExtensionAttribute]
public static bool IsIndexer(PropertyInfo propertyInfo);
    [ExtensionAttribute]
public static bool IsConstructedGenericType(TypeInfo type);
    [ExtensionAttribute]
public static MethodInfo GetGetMethod(PropertyInfo propInfo);
    [ExtensionAttribute]
public static MethodInfo GetSetMethod(PropertyInfo propInfo);
}
public class MessagePack.Internal.RuntimeTypeHandleEqualityComparer : object {
    public static IEqualityComparer`1<RuntimeTypeHandle> Default;
    private static RuntimeTypeHandleEqualityComparer();
    public sealed virtual bool Equals(RuntimeTypeHandle x, RuntimeTypeHandle y);
    public sealed virtual int GetHashCode(RuntimeTypeHandle obj);
}
internal static class MessagePack.Internal.StandardResolverHelper : object {
    public static IFormatterResolver[] DefaultResolvers;
    private static StandardResolverHelper();
}
internal class MessagePack.Internal.StringArraySegmentByteAscymmetricEqualityComparer : object {
    private static bool Is32Bit;
    private static StringArraySegmentByteAscymmetricEqualityComparer();
    public sealed virtual bool Equals(Byte[] x, Byte[] y);
    public sealed virtual bool Equals(Byte[] x, ArraySegment`1<byte> y);
    public sealed virtual int GetHashCode(Byte[] key1);
    public sealed virtual int GetHashCode(ArraySegment`1<byte> key2);
}
internal class MessagePack.Internal.ThreadsafeTypeKeyHashTable`1 : object {
    private Entry[] buckets;
    private int size;
    private object writerLock;
    private float loadFactor;
    public ThreadsafeTypeKeyHashTable`1(int capacity, float loadFactor);
    public bool TryAdd(Type key, TValue value);
    public bool TryAdd(Type key, Func`2<Type, TValue> valueFactory);
    private bool TryAddInternal(Type key, Func`2<Type, TValue> valueFactory, TValue& resultingValue);
    private bool AddToBuckets(Entry[] buckets, Type newKey, Entry<TValue> newEntryOrNull, Func`2<Type, TValue> valueFactory, TValue& resultingValue);
    public bool TryGetValue(Type key, TValue& value);
    public TValue GetOrAdd(Type key, Func`2<Type, TValue> valueFactory);
    private static int CalculateCapacity(int collectionSize, float loadFactor);
    private static void VolatileWrite(Entry& location, Entry<TValue> value);
    private static void VolatileWrite(Entry[]& location, Entry[] value);
}
public static class MessagePack.Internal.UnsafeMemory : object {
    public static bool Is32Bit;
    private static UnsafeMemory();
}
public static class MessagePack.Internal.UnsafeMemory32 : object {
    public static void WriteRaw4(MessagePackWriter& writer, ReadOnlySpan`1<byte> src);
    public static void WriteRaw5(MessagePackWriter& writer, ReadOnlySpan`1<byte> src);
    public static void WriteRaw6(MessagePackWriter& writer, ReadOnlySpan`1<byte> src);
    public static void WriteRaw7(MessagePackWriter& writer, ReadOnlySpan`1<byte> src);
    public static void WriteRaw8(MessagePackWriter& writer, ReadOnlySpan`1<byte> src);
    public static void WriteRaw9(MessagePackWriter& writer, ReadOnlySpan`1<byte> src);
    public static void WriteRaw10(MessagePackWriter& writer, ReadOnlySpan`1<byte> src);
    public static void WriteRaw11(MessagePackWriter& writer, ReadOnlySpan`1<byte> src);
    public static void WriteRaw12(MessagePackWriter& writer, ReadOnlySpan`1<byte> src);
    public static void WriteRaw13(MessagePackWriter& writer, ReadOnlySpan`1<byte> src);
    public static void WriteRaw14(MessagePackWriter& writer, ReadOnlySpan`1<byte> src);
    public static void WriteRaw15(MessagePackWriter& writer, ReadOnlySpan`1<byte> src);
    public static void WriteRaw16(MessagePackWriter& writer, ReadOnlySpan`1<byte> src);
    public static void WriteRaw17(MessagePackWriter& writer, ReadOnlySpan`1<byte> src);
    public static void WriteRaw18(MessagePackWriter& writer, ReadOnlySpan`1<byte> src);
    public static void WriteRaw19(MessagePackWriter& writer, ReadOnlySpan`1<byte> src);
    public static void WriteRaw20(MessagePackWriter& writer, ReadOnlySpan`1<byte> src);
    public static void WriteRaw21(MessagePackWriter& writer, ReadOnlySpan`1<byte> src);
    public static void WriteRaw22(MessagePackWriter& writer, ReadOnlySpan`1<byte> src);
    public static void WriteRaw23(MessagePackWriter& writer, ReadOnlySpan`1<byte> src);
    public static void WriteRaw24(MessagePackWriter& writer, ReadOnlySpan`1<byte> src);
    public static void WriteRaw25(MessagePackWriter& writer, ReadOnlySpan`1<byte> src);
    public static void WriteRaw26(MessagePackWriter& writer, ReadOnlySpan`1<byte> src);
    public static void WriteRaw27(MessagePackWriter& writer, ReadOnlySpan`1<byte> src);
    public static void WriteRaw28(MessagePackWriter& writer, ReadOnlySpan`1<byte> src);
    public static void WriteRaw29(MessagePackWriter& writer, ReadOnlySpan`1<byte> src);
    public static void WriteRaw30(MessagePackWriter& writer, ReadOnlySpan`1<byte> src);
    public static void WriteRaw31(MessagePackWriter& writer, ReadOnlySpan`1<byte> src);
    public static void WriteRaw1(MessagePackWriter& writer, ReadOnlySpan`1<byte> src);
    public static void WriteRaw2(MessagePackWriter& writer, ReadOnlySpan`1<byte> src);
    public static void WriteRaw3(MessagePackWriter& writer, ReadOnlySpan`1<byte> src);
}
public static class MessagePack.Internal.UnsafeMemory64 : object {
    public static void WriteRaw8(MessagePackWriter& writer, ReadOnlySpan`1<byte> src);
    public static void WriteRaw9(MessagePackWriter& writer, ReadOnlySpan`1<byte> src);
    public static void WriteRaw10(MessagePackWriter& writer, ReadOnlySpan`1<byte> src);
    public static void WriteRaw11(MessagePackWriter& writer, ReadOnlySpan`1<byte> src);
    public static void WriteRaw12(MessagePackWriter& writer, ReadOnlySpan`1<byte> src);
    public static void WriteRaw13(MessagePackWriter& writer, ReadOnlySpan`1<byte> src);
    public static void WriteRaw14(MessagePackWriter& writer, ReadOnlySpan`1<byte> src);
    public static void WriteRaw15(MessagePackWriter& writer, ReadOnlySpan`1<byte> src);
    public static void WriteRaw16(MessagePackWriter& writer, ReadOnlySpan`1<byte> src);
    public static void WriteRaw17(MessagePackWriter& writer, ReadOnlySpan`1<byte> src);
    public static void WriteRaw18(MessagePackWriter& writer, ReadOnlySpan`1<byte> src);
    public static void WriteRaw19(MessagePackWriter& writer, ReadOnlySpan`1<byte> src);
    public static void WriteRaw20(MessagePackWriter& writer, ReadOnlySpan`1<byte> src);
    public static void WriteRaw21(MessagePackWriter& writer, ReadOnlySpan`1<byte> src);
    public static void WriteRaw22(MessagePackWriter& writer, ReadOnlySpan`1<byte> src);
    public static void WriteRaw23(MessagePackWriter& writer, ReadOnlySpan`1<byte> src);
    public static void WriteRaw24(MessagePackWriter& writer, ReadOnlySpan`1<byte> src);
    public static void WriteRaw25(MessagePackWriter& writer, ReadOnlySpan`1<byte> src);
    public static void WriteRaw26(MessagePackWriter& writer, ReadOnlySpan`1<byte> src);
    public static void WriteRaw27(MessagePackWriter& writer, ReadOnlySpan`1<byte> src);
    public static void WriteRaw28(MessagePackWriter& writer, ReadOnlySpan`1<byte> src);
    public static void WriteRaw29(MessagePackWriter& writer, ReadOnlySpan`1<byte> src);
    public static void WriteRaw30(MessagePackWriter& writer, ReadOnlySpan`1<byte> src);
    public static void WriteRaw31(MessagePackWriter& writer, ReadOnlySpan`1<byte> src);
    public static void WriteRaw1(MessagePackWriter& writer, ReadOnlySpan`1<byte> src);
    public static void WriteRaw2(MessagePackWriter& writer, ReadOnlySpan`1<byte> src);
    public static void WriteRaw3(MessagePackWriter& writer, ReadOnlySpan`1<byte> src);
    public static void WriteRaw4(MessagePackWriter& writer, ReadOnlySpan`1<byte> src);
    public static void WriteRaw5(MessagePackWriter& writer, ReadOnlySpan`1<byte> src);
    public static void WriteRaw6(MessagePackWriter& writer, ReadOnlySpan`1<byte> src);
    public static void WriteRaw7(MessagePackWriter& writer, ReadOnlySpan`1<byte> src);
}
internal static class MessagePack.LZ4.LZ4Codec : object {
    private static int MEMORY_USAGE;
    private static int NOTCOMPRESSIBLE_DETECTIONLEVEL;
    private static int MINMATCH;
    private static int SKIPSTRENGTH;
    private static int COPYLENGTH;
    private static int LASTLITERALS;
    private static int MFLIMIT;
    private static int MINLENGTH;
    private static int MAXD_LOG;
    private static int MAXD;
    private static int MAXD_MASK;
    private static int MAX_DISTANCE;
    private static int ML_BITS;
    private static int ML_MASK;
    private static int RUN_BITS;
    private static int RUN_MASK;
    private static int STEPSIZE_64;
    private static int STEPSIZE_32;
    private static int LZ4_64KLIMIT;
    private static int HASH_LOG;
    private static int HASH_TABLESIZE;
    private static int HASH_ADJUST;
    private static int HASH64K_LOG;
    private static int HASH64K_TABLESIZE;
    private static int HASH64K_ADJUST;
    private static int HASHHC_LOG;
    private static int HASHHC_TABLESIZE;
    private static int HASHHC_ADJUST;
    private static int MAX_NB_ATTEMPTS;
    private static int OPTIMAL_ML;
    private static int BLOCK_COPY_LIMIT;
    private static Int32[] DECODER_TABLE_32;
    private static Int32[] DECODER_TABLE_64;
    private static Int32[] DEBRUIJN_TABLE_32;
    private static Int32[] DEBRUIJN_TABLE_64;
    private static LZ4Codec();
    public static int MaximumOutputLength(int inputLength);
    internal static void CheckArguments(Byte[] input, int inputOffset, int inputLength, Byte[] output, int outputOffset, int outputLength);
    public static int Encode(ReadOnlySpan`1<byte> input, Span`1<byte> output);
    public static int Decode(ReadOnlySpan`1<byte> input, Span`1<byte> output);
    private static int LZ4_compressCtx_32(UInt32* hash_table, Byte* src, Byte* dst, int src_len, int dst_maxlen);
    private static int LZ4_compress64kCtx_32(UInt16* hash_table, Byte* src, Byte* dst, int src_len, int dst_maxlen);
    private static int LZ4_uncompress_32(Byte* src, Byte* dst, int dst_len);
    private static void BlockCopy32(Byte* src, Byte* dst, int len);
    private static int LZ4_compressCtx_64(UInt32* hash_table, Byte* src, Byte* dst, int src_len, int dst_maxlen);
    private static int LZ4_compress64kCtx_64(UInt16* hash_table, Byte* src, Byte* dst, int src_len, int dst_maxlen);
    private static int LZ4_uncompress_64(Byte* src, Byte* dst, int dst_len);
    private static void BlockCopy64(Byte* src, Byte* dst, int len);
}
public static class MessagePack.MessagePackCode : object {
    public static byte MinFixInt;
    public static byte MaxFixInt;
    public static byte MinFixMap;
    public static byte MaxFixMap;
    public static byte MinFixArray;
    public static byte MaxFixArray;
    public static byte MinFixStr;
    public static byte MaxFixStr;
    public static byte Nil;
    public static byte NeverUsed;
    public static byte False;
    public static byte True;
    public static byte Bin8;
    public static byte Bin16;
    public static byte Bin32;
    public static byte Ext8;
    public static byte Ext16;
    public static byte Ext32;
    public static byte Float32;
    public static byte Float64;
    public static byte UInt8;
    public static byte UInt16;
    public static byte UInt32;
    public static byte UInt64;
    public static byte Int8;
    public static byte Int16;
    public static byte Int32;
    public static byte Int64;
    public static byte FixExt1;
    public static byte FixExt2;
    public static byte FixExt4;
    public static byte FixExt8;
    public static byte FixExt16;
    public static byte Str8;
    public static byte Str16;
    public static byte Str32;
    public static byte Array16;
    public static byte Array32;
    public static byte Map16;
    public static byte Map32;
    public static byte MinNegativeFixInt;
    public static byte MaxNegativeFixInt;
    private static MessagePackType[] TypeLookupTable;
    private static String[] FormatNameTable;
    private static MessagePackCode();
    public static MessagePackType ToMessagePackType(byte code);
    public static string ToFormatName(byte code);
    internal static bool IsSignedInteger(byte code);
}
public enum MessagePack.MessagePackCompression : Enum {
    public int value__;
    public static MessagePackCompression None;
    public static MessagePackCompression Lz4Block;
    public static MessagePackCompression Lz4BlockArray;
}
[ExtensionAttribute]
internal static class MessagePack.MessagePackCompressionExtensions : object {
    [ExtensionAttribute]
public static bool IsCompression(MessagePackCompression compression);
}
public static class MessagePack.MessagePackRange : object {
    public static int MinFixNegativeInt;
    public static int MaxFixNegativeInt;
    public static int MaxFixPositiveInt;
    public static int MinFixStringLength;
    public static int MaxFixStringLength;
    public static int MaxFixMapCount;
    public static int MaxFixArrayCount;
}
[IsByRefLikeAttribute]
[ObsoleteAttribute("Types with embedded references are not supported in this version of your compiler.", "True")]
public class MessagePack.MessagePackReader : ValueType {
    private SequenceReader`1<byte> reader;
    [CompilerGeneratedAttribute]
private CancellationToken <CancellationToken>k__BackingField;
    [CompilerGeneratedAttribute]
private int <Depth>k__BackingField;
    public CancellationToken CancellationToken { get; public set; }
    public int Depth { get; public set; }
    public ReadOnlySequence`1<byte> Sequence { get; }
    public SequencePosition Position { get; }
    public long Consumed { get; }
    public bool End { get; }
    public bool IsNil { get; }
    public MessagePackType NextMessagePackType { get; }
    public byte NextCode { get; }
    public MessagePackReader(ReadOnlyMemory`1<byte> memory);
    public MessagePackReader(ReadOnlySequence`1& readOnlySequence);
    public byte ReadByte();
    public ushort ReadUInt16();
    public UInt32 ReadUInt32();
    public ulong ReadUInt64();
    public sbyte ReadSByte();
    public short ReadInt16();
    public int ReadInt32();
    public long ReadInt64();
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public CancellationToken get_CancellationToken();
    [CompilerGeneratedAttribute]
public void set_CancellationToken(CancellationToken value);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public int get_Depth();
    [CompilerGeneratedAttribute]
public void set_Depth(int value);
    public ReadOnlySequence`1<byte> get_Sequence();
    public SequencePosition get_Position();
    public long get_Consumed();
    public bool get_End();
    public bool get_IsNil();
    public MessagePackType get_NextMessagePackType();
    public byte get_NextCode();
    public MessagePackReader Clone(ReadOnlySequence`1& readOnlySequence);
    public MessagePackReader CreatePeekReader();
    public void Skip();
    internal bool TrySkip();
    public Nil ReadNil();
    public bool TryReadNil();
    public ReadOnlySequence`1<byte> ReadRaw(long length);
    public ReadOnlySequence`1<byte> ReadRaw();
    public int ReadArrayHeader();
    public bool TryReadArrayHeader(Int32& count);
    public int ReadMapHeader();
    public bool TryReadMapHeader(Int32& count);
    public bool ReadBoolean();
    public char ReadChar();
    public float ReadSingle();
    public double ReadDouble();
    public DateTime ReadDateTime();
    public DateTime ReadDateTime(ExtensionHeader header);
    public Nullable`1<ReadOnlySequence`1<byte>> ReadBytes();
    public Nullable`1<ReadOnlySequence`1<byte>> ReadStringSequence();
    public bool TryReadStringSpan(ReadOnlySpan`1& span);
    public string ReadString();
    public ExtensionHeader ReadExtensionFormatHeader();
    public bool TryReadExtensionFormatHeader(ExtensionHeader& extensionHeader);
    public ExtensionResult ReadExtensionFormat();
    private static EndOfStreamException ThrowNotEnoughBytesException();
    private static EndOfStreamException ThrowNotEnoughBytesException(Exception innerException);
    private static Exception ThrowInvalidCode(byte code);
    private static void ThrowInsufficientBufferUnless(bool condition);
    private int GetBytesLength();
    private bool TryGetBytesLength(Int32& length);
    private bool TryGetStringLengthInBytes(Int32& length);
    private int GetStringLengthInBytes();
    private bool TryGetStringLengthInBytesSlow(byte code, Int32& length);
    private string ReadStringSlow(int byteLength);
    private bool TrySkipNextArray();
    private bool TrySkipNextMap();
    private bool TrySkip(int count);
}
public class MessagePack.MessagePackSecurity : object {
    public static MessagePackSecurity TrustedData;
    public static MessagePackSecurity UntrustedData;
    private ObjectFallbackEqualityComparer objectFallbackEqualityComparer;
    [CompilerGeneratedAttribute]
private bool <HashCollisionResistant>k__BackingField;
    [CompilerGeneratedAttribute]
private int <MaximumObjectGraphDepth>k__BackingField;
    public bool HashCollisionResistant { get; private set; }
    public int MaximumObjectGraphDepth { get; private set; }
    protected MessagePackSecurity(MessagePackSecurity copyFrom);
    private static MessagePackSecurity();
    [CompilerGeneratedAttribute]
public bool get_HashCollisionResistant();
    [CompilerGeneratedAttribute]
private void set_HashCollisionResistant(bool value);
    [CompilerGeneratedAttribute]
public int get_MaximumObjectGraphDepth();
    [CompilerGeneratedAttribute]
private void set_MaximumObjectGraphDepth(int value);
    public MessagePackSecurity WithMaximumObjectGraphDepth(int maximumObjectGraphDepth);
    public MessagePackSecurity WithHashCollisionResistant(bool hashCollisionResistant);
    public IEqualityComparer`1<T> GetEqualityComparer();
    public IEqualityComparer GetEqualityComparer();
    protected virtual IEqualityComparer`1<T> GetHashCollisionResistantEqualityComparer();
    public void DepthStep(MessagePackReader& reader);
    protected virtual IEqualityComparer GetHashCollisionResistantEqualityComparer();
    protected virtual MessagePackSecurity Clone();
}
public class MessagePack.MessagePackSerializationException : Exception {
    public MessagePackSerializationException(string message);
    public MessagePackSerializationException(string message, Exception inner);
    protected MessagePackSerializationException(SerializationInfo info, StreamingContext context);
}
public static class MessagePack.MessagePackSerializer : object {
    private static int LZ4NotCompressionSizeInLz4BlockType;
    private static int MaxHintSize;
    [CompilerGeneratedAttribute]
private static MessagePackSerializerOptions <DefaultOptions>k__BackingField;
    [ThreadStaticAttribute]
private static Byte[] scratchArray;
    private static LZ4Transform LZ4CodecEncode;
    private static LZ4Transform LZ4CodecDecode;
    private static Func`2<Type, CompiledMethods> CreateCompiledMethods;
    private static ThreadsafeTypeKeyHashTable`1<CompiledMethods> Serializes;
    public static MessagePackSerializerOptions DefaultOptions { get; public set; }
    private static MessagePackSerializer();
    [CompilerGeneratedAttribute]
public static MessagePackSerializerOptions get_DefaultOptions();
    [CompilerGeneratedAttribute]
public static void set_DefaultOptions(MessagePackSerializerOptions value);
    public static void Serialize(IBufferWriter`1<byte> writer, T value, MessagePackSerializerOptions options, CancellationToken cancellationToken);
    public static void Serialize(MessagePackWriter& writer, T value, MessagePackSerializerOptions options);
    public static Byte[] Serialize(T value, MessagePackSerializerOptions options, CancellationToken cancellationToken);
    public static void Serialize(Stream stream, T value, MessagePackSerializerOptions options, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("MessagePack.MessagePackSerializer/<SerializeAsync>d__12`1")]
public static Task SerializeAsync(Stream stream, T value, MessagePackSerializerOptions options, CancellationToken cancellationToken);
    public static T Deserialize(ReadOnlySequence`1& byteSequence, MessagePackSerializerOptions options, CancellationToken cancellationToken);
    public static T Deserialize(MessagePackReader& reader, MessagePackSerializerOptions options);
    public static T Deserialize(ReadOnlyMemory`1<byte> buffer, MessagePackSerializerOptions options, CancellationToken cancellationToken);
    public static T Deserialize(ReadOnlyMemory`1<byte> buffer, Int32& bytesRead, CancellationToken cancellationToken);
    public static T Deserialize(ReadOnlyMemory`1<byte> buffer, MessagePackSerializerOptions options, Int32& bytesRead, CancellationToken cancellationToken);
    public static T Deserialize(Stream stream, MessagePackSerializerOptions options, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("MessagePack.MessagePackSerializer/<DeserializeAsync>d__19`1")]
public static ValueTask`1<T> DeserializeAsync(Stream stream, MessagePackSerializerOptions options, CancellationToken cancellationToken);
    private static bool TryDeserializeFromMemoryStream(Stream stream, MessagePackSerializerOptions options, CancellationToken cancellationToken, T& result);
    private static T DeserializeFromSequenceAndRewindStreamIfPossible(Stream streamToRewind, MessagePackSerializerOptions options, ReadOnlySequence`1<byte> sequence, CancellationToken cancellationToken);
    private static int LZ4Operation(ReadOnlySequence`1& input, Span`1<byte> output, LZ4Transform lz4Operation);
    private static bool TryDecompress(MessagePackReader& reader, IBufferWriter`1<byte> writer);
    private static void ToLZ4BinaryCore(ReadOnlySequence`1& msgpackUncompressedData, MessagePackWriter& writer, MessagePackCompression compression);
    private static int GetUInt32WriteSize(UInt32 value);
    private static void WriteBin32Header(UInt32 value, Span`1<byte> span);
    private static bool IsMessagePackFixedSizePrimitiveTypeHelper(Type type);
    public static void SerializeToJson(TextWriter textWriter, T obj, MessagePackSerializerOptions options, CancellationToken cancellationToken);
    public static string SerializeToJson(T obj, MessagePackSerializerOptions options, CancellationToken cancellationToken);
    public static string ConvertToJson(ReadOnlyMemory`1<byte> bytes, MessagePackSerializerOptions options, CancellationToken cancellationToken);
    public static string ConvertToJson(ReadOnlySequence`1& bytes, MessagePackSerializerOptions options, CancellationToken cancellationToken);
    public static void ConvertToJson(MessagePackReader& reader, TextWriter jsonWriter, MessagePackSerializerOptions options);
    public static void ConvertFromJson(string str, MessagePackWriter& writer, MessagePackSerializerOptions options);
    public static Byte[] ConvertFromJson(string str, MessagePackSerializerOptions options, CancellationToken cancellationToken);
    public static void ConvertFromJson(TextReader reader, MessagePackWriter& writer, MessagePackSerializerOptions options);
    private static UInt32 FromJsonCore(TinyJsonReader jr, MessagePackWriter& writer);
    private static void ToJsonCore(MessagePackReader& reader, TextWriter writer, MessagePackSerializerOptions options);
    private static void WriteJsonString(string value, TextWriter builder);
    public static void Serialize(Type type, MessagePackWriter& writer, object obj, MessagePackSerializerOptions options);
    public static void Serialize(Type type, IBufferWriter`1<byte> writer, object obj, MessagePackSerializerOptions options, CancellationToken cancellationToken);
    public static Byte[] Serialize(Type type, object obj, MessagePackSerializerOptions options, CancellationToken cancellationToken);
    public static void Serialize(Type type, Stream stream, object obj, MessagePackSerializerOptions options, CancellationToken cancellationToken);
    public static Task SerializeAsync(Type type, Stream stream, object obj, MessagePackSerializerOptions options, CancellationToken cancellationToken);
    public static object Deserialize(Type type, MessagePackReader& reader, MessagePackSerializerOptions options);
    public static object Deserialize(Type type, Stream stream, MessagePackSerializerOptions options, CancellationToken cancellationToken);
    public static ValueTask`1<object> DeserializeAsync(Type type, Stream stream, MessagePackSerializerOptions options, CancellationToken cancellationToken);
    public static object Deserialize(Type type, ReadOnlyMemory`1<byte> bytes, MessagePackSerializerOptions options, CancellationToken cancellationToken);
    public static object Deserialize(Type type, ReadOnlySequence`1<byte> bytes, MessagePackSerializerOptions options, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("MessagePack.MessagePackSerializer/<DeserializeObjectAsync>d__56`1")]
private static ValueTask`1<object> DeserializeObjectAsync(Stream stream, MessagePackSerializerOptions options, CancellationToken cancellationToken);
    private static CompiledMethods GetOrAdd(Type type);
}
public class MessagePack.MessagePackSerializerOptions : object {
    internal static Regex AssemblyNameVersionSelectorRegex;
    private static HashSet`1<string> BlacklistCheck;
    [CompilerGeneratedAttribute]
private IFormatterResolver <Resolver>k__BackingField;
    [CompilerGeneratedAttribute]
private MessagePackCompression <Compression>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<bool> <OldSpec>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <OmitAssemblyVersion>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <AllowAssemblyVersionMismatch>k__BackingField;
    [CompilerGeneratedAttribute]
private MessagePackSecurity <Security>k__BackingField;
    public static MessagePackSerializerOptions Standard { get; }
    public IFormatterResolver Resolver { get; private set; }
    public MessagePackCompression Compression { get; private set; }
    public Nullable`1<bool> OldSpec { get; private set; }
    public bool OmitAssemblyVersion { get; private set; }
    public bool AllowAssemblyVersionMismatch { get; private set; }
    public MessagePackSecurity Security { get; private set; }
    protected internal MessagePackSerializerOptions(IFormatterResolver resolver);
    protected MessagePackSerializerOptions(MessagePackSerializerOptions copyFrom);
    private static MessagePackSerializerOptions();
    public static MessagePackSerializerOptions get_Standard();
    [CompilerGeneratedAttribute]
public IFormatterResolver get_Resolver();
    [CompilerGeneratedAttribute]
private void set_Resolver(IFormatterResolver value);
    [CompilerGeneratedAttribute]
public MessagePackCompression get_Compression();
    [CompilerGeneratedAttribute]
private void set_Compression(MessagePackCompression value);
    [CompilerGeneratedAttribute]
public Nullable`1<bool> get_OldSpec();
    [CompilerGeneratedAttribute]
private void set_OldSpec(Nullable`1<bool> value);
    [CompilerGeneratedAttribute]
public bool get_OmitAssemblyVersion();
    [CompilerGeneratedAttribute]
private void set_OmitAssemblyVersion(bool value);
    [CompilerGeneratedAttribute]
public bool get_AllowAssemblyVersionMismatch();
    [CompilerGeneratedAttribute]
private void set_AllowAssemblyVersionMismatch(bool value);
    [CompilerGeneratedAttribute]
public MessagePackSecurity get_Security();
    [CompilerGeneratedAttribute]
private void set_Security(MessagePackSecurity value);
    public virtual Type LoadType(string typeName);
    public virtual void ThrowIfDeserializingTypeIsDisallowed(Type type);
    public MessagePackSerializerOptions WithResolver(IFormatterResolver resolver);
    public MessagePackSerializerOptions WithCompression(MessagePackCompression compression);
    public MessagePackSerializerOptions WithOldSpec(Nullable`1<bool> oldSpec);
    public MessagePackSerializerOptions WithOmitAssemblyVersion(bool omitAssemblyVersion);
    public MessagePackSerializerOptions WithAllowAssemblyVersionMismatch(bool allowAssemblyVersionMismatch);
    public MessagePackSerializerOptions WithSecurity(MessagePackSecurity security);
    protected virtual MessagePackSerializerOptions Clone();
}
public class MessagePack.MessagePackStreamReader : object {
    private Stream stream;
    private bool leaveOpen;
    private Rental sequenceRental;
    private Nullable`1<SequencePosition> endOfLastMessage;
    public ReadOnlySequence`1<byte> RemainingBytes { get; }
    private Sequence`1<byte> ReadData { get; }
    public MessagePackStreamReader(Stream stream);
    public MessagePackStreamReader(Stream stream, bool leaveOpen);
    [AsyncIteratorStateMachineAttribute("MessagePack.MessagePackStreamReader/<ReadArrayAsync>d__0")]
public IAsyncEnumerable`1<ReadOnlySequence`1<byte>> ReadArrayAsync(CancellationToken cancellationToken);
    private bool TryReadArrayHeader(Int32& length);
    public ReadOnlySequence`1<byte> get_RemainingBytes();
    private Sequence`1<byte> get_ReadData();
    [AsyncStateMachineAttribute("MessagePack.MessagePackStreamReader/<ReadAsync>d__12")]
public ValueTask`1<Nullable`1<ReadOnlySequence`1<byte>>> ReadAsync(CancellationToken cancellationToken);
    public void DiscardBufferedData();
    public sealed virtual void Dispose();
    private void RecycleLastMessage();
    [AsyncStateMachineAttribute("MessagePack.MessagePackStreamReader/<TryReadMoreDataAsync>d__16")]
private Task`1<bool> TryReadMoreDataAsync(CancellationToken cancellationToken);
    private bool TryReadNextMessage(ReadOnlySequence`1& completeMessage);
}
public enum MessagePack.MessagePackType : Enum {
    public byte value__;
    public static MessagePackType Unknown;
    public static MessagePackType Integer;
    public static MessagePackType Nil;
    public static MessagePackType Boolean;
    public static MessagePackType Float;
    public static MessagePackType String;
    public static MessagePackType Binary;
    public static MessagePackType Array;
    public static MessagePackType Map;
    public static MessagePackType Extension;
}
[IsByRefLikeAttribute]
[ObsoleteAttribute("Types with embedded references are not supported in this version of your compiler.", "True")]
public class MessagePack.MessagePackWriter : ValueType {
    private BufferWriter writer;
    [CompilerGeneratedAttribute]
private CancellationToken <CancellationToken>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <OldSpec>k__BackingField;
    public CancellationToken CancellationToken { get; public set; }
    public bool OldSpec { get; public set; }
    public MessagePackWriter(IBufferWriter`1<byte> writer);
    internal MessagePackWriter(SequencePool sequencePool, Byte[] array);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public CancellationToken get_CancellationToken();
    [CompilerGeneratedAttribute]
public void set_CancellationToken(CancellationToken value);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public bool get_OldSpec();
    [CompilerGeneratedAttribute]
public void set_OldSpec(bool value);
    public MessagePackWriter Clone(IBufferWriter`1<byte> writer);
    public void Flush();
    public void WriteNil();
    public void WriteRaw(ReadOnlySpan`1<byte> rawMessagePackBlock);
    public void WriteRaw(ReadOnlySequence`1& rawMessagePackBlock);
    public void WriteArrayHeader(int count);
    public void WriteArrayHeader(UInt32 count);
    public void WriteMapHeader(int count);
    public void WriteMapHeader(UInt32 count);
    public void Write(byte value);
    public void WriteUInt8(byte value);
    public void Write(sbyte value);
    public void WriteInt8(sbyte value);
    public void Write(ushort value);
    public void WriteUInt16(ushort value);
    public void Write(short value);
    public void WriteInt16(short value);
    public void Write(UInt32 value);
    public void WriteUInt32(UInt32 value);
    public void Write(int value);
    public void WriteInt32(int value);
    public void Write(ulong value);
    public void WriteUInt64(ulong value);
    public void Write(long value);
    public void WriteInt64(long value);
    public void Write(bool value);
    public void Write(char value);
    public void Write(float value);
    public void Write(double value);
    public void Write(DateTime dateTime);
    public void Write(Byte[] src);
    public void Write(ReadOnlySpan`1<byte> src);
    public void Write(ReadOnlySequence`1& src);
    public void WriteBinHeader(int length);
    public void WriteString(ReadOnlySequence`1& utf8stringBytes);
    public void WriteString(ReadOnlySpan`1<byte> utf8stringBytes);
    public void WriteStringHeader(int byteCount);
    public void Write(string value);
    public void Write(ReadOnlySpan`1<char> value);
    public void WriteExtensionFormatHeader(ExtensionHeader extensionHeader);
    public void WriteExtensionFormat(ExtensionResult extensionData);
    public Span`1<byte> GetSpan(int length);
    public void Advance(int length);
    internal void WriteBigEndian(ushort value);
    internal void WriteBigEndian(UInt32 value);
    internal void WriteBigEndian(ulong value);
    internal Byte[] FlushAndGetArray();
    private static void WriteBigEndian(short value, Span`1<byte> span);
    private static void WriteBigEndian(int value, Span`1<byte> span);
    private static void WriteBigEndian(long value, Span`1<byte> span);
    private static void WriteBigEndian(ushort value, Span`1<byte> span);
    private static void WriteBigEndian(ushort value, Byte* span);
    private static void WriteBigEndian(UInt32 value, Span`1<byte> span);
    private static void WriteBigEndian(UInt32 value, Byte* span);
    private static void WriteBigEndian(ulong value, Span`1<byte> span);
    private static void WriteBigEndian(float value, Span`1<byte> span);
    private static void WriteBigEndian(double value, Span`1<byte> span);
    private Byte& WriteString_PrepareSpan(int characterLength, Int32& bufferSize, Int32& encodedBytesOffset);
    private void WriteString_PostEncoding(Byte* pBuffer, int estimatedOffset, int byteCount);
    private static void MemoryCopy(Void* source, Void* destination, long destinationSizeInBytes, long sourceBytesToCopy);
}
public class MessagePack.Nil : ValueType {
    public static Nil Default;
    private static Nil();
    public virtual bool Equals(object obj);
    public sealed virtual bool Equals(Nil other);
    public virtual int GetHashCode();
    public virtual string ToString();
}
public static class MessagePack.ReservedMessagePackExtensionTypeCode : object {
    public static sbyte DateTime;
}
public class MessagePack.Resolvers.AttributeFormatterResolver : object {
    public static AttributeFormatterResolver Instance;
    private static AttributeFormatterResolver();
    public sealed virtual IMessagePackFormatter`1<T> GetFormatter();
}
public class MessagePack.Resolvers.BuiltinResolver : object {
    public static BuiltinResolver Instance;
    private static BuiltinResolver();
    public sealed virtual IMessagePackFormatter`1<T> GetFormatter();
}
internal abstract class MessagePack.Resolvers.CachingFormatterResolver : object {
    private ThreadsafeTypeKeyHashTable`1<IMessagePackFormatter> formatters;
    public sealed virtual IMessagePackFormatter`1<T> GetFormatter();
    protected abstract virtual IMessagePackFormatter`1<T> GetFormatterCore();
}
public static class MessagePack.Resolvers.CompositeResolver : object {
    private static ReadOnlyDictionary`2<Type, IMessagePackFormatter> EmptyFormattersByType;
    private static CompositeResolver();
    public static IFormatterResolver Create(IReadOnlyList`1<IMessagePackFormatter> formatters, IReadOnlyList`1<IFormatterResolver> resolvers);
    public static IFormatterResolver Create(IFormatterResolver[] resolvers);
    public static IFormatterResolver Create(IMessagePackFormatter[] formatters);
}
public class MessagePack.Resolvers.ContractlessStandardResolver : object {
    public static ContractlessStandardResolver Instance;
    public static MessagePackSerializerOptions Options;
    private static IFormatterResolver[] Resolvers;
    private static ContractlessStandardResolver();
    public sealed virtual IMessagePackFormatter`1<T> GetFormatter();
}
public class MessagePack.Resolvers.ContractlessStandardResolverAllowPrivate : object {
    public static ContractlessStandardResolverAllowPrivate Instance;
    public static MessagePackSerializerOptions Options;
    private static IFormatterResolver[] Resolvers;
    private static ContractlessStandardResolverAllowPrivate();
    public sealed virtual IMessagePackFormatter`1<T> GetFormatter();
}
public class MessagePack.Resolvers.DynamicContractlessObjectResolver : object {
    public static DynamicContractlessObjectResolver Instance;
    private static string ModuleName;
    private static DynamicAssembly DynamicAssembly;
    private static DynamicContractlessObjectResolver();
    public sealed virtual IMessagePackFormatter`1<T> GetFormatter();
}
public class MessagePack.Resolvers.DynamicContractlessObjectResolverAllowPrivate : object {
    public static DynamicContractlessObjectResolverAllowPrivate Instance;
    private static DynamicContractlessObjectResolverAllowPrivate();
    public sealed virtual IMessagePackFormatter`1<T> GetFormatter();
}
public class MessagePack.Resolvers.DynamicEnumAsStringResolver : object {
    public static DynamicEnumAsStringResolver Instance;
    public static MessagePackSerializerOptions Options;
    private static DynamicEnumAsStringResolver();
    public sealed virtual IMessagePackFormatter`1<T> GetFormatter();
}
public class MessagePack.Resolvers.DynamicEnumResolver : object {
    public static DynamicEnumResolver Instance;
    private static string ModuleName;
    private static DynamicAssembly DynamicAssembly;
    private static int nameSequence;
    private static DynamicEnumResolver();
    public sealed virtual IMessagePackFormatter`1<T> GetFormatter();
    private static TypeInfo BuildType(Type enumType);
}
public class MessagePack.Resolvers.DynamicGenericResolver : object {
    public static DynamicGenericResolver Instance;
    private static DynamicGenericResolver();
    public sealed virtual IMessagePackFormatter`1<T> GetFormatter();
}
public class MessagePack.Resolvers.DynamicObjectResolver : object {
    private static string ModuleName;
    public static DynamicObjectResolver Instance;
    public static MessagePackSerializerOptions Options;
    internal static DynamicAssembly DynamicAssembly;
    private static DynamicObjectResolver();
    public sealed virtual IMessagePackFormatter`1<T> GetFormatter();
}
public class MessagePack.Resolvers.DynamicObjectResolverAllowPrivate : object {
    public static DynamicObjectResolverAllowPrivate Instance;
    private static DynamicObjectResolverAllowPrivate();
    public sealed virtual IMessagePackFormatter`1<T> GetFormatter();
}
public class MessagePack.Resolvers.DynamicUnionResolver : object {
    private static string ModuleName;
    public static DynamicUnionResolver Instance;
    public static MessagePackSerializerOptions Options;
    private static DynamicAssembly DynamicAssembly;
    private static Regex SubtractFullNameRegex;
    private static int nameSequence;
    private static Type refMessagePackReader;
    private static Type refKvp;
    private static MethodInfo getFormatterWithVerify;
    private static MethodInfo getResolverFromOptions;
    private static Func`2<Type, MethodInfo> getSerialize;
    private static Func`2<Type, MethodInfo> getDeserialize;
    private static FieldInfo runtimeTypeHandleEqualityComparer;
    private static ConstructorInfo intIntKeyValuePairConstructor;
    private static ConstructorInfo typeMapDictionaryConstructor;
    private static MethodInfo typeMapDictionaryAdd;
    private static MethodInfo typeMapDictionaryTryGetValue;
    private static ConstructorInfo keyMapDictionaryConstructor;
    private static MethodInfo keyMapDictionaryAdd;
    private static MethodInfo keyMapDictionaryTryGetValue;
    private static MethodInfo objectGetType;
    private static MethodInfo getTypeHandle;
    private static MethodInfo intIntKeyValuePairGetKey;
    private static MethodInfo intIntKeyValuePairGetValue;
    private static ConstructorInfo invalidOperationExceptionConstructor;
    private static ConstructorInfo objectCtor;
    private static DynamicUnionResolver();
    public sealed virtual IMessagePackFormatter`1<T> GetFormatter();
    private static TypeInfo BuildType(Type type);
    private static void BuildConstructor(Type type, UnionAttribute[] infos, ConstructorInfo method, FieldBuilder typeToKeyAndJumpMap, FieldBuilder keyToJumpMap, ILGenerator il);
    private static void BuildSerialize(Type type, UnionAttribute[] infos, MethodBuilder method, FieldBuilder typeToKeyAndJumpMap, ILGenerator il);
    private static void BuildDeserialize(Type type, UnionAttribute[] infos, MethodBuilder method, FieldBuilder keyToJumpMap, ILGenerator il);
    private static bool IsZeroStartSequential(UnionAttribute[] infos);
}
internal class MessagePack.Resolvers.ForceSizePrimitiveObjectResolver : object {
    public static ForceSizePrimitiveObjectResolver Instance;
    public static MessagePackSerializerOptions Options;
    private static ForceSizePrimitiveObjectResolver();
    public sealed virtual IMessagePackFormatter`1<T> GetFormatter();
}
internal class MessagePack.Resolvers.MessagePackDynamicUnionResolverException : MessagePackSerializationException {
    public MessagePackDynamicUnionResolverException(string message);
}
public class MessagePack.Resolvers.NativeDateTimeResolver : object {
    public static NativeDateTimeResolver Instance;
    public static MessagePackSerializerOptions Options;
    private static NativeDateTimeResolver();
    public sealed virtual IMessagePackFormatter`1<T> GetFormatter();
}
public class MessagePack.Resolvers.NativeDecimalResolver : object {
    public static NativeDecimalResolver Instance;
    private static NativeDecimalResolver();
    public sealed virtual IMessagePackFormatter`1<T> GetFormatter();
    private static object GetFormatterHelper(Type t);
}
public class MessagePack.Resolvers.NativeGuidResolver : object {
    public static NativeGuidResolver Instance;
    private static NativeGuidResolver();
    public sealed virtual IMessagePackFormatter`1<T> GetFormatter();
    private static object GetFormatterHelper(Type t);
}
public class MessagePack.Resolvers.PrimitiveObjectResolver : object {
    public static PrimitiveObjectResolver Instance;
    public static MessagePackSerializerOptions Options;
    private static PrimitiveObjectResolver();
    public sealed virtual IMessagePackFormatter`1<T> GetFormatter();
}
public class MessagePack.Resolvers.StandardResolver : object {
    public static StandardResolver Instance;
    public static MessagePackSerializerOptions Options;
    private static IFormatterResolver[] Resolvers;
    private static StandardResolver();
    public sealed virtual IMessagePackFormatter`1<T> GetFormatter();
}
public class MessagePack.Resolvers.StandardResolverAllowPrivate : object {
    public static StandardResolverAllowPrivate Instance;
    public static MessagePackSerializerOptions Options;
    private static IFormatterResolver[] Resolvers;
    private static StandardResolverAllowPrivate();
    public sealed virtual IMessagePackFormatter`1<T> GetFormatter();
}
public class MessagePack.Resolvers.StaticCompositeResolver : object {
    public static StaticCompositeResolver Instance;
    private bool freezed;
    private IReadOnlyList`1<IMessagePackFormatter> formatters;
    private IReadOnlyList`1<IFormatterResolver> resolvers;
    private static StaticCompositeResolver();
    public void Register(IMessagePackFormatter[] formatters);
    public void Register(IFormatterResolver[] resolvers);
    public void Register(IReadOnlyList`1<IMessagePackFormatter> formatters, IReadOnlyList`1<IFormatterResolver> resolvers);
    public sealed virtual IMessagePackFormatter`1<T> GetFormatter();
}
public class MessagePack.Resolvers.TypelessContractlessStandardResolver : object {
    public static TypelessContractlessStandardResolver Instance;
    public static MessagePackSerializerOptions Options;
    private static IReadOnlyList`1<IFormatterResolver> Resolvers;
    private ResolverCache resolverCache;
    private static TypelessContractlessStandardResolver();
    public sealed virtual IMessagePackFormatter`1<T> GetFormatter();
}
public class MessagePack.Resolvers.TypelessObjectResolver : object {
    public static IFormatterResolver Instance;
    private static IFormatterResolver[] Resolvers;
    private static TypelessObjectResolver();
    public sealed virtual IMessagePackFormatter`1<T> GetFormatter();
}
internal static class MessagePack.SafeBitConverter : object {
    internal static long ToInt64(ReadOnlySpan`1<byte> value);
    internal static ulong ToUInt64(ReadOnlySpan`1<byte> value);
    internal static ushort ToUInt16(ReadOnlySpan`1<byte> value);
    internal static UInt32 ToUInt32(ReadOnlySpan`1<byte> value);
}
internal class MessagePack.SequencePool : object {
    internal static SequencePool Shared;
    private static int MinimumSpanLength;
    private int maxSize;
    private Stack`1<Sequence`1<byte>> pool;
    private ArrayPool`1<byte> arrayPool;
    internal SequencePool(int maxSize);
    private static SequencePool();
    internal Rental Rent();
    private void Return(Sequence`1<byte> value);
}
[IsByRefLikeAttribute]
[ObsoleteAttribute("Types with embedded references are not supported in this version of your compiler.", "True")]
internal class MessagePack.SequenceReader`1 : ValueType {
    private bool usingSequence;
    private ReadOnlySequence`1<T> sequence;
    private SequencePosition currentPosition;
    private SequencePosition nextPosition;
    private ReadOnlyMemory`1<T> memory;
    private bool moreData;
    private long length;
    [CompilerGeneratedAttribute]
private ReadOnlySpan`1<T> <CurrentSpan>k__BackingField;
    [CompilerGeneratedAttribute]
private int <CurrentSpanIndex>k__BackingField;
    [CompilerGeneratedAttribute]
private long <Consumed>k__BackingField;
    public bool End { get; }
    public ReadOnlySequence`1<T> Sequence { get; }
    public SequencePosition Position { get; }
    public ReadOnlySpan`1<T> CurrentSpan { get; private set; }
    public int CurrentSpanIndex { get; private set; }
    public ReadOnlySpan`1<T> UnreadSpan { get; }
    public long Consumed { get; private set; }
    public long Remaining { get; }
    public long Length { get; }
    public SequenceReader`1(ReadOnlySequence`1& sequence);
    public SequenceReader`1(ReadOnlyMemory`1<T> memory);
    public bool get_End();
    public ReadOnlySequence`1<T> get_Sequence();
    public SequencePosition get_Position();
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public ReadOnlySpan`1<T> get_CurrentSpan();
    [CompilerGeneratedAttribute]
private void set_CurrentSpan(ReadOnlySpan`1<T> value);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public int get_CurrentSpanIndex();
    [CompilerGeneratedAttribute]
private void set_CurrentSpanIndex(int value);
    public ReadOnlySpan`1<T> get_UnreadSpan();
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public long get_Consumed();
    [CompilerGeneratedAttribute]
private void set_Consumed(long value);
    public long get_Remaining();
    public long get_Length();
    public bool TryPeek(T& value);
    public bool TryRead(T& value);
    public void Rewind(long count);
    private void RetreatToPreviousSpan(long consumed);
    private void ResetReader();
    private void GetNextSpan();
    public void Advance(long count);
    internal void AdvanceCurrentSpan(long count);
    internal void AdvanceWithinSpan(long count);
    internal bool TryAdvance(long count);
    private void AdvanceToNextSpan(long count);
    public bool TryCopyTo(Span`1<T> destination);
    internal bool TryCopyMultisegment(Span`1<T> destination);
}
[ExtensionAttribute]
internal static class MessagePack.SequenceReaderExtensions : object {
    [ExtensionAttribute]
internal static bool TryRead(SequenceReader`1& reader, T& value);
    private static bool TryReadMultisegment(SequenceReader`1& reader, T& value);
    [ExtensionAttribute]
public static bool TryRead(SequenceReader`1& reader, SByte& value);
    [ExtensionAttribute]
public static bool TryReadBigEndian(SequenceReader`1& reader, Int16& value);
    [ExtensionAttribute]
public static bool TryReadBigEndian(SequenceReader`1& reader, UInt16& value);
    private static bool TryReadReverseEndianness(SequenceReader`1& reader, Int16& value);
    [ExtensionAttribute]
public static bool TryReadBigEndian(SequenceReader`1& reader, Int32& value);
    [ExtensionAttribute]
public static bool TryReadBigEndian(SequenceReader`1& reader, UInt32& value);
    private static bool TryReadReverseEndianness(SequenceReader`1& reader, Int32& value);
    [ExtensionAttribute]
public static bool TryReadBigEndian(SequenceReader`1& reader, Int64& value);
    [ExtensionAttribute]
public static bool TryReadBigEndian(SequenceReader`1& reader, UInt64& value);
    private static bool TryReadReverseEndianness(SequenceReader`1& reader, Int64& value);
    [ExtensionAttribute]
public static bool TryReadBigEndian(SequenceReader`1& reader, Single& value);
    [ExtensionAttribute]
public static bool TryReadBigEndian(SequenceReader`1& reader, Double& value);
}
internal static class MessagePack.StringEncoding : object {
    internal static Encoding UTF8;
    private static StringEncoding();
}
internal static class MessagePack.ThisLibraryExtensionTypeCodes : object {
    internal static sbyte UnityVector2;
    internal static sbyte UnityVector3;
    internal static sbyte UnityVector4;
    internal static sbyte UnityQuaternion;
    internal static sbyte UnityColor;
    internal static sbyte UnityBounds;
    internal static sbyte UnityRect;
    internal static sbyte UnityInt;
    internal static sbyte UnityFloat;
    internal static sbyte UnityDouble;
    internal static sbyte Lz4BlockArray;
    internal static sbyte Lz4Block;
    internal static sbyte TypelessFormatter;
}
public class MessagePack.TinyJsonException : MessagePackSerializationException {
    public TinyJsonException(string message);
}
internal class MessagePack.TinyJsonReader : object {
    private TextReader reader;
    private bool disposeInnerReader;
    private StringBuilder reusableBuilder;
    [CompilerGeneratedAttribute]
private TinyJsonToken <TokenType>k__BackingField;
    [CompilerGeneratedAttribute]
private ValueType <ValueType>k__BackingField;
    [CompilerGeneratedAttribute]
private double <DoubleValue>k__BackingField;
    [CompilerGeneratedAttribute]
private long <LongValue>k__BackingField;
    [CompilerGeneratedAttribute]
private ulong <ULongValue>k__BackingField;
    [CompilerGeneratedAttribute]
private decimal <DecimalValue>k__BackingField;
    [CompilerGeneratedAttribute]
private string <StringValue>k__BackingField;
    public TinyJsonToken TokenType { get; private set; }
    public ValueType ValueType { get; private set; }
    public double DoubleValue { get; private set; }
    public long LongValue { get; private set; }
    public ulong ULongValue { get; private set; }
    public decimal DecimalValue { get; private set; }
    public string StringValue { get; private set; }
    public TinyJsonReader(TextReader reader, bool disposeInnerReader);
    [CompilerGeneratedAttribute]
public TinyJsonToken get_TokenType();
    [CompilerGeneratedAttribute]
private void set_TokenType(TinyJsonToken value);
    [CompilerGeneratedAttribute]
public ValueType get_ValueType();
    [CompilerGeneratedAttribute]
private void set_ValueType(ValueType value);
    [CompilerGeneratedAttribute]
public double get_DoubleValue();
    [CompilerGeneratedAttribute]
private void set_DoubleValue(double value);
    [CompilerGeneratedAttribute]
public long get_LongValue();
    [CompilerGeneratedAttribute]
private void set_LongValue(long value);
    [CompilerGeneratedAttribute]
public ulong get_ULongValue();
    [CompilerGeneratedAttribute]
private void set_ULongValue(ulong value);
    [CompilerGeneratedAttribute]
public decimal get_DecimalValue();
    [CompilerGeneratedAttribute]
private void set_DecimalValue(decimal value);
    [CompilerGeneratedAttribute]
public string get_StringValue();
    [CompilerGeneratedAttribute]
private void set_StringValue(string value);
    public bool Read();
    public sealed virtual void Dispose();
    private void SkipWhiteSpace();
    private char ReadChar();
    private static bool IsWordBreak(char c);
    private void ReadNextToken();
    private void ReadValue();
    private void ReadNumber();
    private void ReadString();
}
internal enum MessagePack.TinyJsonToken : Enum {
    public int value__;
    public static TinyJsonToken None;
    public static TinyJsonToken StartObject;
    public static TinyJsonToken EndObject;
    public static TinyJsonToken StartArray;
    public static TinyJsonToken EndArray;
    public static TinyJsonToken Number;
    public static TinyJsonToken String;
    public static TinyJsonToken True;
    public static TinyJsonToken False;
    public static TinyJsonToken Null;
}
[ExtensionAttribute]
internal static class MessagePack.Utilities : object {
    internal static bool IsMono;
    private static Utilities();
    internal static Byte[] GetWriterBytes(TArg arg, GetWriterBytesAction`1<TArg> action);
    [ExtensionAttribute]
internal static Memory`1<T> GetMemoryCheckResult(IBufferWriter`1<T> bufferWriter, int size);
}
internal enum MessagePack.ValueType : Enum {
    public byte value__;
    public static ValueType Null;
    public static ValueType True;
    public static ValueType False;
    public static ValueType Double;
    public static ValueType Long;
    public static ValueType ULong;
    public static ValueType Decimal;
    public static ValueType String;
}
[CompilerGeneratedAttribute]
[EmbeddedAttribute]
internal class Microsoft.CodeAnalysis.EmbeddedAttribute : Attribute {
}
internal static class Nerdbank.Streams.Requires : object {
    [DebuggerStepThroughAttribute]
public static void Range(bool condition, string parameterName, string message);
    [DebuggerStepThroughAttribute]
public static Exception FailRange(string parameterName, string message);
    [DebuggerStepThroughAttribute]
public static T NotNull(T value, string parameterName);
    [DebuggerStepThroughAttribute]
public static void Argument(bool condition, string parameterName, string message);
    [DebuggerStepThroughAttribute]
public static void Argument(bool condition, string parameterName, string message, object arg1);
    [DebuggerStepThroughAttribute]
public static void Argument(bool condition, string parameterName, string message, object arg1, object arg2);
    [DebuggerStepThroughAttribute]
public static void Argument(bool condition, string parameterName, string message, Object[] args);
}
[DebuggerDisplayAttribute("{DebuggerDisplay,nq}")]
internal class Nerdbank.Streams.Sequence`1 : object {
    private static int DefaultLengthFromArrayPool;
    private Stack`1<SequenceSegment<T>> segmentPool;
    private MemoryPool`1<T> memoryPool;
    private ArrayPool`1<T> arrayPool;
    private SequenceSegment<T> first;
    private SequenceSegment<T> last;
    [CompilerGeneratedAttribute]
private int <MinimumSpanLength>k__BackingField;
    public int MinimumSpanLength { get; public set; }
    public ReadOnlySequence`1<T> AsReadOnlySequence { get; }
    public long Length { get; }
    private string DebuggerDisplay { get; }
    public Sequence`1(MemoryPool`1<T> memoryPool);
    public Sequence`1(ArrayPool`1<T> arrayPool);
    private static Sequence`1();
    [CompilerGeneratedAttribute]
public int get_MinimumSpanLength();
    [CompilerGeneratedAttribute]
public void set_MinimumSpanLength(int value);
    public ReadOnlySequence`1<T> get_AsReadOnlySequence();
    public long get_Length();
    private string get_DebuggerDisplay();
    public static ReadOnlySequence`1<T> op_Implicit(Sequence`1<T> sequence);
    public void AdvanceTo(SequencePosition position);
    public sealed virtual void Advance(int count);
    public sealed virtual Memory`1<T> GetMemory(int sizeHint);
    public sealed virtual Span`1<T> GetSpan(int sizeHint);
    [EditorBrowsableAttribute("1")]
public sealed virtual void Dispose();
    public void Reset();
    private SequenceSegment<T> GetSegment(int sizeHint);
    private void Append(SequenceSegment<T> segment);
    private SequenceSegment<T> RecycleAndGetNext(SequenceSegment<T> segment);
}
internal static class Nerdbank.Streams.Verify : object {
    [DebuggerStepThroughAttribute]
internal static void Operation(bool condition, string message);
}
[CompilerGeneratedAttribute]
[EmbeddedAttribute]
internal class System.Runtime.CompilerServices.IsUnmanagedAttribute : Attribute {
}
[GeneratedCodeAttribute("Nerdbank.GitVersioning.Tasks", "3.2.7.52841")]
[ExcludeFromCodeCoverageAttribute]
internal static class ThisAssembly : object {
    internal static string AssemblyVersion;
    internal static string AssemblyFileVersion;
    internal static string AssemblyInformationalVersion;
    internal static string AssemblyName;
    internal static string AssemblyTitle;
    internal static string AssemblyConfiguration;
    internal static string GitCommitId;
    internal static string PublicKey;
    internal static string PublicKeyToken;
    internal static bool IsPublicRelease;
    internal static bool IsPrerelease;
    internal static DateTime GitCommitDate;
    internal static string RootNamespace;
    private static ThisAssembly();
}
