[ExportCodeFixProviderAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.CSharp.AddAccessibilityModifiers.CSharpAddAccessibilityModifiersCodeFixProvider : AbstractAddAccessibilityModifiersCodeFixProvider {
    [NullableContextAttribute("1")]
protected virtual SyntaxNode MapToDeclarator(SyntaxNode node);
}
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
internal class Microsoft.CodeAnalysis.CSharp.AddAccessibilityModifiers.CSharpAddAccessibilityModifiersDiagnosticAnalyzer : AbstractAddAccessibilityModifiersDiagnosticAnalyzer`1<CompilationUnitSyntax> {
    private static CSharpSyntaxFacts SyntaxFacts { get; }
    private static CSharpSyntaxFacts get_SyntaxFacts();
    protected virtual void ProcessCompilationUnit(SyntaxTreeAnalysisContext context, CodeStyleOption2`1<AccessibilityModifiersRequired> option, CompilationUnitSyntax compilationUnit);
    private void ProcessMembers(SyntaxTreeAnalysisContext context, CodeStyleOption2`1<AccessibilityModifiersRequired> option, SyntaxList`1<MemberDeclarationSyntax> members);
    private void ProcessMemberDeclaration(SyntaxTreeAnalysisContext context, CodeStyleOption2`1<AccessibilityModifiersRequired> option, MemberDeclarationSyntax member);
}
[ExportCodeFixProviderAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.CSharp.AddAnonymousTypeMemberName.CSharpAddAnonymousTypeMemberNameCodeFixProvider : AbstractAddAnonymousTypeMemberNameCodeFixProvider`3<ExpressionSyntax, AnonymousObjectCreationExpressionSyntax, AnonymousObjectMemberDeclaratorSyntax> {
    private static string CS0746;
    [CompilerGeneratedAttribute]
private ImmutableArray`1<string> <FixableDiagnosticIds>k__BackingField;
    public ImmutableArray`1<string> FixableDiagnosticIds { get; }
    [CompilerGeneratedAttribute]
public virtual ImmutableArray`1<string> get_FixableDiagnosticIds();
    protected virtual bool HasName(AnonymousObjectMemberDeclaratorSyntax declarator);
    protected virtual ExpressionSyntax GetExpression(AnonymousObjectMemberDeclaratorSyntax declarator);
    protected virtual AnonymousObjectMemberDeclaratorSyntax WithName(AnonymousObjectMemberDeclaratorSyntax declarator, SyntaxToken name);
    protected virtual IEnumerable`1<string> GetAnonymousObjectMemberNames(AnonymousObjectCreationExpressionSyntax initializer);
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[ExportCodeRefactoringProviderAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.CSharp.AddDebuggerDisplay.CSharpAddDebuggerDisplayCodeRefactoringProvider : AbstractAddDebuggerDisplayCodeRefactoringProvider`2<TypeDeclarationSyntax, MethodDeclarationSyntax> {
    protected bool CanNameofAccessNonPublicMembersFromAttributeArgument { get; }
    protected virtual bool get_CanNameofAccessNonPublicMembersFromAttributeArgument();
    protected virtual bool SupportsConstantInterpolatedStrings(Document document);
}
[ExportCodeRefactoringProviderAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.CSharp.AddFileBanner.CSharpAddFileBannerCodeRefactoringProvider : AbstractAddFileBannerCodeRefactoringProvider {
    protected virtual bool IsCommentStartCharacter(char ch);
    protected virtual SyntaxTrivia CreateTrivia(SyntaxTrivia trivia, string text);
}
internal static class Microsoft.CodeAnalysis.CSharp.AddImport.AddImportDiagnosticIds : object {
    public static string CS0103;
    public static string CS0246;
    public static string CS0305;
    public static string CS1061;
    public static string CS1935;
    public static string CS0308;
    public static string CS0122;
    public static string CS0307;
    public static string CS0616;
    public static string CS1501;
    public static string CS1503;
    public static string CS1574;
    public static string CS1580;
    public static string CS1581;
    public static string CS1584;
    public static string CS1929;
    public static string CS1955;
    public static string CS0428;
    public static string CS7036;
    public static string CS8129;
    public static string CS0281;
    public static string CS4036;
    public static string CS1579;
    public static string CS8414;
    public static string CS8411;
    public static string CS8415;
    public static ImmutableArray`1<string> FixableTypeIds;
    public static ImmutableArray`1<string> FixableDiagnosticIds;
    private static AddImportDiagnosticIds();
}
[ExportCodeFixProviderAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.CSharp.AddImport.CSharpAddImportCodeFixProvider : AbstractAddImportCodeFixProvider {
    public ImmutableArray`1<string> FixableDiagnosticIds { get; }
    internal CSharpAddImportCodeFixProvider(IPackageInstallerService installerService, ISymbolSearchService symbolSearchService);
    public virtual ImmutableArray`1<string> get_FixableDiagnosticIds();
}
[ExportLanguageServiceAttribute("Microsoft.CodeAnalysis.AddImport.IAddImportFeatureService", "C#", "Default")]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.CSharp.AddImport.CSharpAddImportFeatureService : AbstractAddImportFeatureService`1<SimpleNameSyntax> {
    protected virtual bool CanAddImport(SyntaxNode node, bool allowInHiddenRegions, CancellationToken cancellationToken);
    protected virtual bool CanAddImportForMethod(string diagnosticId, ISyntaxFacts syntaxFacts, SyntaxNode node, SimpleNameSyntax& nameNode);
    protected virtual bool CanAddImportForDeconstruct(string diagnosticId, SyntaxNode node);
    protected virtual bool CanAddImportForGetAwaiter(string diagnosticId, ISyntaxFacts syntaxFactsService, SyntaxNode node);
    protected virtual bool CanAddImportForGetEnumerator(string diagnosticId, ISyntaxFacts syntaxFactsService, SyntaxNode node);
    protected virtual bool CanAddImportForGetAsyncEnumerator(string diagnosticId, ISyntaxFacts syntaxFactsService, SyntaxNode node);
    protected virtual bool CanAddImportForNamespace(string diagnosticId, SyntaxNode node, SimpleNameSyntax& nameNode);
    protected virtual bool CanAddImportForQuery(string diagnosticId, SyntaxNode node);
    protected virtual bool CanAddImportForType(string diagnosticId, SyntaxNode node, SimpleNameSyntax& nameNode);
    private static bool TryFindStandaloneType(SyntaxNode node, SimpleNameSyntax& nameNode);
    private static SimpleNameSyntax GetLeftMostSimpleName(QualifiedNameSyntax qn);
    protected virtual ISet`1<INamespaceSymbol> GetImportNamespacesInScope(SemanticModel semanticModel, SyntaxNode node, CancellationToken cancellationToken);
    protected virtual ITypeSymbol GetDeconstructInfo(SemanticModel semanticModel, SyntaxNode node, CancellationToken cancellationToken);
    protected virtual ITypeSymbol GetQueryClauseInfo(SemanticModel semanticModel, SyntaxNode node, CancellationToken cancellationToken);
    private static bool InfoBoundSuccessfully(SymbolInfo symbolInfo);
    private static bool InfoBoundSuccessfully(QueryClauseInfo semanticInfo);
    private static bool InfoBoundSuccessfully(ISymbol operation);
    protected virtual string GetDescription(IReadOnlyList`1<string> nameParts);
    protected virtual ValueTuple`2<string, bool> GetDescription(Document document, INamespaceOrTypeSymbol namespaceOrTypeSymbol, SemanticModel semanticModel, SyntaxNode contextNode, CancellationToken cancellationToken);
    private static string GetUsingDirectiveString(INamespaceOrTypeSymbol namespaceOrTypeSymbol);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.CSharp.AddImport.CSharpAddImportFeatureService/<AddImportAsync>d__21")]
protected virtual Task`1<Document> AddImportAsync(SyntaxNode contextNode, INamespaceOrTypeSymbol namespaceOrTypeSymbol, Document document, bool placeSystemNamespaceFirst, bool allowInHiddenRegions, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.CSharp.AddImport.CSharpAddImportFeatureService/<AddImportWorkerAsync>d__22")]
private Task`1<CompilationUnitSyntax> AddImportWorkerAsync(Document document, CompilationUnitSyntax root, SyntaxNode contextNode, INamespaceOrTypeSymbol namespaceOrTypeSymbol, bool placeSystemNamespaceFirst, bool allowInHiddenRegions, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.CSharp.AddImport.CSharpAddImportFeatureService/<AddImportAsync>d__23")]
protected virtual Task`1<Document> AddImportAsync(SyntaxNode contextNode, IReadOnlyList`1<string> namespaceParts, Document document, bool placeSystemNamespaceFirst, bool allowInHiddenRegions, CancellationToken cancellationToken);
    private NameSyntax CreateNameSyntax(IReadOnlyList`1<string> namespaceParts, int index);
    private static ValueTuple`2<ExternAliasDirectiveSyntax, bool> GetExternAliasDirective(INamespaceOrTypeSymbol namespaceSymbol, SemanticModel semanticModel, SyntaxNode contextNode);
    private ValueTuple`2<UsingDirectiveSyntax, bool> GetUsingDirective(Document document, INamespaceOrTypeSymbol namespaceOrTypeSymbol, SemanticModel semanticModel, CompilationUnitSyntax root, SyntaxNode contextNode);
    private static NameSyntax RemoveGlobalAliasIfUnnecessary(SemanticModel semanticModel, NameSyntax nameSyntax, NamespaceDeclarationSyntax namespaceToAddTo);
    private static bool ConflictsWithExistingMember(SemanticModel semanticModel, NamespaceDeclarationSyntax namespaceToAddTo, string rightOfAliasName);
    private NameSyntax AddOrReplaceAlias(NameSyntax nameSyntax, IdentifierNameSyntax alias);
    private static ValueTuple`2<string, bool> GetExternAliasString(INamespaceOrTypeSymbol namespaceSymbol, SemanticModel semanticModel, SyntaxNode contextNode);
    private static bool HasExistingExternAlias(string alias, SyntaxNode contextNode);
    private static CompilationUnitSyntax GetCompilationUnitSyntaxNode(SyntaxNode contextNode, CancellationToken cancellationToken);
    protected virtual bool IsViableExtensionMethod(IMethodSymbol method, SyntaxNode expression, SemanticModel semanticModel, ISyntaxFacts syntaxFacts, CancellationToken cancellationToken);
    protected virtual bool IsAddMethodContext(SyntaxNode node, SemanticModel semanticModel);
}
[ExportLanguageServiceAttribute("Microsoft.CodeAnalysis.AddMissingImports.IAddMissingImportsFeatureService", "C#", "Default")]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.CSharp.AddMissingImports.CSharpAddMissingImportsFeatureService : AbstractAddMissingImportsFeatureService {
    protected ImmutableArray`1<string> FixableDiagnosticIds { get; }
    protected sealed virtual ImmutableArray`1<string> get_FixableDiagnosticIds();
}
[ExportCodeFixProviderAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
[SharedAttribute]
[ExtensionOrderAttribute]
internal class Microsoft.CodeAnalysis.CSharp.AddMissingReference.CSharpAddMissingReferenceCodeFixProvider : AbstractAddMissingReferenceCodeFixProvider {
    private static string CS0012;
    [CompilerGeneratedAttribute]
private ImmutableArray`1<string> <FixableDiagnosticIds>k__BackingField;
    public ImmutableArray`1<string> FixableDiagnosticIds { get; }
    internal CSharpAddMissingReferenceCodeFixProvider(IPackageInstallerService installerService, ISymbolSearchService symbolSearchService);
    [CompilerGeneratedAttribute]
public sealed virtual ImmutableArray`1<string> get_FixableDiagnosticIds();
}
[ExportCodeFixProviderAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.CSharp.AddObsoleteAttribute.CSharpAddObsoleteAttributeCodeFixProvider : AbstractAddObsoleteAttributeCodeFixProvider {
    [CompilerGeneratedAttribute]
private ImmutableArray`1<string> <FixableDiagnosticIds>k__BackingField;
    public ImmutableArray`1<string> FixableDiagnosticIds { get; }
    [CompilerGeneratedAttribute]
public virtual ImmutableArray`1<string> get_FixableDiagnosticIds();
}
[ExportCodeFixProviderAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.CSharp.AddPackage.CSharpAddSpecificPackageCodeFixProvider : AbstractAddSpecificPackageCodeFixProvider {
    private static string CS8179;
    public ImmutableArray`1<string> FixableDiagnosticIds { get; }
    public virtual ImmutableArray`1<string> get_FixableDiagnosticIds();
    protected virtual string GetAssemblyName(string id);
}
[ExportCodeFixProviderAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
[SharedAttribute]
[ExtensionOrderAttribute]
internal class Microsoft.CodeAnalysis.CSharp.AddParameter.CSharpAddParameterCodeFixProvider : AbstractAddParameterCodeFixProvider`6<ArgumentSyntax, AttributeArgumentSyntax, ArgumentListSyntax, AttributeArgumentListSyntax, InvocationExpressionSyntax, BaseObjectCreationExpressionSyntax> {
    private static string CS1501;
    private static string CS1503;
    private static string CS1660;
    private static string CS1729;
    private static string CS1739;
    private static ImmutableArray`1<string> AddParameterFixableDiagnosticIds;
    public ImmutableArray`1<string> FixableDiagnosticIds { get; }
    protected ImmutableArray`1<string> TooManyArgumentsDiagnosticIds { get; }
    protected ImmutableArray`1<string> CannotConvertDiagnosticIds { get; }
    private static CSharpAddParameterCodeFixProvider();
    public virtual ImmutableArray`1<string> get_FixableDiagnosticIds();
    protected virtual ImmutableArray`1<string> get_TooManyArgumentsDiagnosticIds();
    protected virtual ImmutableArray`1<string> get_CannotConvertDiagnosticIds();
    protected virtual RegisterFixData`1<ArgumentSyntax> TryGetLanguageSpecificFixInfo(SemanticModel semanticModel, SyntaxNode node, CancellationToken cancellationToken);
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
internal class Microsoft.CodeAnalysis.CSharp.AddRequiredParentheses.CSharpAddRequiredExpressionParenthesesDiagnosticAnalyzer : AbstractAddRequiredParenthesesDiagnosticAnalyzer`3<ExpressionSyntax, ExpressionSyntax, SyntaxKind> {
    [NullableAttribute("0")]
private static ImmutableArray`1<SyntaxKind> s_kinds;
    private static CSharpAddRequiredExpressionParenthesesDiagnosticAnalyzer();
    [NullableContextAttribute("0")]
protected virtual ImmutableArray`1<SyntaxKind> GetSyntaxNodeKinds();
    protected virtual int GetPrecedence(ExpressionSyntax binaryLike);
    protected virtual bool IsBinaryLike(ExpressionSyntax node);
    protected virtual ValueTuple`3<ExpressionSyntax, SyntaxToken, ExpressionSyntax> GetPartsOfBinaryLike(ExpressionSyntax binaryLike);
    protected virtual ExpressionSyntax TryGetAppropriateParent(ExpressionSyntax binaryLike);
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
internal class Microsoft.CodeAnalysis.CSharp.AddRequiredParentheses.CSharpAddRequiredPatternParenthesesDiagnosticAnalyzer : AbstractAddRequiredParenthesesDiagnosticAnalyzer`3<PatternSyntax, BinaryPatternSyntax, SyntaxKind> {
    [NullableAttribute("0")]
private static ImmutableArray`1<SyntaxKind> s_kinds;
    private static CSharpAddRequiredPatternParenthesesDiagnosticAnalyzer();
    [NullableContextAttribute("0")]
protected virtual ImmutableArray`1<SyntaxKind> GetSyntaxNodeKinds();
    protected virtual int GetPrecedence(BinaryPatternSyntax pattern);
    protected virtual bool IsBinaryLike(PatternSyntax node);
    protected virtual ValueTuple`3<PatternSyntax, SyntaxToken, PatternSyntax> GetPartsOfBinaryLike(BinaryPatternSyntax binaryPattern);
    protected virtual PatternSyntax TryGetAppropriateParent(BinaryPatternSyntax binaryLike);
}
[ExportCodeFixProviderAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
[SharedAttribute]
[ExtensionOrderAttribute]
internal class Microsoft.CodeAnalysis.CSharp.AliasAmbiguousType.CSharpAliasAmbiguousTypeCodeFixProvider : AbstractAliasAmbiguousTypeCodeFixProvider {
    private static string CS0104;
    public ImmutableArray`1<string> FixableDiagnosticIds { get; }
    public virtual ImmutableArray`1<string> get_FixableDiagnosticIds();
    protected virtual string GetTextPreviewOfChange(string alias, ITypeSymbol typeSymbol);
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
internal class Microsoft.CodeAnalysis.CSharp.Analyzers.MatchFolderAndNamespace.CSharpMatchFolderAndNamespaceDiagnosticAnalyzer : AbstractMatchFolderAndNamespaceDiagnosticAnalyzer`1<NamespaceDeclarationSyntax> {
    protected virtual ISyntaxFacts GetSyntaxFacts();
    protected virtual void InitializeWorker(AnalysisContext context);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.CodeAnalysis.CSharp.Analyzers.SimplifyInterpolation.CSharpSimplifyInterpolationHelpers : AbstractSimplifyInterpolationHelpers {
    [CompilerGeneratedAttribute]
private static CSharpSimplifyInterpolationHelpers <Instance>k__BackingField;
    public static CSharpSimplifyInterpolationHelpers Instance { get; }
    protected bool PermitNonLiteralAlignmentComponents { get; }
    private static CSharpSimplifyInterpolationHelpers();
    [CompilerGeneratedAttribute]
public static CSharpSimplifyInterpolationHelpers get_Instance();
    protected virtual bool get_PermitNonLiteralAlignmentComponents();
    protected virtual SyntaxNode GetPreservedInterpolationExpressionSyntax(IOperation operation);
}
internal abstract class Microsoft.CodeAnalysis.CSharp.AssignOutParameters.AbstractAssignOutParametersCodeFixProvider : SyntaxEditorBasedCodeFixProvider {
    private static string CS0177;
    [CompilerGeneratedAttribute]
private ImmutableArray`1<string> <FixableDiagnosticIds>k__BackingField;
    public ImmutableArray`1<string> FixableDiagnosticIds { get; }
    internal CodeFixCategory CodeFixCategory { get; }
    [CompilerGeneratedAttribute]
public sealed virtual ImmutableArray`1<string> get_FixableDiagnosticIds();
    internal sealed virtual CodeFixCategory get_CodeFixCategory();
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.CSharp.AssignOutParameters.AbstractAssignOutParametersCodeFixProvider/<RegisterCodeFixesAsync>d__6")]
public sealed virtual Task RegisterCodeFixesAsync(CodeFixContext context);
    protected abstract virtual void TryRegisterFix(CodeFixContext context, Document document, SyntaxNode container, SyntaxNode location);
    private static ValueTuple`2<SyntaxNode, SyntaxNode> GetContainer(SyntaxNode root, TextSpan span);
    private static bool IsValidLocation(SyntaxNode location);
    private static SyntaxNode GetContainer(SyntaxNode node);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.CSharp.AssignOutParameters.AbstractAssignOutParametersCodeFixProvider/<GetUnassignedParametersAsync>d__11")]
private static Task`1<MultiDictionary`2<SyntaxNode, ValueTuple`2<SyntaxNode, ImmutableArray`1<IParameterSymbol>>>> GetUnassignedParametersAsync(Document document, ImmutableArray`1<Diagnostic> diagnostics, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.CSharp.AssignOutParameters.AbstractAssignOutParametersCodeFixProvider/<FixAllAsync>d__12")]
protected sealed virtual Task FixAllAsync(Document document, ImmutableArray`1<Diagnostic> diagnostics, SyntaxEditor editor, CancellationToken cancellationToken);
    protected abstract virtual void AssignOutParameters(SyntaxEditor editor, SyntaxNode container, ValueSet<SyntaxNode, ValueTuple`2<SyntaxNode, ImmutableArray`1<IParameterSymbol>>> values, CancellationToken cancellationToken);
    protected static ImmutableArray`1<SyntaxNode> GenerateAssignmentStatements(SyntaxGenerator generator, ImmutableArray`1<IParameterSymbol> unassignedParameters);
}
[ExportCodeFixProviderAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.CSharp.AssignOutParameters.AssignOutParametersAboveReturnCodeFixProvider : AbstractAssignOutParametersCodeFixProvider {
    protected virtual void TryRegisterFix(CodeFixContext context, Document document, SyntaxNode container, SyntaxNode location);
    protected virtual void AssignOutParameters(SyntaxEditor editor, SyntaxNode container, ValueSet<SyntaxNode, ValueTuple`2<SyntaxNode, ImmutableArray`1<IParameterSymbol>>> values, CancellationToken cancellationToken);
    private static void AddAssignmentStatements(SyntaxEditor editor, SyntaxNode exprOrStatement, ImmutableArray`1<SyntaxNode> statements);
}
[ExportCodeFixProviderAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.CSharp.AssignOutParameters.AssignOutParametersAtStartCodeFixProvider : AbstractAssignOutParametersCodeFixProvider {
    protected virtual void TryRegisterFix(CodeFixContext context, Document document, SyntaxNode container, SyntaxNode location);
    protected virtual void AssignOutParameters(SyntaxEditor editor, SyntaxNode container, ValueSet<SyntaxNode, ValueTuple`2<SyntaxNode, ImmutableArray`1<IParameterSymbol>>> values, CancellationToken cancellationToken);
}
[ExportAttribute("C#", "Microsoft.CodeAnalysis.BraceCompletion.IBraceCompletionService")]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.CSharp.BraceCompletion.BracketBraceCompletionService : AbstractBraceCompletionService {
    protected char OpeningBrace { get; }
    protected char ClosingBrace { get; }
    protected virtual char get_OpeningBrace();
    protected virtual char get_ClosingBrace();
    [NullableContextAttribute("1")]
public virtual Task`1<bool> AllowOverTypeAsync(BraceCompletionContext context, CancellationToken cancellationToken);
    protected virtual bool IsValidOpeningBraceToken(SyntaxToken token);
    protected virtual bool IsValidClosingBraceToken(SyntaxToken token);
}
[ExportAttribute("C#", "Microsoft.CodeAnalysis.BraceCompletion.IBraceCompletionService")]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.CSharp.BraceCompletion.CharLiteralBraceCompletionService : AbstractBraceCompletionService {
    protected char OpeningBrace { get; }
    protected char ClosingBrace { get; }
    protected virtual char get_OpeningBrace();
    protected virtual char get_ClosingBrace();
    [NullableContextAttribute("1")]
public virtual Task`1<bool> AllowOverTypeAsync(BraceCompletionContext braceCompletionContext, CancellationToken cancellationToken);
    protected virtual bool IsValidOpeningBraceToken(SyntaxToken token);
    protected virtual bool IsValidClosingBraceToken(SyntaxToken token);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExportAttribute("C#", "Microsoft.CodeAnalysis.BraceCompletion.IBraceCompletionService")]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.CSharp.BraceCompletion.CurlyBraceCompletionService : AbstractBraceCompletionService {
    private static SyntaxAnnotation s_closingBraceSyntaxAnnotation;
    protected char OpeningBrace { get; }
    protected char ClosingBrace { get; }
    private static CurlyBraceCompletionService();
    protected virtual char get_OpeningBrace();
    protected virtual char get_ClosingBrace();
    public virtual Task`1<bool> AllowOverTypeAsync(BraceCompletionContext context, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.CSharp.BraceCompletion.CurlyBraceCompletionService/<GetTextChangesAfterCompletionAsync>d__7")]
public virtual Task`1<Nullable`1<BraceCompletionResult>> GetTextChangesAfterCompletionAsync(BraceCompletionContext braceCompletionContext, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.CSharp.BraceCompletion.CurlyBraceCompletionService/<GetTextChangeAfterReturnAsync>d__8")]
public virtual Task`1<Nullable`1<BraceCompletionResult>> GetTextChangeAfterReturnAsync(BraceCompletionContext context, DocumentOptionSet documentOptions, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.CSharp.BraceCompletion.CurlyBraceCompletionService/<CanProvideBraceCompletionAsync>d__9")]
public virtual Task`1<bool> CanProvideBraceCompletionAsync(char brace, int openingPosition, Document document, CancellationToken cancellationToken);
    protected virtual bool IsValidOpeningBraceToken(SyntaxToken token);
    protected virtual bool IsValidClosingBraceToken(SyntaxToken token);
    private static bool ContainsOnlyWhitespace(SourceText text, int openingPosition, int closingBraceEndPoint);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.CSharp.BraceCompletion.CurlyBraceCompletionService/<FormatTrackingSpanAsync>d__13")]
private static Task`1<ValueTuple`2<ImmutableArray`1<TextChange>, int>> FormatTrackingSpanAsync(Document document, int openingPoint, int closingPoint, bool shouldHonorAutoFormattingOnCloseBraceOption, ImmutableArray`1<AbstractFormattingRule> braceFormattingIndentationRules, DocumentOptionSet documentOptions, CancellationToken cancellationToken);
    private static ImmutableArray`1<AbstractFormattingRule> GetBraceIndentationFormattingRules(DocumentOptionSet documentOptions);
    [CompilerGeneratedAttribute]
internal static TextLine <GetTextChangeAfterReturnAsync>g__GetLineBetweenCurlys|8_0(int closingPosition, SourceText text);
    [CompilerGeneratedAttribute]
internal static LinePosition <GetTextChangeAfterReturnAsync>g__GetIndentedLinePosition|8_1(Document document, SourceText sourceText, int lineNumber, CancellationToken cancellationToken);
    [NullableContextAttribute("0")]
[CompilerGeneratedAttribute]
internal static ImmutableArray`1<TextChange> <GetTextChangeAfterReturnAsync>g__GetMergedChanges|8_2(TextChange newLineEdit, ImmutableArray`1<TextChange> formattingChanges, SourceText formattedText);
    [CompilerGeneratedAttribute]
[DebuggerHiddenAttribute]
private Task`1<bool> <>n__0(char brace, int openingPosition, Document document, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.CSharp.BraceCompletion.CurlyBraceCompletionService/<<FormatTrackingSpanAsync>g__GetDocumentWithAnnotatedClosingBraceAsync|13_0>d")]
[CompilerGeneratedAttribute]
internal static Task`1<Document> <FormatTrackingSpanAsync>g__GetDocumentWithAnnotatedClosingBraceAsync|13_0(Document document, int closingBraceEndPoint, CancellationToken cancellationToken);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExportAttribute("C#", "Microsoft.CodeAnalysis.BraceCompletion.IBraceCompletionService")]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.CSharp.BraceCompletion.InterpolatedStringBraceCompletionService : AbstractBraceCompletionService {
    protected char OpeningBrace { get; }
    protected char ClosingBrace { get; }
    protected virtual char get_OpeningBrace();
    protected virtual char get_ClosingBrace();
    public virtual Task`1<bool> AllowOverTypeAsync(BraceCompletionContext context, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.CSharp.BraceCompletion.InterpolatedStringBraceCompletionService/<CanProvideBraceCompletionAsync>d__6")]
public virtual Task`1<bool> CanProvideBraceCompletionAsync(char brace, int openingPosition, Document document, CancellationToken cancellationToken);
    protected virtual bool IsValidOpeningBraceToken(SyntaxToken leftToken);
    protected virtual bool IsValidClosingBraceToken(SyntaxToken rightToken);
    protected virtual Task`1<bool> IsValidOpenBraceTokenAtPositionAsync(SyntaxToken token, int position, Document document, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.CSharp.BraceCompletion.InterpolatedStringBraceCompletionService/<IsPositionInInterpolatedStringContextAsync>d__10")]
public static Task`1<bool> IsPositionInInterpolatedStringContextAsync(Document document, int position, CancellationToken cancellationToken);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExportAttribute("C#", "Microsoft.CodeAnalysis.BraceCompletion.IBraceCompletionService")]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.CSharp.BraceCompletion.InterpolationBraceCompletionService : AbstractBraceCompletionService {
    protected char OpeningBrace { get; }
    protected char ClosingBrace { get; }
    protected virtual char get_OpeningBrace();
    protected virtual char get_ClosingBrace();
    public virtual Task`1<bool> AllowOverTypeAsync(BraceCompletionContext context, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.CSharp.BraceCompletion.InterpolationBraceCompletionService/<CanProvideBraceCompletionAsync>d__6")]
public virtual Task`1<bool> CanProvideBraceCompletionAsync(char brace, int openingPosition, Document document, CancellationToken cancellationToken);
    protected virtual Task`1<bool> IsValidOpenBraceTokenAtPositionAsync(SyntaxToken token, int position, Document document, CancellationToken cancellationToken);
    protected virtual bool IsValidOpeningBraceToken(SyntaxToken token);
    protected virtual bool IsValidClosingBraceToken(SyntaxToken token);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.CSharp.BraceCompletion.InterpolationBraceCompletionService/<IsPositionInInterpolationContextAsync>d__10")]
public static Task`1<bool> IsPositionInInterpolationContextAsync(Document document, int position, CancellationToken cancellationToken);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExportAttribute("C#", "Microsoft.CodeAnalysis.BraceCompletion.IBraceCompletionService")]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.CSharp.BraceCompletion.LessAndGreaterThanBraceCompletionService : AbstractBraceCompletionService {
    protected char OpeningBrace { get; }
    protected char ClosingBrace { get; }
    protected virtual char get_OpeningBrace();
    protected virtual char get_ClosingBrace();
    public virtual Task`1<bool> AllowOverTypeAsync(BraceCompletionContext context, CancellationToken cancellationToken);
    protected virtual bool IsValidOpeningBraceToken(SyntaxToken token);
    protected virtual bool IsValidClosingBraceToken(SyntaxToken token);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.CSharp.BraceCompletion.LessAndGreaterThanBraceCompletionService/<IsValidOpenBraceTokenAtPositionAsync>d__8")]
protected virtual Task`1<bool> IsValidOpenBraceTokenAtPositionAsync(SyntaxToken token, int position, Document document, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.CSharp.BraceCompletion.LessAndGreaterThanBraceCompletionService/<PossibleTypeArgumentAsync>d__9")]
private static Task`1<bool> PossibleTypeArgumentAsync(Document document, SyntaxToken token, CancellationToken cancellationToken);
    private static bool IsGenericTypeOrMethod(ISymbol symbol);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExportAttribute("C#", "Microsoft.CodeAnalysis.BraceCompletion.IBraceCompletionService")]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.CSharp.BraceCompletion.ParenthesisBraceCompletionService : AbstractBraceCompletionService {
    protected char OpeningBrace { get; }
    protected char ClosingBrace { get; }
    protected virtual char get_OpeningBrace();
    protected virtual char get_ClosingBrace();
    public virtual Task`1<bool> AllowOverTypeAsync(BraceCompletionContext context, CancellationToken cancellationToken);
    protected virtual bool IsValidOpeningBraceToken(SyntaxToken token);
    protected virtual bool IsValidClosingBraceToken(SyntaxToken token);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.CSharp.BraceCompletion.ParenthesisBraceCompletionService/<IsValidOpenBraceTokenAtPositionAsync>d__8")]
protected virtual Task`1<bool> IsValidOpenBraceTokenAtPositionAsync(SyntaxToken token, int position, Document document, CancellationToken cancellationToken);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExportAttribute("C#", "Microsoft.CodeAnalysis.BraceCompletion.IBraceCompletionService")]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.CSharp.BraceCompletion.StringLiteralBraceCompletionService : AbstractBraceCompletionService {
    protected char OpeningBrace { get; }
    protected char ClosingBrace { get; }
    protected virtual char get_OpeningBrace();
    protected virtual char get_ClosingBrace();
    public virtual Task`1<bool> AllowOverTypeAsync(BraceCompletionContext context, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.CSharp.BraceCompletion.StringLiteralBraceCompletionService/<CanProvideBraceCompletionAsync>d__6")]
public virtual Task`1<bool> CanProvideBraceCompletionAsync(char brace, int openingPosition, Document document, CancellationToken cancellationToken);
    protected virtual bool IsValidOpeningBraceToken(SyntaxToken token);
    protected virtual bool IsValidClosingBraceToken(SyntaxToken token);
    protected virtual Task`1<bool> IsValidOpenBraceTokenAtPositionAsync(SyntaxToken token, int position, Document document, CancellationToken cancellationToken);
    [CompilerGeneratedAttribute]
[DebuggerHiddenAttribute]
private Task`1<bool> <>n__0(char brace, int openingPosition, Document document, CancellationToken cancellationToken);
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[ExportLanguageServiceAttribute("Microsoft.CodeAnalysis.ChangeNamespace.IChangeNamespaceService", "C#", "Default")]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.CSharp.ChangeNamespace.CSharpChangeNamespaceService : AbstractChangeNamespaceService`3<NamespaceDeclarationSyntax, CompilationUnitSyntax, MemberDeclarationSyntax> {
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.CSharp.ChangeNamespace.CSharpChangeNamespaceService/<GetValidContainersFromAllLinkedDocumentsAsync>d__1")]
protected virtual Task`1<ImmutableArray`1<ValueTuple`2<DocumentId, SyntaxNode>>> GetValidContainersFromAllLinkedDocumentsAsync(Document document, SyntaxNode container, CancellationToken cancellationToken);
    protected virtual string GetDeclaredNamespace(SyntaxNode container);
    protected virtual SyntaxList`1<MemberDeclarationSyntax> GetMemberDeclarationsInContainer(SyntaxNode container);
    public virtual bool TryGetReplacementReferenceSyntax(SyntaxNode reference, ImmutableArray`1<string> newNamespaceParts, ISyntaxFactsService syntaxFacts, SyntaxNode& oldNode, SyntaxNode& newNode);
    [NullableContextAttribute("2")]
private static bool TryGetGlobalQualifiedName(ImmutableArray`1<string> newNamespaceParts, SimpleNameSyntax nameNode, string aliasQualifier, SyntaxNode& newNode);
    protected virtual CompilationUnitSyntax ChangeNamespaceDeclaration(CompilationUnitSyntax root, ImmutableArray`1<string> declaredNamespaceParts, ImmutableArray`1<string> targetNamespaceParts);
    private static CompilationUnitSyntax MoveMembersFromNamespaceToGlobal(CompilationUnitSyntax root, NamespaceDeclarationSyntax namespaceDecl);
    private static CompilationUnitSyntax MoveMembersFromGlobalToNamespace(CompilationUnitSyntax compilationUnit, ImmutableArray`1<string> targetNamespaceParts);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.CSharp.ChangeNamespace.CSharpChangeNamespaceService/<TryGetApplicableContainerFromSpanAsync>d__9")]
protected virtual Task`1<SyntaxNode> TryGetApplicableContainerFromSpanAsync(Document document, TextSpan span, CancellationToken cancellationToken);
    [NullableContextAttribute("2")]
private static string GetAliasQualifier(SyntaxNode name);
    private static NameSyntax CreateNamespaceAsQualifiedName(ImmutableArray`1<string> namespaceParts, string aliasQualifier, int index);
    private static ExpressionSyntax CreateNamespaceAsMemberAccess(ImmutableArray`1<string> namespaceParts, string aliasQualifier, int index);
    [NullableContextAttribute("0")]
private static ValueTuple`2<ImmutableArray`1<SyntaxTrivia>, ImmutableArray`1<SyntaxTrivia>> GetOpeningAndClosingTriviaOfNamespaceDeclaration(NamespaceDeclarationSyntax namespaceDeclaration);
    [CompilerGeneratedAttribute]
internal static bool <TryGetApplicableContainerFromSpanAsync>g__ContainsNamespaceDeclaration|9_0(SyntaxNode node);
}
internal class Microsoft.CodeAnalysis.CSharp.ChangeSignature.ChangeSignatureFormattingRule : BaseFormattingRule {
    private static ImmutableArray`1<SyntaxKind> s_allowableKinds;
    private static ChangeSignatureFormattingRule();
    public virtual void AddIndentBlockOperations(List`1<IndentBlockOperation> list, SyntaxNode node, NextIndentBlockOperationAction& modreq(System.Runtime.InteropServices.InAttribute) nextOperation);
    private static void AddChangeSignatureIndentOperation(List`1<IndentBlockOperation> list, SyntaxNode node);
    public virtual AdjustNewLinesOperation GetAdjustNewLinesOperation(SyntaxToken& modreq(System.Runtime.InteropServices.InAttribute) previousToken, SyntaxToken& modreq(System.Runtime.InteropServices.InAttribute) currentToken, NextGetAdjustNewLinesOperation& modreq(System.Runtime.InteropServices.InAttribute) nextOperation);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExportLanguageServiceAttribute("Microsoft.CodeAnalysis.ChangeSignature.AbstractChangeSignatureService", "C#", "Default")]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.CSharp.ChangeSignature.CSharpChangeSignatureService : AbstractChangeSignatureService {
    [NullableAttribute("0")]
private static ImmutableArray`1<SyntaxKind> _declarationKinds;
    [NullableAttribute("0")]
private static ImmutableArray`1<SyntaxKind> _declarationAndInvocableKinds;
    [NullableAttribute("0")]
private static ImmutableArray`1<SyntaxKind> _updatableAncestorKinds;
    [NullableAttribute("0")]
private static ImmutableArray`1<SyntaxKind> _updatableNodeKinds;
    protected SyntaxGenerator Generator { get; }
    protected ISyntaxFacts SyntaxFacts { get; }
    private static CSharpChangeSignatureService();
    protected virtual SyntaxGenerator get_Generator();
    protected virtual ISyntaxFacts get_SyntaxFacts();
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.CSharp.ChangeSignature.CSharpChangeSignatureService/<GetInvocationSymbolAsync>d__9")]
public virtual Task`1<ValueTuple`2<ISymbol, int>> GetInvocationSymbolAsync(Document document, int position, bool restrictToDeclarations, CancellationToken cancellationToken);
    private static int TryGetSelectedIndexFromDeclaration(int position, SyntaxNode matchingNode);
    private static SyntaxNode GetMatchingNode(SyntaxNode node, bool restrictToDeclarations);
    private static bool InSymbolHeader(SyntaxNode matchingNode, int position);
    public virtual SyntaxNode FindNodeToUpdate(Document document, SyntaxNode node);
    private static SyntaxNode GetNodeContainingTargetNode(SyntaxNode matchingNode);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.CSharp.ChangeSignature.CSharpChangeSignatureService/<ChangeSignatureAsync>d__15")]
public virtual Task`1<SyntaxNode> ChangeSignatureAsync(Document document, ISymbol declarationSymbol, SyntaxNode potentiallyUpdatedNode, SyntaxNode originalNode, SignatureChange signaturePermutation, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.CSharp.ChangeSignature.CSharpChangeSignatureService/<UpdateArgumentListAsync>d__16`1")]
private Task`1<T> UpdateArgumentListAsync(ISymbol declarationSymbol, SignatureChange signaturePermutation, T argumentList, bool isReducedExtensionMethod, bool isParamsArrayExpanded, Document document, int position, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.CSharp.ChangeSignature.CSharpChangeSignatureService/<UpdateAttributeArgumentListAsync>d__17")]
private Task`1<AttributeArgumentListSyntax> UpdateAttributeArgumentListAsync(ISymbol declarationSymbol, SignatureChange signaturePermutation, AttributeArgumentListSyntax argumentList, bool isReducedExtensionMethod, bool isParamsArrayExpanded, Document document, int position, CancellationToken cancellationToken);
    private static bool IsParamsArrayExpanded(SemanticModel semanticModel, SyntaxNode node, SymbolInfo symbolInfo, CancellationToken cancellationToken);
    private static ParameterSyntax CreateNewParameterSyntax(AddedParameter addedParameter);
    private static ParameterSyntax CreateNewParameterSyntax(AddedParameter addedParameter, bool skipParameterType);
    private static CrefParameterSyntax CreateNewCrefParameterSyntax(AddedParameter addedParameter);
    private SeparatedSyntaxList`1<T> UpdateDeclaration(SeparatedSyntaxList`1<T> list, SignatureChange updatedSignature, Func`2<AddedParameter, T> createNewParameterMethod);
    protected virtual T TransferLeadingWhitespaceTrivia(T newArgument, SyntaxNode oldArgument);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.CSharp.ChangeSignature.CSharpChangeSignatureService/<AddNewArgumentsToListAsync>d__24")]
private Task`1<SeparatedSyntaxList`1<SyntaxNode>> AddNewArgumentsToListAsync(ISymbol declarationSymbol, SeparatedSyntaxList`1<SyntaxNode> newArguments, SeparatedSyntaxList`1<SyntaxNode> originalArguments, SignatureChange signaturePermutation, bool isReducedExtensionMethod, bool isParamsArrayExpanded, bool generateAttributeArguments, Document document, int position, CancellationToken cancellationToken);
    private SeparatedSyntaxList`1<AttributeArgumentSyntax> PermuteAttributeArgumentList(ISymbol declarationSymbol, SeparatedSyntaxList`1<AttributeArgumentSyntax> arguments, SignatureChange updatedSignature);
    private SeparatedSyntaxList`1<ArgumentSyntax> PermuteArgumentList(ISymbol declarationSymbol, SeparatedSyntaxList`1<ArgumentSyntax> arguments, SignatureChange updatedSignature, bool isReducedExtensionMethod);
    private ImmutableArray`1<T> TransferLeadingWhitespaceTrivia(IEnumerable`1<T> newArguments, SeparatedSyntaxList`1<U> oldArguments);
    private ImmutableArray`1<SyntaxTrivia> UpdateParamTagsInLeadingTrivia(Document document, CSharpSyntaxNode node, ISymbol declarationSymbol, SignatureChange updatedSignature);
    private static ImmutableArray`1<SyntaxNode> VerifyAndPermuteParamNodes(IEnumerable`1<XmlElementSyntax> paramNodes, ISymbol declarationSymbol, SignatureChange updatedSignature);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.CSharp.ChangeSignature.CSharpChangeSignatureService/<DetermineCascadedSymbolsFromDelegateInvokeAsync>d__30")]
public virtual Task`1<ImmutableArray`1<ISymbol>> DetermineCascadedSymbolsFromDelegateInvokeAsync(IMethodSymbol symbol, Document document, CancellationToken cancellationToken);
    protected virtual IEnumerable`1<AbstractFormattingRule> GetFormattingRules(Document document);
    protected virtual SyntaxNode AddNameToArgument(SyntaxNode newArgument, string name);
    protected virtual SyntaxNode CreateExplicitParamsArrayFromIndividualArguments(SeparatedSyntaxList`1<SyntaxNode> newArguments, int indexInExistingList, IParameterSymbol parameterSymbol);
    protected virtual bool SupportsOptionalAndParamsArrayParametersSimultaneously();
    protected virtual SyntaxToken CommaTokenWithElasticSpace();
}
internal class Microsoft.CodeAnalysis.CSharp.ChangeSignature.UnifiedArgumentSyntax : ValueType {
    private SyntaxNode _argument;
    public SyntaxNode NameColon { get; }
    public SyntaxNode Expression { get; }
    public bool IsDefault { get; }
    public bool IsNamed { get; }
    private UnifiedArgumentSyntax(SyntaxNode argument);
    public static IUnifiedArgumentSyntax Create(ArgumentSyntax argument);
    public static IUnifiedArgumentSyntax Create(AttributeArgumentSyntax argument);
    public SyntaxNode get_NameColon();
    public IUnifiedArgumentSyntax WithNameColon(SyntaxNode nameColonSyntax);
    public sealed virtual string GetName();
    public sealed virtual IUnifiedArgumentSyntax WithName(string name);
    public sealed virtual IUnifiedArgumentSyntax WithAdditionalAnnotations(SyntaxAnnotation annotation);
    public SyntaxNode get_Expression();
    public sealed virtual bool get_IsDefault();
    public sealed virtual bool get_IsNamed();
    public static SyntaxNode op_Explicit(UnifiedArgumentSyntax unified);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExportLanguageServiceAttribute("Microsoft.CodeAnalysis.CodeCleanup.ICodeCleanupService", "C#", "Default")]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.CSharp.CodeCleanup.CSharpCodeCleanupService : AbstractCodeCleanupService {
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private static ImmutableArray`1<DiagnosticSet> s_diagnosticSets;
    protected string OrganizeImportsDescription { get; }
    [ImportingConstructorAttribute]
[ObsoleteAttribute("This exported object must be obtained through the MEF export provider.", "True")]
public CSharpCodeCleanupService(ICodeFixService codeFixService);
    private static CSharpCodeCleanupService();
    protected virtual string get_OrganizeImportsDescription();
    protected virtual ImmutableArray`1<DiagnosticSet> GetDiagnosticSets();
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[ExportCodeFixProviderAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.CSharp.CodeFixes.AddExplicitCast.CSharpAddExplicitCastCodeFixProvider : AbstractAddExplicitCastCodeFixProvider`1<ExpressionSyntax> {
    private static string CS0266;
    private static string CS1503;
    private ArgumentFixer _argumentFixer;
    private AttributeArgumentFixer _attributeArgumentFixer;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ImmutableArray`1<string> FixableDiagnosticIds { get; }
    public virtual ImmutableArray`1<string> get_FixableDiagnosticIds();
    protected virtual SyntaxNode ApplyFix(SyntaxNode currentRoot, ExpressionSyntax targetNode, ITypeSymbol conversionType);
    protected virtual bool TryGetTargetTypeInfo(Document document, SemanticModel semanticModel, SyntaxNode root, string diagnosticId, ExpressionSyntax spanNode, CancellationToken cancellationToken, ImmutableArray`1& potentialConversionTypes);
    protected virtual CommonConversion ClassifyConversion(SemanticModel semanticModel, ExpressionSyntax expression, ITypeSymbol type);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExportCodeFixProviderAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.CSharp.CodeFixes.ConditionalExpressionInStringInterpolation.CSharpAddParenthesesAroundConditionalExpressionInInterpolatedStringCodeFixProvider : CodeFixProvider {
    private static string CS8361;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ImmutableArray`1<string> FixableDiagnosticIds { get; }
    [NullableContextAttribute("2")]
public virtual FixAllProvider GetFixAllProvider();
    public virtual ImmutableArray`1<string> get_FixableDiagnosticIds();
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.CSharp.CodeFixes.ConditionalExpressionInStringInterpolation.CSharpAddParenthesesAroundConditionalExpressionInInterpolatedStringCodeFixProvider/<RegisterCodeFixesAsync>d__5")]
public sealed virtual Task RegisterCodeFixesAsync(CodeFixContext context);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.CSharp.CodeFixes.ConditionalExpressionInStringInterpolation.CSharpAddParenthesesAroundConditionalExpressionInInterpolatedStringCodeFixProvider/<GetChangedDocumentAsync>d__6")]
private static Task`1<Document> GetChangedDocumentAsync(Document document, int conditionalExpressionSyntaxStartPosition, CancellationToken cancellationToken);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExportCodeFixProviderAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.CSharp.CodeFixes.ConvertToAsync.CSharpConvertToAsyncMethodCodeFixProvider : AbstractConvertToAsyncCodeFixProvider {
    private static string CS4008;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ImmutableArray`1<string> FixableDiagnosticIds { get; }
    public virtual ImmutableArray`1<string> get_FixableDiagnosticIds();
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.CSharp.CodeFixes.ConvertToAsync.CSharpConvertToAsyncMethodCodeFixProvider/<GetDescriptionAsync>d__4")]
protected virtual Task`1<string> GetDescriptionAsync(Diagnostic diagnostic, SyntaxNode node, SemanticModel semanticModel, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.CSharp.CodeFixes.ConvertToAsync.CSharpConvertToAsyncMethodCodeFixProvider/<GetRootInOtherSyntaxTreeAsync>d__5")]
protected virtual Task`1<Tuple`2<SyntaxTree, SyntaxNode>> GetRootInOtherSyntaxTreeAsync(SyntaxNode node, SemanticModel semanticModel, Diagnostic diagnostic, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.CSharp.CodeFixes.ConvertToAsync.CSharpConvertToAsyncMethodCodeFixProvider/<GetMethodDeclarationAsync>d__6")]
private static Task`1<MethodDeclarationSyntax> GetMethodDeclarationAsync(SyntaxNode node, SemanticModel semanticModel, CancellationToken cancellationToken);
    private static MethodDeclarationSyntax ConvertToAsyncFunction(MethodDeclarationSyntax methodDeclaration);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExportCodeFixProviderAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.CSharp.CodeFixes.DeclareAsNullable.CSharpDeclareAsNullableCodeFixProvider : SyntaxEditorBasedCodeFixProvider {
    private static string AssigningNullLiteralLocallyEquivalenceKey;
    private static string AssigningNullLiteralRemotelyEquivalenceKey;
    private static string ConditionalOperatorEquivalenceKey;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ImmutableArray`1<string> FixableDiagnosticIds { get; }
    internal CodeFixCategory CodeFixCategory { get; }
    public sealed virtual ImmutableArray`1<string> get_FixableDiagnosticIds();
    internal sealed virtual CodeFixCategory get_CodeFixCategory();
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.CSharp.CodeFixes.DeclareAsNullable.CSharpDeclareAsNullableCodeFixProvider/<RegisterCodeFixesAsync>d__8")]
public virtual Task RegisterCodeFixesAsync(CodeFixContext context);
    private static string GetEquivalenceKey(SyntaxNode node, SemanticModel model);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.CSharp.CodeFixes.DeclareAsNullable.CSharpDeclareAsNullableCodeFixProvider/<FixAllAsync>d__10")]
protected virtual Task FixAllAsync(Document document, ImmutableArray`1<Diagnostic> diagnostics, SyntaxEditor editor, CancellationToken cancellationToken);
    protected virtual bool IncludeDiagnosticDuringFixAll(Diagnostic diagnostic, Document document, SemanticModel model, string equivalenceKey, CancellationToken cancellationToken);
    private static void MakeDeclarationNullable(SyntaxEditor editor, SemanticModel model, SyntaxNode node, HashSet`1<TypeSyntax> alreadyHandled);
    private static TypeSyntax TryGetDeclarationTypeToFix(SemanticModel model, SyntaxNode node);
    private static bool IsExpressionSupported(SyntaxNode node);
    [CompilerGeneratedAttribute]
internal static bool <GetEquivalenceKey>g__IsRemoteApiUsage|9_0(SyntaxNode node, SemanticModel model);
    [CompilerGeneratedAttribute]
internal static TypeSyntax <TryGetDeclarationTypeToFix>g__TryGetReturnType|13_0(TypeSyntax returnType, SyntaxTokenList modifiers, bool onYield);
    [CompilerGeneratedAttribute]
internal static TypeSyntax <TryGetDeclarationTypeToFix>g__TryGetSingleTypeArgument|13_1(TypeSyntax type);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
internal static TypeSyntax <TryGetDeclarationTypeToFix>g__TryGetParameterTypeSyntax|13_2(IParameterSymbol parameterSymbol);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExportCodeFixProviderAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.CSharp.CodeFixes.FixReturnType.CSharpFixReturnTypeCodeFixProvider : SyntaxEditorBasedCodeFixProvider {
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ImmutableArray`1<string> FixableDiagnosticIds { get; }
    internal CodeFixCategory CodeFixCategory { get; }
    public virtual ImmutableArray`1<string> get_FixableDiagnosticIds();
    internal virtual CodeFixCategory get_CodeFixCategory();
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.CSharp.CodeFixes.FixReturnType.CSharpFixReturnTypeCodeFixProvider/<RegisterCodeFixesAsync>d__5")]
public virtual Task RegisterCodeFixesAsync(CodeFixContext context);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.CSharp.CodeFixes.FixReturnType.CSharpFixReturnTypeCodeFixProvider/<TryGetOldAndNewReturnTypeAsync>d__6")]
private static Task`1<ValueTuple`2<TypeSyntax, TypeSyntax>> TryGetOldAndNewReturnTypeAsync(Document document, ImmutableArray`1<Diagnostic> diagnostics, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.CSharp.CodeFixes.FixReturnType.CSharpFixReturnTypeCodeFixProvider/<FixAllAsync>d__7")]
protected virtual Task FixAllAsync(Document document, ImmutableArray`1<Diagnostic> diagnostics, SyntaxEditor editor, CancellationToken cancellationToken);
    private static ValueTuple`2<TypeSyntax, bool> TryGetDeclarationTypeToFix(SyntaxNode node);
    [CompilerGeneratedAttribute]
internal static bool <RegisterCodeFixesAsync>g__IsVoid|5_1(TypeSyntax typeSyntax);
    [CompilerGeneratedAttribute]
internal static ValueTuple`2<TypeSyntax, bool> <TryGetDeclarationTypeToFix>g__TryGetReturnTypeToFix|8_2(SyntaxNode containingMember);
    [CompilerGeneratedAttribute]
internal static bool <TryGetDeclarationTypeToFix>g__IsAsync|8_3(SyntaxTokenList modifiers);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExportCodeFixProviderAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
[SharedAttribute]
[ExtensionOrderAttribute]
internal class Microsoft.CodeAnalysis.CSharp.CodeFixes.FullyQualify.CSharpFullyQualifyCodeFixProvider : AbstractFullyQualifyCodeFixProvider {
    private static string CS0103;
    private static string CS0104;
    private static string CS0246;
    private static string CS0305;
    private static string CS0308;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ImmutableArray`1<string> FixableDiagnosticIds { get; }
    protected bool IgnoreCase { get; }
    public virtual ImmutableArray`1<string> get_FixableDiagnosticIds();
    protected virtual bool get_IgnoreCase();
    protected virtual bool CanFullyQualify(Diagnostic diagnostic, SyntaxNode& node);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.CSharp.CodeFixes.FullyQualify.CSharpFullyQualifyCodeFixProvider/<ReplaceNodeAsync>d__11")]
protected virtual Task`1<SyntaxNode> ReplaceNodeAsync(SyntaxNode node, string containerName, bool resultingSymbolIsType, CancellationToken cancellationToken);
}
[ExportCodeFixProviderAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
[SharedAttribute]
[ExtensionOrderAttribute]
internal class Microsoft.CodeAnalysis.CSharp.CodeFixes.GenerateDeconstructMethod.GenerateDeconstructMethodCodeFixProvider : CodeFixProvider {
    private static string CS8129;
    public ImmutableArray`1<string> FixableDiagnosticIds { get; }
    public sealed virtual ImmutableArray`1<string> get_FixableDiagnosticIds();
    public virtual FixAllProvider GetFixAllProvider();
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.CSharp.CodeFixes.GenerateDeconstructMethod.GenerateDeconstructMethodCodeFixProvider/<RegisterCodeFixesAsync>d__5")]
public sealed virtual Task RegisterCodeFixesAsync(CodeFixContext context);
}
[ExportCodeFixProviderAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
[SharedAttribute]
[ExtensionOrderAttribute]
internal class Microsoft.CodeAnalysis.CSharp.CodeFixes.GenerateEnumMember.GenerateEnumMemberCodeFixProvider : AbstractGenerateMemberCodeFixProvider {
    private static string CS0117;
    public ImmutableArray`1<string> FixableDiagnosticIds { get; }
    public virtual ImmutableArray`1<string> get_FixableDiagnosticIds();
    protected virtual Task`1<ImmutableArray`1<CodeAction>> GetCodeActionsAsync(Document document, SyntaxNode node, CancellationToken cancellationToken);
    protected virtual bool IsCandidate(SyntaxNode node, SyntaxToken token, Diagnostic diagnostic);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExportCodeFixProviderAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
[SharedAttribute]
[ExtensionOrderAttribute]
internal class Microsoft.CodeAnalysis.CSharp.CodeFixes.GenerateMethod.GenerateConversionCodeFixProvider : AbstractGenerateMemberCodeFixProvider {
    private static string CS0029;
    private static string CS0030;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ImmutableArray`1<string> FixableDiagnosticIds { get; }
    public virtual ImmutableArray`1<string> get_FixableDiagnosticIds();
    protected virtual bool IsCandidate(SyntaxNode node, SyntaxToken token, Diagnostic diagnostic);
    protected virtual SyntaxNode GetTargetNode(SyntaxNode node);
    protected virtual Task`1<ImmutableArray`1<CodeAction>> GetCodeActionsAsync(Document document, SyntaxNode node, CancellationToken cancellationToken);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExportCodeFixProviderAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
[SharedAttribute]
[ExtensionOrderAttribute]
internal class Microsoft.CodeAnalysis.CSharp.CodeFixes.GenerateMethod.GenerateMethodCodeFixProvider : AbstractGenerateMemberCodeFixProvider {
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private ImmutableArray`1<string> <FixableDiagnosticIds>k__BackingField;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ImmutableArray`1<string> FixableDiagnosticIds { get; }
    [CompilerGeneratedAttribute]
public virtual ImmutableArray`1<string> get_FixableDiagnosticIds();
    protected virtual bool IsCandidate(SyntaxNode node, SyntaxToken token, Diagnostic diagnostic);
    protected virtual SyntaxNode GetTargetNode(SyntaxNode node);
    protected virtual Task`1<ImmutableArray`1<CodeAction>> GetCodeActionsAsync(Document document, SyntaxNode node, CancellationToken cancellationToken);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal static class Microsoft.CodeAnalysis.CSharp.CodeFixes.GenerateMethod.GenerateMethodDiagnosticIds : object {
    private static string CS0103;
    private static string CS0117;
    private static string CS0118;
    private static string CS0122;
    private static string CS0305;
    private static string CS0308;
    private static string CS0539;
    private static string CS1061;
    private static string CS1501;
    private static string CS1503;
    private static string CS1660;
    private static string CS1739;
    private static string CS7036;
    private static string CS1955;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static ImmutableArray`1<string> FixableDiagnosticIds;
    private static GenerateMethodDiagnosticIds();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExportCodeFixProviderAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
[SharedAttribute]
[ExtensionOrderAttribute]
internal class Microsoft.CodeAnalysis.CSharp.CodeFixes.GenerateType.GenerateTypeCodeFixProvider : AbstractGenerateMemberCodeFixProvider {
    private static string CS0103;
    private static string CS0117;
    private static string CS0234;
    private static string CS0246;
    private static string CS0305;
    private static string CS0308;
    private static string CS0426;
    private static string CS0616;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ImmutableArray`1<string> FixableDiagnosticIds { get; }
    public virtual ImmutableArray`1<string> get_FixableDiagnosticIds();
    protected virtual bool IsCandidate(SyntaxNode node, SyntaxToken token, Diagnostic diagnostic);
    protected virtual SyntaxNode GetTargetNode(SyntaxNode node);
    protected virtual Task`1<ImmutableArray`1<CodeAction>> GetCodeActionsAsync(Document document, SyntaxNode node, CancellationToken cancellationToken);
}
[ExportCodeFixProviderAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.CSharp.CodeFixes.HideBase.HideBaseCodeFixProvider : CodeFixProvider {
    internal static string CS0108;
    public ImmutableArray`1<string> FixableDiagnosticIds { get; }
    public virtual ImmutableArray`1<string> get_FixableDiagnosticIds();
    public virtual FixAllProvider GetFixAllProvider();
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.CSharp.CodeFixes.HideBase.HideBaseCodeFixProvider/<RegisterCodeFixesAsync>d__6")]
public sealed virtual Task RegisterCodeFixesAsync(CodeFixContext context);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExportCodeFixProviderAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.CSharp.CodeFixes.Iterator.CSharpAddYieldCodeFixProvider : AbstractIteratorCodeFixProvider {
    private static string CS0029;
    private static string CS0266;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ImmutableArray`1<string> FixableDiagnosticIds { get; }
    public virtual ImmutableArray`1<string> get_FixableDiagnosticIds();
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.CSharp.CodeFixes.Iterator.CSharpAddYieldCodeFixProvider/<GetCodeFixAsync>d__5")]
protected virtual Task`1<CodeAction> GetCodeFixAsync(SyntaxNode root, SyntaxNode node, Document document, Diagnostic diagnostics, CancellationToken cancellationToken);
    [NullableContextAttribute("2")]
private static bool TryGetExpressionType(SemanticModel model, ExpressionSyntax expression, ITypeSymbol& returnExpressionType);
    private static bool TryGetMethodReturnType(SyntaxNode node, SemanticModel model, CancellationToken cancellationToken, ITypeSymbol& methodReturnType);
    private bool IsCorrectTypeForYieldReturn(ITypeSymbol typeArgument, ITypeSymbol returnExpressionType, ITypeSymbol methodReturnType, SemanticModel model);
    private bool CanConvertTypes(ITypeSymbol typeArgument, ITypeSymbol returnExpressionType, SemanticModel model);
    private static bool IsCorrectTypeForYieldReturn(ITypeSymbol methodReturnType, SemanticModel model);
    protected virtual bool TryGetNode(SyntaxNode root, TextSpan span, SyntaxNode& node);
}
[ExportCodeFixProviderAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.CSharp.CodeFixes.Iterator.CSharpChangeToIEnumerableCodeFixProvider : AbstractIteratorCodeFixProvider {
    private static string CS1624;
    public ImmutableArray`1<string> FixableDiagnosticIds { get; }
    public virtual ImmutableArray`1<string> get_FixableDiagnosticIds();
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.CSharp.CodeFixes.Iterator.CSharpChangeToIEnumerableCodeFixProvider/<GetCodeFixAsync>d__4")]
protected virtual Task`1<CodeAction> GetCodeFixAsync(SyntaxNode root, SyntaxNode node, Document document, Diagnostic diagnostics, CancellationToken cancellationToken);
    private static bool TryGetIEnumerableSymbols(SemanticModel model, INamedTypeSymbol& ienumerableSymbol, INamedTypeSymbol& ienumerableGenericSymbol);
}
[ExportCodeFixProviderAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.CSharp.CodeFixes.MakeStatementAsynchronous.CSharpMakeStatementAsynchronousCodeFixProvider : SyntaxEditorBasedCodeFixProvider {
    public ImmutableArray`1<string> FixableDiagnosticIds { get; }
    internal CodeFixCategory CodeFixCategory { get; }
    public sealed virtual ImmutableArray`1<string> get_FixableDiagnosticIds();
    internal sealed virtual CodeFixCategory get_CodeFixCategory();
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.CSharp.CodeFixes.MakeStatementAsynchronous.CSharpMakeStatementAsynchronousCodeFixProvider/<RegisterCodeFixesAsync>d__5")]
public virtual Task RegisterCodeFixesAsync(CodeFixContext context);
    protected virtual Task FixAllAsync(Document document, ImmutableArray`1<Diagnostic> diagnostics, SyntaxEditor editor, CancellationToken cancellationToken);
    private static void MakeStatementAsynchronous(SyntaxEditor editor, SyntaxNode statementToFix);
    private static SyntaxNode TryGetStatementToFix(SyntaxNode node);
}
[ExportCodeFixProviderAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.CSharp.CodeFixes.MatchFolderAndNamespace.CSharpChangeNamespaceToMatchFolderCodeFixProvider : AbstractChangeNamespaceToMatchFolderCodeFixProvider {
}
[ExportCodeFixProviderAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.CSharp.CodeFixes.RemoveInKeyword.RemoveInKeywordCodeFixProvider : CodeFixProvider {
    private static string CS1615;
    public ImmutableArray`1<string> FixableDiagnosticIds { get; }
    public virtual FixAllProvider GetFixAllProvider();
    public virtual ImmutableArray`1<string> get_FixableDiagnosticIds();
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.CSharp.CodeFixes.RemoveInKeyword.RemoveInKeywordCodeFixProvider/<RegisterCodeFixesAsync>d__5")]
public virtual Task RegisterCodeFixesAsync(CodeFixContext context);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.CSharp.CodeFixes.RemoveInKeyword.RemoveInKeywordCodeFixProvider/<FixAsync>d__6")]
private static Task`1<Document> FixAsync(Document document, ArgumentSyntax argumentSyntax, CancellationToken cancellationToken);
}
[ExportCodeFixProviderAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.CSharp.CodeFixes.RemoveNewModifier.RemoveNewModifierCodeFixProvider : CodeFixProvider {
    private static string CS0109;
    public ImmutableArray`1<string> FixableDiagnosticIds { get; }
    public virtual FixAllProvider GetFixAllProvider();
    public virtual ImmutableArray`1<string> get_FixableDiagnosticIds();
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.CSharp.CodeFixes.RemoveNewModifier.RemoveNewModifierCodeFixProvider/<RegisterCodeFixesAsync>d__5")]
public virtual Task RegisterCodeFixesAsync(CodeFixContext context);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.CSharp.CodeFixes.RemoveNewModifier.RemoveNewModifierCodeFixProvider/<FixAsync>d__6")]
private static Task`1<Document> FixAsync(Document document, SyntaxGenerator generator, MemberDeclarationSyntax memberDeclaration, CancellationToken cancellationToken);
}
[ExportConfigurationFixProviderAttribute("Suppression", "Mono.Cecil.CustomAttributeArgument[]")]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.CSharp.CodeFixes.Suppression.CSharpSuppressionCodeFixProvider : AbstractSuppressionCodeFixProvider {
    protected string DefaultFileExtension { get; }
    protected string SingleLineCommentStart { get; }
    protected virtual SyntaxTriviaList CreatePragmaRestoreDirectiveTrivia(Diagnostic diagnostic, Func`2<SyntaxNode, SyntaxNode> formatNode, bool needsLeadingEndOfLine, bool needsTrailingEndOfLine);
    protected virtual SyntaxTriviaList CreatePragmaDisableDirectiveTrivia(Diagnostic diagnostic, Func`2<SyntaxNode, SyntaxNode> formatNode, bool needsLeadingEndOfLine, bool needsTrailingEndOfLine);
    private static SyntaxTriviaList CreatePragmaDirectiveTrivia(SyntaxToken disableOrRestoreKeyword, Diagnostic diagnostic, Func`2<SyntaxNode, SyntaxNode> formatNode, bool needsLeadingEndOfLine, bool needsTrailingEndOfLine);
    protected virtual string get_DefaultFileExtension();
    protected virtual string get_SingleLineCommentStart();
    protected virtual bool IsAttributeListWithAssemblyAttributes(SyntaxNode node);
    protected virtual bool IsEndOfLine(SyntaxTrivia trivia);
    protected virtual bool IsEndOfFileToken(SyntaxToken token);
    protected virtual SyntaxNode AddGlobalSuppressMessageAttribute(SyntaxNode newRoot, ISymbol targetSymbol, INamedTypeSymbol suppressMessageAttribute, Diagnostic diagnostic, Workspace workspace, Compilation compilation, IAddImportsService addImportsService, CancellationToken cancellationToken);
    protected virtual SyntaxNode AddLocalSuppressMessageAttribute(SyntaxNode targetNode, ISymbol targetSymbol, INamedTypeSymbol suppressMessageAttribute, Diagnostic diagnostic);
    private static AttributeListSyntax CreateAttributeList(ISymbol targetSymbol, NameSyntax attributeName, Diagnostic diagnostic, bool isAssemblyAttribute, SyntaxTriviaList leadingTrivia, bool needsLeadingEndOfLine);
    private static AttributeArgumentListSyntax CreateAttributeArguments(ISymbol targetSymbol, Diagnostic diagnostic, bool isAssemblyAttribute);
    protected virtual bool IsSingleAttributeInAttributeList(SyntaxNode attribute);
    protected virtual bool IsAnyPragmaDirectiveForId(SyntaxTrivia trivia, string id, Boolean& enableDirective, Boolean& hasMultipleIds);
    protected virtual SyntaxTrivia TogglePragmaDirective(SyntaxTrivia trivia);
    protected virtual SyntaxToken GetAdjustedTokenForPragmaRestore(SyntaxToken token, SyntaxNode root, TextLineCollection lines, int indexOfLine);
}
[ExportLanguageServiceAttribute("Microsoft.CodeAnalysis.CodeLens.ICodeLensDisplayInfoService", "C#", "Default")]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.CSharp.CodeLens.CSharpCodeLensDisplayInfoService : object {
    private static SymbolDisplayFormat Format;
    private static CSharpCodeLensDisplayInfoService();
    public sealed virtual SyntaxNode GetDisplayNode(SyntaxNode node);
    public sealed virtual string GetDisplayName(SemanticModel semanticModel, SyntaxNode node);
    private static string GetEnclosingScopeString(SyntaxNode node, SemanticModel semanticModel, SymbolDisplayFormat symbolDisplayFormat);
}
[ExportCodeRefactoringProviderAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.CSharp.CodeRefactorings.AddAwait.CSharpAddAwaitCodeRefactoringProvider : AbstractAddAwaitCodeRefactoringProvider`1<ExpressionSyntax> {
    protected virtual string GetTitle();
    protected virtual string GetTitleWithConfigureAwait();
    protected virtual bool IsInAsyncContext(SyntaxNode node);
}
[ExportCodeRefactoringProviderAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.CSharp.CodeRefactorings.AddMissingImports.CSharpAddMissingImportsRefactoringProvider : AbstractAddMissingImportsRefactoringProvider {
    protected string CodeActionTitle { get; }
    [ImportingConstructorAttribute]
public CSharpAddMissingImportsRefactoringProvider(IPasteTrackingService pasteTrackingService);
    protected virtual string get_CodeActionTitle();
}
[ExportCodeRefactoringProviderAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.CSharp.CodeRefactorings.ConvertLocalFunctionToMethod.CSharpConvertLocalFunctionToMethodCodeRefactoringProvider : CodeRefactoringProvider {
    private static SyntaxAnnotation s_delegateToReplaceAnnotation;
    private static SyntaxGenerator s_generator;
    private static CSharpConvertLocalFunctionToMethodCodeRefactoringProvider();
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.CSharp.CodeRefactorings.ConvertLocalFunctionToMethod.CSharpConvertLocalFunctionToMethodCodeRefactoringProvider/<ComputeRefactoringsAsync>d__3")]
public virtual Task ComputeRefactoringsAsync(CodeRefactoringContext context);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.CSharp.CodeRefactorings.ConvertLocalFunctionToMethod.CSharpConvertLocalFunctionToMethodCodeRefactoringProvider/<UpdateDocumentAsync>d__4")]
private static Task`1<Document> UpdateDocumentAsync(SyntaxNode root, Document document, BlockSyntax parentBlock, LocalFunctionStatementSyntax localFunction, CancellationToken cancellationToken);
    private static bool SupportsNonTrailingNamedArguments(ParseOptions options);
    private static SyntaxNode GenerateArgument(IParameterSymbol p, string name, bool shouldUseNamedArguments);
    private static List`1<string> GenerateUniqueParameterNames(ImmutableArray`1<IParameterSymbol> parameters, List`1<string> reservedNames);
    private static List`1<string> GetReservedNames(SyntaxNode node, SemanticModel semanticModel, CancellationToken cancellationToken);
    private static ParameterSyntax GenerateParameter(IParameterSymbol p, string name);
    private static MethodDeclarationSyntax WithBodyFrom(MethodDeclarationSyntax method, LocalFunctionStatementSyntax localFunction);
    private static void GetCapturedTypeParameters(ISymbol symbol, List`1<ITypeParameterSymbol> typeParameters);
    private static void RemoveUnusedTypeParameters(SyntaxNode localFunction, SemanticModel semanticModel, List`1<ITypeParameterSymbol> typeParameters, IEnumerable`1<ITypeParameterSymbol> reservedTypeParameters);
    private static string GenerateUniqueMethodName(ISymbol declaredSymbol);
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[ExportLanguageServiceAttribute("Microsoft.CodeAnalysis.CodeRefactorings.IRefactoringHelpersService", "C#", "Default")]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.CSharp.CodeRefactorings.CSharpRefactoringHelpersService : AbstractRefactoringHelpersService`3<ExpressionSyntax, ArgumentSyntax, ExpressionStatementSyntax> {
    [IteratorStateMachineAttribute("Microsoft.CodeAnalysis.CSharp.CodeRefactorings.CSharpRefactoringHelpersService/<ExtractNodesSimple>d__1")]
protected virtual IEnumerable`1<SyntaxNode> ExtractNodesSimple(SyntaxNode node, ISyntaxFactsService syntaxFacts);
    [CompilerGeneratedAttribute]
[DebuggerHiddenAttribute]
private IEnumerable`1<SyntaxNode> <>n__0(SyntaxNode node, ISyntaxFactsService syntaxFacts);
}
[ExportCodeRefactoringProviderAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
[SharedAttribute]
[ExtensionOrderAttribute]
internal class Microsoft.CodeAnalysis.CSharp.CodeRefactorings.ExtractClass.CSharpExtractClassCodeRefactoringProvider : AbstractExtractClassRefactoringProvider {
    [NullableContextAttribute("1")]
internal CSharpExtractClassCodeRefactoringProvider(IExtractClassOptionsService optionsService);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.CSharp.CodeRefactorings.ExtractClass.CSharpExtractClassCodeRefactoringProvider/<GetSelectedClassDeclarationAsync>d__2")]
protected virtual Task`1<SyntaxNode> GetSelectedClassDeclarationAsync(CodeRefactoringContext context);
    protected virtual Task`1<SyntaxNode> GetSelectedNodeAsync(CodeRefactoringContext context);
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[ExportCodeRefactoringProviderAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
[SharedAttribute]
[ExportAttribute("Microsoft.CodeAnalysis.CSharp.CodeRefactorings.InlineMethod.CSharpInlineMethodRefactoringProvider")]
internal class Microsoft.CodeAnalysis.CSharp.CodeRefactorings.InlineMethod.CSharpInlineMethodRefactoringProvider : AbstractInlineMethodRefactoringProvider`4<BaseMethodDeclarationSyntax, StatementSyntax, ExpressionSyntax, InvocationExpressionSyntax> {
    protected virtual ExpressionSyntax GetRawInlineExpression(BaseMethodDeclarationSyntax methodDeclarationSyntax);
    protected virtual SyntaxNode GenerateTypeSyntax(ITypeSymbol symbol, bool allowVar);
    protected virtual ExpressionSyntax GenerateLiteralExpression(ITypeSymbol typeSymbol, object value);
    protected virtual bool IsFieldDeclarationSyntax(SyntaxNode node);
    protected virtual bool IsValidExpressionUnderExpressionStatement(ExpressionSyntax expressionNode);
    protected virtual bool CanBeReplacedByThrowExpression(SyntaxNode syntaxNode);
    private static bool IsNullConditionalInvocationExpression(ExpressionSyntax expressionSyntax);
}
[ExportCodeRefactoringProviderAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.CSharp.CodeRefactorings.InlineTemporary.InlineTemporaryCodeRefactoringProvider : AbstractInlineTemporaryCodeRefactoringProvider`1<VariableDeclaratorSyntax> {
    internal static SyntaxAnnotation DefinitionAnnotation;
    internal static SyntaxAnnotation ReferenceAnnotation;
    internal static SyntaxAnnotation InitializerAnnotation;
    internal static SyntaxAnnotation ExpressionToInlineAnnotation;
    private static InlineTemporaryCodeRefactoringProvider();
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.CSharp.CodeRefactorings.InlineTemporary.InlineTemporaryCodeRefactoringProvider/<ComputeRefactoringsAsync>d__5")]
public virtual Task ComputeRefactoringsAsync(CodeRefactoringContext context);
    private static bool HasConflict(IdentifierNameSyntax identifier, VariableDeclaratorSyntax variableDeclarator);
    private static SyntaxAnnotation CreateConflictAnnotation();
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.CSharp.CodeRefactorings.InlineTemporary.InlineTemporaryCodeRefactoringProvider/<InlineTemporaryAsync>d__8")]
private static Task`1<Document> InlineTemporaryAsync(Document document, VariableDeclaratorSyntax declarator, CancellationToken cancellationToken);
    private static bool MayContainSideEffects(SyntaxNode expression);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.CSharp.CodeRefactorings.InlineTemporary.InlineTemporaryCodeRefactoringProvider/<FindDeclaratorAsync>d__10")]
private static Task`1<VariableDeclaratorSyntax> FindDeclaratorAsync(Document document, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.CSharp.CodeRefactorings.InlineTemporary.InlineTemporaryCodeRefactoringProvider/<FindInitializerAsync>d__11")]
private static Task`1<ExpressionSyntax> FindInitializerAsync(Document document, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.CSharp.CodeRefactorings.InlineTemporary.InlineTemporaryCodeRefactoringProvider/<FindNodeWithAnnotationAsync>d__12`1")]
private static Task`1<T> FindNodeWithAnnotationAsync(Document document, SyntaxAnnotation annotation, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.CSharp.CodeRefactorings.InlineTemporary.InlineTemporaryCodeRefactoringProvider/<FindReferenceAnnotatedNodesAsync>d__13")]
private static Task`1<IEnumerable`1<IdentifierNameSyntax>> FindReferenceAnnotatedNodesAsync(Document document, CancellationToken cancellationToken);
    [IteratorStateMachineAttribute("Microsoft.CodeAnalysis.CSharp.CodeRefactorings.InlineTemporary.InlineTemporaryCodeRefactoringProvider/<FindReferenceAnnotatedNodes>d__14")]
private static IEnumerable`1<IdentifierNameSyntax> FindReferenceAnnotatedNodes(SyntaxNode root);
    private static SyntaxNode GetScope(VariableDeclaratorSyntax variableDeclarator);
    private static VariableDeclaratorSyntax FindDeclarator(SyntaxNode node);
    private static SyntaxNode RemoveDeclaratorFromVariableList(VariableDeclaratorSyntax variableDeclarator, VariableDeclarationSyntax variableDeclaration);
    private static SyntaxNode RemoveDeclaratorFromScope(VariableDeclaratorSyntax variableDeclarator, SyntaxNode scope);
    private static ExpressionSyntax SkipRedundantExteriorParentheses(ExpressionSyntax expression);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.CSharp.CodeRefactorings.InlineTemporary.InlineTemporaryCodeRefactoringProvider/<CreateExpressionToInlineAsync>d__20")]
private static Task`1<ExpressionSyntax> CreateExpressionToInlineAsync(VariableDeclaratorSyntax variableDeclarator, Document document, CancellationToken cancellationToken);
    private static SyntaxNode GetTopMostParentingExpression(ExpressionSyntax expression);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.CSharp.CodeRefactorings.InlineTemporary.InlineTemporaryCodeRefactoringProvider/<DetectSemanticConflictsAsync>d__22")]
private static Task`1<Document> DetectSemanticConflictsAsync(Document inlinedDocument, SemanticModel newSemanticModelForInlinedDocument, SemanticModel semanticModelBeforeInline, SymbolInfo originalInitializerSymbolInfo, CancellationToken cancellationToken);
    private static bool IsInDeconstructionAssignmentLeft(ExpressionSyntax node);
    [CompilerGeneratedAttribute]
internal static SyntaxNode <DetectSemanticConflictsAsync>g__conflictAnnotationAdder|22_0(SyntaxNode oldNode, SyntaxNode newNode);
}
internal class Microsoft.CodeAnalysis.CSharp.CodeRefactorings.LambdaSimplifier.LambdaSimplifierCodeRefactoringProvider : CodeRefactoringProvider {
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.CSharp.CodeRefactorings.LambdaSimplifier.LambdaSimplifierCodeRefactoringProvider/<ComputeRefactoringsAsync>d__0")]
public virtual Task ComputeRefactoringsAsync(CodeRefactoringContext context);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.CSharp.CodeRefactorings.LambdaSimplifier.LambdaSimplifierCodeRefactoringProvider/<SimplifyLambdaAsync>d__1")]
private static Task`1<Document> SimplifyLambdaAsync(Document document, SyntaxNode lambda, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.CSharp.CodeRefactorings.LambdaSimplifier.LambdaSimplifierCodeRefactoringProvider/<SimplifyAllLambdasAsync>d__2")]
private static Task`1<Document> SimplifyAllLambdasAsync(Document document, CancellationToken cancellationToken);
    private static bool CanSimplify(SemanticDocument document, SimpleLambdaExpressionSyntax node, CancellationToken cancellationToken);
    private static bool CanSimplify(SemanticDocument document, ParenthesizedLambdaExpressionSyntax node, CancellationToken cancellationToken);
    private static bool CanSimplify(SemanticDocument document, ExpressionSyntax lambda, List`1<SyntaxToken> paramNames, InvocationExpressionSyntax invocation, CancellationToken cancellationToken);
    private static bool WouldCauseAmbiguity(ExpressionSyntax lambda, InvocationExpressionSyntax invocation, SemanticModel oldSemanticModel, CancellationToken cancellationToken);
    private static InvocationExpressionSyntax TryGetInvocationExpression(SyntaxNode lambdaBody);
}
[ExportLanguageServiceAttribute("Microsoft.CodeAnalysis.CodeRefactorings.MoveType.IMoveTypeService", "C#", "Default")]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.CSharp.CodeRefactorings.MoveType.CSharpMoveTypeService : AbstractMoveTypeService`5<CSharpMoveTypeService, BaseTypeDeclarationSyntax, NamespaceDeclarationSyntax, MemberDeclarationSyntax, CompilationUnitSyntax> {
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.CSharp.CodeRefactorings.MoveType.CSharpMoveTypeService/<GetRelevantNodeAsync>d__1")]
protected virtual Task`1<BaseTypeDeclarationSyntax> GetRelevantNodeAsync(Document document, TextSpan textSpan, CancellationToken cancellationToken);
}
internal static class Microsoft.CodeAnalysis.CSharp.CodeRefactorings.NodeSelectionHelpers : object {
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.CSharp.CodeRefactorings.NodeSelectionHelpers/<GetSelectedDeclarationOrVariableAsync>d__0")]
internal static Task`1<SyntaxNode> GetSelectedDeclarationOrVariableAsync(CodeRefactoringContext context);
}
[ExportCodeRefactoringProviderAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.CSharp.CodeRefactorings.PullMemberUp.CSharpPullMemberUpCodeRefactoringProvider : AbstractPullMemberUpRefactoringProvider {
    public CSharpPullMemberUpCodeRefactoringProvider(IPullMemberUpOptionsService service);
    protected virtual Task`1<SyntaxNode> GetSelectedNodeAsync(CodeRefactoringContext context);
}
[ExportLanguageServiceAttribute("Microsoft.CodeAnalysis.ReplaceMethodWithProperty.IReplaceMethodWithPropertyService", "C#", "Default")]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.CSharp.CodeRefactorings.ReplaceMethodWithProperty.CSharpReplaceMethodWithPropertyService : AbstractReplaceMethodWithPropertyService`1<MethodDeclarationSyntax> {
    private static Action`4<SyntaxEditor, InvocationExpressionSyntax, SimpleNameSyntax, SimpleNameSyntax> s_replaceGetReferenceInvocation;
    private static Action`4<SyntaxEditor, InvocationExpressionSyntax, SimpleNameSyntax, SimpleNameSyntax> s_replaceSetReferenceInvocation;
    private static CSharpReplaceMethodWithPropertyService();
    public sealed virtual void RemoveSetMethod(SyntaxEditor editor, SyntaxNode setMethodDeclaration);
    public sealed virtual void ReplaceGetMethodWithProperty(DocumentOptionSet documentOptions, ParseOptions parseOptions, SyntaxEditor editor, SemanticModel semanticModel, GetAndSetMethods getAndSetMethods, string propertyName, bool nameChanged);
    public static SyntaxNode ConvertMethodsToProperty(DocumentOptionSet documentOptions, ParseOptions parseOptions, SemanticModel semanticModel, SyntaxGenerator generator, GetAndSetMethods getAndSetMethods, string propertyName, bool nameChanged);
    public static PropertyDeclarationSyntax ConvertMethodsToPropertyWorker(DocumentOptionSet documentOptions, ParseOptions parseOptions, SemanticModel semanticModel, SyntaxGenerator generator, GetAndSetMethods getAndSetMethods, string propertyName, bool nameChanged);
    private static SyntaxToken GetPropertyName(SyntaxToken identifier, string propertyName, bool nameChanged);
    private static AccessorDeclarationSyntax CreateGetAccessor(GetAndSetMethods getAndSetMethods, DocumentOptionSet documentOptions, ParseOptions parseOptions);
    private static AccessorDeclarationSyntax UseExpressionOrBlockBodyIfDesired(DocumentOptionSet documentOptions, ParseOptions parseOptions, AccessorDeclarationSyntax accessorDeclaration);
    private static AccessorDeclarationSyntax CreateGetAccessorWorker(GetAndSetMethods getAndSetMethods);
    private static AccessorDeclarationSyntax CreateSetAccessor(SemanticModel semanticModel, SyntaxGenerator generator, GetAndSetMethods getAndSetMethods, DocumentOptionSet documentOptions, ParseOptions parseOptions);
    private static AccessorDeclarationSyntax CreateSetAccessorWorker(SemanticModel semanticModel, SyntaxGenerator generator, GetAndSetMethods getAndSetMethods);
    private static TNode ReplaceReferencesToParameterWithValue(SemanticModel semanticModel, IParameterSymbol parameter, TNode node);
    public sealed virtual void ReplaceGetReference(SyntaxEditor editor, SyntaxToken nameToken, string propertyName, bool nameChanged);
    public sealed virtual void ReplaceSetReference(SyntaxEditor editor, SyntaxToken nameToken, string propertyName, bool nameChanged);
    public static void ReplaceInvocation(SyntaxEditor editor, SyntaxToken nameToken, string propertyName, bool nameChanged, Action`4<SyntaxEditor, InvocationExpressionSyntax, SimpleNameSyntax, SimpleNameSyntax> replace);
    private static bool IsInvocationName(IdentifierNameSyntax nameNode, ExpressionSyntax invocationExpression);
    private sealed virtual override Task`1<SyntaxNode> Microsoft.CodeAnalysis.ReplaceMethodWithProperty.IReplaceMethodWithPropertyService.GetMethodDeclarationAsync(CodeRefactoringContext context);
}
[ExportCodeRefactoringProviderAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.CSharp.CodeRefactorings.SyncNamespace.CSharpSyncNamespaceCodeRefactoringProvider : AbstractSyncNamespaceCodeRefactoringProvider`3<NamespaceDeclarationSyntax, CompilationUnitSyntax, MemberDeclarationSyntax> {
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.CSharp.CodeRefactorings.SyncNamespace.CSharpSyncNamespaceCodeRefactoringProvider/<TryGetApplicableInvocationNodeAsync>d__1")]
protected virtual Task`1<SyntaxNode> TryGetApplicableInvocationNodeAsync(Document document, TextSpan span, CancellationToken cancellationToken);
    protected virtual string EscapeIdentifier(string identifier);
}
[ExportCodeRefactoringProviderAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.CSharp.CodeRefactorings.UseExplicitType.UseExplicitTypeCodeRefactoringProvider : AbstractUseTypeCodeRefactoringProvider {
    protected string Title { get; }
    protected virtual string get_Title();
    protected virtual TypeSyntax FindAnalyzableType(SyntaxNode node, SemanticModel semanticModel, CancellationToken cancellationToken);
    protected virtual TypeStyleResult AnalyzeTypeName(TypeSyntax typeName, SemanticModel semanticModel, OptionSet optionSet, CancellationToken cancellationToken);
    protected virtual Task HandleDeclarationAsync(Document document, SyntaxEditor editor, TypeSyntax node, CancellationToken cancellationToken);
}
[ExportCodeRefactoringProviderAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.CSharp.CodeRefactorings.UseImplicitType.UseImplicitTypeCodeRefactoringProvider : AbstractUseTypeCodeRefactoringProvider {
    protected string Title { get; }
    protected virtual string get_Title();
    protected virtual TypeSyntax FindAnalyzableType(SyntaxNode node, SemanticModel semanticModel, CancellationToken cancellationToken);
    protected virtual TypeStyleResult AnalyzeTypeName(TypeSyntax typeName, SemanticModel semanticModel, OptionSet optionSet, CancellationToken cancellationToken);
    protected virtual Task HandleDeclarationAsync(Document document, SyntaxEditor editor, TypeSyntax type, CancellationToken cancellationToken);
}
internal abstract class Microsoft.CodeAnalysis.CSharp.CodeRefactorings.UseType.AbstractUseTypeCodeRefactoringProvider : CodeRefactoringProvider {
    protected string Title { get; }
    protected abstract virtual string get_Title();
    protected abstract virtual Task HandleDeclarationAsync(Document document, SyntaxEditor editor, TypeSyntax type, CancellationToken cancellationToken);
    protected abstract virtual TypeSyntax FindAnalyzableType(SyntaxNode node, SemanticModel semanticModel, CancellationToken cancellationToken);
    protected abstract virtual TypeStyleResult AnalyzeTypeName(TypeSyntax typeName, SemanticModel semanticModel, OptionSet optionSet, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.CSharp.CodeRefactorings.UseType.AbstractUseTypeCodeRefactoringProvider/<ComputeRefactoringsAsync>d__5")]
public virtual Task ComputeRefactoringsAsync(CodeRefactoringContext context);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.CSharp.CodeRefactorings.UseType.AbstractUseTypeCodeRefactoringProvider/<GetDeclarationAsync>d__6")]
private static Task`1<SyntaxNode> GetDeclarationAsync(CodeRefactoringContext context);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.CSharp.CodeRefactorings.UseType.AbstractUseTypeCodeRefactoringProvider/<UpdateDocumentAsync>d__7")]
private Task`1<Document> UpdateDocumentAsync(Document document, TypeSyntax type, CancellationToken cancellationToken);
}
internal static class Microsoft.CodeAnalysis.CSharp.Completion.CSharpCompletionOptions : object {
    [ObsoleteAttribute("This option is superceded by CompletionOptions.EnterKeyBehavior")]
public static Option2`1<bool> AddNewLineOnEnterAfterFullyTypedWord;
    [ObsoleteAttribute("This option is superceded by CompletionOptions.SnippetsBehavior")]
public static Option2`1<bool> IncludeSnippets;
    private static CSharpCompletionOptions();
}
internal class Microsoft.CodeAnalysis.CSharp.Completion.CSharpCompletionService : CommonCompletionService {
    private Workspace _workspace;
    private CompletionRules _latestRules;
    public string Language { get; }
    [ObsoleteAttribute("This factory method only provides services for the MEF export provider.", "True")]
public CSharpCompletionService(Workspace workspace);
    public virtual string get_Language();
    public virtual TextSpan GetDefaultCompletionListSpan(SourceText text, int caretPosition);
    public virtual CompletionRules GetRules();
}
[ExportLanguageServiceFactoryAttribute("Microsoft.CodeAnalysis.Completion.CompletionService", "C#", "Default")]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.CSharp.Completion.CSharpCompletionServiceFactory : object {
    [ObsoleteAttribute("This factory method only provides services for the MEF export provider.", "True")]
public sealed virtual ILanguageService CreateLanguageService(HostLanguageServices languageServices);
}
internal class Microsoft.CodeAnalysis.CSharp.Completion.KeywordRecommenders.AbstractKeywordRecommender : AbstractSyntacticSingleKeywordRecommender {
    private static ISet`1<SyntaxKind> s_validMemberModifiers;
    private static ISet`1<SyntaxKind> s_validTypeModifiers;
    private static AbstractKeywordRecommender();
    protected virtual bool IsValidContext(int position, CSharpSyntaxContext context, CancellationToken cancellationToken);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal abstract class Microsoft.CodeAnalysis.CSharp.Completion.KeywordRecommenders.AbstractNativeIntegerKeywordRecommender : object {
    protected RecommendedKeyword Keyword { get; }
    protected abstract virtual RecommendedKeyword get_Keyword();
    private static bool IsValidContext(CSharpSyntaxContext context);
    public sealed virtual ImmutableArray`1<RecommendedKeyword> RecommendKeywords(int position, CSharpSyntaxContext context, CancellationToken cancellationToken);
}
internal abstract class Microsoft.CodeAnalysis.CSharp.Completion.KeywordRecommenders.AbstractSpecialTypePreselectingKeywordRecommender : AbstractSyntacticSingleKeywordRecommender {
    protected SpecialType SpecialType { get; }
    public AbstractSpecialTypePreselectingKeywordRecommender(SyntaxKind keywordKind, bool isValidInPreprocessorContext, bool shouldFormatOnCommit);
    protected abstract virtual SpecialType get_SpecialType();
    [NullableContextAttribute("1")]
protected virtual bool ShouldPreselect(CSharpSyntaxContext context, CancellationToken cancellationToken);
    [CompilerGeneratedAttribute]
private bool <ShouldPreselect>b__3_0(ITypeSymbol t);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal abstract class Microsoft.CodeAnalysis.CSharp.Completion.KeywordRecommenders.AbstractSyntacticSingleKeywordRecommender : object {
    public SyntaxKind KeywordKind;
    private bool _isValidInPreprocessorContext;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private ImmutableArray`1<RecommendedKeyword> _keywordPriorityRecommendedKeywords;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private ImmutableArray`1<RecommendedKeyword> _defaultPriorityRecommendedKeywords;
    protected int DefaultMatchPriority { get; }
    protected AbstractSyntacticSingleKeywordRecommender(SyntaxKind keywordKind, bool isValidInPreprocessorContext, bool shouldFormatOnCommit);
    protected virtual int get_DefaultMatchPriority();
    protected abstract virtual bool IsValidContext(int position, CSharpSyntaxContext context, CancellationToken cancellationToken);
    public sealed virtual ImmutableArray`1<RecommendedKeyword> RecommendKeywords(int position, CSharpSyntaxContext context, CancellationToken cancellationToken);
    protected virtual bool ShouldPreselect(CSharpSyntaxContext context, CancellationToken cancellationToken);
    private Nullable`1<SyntaxKind> RecommendKeyword(int position, CSharpSyntaxContext context, CancellationToken cancellationToken);
    internal TestAccessor GetTestAccessor();
}
internal class Microsoft.CodeAnalysis.CSharp.Completion.KeywordRecommenders.AddKeywordRecommender : AbstractSyntacticSingleKeywordRecommender {
    protected virtual bool IsValidContext(int position, CSharpSyntaxContext context, CancellationToken cancellationToken);
}
internal class Microsoft.CodeAnalysis.CSharp.Completion.KeywordRecommenders.AliasKeywordRecommender : AbstractSyntacticSingleKeywordRecommender {
    protected virtual bool IsValidContext(int position, CSharpSyntaxContext context, CancellationToken cancellationToken);
}
internal class Microsoft.CodeAnalysis.CSharp.Completion.KeywordRecommenders.AndKeywordRecommender : AbstractSyntacticSingleKeywordRecommender {
    protected virtual bool IsValidContext(int position, CSharpSyntaxContext context, CancellationToken cancellationToken);
}
internal class Microsoft.CodeAnalysis.CSharp.Completion.KeywordRecommenders.AnnotationsKeywordRecommender : AbstractSyntacticSingleKeywordRecommender {
    protected virtual bool IsValidContext(int position, CSharpSyntaxContext context, CancellationToken cancellationToken);
}
internal class Microsoft.CodeAnalysis.CSharp.Completion.KeywordRecommenders.AscendingKeywordRecommender : AbstractSyntacticSingleKeywordRecommender {
    protected virtual bool IsValidContext(int position, CSharpSyntaxContext context, CancellationToken cancellationToken);
}
internal class Microsoft.CodeAnalysis.CSharp.Completion.KeywordRecommenders.AsKeywordRecommender : AbstractSyntacticSingleKeywordRecommender {
    protected virtual bool IsValidContext(int position, CSharpSyntaxContext context, CancellationToken cancellationToken);
}
internal class Microsoft.CodeAnalysis.CSharp.Completion.KeywordRecommenders.AssemblyKeywordRecommender : AbstractSyntacticSingleKeywordRecommender {
    protected virtual bool IsValidContext(int position, CSharpSyntaxContext context, CancellationToken cancellationToken);
}
internal class Microsoft.CodeAnalysis.CSharp.Completion.KeywordRecommenders.AsyncKeywordRecommender : AbstractSyntacticSingleKeywordRecommender {
    private static ISet`1<SyntaxKind> s_validLocalFunctionModifiers;
    private static AsyncKeywordRecommender();
    protected virtual bool IsValidContext(int position, CSharpSyntaxContext context, CancellationToken cancellationToken);
    private static bool InMemberDeclarationContext(int position, CSharpSyntaxContext context, CancellationToken cancellationToken);
}
internal class Microsoft.CodeAnalysis.CSharp.Completion.KeywordRecommenders.AwaitKeywordRecommender : AbstractSyntacticSingleKeywordRecommender {
    protected virtual bool IsValidContext(int position, CSharpSyntaxContext context, CancellationToken cancellationToken);
}
internal class Microsoft.CodeAnalysis.CSharp.Completion.KeywordRecommenders.BaseKeywordRecommender : AbstractSyntacticSingleKeywordRecommender {
    protected virtual bool IsValidContext(int position, CSharpSyntaxContext context, CancellationToken cancellationToken);
    private static bool IsInstanceExpressionOrStatement(CSharpSyntaxContext context);
    private static bool IsConstructorInitializerContext(CSharpSyntaxContext context);
}
internal class Microsoft.CodeAnalysis.CSharp.Completion.KeywordRecommenders.BoolKeywordRecommender : AbstractSpecialTypePreselectingKeywordRecommender {
    protected SpecialType SpecialType { get; }
    protected virtual bool IsValidContext(int position, CSharpSyntaxContext context, CancellationToken cancellationToken);
    protected virtual SpecialType get_SpecialType();
}
internal class Microsoft.CodeAnalysis.CSharp.Completion.KeywordRecommenders.BreakKeywordRecommender : AbstractSyntacticSingleKeywordRecommender {
    protected virtual bool IsValidContext(int position, CSharpSyntaxContext context, CancellationToken cancellationToken);
    private static bool IsInBreakableConstructContext(CSharpSyntaxContext context);
}
internal class Microsoft.CodeAnalysis.CSharp.Completion.KeywordRecommenders.ByKeywordRecommender : AbstractSyntacticSingleKeywordRecommender {
    protected virtual bool IsValidContext(int position, CSharpSyntaxContext context, CancellationToken cancellationToken);
}
internal class Microsoft.CodeAnalysis.CSharp.Completion.KeywordRecommenders.ByteKeywordRecommender : AbstractSpecialTypePreselectingKeywordRecommender {
    protected SpecialType SpecialType { get; }
    protected virtual bool IsValidContext(int position, CSharpSyntaxContext context, CancellationToken cancellationToken);
    protected virtual SpecialType get_SpecialType();
}
internal class Microsoft.CodeAnalysis.CSharp.Completion.KeywordRecommenders.CaseKeywordRecommender : AbstractSyntacticSingleKeywordRecommender {
    protected virtual bool IsValidContext(int position, CSharpSyntaxContext context, CancellationToken cancellationToken);
    internal static bool IsAfterGotoInSwitchContext(CSharpSyntaxContext context);
}
internal class Microsoft.CodeAnalysis.CSharp.Completion.KeywordRecommenders.CatchKeywordRecommender : AbstractSyntacticSingleKeywordRecommender {
    protected virtual bool IsValidContext(int position, CSharpSyntaxContext context, CancellationToken cancellationToken);
}
internal class Microsoft.CodeAnalysis.CSharp.Completion.KeywordRecommenders.CharKeywordRecommender : AbstractSpecialTypePreselectingKeywordRecommender {
    protected SpecialType SpecialType { get; }
    protected virtual bool IsValidContext(int position, CSharpSyntaxContext context, CancellationToken cancellationToken);
    protected virtual SpecialType get_SpecialType();
}
internal class Microsoft.CodeAnalysis.CSharp.Completion.KeywordRecommenders.CheckedKeywordRecommender : AbstractSyntacticSingleKeywordRecommender {
    protected virtual bool IsValidContext(int position, CSharpSyntaxContext context, CancellationToken cancellationToken);
}
internal class Microsoft.CodeAnalysis.CSharp.Completion.KeywordRecommenders.ChecksumKeywordRecommender : AbstractSyntacticSingleKeywordRecommender {
    protected virtual bool IsValidContext(int position, CSharpSyntaxContext context, CancellationToken cancellationToken);
}
internal class Microsoft.CodeAnalysis.CSharp.Completion.KeywordRecommenders.ClassKeywordRecommender : AbstractSyntacticSingleKeywordRecommender {
    private static ISet`1<SyntaxKind> s_validModifiers;
    private static ClassKeywordRecommender();
    protected virtual bool IsValidContext(int position, CSharpSyntaxContext context, CancellationToken cancellationToken);
}
internal class Microsoft.CodeAnalysis.CSharp.Completion.KeywordRecommenders.ConstKeywordRecommender : AbstractSyntacticSingleKeywordRecommender {
    private static ISet`1<SyntaxKind> s_validModifiers;
    private static ISet`1<SyntaxKind> s_validGlobalModifiers;
    private static ConstKeywordRecommender();
    protected virtual bool IsValidContext(int position, CSharpSyntaxContext context, CancellationToken cancellationToken);
    private static bool IsMemberDeclarationContext(CSharpSyntaxContext context, CancellationToken cancellationToken);
    private static bool IsLocalVariableDeclaration(CSharpSyntaxContext context);
}
internal class Microsoft.CodeAnalysis.CSharp.Completion.KeywordRecommenders.ContinueKeywordRecommender : AbstractSyntacticSingleKeywordRecommender {
    protected virtual bool IsValidContext(int position, CSharpSyntaxContext context, CancellationToken cancellationToken);
}
internal class Microsoft.CodeAnalysis.CSharp.Completion.KeywordRecommenders.DecimalKeywordRecommender : AbstractSpecialTypePreselectingKeywordRecommender {
    protected SpecialType SpecialType { get; }
    protected virtual bool IsValidContext(int position, CSharpSyntaxContext context, CancellationToken cancellationToken);
    protected virtual SpecialType get_SpecialType();
}
internal class Microsoft.CodeAnalysis.CSharp.Completion.KeywordRecommenders.DefaultKeywordRecommender : AbstractSyntacticSingleKeywordRecommender {
    protected virtual bool IsValidContext(int position, CSharpSyntaxContext context, CancellationToken cancellationToken);
    private static bool IsValidPreProcessorContext(CSharpSyntaxContext context);
}
internal class Microsoft.CodeAnalysis.CSharp.Completion.KeywordRecommenders.DefineKeywordRecommender : AbstractSyntacticSingleKeywordRecommender {
    [NullableContextAttribute("1")]
protected virtual bool IsValidContext(int position, CSharpSyntaxContext context, CancellationToken cancellationToken);
}
internal class Microsoft.CodeAnalysis.CSharp.Completion.KeywordRecommenders.DelegateKeywordRecommender : AbstractSyntacticSingleKeywordRecommender {
    private static ISet`1<SyntaxKind> s_validModifiers;
    private static DelegateKeywordRecommender();
    protected virtual bool IsValidContext(int position, CSharpSyntaxContext context, CancellationToken cancellationToken);
    private static bool IsAfterAsyncKeywordInExpressionContext(CSharpSyntaxContext context, CancellationToken cancellationToken);
    [CompilerGeneratedAttribute]
internal static bool <IsValidContext>g__ValidTypeContext|2_0(CSharpSyntaxContext context);
}
internal class Microsoft.CodeAnalysis.CSharp.Completion.KeywordRecommenders.DescendingKeywordRecommender : AbstractSyntacticSingleKeywordRecommender {
    protected virtual bool IsValidContext(int position, CSharpSyntaxContext context, CancellationToken cancellationToken);
}
internal class Microsoft.CodeAnalysis.CSharp.Completion.KeywordRecommenders.DisableKeywordRecommender : AbstractSyntacticSingleKeywordRecommender {
    protected virtual bool IsValidContext(int position, CSharpSyntaxContext context, CancellationToken cancellationToken);
}
internal class Microsoft.CodeAnalysis.CSharp.Completion.KeywordRecommenders.DoKeywordRecommender : AbstractSyntacticSingleKeywordRecommender {
    protected virtual bool IsValidContext(int position, CSharpSyntaxContext context, CancellationToken cancellationToken);
}
internal class Microsoft.CodeAnalysis.CSharp.Completion.KeywordRecommenders.DoubleKeywordRecommender : AbstractSpecialTypePreselectingKeywordRecommender {
    protected SpecialType SpecialType { get; }
    protected virtual bool IsValidContext(int position, CSharpSyntaxContext context, CancellationToken cancellationToken);
    protected virtual SpecialType get_SpecialType();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.CodeAnalysis.CSharp.Completion.KeywordRecommenders.DynamicKeywordRecommender : object {
    private static bool IsValidContext(int position, CSharpSyntaxContext context, CancellationToken cancellationToken);
    public sealed virtual ImmutableArray`1<RecommendedKeyword> RecommendKeywords(int position, CSharpSyntaxContext context, CancellationToken cancellationToken);
    protected static bool IsDynamicTypeContext(int position, CSharpSyntaxContext context, CancellationToken cancellationToken);
    private static bool IsAfterRefTypeContext(CSharpSyntaxContext context);
}
internal class Microsoft.CodeAnalysis.CSharp.Completion.KeywordRecommenders.ElifKeywordRecommender : AbstractSyntacticSingleKeywordRecommender {
    protected virtual bool IsValidContext(int position, CSharpSyntaxContext context, CancellationToken cancellationToken);
}
internal class Microsoft.CodeAnalysis.CSharp.Completion.KeywordRecommenders.ElseKeywordRecommender : AbstractSyntacticSingleKeywordRecommender {
    protected virtual bool IsValidContext(int position, CSharpSyntaxContext context, CancellationToken cancellationToken);
}
internal class Microsoft.CodeAnalysis.CSharp.Completion.KeywordRecommenders.EnableKeywordRecommender : AbstractSyntacticSingleKeywordRecommender {
    protected virtual bool IsValidContext(int position, CSharpSyntaxContext context, CancellationToken cancellationToken);
}
internal class Microsoft.CodeAnalysis.CSharp.Completion.KeywordRecommenders.EndIfKeywordRecommender : AbstractSyntacticSingleKeywordRecommender {
    protected virtual bool IsValidContext(int position, CSharpSyntaxContext context, CancellationToken cancellationToken);
}
internal class Microsoft.CodeAnalysis.CSharp.Completion.KeywordRecommenders.EndRegionKeywordRecommender : AbstractSyntacticSingleKeywordRecommender {
    protected virtual bool IsValidContext(int position, CSharpSyntaxContext context, CancellationToken cancellationToken);
}
internal class Microsoft.CodeAnalysis.CSharp.Completion.KeywordRecommenders.EnumKeywordRecommender : AbstractSyntacticSingleKeywordRecommender {
    private static ISet`1<SyntaxKind> s_validModifiers;
    private static EnumKeywordRecommender();
    protected virtual bool IsValidContext(int position, CSharpSyntaxContext context, CancellationToken cancellationToken);
}
internal class Microsoft.CodeAnalysis.CSharp.Completion.KeywordRecommenders.EqualsKeywordRecommender : AbstractSyntacticSingleKeywordRecommender {
    protected virtual bool IsValidContext(int position, CSharpSyntaxContext context, CancellationToken cancellationToken);
}
internal class Microsoft.CodeAnalysis.CSharp.Completion.KeywordRecommenders.ErrorKeywordRecommender : AbstractSyntacticSingleKeywordRecommender {
    protected virtual bool IsValidContext(int position, CSharpSyntaxContext context, CancellationToken cancellationToken);
}
internal class Microsoft.CodeAnalysis.CSharp.Completion.KeywordRecommenders.EventKeywordRecommender : AbstractSyntacticSingleKeywordRecommender {
    private static ISet`1<SyntaxKind> s_validClassModifiers;
    private static ISet`1<SyntaxKind> s_validStructModifiers;
    private static EventKeywordRecommender();
    protected virtual bool IsValidContext(int position, CSharpSyntaxContext context, CancellationToken cancellationToken);
}
internal class Microsoft.CodeAnalysis.CSharp.Completion.KeywordRecommenders.ExplicitKeywordRecommender : AbstractSyntacticSingleKeywordRecommender {
    private static ISet`1<SyntaxKind> s_validMemberModifiers;
    private static ExplicitKeywordRecommender();
    protected virtual bool IsValidContext(int position, CSharpSyntaxContext context, CancellationToken cancellationToken);
}
internal class Microsoft.CodeAnalysis.CSharp.Completion.KeywordRecommenders.ExternKeywordRecommender : AbstractSyntacticSingleKeywordRecommender {
    private static ISet`1<SyntaxKind> s_validModifiers;
    private static ISet`1<SyntaxKind> s_validGlobalModifiers;
    private static ISet`1<SyntaxKind> s_validLocalFunctionModifiers;
    private static ExternKeywordRecommender();
    protected virtual bool IsValidContext(int position, CSharpSyntaxContext context, CancellationToken cancellationToken);
    private static bool IsExternAliasContext(CSharpSyntaxContext context);
}
internal class Microsoft.CodeAnalysis.CSharp.Completion.KeywordRecommenders.FalseKeywordRecommender : AbstractSyntacticSingleKeywordRecommender {
    protected virtual bool IsValidContext(int position, CSharpSyntaxContext context, CancellationToken cancellationToken);
}
internal class Microsoft.CodeAnalysis.CSharp.Completion.KeywordRecommenders.FieldKeywordRecommender : AbstractSyntacticSingleKeywordRecommender {
    private static ISet`1<SyntaxKind> s_validTypeDeclarations;
    private static FieldKeywordRecommender();
    protected virtual bool IsValidContext(int position, CSharpSyntaxContext context, CancellationToken cancellationToken);
}
internal class Microsoft.CodeAnalysis.CSharp.Completion.KeywordRecommenders.FinallyKeywordRecommender : AbstractSyntacticSingleKeywordRecommender {
    protected virtual bool IsValidContext(int position, CSharpSyntaxContext context, CancellationToken cancellationToken);
}
internal class Microsoft.CodeAnalysis.CSharp.Completion.KeywordRecommenders.FixedKeywordRecommender : AbstractSyntacticSingleKeywordRecommender {
    private static ISet`1<SyntaxKind> s_validModifiers;
    private static FixedKeywordRecommender();
    protected virtual bool IsValidContext(int position, CSharpSyntaxContext context, CancellationToken cancellationToken);
    private static bool IsMemberDeclarationContext(CSharpSyntaxContext context, CancellationToken cancellationToken);
    private static bool IsUnsafeStatementContext(CSharpSyntaxContext context);
}
internal class Microsoft.CodeAnalysis.CSharp.Completion.KeywordRecommenders.FloatKeywordRecommender : AbstractSpecialTypePreselectingKeywordRecommender {
    protected SpecialType SpecialType { get; }
    protected virtual bool IsValidContext(int position, CSharpSyntaxContext context, CancellationToken cancellationToken);
    protected virtual SpecialType get_SpecialType();
}
internal class Microsoft.CodeAnalysis.CSharp.Completion.KeywordRecommenders.ForEachKeywordRecommender : AbstractSyntacticSingleKeywordRecommender {
    protected virtual bool IsValidContext(int position, CSharpSyntaxContext context, CancellationToken cancellationToken);
}
internal class Microsoft.CodeAnalysis.CSharp.Completion.KeywordRecommenders.ForKeywordRecommender : AbstractSyntacticSingleKeywordRecommender {
    protected virtual bool IsValidContext(int position, CSharpSyntaxContext context, CancellationToken cancellationToken);
}
internal class Microsoft.CodeAnalysis.CSharp.Completion.KeywordRecommenders.FromKeywordRecommender : AbstractSyntacticSingleKeywordRecommender {
    protected virtual bool IsValidContext(int position, CSharpSyntaxContext context, CancellationToken cancellationToken);
}
internal class Microsoft.CodeAnalysis.CSharp.Completion.KeywordRecommenders.GetKeywordRecommender : AbstractSyntacticSingleKeywordRecommender {
    protected virtual bool IsValidContext(int position, CSharpSyntaxContext context, CancellationToken cancellationToken);
}
internal class Microsoft.CodeAnalysis.CSharp.Completion.KeywordRecommenders.GlobalKeywordRecommender : AbstractSyntacticSingleKeywordRecommender {
    protected virtual bool IsValidContext(int position, CSharpSyntaxContext context, CancellationToken cancellationToken);
}
internal class Microsoft.CodeAnalysis.CSharp.Completion.KeywordRecommenders.GotoKeywordRecommender : AbstractSyntacticSingleKeywordRecommender {
    protected virtual bool IsValidContext(int position, CSharpSyntaxContext context, CancellationToken cancellationToken);
}
internal class Microsoft.CodeAnalysis.CSharp.Completion.KeywordRecommenders.GroupKeywordRecommender : AbstractSyntacticSingleKeywordRecommender {
    protected virtual bool IsValidContext(int position, CSharpSyntaxContext context, CancellationToken cancellationToken);
}
internal class Microsoft.CodeAnalysis.CSharp.Completion.KeywordRecommenders.HiddenKeywordRecommender : AbstractSyntacticSingleKeywordRecommender {
    protected virtual bool IsValidContext(int position, CSharpSyntaxContext context, CancellationToken cancellationToken);
}
internal class Microsoft.CodeAnalysis.CSharp.Completion.KeywordRecommenders.IfKeywordRecommender : AbstractSyntacticSingleKeywordRecommender {
    protected virtual bool IsValidContext(int position, CSharpSyntaxContext context, CancellationToken cancellationToken);
}
internal class Microsoft.CodeAnalysis.CSharp.Completion.KeywordRecommenders.ImplicitKeywordRecommender : AbstractSyntacticSingleKeywordRecommender {
    private static ISet`1<SyntaxKind> s_validMemberModifiers;
    private static ImplicitKeywordRecommender();
    protected virtual bool IsValidContext(int position, CSharpSyntaxContext context, CancellationToken cancellationToken);
}
internal class Microsoft.CodeAnalysis.CSharp.Completion.KeywordRecommenders.InitKeywordRecommender : AbstractSyntacticSingleKeywordRecommender {
    protected virtual bool IsValidContext(int position, CSharpSyntaxContext context, CancellationToken cancellationToken);
}
internal class Microsoft.CodeAnalysis.CSharp.Completion.KeywordRecommenders.InKeywordRecommender : AbstractSyntacticSingleKeywordRecommender {
    protected virtual bool IsValidContext(int position, CSharpSyntaxContext context, CancellationToken cancellationToken);
    private static bool IsInParameterModifierContext(int position, CSharpSyntaxContext context);
    private static bool IsValidContextInForEachClause(CSharpSyntaxContext context);
    private static bool IsValidContextInFromClause(CSharpSyntaxContext context, CancellationToken cancellationToken);
    private static bool IsValidContextInJoinClause(CSharpSyntaxContext context, CancellationToken cancellationToken);
}
internal class Microsoft.CodeAnalysis.CSharp.Completion.KeywordRecommenders.InterfaceKeywordRecommender : AbstractSyntacticSingleKeywordRecommender {
    private static ISet`1<SyntaxKind> s_validModifiers;
    private static InterfaceKeywordRecommender();
    protected virtual bool IsValidContext(int position, CSharpSyntaxContext context, CancellationToken cancellationToken);
}
internal class Microsoft.CodeAnalysis.CSharp.Completion.KeywordRecommenders.InternalKeywordRecommender : AbstractSyntacticSingleKeywordRecommender {
    protected virtual bool IsValidContext(int position, CSharpSyntaxContext context, CancellationToken cancellationToken);
    private static bool IsValidContextForAccessor(CSharpSyntaxContext context);
    private static bool IsValidContextForMember(CSharpSyntaxContext context, CancellationToken cancellationToken);
    private static bool IsValidContextForType(CSharpSyntaxContext context, CancellationToken cancellationToken);
    private static bool CheckPreviousAccessibilityModifiers(CSharpSyntaxContext context);
}
internal class Microsoft.CodeAnalysis.CSharp.Completion.KeywordRecommenders.IntKeywordRecommender : AbstractSpecialTypePreselectingKeywordRecommender {
    protected SpecialType SpecialType { get; }
    protected virtual bool IsValidContext(int position, CSharpSyntaxContext context, CancellationToken cancellationToken);
    protected virtual SpecialType get_SpecialType();
}
internal class Microsoft.CodeAnalysis.CSharp.Completion.KeywordRecommenders.IntoKeywordRecommender : AbstractSyntacticSingleKeywordRecommender {
    protected virtual bool IsValidContext(int position, CSharpSyntaxContext context, CancellationToken cancellationToken);
    private static bool IsValidContextForSelect(CSharpSyntaxContext context);
    private static bool IsValidContextForGroup(CSharpSyntaxContext context);
    private static bool IsValidContextForJoin(CSharpSyntaxContext context);
}
internal class Microsoft.CodeAnalysis.CSharp.Completion.KeywordRecommenders.IsKeywordRecommender : AbstractSyntacticSingleKeywordRecommender {
    protected virtual bool IsValidContext(int position, CSharpSyntaxContext context, CancellationToken cancellationToken);
}
internal class Microsoft.CodeAnalysis.CSharp.Completion.KeywordRecommenders.JoinKeywordRecommender : AbstractSyntacticSingleKeywordRecommender {
    protected virtual bool IsValidContext(int position, CSharpSyntaxContext context, CancellationToken cancellationToken);
}
internal class Microsoft.CodeAnalysis.CSharp.Completion.KeywordRecommenders.LetKeywordRecommender : AbstractSyntacticSingleKeywordRecommender {
    protected virtual bool IsValidContext(int position, CSharpSyntaxContext context, CancellationToken cancellationToken);
}
internal class Microsoft.CodeAnalysis.CSharp.Completion.KeywordRecommenders.LineKeywordRecommender : AbstractSyntacticSingleKeywordRecommender {
    protected virtual bool IsValidContext(int position, CSharpSyntaxContext context, CancellationToken cancellationToken);
}
internal class Microsoft.CodeAnalysis.CSharp.Completion.KeywordRecommenders.LoadKeywordRecommender : AbstractSyntacticSingleKeywordRecommender {
    [NullableContextAttribute("1")]
protected virtual bool IsValidContext(int position, CSharpSyntaxContext context, CancellationToken cancellationToken);
}
internal class Microsoft.CodeAnalysis.CSharp.Completion.KeywordRecommenders.LockKeywordRecommender : AbstractSyntacticSingleKeywordRecommender {
    protected virtual bool IsValidContext(int position, CSharpSyntaxContext context, CancellationToken cancellationToken);
}
internal class Microsoft.CodeAnalysis.CSharp.Completion.KeywordRecommenders.LongKeywordRecommender : AbstractSpecialTypePreselectingKeywordRecommender {
    protected SpecialType SpecialType { get; }
    protected virtual bool IsValidContext(int position, CSharpSyntaxContext context, CancellationToken cancellationToken);
    protected virtual SpecialType get_SpecialType();
}
internal class Microsoft.CodeAnalysis.CSharp.Completion.KeywordRecommenders.ManagedKeywordRecommender : AbstractSyntacticSingleKeywordRecommender {
    [NullableContextAttribute("1")]
protected virtual bool IsValidContext(int position, CSharpSyntaxContext context, CancellationToken cancellationToken);
}
internal class Microsoft.CodeAnalysis.CSharp.Completion.KeywordRecommenders.MethodKeywordRecommender : AbstractSyntacticSingleKeywordRecommender {
    protected virtual bool IsValidContext(int position, CSharpSyntaxContext context, CancellationToken cancellationToken);
}
internal class Microsoft.CodeAnalysis.CSharp.Completion.KeywordRecommenders.ModuleKeywordRecommender : AbstractSyntacticSingleKeywordRecommender {
    protected virtual bool IsValidContext(int position, CSharpSyntaxContext context, CancellationToken cancellationToken);
}
internal class Microsoft.CodeAnalysis.CSharp.Completion.KeywordRecommenders.NameOfKeywordRecommender : AbstractSyntacticSingleKeywordRecommender {
    protected virtual bool IsValidContext(int position, CSharpSyntaxContext context, CancellationToken cancellationToken);
    private static bool IsAttributeArgumentContext(CSharpSyntaxContext context);
}
internal class Microsoft.CodeAnalysis.CSharp.Completion.KeywordRecommenders.NamespaceKeywordRecommender : AbstractSyntacticSingleKeywordRecommender {
    protected virtual bool IsValidContext(int position, CSharpSyntaxContext context, CancellationToken cancellationToken);
}
internal class Microsoft.CodeAnalysis.CSharp.Completion.KeywordRecommenders.NewKeywordRecommender : AbstractSyntacticSingleKeywordRecommender {
    private static ISet`1<SyntaxKind> s_validMemberModifiers;
    protected static ISet`1<SyntaxKind> ValidTypeModifiers;
    private static NewKeywordRecommender();
    protected virtual bool IsValidContext(int position, CSharpSyntaxContext context, CancellationToken cancellationToken);
    private static bool IsTypeDeclarationContext(CSharpSyntaxContext context, CancellationToken cancellationToken);
    private static bool IsMemberDeclarationContext(CSharpSyntaxContext context, CancellationToken cancellationToken);
    private static bool IsNewConstraintContext(CSharpSyntaxContext context);
}
internal class Microsoft.CodeAnalysis.CSharp.Completion.KeywordRecommenders.NintKeywordRecommender : AbstractNativeIntegerKeywordRecommender {
    protected RecommendedKeyword Keyword { get; }
    protected virtual RecommendedKeyword get_Keyword();
}
internal class Microsoft.CodeAnalysis.CSharp.Completion.KeywordRecommenders.NotKeywordRecommender : AbstractSyntacticSingleKeywordRecommender {
    protected virtual bool IsValidContext(int position, CSharpSyntaxContext context, CancellationToken cancellationToken);
}
internal class Microsoft.CodeAnalysis.CSharp.Completion.KeywordRecommenders.NotNullKeywordRecommender : object {
    [NullableContextAttribute("1")]
public sealed virtual ImmutableArray`1<RecommendedKeyword> RecommendKeywords(int position, CSharpSyntaxContext context, CancellationToken cancellationToken);
}
internal class Microsoft.CodeAnalysis.CSharp.Completion.KeywordRecommenders.NuintKeywordRecommender : AbstractNativeIntegerKeywordRecommender {
    protected RecommendedKeyword Keyword { get; }
    protected virtual RecommendedKeyword get_Keyword();
}
internal class Microsoft.CodeAnalysis.CSharp.Completion.KeywordRecommenders.NullableKeywordRecommender : AbstractSyntacticSingleKeywordRecommender {
    protected virtual bool IsValidContext(int position, CSharpSyntaxContext context, CancellationToken cancellationToken);
}
internal class Microsoft.CodeAnalysis.CSharp.Completion.KeywordRecommenders.NullKeywordRecommender : AbstractSyntacticSingleKeywordRecommender {
    protected virtual bool IsValidContext(int position, CSharpSyntaxContext context, CancellationToken cancellationToken);
}
internal class Microsoft.CodeAnalysis.CSharp.Completion.KeywordRecommenders.ObjectKeywordRecommender : AbstractSpecialTypePreselectingKeywordRecommender {
    protected SpecialType SpecialType { get; }
    protected virtual bool IsValidContext(int position, CSharpSyntaxContext context, CancellationToken cancellationToken);
    protected virtual SpecialType get_SpecialType();
}
internal class Microsoft.CodeAnalysis.CSharp.Completion.KeywordRecommenders.OnKeywordRecommender : AbstractSyntacticSingleKeywordRecommender {
    protected virtual bool IsValidContext(int position, CSharpSyntaxContext context, CancellationToken cancellationToken);
}
internal class Microsoft.CodeAnalysis.CSharp.Completion.KeywordRecommenders.OperatorKeywordRecommender : AbstractSyntacticSingleKeywordRecommender {
    protected virtual bool IsValidContext(int position, CSharpSyntaxContext context, CancellationToken cancellationToken);
}
internal class Microsoft.CodeAnalysis.CSharp.Completion.KeywordRecommenders.OrderByKeywordRecommender : AbstractSyntacticSingleKeywordRecommender {
    protected virtual bool IsValidContext(int position, CSharpSyntaxContext context, CancellationToken cancellationToken);
}
internal class Microsoft.CodeAnalysis.CSharp.Completion.KeywordRecommenders.OrKeywordRecommender : AbstractSyntacticSingleKeywordRecommender {
    protected virtual bool IsValidContext(int position, CSharpSyntaxContext context, CancellationToken cancellationToken);
}
internal class Microsoft.CodeAnalysis.CSharp.Completion.KeywordRecommenders.OutKeywordRecommender : AbstractSyntacticSingleKeywordRecommender {
    protected virtual bool IsValidContext(int position, CSharpSyntaxContext context, CancellationToken cancellationToken);
    private static bool IsOutParameterModifierContext(int position, CSharpSyntaxContext context);
}
internal class Microsoft.CodeAnalysis.CSharp.Completion.KeywordRecommenders.OverrideKeywordRecommender : AbstractSyntacticSingleKeywordRecommender {
    private static ISet`1<SyntaxKind> s_validMemberModifiers;
    private static OverrideKeywordRecommender();
    protected virtual bool IsValidContext(int position, CSharpSyntaxContext context, CancellationToken cancellationToken);
}
internal class Microsoft.CodeAnalysis.CSharp.Completion.KeywordRecommenders.ParamKeywordRecommender : AbstractSyntacticSingleKeywordRecommender {
    protected virtual bool IsValidContext(int position, CSharpSyntaxContext context, CancellationToken cancellationToken);
}
internal class Microsoft.CodeAnalysis.CSharp.Completion.KeywordRecommenders.ParamsKeywordRecommender : AbstractSyntacticSingleKeywordRecommender {
    protected virtual bool IsValidContext(int position, CSharpSyntaxContext context, CancellationToken cancellationToken);
}
internal class Microsoft.CodeAnalysis.CSharp.Completion.KeywordRecommenders.PartialKeywordRecommender : AbstractSyntacticSingleKeywordRecommender {
    private static ISet`1<SyntaxKind> s_validMemberModifiers;
    private static PartialKeywordRecommender();
    protected virtual bool IsValidContext(int position, CSharpSyntaxContext context, CancellationToken cancellationToken);
    private static bool IsMemberDeclarationContext(CSharpSyntaxContext context, CancellationToken cancellationToken);
    private static bool IsTypeDeclarationContext(CSharpSyntaxContext context, CancellationToken cancellationToken);
}
internal class Microsoft.CodeAnalysis.CSharp.Completion.KeywordRecommenders.PragmaKeywordRecommender : AbstractSyntacticSingleKeywordRecommender {
    protected virtual bool IsValidContext(int position, CSharpSyntaxContext context, CancellationToken cancellationToken);
}
internal class Microsoft.CodeAnalysis.CSharp.Completion.KeywordRecommenders.PrivateKeywordRecommender : AbstractSyntacticSingleKeywordRecommender {
    protected virtual bool IsValidContext(int position, CSharpSyntaxContext context, CancellationToken cancellationToken);
    private static bool IsValidContextForAccessor(CSharpSyntaxContext context);
    private static bool IsValidContextForMember(CSharpSyntaxContext context, CancellationToken cancellationToken);
    private static bool IsValidContextForType(CSharpSyntaxContext context, CancellationToken cancellationToken);
    private static bool CheckPreviousAccessibilityModifiers(CSharpSyntaxContext context);
}
internal class Microsoft.CodeAnalysis.CSharp.Completion.KeywordRecommenders.PropertyKeywordRecommender : AbstractSyntacticSingleKeywordRecommender {
    protected virtual bool IsValidContext(int position, CSharpSyntaxContext context, CancellationToken cancellationToken);
}
internal class Microsoft.CodeAnalysis.CSharp.Completion.KeywordRecommenders.ProtectedKeywordRecommender : AbstractSyntacticSingleKeywordRecommender {
    protected virtual bool IsValidContext(int position, CSharpSyntaxContext context, CancellationToken cancellationToken);
    private static bool IsValidContextForAccessor(CSharpSyntaxContext context);
    private static bool IsValidContextForMember(CSharpSyntaxContext context, CancellationToken cancellationToken);
    private static bool IsValidContextForType(CSharpSyntaxContext context, CancellationToken cancellationToken);
    private static bool CheckPreviousAccessibilityModifiers(CSharpSyntaxContext context);
}
internal class Microsoft.CodeAnalysis.CSharp.Completion.KeywordRecommenders.PublicKeywordRecommender : AbstractSyntacticSingleKeywordRecommender {
    protected virtual bool IsValidContext(int position, CSharpSyntaxContext context, CancellationToken cancellationToken);
    private static bool IsValidContextForMember(CSharpSyntaxContext context, CancellationToken cancellationToken);
    private static bool IsValidContextForType(CSharpSyntaxContext context, CancellationToken cancellationToken);
    private static bool CheckPreviousAccessibilityModifiers(CSharpSyntaxContext context);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.CodeAnalysis.CSharp.Completion.KeywordRecommenders.ReadOnlyKeywordRecommender : AbstractSyntacticSingleKeywordRecommender {
    private static ISet`1<SyntaxKind> s_validMemberModifiers;
    private static ReadOnlyKeywordRecommender();
    protected virtual bool IsValidContext(int position, CSharpSyntaxContext context, CancellationToken cancellationToken);
    private static bool IsRefReadOnlyContext(CSharpSyntaxContext context);
    private static bool IsValidContextForType(CSharpSyntaxContext context, CancellationToken cancellationToken);
    private static bool IsStructAccessorContext(CSharpSyntaxContext context);
}
internal class Microsoft.CodeAnalysis.CSharp.Completion.KeywordRecommenders.RecordKeywordRecommender : AbstractSyntacticSingleKeywordRecommender {
    private static ISet`1<SyntaxKind> s_validModifiers;
    private static RecordKeywordRecommender();
    protected virtual bool IsValidContext(int position, CSharpSyntaxContext context, CancellationToken cancellationToken);
}
internal class Microsoft.CodeAnalysis.CSharp.Completion.KeywordRecommenders.ReferenceKeywordRecommender : AbstractSyntacticSingleKeywordRecommender {
    [NullableContextAttribute("1")]
protected virtual bool IsValidContext(int position, CSharpSyntaxContext context, CancellationToken cancellationToken);
}
internal class Microsoft.CodeAnalysis.CSharp.Completion.KeywordRecommenders.RefKeywordRecommender : AbstractSyntacticSingleKeywordRecommender {
    private static ISet`1<SyntaxKind> RefMemberModifiers;
    private static ISet`1<SyntaxKind> RefGlobalMemberModifiers;
    private static ISet`1<SyntaxKind> RefGlobalMemberScriptModifiers;
    private static RefKeywordRecommender();
    protected virtual bool IsValidContext(int position, CSharpSyntaxContext context, CancellationToken cancellationToken);
    private static bool IsRefParameterModifierContext(int position, CSharpSyntaxContext context);
    private static bool IsValidNewByRefContext(SyntaxTree syntaxTree, int position, CSharpSyntaxContext context, CancellationToken cancellationToken);
    private static bool IsValidRefExpressionContext(CSharpSyntaxContext context);
    private static bool IsValidContextForType(CSharpSyntaxContext context, CancellationToken cancellationToken);
}
internal class Microsoft.CodeAnalysis.CSharp.Completion.KeywordRecommenders.RegionKeywordRecommender : AbstractSyntacticSingleKeywordRecommender {
    protected virtual bool IsValidContext(int position, CSharpSyntaxContext context, CancellationToken cancellationToken);
}
internal class Microsoft.CodeAnalysis.CSharp.Completion.KeywordRecommenders.RemoveKeywordRecommender : AbstractSyntacticSingleKeywordRecommender {
    protected virtual bool IsValidContext(int position, CSharpSyntaxContext context, CancellationToken cancellationToken);
}
internal class Microsoft.CodeAnalysis.CSharp.Completion.KeywordRecommenders.RestoreKeywordRecommender : AbstractSyntacticSingleKeywordRecommender {
    protected virtual bool IsValidContext(int position, CSharpSyntaxContext context, CancellationToken cancellationToken);
}
internal class Microsoft.CodeAnalysis.CSharp.Completion.KeywordRecommenders.ReturnKeywordRecommender : AbstractSyntacticSingleKeywordRecommender {
    protected virtual bool IsValidContext(int position, CSharpSyntaxContext context, CancellationToken cancellationToken);
    private static bool IsAttributeContext(CSharpSyntaxContext context, CancellationToken cancellationToken);
}
internal class Microsoft.CodeAnalysis.CSharp.Completion.KeywordRecommenders.SByteKeywordRecommender : AbstractSpecialTypePreselectingKeywordRecommender {
    protected SpecialType SpecialType { get; }
    protected virtual bool IsValidContext(int position, CSharpSyntaxContext context, CancellationToken cancellationToken);
    protected virtual SpecialType get_SpecialType();
}
internal class Microsoft.CodeAnalysis.CSharp.Completion.KeywordRecommenders.SealedKeywordRecommender : AbstractSyntacticSingleKeywordRecommender {
    private static ISet`1<SyntaxKind> s_validMemberModifiers;
    private static ISet`1<SyntaxKind> s_validTypeModifiers;
    private static SealedKeywordRecommender();
    protected virtual bool IsValidContext(int position, CSharpSyntaxContext context, CancellationToken cancellationToken);
}
internal class Microsoft.CodeAnalysis.CSharp.Completion.KeywordRecommenders.SelectKeywordRecommender : AbstractSyntacticSingleKeywordRecommender {
    protected virtual bool IsValidContext(int position, CSharpSyntaxContext context, CancellationToken cancellationToken);
}
internal class Microsoft.CodeAnalysis.CSharp.Completion.KeywordRecommenders.SetKeywordRecommender : AbstractSyntacticSingleKeywordRecommender {
    protected virtual bool IsValidContext(int position, CSharpSyntaxContext context, CancellationToken cancellationToken);
}
internal class Microsoft.CodeAnalysis.CSharp.Completion.KeywordRecommenders.ShortKeywordRecommender : AbstractSpecialTypePreselectingKeywordRecommender {
    protected SpecialType SpecialType { get; }
    protected virtual bool IsValidContext(int position, CSharpSyntaxContext context, CancellationToken cancellationToken);
    protected virtual SpecialType get_SpecialType();
}
internal class Microsoft.CodeAnalysis.CSharp.Completion.KeywordRecommenders.SizeOfKeywordRecommender : AbstractSyntacticSingleKeywordRecommender {
    protected virtual bool IsValidContext(int position, CSharpSyntaxContext context, CancellationToken cancellationToken);
}
internal class Microsoft.CodeAnalysis.CSharp.Completion.KeywordRecommenders.StackAllocKeywordRecommender : AbstractSyntacticSingleKeywordRecommender {
    protected virtual bool IsValidContext(int position, CSharpSyntaxContext context, CancellationToken cancellationToken);
}
internal class Microsoft.CodeAnalysis.CSharp.Completion.KeywordRecommenders.StaticKeywordRecommender : AbstractSyntacticSingleKeywordRecommender {
    private static ISet`1<SyntaxKind> s_validTypeModifiers;
    private static ISet`1<SyntaxKind> s_validMemberModifiers;
    private static ISet`1<SyntaxKind> s_validGlobalMemberModifiers;
    private static ISet`1<SyntaxKind> s_validLocalFunctionModifiers;
    private static StaticKeywordRecommender();
    protected virtual bool IsValidContext(int position, CSharpSyntaxContext context, CancellationToken cancellationToken);
    private static bool IsValidContextForMember(CSharpSyntaxContext context, CancellationToken cancellationToken);
    private static bool IsValidContextForType(CSharpSyntaxContext context, CancellationToken cancellationToken);
}
internal class Microsoft.CodeAnalysis.CSharp.Completion.KeywordRecommenders.StringKeywordRecommender : AbstractSpecialTypePreselectingKeywordRecommender {
    protected SpecialType SpecialType { get; }
    protected virtual bool IsValidContext(int position, CSharpSyntaxContext context, CancellationToken cancellationToken);
    protected virtual SpecialType get_SpecialType();
}
internal class Microsoft.CodeAnalysis.CSharp.Completion.KeywordRecommenders.StructKeywordRecommender : AbstractSyntacticSingleKeywordRecommender {
    private static ISet`1<SyntaxKind> s_validModifiers;
    private static StructKeywordRecommender();
    protected virtual bool IsValidContext(int position, CSharpSyntaxContext context, CancellationToken cancellationToken);
}
internal class Microsoft.CodeAnalysis.CSharp.Completion.KeywordRecommenders.SwitchKeywordRecommender : AbstractSyntacticSingleKeywordRecommender {
    protected virtual bool IsValidContext(int position, CSharpSyntaxContext context, CancellationToken cancellationToken);
}
internal class Microsoft.CodeAnalysis.CSharp.Completion.KeywordRecommenders.ThisKeywordRecommender : AbstractSyntacticSingleKeywordRecommender {
    protected virtual bool IsValidContext(int position, CSharpSyntaxContext context, CancellationToken cancellationToken);
    private static bool IsInstanceExpressionOrStatement(CSharpSyntaxContext context);
    private static bool IsConstructorInitializerContext(CSharpSyntaxContext context);
    private static bool IsThisParameterModifierContext(CSharpSyntaxContext context);
    protected virtual bool ShouldPreselect(CSharpSyntaxContext context, CancellationToken cancellationToken);
}
internal class Microsoft.CodeAnalysis.CSharp.Completion.KeywordRecommenders.ThrowKeywordRecommender : AbstractSyntacticSingleKeywordRecommender {
    protected virtual bool IsValidContext(int position, CSharpSyntaxContext context, CancellationToken cancellationToken);
}
internal class Microsoft.CodeAnalysis.CSharp.Completion.KeywordRecommenders.TrueKeywordRecommender : AbstractSyntacticSingleKeywordRecommender {
    protected virtual bool IsValidContext(int position, CSharpSyntaxContext context, CancellationToken cancellationToken);
}
internal class Microsoft.CodeAnalysis.CSharp.Completion.KeywordRecommenders.TryKeywordRecommender : AbstractSyntacticSingleKeywordRecommender {
    protected virtual bool IsValidContext(int position, CSharpSyntaxContext context, CancellationToken cancellationToken);
}
internal class Microsoft.CodeAnalysis.CSharp.Completion.KeywordRecommenders.TypeKeywordRecommender : AbstractSyntacticSingleKeywordRecommender {
    protected virtual bool IsValidContext(int position, CSharpSyntaxContext context, CancellationToken cancellationToken);
}
internal class Microsoft.CodeAnalysis.CSharp.Completion.KeywordRecommenders.TypeOfKeywordRecommender : AbstractSyntacticSingleKeywordRecommender {
    protected virtual bool IsValidContext(int position, CSharpSyntaxContext context, CancellationToken cancellationToken);
    private static bool IsAttributeArgumentContext(CSharpSyntaxContext context);
}
internal class Microsoft.CodeAnalysis.CSharp.Completion.KeywordRecommenders.TypeVarKeywordRecommender : AbstractSyntacticSingleKeywordRecommender {
    protected virtual bool IsValidContext(int position, CSharpSyntaxContext context, CancellationToken cancellationToken);
}
internal class Microsoft.CodeAnalysis.CSharp.Completion.KeywordRecommenders.UIntKeywordRecommender : AbstractSpecialTypePreselectingKeywordRecommender {
    protected SpecialType SpecialType { get; }
    protected virtual bool IsValidContext(int position, CSharpSyntaxContext context, CancellationToken cancellationToken);
    protected virtual SpecialType get_SpecialType();
}
internal class Microsoft.CodeAnalysis.CSharp.Completion.KeywordRecommenders.ULongKeywordRecommender : AbstractSpecialTypePreselectingKeywordRecommender {
    protected SpecialType SpecialType { get; }
    protected virtual bool IsValidContext(int position, CSharpSyntaxContext context, CancellationToken cancellationToken);
    protected virtual SpecialType get_SpecialType();
}
internal class Microsoft.CodeAnalysis.CSharp.Completion.KeywordRecommenders.UncheckedKeywordRecommender : AbstractSyntacticSingleKeywordRecommender {
    protected virtual bool IsValidContext(int position, CSharpSyntaxContext context, CancellationToken cancellationToken);
}
internal class Microsoft.CodeAnalysis.CSharp.Completion.KeywordRecommenders.UndefKeywordRecommender : AbstractSyntacticSingleKeywordRecommender {
    [NullableContextAttribute("1")]
protected virtual bool IsValidContext(int position, CSharpSyntaxContext context, CancellationToken cancellationToken);
}
internal class Microsoft.CodeAnalysis.CSharp.Completion.KeywordRecommenders.UnmanagedKeywordRecommender : AbstractSyntacticSingleKeywordRecommender {
    protected virtual bool IsValidContext(int position, CSharpSyntaxContext context, CancellationToken cancellationToken);
}
internal class Microsoft.CodeAnalysis.CSharp.Completion.KeywordRecommenders.UnsafeKeywordRecommender : AbstractSyntacticSingleKeywordRecommender {
    private static ISet`1<SyntaxKind> s_validTypeModifiers;
    private static ISet`1<SyntaxKind> s_validMemberModifiers;
    private static ISet`1<SyntaxKind> s_validGlobalMemberModifiers;
    private static ISet`1<SyntaxKind> s_validLocalFunctionModifiers;
    private static UnsafeKeywordRecommender();
    protected virtual bool IsValidContext(int position, CSharpSyntaxContext context, CancellationToken cancellationToken);
}
internal class Microsoft.CodeAnalysis.CSharp.Completion.KeywordRecommenders.UShortKeywordRecommender : AbstractSpecialTypePreselectingKeywordRecommender {
    protected int DefaultMatchPriority { get; }
    protected SpecialType SpecialType { get; }
    protected virtual int get_DefaultMatchPriority();
    [NullableContextAttribute("1")]
protected virtual bool IsValidContext(int position, CSharpSyntaxContext context, CancellationToken cancellationToken);
    protected virtual SpecialType get_SpecialType();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.CodeAnalysis.CSharp.Completion.KeywordRecommenders.UsingKeywordRecommender : AbstractSyntacticSingleKeywordRecommender {
    protected virtual bool IsValidContext(int position, CSharpSyntaxContext context, CancellationToken cancellationToken);
    private static bool IsUsingDirectiveContext(CSharpSyntaxContext context, CancellationToken cancellationToken);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.CodeAnalysis.CSharp.Completion.KeywordRecommenders.VarKeywordRecommender : object {
    private static bool IsValidContext(CSharpSyntaxContext context);
    public sealed virtual ImmutableArray`1<RecommendedKeyword> RecommendKeywords(int position, CSharpSyntaxContext context, CancellationToken cancellationToken);
}
internal class Microsoft.CodeAnalysis.CSharp.Completion.KeywordRecommenders.VirtualKeywordRecommender : AbstractSyntacticSingleKeywordRecommender {
    private static ISet`1<SyntaxKind> s_validMemberModifiers;
    private static VirtualKeywordRecommender();
    protected virtual bool IsValidContext(int position, CSharpSyntaxContext context, CancellationToken cancellationToken);
}
internal class Microsoft.CodeAnalysis.CSharp.Completion.KeywordRecommenders.VoidKeywordRecommender : AbstractSyntacticSingleKeywordRecommender {
    private static ISet`1<SyntaxKind> s_validClassInterfaceRecordModifiers;
    private static ISet`1<SyntaxKind> s_validStructModifiers;
    private static VoidKeywordRecommender();
    protected virtual bool IsValidContext(int position, CSharpSyntaxContext context, CancellationToken cancellationToken);
    private static bool IsUnsafeDefaultExpressionContext(CSharpSyntaxContext context);
    private static bool IsUnsafeCastTypeContext(CSharpSyntaxContext context);
    private static bool IsUnsafeParameterTypeContext(CSharpSyntaxContext context);
    private static bool IsUnsafeLocalVariableDeclarationContext(CSharpSyntaxContext context);
    private static bool IsMemberReturnTypeContext(int position, CSharpSyntaxContext context, CancellationToken cancellationToken);
}
internal class Microsoft.CodeAnalysis.CSharp.Completion.KeywordRecommenders.VolatileKeywordRecommender : AbstractSyntacticSingleKeywordRecommender {
    private static ISet`1<SyntaxKind> s_validMemberModifiers;
    private static VolatileKeywordRecommender();
    protected virtual bool IsValidContext(int position, CSharpSyntaxContext context, CancellationToken cancellationToken);
}
internal class Microsoft.CodeAnalysis.CSharp.Completion.KeywordRecommenders.WarningKeywordRecommender : AbstractSyntacticSingleKeywordRecommender {
    protected virtual bool IsValidContext(int position, CSharpSyntaxContext context, CancellationToken cancellationToken);
}
internal class Microsoft.CodeAnalysis.CSharp.Completion.KeywordRecommenders.WarningsKeywordRecommender : AbstractSyntacticSingleKeywordRecommender {
    protected virtual bool IsValidContext(int position, CSharpSyntaxContext context, CancellationToken cancellationToken);
}
internal class Microsoft.CodeAnalysis.CSharp.Completion.KeywordRecommenders.WhenKeywordRecommender : AbstractSyntacticSingleKeywordRecommender {
    protected virtual bool IsValidContext(int position, CSharpSyntaxContext context, CancellationToken cancellationToken);
    private static bool IsAfterCompleteExpressionOrPatternInCaseLabel(CSharpSyntaxContext context);
}
internal class Microsoft.CodeAnalysis.CSharp.Completion.KeywordRecommenders.WhereKeywordRecommender : AbstractSyntacticSingleKeywordRecommender {
    protected virtual bool IsValidContext(int position, CSharpSyntaxContext context, CancellationToken cancellationToken);
    private static bool IsTypeParameterConstraintContext(CSharpSyntaxContext context);
    private static bool IsQueryContext(CSharpSyntaxContext context);
}
internal class Microsoft.CodeAnalysis.CSharp.Completion.KeywordRecommenders.WhileKeywordRecommender : AbstractSyntacticSingleKeywordRecommender {
    protected virtual bool IsValidContext(int position, CSharpSyntaxContext context, CancellationToken cancellationToken);
}
internal class Microsoft.CodeAnalysis.CSharp.Completion.KeywordRecommenders.WithKeywordRecommender : AbstractSyntacticSingleKeywordRecommender {
    protected virtual bool IsValidContext(int position, CSharpSyntaxContext context, CancellationToken cancellationToken);
}
internal class Microsoft.CodeAnalysis.CSharp.Completion.KeywordRecommenders.YieldKeywordRecommender : AbstractSyntacticSingleKeywordRecommender {
    protected virtual bool IsValidContext(int position, CSharpSyntaxContext context, CancellationToken cancellationToken);
}
[ExportCompletionProviderAttribute("AttributeNamedParameterCompletionProvider", "C#")]
[ExtensionOrderAttribute]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.CSharp.Completion.Providers.AttributeNamedParameterCompletionProvider : LSPCompletionProvider {
    private static string EqualsString;
    private static string SpaceEqualsString;
    private static string ColonString;
    private static CompletionItemRules _spaceItemFilterRule;
    [CompilerGeneratedAttribute]
private ImmutableHashSet`1<char> <TriggerCharacters>k__BackingField;
    public ImmutableHashSet`1<char> TriggerCharacters { get; }
    private static AttributeNamedParameterCompletionProvider();
    public virtual bool IsInsertionTrigger(SourceText text, int characterPosition, OptionSet options);
    [CompilerGeneratedAttribute]
public virtual ImmutableHashSet`1<char> get_TriggerCharacters();
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.CSharp.Completion.Providers.AttributeNamedParameterCompletionProvider/<ProvideCompletionsAsync>d__9")]
public virtual Task ProvideCompletionsAsync(CompletionContext context);
    private static bool IsAfterNameColonArgument(SyntaxToken token);
    private static bool IsAfterNameEqualsArgument(SyntaxToken token);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.CSharp.Completion.Providers.AttributeNamedParameterCompletionProvider/<GetNameEqualsItemsAsync>d__12")]
private static Task`1<ImmutableArray`1<CompletionItem>> GetNameEqualsItemsAsync(CompletionContext context, SemanticModel semanticModel, SyntaxToken token, AttributeSyntax attributeSyntax, ISet`1<string> existingNamedParameters);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.CSharp.Completion.Providers.AttributeNamedParameterCompletionProvider/<GetNameColonItemsAsync>d__13")]
private static Task`1<IEnumerable`1<CompletionItem>> GetNameColonItemsAsync(CompletionContext context, SemanticModel semanticModel, SyntaxToken token, AttributeSyntax attributeSyntax, ISet`1<string> existingNamedParameters);
    protected virtual Task`1<CompletionDescription> GetDescriptionWorkerAsync(Document document, CompletionItem item, CancellationToken cancellationToken);
    private static bool IsValid(ImmutableArray`1<IParameterSymbol> parameterList, ISet`1<string> existingNamedParameters);
    private static ISet`1<string> GetExistingNamedParameters(AttributeArgumentListSyntax argumentList, int position);
    private static IEnumerable`1<ImmutableArray`1<IParameterSymbol>> GetParameterLists(SemanticModel semanticModel, int position, AttributeSyntax attribute, CancellationToken cancellationToken);
    private static IEnumerable`1<ISymbol> GetAttributeNamedParameters(SemanticModel semanticModel, int position, AttributeSyntax attribute, CancellationToken cancellationToken);
    protected virtual Task`1<Nullable`1<TextChange>> GetTextChangeAsync(CompletionItem selectedItem, Nullable`1<char> ch, CancellationToken cancellationToken);
    private static Nullable`1<TextChange> GetTextChange(CompletionItem selectedItem, Nullable`1<char> ch);
}
internal static class Microsoft.CodeAnalysis.CSharp.Completion.Providers.CompletionUtilities : object {
    [CompilerGeneratedAttribute]
private static ImmutableHashSet`1<char> <CommonTriggerCharacters>k__BackingField;
    [CompilerGeneratedAttribute]
private static ImmutableHashSet`1<char> <CommonTriggerCharactersWithArgumentList>k__BackingField;
    internal static ImmutableHashSet`1<char> CommonTriggerCharacters { get; }
    internal static ImmutableHashSet`1<char> CommonTriggerCharactersWithArgumentList { get; }
    internal static ImmutableHashSet`1<char> SpaceTriggerCharacter { get; }
    private static CompletionUtilities();
    internal static TextSpan GetCompletionItemSpan(SourceText text, int position);
    public static bool IsWordStartCharacter(char ch);
    public static bool IsWordCharacter(char ch);
    public static bool IsCompletionItemStartCharacter(char ch);
    public static bool TreatAsDot(SyntaxToken token, int characterPosition);
    internal static bool IsTriggerCharacter(SourceText text, int characterPosition, OptionSet options);
    [CompilerGeneratedAttribute]
internal static ImmutableHashSet`1<char> get_CommonTriggerCharacters();
    [CompilerGeneratedAttribute]
internal static ImmutableHashSet`1<char> get_CommonTriggerCharactersWithArgumentList();
    internal static bool IsTriggerCharacterOrArgumentListCharacter(SourceText text, int characterPosition, OptionSet options);
    private static bool IsArgumentListCharacter(SourceText text, int characterPosition);
    internal static bool IsArgumentListCharacter(char ch);
    internal static bool IsTriggerAfterSpaceOrStartOfWordCharacter(SourceText text, int characterPosition, OptionSet options);
    internal static ImmutableHashSet`1<char> get_SpaceTriggerCharacter();
    private static bool SpaceTypedNotBeforeWord(char ch, SourceText text, int characterPosition);
    public static bool IsStartingNewWord(SourceText text, int characterPosition);
    public static ValueTuple`3<string, string, string> GetDisplayAndSuffixAndInsertionText(ISymbol symbol, SyntaxContext context);
    public static string GetInsertionText(ISymbol symbol, SyntaxContext context);
    public static int GetTargetCaretPositionForMethod(MethodDeclarationSyntax methodDeclaration);
}
[ExportArgumentProviderAttribute("ContextVariableArgumentProvider", "C#")]
[ExtensionOrderAttribute]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.CSharp.Completion.Providers.ContextVariableArgumentProvider : AbstractContextVariableArgumentProvider {
}
[ExportCompletionProviderAttribute("CrefCompletionProvider", "C#")]
[ExtensionOrderAttribute]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.CSharp.Completion.Providers.CrefCompletionProvider : AbstractCrefCompletionProvider {
    public static SymbolDisplayFormat QualifiedCrefFormat;
    public static SymbolDisplayFormat CrefFormat;
    public static SymbolDisplayFormat CrefFormatForSpecialTypes;
    private Action`1<SyntaxNode> _testSpeculativeNodeCallbackOpt;
    [CompilerGeneratedAttribute]
private ImmutableHashSet`1<char> <TriggerCharacters>k__BackingField;
    private static CharacterSetModificationRule s_WithoutOpenBrace;
    private static CharacterSetModificationRule s_WithoutOpenParen;
    private static string InsertionTextProperty;
    public ImmutableHashSet`1<char> TriggerCharacters { get; }
    private static CrefCompletionProvider();
    public virtual bool IsInsertionTrigger(SourceText text, int characterPosition, OptionSet options);
    [CompilerGeneratedAttribute]
public virtual ImmutableHashSet`1<char> get_TriggerCharacters();
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.CSharp.Completion.Providers.CrefCompletionProvider/<ProvideCompletionsAsync>d__9")]
public virtual Task ProvideCompletionsAsync(CompletionContext context);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.CSharp.Completion.Providers.CrefCompletionProvider/<GetSymbolsAsync>d__10")]
protected virtual Task`1<ValueTuple`3<SyntaxToken, SemanticModel, ImmutableArray`1<ISymbol>>> GetSymbolsAsync(Document document, int position, OptionSet options, CancellationToken cancellationToken);
    private static bool IsCrefStartContext(SyntaxToken token);
    private static bool IsCrefParameterListContext(SyntaxToken token);
    private static bool IsCrefQualifiedNameContext(SyntaxToken token);
    private static ImmutableArray`1<ISymbol> GetSymbols(SyntaxToken token, SemanticModel semanticModel, CancellationToken cancellationToken);
    private static ImmutableArray`1<ISymbol> GetUnqualifiedSymbols(SyntaxToken token, SemanticModel semanticModel, CancellationToken cancellationToken);
    private static ImmutableArray`1<ISymbol> GetQualifiedSymbols(QualifiedCrefSyntax parent, SyntaxToken token, SemanticModel semanticModel, CancellationToken cancellationToken);
    private static TextSpan GetCompletionItemSpan(SourceText text, int position);
    [IteratorStateMachineAttribute("Microsoft.CodeAnalysis.CSharp.Completion.Providers.CrefCompletionProvider/<CreateCompletionItems>d__18")]
private static IEnumerable`1<CompletionItem> CreateCompletionItems(SemanticModel semanticModel, ImmutableArray`1<ISymbol> symbols, SyntaxToken token, int position, ImmutableDictionary`2<string, string> options);
    private static bool TryCreateSpecialTypeItem(SemanticModel semanticModel, ISymbol symbol, SyntaxToken token, int position, StringBuilder builder, ImmutableDictionary`2<string, string> options, CompletionItem& item);
    private static CompletionItem CreateItem(SemanticModel semanticModel, ISymbol symbol, SyntaxToken token, int position, StringBuilder builder, ImmutableDictionary`2<string, string> options);
    private static CompletionItem CreateItem(SemanticModel semanticModel, ISymbol symbol, SyntaxToken token, int position, StringBuilder builder, ImmutableDictionary`2<string, string> options, SymbolDisplayFormat unqualifiedCrefFormat);
    private static CompletionItem CreateItemFromBuilder(ISymbol symbol, int position, StringBuilder builder, ImmutableDictionary`2<string, string> options);
    private static CompletionItemRules GetRules(string displayText);
    protected virtual Task`1<Nullable`1<TextChange>> GetTextChangeAsync(CompletionItem selectedItem, Nullable`1<char> ch, CancellationToken cancellationToken);
    internal TestAccessor GetTestAccessor();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExportCompletionProviderAttribute("CSharpSuggestionModeCompletionProvider", "C#")]
[ExtensionOrderAttribute]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.CSharp.Completion.Providers.CSharpSuggestionModeCompletionProvider : AbstractSuggestionModeCompletionProvider {
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.CSharp.Completion.Providers.CSharpSuggestionModeCompletionProvider/<GetSuggestionModeItemAsync>d__1")]
protected virtual Task`1<CompletionItem> GetSuggestionModeItemAsync(Document document, int position, TextSpan itemSpan, CompletionTrigger trigger, CancellationToken cancellationToken);
    private static bool IsAnonymousObjectCreation(SyntaxToken token);
    private static bool IsLambdaExpression(SemanticModel semanticModel, SyntaxTree tree, int position, SyntaxToken token, ITypeInferenceService typeInferrer, CancellationToken cancellationToken);
    private static ITypeSymbol GetDelegateType(TypeInferenceInfo typeInferenceInfo, Compilation compilation);
    private static bool IsPotentialPatternVariableDeclaration(SyntaxToken token);
}
[ExportCompletionProviderAttribute("DeclarationNameCompletionProvider", "C#")]
[ExtensionOrderAttribute]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.CSharp.Completion.Providers.DeclarationNameCompletionProvider : LSPCompletionProvider {
    [CompilerGeneratedAttribute]
private ImmutableHashSet`1<char> <TriggerCharacters>k__BackingField;
    public ImmutableHashSet`1<char> TriggerCharacters { get; }
    public virtual bool IsInsertionTrigger(SourceText text, int insertedCharacterPosition, OptionSet options);
    [CompilerGeneratedAttribute]
public virtual ImmutableHashSet`1<char> get_TriggerCharacters();
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.CSharp.Completion.Providers.DeclarationNameCompletionProvider/<ProvideCompletionsAsync>d__5")]
public virtual Task ProvideCompletionsAsync(CompletionContext completionContext);
    private ImmutableArray`1<ImmutableArray`1<string>> GetBaseNames(SemanticModel semanticModel, NameDeclarationInfo nameInfo);
    private static bool IsValidType(ITypeSymbol type);
    private static Glyph GetGlyph(SymbolKind kind, Nullable`1<Accessibility> declaredAccessibility);
    private ValueTuple`2<ITypeSymbol, bool> UnwrapType(ITypeSymbol type, Compilation compilation, bool wasPlural, HashSet`1<ITypeSymbol> seenTypes);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.CSharp.Completion.Providers.DeclarationNameCompletionProvider/<GetRecommendedNamesAsync>d__10")]
private static Task`1<ImmutableArray`1<ValueTuple`2<string, SymbolKind>>> GetRecommendedNamesAsync(ImmutableArray`1<ImmutableArray`1<string>> baseNames, NameDeclarationInfo declarationInfo, CSharpSyntaxContext context, Document document, CancellationToken cancellationToken);
    private static bool IsRelevantSymbolKind(ISymbol symbol);
    private static CompletionItem CreateCompletionItem(string name, Glyph glyph, string sortText);
    private static bool CanRemoveInterfacePrefix(string name);
}
[ExportArgumentProviderAttribute("DefaultArgumentProvider", "C#")]
[ExtensionOrderAttribute]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.CSharp.Completion.Providers.DefaultArgumentProvider : AbstractDefaultArgumentProvider {
    [NullableContextAttribute("1")]
public virtual Task ProvideArgumentAsync(ArgumentContext context);
}
internal static class Microsoft.CodeAnalysis.CSharp.Completion.Providers.DirectiveCompletionProviderUtilities : object {
    [NullableContextAttribute("1")]
internal static bool TryGetStringLiteralToken(SyntaxTree tree, int position, SyntaxKind directiveKind, SyntaxToken& stringLiteral, CancellationToken cancellationToken);
}
[ExportCompletionProviderAttribute("EmbeddedLanguageCompletionProvider", "C#")]
[ExtensionOrderAttribute]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.CSharp.Completion.Providers.EmbeddedLanguageCompletionProvider : AbstractEmbeddedLanguageCompletionProvider {
    [NullableContextAttribute("1")]
[ImportingConstructorAttribute]
[ObsoleteAttribute("This exported object must be obtained through the MEF export provider.", "True")]
public EmbeddedLanguageCompletionProvider(IEnumerable`1<Lazy`2<ILanguageService, LanguageServiceMetadata>> languageServices);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExportCompletionProviderAttribute("EnumAndCompletionListTagCompletionProvider", "C#")]
[ExtensionOrderAttribute]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.CSharp.Completion.Providers.EnumAndCompletionListTagCompletionProvider : LSPCompletionProvider {
    private static CompletionItemRules s_enumTypeRules;
    private static ImmutableHashSet`1<char> s_triggerCharacters;
    public ImmutableHashSet`1<char> TriggerCharacters { get; }
    private static EnumAndCompletionListTagCompletionProvider();
    public virtual bool IsInsertionTrigger(SourceText text, int characterPosition, OptionSet options);
    public virtual ImmutableHashSet`1<char> get_TriggerCharacters();
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.CSharp.Completion.Providers.EnumAndCompletionListTagCompletionProvider/<ProvideCompletionsAsync>d__6")]
public virtual Task ProvideCompletionsAsync(CompletionContext context);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.CSharp.Completion.Providers.EnumAndCompletionListTagCompletionProvider/<HandleSingleTypeAsync>d__7")]
private static Task HandleSingleTypeAsync(CompletionContext context, SemanticModel semanticModel, SyntaxToken token, ITypeSymbol type, CancellationToken cancellationToken);
    private static ITypeSymbol TryGetEnumTypeInEnumInitializer(SemanticModel semanticModel, SyntaxToken token, ITypeSymbol type, CancellationToken cancellationToken);
    protected virtual Task`1<CompletionDescription> GetDescriptionWorkerAsync(Document document, CompletionItem item, CancellationToken cancellationToken);
    private static INamedTypeSymbol TryGetCompletionListType(ITypeSymbol type, INamedTypeSymbol within, Compilation compilation);
    private static INamedTypeSymbol TryGetTypeWithStaticMembers(ITypeSymbol type);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExportCompletionProviderAttribute("ExplicitInterfaceMemberCompletionProvider", "C#")]
[SharedAttribute]
[ExtensionOrderAttribute]
internal class Microsoft.CodeAnalysis.CSharp.Completion.Providers.ExplicitInterfaceMemberCompletionProvider : LSPCompletionProvider {
    private static SymbolDisplayFormat s_signatureDisplayFormat;
    [CompilerGeneratedAttribute]
private ImmutableHashSet`1<char> <TriggerCharacters>k__BackingField;
    public ImmutableHashSet`1<char> TriggerCharacters { get; }
    private static ExplicitInterfaceMemberCompletionProvider();
    public virtual bool IsInsertionTrigger(SourceText text, int characterPosition, OptionSet options);
    [CompilerGeneratedAttribute]
public virtual ImmutableHashSet`1<char> get_TriggerCharacters();
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.CSharp.Completion.Providers.ExplicitInterfaceMemberCompletionProvider/<ProvideCompletionsAsync>d__6")]
public virtual Task ProvideCompletionsAsync(CompletionContext context);
    private static ValueTuple`2<string, string> SplitMemberName(string memberString);
    protected virtual Task`1<CompletionDescription> GetDescriptionWorkerAsync(Document document, CompletionItem item, CancellationToken cancellationToken);
    public virtual Task`1<Nullable`1<TextChange>> GetTextChangeAsync(Document document, CompletionItem selectedItem, Nullable`1<char> ch, CancellationToken cancellationToken);
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[ExportCompletionProviderAttribute("ExplicitInterfaceTypeCompletionProvider", "C#")]
[ExtensionOrderAttribute]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.CSharp.Completion.Providers.ExplicitInterfaceTypeCompletionProvider : AbstractSymbolCompletionProvider`1<CSharpSyntaxContext> {
    [CompilerGeneratedAttribute]
private ImmutableHashSet`1<char> <TriggerCharacters>k__BackingField;
    public ImmutableHashSet`1<char> TriggerCharacters { get; }
    public virtual bool IsInsertionTrigger(SourceText text, int insertedCharacterPosition, OptionSet options);
    [CompilerGeneratedAttribute]
public virtual ImmutableHashSet`1<char> get_TriggerCharacters();
    protected virtual ValueTuple`3<string, string, string> GetDisplayAndSuffixAndInsertionText(ISymbol symbol, CSharpSyntaxContext context);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.CSharp.Completion.Providers.ExplicitInterfaceTypeCompletionProvider/<ProvideCompletionsAsync>d__6")]
public virtual Task ProvideCompletionsAsync(CompletionContext context);
    protected virtual Task`1<ImmutableArray`1<ValueTuple`2<ISymbol, bool>>> GetSymbolsAsync(CompletionContext completionContext, CSharpSyntaxContext context, int position, OptionSet options, CancellationToken cancellationToken);
    private static bool IsPreviousTokenValid(SyntaxToken tokenBeforeType);
    private static bool IsClassOrStructOrInterfaceOrRecord(SyntaxNode node);
    [CompilerGeneratedAttribute]
[DebuggerHiddenAttribute]
private Task <>n__0(CompletionContext completionContext);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExportCompletionProviderAttribute("ExtensionMethodImportCompletionProvider", "C#")]
[ExtensionOrderAttribute]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.CSharp.Completion.Providers.ExtensionMethodImportCompletionProvider : AbstractExtensionMethodImportCompletionProvider {
    [CompilerGeneratedAttribute]
private ImmutableHashSet`1<char> <TriggerCharacters>k__BackingField;
    protected string GenericSuffix { get; }
    public ImmutableHashSet`1<char> TriggerCharacters { get; }
    protected virtual string get_GenericSuffix();
    public virtual bool IsInsertionTrigger(SourceText text, int characterPosition, OptionSet options);
    [CompilerGeneratedAttribute]
public virtual ImmutableHashSet`1<char> get_TriggerCharacters();
    protected virtual ImmutableArray`1<string> GetImportedNamespaces(SyntaxNode location, SemanticModel semanticModel, CancellationToken cancellationToken);
    protected virtual Task`1<SyntaxContext> CreateContextAsync(Document document, int position, bool usePartialSemantic, CancellationToken cancellationToken);
    protected virtual bool IsFinalSemicolonOfUsingOrExtern(SyntaxNode directive, SyntaxToken token);
    protected virtual Task`1<bool> ShouldProvideParenthesisCompletionAsync(Document document, CompletionItem item, Nullable`1<char> commitKey, CancellationToken cancellationToken);
}
[ExportCompletionProviderAttribute("ExternAliasCompletionProvider", "C#")]
[ExtensionOrderAttribute]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.CSharp.Completion.Providers.ExternAliasCompletionProvider : LSPCompletionProvider {
    [CompilerGeneratedAttribute]
private ImmutableHashSet`1<char> <TriggerCharacters>k__BackingField;
    public ImmutableHashSet`1<char> TriggerCharacters { get; }
    public virtual bool IsInsertionTrigger(SourceText text, int characterPosition, OptionSet options);
    [CompilerGeneratedAttribute]
public virtual ImmutableHashSet`1<char> get_TriggerCharacters();
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.CSharp.Completion.Providers.ExternAliasCompletionProvider/<ProvideCompletionsAsync>d__5")]
public virtual Task ProvideCompletionsAsync(CompletionContext context);
}
[ExportArgumentProviderAttribute("FirstBuiltInArgumentProvider", "C#")]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.CSharp.Completion.Providers.FirstBuiltInArgumentProvider : ArgumentProvider {
    [NullableContextAttribute("1")]
public virtual Task ProvideArgumentAsync(ArgumentContext context);
}
[ExportCompletionProviderAttribute("FirstBuiltInCompletionProvider", "C#")]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.CSharp.Completion.Providers.FirstBuiltInCompletionProvider : CompletionProvider {
    [NullableContextAttribute("1")]
public virtual Task ProvideCompletionsAsync(CompletionContext context);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExportCompletionProviderAttribute("FunctionPointerUnmanagedCallingConventionCompletionProvider", "C#")]
[ExtensionOrderAttribute]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.CSharp.Completion.Providers.FunctionPointerUnmanagedCallingConventionCompletionProvider : LSPCompletionProvider {
    [CompilerGeneratedAttribute]
private ImmutableHashSet`1<char> <TriggerCharacters>k__BackingField;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private static ImmutableArray`1<string> s_predefinedCallingConventions;
    public ImmutableHashSet`1<char> TriggerCharacters { get; }
    private static FunctionPointerUnmanagedCallingConventionCompletionProvider();
    public virtual bool IsInsertionTrigger(SourceText text, int characterPosition, OptionSet options);
    [CompilerGeneratedAttribute]
public virtual ImmutableHashSet`1<char> get_TriggerCharacters();
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.CSharp.Completion.Providers.FunctionPointerUnmanagedCallingConventionCompletionProvider/<ProvideCompletionsAsync>d__6")]
public virtual Task ProvideCompletionsAsync(CompletionContext context);
    private static void AddTypes(HashSet`1<CompletionItem> completionItems, int contextPosition, SemanticModel semanticModel, CancellationToken cancellationToken);
    protected virtual Task`1<CompletionDescription> GetDescriptionWorkerAsync(Document document, CompletionItem item, CancellationToken cancellationToken);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal static class Microsoft.CodeAnalysis.CSharp.Completion.Providers.ImportCompletionProviderHelper : object {
    public static ImmutableArray`1<string> GetImportedNamespaces(SyntaxNode location, SemanticModel semanticModel);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.CSharp.Completion.Providers.ImportCompletionProviderHelper/<CreateContextAsync>d__1")]
public static Task`1<SyntaxContext> CreateContextAsync(Document document, int position, bool usePartialSemantic, CancellationToken cancellationToken);
}
[ExportCompletionProviderAttribute("InternalsVisibleToCompletionProvider", "C#")]
[ExtensionOrderAttribute]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.CSharp.Completion.Providers.InternalsVisibleToCompletionProvider : AbstractInternalsVisibleToCompletionProvider {
    protected virtual IImmutableList`1<SyntaxNode> GetAssemblyScopedAttributeSyntaxNodesOfDocument(SyntaxNode documentRoot);
    protected virtual SyntaxNode GetConstructorArgumentOfInternalsVisibleToAttribute(SyntaxNode internalsVisibleToAttribute);
    protected virtual bool ShouldTriggerAfterQuotes(SourceText text, int insertedCharacterPosition);
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[ExportCompletionProviderAttribute("KeywordCompletionProvider", "C#")]
[ExtensionOrderAttribute]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.CSharp.Completion.Providers.KeywordCompletionProvider : AbstractKeywordCompletionProvider`1<CSharpSyntaxContext> {
    [CompilerGeneratedAttribute]
private ImmutableHashSet`1<char> <TriggerCharacters>k__BackingField;
    private static CompletionItemRules s_tupleRules;
    public ImmutableHashSet`1<char> TriggerCharacters { get; }
    private static KeywordCompletionProvider();
    public virtual bool IsInsertionTrigger(SourceText text, int characterPosition, OptionSet options);
    [CompilerGeneratedAttribute]
public virtual ImmutableHashSet`1<char> get_TriggerCharacters();
    protected virtual CompletionItem CreateItem(RecommendedKeyword keyword, CSharpSyntaxContext context, CancellationToken cancellationToken);
}
[ExportArgumentProviderAttribute("LastBuiltInArgumentProvider", "C#")]
[ExtensionOrderAttribute]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.CSharp.Completion.Providers.LastBuiltInArgumentProvider : ArgumentProvider {
    [NullableContextAttribute("1")]
public virtual Task ProvideArgumentAsync(ArgumentContext context);
}
[ExportCompletionProviderAttribute("LastBuiltInCompletionProvider", "C#")]
[ExtensionOrderAttribute]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.CSharp.Completion.Providers.LastBuiltInCompletionProvider : CompletionProvider {
    [NullableContextAttribute("1")]
public virtual Task ProvideCompletionsAsync(CompletionContext context);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExportCompletionProviderAttribute("LoadDirectiveCompletionProvider", "C#")]
[ExtensionOrderAttribute]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.CSharp.Completion.Providers.LoadDirectiveCompletionProvider : AbstractLoadDirectiveCompletionProvider {
    protected string DirectiveName { get; }
    protected virtual string get_DirectiveName();
    protected virtual bool TryGetStringLiteralToken(SyntaxTree tree, int position, SyntaxToken& stringLiteral, CancellationToken cancellationToken);
}
[ExportCompletionProviderAttribute("NamedParameterCompletionProvider", "C#")]
[ExtensionOrderAttribute]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.CSharp.Completion.Providers.NamedParameterCompletionProvider : LSPCompletionProvider {
    private static string ColonString;
    private static CompletionItemRules s_rules;
    [CompilerGeneratedAttribute]
private ImmutableHashSet`1<char> <TriggerCharacters>k__BackingField;
    public ImmutableHashSet`1<char> TriggerCharacters { get; }
    private static NamedParameterCompletionProvider();
    public virtual bool IsInsertionTrigger(SourceText text, int characterPosition, OptionSet options);
    [CompilerGeneratedAttribute]
public virtual ImmutableHashSet`1<char> get_TriggerCharacters();
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.CSharp.Completion.Providers.NamedParameterCompletionProvider/<ProvideCompletionsAsync>d__7")]
public virtual Task ProvideCompletionsAsync(CompletionContext context);
    protected virtual Task`1<CompletionDescription> GetDescriptionWorkerAsync(Document document, CompletionItem item, CancellationToken cancellationToken);
    private static bool IsValid(ImmutableArray`1<IParameterSymbol> parameterList, ISet`1<string> existingNamedParameters);
    private static ISet`1<string> GetExistingNamedParameters(BaseArgumentListSyntax argumentList, int position);
    private static IEnumerable`1<ImmutableArray`1<IParameterSymbol>> GetParameterLists(SemanticModel semanticModel, int position, SyntaxNode invocableNode, CancellationToken cancellationToken);
    private static IEnumerable`1<ImmutableArray`1<IParameterSymbol>> GetObjectCreationExpressionParameterLists(SemanticModel semanticModel, int position, BaseObjectCreationExpressionSyntax objectCreationExpression, CancellationToken cancellationToken);
    private static IEnumerable`1<ImmutableArray`1<IParameterSymbol>> GetElementAccessExpressionParameterLists(SemanticModel semanticModel, int position, ElementAccessExpressionSyntax elementAccessExpression, CancellationToken cancellationToken);
    private static IEnumerable`1<ImmutableArray`1<IParameterSymbol>> GetConstructorInitializerParameterLists(SemanticModel semanticModel, int position, ConstructorInitializerSyntax constructorInitializer, CancellationToken cancellationToken);
    private static IEnumerable`1<ImmutableArray`1<IParameterSymbol>> GetRecordBaseTypeParameterLists(SemanticModel semanticModel, int position, PrimaryConstructorBaseTypeSyntax recordBaseType, CancellationToken cancellationToken);
    private static IEnumerable`1<ImmutableArray`1<IParameterSymbol>> GetInvocationExpressionParameterLists(SemanticModel semanticModel, int position, InvocationExpressionSyntax invocationExpression, CancellationToken cancellationToken);
    private sealed virtual override bool System.Collections.Generic.IEqualityComparer<Microsoft.CodeAnalysis.IParameterSymbol>.Equals(IParameterSymbol x, IParameterSymbol y);
    private sealed virtual override int System.Collections.Generic.IEqualityComparer<Microsoft.CodeAnalysis.IParameterSymbol>.GetHashCode(IParameterSymbol obj);
    protected virtual Task`1<Nullable`1<TextChange>> GetTextChangeAsync(CompletionItem selectedItem, Nullable`1<char> ch, CancellationToken cancellationToken);
}
[ExportCompletionProviderAttribute("ObjectAndWithInitializerCompletionProvider", "C#")]
[ExtensionOrderAttribute]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.CSharp.Completion.Providers.ObjectAndWithInitializerCompletionProvider : AbstractObjectInitializerCompletionProvider {
    [CompilerGeneratedAttribute]
private ImmutableHashSet`1<char> <TriggerCharacters>k__BackingField;
    public ImmutableHashSet`1<char> TriggerCharacters { get; }
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.CSharp.Completion.Providers.ObjectAndWithInitializerCompletionProvider/<IsExclusiveAsync>d__1")]
protected virtual Task`1<bool> IsExclusiveAsync(Document document, int position, CancellationToken cancellationToken);
    public virtual bool IsInsertionTrigger(SourceText text, int characterPosition, OptionSet options);
    [CompilerGeneratedAttribute]
public virtual ImmutableHashSet`1<char> get_TriggerCharacters();
    protected virtual Tuple`2<ITypeSymbol, Location> GetInitializedType(Document document, SemanticModel semanticModel, int position, CancellationToken cancellationToken);
    private static ITypeSymbol GetInitializedType(SyntaxToken token, Document document, SemanticModel semanticModel, CancellationToken cancellationToken);
    protected virtual HashSet`1<string> GetInitializedMembers(SyntaxTree tree, int position, CancellationToken cancellationToken);
    protected virtual bool IsInitializable(ISymbol member, INamedTypeSymbol containingType);
    protected virtual string EscapeIdentifier(ISymbol symbol);
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[ExportCompletionProviderAttribute("ObjectCreationCompletionProvider", "C#")]
[ExtensionOrderAttribute]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.CSharp.Completion.Providers.ObjectCreationCompletionProvider : AbstractObjectCreationCompletionProvider`1<CSharpSyntaxContext> {
    [CompilerGeneratedAttribute]
private ImmutableHashSet`1<char> <TriggerCharacters>k__BackingField;
    private static CompletionItemRules s_arrayRules;
    private static CompletionItemRules s_objectRules;
    private static CompletionItemRules s_defaultRules;
    public ImmutableHashSet`1<char> TriggerCharacters { get; }
    private static ObjectCreationCompletionProvider();
    public virtual bool IsInsertionTrigger(SourceText text, int characterPosition, OptionSet options);
    [CompilerGeneratedAttribute]
public virtual ImmutableHashSet`1<char> get_TriggerCharacters();
    protected virtual SyntaxNode GetObjectCreationNewExpression(SyntaxTree tree, int position, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.CSharp.Completion.Providers.ObjectCreationCompletionProvider/<GetSymbolsAsync>d__6")]
protected virtual Task`1<ImmutableArray`1<ValueTuple`2<ISymbol, bool>>> GetSymbolsAsync(CompletionContext completionContext, CSharpSyntaxContext context, int position, OptionSet options, CancellationToken cancellationToken);
    protected virtual ValueTuple`3<string, string, string> GetDisplayAndSuffixAndInsertionText(ISymbol symbol, CSharpSyntaxContext context);
    protected virtual CompletionItemRules GetCompletionItemRules(ImmutableArray`1<ValueTuple`2<ISymbol, bool>> symbols);
    protected virtual string GetInsertionText(CompletionItem item, char ch);
    [CompilerGeneratedAttribute]
[DebuggerHiddenAttribute]
private Task`1<ImmutableArray`1<ValueTuple`2<ISymbol, bool>>> <>n__0(CompletionContext completionContext, CSharpSyntaxContext context, int position, OptionSet options, CancellationToken cancellationToken);
}
[ExportCompletionProviderAttribute("OverrideCompletionProvider", "C#")]
[ExtensionOrderAttribute]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.CSharp.Completion.Providers.OverrideCompletionProvider : AbstractOverrideCompletionProvider {
    [CompilerGeneratedAttribute]
private ImmutableHashSet`1<char> <TriggerCharacters>k__BackingField;
    public ImmutableHashSet`1<char> TriggerCharacters { get; }
    protected virtual SyntaxNode GetSyntax(SyntaxToken token);
    public virtual bool IsInsertionTrigger(SourceText text, int characterPosition, OptionSet options);
    [CompilerGeneratedAttribute]
public virtual ImmutableHashSet`1<char> get_TriggerCharacters();
    protected virtual SyntaxToken GetToken(CompletionItem completionItem, SyntaxTree tree, CancellationToken cancellationToken);
    public virtual bool TryDetermineReturnType(SyntaxToken startToken, SemanticModel semanticModel, CancellationToken cancellationToken, ITypeSymbol& returnType, SyntaxToken& nextToken);
    public virtual bool TryDetermineModifiers(SyntaxToken startToken, SourceText text, int startLine, Accessibility& seenAccessibility, DeclarationModifiers& modifiers);
    public virtual SyntaxToken FindStartingToken(SyntaxTree tree, int position, CancellationToken cancellationToken);
    public virtual ImmutableArray`1<ISymbol> FilterOverrides(ImmutableArray`1<ISymbol> members, ITypeSymbol returnType);
    protected virtual int GetTargetCaretPosition(SyntaxNode caretTarget);
}
[ExportCompletionProviderAttribute("PartialMethodCompletionProvider", "C#")]
[ExtensionOrderAttribute]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.CSharp.Completion.Providers.PartialMethodCompletionProvider : AbstractPartialMethodCompletionProvider {
    [CompilerGeneratedAttribute]
private ImmutableHashSet`1<char> <TriggerCharacters>k__BackingField;
    public ImmutableHashSet`1<char> TriggerCharacters { get; }
    protected virtual bool IncludeAccessibility(IMethodSymbol method, CancellationToken cancellationToken);
    protected virtual SyntaxNode GetSyntax(SyntaxToken token);
    protected virtual int GetTargetCaretPosition(SyntaxNode caretTarget);
    protected virtual SyntaxToken GetToken(CompletionItem completionItem, SyntaxTree tree, CancellationToken cancellationToken);
    public virtual bool IsInsertionTrigger(SourceText text, int characterPosition, OptionSet options);
    [CompilerGeneratedAttribute]
public virtual ImmutableHashSet`1<char> get_TriggerCharacters();
    protected virtual bool IsPartial(IMethodSymbol method);
    protected virtual bool IsPartialMethodCompletionContext(SyntaxTree tree, int position, CancellationToken cancellationToken, DeclarationModifiers& modifiers, SyntaxToken& token);
    private static bool VerifyModifiers(SyntaxTree tree, int position, CancellationToken cancellationToken, DeclarationModifiers& modifiers);
    private static bool IsOnSameLine(SyntaxToken syntaxToken, SyntaxToken touchingToken, SourceText text);
    protected virtual string GetDisplayText(IMethodSymbol method, SemanticModel semanticModel, int position);
}
[ExportCompletionProviderAttribute("PartialTypeCompletionProvider", "C#")]
[ExtensionOrderAttribute]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.CSharp.Completion.Providers.PartialTypeCompletionProvider : AbstractPartialTypeCompletionProvider`1<CSharpSyntaxContext> {
    private static string InsertionTextOnLessThan;
    private static SymbolDisplayFormat _symbolFormatWithGenerics;
    private static SymbolDisplayFormat _symbolFormatWithoutGenerics;
    [CompilerGeneratedAttribute]
private ImmutableHashSet`1<char> <TriggerCharacters>k__BackingField;
    public ImmutableHashSet`1<char> TriggerCharacters { get; }
    private static PartialTypeCompletionProvider();
    public virtual bool IsInsertionTrigger(SourceText text, int characterPosition, OptionSet options);
    [CompilerGeneratedAttribute]
public virtual ImmutableHashSet`1<char> get_TriggerCharacters();
    protected virtual SyntaxNode GetPartialTypeSyntaxNode(SyntaxTree tree, int position, CancellationToken cancellationToken);
    protected virtual ValueTuple`3<string, string, string> GetDisplayAndSuffixAndInsertionText(INamedTypeSymbol symbol, CSharpSyntaxContext context);
    protected virtual IEnumerable`1<INamedTypeSymbol> LookupCandidateSymbols(CSharpSyntaxContext context, INamedTypeSymbol declaredSymbol, CancellationToken cancellationToken);
    private static bool IsPartialTypeDeclaration(SyntaxNode syntax);
    protected virtual ImmutableDictionary`2<string, string> GetProperties(INamedTypeSymbol symbol, CSharpSyntaxContext context);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.CSharp.Completion.Providers.PartialTypeCompletionProvider/<GetTextChangeAsync>d__13")]
public virtual Task`1<Nullable`1<TextChange>> GetTextChangeAsync(Document document, CompletionItem selectedItem, Nullable`1<char> ch, CancellationToken cancellationToken);
    [CompilerGeneratedAttribute]
[DebuggerHiddenAttribute]
private Task`1<Nullable`1<TextChange>> <>n__0(Document document, CompletionItem selectedItem, Nullable`1<char> ch, CancellationToken cancellationToken);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExportCompletionProviderAttribute("PreprocessorCompletionProvider", "C#")]
[ExtensionOrderAttribute]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.CSharp.Completion.Providers.PreprocessorCompletionProvider : AbstractPreprocessorCompletionProvider {
    [CompilerGeneratedAttribute]
private ImmutableHashSet`1<char> <TriggerCharacters>k__BackingField;
    public ImmutableHashSet`1<char> TriggerCharacters { get; }
    public virtual bool IsInsertionTrigger(SourceText text, int characterPosition, OptionSet options);
    [CompilerGeneratedAttribute]
public virtual ImmutableHashSet`1<char> get_TriggerCharacters();
}
[ExportCompletionProviderAttribute("PropertySubpatternCompletionProvider", "C#")]
[ExtensionOrderAttribute]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.CSharp.Completion.Providers.PropertySubpatternCompletionProvider : LSPCompletionProvider {
    private static CompletionItemRules s_rules;
    [CompilerGeneratedAttribute]
private ImmutableHashSet`1<char> <TriggerCharacters>k__BackingField;
    public ImmutableHashSet`1<char> TriggerCharacters { get; }
    private static PropertySubpatternCompletionProvider();
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.CSharp.Completion.Providers.PropertySubpatternCompletionProvider/<ProvideCompletionsAsync>d__1")]
public virtual Task ProvideCompletionsAsync(CompletionContext context);
    private static bool IsFieldOrReadableProperty(ISymbol symbol);
    protected virtual Task`1<CompletionDescription> GetDescriptionWorkerAsync(Document document, CompletionItem item, CancellationToken cancellationToken);
    public virtual bool IsInsertionTrigger(SourceText text, int characterPosition, OptionSet options);
    [CompilerGeneratedAttribute]
public virtual ImmutableHashSet`1<char> get_TriggerCharacters();
    private static SyntaxToken TryGetOpenBraceOrCommaInPropertyPatternClause(SyntaxTree tree, int position, CancellationToken cancellationToken);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExportCompletionProviderAttribute("ReferenceDirectiveCompletionProvider", "C#")]
[ExtensionOrderAttribute]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.CSharp.Completion.Providers.ReferenceDirectiveCompletionProvider : AbstractReferenceDirectiveCompletionProvider {
    protected string DirectiveName { get; }
    protected virtual string get_DirectiveName();
    protected virtual bool TryGetStringLiteralToken(SyntaxTree tree, int position, SyntaxToken& stringLiteral, CancellationToken cancellationToken);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExportCompletionProviderAttribute("SnippetCompletionProvider", "C#")]
[ExtensionOrderAttribute]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.CSharp.Completion.Providers.SnippetCompletionProvider : LSPCompletionProvider {
    [CompilerGeneratedAttribute]
private ImmutableHashSet`1<char> <TriggerCharacters>k__BackingField;
    private static CompletionItemRules s_tupleRules;
    internal bool IsSnippetProvider { get; }
    public ImmutableHashSet`1<char> TriggerCharacters { get; }
    private static SnippetCompletionProvider();
    internal virtual bool get_IsSnippetProvider();
    public virtual bool IsInsertionTrigger(SourceText text, int characterPosition, OptionSet options);
    [CompilerGeneratedAttribute]
public virtual ImmutableHashSet`1<char> get_TriggerCharacters();
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.CSharp.Completion.Providers.SnippetCompletionProvider/<ProvideCompletionsAsync>d__7")]
public virtual Task ProvideCompletionsAsync(CompletionContext context);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.CSharp.Completion.Providers.SnippetCompletionProvider/<GetSnippetsForDocumentAsync>d__8")]
private static Task`1<ImmutableArray`1<CompletionItem>> GetSnippetsForDocumentAsync(Document document, int position, CancellationToken cancellationToken);
    private static ImmutableArray`1<CompletionItem> GetSnippetCompletionItems(Workspace workspace, SemanticModel semanticModel, bool isPreProcessorContext, bool isTupleContext, CancellationToken cancellationToken);
}
[ExportCompletionProviderAttribute("SpeculativeTCompletionProvider", "C#")]
[ExtensionOrderAttribute]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.CSharp.Completion.Providers.SpeculativeTCompletionProvider : LSPCompletionProvider {
    [CompilerGeneratedAttribute]
private ImmutableHashSet`1<char> <TriggerCharacters>k__BackingField;
    public ImmutableHashSet`1<char> TriggerCharacters { get; }
    public virtual bool IsInsertionTrigger(SourceText text, int characterPosition, OptionSet options);
    [CompilerGeneratedAttribute]
public virtual ImmutableHashSet`1<char> get_TriggerCharacters();
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.CSharp.Completion.Providers.SpeculativeTCompletionProvider/<ProvideCompletionsAsync>d__5")]
public virtual Task ProvideCompletionsAsync(CompletionContext context);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.CSharp.Completion.Providers.SpeculativeTCompletionProvider/<ShouldShowSpeculativeTCompletionItemAsync>d__6")]
private static Task`1<bool> ShouldShowSpeculativeTCompletionItemAsync(Document document, int position, CancellationToken cancellationToken);
    private static bool IsStartOfSpeculativeTContext(SyntaxTree syntaxTree, int position, CancellationToken cancellationToken);
    private static int WalkOutOfGenericType(SyntaxTree syntaxTree, int position, SemanticModel semanticModel, CancellationToken cancellationToken);
    private static int WalkOutOfRefType(SyntaxTree syntaxTree, int position, CancellationToken cancellationToken);
    private static int WalkOutOfTupleType(SyntaxTree syntaxTree, int position, CancellationToken cancellationToken);
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[ExportCompletionProviderAttribute("SymbolCompletionProvider", "C#")]
[ExtensionOrderAttribute]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.CSharp.Completion.Providers.SymbolCompletionProvider : AbstractRecommendationServiceBasedCompletionProvider`1<CSharpSyntaxContext> {
    [TupleElementNamesAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private static Dictionary`2<ValueTuple`3<bool, bool, bool>, CompletionItemRules> s_cachedRules;
    [CompilerGeneratedAttribute]
private ImmutableHashSet`1<char> <TriggerCharacters>k__BackingField;
    protected CompletionItemSelectionBehavior PreselectedItemSelectionBehavior { get; }
    public ImmutableHashSet`1<char> TriggerCharacters { get; }
    private static SymbolCompletionProvider();
    protected virtual CompletionItemSelectionBehavior get_PreselectedItemSelectionBehavior();
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.CSharp.Completion.Providers.SymbolCompletionProvider/<ShouldPreselectInferredTypesAsync>d__5")]
protected virtual Task`1<bool> ShouldPreselectInferredTypesAsync(CompletionContext context, int position, OptionSet options, CancellationToken cancellationToken);
    protected virtual bool IsInstrinsic(ISymbol s);
    public virtual bool IsInsertionTrigger(SourceText text, int characterPosition, OptionSet options);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.CSharp.Completion.Providers.SymbolCompletionProvider/<IsSyntacticTriggerCharacterAsync>d__8")]
internal virtual Task`1<bool> IsSyntacticTriggerCharacterAsync(Document document, int caretPosition, CompletionTrigger trigger, OptionSet options, CancellationToken cancellationToken);
    [CompilerGeneratedAttribute]
public virtual ImmutableHashSet`1<char> get_TriggerCharacters();
    private static bool ShouldTriggerInArgumentLists(OptionSet options);
    protected virtual bool IsTriggerOnDot(SyntaxToken token, int characterPosition);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.CSharp.Completion.Providers.SymbolCompletionProvider/<IsTriggerInArgumentListAsync>d__14")]
private static Task`1<Nullable`1<bool>> IsTriggerInArgumentListAsync(Document document, int characterPosition, CancellationToken cancellationToken);
    protected virtual ValueTuple`3<string, string, string> GetDisplayAndSuffixAndInsertionText(ISymbol symbol, CSharpSyntaxContext context);
    protected virtual CompletionItemRules GetCompletionItemRules(ImmutableArray`1<ValueTuple`2<ISymbol, bool>> symbols, CSharpSyntaxContext context);
    protected virtual CompletionItem CreateItem(CompletionContext completionContext, string displayText, string displayTextSuffix, string insertionText, ImmutableArray`1<ValueTuple`2<ISymbol, bool>> symbols, CSharpSyntaxContext context, SupportedPlatformData supportedPlatformData);
    protected virtual string GetInsertionText(CompletionItem item, char ch);
    [NullableContextAttribute("0")]
[CompilerGeneratedAttribute]
internal static CompletionItemRules <.cctor>g__MakeRule|1_0(ValueTuple`3<bool, bool, bool> context);
}
[ExportCompletionProviderAttribute("TupleNameCompletionProvider", "C#")]
[ExtensionOrderAttribute]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.CSharp.Completion.Providers.TupleNameCompletionProvider : LSPCompletionProvider {
    private static string ColonString;
    public ImmutableHashSet`1<char> TriggerCharacters { get; }
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.CSharp.Completion.Providers.TupleNameCompletionProvider/<ProvideCompletionsAsync>d__2")]
public virtual Task ProvideCompletionsAsync(CompletionContext completionContext);
    private static Nullable`1<int> GetElementIndex(CSharpSyntaxContext context);
    private static void AddItems(ImmutableArray`1<INamedTypeSymbol> inferredTypes, int index, CompletionContext context, int spanStart);
    protected virtual Task`1<Nullable`1<TextChange>> GetTextChangeAsync(CompletionItem selectedItem, Nullable`1<char> ch, CancellationToken cancellationToken);
    public virtual ImmutableHashSet`1<char> get_TriggerCharacters();
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[ExportCompletionProviderAttribute("TypeImportCompletionProvider", "C#")]
[ExtensionOrderAttribute]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.CSharp.Completion.Providers.TypeImportCompletionProvider : AbstractTypeImportCompletionProvider`1<UsingDirectiveSyntax> {
    [CompilerGeneratedAttribute]
private ImmutableHashSet`1<char> <TriggerCharacters>k__BackingField;
    public ImmutableHashSet`1<char> TriggerCharacters { get; }
    public virtual bool IsInsertionTrigger(SourceText text, int characterPosition, OptionSet options);
    [CompilerGeneratedAttribute]
public virtual ImmutableHashSet`1<char> get_TriggerCharacters();
    protected virtual ImmutableArray`1<string> GetImportedNamespaces(SyntaxNode location, SemanticModel semanticModel, CancellationToken cancellationToken);
    protected virtual Task`1<SyntaxContext> CreateContextAsync(Document document, int position, bool usePartialSemantic, CancellationToken cancellationToken);
    protected virtual bool IsFinalSemicolonOfUsingOrExtern(SyntaxNode directive, SyntaxToken token);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.CSharp.Completion.Providers.TypeImportCompletionProvider/<ShouldProvideParenthesisCompletionAsync>d__8")]
protected virtual Task`1<bool> ShouldProvideParenthesisCompletionAsync(Document document, CompletionItem item, Nullable`1<char> commitKey, CancellationToken cancellationToken);
    protected virtual ImmutableArray`1<UsingDirectiveSyntax> GetAliasDeclarationNodes(SyntaxNode node);
}
[ExportLanguageServiceFactoryAttribute("Microsoft.CodeAnalysis.Completion.Providers.ImportCompletion.ITypeImportCompletionService", "C#", "Default")]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.CSharp.Completion.Providers.TypeImportCompletionServiceFactory : object {
    [NullableContextAttribute("1")]
public sealed virtual ILanguageService CreateLanguageService(HostLanguageServices languageServices);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExportCompletionProviderAttribute("UnnamedSymbolCompletionProvider", "C#")]
[SharedAttribute]
[ExtensionOrderAttribute]
internal class Microsoft.CodeAnalysis.CSharp.Completion.Providers.UnnamedSymbolCompletionProvider : LSPCompletionProvider {
    private static string SortingPrefix;
    internal static string KindName;
    internal static string IndexerKindName;
    internal static string OperatorKindName;
    internal static string ConversionKindName;
    private static string DocumentationCommentXmlName;
    private int ConversionSortingGroupIndex;
    private static string RehydrateName;
    private static ImmutableDictionary`2<string, string> ConversionProperties;
    private ImmutableDictionary`2<string, string> IndexerProperties;
    private int OperatorSortingGroupIndex;
    private string OperatorName;
    private ImmutableDictionary`2<string, string> OperatorProperties;
    [TupleElementNamesAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private static ImmutableArray`1<ValueTuple`2<string, OperatorPosition>> s_operatorInfo;
    [TupleElementNamesAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private static Dictionary`2<string, ValueTuple`2<int, OperatorPosition>> s_operatorNameToInfo;
    private static CompletionItemRules s_operatorRules;
    public ImmutableHashSet`1<char> TriggerCharacters { get; }
    private static UnnamedSymbolCompletionProvider();
    public virtual ImmutableHashSet`1<char> get_TriggerCharacters();
    public virtual bool IsInsertionTrigger(SourceText text, int insertedCharacterPosition, OptionSet options);
    private static string SortText(int sortingGroupIndex, string sortTextSymbolPart);
    [NullableContextAttribute("0")]
private static ValueTuple`2<SyntaxToken, int> GetDotAndExpressionStart(SyntaxNode root, int position);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.CSharp.Completion.Providers.UnnamedSymbolCompletionProvider/<ProvideCompletionsAsync>d__12")]
public virtual Task ProvideCompletionsAsync(CompletionContext context);
    private void AddUnnamedSymbols(CompletionContext context, int position, SemanticModel semanticModel, ImmutableArray`1<ISymbol> unnamedSymbols, CancellationToken cancellationToken);
    internal virtual Task`1<CompletionChange> GetChangeAsync(Document document, CompletionItem item, TextSpan completionListSpan, Nullable`1<char> commitKey, bool disallowAddingImports, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.CSharp.Completion.Providers.UnnamedSymbolCompletionProvider/<GetDescriptionAsync>d__15")]
public virtual Task`1<CompletionDescription> GetDescriptionAsync(Document document, CompletionItem item, CancellationToken cancellationToken);
    private static Task`1<CompletionChange> ReplaceTextAfterOperatorAsync(Document document, CompletionItem item, string text, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.CSharp.Completion.Providers.UnnamedSymbolCompletionProvider/<ReplaceTextAfterOperatorAsync>d__17")]
private static Task`1<CompletionChange> ReplaceTextAfterOperatorAsync(Document document, CompletionItem item, string text, bool keepQuestion, int positionOffset, CancellationToken cancellationToken);
    private void AddConversion(CompletionContext context, SemanticModel semanticModel, int position, IMethodSymbol conversion);
    private static ValueTuple`2<ImmutableArray`1<ISymbol>, ImmutableDictionary`2<string, string>> GetConversionSymbolsAndProperties(CompletionContext context, IMethodSymbol conversion);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.CSharp.Completion.Providers.UnnamedSymbolCompletionProvider/<GetConversionChangeAsync>d__23")]
private static Task`1<CompletionChange> GetConversionChangeAsync(Document document, CompletionItem item, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.CSharp.Completion.Providers.UnnamedSymbolCompletionProvider/<GetConversionDescriptionAsync>d__24")]
private static Task`1<CompletionDescription> GetConversionDescriptionAsync(Document document, CompletionItem item, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.CSharp.Completion.Providers.UnnamedSymbolCompletionProvider/<TryRehydrateAsync>d__25")]
private static Task`1<ISymbol> TryRehydrateAsync(Document document, CompletionItem item, CancellationToken cancellationToken);
    private void AddIndexers(CompletionContext context, ImmutableArray`1<ISymbol> indexers);
    private static Task`1<CompletionChange> GetIndexerChangeAsync(Document document, CompletionItem item, CancellationToken cancellationToken);
    private static Task`1<CompletionDescription> GetIndexerDescriptionAsync(Document document, CompletionItem item, CancellationToken cancellationToken);
    private void AddOperatorGroup(CompletionContext context, string opName, IEnumerable`1<ISymbol> operators);
    private static string GetOperatorText(string opName);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.CSharp.Completion.Providers.UnnamedSymbolCompletionProvider/<GetOperatorChangeAsync>d__40")]
private Task`1<CompletionChange> GetOperatorChangeAsync(Document document, CompletionItem item, CancellationToken cancellationToken);
    private static OperatorPosition GetOperatorPosition(string operatorName);
    private static Task`1<CompletionDescription> GetOperatorDescriptionAsync(Document document, CompletionItem item, CancellationToken cancellationToken);
    private static string GetOperatorInlineDescription(string opName);
}
[ExportCompletionProviderAttribute("XmlDocCommentCompletionProvider", "C#")]
[ExtensionOrderAttribute]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.CSharp.Completion.Providers.XmlDocCommentCompletionProvider : AbstractDocCommentCompletionProvider`1<DocumentationCommentTriviaSyntax> {
    [CompilerGeneratedAttribute]
private ImmutableHashSet`1<char> <TriggerCharacters>k__BackingField;
    private static CompletionItemRules s_defaultRules;
    public ImmutableHashSet`1<char> TriggerCharacters { get; }
    private static XmlDocCommentCompletionProvider();
    public virtual bool IsInsertionTrigger(SourceText text, int characterPosition, OptionSet options);
    [CompilerGeneratedAttribute]
public virtual ImmutableHashSet`1<char> get_TriggerCharacters();
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.CSharp.Completion.Providers.XmlDocCommentCompletionProvider/<GetItemsWorkerAsync>d__5")]
protected virtual Task`1<IEnumerable`1<CompletionItem>> GetItemsWorkerAsync(Document document, int position, CompletionTrigger trigger, CancellationToken cancellationToken);
    private void AddXmlElementItems(List`1<CompletionItem> items, XmlElementStartTagSyntax startTag);
    private bool IsAttributeNameContext(SyntaxToken token, int position, String& elementName, ISet`1& attributeNames);
    private ValueTuple`2<string, SyntaxList`1<XmlAttributeSyntax>> GetElementNameAndAttributes(SyntaxNode node);
    private static bool IsAttributeValueContext(SyntaxToken token, String& tagName, String& attributeName);
    [IteratorStateMachineAttribute("Microsoft.CodeAnalysis.CSharp.Completion.Providers.XmlDocCommentCompletionProvider/<GetKeywordNames>d__10")]
protected virtual IEnumerable`1<string> GetKeywordNames();
    protected virtual IEnumerable`1<string> GetExistingTopLevelElementNames(DocumentationCommentTriviaSyntax syntax);
    protected virtual IEnumerable`1<string> GetExistingTopLevelAttributeValues(DocumentationCommentTriviaSyntax syntax, string elementName, string attributeName);
    private string GetElementName(XmlNodeSyntax node);
    private string GetAttributeName(XmlAttributeSyntax attribute);
    private string GetAttributeValue(XmlAttributeSyntax attribute);
}
[ExportCodeFixProviderAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.CSharp.ConflictMarkerResolution.CSharpResolveConflictMarkerCodeFixProvider : AbstractResolveConflictMarkerCodeFixProvider {
    [NullableAttribute("1")]
private static string CS8300;
}
[ExtensionOrderAttribute]
[ExportCodeRefactoringProviderAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.CSharp.ConvertAnonymousTypeToClass.CSharpConvertAnonymousTypeToClassCodeRefactoringProvider : AbstractConvertAnonymousTypeToClassCodeRefactoringProvider`6<ExpressionSyntax, NameSyntax, IdentifierNameSyntax, ObjectCreationExpressionSyntax, AnonymousObjectCreationExpressionSyntax, NamespaceDeclarationSyntax> {
    protected virtual ObjectCreationExpressionSyntax CreateObjectCreationExpression(NameSyntax nameNode, AnonymousObjectCreationExpressionSyntax anonymousObject);
    private ArgumentListSyntax CreateArgumentList(AnonymousObjectCreationExpressionSyntax anonymousObject);
    private SeparatedSyntaxList`1<ArgumentSyntax> CreateArguments(SeparatedSyntaxList`1<AnonymousObjectMemberDeclaratorSyntax> initializers);
    private static SyntaxNodeOrTokenList OmitTrailingComma(SyntaxNodeOrTokenList list);
    private SyntaxNodeOrTokenList CreateArguments(SyntaxNodeOrTokenList list);
    private SyntaxNodeOrToken CreateArgumentOrComma(SyntaxNodeOrToken declOrComma);
    private static ArgumentSyntax CreateArgument(AnonymousObjectMemberDeclaratorSyntax decl);
}
[ExportCodeFixProviderAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.CSharp.ConvertAnonymousTypeToTuple.CSharpConvertAnonymousTypeToTupleCodeFixProvider : AbstractConvertAnonymousTypeToTupleCodeFixProvider`3<ExpressionSyntax, TupleExpressionSyntax, AnonymousObjectCreationExpressionSyntax> {
    protected virtual TupleExpressionSyntax ConvertToTuple(AnonymousObjectCreationExpressionSyntax anonCreation);
    private static SeparatedSyntaxList`1<ArgumentSyntax> ConvertInitializers(SeparatedSyntaxList`1<AnonymousObjectMemberDeclaratorSyntax> initializers);
    private static ArgumentSyntax ConvertInitializer(AnonymousObjectMemberDeclaratorSyntax declarator);
    private static NameColonSyntax ConvertName(NameEqualsSyntax nameEquals);
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
internal class Microsoft.CodeAnalysis.CSharp.ConvertAnonymousTypeToTuple.CSharpConvertAnonymousTypeToTupleDiagnosticAnalyzer : AbstractConvertAnonymousTypeToTupleDiagnosticAnalyzer`2<SyntaxKind, AnonymousObjectCreationExpressionSyntax> {
    protected virtual int GetInitializerCount(AnonymousObjectCreationExpressionSyntax anonymousType);
}
[ExportCodeRefactoringProviderAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.CSharp.ConvertAutoPropertyToFullProperty.CSharpConvertAutoPropertyToFullPropertyCodeRefactoringProvider : AbstractConvertAutoPropertyToFullPropertyCodeRefactoringProvider`2<PropertyDeclarationSyntax, TypeDeclarationSyntax> {
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.CSharp.ConvertAutoPropertyToFullProperty.CSharpConvertAutoPropertyToFullPropertyCodeRefactoringProvider/<GetFieldNameAsync>d__1")]
internal virtual Task`1<string> GetFieldNameAsync(Document document, IPropertySymbol property, CancellationToken cancellationToken);
    internal virtual ValueTuple`2<SyntaxNode, SyntaxNode> GetNewAccessors(DocumentOptionSet options, SyntaxNode property, string fieldName, SyntaxGenerator generator);
    private static ValueTuple`2<AccessorDeclarationSyntax, AccessorDeclarationSyntax> GetExistingAccessors(AccessorListSyntax accessorListSyntax);
    private static SyntaxNode GetUpdatedAccessor(DocumentOptionSet options, SyntaxNode accessor, SyntaxNode statement);
    internal static SyntaxNode AddStatement(SyntaxNode accessor, SyntaxNode statement);
    internal virtual SyntaxNode ConvertPropertyToExpressionBodyIfDesired(DocumentOptionSet options, SyntaxNode property);
    internal static ExpressionBodyPreference GetAccessorExpressionBodyPreference(DocumentOptionSet options);
    internal static ExpressionBodyPreference GetPropertyExpressionBodyPreference(DocumentOptionSet options);
    internal virtual SyntaxNode GetTypeBlock(SyntaxNode syntaxNode);
    internal virtual SyntaxNode GetInitializerValue(SyntaxNode property);
    internal virtual SyntaxNode GetPropertyWithoutInitializer(SyntaxNode property);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal abstract class Microsoft.CodeAnalysis.CSharp.ConvertBetweenRegularAndVerbatimString.AbstractConvertBetweenRegularAndVerbatimStringCodeRefactoringProvider`1 : CodeRefactoringProvider {
    private static char OpenBrace;
    private static char CloseBrace;
    protected static char DoubleQuote;
    protected bool IsInterpolation { get; }
    protected abstract virtual bool get_IsInterpolation();
    protected abstract virtual bool IsAppropriateLiteralKind(TStringExpressionSyntax literalExpression);
    protected abstract virtual void AddSubStringTokens(TStringExpressionSyntax literalExpression, ArrayBuilder`1<SyntaxToken> subTokens);
    protected abstract virtual bool IsVerbatim(TStringExpressionSyntax literalExpression);
    protected abstract virtual TStringExpressionSyntax CreateVerbatimStringExpression(IVirtualCharService charService, StringBuilder sb, TStringExpressionSyntax stringExpression);
    protected abstract virtual TStringExpressionSyntax CreateRegularStringExpression(IVirtualCharService charService, StringBuilder sb, TStringExpressionSyntax stringExpression);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.CSharp.ConvertBetweenRegularAndVerbatimString.AbstractConvertBetweenRegularAndVerbatimStringCodeRefactoringProvider`1/<ComputeRefactoringsAsync>d__10")]
public sealed virtual Task ComputeRefactoringsAsync(CodeRefactoringContext context);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.CSharp.ConvertBetweenRegularAndVerbatimString.AbstractConvertBetweenRegularAndVerbatimStringCodeRefactoringProvider`1/<ConvertAsync>d__11")]
private static Task`1<Document> ConvertAsync(Func`4<IVirtualCharService, StringBuilder, TStringExpressionSyntax, TStringExpressionSyntax> convert, Document document, TStringExpressionSyntax stringExpression, CancellationToken cancellationToken);
    private Task`1<Document> ConvertToVerbatimStringAsync(Document document, TStringExpressionSyntax stringExpression, CancellationToken cancellationToken);
    private Task`1<Document> ConvertToRegularStringAsync(Document document, TStringExpressionSyntax stringExpression, CancellationToken cancellationToken);
    protected void AddVerbatimStringText(IVirtualCharService charService, StringBuilder sb, SyntaxToken stringToken);
    private static bool IsOpenOrCloseBrace(VirtualChar ch);
    protected void AddRegularStringText(IVirtualCharService charService, StringBuilder sb, SyntaxToken stringToken);
    private static bool ContainsSimpleEscape(IVirtualCharService charService, ArrayBuilder`1<SyntaxToken> subTokens);
    private static bool ContainsSimpleEscape(VirtualCharSequence chars);
    [CompilerGeneratedAttribute]
internal static bool <AddVerbatimStringText>g__ShouldDouble|14_0(VirtualChar ch, bool isInterpolation);
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[ExportCodeRefactoringProviderAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
[SharedAttribute]
[ExtensionOrderAttribute]
internal class Microsoft.CodeAnalysis.CSharp.ConvertBetweenRegularAndVerbatimString.ConvertBetweenRegularAndVerbatimInterpolatedStringCodeRefactoringProvider : AbstractConvertBetweenRegularAndVerbatimStringCodeRefactoringProvider`1<InterpolatedStringExpressionSyntax> {
    [CompilerGeneratedAttribute]
private bool <IsInterpolation>k__BackingField;
    protected bool IsInterpolation { get; }
    [CompilerGeneratedAttribute]
protected virtual bool get_IsInterpolation();
    protected virtual bool IsAppropriateLiteralKind(InterpolatedStringExpressionSyntax literalExpression);
    protected virtual void AddSubStringTokens(InterpolatedStringExpressionSyntax literalExpression, ArrayBuilder`1<SyntaxToken> subStringTokens);
    protected virtual bool IsVerbatim(InterpolatedStringExpressionSyntax literalExpression);
    private static InterpolatedStringExpressionSyntax Convert(IVirtualCharService charService, StringBuilder sb, InterpolatedStringExpressionSyntax stringExpression, SyntaxKind newStartKind, Action`3<IVirtualCharService, StringBuilder, SyntaxToken> addStringText);
    private static SyntaxToken CreateTextToken(SyntaxToken textToken, StringBuilder sb);
    protected virtual InterpolatedStringExpressionSyntax CreateVerbatimStringExpression(IVirtualCharService charService, StringBuilder sb, InterpolatedStringExpressionSyntax stringExpression);
    protected virtual InterpolatedStringExpressionSyntax CreateRegularStringExpression(IVirtualCharService charService, StringBuilder sb, InterpolatedStringExpressionSyntax stringExpression);
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[ExportCodeRefactoringProviderAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
[SharedAttribute]
[ExtensionOrderAttribute]
internal class Microsoft.CodeAnalysis.CSharp.ConvertBetweenRegularAndVerbatimString.ConvertBetweenRegularAndVerbatimStringCodeRefactoringProvider : AbstractConvertBetweenRegularAndVerbatimStringCodeRefactoringProvider`1<LiteralExpressionSyntax> {
    [CompilerGeneratedAttribute]
private bool <IsInterpolation>k__BackingField;
    protected bool IsInterpolation { get; }
    [CompilerGeneratedAttribute]
protected virtual bool get_IsInterpolation();
    protected virtual bool IsAppropriateLiteralKind(LiteralExpressionSyntax literalExpression);
    protected virtual void AddSubStringTokens(LiteralExpressionSyntax literalExpression, ArrayBuilder`1<SyntaxToken> subStringTokens);
    protected virtual bool IsVerbatim(LiteralExpressionSyntax literalExpression);
    protected virtual LiteralExpressionSyntax CreateVerbatimStringExpression(IVirtualCharService charService, StringBuilder sb, LiteralExpressionSyntax stringExpression);
    protected virtual LiteralExpressionSyntax CreateRegularStringExpression(IVirtualCharService charService, StringBuilder sb, LiteralExpressionSyntax stringExpression);
    private static SyntaxToken CreateStringToken(StringBuilder sb);
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[ExportCodeRefactoringProviderAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.CSharp.ConvertCast.CSharpConvertDirectCastToTryCastCodeRefactoringProvider : AbstractConvertCastCodeRefactoringProvider`3<TypeSyntax, CastExpressionSyntax, BinaryExpressionSyntax> {
    protected int FromKind { get; }
    protected virtual string GetTitle();
    protected virtual int get_FromKind();
    protected virtual TypeSyntax GetTypeNode(CastExpressionSyntax from);
    protected virtual BinaryExpressionSyntax ConvertExpression(CastExpressionSyntax castExpression);
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[ExportCodeRefactoringProviderAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.CSharp.ConvertCast.CSharpConvertTryCastToDirectCastCodeRefactoringProvider : AbstractConvertCastCodeRefactoringProvider`3<TypeSyntax, BinaryExpressionSyntax, CastExpressionSyntax> {
    protected int FromKind { get; }
    protected virtual string GetTitle();
    protected virtual int get_FromKind();
    protected virtual TypeSyntax GetTypeNode(BinaryExpressionSyntax expression);
    protected virtual CastExpressionSyntax ConvertExpression(BinaryExpressionSyntax asExpression);
}
[ExportCodeRefactoringProviderAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.CSharp.ConvertForEachToFor.CSharpConvertForEachToForCodeRefactoringProvider : AbstractConvertForEachToForCodeRefactoringProvider`2<StatementSyntax, ForEachStatementSyntax> {
    protected string Title { get; }
    protected virtual string get_Title();
    protected virtual bool IsValid(ForEachStatementSyntax foreachStatement);
    protected virtual bool ValidLocation(ForEachInfo<StatementSyntax, ForEachStatementSyntax> foreachInfo);
    protected virtual ValueTuple`2<SyntaxNode, SyntaxNode> GetForEachBody(ForEachStatementSyntax foreachStatement);
    protected virtual void ConvertToForStatement(SemanticModel model, ForEachInfo<StatementSyntax, ForEachStatementSyntax> foreachInfo, SyntaxEditor editor, CancellationToken cancellationToken);
    private StatementSyntax GetForLoopBody(SyntaxGenerator generator, ForEachInfo<StatementSyntax, ForEachStatementSyntax> foreachInfo, SyntaxNode collectionVariableName, SyntaxToken indexVariable, bool donotCastElement);
    protected virtual bool IsSupported(ILocalSymbol foreachVariable, IForEachLoopOperation forEachOperation, ForEachStatementSyntax foreachStatement);
}
[ExportCodeRefactoringProviderAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.CSharp.ConvertForToForEach.CSharpConvertForToForEachCodeRefactoringProvider : AbstractConvertForToForEachCodeRefactoringProvider`6<StatementSyntax, ForStatementSyntax, ExpressionSyntax, MemberAccessExpressionSyntax, TypeSyntax, VariableDeclaratorSyntax> {
    protected virtual string GetTitle();
    protected virtual SyntaxList`1<StatementSyntax> GetBodyStatements(ForStatementSyntax forStatement);
    protected virtual bool TryGetForStatementComponents(ForStatementSyntax forStatement, SyntaxToken& iterationVariable, ExpressionSyntax& initializer, MemberAccessExpressionSyntax& memberAccess, ExpressionSyntax& stepValueExpressionOpt, CancellationToken cancellationToken);
    private static bool TryGetStepValue(SyntaxToken iterationVariable, ExpressionSyntax incrementor, ExpressionSyntax& stepValue);
    protected virtual SyntaxNode ConvertForNode(ForStatementSyntax forStatement, TypeSyntax typeNode, SyntaxToken foreachIdentifier, ExpressionSyntax collectionExpression, ITypeSymbol iterationVariableType, OptionSet optionSet);
    protected virtual bool IsValidVariableDeclarator(VariableDeclaratorSyntax firstVariable);
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[ExportCodeRefactoringProviderAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.CSharp.ConvertIfToSwitch.CSharpConvertIfToSwitchCodeRefactoringProvider : AbstractConvertIfToSwitchCodeRefactoringProvider`4<IfStatementSyntax, ExpressionSyntax, BinaryExpressionSyntax, PatternSyntax> {
    private static Dictionary`2<BinaryOperatorKind, SyntaxKind> s_operatorMap;
    private static CSharpConvertIfToSwitchCodeRefactoringProvider();
    public virtual string GetTitle(bool forSwitchExpression);
    public virtual Analyzer<IfStatementSyntax, ExpressionSyntax, BinaryExpressionSyntax, PatternSyntax> CreateAnalyzer(ISyntaxFacts syntaxFacts, ParseOptions options);
    public virtual SyntaxNode CreateSwitchExpressionStatement(SyntaxNode target, ImmutableArray`1<AnalyzedSwitchSection<IfStatementSyntax, ExpressionSyntax, BinaryExpressionSyntax, PatternSyntax>> sections, Feature<IfStatementSyntax, ExpressionSyntax, BinaryExpressionSyntax, PatternSyntax> feature);
    private static SwitchExpressionArmSyntax AsSwitchExpressionArmSyntax(AnalyzedSwitchSection<IfStatementSyntax, ExpressionSyntax, BinaryExpressionSyntax, PatternSyntax> section, Feature<IfStatementSyntax, ExpressionSyntax, BinaryExpressionSyntax, PatternSyntax> feature);
    private static ExpressionSyntax AsExpressionSyntax(IOperation operation);
    public virtual SyntaxNode CreateSwitchStatement(IfStatementSyntax ifStatement, SyntaxNode expression, IEnumerable`1<SyntaxNode> sectionList);
    private static WhenClauseSyntax AsWhenClause(AnalyzedSwitchLabel<IfStatementSyntax, ExpressionSyntax, BinaryExpressionSyntax, PatternSyntax> label);
    [NullableContextAttribute("2")]
private static WhenClauseSyntax AsWhenClause(ExpressionSyntax expression);
    public virtual SyntaxNode AsSwitchLabelSyntax(AnalyzedSwitchLabel<IfStatementSyntax, ExpressionSyntax, BinaryExpressionSyntax, PatternSyntax> label, Feature<IfStatementSyntax, ExpressionSyntax, BinaryExpressionSyntax, PatternSyntax> feature);
    private static PatternSyntax AsPatternSyntax(AnalyzedPattern<IfStatementSyntax, ExpressionSyntax, BinaryExpressionSyntax, PatternSyntax> pattern, Feature<IfStatementSyntax, ExpressionSyntax, BinaryExpressionSyntax, PatternSyntax> feature);
    public virtual IEnumerable`1<SyntaxNode> AsSwitchSectionStatements(IOperation operation);
}
internal abstract class Microsoft.CodeAnalysis.CSharp.ConvertLinq.ConvertForEachToLinqQuery.AbstractConverter : object {
    [CompilerGeneratedAttribute]
private ForEachInfo`2<ForEachStatementSyntax, StatementSyntax> <ForEachInfo>k__BackingField;
    public ForEachInfo`2<ForEachStatementSyntax, StatementSyntax> ForEachInfo { get; }
    public AbstractConverter(ForEachInfo`2<ForEachStatementSyntax, StatementSyntax> forEachInfo);
    [CompilerGeneratedAttribute]
public sealed virtual ForEachInfo`2<ForEachStatementSyntax, StatementSyntax> get_ForEachInfo();
    public abstract virtual void Convert(SyntaxEditor editor, bool convertToQuery, CancellationToken cancellationToken);
    protected ExpressionSyntax CreateQueryExpressionOrLinqInvocation(ExpressionSyntax selectExpression, IEnumerable`1<SyntaxToken> leadingTokensForSelect, IEnumerable`1<SyntaxToken> trailingTokensForSelect, bool convertToQuery);
    private QueryExpressionSyntax CreateQueryExpression(ExpressionSyntax selectExpression, IEnumerable`1<SyntaxToken> leadingTokensForSelect, IEnumerable`1<SyntaxToken> trailingTokensForSelect);
    private static QueryClauseSyntax CreateQueryClause(ExtendedSyntaxNode node);
    private static FromClauseSyntax CreateFromClause(ForEachStatementSyntax forEachStatement, IEnumerable`1<SyntaxTrivia> extraLeadingTrivia, IEnumerable`1<SyntaxTrivia> extraTrailingTrivia);
    private ExpressionSyntax CreateLinqInvocationOrSimpleExpression(ExpressionSyntax selectExpression, IEnumerable`1<SyntaxToken> leadingTokensForSelect, IEnumerable`1<SyntaxToken> trailingTokensForSelect);
    private ExpressionSyntax CreateLinqInvocationOrSimpleExpression(ForEachStatementSyntax forEachStatement, ExpressionSyntax receiverForInvocation, IEnumerable`1<SyntaxTrivia> leadingCommentsTrivia, IEnumerable`1<SyntaxTrivia> trailingCommentsTrivia, ExpressionSyntax selectExpression, Int32& currentExtendedNodeIndex);
    private ExpressionSyntax CreateLinqInvocationForExtendedNode(ExpressionSyntax selectExpression, Int32& extendedNodeIndex, ExpressionSyntax& receiver, Boolean& hasForEachChild);
}
internal abstract class Microsoft.CodeAnalysis.CSharp.ConvertLinq.ConvertForEachToLinqQuery.AbstractToMethodConverter : AbstractConverter {
    private ExpressionSyntax _selectExpression;
    private ExpressionSyntax _modifyingExpression;
    private SyntaxTrivia[] _trivia;
    protected string MethodName { get; }
    public AbstractToMethodConverter(ForEachInfo`2<ForEachStatementSyntax, StatementSyntax> forEachInfo, ExpressionSyntax selectExpression, ExpressionSyntax modifyingExpression, SyntaxTrivia[] trivia);
    protected abstract virtual string get_MethodName();
    protected abstract virtual bool CanReplaceInitialization(ExpressionSyntax expressionSyntax, CancellationToken cancellationToken);
    protected abstract virtual StatementSyntax CreateDefaultStatement(ExpressionSyntax queryOrLinqInvocationExpression, ExpressionSyntax expression);
    public virtual void Convert(SyntaxEditor editor, bool convertToQuery, CancellationToken cancellationToken);
    protected InvocationExpressionSyntax CreateInvocationExpression(ExpressionSyntax queryOrLinqInvocationExpression);
    [CompilerGeneratedAttribute]
private void <Convert>g__Convert|8_0(ExpressionSyntax replacingExpression, SyntaxNode nodeToRemoveIfFollowedByReturn, <>c__DisplayClass8_0& );
    [CompilerGeneratedAttribute]
internal static SyntaxTrivia[] <Convert>g__GetTriviaFromVariableDeclarator|8_1(VariableDeclaratorSyntax variableDeclarator);
    [CompilerGeneratedAttribute]
internal static SyntaxTrivia[] <Convert>g__GetTriviaFromNode|8_2(SyntaxNode node);
}
[ExportCodeRefactoringProviderAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.CSharp.ConvertLinq.ConvertForEachToLinqQuery.CSharpConvertForEachToLinqQueryProvider : AbstractConvertForEachToLinqQueryProvider`2<ForEachStatementSyntax, StatementSyntax> {
    protected virtual IConverter`2<ForEachStatementSyntax, StatementSyntax> CreateDefaultConverter(ForEachInfo`2<ForEachStatementSyntax, StatementSyntax> forEachInfo);
    protected virtual ForEachInfo`2<ForEachStatementSyntax, StatementSyntax> CreateForEachInfo(ForEachStatementSyntax forEachStatement, SemanticModel semanticModel, bool convertLocalDeclarations);
    protected virtual bool TryBuildSpecificConverter(ForEachInfo`2<ForEachStatementSyntax, StatementSyntax> forEachInfo, SemanticModel semanticModel, StatementSyntax statementCannotBeConverted, CancellationToken cancellationToken, IConverter`2& converter);
    protected virtual SyntaxNode AddLinqUsing(IConverter`2<ForEachStatementSyntax, StatementSyntax> converter, SemanticModel semanticModel, SyntaxNode root);
    internal static bool TypeSymbolOptIsList(ITypeSymbol typeSymbol, SemanticModel semanticModel);
    [CompilerGeneratedAttribute]
internal static bool <CreateForEachInfo>g__TryProcessLocalDeclarationStatement|2_0(LocalDeclarationStatementSyntax localDeclarationStatement, <>c__DisplayClass2_0& );
}
internal class Microsoft.CodeAnalysis.CSharp.ConvertLinq.ConvertForEachToLinqQuery.DefaultConverter : AbstractConverter {
    private static TypeSyntax VarNameIdentifier;
    public DefaultConverter(ForEachInfo`2<ForEachStatementSyntax, StatementSyntax> forEachInfo);
    private static DefaultConverter();
    public virtual void Convert(SyntaxEditor editor, bool convertToQuery, CancellationToken cancellationToken);
    private StatementSyntax CreateDefaultReplacementStatement(IEnumerable`1<SyntaxToken> identifiers, BlockSyntax block, bool convertToQuery);
    private static BlockSyntax WrapWithBlockIfNecessary(IEnumerable`1<StatementSyntax> statements);
}
internal class Microsoft.CodeAnalysis.CSharp.ConvertLinq.ConvertForEachToLinqQuery.ToCountConverter : AbstractToMethodConverter {
    protected string MethodName { get; }
    public ToCountConverter(ForEachInfo`2<ForEachStatementSyntax, StatementSyntax> forEachInfo, ExpressionSyntax selectExpression, ExpressionSyntax modifyingExpression, SyntaxTrivia[] trivia);
    protected virtual string get_MethodName();
    protected virtual bool CanReplaceInitialization(ExpressionSyntax expression, CancellationToken cancellationToken);
    protected virtual StatementSyntax CreateDefaultStatement(ExpressionSyntax queryOrLinqInvocationExpression, ExpressionSyntax expression);
}
internal class Microsoft.CodeAnalysis.CSharp.ConvertLinq.ConvertForEachToLinqQuery.ToToListConverter : AbstractToMethodConverter {
    protected string MethodName { get; }
    public ToToListConverter(ForEachInfo`2<ForEachStatementSyntax, StatementSyntax> forEachInfo, ExpressionSyntax selectExpression, ExpressionSyntax modifyingExpression, SyntaxTrivia[] trivia);
    protected virtual string get_MethodName();
    protected virtual bool CanReplaceInitialization(ExpressionSyntax expression, CancellationToken cancellationToken);
    protected virtual StatementSyntax CreateDefaultStatement(ExpressionSyntax queryOrLinqInvocationExpression, ExpressionSyntax expression);
}
internal class Microsoft.CodeAnalysis.CSharp.ConvertLinq.ConvertForEachToLinqQuery.YieldReturnConverter : AbstractConverter {
    private YieldStatementSyntax _yieldReturnStatement;
    private YieldStatementSyntax _yieldBreakStatement;
    public YieldReturnConverter(ForEachInfo`2<ForEachStatementSyntax, StatementSyntax> forEachInfo, YieldStatementSyntax yieldReturnStatement, YieldStatementSyntax yieldBreakStatement);
    public virtual void Convert(SyntaxEditor editor, bool convertToQuery, CancellationToken cancellationToken);
}
[ExportCodeRefactoringProviderAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.CSharp.ConvertLinq.CSharpConvertLinqQueryToForEachProvider : AbstractConvertLinqQueryToForEachProvider`2<QueryExpressionSyntax, StatementSyntax> {
    private static TypeSyntax VarNameIdentifier;
    protected string Title { get; }
    private static CSharpConvertLinqQueryToForEachProvider();
    protected virtual string get_Title();
    protected virtual bool TryConvert(QueryExpressionSyntax queryExpression, SemanticModel semanticModel, ISemanticFactsService semanticFacts, CancellationToken cancellationToken, DocumentUpdateInfo& documentUpdateInfo);
    protected virtual Task`1<QueryExpressionSyntax> FindNodeToRefactorAsync(CodeRefactoringContext context);
}
[ExportCodeRefactoringProviderAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.CSharp.ConvertNumericLiteral.CSharpConvertNumericLiteralCodeRefactoringProvider : AbstractConvertNumericLiteralCodeRefactoringProvider`1<LiteralExpressionSyntax> {
    protected virtual ValueTuple`2<string, string> GetNumericLiteralPrefixes();
}
[ExportCodeFixProviderAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.CSharp.ConvertSwitchStatementToExpression.ConvertSwitchStatementToExpressionCodeFixProvider : SyntaxEditorBasedCodeFixProvider {
    public ImmutableArray`1<string> FixableDiagnosticIds { get; }
    internal CodeFixCategory CodeFixCategory { get; }
    public virtual ImmutableArray`1<string> get_FixableDiagnosticIds();
    internal sealed virtual CodeFixCategory get_CodeFixCategory();
    public virtual Task RegisterCodeFixesAsync(CodeFixContext context);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.CSharp.ConvertSwitchStatementToExpression.ConvertSwitchStatementToExpressionCodeFixProvider/<FixAllAsync>d__6")]
protected virtual Task FixAllAsync(Document document, ImmutableArray`1<Diagnostic> diagnostics, SyntaxEditor editor, CancellationToken cancellationToken);
}
internal static class Microsoft.CodeAnalysis.CSharp.ConvertSwitchStatementToExpression.ConvertSwitchStatementToExpressionConstants : object {
    public static string NodeToGenerateKey;
    public static string ShouldRemoveNextStatementKey;
}
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
internal class Microsoft.CodeAnalysis.CSharp.ConvertSwitchStatementToExpression.ConvertSwitchStatementToExpressionDiagnosticAnalyzer : AbstractBuiltInCodeStyleDiagnosticAnalyzer {
    protected virtual void InitializeWorker(AnalysisContext context);
    private void AnalyzeSyntax(SyntaxNodeAnalysisContext context);
    public virtual DiagnosticAnalyzerCategory GetAnalyzerCategory();
}
internal static class Microsoft.CodeAnalysis.CSharp.ConvertSwitchStatementToExpression.ConvertSwitchStatementToExpressionHelpers : object {
    public static bool IsDefaultSwitchLabel(SwitchLabelSyntax node);
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[ExportCodeRefactoringProviderAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.CSharp.ConvertToInterpolatedString.CSharpConvertConcatenationToInterpolatedStringRefactoringProvider : AbstractConvertConcatenationToInterpolatedStringRefactoringProvider`1<ExpressionSyntax> {
    protected virtual bool SupportsConstantInterpolatedStrings(Document document);
    protected virtual string GetTextWithoutQuotes(string text, bool isVerbatim, bool isCharacterLiteral);
}
[ExportCodeRefactoringProviderAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.CSharp.ConvertToInterpolatedString.CSharpConvertPlaceholderToInterpolatedStringRefactoringProvider : AbstractConvertPlaceholderToInterpolatedStringRefactoringProvider`5<InvocationExpressionSyntax, ExpressionSyntax, ArgumentSyntax, LiteralExpressionSyntax, ArgumentListSyntax> {
    protected virtual SyntaxNode GetInterpolatedString(string text);
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[ExtensionOrderAttribute]
[ExportLanguageServiceAttribute("Microsoft.CodeAnalysis.ConvertTupleToStruct.IConvertTupleToStructCodeRefactoringProvider", "C#", "Default")]
[ExportCodeRefactoringProviderAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.CSharp.ConvertTupleToStruct.CSharpConvertTupleToStructCodeRefactoringProvider : AbstractConvertTupleToStructCodeRefactoringProvider`10<ExpressionSyntax, NameSyntax, IdentifierNameSyntax, LiteralExpressionSyntax, ObjectCreationExpressionSyntax, TupleExpressionSyntax, ArgumentSyntax, TupleTypeSyntax, TypeDeclarationSyntax, NamespaceDeclarationSyntax> {
    protected virtual ArgumentSyntax GetArgumentWithChangedName(ArgumentSyntax argument, string name);
    [NullableContextAttribute("2")]
private static NameColonSyntax ChangeName(NameColonSyntax nameColon, string name);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExportCodeFixProviderAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.CSharp.ConvertTypeOfToNameOf.CSharpConvertTypeOfToNameOfCodeFixProvider : AbstractConvertTypeOfToNameOfCodeFixProvider {
    protected virtual string GetCodeFixTitle();
    protected virtual SyntaxNode GetSymbolTypeExpression(SemanticModel model, SyntaxNode node, CancellationToken cancellationToken);
}
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
internal class Microsoft.CodeAnalysis.CSharp.ConvertTypeOfToNameOf.CSharpConvertTypeOfToNameOfDiagnosticAnalyzer : AbstractConvertTypeOfToNameOfDiagnosticAnalyzer {
    [NullableAttribute("1")]
private static string s_title;
    private static CSharpConvertTypeOfToNameOfDiagnosticAnalyzer();
    protected virtual bool IsValidTypeofAction(OperationAnalysisContext context);
}
internal static class Microsoft.CodeAnalysis.CSharp.CSharpAnalyzersResources : object {
    private static ResourceManager s_resourceManager;
    [CompilerGeneratedAttribute]
private static CultureInfo <Culture>k__BackingField;
    internal static ResourceManager ResourceManager { get; }
    internal static CultureInfo Culture { get; internal set; }
    internal static string Convert_switch_statement_to_expression { get; }
    internal static string Use_switch_expression { get; }
    internal static string Use_explicit_type_instead_of_var { get; }
    internal static string Use_explicit_type { get; }
    internal static string use_var_instead_of_explicit_type { get; }
    internal static string Use_implicit_type { get; }
    internal static string Using_directive_is_unnecessary { get; }
    internal static string Add_braces { get; }
    internal static string Add_braces_to_0_statement { get; }
    internal static string Misplaced_using_directive { get; }
    internal static string Move_misplaced_using_directives { get; }
    internal static string Using_directives_must_be_placed_inside_of_a_namespace_declaration { get; }
    internal static string Using_directives_must_be_placed_outside_of_a_namespace_declaration { get; }
    internal static string Warning_colon_Moving_using_directives_may_change_code_meaning { get; }
    internal static string Use_expression_body_for_methods { get; }
    internal static string Use_block_body_for_methods { get; }
    internal static string Use_block_body_for_accessors { get; }
    internal static string Use_block_body_for_constructors { get; }
    internal static string Use_block_body_for_indexers { get; }
    internal static string Use_block_body_for_operators { get; }
    internal static string Use_block_body_for_properties { get; }
    internal static string Use_expression_body_for_accessors { get; }
    internal static string Use_expression_body_for_constructors { get; }
    internal static string Use_expression_body_for_indexers { get; }
    internal static string Use_expression_body_for_operators { get; }
    internal static string Use_expression_body_for_properties { get; }
    internal static string Use_block_body_for_local_functions { get; }
    internal static string Use_expression_body_for_local_functions { get; }
    internal static string Unreachable_code_detected { get; }
    internal static string Use_pattern_matching { get; }
    internal static string Use_is_null_check { get; }
    internal static string Use_simple_using_statement { get; }
    internal static string using_statement_can_be_simplified { get; }
    internal static string if_statement_can_be_simplified { get; }
    internal static string Simplify_default_expression { get; }
    internal static string default_expression_can_be_simplified { get; }
    internal static string Make_readonly_fields_writable { get; }
    internal static string Struct_contains_assignment_to_this_outside_of_constructor_Make_readonly_fields_writable { get; }
    internal static string Deconstruct_variable_declaration { get; }
    internal static string Variable_declaration_can_be_deconstructed { get; }
    internal static string Local_function_can_be_made_static { get; }
    internal static string Make_local_function_static { get; }
    internal static string _0_can_be_simplified { get; }
    internal static string Indexing_can_be_simplified { get; }
    internal static string Use_local_function { get; }
    internal static string Use_index_operator { get; }
    internal static string Use_range_operator { get; }
    internal static string Delegate_invocation_can_be_simplified { get; }
    internal static string Inline_variable_declaration { get; }
    internal static string Variable_declaration_can_be_inlined { get; }
    internal static string Negate_expression_changes_semantics { get; }
    internal static string Remove_operator_preserves_semantics { get; }
    internal static string Remove_suppression_operators { get; }
    internal static string Remove_unnecessary_suppression_operator { get; }
    internal static string Suppression_operator_has_no_effect_and_can_be_misinterpreted { get; }
    internal static string typeof_can_be_converted__to_nameof { get; }
    internal static string Use_new { get; }
    internal static string new_expression_can_be_simplified { get; }
    internal static string Discard_can_be_removed { get; }
    internal static string Remove_unnessary_discard { get; }
    internal static string Embedded_statements_must_be_on_their_own_line { get; }
    internal static string Consecutive_braces_must_not_have_a_blank_between_them { get; }
    internal static string Blank_line_not_allowed_after_constructor_initializer_colon { get; }
    internal static ResourceManager get_ResourceManager();
    [CompilerGeneratedAttribute]
internal static CultureInfo get_Culture();
    [CompilerGeneratedAttribute]
internal static void set_Culture(CultureInfo value);
    internal static string GetResourceString(string resourceKey, string defaultValue);
    internal static string get_Convert_switch_statement_to_expression();
    internal static string get_Use_switch_expression();
    internal static string get_Use_explicit_type_instead_of_var();
    internal static string get_Use_explicit_type();
    internal static string get_use_var_instead_of_explicit_type();
    internal static string get_Use_implicit_type();
    internal static string get_Using_directive_is_unnecessary();
    internal static string get_Add_braces();
    internal static string get_Add_braces_to_0_statement();
    internal static string get_Misplaced_using_directive();
    internal static string get_Move_misplaced_using_directives();
    internal static string get_Using_directives_must_be_placed_inside_of_a_namespace_declaration();
    internal static string get_Using_directives_must_be_placed_outside_of_a_namespace_declaration();
    internal static string get_Warning_colon_Moving_using_directives_may_change_code_meaning();
    internal static string get_Use_expression_body_for_methods();
    internal static string get_Use_block_body_for_methods();
    internal static string get_Use_block_body_for_accessors();
    internal static string get_Use_block_body_for_constructors();
    internal static string get_Use_block_body_for_indexers();
    internal static string get_Use_block_body_for_operators();
    internal static string get_Use_block_body_for_properties();
    internal static string get_Use_expression_body_for_accessors();
    internal static string get_Use_expression_body_for_constructors();
    internal static string get_Use_expression_body_for_indexers();
    internal static string get_Use_expression_body_for_operators();
    internal static string get_Use_expression_body_for_properties();
    internal static string get_Use_block_body_for_local_functions();
    internal static string get_Use_expression_body_for_local_functions();
    internal static string get_Unreachable_code_detected();
    internal static string get_Use_pattern_matching();
    internal static string get_Use_is_null_check();
    internal static string get_Use_simple_using_statement();
    internal static string get_using_statement_can_be_simplified();
    internal static string get_if_statement_can_be_simplified();
    internal static string get_Simplify_default_expression();
    internal static string get_default_expression_can_be_simplified();
    internal static string get_Make_readonly_fields_writable();
    internal static string get_Struct_contains_assignment_to_this_outside_of_constructor_Make_readonly_fields_writable();
    internal static string get_Deconstruct_variable_declaration();
    internal static string get_Variable_declaration_can_be_deconstructed();
    internal static string get_Local_function_can_be_made_static();
    internal static string get_Make_local_function_static();
    internal static string get__0_can_be_simplified();
    internal static string get_Indexing_can_be_simplified();
    internal static string get_Use_local_function();
    internal static string get_Use_index_operator();
    internal static string get_Use_range_operator();
    internal static string get_Delegate_invocation_can_be_simplified();
    internal static string get_Inline_variable_declaration();
    internal static string get_Variable_declaration_can_be_inlined();
    internal static string get_Negate_expression_changes_semantics();
    internal static string get_Remove_operator_preserves_semantics();
    internal static string get_Remove_suppression_operators();
    internal static string get_Remove_unnecessary_suppression_operator();
    internal static string get_Suppression_operator_has_no_effect_and_can_be_misinterpreted();
    internal static string get_typeof_can_be_converted__to_nameof();
    internal static string get_Use_new();
    internal static string get_new_expression_can_be_simplified();
    internal static string get_Discard_can_be_removed();
    internal static string get_Remove_unnessary_discard();
    internal static string get_Embedded_statements_must_be_on_their_own_line();
    internal static string get_Consecutive_braces_must_not_have_a_blank_between_them();
    internal static string get_Blank_line_not_allowed_after_constructor_initializer_colon();
}
internal static class Microsoft.CodeAnalysis.CSharp.CSharpCodeFixesResources : object {
    private static ResourceManager s_resourceManager;
    [CompilerGeneratedAttribute]
private static CultureInfo <Culture>k__BackingField;
    internal static ResourceManager ResourceManager { get; }
    internal static CultureInfo Culture { get; internal set; }
    internal static string Remove_Unnecessary_Usings { get; }
    internal static string Add_this { get; }
    internal static string Remove_unreachable_code { get; }
    internal static string Pass_in_captured_variables_as_arguments { get; }
    internal static string Warning_colon_Adding_parameters_to_local_function_declaration_may_produce_invalid_code { get; }
    internal static string Convert_typeof_to_nameof { get; }
    internal static string Place_statement_on_following_line { get; }
    internal static string Remove_blank_lines_between_braces { get; }
    internal static string Place_colon_on_following_line { get; }
    internal static ResourceManager get_ResourceManager();
    [CompilerGeneratedAttribute]
internal static CultureInfo get_Culture();
    [CompilerGeneratedAttribute]
internal static void set_Culture(CultureInfo value);
    internal static string GetResourceString(string resourceKey, string defaultValue);
    internal static string get_Remove_Unnecessary_Usings();
    internal static string get_Add_this();
    internal static string get_Remove_unreachable_code();
    internal static string get_Pass_in_captured_variables_as_arguments();
    internal static string get_Warning_colon_Adding_parameters_to_local_function_declaration_may_produce_invalid_code();
    internal static string get_Convert_typeof_to_nameof();
    internal static string get_Place_statement_on_following_line();
    internal static string get_Remove_blank_lines_between_braces();
    internal static string get_Place_colon_on_following_line();
}
internal class Microsoft.CodeAnalysis.CSharp.CSharpDeclarationComputer : DeclarationComputer {
    public static void ComputeDeclarationsInSpan(SemanticModel model, TextSpan span, bool getSymbol, ArrayBuilder`1<DeclarationInfo> builder, CancellationToken cancellationToken);
    public static void ComputeDeclarationsInNode(SemanticModel model, ISymbol associatedSymbol, SyntaxNode node, bool getSymbol, ArrayBuilder`1<DeclarationInfo> builder, CancellationToken cancellationToken, Nullable`1<int> levelsToCompute);
    private static bool InvalidLevel(Nullable`1<int> level);
    private static Nullable`1<int> DecrementLevel(Nullable`1<int> level);
    private static void ComputeDeclarations(SemanticModel model, ISymbol associatedSymbol, SyntaxNode node, Func`3<SyntaxNode, Nullable`1<int>, bool> shouldSkip, bool getSymbol, ArrayBuilder`1<DeclarationInfo> builder, Nullable`1<int> levelsToCompute, CancellationToken cancellationToken);
    [IteratorStateMachineAttribute("Microsoft.CodeAnalysis.CSharp.CSharpDeclarationComputer/<GetAttributes>d__5")]
private static IEnumerable`1<SyntaxNode> GetAttributes(SyntaxList`1<AttributeListSyntax> attributeLists);
    private static IEnumerable`1<SyntaxNode> GetParameterListInitializersAndAttributes(BaseParameterListSyntax parameterList);
    private static IEnumerable`1<SyntaxNode> GetParameterInitializersAndAttributes(ParameterSyntax parameter);
    private static IEnumerable`1<SyntaxNode> GetTypeParameterListAttributes(TypeParameterListSyntax typeParameterList);
    private static DeclarationInfo GetExpressionBodyDeclarationInfo(BasePropertyDeclarationSyntax declarationWithExpressionBody, ArrowExpressionClauseSyntax expressionBody, SemanticModel model, bool getSymbol, CancellationToken cancellationToken);
    internal static ArrowExpressionClauseSyntax GetExpressionBodySyntax(CSharpSyntaxNode node);
}
internal static class Microsoft.CodeAnalysis.CSharp.CSharpFeaturesResources : object {
    private static ResourceManager s_resourceManager;
    [CompilerGeneratedAttribute]
private static CultureInfo <Culture>k__BackingField;
    internal static ResourceManager ResourceManager { get; }
    internal static CultureInfo Culture { get; internal set; }
    internal static string Inline_temporary_variable { get; }
    internal static string Conflict_s_detected { get; }
    internal static string Invert_if { get; }
    internal static string Add_await { get; }
    internal static string Add_await_and_ConfigureAwaitFalse { get; }
    internal static string Simplify_lambda_expression { get; }
    internal static string Simplify_all_occurrences { get; }
    internal static string lambda_expression { get; }
    internal static string Autoselect_disabled_due_to_potential_lambda_declaration { get; }
    internal static string member_name { get; }
    internal static string Autoselect_disabled_due_to_possible_explicitly_named_anonymous_type_member_creation { get; }
    internal static string element_name { get; }
    internal static string Autoselect_disabled_due_to_possible_tuple_type_element_creation { get; }
    internal static string pattern_variable { get; }
    internal static string Autoselect_disabled_due_to_potential_pattern_variable_declaration { get; }
    internal static string range_variable { get; }
    internal static string Autoselect_disabled_due_to_potential_range_variable_declaration { get; }
    internal static string Declare_as_nullable { get; }
    internal static string Fix_return_type { get; }
    internal static string Simplify_name_0 { get; }
    internal static string Simplify_member_access_0 { get; }
    internal static string Remove_this_qualification { get; }
    internal static string Name_can_be_simplified { get; }
    internal static string Can_t_determine_valid_range_of_statements_to_extract { get; }
    internal static string Not_all_code_paths_return { get; }
    internal static string Selection_does_not_contain_a_valid_node { get; }
    internal static string Invalid_selection { get; }
    internal static string Selection_does_not_contain_a_valid_token { get; }
    internal static string No_valid_selection_to_perform_extraction { get; }
    internal static string No_common_root_node_for_extraction { get; }
    internal static string Contains_invalid_selection { get; }
    internal static string The_selection_contains_syntactic_errors { get; }
    internal static string Selection_can_not_cross_over_preprocessor_directives { get; }
    internal static string Selection_can_not_contain_a_yield_statement { get; }
    internal static string Selection_can_not_contain_throw_statement { get; }
    internal static string Selection_can_not_be_part_of_constant_initializer_expression { get; }
    internal static string Selection_can_not_contain_a_pattern_expression { get; }
    internal static string The_selected_code_is_inside_an_unsafe_context { get; }
    internal static string No_valid_statement_range_to_extract { get; }
    internal static string deprecated { get; }
    internal static string extension { get; }
    internal static string awaitable { get; }
    internal static string awaitable_extension { get; }
    internal static string Organize_Usings { get; }
    internal static string Insert_await { get; }
    internal static string Make_0_return_Task_instead_of_void { get; }
    internal static string Change_return_type_from_0_to_1 { get; }
    internal static string Replace_return_with_yield_return { get; }
    internal static string Generate_explicit_conversion_operator_in_0 { get; }
    internal static string Generate_implicit_conversion_operator_in_0 { get; }
    internal static string try_block { get; }
    internal static string catch_clause { get; }
    internal static string filter_clause { get; }
    internal static string finally_clause { get; }
    internal static string fixed_statement { get; }
    internal static string using_statement { get; }
    internal static string lock_statement { get; }
    internal static string foreach_statement { get; }
    internal static string asynchronous_foreach_statement { get; }
    internal static string using_declaration { get; }
    internal static string asynchronous_using_declaration { get; }
    internal static string checked_statement { get; }
    internal static string unchecked_statement { get; }
    internal static string yield_return_statement { get; }
    internal static string yield_break_statement { get; }
    internal static string await_expression { get; }
    internal static string lambda { get; }
    internal static string anonymous_method { get; }
    internal static string from_clause { get; }
    internal static string join_clause { get; }
    internal static string let_clause { get; }
    internal static string where_clause { get; }
    internal static string orderby_clause { get; }
    internal static string select_clause { get; }
    internal static string groupby_clause { get; }
    internal static string query_body { get; }
    internal static string into_clause { get; }
    internal static string is_pattern { get; }
    internal static string deconstruction { get; }
    internal static string tuple { get; }
    internal static string local_function { get; }
    internal static string out_var { get; }
    internal static string ref_local_or_expression { get; }
    internal static string switch_statement { get; }
    internal static string global_statement { get; }
    internal static string extern_alias { get; }
    internal static string using_directive { get; }
    internal static string struct_ { get; }
    internal static string event_field { get; }
    internal static string conversion_operator { get; }
    internal static string destructor { get; }
    internal static string indexer { get; }
    internal static string property_getter { get; }
    internal static string indexer_getter { get; }
    internal static string property_setter { get; }
    internal static string indexer_setter { get; }
    internal static string attribute_target { get; }
    internal static string _0_does_not_contain_a_constructor_that_takes_that_many_arguments { get; }
    internal static string The_name_0_does_not_exist_in_the_current_context { get; }
    internal static string Hide_base_member { get; }
    internal static string Remove_new_modifier { get; }
    internal static string Properties { get; }
    internal static string Autoselect_disabled_due_to_namespace_declaration { get; }
    internal static string namespace_name { get; }
    internal static string Autoselect_disabled_due_to_type_declaration { get; }
    internal static string Autoselect_disabled_due_to_possible_deconstruction_declaration { get; }
    internal static string Upgrade_this_project_to_csharp_language_version_0 { get; }
    internal static string Upgrade_all_csharp_projects_to_language_version_0 { get; }
    internal static string class_name { get; }
    internal static string interface_name { get; }
    internal static string designation_name { get; }
    internal static string struct_name { get; }
    internal static string Make_method_async { get; }
    internal static string Make_method_async_remain_void { get; }
    internal static string Convert_to_switch_statement { get; }
    internal static string Convert_to_switch_expression { get; }
    internal static string Name { get; }
    internal static string Autoselect_disabled_due_to_member_declaration { get; }
    internal static string Suggested_name { get; }
    internal static string Remove_unused_function { get; }
    internal static string Add_parentheses_around_conditional_expression_in_interpolated_string { get; }
    internal static string Convert_to_foreach { get; }
    internal static string Convert_to_for { get; }
    internal static string Allow_unsafe_code_in_this_project { get; }
    internal static string Add_Obsolete { get; }
    internal static string Convert_to_method { get; }
    internal static string Add_remove_braces_for_single_line_control_statements { get; }
    internal static string Apply_language_framework_type_preferences { get; }
    internal static string Apply_implicit_explicit_type_preferences { get; }
    internal static string Apply_this_qualification_preferences { get; }
    internal static string Sort_accessibility_modifiers { get; }
    internal static string Apply_expression_block_body_preferences { get; }
    internal static string Apply_inline_out_variable_preferences { get; }
    internal static string Make_private_field_readonly_when_possible { get; }
    internal static string Use_0 { get; }
    internal static string Add_missing_usings { get; }
    internal static string Introduce_using_statement { get; }
    internal static string Unseal_class_0 { get; }
    internal static string Make_ref_struct { get; }
    internal static string Assign_out_parameters { get; }
    internal static string Assign_out_parameters_at_start { get; }
    internal static string Warning_Inlining_temporary_into_conditional_method_call { get; }
    internal static string Warning_Inlining_temporary_variable_may_change_code_meaning { get; }
    internal static string local_variable_declaration { get; }
    internal static string switch_statement_case_clause { get; }
    internal static string Reverse_for_statement { get; }
    internal static string Convert_to_regular_string { get; }
    internal static string Convert_to_verbatim_string { get; }
    internal static string Assign_to_0 { get; }
    internal static string Compare_to_0 { get; }
    internal static string Apply_using_directive_placement_preferences { get; }
    internal static string Remove_in_keyword { get; }
    internal static string Change_to_as_expression { get; }
    internal static string Change_to_cast { get; }
    internal static string record_ { get; }
    internal static ResourceManager get_ResourceManager();
    [CompilerGeneratedAttribute]
internal static CultureInfo get_Culture();
    [CompilerGeneratedAttribute]
internal static void set_Culture(CultureInfo value);
    internal static string GetResourceString(string resourceKey, string defaultValue);
    internal static string get_Inline_temporary_variable();
    internal static string get_Conflict_s_detected();
    internal static string get_Invert_if();
    internal static string get_Add_await();
    internal static string get_Add_await_and_ConfigureAwaitFalse();
    internal static string get_Simplify_lambda_expression();
    internal static string get_Simplify_all_occurrences();
    internal static string get_lambda_expression();
    internal static string get_Autoselect_disabled_due_to_potential_lambda_declaration();
    internal static string get_member_name();
    internal static string get_Autoselect_disabled_due_to_possible_explicitly_named_anonymous_type_member_creation();
    internal static string get_element_name();
    internal static string get_Autoselect_disabled_due_to_possible_tuple_type_element_creation();
    internal static string get_pattern_variable();
    internal static string get_Autoselect_disabled_due_to_potential_pattern_variable_declaration();
    internal static string get_range_variable();
    internal static string get_Autoselect_disabled_due_to_potential_range_variable_declaration();
    internal static string get_Declare_as_nullable();
    internal static string get_Fix_return_type();
    internal static string get_Simplify_name_0();
    internal static string get_Simplify_member_access_0();
    internal static string get_Remove_this_qualification();
    internal static string get_Name_can_be_simplified();
    internal static string get_Can_t_determine_valid_range_of_statements_to_extract();
    internal static string get_Not_all_code_paths_return();
    internal static string get_Selection_does_not_contain_a_valid_node();
    internal static string get_Invalid_selection();
    internal static string get_Selection_does_not_contain_a_valid_token();
    internal static string get_No_valid_selection_to_perform_extraction();
    internal static string get_No_common_root_node_for_extraction();
    internal static string get_Contains_invalid_selection();
    internal static string get_The_selection_contains_syntactic_errors();
    internal static string get_Selection_can_not_cross_over_preprocessor_directives();
    internal static string get_Selection_can_not_contain_a_yield_statement();
    internal static string get_Selection_can_not_contain_throw_statement();
    internal static string get_Selection_can_not_be_part_of_constant_initializer_expression();
    internal static string get_Selection_can_not_contain_a_pattern_expression();
    internal static string get_The_selected_code_is_inside_an_unsafe_context();
    internal static string get_No_valid_statement_range_to_extract();
    internal static string get_deprecated();
    internal static string get_extension();
    internal static string get_awaitable();
    internal static string get_awaitable_extension();
    internal static string get_Organize_Usings();
    internal static string get_Insert_await();
    internal static string get_Make_0_return_Task_instead_of_void();
    internal static string get_Change_return_type_from_0_to_1();
    internal static string get_Replace_return_with_yield_return();
    internal static string get_Generate_explicit_conversion_operator_in_0();
    internal static string get_Generate_implicit_conversion_operator_in_0();
    internal static string get_try_block();
    internal static string get_catch_clause();
    internal static string get_filter_clause();
    internal static string get_finally_clause();
    internal static string get_fixed_statement();
    internal static string get_using_statement();
    internal static string get_lock_statement();
    internal static string get_foreach_statement();
    internal static string get_asynchronous_foreach_statement();
    internal static string get_using_declaration();
    internal static string get_asynchronous_using_declaration();
    internal static string get_checked_statement();
    internal static string get_unchecked_statement();
    internal static string get_yield_return_statement();
    internal static string get_yield_break_statement();
    internal static string get_await_expression();
    internal static string get_lambda();
    internal static string get_anonymous_method();
    internal static string get_from_clause();
    internal static string get_join_clause();
    internal static string get_let_clause();
    internal static string get_where_clause();
    internal static string get_orderby_clause();
    internal static string get_select_clause();
    internal static string get_groupby_clause();
    internal static string get_query_body();
    internal static string get_into_clause();
    internal static string get_is_pattern();
    internal static string get_deconstruction();
    internal static string get_tuple();
    internal static string get_local_function();
    internal static string get_out_var();
    internal static string get_ref_local_or_expression();
    internal static string get_switch_statement();
    internal static string get_global_statement();
    internal static string get_extern_alias();
    internal static string get_using_directive();
    internal static string get_struct_();
    internal static string get_event_field();
    internal static string get_conversion_operator();
    internal static string get_destructor();
    internal static string get_indexer();
    internal static string get_property_getter();
    internal static string get_indexer_getter();
    internal static string get_property_setter();
    internal static string get_indexer_setter();
    internal static string get_attribute_target();
    internal static string get__0_does_not_contain_a_constructor_that_takes_that_many_arguments();
    internal static string get_The_name_0_does_not_exist_in_the_current_context();
    internal static string get_Hide_base_member();
    internal static string get_Remove_new_modifier();
    internal static string get_Properties();
    internal static string get_Autoselect_disabled_due_to_namespace_declaration();
    internal static string get_namespace_name();
    internal static string get_Autoselect_disabled_due_to_type_declaration();
    internal static string get_Autoselect_disabled_due_to_possible_deconstruction_declaration();
    internal static string get_Upgrade_this_project_to_csharp_language_version_0();
    internal static string get_Upgrade_all_csharp_projects_to_language_version_0();
    internal static string get_class_name();
    internal static string get_interface_name();
    internal static string get_designation_name();
    internal static string get_struct_name();
    internal static string get_Make_method_async();
    internal static string get_Make_method_async_remain_void();
    internal static string get_Convert_to_switch_statement();
    internal static string get_Convert_to_switch_expression();
    internal static string get_Name();
    internal static string get_Autoselect_disabled_due_to_member_declaration();
    internal static string get_Suggested_name();
    internal static string get_Remove_unused_function();
    internal static string get_Add_parentheses_around_conditional_expression_in_interpolated_string();
    internal static string get_Convert_to_foreach();
    internal static string get_Convert_to_for();
    internal static string get_Allow_unsafe_code_in_this_project();
    internal static string get_Add_Obsolete();
    internal static string get_Convert_to_method();
    internal static string get_Add_remove_braces_for_single_line_control_statements();
    internal static string get_Apply_language_framework_type_preferences();
    internal static string get_Apply_implicit_explicit_type_preferences();
    internal static string get_Apply_this_qualification_preferences();
    internal static string get_Sort_accessibility_modifiers();
    internal static string get_Apply_expression_block_body_preferences();
    internal static string get_Apply_inline_out_variable_preferences();
    internal static string get_Make_private_field_readonly_when_possible();
    internal static string get_Use_0();
    internal static string get_Add_missing_usings();
    internal static string get_Introduce_using_statement();
    internal static string get_Unseal_class_0();
    internal static string get_Make_ref_struct();
    internal static string get_Assign_out_parameters();
    internal static string get_Assign_out_parameters_at_start();
    internal static string get_Warning_Inlining_temporary_into_conditional_method_call();
    internal static string get_Warning_Inlining_temporary_variable_may_change_code_meaning();
    internal static string get_local_variable_declaration();
    internal static string get_switch_statement_case_clause();
    internal static string get_Reverse_for_statement();
    internal static string get_Convert_to_regular_string();
    internal static string get_Convert_to_verbatim_string();
    internal static string get_Assign_to_0();
    internal static string get_Compare_to_0();
    internal static string get_Apply_using_directive_placement_preferences();
    internal static string get_Remove_in_keyword();
    internal static string get_Change_to_as_expression();
    internal static string get_Change_to_cast();
    internal static string get_record_();
}
internal class Microsoft.CodeAnalysis.CSharp.Debugging.BreakpointResolver : AbstractBreakpointResolver {
    public BreakpointResolver(Solution solution, string text);
    protected virtual IEnumerable`1<ISymbol> GetMembers(INamedTypeSymbol type, string name);
    protected virtual bool HasMethodBody(IMethodSymbol method, CancellationToken cancellationToken);
    protected virtual void ParseText(IList`1& nameParts, Nullable`1& parameterCount);
}
[ExportLanguageServiceAttribute("Microsoft.CodeAnalysis.Debugging.IBreakpointResolutionService", "C#", "Default")]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.CSharp.Debugging.CSharpBreakpointResolutionService : object {
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.CSharp.Debugging.CSharpBreakpointResolutionService/<ResolveBreakpointAsync>d__1")]
public sealed virtual Task`1<BreakpointResolutionResult> ResolveBreakpointAsync(Document document, TextSpan textSpan, CancellationToken cancellationToken);
    public sealed virtual Task`1<IEnumerable`1<BreakpointResolutionResult>> ResolveBreakpointsAsync(Solution solution, string name, CancellationToken cancellationToken);
}
[ExportLanguageServiceAttribute("Microsoft.CodeAnalysis.Debugging.ILanguageDebugInfoService", "C#", "Default")]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.CSharp.Debugging.CSharpLanguageDebugInfoService : object {
    public sealed virtual Task`1<DebugLocationInfo> GetLocationInfoAsync(Document document, int position, CancellationToken cancellationToken);
    public sealed virtual Task`1<DebugDataTipInfo> GetDataTipInfoAsync(Document document, int position, CancellationToken cancellationToken);
}
[ExportLanguageServiceAttribute("Microsoft.CodeAnalysis.Debugging.IProximityExpressionsService", "C#", "Default")]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.CSharp.Debugging.CSharpProximityExpressionsService : object {
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.CSharp.Debugging.CSharpProximityExpressionsService/<IsValidAsync>d__1")]
public sealed virtual Task`1<bool> IsValidAsync(Document document, int position, string expressionValue, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.CSharp.Debugging.CSharpProximityExpressionsService/<GetProximityExpressionsAsync>d__2")]
public sealed virtual Task`1<IList`1<string>> GetProximityExpressionsAsync(Document document, int position, CancellationToken cancellationToken);
    public static IList`1<string> GetProximityExpressions(SyntaxTree syntaxTree, int position, CancellationToken cancellationToken);
    [ObsoleteAttribute("Use GetProximityExpressions.")]
private static IList`1<string> Do(SyntaxTree syntaxTree, int position, CancellationToken cancellationToken);
    private static void AddRelevantExpressions(StatementSyntax statement, IList`1<string> expressions, bool includeDeclarations);
    private static string ConvertToString(ExpressionSyntax expression);
    private static void AddExpressionTerms(ExpressionSyntax expression, IList`1<string> terms);
    private static void AddIfValidTerm(ExpressionSyntax expression, ExpressionType type, IList`1<string> terms);
    private static bool IsValidTerm(ExpressionType type);
    private static bool IsValidExpression(ExpressionType type);
    private static void AddSubExpressionTerms(ExpressionSyntax expression, IList`1<string> terms, ExpressionType& expressionType);
    private static void AddCastExpressionTerms(CastExpressionSyntax castExpression, IList`1<string> terms, ExpressionType& expressionType);
    private static void AddMemberAccessExpressionTerms(MemberAccessExpressionSyntax memberAccessExpression, IList`1<string> terms, ExpressionType& expressionType);
    private static void AddObjectCreationExpressionTerms(ObjectCreationExpressionSyntax objectionCreationExpression, IList`1<string> terms, ExpressionType& expressionType);
    private static void AddArrayCreationExpressionTerms(ArrayCreationExpressionSyntax arrayCreationExpression, IList`1<string> terms, ExpressionType& expressionType);
    private static void AddInvocationExpressionTerms(InvocationExpressionSyntax invocationExpression, IList`1<string> terms, ExpressionType& expressionType);
    private static void AddPrefixUnaryExpressionTerms(PrefixUnaryExpressionSyntax prefixUnaryExpression, IList`1<string> terms, ExpressionType& expressionType);
    private static void AddAwaitExpressionTerms(AwaitExpressionSyntax awaitExpression, IList`1<string> terms, ExpressionType& expressionType);
    private static void AddPostfixUnaryExpressionTerms(PostfixUnaryExpressionSyntax postfixUnaryExpression, IList`1<string> terms, ExpressionType& expressionType);
    private static void AddConditionalExpressionTerms(ConditionalExpressionSyntax conditionalExpression, IList`1<string> terms, ExpressionType& expressionType);
    private static void AddBinaryExpressionTerms(ExpressionSyntax binaryExpression, ExpressionSyntax left, ExpressionSyntax right, IList`1<string> terms, ExpressionType& expressionType);
    private static void AddArgumentTerms(ArgumentListSyntax argumentList, IList`1<string> terms, ExpressionType& expressionType);
}
internal static class Microsoft.CodeAnalysis.CSharp.Debugging.DataTipInfoGetter : object {
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.CSharp.Debugging.DataTipInfoGetter/<GetInfoAsync>d__0")]
internal static Task`1<DebugDataTipInfo> GetInfoAsync(Document document, int position, CancellationToken cancellationToken);
}
internal static class Microsoft.CodeAnalysis.CSharp.Debugging.LocationInfoGetter : object {
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.CSharp.Debugging.LocationInfoGetter/<GetInfoAsync>d__0")]
internal static Task`1<DebugLocationInfo> GetInfoAsync(Document document, int position, CancellationToken cancellationToken);
}
[ExportCodeFixProviderAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.CSharp.Diagnostics.AddBraces.CSharpAddBracesCodeFixProvider : SyntaxEditorBasedCodeFixProvider {
    public ImmutableArray`1<string> FixableDiagnosticIds { get; }
    internal CodeFixCategory CodeFixCategory { get; }
    public virtual ImmutableArray`1<string> get_FixableDiagnosticIds();
    internal sealed virtual CodeFixCategory get_CodeFixCategory();
    public sealed virtual Task RegisterCodeFixesAsync(CodeFixContext context);
    protected virtual Task FixAllAsync(Document document, ImmutableArray`1<Diagnostic> diagnostics, SyntaxEditor editor, CancellationToken cancellationToken);
}
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
internal class Microsoft.CodeAnalysis.CSharp.Diagnostics.AddBraces.CSharpAddBracesDiagnosticAnalyzer : AbstractBuiltInCodeStyleDiagnosticAnalyzer {
    protected virtual void InitializeWorker(AnalysisContext context);
    public virtual DiagnosticAnalyzerCategory GetAnalyzerCategory();
    public void AnalyzeNode(SyntaxNodeAnalysisContext context);
    private static bool ContainsInterleavedDirective(SyntaxNode statement, StatementSyntax embeddedStatement, CancellationToken cancellationToken);
    private static bool IsConsideredMultiLine(SyntaxNode statement, SyntaxNode embeddedStatement);
    private static bool RequiresBracesToMatchContext(SyntaxNode statement);
    private static IfStatementSyntax GetOutermostIfStatementOfSequence(SyntaxNode ifStatementOrElseClause);
    private static bool AnyPartOfIfSequenceUsesBraces(IfStatementSyntax statement);
}
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
internal class Microsoft.CodeAnalysis.CSharp.Diagnostics.Analyzers.CSharpPreferFrameworkTypeDiagnosticAnalyzer : PreferFrameworkTypeDiagnosticAnalyzerBase`3<SyntaxKind, ExpressionSyntax, PredefinedTypeSyntax> {
    [CompilerGeneratedAttribute]
private ImmutableArray`1<SyntaxKind> <SyntaxKindsOfInterest>k__BackingField;
    protected ImmutableArray`1<SyntaxKind> SyntaxKindsOfInterest { get; }
    [CompilerGeneratedAttribute]
protected virtual ImmutableArray`1<SyntaxKind> get_SyntaxKindsOfInterest();
    protected virtual bool IsPredefinedTypeReplaceableWithFrameworkType(PredefinedTypeSyntax node);
    protected virtual bool IsInMemberAccessOrCrefReferenceContext(ExpressionSyntax node);
    protected virtual string GetLanguageName();
}
[ExportLanguageServiceAttribute("Microsoft.CodeAnalysis.Diagnostics.IAnalyzerDriverService", "C#", "Default")]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.CSharp.Diagnostics.CSharpAnalyzerDriverService : object {
    public sealed virtual void ComputeDeclarationsInSpan(SemanticModel model, TextSpan span, bool getSymbol, ArrayBuilder`1<DeclarationInfo> builder, CancellationToken cancellationToken);
}
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
internal class Microsoft.CodeAnalysis.CSharp.Diagnostics.CSharpUnboundIdentifiersDiagnosticAnalyzer : UnboundIdentifiersDiagnosticAnalyzerBase`5<SyntaxKind, SimpleNameSyntax, QualifiedNameSyntax, IncompleteMemberSyntax, LambdaExpressionSyntax> {
    private LocalizableString _nameNotInContextMessageFormat;
    private LocalizableString _constructorOverloadResolutionFailureMessageFormat;
    private static ImmutableArray`1<SyntaxKind> s_kindsOfInterest;
    protected ImmutableArray`1<SyntaxKind> SyntaxKindsOfInterest { get; }
    protected DiagnosticDescriptor DiagnosticDescriptor { get; }
    protected DiagnosticDescriptor DiagnosticDescriptor2 { get; }
    private static CSharpUnboundIdentifiersDiagnosticAnalyzer();
    protected virtual ImmutableArray`1<SyntaxKind> get_SyntaxKindsOfInterest();
    protected virtual DiagnosticDescriptor get_DiagnosticDescriptor();
    protected virtual DiagnosticDescriptor get_DiagnosticDescriptor2();
    protected virtual bool ConstructorDoesNotExist(SyntaxNode node, SymbolInfo info, SemanticModel model);
    protected virtual bool IsNameOf(SyntaxNode node);
}
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
internal class Microsoft.CodeAnalysis.CSharp.Diagnostics.NamingStyles.CSharpNamingStyleDiagnosticAnalyzer : NamingStyleDiagnosticAnalyzerBase`1<SyntaxKind> {
    [CompilerGeneratedAttribute]
private ImmutableArray`1<SyntaxKind> <SupportedSyntaxKinds>k__BackingField;
    protected ImmutableArray`1<SyntaxKind> SupportedSyntaxKinds { get; }
    [CompilerGeneratedAttribute]
protected virtual ImmutableArray`1<SyntaxKind> get_SupportedSyntaxKinds();
    [NullableContextAttribute("1")]
protected virtual bool ShouldIgnore(ISymbol symbol);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
internal class Microsoft.CodeAnalysis.CSharp.Diagnostics.SimplifyTypeNames.CSharpSimplifyTypeNamesDiagnosticAnalyzer : SimplifyTypeNamesDiagnosticAnalyzerBase`1<SyntaxKind> {
    [NullableAttribute("0")]
private static ImmutableArray`1<SyntaxKind> s_kindsOfInterest;
    private static CSharpSimplifyTypeNamesDiagnosticAnalyzer();
    protected virtual bool IsIgnoredCodeBlock(SyntaxNode codeBlock);
    protected virtual ImmutableArray`1<Diagnostic> AnalyzeCodeBlock(CodeBlockAnalysisContext context);
    [NullableContextAttribute("2")]
protected virtual ImmutableArray`1<Diagnostic> AnalyzeSemanticModel(SemanticModelAnalysisContext context, SimpleIntervalTree`2<TextSpan, TextSpanIntervalIntrospector> codeBlockIntervalTree);
    internal virtual bool IsCandidate(SyntaxNode node);
    internal virtual bool CanSimplifyTypeNameExpression(SemanticModel model, SyntaxNode node, OptionSet optionSet, TextSpan& issueSpan, String& diagnosticId, Boolean& inDeclaration, CancellationToken cancellationToken);
    protected virtual string GetLanguageName();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.CodeAnalysis.CSharp.Diagnostics.SimplifyTypeNames.TypeSyntaxSimplifierWalker : CSharpSyntaxWalker {
    private static ImmutableHashSet`1<string> s_emptyAliasedNames;
    private static ImmutableHashSet`1<string> s_predefinedTypeMetadataNames;
    private CSharpSimplifyTypeNamesDiagnosticAnalyzer _analyzer;
    private SemanticModel _semanticModel;
    private OptionSet _optionSet;
    [NullableAttribute("2")]
private SimpleIntervalTree`2<TextSpan, TextSpanIntervalIntrospector> _ignoredSpans;
    private CancellationToken _cancellationToken;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private Builder<Diagnostic> _diagnostics;
    private ImmutableHashSet`1<string> _aliasedNames;
    public bool HasDiagnostics { get; }
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ImmutableArray`1<Diagnostic> Diagnostics { get; }
    public Builder<Diagnostic> DiagnosticsBuilder { get; }
    public TypeSyntaxSimplifierWalker(CSharpSimplifyTypeNamesDiagnosticAnalyzer analyzer, SemanticModel semanticModel, OptionSet optionSet, SimpleIntervalTree`2<TextSpan, TextSpanIntervalIntrospector> ignoredSpans, CancellationToken cancellationToken);
    private static TypeSyntaxSimplifierWalker();
    public bool get_HasDiagnostics();
    public ImmutableArray`1<Diagnostic> get_Diagnostics();
    public Builder<Diagnostic> get_DiagnosticsBuilder();
    private static ImmutableHashSet`1<string> GetAliasedNames(CompilationUnitSyntax compilationUnit);
    public virtual void VisitQualifiedName(QualifiedNameSyntax node);
    public virtual void VisitAliasQualifiedName(AliasQualifiedNameSyntax node);
    public virtual void VisitGenericName(GenericNameSyntax node);
    public virtual void VisitIdentifierName(IdentifierNameSyntax node);
    public virtual void VisitMemberAccessExpression(MemberAccessExpressionSyntax node);
    public virtual void VisitQualifiedCref(QualifiedCrefSyntax node);
    private bool TrySimplify(SyntaxNode node);
    [CompilerGeneratedAttribute]
internal static void <GetAliasedNames>g__AddAliasedName|16_0(UsingDirectiveSyntax usingDirective, <>c__DisplayClass16_0& );
    [CompilerGeneratedAttribute]
internal static void <GetAliasedNames>g__AddAliasedNames|16_1(NamespaceDeclarationSyntax namespaceDeclaration, <>c__DisplayClass16_0& );
    [CompilerGeneratedAttribute]
private bool <VisitIdentifierName>g__CanReplaceIdentifierWithAlias|20_0(string identifier);
    [CompilerGeneratedAttribute]
internal static bool <VisitIdentifierName>g__CanReplaceIdentifierWithPredefinedType|20_1(string identifier);
}
internal abstract class Microsoft.CodeAnalysis.CSharp.Diagnostics.TypeStyle.CSharpTypeStyleDiagnosticAnalyzerBase : AbstractBuiltInCodeStyleDiagnosticAnalyzer {
    protected CSharpTypeStyleHelper Helper { get; }
    protected CSharpTypeStyleDiagnosticAnalyzerBase(string diagnosticId, EnforceOnBuild enforceOnBuild, LocalizableString title, LocalizableString message);
    protected abstract virtual CSharpTypeStyleHelper get_Helper();
    public virtual DiagnosticAnalyzerCategory GetAnalyzerCategory();
    public virtual bool OpenFileOnly(OptionSet options);
    protected virtual void InitializeWorker(AnalysisContext context);
    private void HandleVariableDeclaration(SyntaxNodeAnalysisContext context);
    private static Diagnostic CreateDiagnostic(DiagnosticDescriptor descriptor, SyntaxNode declaration, TextSpan diagnosticSpan, ReportDiagnostic severity);
}
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
internal class Microsoft.CodeAnalysis.CSharp.Diagnostics.TypeStyle.CSharpUseExplicitTypeDiagnosticAnalyzer : CSharpTypeStyleDiagnosticAnalyzerBase {
    private static LocalizableString s_Title;
    private static LocalizableString s_Message;
    protected CSharpTypeStyleHelper Helper { get; }
    private static CSharpUseExplicitTypeDiagnosticAnalyzer();
    protected virtual CSharpTypeStyleHelper get_Helper();
}
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
internal class Microsoft.CodeAnalysis.CSharp.Diagnostics.TypeStyle.CSharpUseImplicitTypeDiagnosticAnalyzer : CSharpTypeStyleDiagnosticAnalyzerBase {
    private static LocalizableString s_Title;
    private static LocalizableString s_Message;
    protected CSharpTypeStyleHelper Helper { get; }
    private static CSharpUseImplicitTypeDiagnosticAnalyzer();
    protected virtual CSharpTypeStyleHelper get_Helper();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExportCodeFixProviderAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.CSharp.DisambiguateSameVariable.CSharpDisambiguateSameVariableCodeFixProvider : SyntaxEditorBasedCodeFixProvider {
    private static string CS1717;
    private static string CS1718;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private ImmutableArray`1<string> <FixableDiagnosticIds>k__BackingField;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ImmutableArray`1<string> FixableDiagnosticIds { get; }
    internal CodeFixCategory CodeFixCategory { get; }
    [CompilerGeneratedAttribute]
public virtual ImmutableArray`1<string> get_FixableDiagnosticIds();
    internal virtual CodeFixCategory get_CodeFixCategory();
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.CSharp.DisambiguateSameVariable.CSharpDisambiguateSameVariableCodeFixProvider/<RegisterCodeFixesAsync>d__8")]
public virtual Task RegisterCodeFixesAsync(CodeFixContext context);
    [NullableContextAttribute("2")]
private static bool CanFix(SemanticModel semanticModel, Diagnostic diagnostic, CancellationToken cancellationToken, SimpleNameSyntax& leftName, ISymbol& matchingMember, String& title);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.CSharp.DisambiguateSameVariable.CSharpDisambiguateSameVariableCodeFixProvider/<FixAllAsync>d__10")]
protected virtual Task FixAllAsync(Document document, ImmutableArray`1<Diagnostic> diagnostics, SyntaxEditor editor, CancellationToken cancellationToken);
}
[ExportLanguageServiceAttribute("Microsoft.CodeAnalysis.DocumentationComments.IDocumentationCommentFormattingService", "C#", "Default")]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.CSharp.DocumentationComments.CSharpDocumentationCommentFormattingService : AbstractDocumentationCommentFormattingService {
}
internal class Microsoft.CodeAnalysis.CSharp.DocumentationComments.DocCommentConverter : CSharpSyntaxRewriter {
    private IDocumentationCommentFormattingService _formattingService;
    private CancellationToken _cancellationToken;
    private DocCommentConverter(IDocumentationCommentFormattingService formattingService, CancellationToken cancellationToken);
    public static SyntaxNode ConvertToRegularComments(SyntaxNode node, IDocumentationCommentFormattingService formattingService, CancellationToken cancellationToken);
    public virtual SyntaxNode Visit(SyntaxNode node);
    [IteratorStateMachineAttribute("Microsoft.CodeAnalysis.CSharp.DocumentationComments.DocCommentConverter/<ConvertDocCommentToRegularComment>d__5")]
private IEnumerable`1<SyntaxTrivia> ConvertDocCommentToRegularComment(DocumentationCommentTriviaSyntax structuredTrivia);
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[ExportLanguageServiceAttribute("Microsoft.CodeAnalysis.DocumentationComments.IDocumentationCommentSnippetService", "C#", "Default")]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.CSharp.DocumentationComments.DocumentationCommentSnippetService : AbstractDocumentationCommentSnippetService`2<DocumentationCommentTriviaSyntax, MemberDeclarationSyntax> {
    public string DocumentationCommentCharacter { get; }
    protected bool AddIndent { get; }
    protected string ExteriorTriviaText { get; }
    public virtual string get_DocumentationCommentCharacter();
    protected virtual bool get_AddIndent();
    protected virtual string get_ExteriorTriviaText();
    protected virtual MemberDeclarationSyntax GetContainingMember(SyntaxTree syntaxTree, int position, CancellationToken cancellationToken);
    protected virtual bool SupportsDocumentationComments(MemberDeclarationSyntax member);
    protected virtual bool HasDocumentationComment(MemberDeclarationSyntax member);
    protected virtual int GetPrecedingDocumentationCommentCount(MemberDeclarationSyntax member);
    protected virtual bool IsMemberDeclaration(MemberDeclarationSyntax member);
    protected virtual List`1<string> GetDocumentationCommentStubLines(MemberDeclarationSyntax member);
    protected virtual SyntaxToken GetTokenToRight(SyntaxTree syntaxTree, int position, CancellationToken cancellationToken);
    protected virtual SyntaxToken GetTokenToLeft(SyntaxTree syntaxTree, int position, CancellationToken cancellationToken);
    protected virtual bool IsDocCommentNewLine(SyntaxToken token);
    protected virtual bool IsEndOfLineTrivia(SyntaxTrivia trivia);
    protected virtual bool IsSingleExteriorTrivia(DocumentationCommentTriviaSyntax documentationComment, bool allowWhitespace);
    private static IList`1<SyntaxToken> GetTextTokensFollowingExteriorTrivia(XmlTextSyntax xmlText);
    [NullableContextAttribute("2")]
protected virtual bool EndsWithSingleExteriorTrivia(DocumentationCommentTriviaSyntax documentationComment);
    [NullableContextAttribute("2")]
protected virtual bool IsMultilineDocComment(DocumentationCommentTriviaSyntax documentationComment);
    protected virtual bool HasSkippedTrailingTrivia(SyntaxToken token);
}
[ExportLanguageServiceAttribute("Microsoft.CodeAnalysis.DocumentHighlighting.IDocumentHighlightsService", "C#", "Default")]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.CSharp.DocumentHighlighting.CSharpDocumentHighlightsService : AbstractDocumentHighlightsService {
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.CSharp.DocumentHighlighting.CSharpDocumentHighlightsService/<GetAdditionalReferencesAsync>d__1")]
protected virtual Task`1<ImmutableArray`1<Location>> GetAdditionalReferencesAsync(Document document, ISymbol symbol, CancellationToken cancellationToken);
}
internal static class Microsoft.CodeAnalysis.CSharp.EditAndContinue.BreakpointSpans : object {
    public static bool TryGetBreakpointSpan(SyntaxTree tree, int position, CancellationToken cancellationToken, TextSpan& breakpointSpan);
    private static bool IsBlank(TextLine line);
    public static bool TryGetClosestBreakpointSpan(SyntaxNode root, int position, TextSpan& span);
    private static TextSpan CreateSpan(SyntaxToken startToken, SyntaxToken endToken);
    private static TextSpan CreateSpan(SyntaxNode node);
    private static TextSpan CreateSpan(SyntaxNode node, SyntaxToken token);
    private static TextSpan CreateSpan(SyntaxToken token);
    private static TextSpan CreateSpan(SyntaxTokenList startOpt, SyntaxNodeOrToken startFallbackOpt, SyntaxNodeOrToken endOpt);
    private static int GetEndPosition(SyntaxNodeOrToken nodeOrToken);
    private static Nullable`1<TextSpan> TryCreateSpanForNode(SyntaxNode node, int position);
    private static TextSpan CreateSpanForConstructorDeclaration(ConstructorDeclarationSyntax constructorSyntax);
    private static TextSpan CreateSpanForConstructorInitializer(ConstructorInitializerSyntax constructorInitializer);
    private static Nullable`1<TextSpan> TryCreateSpanForFieldDeclaration(BaseFieldDeclarationSyntax fieldDeclaration, int position);
    private static Nullable`1<TextSpan> TryCreateSpanForSwitchLabel(SwitchLabelSyntax switchLabel, int position);
    private static TextSpan CreateSpanForBlock(BlockSyntax block, int position);
    private static Nullable`1<TextSpan> TryCreateSpanForStatement(StatementSyntax statement, int position);
    private static SyntaxToken LastNotMissing(SyntaxToken token1, SyntaxToken token2);
    private static Nullable`1<TextSpan> TryCreateSpanForVariableDeclaration(VariableDeclarationSyntax declaration, int position);
    private static Nullable`1<TextSpan> TryCreateSpanForVariableDeclaration(VariableDeclarationSyntax variableDeclaration, SyntaxTokenList modifiersOpt, SyntaxToken semicolonOpt, int position);
    private static VariableDeclaratorSyntax FindClosestDeclaratorWithInitializer(SeparatedSyntaxList`1<VariableDeclaratorSyntax> declarators, int position);
    private static int GetItemIndexByPosition(SeparatedSyntaxList`1<TNode> list, int position);
    private static TextSpan CreateSpanForCatchClause(CatchClauseSyntax catchClause);
    private static bool IsBreakableExpression(ExpressionSyntax expression);
    private static Nullable`1<TextSpan> CreateSpanForAccessors(SyntaxList`1<AccessorDeclarationSyntax> accessors, int position);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.CodeAnalysis.CSharp.EditAndContinue.CSharpEditAndContinueAnalyzer : AbstractEditAndContinueAnalyzer {
    internal SyntaxNode EmptyCompilationUnit { get; }
    protected SymbolDisplayFormat ErrorDisplayFormat { get; }
    public CSharpEditAndContinueAnalyzer(Action`1<SyntaxNode> testFaultInjector);
    [NullableContextAttribute("2")]
internal virtual SyntaxNode FindMemberDeclaration(SyntaxNode root, SyntaxNode node);
    internal virtual SyntaxNode TryGetDeclarationBody(SyntaxNode node);
    protected virtual ImmutableArray`1<ISymbol> GetCapturedVariables(SemanticModel model, SyntaxNode memberBody);
    internal virtual bool HasParameterClosureScope(ISymbol member);
    protected virtual IEnumerable`1<SyntaxNode> GetVariableUseSites(IEnumerable`1<SyntaxNode> roots, ISymbol localOrParameter, SemanticModel model, CancellationToken cancellationToken);
    internal virtual IEnumerable`1<SyntaxToken> TryGetActiveTokens(SyntaxNode node);
    protected virtual SyntaxNode GetEncompassingAncestorImpl(SyntaxNode bodyOrMatchRoot);
    protected virtual SyntaxNode FindStatementAndPartner(SyntaxNode declarationBody, TextSpan span, SyntaxNode partnerDeclarationBody, SyntaxNode& partner, Int32& statementPart);
    private static BlockPart GetStatementPart(BlockSyntax node, int position);
    private static TextSpan GetActiveSpan(BlockSyntax node, BlockPart part);
    private static ForEachPart GetStatementPart(CommonForEachStatementSyntax node, int position);
    private static TextSpan GetActiveSpan(ForEachStatementSyntax node, ForEachPart part);
    private static TextSpan GetActiveSpan(ForEachVariableStatementSyntax node, ForEachPart part);
    private static TextSpan GetActiveSpan(SwitchExpressionSyntax node, SwitchExpressionPart part);
    protected virtual bool AreEquivalent(SyntaxNode left, SyntaxNode right);
    private static bool AreEquivalentIgnoringLambdaBodies(SyntaxNode left, SyntaxNode right);
    internal virtual SyntaxNode FindPartner(SyntaxNode leftRoot, SyntaxNode rightRoot, SyntaxNode leftNode);
    internal virtual SyntaxNode FindPartnerInMemberInitializer(SemanticModel leftModel, INamedTypeSymbol leftType, SyntaxNode leftNode, INamedTypeSymbol rightType, CancellationToken cancellationToken);
    internal virtual bool IsClosureScope(SyntaxNode node);
    [NullableContextAttribute("2")]
protected virtual SyntaxNode FindEnclosingLambdaBody(SyntaxNode container, SyntaxNode node);
    protected virtual IEnumerable`1<SyntaxNode> GetLambdaBodyExpressionsAndStatements(SyntaxNode lambdaBody);
    protected virtual SyntaxNode TryGetPartnerLambdaBody(SyntaxNode oldBody, SyntaxNode newLambda);
    protected virtual Match`1<SyntaxNode> ComputeTopLevelMatch(SyntaxNode oldCompilationUnit, SyntaxNode newCompilationUnit);
    protected virtual Match`1<SyntaxNode> ComputeTopLevelDeclarationMatch(SyntaxNode oldDeclaration, SyntaxNode newDeclaration);
    protected virtual Match`1<SyntaxNode> ComputeBodyMatch(SyntaxNode oldBody, SyntaxNode newBody, IEnumerable`1<KeyValuePair`2<SyntaxNode, SyntaxNode>> knownMatches);
    [IteratorStateMachineAttribute("Microsoft.CodeAnalysis.CSharp.EditAndContinue.CSharpEditAndContinueAnalyzer/<GetChildNodes>d__30")]
private static IEnumerable`1<SyntaxNode> GetChildNodes(SyntaxNode root, SyntaxNode body);
    internal virtual void ReportDeclarationInsertDeleteRudeEdits(ArrayBuilder`1<RudeEditDiagnostic> diagnostics, SyntaxNode oldNode, SyntaxNode newNode, ISymbol oldSymbol, ISymbol newSymbol);
    protected virtual void ReportLocalFunctionsDeclarationRudeEdits(ArrayBuilder`1<RudeEditDiagnostic> diagnostics, Match`1<SyntaxNode> bodyMatch);
    protected virtual bool TryMatchActiveStatement(SyntaxNode oldStatement, int statementPart, SyntaxNode oldBody, SyntaxNode newBody, SyntaxNode& newStatement);
    protected virtual IEnumerable`1<SequenceEdit> GetSyntaxSequenceEdits(ImmutableArray`1<SyntaxNode> oldNodes, ImmutableArray`1<SyntaxNode> newNodes);
    internal virtual SyntaxNode get_EmptyCompilationUnit();
    internal virtual bool ExperimentalFeaturesEnabled(SyntaxTree tree);
    protected virtual bool StateMachineSuspensionPointKindEquals(SyntaxNode suspensionPoint1, SyntaxNode suspensionPoint2);
    protected virtual bool StatementLabelEquals(SyntaxNode node1, SyntaxNode node2);
    protected virtual bool TryGetEnclosingBreakpointSpan(SyntaxNode root, int position, TextSpan& span);
    protected virtual bool TryGetActiveSpan(SyntaxNode node, int statementPart, int minLength, TextSpan& span);
    [IteratorStateMachineAttribute("Microsoft.CodeAnalysis.CSharp.EditAndContinue.CSharpEditAndContinueAnalyzer/<EnumerateNearStatements>d__42")]
protected virtual IEnumerable`1<ValueTuple`2<SyntaxNode, int>> EnumerateNearStatements(SyntaxNode statement);
    protected virtual bool AreEquivalentActiveStatements(SyntaxNode oldStatement, SyntaxNode newStatement, int statementPart);
    private static bool HasEquivalentUsingDeclarations(BlockSyntax oldBlock, BlockSyntax newBlock);
    private static bool AreEquivalentActiveStatements(IfStatementSyntax oldNode, IfStatementSyntax newNode);
    private static bool AreEquivalentActiveStatements(WhileStatementSyntax oldNode, WhileStatementSyntax newNode);
    private static bool AreEquivalentActiveStatements(DoStatementSyntax oldNode, DoStatementSyntax newNode);
    private static bool AreEquivalentActiveStatements(SwitchStatementSyntax oldNode, SwitchStatementSyntax newNode);
    private static bool AreEquivalentActiveStatements(LockStatementSyntax oldNode, LockStatementSyntax newNode);
    private static bool AreEquivalentActiveStatements(FixedStatementSyntax oldNode, FixedStatementSyntax newNode);
    private static bool AreEquivalentActiveStatements(UsingStatementSyntax oldNode, UsingStatementSyntax newNode);
    private static bool AreEquivalentActiveStatements(CommonForEachStatementSyntax oldNode, CommonForEachStatementSyntax newNode);
    private static bool AreSimilarActiveStatements(CommonForEachStatementSyntax oldNode, CommonForEachStatementSyntax newNode);
    internal virtual bool IsInterfaceDeclaration(SyntaxNode node);
    internal virtual bool IsRecordDeclaration(SyntaxNode node);
    internal virtual SyntaxNode TryGetContainingTypeDeclaration(SyntaxNode node);
    internal virtual bool HasBackingField(SyntaxNode propertyOrIndexerDeclaration);
    internal virtual SyntaxNode TryGetAssociatedMemberDeclaration(SyntaxNode node);
    internal virtual bool IsDeclarationWithInitializer(SyntaxNode declaration);
    internal virtual bool IsRecordPrimaryConstructorParameter(SyntaxNode declaration);
    private static bool IsPropertyDeclarationMatchingPrimaryConstructorParameter(SyntaxNode declaration, INamedTypeSymbol newContainingType);
    internal virtual bool IsPropertyAccessorDeclarationMatchingPrimaryConstructorParameter(SyntaxNode declaration, INamedTypeSymbol newContainingType, Boolean& isFirstAccessor);
    internal virtual bool IsConstructorWithMemberInitializers(SyntaxNode constructorDeclaration);
    internal virtual bool IsPartial(INamedTypeSymbol type);
    protected virtual SyntaxNode GetSymbolDeclarationSyntax(SyntaxReference reference, CancellationToken cancellationToken);
    protected virtual ISymbol GetSymbolForEdit(SemanticModel model, SyntaxNode node, EditKind editKind, IReadOnlyDictionary`2<SyntaxNode, EditKind> editMap, Boolean& isAmbiguous, CancellationToken cancellationToken);
    protected virtual void GetUpdatedDeclarationBodies(SyntaxNode oldDeclaration, SyntaxNode newDeclaration, SyntaxNode& oldBody, SyntaxNode& newBody);
    private static bool IsGetterToExpressionBodyTransformation(EditKind editKind, SyntaxNode node, IReadOnlyDictionary`2<SyntaxNode, EditKind> editMap);
    internal virtual bool ContainsLambda(SyntaxNode declaration);
    internal virtual bool IsLambda(SyntaxNode node);
    internal virtual bool IsLocalFunction(SyntaxNode node);
    internal virtual bool IsNestedFunction(SyntaxNode node);
    [NullableContextAttribute("2")]
internal virtual bool TryGetLambdaBodies(SyntaxNode node, SyntaxNode& body1, SyntaxNode& body2);
    internal virtual SyntaxNode GetLambda(SyntaxNode lambdaBody);
    internal virtual IMethodSymbol GetLambdaExpressionSymbol(SemanticModel model, SyntaxNode lambdaExpression, CancellationToken cancellationToken);
    internal virtual SyntaxNode GetContainingQueryExpression(SyntaxNode node);
    internal virtual bool QueryClauseLambdasTypeEquivalent(SemanticModel oldModel, SyntaxNode oldNode, SemanticModel newModel, SyntaxNode newNode, CancellationToken cancellationToken);
    protected virtual void ReportLambdaSignatureRudeEdits(SemanticModel oldModel, SyntaxNode oldLambdaBody, SemanticModel newModel, SyntaxNode newLambdaBody, ArrayBuilder`1<RudeEditDiagnostic> diagnostics, Boolean& hasErrors, CancellationToken cancellationToken);
    private static bool IsLocalFunctionBody(SyntaxNode lambdaBody);
    private static bool GroupBySignatureComparer(ImmutableArray`1<IParameterSymbol> oldParameters, ITypeSymbol oldReturnType, ImmutableArray`1<IParameterSymbol> newParameters, ITypeSymbol newReturnType);
    protected virtual SymbolDisplayFormat get_ErrorDisplayFormat();
    protected virtual Nullable`1<TextSpan> TryGetDiagnosticSpan(SyntaxNode node, EditKind editKind);
    internal static TextSpan GetDiagnosticSpan(SyntaxNode node, EditKind editKind);
    private static Nullable`1<TextSpan> TryGetDiagnosticSpanImpl(SyntaxNode node, EditKind editKind);
    internal static Nullable`1<TextSpan> TryGetDiagnosticSpanImpl(SyntaxKind kind, SyntaxNode node, EditKind editKind);
    private static TextSpan GetDiagnosticSpan(SyntaxTokenList modifiers, SyntaxNodeOrToken start, SyntaxNodeOrToken end);
    private static TextSpan CombineSpans(TextSpan first, TextSpan second, TextSpan defaultSpan);
    internal virtual TextSpan GetLambdaParameterDiagnosticSpan(SyntaxNode lambda, int ordinal);
    protected virtual string TryGetDisplayName(SyntaxNode node, EditKind editKind);
    internal static string GetDisplayName(SyntaxNode node, EditKind editKind);
    internal static string TryGetDisplayNameImpl(SyntaxNode node, EditKind editKind);
    protected virtual string GetSuspensionPointDisplayName(SyntaxNode node, EditKind editKind);
    internal virtual void ReportTopLevelSyntacticRudeEdits(ArrayBuilder`1<RudeEditDiagnostic> diagnostics, Match`1<SyntaxNode> match, Edit`1<SyntaxNode> edit, Dictionary`2<SyntaxNode, EditKind> editMap);
    internal virtual void ReportMemberUpdateRudeEdits(ArrayBuilder`1<RudeEditDiagnostic> diagnostics, SyntaxNode newMember, Nullable`1<TextSpan> span);
    internal virtual void ReportInsertedMemberSymbolRudeEdits(ArrayBuilder`1<RudeEditDiagnostic> diagnostics, ISymbol newSymbol, SyntaxNode newNode, bool insertingIntoExistingContainingType);
    internal virtual void ReportTypeDeclarationInsertDeleteRudeEdits(ArrayBuilder`1<RudeEditDiagnostic> diagnostics, INamedTypeSymbol oldType, INamedTypeSymbol newType, SyntaxNode newDeclaration, CancellationToken cancellationToken);
    protected virtual List`1<SyntaxNode> GetExceptionHandlingAncestors(SyntaxNode node, bool isNonLeaf);
    internal virtual void ReportEnclosingExceptionHandlingRudeEdits(ArrayBuilder`1<RudeEditDiagnostic> diagnostics, IEnumerable`1<Edit`1<SyntaxNode>> exceptionHandlingEdits, SyntaxNode oldStatement, TextSpan newStatementSpan);
    private static bool AreExceptionClausesEquivalent(SyntaxNode oldNode, SyntaxNode newNode);
    protected virtual TextSpan GetExceptionHandlingRegion(SyntaxNode node, Boolean& coversAllChildren);
    internal virtual bool IsStateMachineMethod(SyntaxNode declaration);
    protected virtual void GetStateMachineInfo(SyntaxNode body, ImmutableArray`1& suspensionPoints, StateMachineKinds& kinds);
    internal virtual void ReportStateMachineSuspensionPointRudeEdits(ArrayBuilder`1<RudeEditDiagnostic> diagnostics, SyntaxNode oldNode, SyntaxNode newNode);
    internal virtual void ReportStateMachineSuspensionPointDeletedRudeEdit(ArrayBuilder`1<RudeEditDiagnostic> diagnostics, Match`1<SyntaxNode> match, SyntaxNode deletedSuspensionPoint);
    internal virtual void ReportStateMachineSuspensionPointInsertedRudeEdit(ArrayBuilder`1<RudeEditDiagnostic> diagnostics, Match`1<SyntaxNode> match, SyntaxNode insertedSuspensionPoint, bool aroundActiveStatement);
    private static SyntaxNode FindContainingStatementPart(SyntaxNode node);
    private static bool HasNoSpilledState(SyntaxNode awaitExpression, SyntaxNode containingStatementPart);
    private static ExpressionSyntax GetExpressionFromStatementPart(SyntaxNode statement);
    private static bool IsSimpleAwaitAssignment(SyntaxNode node, SyntaxNode awaitExpression);
    internal virtual void ReportOtherRudeEditsAroundActiveStatement(ArrayBuilder`1<RudeEditDiagnostic> diagnostics, Match`1<SyntaxNode> match, SyntaxNode oldActiveStatement, SyntaxNode newActiveStatement, bool isNonLeaf);
    private void ReportRudeEditsForSwitchWhenClauses(ArrayBuilder`1<RudeEditDiagnostic> diagnostics, SyntaxNode oldActiveStatement, SyntaxNode newActiveStatement);
    private static bool AreEquivalentSwitchStatementDecisionTrees(SwitchStatementSyntax oldSwitch, SwitchStatementSyntax newSwitch);
    private static bool AreSwitchSectionsEquivalent(SwitchSectionSyntax oldSection, SwitchSectionSyntax newSection);
    private static bool AreLabelsEquivalent(SwitchLabelSyntax oldLabel, SwitchLabelSyntax newLabel);
    private void ReportRudeEditsForCheckedStatements(ArrayBuilder`1<RudeEditDiagnostic> diagnostics, SyntaxNode oldActiveStatement, SyntaxNode newActiveStatement, bool isNonLeaf);
    [NullableContextAttribute("2")]
private static CheckedStatementSyntax TryGetCheckedStatementAncestor(SyntaxNode node);
    private void ReportRudeEditsForAncestorsDeclaringInterStatementTemps(ArrayBuilder`1<RudeEditDiagnostic> diagnostics, Match`1<SyntaxNode> match, SyntaxNode oldActiveStatement, SyntaxNode newActiveStatement);
    private static bool DeclareSameIdentifiers(SeparatedSyntaxList`1<VariableDeclaratorSyntax> oldVariables, SeparatedSyntaxList`1<VariableDeclaratorSyntax> newVariables);
    private static bool DeclareSameIdentifiers(SyntaxToken[] oldVariables, SyntaxToken[] newVariables);
    [CompilerGeneratedAttribute]
internal static SyntaxNode <ComputeBodyMatch>g__GetMatchingRoot|29_0(SyntaxNode body);
    [CompilerGeneratedAttribute]
internal static void <ReportTypeDeclarationInsertDeleteRudeEdits>g__Report|98_4(Action`2<ArrayBuilder`1<SyntaxNode>, TypeDeclarationSyntax> addNodes, RudeEditKind rudeEditKind, <>c__DisplayClass98_0& );
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.CodeAnalysis.CSharp.EditAndContinue.SyntaxComparer : AbstractSyntaxComparer {
    internal static SyntaxComparer TopLevel;
    internal static SyntaxComparer Statement;
    protected internal int LabelCount { get; }
    [NullableContextAttribute("2")]
public SyntaxComparer(SyntaxNode oldRoot, SyntaxNode newRoot, IEnumerable`1<SyntaxNode> oldRootChildren, IEnumerable`1<SyntaxNode> newRootChildren, bool compareStatementSyntax);
    private static SyntaxComparer();
    protected virtual bool IsLambdaBodyStatementOrExpression(SyntaxNode node);
    private static int TiedToAncestor(Label label);
    [NullableContextAttribute("2")]
internal virtual int Classify(int kind, SyntaxNode node, Boolean& isLeaf);
    [NullableContextAttribute("2")]
internal Label Classify(SyntaxKind kind, SyntaxNode node, Boolean& isLeaf);
    [NullableContextAttribute("2")]
private static Label ClassifyStatementSyntax(SyntaxKind kind, SyntaxNode node, Boolean& isLeaf);
    private static Label ClassifyTopSyntax(SyntaxKind kind, Boolean& isLeaf);
    internal bool HasLabel(SyntaxKind kind);
    protected internal virtual int get_LabelCount();
    protected internal virtual int TiedToAncestor(int label);
    public virtual bool ValuesEqual(SyntaxNode left, SyntaxNode right);
    private bool Equal(SwitchSectionSyntax left, SwitchSectionSyntax right);
    private static SyntaxNode GetBody(SyntaxNode node);
    protected virtual bool TryComputeWeightedDistance(SyntaxNode leftNode, SyntaxNode rightNode, Double& distance);
    private static double ComputeWeightedDistanceOfNestedFunctions(SyntaxNode leftNode, SyntaxNode rightNode);
    private static void GetNestedFunctionsParts(SyntaxNode nestedFunction, IEnumerable`1& parameters, SyntaxToken& asyncKeyword, SyntaxNode& body, SyntaxTokenList& modifiers, TypeSyntax& returnType, SyntaxToken& identifier, TypeParameterListSyntax& typeParameters);
    private bool TryComputeWeightedDistance(BlockSyntax leftBlock, BlockSyntax rightBlock, Double& distance);
    private double ComputeWeightedDistance(SingleVariableDesignationSyntax leftNode, SingleVariableDesignationSyntax rightNode);
    private static double ComputeWeightedBlockDistance(BlockSyntax leftBlock, BlockSyntax rightBlock);
    private static double ComputeWeightedDistance(CatchClauseSyntax left, CatchClauseSyntax right);
    private static double ComputeWeightedDistance(CommonForEachStatementSyntax leftCommonForEach, CommonForEachStatementSyntax rightCommonForEach);
    private static double ComputeWeightedDistance(ForStatementSyntax left, ForStatementSyntax right);
    private static double ComputeWeightedDistance(VariableDeclarationSyntax leftVariables, StatementSyntax leftStatement, VariableDeclarationSyntax rightVariables, StatementSyntax rightStatement);
    private static double ComputeWeightedDistance(SyntaxNode leftHeader, StatementSyntax leftStatement, SyntaxNode rightHeader, StatementSyntax rightStatement);
    private static double AdjustForLocalsInBlock(double distance, StatementSyntax leftStatement, StatementSyntax rightStatement, double localsWeight);
    [NullableContextAttribute("2")]
private static bool TryComputeLocalsDistance(VariableDeclarationSyntax left, VariableDeclarationSyntax right, Double& distance);
    private static bool TryComputeLocalsDistance(BlockSyntax left, BlockSyntax right, Double& distance);
    private static void GetLocalNames(BlockSyntax block, List`1& result);
    private static void GetLocalNames(VariableDeclarationSyntax localDeclaration, List`1& result);
    internal static void GetLocalNames(CommonForEachStatementSyntax commonForEach, List`1& result);
    private static void GetLocalNames(ExpressionSyntax expression, List`1& result);
    private static void GetLocalNames(VariableDesignationSyntax designation, List`1& result);
    [NullableContextAttribute("2")]
private static void GetLocalNames(SyntaxToken syntaxToken, List`1& result);
    [NullableContextAttribute("2")]
private static double CombineOptional(double distance0, SyntaxNode left1, SyntaxNode right1, SyntaxNode left2, SyntaxNode right2, double weight0, double weight1);
    private static Nullable`1<SyntaxNodeOrToken> TryGetName(SyntaxNode node);
    public sealed virtual double GetDistance(SyntaxNode oldNode, SyntaxNode newNode);
    [NullableContextAttribute("2")]
internal static double ComputeValueDistance(SyntaxNode oldNode, SyntaxNode newNode);
    internal static double ComputeDistance(SyntaxNodeOrToken oldNodeOrToken, SyntaxNodeOrToken newNodeOrToken);
    [IteratorStateMachineAttribute("Microsoft.CodeAnalysis.CSharp.EditAndContinue.SyntaxComparer/<GetDescendantTokensIgnoringSeparators>d__42`1")]
internal static IEnumerable`1<SyntaxToken> GetDescendantTokensIgnoringSeparators(SeparatedSyntaxList`1<TSyntaxNode> list);
    [NullableContextAttribute("2")]
public static double ComputeDistance(SyntaxNode oldNode, SyntaxNode newNode);
    public static double ComputeDistance(SyntaxToken oldToken, SyntaxToken newToken);
    [NullableContextAttribute("2")]
public static double ComputeDistance(IEnumerable`1<SyntaxToken> oldTokens, IEnumerable`1<SyntaxToken> newTokens);
    [NullableContextAttribute("0")]
public static double ComputeDistance(ImmutableArray`1<SyntaxToken> oldTokens, ImmutableArray`1<SyntaxToken> newTokens);
    public static double ComputeDistance(IEnumerable`1<SyntaxNode> oldNodes, IEnumerable`1<SyntaxNode> newNodes);
    public static double ComputeDistance(ImmutableArray`1<SyntaxNode> oldNodes, ImmutableArray`1<SyntaxNode> newNodes);
    public static IEnumerable`1<SequenceEdit> GetSequenceEdits(IEnumerable`1<SyntaxNode> oldNodes, IEnumerable`1<SyntaxNode> newNodes);
    public static IEnumerable`1<SequenceEdit> GetSequenceEdits(ImmutableArray`1<SyntaxNode> oldNodes, ImmutableArray`1<SyntaxNode> newNodes);
    [NullableContextAttribute("2")]
public static IEnumerable`1<SequenceEdit> GetSequenceEdits(IEnumerable`1<SyntaxToken> oldTokens, IEnumerable`1<SyntaxToken> newTokens);
    [NullableContextAttribute("0")]
public static IEnumerable`1<SequenceEdit> GetSequenceEdits(ImmutableArray`1<SyntaxToken> oldTokens, ImmutableArray`1<SyntaxToken> newTokens);
    [CompilerGeneratedAttribute]
private bool <ValuesEqual>b__14_0(SyntaxKind childKind);
    [CompilerGeneratedAttribute]
private bool <ValuesEqual>b__14_1(SyntaxKind childKind);
}
internal static class Microsoft.CodeAnalysis.CSharp.EditAndContinue.SyntaxUtilities : object {
    public static SyntaxNode TryGetMethodDeclarationBody(SyntaxNode node);
    [ConditionalAttribute("DEBUG")]
public static void AssertIsBody(SyntaxNode syntax, bool allowLambda);
    public static void FindLeafNodeAndPartner(SyntaxNode leftRoot, int leftPosition, SyntaxNode rightRoot, SyntaxNode& leftNode, SyntaxNode& rightNodeOpt);
    public static SyntaxNode FindPartner(SyntaxNode leftRoot, SyntaxNode rightRoot, SyntaxNode leftNode);
    public static bool Any(TypeParameterListSyntax listOpt);
    public static SyntaxNode TryGetEffectiveGetterBody(SyntaxNode declaration);
    public static SyntaxNode TryGetEffectiveGetterBody(ArrowExpressionClauseSyntax propertyBody, AccessorListSyntax accessorList);
    public static Nullable`1<SyntaxTokenList> TryGetFieldOrPropertyModifiers(SyntaxNode node);
    public static bool IsParameterlessConstructor(SyntaxNode declaration);
    public static bool HasBackingField(PropertyDeclarationSyntax property);
    public static bool IsAsyncDeclaration(SyntaxNode declaration);
    public static IEnumerable`1<SyntaxNode> GetSuspensionPoints(SyntaxNode body);
    public static bool IsSuspensionPoint(SyntaxNode node);
    [CompilerGeneratedAttribute]
internal static SyntaxNode <TryGetMethodDeclarationBody>g__BlockOrExpression|0_0(BlockSyntax blockBodyOpt, ArrowExpressionClauseSyntax expressionBodyOpt);
}
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
internal class Microsoft.CodeAnalysis.CSharp.EmbeddedLanguages.CSharpRegexDiagnosticAnalyzer : AbstractRegexDiagnosticAnalyzer {
}
[ExportLanguageServiceAttribute("Microsoft.CodeAnalysis.EncapsulateField.AbstractEncapsulateFieldService", "C#", "Default")]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.CSharp.EncapsulateField.CSharpEncapsulateFieldService : AbstractEncapsulateFieldService {
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.CSharp.EncapsulateField.CSharpEncapsulateFieldService/<RewriteFieldNameAndAccessibilityAsync>d__1")]
protected virtual Task`1<SyntaxNode> RewriteFieldNameAndAccessibilityAsync(string originalFieldName, bool makePrivate, Document document, SyntaxAnnotation declarationAnnotation, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.CSharp.EncapsulateField.CSharpEncapsulateFieldService/<GetFieldsAsync>d__2")]
protected virtual Task`1<ImmutableArray`1<IFieldSymbol>> GetFieldsAsync(Document document, TextSpan span, CancellationToken cancellationToken);
    private bool CanEncapsulate(FieldDeclarationSyntax field);
    protected virtual ValueTuple`2<string, string> GenerateFieldAndPropertyNames(IFieldSymbol field);
    private static bool IsNew(IFieldSymbol field);
    private static string GenerateFieldName(string correspondingPropertyName);
    protected static string MakeUnique(string baseName, INamedTypeSymbol containingType);
    internal virtual IEnumerable`1<SyntaxNode> GetConstructorNodes(INamedTypeSymbol containingType);
}
[ExportLanguageServiceAttribute("Microsoft.CodeAnalysis.ExtractInterface.AbstractExtractInterfaceService", "C#", "Default")]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.CSharp.ExtractInterface.CSharpExtractInterfaceService : AbstractExtractInterfaceService {
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.CSharp.ExtractInterface.CSharpExtractInterfaceService/<GetTypeDeclarationAsync>d__1")]
protected virtual Task`1<SyntaxNode> GetTypeDeclarationAsync(Document document, int position, TypeDiscoveryRule typeDiscoveryRule, CancellationToken cancellationToken);
    internal virtual string GetContainingNamespaceDisplay(INamedTypeSymbol typeSymbol, CompilationOptions compilationOptions);
    internal virtual bool IsExtractableMember(ISymbol m);
    internal virtual bool ShouldIncludeAccessibilityModifier(SyntaxNode typeNode);
    protected virtual Task`1<Solution> UpdateMembersWithExplicitImplementationsAsync(Solution unformattedSolution, IReadOnlyList`1<DocumentId> documentIds, INamedTypeSymbol extractedInterface, INamedTypeSymbol typeToExtractFrom, IEnumerable`1<ISymbol> includedMembers, ImmutableDictionary`2<ISymbol, SyntaxAnnotation> symbolToDeclarationMap, CancellationToken cancellationToken);
}
[ExportAttribute("Microsoft.CodeAnalysis.ExtractMethod.IExtractMethodService")]
[SharedAttribute]
[ExportLanguageServiceAttribute("Microsoft.CodeAnalysis.ExtractMethod.IExtractMethodService", "C#", "Default")]
internal class Microsoft.CodeAnalysis.CSharp.ExtractMethod.CSharpExtractMethodService : AbstractExtractMethodService`3<CSharpSelectionValidator, CSharpMethodExtractor, CSharpSelectionResult> {
    protected virtual CSharpSelectionValidator CreateSelectionValidator(SemanticDocument document, TextSpan textSpan, OptionSet options);
    protected virtual CSharpMethodExtractor CreateMethodExtractor(CSharpSelectionResult selectionResult, bool localFunction);
}
internal class Microsoft.CodeAnalysis.CSharp.ExtractMethod.CSharpMethodExtractor : MethodExtractor {
    public CSharpMethodExtractor(CSharpSelectionResult result, bool localFunction);
    protected virtual Task`1<AnalyzerResult> AnalyzeAsync(SelectionResult selectionResult, bool localFunction, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.CSharp.ExtractMethod.CSharpMethodExtractor/<GetInsertionPointAsync>d__3")]
protected virtual Task`1<InsertionPoint> GetInsertionPointAsync(SemanticDocument document, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.CSharp.ExtractMethod.CSharpMethodExtractor/<PreserveTriviaAsync>d__4")]
protected virtual Task`1<TriviaResult> PreserveTriviaAsync(SelectionResult selectionResult, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.CSharp.ExtractMethod.CSharpMethodExtractor/<ExpandAsync>d__5")]
protected virtual Task`1<SemanticDocument> ExpandAsync(SelectionResult selection, CancellationToken cancellationToken);
    protected virtual Task`1<GeneratedCode> GenerateCodeAsync(InsertionPoint insertionPoint, SelectionResult selectionResult, AnalyzerResult analyzeResult, OptionSet options, CancellationToken cancellationToken);
    protected virtual IEnumerable`1<AbstractFormattingRule> GetFormattingRules(Document document);
    protected virtual SyntaxToken GetMethodNameAtInvocation(IEnumerable`1<SyntaxNodeOrToken> methodNames);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.CSharp.ExtractMethod.CSharpMethodExtractor/<CheckTypeAsync>d__9")]
protected virtual Task`1<OperationStatus> CheckTypeAsync(Document document, SyntaxNode contextNode, Location location, ITypeSymbol type, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.CSharp.ExtractMethod.CSharpMethodExtractor/<InsertNewLineBeforeLocalFunctionIfNecessaryAsync>d__10")]
protected virtual Task`1<ValueTuple`3<Document, SyntaxToken, SyntaxNode>> InsertNewLineBeforeLocalFunctionIfNecessaryAsync(Document document, SyntaxToken methodName, SyntaxNode methodDefinition, CancellationToken cancellationToken);
    [NullableContextAttribute("1")]
[CompilerGeneratedAttribute]
private bool <GetInsertionPointAsync>b__3_0(LocalFunctionStatementSyntax node);
}
internal abstract class Microsoft.CodeAnalysis.CSharp.ExtractMethod.CSharpSelectionResult : SelectionResult {
    protected CSharpSelectionResult(OperationStatus status, TextSpan originalSpan, TextSpan finalSpan, OptionSet options, bool selectionInExpression, SemanticDocument document, SyntaxAnnotation firstTokenAnnotation, SyntaxAnnotation lastTokenAnnotation);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.CSharp.ExtractMethod.CSharpSelectionResult/<CreateAsync>d__0")]
public static Task`1<CSharpSelectionResult> CreateAsync(OperationStatus status, TextSpan originalSpan, TextSpan finalSpan, OptionSet options, bool selectionInExpression, SemanticDocument document, SyntaxToken firstToken, SyntaxToken lastToken, CancellationToken cancellationToken);
    protected virtual bool UnderAnonymousOrLocalMethod(SyntaxToken token, SyntaxToken firstToken, SyntaxToken lastToken);
    public StatementSyntax GetFirstStatement();
    public StatementSyntax GetLastStatement();
    public StatementSyntax GetFirstStatementUnderContainer();
    public StatementSyntax GetLastStatementUnderContainer();
    public SyntaxNode GetInnermostStatementContainer();
    public bool ShouldPutUnsafeModifier();
    public SyntaxKind UnderCheckedExpressionContext();
    public SyntaxKind UnderCheckedStatementContext();
    private SyntaxKind UnderCheckedContext();
    [NullableContextAttribute("2")]
private static bool IsCoClassImplicitConversion(TypeInfo info, Conversion conversion, ISymbol coclassSymbol);
}
internal class Microsoft.CodeAnalysis.CSharp.ExtractMethod.CSharpSelectionValidator : SelectionValidator {
    public CSharpSelectionValidator(SemanticDocument document, TextSpan textSpan, OptionSet options);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.CSharp.ExtractMethod.CSharpSelectionValidator/<GetValidSelectionAsync>d__1")]
public virtual Task`1<SelectionResult> GetValidSelectionAsync(CancellationToken cancellationToken);
    private static SelectionInfo ApplySpecialCases(SelectionInfo selectionInfo, SourceText text);
    private static TextSpan GetControlFlowSpan(SelectionInfo selectionInfo);
    private static SelectionInfo AdjustFinalTokensBasedOnContext(SelectionInfo selectionInfo, SemanticModel semanticModel, CancellationToken cancellationToken);
    private SelectionInfo GetInitialSelectionInfo(SyntaxNode root, SourceText text);
    private static SelectionInfo CheckErrorCasesAndAppendDescriptions(SelectionInfo selectionInfo, SyntaxNode root);
    private static SelectionInfo AssignInitialFinalTokens(SelectionInfo selectionInfo, SyntaxNode root, CancellationToken cancellationToken);
    private static SelectionInfo AssignFinalSpan(SelectionInfo selectionInfo, SourceText text);
    public virtual bool ContainsNonReturnExitPointsStatements(IEnumerable`1<SyntaxNode> jumpsOutOfRegion);
    public virtual IEnumerable`1<SyntaxNode> GetOuterReturnStatements(SyntaxNode commonRoot, IEnumerable`1<SyntaxNode> jumpsOutOfRegion);
    public virtual bool IsFinalSpanSemanticallyValidSpan(SyntaxNode root, TextSpan textSpan, IEnumerable`1<SyntaxNode> returnStatements, CancellationToken cancellationToken);
    private static TextSpan GetAdjustedSpan(SourceText text, TextSpan textSpan);
    public static bool Check(SemanticModel semanticModel, SyntaxNode node, CancellationToken cancellationToken);
    private static bool CheckGlobalStatement();
    private static bool CheckBlock(BlockSyntax block);
    private static bool CheckExpression(SemanticModel semanticModel, ExpressionSyntax expression, CancellationToken cancellationToken);
    private static bool CheckStatement(StatementSyntax statement);
}
internal class Microsoft.CodeAnalysis.CSharp.ExtractMethod.CSharpSyntaxTriviaService : AbstractSyntaxTriviaService {
    public static CSharpSyntaxTriviaService Instance;
    private static CSharpSyntaxTriviaService();
}
[ExportLanguageServiceFactoryAttribute("Microsoft.CodeAnalysis.ExtractMethod.ISyntaxTriviaService", "C#", "Default")]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.CSharp.ExtractMethod.CSharpSyntaxTriviaServiceFactory : object {
    public sealed virtual ILanguageService CreateLanguageService(HostLanguageServices provider);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
internal static class Microsoft.CodeAnalysis.CSharp.ExtractMethod.Extensions : object {
    [NullableContextAttribute("2")]
[ExtensionAttribute]
public static ExpressionSyntax GetUnparenthesizedExpression(ExpressionSyntax node);
    [ExtensionAttribute]
public static StatementSyntax GetStatementUnderContainer(SyntaxNode node);
    [ExtensionAttribute]
public static StatementSyntax GetParentLabeledStatementIfPossible(SyntaxNode node);
    [NullableContextAttribute("2")]
[ExtensionAttribute]
public static bool IsStatementContainerNode(SyntaxNode node);
    [NullableContextAttribute("2")]
[ExtensionAttribute]
public static BlockSyntax GetBlockBody(SyntaxNode node);
    [ExtensionAttribute]
public static bool UnderValidContext(SyntaxNode node);
    [ExtensionAttribute]
public static bool UnderValidContext(SyntaxToken token);
    [ExtensionAttribute]
public static bool PartOfConstantInitializerExpression(SyntaxNode node);
    [ExtensionAttribute]
private static bool PartOfConstantInitializerExpression(SyntaxNode node, Func`2<T, SyntaxTokenList> modifiersGetter);
    [ExtensionAttribute]
public static bool ContainArgumentlessThrowWithoutEnclosingCatch(IEnumerable`1<SyntaxToken> tokens, TextSpan textSpan);
    [ExtensionAttribute]
public static bool ContainPreprocessorCrossOver(IEnumerable`1<SyntaxToken> tokens, TextSpan textSpan);
    [IteratorStateMachineAttribute("Microsoft.CodeAnalysis.CSharp.ExtractMethod.Extensions/<GetAllTrivia>d__11")]
[ExtensionAttribute]
public static IEnumerable`1<SyntaxTrivia> GetAllTrivia(IEnumerable`1<SyntaxToken> tokens);
    [ExtensionAttribute]
public static bool HasSyntaxAnnotation(HashSet`1<SyntaxAnnotation> set, SyntaxNode node);
    [ExtensionAttribute]
public static bool HasHybridTriviaBetween(SyntaxToken token1, SyntaxToken token2);
    [NullableContextAttribute("2")]
[ExtensionAttribute]
public static bool IsArrayInitializer(SyntaxNode node);
    [NullableContextAttribute("2")]
[ExtensionAttribute]
public static bool IsExpressionInCast(SyntaxNode node);
    [NullableContextAttribute("2")]
[ExtensionAttribute]
public static bool IsObjectType(ITypeSymbol type);
    [ExtensionAttribute]
public static bool BetweenFieldAndNonFieldMember(SyntaxToken token1, SyntaxToken token2);
}
[ExportLanguageServiceAttribute("Microsoft.CodeAnalysis.EmbeddedLanguages.LanguageServices.IEmbeddedLanguagesProvider", "C#", "Desktop")]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.CSharp.Features.EmbeddedLanguages.CSharpEmbeddedLanguageFeaturesProvider : AbstractEmbeddedLanguageFeaturesProvider {
    internal virtual string EscapeText(string text, SyntaxToken token);
}
internal static class Microsoft.CodeAnalysis.CSharp.Features.EmbeddedLanguages.EmbeddedLanguageUtilities : object {
    public static string EscapeText(string text, SyntaxToken token);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExportCodeFixProviderAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.CSharp.FileHeaders.CSharpFileHeaderCodeFixProvider : AbstractFileHeaderCodeFixProvider {
    protected AbstractFileHeaderHelper FileHeaderHelper { get; }
    protected ISyntaxFacts SyntaxFacts { get; }
    protected ISyntaxKinds SyntaxKinds { get; }
    protected virtual AbstractFileHeaderHelper get_FileHeaderHelper();
    protected virtual ISyntaxFacts get_SyntaxFacts();
    protected virtual ISyntaxKinds get_SyntaxKinds();
    protected virtual SyntaxTrivia EndOfLine(string text);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
internal class Microsoft.CodeAnalysis.CSharp.FileHeaders.CSharpFileHeaderDiagnosticAnalyzer : AbstractFileHeaderDiagnosticAnalyzer {
    protected AbstractFileHeaderHelper FileHeaderHelper { get; }
    protected virtual AbstractFileHeaderHelper get_FileHeaderHelper();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.CodeAnalysis.CSharp.FileHeaders.CSharpFileHeaderHelper : AbstractFileHeaderHelper {
    public static CSharpFileHeaderHelper Instance;
    public string CommentPrefix { get; }
    private static CSharpFileHeaderHelper();
    public virtual string get_CommentPrefix();
    [NullableContextAttribute("0")]
protected virtual ReadOnlyMemory`1<char> GetTextContextOfComment(SyntaxTrivia commentTrivia);
}
[ExportLanguageServiceAttribute("Microsoft.CodeAnalysis.GenerateMember.GenerateConstructor.IGenerateConstructorService", "C#", "Default")]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.CSharp.GenerateConstructor.CSharpGenerateConstructorService : AbstractGenerateConstructorService`2<CSharpGenerateConstructorService, ExpressionSyntax> {
    protected virtual bool ContainingTypesOrSelfHasUnsafeKeyword(INamedTypeSymbol containingType);
    protected virtual bool IsSimpleNameGeneration(SemanticDocument document, SyntaxNode node, CancellationToken cancellationToken);
    protected virtual bool IsConstructorInitializerGeneration(SemanticDocument document, SyntaxNode node, CancellationToken cancellationToken);
    protected virtual bool IsImplicitObjectCreation(SemanticDocument document, SyntaxNode node, CancellationToken cancellationToken);
    protected virtual bool TryInitializeConstructorInitializerGeneration(SemanticDocument document, SyntaxNode node, CancellationToken cancellationToken, SyntaxToken& token, ImmutableArray`1& arguments, INamedTypeSymbol& typeToGenerateIn);
    private static ImmutableArray`1<Argument<CSharpGenerateConstructorService, ExpressionSyntax>> GetArguments(SeparatedSyntaxList`1<ArgumentSyntax> arguments);
    private static ImmutableArray`1<Argument<CSharpGenerateConstructorService, ExpressionSyntax>> GetArguments(SeparatedSyntaxList`1<AttributeArgumentSyntax> arguments);
    protected virtual bool TryInitializeSimpleNameGenerationState(SemanticDocument document, SyntaxNode node, CancellationToken cancellationToken, SyntaxToken& token, ImmutableArray`1& arguments, INamedTypeSymbol& typeToGenerateIn);
    protected virtual bool TryInitializeSimpleAttributeNameGenerationState(SemanticDocument document, SyntaxNode node, CancellationToken cancellationToken, SyntaxToken& token, ImmutableArray`1& arguments, INamedTypeSymbol& typeToGenerateIn);
    protected virtual bool TryInitializeImplicitObjectCreation(SemanticDocument document, SyntaxNode node, CancellationToken cancellationToken, SyntaxToken& token, ImmutableArray`1& arguments, INamedTypeSymbol& typeToGenerateIn);
    protected virtual string GenerateNameForExpression(SemanticModel semanticModel, ExpressionSyntax expression, CancellationToken cancellationToken);
    protected virtual ITypeSymbol GetArgumentType(SemanticModel semanticModel, Argument<CSharpGenerateConstructorService, ExpressionSyntax> argument, CancellationToken cancellationToken);
    protected virtual bool IsConversionImplicit(Compilation compilation, ITypeSymbol sourceType, ITypeSymbol targetType);
    protected virtual IMethodSymbol GetCurrentConstructor(SemanticModel semanticModel, SyntaxToken token, CancellationToken cancellationToken);
    protected virtual IMethodSymbol GetDelegatedConstructor(SemanticModel semanticModel, IMethodSymbol constructor, CancellationToken cancellationToken);
}
[ExportCodeFixProviderAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
[SharedAttribute]
[ExtensionOrderAttribute]
internal class Microsoft.CodeAnalysis.CSharp.GenerateConstructor.GenerateConstructorCodeFixProvider : AbstractGenerateMemberCodeFixProvider {
    public ImmutableArray`1<string> FixableDiagnosticIds { get; }
    public virtual ImmutableArray`1<string> get_FixableDiagnosticIds();
    protected virtual Task`1<ImmutableArray`1<CodeAction>> GetCodeActionsAsync(Document document, SyntaxNode node, CancellationToken cancellationToken);
    protected virtual bool IsCandidate(SyntaxNode node, SyntaxToken token, Diagnostic diagnostic);
    protected virtual SyntaxNode GetTargetNode(SyntaxNode node);
}
internal static class Microsoft.CodeAnalysis.CSharp.GenerateConstructor.GenerateConstructorDiagnosticIds : object {
    public static string CS0122;
    public static string CS1729;
    public static string CS1739;
    public static string CS1503;
    public static string CS1660;
    public static string CS7036;
    public static ImmutableArray`1<string> AllDiagnosticIds;
    public static ImmutableArray`1<string> TooManyArgumentsDiagnosticIds;
    public static ImmutableArray`1<string> CannotConvertDiagnosticIds;
    private static GenerateConstructorDiagnosticIds();
}
[ExportCodeRefactoringProviderAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
[SharedAttribute]
[ExtensionOrderAttribute]
[IntentProviderAttribute("GenerateConstructor", "C#")]
internal class Microsoft.CodeAnalysis.CSharp.GenerateConstructorFromMembers.CSharpGenerateConstructorFromMembersCodeRefactoringProvider : AbstractGenerateConstructorFromMembersCodeRefactoringProvider {
    internal CSharpGenerateConstructorFromMembersCodeRefactoringProvider(IPickMembersService pickMembersService_forTesting);
    protected virtual bool ContainingTypesOrSelfHasUnsafeKeyword(INamedTypeSymbol containingType);
    protected virtual string ToDisplayString(IParameterSymbol parameter, SymbolDisplayFormat format);
    protected virtual bool PrefersThrowExpression(DocumentOptionSet options);
}
[ExportLanguageServiceAttribute("Microsoft.CodeAnalysis.GenerateEqualsAndGetHashCodeFromMembers.IGenerateEqualsAndGetHashCodeService", "C#", "Default")]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.CSharp.GenerateEqualsAndGetHashCodeFromMembers.CSharpGenerateEqualsAndGetHashCodeService : AbstractGenerateEqualsAndGetHashCodeService {
    protected virtual bool TryWrapWithUnchecked(ImmutableArray`1<SyntaxNode> statements, ImmutableArray`1& wrappedStatements);
}
[ExportLanguageServiceAttribute("Microsoft.CodeAnalysis.GenerateMember.GenerateDefaultConstructors.IGenerateDefaultConstructorsService", "C#", "Default")]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.CSharp.GenerateMember.GenerateDefaultConstructors.CSharpGenerateDefaultConstructorsService : AbstractGenerateDefaultConstructorsService`1<CSharpGenerateDefaultConstructorsService> {
    protected virtual bool TryInitializeState(SemanticDocument semanticDocument, TextSpan textSpan, CancellationToken cancellationToken, INamedTypeSymbol& classType);
}
[ExportLanguageServiceAttribute("Microsoft.CodeAnalysis.GenerateMember.GenerateEnumMember.IGenerateEnumMemberService", "C#", "Default")]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.CSharp.GenerateMember.GenerateEnumMember.CSharpGenerateEnumMemberService : AbstractGenerateEnumMemberService`3<CSharpGenerateEnumMemberService, SimpleNameSyntax, ExpressionSyntax> {
    protected virtual bool IsIdentifierNameGeneration(SyntaxNode node);
    protected virtual bool TryInitializeIdentifierNameState(SemanticDocument document, SimpleNameSyntax identifierName, CancellationToken cancellationToken, SyntaxToken& identifierToken, ExpressionSyntax& simpleNameOrMemberAccessExpression);
}
[ExportLanguageServiceAttribute("Microsoft.CodeAnalysis.GenerateMember.GenerateParameterizedMember.IGenerateDeconstructMemberService", "C#", "Default")]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.CSharp.GenerateMember.GenerateMethod.CSharpGenerateDeconstructMethodService : AbstractGenerateDeconstructMethodService`4<CSharpGenerateDeconstructMethodService, SimpleNameSyntax, ExpressionSyntax, InvocationExpressionSyntax> {
    protected virtual bool ContainingTypesOrSelfHasUnsafeKeyword(INamedTypeSymbol containingType);
    protected virtual AbstractInvocationInfo<CSharpGenerateDeconstructMethodService, SimpleNameSyntax, ExpressionSyntax, InvocationExpressionSyntax> CreateInvocationMethodInfo(SemanticDocument document, State<CSharpGenerateDeconstructMethodService, SimpleNameSyntax, ExpressionSyntax, InvocationExpressionSyntax> state);
    protected virtual bool AreSpecialOptionsActive(SemanticModel semanticModel);
    protected virtual bool IsValidSymbol(ISymbol symbol, SemanticModel semanticModel);
}
[ExportLanguageServiceAttribute("Microsoft.CodeAnalysis.GenerateMember.GenerateParameterizedMember.IGenerateParameterizedMemberService", "C#", "Default")]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.CSharp.GenerateMember.GenerateMethod.CSharpGenerateMethodService : AbstractGenerateMethodService`4<CSharpGenerateMethodService, SimpleNameSyntax, ExpressionSyntax, InvocationExpressionSyntax> {
    protected virtual bool IsExplicitInterfaceGeneration(SyntaxNode node);
    protected virtual bool IsSimpleNameGeneration(SyntaxNode node);
    protected virtual bool ContainingTypesOrSelfHasUnsafeKeyword(INamedTypeSymbol containingType);
    protected virtual AbstractInvocationInfo<CSharpGenerateMethodService, SimpleNameSyntax, ExpressionSyntax, InvocationExpressionSyntax> CreateInvocationMethodInfo(SemanticDocument document, State<CSharpGenerateMethodService, SimpleNameSyntax, ExpressionSyntax, InvocationExpressionSyntax> state);
    protected virtual bool AreSpecialOptionsActive(SemanticModel semanticModel);
    protected virtual bool IsValidSymbol(ISymbol symbol, SemanticModel semanticModel);
    protected virtual bool TryInitializeExplicitInterfaceState(SemanticDocument document, SyntaxNode node, CancellationToken cancellationToken, SyntaxToken& identifierToken, IMethodSymbol& methodSymbol, INamedTypeSymbol& typeToGenerateIn);
    protected virtual bool TryInitializeSimpleNameState(SemanticDocument document, SimpleNameSyntax simpleName, CancellationToken cancellationToken, SyntaxToken& identifierToken, ExpressionSyntax& simpleNameOrMemberAccessExpression, InvocationExpressionSyntax& invocationExpressionOpt, Boolean& isInConditionalAccessExpression);
    protected virtual ITypeSymbol DetermineReturnTypeForSimpleNameOrMemberAccessExpression(ITypeInferenceService typeInferenceService, SemanticModel semanticModel, ExpressionSyntax expression, CancellationToken cancellationToken);
}
internal abstract class Microsoft.CodeAnalysis.CSharp.GenerateMember.GenerateMethod.CSharpGenerateParameterizedMemberService`1 : AbstractGenerateParameterizedMemberService`4<TService, SimpleNameSyntax, ExpressionSyntax, InvocationExpressionSyntax> {
}
internal static class Microsoft.CodeAnalysis.CSharp.GenerateMember.GenerateParameterizedMember.CSharpCommonGenerationServiceMethods : object {
    public static bool AreSpecialOptionsActive();
    public static bool IsValidSymbol();
}
[ExportLanguageServiceAttribute("Microsoft.CodeAnalysis.GenerateMember.GenerateParameterizedMember.IGenerateConversionService", "C#", "Default")]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.CSharp.GenerateMember.GenerateParameterizedMember.CSharpGenerateConversionService : AbstractGenerateConversionService`4<CSharpGenerateConversionService, SimpleNameSyntax, ExpressionSyntax, InvocationExpressionSyntax> {
    protected virtual bool IsImplicitConversionGeneration(SyntaxNode node);
    protected virtual bool IsExplicitConversionGeneration(SyntaxNode node);
    protected virtual bool ContainingTypesOrSelfHasUnsafeKeyword(INamedTypeSymbol containingType);
    protected virtual AbstractInvocationInfo<CSharpGenerateConversionService, SimpleNameSyntax, ExpressionSyntax, InvocationExpressionSyntax> CreateInvocationMethodInfo(SemanticDocument document, State<CSharpGenerateConversionService, SimpleNameSyntax, ExpressionSyntax, InvocationExpressionSyntax> state);
    protected virtual bool AreSpecialOptionsActive(SemanticModel semanticModel);
    protected virtual bool IsValidSymbol(ISymbol symbol, SemanticModel semanticModel);
    protected virtual bool TryInitializeImplicitConversionState(SemanticDocument document, SyntaxNode expression, ISet`1<TypeKind> classInterfaceModuleStructTypes, CancellationToken cancellationToken, SyntaxToken& identifierToken, IMethodSymbol& methodSymbol, INamedTypeSymbol& typeToGenerateIn);
    protected virtual bool TryInitializeExplicitConversionState(SemanticDocument document, SyntaxNode expression, ISet`1<TypeKind> classInterfaceModuleStructTypes, CancellationToken cancellationToken, SyntaxToken& identifierToken, IMethodSymbol& methodSymbol, INamedTypeSymbol& typeToGenerateIn);
    private static bool TryGetConversionMethodAndTypeToGenerateIn(SemanticDocument document, SyntaxNode expression, ISet`1<TypeKind> classInterfaceModuleStructTypes, CancellationToken cancellationToken, IMethodSymbol& methodSymbol, INamedTypeSymbol& typeToGenerateIn);
    private static bool TryGetExplicitConversionMethodAndTypeToGenerateIn(SemanticDocument document, CastExpressionSyntax castExpression, ISet`1<TypeKind> classInterfaceModuleStructTypes, CancellationToken cancellationToken, IMethodSymbol& methodSymbol, INamedTypeSymbol& typeToGenerateIn);
    private static bool TryGetImplicitConversionMethodAndTypeToGenerateIn(SemanticDocument document, SyntaxNode expression, ISet`1<TypeKind> classInterfaceModuleStructTypes, CancellationToken cancellationToken, IMethodSymbol& methodSymbol, INamedTypeSymbol& typeToGenerateIn);
    private static IMethodSymbol GenerateMethodSymbol(INamedTypeSymbol typeToGenerateIn, INamedTypeSymbol parameterSymbol);
    protected virtual string GetImplicitConversionDisplayText(State<CSharpGenerateConversionService, SimpleNameSyntax, ExpressionSyntax, InvocationExpressionSyntax> state);
    protected virtual string GetExplicitConversionDisplayText(State<CSharpGenerateConversionService, SimpleNameSyntax, ExpressionSyntax, InvocationExpressionSyntax> state);
}
[ExportLanguageServiceAttribute("Microsoft.CodeAnalysis.GenerateMember.GenerateVariable.IGenerateVariableService", "C#", "Default")]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.CSharp.GenerateMember.GenerateVariable.CSharpGenerateVariableService : AbstractGenerateVariableService`3<CSharpGenerateVariableService, SimpleNameSyntax, ExpressionSyntax> {
    protected virtual bool IsExplicitInterfaceGeneration(SyntaxNode node);
    protected virtual bool IsIdentifierNameGeneration(SyntaxNode node);
    protected virtual bool ContainingTypesOrSelfHasUnsafeKeyword(INamedTypeSymbol containingType);
    protected virtual bool TryInitializeExplicitInterfaceState(SemanticDocument document, SyntaxNode node, CancellationToken cancellationToken, SyntaxToken& identifierToken, IPropertySymbol& propertySymbol, INamedTypeSymbol& typeToGenerateIn);
    protected virtual bool TryInitializeIdentifierNameState(SemanticDocument document, SimpleNameSyntax identifierName, CancellationToken cancellationToken, SyntaxToken& identifierToken, ExpressionSyntax& simpleNameOrMemberAccessExpression, Boolean& isInExecutableBlock, Boolean& isConditionalAccessExpression);
    private static bool IsProbablyGeneric(SimpleNameSyntax identifierName, CancellationToken cancellationToken);
    private static bool IsLegal(SemanticDocument document, ExpressionSyntax expression, CancellationToken cancellationToken);
    protected virtual bool TryConvertToLocalDeclaration(ITypeSymbol type, SyntaxToken identifierToken, OptionSet options, SemanticModel semanticModel, CancellationToken cancellationToken, SyntaxNode& newRoot);
}
[ExportLanguageServiceAttribute("Microsoft.CodeAnalysis.GenerateType.IGenerateTypeService", "C#", "Default")]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.CSharp.GenerateType.CSharpGenerateTypeService : AbstractGenerateTypeService`6<CSharpGenerateTypeService, SimpleNameSyntax, ObjectCreationExpressionSyntax, ExpressionSyntax, TypeDeclarationSyntax, ArgumentSyntax> {
    private static IMethodSymbol s_accessor;
    protected string DefaultFileExtension { get; }
    private static CSharpGenerateTypeService();
    protected virtual string get_DefaultFileExtension();
    protected virtual ExpressionSyntax GetLeftSideOfDot(SimpleNameSyntax simpleName);
    protected virtual bool IsInCatchDeclaration(ExpressionSyntax expression);
    protected virtual bool IsArrayElementType(ExpressionSyntax expression);
    protected virtual bool IsInValueTypeConstraintContext(SemanticModel semanticModel, ExpressionSyntax expression, CancellationToken cancellationToken);
    protected virtual bool IsInInterfaceList(ExpressionSyntax expression);
    protected virtual bool TryGetNameParts(ExpressionSyntax expression, IList`1& nameParts);
    protected virtual bool TryInitializeState(SemanticDocument document, SimpleNameSyntax simpleName, CancellationToken cancellationToken, GenerateTypeServiceStateOptions& generateTypeServiceStateOptions);
    private static IMethodSymbol GetMethodSymbolIfPresent(SemanticModel semanticModel, ExpressionSyntax expression, CancellationToken cancellationToken);
    private static Accessibility DetermineAccessibilityConstraint(State<CSharpGenerateTypeService, SimpleNameSyntax, ObjectCreationExpressionSyntax, ExpressionSyntax, TypeDeclarationSyntax, ArgumentSyntax> state, SemanticModel semanticModel, CancellationToken cancellationToken);
    private static bool AllContainingTypesArePublicOrProtected(State<CSharpGenerateTypeService, SimpleNameSyntax, ObjectCreationExpressionSyntax, ExpressionSyntax, TypeDeclarationSyntax, ArgumentSyntax> state, SemanticModel semanticModel, CancellationToken cancellationToken);
    protected virtual ImmutableArray`1<ITypeParameterSymbol> GetTypeParameters(State<CSharpGenerateTypeService, SimpleNameSyntax, ObjectCreationExpressionSyntax, ExpressionSyntax, TypeDeclarationSyntax, ArgumentSyntax> state, SemanticModel semanticModel, CancellationToken cancellationToken);
    protected virtual bool TryGetArgumentList(ObjectCreationExpressionSyntax objectCreationExpression, IList`1& argumentList);
    protected virtual IList`1<ParameterName> GenerateParameterNames(SemanticModel semanticModel, IList`1<ArgumentSyntax> arguments, CancellationToken cancellationToken);
    public virtual string GetRootNamespace(CompilationOptions options);
    protected virtual bool IsInVariableTypeContext(ExpressionSyntax expression);
    protected virtual INamedTypeSymbol DetermineTypeToGenerateIn(SemanticModel semanticModel, SimpleNameSyntax simpleName, CancellationToken cancellationToken);
    protected virtual Accessibility GetAccessibility(State<CSharpGenerateTypeService, SimpleNameSyntax, ObjectCreationExpressionSyntax, ExpressionSyntax, TypeDeclarationSyntax, ArgumentSyntax> state, SemanticModel semanticModel, bool intoNamespace, CancellationToken cancellationToken);
    protected virtual ITypeSymbol DetermineArgumentType(SemanticModel semanticModel, ArgumentSyntax argument, CancellationToken cancellationToken);
    protected virtual bool IsConversionImplicit(Compilation compilation, ITypeSymbol sourceType, ITypeSymbol targetType);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.CSharp.GenerateType.CSharpGenerateTypeService/<GetOrGenerateEnclosingNamespaceSymbolAsync>d__22")]
public virtual Task`1<ValueTuple`3<INamespaceSymbol, INamespaceOrTypeSymbol, Location>> GetOrGenerateEnclosingNamespaceSymbolAsync(INamedTypeSymbol namedTypeSymbol, String[] containers, Document selectedDocument, SyntaxNode selectedDocumentRoot, CancellationToken cancellationToken);
    private NamespaceDeclarationSyntax FindNamespaceInMemberDeclarations(SyntaxList`1<MemberDeclarationSyntax> members, int indexDone, List`1<string> containers);
    private NamespaceDeclarationSyntax FindNamespaceInNamespace(NamespaceDeclarationSyntax namespaceDecl, int indexDone, List`1<string> containers);
    private static bool IdentifierMatches(int indexDone, List`1<string> namespaceContainers, List`1<string> containers);
    private void GetNamespaceContainers(NameSyntax name, List`1<string> namespaceContainers);
    internal virtual bool TryGetBaseList(ExpressionSyntax expression, TypeKindOptions& typeKindValue);
    internal virtual bool IsPublicOnlyAccessibility(ExpressionSyntax expression, Project project);
    private static bool IsAllContainingTypeDeclsPublic(SyntaxNode node);
    internal virtual bool IsGenericName(SimpleNameSyntax simpleName);
    internal virtual bool IsSimpleName(ExpressionSyntax expression);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.CSharp.GenerateType.CSharpGenerateTypeService/<TryAddUsingsOrImportToDocumentAsync>d__32")]
internal virtual Task`1<Solution> TryAddUsingsOrImportToDocumentAsync(Solution updatedSolution, SyntaxNode modifiedRoot, Document document, SimpleNameSyntax simpleName, string includeUsingsOrImports, CancellationToken cancellationToken);
    private static ITypeSymbol GetPropertyType(SimpleNameSyntax propertyName, SemanticModel semanticModel, ITypeInferenceService typeInference, CancellationToken cancellationToken);
    private static IPropertySymbol CreatePropertySymbol(SimpleNameSyntax propertyName, ITypeSymbol propertyType);
    internal virtual bool TryGenerateProperty(SimpleNameSyntax propertyName, SemanticModel semanticModel, ITypeInferenceService typeInference, CancellationToken cancellationToken, IPropertySymbol& property);
}
[ExportCodeFixProviderAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
[SharedAttribute]
[ExtensionOrderAttribute]
internal class Microsoft.CodeAnalysis.CSharp.GenerateVariable.CSharpGenerateVariableCodeFixProvider : AbstractGenerateMemberCodeFixProvider {
    private static string CS1061;
    private static string CS0103;
    private static string CS0117;
    private static string CS0539;
    private static string CS0246;
    private static string CS0120;
    private static string CS0118;
    public ImmutableArray`1<string> FixableDiagnosticIds { get; }
    public virtual ImmutableArray`1<string> get_FixableDiagnosticIds();
    protected virtual bool IsCandidate(SyntaxNode node, SyntaxToken token, Diagnostic diagnostic);
    protected virtual SyntaxNode GetTargetNode(SyntaxNode node);
    protected virtual Task`1<ImmutableArray`1<CodeAction>> GetCodeActionsAsync(Document document, SyntaxNode node, CancellationToken cancellationToken);
}
[ExportLanguageServiceAttribute("Microsoft.CodeAnalysis.GoToDefinition.IFindDefinitionService", "C#", "Default")]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.CSharp.GoToDefinition.CSharpFindDefinitionService : AbstractFindDefinitionService {
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExportLanguageServiceAttribute("Microsoft.CodeAnalysis.GoToDefinition.IGoToDefinitionSymbolService", "C#", "Default")]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.CSharp.GoToDefinition.CSharpGoToDefinitionSymbolService : AbstractGoToDefinitionSymbolService {
    protected virtual ISymbol FindRelatedExplicitlyDeclaredSymbol(ISymbol symbol, Compilation compilation);
    protected virtual Nullable`1<int> GetTargetPositionIfControlFlow(SemanticModel semanticModel, SyntaxToken token);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
internal static SyntaxNode <GetTargetPositionIfControlFlow>g__TryFindContinuableConstruct|2_0(SyntaxNode node);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
internal static SyntaxNode <GetTargetPositionIfControlFlow>g__TryFindBreakableConstruct|2_1(SyntaxNode node);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
internal static SyntaxNode <GetTargetPositionIfControlFlow>g__TryFindContainingReturnableConstruct|2_2(SyntaxNode node);
}
[ExportCodeFixProviderAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
[SharedAttribute]
[ExtensionOrderAttribute]
internal class Microsoft.CodeAnalysis.CSharp.ImplementAbstractClass.CSharpImplementAbstractClassCodeFixProvider : AbstractImplementAbstractClassCodeFixProvider`1<TypeDeclarationSyntax> {
    private static string CS0534;
    protected virtual SyntaxToken GetClassIdentifier(TypeDeclarationSyntax classNode);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal abstract class Microsoft.CodeAnalysis.CSharp.ImplementInterface.AbstractChangeImplementionCodeRefactoringProvider : CodeRefactoringProvider {
    private static SymbolDisplayFormat NameAndTypeParametersFormat;
    protected string Implement_0 { get; }
    protected string Implement_all_interfaces { get; }
    protected string Implement { get; }
    private static AbstractChangeImplementionCodeRefactoringProvider();
    protected abstract virtual string get_Implement_0();
    protected abstract virtual string get_Implement_all_interfaces();
    protected abstract virtual string get_Implement();
    [NullableContextAttribute("2")]
protected abstract virtual bool CheckExplicitNameAllowsConversion(ExplicitInterfaceSpecifierSyntax explicitName);
    protected abstract virtual bool CheckMemberCanBeConverted(ISymbol member);
    protected abstract virtual SyntaxNode ChangeImplementation(SyntaxGenerator generator, SyntaxNode currentDecl, ISymbol interfaceMember);
    protected abstract virtual Task UpdateReferencesAsync(Project project, SolutionEditor solutionEditor, ISymbol implMember, INamedTypeSymbol containingType, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.CSharp.ImplementInterface.AbstractChangeImplementionCodeRefactoringProvider/<ComputeRefactoringsAsync>d__11")]
public sealed virtual Task ComputeRefactoringsAsync(CodeRefactoringContext context);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.CSharp.ImplementInterface.AbstractChangeImplementionCodeRefactoringProvider/<GetContainerAsync>d__12")]
private static Task`1<ValueTuple`3<SyntaxNode, ExplicitInterfaceSpecifierSyntax, SyntaxToken>> GetContainerAsync(CodeRefactoringContext context);
    private static ValueTuple`3<SyntaxNode, ExplicitInterfaceSpecifierSyntax, SyntaxToken> GetContainer(SyntaxToken token);
    private static int TotalCount(OrderedMultiDictionary`2<ISymbol, ISymbol> dictionary);
    private OrderedMultiDictionary`2<ISymbol, ISymbol> GetImplementedMembers(INamedTypeSymbol containingType, ImmutableArray`1<INamedTypeSymbol> interfaceTypes);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.CSharp.ImplementInterface.AbstractChangeImplementionCodeRefactoringProvider/<ChangeImplementationAsync>d__16")]
private Task`1<Solution> ChangeImplementationAsync(Project project, OrderedMultiDictionary`2<ISymbol, ISymbol> implMemberToInterfaceMembers, CancellationToken cancellationToken);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExportCodeRefactoringProviderAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.CSharp.ImplementInterface.CSharpImplementExplicitlyCodeRefactoringProvider : AbstractChangeImplementionCodeRefactoringProvider {
    protected string Implement_0 { get; }
    protected string Implement_all_interfaces { get; }
    protected string Implement { get; }
    protected virtual string get_Implement_0();
    protected virtual string get_Implement_all_interfaces();
    protected virtual string get_Implement();
    [NullableContextAttribute("2")]
protected virtual bool CheckExplicitNameAllowsConversion(ExplicitInterfaceSpecifierSyntax explicitName);
    protected virtual bool CheckMemberCanBeConverted(ISymbol member);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.CSharp.ImplementInterface.CSharpImplementExplicitlyCodeRefactoringProvider/<UpdateReferencesAsync>d__9")]
protected virtual Task UpdateReferencesAsync(Project project, SolutionEditor solutionEditor, ISymbol implMember, INamedTypeSymbol interfaceType, CancellationToken cancellationToken);
    private static void UpdateLocation(SemanticModel semanticModel, INamedTypeSymbol interfaceType, SyntaxEditor editor, ISyntaxFactsService syntaxFacts, Location location, CancellationToken cancellationToken);
    protected virtual SyntaxNode ChangeImplementation(SyntaxGenerator generator, SyntaxNode decl, ISymbol interfaceMember);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExportCodeRefactoringProviderAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.CSharp.ImplementInterface.CSharpImplementImplicitlyCodeRefactoringProvider : AbstractChangeImplementionCodeRefactoringProvider {
    protected string Implement_0 { get; }
    protected string Implement_all_interfaces { get; }
    protected string Implement { get; }
    protected virtual string get_Implement_0();
    protected virtual string get_Implement_all_interfaces();
    protected virtual string get_Implement();
    [NullableContextAttribute("2")]
protected virtual bool CheckExplicitNameAllowsConversion(ExplicitInterfaceSpecifierSyntax explicitName);
    protected virtual bool CheckMemberCanBeConverted(ISymbol member);
    protected virtual Task UpdateReferencesAsync(Project project, SolutionEditor solutionEditor, ISymbol implMember, INamedTypeSymbol containingType, CancellationToken cancellationToken);
    protected virtual SyntaxNode ChangeImplementation(SyntaxGenerator generator, SyntaxNode decl, ISymbol _);
    private static SyntaxNode WithoutExplicitImpl(SyntaxNode decl);
}
[ExportCodeFixProviderAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
[SharedAttribute]
[ExtensionOrderAttribute]
internal class Microsoft.CodeAnalysis.CSharp.ImplementInterface.CSharpImplementInterfaceCodeFixProvider : CodeFixProvider {
    private Func`2<TypeSyntax, bool> _interfaceName;
    private static string CS0535;
    private static string CS0737;
    private static string CS0738;
    [CompilerGeneratedAttribute]
private ImmutableArray`1<string> <FixableDiagnosticIds>k__BackingField;
    public ImmutableArray`1<string> FixableDiagnosticIds { get; }
    [CompilerGeneratedAttribute]
public sealed virtual ImmutableArray`1<string> get_FixableDiagnosticIds();
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.CSharp.ImplementInterface.CSharpImplementInterfaceCodeFixProvider/<RegisterCodeFixesAsync>d__8")]
public sealed virtual Task RegisterCodeFixesAsync(CodeFixContext context);
    public sealed virtual FixAllProvider GetFixAllProvider();
}
[ExportLanguageServiceAttribute("Microsoft.CodeAnalysis.ImplementInterface.IImplementInterfaceService", "C#", "Default")]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.CSharp.ImplementInterface.CSharpImplementInterfaceService : AbstractImplementInterfaceService {
    protected bool CanImplementImplicitly { get; }
    protected bool HasHiddenExplicitImplementation { get; }
    protected virtual string ToDisplayString(IMethodSymbol disposeImplMethod, SymbolDisplayFormat format);
    protected virtual bool TryInitializeState(Document document, SemanticModel model, SyntaxNode node, CancellationToken cancellationToken, SyntaxNode& classOrStructDecl, INamedTypeSymbol& classOrStructType, IEnumerable`1& interfaceTypes);
    protected virtual bool get_CanImplementImplicitly();
    protected virtual bool get_HasHiddenExplicitImplementation();
    protected virtual SyntaxNode AddCommentInsideIfStatement(SyntaxNode ifStatement, SyntaxTriviaList trivia);
    protected virtual SyntaxNode CreateFinalizer(SyntaxGenerator g, INamedTypeSymbol classType, string disposeMethodDisplayString);
}
[ExportCodeRefactoringProviderAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
[SharedAttribute]
[ExtensionOrderAttribute]
internal class Microsoft.CodeAnalysis.CSharp.InitializeParameter.CSharpAddParameterCheckCodeRefactoringProvider : AbstractAddParameterCheckCodeRefactoringProvider`5<BaseTypeDeclarationSyntax, ParameterSyntax, StatementSyntax, ExpressionSyntax, BinaryExpressionSyntax> {
    protected virtual bool IsFunctionDeclaration(SyntaxNode node);
    protected virtual SyntaxNode GetBody(SyntaxNode functionDeclaration);
    protected virtual void InsertStatement(SyntaxEditor editor, SyntaxNode functionDeclaration, bool returnsVoid, SyntaxNode statementToAddAfterOpt, StatementSyntax statement);
    protected virtual bool IsImplicitConversion(Compilation compilation, ITypeSymbol source, ITypeSymbol destination);
    protected virtual bool CanOffer(SyntaxNode body);
    protected virtual bool PrefersThrowExpression(DocumentOptionSet options);
    protected virtual string EscapeResourceString(string input);
    protected virtual StatementSyntax CreateParameterCheckIfStatement(DocumentOptionSet options, ExpressionSyntax condition, StatementSyntax ifTrueStatement);
}
[ExportCodeRefactoringProviderAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
[SharedAttribute]
[ExtensionOrderAttribute]
[ExtensionOrderAttribute]
internal class Microsoft.CodeAnalysis.CSharp.InitializeParameter.CSharpInitializeMemberFromParameterCodeRefactoringProvider : AbstractInitializeMemberFromParameterCodeRefactoringProvider`4<BaseTypeDeclarationSyntax, ParameterSyntax, StatementSyntax, ExpressionSyntax> {
    protected virtual bool IsFunctionDeclaration(SyntaxNode node);
    protected virtual SyntaxNode TryGetLastStatement(IBlockOperation blockStatementOpt);
    protected virtual void InsertStatement(SyntaxEditor editor, SyntaxNode functionDeclaration, bool returnsVoid, SyntaxNode statementToAddAfterOpt, StatementSyntax statement);
    protected virtual bool IsImplicitConversion(Compilation compilation, ITypeSymbol source, ITypeSymbol destination);
    protected virtual Accessibility DetermineDefaultFieldAccessibility(INamedTypeSymbol containingType);
    protected virtual Accessibility DetermineDefaultPropertyAccessibility();
    protected virtual SyntaxNode GetBody(SyntaxNode functionDeclaration);
}
internal static class Microsoft.CodeAnalysis.CSharp.InitializeParameter.InitializeParameterHelpers : object {
    public static bool IsFunctionDeclaration(SyntaxNode node);
    public static SyntaxNode GetBody(SyntaxNode functionDeclaration);
    private static Nullable`1<SyntaxToken> TryGetSemicolonToken(SyntaxNode functionDeclaration);
    public static bool IsImplicitConversion(Compilation compilation, ITypeSymbol source, ITypeSymbol destination);
    public static SyntaxNode TryGetLastStatement(IBlockOperation blockStatementOpt);
    public static void InsertStatement(SyntaxEditor editor, SyntaxNode functionDeclaration, bool returnsVoid, SyntaxNode statementToAddAfterOpt, StatementSyntax statement);
    public static bool IsExpressionBody(SyntaxNode body);
    public static bool TryConvertExpressionBodyToStatement(SyntaxNode body, SyntaxToken semicolonToken, bool createReturnStatementForExpression, StatementSyntax& statement);
}
[ExportCodeFixProviderAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.CSharp.InlineDeclaration.CSharpInlineDeclarationCodeFixProvider : SyntaxEditorBasedCodeFixProvider {
    public ImmutableArray`1<string> FixableDiagnosticIds { get; }
    internal CodeFixCategory CodeFixCategory { get; }
    public virtual ImmutableArray`1<string> get_FixableDiagnosticIds();
    internal sealed virtual CodeFixCategory get_CodeFixCategory();
    public virtual Task RegisterCodeFixesAsync(CodeFixContext context);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.CSharp.InlineDeclaration.CSharpInlineDeclarationCodeFixProvider/<FixAllAsync>d__6")]
protected virtual Task FixAllAsync(Document document, ImmutableArray`1<Diagnostic> diagnostics, SyntaxEditor editor, CancellationToken cancellationToken);
    private static ValueTuple`3<VariableDeclaratorSyntax, IdentifierNameSyntax, SyntaxNode> FindDiagnosticNodes(Diagnostic diagnostic, CancellationToken cancellationToken);
    private static SyntaxNode ReplaceIdentifierWithInlineDeclaration(OptionSet options, SemanticModel semanticModel, SyntaxNode currentRoot, VariableDeclaratorSyntax declarator, IdentifierNameSyntax identifier, SyntaxNode currentNode, HashSet`1<StatementSyntax> declarationsToRemove, Workspace workspace, CancellationToken cancellationToken);
    public static TypeSyntax GenerateTypeSyntaxOrVar(ITypeSymbol symbol, OptionSet options);
    private static bool IsVarDesired(ITypeSymbol type, OptionSet options);
    private static DeclarationExpressionSyntax GetDeclarationExpression(SourceText sourceText, IdentifierNameSyntax identifier, TypeSyntax newType, VariableDeclaratorSyntax declaratorOpt);
    [IteratorStateMachineAttribute("Microsoft.CodeAnalysis.CSharp.InlineDeclaration.CSharpInlineDeclarationCodeFixProvider/<MassageTrivia>d__12")]
private static IEnumerable`1<SyntaxTrivia> MassageTrivia(IEnumerable`1<SyntaxTrivia> triviaList);
    private static bool SemanticsChanged(SemanticModel semanticModel, SyntaxNode nodeToReplace, IdentifierNameSyntax identifier, DeclarationExpressionSyntax declarationExpression, CancellationToken cancellationToken);
    private static SyntaxNode GetTopmostContainer(SyntaxNode expression);
    private static bool TryGetSpeculativeSemanticModel(SemanticModel semanticModel, int position, SyntaxNode topmostContainer, SemanticModel& speculativeModel);
}
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
internal class Microsoft.CodeAnalysis.CSharp.InlineDeclaration.CSharpInlineDeclarationDiagnosticAnalyzer : AbstractBuiltInCodeStyleDiagnosticAnalyzer {
    private static string CS0165;
    public virtual DiagnosticAnalyzerCategory GetAnalyzerCategory();
    protected virtual void InitializeWorker(AnalysisContext context);
    private void AnalyzeSyntaxNode(SyntaxNodeAnalysisContext context, INamedTypeSymbol expressionTypeOpt);
    private static bool WouldCauseDefiniteAssignmentErrors(SemanticModel semanticModel, LocalDeclarationStatementSyntax localStatement, BlockSyntax enclosingBlock, ILocalSymbol outLocalSymbol);
    private static SyntaxNode GetOutArgumentScope(SyntaxNode argumentExpression);
    private static bool IsAccessed(SemanticModel semanticModel, ISymbol outSymbol, BlockSyntax enclosingBlockOfLocalStatement, LocalDeclarationStatementSyntax localStatement, ArgumentSyntax argumentNode, CancellationToken cancellationToken);
    [NullableContextAttribute("1")]
[CompilerGeneratedAttribute]
private void <InitializeWorker>b__3_0(CompilationStartAnalysisContext compilationContext);
}
[ExportLanguageServiceAttribute("Microsoft.CodeAnalysis.InlineHints.IInlineHintsService", "C#", "Default")]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.CSharp.InlineHints.CSharpInlineHintsService : AbstractInlineHintsService {
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExportLanguageServiceAttribute("Microsoft.CodeAnalysis.InlineHints.IInlineParameterNameHintsService", "C#", "Default")]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.CSharp.InlineHints.CSharpInlineParameterNameHintsService : AbstractInlineParameterNameHintsService {
    protected virtual void AddAllParameterNameHintLocations(SemanticModel semanticModel, SyntaxNode node, ArrayBuilder`1<ValueTuple`3<int, IParameterSymbol, HintKind>> buffer, CancellationToken cancellationToken);
    private static void AddArguments(SemanticModel semanticModel, ArrayBuilder`1<ValueTuple`3<int, IParameterSymbol, HintKind>> buffer, AttributeArgumentListSyntax argumentList, CancellationToken cancellationToken);
    private static void AddArguments(SemanticModel semanticModel, ArrayBuilder`1<ValueTuple`3<int, IParameterSymbol, HintKind>> buffer, BaseArgumentListSyntax argumentList, CancellationToken cancellationToken);
    private static HintKind GetKind(ExpressionSyntax arg);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExportLanguageServiceAttribute("Microsoft.CodeAnalysis.InlineHints.IInlineTypeHintsService", "C#", "Default")]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.CSharp.InlineHints.CSharpInlineTypeHintsService : AbstractInlineTypeHintsService {
    protected virtual Nullable`1<TypeHint> TryGetTypeHint(SemanticModel semanticModel, SyntaxNode node, bool displayAllOverride, bool forImplicitVariableTypes, bool forLambdaParameterTypes, bool forImplicitObjectCreation, CancellationToken cancellationToken);
    private static TypeHint CreateTypeHint(ITypeSymbol type, bool displayAllOverride, bool normalOption, SyntaxNodeOrToken displayAllSpan, SyntaxNodeOrToken normalSpan);
    private static TextSpan GetSpan(bool displayAllOverride, bool normalOption, SyntaxNodeOrToken displayAllSpan, SyntaxNodeOrToken normalSpan);
    [NullableContextAttribute("2")]
private static bool IsValidType(ITypeSymbol type);
}
[ExtensionAttribute]
internal static class Microsoft.CodeAnalysis.CSharp.InternalExtensions : object {
    [ExtensionAttribute]
public static ITypeSymbol DetermineParameterType(ArgumentSyntax argument, SemanticModel semanticModel, CancellationToken cancellationToken);
    public static ITypeSymbol DetermineParameterType(ExpressionSyntax expression, SemanticModel semanticModel, CancellationToken cancellationToken);
}
[ExtensionOrderAttribute]
[ExportCodeRefactoringProviderAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.CSharp.IntroduceUsingStatement.CSharpIntroduceUsingStatementCodeRefactoringProvider : AbstractIntroduceUsingStatementCodeRefactoringProvider`2<StatementSyntax, LocalDeclarationStatementSyntax> {
    protected string CodeActionTitle { get; }
    protected virtual string get_CodeActionTitle();
    protected virtual bool CanRefactorToContainBlockStatements(SyntaxNode parent);
    protected virtual SyntaxList`1<StatementSyntax> GetStatements(SyntaxNode parentOfStatementsToSurround);
    protected virtual SyntaxNode WithStatements(SyntaxNode parentOfStatementsToSurround, SyntaxList`1<StatementSyntax> statements);
    protected virtual StatementSyntax CreateUsingStatement(LocalDeclarationStatementSyntax declarationStatement, SyntaxTriviaList sameLineTrivia, SyntaxList`1<StatementSyntax> statementsToSurround);
}
[ExportCodeRefactoringProviderAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.CSharp.IntroduceVariable.CSharpIntroduceLocalForExpressionCodeRefactoringProvider : AbstractIntroduceLocalForExpressionCodeRefactoringProvider`4<ExpressionSyntax, StatementSyntax, ExpressionStatementSyntax, LocalDeclarationStatementSyntax> {
    protected virtual bool IsValid(ExpressionStatementSyntax expressionStatement, TextSpan span);
    protected virtual LocalDeclarationStatementSyntax FixupLocalDeclaration(ExpressionStatementSyntax expressionStatement, LocalDeclarationStatementSyntax localDeclaration);
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[ExportCodeRefactoringProviderAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.CSharp.IntroduceVariable.CSharpIntroduceParameterCodeRefactoringProvider : AbstractIntroduceParameterService`4<ExpressionSyntax, InvocationExpressionSyntax, ObjectCreationExpressionSyntax, IdentifierNameSyntax> {
    protected virtual SyntaxNode GenerateExpressionFromOptionalParameter(IParameterSymbol parameterSymbol);
    protected virtual SyntaxNode GetLocalDeclarationFromDeclarator(SyntaxNode variableDecl);
    protected virtual bool IsDestructor(IMethodSymbol methodSymbol);
    protected virtual SyntaxNode UpdateArgumentListSyntax(SyntaxNode argumentList, SeparatedSyntaxList`1<SyntaxNode> arguments);
}
[ExportLanguageServiceAttribute("Microsoft.CodeAnalysis.IntroduceVariable.IIntroduceVariableService", "C#", "Default")]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.CSharp.IntroduceVariable.CSharpIntroduceVariableService : AbstractIntroduceVariableService`6<CSharpIntroduceVariableService, ExpressionSyntax, TypeSyntax, TypeDeclarationSyntax, QueryExpressionSyntax, NameSyntax> {
    protected virtual bool IsInNonFirstQueryClause(ExpressionSyntax expression);
    protected virtual bool IsInFieldInitializer(ExpressionSyntax expression);
    protected virtual bool IsInParameterInitializer(ExpressionSyntax expression);
    protected virtual bool IsInConstructorInitializer(ExpressionSyntax expression);
    protected virtual bool IsInAutoPropertyInitializer(ExpressionSyntax expression);
    protected virtual bool IsInExpressionBodiedMember(ExpressionSyntax expression);
    protected virtual bool IsInAttributeArgumentInitializer(ExpressionSyntax expression);
    protected virtual bool CanIntroduceVariableFor(ExpressionSyntax expression);
    protected virtual IEnumerable`1<SyntaxNode> GetContainingExecutableBlocks(ExpressionSyntax expression);
    protected virtual IList`1<bool> GetInsertionIndices(TypeDeclarationSyntax destination, CancellationToken cancellationToken);
    protected virtual bool CanReplace(ExpressionSyntax expression);
    protected virtual bool IsExpressionInStaticLocalFunction(ExpressionSyntax expression);
    protected virtual TNode RewriteCore(TNode node, SyntaxNode replacementNode, ISet`1<ExpressionSyntax> matches);
    protected virtual Task`1<Document> IntroduceFieldAsync(SemanticDocument document, ExpressionSyntax expression, bool allOccurrences, bool isConstant, CancellationToken cancellationToken);
    protected virtual int DetermineConstantInsertPosition(TypeDeclarationSyntax oldType, TypeDeclarationSyntax newType);
    protected static int DetermineConstantInsertPosition(SyntaxList`1<MemberDeclarationSyntax> oldMembers, SyntaxList`1<MemberDeclarationSyntax> newMembers);
    protected virtual int DetermineFieldInsertPosition(TypeDeclarationSyntax oldType, TypeDeclarationSyntax newType);
    protected static int DetermineFieldInsertPosition(SyntaxList`1<MemberDeclarationSyntax> oldMembers, SyntaxList`1<MemberDeclarationSyntax> newMembers);
    private static bool IsConstantField(MemberDeclarationSyntax member);
    protected static int DetermineFirstChange(SyntaxList`1<MemberDeclarationSyntax> oldMembers, SyntaxList`1<MemberDeclarationSyntax> newMembers);
    protected static TypeDeclarationSyntax InsertMember(TypeDeclarationSyntax typeDeclaration, MemberDeclarationSyntax memberDeclaration, int index);
    private static SyntaxTokenList MakeFieldModifiers(bool isConstant, bool inScript);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.CSharp.IntroduceVariable.CSharpIntroduceVariableService/<IntroduceLocalAsync>d__24")]
protected virtual Task`1<Document> IntroduceLocalAsync(SemanticDocument document, ExpressionSyntax expression, bool allOccurrences, bool isConstant, CancellationToken cancellationToken);
    private Document IntroduceLocalDeclarationIntoLambda(SemanticDocument document, LambdaExpressionSyntax oldLambda, ExpressionSyntax expression, IdentifierNameSyntax newLocalName, LocalDeclarationStatementSyntax declarationStatement, bool allOccurrences, CancellationToken cancellationToken);
    private static bool ShouldIncludeReturnStatement(SemanticDocument document, LambdaExpressionSyntax oldLambda, CancellationToken cancellationToken);
    private static BlockSyntax GetNewBlockBodyForLambda(LocalDeclarationStatementSyntax declarationStatement, bool isEntireLambdaBodySelected, ExpressionSyntax rewrittenBody, bool includeReturnStatement);
    private static TypeSyntax GetTypeSyntax(SemanticDocument document, ExpressionSyntax expression, CancellationToken cancellationToken);
    private Document RewriteExpressionBodiedMemberAndIntroduceLocalDeclaration(SemanticDocument document, ArrowExpressionClauseSyntax arrowExpression, ExpressionSyntax expression, NameSyntax newLocalName, LocalDeclarationStatementSyntax declarationStatement, bool allOccurrences, bool createReturnStatement, CancellationToken cancellationToken);
    private static SyntaxNode WithBlockBody(SyntaxNode node, BlockSyntax body);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.CSharp.IntroduceVariable.CSharpIntroduceVariableService/<IntroduceLocalDeclarationIntoBlockAsync>d__31")]
private Task`1<Document> IntroduceLocalDeclarationIntoBlockAsync(SemanticDocument document, BlockSyntax block, ExpressionSyntax expression, NameSyntax newLocalName, LocalDeclarationStatementSyntax declarationStatement, bool allOccurrences, CancellationToken cancellationToken);
    [IteratorStateMachineAttribute("Microsoft.CodeAnalysis.CSharp.IntroduceVariable.CSharpIntroduceVariableService/<GetApplicableStatementAncestors>d__32")]
private static IEnumerable`1<StatementSyntax> GetApplicableStatementAncestors(ExpressionSyntax expr);
    private static int GetFirstStatementAffectedIndex(SyntaxNode innermostCommonBlock, ISet`1<ExpressionSyntax> matches, int firstStatementAffectedIndex);
    private static SyntaxList`1<StatementSyntax> InsertWithinTriviaOfNext(SyntaxList`1<StatementSyntax> oldStatements, StatementSyntax newStatement, int statementIndex);
    private static bool IsBlockLike(SyntaxNode node);
    private static SyntaxList`1<StatementSyntax> GetStatements(SyntaxNode blockLike);
    private static SyntaxNode WithStatements(SyntaxNode blockLike, SyntaxList`1<StatementSyntax> statements);
    private static bool IsAnyQueryClause(SyntaxNode node);
    protected virtual Task`1<Document> IntroduceQueryLocalAsync(SemanticDocument document, ExpressionSyntax expression, bool allOccurrences, CancellationToken cancellationToken);
    private Document IntroduceQueryLocalForSingleOccurrence(SemanticDocument document, ExpressionSyntax expression, NameSyntax newLocalName, LetClauseSyntax letClause, bool allOccurrences, CancellationToken cancellationToken);
    private static QueryBodySyntax GetNewQuery(QueryBodySyntax oldQuery, SyntaxNode oldClause, SyntaxNode newClause, LetClauseSyntax letClause);
}
[ExtensionOrderAttribute]
[ExportCodeRefactoringProviderAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.CSharp.InvertConditional.CSharpInvertConditionalCodeRefactoringProvider : AbstractInvertConditionalCodeRefactoringProvider`1<ConditionalExpressionSyntax> {
    protected virtual bool ShouldOffer(ConditionalExpressionSyntax conditional);
}
[ExportCodeRefactoringProviderAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.CSharp.InvertIf.CSharpInvertIfCodeRefactoringProvider : AbstractInvertIfCodeRefactoringProvider`3<IfStatementSyntax, StatementSyntax, StatementSyntax> {
    protected virtual string GetTitle();
    protected virtual bool IsElseless(IfStatementSyntax ifNode);
    protected virtual bool CanInvert(IfStatementSyntax ifNode);
    protected virtual SyntaxNode GetCondition(IfStatementSyntax ifNode);
    protected virtual StatementRange<IfStatementSyntax, StatementSyntax, StatementSyntax> GetIfBodyStatementRange(IfStatementSyntax ifNode);
    protected virtual bool IsStatementContainer(SyntaxNode node);
    protected virtual bool IsNoOpSyntaxNode(SyntaxNode node);
    protected virtual bool IsExecutableStatement(SyntaxNode node);
    protected virtual StatementSyntax GetNextStatement(StatementSyntax node);
    protected virtual StatementSyntax GetIfBody(IfStatementSyntax ifNode);
    protected virtual StatementSyntax GetEmptyEmbeddedStatement();
    protected virtual StatementSyntax GetElseBody(IfStatementSyntax ifNode);
    protected virtual bool CanControlFlowOut(SyntaxNode node);
    protected virtual SyntaxList`1<StatementSyntax> GetStatements(SyntaxNode node);
    protected virtual int GetJumpStatementRawKind(SyntaxNode node);
    protected virtual StatementSyntax GetJumpStatement(int rawKind);
    protected virtual StatementSyntax AsEmbeddedStatement(IEnumerable`1<StatementSyntax> statements, StatementSyntax original);
    protected virtual IfStatementSyntax UpdateIf(SourceText sourceText, IfStatementSyntax ifNode, SyntaxNode condition, StatementSyntax trueStatement, StatementSyntax falseStatementOpt);
    protected virtual SyntaxNode WithStatements(SyntaxNode node, IEnumerable`1<StatementSyntax> statements);
    protected virtual IEnumerable`1<StatementSyntax> UnwrapBlock(StatementSyntax ifBody);
    protected virtual bool IsSingleStatementStatementRange(StatementRange<IfStatementSyntax, StatementSyntax, StatementSyntax> statementRange);
    [CompilerGeneratedAttribute]
internal static bool <IsSingleStatementStatementRange>g__IsSingleStatement|21_0(StatementSyntax statement);
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[ExtensionOrderAttribute]
[ExportCodeRefactoringProviderAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.CSharp.InvertLogical.CSharpInvertLogicalCodeRefactoringProvider : AbstractInvertLogicalCodeRefactoringProvider`3<SyntaxKind, ExpressionSyntax, BinaryExpressionSyntax> {
    protected virtual string GetOperatorText(SyntaxKind binaryExprKind);
}
internal static class Microsoft.CodeAnalysis.CSharp.InvokeDelegateWithConditionalAccess.Constants : object {
    public static string Kind;
    public static string VariableAndIfStatementForm;
    public static string SingleIfStatementForm;
}
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
internal class Microsoft.CodeAnalysis.CSharp.InvokeDelegateWithConditionalAccess.InvokeDelegateWithConditionalAccessAnalyzer : AbstractBuiltInCodeStyleDiagnosticAnalyzer {
    protected virtual void InitializeWorker(AnalysisContext context);
    private void SyntaxNodeAction(SyntaxNodeAnalysisContext syntaxContext);
    private bool TryCheckSingleIfStatementForm(SyntaxNodeAnalysisContext syntaxContext, IfStatementSyntax ifStatement, BinaryExpressionSyntax condition, ExpressionStatementSyntax expressionStatement, InvocationExpressionSyntax invocationExpression, ReportDiagnostic severity);
    private void ReportDiagnostics(SyntaxNodeAnalysisContext syntaxContext, StatementSyntax firstStatement, IfStatementSyntax ifStatement, ExpressionStatementSyntax expressionStatement, ReportDiagnostic severity, ImmutableArray`1<Location> additionalLocations, string kind);
    private bool TryCheckVariableAndIfStatementForm(SyntaxNodeAnalysisContext syntaxContext, IfStatementSyntax ifStatement, BinaryExpressionSyntax condition, ExpressionStatementSyntax expressionStatement, InvocationExpressionSyntax invocationExpression, ReportDiagnostic severity);
    private static bool IsNullCheckExpression(ExpressionSyntax left, ExpressionSyntax right);
    public virtual DiagnosticAnalyzerCategory GetAnalyzerCategory();
}
[ExportCodeFixProviderAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.CSharp.InvokeDelegateWithConditionalAccess.InvokeDelegateWithConditionalAccessCodeFixProvider : SyntaxEditorBasedCodeFixProvider {
    [CompilerGeneratedAttribute]
private ImmutableArray`1<string> <FixableDiagnosticIds>k__BackingField;
    public ImmutableArray`1<string> FixableDiagnosticIds { get; }
    internal CodeFixCategory CodeFixCategory { get; }
    [CompilerGeneratedAttribute]
public virtual ImmutableArray`1<string> get_FixableDiagnosticIds();
    internal sealed virtual CodeFixCategory get_CodeFixCategory();
    protected virtual bool IncludeDiagnosticDuringFixAll(Diagnostic diagnostic);
    public virtual Task RegisterCodeFixesAsync(CodeFixContext context);
    protected virtual Task FixAllAsync(Document document, ImmutableArray`1<Diagnostic> diagnostics, SyntaxEditor editor, CancellationToken cancellationToken);
    private static void AddEdits(SyntaxEditor editor, Diagnostic diagnostic, CancellationToken cancellationToken);
    private static void HandleSingleIfStatementForm(SyntaxEditor editor, Diagnostic diagnostic, CancellationToken cancellationToken);
    private static void HandleVariableAndIfStatementForm(SyntaxEditor editor, Diagnostic diagnostic, CancellationToken cancellationToken);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal static class Microsoft.CodeAnalysis.CSharp.LambdaUtilities : object {
    public static bool IsLambda(SyntaxNode node);
    public static bool IsNotLambda(SyntaxNode node);
    public static SyntaxNode GetLambda(SyntaxNode lambdaBody);
    internal static SyntaxNode TryGetCorrespondingLambdaBody(SyntaxNode oldBody, SyntaxNode newLambda);
    public static SyntaxNode GetNestedFunctionBody(SyntaxNode nestedFunction);
    public static bool IsNotLambdaBody(SyntaxNode node);
    public static bool IsLambdaBody(SyntaxNode node, bool allowReducedLambdas);
    private static bool IsReducedSelectOrGroupByClause(SelectOrGroupClauseSyntax selectOrGroupClause, ExpressionSyntax selectOrGroupExpression);
    public static bool IsLambdaBodyStatementOrExpression(SyntaxNode node);
    public static bool IsLambdaBodyStatementOrExpression(SyntaxNode node, SyntaxNode& lambdaBody);
    [NullableContextAttribute("2")]
public static bool TryGetLambdaBodies(SyntaxNode node, SyntaxNode& lambdaBody1, SyntaxNode& lambdaBody2);
    public static bool AreEquivalentIgnoringLambdaBodies(SyntaxNode oldNode, SyntaxNode newNode);
    internal static bool IsQueryPairLambda(SyntaxNode syntax);
    internal static bool IsClosureScope(SyntaxNode node);
    internal static int GetDeclaratorPosition(SyntaxNode node);
    private static SyntaxNode GetLocalFunctionBody(LocalFunctionStatementSyntax localFunctionStatementSyntax);
}
[ExportCodeFixProviderAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.CSharp.MakeFieldReadonly.CSharpMakeFieldReadonlyCodeFixProvider : AbstractMakeFieldReadonlyCodeFixProvider`2<VariableDeclaratorSyntax, FieldDeclarationSyntax> {
    protected virtual SyntaxNode GetInitializerNode(VariableDeclaratorSyntax declaration);
    protected virtual ImmutableList`1<VariableDeclaratorSyntax> GetVariableDeclarators(FieldDeclarationSyntax fieldDeclaration);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal static class Microsoft.CodeAnalysis.CSharp.MakeLocalFunctionStatic.MakeLocalFunctionStaticCodeFixHelper : object {
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.CSharp.MakeLocalFunctionStatic.MakeLocalFunctionStaticCodeFixHelper/<MakeLocalFunctionStaticAsync>d__0")]
public static Task`1<Document> MakeLocalFunctionStaticAsync(Document document, LocalFunctionStatementSyntax localFunction, ImmutableArray`1<ISymbol> captures, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.CSharp.MakeLocalFunctionStatic.MakeLocalFunctionStaticCodeFixHelper/<MakeLocalFunctionStaticAsync>d__1")]
public static Task MakeLocalFunctionStaticAsync(Document document, LocalFunctionStatementSyntax localFunction, ImmutableArray`1<ISymbol> captures, SyntaxEditor syntaxEditor, CancellationToken cancellationToken);
    public static SyntaxNode AddStaticModifier(SyntaxNode localFunction, SyntaxGenerator generator);
    private static ImmutableArray`1<ValueTuple`2<IParameterSymbol, ISymbol>> CreateParameterSymbols(ImmutableArray`1<ISymbol> captures);
}
[ExportCodeFixProviderAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.CSharp.MakeLocalFunctionStatic.MakeLocalFunctionStaticCodeFixProvider : SyntaxEditorBasedCodeFixProvider {
    [CompilerGeneratedAttribute]
private ImmutableArray`1<string> <FixableDiagnosticIds>k__BackingField;
    public ImmutableArray`1<string> FixableDiagnosticIds { get; }
    internal CodeFixCategory CodeFixCategory { get; }
    [CompilerGeneratedAttribute]
public virtual ImmutableArray`1<string> get_FixableDiagnosticIds();
    internal sealed virtual CodeFixCategory get_CodeFixCategory();
    public virtual Task RegisterCodeFixesAsync(CodeFixContext context);
    protected virtual Task FixAllAsync(Document document, ImmutableArray`1<Diagnostic> diagnostics, SyntaxEditor editor, CancellationToken cancellationToken);
}
[ExportCodeRefactoringProviderAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.CSharp.MakeLocalFunctionStatic.MakeLocalFunctionStaticCodeRefactoringProvider : CodeRefactoringProvider {
    [NullableContextAttribute("1")]
[AsyncStateMachineAttribute("Microsoft.CodeAnalysis.CSharp.MakeLocalFunctionStatic.MakeLocalFunctionStaticCodeRefactoringProvider/<ComputeRefactoringsAsync>d__1")]
public virtual Task ComputeRefactoringsAsync(CodeRefactoringContext context);
}
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
internal class Microsoft.CodeAnalysis.CSharp.MakeLocalFunctionStatic.MakeLocalFunctionStaticDiagnosticAnalyzer : AbstractBuiltInCodeStyleDiagnosticAnalyzer {
    public virtual DiagnosticAnalyzerCategory GetAnalyzerCategory();
    protected virtual void InitializeWorker(AnalysisContext context);
    private void AnalyzeSyntax(SyntaxNodeAnalysisContext context);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal static class Microsoft.CodeAnalysis.CSharp.MakeLocalFunctionStatic.MakeLocalFunctionStaticHelper : object {
    public static bool IsStaticLocalFunctionSupported(SyntaxTree tree);
    private static bool TryGetDataFlowAnalysis(LocalFunctionStatementSyntax localFunction, SemanticModel semanticModel, DataFlowAnalysis& dataFlow);
    private static bool CanBeCalledFromStaticContext(LocalFunctionStatementSyntax localFunction, DataFlowAnalysis dataFlow);
    private static bool HasCapturesThatArentThis(ImmutableArray`1<ISymbol> captures);
    public static bool CanMakeLocalFunctionStaticBecauseNoCaptures(LocalFunctionStatementSyntax localFunction, SemanticModel semanticModel);
    public static bool CanMakeLocalFunctionStaticByRefactoringCaptures(LocalFunctionStatementSyntax localFunction, SemanticModel semanticModel, ImmutableArray`1& captures);
    [CompilerGeneratedAttribute]
internal static bool <CanBeCalledFromStaticContext>g__IsChildOrSelf|2_1(LocalFunctionStatementSyntax containingLocalFunction, ISymbol calledLocationFunction);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExportCodeFixProviderAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.CSharp.MakeLocalFunctionStatic.PassInCapturedVariablesAsArgumentsCodeFixProvider : SyntaxEditorBasedCodeFixProvider {
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ImmutableArray`1<string> FixableDiagnosticIds { get; }
    internal CodeFixCategory CodeFixCategory { get; }
    public virtual ImmutableArray`1<string> get_FixableDiagnosticIds();
    internal virtual CodeFixCategory get_CodeFixCategory();
    public virtual Task RegisterCodeFixesAsync(CodeFixContext context);
    protected virtual Task FixAllAsync(Document document, ImmutableArray`1<Diagnostic> diagnostics, SyntaxEditor editor, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.CSharp.MakeLocalFunctionStatic.PassInCapturedVariablesAsArgumentsCodeFixProvider/<WrapFixAsync>d__7")]
private static Task WrapFixAsync(Document document, ImmutableArray`1<Diagnostic> diagnostics, Func`4<Document, LocalFunctionStatementSyntax, ImmutableArray`1<ISymbol>, Task> fixer, CancellationToken cancellationToken);
}
[ExportCodeFixProviderAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.CSharp.MakeMemberStatic.CSharpMakeMemberStaticCodeFixProvider : AbstractMakeMemberStaticCodeFixProvider {
    [CompilerGeneratedAttribute]
private ImmutableArray`1<string> <FixableDiagnosticIds>k__BackingField;
    public ImmutableArray`1<string> FixableDiagnosticIds { get; }
    [CompilerGeneratedAttribute]
public virtual ImmutableArray`1<string> get_FixableDiagnosticIds();
    protected virtual bool IsValidMemberNode(SyntaxNode node);
}
[ExportCodeFixProviderAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.CSharp.MakeMethodAsynchronous.CSharpMakeMethodAsynchronousCodeFixProvider : AbstractMakeMethodAsynchronousCodeFixProvider {
    private static string CS4032;
    private static string CS4033;
    private static string CS4034;
    private static SyntaxToken s_asyncToken;
    [CompilerGeneratedAttribute]
private ImmutableArray`1<string> <FixableDiagnosticIds>k__BackingField;
    public ImmutableArray`1<string> FixableDiagnosticIds { get; }
    private static CSharpMakeMethodAsynchronousCodeFixProvider();
    [CompilerGeneratedAttribute]
public virtual ImmutableArray`1<string> get_FixableDiagnosticIds();
    protected virtual string GetMakeAsyncTaskFunctionResource();
    protected virtual string GetMakeAsyncVoidFunctionResource();
    protected virtual bool IsAsyncSupportingFunctionSyntax(SyntaxNode node);
    protected virtual bool IsAsyncReturnType(ITypeSymbol type, KnownTypes knownTypes);
    protected virtual SyntaxNode AddAsyncTokenAndFixReturnType(bool keepVoid, IMethodSymbol methodSymbolOpt, SyntaxNode node, KnownTypes knownTypes);
    private static SyntaxNode FixMethod(bool keepVoid, IMethodSymbol methodSymbol, MethodDeclarationSyntax method, KnownTypes knownTypes);
    private static SyntaxNode FixLocalFunction(bool keepVoid, IMethodSymbol methodSymbol, LocalFunctionStatementSyntax localFunction, KnownTypes knownTypes);
    private static TypeSyntax FixMethodReturnType(bool keepVoid, IMethodSymbol methodSymbol, TypeSyntax returnTypeSyntax, KnownTypes knownTypes);
    private static bool IsIterator(IMethodSymbol x);
    private static bool IsIAsyncEnumerableOrEnumerator(ITypeSymbol returnType, KnownTypes knownTypes);
    private static bool IsIEnumerable(ITypeSymbol returnType, KnownTypes knownTypes);
    private static bool IsIEnumerator(ITypeSymbol returnType, KnownTypes knownTypes);
    private static SyntaxTokenList AddAsyncModifierWithCorrectedTrivia(SyntaxTokenList modifiers, TypeSyntax& newReturnType);
    private static SyntaxNode FixParenthesizedLambda(ParenthesizedLambdaExpressionSyntax lambda);
    private static SyntaxNode FixSimpleLambda(SimpleLambdaExpressionSyntax lambda);
    private static SyntaxNode FixAnonymousMethod(AnonymousMethodExpressionSyntax method);
    [CompilerGeneratedAttribute]
internal static TypeSyntax <FixMethodReturnType>g__MakeGenericType|15_0(string type, ITypeSymbol typeArgumentFrom);
    [CompilerGeneratedAttribute]
internal static bool <IsIterator>g__ContainsYield|16_1(SyntaxNode node);
    [CompilerGeneratedAttribute]
internal static bool <IsIterator>g__IsYield|16_2(SyntaxNode node);
}
[ExportCodeFixProviderAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
[SharedAttribute]
[ExtensionOrderAttribute]
internal class Microsoft.CodeAnalysis.CSharp.MakeMethodSynchronous.CSharpMakeMethodSynchronousCodeFixProvider : AbstractMakeMethodSynchronousCodeFixProvider {
    private static string CS1998;
    [CompilerGeneratedAttribute]
private ImmutableArray`1<string> <FixableDiagnosticIds>k__BackingField;
    public ImmutableArray`1<string> FixableDiagnosticIds { get; }
    [CompilerGeneratedAttribute]
public virtual ImmutableArray`1<string> get_FixableDiagnosticIds();
    protected virtual bool IsAsyncSupportingFunctionSyntax(SyntaxNode node);
    protected virtual SyntaxNode RemoveAsyncTokenAndFixReturnType(IMethodSymbol methodSymbolOpt, SyntaxNode node, KnownTypes knownTypes);
    private static SyntaxNode FixMethod(IMethodSymbol methodSymbol, MethodDeclarationSyntax method, KnownTypes knownTypes);
    private static SyntaxNode FixLocalFunction(IMethodSymbol methodSymbol, LocalFunctionStatementSyntax localFunction, KnownTypes knownTypes);
    private static TypeSyntax FixMethodReturnType(IMethodSymbol methodSymbol, TypeSyntax returnTypeSyntax, KnownTypes knownTypes);
}
internal static class Microsoft.CodeAnalysis.CSharp.MakeMethodSynchronous.RemoveAsyncModifierHelpers : object {
    internal static SyntaxNode WithoutAsyncModifier(MethodDeclarationSyntax method, TypeSyntax returnType);
    internal static SyntaxNode WithoutAsyncModifier(LocalFunctionStatementSyntax localFunction, TypeSyntax returnType);
    internal static SyntaxNode WithoutAsyncModifier(ParenthesizedLambdaExpressionSyntax lambda);
    internal static SyntaxNode WithoutAsyncModifier(SimpleLambdaExpressionSyntax lambda);
    internal static SyntaxNode WithoutAsyncModifier(AnonymousMethodExpressionSyntax method);
    private static SyntaxTokenList RemoveAsyncModifier(SyntaxTokenList modifiers, TypeSyntax& newReturnType);
}
[ExportCodeFixProviderAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.CSharp.MakeRefStruct.MakeRefStructCodeFixProvider : CodeFixProvider {
    private static string CS8345;
    public ImmutableArray`1<string> FixableDiagnosticIds { get; }
    public virtual ImmutableArray`1<string> get_FixableDiagnosticIds();
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.CSharp.MakeRefStruct.MakeRefStructCodeFixProvider/<RegisterCodeFixesAsync>d__4")]
public virtual Task RegisterCodeFixesAsync(CodeFixContext context);
    public virtual FixAllProvider GetFixAllProvider();
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.CSharp.MakeRefStruct.MakeRefStructCodeFixProvider/<FixCodeAsync>d__6")]
private static Task`1<Document> FixCodeAsync(Document document, StructDeclarationSyntax structDeclaration, CancellationToken cancellationToken);
    private static StructDeclarationSyntax FindContainingStruct(SyntaxNode root, TextSpan span);
}
[ExportCodeFixProviderAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.CSharp.MakeStructFieldsWritable.CSharpMakeStructFieldsWritableCodeFixProvider : SyntaxEditorBasedCodeFixProvider {
    public ImmutableArray`1<string> FixableDiagnosticIds { get; }
    internal CodeFixCategory CodeFixCategory { get; }
    public virtual ImmutableArray`1<string> get_FixableDiagnosticIds();
    internal sealed virtual CodeFixCategory get_CodeFixCategory();
    public virtual Task RegisterCodeFixesAsync(CodeFixContext context);
    protected virtual Task FixAllAsync(Document document, ImmutableArray`1<Diagnostic> diagnostics, SyntaxEditor editor, CancellationToken cancellationToken);
}
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
internal class Microsoft.CodeAnalysis.CSharp.MakeStructFieldsWritable.CSharpMakeStructFieldsWritableDiagnosticAnalyzer : AbstractCodeQualityDiagnosticAnalyzer {
    private static DiagnosticDescriptor s_diagnosticDescriptor;
    private static CSharpMakeStructFieldsWritableDiagnosticAnalyzer();
    public virtual DiagnosticAnalyzerCategory GetAnalyzerCategory();
    protected virtual void InitializeWorker(AnalysisContext context);
}
[NullableContextAttribute("2")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[ExportCodeFixProviderAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.CSharp.MakeTypeAbstract.CSharpMakeTypeAbstractCodeFixProvider : AbstractMakeTypeAbstractCodeFixProvider`1<TypeDeclarationSyntax> {
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private ImmutableArray`1<string> <FixableDiagnosticIds>k__BackingField;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ImmutableArray`1<string> FixableDiagnosticIds { get; }
    [CompilerGeneratedAttribute]
public virtual ImmutableArray`1<string> get_FixableDiagnosticIds();
    protected virtual bool IsValidRefactoringContext(SyntaxNode node, TypeDeclarationSyntax& typeDeclaration);
}
internal class Microsoft.CodeAnalysis.CSharp.MetadataAsSource.CSharpMetadataAsSourceService : AbstractMetadataAsSourceService {
    private static AbstractFormattingRule s_memberSeparationRule;
    public static CSharpMetadataAsSourceService Instance;
    private static CSharpMetadataAsSourceService();
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.CSharp.MetadataAsSource.CSharpMetadataAsSourceService/<AddAssemblyInfoRegionAsync>d__3")]
protected virtual Task`1<Document> AddAssemblyInfoRegionAsync(Document document, Compilation symbolCompilation, ISymbol symbol, CancellationToken cancellationToken);
    protected virtual IEnumerable`1<AbstractFormattingRule> GetFormattingRules(Document document);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.CSharp.MetadataAsSource.CSharpMetadataAsSourceService/<ConvertDocCommentsToRegularCommentsAsync>d__5")]
protected virtual Task`1<Document> ConvertDocCommentsToRegularCommentsAsync(Document document, IDocumentationCommentFormattingService docCommentFormattingService, CancellationToken cancellationToken);
    protected virtual ImmutableArray`1<AbstractReducer> GetReducers();
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.CSharp.MetadataAsSource.CSharpMetadataAsSourceService/<AddNullableRegionsAsync>d__7")]
protected virtual Task`1<Document> AddNullableRegionsAsync(Document document, CancellationToken cancellationToken);
    private static ValueTuple`2<bool, bool> GetNullableAnnotations(SyntaxNode node);
    private static bool HasAnnotation(SyntaxNode node, SyntaxAnnotation annotation);
    private static SyntaxTrivia[] CreateNullableTrivia(bool enable);
    private TSyntax AddNullableRegions(TSyntax node, CancellationToken cancellationToken);
    private SyntaxList`1<MemberDeclarationSyntax> AddNullableRegions(SyntaxList`1<MemberDeclarationSyntax> members, CancellationToken cancellationToken);
    private TypeDeclarationSyntax AddNullableRegionsAroundTypeMembers(TypeDeclarationSyntax type, CancellationToken cancellationToken);
    private static MemberDeclarationSyntax TransitionTo(MemberDeclarationSyntax member, bool enabled, Boolean& currentlyEnabled);
}
[ExportLanguageServiceFactoryAttribute("Microsoft.CodeAnalysis.MetadataAsSource.IMetadataAsSourceService", "C#", "Default")]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.CSharp.MetadataAsSource.CSharpMetadataAsSourceServiceFactory : object {
    public sealed virtual ILanguageService CreateLanguageService(HostLanguageServices provider);
}
[ExportCodeFixProviderAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.CSharp.MisplacedUsingDirectives.MisplacedUsingDirectivesCodeFixProvider : CodeFixProvider {
    private static SyntaxAnnotation s_usingPlacementCodeFixAnnotation;
    public ImmutableArray`1<string> FixableDiagnosticIds { get; }
    private static MisplacedUsingDirectivesCodeFixProvider();
    public virtual ImmutableArray`1<string> get_FixableDiagnosticIds();
    public virtual FixAllProvider GetFixAllProvider();
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.CSharp.MisplacedUsingDirectives.MisplacedUsingDirectivesCodeFixProvider/<RegisterCodeFixesAsync>d__5")]
public virtual Task RegisterCodeFixesAsync(CodeFixContext context);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.CSharp.MisplacedUsingDirectives.MisplacedUsingDirectivesCodeFixProvider/<TransformDocumentIfRequiredAsync>d__6")]
internal static Task`1<Document> TransformDocumentIfRequiredAsync(Document document, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.CSharp.MisplacedUsingDirectives.MisplacedUsingDirectivesCodeFixProvider/<GetTransformedDocumentAsync>d__7")]
private static Task`1<Document> GetTransformedDocumentAsync(Document document, CompilationUnitSyntax compilationUnit, AddImportPlacement placement, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.CSharp.MisplacedUsingDirectives.MisplacedUsingDirectivesCodeFixProvider/<ExpandUsingDirectivesAsync>d__8")]
private static Task`1<SyntaxNode> ExpandUsingDirectivesAsync(Document document, CompilationUnitSyntax containerNode, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.CSharp.MisplacedUsingDirectives.MisplacedUsingDirectivesCodeFixProvider/<ExpandUsingDirectiveAsync>d__9")]
private static Task`1<SyntaxNode> ExpandUsingDirectiveAsync(Document document, SyntaxNode node, CancellationToken cancellationToken);
    private static CompilationUnitSyntax MoveUsingsInsideNamespace(CompilationUnitSyntax compilationUnit, SyntaxAnnotation warningAnnotation);
    private static CompilationUnitSyntax MoveUsingsOutsideNamespaces(CompilationUnitSyntax compilationUnit, SyntaxAnnotation warningAnnotation);
    private static ValueTuple`2<NamespaceDeclarationSyntax, IEnumerable`1<UsingDirectiveSyntax>> RemoveUsingsFromNamespace(NamespaceDeclarationSyntax usingContainer);
    private static ValueTuple`2<IEnumerable`1<UsingDirectiveSyntax>, IEnumerable`1<SyntaxTrivia>> RemoveDuplicateUsings(IEnumerable`1<UsingDirectiveSyntax> existingUsings, ImmutableArray`1<UsingDirectiveSyntax> usingsToAdd);
    private static SyntaxList`1<MemberDeclarationSyntax> GetMembers(SyntaxNode node);
    private static TSyntaxNode RemoveLeadingBlankLinesFromFirstMember(TSyntaxNode node);
    [IteratorStateMachineAttribute("Microsoft.CodeAnalysis.CSharp.MisplacedUsingDirectives.MisplacedUsingDirectivesCodeFixProvider/<SplitIntoLines>d__16")]
private static IEnumerable`1<IEnumerable`1<SyntaxTrivia>> SplitIntoLines(SyntaxTriviaList triviaList);
    private static TSyntaxNode EnsureLeadingBlankLineBeforeFirstMember(TSyntaxNode node);
    private static ValueTuple`2<AddImportPlacement, bool> DeterminePlacement(CompilationUnitSyntax compilationUnit, OptionSet options);
    private static bool HasOneNamespace(CompilationUnitSyntax compilationUnit);
    private static ValueTuple`2<CompilationUnitSyntax, ImmutableArray`1<SyntaxTrivia>> RemoveFileHeader(CompilationUnitSyntax syntaxRoot, ISyntaxFactsService syntaxFactsService);
    private static CompilationUnitSyntax AddFileHeader(CompilationUnitSyntax compilationUnit, ImmutableArray`1<SyntaxTrivia> fileHeader);
}
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
internal class Microsoft.CodeAnalysis.CSharp.MisplacedUsingDirectives.MisplacedUsingDirectivesDiagnosticAnalyzer : AbstractBuiltInCodeStyleDiagnosticAnalyzer {
    private static LocalizableResourceString s_localizableTitle;
    private static LocalizableResourceString s_localizableOutsideMessage;
    private static DiagnosticDescriptor s_outsideDiagnosticDescriptor;
    private static LocalizableResourceString s_localizableInsideMessage;
    private static DiagnosticDescriptor s_insideDiagnosticDescriptor;
    private static MisplacedUsingDirectivesDiagnosticAnalyzer();
    public virtual DiagnosticAnalyzerCategory GetAnalyzerCategory();
    protected virtual void InitializeWorker(AnalysisContext context);
    private void AnalyzeNamespaceNode(SyntaxNodeAnalysisContext context);
    private static void AnalyzeCompilationUnitNode(SyntaxNodeAnalysisContext context);
    private static bool ShouldSuppressDiagnostic(CompilationUnitSyntax compilationUnit);
    private static void ReportDiagnostics(SyntaxNodeAnalysisContext context, DiagnosticDescriptor descriptor, IEnumerable`1<UsingDirectiveSyntax> usingDirectives, CodeStyleOption2`1<AddImportPlacement> option);
}
[ExportCodeRefactoringProviderAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
[SharedAttribute]
[ExtensionOrderAttribute]
internal class Microsoft.CodeAnalysis.CSharp.MoveDeclarationNearReference.CSharpMoveDeclarationNearReferenceCodeRefactoringProvider : AbstractMoveDeclarationNearReferenceCodeRefactoringProvider`1<LocalDeclarationStatementSyntax> {
}
[ExportLanguageServiceAttribute("Microsoft.CodeAnalysis.MoveToNamespace.IMoveToNamespaceService", "C#", "Default")]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.CSharp.MoveToNamespace.CSharpMoveToNamespaceService : AbstractMoveToNamespaceService`3<CompilationUnitSyntax, NamespaceDeclarationSyntax, BaseTypeDeclarationSyntax> {
    [ImportingConstructorAttribute]
[ObsoleteAttribute("This exported object must be obtained through the MEF export provider.", "True")]
public CSharpMoveToNamespaceService(IMoveToNamespaceOptionsService optionsService);
    protected virtual string GetNamespaceName(SyntaxNode container);
    protected virtual bool IsContainedInNamespaceDeclaration(NamespaceDeclarationSyntax namespaceDeclaration, int position);
}
[ExtensionOrderAttribute]
[ExportCodeRefactoringProviderAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.CSharp.NameTupleElement.CSharpNameTupleElementCodeRefactoringProvider : AbstractNameTupleElementCodeRefactoringProvider`2<ArgumentSyntax, TupleExpressionSyntax> {
    protected virtual ArgumentSyntax WithName(ArgumentSyntax argument, string argumentName);
}
[ExportLanguageServiceAttribute("Microsoft.CodeAnalysis.NavigateTo.INavigateToSearchService", "C#", "Default")]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.CSharp.NavigateTo.CSharpNavigateToSearchService : AbstractNavigateToSearchService {
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExportLanguageServiceAttribute("Microsoft.CodeAnalysis.NavigationBar.INavigationBarItemService", "C#", "Default")]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.CSharp.NavigationBar.CSharpNavigationBarItemService : AbstractNavigationBarItemService {
    private static SymbolDisplayFormat s_typeFormat;
    private static SymbolDisplayFormat s_memberFormat;
    private static CSharpNavigationBarItemService();
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.CSharp.NavigationBar.CSharpNavigationBarItemService/<GetItemsInCurrentProcessAsync>d__3")]
protected virtual Task`1<ImmutableArray`1<RoslynNavigationBarItem>> GetItemsInCurrentProcessAsync(Document document, bool supportsCodeGeneration, CancellationToken cancellationToken);
    private static ImmutableArray`1<RoslynNavigationBarItem> GetMembersInTypes(SyntaxTree tree, IEnumerable`1<INamedTypeSymbol> types, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.CSharp.NavigationBar.CSharpNavigationBarItemService/<GetTypesInFileAsync>d__5")]
private static Task`1<IEnumerable`1<INamedTypeSymbol>> GetTypesInFileAsync(Document document, CancellationToken cancellationToken);
    private static IEnumerable`1<INamedTypeSymbol> GetTypesInFile(SemanticModel semanticModel, CancellationToken cancellationToken);
    private static ISymbol GetType(SemanticModel semanticModel, SyntaxNode node, CancellationToken cancellationToken);
    private static bool IsAccessor(ISymbol member);
    private static RoslynNavigationBarItem CreateItemForMember(ISymbol member, int symbolIndex, SyntaxTree tree, CancellationToken cancellationToken);
    private static ImmutableArray`1<TextSpan> GetSpansInDocument(ISymbol symbol, SyntaxTree tree, CancellationToken cancellationToken);
    private static void AddFieldSpan(ISymbol symbol, SyntaxTree tree, ArrayBuilder`1<TextSpan> spans);
    private static void AddEnumMemberSpan(ISymbol symbol, SyntaxTree tree, ArrayBuilder`1<TextSpan> spans);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExportCodeFixProviderAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.CSharp.NewLines.ConsecutiveBracePlacement.ConsecutiveBracePlacementCodeFixProvider : CodeFixProvider {
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ImmutableArray`1<string> FixableDiagnosticIds { get; }
    public virtual ImmutableArray`1<string> get_FixableDiagnosticIds();
    public virtual Task RegisterCodeFixesAsync(CodeFixContext context);
    private static Task`1<Document> UpdateDocumentAsync(Document document, Diagnostic diagnostic, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.CSharp.NewLines.ConsecutiveBracePlacement.ConsecutiveBracePlacementCodeFixProvider/<FixAllAsync>d__5")]
public static Task`1<Document> FixAllAsync(Document document, ImmutableArray`1<Diagnostic> diagnostics, CancellationToken cancellationToken);
    private static void FixOne(SyntaxNode root, SourceText text, Dictionary`2<SyntaxToken, SyntaxToken> tokenToToken, Diagnostic diagnostic, CancellationToken cancellationToken);
    public virtual FixAllProvider GetFixAllProvider();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
internal class Microsoft.CodeAnalysis.CSharp.NewLines.ConsecutiveBracePlacement.ConsecutiveBracePlacementDiagnosticAnalyzer : AbstractBuiltInCodeStyleDiagnosticAnalyzer {
    public virtual DiagnosticAnalyzerCategory GetAnalyzerCategory();
    protected virtual void InitializeWorker(AnalysisContext context);
    private void AnalyzeTree(SyntaxTreeAnalysisContext context);
    private void Recurse(SyntaxTreeAnalysisContext context, ReportDiagnostic severity, ArrayBuilder`1<SyntaxNode> stack);
    private void ProcessToken(SyntaxTreeAnalysisContext context, ReportDiagnostic severity, SourceText text, SyntaxToken token);
    public static bool HasExcessBlankLinesAfter(SourceText text, SyntaxToken token, SyntaxToken& secondBrace, SyntaxTrivia& endOfLineTrivia);
    private static bool IsAllWhitespace(TextLine textLine);
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
internal class Microsoft.CodeAnalysis.CSharp.NewLines.ConsecutiveStatementPlacement.CSharpConsecutiveStatementPlacementDiagnosticAnalyzer : AbstractConsecutiveStatementPlacementDiagnosticAnalyzer`1<StatementSyntax> {
    protected virtual bool IsBlockLikeStatement(SyntaxNode node);
    protected virtual Location GetDiagnosticLocation(SyntaxNode block);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExportCodeFixProviderAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.CSharp.NewLines.ConstructorInitializerPlacement.ConstructorInitializerPlacementCodeFixProvider : CodeFixProvider {
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ImmutableArray`1<string> FixableDiagnosticIds { get; }
    public virtual ImmutableArray`1<string> get_FixableDiagnosticIds();
    public virtual Task RegisterCodeFixesAsync(CodeFixContext context);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.CSharp.NewLines.ConstructorInitializerPlacement.ConstructorInitializerPlacementCodeFixProvider/<UpdateDocumentAsync>d__4")]
private static Task`1<Document> UpdateDocumentAsync(Document document, ImmutableArray`1<Diagnostic> diagnostics, CancellationToken cancellationToken);
    private static void MoveTriviaWhenOnSameLine(Dictionary`2<SyntaxToken, SyntaxToken> replacementMap, SyntaxToken colonToken, SyntaxToken thisBaseKeyword);
    [NullableContextAttribute("2")]
public virtual FixAllProvider GetFixAllProvider();
    [CompilerGeneratedAttribute]
internal static SyntaxToken <MoveTriviaWhenOnSameLine>g__ComputeNewCloseParen|5_0(SyntaxToken colonToken, SyntaxToken previousToken);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
internal class Microsoft.CodeAnalysis.CSharp.NewLines.ConstructorInitializerPlacement.ConstructorInitializerPlacementDiagnosticAnalyzer : AbstractBuiltInCodeStyleDiagnosticAnalyzer {
    public virtual DiagnosticAnalyzerCategory GetAnalyzerCategory();
    protected virtual void InitializeWorker(AnalysisContext context);
    private void AnalyzeTree(SyntaxTreeAnalysisContext context);
    private void Recurse(SyntaxTreeAnalysisContext context, ReportDiagnostic severity, SyntaxNode node);
    private void ProcessConstructorInitializer(SyntaxTreeAnalysisContext context, ReportDiagnostic severity, ConstructorInitializerSyntax initializer);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExportCodeFixProviderAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.CSharp.NewLines.EmbeddedStatementPlacement.EmbeddedStatementPlacementCodeFixProvider : CodeFixProvider {
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ImmutableArray`1<string> FixableDiagnosticIds { get; }
    public virtual ImmutableArray`1<string> get_FixableDiagnosticIds();
    public virtual Task RegisterCodeFixesAsync(CodeFixContext context);
    private static Task`1<Document> UpdateDocumentAsync(Document document, Diagnostic diagnostic, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.CSharp.NewLines.EmbeddedStatementPlacement.EmbeddedStatementPlacementCodeFixProvider/<FixAllAsync>d__5")]
public static Task`1<Document> FixAllAsync(Document document, ImmutableArray`1<Diagnostic> diagnostics, CancellationToken cancellationToken);
    private static void FixOne(SyntaxEditor editor, Diagnostic diagnostic, SyntaxTrivia endOfLineTrivia, CancellationToken cancellationToken);
    private static SyntaxNode AddLeadingTrivia(SyntaxNode node, SyntaxTrivia trivia);
    private static SyntaxToken AddLeadingTrivia(SyntaxToken token, SyntaxTrivia trivia);
    public virtual FixAllProvider GetFixAllProvider();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
internal class Microsoft.CodeAnalysis.CSharp.NewLines.EmbeddedStatementPlacement.EmbeddedStatementPlacementDiagnosticAnalyzer : AbstractBuiltInCodeStyleDiagnosticAnalyzer {
    public virtual DiagnosticAnalyzerCategory GetAnalyzerCategory();
    protected virtual void InitializeWorker(AnalysisContext context);
    private void AnalyzeTree(SyntaxTreeAnalysisContext context);
    private void Recurse(SyntaxTreeAnalysisContext context, ReportDiagnostic severity, SyntaxNode node);
    private bool CheckStatementSyntax(SyntaxTreeAnalysisContext context, ReportDiagnostic severity, StatementSyntax statement);
    public static bool StatementNeedsWrapping(StatementSyntax statement);
    public static bool ContainsEndOfLineBetween(SyntaxToken previous, SyntaxToken next);
    private static bool ContainsEndOfLine(SyntaxTriviaList triviaList);
}
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
internal class Microsoft.CodeAnalysis.CSharp.NewLines.MultipleBlankLines.CSharpMultipleBlankLinesDiagnosticAnalyzer : AbstractMultipleBlankLinesDiagnosticAnalyzer {
}
[ExportCodeFixProviderAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.CSharp.OrderModifiers.CSharpOrderModifiersCodeFixProvider : AbstractOrderModifiersCodeFixProvider {
    private static string CS0267;
    [CompilerGeneratedAttribute]
private ImmutableArray`1<string> <FixableCompilerErrorIds>k__BackingField;
    protected ImmutableArray`1<string> FixableCompilerErrorIds { get; }
    [CompilerGeneratedAttribute]
protected virtual ImmutableArray`1<string> get_FixableCompilerErrorIds();
}
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
internal class Microsoft.CodeAnalysis.CSharp.OrderModifiers.CSharpOrderModifiersDiagnosticAnalyzer : AbstractOrderModifiersDiagnosticAnalyzer {
    protected virtual void Recurse(SyntaxTreeAnalysisContext context, Dictionary`2<int, int> preferredOrder, ReportDiagnostic severity, SyntaxNode root);
}
internal class Microsoft.CodeAnalysis.CSharp.OrderModifiers.CSharpOrderModifiersHelper : AbstractOrderModifiersHelpers {
    public static CSharpOrderModifiersHelper Instance;
    private static CSharpOrderModifiersHelper();
    protected virtual int GetKeywordKind(string trimmed);
    protected virtual bool TryParse(string value, Dictionary`2& parsed);
}
[ExportLanguageServiceAttribute("Microsoft.CodeAnalysis.Organizing.IOrganizingService", "C#", "Default")]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.CSharp.Organizing.CSharpOrganizingService : AbstractOrganizingService {
    [ImportingConstructorAttribute]
[ObsoleteAttribute("This exported object must be obtained through the MEF export provider.", "True")]
public CSharpOrganizingService(IEnumerable`1<Lazy`2<ISyntaxOrganizer, LanguageMetadata>> organizers);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.CSharp.Organizing.CSharpOrganizingService/<ProcessAsync>d__1")]
protected virtual Task`1<Document> ProcessAsync(Document document, IEnumerable`1<ISyntaxOrganizer> organizers, CancellationToken cancellationToken);
}
[ExportSyntaxNodeOrganizerAttribute("C#")]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.CSharp.Organizing.Organizers.ClassDeclarationOrganizer : AbstractSyntaxNodeOrganizer`1<ClassDeclarationSyntax> {
    protected virtual ClassDeclarationSyntax Organize(ClassDeclarationSyntax syntax, CancellationToken cancellationToken);
}
[ExportSyntaxNodeOrganizerAttribute("C#")]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.CSharp.Organizing.Organizers.ConstructorDeclarationOrganizer : AbstractSyntaxNodeOrganizer`1<ConstructorDeclarationSyntax> {
    protected virtual ConstructorDeclarationSyntax Organize(ConstructorDeclarationSyntax syntax, CancellationToken cancellationToken);
}
[ExportSyntaxNodeOrganizerAttribute("C#")]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.CSharp.Organizing.Organizers.DestructorDeclarationOrganizer : AbstractSyntaxNodeOrganizer`1<DestructorDeclarationSyntax> {
    protected virtual DestructorDeclarationSyntax Organize(DestructorDeclarationSyntax syntax, CancellationToken cancellationToken);
}
[ExportSyntaxNodeOrganizerAttribute("C#")]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.CSharp.Organizing.Organizers.EnumDeclarationOrganizer : AbstractSyntaxNodeOrganizer`1<EnumDeclarationSyntax> {
    protected virtual EnumDeclarationSyntax Organize(EnumDeclarationSyntax syntax, CancellationToken cancellationToken);
}
[ExportSyntaxNodeOrganizerAttribute("C#")]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.CSharp.Organizing.Organizers.EventDeclarationOrganizer : AbstractSyntaxNodeOrganizer`1<EventDeclarationSyntax> {
    protected virtual EventDeclarationSyntax Organize(EventDeclarationSyntax syntax, CancellationToken cancellationToken);
}
[ExportSyntaxNodeOrganizerAttribute("C#")]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.CSharp.Organizing.Organizers.EventFieldDeclarationOrganizer : AbstractSyntaxNodeOrganizer`1<EventFieldDeclarationSyntax> {
    protected virtual EventFieldDeclarationSyntax Organize(EventFieldDeclarationSyntax syntax, CancellationToken cancellationToken);
}
[ExportSyntaxNodeOrganizerAttribute("C#")]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.CSharp.Organizing.Organizers.FieldDeclarationOrganizer : AbstractSyntaxNodeOrganizer`1<FieldDeclarationSyntax> {
    protected virtual FieldDeclarationSyntax Organize(FieldDeclarationSyntax syntax, CancellationToken cancellationToken);
}
[ExportSyntaxNodeOrganizerAttribute("C#")]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.CSharp.Organizing.Organizers.IndexerDeclarationOrganizer : AbstractSyntaxNodeOrganizer`1<IndexerDeclarationSyntax> {
    protected virtual IndexerDeclarationSyntax Organize(IndexerDeclarationSyntax syntax, CancellationToken cancellationToken);
}
[ExportSyntaxNodeOrganizerAttribute("C#")]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.CSharp.Organizing.Organizers.InterfaceDeclarationOrganizer : AbstractSyntaxNodeOrganizer`1<InterfaceDeclarationSyntax> {
    protected virtual InterfaceDeclarationSyntax Organize(InterfaceDeclarationSyntax syntax, CancellationToken cancellationToken);
}
internal static class Microsoft.CodeAnalysis.CSharp.Organizing.Organizers.MemberDeclarationsOrganizer : object {
    public static SyntaxList`1<MemberDeclarationSyntax> Organize(SyntaxList`1<MemberDeclarationSyntax> members, CancellationToken cancellationToken);
    private static void TransferTrivia(IList`1<TSyntaxNode> originalList, IList`1<TSyntaxNode> finalList);
    private static void FixupOriginalFirstNode(IList`1<TSyntaxNode> originalList, IList`1<TSyntaxNode> finalList);
    private static void CopyBanner(IList`1<TSyntaxNode> originalList, IList`1<TSyntaxNode> finalList);
    private static IList`1<MemberDeclarationSyntax> OrganizeMemberGroup(IList`1<MemberDeclarationSyntax> members);
}
[ExportSyntaxNodeOrganizerAttribute("C#")]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.CSharp.Organizing.Organizers.MethodDeclarationOrganizer : AbstractSyntaxNodeOrganizer`1<MethodDeclarationSyntax> {
    protected virtual MethodDeclarationSyntax Organize(MethodDeclarationSyntax syntax, CancellationToken cancellationToken);
}
internal static class Microsoft.CodeAnalysis.CSharp.Organizing.Organizers.ModifiersOrganizer : object {
    public static SyntaxTokenList Organize(SyntaxTokenList modifiers);
}
[ExportSyntaxNodeOrganizerAttribute("C#")]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.CSharp.Organizing.Organizers.OperatorDeclarationOrganizer : AbstractSyntaxNodeOrganizer`1<OperatorDeclarationSyntax> {
    protected virtual OperatorDeclarationSyntax Organize(OperatorDeclarationSyntax syntax, CancellationToken cancellationToken);
}
[ExportSyntaxNodeOrganizerAttribute("C#")]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.CSharp.Organizing.Organizers.PropertyDeclarationOrganizer : AbstractSyntaxNodeOrganizer`1<PropertyDeclarationSyntax> {
    protected virtual PropertyDeclarationSyntax Organize(PropertyDeclarationSyntax syntax, CancellationToken cancellationToken);
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[ExportSyntaxNodeOrganizerAttribute("C#")]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.CSharp.Organizing.Organizers.RecordDeclarationOrganizer : AbstractSyntaxNodeOrganizer`1<RecordDeclarationSyntax> {
    protected virtual RecordDeclarationSyntax Organize(RecordDeclarationSyntax syntax, CancellationToken cancellationToken);
}
[ExportSyntaxNodeOrganizerAttribute("C#")]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.CSharp.Organizing.Organizers.StructDeclarationOrganizer : AbstractSyntaxNodeOrganizer`1<StructDeclarationSyntax> {
    protected virtual StructDeclarationSyntax Organize(StructDeclarationSyntax syntax, CancellationToken cancellationToken);
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[ExportCodeFixProviderAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
[SharedAttribute]
[ExtensionOrderAttribute]
internal class Microsoft.CodeAnalysis.CSharp.PopulateSwitch.CSharpPopulateSwitchExpressionCodeFixProvider : AbstractPopulateSwitchExpressionCodeFixProvider`4<ExpressionSyntax, SwitchExpressionSyntax, SwitchExpressionArmSyntax, MemberAccessExpressionSyntax> {
    protected virtual SwitchExpressionArmSyntax CreateDefaultSwitchArm(SyntaxGenerator generator, Compilation compilation);
    protected virtual SwitchExpressionArmSyntax CreateSwitchArm(SyntaxGenerator generator, Compilation compilation, MemberAccessExpressionSyntax caseLabel);
    protected virtual SwitchExpressionSyntax InsertSwitchArms(SyntaxGenerator generator, SwitchExpressionSyntax switchNode, int insertLocation, List`1<SwitchExpressionArmSyntax> newArms);
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
internal class Microsoft.CodeAnalysis.CSharp.PopulateSwitch.CSharpPopulateSwitchExpressionDiagnosticAnalyzer : AbstractPopulateSwitchExpressionDiagnosticAnalyzer`1<SwitchExpressionSyntax> {
    protected virtual Location GetDiagnosticLocation(SwitchExpressionSyntax switchBlock);
}
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[ExportCodeFixProviderAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
[SharedAttribute]
[ExtensionOrderAttribute]
internal class Microsoft.CodeAnalysis.CSharp.PopulateSwitch.CSharpPopulateSwitchStatementCodeFixProvider : AbstractPopulateSwitchStatementCodeFixProvider`3<SwitchStatementSyntax, SwitchSectionSyntax, MemberAccessExpressionSyntax> {
}
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
internal class Microsoft.CodeAnalysis.CSharp.PopulateSwitch.CSharpPopulateSwitchStatementDiagnosticAnalyzer : AbstractPopulateSwitchStatementDiagnosticAnalyzer`1<SwitchStatementSyntax> {
}
[ExportCodeFixProviderAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
[SharedAttribute]
[ExtensionOrderAttribute]
internal class Microsoft.CodeAnalysis.CSharp.QualifyMemberAccess.CSharpQualifyMemberAccessCodeFixProvider : AbstractQualifyMemberAccessCodeFixprovider`2<SimpleNameSyntax, InvocationExpressionSyntax> {
    protected virtual SimpleNameSyntax GetNode(Diagnostic diagnostic, CancellationToken cancellationToken);
    protected virtual string GetTitle();
}
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
internal class Microsoft.CodeAnalysis.CSharp.QualifyMemberAccess.CSharpQualifyMemberAccessDiagnosticAnalyzer : AbstractQualifyMemberAccessDiagnosticAnalyzer`3<SyntaxKind, ExpressionSyntax, SimpleNameSyntax> {
    protected virtual string GetLanguageName();
    protected virtual bool IsAlreadyQualifiedMemberAccess(ExpressionSyntax node);
    protected virtual bool CanMemberAccessBeQualified(ISymbol containingSymbol, SyntaxNode node);
    private static bool IsInPropertyOrFieldInitialization(ISymbol containingSymbol, SyntaxNode node);
    private static bool IsInPropertyInitialization(SyntaxNode declarationSyntax, SyntaxNode node);
    private static bool IsInFieldInitialization(SyntaxNode declarationSyntax, SyntaxNode node);
    protected virtual Location GetLocation(IOperation operation);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExportQuickInfoProviderAttribute("DiagnosticAnalyzer", "C#")]
[SharedAttribute]
[ExtensionOrderAttribute]
internal class Microsoft.CodeAnalysis.CSharp.QuickInfo.CSharpDiagnosticAnalyzerQuickInfoProvider : CommonQuickInfoProvider {
    private IDiagnosticAnalyzerService _diagnosticAnalyzerService;
    [ImportingConstructorAttribute]
public CSharpDiagnosticAnalyzerQuickInfoProvider(IDiagnosticAnalyzerService diagnosticAnalyzerService);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.CSharp.QuickInfo.CSharpDiagnosticAnalyzerQuickInfoProvider/<BuildQuickInfoAsync>d__2")]
protected virtual Task`1<QuickInfoItem> BuildQuickInfoAsync(Document document, SyntaxToken token, CancellationToken cancellationToken);
    private QuickInfoItem GetQuickinfoForPragmaWarning(Document document, SyntaxToken token);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.CSharp.QuickInfo.CSharpDiagnosticAnalyzerQuickInfoProvider/<GetQuickInfoForSuppressMessageAttributeAsync>d__4")]
private Task`1<QuickInfoItem> GetQuickInfoForSuppressMessageAttributeAsync(Document document, SyntaxToken token, CancellationToken cancellationToken);
    private QuickInfoItem GetQuickInfoFromSupportedDiagnosticsOfProjectAnalyzers(Document document, string errorCode, TextSpan location);
    private static QuickInfoItem CreateQuickInfo(TextSpan location, DiagnosticDescriptor descriptor, TextSpan[] relatedSpans);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
internal static class Microsoft.CodeAnalysis.CSharp.QuickInfo.CSharpDiagnosticAnalyzerQuickInfoProviderExtensions : object {
    [ExtensionAttribute]
public static string ToStringOrNull(LocalizableString this);
    [NullableContextAttribute("2")]
[ExtensionAttribute]
public static bool IsSuppressMessageAttribute(NameSyntax name);
    [ExtensionAttribute]
public static string ExtractErrorCodeFromCheckId(string checkId);
}
internal class Microsoft.CodeAnalysis.CSharp.QuickInfo.CSharpQuickInfoService : QuickInfoServiceWithProviders {
    [NullableContextAttribute("1")]
internal CSharpQuickInfoService(Workspace workspace);
}
[ExportLanguageServiceFactoryAttribute("Microsoft.CodeAnalysis.QuickInfo.QuickInfoService", "C#", "Default")]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.CSharp.QuickInfo.CSharpQuickInfoServiceFactory : object {
    [NullableContextAttribute("1")]
public sealed virtual ILanguageService CreateLanguageService(HostLanguageServices languageServices);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
[ExportQuickInfoProviderAttribute("Semantic", "C#")]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.CSharp.QuickInfo.CSharpSemanticQuickInfoProvider : CommonSemanticQuickInfoProvider {
    protected virtual bool GetBindableNodeForTokenIndicatingLambda(SyntaxToken token, SyntaxNode& found);
    protected virtual bool GetBindableNodeForTokenIndicatingPossibleIndexerAccess(SyntaxToken token, SyntaxNode& found);
    protected virtual bool ShouldCheckPreviousToken(SyntaxToken token);
    [NullableContextAttribute("1")]
protected virtual NullableFlowState GetNullabilityAnalysis(Workspace workspace, SemanticModel semanticModel, ISymbol symbol, SyntaxNode node, CancellationToken cancellationToken);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExportQuickInfoProviderAttribute("Syntactic", "C#")]
[SharedAttribute]
[ExtensionOrderAttribute]
internal class Microsoft.CodeAnalysis.CSharp.QuickInfo.CSharpSyntacticQuickInfoProvider : CommonQuickInfoProvider {
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.CSharp.QuickInfo.CSharpSyntacticQuickInfoProvider/<BuildQuickInfoAsync>d__1")]
protected virtual Task`1<QuickInfoItem> BuildQuickInfoAsync(Document document, SyntaxToken token, CancellationToken cancellationToken);
    private static bool IsScopeBlock(SyntaxNode node);
    private static void MarkInterestedSpanNearbyScopeBlock(SyntaxNode block, SyntaxToken openBrace, Int32& spanStart, Int32& spanEnd);
    private static bool TryFindFurthestNearbyComment(T& triviaSearchList, SyntaxTrivia& nearbyTrivia);
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[ExportCodeFixProviderAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
[SharedAttribute]
[ExtensionOrderAttribute]
internal class Microsoft.CodeAnalysis.CSharp.RemoveAsyncModifier.CSharpRemoveAsyncModifierCodeFixProvider : AbstractRemoveAsyncModifierCodeFixProvider`2<ReturnStatementSyntax, ExpressionSyntax> {
    private static string CS1998;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private ImmutableArray`1<string> <FixableDiagnosticIds>k__BackingField;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ImmutableArray`1<string> FixableDiagnosticIds { get; }
    [CompilerGeneratedAttribute]
public virtual ImmutableArray`1<string> get_FixableDiagnosticIds();
    protected virtual bool IsAsyncSupportingFunctionSyntax(SyntaxNode node);
    protected virtual SyntaxNode ConvertToBlockBody(SyntaxNode node, ExpressionSyntax expressionBody);
    protected virtual SyntaxNode RemoveAsyncModifier(SyntaxGenerator generator, SyntaxNode methodLikeNode);
    private static SyntaxNode AnnotateBlock(SyntaxGenerator generator, SyntaxNode node);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExportCodeFixProviderAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.CSharp.RemoveConfusingSuppression.CSharpRemoveConfusingSuppressionCodeFixProvider : CodeFixProvider {
    public static string RemoveOperator;
    public static string NegateExpression;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ImmutableArray`1<string> FixableDiagnosticIds { get; }
    public virtual ImmutableArray`1<string> get_FixableDiagnosticIds();
    public virtual Task RegisterCodeFixesAsync(CodeFixContext context);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.CSharp.RemoveConfusingSuppression.CSharpRemoveConfusingSuppressionCodeFixProvider/<FixAllAsync>d__6")]
private static Task`1<Document> FixAllAsync(Document document, ImmutableArray`1<Diagnostic> diagnostics, bool negate, CancellationToken cancellationToken);
    public virtual FixAllProvider GetFixAllProvider();
}
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
internal class Microsoft.CodeAnalysis.CSharp.RemoveConfusingSuppression.CSharpRemoveConfusingSuppressionDiagnosticAnalyzer : AbstractBuiltInCodeStyleDiagnosticAnalyzer {
    public virtual DiagnosticAnalyzerCategory GetAnalyzerCategory();
    [NullableContextAttribute("1")]
protected virtual void InitializeWorker(AnalysisContext context);
    private void AnalyzeSyntax(SyntaxNodeAnalysisContext context);
}
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
internal class Microsoft.CodeAnalysis.CSharp.RemoveRedundantEquality.CSharpRemoveRedundantEqualityDiagnosticAnalyzer : AbstractRemoveRedundantEqualityDiagnosticAnalyzer {
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExportCodeFixProviderAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
[SharedAttribute]
[ExtensionOrderAttribute]
internal class Microsoft.CodeAnalysis.CSharp.RemoveUnnecessaryCast.CSharpRemoveUnnecessaryCastCodeFixProvider : SyntaxEditorBasedCodeFixProvider {
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private ImmutableArray`1<string> <FixableDiagnosticIds>k__BackingField;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ImmutableArray`1<string> FixableDiagnosticIds { get; }
    internal CodeFixCategory CodeFixCategory { get; }
    [CompilerGeneratedAttribute]
public sealed virtual ImmutableArray`1<string> get_FixableDiagnosticIds();
    internal sealed virtual CodeFixCategory get_CodeFixCategory();
    public sealed virtual Task RegisterCodeFixesAsync(CodeFixContext context);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.CSharp.RemoveUnnecessaryCast.CSharpRemoveUnnecessaryCastCodeFixProvider/<FixAllAsync>d__7")]
protected virtual Task FixAllAsync(Document document, ImmutableArray`1<Diagnostic> diagnostics, SyntaxEditor editor, CancellationToken cancellationToken);
    private ExpressionSyntax Recurse(ExpressionSyntax old);
}
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
internal class Microsoft.CodeAnalysis.CSharp.RemoveUnnecessaryCast.CSharpRemoveUnnecessaryCastDiagnosticAnalyzer : AbstractRemoveUnnecessaryCastDiagnosticAnalyzer`2<SyntaxKind, ExpressionSyntax> {
    [CompilerGeneratedAttribute]
private ImmutableArray`1<SyntaxKind> <SyntaxKindsOfInterest>k__BackingField;
    protected ImmutableArray`1<SyntaxKind> SyntaxKindsOfInterest { get; }
    [CompilerGeneratedAttribute]
protected virtual ImmutableArray`1<SyntaxKind> get_SyntaxKindsOfInterest();
    [NullableContextAttribute("1")]
protected virtual bool IsUnnecessaryCast(SemanticModel model, ExpressionSyntax cast, CancellationToken cancellationToken);
    [NullableContextAttribute("1")]
protected virtual TextSpan GetFadeSpan(ExpressionSyntax node);
}
[ExportCodeFixProviderAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.CSharp.RemoveUnnecessaryDiscardDesignation.CSharpRemoveUnnecessaryDiscardDesignationCodeFixProvider : SyntaxEditorBasedCodeFixProvider {
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ImmutableArray`1<string> FixableDiagnosticIds { get; }
    internal CodeFixCategory CodeFixCategory { get; }
    public virtual ImmutableArray`1<string> get_FixableDiagnosticIds();
    internal sealed virtual CodeFixCategory get_CodeFixCategory();
    [NullableContextAttribute("1")]
public virtual Task RegisterCodeFixesAsync(CodeFixContext context);
    [NullableContextAttribute("1")]
protected virtual Task FixAllAsync(Document document, ImmutableArray`1<Diagnostic> diagnostics, SyntaxEditor editor, CancellationToken cancellationToken);
}
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
internal class Microsoft.CodeAnalysis.CSharp.RemoveUnnecessaryDiscardDesignation.CSharpRemoveUnnecessaryDiscardDesignationDiagnosticAnalyzer : AbstractBuiltInCodeStyleDiagnosticAnalyzer {
    public virtual DiagnosticAnalyzerCategory GetAnalyzerCategory();
    [NullableContextAttribute("1")]
protected virtual void InitializeWorker(AnalysisContext context);
    private void AnalyzeDiscardDesignation(SyntaxNodeAnalysisContext context);
    [NullableContextAttribute("1")]
[CompilerGeneratedAttribute]
private void <AnalyzeDiscardDesignation>g__Report|3_0(DiscardDesignationSyntax discard, <>c__DisplayClass3_0& );
}
[ExportCodeFixProviderAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
[SharedAttribute]
[ExtensionOrderAttribute]
internal class Microsoft.CodeAnalysis.CSharp.RemoveUnnecessaryImports.CSharpRemoveUnnecessaryImportsCodeFixProvider : AbstractRemoveUnnecessaryImportsCodeFixProvider {
    protected virtual string GetTitle();
}
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
internal class Microsoft.CodeAnalysis.CSharp.RemoveUnnecessaryImports.CSharpRemoveUnnecessaryImportsDiagnosticAnalyzer : AbstractRemoveUnnecessaryImportsDiagnosticAnalyzer {
    private static LocalizableString s_TitleAndMessageFormat;
    protected IUnnecessaryImportsProvider UnnecessaryImportsProvider { get; }
    private static CSharpRemoveUnnecessaryImportsDiagnosticAnalyzer();
    protected virtual LocalizableString GetTitleAndMessageFormatForClassificationIdDescriptor();
    protected virtual ImmutableArray`1<SyntaxNode> MergeImports(ImmutableArray`1<SyntaxNode> unnecessaryImports);
    protected virtual IUnnecessaryImportsProvider get_UnnecessaryImportsProvider();
    protected virtual bool IsRegularCommentOrDocComment(SyntaxTrivia trivia);
    [IteratorStateMachineAttribute("Microsoft.CodeAnalysis.CSharp.RemoveUnnecessaryImports.CSharpRemoveUnnecessaryImportsDiagnosticAnalyzer/<GetFixableDiagnosticSpans>d__6")]
protected virtual IEnumerable`1<TextSpan> GetFixableDiagnosticSpans(IEnumerable`1<SyntaxNode> nodes, SyntaxTree tree, CancellationToken cancellationToken);
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
internal class Microsoft.CodeAnalysis.CSharp.RemoveUnnecessaryParentheses.CSharpRemoveUnnecessaryExpressionParenthesesDiagnosticAnalyzer : AbstractRemoveUnnecessaryParenthesesDiagnosticAnalyzer`2<SyntaxKind, ParenthesizedExpressionSyntax> {
    protected virtual SyntaxKind GetSyntaxKind();
    protected virtual ISyntaxFacts GetSyntaxFacts();
    protected virtual bool CanRemoveParentheses(ParenthesizedExpressionSyntax parenthesizedExpression, SemanticModel semanticModel, PrecedenceKind& precedence, Boolean& clarifiesPrecedence);
    public static bool CanRemoveParenthesesHelper(ParenthesizedExpressionSyntax parenthesizedExpression, SemanticModel semanticModel, PrecedenceKind& parentPrecedenceKind, Boolean& clarifiesPrecedence);
}
[ExportCodeFixProviderAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.CSharp.RemoveUnnecessaryParentheses.CSharpRemoveUnnecessaryParenthesesCodeFixProvider : AbstractRemoveUnnecessaryParenthesesCodeFixProvider`1<SyntaxNode> {
    protected virtual bool CanRemoveParentheses(SyntaxNode current, SemanticModel semanticModel);
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
internal class Microsoft.CodeAnalysis.CSharp.RemoveUnnecessaryParentheses.CSharpRemoveUnnecessaryPatternParenthesesDiagnosticAnalyzer : AbstractRemoveUnnecessaryParenthesesDiagnosticAnalyzer`2<SyntaxKind, ParenthesizedPatternSyntax> {
    protected virtual SyntaxKind GetSyntaxKind();
    protected virtual ISyntaxFacts GetSyntaxFacts();
    protected virtual bool CanRemoveParentheses(ParenthesizedPatternSyntax parenthesizedExpression, SemanticModel semanticModel, PrecedenceKind& precedence, Boolean& clarifiesPrecedence);
    public static bool CanRemoveParenthesesHelper(ParenthesizedPatternSyntax parenthesizedPattern, PrecedenceKind& parentPrecedenceKind, Boolean& clarifiesPrecedence);
}
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
internal class Microsoft.CodeAnalysis.CSharp.RemoveUnnecessarySuppressions.CSharpRemoveUnnecessaryAttributeSuppressionsDiagnosticAnalyzer : AbstractRemoveUnnecessaryAttributeSuppressionsDiagnosticAnalyzer {
    [NullableContextAttribute("1")]
protected virtual void RegisterAttributeSyntaxAction(CompilationStartAnalysisContext context, CompilationAnalyzer compilationAnalyzer);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
internal class Microsoft.CodeAnalysis.CSharp.RemoveUnnecessarySuppressions.CSharpRemoveUnnecessaryInlineSuppressionsDiagnosticAnalyzer : AbstractRemoveUnnecessaryInlineSuppressionsDiagnosticAnalyzer {
    protected string CompilerErrorCodePrefix { get; }
    protected int CompilerErrorCodeDigitCount { get; }
    protected ISyntaxFacts SyntaxFacts { get; }
    protected ISemanticFacts SemanticFacts { get; }
    protected virtual string get_CompilerErrorCodePrefix();
    protected virtual int get_CompilerErrorCodeDigitCount();
    protected virtual ISyntaxFacts get_SyntaxFacts();
    protected virtual ISemanticFacts get_SemanticFacts();
    protected virtual ValueTuple`2<Assembly, string> GetCompilerDiagnosticAnalyzerInfo();
}
[ExportCodeFixProviderAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.CSharp.RemoveUnreachableCode.CSharpRemoveUnreachableCodeCodeFixProvider : SyntaxEditorBasedCodeFixProvider {
    [CompilerGeneratedAttribute]
private ImmutableArray`1<string> <FixableDiagnosticIds>k__BackingField;
    public ImmutableArray`1<string> FixableDiagnosticIds { get; }
    internal CodeFixCategory CodeFixCategory { get; }
    [CompilerGeneratedAttribute]
public virtual ImmutableArray`1<string> get_FixableDiagnosticIds();
    internal sealed virtual CodeFixCategory get_CodeFixCategory();
    public virtual Task RegisterCodeFixesAsync(CodeFixContext context);
    protected virtual bool IncludeDiagnosticDuringFixAll(Diagnostic diagnostic);
    private static bool IsSubsequentSection(Diagnostic diagnostic);
    protected virtual Task FixAllAsync(Document document, ImmutableArray`1<Diagnostic> diagnostics, SyntaxEditor editor, CancellationToken cancellationToken);
    [CompilerGeneratedAttribute]
internal static void <FixAllAsync>g__RemoveStatement|9_0(SyntaxEditor editor, SyntaxNode statement);
}
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
internal class Microsoft.CodeAnalysis.CSharp.RemoveUnreachableCode.CSharpRemoveUnreachableCodeDiagnosticAnalyzer : AbstractBuiltInCodeStyleDiagnosticAnalyzer {
    private static string CS0162;
    public static string IsSubsequentSection;
    private static ImmutableDictionary`2<string, string> s_subsequentSectionProperties;
    private static CSharpRemoveUnreachableCodeDiagnosticAnalyzer();
    public virtual DiagnosticAnalyzerCategory GetAnalyzerCategory();
    protected virtual void InitializeWorker(AnalysisContext context);
    private void AnalyzeSemanticModel(SemanticModelAnalysisContext context);
    private void ProcessUnreachableDiagnostic(SemanticModelAnalysisContext context, SyntaxNode root, TextSpan sourceSpan, bool fadeOutCode);
}
internal static class Microsoft.CodeAnalysis.CSharp.RemoveUnreachableCode.RemoveUnreachableCodeHelpers : object {
    public static ImmutableArray`1<ImmutableArray`1<StatementSyntax>> GetSubsequentUnreachableSections(StatementSyntax firstUnreachableStatement);
    private static void AddIfNonEmpty(ArrayBuilder`1<ImmutableArray`1<StatementSyntax>> sections, ImmutableArray`1<StatementSyntax> lastSection);
}
[ExportCodeFixProviderAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
[SharedAttribute]
[ExtensionOrderAttribute]
internal class Microsoft.CodeAnalysis.CSharp.RemoveUnusedLocalFunction.CSharpRemoveUnusedLocalFunctionCodeFixProvider : SyntaxEditorBasedCodeFixProvider {
    private static string CS8321;
    public ImmutableArray`1<string> FixableDiagnosticIds { get; }
    internal CodeFixCategory CodeFixCategory { get; }
    public sealed virtual ImmutableArray`1<string> get_FixableDiagnosticIds();
    internal sealed virtual CodeFixCategory get_CodeFixCategory();
    public virtual Task RegisterCodeFixesAsync(CodeFixContext context);
    protected virtual Task FixAllAsync(Document document, ImmutableArray`1<Diagnostic> diagnostics, SyntaxEditor editor, CancellationToken cancellationToken);
}
[ExportCodeFixProviderAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.CSharp.RemoveUnusedMembers.CSharpRemoveUnusedMembersCodeFixProvider : AbstractRemoveUnusedMembersCodeFixProvider`1<FieldDeclarationSyntax> {
    protected virtual void AdjustAndAddAppropriateDeclaratorsToRemove(HashSet`1<FieldDeclarationSyntax> fieldDeclarators, HashSet`1<SyntaxNode> declarators);
}
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
internal class Microsoft.CodeAnalysis.CSharp.RemoveUnusedMembers.CSharpRemoveUnusedMembersDiagnosticAnalyzer : AbstractRemoveUnusedMembersDiagnosticAnalyzer`2<DocumentationCommentTriviaSyntax, IdentifierNameSyntax> {
}
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
internal class Microsoft.CodeAnalysis.CSharp.RemoveUnusedParametersAndValues.CSharpRemoveUnusedParametersAndValuesDiagnosticAnalyzer : AbstractRemoveUnusedParametersAndValuesDiagnosticAnalyzer {
    protected virtual bool IsRecordDeclaration(SyntaxNode node);
    protected virtual bool SupportsDiscard(SyntaxTree tree);
    protected virtual bool MethodHasHandlesClause(IMethodSymbol method);
    protected virtual bool IsIfConditionalDirective(SyntaxNode node);
    protected virtual bool ShouldBailOutFromRemovableAssignmentAnalysis(IOperation unusedSymbolWriteOperation);
    protected virtual bool IsCallStatement(IExpressionStatementOperation expressionStatement);
    protected virtual bool IsExpressionOfExpressionBody(IExpressionStatementOperation expressionStatementOperation);
    protected virtual Location GetDefinitionLocationToFade(IOperation unusedDefinition);
}
[ExportCodeFixProviderAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
[SharedAttribute]
[ExtensionOrderAttribute]
internal class Microsoft.CodeAnalysis.CSharp.RemoveUnusedParametersAndValues.CSharpRemoveUnusedValuesCodeFixProvider : AbstractRemoveUnusedValuesCodeFixProvider`11<ExpressionSyntax, StatementSyntax, BlockSyntax, ExpressionStatementSyntax, LocalDeclarationStatementSyntax, VariableDeclaratorSyntax, ForEachStatementSyntax, SwitchSectionSyntax, SwitchLabelSyntax, CatchClauseSyntax, CatchClauseSyntax> {
    protected virtual BlockSyntax WrapWithBlockIfNecessary(IEnumerable`1<StatementSyntax> statements);
    protected virtual SyntaxToken GetForEachStatementIdentifier(ForEachStatementSyntax node);
    protected virtual LocalDeclarationStatementSyntax GetCandidateLocalDeclarationForRemoval(VariableDeclaratorSyntax declarator);
    protected virtual SyntaxNode TryUpdateNameForFlaggedNode(SyntaxNode node, SyntaxToken newName);
    protected virtual SyntaxNode TryUpdateParentOfUpdatedNode(SyntaxNode parent, SyntaxNode newNameNode, SyntaxEditor editor, ISyntaxFacts syntaxFacts);
    protected virtual void InsertAtStartOfSwitchCaseBlockForDeclarationInCaseLabelOrClause(SwitchSectionSyntax switchCaseBlock, SyntaxEditor editor, LocalDeclarationStatementSyntax declarationStatement);
    protected virtual SyntaxNode GetReplacementNodeForCompoundAssignment(SyntaxNode originalCompoundAssignment, SyntaxNode newAssignmentTarget, SyntaxEditor editor, ISyntaxFactsService syntaxFacts);
}
[ExportCodeFixProviderAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
[SharedAttribute]
[ExtensionOrderAttribute]
internal class Microsoft.CodeAnalysis.CSharp.RemoveUnusedVariable.CSharpRemoveUnusedVariableCodeFixProvider : AbstractRemoveUnusedVariableCodeFixProvider`3<LocalDeclarationStatementSyntax, VariableDeclaratorSyntax, VariableDeclarationSyntax> {
    public static string CS0168;
    public static string CS0219;
    public ImmutableArray`1<string> FixableDiagnosticIds { get; }
    public sealed virtual ImmutableArray`1<string> get_FixableDiagnosticIds();
    protected virtual bool IsCatchDeclarationIdentifier(SyntaxToken token);
    protected virtual SyntaxNode GetNodeToRemoveOrReplace(SyntaxNode node);
    protected virtual void RemoveOrReplaceNode(SyntaxEditor editor, SyntaxNode node, ISyntaxFactsService syntaxFacts);
    protected virtual SeparatedSyntaxList`1<SyntaxNode> GetVariables(LocalDeclarationStatementSyntax localDeclarationStatement);
}
[ExportCodeFixProviderAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.CSharp.ReplaceDefaultLiteral.CSharpReplaceDefaultLiteralCodeFixProvider : CodeFixProvider {
    private static string CS8313;
    private static string CS8505;
    [CompilerGeneratedAttribute]
private ImmutableArray`1<string> <FixableDiagnosticIds>k__BackingField;
    public ImmutableArray`1<string> FixableDiagnosticIds { get; }
    [CompilerGeneratedAttribute]
public virtual ImmutableArray`1<string> get_FixableDiagnosticIds();
    public virtual FixAllProvider GetFixAllProvider();
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.CSharp.ReplaceDefaultLiteral.CSharpReplaceDefaultLiteralCodeFixProvider/<RegisterCodeFixesAsync>d__7")]
public virtual Task RegisterCodeFixesAsync(CodeFixContext context);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.CSharp.ReplaceDefaultLiteral.CSharpReplaceDefaultLiteralCodeFixProvider/<ReplaceAsync>d__8")]
private static Task`1<Document> ReplaceAsync(Document document, TextSpan span, SyntaxNode newExpression, CancellationToken cancellationToken);
    private static ValueTuple`2<SyntaxNode, string> GetReplacementExpressionAndText(Document document, SemanticModel semanticModel, LiteralExpressionSyntax defaultLiteral, CancellationToken cancellationToken);
    private static bool IsFlagsEnum(ITypeSymbol type, Compilation compilation);
    private static bool IsZero(object o);
    [CompilerGeneratedAttribute]
internal static ValueTuple`2<SyntaxNode, string> <GetReplacementExpressionAndText>g__GenerateMemberAccess|9_0(string memberName, <>c__DisplayClass9_0& );
}
[ExportCodeRefactoringProviderAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.CSharp.ReplaceDocCommentTextWithTag.CSharpReplaceDocCommentTextWithTagCodeRefactoringProvider : AbstractReplaceDocCommentTextWithTagCodeRefactoringProvider {
    private static ImmutableHashSet`1<string> s_triggerKeywords;
    private static CSharpReplaceDocCommentTextWithTagCodeRefactoringProvider();
    protected virtual bool IsXmlTextToken(SyntaxToken token);
    protected virtual bool IsInXMLAttribute(SyntaxToken token);
    protected virtual bool IsKeyword(string text);
    protected virtual SyntaxNode ParseExpression(string text);
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[ExportLanguageServiceAttribute("Microsoft.CodeAnalysis.ReplacePropertyWithMethods.IReplacePropertyWithMethodsService", "C#", "Default")]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.CSharp.ReplacePropertyWithMethods.CSharpReplacePropertyWithMethodsService : AbstractReplacePropertyWithMethodsService`5<IdentifierNameSyntax, ExpressionSyntax, NameMemberCrefSyntax, StatementSyntax, PropertyDeclarationSyntax> {
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.CSharp.ReplacePropertyWithMethods.CSharpReplacePropertyWithMethodsService/<GetReplacementMembersAsync>d__3")]
public virtual Task`1<ImmutableArray`1<SyntaxNode>> GetReplacementMembersAsync(Document document, IPropertySymbol property, SyntaxNode propertyDeclarationNode, IFieldSymbol propertyBackingField, string desiredGetMethodName, string desiredSetMethodName, CancellationToken cancellationToken);
    private static ImmutableArray`1<SyntaxNode> ConvertPropertyToMembers(DocumentOptionSet documentOptions, ParseOptions parseOptions, SyntaxGenerator generator, IPropertySymbol property, PropertyDeclarationSyntax propertyDeclaration, IFieldSymbol propertyBackingField, string desiredGetMethodName, string desiredSetMethodName, CancellationToken cancellationToken);
    private static SyntaxNode GetSetMethod(DocumentOptionSet documentOptions, ParseOptions parseOptions, SyntaxGenerator generator, PropertyDeclarationSyntax propertyDeclaration, IFieldSymbol propertyBackingField, IMethodSymbol setMethod, string desiredSetMethodName, CancellationToken cancellationToken);
    private static MethodDeclarationSyntax GetSetMethodWorker(SyntaxGenerator generator, PropertyDeclarationSyntax propertyDeclaration, IFieldSymbol propertyBackingField, IMethodSymbol setMethod, string desiredSetMethodName, CancellationToken cancellationToken);
    private static SyntaxNode GetGetMethod(DocumentOptionSet documentOptions, ParseOptions parseOptions, SyntaxGenerator generator, PropertyDeclarationSyntax propertyDeclaration, IFieldSymbol propertyBackingField, IMethodSymbol getMethod, string desiredGetMethodName, CancellationToken cancellationToken);
    private static MethodDeclarationSyntax CopyLeadingTrivia(PropertyDeclarationSyntax propertyDeclaration, MethodDeclarationSyntax methodDeclaration, CSharpSyntaxRewriter documentationCommentRewriter);
    private static SyntaxTrivia ConvertTrivia(SyntaxTrivia trivia, CSharpSyntaxRewriter rewriter);
    private static SyntaxTrivia ConvertDocumentationComment(SyntaxTrivia trivia, CSharpSyntaxRewriter rewriter);
    private static SyntaxNode UseExpressionOrBlockBodyIfDesired(DocumentOptionSet documentOptions, ParseOptions parseOptions, MethodDeclarationSyntax methodDeclaration, bool createReturnStatementForExpression);
    private static MethodDeclarationSyntax GetGetMethodWorker(SyntaxGenerator generator, PropertyDeclarationSyntax propertyDeclaration, IFieldSymbol propertyBackingField, IMethodSymbol getMethod, string desiredGetMethodName, CancellationToken cancellationToken);
    private static bool IsValueName(XmlNameSyntax name);
    public virtual SyntaxNode GetPropertyNodeToReplace(SyntaxNode propertyDeclaration);
    protected virtual NameMemberCrefSyntax TryGetCrefSyntax(IdentifierNameSyntax identifierName);
    protected virtual NameMemberCrefSyntax CreateCrefSyntax(NameMemberCrefSyntax originalCref, SyntaxToken identifierToken, SyntaxNode parameterType);
    protected virtual ExpressionSyntax UnwrapCompoundAssignment(SyntaxNode compoundAssignment, ExpressionSyntax readExpression);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExportCodeRefactoringProviderAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.CSharp.ReverseForStatement.CSharpReverseForStatementCodeRefactoringProvider : CodeRefactoringProvider {
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.CSharp.ReverseForStatement.CSharpReverseForStatementCodeRefactoringProvider/<ComputeRefactoringsAsync>d__1")]
public virtual Task ComputeRefactoringsAsync(CodeRefactoringContext context);
    private static bool IsUnsignedBoundary(SemanticModel semanticModel, VariableDeclaratorSyntax variable, ExpressionSyntax start, ExpressionSyntax end, CancellationToken cancellationToken);
    private static bool IsUnsignedBoundary(Optional`1<object> startValue, Optional`1<object> endValue, ulong maxValue);
    private static bool ValueEquals(Optional`1<object> valueOpt, ulong value);
    private static bool MatchesIncrementPattern(VariableDeclaratorSyntax variable, BinaryExpressionSyntax condition, ExpressionSyntax after, ExpressionSyntax& start, Boolean& equals, ExpressionSyntax& end);
    private static bool MatchesDecrementPattern(VariableDeclaratorSyntax variable, BinaryExpressionSyntax condition, ExpressionSyntax after, ExpressionSyntax& end, ExpressionSyntax& start);
    private static bool IsIncrementInitializer(VariableDeclaratorSyntax variable, ExpressionSyntax& start);
    private static bool IsIncrementCondition(VariableDeclaratorSyntax variable, BinaryExpressionSyntax condition, Boolean& equals, ExpressionSyntax& end);
    private static bool IsIncrementAfter(VariableDeclaratorSyntax variable, ExpressionSyntax after);
    private static bool IsLiteralOne(ExpressionSyntax expression);
    private static bool IsDecrementInitializer(VariableDeclaratorSyntax variable, ExpressionSyntax& end);
    private static bool IsDecrementCondition(VariableDeclaratorSyntax variable, BinaryExpressionSyntax condition, ExpressionSyntax& start);
    private static bool IsDecrementAfter(VariableDeclaratorSyntax variable, ExpressionSyntax after);
    private static bool IsVariableReference(VariableDeclaratorSyntax variable, ExpressionSyntax expr);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.CSharp.ReverseForStatement.CSharpReverseForStatementCodeRefactoringProvider/<ReverseForStatementAsync>d__15")]
private Task`1<Document> ReverseForStatementAsync(Document document, ForStatementSyntax forStatement, CancellationToken cancellationToken);
    private ExpressionSyntax Reduce(ExpressionSyntax expr);
    private static BinaryExpressionSyntax Invert(VariableDeclaratorSyntax variable, BinaryExpressionSyntax condition, ExpressionSyntax operand);
    private static ExpressionSyntax InvertAfter(ExpressionSyntax after);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal abstract class Microsoft.CodeAnalysis.CSharp.SignatureHelp.AbstractCSharpSignatureHelpProvider : AbstractSignatureHelpProvider {
    private static SymbolDisplayFormat s_allowDefaultLiteralFormat;
    private static IList`1<SymbolDisplayPart> _separatorParts;
    private static AbstractCSharpSignatureHelpProvider();
    protected static SymbolDisplayPart Keyword(SyntaxKind kind);
    protected static SymbolDisplayPart Operator(SyntaxKind kind);
    protected static SymbolDisplayPart Punctuation(SyntaxKind kind);
    protected static SymbolDisplayPart Text(string text);
    protected static SymbolDisplayPart Space();
    protected static SymbolDisplayPart NewLine();
    protected static IList`1<SymbolDisplayPart> GetSeparatorParts();
    protected static SignatureHelpSymbolParameter Convert(IParameterSymbol parameter, SemanticModel semanticModel, int position, IDocumentationCommentFormattingService formatter);
    [ObsoleteAttribute("Expected to exist by IntelliCode. This can be removed once their unnecessary use of this is removed.")]
protected IList`1<TaggedText> GetAwaitableUsage(IMethodSymbol method, SemanticModel semanticModel, int position);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal abstract class Microsoft.CodeAnalysis.CSharp.SignatureHelp.AbstractOrdinaryMethodSignatureHelpProvider : AbstractCSharpSignatureHelpProvider {
    internal static SignatureHelpItem ConvertMethodGroupMethod(Document document, IMethodSymbol method, int position, SemanticModel semanticModel);
    internal static SignatureHelpItem ConvertMethodGroupMethod(Document document, IMethodSymbol method, int position, SemanticModel semanticModel, IList`1<SymbolDisplayPart> descriptionParts);
    private static IList`1<SymbolDisplayPart> GetMethodGroupPreambleParts(IMethodSymbol method, SemanticModel semanticModel, int position);
    private static IList`1<SymbolDisplayPart> GetMethodGroupPostambleParts();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExportSignatureHelpProviderAttribute("AttributeSignatureHelpProvider", "C#")]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.CSharp.SignatureHelp.AttributeSignatureHelpProvider : AbstractCSharpSignatureHelpProvider {
    public virtual bool IsTriggerCharacter(char ch);
    public virtual bool IsRetriggerCharacter(char ch);
    private bool TryGetAttributeExpression(SyntaxNode root, int position, ISyntaxFactsService syntaxFacts, SignatureHelpTriggerReason triggerReason, CancellationToken cancellationToken, AttributeSyntax& attribute);
    private bool IsTriggerToken(SyntaxToken token);
    private static bool IsArgumentListToken(AttributeSyntax expression, SyntaxToken token);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.CSharp.SignatureHelp.AttributeSignatureHelpProvider/<GetItemsWorkerAsync>d__6")]
protected virtual Task`1<SignatureHelpItems> GetItemsWorkerAsync(Document document, int position, SignatureHelpTriggerInfo triggerInfo, CancellationToken cancellationToken);
    public virtual SignatureHelpState GetCurrentArgumentState(SyntaxNode root, int position, ISyntaxFactsService syntaxFacts, TextSpan currentSpan, CancellationToken cancellationToken);
    private static SignatureHelpItem Convert(IMethodSymbol constructor, ISymbol within, AttributeSyntax attribute, SemanticModel semanticModel, IAnonymousTypeDisplayService anonymousTypeDisplayService, IDocumentationCommentFormattingService documentationCommentFormatter, CancellationToken cancellationToken);
    private static IList`1<SignatureHelpSymbolParameter> GetParameters(IMethodSymbol constructor, SemanticModel semanticModel, int position, IList`1<ISymbol> namedParameters, IDocumentationCommentFormattingService documentationCommentFormatter, CancellationToken cancellationToken);
    [NullableContextAttribute("2")]
private static List`1<SymbolDisplayPart> GetParameterPrefixDisplayParts(int i);
    private static IList`1<SymbolDisplayPart> GetPreambleParts(IMethodSymbol method, SemanticModel semanticModel, int position);
    private static IList`1<SymbolDisplayPart> GetPostambleParts();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExportSignatureHelpProviderAttribute("ConstructorInitializerSignatureHelpProvider", "C#")]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.CSharp.SignatureHelp.ConstructorInitializerSignatureHelpProvider : AbstractCSharpSignatureHelpProvider {
    public virtual bool IsTriggerCharacter(char ch);
    public virtual bool IsRetriggerCharacter(char ch);
    private bool TryGetConstructorInitializer(SyntaxNode root, int position, ISyntaxFactsService syntaxFacts, SignatureHelpTriggerReason triggerReason, CancellationToken cancellationToken, ConstructorInitializerSyntax& expression);
    private bool IsTriggerToken(SyntaxToken token);
    private static bool IsArgumentListToken(ConstructorInitializerSyntax expression, SyntaxToken token);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.CSharp.SignatureHelp.ConstructorInitializerSignatureHelpProvider/<GetItemsWorkerAsync>d__6")]
protected virtual Task`1<SignatureHelpItems> GetItemsWorkerAsync(Document document, int position, SignatureHelpTriggerInfo triggerInfo, CancellationToken cancellationToken);
    public virtual SignatureHelpState GetCurrentArgumentState(SyntaxNode root, int position, ISyntaxFactsService syntaxFacts, TextSpan currentSpan, CancellationToken cancellationToken);
    private static SignatureHelpItem Convert(IMethodSymbol constructor, SyntaxToken openToken, SemanticModel semanticModel, IAnonymousTypeDisplayService anonymousTypeDisplayService, IDocumentationCommentFormattingService documentationCommentFormattingService);
    private static IList`1<SymbolDisplayPart> GetPreambleParts(IMethodSymbol method, SemanticModel semanticModel, int position);
    private static IList`1<SymbolDisplayPart> GetPostambleParts();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExportSignatureHelpProviderAttribute("ElementAccessExpressionSignatureHelpProvider", "C#")]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.CSharp.SignatureHelp.ElementAccessExpressionSignatureHelpProvider : AbstractCSharpSignatureHelpProvider {
    public virtual bool IsTriggerCharacter(char ch);
    private static bool IsTriggerCharacterInternal(char ch);
    public virtual bool IsRetriggerCharacter(char ch);
    private static bool TryGetElementAccessExpression(SyntaxNode root, int position, ISyntaxFactsService syntaxFacts, SignatureHelpTriggerReason triggerReason, CancellationToken cancellationToken, ExpressionSyntax& identifier, SyntaxToken& openBrace);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.CSharp.SignatureHelp.ElementAccessExpressionSignatureHelpProvider/<GetItemsWorkerAsync>d__5")]
protected virtual Task`1<SignatureHelpItems> GetItemsWorkerAsync(Document document, int position, SignatureHelpTriggerInfo triggerInfo, CancellationToken cancellationToken);
    private static TextSpan GetTextSpan(ExpressionSyntax expression, SyntaxToken openBracket);
    public virtual SignatureHelpState GetCurrentArgumentState(SyntaxNode root, int position, ISyntaxFactsService syntaxFacts, TextSpan currentSpan, CancellationToken cancellationToken);
    private static bool TryGetComIndexers(SemanticModel semanticModel, ExpressionSyntax expression, CancellationToken cancellationToken, ImmutableArray`1& indexers, ITypeSymbol& expressionType);
    private static bool TryGetIndexers(int position, SemanticModel semanticModel, ExpressionSyntax expression, CancellationToken cancellationToken, ImmutableArray`1& indexers, ITypeSymbol& expressionType);
    private static SignatureHelpItem Convert(IPropertySymbol indexer, SyntaxToken openToken, SemanticModel semanticModel, IAnonymousTypeDisplayService anonymousTypeDisplayService, IDocumentationCommentFormattingService documentationCommentFormattingService);
    private static IList`1<SymbolDisplayPart> GetPreambleParts(IPropertySymbol indexer, int position, SemanticModel semanticModel);
    private static IList`1<SymbolDisplayPart> GetPostambleParts();
}
[ExportSignatureHelpProviderAttribute("GenericNamePartiallyWrittenSignatureHelpProvider", "C#")]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.CSharp.SignatureHelp.GenericNamePartiallyWrittenSignatureHelpProvider : GenericNameSignatureHelpProvider {
    [NullableContextAttribute("1")]
protected virtual bool TryGetGenericIdentifier(SyntaxNode root, int position, ISyntaxFactsService syntaxFacts, SignatureHelpTriggerReason triggerReason, CancellationToken cancellationToken, SyntaxToken& genericIdentifier, SyntaxToken& lessThanToken);
    protected virtual TextSpan GetTextSpan(SyntaxToken genericIdentifier, SyntaxToken lessThanToken);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExportSignatureHelpProviderAttribute("GenericNameSignatureHelpProvider", "C#")]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.CSharp.SignatureHelp.GenericNameSignatureHelpProvider : AbstractCSharpSignatureHelpProvider {
    private static SymbolDisplayFormat s_minimallyQualifiedFormat;
    private static GenericNameSignatureHelpProvider();
    public virtual bool IsTriggerCharacter(char ch);
    public virtual bool IsRetriggerCharacter(char ch);
    protected virtual bool TryGetGenericIdentifier(SyntaxNode root, int position, ISyntaxFactsService syntaxFacts, SignatureHelpTriggerReason triggerReason, CancellationToken cancellationToken, SyntaxToken& genericIdentifier, SyntaxToken& lessThanToken);
    private bool IsTriggerToken(SyntaxToken token);
    private bool IsArgumentListToken(GenericNameSyntax node, SyntaxToken token);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.CSharp.SignatureHelp.GenericNameSignatureHelpProvider/<GetItemsWorkerAsync>d__6")]
protected virtual Task`1<SignatureHelpItems> GetItemsWorkerAsync(Document document, int position, SignatureHelpTriggerInfo triggerInfo, CancellationToken cancellationToken);
    public virtual SignatureHelpState GetCurrentArgumentState(SyntaxNode root, int position, ISyntaxFactsService syntaxFacts, TextSpan currentSpan, CancellationToken cancellationToken);
    protected virtual TextSpan GetTextSpan(SyntaxToken genericIdentifier, SyntaxToken lessThanToken);
    private static SignatureHelpItem Convert(ISymbol symbol, SyntaxToken lessThanToken, SemanticModel semanticModel, IAnonymousTypeDisplayService anonymousTypeDisplayService, IDocumentationCommentFormattingService documentationCommentFormattingService);
    private static SignatureHelpSymbolParameter Convert(ITypeParameterSymbol parameter, SemanticModel semanticModel, int position, IDocumentationCommentFormattingService formatter);
    private static IList`1<SymbolDisplayPart> GetSelectedDisplayParts(ITypeParameterSymbol typeParam, SemanticModel semanticModel, int position);
    private static bool TypeParameterHasConstraints(ITypeParameterSymbol typeParam);
    private static IList`1<SymbolDisplayPart> GetPreambleParts(IMethodSymbol method, SemanticModel semanticModel, int position);
    private static ITypeSymbol GetContainingType(IMethodSymbol method);
    private static IList`1<SymbolDisplayPart> GetPostambleParts(IMethodSymbol method, SemanticModel semanticModel, int position);
    private static IList`1<SymbolDisplayPart> GetPreambleParts(INamedTypeSymbol namedType, SemanticModel semanticModel, int position);
    private static IList`1<SymbolDisplayPart> GetPostambleParts();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExportSignatureHelpProviderAttribute("InitializerExpressionSignatureHelpProvider", "C#")]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.CSharp.SignatureHelp.InitializerExpressionSignatureHelpProvider : AbstractOrdinaryMethodSignatureHelpProvider {
    public virtual bool IsTriggerCharacter(char ch);
    public virtual bool IsRetriggerCharacter(char ch);
    private bool TryGetInitializerExpression(SyntaxNode root, int position, ISyntaxFactsService syntaxFacts, SignatureHelpTriggerReason triggerReason, CancellationToken cancellationToken, InitializerExpressionSyntax& expression);
    private bool IsTriggerToken(SyntaxToken token);
    private static bool IsInitializerExpressionToken(InitializerExpressionSyntax expression, SyntaxToken token);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.CSharp.SignatureHelp.InitializerExpressionSignatureHelpProvider/<GetItemsWorkerAsync>d__6")]
protected virtual Task`1<SignatureHelpItems> GetItemsWorkerAsync(Document document, int position, SignatureHelpTriggerInfo triggerInfo, CancellationToken cancellationToken);
    public virtual SignatureHelpState GetCurrentArgumentState(SyntaxNode root, int position, ISyntaxFactsService syntaxFacts, TextSpan currentSpan, CancellationToken cancellationToken);
}
[ExportSignatureHelpProviderAttribute("InvocationExpressionSignatureHelpProvider", "C#")]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.CSharp.SignatureHelp.InvocationExpressionSignatureHelpProvider : InvocationExpressionSignatureHelpProviderBase {
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.CodeAnalysis.CSharp.SignatureHelp.InvocationExpressionSignatureHelpProviderBase : AbstractOrdinaryMethodSignatureHelpProvider {
    public virtual bool IsTriggerCharacter(char ch);
    public virtual bool IsRetriggerCharacter(char ch);
    private bool TryGetInvocationExpression(SyntaxNode root, int position, ISyntaxFactsService syntaxFacts, SignatureHelpTriggerReason triggerReason, CancellationToken cancellationToken, InvocationExpressionSyntax& expression);
    private bool IsTriggerToken(SyntaxToken token);
    private static bool IsArgumentListToken(InvocationExpressionSyntax expression, SyntaxToken token);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.CSharp.SignatureHelp.InvocationExpressionSignatureHelpProviderBase/<GetItemsWorkerAsync>d__5")]
protected virtual Task`1<SignatureHelpItems> GetItemsWorkerAsync(Document document, int position, SignatureHelpTriggerInfo triggerInfo, CancellationToken cancellationToken);
    public virtual SignatureHelpState GetCurrentArgumentState(SyntaxNode root, int position, ISyntaxFactsService syntaxFacts, TextSpan currentSpan, CancellationToken cancellationToken);
    private static IList`1<SignatureHelpItem> GetDelegateInvokeItems(InvocationExpressionSyntax invocationExpression, SemanticModel semanticModel, IAnonymousTypeDisplayService anonymousTypeDisplayService, IDocumentationCommentFormattingService documentationCommentFormattingService, ISymbol within, INamedTypeSymbol delegateType, Nullable`1& selectedItem, CancellationToken cancellationToken);
    private static IList`1<SignatureHelpItem> GetFunctionPointerInvokeItems(InvocationExpressionSyntax invocationExpression, SemanticModel semanticModel, IAnonymousTypeDisplayService anonymousTypeDisplayService, IDocumentationCommentFormattingService documentationCommentFormattingService, IFunctionPointerTypeSymbol functionPointerType, Nullable`1& selectedItem, CancellationToken cancellationToken);
    private static IList`1<SignatureHelpItem> GetDelegateOrFunctionPointerInvokeItems(InvocationExpressionSyntax invocationExpression, IMethodSymbol invokeMethod, SemanticModel semanticModel, IAnonymousTypeDisplayService anonymousTypeDisplayService, IDocumentationCommentFormattingService documentationCommentFormattingService, Nullable`1& selectedItem, CancellationToken cancellationToken);
    private static IList`1<SymbolDisplayPart> GetDelegateOrFunctionPointerInvokePreambleParts(IMethodSymbol invokeMethod, SemanticModel semanticModel, int position);
    private static IList`1<SignatureHelpSymbolParameter> GetDelegateOrFunctionPointerInvokeParameters(IMethodSymbol invokeMethod, SemanticModel semanticModel, int position, IDocumentationCommentFormattingService formattingService, CancellationToken cancellationToken);
    private static IList`1<SymbolDisplayPart> GetDelegateOrFunctionPointerInvokePostambleParts();
    internal virtual Task`1<ValueTuple`2<ImmutableArray`1<SignatureHelpItem>, Nullable`1<int>>> GetMethodGroupItemsAndSelectionAsync(ImmutableArray`1<IMethodSymbol> accessibleMethods, Document document, InvocationExpressionSyntax invocationExpression, SemanticModel semanticModel, SymbolInfo currentSymbol, CancellationToken cancellationToken);
    private static ImmutableArray`1<IMethodSymbol> GetAccessibleMethods(InvocationExpressionSyntax invocationExpression, SemanticModel semanticModel, ISymbol within, IEnumerable`1<IMethodSymbol> methodGroup, CancellationToken cancellationToken);
    private static bool IsHiddenByOtherMethod(IMethodSymbol method, ISet`1<IMethodSymbol> methodSet);
    private static bool IsHiddenBy(IMethodSymbol method1, IMethodSymbol method2);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExportSignatureHelpProviderAttribute("ObjectCreationExpressionSignatureHelpProvider", "C#")]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.CSharp.SignatureHelp.ObjectCreationExpressionSignatureHelpProvider : AbstractCSharpSignatureHelpProvider {
    public virtual bool IsTriggerCharacter(char ch);
    public virtual bool IsRetriggerCharacter(char ch);
    private bool TryGetObjectCreationExpression(SyntaxNode root, int position, ISyntaxFactsService syntaxFacts, SignatureHelpTriggerReason triggerReason, CancellationToken cancellationToken, BaseObjectCreationExpressionSyntax& expression);
    private bool IsTriggerToken(SyntaxToken token);
    private static bool IsArgumentListToken(BaseObjectCreationExpressionSyntax expression, SyntaxToken token);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.CSharp.SignatureHelp.ObjectCreationExpressionSignatureHelpProvider/<GetItemsWorkerAsync>d__6")]
protected virtual Task`1<SignatureHelpItems> GetItemsWorkerAsync(Document document, int position, SignatureHelpTriggerInfo triggerInfo, CancellationToken cancellationToken);
    public virtual SignatureHelpState GetCurrentArgumentState(SyntaxNode root, int position, ISyntaxFactsService syntaxFacts, TextSpan currentSpan, CancellationToken cancellationToken);
    private static ValueTuple`2<IList`1<SignatureHelpItem>, Nullable`1<int>> GetDelegateTypeConstructors(BaseObjectCreationExpressionSyntax objectCreationExpression, SemanticModel semanticModel, IAnonymousTypeDisplayService anonymousTypeDisplayService, INamedTypeSymbol delegateType);
    private static IList`1<SymbolDisplayPart> GetDelegateTypePreambleParts(IMethodSymbol invokeMethod, SemanticModel semanticModel, int position);
    private static IList`1<SignatureHelpSymbolParameter> GetDelegateTypeParameters(IMethodSymbol invokeMethod, SemanticModel semanticModel, int position);
    private static IList`1<SymbolDisplayPart> GetDelegateTypePostambleParts();
    private static ValueTuple`2<IList`1<SignatureHelpItem>, Nullable`1<int>> GetNormalTypeConstructors(Document document, BaseObjectCreationExpressionSyntax objectCreationExpression, SemanticModel semanticModel, IAnonymousTypeDisplayService anonymousTypeDisplayService, IDocumentationCommentFormattingService documentationCommentFormattingService, INamedTypeSymbol normalType, ISymbol within, CancellationToken cancellationToken);
    private static SignatureHelpItem ConvertNormalTypeConstructor(IMethodSymbol constructor, BaseObjectCreationExpressionSyntax objectCreationExpression, SemanticModel semanticModel, IAnonymousTypeDisplayService anonymousTypeDisplayService, IDocumentationCommentFormattingService documentationCommentFormattingService);
    private static IList`1<SymbolDisplayPart> GetNormalTypePreambleParts(IMethodSymbol method, SemanticModel semanticModel, int position);
    private static IList`1<SymbolDisplayPart> GetNormalTypePostambleParts();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExportSignatureHelpProviderAttribute("PrimaryConstructorBaseTypeSignatureHelpProvider", "C#")]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.CSharp.SignatureHelp.PrimaryConstructorBaseTypeSignatureHelpProvider : AbstractCSharpSignatureHelpProvider {
    public virtual bool IsTriggerCharacter(char ch);
    public virtual bool IsRetriggerCharacter(char ch);
    private bool TryGetBaseTypeSyntax(SyntaxNode root, int position, ISyntaxFactsService syntaxFacts, SignatureHelpTriggerReason triggerReason, CancellationToken cancellationToken, PrimaryConstructorBaseTypeSyntax& expression);
    private bool IsTriggerToken(SyntaxToken token);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.CSharp.SignatureHelp.PrimaryConstructorBaseTypeSignatureHelpProvider/<GetItemsWorkerAsync>d__5")]
protected virtual Task`1<SignatureHelpItems> GetItemsWorkerAsync(Document document, int position, SignatureHelpTriggerInfo triggerInfo, CancellationToken cancellationToken);
    public virtual SignatureHelpState GetCurrentArgumentState(SyntaxNode root, int position, ISyntaxFactsService syntaxFacts, TextSpan currentSpan, CancellationToken cancellationToken);
    private static SignatureHelpItem Convert(IMethodSymbol constructor, SyntaxToken openToken, SemanticModel semanticModel, IAnonymousTypeDisplayService anonymousTypeDisplayService, IDocumentationCommentFormattingService documentationCommentFormattingService);
    [CompilerGeneratedAttribute]
internal static bool <TryGetBaseTypeSyntax>g__IsArgumentListToken|3_0(PrimaryConstructorBaseTypeSyntax expression, SyntaxToken token);
    [CompilerGeneratedAttribute]
internal static IList`1<SymbolDisplayPart> <Convert>g__GetPreambleParts|7_1(IMethodSymbol method, SemanticModel semanticModel, int position);
    [CompilerGeneratedAttribute]
internal static IList`1<SymbolDisplayPart> <Convert>g__GetPostambleParts|7_2();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal static class Microsoft.CodeAnalysis.CSharp.SignatureHelp.SignatureHelpUtilities : object {
    private static Func`2<BaseArgumentListSyntax, SyntaxToken> s_getBaseArgumentListOpenToken;
    private static Func`2<TypeArgumentListSyntax, SyntaxToken> s_getTypeArgumentListOpenToken;
    private static Func`2<InitializerExpressionSyntax, SyntaxToken> s_getInitializerExpressionOpenToken;
    private static Func`2<AttributeArgumentListSyntax, SyntaxToken> s_getAttributeArgumentListOpenToken;
    private static Func`2<BaseArgumentListSyntax, SyntaxToken> s_getBaseArgumentListCloseToken;
    private static Func`2<TypeArgumentListSyntax, SyntaxToken> s_getTypeArgumentListCloseToken;
    private static Func`2<InitializerExpressionSyntax, SyntaxToken> s_getInitializerExpressionCloseToken;
    private static Func`2<AttributeArgumentListSyntax, SyntaxToken> s_getAttributeArgumentListCloseToken;
    private static Func`2<BaseArgumentListSyntax, IEnumerable`1<SyntaxNodeOrToken>> s_getBaseArgumentListArgumentsWithSeparators;
    private static Func`2<TypeArgumentListSyntax, IEnumerable`1<SyntaxNodeOrToken>> s_getTypeArgumentListArgumentsWithSeparators;
    private static Func`2<InitializerExpressionSyntax, IEnumerable`1<SyntaxNodeOrToken>> s_getInitializerExpressionArgumentsWithSeparators;
    private static Func`2<AttributeArgumentListSyntax, IEnumerable`1<SyntaxNodeOrToken>> s_getAttributeArgumentListArgumentsWithSeparators;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private static Func`2<BaseArgumentListSyntax, IEnumerable`1<string>> s_getBaseArgumentListNames;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private static Func`2<TypeArgumentListSyntax, IEnumerable`1<string>> s_getTypeArgumentListNames;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private static Func`2<InitializerExpressionSyntax, IEnumerable`1<string>> s_getInitializerExpressionNames;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private static Func`2<AttributeArgumentListSyntax, IEnumerable`1<string>> s_getAttributeArgumentListNames;
    private static SignatureHelpUtilities();
    internal static SignatureHelpState GetSignatureHelpState(BaseArgumentListSyntax argumentList, int position);
    internal static SignatureHelpState GetSignatureHelpState(TypeArgumentListSyntax argumentList, int position);
    internal static SignatureHelpState GetSignatureHelpState(InitializerExpressionSyntax argumentList, int position);
    internal static SignatureHelpState GetSignatureHelpState(AttributeArgumentListSyntax argumentList, int position);
    internal static TextSpan GetSignatureHelpSpan(BaseArgumentListSyntax argumentList);
    internal static TextSpan GetSignatureHelpSpan(TypeArgumentListSyntax argumentList);
    internal static TextSpan GetSignatureHelpSpan(InitializerExpressionSyntax initializer);
    internal static TextSpan GetSignatureHelpSpan(AttributeArgumentListSyntax argumentList);
    internal static bool IsTriggerParenOrComma(SyntaxToken token, Func`2<char, bool> isTriggerCharacter);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExportSignatureHelpProviderAttribute("TupleSignatureHelpProvider", "C#")]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.CSharp.SignatureHelp.TupleConstructionSignatureHelpProvider : AbstractCSharpSignatureHelpProvider {
    private static Func`2<TupleExpressionSyntax, SyntaxToken> s_getOpenToken;
    private static Func`2<TupleExpressionSyntax, SyntaxToken> s_getCloseToken;
    private static Func`2<TupleExpressionSyntax, IEnumerable`1<SyntaxNodeOrToken>> s_getArgumentsWithSeparators;
    private static Func`2<TupleExpressionSyntax, IEnumerable`1<string>> s_getArgumentNames;
    private static TupleConstructionSignatureHelpProvider();
    public virtual SignatureHelpState GetCurrentArgumentState(SyntaxNode root, int position, ISyntaxFactsService syntaxFacts, TextSpan currentSpan, CancellationToken cancellationToken);
    private bool GetOuterMostTupleExpressionInSpan(SyntaxNode root, int position, ISyntaxFactsService syntaxFacts, TextSpan currentSpan, CancellationToken cancellationToken, TupleExpressionSyntax& result);
    private bool GetOuterMostParenthesizedExpressionInSpan(SyntaxNode root, int position, ISyntaxFactsService syntaxFacts, TextSpan currentSpan, CancellationToken cancellationToken, ParenthesizedExpressionSyntax& result);
    public virtual bool IsRetriggerCharacter(char ch);
    public virtual bool IsTriggerCharacter(char ch);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.CSharp.SignatureHelp.TupleConstructionSignatureHelpProvider/<GetItemsWorkerAsync>d__10")]
protected virtual Task`1<SignatureHelpItems> GetItemsWorkerAsync(Document document, int position, SignatureHelpTriggerInfo triggerInfo, CancellationToken cancellationToken);
    private IEnumerable`1<INamedTypeSymbol> FindNearestTupleConstructionWithInferrableType(SyntaxNode root, SemanticModel semanticModel, int position, SignatureHelpTriggerInfo triggerInfo, ITypeInferenceService typeInferrer, ISyntaxFactsService syntaxFacts, CancellationToken cancellationToken, ExpressionSyntax& targetExpression);
    private SignatureHelpItems CreateItems(int position, SyntaxNode root, ISyntaxFactsService syntaxFacts, SyntaxNode targetExpression, SemanticModel semanticModel, IEnumerable`1<INamedTypeSymbol> tupleTypes, CancellationToken cancellationToken);
    [NullableContextAttribute("0")]
private static SignatureHelpItem Convert(INamedTypeSymbol tupleType, ImmutableArray`1<TaggedText> prefixParts, ImmutableArray`1<TaggedText> suffixParts, ImmutableArray`1<TaggedText> separatorParts, SemanticModel semanticModel, int position);
    private static IEnumerable`1<SignatureHelpParameter> ConvertTupleMembers(INamedTypeSymbol tupleType, SemanticModel semanticModel, int position);
    private bool TryGetTupleExpression(SignatureHelpTriggerReason triggerReason, SyntaxNode root, int position, ISyntaxFactsService syntaxFacts, CancellationToken cancellationToken, TupleExpressionSyntax& tupleExpression);
    private bool IsTupleExpressionTriggerToken(SyntaxToken token);
    [NullableContextAttribute("2")]
private static bool IsTupleArgumentListToken(TupleExpressionSyntax tupleExpression, SyntaxToken token);
    private bool TryGetParenthesizedExpression(SignatureHelpTriggerReason triggerReason, SyntaxNode root, int position, ISyntaxFactsService syntaxFacts, CancellationToken cancellationToken, ParenthesizedExpressionSyntax& parenthesizedExpression);
    private bool IsParenthesizedExpressionTriggerToken(SyntaxToken token);
    [NullableContextAttribute("2")]
private static bool IsParenthesizedExpressionToken(ParenthesizedExpressionSyntax expr, SyntaxToken token);
}
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
internal class Microsoft.CodeAnalysis.CSharp.SimplifyBooleanExpression.CSharpSimplifyConditionalDiagnosticAnalyzer : AbstractSimplifyConditionalDiagnosticAnalyzer`3<SyntaxKind, ExpressionSyntax, ConditionalExpressionSyntax> {
    protected ISyntaxFacts SyntaxFacts { get; }
    protected virtual ISyntaxFacts get_SyntaxFacts();
    protected virtual CommonConversion GetConversion(SemanticModel semanticModel, ExpressionSyntax node, CancellationToken cancellationToken);
}
[ExportCodeFixProviderAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.CSharp.SimplifyInterpolation.CSharpSimplifyInterpolationCodeFixProvider : AbstractSimplifyInterpolationCodeFixProvider`5<InterpolationSyntax, ExpressionSyntax, InterpolationAlignmentClauseSyntax, InterpolationFormatClauseSyntax, InterpolatedStringExpressionSyntax> {
    protected virtual AbstractSimplifyInterpolationHelpers GetHelpers();
    protected virtual InterpolationSyntax WithExpression(InterpolationSyntax interpolation, ExpressionSyntax expression);
    protected virtual InterpolationSyntax WithAlignmentClause(InterpolationSyntax interpolation, InterpolationAlignmentClauseSyntax alignmentClause);
    protected virtual InterpolationSyntax WithFormatClause(InterpolationSyntax interpolation, InterpolationFormatClauseSyntax formatClause);
    protected virtual string Escape(InterpolatedStringExpressionSyntax interpolatedString, string formatString);
}
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
internal class Microsoft.CodeAnalysis.CSharp.SimplifyInterpolation.CSharpSimplifyInterpolationDiagnosticAnalyzer : AbstractSimplifyInterpolationDiagnosticAnalyzer`2<InterpolationSyntax, ExpressionSyntax> {
    protected virtual IVirtualCharService GetVirtualCharService();
    protected virtual ISyntaxFacts GetSyntaxFacts();
    protected virtual AbstractSimplifyInterpolationHelpers GetHelpers();
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[ExportCodeFixProviderAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.CSharp.SimplifyLinqExpression.CSharpSimplifyLinqExpressionCodeFixProvider : AbstractSimplifyLinqExpressionCodeFixProvider`3<InvocationExpressionSyntax, SimpleNameSyntax, ExpressionSyntax> {
    protected ISyntaxFacts SyntaxFacts { get; }
    protected virtual ISyntaxFacts get_SyntaxFacts();
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
internal class Microsoft.CodeAnalysis.CSharp.SimplifyLinqExpression.CSharpSimplifyLinqExpressionDiagnosticAnalyzer : AbstractSimplifyLinqExpressionDiagnosticAnalyzer`2<InvocationExpressionSyntax, MemberAccessExpressionSyntax> {
    protected ISyntaxFacts SyntaxFacts { get; }
    protected virtual ISyntaxFacts get_SyntaxFacts();
    protected virtual IInvocationOperation TryGetNextInvocationInChain(IInvocationOperation invocation);
}
[ExportCodeFixProviderAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
[SharedAttribute]
[ExtensionOrderAttribute]
internal class Microsoft.CodeAnalysis.CSharp.SimplifyThisOrMe.CSharpSimplifyThisOrMeCodeFixProvider : AbstractSimplifyThisOrMeCodeFixProvider`1<MemberAccessExpressionSyntax> {
    protected virtual string GetTitle();
    protected virtual SyntaxNode Rewrite(SyntaxNode root, ISet`1<MemberAccessExpressionSyntax> memberAccessNodes);
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
internal class Microsoft.CodeAnalysis.CSharp.SimplifyThisOrMe.CSharpSimplifyThisOrMeDiagnosticAnalyzer : AbstractSimplifyThisOrMeDiagnosticAnalyzer`4<SyntaxKind, ExpressionSyntax, ThisExpressionSyntax, MemberAccessExpressionSyntax> {
    protected virtual string GetLanguageName();
    protected virtual ISyntaxFacts GetSyntaxFacts();
    protected virtual bool CanSimplifyTypeNameExpression(SemanticModel model, MemberAccessExpressionSyntax node, OptionSet optionSet, TextSpan& issueSpan, CancellationToken cancellationToken);
}
[ExportCodeFixProviderAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
[SharedAttribute]
[ExtensionOrderAttribute]
internal class Microsoft.CodeAnalysis.CSharp.SimplifyTypeNames.SimplifyTypeNamesCodeFixProvider : AbstractSimplifyTypeNamesCodeFixProvider`1<SyntaxKind> {
    protected virtual string GetTitle(string diagnosticId, string nodeText);
    protected virtual SyntaxNode AddSimplificationAnnotationTo(SyntaxNode expressionSyntax);
}
[ExportLanguageServiceAttribute("Microsoft.CodeAnalysis.SolutionCrawler.IDocumentDifferenceService", "C#", "Default")]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.CSharp.SolutionCrawler.CSharpDocumentDifferenceService : AbstractDocumentDifferenceService {
}
[ExportCodeFixProviderAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
[SharedAttribute]
[ExtensionOrderAttribute]
internal class Microsoft.CodeAnalysis.CSharp.SpellCheck.CSharpSpellCheckCodeFixProvider : AbstractSpellCheckCodeFixProvider`1<SimpleNameSyntax> {
    private static string CS0426;
    private static string CS1520;
    [CompilerGeneratedAttribute]
private ImmutableArray`1<string> <FixableDiagnosticIds>k__BackingField;
    public ImmutableArray`1<string> FixableDiagnosticIds { get; }
    [CompilerGeneratedAttribute]
public virtual ImmutableArray`1<string> get_FixableDiagnosticIds();
    protected virtual bool ShouldSpellCheck(SimpleNameSyntax name);
    protected virtual bool DescendIntoChildren(SyntaxNode arg);
    protected virtual bool IsGeneric(SyntaxToken token);
    protected virtual bool IsGeneric(SimpleNameSyntax nameNode);
    protected virtual bool IsGeneric(CompletionItem completionItem);
    protected virtual SyntaxToken CreateIdentifier(SyntaxToken nameToken, string newName);
}
[ExportLanguageServiceAttribute("Microsoft.CodeAnalysis.SplitOrMergeIfStatements.IIfLikeStatementGenerator", "C#", "Default")]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.CSharp.SplitOrMergeIfStatements.CSharpIfLikeStatementGenerator : object {
    public sealed virtual bool IsIfOrElseIf(SyntaxNode node);
    public sealed virtual bool IsCondition(SyntaxNode expression, SyntaxNode& ifOrElseIf);
    public sealed virtual bool IsElseIfClause(SyntaxNode node, SyntaxNode& parentIfOrElseIf);
    public sealed virtual bool HasElseIfClause(SyntaxNode ifOrElseIf, SyntaxNode& elseIfClause);
    public sealed virtual SyntaxNode GetCondition(SyntaxNode ifOrElseIf);
    public sealed virtual SyntaxNode GetRootIfStatement(SyntaxNode ifOrElseIf);
    public sealed virtual ImmutableArray`1<SyntaxNode> GetElseIfAndElseClauses(SyntaxNode ifOrElseIf);
    public sealed virtual SyntaxNode WithCondition(SyntaxNode ifOrElseIf, SyntaxNode condition);
    public sealed virtual SyntaxNode WithStatementInBlock(SyntaxNode ifOrElseIf, SyntaxNode statement);
    public sealed virtual SyntaxNode WithStatementsOf(SyntaxNode ifOrElseIf, SyntaxNode otherIfOrElseIf);
    public sealed virtual SyntaxNode WithElseIfAndElseClausesOf(SyntaxNode ifStatement, SyntaxNode otherIfStatement);
    public sealed virtual SyntaxNode ToIfStatement(SyntaxNode ifOrElseIf);
    public sealed virtual SyntaxNode ToElseIfClause(SyntaxNode ifOrElseIf);
    public sealed virtual void InsertElseIfClause(SyntaxEditor editor, SyntaxNode afterIfOrElseIf, SyntaxNode elseIfClause);
    public sealed virtual void RemoveElseIfClause(SyntaxEditor editor, SyntaxNode elseIfClause);
    private static bool ContainsEmbeddedIfStatement(IfStatementSyntax ifStatement);
}
[ExportCodeRefactoringProviderAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.CSharp.SplitOrMergeIfStatements.CSharpMergeConsecutiveIfStatementsCodeRefactoringProvider : AbstractMergeConsecutiveIfStatementsCodeRefactoringProvider {
    protected virtual bool IsApplicableSpan(SyntaxNode node, TextSpan span, SyntaxNode& ifOrElseIf);
}
[ExportCodeRefactoringProviderAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.CSharp.SplitOrMergeIfStatements.CSharpMergeNestedIfStatementsCodeRefactoringProvider : AbstractMergeNestedIfStatementsCodeRefactoringProvider {
    protected virtual bool IsApplicableSpan(SyntaxNode node, TextSpan span, SyntaxNode& ifOrElseIf);
}
[ExportCodeRefactoringProviderAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
[SharedAttribute]
[ExtensionOrderAttribute]
internal class Microsoft.CodeAnalysis.CSharp.SplitOrMergeIfStatements.CSharpSplitIntoConsecutiveIfStatementsCodeRefactoringProvider : AbstractSplitIntoConsecutiveIfStatementsCodeRefactoringProvider {
}
[ExportCodeRefactoringProviderAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
[SharedAttribute]
[ExtensionOrderAttribute]
internal class Microsoft.CodeAnalysis.CSharp.SplitOrMergeIfStatements.CSharpSplitIntoNestedIfStatementsCodeRefactoringProvider : AbstractSplitIntoNestedIfStatementsCodeRefactoringProvider {
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal class Microsoft.CodeAnalysis.CSharp.Structure.AccessorDeclarationStructureProvider : AbstractSyntaxNodeStructureProvider`1<AccessorDeclarationSyntax> {
    protected virtual void CollectBlockSpans(AccessorDeclarationSyntax accessorDeclaration, TemporaryArray`1& spans, BlockStructureOptionProvider optionProvider, CancellationToken cancellationToken);
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal class Microsoft.CodeAnalysis.CSharp.Structure.AnonymousMethodExpressionStructureProvider : AbstractSyntaxNodeStructureProvider`1<AnonymousMethodExpressionSyntax> {
    protected virtual void CollectBlockSpans(AnonymousMethodExpressionSyntax anonymousMethod, TemporaryArray`1& spans, BlockStructureOptionProvider optionProvider, CancellationToken cancellationToken);
}
internal class Microsoft.CodeAnalysis.CSharp.Structure.ArrowExpressionClauseStructureProvider : AbstractSyntaxNodeStructureProvider`1<ArrowExpressionClauseSyntax> {
    protected virtual void CollectBlockSpans(ArrowExpressionClauseSyntax node, TemporaryArray`1& spans, BlockStructureOptionProvider optionProvider, CancellationToken cancellationToken);
}
internal class Microsoft.CodeAnalysis.CSharp.Structure.BlockSyntaxStructureProvider : AbstractSyntaxNodeStructureProvider`1<BlockSyntax> {
    protected virtual void CollectBlockSpans(BlockSyntax node, TemporaryArray`1& spans, BlockStructureOptionProvider optionProvider, CancellationToken cancellationToken);
    private static bool IsNonBlockStatement(SyntaxNode node);
    private static TextSpan GetHintSpan(BlockSyntax node);
    private static TextSpan GetTextSpan(BlockSyntax node);
    private static int GetEnd(BlockSyntax node);
    private static string GetType(SyntaxNode parent);
}
internal class Microsoft.CodeAnalysis.CSharp.Structure.CompilationUnitStructureProvider : AbstractSyntaxNodeStructureProvider`1<CompilationUnitSyntax> {
    protected virtual void CollectBlockSpans(CompilationUnitSyntax compilationUnit, TemporaryArray`1& spans, BlockStructureOptionProvider optionProvider, CancellationToken cancellationToken);
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal class Microsoft.CodeAnalysis.CSharp.Structure.ConstructorDeclarationStructureProvider : AbstractSyntaxNodeStructureProvider`1<ConstructorDeclarationSyntax> {
    protected virtual void CollectBlockSpans(ConstructorDeclarationSyntax constructorDeclaration, TemporaryArray`1& spans, BlockStructureOptionProvider optionProvider, CancellationToken cancellationToken);
}
internal class Microsoft.CodeAnalysis.CSharp.Structure.ConversionOperatorDeclarationStructureProvider : AbstractSyntaxNodeStructureProvider`1<ConversionOperatorDeclarationSyntax> {
    protected virtual void CollectBlockSpans(ConversionOperatorDeclarationSyntax operatorDeclaration, TemporaryArray`1& spans, BlockStructureOptionProvider optionProvider, CancellationToken cancellationToken);
}
internal class Microsoft.CodeAnalysis.CSharp.Structure.CSharpBlockStructureProvider : AbstractBlockStructureProvider {
    private static ImmutableDictionary`2<Type, ImmutableArray`1<AbstractSyntaxStructureProvider>> CreateDefaultNodeProviderMap();
    private static ImmutableDictionary`2<int, ImmutableArray`1<AbstractSyntaxStructureProvider>> CreateDefaultTriviaProviderMap();
}
internal class Microsoft.CodeAnalysis.CSharp.Structure.CSharpBlockStructureService : BlockStructureServiceWithProviders {
    public string Language { get; }
    public CSharpBlockStructureService(Workspace workspace);
    protected virtual ImmutableArray`1<BlockStructureProvider> GetBuiltInProviders();
    public virtual string get_Language();
}
[ExportLanguageServiceFactoryAttribute("Microsoft.CodeAnalysis.Structure.BlockStructureService", "C#", "Default")]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.CSharp.Structure.CSharpBlockStructureServiceFactory : object {
    public sealed virtual ILanguageService CreateLanguageService(HostLanguageServices languageServices);
}
internal static class Microsoft.CodeAnalysis.CSharp.Structure.CSharpStructureHelpers : object {
    public static string Ellipsis;
    public static string MultiLineCommentSuffix;
    public static int MaxXmlDocCommentBannerLength;
    private static Char[] s_newLineCharacters;
    private static CSharpStructureHelpers();
    private static int GetCollapsibleStart(SyntaxToken firstToken);
    private static ValueTuple`2<int, int> GetCollapsibleEnd(SyntaxToken lastToken, bool compressEmptyLines);
    public static SyntaxToken GetLastInlineMethodBlockToken(SyntaxNode node);
    private static string CreateCommentBannerTextWithPrefix(string text, string prefix);
    private static string GetCommentBannerText(SyntaxTrivia comment);
    private static BlockSpan CreateCommentBlockSpan(SyntaxTrivia startComment, SyntaxTrivia endComment);
    internal static ImmutableArray`1<BlockSpan> CreateCommentBlockSpan(SyntaxTriviaList triviaList);
    public static void CollectCommentBlockSpans(SyntaxTriviaList triviaList, TemporaryArray`1& spans);
    public static void CollectCommentBlockSpans(SyntaxNode node, TemporaryArray`1& spans, BlockStructureOptionProvider optionProvider);
    private static BlockSpan CreateBlockSpan(TextSpan textSpan, string bannerText, bool autoCollapse, string type, bool isCollapsible);
    private static BlockSpan CreateBlockSpan(TextSpan textSpan, TextSpan hintSpan, string bannerText, bool autoCollapse, string type, bool isCollapsible);
    public static BlockSpan CreateBlockSpan(SyntaxNode node, string bannerText, bool autoCollapse, string type, bool isCollapsible);
    public static Nullable`1<BlockSpan> CreateBlockSpan(SyntaxNode node, SyntaxToken syntaxToken, bool compressEmptyLines, string bannerText, bool autoCollapse, string type, bool isCollapsible);
    public static Nullable`1<BlockSpan> CreateBlockSpan(SyntaxNode node, SyntaxToken startToken, int spanEndPos, int hintEndPos, string bannerText, bool autoCollapse, string type, bool isCollapsible);
    private static TextSpan GetHintSpan(SyntaxNode node, int endPos);
    public static Nullable`1<BlockSpan> CreateBlockSpan(SyntaxNode node, SyntaxToken startToken, SyntaxToken endToken, bool compressEmptyLines, string bannerText, bool autoCollapse, string type, bool isCollapsible);
    public static BlockSpan CreateBlockSpan(SyntaxNode node, bool autoCollapse, string type, bool isCollapsible);
    public static Nullable`1<BlockSpan> CreateBlockSpan(SyntaxNode node, SyntaxToken syntaxToken, bool compressEmptyLines, bool autoCollapse, string type, bool isCollapsible);
    public static Nullable`1<BlockSpan> CreateBlockSpan(SyntaxNode node, SyntaxToken startToken, SyntaxToken endToken, bool compressEmptyLines, bool autoCollapse, string type, bool isCollapsible);
    public static Nullable`1<BlockSpan> CreateBlockSpan(IEnumerable`1<SyntaxNode> syntaxList, bool compressEmptyLines, bool autoCollapse, string type, bool isCollapsible);
    [CompilerGeneratedAttribute]
internal static bool <GetCollapsibleEnd>g__ProcessTrivia|5_0(SyntaxTrivia trivia, bool compressEmptyLines, Int32& end, Nullable`1& hintEnd);
    [CompilerGeneratedAttribute]
internal static void <CollectCommentBlockSpans>g__completeSingleLineCommentGroup|11_0(TemporaryArray`1& spans, <>c__DisplayClass11_0& );
    [CompilerGeneratedAttribute]
internal static bool <CollectCommentBlockSpans>g__TryGetLeadingCollapsibleSpan|12_0(SyntaxNode node, BlockSpan& span);
    [CompilerGeneratedAttribute]
internal static SyntaxToken <CollectCommentBlockSpans>g__GetEndToken|12_1(SyntaxNode node);
    [CompilerGeneratedAttribute]
internal static SyntaxToken <CollectCommentBlockSpans>g__GetHintTextEndToken|12_2(SyntaxNode node);
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal class Microsoft.CodeAnalysis.CSharp.Structure.DelegateDeclarationStructureProvider : AbstractSyntaxNodeStructureProvider`1<DelegateDeclarationSyntax> {
    protected virtual void CollectBlockSpans(DelegateDeclarationSyntax delegateDeclaration, TemporaryArray`1& spans, BlockStructureOptionProvider optionProvider, CancellationToken cancellationToken);
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal class Microsoft.CodeAnalysis.CSharp.Structure.DestructorDeclarationStructureProvider : AbstractSyntaxNodeStructureProvider`1<DestructorDeclarationSyntax> {
    protected virtual void CollectBlockSpans(DestructorDeclarationSyntax destructorDeclaration, TemporaryArray`1& spans, BlockStructureOptionProvider optionProvider, CancellationToken cancellationToken);
}
internal class Microsoft.CodeAnalysis.CSharp.Structure.DisabledTextTriviaStructureProvider : AbstractSyntaxTriviaStructureProvider {
    public virtual void CollectBlockSpans(SyntaxTrivia trivia, TemporaryArray`1& spans, BlockStructureOptionProvider optionProvider, CancellationToken cancellationToken);
    public static void CollectBlockSpans(SyntaxTree syntaxTree, SyntaxTrivia trivia, TemporaryArray`1& spans, CancellationToken cancellationToken);
    private static int GetEndPositionExludingLastNewLine(SyntaxTree syntaxTree, SyntaxTrivia trivia, CancellationToken cancellationToken);
    private static SyntaxTrivia GetCorrespondingEndTrivia(SyntaxTrivia trivia, SyntaxTriviaList triviaList, int index);
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal class Microsoft.CodeAnalysis.CSharp.Structure.DocumentationCommentStructureProvider : AbstractSyntaxNodeStructureProvider`1<DocumentationCommentTriviaSyntax> {
    protected virtual void CollectBlockSpans(DocumentationCommentTriviaSyntax documentationComment, TemporaryArray`1& spans, BlockStructureOptionProvider optionProvider, CancellationToken cancellationToken);
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal class Microsoft.CodeAnalysis.CSharp.Structure.EnumDeclarationStructureProvider : AbstractSyntaxNodeStructureProvider`1<EnumDeclarationSyntax> {
    protected virtual void CollectBlockSpans(EnumDeclarationSyntax enumDeclaration, TemporaryArray`1& spans, BlockStructureOptionProvider optionProvider, CancellationToken cancellationToken);
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal class Microsoft.CodeAnalysis.CSharp.Structure.EnumMemberDeclarationStructureProvider : AbstractSyntaxNodeStructureProvider`1<EnumMemberDeclarationSyntax> {
    protected virtual void CollectBlockSpans(EnumMemberDeclarationSyntax enumMemberDeclaration, TemporaryArray`1& spans, BlockStructureOptionProvider optionProvider, CancellationToken cancellationToken);
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal class Microsoft.CodeAnalysis.CSharp.Structure.EventDeclarationStructureProvider : AbstractSyntaxNodeStructureProvider`1<EventDeclarationSyntax> {
    protected virtual void CollectBlockSpans(EventDeclarationSyntax eventDeclaration, TemporaryArray`1& spans, BlockStructureOptionProvider optionProvider, CancellationToken cancellationToken);
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal class Microsoft.CodeAnalysis.CSharp.Structure.EventFieldDeclarationStructureProvider : AbstractSyntaxNodeStructureProvider`1<EventFieldDeclarationSyntax> {
    protected virtual void CollectBlockSpans(EventFieldDeclarationSyntax eventFieldDeclaration, TemporaryArray`1& spans, BlockStructureOptionProvider optionProvider, CancellationToken cancellationToken);
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal class Microsoft.CodeAnalysis.CSharp.Structure.FieldDeclarationStructureProvider : AbstractSyntaxNodeStructureProvider`1<FieldDeclarationSyntax> {
    protected virtual void CollectBlockSpans(FieldDeclarationSyntax fieldDeclaration, TemporaryArray`1& spans, BlockStructureOptionProvider optionProvider, CancellationToken cancellationToken);
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal class Microsoft.CodeAnalysis.CSharp.Structure.IndexerDeclarationStructureProvider : AbstractSyntaxNodeStructureProvider`1<IndexerDeclarationSyntax> {
    protected virtual void CollectBlockSpans(IndexerDeclarationSyntax indexerDeclaration, TemporaryArray`1& spans, BlockStructureOptionProvider optionProvider, CancellationToken cancellationToken);
}
internal class Microsoft.CodeAnalysis.CSharp.Structure.InitializerExpressionStructureProvider : AbstractSyntaxNodeStructureProvider`1<InitializerExpressionSyntax> {
    protected virtual void CollectBlockSpans(InitializerExpressionSyntax node, TemporaryArray`1& spans, BlockStructureOptionProvider optionProvider, CancellationToken cancellationToken);
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal class Microsoft.CodeAnalysis.CSharp.Structure.InterpolatedStringExpressionStructureProvider : AbstractSyntaxNodeStructureProvider`1<InterpolatedStringExpressionSyntax> {
    protected virtual void CollectBlockSpans(InterpolatedStringExpressionSyntax node, TemporaryArray`1& spans, BlockStructureOptionProvider optionProvider, CancellationToken cancellationToken);
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal class Microsoft.CodeAnalysis.CSharp.Structure.MethodDeclarationStructureProvider : AbstractSyntaxNodeStructureProvider`1<MethodDeclarationSyntax> {
    protected virtual void CollectBlockSpans(MethodDeclarationSyntax methodDeclaration, TemporaryArray`1& spans, BlockStructureOptionProvider optionProvider, CancellationToken cancellationToken);
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal class Microsoft.CodeAnalysis.CSharp.Structure.NamespaceDeclarationStructureProvider : AbstractSyntaxNodeStructureProvider`1<NamespaceDeclarationSyntax> {
    protected virtual void CollectBlockSpans(NamespaceDeclarationSyntax namespaceDeclaration, TemporaryArray`1& spans, BlockStructureOptionProvider optionProvider, CancellationToken cancellationToken);
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal class Microsoft.CodeAnalysis.CSharp.Structure.OperatorDeclarationStructureProvider : AbstractSyntaxNodeStructureProvider`1<OperatorDeclarationSyntax> {
    protected virtual void CollectBlockSpans(OperatorDeclarationSyntax operatorDeclaration, TemporaryArray`1& spans, BlockStructureOptionProvider optionProvider, CancellationToken cancellationToken);
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal class Microsoft.CodeAnalysis.CSharp.Structure.ParenthesizedLambdaExpressionStructureProvider : AbstractSyntaxNodeStructureProvider`1<ParenthesizedLambdaExpressionSyntax> {
    protected virtual void CollectBlockSpans(ParenthesizedLambdaExpressionSyntax lambdaExpression, TemporaryArray`1& spans, BlockStructureOptionProvider optionProvider, CancellationToken cancellationToken);
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal class Microsoft.CodeAnalysis.CSharp.Structure.PropertyDeclarationStructureProvider : AbstractSyntaxNodeStructureProvider`1<PropertyDeclarationSyntax> {
    protected virtual void CollectBlockSpans(PropertyDeclarationSyntax propertyDeclaration, TemporaryArray`1& spans, BlockStructureOptionProvider optionProvider, CancellationToken cancellationToken);
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal class Microsoft.CodeAnalysis.CSharp.Structure.RegionDirectiveStructureProvider : AbstractSyntaxNodeStructureProvider`1<RegionDirectiveTriviaSyntax> {
    private static string GetBannerText(DirectiveTriviaSyntax simpleDirective);
    protected virtual void CollectBlockSpans(RegionDirectiveTriviaSyntax regionDirective, TemporaryArray`1& spans, BlockStructureOptionProvider optionProvider, CancellationToken cancellationToken);
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal class Microsoft.CodeAnalysis.CSharp.Structure.SimpleLambdaExpressionStructureProvider : AbstractSyntaxNodeStructureProvider`1<SimpleLambdaExpressionSyntax> {
    protected virtual void CollectBlockSpans(SimpleLambdaExpressionSyntax lambdaExpression, TemporaryArray`1& spans, BlockStructureOptionProvider optionProvider, CancellationToken cancellationToken);
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal class Microsoft.CodeAnalysis.CSharp.Structure.StringLiteralExpressionStructureProvider : AbstractSyntaxNodeStructureProvider`1<LiteralExpressionSyntax> {
    protected virtual void CollectBlockSpans(LiteralExpressionSyntax node, TemporaryArray`1& spans, BlockStructureOptionProvider optionProvider, CancellationToken cancellationToken);
}
internal class Microsoft.CodeAnalysis.CSharp.Structure.SwitchStatementStructureProvider : AbstractSyntaxNodeStructureProvider`1<SwitchStatementSyntax> {
    protected virtual void CollectBlockSpans(SwitchStatementSyntax node, TemporaryArray`1& spans, BlockStructureOptionProvider optionProvider, CancellationToken cancellationToken);
}
internal class Microsoft.CodeAnalysis.CSharp.Structure.TypeDeclarationStructureProvider : AbstractSyntaxNodeStructureProvider`1<TypeDeclarationSyntax> {
    protected virtual void CollectBlockSpans(TypeDeclarationSyntax typeDeclaration, TemporaryArray`1& spans, BlockStructureOptionProvider optionProvider, CancellationToken cancellationToken);
}
internal class Microsoft.CodeAnalysis.CSharp.TodoComments.CSharpTodoCommentService : AbstractTodoCommentService {
    private static int s_multilineCommentPostfixLength;
    private static string SingleLineCommentPrefix;
    private static CSharpTodoCommentService();
    protected virtual void AppendTodoComments(ImmutableArray`1<TodoCommentDescriptor> commentDescriptors, SyntacticDocument document, SyntaxTrivia trivia, ArrayBuilder`1<TodoComment> todoList);
    protected virtual string GetNormalizedText(string message);
    protected virtual bool IsIdentifierCharacter(char ch);
    protected virtual int GetCommentStartingIndex(string message);
    protected virtual bool PreprocessorHasComment(SyntaxTrivia trivia);
    protected virtual bool IsSingleLineComment(SyntaxTrivia trivia);
    protected virtual bool IsMultilineComment(SyntaxTrivia trivia);
}
[ExportLanguageServiceFactoryAttribute("Microsoft.CodeAnalysis.TodoComments.ITodoCommentService", "C#", "Default")]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.CSharp.TodoComments.CSharpTodoCommentServiceFactory : object {
    public sealed virtual ILanguageService CreateLanguageService(HostLanguageServices languageServices);
}
[ExportCodeFixProviderAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.CSharp.TypeStyle.UseExplicitTypeCodeFixProvider : SyntaxEditorBasedCodeFixProvider {
    public ImmutableArray`1<string> FixableDiagnosticIds { get; }
    internal CodeFixCategory CodeFixCategory { get; }
    public virtual ImmutableArray`1<string> get_FixableDiagnosticIds();
    internal sealed virtual CodeFixCategory get_CodeFixCategory();
    public virtual Task RegisterCodeFixesAsync(CodeFixContext context);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.CSharp.TypeStyle.UseExplicitTypeCodeFixProvider/<FixAllAsync>d__6")]
protected virtual Task FixAllAsync(Document document, ImmutableArray`1<Diagnostic> diagnostics, SyntaxEditor editor, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.CSharp.TypeStyle.UseExplicitTypeCodeFixProvider/<HandleDeclarationAsync>d__7")]
internal static Task HandleDeclarationAsync(Document document, SyntaxEditor editor, SyntaxNode node, CancellationToken cancellationToken);
    private static ExpressionSyntax GenerateTupleDeclaration(ITypeSymbol typeSymbol, ParenthesizedVariableDesignationSyntax parensDesignation);
}
[ExportCodeFixProviderAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.CSharp.TypeStyle.UseImplicitTypeCodeFixProvider : SyntaxEditorBasedCodeFixProvider {
    public ImmutableArray`1<string> FixableDiagnosticIds { get; }
    internal CodeFixCategory CodeFixCategory { get; }
    public virtual ImmutableArray`1<string> get_FixableDiagnosticIds();
    internal sealed virtual CodeFixCategory get_CodeFixCategory();
    public virtual Task RegisterCodeFixesAsync(CodeFixContext context);
    protected virtual Task FixAllAsync(Document document, ImmutableArray`1<Diagnostic> diagnostics, SyntaxEditor editor, CancellationToken cancellationToken);
    internal static void ReplaceTypeWithVar(SyntaxEditor editor, TypeSyntax type);
}
[ExportCodeFixProviderAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.CSharp.UnsealClass.CSharpUnsealClassCodeFixProvider : AbstractUnsealClassCodeFixProvider {
    private static string CS0509;
    [CompilerGeneratedAttribute]
private ImmutableArray`1<string> <FixableDiagnosticIds>k__BackingField;
    public ImmutableArray`1<string> FixableDiagnosticIds { get; }
    protected string TitleFormat { get; }
    [CompilerGeneratedAttribute]
public virtual ImmutableArray`1<string> get_FixableDiagnosticIds();
    protected virtual string get_TitleFormat();
}
[ExportCodeFixProviderAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.CSharp.UpdateProjectToAllowUnsafe.CSharpUpdateProjectToAllowUnsafeCodeFixProvider : CodeFixProvider {
    private static string CS0227;
    [CompilerGeneratedAttribute]
private ImmutableArray`1<string> <FixableDiagnosticIds>k__BackingField;
    public ImmutableArray`1<string> FixableDiagnosticIds { get; }
    [CompilerGeneratedAttribute]
public virtual ImmutableArray`1<string> get_FixableDiagnosticIds();
    public virtual FixAllProvider GetFixAllProvider();
    public virtual Task RegisterCodeFixesAsync(CodeFixContext context);
    private static Solution AllowUnsafeOnProject(Project project);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExportCodeFixProviderAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.CSharp.UpgradeProject.CSharpUpgradeProjectCodeFixProvider : AbstractUpgradeProjectCodeFixProvider {
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private ImmutableArray`1<string> <FixableDiagnosticIds>k__BackingField;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ImmutableArray`1<string> FixableDiagnosticIds { get; }
    public string UpgradeThisProjectResource { get; }
    public string UpgradeAllProjectsResource { get; }
    [CompilerGeneratedAttribute]
public virtual ImmutableArray`1<string> get_FixableDiagnosticIds();
    public virtual string get_UpgradeThisProjectResource();
    public virtual string get_UpgradeAllProjectsResource();
    public virtual string SuggestedVersion(ImmutableArray`1<Diagnostic> diagnostics);
    private static LanguageVersion RequiredVersion(ImmutableArray`1<Diagnostic> diagnostics);
    public virtual Solution UpgradeProject(Project project, string newVersion);
    public virtual bool IsUpgrade(Project project, string newVersion);
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
internal class Microsoft.CodeAnalysis.CSharp.UseAutoProperty.CSharpUseAutoPropertyAnalyzer : AbstractUseAutoPropertyAnalyzer`4<PropertyDeclarationSyntax, FieldDeclarationSyntax, VariableDeclaratorSyntax, ExpressionSyntax> {
    protected virtual bool SupportsReadOnlyProperties(Compilation compilation);
    protected virtual bool SupportsPropertyInitializer(Compilation compilation);
    protected virtual bool CanExplicitInterfaceImplementationsBeFixed();
    protected virtual void AnalyzeCompilationUnit(SemanticModelAnalysisContext context, SyntaxNode root, List`1<AnalysisResult<PropertyDeclarationSyntax, FieldDeclarationSyntax, VariableDeclaratorSyntax, ExpressionSyntax>> analysisResults);
    private void AnalyzeMembers(SemanticModelAnalysisContext context, SyntaxList`1<MemberDeclarationSyntax> members, List`1<AnalysisResult<PropertyDeclarationSyntax, FieldDeclarationSyntax, VariableDeclaratorSyntax, ExpressionSyntax>> analysisResults);
    private void AnalyzeMemberDeclaration(SemanticModelAnalysisContext context, MemberDeclarationSyntax member, List`1<AnalysisResult<PropertyDeclarationSyntax, FieldDeclarationSyntax, VariableDeclaratorSyntax, ExpressionSyntax>> analysisResults);
    protected virtual void RegisterIneligibleFieldsAction(List`1<AnalysisResult<PropertyDeclarationSyntax, FieldDeclarationSyntax, VariableDeclaratorSyntax, ExpressionSyntax>> analysisResults, HashSet`1<IFieldSymbol> ineligibleFields, Compilation compilation, CancellationToken cancellationToken);
    protected virtual ExpressionSyntax GetFieldInitializer(VariableDeclaratorSyntax variable, CancellationToken cancellationToken);
    private static void AddIneligibleFields(SemanticModel semanticModel, ExpressionSyntax expression, HashSet`1<IFieldSymbol> ineligibleFields, CancellationToken cancellationToken);
    private static bool CheckExpressionSyntactically(ExpressionSyntax expression);
    protected virtual ExpressionSyntax GetGetterExpression(IMethodSymbol getMethod, CancellationToken cancellationToken);
    private static ExpressionSyntax GetGetterExpressionFromSymbol(IMethodSymbol getMethod, CancellationToken cancellationToken);
    [NullableContextAttribute("2")]
private static T GetSingleStatementFromAccessor(AccessorDeclarationSyntax accessorDeclaration);
    protected virtual ExpressionSyntax GetSetterExpression(IMethodSymbol setMethod, SemanticModel semanticModel, CancellationToken cancellationToken);
    [NullableContextAttribute("2")]
private static ExpressionSyntax GetExpressionFromSetter(AccessorDeclarationSyntax setAccessor);
    protected virtual SyntaxNode GetFieldNode(FieldDeclarationSyntax fieldDeclaration, VariableDeclaratorSyntax variableDeclarator);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
internal static void <AddIneligibleFields>g__AddIneligibleField|8_0(ISymbol symbol, <>c__DisplayClass8_0& );
}
[ExportCodeFixProviderAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.CSharp.UseAutoProperty.CSharpUseAutoPropertyCodeFixProvider : AbstractUseAutoPropertyCodeFixProvider`5<TypeDeclarationSyntax, PropertyDeclarationSyntax, VariableDeclaratorSyntax, ConstructorDeclarationSyntax, ExpressionSyntax> {
    protected virtual PropertyDeclarationSyntax GetPropertyDeclaration(SyntaxNode node);
    protected virtual SyntaxNode GetNodeToRemove(VariableDeclaratorSyntax declarator);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.CSharp.UseAutoProperty.CSharpUseAutoPropertyCodeFixProvider/<UpdatePropertyAsync>d__3")]
protected virtual Task`1<SyntaxNode> UpdatePropertyAsync(Document propertyDocument, Compilation compilation, IFieldSymbol fieldSymbol, IPropertySymbol propertySymbol, PropertyDeclarationSyntax propertyDeclaration, bool isWrittenOutsideOfConstructor, CancellationToken cancellationToken);
    protected virtual IEnumerable`1<AbstractFormattingRule> GetFormattingRules(Document document);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.CSharp.UseAutoProperty.CSharpUseAutoPropertyCodeFixProvider/<GetFieldInitializerAsync>d__6")]
private static Task`1<ExpressionSyntax> GetFieldInitializerAsync(IFieldSymbol fieldSymbol, CancellationToken cancellationToken);
    private static bool NeedsSetter(Compilation compilation, PropertyDeclarationSyntax propertyDeclaration, bool isWrittenOutsideOfConstructor);
    private static bool SupportsReadOnlyProperties(Compilation compilation);
    private static AccessorListSyntax UpdateAccessorList(AccessorListSyntax accessorList);
    [IteratorStateMachineAttribute("Microsoft.CodeAnalysis.CSharp.UseAutoProperty.CSharpUseAutoPropertyCodeFixProvider/<GetAccessors>d__10")]
private static IEnumerable`1<AccessorDeclarationSyntax> GetAccessors(SyntaxList`1<AccessorDeclarationSyntax> accessors);
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
internal class Microsoft.CodeAnalysis.CSharp.UseCoalesceExpression.CSharpUseCoalesceExpressionDiagnosticAnalyzer : AbstractUseCoalesceExpressionDiagnosticAnalyzer`4<SyntaxKind, ExpressionSyntax, ConditionalExpressionSyntax, BinaryExpressionSyntax> {
    protected virtual ISyntaxFacts GetSyntaxFacts();
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
internal class Microsoft.CodeAnalysis.CSharp.UseCoalesceExpression.CSharpUseCoalesceExpressionForNullableDiagnosticAnalyzer : AbstractUseCoalesceExpressionForNullableDiagnosticAnalyzer`6<SyntaxKind, ExpressionSyntax, ConditionalExpressionSyntax, BinaryExpressionSyntax, MemberAccessExpressionSyntax, PrefixUnaryExpressionSyntax> {
    protected virtual ISyntaxFacts GetSyntaxFacts();
}
[ExportCodeFixProviderAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.CSharp.UseCollectionInitializer.CSharpUseCollectionInitializerCodeFixProvider : AbstractUseCollectionInitializerCodeFixProvider`8<SyntaxKind, ExpressionSyntax, StatementSyntax, ObjectCreationExpressionSyntax, MemberAccessExpressionSyntax, InvocationExpressionSyntax, ExpressionStatementSyntax, VariableDeclaratorSyntax> {
    protected virtual StatementSyntax GetNewStatement(StatementSyntax statement, ObjectCreationExpressionSyntax objectCreation, ImmutableArray`1<ExpressionStatementSyntax> matches);
    private static ObjectCreationExpressionSyntax GetNewObjectCreation(ObjectCreationExpressionSyntax objectCreation, ImmutableArray`1<ExpressionStatementSyntax> matches);
    private static SeparatedSyntaxList`1<ExpressionSyntax> CreateExpressions(ImmutableArray`1<ExpressionStatementSyntax> matches);
    private static ExpressionSyntax ConvertExpression(ExpressionSyntax expression);
    private static ExpressionSyntax ConvertAssignment(AssignmentExpressionSyntax assignment);
    private static ExpressionSyntax ConvertInvocation(InvocationExpressionSyntax invocation);
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
internal class Microsoft.CodeAnalysis.CSharp.UseCollectionInitializer.CSharpUseCollectionInitializerDiagnosticAnalyzer : AbstractUseCollectionInitializerDiagnosticAnalyzer`8<SyntaxKind, ExpressionSyntax, StatementSyntax, ObjectCreationExpressionSyntax, MemberAccessExpressionSyntax, InvocationExpressionSyntax, ExpressionStatementSyntax, VariableDeclaratorSyntax> {
    protected virtual bool AreCollectionInitializersSupported(SyntaxNodeAnalysisContext context);
    protected virtual ISyntaxFacts GetSyntaxFacts();
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[ExportCodeFixProviderAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.CSharp.UseCompoundAssignment.CSharpUseCompoundAssignmentCodeFixProvider : AbstractUseCompoundAssignmentCodeFixProvider`3<SyntaxKind, AssignmentExpressionSyntax, ExpressionSyntax> {
    protected virtual SyntaxToken Token(SyntaxKind kind);
    protected virtual AssignmentExpressionSyntax Assignment(SyntaxKind assignmentOpKind, ExpressionSyntax left, SyntaxToken syntaxToken, ExpressionSyntax right);
    protected virtual ExpressionSyntax Increment(ExpressionSyntax left);
    protected virtual ExpressionSyntax Decrement(ExpressionSyntax left);
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
internal class Microsoft.CodeAnalysis.CSharp.UseCompoundAssignment.CSharpUseCompoundAssignmentDiagnosticAnalyzer : AbstractUseCompoundAssignmentDiagnosticAnalyzer`3<SyntaxKind, AssignmentExpressionSyntax, BinaryExpressionSyntax> {
    protected virtual SyntaxKind GetAnalysisKind();
    protected virtual bool IsSupported(SyntaxKind assignmentKind, ParseOptions options);
    protected virtual int TryGetIncrementOrDecrement(SyntaxKind opKind, object constantValue);
}
[ExportCodeFixProviderAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.CSharp.UseCompoundAssignment.CSharpUseCompoundCoalesceAssignmentCodeFixProvider : SyntaxEditorBasedCodeFixProvider {
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private ImmutableArray`1<string> <FixableDiagnosticIds>k__BackingField;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ImmutableArray`1<string> FixableDiagnosticIds { get; }
    internal CodeFixCategory CodeFixCategory { get; }
    [CompilerGeneratedAttribute]
public virtual ImmutableArray`1<string> get_FixableDiagnosticIds();
    internal sealed virtual CodeFixCategory get_CodeFixCategory();
    [NullableContextAttribute("1")]
public virtual Task RegisterCodeFixesAsync(CodeFixContext context);
    [NullableContextAttribute("1")]
[AsyncStateMachineAttribute("Microsoft.CodeAnalysis.CSharp.UseCompoundAssignment.CSharpUseCompoundCoalesceAssignmentCodeFixProvider/<FixAllAsync>d__7")]
protected virtual Task FixAllAsync(Document document, ImmutableArray`1<Diagnostic> diagnostics, SyntaxEditor editor, CancellationToken cancellationToken);
}
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
internal class Microsoft.CodeAnalysis.CSharp.UseCompoundAssignment.CSharpUseCompoundCoalesceAssignmentDiagnosticAnalyzer : AbstractBuiltInCodeStyleDiagnosticAnalyzer {
    public virtual DiagnosticAnalyzerCategory GetAnalyzerCategory();
    protected virtual void InitializeWorker(AnalysisContext context);
    private void AnalyzeCoalesceExpression(SyntaxNodeAnalysisContext context);
}
internal static class Microsoft.CodeAnalysis.CSharp.UseCompoundAssignment.Utilities : object {
    public static ImmutableArray`1<ValueTuple`3<SyntaxKind, SyntaxKind, SyntaxKind>> Kinds;
    private static Utilities();
    private static SyntaxKind FindOperatorToken(SyntaxKind assignmentExpressionKind);
}
[ExportCodeFixProviderAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.CSharp.UseConditionalExpression.CSharpUseConditionalExpressionForAssignmentCodeFixProvider : AbstractUseConditionalExpressionForAssignmentCodeFixProvider`6<StatementSyntax, IfStatementSyntax, LocalDeclarationStatementSyntax, VariableDeclaratorSyntax, ExpressionSyntax, ConditionalExpressionSyntax> {
    protected virtual AbstractFormattingRule GetMultiLineFormattingRule();
    protected virtual VariableDeclaratorSyntax WithInitializer(VariableDeclaratorSyntax variable, ExpressionSyntax value);
    protected virtual VariableDeclaratorSyntax GetDeclaratorSyntax(IVariableDeclaratorOperation declarator);
    protected virtual LocalDeclarationStatementSyntax AddSimplificationToType(LocalDeclarationStatementSyntax statement);
    protected virtual StatementSyntax WrapWithBlockIfAppropriate(IfStatementSyntax ifStatement, StatementSyntax statement);
    protected virtual ExpressionSyntax ConvertToExpression(IThrowOperation throwOperation);
}
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
internal class Microsoft.CodeAnalysis.CSharp.UseConditionalExpression.CSharpUseConditionalExpressionForAssignmentDiagnosticAnalyzer : AbstractUseConditionalExpressionForAssignmentDiagnosticAnalyzer`1<IfStatementSyntax> {
    protected virtual ISyntaxFacts GetSyntaxFacts();
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[ExportCodeFixProviderAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.CSharp.UseConditionalExpression.CSharpUseConditionalExpressionForReturnCodeFixProvider : AbstractUseConditionalExpressionForReturnCodeFixProvider`4<StatementSyntax, IfStatementSyntax, ExpressionSyntax, ConditionalExpressionSyntax> {
    protected virtual AbstractFormattingRule GetMultiLineFormattingRule();
    protected virtual StatementSyntax WrapWithBlockIfAppropriate(IfStatementSyntax ifStatement, StatementSyntax statement);
    protected virtual ExpressionSyntax ConvertToExpression(IThrowOperation throwOperation);
}
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
internal class Microsoft.CodeAnalysis.CSharp.UseConditionalExpression.CSharpUseConditionalExpressionForReturnDiagnosticAnalyzer : AbstractUseConditionalExpressionForReturnDiagnosticAnalyzer`1<IfStatementSyntax> {
    protected virtual ISyntaxFacts GetSyntaxFacts();
}
internal static class Microsoft.CodeAnalysis.CSharp.UseConditionalExpression.CSharpUseConditionalExpressionHelpers : object {
    [NullableContextAttribute("1")]
public static ExpressionSyntax ConvertToExpression(IThrowOperation throwOperation);
}
internal class Microsoft.CodeAnalysis.CSharp.UseConditionalExpression.MultiLineConditionalExpressionFormattingRule : AbstractFormattingRule {
    public static AbstractFormattingRule Instance;
    private static MultiLineConditionalExpressionFormattingRule();
    private static bool IsQuestionOrColonOfNewConditional(SyntaxToken token);
    public virtual AdjustNewLinesOperation GetAdjustNewLinesOperation(SyntaxToken& modreq(System.Runtime.InteropServices.InAttribute) previousToken, SyntaxToken& modreq(System.Runtime.InteropServices.InAttribute) currentToken, NextGetAdjustNewLinesOperation& modreq(System.Runtime.InteropServices.InAttribute) nextOperation);
    public virtual void AddIndentBlockOperations(List`1<IndentBlockOperation> list, SyntaxNode node, NextIndentBlockOperationAction& modreq(System.Runtime.InteropServices.InAttribute) nextOperation);
}
[ExportCodeFixProviderAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.CSharp.UseDeconstruction.CSharpUseDeconstructionCodeFixProvider : SyntaxEditorBasedCodeFixProvider {
    public ImmutableArray`1<string> FixableDiagnosticIds { get; }
    internal CodeFixCategory CodeFixCategory { get; }
    public virtual ImmutableArray`1<string> get_FixableDiagnosticIds();
    internal sealed virtual CodeFixCategory get_CodeFixCategory();
    public virtual Task RegisterCodeFixesAsync(CodeFixContext context);
    protected virtual Task FixAllAsync(Document document, ImmutableArray`1<Diagnostic> diagnostics, SyntaxEditor editor, CancellationToken cancellationToken);
    private SyntaxNode UpdateRoot(SemanticModel semanticModel, SyntaxNode root, SyntaxNode node, Workspace workspace, CancellationToken cancellationToken);
    private ForEachVariableStatementSyntax CreateForEachVariableStatement(INamedTypeSymbol tupleType, ForEachStatementSyntax forEachStatement);
    private ExpressionStatementSyntax CreateDeconstructionStatement(INamedTypeSymbol tupleType, LocalDeclarationStatementSyntax declarationStatement, VariableDeclaratorSyntax variableDeclarator);
    private ExpressionSyntax CreateTupleOrDeclarationExpression(INamedTypeSymbol tupleType, TypeSyntax typeNode);
    private static DeclarationExpressionSyntax CreateDeclarationExpression(INamedTypeSymbol tupleType, TypeSyntax typeNode);
    private TupleExpressionSyntax CreateTupleExpression(TupleTypeSyntax typeNode);
    private SyntaxNodeOrToken ConvertTupleTypeElementComponent(SyntaxNodeOrToken nodeOrToken);
}
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
internal class Microsoft.CodeAnalysis.CSharp.UseDeconstruction.CSharpUseDeconstructionDiagnosticAnalyzer : AbstractBuiltInCodeStyleDiagnosticAnalyzer {
    public virtual DiagnosticAnalyzerCategory GetAnalyzerCategory();
    protected virtual void InitializeWorker(AnalysisContext context);
    private void AnalyzeNode(SyntaxNodeAnalysisContext context);
    private void AnalyzeVariableDeclaration(SyntaxNodeAnalysisContext context, VariableDeclarationSyntax variableDeclaration, ReportDiagnostic severity);
    private void AnalyzeForEachStatement(SyntaxNodeAnalysisContext context, ForEachStatementSyntax forEachStatement, ReportDiagnostic severity);
    public static bool TryAnalyzeVariableDeclaration(SemanticModel semanticModel, VariableDeclarationSyntax variableDeclaration, INamedTypeSymbol& tupleType, ImmutableArray`1& memberAccessExpressions, CancellationToken cancellationToken);
    public static bool TryAnalyzeForEachStatement(SemanticModel semanticModel, ForEachStatementSyntax forEachStatement, INamedTypeSymbol& tupleType, ImmutableArray`1& memberAccessExpressions, CancellationToken cancellationToken);
    private static bool TryAnalyze(SemanticModel semanticModel, ILocalSymbol local, TypeSyntax typeNode, SyntaxToken identifier, Conversion conversion, SyntaxNode searchScope, INamedTypeSymbol& tupleType, ImmutableArray`1& memberAccessExpressions, CancellationToken cancellationToken);
    private static bool AnyTupleFieldNamesCollideWithExistingNames(SemanticModel semanticModel, INamedTypeSymbol tupleType, SyntaxNode container, CancellationToken cancellationToken);
    private static bool IsViableTupleTypeSyntax(TypeSyntax type);
    private static bool OnlyUsedToAccessTupleFields(SemanticModel semanticModel, SyntaxNode searchScope, ILocalSymbol local, ArrayBuilder`1<MemberAccessExpressionSyntax> memberAccessLocations, CancellationToken cancellationToken);
    private static IEnumerable`1<ISymbol> GetExistingSymbols(SemanticModel semanticModel, SyntaxNode container, CancellationToken cancellationToken);
}
[ExportCodeFixProviderAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.CSharp.UseDefaultLiteral.CSharpUseDefaultLiteralCodeFixProvider : SyntaxEditorBasedCodeFixProvider {
    [CompilerGeneratedAttribute]
private ImmutableArray`1<string> <FixableDiagnosticIds>k__BackingField;
    public ImmutableArray`1<string> FixableDiagnosticIds { get; }
    internal CodeFixCategory CodeFixCategory { get; }
    [CompilerGeneratedAttribute]
public virtual ImmutableArray`1<string> get_FixableDiagnosticIds();
    internal sealed virtual CodeFixCategory get_CodeFixCategory();
    public virtual Task RegisterCodeFixesAsync(CodeFixContext context);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.CSharp.UseDefaultLiteral.CSharpUseDefaultLiteralCodeFixProvider/<FixAllAsync>d__7")]
protected virtual Task FixAllAsync(Document document, ImmutableArray`1<Diagnostic> diagnostics, SyntaxEditor editor, CancellationToken cancellationToken);
}
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
internal class Microsoft.CodeAnalysis.CSharp.UseDefaultLiteral.CSharpUseDefaultLiteralDiagnosticAnalyzer : AbstractBuiltInCodeStyleDiagnosticAnalyzer {
    public virtual DiagnosticAnalyzerCategory GetAnalyzerCategory();
    protected virtual void InitializeWorker(AnalysisContext context);
    private void AnalyzeSyntax(SyntaxNodeAnalysisContext context);
}
[ExportCodeFixProviderAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.CSharp.UseExplicitTypeForConst.UseExplicitTypeForConstCodeFixProvider : CodeFixProvider {
    private static string CS0822;
    [CompilerGeneratedAttribute]
private ImmutableArray`1<string> <FixableDiagnosticIds>k__BackingField;
    public ImmutableArray`1<string> FixableDiagnosticIds { get; }
    [CompilerGeneratedAttribute]
public virtual ImmutableArray`1<string> get_FixableDiagnosticIds();
    public virtual FixAllProvider GetFixAllProvider();
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.CSharp.UseExplicitTypeForConst.UseExplicitTypeForConstCodeFixProvider/<RegisterCodeFixesAsync>d__6")]
public virtual Task RegisterCodeFixesAsync(CodeFixContext context);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.CSharp.UseExplicitTypeForConst.UseExplicitTypeForConstCodeFixProvider/<FixAsync>d__7")]
private static Task`1<Document> FixAsync(Document document, TextSpan span, ITypeSymbol type, CancellationToken cancellationToken);
}
[ExportCodeFixProviderAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.CSharp.UseExpressionBody.UseExpressionBodyCodeFixProvider : SyntaxEditorBasedCodeFixProvider {
    [CompilerGeneratedAttribute]
private ImmutableArray`1<string> <FixableDiagnosticIds>k__BackingField;
    private static ImmutableArray`1<UseExpressionBodyHelper> _helpers;
    public ImmutableArray`1<string> FixableDiagnosticIds { get; }
    internal CodeFixCategory CodeFixCategory { get; }
    private static UseExpressionBodyCodeFixProvider();
    [CompilerGeneratedAttribute]
public sealed virtual ImmutableArray`1<string> get_FixableDiagnosticIds();
    internal sealed virtual CodeFixCategory get_CodeFixCategory();
    protected virtual bool IncludeDiagnosticDuringFixAll(Diagnostic diagnostic);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.CSharp.UseExpressionBody.UseExpressionBodyCodeFixProvider/<RegisterCodeFixesAsync>d__8")]
public sealed virtual Task RegisterCodeFixesAsync(CodeFixContext context);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.CSharp.UseExpressionBody.UseExpressionBodyCodeFixProvider/<FixAllAsync>d__9")]
protected virtual Task FixAllAsync(Document document, ImmutableArray`1<Diagnostic> diagnostics, SyntaxEditor editor, CancellationToken cancellationToken);
    private static void AddEdits(SemanticModel semanticModel, SyntaxEditor editor, Diagnostic diagnostic, HashSet`1<AccessorListSyntax> accessorLists, CancellationToken cancellationToken);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExportCodeRefactoringProviderAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.CSharp.UseExpressionBody.UseExpressionBodyCodeRefactoringProvider : CodeRefactoringProvider {
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private static ImmutableArray`1<UseExpressionBodyHelper> _helpers;
    private static UseExpressionBodyCodeRefactoringProvider();
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.CSharp.UseExpressionBody.UseExpressionBodyCodeRefactoringProvider/<ComputeRefactoringsAsync>d__2")]
public virtual Task ComputeRefactoringsAsync(CodeRefactoringContext context);
    private static SyntaxNode TryGetDeclaration(UseExpressionBodyHelper helper, SourceText text, SyntaxNode node, int position);
    private static bool TryComputeRefactoring(CodeRefactoringContext context, SyntaxNode root, SyntaxNode declaration, OptionSet optionSet, UseExpressionBodyHelper helper);
    private static SyntaxNode GetDeclaration(SyntaxNode node, UseExpressionBodyHelper helper);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.CSharp.UseExpressionBody.UseExpressionBodyCodeRefactoringProvider/<UpdateDocumentAsync>d__6")]
private static Task`1<Document> UpdateDocumentAsync(Document document, SyntaxNode root, SyntaxNode declaration, UseExpressionBodyHelper helper, bool useExpressionBody, CancellationToken cancellationToken);
}
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
internal class Microsoft.CodeAnalysis.CSharp.UseExpressionBody.UseExpressionBodyDiagnosticAnalyzer : AbstractBuiltInCodeStyleDiagnosticAnalyzer {
    public static string FixesError;
    private ImmutableArray`1<SyntaxKind> _syntaxKinds;
    private static ImmutableArray`1<UseExpressionBodyHelper> _helpers;
    private static UseExpressionBodyDiagnosticAnalyzer();
    private static ImmutableDictionary`2<DiagnosticDescriptor, ILanguageSpecificOption> GetSupportedDescriptorsWithOptions();
    public virtual DiagnosticAnalyzerCategory GetAnalyzerCategory();
    protected virtual void InitializeWorker(AnalysisContext context);
    private void AnalyzeSyntax(SyntaxNodeAnalysisContext context);
    private static Diagnostic AnalyzeSyntax(OptionSet optionSet, SyntaxNode declaration, UseExpressionBodyHelper helper);
}
internal class Microsoft.CodeAnalysis.CSharp.UseExpressionBody.UseExpressionBodyForAccessorsHelper : UseExpressionBodyHelper`1<AccessorDeclarationSyntax> {
    public static UseExpressionBodyForAccessorsHelper Instance;
    private static UseExpressionBodyForAccessorsHelper();
    protected virtual BlockSyntax GetBody(AccessorDeclarationSyntax declaration);
    protected virtual ArrowExpressionClauseSyntax GetExpressionBody(AccessorDeclarationSyntax declaration);
    protected virtual SyntaxToken GetSemicolonToken(AccessorDeclarationSyntax declaration);
    protected virtual AccessorDeclarationSyntax WithSemicolonToken(AccessorDeclarationSyntax declaration, SyntaxToken token);
    protected virtual AccessorDeclarationSyntax WithExpressionBody(AccessorDeclarationSyntax declaration, ArrowExpressionClauseSyntax expressionBody);
    protected virtual AccessorDeclarationSyntax WithBody(AccessorDeclarationSyntax declaration, BlockSyntax body);
    protected virtual bool CreateReturnStatementForExpression(SemanticModel semanticModel, AccessorDeclarationSyntax declaration);
}
internal class Microsoft.CodeAnalysis.CSharp.UseExpressionBody.UseExpressionBodyForConstructorsHelper : UseExpressionBodyHelper`1<ConstructorDeclarationSyntax> {
    public static UseExpressionBodyForConstructorsHelper Instance;
    private static UseExpressionBodyForConstructorsHelper();
    protected virtual BlockSyntax GetBody(ConstructorDeclarationSyntax declaration);
    protected virtual ArrowExpressionClauseSyntax GetExpressionBody(ConstructorDeclarationSyntax declaration);
    protected virtual SyntaxToken GetSemicolonToken(ConstructorDeclarationSyntax declaration);
    protected virtual ConstructorDeclarationSyntax WithSemicolonToken(ConstructorDeclarationSyntax declaration, SyntaxToken token);
    protected virtual ConstructorDeclarationSyntax WithExpressionBody(ConstructorDeclarationSyntax declaration, ArrowExpressionClauseSyntax expressionBody);
    protected virtual ConstructorDeclarationSyntax WithBody(ConstructorDeclarationSyntax declaration, BlockSyntax body);
    protected virtual bool CreateReturnStatementForExpression(SemanticModel semanticModel, ConstructorDeclarationSyntax declaration);
}
internal class Microsoft.CodeAnalysis.CSharp.UseExpressionBody.UseExpressionBodyForConversionOperatorsHelper : UseExpressionBodyHelper`1<ConversionOperatorDeclarationSyntax> {
    public static UseExpressionBodyForConversionOperatorsHelper Instance;
    private static UseExpressionBodyForConversionOperatorsHelper();
    protected virtual BlockSyntax GetBody(ConversionOperatorDeclarationSyntax declaration);
    protected virtual ArrowExpressionClauseSyntax GetExpressionBody(ConversionOperatorDeclarationSyntax declaration);
    protected virtual SyntaxToken GetSemicolonToken(ConversionOperatorDeclarationSyntax declaration);
    protected virtual ConversionOperatorDeclarationSyntax WithSemicolonToken(ConversionOperatorDeclarationSyntax declaration, SyntaxToken token);
    protected virtual ConversionOperatorDeclarationSyntax WithExpressionBody(ConversionOperatorDeclarationSyntax declaration, ArrowExpressionClauseSyntax expressionBody);
    protected virtual ConversionOperatorDeclarationSyntax WithBody(ConversionOperatorDeclarationSyntax declaration, BlockSyntax body);
    protected virtual bool CreateReturnStatementForExpression(SemanticModel semanticModel, ConversionOperatorDeclarationSyntax declaration);
}
internal class Microsoft.CodeAnalysis.CSharp.UseExpressionBody.UseExpressionBodyForIndexersHelper : UseExpressionBodyHelper`1<IndexerDeclarationSyntax> {
    public static UseExpressionBodyForIndexersHelper Instance;
    private static UseExpressionBodyForIndexersHelper();
    protected virtual BlockSyntax GetBody(IndexerDeclarationSyntax declaration);
    protected virtual ArrowExpressionClauseSyntax GetExpressionBody(IndexerDeclarationSyntax declaration);
    protected virtual SyntaxToken GetSemicolonToken(IndexerDeclarationSyntax declaration);
    protected virtual IndexerDeclarationSyntax WithSemicolonToken(IndexerDeclarationSyntax declaration, SyntaxToken token);
    protected virtual IndexerDeclarationSyntax WithExpressionBody(IndexerDeclarationSyntax declaration, ArrowExpressionClauseSyntax expressionBody);
    protected virtual IndexerDeclarationSyntax WithAccessorList(IndexerDeclarationSyntax declaration, AccessorListSyntax accessorList);
    protected virtual IndexerDeclarationSyntax WithBody(IndexerDeclarationSyntax declaration, BlockSyntax body);
    protected virtual IndexerDeclarationSyntax WithGenerateBody(SemanticModel semanticModel, IndexerDeclarationSyntax declaration);
    protected virtual bool CreateReturnStatementForExpression(SemanticModel semanticModel, IndexerDeclarationSyntax declaration);
    protected virtual bool TryConvertToExpressionBody(IndexerDeclarationSyntax declaration, ParseOptions options, ExpressionBodyPreference conversionPreference, ArrowExpressionClauseSyntax& arrowExpression, SyntaxToken& semicolonToken);
    protected virtual Location GetDiagnosticLocation(IndexerDeclarationSyntax declaration);
}
internal class Microsoft.CodeAnalysis.CSharp.UseExpressionBody.UseExpressionBodyForLocalFunctionHelper : UseExpressionBodyHelper`1<LocalFunctionStatementSyntax> {
    public static UseExpressionBodyForLocalFunctionHelper Instance;
    private static UseExpressionBodyForLocalFunctionHelper();
    protected virtual BlockSyntax GetBody(LocalFunctionStatementSyntax statement);
    protected virtual ArrowExpressionClauseSyntax GetExpressionBody(LocalFunctionStatementSyntax statement);
    protected virtual SyntaxToken GetSemicolonToken(LocalFunctionStatementSyntax statement);
    protected virtual LocalFunctionStatementSyntax WithSemicolonToken(LocalFunctionStatementSyntax statement, SyntaxToken token);
    protected virtual LocalFunctionStatementSyntax WithExpressionBody(LocalFunctionStatementSyntax statement, ArrowExpressionClauseSyntax expressionBody);
    protected virtual LocalFunctionStatementSyntax WithBody(LocalFunctionStatementSyntax statement, BlockSyntax body);
    protected virtual bool CreateReturnStatementForExpression(SemanticModel semanticModel, LocalFunctionStatementSyntax statement);
}
internal class Microsoft.CodeAnalysis.CSharp.UseExpressionBody.UseExpressionBodyForMethodsHelper : UseExpressionBodyHelper`1<MethodDeclarationSyntax> {
    public static UseExpressionBodyForMethodsHelper Instance;
    private static UseExpressionBodyForMethodsHelper();
    protected virtual BlockSyntax GetBody(MethodDeclarationSyntax declaration);
    protected virtual ArrowExpressionClauseSyntax GetExpressionBody(MethodDeclarationSyntax declaration);
    protected virtual SyntaxToken GetSemicolonToken(MethodDeclarationSyntax declaration);
    protected virtual MethodDeclarationSyntax WithSemicolonToken(MethodDeclarationSyntax declaration, SyntaxToken token);
    protected virtual MethodDeclarationSyntax WithExpressionBody(MethodDeclarationSyntax declaration, ArrowExpressionClauseSyntax expressionBody);
    protected virtual MethodDeclarationSyntax WithBody(MethodDeclarationSyntax declaration, BlockSyntax body);
    protected virtual bool CreateReturnStatementForExpression(SemanticModel semanticModel, MethodDeclarationSyntax declaration);
}
internal class Microsoft.CodeAnalysis.CSharp.UseExpressionBody.UseExpressionBodyForOperatorsHelper : UseExpressionBodyHelper`1<OperatorDeclarationSyntax> {
    public static UseExpressionBodyForOperatorsHelper Instance;
    private static UseExpressionBodyForOperatorsHelper();
    protected virtual BlockSyntax GetBody(OperatorDeclarationSyntax declaration);
    protected virtual ArrowExpressionClauseSyntax GetExpressionBody(OperatorDeclarationSyntax declaration);
    protected virtual SyntaxToken GetSemicolonToken(OperatorDeclarationSyntax declaration);
    protected virtual OperatorDeclarationSyntax WithSemicolonToken(OperatorDeclarationSyntax declaration, SyntaxToken token);
    protected virtual OperatorDeclarationSyntax WithExpressionBody(OperatorDeclarationSyntax declaration, ArrowExpressionClauseSyntax expressionBody);
    protected virtual OperatorDeclarationSyntax WithBody(OperatorDeclarationSyntax declaration, BlockSyntax body);
    protected virtual bool CreateReturnStatementForExpression(SemanticModel semanticModel, OperatorDeclarationSyntax declaration);
}
internal class Microsoft.CodeAnalysis.CSharp.UseExpressionBody.UseExpressionBodyForPropertiesHelper : UseExpressionBodyHelper`1<PropertyDeclarationSyntax> {
    public static UseExpressionBodyForPropertiesHelper Instance;
    private static UseExpressionBodyForPropertiesHelper();
    protected virtual BlockSyntax GetBody(PropertyDeclarationSyntax declaration);
    protected virtual ArrowExpressionClauseSyntax GetExpressionBody(PropertyDeclarationSyntax declaration);
    protected virtual SyntaxToken GetSemicolonToken(PropertyDeclarationSyntax declaration);
    protected virtual PropertyDeclarationSyntax WithSemicolonToken(PropertyDeclarationSyntax declaration, SyntaxToken token);
    protected virtual PropertyDeclarationSyntax WithExpressionBody(PropertyDeclarationSyntax declaration, ArrowExpressionClauseSyntax expressionBody);
    protected virtual PropertyDeclarationSyntax WithAccessorList(PropertyDeclarationSyntax declaration, AccessorListSyntax accessorListSyntax);
    protected virtual PropertyDeclarationSyntax WithBody(PropertyDeclarationSyntax declaration, BlockSyntax body);
    protected virtual PropertyDeclarationSyntax WithGenerateBody(SemanticModel semanticModel, PropertyDeclarationSyntax declaration);
    protected virtual bool CreateReturnStatementForExpression(SemanticModel semanticModel, PropertyDeclarationSyntax declaration);
    protected virtual bool TryConvertToExpressionBody(PropertyDeclarationSyntax declaration, ParseOptions options, ExpressionBodyPreference conversionPreference, ArrowExpressionClauseSyntax& arrowExpression, SyntaxToken& semicolonToken);
    protected virtual Location GetDiagnosticLocation(PropertyDeclarationSyntax declaration);
}
internal abstract class Microsoft.CodeAnalysis.CSharp.UseExpressionBody.UseExpressionBodyHelper : object {
    public static ImmutableArray`1<UseExpressionBodyHelper> Helpers;
    public Option2`1<CodeStyleOption2`1<ExpressionBodyPreference>> Option { get; }
    public LocalizableString UseExpressionBodyTitle { get; }
    public LocalizableString UseBlockBodyTitle { get; }
    public string DiagnosticId { get; }
    public EnforceOnBuild EnforceOnBuild { get; }
    public ImmutableArray`1<SyntaxKind> SyntaxKinds { get; }
    private static UseExpressionBodyHelper();
    public abstract virtual Option2`1<CodeStyleOption2`1<ExpressionBodyPreference>> get_Option();
    public abstract virtual LocalizableString get_UseExpressionBodyTitle();
    public abstract virtual LocalizableString get_UseBlockBodyTitle();
    public abstract virtual string get_DiagnosticId();
    public abstract virtual EnforceOnBuild get_EnforceOnBuild();
    public abstract virtual ImmutableArray`1<SyntaxKind> get_SyntaxKinds();
    public abstract virtual BlockSyntax GetBody(SyntaxNode declaration);
    public abstract virtual ArrowExpressionClauseSyntax GetExpressionBody(SyntaxNode declaration);
    public abstract virtual bool CanOfferUseExpressionBody(OptionSet optionSet, SyntaxNode declaration, bool forAnalyzer);
    public abstract virtual ValueTuple`2<bool, bool> CanOfferUseBlockBody(OptionSet optionSet, SyntaxNode declaration, bool forAnalyzer);
    public abstract virtual SyntaxNode Update(SemanticModel semanticModel, SyntaxNode declaration, bool useExpressionBody);
    public abstract virtual Location GetDiagnosticLocation(SyntaxNode declaration);
}
internal abstract class Microsoft.CodeAnalysis.CSharp.UseExpressionBody.UseExpressionBodyHelper`1 : UseExpressionBodyHelper {
    [CompilerGeneratedAttribute]
private Option2`1<CodeStyleOption2`1<ExpressionBodyPreference>> <Option>k__BackingField;
    [CompilerGeneratedAttribute]
private LocalizableString <UseExpressionBodyTitle>k__BackingField;
    [CompilerGeneratedAttribute]
private LocalizableString <UseBlockBodyTitle>k__BackingField;
    [CompilerGeneratedAttribute]
private string <DiagnosticId>k__BackingField;
    [CompilerGeneratedAttribute]
private EnforceOnBuild <EnforceOnBuild>k__BackingField;
    [CompilerGeneratedAttribute]
private ImmutableArray`1<SyntaxKind> <SyntaxKinds>k__BackingField;
    public Option2`1<CodeStyleOption2`1<ExpressionBodyPreference>> Option { get; }
    public LocalizableString UseExpressionBodyTitle { get; }
    public LocalizableString UseBlockBodyTitle { get; }
    public string DiagnosticId { get; }
    public EnforceOnBuild EnforceOnBuild { get; }
    public ImmutableArray`1<SyntaxKind> SyntaxKinds { get; }
    protected UseExpressionBodyHelper`1(string diagnosticId, EnforceOnBuild enforceOnBuild, LocalizableString useExpressionBodyTitle, LocalizableString useBlockBodyTitle, Option2`1<CodeStyleOption2`1<ExpressionBodyPreference>> option, ImmutableArray`1<SyntaxKind> syntaxKinds);
    [CompilerGeneratedAttribute]
public virtual Option2`1<CodeStyleOption2`1<ExpressionBodyPreference>> get_Option();
    [CompilerGeneratedAttribute]
public virtual LocalizableString get_UseExpressionBodyTitle();
    [CompilerGeneratedAttribute]
public virtual LocalizableString get_UseBlockBodyTitle();
    [CompilerGeneratedAttribute]
public virtual string get_DiagnosticId();
    [CompilerGeneratedAttribute]
public virtual EnforceOnBuild get_EnforceOnBuild();
    [CompilerGeneratedAttribute]
public virtual ImmutableArray`1<SyntaxKind> get_SyntaxKinds();
    protected static AccessorDeclarationSyntax GetSingleGetAccessor(AccessorListSyntax accessorList);
    protected static BlockSyntax GetBodyFromSingleGetAccessor(AccessorListSyntax accessorList);
    public virtual BlockSyntax GetBody(SyntaxNode declaration);
    public virtual ArrowExpressionClauseSyntax GetExpressionBody(SyntaxNode declaration);
    public virtual bool CanOfferUseExpressionBody(OptionSet optionSet, SyntaxNode declaration, bool forAnalyzer);
    public virtual ValueTuple`2<bool, bool> CanOfferUseBlockBody(OptionSet optionSet, SyntaxNode declaration, bool forAnalyzer);
    public sealed virtual SyntaxNode Update(SemanticModel semanticModel, SyntaxNode declaration, bool useExpressionBody);
    public virtual Location GetDiagnosticLocation(SyntaxNode declaration);
    protected virtual Location GetDiagnosticLocation(TDeclaration declaration);
    public bool CanOfferUseExpressionBody(OptionSet optionSet, TDeclaration declaration, bool forAnalyzer);
    protected virtual bool TryConvertToExpressionBody(TDeclaration declaration, ParseOptions options, ExpressionBodyPreference conversionPreference, ArrowExpressionClauseSyntax& expressionWhenOnSingleLine, SyntaxToken& semicolonWhenOnSingleLine);
    private bool TryConvertToExpressionBodyWorker(SyntaxNode declaration, ParseOptions options, ExpressionBodyPreference conversionPreference, ArrowExpressionClauseSyntax& expressionWhenOnSingleLine, SyntaxToken& semicolonWhenOnSingleLine);
    protected bool TryConvertToExpressionBodyForBaseProperty(BasePropertyDeclarationSyntax declaration, ParseOptions options, ExpressionBodyPreference conversionPreference, ArrowExpressionClauseSyntax& arrowExpression, SyntaxToken& semicolonToken);
    public ValueTuple`2<bool, bool> CanOfferUseBlockBody(OptionSet optionSet, TDeclaration declaration, bool forAnalyzer);
    public TDeclaration Update(SemanticModel semanticModel, TDeclaration declaration, bool useExpressionBody);
    protected abstract virtual BlockSyntax GetBody(TDeclaration declaration);
    protected abstract virtual ArrowExpressionClauseSyntax GetExpressionBody(TDeclaration declaration);
    protected abstract virtual bool CreateReturnStatementForExpression(SemanticModel semanticModel, TDeclaration declaration);
    protected abstract virtual SyntaxToken GetSemicolonToken(TDeclaration declaration);
    protected abstract virtual TDeclaration WithSemicolonToken(TDeclaration declaration, SyntaxToken token);
    protected abstract virtual TDeclaration WithExpressionBody(TDeclaration declaration, ArrowExpressionClauseSyntax expressionBody);
    protected abstract virtual TDeclaration WithBody(TDeclaration declaration, BlockSyntax body);
    protected virtual TDeclaration WithGenerateBody(SemanticModel semanticModel, TDeclaration declaration);
    protected TDeclaration WithAccessorList(SemanticModel semanticModel, TDeclaration declaration);
    protected virtual TDeclaration WithAccessorList(TDeclaration declaration, AccessorListSyntax accessorListSyntax);
}
[ExportCodeFixProviderAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.CSharp.UseExpressionBodyForLambda.UseExpressionBodyForLambdaCodeFixProvider : CodeFixProvider<ExpressionBodyPreference, UseExpressionBodyForLambdaCodeStyleProvider> {
}
[ExportCodeRefactoringProviderAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.CSharp.UseExpressionBodyForLambda.UseExpressionBodyForLambdaCodeRefactoringProvider : CodeRefactoringProvider<ExpressionBodyPreference, UseExpressionBodyForLambdaCodeStyleProvider> {
}
internal class Microsoft.CodeAnalysis.CSharp.UseExpressionBodyForLambda.UseExpressionBodyForLambdaCodeStyleProvider : AbstractCodeStyleProvider`2<ExpressionBodyPreference, UseExpressionBodyForLambdaCodeStyleProvider> {
    private static LocalizableString UseExpressionBodyTitle;
    private static LocalizableString UseBlockBodyTitle;
    private static UseExpressionBodyForLambdaCodeStyleProvider();
    private static ExpressionSyntax GetBodyAsExpression(LambdaExpressionSyntax declaration);
    private static bool CanOfferUseExpressionBody(ExpressionBodyPreference preference, LambdaExpressionSyntax declaration);
    private static bool TryConvertToExpressionBody(LambdaExpressionSyntax declaration, ParseOptions options, ExpressionBodyPreference conversionPreference, ExpressionSyntax& expression, SyntaxToken& semicolon);
    private static bool CanOfferUseBlockBody(SemanticModel semanticModel, ExpressionBodyPreference preference, LambdaExpressionSyntax declaration, CancellationToken cancellationToken);
    private static LambdaExpressionSyntax Update(SemanticModel semanticModel, LambdaExpressionSyntax originalDeclaration, LambdaExpressionSyntax currentDeclaration);
    private static LambdaExpressionSyntax UpdateWorker(SemanticModel semanticModel, LambdaExpressionSyntax originalDeclaration, LambdaExpressionSyntax currentDeclaration);
    private static LambdaExpressionSyntax WithExpressionBody(LambdaExpressionSyntax declaration);
    private static LambdaExpressionSyntax WithBlockBody(SemanticModel semanticModel, LambdaExpressionSyntax originalDeclaration, LambdaExpressionSyntax currentDeclaration);
    private static bool CreateReturnStatementForExpression(SemanticModel semanticModel, LambdaExpressionSyntax declaration);
    protected virtual void DiagnosticAnalyzerInitialize(AnalysisContext<ExpressionBodyPreference, UseExpressionBodyForLambdaCodeStyleProvider> context);
    protected virtual DiagnosticAnalyzerCategory GetAnalyzerCategory();
    private void AnalyzeSyntax(SyntaxNodeAnalysisContext context, CodeStyleOption2`1<ExpressionBodyPreference> option);
    private Diagnostic AnalyzeSyntax(SemanticModel semanticModel, CodeStyleOption2`1<ExpressionBodyPreference> option, LambdaExpressionSyntax declaration, CancellationToken cancellationToken);
    private static Location GetDiagnosticLocation(LambdaExpressionSyntax declaration);
    protected virtual Task`1<ImmutableArray`1<CodeAction>> ComputeCodeActionsAsync(Document document, Diagnostic diagnostic, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.CSharp.UseExpressionBodyForLambda.UseExpressionBodyForLambdaCodeStyleProvider/<FixAllAsync>d__19")]
protected virtual Task FixAllAsync(Document document, ImmutableArray`1<Diagnostic> diagnostics, SyntaxEditor editor, CancellationToken cancellationToken);
    private static void AddEdits(SyntaxEditor editor, SemanticModel semanticModel, Diagnostic diagnostic, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.CSharp.UseExpressionBodyForLambda.UseExpressionBodyForLambdaCodeStyleProvider/<ComputeOpposingRefactoringsWhenAnalyzerActiveAsync>d__21")]
protected virtual Task`1<ImmutableArray`1<CodeAction>> ComputeOpposingRefactoringsWhenAnalyzerActiveAsync(Document document, TextSpan span, ExpressionBodyPreference option, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.CSharp.UseExpressionBodyForLambda.UseExpressionBodyForLambdaCodeStyleProvider/<ComputeAllRefactoringsWhenAnalyzerInactiveAsync>d__22")]
protected virtual Task`1<ImmutableArray`1<CodeAction>> ComputeAllRefactoringsWhenAnalyzerInactiveAsync(Document document, TextSpan span, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.CSharp.UseExpressionBodyForLambda.UseExpressionBodyForLambdaCodeStyleProvider/<ComputeRefactoringsAsync>d__23")]
private static Task`1<ImmutableArray`1<CodeAction>> ComputeRefactoringsAsync(Document document, TextSpan span, ExpressionBodyPreference option, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.CSharp.UseExpressionBodyForLambda.UseExpressionBodyForLambdaCodeStyleProvider/<UpdateDocumentAsync>d__24")]
private static Task`1<Document> UpdateDocumentAsync(Document document, SyntaxNode root, LambdaExpressionSyntax declaration, CancellationToken cancellationToken);
}
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
internal class Microsoft.CodeAnalysis.CSharp.UseExpressionBodyForLambda.UseExpressionBodyForLambdaDiagnosticAnalyzer : DiagnosticAnalyzer<ExpressionBodyPreference, UseExpressionBodyForLambdaCodeStyleProvider> {
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExportCodeFixProviderAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.CSharp.UseImplicitObjectCreation.CSharpUseImplicitObjectCreationCodeFixProvider : SyntaxEditorBasedCodeFixProvider {
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ImmutableArray`1<string> FixableDiagnosticIds { get; }
    internal CodeFixCategory CodeFixCategory { get; }
    public virtual ImmutableArray`1<string> get_FixableDiagnosticIds();
    internal sealed virtual CodeFixCategory get_CodeFixCategory();
    protected virtual bool IncludeDiagnosticDuringFixAll(Diagnostic diagnostic);
    public virtual Task RegisterCodeFixesAsync(CodeFixContext context);
    protected virtual Task FixAllAsync(Document document, ImmutableArray`1<Diagnostic> diagnostics, SyntaxEditor editor, CancellationToken cancellationToken);
    private static void FixOne(SyntaxEditor editor, Diagnostic diagnostic, CancellationToken cancellationToken);
    private static SyntaxToken WithoutTrailingWhitespace(SyntaxToken newKeyword);
}
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
internal class Microsoft.CodeAnalysis.CSharp.UseImplicitObjectCreation.CSharpUseImplicitObjectCreationDiagnosticAnalyzer : AbstractBuiltInCodeStyleDiagnosticAnalyzer {
    public virtual DiagnosticAnalyzerCategory GetAnalyzerCategory();
    [NullableContextAttribute("1")]
protected virtual void InitializeWorker(AnalysisContext context);
    private void AnalyzeSyntax(SyntaxNodeAnalysisContext context);
}
internal static class Microsoft.CodeAnalysis.CSharp.UseIndexOrRangeOperator.CodeFixHelpers : object {
    public static PrefixUnaryExpressionSyntax IndexExpression(ExpressionSyntax expr);
}
[ExportCodeFixProviderAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.CSharp.UseIndexOrRangeOperator.CSharpUseIndexOperatorCodeFixProvider : SyntaxEditorBasedCodeFixProvider {
    [CompilerGeneratedAttribute]
private ImmutableArray`1<string> <FixableDiagnosticIds>k__BackingField;
    public ImmutableArray`1<string> FixableDiagnosticIds { get; }
    internal CodeFixCategory CodeFixCategory { get; }
    [CompilerGeneratedAttribute]
public virtual ImmutableArray`1<string> get_FixableDiagnosticIds();
    internal sealed virtual CodeFixCategory get_CodeFixCategory();
    public virtual Task RegisterCodeFixesAsync(CodeFixContext context);
    protected virtual Task FixAllAsync(Document document, ImmutableArray`1<Diagnostic> diagnostics, SyntaxEditor editor, CancellationToken cancellationToken);
}
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
internal class Microsoft.CodeAnalysis.CSharp.UseIndexOrRangeOperator.CSharpUseIndexOperatorDiagnosticAnalyzer : AbstractBuiltInCodeStyleDiagnosticAnalyzer {
    public virtual DiagnosticAnalyzerCategory GetAnalyzerCategory();
    protected virtual void InitializeWorker(AnalysisContext context);
    private void AnalyzeInvocation(OperationAnalysisContext context, InfoCache infoCache);
    private void AnalyzePropertyReference(OperationAnalysisContext context, InfoCache infoCache);
    private void AnalyzeArrayElementReference(OperationAnalysisContext context, InfoCache infoCache, IPropertySymbol arrayLengthProperty);
    private void AnalyzeInvokedMember(OperationAnalysisContext context, InfoCache infoCache, IOperation instance, IMethodSymbol targetMethodOpt, IOperation argumentValue, IPropertySymbol lengthLikePropertyOpt, CancellationToken cancellationToken);
    private static IPropertySymbol TryGetLengthLikeProperty(InfoCache infoCache, IMethodSymbol targetMethodOpt);
}
[ExportCodeFixProviderAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.CSharp.UseIndexOrRangeOperator.CSharpUseRangeOperatorCodeFixProvider : SyntaxEditorBasedCodeFixProvider {
    [CompilerGeneratedAttribute]
private ImmutableArray`1<string> <FixableDiagnosticIds>k__BackingField;
    public ImmutableArray`1<string> FixableDiagnosticIds { get; }
    internal CodeFixCategory CodeFixCategory { get; }
    [CompilerGeneratedAttribute]
public virtual ImmutableArray`1<string> get_FixableDiagnosticIds();
    internal sealed virtual CodeFixCategory get_CodeFixCategory();
    public virtual Task RegisterCodeFixesAsync(CodeFixContext context);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.CSharp.UseIndexOrRangeOperator.CSharpUseRangeOperatorCodeFixProvider/<FixAllAsync>d__7")]
protected virtual Task FixAllAsync(Document document, ImmutableArray`1<Diagnostic> diagnostics, SyntaxEditor editor, CancellationToken cancellationToken);
    private static SyntaxNode UpdateInvocation(SemanticModel semanticModel, SyntaxNode currentRoot, InvocationExpressionSyntax currentInvocation, SyntaxGenerator generator, CancellationToken cancellationToken);
    private static InvocationExpressionSyntax GetInvocationExpression(Diagnostic d, CancellationToken cancellationToken);
    private static ExpressionSyntax FixOne(Result result, SyntaxGenerator generator);
    private static RangeExpressionSyntax CreateRangeExpression(Result result, SyntaxGenerator generator);
    private static RangeExpressionSyntax CreateComputedRange(Result result);
    private static RangeExpressionSyntax CreateConstantRange(Result result, SyntaxGenerator generator);
    private static int GetInt32Value(IOperation operation);
    private static bool IsFromEnd(IPropertySymbol lengthLikeProperty, IOperation instance, IOperation& rangeOperation);
}
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
internal class Microsoft.CodeAnalysis.CSharp.UseIndexOrRangeOperator.CSharpUseRangeOperatorDiagnosticAnalyzer : AbstractBuiltInCodeStyleDiagnosticAnalyzer {
    public static string ComputedRange;
    public static string ConstantRange;
    public virtual DiagnosticAnalyzerCategory GetAnalyzerCategory();
    protected virtual void InitializeWorker(AnalysisContext context);
    private void AnalyzeInvocation(OperationAnalysisContext context, InfoCache infoCache);
    public static Nullable`1<Result> AnalyzeInvocation(IInvocationOperation invocation, InfoCache infoCache, AnalyzerOptions analyzerOptionsOpt, CancellationToken cancellationToken);
    private static Nullable`1<Result> AnalyzeOneArgumentInvocation(IInvocationOperation invocation, InfoCache infoCache, InvocationExpressionSyntax invocationSyntax, CodeStyleOption2`1<bool> option);
    private static Nullable`1<Result> AnalyzeTwoArgumentInvocation(IInvocationOperation invocation, InfoCache infoCache, InvocationExpressionSyntax invocationSyntax, CodeStyleOption2`1<bool> option);
    private Diagnostic CreateDiagnostic(Result result);
    private static bool IsConstantInt32(IOperation operation);
    private static bool IsWriteableIndexer(IInvocationOperation invocation, IPropertySymbol indexer);
    [NullableContextAttribute("1")]
[CompilerGeneratedAttribute]
private void <InitializeWorker>b__4_0(CompilationStartAnalysisContext compilationContext);
}
internal static class Microsoft.CodeAnalysis.CSharp.UseIndexOrRangeOperator.Helpers : object {
    public static IPropertySymbol TryGetLengthOrCountProperty(ITypeSymbol namedType);
    public static IPropertySymbol TryGetNoArgInt32Property(ITypeSymbol type, string name);
    public static bool IsPublicInstance(ISymbol symbol);
    public static bool IsInstanceLengthCheck(IPropertySymbol lengthLikeProperty, IOperation instance, IOperation operation);
    public static bool IsSubtraction(IOperation operation, IBinaryOperation& subtraction);
    public static bool IsIntIndexingMethod(IMethodSymbol method);
    public static bool IsTwoArgumentSliceLikeMethod(IMethodSymbol method);
    public static bool IsOneArgumentSliceLikeMethod(IMethodSymbol method);
    private static bool IsSliceFirstParameter(IParameterSymbol parameter);
    private static bool IsSliceSecondParameter(IParameterSymbol parameter);
    public static IPropertySymbol GetIndexer(ITypeSymbol type, ITypeSymbol parameterType, ITypeSymbol returnType);
    public static IMethodSymbol GetOverload(IMethodSymbol method, ITypeSymbol parameterType);
}
[IsReadOnlyAttribute]
internal class Microsoft.CodeAnalysis.CSharp.UseIndexOrRangeOperator.MemberInfo : ValueType {
    public IPropertySymbol LengthLikeProperty;
    public IMethodSymbol OverloadedMethodOpt;
    public MemberInfo(IPropertySymbol lengthLikeProperty, IMethodSymbol overloadedMethodOpt);
}
[ExportCodeFixProviderAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.CSharp.UseInferredMemberName.CSharpUseInferredMemberNameCodeFixProvider : AbstractUseInferredMemberNameCodeFixProvider {
    protected virtual void LanguageSpecificRemoveSuggestedNode(SyntaxEditor editor, SyntaxNode node);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
internal class Microsoft.CodeAnalysis.CSharp.UseInferredMemberName.CSharpUseInferredMemberNameDiagnosticAnalyzer : AbstractUseInferredMemberNameDiagnosticAnalyzer {
    protected virtual void InitializeWorker(AnalysisContext context);
    protected virtual void LanguageSpecificAnalyzeSyntax(SyntaxNodeAnalysisContext context, SyntaxTree syntaxTree, AnalyzerOptions options, CancellationToken cancellationToken);
    private void ReportDiagnosticsIfNeeded(NameColonSyntax nameColon, SyntaxNodeAnalysisContext context, AnalyzerOptions options, SyntaxTree syntaxTree, CancellationToken cancellationToken);
    private void ReportDiagnosticsIfNeeded(NameEqualsSyntax nameEquals, SyntaxNodeAnalysisContext context, AnalyzerOptions options, SyntaxTree syntaxTree, CancellationToken cancellationToken);
}
[ExportCodeFixProviderAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.CSharp.UseInterpolatedVerbatimString.CSharpUseInterpolatedVerbatimStringCodeFixProvider : SyntaxEditorBasedCodeFixProvider {
    private static string InterpolatedVerbatimText;
    public ImmutableArray`1<string> FixableDiagnosticIds { get; }
    internal CodeFixCategory CodeFixCategory { get; }
    public virtual ImmutableArray`1<string> get_FixableDiagnosticIds();
    internal sealed virtual CodeFixCategory get_CodeFixCategory();
    public virtual Task RegisterCodeFixesAsync(CodeFixContext context);
    protected virtual Task FixAllAsync(Document document, ImmutableArray`1<Diagnostic> diagnostics, SyntaxEditor editor, CancellationToken cancellationToken);
    private static void AddEdits(SyntaxEditor editor, Diagnostic diagnostic, CancellationToken cancellationToken);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExportCodeFixProviderAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.CSharp.UseIsNullCheck.CSharpUseIsNullCheckForCastAndEqualityOperatorCodeFixProvider : SyntaxEditorBasedCodeFixProvider {
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ImmutableArray`1<string> FixableDiagnosticIds { get; }
    internal CodeFixCategory CodeFixCategory { get; }
    public virtual ImmutableArray`1<string> get_FixableDiagnosticIds();
    internal sealed virtual CodeFixCategory get_CodeFixCategory();
    private static bool IsSupportedDiagnostic(Diagnostic diagnostic);
    public virtual Task RegisterCodeFixesAsync(CodeFixContext context);
    protected virtual Task FixAllAsync(Document document, ImmutableArray`1<Diagnostic> diagnostics, SyntaxEditor editor, CancellationToken cancellationToken);
    private static ExpressionSyntax Rewrite(BinaryExpressionSyntax binary);
    private static IsPatternExpressionSyntax RewriteWorker(BinaryExpressionSyntax binary);
    private static IsPatternExpressionSyntax Rewrite(BinaryExpressionSyntax binary, ExpressionSyntax expr, ExpressionSyntax nullLiteral);
}
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
internal class Microsoft.CodeAnalysis.CSharp.UseIsNullCheck.CSharpUseIsNullCheckForCastAndEqualityOperatorDiagnosticAnalyzer : AbstractBuiltInCodeStyleDiagnosticAnalyzer {
    private static ImmutableDictionary`2<string, string> s_properties;
    private static CSharpUseIsNullCheckForCastAndEqualityOperatorDiagnosticAnalyzer();
    public virtual DiagnosticAnalyzerCategory GetAnalyzerCategory();
    protected virtual void InitializeWorker(AnalysisContext context);
    private void AnalyzeSyntax(SyntaxNodeAnalysisContext context);
    private static bool IsObjectCastAndNullCheck(SemanticModel semanticModel, ExpressionSyntax left, ExpressionSyntax right);
}
[ExportCodeFixProviderAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.CSharp.UseIsNullCheck.CSharpUseIsNullCheckForReferenceEqualsCodeFixProvider : AbstractUseIsNullCheckForReferenceEqualsCodeFixProvider`1<ExpressionSyntax> {
    private static LiteralExpressionSyntax s_nullLiteralExpression;
    private static ConstantPatternSyntax s_nullLiteralPattern;
    private static CSharpUseIsNullCheckForReferenceEqualsCodeFixProvider();
    protected virtual string GetIsNullTitle();
    protected virtual string GetIsNotNullTitle();
    private static SyntaxNode CreateEqualsNullCheck(ExpressionSyntax argument);
    private static SyntaxNode CreateIsNullCheck(ExpressionSyntax argument);
    private static SyntaxNode CreateIsNotNullCheck(ExpressionSyntax argument);
    protected virtual SyntaxNode CreateNullCheck(ExpressionSyntax argument, bool isUnconstrainedGeneric);
    protected virtual SyntaxNode CreateNotNullCheck(ExpressionSyntax argument);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
internal class Microsoft.CodeAnalysis.CSharp.UseIsNullCheck.CSharpUseIsNullCheckForReferenceEqualsDiagnosticAnalyzer : AbstractUseIsNullCheckForReferenceEqualsDiagnosticAnalyzer`1<SyntaxKind> {
    protected virtual bool IsLanguageVersionSupported(ParseOptions options);
    protected virtual bool IsUnconstrainedGenericSupported(ParseOptions options);
    protected virtual ISyntaxFacts GetSyntaxFacts();
}
[ExportCodeFixProviderAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.CSharp.UseLocalFunction.CSharpUseLocalFunctionCodeFixProvider : SyntaxEditorBasedCodeFixProvider {
    private static TypeSyntax s_objectType;
    public ImmutableArray`1<string> FixableDiagnosticIds { get; }
    internal CodeFixCategory CodeFixCategory { get; }
    private static CSharpUseLocalFunctionCodeFixProvider();
    public virtual ImmutableArray`1<string> get_FixableDiagnosticIds();
    internal sealed virtual CodeFixCategory get_CodeFixCategory();
    protected virtual bool IncludeDiagnosticDuringFixAll(Diagnostic diagnostic);
    public virtual Task RegisterCodeFixesAsync(CodeFixContext context);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.CSharp.UseLocalFunction.CSharpUseLocalFunctionCodeFixProvider/<FixAllAsync>d__8")]
protected virtual Task FixAllAsync(Document document, ImmutableArray`1<Diagnostic> diagnostics, SyntaxEditor editor, CancellationToken cancellationToken);
    private static bool MakeStatic(SemanticModel semanticModel, bool makeStaticIfPossible, LocalDeclarationStatementSyntax localDeclaration, CancellationToken cancellationToken);
    private static SyntaxNode ReplaceAnonymousWithLocalFunction(Workspace workspace, SyntaxNode currentRoot, LocalDeclarationStatementSyntax localDeclaration, AnonymousFunctionExpressionSyntax anonymousFunction, IMethodSymbol delegateMethod, ParameterListSyntax parameterList, bool makeStatic);
    private static SyntaxNode ReplaceReferences(Document document, SyntaxNode currentRoot, INamedTypeSymbol delegateType, ParameterListSyntax parameterList, ImmutableArray`1<ExpressionSyntax> references);
    private static LocalFunctionStatementSyntax CreateLocalFunctionStatement(LocalDeclarationStatementSyntax localDeclaration, AnonymousFunctionExpressionSyntax anonymousFunction, IMethodSymbol delegateMethod, ParameterListSyntax parameterList, bool makeStatic);
    private static ParameterListSyntax GenerateParameterList(AnonymousFunctionExpressionSyntax anonymousFunction, IMethodSymbol delegateMethod);
    private static ParameterListSyntax TryGetOrCreateParameterList(AnonymousFunctionExpressionSyntax anonymousFunction);
    private static InvocationExpressionSyntax WithNewParameterNames(InvocationExpressionSyntax invocation, IMethodSymbol method, ParameterListSyntax newParameterList);
    private static int TryDetermineParameterIndex(NameColonSyntax argumentNameColon, IMethodSymbol method);
    private static EqualsValueClauseSyntax GetDefaultValue(IParameterSymbol parameter);
    [CompilerGeneratedAttribute]
internal static ParameterSyntax <GenerateParameterList>g__PromoteParameter|13_2(ParameterSyntax parameterNode, IParameterSymbol delegateParameter);
}
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
internal class Microsoft.CodeAnalysis.CSharp.UseLocalFunction.CSharpUseLocalFunctionDiagnosticAnalyzer : AbstractBuiltInCodeStyleDiagnosticAnalyzer {
    protected virtual void InitializeWorker(AnalysisContext context);
    private void SyntaxNodeAction(SyntaxNodeAnalysisContext syntaxContext, INamedTypeSymbol expressionTypeOpt);
    private static bool CheckForPattern(AnonymousFunctionExpressionSyntax anonymousFunction, LocalDeclarationStatementSyntax& localDeclaration);
    private static bool CheckForSimpleLocalDeclarationPattern(AnonymousFunctionExpressionSyntax anonymousFunction, LocalDeclarationStatementSyntax& localDeclaration);
    private static bool CanReplaceAnonymousWithLocalFunction(SemanticModel semanticModel, INamedTypeSymbol expressionTypeOpt, ISymbol local, BlockSyntax block, AnonymousFunctionExpressionSyntax anonymousFunction, ImmutableArray`1& referenceLocations, CancellationToken cancellationToken);
    private static bool CheckForCastedLocalDeclarationPattern(AnonymousFunctionExpressionSyntax anonymousFunction, LocalDeclarationStatementSyntax& localDeclaration);
    private static bool CheckForLocalDeclarationAndAssignment(AnonymousFunctionExpressionSyntax anonymousFunction, LocalDeclarationStatementSyntax& localDeclaration);
    private static bool CanReplaceDelegateWithLocalFunction(INamedTypeSymbol delegateType, LocalDeclarationStatementSyntax localDeclaration, SemanticModel semanticModel, CancellationToken cancellationToken);
    public virtual DiagnosticAnalyzerCategory GetAnalyzerCategory();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionOrderAttribute]
[ExportCodeRefactoringProviderAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.CSharp.UseNamedArguments.CSharpUseNamedArgumentsCodeRefactoringProvider : AbstractUseNamedArgumentsCodeRefactoringProvider {
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[ExportCodeFixProviderAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.CSharp.UseNullPropagation.CSharpUseNullPropagationCodeFixProvider : AbstractUseNullPropagationCodeFixProvider`10<SyntaxKind, ExpressionSyntax, ConditionalExpressionSyntax, BinaryExpressionSyntax, InvocationExpressionSyntax, MemberAccessExpressionSyntax, ConditionalAccessExpressionSyntax, ElementAccessExpressionSyntax, ElementBindingExpressionSyntax, BracketedArgumentListSyntax> {
    protected virtual ElementBindingExpressionSyntax ElementBindingExpression(BracketedArgumentListSyntax argumentList);
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
internal class Microsoft.CodeAnalysis.CSharp.UseNullPropagation.CSharpUseNullPropagationDiagnosticAnalyzer : AbstractUseNullPropagationDiagnosticAnalyzer`8<SyntaxKind, ExpressionSyntax, ConditionalExpressionSyntax, BinaryExpressionSyntax, InvocationExpressionSyntax, MemberAccessExpressionSyntax, ConditionalAccessExpressionSyntax, ElementAccessExpressionSyntax> {
    protected virtual bool ShouldAnalyze(ParseOptions options);
    protected virtual ISyntaxFacts GetSyntaxFacts();
    protected virtual bool IsInExpressionTree(SemanticModel semanticModel, SyntaxNode node, INamedTypeSymbol expressionTypeOpt, CancellationToken cancellationToken);
    protected virtual bool TryAnalyzePatternCondition(ISyntaxFacts syntaxFacts, SyntaxNode conditionNode, SyntaxNode& conditionPartToCheck, Boolean& isEquals);
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[ExportCodeFixProviderAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.CSharp.UseObjectInitializer.CSharpUseObjectInitializerCodeFixProvider : AbstractUseObjectInitializerCodeFixProvider`7<SyntaxKind, ExpressionSyntax, StatementSyntax, ObjectCreationExpressionSyntax, MemberAccessExpressionSyntax, ExpressionStatementSyntax, VariableDeclaratorSyntax> {
    protected virtual StatementSyntax GetNewStatement(StatementSyntax statement, ObjectCreationExpressionSyntax objectCreation, ImmutableArray`1<Match`4<ExpressionSyntax, StatementSyntax, MemberAccessExpressionSyntax, ExpressionStatementSyntax>> matches);
    private static ObjectCreationExpressionSyntax GetNewObjectCreation(ObjectCreationExpressionSyntax objectCreation, ImmutableArray`1<Match`4<ExpressionSyntax, StatementSyntax, MemberAccessExpressionSyntax, ExpressionStatementSyntax>> matches);
    private static SeparatedSyntaxList`1<ExpressionSyntax> CreateExpressions(ImmutableArray`1<Match`4<ExpressionSyntax, StatementSyntax, MemberAccessExpressionSyntax, ExpressionStatementSyntax>> matches);
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
internal class Microsoft.CodeAnalysis.CSharp.UseObjectInitializer.CSharpUseObjectInitializerDiagnosticAnalyzer : AbstractUseObjectInitializerDiagnosticAnalyzer`7<SyntaxKind, ExpressionSyntax, StatementSyntax, ObjectCreationExpressionSyntax, MemberAccessExpressionSyntax, ExpressionStatementSyntax, VariableDeclaratorSyntax> {
    protected bool FadeOutOperatorToken { get; }
    protected virtual bool get_FadeOutOperatorToken();
    protected virtual bool AreObjectInitializersSupported(SyntaxNodeAnalysisContext context);
    protected virtual ISyntaxFacts GetSyntaxFacts();
    protected virtual bool IsValidContainingStatement(StatementSyntax node);
}
internal static class Microsoft.CodeAnalysis.CSharp.UseObjectInitializer.UseInitializerHelpers : object {
    public static ObjectCreationExpressionSyntax GetNewObjectCreation(ObjectCreationExpressionSyntax objectCreation, SeparatedSyntaxList`1<ExpressionSyntax> expressions);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal abstract class Microsoft.CodeAnalysis.CSharp.UsePatternCombinators.AnalyzedPattern : object {
    public IOperation Target;
    private AnalyzedPattern(IOperation target);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal static class Microsoft.CodeAnalysis.CSharp.UsePatternCombinators.CSharpUsePatternCombinatorsAnalyzer : object {
    public static AnalyzedPattern Analyze(IOperation operation);
    private static AnalyzedPattern ParsePattern(IOperation operation);
    private static AnalyzedPattern ParseBinaryPattern(IBinaryOperation op, bool isDisjunctive, SyntaxToken token);
    private static ConstantResult DetermineConstant(IBinaryOperation op);
    private static AnalyzedPattern ParseRelationalPattern(IBinaryOperation op);
    private static AnalyzedPattern ParseConstantPattern(IBinaryOperation op);
    private static bool IsRelationalOperator(BinaryOperatorKind operatorKind);
    public static BinaryOperatorKind Flip(BinaryOperatorKind operatorKind);
    private static bool IsConstant(IOperation operation);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExportCodeFixProviderAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.CSharp.UsePatternCombinators.CSharpUsePatternCombinatorsCodeFixProvider : SyntaxEditorBasedCodeFixProvider {
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ImmutableArray`1<string> FixableDiagnosticIds { get; }
    internal CodeFixCategory CodeFixCategory { get; }
    private static SyntaxKind MapToSyntaxKind(BinaryOperatorKind kind);
    public virtual ImmutableArray`1<string> get_FixableDiagnosticIds();
    internal sealed virtual CodeFixCategory get_CodeFixCategory();
    public virtual Task RegisterCodeFixesAsync(CodeFixContext context);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.CSharp.UsePatternCombinators.CSharpUsePatternCombinatorsCodeFixProvider/<FixAllAsync>d__7")]
protected virtual Task FixAllAsync(Document document, ImmutableArray`1<Diagnostic> diagnostics, SyntaxEditor editor, CancellationToken cancellationToken);
    private static PatternSyntax AsPatternSyntax(AnalyzedPattern pattern);
    private static ExpressionSyntax AsExpressionSyntax(ExpressionSyntax expr, AnalyzedPattern p);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
internal class Microsoft.CodeAnalysis.CSharp.UsePatternCombinators.CSharpUsePatternCombinatorsDiagnosticAnalyzer : AbstractBuiltInCodeStyleDiagnosticAnalyzer {
    protected virtual void InitializeWorker(AnalysisContext context);
    private void AnalyzeNode(SyntaxNodeAnalysisContext context);
    private static bool HasIllegalPatternVariables(AnalyzedPattern pattern, bool permitDesignations, bool isTopLevel);
    private static bool IsTopmostExpression(ExpressionSyntax node);
    private static bool IsTrivial(AnalyzedPattern pattern);
    public virtual DiagnosticAnalyzerCategory GetAnalyzerCategory();
}
[ExportCodeFixProviderAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.CSharp.UsePatternMatching.CSharpAsAndNullCheckCodeFixProvider : SyntaxEditorBasedCodeFixProvider {
    public ImmutableArray`1<string> FixableDiagnosticIds { get; }
    internal CodeFixCategory CodeFixCategory { get; }
    public virtual ImmutableArray`1<string> get_FixableDiagnosticIds();
    internal sealed virtual CodeFixCategory get_CodeFixCategory();
    public virtual Task RegisterCodeFixesAsync(CodeFixContext context);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.CSharp.UsePatternMatching.CSharpAsAndNullCheckCodeFixProvider/<FixAllAsync>d__6")]
protected virtual Task FixAllAsync(Document document, ImmutableArray`1<Diagnostic> diagnostics, SyntaxEditor editor, CancellationToken cancellationToken);
    private static void AddEdits(SyntaxEditor editor, Diagnostic diagnostic, LanguageVersion languageVersion, Action`1<StatementSyntax> removeStatement, CancellationToken cancellationToken);
    private static ExpressionSyntax GetCondition(LanguageVersion languageVersion, ExpressionSyntax comparison, BinaryExpressionSyntax asExpression, DeclarationPatternSyntax declarationPattern);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
internal class Microsoft.CodeAnalysis.CSharp.UsePatternMatching.CSharpAsAndNullCheckDiagnosticAnalyzer : AbstractBuiltInCodeStyleDiagnosticAnalyzer {
    protected virtual void InitializeWorker(AnalysisContext context);
    private void SyntaxNodeAction(SyntaxNodeAnalysisContext syntaxContext);
    [NullableContextAttribute("2")]
private static bool TryGetTypeCheckParts(SemanticModel semanticModel, SyntaxNode operand, VariableDeclaratorSyntax& declarator, BinaryExpressionSyntax& asExpression, ILocalSymbol& localSymbol);
    private static bool TryFindVariableDeclarator(SemanticModel semanticModel, IdentifierNameSyntax identifier, ILocalSymbol& localSymbol, VariableDeclaratorSyntax& declarator);
    private static ExpressionSyntax GetNullCheckOperand(ExpressionSyntax left, SyntaxKind comparisonKind, SyntaxNode right);
    public virtual DiagnosticAnalyzerCategory GetAnalyzerCategory();
}
[ExportCodeFixProviderAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.CSharp.UsePatternMatching.CSharpIsAndCastCheckCodeFixProvider : SyntaxEditorBasedCodeFixProvider {
    public ImmutableArray`1<string> FixableDiagnosticIds { get; }
    internal CodeFixCategory CodeFixCategory { get; }
    public virtual ImmutableArray`1<string> get_FixableDiagnosticIds();
    internal sealed virtual CodeFixCategory get_CodeFixCategory();
    public virtual Task RegisterCodeFixesAsync(CodeFixContext context);
    protected virtual Task FixAllAsync(Document document, ImmutableArray`1<Diagnostic> diagnostics, SyntaxEditor editor, CancellationToken cancellationToken);
    private static void AddEdits(SyntaxEditor editor, Diagnostic diagnostic, CancellationToken cancellationToken);
    private static IfStatementSyntax GetUpdatedIfStatement(IsPatternExpressionSyntax updatedCondition, ImmutableArray`1<SyntaxTrivia> trivia, IfStatementSyntax originalIf, IfStatementSyntax currentIf);
}
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
internal class Microsoft.CodeAnalysis.CSharp.UsePatternMatching.CSharpIsAndCastCheckDiagnosticAnalyzer : AbstractBuiltInCodeStyleDiagnosticAnalyzer {
    public static CSharpIsAndCastCheckDiagnosticAnalyzer Instance;
    private static CSharpIsAndCastCheckDiagnosticAnalyzer();
    protected virtual void InitializeWorker(AnalysisContext context);
    private void SyntaxNodeAction(SyntaxNodeAnalysisContext syntaxContext);
    public static bool TryGetPatternPieces(BinaryExpressionSyntax isExpression, IfStatementSyntax& ifStatement, LocalDeclarationStatementSyntax& localDeclarationStatement, VariableDeclaratorSyntax& declarator, CastExpressionSyntax& castExpression);
    private static bool ContainsVariableDeclaration(SyntaxNode scope, VariableDeclaratorSyntax variable);
    public virtual DiagnosticAnalyzerCategory GetAnalyzerCategory();
}
[ExportCodeFixProviderAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.CSharp.UsePatternMatching.CSharpIsAndCastCheckWithoutNameCodeFixProvider : SyntaxEditorBasedCodeFixProvider {
    public ImmutableArray`1<string> FixableDiagnosticIds { get; }
    internal CodeFixCategory CodeFixCategory { get; }
    public virtual ImmutableArray`1<string> get_FixableDiagnosticIds();
    internal sealed virtual CodeFixCategory get_CodeFixCategory();
    public virtual Task RegisterCodeFixesAsync(CodeFixContext context);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.CSharp.UsePatternMatching.CSharpIsAndCastCheckWithoutNameCodeFixProvider/<FixAllAsync>d__6")]
protected virtual Task FixAllAsync(Document document, ImmutableArray`1<Diagnostic> diagnostics, SyntaxEditor editor, CancellationToken cancellationToken);
}
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.CSharp.UsePatternMatching.CSharpIsAndCastCheckWithoutNameDiagnosticAnalyzer : AbstractBuiltInCodeStyleDiagnosticAnalyzer {
    private static string CS0165;
    private static SyntaxAnnotation s_referenceAnnotation;
    public static CSharpIsAndCastCheckWithoutNameDiagnosticAnalyzer Instance;
    private static CSharpIsAndCastCheckWithoutNameDiagnosticAnalyzer();
    public virtual DiagnosticAnalyzerCategory GetAnalyzerCategory();
    protected virtual void InitializeWorker(AnalysisContext context);
    private void SyntaxNodeAction(SyntaxNodeAnalysisContext context);
    public ValueTuple`2<HashSet`1<CastExpressionSyntax>, string> AnalyzeExpression(SemanticModel semanticModel, BinaryExpressionSyntax isExpression, CancellationToken cancellationToken);
    private static bool ReplacementCausesError(SemanticModel updatedSemanticModel, CancellationToken cancellationToken);
    public static SemanticModel ReplaceMatches(SemanticModel semanticModel, BinaryExpressionSyntax isExpression, string localName, HashSet`1<CastExpressionSyntax> matches, CancellationToken cancellationToken);
    private static SyntaxNode GetContainer(BinaryExpressionSyntax isExpression);
    private void AddMatches(SyntaxNode node, ExpressionSyntax expr, TypeSyntax type, HashSet`1<CastExpressionSyntax> matches);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExportCodeFixProviderAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.CSharp.UsePatternMatching.CSharpUseNotPatternCodeFixProvider : SyntaxEditorBasedCodeFixProvider {
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ImmutableArray`1<string> FixableDiagnosticIds { get; }
    internal CodeFixCategory CodeFixCategory { get; }
    public virtual ImmutableArray`1<string> get_FixableDiagnosticIds();
    internal sealed virtual CodeFixCategory get_CodeFixCategory();
    public virtual Task RegisterCodeFixesAsync(CodeFixContext context);
    protected virtual Task FixAllAsync(Document document, ImmutableArray`1<Diagnostic> diagnostics, SyntaxEditor editor, CancellationToken cancellationToken);
    private static void ProcessDiagnostic(SyntaxEditor editor, Diagnostic diagnostic, CancellationToken cancellationToken);
}
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
internal class Microsoft.CodeAnalysis.CSharp.UsePatternMatching.CSharpUseNotPatternDiagnosticAnalyzer : AbstractBuiltInCodeStyleDiagnosticAnalyzer {
    public virtual DiagnosticAnalyzerCategory GetAnalyzerCategory();
    [NullableContextAttribute("1")]
protected virtual void InitializeWorker(AnalysisContext context);
    private void SyntaxNodeAction(SyntaxNodeAnalysisContext syntaxContext);
}
[ExportCodeFixProviderAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.CSharp.UseSimpleUsingStatement.UseSimpleUsingStatementCodeFixProvider : SyntaxEditorBasedCodeFixProvider {
    [CompilerGeneratedAttribute]
private ImmutableArray`1<string> <FixableDiagnosticIds>k__BackingField;
    public ImmutableArray`1<string> FixableDiagnosticIds { get; }
    internal CodeFixCategory CodeFixCategory { get; }
    [CompilerGeneratedAttribute]
public virtual ImmutableArray`1<string> get_FixableDiagnosticIds();
    internal sealed virtual CodeFixCategory get_CodeFixCategory();
    public virtual Task RegisterCodeFixesAsync(CodeFixContext context);
    protected virtual Task FixAllAsync(Document document, ImmutableArray`1<Diagnostic> diagnostics, SyntaxEditor editor, CancellationToken cancellationToken);
    private static SyntaxNode RewriteBlock(BlockSyntax originalBlock, BlockSyntax currentBlock, ISet`1<UsingStatementSyntax> topmostUsingStatements);
    private static IEnumerable`1<StatementSyntax> Expand(UsingStatementSyntax usingStatement);
    private static SyntaxTriviaList Expand(List`1<StatementSyntax> result, UsingStatementSyntax usingStatement);
    private static LocalDeclarationStatementSyntax Convert(UsingStatementSyntax usingStatement);
}
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
internal class Microsoft.CodeAnalysis.CSharp.UseSimpleUsingStatement.UseSimpleUsingStatementDiagnosticAnalyzer : AbstractBuiltInCodeStyleDiagnosticAnalyzer {
    public virtual DiagnosticAnalyzerCategory GetAnalyzerCategory();
    protected virtual void InitializeWorker(AnalysisContext context);
    private void AnalyzeSyntax(SyntaxNodeAnalysisContext context);
    private static bool CausesVariableCollision(SemanticModel semanticModel, BlockSyntax parentBlock, UsingStatementSyntax outermostUsing, UsingStatementSyntax innermostUsing, CancellationToken cancellationToken);
    private static bool DeclaredLocalCausesCollision(ILookup`2<string, ISymbol> symbolNameToExistingSymbol, ImmutableArray`1<ILocalSymbol> locals);
    private static bool PreservesSemantics(BlockSyntax parentBlock, UsingStatementSyntax outermostUsing, UsingStatementSyntax innermostUsing);
    private static bool UsingStatementDoesNotInvolveJumps(SyntaxList`1<StatementSyntax> parentStatements, int index, UsingStatementSyntax innermostUsing);
    private static bool IsGotoOrLabeledStatement(StatementSyntax priorStatement);
    private static bool UsingValueDoesNotLeakToFollowingStatements(SyntaxList`1<StatementSyntax> statements, int index);
}
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
internal class Microsoft.CodeAnalysis.CSharp.UseThrowExpression.CSharpUseThrowExpressionDiagnosticAnalyzer : AbstractUseThrowExpressionDiagnosticAnalyzer {
    protected virtual bool IsSupported(ParseOptions options);
    protected virtual bool IsInExpressionTree(SemanticModel semanticModel, SyntaxNode node, INamedTypeSymbol expressionTypeOpt, CancellationToken cancellationToken);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
internal class Microsoft.CodeAnalysis.CSharp.ValidateFormatString.CSharpValidateFormatStringDiagnosticAnalyzer : AbstractValidateFormatStringDiagnosticAnalyzer`1<SyntaxKind> {
    protected virtual ISyntaxFacts GetSyntaxFacts();
    protected virtual SyntaxNode TryGetMatchingNamedArgument(SeparatedSyntaxList`1<SyntaxNode> arguments, string searchArgumentName);
    protected virtual SyntaxNode GetArgumentExpression(SyntaxNode syntaxNode);
}
internal class Microsoft.CodeAnalysis.CSharp.Wrapping.BinaryExpression.CSharpBinaryExpressionWrapper : AbstractBinaryExpressionWrapper`1<BinaryExpressionSyntax> {
    protected virtual SyntaxTriviaList GetNewLineBeforeOperatorTrivia(SyntaxTriviaList newLine);
}
internal class Microsoft.CodeAnalysis.CSharp.Wrapping.ChainedExpression.CSharpChainedExpressionWrapper : AbstractChainedExpressionWrapper`2<NameSyntax, BaseArgumentListSyntax> {
    protected virtual SyntaxTriviaList GetNewLineBeforeOperatorTrivia(SyntaxTriviaList newLine);
}
[ExportCodeRefactoringProviderAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.CSharp.Wrapping.CSharpWrappingCodeRefactoringProvider : AbstractWrappingCodeRefactoringProvider {
    private static ImmutableArray`1<ISyntaxWrapper> s_wrappers;
    private static CSharpWrappingCodeRefactoringProvider();
}
internal abstract class Microsoft.CodeAnalysis.CSharp.Wrapping.SeparatedSyntaxList.AbstractCSharpSeparatedSyntaxListWrapper`2 : AbstractSeparatedSyntaxListWrapper`2<TListSyntax, TListItemSyntax> {
}
internal class Microsoft.CodeAnalysis.CSharp.Wrapping.SeparatedSyntaxList.CSharpArgumentWrapper : AbstractCSharpSeparatedSyntaxListWrapper`2<BaseArgumentListSyntax, ArgumentSyntax> {
    protected string Align_wrapped_items { get; }
    protected string Indent_all_items { get; }
    protected string Indent_wrapped_items { get; }
    protected string Unwrap_all_items { get; }
    protected string Unwrap_and_indent_all_items { get; }
    protected string Unwrap_list { get; }
    protected string Wrap_every_item { get; }
    protected string Wrap_long_list { get; }
    protected virtual string get_Align_wrapped_items();
    protected virtual string get_Indent_all_items();
    protected virtual string get_Indent_wrapped_items();
    protected virtual string get_Unwrap_all_items();
    protected virtual string get_Unwrap_and_indent_all_items();
    protected virtual string get_Unwrap_list();
    protected virtual string get_Wrap_every_item();
    protected virtual string get_Wrap_long_list();
    protected virtual SeparatedSyntaxList`1<ArgumentSyntax> GetListItems(BaseArgumentListSyntax listSyntax);
    protected virtual BaseArgumentListSyntax TryGetApplicableList(SyntaxNode node);
    protected virtual bool PositionIsApplicable(SyntaxNode root, int position, SyntaxNode declaration, BaseArgumentListSyntax listSyntax);
    private static ExpressionSyntax TryGetInvokedName(ExpressionSyntax expr);
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal class Microsoft.CodeAnalysis.CSharp.Wrapping.SeparatedSyntaxList.CSharpParameterWrapper : AbstractCSharpSeparatedSyntaxListWrapper`2<BaseParameterListSyntax, ParameterSyntax> {
    protected string Align_wrapped_items { get; }
    protected string Indent_all_items { get; }
    protected string Indent_wrapped_items { get; }
    protected string Unwrap_all_items { get; }
    protected string Unwrap_and_indent_all_items { get; }
    protected string Unwrap_list { get; }
    protected string Wrap_every_item { get; }
    protected string Wrap_long_list { get; }
    protected virtual string get_Align_wrapped_items();
    protected virtual string get_Indent_all_items();
    protected virtual string get_Indent_wrapped_items();
    protected virtual string get_Unwrap_all_items();
    protected virtual string get_Unwrap_and_indent_all_items();
    protected virtual string get_Unwrap_list();
    protected virtual string get_Wrap_every_item();
    protected virtual string get_Wrap_long_list();
    protected virtual SeparatedSyntaxList`1<ParameterSyntax> GetListItems(BaseParameterListSyntax listSyntax);
    protected virtual BaseParameterListSyntax TryGetApplicableList(SyntaxNode node);
    protected virtual bool PositionIsApplicable(SyntaxNode root, int position, SyntaxNode declaration, BaseParameterListSyntax listSyntax);
}
[ExportCodeFixProviderAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
[SharedAttribute]
[ExtensionOrderAttribute]
internal class Microsoft.CodeAnalysis.DiagnosticComments.CodeFixes.CSharpAddDocCommentNodesCodeFixProvider : AbstractAddDocCommentNodesCodeFixProvider`4<XmlElementSyntax, XmlNameAttributeSyntax, XmlTextSyntax, MemberDeclarationSyntax> {
    private static string CS1573;
    [CompilerGeneratedAttribute]
private ImmutableArray`1<string> <FixableDiagnosticIds>k__BackingField;
    [CompilerGeneratedAttribute]
private string <NodeName>k__BackingField;
    public ImmutableArray`1<string> FixableDiagnosticIds { get; }
    protected string NodeName { get; }
    [CompilerGeneratedAttribute]
public virtual ImmutableArray`1<string> get_FixableDiagnosticIds();
    [CompilerGeneratedAttribute]
protected virtual string get_NodeName();
    protected virtual List`1<XmlNameAttributeSyntax> GetNameAttributes(XmlElementSyntax node);
    protected virtual string GetValueFromNameAttribute(XmlNameAttributeSyntax attribute);
    protected virtual SyntaxNode TryGetDocCommentNode(SyntaxTriviaList leadingTrivia);
    protected virtual string GetXmlElementLocalName(XmlElementSyntax element);
    protected virtual List`1<string> GetParameterNames(MemberDeclarationSyntax member);
    protected virtual XmlElementSyntax GetNewNode(string parameterName, bool isFirstNodeInComment);
    [CompilerGeneratedAttribute]
private bool <TryGetDocCommentNode>b__10_1(XmlElementSyntax element);
}
[ExportCodeFixProviderAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
[SharedAttribute]
[ExtensionOrderAttribute]
internal class Microsoft.CodeAnalysis.DiagnosticComments.CodeFixes.CSharpRemoveDocCommentNodeCodeFixProvider : AbstractRemoveDocCommentNodeCodeFixProvider`2<XmlElementSyntax, XmlTextSyntax> {
    private static string CS1571;
    private static string CS1572;
    private static string CS1710;
    [CompilerGeneratedAttribute]
private ImmutableArray`1<string> <FixableDiagnosticIds>k__BackingField;
    [CompilerGeneratedAttribute]
private string <DocCommentSignifierToken>k__BackingField;
    public ImmutableArray`1<string> FixableDiagnosticIds { get; }
    protected string DocCommentSignifierToken { get; }
    [CompilerGeneratedAttribute]
public virtual ImmutableArray`1<string> get_FixableDiagnosticIds();
    [CompilerGeneratedAttribute]
protected virtual string get_DocCommentSignifierToken();
    protected virtual SyntaxTriviaList GetRevisedDocCommentTrivia(string docCommentText);
    protected virtual SyntaxTokenList GetTextTokens(XmlTextSyntax xmlText);
    protected virtual bool IsXmlWhitespaceToken(SyntaxToken token);
    protected virtual bool IsXmlNewLineToken(SyntaxToken token);
    private static bool IsWhitespace(string text);
}
[ExportLanguageServiceAttribute("Microsoft.CodeAnalysis.CommentSelection.ICommentSelectionService", "C#", "Default")]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.Editor.CSharp.CommentSelection.CSharpCommentSelectionService : AbstractCommentSelectionService {
    public string SingleLineCommentString { get; }
    public bool SupportsBlockComment { get; }
    public string BlockCommentStartString { get; }
    public string BlockCommentEndString { get; }
    public virtual string get_SingleLineCommentString();
    public virtual bool get_SupportsBlockComment();
    public virtual string get_BlockCommentStartString();
    public virtual string get_BlockCommentEndString();
}
[ExportLanguageServiceAttribute("Microsoft.CodeAnalysis.LanguageServices.IAnonymousTypeDisplayService", "C#", "Default")]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.Editor.CSharp.LanguageServices.CSharpAnonymousTypeDisplayService : AbstractAnonymousTypeDisplayService {
    public virtual ImmutableArray`1<SymbolDisplayPart> GetAnonymousTypeParts(INamedTypeSymbol anonymousType, SemanticModel semanticModel, int position);
}
internal class Microsoft.CodeAnalysis.Editor.CSharp.LanguageServices.CSharpSymbolDisplayService : AbstractSymbolDisplayService {
    public CSharpSymbolDisplayService(HostLanguageServices provider);
    protected virtual AbstractSymbolDescriptionBuilder CreateDescriptionBuilder(Workspace workspace, SemanticModel semanticModel, int position, CancellationToken cancellationToken);
}
[ExportLanguageServiceFactoryAttribute("Microsoft.CodeAnalysis.LanguageServices.ISymbolDisplayService", "C#", "Default")]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.Editor.CSharp.LanguageServices.CSharpSymbolDisplayServiceFactory : object {
    public sealed virtual ILanguageService CreateLanguageService(HostLanguageServices provider);
}
[CompilerGeneratedAttribute]
[EmbeddedAttribute]
internal class Microsoft.CodeAnalysis.EmbeddedAttribute : Attribute {
}
[NullableContextAttribute("1")]
internal interface Microsoft.CodeAnalysis.ExternalAccess.Pythia.Api.IPythiaSignatureHelpProviderImplementation {
    public abstract virtual Task`1<ValueTuple`2<ImmutableArray`1<PythiaSignatureHelpItemWrapper>, Nullable`1<int>>> GetMethodGroupItemsAndSelectionAsync(ImmutableArray`1<IMethodSymbol> accessibleMethods, Document document, InvocationExpressionSyntax invocationExpression, SemanticModel semanticModel, SymbolInfo currentSymbol, CancellationToken cancellationToken);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[IsReadOnlyAttribute]
internal class Microsoft.CodeAnalysis.ExternalAccess.Pythia.Api.PythiaSignatureHelpItemWrapper : ValueType {
    internal SignatureHelpItem UnderlyingObject;
    public PythiaSignatureHelpItemWrapper(SignatureHelpItem underlyingObject);
    public static SymbolDisplayPart CreateTextDisplayPart(string text);
    public static PythiaSignatureHelpItemWrapper CreateFromMethodGroupMethod(Document document, IMethodSymbol method, int position, SemanticModel semanticModel, IList`1<SymbolDisplayPart> descriptionParts);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExportSignatureHelpProviderAttribute("PythiaSignatureHelpProvider", "C#")]
[SharedAttribute]
[ExtensionOrderAttribute]
internal class Microsoft.CodeAnalysis.ExternalAccess.Pythia.PythiaSignatureHelpProvider : InvocationExpressionSignatureHelpProviderBase {
    private Lazy`1<IPythiaSignatureHelpProviderImplementation> _lazyImplementation;
    [ImportingConstructorAttribute]
[ObsoleteAttribute("This exported object must be obtained through the MEF export provider.", "True")]
public PythiaSignatureHelpProvider(Lazy`1<IPythiaSignatureHelpProviderImplementation> implementation);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.ExternalAccess.Pythia.PythiaSignatureHelpProvider/<GetMethodGroupItemsAndSelectionAsync>d__2")]
internal virtual Task`1<ValueTuple`2<ImmutableArray`1<SignatureHelpItem>, Nullable`1<int>>> GetMethodGroupItemsAndSelectionAsync(ImmutableArray`1<IMethodSymbol> accessibleMethods, Document document, InvocationExpressionSyntax invocationExpression, SemanticModel semanticModel, SymbolInfo currentSymbol, CancellationToken cancellationToken);
}
[CompilerGeneratedAttribute]
[EmbeddedAttribute]
internal class System.Runtime.CompilerServices.IsReadOnlyAttribute : Attribute {
}
[CompilerGeneratedAttribute]
[EmbeddedAttribute]
[AttributeUsageAttribute("27524")]
internal class System.Runtime.CompilerServices.NullableAttribute : Attribute {
    public Byte[] NullableFlags;
    public NullableAttribute(byte );
    public NullableAttribute(Byte[] );
}
[CompilerGeneratedAttribute]
[EmbeddedAttribute]
[AttributeUsageAttribute("5196")]
internal class System.Runtime.CompilerServices.NullableContextAttribute : Attribute {
    public byte Flag;
    public NullableContextAttribute(byte );
}
