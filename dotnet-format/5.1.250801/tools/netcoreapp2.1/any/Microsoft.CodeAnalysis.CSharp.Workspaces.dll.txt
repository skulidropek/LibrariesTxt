internal enum Microsoft.CodeAnalysis.CodeStyle.PreferBracesPreference : Enum {
    public int value__;
    public static PreferBracesPreference None;
    public static PreferBracesPreference Always;
    public static PreferBracesPreference WhenMultiline;
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[ExportLanguageServiceAttribute("Microsoft.CodeAnalysis.AddImports.IAddImportsService", "C#", "Default")]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.CSharp.AddImports.CSharpAddImportsService : AbstractAddImportsService`4<CompilationUnitSyntax, NamespaceDeclarationSyntax, UsingDirectiveSyntax, ExternAliasDirectiveSyntax> {
    protected virtual ImmutableArray`1<SyntaxNode> GetGlobalImports(Compilation compilation, SyntaxGenerator generator);
    protected virtual SyntaxNode GetAlias(UsingDirectiveSyntax usingOrAlias);
    protected virtual bool IsStaticUsing(UsingDirectiveSyntax usingOrAlias);
    protected virtual SyntaxNode Rewrite(ExternAliasDirectiveSyntax[] externAliases, UsingDirectiveSyntax[] usingDirectives, UsingDirectiveSyntax[] staticUsingDirectives, UsingDirectiveSyntax[] aliasDirectives, SyntaxNode externContainer, SyntaxNode usingContainer, SyntaxNode staticUsingContainer, SyntaxNode aliasContainer, bool placeSystemNamespaceFirst, bool allowInHiddenRegions, SyntaxNode root, CancellationToken cancellationToken);
    protected virtual SyntaxList`1<UsingDirectiveSyntax> GetUsingsAndAliases(SyntaxNode node);
    protected virtual SyntaxList`1<ExternAliasDirectiveSyntax> GetExterns(SyntaxNode node);
    protected virtual bool IsEquivalentImport(SyntaxNode a, SyntaxNode b);
}
[ExportLanguageServiceAttribute("Microsoft.CodeAnalysis.CaseCorrection.ICaseCorrectionService", "C#", "Default")]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.CSharp.CaseCorrection.CSharpCaseCorrectionService : AbstractCaseCorrectionService {
    [NullableContextAttribute("1")]
protected virtual void AddReplacements(SemanticModel semanticModel, SyntaxNode root, ImmutableArray`1<TextSpan> spans, Workspace workspace, ConcurrentDictionary`2<SyntaxToken, SyntaxToken> replacements, CancellationToken cancellationToken);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
internal static class Microsoft.CodeAnalysis.CSharp.Classification.ClassificationHelpers : object {
    private static string FromKeyword;
    private static string VarKeyword;
    private static string UnmanagedKeyword;
    private static string NotNullKeyword;
    private static string DynamicKeyword;
    private static string AwaitKeyword;
    [NullableContextAttribute("2")]
public static string GetClassification(SyntaxToken token);
    private static bool IsControlKeyword(SyntaxToken token);
    private static bool IsControlKeywordKind(SyntaxKind kind);
    private static bool IsControlStatementKind(SyntaxKind kind);
    private static bool IsStringToken(SyntaxToken token);
    private static bool IsVerbatimStringToken(SyntaxToken token);
    [NullableContextAttribute("2")]
private static string GetClassificationForIdentifier(SyntaxToken token);
    private static string GetClassificationTypeForConstructorOrDestructorParent(SyntaxNode parentNode);
    private static bool IsNamespaceName(IdentifierNameSyntax identifierSyntax);
    public static bool IsStaticallyDeclared(SyntaxToken token);
    private static bool IsExtensionMethod(MethodDeclarationSyntax methodDeclaration);
    [NullableContextAttribute("2")]
private static string GetClassificationForTypeDeclarationIdentifier(SyntaxToken identifier);
    private static string GetClassificationForPunctuation(SyntaxToken token);
    [ExtensionAttribute]
private static bool IsOperator(SyntaxKind kind);
    private static bool IsActualContextualKeyword(SyntaxToken token);
    internal static void AddLexicalClassifications(SourceText text, TextSpan textSpan, ArrayBuilder`1<ClassifiedSpan> result, CancellationToken cancellationToken);
    internal static ClassifiedSpan AdjustStaleClassification(SourceText rawText, ClassifiedSpan classifiedSpan);
}
internal class Microsoft.CodeAnalysis.CSharp.Classification.Classifiers.DiscardSyntaxClassifier : AbstractSyntaxClassifier {
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private ImmutableArray`1<Type> <SyntaxNodeTypes>k__BackingField;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ImmutableArray`1<Type> SyntaxNodeTypes { get; }
    [CompilerGeneratedAttribute]
public virtual ImmutableArray`1<Type> get_SyntaxNodeTypes();
    [NullableContextAttribute("1")]
public virtual void AddClassifications(Workspace workspace, SyntaxNode syntax, SemanticModel semanticModel, ArrayBuilder`1<ClassifiedSpan> result, CancellationToken cancellationToken);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.CodeAnalysis.CSharp.Classification.Classifiers.NameSyntaxClassifier : AbstractNameSyntaxClassifier {
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private ImmutableArray`1<Type> <SyntaxNodeTypes>k__BackingField;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ImmutableArray`1<Type> SyntaxNodeTypes { get; }
    public virtual void AddClassifications(Workspace workspace, SyntaxNode syntax, SemanticModel semanticModel, ArrayBuilder`1<ClassifiedSpan> result, CancellationToken cancellationToken);
    [CompilerGeneratedAttribute]
public virtual ImmutableArray`1<Type> get_SyntaxNodeTypes();
    protected virtual Nullable`1<int> GetRightmostNameArity(SyntaxNode node);
    protected virtual bool IsParentAnAttribute(SyntaxNode node);
    private void ClassifyTypeSyntax(NameSyntax name, SemanticModel semanticModel, ArrayBuilder`1<ClassifiedSpan> result, CancellationToken cancellationToken);
    private bool TryClassifySymbol(NameSyntax name, SymbolInfo symbolInfo, SemanticModel semanticModel, ArrayBuilder`1<ClassifiedSpan> result, CancellationToken cancellationToken);
    private static bool TryClassifyAmbiguousSymbol(NameSyntax name, SymbolInfo symbolInfo, SemanticModel semanticModel, ArrayBuilder`1<ClassifiedSpan> result, CancellationToken cancellationToken);
    private static bool TryClassifySymbol(NameSyntax name, ISymbol symbol, SemanticModel semanticModel, CancellationToken cancellationToken, ClassifiedSpan& classifiedSpan);
    private static string GetClassificationForField(IFieldSymbol fieldSymbol);
    private static string GetClassificationForLocal(ILocalSymbol localSymbol);
    private static string GetClassificationForMethod(IMethodSymbol methodSymbol);
    private static bool IsInVarContext(NameSyntax name);
    private static bool TryClassifyFromIdentifier(NameSyntax name, SymbolInfo symbolInfo, ArrayBuilder`1<ClassifiedSpan> result);
    private static bool TryClassifyValueIdentifier(NameSyntax name, SymbolInfo symbolInfo, ArrayBuilder`1<ClassifiedSpan> result);
    private static bool TryClassifyNameOfIdentifier(NameSyntax name, SymbolInfo symbolInfo, ArrayBuilder`1<ClassifiedSpan> result);
    private static bool IsSymbolWithName(ISymbol symbol, string name);
}
internal class Microsoft.CodeAnalysis.CSharp.Classification.Classifiers.SyntaxTokenClassifier : AbstractSyntaxClassifier {
    [CompilerGeneratedAttribute]
private ImmutableArray`1<int> <SyntaxTokenKinds>k__BackingField;
    [NullableAttribute("1")]
private static Func`2<ITypeSymbol, bool> s_shouldInclude;
    public ImmutableArray`1<int> SyntaxTokenKinds { get; }
    private static SyntaxTokenClassifier();
    [CompilerGeneratedAttribute]
public virtual ImmutableArray`1<int> get_SyntaxTokenKinds();
    [NullableContextAttribute("1")]
public virtual void AddClassifications(Workspace workspace, SyntaxToken lessThanToken, SemanticModel semanticModel, ArrayBuilder`1<ClassifiedSpan> result, CancellationToken cancellationToken);
    private static bool CouldBeGenericType(SyntaxToken identifier);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.CodeAnalysis.CSharp.Classification.Classifiers.UsingDirectiveSyntaxClassifier : AbstractSyntaxClassifier {
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private ImmutableArray`1<Type> <SyntaxNodeTypes>k__BackingField;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ImmutableArray`1<Type> SyntaxNodeTypes { get; }
    public virtual void AddClassifications(Workspace workspace, SyntaxNode syntax, SemanticModel semanticModel, ArrayBuilder`1<ClassifiedSpan> result, CancellationToken cancellationToken);
    [CompilerGeneratedAttribute]
public virtual ImmutableArray`1<Type> get_SyntaxNodeTypes();
    private static void ClassifyUsingDirectiveSyntax(UsingDirectiveSyntax usingDirective, SemanticModel semanticModel, ArrayBuilder`1<ClassifiedSpan> result, CancellationToken cancellationToken);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExportLanguageServiceAttribute("Microsoft.CodeAnalysis.Classification.IClassificationService", "C#", "Default")]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.CSharp.Classification.CSharpEditorClassificationService : AbstractClassificationService {
    public virtual void AddLexicalClassifications(SourceText text, TextSpan textSpan, ArrayBuilder`1<ClassifiedSpan> result, CancellationToken cancellationToken);
    public virtual ClassifiedSpan AdjustStaleClassification(SourceText text, ClassifiedSpan classifiedSpan);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.CodeAnalysis.CSharp.Classification.CSharpSyntaxClassificationService : AbstractSyntaxClassificationService {
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private ImmutableArray`1<ISyntaxClassifier> s_defaultSyntaxClassifiers;
    [ObsoleteAttribute("This factory method only provides services for the MEF export provider.", "True")]
public CSharpSyntaxClassificationService(HostLanguageServices languageServices);
    public virtual ImmutableArray`1<ISyntaxClassifier> GetDefaultSyntaxClassifiers();
    public virtual void AddLexicalClassifications(SourceText text, TextSpan textSpan, ArrayBuilder`1<ClassifiedSpan> result, CancellationToken cancellationToken);
    public virtual void AddSyntacticClassifications(SyntaxNode root, TextSpan textSpan, ArrayBuilder`1<ClassifiedSpan> result, CancellationToken cancellationToken);
    public virtual ClassifiedSpan FixClassification(SourceText rawText, ClassifiedSpan classifiedSpan);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.CodeAnalysis.CSharp.Classification.OperatorOverloadSyntaxClassifier : AbstractSyntaxClassifier {
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private ImmutableArray`1<Type> <SyntaxNodeTypes>k__BackingField;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ImmutableArray`1<Type> SyntaxNodeTypes { get; }
    [CompilerGeneratedAttribute]
public virtual ImmutableArray`1<Type> get_SyntaxNodeTypes();
    public virtual void AddClassifications(Workspace workspace, SyntaxNode syntax, SemanticModel semanticModel, ArrayBuilder`1<ClassifiedSpan> result, CancellationToken cancellationToken);
    private static TextSpan GetOperatorTokenSpan(SyntaxNode syntax);
}
[ExportLanguageServiceFactoryAttribute("Microsoft.CodeAnalysis.Classification.ISyntaxClassificationService", "C#", "Default")]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.CSharp.Classification.SyntaxClassification.CSharpSyntaxClassificationServiceFactory : object {
    [NullableContextAttribute("1")]
[ObsoleteAttribute("This factory method only provides services for the MEF export provider.", "True")]
public sealed virtual ILanguageService CreateLanguageService(HostLanguageServices languageServices);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.CodeAnalysis.CSharp.Classification.Worker : object {
    private TextSpan _textSpan;
    private ArrayBuilder`1<ClassifiedSpan> _result;
    private CancellationToken _cancellationToken;
    private Worker(TextSpan textSpan, ArrayBuilder`1<ClassifiedSpan> result, CancellationToken cancellationToken);
    internal static void CollectClassifiedSpans(IEnumerable`1<SyntaxToken> tokens, TextSpan textSpan, ArrayBuilder`1<ClassifiedSpan> result, CancellationToken cancellationToken);
    internal static void CollectClassifiedSpans(SyntaxNode node, TextSpan textSpan, ArrayBuilder`1<ClassifiedSpan> result, CancellationToken cancellationToken);
    private void AddClassification(TextSpan span, string type);
    private bool ShouldAddSpan(TextSpan span);
    private void AddClassification(SyntaxTrivia trivia, string type);
    private void AddClassification(SyntaxToken token, string type);
    private void ClassifyNodeOrToken(SyntaxNodeOrToken nodeOrToken);
    private void ClassifyNode(SyntaxNode node);
    private void ClassifyToken(SyntaxToken token);
    private void ClassifyTriviaList(SyntaxTriviaList list);
    private void ClassifyTrivia(SyntaxTrivia trivia, SyntaxTriviaList triviaList);
    private void ClassifySkippedTokens(SkippedTokensTriviaSyntax skippedTokens);
    private void ClassifyConflictMarker(SyntaxTrivia trivia);
    private void ClassifyDisabledText(SyntaxTrivia trivia, SyntaxTriviaList triviaList);
    private void ClassifyDocumentationComment(DocumentationCommentTriviaSyntax documentationComment);
    private void ClassifyXmlNode(XmlNodeSyntax node);
    private void ClassifyXmlTrivia(SyntaxTriviaList triviaList);
    private void ClassifyExteriorTrivia(SyntaxTrivia trivia);
    private void AddXmlClassification(SyntaxToken token, string classificationType);
    private void ClassifyXmlTextTokens(SyntaxTokenList textTokens);
    private void ClassifyXmlTextToken(SyntaxToken token);
    private void ClassifyXmlName(XmlNameSyntax node);
    private void ClassifyXmlElement(XmlElementSyntax node);
    private void ClassifyXmlElementStartTag(XmlElementStartTagSyntax node);
    private void ClassifyXmlElementEndTag(XmlElementEndTagSyntax node);
    private void ClassifyXmlEmptyElement(XmlEmptyElementSyntax node);
    private void ClassifyXmlAttribute(XmlAttributeSyntax attribute);
    private void ClassifyXmlText(XmlTextSyntax node);
    private void ClassifyXmlComment(XmlCommentSyntax node);
    private void ClassifyXmlCDataSection(XmlCDataSectionSyntax node);
    private void ClassifyXmlProcessingInstruction(XmlProcessingInstructionSyntax node);
    private void ClassifyPreprocessorDirective(DirectiveTriviaSyntax node);
    private void ClassifyDirectiveTrivia(DirectiveTriviaSyntax node, bool allowComments);
    private void ClassifyPreprocessorTrivia(SyntaxTrivia trivia, bool allowComments);
    [NullableContextAttribute("2")]
private void ClassifyPreprocessorExpression(ExpressionSyntax node);
    private void ClassifyIfDirective(IfDirectiveTriviaSyntax node);
    private void ClassifyElifDirective(ElifDirectiveTriviaSyntax node);
    private void ClassifyElseDirective(ElseDirectiveTriviaSyntax node);
    private void ClassifyEndIfDirective(EndIfDirectiveTriviaSyntax node);
    private void ClassifyErrorDirective(ErrorDirectiveTriviaSyntax node);
    private void ClassifyWarningDirective(WarningDirectiveTriviaSyntax node);
    private void ClassifyRegionDirective(RegionDirectiveTriviaSyntax node);
    private void ClassifyEndRegionDirective(EndRegionDirectiveTriviaSyntax node);
    private void ClassifyDefineDirective(DefineDirectiveTriviaSyntax node);
    private void ClassifyUndefDirective(UndefDirectiveTriviaSyntax node);
    private void ClassifyBadDirective(BadDirectiveTriviaSyntax node);
    private void ClassifyLineDirective(LineDirectiveTriviaSyntax node);
    private void ClassifyPragmaChecksumDirective(PragmaChecksumDirectiveTriviaSyntax node);
    private void ClassifyPragmaWarningDirective(PragmaWarningDirectiveTriviaSyntax node);
    private void ClassifyReferenceDirective(ReferenceDirectiveTriviaSyntax node);
    private void ClassifyLoadDirective(LoadDirectiveTriviaSyntax node);
    private void ClassifyNullableDirective(NullableDirectiveTriviaSyntax node);
}
internal class Microsoft.CodeAnalysis.CSharp.CodeCleanup.CSharpCodeCleanerService : AbstractCodeCleanerService {
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private static ImmutableArray`1<ICodeCleanupProvider> s_defaultProviders;
    private static CSharpCodeCleanerService();
    public virtual ImmutableArray`1<ICodeCleanupProvider> GetDefaultProviders();
    protected virtual ImmutableArray`1<TextSpan> GetSpansToAvoid(SyntaxNode root);
}
[ExportLanguageServiceFactoryAttribute("Microsoft.CodeAnalysis.CodeCleanup.ICodeCleanerService", "C#", "Default")]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.CSharp.CodeCleanup.CSharpCodeCleanerServiceFactory : object {
    [NullableContextAttribute("1")]
public sealed virtual ILanguageService CreateLanguageService(HostLanguageServices provider);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal static class Microsoft.CodeAnalysis.CSharp.CodeGeneration.ArgumentGenerator : object {
    public static ArgumentSyntax GenerateArgument(SyntaxNode argument);
    public static ArgumentListSyntax GenerateArgumentList(IList`1<SyntaxNode> arguments);
    public static BracketedArgumentListSyntax GenerateBracketedArgumentList(IList`1<SyntaxNode> arguments);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal static class Microsoft.CodeAnalysis.CSharp.CodeGeneration.AttributeGenerator : object {
    public static SyntaxList`1<AttributeListSyntax> GenerateAttributeLists(ImmutableArray`1<AttributeData> attributes, CodeGenerationOptions options, Nullable`1<SyntaxToken> target);
    private static AttributeListSyntax TryGenerateAttributeDeclaration(AttributeData attribute, Nullable`1<SyntaxToken> target, CodeGenerationOptions options);
    private static AttributeSyntax TryGenerateAttribute(AttributeData attribute, CodeGenerationOptions options);
    private static bool IsCompilerInternalAttribute(AttributeData attribute);
    private static AttributeArgumentListSyntax GenerateAttributeArgumentList(AttributeData attribute);
}
internal static class Microsoft.CodeAnalysis.CSharp.CodeGeneration.ConstructorGenerator : object {
    private static MemberDeclarationSyntax LastConstructorOrField(SyntaxList`1<MemberDeclarationSyntax> members);
    internal static TypeDeclarationSyntax AddConstructorTo(TypeDeclarationSyntax destination, IMethodSymbol constructor, CodeGenerationOptions options, IList`1<bool> availableIndices);
    internal static ConstructorDeclarationSyntax GenerateConstructorDeclaration(IMethodSymbol constructor, CodeGenerationOptions options, ParseOptions parseOptions);
    private static ConstructorDeclarationSyntax UseExpressionBodyIfDesired(CodeGenerationOptions options, ConstructorDeclarationSyntax declaration, ParseOptions parseOptions);
    private static ConstructorInitializerSyntax GenerateConstructorInitializer(IMethodSymbol constructor);
    private static ArgumentListSyntax GenerateArgumentList(ImmutableArray`1<SyntaxNode> arguments);
    private static BlockSyntax GenerateBlock(IMethodSymbol constructor);
    private static SyntaxTokenList GenerateModifiers(IMethodSymbol constructor, CodeGenerationOptions options);
}
internal static class Microsoft.CodeAnalysis.CSharp.CodeGeneration.ConversionGenerator : object {
    internal static TypeDeclarationSyntax AddConversionTo(TypeDeclarationSyntax destination, IMethodSymbol method, CodeGenerationOptions options, IList`1<bool> availableIndices);
    internal static ConversionOperatorDeclarationSyntax GenerateConversionDeclaration(IMethodSymbol method, CodeGenerationOptions options, ParseOptions parseOptions);
    private static ConversionOperatorDeclarationSyntax GenerateConversionDeclarationWorker(IMethodSymbol method, CodeGenerationOptions options, ParseOptions parseOptions);
    private static ConversionOperatorDeclarationSyntax UseExpressionBodyIfDesired(CodeGenerationOptions options, ConversionOperatorDeclarationSyntax declaration, ParseOptions parseOptions);
    private static SyntaxTokenList GenerateModifiers();
}
internal static class Microsoft.CodeAnalysis.CSharp.CodeGeneration.CSharpCodeGenerationHelpers : object {
    public static TDeclarationSyntax ConditionallyAddFormattingAnnotationTo(TDeclarationSyntax result, SyntaxList`1<MemberDeclarationSyntax> members);
    internal static void AddAccessibilityModifiers(Accessibility accessibility, ArrayBuilder`1<SyntaxToken> tokens, CodeGenerationOptions options, Accessibility defaultAccessibility);
    public static TypeDeclarationSyntax AddMembersTo(TypeDeclarationSyntax destination, SyntaxList`1<MemberDeclarationSyntax> members);
    private static TypeDeclarationSyntax ReplaceUnterminatedConstructs(TypeDeclarationSyntax destination);
    private static SyntaxTrivia ReplaceUnterminatedConstructs(SyntaxTrivia skippedTokensTrivia);
    private static SyntaxToken ReplaceUnterminatedConstruct(SyntaxToken token);
    public static MemberDeclarationSyntax FirstMember(SyntaxList`1<MemberDeclarationSyntax> members);
    public static MemberDeclarationSyntax FirstMethod(SyntaxList`1<MemberDeclarationSyntax> members);
    public static MemberDeclarationSyntax LastField(SyntaxList`1<MemberDeclarationSyntax> members);
    public static MemberDeclarationSyntax LastConstructor(SyntaxList`1<MemberDeclarationSyntax> members);
    public static MemberDeclarationSyntax LastMethod(SyntaxList`1<MemberDeclarationSyntax> members);
    public static MemberDeclarationSyntax LastOperator(SyntaxList`1<MemberDeclarationSyntax> members);
    public static SyntaxList`1<TDeclaration> Insert(SyntaxList`1<TDeclaration> declarationList, TDeclaration declaration, CodeGenerationOptions options, IList`1<bool> availableIndices, Func`2<SyntaxList`1<TDeclaration>, TDeclaration> after, Func`2<SyntaxList`1<TDeclaration>, TDeclaration> before);
    private static bool AreBracesMissing(TDeclaration declaration);
    public static SyntaxNode GetContextNode(Location location, CancellationToken cancellationToken);
    public static ExplicitInterfaceSpecifierSyntax GenerateExplicitInterfaceSpecifier(IEnumerable`1<ISymbol> implementations);
    public static CodeGenerationDestination GetDestination(SyntaxNode destination);
    public static TSyntaxNode ConditionallyAddDocumentationCommentTo(TSyntaxNode node, ISymbol symbol, CodeGenerationOptions options, CancellationToken cancellationToken);
}
internal class Microsoft.CodeAnalysis.CSharp.CodeGeneration.CSharpCodeGenerationService : AbstractCodeGenerationService {
    public CSharpCodeGenerationService(HostLanguageServices languageServices);
    public virtual CodeGenerationDestination GetDestination(SyntaxNode node);
    protected virtual IComparer`1<SyntaxNode> GetMemberComparer();
    protected virtual IList`1<bool> GetAvailableInsertionIndices(SyntaxNode destination, CancellationToken cancellationToken);
    private static IList`1<bool> GetInsertionIndices(TypeDeclarationSyntax destination, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.CSharp.CodeGeneration.CSharpCodeGenerationService/<AddEventAsync>d__5")]
public virtual Task`1<Document> AddEventAsync(Solution solution, INamedTypeSymbol destination, IEventSymbol event, CodeGenerationOptions options, CancellationToken cancellationToken);
    protected virtual TDeclarationNode AddEvent(TDeclarationNode destination, IEventSymbol event, CodeGenerationOptions options, IList`1<bool> availableIndices);
    protected virtual TDeclarationNode AddField(TDeclarationNode destination, IFieldSymbol field, CodeGenerationOptions options, IList`1<bool> availableIndices);
    protected virtual TDeclarationNode AddMethod(TDeclarationNode destination, IMethodSymbol method, CodeGenerationOptions options, IList`1<bool> availableIndices);
    protected virtual TDeclarationNode AddProperty(TDeclarationNode destination, IPropertySymbol property, CodeGenerationOptions options, IList`1<bool> availableIndices);
    protected virtual TDeclarationNode AddNamedType(TDeclarationNode destination, INamedTypeSymbol namedType, CodeGenerationOptions options, IList`1<bool> availableIndices, CancellationToken cancellationToken);
    protected virtual TDeclarationNode AddNamespace(TDeclarationNode destination, INamespaceSymbol namespace, CodeGenerationOptions options, IList`1<bool> availableIndices, CancellationToken cancellationToken);
    public virtual TDeclarationNode AddParameters(TDeclarationNode destination, IEnumerable`1<IParameterSymbol> parameters, CodeGenerationOptions options, CancellationToken cancellationToken);
    public virtual TDeclarationNode AddAttributes(TDeclarationNode destination, IEnumerable`1<AttributeData> attributes, Nullable`1<SyntaxToken> target, CodeGenerationOptions options, CancellationToken cancellationToken);
    protected virtual TDeclarationNode AddMembers(TDeclarationNode destination, IEnumerable`1<SyntaxNode> members);
    public virtual TDeclarationNode RemoveAttribute(TDeclarationNode destination, AttributeData attributeToRemove, CodeGenerationOptions options, CancellationToken cancellationToken);
    public virtual TDeclarationNode RemoveAttribute(TDeclarationNode destination, SyntaxNode attributeToRemove, CodeGenerationOptions options, CancellationToken cancellationToken);
    private static SyntaxList`1<AttributeListSyntax> RemoveAttributeFromAttributeLists(SyntaxList`1<AttributeListSyntax> attributeLists, SyntaxNode attributeToRemove, Int32& positionOfRemovedNode, SyntaxTriviaList& triviaOfRemovedNode);
    public virtual TDeclarationNode AddStatements(TDeclarationNode destinationMember, IEnumerable`1<SyntaxNode> statements, CodeGenerationOptions options, CancellationToken cancellationToken);
    private static TDeclarationNode AddStatementsWorker(TDeclarationNode destinationMember, IEnumerable`1<SyntaxNode> statements, CodeGenerationOptions options, CancellationToken cancellationToken);
    private static TDeclarationNode AddStatementsToMemberDeclaration(TDeclarationNode destinationMember, IEnumerable`1<SyntaxNode> statements, MemberDeclarationSyntax memberDeclaration);
    public virtual SyntaxNode CreateEventDeclaration(IEventSymbol event, CodeGenerationDestination destination, CodeGenerationOptions options);
    public virtual SyntaxNode CreateFieldDeclaration(IFieldSymbol field, CodeGenerationDestination destination, CodeGenerationOptions options);
    public virtual SyntaxNode CreateMethodDeclaration(IMethodSymbol method, CodeGenerationDestination destination, CodeGenerationOptions options);
    public virtual SyntaxNode CreatePropertyDeclaration(IPropertySymbol property, CodeGenerationDestination destination, CodeGenerationOptions options);
    public virtual SyntaxNode CreateNamedTypeDeclaration(INamedTypeSymbol namedType, CodeGenerationDestination destination, CodeGenerationOptions options, CancellationToken cancellationToken);
    public virtual SyntaxNode CreateNamespaceDeclaration(INamespaceSymbol namespace, CodeGenerationDestination destination, CodeGenerationOptions options, CancellationToken cancellationToken);
    private static TDeclarationNode UpdateDeclarationModifiers(TDeclarationNode declaration, Func`2<SyntaxTokenList, SyntaxTokenList> computeNewModifiersList);
    public virtual TDeclarationNode UpdateDeclarationModifiers(TDeclarationNode declaration, IEnumerable`1<SyntaxToken> newModifiers, CodeGenerationOptions options, CancellationToken cancellationToken);
    public virtual TDeclarationNode UpdateDeclarationAccessibility(TDeclarationNode declaration, Accessibility newAccessibility, CodeGenerationOptions options, CancellationToken cancellationToken);
    private static SyntaxTokenList UpdateDeclarationAccessibility(SyntaxTokenList modifiersList, Accessibility newAccessibility, CodeGenerationOptions options);
    public virtual TDeclarationNode UpdateDeclarationType(TDeclarationNode declaration, ITypeSymbol newType, CodeGenerationOptions options, CancellationToken cancellationToken);
    public virtual TDeclarationNode UpdateDeclarationMembers(TDeclarationNode declaration, IList`1<ISymbol> newMembers, CodeGenerationOptions options, CancellationToken cancellationToken);
    [NullableContextAttribute("1")]
[CompilerGeneratedAttribute]
[DebuggerHiddenAttribute]
private Task`1<Document> <>n__0(Solution solution, INamedTypeSymbol destination, IEventSymbol event, CodeGenerationOptions options, CancellationToken cancellationToken);
}
[ExportLanguageServiceFactoryAttribute("Microsoft.CodeAnalysis.CodeGeneration.ICodeGenerationService", "C#", "Default")]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.CSharp.CodeGeneration.CSharpCodeGenerationServiceFactory : object {
    public sealed virtual ILanguageService CreateLanguageService(HostLanguageServices provider);
}
internal class Microsoft.CodeAnalysis.CSharp.CodeGeneration.CSharpDeclarationComparer : object {
    private static Dictionary`2<SyntaxKind, int> s_kindPrecedenceMap;
    private static Dictionary`2<SyntaxKind, int> s_operatorPrecedenceMap;
    public static CSharpDeclarationComparer WithNamesInstance;
    public static CSharpDeclarationComparer WithoutNamesInstance;
    private bool _includeName;
    private CSharpDeclarationComparer(bool includeName);
    private static CSharpDeclarationComparer();
    public sealed virtual int Compare(SyntaxNode x, SyntaxNode y);
    private int Compare(DelegateDeclarationSyntax x, DelegateDeclarationSyntax y);
    private int Compare(BaseFieldDeclarationSyntax x, BaseFieldDeclarationSyntax y);
    private static int Compare(ConstructorDeclarationSyntax x, ConstructorDeclarationSyntax y);
    private int Compare(MethodDeclarationSyntax x, MethodDeclarationSyntax y);
    private static int Compare(ConversionOperatorDeclarationSyntax x, ConversionOperatorDeclarationSyntax y);
    private static int Compare(OperatorDeclarationSyntax x, OperatorDeclarationSyntax y);
    private int Compare(EventDeclarationSyntax x, EventDeclarationSyntax y);
    private static int Compare(IndexerDeclarationSyntax x, IndexerDeclarationSyntax y);
    private int Compare(PropertyDeclarationSyntax x, PropertyDeclarationSyntax y);
    private int Compare(EnumDeclarationSyntax x, EnumDeclarationSyntax y);
    private int Compare(BaseTypeDeclarationSyntax x, BaseTypeDeclarationSyntax y);
    private static bool NeitherNull(object x, object y, Int32& comparisonResult);
    private static bool ContainsToken(SyntaxTokenList list, SyntaxKind kind);
    private static int GetAccessibilityPrecedence(SyntaxTokenList modifiers, SyntaxNode parent);
    private static bool BothHaveModifier(SyntaxTokenList x, SyntaxTokenList y, SyntaxKind modifierKind, Int32& comparisonResult);
    private static bool EqualStaticness(SyntaxTokenList x, SyntaxTokenList y, Int32& comparisonResult);
    private static bool EqualConstness(SyntaxTokenList x, SyntaxTokenList y, Int32& comparisonResult);
    private static bool EqualReadOnlyness(SyntaxTokenList x, SyntaxTokenList y, Int32& comparisonResult);
    private static bool EqualAccessibility(SyntaxNode x, SyntaxTokenList xModifiers, SyntaxNode y, SyntaxTokenList yModifiers, Int32& comparisonResult);
    private static bool EqualIdentifierName(SyntaxToken x, SyntaxToken y, Int32& comparisonResult);
    private static bool EqualOperatorPrecedence(SyntaxToken x, SyntaxToken y, Int32& comparisonResult);
    private static bool EqualParameterCount(BaseParameterListSyntax x, BaseParameterListSyntax y, Int32& comparisonResult);
}
internal class Microsoft.CodeAnalysis.CSharp.CodeGeneration.CSharpFlagsEnumGenerator : AbstractFlagsEnumGenerator {
    internal static CSharpFlagsEnumGenerator Instance;
    private static SyntaxGenerator s_generatorInstance;
    private static CSharpFlagsEnumGenerator();
    protected virtual SyntaxNode CreateExplicitlyCastedLiteralValue(INamedTypeSymbol enumType, SpecialType underlyingSpecialType, object constantValue);
    protected virtual SyntaxGenerator GetSyntaxGenerator();
    protected virtual bool IsValidName(INamedTypeSymbol enumType, string name);
}
[ExportLanguageServiceAttribute("Microsoft.CodeAnalysis.Editing.SyntaxGenerator", "C#", "Default")]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.CSharp.CodeGeneration.CSharpSyntaxGenerator : SyntaxGenerator {
    private static IdentifierNameSyntax s_nameOfIdentifier;
    public static SyntaxGenerator Instance;
    private static ConditionalWeakTable`2<SyntaxNode, IReadOnlyList`1<SyntaxNode>> s_declAttributes;
    private static ConditionalWeakTable`2<SyntaxNode, IReadOnlyList`1<SyntaxNode>> s_declReturnAttributes;
    private static DeclarationModifiers s_fieldModifiers;
    private static DeclarationModifiers s_methodModifiers;
    private static DeclarationModifiers s_constructorModifiers;
    private static DeclarationModifiers s_destructorModifiers;
    private static DeclarationModifiers s_propertyModifiers;
    private static DeclarationModifiers s_eventModifiers;
    private static DeclarationModifiers s_eventFieldModifiers;
    private static DeclarationModifiers s_indexerModifiers;
    private static DeclarationModifiers s_classModifiers;
    private static DeclarationModifiers s_recordModifiers;
    private static DeclarationModifiers s_structModifiers;
    private static DeclarationModifiers s_interfaceModifiers;
    private static DeclarationModifiers s_accessorModifiers;
    private static DeclarationModifiers s_localFunctionModifiers;
    private static DeclarationModifiers s_lambdaModifiers;
    private static IReadOnlyList`1<SyntaxNode> s_EmptyList;
    internal SyntaxTrivia ElasticCarriageReturnLineFeed { get; }
    internal SyntaxTrivia CarriageReturnLineFeed { get; }
    internal bool RequiresExplicitImplementationForInterfaceMembers { get; }
    internal SyntaxGeneratorInternal SyntaxGeneratorInternal { get; }
    private static CSharpSyntaxGenerator();
    internal virtual SyntaxTrivia get_ElasticCarriageReturnLineFeed();
    internal virtual SyntaxTrivia get_CarriageReturnLineFeed();
    internal virtual bool get_RequiresExplicitImplementationForInterfaceMembers();
    internal virtual SyntaxGeneratorInternal get_SyntaxGeneratorInternal();
    internal virtual SyntaxTrivia Whitespace(string text);
    internal virtual SyntaxTrivia SingleLineComment(string text);
    internal virtual SeparatedSyntaxList`1<TElement> SeparatedList(SyntaxNodeOrTokenList list);
    internal virtual SyntaxToken CreateInterpolatedStringStartToken(bool isVerbatim);
    internal virtual SyntaxToken CreateInterpolatedStringEndToken();
    internal virtual SeparatedSyntaxList`1<TElement> SeparatedList(IEnumerable`1<TElement> nodes, IEnumerable`1<SyntaxToken> separators);
    internal virtual SyntaxTrivia Trivia(SyntaxNode node);
    internal virtual SyntaxNode DocumentationCommentTrivia(IEnumerable`1<SyntaxNode> nodes, SyntaxTriviaList trailingTrivia, SyntaxTrivia lastWhitespaceTrivia, string endOfLineString);
    internal virtual SyntaxNode DocumentationCommentTriviaWithUpdatedContent(SyntaxTrivia trivia, IEnumerable`1<SyntaxNode> content);
    public virtual SyntaxNode CompilationUnit(IEnumerable`1<SyntaxNode> declarations);
    private SyntaxList`1<UsingDirectiveSyntax> AsUsingDirectives(IEnumerable`1<SyntaxNode> declarations);
    private SyntaxNode AsUsingDirective(SyntaxNode node);
    private static SyntaxList`1<MemberDeclarationSyntax> AsNamespaceMembers(IEnumerable`1<SyntaxNode> declarations);
    private static SyntaxNode AsNamespaceMember(SyntaxNode declaration);
    public virtual SyntaxNode NamespaceImportDeclaration(SyntaxNode name);
    public virtual SyntaxNode AliasImportDeclaration(string aliasIdentifierName, SyntaxNode name);
    public virtual SyntaxNode NamespaceDeclaration(SyntaxNode name, IEnumerable`1<SyntaxNode> declarations);
    public virtual SyntaxNode FieldDeclaration(string name, SyntaxNode type, Accessibility accessibility, DeclarationModifiers modifiers, SyntaxNode initializer);
    public virtual SyntaxNode ParameterDeclaration(string name, SyntaxNode type, SyntaxNode initializer, RefKind refKind);
    internal static SyntaxToken GetArgumentModifiers(RefKind refKind);
    public virtual SyntaxNode MethodDeclaration(string name, IEnumerable`1<SyntaxNode> parameters, IEnumerable`1<string> typeParameters, SyntaxNode returnType, Accessibility accessibility, DeclarationModifiers modifiers, IEnumerable`1<SyntaxNode> statements);
    public virtual SyntaxNode OperatorDeclaration(OperatorKind kind, IEnumerable`1<SyntaxNode> parameters, SyntaxNode returnType, Accessibility accessibility, DeclarationModifiers modifiers, IEnumerable`1<SyntaxNode> statements);
    private static SyntaxKind GetTokenKind(OperatorKind kind);
    private static ParameterListSyntax AsParameterList(IEnumerable`1<SyntaxNode> parameters);
    public virtual SyntaxNode ConstructorDeclaration(string name, IEnumerable`1<SyntaxNode> parameters, Accessibility accessibility, DeclarationModifiers modifiers, IEnumerable`1<SyntaxNode> baseConstructorArguments, IEnumerable`1<SyntaxNode> statements);
    public virtual SyntaxNode PropertyDeclaration(string name, SyntaxNode type, Accessibility accessibility, DeclarationModifiers modifiers, IEnumerable`1<SyntaxNode> getAccessorStatements, IEnumerable`1<SyntaxNode> setAccessorStatements);
    public virtual SyntaxNode GetAccessorDeclaration(Accessibility accessibility, IEnumerable`1<SyntaxNode> statements);
    public virtual SyntaxNode SetAccessorDeclaration(Accessibility accessibility, IEnumerable`1<SyntaxNode> statements);
    private static SyntaxNode AccessorDeclaration(SyntaxKind kind, Accessibility accessibility, IEnumerable`1<SyntaxNode> statements);
    public virtual SyntaxNode WithAccessorDeclarations(SyntaxNode declaration, IEnumerable`1<SyntaxNode> accessorDeclarations);
    private static AccessorListSyntax CreateAccessorList(AccessorListSyntax accessorListOpt, IEnumerable`1<SyntaxNode> accessorDeclarations);
    public virtual SyntaxNode IndexerDeclaration(IEnumerable`1<SyntaxNode> parameters, SyntaxNode type, Accessibility accessibility, DeclarationModifiers modifiers, IEnumerable`1<SyntaxNode> getAccessorStatements, IEnumerable`1<SyntaxNode> setAccessorStatements);
    private static BracketedParameterListSyntax AsBracketedParameterList(IEnumerable`1<SyntaxNode> parameters);
    private static AccessorDeclarationSyntax AccessorDeclaration(SyntaxKind kind, IEnumerable`1<SyntaxNode> statements);
    public virtual SyntaxNode EventDeclaration(string name, SyntaxNode type, Accessibility accessibility, DeclarationModifiers modifiers);
    public virtual SyntaxNode CustomEventDeclaration(string name, SyntaxNode type, Accessibility accessibility, DeclarationModifiers modifiers, IEnumerable`1<SyntaxNode> parameters, IEnumerable`1<SyntaxNode> addAccessorStatements, IEnumerable`1<SyntaxNode> removeAccessorStatements);
    public virtual SyntaxNode AsPublicInterfaceImplementation(SyntaxNode declaration, SyntaxNode interfaceTypeName, string interfaceMemberName);
    public virtual SyntaxNode AsPrivateInterfaceImplementation(SyntaxNode declaration, SyntaxNode interfaceTypeName, string interfaceMemberName);
    private SyntaxNode WithoutConstraints(SyntaxNode declaration);
    private static SyntaxNode WithInterfaceSpecifier(SyntaxNode declaration, ExplicitInterfaceSpecifierSyntax specifier);
    private SyntaxNode AsImplementation(SyntaxNode declaration, Accessibility requiredAccess);
    private static SyntaxNode WithBodies(SyntaxNode declaration);
    private static AccessorListSyntax WithBodies(AccessorListSyntax accessorList);
    private static AccessorDeclarationSyntax WithBody(AccessorDeclarationSyntax accessor);
    private static AccessorListSyntax WithoutBodies(AccessorListSyntax accessorList);
    private static AccessorDeclarationSyntax WithoutBody(AccessorDeclarationSyntax accessor);
    public virtual SyntaxNode ClassDeclaration(string name, IEnumerable`1<string> typeParameters, Accessibility accessibility, DeclarationModifiers modifiers, SyntaxNode baseType, IEnumerable`1<SyntaxNode> interfaceTypes, IEnumerable`1<SyntaxNode> members);
    private SyntaxList`1<MemberDeclarationSyntax> AsClassMembers(string className, IEnumerable`1<SyntaxNode> members);
    private MemberDeclarationSyntax AsClassMember(SyntaxNode node, string className);
    public virtual SyntaxNode StructDeclaration(string name, IEnumerable`1<string> typeParameters, Accessibility accessibility, DeclarationModifiers modifiers, IEnumerable`1<SyntaxNode> interfaceTypes, IEnumerable`1<SyntaxNode> members);
    public virtual SyntaxNode InterfaceDeclaration(string name, IEnumerable`1<string> typeParameters, Accessibility accessibility, IEnumerable`1<SyntaxNode> interfaceTypes, IEnumerable`1<SyntaxNode> members);
    private SyntaxList`1<MemberDeclarationSyntax> AsInterfaceMembers(IEnumerable`1<SyntaxNode> members);
    internal virtual SyntaxNode AsInterfaceMember(SyntaxNode m);
    public virtual SyntaxNode EnumDeclaration(string name, Accessibility accessibility, DeclarationModifiers modifiers, IEnumerable`1<SyntaxNode> members);
    internal virtual SyntaxNode EnumDeclaration(string name, SyntaxNode underlyingType, Accessibility accessibility, DeclarationModifiers modifiers, IEnumerable`1<SyntaxNode> members);
    public virtual SyntaxNode EnumMember(string name, SyntaxNode expression);
    private EnumMemberDeclarationSyntax AsEnumMember(SyntaxNode node);
    private SeparatedSyntaxList`1<EnumMemberDeclarationSyntax> AsEnumMembers(IEnumerable`1<SyntaxNode> members);
    public virtual SyntaxNode DelegateDeclaration(string name, IEnumerable`1<SyntaxNode> parameters, IEnumerable`1<string> typeParameters, SyntaxNode returnType, Accessibility accessibility, DeclarationModifiers modifiers);
    public virtual SyntaxNode Attribute(SyntaxNode name, IEnumerable`1<SyntaxNode> attributeArguments);
    public virtual SyntaxNode AttributeArgument(string name, SyntaxNode expression);
    private static AttributeArgumentListSyntax AsAttributeArgumentList(IEnumerable`1<SyntaxNode> arguments);
    private static AttributeArgumentSyntax AsAttributeArgument(SyntaxNode node);
    public virtual TNode ClearTrivia(TNode node);
    private static SyntaxList`1<AttributeListSyntax> AsAttributeLists(IEnumerable`1<SyntaxNode> attributes);
    private static AttributeListSyntax AsAttributeList(SyntaxNode node);
    public virtual IReadOnlyList`1<SyntaxNode> GetAttributes(SyntaxNode declaration);
    public virtual IReadOnlyList`1<SyntaxNode> GetReturnAttributes(SyntaxNode declaration);
    private static bool IsReturnAttribute(AttributeListSyntax list);
    public virtual SyntaxNode InsertAttributes(SyntaxNode declaration, int index, IEnumerable`1<SyntaxNode> attributes);
    private SyntaxNode InsertAttributesInternal(SyntaxNode declaration, int index, IEnumerable`1<SyntaxNode> attributes);
    public virtual SyntaxNode InsertReturnAttributes(SyntaxNode declaration, int index, IEnumerable`1<SyntaxNode> attributes);
    private SyntaxNode InsertReturnAttributesInternal(SyntaxNode d, int index, IEnumerable`1<SyntaxNode> attributes);
    private static IEnumerable`1<AttributeListSyntax> AsReturnAttributes(IEnumerable`1<SyntaxNode> attributes);
    private static SyntaxList`1<AttributeListSyntax> AsAssemblyAttributes(IEnumerable`1<AttributeListSyntax> attributes);
    public virtual IReadOnlyList`1<SyntaxNode> GetAttributeArguments(SyntaxNode attributeDeclaration);
    public virtual SyntaxNode InsertAttributeArguments(SyntaxNode declaration, int index, IEnumerable`1<SyntaxNode> attributeArguments);
    private static SyntaxNode InsertAttributeArgumentsInternal(SyntaxNode declaration, int index, IEnumerable`1<SyntaxNode> attributeArguments);
    private static AttributeArgumentListSyntax GetAttributeArgumentList(SyntaxNode declaration);
    private static SyntaxNode WithAttributeArgumentList(SyntaxNode declaration, AttributeArgumentListSyntax argList);
    internal static SyntaxList`1<AttributeListSyntax> GetAttributeLists(SyntaxNode declaration);
    private static SyntaxNode WithAttributeLists(SyntaxNode declaration, SyntaxList`1<AttributeListSyntax> attributeLists);
    internal virtual ImmutableArray`1<SyntaxNode> GetTypeInheritance(SyntaxNode declaration);
    public virtual IReadOnlyList`1<SyntaxNode> GetNamespaceImports(SyntaxNode declaration);
    public virtual SyntaxNode InsertNamespaceImports(SyntaxNode declaration, int index, IEnumerable`1<SyntaxNode> imports);
    private SyntaxNode InsertNamespaceImportsInternal(SyntaxNode declaration, int index, IEnumerable`1<SyntaxNode> imports);
    public virtual IReadOnlyList`1<SyntaxNode> GetMembers(SyntaxNode declaration);
    private static ImmutableArray`1<SyntaxNode> Flatten(IEnumerable`1<SyntaxNode> declarations);
    private static int GetDeclarationCount(SyntaxNode declaration);
    private static SyntaxNode EnsureRecordDeclarationHasBody(SyntaxNode declaration);
    public virtual SyntaxNode InsertMembers(SyntaxNode declaration, int index, IEnumerable`1<SyntaxNode> members);
    private IEnumerable`1<MemberDeclarationSyntax> AsMembersOf(SyntaxNode declaration, IEnumerable`1<SyntaxNode> members);
    private SyntaxNode AsMemberOf(SyntaxNode declaration, SyntaxNode member);
    public virtual Accessibility GetAccessibility(SyntaxNode declaration);
    public virtual SyntaxNode WithAccessibility(SyntaxNode declaration, Accessibility accessibility);
    private static DeclarationModifiers GetAllowedModifiers(SyntaxKind kind);
    public virtual DeclarationModifiers GetModifiers(SyntaxNode declaration);
    public virtual SyntaxNode WithModifiers(SyntaxNode declaration, DeclarationModifiers modifiers);
    private SyntaxNode WithModifiersInternal(SyntaxNode declaration, DeclarationModifiers modifiers);
    private static SyntaxNode SetModifierTokens(SyntaxNode declaration, SyntaxTokenList modifiers);
    private static SyntaxTokenList AsModifierList(Accessibility accessibility, DeclarationModifiers modifiers, SyntaxKind kind);
    private static SyntaxTokenList AsModifierList(Accessibility accessibility, DeclarationModifiers modifiers);
    private static TypeParameterListSyntax AsTypeParameterList(IEnumerable`1<string> typeParameterNames);
    public virtual SyntaxNode WithTypeParameters(SyntaxNode declaration, IEnumerable`1<string> typeParameterNames);
    internal virtual SyntaxNode WithExplicitInterfaceImplementations(SyntaxNode declaration, ImmutableArray`1<ISymbol> explicitInterfaceImplementations);
    private static ExplicitInterfaceSpecifierSyntax CreateExplicitInterfaceSpecifier(ImmutableArray`1<ISymbol> explicitInterfaceImplementations);
    public virtual SyntaxNode WithTypeConstraint(SyntaxNode declaration, string typeParameterName, SpecialTypeConstraintKind kinds, IEnumerable`1<SyntaxNode> types);
    private static SyntaxList`1<TypeParameterConstraintClauseSyntax> WithTypeConstraints(SyntaxList`1<TypeParameterConstraintClauseSyntax> clauses, string typeParameterName, SpecialTypeConstraintKind kinds, IEnumerable`1<SyntaxNode> types);
    public virtual DeclarationKind GetDeclarationKind(SyntaxNode declaration);
    public virtual string GetName(SyntaxNode declaration);
    public virtual SyntaxNode WithName(SyntaxNode declaration, string name);
    private SyntaxNode WithNameInternal(SyntaxNode declaration, string name);
    public virtual SyntaxNode GetType(SyntaxNode declaration);
    private static TypeSyntax NotVoid(TypeSyntax type);
    public virtual SyntaxNode WithType(SyntaxNode declaration, SyntaxNode type);
    private static SyntaxNode WithTypeInternal(SyntaxNode declaration, SyntaxNode type);
    private SyntaxNode Isolate(SyntaxNode declaration, Func`2<SyntaxNode, SyntaxNode> editor);
    private SyntaxNode AsIsolatedDeclaration(SyntaxNode declaration);
    private static SyntaxNode WithVariable(SyntaxNode declaration, VariableDeclaratorSyntax variable);
    private static VariableDeclarationSyntax GetVariableDeclaration(SyntaxNode declaration);
    private static SyntaxNode WithVariableDeclaration(SyntaxNode declaration, VariableDeclarationSyntax variables);
    private static SyntaxNode GetFullDeclaration(SyntaxNode declaration);
    private SyntaxNode AsNodeLike(SyntaxNode existingNode, SyntaxNode newNode);
    public virtual IReadOnlyList`1<SyntaxNode> GetParameters(SyntaxNode declaration);
    public virtual SyntaxNode InsertParameters(SyntaxNode declaration, int index, IEnumerable`1<SyntaxNode> parameters);
    public virtual IReadOnlyList`1<SyntaxNode> GetSwitchSections(SyntaxNode switchStatement);
    public virtual SyntaxNode InsertSwitchSections(SyntaxNode switchStatement, int index, IEnumerable`1<SyntaxNode> switchSections);
    private static TNode AddMissingTokens(TNode node, bool recurse);
    internal virtual SyntaxNode GetParameterListNode(SyntaxNode declaration);
    private static SyntaxNode WithParameterList(SyntaxNode declaration, BaseParameterListSyntax list);
    public virtual SyntaxNode GetExpression(SyntaxNode declaration);
    public virtual SyntaxNode WithExpression(SyntaxNode declaration, SyntaxNode expression);
    private static SyntaxNode WithExpressionInternal(SyntaxNode declaration, SyntaxNode expression);
    private static EqualsValueClauseSyntax GetEqualsValue(SyntaxNode declaration);
    private static SyntaxNode WithEqualsValue(SyntaxNode declaration, EqualsValueClauseSyntax eq);
    public virtual IReadOnlyList`1<SyntaxNode> GetStatements(SyntaxNode declaration);
    public virtual SyntaxNode WithStatements(SyntaxNode declaration, IEnumerable`1<SyntaxNode> statements);
    public virtual IReadOnlyList`1<SyntaxNode> GetAccessors(SyntaxNode declaration);
    public virtual SyntaxNode InsertAccessors(SyntaxNode declaration, int index, IEnumerable`1<SyntaxNode> accessors);
    internal static AccessorListSyntax GetAccessorList(SyntaxNode declaration);
    private static bool CanHaveAccessors(SyntaxNode declaration);
    private static SyntaxNode WithAccessorList(SyntaxNode declaration, AccessorListSyntax accessorList);
    private static AccessorListSyntax AsAccessorList(IEnumerable`1<SyntaxNode> nodes, SyntaxKind parentKind);
    private static AccessorDeclarationSyntax AsAccessor(SyntaxNode node, SyntaxKind parentKind);
    private static AccessorDeclarationSyntax GetAccessor(SyntaxNode declaration, SyntaxKind kind);
    private SyntaxNode WithAccessor(SyntaxNode declaration, SyntaxKind kind, AccessorDeclarationSyntax accessor);
    private SyntaxNode WithAccessor(SyntaxNode declaration, AccessorListSyntax accessorList, SyntaxKind kind, AccessorDeclarationSyntax accessor);
    public virtual IReadOnlyList`1<SyntaxNode> GetGetAccessorStatements(SyntaxNode declaration);
    public virtual IReadOnlyList`1<SyntaxNode> GetSetAccessorStatements(SyntaxNode declaration);
    public virtual SyntaxNode WithGetAccessorStatements(SyntaxNode declaration, IEnumerable`1<SyntaxNode> statements);
    public virtual SyntaxNode WithSetAccessorStatements(SyntaxNode declaration, IEnumerable`1<SyntaxNode> statements);
    private SyntaxNode WithAccessorStatements(SyntaxNode declaration, SyntaxKind kind, IEnumerable`1<SyntaxNode> statements);
    public virtual IReadOnlyList`1<SyntaxNode> GetBaseAndInterfaceTypes(SyntaxNode declaration);
    public virtual SyntaxNode AddBaseType(SyntaxNode declaration, SyntaxNode baseType);
    public virtual SyntaxNode AddInterfaceType(SyntaxNode declaration, SyntaxNode interfaceType);
    private static SyntaxNode AddBaseList(SyntaxNode declaration, BaseListSyntax baseList);
    private static BaseListSyntax GetBaseList(SyntaxNode declaration);
    private static SyntaxNode WithBaseList(SyntaxNode declaration, BaseListSyntax baseList);
    public virtual SyntaxNode ReplaceNode(SyntaxNode root, SyntaxNode declaration, SyntaxNode newDeclaration);
    private static bool AreInlineReplaceableSubDeclarations(SyntaxNode decl1, SyntaxNode decl2);
    private static bool AreSimilarExceptForSubDeclarations(SyntaxNode decl1, SyntaxNode decl2);
    private IEnumerable`1<SyntaxNode> SplitAndReplace(SyntaxNode multiPartDeclaration, int index, IEnumerable`1<SyntaxNode> newDeclarations);
    public virtual SyntaxNode InsertNodesBefore(SyntaxNode root, SyntaxNode declaration, IEnumerable`1<SyntaxNode> newDeclarations);
    private SyntaxNode InsertNodesBeforeInternal(SyntaxNode root, SyntaxNode declaration, IEnumerable`1<SyntaxNode> newDeclarations);
    public virtual SyntaxNode InsertNodesAfter(SyntaxNode root, SyntaxNode declaration, IEnumerable`1<SyntaxNode> newDeclarations);
    private SyntaxNode InsertNodesAfterInternal(SyntaxNode root, SyntaxNode declaration, IEnumerable`1<SyntaxNode> newDeclarations);
    private IEnumerable`1<SyntaxNode> SplitAndInsert(SyntaxNode multiPartDeclaration, int index, IEnumerable`1<SyntaxNode> newDeclarations);
    private SyntaxNode WithSubDeclarationsRemoved(SyntaxNode declaration, int index, int count);
    private static IReadOnlyList`1<SyntaxNode> GetSubDeclarations(SyntaxNode declaration);
    public virtual SyntaxNode RemoveNode(SyntaxNode root, SyntaxNode node);
    public virtual SyntaxNode RemoveNode(SyntaxNode root, SyntaxNode node, SyntaxRemoveOptions options);
    private SyntaxNode RemoveNodeInternal(SyntaxNode root, SyntaxNode declaration, SyntaxRemoveOptions options);
    private static SyntaxNode ShiftTrivia(SyntaxNode root, SyntaxNode node);
    internal virtual bool IsRegularOrDocComment(SyntaxTrivia trivia);
    public virtual SyntaxNode AddEventHandler(SyntaxNode event, SyntaxNode handler);
    public virtual SyntaxNode RemoveEventHandler(SyntaxNode event, SyntaxNode handler);
    public virtual SyntaxNode AwaitExpression(SyntaxNode expression);
    public virtual SyntaxNode NameOfExpression(SyntaxNode expression);
    public virtual SyntaxNode ReturnStatement(SyntaxNode expressionOpt);
    public virtual SyntaxNode ThrowStatement(SyntaxNode expressionOpt);
    public virtual SyntaxNode ThrowExpression(SyntaxNode expression);
    internal virtual bool SupportsThrowExpression();
    public virtual SyntaxNode IfStatement(SyntaxNode condition, IEnumerable`1<SyntaxNode> trueStatements, IEnumerable`1<SyntaxNode> falseStatements);
    private static BlockSyntax CreateBlock(IEnumerable`1<SyntaxNode> statements);
    private static SyntaxList`1<StatementSyntax> AsStatementList(IEnumerable`1<SyntaxNode> nodes);
    private static StatementSyntax AsStatement(SyntaxNode node);
    public virtual SyntaxNode ExpressionStatement(SyntaxNode expression);
    internal virtual SyntaxNode MemberAccessExpressionWorker(SyntaxNode expression, SyntaxNode simpleName);
    public virtual SyntaxNode ConditionalAccessExpression(SyntaxNode expression, SyntaxNode whenNotNull);
    public virtual SyntaxNode MemberBindingExpression(SyntaxNode name);
    public virtual SyntaxNode ElementBindingExpression(IEnumerable`1<SyntaxNode> arguments);
    private static ExpressionSyntax ParenthesizeLeft(ExpressionSyntax expression);
    private static SeparatedSyntaxList`1<ExpressionSyntax> AsExpressionList(IEnumerable`1<SyntaxNode> expressions);
    public virtual SyntaxNode ArrayCreationExpression(SyntaxNode elementType, SyntaxNode size);
    public virtual SyntaxNode ArrayCreationExpression(SyntaxNode elementType, IEnumerable`1<SyntaxNode> elements);
    public virtual SyntaxNode ObjectCreationExpression(SyntaxNode type, IEnumerable`1<SyntaxNode> arguments);
    internal virtual SyntaxNode ObjectCreationExpression(SyntaxNode type, SyntaxToken openParen, SeparatedSyntaxList`1<SyntaxNode> arguments, SyntaxToken closeParen);
    private static ArgumentListSyntax CreateArgumentList(IEnumerable`1<SyntaxNode> arguments);
    private static SeparatedSyntaxList`1<ArgumentSyntax> CreateArguments(IEnumerable`1<SyntaxNode> arguments);
    private static ArgumentSyntax AsArgument(SyntaxNode argOrExpression);
    public virtual SyntaxNode InvocationExpression(SyntaxNode expression, IEnumerable`1<SyntaxNode> arguments);
    public virtual SyntaxNode ElementAccessExpression(SyntaxNode expression, IEnumerable`1<SyntaxNode> arguments);
    internal virtual SyntaxToken NumericLiteralToken(string text, ulong value);
    public virtual SyntaxNode DefaultExpression(SyntaxNode type);
    public virtual SyntaxNode DefaultExpression(ITypeSymbol type);
    private static SyntaxNode Parenthesize(SyntaxNode expression, bool includeElasticTrivia, bool addSimplifierAnnotation);
    public virtual SyntaxNode IsTypeExpression(SyntaxNode expression, SyntaxNode type);
    public virtual SyntaxNode TypeOfExpression(SyntaxNode type);
    public virtual SyntaxNode TryCastExpression(SyntaxNode expression, SyntaxNode type);
    public virtual SyntaxNode CastExpression(SyntaxNode type, SyntaxNode expression);
    public virtual SyntaxNode ConvertExpression(SyntaxNode type, SyntaxNode expression);
    public virtual SyntaxNode AssignmentStatement(SyntaxNode left, SyntaxNode right);
    private static SyntaxNode CreateBinaryExpression(SyntaxKind syntaxKind, SyntaxNode left, SyntaxNode right);
    public virtual SyntaxNode ValueEqualsExpression(SyntaxNode left, SyntaxNode right);
    public virtual SyntaxNode ReferenceEqualsExpression(SyntaxNode left, SyntaxNode right);
    public virtual SyntaxNode ValueNotEqualsExpression(SyntaxNode left, SyntaxNode right);
    public virtual SyntaxNode ReferenceNotEqualsExpression(SyntaxNode left, SyntaxNode right);
    public virtual SyntaxNode LessThanExpression(SyntaxNode left, SyntaxNode right);
    public virtual SyntaxNode LessThanOrEqualExpression(SyntaxNode left, SyntaxNode right);
    public virtual SyntaxNode GreaterThanExpression(SyntaxNode left, SyntaxNode right);
    public virtual SyntaxNode GreaterThanOrEqualExpression(SyntaxNode left, SyntaxNode right);
    public virtual SyntaxNode NegateExpression(SyntaxNode expression);
    public virtual SyntaxNode AddExpression(SyntaxNode left, SyntaxNode right);
    public virtual SyntaxNode SubtractExpression(SyntaxNode left, SyntaxNode right);
    public virtual SyntaxNode MultiplyExpression(SyntaxNode left, SyntaxNode right);
    public virtual SyntaxNode DivideExpression(SyntaxNode left, SyntaxNode right);
    public virtual SyntaxNode ModuloExpression(SyntaxNode left, SyntaxNode right);
    public virtual SyntaxNode BitwiseAndExpression(SyntaxNode left, SyntaxNode right);
    public virtual SyntaxNode BitwiseOrExpression(SyntaxNode left, SyntaxNode right);
    public virtual SyntaxNode BitwiseNotExpression(SyntaxNode operand);
    public virtual SyntaxNode LogicalAndExpression(SyntaxNode left, SyntaxNode right);
    public virtual SyntaxNode LogicalOrExpression(SyntaxNode left, SyntaxNode right);
    public virtual SyntaxNode LogicalNotExpression(SyntaxNode expression);
    public virtual SyntaxNode ConditionalExpression(SyntaxNode condition, SyntaxNode whenTrue, SyntaxNode whenFalse);
    public virtual SyntaxNode CoalesceExpression(SyntaxNode left, SyntaxNode right);
    public virtual SyntaxNode ThisExpression();
    public virtual SyntaxNode BaseExpression();
    public virtual SyntaxNode LiteralExpression(object value);
    public virtual SyntaxNode TypedConstantExpression(TypedConstant value);
    public virtual SyntaxNode IdentifierName(string identifier);
    public virtual SyntaxNode GenericName(string identifier, IEnumerable`1<SyntaxNode> typeArguments);
    internal virtual SyntaxNode GenericName(SyntaxToken identifier, IEnumerable`1<SyntaxNode> typeArguments);
    public virtual SyntaxNode WithTypeArguments(SyntaxNode expression, IEnumerable`1<SyntaxNode> typeArguments);
    public virtual SyntaxNode QualifiedName(SyntaxNode left, SyntaxNode right);
    internal virtual SyntaxNode GlobalAliasedName(SyntaxNode name);
    public virtual SyntaxNode NameExpression(INamespaceOrTypeSymbol namespaceOrTypeSymbol);
    public virtual SyntaxNode TypeExpression(ITypeSymbol typeSymbol);
    public virtual SyntaxNode TypeExpression(SpecialType specialType);
    public virtual SyntaxNode ArrayTypeExpression(SyntaxNode type);
    public virtual SyntaxNode NullableTypeExpression(SyntaxNode type);
    internal virtual SyntaxNode CreateTupleType(IEnumerable`1<SyntaxNode> elements);
    public virtual SyntaxNode TupleElementExpression(SyntaxNode type, string name);
    public virtual SyntaxNode Argument(string nameOpt, RefKind refKind, SyntaxNode expression);
    public virtual SyntaxNode LocalDeclarationStatement(SyntaxNode type, string name, SyntaxNode initializer, bool isConst);
    public virtual SyntaxNode UsingStatement(SyntaxNode type, string name, SyntaxNode expression, IEnumerable`1<SyntaxNode> statements);
    public virtual SyntaxNode UsingStatement(SyntaxNode expression, IEnumerable`1<SyntaxNode> statements);
    public virtual SyntaxNode LockStatement(SyntaxNode expression, IEnumerable`1<SyntaxNode> statements);
    public virtual SyntaxNode TryCatchStatement(IEnumerable`1<SyntaxNode> tryStatements, IEnumerable`1<SyntaxNode> catchClauses, IEnumerable`1<SyntaxNode> finallyStatements);
    public virtual SyntaxNode CatchClause(SyntaxNode type, string name, IEnumerable`1<SyntaxNode> statements);
    public virtual SyntaxNode WhileStatement(SyntaxNode condition, IEnumerable`1<SyntaxNode> statements);
    public virtual SyntaxNode SwitchStatement(SyntaxNode expression, IEnumerable`1<SyntaxNode> caseClauses);
    public virtual SyntaxNode SwitchSection(IEnumerable`1<SyntaxNode> expressions, IEnumerable`1<SyntaxNode> statements);
    internal virtual SyntaxNode SwitchSectionFromLabels(IEnumerable`1<SyntaxNode> labels, IEnumerable`1<SyntaxNode> statements);
    public virtual SyntaxNode DefaultSwitchSection(IEnumerable`1<SyntaxNode> statements);
    private static SyntaxList`1<SwitchLabelSyntax> AsSwitchLabels(IEnumerable`1<SyntaxNode> expressions);
    public virtual SyntaxNode ExitSwitchStatement();
    internal virtual SyntaxNode ScopeBlock(IEnumerable`1<SyntaxNode> statements);
    public virtual SyntaxNode ValueReturningLambdaExpression(IEnumerable`1<SyntaxNode> parameterDeclarations, SyntaxNode expression);
    private static bool IsSimpleLambdaParameter(SyntaxNode node);
    public virtual SyntaxNode VoidReturningLambdaExpression(IEnumerable`1<SyntaxNode> lambdaParameters, SyntaxNode expression);
    public virtual SyntaxNode ValueReturningLambdaExpression(IEnumerable`1<SyntaxNode> parameterDeclarations, IEnumerable`1<SyntaxNode> statements);
    public virtual SyntaxNode VoidReturningLambdaExpression(IEnumerable`1<SyntaxNode> lambdaParameters, IEnumerable`1<SyntaxNode> statements);
    public virtual SyntaxNode LambdaParameter(string identifier, SyntaxNode type);
    internal virtual SyntaxNode IdentifierName(SyntaxToken identifier);
    internal virtual SyntaxNode NamedAnonymousObjectMemberDeclarator(SyntaxNode identifier, SyntaxNode expression);
    public virtual SyntaxNode TupleExpression(IEnumerable`1<SyntaxNode> arguments);
    internal virtual SyntaxNode RemoveAllComments(SyntaxNode node);
    internal virtual SyntaxTriviaList RemoveCommentLines(SyntaxTriviaList syntaxTriviaList);
    internal virtual SyntaxNode ParseExpression(string stringToParse);
    [CompilerGeneratedAttribute]
private SyntaxNode <AsInterfaceMember>b__63_0(SyntaxNode member);
    [CompilerGeneratedAttribute]
internal static void <Flatten>g__FlattenDeclaration|100_0(ArrayBuilder`1<SyntaxNode> builder, SyntaxNode declaration, VariableDeclarationSyntax variableDeclaration);
    [IteratorStateMachineAttribute("Microsoft.CodeAnalysis.CSharp.CodeGeneration.CSharpSyntaxGenerator/<<RemoveCommentLines>g__splitIntoLines|307_0>d")]
[CompilerGeneratedAttribute]
internal static IEnumerable`1<IEnumerable`1<SyntaxTrivia>> <RemoveCommentLines>g__splitIntoLines|307_0(SyntaxTriviaList triviaList);
}
[ExportLanguageServiceAttribute("Microsoft.CodeAnalysis.Editing.SyntaxGeneratorInternal", "C#", "Default")]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.CSharp.CodeGeneration.CSharpSyntaxGeneratorInternal : SyntaxGeneratorInternal {
    public static SyntaxGeneratorInternal Instance;
    internal ISyntaxFacts SyntaxFacts { get; }
    private static CSharpSyntaxGeneratorInternal();
    internal virtual ISyntaxFacts get_SyntaxFacts();
    internal virtual SyntaxTrivia EndOfLine(string text);
    internal virtual SyntaxNode LocalDeclarationStatement(SyntaxNode type, SyntaxToken name, SyntaxNode initializer, bool isConst);
    internal virtual SyntaxNode WithInitializer(SyntaxNode variableDeclarator, SyntaxNode initializer);
    internal virtual SyntaxNode EqualsValueClause(SyntaxToken operatorToken, SyntaxNode value);
    internal static VariableDeclarationSyntax VariableDeclaration(SyntaxNode type, SyntaxToken name, SyntaxNode expression);
    internal virtual SyntaxToken Identifier(string identifier);
    internal virtual SyntaxNode ConditionalAccessExpression(SyntaxNode expression, SyntaxNode whenNotNull);
    internal virtual SyntaxNode MemberBindingExpression(SyntaxNode name);
    internal virtual SyntaxNode RefExpression(SyntaxNode expression);
    internal virtual SyntaxNode AddParentheses(SyntaxNode expressionOrPattern, bool includeElasticTrivia, bool addSimplifierAnnotation);
    internal static SyntaxNode Parenthesize(SyntaxNode expressionOrPattern, bool includeElasticTrivia, bool addSimplifierAnnotation);
    internal virtual SyntaxNode YieldReturnStatement(SyntaxNode expressionOpt);
    internal virtual bool RequiresLocalDeclarationType();
    internal virtual SyntaxNode InterpolatedStringExpression(SyntaxToken startToken, IEnumerable`1<SyntaxNode> content, SyntaxToken endToken);
    internal virtual SyntaxNode InterpolatedStringText(SyntaxToken textToken);
    internal virtual SyntaxToken InterpolatedStringTextToken(string content, string value);
    internal virtual SyntaxNode Interpolation(SyntaxNode syntaxNode);
    internal virtual SyntaxNode InterpolationAlignmentClause(SyntaxNode alignment);
    internal virtual SyntaxNode InterpolationFormatClause(string format);
    internal virtual SyntaxNode TypeParameterList(IEnumerable`1<string> typeParameterNames);
    internal static SyntaxTokenList GetParameterModifiers(RefKind refKind, bool forFunctionPointerReturnParameter);
    internal virtual bool SupportsPatterns(ParseOptions options);
    internal virtual SyntaxNode IsPatternExpression(SyntaxNode expression, SyntaxToken isKeyword, SyntaxNode pattern);
    internal virtual SyntaxNode ConstantPattern(SyntaxNode expression);
    internal virtual SyntaxNode DeclarationPattern(INamedTypeSymbol type, string name);
    internal virtual SyntaxNode AndPattern(SyntaxNode left, SyntaxNode right);
    internal virtual SyntaxNode NotPattern(SyntaxNode pattern);
    internal virtual SyntaxNode OrPattern(SyntaxNode left, SyntaxNode right);
    internal virtual SyntaxNode ParenthesizedPattern(SyntaxNode pattern);
    internal virtual SyntaxNode TypePattern(SyntaxNode type);
}
internal static class Microsoft.CodeAnalysis.CSharp.CodeGeneration.DestructorGenerator : object {
    private static MemberDeclarationSyntax LastConstructorOrField(SyntaxList`1<MemberDeclarationSyntax> members);
    internal static TypeDeclarationSyntax AddDestructorTo(TypeDeclarationSyntax destination, IMethodSymbol destructor, CodeGenerationOptions options, IList`1<bool> availableIndices);
    internal static DestructorDeclarationSyntax GenerateDestructorDeclaration(IMethodSymbol destructor, CodeGenerationOptions options);
    private static BlockSyntax GenerateBlock(IMethodSymbol constructor);
}
internal static class Microsoft.CodeAnalysis.CSharp.CodeGeneration.EnumMemberGenerator : object {
    internal static EnumDeclarationSyntax AddEnumMemberTo(EnumDeclarationSyntax destination, IFieldSymbol enumMember, CodeGenerationOptions options);
    public static EnumMemberDeclarationSyntax GenerateEnumMemberDeclaration(IFieldSymbol enumMember, EnumDeclarationSyntax destinationOpt, CodeGenerationOptions options);
    private static ExpressionSyntax CreateEnumMemberValue(EnumDeclarationSyntax destinationOpt, IFieldSymbol enumMember);
}
internal static class Microsoft.CodeAnalysis.CSharp.CodeGeneration.EventGenerator : object {
    private static MemberDeclarationSyntax AfterMember(SyntaxList`1<MemberDeclarationSyntax> members, MemberDeclarationSyntax eventDeclaration);
    private static MemberDeclarationSyntax BeforeMember(SyntaxList`1<MemberDeclarationSyntax> members, MemberDeclarationSyntax eventDeclaration);
    internal static CompilationUnitSyntax AddEventTo(CompilationUnitSyntax destination, IEventSymbol event, CodeGenerationOptions options, IList`1<bool> availableIndices);
    internal static TypeDeclarationSyntax AddEventTo(TypeDeclarationSyntax destination, IEventSymbol event, CodeGenerationOptions options, IList`1<bool> availableIndices);
    public static MemberDeclarationSyntax GenerateEventDeclaration(IEventSymbol event, CodeGenerationDestination destination, CodeGenerationOptions options);
    private static MemberDeclarationSyntax GenerateEventFieldDeclaration(IEventSymbol event, CodeGenerationDestination destination, CodeGenerationOptions options);
    private static MemberDeclarationSyntax GenerateEventDeclarationWorker(IEventSymbol event, CodeGenerationDestination destination, CodeGenerationOptions options);
    private static AccessorListSyntax GenerateAccessorList(IEventSymbol event, CodeGenerationDestination destination, CodeGenerationOptions options);
    private static AccessorDeclarationSyntax GenerateAccessorDeclaration(IEventSymbol event, IMethodSymbol accessor, SyntaxKind kind, CodeGenerationDestination destination, CodeGenerationOptions options);
    private static AccessorDeclarationSyntax GenerateAccessorDeclaration(IMethodSymbol accessor, SyntaxKind kind, bool hasBody);
    private static BlockSyntax GenerateBlock(IMethodSymbol accessor);
    private static bool HasAccessorBodies(IEventSymbol event, CodeGenerationDestination destination, IMethodSymbol accessor);
    private static SyntaxTokenList GenerateModifiers(IEventSymbol event, CodeGenerationDestination destination, CodeGenerationOptions options);
}
internal static class Microsoft.CodeAnalysis.CSharp.CodeGeneration.ExpressionGenerator : object {
    internal static ExpressionSyntax GenerateExpression(TypedConstant typedConstant);
    private static ExpressionSyntax GenerateNullLiteral();
    internal static ExpressionSyntax GenerateExpression(ITypeSymbol type, object value, bool canUseFieldReference);
    internal static ExpressionSyntax GenerateNonEnumValueExpression(ITypeSymbol type, object value, bool canUseFieldReference);
    private static ExpressionSyntax GenerateBooleanLiteralExpression(bool val);
    private static ExpressionSyntax GenerateStringLiteralExpression(string val);
    private static ExpressionSyntax GenerateCharLiteralExpression(char val);
    private static string DetermineSuffix(ITypeSymbol type, object value);
    private static ExpressionSyntax GenerateDoubleLiteralExpression(ITypeSymbol type, double value, bool canUseFieldReference);
    private static ExpressionSyntax GenerateSingleLiteralExpression(ITypeSymbol type, float value, bool canUseFieldReference);
    private static ExpressionSyntax GenerateNonNegativeLiteralExpression(ITypeSymbol type, T value, IEnumerable`1<KeyValuePair`2<T, string>> constants, string formatString, bool canUseFieldReference, Func`3<string, T, SyntaxToken> tokenFactory);
    private static ExpressionSyntax GenerateLiteralExpression(ITypeSymbol type, T value, IEnumerable`1<KeyValuePair`2<T, string>> constants, string formatString, bool canUseFieldReference, Func`3<string, T, SyntaxToken> tokenFactory, Func`2<T, bool> isNegative, Func`2<T, T> negate, string integerMinValueString);
    private static ExpressionSyntax GenerateFieldReference(ITypeSymbol type, T value, IEnumerable`1<KeyValuePair`2<T, string>> constants);
    private static ExpressionSyntax GenerateMemberAccess(String[] names);
}
internal static class Microsoft.CodeAnalysis.CSharp.CodeGeneration.FieldGenerator : object {
    private static MemberDeclarationSyntax LastField(SyntaxList`1<MemberDeclarationSyntax> members, FieldDeclarationSyntax fieldDeclaration);
    internal static CompilationUnitSyntax AddFieldTo(CompilationUnitSyntax destination, IFieldSymbol field, CodeGenerationOptions options, IList`1<bool> availableIndices);
    internal static TypeDeclarationSyntax AddFieldTo(TypeDeclarationSyntax destination, IFieldSymbol field, CodeGenerationOptions options, IList`1<bool> availableIndices);
    public static FieldDeclarationSyntax GenerateFieldDeclaration(IFieldSymbol field, CodeGenerationOptions options);
    private static EqualsValueClauseSyntax GenerateEqualsValue(IFieldSymbol field);
    private static SyntaxTokenList GenerateModifiers(IFieldSymbol field, CodeGenerationOptions options);
}
internal static class Microsoft.CodeAnalysis.CSharp.CodeGeneration.MethodGenerator : object {
    internal static NamespaceDeclarationSyntax AddMethodTo(NamespaceDeclarationSyntax destination, IMethodSymbol method, CodeGenerationOptions options, IList`1<bool> availableIndices);
    internal static CompilationUnitSyntax AddMethodTo(CompilationUnitSyntax destination, IMethodSymbol method, CodeGenerationOptions options, IList`1<bool> availableIndices);
    internal static TypeDeclarationSyntax AddMethodTo(TypeDeclarationSyntax destination, IMethodSymbol method, CodeGenerationOptions options, IList`1<bool> availableIndices);
    public static MethodDeclarationSyntax GenerateMethodDeclaration(IMethodSymbol method, CodeGenerationDestination destination, CodeGenerationOptions options, ParseOptions parseOptions);
    public static LocalFunctionStatementSyntax GenerateLocalFunctionDeclaration(IMethodSymbol method, CodeGenerationDestination destination, CodeGenerationOptions options, ParseOptions parseOptions);
    private static MethodDeclarationSyntax GenerateMethodDeclarationWorker(IMethodSymbol method, CodeGenerationDestination destination, CodeGenerationOptions options, ParseOptions parseOptions);
    private static LocalFunctionStatementSyntax GenerateLocalFunctionDeclarationWorker(IMethodSymbol method, CodeGenerationDestination destination, CodeGenerationOptions options, ParseOptions parseOptions);
    private static MethodDeclarationSyntax UseExpressionBodyIfDesired(CodeGenerationOptions options, MethodDeclarationSyntax methodDeclaration, ParseOptions parseOptions);
    private static LocalFunctionStatementSyntax UseExpressionBodyIfDesired(CodeGenerationOptions options, LocalFunctionStatementSyntax localFunctionDeclaration, ParseOptions parseOptions);
    private static SyntaxList`1<AttributeListSyntax> GenerateAttributes(IMethodSymbol method, CodeGenerationOptions options, bool isExplicit);
    private static SyntaxList`1<TypeParameterConstraintClauseSyntax> GenerateConstraintClauses(IMethodSymbol method);
    private static TypeParameterListSyntax GenerateTypeParameterList(IMethodSymbol method, CodeGenerationOptions options);
    private static SyntaxTokenList GenerateModifiers(IMethodSymbol method, CodeGenerationDestination destination, CodeGenerationOptions options);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal static class Microsoft.CodeAnalysis.CSharp.CodeGeneration.NamedTypeGenerator : object {
    public static TypeDeclarationSyntax AddNamedTypeTo(ICodeGenerationService service, TypeDeclarationSyntax destination, INamedTypeSymbol namedType, CodeGenerationOptions options, IList`1<bool> availableIndices, CancellationToken cancellationToken);
    public static NamespaceDeclarationSyntax AddNamedTypeTo(ICodeGenerationService service, NamespaceDeclarationSyntax destination, INamedTypeSymbol namedType, CodeGenerationOptions options, IList`1<bool> availableIndices, CancellationToken cancellationToken);
    public static CompilationUnitSyntax AddNamedTypeTo(ICodeGenerationService service, CompilationUnitSyntax destination, INamedTypeSymbol namedType, CodeGenerationOptions options, IList`1<bool> availableIndices, CancellationToken cancellationToken);
    public static MemberDeclarationSyntax GenerateNamedTypeDeclaration(ICodeGenerationService service, INamedTypeSymbol namedType, CodeGenerationDestination destination, CodeGenerationOptions options, CancellationToken cancellationToken);
    private static RecordDeclarationSyntax GenerateRecordMembers(ICodeGenerationService service, CodeGenerationOptions options, RecordDeclarationSyntax recordDeclaration, ImmutableArray`1<ISymbol> members, CancellationToken cancellationToken);
    public static MemberDeclarationSyntax UpdateNamedTypeDeclaration(ICodeGenerationService service, MemberDeclarationSyntax declaration, IList`1<ISymbol> newMembers, CodeGenerationOptions options, CancellationToken cancellationToken);
    private static MemberDeclarationSyntax GetDeclarationSyntaxWithoutMembers(INamedTypeSymbol namedType, CodeGenerationDestination destination, CodeGenerationOptions options);
    private static MemberDeclarationSyntax RemoveAllMembers(MemberDeclarationSyntax declaration);
    private static MemberDeclarationSyntax GetDeclarationSyntaxWithoutMembersWorker(INamedTypeSymbol namedType, CodeGenerationDestination destination, CodeGenerationOptions options);
    private static DelegateDeclarationSyntax GenerateDelegateDeclaration(INamedTypeSymbol namedType, CodeGenerationDestination destination, CodeGenerationOptions options);
    private static EnumDeclarationSyntax GenerateEnumDeclaration(INamedTypeSymbol namedType, CodeGenerationDestination destination, CodeGenerationOptions options);
    private static SyntaxList`1<AttributeListSyntax> GenerateAttributeDeclarations(INamedTypeSymbol namedType, CodeGenerationOptions options);
    private static SyntaxTokenList GenerateModifiers(INamedTypeSymbol namedType, CodeGenerationDestination destination, CodeGenerationOptions options);
    private static TypeParameterListSyntax GenerateTypeParameterList(INamedTypeSymbol namedType, CodeGenerationOptions options);
    private static BaseListSyntax GenerateBaseList(INamedTypeSymbol namedType);
    private static SyntaxList`1<TypeParameterConstraintClauseSyntax> GenerateConstraintClauses(INamedTypeSymbol namedType);
}
internal static class Microsoft.CodeAnalysis.CSharp.CodeGeneration.NamespaceGenerator : object {
    public static NamespaceDeclarationSyntax AddNamespaceTo(ICodeGenerationService service, NamespaceDeclarationSyntax destination, INamespaceSymbol namespace, CodeGenerationOptions options, IList`1<bool> availableIndices, CancellationToken cancellationToken);
    public static CompilationUnitSyntax AddNamespaceTo(ICodeGenerationService service, CompilationUnitSyntax destination, INamespaceSymbol namespace, CodeGenerationOptions options, IList`1<bool> availableIndices, CancellationToken cancellationToken);
    internal static SyntaxNode GenerateNamespaceDeclaration(ICodeGenerationService service, INamespaceSymbol namespace, CodeGenerationOptions options, CancellationToken cancellationToken);
    public static SyntaxNode UpdateCompilationUnitOrNamespaceDeclaration(ICodeGenerationService service, SyntaxNode declaration, IList`1<ISymbol> newMembers, CodeGenerationOptions options, CancellationToken cancellationToken);
    private static SyntaxNode GenerateNamespaceDeclarationWorker(string name, INamespaceSymbol innermostNamespace);
    private static SyntaxNode GetDeclarationSyntaxWithoutMembers(INamespaceSymbol namespace, INamespaceSymbol innermostNamespace, string name, CodeGenerationOptions options);
    private static SyntaxNode RemoveAllMembers(SyntaxNode declaration);
    private static SyntaxList`1<UsingDirectiveSyntax> GenerateUsingDirectives(INamespaceSymbol innermostNamespace);
    private static UsingDirectiveSyntax GenerateUsingDirective(ISymbol symbol);
    private static NameSyntax GenerateName(INamespaceOrTypeSymbol symbol);
}
internal static class Microsoft.CodeAnalysis.CSharp.CodeGeneration.OperatorGenerator : object {
    internal static TypeDeclarationSyntax AddOperatorTo(TypeDeclarationSyntax destination, IMethodSymbol method, CodeGenerationOptions options, IList`1<bool> availableIndices);
    internal static OperatorDeclarationSyntax GenerateOperatorDeclaration(IMethodSymbol method, CodeGenerationOptions options, ParseOptions parseOptions);
    private static OperatorDeclarationSyntax UseExpressionBodyIfDesired(CodeGenerationOptions options, OperatorDeclarationSyntax declaration, ParseOptions parseOptions);
    private static OperatorDeclarationSyntax GenerateOperatorDeclarationWorker(IMethodSymbol method, CodeGenerationOptions options, ParseOptions parseOptions);
    private static SyntaxTokenList GenerateModifiers();
}
internal static class Microsoft.CodeAnalysis.CSharp.CodeGeneration.ParameterGenerator : object {
    public static ParameterListSyntax GenerateParameterList(ImmutableArray`1<IParameterSymbol> parameterDefinitions, bool isExplicit, CodeGenerationOptions options);
    public static ParameterListSyntax GenerateParameterList(IEnumerable`1<IParameterSymbol> parameterDefinitions, bool isExplicit, CodeGenerationOptions options);
    public static BracketedParameterListSyntax GenerateBracketedParameterList(ImmutableArray`1<IParameterSymbol> parameterDefinitions, bool isExplicit, CodeGenerationOptions options);
    public static BracketedParameterListSyntax GenerateBracketedParameterList(IEnumerable`1<IParameterSymbol> parameterDefinitions, bool isExplicit, CodeGenerationOptions options);
    internal static ImmutableArray`1<ParameterSyntax> GetParameters(IEnumerable`1<IParameterSymbol> parameterDefinitions, bool isExplicit, CodeGenerationOptions options);
    internal static ParameterSyntax GetParameter(IParameterSymbol p, CodeGenerationOptions options, bool isExplicit, bool isFirstParam, bool seenOptional);
    private static SyntaxTokenList GenerateModifiers(IParameterSymbol parameter, bool isFirstParam);
    private static EqualsValueClauseSyntax GenerateEqualsValueClause(IParameterSymbol parameter, bool isExplicit, bool seenOptional);
    private static ExpressionSyntax GenerateEqualsValueClauseWorker(IParameterSymbol parameter, object value);
    private static SyntaxList`1<AttributeListSyntax> GenerateAttributes(IParameterSymbol parameter, bool isExplicit, CodeGenerationOptions options);
}
internal static class Microsoft.CodeAnalysis.CSharp.CodeGeneration.PropertyGenerator : object {
    public static bool CanBeGenerated(IPropertySymbol property);
    private static MemberDeclarationSyntax LastPropertyOrField(SyntaxList`1<MemberDeclarationSyntax> members);
    internal static CompilationUnitSyntax AddPropertyTo(CompilationUnitSyntax destination, IPropertySymbol property, CodeGenerationOptions options, IList`1<bool> availableIndices);
    internal static TypeDeclarationSyntax AddPropertyTo(TypeDeclarationSyntax destination, IPropertySymbol property, CodeGenerationOptions options, IList`1<bool> availableIndices);
    public static MemberDeclarationSyntax GeneratePropertyOrIndexer(IPropertySymbol property, CodeGenerationDestination destination, CodeGenerationOptions options, ParseOptions parseOptions);
    private static MemberDeclarationSyntax GenerateIndexerDeclaration(IPropertySymbol property, CodeGenerationDestination destination, CodeGenerationOptions options, ParseOptions parseOptions);
    private static MemberDeclarationSyntax GeneratePropertyDeclaration(IPropertySymbol property, CodeGenerationDestination destination, CodeGenerationOptions options, ParseOptions parseOptions);
    private static TypeSyntax GenerateTypeSyntax(IPropertySymbol property);
    private static bool TryGetExpressionBody(BasePropertyDeclarationSyntax baseProperty, ParseOptions options, ExpressionBodyPreference preference, ArrowExpressionClauseSyntax& arrowExpression, SyntaxToken& semicolonToken);
    private static PropertyDeclarationSyntax UseExpressionBodyIfDesired(CodeGenerationOptions options, PropertyDeclarationSyntax declaration, ParseOptions parseOptions);
    private static IndexerDeclarationSyntax UseExpressionBodyIfDesired(CodeGenerationOptions options, IndexerDeclarationSyntax declaration, ParseOptions parseOptions);
    private static AccessorDeclarationSyntax UseExpressionBodyIfDesired(CodeGenerationOptions options, AccessorDeclarationSyntax declaration, ParseOptions parseOptions);
    private static bool TryGetArrowExpressionBody(SyntaxKind declaratoinKind, AccessorDeclarationSyntax accessor, ParseOptions options, ExpressionBodyPreference preference, ArrowExpressionClauseSyntax& arrowExpression, SyntaxToken& semicolonToken);
    private static AccessorListSyntax GenerateAccessorList(IPropertySymbol property, CodeGenerationDestination destination, CodeGenerationOptions options, ParseOptions parseOptions);
    private static AccessorDeclarationSyntax GenerateAccessorDeclaration(IPropertySymbol property, IMethodSymbol accessor, SyntaxKind kind, CodeGenerationDestination destination, CodeGenerationOptions options, ParseOptions parseOptions);
    private static AccessorDeclarationSyntax GenerateAccessorDeclaration(IPropertySymbol property, IMethodSymbol accessor, SyntaxKind kind, bool hasBody, CodeGenerationOptions options, ParseOptions parseOptions);
    private static BlockSyntax GenerateBlock(IMethodSymbol accessor);
    private static bool HasAccessorBodies(IPropertySymbol property, CodeGenerationDestination destination, IMethodSymbol accessor);
    private static SyntaxTokenList GenerateAccessorModifiers(IPropertySymbol property, IMethodSymbol accessor, CodeGenerationOptions options);
    private static SyntaxTokenList GenerateModifiers(IPropertySymbol property, CodeGenerationDestination destination, CodeGenerationOptions options);
}
internal static class Microsoft.CodeAnalysis.CSharp.CodeGeneration.StatementGenerator : object {
    internal static SyntaxList`1<StatementSyntax> GenerateStatements(IEnumerable`1<SyntaxNode> statements);
    internal static BlockSyntax GenerateBlock(IMethodSymbol method);
}
internal static class Microsoft.CodeAnalysis.CSharp.CodeGeneration.TypeParameterGenerator : object {
    public static TypeParameterListSyntax GenerateTypeParameterList(ImmutableArray`1<ITypeParameterSymbol> typeParameters, CodeGenerationOptions options);
    private static TypeParameterSyntax GenerateTypeParameter(ITypeParameterSymbol symbol, CodeGenerationOptions options);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal static class Microsoft.CodeAnalysis.CSharp.CodeStyle.CSharpCodeStyleOptionGroups : object {
    public static OptionGroup VarPreferences;
    public static OptionGroup ExpressionBodiedMembers;
    public static OptionGroup PatternMatching;
    public static OptionGroup NullCheckingPreferences;
    public static OptionGroup Modifier;
    public static OptionGroup CodeBlockPreferences;
    public static OptionGroup ExpressionLevelPreferences;
    public static OptionGroup UsingDirectivePreferences;
    public static OptionGroup NewLinePreferences;
    private static CSharpCodeStyleOptionGroups();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal static class Microsoft.CodeAnalysis.CSharp.CodeStyle.CSharpCodeStyleOptions : object {
    private static CodeStyleOption2`1<bool> s_trueWithSuggestionEnforcement;
    private static CodeStyleOption2`1<bool> s_trueWithSilentEnforcement;
    private static Builder<IOption2> s_allOptionsBuilder;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private static ImmutableArray`1<IOption2> <AllOptions>k__BackingField;
    public static Option2`1<CodeStyleOption2`1<bool>> VarForBuiltInTypes;
    public static Option2`1<CodeStyleOption2`1<bool>> VarWhenTypeIsApparent;
    public static Option2`1<CodeStyleOption2`1<bool>> VarElsewhere;
    public static Option2`1<CodeStyleOption2`1<bool>> PreferConditionalDelegateCall;
    public static Option2`1<CodeStyleOption2`1<bool>> PreferSwitchExpression;
    public static Option2`1<CodeStyleOption2`1<bool>> PreferPatternMatching;
    public static Option2`1<CodeStyleOption2`1<bool>> PreferPatternMatchingOverAsWithNullCheck;
    public static Option2`1<CodeStyleOption2`1<bool>> PreferPatternMatchingOverIsWithCastCheck;
    public static Option2`1<CodeStyleOption2`1<bool>> PreferNotPattern;
    public static Option2`1<CodeStyleOption2`1<bool>> PreferThrowExpression;
    public static Option2`1<CodeStyleOption2`1<bool>> PreferInlinedVariableDeclaration;
    public static Option2`1<CodeStyleOption2`1<bool>> PreferDeconstructedVariableDeclaration;
    public static Option2`1<CodeStyleOption2`1<bool>> PreferIndexOperator;
    public static Option2`1<CodeStyleOption2`1<bool>> PreferRangeOperator;
    public static CodeStyleOption2`1<ExpressionBodyPreference> NeverWithSilentEnforcement;
    public static CodeStyleOption2`1<ExpressionBodyPreference> NeverWithSuggestionEnforcement;
    public static CodeStyleOption2`1<ExpressionBodyPreference> WhenPossibleWithSilentEnforcement;
    public static CodeStyleOption2`1<ExpressionBodyPreference> WhenPossibleWithSuggestionEnforcement;
    public static CodeStyleOption2`1<ExpressionBodyPreference> WhenOnSingleLineWithSilentEnforcement;
    public static CodeStyleOption2`1<PreferBracesPreference> UseBracesWithSilentEnforcement;
    public static Option2`1<CodeStyleOption2`1<ExpressionBodyPreference>> PreferExpressionBodiedConstructors;
    public static Option2`1<CodeStyleOption2`1<ExpressionBodyPreference>> PreferExpressionBodiedMethods;
    public static Option2`1<CodeStyleOption2`1<ExpressionBodyPreference>> PreferExpressionBodiedOperators;
    public static Option2`1<CodeStyleOption2`1<ExpressionBodyPreference>> PreferExpressionBodiedProperties;
    public static Option2`1<CodeStyleOption2`1<ExpressionBodyPreference>> PreferExpressionBodiedIndexers;
    public static Option2`1<CodeStyleOption2`1<ExpressionBodyPreference>> PreferExpressionBodiedAccessors;
    public static Option2`1<CodeStyleOption2`1<ExpressionBodyPreference>> PreferExpressionBodiedLambdas;
    public static Option2`1<CodeStyleOption2`1<ExpressionBodyPreference>> PreferExpressionBodiedLocalFunctions;
    public static Option2`1<CodeStyleOption2`1<PreferBracesPreference>> PreferBraces;
    public static Option2`1<CodeStyleOption2`1<bool>> PreferSimpleDefaultExpression;
    private static SyntaxKind[] s_preferredModifierOrderDefault;
    public static Option2`1<CodeStyleOption2`1<string>> PreferredModifierOrder;
    public static Option2`1<CodeStyleOption2`1<bool>> PreferStaticLocalFunction;
    public static Option2`1<CodeStyleOption2`1<bool>> PreferSimpleUsingStatement;
    public static Option2`1<CodeStyleOption2`1<bool>> PreferLocalOverAnonymousFunction;
    public static CodeStyleOption2`1<AddImportPlacement> PreferOutsidePlacementWithSilentEnforcement;
    public static Option2`1<CodeStyleOption2`1<AddImportPlacement>> PreferredUsingDirectivePlacement;
    internal static Option2`1<CodeStyleOption2`1<UnusedValuePreference>> UnusedValueExpressionStatement;
    internal static Option2`1<CodeStyleOption2`1<UnusedValuePreference>> UnusedValueAssignment;
    public static Option2`1<CodeStyleOption2`1<bool>> ImplicitObjectCreationWhenTypeIsApparent;
    [CompilerGeneratedAttribute]
private static Option2`1<CodeStyleOption2`1<bool>> <AllowEmbeddedStatementsOnSameLine>k__BackingField;
    [CompilerGeneratedAttribute]
private static Option2`1<CodeStyleOption2`1<bool>> <AllowBlankLinesBetweenConsecutiveBraces>k__BackingField;
    [CompilerGeneratedAttribute]
private static Option2`1<CodeStyleOption2`1<bool>> <AllowBlankLineAfterColonInConstructorInitializer>k__BackingField;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static ImmutableArray`1<IOption2> AllOptions { get; }
    public static Option2`1<CodeStyleOption2`1<bool>> AllowEmbeddedStatementsOnSameLine { get; }
    public static Option2`1<CodeStyleOption2`1<bool>> AllowBlankLinesBetweenConsecutiveBraces { get; }
    public static Option2`1<CodeStyleOption2`1<bool>> AllowBlankLineAfterColonInConstructorInitializer { get; }
    private static CSharpCodeStyleOptions();
    [CompilerGeneratedAttribute]
internal static ImmutableArray`1<IOption2> get_AllOptions();
    private static Option2`1<T> CreateOption(OptionGroup group, string name, T defaultValue, OptionStorageLocation2[] storageLocations);
    private static Option2`1<CodeStyleOption2`1<bool>> CreateOption(OptionGroup group, string name, CodeStyleOption2`1<bool> defaultValue, string editorconfigKeyName, string roamingProfileStorageKeyName);
    private static Option2`1<CodeStyleOption2`1<string>> CreateOption(OptionGroup group, string name, CodeStyleOption2`1<string> defaultValue, string editorconfigKeyName, string roamingProfileStorageKeyName);
    private static Option2`1<CodeStyleOption2`1<ExpressionBodyPreference>> CreatePreferExpressionBodyOption(string optionName, CodeStyleOption2`1<ExpressionBodyPreference> defaultValue, string editorconfigKeyName);
    private static Option2`1<CodeStyleOption2`1<PreferBracesPreference>> CreatePreferBracesOption(string optionName, CodeStyleOption2`1<PreferBracesPreference> defaultValue, string editorconfigKeyName);
    private static Option2`1<CodeStyleOption2`1<AddImportPlacement>> CreateUsingDirectivePlacementOption(string optionName, CodeStyleOption2`1<AddImportPlacement> defaultValue, string editorconfigKeyName);
    [CompilerGeneratedAttribute]
public static Option2`1<CodeStyleOption2`1<bool>> get_AllowEmbeddedStatementsOnSameLine();
    [CompilerGeneratedAttribute]
public static Option2`1<CodeStyleOption2`1<bool>> get_AllowBlankLinesBetweenConsecutiveBraces();
    [CompilerGeneratedAttribute]
public static Option2`1<CodeStyleOption2`1<bool>> get_AllowBlankLineAfterColonInConstructorInitializer();
    [IteratorStateMachineAttribute("Microsoft.CodeAnalysis.CSharp.CodeStyle.CSharpCodeStyleOptions/<GetCodeStyleOptions>d__62")]
public static IEnumerable`1<Option2`1<CodeStyleOption2`1<bool>>> GetCodeStyleOptions();
    [IteratorStateMachineAttribute("Microsoft.CodeAnalysis.CSharp.CodeStyle.CSharpCodeStyleOptions/<GetExpressionBodyOptions>d__63")]
public static IEnumerable`1<Option2`1<CodeStyleOption2`1<ExpressionBodyPreference>>> GetExpressionBodyOptions();
    public static CodeStyleOption2`1<ExpressionBodyPreference> ParseExpressionBodyPreference(string optionString, CodeStyleOption2`1<ExpressionBodyPreference> default);
    private static string GetExpressionBodyPreferenceEditorConfigString(CodeStyleOption2`1<ExpressionBodyPreference> value, CodeStyleOption2`1<ExpressionBodyPreference> defaultValue);
    public static CodeStyleOption2`1<AddImportPlacement> ParseUsingDirectivesPlacement(string optionString, CodeStyleOption2`1<AddImportPlacement> default);
    public static string GetUsingDirectivesPlacementEditorConfigString(CodeStyleOption2`1<AddImportPlacement> value, CodeStyleOption2`1<AddImportPlacement> defaultValue);
    private static CodeStyleOption2`1<PreferBracesPreference> ParsePreferBracesPreference(string optionString, CodeStyleOption2`1<PreferBracesPreference> defaultValue);
    private static string GetPreferBracesPreferenceEditorConfigString(CodeStyleOption2`1<PreferBracesPreference> value, CodeStyleOption2`1<PreferBracesPreference> defaultValue);
}
[ExportOptionProviderAttribute("C#")]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.CSharp.CodeStyle.CSharpCodeStyleOptionsProvider : object {
    [CompilerGeneratedAttribute]
private ImmutableArray`1<IOption> <Options>k__BackingField;
    public ImmutableArray`1<IOption> Options { get; }
    [CompilerGeneratedAttribute]
public sealed virtual ImmutableArray`1<IOption> get_Options();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal static class Microsoft.CodeAnalysis.CSharp.CodeStyle.TypeStyle.TypeStyleHelper : object {
    public static bool IsBuiltInType(ITypeSymbol type);
    public static bool IsTypeApparentInAssignmentExpression(UseVarPreference stylePreferences, ExpressionSyntax initializerExpression, SemanticModel semanticModel, ITypeSymbol typeInDeclaration, CancellationToken cancellationToken);
    private static bool IsPossibleCreationOrConversionMethod(IMethodSymbol methodSymbol, ITypeSymbol typeInDeclaration, SemanticModel semanticModel, ExpressionSyntax containingTypeName, CancellationToken cancellationToken);
    private static bool IsPossibleCreationMethod(IMethodSymbol methodSymbol, ITypeSymbol typeInDeclaration, ITypeSymbol containingType);
    private static bool IsPossibleConversionMethod(IMethodSymbol methodSymbol);
    private static bool IsContainerTypeEqualToReturnType(IMethodSymbol methodSymbol, ITypeSymbol typeInDeclaration, ITypeSymbol containingType);
    [NullableContextAttribute("2")]
private static ITypeSymbol UnwrapTupleType(ITypeSymbol symbol);
    private static ExpressionSyntax GetRightmostInvocationExpression(ExpressionSyntax node);
    public static bool IsPredefinedType(TypeSyntax type);
}
[FlagsAttribute]
internal enum Microsoft.CodeAnalysis.CSharp.CodeStyle.TypeStyle.UseVarPreference : Enum {
    public int value__;
    public static UseVarPreference None;
    public static UseVarPreference ForBuiltInTypes;
    public static UseVarPreference WhenTypeIsApparent;
    public static UseVarPreference Elsewhere;
}
[ExportLanguageServiceAttribute("Microsoft.CodeAnalysis.Host.ICommandLineParserService", "C#", "Default")]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.CSharp.CSharpCommandLineParserService : object {
    public sealed virtual CommandLineArguments Parse(IEnumerable`1<string> arguments, string baseDirectory, bool isInteractive, string sdkDirectory);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExportLanguageServiceAttribute("Microsoft.CodeAnalysis.Host.ICompilationFactoryService", "C#", "Default")]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.CSharp.CSharpCompilationFactoryService : object {
    private static CSharpCompilationOptions s_defaultOptions;
    private static CSharpCompilationFactoryService();
    private sealed virtual override Compilation Microsoft.CodeAnalysis.Host.ICompilationFactoryService.CreateCompilation(string assemblyName, CompilationOptions options);
    private sealed virtual override Compilation Microsoft.CodeAnalysis.Host.ICompilationFactoryService.CreateSubmissionCompilation(string assemblyName, CompilationOptions options, Type hostObjectType);
    private sealed virtual override CompilationOptions Microsoft.CodeAnalysis.Host.ICompilationFactoryService.GetDefaultCompilationOptions();
    private sealed virtual override GeneratorDriver Microsoft.CodeAnalysis.Host.ICompilationFactoryService.CreateGeneratorDriver(ParseOptions parseOptions, ImmutableArray`1<ISourceGenerator> generators, AnalyzerConfigOptionsProvider optionsProvider, ImmutableArray`1<AdditionalText> additionalTexts);
}
internal static class Microsoft.CodeAnalysis.CSharp.CSharpCompilerExtensionsResources : object {
    private static ResourceManager s_resourceManager;
    [CompilerGeneratedAttribute]
private static CultureInfo <Culture>k__BackingField;
    internal static ResourceManager ResourceManager { get; }
    internal static CultureInfo Culture { get; internal set; }
    internal static string var_preferences { get; }
    internal static string Expression_bodied_members { get; }
    internal static string Pattern_matching_preferences { get; }
    internal static string Null_checking_preferences { get; }
    internal static string Code_block_preferences { get; }
    internal static string using_directive_preferences { get; }
    internal static string Expected_string_or_char_literal { get; }
    internal static string _0_1_is_not_supported_in_this_version { get; }
    internal static ResourceManager get_ResourceManager();
    [CompilerGeneratedAttribute]
internal static CultureInfo get_Culture();
    [CompilerGeneratedAttribute]
internal static void set_Culture(CultureInfo value);
    internal static string GetResourceString(string resourceKey, string defaultValue);
    internal static string get_var_preferences();
    internal static string get_Expression_bodied_members();
    internal static string get_Pattern_matching_preferences();
    internal static string get_Null_checking_preferences();
    internal static string get_Code_block_preferences();
    internal static string get_using_directive_preferences();
    internal static string get_Expected_string_or_char_literal();
    internal static string get__0_1_is_not_supported_in_this_version();
}
[ExportLanguageServiceAttribute("Microsoft.CodeAnalysis.ILinkedFileMergeConflictCommentAdditionService", "C#", "Default")]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.CSharp.CSharpLinkedFileMergeConflictCommentAdditionService : AbstractLinkedFileMergeConflictCommentAdditionService {
    internal virtual string GetConflictCommentText(string header, string beforeString, string afterString);
}
internal class Microsoft.CodeAnalysis.CSharp.CSharpSemanticFacts : object {
    internal static CSharpSemanticFacts Instance;
    public bool SupportsImplicitInterfaceImplementation { get; }
    public bool ExposesAnonymousFunctionParameterNames { get; }
    public bool SupportsParameterizedProperties { get; }
    private static CSharpSemanticFacts();
    public sealed virtual string GenerateNameForExpression(SemanticModel semanticModel, SyntaxNode expression, bool capitalize, CancellationToken cancellationToken);
    public sealed virtual bool get_SupportsImplicitInterfaceImplementation();
    public sealed virtual bool get_ExposesAnonymousFunctionParameterNames();
    public sealed virtual bool IsWrittenTo(SemanticModel semanticModel, SyntaxNode node, CancellationToken cancellationToken);
    public sealed virtual bool IsOnlyWrittenTo(SemanticModel semanticModel, SyntaxNode node, CancellationToken cancellationToken);
    public sealed virtual bool IsInOutContext(SemanticModel semanticModel, SyntaxNode node, CancellationToken cancellationToken);
    public sealed virtual bool IsInRefContext(SemanticModel semanticModel, SyntaxNode node, CancellationToken cancellationToken);
    public sealed virtual bool IsInInContext(SemanticModel semanticModel, SyntaxNode node, CancellationToken cancellationToken);
    public sealed virtual bool CanReplaceWithRValue(SemanticModel semanticModel, SyntaxNode expression, CancellationToken cancellationToken);
    public sealed virtual ISymbol GetDeclaredSymbol(SemanticModel semanticModel, SyntaxToken token, CancellationToken cancellationToken);
    public sealed virtual bool LastEnumValueHasInitializer(INamedTypeSymbol namedTypeSymbol);
    public sealed virtual bool get_SupportsParameterizedProperties();
    public sealed virtual bool TryGetSpeculativeSemanticModel(SemanticModel oldSemanticModel, SyntaxNode oldNode, SyntaxNode newNode, SemanticModel& speculativeModel);
    public sealed virtual ImmutableHashSet`1<string> GetAliasNameSet(SemanticModel model, CancellationToken cancellationToken);
    private static void AppendAliasNames(SyntaxList`1<UsingDirectiveSyntax> usings, Builder<string> builder);
    private void AppendAliasNames(IEnumerable`1<NamespaceDeclarationSyntax> namespaces, Builder<string> builder, CancellationToken cancellationToken);
    public sealed virtual ForEachSymbols GetForEachSymbols(SemanticModel semanticModel, SyntaxNode forEachStatement);
    public sealed virtual IMethodSymbol GetGetAwaiterMethod(SemanticModel semanticModel, SyntaxNode node);
    public sealed virtual ImmutableArray`1<IMethodSymbol> GetDeconstructionAssignmentMethods(SemanticModel semanticModel, SyntaxNode node);
    public sealed virtual ImmutableArray`1<IMethodSymbol> GetDeconstructionForEachMethods(SemanticModel semanticModel, SyntaxNode node);
    private static void FlattenDeconstructionMethods(DeconstructionInfo deconstruction, TemporaryArray`1& builder);
    public sealed virtual bool IsPartial(ITypeSymbol typeSymbol, CancellationToken cancellationToken);
    public sealed virtual IEnumerable`1<ISymbol> GetDeclaredSymbols(SemanticModel semanticModel, SyntaxNode memberDeclaration, CancellationToken cancellationToken);
    public sealed virtual IParameterSymbol FindParameterForArgument(SemanticModel semanticModel, SyntaxNode argumentNode, CancellationToken cancellationToken);
    public sealed virtual ImmutableArray`1<ISymbol> GetBestOrAllSymbols(SemanticModel semanticModel, SyntaxNode node, SyntaxToken token, CancellationToken cancellationToken);
    private static SymbolInfo GetSymbolInfo(SemanticModel semanticModel, SyntaxNode node, SyntaxToken token, CancellationToken cancellationToken);
    public sealed virtual bool IsInsideNameOfExpression(SemanticModel semanticModel, SyntaxNode node, CancellationToken cancellationToken);
}
internal class Microsoft.CodeAnalysis.CSharp.CSharpSemanticFactsService : AbstractSemanticFactsService {
    internal static CSharpSemanticFactsService Instance;
    protected ISyntaxFacts SyntaxFacts { get; }
    protected ISemanticFacts SemanticFacts { get; }
    private static CSharpSemanticFactsService();
    protected virtual ISyntaxFacts get_SyntaxFacts();
    protected virtual ISemanticFacts get_SemanticFacts();
    protected virtual SyntaxToken ToIdentifierToken(string identifier);
    protected virtual IEnumerable`1<ISymbol> GetCollidableSymbols(SemanticModel semanticModel, SyntaxNode location, SyntaxNode container, CancellationToken cancellationToken);
    public sealed virtual bool IsExpressionContext(SemanticModel semanticModel, int position, CancellationToken cancellationToken);
    public sealed virtual bool IsInExpressionTree(SemanticModel semanticModel, SyntaxNode node, INamedTypeSymbol expressionTypeOpt, CancellationToken cancellationToken);
    public sealed virtual bool IsStatementContext(SemanticModel semanticModel, int position, CancellationToken cancellationToken);
    public sealed virtual bool IsTypeContext(SemanticModel semanticModel, int position, CancellationToken cancellationToken);
    public sealed virtual bool IsNamespaceContext(SemanticModel semanticModel, int position, CancellationToken cancellationToken);
    public sealed virtual bool IsNamespaceDeclarationNameContext(SemanticModel semanticModel, int position, CancellationToken cancellationToken);
    public sealed virtual bool IsTypeDeclarationContext(SemanticModel semanticModel, int position, CancellationToken cancellationToken);
    public sealed virtual bool IsMemberDeclarationContext(SemanticModel semanticModel, int position, CancellationToken cancellationToken);
    public sealed virtual bool IsGlobalStatementContext(SemanticModel semanticModel, int position, CancellationToken cancellationToken);
    public sealed virtual bool IsLabelContext(SemanticModel semanticModel, int position, CancellationToken cancellationToken);
    public sealed virtual bool IsAttributeNameContext(SemanticModel semanticModel, int position, CancellationToken cancellationToken);
    public sealed virtual CommonConversion ClassifyConversion(SemanticModel semanticModel, SyntaxNode expression, ITypeSymbol destination);
    private sealed virtual override SyntaxToken Microsoft.CodeAnalysis.LanguageServices.ISemanticFactsService.GenerateUniqueName(SemanticModel semanticModel, SyntaxNode location, SyntaxNode containerOpt, string baseName, CancellationToken cancellationToken);
    private sealed virtual override SyntaxToken Microsoft.CodeAnalysis.LanguageServices.ISemanticFactsService.GenerateUniqueName(SemanticModel semanticModel, SyntaxNode location, SyntaxNode containerOpt, string baseName, IEnumerable`1<string> usedNames, CancellationToken cancellationToken);
    private sealed virtual override SyntaxToken Microsoft.CodeAnalysis.LanguageServices.ISemanticFactsService.GenerateUniqueName(SemanticModel semanticModel, SyntaxNode location, SyntaxNode containerOpt, string baseName, Func`2<ISymbol, bool> filter, IEnumerable`1<string> usedNames, CancellationToken cancellationToken);
    private sealed virtual override SyntaxToken Microsoft.CodeAnalysis.LanguageServices.ISemanticFactsService.GenerateUniqueLocalName(SemanticModel semanticModel, SyntaxNode location, SyntaxNode containerOpt, string baseName, CancellationToken cancellationToken);
    private sealed virtual override SyntaxToken Microsoft.CodeAnalysis.LanguageServices.ISemanticFactsService.GenerateUniqueLocalName(SemanticModel semanticModel, SyntaxNode location, SyntaxNode containerOpt, string baseName, IEnumerable`1<string> usedNames, CancellationToken cancellationToken);
    private sealed virtual override SyntaxToken Microsoft.CodeAnalysis.LanguageServices.ISemanticFactsService.GenerateUniqueName(string baseName, IEnumerable`1<string> usedNames);
}
[ExportLanguageServiceFactoryAttribute("Microsoft.CodeAnalysis.LanguageServices.ISemanticFactsService", "C#", "Default")]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.CSharp.CSharpSemanticFactsServiceFactory : object {
    public sealed virtual ILanguageService CreateLanguageService(HostLanguageServices languageServices);
}
[ExportLanguageServiceAttribute("Microsoft.CodeAnalysis.LanguageServices.ISymbolDeclarationService", "C#", "Default")]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.CSharp.CSharpSymbolDeclarationService : object {
    public sealed virtual ImmutableArray`1<SyntaxReference> GetDeclarations(ISymbol symbol);
}
[ExportLanguageServiceFactoryAttribute("Microsoft.CodeAnalysis.LanguageServices.ISyntaxFactsService", "C#", "Default")]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.CSharp.CSharpSyntaxFactsServiceFactory : object {
    public sealed virtual ILanguageService CreateLanguageService(HostLanguageServices languageServices);
}
[ExportLanguageServiceFactoryAttribute("Microsoft.CodeAnalysis.Host.ISyntaxTreeFactoryService", "C#", "Default")]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.CSharp.CSharpSyntaxTreeFactoryServiceFactory : object {
    private static CSharpParseOptions _parseOptionWithLatestLanguageVersion;
    private static CSharpSyntaxTreeFactoryServiceFactory();
    public sealed virtual ILanguageService CreateLanguageService(HostLanguageServices provider);
}
[ExportLanguageServiceAttribute("Microsoft.CodeAnalysis.LanguageServices.ITypeInferenceService", "C#", "Default")]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.CSharp.CSharpTypeInferenceService : AbstractTypeInferenceService {
    public static CSharpTypeInferenceService Instance;
    private static CSharpTypeInferenceService();
    protected virtual AbstractTypeInferrer CreateTypeInferrer(SemanticModel semanticModel, CancellationToken cancellationToken);
}
internal static class Microsoft.CodeAnalysis.CSharp.CSharpWorkspaceExtensionsResources : object {
    private static ResourceManager s_resourceManager;
    [CompilerGeneratedAttribute]
private static CultureInfo <Culture>k__BackingField;
    internal static ResourceManager ResourceManager { get; }
    internal static CultureInfo Culture { get; internal set; }
    internal static string EmptyResource { get; }
    internal static ResourceManager get_ResourceManager();
    [CompilerGeneratedAttribute]
internal static CultureInfo get_Culture();
    [CompilerGeneratedAttribute]
internal static void set_Culture(CultureInfo value);
    internal static string GetResourceString(string resourceKey, string defaultValue);
    internal static string get_EmptyResource();
}
internal static class Microsoft.CodeAnalysis.CSharp.CSharpWorkspaceResources : object {
    private static ResourceManager s_resourceManager;
    [CompilerGeneratedAttribute]
private static CultureInfo <Culture>k__BackingField;
    internal static ResourceManager ResourceManager { get; }
    internal static CultureInfo Culture { get; internal set; }
    internal static string No_available_location_found_to_add_statements_to { get; }
    internal static string Namespace_can_not_be_added_in_this_destination { get; }
    internal static string Node_does_not_descend_from_root { get; }
    internal static string Node_not_in_parent_s_child_list { get; }
    internal static string Trivia_is_not_associated_with_token { get; }
    internal static string Cannot_retrieve_the_Span_of_a_null_syntax_reference { get; }
    internal static string Only_attributes_constructor_initializers_expressions_or_statements_can_be_made_explicit { get; }
    internal static string Implement_Interface { get; }
    internal static string Indentation_preferences { get; }
    internal static string Space_preferences { get; }
    internal static string Wrapping_preferences { get; }
    internal static string Remove_and_Sort_Usings { get; }
    internal static string Sort_Usings { get; }
    internal static ResourceManager get_ResourceManager();
    [CompilerGeneratedAttribute]
internal static CultureInfo get_Culture();
    [CompilerGeneratedAttribute]
internal static void set_Culture(CultureInfo value);
    internal static string GetResourceString(string resourceKey, string defaultValue);
    internal static string get_No_available_location_found_to_add_statements_to();
    internal static string get_Namespace_can_not_be_added_in_this_destination();
    internal static string get_Node_does_not_descend_from_root();
    internal static string get_Node_not_in_parent_s_child_list();
    internal static string get_Trivia_is_not_associated_with_token();
    internal static string get_Cannot_retrieve_the_Span_of_a_null_syntax_reference();
    internal static string get_Only_attributes_constructor_initializers_expressions_or_statements_can_be_made_explicit();
    internal static string get_Implement_Interface();
    internal static string get_Indentation_preferences();
    internal static string get_Space_preferences();
    internal static string get_Wrapping_preferences();
    internal static string get_Remove_and_Sort_Usings();
    internal static string get_Sort_Usings();
}
[ExportLanguageServiceAttribute("Microsoft.CodeAnalysis.Diagnostics.IDiagnosticPropertiesService", "C#", "Default")]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.CSharp.Diagnostics.CSharpDiagnosticPropertiesService : AbstractDiagnosticPropertiesService {
    private static Compilation s_compilation;
    private static CSharpDiagnosticPropertiesService();
    protected virtual Compilation GetCompilation();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExportLanguageServiceAttribute("Microsoft.CodeAnalysis.Editing.ImportAdderService", "C#", "Default")]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.CSharp.Editing.CSharpImportAdder : ImportAdderService {
    protected virtual INamespaceSymbol GetExplicitNamespaceSymbol(SyntaxNode node, SemanticModel model);
    protected virtual void AddPotentiallyConflictingImports(SemanticModel model, SyntaxNode container, ImmutableArray`1<INamespaceSymbol> namespaceSymbols, HashSet`1<INamespaceSymbol> conflicts, CancellationToken cancellationToken);
    private static INamespaceSymbol GetExplicitNamespaceSymbol(ExpressionSyntax fullName, ExpressionSyntax namespacePart, SemanticModel model);
}
[ExportLanguageServiceAttribute("Microsoft.CodeAnalysis.EmbeddedLanguages.LanguageServices.IEmbeddedLanguagesProvider", "C#", "Default")]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.CSharp.EmbeddedLanguages.LanguageServices.CSharpEmbeddedLanguagesProvider : AbstractEmbeddedLanguagesProvider {
    public static EmbeddedLanguageInfo Info;
    private static CSharpEmbeddedLanguagesProvider();
}
[ExportLanguageServiceFactoryAttribute("Microsoft.CodeAnalysis.EmbeddedLanguages.VirtualChars.IVirtualCharLanguageService", "C#", "Default")]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.CSharp.EmbeddedLanguages.VirtualChars.CSharpVirtualCharLanguageServiceFactory : object {
    [NullableContextAttribute("1")]
public sealed virtual ILanguageService CreateLanguageService(HostLanguageServices languageServices);
}
internal class Microsoft.CodeAnalysis.CSharp.EmbeddedLanguages.VirtualChars.CSharpVirtualCharService : AbstractVirtualCharService {
    public static IVirtualCharService Instance;
    private static CSharpVirtualCharService();
    protected virtual bool IsStringOrCharLiteralToken(SyntaxToken token);
    protected virtual VirtualCharSequence TryConvertToVirtualCharsWorker(SyntaxToken token);
    private static bool IsInDirective(SyntaxNode node);
    private static VirtualCharSequence TryConvertVerbatimStringToVirtualChars(SyntaxToken token, string startDelimiter, string endDelimiter, bool escapeBraces);
    private static VirtualCharSequence TryConvertStringToVirtualChars(SyntaxToken token, string startDelimiter, string endDelimiter, bool escapeBraces);
    private static bool TryAddEscape(ArrayBuilder`1<ValueTuple`2<char, TextSpan>> result, string tokenText, int offset, int index);
    public virtual bool TryGetEscapeCharacter(VirtualChar ch, Char& escapedChar);
    private static bool TryAddSingleCharacterEscape(ArrayBuilder`1<ValueTuple`2<char, TextSpan>> result, string tokenText, int offset, int index);
    private static bool TryAddMultiCharacterEscape(ArrayBuilder`1<ValueTuple`2<char, TextSpan>> result, string tokenText, int offset, int index);
    private static bool TryAddMultiCharacterEscape(ArrayBuilder`1<ValueTuple`2<char, TextSpan>> result, string tokenText, int offset, int index, char character);
    private static int HexValue(char c);
    private static bool IsHexDigit(char c);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
internal static class Microsoft.CodeAnalysis.CSharp.Extensions.ArgumentSyntaxExtensions : object {
    [ExtensionAttribute]
public static SyntaxTokenList GenerateParameterModifiers(ArgumentSyntax argument);
    [NullableContextAttribute("2")]
[ExtensionAttribute]
public static RefKind GetRefKind(ArgumentSyntax argument);
    [ExtensionAttribute]
public static IParameterSymbol DetermineParameter(ArgumentSyntax argument, SemanticModel semanticModel, bool allowParams, CancellationToken cancellationToken);
}
[ExtensionAttribute]
internal static class Microsoft.CodeAnalysis.CSharp.Extensions.ArrowExpressionClauseSyntaxExtensions : object {
    [ExtensionAttribute]
public static bool TryConvertToBlock(ArrowExpressionClauseSyntax arrowExpression, SyntaxToken semicolonToken, bool createReturnStatementForExpression, BlockSyntax& block);
    [ExtensionAttribute]
public static bool TryConvertToStatement(ArrowExpressionClauseSyntax arrowExpression, SyntaxToken semicolonToken, bool createReturnStatementForExpression, StatementSyntax& statement);
}
[ExtensionAttribute]
internal static class Microsoft.CodeAnalysis.CSharp.Extensions.AssignmentExpressionSyntaxExtensions : object {
    [ExtensionAttribute]
internal static bool IsDeconstruction(AssignmentExpressionSyntax assignment);
}
[ExtensionAttribute]
internal static class Microsoft.CodeAnalysis.CSharp.Extensions.AttributeArgumentSyntaxExtensions : object {
    [ExtensionAttribute]
public static IParameterSymbol DetermineParameter(AttributeArgumentSyntax argument, SemanticModel semanticModel, bool allowParams, CancellationToken cancellationToken);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
internal static class Microsoft.CodeAnalysis.CSharp.Extensions.BaseArgumentListSyntaxExtensions : object {
    [ExtensionAttribute]
public static SyntaxToken GetOpenToken(BaseArgumentListSyntax node);
    [ExtensionAttribute]
public static SyntaxToken GetCloseToken(BaseArgumentListSyntax node);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
[ExtensionAttribute]
internal static class Microsoft.CodeAnalysis.CSharp.Extensions.BasePropertyDeclarationSyntaxExtensions : object {
    [ExtensionAttribute]
public static SyntaxToken TryGetSemicolonToken(BasePropertyDeclarationSyntax node);
    [ExtensionAttribute]
public static BasePropertyDeclarationSyntax TryWithSemicolonToken(BasePropertyDeclarationSyntax node, SyntaxToken semicolonToken);
    [ExtensionAttribute]
public static BasePropertyDeclarationSyntax TryWithExpressionBody(BasePropertyDeclarationSyntax node, ArrowExpressionClauseSyntax expressionBody);
}
[ExtensionAttribute]
internal static class Microsoft.CodeAnalysis.CSharp.Extensions.BlockSyntaxExtensions : object {
    [ExtensionAttribute]
public static bool TryConvertToExpressionBody(BlockSyntax block, ParseOptions options, ExpressionBodyPreference preference, ExpressionSyntax& expression, SyntaxToken& semicolonToken);
    [ExtensionAttribute]
public static bool TryConvertToArrowExpressionBody(BlockSyntax block, SyntaxKind declarationKind, ParseOptions options, ExpressionBodyPreference preference, ArrowExpressionClauseSyntax& arrowExpression, SyntaxToken& semicolonToken);
    private static bool IsSupportedInCSharp6(SyntaxKind declarationKind);
    public static bool MatchesPreference(ExpressionSyntax expression, ExpressionBodyPreference preference);
    private static bool TryGetExpression(LanguageVersion version, StatementSyntax firstStatement, ExpressionSyntax& expression, SyntaxToken& semicolonToken);
}
[ExtensionAttribute]
internal static class Microsoft.CodeAnalysis.CSharp.Extensions.CastExpressionSyntaxExtensions : object {
    [NullableContextAttribute("1")]
[ExtensionAttribute]
public static ExpressionSyntax Uncast(CastExpressionSyntax node);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
internal static class Microsoft.CodeAnalysis.CSharp.Extensions.CompilationUnitSyntaxExtensions : object {
    [ExtensionAttribute]
public static bool CanAddUsingDirectives(SyntaxNode contextNode, Document document, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static bool CanAddUsingDirectives(SyntaxNode contextNode, bool allowInHiddenRegions, CancellationToken cancellationToken);
    private static TextSpan GetUsingsSpan(CompilationUnitSyntax root, NamespaceDeclarationSyntax namespaceDeclaration);
    [ExtensionAttribute]
public static CompilationUnitSyntax AddUsingDirective(CompilationUnitSyntax root, UsingDirectiveSyntax usingDirective, SyntaxNode contextNode, bool placeSystemNamespaceFirst, SyntaxAnnotation[] annotations);
    [ExtensionAttribute]
public static CompilationUnitSyntax AddUsingDirectives(CompilationUnitSyntax root, IList`1<UsingDirectiveSyntax> usingDirectives, SyntaxNode contextNode, bool placeSystemNamespaceFirst, SyntaxAnnotation[] annotations);
    [ExtensionAttribute]
public static CompilationUnitSyntax AddUsingDirectives(CompilationUnitSyntax root, IList`1<UsingDirectiveSyntax> usingDirectives, bool placeSystemNamespaceFirst, SyntaxAnnotation[] annotations);
    private static List`1<UsingDirectiveSyntax> AddUsingDirectives(CompilationUnitSyntax root, IList`1<UsingDirectiveSyntax> usingDirectives);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.CodeAnalysis.CSharp.Extensions.ContextQuery.CSharpSyntaxContext : SyntaxContext {
    [NullableAttribute("2")]
public TypeDeclarationSyntax ContainingTypeDeclaration;
    [NullableAttribute("2")]
public BaseTypeDeclarationSyntax ContainingTypeOrEnumDeclaration;
    public bool IsInNonUserCode;
    public bool IsPreProcessorKeywordContext;
    public bool IsGlobalStatementContext;
    public bool IsNonAttributeExpressionContext;
    public bool IsConstantExpressionContext;
    public bool IsLabelContext;
    public bool IsTypeArgumentOfConstraintContext;
    public bool IsIsOrAsOrSwitchOrWithExpressionContext;
    public bool IsObjectCreationTypeContext;
    public bool IsDefiniteCastTypeContext;
    public bool IsGenericTypeArgumentContext;
    public bool IsEnumBaseListContext;
    public bool IsIsOrAsTypeContext;
    public bool IsLocalVariableDeclarationContext;
    public bool IsDeclarationExpressionContext;
    public bool IsFixedVariableDeclarationContext;
    public bool IsParameterTypeContext;
    public bool IsPossibleLambdaOrAnonymousMethodParameterTypeContext;
    public bool IsImplicitOrExplicitOperatorTypeContext;
    public bool IsPrimaryFunctionExpressionContext;
    public bool IsDelegateReturnTypeContext;
    public bool IsTypeOfExpressionContext;
    public ISet`1<SyntaxKind> PrecedingModifiers;
    public bool IsInstanceContext;
    public bool IsCrefContext;
    public bool IsCatchFilterContext;
    public bool IsDestructorTypeContext;
    public bool IsLeftSideOfImportAliasDirective;
    public bool IsFunctionPointerTypeArgumentContext;
    [NullableContextAttribute("2")]
private CSharpSyntaxContext(Workspace workspace, SemanticModel semanticModel, int position, SyntaxToken leftToken, SyntaxToken targetToken, TypeDeclarationSyntax containingTypeDeclaration, BaseTypeDeclarationSyntax containingTypeOrEnumDeclaration, bool isInNonUserCode, bool isPreProcessorDirectiveContext, bool isPreProcessorKeywordContext, bool isPreProcessorExpressionContext, bool isTypeContext, bool isNamespaceContext, bool isNamespaceDeclarationNameContext, bool isStatementContext, bool isGlobalStatementContext, bool isAnyExpressionContext, bool isNonAttributeExpressionContext, bool isConstantExpressionContext, bool isAttributeNameContext, bool isEnumTypeMemberAccessContext, bool isNameOfContext, bool isInQuery, bool isInImportsDirective, bool isLeftSideOfImportAliasDirective, bool isLabelContext, bool isTypeArgumentOfConstraintContext, bool isRightOfDotOrArrowOrColonColon, bool isIsOrAsOrSwitchOrWithExpressionContext, bool isObjectCreationTypeContext, bool isDefiniteCastTypeContext, bool isGenericTypeArgumentContext, bool isEnumBaseListContext, bool isIsOrAsTypeContext, bool isLocalVariableDeclarationContext, bool isDeclarationExpressionContext, bool isFixedVariableDeclarationContext, bool isParameterTypeContext, bool isPossibleLambdaOrAnonymousMethodParameterTypeContext, bool isImplicitOrExplicitOperatorTypeContext, bool isPrimaryFunctionExpressionContext, bool isDelegateReturnTypeContext, bool isTypeOfExpressionContext, ISet`1<SyntaxKind> precedingModifiers, bool isInstanceContext, bool isCrefContext, bool isCatchFilterContext, bool isDestructorTypeContext, bool isPossibleTupleContext, bool isStartPatternContext, bool isAfterPatternContext, bool isRightSideOfNumericType, bool isInArgumentList, bool isFunctionPointerTypeArgumentContext, CancellationToken cancellationToken);
    public static CSharpSyntaxContext CreateContext(Workspace workspace, SemanticModel semanticModel, int position, CancellationToken cancellationToken);
    private static CSharpSyntaxContext CreateContextWorker(Workspace workspace, SemanticModel semanticModel, int position, CancellationToken cancellationToken);
    public static CSharpSyntaxContext CreateContext_Test(SemanticModel semanticModel, int position, CancellationToken cancellationToken);
    private static bool IsWithinAsyncMethod();
    public bool IsTypeAttributeContext(CancellationToken cancellationToken);
    [NullableContextAttribute("2")]
public bool IsTypeDeclarationContext(ISet`1<SyntaxKind> validModifiers, ISet`1<SyntaxKind> validTypeDeclarations, bool canBePartial, CancellationToken cancellationToken);
    public bool IsMemberAttributeContext(ISet`1<SyntaxKind> validTypeDeclarations, CancellationToken cancellationToken);
    public bool IsStatementAttributeContext();
    [NullableContextAttribute("2")]
public bool IsMemberDeclarationContext(ISet`1<SyntaxKind> validModifiers, ISet`1<SyntaxKind> validTypeDeclarations, bool canBePartial, CancellationToken cancellationToken);
    private static bool IsLeftSideOfUsingAliasDirective(SyntaxToken leftToken);
    internal virtual ITypeInferenceService GetTypeInferenceServiceWithoutWorkspace();
    internal bool IsAwaitStatementContext(int position, CancellationToken cancellationToken);
}
[ExportLanguageServiceAttribute("Microsoft.CodeAnalysis.Shared.Extensions.ContextQuery.ISyntaxContextService", "C#", "Default")]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.CSharp.Extensions.ContextQuery.CSharpSyntaxContextService : object {
    [NullableContextAttribute("1")]
public sealed virtual SyntaxContext CreateContext(Workspace workspace, SemanticModel semanticModel, int position, CancellationToken cancellationToken);
}
[ExtensionAttribute]
internal static class Microsoft.CodeAnalysis.CSharp.Extensions.ContextQuery.SyntaxNodeExtensions : object {
    [NullableContextAttribute("2")]
[ExtensionAttribute]
public static bool IsDelegateOrConstructorOrLocalFunctionOrMethodOrOperatorParameterList(SyntaxNode node, bool includeOperators);
}
[ExtensionAttribute]
internal static class Microsoft.CodeAnalysis.CSharp.Extensions.ContextQuery.SyntaxTokenExtensions : object {
    [ExtensionAttribute]
public static bool IsUsingOrExternKeyword(SyntaxToken token);
    [ExtensionAttribute]
public static bool IsUsingKeywordInUsingDirective(SyntaxToken token);
    [ExtensionAttribute]
public static bool IsStaticKeywordInUsingDirective(SyntaxToken token);
    [ExtensionAttribute]
public static bool IsBeginningOfStatementContext(SyntaxToken token);
    [ExtensionAttribute]
public static bool IsBeginningOfGlobalStatementContext(SyntaxToken token);
    [ExtensionAttribute]
public static bool IsAfterPossibleCast(SyntaxToken token);
    [ExtensionAttribute]
public static bool IsLastTokenOfQueryClause(SyntaxToken token);
    [ExtensionAttribute]
public static bool IsPreProcessorExpressionContext(SyntaxToken targetToken);
    [ExtensionAttribute]
public static bool IsOrderByDirectionContext(SyntaxToken targetToken);
    [ExtensionAttribute]
public static bool IsSwitchLabelContext(SyntaxToken targetToken);
    [ExtensionAttribute]
public static bool IsXmlCrefParameterModifierContext(SyntaxToken targetToken);
    [ExtensionAttribute]
public static bool IsConstructorOrMethodParameterArgumentContext(SyntaxToken targetToken);
    [ExtensionAttribute]
public static bool IsUnaryOperatorContext(SyntaxToken targetToken);
    [ExtensionAttribute]
public static bool IsUnsafeContext(SyntaxToken targetToken);
    [ExtensionAttribute]
public static bool IsAfterYieldKeyword(SyntaxToken targetToken);
    [ExtensionAttribute]
public static bool IsAnyAccessorDeclarationContext(SyntaxToken targetToken, int position, SyntaxKind kind);
    [ExtensionAttribute]
public static bool IsAccessorDeclarationContext(SyntaxToken targetToken, int position, SyntaxKind kind);
    private static bool IsAccessorDeclarationContextWorker(SyntaxToken& targetToken);
    [NullableContextAttribute("2")]
private static bool IsGenericInterfaceOrDelegateTypeParameterList(SyntaxNode node);
    [ExtensionAttribute]
public static bool IsTypeParameterVarianceContext(SyntaxToken targetToken);
    [ExtensionAttribute]
public static bool IsMandatoryNamedParameterPosition(SyntaxToken token);
    [NullableContextAttribute("1")]
[ExtensionAttribute]
public static bool IsNumericTypeContext(SyntaxToken token, SemanticModel semanticModel, CancellationToken cancellationToken);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
internal static class Microsoft.CodeAnalysis.CSharp.Extensions.ContextQuery.SyntaxTreeExtensions : object {
    [NullableContextAttribute("0")]
[ExtensionAttribute]
public static bool IsPreProcessorDirectiveContext(SyntaxTree syntaxTree, int position, SyntaxToken preProcessorTokenOnLeftOfPosition, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static bool IsAttributeNameContext(SyntaxTree syntaxTree, int position, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static bool IsGlobalMemberDeclarationContext(SyntaxTree syntaxTree, int position, ISet`1<SyntaxKind> validModifiers, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static bool IsMemberDeclarationContext(SyntaxTree syntaxTree, int position, SyntaxToken tokenOnLeftOfPosition);
    [NullableContextAttribute("2")]
[ExtensionAttribute]
public static bool IsMemberDeclarationContext(SyntaxTree syntaxTree, int position, CSharpSyntaxContext contextOpt, ISet`1<SyntaxKind> validModifiers, ISet`1<SyntaxKind> validTypeDeclarations, bool canBePartial, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static bool IsLambdaDeclarationContext(SyntaxTree syntaxTree, int position, SyntaxKind otherModifier, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static bool IsLocalFunctionDeclarationContext(SyntaxTree syntaxTree, int position, ISet`1<SyntaxKind> validModifiers, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static bool IsTypeDeclarationContext(SyntaxTree syntaxTree, int position, SyntaxToken tokenOnLeftOfPosition, CancellationToken cancellationToken);
    [NullableContextAttribute("2")]
[ExtensionAttribute]
public static bool IsTypeDeclarationContext(SyntaxTree syntaxTree, int position, CSharpSyntaxContext contextOpt, ISet`1<SyntaxKind> validModifiers, ISet`1<SyntaxKind> validTypeDeclarations, bool canBePartial, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static bool IsNamespaceContext(SyntaxTree syntaxTree, int position, CancellationToken cancellationToken, SemanticModel semanticModelOpt);
    [ExtensionAttribute]
public static bool IsNamespaceDeclarationNameContext(SyntaxTree syntaxTree, int position, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static bool IsPartialTypeDeclarationNameContext(SyntaxTree syntaxTree, int position, CancellationToken cancellationToken, TypeDeclarationSyntax& declarationSyntax);
    [ExtensionAttribute]
public static bool IsDefinitelyNotTypeContext(SyntaxTree syntaxTree, int position, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static bool IsTypeContext(SyntaxTree syntaxTree, int position, CancellationToken cancellationToken, SemanticModel semanticModelOpt);
    [ExtensionAttribute]
public static bool IsBaseClassOrInterfaceContext(SyntaxTree syntaxTree, int position, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static bool IsUsingAliasContext(SyntaxTree syntaxTree, int position, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static bool IsUsingStaticContext(SyntaxTree syntaxTree, int position, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static bool IsTypeArgumentOfConstraintClause(SyntaxTree syntaxTree, int position, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static bool IsTypeParameterConstraintStartContext(SyntaxTree syntaxTree, int position, SyntaxToken tokenOnLeftOfPosition);
    [ExtensionAttribute]
public static bool IsTypeParameterConstraintContext(SyntaxTree syntaxTree, int position, SyntaxToken tokenOnLeftOfPosition);
    [ExtensionAttribute]
public static bool IsTypeOfExpressionContext(SyntaxTree syntaxTree, int position, SyntaxToken tokenOnLeftOfPosition);
    [ExtensionAttribute]
public static bool IsDefaultExpressionContext(SyntaxTree syntaxTree, int position, SyntaxToken tokenOnLeftOfPosition);
    [ExtensionAttribute]
public static bool IsSizeOfExpressionContext(SyntaxTree syntaxTree, int position, SyntaxToken tokenOnLeftOfPosition);
    [ExtensionAttribute]
public static bool IsFunctionPointerTypeArgumentContext(SyntaxTree syntaxTree, int position, SyntaxToken tokenOnLeftOfPosition, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static bool IsGenericTypeArgumentContext(SyntaxTree syntaxTree, int position, SyntaxToken tokenOnLeftOfPosition, CancellationToken cancellationToken, SemanticModel semanticModelOpt);
    [ExtensionAttribute]
public static bool IsParameterModifierContext(SyntaxTree syntaxTree, int position, SyntaxToken tokenOnLeftOfPosition, bool includeOperators, Int32& parameterIndex, SyntaxKind& previousModifier);
    [ExtensionAttribute]
public static bool IsParamsModifierContext(SyntaxTree syntaxTree, int position, SyntaxToken tokenOnLeftOfPosition);
    [ExtensionAttribute]
public static bool IsDelegateReturnTypeContext(SyntaxTree syntaxTree, int position, SyntaxToken tokenOnLeftOfPosition);
    [ExtensionAttribute]
public static bool IsImplicitOrExplicitOperatorTypeContext(SyntaxTree syntaxTree, int position, SyntaxToken tokenOnLeftOfPosition);
    [ExtensionAttribute]
public static bool IsParameterTypeContext(SyntaxTree syntaxTree, int position, SyntaxToken tokenOnLeftOfPosition);
    [ExtensionAttribute]
public static bool IsPossibleExtensionMethodContext(SyntaxTree syntaxTree, SyntaxToken tokenOnLeftOfPosition);
    [ExtensionAttribute]
public static bool IsPossibleLambdaParameterModifierContext(SyntaxTree syntaxTree, int position, SyntaxToken tokenOnLeftOfPosition);
    [ExtensionAttribute]
public static bool IsAnonymousMethodParameterModifierContext(SyntaxTree syntaxTree, int position, SyntaxToken tokenOnLeftOfPosition);
    [ExtensionAttribute]
public static bool IsPossibleLambdaOrAnonymousMethodParameterTypeContext(SyntaxTree syntaxTree, int position, SyntaxToken tokenOnLeftOfPosition, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static bool IsPossibleTupleContext(SyntaxTree syntaxTree, SyntaxToken leftToken, int position);
    [ExtensionAttribute]
public static bool IsAtStartOfPattern(SyntaxTree syntaxTree, SyntaxToken leftToken, int position);
    [ExtensionAttribute]
public static bool IsAtEndOfPattern(SyntaxTree syntaxTree, SyntaxToken leftToken, int position);
    private static SyntaxToken FindTokenOnLeftOfNode(SyntaxNode node);
    [ExtensionAttribute]
public static bool IsPossibleTupleOpenParenOrComma(SyntaxToken possibleCommaOrParen);
    [ExtensionAttribute]
public static bool IsPossibleDeconstructionDesignation(SyntaxTree syntaxTree, int position, CancellationToken cancellationToken);
    private static SyntaxNode UnwrapPossibleTuple(SyntaxNode node);
    private static bool IsPossibleVarDeconstructionOpenParenOrComma(SyntaxToken leftToken);
    [ExtensionAttribute]
public static bool HasNames(TupleExpressionSyntax tuple);
    [ExtensionAttribute]
public static bool IsValidContextForFromClause(SyntaxTree syntaxTree, int position, SyntaxToken tokenOnLeftOfPosition, CancellationToken cancellationToken, SemanticModel semanticModelOpt);
    [ExtensionAttribute]
public static bool IsValidContextForJoinClause(SyntaxTree syntaxTree, int position, SyntaxToken tokenOnLeftOfPosition);
    [ExtensionAttribute]
public static bool IsDeclarationExpressionContext(SyntaxTree syntaxTree, int position, SyntaxToken tokenOnLeftOfPosition);
    [ExtensionAttribute]
public static bool IsLocalVariableDeclarationContext(SyntaxTree syntaxTree, int position, SyntaxToken tokenOnLeftOfPosition, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static bool IsFixedVariableDeclarationContext(SyntaxTree syntaxTree, int position, SyntaxToken tokenOnLeftOfPosition);
    [ExtensionAttribute]
public static bool IsCatchVariableDeclarationContext(SyntaxTree syntaxTree, int position, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static bool IsIsOrAsTypeContext(SyntaxTree syntaxTree, int position, SyntaxToken tokenOnLeftOfPosition);
    [ExtensionAttribute]
public static bool IsObjectCreationTypeContext(SyntaxTree syntaxTree, int position, SyntaxToken tokenOnLeftOfPosition, CancellationToken cancellationToken);
    private static bool IsNonConstantExpressionContext(SyntaxTree syntaxTree, int position, SyntaxToken tokenOnLeftOfPosition, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static bool IsPreProcessorDirectiveContext(SyntaxTree syntaxTree, int position, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static bool IsPreProcessorKeywordContext(SyntaxTree syntaxTree, int position, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static bool IsPreProcessorKeywordContext(SyntaxTree syntaxTree, int position, SyntaxToken preProcessorTokenOnLeftOfPosition);
    [ExtensionAttribute]
public static bool IsStatementContext(SyntaxTree syntaxTree, int position, SyntaxToken tokenOnLeftOfPosition, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static bool IsGlobalStatementContext(SyntaxTree syntaxTree, int position, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static bool IsInstanceContext(SyntaxTree syntaxTree, SyntaxToken targetToken, SemanticModel semanticModel, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static bool IsPossibleCastTypeContext(SyntaxTree syntaxTree, int position, SyntaxToken tokenOnLeftOfPosition, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static bool IsDefiniteCastTypeContext(SyntaxTree syntaxTree, int position, SyntaxToken tokenOnLeftOfPosition);
    [ExtensionAttribute]
public static bool IsConstantExpressionContext(SyntaxTree syntaxTree, int position, SyntaxToken tokenOnLeftOfPosition);
    [ExtensionAttribute]
public static bool IsLabelContext(SyntaxTree syntaxTree, int position, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static bool IsExpressionContext(SyntaxTree syntaxTree, int position, SyntaxToken tokenOnLeftOfPosition, bool attributes, CancellationToken cancellationToken, SemanticModel semanticModelOpt);
    [ExtensionAttribute]
public static bool IsInvocationOfVarExpression(SyntaxToken token);
    [ExtensionAttribute]
public static bool IsNameOfContext(SyntaxTree syntaxTree, int position, SemanticModel semanticModelOpt, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static bool IsIsOrAsOrSwitchOrWithExpressionContext(SyntaxTree syntaxTree, SemanticModel semanticModel, int position, SyntaxToken tokenOnLeftOfPosition, CancellationToken cancellationToken);
    private static bool IsRightSideName(ExpressionSyntax name);
    [ExtensionAttribute]
public static bool IsCatchOrFinallyContext(SyntaxTree syntaxTree, int position, SyntaxToken tokenOnLeftOfPosition);
    [ExtensionAttribute]
public static bool IsCatchFilterContext(SyntaxTree syntaxTree, int position, SyntaxToken tokenOnLeftOfPosition);
    [ExtensionAttribute]
public static bool IsEnumBaseListContext(SyntaxTree syntaxTree, int position, SyntaxToken tokenOnLeftOfPosition);
    [ExtensionAttribute]
public static bool IsEnumTypeMemberAccessContext(SyntaxTree syntaxTree, SemanticModel semanticModel, int position, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static bool IsFunctionPointerCallingConventionContext(SyntaxTree syntaxTree, SyntaxToken targetToken);
    [CompilerGeneratedAttribute]
internal static bool <IsGlobalMemberDeclarationContext>g__IsGlobalAttributeList|2_0(AttributeListSyntax attributeList);
    [CompilerGeneratedAttribute]
internal static bool <IsAtEndOfPattern>g__IsAtEndOfSwitchStatementPattern|36_0(SyntaxToken leftToken);
}
[ExtensionAttribute]
internal static class Microsoft.CodeAnalysis.CSharp.Extensions.ConversionExtensions : object {
    [ExtensionAttribute]
public static bool IsIdentityOrImplicitReference(Conversion conversion);
    [ExtensionAttribute]
public static bool IsImplicitUserDefinedConversion(Conversion conversion);
}
[ExtensionAttribute]
internal static class Microsoft.CodeAnalysis.CSharp.Extensions.DefaultExpressionSyntaxExtensions : object {
    private static LiteralExpressionSyntax s_defaultLiteralExpression;
    private static DefaultExpressionSyntaxExtensions();
    [ExtensionAttribute]
public static bool CanReplaceWithDefaultLiteral(DefaultExpressionSyntax defaultExpression, CSharpParseOptions parseOptions, bool preferSimpleDefaultExpression, SemanticModel semanticModel, CancellationToken cancellationToken);
    private static Nullable`1<bool> CanReplaceWithDefaultLiteralFast(DefaultExpressionSyntax defaultExpression, SemanticModel semanticModel, CancellationToken cancellationToken);
    private static TypeSyntax GetTypeSyntax(EqualsValueClauseSyntax equalsValueClause);
    private static bool CanReplaceWithDefaultLiteralSlow(DefaultExpressionSyntax defaultExpression, SemanticModel semanticModel, CancellationToken cancellationToken);
}
[ExtensionAttribute]
internal static class Microsoft.CodeAnalysis.CSharp.Extensions.DirectiveSyntaxExtensions : object {
    private static ConditionalWeakTable`2<SyntaxNode, DirectiveInfo> s_rootToDirectiveInfo;
    private static DirectiveSyntaxExtensions();
    [ExtensionAttribute]
private static SyntaxNode GetAbsoluteRoot(SyntaxNode node);
    private static DirectiveInfo GetDirectiveInfo(SyntaxNode node, CancellationToken cancellationToken);
    [ExtensionAttribute]
internal static DirectiveTriviaSyntax GetMatchingDirective(DirectiveTriviaSyntax directive, CancellationToken cancellationToken);
    [ExtensionAttribute]
internal static IReadOnlyList`1<DirectiveTriviaSyntax> GetMatchingConditionalDirectives(DirectiveTriviaSyntax directive, CancellationToken cancellationToken);
}
[ExtensionAttribute]
internal static class Microsoft.CodeAnalysis.CSharp.Extensions.DocumentationCommentExtensions : object {
    [NullableContextAttribute("2")]
[ExtensionAttribute]
public static bool IsMultilineDocComment(DocumentationCommentTriviaSyntax documentationComment);
}
[ExtensionAttribute]
internal static class Microsoft.CodeAnalysis.CSharp.Extensions.ExpressionSyntaxExtensions : object {
    [ExtensionAttribute]
public static ExpressionSyntax WalkUpParentheses(ExpressionSyntax expression);
    [ExtensionAttribute]
public static ExpressionSyntax WalkDownParentheses(ExpressionSyntax expression);
    [ExtensionAttribute]
public static bool IsQualifiedCrefName(ExpressionSyntax expression);
    [ExtensionAttribute]
public static bool IsSimpleMemberAccessExpressionName(ExpressionSyntax expression);
    [ExtensionAttribute]
public static bool IsAnyMemberAccessExpressionName(ExpressionSyntax expression);
    [ExtensionAttribute]
public static bool IsMemberBindingExpressionName(ExpressionSyntax expression);
    [ExtensionAttribute]
public static bool IsRightSideOfQualifiedName(ExpressionSyntax expression);
    [ExtensionAttribute]
public static bool IsRightSideOfColonColon(ExpressionSyntax expression);
    [ExtensionAttribute]
public static bool IsRightSideOfDot(ExpressionSyntax name);
    [ExtensionAttribute]
public static bool IsRightSideOfDotOrArrow(ExpressionSyntax name);
    [ExtensionAttribute]
public static bool IsRightSideOfDotOrColonColon(ExpressionSyntax name);
    [ExtensionAttribute]
public static bool IsRightSideOfDotOrArrowOrColonColon(ExpressionSyntax name);
    [ExtensionAttribute]
public static bool IsRightOfCloseParen(ExpressionSyntax expression);
    [ExtensionAttribute]
public static bool IsLeftSideOfDot(ExpressionSyntax expression);
    [ExtensionAttribute]
public static bool IsLeftSideOfSimpleMemberAccessExpression(ExpressionSyntax expression);
    [ExtensionAttribute]
public static bool IsLeftSideOfDotOrArrow(ExpressionSyntax expression);
    [ExtensionAttribute]
public static bool IsLeftSideOfQualifiedName(ExpressionSyntax expression);
    [ExtensionAttribute]
public static bool IsLeftSideOfExplicitInterfaceSpecifier(NameSyntax name);
    [ExtensionAttribute]
public static bool IsExpressionOfInvocation(ExpressionSyntax expression);
    [ExtensionAttribute]
public static bool TryGetNameParts(ExpressionSyntax expression, IList`1& parts);
    [ExtensionAttribute]
public static bool TryGetNameParts(ExpressionSyntax expression, List`1<string> parts);
    private static bool AddSimpleName(SimpleNameSyntax simpleName, List`1<string> parts);
    [ExtensionAttribute]
public static bool IsAnyLiteralExpression(ExpressionSyntax expression);
    [ExtensionAttribute]
public static bool IsInConstantContext(ExpressionSyntax expression);
    [ExtensionAttribute]
public static bool IsInOutContext(ExpressionSyntax expression);
    [ExtensionAttribute]
public static bool IsInRefContext(ExpressionSyntax expression);
    [ExtensionAttribute]
public static bool IsInInContext(ExpressionSyntax expression);
    private static ExpressionSyntax GetExpressionToAnalyzeForWrites(ExpressionSyntax expression);
    [ExtensionAttribute]
public static bool IsOnlyWrittenTo(ExpressionSyntax expression);
    private static bool IsExpressionOfArgumentInDeconstruction(ExpressionSyntax expr);
    [ExtensionAttribute]
public static bool IsWrittenTo(ExpressionSyntax expression);
    [ExtensionAttribute]
public static bool IsAttributeNamedArgumentIdentifier(ExpressionSyntax expression);
    [ExtensionAttribute]
public static bool IsOperandOfIncrementOrDecrementExpression(ExpressionSyntax expression);
    [ExtensionAttribute]
public static bool IsNamedArgumentIdentifier(ExpressionSyntax expression);
    [ExtensionAttribute]
public static bool IsInsideNameOfExpression(ExpressionSyntax expression, SemanticModel semanticModel, CancellationToken cancellationToken);
    private static bool CanReplace(ISymbol symbol);
    [ExtensionAttribute]
public static bool CanReplaceWithRValue(ExpressionSyntax expression, SemanticModel semanticModel, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static bool CanReplaceWithLValue(ExpressionSyntax expression, SemanticModel semanticModel, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static bool CanAccessInstanceAndStaticMembersOffOf(ExpressionSyntax expression, SemanticModel semanticModel, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static bool IsNameOfArgumentExpression(ExpressionSyntax expression);
    [ExtensionAttribute]
public static bool IsNameOfInvocation(InvocationExpressionSyntax invocation);
    [ExtensionAttribute]
public static SimpleNameSyntax GetRightmostName(ExpressionSyntax node);
    [ExtensionAttribute]
public static OperatorPrecedence GetOperatorPrecedence(ExpressionSyntax expression);
    [ExtensionAttribute]
public static bool TryConvertToStatement(ExpressionSyntax expression, Nullable`1<SyntaxToken> semicolonTokenOpt, bool createReturnStatementForExpression, StatementSyntax& statement);
    private static StatementSyntax ConvertToStatement(ExpressionSyntax expression, SyntaxToken semicolonToken, bool createReturnStatementForExpression);
    [ExtensionAttribute]
public static bool IsDirectChildOfMemberAccessExpression(ExpressionSyntax expression);
    [ExtensionAttribute]
public static bool InsideCrefReference(ExpressionSyntax expression);
    [NullableContextAttribute("1")]
[ExtensionAttribute]
public static ExpressionSyntax Parenthesize(ExpressionSyntax expression, bool includeElasticTrivia, bool addSimplifierAnnotation);
    [NullableContextAttribute("1")]
[ExtensionAttribute]
private static ExpressionSyntax ParenthesizeWorker(ExpressionSyntax expression, bool includeElasticTrivia);
    [NullableContextAttribute("1")]
[ExtensionAttribute]
public static PatternSyntax Parenthesize(PatternSyntax pattern, bool includeElasticTrivia, bool addSimplifierAnnotation);
    [NullableContextAttribute("1")]
[ExtensionAttribute]
public static CastExpressionSyntax Cast(ExpressionSyntax expression, ITypeSymbol targetType);
    [NullableContextAttribute("1")]
[ExtensionAttribute]
public static ExpressionSyntax CastIfPossible(ExpressionSyntax expression, ITypeSymbol targetType, int position, SemanticModel semanticModel, CancellationToken cancellationToken);
}
[ExtensionAttribute]
internal static class Microsoft.CodeAnalysis.CSharp.Extensions.ForEachStatementSyntaxExtensions : object {
    [ExtensionAttribute]
public static bool IsTypeInferred(CommonForEachStatementSyntax forEachStatement, SemanticModel semanticModel);
}
[ExtensionAttribute]
internal static class Microsoft.CodeAnalysis.CSharp.Extensions.ILocalSymbolExtensions : object {
    [NullableContextAttribute("1")]
[ExtensionAttribute]
public static bool CanSafelyMoveLocalToBlock(ILocalSymbol localSymbol, SyntaxNode currentBlock, SyntaxNode destinationBlock);
    [NullableContextAttribute("1")]
[CompilerGeneratedAttribute]
internal static bool <CanSafelyMoveLocalToBlock>g__HasTypeParameterWithName|0_0(SyntaxNode node, string name);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
internal static class Microsoft.CodeAnalysis.CSharp.Extensions.ITypeParameterSymbolExtensions : object {
    [ExtensionAttribute]
public static SyntaxList`1<TypeParameterConstraintClauseSyntax> GenerateConstraintClauses(ImmutableArray`1<ITypeParameterSymbol> typeParameters);
    [ExtensionAttribute]
public static SyntaxList`1<TypeParameterConstraintClauseSyntax> GenerateConstraintClauses(IEnumerable`1<ITypeParameterSymbol> typeParameters);
    private static void AddConstraintClauses(List`1<TypeParameterConstraintClauseSyntax> clauses, ITypeParameterSymbol typeParameter);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
internal static class Microsoft.CodeAnalysis.CSharp.Extensions.ITypeSymbolExtensions : object {
    [ExtensionAttribute]
public static ExpressionSyntax GenerateExpressionSyntax(ITypeSymbol typeSymbol);
    [ExtensionAttribute]
public static NameSyntax GenerateNameSyntax(INamespaceOrTypeSymbol symbol, bool allowVar);
    [ExtensionAttribute]
public static TypeSyntax GenerateTypeSyntax(INamespaceOrTypeSymbol symbol, bool allowVar);
    private static TypeSyntax GenerateTypeSyntax(INamespaceOrTypeSymbol symbol, bool nameSyntax, bool allowVar);
    [ExtensionAttribute]
public static TypeSyntax GenerateRefTypeSyntax(INamespaceOrTypeSymbol symbol);
    [ExtensionAttribute]
public static TypeSyntax GenerateRefReadOnlyTypeSyntax(INamespaceOrTypeSymbol symbol);
    [ExtensionAttribute]
public static bool ContainingTypesOrSelfHasUnsafeKeyword(ITypeSymbol containingType);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.CSharp.Extensions.ITypeSymbolExtensions/<FindApplicableAliasAsync>d__7")]
[ExtensionAttribute]
public static Task`1<ISymbol> FindApplicableAliasAsync(ITypeSymbol type, int position, SemanticModel semanticModel, CancellationToken cancellationToken);
    private static IEnumerable`1<UsingDirectiveSyntax> GetApplicableUsings(int position, SyntaxNode root);
    [ExtensionAttribute]
public static bool IsIntrinsicType(ITypeSymbol typeSymbol);
}
[ExtensionAttribute]
internal static class Microsoft.CodeAnalysis.CSharp.Extensions.MemberAccessExpressionSyntaxExtensions : object {
    [ExtensionAttribute]
public static SimpleNameSyntax GetNameWithTriviaMoved(MemberAccessExpressionSyntax memberAccess);
    private static SyntaxTriviaList GetLeadingTriviaForSimplifiedMemberAccess(MemberAccessExpressionSyntax memberAccess);
    private static IEnumerable`1<SyntaxTrivia> WithoutElasticTrivia(IEnumerable`1<SyntaxTrivia> list);
}
[ExtensionAttribute]
internal static class Microsoft.CodeAnalysis.CSharp.Extensions.MemberDeclarationSyntaxExtensions : object {
    private static ConditionalWeakTable`2<MemberDeclarationSyntax, Dictionary`2<string, ImmutableArray`1<SyntaxToken>>> s_declarationCache;
    private static CreateValueCallback<MemberDeclarationSyntax, Dictionary`2<string, ImmutableArray`1<SyntaxToken>>> s_createLocalDeclarationMap;
    private static MemberDeclarationSyntaxExtensions();
    [ExtensionAttribute]
public static LocalDeclarationMap GetLocalDeclarationMap(MemberDeclarationSyntax member);
    private static Dictionary`2<string, ImmutableArray`1<SyntaxToken>> CreateLocalDeclarationMap(MemberDeclarationSyntax member);
    [ExtensionAttribute]
public static SyntaxToken GetNameToken(MemberDeclarationSyntax member);
    [ExtensionAttribute]
public static int GetArity(MemberDeclarationSyntax member);
    [ExtensionAttribute]
public static TypeParameterListSyntax GetTypeParameterList(MemberDeclarationSyntax member);
    [ExtensionAttribute]
public static MemberDeclarationSyntax WithParameterList(MemberDeclarationSyntax member, BaseParameterListSyntax parameterList);
    [ExtensionAttribute]
public static MemberDeclarationSyntax AddAttributeLists(MemberDeclarationSyntax member, AttributeListSyntax[] attributeLists);
    [ExtensionAttribute]
public static MemberDeclarationSyntax WithAttributeLists(MemberDeclarationSyntax member, SyntaxList`1<AttributeListSyntax> attributeLists);
    [ExtensionAttribute]
public static TypeSyntax GetMemberType(MemberDeclarationSyntax member);
    [ExtensionAttribute]
public static bool HasMethodShape(MemberDeclarationSyntax memberDeclaration);
    [ExtensionAttribute]
public static BlockSyntax GetBody(MemberDeclarationSyntax memberDeclaration);
    [ExtensionAttribute]
public static ArrowExpressionClauseSyntax GetExpressionBody(MemberDeclarationSyntax memberDeclaration);
    [ExtensionAttribute]
public static MemberDeclarationSyntax WithBody(MemberDeclarationSyntax memberDeclaration, BlockSyntax body);
    [ExtensionAttribute]
public static SyntaxList`1<AttributeListSyntax> GetAttributes(MemberDeclarationSyntax member);
}
[ExtensionAttribute]
internal static class Microsoft.CodeAnalysis.CSharp.Extensions.NamespaceDeclarationSyntaxExtensions : object {
    [NullableContextAttribute("1")]
[ExtensionAttribute]
public static NamespaceDeclarationSyntax AddUsingDirectives(NamespaceDeclarationSyntax namespaceDeclaration, IList`1<UsingDirectiveSyntax> usingDirectives, bool placeSystemNamespaceFirst, SyntaxAnnotation[] annotations);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
internal static class Microsoft.CodeAnalysis.CSharp.Extensions.NameSyntaxExtensions : object {
    [ExtensionAttribute]
public static IList`1<NameSyntax> GetNameParts(NameSyntax nameSyntax);
    [ExtensionAttribute]
public static NameSyntax GetLastDottedName(NameSyntax nameSyntax);
    [ExtensionAttribute]
public static SyntaxToken GetNameToken(NameSyntax nameSyntax);
    [ExtensionAttribute]
public static bool CanBeReplacedWithAnyName(NameSyntax nameSyntax);
}
internal enum Microsoft.CodeAnalysis.CSharp.Extensions.OperatorPrecedence : Enum {
    public int value__;
    public static OperatorPrecedence None;
    public static OperatorPrecedence AssignmentAndLambdaExpression;
    public static OperatorPrecedence Conditional;
    public static OperatorPrecedence NullCoalescing;
    public static OperatorPrecedence ConditionalOr;
    public static OperatorPrecedence ConditionalAnd;
    public static OperatorPrecedence LogicalOr;
    public static OperatorPrecedence LogicalXor;
    public static OperatorPrecedence LogicalAnd;
    public static OperatorPrecedence Equality;
    public static OperatorPrecedence RelationalAndTypeTesting;
    public static OperatorPrecedence Shift;
    public static OperatorPrecedence Additive;
    public static OperatorPrecedence Multiplicative;
    public static OperatorPrecedence Switch;
    public static OperatorPrecedence Range;
    public static OperatorPrecedence Unary;
    public static OperatorPrecedence Primary;
}
[ExtensionAttribute]
internal static class Microsoft.CodeAnalysis.CSharp.Extensions.ParenthesizedExpressionSyntaxExtensions : object {
    private static ObjectPool`1<Stack`1<SyntaxNode>> s_nodeStackPool;
    private static ParenthesizedExpressionSyntaxExtensions();
    [ExtensionAttribute]
public static bool CanRemoveParentheses(ParenthesizedExpressionSyntax node, SemanticModel semanticModel);
    private static bool RemovalMayIntroduceInterpolationAmbiguity(ParenthesizedExpressionSyntax node);
    private static bool RemovalChangesAssociation(ParenthesizedExpressionSyntax node, ExpressionSyntax parentExpression, SemanticModel semanticModel);
    private static bool IsAssociative(SyntaxKind kind);
    private static bool RemovalMayIntroduceCastAmbiguity(ParenthesizedExpressionSyntax node);
    private static bool StartsWithAlias(NameSyntax name);
    private static bool RemovalMayIntroduceCommaListAmbiguity(ParenthesizedExpressionSyntax node);
    private static bool IsPreviousExpressionPotentiallyAmbiguous(ExpressionSyntax node);
    private static bool IsNextExpressionPotentiallyAmbiguous(ExpressionSyntax node);
    private static bool IsSimpleOrDottedName(ExpressionSyntax expression);
    [ExtensionAttribute]
public static bool CanRemoveParentheses(ParenthesizedPatternSyntax node);
    private static bool RemovalChangesAssociation(ParenthesizedPatternSyntax node, PatternSyntax parentPattern);
    [ExtensionAttribute]
public static OperatorPrecedence GetOperatorPrecedence(PatternSyntax pattern);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
internal static class Microsoft.CodeAnalysis.CSharp.Extensions.QueryExpressionSyntaxExtensions : object {
    [ExtensionAttribute]
public static IList`1<SyntaxNode> GetAllClauses(QueryExpressionSyntax query);
    [ExtensionAttribute]
public static IList`1<SyntaxNode> GetAllClauses(QueryBodySyntax body);
    [ExtensionAttribute]
public static QueryExpressionSyntax WithAllClauses(QueryExpressionSyntax query, IList`1<SyntaxNode> allClauses);
    [ExtensionAttribute]
public static QueryBodySyntax WithAllClauses(QueryBodySyntax body, IEnumerable`1<SyntaxNode> allClauses);
}
[ExtensionAttribute]
internal static class Microsoft.CodeAnalysis.CSharp.Extensions.SemanticModelExtensions : object {
    [ExtensionAttribute]
public static ImmutableArray`1<ParameterName> GenerateParameterNames(SemanticModel semanticModel, ArgumentListSyntax argumentList, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static ImmutableArray`1<ParameterName> GenerateParameterNames(SemanticModel semanticModel, AttributeArgumentListSyntax argumentList, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static ImmutableArray`1<ParameterName> GenerateParameterNames(SemanticModel semanticModel, IEnumerable`1<ArgumentSyntax> arguments, IList`1<string> reservedNames, CancellationToken cancellationToken);
    public static ImmutableArray`1<ParameterName> GenerateNames(IList`1<string> reservedNames, ImmutableArray`1<bool> isFixed, ImmutableArray`1<string> parameterNames);
    [ExtensionAttribute]
public static ImmutableArray`1<ParameterName> GenerateParameterNames(SemanticModel semanticModel, IEnumerable`1<AttributeArgumentSyntax> arguments, IList`1<string> reservedNames, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static string GenerateNameForArgument(SemanticModel semanticModel, ArgumentSyntax argument, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static string GenerateNameForArgument(SemanticModel semanticModel, AttributeArgumentSyntax argument, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static string GenerateNameForExpression(SemanticModel semanticModel, ExpressionSyntax expression, bool capitalize, CancellationToken cancellationToken);
    private static string TryGenerateNameForArgumentExpression(SemanticModel semanticModel, ExpressionSyntax expression, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static IEnumerable`1<ITypeSymbol> LookupTypeRegardlessOfArity(SemanticModel semanticModel, SyntaxToken name, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static ImmutableArray`1<ISymbol> LookupName(SemanticModel semanticModel, SyntaxToken name, CancellationToken cancellationToken);
    private static void DecomposeName(ExpressionSyntax expression, ExpressionSyntax& qualifier, String& name, Int32& arity);
    [ExtensionAttribute]
public static ImmutableArray`1<ISymbol> LookupName(SemanticModel semanticModel, ExpressionSyntax expression, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static SymbolInfo GetSymbolInfo(SemanticModel semanticModel, SyntaxToken token);
    private static bool CanBindToken(SyntaxToken token);
    [ExtensionAttribute]
public static ISet`1<INamespaceSymbol> GetUsingNamespacesInScope(SemanticModel semanticModel, SyntaxNode location);
    [ExtensionAttribute]
public static Accessibility DetermineAccessibilityConstraint(SemanticModel semanticModel, TypeSyntax type, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static bool AllContainingTypesArePublicOrProtected(SemanticModel semanticModel, TypeSyntax type, CancellationToken cancellationToken);
    private static TypeSyntax GetOutermostType(TypeSyntax type);
}
[ExtensionAttribute]
internal static class Microsoft.CodeAnalysis.CSharp.Extensions.SeparatedSyntaxListExtensions : object {
    [NullableContextAttribute("1")]
[ExtensionAttribute]
public static SeparatedSyntaxList`1<T> InsertRangeWithTrailingSeparator(SeparatedSyntaxList`1<T> separatedList, int index, IEnumerable`1<T> nodes, SyntaxKind separator);
}
[ExtensionAttribute]
internal static class Microsoft.CodeAnalysis.CSharp.Extensions.SimpleNameSyntaxExtensions : object {
    [ExtensionAttribute]
public static ExpressionSyntax GetLeftSideOfDot(SimpleNameSyntax name);
    [ExtensionAttribute]
public static bool LooksLikeStandaloneTypeName(SimpleNameSyntax simpleName);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
[ExtensionAttribute]
internal static class Microsoft.CodeAnalysis.CSharp.Extensions.StatementSyntaxExtensions : object {
    [NullableContextAttribute("1")]
[ExtensionAttribute]
public static StatementSyntax WithoutLeadingBlankLinesInTrivia(StatementSyntax statement);
    [ExtensionAttribute]
public static StatementSyntax GetPreviousStatement(StatementSyntax statement);
    [ExtensionAttribute]
public static StatementSyntax GetNextStatement(StatementSyntax statement);
    [NullableContextAttribute("1")]
[CompilerGeneratedAttribute]
internal static bool <GetNextStatement>g__AreInSiblingTopLevelStatements|2_0(StatementSyntax one, StatementSyntax other);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
internal static class Microsoft.CodeAnalysis.CSharp.Extensions.StringExtensions : object {
    [ExtensionAttribute]
public static string EscapeIdentifier(string identifier, bool isQueryContext);
    [ExtensionAttribute]
public static SyntaxToken ToIdentifierToken(string identifier, bool isQueryContext);
    [ExtensionAttribute]
public static IdentifierNameSyntax ToIdentifierName(string identifier);
}
[ExtensionAttribute]
internal static class Microsoft.CodeAnalysis.CSharp.Extensions.SymbolDisplayPartExtensions : object {
    [NullableContextAttribute("2")]
[ExtensionAttribute]
public static SymbolDisplayPart MassageErrorTypeNames(SymbolDisplayPart part, string replacement);
}
[ExtensionAttribute]
internal static class Microsoft.CodeAnalysis.CSharp.Extensions.SyntaxKindExtensions : object {
    [ExtensionAttribute]
public static bool Contains(SyntaxKind[] kinds, SyntaxKind kind);
    [ExtensionAttribute]
public static SyntaxKind MapCompoundAssignmentKindToBinaryExpressionKind(SyntaxKind syntaxKind);
}
[ExtensionAttribute]
internal static class Microsoft.CodeAnalysis.CSharp.Extensions.SyntaxListExtensions : object {
    [ExtensionAttribute]
public static SyntaxList`1<T> RemoveRange(SyntaxList`1<T> syntaxList, int index, int count);
    [ExtensionAttribute]
public static SyntaxList`1<T> ToSyntaxList(IEnumerable`1<T> sequence);
    [ExtensionAttribute]
public static SyntaxList`1<T> Insert(SyntaxList`1<T> list, int index, T item);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
internal static class Microsoft.CodeAnalysis.CSharp.Extensions.SyntaxNodeExtensions : object {
    [NullableContextAttribute("2")]
[ExtensionAttribute]
public static bool IsKind(SyntaxNode node, SyntaxKind kind, TNode& result);
    [NullableContextAttribute("2")]
[ExtensionAttribute]
public static bool IsParentKind(SyntaxNode node, SyntaxKind kind);
    [NullableContextAttribute("2")]
[ExtensionAttribute]
public static bool IsParentKind(SyntaxNode node, SyntaxKind kind, TNode& result);
    [NullableContextAttribute("2")]
[ExtensionAttribute]
public static bool IsParentKind(SyntaxNode node, SyntaxKind kind1, SyntaxKind kind2);
    [NullableContextAttribute("2")]
[ExtensionAttribute]
public static bool IsParentKind(SyntaxNode node, SyntaxKind kind1, SyntaxKind kind2, SyntaxKind kind3);
    [NullableContextAttribute("2")]
[ExtensionAttribute]
public static bool IsParentKind(SyntaxNode node, SyntaxKind kind1, SyntaxKind kind2, SyntaxKind kind3, SyntaxKind kind4);
    [NullableContextAttribute("2")]
[ExtensionAttribute]
public static bool IsKind(SyntaxNode node, SyntaxKind kind1, SyntaxKind kind2);
    [NullableContextAttribute("2")]
[ExtensionAttribute]
public static bool IsKind(SyntaxNode node, SyntaxKind kind1, SyntaxKind kind2, SyntaxKind kind3);
    [NullableContextAttribute("2")]
[ExtensionAttribute]
public static bool IsKind(SyntaxNode node, SyntaxKind kind1, SyntaxKind kind2, SyntaxKind kind3, SyntaxKind kind4);
    [NullableContextAttribute("2")]
[ExtensionAttribute]
public static bool IsKind(SyntaxNode node, SyntaxKind kind1, SyntaxKind kind2, SyntaxKind kind3, SyntaxKind kind4, SyntaxKind kind5);
    [NullableContextAttribute("2")]
[ExtensionAttribute]
public static bool IsKind(SyntaxNode node, SyntaxKind kind1, SyntaxKind kind2, SyntaxKind kind3, SyntaxKind kind4, SyntaxKind kind5, SyntaxKind kind6);
    [NullableContextAttribute("2")]
[ExtensionAttribute]
public static bool IsKind(SyntaxNode node, SyntaxKind kind1, SyntaxKind kind2, SyntaxKind kind3, SyntaxKind kind4, SyntaxKind kind5, SyntaxKind kind6, SyntaxKind kind7);
    [NullableContextAttribute("2")]
[ExtensionAttribute]
public static bool IsKind(SyntaxNode node, SyntaxKind kind1, SyntaxKind kind2, SyntaxKind kind3, SyntaxKind kind4, SyntaxKind kind5, SyntaxKind kind6, SyntaxKind kind7, SyntaxKind kind8);
    [NullableContextAttribute("2")]
[ExtensionAttribute]
public static bool IsKind(SyntaxNode node, SyntaxKind kind1, SyntaxKind kind2, SyntaxKind kind3, SyntaxKind kind4, SyntaxKind kind5, SyntaxKind kind6, SyntaxKind kind7, SyntaxKind kind8, SyntaxKind kind9, SyntaxKind kind10);
    [NullableContextAttribute("2")]
[ExtensionAttribute]
public static bool IsKind(SyntaxNode node, SyntaxKind kind1, SyntaxKind kind2, SyntaxKind kind3, SyntaxKind kind4, SyntaxKind kind5, SyntaxKind kind6, SyntaxKind kind7, SyntaxKind kind8, SyntaxKind kind9, SyntaxKind kind10, SyntaxKind kind11);
    [ExtensionAttribute]
public static IEnumerable`1<SyntaxTrivia> GetAllPrecedingTriviaToPreviousToken(SyntaxNode node, SourceText sourceText, bool includePreviousTokenTrailingTriviaOnlyIfOnSameLine);
    [ExtensionAttribute]
public static IEnumerable`1<SyntaxTrivia> GetAllPrecedingTriviaToPreviousToken(SyntaxToken token, SourceText sourceText, bool includePreviousTokenTrailingTriviaOnlyIfOnSameLine);
    [NullableContextAttribute("2")]
[ExtensionAttribute]
public static bool IsAnyArgumentList(SyntaxNode node);
    [NullableContextAttribute("0")]
[ExtensionAttribute]
public static ValueTuple`2<SyntaxToken, SyntaxToken> GetBraces(SyntaxNode node);
    [NullableContextAttribute("2")]
[ExtensionAttribute]
public static bool IsEmbeddedStatementOwner(SyntaxNode node);
    [NullableContextAttribute("2")]
[ExtensionAttribute]
public static StatementSyntax GetEmbeddedStatement(SyntaxNode node);
    [NullableContextAttribute("2")]
[ExtensionAttribute]
public static BaseParameterListSyntax GetParameterList(SyntaxNode declaration);
    [NullableContextAttribute("2")]
[ExtensionAttribute]
public static SyntaxList`1<AttributeListSyntax> GetAttributeLists(SyntaxNode declaration);
    [NullableContextAttribute("2")]
[ExtensionAttribute]
public static ConditionalAccessExpressionSyntax GetParentConditionalAccessExpression(SyntaxNode node);
    [NullableContextAttribute("2")]
[ExtensionAttribute]
public static ConditionalAccessExpressionSyntax GetRootConditionalAccessExpression(SyntaxNode node);
    [ExtensionAttribute]
public static ConditionalAccessExpressionSyntax GetInnerMostConditionalAccessExpression(SyntaxNode node);
    [NullableContextAttribute("2")]
[ExtensionAttribute]
public static bool IsAsyncSupportingFunctionSyntax(SyntaxNode node);
    [NullableContextAttribute("2")]
[ExtensionAttribute]
public static bool IsAnyLambda(SyntaxNode node);
    [NullableContextAttribute("2")]
[ExtensionAttribute]
public static bool IsAnyLambdaOrAnonymousMethod(SyntaxNode node);
    [ExtensionAttribute]
public static bool IsAnyAssignExpression(SyntaxNode node);
    [ExtensionAttribute]
public static bool IsCompoundAssignExpression(SyntaxNode node);
    [NullableContextAttribute("2")]
[ExtensionAttribute]
public static bool IsLeftSideOfAssignExpression(SyntaxNode node);
    [NullableContextAttribute("2")]
[ExtensionAttribute]
public static bool IsLeftSideOfAnyAssignExpression(SyntaxNode node);
    [NullableContextAttribute("2")]
[ExtensionAttribute]
public static bool IsRightSideOfAnyAssignExpression(SyntaxNode node);
    [NullableContextAttribute("2")]
[ExtensionAttribute]
public static bool IsLeftSideOfCompoundAssignExpression(SyntaxNode node);
    [ExtensionAttribute]
public static IEnumerable`1<UsingDirectiveSyntax> GetEnclosingUsingDirectives(SyntaxNode node);
    [ExtensionAttribute]
public static IEnumerable`1<ExternAliasDirectiveSyntax> GetEnclosingExternAliasDirectives(SyntaxNode node);
    [ExtensionAttribute]
public static bool IsUnsafeContext(SyntaxNode node);
    [ExtensionAttribute]
public static bool IsInStaticContext(SyntaxNode node);
    [ExtensionAttribute]
public static NamespaceDeclarationSyntax GetInnermostNamespaceDeclarationWithUsings(SyntaxNode contextNode);
    [ExtensionAttribute]
public static bool IsBreakableConstruct(SyntaxNode node);
    [ExtensionAttribute]
public static bool IsContinuableConstruct(SyntaxNode node);
    [ExtensionAttribute]
public static bool IsReturnableConstruct(SyntaxNode node);
    [ExtensionAttribute]
public static bool SpansPreprocessorDirective(IEnumerable`1<TSyntaxNode> list);
    [NullableContextAttribute("2")]
[ExtensionAttribute]
public static TNode ConvertToSingleLine(TNode node, bool useElasticTrivia);
    [ExtensionAttribute]
public static bool ContainsInterleavedDirective(SyntaxNode syntaxNode, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static bool ContainsInterleavedDirective(SyntaxNode syntaxNode, TextSpan span, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static bool ContainsInterleavedDirective(SyntaxToken token, TextSpan textSpan, CancellationToken cancellationToken);
    private static bool ContainsInterleavedDirective(TextSpan textSpan, SyntaxTriviaList list, CancellationToken cancellationToken);
    private static bool ContainsInterleavedDirective(TextSpan textSpan, SyntaxTrivia trivia, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static IList`1<IList`1<TSyntaxNode>> SplitNodesOnPreprocessorBoundaries(IEnumerable`1<TSyntaxNode> nodes, CancellationToken cancellationToken);
    [NullableContextAttribute("0")]
[ExtensionAttribute]
public static ImmutableArray`1<SyntaxTrivia> GetLeadingBlankLines(TSyntaxNode node);
    [ExtensionAttribute]
public static TSyntaxNode GetNodeWithoutLeadingBlankLines(TSyntaxNode node);
    [ExtensionAttribute]
public static TSyntaxNode GetNodeWithoutLeadingBlankLines(TSyntaxNode node, ImmutableArray`1& strippedTrivia);
    [NullableContextAttribute("0")]
[ExtensionAttribute]
public static ImmutableArray`1<SyntaxTrivia> GetLeadingBannerAndPreprocessorDirectives(TSyntaxNode node);
    [ExtensionAttribute]
public static TSyntaxNode GetNodeWithoutLeadingBannerAndPreprocessorDirectives(TSyntaxNode node);
    [ExtensionAttribute]
public static TSyntaxNode GetNodeWithoutLeadingBannerAndPreprocessorDirectives(TSyntaxNode node, ImmutableArray`1& strippedTrivia);
    [ExtensionAttribute]
public static bool IsVariableDeclaratorValue(SyntaxNode node);
    [ExtensionAttribute]
public static BlockSyntax FindInnermostCommonBlock(IEnumerable`1<SyntaxNode> nodes);
    [IteratorStateMachineAttribute("Microsoft.CodeAnalysis.CSharp.Extensions.SyntaxNodeExtensions/<GetAncestorsOrThis>d__59")]
[ExtensionAttribute]
public static IEnumerable`1<SyntaxNode> GetAncestorsOrThis(SyntaxNode node, Func`2<SyntaxNode, bool> predicate);
    [ExtensionAttribute]
internal static SyntaxNodeOrToken ChildThatContainsPosition(SyntaxNode self, int position, Int32& childIndex);
    [NullableContextAttribute("0")]
[ExtensionAttribute]
public static ValueTuple`2<SyntaxToken, SyntaxToken> GetParentheses(SyntaxNode node);
    [NullableContextAttribute("0")]
[ExtensionAttribute]
public static ValueTuple`2<SyntaxToken, SyntaxToken> GetBrackets(SyntaxNode node);
    [NullableContextAttribute("2")]
[ExtensionAttribute]
public static SyntaxTokenList GetModifiers(SyntaxNode member);
    [NullableContextAttribute("2")]
[ExtensionAttribute]
public static SyntaxNode WithModifiers(SyntaxNode member, SyntaxTokenList modifiers);
    [ExtensionAttribute]
public static bool CheckTopLevel(SyntaxNode node, TextSpan span);
    [ExtensionAttribute]
public static bool ContainsInArgument(ConstructorInitializerSyntax initializer, TextSpan textSpan);
    [ExtensionAttribute]
public static bool ContainsInBlockBody(BlockSyntax block, TextSpan textSpan);
    [ExtensionAttribute]
public static bool ContainsInExpressionBodiedMemberBody(ArrowExpressionClauseSyntax expressionBodiedMember, TextSpan textSpan);
    [ExtensionAttribute]
public static IEnumerable`1<MemberDeclarationSyntax> GetMembers(SyntaxNode node);
    [NullableContextAttribute("2")]
[ExtensionAttribute]
public static bool IsInExpressionTree(SyntaxNode node, SemanticModel semanticModel, INamedTypeSymbol expressionTypeOpt, CancellationToken cancellationToken);
    [NullableContextAttribute("2")]
[ExtensionAttribute]
public static bool IsInDeconstructionLeft(SyntaxNode node, SyntaxNode& deconstructionLeft);
    [ExtensionAttribute]
public static bool IsTopLevelOfUsingAliasDirective(SyntaxToken node);
    [ExtensionAttribute]
public static T WithCommentsFrom(T node, SyntaxToken leadingToken, SyntaxToken trailingToken);
    [ExtensionAttribute]
public static T WithCommentsFrom(T node, IEnumerable`1<SyntaxToken> leadingTokens, IEnumerable`1<SyntaxToken> trailingTokens);
    [ExtensionAttribute]
public static T WithCommentsFrom(T node, IEnumerable`1<SyntaxTrivia> leadingTrivia, IEnumerable`1<SyntaxTrivia> trailingTrivia, SyntaxNodeOrToken[] trailingNodesOrTokens);
    [ExtensionAttribute]
public static T KeepCommentsAndAddElasticMarkers(T node);
    [ExtensionAttribute]
public static SyntaxNode WithPrependedNonIndentationTriviaFrom(SyntaxNode to, SyntaxNode from);
    [CompilerGeneratedAttribute]
internal static bool <IsInExpressionTree>g__TakesExpressionTree|70_0(SymbolInfo info, INamedTypeSymbol expressionType);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
internal static class Microsoft.CodeAnalysis.CSharp.Extensions.SyntaxTokenExtensions : object {
    [NullableContextAttribute("0")]
[ExtensionAttribute]
public static bool IsLastTokenOfNode(SyntaxToken token);
    [NullableContextAttribute("0")]
[ExtensionAttribute]
public static bool IsLastTokenOfNode(SyntaxToken token, T& node);
    [ExtensionAttribute]
public static bool IsKindOrHasMatchingText(SyntaxToken token, SyntaxKind kind);
    [ExtensionAttribute]
public static bool HasMatchingText(SyntaxToken token, SyntaxKind kind);
    [ExtensionAttribute]
public static bool IsKind(SyntaxToken token, SyntaxKind kind1, SyntaxKind kind2);
    [ExtensionAttribute]
public static bool IsKind(SyntaxToken token, SyntaxKind kind1, SyntaxKind kind2, SyntaxKind kind3);
    [ExtensionAttribute]
public static bool IsKind(SyntaxToken token, SyntaxKind kind1, SyntaxKind kind2, SyntaxKind kind3, SyntaxKind kind4);
    [ExtensionAttribute]
public static bool IsKind(SyntaxToken token, SyntaxKind kind1, SyntaxKind kind2, SyntaxKind kind3, SyntaxKind kind4, SyntaxKind kind5);
    [ExtensionAttribute]
public static bool IsKind(SyntaxToken token, SyntaxKind[] kinds);
    [ExtensionAttribute]
public static bool IsOpenBraceOrCommaOfObjectInitializer(SyntaxToken token);
    [ExtensionAttribute]
public static bool IsOpenBraceOfAccessorList(SyntaxToken token);
    [ExtensionAttribute]
public static bool CouldBeKeyword(SyntaxToken token);
    [ExtensionAttribute]
public static bool IsLiteral(SyntaxToken token);
    [ExtensionAttribute]
public static bool IntersectsWith(SyntaxToken token, int position);
    [ExtensionAttribute]
public static SyntaxToken GetPreviousTokenIfTouchingWord(SyntaxToken token, int position);
    private static bool IsWord(SyntaxToken token);
    [ExtensionAttribute]
public static SyntaxToken GetNextNonZeroWidthTokenOrEndOfFile(SyntaxToken token);
    [ExtensionAttribute]
public static bool IsFirstTokenOnLine(SyntaxToken token, SourceText text);
    [ExtensionAttribute]
public static bool SpansPreprocessorDirective(IEnumerable`1<SyntaxToken> tokens);
    [IteratorStateMachineAttribute("Microsoft.CodeAnalysis.CSharp.Extensions.SyntaxTokenExtensions/<GetAllTrailingTrivia>d__19")]
[ExtensionAttribute]
public static IEnumerable`1<SyntaxTrivia> GetAllTrailingTrivia(SyntaxToken token);
    [ExtensionAttribute]
public static bool IsRegularStringLiteral(SyntaxToken token);
    [ExtensionAttribute]
public static bool IsValidAttributeTarget(SyntaxToken token);
    [ExtensionAttribute]
public static SyntaxToken WithCommentsFrom(SyntaxToken token, IEnumerable`1<SyntaxTrivia> leadingTrivia, IEnumerable`1<SyntaxTrivia> trailingTrivia, SyntaxNodeOrToken[] trailingNodesOrTokens);
    [ExtensionAttribute]
public static SyntaxToken KeepCommentsAndAddElasticMarkers(SyntaxToken token);
    [NullableContextAttribute("2")]
[ExtensionAttribute]
public static bool TryParseGenericName(SyntaxToken genericIdentifier, CancellationToken cancellationToken, GenericNameSyntax& genericName);
    [ExtensionAttribute]
public static SyntaxToken FindLastTokenOfPartialGenericName(SyntaxToken genericIdentifier);
}
[ExtensionAttribute]
internal static class Microsoft.CodeAnalysis.CSharp.Extensions.SyntaxTokenListExtensions : object {
    [NullableContextAttribute("1")]
[ExtensionAttribute]
public static IEnumerable`1<SyntaxToken> SkipKinds(SyntaxTokenList tokenList, SyntaxKind[] kinds);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
internal static class Microsoft.CodeAnalysis.CSharp.Extensions.SyntaxTreeExtensions : object {
    private static Func`2<SyntaxKind, bool> s_isDotOrArrow;
    private static Func`2<SyntaxKind, bool> s_isDotOrArrowOrColonColon;
    private static SyntaxTreeExtensions();
    [ExtensionAttribute]
public static ISet`1<SyntaxKind> GetPrecedingModifiers(SyntaxTree syntaxTree, int position, SyntaxToken tokenOnLeftOfPosition);
    [ExtensionAttribute]
public static ISet`1<SyntaxKind> GetPrecedingModifiers(SyntaxTree syntaxTree, int position, SyntaxToken tokenOnLeftOfPosition, Int32& positionBeforeModifiers);
    [ExtensionAttribute]
public static TypeDeclarationSyntax GetContainingTypeDeclaration(SyntaxTree syntaxTree, int position, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static BaseTypeDeclarationSyntax GetContainingTypeOrEnumDeclaration(SyntaxTree syntaxTree, int position, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static IEnumerable`1<TypeDeclarationSyntax> GetContainingTypeDeclarations(SyntaxTree syntaxTree, int position, CancellationToken cancellationToken);
    private static bool BaseTypeDeclarationContainsPosition(BaseTypeDeclarationSyntax declaration, int position);
    [ExtensionAttribute]
public static IEnumerable`1<BaseTypeDeclarationSyntax> GetContainingTypeOrEnumDeclarations(SyntaxTree syntaxTree, int position, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static bool IsRightOfDotOrArrowOrColonColon(SyntaxTree syntaxTree, int position, SyntaxToken targetToken, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static bool IsRightOfDotOrArrow(SyntaxTree syntaxTree, int position, CancellationToken cancellationToken);
    [ExtensionAttribute]
private static bool IsRightOf(SyntaxTree syntaxTree, int position, Func`2<SyntaxKind, bool> predicate, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static bool IsRightOfNumericLiteral(SyntaxTree syntaxTree, int position, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static bool IsAfterKeyword(SyntaxTree syntaxTree, int position, SyntaxKind kind, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static bool IsEntirelyWithinNonUserCodeComment(SyntaxTree syntaxTree, int position, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static bool IsEntirelyWithinComment(SyntaxTree syntaxTree, int position, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static bool IsCrefContext(SyntaxTree syntaxTree, int position, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static bool IsEntirelyWithinCrefSyntax(SyntaxTree syntaxTree, int position, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static bool IsEntirelyWithinSingleLineDocComment(SyntaxTree syntaxTree, int position, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static bool IsEntirelyWithinMultiLineDocComment(SyntaxTree syntaxTree, int position, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static bool IsEntirelyWithinMultiLineComment(SyntaxTree syntaxTree, int position, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static bool IsEntirelyWithinConflictMarker(SyntaxTree syntaxTree, int position, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static bool IsEntirelyWithinTopLevelSingleLineComment(SyntaxTree syntaxTree, int position, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static bool IsEntirelyWithinPreProcessorSingleLineComment(SyntaxTree syntaxTree, int position, CancellationToken cancellationToken);
    private static bool AtEndOfIncompleteStringOrCharLiteral(SyntaxToken token, int position, char lastChar);
    [ExtensionAttribute]
public static bool IsEntirelyWithinStringOrCharLiteral(SyntaxTree syntaxTree, int position, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static bool IsEntirelyWithinStringLiteral(SyntaxTree syntaxTree, int position, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static bool IsEntirelyWithinCharLiteral(SyntaxTree syntaxTree, int position, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static bool IsPrimaryFunctionExpressionContext(SyntaxTree syntaxTree, int position, SyntaxToken tokenOnLeftOfPosition);
    [ExtensionAttribute]
public static bool IsInNonUserCode(SyntaxTree syntaxTree, int position, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static bool IsInInactiveRegion(SyntaxTree syntaxTree, int position, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static bool IsInPartiallyWrittenGeneric(SyntaxTree syntaxTree, int position, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static bool IsInPartiallyWrittenGeneric(SyntaxTree syntaxTree, int position, CancellationToken cancellationToken, SyntaxToken& genericIdentifier);
    [ExtensionAttribute]
public static bool IsInPartiallyWrittenGeneric(SyntaxTree syntaxTree, int position, CancellationToken cancellationToken, SyntaxToken& genericIdentifier, SyntaxToken& lessThanToken);
    private static bool IsFullyWrittenGeneric(SyntaxToken token, SyntaxToken lessThanToken);
}
[ExtensionAttribute]
internal static class Microsoft.CodeAnalysis.CSharp.Extensions.SyntaxTriviaExtensions : object {
    [ExtensionAttribute]
public static bool MatchesKind(SyntaxTrivia trivia, SyntaxKind kind);
    [ExtensionAttribute]
public static bool MatchesKind(SyntaxTrivia trivia, SyntaxKind kind1, SyntaxKind kind2);
    [ExtensionAttribute]
public static bool MatchesKind(SyntaxTrivia trivia, SyntaxKind[] kinds);
    [ExtensionAttribute]
public static bool IsSingleOrMultiLineComment(SyntaxTrivia trivia);
    [ExtensionAttribute]
public static bool IsRegularComment(SyntaxTrivia trivia);
    [ExtensionAttribute]
public static bool IsWhitespaceOrSingleOrMultiLineComment(SyntaxTrivia trivia);
    [ExtensionAttribute]
public static bool IsRegularOrDocComment(SyntaxTrivia trivia);
    [ExtensionAttribute]
public static bool IsSingleLineComment(SyntaxTrivia trivia);
    [ExtensionAttribute]
public static bool IsMultiLineComment(SyntaxTrivia trivia);
    [ExtensionAttribute]
public static bool IsShebangDirective(SyntaxTrivia trivia);
    [ExtensionAttribute]
public static bool IsCompleteMultiLineComment(SyntaxTrivia trivia);
    [ExtensionAttribute]
public static bool IsDocComment(SyntaxTrivia trivia);
    [ExtensionAttribute]
public static bool IsSingleLineDocComment(SyntaxTrivia trivia);
    [ExtensionAttribute]
public static bool IsMultiLineDocComment(SyntaxTrivia trivia);
    [ExtensionAttribute]
public static string GetCommentText(SyntaxTrivia trivia);
    [ExtensionAttribute]
public static string AsString(IEnumerable`1<SyntaxTrivia> trivia);
    [ExtensionAttribute]
public static int GetFullWidth(IEnumerable`1<SyntaxTrivia> trivia);
    [ExtensionAttribute]
public static SyntaxTriviaList AsTrivia(string s);
    [ExtensionAttribute]
public static bool IsWhitespaceOrEndOfLine(SyntaxTrivia trivia);
    [ExtensionAttribute]
public static bool IsEndOfLine(SyntaxTrivia trivia);
    [ExtensionAttribute]
public static bool IsWhitespace(SyntaxTrivia trivia);
    [ExtensionAttribute]
public static SyntaxTrivia GetPreviousTrivia(SyntaxTrivia trivia, SyntaxTree syntaxTree, CancellationToken cancellationToken, bool findInsideTrivia);
    [IteratorStateMachineAttribute("Microsoft.CodeAnalysis.CSharp.Extensions.SyntaxTriviaExtensions/<FilterComments>d__22")]
[ExtensionAttribute]
public static IEnumerable`1<SyntaxTrivia> FilterComments(IEnumerable`1<SyntaxTrivia> trivia, bool addElasticMarker);
    [ExtensionAttribute]
public static bool IsPragmaDirective(SyntaxTrivia trivia, Boolean& isDisable, Boolean& isActive, SeparatedSyntaxList`1& errorCodes);
}
[ExtensionAttribute]
internal static class Microsoft.CodeAnalysis.CSharp.Extensions.SyntaxTriviaListExtensions : object {
    [ExtensionAttribute]
public static bool Any(SyntaxTriviaList triviaList, SyntaxKind[] kinds);
    [ExtensionAttribute]
public static Nullable`1<SyntaxTrivia> GetFirstNewLine(SyntaxTriviaList triviaList);
    [ExtensionAttribute]
public static Nullable`1<SyntaxTrivia> GetLastComment(SyntaxTriviaList triviaList);
    [ExtensionAttribute]
public static Nullable`1<SyntaxTrivia> GetLastCommentOrWhitespace(SyntaxTriviaList triviaList);
    [ExtensionAttribute]
public static IEnumerable`1<SyntaxTrivia> SkipInitialWhitespace(SyntaxTriviaList triviaList);
    private static ImmutableArray`1<ImmutableArray`1<SyntaxTrivia>> GetLeadingBlankLines(SyntaxTriviaList triviaList);
    [ExtensionAttribute]
public static SyntaxTriviaList WithoutLeadingBlankLines(SyntaxTriviaList triviaList);
    [IteratorStateMachineAttribute("Microsoft.CodeAnalysis.CSharp.Extensions.SyntaxTriviaListExtensions/<TakeRange>d__7")]
[ExtensionAttribute]
public static IEnumerable`1<SyntaxTrivia> TakeRange(SyntaxTriviaList triviaList, int start, int end);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
internal static class Microsoft.CodeAnalysis.CSharp.Extensions.TypeDeclarationSyntaxExtensions : object {
    [ExtensionAttribute]
public static IList`1<bool> GetInsertionIndices(TypeDeclarationSyntax destination, CancellationToken cancellationToken);
    private static SyntaxToken GetEndToken(SyntaxNode node);
    [ExtensionAttribute]
public static IEnumerable`1<BaseTypeSyntax> GetAllBaseListTypes(TypeDeclarationSyntax typeNode, SemanticModel model, CancellationToken cancellationToken);
    private static SyntaxToken EnsureToken(SyntaxToken token, SyntaxKind kind, bool prependNewLineIfMissing, bool appendNewLineIfMissing);
    private static BaseTypeDeclarationSyntax EnsureHasBraces(BaseTypeDeclarationSyntax typeDeclaration, bool hasMembers);
    [ExtensionAttribute]
public static TypeDeclarationSyntax EnsureOpenAndCloseBraceTokens(TypeDeclarationSyntax typeDeclaration);
    [ExtensionAttribute]
public static EnumDeclarationSyntax EnsureOpenAndCloseBraceTokens(EnumDeclarationSyntax typeDeclaration);
}
[ExtensionAttribute]
internal static class Microsoft.CodeAnalysis.CSharp.Extensions.TypeSyntaxExtensions : object {
    [ExtensionAttribute]
public static bool IsVoid(TypeSyntax typeSyntax);
    [ExtensionAttribute]
public static bool IsPartial(TypeSyntax typeSyntax);
    [ExtensionAttribute]
public static bool IsTypeInferred(TypeSyntax typeSyntax, SemanticModel semanticModel);
    [ExtensionAttribute]
public static TypeSyntax StripRefIfNeeded(TypeSyntax type);
    [NullableContextAttribute("2")]
[ExtensionAttribute]
public static bool IsPotentialTypeName(TypeSyntax typeSyntax, SemanticModel semanticModelOpt, CancellationToken cancellationToken);
    [NullableContextAttribute("1")]
[ExtensionAttribute]
public static TypeSyntax GenerateReturnTypeSyntax(IMethodSymbol method);
}
[ExtensionAttribute]
internal static class Microsoft.CodeAnalysis.CSharp.Extensions.UsingDirectiveSyntaxExtensions : object {
    [NullableContextAttribute("1")]
[ExtensionAttribute]
public static void SortUsingDirectives(List`1<UsingDirectiveSyntax> usingDirectives, SyntaxList`1<UsingDirectiveSyntax> existingDirectives, bool placeSystemNamespaceFirst);
}
[ExtensionAttribute]
internal static class Microsoft.CodeAnalysis.CSharp.Extensions.VariableDeclaratorExtensions : object {
    [ExtensionAttribute]
public static TypeSyntax GetVariableType(VariableDeclaratorSyntax declarator);
    [ExtensionAttribute]
public static bool IsTypeInferred(VariableDeclaratorSyntax variable, SemanticModel semanticModel);
}
[ExportLanguageServiceAttribute("Microsoft.CodeAnalysis.FindSymbols.IDeclaredSymbolInfoFactoryService", "C#", "Default")]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.CSharp.FindSymbols.CSharpDeclaredSymbolInfoFactoryService : AbstractDeclaredSymbolInfoFactoryService {
    private static ImmutableArray`1<string> GetInheritanceNames(StringTable stringTable, BaseListSyntax baseList);
    private static void AddAliasMaps(SyntaxNode node, List`1<Dictionary`2<string, string>> aliasMaps);
    private static void ProcessUsings(List`1<Dictionary`2<string, string>> aliasMaps, SyntaxList`1<UsingDirectiveSyntax> usings);
    private static void AddInheritanceName(ArrayBuilder`1<string> builder, TypeSyntax type, List`1<Dictionary`2<string, string>> aliasMaps);
    public virtual bool TryGetDeclaredSymbolInfo(StringTable stringTable, SyntaxNode node, string rootNamespace, DeclaredSymbolInfo& declaredSymbolInfo);
    private static bool IsNestedType(BaseTypeDeclarationSyntax typeDecl);
    private static string GetConstructorSuffix(ConstructorDeclarationSyntax constructor);
    private static string GetMethodSuffix(MethodDeclarationSyntax method);
    private static string GetIndexerSuffix(IndexerDeclarationSyntax indexer);
    private static string GetTypeParameterSuffix(TypeParameterListSyntax typeParameterList);
    private static string GetSuffix(char openBrace, char closeBrace, SeparatedSyntaxList`1<ParameterSyntax> parameters);
    private static void AppendParameters(SeparatedSyntaxList`1<ParameterSyntax> parameters, StringBuilder builder);
    private static string GetContainerDisplayName(SyntaxNode node);
    private static string GetFullyQualifiedContainerName(SyntaxNode node);
    private static Accessibility GetAccessibility(SyntaxNode node, SyntaxTokenList modifiers);
    private static string GetTypeName(TypeSyntax type);
    private static string GetSimpleTypeName(SimpleNameSyntax name);
    private static bool IsExtensionMethod(MethodDeclarationSyntax method);
    public virtual string GetRootNamespace(CompilationOptions compilationOptions);
    public virtual bool TryGetAliasesFromUsingDirective(SyntaxNode node, ImmutableArray`1& aliases);
    public virtual string GetReceiverTypeName(SyntaxNode node);
    private static bool TryGetSimpleTypeName(SyntaxNode node, Nullable`1<ImmutableArray`1<string>> typeParameterNames, String& simpleTypeName, Boolean& isArray);
    private static string GetSpecialTypeName(PredefinedTypeSyntax predefinedTypeNode);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.CodeAnalysis.CSharp.Formatting.AggregatedFormattingResult : AbstractAggregatedFormattingResult {
    public AggregatedFormattingResult(SyntaxNode node, IList`1<AbstractFormattingResult> results, SimpleIntervalTree`2<TextSpan, TextSpanIntervalIntrospector> formattingSpans);
    protected virtual SyntaxNode Rewriter(Dictionary`2<ValueTuple`2<SyntaxToken, SyntaxToken>, TriviaData> map, CancellationToken cancellationToken);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.CodeAnalysis.CSharp.Formatting.AnchorIndentationFormattingRule : BaseFormattingRule {
    internal static string Name;
    public virtual void AddAnchorIndentationOperations(List`1<AnchorIndentationOperation> list, SyntaxNode node, NextAnchorIndentationOperationAction& modreq(System.Runtime.InteropServices.InAttribute) nextOperation);
    private static void AddAnchorIndentationOperation(List`1<AnchorIndentationOperation> list, SyntaxNode node);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal abstract class Microsoft.CodeAnalysis.CSharp.Formatting.BaseFormattingRule : AbstractFormattingRule {
    protected static void AddUnindentBlockOperation(List`1<IndentBlockOperation> list, SyntaxToken startToken, SyntaxToken endToken, TextSpan textSpan, IndentBlockOption option);
    protected static void AddUnindentBlockOperation(List`1<IndentBlockOperation> list, SyntaxToken startToken, SyntaxToken endToken, bool includeTriviaAtEnd, IndentBlockOption option);
    protected static void AddAbsoluteZeroIndentBlockOperation(List`1<IndentBlockOperation> list, SyntaxToken startToken, SyntaxToken endToken, IndentBlockOption option);
    protected static void AddIndentBlockOperation(List`1<IndentBlockOperation> list, SyntaxToken startToken, SyntaxToken endToken, IndentBlockOption option);
    protected static void AddIndentBlockOperation(List`1<IndentBlockOperation> list, SyntaxToken startToken, SyntaxToken endToken, TextSpan textSpan, IndentBlockOption option);
    protected static void AddIndentBlockOperation(List`1<IndentBlockOperation> list, SyntaxToken baseToken, SyntaxToken startToken, SyntaxToken endToken, IndentBlockOption option);
    protected static void SetAlignmentBlockOperation(List`1<IndentBlockOperation> list, SyntaxToken baseToken, SyntaxToken startToken, SyntaxToken endToken, IndentBlockOption option);
    protected static void AddSuppressWrappingIfOnSingleLineOperation(List`1<SuppressOperation> list, SyntaxToken startToken, SyntaxToken endToken, SuppressOption extraOption);
    protected static void AddSuppressAllOperationIfOnMultipleLine(List`1<SuppressOperation> list, SyntaxToken startToken, SyntaxToken endToken, SuppressOption extraOption);
    protected static void AddSuppressOperation(List`1<SuppressOperation> list, SyntaxToken startToken, SyntaxToken endToken, SuppressOption option);
    protected static void AddAnchorIndentationOperation(List`1<AnchorIndentationOperation> list, SyntaxToken anchorToken, SyntaxToken endToken);
    protected static void AddAlignIndentationOfTokensToBaseTokenOperation(List`1<AlignTokensOperation> list, SyntaxNode containingNode, SyntaxToken baseNode, IEnumerable`1<SyntaxToken> tokens, AlignTokensOption option);
    protected static AdjustNewLinesOperation CreateAdjustNewLinesOperation(int line, AdjustNewLinesOption option);
    protected static AdjustSpacesOperation CreateAdjustSpacesOperation(int space, AdjustSpacesOption option);
    protected static void AddBraceSuppressOperations(List`1<SuppressOperation> list, SyntaxNode node);
}
public enum Microsoft.CodeAnalysis.CSharp.Formatting.BinaryOperatorSpacingOptions : Enum {
    public int value__;
    public static BinaryOperatorSpacingOptions Single;
    public static BinaryOperatorSpacingOptions Ignore;
    public static BinaryOperatorSpacingOptions Remove;
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.CodeAnalysis.CSharp.Formatting.CSharpFormatEngine : AbstractFormatEngine {
    internal ISyntaxFacts SyntaxFacts { get; }
    public CSharpFormatEngine(SyntaxNode node, AnalyzerConfigOptions options, IEnumerable`1<AbstractFormattingRule> formattingRules, SyntaxToken token1, SyntaxToken token2);
    internal virtual ISyntaxFacts get_SyntaxFacts();
    protected virtual AbstractTriviaDataFactory CreateTriviaFactory();
    protected virtual AbstractFormattingResult CreateFormattingResult(TokenStream tokenStream);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal static class Microsoft.CodeAnalysis.CSharp.Formatting.CSharpFormattingOptionGroups : object {
    public static OptionGroup NewLine;
    public static OptionGroup Indentation;
    public static OptionGroup Spacing;
    public static OptionGroup Wrapping;
    private static CSharpFormattingOptionGroups();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public static class Microsoft.CodeAnalysis.CSharp.Formatting.CSharpFormattingOptions : object {
    [CompilerGeneratedAttribute]
private static Option`1<bool> <SpacingAfterMethodDeclarationName>k__BackingField;
    [CompilerGeneratedAttribute]
private static Option`1<bool> <SpaceWithinMethodDeclarationParenthesis>k__BackingField;
    [CompilerGeneratedAttribute]
private static Option`1<bool> <SpaceBetweenEmptyMethodDeclarationParentheses>k__BackingField;
    [CompilerGeneratedAttribute]
private static Option`1<bool> <SpaceAfterMethodCallName>k__BackingField;
    [CompilerGeneratedAttribute]
private static Option`1<bool> <SpaceWithinMethodCallParentheses>k__BackingField;
    [CompilerGeneratedAttribute]
private static Option`1<bool> <SpaceBetweenEmptyMethodCallParentheses>k__BackingField;
    [CompilerGeneratedAttribute]
private static Option`1<bool> <SpaceAfterControlFlowStatementKeyword>k__BackingField;
    [CompilerGeneratedAttribute]
private static Option`1<bool> <SpaceWithinExpressionParentheses>k__BackingField;
    [CompilerGeneratedAttribute]
private static Option`1<bool> <SpaceWithinCastParentheses>k__BackingField;
    [CompilerGeneratedAttribute]
private static Option`1<bool> <SpaceWithinOtherParentheses>k__BackingField;
    [CompilerGeneratedAttribute]
private static Option`1<bool> <SpaceAfterCast>k__BackingField;
    [CompilerGeneratedAttribute]
private static Option`1<bool> <SpacesIgnoreAroundVariableDeclaration>k__BackingField;
    [CompilerGeneratedAttribute]
private static Option`1<bool> <SpaceBeforeOpenSquareBracket>k__BackingField;
    [CompilerGeneratedAttribute]
private static Option`1<bool> <SpaceBetweenEmptySquareBrackets>k__BackingField;
    [CompilerGeneratedAttribute]
private static Option`1<bool> <SpaceWithinSquareBrackets>k__BackingField;
    [CompilerGeneratedAttribute]
private static Option`1<bool> <SpaceAfterColonInBaseTypeDeclaration>k__BackingField;
    [CompilerGeneratedAttribute]
private static Option`1<bool> <SpaceAfterComma>k__BackingField;
    [CompilerGeneratedAttribute]
private static Option`1<bool> <SpaceAfterDot>k__BackingField;
    [CompilerGeneratedAttribute]
private static Option`1<bool> <SpaceAfterSemicolonsInForStatement>k__BackingField;
    [CompilerGeneratedAttribute]
private static Option`1<bool> <SpaceBeforeColonInBaseTypeDeclaration>k__BackingField;
    [CompilerGeneratedAttribute]
private static Option`1<bool> <SpaceBeforeComma>k__BackingField;
    [CompilerGeneratedAttribute]
private static Option`1<bool> <SpaceBeforeDot>k__BackingField;
    [CompilerGeneratedAttribute]
private static Option`1<bool> <SpaceBeforeSemicolonsInForStatement>k__BackingField;
    [CompilerGeneratedAttribute]
private static Option`1<BinaryOperatorSpacingOptions> <SpacingAroundBinaryOperator>k__BackingField;
    [CompilerGeneratedAttribute]
private static Option`1<bool> <IndentBraces>k__BackingField;
    [CompilerGeneratedAttribute]
private static Option`1<bool> <IndentBlock>k__BackingField;
    [CompilerGeneratedAttribute]
private static Option`1<bool> <IndentSwitchSection>k__BackingField;
    [CompilerGeneratedAttribute]
private static Option`1<bool> <IndentSwitchCaseSection>k__BackingField;
    [CompilerGeneratedAttribute]
private static Option`1<bool> <IndentSwitchCaseSectionWhenBlock>k__BackingField;
    [CompilerGeneratedAttribute]
private static Option`1<LabelPositionOptions> <LabelPositioning>k__BackingField;
    [CompilerGeneratedAttribute]
private static Option`1<bool> <WrappingPreserveSingleLine>k__BackingField;
    [CompilerGeneratedAttribute]
private static Option`1<bool> <WrappingKeepStatementsOnSingleLine>k__BackingField;
    [CompilerGeneratedAttribute]
private static Option`1<bool> <NewLinesForBracesInTypes>k__BackingField;
    [CompilerGeneratedAttribute]
private static Option`1<bool> <NewLinesForBracesInMethods>k__BackingField;
    [CompilerGeneratedAttribute]
private static Option`1<bool> <NewLinesForBracesInProperties>k__BackingField;
    [CompilerGeneratedAttribute]
private static Option`1<bool> <NewLinesForBracesInAccessors>k__BackingField;
    [CompilerGeneratedAttribute]
private static Option`1<bool> <NewLinesForBracesInAnonymousMethods>k__BackingField;
    [CompilerGeneratedAttribute]
private static Option`1<bool> <NewLinesForBracesInControlBlocks>k__BackingField;
    [CompilerGeneratedAttribute]
private static Option`1<bool> <NewLinesForBracesInAnonymousTypes>k__BackingField;
    [CompilerGeneratedAttribute]
private static Option`1<bool> <NewLinesForBracesInObjectCollectionArrayInitializers>k__BackingField;
    [CompilerGeneratedAttribute]
private static Option`1<bool> <NewLinesForBracesInLambdaExpressionBody>k__BackingField;
    [CompilerGeneratedAttribute]
private static Option`1<bool> <NewLineForElse>k__BackingField;
    [CompilerGeneratedAttribute]
private static Option`1<bool> <NewLineForCatch>k__BackingField;
    [CompilerGeneratedAttribute]
private static Option`1<bool> <NewLineForFinally>k__BackingField;
    [CompilerGeneratedAttribute]
private static Option`1<bool> <NewLineForMembersInObjectInit>k__BackingField;
    [CompilerGeneratedAttribute]
private static Option`1<bool> <NewLineForMembersInAnonymousTypes>k__BackingField;
    [CompilerGeneratedAttribute]
private static Option`1<bool> <NewLineForClausesInQuery>k__BackingField;
    public static Option`1<bool> SpacingAfterMethodDeclarationName { get; }
    public static Option`1<bool> SpaceWithinMethodDeclarationParenthesis { get; }
    public static Option`1<bool> SpaceBetweenEmptyMethodDeclarationParentheses { get; }
    public static Option`1<bool> SpaceAfterMethodCallName { get; }
    public static Option`1<bool> SpaceWithinMethodCallParentheses { get; }
    public static Option`1<bool> SpaceBetweenEmptyMethodCallParentheses { get; }
    public static Option`1<bool> SpaceAfterControlFlowStatementKeyword { get; }
    public static Option`1<bool> SpaceWithinExpressionParentheses { get; }
    public static Option`1<bool> SpaceWithinCastParentheses { get; }
    public static Option`1<bool> SpaceWithinOtherParentheses { get; }
    public static Option`1<bool> SpaceAfterCast { get; }
    public static Option`1<bool> SpacesIgnoreAroundVariableDeclaration { get; }
    public static Option`1<bool> SpaceBeforeOpenSquareBracket { get; }
    public static Option`1<bool> SpaceBetweenEmptySquareBrackets { get; }
    public static Option`1<bool> SpaceWithinSquareBrackets { get; }
    public static Option`1<bool> SpaceAfterColonInBaseTypeDeclaration { get; }
    public static Option`1<bool> SpaceAfterComma { get; }
    public static Option`1<bool> SpaceAfterDot { get; }
    public static Option`1<bool> SpaceAfterSemicolonsInForStatement { get; }
    public static Option`1<bool> SpaceBeforeColonInBaseTypeDeclaration { get; }
    public static Option`1<bool> SpaceBeforeComma { get; }
    public static Option`1<bool> SpaceBeforeDot { get; }
    public static Option`1<bool> SpaceBeforeSemicolonsInForStatement { get; }
    public static Option`1<BinaryOperatorSpacingOptions> SpacingAroundBinaryOperator { get; }
    public static Option`1<bool> IndentBraces { get; }
    public static Option`1<bool> IndentBlock { get; }
    public static Option`1<bool> IndentSwitchSection { get; }
    public static Option`1<bool> IndentSwitchCaseSection { get; }
    public static Option`1<bool> IndentSwitchCaseSectionWhenBlock { get; }
    public static Option`1<LabelPositionOptions> LabelPositioning { get; }
    public static Option`1<bool> WrappingPreserveSingleLine { get; }
    public static Option`1<bool> WrappingKeepStatementsOnSingleLine { get; }
    public static Option`1<bool> NewLinesForBracesInTypes { get; }
    public static Option`1<bool> NewLinesForBracesInMethods { get; }
    public static Option`1<bool> NewLinesForBracesInProperties { get; }
    public static Option`1<bool> NewLinesForBracesInAccessors { get; }
    public static Option`1<bool> NewLinesForBracesInAnonymousMethods { get; }
    public static Option`1<bool> NewLinesForBracesInControlBlocks { get; }
    public static Option`1<bool> NewLinesForBracesInAnonymousTypes { get; }
    public static Option`1<bool> NewLinesForBracesInObjectCollectionArrayInitializers { get; }
    public static Option`1<bool> NewLinesForBracesInLambdaExpressionBody { get; }
    public static Option`1<bool> NewLineForElse { get; }
    public static Option`1<bool> NewLineForCatch { get; }
    public static Option`1<bool> NewLineForFinally { get; }
    public static Option`1<bool> NewLineForMembersInObjectInit { get; }
    public static Option`1<bool> NewLineForMembersInAnonymousTypes { get; }
    public static Option`1<bool> NewLineForClausesInQuery { get; }
    private static CSharpFormattingOptions();
    [CompilerGeneratedAttribute]
public static Option`1<bool> get_SpacingAfterMethodDeclarationName();
    [CompilerGeneratedAttribute]
public static Option`1<bool> get_SpaceWithinMethodDeclarationParenthesis();
    [CompilerGeneratedAttribute]
public static Option`1<bool> get_SpaceBetweenEmptyMethodDeclarationParentheses();
    [CompilerGeneratedAttribute]
public static Option`1<bool> get_SpaceAfterMethodCallName();
    [CompilerGeneratedAttribute]
public static Option`1<bool> get_SpaceWithinMethodCallParentheses();
    [CompilerGeneratedAttribute]
public static Option`1<bool> get_SpaceBetweenEmptyMethodCallParentheses();
    [CompilerGeneratedAttribute]
public static Option`1<bool> get_SpaceAfterControlFlowStatementKeyword();
    [CompilerGeneratedAttribute]
public static Option`1<bool> get_SpaceWithinExpressionParentheses();
    [CompilerGeneratedAttribute]
public static Option`1<bool> get_SpaceWithinCastParentheses();
    [CompilerGeneratedAttribute]
public static Option`1<bool> get_SpaceWithinOtherParentheses();
    [CompilerGeneratedAttribute]
public static Option`1<bool> get_SpaceAfterCast();
    [CompilerGeneratedAttribute]
public static Option`1<bool> get_SpacesIgnoreAroundVariableDeclaration();
    [CompilerGeneratedAttribute]
public static Option`1<bool> get_SpaceBeforeOpenSquareBracket();
    [CompilerGeneratedAttribute]
public static Option`1<bool> get_SpaceBetweenEmptySquareBrackets();
    [CompilerGeneratedAttribute]
public static Option`1<bool> get_SpaceWithinSquareBrackets();
    [CompilerGeneratedAttribute]
public static Option`1<bool> get_SpaceAfterColonInBaseTypeDeclaration();
    [CompilerGeneratedAttribute]
public static Option`1<bool> get_SpaceAfterComma();
    [CompilerGeneratedAttribute]
public static Option`1<bool> get_SpaceAfterDot();
    [CompilerGeneratedAttribute]
public static Option`1<bool> get_SpaceAfterSemicolonsInForStatement();
    [CompilerGeneratedAttribute]
public static Option`1<bool> get_SpaceBeforeColonInBaseTypeDeclaration();
    [CompilerGeneratedAttribute]
public static Option`1<bool> get_SpaceBeforeComma();
    [CompilerGeneratedAttribute]
public static Option`1<bool> get_SpaceBeforeDot();
    [CompilerGeneratedAttribute]
public static Option`1<bool> get_SpaceBeforeSemicolonsInForStatement();
    [CompilerGeneratedAttribute]
public static Option`1<BinaryOperatorSpacingOptions> get_SpacingAroundBinaryOperator();
    [CompilerGeneratedAttribute]
public static Option`1<bool> get_IndentBraces();
    [CompilerGeneratedAttribute]
public static Option`1<bool> get_IndentBlock();
    [CompilerGeneratedAttribute]
public static Option`1<bool> get_IndentSwitchSection();
    [CompilerGeneratedAttribute]
public static Option`1<bool> get_IndentSwitchCaseSection();
    [CompilerGeneratedAttribute]
public static Option`1<bool> get_IndentSwitchCaseSectionWhenBlock();
    [CompilerGeneratedAttribute]
public static Option`1<LabelPositionOptions> get_LabelPositioning();
    [CompilerGeneratedAttribute]
public static Option`1<bool> get_WrappingPreserveSingleLine();
    [CompilerGeneratedAttribute]
public static Option`1<bool> get_WrappingKeepStatementsOnSingleLine();
    [CompilerGeneratedAttribute]
public static Option`1<bool> get_NewLinesForBracesInTypes();
    [CompilerGeneratedAttribute]
public static Option`1<bool> get_NewLinesForBracesInMethods();
    [CompilerGeneratedAttribute]
public static Option`1<bool> get_NewLinesForBracesInProperties();
    [CompilerGeneratedAttribute]
public static Option`1<bool> get_NewLinesForBracesInAccessors();
    [CompilerGeneratedAttribute]
public static Option`1<bool> get_NewLinesForBracesInAnonymousMethods();
    [CompilerGeneratedAttribute]
public static Option`1<bool> get_NewLinesForBracesInControlBlocks();
    [CompilerGeneratedAttribute]
public static Option`1<bool> get_NewLinesForBracesInAnonymousTypes();
    [CompilerGeneratedAttribute]
public static Option`1<bool> get_NewLinesForBracesInObjectCollectionArrayInitializers();
    [CompilerGeneratedAttribute]
public static Option`1<bool> get_NewLinesForBracesInLambdaExpressionBody();
    [CompilerGeneratedAttribute]
public static Option`1<bool> get_NewLineForElse();
    [CompilerGeneratedAttribute]
public static Option`1<bool> get_NewLineForCatch();
    [CompilerGeneratedAttribute]
public static Option`1<bool> get_NewLineForFinally();
    [CompilerGeneratedAttribute]
public static Option`1<bool> get_NewLineForMembersInObjectInit();
    [CompilerGeneratedAttribute]
public static Option`1<bool> get_NewLineForMembersInAnonymousTypes();
    [CompilerGeneratedAttribute]
public static Option`1<bool> get_NewLineForClausesInQuery();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal static class Microsoft.CodeAnalysis.CSharp.Formatting.CSharpFormattingOptions2 : object {
    private static Builder<IOption2> s_allOptionsBuilder;
    private static Builder<Option2`1<bool>, SpacingWithinParenthesesOption> s_spacingWithinParenthesisOptionsMapBuilder;
    private static Builder<Option2`1<bool>, NewLineOption> s_newLineOptionsMapBuilder;
    private static BidirectionalMap`2<string, SpacingWithinParenthesesOption> s_spacingWithinParenthesisOptionsEditorConfigMap;
    private static BidirectionalMap`2<string, BinaryOperatorSpacingOptions> s_binaryOperatorSpacingOptionsEditorConfigMap;
    private static BidirectionalMap`2<string, LabelPositionOptions> s_labelPositionOptionsEditorConfigMap;
    private static BidirectionalMap`2<string, NewLineOption> s_legacyNewLineOptionsEditorConfigMap;
    private static BidirectionalMap`2<string, NewLineOption> s_newLineOptionsEditorConfigMap;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private static ImmutableArray`1<IOption2> <AllOptions>k__BackingField;
    [CompilerGeneratedAttribute]
private static ImmutableDictionary`2<Option2`1<bool>, SpacingWithinParenthesesOption> <SpacingWithinParenthesisOptionsMap>k__BackingField;
    [CompilerGeneratedAttribute]
private static ImmutableDictionary`2<Option2`1<bool>, NewLineOption> <NewLineOptionsMap>k__BackingField;
    [CompilerGeneratedAttribute]
private static Option2`1<bool> <SpacingAfterMethodDeclarationName>k__BackingField;
    [CompilerGeneratedAttribute]
private static Option2`1<bool> <SpaceWithinMethodDeclarationParenthesis>k__BackingField;
    [CompilerGeneratedAttribute]
private static Option2`1<bool> <SpaceBetweenEmptyMethodDeclarationParentheses>k__BackingField;
    [CompilerGeneratedAttribute]
private static Option2`1<bool> <SpaceAfterMethodCallName>k__BackingField;
    [CompilerGeneratedAttribute]
private static Option2`1<bool> <SpaceWithinMethodCallParentheses>k__BackingField;
    [CompilerGeneratedAttribute]
private static Option2`1<bool> <SpaceBetweenEmptyMethodCallParentheses>k__BackingField;
    [CompilerGeneratedAttribute]
private static Option2`1<bool> <SpaceAfterControlFlowStatementKeyword>k__BackingField;
    [CompilerGeneratedAttribute]
private static Option2`1<bool> <SpaceWithinExpressionParentheses>k__BackingField;
    [CompilerGeneratedAttribute]
private static Option2`1<bool> <SpaceWithinCastParentheses>k__BackingField;
    [CompilerGeneratedAttribute]
private static Option2`1<bool> <SpaceWithinOtherParentheses>k__BackingField;
    [CompilerGeneratedAttribute]
private static Option2`1<bool> <SpaceAfterCast>k__BackingField;
    [CompilerGeneratedAttribute]
private static Option2`1<bool> <SpacesIgnoreAroundVariableDeclaration>k__BackingField;
    [CompilerGeneratedAttribute]
private static Option2`1<bool> <SpaceBeforeOpenSquareBracket>k__BackingField;
    [CompilerGeneratedAttribute]
private static Option2`1<bool> <SpaceBetweenEmptySquareBrackets>k__BackingField;
    [CompilerGeneratedAttribute]
private static Option2`1<bool> <SpaceWithinSquareBrackets>k__BackingField;
    [CompilerGeneratedAttribute]
private static Option2`1<bool> <SpaceAfterColonInBaseTypeDeclaration>k__BackingField;
    [CompilerGeneratedAttribute]
private static Option2`1<bool> <SpaceAfterComma>k__BackingField;
    [CompilerGeneratedAttribute]
private static Option2`1<bool> <SpaceAfterDot>k__BackingField;
    [CompilerGeneratedAttribute]
private static Option2`1<bool> <SpaceAfterSemicolonsInForStatement>k__BackingField;
    [CompilerGeneratedAttribute]
private static Option2`1<bool> <SpaceBeforeColonInBaseTypeDeclaration>k__BackingField;
    [CompilerGeneratedAttribute]
private static Option2`1<bool> <SpaceBeforeComma>k__BackingField;
    [CompilerGeneratedAttribute]
private static Option2`1<bool> <SpaceBeforeDot>k__BackingField;
    [CompilerGeneratedAttribute]
private static Option2`1<bool> <SpaceBeforeSemicolonsInForStatement>k__BackingField;
    [CompilerGeneratedAttribute]
private static Option2`1<BinaryOperatorSpacingOptions> <SpacingAroundBinaryOperator>k__BackingField;
    [CompilerGeneratedAttribute]
private static Option2`1<bool> <IndentBraces>k__BackingField;
    [CompilerGeneratedAttribute]
private static Option2`1<bool> <IndentBlock>k__BackingField;
    [CompilerGeneratedAttribute]
private static Option2`1<bool> <IndentSwitchSection>k__BackingField;
    [CompilerGeneratedAttribute]
private static Option2`1<bool> <IndentSwitchCaseSection>k__BackingField;
    [CompilerGeneratedAttribute]
private static Option2`1<bool> <IndentSwitchCaseSectionWhenBlock>k__BackingField;
    [CompilerGeneratedAttribute]
private static Option2`1<LabelPositionOptions> <LabelPositioning>k__BackingField;
    [CompilerGeneratedAttribute]
private static Option2`1<bool> <WrappingPreserveSingleLine>k__BackingField;
    [CompilerGeneratedAttribute]
private static Option2`1<bool> <WrappingKeepStatementsOnSingleLine>k__BackingField;
    [CompilerGeneratedAttribute]
private static Option2`1<bool> <NewLinesForBracesInTypes>k__BackingField;
    [CompilerGeneratedAttribute]
private static Option2`1<bool> <NewLinesForBracesInMethods>k__BackingField;
    [CompilerGeneratedAttribute]
private static Option2`1<bool> <NewLinesForBracesInProperties>k__BackingField;
    [CompilerGeneratedAttribute]
private static Option2`1<bool> <NewLinesForBracesInAccessors>k__BackingField;
    [CompilerGeneratedAttribute]
private static Option2`1<bool> <NewLinesForBracesInAnonymousMethods>k__BackingField;
    [CompilerGeneratedAttribute]
private static Option2`1<bool> <NewLinesForBracesInControlBlocks>k__BackingField;
    [CompilerGeneratedAttribute]
private static Option2`1<bool> <NewLinesForBracesInAnonymousTypes>k__BackingField;
    [CompilerGeneratedAttribute]
private static Option2`1<bool> <NewLinesForBracesInObjectCollectionArrayInitializers>k__BackingField;
    [CompilerGeneratedAttribute]
private static Option2`1<bool> <NewLinesForBracesInLambdaExpressionBody>k__BackingField;
    [CompilerGeneratedAttribute]
private static Option2`1<bool> <NewLineForElse>k__BackingField;
    [CompilerGeneratedAttribute]
private static Option2`1<bool> <NewLineForCatch>k__BackingField;
    [CompilerGeneratedAttribute]
private static Option2`1<bool> <NewLineForFinally>k__BackingField;
    [CompilerGeneratedAttribute]
private static Option2`1<bool> <NewLineForMembersInObjectInit>k__BackingField;
    [CompilerGeneratedAttribute]
private static Option2`1<bool> <NewLineForMembersInAnonymousTypes>k__BackingField;
    [CompilerGeneratedAttribute]
private static Option2`1<bool> <NewLineForClausesInQuery>k__BackingField;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static ImmutableArray`1<IOption2> AllOptions { get; }
    private static ImmutableDictionary`2<Option2`1<bool>, SpacingWithinParenthesesOption> SpacingWithinParenthesisOptionsMap { get; }
    private static ImmutableDictionary`2<Option2`1<bool>, NewLineOption> NewLineOptionsMap { get; }
    public static Option2`1<bool> SpacingAfterMethodDeclarationName { get; }
    public static Option2`1<bool> SpaceWithinMethodDeclarationParenthesis { get; }
    public static Option2`1<bool> SpaceBetweenEmptyMethodDeclarationParentheses { get; }
    public static Option2`1<bool> SpaceAfterMethodCallName { get; }
    public static Option2`1<bool> SpaceWithinMethodCallParentheses { get; }
    public static Option2`1<bool> SpaceBetweenEmptyMethodCallParentheses { get; }
    public static Option2`1<bool> SpaceAfterControlFlowStatementKeyword { get; }
    public static Option2`1<bool> SpaceWithinExpressionParentheses { get; }
    public static Option2`1<bool> SpaceWithinCastParentheses { get; }
    public static Option2`1<bool> SpaceWithinOtherParentheses { get; }
    public static Option2`1<bool> SpaceAfterCast { get; }
    public static Option2`1<bool> SpacesIgnoreAroundVariableDeclaration { get; }
    public static Option2`1<bool> SpaceBeforeOpenSquareBracket { get; }
    public static Option2`1<bool> SpaceBetweenEmptySquareBrackets { get; }
    public static Option2`1<bool> SpaceWithinSquareBrackets { get; }
    public static Option2`1<bool> SpaceAfterColonInBaseTypeDeclaration { get; }
    public static Option2`1<bool> SpaceAfterComma { get; }
    public static Option2`1<bool> SpaceAfterDot { get; }
    public static Option2`1<bool> SpaceAfterSemicolonsInForStatement { get; }
    public static Option2`1<bool> SpaceBeforeColonInBaseTypeDeclaration { get; }
    public static Option2`1<bool> SpaceBeforeComma { get; }
    public static Option2`1<bool> SpaceBeforeDot { get; }
    public static Option2`1<bool> SpaceBeforeSemicolonsInForStatement { get; }
    public static Option2`1<BinaryOperatorSpacingOptions> SpacingAroundBinaryOperator { get; }
    public static Option2`1<bool> IndentBraces { get; }
    public static Option2`1<bool> IndentBlock { get; }
    public static Option2`1<bool> IndentSwitchSection { get; }
    public static Option2`1<bool> IndentSwitchCaseSection { get; }
    public static Option2`1<bool> IndentSwitchCaseSectionWhenBlock { get; }
    public static Option2`1<LabelPositionOptions> LabelPositioning { get; }
    public static Option2`1<bool> WrappingPreserveSingleLine { get; }
    public static Option2`1<bool> WrappingKeepStatementsOnSingleLine { get; }
    public static Option2`1<bool> NewLinesForBracesInTypes { get; }
    public static Option2`1<bool> NewLinesForBracesInMethods { get; }
    public static Option2`1<bool> NewLinesForBracesInProperties { get; }
    public static Option2`1<bool> NewLinesForBracesInAccessors { get; }
    public static Option2`1<bool> NewLinesForBracesInAnonymousMethods { get; }
    public static Option2`1<bool> NewLinesForBracesInControlBlocks { get; }
    public static Option2`1<bool> NewLinesForBracesInAnonymousTypes { get; }
    public static Option2`1<bool> NewLinesForBracesInObjectCollectionArrayInitializers { get; }
    public static Option2`1<bool> NewLinesForBracesInLambdaExpressionBody { get; }
    public static Option2`1<bool> NewLineForElse { get; }
    public static Option2`1<bool> NewLineForCatch { get; }
    public static Option2`1<bool> NewLineForFinally { get; }
    public static Option2`1<bool> NewLineForMembersInObjectInit { get; }
    public static Option2`1<bool> NewLineForMembersInAnonymousTypes { get; }
    public static Option2`1<bool> NewLineForClausesInQuery { get; }
    private static CSharpFormattingOptions2();
    [CompilerGeneratedAttribute]
internal static ImmutableArray`1<IOption2> get_AllOptions();
    [CompilerGeneratedAttribute]
private static ImmutableDictionary`2<Option2`1<bool>, SpacingWithinParenthesesOption> get_SpacingWithinParenthesisOptionsMap();
    [CompilerGeneratedAttribute]
private static ImmutableDictionary`2<Option2`1<bool>, NewLineOption> get_NewLineOptionsMap();
    private static Option2`1<T> CreateOption(OptionGroup group, string name, T defaultValue, OptionStorageLocation2[] storageLocations);
    private static Option2`1<bool> CreateSpaceWithinParenthesesOption(SpacingWithinParenthesesOption parenthesesOption, string name);
    private static Option2`1<bool> CreateNewLineForBracesOption(NewLineOption newLineOption, string name);
    [CompilerGeneratedAttribute]
public static Option2`1<bool> get_SpacingAfterMethodDeclarationName();
    [CompilerGeneratedAttribute]
public static Option2`1<bool> get_SpaceWithinMethodDeclarationParenthesis();
    [CompilerGeneratedAttribute]
public static Option2`1<bool> get_SpaceBetweenEmptyMethodDeclarationParentheses();
    [CompilerGeneratedAttribute]
public static Option2`1<bool> get_SpaceAfterMethodCallName();
    [CompilerGeneratedAttribute]
public static Option2`1<bool> get_SpaceWithinMethodCallParentheses();
    [CompilerGeneratedAttribute]
public static Option2`1<bool> get_SpaceBetweenEmptyMethodCallParentheses();
    [CompilerGeneratedAttribute]
public static Option2`1<bool> get_SpaceAfterControlFlowStatementKeyword();
    [CompilerGeneratedAttribute]
public static Option2`1<bool> get_SpaceWithinExpressionParentheses();
    [CompilerGeneratedAttribute]
public static Option2`1<bool> get_SpaceWithinCastParentheses();
    [CompilerGeneratedAttribute]
public static Option2`1<bool> get_SpaceWithinOtherParentheses();
    [CompilerGeneratedAttribute]
public static Option2`1<bool> get_SpaceAfterCast();
    [CompilerGeneratedAttribute]
public static Option2`1<bool> get_SpacesIgnoreAroundVariableDeclaration();
    [CompilerGeneratedAttribute]
public static Option2`1<bool> get_SpaceBeforeOpenSquareBracket();
    [CompilerGeneratedAttribute]
public static Option2`1<bool> get_SpaceBetweenEmptySquareBrackets();
    [CompilerGeneratedAttribute]
public static Option2`1<bool> get_SpaceWithinSquareBrackets();
    [CompilerGeneratedAttribute]
public static Option2`1<bool> get_SpaceAfterColonInBaseTypeDeclaration();
    [CompilerGeneratedAttribute]
public static Option2`1<bool> get_SpaceAfterComma();
    [CompilerGeneratedAttribute]
public static Option2`1<bool> get_SpaceAfterDot();
    [CompilerGeneratedAttribute]
public static Option2`1<bool> get_SpaceAfterSemicolonsInForStatement();
    [CompilerGeneratedAttribute]
public static Option2`1<bool> get_SpaceBeforeColonInBaseTypeDeclaration();
    [CompilerGeneratedAttribute]
public static Option2`1<bool> get_SpaceBeforeComma();
    [CompilerGeneratedAttribute]
public static Option2`1<bool> get_SpaceBeforeDot();
    [CompilerGeneratedAttribute]
public static Option2`1<bool> get_SpaceBeforeSemicolonsInForStatement();
    [CompilerGeneratedAttribute]
public static Option2`1<BinaryOperatorSpacingOptions> get_SpacingAroundBinaryOperator();
    [CompilerGeneratedAttribute]
public static Option2`1<bool> get_IndentBraces();
    [CompilerGeneratedAttribute]
public static Option2`1<bool> get_IndentBlock();
    [CompilerGeneratedAttribute]
public static Option2`1<bool> get_IndentSwitchSection();
    [CompilerGeneratedAttribute]
public static Option2`1<bool> get_IndentSwitchCaseSection();
    [CompilerGeneratedAttribute]
public static Option2`1<bool> get_IndentSwitchCaseSectionWhenBlock();
    [CompilerGeneratedAttribute]
public static Option2`1<LabelPositionOptions> get_LabelPositioning();
    [CompilerGeneratedAttribute]
public static Option2`1<bool> get_WrappingPreserveSingleLine();
    [CompilerGeneratedAttribute]
public static Option2`1<bool> get_WrappingKeepStatementsOnSingleLine();
    [CompilerGeneratedAttribute]
public static Option2`1<bool> get_NewLinesForBracesInTypes();
    [CompilerGeneratedAttribute]
public static Option2`1<bool> get_NewLinesForBracesInMethods();
    [CompilerGeneratedAttribute]
public static Option2`1<bool> get_NewLinesForBracesInProperties();
    [CompilerGeneratedAttribute]
public static Option2`1<bool> get_NewLinesForBracesInAccessors();
    [CompilerGeneratedAttribute]
public static Option2`1<bool> get_NewLinesForBracesInAnonymousMethods();
    [CompilerGeneratedAttribute]
public static Option2`1<bool> get_NewLinesForBracesInControlBlocks();
    [CompilerGeneratedAttribute]
public static Option2`1<bool> get_NewLinesForBracesInAnonymousTypes();
    [CompilerGeneratedAttribute]
public static Option2`1<bool> get_NewLinesForBracesInObjectCollectionArrayInitializers();
    [CompilerGeneratedAttribute]
public static Option2`1<bool> get_NewLinesForBracesInLambdaExpressionBody();
    [CompilerGeneratedAttribute]
public static Option2`1<bool> get_NewLineForElse();
    [CompilerGeneratedAttribute]
public static Option2`1<bool> get_NewLineForCatch();
    [CompilerGeneratedAttribute]
public static Option2`1<bool> get_NewLineForFinally();
    [CompilerGeneratedAttribute]
public static Option2`1<bool> get_NewLineForMembersInObjectInit();
    [CompilerGeneratedAttribute]
public static Option2`1<bool> get_NewLineForMembersInAnonymousTypes();
    [CompilerGeneratedAttribute]
public static Option2`1<bool> get_NewLineForClausesInQuery();
    internal static bool DetermineIfSpaceOptionIsSet(string value, SpacingWithinParenthesesOption parenthesesSpacingOption);
    private static Nullable`1<SpacingWithinParenthesesOption> ConvertToSpacingOption(string value);
    private static string GetSpacingWithParenthesesEditorConfigString(OptionSet optionSet);
    internal static BinaryOperatorSpacingOptions ParseEditorConfigSpacingAroundBinaryOperator(string binaryOperatorSpacingValue);
    private static string GetSpacingAroundBinaryOperatorEditorConfigString(BinaryOperatorSpacingOptions value);
    internal static LabelPositionOptions ParseEditorConfigLabelPositioning(string labelIndentationValue);
    private static string GetLabelPositionOptionEditorConfigString(LabelPositionOptions value);
    internal static bool DetermineIfNewLineOptionIsSet(string value, NewLineOption optionName);
    private static Nullable`1<NewLineOption> ConvertToNewLineOption(string value);
    private static string GetNewLineOptionEditorConfigString(OptionSet optionSet);
    internal static bool DetermineIfIgnoreSpacesAroundVariableDeclarationIsSet(string value);
}
[ExportOptionProviderAttribute("C#")]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.CSharp.Formatting.CSharpFormattingOptionsProvider : object {
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private ImmutableArray`1<IOption> <Options>k__BackingField;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ImmutableArray`1<IOption> Options { get; }
    [CompilerGeneratedAttribute]
public sealed virtual ImmutableArray`1<IOption> get_Options();
}
[ExportLanguageServiceAttribute("Microsoft.CodeAnalysis.Formatting.IFormattingService", "C#", "Default")]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.CSharp.Formatting.CSharpFormattingService : AbstractFormattingService {
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.CodeAnalysis.CSharp.Formatting.CSharpStructuredTriviaFormatEngine : AbstractFormatEngine {
    internal ISyntaxFacts SyntaxFacts { get; }
    private CSharpStructuredTriviaFormatEngine(SyntaxTrivia trivia, int initialColumn, AnalyzerConfigOptions options, ChainedFormattingRules formattingRules, SyntaxToken token1, SyntaxToken token2);
    public static IFormattingResult Format(SyntaxTrivia trivia, int initialColumn, AnalyzerConfigOptions options, ChainedFormattingRules formattingRules, CancellationToken cancellationToken);
    internal virtual ISyntaxFacts get_SyntaxFacts();
    protected virtual AbstractTriviaDataFactory CreateTriviaFactory();
    protected virtual FormattingContext CreateFormattingContext(TokenStream tokenStream, CancellationToken cancellationToken);
    protected virtual NodeOperations CreateNodeOperations(CancellationToken cancellationToken);
    protected virtual AbstractFormattingResult CreateFormattingResult(TokenStream tokenStream);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExportLanguageServiceAttribute("Microsoft.CodeAnalysis.Formatting.ISyntaxFormattingService", "C#", "Default")]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.CSharp.Formatting.CSharpSyntaxFormattingService : AbstractSyntaxFormattingService {
    private ImmutableList`1<AbstractFormattingRule> _rules;
    public virtual IEnumerable`1<AbstractFormattingRule> GetDefaultFormattingRules();
    protected virtual IFormattingResult CreateAggregatedFormattingResult(SyntaxNode node, IList`1<AbstractFormattingResult> results, SimpleIntervalTree`2<TextSpan, TextSpanIntervalIntrospector> formattingSpans);
    protected virtual AbstractFormattingResult Format(SyntaxNode node, AnalyzerConfigOptions options, IEnumerable`1<AbstractFormattingRule> formattingRules, SyntaxToken token1, SyntaxToken token2, CancellationToken cancellationToken);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.CodeAnalysis.CSharp.Formatting.CSharpTriviaFormatter : AbstractTriviaFormatter {
    private bool _succeeded;
    private SyntaxTrivia _newLine;
    public CSharpTriviaFormatter(FormattingContext context, ChainedFormattingRules formattingRules, SyntaxToken token1, SyntaxToken token2, string originalString, int lineBreaks, int spaces);
    protected virtual bool Succeeded();
    protected virtual bool IsWhitespace(SyntaxTrivia trivia);
    protected virtual bool IsEndOfLine(SyntaxTrivia trivia);
    protected virtual bool IsWhitespace(char ch);
    protected virtual bool IsNewLine(char ch);
    protected virtual SyntaxTrivia CreateWhitespace(string text);
    protected virtual SyntaxTrivia CreateEndOfLine();
    protected virtual LineColumnRule GetLineColumnRuleBetween(SyntaxTrivia trivia1, LineColumnDelta existingWhitespaceBetween, bool implicitLineBreak, SyntaxTrivia trivia2);
    protected virtual bool ContainsImplicitLineBreak(SyntaxTrivia trivia);
    private bool IsStartOrEndOfFile(SyntaxTrivia trivia1, SyntaxTrivia trivia2);
    private static bool IsMultilineComment(SyntaxTrivia trivia1);
    private bool TryFormatMultiLineCommentTrivia(LineColumn lineColumn, SyntaxTrivia trivia, SyntaxTrivia& result);
    protected virtual LineColumnDelta Format(LineColumn lineColumn, SyntaxTrivia trivia, ArrayBuilder`1<SyntaxTrivia> changes, CancellationToken cancellationToken);
    protected virtual LineColumnDelta Format(LineColumn lineColumn, SyntaxTrivia trivia, ArrayBuilder`1<TextChange> changes, CancellationToken cancellationToken);
    private SyntaxTrivia FormatDocumentComment(LineColumn lineColumn, SyntaxTrivia trivia);
    private LineColumnDelta FormatStructuredTrivia(LineColumn lineColumn, SyntaxTrivia trivia, ArrayBuilder`1<SyntaxTrivia> changes, CancellationToken cancellationToken);
    private LineColumnDelta FormatStructuredTrivia(LineColumn lineColumn, SyntaxTrivia trivia, ArrayBuilder`1<TextChange> changes, CancellationToken cancellationToken);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.CodeAnalysis.CSharp.Formatting.DefaultOperationProvider : AbstractFormattingRule {
    public static DefaultOperationProvider Instance;
    private static DefaultOperationProvider();
    public virtual void AddSuppressOperations(List`1<SuppressOperation> list, SyntaxNode node, NextSuppressOperationAction& modreq(System.Runtime.InteropServices.InAttribute) nextOperation);
    public virtual void AddAnchorIndentationOperations(List`1<AnchorIndentationOperation> list, SyntaxNode node, NextAnchorIndentationOperationAction& modreq(System.Runtime.InteropServices.InAttribute) nextOperation);
    public virtual void AddIndentBlockOperations(List`1<IndentBlockOperation> list, SyntaxNode node, NextIndentBlockOperationAction& modreq(System.Runtime.InteropServices.InAttribute) nextOperation);
    public virtual void AddAlignTokensOperations(List`1<AlignTokensOperation> list, SyntaxNode node, NextAlignTokensOperationAction& modreq(System.Runtime.InteropServices.InAttribute) nextOperation);
    [NullableContextAttribute("2")]
public virtual AdjustNewLinesOperation GetAdjustNewLinesOperation(SyntaxToken& modreq(System.Runtime.InteropServices.InAttribute) previousToken, SyntaxToken& modreq(System.Runtime.InteropServices.InAttribute) currentToken, NextGetAdjustNewLinesOperation& modreq(System.Runtime.InteropServices.InAttribute) nextOperation);
    public virtual AdjustSpacesOperation GetAdjustSpacesOperation(SyntaxToken& modreq(System.Runtime.InteropServices.InAttribute) previousToken, SyntaxToken& modreq(System.Runtime.InteropServices.InAttribute) currentToken, NextGetAdjustSpacesOperation& modreq(System.Runtime.InteropServices.InAttribute) nextOperation);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.CodeAnalysis.CSharp.Formatting.ElasticTriviaFormattingRule : BaseFormattingRule {
    internal static string Name;
    public virtual void AddSuppressOperations(List`1<SuppressOperation> list, SyntaxNode node, NextSuppressOperationAction& modreq(System.Runtime.InteropServices.InAttribute) nextOperation);
    private static void AddPropertyDeclarationSuppressOperations(List`1<SuppressOperation> list, SyntaxNode node);
    private static void AddInitializerSuppressOperations(List`1<SuppressOperation> list, SyntaxNode node);
    private static InitializerExpressionSyntax GetInitializerNode(SyntaxNode node);
    private static Nullable`1<SyntaxToken> GetLastTokenOfType(SyntaxNode node);
    [NullableContextAttribute("2")]
public virtual AdjustNewLinesOperation GetAdjustNewLinesOperation(SyntaxToken& modreq(System.Runtime.InteropServices.InAttribute) previousToken, SyntaxToken& modreq(System.Runtime.InteropServices.InAttribute) currentToken, NextGetAdjustNewLinesOperation& modreq(System.Runtime.InteropServices.InAttribute) nextOperation);
    [NullableContextAttribute("2")]
private static AdjustNewLinesOperation GetAdjustNewLinesOperationBetweenMembers(SyntaxToken previousToken, SyntaxToken currentToken);
    [NullableContextAttribute("2")]
public virtual AdjustSpacesOperation GetAdjustSpacesOperation(SyntaxToken& modreq(System.Runtime.InteropServices.InAttribute) previousToken, SyntaxToken& modreq(System.Runtime.InteropServices.InAttribute) currentToken, NextGetAdjustSpacesOperation& modreq(System.Runtime.InteropServices.InAttribute) nextOperation);
    private static int LineBreaksAfter(SyntaxToken previousToken, SyntaxToken currentToken);
    private static int LineBreaksAfterCloseBrace(SyntaxToken nextToken);
    private static int LineBreaksAfterSemicolon(SyntaxToken previousToken, SyntaxToken currentToken);
    private static bool IsWhitespace(SyntaxTrivia trivia);
    private static int GetNumberOfLines(IEnumerable`1<SyntaxTrivia> triviaList);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
internal class Microsoft.CodeAnalysis.CSharp.Formatting.EndOfFileTokenFormattingRule : BaseFormattingRule {
    [NullableAttribute("1")]
internal static string Name;
    public virtual AdjustNewLinesOperation GetAdjustNewLinesOperation(SyntaxToken& modreq(System.Runtime.InteropServices.InAttribute) previousToken, SyntaxToken& modreq(System.Runtime.InteropServices.InAttribute) currentToken, NextGetAdjustNewLinesOperation& modreq(System.Runtime.InteropServices.InAttribute) nextOperation);
    public virtual AdjustSpacesOperation GetAdjustSpacesOperation(SyntaxToken& modreq(System.Runtime.InteropServices.InAttribute) previousToken, SyntaxToken& modreq(System.Runtime.InteropServices.InAttribute) currentToken, NextGetAdjustSpacesOperation& modreq(System.Runtime.InteropServices.InAttribute) nextOperation);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
internal static class Microsoft.CodeAnalysis.CSharp.Formatting.FormattingHelpers : object {
    public static string NewLine;
    [ExtensionAttribute]
public static string GetIndent(SyntaxToken token);
    [ExtensionAttribute]
public static string ContentBeforeLastNewLine(IEnumerable`1<SyntaxTrivia> trivia);
    [NullableContextAttribute("0")]
[ExtensionAttribute]
public static ValueTuple`2<SyntaxToken, SyntaxToken> GetBracePair(SyntaxNode node);
    [NullableContextAttribute("0")]
[ExtensionAttribute]
public static bool IsValidBracePair(ValueTuple`2<SyntaxToken, SyntaxToken> bracePair);
    [ExtensionAttribute]
public static bool IsOpenParenInParameterListOfAConversionOperatorDeclaration(SyntaxToken token);
    [ExtensionAttribute]
public static bool IsOpenParenInParameterListOfAOperationDeclaration(SyntaxToken token);
    [ExtensionAttribute]
public static bool IsOpenParenInParameterList(SyntaxToken token);
    [ExtensionAttribute]
public static bool IsCloseParenInParameterList(SyntaxToken token);
    [ExtensionAttribute]
public static bool IsOpenParenInArgumentListOrPositionalPattern(SyntaxToken token);
    [ExtensionAttribute]
public static bool IsCloseParenInArgumentListOrPositionalPattern(SyntaxToken token);
    private static bool IsTokenInArgumentListOrPositionalPattern(SyntaxToken token);
    [ExtensionAttribute]
public static bool IsColonInTypeBaseList(SyntaxToken token);
    [ExtensionAttribute]
public static bool IsCommaInArgumentOrParameterList(SyntaxToken token);
    [ExtensionAttribute]
public static bool IsLambdaBodyBlock(SyntaxNode node);
    [ExtensionAttribute]
public static bool IsAnonymousMethodBlock(SyntaxNode node);
    [ExtensionAttribute]
public static bool IsSemicolonInForStatement(SyntaxToken token);
    [ExtensionAttribute]
public static bool IsSemicolonOfEmbeddedStatement(SyntaxToken token);
    [ExtensionAttribute]
public static bool IsCloseBraceOfExpression(SyntaxToken token);
    [ExtensionAttribute]
public static bool IsCloseBraceOfEmbeddedBlock(SyntaxToken token);
    [NullableContextAttribute("2")]
[ExtensionAttribute]
public static bool IsEmbeddedStatement(SyntaxNode node);
    [ExtensionAttribute]
public static bool IsCommaInEnumDeclaration(SyntaxToken token);
    [ExtensionAttribute]
public static bool IsCommaInAnyArgumentsList(SyntaxToken token);
    [ExtensionAttribute]
public static bool IsParenInParenthesizedExpression(SyntaxToken token);
    [ExtensionAttribute]
public static bool IsParenInArgumentList(SyntaxToken token);
    [ExtensionAttribute]
public static bool IsEqualsTokenInAutoPropertyInitializers(SyntaxToken token);
    [ExtensionAttribute]
public static bool IsCloseParenInStatement(SyntaxToken token);
    [ExtensionAttribute]
public static bool IsDotInMemberAccessOrQualifiedName(SyntaxToken token);
    [ExtensionAttribute]
public static bool IsDotInMemberAccess(SyntaxToken token);
    [ExtensionAttribute]
public static bool IsGenericGreaterThanToken(SyntaxToken token);
    [ExtensionAttribute]
public static bool IsCommaInInitializerExpression(SyntaxToken token);
    [ExtensionAttribute]
public static bool IsColonInCasePatternSwitchLabel(SyntaxToken token);
    [ExtensionAttribute]
public static bool IsColonInSwitchExpressionArm(SyntaxToken token);
    [ExtensionAttribute]
public static bool IsCommaInSwitchExpression(SyntaxToken token);
    [ExtensionAttribute]
public static bool IsCommaInPropertyPatternClause(SyntaxToken token);
    [ExtensionAttribute]
public static bool IsIdentifierInLabeledStatement(SyntaxToken token);
    [ExtensionAttribute]
public static bool IsColonInSwitchLabel(SyntaxToken token);
    [ExtensionAttribute]
public static bool IsColonInLabeledStatement(SyntaxToken token);
    [NullableContextAttribute("2")]
[ExtensionAttribute]
public static bool IsEmbeddedStatementOwnerWithCloseParen(SyntaxNode node);
    [ExtensionAttribute]
public static bool IsNestedQueryExpression(SyntaxToken token);
    [ExtensionAttribute]
public static bool IsFirstFromKeywordInExpression(SyntaxToken token);
    [NullableContextAttribute("2")]
[ExtensionAttribute]
public static bool IsInitializerForObjectOrAnonymousObjectCreationExpression(SyntaxNode node);
    [NullableContextAttribute("2")]
[ExtensionAttribute]
public static bool IsInitializerForArrayOrCollectionCreationExpression(SyntaxNode node);
    [ExtensionAttribute]
public static bool ParenOrBracketContainsNothing(SyntaxToken token1, SyntaxToken token2);
    [ExtensionAttribute]
public static bool IsLastTokenInLabelStatement(SyntaxToken token);
    [NullableContextAttribute("0")]
[ExtensionAttribute]
public static ValueTuple`2<SyntaxToken, SyntaxToken> GetFirstAndLastMemberDeclarationTokensAfterAttributes(MemberDeclarationSyntax node);
    [ExtensionAttribute]
public static bool IsPlusOrMinusExpression(SyntaxToken token);
    [ExtensionAttribute]
public static bool IsInterpolation(SyntaxToken currentToken);
    [ExtensionAttribute]
public static bool IsOpenParenInVarDeconstructionDeclaration(SyntaxToken currentToken);
    [ExtensionAttribute]
public static bool IsCommaInTupleExpression(SyntaxToken currentToken);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.CodeAnalysis.CSharp.Formatting.FormattingResult : AbstractFormattingResult {
    internal FormattingResult(TreeData treeInfo, TokenStream tokenStream, TextSpan spanToFormat);
    protected virtual SyntaxNode Rewriter(Dictionary`2<ValueTuple`2<SyntaxToken, SyntaxToken>, TriviaData> changeMap, CancellationToken cancellationToken);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.CodeAnalysis.CSharp.Formatting.IndentBlockFormattingRule : BaseFormattingRule {
    internal static string Name;
    private CachedOptions _options;
    private IndentBlockFormattingRule(CachedOptions options);
    public virtual AbstractFormattingRule WithOptions(AnalyzerConfigOptions options);
    public virtual void AddIndentBlockOperations(List`1<IndentBlockOperation> list, SyntaxNode node, NextIndentBlockOperationAction& modreq(System.Runtime.InteropServices.InAttribute) nextOperation);
    private static void AddTypeParameterConstraintClauseOperation(List`1<IndentBlockOperation> list, SyntaxNode node);
    private void AddSwitchIndentationOperation(List`1<IndentBlockOperation> list, SyntaxNode node);
    private void AddLabelIndentationOperation(List`1<IndentBlockOperation> list, SyntaxNode node);
    private static void AddAlignmentBlockOperation(List`1<IndentBlockOperation> list, SyntaxNode node);
    private static void SetAlignmentBlockOperation(List`1<IndentBlockOperation> list, SyntaxNode baseNode, SyntaxNode body);
    private void AddBlockIndentationOperation(List`1<IndentBlockOperation> list, SyntaxNode node);
    [NullableContextAttribute("0")]
private static void AddAlignmentBlockOperationRelativeToFirstTokenOnBaseTokenLine(List`1<IndentBlockOperation> list, ValueTuple`2<SyntaxToken, SyntaxToken> bracePair);
    private static void AddEmbeddedStatementsIndentationOperation(List`1<IndentBlockOperation> list, SyntaxNode node);
    private static void AddEmbeddedStatementsIndentationOperation(List`1<IndentBlockOperation> list, StatementSyntax statement);
}
internal class Microsoft.CodeAnalysis.CSharp.Formatting.IndentUserSettingsFormattingRule : BaseFormattingRule {
    private CachedOptions _options;
    private IndentUserSettingsFormattingRule(CachedOptions options);
    [NullableContextAttribute("1")]
public virtual AbstractFormattingRule WithOptions(AnalyzerConfigOptions options);
    [NullableContextAttribute("1")]
public virtual void AddIndentBlockOperations(List`1<IndentBlockOperation> list, SyntaxNode node, NextIndentBlockOperationAction& modreq(System.Runtime.InteropServices.InAttribute) nextOperation);
}
public enum Microsoft.CodeAnalysis.CSharp.Formatting.LabelPositionOptions : Enum {
    public int value__;
    public static LabelPositionOptions LeftMost;
    public static LabelPositionOptions OneLess;
    public static LabelPositionOptions NoIndent;
}
internal class Microsoft.CodeAnalysis.CSharp.Formatting.NewLineUserSettingFormattingRule : BaseFormattingRule {
    private CachedOptions _options;
    private NewLineUserSettingFormattingRule(CachedOptions options);
    [NullableContextAttribute("1")]
public virtual AbstractFormattingRule WithOptions(AnalyzerConfigOptions options);
    [NullableContextAttribute("1")]
private static bool IsControlBlock(SyntaxNode node);
    [NullableContextAttribute("2")]
public virtual AdjustSpacesOperation GetAdjustSpacesOperation(SyntaxToken& modreq(System.Runtime.InteropServices.InAttribute) previousToken, SyntaxToken& modreq(System.Runtime.InteropServices.InAttribute) currentToken, NextGetAdjustSpacesOperation& modreq(System.Runtime.InteropServices.InAttribute) nextOperation);
    [NullableContextAttribute("2")]
public virtual AdjustNewLinesOperation GetAdjustNewLinesOperation(SyntaxToken& modreq(System.Runtime.InteropServices.InAttribute) previousToken, SyntaxToken& modreq(System.Runtime.InteropServices.InAttribute) currentToken, NextGetAdjustNewLinesOperation& modreq(System.Runtime.InteropServices.InAttribute) nextOperation);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.CodeAnalysis.CSharp.Formatting.QueryExpressionFormattingRule : BaseFormattingRule {
    internal static string Name;
    private CachedOptions _options;
    private QueryExpressionFormattingRule(CachedOptions options);
    public virtual AbstractFormattingRule WithOptions(AnalyzerConfigOptions options);
    public virtual void AddSuppressOperations(List`1<SuppressOperation> list, SyntaxNode node, NextSuppressOperationAction& modreq(System.Runtime.InteropServices.InAttribute) nextOperation);
    private static void AddIndentBlockOperationsForFromClause(List`1<IndentBlockOperation> list, FromClauseSyntax fromClause);
    public virtual void AddIndentBlockOperations(List`1<IndentBlockOperation> list, SyntaxNode node, NextIndentBlockOperationAction& modreq(System.Runtime.InteropServices.InAttribute) nextOperation);
    public virtual void AddAnchorIndentationOperations(List`1<AnchorIndentationOperation> list, SyntaxNode node, NextAnchorIndentationOperationAction& modreq(System.Runtime.InteropServices.InAttribute) nextOperation);
    [NullableContextAttribute("2")]
public virtual AdjustNewLinesOperation GetAdjustNewLinesOperation(SyntaxToken& modreq(System.Runtime.InteropServices.InAttribute) previousToken, SyntaxToken& modreq(System.Runtime.InteropServices.InAttribute) currentToken, NextGetAdjustNewLinesOperation& modreq(System.Runtime.InteropServices.InAttribute) nextOperation);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.CodeAnalysis.CSharp.Formatting.SpacingFormattingRule : BaseFormattingRule {
    private CachedOptions _options;
    private SpacingFormattingRule(CachedOptions options);
    public virtual AbstractFormattingRule WithOptions(AnalyzerConfigOptions options);
    [NullableContextAttribute("2")]
public virtual AdjustSpacesOperation GetAdjustSpacesOperation(SyntaxToken& modreq(System.Runtime.InteropServices.InAttribute) previousToken, SyntaxToken& modreq(System.Runtime.InteropServices.InAttribute) currentToken, NextGetAdjustSpacesOperation& modreq(System.Runtime.InteropServices.InAttribute) nextOperation);
    public virtual void AddSuppressOperations(List`1<SuppressOperation> list, SyntaxNode node, NextSuppressOperationAction& modreq(System.Runtime.InteropServices.InAttribute) nextOperation);
    private static bool IsEmptyForStatement(ForStatementSyntax forStatement);
    private void SuppressVariableDeclaration(List`1<SuppressOperation> list, SyntaxNode node);
    private static AdjustSpacesOperation AdjustSpacesOperationZeroOrOne(bool option, AdjustSpacesOption explicitOption);
    private static bool HasFormattableBracketParent(SyntaxToken token);
    private static bool IsFunctionLikeKeywordExpressionKind(SyntaxKind syntaxKind);
    private static bool IsControlFlowLikeKeywordStatementKind(SyntaxKind syntaxKind);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
internal class Microsoft.CodeAnalysis.CSharp.Formatting.StructuredTriviaFormattingRule : BaseFormattingRule {
    [NullableAttribute("1")]
internal static string Name;
    public virtual AdjustNewLinesOperation GetAdjustNewLinesOperation(SyntaxToken& modreq(System.Runtime.InteropServices.InAttribute) previousToken, SyntaxToken& modreq(System.Runtime.InteropServices.InAttribute) currentToken, NextGetAdjustNewLinesOperation& modreq(System.Runtime.InteropServices.InAttribute) nextOperation);
    public virtual AdjustSpacesOperation GetAdjustSpacesOperation(SyntaxToken& modreq(System.Runtime.InteropServices.InAttribute) previousToken, SyntaxToken& modreq(System.Runtime.InteropServices.InAttribute) currentToken, NextGetAdjustSpacesOperation& modreq(System.Runtime.InteropServices.InAttribute) nextOperation);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.CodeAnalysis.CSharp.Formatting.SuppressFormattingRule : BaseFormattingRule {
    internal static string Name;
    public virtual void AddSuppressOperations(List`1<SuppressOperation> list, SyntaxNode node, NextSuppressOperationAction& modreq(System.Runtime.InteropServices.InAttribute) nextOperation);
    private static void AddSpecificNodesSuppressOperations(List`1<SuppressOperation> list, SyntaxNode node);
    private static void AddStatementExceptBlockSuppressOperations(List`1<SuppressOperation> list, SyntaxNode node);
    private static void AddFormatSuppressOperations(List`1<SuppressOperation> list, SyntaxNode node);
    [NullableContextAttribute("2")]
private static bool IsFormatDirective(DirectiveTriviaSyntax trivia, SyntaxKind disableOrRestoreKeyword);
    private static void AddInitializerSuppressOperations(List`1<SuppressOperation> list, SyntaxNode node);
    private static void AddInitializerSuppressOperations(List`1<SuppressOperation> list, SyntaxNode parent, IEnumerable`1<SyntaxNode> items);
    private static InitializerExpressionSyntax GetInitializerNode(SyntaxNode node);
    [CompilerGeneratedAttribute]
internal static void <AddFormatSuppressOperations>g__ProcessTriviaList|4_0(List`1<SuppressOperation> list, SyntaxTriviaList triviaList);
    [CompilerGeneratedAttribute]
internal static void <AddFormatSuppressOperations>g__ProcessTrivia|4_1(List`1<SuppressOperation> list, SyntaxTrivia trivia);
    [CompilerGeneratedAttribute]
internal static void <AddFormatSuppressOperations>g__ProcessStructuredTrivia|4_2(List`1<SuppressOperation> list, SyntaxNode structure);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.CodeAnalysis.CSharp.Formatting.TokenBasedFormattingRule : BaseFormattingRule {
    internal static string Name;
    private CachedOptions _options;
    private TokenBasedFormattingRule(CachedOptions options);
    public virtual AbstractFormattingRule WithOptions(AnalyzerConfigOptions options);
    [NullableContextAttribute("2")]
public virtual AdjustNewLinesOperation GetAdjustNewLinesOperation(SyntaxToken& modreq(System.Runtime.InteropServices.InAttribute) previousToken, SyntaxToken& modreq(System.Runtime.InteropServices.InAttribute) currentToken, NextGetAdjustNewLinesOperation& modreq(System.Runtime.InteropServices.InAttribute) nextOperation);
    private AdjustNewLinesOperation AdjustNewLinesAfterSemicolonToken(SyntaxToken previousToken, SyntaxToken currentToken);
    private static SyntaxList`1<UsingDirectiveSyntax> GetUsings(SyntaxNode node);
    [NullableContextAttribute("2")]
public virtual AdjustSpacesOperation GetAdjustSpacesOperation(SyntaxToken& modreq(System.Runtime.InteropServices.InAttribute) previousToken, SyntaxToken& modreq(System.Runtime.InteropServices.InAttribute) currentToken, NextGetAdjustSpacesOperation& modreq(System.Runtime.InteropServices.InAttribute) nextOperation);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.CodeAnalysis.CSharp.Formatting.TriviaDataFactory : AbstractTriviaDataFactory {
    public TriviaDataFactory(TreeData treeInfo, AnalyzerConfigOptions options);
    private static bool IsCSharpWhitespace(char c);
    public virtual TriviaData CreateLeadingTrivia(SyntaxToken token);
    public virtual TriviaData CreateTrailingTrivia(SyntaxToken token);
    public virtual TriviaData Create(SyntaxToken token1, SyntaxToken token2);
    private static bool ContainsOnlyWhitespace(AnalysisResult result);
    [NullableContextAttribute("2")]
private TriviaData GetWhitespaceOnlyTriviaInfo(SyntaxToken token1, SyntaxToken token2, AnalysisResult result);
    private int CalculateSpaces(SyntaxToken token1, SyntaxToken token2);
    [NullableContextAttribute("0")]
private ValueTuple`3<bool, int, int> GetLineBreaksAndIndentation(AnalysisResult result);
    private static int GetSpaceOnSingleLine(AnalysisResult result);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.CodeAnalysis.CSharp.Formatting.TriviaRewriter : CSharpSyntaxRewriter {
    private SyntaxNode _node;
    private SimpleIntervalTree`2<TextSpan, TextSpanIntervalIntrospector> _spans;
    private CancellationToken _cancellationToken;
    private Dictionary`2<SyntaxToken, SyntaxTriviaList> _trailingTriviaMap;
    private Dictionary`2<SyntaxToken, SyntaxTriviaList> _leadingTriviaMap;
    public TriviaRewriter(SyntaxNode node, SimpleIntervalTree`2<TextSpan, TextSpanIntervalIntrospector> spanToFormat, Dictionary`2<ValueTuple`2<SyntaxToken, SyntaxToken>, TriviaData> map, CancellationToken cancellationToken);
    public SyntaxNode Transform();
    private void PreprocessTriviaListMap(Dictionary`2<ValueTuple`2<SyntaxToken, SyntaxToken>, TriviaData> map, CancellationToken cancellationToken);
    [NullableContextAttribute("0")]
private ValueTuple`2<SyntaxTriviaList, SyntaxTriviaList> GetTrailingAndLeadingTrivia(KeyValuePair`2<ValueTuple`2<SyntaxToken, SyntaxToken>, TriviaData> pair, CancellationToken cancellationToken);
    [NullableContextAttribute("0")]
private TextSpan GetTextSpan(ValueTuple`2<SyntaxToken, SyntaxToken> pair);
    private static int GetFirstEndOfLineIndexOrRightBeforeComment(SyntaxTriviaList triviaList);
    [NullableContextAttribute("0")]
private SyntaxTriviaList GetLeadingTriviaAtBeginningOfTree(ValueTuple`2<SyntaxToken, SyntaxToken> pair, TriviaData triviaData, CancellationToken cancellationToken);
    [NullableContextAttribute("2")]
public virtual SyntaxNode Visit(SyntaxNode node);
    public virtual SyntaxToken VisitToken(SyntaxToken token);
    private static SyntaxToken CreateNewToken(SyntaxTriviaList leadingTrivia, SyntaxToken token, SyntaxTriviaList trailingTrivia);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.CodeAnalysis.CSharp.Formatting.WrappingFormattingRule : BaseFormattingRule {
    private CachedOptions _options;
    private WrappingFormattingRule(CachedOptions options);
    public virtual AbstractFormattingRule WithOptions(AnalyzerConfigOptions options);
    public virtual void AddSuppressOperations(List`1<SuppressOperation> list, SyntaxNode node, NextSuppressOperationAction& modreq(System.Runtime.InteropServices.InAttribute) nextOperation);
    [NullableContextAttribute("0")]
private static ValueTuple`2<SyntaxToken, SyntaxToken> GetSpecificNodeSuppressionTokenRange(SyntaxNode node);
    private static void AddSpecificNodesSuppressOperations(List`1<SuppressOperation> list, SyntaxNode node);
    private static void AddStatementExceptBlockSuppressOperations(List`1<SuppressOperation> list, SyntaxNode node);
    private static void RemoveSuppressOperationForStatementMethodDeclaration(List`1<SuppressOperation> list, SyntaxNode node);
    private static void RemoveSuppressOperationForBlock(List`1<SuppressOperation> list, SyntaxNode node);
    [NullableContextAttribute("0")]
private static ValueTuple`2<SyntaxToken, SyntaxToken> GetBracePair(SyntaxNode node);
    private static void RemoveSuppressOperation(List`1<SuppressOperation> list, SyntaxToken startToken, SyntaxToken endToken);
}
[ExportLanguageServiceAttribute("Microsoft.CodeAnalysis.GeneratedCodeRecognition.IGeneratedCodeRecognitionService", "C#", "Default")]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.CSharp.GeneratedCodeRecognition.CSharpGeneratedCodeRecognitionService : AbstractGeneratedCodeRecognitionService {
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[ExportLanguageServiceAttribute("Microsoft.CodeAnalysis.Indentation.IIndentationService", "C#", "Default")]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.CSharp.Indentation.CSharpIndentationService : AbstractIndentationService`1<CompilationUnitSyntax> {
    public static CSharpIndentationService Instance;
    private static AbstractFormattingRule s_instance;
    private static CSharpIndentationService();
    protected virtual AbstractFormattingRule GetSpecializedIndentationFormattingRule(IndentStyle indentStyle);
    public static bool ShouldUseSmartTokenFormatterInsteadOfIndenter(IEnumerable`1<AbstractFormattingRule> formattingRules, CompilationUnitSyntax root, TextLine line, IOptionService optionService, OptionSet optionSet, SyntaxToken& token);
    private static bool IsInvalidToken(SyntaxToken token);
    protected virtual bool ShouldUseTokenIndenter(Indenter<CompilationUnitSyntax> indenter, SyntaxToken& syntaxToken);
    protected virtual ISmartTokenFormatter CreateSmartTokenFormatter(Indenter<CompilationUnitSyntax> indenter);
    protected virtual Nullable`1<IndentationResult> GetDesiredIndentationWorker(Indenter<CompilationUnitSyntax> indenter, Nullable`1<SyntaxToken> tokenOpt, Nullable`1<SyntaxTrivia> triviaOpt);
    private static Nullable`1<IndentationResult> TryGetDesiredIndentation(Indenter<CompilationUnitSyntax> indenter, Nullable`1<SyntaxTrivia> triviaOpt);
    private static Nullable`1<IndentationResult> TryGetDesiredIndentation(Indenter<CompilationUnitSyntax> indenter, Nullable`1<SyntaxToken> tokenOpt);
    private static IndentationResult GetIndentationBasedOnToken(Indenter<CompilationUnitSyntax> indenter, SyntaxToken token);
    private static IndentationResult GetIndentationFromCommaSeparatedList(Indenter<CompilationUnitSyntax> indenter, SyntaxToken token);
    [NullableContextAttribute("0")]
private static IndentationResult GetIndentationFromCommaSeparatedList(Indenter<CompilationUnitSyntax> indenter, SeparatedSyntaxList`1<T> list, SyntaxToken token);
    private static IndentationResult GetDefaultIndentationFromToken(Indenter<CompilationUnitSyntax> indenter, SyntaxToken token);
    private static IndentationResult GetIndentationForQueryExpression(Indenter<CompilationUnitSyntax> indenter, SyntaxToken token);
    [NullableContextAttribute("2")]
private static SyntaxNode GetQueryExpressionClause(SyntaxToken token);
    private static bool IsPartOfQueryExpression(SyntaxToken token);
    private static IndentationResult GetDefaultIndentationFromTokenLine(Indenter<CompilationUnitSyntax> indenter, SyntaxToken token, Nullable`1<int> additionalSpace);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.CodeAnalysis.CSharp.Indentation.CSharpSmartTokenFormatter : object {
    private OptionSet _optionSet;
    private IEnumerable`1<AbstractFormattingRule> _formattingRules;
    private CompilationUnitSyntax _root;
    public CSharpSmartTokenFormatter(OptionSet optionSet, IEnumerable`1<AbstractFormattingRule> formattingRules, CompilationUnitSyntax root);
    public IList`1<TextChange> FormatRange(Workspace workspace, SyntaxToken startToken, SyntaxToken endToken, CancellationToken cancellationToken);
    private static bool CloseBraceOfTryOrDoBlock(SyntaxToken endToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.CSharp.Indentation.CSharpSmartTokenFormatter/<FormatTokenAsync>d__6")]
public sealed virtual Task`1<IList`1<TextChange>> FormatTokenAsync(Workspace workspace, SyntaxToken token, CancellationToken cancellationToken);
}
internal class Microsoft.CodeAnalysis.CSharp.LanguageServices.CSharpDocumentationCommentService : AbstractDocumentationCommentService`10<DocumentationCommentTriviaSyntax, XmlNodeSyntax, XmlAttributeSyntax, CrefSyntax, XmlElementSyntax, XmlTextSyntax, XmlEmptyElementSyntax, XmlCrefAttributeSyntax, XmlNameAttributeSyntax, XmlTextAttributeSyntax> {
    public static IDocumentationCommentService Instance;
    private static CSharpDocumentationCommentService();
    protected virtual SyntaxList`1<XmlAttributeSyntax> GetAttributes(XmlEmptyElementSyntax xmlEmpty);
    protected virtual CrefSyntax GetCref(XmlCrefAttributeSyntax xmlCref);
    protected virtual SyntaxToken GetIdentifier(XmlNameAttributeSyntax xmlName);
    protected virtual SyntaxNode GetName(XmlElementSyntax xmlElement);
    protected virtual SyntaxTokenList GetTextTokens(XmlTextAttributeSyntax xmlTextAttribute);
    protected virtual SyntaxTokenList GetTextTokens(XmlTextSyntax xmlText);
}
internal class Microsoft.CodeAnalysis.CSharp.LanguageServices.CSharpSelectedMembers : AbstractSelectedMembers`5<MemberDeclarationSyntax, FieldDeclarationSyntax, PropertyDeclarationSyntax, TypeDeclarationSyntax, VariableDeclaratorSyntax> {
    public static CSharpSelectedMembers Instance;
    private static CSharpSelectedMembers();
    protected virtual IEnumerable`1<VariableDeclaratorSyntax> GetAllDeclarators(FieldDeclarationSyntax field);
    protected virtual SyntaxList`1<MemberDeclarationSyntax> GetMembers(TypeDeclarationSyntax containingType);
    protected virtual SyntaxToken GetPropertyIdentifier(PropertyDeclarationSyntax declarator);
    protected virtual SyntaxToken GetVariableIdentifier(VariableDeclaratorSyntax declarator);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
internal class Microsoft.CodeAnalysis.CSharp.LanguageServices.CSharpSyntaxFacts : AbstractSyntaxFacts {
    [NullableAttribute("1")]
internal static CSharpSyntaxFacts Instance;
    [NullableAttribute("1")]
[CompilerGeneratedAttribute]
private StringComparer <StringComparer>k__BackingField;
    [NullableAttribute("1")]
[CompilerGeneratedAttribute]
private ISyntaxKinds <SyntaxKinds>k__BackingField;
    [NullableAttribute("1")]
private static string dotToken;
    public bool IsCaseSensitive { get; }
    [NullableAttribute("1")]
public StringComparer StringComparer { get; }
    public SyntaxTrivia ElasticMarker { get; }
    public SyntaxTrivia ElasticCarriageReturnLineFeed { get; }
    [NullableAttribute("1")]
public ISyntaxKinds SyntaxKinds { get; }
    [NullableAttribute("1")]
protected IDocumentationCommentService DocumentationCommentService { get; }
    private static CSharpSyntaxFacts();
    public sealed virtual bool get_IsCaseSensitive();
    [NullableContextAttribute("1")]
[CompilerGeneratedAttribute]
public sealed virtual StringComparer get_StringComparer();
    public sealed virtual SyntaxTrivia get_ElasticMarker();
    public sealed virtual SyntaxTrivia get_ElasticCarriageReturnLineFeed();
    [NullableContextAttribute("1")]
[CompilerGeneratedAttribute]
public virtual ISyntaxKinds get_SyntaxKinds();
    [NullableContextAttribute("1")]
protected virtual IDocumentationCommentService get_DocumentationCommentService();
    [NullableContextAttribute("1")]
public sealed virtual bool SupportsIndexingInitializer(ParseOptions options);
    [NullableContextAttribute("1")]
public sealed virtual bool SupportsThrowExpression(ParseOptions options);
    [NullableContextAttribute("1")]
public sealed virtual bool SupportsLocalFunctionDeclaration(ParseOptions options);
    [NullableContextAttribute("1")]
public sealed virtual bool SupportsRecord(ParseOptions options);
    [NullableContextAttribute("1")]
public sealed virtual SyntaxToken ParseToken(string text);
    [NullableContextAttribute("1")]
public sealed virtual SyntaxTriviaList ParseLeadingTrivia(string text);
    [NullableContextAttribute("1")]
public sealed virtual string EscapeIdentifier(string identifier);
    public sealed virtual bool IsVerbatimIdentifier(SyntaxToken token);
    public sealed virtual bool IsOperator(SyntaxToken token);
    public sealed virtual bool IsReservedKeyword(SyntaxToken token);
    public sealed virtual bool IsContextualKeyword(SyntaxToken token);
    public sealed virtual bool IsPreprocessorKeyword(SyntaxToken token);
    [NullableContextAttribute("1")]
public sealed virtual bool IsPreProcessorDirectiveContext(SyntaxTree syntaxTree, int position, CancellationToken cancellationToken);
    public sealed virtual bool IsEntirelyWithinStringOrCharOrNumericLiteral(SyntaxTree syntaxTree, int position, CancellationToken cancellationToken);
    public sealed virtual bool IsDirective(SyntaxNode node);
    public sealed virtual bool TryGetExternalSourceInfo(SyntaxNode node, ExternalSourceInfo& info);
    public sealed virtual bool IsRightSideOfQualifiedName(SyntaxNode node);
    public sealed virtual bool IsNameOfSimpleMemberAccessExpression(SyntaxNode node);
    public sealed virtual bool IsNameOfAnyMemberAccessExpression(SyntaxNode node);
    public sealed virtual bool IsNameOfMemberBindingExpression(SyntaxNode node);
    public sealed virtual SyntaxNode GetStandaloneExpression(SyntaxNode node);
    public sealed virtual SyntaxNode GetRootConditionalAccessExpression(SyntaxNode node);
    public sealed virtual bool IsObjectCreationExpressionType(SyntaxNode node);
    public sealed virtual bool IsDeclarationExpression(SyntaxNode node);
    [NullableContextAttribute("1")]
public sealed virtual bool IsAttributeName(SyntaxNode node);
    public sealed virtual bool IsAnonymousFunction(SyntaxNode node);
    public sealed virtual bool IsNamedArgument(SyntaxNode node);
    public sealed virtual bool IsNameOfNamedArgument(SyntaxNode node);
    public sealed virtual Nullable`1<SyntaxToken> GetNameOfParameter(SyntaxNode node);
    public sealed virtual SyntaxNode GetDefaultOfParameter(SyntaxNode node);
    [NullableContextAttribute("1")]
public sealed virtual SyntaxNode GetParameterList(SyntaxNode node);
    public sealed virtual bool IsParameterList(SyntaxNode node);
    public sealed virtual SyntaxToken GetIdentifierOfGenericName(SyntaxNode genericName);
    public sealed virtual bool IsUsingDirectiveName(SyntaxNode node);
    public sealed virtual bool IsUsingAliasDirective(SyntaxNode node);
    public sealed virtual bool IsDeconstructionForEachStatement(SyntaxNode node);
    public sealed virtual bool IsDeconstructionAssignment(SyntaxNode node);
    [NullableContextAttribute("1")]
public sealed virtual Location GetDeconstructionReferenceLocation(SyntaxNode node);
    public sealed virtual bool IsStatement(SyntaxNode node);
    public sealed virtual bool IsExecutableStatement(SyntaxNode node);
    public sealed virtual bool IsMethodBody(SyntaxNode node);
    public sealed virtual SyntaxNode GetExpressionOfReturnStatement(SyntaxNode node);
    public sealed virtual bool IsThisConstructorInitializer(SyntaxToken token);
    public sealed virtual bool IsBaseConstructorInitializer(SyntaxToken token);
    public sealed virtual bool IsQueryKeyword(SyntaxToken token);
    [NullableContextAttribute("1")]
public sealed virtual bool IsThrowExpression(SyntaxNode node);
    public sealed virtual bool IsPredefinedType(SyntaxToken token);
    public sealed virtual bool IsPredefinedType(SyntaxToken token, PredefinedType type);
    public sealed virtual bool TryGetPredefinedType(SyntaxToken token, PredefinedType& type);
    private static PredefinedType GetPredefinedType(SyntaxToken token);
    public sealed virtual bool IsPredefinedOperator(SyntaxToken token);
    public sealed virtual bool IsPredefinedOperator(SyntaxToken token, PredefinedOperator op);
    public sealed virtual bool TryGetPredefinedOperator(SyntaxToken token, PredefinedOperator& op);
    private static PredefinedOperator GetPredefinedOperator(SyntaxToken token);
    [NullableContextAttribute("1")]
public sealed virtual string GetText(int kind);
    public sealed virtual bool IsIdentifierStartCharacter(char c);
    public sealed virtual bool IsIdentifierPartCharacter(char c);
    public sealed virtual bool IsIdentifierEscapeCharacter(char c);
    [NullableContextAttribute("1")]
public sealed virtual bool IsValidIdentifier(string identifier);
    [NullableContextAttribute("1")]
public sealed virtual bool IsVerbatimIdentifier(string identifier);
    public sealed virtual bool IsTypeCharacter(char c);
    public sealed virtual bool IsStartOfUnicodeEscapeSequence(char c);
    public sealed virtual bool IsLiteral(SyntaxToken token);
    public sealed virtual bool IsStringLiteralOrInterpolatedStringLiteral(SyntaxToken token);
    public sealed virtual bool IsNumericLiteralExpression(SyntaxNode node);
    public sealed virtual bool IsTypeNamedVarInVariableOrFieldDeclaration(SyntaxToken token, SyntaxNode parent);
    public sealed virtual bool IsTypeNamedDynamic(SyntaxToken token, SyntaxNode parent);
    public sealed virtual bool IsBindableToken(SyntaxToken token);
    [NullableContextAttribute("1")]
public sealed virtual void GetPartsOfConditionalAccessExpression(SyntaxNode node, SyntaxNode& expression, SyntaxToken& operatorToken, SyntaxNode& whenNotNull);
    public sealed virtual bool IsPostfixUnaryExpression(SyntaxNode node);
    public sealed virtual bool IsMemberBindingExpression(SyntaxNode node);
    public sealed virtual bool IsPointerMemberAccessExpression(SyntaxNode node);
    public sealed virtual void GetNameAndArityOfSimpleName(SyntaxNode node, String& name, Int32& arity);
    [NullableContextAttribute("1")]
public sealed virtual bool LooksGeneric(SyntaxNode simpleName);
    public sealed virtual SyntaxNode GetTargetOfMemberBinding(SyntaxNode node);
    [NullableContextAttribute("1")]
public sealed virtual SyntaxNode GetNameOfMemberBindingExpression(SyntaxNode node);
    public sealed virtual SyntaxNode GetExpressionOfMemberAccessExpression(SyntaxNode node, bool allowImplicitTarget);
    public sealed virtual void GetPartsOfElementAccessExpression(SyntaxNode node, SyntaxNode& expression, SyntaxNode& argumentList);
    public sealed virtual SyntaxNode GetExpressionOfInterpolation(SyntaxNode node);
    [NullableContextAttribute("1")]
public sealed virtual bool IsInStaticContext(SyntaxNode node);
    public sealed virtual bool IsInNamespaceOrTypeContext(SyntaxNode node);
    public sealed virtual bool IsBaseTypeList(SyntaxNode node);
    public sealed virtual SyntaxNode GetExpressionOfArgument(SyntaxNode node);
    public sealed virtual RefKind GetRefKindOfArgument(SyntaxNode node);
    public sealed virtual bool IsArgument(SyntaxNode node);
    public sealed virtual bool IsSimpleArgument(SyntaxNode node);
    public sealed virtual bool IsInConstantContext(SyntaxNode node);
    [NullableContextAttribute("1")]
public sealed virtual bool IsInConstructor(SyntaxNode node);
    [NullableContextAttribute("1")]
public sealed virtual bool IsUnsafeContext(SyntaxNode node);
    [NullableContextAttribute("1")]
public sealed virtual SyntaxNode GetNameOfAttribute(SyntaxNode node);
    [NullableContextAttribute("1")]
public sealed virtual SyntaxNode GetExpressionOfParenthesizedExpression(SyntaxNode node);
    public sealed virtual bool IsAttributeNamedArgumentIdentifier(SyntaxNode node);
    public sealed virtual SyntaxNode GetContainingTypeDeclaration(SyntaxNode root, int position);
    public sealed virtual SyntaxNode GetContainingVariableDeclaratorOfFieldDeclaration(SyntaxNode node);
    [NullableContextAttribute("1")]
public sealed virtual SyntaxToken FindTokenOnLeftOfPosition(SyntaxNode node, int position, bool includeSkipped, bool includeDirectives, bool includeDocumentationComments);
    [NullableContextAttribute("1")]
public sealed virtual SyntaxToken FindTokenOnRightOfPosition(SyntaxNode node, int position, bool includeSkipped, bool includeDirectives, bool includeDocumentationComments);
    public sealed virtual bool IsNameOfSubpattern(SyntaxNode node);
    [NullableContextAttribute("1")]
public sealed virtual bool IsPropertyPatternClause(SyntaxNode node);
    public sealed virtual bool IsMemberInitializerNamedAssignmentIdentifier(SyntaxNode node);
    public sealed virtual bool IsMemberInitializerNamedAssignmentIdentifier(SyntaxNode node, SyntaxNode& initializedInstance);
    [NullableContextAttribute("1")]
public sealed virtual bool IsElementAccessExpression(SyntaxNode node);
    public sealed virtual SyntaxNode ConvertToSingleLine(SyntaxNode node, bool useElasticTrivia);
    [NullableContextAttribute("1")]
public sealed virtual void GetPartsOfParenthesizedExpression(SyntaxNode node, SyntaxToken& openParen, SyntaxNode& expression, SyntaxToken& closeParen);
    [NullableContextAttribute("1")]
public sealed virtual bool IsIndexerMemberCRef(SyntaxNode node);
    public sealed virtual SyntaxNode GetContainingMemberDeclaration(SyntaxNode root, int position, bool useFullSpan);
    public sealed virtual bool IsMethodLevelMember(SyntaxNode node);
    public sealed virtual bool IsTopLevelNodeWithMembers(SyntaxNode node);
    public sealed virtual string GetDisplayName(SyntaxNode node, DisplayNameOptions options, string rootNamespace);
    [NullableContextAttribute("1")]
private static string GetName(SyntaxNode node, DisplayNameOptions options);
    [NullableContextAttribute("1")]
private static void AppendTypeParameterList(StringBuilder builder, TypeParameterListSyntax typeParameterList);
    [NullableContextAttribute("1")]
public sealed virtual List`1<SyntaxNode> GetTopLevelAndMethodLevelMembers(SyntaxNode root);
    [NullableContextAttribute("1")]
public sealed virtual List`1<SyntaxNode> GetMethodLevelMembers(SyntaxNode root);
    public sealed virtual bool IsClassDeclaration(SyntaxNode node);
    public sealed virtual bool IsNamespaceDeclaration(SyntaxNode node);
    public sealed virtual SyntaxNode GetNameOfNamespaceDeclaration(SyntaxNode node);
    [NullableContextAttribute("1")]
public sealed virtual SyntaxList`1<SyntaxNode> GetMembersOfTypeDeclaration(SyntaxNode typeDeclaration);
    [NullableContextAttribute("1")]
public sealed virtual SyntaxList`1<SyntaxNode> GetMembersOfNamespaceDeclaration(SyntaxNode namespaceDeclaration);
    [NullableContextAttribute("1")]
public sealed virtual SyntaxList`1<SyntaxNode> GetMembersOfCompilationUnit(SyntaxNode compilationUnit);
    [NullableContextAttribute("1")]
private void AppendMembers(SyntaxNode node, List`1<SyntaxNode> list, bool topLevel, bool methodLevel);
    [NullableContextAttribute("1")]
public sealed virtual TextSpan GetMemberBodySpanForSpeculativeBinding(SyntaxNode node);
    public sealed virtual bool ContainsInMemberBody(SyntaxNode node, TextSpan span);
    [NullableContextAttribute("1")]
private static TextSpan GetBlockBodySpan(BlockSyntax body);
    public sealed virtual SyntaxNode TryGetBindableParent(SyntaxToken token);
    [NullableContextAttribute("1")]
public sealed virtual IEnumerable`1<SyntaxNode> GetConstructors(SyntaxNode root, CancellationToken cancellationToken);
    [NullableContextAttribute("1")]
private void AppendConstructors(SyntaxList`1<MemberDeclarationSyntax> members, List`1<SyntaxNode> constructors, CancellationToken cancellationToken);
    public sealed virtual bool TryGetCorrespondingOpenBrace(SyntaxToken token, SyntaxToken& openBrace);
    [NullableContextAttribute("1")]
public sealed virtual TextSpan GetInactiveRegionSpanAroundPosition(SyntaxTree syntaxTree, int position, CancellationToken cancellationToken);
    [NullableContextAttribute("1")]
public sealed virtual string GetNameForArgument(SyntaxNode argument);
    [NullableContextAttribute("1")]
public sealed virtual string GetNameForAttributeArgument(SyntaxNode argument);
    public sealed virtual bool IsLeftSideOfDot(SyntaxNode node);
    public sealed virtual SyntaxNode GetRightSideOfDot(SyntaxNode node);
    public sealed virtual SyntaxNode GetLeftSideOfDot(SyntaxNode node, bool allowImplicitTarget);
    public sealed virtual bool IsLeftSideOfExplicitInterfaceSpecifier(SyntaxNode node);
    public sealed virtual bool IsLeftSideOfAssignment(SyntaxNode node);
    public sealed virtual bool IsLeftSideOfAnyAssignment(SyntaxNode node);
    public sealed virtual bool IsLeftSideOfCompoundAssignment(SyntaxNode node);
    public sealed virtual SyntaxNode GetRightHandSideOfAssignment(SyntaxNode node);
    public sealed virtual bool IsInferredAnonymousObjectMemberDeclarator(SyntaxNode node);
    public sealed virtual bool IsOperandOfIncrementExpression(SyntaxNode node);
    public static bool IsOperandOfDecrementExpression(SyntaxNode node);
    public sealed virtual bool IsOperandOfIncrementOrDecrementExpression(SyntaxNode node);
    [NullableContextAttribute("1")]
public sealed virtual SyntaxList`1<SyntaxNode> GetContentsOfInterpolatedString(SyntaxNode interpolatedString);
    public sealed virtual bool IsVerbatimStringLiteral(SyntaxToken token);
    public sealed virtual bool IsNumericLiteral(SyntaxToken token);
    [NullableContextAttribute("1")]
public sealed virtual void GetPartsOfInvocationExpression(SyntaxNode node, SyntaxNode& expression, SyntaxNode& argumentList);
    public sealed virtual SeparatedSyntaxList`1<SyntaxNode> GetArgumentsOfInvocationExpression(SyntaxNode invocationExpression);
    public sealed virtual SeparatedSyntaxList`1<SyntaxNode> GetArgumentsOfObjectCreationExpression(SyntaxNode objectCreationExpression);
    public sealed virtual SeparatedSyntaxList`1<SyntaxNode> GetArgumentsOfArgumentList(SyntaxNode argumentList);
    [NullableContextAttribute("1")]
public sealed virtual SyntaxNode GetArgumentListOfInvocationExpression(SyntaxNode invocationExpression);
    [NullableContextAttribute("1")]
public sealed virtual SyntaxNode GetArgumentListOfObjectCreationExpression(SyntaxNode objectCreationExpression);
    public sealed virtual bool IsRegularComment(SyntaxTrivia trivia);
    public sealed virtual bool IsDocumentationComment(SyntaxTrivia trivia);
    public sealed virtual bool IsElastic(SyntaxTrivia trivia);
    public sealed virtual bool IsPragmaDirective(SyntaxTrivia trivia, Boolean& isDisable, Boolean& isActive, SeparatedSyntaxList`1& errorCodes);
    public sealed virtual bool IsDocumentationCommentExteriorTrivia(SyntaxTrivia trivia);
    [NullableContextAttribute("1")]
public sealed virtual bool IsDocumentationComment(SyntaxNode node);
    public sealed virtual bool IsUsingOrExternOrImport(SyntaxNode node);
    public sealed virtual bool IsGlobalAssemblyAttribute(SyntaxNode node);
    public sealed virtual bool IsGlobalModuleAttribute(SyntaxNode node);
    private static bool IsGlobalAttribute(SyntaxNode node, SyntaxKind attributeTarget);
    [NullableContextAttribute("1")]
private static bool IsMemberDeclaration(SyntaxNode node);
    [NullableContextAttribute("1")]
public sealed virtual bool IsDeclaration(SyntaxNode node);
    [NullableContextAttribute("1")]
public sealed virtual bool IsTypeDeclaration(SyntaxNode node);
    [NullableContextAttribute("1")]
public sealed virtual SyntaxNode GetObjectCreationInitializer(SyntaxNode node);
    [NullableContextAttribute("1")]
public sealed virtual SyntaxNode GetObjectCreationType(SyntaxNode node);
    public sealed virtual bool IsSimpleAssignmentStatement(SyntaxNode statement);
    [NullableContextAttribute("1")]
public sealed virtual void GetPartsOfAssignmentStatement(SyntaxNode statement, SyntaxNode& left, SyntaxToken& operatorToken, SyntaxNode& right);
    [NullableContextAttribute("1")]
public sealed virtual void GetPartsOfAssignmentExpressionOrStatement(SyntaxNode statement, SyntaxNode& left, SyntaxToken& operatorToken, SyntaxNode& right);
    [NullableContextAttribute("1")]
public sealed virtual SyntaxNode GetNameOfMemberAccessExpression(SyntaxNode memberAccessExpression);
    [NullableContextAttribute("1")]
public sealed virtual void GetPartsOfMemberAccessExpression(SyntaxNode node, SyntaxNode& expression, SyntaxToken& operatorToken, SyntaxNode& name);
    [NullableContextAttribute("1")]
public sealed virtual SyntaxToken GetIdentifierOfSimpleName(SyntaxNode node);
    [NullableContextAttribute("1")]
public sealed virtual SyntaxToken GetIdentifierOfVariableDeclarator(SyntaxNode node);
    [NullableContextAttribute("1")]
public sealed virtual SyntaxToken GetIdentifierOfParameter(SyntaxNode node);
    [NullableContextAttribute("1")]
public sealed virtual SyntaxToken GetIdentifierOfIdentifierName(SyntaxNode node);
    public sealed virtual bool IsLocalFunctionStatement(SyntaxNode node);
    [NullableContextAttribute("1")]
public sealed virtual bool IsDeclaratorOfLocalDeclarationStatement(SyntaxNode declarator, SyntaxNode localDeclarationStatement);
    public sealed virtual bool AreEquivalent(SyntaxToken token1, SyntaxToken token2);
    public sealed virtual bool AreEquivalent(SyntaxNode node1, SyntaxNode node2);
    public sealed virtual bool IsExpressionOfInvocationExpression(SyntaxNode node);
    public sealed virtual bool IsExpressionOfAwaitExpression(SyntaxNode node);
    public sealed virtual bool IsExpressionOfMemberAccessExpression(SyntaxNode node);
    [NullableContextAttribute("1")]
public static SyntaxNode GetExpressionOfInvocationExpression(SyntaxNode node);
    [NullableContextAttribute("1")]
public sealed virtual SyntaxNode GetExpressionOfAwaitExpression(SyntaxNode node);
    public sealed virtual bool IsExpressionOfForeach(SyntaxNode node);
    [NullableContextAttribute("1")]
public sealed virtual SyntaxNode GetExpressionOfExpressionStatement(SyntaxNode node);
    public sealed virtual bool IsBinaryExpression(SyntaxNode node);
    public sealed virtual bool IsIsExpression(SyntaxNode node);
    [NullableContextAttribute("1")]
public sealed virtual void GetPartsOfBinaryExpression(SyntaxNode node, SyntaxNode& left, SyntaxToken& operatorToken, SyntaxNode& right);
    [NullableContextAttribute("1")]
public sealed virtual void GetPartsOfConditionalExpression(SyntaxNode node, SyntaxNode& condition, SyntaxNode& whenTrue, SyntaxNode& whenFalse);
    public sealed virtual SyntaxNode WalkDownParentheses(SyntaxNode node);
    [NullableContextAttribute("1")]
public sealed virtual void GetPartsOfTupleExpression(SyntaxNode node, SyntaxToken& openParen, SeparatedSyntaxList`1& arguments, SyntaxToken& closeParen);
    [NullableContextAttribute("1")]
public sealed virtual SyntaxNode GetOperandOfPrefixUnaryExpression(SyntaxNode node);
    [NullableContextAttribute("1")]
public sealed virtual SyntaxToken GetOperatorTokenOfPrefixUnaryExpression(SyntaxNode node);
    [NullableContextAttribute("1")]
public sealed virtual SyntaxNode GetNextExecutableStatement(SyntaxNode statement);
    public virtual bool IsSingleLineCommentTrivia(SyntaxTrivia trivia);
    public virtual bool IsMultiLineCommentTrivia(SyntaxTrivia trivia);
    public virtual bool IsSingleLineDocCommentTrivia(SyntaxTrivia trivia);
    public virtual bool IsMultiLineDocCommentTrivia(SyntaxTrivia trivia);
    public virtual bool IsShebangDirectiveTrivia(SyntaxTrivia trivia);
    public virtual bool IsPreprocessorDirective(SyntaxTrivia trivia);
    [NullableContextAttribute("1")]
public sealed virtual bool IsOnTypeHeader(SyntaxNode root, int position, bool fullHeader, SyntaxNode& typeDeclaration);
    [NullableContextAttribute("1")]
public sealed virtual bool IsOnPropertyDeclarationHeader(SyntaxNode root, int position, SyntaxNode& propertyDeclaration);
    [NullableContextAttribute("1")]
public sealed virtual bool IsOnParameterHeader(SyntaxNode root, int position, SyntaxNode& parameter);
    [NullableContextAttribute("1")]
public sealed virtual bool IsOnMethodHeader(SyntaxNode root, int position, SyntaxNode& method);
    [NullableContextAttribute("1")]
public sealed virtual bool IsOnLocalFunctionHeader(SyntaxNode root, int position, SyntaxNode& localFunction);
    [NullableContextAttribute("1")]
public sealed virtual bool IsOnLocalDeclarationHeader(SyntaxNode root, int position, SyntaxNode& localDeclaration);
    [NullableContextAttribute("1")]
public sealed virtual bool IsOnIfStatementHeader(SyntaxNode root, int position, SyntaxNode& ifStatement);
    [NullableContextAttribute("1")]
public sealed virtual bool IsOnWhileStatementHeader(SyntaxNode root, int position, SyntaxNode& whileStatement);
    [NullableContextAttribute("1")]
public sealed virtual bool IsOnForeachHeader(SyntaxNode root, int position, SyntaxNode& foreachStatement);
    [NullableContextAttribute("1")]
public sealed virtual bool IsBetweenTypeMembers(SourceText sourceText, SyntaxNode root, int position, SyntaxNode& typeDeclaration);
    protected virtual bool ContainsInterleavedDirective(TextSpan span, SyntaxToken token, CancellationToken cancellationToken);
    public sealed virtual SyntaxTokenList GetModifiers(SyntaxNode node);
    public sealed virtual SyntaxNode WithModifiers(SyntaxNode node, SyntaxTokenList modifiers);
    public sealed virtual bool IsLiteralExpression(SyntaxNode node);
    [NullableContextAttribute("1")]
public sealed virtual SeparatedSyntaxList`1<SyntaxNode> GetVariablesOfLocalDeclarationStatement(SyntaxNode node);
    [NullableContextAttribute("1")]
public sealed virtual SyntaxNode GetInitializerOfVariableDeclarator(SyntaxNode node);
    [NullableContextAttribute("1")]
public sealed virtual SyntaxNode GetTypeOfVariableDeclarator(SyntaxNode node);
    public sealed virtual SyntaxNode GetValueOfEqualsValueClause(SyntaxNode node);
    public sealed virtual bool IsScopeBlock(SyntaxNode node);
    public sealed virtual bool IsExecutableBlock(SyntaxNode node);
    [NullableContextAttribute("1")]
public sealed virtual IReadOnlyList`1<SyntaxNode> GetExecutableBlockStatements(SyntaxNode node);
    [NullableContextAttribute("1")]
public sealed virtual SyntaxNode FindInnermostCommonExecutableBlock(IEnumerable`1<SyntaxNode> nodes);
    public sealed virtual bool IsStatementContainer(SyntaxNode node);
    [NullableContextAttribute("1")]
public sealed virtual IReadOnlyList`1<SyntaxNode> GetStatementContainerStatements(SyntaxNode node);
    public sealed virtual bool IsConversionExpression(SyntaxNode node);
    public sealed virtual bool IsCastExpression(SyntaxNode node);
    [NullableContextAttribute("1")]
public sealed virtual void GetPartsOfCastExpression(SyntaxNode node, SyntaxNode& type, SyntaxNode& expression);
    public sealed virtual Nullable`1<SyntaxToken> GetDeclarationIdentifierIfOverride(SyntaxToken token);
    public virtual SyntaxList`1<SyntaxNode> GetAttributeLists(SyntaxNode node);
    public virtual bool IsParameterNameXmlElementSyntax(SyntaxNode node);
    public virtual SyntaxList`1<SyntaxNode> GetContentFromDocumentationCommentTriviaSyntax(SyntaxTrivia trivia);
    [NullableContextAttribute("1")]
public virtual bool CanHaveAccessibility(SyntaxNode declaration);
    [NullableContextAttribute("1")]
public virtual Accessibility GetAccessibility(SyntaxNode declaration);
    public virtual void GetAccessibilityAndModifiers(SyntaxTokenList modifierList, Accessibility& accessibility, DeclarationModifiers& modifiers, Boolean& isDefault);
    public virtual SyntaxTokenList GetModifierTokens(SyntaxNode declaration);
    [NullableContextAttribute("1")]
public virtual DeclarationKind GetDeclarationKind(SyntaxNode declaration);
    internal static bool ParentIsFieldDeclaration(SyntaxNode node);
    internal static bool ParentIsEventFieldDeclaration(SyntaxNode node);
    internal static bool ParentIsLocalDeclarationStatement(SyntaxNode node);
    public sealed virtual bool IsIsPatternExpression(SyntaxNode node);
    [NullableContextAttribute("1")]
public sealed virtual void GetPartsOfIsPatternExpression(SyntaxNode node, SyntaxNode& left, SyntaxToken& isToken, SyntaxNode& right);
    public sealed virtual bool IsAnyPattern(SyntaxNode node);
    public sealed virtual bool IsConstantPattern(SyntaxNode node);
    public sealed virtual bool IsDeclarationPattern(SyntaxNode node);
    public sealed virtual bool IsRecursivePattern(SyntaxNode node);
    public sealed virtual bool IsVarPattern(SyntaxNode node);
    [NullableContextAttribute("1")]
public sealed virtual SyntaxNode GetExpressionOfConstantPattern(SyntaxNode node);
    [NullableContextAttribute("1")]
public sealed virtual void GetPartsOfDeclarationPattern(SyntaxNode node, SyntaxNode& type, SyntaxNode& designation);
    public sealed virtual void GetPartsOfRecursivePattern(SyntaxNode node, SyntaxNode& type, SyntaxNode& positionalPart, SyntaxNode& propertyPart, SyntaxNode& designation);
    [NullableContextAttribute("1")]
public sealed virtual bool SupportsNotPattern(ParseOptions options);
    public sealed virtual bool IsAndPattern(SyntaxNode node);
    public sealed virtual bool IsBinaryPattern(SyntaxNode node);
    public sealed virtual bool IsNotPattern(SyntaxNode node);
    public sealed virtual bool IsOrPattern(SyntaxNode node);
    public sealed virtual bool IsParenthesizedPattern(SyntaxNode node);
    public sealed virtual bool IsTypePattern(SyntaxNode node);
    public sealed virtual bool IsUnaryPattern(SyntaxNode node);
    [NullableContextAttribute("1")]
public sealed virtual void GetPartsOfParenthesizedPattern(SyntaxNode node, SyntaxToken& openParen, SyntaxNode& pattern, SyntaxToken& closeParen);
    [NullableContextAttribute("1")]
public sealed virtual void GetPartsOfBinaryPattern(SyntaxNode node, SyntaxNode& left, SyntaxToken& operatorToken, SyntaxNode& right);
    [NullableContextAttribute("1")]
public sealed virtual void GetPartsOfUnaryPattern(SyntaxNode node, SyntaxToken& operatorToken, SyntaxNode& pattern);
    [NullableContextAttribute("1")]
public sealed virtual SyntaxNode GetTypeOfTypePattern(SyntaxNode node);
    public sealed virtual bool IsImplicitObjectCreation(SyntaxNode node);
    [NullableContextAttribute("1")]
public sealed virtual SyntaxNode GetExpressionOfThrowExpression(SyntaxNode throwExpression);
    public sealed virtual bool IsThrowStatement(SyntaxNode node);
    public sealed virtual bool IsLocalFunction(SyntaxNode node);
    [NullableContextAttribute("1")]
public sealed virtual void GetPartsOfInterpolationExpression(SyntaxNode node, SyntaxToken& stringStartToken, SyntaxList`1& contents, SyntaxToken& stringEndToken);
    [NullableContextAttribute("1")]
public sealed virtual bool IsVerbatimInterpolatedStringExpression(SyntaxNode node);
    private sealed virtual override bool Microsoft.CodeAnalysis.LanguageServices.ISyntaxFacts.HasIncompleteParentMember(SyntaxNode node);
    private sealed virtual override ImmutableArray`1<SyntaxTrivia> Microsoft.CodeAnalysis.LanguageServices.ISyntaxFacts.GetLeadingBlankLines(SyntaxNode node);
    private sealed virtual override TSyntaxNode Microsoft.CodeAnalysis.LanguageServices.ISyntaxFacts.GetNodeWithoutLeadingBlankLines(TSyntaxNode node);
    private sealed virtual override ImmutableArray`1<SyntaxTrivia> Microsoft.CodeAnalysis.LanguageServices.ISyntaxFacts.GetFileBanner(SyntaxNode root);
    private sealed virtual override ImmutableArray`1<SyntaxTrivia> Microsoft.CodeAnalysis.LanguageServices.ISyntaxFacts.GetFileBanner(SyntaxToken firstToken);
    private sealed virtual override bool Microsoft.CodeAnalysis.LanguageServices.ISyntaxFacts.ContainsInterleavedDirective(SyntaxNode node, CancellationToken cancellationToken);
    private sealed virtual override bool Microsoft.CodeAnalysis.LanguageServices.ISyntaxFacts.ContainsInterleavedDirective(ImmutableArray`1<SyntaxNode> nodes, CancellationToken cancellationToken);
    private sealed virtual override string Microsoft.CodeAnalysis.LanguageServices.ISyntaxFacts.GetBannerText(SyntaxNode documentationCommentTriviaSyntax, int maxBannerLength, CancellationToken cancellationToken);
    private sealed virtual override bool Microsoft.CodeAnalysis.LanguageServices.ISyntaxFacts.SpansPreprocessorDirective(IEnumerable`1<SyntaxNode> nodes);
    [NullableContextAttribute("1")]
[CompilerGeneratedAttribute]
private bool <FindInnermostCommonExecutableBlock>b__238_0(SyntaxNode node);
}
internal class Microsoft.CodeAnalysis.CSharp.LanguageServices.CSharpSyntaxKinds : object {
    [NullableAttribute("1")]
public static CSharpSyntaxKinds Instance;
    public int ConflictMarkerTrivia { get; }
    public int DisabledTextTrivia { get; }
    public int EndOfLineTrivia { get; }
    public int SkippedTokensTrivia { get; }
    public int WhitespaceTrivia { get; }
    public int SingleLineCommentTrivia { get; }
    public Nullable`1<int> MultiLineCommentTrivia { get; }
    public int CloseBraceToken { get; }
    public int ColonToken { get; }
    public int CharacterLiteralToken { get; }
    public int DotToken { get; }
    public int InterpolatedStringTextToken { get; }
    public int QuestionToken { get; }
    public int StringLiteralToken { get; }
    public int IfKeyword { get; }
    public int GenericName { get; }
    public int IdentifierName { get; }
    public int QualifiedName { get; }
    public int TupleType { get; }
    public int AnonymousObjectCreationExpression { get; }
    public int AwaitExpression { get; }
    public int BaseExpression { get; }
    public int CharacterLiteralExpression { get; }
    public int ConditionalAccessExpression { get; }
    public int ConditionalExpression { get; }
    public int DefaultLiteralExpression { get; }
    public int FalseLiteralExpression { get; }
    public int InvocationExpression { get; }
    public int LogicalAndExpression { get; }
    public int LogicalOrExpression { get; }
    public int LogicalNotExpression { get; }
    public int ObjectCreationExpression { get; }
    public int NullLiteralExpression { get; }
    public int ParenthesizedExpression { get; }
    public int QueryExpression { get; }
    public int ReferenceEqualsExpression { get; }
    public int ReferenceNotEqualsExpression { get; }
    public int SimpleMemberAccessExpression { get; }
    public int StringLiteralExpression { get; }
    public int TernaryConditionalExpression { get; }
    public int ThisExpression { get; }
    public int TrueLiteralExpression { get; }
    public int TupleExpression { get; }
    public int EndOfFileToken { get; }
    public int AwaitKeyword { get; }
    public int IdentifierToken { get; }
    public int GlobalKeyword { get; }
    public int IncompleteMember { get; }
    public int HashToken { get; }
    public int ExpressionStatement { get; }
    public int ForEachStatement { get; }
    public int LocalDeclarationStatement { get; }
    public int LockStatement { get; }
    public int ReturnStatement { get; }
    public int UsingStatement { get; }
    public int Attribute { get; }
    public int Parameter { get; }
    public int TypeConstraint { get; }
    public int VariableDeclarator { get; }
    public int ParameterList { get; }
    public int TypeArgumentList { get; }
    public Nullable`1<int> GlobalStatement { get; }
    public int Interpolation { get; }
    public int InterpolatedStringExpression { get; }
    public int InterpolatedStringText { get; }
    private static CSharpSyntaxKinds();
    public sealed virtual TSyntaxKind Convert(int kind);
    public sealed virtual int get_ConflictMarkerTrivia();
    public sealed virtual int get_DisabledTextTrivia();
    public sealed virtual int get_EndOfLineTrivia();
    public sealed virtual int get_SkippedTokensTrivia();
    public sealed virtual int get_WhitespaceTrivia();
    public sealed virtual int get_SingleLineCommentTrivia();
    public sealed virtual Nullable`1<int> get_MultiLineCommentTrivia();
    public sealed virtual int get_CloseBraceToken();
    public sealed virtual int get_ColonToken();
    public sealed virtual int get_CharacterLiteralToken();
    public sealed virtual int get_DotToken();
    public sealed virtual int get_InterpolatedStringTextToken();
    public sealed virtual int get_QuestionToken();
    public sealed virtual int get_StringLiteralToken();
    public sealed virtual int get_IfKeyword();
    public sealed virtual int get_GenericName();
    public sealed virtual int get_IdentifierName();
    public sealed virtual int get_QualifiedName();
    public sealed virtual int get_TupleType();
    public sealed virtual int get_AnonymousObjectCreationExpression();
    public sealed virtual int get_AwaitExpression();
    public sealed virtual int get_BaseExpression();
    public sealed virtual int get_CharacterLiteralExpression();
    public sealed virtual int get_ConditionalAccessExpression();
    public sealed virtual int get_ConditionalExpression();
    public sealed virtual int get_DefaultLiteralExpression();
    public sealed virtual int get_FalseLiteralExpression();
    public sealed virtual int get_InvocationExpression();
    public sealed virtual int get_LogicalAndExpression();
    public sealed virtual int get_LogicalOrExpression();
    public sealed virtual int get_LogicalNotExpression();
    public sealed virtual int get_ObjectCreationExpression();
    public sealed virtual int get_NullLiteralExpression();
    public sealed virtual int get_ParenthesizedExpression();
    public sealed virtual int get_QueryExpression();
    public sealed virtual int get_ReferenceEqualsExpression();
    public sealed virtual int get_ReferenceNotEqualsExpression();
    public sealed virtual int get_SimpleMemberAccessExpression();
    public sealed virtual int get_StringLiteralExpression();
    public sealed virtual int get_TernaryConditionalExpression();
    public sealed virtual int get_ThisExpression();
    public sealed virtual int get_TrueLiteralExpression();
    public sealed virtual int get_TupleExpression();
    public sealed virtual int get_EndOfFileToken();
    public sealed virtual int get_AwaitKeyword();
    public sealed virtual int get_IdentifierToken();
    public sealed virtual int get_GlobalKeyword();
    public sealed virtual int get_IncompleteMember();
    public sealed virtual int get_HashToken();
    public sealed virtual int get_ExpressionStatement();
    public sealed virtual int get_ForEachStatement();
    public sealed virtual int get_LocalDeclarationStatement();
    public sealed virtual int get_LockStatement();
    public sealed virtual int get_ReturnStatement();
    public sealed virtual int get_UsingStatement();
    public sealed virtual int get_Attribute();
    public sealed virtual int get_Parameter();
    public sealed virtual int get_TypeConstraint();
    public sealed virtual int get_VariableDeclarator();
    public sealed virtual int get_ParameterList();
    public sealed virtual int get_TypeArgumentList();
    public sealed virtual Nullable`1<int> get_GlobalStatement();
    public sealed virtual int get_Interpolation();
    public sealed virtual int get_InterpolatedStringExpression();
    public sealed virtual int get_InterpolatedStringText();
}
[ExportLanguageServiceFactoryAttribute("Microsoft.CodeAnalysis.LanguageServices.ISyntaxKindsService", "C#", "Default")]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.CSharp.LanguageServices.CSharpSyntaxKindsServiceFactory : object {
    public sealed virtual ILanguageService CreateLanguageService(HostLanguageServices languageServices);
}
[ExportLanguageServiceAttribute("Microsoft.CodeAnalysis.MoveDeclarationNearReference.IMoveDeclarationNearReferenceService", "C#", "Default")]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.CSharp.MoveDeclarationNearReference.CSharpMoveDeclarationNearReferenceService : AbstractMoveDeclarationNearReferenceService`4<CSharpMoveDeclarationNearReferenceService, StatementSyntax, LocalDeclarationStatementSyntax, VariableDeclaratorSyntax> {
    protected virtual bool IsMeaningfulBlock(SyntaxNode node);
    protected virtual SyntaxNode GetVariableDeclaratorSymbolNode(VariableDeclaratorSyntax variableDeclarator);
    protected virtual bool IsValidVariableDeclarator(VariableDeclaratorSyntax variableDeclarator);
    protected virtual SyntaxToken GetIdentifierOfVariableDeclarator(VariableDeclaratorSyntax variableDeclarator);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.CSharp.MoveDeclarationNearReference.CSharpMoveDeclarationNearReferenceService/<TypesAreCompatibleAsync>d__5")]
protected virtual Task`1<bool> TypesAreCompatibleAsync(Document document, ILocalSymbol localSymbol, LocalDeclarationStatementSyntax declarationStatement, SyntaxNode right, CancellationToken cancellationToken);
    protected virtual bool CanMoveToBlock(ILocalSymbol localSymbol, SyntaxNode currentBlock, SyntaxNode destinationBlock);
}
[ExportLanguageServiceAttribute("Microsoft.CodeAnalysis.OrganizeImports.IOrganizeImportsService", "C#", "Default")]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.CSharp.OrganizeImports.CSharpOrganizeImportsService : object {
    public string SortImportsDisplayStringWithAccelerator { get; }
    public string SortAndRemoveUnusedImportsDisplayStringWithAccelerator { get; }
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.CSharp.OrganizeImports.CSharpOrganizeImportsService/<OrganizeImportsAsync>d__1")]
public sealed virtual Task`1<Document> OrganizeImportsAsync(Document document, CancellationToken cancellationToken);
    public sealed virtual string get_SortImportsDisplayStringWithAccelerator();
    public sealed virtual string get_SortAndRemoveUnusedImportsDisplayStringWithAccelerator();
}
internal abstract class Microsoft.CodeAnalysis.CSharp.Precedence.AbstractCSharpPrecedenceService`1 : AbstractPrecedenceService`2<TSyntax, OperatorPrecedence> {
    public sealed virtual PrecedenceKind GetPrecedenceKind(OperatorPrecedence precedence);
}
internal class Microsoft.CodeAnalysis.CSharp.Precedence.CSharpExpressionPrecedenceService : AbstractCSharpPrecedenceService`1<ExpressionSyntax> {
    public static CSharpExpressionPrecedenceService Instance;
    private static CSharpExpressionPrecedenceService();
    public virtual OperatorPrecedence GetOperatorPrecedence(ExpressionSyntax expression);
}
internal class Microsoft.CodeAnalysis.CSharp.Precedence.CSharpPatternPrecedenceService : AbstractCSharpPrecedenceService`1<PatternSyntax> {
    public static CSharpPatternPrecedenceService Instance;
    private static CSharpPatternPrecedenceService();
    public virtual OperatorPrecedence GetOperatorPrecedence(PatternSyntax pattern);
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[ExportLanguageServiceAttribute("Microsoft.CodeAnalysis.Recommendations.IRecommendationService", "C#", "Default")]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.CSharp.Recommendations.CSharpRecommendationService : AbstractRecommendationService`1<CSharpSyntaxContext> {
    protected virtual CSharpSyntaxContext CreateContext(Workspace workspace, SemanticModel semanticModel, int position, CancellationToken cancellationToken);
    protected virtual AbstractRecommendationServiceRunner`1<CSharpSyntaxContext> CreateRunner(CSharpSyntaxContext context, bool filterOutOfScopeLocals, CancellationToken cancellationToken);
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal class Microsoft.CodeAnalysis.CSharp.Recommendations.CSharpRecommendationServiceRunner : AbstractRecommendationServiceRunner`1<CSharpSyntaxContext> {
    [NullableAttribute("0")]
private static ImmutableArray`1<SpecialType> s_predefinedEnumConversionTargets;
    [NullableAttribute("0")]
private static ImmutableArray`1<SpecialType> s_sbyteConversions;
    [NullableAttribute("0")]
private static ImmutableArray`1<SpecialType> s_byteConversions;
    [NullableAttribute("0")]
private static ImmutableArray`1<SpecialType> s_int16Conversions;
    [NullableAttribute("0")]
private static ImmutableArray`1<SpecialType> s_uint16Conversions;
    [NullableAttribute("0")]
private static ImmutableArray`1<SpecialType> s_int32Conversions;
    [NullableAttribute("0")]
private static ImmutableArray`1<SpecialType> s_uint32Conversions;
    [NullableAttribute("0")]
private static ImmutableArray`1<SpecialType> s_int64Conversions;
    [NullableAttribute("0")]
private static ImmutableArray`1<SpecialType> s_uint64Conversions;
    [NullableAttribute("0")]
private static ImmutableArray`1<SpecialType> s_charConversions;
    [NullableAttribute("0")]
private static ImmutableArray`1<SpecialType> s_singleConversions;
    [NullableAttribute("0")]
private static ImmutableArray`1<SpecialType> s_doubleConversions;
    public CSharpRecommendationServiceRunner(CSharpSyntaxContext context, bool filterOutOfScopeLocals, CancellationToken cancellationToken);
    private static CSharpRecommendationServiceRunner();
    public virtual RecommendedSymbols GetRecommendedSymbols();
    public virtual bool TryGetExplicitTypeOfLambdaParameter(SyntaxNode lambdaSyntax, int ordinalInLambda, ITypeSymbol& explicitLambdaParameterType);
    private ImmutableArray`1<ISymbol> GetSymbolsForCurrentContext();
    private RecommendedSymbols GetSymbolsOffOfContainer();
    private ImmutableArray`1<ISymbol> GetSymbolsForGlobalStatementContext();
    private ImmutableArray`1<ISymbol> GetSymbolsForTypeArgumentOfConstraintClause();
    private RecommendedSymbols GetSymbolsOffOffAlias(IdentifierNameSyntax alias);
    private ImmutableArray`1<ISymbol> GetSymbolsForLabelContext();
    private ImmutableArray`1<ISymbol> GetSymbolsForTypeOrNamespaceContext();
    private ImmutableArray`1<ISymbol> GetSymbolsForExpressionOrStatementContext();
    private RecommendedSymbols GetSymbolsOffOfName(NameSyntax name);
    private bool ShouldBeTreatedAsTypeInsteadOfExpression(ExpressionSyntax name, SymbolInfo& leftHandBinding, ITypeSymbol& container);
    [NullableContextAttribute("2")]
private RecommendedSymbols GetSymbolsOffOfExpression(ExpressionSyntax originalExpression);
    private RecommendedSymbols GetSymbolsOffOfDereferencedExpression(ExpressionSyntax originalExpression);
    private RecommendedSymbols GetSymbolsOffOfConditionalReceiver(ExpressionSyntax originalExpression);
    private RecommendedSymbols GetSymbolsOffOfBoundExpression(ExpressionSyntax originalExpression, ExpressionSyntax expression, SymbolInfo leftHandBinding, ITypeSymbol containerType);
    private ImmutableArray`1<ISymbol> GetUnnamedSymbols(ExpressionSyntax originalExpression);
    private ITypeSymbol GetContainerForUnnamedSymbols(SemanticModel semanticModel, ExpressionSyntax originalExpression);
    private void AddIndexers(ITypeSymbol container, ArrayBuilder`1<ISymbol> symbols);
    private void AddConversions(ITypeSymbol container, ArrayBuilder`1<ISymbol> symbols);
    private static ITypeSymbol TryMakeNullable(Compilation compilation, ITypeSymbol container);
    private void AddUserDefinedConversionsOfType(ITypeSymbol container, INamedTypeSymbol containerWithoutNullable, ArrayBuilder`1<ISymbol> symbols);
    private IMethodSymbol LiftConversion(Compilation compilation, IMethodSymbol method);
    private void AddBuiltInNumericConversions(ITypeSymbol container, INamedTypeSymbol containerWithoutNullable, ArrayBuilder`1<ISymbol> symbols);
    [NullableContextAttribute("0")]
public static Nullable`1<ImmutableArray`1<SpecialType>> GetPredefinedNumericConversions(ITypeSymbol container);
    private void AddCompletionItemsForSpecialTypes(ITypeSymbol container, INamedTypeSymbol containerWithoutNullable, ArrayBuilder`1<ISymbol> symbols, ImmutableArray`1<SpecialType> specialTypes);
    private static IMethodSymbol CreateConversion(INamedTypeSymbol containingType, ITypeSymbol fromType, ITypeSymbol toType, string documentationCommentXml);
    private void AddBuiltInEnumConversions(ITypeSymbol container, INamedTypeSymbol containerWithoutNullable, ArrayBuilder`1<ISymbol> symbols);
    private static void AddOperators(ITypeSymbol container, ArrayBuilder`1<ISymbol> symbols);
    private static bool ExcludeOperatorType(ITypeSymbol container);
    private static bool IsLiftableOperator(IMethodSymbol symbol);
    [NullableContextAttribute("0")]
[CompilerGeneratedAttribute]
private ISymbol <GetSymbolsForTypeArgumentOfConstraintClause>b__6_0(SyntaxNode n);
    [NullableContextAttribute("0")]
[CompilerGeneratedAttribute]
private bool <GetSymbolsForLabelContext>b__8_0(ISymbol label);
    [CompilerGeneratedAttribute]
internal static bool <AddUserDefinedConversionsOfType>g__IsLiftableConversion|34_0(IMethodSymbol method);
    [CompilerGeneratedAttribute]
internal static string <AddCompletionItemsForSpecialTypes>g__CreateConversionDocumentationCommentXml|38_0(ITypeSymbol fromType, ITypeSymbol toType);
    [CompilerGeneratedAttribute]
internal static string <AddCompletionItemsForSpecialTypes>g__SeeTag|38_1(string id);
}
[ExportLanguageServiceAttribute("Microsoft.CodeAnalysis.RemoveUnnecessaryImports.IRemoveUnnecessaryImportsService", "C#", "Default")]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.CSharp.RemoveUnnecessaryImports.CSharpRemoveUnnecessaryImportsService : AbstractRemoveUnnecessaryImportsService`1<UsingDirectiveSyntax> {
    protected IUnnecessaryImportsProvider UnnecessaryImportsProvider { get; }
    protected virtual IUnnecessaryImportsProvider get_UnnecessaryImportsProvider();
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.CSharp.RemoveUnnecessaryImports.CSharpRemoveUnnecessaryImportsService/<RemoveUnnecessaryImportsAsync>d__3")]
public virtual Task`1<Document> RemoveUnnecessaryImportsAsync(Document document, Func`2<SyntaxNode, bool> predicate, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.CSharp.RemoveUnnecessaryImports.CSharpRemoveUnnecessaryImportsService/<FormatResultAsync>d__4")]
private Task`1<SyntaxNode> FormatResultAsync(Document document, CompilationUnitSyntax newRoot, CancellationToken cancellationToken);
    private void AddFormattingSpans(CompilationUnitSyntax compilationUnit, List`1<TextSpan> spans, CancellationToken cancellationToken);
    private void AddFormattingSpans(NamespaceDeclarationSyntax namespaceMember, List`1<TextSpan> spans, CancellationToken cancellationToken);
    private static int GetEndPosition(SyntaxNode container, SyntaxList`1<MemberDeclarationSyntax> list);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExportLanguageServiceAttribute("Microsoft.CodeAnalysis.Rename.IRenameRewriterLanguageService", "C#", "Default")]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.CSharp.Rename.CSharpRenameConflictLanguageService : AbstractRenameRewriterLanguageService {
    public virtual SyntaxNode AnnotateAndRename(RenameRewriterParameters parameters);
    public virtual bool LocalVariableConflict(SyntaxToken token, IEnumerable`1<ISymbol> newReferencedSymbols);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.CSharp.Rename.CSharpRenameConflictLanguageService/<ComputeDeclarationConflictsAsync>d__4")]
public virtual Task`1<ImmutableArray`1<Location>> ComputeDeclarationConflictsAsync(string replacementText, ISymbol renamedSymbol, ISymbol renameSymbol, IEnumerable`1<ISymbol> referencedSymbols, Solution baseSolution, Solution newSolution, IDictionary`2<Location, Location> reverseMappedLocations, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.CSharp.Rename.CSharpRenameConflictLanguageService/<GetVBPropertyFromAccessorOrAnOverrideAsync>d__5")]
private static Task`1<ISymbol> GetVBPropertyFromAccessorOrAnOverrideAsync(ISymbol symbol, Solution solution, CancellationToken cancellationToken);
    private static void AddSymbolSourceSpans(ArrayBuilder`1<Location> conflicts, IEnumerable`1<ISymbol> symbols, IDictionary`2<Location, Location> reverseMappedLocations);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.CSharp.Rename.CSharpRenameConflictLanguageService/<ComputeImplicitReferenceConflictsAsync>d__7")]
public virtual Task`1<ImmutableArray`1<Location>> ComputeImplicitReferenceConflictsAsync(ISymbol renameSymbol, ISymbol renamedSymbol, IEnumerable`1<ReferenceLocation> implicitReferenceLocations, CancellationToken cancellationToken);
    public virtual ImmutableArray`1<Location> ComputePossibleImplicitUsageConflicts(ISymbol renamedSymbol, SemanticModel semanticModel, Location originalDeclarationLocation, int newDeclarationLocationStartingPosition, CancellationToken cancellationToken);
    public virtual void TryAddPossibleNameConflicts(ISymbol symbol, string replacementText, ICollection`1<string> possibleNameConflicts);
    [NullableContextAttribute("2")]
public virtual SyntaxNode GetExpansionTargetForLocation(SyntaxToken token);
    [NullableContextAttribute("2")]
private static SyntaxNode GetExpansionTarget(SyntaxToken token);
    public virtual bool IsIdentifierValid(string replacementText, ISyntaxFactsService syntaxFactsService);
    public static SemanticModel GetSemanticModelForNode(SyntaxNode node, SemanticModel originalSemanticModel);
}
internal class Microsoft.CodeAnalysis.CSharp.Rename.LabelConflictVisitor : CSharpSyntaxVisitor {
    private ConflictingIdentifierTracker _tracker;
    public IEnumerable`1<SyntaxToken> ConflictingTokens { get; }
    public LabelConflictVisitor(SyntaxToken tokenBeingRenamed);
    public virtual void DefaultVisit(SyntaxNode node);
    public virtual void VisitBlock(BlockSyntax node);
    public IEnumerable`1<SyntaxToken> get_ConflictingTokens();
}
internal class Microsoft.CodeAnalysis.CSharp.Rename.LocalConflictVisitor : CSharpSyntaxVisitor {
    private ConflictingIdentifierTracker _tracker;
    public IEnumerable`1<SyntaxToken> ConflictingTokens { get; }
    public LocalConflictVisitor(SyntaxToken tokenBeingRenamed);
    public virtual void DefaultVisit(SyntaxNode node);
    public virtual void VisitMethodDeclaration(MethodDeclarationSyntax node);
    public virtual void VisitBlock(BlockSyntax node);
    private void VisitBlockStatements(SyntaxNode node, IEnumerable`1<SyntaxNode> statements);
    public virtual void VisitForEachStatement(ForEachStatementSyntax node);
    public virtual void VisitForStatement(ForStatementSyntax node);
    public virtual void VisitUsingStatement(UsingStatementSyntax node);
    public virtual void VisitCatchClause(CatchClauseSyntax node);
    public virtual void VisitSimpleLambdaExpression(SimpleLambdaExpressionSyntax node);
    public virtual void VisitParenthesizedLambdaExpression(ParenthesizedLambdaExpressionSyntax node);
    public virtual void VisitQueryExpression(QueryExpressionSyntax node);
    private void VisitQueryInternal(FromClauseSyntax fromClause, QueryBodySyntax body);
    public virtual void VisitQueryContinuation(QueryContinuationSyntax node);
    public virtual void VisitSwitchStatement(SwitchStatementSyntax node);
    public IEnumerable`1<SyntaxToken> get_ConflictingTokens();
}
[ExportLanguageServiceAttribute("Microsoft.CodeAnalysis.ReplaceDiscardDeclarationsWithAssignments.IReplaceDiscardDeclarationsWithAssignmentsService", "C#", "Default")]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.CSharp.ReplaceDiscardDeclarationsWithAssignments.CSharpReplaceDiscardDeclarationsWithAssignmentsService : object {
    private static string DiscardVariableName;
    public sealed virtual Task`1<SyntaxNode> ReplaceAsync(SyntaxNode memberDeclaration, SemanticModel semanticModel, Workspace workspace, CancellationToken cancellationToken);
    private static bool IsDiscardDeclaration(VariableDeclaratorSyntax variable);
    private static bool IsDiscardDeclaration(CatchDeclarationSyntax catchDeclaration);
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[ExportLanguageServiceAttribute("Microsoft.CodeAnalysis.SemanticModelReuse.ISemanticModelReuseLanguageService", "C#", "Default")]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.CSharp.SemanticModelReuse.CSharpSemanticModelReuseLanguageService : AbstractSemanticModelReuseLanguageService`4<MemberDeclarationSyntax, BaseMethodDeclarationSyntax, BasePropertyDeclarationSyntax, AccessorDeclarationSyntax> {
    protected ISyntaxFacts SyntaxFacts { get; }
    protected virtual ISyntaxFacts get_SyntaxFacts();
    protected virtual BasePropertyDeclarationSyntax GetBasePropertyDeclaration(AccessorDeclarationSyntax accessor);
    protected virtual SyntaxList`1<AccessorDeclarationSyntax> GetAccessors(BasePropertyDeclarationSyntax baseProperty);
    public virtual SyntaxNode TryGetContainingMethodBodyForSpeculation(SyntaxNode node);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.CSharp.SemanticModelReuse.CSharpSemanticModelReuseLanguageService/<TryGetSpeculativeSemanticModelWorkerAsync>d__6")]
protected virtual Task`1<SemanticModel> TryGetSpeculativeSemanticModelWorkerAsync(SemanticModel previousSemanticModel, SyntaxNode currentBodyNode, CancellationToken cancellationToken);
}
[ExportLanguageServiceAttribute("Microsoft.CodeAnalysis.Serialization.IOptionsSerializationService", "C#", "Default")]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.CSharp.Serialization.CSharpOptionsSerializationService : AbstractOptionsSerializationService {
    public virtual void WriteTo(CompilationOptions options, ObjectWriter writer, CancellationToken cancellationToken);
    public virtual void WriteTo(ParseOptions options, ObjectWriter writer);
    public virtual CompilationOptions ReadCompilationOptionsFrom(ObjectReader reader, CancellationToken cancellationToken);
    public virtual ParseOptions ReadParseOptionsFrom(ObjectReader reader, CancellationToken cancellationToken);
}
[ExtensionAttribute]
internal static class Microsoft.CodeAnalysis.CSharp.Shared.Extensions.LanguageVersionExtensions : object {
    [ExtensionAttribute]
public static bool IsCSharp9OrAbove(LanguageVersion languageVersion);
    [ExtensionAttribute]
public static bool IsCSharp10OrAbove(LanguageVersion languageVersion);
    [ExtensionAttribute]
public static bool HasConstantInterpolatedStrings(LanguageVersion languageVersion);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
internal static class Microsoft.CodeAnalysis.CSharp.Shared.Lightup.NullableSyntaxAnnotationEx : object {
    [CompilerGeneratedAttribute]
private static SyntaxAnnotation <Oblivious>k__BackingField;
    [CompilerGeneratedAttribute]
private static SyntaxAnnotation <AnnotatedOrNotAnnotated>k__BackingField;
    public static SyntaxAnnotation Oblivious { get; }
    public static SyntaxAnnotation AnnotatedOrNotAnnotated { get; }
    private static NullableSyntaxAnnotationEx();
    [CompilerGeneratedAttribute]
public static SyntaxAnnotation get_Oblivious();
    [CompilerGeneratedAttribute]
public static SyntaxAnnotation get_AnnotatedOrNotAnnotated();
}
internal abstract class Microsoft.CodeAnalysis.CSharp.Simplification.AbstractCSharpReducer : AbstractReducer {
    protected AbstractCSharpReducer(ObjectPool`1<IReductionRewriter> pool);
}
internal class Microsoft.CodeAnalysis.CSharp.Simplification.CSharpCastReducer : AbstractCSharpReducer {
    private static ObjectPool`1<IReductionRewriter> s_pool;
    private static Func`5<CastExpressionSyntax, SemanticModel, OptionSet, CancellationToken, ExpressionSyntax> s_simplifyCast;
    private static CSharpCastReducer();
    private static ExpressionSyntax SimplifyCast(CastExpressionSyntax node, SemanticModel semanticModel, OptionSet optionSet, CancellationToken cancellationToken);
}
internal class Microsoft.CodeAnalysis.CSharp.Simplification.CSharpDefaultExpressionReducer : AbstractCSharpReducer {
    private static ObjectPool`1<IReductionRewriter> s_pool;
    private static CSharpDefaultExpressionReducer();
}
internal class Microsoft.CodeAnalysis.CSharp.Simplification.CSharpEscapingReducer : AbstractCSharpReducer {
    private static ObjectPool`1<IReductionRewriter> s_pool;
    private static Func`5<SyntaxToken, SemanticModel, OptionSet, CancellationToken, SyntaxToken> s_simplifyIdentifierToken;
    private static CSharpEscapingReducer();
    private static SyntaxToken SimplifyIdentifierToken(SyntaxToken token, SemanticModel semanticModel, OptionSet optionSet, CancellationToken cancellationToken);
    private static SyntaxToken CreateNewIdentifierTokenFromToken(SyntaxToken originalToken, bool escape);
}
internal class Microsoft.CodeAnalysis.CSharp.Simplification.CSharpExtensionMethodReducer : AbstractCSharpReducer {
    private static ObjectPool`1<IReductionRewriter> s_pool;
    private static Func`5<InvocationExpressionSyntax, SemanticModel, OptionSet, CancellationToken, SyntaxNode> s_simplifyExtensionMethod;
    private static CSharpExtensionMethodReducer();
    private static SyntaxNode SimplifyExtensionMethod(InvocationExpressionSyntax node, SemanticModel semanticModel, OptionSet optionSet, CancellationToken cancellationToken);
    private static InvocationExpressionSyntax TryReduceExtensionMethod(InvocationExpressionSyntax node, SemanticModel semanticModel, InvocationExpressionSyntax rewrittenNode, SimpleNameSyntax expressionName);
}
internal class Microsoft.CodeAnalysis.CSharp.Simplification.CSharpInferredMemberNameReducer : AbstractCSharpReducer {
    private static ObjectPool`1<IReductionRewriter> s_pool;
    private static CSharpInferredMemberNameReducer();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal static class Microsoft.CodeAnalysis.CSharp.Simplification.CSharpInferredMemberNameSimplifier : object {
    internal static bool CanSimplifyTupleElementName(ArgumentSyntax node, CSharpParseOptions parseOptions);
    internal static bool CanSimplifyAnonymousTypeMemberName(AnonymousObjectMemberDeclaratorSyntax node);
    private static bool RemovalCausesAmbiguity(SeparatedSyntaxList`1<ArgumentSyntax> arguments, ArgumentSyntax toRemove);
    private static bool RemovalCausesAmbiguity(SeparatedSyntaxList`1<AnonymousObjectMemberDeclaratorSyntax> initializers, AnonymousObjectMemberDeclaratorSyntax toRemove);
}
internal class Microsoft.CodeAnalysis.CSharp.Simplification.CSharpMiscellaneousReducer : AbstractCSharpReducer {
    private static ObjectPool`1<IReductionRewriter> s_pool;
    private static Func`5<ParameterSyntax, SemanticModel, OptionSet, CancellationToken, SyntaxNode> s_simplifyParameter;
    private static Func`5<ParenthesizedLambdaExpressionSyntax, SemanticModel, OptionSet, CancellationToken, SyntaxNode> s_simplifyParenthesizedLambdaExpression;
    private static Func`5<BlockSyntax, SemanticModel, OptionSet, CancellationToken, SyntaxNode> s_simplifyBlock;
    private static CSharpMiscellaneousReducer();
    private static bool CanRemoveTypeFromParameter(ParameterSyntax parameterSyntax, SemanticModel semanticModel, CancellationToken cancellationToken);
    private static SyntaxNode SimplifyParameter(ParameterSyntax node, SemanticModel semanticModel, OptionSet optionSet, CancellationToken cancellationToken);
    private static SyntaxNode SimplifyParenthesizedLambdaExpression(ParenthesizedLambdaExpressionSyntax parenthesizedLambda, SemanticModel semanticModel, OptionSet optionSet, CancellationToken cancellationToken);
    private static SyntaxNode SimplifyBlock(BlockSyntax node, SemanticModel semanticModel, OptionSet optionSet, CancellationToken cancellationToken);
    private static bool CanHaveEmbeddedStatement(SyntaxNode node);
}
internal class Microsoft.CodeAnalysis.CSharp.Simplification.CSharpNameReducer : AbstractCSharpReducer {
    private static ObjectPool`1<IReductionRewriter> s_pool;
    private static Func`5<SyntaxNode, SemanticModel, OptionSet, CancellationToken, SyntaxNode> s_simplifyName;
    private static CSharpNameReducer();
    private static SyntaxNode SimplifyName(SyntaxNode node, SemanticModel semanticModel, OptionSet optionSet, CancellationToken cancellationToken);
}
internal class Microsoft.CodeAnalysis.CSharp.Simplification.CSharpNullableAnnotationReducer : AbstractCSharpReducer {
    private static ObjectPool`1<IReductionRewriter> s_pool;
    private static Func`5<NullableTypeSyntax, SemanticModel, OptionSet, CancellationToken, SyntaxNode> s_simplifyNullableType;
    private static CSharpNullableAnnotationReducer();
    private static SyntaxNode SimplifyNullableType(NullableTypeSyntax node, SemanticModel semanticModel, OptionSet optionSet, CancellationToken cancellationToken);
}
internal class Microsoft.CodeAnalysis.CSharp.Simplification.CSharpParenthesizedExpressionReducer : AbstractCSharpReducer {
    private static ObjectPool`1<IReductionRewriter> s_pool;
    private static Func`5<ParenthesizedExpressionSyntax, SemanticModel, OptionSet, CancellationToken, SyntaxNode> s_simplifyParentheses;
    private static CSharpParenthesizedExpressionReducer();
    private static SyntaxNode SimplifyParentheses(ParenthesizedExpressionSyntax node, SemanticModel semanticModel, OptionSet optionSet, CancellationToken cancellationToken);
}
internal class Microsoft.CodeAnalysis.CSharp.Simplification.CSharpParenthesizedPatternReducer : AbstractCSharpReducer {
    private static ObjectPool`1<IReductionRewriter> s_pool;
    private static Func`5<ParenthesizedPatternSyntax, SemanticModel, OptionSet, CancellationToken, SyntaxNode> s_simplifyParentheses;
    private static CSharpParenthesizedPatternReducer();
    private static SyntaxNode SimplifyParentheses(ParenthesizedPatternSyntax node, SemanticModel semanticModel, OptionSet optionSet, CancellationToken cancellationToken);
}
internal static class Microsoft.CodeAnalysis.CSharp.Simplification.CSharpSimplificationHelpers : object {
    public static SyntaxToken TryEscapeIdentifierToken(SyntaxToken syntaxToken, SyntaxNode parentOfToken);
    public static T AppendElasticTriviaIfNecessary(T rewrittenNode, T originalNode);
    public static bool TryAddLeadingElasticTriviaIfNecessary(SyntaxToken token, SyntaxToken originalToken, SyntaxToken& tokenWithLeadingWhitespace);
}
[ExportLanguageServiceAttribute("Microsoft.CodeAnalysis.Simplification.ISimplificationService", "C#", "Default")]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.CSharp.Simplification.CSharpSimplificationService : AbstractSimplificationService`3<ExpressionSyntax, StatementSyntax, CrefSyntax> {
    private static ImmutableArray`1<AbstractReducer> s_reducers;
    private static string s_CS8019_UnusedUsingDirective;
    private static CSharpSimplificationService();
    public virtual SyntaxNode Expand(SyntaxNode node, SemanticModel semanticModel, SyntaxAnnotation annotationForReplacedAliasIdentifier, Func`2<SyntaxNode, bool> expandInsideNode, bool expandParameter, CancellationToken cancellationToken);
    public virtual SyntaxToken Expand(SyntaxToken token, SemanticModel semanticModel, Func`2<SyntaxNode, bool> expandInsideNode, CancellationToken cancellationToken);
    public static SyntaxToken TryEscapeIdentifierToken(SyntaxToken syntaxToken, SyntaxNode parentOfToken);
    public static T AppendElasticTriviaIfNecessary(T rewrittenNode, T originalNode);
    private static bool TryAddLeadingElasticTriviaIfNecessary(SyntaxToken token, SyntaxToken originalToken, SyntaxToken& tokenWithLeadingWhitespace);
    protected virtual SemanticModel GetSpeculativeSemanticModel(SyntaxNode& nodeToSpeculate, SemanticModel originalSemanticModel, SyntaxNode originalNode);
    protected virtual ImmutableArray`1<NodeOrTokenToReduce> GetNodesAndTokensToReduce(SyntaxNode root, Func`2<SyntaxNodeOrToken, bool> isNodeOrTokenOutsideSimplifySpans);
    protected virtual bool CanNodeBeSimplifiedWithoutSpeculation(SyntaxNode node);
    protected virtual void GetUnusedNamespaceImports(SemanticModel model, HashSet`1<SyntaxNode> namespaceImports, CancellationToken cancellationToken);
    private static bool IsTupleInDeconstruction(SyntaxNode tuple);
}
internal class Microsoft.CodeAnalysis.CSharp.Simplification.CSharpVarReducer : AbstractCSharpReducer {
    private static ObjectPool`1<IReductionRewriter> s_pool;
    private static CSharpVarReducer();
    public virtual bool IsApplicable(OptionSet optionSet);
}
internal abstract class Microsoft.CodeAnalysis.CSharp.Simplification.Simplifiers.AbstractCSharpSimplifier`2 : AbstractSimplifier`2<TSyntax, TSimplifiedSyntax> {
    protected static SyntaxKind GetPredefinedKeywordKind(SpecialType specialType);
    protected static bool TryReplaceExpressionWithAlias(ExpressionSyntax node, SemanticModel semanticModel, ISymbol symbol, CancellationToken cancellationToken, IAliasSymbol& aliasReplacement);
    private static bool IsAliasReplaceableExpression(ExpressionSyntax expression);
    private static bool HasUsingAliasDirective(SyntaxNode syntax);
    private static bool ValidateAliasForTarget(IAliasSymbol aliasReplacement, SemanticModel semanticModel, ExpressionSyntax node, ISymbol symbol);
    private static IAliasSymbol GetAliasForSymbol(INamespaceOrTypeSymbol symbol, SyntaxToken token, SemanticModel semanticModel, CancellationToken cancellationToken);
    private static int GetNamespaceIdForAliasSearch(SemanticModel semanticModel, SyntaxToken token, CancellationToken cancellationToken);
    private static SyntaxNode GetStartNodeForNamespaceId(SemanticModel semanticModel, SyntaxToken token, CancellationToken cancellationToken);
    private static int GetNamespaceId(SyntaxNode container, NamespaceDeclarationSyntax target, Int32& index);
    private static int GetNamespaceId(SyntaxList`1<MemberDeclarationSyntax> members, NamespaceDeclarationSyntax target, Int32& index);
    protected static TypeSyntax CreatePredefinedTypeSyntax(ExpressionSyntax expression, SyntaxKind keywordKind);
    protected static bool InsideNameOfExpression(ExpressionSyntax expression, SemanticModel semanticModel);
    protected static bool PreferPredefinedTypeKeywordInMemberAccess(ExpressionSyntax expression, OptionSet optionSet, SemanticModel semanticModel);
    protected static bool WillConflictWithExistingLocal(ExpressionSyntax expression, ExpressionSyntax simplifiedNode, SemanticModel semanticModel);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal static class Microsoft.CodeAnalysis.CSharp.Simplification.Simplifiers.CastSimplifier : object {
    public static bool IsUnnecessaryCast(ExpressionSyntax cast, SemanticModel semanticModel, CancellationToken cancellationToken);
    public static bool IsUnnecessaryCast(CastExpressionSyntax cast, SemanticModel semanticModel, CancellationToken cancellationToken);
    public static bool IsUnnecessaryAsCast(BinaryExpressionSyntax cast, SemanticModel semanticModel, CancellationToken cancellationToken);
    private static bool IsCastSafeToRemove(ExpressionSyntax castNode, ExpressionSyntax castedExpressionNode, SemanticModel semanticModel, CancellationToken cancellationToken);
    private static bool CastHasRuntimeImpact(SpeculationAnalyzer speculationAnalyzer, ExpressionSyntax castNode, ExpressionSyntax castedExpressionNode, SemanticModel semanticModel, CancellationToken cancellationToken);
    private static bool CastDefinitelyHasNoRuntimeImpact(ExpressionSyntax castNode, ExpressionSyntax castedExpressionNode, SemanticModel semanticModel, CancellationToken cancellationToken);
    private static bool CastHasNoRuntimeImpact_Legacy(SpeculationAnalyzer speculationAnalyzer, ExpressionSyntax castNode, ExpressionSyntax castedExpressionNode, SemanticModel semanticModel, CancellationToken cancellationToken);
    private static bool IsObjectCastInInterpolation(ExpressionSyntax castNode, ITypeSymbol castType);
    private static bool IsEnumToNumericCastThatCanDefinitelyBeRemoved(ExpressionSyntax castNode, ITypeSymbol castType, ITypeSymbol castedExpressionType, SemanticModel semanticModel, CancellationToken cancellationToken);
    private static bool CastMustBePreserved(ExpressionSyntax castNode, ExpressionSyntax castedExpressionNode, SemanticModel semanticModel, CancellationToken cancellationToken);
    private static bool IsBitwiseNotOfExtendedUnsignedValue(ExpressionSyntax castNode, Conversion conversion, ITypeSymbol castType, ITypeSymbol castedExressionType);
    private static bool IsUnsigned(ITypeSymbol type);
    private static bool IsNuint(ITypeSymbol type);
    private static bool IsIntPtrToNativeIntegerNestedCast(ExpressionSyntax castNode, ITypeSymbol castType, ITypeSymbol castedExpressionType, SemanticModel semanticModel, CancellationToken cancellationToken);
    private static bool IsTypeLessExpressionNotInTargetTypedLocation(ExpressionSyntax castNode, ITypeSymbol castedExpressionType);
    private static bool IsInTargetTypingLocation(ExpressionSyntax node);
    private static bool IsExplicitCastThatMustBePreserved(ExpressionSyntax castNode, Conversion conversion);
    private static bool PointerOrIntPtrCastMustBePreserved(Conversion conversion);
    private static bool InvolvesDynamic(ExpressionSyntax castNode, ITypeSymbol castType, ITypeSymbol castedExpressionType, SemanticModel semanticModel, CancellationToken cancellationToken);
    private static bool IsDereferenceOfNullPointerCast(ExpressionSyntax castNode, ExpressionSyntax castedExpressionNode);
    private static bool IsBranchOfConditionalExpression(ExpressionSyntax expression);
    private static bool CastMustBePreservedInConditionalBranch(ExpressionSyntax castNode, Conversion conversion);
    private static bool CastRemovalWouldCauseSignExtensionWarning(ExpressionSyntax expression, SemanticModel semanticModel, CancellationToken cancellationToken);
    private static Nullable`1<ulong> GetConstantValueForBitwiseOrCheck(IOperation operation);
    [NullableContextAttribute("2")]
private static ulong FindSurprisingSignExtensionBits(IOperation operation, bool treatExplicitCastAsImplicit);
    private static bool IdentityFloatingPointCastMustBePreserved(ExpressionSyntax castNode, ExpressionSyntax castedExpressionNode, ITypeSymbol castType, ITypeSymbol castedExpressionType, SemanticModel semanticModel, Conversion conversion, CancellationToken cancellationToken);
    private static bool IsFieldOrArrayElement(SemanticModel semanticModel, ExpressionSyntax expr, CancellationToken cancellationToken);
    private static bool HaveSameUserDefinedConversion(Conversion conversion1, Conversion conversion2);
    private static bool IsInDelegateCreationExpression(ExpressionSyntax castNode, SemanticModel semanticModel);
    private static bool IsDynamicInvocation(ExpressionSyntax castExpression, SemanticModel semanticModel, CancellationToken cancellationToken);
    private static bool IsDynamicAssignment(ExpressionSyntax castExpression, SemanticModel semanticModel, CancellationToken cancellationToken);
    private static bool IsRequiredImplicitNumericConversion(ITypeSymbol sourceType, ITypeSymbol destinationType);
    private static bool CastIsRequiredToPreventUnintendedComparisonWarning(ExpressionSyntax castNode, ExpressionSyntax castedExpressionNode, ITypeSymbol castType, SemanticModel semanticModel, CancellationToken cancellationToken);
    private static bool CastIsRequiredToPreventUnintendedComparisonWarning(ExpressionSyntax left, ExpressionSyntax right, string operatorName, SemanticModel semanticModel, CancellationToken cancellationToken);
    private static Conversion GetSpeculatedExpressionToOuterTypeConversion(ExpressionSyntax speculatedExpression, SpeculationAnalyzer speculationAnalyzer, CancellationToken cancellationToken);
    private static bool UserDefinedConversionIsAllowed(ExpressionSyntax expression);
    private static bool ParamsArgumentCastMustBePreserved(ExpressionSyntax cast, ITypeSymbol castType, SemanticModel semanticModel, CancellationToken cancellationToken);
    private static bool ParameterTypeMatchesParamsElementType(IParameterSymbol parameter, ITypeSymbol castType, SemanticModel semanticModel);
    private static ITypeSymbol GetOuterCastType(ExpressionSyntax expression, SemanticModel semanticModel, Boolean& parentIsIsOrAsExpression);
}
internal class Microsoft.CodeAnalysis.CSharp.Simplification.Simplifiers.ExpressionSimplifier : AbstractCSharpSimplifier`2<ExpressionSyntax, ExpressionSyntax> {
    public static ExpressionSimplifier Instance;
    private static ExpressionSimplifier();
    public virtual bool TrySimplify(ExpressionSyntax expression, SemanticModel semanticModel, OptionSet optionSet, ExpressionSyntax& replacementNode, TextSpan& issueSpan, CancellationToken cancellationToken);
    private static bool TryReduceExplicitName(ExpressionSyntax expression, SemanticModel semanticModel, TypeSyntax& replacementNode, TextSpan& issueSpan, OptionSet optionSet, CancellationToken cancellationToken);
    private static bool TryReduceMemberAccessExpression(MemberAccessExpressionSyntax memberAccess, SemanticModel semanticModel, TypeSyntax& replacementNode, TextSpan& issueSpan, OptionSet optionSet, CancellationToken cancellationToken);
    private static void GetReplacementCandidates(SemanticModel semanticModel, MemberAccessExpressionSyntax memberAccess, ISymbol actualSymbol, ImmutableArray`1& speculativeSymbols, ImmutableArray`1& speculativeNamespacesAndTypes);
    private static bool IsReplacementCandidate(ISymbol actualSymbol, ImmutableArray`1<ISymbol> speculativeSymbols, ImmutableArray`1<ISymbol> speculativeNamespacesAndTypes);
    private static bool TrySimplify(ExpressionSyntax expression, SemanticModel semanticModel, ExpressionSyntax& replacementNode, TextSpan& issueSpan, CancellationToken cancellationToken);
    private static bool CanReplaceWithReducedName(MemberAccessExpressionSyntax memberAccess, ExpressionSyntax reducedName, SemanticModel semanticModel, ISymbol symbol, CancellationToken cancellationToken);
    private static bool IsNonRemovablePartOfDynamicMethodInvocation(SemanticModel semanticModel, MemberAccessExpressionSyntax memberAccess, CancellationToken cancellationToken);
    private static bool AccessMethodWithDynamicArgumentInsideStructConstructor(MemberAccessExpressionSyntax memberAccess, SemanticModel semanticModel);
    private static bool TrySimplifyMemberAccessOrQualifiedName(ExpressionSyntax left, ExpressionSyntax right, SemanticModel semanticModel, ExpressionSyntax& replacementNode, TextSpan& issueSpan);
    private static bool IsThisOrTypeOrNamespace(MemberAccessExpressionSyntax memberAccess, SemanticModel semanticModel);
    private static bool ParserWouldTreatExpressionAsCast(ExpressionSyntax reducedNode, MemberAccessExpressionSyntax originalNode);
    private static bool IsNameOrMemberAccessButNoExpression(SyntaxNode node);
    protected static bool ReplacementChangesSemantics(ExpressionSyntax originalExpression, ExpressionSyntax replacedExpression, SemanticModel semanticModel);
}
internal class Microsoft.CodeAnalysis.CSharp.Simplification.Simplifiers.NameSimplifier : AbstractCSharpSimplifier`2<NameSyntax, TypeSyntax> {
    public static NameSimplifier Instance;
    private static NameSimplifier();
    public virtual bool TrySimplify(NameSyntax name, SemanticModel semanticModel, OptionSet optionSet, TypeSyntax& replacementNode, TextSpan& issueSpan, CancellationToken cancellationToken);
    private static bool TryReduceCrefColorColor(NameSyntax name, TypeSyntax replacement, SemanticModel semanticModel, CancellationToken cancellationToken);
    private static bool CanSimplifyNullable(INamedTypeSymbol type, NameSyntax name, SemanticModel semanticModel);
    private static bool CanReplaceWithPredefinedTypeKeywordInContext(NameSyntax name, SemanticModel semanticModel, TypeSyntax& replacementNode, TextSpan& issueSpan, SyntaxKind keywordKind, string codeStyleOptionName);
    private static bool TryReduceAttributeSuffix(NameSyntax name, SyntaxToken identifierToken, TypeSyntax& replacementNode, TextSpan& issueSpan);
    private static bool IsPartOfNamespaceDeclarationName(SyntaxNode node);
    public static bool CanReplaceWithReducedNameInContext(NameSyntax name, TypeSyntax reducedName, SemanticModel semanticModel);
    private static bool ContainsOpenName(NameSyntax name);
    private static bool CanReplaceWithReducedName(NameSyntax name, TypeSyntax reducedName, SemanticModel semanticModel, CancellationToken cancellationToken);
    private static bool IsNotNullableReplaceable(NameSyntax name, TypeSyntax reducedName);
    private static bool IsNullableTypeInPointerExpression(ExpressionSyntax simplifiedNode);
    private static bool IsNonNameSyntaxInUsingDirective(ExpressionSyntax expression, ExpressionSyntax simplifiedNode);
    private static bool IsAmbiguousCast(ExpressionSyntax expression, ExpressionSyntax simplifiedNode);
    private static bool IsNonReducableQualifiedNameInUsingDirective(SemanticModel model, NameSyntax name);
    private static bool IsQualifiedNameInUsingDirective(SemanticModel model, NameSyntax name);
    private static bool IsGlobalAliasQualifiedName(NameSyntax name);
    private static bool IsInScriptClass(SemanticModel model, NameSyntax name);
    private static bool PreferPredefinedTypeKeywordInDeclarations(NameSyntax name, OptionSet optionSet, SemanticModel semanticModel);
}
internal class Microsoft.CodeAnalysis.CSharp.Simplification.Simplifiers.QualifiedCrefSimplifier : AbstractCSharpSimplifier`2<QualifiedCrefSyntax, CrefSyntax> {
    public static QualifiedCrefSimplifier Instance;
    private static QualifiedCrefSimplifier();
    public virtual bool TrySimplify(QualifiedCrefSyntax crefSyntax, SemanticModel semanticModel, OptionSet optionSet, CrefSyntax& replacementNode, TextSpan& issueSpan, CancellationToken cancellationToken);
    private static TypeCrefSyntax CreateReplacement(QualifiedCrefSyntax crefSyntax, SyntaxKind keywordKind);
    public static bool CanSimplifyWithReplacement(QualifiedCrefSyntax crefSyntax, SemanticModel semanticModel, CrefSyntax replacement, CancellationToken cancellationToken);
    private static bool CanSimplifyWithReplacement(QualifiedCrefSyntax crefSyntax, SemanticModel semanticModel, CrefSyntax replacement, CrefSyntax& replacementNode, TextSpan& issueSpan, CancellationToken cancellationToken);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal abstract class Microsoft.CodeAnalysis.CSharp.Utilities.CSharpTypeStyleHelper : object {
    protected abstract virtual bool IsStylePreferred(State& modreq(System.Runtime.InteropServices.InAttribute) state);
    public virtual TypeStyleResult AnalyzeTypeName(TypeSyntax typeName, SemanticModel semanticModel, OptionSet optionSet, CancellationToken cancellationToken);
    internal abstract virtual bool TryAnalyzeVariableDeclaration(TypeSyntax typeName, SemanticModel semanticModel, OptionSet optionSet, CancellationToken cancellationToken);
    protected abstract virtual bool AssignmentSupportsStylePreference(SyntaxToken identifier, TypeSyntax typeName, ExpressionSyntax initializer, SemanticModel semanticModel, OptionSet optionSet, CancellationToken cancellationToken);
    internal TypeSyntax FindAnalyzableType(SyntaxNode node, SemanticModel semanticModel, CancellationToken cancellationToken);
    public virtual bool ShouldAnalyzeVariableDeclaration(VariableDeclarationSyntax variableDeclaration, CancellationToken cancellationToken);
    protected virtual bool ShouldAnalyzeForEachStatement(ForEachStatementSyntax forEachStatement, SemanticModel semanticModel, CancellationToken cancellationToken);
    protected virtual bool ShouldAnalyzeDeclarationExpression(DeclarationExpressionSyntax declaration, SemanticModel semanticModel, CancellationToken cancellationToken);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.CodeAnalysis.CSharp.Utilities.CSharpUseExplicitTypeHelper : CSharpTypeStyleHelper {
    public static CSharpUseExplicitTypeHelper Instance;
    private static CSharpUseExplicitTypeHelper();
    protected virtual bool IsStylePreferred(State& modreq(System.Runtime.InteropServices.InAttribute) state);
    public virtual bool ShouldAnalyzeVariableDeclaration(VariableDeclarationSyntax variableDeclaration, CancellationToken cancellationToken);
    protected virtual bool ShouldAnalyzeForEachStatement(ForEachStatementSyntax forEachStatement, SemanticModel semanticModel, CancellationToken cancellationToken);
    internal virtual bool TryAnalyzeVariableDeclaration(TypeSyntax typeName, SemanticModel semanticModel, OptionSet optionSet, CancellationToken cancellationToken);
    protected virtual bool ShouldAnalyzeDeclarationExpression(DeclarationExpressionSyntax declaration, SemanticModel semanticModel, CancellationToken cancellationToken);
    protected virtual bool AssignmentSupportsStylePreference(SyntaxToken identifier, TypeSyntax typeName, ExpressionSyntax initializer, SemanticModel semanticModel, OptionSet optionSet, CancellationToken cancellationToken);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.CodeAnalysis.CSharp.Utilities.CSharpUseImplicitTypeHelper : CSharpTypeStyleHelper {
    public static CSharpUseImplicitTypeHelper Instance;
    private static CSharpUseImplicitTypeHelper();
    public virtual TypeStyleResult AnalyzeTypeName(TypeSyntax typeName, SemanticModel semanticModel, OptionSet optionSet, CancellationToken cancellationToken);
    public virtual bool ShouldAnalyzeVariableDeclaration(VariableDeclarationSyntax variableDeclaration, CancellationToken cancellationToken);
    protected virtual bool ShouldAnalyzeForEachStatement(ForEachStatementSyntax forEachStatement, SemanticModel semanticModel, CancellationToken cancellationToken);
    protected virtual bool IsStylePreferred(State& modreq(System.Runtime.InteropServices.InAttribute) state);
    internal virtual bool TryAnalyzeVariableDeclaration(TypeSyntax typeName, SemanticModel semanticModel, OptionSet optionSet, CancellationToken cancellationToken);
    private static bool TryAnalyzeDeclarationExpression(DeclarationExpressionSyntax declarationExpression, SemanticModel semanticModel, CancellationToken cancellationToken);
    private static bool IsSafeToSwitchToVarWithoutNeedingSpeculation(DeclarationExpressionSyntax declarationExpression, SemanticModel semanticModel, CancellationToken cancellationToken);
    protected virtual bool AssignmentSupportsStylePreference(SyntaxToken identifier, TypeSyntax typeName, ExpressionSyntax initializer, SemanticModel semanticModel, OptionSet optionSet, CancellationToken cancellationToken);
    internal static ExpressionSyntax GetInitializerExpression(ExpressionSyntax initializer);
    protected virtual bool ShouldAnalyzeDeclarationExpression(DeclarationExpressionSyntax declaration, SemanticModel semanticModel, CancellationToken cancellationToken);
}
internal static class Microsoft.CodeAnalysis.CSharp.Utilities.FormattingRangeHelper : object {
    public static Nullable`1<ValueTuple`2<SyntaxToken, SyntaxToken>> FindAppropriateRange(SyntaxToken endToken, bool useDefaultRange);
    private static Nullable`1<ValueTuple`2<SyntaxToken, SyntaxToken>> FixupOpenBrace(Nullable`1<ValueTuple`2<SyntaxToken, SyntaxToken>> tokenRange);
    private static Nullable`1<ValueTuple`2<SyntaxToken, SyntaxToken>> FindAppropriateRangeWorker(SyntaxToken endToken, bool useDefaultRange);
    private static Nullable`1<ValueTuple`2<SyntaxToken, SyntaxToken>> FindAppropriateRangeForSemicolon(SyntaxToken endToken);
    private static Nullable`1<ValueTuple`2<SyntaxToken, SyntaxToken>> FindAppropriateRangeForCloseBrace(SyntaxToken endToken);
    private static Nullable`1<ValueTuple`2<SyntaxToken, SyntaxToken>> FindAppropriateRangeForColon(SyntaxToken endToken);
    private static SyntaxToken GetPreviousTokenIfNotFirstTokenInTree(SyntaxToken token);
    public static bool AreTwoTokensOnSameLine(SyntaxToken token1, SyntaxToken token2);
    private static SyntaxToken GetAppropriatePreviousToken(SyntaxToken startToken, bool canTokenBeFirstInABlock);
    private static bool IsOpenBraceTokenOfABlockOrTypeOrNamespace(SyntaxToken previousToken);
    [NullableContextAttribute("1")]
private static bool IsSpecialContainingNode(SyntaxNode node);
    [NullableContextAttribute("2")]
private static SyntaxNode GetTopContainingNode(SyntaxNode node);
    public static bool IsColonInSwitchLabel(SyntaxToken token);
    public static bool InBetweenTwoMembers(SyntaxToken previousToken, SyntaxToken currentToken);
    [NullableContextAttribute("2")]
public static MemberDeclarationSyntax GetEnclosingMember(SyntaxToken token);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.CodeAnalysis.CSharp.Utilities.NameSyntaxComparer : object {
    private IComparer`1<SyntaxToken> _tokenComparer;
    internal TypeSyntaxComparer TypeComparer;
    internal NameSyntaxComparer(IComparer`1<SyntaxToken> tokenComparer);
    public static IComparer`1<NameSyntax> Create();
    public static IComparer`1<NameSyntax> Create(IComparer`1<SyntaxToken> tokenComparer);
    [NullableContextAttribute("2")]
public sealed virtual int Compare(NameSyntax x, NameSyntax y);
    private IList`1<SimpleNameSyntax> DecomposeNameParts(NameSyntax name);
    private void DecomposeNameParts(NameSyntax name, List`1<SimpleNameSyntax> result);
    private int Compare(GenericNameSyntax x, GenericNameSyntax y);
}
internal class Microsoft.CodeAnalysis.CSharp.Utilities.NameSyntaxIterator : object {
    private NameSyntax _name;
    public NameSyntaxIterator(NameSyntax name);
    public sealed virtual IEnumerator`1<NameSyntax> GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
}
internal class Microsoft.CodeAnalysis.CSharp.Utilities.SpeculationAnalyzer : AbstractSpeculationAnalyzer`7<ExpressionSyntax, TypeSyntax, AttributeSyntax, ArgumentSyntax, CommonForEachStatementSyntax, ThrowStatementSyntax, Conversion> {
    public SpeculationAnalyzer(ExpressionSyntax expression, ExpressionSyntax newExpression, SemanticModel semanticModel, CancellationToken cancellationToken, bool skipVerificationForReplacedNode, bool failOnOverloadResolutionFailuresInOriginalCode);
    protected virtual SyntaxNode GetSemanticRootForSpeculation(ExpressionSyntax expression);
    public static bool CanSpeculateOnNode(SyntaxNode node);
    protected virtual void ValidateSpeculativeSemanticModel(SemanticModel speculativeSemanticModel, SyntaxNode nodeToSpeculate);
    protected virtual SemanticModel CreateSpeculativeSemanticModel(SyntaxNode originalNode, SyntaxNode nodeToSpeculate, SemanticModel semanticModel);
    public static SemanticModel CreateSpeculativeSemanticModelForNode(SyntaxNode originalNode, SyntaxNode nodeToSpeculate, SemanticModel semanticModel);
    public static SemanticModel CreateSpeculativeSemanticModelForNode(SyntaxNode nodeToSpeculate, SemanticModel semanticModel, int position, bool isInNamespaceOrTypeContext);
    public bool ReplacementChangesSemanticsOfUnchangedLambda(ExpressionSyntax originalLambda, ExpressionSyntax replacedLambda);
    private bool HaveSameParameterType(ParameterSyntax originalParam, ParameterSyntax replacedParam);
    private bool ReplacementChangesSemanticsForNodes(IEnumerable`1<IdentifierNameSyntax> originalIdentifierNodes, IEnumerable`1<IdentifierNameSyntax> replacedIdentifierNodes, SyntaxNode originalRoot);
    protected virtual bool ReplacementChangesSemanticsForNodeLanguageSpecific(SyntaxNode currentOriginalNode, SyntaxNode currentReplacedNode, SyntaxNode previousOriginalNode, SyntaxNode previousReplacedNode);
    private bool ReplacementBreaksBoxingInConditionalExpression(TypeInfo originalExpressionTypeInfo, TypeInfo newExpressionTypeInfo, ExpressionSyntax previousOriginalNode, ExpressionSyntax previousReplacedNode);
    private bool ReplacementBreaksAnonymousObjectMemberDeclarator(AnonymousObjectMemberDeclaratorSyntax originalAnonymousObjectMemberDeclarator, AnonymousObjectMemberDeclaratorSyntax replacedAnonymousObjectMemberDeclarator);
    private bool ReplacementBreaksConstructorInitializer(ConstructorInitializerSyntax ctorInitializer, ConstructorInitializerSyntax newCtorInitializer);
    private bool ReplacementBreaksCollectionInitializerAddMethod(ExpressionSyntax originalInitializer, ExpressionSyntax newInitializer);
    protected virtual bool ExpressionMightReferenceMember(SyntaxNode node);
    protected virtual ImmutableArray`1<ArgumentSyntax> GetArguments(ExpressionSyntax expression);
    private static BaseArgumentListSyntax GetArgumentList(ExpressionSyntax expression);
    protected virtual ExpressionSyntax GetReceiver(ExpressionSyntax expression);
    protected virtual bool IsInNamespaceOrTypeContext(ExpressionSyntax node);
    protected virtual ExpressionSyntax GetForEachStatementExpression(CommonForEachStatementSyntax forEachStatement);
    protected virtual ExpressionSyntax GetThrowStatementExpression(ThrowStatementSyntax throwStatement);
    protected virtual bool IsForEachTypeInferred(CommonForEachStatementSyntax forEachStatement, SemanticModel semanticModel);
    protected virtual bool IsParenthesizedExpression(SyntaxNode node);
    protected virtual bool IsNamedArgument(ArgumentSyntax argument);
    protected virtual string GetNamedArgumentIdentifierValueText(ArgumentSyntax argument);
    private bool ReplacementBreaksBinaryExpression(BinaryExpressionSyntax binaryExpression, BinaryExpressionSyntax newBinaryExpression);
    private bool ReplacementBreaksConditionalAccessExpression(ConditionalAccessExpressionSyntax conditionalAccessExpression, ConditionalAccessExpressionSyntax newConditionalAccessExpression);
    private bool ReplacementBreaksIsOrAsExpression(BinaryExpressionSyntax originalIsOrAsExpression, BinaryExpressionSyntax newIsOrAsExpression);
    private bool ReplacementBreaksAssignmentExpression(AssignmentExpressionSyntax assignmentExpression, AssignmentExpressionSyntax newAssignmentExpression);
    private bool ReplacementBreaksQueryClause(QueryClauseSyntax originalClause, QueryClauseSyntax newClause);
    protected virtual bool ReplacementIntroducesErrorType(ExpressionSyntax originalExpression, ExpressionSyntax newExpression);
    protected virtual bool ConversionsAreCompatible(SemanticModel originalModel, ExpressionSyntax originalExpression, SemanticModel newModel, ExpressionSyntax newExpression);
    private static bool ConditionalExpressionConversionsAreAllowed(ExpressionSyntax originalExpression);
    protected virtual bool ConversionsAreCompatible(ExpressionSyntax originalExpression, ITypeSymbol originalTargetType, ExpressionSyntax newExpression, ITypeSymbol newTargetType);
    private bool ConversionsAreCompatible(Conversion originalConversion, Conversion newConversion);
    protected virtual bool ForEachConversionsAreCompatible(SemanticModel originalModel, CommonForEachStatementSyntax originalForEach, SemanticModel newModel, CommonForEachStatementSyntax newForEach);
    protected virtual void GetForEachSymbols(SemanticModel model, CommonForEachStatementSyntax forEach, IMethodSymbol& getEnumeratorMethod, ITypeSymbol& elementType);
    protected virtual bool IsReferenceConversion(Compilation compilation, ITypeSymbol sourceType, ITypeSymbol targetType);
    protected virtual Conversion ClassifyConversion(SemanticModel model, ExpressionSyntax expression, ITypeSymbol targetType);
    protected virtual Conversion ClassifyConversion(SemanticModel model, ITypeSymbol originalType, ITypeSymbol targetType);
}
internal class Microsoft.CodeAnalysis.CSharp.Utilities.SyntaxKindSet : object {
    public static ISet`1<SyntaxKind> AllTypeModifiers;
    public static ISet`1<SyntaxKind> AllMemberModifiers;
    public static ISet`1<SyntaxKind> AllGlobalMemberModifiers;
    public static ISet`1<SyntaxKind> AllLocalFunctionModifiers;
    public static ISet`1<SyntaxKind> AllTypeDeclarations;
    public static ISet`1<SyntaxKind> ClassInterfaceStructRecordTypeDeclarations;
    public static ISet`1<SyntaxKind> ClassInterfaceRecordTypeDeclarations;
    public static ISet`1<SyntaxKind> ClassStructRecordTypeDeclarations;
    public static ISet`1<SyntaxKind> StructOnlyTypeDeclarations;
    private static SyntaxKindSet();
}
internal class Microsoft.CodeAnalysis.CSharp.Utilities.TokenComparer : object {
    [NullableAttribute("1")]
public static IComparer`1<SyntaxToken> NormalInstance;
    [NullableAttribute("1")]
public static IComparer`1<SyntaxToken> SystemFirstInstance;
    private bool _specialCaseSystem;
    private TokenComparer(bool specialCaseSystem);
    private static TokenComparer();
    public sealed virtual int Compare(SyntaxToken x, SyntaxToken y);
    private static int CompareWorker(SyntaxToken x, SyntaxToken y);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.CodeAnalysis.CSharp.Utilities.TypeStyleResult : ValueType {
    private CSharpTypeStyleHelper _helper;
    private TypeSyntax _typeName;
    private SemanticModel _semanticModel;
    private OptionSet _optionSet;
    private CancellationToken _cancellationToken;
    public bool IsStylePreferred;
    public ReportDiagnostic Severity;
    public TypeStyleResult(CSharpTypeStyleHelper helper, TypeSyntax typeName, SemanticModel semanticModel, OptionSet optionSet, bool isStylePreferred, ReportDiagnostic severity, CancellationToken cancellationToken);
    public bool CanConvert();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.CodeAnalysis.CSharp.Utilities.TypeSyntaxComparer : object {
    private IComparer`1<SyntaxToken> _tokenComparer;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal IComparer`1<NameSyntax> NameComparer;
    internal TypeSyntaxComparer(IComparer`1<SyntaxToken> tokenComparer, IComparer`1<NameSyntax> nameComparer);
    [NullableContextAttribute("2")]
public sealed virtual int Compare(TypeSyntax x, TypeSyntax y);
    private static TypeSyntax UnwrapType(TypeSyntax type);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.CodeAnalysis.CSharp.Utilities.UsingsAndExternAliasesDirectiveComparer : object {
    public static IComparer`1<SyntaxNode> NormalInstance;
    public static IComparer`1<SyntaxNode> SystemFirstInstance;
    private IComparer`1<NameSyntax> _nameComparer;
    private IComparer`1<SyntaxToken> _tokenComparer;
    private UsingsAndExternAliasesDirectiveComparer(IComparer`1<NameSyntax> nameComparer, IComparer`1<SyntaxToken> tokenComparer);
    private static UsingsAndExternAliasesDirectiveComparer();
    [NullableContextAttribute("2")]
private static UsingKind GetUsingKind(UsingDirectiveSyntax usingDirective, ExternAliasDirectiveSyntax externDirective);
    [NullableContextAttribute("2")]
public sealed virtual int Compare(SyntaxNode directive1, SyntaxNode directive2);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal static class Microsoft.CodeAnalysis.CSharp.Utilities.UsingsAndExternAliasesOrganizer : object {
    private static SyntaxTrivia s_newLine;
    private static UsingsAndExternAliasesOrganizer();
    public static void Organize(SyntaxList`1<ExternAliasDirectiveSyntax> externAliasList, SyntaxList`1<UsingDirectiveSyntax> usingList, bool placeSystemNamespaceFirst, bool separateGroups, SyntaxList`1& organizedExternAliasList, SyntaxList`1& organizedUsingList);
    public static bool NeedsGrouping(UsingDirectiveSyntax using1, UsingDirectiveSyntax using2);
    private static void OrganizeWorker(SyntaxList`1<ExternAliasDirectiveSyntax> externAliasList, SyntaxList`1<UsingDirectiveSyntax> usingList, bool placeSystemNamespaceFirst, SyntaxList`1& organizedExternAliasList, SyntaxList`1& organizedUsingList);
    private static void EnsureNewLines(IList`1<SyntaxNode> list);
    private static SyntaxNode TrimLeadingNewLines(SyntaxNode node);
}
[CompilerGeneratedAttribute]
[EmbeddedAttribute]
internal class Microsoft.CodeAnalysis.EmbeddedAttribute : Attribute {
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
internal static class Microsoft.CodeAnalysis.ExternalAccess.Pythia.Api.PythiaSymbolExtensions : object {
    [ExtensionAttribute]
public static string ToNameDisplayString(ISymbol symbol);
    [ExtensionAttribute]
public static ITypeSymbol GetMemberType(ISymbol symbol);
    [NullableContextAttribute("2")]
[ExtensionAttribute]
public static ITypeSymbol GetSymbolType(ISymbol symbol);
    [NullableContextAttribute("2")]
[ExtensionAttribute]
public static ISymbol GetAnySymbol(SymbolInfo info);
    [ExtensionAttribute]
public static ImmutableArray`1<T> FilterToVisibleAndBrowsableSymbols(ImmutableArray`1<T> symbols, bool hideAdvancedMembers, Compilation compilation);
    [ExtensionAttribute]
public static bool IsAccessibleWithin(ISymbol symbol, ISymbol within, ITypeSymbol throughType);
    [ExtensionAttribute]
public static Nullable`1<bool> IsMoreSpecificThan(IMethodSymbol method1, IMethodSymbol method2);
    [NullableContextAttribute("2")]
[ExtensionAttribute]
public static ISymbol GetOriginalUnreducedDefinition(ISymbol symbol);
    [ExtensionAttribute]
public static bool IsAwaitableNonDynamic(ISymbol symbol, SemanticModel semanticModel, int position);
    [ExtensionAttribute]
public static bool IsExtensionMethod(ISymbol symbol);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
internal static class Microsoft.CodeAnalysis.ExternalAccess.Pythia.Api.PythiaSyntaxExtensions : object {
    [ExtensionAttribute]
public static bool IsInNonUserCode(SyntaxTree syntaxTree, int position, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static SyntaxToken GetPreviousTokenIfTouchingWord(SyntaxToken token, int position);
    [ExtensionAttribute]
public static SyntaxToken FindTokenOnLeftOfPosition(SyntaxTree syntaxTree, int position, CancellationToken cancellationToken, bool includeSkipped, bool includeDirectives, bool includeDocumentationComments);
    [ExtensionAttribute]
public static bool IsFoundUnder(SyntaxNode node, Func`2<TParent, SyntaxNode> childGetter);
    [ExtensionAttribute]
public static SimpleNameSyntax GetRightmostName(ExpressionSyntax node);
    [ExtensionAttribute]
public static bool IsInStaticContext(SyntaxNode node);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
[ExtensionAttribute]
internal static class Microsoft.CodeAnalysis.NullableExtensions : object {
    [ExtensionAttribute]
public static ITypeSymbol GetConvertedTypeWithAnnotatedNullability(TypeInfo typeInfo);
    [ExtensionAttribute]
public static ITypeSymbol GetTypeWithAnnotatedNullability(TypeInfo typeInfo);
}
internal class Microsoft.CodeAnalysis.RemoveUnnecessaryImports.CSharpUnnecessaryImportsProvider : AbstractUnnecessaryImportsProvider`1<UsingDirectiveSyntax> {
    public static CSharpUnnecessaryImportsProvider Instance;
    private static CSharpUnnecessaryImportsProvider();
    protected virtual ImmutableArray`1<SyntaxNode> GetUnnecessaryImports(SemanticModel model, SyntaxNode root, Func`2<SyntaxNode, bool> predicate, CancellationToken cancellationToken);
}
[CompilerGeneratedAttribute]
[EmbeddedAttribute]
internal class System.Runtime.CompilerServices.IsReadOnlyAttribute : Attribute {
}
[CompilerGeneratedAttribute]
[EmbeddedAttribute]
[AttributeUsageAttribute("27524")]
internal class System.Runtime.CompilerServices.NullableAttribute : Attribute {
    public Byte[] NullableFlags;
    public NullableAttribute(byte );
    public NullableAttribute(Byte[] );
}
[CompilerGeneratedAttribute]
[EmbeddedAttribute]
[AttributeUsageAttribute("5196")]
internal class System.Runtime.CompilerServices.NullableContextAttribute : Attribute {
    public byte Flag;
    public NullableContextAttribute(byte );
}
