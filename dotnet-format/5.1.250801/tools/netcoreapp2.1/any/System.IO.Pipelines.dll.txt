internal static class FxResources.System.IO.Pipelines.SR : object {
}
[CompilerGeneratedAttribute]
[EmbeddedAttribute]
internal class Microsoft.CodeAnalysis.EmbeddedAttribute : Attribute {
}
[AttributeUsageAttribute("2432")]
internal class System.Diagnostics.CodeAnalysis.AllowNullAttribute : Attribute {
}
[AttributeUsageAttribute("2432")]
internal class System.Diagnostics.CodeAnalysis.DisallowNullAttribute : Attribute {
}
[AttributeUsageAttribute("64")]
internal class System.Diagnostics.CodeAnalysis.DoesNotReturnAttribute : Attribute {
}
[AttributeUsageAttribute("2048")]
internal class System.Diagnostics.CodeAnalysis.DoesNotReturnIfAttribute : Attribute {
    [CompilerGeneratedAttribute]
private bool <ParameterValue>k__BackingField;
    public bool ParameterValue { get; }
    public DoesNotReturnIfAttribute(bool parameterValue);
    [CompilerGeneratedAttribute]
public bool get_ParameterValue();
}
[AttributeUsageAttribute("10624")]
internal class System.Diagnostics.CodeAnalysis.MaybeNullAttribute : Attribute {
}
[AttributeUsageAttribute("2048")]
internal class System.Diagnostics.CodeAnalysis.MaybeNullWhenAttribute : Attribute {
    [CompilerGeneratedAttribute]
private bool <ReturnValue>k__BackingField;
    public bool ReturnValue { get; }
    public MaybeNullWhenAttribute(bool returnValue);
    [CompilerGeneratedAttribute]
public bool get_ReturnValue();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[AttributeUsageAttribute("192")]
internal class System.Diagnostics.CodeAnalysis.MemberNotNullAttribute : Attribute {
    [CompilerGeneratedAttribute]
private String[] <Members>k__BackingField;
    public String[] Members { get; }
    public MemberNotNullAttribute(string member);
    public MemberNotNullAttribute(String[] members);
    [CompilerGeneratedAttribute]
public String[] get_Members();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[AttributeUsageAttribute("192")]
internal class System.Diagnostics.CodeAnalysis.MemberNotNullWhenAttribute : Attribute {
    [CompilerGeneratedAttribute]
private bool <ReturnValue>k__BackingField;
    [CompilerGeneratedAttribute]
private String[] <Members>k__BackingField;
    public bool ReturnValue { get; }
    public String[] Members { get; }
    public MemberNotNullWhenAttribute(bool returnValue, string member);
    public MemberNotNullWhenAttribute(bool returnValue, String[] members);
    [CompilerGeneratedAttribute]
public bool get_ReturnValue();
    [CompilerGeneratedAttribute]
public String[] get_Members();
}
[AttributeUsageAttribute("10624")]
internal class System.Diagnostics.CodeAnalysis.NotNullAttribute : Attribute {
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[AttributeUsageAttribute("10368")]
internal class System.Diagnostics.CodeAnalysis.NotNullIfNotNullAttribute : Attribute {
    [CompilerGeneratedAttribute]
private string <ParameterName>k__BackingField;
    public string ParameterName { get; }
    public NotNullIfNotNullAttribute(string parameterName);
    [CompilerGeneratedAttribute]
public string get_ParameterName();
}
[AttributeUsageAttribute("2048")]
internal class System.Diagnostics.CodeAnalysis.NotNullWhenAttribute : Attribute {
    [CompilerGeneratedAttribute]
private bool <ReturnValue>k__BackingField;
    public bool ReturnValue { get; }
    public NotNullWhenAttribute(bool returnValue);
    [CompilerGeneratedAttribute]
public bool get_ReturnValue();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class System.IO.Pipelines.BufferSegment : ReadOnlySequenceSegment`1<byte> {
    private IMemoryOwner`1<byte> _memoryOwner;
    private Byte[] _array;
    private BufferSegment _next;
    private int _end;
    [CompilerGeneratedAttribute]
private Memory`1<byte> <AvailableMemory>k__BackingField;
    public int End { get; public set; }
    [NullableAttribute("2")]
public BufferSegment NextSegment { get; public set; }
    [NullableAttribute("2")]
internal object MemoryOwner { get; }
    [NullableAttribute("0")]
public Memory`1<byte> AvailableMemory { get; private set; }
    public int Length { get; }
    public int WritableBytes { get; }
    public int get_End();
    public void set_End(int value);
    [NullableContextAttribute("2")]
public BufferSegment get_NextSegment();
    [NullableContextAttribute("2")]
public void set_NextSegment(BufferSegment value);
    public void SetOwnedMemory(IMemoryOwner`1<byte> memoryOwner);
    public void SetOwnedMemory(Byte[] arrayPoolBuffer);
    public void ResetMemory();
    [NullableContextAttribute("2")]
internal object get_MemoryOwner();
    [NullableContextAttribute("0")]
[CompilerGeneratedAttribute]
public Memory`1<byte> get_AvailableMemory();
    [CompilerGeneratedAttribute]
private void set_AvailableMemory(Memory`1<byte> value);
    public int get_Length();
    public int get_WritableBytes();
    public void SetNext(BufferSegment segment);
    internal static long GetLength(BufferSegment startSegment, int startIndex, BufferSegment endSegment, int endIndex);
    internal static long GetLength(long startPosition, BufferSegment endSegment, int endIndex);
}
internal class System.IO.Pipelines.BufferSegmentStack : ValueType {
    private SegmentAsValueType[] _array;
    private int _size;
    public int Count { get; }
    public BufferSegmentStack(int size);
    public int get_Count();
    [NullableContextAttribute("2")]
public bool TryPop(BufferSegment& result);
    [NullableContextAttribute("1")]
public void Push(BufferSegment item);
    private void PushWithResize(BufferSegment item);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
[IsReadOnlyAttribute]
internal class System.IO.Pipelines.CompletionData : ValueType {
    [CompilerGeneratedAttribute]
private Action`1<object> <Completion>k__BackingField;
    [CompilerGeneratedAttribute]
private object <CompletionState>k__BackingField;
    [CompilerGeneratedAttribute]
private ExecutionContext <ExecutionContext>k__BackingField;
    [CompilerGeneratedAttribute]
private SynchronizationContext <SynchronizationContext>k__BackingField;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public Action`1<object> Completion { get; }
    public object CompletionState { get; }
    public ExecutionContext ExecutionContext { get; }
    public SynchronizationContext SynchronizationContext { get; }
    public CompletionData(Action`1<object> completion, object completionState, ExecutionContext executionContext, SynchronizationContext synchronizationContext);
    [CompilerGeneratedAttribute]
public Action`1<object> get_Completion();
    [CompilerGeneratedAttribute]
public object get_CompletionState();
    [CompilerGeneratedAttribute]
public ExecutionContext get_ExecutionContext();
    [CompilerGeneratedAttribute]
public SynchronizationContext get_SynchronizationContext();
}
internal enum System.IO.Pipelines.ExceptionArgument : Enum {
    public int value__;
    public static ExceptionArgument minimumSize;
    public static ExceptionArgument bytes;
    public static ExceptionArgument callback;
    public static ExceptionArgument options;
    public static ExceptionArgument pauseWriterThreshold;
    public static ExceptionArgument resumeWriterThreshold;
    public static ExceptionArgument sizeHint;
}
public class System.IO.Pipelines.FlushResult : ValueType {
    internal ResultFlags _resultFlags;
    public bool IsCanceled { get; }
    public bool IsCompleted { get; }
    public FlushResult(bool isCanceled, bool isCompleted);
    public bool get_IsCanceled();
    public bool get_IsCompleted();
}
[NullableContextAttribute("1")]
public interface System.IO.Pipelines.IDuplexPipe {
    public PipeReader Input { get; }
    public PipeWriter Output { get; }
    public abstract virtual PipeReader get_Input();
    public abstract virtual PipeWriter get_Output();
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
internal class System.IO.Pipelines.InlineScheduler : PipeScheduler {
    public virtual void Schedule(Action`1<object> action, object state);
    internal virtual void UnsafeSchedule(Action`1<object> action, object state);
}
public class System.IO.Pipelines.Pipe : object {
    internal static int InitialSegmentPoolSize;
    internal static int MaxSegmentPoolSize;
    private static Action`1<object> s_signalReaderAwaitable;
    private static Action`1<object> s_signalWriterAwaitable;
    private static Action`1<object> s_invokeCompletionCallbacks;
    private static ContextCallback s_executionContextRawCallback;
    private static SendOrPostCallback s_syncContextExecutionContextCallback;
    private static SendOrPostCallback s_syncContextExecuteWithoutExecutionContextCallback;
    private static Action`1<object> s_scheduleWithExecutionContextCallback;
    private object _sync;
    private MemoryPool`1<byte> _pool;
    private int _minimumSegmentSize;
    private long _pauseWriterThreshold;
    private long _resumeWriterThreshold;
    private PipeScheduler _readerScheduler;
    private PipeScheduler _writerScheduler;
    private BufferSegmentStack _bufferSegmentPool;
    private DefaultPipeReader _reader;
    private DefaultPipeWriter _writer;
    private bool _useSynchronizationContext;
    private long _unconsumedBytes;
    private long _unflushedBytes;
    private PipeAwaitable _readerAwaitable;
    private PipeAwaitable _writerAwaitable;
    private PipeCompletion _writerCompletion;
    private PipeCompletion _readerCompletion;
    private long _lastExaminedIndex;
    private BufferSegment _readHead;
    private int _readHeadIndex;
    private int _maxPooledBufferSize;
    private bool _disposed;
    private BufferSegment _readTail;
    private int _readTailIndex;
    private BufferSegment _writingHead;
    private Memory`1<byte> _writingHeadMemory;
    private int _writingHeadBytesBuffered;
    private PipeOperationState _operationState;
    internal long Length { get; }
    [NullableAttribute("1")]
public PipeReader Reader { get; }
    [NullableAttribute("1")]
public PipeWriter Writer { get; }
    [NullableContextAttribute("1")]
public Pipe(PipeOptions options);
    private static Pipe();
    internal long get_Length();
    private void ResetState();
    internal Memory`1<byte> GetMemory(int sizeHint);
    internal Span`1<byte> GetSpan(int sizeHint);
    private void AllocateWriteHeadIfNeeded(int sizeHint);
    private void AllocateWriteHeadSynchronized(int sizeHint);
    private BufferSegment AllocateSegment(int sizeHint);
    private int GetSegmentSize(int sizeHint, int maxBufferSize);
    private BufferSegment CreateSegmentUnsynchronized();
    private void ReturnSegmentUnsynchronized(BufferSegment segment);
    internal bool CommitUnsynchronized();
    internal void Advance(int bytes);
    private void AdvanceCore(int bytesWritten);
    internal ValueTask`1<FlushResult> FlushAsync(CancellationToken cancellationToken);
    private void PrepareFlush(CompletionData& completionData, ValueTask`1& result, CancellationToken cancellationToken);
    [NullableContextAttribute("2")]
internal void CompleteWriter(Exception exception);
    internal void AdvanceReader(SequencePosition& consumed);
    internal void AdvanceReader(SequencePosition& consumed, SequencePosition& examined);
    private void AdvanceReader(BufferSegment consumedSegment, int consumedIndex, BufferSegment examinedSegment, int examinedIndex);
    [NullableContextAttribute("2")]
internal void CompleteReader(Exception exception);
    [NullableContextAttribute("2")]
internal void OnWriterCompleted(Action`2<Exception, object> callback, object state);
    internal void CancelPendingRead();
    internal void CancelPendingFlush();
    [NullableContextAttribute("2")]
internal void OnReaderCompleted(Action`2<Exception, object> callback, object state);
    internal ValueTask`1<ReadResult> ReadAsync(CancellationToken token);
    internal bool TryRead(ReadResult& result);
    private static void ScheduleCallbacks(PipeScheduler scheduler, PipeCompletionCallbacks completionCallbacks);
    private static void TrySchedule(PipeScheduler scheduler, CompletionData& completionData);
    private static void ScheduleWithContext(PipeScheduler scheduler, CompletionData& completionData);
    private static void ExecuteWithoutExecutionContext(object state);
    private static void ExecuteWithExecutionContext(object state);
    private void CompletePipe();
    internal ValueTaskSourceStatus GetReadAsyncStatus();
    [NullableContextAttribute("2")]
internal void OnReadAsyncCompleted(Action`1<object> continuation, object state, ValueTaskSourceOnCompletedFlags flags);
    internal ReadResult GetReadAsyncResult();
    private void GetReadResult(ReadResult& result);
    internal ValueTaskSourceStatus GetFlushAsyncStatus();
    internal FlushResult GetFlushAsyncResult();
    private void GetFlushResult(FlushResult& result);
    internal ValueTask`1<FlushResult> WriteAsync(ReadOnlyMemory`1<byte> source, CancellationToken cancellationToken);
    private void WriteMultiSegment(ReadOnlySpan`1<byte> source);
    [NullableContextAttribute("2")]
internal void OnFlushAsyncCompleted(Action`1<object> continuation, object state, ValueTaskSourceOnCompletedFlags flags);
    private void ReaderCancellationRequested();
    private void WriterCancellationRequested();
    [NullableContextAttribute("1")]
public PipeReader get_Reader();
    [NullableContextAttribute("1")]
public PipeWriter get_Writer();
    public void Reset();
    [CompilerGeneratedAttribute]
private void <AdvanceReader>g__MoveReturnEndToNextBlock|60_0(<>c__DisplayClass60_0& );
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
[DebuggerDisplayAttribute("CanceledState: {_awaitableState}, IsCompleted: {IsCompleted}")]
internal class System.IO.Pipelines.PipeAwaitable : ValueType {
    private AwaitableState _awaitableState;
    private Action`1<object> _completion;
    private object _completionState;
    private CancellationTokenRegistration _cancellationTokenRegistration;
    private SynchronizationContext _synchronizationContext;
    private ExecutionContext _executionContext;
    private CancellationToken _cancellationToken;
    private CancellationToken CancellationToken { get; }
    public bool IsCompleted { get; }
    public bool IsRunning { get; }
    public PipeAwaitable(bool completed, bool useSynchronizationContext);
    private CancellationToken get_CancellationToken();
    public bool get_IsCompleted();
    public bool get_IsRunning();
    public void BeginOperation(CancellationToken cancellationToken, Action`1<object> callback, object state);
    public void Complete(CompletionData& completionData);
    private void ExtractCompletion(CompletionData& completionData);
    public void SetUncompleted();
    public void OnCompleted(Action`1<object> continuation, object state, ValueTaskSourceOnCompletedFlags flags, CompletionData& completionData, Boolean& doubleCompletion);
    public void Cancel(CompletionData& completionData);
    public void CancellationTokenFired(CompletionData& completionData);
    public bool ObserveCancellation();
    public CancellationTokenRegistration ReleaseCancellationTokenRegistration(CancellationToken& cancellationToken);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
[DebuggerDisplayAttribute("IsCompleted: {IsCompleted}")]
internal class System.IO.Pipelines.PipeCompletion : ValueType {
    private static ArrayPool`1<PipeCompletionCallback> s_completionCallbackPool;
    private static int InitialCallbacksSize;
    private bool _isCompleted;
    private ExceptionDispatchInfo _exceptionInfo;
    private PipeCompletionCallback _firstCallback;
    private PipeCompletionCallback[] _callbacks;
    private int _callbackCount;
    public bool IsCompleted { get; }
    public bool IsFaulted { get; }
    private static PipeCompletion();
    public bool get_IsCompleted();
    public bool get_IsFaulted();
    public PipeCompletionCallbacks TryComplete(Exception exception);
    public PipeCompletionCallbacks AddCallback(Action`2<Exception, object> callback, object state);
    private void EnsureSpace();
    public bool IsCompletedOrThrow();
    private PipeCompletionCallbacks GetCallbacks();
    public void Reset();
    private void ThrowLatchedException();
    [NullableContextAttribute("1")]
public virtual string ToString();
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
internal class System.IO.Pipelines.PipeCompletionCallback : ValueType {
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public Action`2<Exception, object> Callback;
    public object State;
    public PipeCompletionCallback(Action`2<Exception, object> callback, object state);
}
internal class System.IO.Pipelines.PipeCompletionCallbacks : object {
    private ArrayPool`1<PipeCompletionCallback> _pool;
    private int _count;
    private Exception _exception;
    private PipeCompletionCallback _firstCallback;
    private PipeCompletionCallback[] _callbacks;
    [NullableContextAttribute("2")]
public PipeCompletionCallbacks(ArrayPool`1<PipeCompletionCallback> pool, int count, Exception exception, PipeCompletionCallback firstCallback, PipeCompletionCallback[] callbacks);
    public void Execute();
    private void Execute(PipeCompletionCallback callback, List`1& exceptions);
}
[DebuggerDisplayAttribute("State: {_state}")]
internal class System.IO.Pipelines.PipeOperationState : ValueType {
    private State _state;
    public bool IsWritingActive { get; }
    public bool IsReadingActive { get; }
    public void BeginRead();
    public void BeginReadTentative();
    public void EndRead();
    public void BeginWrite();
    public void EndWrite();
    public bool get_IsWritingActive();
    public bool get_IsReadingActive();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class System.IO.Pipelines.PipeOptions : object {
    private static int DefaultMinimumSegmentSize;
    private static int DefaultResumeWriterThreshold;
    private static int DefaultPauseWriterThreshold;
    [CompilerGeneratedAttribute]
private static PipeOptions <Default>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <UseSynchronizationContext>k__BackingField;
    [CompilerGeneratedAttribute]
private long <PauseWriterThreshold>k__BackingField;
    [CompilerGeneratedAttribute]
private long <ResumeWriterThreshold>k__BackingField;
    [CompilerGeneratedAttribute]
private int <MinimumSegmentSize>k__BackingField;
    [CompilerGeneratedAttribute]
private PipeScheduler <WriterScheduler>k__BackingField;
    [CompilerGeneratedAttribute]
private PipeScheduler <ReaderScheduler>k__BackingField;
    [CompilerGeneratedAttribute]
private MemoryPool`1<byte> <Pool>k__BackingField;
    public static PipeOptions Default { get; }
    public bool UseSynchronizationContext { get; }
    public long PauseWriterThreshold { get; }
    public long ResumeWriterThreshold { get; }
    public int MinimumSegmentSize { get; }
    public PipeScheduler WriterScheduler { get; }
    public PipeScheduler ReaderScheduler { get; }
    public MemoryPool`1<byte> Pool { get; }
    [NullableContextAttribute("2")]
public PipeOptions(MemoryPool`1<byte> pool, PipeScheduler readerScheduler, PipeScheduler writerScheduler, long pauseWriterThreshold, long resumeWriterThreshold, int minimumSegmentSize, bool useSynchronizationContext);
    private static PipeOptions();
    [CompilerGeneratedAttribute]
public static PipeOptions get_Default();
    [CompilerGeneratedAttribute]
public bool get_UseSynchronizationContext();
    [CompilerGeneratedAttribute]
public long get_PauseWriterThreshold();
    [CompilerGeneratedAttribute]
public long get_ResumeWriterThreshold();
    [CompilerGeneratedAttribute]
public int get_MinimumSegmentSize();
    [CompilerGeneratedAttribute]
public PipeScheduler get_WriterScheduler();
    [CompilerGeneratedAttribute]
public PipeScheduler get_ReaderScheduler();
    [CompilerGeneratedAttribute]
public MemoryPool`1<byte> get_Pool();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public abstract class System.IO.Pipelines.PipeReader : object {
    private PipeReaderStream _stream;
    public abstract virtual bool TryRead(ReadResult& result);
    [NullableContextAttribute("0")]
public abstract virtual ValueTask`1<ReadResult> ReadAsync(CancellationToken cancellationToken);
    public abstract virtual void AdvanceTo(SequencePosition consumed);
    public abstract virtual void AdvanceTo(SequencePosition consumed, SequencePosition examined);
    public virtual Stream AsStream(bool leaveOpen);
    public abstract virtual void CancelPendingRead();
    [NullableContextAttribute("2")]
public abstract virtual void Complete(Exception exception);
    [NullableContextAttribute("2")]
public virtual ValueTask CompleteAsync(Exception exception);
    [NullableContextAttribute("2")]
[ObsoleteAttribute("OnWriterCompleted may not be invoked on all implementations of PipeReader. This will be removed in a future release.")]
public virtual void OnWriterCompleted(Action`2<Exception, object> callback, object state);
    public static PipeReader Create(Stream stream, StreamPipeReaderOptions readerOptions);
    public virtual Task CopyToAsync(PipeWriter destination, CancellationToken cancellationToken);
    public virtual Task CopyToAsync(Stream destination, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("System.IO.Pipelines.PipeReader/<CopyToAsyncCore>d__13`1")]
private Task CopyToAsyncCore(TStream destination, Func`4<TStream, ReadOnlyMemory`1<byte>, CancellationToken, ValueTask> writeAsync, CancellationToken cancellationToken);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class System.IO.Pipelines.PipeReaderStream : Stream {
    private PipeReader _pipeReader;
    [CompilerGeneratedAttribute]
private bool <LeaveOpen>k__BackingField;
    public bool CanRead { get; }
    public bool CanSeek { get; }
    public bool CanWrite { get; }
    public long Length { get; }
    public long Position { get; public set; }
    internal bool LeaveOpen { get; internal set; }
    public PipeReaderStream(PipeReader pipeReader, bool leaveOpen);
    protected virtual void Dispose(bool disposing);
    public virtual bool get_CanRead();
    public virtual bool get_CanSeek();
    public virtual bool get_CanWrite();
    public virtual long get_Length();
    public virtual long get_Position();
    public virtual void set_Position(long value);
    [CompilerGeneratedAttribute]
internal bool get_LeaveOpen();
    [CompilerGeneratedAttribute]
internal void set_LeaveOpen(bool value);
    public virtual void Flush();
    public virtual int Read(Byte[] buffer, int offset, int count);
    public virtual long Seek(long offset, SeekOrigin origin);
    public virtual void SetLength(long value);
    public virtual void Write(Byte[] buffer, int offset, int count);
    public sealed virtual IAsyncResult BeginRead(Byte[] buffer, int offset, int count, AsyncCallback callback, object state);
    public sealed virtual int EndRead(IAsyncResult asyncResult);
    public virtual Task`1<int> ReadAsync(Byte[] buffer, int offset, int count, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("System.IO.Pipelines.PipeReaderStream/<ReadAsyncInternal>d__26")]
private ValueTask`1<int> ReadAsyncInternal(Memory`1<byte> buffer, CancellationToken cancellationToken);
    public virtual Task CopyToAsync(Stream destination, int bufferSize, CancellationToken cancellationToken);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public abstract class System.IO.Pipelines.PipeScheduler : object {
    private static ThreadPoolScheduler s_threadPoolScheduler;
    private static InlineScheduler s_inlineScheduler;
    public static PipeScheduler ThreadPool { get; }
    public static PipeScheduler Inline { get; }
    private static PipeScheduler();
    public static PipeScheduler get_ThreadPool();
    public static PipeScheduler get_Inline();
    [NullableContextAttribute("2")]
public abstract virtual void Schedule(Action`1<object> action, object state);
    [NullableContextAttribute("2")]
internal virtual void UnsafeSchedule(Action`1<object> action, object state);
}
public abstract class System.IO.Pipelines.PipeWriter : object {
    private PipeWriterStream _stream;
    [NullableContextAttribute("2")]
public abstract virtual void Complete(Exception exception);
    [NullableContextAttribute("2")]
public virtual ValueTask CompleteAsync(Exception exception);
    public abstract virtual void CancelPendingFlush();
    [NullableContextAttribute("2")]
[ObsoleteAttribute("OnReaderCompleted may not be invoked on all implementations of PipeWriter. This will be removed in a future release.")]
public virtual void OnReaderCompleted(Action`2<Exception, object> callback, object state);
    public abstract virtual ValueTask`1<FlushResult> FlushAsync(CancellationToken cancellationToken);
    public abstract virtual void Advance(int bytes);
    public abstract virtual Memory`1<byte> GetMemory(int sizeHint);
    public abstract virtual Span`1<byte> GetSpan(int sizeHint);
    [NullableContextAttribute("1")]
public virtual Stream AsStream(bool leaveOpen);
    [NullableContextAttribute("1")]
public static PipeWriter Create(Stream stream, StreamPipeWriterOptions writerOptions);
    public virtual ValueTask`1<FlushResult> WriteAsync(ReadOnlyMemory`1<byte> source, CancellationToken cancellationToken);
    [NullableContextAttribute("1")]
[AsyncStateMachineAttribute("System.IO.Pipelines.PipeWriter/<CopyFromAsync>d__12")]
protected internal virtual Task CopyFromAsync(Stream source, CancellationToken cancellationToken);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class System.IO.Pipelines.PipeWriterStream : Stream {
    private PipeWriter _pipeWriter;
    [CompilerGeneratedAttribute]
private bool <LeaveOpen>k__BackingField;
    internal bool LeaveOpen { get; internal set; }
    public bool CanRead { get; }
    public bool CanSeek { get; }
    public bool CanWrite { get; }
    public long Length { get; }
    public long Position { get; public set; }
    public PipeWriterStream(PipeWriter pipeWriter, bool leaveOpen);
    protected virtual void Dispose(bool disposing);
    [CompilerGeneratedAttribute]
internal bool get_LeaveOpen();
    [CompilerGeneratedAttribute]
internal void set_LeaveOpen(bool value);
    public virtual bool get_CanRead();
    public virtual bool get_CanSeek();
    public virtual bool get_CanWrite();
    public virtual long get_Length();
    public virtual long get_Position();
    public virtual void set_Position(long value);
    public virtual void Flush();
    public virtual int Read(Byte[] buffer, int offset, int count);
    public virtual long Seek(long offset, SeekOrigin origin);
    public virtual void SetLength(long value);
    public sealed virtual IAsyncResult BeginWrite(Byte[] buffer, int offset, int count, AsyncCallback callback, object state);
    public sealed virtual void EndWrite(IAsyncResult asyncResult);
    public virtual void Write(Byte[] buffer, int offset, int count);
    public virtual Task WriteAsync(Byte[] buffer, int offset, int count, CancellationToken cancellationToken);
    public virtual Task FlushAsync(CancellationToken cancellationToken);
    private static Task GetFlushResultAsTask(ValueTask`1<FlushResult> valueTask);
    [NullableContextAttribute("0")]
[AsyncStateMachineAttribute("System.IO.Pipelines.PipeWriterStream/<<GetFlushResultAsTask>g__AwaitTask|27_0>d")]
[CompilerGeneratedAttribute]
internal static Task <GetFlushResultAsTask>g__AwaitTask|27_0(ValueTask`1<FlushResult> valueTask);
}
[IsReadOnlyAttribute]
public class System.IO.Pipelines.ReadResult : ValueType {
    internal ReadOnlySequence`1<byte> _resultBuffer;
    internal ResultFlags _resultFlags;
    public ReadOnlySequence`1<byte> Buffer { get; }
    public bool IsCanceled { get; }
    public bool IsCompleted { get; }
    public ReadResult(ReadOnlySequence`1<byte> buffer, bool isCanceled, bool isCompleted);
    public ReadOnlySequence`1<byte> get_Buffer();
    public bool get_IsCanceled();
    public bool get_IsCompleted();
}
[FlagsAttribute]
internal enum System.IO.Pipelines.ResultFlags : Enum {
    public byte value__;
    public static ResultFlags None;
    public static ResultFlags Canceled;
    public static ResultFlags Completed;
}
[ExtensionAttribute]
internal static class System.IO.Pipelines.StreamExtensions : object {
    [ExtensionAttribute]
public static ValueTask`1<int> ReadAsync(Stream stream, Memory`1<byte> buffer, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static void Write(Stream stream, ReadOnlyMemory`1<byte> buffer);
    [ExtensionAttribute]
public static ValueTask WriteAsync(Stream stream, ReadOnlyMemory`1<byte> buffer, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("System.IO.Pipelines.StreamExtensions/<FinishWriteAsync>d__3")]
private static Task FinishWriteAsync(Task writeTask, Byte[] localBuffer);
    [AsyncStateMachineAttribute("System.IO.Pipelines.StreamExtensions/<<ReadAsync>g__FinishReadAsync|0_0>d")]
[CompilerGeneratedAttribute]
internal static ValueTask`1<int> <ReadAsync>g__FinishReadAsync|0_0(Task`1<int> readTask, Byte[] localBuffer, Memory`1<byte> localDestination);
}
[ExtensionAttribute]
public static class System.IO.Pipelines.StreamPipeExtensions : object {
    [NullableContextAttribute("1")]
[ExtensionAttribute]
public static Task CopyToAsync(Stream source, PipeWriter destination, CancellationToken cancellationToken);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class System.IO.Pipelines.StreamPipeReader : PipeReader {
    internal static int InitialSegmentPoolSize;
    internal static int MaxSegmentPoolSize;
    private int _bufferSize;
    private int _minimumReadThreshold;
    private MemoryPool`1<byte> _pool;
    private CancellationTokenSource _internalTokenSource;
    private bool _isReaderCompleted;
    private bool _isStreamCompleted;
    private BufferSegment _readHead;
    private int _readIndex;
    private BufferSegment _readTail;
    private long _bufferedBytes;
    private bool _examinedEverything;
    private object _lock;
    private BufferSegmentStack _bufferSegmentPool;
    private bool _leaveOpen;
    [CompilerGeneratedAttribute]
private Stream <InnerStream>k__BackingField;
    public Stream InnerStream { get; }
    private CancellationTokenSource InternalTokenSource { get; }
    public StreamPipeReader(Stream readingStream, StreamPipeReaderOptions options);
    [CompilerGeneratedAttribute]
public Stream get_InnerStream();
    public virtual void AdvanceTo(SequencePosition consumed);
    private CancellationTokenSource get_InternalTokenSource();
    public virtual void AdvanceTo(SequencePosition consumed, SequencePosition examined);
    private void AdvanceTo(BufferSegment consumedSegment, int consumedIndex, BufferSegment examinedSegment, int examinedIndex);
    public virtual void CancelPendingRead();
    [NullableContextAttribute("2")]
public virtual void Complete(Exception exception);
    [NullableContextAttribute("0")]
[AsyncStateMachineAttribute("System.IO.Pipelines.StreamPipeReader/<ReadAsync>d__27")]
public virtual ValueTask`1<ReadResult> ReadAsync(CancellationToken cancellationToken);
    private void ClearCancellationToken();
    private void ThrowIfCompleted();
    public virtual bool TryRead(ReadResult& result);
    private bool TryReadInternal(CancellationTokenSource source, ReadResult& result);
    private ReadOnlySequence`1<byte> GetCurrentReadOnlySequence();
    private void AllocateReadTail();
    private BufferSegment AllocateSegment();
    private BufferSegment CreateSegmentUnsynchronized();
    private void ReturnSegmentUnsynchronized(BufferSegment segment);
    private void Cancel();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class System.IO.Pipelines.StreamPipeReaderOptions : object {
    private static int DefaultBufferSize;
    private static int DefaultMinimumReadSize;
    internal static StreamPipeReaderOptions s_default;
    [CompilerGeneratedAttribute]
private int <BufferSize>k__BackingField;
    [CompilerGeneratedAttribute]
private int <MinimumReadSize>k__BackingField;
    [CompilerGeneratedAttribute]
private MemoryPool`1<byte> <Pool>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <LeaveOpen>k__BackingField;
    public int BufferSize { get; }
    public int MinimumReadSize { get; }
    public MemoryPool`1<byte> Pool { get; }
    public bool LeaveOpen { get; }
    [NullableContextAttribute("2")]
public StreamPipeReaderOptions(MemoryPool`1<byte> pool, int bufferSize, int minimumReadSize, bool leaveOpen);
    private static StreamPipeReaderOptions();
    [CompilerGeneratedAttribute]
public int get_BufferSize();
    [CompilerGeneratedAttribute]
public int get_MinimumReadSize();
    [CompilerGeneratedAttribute]
public MemoryPool`1<byte> get_Pool();
    [CompilerGeneratedAttribute]
public bool get_LeaveOpen();
}
internal class System.IO.Pipelines.StreamPipeWriter : PipeWriter {
    internal static int InitialSegmentPoolSize;
    internal static int MaxSegmentPoolSize;
    private int _minimumBufferSize;
    private BufferSegment _head;
    private BufferSegment _tail;
    private Memory`1<byte> _tailMemory;
    private int _tailBytesBuffered;
    private int _bytesBuffered;
    private MemoryPool`1<byte> _pool;
    private CancellationTokenSource _internalTokenSource;
    private bool _isCompleted;
    private object _lockObject;
    private BufferSegmentStack _bufferSegmentPool;
    private bool _leaveOpen;
    [CompilerGeneratedAttribute]
private Stream <InnerStream>k__BackingField;
    [NullableAttribute("1")]
private CancellationTokenSource InternalTokenSource { get; }
    [NullableAttribute("1")]
public Stream InnerStream { get; }
    [NullableContextAttribute("1")]
public StreamPipeWriter(Stream writingStream, StreamPipeWriterOptions options);
    private CancellationTokenSource get_InternalTokenSource();
    [NullableContextAttribute("1")]
[CompilerGeneratedAttribute]
public Stream get_InnerStream();
    public virtual void Advance(int bytes);
    public virtual Memory`1<byte> GetMemory(int sizeHint);
    public virtual Span`1<byte> GetSpan(int sizeHint);
    private void AllocateMemory(int sizeHint);
    private BufferSegment AllocateSegment(int sizeHint);
    private int GetSegmentSize(int sizeHint, int maxBufferSize);
    private BufferSegment CreateSegmentUnsynchronized();
    private void ReturnSegmentUnsynchronized(BufferSegment segment);
    public virtual void CancelPendingFlush();
    [NullableContextAttribute("2")]
public virtual void Complete(Exception exception);
    [NullableContextAttribute("2")]
[AsyncStateMachineAttribute("System.IO.Pipelines.StreamPipeWriter/<CompleteAsync>d__30")]
public virtual ValueTask CompleteAsync(Exception exception);
    public virtual ValueTask`1<FlushResult> FlushAsync(CancellationToken cancellationToken);
    private void Cancel();
    [AsyncStateMachineAttribute("System.IO.Pipelines.StreamPipeWriter/<FlushAsyncInternal>d__33")]
private ValueTask`1<FlushResult> FlushAsyncInternal(bool writeToStream, CancellationToken cancellationToken);
    private void FlushInternal(bool writeToStream);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class System.IO.Pipelines.StreamPipeWriterOptions : object {
    private static int DefaultMinimumBufferSize;
    internal static StreamPipeWriterOptions s_default;
    [CompilerGeneratedAttribute]
private int <MinimumBufferSize>k__BackingField;
    [CompilerGeneratedAttribute]
private MemoryPool`1<byte> <Pool>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <LeaveOpen>k__BackingField;
    public int MinimumBufferSize { get; }
    public MemoryPool`1<byte> Pool { get; }
    public bool LeaveOpen { get; }
    [NullableContextAttribute("2")]
public StreamPipeWriterOptions(MemoryPool`1<byte> pool, int minimumBufferSize, bool leaveOpen);
    private static StreamPipeWriterOptions();
    [CompilerGeneratedAttribute]
public int get_MinimumBufferSize();
    [CompilerGeneratedAttribute]
public MemoryPool`1<byte> get_Pool();
    [CompilerGeneratedAttribute]
public bool get_LeaveOpen();
}
internal class System.IO.Pipelines.ThreadPoolScheduler : PipeScheduler {
    [NullableContextAttribute("1")]
public virtual void Schedule(Action`1<object> action, object state);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal static class System.IO.Pipelines.ThrowHelper : object {
    [DoesNotReturnAttribute]
internal static void ThrowArgumentOutOfRangeException(ExceptionArgument argument);
    private static Exception CreateArgumentOutOfRangeException(ExceptionArgument argument);
    [DoesNotReturnAttribute]
internal static void ThrowArgumentNullException(ExceptionArgument argument);
    private static Exception CreateArgumentNullException(ExceptionArgument argument);
    [DoesNotReturnAttribute]
public static void ThrowInvalidOperationException_AlreadyReading();
    public static Exception CreateInvalidOperationException_AlreadyReading();
    [DoesNotReturnAttribute]
public static void ThrowInvalidOperationException_NoReadToComplete();
    public static Exception CreateInvalidOperationException_NoReadToComplete();
    [DoesNotReturnAttribute]
public static void ThrowInvalidOperationException_NoConcurrentOperation();
    public static Exception CreateInvalidOperationException_NoConcurrentOperation();
    [DoesNotReturnAttribute]
public static void ThrowInvalidOperationException_GetResultNotCompleted();
    public static Exception CreateInvalidOperationException_GetResultNotCompleted();
    [DoesNotReturnAttribute]
public static void ThrowInvalidOperationException_NoWritingAllowed();
    public static Exception CreateInvalidOperationException_NoWritingAllowed();
    [DoesNotReturnAttribute]
public static void ThrowInvalidOperationException_NoReadingAllowed();
    public static Exception CreateInvalidOperationException_NoReadingAllowed();
    [DoesNotReturnAttribute]
public static void ThrowInvalidOperationException_InvalidExaminedPosition();
    public static Exception CreateInvalidOperationException_InvalidExaminedPosition();
    [DoesNotReturnAttribute]
public static void ThrowInvalidOperationException_InvalidExaminedOrConsumedPosition();
    public static Exception CreateInvalidOperationException_InvalidExaminedOrConsumedPosition();
    [DoesNotReturnAttribute]
public static void ThrowInvalidOperationException_AdvanceToInvalidCursor();
    public static Exception CreateInvalidOperationException_AdvanceToInvalidCursor();
    [DoesNotReturnAttribute]
public static void ThrowInvalidOperationException_ResetIncompleteReaderWriter();
    public static Exception CreateInvalidOperationException_ResetIncompleteReaderWriter();
    [DoesNotReturnAttribute]
public static void ThrowOperationCanceledException_ReadCanceled();
    public static Exception CreateOperationCanceledException_ReadCanceled();
    [DoesNotReturnAttribute]
public static void ThrowOperationCanceledException_FlushCanceled();
    public static Exception CreateOperationCanceledException_FlushCanceled();
    [DoesNotReturnAttribute]
public static void ThrowInvalidOperationException_InvalidZeroByteRead();
    public static Exception CreateInvalidOperationException_InvalidZeroByteRead();
}
[CompilerGeneratedAttribute]
[EmbeddedAttribute]
internal class System.Runtime.CompilerServices.IsReadOnlyAttribute : Attribute {
}
[CompilerGeneratedAttribute]
[EmbeddedAttribute]
[AttributeUsageAttribute("27524")]
internal class System.Runtime.CompilerServices.NullableAttribute : Attribute {
    public Byte[] NullableFlags;
    public NullableAttribute(byte );
    public NullableAttribute(Byte[] );
}
[CompilerGeneratedAttribute]
[EmbeddedAttribute]
[AttributeUsageAttribute("5196")]
internal class System.Runtime.CompilerServices.NullableContextAttribute : Attribute {
    public byte Flag;
    public NullableContextAttribute(byte );
}
[CompilerGeneratedAttribute]
[EmbeddedAttribute]
[AttributeUsageAttribute("2")]
internal class System.Runtime.CompilerServices.NullablePublicOnlyAttribute : Attribute {
    public bool IncludesInternals;
    public NullablePublicOnlyAttribute(bool );
}
internal static class System.SR : object {
    private static bool s_usingResourceKeys;
    private static ResourceManager s_resourceManager;
    internal static ResourceManager ResourceManager { get; }
    internal static string AdvanceToInvalidCursor { get; }
    internal static string ConcurrentOperationsNotSupported { get; }
    internal static string FlushCanceledOnPipeWriter { get; }
    internal static string GetResultBeforeCompleted { get; }
    internal static string InvalidExaminedOrConsumedPosition { get; }
    internal static string InvalidExaminedPosition { get; }
    internal static string InvalidZeroByteRead { get; }
    internal static string NoReadingOperationToComplete { get; }
    internal static string ReadCanceledOnPipeReader { get; }
    internal static string ReaderAndWriterHasToBeCompleted { get; }
    internal static string ReadingAfterCompleted { get; }
    internal static string ReadingIsInProgress { get; }
    internal static string WritingAfterCompleted { get; }
    private static SR();
    private static bool UsingResourceKeys();
    [NullableContextAttribute("1")]
internal static string GetResourceString(string resourceKey, string defaultString);
    [NullableContextAttribute("1")]
internal static string Format(string resourceFormat, object p1);
    [NullableContextAttribute("1")]
internal static string Format(string resourceFormat, object p1, object p2);
    [NullableContextAttribute("2")]
internal static string Format(string resourceFormat, object p1, object p2, object p3);
    [NullableContextAttribute("1")]
internal static string Format(string resourceFormat, Object[] args);
    [NullableContextAttribute("1")]
internal static string Format(IFormatProvider provider, string resourceFormat, object p1);
    [NullableContextAttribute("2")]
internal static string Format(IFormatProvider provider, string resourceFormat, object p1, object p2);
    [NullableContextAttribute("2")]
internal static string Format(IFormatProvider provider, string resourceFormat, object p1, object p2, object p3);
    [NullableContextAttribute("1")]
internal static string Format(IFormatProvider provider, string resourceFormat, Object[] args);
    internal static ResourceManager get_ResourceManager();
    internal static string get_AdvanceToInvalidCursor();
    internal static string get_ConcurrentOperationsNotSupported();
    internal static string get_FlushCanceledOnPipeWriter();
    internal static string get_GetResultBeforeCompleted();
    internal static string get_InvalidExaminedOrConsumedPosition();
    internal static string get_InvalidExaminedPosition();
    internal static string get_InvalidZeroByteRead();
    internal static string get_NoReadingOperationToComplete();
    internal static string get_ReadCanceledOnPipeReader();
    internal static string get_ReaderAndWriterHasToBeCompleted();
    internal static string get_ReadingAfterCompleted();
    internal static string get_ReadingIsInProgress();
    internal static string get_WritingAfterCompleted();
}
[ExtensionAttribute]
internal static class System.Threading.CancellationTokenExtensions : object {
    [NullableContextAttribute("1")]
[ExtensionAttribute]
internal static CancellationTokenRegistration UnsafeRegister(CancellationToken cancellationToken, Action`1<object> callback, object state);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal static class System.Threading.Tasks.TaskToApm : object {
    public static IAsyncResult Begin(Task task, AsyncCallback callback, object state);
    public static void End(IAsyncResult asyncResult);
    public static TResult End(IAsyncResult asyncResult);
    [DoesNotReturnAttribute]
private static void ThrowArgumentException(IAsyncResult asyncResult);
}
