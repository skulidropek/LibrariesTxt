[CompilerGeneratedAttribute]
[EmbeddedAttribute]
internal class Microsoft.CodeAnalysis.EmbeddedAttribute : Attribute {
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class System.CommandLine.Argument : Symbol {
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private Func`2<ArgumentResult, object> _defaultValueFactory;
    [NullableAttribute("2")]
private IArgumentArity _arity;
    [NullableAttribute("2")]
private TryConvertArgument _convertArguments;
    private Type _argumentType;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private List`1<ISuggestionSource> _suggestions;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private HashSet`1<string> <AllowedValues>k__BackingField;
    [CompilerGeneratedAttribute]
private List`1<ValidateSymbol`1<ArgumentResult>> <Validators>k__BackingField;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal HashSet`1<string> AllowedValues { get; private set; }
    public IArgumentArity Arity { get; public set; }
    [NullableAttribute("2")]
internal TryConvertArgument ConvertArguments { get; internal set; }
    public List`1<ISuggestionSource> Suggestions { get; }
    public Type ArgumentType { get; public set; }
    private protected string DefaultName { get; }
    internal List`1<ValidateSymbol`1<ArgumentResult>> Validators { get; }
    public bool HasDefaultValue { get; }
    internal static Argument None { get; }
    private IArgumentArity System.CommandLine.IArgument.Arity { get; }
    private string System.CommandLine.Binding.IValueDescriptor.ValueName { get; }
    private Type System.CommandLine.Binding.IValueDescriptor.ValueType { get; }
    public Argument(string name);
    [CompilerGeneratedAttribute]
internal HashSet`1<string> get_AllowedValues();
    [CompilerGeneratedAttribute]
private void set_AllowedValues(HashSet`1<string> value);
    public IArgumentArity get_Arity();
    public void set_Arity(IArgumentArity value);
    [NullableContextAttribute("2")]
internal TryConvertArgument get_ConvertArguments();
    [NullableContextAttribute("2")]
internal void set_ConvertArguments(TryConvertArgument value);
    public List`1<ISuggestionSource> get_Suggestions();
    public Type get_ArgumentType();
    public void set_ArgumentType(Type value);
    private protected virtual string get_DefaultName();
    [CompilerGeneratedAttribute]
internal List`1<ValidateSymbol`1<ArgumentResult>> get_Validators();
    public void AddValidator(ValidateSymbol`1<ArgumentResult> validator);
    [NullableContextAttribute("2")]
public sealed virtual object GetDefaultValue();
    internal object GetDefaultValue(ArgumentResult argumentResult);
    [NullableContextAttribute("2")]
public void SetDefaultValue(object value);
    public void SetDefaultValueFactory(Func`1<object> getDefaultValue);
    public void SetDefaultValueFactory(Func`2<ArgumentResult, object> getDefaultValue);
    public sealed virtual bool get_HasDefaultValue();
    internal static Argument get_None();
    internal void AddAllowedValues(IEnumerable`1<string> values);
    [NullableContextAttribute("2")]
public virtual IEnumerable`1<string> GetSuggestions(ParseResult parseResult, string textToMatch);
    public virtual string ToString();
    private sealed virtual override IArgumentArity System.CommandLine.IArgument.get_Arity();
    private sealed virtual override string System.CommandLine.Binding.IValueDescriptor.get_ValueName();
    private sealed virtual override Type System.CommandLine.Binding.IValueDescriptor.get_ValueType();
    [CompilerGeneratedAttribute]
private bool <get_ConvertArguments>b__15_0(ArgumentResult symbol, Object& value);
    [CompilerGeneratedAttribute]
private bool <get_ConvertArguments>g__DefaultConvert|15_1(SymbolResult symbol, Object& value);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class System.CommandLine.Argument`1 : Argument {
    public Argument`1(string name, string description);
    public Argument`1(string name, Func`1<T> getDefaultValue, string description);
    public Argument`1(Func`1<T> getDefaultValue);
    public Argument`1(string name, ParseArgument`1<T> parse, bool isDefault);
    public Argument`1(ParseArgument`1<T> parse, bool isDefault);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class System.CommandLine.ArgumentArity : object {
    public static int MaximumArity;
    [CompilerGeneratedAttribute]
private int <MinimumNumberOfValues>k__BackingField;
    [CompilerGeneratedAttribute]
private int <MaximumNumberOfValues>k__BackingField;
    public int MinimumNumberOfValues { get; }
    public int MaximumNumberOfValues { get; }
    public static IArgumentArity Zero { get; }
    public static IArgumentArity ZeroOrOne { get; }
    public static IArgumentArity ExactlyOne { get; }
    public static IArgumentArity ZeroOrMore { get; }
    public static IArgumentArity OneOrMore { get; }
    public ArgumentArity(int minimumNumberOfValues, int maximumNumberOfValues);
    [CompilerGeneratedAttribute]
public sealed virtual int get_MinimumNumberOfValues();
    [CompilerGeneratedAttribute]
public sealed virtual int get_MaximumNumberOfValues();
    internal static FailedArgumentConversionArityResult Validate(SymbolResult symbolResult, IArgument argument, int minimumNumberOfValues, int maximumNumberOfValues);
    public static IArgumentArity get_Zero();
    public static IArgumentArity get_ZeroOrOne();
    public static IArgumentArity get_ExactlyOne();
    public static IArgumentArity get_ZeroOrMore();
    public static IArgumentArity get_OneOrMore();
    internal static IArgumentArity Default(Type type, Argument argument, ISymbol parent);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
public static class System.CommandLine.ArgumentExtensions : object {
    [ExtensionAttribute]
public static TArgument AddSuggestions(TArgument argument, String[] values);
    [ExtensionAttribute]
public static TArgument AddSuggestions(TArgument argument, SuggestDelegate suggest);
    [ExtensionAttribute]
public static TArgument FromAmong(TArgument argument, String[] values);
    [ExtensionAttribute]
public static Argument`1<FileInfo> ExistingOnly(Argument`1<FileInfo> argument);
    [ExtensionAttribute]
public static Argument`1<DirectoryInfo> ExistingOnly(Argument`1<DirectoryInfo> argument);
    [ExtensionAttribute]
public static Argument`1<FileSystemInfo> ExistingOnly(Argument`1<FileSystemInfo> argument);
    [ExtensionAttribute]
public static Argument`1<T> ExistingOnly(Argument`1<T> argument);
    [ExtensionAttribute]
public static TArgument LegalFilePathsOnly(TArgument argument);
    [ExtensionAttribute]
public static ParseResult Parse(Argument argument, string commandLine);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class System.CommandLine.Binding.AnonymousConsoleFactory : object {
    private Func`2<BindingContext, IConsole> _create;
    public AnonymousConsoleFactory(Func`2<BindingContext, IConsole> create);
    public sealed virtual IConsole CreateConsole(BindingContext context);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal abstract class System.CommandLine.Binding.ArgumentConversionResult : object {
    [CompilerGeneratedAttribute]
private IArgument <Argument>k__BackingField;
    [NullableAttribute("2")]
[CompilerGeneratedAttribute]
private string <ErrorMessage>k__BackingField;
    public IArgument Argument { get; }
    [NullableAttribute("2")]
internal string ErrorMessage { get; internal set; }
    private protected ArgumentConversionResult(IArgument argument);
    [CompilerGeneratedAttribute]
public IArgument get_Argument();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
internal string get_ErrorMessage();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
internal void set_ErrorMessage(string value);
    internal static FailedArgumentConversionResult Failure(IArgument argument, string error);
    public static SuccessfulArgumentConversionResult Success(IArgument argument, object value);
    internal static NoArgumentConversionResult None(IArgument argument);
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal class System.CommandLine.Binding.ArgumentConversionResultSet : AliasedSet`1<ArgumentConversionResult> {
    protected virtual IReadOnlyCollection`1<string> GetAliases(ArgumentConversionResult item);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
internal static class System.CommandLine.Binding.ArgumentConverter : object {
    private static Dictionary`2<Type, Func`2<string, object>> _converters;
    private static ArgumentConverter();
    internal static ArgumentConversionResult ConvertObject(IArgument argument, Type type, object value);
    private static ArgumentConversionResult ConvertString(IArgument argument, Type type, string value);
    public static ArgumentConversionResult ConvertStrings(IArgument argument, Type type, IReadOnlyCollection`1<string> arguments);
    private static Type GetItemTypeIfEnumerable(Type type);
    [ExtensionAttribute]
internal static bool IsEnumerable(Type type);
    [ExtensionAttribute]
private static bool HasStringTypeConverter(Type type);
    private static FailedArgumentConversionResult Failure(IArgument argument, Type type, string value);
    [ExtensionAttribute]
public static bool CanBeBoundFromScalarValue(Type type);
    [ExtensionAttribute]
private static bool TryFindConstructorWithSingleParameterOfType(Type type, Type parameterType, ConstructorInfo& ctor);
    [ExtensionAttribute]
internal static ArgumentConversionResult ConvertIfNeeded(ArgumentConversionResult conversionResult, SymbolResult symbolResult, Type toType);
    [ExtensionAttribute]
internal static object GetValueOrDefault(ArgumentConversionResult result);
    [ExtensionAttribute]
internal static T GetValueOrDefault(ArgumentConversionResult result);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
internal static class System.CommandLine.Binding.Binder : object {
    [ExtensionAttribute]
internal static bool IsMatch(string parameterName, string alias);
    [ExtensionAttribute]
internal static bool IsMatch(string parameterName, ISymbol symbol);
    [ExtensionAttribute]
internal static bool IsNullable(Type t);
    [ExtensionAttribute]
public static object GetDefaultValueForType(Type type);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class System.CommandLine.Binding.BindingContext : object {
    private IConsole _console;
    private Dictionary`2<Type, ModelBinder> _modelBindersByValueDescriptor;
    [CompilerGeneratedAttribute]
private ParseResult <ParseResult>k__BackingField;
    [NullableAttribute("2")]
[CompilerGeneratedAttribute]
private IConsoleFactory <ConsoleFactory>k__BackingField;
    [CompilerGeneratedAttribute]
private ServiceProvider <ServiceProvider>k__BackingField;
    public ParseResult ParseResult { get; public set; }
    [NullableAttribute("2")]
internal IConsoleFactory ConsoleFactory { get; internal set; }
    internal IHelpBuilder HelpBuilder { get; }
    public IConsole Console { get; }
    internal ServiceProvider ServiceProvider { get; }
    public BindingContext(ParseResult parseResult, IConsole console);
    [CompilerGeneratedAttribute]
public ParseResult get_ParseResult();
    [CompilerGeneratedAttribute]
public void set_ParseResult(ParseResult value);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
internal IConsoleFactory get_ConsoleFactory();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
internal void set_ConsoleFactory(IConsoleFactory value);
    internal IHelpBuilder get_HelpBuilder();
    public IConsole get_Console();
    [CompilerGeneratedAttribute]
internal ServiceProvider get_ServiceProvider();
    public void AddModelBinder(ModelBinder binder);
    public ModelBinder GetModelBinder(IValueDescriptor valueDescriptor);
    public void AddService(Type serviceType, Func`2<IServiceProvider, object> factory);
    public void AddService(Func`2<IServiceProvider, T> factory);
    internal bool TryGetValueSource(IValueDescriptor valueDescriptor, IValueSource& valueSource);
    internal bool TryBindToScalarValue(IValueDescriptor valueDescriptor, IValueSource valueSource, BoundValue& boundValue);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class System.CommandLine.Binding.BoundValue : object {
    [CompilerGeneratedAttribute]
private IValueDescriptor <ValueDescriptor>k__BackingField;
    [CompilerGeneratedAttribute]
private IValueSource <ValueSource>k__BackingField;
    [NullableAttribute("2")]
[CompilerGeneratedAttribute]
private object <Value>k__BackingField;
    public IValueDescriptor ValueDescriptor { get; }
    public IValueSource ValueSource { get; }
    [NullableAttribute("2")]
public object Value { get; }
    internal BoundValue(object value, IValueDescriptor valueDescriptor, IValueSource valueSource);
    [CompilerGeneratedAttribute]
public IValueDescriptor get_ValueDescriptor();
    [CompilerGeneratedAttribute]
public IValueSource get_ValueSource();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public virtual object get_Value();
    public virtual string ToString();
    public static BoundValue DefaultForType(IValueDescriptor valueDescriptor);
    public static BoundValue DefaultForValueDescriptor(IValueDescriptor valueDescriptor);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
internal class System.CommandLine.Binding.ConstructorAndArgs : object {
    [CompilerGeneratedAttribute]
private ConstructorDescriptor <Constructor>k__BackingField;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private IReadOnlyList`1<BoundValue> <BoundValues>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <NonDefaultsUsed>k__BackingField;
    public ConstructorDescriptor Constructor { get; }
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public IReadOnlyList`1<BoundValue> BoundValues { get; }
    public bool NonDefaultsUsed { get; }
    public ConstructorAndArgs(ConstructorDescriptor constructor, IReadOnlyList`1<BoundValue> boundValues, bool nonDefaultsUsed);
    [CompilerGeneratedAttribute]
public ConstructorDescriptor get_Constructor();
    [CompilerGeneratedAttribute]
public IReadOnlyList`1<BoundValue> get_BoundValues();
    [CompilerGeneratedAttribute]
public bool get_NonDefaultsUsed();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class System.CommandLine.Binding.ConstructorDescriptor : object {
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private List`1<ParameterDescriptor> _parameterDescriptors;
    private ConstructorInfo _constructorInfo;
    [CompilerGeneratedAttribute]
private ModelDescriptor <Parent>k__BackingField;
    public ModelDescriptor Parent { get; }
    public IReadOnlyList`1<ParameterDescriptor> ParameterDescriptors { get; }
    internal ConstructorDescriptor(ConstructorInfo constructorInfo, ModelDescriptor parent);
    [CompilerGeneratedAttribute]
public sealed virtual ModelDescriptor get_Parent();
    public sealed virtual IReadOnlyList`1<ParameterDescriptor> get_ParameterDescriptors();
    internal object Invoke(IReadOnlyCollection`1<object> parameters);
    public virtual string ToString();
    [NullableContextAttribute("0")]
[CompilerGeneratedAttribute]
private ParameterDescriptor <get_ParameterDescriptors>b__7_0(ParameterInfo p);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class System.CommandLine.Binding.DelegateHandlerDescriptor : HandlerDescriptor {
    private Delegate _handlerDelegate;
    [NullableAttribute("2")]
public ModelDescriptor Parent { get; }
    public DelegateHandlerDescriptor(Delegate handlerDelegate);
    public virtual ICommandHandler GetCommandHandler();
    [NullableContextAttribute("2")]
public virtual ModelDescriptor get_Parent();
    protected virtual IEnumerable`1<ParameterDescriptor> InitializeParameterDescriptors();
    [NullableContextAttribute("0")]
[CompilerGeneratedAttribute]
private ParameterDescriptor <InitializeParameterDescriptors>b__5_0(ParameterInfo p);
}
internal class System.CommandLine.Binding.DelegateValueSource : object {
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private Func`2<BindingContext, object> _getValue;
    public DelegateValueSource(Func`2<BindingContext, object> getValue);
    [NullableContextAttribute("2")]
public sealed virtual bool TryGetValue(IValueDescriptor valueDescriptor, BindingContext bindingContext, Object& boundValue);
}
[ExtensionAttribute]
internal static class System.CommandLine.Binding.ExpressionExtensions : object {
    [NullableContextAttribute("2")]
[ExtensionAttribute]
internal static ValueTuple`2<Type, string> MemberTypeAndName(Expression`1<Func`2<T, TValue>> expression);
    [NullableContextAttribute("1")]
[ExtensionAttribute]
internal static Type ReturnType(MemberInfo memberInfo);
    [NullableContextAttribute("1")]
[CompilerGeneratedAttribute]
internal static ValueTuple`2<Type, string> <MemberTypeAndName>g__TypeAndName|0_0(MemberExpression memberExpression);
}
internal abstract class System.CommandLine.Binding.FailedArgumentConversionArityResult : FailedArgumentConversionResult {
    [NullableContextAttribute("1")]
internal FailedArgumentConversionArityResult(IArgument argument, string errorMessage);
}
internal class System.CommandLine.Binding.FailedArgumentConversionResult : ArgumentConversionResult {
    [NullableContextAttribute("1")]
internal FailedArgumentConversionResult(IArgument argument, string errorMessage);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class System.CommandLine.Binding.FailedArgumentTypeConversionResult : FailedArgumentConversionResult {
    internal FailedArgumentTypeConversionResult(IArgument argument, Type type, string value);
    private static string FormatErrorMessage(IArgument argument, Type type, string value);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public abstract class System.CommandLine.Binding.HandlerDescriptor : object {
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private List`1<ParameterDescriptor> _parameterDescriptors;
    [NullableAttribute("2")]
public ModelDescriptor Parent { get; }
    public IReadOnlyList`1<ParameterDescriptor> ParameterDescriptors { get; }
    public abstract virtual ICommandHandler GetCommandHandler();
    [NullableContextAttribute("2")]
public abstract virtual ModelDescriptor get_Parent();
    public sealed virtual IReadOnlyList`1<ParameterDescriptor> get_ParameterDescriptors();
    protected abstract virtual IEnumerable`1<ParameterDescriptor> InitializeParameterDescriptors();
    public virtual string ToString();
    public static HandlerDescriptor FromMethodInfo(MethodInfo methodInfo, object target);
    public static HandlerDescriptor FromDelegate(Delegate delegate);
}
[NullableContextAttribute("1")]
internal interface System.CommandLine.Binding.IConsoleFactory {
    public abstract virtual IConsole CreateConsole(BindingContext invocationContext);
}
[NullableContextAttribute("1")]
public interface System.CommandLine.Binding.IMethodDescriptor {
    [NullableAttribute("2")]
public ModelDescriptor Parent { get; }
    public IReadOnlyList`1<ParameterDescriptor> ParameterDescriptors { get; }
    [NullableContextAttribute("2")]
public abstract virtual ModelDescriptor get_Parent();
    public abstract virtual IReadOnlyList`1<ParameterDescriptor> get_ParameterDescriptors();
}
[NullableContextAttribute("1")]
public interface System.CommandLine.Binding.IValueDescriptor {
    public string ValueName { get; }
    public Type ValueType { get; }
    public bool HasDefaultValue { get; }
    public abstract virtual string get_ValueName();
    public abstract virtual Type get_ValueType();
    public abstract virtual bool get_HasDefaultValue();
    [NullableContextAttribute("2")]
public abstract virtual object GetDefaultValue();
}
[NullableContextAttribute("2")]
public interface System.CommandLine.Binding.IValueSource {
    public abstract virtual bool TryGetValue(IValueDescriptor valueDescriptor, BindingContext bindingContext, Object& boundValue);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class System.CommandLine.Binding.MethodInfoHandlerDescriptor : HandlerDescriptor {
    private MethodInfo _handlerMethodInfo;
    [NullableAttribute("2")]
private object _invocationTarget;
    public ModelDescriptor Parent { get; }
    public MethodInfoHandlerDescriptor(MethodInfo handlerMethodInfo, object target);
    public virtual ICommandHandler GetCommandHandler();
    public virtual ModelDescriptor get_Parent();
    protected virtual IEnumerable`1<ParameterDescriptor> InitializeParameterDescriptors();
    [NullableContextAttribute("0")]
[CompilerGeneratedAttribute]
private ParameterDescriptor <InitializeParameterDescriptors>b__6_0(ParameterInfo p);
}
internal class System.CommandLine.Binding.MissingArgumentConversionResult : FailedArgumentConversionArityResult {
    [NullableContextAttribute("1")]
internal MissingArgumentConversionResult(IArgument argument, string errorMessage);
}
internal class System.CommandLine.Binding.MissingValueSource : object {
    [NullableContextAttribute("2")]
public sealed virtual bool TryGetValue(IValueDescriptor valueDescriptor, BindingContext bindingContext, Object& boundValue);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class System.CommandLine.Binding.ModelBinder : object {
    [CompilerGeneratedAttribute]
private IValueDescriptor <ValueDescriptor>k__BackingField;
    [CompilerGeneratedAttribute]
private ModelDescriptor <ModelDescriptor>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <EnforceExplicitBinding>k__BackingField;
    [CompilerGeneratedAttribute]
private Dictionary`2<IValueDescriptor, IValueSource> <ConstructorArgumentBindingSources>k__BackingField;
    [CompilerGeneratedAttribute]
private Dictionary`2<IValueDescriptor, IValueSource> <MemberBindingSources>k__BackingField;
    public IValueDescriptor ValueDescriptor { get; }
    public ModelDescriptor ModelDescriptor { get; }
    public bool EnforceExplicitBinding { get; public set; }
    internal Dictionary`2<IValueDescriptor, IValueSource> ConstructorArgumentBindingSources { get; }
    internal Dictionary`2<IValueDescriptor, IValueSource> MemberBindingSources { get; }
    public ModelBinder(Type modelType);
    internal ModelBinder(IValueDescriptor valueDescriptor);
    [CompilerGeneratedAttribute]
public IValueDescriptor get_ValueDescriptor();
    [CompilerGeneratedAttribute]
public ModelDescriptor get_ModelDescriptor();
    [CompilerGeneratedAttribute]
public bool get_EnforceExplicitBinding();
    [CompilerGeneratedAttribute]
public void set_EnforceExplicitBinding(bool value);
    [CompilerGeneratedAttribute]
internal Dictionary`2<IValueDescriptor, IValueSource> get_ConstructorArgumentBindingSources();
    [CompilerGeneratedAttribute]
internal Dictionary`2<IValueDescriptor, IValueSource> get_MemberBindingSources();
    public void BindConstructorArgumentFromValue(ParameterInfo parameter, IValueDescriptor valueDescriptor);
    public void BindMemberFromValue(PropertyInfo property, IValueDescriptor valueDescriptor);
    public object CreateInstance(BindingContext bindingContext);
    private ValueTuple`3<bool, object, bool> CreateInstanceInternal(BindingContext bindingContext);
    private bool DisallowedBindingType();
    private bool ShortCutTheBinding(BindingContext bindingContext);
    private ValueTuple`3<bool, object, bool> GetSimpleModelValue(IDictionary`2<IValueDescriptor, IValueSource> bindingSources, BindingContext bindingContext);
    private ValueTuple`3<bool, object, bool> InstanceFromSpecificConstructor(BindingContext bindingContext, ConstructorDescriptor constructor, IReadOnlyList`1<BoundValue> boundValues, Boolean& nonDefaultsUsed);
    public void UpdateInstance(T instance, BindingContext bindingContext);
    private bool UpdateInstanceInternalNotifyIfNonDefaultsUsed(T instance, BindingContext bindingContext);
    private ConstructorAndArgs GetBestConstructorAndArgs(BindingContext bindingContext);
    internal static ValueTuple`2<IReadOnlyList`1<BoundValue>, bool> GetBoundValues(IDictionary`2<IValueDescriptor, IValueSource> bindingSources, BindingContext bindingContext, IReadOnlyList`1<IValueDescriptor> valueDescriptors, bool enforceExplicitBinding, Type parentType, bool includeMissingValues);
    internal static IValueSource GetValueSource(IDictionary`2<IValueDescriptor, IValueSource> bindingSources, BindingContext bindingContext, IValueDescriptor valueDescriptor, bool enforceExplicitBinding);
    internal static ValueTuple`2<BoundValue, bool> GetBoundValue(IValueSource valueSource, BindingContext bindingContext, IValueDescriptor valueDescriptor, bool includeMissingValues, Type parentType);
    protected ConstructorDescriptor FindModelConstructorDescriptor(ConstructorInfo constructorInfo);
    protected IValueDescriptor FindModelPropertyDescriptor(Type propertyType, string propertyName);
    private ConstructorInfo FindConstructorOrThrow(ParameterInfo parameter, string message);
    [CompilerGeneratedAttribute]
internal static bool <ShortCutTheBinding>g__IsNullable|23_0(Type type);
    [CompilerGeneratedAttribute]
internal static bool <FindModelConstructorDescriptor>g__MatchParameter|32_1(ParameterDescriptor desc, ParameterInfo info);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class System.CommandLine.Binding.ModelBinder`1 : ModelBinder {
    public void BindMemberFromValue(Expression`1<Func`2<TModel, TValue>> property, IValueDescriptor valueDescriptor);
    public void BindMemberFromValue(Expression`1<Func`2<TModel, TValue>> property, Func`2<BindingContext, TValue> getValue);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class System.CommandLine.Binding.ModelDescriptor : object {
    private static BindingFlags CommonBindingFlags;
    private static ConcurrentDictionary`2<Type, ModelDescriptor> _modelDescriptors;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private List`1<PropertyDescriptor> _propertyDescriptors;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private List`1<ConstructorDescriptor> _constructorDescriptors;
    [CompilerGeneratedAttribute]
private Type <ModelType>k__BackingField;
    public IReadOnlyList`1<ConstructorDescriptor> ConstructorDescriptors { get; }
    public IReadOnlyList`1<IValueDescriptor> PropertyDescriptors { get; }
    public Type ModelType { get; }
    protected ModelDescriptor(Type modelType);
    private static ModelDescriptor();
    public IReadOnlyList`1<ConstructorDescriptor> get_ConstructorDescriptors();
    public IReadOnlyList`1<IValueDescriptor> get_PropertyDescriptors();
    [CompilerGeneratedAttribute]
public Type get_ModelType();
    public virtual string ToString();
    public static ModelDescriptor FromType();
    public static ModelDescriptor FromType(Type type);
    [NullableContextAttribute("0")]
[CompilerGeneratedAttribute]
private ConstructorDescriptor <get_ConstructorDescriptors>b__6_0(ConstructorInfo i);
    [NullableContextAttribute("0")]
[CompilerGeneratedAttribute]
private PropertyDescriptor <get_PropertyDescriptors>b__8_1(PropertyInfo i);
}
internal class System.CommandLine.Binding.NoArgumentConversionResult : ArgumentConversionResult {
    [NullableContextAttribute("1")]
internal NoArgumentConversionResult(IArgument argument);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class System.CommandLine.Binding.ParameterDescriptor : object {
    private ParameterInfo _parameterInfo;
    private Nullable`1<bool> _allowsNull;
    [CompilerGeneratedAttribute]
private IMethodDescriptor <Parent>k__BackingField;
    public string ValueName { get; }
    public IMethodDescriptor Parent { get; }
    public Type ValueType { get; }
    public bool HasDefaultValue { get; }
    public bool AllowsNull { get; }
    internal ParameterDescriptor(ParameterInfo parameterInfo, IMethodDescriptor parent);
    public sealed virtual string get_ValueName();
    [CompilerGeneratedAttribute]
public IMethodDescriptor get_Parent();
    public sealed virtual Type get_ValueType();
    public sealed virtual bool get_HasDefaultValue();
    public bool get_AllowsNull();
    public static bool CalculateAllowsNull(ParameterInfo parameterInfo);
    [NullableContextAttribute("2")]
public sealed virtual object GetDefaultValue();
    public virtual string ToString();
}
internal class System.CommandLine.Binding.ParseResultMatchingValueSource : object {
    [NullableContextAttribute("2")]
public sealed virtual bool TryGetValue(IValueDescriptor valueDescriptor, BindingContext bindingContext, Object& boundValue);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class System.CommandLine.Binding.PropertyDescriptor : object {
    private PropertyInfo _propertyInfo;
    [CompilerGeneratedAttribute]
private ModelDescriptor <Parent>k__BackingField;
    public string ValueName { get; }
    public ModelDescriptor Parent { get; }
    internal string Path { get; }
    public Type ValueType { get; }
    public bool HasDefaultValue { get; }
    internal PropertyDescriptor(PropertyInfo propertyInfo, ModelDescriptor parent);
    public sealed virtual string get_ValueName();
    [CompilerGeneratedAttribute]
public ModelDescriptor get_Parent();
    internal string get_Path();
    public sealed virtual Type get_ValueType();
    public sealed virtual bool get_HasDefaultValue();
    [NullableContextAttribute("2")]
public sealed virtual object GetDefaultValue();
    [NullableContextAttribute("2")]
public void SetValue(object instance, object value);
    public virtual string ToString();
}
internal class System.CommandLine.Binding.ServiceProviderValueSource : object {
    [NullableContextAttribute("2")]
public sealed virtual bool TryGetValue(IValueDescriptor valueDescriptor, BindingContext bindingContext, Object& boundValue);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class System.CommandLine.Binding.SpecificSymbolValueSource : object {
    [CompilerGeneratedAttribute]
private IValueDescriptor <ValueDescriptor>k__BackingField;
    public IValueDescriptor ValueDescriptor { get; }
    public SpecificSymbolValueSource(IValueDescriptor valueDescriptor);
    [CompilerGeneratedAttribute]
public IValueDescriptor get_ValueDescriptor();
    [NullableContextAttribute("2")]
public sealed virtual bool TryGetValue(IValueDescriptor valueDescriptor, BindingContext bindingContext, Object& boundValue);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
internal class System.CommandLine.Binding.SuccessfulArgumentConversionResult : ArgumentConversionResult {
    [CompilerGeneratedAttribute]
private object <Value>k__BackingField;
    public object Value { get; }
    [NullableContextAttribute("1")]
internal SuccessfulArgumentConversionResult(IArgument argument, object value);
    [CompilerGeneratedAttribute]
public object get_Value();
}
internal class System.CommandLine.Binding.TooManyArgumentsConversionResult : FailedArgumentConversionArityResult {
    [NullableContextAttribute("1")]
internal TooManyArgumentsConversionResult(IArgument argument, string errorMessage);
}
internal class System.CommandLine.Binding.TryConvertArgument : MulticastDelegate {
    public TryConvertArgument(object object, IntPtr method);
    [NullableContextAttribute("1")]
public virtual bool Invoke(ArgumentResult argumentResult, Object& value);
    public virtual IAsyncResult BeginInvoke(ArgumentResult argumentResult, Object& value, AsyncCallback callback, object object);
    public virtual bool EndInvoke(Object& value, IAsyncResult result);
}
internal class System.CommandLine.Binding.TypeDefaultValueSource : object {
    [NullableAttribute("1")]
public static IValueSource Instance;
    private static TypeDefaultValueSource();
    [NullableContextAttribute("2")]
public sealed virtual bool TryGetValue(IValueDescriptor valueDescriptor, BindingContext bindingContext, Object& boundValue);
}
internal class System.CommandLine.Binding.ValueDescriptorDefaultValueSource : object {
    [NullableAttribute("1")]
public static IValueSource Instance;
    private static ValueDescriptorDefaultValueSource();
    [NullableContextAttribute("2")]
public sealed virtual bool TryGetValue(IValueDescriptor valueDescriptor, BindingContext bindingContext, Object& boundValue);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class System.CommandLine.Builder.CommandBuilder : object {
    [CompilerGeneratedAttribute]
private Command <Command>k__BackingField;
    public Command Command { get; }
    public IEnumerable`1<Option> Options { get; }
    public CommandBuilder(Command command);
    [CompilerGeneratedAttribute]
public Command get_Command();
    public IEnumerable`1<Option> get_Options();
    internal void AddCommand(Command command);
    internal void AddOption(Option option);
    internal void AddGlobalOption(Option option);
    internal void AddArgument(Argument argument);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
public class System.CommandLine.Builder.CommandLineBuilder : CommandBuilder {
    [TupleElementNamesAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private List`1<ValueTuple`2<InvocationMiddleware, int>> _middlewareList;
    [CompilerGeneratedAttribute]
private bool <EnableDirectives>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <EnablePosixBundling>k__BackingField;
    [CompilerGeneratedAttribute]
private ResponseFileHandling <ResponseFileHandling>k__BackingField;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private Func`2<BindingContext, IHelpBuilder> <HelpBuilderFactory>k__BackingField;
    [CompilerGeneratedAttribute]
private HelpOption <HelpOption>k__BackingField;
    [CompilerGeneratedAttribute]
private ValidationMessages <ValidationMessages>k__BackingField;
    public bool EnableDirectives { get; public set; }
    public bool EnablePosixBundling { get; public set; }
    public ResponseFileHandling ResponseFileHandling { get; public set; }
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal Func`2<BindingContext, IHelpBuilder> HelpBuilderFactory { get; internal set; }
    internal HelpOption HelpOption { get; internal set; }
    internal ValidationMessages ValidationMessages { get; internal set; }
    public CommandLineBuilder(Command rootCommand);
    [CompilerGeneratedAttribute]
public bool get_EnableDirectives();
    [CompilerGeneratedAttribute]
public void set_EnableDirectives(bool value);
    [CompilerGeneratedAttribute]
public bool get_EnablePosixBundling();
    [CompilerGeneratedAttribute]
public void set_EnablePosixBundling(bool value);
    [CompilerGeneratedAttribute]
public ResponseFileHandling get_ResponseFileHandling();
    [CompilerGeneratedAttribute]
public void set_ResponseFileHandling(ResponseFileHandling value);
    [CompilerGeneratedAttribute]
internal Func`2<BindingContext, IHelpBuilder> get_HelpBuilderFactory();
    [CompilerGeneratedAttribute]
internal void set_HelpBuilderFactory(Func`2<BindingContext, IHelpBuilder> value);
    [CompilerGeneratedAttribute]
internal HelpOption get_HelpOption();
    [CompilerGeneratedAttribute]
internal void set_HelpOption(HelpOption value);
    [CompilerGeneratedAttribute]
internal ValidationMessages get_ValidationMessages();
    [CompilerGeneratedAttribute]
internal void set_ValidationMessages(ValidationMessages value);
    [NullableContextAttribute("1")]
public Parser Build();
    [NullableContextAttribute("1")]
internal void AddMiddleware(InvocationMiddleware middleware, MiddlewareOrder order);
    [NullableContextAttribute("1")]
internal void AddMiddleware(InvocationMiddleware middleware, MiddlewareOrderInternal order);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
public static class System.CommandLine.Builder.CommandLineBuilderExtensions : object {
    private static Lazy`1<string> _assemblyVersion;
    private static CommandLineBuilderExtensions();
    [ExtensionAttribute]
public static TBuilder AddArgument(TBuilder builder, Argument argument);
    [ExtensionAttribute]
public static TBuilder AddCommand(TBuilder builder, Command command);
    [ExtensionAttribute]
public static TBuilder AddOption(TBuilder builder, Option option);
    [ExtensionAttribute]
public static TBuilder AddGlobalOption(TBuilder builder, Option option);
    [ExtensionAttribute]
public static CommandLineBuilder CancelOnProcessTermination(CommandLineBuilder builder);
    [ExtensionAttribute]
public static CommandLineBuilder ConfigureConsole(CommandLineBuilder builder, Func`2<BindingContext, IConsole> createConsole);
    [ExtensionAttribute]
public static CommandLineBuilder EnableDirectives(CommandLineBuilder builder, bool value);
    [ExtensionAttribute]
public static CommandLineBuilder EnablePosixBundling(CommandLineBuilder builder, bool value);
    [ExtensionAttribute]
public static CommandLineBuilder ParseResponseFileAs(CommandLineBuilder builder, ResponseFileHandling responseFileHandling);
    [ExtensionAttribute]
public static CommandLineBuilder RegisterWithDotnetSuggest(CommandLineBuilder builder);
    [ExtensionAttribute]
public static CommandLineBuilder UseDebugDirective(CommandLineBuilder builder);
    [ExtensionAttribute]
public static CommandLineBuilder UseEnvironmentVariableDirective(CommandLineBuilder builder);
    [ExtensionAttribute]
public static CommandLineBuilder UseDefaults(CommandLineBuilder builder);
    [ExtensionAttribute]
public static CommandLineBuilder UseExceptionHandler(CommandLineBuilder builder, Action`2<Exception, InvocationContext> onException);
    [ExtensionAttribute]
public static CommandLineBuilder UseHelp(CommandLineBuilder builder);
    [ExtensionAttribute]
internal static CommandLineBuilder UseHelp(CommandLineBuilder builder, HelpOption helpOption);
    [ExtensionAttribute]
public static TBuilder UseHelpBuilder(TBuilder builder, Func`2<BindingContext, IHelpBuilder> getHelpBuilder);
    [ExtensionAttribute]
public static CommandLineBuilder UseMiddleware(CommandLineBuilder builder, InvocationMiddleware middleware, MiddlewareOrder order);
    [ExtensionAttribute]
public static CommandLineBuilder UseMiddleware(CommandLineBuilder builder, Action`1<InvocationContext> onInvoke, MiddlewareOrder order);
    [ExtensionAttribute]
public static CommandLineBuilder UseParseDirective(CommandLineBuilder builder);
    [ExtensionAttribute]
public static CommandLineBuilder UseParseErrorReporting(CommandLineBuilder builder);
    [ExtensionAttribute]
public static CommandLineBuilder UseSuggestDirective(CommandLineBuilder builder);
    [ExtensionAttribute]
public static CommandLineBuilder UseTypoCorrections(CommandLineBuilder builder, int maxLevenshteinDistance);
    [ExtensionAttribute]
public static CommandLineBuilder UseValidationMessages(CommandLineBuilder builder, ValidationMessages validationMessages);
    [ExtensionAttribute]
public static CommandLineBuilder UseVersionOption(CommandLineBuilder builder);
    private static bool ShowHelp(InvocationContext context, IOption helpOption);
    [CompilerGeneratedAttribute]
internal static void <UseExceptionHandler>g__Default|14_1(Exception exception, InvocationContext context);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[DefaultMemberAttribute("Item")]
public abstract class System.CommandLine.Collections.AliasedSet`1 : object {
    private protected Dictionary`2<string, T> ItemsByAlias;
    [CompilerGeneratedAttribute]
private List`1<T> <Items>k__BackingField;
    [CompilerGeneratedAttribute]
private HashSet`1<T> <DirtyItems>k__BackingField;
    private protected List`1<T> Items { get; }
    private protected HashSet`1<T> DirtyItems { get; }
    [NullableAttribute("2")]
public T Item { get; }
    public int Count { get; }
    public T Item { get; }
    [CompilerGeneratedAttribute]
private protected List`1<T> get_Items();
    [CompilerGeneratedAttribute]
private protected HashSet`1<T> get_DirtyItems();
    public T get_Item(string alias);
    public sealed virtual T GetByAlias(string alias);
    public sealed virtual int get_Count();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    public sealed virtual IEnumerator`1<T> GetEnumerator();
    internal virtual void Add(T item);
    internal virtual void Remove(T item);
    protected abstract virtual IReadOnlyCollection`1<string> GetAliases(T item);
    public bool Contains(string alias);
    public sealed virtual T get_Item(int index);
    private protected void EnsureAliasIndexIsCurrent();
}
public interface System.CommandLine.Collections.ISymbolSet {
    [NullableContextAttribute("1")]
public abstract virtual ISymbol GetByAlias(string alias);
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public class System.CommandLine.Collections.SymbolSet : AliasedSet`1<ISymbol> {
    internal virtual void Add(ISymbol item);
    internal virtual void Remove(ISymbol item);
    private void Resync(ISymbol symbol);
    internal void AddWithoutAliasCollisionCheck(ISymbol item);
    internal bool IsAnyAliasInUse(ISymbol item, String& aliasAlreadyInUse);
    internal void ThrowIfAnyAliasIsInUse(ISymbol item);
    protected virtual IReadOnlyCollection`1<string> GetAliases(ISymbol item);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class System.CommandLine.Command : Symbol {
    private SymbolSet _globalOptions;
    [CompilerGeneratedAttribute]
private List`1<ValidateSymbol`1<CommandResult>> <Validators>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <TreatUnmatchedTokensAsErrors>k__BackingField;
    [NullableAttribute("2")]
[CompilerGeneratedAttribute]
private ICommandHandler <Handler>k__BackingField;
    [NullableAttribute("2")]
[CompilerGeneratedAttribute]
private Parser <ImplicitParser>k__BackingField;
    public IEnumerable`1<Argument> Arguments { get; }
    public IEnumerable`1<Option> Options { get; }
    public IEnumerable`1<Option> GlobalOptions { get; }
    private protected string DefaultName { get; }
    internal List`1<ValidateSymbol`1<CommandResult>> Validators { get; }
    public bool TreatUnmatchedTokensAsErrors { get; public set; }
    [NullableAttribute("2")]
public ICommandHandler Handler { get; public set; }
    private IEnumerable`1<IArgument> System.CommandLine.ICommand.Arguments { get; }
    private IEnumerable`1<IOption> System.CommandLine.ICommand.Options { get; }
    [NullableAttribute("2")]
internal Parser ImplicitParser { get; internal set; }
    public Command(string name, string description);
    public IEnumerable`1<Argument> get_Arguments();
    public IEnumerable`1<Option> get_Options();
    public IEnumerable`1<Option> get_GlobalOptions();
    public void AddArgument(Argument argument);
    public void AddCommand(Command command);
    public void AddOption(Option option);
    public void AddGlobalOption(Option option);
    public bool TryAddGlobalOption(Option option);
    public void Add(Symbol symbol);
    public void Add(Argument argument);
    public virtual void AddAlias(string alias);
    private protected virtual void AddAliasInner(string alias);
    private protected virtual void AddSymbol(Symbol symbol);
    private protected virtual string get_DefaultName();
    [CompilerGeneratedAttribute]
internal List`1<ValidateSymbol`1<CommandResult>> get_Validators();
    public void AddValidator(ValidateSymbol`1<CommandResult> validate);
    [CompilerGeneratedAttribute]
public sealed virtual bool get_TreatUnmatchedTokensAsErrors();
    [CompilerGeneratedAttribute]
public void set_TreatUnmatchedTokensAsErrors(bool value);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public ICommandHandler get_Handler();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public void set_Handler(ICommandHandler value);
    public sealed virtual IEnumerator`1<Symbol> GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    private sealed virtual override IEnumerable`1<IArgument> System.CommandLine.ICommand.get_Arguments();
    private sealed virtual override IEnumerable`1<IOption> System.CommandLine.ICommand.get_Options();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
internal Parser get_ImplicitParser();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
internal void set_ImplicitParser(Parser value);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
public static class System.CommandLine.CommandExtensions : object {
    [ExtensionAttribute]
public static int Invoke(Command command, String[] args, IConsole console);
    [ExtensionAttribute]
public static int Invoke(Command command, string commandLine, IConsole console);
    [AsyncStateMachineAttribute("System.CommandLine.CommandExtensions/<InvokeAsync>d__2")]
[ExtensionAttribute]
public static Task`1<int> InvokeAsync(Command command, String[] args, IConsole console);
    [ExtensionAttribute]
public static Task`1<int> InvokeAsync(Command command, string commandLine, IConsole console);
    private static InvocationPipeline GetInvocationPipeline(Command command, String[] args);
    [ExtensionAttribute]
public static ParseResult Parse(Command command, String[] args);
    [ExtensionAttribute]
public static ParseResult Parse(Command command, string commandLine, IReadOnlyCollection`1<char> delimiters);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class System.CommandLine.CommandLineConfiguration : object {
    private IReadOnlyCollection`1<InvocationMiddleware> _middlewarePipeline;
    private Func`2<BindingContext, IHelpBuilder> _helpBuilderFactory;
    private SymbolSet _symbols;
    [CompilerGeneratedAttribute]
private HashSet`1<char> <ArgumentDelimitersInternal>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <EnableDirectives>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <EnablePosixBundling>k__BackingField;
    [CompilerGeneratedAttribute]
private ValidationMessages <ValidationMessages>k__BackingField;
    [CompilerGeneratedAttribute]
private ICommand <RootCommand>k__BackingField;
    [CompilerGeneratedAttribute]
private ResponseFileHandling <ResponseFileHandling>k__BackingField;
    public ISymbolSet Symbols { get; }
    public IReadOnlyCollection`1<char> ArgumentDelimiters { get; }
    internal HashSet`1<char> ArgumentDelimitersInternal { get; }
    public bool EnableDirectives { get; }
    public bool EnablePosixBundling { get; }
    public ValidationMessages ValidationMessages { get; }
    internal Func`2<BindingContext, IHelpBuilder> HelpBuilderFactory { get; }
    internal IReadOnlyCollection`1<InvocationMiddleware> Middleware { get; }
    public ICommand RootCommand { get; }
    internal ResponseFileHandling ResponseFileHandling { get; }
    [NullableContextAttribute("2")]
public CommandLineConfiguration(IReadOnlyCollection`1<Symbol> symbols, IReadOnlyCollection`1<char> argumentDelimiters, bool enablePosixBundling, bool enableDirectives, ValidationMessages validationMessages, ResponseFileHandling responseFileHandling, IReadOnlyCollection`1<InvocationMiddleware> middlewarePipeline, Func`2<BindingContext, IHelpBuilder> helpBuilderFactory);
    private void AddGlobalOptionsToChildren(Command parentCommand);
    public ISymbolSet get_Symbols();
    public IReadOnlyCollection`1<char> get_ArgumentDelimiters();
    [CompilerGeneratedAttribute]
internal HashSet`1<char> get_ArgumentDelimitersInternal();
    [CompilerGeneratedAttribute]
public bool get_EnableDirectives();
    [CompilerGeneratedAttribute]
public bool get_EnablePosixBundling();
    [CompilerGeneratedAttribute]
public ValidationMessages get_ValidationMessages();
    internal Func`2<BindingContext, IHelpBuilder> get_HelpBuilderFactory();
    internal IReadOnlyCollection`1<InvocationMiddleware> get_Middleware();
    [CompilerGeneratedAttribute]
public ICommand get_RootCommand();
    [CompilerGeneratedAttribute]
internal ResponseFileHandling get_ResponseFileHandling();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
internal static class System.CommandLine.DictionaryExtensions : object {
    [ExtensionAttribute]
public static TValue GetOrAdd(IDictionary`2<TKey, TValue> source, TKey key, Func`2<TKey, TValue> create);
    [ExtensionAttribute]
public static bool TryAdd(IDictionary`2<TKey, TValue> source, TKey key, TValue value);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class System.CommandLine.DirectiveCollection : object {
    private Dictionary`2<string, List`1<string>> _directives;
    public void Add(string name, string value);
    public sealed virtual bool Contains(string name);
    public sealed virtual bool TryGetValues(string name, IEnumerable`1& values);
    public sealed virtual IEnumerator`1<KeyValuePair`2<string, IEnumerable`1<string>>> GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
internal static class System.CommandLine.EnumerableExtensions : object {
    [IteratorStateMachineAttribute("System.CommandLine.EnumerableExtensions/<FlattenBreadthFirst>d__0`1")]
[ExtensionAttribute]
internal static IEnumerable`1<T> FlattenBreadthFirst(IEnumerable`1<T> source, Func`2<T, IEnumerable`1<T>> children);
    [IteratorStateMachineAttribute("System.CommandLine.EnumerableExtensions/<RecurseWhileNotNull>d__1`1")]
[ExtensionAttribute]
internal static IEnumerable`1<T> RecurseWhileNotNull(T source, Func`2<T, T> next);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public static class System.CommandLine.Help.DefaultHelpText : object {
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class System.CommandLine.Help.HelpBuilder : object {
    protected static int DefaultColumnGutter;
    protected static int DefaultIndentationSize;
    protected static int WindowMargin;
    private int _indentationLevel;
    [CompilerGeneratedAttribute]
private IConsole <Console>k__BackingField;
    [CompilerGeneratedAttribute]
private int <ColumnGutter>k__BackingField;
    [CompilerGeneratedAttribute]
private int <IndentationSize>k__BackingField;
    [CompilerGeneratedAttribute]
private int <MaxWidth>k__BackingField;
    protected IConsole Console { get; }
    public int ColumnGutter { get; }
    public int IndentationSize { get; }
    public int MaxWidth { get; }
    protected int CurrentIndentation { get; }
    public HelpBuilder(IConsole console, Nullable`1<int> columnGutter, Nullable`1<int> indentationSize, Nullable`1<int> maxWidth);
    [CompilerGeneratedAttribute]
protected IConsole get_Console();
    [CompilerGeneratedAttribute]
public int get_ColumnGutter();
    [CompilerGeneratedAttribute]
public int get_IndentationSize();
    [CompilerGeneratedAttribute]
public int get_MaxWidth();
    public virtual void Write(ICommand command);
    public virtual void Write(IOption option);
    protected int get_CurrentIndentation();
    protected void Indent(int levels);
    protected void Outdent(int levels);
    protected int GetAvailableWidth();
    protected static string GetPadding(int width);
    private void AppendBlankLine();
    private void AppendPadding(Nullable`1<int> offset);
    private void AppendLine(string text, Nullable`1<int> offset);
    private void AppendText(string text, Nullable`1<int> offset);
    [NullableContextAttribute("2")]
private void AppendHeading(string heading);
    private void AppendDescription(string description);
    protected virtual void AppendHelpItems(IReadOnlyCollection`1<HelpItem> helpItems);
    protected virtual IReadOnlyList`1<IReadOnlyList`1<string>> CreateTable(IEnumerable`1<T> collection, Func`2<T, IEnumerable`1<string>> selector);
    private IReadOnlyList`1<int> ColumnWidths(IEnumerable`1<IReadOnlyList`1<string>> table);
    private void AppendTable(IEnumerable`1<IEnumerable`1<string>> table, IReadOnlyList`1<int> columnWidths);
    private void AppendRow(IEnumerable`1<string> row, IReadOnlyList`1<int> columnWidths);
    protected virtual IReadOnlyList`1<string> SplitText(string text, int width);
    [IteratorStateMachineAttribute("System.CommandLine.Help.HelpBuilder/<GetArgumentHelpItems>d__37")]
private IEnumerable`1<HelpItem> GetArgumentHelpItems(ISymbol symbol);
    protected virtual string ArgumentDescriptor(IArgument argument);
    protected virtual string DefaultValueHint(IArgument argument, bool isSingleArgument);
    [IteratorStateMachineAttribute("System.CommandLine.Help.HelpBuilder/<GetOptionHelpItems>d__40")]
private IEnumerable`1<HelpItem> GetOptionHelpItems(ISymbol symbol);
    protected virtual void AddSynopsis(ICommand command);
    protected virtual void AddUsage(ICommand command);
    private string FormatArgumentUsage(IReadOnlyCollection`1<IArgument> arguments);
    protected virtual void AddArguments(ICommand command);
    protected virtual void AddOptions(ICommand command);
    protected virtual void AddSubcommands(ICommand command);
    protected virtual void AddAdditionalArguments(ICommand command);
    [NullableContextAttribute("2")]
private bool ShouldDisplayArgumentHelp(ICommand command);
    private int GetConsoleWindowWidth(IConsole console);
    private string ShortenWhitespace(string input);
    private string JoinNonEmpty(string separator, String[] values);
    internal bool ShouldShowHelp(ISymbol symbol);
    internal bool ShouldShowDefaultValueHint(IArgument argument);
    [NullableContextAttribute("0")]
[CompilerGeneratedAttribute]
private IEnumerable`1<string> <AppendHelpItems>b__31_0(HelpItem item);
    [CompilerGeneratedAttribute]
private string <GetArgumentHelpItems>g__BuildDefaultValueHint|37_0(IArgument argument);
    [CompilerGeneratedAttribute]
private string <GetOptionHelpItems>g__BuildDefaultValueHint|40_6(IEnumerable`1<IArgument> arguments);
    [CompilerGeneratedAttribute]
internal static bool <FormatArgumentUsage>g__IsMultiParented|43_0(IArgument argument);
    [CompilerGeneratedAttribute]
internal static bool <FormatArgumentUsage>g__IsOptional|43_1(IArgument argument);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class System.CommandLine.Help.HelpOption : Option {
    public Argument Argument { get; public set; }
    public virtual Argument get_Argument();
    public virtual void set_Argument(Argument value);
    protected bool Equals(HelpOption other);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
}
[NullableContextAttribute("1")]
public interface System.CommandLine.Help.IHelpBuilder {
    public abstract virtual void Write(ICommand command);
}
public interface System.CommandLine.IArgument {
    [NullableAttribute("1")]
public IArgumentArity Arity { get; }
    [NullableContextAttribute("1")]
public abstract virtual IArgumentArity get_Arity();
}
public interface System.CommandLine.IArgumentArity {
    public int MinimumNumberOfValues { get; }
    public int MaximumNumberOfValues { get; }
    public abstract virtual int get_MinimumNumberOfValues();
    public abstract virtual int get_MaximumNumberOfValues();
}
[NullableContextAttribute("1")]
public interface System.CommandLine.ICommand {
    public bool TreatUnmatchedTokensAsErrors { get; }
    public IEnumerable`1<IArgument> Arguments { get; }
    public IEnumerable`1<IOption> Options { get; }
    public abstract virtual bool get_TreatUnmatchedTokensAsErrors();
    public abstract virtual IEnumerable`1<IArgument> get_Arguments();
    public abstract virtual IEnumerable`1<IOption> get_Options();
}
public interface System.CommandLine.IConsole {
}
[NullableContextAttribute("1")]
public interface System.CommandLine.IDirectiveCollection {
    public abstract virtual bool Contains(string name);
    public abstract virtual bool TryGetValues(string name, IEnumerable`1& values);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
public static class System.CommandLine.Invocation.CommandHandler : object {
    [NullableContextAttribute("1")]
public static ICommandHandler Create(Delegate delegate);
    [NullableContextAttribute("1")]
public static ICommandHandler Create(MethodInfo method, object target);
    [NullableContextAttribute("1")]
public static ICommandHandler Create(Action action);
    [NullableContextAttribute("1")]
public static ICommandHandler Create(Action`1<T> action);
    [NullableContextAttribute("1")]
public static ICommandHandler Create(Action`2<T1, T2> action);
    public static ICommandHandler Create(Action`3<T1, T2, T3> action);
    public static ICommandHandler Create(Action`4<T1, T2, T3, T4> action);
    public static ICommandHandler Create(Action`5<T1, T2, T3, T4, T5> action);
    public static ICommandHandler Create(Action`6<T1, T2, T3, T4, T5, T6> action);
    public static ICommandHandler Create(Action`7<T1, T2, T3, T4, T5, T6, T7> action);
    public static ICommandHandler Create(Action`8<T1, T2, T3, T4, T5, T6, T7, T8> action);
    public static ICommandHandler Create(Action`9<T1, T2, T3, T4, T5, T6, T7, T8, T9> action);
    public static ICommandHandler Create(Action`10<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10> action);
    public static ICommandHandler Create(Action`11<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11> action);
    [NullableContextAttribute("1")]
public static ICommandHandler Create(Func`1<int> action);
    [NullableContextAttribute("1")]
public static ICommandHandler Create(Func`2<T, int> action);
    [NullableContextAttribute("1")]
public static ICommandHandler Create(Func`3<T1, T2, int> action);
    public static ICommandHandler Create(Func`4<T1, T2, T3, int> action);
    public static ICommandHandler Create(Func`5<T1, T2, T3, T4, int> action);
    public static ICommandHandler Create(Func`6<T1, T2, T3, T4, T5, int> action);
    public static ICommandHandler Create(Func`7<T1, T2, T3, T4, T5, T6, int> action);
    public static ICommandHandler Create(Func`8<T1, T2, T3, T4, T5, T6, T7, int> action);
    [NullableContextAttribute("1")]
public static ICommandHandler Create(Func`1<Task> action);
    [NullableContextAttribute("1")]
public static ICommandHandler Create(Func`2<T, Task> action);
    [NullableContextAttribute("1")]
public static ICommandHandler Create(Func`3<T1, T2, Task> action);
    public static ICommandHandler Create(Func`4<T1, T2, T3, Task> action);
    public static ICommandHandler Create(Func`5<T1, T2, T3, T4, Task> action);
    public static ICommandHandler Create(Func`6<T1, T2, T3, T4, T5, Task> action);
    public static ICommandHandler Create(Func`7<T1, T2, T3, T4, T5, T6, Task> action);
    public static ICommandHandler Create(Func`8<T1, T2, T3, T4, T5, T6, T7, Task> action);
    [NullableContextAttribute("1")]
public static ICommandHandler Create(Func`1<Task`1<int>> action);
    [NullableContextAttribute("1")]
public static ICommandHandler Create(Func`2<T, Task`1<int>> action);
    [NullableContextAttribute("1")]
public static ICommandHandler Create(Func`3<T1, T2, Task`1<int>> action);
    public static ICommandHandler Create(Func`4<T1, T2, T3, Task`1<int>> action);
    public static ICommandHandler Create(Func`5<T1, T2, T3, T4, Task`1<int>> action);
    public static ICommandHandler Create(Func`6<T1, T2, T3, T4, T5, Task`1<int>> action);
    public static ICommandHandler Create(Func`7<T1, T2, T3, T4, T5, T6, Task`1<int>> action);
    public static ICommandHandler Create(Func`8<T1, T2, T3, T4, T5, T6, T7, Task`1<int>> action);
    [NullableContextAttribute("1")]
[AsyncStateMachineAttribute("System.CommandLine.Invocation.CommandHandler/<GetResultCodeAsync>d__38")]
internal static Task`1<int> GetResultCodeAsync(object value, InvocationContext context);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class System.CommandLine.Invocation.FeatureRegistration : object {
    private static string _assemblyName;
    private FileInfo _sentinelFile;
    public FeatureRegistration(string featureName);
    private static FeatureRegistration();
    [AsyncStateMachineAttribute("System.CommandLine.Invocation.FeatureRegistration/<EnsureRegistered>d__3")]
public Task EnsureRegistered(Func`1<Task`1<string>> onInitialize);
}
public class System.CommandLine.Invocation.HelpResult : object {
    [NullableContextAttribute("1")]
public sealed virtual void Apply(InvocationContext context);
}
[NullableContextAttribute("1")]
public interface System.CommandLine.Invocation.ICommandHandler {
    public abstract virtual Task`1<int> InvokeAsync(InvocationContext context);
}
[NullableContextAttribute("1")]
public interface System.CommandLine.Invocation.IInvocationResult {
    public abstract virtual void Apply(InvocationContext context);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class System.CommandLine.Invocation.InvocationContext : object {
    [NullableAttribute("2")]
private CancellationTokenSource _cts;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private Action`1<CancellationTokenSource> _cancellationHandlingAddedEvent;
    [CompilerGeneratedAttribute]
private BindingContext <BindingContext>k__BackingField;
    [CompilerGeneratedAttribute]
private int <ResultCode>k__BackingField;
    [NullableAttribute("2")]
[CompilerGeneratedAttribute]
private IInvocationResult <InvocationResult>k__BackingField;
    public BindingContext BindingContext { get; }
    public IConsole Console { get; }
    public Parser Parser { get; }
    public ParseResult ParseResult { get; public set; }
    public int ResultCode { get; public set; }
    [NullableAttribute("2")]
public IInvocationResult InvocationResult { get; public set; }
    public InvocationContext(ParseResult parseResult, IConsole console);
    [CompilerGeneratedAttribute]
public BindingContext get_BindingContext();
    public IConsole get_Console();
    public Parser get_Parser();
    public ParseResult get_ParseResult();
    public void set_ParseResult(ParseResult value);
    [CompilerGeneratedAttribute]
public int get_ResultCode();
    [CompilerGeneratedAttribute]
public void set_ResultCode(int value);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public IInvocationResult get_InvocationResult();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public void set_InvocationResult(IInvocationResult value);
    internal void add_CancellationHandlingAdded(Action`1<CancellationTokenSource> value);
    internal void remove_CancellationHandlingAdded(Action`1<CancellationTokenSource> value);
    public CancellationToken GetCancellationToken();
    public sealed virtual void Dispose();
    [CompilerGeneratedAttribute]
private CancellationToken <.ctor>b__5_0(IServiceProvider _);
    [NullableContextAttribute("0")]
[CompilerGeneratedAttribute]
private InvocationContext <.ctor>b__5_1(IServiceProvider _);
}
public class System.CommandLine.Invocation.InvocationMiddleware : MulticastDelegate {
    public InvocationMiddleware(object object, IntPtr method);
    [NullableContextAttribute("1")]
public virtual Task Invoke(InvocationContext context, Func`2<InvocationContext, Task> next);
    public virtual IAsyncResult BeginInvoke(InvocationContext context, Func`2<InvocationContext, Task> next, AsyncCallback callback, object object);
    public virtual Task EndInvoke(IAsyncResult result);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class System.CommandLine.Invocation.InvocationPipeline : object {
    private ParseResult parseResult;
    public InvocationPipeline(ParseResult parseResult);
    [AsyncStateMachineAttribute("System.CommandLine.Invocation.InvocationPipeline/<InvokeAsync>d__2")]
public Task`1<int> InvokeAsync(IConsole console);
    [NullableContextAttribute("2")]
public int Invoke(IConsole console);
    private static InvocationMiddleware BuildInvocationChain(InvocationContext context);
    private static int GetResultCode(InvocationContext context);
}
public enum System.CommandLine.Invocation.MiddlewareOrder : Enum {
    public int value__;
    public static MiddlewareOrder ExceptionHandler;
    public static MiddlewareOrder Configuration;
    public static MiddlewareOrder Default;
    public static MiddlewareOrder ErrorReporting;
}
internal enum System.CommandLine.Invocation.MiddlewareOrderInternal : Enum {
    public int value__;
    public static MiddlewareOrderInternal Startup;
    public static MiddlewareOrderInternal ExceptionHandler;
    public static MiddlewareOrderInternal EnvironmentVariableDirective;
    public static MiddlewareOrderInternal ConfigureConsole;
    public static MiddlewareOrderInternal RegisterWithDotnetSuggest;
    public static MiddlewareOrderInternal DebugDirective;
    public static MiddlewareOrderInternal ParseDirective;
    public static MiddlewareOrderInternal SuggestDirective;
    public static MiddlewareOrderInternal TypoCorrection;
    public static MiddlewareOrderInternal VersionOption;
    public static MiddlewareOrderInternal HelpOption;
    public static MiddlewareOrderInternal ParseErrorReporting;
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class System.CommandLine.Invocation.ModelBindingCommandHandler : object {
    [NullableAttribute("2")]
private Delegate _handlerDelegate;
    [NullableAttribute("2")]
private object _invocationTarget;
    [NullableAttribute("2")]
private ModelBinder _invocationTargetBinder;
    [NullableAttribute("2")]
private MethodInfo _handlerMethodInfo;
    private IMethodDescriptor _methodDescriptor;
    [CompilerGeneratedAttribute]
private Dictionary`2<IValueDescriptor, IValueSource> <invokeArgumentBindingSources>k__BackingField;
    private bool _enforceExplicitBinding;
    private Dictionary`2<IValueDescriptor, IValueSource> invokeArgumentBindingSources { get; }
    public ModelBindingCommandHandler(MethodInfo handlerMethodInfo, IMethodDescriptor methodDescriptor);
    public ModelBindingCommandHandler(MethodInfo handlerMethodInfo, IMethodDescriptor methodDescriptor, object invocationTarget);
    public ModelBindingCommandHandler(Delegate handlerDelegate, IMethodDescriptor methodDescriptor);
    [CompilerGeneratedAttribute]
private Dictionary`2<IValueDescriptor, IValueSource> get_invokeArgumentBindingSources();
    [AsyncStateMachineAttribute("System.CommandLine.Invocation.ModelBindingCommandHandler/<InvokeAsync>d__12")]
public sealed virtual Task`1<int> InvokeAsync(InvocationContext context);
    public void BindParameter(ParameterInfo param, Argument argument);
    public void BindParameter(ParameterInfo param, Option option);
    private void BindValueSource(ParameterInfo param, IValueSource valueSource);
    [NullableContextAttribute("2")]
private ParameterDescriptor FindParameterDescriptor(ParameterInfo param);
}
internal class System.CommandLine.Invocation.ParseDirectiveResult : object {
    [NullableContextAttribute("1")]
public sealed virtual void Apply(InvocationContext context);
}
public class System.CommandLine.Invocation.ParseErrorResult : object {
    [NullableContextAttribute("1")]
public sealed virtual void Apply(InvocationContext context);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
public static class System.CommandLine.Invocation.Process : object {
    [AsyncStateMachineAttribute("System.CommandLine.Invocation.Process/<ExecuteAsync>d__0")]
public static Task`1<int> ExecuteAsync(string command, string args, string workingDir, Action`1<string> stdOut, Action`1<string> stdErr, ValueTuple`2[] environmentVariables);
    [AsyncStateMachineAttribute("System.CommandLine.Invocation.Process/<CompleteAsync>d__1")]
[ExtensionAttribute]
public static Task`1<int> CompleteAsync(Process process, Nullable`1<CancellationToken> cancellationToken);
    public static Process StartProcess(string command, string args, string workingDir, Action`1<string> stdOut, Action`1<string> stdErr, ValueTuple`2[] environmentVariables);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class System.CommandLine.Invocation.ServiceProvider : object {
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private Dictionary`2<Type, Func`2<IServiceProvider, object>> _services;
    public IReadOnlyCollection`1<Type> AvailableServiceTypes { get; }
    public ServiceProvider(BindingContext bindingContext);
    public void AddService(Func`2<IServiceProvider, T> factory);
    public void AddService(Type serviceType, Func`2<IServiceProvider, object> factory);
    public IReadOnlyCollection`1<Type> get_AvailableServiceTypes();
    public sealed virtual object GetService(Type serviceType);
}
internal class System.CommandLine.Invocation.SuggestDirectiveResult : object {
    private int _position;
    public SuggestDirectiveResult(int position);
    [NullableContextAttribute("1")]
public sealed virtual void Apply(InvocationContext context);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class System.CommandLine.Invocation.TypoCorrection : object {
    private int _maxLevenshteinDistance;
    public TypoCorrection(int maxLevenshteinDistance);
    public void ProvideSuggestions(ParseResult result, IConsole console);
    private IEnumerable`1<string> GetPossibleTokens(ISymbol targetSymbol, string token);
    private static int GetStartsWithDistance(string first, string second);
    private static int GetDistance(string first, string second);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
internal static class System.CommandLine.IO.ConsoleExtensions : object {
    [ExtensionAttribute]
internal static void SetTerminalForegroundRed(IConsole console);
    [ExtensionAttribute]
internal static void ResetTerminalForegroundColor(IConsole console);
}
[NullableContextAttribute("1")]
public interface System.CommandLine.IO.IStandardError {
    public IStandardStreamWriter Error { get; }
    public bool IsErrorRedirected { get; }
    public abstract virtual IStandardStreamWriter get_Error();
    public abstract virtual bool get_IsErrorRedirected();
}
public interface System.CommandLine.IO.IStandardIn {
    public bool IsInputRedirected { get; }
    public abstract virtual bool get_IsInputRedirected();
}
[NullableContextAttribute("1")]
public interface System.CommandLine.IO.IStandardOut {
    public IStandardStreamWriter Out { get; }
    public bool IsOutputRedirected { get; }
    public abstract virtual IStandardStreamWriter get_Out();
    public abstract virtual bool get_IsOutputRedirected();
}
[NullableContextAttribute("1")]
public interface System.CommandLine.IO.IStandardStreamWriter {
    public abstract virtual void Write(string value);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
public static class System.CommandLine.IO.StandardStreamWriter : object {
    public static IStandardStreamWriter Create(TextWriter writer);
    [ExtensionAttribute]
public static void WriteLine(IStandardStreamWriter writer);
    [ExtensionAttribute]
public static void WriteLine(IStandardStreamWriter writer, string value);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class System.CommandLine.IO.SystemConsole : object {
    [CompilerGeneratedAttribute]
private IStandardStreamWriter <Error>k__BackingField;
    [CompilerGeneratedAttribute]
private IStandardStreamWriter <Out>k__BackingField;
    public IStandardStreamWriter Error { get; }
    public bool IsErrorRedirected { get; }
    public IStandardStreamWriter Out { get; }
    public bool IsOutputRedirected { get; }
    public bool IsInputRedirected { get; }
    [CompilerGeneratedAttribute]
public sealed virtual IStandardStreamWriter get_Error();
    public sealed virtual bool get_IsErrorRedirected();
    [CompilerGeneratedAttribute]
public sealed virtual IStandardStreamWriter get_Out();
    public sealed virtual bool get_IsOutputRedirected();
    public sealed virtual bool get_IsInputRedirected();
    public int GetConsoleWindowWidth();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class System.CommandLine.IO.TestConsole : object {
    [CompilerGeneratedAttribute]
private IStandardStreamWriter <Error>k__BackingField;
    [CompilerGeneratedAttribute]
private IStandardStreamWriter <Out>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsOutputRedirected>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsErrorRedirected>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsInputRedirected>k__BackingField;
    public IStandardStreamWriter Error { get; protected set; }
    public IStandardStreamWriter Out { get; protected set; }
    public bool IsOutputRedirected { get; protected set; }
    public bool IsErrorRedirected { get; protected set; }
    public bool IsInputRedirected { get; protected set; }
    [CompilerGeneratedAttribute]
public sealed virtual IStandardStreamWriter get_Error();
    [CompilerGeneratedAttribute]
protected void set_Error(IStandardStreamWriter value);
    [CompilerGeneratedAttribute]
public sealed virtual IStandardStreamWriter get_Out();
    [CompilerGeneratedAttribute]
protected void set_Out(IStandardStreamWriter value);
    [CompilerGeneratedAttribute]
public sealed virtual bool get_IsOutputRedirected();
    [CompilerGeneratedAttribute]
protected void set_IsOutputRedirected(bool value);
    [CompilerGeneratedAttribute]
public sealed virtual bool get_IsErrorRedirected();
    [CompilerGeneratedAttribute]
protected void set_IsErrorRedirected(bool value);
    [CompilerGeneratedAttribute]
public sealed virtual bool get_IsInputRedirected();
    [CompilerGeneratedAttribute]
protected void set_IsInputRedirected(bool value);
}
public interface System.CommandLine.IOption {
    [NullableAttribute("1")]
public IArgument Argument { get; }
    public bool IsRequired { get; }
    [NullableContextAttribute("1")]
public abstract virtual IArgument get_Argument();
    public abstract virtual bool get_IsRequired();
}
[NullableContextAttribute("1")]
public interface System.CommandLine.ISymbol {
    public string Name { get; }
    [NullableAttribute("2")]
public string Description { get; }
    public IReadOnlyCollection`1<string> Aliases { get; }
    public bool IsHidden { get; }
    public ISymbolSet Children { get; }
    public ISymbolSet Parents { get; }
    public abstract virtual string get_Name();
    [NullableContextAttribute("2")]
public abstract virtual string get_Description();
    public abstract virtual IReadOnlyCollection`1<string> get_Aliases();
    public abstract virtual bool HasAlias(string alias);
    public abstract virtual bool get_IsHidden();
    public abstract virtual ISymbolSet get_Children();
    public abstract virtual ISymbolSet get_Parents();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class System.CommandLine.Option : Symbol {
    [NullableAttribute("2")]
private string _implicitName;
    private protected HashSet`1<string> _unprefixedAliases;
    [CompilerGeneratedAttribute]
private List`1<ValidateSymbol`1<OptionResult>> <Validators>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsRequired>k__BackingField;
    public Argument Argument { get; public set; }
    private IEnumerable`1<Argument> Arguments { get; }
    public string Name { get; public set; }
    internal List`1<ValidateSymbol`1<OptionResult>> Validators { get; }
    private IArgument System.CommandLine.IOption.Argument { get; }
    public bool IsRequired { get; public set; }
    private string System.CommandLine.Binding.IValueDescriptor.ValueName { get; }
    private Type System.CommandLine.Binding.IValueDescriptor.ValueType { get; }
    private bool System.CommandLine.Binding.IValueDescriptor.HasDefaultValue { get; }
    private protected string DefaultName { get; }
    public Option(string alias, string description);
    public Option(String[] aliases, string description);
    public virtual Argument get_Argument();
    public virtual void set_Argument(Argument value);
    private IEnumerable`1<Argument> get_Arguments();
    public virtual string get_Name();
    public virtual void set_Name(string value);
    [CompilerGeneratedAttribute]
internal List`1<ValidateSymbol`1<OptionResult>> get_Validators();
    public void AddAlias(string alias);
    private protected virtual void AddAliasInner(string alias);
    public void AddValidator(ValidateSymbol`1<OptionResult> validate);
    public bool HasAliasIgnorePrefix(string alias);
    [NullableContextAttribute("2")]
private protected virtual void RemoveAlias(string alias);
    private sealed virtual override IArgument System.CommandLine.IOption.get_Argument();
    [CompilerGeneratedAttribute]
public sealed virtual bool get_IsRequired();
    [CompilerGeneratedAttribute]
public void set_IsRequired(bool value);
    private sealed virtual override string System.CommandLine.Binding.IValueDescriptor.get_ValueName();
    private sealed virtual override Type System.CommandLine.Binding.IValueDescriptor.get_ValueType();
    private sealed virtual override bool System.CommandLine.Binding.IValueDescriptor.get_HasDefaultValue();
    [NullableContextAttribute("2")]
private sealed virtual override object System.CommandLine.Binding.IValueDescriptor.GetDefaultValue();
    private protected virtual string get_DefaultName();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class System.CommandLine.Option`1 : Option {
    unknown Argument Argument {public set; }
    public Option`1(string alias, string description);
    public Option`1(String[] aliases, string description);
    public Option`1(string alias, ParseArgument`1<T> parseArgument, bool isDefault, string description);
    public Option`1(String[] aliases, ParseArgument`1<T> parseArgument, bool isDefault, string description);
    public Option`1(string alias, Func`1<T> getDefaultValue, string description);
    public Option`1(String[] aliases, Func`1<T> getDefaultValue, string description);
    public virtual void set_Argument(Argument value);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
public static class System.CommandLine.OptionExtensions : object {
    [ExtensionAttribute]
public static TOption FromAmong(TOption option, String[] values);
    [ExtensionAttribute]
public static TOption AddSuggestions(TOption option, String[] values);
    [ExtensionAttribute]
public static TOption AddSuggestions(TOption option, SuggestDelegate suggest);
    [ExtensionAttribute]
public static Option`1<FileInfo> ExistingOnly(Option`1<FileInfo> option);
    [ExtensionAttribute]
public static Option`1<DirectoryInfo> ExistingOnly(Option`1<DirectoryInfo> option);
    [ExtensionAttribute]
public static Option`1<FileSystemInfo> ExistingOnly(Option`1<FileSystemInfo> option);
    [ExtensionAttribute]
public static Option`1<T> ExistingOnly(Option`1<T> option);
    [ExtensionAttribute]
public static TOption LegalFilePathsOnly(TOption option);
    [ExtensionAttribute]
public static ParseResult Parse(Option option, string commandLine);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class System.CommandLine.Parsing.ArgumentResult : SymbolResult {
    [NullableAttribute("2")]
private ArgumentConversionResult _conversionResult;
    [CompilerGeneratedAttribute]
private IArgument <Argument>k__BackingField;
    public IArgument Argument { get; }
    internal ArgumentResult(IArgument argument, SymbolResult parent);
    [CompilerGeneratedAttribute]
public IArgument get_Argument();
    internal ArgumentConversionResult GetArgumentConversionResult();
    public virtual string ToString();
    internal ParseError CustomError(Argument argument);
    internal virtual ArgumentConversionResult Convert(IArgument argument);
    [CompilerGeneratedAttribute]
internal static bool <Convert>g__ShouldCheckArity|8_0(<>c__DisplayClass8_0& );
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
public static class System.CommandLine.Parsing.ArgumentResultExtensions : object {
    [ExtensionAttribute]
public static object GetValueOrDefault(ArgumentResult argumentResult);
    [ExtensionAttribute]
public static T GetValueOrDefault(ArgumentResult argumentResult);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class System.CommandLine.Parsing.CommandArgumentNode : SyntaxNode {
    [CompilerGeneratedAttribute]
private IArgument <Argument>k__BackingField;
    [CompilerGeneratedAttribute]
private CommandNode <ParentCommandNode>k__BackingField;
    public IArgument Argument { get; }
    public CommandNode ParentCommandNode { get; }
    public CommandArgumentNode(Token token, IArgument argument, CommandNode parent);
    [CompilerGeneratedAttribute]
public IArgument get_Argument();
    [CompilerGeneratedAttribute]
public CommandNode get_ParentCommandNode();
}
public class System.CommandLine.Parsing.CommandLineStringSplitter : object {
    [NullableAttribute("1")]
public static CommandLineStringSplitter Instance;
    private static CommandLineStringSplitter();
    [NullableContextAttribute("1")]
[IteratorStateMachineAttribute("System.CommandLine.Parsing.CommandLineStringSplitter/<Split>d__2")]
public IEnumerable`1<string> Split(string commandLine);
    [CompilerGeneratedAttribute]
internal static void <Split>g__Advance|2_0(<>c__DisplayClass2_0& );
    [NullableContextAttribute("1")]
[CompilerGeneratedAttribute]
internal static string <Split>g__CurrentToken|2_1(<>c__DisplayClass2_0& );
    [CompilerGeneratedAttribute]
internal static int <Split>g__IndexOfEndOfToken|2_2(<>c__DisplayClass2_0& );
    [CompilerGeneratedAttribute]
internal static bool <Split>g__IsAtEndOfInput|2_3(<>c__DisplayClass2_0& );
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class System.CommandLine.Parsing.CommandNode : NonterminalSyntaxNode {
    [CompilerGeneratedAttribute]
private ICommand <Command>k__BackingField;
    public ICommand Command { get; }
    public CommandNode(Token token, ICommand command, CommandNode parent);
    [CompilerGeneratedAttribute]
public ICommand get_Command();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[DefaultMemberAttribute("Item")]
public class System.CommandLine.Parsing.CommandResult : SymbolResult {
    [NullableAttribute("2")]
private ArgumentConversionResultSet _results;
    [CompilerGeneratedAttribute]
private ICommand <Command>k__BackingField;
    [CompilerGeneratedAttribute]
private Token <Token>k__BackingField;
    public ICommand Command { get; }
    [NullableAttribute("2")]
public OptionResult Item { get; }
    public Token Token { get; }
    internal ArgumentConversionResultSet ArgumentConversionResults { get; }
    internal CommandResult(ICommand command, Token token, CommandResult parent);
    [CompilerGeneratedAttribute]
public ICommand get_Command();
    public OptionResult get_Item(string alias);
    public OptionResult OptionResult(string alias);
    [CompilerGeneratedAttribute]
public Token get_Token();
    internal ArgumentConversionResultSet get_ArgumentConversionResults();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
public static class System.CommandLine.Parsing.CommandResultExtensions : object {
    [ExtensionAttribute]
public static object GetArgumentValueOrDefault(CommandResult commandResult, string argumentName);
    [ExtensionAttribute]
public static T GetArgumentValueOrDefault(CommandResult commandResult, string argumentName);
    [ExtensionAttribute]
internal static bool TryGetValueForArgument(CommandResult commandResult, IValueDescriptor valueDescriptor, Object& value);
    [ExtensionAttribute]
internal static bool TryGetValueForOption(CommandResult commandResult, IValueDescriptor valueDescriptor, Object& value);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class System.CommandLine.Parsing.DirectiveNode : SyntaxNode {
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    [NullableAttribute("2")]
[CompilerGeneratedAttribute]
private string <Value>k__BackingField;
    public string Name { get; }
    [NullableAttribute("2")]
public string Value { get; }
    public DirectiveNode(Token token, RootCommandNode parent, string name, string value);
    [CompilerGeneratedAttribute]
public string get_Name();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public string get_Value();
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
internal class System.CommandLine.Parsing.ImplicitToken : Token {
    [CompilerGeneratedAttribute]
private object <ActualValue>k__BackingField;
    public object ActualValue { get; }
    public ImplicitToken(object value, TokenType type);
    [CompilerGeneratedAttribute]
public object get_ActualValue();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal abstract class System.CommandLine.Parsing.NonterminalSyntaxNode : SyntaxNode {
    private List`1<SyntaxNode> _children;
    public IReadOnlyList`1<SyntaxNode> Children { get; }
    protected NonterminalSyntaxNode(Token token, SyntaxNode parent);
    public IReadOnlyList`1<SyntaxNode> get_Children();
    internal void AddChildNode(SyntaxNode node);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class System.CommandLine.Parsing.OptionArgumentNode : SyntaxNode {
    [CompilerGeneratedAttribute]
private IArgument <Argument>k__BackingField;
    [CompilerGeneratedAttribute]
private OptionNode <ParentOptionNode>k__BackingField;
    public IArgument Argument { get; }
    public OptionNode ParentOptionNode { get; }
    public OptionArgumentNode(Token token, IArgument argument, OptionNode parent);
    [CompilerGeneratedAttribute]
public IArgument get_Argument();
    [CompilerGeneratedAttribute]
public OptionNode get_ParentOptionNode();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class System.CommandLine.Parsing.OptionNode : NonterminalSyntaxNode {
    [CompilerGeneratedAttribute]
private IOption <Option>k__BackingField;
    public IOption Option { get; }
    public OptionNode(Token token, IOption option, CommandNode parent);
    [CompilerGeneratedAttribute]
public IOption get_Option();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class System.CommandLine.Parsing.OptionResult : SymbolResult {
    [NullableAttribute("2")]
private ArgumentConversionResult _argumentConversionResult;
    [CompilerGeneratedAttribute]
private IOption <Option>k__BackingField;
    [NullableAttribute("2")]
[CompilerGeneratedAttribute]
private Token <Token>k__BackingField;
    public IOption Option { get; }
    public bool IsImplicit { get; }
    [NullableAttribute("2")]
public Token Token { get; }
    private protected int RemainingArgumentCapacity { get; }
    internal ArgumentConversionResult ArgumentConversionResult { get; }
    [NullableContextAttribute("2")]
internal OptionResult(IOption option, Token token, CommandResult parent);
    [CompilerGeneratedAttribute]
public IOption get_Option();
    public bool get_IsImplicit();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public Token get_Token();
    private protected virtual int get_RemainingArgumentCapacity();
    internal ArgumentConversionResult get_ArgumentConversionResult();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
public static class System.CommandLine.Parsing.OptionResultExtensions : object {
    [ExtensionAttribute]
internal static ArgumentConversionResult ConvertIfNeeded(OptionResult optionResult, Type type);
    [ExtensionAttribute]
public static object GetValueOrDefault(OptionResult optionResult);
    [ExtensionAttribute]
public static T GetValueOrDefault(OptionResult optionResult);
}
public class System.CommandLine.Parsing.ParseArgument`1 : MulticastDelegate {
    public ParseArgument`1(object object, IntPtr method);
    [NullableContextAttribute("1")]
public virtual T Invoke(ArgumentResult result);
    public virtual IAsyncResult BeginInvoke(ArgumentResult result, AsyncCallback callback, object object);
    public virtual T EndInvoke(IAsyncResult result);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class System.CommandLine.Parsing.ParseError : object {
    [CompilerGeneratedAttribute]
private string <Message>k__BackingField;
    [NullableAttribute("2")]
[CompilerGeneratedAttribute]
private SymbolResult <SymbolResult>k__BackingField;
    public string Message { get; }
    [NullableAttribute("2")]
public SymbolResult SymbolResult { get; }
    internal ParseError(string message, SymbolResult symbolResult);
    [CompilerGeneratedAttribute]
public string get_Message();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public SymbolResult get_SymbolResult();
    public virtual string ToString();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class System.CommandLine.Parsing.ParseOperation : object {
    private TokenizeResult _tokenizeResult;
    private CommandLineConfiguration _configuration;
    private int _index;
    private Dictionary`2<IArgument, int> _argumentCounts;
    [CompilerGeneratedAttribute]
private List`1<ParseError> <Errors>k__BackingField;
    [NullableAttribute("2")]
[CompilerGeneratedAttribute]
private RootCommandNode <RootCommandNode>k__BackingField;
    [CompilerGeneratedAttribute]
private List`1<Token> <UnmatchedTokens>k__BackingField;
    [CompilerGeneratedAttribute]
private List`1<Token> <UnparsedTokens>k__BackingField;
    private Token CurrentToken { get; }
    public List`1<ParseError> Errors { get; }
    [NullableAttribute("2")]
public RootCommandNode RootCommandNode { get; private set; }
    public List`1<Token> UnmatchedTokens { get; }
    public List`1<Token> UnparsedTokens { get; }
    public ParseOperation(TokenizeResult tokenizeResult, CommandLineConfiguration configuration);
    private Token get_CurrentToken();
    [CompilerGeneratedAttribute]
public List`1<ParseError> get_Errors();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public RootCommandNode get_RootCommandNode();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
private void set_RootCommandNode(RootCommandNode value);
    [CompilerGeneratedAttribute]
public List`1<Token> get_UnmatchedTokens();
    [CompilerGeneratedAttribute]
public List`1<Token> get_UnparsedTokens();
    private void Advance();
    private void IncrementCount(IArgument argument);
    private bool IsFull(IArgument argument);
    private bool More();
    public void Parse();
    private RootCommandNode ParseRootCommand();
    private CommandNode ParseSubcommand(CommandNode parentNode);
    private void ParseCommandChildren(CommandNode parent);
    private CommandArgumentNode ParseCommandArgument(CommandNode commandNode);
    private OptionNode ParseOption(CommandNode parent);
    private void ParseOptionArguments(OptionNode optionNode);
    private void ParseDirectives(RootCommandNode parent);
    private void ParseRemainingTokens();
    [NullableContextAttribute("0")]
[CompilerGeneratedAttribute]
private bool <ParseCommandArgument>b__28_0(IArgument a);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class System.CommandLine.Parsing.Parser : object {
    [CompilerGeneratedAttribute]
private CommandLineConfiguration <Configuration>k__BackingField;
    public CommandLineConfiguration Configuration { get; }
    public Parser(CommandLineConfiguration configuration);
    public Parser(Symbol[] symbols);
    [CompilerGeneratedAttribute]
public CommandLineConfiguration get_Configuration();
    public ParseResult Parse(IReadOnlyList`1<string> arguments, string rawInput);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[DefaultMemberAttribute("Item")]
public class System.CommandLine.Parsing.ParseResult : object {
    private List`1<ParseError> _errors;
    private RootCommandResult _rootCommandResult;
    [CompilerGeneratedAttribute]
private CommandResult <CommandResult>k__BackingField;
    [CompilerGeneratedAttribute]
private Parser <Parser>k__BackingField;
    [CompilerGeneratedAttribute]
private IDirectiveCollection <Directives>k__BackingField;
    [CompilerGeneratedAttribute]
private IReadOnlyList`1<Token> <Tokens>k__BackingField;
    [CompilerGeneratedAttribute]
private IReadOnlyCollection`1<string> <UnmatchedTokens>k__BackingField;
    [NullableAttribute("2")]
[CompilerGeneratedAttribute]
private string <RawInput>k__BackingField;
    [CompilerGeneratedAttribute]
private IReadOnlyCollection`1<string> <UnparsedTokens>k__BackingField;
    public CommandResult CommandResult { get; }
    public Parser Parser { get; }
    public CommandResult RootCommandResult { get; }
    public IReadOnlyCollection`1<ParseError> Errors { get; }
    public IDirectiveCollection Directives { get; }
    public IReadOnlyList`1<Token> Tokens { get; }
    public IReadOnlyCollection`1<string> UnmatchedTokens { get; }
    [NullableAttribute("2")]
internal string RawInput { get; }
    public IReadOnlyCollection`1<string> UnparsedTokens { get; }
    [NullableAttribute("2")]
public SymbolResult Item { get; }
    internal ParseResult(Parser parser, RootCommandResult rootCommandResult, CommandResult commandResult, IDirectiveCollection directives, TokenizeResult tokenizeResult, IReadOnlyCollection`1<string> unparsedTokens, IReadOnlyCollection`1<string> unmatchedTokens, List`1<ParseError> errors, string rawInput);
    [CompilerGeneratedAttribute]
public CommandResult get_CommandResult();
    [CompilerGeneratedAttribute]
public Parser get_Parser();
    public CommandResult get_RootCommandResult();
    public IReadOnlyCollection`1<ParseError> get_Errors();
    [CompilerGeneratedAttribute]
public IDirectiveCollection get_Directives();
    [CompilerGeneratedAttribute]
public IReadOnlyList`1<Token> get_Tokens();
    [CompilerGeneratedAttribute]
public IReadOnlyCollection`1<string> get_UnmatchedTokens();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
internal string get_RawInput();
    [CompilerGeneratedAttribute]
public IReadOnlyCollection`1<string> get_UnparsedTokens();
    public object ValueForOption(string alias);
    public object ValueForArgument(string alias);
    public T ValueForArgument(Argument`1<T> argument);
    public T ValueForArgument(Argument argument);
    public T ValueForArgument(string name);
    public T ValueForOption(Option`1<T> option);
    public T ValueForOption(Option option);
    public T ValueForOption(string alias);
    public SymbolResult get_Item(string alias);
    public virtual string ToString();
    public ArgumentResult FindResultFor(IArgument argument);
    public CommandResult FindResultFor(ICommand command);
    public OptionResult FindResultFor(IOption option);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
public static class System.CommandLine.Parsing.ParseResultExtensions : object {
    [AsyncStateMachineAttribute("System.CommandLine.Parsing.ParseResultExtensions/<InvokeAsync>d__0")]
[ExtensionAttribute]
public static Task`1<int> InvokeAsync(ParseResult parseResult, IConsole console);
    [ExtensionAttribute]
public static int Invoke(ParseResult parseResult, IConsole console);
    [ExtensionAttribute]
public static string TextToMatch(ParseResult source, Nullable`1<int> position);
    [ExtensionAttribute]
public static string Diagram(ParseResult result);
    [ExtensionAttribute]
private static void Diagram(StringBuilder builder, SymbolResult symbolResult, ParseResult parseResult);
    [ExtensionAttribute]
public static SymbolResult FindResultFor(ParseResult parseResult, ISymbol symbol);
    [ExtensionAttribute]
public static bool HasOption(ParseResult parseResult, IOption option);
    [ExtensionAttribute]
public static bool HasOption(ParseResult parseResult, string alias);
    [ExtensionAttribute]
public static IEnumerable`1<string> GetSuggestions(ParseResult parseResult, Nullable`1<int> position);
    [ExtensionAttribute]
internal static SymbolResult SymbolToComplete(ParseResult parseResult, Nullable`1<int> position);
    [CompilerGeneratedAttribute]
internal static String[] <GetSuggestions>g__OptionsWithArgumentLimitReached|8_1(SymbolResult symbolResult, <>c__DisplayClass8_0& );
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class System.CommandLine.Parsing.ParseResultVisitor : SyntaxVisitor {
    private Parser _parser;
    private TokenizeResult _tokenizeResult;
    [NullableAttribute("2")]
private string _rawInput;
    private DirectiveCollection _directives;
    private List`1<string> _unparsedTokens;
    private List`1<string> _unmatchedTokens;
    private List`1<ParseError> _errors;
    [NullableAttribute("2")]
private RootCommandResult _rootCommandResult;
    [NullableAttribute("2")]
private CommandResult _innermostCommandResult;
    public ParseResult Result { get; }
    public ParseResultVisitor(Parser parser, TokenizeResult tokenizeResult, IReadOnlyCollection`1<Token> unparsedTokens, IReadOnlyCollection`1<Token> unmatchedTokens, IReadOnlyCollection`1<ParseError> parseErrors, string rawInput);
    protected virtual void VisitRootCommandNode(RootCommandNode rootCommandNode);
    protected virtual void VisitCommandNode(CommandNode commandNode);
    protected virtual void VisitCommandArgumentNode(CommandArgumentNode argumentNode);
    protected virtual void VisitOptionNode(OptionNode optionNode);
    protected virtual void VisitOptionArgumentNode(OptionArgumentNode argumentNode);
    protected virtual void VisitDirectiveNode(DirectiveNode directiveNode);
    protected virtual void VisitUnknownNode(SyntaxNode node);
    protected virtual void Stop(SyntaxNode node);
    private void ValidateCommandResult();
    private void ValidateCommandHandler();
    private void ValidateOptionResult(OptionResult optionResult);
    private void ValidateArgumentResult(ArgumentResult argumentResult);
    private void PopulateDefaultValues();
    public ParseResult get_Result();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
public static class System.CommandLine.Parsing.ParserExtensions : object {
    [ExtensionAttribute]
public static int Invoke(Parser parser, string commandLine, IConsole console);
    [ExtensionAttribute]
public static int Invoke(Parser parser, String[] args, IConsole console);
    [ExtensionAttribute]
public static Task`1<int> InvokeAsync(Parser parser, string commandLine, IConsole console);
    [AsyncStateMachineAttribute("System.CommandLine.Parsing.ParserExtensions/<InvokeAsync>d__3")]
[ExtensionAttribute]
public static Task`1<int> InvokeAsync(Parser parser, String[] args, IConsole console);
    [ExtensionAttribute]
public static ParseResult Parse(Parser parser, string commandLine);
}
public enum System.CommandLine.Parsing.ResponseFileHandling : Enum {
    public int value__;
    public static ResponseFileHandling ParseArgsAsLineSeparated;
    public static ResponseFileHandling ParseArgsAsSpaceSeparated;
    public static ResponseFileHandling Disabled;
}
internal class System.CommandLine.Parsing.RootCommandNode : CommandNode {
    [NullableContextAttribute("1")]
public RootCommandNode(Token token, ICommand command);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class System.CommandLine.Parsing.RootCommandResult : CommandResult {
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private Dictionary`2<IArgument, ArgumentResult> _allArgumentResults;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private Dictionary`2<ICommand, CommandResult> _allCommandResults;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private Dictionary`2<IOption, OptionResult> _allOptionResults;
    internal RootCommandResult Root { get; }
    public RootCommandResult(ICommand command, Token token);
    internal virtual RootCommandResult get_Root();
    private void EnsureResultMapsAreInitialized();
    public virtual ArgumentResult FindResultFor(IArgument argument);
    public virtual CommandResult FindResultFor(ICommand command);
    public virtual OptionResult FindResultFor(IOption option);
    public SymbolResult FindResultForSymbol(ISymbol symbol);
    internal void AddToSymbolMap(SymbolResult result);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
public static class System.CommandLine.Parsing.StringExtensions : object {
    private static String[] _optionPrefixStrings;
    private static StringExtensions();
    [ExtensionAttribute]
internal static bool ContainsCaseInsensitive(string source, string value);
    [ExtensionAttribute]
internal static int IndexOfCaseInsensitive(string source, string value);
    [ExtensionAttribute]
internal static string RemovePrefix(string rawAlias);
    [ExtensionAttribute]
internal static ValueTuple`2<string, string> SplitPrefix(string rawAlias);
    [ExtensionAttribute]
internal static TokenizeResult Tokenize(IReadOnlyList`1<string> args, CommandLineConfiguration configuration);
    private static List`1<string> NormalizeRootCommand(CommandLineConfiguration commandLineConfiguration, IReadOnlyList`1<string> args);
    [ExtensionAttribute]
private static string GetResponseFileReference(string arg);
    [ExtensionAttribute]
internal static bool TrySplitIntoSubtokens(string arg, Char[] delimiters, String& first, String& rest);
    [ExtensionAttribute]
public static string ToKebabCase(string value);
    private static Token Argument(string value);
    private static Token Command(string value);
    private static Token Option(string value);
    private static Token EndOfArguments();
    private static Token Operand(string value);
    private static Token Directive(string value);
    [IteratorStateMachineAttribute("System.CommandLine.Parsing.StringExtensions/<ExpandResponseFile>d__16")]
private static IEnumerable`1<string> ExpandResponseFile(string filePath, ResponseFileHandling responseFileHandling);
    [ExtensionAttribute]
private static Dictionary`2<string, Token> ValidTokens(ICommand command);
    [CompilerGeneratedAttribute]
internal static bool <Tokenize>g__CanBeUnbundled|5_0(string arg, IReadOnlyCollection`1& replacement, <>c__DisplayClass5_0& );
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
internal static Token <Tokenize>g__TokenForOptionAlias|5_2(char c, <>c__DisplayClass5_0& );
    [CompilerGeneratedAttribute]
internal static void <Tokenize>g__AddRestValue|5_3(List`1<string> list, string rest, <>c__DisplayClass5_0& );
    [CompilerGeneratedAttribute]
internal static bool <Tokenize>g__TryUnbundle|5_4(IReadOnlyCollection`1& replacement, <>c__DisplayClass5_0& , <>c__DisplayClass5_1& );
    [CompilerGeneratedAttribute]
internal static void <Tokenize>g__ReadResponseFile|5_1(string filePath, int i, <>c__DisplayClass5_0& );
    [CompilerGeneratedAttribute]
internal static bool <NormalizeRootCommand>g__FirstArgMatchesRootCommand|6_0(<>c__DisplayClass6_0& );
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public abstract class System.CommandLine.Parsing.SymbolResult : object {
    private protected List`1<Token> _tokens;
    [NullableAttribute("2")]
private ValidationMessages _validationMessages;
    private Dictionary`2<IArgument, ArgumentResult> _defaultArgumentValues;
    [NullableAttribute("2")]
[CompilerGeneratedAttribute]
private string <ErrorMessage>k__BackingField;
    [CompilerGeneratedAttribute]
private SymbolResultSet <Children>k__BackingField;
    [NullableAttribute("2")]
[CompilerGeneratedAttribute]
private SymbolResult <Parent>k__BackingField;
    [CompilerGeneratedAttribute]
private ISymbol <Symbol>k__BackingField;
    [NullableAttribute("2")]
public string ErrorMessage { get; public set; }
    public SymbolResultSet Children { get; }
    [NullableAttribute("2")]
public SymbolResult Parent { get; }
    [NullableAttribute("2")]
internal RootCommandResult Root { get; }
    public ISymbol Symbol { get; }
    public IReadOnlyList`1<Token> Tokens { get; }
    internal bool IsArgumentLimitReached { get; }
    private protected int RemainingArgumentCapacity { get; }
    protected internal ValidationMessages ValidationMessages { get; protected internal set; }
    private protected SymbolResult(ISymbol symbol, SymbolResult parent);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public string get_ErrorMessage();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public void set_ErrorMessage(string value);
    [CompilerGeneratedAttribute]
public SymbolResultSet get_Children();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public SymbolResult get_Parent();
    [NullableContextAttribute("2")]
internal virtual RootCommandResult get_Root();
    [CompilerGeneratedAttribute]
public ISymbol get_Symbol();
    public IReadOnlyList`1<Token> get_Tokens();
    internal bool get_IsArgumentLimitReached();
    private protected virtual int get_RemainingArgumentCapacity();
    internal int MaximumArgumentCapacity();
    protected internal ValidationMessages get_ValidationMessages();
    protected internal void set_ValidationMessages(ValidationMessages value);
    internal void AddToken(Token token);
    public virtual ArgumentResult FindResultFor(IArgument argument);
    public virtual CommandResult FindResultFor(ICommand command);
    public virtual OptionResult FindResultFor(IOption option);
    internal ArgumentResult GetOrCreateDefaultArgumentResult(Argument argument);
    internal bool UseDefaultValueFor(IArgument argument);
    public virtual string ToString();
    internal ParseError UnrecognizedArgumentError(Argument argument);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
internal static class System.CommandLine.Parsing.SymbolResultExtensions : object {
    [IteratorStateMachineAttribute("System.CommandLine.Parsing.SymbolResultExtensions/<AllSymbolResults>d__0")]
[ExtensionAttribute]
internal static IEnumerable`1<SymbolResult> AllSymbolResults(SymbolResult symbolResult);
    [ExtensionAttribute]
internal static Token Token(SymbolResult symbolResult);
    [CompilerGeneratedAttribute]
internal static Token <Token>g__CreateImplicitToken|1_0(IOption option);
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public class System.CommandLine.Parsing.SymbolResultSet : AliasedSet`1<SymbolResult> {
    internal SymbolResult ResultFor(ISymbol symbol);
    protected virtual IReadOnlyCollection`1<string> GetAliases(SymbolResult item);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal abstract class System.CommandLine.Parsing.SyntaxNode : object {
    [NullableAttribute("2")]
[CompilerGeneratedAttribute]
private SyntaxNode <Parent>k__BackingField;
    [CompilerGeneratedAttribute]
private Token <Token>k__BackingField;
    [NullableAttribute("2")]
public SyntaxNode Parent { get; }
    public Token Token { get; }
    protected SyntaxNode(Token token, SyntaxNode parent);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public SyntaxNode get_Parent();
    [CompilerGeneratedAttribute]
public Token get_Token();
    public virtual string ToString();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal abstract class System.CommandLine.Parsing.SyntaxVisitor : object {
    public void Visit(SyntaxNode node);
    private void VisitInternal(SyntaxNode node);
    protected virtual void VisitCommandArgumentNode(CommandArgumentNode argumentNode);
    protected virtual void VisitOptionArgumentNode(OptionArgumentNode argumentNode);
    protected virtual void VisitOptionNode(OptionNode optionNode);
    protected virtual void VisitRootCommandNode(RootCommandNode rootCommandNode);
    protected virtual void VisitCommandNode(CommandNode commandNode);
    protected virtual void VisitDirectiveNode(DirectiveNode directiveNode);
    protected virtual void Start(SyntaxNode node);
    protected virtual void Stop(SyntaxNode node);
    protected virtual void VisitUnknownNode(SyntaxNode node);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class System.CommandLine.Parsing.Token : object {
    [CompilerGeneratedAttribute]
private string <Value>k__BackingField;
    [CompilerGeneratedAttribute]
private string <UnprefixedValue>k__BackingField;
    [CompilerGeneratedAttribute]
private TokenType <Type>k__BackingField;
    public string Value { get; }
    internal string UnprefixedValue { get; }
    public TokenType Type { get; }
    [NullableContextAttribute("2")]
public Token(string value, TokenType type);
    [CompilerGeneratedAttribute]
public string get_Value();
    [CompilerGeneratedAttribute]
internal string get_UnprefixedValue();
    [CompilerGeneratedAttribute]
public TokenType get_Type();
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public virtual string ToString();
    public static bool op_Equality(Token left, Token right);
    public static bool op_Inequality(Token left, Token right);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class System.CommandLine.Parsing.TokenizeError : object {
    [CompilerGeneratedAttribute]
private string <Message>k__BackingField;
    public string Message { get; }
    public TokenizeError(string message);
    [CompilerGeneratedAttribute]
public string get_Message();
    public virtual string ToString();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class System.CommandLine.Parsing.TokenizeResult : object {
    [CompilerGeneratedAttribute]
private IReadOnlyList`1<Token> <Tokens>k__BackingField;
    [CompilerGeneratedAttribute]
private IReadOnlyCollection`1<TokenizeError> <Errors>k__BackingField;
    public IReadOnlyList`1<Token> Tokens { get; }
    public IReadOnlyCollection`1<TokenizeError> Errors { get; }
    internal TokenizeResult(IReadOnlyList`1<Token> tokens, IReadOnlyCollection`1<TokenizeError> errors);
    [CompilerGeneratedAttribute]
public IReadOnlyList`1<Token> get_Tokens();
    [CompilerGeneratedAttribute]
public IReadOnlyCollection`1<TokenizeError> get_Errors();
}
public enum System.CommandLine.Parsing.TokenType : Enum {
    public int value__;
    public static TokenType Argument;
    public static TokenType Command;
    public static TokenType Option;
    public static TokenType EndOfArguments;
    public static TokenType Operand;
    public static TokenType Directive;
}
public class System.CommandLine.Parsing.ValidateSymbol`1 : MulticastDelegate {
    public ValidateSymbol`1(object object, IntPtr method);
    [NullableContextAttribute("1")]
public virtual string Invoke(T symbolResult);
    public virtual IAsyncResult BeginInvoke(T symbolResult, AsyncCallback callback, object object);
    public virtual string EndInvoke(IAsyncResult result);
}
internal static class System.CommandLine.Platform : object {
    private static Nullable`1<bool> _isConsoleRedirectionCheckSupported;
    public static bool IsConsoleRedirectionCheckSupported { get; }
    public static bool get_IsConsoleRedirectionCheckSupported();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class System.CommandLine.RootCommand : Command {
    private static Lazy`1<string> _executablePath;
    private static Lazy`1<string> _executableName;
    public static string ExecutableName { get; }
    public static string ExecutablePath { get; }
    public RootCommand(string description);
    private static RootCommand();
    private static Assembly GetAssembly();
    public static string get_ExecutableName();
    public static string get_ExecutablePath();
    [NullableContextAttribute("2")]
private protected virtual void RemoveAlias(string alias);
}
internal class System.CommandLine.Suggestions.AnonymousSuggestionSource : object {
    [NullableAttribute("1")]
private SuggestDelegate _suggest;
    [NullableContextAttribute("1")]
public AnonymousSuggestionSource(SuggestDelegate suggest);
    [NullableContextAttribute("2")]
public sealed virtual IEnumerable`1<string> GetSuggestions(ParseResult parseResult, string textToMatch);
}
[NullableContextAttribute("2")]
public interface System.CommandLine.Suggestions.ISuggestionSource {
    public abstract virtual IEnumerable`1<string> GetSuggestions(ParseResult parseResult, string textToMatch);
}
public class System.CommandLine.Suggestions.SuggestDelegate : MulticastDelegate {
    public SuggestDelegate(object object, IntPtr method);
    [NullableContextAttribute("2")]
public virtual IEnumerable`1<string> Invoke(ParseResult parseResult, string textToMatch);
    public virtual IAsyncResult BeginInvoke(ParseResult parseResult, string textToMatch, AsyncCallback callback, object object);
    public virtual IEnumerable`1<string> EndInvoke(IAsyncResult result);
}
[ExtensionAttribute]
internal static class System.CommandLine.Suggestions.SuggestionExtensions : object {
    [NullableContextAttribute("2")]
[ExtensionAttribute]
public static IEnumerable`1<string> Containing(IEnumerable`1<string> candidates, string textToMatch);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public static class System.CommandLine.Suggestions.SuggestionSource : object {
    private static ConcurrentDictionary`2<Type, ISuggestionSource> _suggestionSourcesByType;
    private static String[] _trueAndFalse;
    [CompilerGeneratedAttribute]
private static ISuggestionSource <Empty>k__BackingField;
    public static ISuggestionSource Empty { get; }
    private static SuggestionSource();
    public static ISuggestionSource ForType(Type type);
    [CompilerGeneratedAttribute]
public static ISuggestionSource get_Empty();
    [CompilerGeneratedAttribute]
internal static ISuggestionSource <ForType>g__CreateForType|2_0(Type t);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
public static class System.CommandLine.SuggestionSourceExtensions : object {
    [ExtensionAttribute]
public static void Add(List`1<ISuggestionSource> suggestionSources, SuggestDelegate suggest);
    [ExtensionAttribute]
public static void Add(List`1<ISuggestionSource> suggestionSources, String[] suggestions);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public abstract class System.CommandLine.Symbol : object {
    private HashSet`1<string> _aliases;
    [NullableAttribute("2")]
private string _specifiedName;
    private SymbolSet _parents;
    [NullableAttribute("2")]
[CompilerGeneratedAttribute]
private string <Description>k__BackingField;
    [CompilerGeneratedAttribute]
private SymbolSet <Children>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsHidden>k__BackingField;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal Action`1<ISymbol> OnNameOrAliasChanged;
    public IReadOnlyCollection`1<string> Aliases { get; }
    [NullableAttribute("2")]
public string Description { get; public set; }
    public string Name { get; public set; }
    private protected string DefaultName { get; }
    public ISymbolSet Parents { get; }
    public SymbolSet Children { get; }
    public bool IsHidden { get; public set; }
    private ISymbolSet System.CommandLine.ISymbol.Children { get; }
    [NullableContextAttribute("2")]
protected Symbol(string description);
    protected Symbol(string name, string description);
    public sealed virtual IReadOnlyCollection`1<string> get_Aliases();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public sealed virtual string get_Description();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public void set_Description(string value);
    public virtual string get_Name();
    public virtual void set_Name(string value);
    private protected virtual void AddAliasInner(string alias);
    [NullableContextAttribute("2")]
private protected virtual void RemoveAlias(string alias);
    private protected abstract virtual string get_DefaultName();
    public sealed virtual ISymbolSet get_Parents();
    internal void AddParent(Symbol symbol);
    private protected virtual void AddSymbol(Symbol symbol);
    private protected void AddArgumentInner(Argument argument);
    [CompilerGeneratedAttribute]
public SymbolSet get_Children();
    public virtual bool HasAlias(string alias);
    [CompilerGeneratedAttribute]
public sealed virtual bool get_IsHidden();
    [CompilerGeneratedAttribute]
public void set_IsHidden(bool value);
    [NullableContextAttribute("2")]
public virtual IEnumerable`1<string> GetSuggestions(ParseResult parseResult, string textToMatch);
    public virtual string ToString();
    private sealed virtual override ISymbolSet System.CommandLine.ISymbol.get_Children();
    [DebuggerStepThroughAttribute]
private protected void ThrowIfAliasIsInvalid(string alias);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
public static class System.CommandLine.SymbolExtensions : object {
    [ExtensionAttribute]
internal static IEnumerable`1<IArgument> Arguments(ISymbol symbol);
    [ExtensionAttribute]
public static IEnumerable`1<string> GetSuggestions(ISymbol symbol, string textToMatch);
    [ExtensionAttribute]
public static ParseResult Parse(ISymbol symbol, string commandLine);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class System.CommandLine.ValidationMessages : object {
    [CompilerGeneratedAttribute]
private static ValidationMessages <Instance>k__BackingField;
    public static ValidationMessages Instance { get; }
    private static ValidationMessages();
    [CompilerGeneratedAttribute]
public static ValidationMessages get_Instance();
    public virtual string ExpectsOneArgument(SymbolResult symbolResult);
    public virtual string NoArgumentProvided(SymbolResult symbolResult);
    public virtual string ExpectsFewerArguments(Token token, int providedNumberOfValues, int maximumNumberOfValues);
    public virtual string DirectoryDoesNotExist(string path);
    public virtual string FileDoesNotExist(string filePath);
    public virtual string FileOrDirectoryDoesNotExist(string path);
    public virtual string InvalidCharactersInPath(char invalidChar);
    public virtual string RequiredArgumentMissing(SymbolResult symbolResult);
    public virtual string RequiredCommandWasNotProvided();
    public virtual string UnrecognizedArgument(string unrecognizedArg, IReadOnlyCollection`1<string> allowedValues);
    public virtual string UnrecognizedCommandOrArgument(string arg);
    public virtual string ResponseFileNotFound(string filePath);
    public virtual string ErrorReadingResponseFile(string filePath, IOException e);
}
[AttributeUsageAttribute("2432")]
internal class System.Diagnostics.CodeAnalysis.AllowNullAttribute : Attribute {
}
[AttributeUsageAttribute("2432")]
internal class System.Diagnostics.CodeAnalysis.DisallowNullAttribute : Attribute {
}
[AttributeUsageAttribute("64")]
internal class System.Diagnostics.CodeAnalysis.DoesNotReturnAttribute : Attribute {
}
[AttributeUsageAttribute("2048")]
internal class System.Diagnostics.CodeAnalysis.DoesNotReturnIfAttribute : Attribute {
    public bool ParameterValue { get; }
    public DoesNotReturnIfAttribute(bool parameterValue);
    public bool get_ParameterValue();
}
[AttributeUsageAttribute("749")]
internal class System.Diagnostics.CodeAnalysis.ExcludeFromCodeCoverageAttribute : Attribute {
}
[AttributeUsageAttribute("10624")]
internal class System.Diagnostics.CodeAnalysis.MaybeNullAttribute : Attribute {
}
[AttributeUsageAttribute("2048")]
internal class System.Diagnostics.CodeAnalysis.MaybeNullWhenAttribute : Attribute {
    public bool ReturnValue { get; }
    public MaybeNullWhenAttribute(bool returnValue);
    public bool get_ReturnValue();
}
[AttributeUsageAttribute("10624")]
internal class System.Diagnostics.CodeAnalysis.NotNullAttribute : Attribute {
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[AttributeUsageAttribute("10368")]
internal class System.Diagnostics.CodeAnalysis.NotNullIfNotNullAttribute : Attribute {
    public string ParameterName { get; }
    public NotNullIfNotNullAttribute(string parameterName);
    public string get_ParameterName();
}
[AttributeUsageAttribute("2048")]
internal class System.Diagnostics.CodeAnalysis.NotNullWhenAttribute : Attribute {
    public bool ReturnValue { get; }
    public NotNullWhenAttribute(bool returnValue);
    public bool get_ReturnValue();
}
[CompilerGeneratedAttribute]
[EmbeddedAttribute]
[AttributeUsageAttribute("27524")]
internal class System.Runtime.CompilerServices.NullableAttribute : Attribute {
    public Byte[] NullableFlags;
    public NullableAttribute(byte );
    public NullableAttribute(Byte[] );
}
[CompilerGeneratedAttribute]
[EmbeddedAttribute]
[AttributeUsageAttribute("5196")]
internal class System.Runtime.CompilerServices.NullableContextAttribute : Attribute {
    public byte Flag;
    public NullableContextAttribute(byte );
}
