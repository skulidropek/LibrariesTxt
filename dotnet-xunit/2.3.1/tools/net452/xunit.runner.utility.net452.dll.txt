[ExtensionAttribute]
internal static class AssemblyExtensions : object {
    [ExtensionAttribute]
public static string GetLocalCodeBase(Assembly assembly);
    public static string GetLocalCodeBase(string codeBase, char directorySeparator);
}
internal static class CommonTasks : object {
    internal static Task Completed;
    private static CommonTasks();
}
[ExtensionAttribute]
internal static class DictionaryExtensions : object {
    [ExtensionAttribute]
public static void Add(IDictionary`2<TKey, List`1<TValue>> dictionary, TKey key, TValue value);
    [ExtensionAttribute]
public static bool Contains(IDictionary`2<TKey, List`1<TValue>> dictionary, TKey key, TValue value, IEqualityComparer`1<TValue> valueComparer);
    [ExtensionAttribute]
public static TValue GetOrAdd(IDictionary`2<TKey, TValue> dictionary, TKey key);
    [ExtensionAttribute]
public static TValue GetOrAdd(IDictionary`2<TKey, TValue> dictionary, TKey key, Func`1<TValue> newValue);
    [ExtensionAttribute]
public static Dictionary`2<TKey, TValue> ToDictionaryIgnoringDuplicateKeys(IEnumerable`1<TValue> values, Func`2<TValue, TKey> keySelector, IEqualityComparer`1<TKey> comparer);
    [ExtensionAttribute]
public static Dictionary`2<TKey, TValue> ToDictionaryIgnoringDuplicateKeys(IEnumerable`1<TInput> inputValues, Func`2<TInput, TKey> keySelector, Func`2<TInput, TValue> valueSelector, IEqualityComparer`1<TKey> comparer);
}
[ExtensionAttribute]
internal static class DisposableExtensions : object {
    [ExtensionAttribute]
public static void SafeDispose(IDisposable disposable);
}
[ExtensionAttribute]
internal static class ExceptionExtensions : object {
    private static string RETHROW_MARKER;
    [ExtensionAttribute]
public static void RethrowWithNoStackTraceLoss(Exception ex);
    [ExtensionAttribute]
public static Exception Unwrap(Exception ex);
}
internal static class Guard : object {
    public static void ArgumentNotNull(string argName, object argValue);
    public static void ArgumentNotNullOrEmpty(string argName, IEnumerable argValue);
    public static void ArgumentValid(string argName, string message, bool test);
    public static void FileExists(string argName, string fileName);
}
internal static class Internal.Microsoft.DotNet.PlatformAbstractions.ApplicationEnvironment : object {
    [CompilerGeneratedAttribute]
private static string <ApplicationBasePath>k__BackingField;
    public static string ApplicationBasePath { get; }
    private static ApplicationEnvironment();
    [CompilerGeneratedAttribute]
public static string get_ApplicationBasePath();
    private static string GetApplicationBasePath();
}
internal class Internal.Microsoft.DotNet.PlatformAbstractions.HashCodeCombiner : ValueType {
    private long _combinedHash64;
    public int CombinedHash { get; }
    private HashCodeCombiner(long seed);
    public int get_CombinedHash();
    public void Add(int i);
    public void Add(string s);
    public void Add(object o);
    public void Add(TValue value, IEqualityComparer`1<TValue> comparer);
    public static HashCodeCombiner Start();
}
internal static class Internal.Microsoft.DotNet.PlatformAbstractions.Native.NativeMethods : object {
}
internal static class Internal.Microsoft.DotNet.PlatformAbstractions.Native.PlatformApis : object {
    private static Lazy`1<Platform> _platform;
    private static Lazy`1<DistroInfo> _distroInfo;
    private static PlatformApis();
    public static string GetOSName();
    public static string GetOSVersion();
    private static string GetDarwinVersion();
    public static Platform GetOSPlatform();
    private static string GetDistroId();
    private static string GetDistroVersionId();
    private static DistroInfo LoadDistroInfo();
    private static DistroInfo NormalizeDistroInfo(DistroInfo distroInfo);
    private static Platform DetermineOSPlatform();
}
internal enum Internal.Microsoft.DotNet.PlatformAbstractions.Platform : Enum {
    public int value__;
    public static Platform Unknown;
    public static Platform Windows;
    public static Platform Linux;
    public static Platform Darwin;
}
internal static class Internal.Microsoft.DotNet.PlatformAbstractions.RuntimeEnvironment : object {
    private static string OverrideEnvironmentVariableName;
    [CompilerGeneratedAttribute]
private static Platform <OperatingSystemPlatform>k__BackingField;
    [CompilerGeneratedAttribute]
private static string <OperatingSystemVersion>k__BackingField;
    [CompilerGeneratedAttribute]
private static string <OperatingSystem>k__BackingField;
    [CompilerGeneratedAttribute]
private static string <RuntimeArchitecture>k__BackingField;
    public static Platform OperatingSystemPlatform { get; }
    public static string OperatingSystemVersion { get; }
    public static string OperatingSystem { get; }
    public static string RuntimeArchitecture { get; }
    private static RuntimeEnvironment();
    [CompilerGeneratedAttribute]
public static Platform get_OperatingSystemPlatform();
    [CompilerGeneratedAttribute]
public static string get_OperatingSystemVersion();
    [CompilerGeneratedAttribute]
public static string get_OperatingSystem();
    [CompilerGeneratedAttribute]
public static string get_RuntimeArchitecture();
    private static string GetArch();
    public static string GetRuntimeIdentifier();
    private static string GetRIDArch();
    private static string GetRIDVersion();
    private static string GetWindowsProductVersion();
    private static string GetRIDOS();
}
internal class Internal.Microsoft.Extensions.DependencyModel.CompilationLibrary : Library {
    [CompilerGeneratedAttribute]
private IReadOnlyList`1<string> <Assemblies>k__BackingField;
    [CompilerGeneratedAttribute]
private static ICompilationAssemblyResolver <DefaultResolver>k__BackingField;
    public IReadOnlyList`1<string> Assemblies { get; }
    internal static ICompilationAssemblyResolver DefaultResolver { get; }
    public CompilationLibrary(string type, string name, string version, string hash, IEnumerable`1<string> assemblies, IEnumerable`1<Dependency> dependencies, bool serviceable);
    public CompilationLibrary(string type, string name, string version, string hash, IEnumerable`1<string> assemblies, IEnumerable`1<Dependency> dependencies, bool serviceable, string path, string hashPath);
    private static CompilationLibrary();
    [CompilerGeneratedAttribute]
public IReadOnlyList`1<string> get_Assemblies();
    [CompilerGeneratedAttribute]
internal static ICompilationAssemblyResolver get_DefaultResolver();
    public IEnumerable`1<string> ResolveReferencePaths();
    public IEnumerable`1<string> ResolveReferencePaths(ICompilationAssemblyResolver[] customResolvers);
    private IEnumerable`1<string> ResolveReferencePaths(ICompilationAssemblyResolver resolver, List`1<string> assemblies);
}
internal class Internal.Microsoft.Extensions.DependencyModel.CompilationOptions : object {
    [CompilerGeneratedAttribute]
private IReadOnlyList`1<string> <Defines>k__BackingField;
    [CompilerGeneratedAttribute]
private string <LanguageVersion>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Platform>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<bool> <AllowUnsafe>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<bool> <WarningsAsErrors>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<bool> <Optimize>k__BackingField;
    [CompilerGeneratedAttribute]
private string <KeyFile>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<bool> <DelaySign>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<bool> <PublicSign>k__BackingField;
    [CompilerGeneratedAttribute]
private string <DebugType>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<bool> <EmitEntryPoint>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<bool> <GenerateXmlDocumentation>k__BackingField;
    [CompilerGeneratedAttribute]
private static CompilationOptions <Default>k__BackingField;
    public IReadOnlyList`1<string> Defines { get; }
    public string LanguageVersion { get; }
    public string Platform { get; }
    public Nullable`1<bool> AllowUnsafe { get; }
    public Nullable`1<bool> WarningsAsErrors { get; }
    public Nullable`1<bool> Optimize { get; }
    public string KeyFile { get; }
    public Nullable`1<bool> DelaySign { get; }
    public Nullable`1<bool> PublicSign { get; }
    public string DebugType { get; }
    public Nullable`1<bool> EmitEntryPoint { get; }
    public Nullable`1<bool> GenerateXmlDocumentation { get; }
    public static CompilationOptions Default { get; }
    public CompilationOptions(IEnumerable`1<string> defines, string languageVersion, string platform, Nullable`1<bool> allowUnsafe, Nullable`1<bool> warningsAsErrors, Nullable`1<bool> optimize, string keyFile, Nullable`1<bool> delaySign, Nullable`1<bool> publicSign, string debugType, Nullable`1<bool> emitEntryPoint, Nullable`1<bool> generateXmlDocumentation);
    private static CompilationOptions();
    [CompilerGeneratedAttribute]
public IReadOnlyList`1<string> get_Defines();
    [CompilerGeneratedAttribute]
public string get_LanguageVersion();
    [CompilerGeneratedAttribute]
public string get_Platform();
    [CompilerGeneratedAttribute]
public Nullable`1<bool> get_AllowUnsafe();
    [CompilerGeneratedAttribute]
public Nullable`1<bool> get_WarningsAsErrors();
    [CompilerGeneratedAttribute]
public Nullable`1<bool> get_Optimize();
    [CompilerGeneratedAttribute]
public string get_KeyFile();
    [CompilerGeneratedAttribute]
public Nullable`1<bool> get_DelaySign();
    [CompilerGeneratedAttribute]
public Nullable`1<bool> get_PublicSign();
    [CompilerGeneratedAttribute]
public string get_DebugType();
    [CompilerGeneratedAttribute]
public Nullable`1<bool> get_EmitEntryPoint();
    [CompilerGeneratedAttribute]
public Nullable`1<bool> get_GenerateXmlDocumentation();
    [CompilerGeneratedAttribute]
public static CompilationOptions get_Default();
}
internal class Internal.Microsoft.Extensions.DependencyModel.Dependency : ValueType {
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Version>k__BackingField;
    public string Name { get; }
    public string Version { get; }
    public Dependency(string name, string version);
    [CompilerGeneratedAttribute]
public string get_Name();
    [CompilerGeneratedAttribute]
public string get_Version();
    public bool Equals(Dependency other);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
}
internal class Internal.Microsoft.Extensions.DependencyModel.DependencyContext : object {
    private static Lazy`1<DependencyContext> _defaultContext;
    [CompilerGeneratedAttribute]
private TargetInfo <Target>k__BackingField;
    [CompilerGeneratedAttribute]
private CompilationOptions <CompilationOptions>k__BackingField;
    [CompilerGeneratedAttribute]
private IReadOnlyList`1<CompilationLibrary> <CompileLibraries>k__BackingField;
    [CompilerGeneratedAttribute]
private IReadOnlyList`1<RuntimeLibrary> <RuntimeLibraries>k__BackingField;
    [CompilerGeneratedAttribute]
private IReadOnlyList`1<RuntimeFallbacks> <RuntimeGraph>k__BackingField;
    public static DependencyContext Default { get; }
    public TargetInfo Target { get; }
    public CompilationOptions CompilationOptions { get; }
    public IReadOnlyList`1<CompilationLibrary> CompileLibraries { get; }
    public IReadOnlyList`1<RuntimeLibrary> RuntimeLibraries { get; }
    public IReadOnlyList`1<RuntimeFallbacks> RuntimeGraph { get; }
    public DependencyContext(TargetInfo target, CompilationOptions compilationOptions, IEnumerable`1<CompilationLibrary> compileLibraries, IEnumerable`1<RuntimeLibrary> runtimeLibraries, IEnumerable`1<RuntimeFallbacks> runtimeGraph);
    private static DependencyContext();
    public static DependencyContext get_Default();
    [CompilerGeneratedAttribute]
public TargetInfo get_Target();
    [CompilerGeneratedAttribute]
public CompilationOptions get_CompilationOptions();
    [CompilerGeneratedAttribute]
public IReadOnlyList`1<CompilationLibrary> get_CompileLibraries();
    [CompilerGeneratedAttribute]
public IReadOnlyList`1<RuntimeLibrary> get_RuntimeLibraries();
    [CompilerGeneratedAttribute]
public IReadOnlyList`1<RuntimeFallbacks> get_RuntimeGraph();
    public DependencyContext Merge(DependencyContext other);
    private static DependencyContext LoadDefault();
    public static DependencyContext Load(Assembly assembly);
}
[ExtensionAttribute]
internal static class Internal.Microsoft.Extensions.DependencyModel.DependencyContextExtensions : object {
    private static string NativeImageSufix;
    [ExtensionAttribute]
public static IEnumerable`1<string> GetDefaultNativeAssets(DependencyContext self);
    [ExtensionAttribute]
public static IEnumerable`1<string> GetRuntimeNativeAssets(DependencyContext self, string runtimeIdentifier);
    [ExtensionAttribute]
public static IEnumerable`1<string> GetDefaultNativeAssets(RuntimeLibrary self, DependencyContext context);
    [ExtensionAttribute]
public static IEnumerable`1<string> GetRuntimeNativeAssets(RuntimeLibrary self, DependencyContext context, string runtimeIdentifier);
    [ExtensionAttribute]
public static IEnumerable`1<AssemblyName> GetDefaultAssemblyNames(DependencyContext self);
    [ExtensionAttribute]
public static IEnumerable`1<AssemblyName> GetRuntimeAssemblyNames(DependencyContext self, string runtimeIdentifier);
    [ExtensionAttribute]
public static IEnumerable`1<AssemblyName> GetDefaultAssemblyNames(RuntimeLibrary self, DependencyContext context);
    [ExtensionAttribute]
public static IEnumerable`1<AssemblyName> GetRuntimeAssemblyNames(RuntimeLibrary self, DependencyContext context, string runtimeIdentifier);
    private static AssemblyName GetAssemblyName(string assetPath);
    private static IEnumerable`1<string> ResolveAssets(DependencyContext context, string runtimeIdentifier, IEnumerable`1<RuntimeAssetGroup> assets);
    private static IEnumerable`1<string> SelectAssets(IEnumerable`1<string> rids, IEnumerable`1<RuntimeAssetGroup> groups);
}
internal class Internal.Microsoft.Extensions.DependencyModel.DependencyContextJsonReader : object {
    private static String[] EmptyStringArray;
    private IDictionary`2<string, string> _stringPool;
    private static DependencyContextJsonReader();
    public sealed virtual DependencyContext Read(Stream stream);
    protected virtual void Dispose(bool disposing);
    public sealed virtual void Dispose();
    private DependencyContext Read(TextReader reader);
    private Target SelectRuntimeTarget(List`1<Target> targets, string runtimeTargetName);
    private bool IsRuntimeTarget(string name);
    private void ReadRuntimeTarget(JsonObject runtimeTargetJson, String& runtimeTargetName, String& runtimeSignature);
    private CompilationOptions ReadCompilationOptions(JsonObject compilationOptionsJson);
    private List`1<Target> ReadTargets(JsonObject targetsJson);
    private Target ReadTarget(string targetName, JsonObject targetJson);
    private TargetLibrary ReadTargetLibrary(string targetLibraryName, JsonObject targetLibraryJson);
    public IEnumerable`1<Dependency> ReadTargetLibraryDependencies(JsonObject targetLibraryDependenciesJson);
    private List`1<RuntimeTargetEntryStub> ReadTargetLibraryRuntimeTargets(JsonObject targetLibraryRuntimeTargetsJson);
    private List`1<ResourceAssembly> ReadTargetLibraryResources(JsonObject targetLibraryResourcesJson);
    private Dictionary`2<string, LibraryStub> ReadLibraries(JsonObject librariesJson);
    private LibraryStub ReadLibrary(JsonObject libraryJson);
    private List`1<RuntimeFallbacks> ReadRuntimes(JsonObject runtimesJson);
    private IEnumerable`1<Library> CreateLibraries(IEnumerable`1<TargetLibrary> libraries, bool runtime, Dictionary`2<string, LibraryStub> libraryStubs);
    private Library CreateLibrary(TargetLibrary targetLibrary, bool runtime, Dictionary`2<string, LibraryStub> libraryStubs);
    private string Pool(string s);
    [CompilerGeneratedAttribute]
private bool <Read>b__5_0(Target t);
    [CompilerGeneratedAttribute]
private bool <SelectRuntimeTarget>b__6_1(Target t);
}
internal class Internal.Microsoft.Extensions.DependencyModel.DependencyContextLoader : object {
    private static string DepsJsonExtension;
    private string _entryPointDepsLocation;
    private IEnumerable`1<string> _nonEntryPointDepsPaths;
    private IFileSystem _fileSystem;
    private Func`1<IDependencyContextReader> _jsonReaderFactory;
    [CompilerGeneratedAttribute]
private static DependencyContextLoader <Default>k__BackingField;
    public static DependencyContextLoader Default { get; }
    internal DependencyContextLoader(string entryPointDepsLocation, IEnumerable`1<string> nonEntryPointDepsPaths, IFileSystem fileSystem, Func`1<IDependencyContextReader> jsonReaderFactory);
    private static DependencyContextLoader();
    [CompilerGeneratedAttribute]
public static DependencyContextLoader get_Default();
    private static bool IsEntryAssembly(Assembly assembly);
    private static Stream GetResourceStream(Assembly assembly, string name);
    public DependencyContext Load(Assembly assembly);
    private DependencyContext LoadEntryAssemblyContext(IDependencyContextReader reader);
    private DependencyContext LoadContext(IDependencyContextReader reader, string location);
    private DependencyContext LoadAssemblyContext(Assembly assembly, IDependencyContextReader reader);
}
internal class Internal.Microsoft.Extensions.DependencyModel.DependencyContextPaths : object {
    private static string DepsFilesProperty;
    private static string FxDepsFileProperty;
    [CompilerGeneratedAttribute]
private static DependencyContextPaths <Current>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Application>k__BackingField;
    [CompilerGeneratedAttribute]
private string <SharedRuntime>k__BackingField;
    [CompilerGeneratedAttribute]
private IEnumerable`1<string> <NonApplicationPaths>k__BackingField;
    public static DependencyContextPaths Current { get; }
    public string Application { get; }
    public string SharedRuntime { get; }
    public IEnumerable`1<string> NonApplicationPaths { get; }
    public DependencyContextPaths(string application, string sharedRuntime, IEnumerable`1<string> nonApplicationPaths);
    private static DependencyContextPaths();
    [CompilerGeneratedAttribute]
public static DependencyContextPaths get_Current();
    [CompilerGeneratedAttribute]
public string get_Application();
    [CompilerGeneratedAttribute]
public string get_SharedRuntime();
    [CompilerGeneratedAttribute]
public IEnumerable`1<string> get_NonApplicationPaths();
    private static DependencyContextPaths GetCurrent();
    internal static DependencyContextPaths Create(string depsFiles, string sharedRuntime);
}
internal class Internal.Microsoft.Extensions.DependencyModel.DependencyContextStrings : object {
    internal static char VersionSeperator;
    internal static string CompileTimeAssembliesKey;
    internal static string RuntimeAssembliesKey;
    internal static string NativeLibrariesKey;
    internal static string RuntimeTargetPropertyName;
    internal static string LibrariesPropertyName;
    internal static string TargetsPropertyName;
    internal static string DependenciesPropertyName;
    internal static string Sha512PropertyName;
    internal static string PathPropertyName;
    internal static string HashPathPropertyName;
    internal static string RuntimeStoreManifestPropertyName;
    internal static string TypePropertyName;
    internal static string ServiceablePropertyName;
    internal static string CompilationOptionsPropertName;
    internal static string DefinesPropertyName;
    internal static string LanguageVersionPropertyName;
    internal static string PlatformPropertyName;
    internal static string AllowUnsafePropertyName;
    internal static string WarningsAsErrorsPropertyName;
    internal static string OptimizePropertyName;
    internal static string KeyFilePropertyName;
    internal static string DelaySignPropertyName;
    internal static string PublicSignPropertyName;
    internal static string DebugTypePropertyName;
    internal static string EmitEntryPointPropertyName;
    internal static string GenerateXmlDocumentationPropertyName;
    internal static string PortablePropertyName;
    internal static string RuntimeTargetNamePropertyName;
    internal static string RuntimeTargetSignaturePropertyName;
    internal static string RuntimesPropertyName;
    internal static string RuntimeTargetsPropertyName;
    internal static string RidPropertyName;
    internal static string AssetTypePropertyName;
    internal static string RuntimeAssetType;
    internal static string NativeAssetType;
    internal static string ResourceAssembliesPropertyName;
    internal static string LocalePropertyName;
    internal static string CompilationOnlyPropertyName;
}
internal class Internal.Microsoft.Extensions.DependencyModel.DirectoryWrapper : object {
    public sealed virtual bool Exists(string path);
}
internal class Internal.Microsoft.Extensions.DependencyModel.EnvironmentWrapper : object {
    public static IEnvironment Default;
    private static EnvironmentWrapper();
    public sealed virtual string GetEnvironmentVariable(string name);
}
internal class Internal.Microsoft.Extensions.DependencyModel.FileSystemWrapper : object {
    [CompilerGeneratedAttribute]
private static IFileSystem <Default>k__BackingField;
    [CompilerGeneratedAttribute]
private IFile <File>k__BackingField;
    [CompilerGeneratedAttribute]
private IDirectory <Directory>k__BackingField;
    public static IFileSystem Default { get; }
    public IFile File { get; }
    public IDirectory Directory { get; }
    private static FileSystemWrapper();
    [CompilerGeneratedAttribute]
public static IFileSystem get_Default();
    [CompilerGeneratedAttribute]
public sealed virtual IFile get_File();
    [CompilerGeneratedAttribute]
public sealed virtual IDirectory get_Directory();
}
internal class Internal.Microsoft.Extensions.DependencyModel.FileWrapper : object {
    public sealed virtual bool Exists(string path);
    public sealed virtual string ReadAllText(string path);
    public sealed virtual Stream OpenRead(string path);
    public sealed virtual Stream OpenFile(string path, FileMode fileMode, FileAccess fileAccess, FileShare fileShare, int bufferSize, FileOptions fileOptions);
    public sealed virtual void CreateEmptyFile(string path);
}
internal interface Internal.Microsoft.Extensions.DependencyModel.IDependencyContextReader {
    public abstract virtual DependencyContext Read(Stream stream);
}
internal interface Internal.Microsoft.Extensions.DependencyModel.IDirectory {
    public abstract virtual bool Exists(string path);
}
internal interface Internal.Microsoft.Extensions.DependencyModel.IEnvironment {
    public abstract virtual string GetEnvironmentVariable(string name);
}
internal interface Internal.Microsoft.Extensions.DependencyModel.IFile {
    public abstract virtual bool Exists(string path);
    public abstract virtual string ReadAllText(string path);
    public abstract virtual Stream OpenRead(string path);
    public abstract virtual Stream OpenFile(string path, FileMode fileMode, FileAccess fileAccess, FileShare fileShare, int bufferSize, FileOptions fileOptions);
    public abstract virtual void CreateEmptyFile(string path);
}
internal interface Internal.Microsoft.Extensions.DependencyModel.IFileSystem {
    public IFile File { get; }
    public IDirectory Directory { get; }
    public abstract virtual IFile get_File();
    public abstract virtual IDirectory get_Directory();
}
internal class Internal.Microsoft.Extensions.DependencyModel.Library : object {
    [CompilerGeneratedAttribute]
private string <Type>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Version>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Hash>k__BackingField;
    [CompilerGeneratedAttribute]
private IReadOnlyList`1<Dependency> <Dependencies>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <Serviceable>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Path>k__BackingField;
    [CompilerGeneratedAttribute]
private string <HashPath>k__BackingField;
    [CompilerGeneratedAttribute]
private string <RuntimeStoreManifestName>k__BackingField;
    public string Type { get; }
    public string Name { get; }
    public string Version { get; }
    public string Hash { get; }
    public IReadOnlyList`1<Dependency> Dependencies { get; }
    public bool Serviceable { get; }
    public string Path { get; }
    public string HashPath { get; }
    public string RuntimeStoreManifestName { get; }
    public Library(string type, string name, string version, string hash, IEnumerable`1<Dependency> dependencies, bool serviceable);
    public Library(string type, string name, string version, string hash, IEnumerable`1<Dependency> dependencies, bool serviceable, string path, string hashPath);
    public Library(string type, string name, string version, string hash, IEnumerable`1<Dependency> dependencies, bool serviceable, string path, string hashPath, string runtimeStoreManifestName);
    [CompilerGeneratedAttribute]
public string get_Type();
    [CompilerGeneratedAttribute]
public string get_Name();
    [CompilerGeneratedAttribute]
public string get_Version();
    [CompilerGeneratedAttribute]
public string get_Hash();
    [CompilerGeneratedAttribute]
public IReadOnlyList`1<Dependency> get_Dependencies();
    [CompilerGeneratedAttribute]
public bool get_Serviceable();
    [CompilerGeneratedAttribute]
public string get_Path();
    [CompilerGeneratedAttribute]
public string get_HashPath();
    [CompilerGeneratedAttribute]
public string get_RuntimeStoreManifestName();
}
internal class Internal.Microsoft.Extensions.DependencyModel.Resolution.AppBaseCompilationAssemblyResolver : object {
    private static string RefsDirectoryName;
    private IFileSystem _fileSystem;
    private string _basePath;
    private DependencyContextPaths _dependencyContextPaths;
    public AppBaseCompilationAssemblyResolver(string basePath);
    internal AppBaseCompilationAssemblyResolver(IFileSystem fileSystem);
    internal AppBaseCompilationAssemblyResolver(IFileSystem fileSystem, string basePath, DependencyContextPaths dependencyContextPaths);
    private static AppBaseCompilationAssemblyResolver();
    public sealed virtual bool TryResolveAssemblyPaths(CompilationLibrary library, List`1<string> assemblies);
}
internal class Internal.Microsoft.Extensions.DependencyModel.Resolution.CompositeCompilationAssemblyResolver : object {
    private ICompilationAssemblyResolver[] _resolvers;
    public CompositeCompilationAssemblyResolver(ICompilationAssemblyResolver[] resolvers);
    public sealed virtual bool TryResolveAssemblyPaths(CompilationLibrary library, List`1<string> assemblies);
}
internal class Internal.Microsoft.Extensions.DependencyModel.Resolution.DotNetReferenceAssembliesPathResolver : object {
    public static string DotNetReferenceAssembliesPathEnv;
    private static DotNetReferenceAssembliesPathResolver();
    internal static string Resolve(IEnvironment envirnment, IFileSystem fileSystem);
    public static string Resolve();
    private static string GetDefaultDotNetReferenceAssembliesPath(IFileSystem fileSystem);
}
internal interface Internal.Microsoft.Extensions.DependencyModel.Resolution.ICompilationAssemblyResolver {
    public abstract virtual bool TryResolveAssemblyPaths(CompilationLibrary library, List`1<string> assemblies);
}
internal class Internal.Microsoft.Extensions.DependencyModel.Resolution.PackageCompilationAssemblyResolver : object {
    private IFileSystem _fileSystem;
    private String[] _nugetPackageDirectories;
    public PackageCompilationAssemblyResolver(string nugetPackageDirectory);
    internal PackageCompilationAssemblyResolver(IEnvironment environment, IFileSystem fileSystem);
    internal PackageCompilationAssemblyResolver(IFileSystem fileSystem, String[] nugetPackageDirectories);
    private static String[] GetDefaultProbeDirectories(IEnvironment environment);
    internal static String[] GetDefaultProbeDirectories(Platform osPlatform, IEnvironment environment);
    public sealed virtual bool TryResolveAssemblyPaths(CompilationLibrary library, List`1<string> assemblies);
    private static bool TryResolveFromPackagePath(IFileSystem fileSystem, CompilationLibrary library, string basePath, IEnumerable`1& results);
}
internal class Internal.Microsoft.Extensions.DependencyModel.Resolution.ReferenceAssemblyPathResolver : object {
    private IFileSystem _fileSystem;
    private string _defaultReferenceAssembliesPath;
    private String[] _fallbackSearchPaths;
    public ReferenceAssemblyPathResolver(string defaultReferenceAssembliesPath, String[] fallbackSearchPaths);
    internal ReferenceAssemblyPathResolver(IFileSystem fileSystem, IEnvironment environment);
    internal ReferenceAssemblyPathResolver(IFileSystem fileSystem, string defaultReferenceAssembliesPath, String[] fallbackSearchPaths);
    public sealed virtual bool TryResolveAssemblyPaths(CompilationLibrary library, List`1<string> assemblies);
    private bool TryResolveReferenceAssembly(string path, String& fullPath);
    internal static String[] GetFallbackSearchPaths(IFileSystem fileSystem, Platform platform, IEnvironment environment);
    internal static string GetDefaultReferenceAssembliesPath(IFileSystem fileSystem, Platform platform, IEnvironment environment);
}
internal static class Internal.Microsoft.Extensions.DependencyModel.Resolution.ResolverUtils : object {
    internal static bool TryResolvePackagePath(IFileSystem fileSystem, CompilationLibrary library, string basePath, String& packagePath);
    internal static bool TryResolveAssemblyFile(IFileSystem fileSystem, string basePath, string assemblyPath, String& fullName);
}
internal class Internal.Microsoft.Extensions.DependencyModel.ResourceAssembly : object {
    [CompilerGeneratedAttribute]
private string <Locale>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Path>k__BackingField;
    public string Locale { get; public set; }
    public string Path { get; public set; }
    public ResourceAssembly(string path, string locale);
    [CompilerGeneratedAttribute]
public string get_Locale();
    [CompilerGeneratedAttribute]
public void set_Locale(string value);
    [CompilerGeneratedAttribute]
public string get_Path();
    [CompilerGeneratedAttribute]
public void set_Path(string value);
}
internal class Internal.Microsoft.Extensions.DependencyModel.RuntimeAssembly : object {
    private static string NativeImageSufix;
    private string _assemblyName;
    [CompilerGeneratedAttribute]
private string <Path>k__BackingField;
    public AssemblyName Name { get; }
    public string Path { get; }
    public RuntimeAssembly(string assemblyName, string path);
    public AssemblyName get_Name();
    [CompilerGeneratedAttribute]
public string get_Path();
    public static RuntimeAssembly Create(string path);
}
internal class Internal.Microsoft.Extensions.DependencyModel.RuntimeAssetGroup : object {
    [CompilerGeneratedAttribute]
private string <Runtime>k__BackingField;
    [CompilerGeneratedAttribute]
private IReadOnlyList`1<string> <AssetPaths>k__BackingField;
    public string Runtime { get; }
    public IReadOnlyList`1<string> AssetPaths { get; }
    public RuntimeAssetGroup(string runtime, String[] assetPaths);
    public RuntimeAssetGroup(string runtime, IEnumerable`1<string> assetPaths);
    [CompilerGeneratedAttribute]
public string get_Runtime();
    [CompilerGeneratedAttribute]
public IReadOnlyList`1<string> get_AssetPaths();
}
internal class Internal.Microsoft.Extensions.DependencyModel.RuntimeFallbacks : object {
    [CompilerGeneratedAttribute]
private string <Runtime>k__BackingField;
    [CompilerGeneratedAttribute]
private IReadOnlyList`1<string> <Fallbacks>k__BackingField;
    public string Runtime { get; public set; }
    public IReadOnlyList`1<string> Fallbacks { get; public set; }
    public RuntimeFallbacks(string runtime, String[] fallbacks);
    public RuntimeFallbacks(string runtime, IEnumerable`1<string> fallbacks);
    [CompilerGeneratedAttribute]
public string get_Runtime();
    [CompilerGeneratedAttribute]
public void set_Runtime(string value);
    [CompilerGeneratedAttribute]
public IReadOnlyList`1<string> get_Fallbacks();
    [CompilerGeneratedAttribute]
public void set_Fallbacks(IReadOnlyList`1<string> value);
}
internal class Internal.Microsoft.Extensions.DependencyModel.RuntimeLibrary : Library {
    [CompilerGeneratedAttribute]
private IReadOnlyList`1<RuntimeAssetGroup> <RuntimeAssemblyGroups>k__BackingField;
    [CompilerGeneratedAttribute]
private IReadOnlyList`1<RuntimeAssetGroup> <NativeLibraryGroups>k__BackingField;
    [CompilerGeneratedAttribute]
private IReadOnlyList`1<ResourceAssembly> <ResourceAssemblies>k__BackingField;
    public IReadOnlyList`1<RuntimeAssetGroup> RuntimeAssemblyGroups { get; }
    public IReadOnlyList`1<RuntimeAssetGroup> NativeLibraryGroups { get; }
    public IReadOnlyList`1<ResourceAssembly> ResourceAssemblies { get; }
    public RuntimeLibrary(string type, string name, string version, string hash, IReadOnlyList`1<RuntimeAssetGroup> runtimeAssemblyGroups, IReadOnlyList`1<RuntimeAssetGroup> nativeLibraryGroups, IEnumerable`1<ResourceAssembly> resourceAssemblies, IEnumerable`1<Dependency> dependencies, bool serviceable);
    public RuntimeLibrary(string type, string name, string version, string hash, IReadOnlyList`1<RuntimeAssetGroup> runtimeAssemblyGroups, IReadOnlyList`1<RuntimeAssetGroup> nativeLibraryGroups, IEnumerable`1<ResourceAssembly> resourceAssemblies, IEnumerable`1<Dependency> dependencies, bool serviceable, string path, string hashPath);
    public RuntimeLibrary(string type, string name, string version, string hash, IReadOnlyList`1<RuntimeAssetGroup> runtimeAssemblyGroups, IReadOnlyList`1<RuntimeAssetGroup> nativeLibraryGroups, IEnumerable`1<ResourceAssembly> resourceAssemblies, IEnumerable`1<Dependency> dependencies, bool serviceable, string path, string hashPath, string runtimeStoreManifestName);
    [CompilerGeneratedAttribute]
public IReadOnlyList`1<RuntimeAssetGroup> get_RuntimeAssemblyGroups();
    [CompilerGeneratedAttribute]
public IReadOnlyList`1<RuntimeAssetGroup> get_NativeLibraryGroups();
    [CompilerGeneratedAttribute]
public IReadOnlyList`1<ResourceAssembly> get_ResourceAssemblies();
}
internal class Internal.Microsoft.Extensions.DependencyModel.TargetInfo : object {
    [CompilerGeneratedAttribute]
private string <Framework>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Runtime>k__BackingField;
    [CompilerGeneratedAttribute]
private string <RuntimeSignature>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsPortable>k__BackingField;
    public string Framework { get; }
    public string Runtime { get; }
    public string RuntimeSignature { get; }
    public bool IsPortable { get; }
    public TargetInfo(string framework, string runtime, string runtimeSignature, bool isPortable);
    [CompilerGeneratedAttribute]
public string get_Framework();
    [CompilerGeneratedAttribute]
public string get_Runtime();
    [CompilerGeneratedAttribute]
public string get_RuntimeSignature();
    [CompilerGeneratedAttribute]
public bool get_IsPortable();
}
[ExtensionAttribute]
public static class IRunnerLoggerExtensions : object {
    [ExtensionAttribute]
public static void LogMessage(IRunnerLogger logger, string message);
    [ExtensionAttribute]
public static void LogMessage(IRunnerLogger logger, string messageFormat, Object[] args);
    [ExtensionAttribute]
public static void LogMessage(IRunnerLogger logger, StackFrameInfo stackFrame, string messageFormat, Object[] args);
    [ExtensionAttribute]
public static void LogImportantMessage(IRunnerLogger logger, string message);
    [ExtensionAttribute]
public static void LogImportantMessage(IRunnerLogger logger, string messageFormat, Object[] args);
    [ExtensionAttribute]
public static void LogImportantMessage(IRunnerLogger logger, StackFrameInfo stackFrame, string messageFormat, Object[] args);
    [ExtensionAttribute]
public static void LogWarning(IRunnerLogger logger, string message);
    [ExtensionAttribute]
public static void LogWarning(IRunnerLogger logger, string messageFormat, Object[] args);
    [ExtensionAttribute]
public static void LogWarning(IRunnerLogger logger, StackFrameInfo stackFrame, string messageFormat, Object[] args);
    [ExtensionAttribute]
public static void LogError(IRunnerLogger logger, string message);
    [ExtensionAttribute]
public static void LogError(IRunnerLogger logger, string messageFormat, Object[] args);
    [ExtensionAttribute]
public static void LogError(IRunnerLogger logger, StackFrameInfo stackFrame, string messageFormat, Object[] args);
}
[ExtensionAttribute]
public static class MessageSinkMessageExtensions : object {
    [ExtensionAttribute]
public static TMessage Cast(IMessageSinkMessage message, HashSet`1<string> typeNames);
    [ExtensionAttribute]
public static bool Dispatch(IMessageSinkMessage message, HashSet`1<string> messageTypes, MessageHandler`1<TMessage> callback);
}
[ExtensionAttribute]
public static class MessageSinkWithTypesExtensions : object {
    [ExtensionAttribute]
public static bool OnMessage(IMessageSinkWithTypes messageSink, IMessageSinkMessage message);
}
[ExtensionAttribute]
internal static class NewReflectionExtensions : object {
    [ExtensionAttribute]
public static Assembly GetAssembly(Type type);
    [ExtensionAttribute]
public static Attribute[] GetCustomAttributes(Assembly assembly);
    [ExtensionAttribute]
public static bool IsEnum(Type type);
    [ExtensionAttribute]
public static bool IsFromLocalAssembly(Type type);
    [ExtensionAttribute]
public static bool IsGenericType(Type type);
    [ExtensionAttribute]
public static bool IsGenericTypeDefinition(Type type);
    [ExtensionAttribute]
public static bool IsNullableEnum(Type type);
    [ExtensionAttribute]
public static bool IsValueType(Type type);
    [ExtensionAttribute]
public static Type UnwrapNullable(Type type);
    [ExtensionAttribute]
public static Type[] GetGenericArguments(Type type);
    [ExtensionAttribute]
public static Type[] GetInterfaces(Type type);
    [ExtensionAttribute]
public static bool IsAssignableFrom(Type type, Type otherType);
}
[ExtensionAttribute]
internal static class System.Collections.Generic.CollectionExtensions : object {
    [ExtensionAttribute]
public static RuntimeAssetGroup GetDefaultGroup(IEnumerable`1<RuntimeAssetGroup> self);
    [ExtensionAttribute]
public static RuntimeAssetGroup GetRuntimeGroup(IEnumerable`1<RuntimeAssetGroup> self, string runtime);
    private static RuntimeAssetGroup GetGroup(IEnumerable`1<RuntimeAssetGroup> groups, string runtime);
    [ExtensionAttribute]
public static IEnumerable`1<string> GetDefaultAssets(IEnumerable`1<RuntimeAssetGroup> self);
    [ExtensionAttribute]
public static IEnumerable`1<string> GetRuntimeAssets(IEnumerable`1<RuntimeAssetGroup> self, string runtime);
    private static IEnumerable`1<string> GetAssets(IEnumerable`1<RuntimeAssetGroup> groups, string runtime);
}
[ExtensionAttribute]
public static class TestFrameworkExtensions : object {
    [ExtensionAttribute]
public static void Find(ITestFrameworkDiscoverer discoverer, bool includeSourceInformation, IMessageSinkWithTypes discoveryMessageSink, ITestFrameworkDiscoveryOptions discoveryOptions);
    [ExtensionAttribute]
public static void Find(ITestFrameworkDiscoverer discoverer, string typeName, bool includeSourceInformation, IMessageSinkWithTypes discoveryMessageSink, ITestFrameworkDiscoveryOptions discoveryOptions);
    [ExtensionAttribute]
public static void RunAll(ITestFrameworkExecutor executor, IMessageSinkWithTypes executionMessageSink, ITestFrameworkDiscoveryOptions discoveryOptions, ITestFrameworkExecutionOptions executionOptions);
    [ExtensionAttribute]
public static void RunTests(ITestFrameworkExecutor executor, IEnumerable`1<ITestCase> testCases, IMessageSinkWithTypes executionMessageSink, ITestFrameworkExecutionOptions executionOptions);
}
[ExtensionAttribute]
public static class TestFrameworkOptionsReadWriteExtensions : object {
    [ExtensionAttribute]
public static Nullable`1<bool> GetDiagnosticMessages(ITestFrameworkDiscoveryOptions discoveryOptions);
    [ExtensionAttribute]
public static Nullable`1<bool> GetInternalDiagnosticMessages(ITestFrameworkDiscoveryOptions discoveryOptions);
    [ExtensionAttribute]
public static bool GetDiagnosticMessagesOrDefault(ITestFrameworkDiscoveryOptions discoveryOptions);
    [ExtensionAttribute]
public static bool GetInternalDiagnosticMessagesOrDefault(ITestFrameworkDiscoveryOptions discoveryOptions);
    [ExtensionAttribute]
public static Nullable`1<TestMethodDisplay> GetMethodDisplay(ITestFrameworkDiscoveryOptions discoveryOptions);
    [ExtensionAttribute]
public static TestMethodDisplay GetMethodDisplayOrDefault(ITestFrameworkDiscoveryOptions discoveryOptions);
    [ExtensionAttribute]
public static Nullable`1<bool> GetPreEnumerateTheories(ITestFrameworkDiscoveryOptions discoveryOptions);
    [ExtensionAttribute]
public static bool GetPreEnumerateTheoriesOrDefault(ITestFrameworkDiscoveryOptions discoveryOptions);
    [ExtensionAttribute]
public static Nullable`1<bool> GetSynchronousMessageReporting(ITestFrameworkDiscoveryOptions discoveryOptions);
    [ExtensionAttribute]
public static bool GetSynchronousMessageReportingOrDefault(ITestFrameworkDiscoveryOptions discoveryOptions);
    [ExtensionAttribute]
public static void SetDiagnosticMessages(ITestFrameworkDiscoveryOptions discoveryOptions, Nullable`1<bool> value);
    [ExtensionAttribute]
public static void SetInternalDiagnosticMessages(ITestFrameworkDiscoveryOptions discoveryOptions, Nullable`1<bool> value);
    [ExtensionAttribute]
public static void SetMethodDisplay(ITestFrameworkDiscoveryOptions discoveryOptions, Nullable`1<TestMethodDisplay> value);
    [ExtensionAttribute]
public static void SetPreEnumerateTheories(ITestFrameworkDiscoveryOptions discoveryOptions, Nullable`1<bool> value);
    [ExtensionAttribute]
public static void SetSynchronousMessageReporting(ITestFrameworkDiscoveryOptions discoveryOptions, Nullable`1<bool> value);
    [ExtensionAttribute]
public static Nullable`1<bool> GetDiagnosticMessages(ITestFrameworkExecutionOptions executionOptions);
    [ExtensionAttribute]
public static Nullable`1<bool> GetInternalDiagnosticMessages(ITestFrameworkExecutionOptions executionOptions);
    [ExtensionAttribute]
public static bool GetDiagnosticMessagesOrDefault(ITestFrameworkExecutionOptions executionOptions);
    [ExtensionAttribute]
public static bool GetInternalDiagnosticMessagesOrDefault(ITestFrameworkExecutionOptions executionOptions);
    [ExtensionAttribute]
public static Nullable`1<bool> GetDisableParallelization(ITestFrameworkExecutionOptions executionOptions);
    [ExtensionAttribute]
public static bool GetDisableParallelizationOrDefault(ITestFrameworkExecutionOptions executionOptions);
    [ExtensionAttribute]
public static Nullable`1<int> GetMaxParallelThreads(ITestFrameworkExecutionOptions executionOptions);
    [ExtensionAttribute]
public static int GetMaxParallelThreadsOrDefault(ITestFrameworkExecutionOptions executionOptions);
    [ExtensionAttribute]
public static Nullable`1<bool> GetSynchronousMessageReporting(ITestFrameworkExecutionOptions executionOptions);
    [ExtensionAttribute]
public static bool GetSynchronousMessageReportingOrDefault(ITestFrameworkExecutionOptions executionOptions);
    [ExtensionAttribute]
public static void SetDiagnosticMessages(ITestFrameworkExecutionOptions executionOptions, Nullable`1<bool> value);
    [ExtensionAttribute]
public static void SetInternalDiagnosticMessages(ITestFrameworkExecutionOptions executionOptions, Nullable`1<bool> value);
    [ExtensionAttribute]
public static void SetStopOnTestFail(ITestFrameworkExecutionOptions executionOptions, Nullable`1<bool> value);
    [ExtensionAttribute]
public static void SetDisableParallelization(ITestFrameworkExecutionOptions executionOptions, Nullable`1<bool> value);
    [ExtensionAttribute]
public static void SetMaxParallelThreads(ITestFrameworkExecutionOptions executionOptions, Nullable`1<int> value);
    [ExtensionAttribute]
public static void SetSynchronousMessageReporting(ITestFrameworkExecutionOptions executionOptions, Nullable`1<bool> value);
}
internal static class TestOptionsNames : object {
}
[ExtensionAttribute]
internal static class XmlNodeExtensions : object {
    [ExtensionAttribute]
public static Xunit1TestCase ToTestCase(XmlNode xml, string assemblyFileName, string configFileName);
}
public class Xunit.AfterTestFinished : TestMessage {
    [CompilerGeneratedAttribute]
private string <AttributeName>k__BackingField;
    public string AttributeName { get; private set; }
    public AfterTestFinished(ITest test, string attributeName);
    [CompilerGeneratedAttribute]
public sealed virtual string get_AttributeName();
    [CompilerGeneratedAttribute]
private void set_AttributeName(string value);
}
public class Xunit.AfterTestStarting : TestMessage {
    [CompilerGeneratedAttribute]
private string <AttributeName>k__BackingField;
    public string AttributeName { get; private set; }
    public AfterTestStarting(ITest test, string attributeName);
    [CompilerGeneratedAttribute]
public sealed virtual string get_AttributeName();
    [CompilerGeneratedAttribute]
private void set_AttributeName(string value);
}
public class Xunit.AggregateMessageSink : LongLivedMarshalByRefObject {
    [CompilerGeneratedAttribute]
private List`1<IMessageSinkWithTypes> <AggregatedSinks>k__BackingField;
    protected List`1<IMessageSinkWithTypes> AggregatedSinks { get; }
    [CompilerGeneratedAttribute]
protected List`1<IMessageSinkWithTypes> get_AggregatedSinks();
    public virtual void Dispose();
    protected TDispatcher GetOrCreateAggregatedSink(TDispatcher& value);
    public virtual bool OnMessageWithTypes(IMessageSinkMessage message, HashSet`1<string> messageTypes);
}
internal class Xunit.AppDomainManager_AppDomain : object {
    [CompilerGeneratedAttribute]
private AppDomain <AppDomain>k__BackingField;
    [CompilerGeneratedAttribute]
private string <AssemblyFileName>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ConfigFileName>k__BackingField;
    public AppDomain AppDomain { get; private set; }
    public string AssemblyFileName { get; private set; }
    public string ConfigFileName { get; private set; }
    public bool HasAppDomain { get; }
    public AppDomainManager_AppDomain(string assemblyFileName, string configFileName, bool shadowCopy, string shadowCopyFolder);
    [CompilerGeneratedAttribute]
public AppDomain get_AppDomain();
    [CompilerGeneratedAttribute]
private void set_AppDomain(AppDomain value);
    [CompilerGeneratedAttribute]
public string get_AssemblyFileName();
    [CompilerGeneratedAttribute]
private void set_AssemblyFileName(string value);
    [CompilerGeneratedAttribute]
public string get_ConfigFileName();
    [CompilerGeneratedAttribute]
private void set_ConfigFileName(string value);
    public sealed virtual bool get_HasAppDomain();
    private static AppDomain CreateAppDomain(string assemblyFilename, string configFilename, bool shadowCopy, string shadowCopyFolder);
    public sealed virtual TObject CreateObjectFrom(string assemblyLocation, string typeName, Object[] args);
    public sealed virtual TObject CreateObject(AssemblyName assemblyName, string typeName, Object[] args);
    public virtual void Dispose();
    private static string GetDefaultConfigFile(string assemblyFile);
}
internal class Xunit.AppDomainManager_NoAppDomain : object {
    private string assemblyFileName;
    public bool HasAppDomain { get; }
    public AppDomainManager_NoAppDomain(string assemblyFileName);
    public sealed virtual bool get_HasAppDomain();
    public sealed virtual TObject CreateObject(AssemblyName assemblyName, string typeName, Object[] args);
    public sealed virtual TObject CreateObjectFrom(string assemblyLocation, string typeName, Object[] args);
    public sealed virtual void Dispose();
}
internal static class Xunit.AppDomainManagerFactory : object {
    internal static IAppDomainManager Create(bool useAppDomain, string assemblyFileName, string configFileName, bool shadowCopy, string shadowCopyFolder);
}
public enum Xunit.AppDomainSupport : Enum {
    public int value__;
    public static AppDomainSupport IfAvailable;
    public static AppDomainSupport Required;
    public static AppDomainSupport Denied;
}
public class Xunit.AssemblyHelper : LongLivedMarshalByRefObject {
    private string directory;
    public AssemblyHelper(string directory);
    public sealed virtual void Dispose();
    private Assembly LoadAssembly(AssemblyName assemblyName);
    private static Assembly LoadAssembly(string assemblyPath);
    private Assembly Resolve(object sender, ResolveEventArgs args);
    public static IDisposable SubscribeResolve(string path);
    public static IDisposable SubscribeResolveForAssembly(string assemblyFileName, IMessageSink internalDiagnosticsMessageSink);
}
public class Xunit.BeforeTestFinished : TestMessage {
    [CompilerGeneratedAttribute]
private string <AttributeName>k__BackingField;
    public string AttributeName { get; private set; }
    public BeforeTestFinished(ITest test, string attributeName);
    [CompilerGeneratedAttribute]
public sealed virtual string get_AttributeName();
    [CompilerGeneratedAttribute]
private void set_AttributeName(string value);
}
public class Xunit.BeforeTestStarting : TestMessage {
    [CompilerGeneratedAttribute]
private string <AttributeName>k__BackingField;
    public string AttributeName { get; private set; }
    public BeforeTestStarting(ITest test, string attributeName);
    [CompilerGeneratedAttribute]
public sealed virtual string get_AttributeName();
    [CompilerGeneratedAttribute]
private void set_AttributeName(string value);
}
public static class Xunit.ConfigReader : object {
    public static TestAssemblyConfiguration Load(string assemblyFileName, string configFileName);
    public static TestAssemblyConfiguration Load(Stream configStream);
}
public static class Xunit.ConfigReader_Configuration : object {
    public static TestAssemblyConfiguration Load(string assemblyFileName, string configFileName);
    private static Nullable`1<bool> GetBoolean(KeyValueConfigurationCollection settings, string key);
    private static Nullable`1<TValue> GetEnum(KeyValueConfigurationCollection settings, string key);
    private static Nullable`1<int> GetInt(KeyValueConfigurationCollection settings, string key);
    private static T GetValue(KeyValueConfigurationCollection settings, string key, Func`2<string, T> converter);
}
public static class Xunit.ConfigReader_Json : object {
    public static TestAssemblyConfiguration Load(Stream configStream);
    public static TestAssemblyConfiguration Load(string assemblyFileName, string configFileName);
    private static TestAssemblyConfiguration LoadFile(string configFileName);
    private static Stream File_OpenRead(string path);
}
internal static class Xunit.ConsoleHelper : object {
    internal static Action ResetColor;
    internal static Action`1<ConsoleColor> SetForegroundColor;
    private static ConsoleHelper();
    private static void SetForegroundColorANSI(ConsoleColor c);
    private static void SetForegroundColorConsole(ConsoleColor c);
    private static void ResetColorANSI();
    private static void ResetColorConsole();
}
public class Xunit.ConsoleRunnerLogger : object {
    private object lockObject;
    private bool useColors;
    public object LockObject { get; }
    public ConsoleRunnerLogger(bool useColors);
    public sealed virtual object get_LockObject();
    public sealed virtual void LogError(StackFrameInfo stackFrame, string message);
    public sealed virtual void LogImportantMessage(StackFrameInfo stackFrame, string message);
    public sealed virtual void LogMessage(StackFrameInfo stackFrame, string message);
    public sealed virtual void LogWarning(StackFrameInfo stackFrame, string message);
    private IDisposable SetColor(ConsoleColor color);
}
[ObsoleteAttribute("This class has poor performance; please use DefaultRunnerReporterWithTypes instead.")]
public class Xunit.DefaultRunnerReporter : object {
    public string Description { get; }
    public bool IsEnvironmentallyEnabled { get; }
    public string RunnerSwitch { get; }
    public virtual string get_Description();
    public virtual bool get_IsEnvironmentallyEnabled();
    public virtual string get_RunnerSwitch();
    public virtual IMessageSink CreateMessageHandler(IRunnerLogger logger);
}
[ObsoleteAttribute("This class has poor performance; please use DefaultRunnerReporterWithTypesMessageHandler instead.")]
public class Xunit.DefaultRunnerReporterMessageHandler : TestMessageVisitor {
    private string defaultDirectory;
    private ITestFrameworkExecutionOptions defaultExecutionOptions;
    private Dictionary`2<string, ITestFrameworkExecutionOptions> executionOptionsByAssembly;
    [CompilerGeneratedAttribute]
private IRunnerLogger <Logger>k__BackingField;
    protected IRunnerLogger Logger { get; private set; }
    public DefaultRunnerReporterMessageHandler(IRunnerLogger logger);
    [CompilerGeneratedAttribute]
protected IRunnerLogger get_Logger();
    [CompilerGeneratedAttribute]
private void set_Logger(IRunnerLogger value);
    private void AddExecutionOptions(string assemblyFilename, ITestFrameworkExecutionOptions executionOptions);
    protected virtual string Escape(string text);
    protected virtual string GetAssemblyDisplayName(ITestAssemblyMessage assemblyMessage);
    protected virtual string GetAssemblyDisplayName(XunitProjectAssembly assembly);
    protected ITestFrameworkExecutionOptions GetExecutionOptions(string assemblyFilename);
    protected void LogError(string failureType, IFailureInformation failureInfo);
    protected virtual void LogStackTrace(StackFrameInfo frameInfo, string stackTrace);
    protected virtual void LogOutput(StackFrameInfo frameInfo, string output);
    private void RemoveExecutionOptions(string assemblyFilename);
    protected virtual bool Visit(IErrorMessage error);
    protected virtual bool Visit(ITestAssemblyDiscoveryFinished discoveryFinished);
    protected virtual bool Visit(ITestAssemblyDiscoveryStarting discoveryStarting);
    protected virtual bool Visit(ITestAssemblyExecutionFinished executionFinished);
    protected virtual bool Visit(ITestAssemblyExecutionStarting executionStarting);
    protected virtual bool Visit(ITestAssemblyCleanupFailure cleanupFailure);
    protected virtual bool Visit(ITestCaseCleanupFailure cleanupFailure);
    protected virtual bool Visit(ITestClassCleanupFailure cleanupFailure);
    protected virtual bool Visit(ITestCleanupFailure cleanupFailure);
    protected virtual bool Visit(ITestCollectionCleanupFailure cleanupFailure);
    protected virtual bool Visit(ITestExecutionSummary executionSummary);
    protected virtual bool Visit(ITestFailed testFailed);
    protected virtual bool Visit(ITestMethodCleanupFailure cleanupFailure);
    protected virtual bool Visit(ITestPassed testPassed);
    protected virtual bool Visit(ITestSkipped testSkipped);
    public static void WriteDefaultSummary(IRunnerLogger logger, ITestExecutionSummary executionSummary);
}
public class Xunit.DefaultRunnerReporterWithTypes : object {
    public string Description { get; }
    public bool IsEnvironmentallyEnabled { get; }
    public string RunnerSwitch { get; }
    public virtual string get_Description();
    public virtual bool get_IsEnvironmentallyEnabled();
    public virtual string get_RunnerSwitch();
    public virtual IMessageSink CreateMessageHandler(IRunnerLogger logger);
}
public class Xunit.DefaultRunnerReporterWithTypesMessageHandler : TestMessageSink {
    private string defaultDirectory;
    private ITestFrameworkExecutionOptions defaultExecutionOptions;
    private Dictionary`2<string, ITestFrameworkExecutionOptions> executionOptionsByAssembly;
    [CompilerGeneratedAttribute]
private IRunnerLogger <Logger>k__BackingField;
    protected IRunnerLogger Logger { get; private set; }
    public DefaultRunnerReporterWithTypesMessageHandler(IRunnerLogger logger);
    [CompilerGeneratedAttribute]
protected IRunnerLogger get_Logger();
    [CompilerGeneratedAttribute]
private void set_Logger(IRunnerLogger value);
    private void AddExecutionOptions(string assemblyFilename, ITestFrameworkExecutionOptions executionOptions);
    protected virtual string Escape(string text);
    protected virtual string GetAssemblyDisplayName(ITestAssemblyMessage assemblyMessage);
    protected virtual string GetAssemblyDisplayName(XunitProjectAssembly assembly);
    protected ITestFrameworkExecutionOptions GetExecutionOptions(string assemblyFilename);
    protected void LogError(string failureType, IFailureInformation failureInfo);
    protected virtual void LogStackTrace(StackFrameInfo frameInfo, string stackTrace);
    protected virtual void LogOutput(StackFrameInfo frameInfo, string output);
    private void RemoveExecutionOptions(string assemblyFilename);
    protected virtual void HandleErrorMessage(MessageHandlerArgs`1<IErrorMessage> args);
    protected virtual void HandleTestAssemblyDiscoveryFinished(MessageHandlerArgs`1<ITestAssemblyDiscoveryFinished> args);
    protected virtual void HandleTestAssemblyDiscoveryStarting(MessageHandlerArgs`1<ITestAssemblyDiscoveryStarting> args);
    protected virtual void HandleTestAssemblyExecutionFinished(MessageHandlerArgs`1<ITestAssemblyExecutionFinished> args);
    protected virtual void HandleTestAssemblyExecutionStarting(MessageHandlerArgs`1<ITestAssemblyExecutionStarting> args);
    protected virtual void HandleTestAssemblyCleanupFailure(MessageHandlerArgs`1<ITestAssemblyCleanupFailure> args);
    protected virtual void HandleTestCaseCleanupFailure(MessageHandlerArgs`1<ITestCaseCleanupFailure> args);
    protected virtual void HandleTestClassCleanupFailure(MessageHandlerArgs`1<ITestClassCleanupFailure> args);
    protected virtual void HandleTestCleanupFailure(MessageHandlerArgs`1<ITestCleanupFailure> args);
    protected virtual void HandleTestCollectionCleanupFailure(MessageHandlerArgs`1<ITestCollectionCleanupFailure> args);
    protected virtual void HandleTestExecutionSummary(MessageHandlerArgs`1<ITestExecutionSummary> args);
    protected virtual void HandleTestFailed(MessageHandlerArgs`1<ITestFailed> args);
    protected virtual void HandleTestMethodCleanupFailure(MessageHandlerArgs`1<ITestMethodCleanupFailure> args);
    protected virtual void HandleTestPassed(MessageHandlerArgs`1<ITestPassed> args);
    protected virtual void HandleTestSkipped(MessageHandlerArgs`1<ITestSkipped> args);
    public static void WriteDefaultSummary(IRunnerLogger logger, ITestExecutionSummary executionSummary);
}
public class Xunit.DefaultTestCaseBulkDeserializer : object {
    private ITestFrameworkExecutor executor;
    public DefaultTestCaseBulkDeserializer(ITestFrameworkExecutor executor);
    public sealed virtual List`1<KeyValuePair`2<string, ITestCase>> BulkDeserialize(List`1<string> serializations);
    [CompilerGeneratedAttribute]
private ITestCase <BulkDeserialize>b__2_0(string serialization);
}
public class Xunit.DefaultTestCaseDescriptorProvider : object {
    private ITestFrameworkDiscoverer discoverer;
    public DefaultTestCaseDescriptorProvider(ITestFrameworkDiscoverer discoverer);
    public sealed virtual List`1<TestCaseDescriptor> GetTestCaseDescriptors(List`1<ITestCase> testCases, bool includeSerialization);
}
public class Xunit.DelegatingExecutionSummarySink : LongLivedMarshalByRefObject {
    private Func`1<bool> cancelThunk;
    private Action`2<string, ExecutionSummary> completionCallback;
    private Int32 modreq(System.Runtime.CompilerServices.IsVolatile) errors;
    private IMessageSinkWithTypes innerSink;
    [CompilerGeneratedAttribute]
private ExecutionSummary <ExecutionSummary>k__BackingField;
    [CompilerGeneratedAttribute]
private ManualResetEvent <Finished>k__BackingField;
    public ExecutionSummary ExecutionSummary { get; }
    public ManualResetEvent Finished { get; }
    public DelegatingExecutionSummarySink(IMessageSinkWithTypes innerSink, Func`1<bool> cancelThunk, Action`2<string, ExecutionSummary> completionCallback);
    [CompilerGeneratedAttribute]
public sealed virtual ExecutionSummary get_ExecutionSummary();
    [CompilerGeneratedAttribute]
public sealed virtual ManualResetEvent get_Finished();
    public sealed virtual void Dispose();
    private void HandleTestAssemblyFinished(MessageHandlerArgs`1<ITestAssemblyFinished> args);
    public sealed virtual bool OnMessageWithTypes(IMessageSinkMessage message, HashSet`1<string> messageTypes);
    [CompilerGeneratedAttribute]
private void <OnMessageWithTypes>b__13_0(MessageHandlerArgs`1<IErrorMessage> args);
    [CompilerGeneratedAttribute]
private void <OnMessageWithTypes>b__13_1(MessageHandlerArgs`1<ITestAssemblyCleanupFailure> args);
    [CompilerGeneratedAttribute]
private void <OnMessageWithTypes>b__13_2(MessageHandlerArgs`1<ITestCaseCleanupFailure> args);
    [CompilerGeneratedAttribute]
private void <OnMessageWithTypes>b__13_3(MessageHandlerArgs`1<ITestClassCleanupFailure> args);
    [CompilerGeneratedAttribute]
private void <OnMessageWithTypes>b__13_4(MessageHandlerArgs`1<ITestCleanupFailure> args);
    [CompilerGeneratedAttribute]
private void <OnMessageWithTypes>b__13_5(MessageHandlerArgs`1<ITestCollectionCleanupFailure> args);
    [CompilerGeneratedAttribute]
private void <OnMessageWithTypes>b__13_6(MessageHandlerArgs`1<ITestMethodCleanupFailure> args);
}
public class Xunit.DelegatingFailSkipSink : LongLivedMarshalByRefObject {
    private IExecutionSink innerSink;
    private int skipCount;
    public ExecutionSummary ExecutionSummary { get; }
    public ManualResetEvent Finished { get; }
    public DelegatingFailSkipSink(IExecutionSink innerSink);
    public sealed virtual ExecutionSummary get_ExecutionSummary();
    public sealed virtual ManualResetEvent get_Finished();
    public sealed virtual void Dispose();
    public sealed virtual bool OnMessageWithTypes(IMessageSinkMessage message, HashSet`1<string> messageTypes);
}
public class Xunit.DelegatingLongRunningTestDetectionSink : LongLivedMarshalByRefObject {
    private static String[] DiagnosticMessageTypes;
    private Action`1<LongRunningTestsSummary> callback;
    private Dictionary`2<ITestCase, DateTime> executingTestCases;
    private ExecutionEventSink executionSink;
    private IExecutionSink innerSink;
    private DateTime lastTestActivity;
    private TimeSpan longRunningTestTime;
    private ManualResetEvent stopEvent;
    public ExecutionSummary ExecutionSummary { get; }
    public ManualResetEvent Finished { get; }
    protected DateTime UtcNow { get; }
    public DelegatingLongRunningTestDetectionSink(IExecutionSink innerSink, TimeSpan longRunningTestTime, IMessageSinkWithTypes diagnosticMessageSink);
    public DelegatingLongRunningTestDetectionSink(IExecutionSink innerSink, TimeSpan longRunningTestTime, Action`1<LongRunningTestsSummary> callback);
    private static DelegatingLongRunningTestDetectionSink();
    public sealed virtual ExecutionSummary get_ExecutionSummary();
    public sealed virtual ManualResetEvent get_Finished();
    protected virtual DateTime get_UtcNow();
    private static void DispatchLongRunningTestsSummaryAsDiagnosticMessage(LongRunningTestsSummary summary, IMessageSinkWithTypes diagnosticMessageSink);
    public virtual void Dispose();
    private void HandleTestAssemblyFinished(MessageHandlerArgs`1<ITestAssemblyFinished> args);
    private void HandleTestAssemblyStarting(MessageHandlerArgs`1<ITestAssemblyStarting> args);
    private void HandleTestCaseFinished(MessageHandlerArgs`1<ITestCaseFinished> args);
    private void HandleTestCaseStarting(MessageHandlerArgs`1<ITestCaseStarting> args);
    public sealed virtual bool OnMessageWithTypes(IMessageSinkMessage message, HashSet`1<string> messageTypes);
    private void SendLongRunningMessage();
    private void ThreadWorker();
    protected virtual bool WaitForStopEvent(int millionsecondsDelay);
}
public class Xunit.DelegatingXmlCreationSink : LongLivedMarshalByRefObject {
    private XElement assemblyElement;
    private XElement errorsElement;
    private IExecutionSink innerSink;
    private Dictionary`2<Guid, XElement> testCollectionElements;
    public ExecutionSummary ExecutionSummary { get; }
    public ManualResetEvent Finished { get; }
    public DelegatingXmlCreationSink(IExecutionSink innerSink, XElement assemblyElement);
    public sealed virtual ExecutionSummary get_ExecutionSummary();
    public sealed virtual ManualResetEvent get_Finished();
    public sealed virtual bool OnMessageWithTypes(IMessageSinkMessage message, HashSet`1<string> messageTypes);
    private void AddError(string type, string name, IFailureInformation failureInfo);
    private static XElement CreateFailureElement(IFailureInformation failureInfo);
    private XElement CreateTestResultElement(ITestResultMessage testResult, string resultText);
    public sealed virtual void Dispose();
    private XElement GetTestCollectionElement(ITestCollection testCollection);
    private void HandleErrorMessage(MessageHandlerArgs`1<IErrorMessage> args);
    private void HandleTestAssemblyCleanupFailure(MessageHandlerArgs`1<ITestAssemblyCleanupFailure> args);
    private void HandleTestAssemblyFinished(MessageHandlerArgs`1<ITestAssemblyFinished> args);
    private void HandleTestAssemblyStarting(MessageHandlerArgs`1<ITestAssemblyStarting> args);
    private void HandleTestCaseCleanupFailure(MessageHandlerArgs`1<ITestCaseCleanupFailure> args);
    private void HandleTestClassCleanupFailure(MessageHandlerArgs`1<ITestClassCleanupFailure> args);
    private void HandleTestCleanupFailure(MessageHandlerArgs`1<ITestCleanupFailure> args);
    private void HandleTestCollectionCleanupFailure(MessageHandlerArgs`1<ITestCollectionCleanupFailure> args);
    private void HandleTestCollectionFinished(MessageHandlerArgs`1<ITestCollectionFinished> args);
    private void HandleTestFailed(MessageHandlerArgs`1<ITestFailed> args);
    private void HandleTestMethodCleanupFailure(MessageHandlerArgs`1<ITestMethodCleanupFailure> args);
    private void HandleTestPassed(MessageHandlerArgs`1<ITestPassed> args);
    private void HandleTestSkipped(MessageHandlerArgs`1<ITestSkipped> args);
    protected static string XmlEscape(string value);
}
internal class Xunit.DependencyContextAssemblyCache : object {
    private static Tuple`2<string, Assembly> ManagedAssemblyNotFound;
    private string assemblyFolder;
    private XunitPackageCompilationAssemblyResolver assemblyResolver;
    private DependencyContext dependencyContext;
    private IMessageSink internalDiagnosticsMessageSink;
    private Dictionary`2<string, Assembly> managedAssemblyCache;
    private Dictionary`2<string, Tuple`2<RuntimeLibrary, RuntimeAssetGroup>> managedAssemblyMap;
    public DependencyContextAssemblyCache(string assemblyFolder, DependencyContext dependencyContext, IMessageSink internalDiagnosticsMessageSink);
    private static DependencyContextAssemblyCache();
    public Assembly LoadManagedDll(string assemblyName, Func`2<string, Assembly> managedAssemblyLoader);
    private Tuple`2<string, Assembly> ResolveManagedAssembly(string assemblyName, Func`2<string, Assembly> managedAssemblyLoader);
}
internal class Xunit.DependencyContextAssemblyHelper : object {
    private static DependencyContextJsonReader JsonReader;
    private DependencyContextAssemblyCache assemblyCache;
    private IMessageSink internalDiagnosticsMessageSink;
    public DependencyContextAssemblyHelper(string assemblyFolder, DependencyContext dependencyContext, IMessageSink internalDiagnosticsMessageSink);
    private static DependencyContextAssemblyHelper();
    public sealed virtual void Dispose();
    private Assembly OnResolving(object sender, ResolveEventArgs args);
    public static IDisposable SubscribeResolveForAssembly(string assemblyFileName, IMessageSink internalDiagnosticsMessageSink);
}
public class Xunit.DiagnosticEventSink : LongLivedMarshalByRefObject {
    [CompilerGeneratedAttribute]
private MessageHandler`1<IDiagnosticMessage> DiagnosticMessageEvent;
    [CompilerGeneratedAttribute]
private MessageHandler`1<IErrorMessage> ErrorMessageEvent;
    [CompilerGeneratedAttribute]
public void add_DiagnosticMessageEvent(MessageHandler`1<IDiagnosticMessage> value);
    [CompilerGeneratedAttribute]
public void remove_DiagnosticMessageEvent(MessageHandler`1<IDiagnosticMessage> value);
    [CompilerGeneratedAttribute]
public void add_ErrorMessageEvent(MessageHandler`1<IErrorMessage> value);
    [CompilerGeneratedAttribute]
public void remove_ErrorMessageEvent(MessageHandler`1<IErrorMessage> value);
    public sealed virtual void Dispose();
    public sealed virtual bool OnMessageWithTypes(IMessageSinkMessage message, HashSet`1<string> typeNames);
}
public class Xunit.DiagnosticMessage : LongLivedMarshalByRefObject {
    private static HashSet`1<string> interfaceTypes;
    [CompilerGeneratedAttribute]
private string <Message>k__BackingField;
    public HashSet`1<string> InterfaceTypes { get; }
    public string Message { get; public set; }
    public DiagnosticMessage(string message);
    public DiagnosticMessage(string format, Object[] args);
    private static DiagnosticMessage();
    public sealed virtual HashSet`1<string> get_InterfaceTypes();
    [CompilerGeneratedAttribute]
public sealed virtual string get_Message();
    [CompilerGeneratedAttribute]
public void set_Message(string value);
}
internal class Xunit.DiaNavigationData : object {
    [CompilerGeneratedAttribute]
private string <FileName>k__BackingField;
    [CompilerGeneratedAttribute]
private int <LineNumber>k__BackingField;
    public string FileName { get; public set; }
    public int LineNumber { get; public set; }
    [CompilerGeneratedAttribute]
public string get_FileName();
    [CompilerGeneratedAttribute]
public void set_FileName(string value);
    [CompilerGeneratedAttribute]
public int get_LineNumber();
    [CompilerGeneratedAttribute]
public void set_LineNumber(int value);
}
internal class Xunit.DiaSession : object {
    private static MethodInfo methodGetNavigationData;
    private static PropertyInfo propertyFileName;
    private static PropertyInfo propertyMinLineNumber;
    private static Type typeDiaSession;
    private static Type typeDiaNavigationData;
    public string AssemblyFileName;
    private bool sessionHasErrors;
    private Dictionary`2<string, IDisposable> wrappedSessions;
    private static DiaSession();
    public DiaSession(string assemblyFileName);
    public sealed virtual void Dispose();
    public DiaNavigationData GetNavigationData(string typeName, string methodName, string owningAssemblyFilename);
}
internal class Xunit.DiaSessionWrapper : object {
    private AppDomainManager_AppDomain appDomainManager;
    private DiaSessionWrapperHelper helper;
    private DiaSession session;
    public DiaSessionWrapper(string assemblyFilename);
    public DiaNavigationData GetNavigationData(string typeName, string methodName);
    public sealed virtual void Dispose();
}
internal class Xunit.DiaSessionWrapperHelper : LongLivedMarshalByRefObject {
    private static Func`2<MethodInfo, Type> GetStateMachineType;
    private Assembly assembly;
    private Dictionary`2<string, Type> typeNameMap;
    public DiaSessionWrapperHelper(string assemblyFileName);
    private static DiaSessionWrapperHelper();
    private static Type GetStateMachineType_NoOp(MethodInfo method);
    private static Func`2<MethodInfo, Type> InitializeGetStateMachineType();
    public void Normalize(String& typeName, String& methodName, String& assemblyPath);
}
public class Xunit.DiscoveryCompleteMessage : LongLivedMarshalByRefObject {
}
public class Xunit.DiscoveryEventSink : LongLivedMarshalByRefObject {
    [CompilerGeneratedAttribute]
private MessageHandler`1<IDiscoveryCompleteMessage> DiscoveryCompleteMessageEvent;
    [CompilerGeneratedAttribute]
private MessageHandler`1<ITestCaseDiscoveryMessage> TestCaseDiscoveryMessageEvent;
    [CompilerGeneratedAttribute]
public void add_DiscoveryCompleteMessageEvent(MessageHandler`1<IDiscoveryCompleteMessage> value);
    [CompilerGeneratedAttribute]
public void remove_DiscoveryCompleteMessageEvent(MessageHandler`1<IDiscoveryCompleteMessage> value);
    [CompilerGeneratedAttribute]
public void add_TestCaseDiscoveryMessageEvent(MessageHandler`1<ITestCaseDiscoveryMessage> value);
    [CompilerGeneratedAttribute]
public void remove_TestCaseDiscoveryMessageEvent(MessageHandler`1<ITestCaseDiscoveryMessage> value);
    public sealed virtual void Dispose();
    public sealed virtual bool OnMessageWithTypes(IMessageSinkMessage message, HashSet`1<string> typeNames);
}
public class Xunit.ErrorMessage : LongLivedMarshalByRefObject {
    [CompilerGeneratedAttribute]
private String[] <ExceptionTypes>k__BackingField;
    [CompilerGeneratedAttribute]
private String[] <Messages>k__BackingField;
    [CompilerGeneratedAttribute]
private String[] <StackTraces>k__BackingField;
    [CompilerGeneratedAttribute]
private Int32[] <ExceptionParentIndices>k__BackingField;
    [CompilerGeneratedAttribute]
private IEnumerable`1<ITestCase> <TestCases>k__BackingField;
    public String[] ExceptionTypes { get; private set; }
    public String[] Messages { get; private set; }
    public String[] StackTraces { get; private set; }
    public Int32[] ExceptionParentIndices { get; private set; }
    public IEnumerable`1<ITestCase> TestCases { get; private set; }
    public ErrorMessage(IEnumerable`1<ITestCase> testCases, String[] exceptionTypes, String[] messages, String[] stackTraces, Int32[] exceptionParentIndices);
    public ErrorMessage(IEnumerable`1<ITestCase> testCases, Exception ex);
    [CompilerGeneratedAttribute]
public sealed virtual String[] get_ExceptionTypes();
    [CompilerGeneratedAttribute]
private void set_ExceptionTypes(String[] value);
    [CompilerGeneratedAttribute]
public sealed virtual String[] get_Messages();
    [CompilerGeneratedAttribute]
private void set_Messages(String[] value);
    [CompilerGeneratedAttribute]
public sealed virtual String[] get_StackTraces();
    [CompilerGeneratedAttribute]
private void set_StackTraces(String[] value);
    [CompilerGeneratedAttribute]
public sealed virtual Int32[] get_ExceptionParentIndices();
    [CompilerGeneratedAttribute]
private void set_ExceptionParentIndices(Int32[] value);
    [CompilerGeneratedAttribute]
public sealed virtual IEnumerable`1<ITestCase> get_TestCases();
    [CompilerGeneratedAttribute]
private void set_TestCases(IEnumerable`1<ITestCase> value);
}
public static class Xunit.ExceptionUtility : object {
    public static string CombineMessages(IFailureInformation failureInfo);
    public static string CombineStackTraces(IFailureInformation failureInfo);
    private static bool ExcludeStackFrame(string stackFrame);
    private static string FilterStackTrace(string stack);
    private static string GetAt(String[] values, int index);
    private static int GetAt(Int32[] values, int index);
    private static string GetMessage(IFailureInformation failureInfo, int index, int level);
    private static string GetNamespace(string exceptionType);
    private static string GetStackTrace(IFailureInformation failureInfo, int index);
    [IteratorStateMachineAttribute("Xunit.ExceptionUtility/<SplitLines>d__9")]
private static IEnumerable`1<string> SplitLines(string input);
    public static IFailureInformation ConvertExceptionToFailureInformation(Exception ex);
    private static void ConvertExceptionToFailureInformation(Exception ex, int parentIndex, List`1<string> exceptionTypes, List`1<string> messages, List`1<string> stackTraces, List`1<int> indices);
}
public class Xunit.ExecutionEventSink : LongLivedMarshalByRefObject {
    [CompilerGeneratedAttribute]
private MessageHandler`1<IAfterTestFinished> AfterTestFinishedEvent;
    [CompilerGeneratedAttribute]
private MessageHandler`1<IAfterTestStarting> AfterTestStartingEvent;
    [CompilerGeneratedAttribute]
private MessageHandler`1<IBeforeTestFinished> BeforeTestFinishedEvent;
    [CompilerGeneratedAttribute]
private MessageHandler`1<IBeforeTestStarting> BeforeTestStartingEvent;
    [CompilerGeneratedAttribute]
private MessageHandler`1<ITestAssemblyCleanupFailure> TestAssemblyCleanupFailureEvent;
    [CompilerGeneratedAttribute]
private MessageHandler`1<ITestAssemblyFinished> TestAssemblyFinishedEvent;
    [CompilerGeneratedAttribute]
private MessageHandler`1<ITestAssemblyStarting> TestAssemblyStartingEvent;
    [CompilerGeneratedAttribute]
private MessageHandler`1<ITestCaseCleanupFailure> TestCaseCleanupFailureEvent;
    [CompilerGeneratedAttribute]
private MessageHandler`1<ITestCaseFinished> TestCaseFinishedEvent;
    [CompilerGeneratedAttribute]
private MessageHandler`1<ITestCaseStarting> TestCaseStartingEvent;
    [CompilerGeneratedAttribute]
private MessageHandler`1<ITestClassCleanupFailure> TestClassCleanupFailureEvent;
    [CompilerGeneratedAttribute]
private MessageHandler`1<ITestClassConstructionFinished> TestClassConstructionFinishedEvent;
    [CompilerGeneratedAttribute]
private MessageHandler`1<ITestClassConstructionStarting> TestClassConstructionStartingEvent;
    [CompilerGeneratedAttribute]
private MessageHandler`1<ITestClassDisposeFinished> TestClassDisposeFinishedEvent;
    [CompilerGeneratedAttribute]
private MessageHandler`1<ITestClassDisposeStarting> TestClassDisposeStartingEvent;
    [CompilerGeneratedAttribute]
private MessageHandler`1<ITestClassFinished> TestClassFinishedEvent;
    [CompilerGeneratedAttribute]
private MessageHandler`1<ITestClassStarting> TestClassStartingEvent;
    [CompilerGeneratedAttribute]
private MessageHandler`1<ITestCleanupFailure> TestCleanupFailureEvent;
    [CompilerGeneratedAttribute]
private MessageHandler`1<ITestCollectionCleanupFailure> TestCollectionCleanupFailureEvent;
    [CompilerGeneratedAttribute]
private MessageHandler`1<ITestCollectionFinished> TestCollectionFinishedEvent;
    [CompilerGeneratedAttribute]
private MessageHandler`1<ITestCollectionStarting> TestCollectionStartingEvent;
    [CompilerGeneratedAttribute]
private MessageHandler`1<ITestFailed> TestFailedEvent;
    [CompilerGeneratedAttribute]
private MessageHandler`1<ITestFinished> TestFinishedEvent;
    [CompilerGeneratedAttribute]
private MessageHandler`1<ITestMethodCleanupFailure> TestMethodCleanupFailureEvent;
    [CompilerGeneratedAttribute]
private MessageHandler`1<ITestMethodFinished> TestMethodFinishedEvent;
    [CompilerGeneratedAttribute]
private MessageHandler`1<ITestMethodStarting> TestMethodStartingEvent;
    [CompilerGeneratedAttribute]
private MessageHandler`1<ITestOutput> TestOutputEvent;
    [CompilerGeneratedAttribute]
private MessageHandler`1<ITestPassed> TestPassedEvent;
    [CompilerGeneratedAttribute]
private MessageHandler`1<ITestSkipped> TestSkippedEvent;
    [CompilerGeneratedAttribute]
private MessageHandler`1<ITestStarting> TestStartingEvent;
    [CompilerGeneratedAttribute]
public void add_AfterTestFinishedEvent(MessageHandler`1<IAfterTestFinished> value);
    [CompilerGeneratedAttribute]
public void remove_AfterTestFinishedEvent(MessageHandler`1<IAfterTestFinished> value);
    [CompilerGeneratedAttribute]
public void add_AfterTestStartingEvent(MessageHandler`1<IAfterTestStarting> value);
    [CompilerGeneratedAttribute]
public void remove_AfterTestStartingEvent(MessageHandler`1<IAfterTestStarting> value);
    [CompilerGeneratedAttribute]
public void add_BeforeTestFinishedEvent(MessageHandler`1<IBeforeTestFinished> value);
    [CompilerGeneratedAttribute]
public void remove_BeforeTestFinishedEvent(MessageHandler`1<IBeforeTestFinished> value);
    [CompilerGeneratedAttribute]
public void add_BeforeTestStartingEvent(MessageHandler`1<IBeforeTestStarting> value);
    [CompilerGeneratedAttribute]
public void remove_BeforeTestStartingEvent(MessageHandler`1<IBeforeTestStarting> value);
    [CompilerGeneratedAttribute]
public void add_TestAssemblyCleanupFailureEvent(MessageHandler`1<ITestAssemblyCleanupFailure> value);
    [CompilerGeneratedAttribute]
public void remove_TestAssemblyCleanupFailureEvent(MessageHandler`1<ITestAssemblyCleanupFailure> value);
    [CompilerGeneratedAttribute]
public void add_TestAssemblyFinishedEvent(MessageHandler`1<ITestAssemblyFinished> value);
    [CompilerGeneratedAttribute]
public void remove_TestAssemblyFinishedEvent(MessageHandler`1<ITestAssemblyFinished> value);
    [CompilerGeneratedAttribute]
public void add_TestAssemblyStartingEvent(MessageHandler`1<ITestAssemblyStarting> value);
    [CompilerGeneratedAttribute]
public void remove_TestAssemblyStartingEvent(MessageHandler`1<ITestAssemblyStarting> value);
    [CompilerGeneratedAttribute]
public void add_TestCaseCleanupFailureEvent(MessageHandler`1<ITestCaseCleanupFailure> value);
    [CompilerGeneratedAttribute]
public void remove_TestCaseCleanupFailureEvent(MessageHandler`1<ITestCaseCleanupFailure> value);
    [CompilerGeneratedAttribute]
public void add_TestCaseFinishedEvent(MessageHandler`1<ITestCaseFinished> value);
    [CompilerGeneratedAttribute]
public void remove_TestCaseFinishedEvent(MessageHandler`1<ITestCaseFinished> value);
    [CompilerGeneratedAttribute]
public void add_TestCaseStartingEvent(MessageHandler`1<ITestCaseStarting> value);
    [CompilerGeneratedAttribute]
public void remove_TestCaseStartingEvent(MessageHandler`1<ITestCaseStarting> value);
    [CompilerGeneratedAttribute]
public void add_TestClassCleanupFailureEvent(MessageHandler`1<ITestClassCleanupFailure> value);
    [CompilerGeneratedAttribute]
public void remove_TestClassCleanupFailureEvent(MessageHandler`1<ITestClassCleanupFailure> value);
    [CompilerGeneratedAttribute]
public void add_TestClassConstructionFinishedEvent(MessageHandler`1<ITestClassConstructionFinished> value);
    [CompilerGeneratedAttribute]
public void remove_TestClassConstructionFinishedEvent(MessageHandler`1<ITestClassConstructionFinished> value);
    [CompilerGeneratedAttribute]
public void add_TestClassConstructionStartingEvent(MessageHandler`1<ITestClassConstructionStarting> value);
    [CompilerGeneratedAttribute]
public void remove_TestClassConstructionStartingEvent(MessageHandler`1<ITestClassConstructionStarting> value);
    [CompilerGeneratedAttribute]
public void add_TestClassDisposeFinishedEvent(MessageHandler`1<ITestClassDisposeFinished> value);
    [CompilerGeneratedAttribute]
public void remove_TestClassDisposeFinishedEvent(MessageHandler`1<ITestClassDisposeFinished> value);
    [CompilerGeneratedAttribute]
public void add_TestClassDisposeStartingEvent(MessageHandler`1<ITestClassDisposeStarting> value);
    [CompilerGeneratedAttribute]
public void remove_TestClassDisposeStartingEvent(MessageHandler`1<ITestClassDisposeStarting> value);
    [CompilerGeneratedAttribute]
public void add_TestClassFinishedEvent(MessageHandler`1<ITestClassFinished> value);
    [CompilerGeneratedAttribute]
public void remove_TestClassFinishedEvent(MessageHandler`1<ITestClassFinished> value);
    [CompilerGeneratedAttribute]
public void add_TestClassStartingEvent(MessageHandler`1<ITestClassStarting> value);
    [CompilerGeneratedAttribute]
public void remove_TestClassStartingEvent(MessageHandler`1<ITestClassStarting> value);
    [CompilerGeneratedAttribute]
public void add_TestCleanupFailureEvent(MessageHandler`1<ITestCleanupFailure> value);
    [CompilerGeneratedAttribute]
public void remove_TestCleanupFailureEvent(MessageHandler`1<ITestCleanupFailure> value);
    [CompilerGeneratedAttribute]
public void add_TestCollectionCleanupFailureEvent(MessageHandler`1<ITestCollectionCleanupFailure> value);
    [CompilerGeneratedAttribute]
public void remove_TestCollectionCleanupFailureEvent(MessageHandler`1<ITestCollectionCleanupFailure> value);
    [CompilerGeneratedAttribute]
public void add_TestCollectionFinishedEvent(MessageHandler`1<ITestCollectionFinished> value);
    [CompilerGeneratedAttribute]
public void remove_TestCollectionFinishedEvent(MessageHandler`1<ITestCollectionFinished> value);
    [CompilerGeneratedAttribute]
public void add_TestCollectionStartingEvent(MessageHandler`1<ITestCollectionStarting> value);
    [CompilerGeneratedAttribute]
public void remove_TestCollectionStartingEvent(MessageHandler`1<ITestCollectionStarting> value);
    [CompilerGeneratedAttribute]
public void add_TestFailedEvent(MessageHandler`1<ITestFailed> value);
    [CompilerGeneratedAttribute]
public void remove_TestFailedEvent(MessageHandler`1<ITestFailed> value);
    [CompilerGeneratedAttribute]
public void add_TestFinishedEvent(MessageHandler`1<ITestFinished> value);
    [CompilerGeneratedAttribute]
public void remove_TestFinishedEvent(MessageHandler`1<ITestFinished> value);
    [CompilerGeneratedAttribute]
public void add_TestMethodCleanupFailureEvent(MessageHandler`1<ITestMethodCleanupFailure> value);
    [CompilerGeneratedAttribute]
public void remove_TestMethodCleanupFailureEvent(MessageHandler`1<ITestMethodCleanupFailure> value);
    [CompilerGeneratedAttribute]
public void add_TestMethodFinishedEvent(MessageHandler`1<ITestMethodFinished> value);
    [CompilerGeneratedAttribute]
public void remove_TestMethodFinishedEvent(MessageHandler`1<ITestMethodFinished> value);
    [CompilerGeneratedAttribute]
public void add_TestMethodStartingEvent(MessageHandler`1<ITestMethodStarting> value);
    [CompilerGeneratedAttribute]
public void remove_TestMethodStartingEvent(MessageHandler`1<ITestMethodStarting> value);
    [CompilerGeneratedAttribute]
public void add_TestOutputEvent(MessageHandler`1<ITestOutput> value);
    [CompilerGeneratedAttribute]
public void remove_TestOutputEvent(MessageHandler`1<ITestOutput> value);
    [CompilerGeneratedAttribute]
public void add_TestPassedEvent(MessageHandler`1<ITestPassed> value);
    [CompilerGeneratedAttribute]
public void remove_TestPassedEvent(MessageHandler`1<ITestPassed> value);
    [CompilerGeneratedAttribute]
public void add_TestSkippedEvent(MessageHandler`1<ITestSkipped> value);
    [CompilerGeneratedAttribute]
public void remove_TestSkippedEvent(MessageHandler`1<ITestSkipped> value);
    [CompilerGeneratedAttribute]
public void add_TestStartingEvent(MessageHandler`1<ITestStarting> value);
    [CompilerGeneratedAttribute]
public void remove_TestStartingEvent(MessageHandler`1<ITestStarting> value);
    public sealed virtual void Dispose();
    public sealed virtual bool OnMessageWithTypes(IMessageSinkMessage message, HashSet`1<string> messageTypes);
}
public class Xunit.ExecutionSummary : object {
    [CompilerGeneratedAttribute]
private int <Total>k__BackingField;
    [CompilerGeneratedAttribute]
private int <Failed>k__BackingField;
    [CompilerGeneratedAttribute]
private int <Skipped>k__BackingField;
    [CompilerGeneratedAttribute]
private decimal <Time>k__BackingField;
    [CompilerGeneratedAttribute]
private int <Errors>k__BackingField;
    public int Total { get; public set; }
    public int Failed { get; public set; }
    public int Skipped { get; public set; }
    public decimal Time { get; public set; }
    public int Errors { get; public set; }
    [CompilerGeneratedAttribute]
public int get_Total();
    [CompilerGeneratedAttribute]
public void set_Total(int value);
    [CompilerGeneratedAttribute]
public int get_Failed();
    [CompilerGeneratedAttribute]
public void set_Failed(int value);
    [CompilerGeneratedAttribute]
public int get_Skipped();
    [CompilerGeneratedAttribute]
public void set_Skipped(int value);
    [CompilerGeneratedAttribute]
public decimal get_Time();
    [CompilerGeneratedAttribute]
public void set_Time(decimal value);
    [CompilerGeneratedAttribute]
public int get_Errors();
    [CompilerGeneratedAttribute]
public void set_Errors(int value);
}
[ObsoleteAttribute("This class has poor performance; please use FailSkipSink instead.")]
public class Xunit.FailSkipVisitor : TestMessageVisitor`1<ITestAssemblyFinished> {
    private IExecutionVisitor Visitor;
    private int SkipCount;
    public ExecutionSummary ExecutionSummary { get; }
    public FailSkipVisitor(IExecutionVisitor visitor);
    public sealed virtual ExecutionSummary get_ExecutionSummary();
    public virtual bool OnMessage(IMessageSinkMessage message);
}
internal interface Xunit.IAppDomainManager {
    public bool HasAppDomain { get; }
    public abstract virtual bool get_HasAppDomain();
    public abstract virtual TObject CreateObject(AssemblyName assemblyName, string typeName, Object[] args);
    public abstract virtual TObject CreateObjectFrom(string assemblyLocation, string typeName, Object[] args);
}
public interface Xunit.IExecutionSink {
    public ExecutionSummary ExecutionSummary { get; }
    public ManualResetEvent Finished { get; }
    public abstract virtual ExecutionSummary get_ExecutionSummary();
    public abstract virtual ManualResetEvent get_Finished();
}
[ObsoleteAttribute("This interface has poor performance; please use IExecutionSink instead.")]
public interface Xunit.IExecutionVisitor {
    public ExecutionSummary ExecutionSummary { get; }
    public ManualResetEvent Finished { get; }
    public abstract virtual ExecutionSummary get_ExecutionSummary();
    public abstract virtual ManualResetEvent get_Finished();
}
public interface Xunit.IFrontController {
    public bool CanUseAppDomains { get; }
    public abstract virtual bool get_CanUseAppDomains();
}
public interface Xunit.IMessageSinkMessageWithTypes {
    public HashSet`1<string> InterfaceTypes { get; }
    public abstract virtual HashSet`1<string> get_InterfaceTypes();
}
public interface Xunit.IMessageSinkWithTypes {
    public abstract virtual bool OnMessageWithTypes(IMessageSinkMessage message, HashSet`1<string> messageTypes);
}
public interface Xunit.IRunnerLogger {
    public object LockObject { get; }
    public abstract virtual object get_LockObject();
    public abstract virtual void LogMessage(StackFrameInfo stackFrame, string message);
    public abstract virtual void LogImportantMessage(StackFrameInfo stackFrame, string message);
    public abstract virtual void LogWarning(StackFrameInfo stackFrame, string message);
    public abstract virtual void LogError(StackFrameInfo stackFrame, string message);
}
public interface Xunit.IRunnerReporter {
    public string Description { get; }
    public bool IsEnvironmentallyEnabled { get; }
    public string RunnerSwitch { get; }
    public abstract virtual string get_Description();
    public abstract virtual bool get_IsEnvironmentallyEnabled();
    public abstract virtual string get_RunnerSwitch();
    public abstract virtual IMessageSink CreateMessageHandler(IRunnerLogger logger);
}
public interface Xunit.ITestAssemblyDiscoveryFinished {
    public XunitProjectAssembly Assembly { get; }
    public ITestFrameworkDiscoveryOptions DiscoveryOptions { get; }
    public int TestCasesDiscovered { get; }
    public int TestCasesToRun { get; }
    public abstract virtual XunitProjectAssembly get_Assembly();
    public abstract virtual ITestFrameworkDiscoveryOptions get_DiscoveryOptions();
    public abstract virtual int get_TestCasesDiscovered();
    public abstract virtual int get_TestCasesToRun();
}
public interface Xunit.ITestAssemblyDiscoveryStarting {
    public bool AppDomain { get; }
    public XunitProjectAssembly Assembly { get; }
    public ITestFrameworkDiscoveryOptions DiscoveryOptions { get; }
    public bool ShadowCopy { get; }
    public abstract virtual bool get_AppDomain();
    public abstract virtual XunitProjectAssembly get_Assembly();
    public abstract virtual ITestFrameworkDiscoveryOptions get_DiscoveryOptions();
    public abstract virtual bool get_ShadowCopy();
}
public interface Xunit.ITestAssemblyExecutionFinished {
    public XunitProjectAssembly Assembly { get; }
    public ITestFrameworkExecutionOptions ExecutionOptions { get; }
    public ExecutionSummary ExecutionSummary { get; }
    public abstract virtual XunitProjectAssembly get_Assembly();
    public abstract virtual ITestFrameworkExecutionOptions get_ExecutionOptions();
    public abstract virtual ExecutionSummary get_ExecutionSummary();
}
public interface Xunit.ITestAssemblyExecutionStarting {
    public XunitProjectAssembly Assembly { get; }
    public ITestFrameworkExecutionOptions ExecutionOptions { get; }
    public abstract virtual XunitProjectAssembly get_Assembly();
    public abstract virtual ITestFrameworkExecutionOptions get_ExecutionOptions();
}
public interface Xunit.ITestCaseBulkDeserializer {
    public abstract virtual List`1<KeyValuePair`2<string, ITestCase>> BulkDeserialize(List`1<string> serializations);
}
public interface Xunit.ITestCaseDescriptorProvider {
    public abstract virtual List`1<TestCaseDescriptor> GetTestCaseDescriptors(List`1<ITestCase> testCases, bool includeSerialization);
}
public interface Xunit.ITestExecutionSummary {
    public TimeSpan ElapsedClockTime { get; }
    public List`1<KeyValuePair`2<string, ExecutionSummary>> Summaries { get; }
    public abstract virtual TimeSpan get_ElapsedClockTime();
    public abstract virtual List`1<KeyValuePair`2<string, ExecutionSummary>> get_Summaries();
}
public interface Xunit.IXunit1Executor {
    public string TestFrameworkDisplayName { get; }
    public abstract virtual string get_TestFrameworkDisplayName();
    public abstract virtual void EnumerateTests(ICallbackEventHandler handler);
    public abstract virtual void RunTests(string type, List`1<string> methods, ICallbackEventHandler handler);
}
[DefaultMemberAttribute("Item")]
internal class Xunit.JsonArray : JsonValue {
    private JsonValue[] _array;
    public int Length { get; }
    public JsonValue Item { get; }
    public JsonArray(JsonValue[] array, int line, int column);
    public int get_Length();
    public JsonValue get_Item(int index);
}
internal class Xunit.JsonBoolean : JsonValue {
    [CompilerGeneratedAttribute]
private bool <Value>k__BackingField;
    public bool Value { get; private set; }
    public JsonBoolean(JsonToken token);
    [CompilerGeneratedAttribute]
public bool get_Value();
    [CompilerGeneratedAttribute]
private void set_Value(bool value);
    public static bool op_Implicit(JsonBoolean jsonBoolean);
}
internal class Xunit.JsonBuffer : object {
    public static string ValueNull;
    public static string ValueTrue;
    public static string ValueFalse;
    private StringBuilder _buffer;
    private StringBuilder _codePointBuffer;
    private TextReader _reader;
    private JsonToken _token;
    private int _line;
    private int _column;
    public JsonBuffer(TextReader reader);
    public JsonToken Read();
    private int ReadNextChar();
    private string ReadNumber(int firstRead);
    private void ReadLiteral(string literal);
    private string ReadString();
    private static bool IsWhitespace(int value);
}
internal static class Xunit.JsonDeserializer : object {
    public static JsonValue Deserialize(TextReader reader);
    private static JsonValue DeserializeInternal(JsonToken next, JsonBuffer buffer);
    private static JsonArray DeserializeArray(JsonToken head, JsonBuffer buffer);
    private static JsonObject DeserializeObject(JsonToken head, JsonBuffer buffer);
}
internal class Xunit.JsonDeserializerException : Exception {
    [CompilerGeneratedAttribute]
private int <Line>k__BackingField;
    [CompilerGeneratedAttribute]
private int <Column>k__BackingField;
    public int Line { get; }
    public int Column { get; }
    public JsonDeserializerException(string message, Exception innerException, int line, int column);
    public JsonDeserializerException(string message, int line, int column);
    public JsonDeserializerException(string message, JsonToken nextToken);
    [CompilerGeneratedAttribute]
public int get_Line();
    [CompilerGeneratedAttribute]
public int get_Column();
}
internal static class Xunit.JsonDeserializerResource : object {
    internal static string JSON_OpenString { get; }
    internal static string JSON_InvalidEnd { get; }
    internal static string Format_IllegalCharacter(int value);
    internal static string Format_IllegalTrailingCharacterAfterLiteral(int value, string literal);
    internal static string Format_UnrecognizedLiteral(string literal);
    internal static string Format_DuplicateObjectMemberName(string memberName);
    internal static string Format_InvalidFloatNumberFormat(string raw);
    internal static string Format_FloatNumberOverflow(string raw);
    internal static string Format_InvalidSyntax(string syntaxName, string issue);
    internal static string Format_InvalidSyntaxNotExpected(string syntaxName, char unexpected);
    internal static string Format_InvalidSyntaxNotExpected(string syntaxName, string unexpected);
    internal static string Format_InvalidSyntaxExpectation(string syntaxName, char expectation);
    internal static string Format_InvalidSyntaxExpectation(string syntaxName, string expectation);
    internal static string Format_InvalidSyntaxExpectation(string syntaxName, char expectation1, char expectation2);
    internal static string Format_InvalidTokenExpectation(string tokenValue, string expectation);
    internal static string Format_InvalidUnicode(string unicode);
    internal static string Format_UnfinishedJSON(string nextTokenValue);
    internal static string get_JSON_OpenString();
    internal static string get_JSON_InvalidEnd();
}
internal class Xunit.JsonNull : JsonValue {
    public JsonNull(int line, int column);
}
internal class Xunit.JsonNumber : JsonValue {
    private string _raw;
    private double _double;
    public double Double { get; }
    public string Raw { get; }
    public JsonNumber(JsonToken token);
    public double get_Double();
    public string get_Raw();
}
internal class Xunit.JsonObject : JsonValue {
    private IDictionary`2<string, JsonValue> _data;
    public ICollection`1<string> Keys { get; }
    public JsonObject(IDictionary`2<string, JsonValue> data, int line, int column);
    public ICollection`1<string> get_Keys();
    public JsonValue Value(string key);
    public JsonObject ValueAsJsonObject(string key);
    public JsonString ValueAsString(string key);
    public int ValueAsInt(string key);
    public bool ValueAsBoolean(string key, bool defaultValue);
    public Nullable`1<bool> ValueAsNullableBoolean(string key);
    public String[] ValueAsStringArray(string key);
}
internal class Xunit.JsonString : JsonValue {
    private string _value;
    public string Value { get; }
    public JsonString(string value, int line, int column);
    public string get_Value();
    public virtual string ToString();
    public static string op_Implicit(JsonString instance);
}
internal class Xunit.JsonToken : ValueType {
    public JsonTokenType Type;
    public string Value;
    public int Line;
    public int Column;
}
internal enum Xunit.JsonTokenType : Enum {
    public int value__;
    public static JsonTokenType LeftCurlyBracket;
    public static JsonTokenType LeftSquareBracket;
    public static JsonTokenType RightCurlyBracket;
    public static JsonTokenType RightSquareBracket;
    public static JsonTokenType Colon;
    public static JsonTokenType Comma;
    public static JsonTokenType Null;
    public static JsonTokenType True;
    public static JsonTokenType False;
    public static JsonTokenType Number;
    public static JsonTokenType String;
    public static JsonTokenType EOF;
}
internal class Xunit.JsonValue : object {
    [CompilerGeneratedAttribute]
private int <Line>k__BackingField;
    [CompilerGeneratedAttribute]
private int <Column>k__BackingField;
    public int Line { get; }
    public int Column { get; }
    public JsonValue(int line, int column);
    [CompilerGeneratedAttribute]
public int get_Line();
    [CompilerGeneratedAttribute]
public int get_Column();
}
public abstract class Xunit.LongLivedMarshalByRefObject : MarshalByRefObject {
    [SecurityCriticalAttribute]
public sealed virtual object InitializeLifetimeService();
}
public class Xunit.LongRunningTestsSummary : object {
    [CompilerGeneratedAttribute]
private TimeSpan <ConfiguredLongRunningTime>k__BackingField;
    [CompilerGeneratedAttribute]
private IDictionary`2<ITestCase, TimeSpan> <TestCases>k__BackingField;
    public TimeSpan ConfiguredLongRunningTime { get; }
    public IDictionary`2<ITestCase, TimeSpan> TestCases { get; }
    public LongRunningTestsSummary(TimeSpan configuredLongRunningTime, IDictionary`2<ITestCase, TimeSpan> testCases);
    [CompilerGeneratedAttribute]
public TimeSpan get_ConfiguredLongRunningTime();
    [CompilerGeneratedAttribute]
public IDictionary`2<ITestCase, TimeSpan> get_TestCases();
}
public class Xunit.MessageHandler`1 : MulticastDelegate {
    public MessageHandler`1(object object, IntPtr method);
    public virtual void Invoke(MessageHandlerArgs`1<TMessage> args);
    public virtual IAsyncResult BeginInvoke(MessageHandlerArgs`1<TMessage> args, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
public abstract class Xunit.MessageHandlerArgs : object {
    [CompilerGeneratedAttribute]
private bool <IsStopped>k__BackingField;
    public bool IsStopped { get; private set; }
    [CompilerGeneratedAttribute]
public bool get_IsStopped();
    [CompilerGeneratedAttribute]
private void set_IsStopped(bool value);
    public void Stop();
}
public class Xunit.MessageHandlerArgs`1 : MessageHandlerArgs {
    [CompilerGeneratedAttribute]
private TMessage <Message>k__BackingField;
    public TMessage Message { get; }
    public MessageHandlerArgs`1(TMessage message);
    [CompilerGeneratedAttribute]
public TMessage get_Message();
}
public class Xunit.MessageSinkAdapter : LongLivedMarshalByRefObject {
    private IMessageSinkWithTypes inner;
    private MessageSinkAdapter(IMessageSinkWithTypes inner);
    public sealed virtual void Dispose();
    public static HashSet`1<string> GetImplementedInterfaces(IMessageSinkMessage message);
    public sealed virtual bool OnMessage(IMessageSinkMessage message);
    public sealed virtual bool OnMessageWithTypes(IMessageSinkMessage message, HashSet`1<string> messageTypes);
    public static IMessageSink Wrap(IMessageSinkWithTypes sink);
}
public class Xunit.MessageSinkWithTypesAdapter : LongLivedMarshalByRefObject {
    private IMessageSink inner;
    private MessageSinkWithTypesAdapter(IMessageSink inner);
    public sealed virtual void Dispose();
    public sealed virtual bool OnMessage(IMessageSinkMessage message);
    public sealed virtual bool OnMessageWithTypes(IMessageSinkMessage message, HashSet`1<string> messageTypes);
    public static IMessageSinkWithTypes Wrap(IMessageSink sink);
}
public class Xunit.NullMessageSink : LongLivedMarshalByRefObject {
    public sealed virtual void Dispose();
    public sealed virtual bool OnMessage(IMessageSinkMessage message);
    public sealed virtual bool OnMessageWithTypes(IMessageSinkMessage message, HashSet`1<string> messageTypes);
}
public class Xunit.NullSourceInformationProvider : LongLivedMarshalByRefObject {
    public sealed virtual ISourceInformation GetSourceInformation(ITestCase testCase);
    public sealed virtual void Dispose();
}
internal class Xunit.OptimizedRemoteMessageSink : LongLivedMarshalByRefObject {
    private ReaderWriterLockSlim cacheLock;
    private Dictionary`2<Type, HashSet`1<string>> interfaceCache;
    private IMessageSinkWithTypes runnerSink;
    public OptimizedRemoteMessageSink(IMessageSinkWithTypes runnerSink);
    private HashSet`1<string> GetMessageTypes(IMessageSinkMessage message);
    public sealed virtual bool OnMessage(IMessageSinkMessage message);
}
public static class Xunit.RemotingUtility : object {
    public static void CleanUpRegisteredChannels();
}
public class Xunit.RunnerEventSink : LongLivedMarshalByRefObject {
    [CompilerGeneratedAttribute]
private MessageHandler`1<ITestAssemblyDiscoveryFinished> TestAssemblyDiscoveryFinishedEvent;
    [CompilerGeneratedAttribute]
private MessageHandler`1<ITestAssemblyDiscoveryStarting> TestAssemblyDiscoveryStartingEvent;
    [CompilerGeneratedAttribute]
private MessageHandler`1<ITestAssemblyExecutionFinished> TestAssemblyExecutionFinishedEvent;
    [CompilerGeneratedAttribute]
private MessageHandler`1<ITestAssemblyExecutionStarting> TestAssemblyExecutionStartingEvent;
    [CompilerGeneratedAttribute]
private MessageHandler`1<ITestExecutionSummary> TestExecutionSummaryEvent;
    [CompilerGeneratedAttribute]
public void add_TestAssemblyDiscoveryFinishedEvent(MessageHandler`1<ITestAssemblyDiscoveryFinished> value);
    [CompilerGeneratedAttribute]
public void remove_TestAssemblyDiscoveryFinishedEvent(MessageHandler`1<ITestAssemblyDiscoveryFinished> value);
    [CompilerGeneratedAttribute]
public void add_TestAssemblyDiscoveryStartingEvent(MessageHandler`1<ITestAssemblyDiscoveryStarting> value);
    [CompilerGeneratedAttribute]
public void remove_TestAssemblyDiscoveryStartingEvent(MessageHandler`1<ITestAssemblyDiscoveryStarting> value);
    [CompilerGeneratedAttribute]
public void add_TestAssemblyExecutionFinishedEvent(MessageHandler`1<ITestAssemblyExecutionFinished> value);
    [CompilerGeneratedAttribute]
public void remove_TestAssemblyExecutionFinishedEvent(MessageHandler`1<ITestAssemblyExecutionFinished> value);
    [CompilerGeneratedAttribute]
public void add_TestAssemblyExecutionStartingEvent(MessageHandler`1<ITestAssemblyExecutionStarting> value);
    [CompilerGeneratedAttribute]
public void remove_TestAssemblyExecutionStartingEvent(MessageHandler`1<ITestAssemblyExecutionStarting> value);
    [CompilerGeneratedAttribute]
public void add_TestExecutionSummaryEvent(MessageHandler`1<ITestExecutionSummary> value);
    [CompilerGeneratedAttribute]
public void remove_TestExecutionSummaryEvent(MessageHandler`1<ITestExecutionSummary> value);
    public sealed virtual void Dispose();
    public sealed virtual bool OnMessageWithTypes(IMessageSinkMessage message, HashSet`1<string> messageTypes);
}
public class Xunit.Runners.AssemblyRunner : LongLivedMarshalByRefObject {
    private static Dictionary`2<Type, string> MessageTypeNames;
    private Boolean modreq(System.Runtime.CompilerServices.IsVolatile) cancelled;
    private bool disposed;
    private TestAssemblyConfiguration configuration;
    private IFrontController controller;
    private ManualResetEvent discoveryCompleteEvent;
    private ManualResetEvent executionCompleteEvent;
    private object statusLock;
    private int testCasesDiscovered;
    private List`1<ITestCase> testCasesToRun;
    [CompilerGeneratedAttribute]
private Action`1<DiagnosticMessageInfo> <OnDiagnosticMessage>k__BackingField;
    [CompilerGeneratedAttribute]
private Action`1<DiscoveryCompleteInfo> <OnDiscoveryComplete>k__BackingField;
    [CompilerGeneratedAttribute]
private Action`1<ErrorMessageInfo> <OnErrorMessage>k__BackingField;
    [CompilerGeneratedAttribute]
private Action`1<ExecutionCompleteInfo> <OnExecutionComplete>k__BackingField;
    [CompilerGeneratedAttribute]
private Action`1<TestFailedInfo> <OnTestFailed>k__BackingField;
    [CompilerGeneratedAttribute]
private Action`1<TestFinishedInfo> <OnTestFinished>k__BackingField;
    [CompilerGeneratedAttribute]
private Action`1<TestOutputInfo> <OnTestOutput>k__BackingField;
    [CompilerGeneratedAttribute]
private Action`1<TestPassedInfo> <OnTestPassed>k__BackingField;
    [CompilerGeneratedAttribute]
private Action`1<TestSkippedInfo> <OnTestSkipped>k__BackingField;
    [CompilerGeneratedAttribute]
private Action`1<TestStartingInfo> <OnTestStarting>k__BackingField;
    [CompilerGeneratedAttribute]
private Func`2<ITestCase, bool> <TestCaseFilter>k__BackingField;
    public Action`1<DiagnosticMessageInfo> OnDiagnosticMessage { get; public set; }
    public Action`1<DiscoveryCompleteInfo> OnDiscoveryComplete { get; public set; }
    public Action`1<ErrorMessageInfo> OnErrorMessage { get; public set; }
    public Action`1<ExecutionCompleteInfo> OnExecutionComplete { get; public set; }
    public Action`1<TestFailedInfo> OnTestFailed { get; public set; }
    public Action`1<TestFinishedInfo> OnTestFinished { get; public set; }
    public Action`1<TestOutputInfo> OnTestOutput { get; public set; }
    public Action`1<TestPassedInfo> OnTestPassed { get; public set; }
    public Action`1<TestSkippedInfo> OnTestSkipped { get; public set; }
    public Action`1<TestStartingInfo> OnTestStarting { get; public set; }
    public AssemblyRunnerStatus Status { get; }
    public Func`2<ITestCase, bool> TestCaseFilter { get; public set; }
    private static AssemblyRunner();
    private AssemblyRunner(AppDomainSupport appDomainSupport, string assemblyFileName, string configFileName, bool shadowCopy, string shadowCopyFolder);
    [CompilerGeneratedAttribute]
public Action`1<DiagnosticMessageInfo> get_OnDiagnosticMessage();
    [CompilerGeneratedAttribute]
public void set_OnDiagnosticMessage(Action`1<DiagnosticMessageInfo> value);
    [CompilerGeneratedAttribute]
public Action`1<DiscoveryCompleteInfo> get_OnDiscoveryComplete();
    [CompilerGeneratedAttribute]
public void set_OnDiscoveryComplete(Action`1<DiscoveryCompleteInfo> value);
    [CompilerGeneratedAttribute]
public Action`1<ErrorMessageInfo> get_OnErrorMessage();
    [CompilerGeneratedAttribute]
public void set_OnErrorMessage(Action`1<ErrorMessageInfo> value);
    [CompilerGeneratedAttribute]
public Action`1<ExecutionCompleteInfo> get_OnExecutionComplete();
    [CompilerGeneratedAttribute]
public void set_OnExecutionComplete(Action`1<ExecutionCompleteInfo> value);
    [CompilerGeneratedAttribute]
public Action`1<TestFailedInfo> get_OnTestFailed();
    [CompilerGeneratedAttribute]
public void set_OnTestFailed(Action`1<TestFailedInfo> value);
    [CompilerGeneratedAttribute]
public Action`1<TestFinishedInfo> get_OnTestFinished();
    [CompilerGeneratedAttribute]
public void set_OnTestFinished(Action`1<TestFinishedInfo> value);
    [CompilerGeneratedAttribute]
public Action`1<TestOutputInfo> get_OnTestOutput();
    [CompilerGeneratedAttribute]
public void set_OnTestOutput(Action`1<TestOutputInfo> value);
    [CompilerGeneratedAttribute]
public Action`1<TestPassedInfo> get_OnTestPassed();
    [CompilerGeneratedAttribute]
public void set_OnTestPassed(Action`1<TestPassedInfo> value);
    [CompilerGeneratedAttribute]
public Action`1<TestSkippedInfo> get_OnTestSkipped();
    [CompilerGeneratedAttribute]
public void set_OnTestSkipped(Action`1<TestSkippedInfo> value);
    [CompilerGeneratedAttribute]
public Action`1<TestStartingInfo> get_OnTestStarting();
    [CompilerGeneratedAttribute]
public void set_OnTestStarting(Action`1<TestStartingInfo> value);
    public AssemblyRunnerStatus get_Status();
    [CompilerGeneratedAttribute]
public Func`2<ITestCase, bool> get_TestCaseFilter();
    [CompilerGeneratedAttribute]
public void set_TestCaseFilter(Func`2<ITestCase, bool> value);
    private static void AddMessageTypeName();
    public void Cancel();
    public sealed virtual void Dispose();
    private ITestFrameworkDiscoveryOptions GetDiscoveryOptions(Nullable`1<bool> diagnosticMessages, Nullable`1<TestMethodDisplay> methodDisplay, Nullable`1<bool> preEnumerateTheories, Nullable`1<bool> internalDiagnosticMessages);
    private ITestFrameworkExecutionOptions GetExecutionOptions(Nullable`1<bool> diagnosticMessages, Nullable`1<bool> parallel, Nullable`1<int> maxParallelThreads, Nullable`1<bool> internalDiagnosticMessages);
    public void Start(string typeName, Nullable`1<bool> diagnosticMessages, Nullable`1<TestMethodDisplay> methodDisplay, Nullable`1<bool> preEnumerateTheories, Nullable`1<bool> parallel, Nullable`1<int> maxParallelThreads, Nullable`1<bool> internalDiagnosticMessages);
    public static AssemblyRunner WithAppDomain(string assemblyFileName, string configFileName, bool shadowCopy, string shadowCopyFolder);
    public static AssemblyRunner WithoutAppDomain(string assemblyFileName);
    private bool DispatchMessage(IMessageSinkMessage message, HashSet`1<string> messageTypes, Action`1<TMessage> handler);
    private sealed virtual override bool Xunit.IMessageSinkWithTypes.OnMessageWithTypes(IMessageSinkMessage message, HashSet`1<string> messageTypes);
    [CompilerGeneratedAttribute]
private void <Xunit.IMessageSinkWithTypes.OnMessageWithTypes>b__67_0(ITestCaseDiscoveryMessage testDiscovered);
    [CompilerGeneratedAttribute]
private void <Xunit.IMessageSinkWithTypes.OnMessageWithTypes>b__67_1(IDiscoveryCompleteMessage discoveryComplete);
    [CompilerGeneratedAttribute]
private void <Xunit.IMessageSinkWithTypes.OnMessageWithTypes>b__67_2(ITestAssemblyFinished assemblyFinished);
    [CompilerGeneratedAttribute]
private void <Xunit.IMessageSinkWithTypes.OnMessageWithTypes>b__67_3(IDiagnosticMessage m);
    [CompilerGeneratedAttribute]
private void <Xunit.IMessageSinkWithTypes.OnMessageWithTypes>b__67_4(ITestFailed m);
    [CompilerGeneratedAttribute]
private void <Xunit.IMessageSinkWithTypes.OnMessageWithTypes>b__67_5(ITestFinished m);
    [CompilerGeneratedAttribute]
private void <Xunit.IMessageSinkWithTypes.OnMessageWithTypes>b__67_6(ITestOutput m);
    [CompilerGeneratedAttribute]
private void <Xunit.IMessageSinkWithTypes.OnMessageWithTypes>b__67_7(ITestPassed m);
    [CompilerGeneratedAttribute]
private void <Xunit.IMessageSinkWithTypes.OnMessageWithTypes>b__67_8(ITestSkipped m);
    [CompilerGeneratedAttribute]
private void <Xunit.IMessageSinkWithTypes.OnMessageWithTypes>b__67_9(ITestStarting m);
    [CompilerGeneratedAttribute]
private void <Xunit.IMessageSinkWithTypes.OnMessageWithTypes>b__67_10(IErrorMessage m);
    [CompilerGeneratedAttribute]
private void <Xunit.IMessageSinkWithTypes.OnMessageWithTypes>b__67_11(ITestAssemblyCleanupFailure m);
    [CompilerGeneratedAttribute]
private void <Xunit.IMessageSinkWithTypes.OnMessageWithTypes>b__67_12(ITestCaseCleanupFailure m);
    [CompilerGeneratedAttribute]
private void <Xunit.IMessageSinkWithTypes.OnMessageWithTypes>b__67_13(ITestClassCleanupFailure m);
    [CompilerGeneratedAttribute]
private void <Xunit.IMessageSinkWithTypes.OnMessageWithTypes>b__67_14(ITestCleanupFailure m);
    [CompilerGeneratedAttribute]
private void <Xunit.IMessageSinkWithTypes.OnMessageWithTypes>b__67_15(ITestCollectionCleanupFailure m);
    [CompilerGeneratedAttribute]
private void <Xunit.IMessageSinkWithTypes.OnMessageWithTypes>b__67_16(ITestMethodCleanupFailure m);
}
public enum Xunit.Runners.AssemblyRunnerStatus : Enum {
    public int value__;
    public static AssemblyRunnerStatus Idle;
    public static AssemblyRunnerStatus Discovering;
    public static AssemblyRunnerStatus Executing;
}
public class Xunit.Runners.DiagnosticMessageInfo : object {
    [CompilerGeneratedAttribute]
private string <Message>k__BackingField;
    public string Message { get; }
    public DiagnosticMessageInfo(string message);
    [CompilerGeneratedAttribute]
public string get_Message();
}
public class Xunit.Runners.DiscoveryCompleteInfo : object {
    [CompilerGeneratedAttribute]
private int <TestCasesDiscovered>k__BackingField;
    [CompilerGeneratedAttribute]
private int <TestCasesToRun>k__BackingField;
    public int TestCasesDiscovered { get; }
    public int TestCasesToRun { get; }
    public DiscoveryCompleteInfo(int testCasesDiscovered, int testCasesToRun);
    [CompilerGeneratedAttribute]
public int get_TestCasesDiscovered();
    [CompilerGeneratedAttribute]
public int get_TestCasesToRun();
}
public class Xunit.Runners.ErrorMessageInfo : object {
    [CompilerGeneratedAttribute]
private ErrorMessageType <MesssageType>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ExceptionType>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ExceptionMessage>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ExceptionStackTrace>k__BackingField;
    public ErrorMessageType MesssageType { get; }
    public string ExceptionType { get; }
    public string ExceptionMessage { get; }
    public string ExceptionStackTrace { get; }
    public ErrorMessageInfo(ErrorMessageType messageType, string exceptionType, string exceptionMessage, string exceptionStackTrace);
    [CompilerGeneratedAttribute]
public ErrorMessageType get_MesssageType();
    [CompilerGeneratedAttribute]
public string get_ExceptionType();
    [CompilerGeneratedAttribute]
public string get_ExceptionMessage();
    [CompilerGeneratedAttribute]
public string get_ExceptionStackTrace();
}
public enum Xunit.Runners.ErrorMessageType : Enum {
    public int value__;
    public static ErrorMessageType CatastrophicError;
    public static ErrorMessageType TestAssemblyCleanupFailure;
    public static ErrorMessageType TestCollectionCleanupFailure;
    public static ErrorMessageType TestClassCleanupFailure;
    public static ErrorMessageType TestMethodCleanupFailure;
    public static ErrorMessageType TestCaseCleanupFailure;
    public static ErrorMessageType TestCleanupFailure;
}
public class Xunit.Runners.ExecutionCompleteInfo : object {
    [CompilerGeneratedAttribute]
private int <TotalTests>k__BackingField;
    [CompilerGeneratedAttribute]
private int <TestsFailed>k__BackingField;
    [CompilerGeneratedAttribute]
private int <TestsSkipped>k__BackingField;
    [CompilerGeneratedAttribute]
private decimal <ExecutionTime>k__BackingField;
    public static ExecutionCompleteInfo Empty;
    public int TotalTests { get; }
    public int TestsFailed { get; }
    public int TestsSkipped { get; }
    public decimal ExecutionTime { get; }
    public ExecutionCompleteInfo(int totalTests, int testsFailed, int testsSkipped, decimal executionTime);
    private static ExecutionCompleteInfo();
    [CompilerGeneratedAttribute]
public int get_TotalTests();
    [CompilerGeneratedAttribute]
public int get_TestsFailed();
    [CompilerGeneratedAttribute]
public int get_TestsSkipped();
    [CompilerGeneratedAttribute]
public decimal get_ExecutionTime();
}
public abstract class Xunit.Runners.TestExecutedInfo : TestInfo {
    [CompilerGeneratedAttribute]
private decimal <ExecutionTime>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Output>k__BackingField;
    public decimal ExecutionTime { get; }
    public string Output { get; }
    public TestExecutedInfo(string typeName, string methodName, Dictionary`2<string, List`1<string>> traits, string testDisplayName, string testCollectionDisplayName, decimal executionTime, string output);
    [CompilerGeneratedAttribute]
public decimal get_ExecutionTime();
    [CompilerGeneratedAttribute]
public string get_Output();
}
public class Xunit.Runners.TestFailedInfo : TestExecutedInfo {
    [CompilerGeneratedAttribute]
private string <ExceptionType>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ExceptionMessage>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ExceptionStackTrace>k__BackingField;
    public string ExceptionType { get; }
    public string ExceptionMessage { get; }
    public string ExceptionStackTrace { get; }
    public TestFailedInfo(string typeName, string methodName, Dictionary`2<string, List`1<string>> traits, string testDisplayName, string testCollectionDisplayName, decimal executionTime, string output, string exceptionType, string exceptionMessage, string exceptionStackTrace);
    [CompilerGeneratedAttribute]
public string get_ExceptionType();
    [CompilerGeneratedAttribute]
public string get_ExceptionMessage();
    [CompilerGeneratedAttribute]
public string get_ExceptionStackTrace();
}
public class Xunit.Runners.TestFinishedInfo : TestExecutedInfo {
    public TestFinishedInfo(string typeName, string methodName, Dictionary`2<string, List`1<string>> traits, string testDisplayName, string testCollectionDisplayName, decimal executionTime, string output);
}
public abstract class Xunit.Runners.TestInfo : object {
    [CompilerGeneratedAttribute]
private string <TypeName>k__BackingField;
    [CompilerGeneratedAttribute]
private string <MethodName>k__BackingField;
    [CompilerGeneratedAttribute]
private Dictionary`2<string, List`1<string>> <Traits>k__BackingField;
    [CompilerGeneratedAttribute]
private string <TestDisplayName>k__BackingField;
    [CompilerGeneratedAttribute]
private string <TestCollectionDisplayName>k__BackingField;
    public string TypeName { get; }
    public string MethodName { get; }
    public Dictionary`2<string, List`1<string>> Traits { get; }
    public string TestDisplayName { get; }
    public string TestCollectionDisplayName { get; }
    public TestInfo(string typeName, string methodName, Dictionary`2<string, List`1<string>> traits, string testDisplayName, string testCollectionDisplayName);
    [CompilerGeneratedAttribute]
public string get_TypeName();
    [CompilerGeneratedAttribute]
public string get_MethodName();
    [CompilerGeneratedAttribute]
public Dictionary`2<string, List`1<string>> get_Traits();
    [CompilerGeneratedAttribute]
public string get_TestDisplayName();
    [CompilerGeneratedAttribute]
public string get_TestCollectionDisplayName();
}
public class Xunit.Runners.TestOutputInfo : TestInfo {
    [CompilerGeneratedAttribute]
private string <Output>k__BackingField;
    public string Output { get; }
    public TestOutputInfo(string typeName, string methodName, Dictionary`2<string, List`1<string>> traits, string testDisplayName, string testCollectionDisplayName, string output);
    [CompilerGeneratedAttribute]
public string get_Output();
}
public class Xunit.Runners.TestPassedInfo : TestExecutedInfo {
    public TestPassedInfo(string typeName, string methodName, Dictionary`2<string, List`1<string>> traits, string testDisplayName, string testCollectionDisplayName, decimal executionTime, string output);
}
public class Xunit.Runners.TestSkippedInfo : TestInfo {
    [CompilerGeneratedAttribute]
private string <SkipReason>k__BackingField;
    public string SkipReason { get; }
    public TestSkippedInfo(string typeName, string methodName, Dictionary`2<string, List`1<string>> traits, string testDisplayName, string testCollectionDisplayName, string skipReason);
    [CompilerGeneratedAttribute]
public string get_SkipReason();
}
public class Xunit.Runners.TestStartingInfo : TestInfo {
    public TestStartingInfo(string typeName, string methodName, Dictionary`2<string, List`1<string>> traits, string testDisplayName, string testCollectionDisplayName);
}
public abstract class Xunit.Sdk.LongLivedMarshalByRefObject : MarshalByRefObject {
    public static void DisconnectAll();
    [SecurityCriticalAttribute]
public sealed virtual object InitializeLifetimeService();
}
internal static class Xunit.Sdk.SerializationHelper : object {
    private static ConcurrentDictionary`2<Type, string> typeToTypeNameMap;
    private static SerializationHelper();
    public static T Deserialize(string serializedValue);
    public static string Serialize(object value);
    public static bool IsSerializable(object value);
    public static Type GetType(string assemblyQualifiedTypeName);
    public static Type GetType(string assemblyName, string typeName);
    public static string GetTypeNameForSerialization(Type type);
    private static string SubstringTrim(string str, int startIndex, int length);
    private static IList`1<string> SplitAtOuterCommas(string value, bool trimWhitespace);
}
internal class Xunit.Sdk.XunitWorkerThread : object {
    private Thread thread;
    public XunitWorkerThread(Action threadProc);
    public sealed virtual void Dispose();
    public void Join();
    public static void QueueUserWorkItem(Action backgroundTask, EventWaitHandle finished);
}
internal class Xunit.Serialization.XunitSerializationInfo : object {
    private IDictionary`2<string, XunitSerializationTriple> data;
    private static Type[] supportedSerializationTypes;
    public XunitSerializationInfo(IXunitSerializable object);
    private static XunitSerializationInfo();
    public sealed virtual void AddValue(string key, object value, Type type);
    public sealed virtual T GetValue(string key);
    public sealed virtual object GetValue(string key, Type type);
    public string ToSerializedString();
    public static string SerializeTriple(XunitSerializationTriple triple);
    public static XunitSerializationTriple DeserializeTriple(string value);
    public static object Deserialize(Type type, string serializedValue);
    private static IXunitSerializable DeserializeSerializable(Type type, string serializedValue);
    public static string Serialize(object value);
    internal static bool CanSerializeObject(object value);
    private static string FromBase64(string serializedValue);
    private static string ToBase64(string value);
}
internal class Xunit.Serialization.XunitSerializationTriple : object {
    public string Key;
    public object Value;
    public Type Type;
    public XunitSerializationTriple(string key, object value, Type type);
}
public class Xunit.SourceInformation : LongLivedMarshalByRefObject {
    [CompilerGeneratedAttribute]
private string <FileName>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<int> <LineNumber>k__BackingField;
    public string FileName { get; public set; }
    public Nullable`1<int> LineNumber { get; public set; }
    [CompilerGeneratedAttribute]
public sealed virtual string get_FileName();
    [CompilerGeneratedAttribute]
public sealed virtual void set_FileName(string value);
    [CompilerGeneratedAttribute]
public sealed virtual Nullable`1<int> get_LineNumber();
    [CompilerGeneratedAttribute]
public sealed virtual void set_LineNumber(Nullable`1<int> value);
    public sealed virtual void Serialize(IXunitSerializationInfo info);
    public sealed virtual void Deserialize(IXunitSerializationInfo info);
}
public class Xunit.StackFrameInfo : ValueType {
    private static Regex stackFrameRegex;
    [CompilerGeneratedAttribute]
private string <FileName>k__BackingField;
    [CompilerGeneratedAttribute]
private int <LineNumber>k__BackingField;
    public static StackFrameInfo None;
    public string FileName { get; private set; }
    public bool IsEmpty { get; }
    public int LineNumber { get; private set; }
    public StackFrameInfo(string fileName, int lineNumber);
    private static StackFrameInfo();
    [CompilerGeneratedAttribute]
public string get_FileName();
    [CompilerGeneratedAttribute]
private void set_FileName(string value);
    public bool get_IsEmpty();
    [CompilerGeneratedAttribute]
public int get_LineNumber();
    [CompilerGeneratedAttribute]
private void set_LineNumber(int value);
    public static StackFrameInfo FromFailure(IFailureInformation failureInfo);
    public static StackFrameInfo FromSourceInformation(ISourceInformation sourceInfo);
    private static Regex GetStackFrameRegex();
}
public static class Xunit.StackFrameTransformer : object {
    private static Regex regex;
    private static StackFrameTransformer();
    public static string TransformFrame(string stackFrame, string defaultDirectory);
    public static string TransformStack(string stack, string defaultDirectory);
}
public class Xunit.TestAssemblyCleanupFailure : TestAssemblyMessage {
    [CompilerGeneratedAttribute]
private Int32[] <ExceptionParentIndices>k__BackingField;
    [CompilerGeneratedAttribute]
private String[] <ExceptionTypes>k__BackingField;
    [CompilerGeneratedAttribute]
private String[] <Messages>k__BackingField;
    [CompilerGeneratedAttribute]
private String[] <StackTraces>k__BackingField;
    public Int32[] ExceptionParentIndices { get; private set; }
    public String[] ExceptionTypes { get; private set; }
    public String[] Messages { get; private set; }
    public String[] StackTraces { get; private set; }
    public TestAssemblyCleanupFailure(IEnumerable`1<ITestCase> testCases, ITestAssembly testAssembly, String[] exceptionTypes, String[] messages, String[] stackTraces, Int32[] exceptionParentIndices);
    public TestAssemblyCleanupFailure(IEnumerable`1<ITestCase> testCases, ITestAssembly testAssembly, Exception ex);
    [CompilerGeneratedAttribute]
public sealed virtual Int32[] get_ExceptionParentIndices();
    [CompilerGeneratedAttribute]
private void set_ExceptionParentIndices(Int32[] value);
    [CompilerGeneratedAttribute]
public sealed virtual String[] get_ExceptionTypes();
    [CompilerGeneratedAttribute]
private void set_ExceptionTypes(String[] value);
    [CompilerGeneratedAttribute]
public sealed virtual String[] get_Messages();
    [CompilerGeneratedAttribute]
private void set_Messages(String[] value);
    [CompilerGeneratedAttribute]
public sealed virtual String[] get_StackTraces();
    [CompilerGeneratedAttribute]
private void set_StackTraces(String[] value);
}
public class Xunit.TestAssemblyConfiguration : object {
    [CompilerGeneratedAttribute]
private Nullable`1<AppDomainSupport> <AppDomain>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<bool> <DiagnosticMessages>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<bool> <InternalDiagnosticMessages>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<int> <LongRunningTestSeconds>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<int> <MaxParallelThreads>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<TestMethodDisplay> <MethodDisplay>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<bool> <ParallelizeAssembly>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<bool> <ParallelizeTestCollections>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<bool> <PreEnumerateTheories>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<bool> <ShadowCopy>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<bool> <StopOnFail>k__BackingField;
    public Nullable`1<AppDomainSupport> AppDomain { get; public set; }
    public AppDomainSupport AppDomainOrDefault { get; }
    public Nullable`1<bool> DiagnosticMessages { get; public set; }
    public bool DiagnosticMessagesOrDefault { get; }
    public Nullable`1<bool> InternalDiagnosticMessages { get; public set; }
    public bool InternalDiagnosticMessagesOrDefault { get; }
    public Nullable`1<int> LongRunningTestSeconds { get; public set; }
    public int LongRunningTestSecondsOrDefault { get; }
    public Nullable`1<int> MaxParallelThreads { get; public set; }
    public int MaxParallelThreadsOrDefault { get; }
    public Nullable`1<TestMethodDisplay> MethodDisplay { get; public set; }
    public TestMethodDisplay MethodDisplayOrDefault { get; }
    public Nullable`1<bool> ParallelizeAssembly { get; public set; }
    public bool ParallelizeAssemblyOrDefault { get; }
    public Nullable`1<bool> ParallelizeTestCollections { get; public set; }
    public bool ParallelizeTestCollectionsOrDefault { get; }
    public Nullable`1<bool> PreEnumerateTheories { get; public set; }
    public bool PreEnumerateTheoriesOrDefault { get; }
    public Nullable`1<bool> ShadowCopy { get; public set; }
    public bool ShadowCopyOrDefault { get; }
    public Nullable`1<bool> StopOnFail { get; public set; }
    public bool StopOnFailOrDefault { get; }
    [CompilerGeneratedAttribute]
public Nullable`1<AppDomainSupport> get_AppDomain();
    [CompilerGeneratedAttribute]
public void set_AppDomain(Nullable`1<AppDomainSupport> value);
    public AppDomainSupport get_AppDomainOrDefault();
    [CompilerGeneratedAttribute]
public Nullable`1<bool> get_DiagnosticMessages();
    [CompilerGeneratedAttribute]
public void set_DiagnosticMessages(Nullable`1<bool> value);
    public bool get_DiagnosticMessagesOrDefault();
    [CompilerGeneratedAttribute]
public Nullable`1<bool> get_InternalDiagnosticMessages();
    [CompilerGeneratedAttribute]
public void set_InternalDiagnosticMessages(Nullable`1<bool> value);
    public bool get_InternalDiagnosticMessagesOrDefault();
    [CompilerGeneratedAttribute]
public Nullable`1<int> get_LongRunningTestSeconds();
    [CompilerGeneratedAttribute]
public void set_LongRunningTestSeconds(Nullable`1<int> value);
    public int get_LongRunningTestSecondsOrDefault();
    [CompilerGeneratedAttribute]
public Nullable`1<int> get_MaxParallelThreads();
    [CompilerGeneratedAttribute]
public void set_MaxParallelThreads(Nullable`1<int> value);
    public int get_MaxParallelThreadsOrDefault();
    [CompilerGeneratedAttribute]
public Nullable`1<TestMethodDisplay> get_MethodDisplay();
    [CompilerGeneratedAttribute]
public void set_MethodDisplay(Nullable`1<TestMethodDisplay> value);
    public TestMethodDisplay get_MethodDisplayOrDefault();
    [CompilerGeneratedAttribute]
public Nullable`1<bool> get_ParallelizeAssembly();
    [CompilerGeneratedAttribute]
public void set_ParallelizeAssembly(Nullable`1<bool> value);
    public bool get_ParallelizeAssemblyOrDefault();
    [CompilerGeneratedAttribute]
public Nullable`1<bool> get_ParallelizeTestCollections();
    [CompilerGeneratedAttribute]
public void set_ParallelizeTestCollections(Nullable`1<bool> value);
    public bool get_ParallelizeTestCollectionsOrDefault();
    [CompilerGeneratedAttribute]
public Nullable`1<bool> get_PreEnumerateTheories();
    [CompilerGeneratedAttribute]
public void set_PreEnumerateTheories(Nullable`1<bool> value);
    public bool get_PreEnumerateTheoriesOrDefault();
    [CompilerGeneratedAttribute]
public Nullable`1<bool> get_ShadowCopy();
    [CompilerGeneratedAttribute]
public void set_ShadowCopy(Nullable`1<bool> value);
    public bool get_ShadowCopyOrDefault();
    [CompilerGeneratedAttribute]
public Nullable`1<bool> get_StopOnFail();
    [CompilerGeneratedAttribute]
public void set_StopOnFail(Nullable`1<bool> value);
    public bool get_StopOnFailOrDefault();
}
public class Xunit.TestAssemblyDiscoveryFinished : object {
    private static HashSet`1<string> interfaceTypes;
    [CompilerGeneratedAttribute]
private XunitProjectAssembly <Assembly>k__BackingField;
    [CompilerGeneratedAttribute]
private ITestFrameworkDiscoveryOptions <DiscoveryOptions>k__BackingField;
    [CompilerGeneratedAttribute]
private int <TestCasesDiscovered>k__BackingField;
    [CompilerGeneratedAttribute]
private int <TestCasesToRun>k__BackingField;
    public XunitProjectAssembly Assembly { get; private set; }
    public ITestFrameworkDiscoveryOptions DiscoveryOptions { get; private set; }
    public HashSet`1<string> InterfaceTypes { get; }
    public int TestCasesDiscovered { get; private set; }
    public int TestCasesToRun { get; private set; }
    public TestAssemblyDiscoveryFinished(XunitProjectAssembly assembly, ITestFrameworkDiscoveryOptions discoveryOptions, int testCasesDiscovered, int testCasesToRun);
    private static TestAssemblyDiscoveryFinished();
    [CompilerGeneratedAttribute]
public sealed virtual XunitProjectAssembly get_Assembly();
    [CompilerGeneratedAttribute]
private void set_Assembly(XunitProjectAssembly value);
    [CompilerGeneratedAttribute]
public sealed virtual ITestFrameworkDiscoveryOptions get_DiscoveryOptions();
    [CompilerGeneratedAttribute]
private void set_DiscoveryOptions(ITestFrameworkDiscoveryOptions value);
    public sealed virtual HashSet`1<string> get_InterfaceTypes();
    [CompilerGeneratedAttribute]
public sealed virtual int get_TestCasesDiscovered();
    [CompilerGeneratedAttribute]
private void set_TestCasesDiscovered(int value);
    [CompilerGeneratedAttribute]
public sealed virtual int get_TestCasesToRun();
    [CompilerGeneratedAttribute]
private void set_TestCasesToRun(int value);
}
public class Xunit.TestAssemblyDiscoveryStarting : object {
    private static HashSet`1<string> interfaceTypes;
    [CompilerGeneratedAttribute]
private bool <AppDomain>k__BackingField;
    [CompilerGeneratedAttribute]
private XunitProjectAssembly <Assembly>k__BackingField;
    [CompilerGeneratedAttribute]
private ITestFrameworkDiscoveryOptions <DiscoveryOptions>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <ShadowCopy>k__BackingField;
    public bool AppDomain { get; private set; }
    public XunitProjectAssembly Assembly { get; private set; }
    public ITestFrameworkDiscoveryOptions DiscoveryOptions { get; private set; }
    public HashSet`1<string> InterfaceTypes { get; }
    public bool ShadowCopy { get; private set; }
    public TestAssemblyDiscoveryStarting(XunitProjectAssembly assembly, bool appDomain, bool shadowCopy, ITestFrameworkDiscoveryOptions discoveryOptions);
    private static TestAssemblyDiscoveryStarting();
    [CompilerGeneratedAttribute]
public sealed virtual bool get_AppDomain();
    [CompilerGeneratedAttribute]
private void set_AppDomain(bool value);
    [CompilerGeneratedAttribute]
public sealed virtual XunitProjectAssembly get_Assembly();
    [CompilerGeneratedAttribute]
private void set_Assembly(XunitProjectAssembly value);
    [CompilerGeneratedAttribute]
public sealed virtual ITestFrameworkDiscoveryOptions get_DiscoveryOptions();
    [CompilerGeneratedAttribute]
private void set_DiscoveryOptions(ITestFrameworkDiscoveryOptions value);
    public sealed virtual HashSet`1<string> get_InterfaceTypes();
    [CompilerGeneratedAttribute]
public sealed virtual bool get_ShadowCopy();
    [CompilerGeneratedAttribute]
private void set_ShadowCopy(bool value);
}
public class Xunit.TestAssemblyExecutionFinished : object {
    private static HashSet`1<string> interfaceTypes;
    [CompilerGeneratedAttribute]
private XunitProjectAssembly <Assembly>k__BackingField;
    [CompilerGeneratedAttribute]
private ITestFrameworkExecutionOptions <ExecutionOptions>k__BackingField;
    [CompilerGeneratedAttribute]
private ExecutionSummary <ExecutionSummary>k__BackingField;
    public XunitProjectAssembly Assembly { get; private set; }
    public ITestFrameworkExecutionOptions ExecutionOptions { get; private set; }
    public ExecutionSummary ExecutionSummary { get; private set; }
    public HashSet`1<string> InterfaceTypes { get; }
    public TestAssemblyExecutionFinished(XunitProjectAssembly assembly, ITestFrameworkExecutionOptions executionOptions, ExecutionSummary executionSummary);
    private static TestAssemblyExecutionFinished();
    [CompilerGeneratedAttribute]
public sealed virtual XunitProjectAssembly get_Assembly();
    [CompilerGeneratedAttribute]
private void set_Assembly(XunitProjectAssembly value);
    [CompilerGeneratedAttribute]
public sealed virtual ITestFrameworkExecutionOptions get_ExecutionOptions();
    [CompilerGeneratedAttribute]
private void set_ExecutionOptions(ITestFrameworkExecutionOptions value);
    [CompilerGeneratedAttribute]
public sealed virtual ExecutionSummary get_ExecutionSummary();
    [CompilerGeneratedAttribute]
private void set_ExecutionSummary(ExecutionSummary value);
    public sealed virtual HashSet`1<string> get_InterfaceTypes();
}
public class Xunit.TestAssemblyExecutionStarting : object {
    private static HashSet`1<string> interfaceTypes;
    [CompilerGeneratedAttribute]
private XunitProjectAssembly <Assembly>k__BackingField;
    [CompilerGeneratedAttribute]
private ITestFrameworkExecutionOptions <ExecutionOptions>k__BackingField;
    public XunitProjectAssembly Assembly { get; private set; }
    public ITestFrameworkExecutionOptions ExecutionOptions { get; private set; }
    public HashSet`1<string> InterfaceTypes { get; }
    public TestAssemblyExecutionStarting(XunitProjectAssembly assembly, ITestFrameworkExecutionOptions executionOptions);
    private static TestAssemblyExecutionStarting();
    [CompilerGeneratedAttribute]
public sealed virtual XunitProjectAssembly get_Assembly();
    [CompilerGeneratedAttribute]
private void set_Assembly(XunitProjectAssembly value);
    [CompilerGeneratedAttribute]
public sealed virtual ITestFrameworkExecutionOptions get_ExecutionOptions();
    [CompilerGeneratedAttribute]
private void set_ExecutionOptions(ITestFrameworkExecutionOptions value);
    public sealed virtual HashSet`1<string> get_InterfaceTypes();
}
public class Xunit.TestAssemblyFinished : TestAssemblyMessage {
    [CompilerGeneratedAttribute]
private decimal <ExecutionTime>k__BackingField;
    [CompilerGeneratedAttribute]
private int <TestsFailed>k__BackingField;
    [CompilerGeneratedAttribute]
private int <TestsRun>k__BackingField;
    [CompilerGeneratedAttribute]
private int <TestsSkipped>k__BackingField;
    public decimal ExecutionTime { get; private set; }
    public int TestsFailed { get; private set; }
    public int TestsRun { get; private set; }
    public int TestsSkipped { get; private set; }
    public TestAssemblyFinished(IEnumerable`1<ITestCase> testCases, ITestAssembly testAssembly, decimal executionTime, int testsRun, int testsFailed, int testsSkipped);
    [CompilerGeneratedAttribute]
public sealed virtual decimal get_ExecutionTime();
    [CompilerGeneratedAttribute]
private void set_ExecutionTime(decimal value);
    [CompilerGeneratedAttribute]
public sealed virtual int get_TestsFailed();
    [CompilerGeneratedAttribute]
private void set_TestsFailed(int value);
    [CompilerGeneratedAttribute]
public sealed virtual int get_TestsRun();
    [CompilerGeneratedAttribute]
private void set_TestsRun(int value);
    [CompilerGeneratedAttribute]
public sealed virtual int get_TestsSkipped();
    [CompilerGeneratedAttribute]
private void set_TestsSkipped(int value);
}
public class Xunit.TestAssemblyMessage : LongLivedMarshalByRefObject {
    [CompilerGeneratedAttribute]
private ITestAssembly <TestAssembly>k__BackingField;
    [CompilerGeneratedAttribute]
private IEnumerable`1<ITestCase> <TestCases>k__BackingField;
    public ITestAssembly TestAssembly { get; public set; }
    public IEnumerable`1<ITestCase> TestCases { get; private set; }
    public TestAssemblyMessage(IEnumerable`1<ITestCase> testCases, ITestAssembly testAssembly);
    internal TestAssemblyMessage(ITestCase testCase, ITestAssembly testAssembly);
    [CompilerGeneratedAttribute]
public sealed virtual ITestAssembly get_TestAssembly();
    [CompilerGeneratedAttribute]
public void set_TestAssembly(ITestAssembly value);
    [CompilerGeneratedAttribute]
public sealed virtual IEnumerable`1<ITestCase> get_TestCases();
    [CompilerGeneratedAttribute]
private void set_TestCases(IEnumerable`1<ITestCase> value);
}
public class Xunit.TestAssemblyStarting : TestAssemblyMessage {
    [CompilerGeneratedAttribute]
private DateTime <StartTime>k__BackingField;
    [CompilerGeneratedAttribute]
private string <TestEnvironment>k__BackingField;
    [CompilerGeneratedAttribute]
private string <TestFrameworkDisplayName>k__BackingField;
    public DateTime StartTime { get; public set; }
    public string TestEnvironment { get; public set; }
    public string TestFrameworkDisplayName { get; public set; }
    public TestAssemblyStarting(IEnumerable`1<ITestCase> testCases, ITestAssembly testAssembly, DateTime startTime, string testEnvironment, string testFrameworkDisplayName);
    [CompilerGeneratedAttribute]
public sealed virtual DateTime get_StartTime();
    [CompilerGeneratedAttribute]
public void set_StartTime(DateTime value);
    [CompilerGeneratedAttribute]
public sealed virtual string get_TestEnvironment();
    [CompilerGeneratedAttribute]
public void set_TestEnvironment(string value);
    [CompilerGeneratedAttribute]
public sealed virtual string get_TestFrameworkDisplayName();
    [CompilerGeneratedAttribute]
public void set_TestFrameworkDisplayName(string value);
}
public class Xunit.TestCaseCleanupFailure : TestCaseMessage {
    [CompilerGeneratedAttribute]
private String[] <ExceptionTypes>k__BackingField;
    [CompilerGeneratedAttribute]
private String[] <Messages>k__BackingField;
    [CompilerGeneratedAttribute]
private String[] <StackTraces>k__BackingField;
    [CompilerGeneratedAttribute]
private Int32[] <ExceptionParentIndices>k__BackingField;
    public String[] ExceptionTypes { get; private set; }
    public String[] Messages { get; private set; }
    public String[] StackTraces { get; private set; }
    public Int32[] ExceptionParentIndices { get; private set; }
    public TestCaseCleanupFailure(ITestCase testCase, String[] exceptionTypes, String[] messages, String[] stackTraces, Int32[] exceptionParentIndices);
    public TestCaseCleanupFailure(ITestCase testCase, Exception ex);
    [CompilerGeneratedAttribute]
public sealed virtual String[] get_ExceptionTypes();
    [CompilerGeneratedAttribute]
private void set_ExceptionTypes(String[] value);
    [CompilerGeneratedAttribute]
public sealed virtual String[] get_Messages();
    [CompilerGeneratedAttribute]
private void set_Messages(String[] value);
    [CompilerGeneratedAttribute]
public sealed virtual String[] get_StackTraces();
    [CompilerGeneratedAttribute]
private void set_StackTraces(String[] value);
    [CompilerGeneratedAttribute]
public sealed virtual Int32[] get_ExceptionParentIndices();
    [CompilerGeneratedAttribute]
private void set_ExceptionParentIndices(Int32[] value);
}
public class Xunit.TestCaseDescriptor : object {
    private static string Separator;
    private static char SeparatorChar;
    private static string SeparatorEscape;
    [CompilerGeneratedAttribute]
private string <ClassName>k__BackingField;
    [CompilerGeneratedAttribute]
private string <DisplayName>k__BackingField;
    [CompilerGeneratedAttribute]
private string <MethodName>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Serialization>k__BackingField;
    [CompilerGeneratedAttribute]
private string <SkipReason>k__BackingField;
    [CompilerGeneratedAttribute]
private string <SourceFileName>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<int> <SourceLineNumber>k__BackingField;
    public Dictionary`2<string, List`1<string>> Traits;
    [CompilerGeneratedAttribute]
private string <UniqueID>k__BackingField;
    public string ClassName { get; public set; }
    public string DisplayName { get; public set; }
    public string MethodName { get; public set; }
    public string Serialization { get; public set; }
    public string SkipReason { get; public set; }
    public string SourceFileName { get; public set; }
    public Nullable`1<int> SourceLineNumber { get; public set; }
    public string UniqueID { get; public set; }
    public TestCaseDescriptor(string descriptorText);
    [CompilerGeneratedAttribute]
public string get_ClassName();
    [CompilerGeneratedAttribute]
public void set_ClassName(string value);
    [CompilerGeneratedAttribute]
public string get_DisplayName();
    [CompilerGeneratedAttribute]
public void set_DisplayName(string value);
    [CompilerGeneratedAttribute]
public string get_MethodName();
    [CompilerGeneratedAttribute]
public void set_MethodName(string value);
    [CompilerGeneratedAttribute]
public string get_Serialization();
    [CompilerGeneratedAttribute]
public void set_Serialization(string value);
    [CompilerGeneratedAttribute]
public string get_SkipReason();
    [CompilerGeneratedAttribute]
public void set_SkipReason(string value);
    [CompilerGeneratedAttribute]
public string get_SourceFileName();
    [CompilerGeneratedAttribute]
public void set_SourceFileName(string value);
    [CompilerGeneratedAttribute]
public Nullable`1<int> get_SourceLineNumber();
    [CompilerGeneratedAttribute]
public void set_SourceLineNumber(Nullable`1<int> value);
    [CompilerGeneratedAttribute]
public string get_UniqueID();
    [CompilerGeneratedAttribute]
public void set_UniqueID(string value);
    private static string Decode(string value);
}
public class Xunit.TestCaseDiscoveryMessage : TestCaseMessage {
    public TestCaseDiscoveryMessage(ITestCase testCase);
}
public class Xunit.TestCaseFinished : TestCaseMessage {
    [CompilerGeneratedAttribute]
private decimal <ExecutionTime>k__BackingField;
    [CompilerGeneratedAttribute]
private int <TestsFailed>k__BackingField;
    [CompilerGeneratedAttribute]
private int <TestsRun>k__BackingField;
    [CompilerGeneratedAttribute]
private int <TestsSkipped>k__BackingField;
    public decimal ExecutionTime { get; private set; }
    public int TestsFailed { get; private set; }
    public int TestsRun { get; private set; }
    public int TestsSkipped { get; private set; }
    public TestCaseFinished(ITestCase testCase, decimal executionTime, int testsRun, int testsFailed, int testsSkipped);
    [CompilerGeneratedAttribute]
public sealed virtual decimal get_ExecutionTime();
    [CompilerGeneratedAttribute]
private void set_ExecutionTime(decimal value);
    [CompilerGeneratedAttribute]
public sealed virtual int get_TestsFailed();
    [CompilerGeneratedAttribute]
private void set_TestsFailed(int value);
    [CompilerGeneratedAttribute]
public sealed virtual int get_TestsRun();
    [CompilerGeneratedAttribute]
private void set_TestsRun(int value);
    [CompilerGeneratedAttribute]
public sealed virtual int get_TestsSkipped();
    [CompilerGeneratedAttribute]
private void set_TestsSkipped(int value);
}
public class Xunit.TestCaseMessage : TestMethodMessage {
    public ITestCase TestCase { get; }
    public TestCaseMessage(ITestCase testCase);
    public sealed virtual ITestCase get_TestCase();
}
public class Xunit.TestCaseStarting : TestCaseMessage {
    public TestCaseStarting(ITestCase testCase);
}
public class Xunit.TestClassCallbackHandler : XmlNodeCallbackHandler {
    private Dictionary`2<string, Predicate`1<XmlNode>> handlers;
    private IMessageSink messageSink;
    private IList`1<ITestCase> testCases;
    private Xunit1RunSummary testCaseResults;
    private Xunit1RunSummary testMethodResults;
    private ITest currentTest;
    private ITestCase lastTestCase;
    [CompilerGeneratedAttribute]
private Xunit1RunSummary <TestClassResults>k__BackingField;
    public Xunit1RunSummary TestClassResults { get; private set; }
    public TestClassCallbackHandler(IList`1<ITestCase> testCases, IMessageSink messageSink);
    [CompilerGeneratedAttribute]
public Xunit1RunSummary get_TestClassResults();
    [CompilerGeneratedAttribute]
private void set_TestClassResults(Xunit1RunSummary value);
    private ITestCase FindTestCase(string typeName, string methodName);
    private bool OnClass(XmlNode xml);
    private bool OnStart(XmlNode xml);
    private bool OnTest(XmlNode xml);
    public virtual bool OnXmlNode(XmlNode node);
    private List`1<ITestCase> GetTestMethodTestCases(ITestMethod testMethod);
    private void SendTestCaseMessagesWhenAppropriate(ITestCase current);
}
public class Xunit.TestClassCleanupFailure : TestClassMessage {
    [CompilerGeneratedAttribute]
private String[] <ExceptionTypes>k__BackingField;
    [CompilerGeneratedAttribute]
private String[] <Messages>k__BackingField;
    [CompilerGeneratedAttribute]
private String[] <StackTraces>k__BackingField;
    [CompilerGeneratedAttribute]
private Int32[] <ExceptionParentIndices>k__BackingField;
    public String[] ExceptionTypes { get; private set; }
    public String[] Messages { get; private set; }
    public String[] StackTraces { get; private set; }
    public Int32[] ExceptionParentIndices { get; private set; }
    public TestClassCleanupFailure(IEnumerable`1<ITestCase> testCases, ITestClass testClass, String[] exceptionTypes, String[] messages, String[] stackTraces, Int32[] exceptionParentIndices);
    public TestClassCleanupFailure(IEnumerable`1<ITestCase> testCases, ITestClass testClass, Exception ex);
    [CompilerGeneratedAttribute]
public sealed virtual String[] get_ExceptionTypes();
    [CompilerGeneratedAttribute]
private void set_ExceptionTypes(String[] value);
    [CompilerGeneratedAttribute]
public sealed virtual String[] get_Messages();
    [CompilerGeneratedAttribute]
private void set_Messages(String[] value);
    [CompilerGeneratedAttribute]
public sealed virtual String[] get_StackTraces();
    [CompilerGeneratedAttribute]
private void set_StackTraces(String[] value);
    [CompilerGeneratedAttribute]
public sealed virtual Int32[] get_ExceptionParentIndices();
    [CompilerGeneratedAttribute]
private void set_ExceptionParentIndices(Int32[] value);
}
public class Xunit.TestClassConstructionFinished : TestMessage {
    public TestClassConstructionFinished(ITest test);
}
public class Xunit.TestClassConstructionStarting : TestMessage {
    public TestClassConstructionStarting(ITest test);
}
public class Xunit.TestClassDisposeFinished : TestMessage {
    public TestClassDisposeFinished(ITest test);
}
public class Xunit.TestClassDisposeStarting : TestMessage {
    public TestClassDisposeStarting(ITest test);
}
public class Xunit.TestClassFinished : TestClassMessage {
    [CompilerGeneratedAttribute]
private decimal <ExecutionTime>k__BackingField;
    [CompilerGeneratedAttribute]
private int <TestsFailed>k__BackingField;
    [CompilerGeneratedAttribute]
private int <TestsRun>k__BackingField;
    [CompilerGeneratedAttribute]
private int <TestsSkipped>k__BackingField;
    public decimal ExecutionTime { get; private set; }
    public int TestsFailed { get; private set; }
    public int TestsRun { get; private set; }
    public int TestsSkipped { get; private set; }
    public TestClassFinished(IEnumerable`1<ITestCase> testCases, ITestClass testClass, decimal executionTime, int testsRun, int testsFailed, int testsSkipped);
    [CompilerGeneratedAttribute]
public sealed virtual decimal get_ExecutionTime();
    [CompilerGeneratedAttribute]
private void set_ExecutionTime(decimal value);
    [CompilerGeneratedAttribute]
public sealed virtual int get_TestsFailed();
    [CompilerGeneratedAttribute]
private void set_TestsFailed(int value);
    [CompilerGeneratedAttribute]
public sealed virtual int get_TestsRun();
    [CompilerGeneratedAttribute]
private void set_TestsRun(int value);
    [CompilerGeneratedAttribute]
public sealed virtual int get_TestsSkipped();
    [CompilerGeneratedAttribute]
private void set_TestsSkipped(int value);
}
public class Xunit.TestClassMessage : TestCollectionMessage {
    [CompilerGeneratedAttribute]
private ITestClass <TestClass>k__BackingField;
    public ITestClass TestClass { get; public set; }
    public TestClassMessage(IEnumerable`1<ITestCase> testCases, ITestClass testClass);
    internal TestClassMessage(ITestCase testCase, ITestClass testClass);
    [CompilerGeneratedAttribute]
public sealed virtual ITestClass get_TestClass();
    [CompilerGeneratedAttribute]
public void set_TestClass(ITestClass value);
}
public class Xunit.TestClassStarting : TestClassMessage {
    public TestClassStarting(IEnumerable`1<ITestCase> testCases, ITestClass testClass);
}
public class Xunit.TestCleanupFailure : TestMessage {
    [CompilerGeneratedAttribute]
private String[] <ExceptionTypes>k__BackingField;
    [CompilerGeneratedAttribute]
private String[] <Messages>k__BackingField;
    [CompilerGeneratedAttribute]
private String[] <StackTraces>k__BackingField;
    [CompilerGeneratedAttribute]
private Int32[] <ExceptionParentIndices>k__BackingField;
    public String[] ExceptionTypes { get; private set; }
    public String[] Messages { get; private set; }
    public String[] StackTraces { get; private set; }
    public Int32[] ExceptionParentIndices { get; private set; }
    public TestCleanupFailure(ITest test, String[] exceptionTypes, String[] messages, String[] stackTraces, Int32[] exceptionParentIndices);
    public TestCleanupFailure(ITest test, Exception ex);
    [CompilerGeneratedAttribute]
public sealed virtual String[] get_ExceptionTypes();
    [CompilerGeneratedAttribute]
private void set_ExceptionTypes(String[] value);
    [CompilerGeneratedAttribute]
public sealed virtual String[] get_Messages();
    [CompilerGeneratedAttribute]
private void set_Messages(String[] value);
    [CompilerGeneratedAttribute]
public sealed virtual String[] get_StackTraces();
    [CompilerGeneratedAttribute]
private void set_StackTraces(String[] value);
    [CompilerGeneratedAttribute]
public sealed virtual Int32[] get_ExceptionParentIndices();
    [CompilerGeneratedAttribute]
private void set_ExceptionParentIndices(Int32[] value);
}
public class Xunit.TestCollectionCleanupFailure : TestCollectionMessage {
    [CompilerGeneratedAttribute]
private String[] <ExceptionTypes>k__BackingField;
    [CompilerGeneratedAttribute]
private String[] <Messages>k__BackingField;
    [CompilerGeneratedAttribute]
private String[] <StackTraces>k__BackingField;
    [CompilerGeneratedAttribute]
private Int32[] <ExceptionParentIndices>k__BackingField;
    public String[] ExceptionTypes { get; private set; }
    public String[] Messages { get; private set; }
    public String[] StackTraces { get; private set; }
    public Int32[] ExceptionParentIndices { get; private set; }
    public TestCollectionCleanupFailure(IEnumerable`1<ITestCase> testCases, ITestCollection testCollection, String[] exceptionTypes, String[] messages, String[] stackTraces, Int32[] exceptionParentIndices);
    public TestCollectionCleanupFailure(IEnumerable`1<ITestCase> testCases, ITestCollection testCollection, Exception ex);
    [CompilerGeneratedAttribute]
public sealed virtual String[] get_ExceptionTypes();
    [CompilerGeneratedAttribute]
private void set_ExceptionTypes(String[] value);
    [CompilerGeneratedAttribute]
public sealed virtual String[] get_Messages();
    [CompilerGeneratedAttribute]
private void set_Messages(String[] value);
    [CompilerGeneratedAttribute]
public sealed virtual String[] get_StackTraces();
    [CompilerGeneratedAttribute]
private void set_StackTraces(String[] value);
    [CompilerGeneratedAttribute]
public sealed virtual Int32[] get_ExceptionParentIndices();
    [CompilerGeneratedAttribute]
private void set_ExceptionParentIndices(Int32[] value);
}
public class Xunit.TestCollectionFinished : TestCollectionMessage {
    [CompilerGeneratedAttribute]
private decimal <ExecutionTime>k__BackingField;
    [CompilerGeneratedAttribute]
private int <TestsFailed>k__BackingField;
    [CompilerGeneratedAttribute]
private int <TestsRun>k__BackingField;
    [CompilerGeneratedAttribute]
private int <TestsSkipped>k__BackingField;
    public decimal ExecutionTime { get; private set; }
    public int TestsFailed { get; private set; }
    public int TestsRun { get; private set; }
    public int TestsSkipped { get; private set; }
    public TestCollectionFinished(IEnumerable`1<ITestCase> testCases, ITestCollection testCollection, decimal executionTime, int testsRun, int testsFailed, int testsSkipped);
    [CompilerGeneratedAttribute]
public sealed virtual decimal get_ExecutionTime();
    [CompilerGeneratedAttribute]
private void set_ExecutionTime(decimal value);
    [CompilerGeneratedAttribute]
public sealed virtual int get_TestsFailed();
    [CompilerGeneratedAttribute]
private void set_TestsFailed(int value);
    [CompilerGeneratedAttribute]
public sealed virtual int get_TestsRun();
    [CompilerGeneratedAttribute]
private void set_TestsRun(int value);
    [CompilerGeneratedAttribute]
public sealed virtual int get_TestsSkipped();
    [CompilerGeneratedAttribute]
private void set_TestsSkipped(int value);
}
public class Xunit.TestCollectionMessage : TestAssemblyMessage {
    [CompilerGeneratedAttribute]
private ITestCollection <TestCollection>k__BackingField;
    public ITestCollection TestCollection { get; private set; }
    public TestCollectionMessage(IEnumerable`1<ITestCase> testCases, ITestCollection testCollection);
    internal TestCollectionMessage(ITestCase testCase, ITestCollection testCollection);
    [CompilerGeneratedAttribute]
public sealed virtual ITestCollection get_TestCollection();
    [CompilerGeneratedAttribute]
private void set_TestCollection(ITestCollection value);
}
public class Xunit.TestCollectionStarting : TestCollectionMessage {
    public TestCollectionStarting(IEnumerable`1<ITestCase> testCases, ITestCollection testCollection);
}
public class Xunit.TestDiscoverySink : LongLivedMarshalByRefObject {
    private Func`1<bool> cancelThunk;
    private DiscoveryEventSink discoverySink;
    [CompilerGeneratedAttribute]
private List`1<ITestCase> <TestCases>k__BackingField;
    [CompilerGeneratedAttribute]
private ManualResetEvent <Finished>k__BackingField;
    public List`1<ITestCase> TestCases { get; }
    public ManualResetEvent Finished { get; }
    public TestDiscoverySink(Func`1<bool> cancelThunk);
    [CompilerGeneratedAttribute]
public List`1<ITestCase> get_TestCases();
    [CompilerGeneratedAttribute]
public ManualResetEvent get_Finished();
    public sealed virtual void Dispose();
    private sealed virtual override bool Xunit.Abstractions.IMessageSink.OnMessage(IMessageSinkMessage message);
    public sealed virtual bool OnMessageWithTypes(IMessageSinkMessage message, HashSet`1<string> messageTypes);
    [CompilerGeneratedAttribute]
private void <.ctor>b__2_1(MessageHandlerArgs`1<ITestCaseDiscoveryMessage> args);
    [CompilerGeneratedAttribute]
private void <.ctor>b__2_2(MessageHandlerArgs`1<IDiscoveryCompleteMessage> args);
}
[ObsoleteAttribute("This class has poor performance; please use TestDiscoverySink instead.")]
public class Xunit.TestDiscoveryVisitor : TestMessageVisitor`1<IDiscoveryCompleteMessage> {
    [CompilerGeneratedAttribute]
private List`1<ITestCase> <TestCases>k__BackingField;
    public List`1<ITestCase> TestCases { get; private set; }
    [CompilerGeneratedAttribute]
public List`1<ITestCase> get_TestCases();
    [CompilerGeneratedAttribute]
private void set_TestCases(List`1<ITestCase> value);
    protected virtual bool Visit(ITestCaseDiscoveryMessage testCaseDiscovered);
}
public class Xunit.TestExecutionSummary : object {
    private static HashSet`1<string> interfaceTypes;
    [CompilerGeneratedAttribute]
private TimeSpan <ElapsedClockTime>k__BackingField;
    [CompilerGeneratedAttribute]
private List`1<KeyValuePair`2<string, ExecutionSummary>> <Summaries>k__BackingField;
    public TimeSpan ElapsedClockTime { get; private set; }
    public HashSet`1<string> InterfaceTypes { get; }
    public List`1<KeyValuePair`2<string, ExecutionSummary>> Summaries { get; private set; }
    public TestExecutionSummary(TimeSpan elapsedClockTime, List`1<KeyValuePair`2<string, ExecutionSummary>> summaries);
    private static TestExecutionSummary();
    [CompilerGeneratedAttribute]
public sealed virtual TimeSpan get_ElapsedClockTime();
    [CompilerGeneratedAttribute]
private void set_ElapsedClockTime(TimeSpan value);
    public sealed virtual HashSet`1<string> get_InterfaceTypes();
    [CompilerGeneratedAttribute]
public sealed virtual List`1<KeyValuePair`2<string, ExecutionSummary>> get_Summaries();
    [CompilerGeneratedAttribute]
private void set_Summaries(List`1<KeyValuePair`2<string, ExecutionSummary>> value);
}
public class Xunit.TestFailed : TestResultMessage {
    [CompilerGeneratedAttribute]
private String[] <ExceptionTypes>k__BackingField;
    [CompilerGeneratedAttribute]
private String[] <Messages>k__BackingField;
    [CompilerGeneratedAttribute]
private String[] <StackTraces>k__BackingField;
    [CompilerGeneratedAttribute]
private Int32[] <ExceptionParentIndices>k__BackingField;
    public String[] ExceptionTypes { get; private set; }
    public String[] Messages { get; private set; }
    public String[] StackTraces { get; private set; }
    public Int32[] ExceptionParentIndices { get; private set; }
    public TestFailed(ITest test, decimal executionTime, string output, String[] exceptionTypes, String[] messages, String[] stackTraces, Int32[] exceptionParentIndices);
    public TestFailed(ITest test, decimal executionTime, string output, Exception ex);
    [CompilerGeneratedAttribute]
public sealed virtual String[] get_ExceptionTypes();
    [CompilerGeneratedAttribute]
private void set_ExceptionTypes(String[] value);
    [CompilerGeneratedAttribute]
public sealed virtual String[] get_Messages();
    [CompilerGeneratedAttribute]
private void set_Messages(String[] value);
    [CompilerGeneratedAttribute]
public sealed virtual String[] get_StackTraces();
    [CompilerGeneratedAttribute]
private void set_StackTraces(String[] value);
    [CompilerGeneratedAttribute]
public sealed virtual Int32[] get_ExceptionParentIndices();
    [CompilerGeneratedAttribute]
private void set_ExceptionParentIndices(Int32[] value);
}
public class Xunit.TestFinished : TestMessage {
    [CompilerGeneratedAttribute]
private decimal <ExecutionTime>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Output>k__BackingField;
    public decimal ExecutionTime { get; private set; }
    public string Output { get; private set; }
    public TestFinished(ITest test, decimal executionTime, string output);
    [CompilerGeneratedAttribute]
public sealed virtual decimal get_ExecutionTime();
    [CompilerGeneratedAttribute]
private void set_ExecutionTime(decimal value);
    [CompilerGeneratedAttribute]
public sealed virtual string get_Output();
    [CompilerGeneratedAttribute]
private void set_Output(string value);
}
[DebuggerDisplayAttribute("{ToDebuggerDisplay(),nq}")]
public class Xunit.TestFrameworkOptions : object {
    private Dictionary`2<string, object> properties;
    public static ITestFrameworkDiscoveryOptions ForDiscovery(TestAssemblyConfiguration configuration);
    public static ITestFrameworkExecutionOptions ForExecution(TestAssemblyConfiguration configuration);
    public sealed virtual TValue GetValue(string name);
    public sealed virtual void SetValue(string name, TValue value);
    private string ToDebuggerDisplay();
    private string ToDebuggerDisplay(object value);
    [CompilerGeneratedAttribute]
private string <ToDebuggerDisplay>b__6_0(KeyValuePair`2<string, object> p);
}
public class Xunit.TestMessage : TestCaseMessage {
    [CompilerGeneratedAttribute]
private ITest <Test>k__BackingField;
    public ITest Test { get; private set; }
    public TestMessage(ITest test);
    [CompilerGeneratedAttribute]
public sealed virtual ITest get_Test();
    [CompilerGeneratedAttribute]
private void set_Test(ITest value);
}
public class Xunit.TestMessageSink : AggregateMessageSink {
    private DiagnosticEventSink diagnostics;
    private DiscoveryEventSink discovery;
    private ExecutionEventSink execution;
    private RunnerEventSink runner;
    public DiagnosticEventSink Diagnostics { get; }
    public DiscoveryEventSink Discovery { get; }
    public ExecutionEventSink Execution { get; }
    public RunnerEventSink Runner { get; }
    public DiagnosticEventSink get_Diagnostics();
    public DiscoveryEventSink get_Discovery();
    public ExecutionEventSink get_Execution();
    public RunnerEventSink get_Runner();
    public sealed virtual bool OnMessage(IMessageSinkMessage message);
}
[ObsoleteAttribute("This class has poor performance; please use TestMessageSink instead.")]
public class Xunit.TestMessageVisitor : LongLivedMarshalByRefObject {
    protected static bool DoVisit(IMessageSinkMessage message, Func`2<TMessage, bool> callback);
    private bool DoVisit(IMessageSinkMessage message, Func`3<TestMessageVisitor, TMessage, bool> callback);
    public virtual bool OnMessage(IMessageSinkMessage message);
    protected virtual bool Visit(ITestAssemblyDiscoveryFinished discoveryFinished);
    protected virtual bool Visit(ITestAssemblyDiscoveryStarting discoveryStarting);
    protected virtual bool Visit(ITestAssemblyExecutionFinished executionFinished);
    protected virtual bool Visit(ITestAssemblyExecutionStarting executionStarting);
    protected virtual bool Visit(ITestExecutionSummary executionSummary);
    protected virtual bool Visit(IAfterTestFinished afterTestFinished);
    protected virtual bool Visit(IAfterTestStarting afterTestStarting);
    protected virtual bool Visit(IBeforeTestFinished beforeTestFinished);
    protected virtual bool Visit(IBeforeTestStarting beforeTestStarting);
    protected virtual bool Visit(IDiagnosticMessage diagnosticMessage);
    protected virtual bool Visit(IDiscoveryCompleteMessage discoveryComplete);
    protected virtual bool Visit(IErrorMessage error);
    protected virtual bool Visit(ITestAssemblyCleanupFailure cleanupFailure);
    protected virtual bool Visit(ITestAssemblyFinished assemblyFinished);
    protected virtual bool Visit(ITestAssemblyStarting assemblyStarting);
    protected virtual bool Visit(ITestCaseCleanupFailure cleanupFailure);
    protected virtual bool Visit(ITestCaseDiscoveryMessage testCaseDiscovered);
    protected virtual bool Visit(ITestCaseFinished testCaseFinished);
    protected virtual bool Visit(ITestOutput testCaseOutput);
    protected virtual bool Visit(ITestCaseStarting testCaseStarting);
    protected virtual bool Visit(ITestClassCleanupFailure cleanupFailure);
    protected virtual bool Visit(ITestClassConstructionFinished testClassConstructionFinished);
    protected virtual bool Visit(ITestClassConstructionStarting testClassConstructionStarting);
    protected virtual bool Visit(ITestClassDisposeFinished testClassDisposedFinished);
    protected virtual bool Visit(ITestClassDisposeStarting testClassDisposeStarting);
    protected virtual bool Visit(ITestClassFinished testClassFinished);
    protected virtual bool Visit(ITestClassStarting testClassStarting);
    protected virtual bool Visit(ITestCleanupFailure cleanupFailure);
    protected virtual bool Visit(ITestCollectionCleanupFailure cleanupFailure);
    protected virtual bool Visit(ITestCollectionFinished testCollectionFinished);
    protected virtual bool Visit(ITestCollectionStarting testCollectionStarting);
    protected virtual bool Visit(ITestFailed testFailed);
    protected virtual bool Visit(ITestFinished testFinished);
    protected virtual bool Visit(ITestMethodCleanupFailure cleanupFailure);
    protected virtual bool Visit(ITestMethodFinished testMethodFinished);
    protected virtual bool Visit(ITestMethodStarting testMethodStarting);
    protected virtual bool Visit(ITestPassed testPassed);
    protected virtual bool Visit(ITestSkipped testSkipped);
    protected virtual bool Visit(ITestStarting testStarting);
}
[ObsoleteAttribute("This class has poor performance; please use TestMessageSink instead.")]
public class Xunit.TestMessageVisitor`1 : TestMessageVisitor {
    [CompilerGeneratedAttribute]
private ManualResetEvent <Finished>k__BackingField;
    public ManualResetEvent Finished { get; private set; }
    [CompilerGeneratedAttribute]
public sealed virtual ManualResetEvent get_Finished();
    [CompilerGeneratedAttribute]
private void set_Finished(ManualResetEvent value);
    public sealed virtual void Dispose();
    public virtual bool OnMessage(IMessageSinkMessage message);
}
public class Xunit.TestMethodCleanupFailure : TestMethodMessage {
    [CompilerGeneratedAttribute]
private String[] <ExceptionTypes>k__BackingField;
    [CompilerGeneratedAttribute]
private String[] <Messages>k__BackingField;
    [CompilerGeneratedAttribute]
private String[] <StackTraces>k__BackingField;
    [CompilerGeneratedAttribute]
private Int32[] <ExceptionParentIndices>k__BackingField;
    public String[] ExceptionTypes { get; private set; }
    public String[] Messages { get; private set; }
    public String[] StackTraces { get; private set; }
    public Int32[] ExceptionParentIndices { get; private set; }
    public TestMethodCleanupFailure(IEnumerable`1<ITestCase> testCases, ITestMethod testMethod, String[] exceptionTypes, String[] messages, String[] stackTraces, Int32[] exceptionParentIndices);
    public TestMethodCleanupFailure(IEnumerable`1<ITestCase> testCases, ITestMethod testMethod, Exception ex);
    [CompilerGeneratedAttribute]
public sealed virtual String[] get_ExceptionTypes();
    [CompilerGeneratedAttribute]
private void set_ExceptionTypes(String[] value);
    [CompilerGeneratedAttribute]
public sealed virtual String[] get_Messages();
    [CompilerGeneratedAttribute]
private void set_Messages(String[] value);
    [CompilerGeneratedAttribute]
public sealed virtual String[] get_StackTraces();
    [CompilerGeneratedAttribute]
private void set_StackTraces(String[] value);
    [CompilerGeneratedAttribute]
public sealed virtual Int32[] get_ExceptionParentIndices();
    [CompilerGeneratedAttribute]
private void set_ExceptionParentIndices(Int32[] value);
}
public enum Xunit.TestMethodDisplay : Enum {
    public int value__;
    public static TestMethodDisplay ClassAndMethod;
    public static TestMethodDisplay Method;
}
public class Xunit.TestMethodFinished : TestMethodMessage {
    [CompilerGeneratedAttribute]
private decimal <ExecutionTime>k__BackingField;
    [CompilerGeneratedAttribute]
private int <TestsFailed>k__BackingField;
    [CompilerGeneratedAttribute]
private int <TestsRun>k__BackingField;
    [CompilerGeneratedAttribute]
private int <TestsSkipped>k__BackingField;
    public decimal ExecutionTime { get; private set; }
    public int TestsFailed { get; private set; }
    public int TestsRun { get; private set; }
    public int TestsSkipped { get; private set; }
    public TestMethodFinished(IEnumerable`1<ITestCase> testCases, ITestMethod testMethod, decimal executionTime, int testsRun, int testsFailed, int testsSkipped);
    [CompilerGeneratedAttribute]
public sealed virtual decimal get_ExecutionTime();
    [CompilerGeneratedAttribute]
private void set_ExecutionTime(decimal value);
    [CompilerGeneratedAttribute]
public sealed virtual int get_TestsFailed();
    [CompilerGeneratedAttribute]
private void set_TestsFailed(int value);
    [CompilerGeneratedAttribute]
public sealed virtual int get_TestsRun();
    [CompilerGeneratedAttribute]
private void set_TestsRun(int value);
    [CompilerGeneratedAttribute]
public sealed virtual int get_TestsSkipped();
    [CompilerGeneratedAttribute]
private void set_TestsSkipped(int value);
}
public class Xunit.TestMethodMessage : TestClassMessage {
    [CompilerGeneratedAttribute]
private ITestMethod <TestMethod>k__BackingField;
    public ITestMethod TestMethod { get; public set; }
    public TestMethodMessage(IEnumerable`1<ITestCase> testCases, ITestMethod testMethod);
    internal TestMethodMessage(ITestCase testCase, ITestMethod testMethod);
    [CompilerGeneratedAttribute]
public sealed virtual ITestMethod get_TestMethod();
    [CompilerGeneratedAttribute]
public void set_TestMethod(ITestMethod value);
}
public class Xunit.TestMethodStarting : TestMethodMessage {
    public TestMethodStarting(IEnumerable`1<ITestCase> testCases, ITestMethod testMethod);
}
public class Xunit.TestOutput : TestMessage {
    [CompilerGeneratedAttribute]
private string <Output>k__BackingField;
    public string Output { get; private set; }
    public TestOutput(ITest test, string output);
    [CompilerGeneratedAttribute]
public sealed virtual string get_Output();
    [CompilerGeneratedAttribute]
private void set_Output(string value);
}
public class Xunit.TestPassed : TestResultMessage {
    public TestPassed(ITest test, decimal executionTime, string output);
}
public class Xunit.TestResultMessage : TestMessage {
    [CompilerGeneratedAttribute]
private decimal <ExecutionTime>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Output>k__BackingField;
    public decimal ExecutionTime { get; private set; }
    public string Output { get; private set; }
    public TestResultMessage(ITest test, decimal executionTime, string output);
    [CompilerGeneratedAttribute]
public sealed virtual decimal get_ExecutionTime();
    [CompilerGeneratedAttribute]
private void set_ExecutionTime(decimal value);
    [CompilerGeneratedAttribute]
public sealed virtual string get_Output();
    [CompilerGeneratedAttribute]
private void set_Output(string value);
}
public class Xunit.TestSkipped : TestResultMessage {
    [CompilerGeneratedAttribute]
private string <Reason>k__BackingField;
    public string Reason { get; private set; }
    public TestSkipped(ITest test, string reason);
    [CompilerGeneratedAttribute]
public sealed virtual string get_Reason();
    [CompilerGeneratedAttribute]
private void set_Reason(string value);
}
public class Xunit.TestStarting : TestMessage {
    public TestStarting(ITest test);
}
public class Xunit.VisualStudioSourceInformationProvider : LongLivedMarshalByRefObject {
    private static SourceInformation EmptySourceInformation;
    private DiaSessionWrapper session;
    public VisualStudioSourceInformationProvider(string assemblyFileName);
    private static VisualStudioSourceInformationProvider();
    public sealed virtual ISourceInformation GetSourceInformation(ITestCase testCase);
    public sealed virtual void Dispose();
}
[ObsoleteAttribute("This class has poor performance; please use DelegatingExecutionSummarySink and/or DelegatingXmlCreationSink instead.")]
public class Xunit.XmlAggregateVisitor : XmlTestExecutionVisitor {
    private ConcurrentDictionary`2<string, ExecutionSummary> completionMessages;
    private IMessageSink innerMessageSink;
    [CompilerGeneratedAttribute]
private ExecutionSummary <ExecutionSummary>k__BackingField;
    public ExecutionSummary ExecutionSummary { get; private set; }
    public XmlAggregateVisitor(IMessageSink innerMessageSink, ConcurrentDictionary`2<string, ExecutionSummary> completionMessages, XElement assemblyElement, Func`1<bool> cancelThunk);
    [CompilerGeneratedAttribute]
public sealed virtual ExecutionSummary get_ExecutionSummary();
    [CompilerGeneratedAttribute]
private void set_ExecutionSummary(ExecutionSummary value);
    protected virtual bool Visit(ITestAssemblyFinished assemblyFinished);
    public virtual bool OnMessage(IMessageSinkMessage message);
}
public class Xunit.XmlNodeCallbackHandler : LongLivedMarshalByRefObject {
    private Predicate`1<XmlNode> callback;
    private bool continue;
    private string lastNodeName;
    [CompilerGeneratedAttribute]
private XmlNode <LastNode>k__BackingField;
    [CompilerGeneratedAttribute]
private ManualResetEvent <LastNodeArrived>k__BackingField;
    public XmlNode LastNode { get; protected set; }
    public ManualResetEvent LastNodeArrived { get; protected set; }
    public XmlNodeCallbackHandler(Predicate`1<XmlNode> callback, string lastNodeName);
    [CompilerGeneratedAttribute]
public XmlNode get_LastNode();
    [CompilerGeneratedAttribute]
protected void set_LastNode(XmlNode value);
    [CompilerGeneratedAttribute]
public ManualResetEvent get_LastNodeArrived();
    [CompilerGeneratedAttribute]
protected void set_LastNodeArrived(ManualResetEvent value);
    public virtual bool OnXmlNode(XmlNode node);
    private sealed virtual override string System.Web.UI.ICallbackEventHandler.GetCallbackResult();
    private sealed virtual override void System.Web.UI.ICallbackEventHandler.RaiseCallbackEvent(string eventArgument);
}
[ObsoleteAttribute("This class has poor performance; please use DelegatingXmlCreationSink instead.")]
public class Xunit.XmlTestExecutionVisitor : TestMessageVisitor`1<ITestAssemblyFinished> {
    private XElement assemblyElement;
    private XElement errorsElement;
    private ConcurrentDictionary`2<Guid, XElement> testCollectionElements;
    [CompilerGeneratedAttribute]
private Func`1<bool> <CancelThunk>k__BackingField;
    [CompilerGeneratedAttribute]
private int <Errors>k__BackingField;
    [CompilerGeneratedAttribute]
private int <Failed>k__BackingField;
    [CompilerGeneratedAttribute]
private int <Skipped>k__BackingField;
    [CompilerGeneratedAttribute]
private decimal <Time>k__BackingField;
    [CompilerGeneratedAttribute]
private int <Total>k__BackingField;
    public Func`1<bool> CancelThunk { get; }
    public int Errors { get; public set; }
    public int Failed { get; public set; }
    public int Skipped { get; public set; }
    public decimal Time { get; public set; }
    public int Total { get; public set; }
    public XmlTestExecutionVisitor(XElement assemblyElement, Func`1<bool> cancelThunk);
    [CompilerGeneratedAttribute]
public Func`1<bool> get_CancelThunk();
    [CompilerGeneratedAttribute]
public int get_Errors();
    [CompilerGeneratedAttribute]
public void set_Errors(int value);
    [CompilerGeneratedAttribute]
public int get_Failed();
    [CompilerGeneratedAttribute]
public void set_Failed(int value);
    [CompilerGeneratedAttribute]
public int get_Skipped();
    [CompilerGeneratedAttribute]
public void set_Skipped(int value);
    [CompilerGeneratedAttribute]
public decimal get_Time();
    [CompilerGeneratedAttribute]
public void set_Time(decimal value);
    [CompilerGeneratedAttribute]
public int get_Total();
    [CompilerGeneratedAttribute]
public void set_Total(int value);
    private XElement CreateTestResultElement(ITestResultMessage testResult, string resultText);
    private XElement GetTestCollectionElement(ITestCollection testCollection);
    public virtual bool OnMessage(IMessageSinkMessage message);
    protected virtual bool Visit(ITestAssemblyFinished assemblyFinished);
    protected virtual bool Visit(ITestAssemblyStarting assemblyStarting);
    protected virtual bool Visit(ITestCollectionFinished testCollectionFinished);
    protected virtual bool Visit(ITestFailed testFailed);
    protected virtual bool Visit(ITestPassed testPassed);
    protected virtual bool Visit(ITestSkipped testSkipped);
    protected virtual bool Visit(IErrorMessage error);
    protected virtual bool Visit(ITestAssemblyCleanupFailure cleanupFailure);
    protected virtual bool Visit(ITestCaseCleanupFailure cleanupFailure);
    protected virtual bool Visit(ITestClassCleanupFailure cleanupFailure);
    protected virtual bool Visit(ITestCollectionCleanupFailure cleanupFailure);
    protected virtual bool Visit(ITestCleanupFailure cleanupFailure);
    protected virtual bool Visit(ITestMethodCleanupFailure cleanupFailure);
    private void AddError(string type, string name, IFailureInformation failureInfo);
    private static XElement CreateFailureElement(IFailureInformation failureInfo);
    private static string Escape(string value);
    protected static string XmlEscape(string value);
}
public class Xunit.Xunit1 : object {
    private AppDomainSupport appDomainSupport;
    private string assemblyFileName;
    private string configFileName;
    private IXunit1Executor executor;
    private bool shadowCopy;
    private string shadowCopyFolder;
    private ISourceInformationProvider sourceInformationProvider;
    private Stack`1<IDisposable> toDispose;
    public bool CanUseAppDomains { get; }
    public string TargetFramework { get; }
    public string TestFrameworkDisplayName { get; }
    public Xunit1(AppDomainSupport appDomainSupport, ISourceInformationProvider sourceInformationProvider, string assemblyFileName, string configFileName, bool shadowCopy, string shadowCopyFolder);
    public sealed virtual bool get_CanUseAppDomains();
    public sealed virtual string get_TargetFramework();
    public sealed virtual string get_TestFrameworkDisplayName();
    protected virtual IXunit1Executor CreateExecutor();
    public sealed virtual ITestCase Deserialize(string value);
    public sealed virtual void Dispose();
    private void EnsureInitialized();
    public void Find(bool includeSourceInformation, IMessageSink messageSink);
    private sealed virtual override void Xunit.Abstractions.ITestFrameworkDiscoverer.Find(bool includeSourceInformation, IMessageSink messageSink, ITestFrameworkDiscoveryOptions discoveryOptions);
    public void Find(string typeName, bool includeSourceInformation, IMessageSink messageSink);
    private sealed virtual override void Xunit.Abstractions.ITestFrameworkDiscoverer.Find(string typeName, bool includeSourceInformation, IMessageSink messageSink, ITestFrameworkDiscoveryOptions discoveryOptions);
    private void Find(Predicate`1<ITestCaseDiscoveryMessage> filter, bool includeSourceInformation, IMessageSink messageSink);
    public void Run(IMessageSink messageSink);
    private sealed virtual override void Xunit.Abstractions.ITestFrameworkExecutor.RunAll(IMessageSink messageSink, ITestFrameworkDiscoveryOptions discoveryOptions, ITestFrameworkExecutionOptions executionOptions);
    public void Run(IEnumerable`1<ITestCase> testCases, IMessageSink messageSink);
    private sealed virtual override void Xunit.Abstractions.ITestFrameworkExecutor.RunTests(IEnumerable`1<ITestCase> testCases, IMessageSink messageSink, ITestFrameworkExecutionOptions executionOptions);
    private Xunit1RunSummary RunTestCollection(ITestCollection testCollection, IEnumerable`1<ITestCase> testCases, IMessageSink messageSink);
    private Xunit1RunSummary RunTestClass(ITestClass testClass, IList`1<ITestCase> testCases, IMessageSink messageSink);
    public sealed virtual string Serialize(ITestCase testCase);
}
public class Xunit.Xunit1AssemblyInfo : object {
    [CompilerGeneratedAttribute]
private string <AssemblyFileName>k__BackingField;
    public string AssemblyFileName { get; private set; }
    private string Xunit.Abstractions.IAssemblyInfo.AssemblyPath { get; }
    private string Xunit.Abstractions.IAssemblyInfo.Name { get; }
    public Xunit1AssemblyInfo(string assemblyFileName);
    [CompilerGeneratedAttribute]
public string get_AssemblyFileName();
    [CompilerGeneratedAttribute]
private void set_AssemblyFileName(string value);
    private sealed virtual override string Xunit.Abstractions.IAssemblyInfo.get_AssemblyPath();
    private sealed virtual override string Xunit.Abstractions.IAssemblyInfo.get_Name();
    private sealed virtual override IEnumerable`1<IAttributeInfo> Xunit.Abstractions.IAssemblyInfo.GetCustomAttributes(string assemblyQualifiedAttributeTypeName);
    private sealed virtual override ITypeInfo Xunit.Abstractions.IAssemblyInfo.GetType(string typeName);
    private sealed virtual override IEnumerable`1<ITypeInfo> Xunit.Abstractions.IAssemblyInfo.GetTypes(bool includePrivateTypes);
}
internal static class Xunit.Xunit1ExceptionUtility : object {
    private static Regex NestedMessagesRegex;
    private static Regex NestedStackTracesRegex;
    private static Xunit1ExceptionUtility();
    public static IFailureInformation ConvertToFailureInformation(Exception exception);
    public static IFailureInformation ConvertToFailureInformation(XmlNode failureNode);
    private static IFailureInformation ConvertToFailureInformation(string outermostExceptionType, string nestedExceptionMessages, string nestedStackTraces);
}
public class Xunit.Xunit1Executor : object {
    private object executor;
    private IAppDomainManager appDomain;
    private AssemblyName xunitAssemblyName;
    private string xunitAssemblyPath;
    [CompilerGeneratedAttribute]
private string <TestFrameworkDisplayName>k__BackingField;
    public string TestFrameworkDisplayName { get; private set; }
    public Xunit1Executor(bool useAppDomain, string testAssemblyFileName, string configFileName, bool shadowCopy, string shadowCopyFolder);
    [CompilerGeneratedAttribute]
public sealed virtual string get_TestFrameworkDisplayName();
    [CompilerGeneratedAttribute]
private void set_TestFrameworkDisplayName(string value);
    private object CreateObject(string typeName, Object[] args);
    public sealed virtual void Dispose();
    public sealed virtual void EnumerateTests(ICallbackEventHandler handler);
    private static string GetXunitAssemblyPath(string testAssemblyFileName);
    public sealed virtual void RunTests(string type, List`1<string> methods, ICallbackEventHandler handler);
}
public class Xunit.Xunit1ReflectionWrapper : object {
    private static Xunit1ReflectionWrapper VoidType;
    [CompilerGeneratedAttribute]
private string <AssemblyFileName>k__BackingField;
    [CompilerGeneratedAttribute]
private string <MethodName>k__BackingField;
    [CompilerGeneratedAttribute]
private string <TypeName>k__BackingField;
    [CompilerGeneratedAttribute]
private string <UniqueID>k__BackingField;
    public string AssemblyFileName { get; private set; }
    public string MethodName { get; private set; }
    public string TypeName { get; private set; }
    public string UniqueID { get; private set; }
    private string Xunit.Abstractions.IAssemblyInfo.AssemblyPath { get; }
    private string Xunit.Abstractions.IAssemblyInfo.Name { get; }
    private bool Xunit.Abstractions.IMethodInfo.IsAbstract { get; }
    private bool Xunit.Abstractions.IMethodInfo.IsGenericMethodDefinition { get; }
    private bool Xunit.Abstractions.IMethodInfo.IsPublic { get; }
    private bool Xunit.Abstractions.IMethodInfo.IsStatic { get; }
    private string Xunit.Abstractions.IMethodInfo.Name { get; }
    private ITypeInfo Xunit.Abstractions.IMethodInfo.ReturnType { get; }
    private ITypeInfo Xunit.Abstractions.IMethodInfo.Type { get; }
    private IAssemblyInfo Xunit.Abstractions.ITypeInfo.Assembly { get; }
    private ITypeInfo Xunit.Abstractions.ITypeInfo.BaseType { get; }
    private IEnumerable`1<ITypeInfo> Xunit.Abstractions.ITypeInfo.Interfaces { get; }
    private bool Xunit.Abstractions.ITypeInfo.IsAbstract { get; }
    private bool Xunit.Abstractions.ITypeInfo.IsGenericParameter { get; }
    private bool Xunit.Abstractions.ITypeInfo.IsGenericType { get; }
    private bool Xunit.Abstractions.ITypeInfo.IsSealed { get; }
    private bool Xunit.Abstractions.ITypeInfo.IsValueType { get; }
    private string Xunit.Abstractions.ITypeInfo.Name { get; }
    public Xunit1ReflectionWrapper(string assemblyFileName, string typeName, string methodName);
    private static Xunit1ReflectionWrapper();
    [CompilerGeneratedAttribute]
public string get_AssemblyFileName();
    [CompilerGeneratedAttribute]
private void set_AssemblyFileName(string value);
    [CompilerGeneratedAttribute]
public string get_MethodName();
    [CompilerGeneratedAttribute]
private void set_MethodName(string value);
    [CompilerGeneratedAttribute]
public string get_TypeName();
    [CompilerGeneratedAttribute]
private void set_TypeName(string value);
    [CompilerGeneratedAttribute]
public string get_UniqueID();
    [CompilerGeneratedAttribute]
private void set_UniqueID(string value);
    private sealed virtual override string Xunit.Abstractions.IAssemblyInfo.get_AssemblyPath();
    private sealed virtual override string Xunit.Abstractions.IAssemblyInfo.get_Name();
    private sealed virtual override IEnumerable`1<IAttributeInfo> Xunit.Abstractions.IAssemblyInfo.GetCustomAttributes(string assemblyQualifiedAttributeTypeName);
    private sealed virtual override ITypeInfo Xunit.Abstractions.IAssemblyInfo.GetType(string typeName);
    [IteratorStateMachineAttribute("Xunit.Xunit1ReflectionWrapper/<Xunit-Abstractions-IAssemblyInfo-GetTypes>d__24")]
private sealed virtual override IEnumerable`1<ITypeInfo> Xunit.Abstractions.IAssemblyInfo.GetTypes(bool includePrivateTypes);
    private sealed virtual override bool Xunit.Abstractions.IMethodInfo.get_IsAbstract();
    private sealed virtual override bool Xunit.Abstractions.IMethodInfo.get_IsGenericMethodDefinition();
    private sealed virtual override bool Xunit.Abstractions.IMethodInfo.get_IsPublic();
    private sealed virtual override bool Xunit.Abstractions.IMethodInfo.get_IsStatic();
    private sealed virtual override string Xunit.Abstractions.IMethodInfo.get_Name();
    private sealed virtual override ITypeInfo Xunit.Abstractions.IMethodInfo.get_ReturnType();
    private sealed virtual override ITypeInfo Xunit.Abstractions.IMethodInfo.get_Type();
    private sealed virtual override IEnumerable`1<IAttributeInfo> Xunit.Abstractions.IMethodInfo.GetCustomAttributes(string assemblyQualifiedAttributeTypeName);
    private sealed virtual override IEnumerable`1<ITypeInfo> Xunit.Abstractions.IMethodInfo.GetGenericArguments();
    private sealed virtual override IEnumerable`1<IParameterInfo> Xunit.Abstractions.IMethodInfo.GetParameters();
    private sealed virtual override IMethodInfo Xunit.Abstractions.IMethodInfo.MakeGenericMethod(ITypeInfo[] typeArguments);
    private sealed virtual override IAssemblyInfo Xunit.Abstractions.ITypeInfo.get_Assembly();
    private sealed virtual override ITypeInfo Xunit.Abstractions.ITypeInfo.get_BaseType();
    private sealed virtual override IEnumerable`1<ITypeInfo> Xunit.Abstractions.ITypeInfo.get_Interfaces();
    private sealed virtual override bool Xunit.Abstractions.ITypeInfo.get_IsAbstract();
    private sealed virtual override bool Xunit.Abstractions.ITypeInfo.get_IsGenericParameter();
    private sealed virtual override bool Xunit.Abstractions.ITypeInfo.get_IsGenericType();
    private sealed virtual override bool Xunit.Abstractions.ITypeInfo.get_IsSealed();
    private sealed virtual override bool Xunit.Abstractions.ITypeInfo.get_IsValueType();
    private sealed virtual override string Xunit.Abstractions.ITypeInfo.get_Name();
    private sealed virtual override IEnumerable`1<IAttributeInfo> Xunit.Abstractions.ITypeInfo.GetCustomAttributes(string assemblyQualifiedAttributeTypeName);
    private sealed virtual override IEnumerable`1<ITypeInfo> Xunit.Abstractions.ITypeInfo.GetGenericArguments();
    private sealed virtual override IMethodInfo Xunit.Abstractions.ITypeInfo.GetMethod(string methodName, bool includePrivateMethods);
    [IteratorStateMachineAttribute("Xunit.Xunit1ReflectionWrapper/<Xunit-Abstractions-ITypeInfo-GetMethods>d__64")]
private sealed virtual override IEnumerable`1<IMethodInfo> Xunit.Abstractions.ITypeInfo.GetMethods(bool includePrivateMethods);
}
public class Xunit.Xunit1RunSummary : object {
    public bool Continue;
    public int Total;
    public int Failed;
    public int Skipped;
    public decimal Time;
    public void Aggregate(Xunit1RunSummary other);
    public void Reset();
}
public class Xunit.Xunit1Test : LongLivedMarshalByRefObject {
    [CompilerGeneratedAttribute]
private string <DisplayName>k__BackingField;
    [CompilerGeneratedAttribute]
private ITestCase <TestCase>k__BackingField;
    public string DisplayName { get; private set; }
    public ITestCase TestCase { get; private set; }
    public Xunit1Test(ITestCase testCase, string displayName);
    [CompilerGeneratedAttribute]
public sealed virtual string get_DisplayName();
    [CompilerGeneratedAttribute]
private void set_DisplayName(string value);
    [CompilerGeneratedAttribute]
public sealed virtual ITestCase get_TestCase();
    [CompilerGeneratedAttribute]
private void set_TestCase(ITestCase value);
}
public class Xunit.Xunit1TestCase : object {
    private static Dictionary`2<string, List`1<string>> EmptyTraits;
    private Xunit1ReflectionWrapper reflectionWrapper;
    [CompilerGeneratedAttribute]
private string <DisplayName>k__BackingField;
    [CompilerGeneratedAttribute]
private string <SkipReason>k__BackingField;
    [CompilerGeneratedAttribute]
private ISourceInformation <SourceInformation>k__BackingField;
    [CompilerGeneratedAttribute]
private Object[] <TestMethodArguments>k__BackingField;
    [CompilerGeneratedAttribute]
private Dictionary`2<string, List`1<string>> <Traits>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ConfigFileName>k__BackingField;
    public string DisplayName { get; public set; }
    public string SkipReason { get; public set; }
    public ISourceInformation SourceInformation { get; public set; }
    public ITestMethod TestMethod { get; }
    public Object[] TestMethodArguments { get; public set; }
    public Dictionary`2<string, List`1<string>> Traits { get; public set; }
    public string UniqueID { get; }
    private IAssemblyInfo Xunit.Abstractions.ITestAssembly.Assembly { get; }
    public string ConfigFileName { get; public set; }
    private ITypeInfo Xunit.Abstractions.ITestCollection.CollectionDefinition { get; }
    private string Xunit.Abstractions.ITestCollection.DisplayName { get; }
    private ITestAssembly Xunit.Abstractions.ITestCollection.TestAssembly { get; }
    private Guid Xunit.Abstractions.ITestCollection.UniqueID { get; }
    private ITypeInfo Xunit.Abstractions.ITestClass.Class { get; }
    private ITestCollection Xunit.Abstractions.ITestClass.TestCollection { get; }
    private IMethodInfo Xunit.Abstractions.ITestMethod.Method { get; }
    private ITestClass Xunit.Abstractions.ITestMethod.TestClass { get; }
    public Xunit1TestCase(string assemblyFileName, string configFileName, string typeName, string methodName, string displayName, Dictionary`2<string, List`1<string>> traits, string skipReason);
    private static Xunit1TestCase();
    [CompilerGeneratedAttribute]
public sealed virtual string get_DisplayName();
    [CompilerGeneratedAttribute]
public void set_DisplayName(string value);
    [CompilerGeneratedAttribute]
public sealed virtual string get_SkipReason();
    [CompilerGeneratedAttribute]
public void set_SkipReason(string value);
    [CompilerGeneratedAttribute]
public sealed virtual ISourceInformation get_SourceInformation();
    [CompilerGeneratedAttribute]
public sealed virtual void set_SourceInformation(ISourceInformation value);
    public sealed virtual ITestMethod get_TestMethod();
    [CompilerGeneratedAttribute]
public sealed virtual Object[] get_TestMethodArguments();
    [CompilerGeneratedAttribute]
public void set_TestMethodArguments(Object[] value);
    [CompilerGeneratedAttribute]
public sealed virtual Dictionary`2<string, List`1<string>> get_Traits();
    [CompilerGeneratedAttribute]
public void set_Traits(Dictionary`2<string, List`1<string>> value);
    public sealed virtual string get_UniqueID();
    public void Dispose();
    public sealed virtual void Deserialize(IXunitSerializationInfo data);
    public sealed virtual void Serialize(IXunitSerializationInfo data);
    private sealed virtual override IAssemblyInfo Xunit.Abstractions.ITestAssembly.get_Assembly();
    [CompilerGeneratedAttribute]
public sealed virtual string get_ConfigFileName();
    [CompilerGeneratedAttribute]
public void set_ConfigFileName(string value);
    private sealed virtual override ITypeInfo Xunit.Abstractions.ITestCollection.get_CollectionDefinition();
    private sealed virtual override string Xunit.Abstractions.ITestCollection.get_DisplayName();
    private sealed virtual override ITestAssembly Xunit.Abstractions.ITestCollection.get_TestAssembly();
    private sealed virtual override Guid Xunit.Abstractions.ITestCollection.get_UniqueID();
    private sealed virtual override ITypeInfo Xunit.Abstractions.ITestClass.get_Class();
    private sealed virtual override ITestCollection Xunit.Abstractions.ITestClass.get_TestCollection();
    private sealed virtual override IMethodInfo Xunit.Abstractions.ITestMethod.get_Method();
    private sealed virtual override ITestClass Xunit.Abstractions.ITestMethod.get_TestClass();
}
public class Xunit.Xunit2 : Xunit2Discoverer {
    private ITestCaseBulkDeserializer defaultTestCaseBulkDeserializer;
    private ITestFrameworkExecutor remoteExecutor;
    public Xunit2(AppDomainSupport appDomainSupport, ISourceInformationProvider sourceInformationProvider, string assemblyFileName, string configFileName, bool shadowCopy, string shadowCopyFolder, IMessageSink diagnosticMessageSink, bool verifyTestAssemblyExists);
    public sealed virtual List`1<KeyValuePair`2<string, ITestCase>> BulkDeserialize(List`1<string> serializations);
    public sealed virtual ITestCase Deserialize(string value);
    public sealed virtual void Dispose();
    public sealed virtual void RunAll(IMessageSink messageSink, ITestFrameworkDiscoveryOptions discoveryOptions, ITestFrameworkExecutionOptions executionOptions);
    public sealed virtual void RunTests(IEnumerable`1<ITestCase> testCases, IMessageSink messageSink, ITestFrameworkExecutionOptions executionOptions);
}
public class Xunit.Xunit2Discoverer : object {
    private static String[] SupportedPlatforms;
    private static String[] SupportedPlatforms_ForcedAppDomains;
    private AssemblyHelper assemblyHelper;
    private ITestCaseDescriptorProvider defaultTestCaseDescriptorProvider;
    [CompilerGeneratedAttribute]
private IAppDomainManager <AppDomain>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <CanUseAppDomains>k__BackingField;
    [CompilerGeneratedAttribute]
private IMessageSink <DiagnosticMessageSink>k__BackingField;
    [CompilerGeneratedAttribute]
private ITestFramework <Framework>k__BackingField;
    [CompilerGeneratedAttribute]
private ITestFrameworkDiscoverer <RemoteDiscoverer>k__BackingField;
    [CompilerGeneratedAttribute]
private AssemblyName <TestFrameworkAssemblyName>k__BackingField;
    internal IAppDomainManager AppDomain { get; }
    public bool CanUseAppDomains { get; }
    public IMessageSink DiagnosticMessageSink { get; }
    public ITestFramework Framework { get; }
    internal ITestFrameworkDiscoverer RemoteDiscoverer { get; }
    public string TargetFramework { get; }
    internal AssemblyName TestFrameworkAssemblyName { get; }
    public string TestFrameworkDisplayName { get; }
    public Xunit2Discoverer(AppDomainSupport appDomainSupport, ISourceInformationProvider sourceInformationProvider, IAssemblyInfo assemblyInfo, string xunitExecutionAssemblyPath, string shadowCopyFolder, IMessageSink diagnosticMessageSink, bool verifyAssembliesOnDisk);
    internal Xunit2Discoverer(AppDomainSupport appDomainSupport, ISourceInformationProvider sourceInformationProvider, string assemblyFileName, string configFileName, bool shadowCopy, string shadowCopyFolder, IMessageSink diagnosticMessageSink, bool verifyAssembliesOnDisk);
    private Xunit2Discoverer(AppDomainSupport appDomainSupport, ISourceInformationProvider sourceInformationProvider, IAssemblyInfo assemblyInfo, string assemblyFileName, string xunitExecutionAssemblyPath, string configFileName, bool shadowCopy, string shadowCopyFolder, IMessageSink diagnosticMessageSink, bool verifyAssembliesOnDisk);
    private static Xunit2Discoverer();
    [CompilerGeneratedAttribute]
internal IAppDomainManager get_AppDomain();
    [CompilerGeneratedAttribute]
public sealed virtual bool get_CanUseAppDomains();
    [CompilerGeneratedAttribute]
public IMessageSink get_DiagnosticMessageSink();
    [CompilerGeneratedAttribute]
public ITestFramework get_Framework();
    [CompilerGeneratedAttribute]
internal ITestFrameworkDiscoverer get_RemoteDiscoverer();
    public sealed virtual string get_TargetFramework();
    [CompilerGeneratedAttribute]
internal AssemblyName get_TestFrameworkAssemblyName();
    public sealed virtual string get_TestFrameworkDisplayName();
    protected IMessageSink CreateOptimizedRemoteMessageSink(IMessageSink sink);
    public virtual void Dispose();
    public sealed virtual void Find(bool includeSourceInformation, IMessageSink messageSink, ITestFrameworkDiscoveryOptions discoveryOptions);
    public sealed virtual void Find(string typeName, bool includeSourceInformation, IMessageSink messageSink, ITestFrameworkDiscoveryOptions discoveryOptions);
    public sealed virtual List`1<TestCaseDescriptor> GetTestCaseDescriptors(List`1<ITestCase> testCases, bool includeSerialization);
    private static string GetExecutionAssemblyFileName(AppDomainSupport appDomainSupport, string basePath);
    private static String[] GetSupportedPlatformSuffixes(AppDomainSupport appDomainSupport);
    private static AssemblyName GetTestFrameworkAssemblyName(string xunitExecutionAssemblyPath);
    private static string GetXunitExecutionAssemblyPath(AppDomainSupport appDomainSupport, string assemblyFileName, bool verifyTestAssemblyExists);
    private static string GetXunitExecutionAssemblyPath(AppDomainSupport appDomainSupport, IAssemblyInfo assemblyInfo);
    private static bool IsDotNet(string executionAssemblyFileName);
    public sealed virtual string Serialize(ITestCase testCase);
}
public class Xunit.XunitFilters : object {
    private DateTimeOffset cacheDataDate;
    private ChangeTrackingHashSet`1<string> includedMethods;
    private List`1<Regex> methodRegexFilters;
    private HashSet`1<string> methodStandardFilters;
    [CompilerGeneratedAttribute]
private Dictionary`2<string, List`1<string>> <ExcludedTraits>k__BackingField;
    [CompilerGeneratedAttribute]
private Dictionary`2<string, List`1<string>> <IncludedTraits>k__BackingField;
    [CompilerGeneratedAttribute]
private HashSet`1<string> <IncludedClasses>k__BackingField;
    [CompilerGeneratedAttribute]
private HashSet`1<string> <IncludedNameSpaces>k__BackingField;
    public Dictionary`2<string, List`1<string>> ExcludedTraits { get; }
    public Dictionary`2<string, List`1<string>> IncludedTraits { get; }
    public HashSet`1<string> IncludedClasses { get; }
    public ICollection`1<string> IncludedMethods { get; }
    public HashSet`1<string> IncludedNameSpaces { get; }
    [CompilerGeneratedAttribute]
public Dictionary`2<string, List`1<string>> get_ExcludedTraits();
    [CompilerGeneratedAttribute]
public Dictionary`2<string, List`1<string>> get_IncludedTraits();
    [CompilerGeneratedAttribute]
public HashSet`1<string> get_IncludedClasses();
    public ICollection`1<string> get_IncludedMethods();
    [CompilerGeneratedAttribute]
public HashSet`1<string> get_IncludedNameSpaces();
    public bool Filter(ITestCase testCase);
    private bool FilterIncludedNameSpaces(ITestCase testCase);
    private bool FilterIncludedMethodsAndClasses(ITestCase testCase);
    private bool FilterExcludedTraits(ITestCase testCase);
    private bool FilterIncludedTraits(ITestCase testCase);
    private void SplitMethodFilters();
    private string WildcardToRegex(string pattern);
}
public class Xunit.XunitFrontController : object {
    private AppDomainSupport appDomainSupport;
    private string assemblyFileName;
    private ITestCaseBulkDeserializer bulkDeserializer;
    private string configFileName;
    private ITestCaseDescriptorProvider descriptorProvider;
    private IMessageSink diagnosticMessageSink;
    private IFrontController innerController;
    private bool shadowCopy;
    private string shadowCopyFolder;
    private ISourceInformationProvider sourceInformationProvider;
    private Stack`1<IDisposable> toDispose;
    private ITestCaseBulkDeserializer BulkDeserializer { get; }
    public bool CanUseAppDomains { get; }
    private ITestCaseDescriptorProvider DescriptorProvider { get; }
    private IFrontController InnerController { get; }
    public string TargetFramework { get; }
    public string TestFrameworkDisplayName { get; }
    public XunitFrontController(AppDomainSupport appDomainSupport, string assemblyFileName, string configFileName, bool shadowCopy, string shadowCopyFolder, ISourceInformationProvider sourceInformationProvider, IMessageSink diagnosticMessageSink);
    private ITestCaseBulkDeserializer get_BulkDeserializer();
    public sealed virtual bool get_CanUseAppDomains();
    private ITestCaseDescriptorProvider get_DescriptorProvider();
    private IFrontController get_InnerController();
    public sealed virtual string get_TargetFramework();
    public sealed virtual string get_TestFrameworkDisplayName();
    public sealed virtual List`1<KeyValuePair`2<string, ITestCase>> BulkDeserialize(List`1<string> serializations);
    protected virtual IFrontController CreateInnerController();
    public sealed virtual ITestCase Deserialize(string value);
    public sealed virtual void Dispose();
    private void EnsureInitialized();
    public virtual void Find(bool includeSourceInformation, IMessageSink messageSink, ITestFrameworkDiscoveryOptions discoveryOptions);
    public virtual void Find(string typeName, bool includeSourceInformation, IMessageSink messageSink, ITestFrameworkDiscoveryOptions discoveryOptions);
    public sealed virtual List`1<TestCaseDescriptor> GetTestCaseDescriptors(List`1<ITestCase> testCases, bool includeSerialization);
    public virtual void RunAll(IMessageSink messageSink, ITestFrameworkDiscoveryOptions discoveryOptions, ITestFrameworkExecutionOptions executionOptions);
    public virtual void RunTests(IEnumerable`1<ITestCase> testMethods, IMessageSink messageSink, ITestFrameworkExecutionOptions executionOptions);
    public sealed virtual string Serialize(ITestCase testCase);
}
internal class Xunit.XunitPackageCompilationAssemblyResolver : object {
    private static IFileSystem fileSystem;
    private List`1<string> nugetPackageDirectories;
    public XunitPackageCompilationAssemblyResolver(IMessageSink internalDiagnosticsMessageSink);
    private static XunitPackageCompilationAssemblyResolver();
    private static List`1<string> GetDefaultProbeDirectories(IMessageSink internalDiagnosticsMessageSink);
    private static List`1<string> GetDefaultProbeDirectories(Platform osPlatform, IMessageSink internalDiagnosticsMessageSink);
    public sealed virtual bool TryResolveAssemblyPaths(CompilationLibrary library, List`1<string> assemblies);
    private bool TryResolveFromPackagePath(CompilationLibrary library, string basePath, IEnumerable`1& results);
}
public class Xunit.XunitProject : object {
    private List`1<XunitProjectAssembly> assemblies;
    [CompilerGeneratedAttribute]
private XunitFilters <Filters>k__BackingField;
    [CompilerGeneratedAttribute]
private Dictionary`2<string, string> <Output>k__BackingField;
    public IEnumerable`1<XunitProjectAssembly> Assemblies { get; }
    public XunitFilters Filters { get; private set; }
    public Dictionary`2<string, string> Output { get; public set; }
    public IEnumerable`1<XunitProjectAssembly> get_Assemblies();
    [CompilerGeneratedAttribute]
public XunitFilters get_Filters();
    [CompilerGeneratedAttribute]
private void set_Filters(XunitFilters value);
    [CompilerGeneratedAttribute]
public Dictionary`2<string, string> get_Output();
    [CompilerGeneratedAttribute]
public void set_Output(Dictionary`2<string, string> value);
    public void Add(XunitProjectAssembly assembly);
    public sealed virtual IEnumerator`1<XunitProjectAssembly> GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
}
public class Xunit.XunitProjectAssembly : object {
    private TestAssemblyConfiguration configuration;
    [CompilerGeneratedAttribute]
private string <AssemblyFilename>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ConfigFilename>k__BackingField;
    public string AssemblyFilename { get; public set; }
    public string ConfigFilename { get; public set; }
    public TestAssemblyConfiguration Configuration { get; }
    [ObsoleteAttribute("Please use Configuration.ShadowCopyOrDefault (get) or Configuration.ShadowCopy (set) instead")]
public bool ShadowCopy { get; public set; }
    [CompilerGeneratedAttribute]
public string get_AssemblyFilename();
    [CompilerGeneratedAttribute]
public void set_AssemblyFilename(string value);
    [CompilerGeneratedAttribute]
public string get_ConfigFilename();
    [CompilerGeneratedAttribute]
public void set_ConfigFilename(string value);
    public TestAssemblyConfiguration get_Configuration();
    public bool get_ShadowCopy();
    public void set_ShadowCopy(bool value);
}
