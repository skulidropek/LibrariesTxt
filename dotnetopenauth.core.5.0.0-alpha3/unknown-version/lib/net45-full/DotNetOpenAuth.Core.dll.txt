internal static class DotNetOpenAuth.Assumes : object {
    [DebuggerStepThroughAttribute]
internal static void True(bool condition, string message);
    [DebuggerStepThroughAttribute]
internal static void True(bool condition, string unformattedMessage, Object[] args);
    [DebuggerStepThroughAttribute]
internal static void Fail(string message);
    internal static Exception NotReachable();
}
public class DotNetOpenAuth.Configuration.DotNetOpenAuthSection : ConfigurationSectionGroup {
    internal static string SectionName;
    private static string OpenIdElementName;
    private static string OAuthElementName;
    public static MessagingElement Messaging { get; }
    internal static ReportingElement Reporting { get; }
    public static MessagingElement get_Messaging();
    internal static ReportingElement get_Reporting();
    internal static ConfigurationSection GetNamedSection(string name);
}
internal class DotNetOpenAuth.Configuration.HostNameElement : ConfigurationElement {
    private static string NameConfigName;
    [ConfigurationPropertyAttribute("name")]
public string Name { get; public set; }
    internal HostNameElement(string name);
    public string get_Name();
    public void set_Name(string value);
}
internal class DotNetOpenAuth.Configuration.HostNameOrRegexCollection : ConfigurationElementCollection {
    internal IEnumerable`1<string> KeysAsStrings { get; }
    internal IEnumerable`1<Regex> KeysAsRegexs { get; }
    internal IEnumerable`1<string> get_KeysAsStrings();
    internal IEnumerable`1<Regex> get_KeysAsRegexs();
    protected virtual ConfigurationElement CreateNewElement();
    protected virtual object GetElementKey(ConfigurationElement element);
}
public class DotNetOpenAuth.Configuration.MessagingElement : ConfigurationSection {
    private static string WebResourceUrlProviderName;
    private static string UntrustedWebRequestElementName;
    private static string MaximumMessageLifetimeConfigName;
    private static string MaximumClockSkewConfigName;
    private static string RelaxSslRequirementsConfigName;
    private static string StrictConfigName;
    private static int DefaultMaximumIndirectMessageUrlLength;
    private static string MaximumIndirectMessageUrlLengthConfigName;
    private static string PrivateSecretMaximumAgeConfigName;
    private static string MessagingElementName;
    public static MessagingElement Configuration { get; }
    public TimeSpan MaximumMessageLifetime { get; }
    [ConfigurationPropertyAttribute("privateSecretMaximumAge")]
public TimeSpan PrivateSecretMaximumAge { get; public set; }
    [ConfigurationPropertyAttribute("lifetime")]
internal TimeSpan MaximumMessageLifetimeNoSkew { get; internal set; }
    [ConfigurationPropertyAttribute("clockSkew")]
internal TimeSpan MaximumClockSkew { get; internal set; }
    [ConfigurationPropertyAttribute("relaxSslRequirements")]
internal bool RelaxSslRequirements { get; internal set; }
    [ConfigurationPropertyAttribute("strict")]
internal bool Strict { get; internal set; }
    [ConfigurationPropertyAttribute("untrustedWebRequest")]
internal UntrustedWebRequestElement UntrustedWebRequest { get; internal set; }
    [ConfigurationPropertyAttribute("maximumIndirectMessageUrlLength")]
[IntegerValidatorAttribute]
internal int MaximumIndirectMessageUrlLength { get; internal set; }
    [ConfigurationPropertyAttribute("webResourceUrlProvider")]
internal TypeConfigurationElement`1<IEmbeddedResourceRetrieval> EmbeddedResourceRetrievalProvider { get; internal set; }
    public static MessagingElement get_Configuration();
    public TimeSpan get_MaximumMessageLifetime();
    public TimeSpan get_PrivateSecretMaximumAge();
    public void set_PrivateSecretMaximumAge(TimeSpan value);
    internal TimeSpan get_MaximumMessageLifetimeNoSkew();
    internal void set_MaximumMessageLifetimeNoSkew(TimeSpan value);
    internal TimeSpan get_MaximumClockSkew();
    internal void set_MaximumClockSkew(TimeSpan value);
    internal bool get_RelaxSslRequirements();
    internal void set_RelaxSslRequirements(bool value);
    internal bool get_Strict();
    internal void set_Strict(bool value);
    internal UntrustedWebRequestElement get_UntrustedWebRequest();
    internal void set_UntrustedWebRequest(UntrustedWebRequestElement value);
    internal int get_MaximumIndirectMessageUrlLength();
    internal void set_MaximumIndirectMessageUrlLength(int value);
    internal TypeConfigurationElement`1<IEmbeddedResourceRetrieval> get_EmbeddedResourceRetrievalProvider();
    internal void set_EmbeddedResourceRetrievalProvider(TypeConfigurationElement`1<IEmbeddedResourceRetrieval> value);
}
internal class DotNetOpenAuth.Configuration.ReportingElement : ConfigurationSection {
    private static string EnabledAttributeName;
    private static string MinimumReportingIntervalAttributeName;
    private static string MinimumFlushIntervalAttributeName;
    private static string IncludeFeatureUsageAttributeName;
    private static string IncludeEventStatisticsAttributeName;
    private static string IncludeLocalRequestUrisAttributeName;
    private static string IncludeCulturesAttributeName;
    private static string ReportingElementName;
    private static string MinimumFlushIntervalDefault;
    public static ReportingElement Configuration { get; }
    [ConfigurationPropertyAttribute("enabled")]
internal bool Enabled { get; internal set; }
    [ConfigurationPropertyAttribute("minimumReportingInterval")]
internal TimeSpan MinimumReportingInterval { get; internal set; }
    [ConfigurationPropertyAttribute("minimumFlushInterval")]
internal TimeSpan MinimumFlushInterval { get; internal set; }
    [ConfigurationPropertyAttribute("includeFeatureUsage")]
internal bool IncludeFeatureUsage { get; internal set; }
    [ConfigurationPropertyAttribute("includeEventStatistics")]
internal bool IncludeEventStatistics { get; internal set; }
    [ConfigurationPropertyAttribute("includeLocalRequestUris")]
internal bool IncludeLocalRequestUris { get; internal set; }
    [ConfigurationPropertyAttribute("includeCultures")]
internal bool IncludeCultures { get; internal set; }
    public static ReportingElement get_Configuration();
    internal bool get_Enabled();
    internal void set_Enabled(bool value);
    internal TimeSpan get_MinimumReportingInterval();
    internal void set_MinimumReportingInterval(TimeSpan value);
    internal TimeSpan get_MinimumFlushInterval();
    internal void set_MinimumFlushInterval(TimeSpan value);
    internal bool get_IncludeFeatureUsage();
    internal void set_IncludeFeatureUsage(bool value);
    internal bool get_IncludeEventStatistics();
    internal void set_IncludeEventStatistics(bool value);
    internal bool get_IncludeLocalRequestUris();
    internal void set_IncludeLocalRequestUris(bool value);
    internal bool get_IncludeCultures();
    internal void set_IncludeCultures(bool value);
}
internal class DotNetOpenAuth.Configuration.TrustedProviderConfigurationCollection : ConfigurationElementCollection {
    private static string RejectAssertionsFromUntrustedProvidersConfigName;
    [ConfigurationPropertyAttribute("rejectAssertionsFromUntrustedProviders")]
internal bool RejectAssertionsFromUntrustedProviders { get; internal set; }
    internal TrustedProviderConfigurationCollection(IEnumerable`1<TrustedProviderEndpointConfigurationElement> elements);
    internal bool get_RejectAssertionsFromUntrustedProviders();
    internal void set_RejectAssertionsFromUntrustedProviders(bool value);
    protected virtual ConfigurationElement CreateNewElement();
    protected virtual object GetElementKey(ConfigurationElement element);
}
internal class DotNetOpenAuth.Configuration.TrustedProviderEndpointConfigurationElement : ConfigurationElement {
    private static string ProviderEndpointConfigName;
    [ConfigurationPropertyAttribute("endpoint")]
public Uri ProviderEndpoint { get; public set; }
    public Uri get_ProviderEndpoint();
    public void set_ProviderEndpoint(Uri value);
}
internal class DotNetOpenAuth.Configuration.TypeConfigurationCollection`1 : ConfigurationElementCollection {
    [CompilerGeneratedAttribute]
private static Func`2<TypeConfigurationElement`1<T>, bool> CS$<>9__CachedAnonymousMethodDelegate3;
    internal TypeConfigurationCollection`1(IEnumerable`1<Type> elements);
    internal IEnumerable`1<T> CreateInstances(bool allowInternals, IHostFactories hostFactories);
    protected virtual ConfigurationElement CreateNewElement();
    protected virtual object GetElementKey(ConfigurationElement element);
    [CompilerGeneratedAttribute]
private static bool <CreateInstances>b__1(TypeConfigurationElement`1<T> element);
}
internal class DotNetOpenAuth.Configuration.TypeConfigurationElement`1 : ConfigurationElement {
    private static string CustomTypeConfigName;
    private static string XamlReaderSourceConfigName;
    [ConfigurationPropertyAttribute("type")]
public string TypeName { get; public set; }
    [ConfigurationPropertyAttribute("xaml")]
public string XamlSource { get; public set; }
    public Type CustomType { get; }
    public bool IsEmpty { get; }
    public string get_TypeName();
    public void set_TypeName(string value);
    public string get_XamlSource();
    public void set_XamlSource(string value);
    public Type get_CustomType();
    public bool get_IsEmpty();
    public T CreateInstance(T defaultValue, IHostFactories hostFactories);
    public T CreateInstance(T defaultValue, bool allowInternals, IHostFactories hostFactories);
    private static T CreateInstanceFromXaml(Stream xaml);
}
internal class DotNetOpenAuth.Configuration.UntrustedWebRequestElement : ConfigurationElement {
    private static string TimeoutConfigName;
    private static string ReadWriteTimeoutConfigName;
    private static string MaximumBytesToReadConfigName;
    private static string MaximumRedirectionsConfigName;
    private static string WhitelistHostsConfigName;
    private static string WhitelistHostsRegexConfigName;
    private static string BlacklistHostsConfigName;
    private static string BlacklistHostsRegexConfigName;
    [PositiveTimeSpanValidatorAttribute]
[ConfigurationPropertyAttribute("readWriteTimeout")]
public TimeSpan ReadWriteTimeout { get; public set; }
    [PositiveTimeSpanValidatorAttribute]
[ConfigurationPropertyAttribute("timeout")]
public TimeSpan Timeout { get; public set; }
    [IntegerValidatorAttribute]
[ConfigurationPropertyAttribute("maximumBytesToRead")]
public int MaximumBytesToRead { get; public set; }
    [ConfigurationPropertyAttribute("maximumRedirections")]
[IntegerValidatorAttribute]
public int MaximumRedirections { get; public set; }
    [ConfigurationPropertyAttribute("whitelistHosts")]
[ConfigurationCollectionAttribute("DotNetOpenAuth.Configuration.HostNameOrRegexCollection")]
public HostNameOrRegexCollection WhitelistHosts { get; public set; }
    [ConfigurationPropertyAttribute("blacklistHosts")]
[ConfigurationCollectionAttribute("DotNetOpenAuth.Configuration.HostNameOrRegexCollection")]
public HostNameOrRegexCollection BlacklistHosts { get; public set; }
    [ConfigurationCollectionAttribute("DotNetOpenAuth.Configuration.HostNameOrRegexCollection")]
[ConfigurationPropertyAttribute("whitelistHostsRegex")]
public HostNameOrRegexCollection WhitelistHostsRegex { get; public set; }
    [ConfigurationPropertyAttribute("blacklistHostsRegex")]
[ConfigurationCollectionAttribute("DotNetOpenAuth.Configuration.HostNameOrRegexCollection")]
public HostNameOrRegexCollection BlacklistHostsRegex { get; public set; }
    public TimeSpan get_ReadWriteTimeout();
    public void set_ReadWriteTimeout(TimeSpan value);
    public TimeSpan get_Timeout();
    public void set_Timeout(TimeSpan value);
    public int get_MaximumBytesToRead();
    public void set_MaximumBytesToRead(int value);
    public int get_MaximumRedirections();
    public void set_MaximumRedirections(int value);
    public HostNameOrRegexCollection get_WhitelistHosts();
    public void set_WhitelistHosts(HostNameOrRegexCollection value);
    public HostNameOrRegexCollection get_BlacklistHosts();
    public void set_BlacklistHosts(HostNameOrRegexCollection value);
    public HostNameOrRegexCollection get_WhitelistHostsRegex();
    public void set_WhitelistHostsRegex(HostNameOrRegexCollection value);
    public HostNameOrRegexCollection get_BlacklistHostsRegex();
    public void set_BlacklistHostsRegex(HostNameOrRegexCollection value);
}
public interface DotNetOpenAuth.IEmbeddedResourceRetrieval {
    public abstract virtual Uri GetWebResourceUrl(Type someTypeInResourceAssembly, string manifestResourceName);
}
public interface DotNetOpenAuth.IHostFactories {
    public abstract virtual HttpMessageHandler CreateHttpMessageHandler();
    public abstract virtual HttpClient CreateHttpClient(HttpMessageHandler handler);
}
public interface DotNetOpenAuth.IRequireHostFactories {
    public IHostFactories HostFactories { get; public set; }
    public abstract virtual IHostFactories get_HostFactories();
    public abstract virtual void set_HostFactories(IHostFactories value);
}
internal static class DotNetOpenAuth.Logger : object {
    private static ILog library;
    private static ILog yadis;
    private static ILog messaging;
    private static ILog channel;
    private static ILog bindings;
    private static ILog signatures;
    private static ILog http;
    private static ILog controls;
    private static ILog openId;
    private static ILog oauth;
    internal static ILog Library { get; }
    internal static ILog Yadis { get; }
    internal static ILog Messaging { get; }
    internal static ILog Channel { get; }
    internal static ILog Bindings { get; }
    internal static ILog Signatures { get; }
    internal static ILog Http { get; }
    internal static ILog Controls { get; }
    internal static ILog OpenId { get; }
    internal static ILog OAuth { get; }
    private static Logger();
    internal static ILog get_Library();
    internal static ILog get_Yadis();
    internal static ILog get_Messaging();
    internal static ILog get_Channel();
    internal static ILog get_Bindings();
    internal static ILog get_Signatures();
    internal static ILog get_Http();
    internal static ILog get_Controls();
    internal static ILog get_OpenId();
    internal static ILog get_OAuth();
    internal static ILog Create(string name);
    internal static ILog CreateWithBanner(string name);
    internal static ILog Create(Type type);
    private static ILog InitializeFacade(string name);
}
internal interface DotNetOpenAuth.Loggers.ILog {
    public bool IsDebugEnabled { get; }
    public bool IsInfoEnabled { get; }
    public bool IsWarnEnabled { get; }
    public bool IsErrorEnabled { get; }
    public bool IsFatalEnabled { get; }
    public abstract virtual void Debug(object message);
    public abstract virtual void Debug(object message, Exception exception);
    public abstract virtual void DebugFormat(string format, Object[] args);
    public abstract virtual void DebugFormat(string format, object arg0);
    public abstract virtual void DebugFormat(string format, object arg0, object arg1);
    public abstract virtual void DebugFormat(string format, object arg0, object arg1, object arg2);
    public abstract virtual void Info(object message);
    public abstract virtual void Info(object message, Exception exception);
    public abstract virtual void InfoFormat(string format, Object[] args);
    public abstract virtual void InfoFormat(string format, object arg0);
    public abstract virtual void InfoFormat(string format, object arg0, object arg1);
    public abstract virtual void InfoFormat(string format, object arg0, object arg1, object arg2);
    public abstract virtual void Warn(object message);
    public abstract virtual void Warn(object message, Exception exception);
    public abstract virtual void WarnFormat(string format, Object[] args);
    public abstract virtual void WarnFormat(string format, object arg0);
    public abstract virtual void WarnFormat(string format, object arg0, object arg1);
    public abstract virtual void WarnFormat(string format, object arg0, object arg1, object arg2);
    public abstract virtual void Error(object message);
    public abstract virtual void Error(object message, Exception exception);
    public abstract virtual void ErrorFormat(string format, Object[] args);
    public abstract virtual void ErrorFormat(string format, object arg0);
    public abstract virtual void ErrorFormat(string format, object arg0, object arg1);
    public abstract virtual void ErrorFormat(string format, object arg0, object arg1, object arg2);
    public abstract virtual void Fatal(object message);
    public abstract virtual void Fatal(object message, Exception exception);
    public abstract virtual void FatalFormat(string format, Object[] args);
    public abstract virtual void FatalFormat(string format, object arg0);
    public abstract virtual void FatalFormat(string format, object arg0, object arg1);
    public abstract virtual void FatalFormat(string format, object arg0, object arg1, object arg2);
    public abstract virtual bool get_IsDebugEnabled();
    public abstract virtual bool get_IsInfoEnabled();
    public abstract virtual bool get_IsWarnEnabled();
    public abstract virtual bool get_IsErrorEnabled();
    public abstract virtual bool get_IsFatalEnabled();
}
internal class DotNetOpenAuth.Loggers.Log4NetLogger : object {
    private ILog log4netLogger;
    public bool IsDebugEnabled { get; }
    public bool IsInfoEnabled { get; }
    public bool IsWarnEnabled { get; }
    public bool IsErrorEnabled { get; }
    public bool IsFatalEnabled { get; }
    private static bool IsLog4NetPresent { get; }
    private Log4NetLogger(ILog logger);
    public sealed virtual bool get_IsDebugEnabled();
    public sealed virtual bool get_IsInfoEnabled();
    public sealed virtual bool get_IsWarnEnabled();
    public sealed virtual bool get_IsErrorEnabled();
    public sealed virtual bool get_IsFatalEnabled();
    private static bool get_IsLog4NetPresent();
    public sealed virtual void Debug(object message);
    public sealed virtual void Debug(object message, Exception exception);
    public sealed virtual void DebugFormat(string format, Object[] args);
    public sealed virtual void DebugFormat(string format, object arg0);
    public sealed virtual void DebugFormat(string format, object arg0, object arg1);
    public sealed virtual void DebugFormat(string format, object arg0, object arg1, object arg2);
    public void DebugFormat(IFormatProvider provider, string format, Object[] args);
    public sealed virtual void Info(object message);
    public sealed virtual void Info(object message, Exception exception);
    public sealed virtual void InfoFormat(string format, Object[] args);
    public sealed virtual void InfoFormat(string format, object arg0);
    public sealed virtual void InfoFormat(string format, object arg0, object arg1);
    public sealed virtual void InfoFormat(string format, object arg0, object arg1, object arg2);
    public void InfoFormat(IFormatProvider provider, string format, Object[] args);
    public sealed virtual void Warn(object message);
    public sealed virtual void Warn(object message, Exception exception);
    public sealed virtual void WarnFormat(string format, Object[] args);
    public sealed virtual void WarnFormat(string format, object arg0);
    public sealed virtual void WarnFormat(string format, object arg0, object arg1);
    public sealed virtual void WarnFormat(string format, object arg0, object arg1, object arg2);
    public void WarnFormat(IFormatProvider provider, string format, Object[] args);
    public sealed virtual void Error(object message);
    public sealed virtual void Error(object message, Exception exception);
    public sealed virtual void ErrorFormat(string format, Object[] args);
    public sealed virtual void ErrorFormat(string format, object arg0);
    public sealed virtual void ErrorFormat(string format, object arg0, object arg1);
    public sealed virtual void ErrorFormat(string format, object arg0, object arg1, object arg2);
    public void ErrorFormat(IFormatProvider provider, string format, Object[] args);
    public sealed virtual void Fatal(object message);
    public sealed virtual void Fatal(object message, Exception exception);
    public sealed virtual void FatalFormat(string format, Object[] args);
    public sealed virtual void FatalFormat(string format, object arg0);
    public sealed virtual void FatalFormat(string format, object arg0, object arg1);
    public sealed virtual void FatalFormat(string format, object arg0, object arg1, object arg2);
    public void FatalFormat(IFormatProvider provider, string format, Object[] args);
    internal static ILog Initialize(string name);
    private static ILog CreateLogger(string name);
}
internal class DotNetOpenAuth.Loggers.NLogLogger : object {
    private Logger nLogLogger;
    public bool IsDebugEnabled { get; }
    public bool IsInfoEnabled { get; }
    public bool IsWarnEnabled { get; }
    public bool IsErrorEnabled { get; }
    public bool IsFatalEnabled { get; }
    private static bool IsNLogPresent { get; }
    private NLogLogger(Logger logger);
    public sealed virtual bool get_IsDebugEnabled();
    public sealed virtual bool get_IsInfoEnabled();
    public sealed virtual bool get_IsWarnEnabled();
    public sealed virtual bool get_IsErrorEnabled();
    public sealed virtual bool get_IsFatalEnabled();
    private static bool get_IsNLogPresent();
    public sealed virtual void Debug(object message);
    public sealed virtual void Debug(object message, Exception exception);
    public sealed virtual void DebugFormat(string format, Object[] args);
    public sealed virtual void DebugFormat(string format, object arg0);
    public sealed virtual void DebugFormat(string format, object arg0, object arg1);
    public sealed virtual void DebugFormat(string format, object arg0, object arg1, object arg2);
    public void DebugFormat(IFormatProvider provider, string format, Object[] args);
    public sealed virtual void Info(object message);
    public sealed virtual void Info(object message, Exception exception);
    public sealed virtual void InfoFormat(string format, Object[] args);
    public sealed virtual void InfoFormat(string format, object arg0);
    public sealed virtual void InfoFormat(string format, object arg0, object arg1);
    public sealed virtual void InfoFormat(string format, object arg0, object arg1, object arg2);
    public void InfoFormat(IFormatProvider provider, string format, Object[] args);
    public sealed virtual void Warn(object message);
    public sealed virtual void Warn(object message, Exception exception);
    public sealed virtual void WarnFormat(string format, Object[] args);
    public sealed virtual void WarnFormat(string format, object arg0);
    public sealed virtual void WarnFormat(string format, object arg0, object arg1);
    public sealed virtual void WarnFormat(string format, object arg0, object arg1, object arg2);
    public void WarnFormat(IFormatProvider provider, string format, Object[] args);
    public sealed virtual void Error(object message);
    public sealed virtual void Error(object message, Exception exception);
    public sealed virtual void ErrorFormat(string format, Object[] args);
    public sealed virtual void ErrorFormat(string format, object arg0);
    public sealed virtual void ErrorFormat(string format, object arg0, object arg1);
    public sealed virtual void ErrorFormat(string format, object arg0, object arg1, object arg2);
    public void ErrorFormat(IFormatProvider provider, string format, Object[] args);
    public sealed virtual void Fatal(object message);
    public sealed virtual void Fatal(object message, Exception exception);
    public sealed virtual void FatalFormat(string format, Object[] args);
    public sealed virtual void FatalFormat(string format, object arg0);
    public sealed virtual void FatalFormat(string format, object arg0, object arg1);
    public sealed virtual void FatalFormat(string format, object arg0, object arg1, object arg2);
    public void FatalFormat(IFormatProvider provider, string format, Object[] args);
    internal static ILog Initialize(string name);
    private static ILog CreateLogger(string name);
}
internal class DotNetOpenAuth.Loggers.NoOpLogger : object {
    public bool IsDebugEnabled { get; }
    public bool IsInfoEnabled { get; }
    public bool IsWarnEnabled { get; }
    public bool IsErrorEnabled { get; }
    public bool IsFatalEnabled { get; }
    public sealed virtual bool get_IsDebugEnabled();
    public sealed virtual bool get_IsInfoEnabled();
    public sealed virtual bool get_IsWarnEnabled();
    public sealed virtual bool get_IsErrorEnabled();
    public sealed virtual bool get_IsFatalEnabled();
    public sealed virtual void Debug(object message);
    public sealed virtual void Debug(object message, Exception exception);
    public sealed virtual void DebugFormat(string format, Object[] args);
    public sealed virtual void DebugFormat(string format, object arg0);
    public sealed virtual void DebugFormat(string format, object arg0, object arg1);
    public sealed virtual void DebugFormat(string format, object arg0, object arg1, object arg2);
    public sealed virtual void Info(object message);
    public sealed virtual void Info(object message, Exception exception);
    public sealed virtual void InfoFormat(string format, Object[] args);
    public sealed virtual void InfoFormat(string format, object arg0);
    public sealed virtual void InfoFormat(string format, object arg0, object arg1);
    public sealed virtual void InfoFormat(string format, object arg0, object arg1, object arg2);
    public sealed virtual void Warn(object message);
    public sealed virtual void Warn(object message, Exception exception);
    public sealed virtual void WarnFormat(string format, Object[] args);
    public sealed virtual void WarnFormat(string format, object arg0);
    public sealed virtual void WarnFormat(string format, object arg0, object arg1);
    public sealed virtual void WarnFormat(string format, object arg0, object arg1, object arg2);
    public sealed virtual void Error(object message);
    public sealed virtual void Error(object message, Exception exception);
    public sealed virtual void ErrorFormat(string format, Object[] args);
    public sealed virtual void ErrorFormat(string format, object arg0);
    public sealed virtual void ErrorFormat(string format, object arg0, object arg1);
    public sealed virtual void ErrorFormat(string format, object arg0, object arg1, object arg2);
    public sealed virtual void Fatal(object message);
    public sealed virtual void Fatal(object message, Exception exception);
    public sealed virtual void FatalFormat(string format, Object[] args);
    public sealed virtual void FatalFormat(string format, object arg0);
    public sealed virtual void FatalFormat(string format, object arg0, object arg1);
    public sealed virtual void FatalFormat(string format, object arg0, object arg1, object arg2);
    internal static ILog Initialize();
}
internal class DotNetOpenAuth.Loggers.TraceLogger : object {
    private TraceSwitch traceSwitch;
    public bool IsDebugEnabled { get; }
    public bool IsInfoEnabled { get; }
    public bool IsWarnEnabled { get; }
    public bool IsErrorEnabled { get; }
    public bool IsFatalEnabled { get; }
    private static bool IsSufficientPermissionGranted { get; }
    internal TraceLogger(string name);
    public sealed virtual bool get_IsDebugEnabled();
    public sealed virtual bool get_IsInfoEnabled();
    public sealed virtual bool get_IsWarnEnabled();
    public sealed virtual bool get_IsErrorEnabled();
    public sealed virtual bool get_IsFatalEnabled();
    private static bool get_IsSufficientPermissionGranted();
    public sealed virtual void Debug(object message);
    public sealed virtual void Debug(object message, Exception exception);
    public sealed virtual void DebugFormat(string format, Object[] args);
    public sealed virtual void DebugFormat(string format, object arg0);
    public sealed virtual void DebugFormat(string format, object arg0, object arg1);
    public sealed virtual void DebugFormat(string format, object arg0, object arg1, object arg2);
    public sealed virtual void Info(object message);
    public sealed virtual void Info(object message, Exception exception);
    public sealed virtual void InfoFormat(string format, Object[] args);
    public sealed virtual void InfoFormat(string format, object arg0);
    public sealed virtual void InfoFormat(string format, object arg0, object arg1);
    public sealed virtual void InfoFormat(string format, object arg0, object arg1, object arg2);
    public sealed virtual void Warn(object message);
    public sealed virtual void Warn(object message, Exception exception);
    public sealed virtual void WarnFormat(string format, Object[] args);
    public sealed virtual void WarnFormat(string format, object arg0);
    public sealed virtual void WarnFormat(string format, object arg0, object arg1);
    public sealed virtual void WarnFormat(string format, object arg0, object arg1, object arg2);
    public sealed virtual void Error(object message);
    public sealed virtual void Error(object message, Exception exception);
    public sealed virtual void ErrorFormat(string format, Object[] args);
    public sealed virtual void ErrorFormat(string format, object arg0);
    public sealed virtual void ErrorFormat(string format, object arg0, object arg1);
    public sealed virtual void ErrorFormat(string format, object arg0, object arg1, object arg2);
    public sealed virtual void Fatal(object message);
    public sealed virtual void Fatal(object message, Exception exception);
    public sealed virtual void FatalFormat(string format, Object[] args);
    public sealed virtual void FatalFormat(string format, object arg0);
    public sealed virtual void FatalFormat(string format, object arg0, object arg1);
    public sealed virtual void FatalFormat(string format, object arg0, object arg1, object arg2);
    internal static ILog Initialize(string name);
}
internal static class DotNetOpenAuth.MachineKeyUtil : object {
    private static IMachineKey MachineKeyImpl;
    private static MachineKeyUtil();
    public static Byte[] Protect(Byte[] userData, String[] purposes);
    public static Byte[] Unprotect(Byte[] protectedData, String[] purposes);
    private static IMachineKey GetMachineKeyImpl();
}
internal class DotNetOpenAuth.Messaging.Base64WebEncoder : object {
    public sealed virtual string Encode(object value);
    public sealed virtual object Decode(string value);
}
internal class DotNetOpenAuth.Messaging.BinaryDataBagFormatter`1 : DataBagFormatterBase`1<T> {
    protected internal BinaryDataBagFormatter`1(RSACryptoServiceProvider signingKey, RSACryptoServiceProvider encryptingKey, bool compressed, Nullable`1<TimeSpan> maximumAge, INonceStore decodeOnceOnly);
    protected internal BinaryDataBagFormatter`1(ICryptoKeyStore cryptoKeyStore, string bucket, bool signed, bool encrypted, bool compressed, Nullable`1<TimeSpan> minimumAge, Nullable`1<TimeSpan> maximumAge, INonceStore decodeOnceOnly);
    protected virtual Byte[] SerializeCore(T message);
    protected virtual void DeserializeCore(T message, Byte[] data);
}
public class DotNetOpenAuth.Messaging.Bindings.AsymmetricCryptoKeyStoreWrapper : object {
    private ICryptoKeyStore dataStore;
    private MemoryCryptoKeyStore cache;
    private RSACryptoServiceProvider asymmetricCrypto;
    public AsymmetricCryptoKeyStoreWrapper(ICryptoKeyStore dataStore, RSACryptoServiceProvider asymmetricCrypto);
    public sealed virtual CryptoKey GetKey(string bucket, string handle);
    public sealed virtual IEnumerable`1<KeyValuePair`2<string, CryptoKey>> GetKeys(string bucket);
    public sealed virtual void StoreKey(string bucket, string handle, CryptoKey decryptedCryptoKey);
    public sealed virtual void RemoveKey(string bucket, string handle);
    private CryptoKey Decrypt(string bucket, string handle, CryptoKey encryptedCryptoKey);
}
public class DotNetOpenAuth.Messaging.Bindings.CryptoKey : object {
    private Byte[] key;
    private DateTime expiresUtc;
    public Byte[] Key { get; }
    public DateTime ExpiresUtc { get; }
    public CryptoKey(Byte[] key, DateTime expiresUtc);
    public Byte[] get_Key();
    public DateTime get_ExpiresUtc();
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
}
public class DotNetOpenAuth.Messaging.Bindings.CryptoKeyCollisionException : ArgumentException {
    public CryptoKeyCollisionException(Exception inner);
    protected CryptoKeyCollisionException(SerializationInfo info, StreamingContext context);
}
internal class DotNetOpenAuth.Messaging.Bindings.ExpiredMessageException : ProtocolException {
    public ExpiredMessageException(DateTime utcExpirationDate, IProtocolMessage faultedMessage);
    protected ExpiredMessageException(SerializationInfo info, StreamingContext context);
}
public class DotNetOpenAuth.Messaging.Bindings.HardCodedKeyCryptoKeyStore : object {
    private static string HardCodedKeyHandle;
    private CryptoKey OneCryptoKey;
    public HardCodedKeyCryptoKeyStore(string secretAsBase64);
    public HardCodedKeyCryptoKeyStore(Byte[] secret);
    public sealed virtual CryptoKey GetKey(string bucket, string handle);
    public sealed virtual IEnumerable`1<KeyValuePair`2<string, CryptoKey>> GetKeys(string bucket);
    public sealed virtual void StoreKey(string bucket, string handle, CryptoKey key);
    public sealed virtual void RemoveKey(string bucket, string handle);
}
public interface DotNetOpenAuth.Messaging.Bindings.ICryptoKeyAndNonceStore {
}
public interface DotNetOpenAuth.Messaging.Bindings.ICryptoKeyStore {
    public abstract virtual CryptoKey GetKey(string bucket, string handle);
    public abstract virtual IEnumerable`1<KeyValuePair`2<string, CryptoKey>> GetKeys(string bucket);
    public abstract virtual void StoreKey(string bucket, string handle, CryptoKey key);
    public abstract virtual void RemoveKey(string bucket, string handle);
}
internal interface DotNetOpenAuth.Messaging.Bindings.IExpiringProtocolMessage {
    public DateTime UtcCreationDate { get; public set; }
    public abstract virtual DateTime get_UtcCreationDate();
    public abstract virtual void set_UtcCreationDate(DateTime value);
}
public interface DotNetOpenAuth.Messaging.Bindings.INonceStore {
    public abstract virtual bool StoreNonce(string context, string nonce, DateTime timestampUtc);
}
internal class DotNetOpenAuth.Messaging.Bindings.InvalidSignatureException : ProtocolException {
    public InvalidSignatureException(IProtocolMessage faultedMessage);
    protected InvalidSignatureException(SerializationInfo info, StreamingContext context);
}
internal interface DotNetOpenAuth.Messaging.Bindings.IReplayProtectedProtocolMessage {
    public string NonceContext { get; }
    public string Nonce { get; public set; }
    public abstract virtual string get_NonceContext();
    public abstract virtual string get_Nonce();
    public abstract virtual void set_Nonce(string value);
}
public class DotNetOpenAuth.Messaging.Bindings.MemoryCryptoKeyAndNonceStore : object {
    private INonceStore nonceStore;
    private ICryptoKeyStore cryptoKeyStore;
    public MemoryCryptoKeyAndNonceStore(TimeSpan maximumMessageAge);
    public sealed virtual bool StoreNonce(string context, string nonce, DateTime timestampUtc);
    public sealed virtual CryptoKey GetKey(string bucket, string handle);
    public sealed virtual IEnumerable`1<KeyValuePair`2<string, CryptoKey>> GetKeys(string bucket);
    public sealed virtual void StoreKey(string bucket, string handle, CryptoKey key);
    public sealed virtual void RemoveKey(string bucket, string handle);
}
internal class DotNetOpenAuth.Messaging.Bindings.MemoryCryptoKeyStore : object {
    private static TimeSpan cleaningInterval;
    private Dictionary`2<string, Dictionary`2<string, CryptoKey>> store;
    private DateTime lastCleaning;
    private static MemoryCryptoKeyStore();
    public sealed virtual CryptoKey GetKey(string bucket, string handle);
    public sealed virtual IEnumerable`1<KeyValuePair`2<string, CryptoKey>> GetKeys(string bucket);
    public sealed virtual void StoreKey(string bucket, string handle, CryptoKey key);
    public sealed virtual void RemoveKey(string bucket, string handle);
    private void CleanExpiredKeysFromMemoryCacheIfAppropriate();
    private void ClearExpiredKeysFromMemoryCache();
}
internal class DotNetOpenAuth.Messaging.Bindings.MemoryNonceStore : object {
    private static int AutoCleaningFrequency;
    private TimeSpan maximumMessageAge;
    private SortedDictionary`2<DateTime, List`1<string>> usedNonces;
    private object nonceLock;
    private int nonceClearingCounter;
    internal MemoryNonceStore(TimeSpan maximumMessageAge);
    public sealed virtual bool StoreNonce(string context, string nonce, DateTime timestamp);
    public void ClearExpiredNonces();
    [CompilerGeneratedAttribute]
private bool <ClearExpiredNonces>b__2(DateTime time);
}
internal class DotNetOpenAuth.Messaging.Bindings.ReplayedMessageException : ProtocolException {
    public ReplayedMessageException(IProtocolMessage faultedMessage);
    protected ReplayedMessageException(SerializationInfo info, StreamingContext context);
}
internal class DotNetOpenAuth.Messaging.Bindings.StandardExpirationBindingElement : object {
    private static Task`1<Nullable`1<MessageProtections>> NullTask;
    private static Task`1<Nullable`1<MessageProtections>> CompletedExpirationTask;
    [CompilerGeneratedAttribute]
private Channel <Channel>k__BackingField;
    private MessageProtections DotNetOpenAuth.Messaging.IChannelBindingElement.Protection { get; }
    public Channel Channel { get; public set; }
    protected internal static TimeSpan MaximumMessageAge { get; }
    private static StandardExpirationBindingElement();
    private sealed virtual override MessageProtections DotNetOpenAuth.Messaging.IChannelBindingElement.get_Protection();
    [CompilerGeneratedAttribute]
public sealed virtual Channel get_Channel();
    [CompilerGeneratedAttribute]
public sealed virtual void set_Channel(Channel value);
    protected internal static TimeSpan get_MaximumMessageAge();
    public sealed virtual Task`1<Nullable`1<MessageProtections>> ProcessOutgoingMessageAsync(IProtocolMessage message, CancellationToken cancellationToken);
    public sealed virtual Task`1<Nullable`1<MessageProtections>> ProcessIncomingMessageAsync(IProtocolMessage message, CancellationToken cancellationToken);
}
internal class DotNetOpenAuth.Messaging.Bindings.StandardReplayProtectionBindingElement : object {
    private static string AllowedCharacters;
    private static Task`1<Nullable`1<MessageProtections>> NullTask;
    private static Task`1<Nullable`1<MessageProtections>> CompletedReplayProtectionTask;
    private INonceStore nonceStore;
    private int nonceLength;
    [CompilerGeneratedAttribute]
private Channel <Channel>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <AllowZeroLengthNonce>k__BackingField;
    public MessageProtections Protection { get; }
    public Channel Channel { get; public set; }
    internal double NonceStrength { get; internal set; }
    internal bool AllowZeroLengthNonce { get; internal set; }
    internal StandardReplayProtectionBindingElement(INonceStore nonceStore);
    internal StandardReplayProtectionBindingElement(INonceStore nonceStore, bool allowEmptyNonces);
    private static StandardReplayProtectionBindingElement();
    public sealed virtual MessageProtections get_Protection();
    [CompilerGeneratedAttribute]
public sealed virtual Channel get_Channel();
    [CompilerGeneratedAttribute]
public sealed virtual void set_Channel(Channel value);
    internal double get_NonceStrength();
    internal void set_NonceStrength(double value);
    [CompilerGeneratedAttribute]
internal bool get_AllowZeroLengthNonce();
    [CompilerGeneratedAttribute]
internal void set_AllowZeroLengthNonce(bool value);
    public sealed virtual Task`1<Nullable`1<MessageProtections>> ProcessOutgoingMessageAsync(IProtocolMessage message, CancellationToken cancellationToken);
    public sealed virtual Task`1<Nullable`1<MessageProtections>> ProcessIncomingMessageAsync(IProtocolMessage message, CancellationToken cancellationToken);
    private string GenerateUniqueFragment();
}
public abstract class DotNetOpenAuth.Messaging.Channel : object {
    protected internal static string HttpFormUrlEncoded;
    protected internal static string JsonEncoded;
    protected internal static string JsonTextEncoded;
    protected internal static string PlainTextEncoded;
    private static string RedirectResponseBodyFormat;
    private static string IndirectMessageFormPostFormat;
    internal static Encoding PostEntityEncoding;
    internal static XmlDictionaryReaderQuotas DefaultUntrustedXmlDictionaryReaderQuotas;
    protected internal static ContentType HttpFormUrlEncodedContentType;
    [DebuggerBrowsableAttribute("0")]
private List`1<IChannelBindingElement> outgoingBindingElements;
    private List`1<IChannelBindingElement> incomingBindingElements;
    private static MessageDescriptionCollection defaultMessageDescriptions;
    private MessageDescriptionCollection messageDescriptions;
    private IMessageFactory messageTypeProvider;
    private int maximumIndirectMessageUrlLength;
    private EventHandler`1<ChannelEventArgs> Sending;
    [CompilerGeneratedAttribute]
private IHostFactories <HostFactories>k__BackingField;
    [CompilerGeneratedAttribute]
private Action`1<IProtocolMessage> <OutgoingMessageFilter>k__BackingField;
    [CompilerGeneratedAttribute]
private Action`1<IProtocolMessage> <IncomingMessageFilter>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsDisposed>k__BackingField;
    [CompilerGeneratedAttribute]
private XmlDictionaryReaderQuotas <XmlDictionaryReaderQuotas>k__BackingField;
    [CompilerGeneratedAttribute]
private static Func`2<IChannelBindingElement, bool> CS$<>9__CachedAnonymousMethodDelegate48;
    [CompilerGeneratedAttribute]
private static Func`2<IChannelBindingElement, bool> CS$<>9__CachedAnonymousMethodDelegate49;
    [CompilerGeneratedAttribute]
private static Func`2<IChannelBindingElement, MessageProtections> CS$<>9__CachedAnonymousMethodDelegate4a;
    public IHostFactories HostFactories { get; private set; }
    public int MaximumIndirectMessageUrlLength { get; public set; }
    internal MessageDescriptionCollection MessageDescriptions { get; internal set; }
    internal IMessageFactory MessageFactoryTestHook { get; }
    internal Action`1<IProtocolMessage> OutgoingMessageFilter { get; internal set; }
    internal Action`1<IProtocolMessage> IncomingMessageFilter { get; internal set; }
    protected internal ReadOnlyCollection`1<IChannelBindingElement> BindingElements { get; }
    protected internal ReadOnlyCollection`1<IChannelBindingElement> OutgoingBindingElements { get; }
    protected internal ReadOnlyCollection`1<IChannelBindingElement> IncomingBindingElements { get; }
    protected internal bool IsDisposed { get; protected internal set; }
    protected IMessageFactory MessageFactory { get; protected set; }
    protected XmlDictionaryReaderQuotas XmlDictionaryReaderQuotas { get; protected set; }
    protected Channel(IMessageFactory messageTypeProvider, IChannelBindingElement[] bindingElements, IHostFactories hostFactories);
    private static Channel();
    internal void add_Sending(EventHandler`1<ChannelEventArgs> value);
    internal void remove_Sending(EventHandler`1<ChannelEventArgs> value);
    [CompilerGeneratedAttribute]
public IHostFactories get_HostFactories();
    [CompilerGeneratedAttribute]
private void set_HostFactories(IHostFactories value);
    public int get_MaximumIndirectMessageUrlLength();
    public void set_MaximumIndirectMessageUrlLength(int value);
    internal virtual MessageDescriptionCollection get_MessageDescriptions();
    internal virtual void set_MessageDescriptions(MessageDescriptionCollection value);
    internal IMessageFactory get_MessageFactoryTestHook();
    [CompilerGeneratedAttribute]
internal Action`1<IProtocolMessage> get_OutgoingMessageFilter();
    [CompilerGeneratedAttribute]
internal void set_OutgoingMessageFilter(Action`1<IProtocolMessage> value);
    [CompilerGeneratedAttribute]
internal Action`1<IProtocolMessage> get_IncomingMessageFilter();
    [CompilerGeneratedAttribute]
internal void set_IncomingMessageFilter(Action`1<IProtocolMessage> value);
    protected internal ReadOnlyCollection`1<IChannelBindingElement> get_BindingElements();
    protected internal ReadOnlyCollection`1<IChannelBindingElement> get_OutgoingBindingElements();
    protected internal ReadOnlyCollection`1<IChannelBindingElement> get_IncomingBindingElements();
    [CompilerGeneratedAttribute]
protected internal bool get_IsDisposed();
    [CompilerGeneratedAttribute]
protected internal void set_IsDisposed(bool value);
    protected virtual IMessageFactory get_MessageFactory();
    protected virtual void set_MessageFactory(IMessageFactory value);
    [CompilerGeneratedAttribute]
protected virtual XmlDictionaryReaderQuotas get_XmlDictionaryReaderQuotas();
    [CompilerGeneratedAttribute]
protected virtual void set_XmlDictionaryReaderQuotas(XmlDictionaryReaderQuotas value);
    [DebuggerStepThroughAttribute]
[AsyncStateMachineAttribute("DotNetOpenAuth.Messaging.Channel/<PrepareResponseAsync>d__1")]
public Task`1<HttpResponseMessage> PrepareResponseAsync(IProtocolMessage message, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("DotNetOpenAuth.Messaging.Channel/<TryReadFromRequestAsync>d__5`1")]
[DebuggerStepThroughAttribute]
public Task`1<TRequest> TryReadFromRequestAsync(HttpRequestMessage httpRequest, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("DotNetOpenAuth.Messaging.Channel/<ReadFromRequestAsync>d__a`1")]
[DebuggerStepThroughAttribute]
public Task`1<TRequest> ReadFromRequestAsync(HttpRequestMessage httpRequest, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("DotNetOpenAuth.Messaging.Channel/<ReadFromRequestAsync>d__e")]
[DebuggerStepThroughAttribute]
public Task`1<IDirectedProtocolMessage> ReadFromRequestAsync(HttpRequestMessage httpRequest, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("DotNetOpenAuth.Messaging.Channel/<RequestAsync>d__14`1")]
[DebuggerStepThroughAttribute]
public Task`1<TResponse> RequestAsync(IDirectedProtocolMessage requestMessage, CancellationToken cancellationToken);
    [DebuggerStepThroughAttribute]
[AsyncStateMachineAttribute("DotNetOpenAuth.Messaging.Channel/<RequestAsync>d__19")]
public Task`1<IProtocolMessage> RequestAsync(IDirectedProtocolMessage requestMessage, CancellationToken cancellationToken);
    public sealed virtual void Dispose();
    internal Task ProcessIncomingMessageTestHookAsync(IProtocolMessage message, CancellationToken cancellationToken);
    internal HttpRequestMessage CreateHttpRequestTestHook(IDirectedProtocolMessage request);
    internal HttpResponseMessage PrepareDirectResponseTestHook(IProtocolMessage response);
    internal Task`1<IDictionary`2<string, string>> ReadFromResponseCoreAsyncTestHook(HttpResponseMessage response, CancellationToken cancellationToken);
    internal Task ProcessOutgoingMessageTestHookAsync(IProtocolMessage message, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("DotNetOpenAuth.Messaging.Channel/<ParseUrlEncodedFormContentAsync>d__1e")]
[DebuggerStepThroughAttribute]
protected internal static Task`1<IEnumerable`1<KeyValuePair`2<string, string>>> ParseUrlEncodedFormContentAsync(HttpRequestMessage request, CancellationToken cancellationToken);
    protected internal virtual HttpContextBase GetHttpContext();
    protected internal virtual HttpRequestBase GetRequestFromContext();
    protected static MultipartFormDataContent InitializeMultipartFormDataContent(IMessageWithBinaryData requestMessageWithBinaryData);
    protected static bool HttpMethodHasEntity(HttpMethod httpMethod);
    protected static void ApplyMessageTemplate(IMessage message, HttpResponseMessage response);
    protected virtual void Dispose(bool disposing);
    protected virtual void OnSending(IProtocolMessage message);
    [DebuggerStepThroughAttribute]
[AsyncStateMachineAttribute("DotNetOpenAuth.Messaging.Channel/<RequestCoreAsync>d__21")]
protected virtual Task`1<IProtocolMessage> RequestCoreAsync(IDirectedProtocolMessage request, CancellationToken cancellationToken);
    protected virtual void OnReceivingDirectResponse(HttpResponseMessage response, IDirectResponseProtocolMessage message);
    [DebuggerStepThroughAttribute]
[AsyncStateMachineAttribute("DotNetOpenAuth.Messaging.Channel/<ReadFromRequestCoreAsync>d__2c")]
protected virtual Task`1<IDirectedProtocolMessage> ReadFromRequestCoreAsync(HttpRequestMessage request, CancellationToken cancellationToken);
    protected virtual IProtocolMessage Receive(Dictionary`2<string, string> fields, MessageReceivingEndpoint recipient);
    protected virtual HttpResponseMessage PrepareIndirectResponse(IDirectedProtocolMessage message);
    protected virtual HttpResponseMessage Create301RedirectResponse(IDirectedProtocolMessage message, IDictionary`2<string, string> fields, bool payloadInFragment);
    protected virtual HttpResponseMessage CreateFormPostResponse(IDirectedProtocolMessage message, IDictionary`2<string, string> fields);
    protected abstract virtual Task`1<IDictionary`2<string, string>> ReadFromResponseCoreAsync(HttpResponseMessage response, CancellationToken cancellationToken);
    protected virtual HttpRequestMessage CreateHttpRequest(IDirectedProtocolMessage request);
    protected abstract virtual HttpResponseMessage PrepareDirectResponse(IProtocolMessage response);
    protected virtual string SerializeAsJson(IMessage message);
    protected virtual IDictionary`2<string, string> DeserializeFromJson(string json);
    [DebuggerStepThroughAttribute]
[AsyncStateMachineAttribute("DotNetOpenAuth.Messaging.Channel/<ProcessOutgoingMessageAsync>d__34")]
protected Task ProcessOutgoingMessageAsync(IProtocolMessage message, CancellationToken cancellationToken);
    protected virtual HttpRequestMessage InitializeRequestAsGet(IDirectedProtocolMessage requestMessage);
    protected virtual HttpRequestMessage InitializeRequestAsHead(IDirectedProtocolMessage requestMessage);
    protected virtual HttpRequestMessage InitializeRequestAsPost(IDirectedProtocolMessage requestMessage);
    protected virtual HttpRequestMessage InitializeRequestAsPut(IDirectedProtocolMessage requestMessage);
    protected virtual HttpRequestMessage InitializeRequestAsDelete(IDirectedProtocolMessage requestMessage);
    [DebuggerStepThroughAttribute]
[AsyncStateMachineAttribute("DotNetOpenAuth.Messaging.Channel/<ProcessIncomingMessageAsync>d__3c")]
protected virtual Task ProcessIncomingMessageAsync(IProtocolMessage message, CancellationToken cancellationToken);
    protected virtual void FilterReceivedFields(IDictionary`2<string, string> fields);
    protected virtual void PrepareHttpWebRequest(HttpRequestMessage request);
    protected void CustomizeBindingElementOrder(IEnumerable`1<IChannelBindingElement> outgoingOrder, IEnumerable`1<IChannelBindingElement> incomingOrder);
    private static IEnumerable`1<IChannelBindingElement> ValidateAndPrepareBindingElements(IEnumerable`1<IChannelBindingElement> elements);
    private static int BindingElementOutgoingMessageApplicationOrder(MessageProtections protection1, MessageProtections protection2);
    private void EnsureValidMessageParts(IProtocolMessage message);
    private bool IsBindingElementOrderValid(IEnumerable`1<IChannelBindingElement> order);
    [CompilerGeneratedAttribute]
private static bool <ValidateAndPrepareBindingElements>b__44(IChannelBindingElement element);
    [CompilerGeneratedAttribute]
private static bool <ValidateAndPrepareBindingElements>b__45(IChannelBindingElement element);
    [CompilerGeneratedAttribute]
private static MessageProtections <ValidateAndPrepareBindingElements>b__47(IChannelBindingElement element);
    [CompilerGeneratedAttribute]
private bool <IsBindingElementOrderValid>b__4e(IChannelBindingElement el);
}
public class DotNetOpenAuth.Messaging.ChannelEventArgs : EventArgs {
    [CompilerGeneratedAttribute]
private IProtocolMessage <Message>k__BackingField;
    public IProtocolMessage Message { get; private set; }
    internal ChannelEventArgs(IProtocolMessage message);
    [CompilerGeneratedAttribute]
public IProtocolMessage get_Message();
    [CompilerGeneratedAttribute]
private void set_Message(IProtocolMessage value);
}
public abstract class DotNetOpenAuth.Messaging.DataBag : object {
    private static Version DefaultVersion;
    private Version version;
    private Dictionary`2<string, string> extraData;
    [CompilerGeneratedAttribute]
private Byte[] <Nonce>k__BackingField;
    [CompilerGeneratedAttribute]
private DateTime <UtcCreationDate>k__BackingField;
    [CompilerGeneratedAttribute]
private Byte[] <Signature>k__BackingField;
    [CompilerGeneratedAttribute]
private IProtocolMessage <ContainingMessage>k__BackingField;
    private Version DotNetOpenAuth.Messaging.IMessage.Version { get; }
    public IDictionary`2<string, string> ExtraData { get; }
    [MessagePartAttribute]
internal Byte[] Nonce { get; internal set; }
    [MessagePartAttribute("ts")]
internal DateTime UtcCreationDate { get; internal set; }
    internal Byte[] Signature { get; internal set; }
    protected internal IProtocolMessage ContainingMessage { get; protected internal set; }
    [MessagePartAttribute("t")]
protected Type BagType { get; }
    protected DataBag(Version version);
    private static DataBag();
    private sealed virtual override Version DotNetOpenAuth.Messaging.IMessage.get_Version();
    public sealed virtual IDictionary`2<string, string> get_ExtraData();
    [CompilerGeneratedAttribute]
internal Byte[] get_Nonce();
    [CompilerGeneratedAttribute]
internal void set_Nonce(Byte[] value);
    [CompilerGeneratedAttribute]
internal DateTime get_UtcCreationDate();
    [CompilerGeneratedAttribute]
internal void set_UtcCreationDate(DateTime value);
    [CompilerGeneratedAttribute]
internal Byte[] get_Signature();
    [CompilerGeneratedAttribute]
internal void set_Signature(Byte[] value);
    [CompilerGeneratedAttribute]
protected internal IProtocolMessage get_ContainingMessage();
    [CompilerGeneratedAttribute]
protected internal void set_ContainingMessage(IProtocolMessage value);
    protected virtual Type get_BagType();
    private sealed virtual override void DotNetOpenAuth.Messaging.IMessage.EnsureValidMessage();
    protected virtual void EnsureValidMessage();
}
internal abstract class DotNetOpenAuth.Messaging.DataBagFormatterBase`1 : object {
    private static int NonceLength;
    protected static MessageDescriptionCollection MessageDescriptions;
    private TimeSpan minimumAge;
    private ICryptoKeyStore cryptoKeyStore;
    private string cryptoKeyBucket;
    private RSACryptoServiceProvider asymmetricSigning;
    private RSACryptoServiceProvider asymmetricEncrypting;
    private bool signed;
    private INonceStore decodeOnceOnly;
    private Nullable`1<TimeSpan> maximumAge;
    private bool encrypted;
    private bool compressed;
    protected DataBagFormatterBase`1(RSACryptoServiceProvider signingKey, RSACryptoServiceProvider encryptingKey, bool compressed, Nullable`1<TimeSpan> maximumAge, INonceStore decodeOnceOnly);
    protected DataBagFormatterBase`1(ICryptoKeyStore cryptoKeyStore, string bucket, bool signed, bool encrypted, bool compressed, Nullable`1<TimeSpan> minimumAge, Nullable`1<TimeSpan> maximumAge, INonceStore decodeOnceOnly);
    private DataBagFormatterBase`1(bool signed, bool encrypted, bool compressed, Nullable`1<TimeSpan> maximumAge, INonceStore decodeOnceOnly);
    private static DataBagFormatterBase`1();
    public sealed virtual string Serialize(T message);
    public sealed virtual void Deserialize(T message, string value, IProtocolMessage containingMessage, string messagePartName);
    protected abstract virtual Byte[] SerializeCore(T message);
    protected abstract virtual void DeserializeCore(T message, Byte[] data);
    private bool IsSignatureValid(Byte[] signedData, Byte[] signature, string symmetricSecretHandle);
    private Byte[] CalculateSignature(Byte[] bytesToSign, string symmetricSecretHandle);
    private Byte[] Encrypt(Byte[] value, String& symmetricSecretHandle);
    private Byte[] Decrypt(Byte[] value, string symmetricSecretHandle);
}
[FlagsAttribute]
public enum DotNetOpenAuth.Messaging.DirectWebRequestOptions : Enum {
    public int value__;
    public static DirectWebRequestOptions None;
    public static DirectWebRequestOptions AcceptAllHttpResponses;
    public static DirectWebRequestOptions RequireSsl;
}
[DefaultMemberAttribute("Item")]
internal class DotNetOpenAuth.Messaging.EmptyDictionary`2 : object {
    internal static EmptyDictionary`2<TKey, TValue> Instance;
    public ICollection`1<TValue> Values { get; }
    public int Count { get; }
    public bool IsReadOnly { get; }
    public ICollection`1<TKey> Keys { get; }
    public TValue Item { get; public set; }
    private static EmptyDictionary`2();
    public sealed virtual ICollection`1<TValue> get_Values();
    public sealed virtual int get_Count();
    public sealed virtual bool get_IsReadOnly();
    public sealed virtual ICollection`1<TKey> get_Keys();
    public sealed virtual TValue get_Item(TKey key);
    public sealed virtual void set_Item(TKey key, TValue value);
    public sealed virtual void Add(TKey key, TValue value);
    public sealed virtual bool ContainsKey(TKey key);
    public sealed virtual bool Remove(TKey key);
    public sealed virtual bool TryGetValue(TKey key, TValue& value);
    public sealed virtual void Add(KeyValuePair`2<TKey, TValue> item);
    public sealed virtual void Clear();
    public sealed virtual bool Contains(KeyValuePair`2<TKey, TValue> item);
    public sealed virtual void CopyTo(KeyValuePair`2[] array, int arrayIndex);
    public sealed virtual bool Remove(KeyValuePair`2<TKey, TValue> item);
    public sealed virtual IEnumerator`1<KeyValuePair`2<TKey, TValue>> GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
}
internal class DotNetOpenAuth.Messaging.EmptyEnumerator : object {
    internal static EmptyEnumerator Instance;
    public object Current { get; }
    private static EmptyEnumerator();
    public sealed virtual object get_Current();
    public sealed virtual bool MoveNext();
    public sealed virtual void Reset();
}
[DefaultMemberAttribute("Item")]
internal class DotNetOpenAuth.Messaging.EmptyList`1 : object {
    internal static EmptyList`1<T> Instance;
    public int Count { get; }
    public bool IsReadOnly { get; }
    public T Item { get; public set; }
    private static EmptyList`1();
    public sealed virtual int get_Count();
    public sealed virtual bool get_IsReadOnly();
    public sealed virtual T get_Item(int index);
    public sealed virtual void set_Item(int index, T value);
    public sealed virtual int IndexOf(T item);
    public sealed virtual void Insert(int index, T item);
    public sealed virtual void RemoveAt(int index);
    public sealed virtual void Add(T item);
    public sealed virtual void Clear();
    public sealed virtual bool Contains(T item);
    public sealed virtual void CopyTo(T[] array, int arrayIndex);
    public sealed virtual bool Remove(T item);
    public sealed virtual IEnumerator`1<T> GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
}
[ExtensionAttribute]
public static class DotNetOpenAuth.Messaging.EnumerableCacheExtensions : object {
    [ExtensionAttribute]
public static IEnumerable`1<T> CacheGeneratedResults(IEnumerable`1<T> sequence);
}
[ExtensionAttribute]
internal static class DotNetOpenAuth.Messaging.ErrorUtilities : object {
    internal static Exception Wrap(Exception inner, string errorMessage, Object[] args);
    internal static Exception ThrowInternal(string errorMessage);
    internal static void VerifyInternal(bool condition, string errorMessage);
    internal static void VerifyInternal(bool condition, string errorMessage, Object[] args);
    internal static void VerifyOperation(bool condition, string errorMessage);
    internal static void VerifySupported(bool condition, string errorMessage);
    internal static void VerifySupported(bool condition, string errorMessage, Object[] args);
    internal static void VerifyOperation(bool condition, string errorMessage, Object[] args);
    internal static void VerifyHost(bool condition, string errorMessage, Object[] args);
    internal static void VerifyProtocol(bool condition, IProtocolMessage faultedMessage, string errorMessage, Object[] args);
    internal static void VerifyProtocol(bool condition, string unformattedMessage, Object[] args);
    internal static Exception ThrowProtocol(string unformattedMessage, Object[] args);
    internal static Exception ThrowFormat(string message, Object[] args);
    internal static void VerifyFormat(bool condition, string message, Object[] args);
    internal static void VerifyArgument(bool condition, string message, Object[] args);
    internal static Exception ThrowArgumentNamed(string parameterName, string message, Object[] args);
    internal static void VerifyArgumentNamed(bool condition, string parameterName, string message, Object[] args);
    internal static void VerifyArgumentNotNull(object value, string paramName);
    internal static void VerifyNonZeroLength(string value, string paramName);
    internal static void VerifyHttpContext();
    [ExtensionAttribute]
internal static TValue GetValueOrThrow(IDictionary`2<TKey, TValue> dictionary, TKey key, IMessage message);
}
internal static class DotNetOpenAuth.Messaging.HmacAlgorithms : object {
    internal static string HmacSha1;
    internal static string HmacSha256;
    internal static string HmacSha384;
    internal static string HmacSha512;
    internal static HMAC Create(string algorithmName, Byte[] key);
}
internal class DotNetOpenAuth.Messaging.HostErrorException : Exception {
    internal HostErrorException(string message);
    internal HostErrorException(string message, Exception inner);
    protected HostErrorException(SerializationInfo info, StreamingContext context);
}
[FlagsAttribute]
public enum DotNetOpenAuth.Messaging.HttpDeliveryMethods : Enum {
    public int value__;
    public static HttpDeliveryMethods None;
    public static HttpDeliveryMethods AuthorizationHeaderRequest;
    public static HttpDeliveryMethods PostRequest;
    public static HttpDeliveryMethods GetRequest;
    public static HttpDeliveryMethods PutRequest;
    public static HttpDeliveryMethods DeleteRequest;
    public static HttpDeliveryMethods HeadRequest;
    public static HttpDeliveryMethods PatchRequest;
    public static HttpDeliveryMethods OptionsRequest;
    public static HttpDeliveryMethods HttpVerbMask;
}
internal static class DotNetOpenAuth.Messaging.HttpRequestHeaders : object {
    internal static string Authorization;
    internal static string WwwAuthenticate;
    internal static string ContentType;
}
public class DotNetOpenAuth.Messaging.HttpRequestInfo : HttpRequestBase {
    private string httpMethod;
    private Uri requestUri;
    private NameValueCollection headers;
    private NameValueCollection queryString;
    private NameValueCollection form;
    private NameValueCollection serverVariables;
    private HttpCookieCollection cookies;
    public string HttpMethod { get; }
    public NameValueCollection Headers { get; }
    public Uri Url { get; }
    public string RawUrl { get; }
    public NameValueCollection Form { get; }
    public NameValueCollection QueryString { get; }
    public NameValueCollection ServerVariables { get; }
    public HttpCookieCollection Cookies { get; }
    public String[] AcceptTypes { get; }
    public Uri UrlReferrer { get; }
    public int ContentLength { get; }
    public string ContentType { get; public set; }
    internal HttpRequestInfo(HttpRequestMessageProperty request, Uri requestUri);
    internal HttpRequestInfo(string httpMethod, Uri requestUri, NameValueCollection form, NameValueCollection headers, HttpCookieCollection cookies);
    internal HttpRequestInfo(HttpListenerRequest listenerRequest);
    internal HttpRequestInfo(HttpRequestMessage request);
    internal HttpRequestInfo(string httpMethod, Uri requestUri, NameValueCollection headers, Stream inputStream);
    public virtual string get_HttpMethod();
    public virtual NameValueCollection get_Headers();
    public virtual Uri get_Url();
    public virtual string get_RawUrl();
    public virtual NameValueCollection get_Form();
    public virtual NameValueCollection get_QueryString();
    public virtual NameValueCollection get_ServerVariables();
    public virtual HttpCookieCollection get_Cookies();
    public virtual String[] get_AcceptTypes();
    public virtual Uri get_UrlReferrer();
    public virtual int get_ContentLength();
    public virtual string get_ContentType();
    public virtual void set_ContentType(string value);
    public static HttpRequestBase Create(HttpRequestMessageProperty request, Uri requestUri);
    public static HttpRequestBase Create(HttpListenerRequest listenerRequest);
    public static HttpRequestBase Create(string httpMethod, Uri requestUri, NameValueCollection form, NameValueCollection headers);
    public static HttpRequestBase Create(string httpMethod, Uri requestUri, NameValueCollection headers, Stream inputStream);
    private static NameValueCollection ParseFormData(string httpMethod, NameValueCollection headers, Func`1<Stream> inputStreamFunc);
    private static void AddHeaders(NameValueCollection collectionToFill, HttpHeaders headers);
}
internal class DotNetOpenAuth.Messaging.HttpResponseMessageWithOriginal : HttpResponseMessage {
    [CompilerGeneratedAttribute]
private IMessage <OriginalMessage>k__BackingField;
    internal IMessage OriginalMessage { get; private set; }
    internal HttpResponseMessageWithOriginal(IMessage originalMessage, HttpStatusCode statusCode);
    [CompilerGeneratedAttribute]
internal IMessage get_OriginalMessage();
    [CompilerGeneratedAttribute]
private void set_OriginalMessage(IMessage value);
}
public interface DotNetOpenAuth.Messaging.IChannelBindingElement {
    public Channel Channel { get; public set; }
    public MessageProtections Protection { get; }
    public abstract virtual Channel get_Channel();
    public abstract virtual void set_Channel(Channel value);
    public abstract virtual MessageProtections get_Protection();
    public abstract virtual Task`1<Nullable`1<MessageProtections>> ProcessOutgoingMessageAsync(IProtocolMessage message, CancellationToken cancellationToken);
    public abstract virtual Task`1<Nullable`1<MessageProtections>> ProcessIncomingMessageAsync(IProtocolMessage message, CancellationToken cancellationToken);
}
internal interface DotNetOpenAuth.Messaging.IDataBagFormatter`1 {
    public abstract virtual string Serialize(T message);
    public abstract virtual void Deserialize(T message, string data, IProtocolMessage containingMessage, string messagePartName);
}
public interface DotNetOpenAuth.Messaging.IDirectedProtocolMessage {
    public HttpDeliveryMethods HttpMethods { get; }
    public Uri Recipient { get; }
    public abstract virtual HttpDeliveryMethods get_HttpMethods();
    public abstract virtual Uri get_Recipient();
}
public interface DotNetOpenAuth.Messaging.IDirectResponseProtocolMessage {
    public IDirectedProtocolMessage OriginatingRequest { get; }
    public abstract virtual IDirectedProtocolMessage get_OriginatingRequest();
}
public interface DotNetOpenAuth.Messaging.IExtensionMessage {
}
public interface DotNetOpenAuth.Messaging.IHttpDirectRequest {
    public HttpRequestHeaders Headers { get; }
    public abstract virtual HttpRequestHeaders get_Headers();
}
public interface DotNetOpenAuth.Messaging.IHttpDirectResponse {
    public HttpStatusCode HttpStatusCode { get; }
    public WebHeaderCollection Headers { get; }
    public abstract virtual HttpStatusCode get_HttpStatusCode();
    public abstract virtual WebHeaderCollection get_Headers();
}
public interface DotNetOpenAuth.Messaging.IHttpIndirectResponse {
    public bool Include301RedirectPayloadInFragment { get; }
    public abstract virtual bool get_Include301RedirectPayloadInFragment();
}
public interface DotNetOpenAuth.Messaging.IMessage {
    public Version Version { get; }
    public IDictionary`2<string, string> ExtraData { get; }
    public abstract virtual Version get_Version();
    public abstract virtual IDictionary`2<string, string> get_ExtraData();
    public abstract virtual void EnsureValidMessage();
}
public interface DotNetOpenAuth.Messaging.IMessageFactory {
    public abstract virtual IDirectedProtocolMessage GetNewRequestMessage(MessageReceivingEndpoint recipient, IDictionary`2<string, string> fields);
    public abstract virtual IDirectResponseProtocolMessage GetNewResponseMessage(IDirectedProtocolMessage request, IDictionary`2<string, string> fields);
}
public interface DotNetOpenAuth.Messaging.IMessageOriginalPayload {
    public IDictionary`2<string, string> OriginalPayload { get; public set; }
    public abstract virtual IDictionary`2<string, string> get_OriginalPayload();
    public abstract virtual void set_OriginalPayload(IDictionary`2<string, string> value);
}
public interface DotNetOpenAuth.Messaging.IMessageWithBinaryData {
    public IList`1<MultipartContentMember> BinaryData { get; }
    public bool SendAsMultipart { get; }
    public abstract virtual IList`1<MultipartContentMember> get_BinaryData();
    public abstract virtual bool get_SendAsMultipart();
}
internal interface DotNetOpenAuth.Messaging.IMessageWithEvents {
    public abstract virtual void OnSending();
    public abstract virtual void OnReceiving();
}
internal class DotNetOpenAuth.Messaging.InternalErrorException : Exception {
    public InternalErrorException(string message);
    public InternalErrorException(string message, Exception inner);
    protected InternalErrorException(SerializationInfo info, StreamingContext context);
}
public interface DotNetOpenAuth.Messaging.IProtocolMessage {
    public MessageProtections RequiredProtection { get; }
    public MessageTransport Transport { get; }
    public abstract virtual MessageProtections get_RequiredProtection();
    public abstract virtual MessageTransport get_Transport();
}
public interface DotNetOpenAuth.Messaging.IProtocolMessageWithExtensions {
    public IList`1<IExtensionMessage> Extensions { get; }
    public abstract virtual IList`1<IExtensionMessage> get_Extensions();
}
internal interface DotNetOpenAuth.Messaging.IStreamSerializingDataBag {
    public abstract virtual void Serialize(Stream stream);
    public abstract virtual void Deserialize(Stream stream);
}
public interface DotNetOpenAuth.Messaging.ITamperResistantProtocolMessage {
    public string Signature { get; public set; }
    public abstract virtual string get_Signature();
    public abstract virtual void set_Signature(string value);
}
internal class DotNetOpenAuth.Messaging.KeyedCollectionDelegate`2 : KeyedCollection`2<TKey, TItem> {
    private Func`2<TItem, TKey> getKeyForItemDelegate;
    internal KeyedCollectionDelegate`2(Func`2<TItem, TKey> getKeyForItemDelegate);
    protected virtual TKey GetKeyForItem(TItem item);
}
[AttributeUsageAttribute("384")]
[DebuggerDisplayAttribute("MessagePartAttribute {Name}")]
public class DotNetOpenAuth.Messaging.MessagePartAttribute : Attribute {
    private string name;
    [CompilerGeneratedAttribute]
private ProtectionLevel <RequiredProtection>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsRequired>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <AllowEmpty>k__BackingField;
    [CompilerGeneratedAttribute]
private Type <Encoder>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsSecuritySensitive>k__BackingField;
    [CompilerGeneratedAttribute]
private Version <MinVersionValue>k__BackingField;
    [CompilerGeneratedAttribute]
private Version <MaxVersionValue>k__BackingField;
    public string Name { get; private set; }
    public ProtectionLevel RequiredProtection { get; public set; }
    public bool IsRequired { get; public set; }
    public bool AllowEmpty { get; public set; }
    public Type Encoder { get; public set; }
    public string MinVersion { get; public set; }
    public string MaxVersion { get; public set; }
    public bool IsSecuritySensitive { get; public set; }
    internal Version MinVersionValue { get; internal set; }
    internal Version MaxVersionValue { get; internal set; }
    public MessagePartAttribute(string name);
    public string get_Name();
    private void set_Name(string value);
    [CompilerGeneratedAttribute]
public ProtectionLevel get_RequiredProtection();
    [CompilerGeneratedAttribute]
public void set_RequiredProtection(ProtectionLevel value);
    [CompilerGeneratedAttribute]
public bool get_IsRequired();
    [CompilerGeneratedAttribute]
public void set_IsRequired(bool value);
    [CompilerGeneratedAttribute]
public bool get_AllowEmpty();
    [CompilerGeneratedAttribute]
public void set_AllowEmpty(bool value);
    [CompilerGeneratedAttribute]
public Type get_Encoder();
    [CompilerGeneratedAttribute]
public void set_Encoder(Type value);
    public string get_MinVersion();
    public void set_MinVersion(string value);
    public string get_MaxVersion();
    public void set_MaxVersion(string value);
    [CompilerGeneratedAttribute]
public bool get_IsSecuritySensitive();
    [CompilerGeneratedAttribute]
public void set_IsSecuritySensitive(bool value);
    [CompilerGeneratedAttribute]
internal Version get_MinVersionValue();
    [CompilerGeneratedAttribute]
internal void set_MinVersionValue(Version value);
    [CompilerGeneratedAttribute]
internal Version get_MaxVersionValue();
    [CompilerGeneratedAttribute]
internal void set_MaxVersionValue(Version value);
}
[FlagsAttribute]
public enum DotNetOpenAuth.Messaging.MessageProtections : Enum {
    public int value__;
    public static MessageProtections None;
    public static MessageProtections TamperProtection;
    public static MessageProtections Expiration;
    public static MessageProtections ReplayProtection;
    public static MessageProtections All;
}
internal static class DotNetOpenAuth.Messaging.MessageProtectionTasks : object {
    internal static Task`1<Nullable`1<MessageProtections>> Null;
    internal static Task`1<Nullable`1<MessageProtections>> None;
    internal static Task`1<Nullable`1<MessageProtections>> TamperProtection;
    internal static Task`1<Nullable`1<MessageProtections>> ReplayProtection;
    private static MessageProtectionTasks();
}
[DebuggerDisplayAttribute("{AllowedMethods} {Location}")]
public class DotNetOpenAuth.Messaging.MessageReceivingEndpoint : object {
    [CompilerGeneratedAttribute]
private Uri <Location>k__BackingField;
    [CompilerGeneratedAttribute]
private HttpDeliveryMethods <AllowedMethods>k__BackingField;
    public Uri Location { get; private set; }
    public HttpDeliveryMethods AllowedMethods { get; private set; }
    public MessageReceivingEndpoint(string locationUri, HttpDeliveryMethods method);
    public MessageReceivingEndpoint(Uri location, HttpDeliveryMethods method);
    [CompilerGeneratedAttribute]
public Uri get_Location();
    [CompilerGeneratedAttribute]
private void set_Location(Uri value);
    [CompilerGeneratedAttribute]
public HttpDeliveryMethods get_AllowedMethods();
    [CompilerGeneratedAttribute]
private void set_AllowedMethods(HttpDeliveryMethods value);
}
internal class DotNetOpenAuth.Messaging.MessageSerializer : object {
    private Type messageType;
    private MessageSerializer(Type messageType);
    internal static MessageSerializer Get(Type messageType);
    internal static void DeserializeJsonAsFlatDictionary(IDictionary`2<string, string> messageDictionary, XmlDictionaryReader reader);
    internal static void Serialize(MessageDictionary messageDictionary, XmlDictionaryWriter writer);
    internal static void Deserialize(MessageDictionary messageDictionary, XmlDictionaryReader reader);
    internal IDictionary`2<string, string> Serialize(MessageDictionary messageDictionary);
    internal void Deserialize(IDictionary`2<string, string> fields, MessageDictionary messageDictionary);
    private static bool IsNumeric(Type type);
}
public enum DotNetOpenAuth.Messaging.MessageTransport : Enum {
    public int value__;
    public static MessageTransport Direct;
    public static MessageTransport Indirect;
}
[CompilerGeneratedAttribute]
[GeneratedCodeAttribute("System.Resources.Tools.StronglyTypedResourceBuilder", "4.0.0.0")]
[DebuggerNonUserCodeAttribute]
internal class DotNetOpenAuth.Messaging.MessagingStrings : object {
    private static ResourceManager resourceMan;
    private static CultureInfo resourceCulture;
    [EditorBrowsableAttribute("2")]
internal static ResourceManager ResourceManager { get; }
    [EditorBrowsableAttribute("2")]
internal static CultureInfo Culture { get; internal set; }
    internal static string ArgumentPropertyMissing { get; }
    internal static string BinaryDataRequiresMultipart { get; }
    internal static string CurrentHttpContextRequired { get; }
    internal static string DataContractMissingFromMessageType { get; }
    internal static string DataContractMissingNamespace { get; }
    internal static string DataCorruptionDetected { get; }
    internal static string DerivedTypeNotExpected { get; }
    internal static string DirectedMessageMissingRecipient { get; }
    internal static string DirectWebRequestOptionsNotSupported { get; }
    internal static string EncoderInstantiationFailed { get; }
    internal static string ErrorDeserializingMessage { get; }
    internal static string ErrorInRequestReplyMessage { get; }
    internal static string ExceptionNotConstructedForTransit { get; }
    internal static string ExceptionUndeliverable { get; }
    internal static string ExpectedMessageNotReceived { get; }
    internal static string ExpectedParameterWasMissing { get; }
    internal static string ExpiredMessage { get; }
    internal static string ExtraParameterAddFailure { get; }
    internal static string GetOrPostFlagsRequired { get; }
    internal static string HttpContextRequired { get; }
    internal static string IndirectMessagesMustImplementIDirectedProtocolMessage { get; }
    internal static string InsecureWebRequestWithSslRequired { get; }
    internal static string InsufficientMessageProtection { get; }
    internal static string InvalidCustomBindingElementOrder { get; }
    internal static string InvalidMessageParts { get; }
    internal static string InvalidNonceReceived { get; }
    internal static string KeyAlreadyExists { get; }
    internal static string MessageExceedsGetSizePostNotAllowed { get; }
    internal static string MessageNotExtensible { get; }
    internal static string MessagePartEncoderWrongType { get; }
    internal static string MessagePartReadFailure { get; }
    internal static string MessagePartValueBase64DecodingFault { get; }
    internal static string MessagePartWriteFailure { get; }
    internal static string MessageTimestampInFuture { get; }
    internal static string MissingDecryptionKeyForHandle { get; }
    internal static string NonEmptyStringExpected { get; }
    internal static string QueuedMessageResponseAlreadyExists { get; }
    internal static string ReplayAttackDetected { get; }
    internal static string ReplayProtectionNotSupported { get; }
    internal static string RequiredMessagePartConstantIncorrect { get; }
    internal static string RequiredNonEmptyParameterWasEmpty { get; }
    internal static string RequiredParametersMissing { get; }
    internal static string RequiredProtectionMissing { get; }
    internal static string SequenceContainsNoElements { get; }
    internal static string SequenceContainsNullElement { get; }
    internal static string SessionRequired { get; }
    internal static string SignatureInvalid { get; }
    internal static string SigningNotSupported { get; }
    internal static string StandardMessageFactoryUnsupportedMessageType { get; }
    internal static string StreamMustHaveKnownLength { get; }
    internal static string StreamUnreadable { get; }
    internal static string StreamUnwritable { get; }
    internal static string TooManyBindingsOfferingSameProtection { get; }
    internal static string TooManyRedirects { get; }
    internal static string UnexpectedBufferLength { get; }
    internal static string UnexpectedEmptyArray { get; }
    internal static string UnexpectedEmptyString { get; }
    internal static string UnexpectedHttpStatusCode { get; }
    internal static string UnexpectedMessagePartValue { get; }
    internal static string UnexpectedMessagePartValueForConstant { get; }
    internal static string UnexpectedMessageReceived { get; }
    internal static string UnexpectedMessageReceivedOfMany { get; }
    internal static string UnexpectedNullKey { get; }
    internal static string UnexpectedNullOrEmptyKey { get; }
    internal static string UnexpectedNullValue { get; }
    internal static string UnexpectedType { get; }
    internal static string UnrecognizedEnumValue { get; }
    internal static string UnsafeWebRequestDetected { get; }
    internal static string UnsupportedEncryptionAlgorithm { get; }
    internal static string UnsupportedHttpVerb { get; }
    internal static string UnsupportedHttpVerbForMessageType { get; }
    internal static string UntrustedRedirectsOnPOSTNotSupported { get; }
    internal static string WebRequestFailed { get; }
    internal static ResourceManager get_ResourceManager();
    internal static CultureInfo get_Culture();
    internal static void set_Culture(CultureInfo value);
    internal static string get_ArgumentPropertyMissing();
    internal static string get_BinaryDataRequiresMultipart();
    internal static string get_CurrentHttpContextRequired();
    internal static string get_DataContractMissingFromMessageType();
    internal static string get_DataContractMissingNamespace();
    internal static string get_DataCorruptionDetected();
    internal static string get_DerivedTypeNotExpected();
    internal static string get_DirectedMessageMissingRecipient();
    internal static string get_DirectWebRequestOptionsNotSupported();
    internal static string get_EncoderInstantiationFailed();
    internal static string get_ErrorDeserializingMessage();
    internal static string get_ErrorInRequestReplyMessage();
    internal static string get_ExceptionNotConstructedForTransit();
    internal static string get_ExceptionUndeliverable();
    internal static string get_ExpectedMessageNotReceived();
    internal static string get_ExpectedParameterWasMissing();
    internal static string get_ExpiredMessage();
    internal static string get_ExtraParameterAddFailure();
    internal static string get_GetOrPostFlagsRequired();
    internal static string get_HttpContextRequired();
    internal static string get_IndirectMessagesMustImplementIDirectedProtocolMessage();
    internal static string get_InsecureWebRequestWithSslRequired();
    internal static string get_InsufficientMessageProtection();
    internal static string get_InvalidCustomBindingElementOrder();
    internal static string get_InvalidMessageParts();
    internal static string get_InvalidNonceReceived();
    internal static string get_KeyAlreadyExists();
    internal static string get_MessageExceedsGetSizePostNotAllowed();
    internal static string get_MessageNotExtensible();
    internal static string get_MessagePartEncoderWrongType();
    internal static string get_MessagePartReadFailure();
    internal static string get_MessagePartValueBase64DecodingFault();
    internal static string get_MessagePartWriteFailure();
    internal static string get_MessageTimestampInFuture();
    internal static string get_MissingDecryptionKeyForHandle();
    internal static string get_NonEmptyStringExpected();
    internal static string get_QueuedMessageResponseAlreadyExists();
    internal static string get_ReplayAttackDetected();
    internal static string get_ReplayProtectionNotSupported();
    internal static string get_RequiredMessagePartConstantIncorrect();
    internal static string get_RequiredNonEmptyParameterWasEmpty();
    internal static string get_RequiredParametersMissing();
    internal static string get_RequiredProtectionMissing();
    internal static string get_SequenceContainsNoElements();
    internal static string get_SequenceContainsNullElement();
    internal static string get_SessionRequired();
    internal static string get_SignatureInvalid();
    internal static string get_SigningNotSupported();
    internal static string get_StandardMessageFactoryUnsupportedMessageType();
    internal static string get_StreamMustHaveKnownLength();
    internal static string get_StreamUnreadable();
    internal static string get_StreamUnwritable();
    internal static string get_TooManyBindingsOfferingSameProtection();
    internal static string get_TooManyRedirects();
    internal static string get_UnexpectedBufferLength();
    internal static string get_UnexpectedEmptyArray();
    internal static string get_UnexpectedEmptyString();
    internal static string get_UnexpectedHttpStatusCode();
    internal static string get_UnexpectedMessagePartValue();
    internal static string get_UnexpectedMessagePartValueForConstant();
    internal static string get_UnexpectedMessageReceived();
    internal static string get_UnexpectedMessageReceivedOfMany();
    internal static string get_UnexpectedNullKey();
    internal static string get_UnexpectedNullOrEmptyKey();
    internal static string get_UnexpectedNullValue();
    internal static string get_UnexpectedType();
    internal static string get_UnrecognizedEnumValue();
    internal static string get_UnsafeWebRequestDetected();
    internal static string get_UnsupportedEncryptionAlgorithm();
    internal static string get_UnsupportedHttpVerb();
    internal static string get_UnsupportedHttpVerbForMessageType();
    internal static string get_UntrustedRedirectsOnPOSTNotSupported();
    internal static string get_WebRequestFailed();
}
[ExtensionAttribute]
public static class DotNetOpenAuth.Messaging.MessagingUtilities : object {
    internal static string UppercaseLetters;
    internal static string LowercaseLetters;
    internal static string Digits;
    internal static string AlphaNumeric;
    internal static string Base64Characters;
    internal static string Base64WebSafeCharacters;
    internal static string AlphaNumericNoLookAlikes;
    private static int SymmetricSecretHandleLength;
    internal static RandomNumberGenerator CryptoRandomDataGenerator;
    private static Task CompletedTaskField;
    private static TimeSpan SymmetricSecretKeyLifespan;
    private static Char[] EqualsArray;
    private static Char[] CommaArray;
    private static Char[] QuoteArray;
    private static String[] UriRfc3986CharsToEscape;
    private static Dictionary`2<string, string> javascriptStaticStringEscaping;
    [CompilerGeneratedAttribute]
private static Func`2<string, <>f__AnonymousType2`2<string, String[]>> CS$<>9__CachedAnonymousMethodDelegate1b;
    [CompilerGeneratedAttribute]
private static Func`2<<>f__AnonymousType2`2<string, String[]>, <>f__AnonymousType3`2<<>f__AnonymousType2`2<string, String[]>, string>> CS$<>9__CachedAnonymousMethodDelegate1c;
    [CompilerGeneratedAttribute]
private static Func`2<<>f__AnonymousType3`2<<>f__AnonymousType2`2<string, String[]>, string>, <>f__AnonymousType4`2<<>f__AnonymousType3`2<<>f__AnonymousType2`2<string, String[]>, string>, string>> CS$<>9__CachedAnonymousMethodDelegate1d;
    [CompilerGeneratedAttribute]
private static Func`2<<>f__AnonymousType4`2<<>f__AnonymousType3`2<<>f__AnonymousType2`2<string, String[]>, string>, string>, KeyValuePair`2<string, string>> CS$<>9__CachedAnonymousMethodDelegate1e;
    internal static Task CompletedTask { get; }
    internal static Random NonCryptoRandomDataGenerator { get; }
    private static MessagingUtilities();
    internal static Task get_CompletedTask();
    internal static Random get_NonCryptoRandomDataGenerator();
    public static Uri GetRequestUrlFromContext();
    [ExtensionAttribute]
public static Uri StripQueryArgumentsWithPrefix(Uri uri, string prefix);
    [ExtensionAttribute]
public static string ToStringDescriptive(Exception exception);
    [ObsoleteAttribute("Use Enumerable.SelectMany instead.")]
[ExtensionAttribute]
public static IEnumerable`1<T> Flatten(IEnumerable`1<IEnumerable`1<T>> sequence);
    [ExtensionAttribute]
public static DateTime CutToSecond(DateTime value);
    [ExtensionAttribute]
public static void AppendQueryArgument(UriBuilder builder, string name, string value);
    [ExtensionAttribute]
public static void AddRange(ICollection`1<T> collection, IEnumerable`1<T> values);
    [ExtensionAttribute]
public static bool Equals(TimeSpan self, TimeSpan other, TimeSpan marginOfError);
    public static bool EqualsConstantTime(string value1, string value2);
    [ExtensionAttribute]
public static Uri GetPublicFacingUrl(HttpRequestBase request, NameValueCollection serverVariables);
    [ExtensionAttribute]
public static Uri GetPublicFacingUrl(HttpRequestBase request);
    public static Uri GetPublicFacingUrl();
    [ExtensionAttribute]
public static HttpRequestMessage AsHttpRequestMessage(HttpRequestBase request);
    [DebuggerStepThroughAttribute]
[ExtensionAttribute]
[AsyncStateMachineAttribute("DotNetOpenAuth.Messaging.MessagingUtilities/<SendAsync>d__c")]
public static Task SendAsync(HttpResponseMessage response, HttpContextBase context, CancellationToken cancellationToken);
    [ExtensionAttribute]
internal static void DisposeIfNotNull(IDisposable disposable);
    [ExtensionAttribute]
internal static HttpRequestMessage Clone(HttpRequestMessage original);
    internal static Uri GetWebRoot();
    internal static XmlReaderSettings CreateUntrustedXmlReaderSettings();
    [ExtensionAttribute]
internal static void ResetContents(ICollection`1<T> collection, IEnumerable`1<T> values);
    [ExtensionAttribute]
internal static Uri StripMessagePartsFromQueryString(Uri uri, MessageDescription messageDescription);
    internal static string AssembleAuthorizationHeader(IEnumerable`1<KeyValuePair`2<string, string>> fields);
    internal static string AssembleAuthorizationHeader(string scheme, IEnumerable`1<KeyValuePair`2<string, string>> fields);
    internal static IEnumerable`1<KeyValuePair`2<string, string>> ParseAuthorizationHeader(string scheme, AuthenticationHeaderValue authorizationHeader);
    internal static string CombineKeyHandleAndPayload(string handle, string payload);
    internal static void ExtractKeyHandleAndPayload(string messagePart, string keyHandleAndBlob, String& handle, String& dataBlob);
    internal static Byte[] GetNonCryptoRandomData(int length);
    internal static Byte[] GetCryptoRandomData(int length);
    internal static string GetCryptoRandomDataAsBase64(int binaryLength);
    internal static string GetNonCryptoRandomDataAsBase64(int binaryLength, bool useWeb64);
    internal static string GetRandomString(int length, string allowableCharacters);
    [ExtensionAttribute]
internal static string ComputeHash(HashAlgorithm algorithm, string value, Encoding encoding);
    [ExtensionAttribute]
internal static string ComputeHash(HashAlgorithm algorithm, IDictionary`2<string, string> data, Encoding encoding);
    [ExtensionAttribute]
internal static string ComputeHash(HashAlgorithm algorithm, IEnumerable`1<KeyValuePair`2<string, string>> sortedData, Encoding encoding);
    internal static Byte[] Encrypt(Byte[] buffer, Byte[] key);
    internal static Byte[] Decrypt(Byte[] buffer, Byte[] key);
    internal static string Encrypt(string plainText, Byte[] key);
    internal static string Decrypt(string cipherText, Byte[] key);
    [ExtensionAttribute]
internal static Byte[] EncryptWithRandomSymmetricKey(RSACryptoServiceProvider crypto, Byte[] buffer);
    [ExtensionAttribute]
internal static Byte[] DecryptWithRandomSymmetricKey(RSACryptoServiceProvider crypto, Byte[] buffer);
    [ExtensionAttribute]
internal static KeyValuePair`2<string, CryptoKey> GetCurrentKey(ICryptoKeyStore cryptoKeyStore, string bucket, TimeSpan minimumRemainingLife, int keySize);
    internal static Byte[] Compress(Byte[] buffer, CompressionMethod method);
    internal static Byte[] Decompress(Byte[] buffer, CompressionMethod method);
    internal static string ConvertToBase64WebSafeString(Byte[] data);
    internal static Byte[] FromBase64WebSafeString(string base64WebSafe);
    internal static void ApplyHeadersToResponse(WebHeaderCollection headers, HttpResponseBase response);
    [ExtensionAttribute]
internal static int CopyUpTo(Stream copyFrom, Stream copyTo, int maximumBytesToCopy);
    [ExtensionAttribute]
internal static Stream CreateSnapshot(Stream copyFrom);
    [ExtensionAttribute]
internal static void CopyHeadersFrom(HttpRequestMessage message, HttpRequestBase request);
    internal static bool AreEquivalent(T[] first, T[] second);
    internal static bool AreEquivalentConstantTime(Byte[] first, Byte[] second);
    internal static bool AreEquivalent(IEnumerable`1<T> sequence1, IEnumerable`1<T> sequence2);
    internal static bool AreEquivalentUnordered(ICollection`1<T> first, ICollection`1<T> second);
    internal static bool AreEquivalent(IDictionary`2<TKey, TValue> first, IDictionary`2<TKey, TValue> second);
    internal static string CreateQueryString(IEnumerable`1<KeyValuePair`2<string, string>> args);
    [ExtensionAttribute]
internal static void AppendQueryArgs(UriBuilder builder, IEnumerable`1<KeyValuePair`2<string, string>> args);
    [ExtensionAttribute]
internal static void AppendFragmentArgs(UriBuilder builder, IEnumerable`1<KeyValuePair`2<string, string>> args);
    [ExtensionAttribute]
internal static void AppendAndReplaceQueryArgs(UriBuilder builder, IEnumerable`1<KeyValuePair`2<string, string>> args);
    [ExtensionAttribute]
internal static MessageReceivingEndpoint GetRecipient(HttpRequestMessage request);
    internal static HttpDeliveryMethods GetHttpDeliveryMethod(string httpVerb);
    internal static HttpMethod GetHttpVerb(HttpDeliveryMethods httpMethod);
    [ExtensionAttribute]
internal static void AddExtraParameters(MessageDictionary messageDictionary, IDictionary`2<string, string> extraParameters);
    [ExtensionAttribute]
internal static Uri GetDirectUriRequest(HttpResponseMessage response);
    [ExtensionAttribute]
internal static Dictionary`2<TKey, TValue> ToDictionary(IEnumerable`1<KeyValuePair`2<TKey, TValue>> sequence);
    [ExtensionAttribute]
internal static IEnumerable`1<KeyValuePair`2<string, string>> AsKeyValuePairs(NameValueCollection nvc);
    [ExtensionAttribute]
internal static Dictionary`2<string, string> ToDictionary(NameValueCollection nvc);
    [ExtensionAttribute]
internal static Dictionary`2<string, string> ToDictionary(NameValueCollection nvc, bool throwOnNullKey);
    [ExtensionAttribute]
internal static NameValueCollection ToNameValueCollection(IDictionary`2<string, string> data);
    [ExtensionAttribute]
internal static IOrderedEnumerable`1<TSource> OrderBy(IEnumerable`1<TSource> source, Func`2<TSource, TKey> keySelector, Comparison`1<TKey> comparer);
    [ExtensionAttribute]
internal static bool IsRequest(IDirectedProtocolMessage message);
    [ExtensionAttribute]
internal static bool IsDirectResponse(IDirectResponseProtocolMessage message);
    [ExtensionAttribute]
internal static void WriteBuffer(BinaryWriter writer, Byte[] buffer);
    [ExtensionAttribute]
internal static Byte[] ReadBuffer(BinaryReader reader, int maxBufferSize);
    internal static string CreateJsonObject(IEnumerable`1<KeyValuePair`2<string, string>> namesAndValues, bool valuesPreEncoded);
    internal static string SerializeAsJson(IMessage message, MessageDescriptionCollection messageDescriptions);
    internal static Byte[] SerializeAsJsonBytes(IMessage message, MessageDescriptionCollection messageDescriptions, Encoding encoding);
    internal static void DeserializeFromJson(Byte[] jsonBytes, IMessage receivingMessage, MessageDescriptionCollection messageDescriptions, Encoding encoding);
    internal static string GetSafeJavascriptValue(string value);
    internal static string EscapeUriDataStringRfc3986(string value);
    [ExtensionAttribute]
internal static DateTime ToLocalTimeSafe(DateTime value);
    [ExtensionAttribute]
internal static DateTime ToUniversalTimeSafe(DateTime value);
    [ExtensionAttribute]
internal static NameValueCollection GetQueryStringBeforeRewriting(HttpRequestBase request);
    [ExtensionAttribute]
internal static bool GetIsUrlRewritten(HttpRequestBase request);
    [ExtensionAttribute]
internal static NameValueCollection GetQueryOrForm(HttpRequestBase request);
    private static SymmetricAlgorithm CreateSymmetricAlgorithm(Byte[] key);
    [CompilerGeneratedAttribute]
private static <>f__AnonymousType2`2<string, String[]> <ParseAuthorizationHeader>b__17(string element);
    [CompilerGeneratedAttribute]
private static <>f__AnonymousType3`2<<>f__AnonymousType2`2<string, String[]>, string> <ParseAuthorizationHeader>b__18(<>f__AnonymousType2`2<string, String[]> <>h__TransparentIdentifier14);
    [CompilerGeneratedAttribute]
private static <>f__AnonymousType4`2<<>f__AnonymousType3`2<<>f__AnonymousType2`2<string, String[]>, string>, string> <ParseAuthorizationHeader>b__19(<>f__AnonymousType3`2<<>f__AnonymousType2`2<string, String[]>, string> <>h__TransparentIdentifier15);
    [CompilerGeneratedAttribute]
private static KeyValuePair`2<string, string> <ParseAuthorizationHeader>b__1a(<>f__AnonymousType4`2<<>f__AnonymousType3`2<<>f__AnonymousType2`2<string, String[]>, string>, string> <>h__TransparentIdentifier16);
    [CompilerGeneratedAttribute]
private static TKey <ToDictionary>b__22(KeyValuePair`2<TKey, TValue> pair);
    [CompilerGeneratedAttribute]
private static TValue <ToDictionary>b__23(KeyValuePair`2<TKey, TValue> pair);
}
public class DotNetOpenAuth.Messaging.MultipartContentMember : ValueType {
    [CompilerGeneratedAttribute]
private HttpContent <Content>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    [CompilerGeneratedAttribute]
private string <FileName>k__BackingField;
    public HttpContent Content { get; public set; }
    public string Name { get; public set; }
    public string FileName { get; public set; }
    public MultipartContentMember(HttpContent content, string name, string fileName);
    [CompilerGeneratedAttribute]
public HttpContent get_Content();
    [CompilerGeneratedAttribute]
public void set_Content(HttpContent value);
    [CompilerGeneratedAttribute]
public string get_Name();
    [CompilerGeneratedAttribute]
public void set_Name(string value);
    [CompilerGeneratedAttribute]
public string get_FileName();
    [CompilerGeneratedAttribute]
public void set_FileName(string value);
}
public class DotNetOpenAuth.Messaging.ProtocolException : Exception {
    [CompilerGeneratedAttribute]
private IProtocolMessage <FaultedMessage>k__BackingField;
    internal IProtocolMessage FaultedMessage { get; private set; }
    public ProtocolException(string message);
    public ProtocolException(string message, Exception inner);
    protected internal ProtocolException(string message, IProtocolMessage faultedMessage, Exception innerException);
    protected ProtocolException(SerializationInfo info, StreamingContext context);
    [CompilerGeneratedAttribute]
internal IProtocolMessage get_FaultedMessage();
    [CompilerGeneratedAttribute]
private void set_FaultedMessage(IProtocolMessage value);
}
public class DotNetOpenAuth.Messaging.ProtocolFaultResponseException : ProtocolException {
    private Channel channel;
    [CompilerGeneratedAttribute]
private IDirectResponseProtocolMessage <ErrorResponseMessage>k__BackingField;
    public IDirectResponseProtocolMessage ErrorResponseMessage { get; private set; }
    protected internal ProtocolFaultResponseException(Channel channel, IDirectResponseProtocolMessage errorResponse, IProtocolMessage faultedMessage, Exception innerException, string message);
    protected ProtocolFaultResponseException(SerializationInfo info, StreamingContext context);
    [CompilerGeneratedAttribute]
public IDirectResponseProtocolMessage get_ErrorResponseMessage();
    [CompilerGeneratedAttribute]
private void set_ErrorResponseMessage(IDirectResponseProtocolMessage value);
    public Task`1<HttpResponseMessage> CreateErrorResponseAsync(CancellationToken cancellationToken);
}
[DefaultMemberAttribute("Item")]
internal class DotNetOpenAuth.Messaging.ReadOnlyDictionary`2 : object {
    private IDictionary`2<K, V> baseDictionary;
    public ICollection`1<K> Keys { get; }
    public ICollection`1<V> Values { get; }
    public int Count { get; }
    public bool IsReadOnly { get; }
    public V Item { get; public set; }
    public ReadOnlyDictionary`2(IDictionary`2<K, V> baseDictionary);
    public sealed virtual ICollection`1<K> get_Keys();
    public sealed virtual ICollection`1<V> get_Values();
    public sealed virtual int get_Count();
    public sealed virtual bool get_IsReadOnly();
    public sealed virtual V get_Item(K key);
    public sealed virtual void set_Item(K key, V value);
    public sealed virtual void Add(K key, V value);
    public sealed virtual bool ContainsKey(K key);
    public sealed virtual bool Remove(K key);
    public sealed virtual bool TryGetValue(K key, V& value);
    public sealed virtual void Add(KeyValuePair`2<K, V> item);
    public sealed virtual void Clear();
    public sealed virtual bool Contains(KeyValuePair`2<K, V> item);
    public sealed virtual void CopyTo(KeyValuePair`2[] array, int arrayIndex);
    public sealed virtual bool Remove(KeyValuePair`2<K, V> item);
    public sealed virtual IEnumerator`1<KeyValuePair`2<K, V>> GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
}
[AttributeUsageAttribute("12")]
internal class DotNetOpenAuth.Messaging.Reflection.DefaultEncoderAttribute : Attribute {
    [CompilerGeneratedAttribute]
private IMessagePartEncoder <Encoder>k__BackingField;
    public IMessagePartEncoder Encoder { get; private set; }
    public DefaultEncoderAttribute(Type converterType);
    [CompilerGeneratedAttribute]
public IMessagePartEncoder get_Encoder();
    [CompilerGeneratedAttribute]
private void set_Encoder(IMessagePartEncoder value);
}
public interface DotNetOpenAuth.Messaging.Reflection.IMessagePartEncoder {
    public abstract virtual string Encode(object value);
    public abstract virtual object Decode(string value);
}
public interface DotNetOpenAuth.Messaging.Reflection.IMessagePartFormattingEncoder {
    public Type FormattingType { get; }
    public abstract virtual Type get_FormattingType();
}
public interface DotNetOpenAuth.Messaging.Reflection.IMessagePartNullEncoder {
    public string EncodedNullValue { get; }
    public abstract virtual string get_EncodedNullValue();
}
public interface DotNetOpenAuth.Messaging.Reflection.IMessagePartOriginalEncoder {
    public abstract virtual string EncodeAsOriginalString(object value);
}
internal class DotNetOpenAuth.Messaging.Reflection.MessageDescription : object {
    private Dictionary`2<string, MessagePart> mapping;
    [CompilerGeneratedAttribute]
private Version <MessageVersion>k__BackingField;
    [CompilerGeneratedAttribute]
private Type <MessageType>k__BackingField;
    [CompilerGeneratedAttribute]
private ConstructorInfo[] <Constructors>k__BackingField;
    [CompilerGeneratedAttribute]
private static Func`2<MessagePart, string> CS$<>9__CachedAnonymousMethodDelegate2;
    [CompilerGeneratedAttribute]
private static Func`2<MessagePart, string> CS$<>9__CachedAnonymousMethodDelegate7;
    [CompilerGeneratedAttribute]
private static Func`2<MessagePart, bool> CS$<>9__CachedAnonymousMethodDelegatee;
    [CompilerGeneratedAttribute]
private static Func`2<MessagePart, string> CS$<>9__CachedAnonymousMethodDelegatef;
    [CompilerGeneratedAttribute]
private static Func`2<MessagePartAttribute, Version> CS$<>9__CachedAnonymousMethodDelegate15;
    internal IDictionary`2<string, MessagePart> Mapping { get; }
    internal Version MessageVersion { get; private set; }
    internal Type MessageType { get; private set; }
    internal ConstructorInfo[] Constructors { get; private set; }
    internal MessageDescription(Type messageType, Version messageVersion);
    internal IDictionary`2<string, MessagePart> get_Mapping();
    [CompilerGeneratedAttribute]
internal Version get_MessageVersion();
    [CompilerGeneratedAttribute]
private void set_MessageVersion(Version value);
    [CompilerGeneratedAttribute]
internal Type get_MessageType();
    [CompilerGeneratedAttribute]
private void set_MessageType(Type value);
    [CompilerGeneratedAttribute]
internal ConstructorInfo[] get_Constructors();
    [CompilerGeneratedAttribute]
private void set_Constructors(ConstructorInfo[] value);
    public virtual string ToString();
    internal MessageDictionary GetDictionary(IMessage message);
    internal MessageDictionary GetDictionary(IMessage message, bool getOriginalValues);
    internal void EnsureMessagePartsPassBasicValidation(IDictionary`2<string, string> parts);
    internal bool CheckMessagePartsPassBasicValidation(IDictionary`2<string, string> parts);
    private bool CheckRequiredMessagePartsArePresent(IEnumerable`1<string> keys, bool throwOnFailure);
    private bool CheckRequiredProtocolMessagePartsAreNotEmpty(IDictionary`2<string, string> partValues, bool throwOnFailure);
    private bool CheckMessagePartsConstantValues(IDictionary`2<string, string> partValues, bool throwOnFailure);
    private void ReflectMessageType();
    [CompilerGeneratedAttribute]
private static string <CheckRequiredMessagePartsArePresent>b__1(MessagePart part);
    [CompilerGeneratedAttribute]
private static string <CheckRequiredProtocolMessagePartsAreNotEmpty>b__6(MessagePart part);
    [CompilerGeneratedAttribute]
private static bool <CheckMessagePartsConstantValues>b__a(MessagePart part);
    [CompilerGeneratedAttribute]
private static string <CheckMessagePartsConstantValues>b__d(MessagePart part);
    [CompilerGeneratedAttribute]
private static Version <ReflectMessageType>b__12(MessagePartAttribute a);
    [CompilerGeneratedAttribute]
private bool <ReflectMessageType>b__13(MessagePartAttribute a);
    [CompilerGeneratedAttribute]
private bool <ReflectMessageType>b__14(MessagePartAttribute a);
}
internal class DotNetOpenAuth.Messaging.Reflection.MessageDescriptionCollection : object {
    private Dictionary`2<MessageTypeAndVersion, MessageDescription> reflectedMessageTypes;
    public sealed virtual IEnumerator`1<MessageDescription> GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    internal MessageDescription Get(Type messageType, Version messageVersion);
    internal MessageDescription Get(IMessage message);
    internal MessageDictionary GetAccessor(IMessage message);
    internal MessageDictionary GetAccessor(IMessage message, bool getOriginalValues);
}
[DefaultMemberAttribute("Item")]
internal class DotNetOpenAuth.Messaging.Reflection.MessageDictionary : object {
    private IMessage message;
    private MessageDescription description;
    private bool getOriginalValues;
    public IMessage Message { get; }
    public MessageDescription Description { get; }
    public int Count { get; }
    private bool System.Collections.Generic.ICollection<System.Collections.Generic.KeyValuePair<System.String,System.String>>.IsReadOnly { get; }
    public ICollection`1<string> Keys { get; }
    public ICollection`1<string> DeclaredKeys { get; }
    public ICollection`1<string> AdditionalKeys { get; }
    public ICollection`1<string> Values { get; }
    private MessageSerializer Serializer { get; }
    public string Item { get; public set; }
    internal MessageDictionary(IMessage message, MessageDescription description, bool getOriginalValues);
    public IMessage get_Message();
    public MessageDescription get_Description();
    public sealed virtual int get_Count();
    private sealed virtual override bool System.Collections.Generic.ICollection<System.Collections.Generic.KeyValuePair<System.String,System.String>>.get_IsReadOnly();
    public sealed virtual ICollection`1<string> get_Keys();
    public ICollection`1<string> get_DeclaredKeys();
    public ICollection`1<string> get_AdditionalKeys();
    public sealed virtual ICollection`1<string> get_Values();
    private MessageSerializer get_Serializer();
    public sealed virtual string get_Item(string key);
    public sealed virtual void set_Item(string key, string value);
    public sealed virtual void Add(string key, string value);
    public sealed virtual bool ContainsKey(string key);
    public sealed virtual bool Remove(string key);
    public sealed virtual bool TryGetValue(string key, String& value);
    public sealed virtual void Add(KeyValuePair`2<string, string> item);
    public void ClearValues();
    public sealed virtual void Clear();
    public sealed virtual bool Contains(KeyValuePair`2<string, string> item);
    private sealed virtual override void System.Collections.Generic.ICollection<System.Collections.Generic.KeyValuePair<System.String,System.String>>.CopyTo(KeyValuePair`2[] array, int arrayIndex);
    public sealed virtual bool Remove(KeyValuePair`2<string, string> item);
    public sealed virtual IEnumerator`1<KeyValuePair`2<string, string>> GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    public IDictionary`2<string, string> Serialize();
    public void Deserialize(IDictionary`2<string, string> fields);
}
[DebuggerDisplayAttribute("MessagePart {Name}")]
internal class DotNetOpenAuth.Messaging.Reflection.MessagePart : object {
    private static Dictionary`2<Type, ValueMapping> converters;
    private static Dictionary`2<Type, IMessagePartEncoder> encoders;
    private ValueMapping converter;
    private PropertyInfo property;
    private FieldInfo field;
    private Type memberDeclaredType;
    private object defaultMemberValue;
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    [CompilerGeneratedAttribute]
private ProtectionLevel <RequiredProtection>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsRequired>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <AllowEmpty>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsConstantValue>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsConstantValueAvailableStatically>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsSecuritySensitive>k__BackingField;
    [CompilerGeneratedAttribute]
private static Func`2<string, Uri> CS$<>9__CachedAnonymousMethodDelegate13;
    [CompilerGeneratedAttribute]
private static Func`2<string, bool> CS$<>9__CachedAnonymousMethodDelegate14;
    [CompilerGeneratedAttribute]
private static Func`2<Byte[], string> CS$<>9__CachedAnonymousMethodDelegate15;
    [CompilerGeneratedAttribute]
private static Func`2<string, Byte[]> CS$<>9__CachedAnonymousMethodDelegate16;
    [CompilerGeneratedAttribute]
private static Func`2<Uri, string> CS$<>9__CachedAnonymousMethodDelegate17;
    [CompilerGeneratedAttribute]
private static Func`2<Uri, string> CS$<>9__CachedAnonymousMethodDelegate18;
    [CompilerGeneratedAttribute]
private static Func`2<DateTime, string> CS$<>9__CachedAnonymousMethodDelegate19;
    [CompilerGeneratedAttribute]
private static Func`2<string, DateTime> CS$<>9__CachedAnonymousMethodDelegate1a;
    [CompilerGeneratedAttribute]
private static Func`2<TimeSpan, string> CS$<>9__CachedAnonymousMethodDelegate1b;
    [CompilerGeneratedAttribute]
private static Func`2<string, TimeSpan> CS$<>9__CachedAnonymousMethodDelegate1c;
    [CompilerGeneratedAttribute]
private static Func`2<bool, string> CS$<>9__CachedAnonymousMethodDelegate1d;
    [CompilerGeneratedAttribute]
private static Func`2<CultureInfo, string> CS$<>9__CachedAnonymousMethodDelegate1e;
    [CompilerGeneratedAttribute]
private static Func`2<string, CultureInfo> CS$<>9__CachedAnonymousMethodDelegate1f;
    [CompilerGeneratedAttribute]
private static Func`2<CultureInfo[], string> CS$<>9__CachedAnonymousMethodDelegate20;
    [CompilerGeneratedAttribute]
private static Func`2<string, CultureInfo[]> CS$<>9__CachedAnonymousMethodDelegate21;
    [CompilerGeneratedAttribute]
private static Func`2<Type, string> CS$<>9__CachedAnonymousMethodDelegate22;
    [CompilerGeneratedAttribute]
private static Func`2<string, Type> CS$<>9__CachedAnonymousMethodDelegate23;
    [CompilerGeneratedAttribute]
private static Func`2<CultureInfo, string> CS$<>9__CachedAnonymousMethodDelegate24;
    [CompilerGeneratedAttribute]
private static Func`2<string, CultureInfo> CS$<>9__CachedAnonymousMethodDelegate25;
    [CompilerGeneratedAttribute]
private static Func`2<object, string> CS$<>9__CachedAnonymousMethodDelegate31;
    internal string Name { get; internal set; }
    internal ProtectionLevel RequiredProtection { get; internal set; }
    internal bool IsRequired { get; internal set; }
    internal bool AllowEmpty { get; internal set; }
    internal bool IsConstantValue { get; internal set; }
    internal bool IsConstantValueAvailableStatically { get; internal set; }
    internal bool IsSecuritySensitive { get; internal set; }
    internal string StaticConstantValue { get; }
    internal Type MemberDeclaredType { get; }
    internal Type PreferredFormattingType { get; }
    private static MessagePart();
    internal MessagePart(MemberInfo member, MessagePartAttribute attribute);
    [CompilerGeneratedAttribute]
internal string get_Name();
    [CompilerGeneratedAttribute]
internal void set_Name(string value);
    [CompilerGeneratedAttribute]
internal ProtectionLevel get_RequiredProtection();
    [CompilerGeneratedAttribute]
internal void set_RequiredProtection(ProtectionLevel value);
    [CompilerGeneratedAttribute]
internal bool get_IsRequired();
    [CompilerGeneratedAttribute]
internal void set_IsRequired(bool value);
    [CompilerGeneratedAttribute]
internal bool get_AllowEmpty();
    [CompilerGeneratedAttribute]
internal void set_AllowEmpty(bool value);
    [CompilerGeneratedAttribute]
internal bool get_IsConstantValue();
    [CompilerGeneratedAttribute]
internal void set_IsConstantValue(bool value);
    [CompilerGeneratedAttribute]
internal bool get_IsConstantValueAvailableStatically();
    [CompilerGeneratedAttribute]
internal void set_IsConstantValueAvailableStatically(bool value);
    [CompilerGeneratedAttribute]
internal bool get_IsSecuritySensitive();
    [CompilerGeneratedAttribute]
internal void set_IsSecuritySensitive(bool value);
    internal string get_StaticConstantValue();
    internal Type get_MemberDeclaredType();
    internal Type get_PreferredFormattingType();
    internal void SetValue(IMessage message, string value);
    internal string GetValue(IMessage message);
    internal string GetValue(IMessage message, bool originalValue);
    internal bool IsNondefaultValueSet(IMessage message);
    private static void Map(Func`2<T, string> toString, Func`2<T, string> toOriginalString, Func`2<string, T> toValue);
    private static ValueMapping CreateFallbackMapping(Type type);
    private static ValueMapping GetDefaultEncoder(Type type);
    private static object DeriveDefaultValue(Type type);
    private static bool IsNonNullableValueType(Type type);
    private static IMessagePartEncoder GetEncoder(Type messagePartEncoder);
    private object GetValueAsObject(IMessage message);
    private void SetValueAsObject(IMessage message, object value);
    private object ToValue(string value);
    private string ToString(object value, bool originalString);
    private void ValidateSettings();
    [CompilerGeneratedAttribute]
private static Uri <.cctor>b__0(string str);
    [CompilerGeneratedAttribute]
private static bool <.cctor>b__1(string str);
    [CompilerGeneratedAttribute]
private static string <.cctor>b__2(Byte[] bytes);
    [CompilerGeneratedAttribute]
private static Byte[] <.cctor>b__3(string str);
    [CompilerGeneratedAttribute]
private static string <.cctor>b__4(Uri uri);
    [CompilerGeneratedAttribute]
private static string <.cctor>b__5(Uri uri);
    [CompilerGeneratedAttribute]
private static string <.cctor>b__6(DateTime dt);
    [CompilerGeneratedAttribute]
private static DateTime <.cctor>b__7(string str);
    [CompilerGeneratedAttribute]
private static string <.cctor>b__8(TimeSpan ts);
    [CompilerGeneratedAttribute]
private static TimeSpan <.cctor>b__9(string str);
    [CompilerGeneratedAttribute]
private static string <.cctor>b__a(bool value);
    [CompilerGeneratedAttribute]
private static string <.cctor>b__b(CultureInfo c);
    [CompilerGeneratedAttribute]
private static CultureInfo <.cctor>b__c(string str);
    [CompilerGeneratedAttribute]
private static string <.cctor>b__d(CultureInfo[] cs);
    [CompilerGeneratedAttribute]
private static CultureInfo[] <.cctor>b__f(string str);
    [CompilerGeneratedAttribute]
private static string <.cctor>b__11(Type t);
    [CompilerGeneratedAttribute]
private static Type <.cctor>b__12(string str);
    [CompilerGeneratedAttribute]
private static string <.cctor>b__e(CultureInfo c);
    [CompilerGeneratedAttribute]
private static CultureInfo <.cctor>b__10(string s);
    [CompilerGeneratedAttribute]
private static string <CreateFallbackMapping>b__2f(object obj);
}
internal class DotNetOpenAuth.Messaging.Reflection.ValueMapping : ValueType {
    internal Func`2<object, string> ValueToString;
    internal Func`2<object, string> ValueToOriginalString;
    internal Func`2<string, object> StringToValue;
    [CompilerGeneratedAttribute]
private IMessagePartEncoder <Encoder>k__BackingField;
    internal IMessagePartEncoder Encoder { get; private set; }
    internal ValueMapping(Func`2<object, string> toString, Func`2<object, string> toOriginalString, Func`2<string, object> toValue);
    internal ValueMapping(IMessagePartEncoder encoder);
    [CompilerGeneratedAttribute]
internal IMessagePartEncoder get_Encoder();
    [CompilerGeneratedAttribute]
private void set_Encoder(IMessagePartEncoder value);
}
internal class DotNetOpenAuth.Messaging.StandardMessageFactory : object {
    private Dictionary`2<MessageDescription, ConstructorInfo> requestMessageTypes;
    private Dictionary`2<MessageDescription, Dictionary`2<Type, ConstructorInfo>> responseMessageTypes;
    [CompilerGeneratedAttribute]
private static Func`2<MessageDescription, int> CS$<>9__CachedAnonymousMethodDelegate3;
    [CompilerGeneratedAttribute]
private static Func`2<KeyValuePair`2<MessageDescription, Dictionary`2<Type, ConstructorInfo>>, <>f__AnonymousType0`2<KeyValuePair`2<MessageDescription, Dictionary`2<Type, ConstructorInfo>>, MessageDescription>> CS$<>9__CachedAnonymousMethodDelegate10;
    [CompilerGeneratedAttribute]
private static Func`2<<>f__AnonymousType1`2<<>f__AnonymousType0`2<KeyValuePair`2<MessageDescription, Dictionary`2<Type, ConstructorInfo>>, MessageDescription>, IEnumerable`1<ConstructorInfo>>, bool> CS$<>9__CachedAnonymousMethodDelegate11;
    [CompilerGeneratedAttribute]
private static Func`2<<>f__AnonymousType1`2<<>f__AnonymousType0`2<KeyValuePair`2<MessageDescription, Dictionary`2<Type, ConstructorInfo>>, MessageDescription>, IEnumerable`1<ConstructorInfo>>, int> CS$<>9__CachedAnonymousMethodDelegate12;
    [CompilerGeneratedAttribute]
private static Func`2<<>f__AnonymousType1`2<<>f__AnonymousType0`2<KeyValuePair`2<MessageDescription, Dictionary`2<Type, ConstructorInfo>>, MessageDescription>, IEnumerable`1<ConstructorInfo>>, MessageDescription> CS$<>9__CachedAnonymousMethodDelegate13;
    [CompilerGeneratedAttribute]
private static Func`2<KeyValuePair`2<Type, ConstructorInfo>, ConstructorInfo> CS$<>9__CachedAnonymousMethodDelegate1e;
    public virtual void AddMessageTypes(IEnumerable`1<MessageDescription> messageTypes);
    public virtual IDirectedProtocolMessage GetNewRequestMessage(MessageReceivingEndpoint recipient, IDictionary`2<string, string> fields);
    public virtual IDirectResponseProtocolMessage GetNewResponseMessage(IDirectedProtocolMessage request, IDictionary`2<string, string> fields);
    protected virtual MessageDescription GetMessageDescription(MessageReceivingEndpoint recipient, IDictionary`2<string, string> fields);
    protected virtual MessageDescription GetMessageDescription(IDirectedProtocolMessage request, IDictionary`2<string, string> fields);
    protected virtual IDirectedProtocolMessage InstantiateAsRequest(MessageDescription messageDescription, MessageReceivingEndpoint recipient);
    protected virtual IDirectResponseProtocolMessage InstantiateAsResponse(MessageDescription messageDescription, IDirectedProtocolMessage request);
    private static int GetDerivationDistance(Type assignableType, Type derivedType);
    private static int CountInCommon(ICollection`1<string> collection1, ICollection`1<string> collection2, StringComparison comparison);
    private IEnumerable`1<ConstructorInfo> FindMatchingResponseConstructors(MessageDescription messageDescription, Type requestType);
    [CompilerGeneratedAttribute]
private static int <GetMessageDescription>b__2(MessageDescription message);
    [CompilerGeneratedAttribute]
private static <>f__AnonymousType0`2<KeyValuePair`2<MessageDescription, Dictionary`2<Type, ConstructorInfo>>, MessageDescription> <GetMessageDescription>b__8(KeyValuePair`2<MessageDescription, Dictionary`2<Type, ConstructorInfo>> responseMessageType);
    [CompilerGeneratedAttribute]
private static bool <GetMessageDescription>b__b(<>f__AnonymousType1`2<<>f__AnonymousType0`2<KeyValuePair`2<MessageDescription, Dictionary`2<Type, ConstructorInfo>>, MessageDescription>, IEnumerable`1<ConstructorInfo>> <>h__TransparentIdentifier7);
    [CompilerGeneratedAttribute]
private static int <GetMessageDescription>b__e(<>f__AnonymousType1`2<<>f__AnonymousType0`2<KeyValuePair`2<MessageDescription, Dictionary`2<Type, ConstructorInfo>>, MessageDescription>, IEnumerable`1<ConstructorInfo>> <>h__TransparentIdentifier7);
    [CompilerGeneratedAttribute]
private static MessageDescription <GetMessageDescription>b__f(<>f__AnonymousType1`2<<>f__AnonymousType0`2<KeyValuePair`2<MessageDescription, Dictionary`2<Type, ConstructorInfo>>, MessageDescription>, IEnumerable`1<ConstructorInfo>> <>h__TransparentIdentifier7);
    [CompilerGeneratedAttribute]
private static ConstructorInfo <FindMatchingResponseConstructors>b__1d(KeyValuePair`2<Type, ConstructorInfo> pair);
}
public abstract class DotNetOpenAuth.Messaging.StandardMessageFactoryChannel : Channel {
    private ICollection`1<Type> messageTypes;
    private ICollection`1<Version> versions;
    internal StandardMessageFactory StandardMessageFactory { get; internal set; }
    internal MessageDescriptionCollection MessageDescriptions { get; internal set; }
    protected IMessageFactory MessageFactory { get; protected set; }
    protected StandardMessageFactoryChannel(ICollection`1<Type> messageTypes, ICollection`1<Version> versions, IHostFactories hostFactories, IChannelBindingElement[] bindingElements);
    internal StandardMessageFactory get_StandardMessageFactory();
    internal void set_StandardMessageFactory(StandardMessageFactory value);
    internal sealed virtual MessageDescriptionCollection get_MessageDescriptions();
    internal sealed virtual void set_MessageDescriptions(MessageDescriptionCollection value);
    protected sealed virtual IMessageFactory get_MessageFactory();
    protected sealed virtual void set_MessageFactory(IMessageFactory value);
    private static IEnumerable`1<MessageDescription> GetMessageDescriptions(ICollection`1<Type> messageTypes, ICollection`1<Version> versions, MessageDescriptionCollection descriptionsCache);
}
internal class DotNetOpenAuth.Messaging.TimespanSecondsEncoder : object {
    public Type FormattingType { get; }
    public sealed virtual Type get_FormattingType();
    public sealed virtual string Encode(object value);
    public sealed virtual object Decode(string value);
}
internal class DotNetOpenAuth.Messaging.TimestampEncoder : object {
    internal static DateTime Epoch;
    private static TimestampEncoder();
    public sealed virtual string Encode(object value);
    public sealed virtual object Decode(string value);
}
internal class DotNetOpenAuth.Messaging.UnprotectedMessageException : ProtocolException {
    internal UnprotectedMessageException(IProtocolMessage faultedMessage, MessageProtections appliedProtection);
    protected UnprotectedMessageException(SerializationInfo info, StreamingContext context);
}
internal class DotNetOpenAuth.Messaging.UriStyleMessageFormatter`1 : DataBagFormatterBase`1<T> {
    protected internal UriStyleMessageFormatter`1(RSACryptoServiceProvider signingKey, RSACryptoServiceProvider encryptingKey, bool compressed, Nullable`1<TimeSpan> maximumAge, INonceStore decodeOnceOnly);
    protected internal UriStyleMessageFormatter`1(ICryptoKeyStore cryptoKeyStore, string bucket, bool signed, bool encrypted, bool compressed, Nullable`1<TimeSpan> minimumAge, Nullable`1<TimeSpan> maximumAge, INonceStore decodeOnceOnly);
    protected virtual Byte[] SerializeCore(T message);
    protected virtual void DeserializeCore(T message, Byte[] data);
}
public class DotNetOpenAuth.Reporting : object {
    private static Encoding Utf8NoPreamble;
    private static bool enabled;
    private static bool broken;
    private static bool initialized;
    private static object initializationSync;
    private static IsolatedStorageFile file;
    private static Guid reportOriginIdentity;
    private static Uri wellKnownPostLocation;
    private static PersistentHashSet observedRequests;
    private static PersistentHashSet observedCultures;
    private static PersistentHashSet observedFeatures;
    private static List`1<PersistentHashSet> observations;
    private static Dictionary`2<string, PersistentCounter> events;
    private static object publishingConsiderationLock;
    private static DateTime lastPublished;
    public static bool Enabled { get; public set; }
    internal static PersistentHashSet ObservedFeatures { get; }
    internal static ReportingElement Configuration { get; }
    private static Reporting();
    public static bool get_Enabled();
    public static void set_Enabled(bool value);
    internal static PersistentHashSet get_ObservedFeatures();
    internal static ReportingElement get_Configuration();
    internal static void RecordEventOccurrence(string eventName, string category);
    internal static void RecordEventOccurrence(object eventNameByObjectType, string category);
    internal static void RecordFeatureUse(string feature);
    internal static void RecordFeatureUse(object value);
    internal static void RecordFeatureAndDependencyUse(object value, object dependency1);
    internal static void RecordFeatureAndDependencyUse(object value, object dependency1, object dependency2);
    internal static void RecordRequestStatistics(HttpRequestBase request);
    protected static void Touch();
    private static void Initialize();
    private static HttpClient CreateHttpClient();
    private static Stream GetReport();
    [DebuggerStepThroughAttribute]
[AsyncStateMachineAttribute("DotNetOpenAuth.Reporting/<SendStatsAsync>d__8")]
private static Task`1<bool> SendStatsAsync();
    private static void DemuxLogMessage(string line);
    private static IsolatedStorageFile GetIsolatedStorage();
    private static Guid GetOrCreateOriginIdentity();
    private static string SanitizeFileName(string fileName);
}
internal static class DotNetOpenAuth.RequiresEx : object {
    [DebuggerStepThroughAttribute]
internal static void ValidState(bool condition);
    [DebuggerStepThroughAttribute]
internal static void ValidState(bool condition, string message);
    [DebuggerStepThroughAttribute]
internal static void ValidState(bool condition, string unformattedMessage, Object[] args);
    [DebuggerStepThroughAttribute]
internal static void NotNullSubtype(Type type, string parameterName);
    [DebuggerStepThroughAttribute]
internal static void Format(bool condition, string message);
    [DebuggerStepThroughAttribute]
internal static void Support(bool condition, string message);
}
[GeneratedCodeAttribute("System.Resources.Tools.StronglyTypedResourceBuilder", "4.0.0.0")]
[DebuggerNonUserCodeAttribute]
[CompilerGeneratedAttribute]
internal class DotNetOpenAuth.Strings : object {
    private static ResourceManager resourceMan;
    private static CultureInfo resourceCulture;
    [EditorBrowsableAttribute("2")]
internal static ResourceManager ResourceManager { get; }
    [EditorBrowsableAttribute("2")]
internal static CultureInfo Culture { get; internal set; }
    internal static string ConfigurationTypeMustBePublic { get; }
    internal static string ConfigurationXamlReferenceRequiresHttpContext { get; }
    internal static string EmbeddedResourceUrlProviderRequired { get; }
    internal static string EmptyStringNotAllowed { get; }
    internal static string Generic_CryptoFailure { get; }
    internal static string HostFactoriesRequired { get; }
    internal static string InvalidArgument { get; }
    internal static string RequiredPropertyNotYetPreset { get; }
    internal static string ResponseBodyNotSupported { get; }
    internal static string StoreRequiredWhenNoHttpContextAvailable { get; }
    internal static ResourceManager get_ResourceManager();
    internal static CultureInfo get_Culture();
    internal static void set_Culture(CultureInfo value);
    internal static string get_ConfigurationTypeMustBePublic();
    internal static string get_ConfigurationXamlReferenceRequiresHttpContext();
    internal static string get_EmbeddedResourceUrlProviderRequired();
    internal static string get_EmptyStringNotAllowed();
    internal static string get_Generic_CryptoFailure();
    internal static string get_HostFactoriesRequired();
    internal static string get_InvalidArgument();
    internal static string get_RequiredPropertyNotYetPreset();
    internal static string get_ResponseBodyNotSupported();
    internal static string get_StoreRequiredWhenNoHttpContextAvailable();
}
[ExtensionAttribute]
internal static class DotNetOpenAuth.UriUtil : object {
    [CompilerGeneratedAttribute]
private static MatchEvaluator CS$<>9__CachedAnonymousMethodDelegate4;
    [ExtensionAttribute]
internal static bool QueryStringContainPrefixedParameters(Uri uri, string prefix);
    [ExtensionAttribute]
internal static bool IsTransportSecure(Uri uri);
    [ExtensionAttribute]
internal static string ToStringWithImpliedPorts(UriBuilder builder);
    internal static void ValidateResolvableUrl(Page page, bool designMode, string value);
    [CompilerGeneratedAttribute]
private static string <ToStringWithImpliedPorts>b__3(Match m);
}
[ExtensionAttribute]
internal static class DotNetOpenAuth.Util : object {
    internal static string DefaultNamespace;
    private static Lazy`1<string> libraryVersionLazy;
    private static Lazy`1<ProductInfoHeaderValue> libraryVersionHeaderLazy;
    private static IEmbeddedResourceRetrieval embeddedResourceRetrieval;
    [CompilerGeneratedAttribute]
private static Func`1<string> CS$<>9__CachedAnonymousMethodDelegatef;
    [CompilerGeneratedAttribute]
private static Func`1<ProductInfoHeaderValue> CS$<>9__CachedAnonymousMethodDelegate10;
    internal static string LibraryVersion { get; }
    internal static ProductInfoHeaderValue LibraryVersionHeader { get; }
    internal static string AssemblyFileVersion { get; }
    private static Util();
    internal static string get_LibraryVersion();
    internal static ProductInfoHeaderValue get_LibraryVersionHeader();
    internal static string get_AssemblyFileVersion();
    [ExtensionAttribute]
internal static bool EqualsNullSafe(T first, T second);
    [ExtensionAttribute]
internal static object ToStringDeferred(IEnumerable`1<KeyValuePair`2<K, V>> pairs);
    [ExtensionAttribute]
internal static object ToStringDeferred(IEnumerable`1<T> list);
    [ExtensionAttribute]
internal static object ToStringDeferred(IEnumerable`1<T> list, bool multiLineElements);
    internal static string GetWebResourceUrl(Type someTypeInResourceAssembly, string manifestResourceName);
    [ExtensionAttribute]
[AsyncStateMachineAttribute("DotNetOpenAuth.Util/<ToDictionaryAsync>d__9`2")]
[DebuggerStepThroughAttribute]
internal static Task`1<Dictionary`2<TSource, TResult>> ToDictionaryAsync(IEnumerable`1<TSource> source, Func`2<TSource, Task`1<TResult>> transform);
    [CompilerGeneratedAttribute]
private static TSource <ToDictionaryAsync>b__6(TSource s);
    [CompilerGeneratedAttribute]
private static TSource <ToDictionaryAsync>b__7(KeyValuePair`2<TSource, Task`1<TResult>> p);
    [CompilerGeneratedAttribute]
private static TResult <ToDictionaryAsync>b__8(KeyValuePair`2<TSource, Task`1<TResult>> p);
    [CompilerGeneratedAttribute]
private static string <.cctor>b__d();
    [CompilerGeneratedAttribute]
private static ProductInfoHeaderValue <.cctor>b__e();
}
internal class ThisAssembly : object {
    internal static string AssemblyVersion;
    internal static string AssemblyFileVersion;
    internal static string AssemblyInformationalVersion;
    internal static string AssemblyTitle;
    internal static string AssemblyProduct;
}
