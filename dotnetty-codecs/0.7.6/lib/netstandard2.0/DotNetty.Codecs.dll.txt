public static class DotNetty.Codecs.Base64.Base64 : object {
    private static int MAX_LINE_LENGTH;
    private static byte EQUALS_SIGN;
    private static byte NEW_LINE;
    private static sbyte WHITE_SPACE_ENC;
    private static sbyte EQUALS_SIGN_ENC;
    public static IByteBuffer Encode(IByteBuffer src);
    public static IByteBuffer Encode(IByteBuffer src, Base64Dialect dialect);
    public static IByteBuffer Encode(IByteBuffer src, bool breakLines, Base64Dialect dialect);
    public static IByteBuffer Encode(IByteBuffer src, int offset, int length, bool breakLines, Base64Dialect dialect);
    private static int EncodeUsingPointer(Byte* alphabet, IByteBuffer src, IByteBuffer dest, int offset, int length, bool breakLines);
    private static int EncodeUsingGetSet(Byte* alphabet, IByteBuffer src, IByteBuffer dest, int offset, int length, bool breakLines);
    public static IByteBuffer Encode(IByteBuffer src, int offset, int length, bool breakLines, Base64Dialect dialect, IByteBufferAllocator allocator);
    public static IByteBuffer Decode(IByteBuffer src);
    public static IByteBuffer Decode(IByteBuffer src, Base64Dialect dialect);
    public static IByteBuffer Decode(IByteBuffer src, int offset, int length, Base64Dialect dialect);
    private static int DecodeUsingPointer(IByteBuffer src, IByteBuffer dest, SByte* decodabet, int offset, int length);
    private static int DecodeUsingGetSet(IByteBuffer src, IByteBuffer dest, SByte* decodabet, int offset, int length);
    public static IByteBuffer Decode(IByteBuffer src, int offset, int length, Base64Dialect dialect, IByteBufferAllocator allocator);
}
public class DotNetty.Codecs.Base64.Base64Decoder : MessageToMessageDecoder`1<IByteBuffer> {
    private Base64Dialect dialect;
    public bool IsSharable { get; }
    public Base64Decoder(Base64Dialect dialect);
    protected internal virtual void Decode(IChannelHandlerContext context, IByteBuffer message, List`1<object> output);
    public virtual bool get_IsSharable();
}
public class DotNetty.Codecs.Base64.Base64Dialect : ValueType {
    public static Base64Dialect STANDARD;
    public static Base64Dialect URL_SAFE;
    public Byte[] alphabet;
    public SByte[] decodabet;
    public bool breakLinesByDefault;
    private Base64Dialect(Byte[] alphabet, SByte[] decodabet, bool breakLinesByDefault);
    private static Base64Dialect();
}
public class DotNetty.Codecs.Base64.Base64Encoder : MessageToMessageDecoder`1<IByteBuffer> {
    private bool breakLines;
    private Base64Dialect dialect;
    public bool IsSharable { get; }
    public Base64Encoder(bool breakLines);
    public Base64Encoder(bool breakLines, Base64Dialect dialect);
    protected internal virtual void Decode(IChannelHandlerContext context, IByteBuffer message, List`1<object> output);
    public virtual bool get_IsSharable();
}
public abstract class DotNetty.Codecs.ByteToMessageDecoder : ChannelHandlerAdapter {
    public static CumulationFunc MergeCumulator;
    public static CumulationFunc CompositionCumulation;
    private IByteBuffer cumulation;
    private CumulationFunc cumulator;
    private bool decodeWasNull;
    private bool first;
    [CompilerGeneratedAttribute]
private bool <SingleDecode>k__BackingField;
    public bool SingleDecode { get; public set; }
    protected int ActualReadableBytes { get; }
    protected IByteBuffer InternalBuffer { get; }
    private static ByteToMessageDecoder();
    [CompilerGeneratedAttribute]
public bool get_SingleDecode();
    [CompilerGeneratedAttribute]
public void set_SingleDecode(bool value);
    public void SetCumulator(CumulationFunc cumulationFunc);
    protected int get_ActualReadableBytes();
    protected IByteBuffer get_InternalBuffer();
    protected internal abstract virtual void Decode(IChannelHandlerContext context, IByteBuffer input, List`1<object> output);
    private static IByteBuffer ExpandCumulation(IByteBufferAllocator allocator, IByteBuffer cumulation, int readable);
    public virtual void HandlerRemoved(IChannelHandlerContext context);
    protected virtual void HandlerRemovedInternal(IChannelHandlerContext context);
    public virtual void ChannelRead(IChannelHandlerContext context, object message);
    public virtual void ChannelReadComplete(IChannelHandlerContext context);
    protected void DiscardSomeReadBytes();
    public virtual void ChannelInactive(IChannelHandlerContext ctx);
    protected virtual void CallDecode(IChannelHandlerContext context, IByteBuffer input, List`1<object> output);
    protected virtual void DecodeLast(IChannelHandlerContext context, IByteBuffer input, List`1<object> output);
}
public class DotNetty.Codecs.CharSequenceValueConverter : object {
    public static CharSequenceValueConverter Default;
    private static AsciiString TrueAscii;
    private static CharSequenceValueConverter();
    public virtual ICharSequence ConvertObject(object value);
    public sealed virtual ICharSequence ConvertInt(int value);
    public sealed virtual ICharSequence ConvertLong(long value);
    public sealed virtual ICharSequence ConvertDouble(double value);
    public sealed virtual ICharSequence ConvertChar(char value);
    public sealed virtual ICharSequence ConvertBoolean(bool value);
    public sealed virtual ICharSequence ConvertFloat(float value);
    public sealed virtual bool ConvertToBoolean(ICharSequence value);
    public sealed virtual ICharSequence ConvertByte(byte value);
    public sealed virtual byte ConvertToByte(ICharSequence value);
    public sealed virtual char ConvertToChar(ICharSequence value);
    public sealed virtual ICharSequence ConvertShort(short value);
    public sealed virtual short ConvertToShort(ICharSequence value);
    public sealed virtual int ConvertToInt(ICharSequence value);
    public sealed virtual long ConvertToLong(ICharSequence value);
    public sealed virtual ICharSequence ConvertTimeMillis(long value);
    public sealed virtual long ConvertToTimeMillis(ICharSequence value);
    public sealed virtual float ConvertToFloat(ICharSequence value);
    public sealed virtual double ConvertToDouble(ICharSequence value);
}
public class DotNetty.Codecs.CodecException : Exception {
    public CodecException(string message, Exception innereException);
    public CodecException(string message);
    public CodecException(Exception innerException);
}
internal class DotNetty.Codecs.Compression.Adler32 : object {
    private static int BASE;
    private static int NMAX;
    private long s1;
    private long s2;
    public sealed virtual void Reset(long init);
    public sealed virtual void Reset();
    public sealed virtual long GetValue();
    public sealed virtual void Update(Byte[] buf, int index, int len);
    public sealed virtual IChecksum Copy();
    internal static long Combine(long adler1, long adler2, long len2);
}
public class DotNetty.Codecs.Compression.CompressionException : EncoderException {
    public CompressionException(string message);
    public CompressionException(string message, Exception exception);
}
internal class DotNetty.Codecs.Compression.CRC32 : object {
    private int v;
    private static Int32[] crc_table;
    private static int GF2_DIM;
    private static CRC32();
    public sealed virtual void Update(Byte[] buf, int index, int len);
    public sealed virtual void Reset();
    public sealed virtual void Reset(long vv);
    public sealed virtual long GetValue();
    internal static long Combine(long crc1, long crc2, long len2);
    private static long gf2_matrix_times(Int64[] mat, long vec);
    private static void gf2_matrix_square(Int64[] square, Int64[] mat);
    public sealed virtual IChecksum Copy();
    public static Int32[] getCRC32Table();
}
public class DotNetty.Codecs.Compression.DecompressionException : DecoderException {
    public DecompressionException(string message);
    public DecompressionException(string message, Exception exception);
}
internal class DotNetty.Codecs.Compression.Deflate : object {
    private static int MAX_MEM_LEVEL;
    private static int Z_DEFAULT_COMPRESSION;
    private static int MAX_WBITS;
    private static int DEF_MEM_LEVEL;
    private static int STORED;
    private static int FAST;
    private static int SLOW;
    private static Config[] config_table;
    private static String[] z_errmsg;
    private static int NeedMore;
    private static int BlockDone;
    private static int FinishStarted;
    private static int FinishDone;
    private static int PRESET_DICT;
    private static int Z_FILTERED;
    private static int Z_HUFFMAN_ONLY;
    private static int Z_DEFAULT_STRATEGY;
    private static int Z_NO_FLUSH;
    private static int Z_PARTIAL_FLUSH;
    private static int Z_FULL_FLUSH;
    private static int Z_FINISH;
    private static int Z_OK;
    private static int Z_STREAM_END;
    private static int Z_NEED_DICT;
    private static int Z_STREAM_ERROR;
    private static int Z_DATA_ERROR;
    private static int Z_BUF_ERROR;
    private static int INIT_STATE;
    private static int BUSY_STATE;
    private static int FINISH_STATE;
    private static int Z_DEFLATED;
    private static int STORED_BLOCK;
    private static int STATIC_TREES;
    private static int DYN_TREES;
    private static int Z_BINARY;
    private static int Z_ASCII;
    private static int Z_UNKNOWN;
    private static int Buf_size;
    private static int REP_3_6;
    private static int REPZ_3_10;
    private static int REPZ_11_138;
    private static int MIN_MATCH;
    private static int MAX_MATCH;
    private static int MIN_LOOKAHEAD;
    private static int MAX_BITS;
    private static int D_CODES;
    private static int BL_CODES;
    private static int LENGTH_CODES;
    private static int LITERALS;
    private static int L_CODES;
    private static int HEAP_SIZE;
    private static int END_BLOCK;
    private ZStream strm;
    private int status;
    internal Byte[] pending_buf;
    private int pending_buf_size;
    internal int pending_out;
    internal int pending;
    internal int wrap;
    private byte data_type;
    private byte method;
    private int last_flush;
    private int w_size;
    private int w_bits;
    private int w_mask;
    private Byte[] window;
    private int window_size;
    private Int16[] prev;
    private Int16[] head;
    private int ins_h;
    private int hash_size;
    private int hash_bits;
    private int hash_mask;
    private int hash_shift;
    private int block_start;
    private int match_length;
    private int prev_match;
    private int match_available;
    private int strstart;
    private int match_start;
    private int lookahead;
    private int prev_length;
    private int max_chain_length;
    private int max_lazy_match;
    internal int level;
    private int strategy;
    private int good_match;
    private int nice_match;
    private Int16[] dyn_ltree;
    private Int16[] dyn_dtree;
    private Int16[] bl_tree;
    private Tree l_desc;
    private Tree d_desc;
    private Tree bl_desc;
    internal Int16[] bl_count;
    internal Int16[] next_code;
    internal Int32[] heap;
    internal int heap_len;
    internal int heap_max;
    internal Byte[] depth;
    private Byte[] l_buf;
    private int lit_bufsize;
    private int last_lit;
    private int d_buf;
    internal int opt_len;
    internal int static_len;
    private int matches;
    private int last_eob_len;
    private short bi_buf;
    private int bi_valid;
    private GZIPHeader gheader;
    private static Deflate();
    internal Deflate(ZStream strm);
    private void Lm_init();
    private void Tr_init();
    private void Init_block();
    internal void Pqdownheap(Int16[] tree, int k);
    private static bool Smaller(Int16[] tree, int n, int m, Byte[] depth);
    private void Scan_tree(Int16[] tree, int max_code);
    private int Build_bl_tree();
    private void Send_all_trees(int lcodes, int dcodes, int blcodes);
    private void Send_tree(Int16[] tree, int max_code);
    internal void Put_byte(Byte[] p, int start, int len);
    internal void Put_byte(byte c);
    internal void Put_short(int w);
    private void PutShortMSB(int b);
    private void Send_code(int c, Int16[] tree);
    private void Send_bits(int value, int length);
    private void _tr_align();
    private bool _tr_tally(int dist, int lc);
    private void Compress_block(Int16[] ltree, Int16[] dtree);
    private void Set_data_type();
    private void Bi_flush();
    private void Bi_windup();
    private void Copy_block(int buf, int len, bool header);
    private void Flush_block_only(bool eof);
    private int Deflate_stored(int flush);
    private void _tr_stored_block(int buf, int stored_len, bool eof);
    private void _tr_flush_block(int buf, int stored_len, bool eof);
    private void Fill_window();
    private int Deflate_fast(int flush);
    private int Deflate_slow(int flush);
    private int Longest_match(int cur_match);
    internal int DeflateInit(int level, int bits, int memlevel);
    internal int DeflateInit(int level, int bits);
    internal int DeflateInit(int level);
    private int DeflateInit(int level, int method, int windowBits, int memLevel, int strategy);
    private int DeflateReset();
    internal int DeflateEnd();
    internal int DeflateParams(int _level, int _strategy);
    internal int DeflateSetDictionary(Byte[] dictionary, int dictLength);
    internal int Deflate_D(int flush);
    internal static int DeflateCopy(ZStream dest, ZStream src);
    public Deflate Clone(ZStream z);
    private static Byte[] Dup(Byte[] buf);
    private static Int16[] Dup(Int16[] buf);
    private static Int32[] Dup(Int32[] buf);
    private GZIPHeader GetGZIPHeader();
}
internal class DotNetty.Codecs.Compression.Deflater : ZStream {
    private static int MAX_WBITS;
    private static int Z_OK;
    private static int Z_STREAM_END;
    private static int Z_STREAM_ERROR;
    private bool finished;
    public Deflater(int level);
    public Deflater(int level, bool nowrap);
    public Deflater(int level, int bits);
    public Deflater(int level, int bits, bool nowrap);
    public Deflater(int level, int bits, int memlevel, WrapperType wrapperType);
    public Deflater(int level, int bits, int memlevel);
    public int Init(int level);
    public int Init(int level, bool nowrap);
    public int Init(int level, int bits);
    public int Init(int level, int bits, int memlevel, WrapperType wrapperType);
    public int Init(int level, int bits, int memlevel);
    public int Init(int level, int bits, bool nowrap);
    public int Deflate(int flush);
    public virtual int End();
    public int Params(int level, int strategy);
    public int SetDictionary(Byte[] dictionary, int dictLength);
    public virtual bool Finished();
    public int Copy(Deflater src);
}
public class DotNetty.Codecs.Compression.GZIPException : IOException {
    public GZIPException(string s);
}
internal class DotNetty.Codecs.Compression.GZIPHeader : object {
    private static Encoding ISOEncoding;
    private static byte Platform;
    public static byte OS_MSDOS;
    public static byte OS_AMIGA;
    public static byte OS_VMS;
    public static byte OS_UNIX;
    public static byte OS_ATARI;
    public static byte OS_OS2;
    public static byte OS_MACOS;
    public static byte OS_TOPS20;
    public static byte OS_WIN32;
    public static byte OS_VMCMS;
    public static byte OS_ZSYSTEM;
    public static byte OS_CPM;
    public static byte OS_QDOS;
    public static byte OS_RISCOS;
    public static byte OS_UNKNOWN;
    private bool text;
    private bool fhcrc;
    internal long time;
    internal int xflags;
    internal int os;
    internal Byte[] extra;
    internal Byte[] name;
    internal Byte[] comment;
    internal int hcrc;
    internal long crc;
    private long mtime;
    private static GZIPHeader();
    public void SetModifiedTime(long value);
    public long GetModifiedTime();
    public void SetOS(int value);
    public int GetOS();
    public void SetName(string value);
    public string GetName();
    public void SetComment(string value);
    public string GetComment();
    public void SetCRC(long value);
    public long GetCRC();
    internal void Put(Deflate d);
    public GZIPHeader Clone();
}
internal interface DotNetty.Codecs.Compression.IChecksum {
    public abstract virtual void Update(Byte[] buf, int index, int len);
    public abstract virtual void Reset();
    public abstract virtual void Reset(long init);
    public abstract virtual long GetValue();
    public abstract virtual IChecksum Copy();
}
internal class DotNetty.Codecs.Compression.InfBlocks : object {
    private static int MANY;
    private static Int32[] inflate_mask;
    private static Int32[] border;
    private static int Z_OK;
    private static int Z_STREAM_END;
    private static int Z_STREAM_ERROR;
    private static int Z_DATA_ERROR;
    private static int Z_BUF_ERROR;
    private static int TYPE;
    private static int LENS;
    private static int STORED;
    private static int TABLE;
    private static int BTREE;
    private static int DTREE;
    private static int CODES;
    private static int DRY;
    private static int DONE;
    private static int BAD;
    private int mode;
    private int left;
    private int table;
    private int index;
    private Int32[] blens;
    private Int32[] bb;
    private Int32[] tb;
    private Int32[] bl;
    private Int32[] bd;
    private Int32[][] tl;
    private Int32[][] td;
    private Int32[] tli;
    private Int32[] tdi;
    private InfCodes codes;
    private int last;
    internal int bitk;
    internal int bitb;
    internal Int32[] hufts;
    internal Byte[] window;
    internal int end;
    internal int read;
    internal int write;
    private bool check;
    private InfTree inftree;
    private ZStream z;
    internal InfBlocks(ZStream z, int w);
    private static InfBlocks();
    internal void Reset();
    internal int Proc(int r);
    internal void Free();
    internal void Set_dictionary(Byte[] d, int start, int n);
    internal int Sync_point();
    internal int Inflate_flush(int r);
}
internal class DotNetty.Codecs.Compression.InfCodes : object {
    private static Int32[] inflate_mask;
    private static int Z_OK;
    private static int Z_STREAM_END;
    private static int Z_STREAM_ERROR;
    private static int Z_DATA_ERROR;
    private static int START;
    private static int LEN;
    private static int LENEXT;
    private static int DIST;
    private static int DISTEXT;
    private static int COPY;
    private static int LIT;
    private static int WASH;
    private static int END;
    private static int BADCODE;
    private int mode;
    private int len;
    private Int32[] tree;
    private int tree_index;
    private int need;
    private int lit;
    private int get;
    private int dist;
    private byte lbits;
    private byte dbits;
    private Int32[] ltree;
    private int ltree_index;
    private Int32[] dtree;
    private int dtree_index;
    private ZStream z;
    private InfBlocks s;
    internal InfCodes(ZStream z, InfBlocks s);
    private static InfCodes();
    internal void Init(int bl, int bd, Int32[] tl, int tl_index, Int32[] td, int td_index);
    internal int Proc(int r);
    internal void Free(ZStream z);
    private static int Inflate_fast(int bl, int bd, Int32[] tl, int tl_index, Int32[] td, int td_index, InfBlocks s, ZStream z);
}
internal class DotNetty.Codecs.Compression.Inflate : object {
    private static int PRESET_DICT;
    private static int Z_FINISH;
    private static int Z_DEFLATED;
    private static int Z_OK;
    private static int Z_STREAM_END;
    private static int Z_NEED_DICT;
    private static int Z_STREAM_ERROR;
    private static int Z_DATA_ERROR;
    private static int Z_BUF_ERROR;
    private static int DICT4;
    private static int DICT3;
    private static int DICT2;
    private static int DICT1;
    private static int DICT0;
    private static int BLOCKS;
    private static int CHECK4;
    private static int CHECK3;
    private static int CHECK2;
    private static int CHECK1;
    private static int DONE;
    private static int BAD;
    private static int HEAD;
    private static int LENGTH;
    private static int TIME;
    private static int OS;
    private static int EXLEN;
    private static int EXTRA;
    private static int NAME;
    private static int COMMENT;
    private static int HCRC;
    private static int FLAGS;
    internal static int INFLATE_ANY;
    internal int mode;
    private int method;
    private long was;
    private long need;
    private int marker;
    internal int wrap;
    private int wbits;
    private InfBlocks blocks;
    private ZStream z;
    private int flags;
    private int need_bytes;
    private Byte[] crcbuf;
    private GZIPHeader gheader;
    private static Byte[] mark;
    private MemoryStream tmp_string;
    internal Inflate(ZStream z);
    private static Inflate();
    internal int InflateReset();
    internal int InflateEnd();
    internal int InflateInit(int w);
    internal int Inflate_I(int f);
    internal int InflateSetDictionary(Byte[] dictionary, int dictLength);
    internal int InflateSync();
    internal int InflateSyncPoint();
    private int ReadBytes(int n, int r, int f);
    private int ReadString(int r, int f);
    private int ReadBytes(int r, int f);
    private void Checksum(int n, long v);
    public GZIPHeader getGZIPHeader();
    internal bool InParsingHeader();
}
internal class DotNetty.Codecs.Compression.Inflater : ZStream {
    private static int MAX_WBITS;
    private static int DEF_WBITS;
    private static int Z_OK;
    private static int Z_STREAM_ERROR;
    public Inflater(WrapperType wrapperType);
    public Inflater(int w, WrapperType wrapperType);
    public Inflater(int w);
    public Inflater(bool nowrap);
    public Inflater(int w, bool nowrap);
    public int Init();
    public int Init(WrapperType wrapperType);
    public int Init(int w, WrapperType wrapperType);
    public int Init(bool nowrap);
    public int Init(int w);
    public int Init(int w, bool nowrap);
    public int Inflate(int f);
    public virtual int End();
    public int Sync();
    public int SyncPoint();
    public int SetDictionary(Byte[] dictionary, int dictLength);
    public virtual bool Finished();
}
internal class DotNetty.Codecs.Compression.InfTree : object {
    private static int MANY;
    private static int Z_OK;
    private static int Z_DATA_ERROR;
    private static int Z_MEM_ERROR;
    private static int Z_BUF_ERROR;
    private static int fixed_bl;
    private static int fixed_bd;
    private static Int32[] fixed_tl;
    private static Int32[] fixed_td;
    private static Int32[] cplens;
    private static Int32[] cplext;
    private static Int32[] cpdist;
    private static Int32[] cpdext;
    private static int BMAX;
    private Int32[] hn;
    private Int32[] v;
    private Int32[] c;
    private Int32[] r;
    private Int32[] u;
    private Int32[] x;
    private static InfTree();
    private int Huft_build(Int32[] b, int bindex, int n, int s, Int32[] d, Int32[] e, Int32[] t, Int32[] m, Int32[] hp, Int32[] hn, Int32[] v);
    internal int Inflate_trees_bits(Int32[] c, Int32[] bb, Int32[] tb, Int32[] hp, ZStream z);
    internal int Inflate_trees_dynamic(int nl, int nd, Int32[] c, Int32[] bl, Int32[] bd, Int32[] tl, Int32[] td, Int32[] hp, ZStream z);
    internal static int Inflate_trees_fixed(Int32[] bl, Int32[] bd, Int32[][] tl, Int32[][] td, ZStream z);
    private void InitWorkArea(int vsize);
}
public class DotNetty.Codecs.Compression.JZlib : object {
    private static string VersionString;
    public static int MAX_WBITS;
    public static int DEF_WBITS;
    public static WrapperType W_NONE;
    public static WrapperType W_ZLIB;
    public static WrapperType W_GZIP;
    public static WrapperType W_ANY;
    public static int Z_NO_COMPRESSION;
    public static int Z_BEST_SPEED;
    public static int Z_BEST_COMPRESSION;
    public static int Z_DEFAULT_COMPRESSION;
    public static int Z_FILTERED;
    public static int Z_HUFFMAN_ONLY;
    public static int Z_DEFAULT_STRATEGY;
    public static int Z_NO_FLUSH;
    public static int Z_PARTIAL_FLUSH;
    public static int Z_SYNC_FLUSH;
    public static int Z_FULL_FLUSH;
    public static int Z_FINISH;
    public static int Z_OK;
    public static int Z_STREAM_END;
    public static int Z_NEED_DICT;
    public static int Z_ERRNO;
    public static int Z_STREAM_ERROR;
    public static int Z_DATA_ERROR;
    public static int Z_MEM_ERROR;
    public static int Z_BUF_ERROR;
    public static int Z_VERSION_ERROR;
    public static byte Z_BINARY;
    public static byte Z_ASCII;
    public static byte Z_UNKNOWN;
    private static JZlib();
    public static string Version();
    public static long Adler32_combine(long adler1, long adler2, long len2);
}
public class DotNetty.Codecs.Compression.JZlibDecoder : ZlibDecoder {
    private Inflater z;
    private Byte[] dictionary;
    private Boolean modreq(System.Runtime.CompilerServices.IsVolatile) finished;
    public bool IsClosed { get; }
    public JZlibDecoder(ZlibWrapper wrapper);
    public JZlibDecoder(Byte[] dictionary);
    public virtual bool get_IsClosed();
    protected internal virtual void Decode(IChannelHandlerContext context, IByteBuffer input, List`1<object> output);
}
public class DotNetty.Codecs.Compression.JZlibEncoder : ZlibEncoder {
    private int wrapperOverhead;
    private Deflater z;
    private Boolean modreq(System.Runtime.CompilerServices.IsVolatile) finished;
    private IChannelHandlerContext modreq(System.Runtime.CompilerServices.IsVolatile) ctx;
    public bool IsClosed { get; }
    public JZlibEncoder(int compressionLevel);
    public JZlibEncoder(ZlibWrapper wrapper);
    public JZlibEncoder(ZlibWrapper wrapper, int compressionLevel);
    public JZlibEncoder(ZlibWrapper wrapper, int compressionLevel, int windowBits, int memLevel);
    public JZlibEncoder(Byte[] dictionary);
    public JZlibEncoder(int compressionLevel, Byte[] dictionary);
    public JZlibEncoder(int compressionLevel, int windowBits, int memLevel, Byte[] dictionary);
    public virtual Task CloseAsync();
    public virtual Task CloseAsync(IChannelHandlerContext context);
    private IChannelHandlerContext CurrentContext();
    public virtual bool get_IsClosed();
    protected virtual void Encode(IChannelHandlerContext context, IByteBuffer message, IByteBuffer output);
    private Task FinishEncode(IChannelHandlerContext context);
    public virtual void HandlerAdded(IChannelHandlerContext context);
}
internal class DotNetty.Codecs.Compression.StaticTree : object {
    private static int MAX_BITS;
    private static int BL_CODES;
    private static int D_CODES;
    private static int LITERALS;
    private static int LENGTH_CODES;
    private static int L_CODES;
    private static int MAX_BL_BITS;
    internal static Int16[] static_ltree;
    internal static Int16[] static_dtree;
    internal static StaticTree static_l_desc;
    internal static StaticTree static_d_desc;
    internal static StaticTree static_bl_desc;
    internal Int16[] static_tree;
    internal Int32[] extra_bits;
    internal int extra_base;
    internal int elems;
    internal int max_length;
    private StaticTree(Int16[] static_tree, Int32[] extra_bits, int extra_base, int elems, int max_length);
    private static StaticTree();
}
internal class DotNetty.Codecs.Compression.Tree : object {
    private static int MAX_BITS;
    private static int LITERALS;
    private static int LENGTH_CODES;
    private static int L_CODES;
    private static int HEAP_SIZE;
    internal static int MAX_BL_BITS;
    internal static int END_BLOCK;
    internal static int REP_3_6;
    internal static int REPZ_3_10;
    internal static int REPZ_11_138;
    internal static Int32[] extra_lbits;
    internal static Int32[] extra_dbits;
    internal static Int32[] extra_blbits;
    internal static Byte[] bl_order;
    internal static int Buf_size;
    internal static int DIST_CODE_LEN;
    private static Byte[] _dist_code;
    internal static Byte[] _length_code;
    internal static Int32[] base_length;
    internal static Int32[] base_dist;
    internal Int16[] dyn_tree;
    internal int max_code;
    internal StaticTree stat_desc;
    private static Tree();
    internal static int D_code(int dist);
    private void Gen_bitlen(Deflate s);
    internal void Build_tree(Deflate s);
    private static void Gen_codes(Int16[] tree, int max_code, Int16[] bl_count, Int16[] next_code);
    private static int Bi_reverse(int code, int len);
}
public static class DotNetty.Codecs.Compression.ZlibCodecFactory : object {
    public static bool IsSupportingWindowSizeAndMemLevel { get; }
    public static bool get_IsSupportingWindowSizeAndMemLevel();
    public static ZlibEncoder NewZlibEncoder(int compressionLevel);
    public static ZlibEncoder NewZlibEncoder(ZlibWrapper wrapper);
    public static ZlibEncoder NewZlibEncoder(ZlibWrapper wrapper, int compressionLevel);
    public static ZlibEncoder NewZlibEncoder(ZlibWrapper wrapper, int compressionLevel, int windowBits, int memLevel);
    public static ZlibEncoder NewZlibEncoder(Byte[] dictionary);
    public static ZlibEncoder NewZlibEncoder(int compressionLevel, Byte[] dictionary);
    public static ZlibEncoder NewZlibEncoder(int compressionLevel, int windowBits, int memLevel, Byte[] dictionary);
    public static ZlibDecoder NewZlibDecoder();
    public static ZlibDecoder NewZlibDecoder(ZlibWrapper wrapper);
    public static ZlibDecoder NewZlibDecoder(Byte[] dictionary);
}
public abstract class DotNetty.Codecs.Compression.ZlibDecoder : ByteToMessageDecoder {
    public bool IsClosed { get; }
    public abstract virtual bool get_IsClosed();
}
public abstract class DotNetty.Codecs.Compression.ZlibEncoder : MessageToByteEncoder`1<IByteBuffer> {
    public bool IsClosed { get; }
    public abstract virtual bool get_IsClosed();
    public abstract virtual Task CloseAsync();
}
internal static class DotNetty.Codecs.Compression.ZlibUtil : object {
    public static void Fail(Inflater z, string message, int resultCode);
    public static void Fail(Deflater z, string message, int resultCode);
    public static WrapperType ConvertWrapperType(ZlibWrapper wrapper);
    public static int WrapperOverhead(ZlibWrapper wrapper);
}
public enum DotNetty.Codecs.Compression.ZlibWrapper : Enum {
    public int value__;
    public static ZlibWrapper Zlib;
    public static ZlibWrapper Gzip;
    public static ZlibWrapper None;
    public static ZlibWrapper ZlibOrNone;
}
internal class DotNetty.Codecs.Compression.ZStream : object {
    private static int MAX_WBITS;
    private static int DEF_WBITS;
    private static int Z_OK;
    private static int Z_STREAM_ERROR;
    public Byte[] next_in;
    public int next_in_index;
    public int avail_in;
    public long total_in;
    public Byte[] next_out;
    public int next_out_index;
    public int avail_out;
    public long total_out;
    public string msg;
    internal Deflate dstate;
    internal Inflate istate;
    internal int data_type;
    internal IChecksum adler;
    protected ZStream(IChecksum adler);
    internal int InflateInit();
    internal int InflateInit(bool nowrap);
    internal int InflateInit(int w);
    internal int InflateInit(WrapperType wrapperType);
    internal int InflateInit(int w, WrapperType wrapperType);
    internal int InflateInit(int w, bool nowrap);
    internal int Inflate_z(int f);
    internal int InflateEnd();
    internal int InflateSync();
    internal int InflateSyncPoint();
    internal int InflateSetDictionary(Byte[] dictionary, int dictLength);
    internal bool InflateFinished();
    internal int DeflateInit(int level);
    internal int DeflateInit(int level, bool nowrap);
    internal int DeflateInit(int level, int bits);
    internal int DeflateInit(int level, int bits, int memlevel, WrapperType wrapperType);
    internal int DeflateInit(int level, int bits, int memlevel);
    internal int DeflateInit(int level, int bits, bool nowrap);
    internal int Deflate_z(int flush);
    internal int DeflateEnd();
    internal int DeflateParams(int level, int strategy);
    internal int DeflateSetDictionary(Byte[] dictionary, int dictLength);
    internal void Flush_pending();
    internal int Read_buf(Byte[] buf, int start, int size);
    internal long GetAdler();
    internal void Free();
    internal void SetOutput(Byte[] buf);
    internal void SetOutput(Byte[] buf, int off, int len);
    internal void SetInput(Byte[] buf);
    internal void SetInput(Byte[] buf, bool append);
    internal void SetInput(Byte[] buf, int off, int len, bool append);
    internal Byte[] GetNextIn();
    internal void SetNextIn(Byte[] next_in_value);
    internal int GetNextInIndex();
    internal void SetNextInIndex(int next_in_index_value);
    internal int GetAvailIn();
    internal void SetAvailIn(int avail_in_value);
    internal Byte[] GetNextOut();
    internal void SetNextOut(Byte[] next_out_value);
    internal int GetNextOutIndex();
    internal void SetNextOutIndex(int next_out_index_value);
    internal int GetAvailOut();
    internal void SetAvailOut(int avail_out_value);
    internal long GetTotalOut();
    internal long GetTotalIn();
    internal string GetMessage();
    public virtual int End();
    public virtual bool Finished();
}
public class DotNetty.Codecs.CorruptedFrameException : DecoderException {
    public CorruptedFrameException(string message);
    public CorruptedFrameException(Exception cause);
}
public class DotNetty.Codecs.DatagramPacketDecoder : MessageToMessageDecoder`1<DatagramPacket> {
    private MessageToMessageDecoder`1<IByteBuffer> decoder;
    public DatagramPacketDecoder(MessageToMessageDecoder`1<IByteBuffer> decoder);
    public virtual bool AcceptInboundMessage(object msg);
    protected internal virtual void Decode(IChannelHandlerContext context, DatagramPacket message, List`1<object> output);
    public virtual void ChannelRegistered(IChannelHandlerContext context);
    public virtual void ChannelUnregistered(IChannelHandlerContext context);
    public virtual void ChannelActive(IChannelHandlerContext context);
    public virtual void ChannelInactive(IChannelHandlerContext context);
    public virtual void ChannelReadComplete(IChannelHandlerContext context);
    public virtual void UserEventTriggered(IChannelHandlerContext context, object evt);
    public virtual void ChannelWritabilityChanged(IChannelHandlerContext context);
    public virtual void ExceptionCaught(IChannelHandlerContext context, Exception exception);
    public virtual void HandlerAdded(IChannelHandlerContext context);
    public virtual void HandlerRemoved(IChannelHandlerContext context);
}
public class DotNetty.Codecs.DatagramPacketEncoder`1 : MessageToMessageEncoder`1<IAddressedEnvelope`1<T>> {
    private MessageToMessageEncoder`1<T> encoder;
    public DatagramPacketEncoder`1(MessageToMessageEncoder`1<T> encoder);
    public virtual bool AcceptOutboundMessage(object msg);
    protected internal virtual void Encode(IChannelHandlerContext context, IAddressedEnvelope`1<T> message, List`1<object> output);
    public virtual Task BindAsync(IChannelHandlerContext context, EndPoint localAddress);
    public virtual Task ConnectAsync(IChannelHandlerContext context, EndPoint remoteAddress, EndPoint localAddress);
    public virtual Task DisconnectAsync(IChannelHandlerContext context);
    public virtual Task CloseAsync(IChannelHandlerContext context);
    public virtual Task DeregisterAsync(IChannelHandlerContext context);
    public virtual void Read(IChannelHandlerContext context);
    public virtual void Flush(IChannelHandlerContext context);
    public virtual void HandlerAdded(IChannelHandlerContext context);
    public virtual void HandlerRemoved(IChannelHandlerContext context);
    public virtual void ExceptionCaught(IChannelHandlerContext context, Exception exception);
}
public class DotNetty.Codecs.DateFormatter : object {
    private static BitArray Delimiters;
    private static String[] DayOfWeekToShortName;
    private static String[] CalendarMonthToShortName;
    private static ThreadLocalCache Cache;
    private StringBuilder sb;
    private bool timeFound;
    private int hours;
    private int minutes;
    private int seconds;
    private bool dayOfMonthFound;
    private int dayOfMonth;
    private bool monthFound;
    private int month;
    private bool yearFound;
    private int year;
    private static AsciiString Jan;
    private static AsciiString Feb;
    private static AsciiString Mar;
    private static AsciiString Apr;
    private static AsciiString May;
    private static AsciiString Jun;
    private static AsciiString Jul;
    private static AsciiString Aug;
    private static AsciiString Sep;
    private static AsciiString Oct;
    private static AsciiString Nov;
    private static AsciiString Dec;
    private static DateFormatter();
    private static BitArray GetDelimiters();
    public static Nullable`1<DateTime> ParseHttpDate(string txt);
    public static Nullable`1<DateTime> ParseHttpDate(ICharSequence txt);
    public static Nullable`1<DateTime> ParseHttpDate(string txt, int start, int end);
    public static Nullable`1<DateTime> ParseHttpDate(ICharSequence txt, int start, int end);
    public static string Format(DateTime dateTime);
    public static StringBuilder Append(DateTime dateTime, StringBuilder sb);
    private static DateFormatter Formatter();
    private static bool IsDelim(char c);
    private static bool IsDigit(char c);
    private static int GetNumericalValue(char c);
    public void Reset();
    private bool TryParseTime(ICharSequence txt, int tokenStart, int tokenEnd);
    private bool TryParseDayOfMonth(ICharSequence txt, int tokenStart, int tokenEnd);
    private static bool MatchMonth(ICharSequence month, ICharSequence txt, int tokenStart);
    private bool TryParseMonth(ICharSequence txt, int tokenStart, int tokenEnd);
    private bool TryParseYear(ICharSequence txt, int tokenStart, int tokenEnd);
    private bool ParseToken(ICharSequence txt, int tokenStart, int tokenEnd);
    private Nullable`1<DateTime> Parse0(ICharSequence txt, int start, int end);
    private bool Parse1(ICharSequence txt, int start, int end);
    private bool NormalizeAndValidate();
    private DateTime ComputeDate();
    private string Format0(DateTime dateTime);
    private static StringBuilder Append0(DateTime dateTime, StringBuilder buffer);
    private static StringBuilder AppendZeroLeftPadded(int value, StringBuilder sb);
}
public class DotNetty.Codecs.DecoderException : CodecException {
    public DecoderException(string message);
    public DecoderException(Exception cause);
    public DecoderException(string message, Exception cause);
}
public class DotNetty.Codecs.DecoderResult : object {
    protected static Signal SignalUnfinished;
    protected static Signal SignalSuccess;
    public static DecoderResult Unfinished;
    public static DecoderResult Success;
    private Exception cause;
    public bool IsFinished { get; }
    public bool IsSuccess { get; }
    public bool IsFailure { get; }
    public Exception Cause { get; }
    protected DecoderResult(Exception cause);
    private static DecoderResult();
    public static DecoderResult Failure(Exception cause);
    public bool get_IsFinished();
    public bool get_IsSuccess();
    public bool get_IsFailure();
    public Exception get_Cause();
    public virtual string ToString();
}
public class DotNetty.Codecs.DefaultHeaders`2 : object {
    private static int HashCodeSeed;
    private static DefaultHashingStrategy`1<TValue> DefaultValueHashingStrategy;
    private static DefaultHashingStrategy`1<TKey> DefaultKeyHashingStragety;
    private static NullNameValidator`1<TKey> DefaultKeyNameValidator;
    private HeaderEntry`2[] entries;
    private HeaderEntry`2<TKey, TValue> head;
    private byte hashMask;
    protected IValueConverter`1<TValue> ValueConverter;
    private INameValidator`1<TKey> nameValidator;
    private IHashingStrategy`1<TKey> hashingStrategy;
    private int size;
    public int Size { get; }
    public bool IsEmpty { get; }
    public DefaultHeaders`2(IValueConverter`1<TValue> valueConverter);
    public DefaultHeaders`2(IValueConverter`1<TValue> valueConverter, INameValidator`1<TKey> nameValidator);
    public DefaultHeaders`2(IHashingStrategy`1<TKey> nameHashingStrategy, IValueConverter`1<TValue> valueConverter, INameValidator`1<TKey> nameValidator);
    public DefaultHeaders`2(IHashingStrategy`1<TKey> nameHashingStrategy, IValueConverter`1<TValue> valueConverter, INameValidator`1<TKey> nameValidator, int arraySizeHint);
    private static DefaultHeaders`2();
    public sealed virtual bool TryGet(TKey name, TValue& value);
    public sealed virtual TValue Get(TKey name, TValue defaultValue);
    public sealed virtual bool TryGetAndRemove(TKey name, TValue& value);
    public sealed virtual TValue GetAndRemove(TKey name, TValue defaultValue);
    public virtual IList`1<TValue> GetAll(TKey name);
    public virtual IEnumerable`1<TValue> ValueIterator(TKey name);
    public sealed virtual IList`1<TValue> GetAllAndRemove(TKey name);
    public sealed virtual bool Contains(TKey name);
    public sealed virtual bool ContainsObject(TKey name, object value);
    public sealed virtual bool ContainsBoolean(TKey name, bool value);
    public sealed virtual bool ContainsByte(TKey name, byte value);
    public sealed virtual bool ContainsChar(TKey name, char value);
    public sealed virtual bool ContainsShort(TKey name, short value);
    public sealed virtual bool ContainsInt(TKey name, int value);
    public sealed virtual bool ContainsLong(TKey name, long value);
    public sealed virtual bool ContainsFloat(TKey name, float value);
    public sealed virtual bool ContainsDouble(TKey name, double value);
    public sealed virtual bool ContainsTimeMillis(TKey name, long value);
    public sealed virtual bool Contains(TKey name, TValue value);
    public bool Contains(TKey name, TValue value, IHashingStrategy`1<TValue> valueHashingStrategy);
    public sealed virtual int get_Size();
    public sealed virtual bool get_IsEmpty();
    public sealed virtual ISet`1<TKey> Names();
    public virtual IHeaders`2<TKey, TValue> Add(TKey name, TValue value);
    public virtual IHeaders`2<TKey, TValue> Add(TKey name, IEnumerable`1<TValue> values);
    public virtual IHeaders`2<TKey, TValue> AddObject(TKey name, object value);
    public virtual IHeaders`2<TKey, TValue> AddObject(TKey name, IEnumerable`1<object> values);
    public virtual IHeaders`2<TKey, TValue> AddObject(TKey name, Object[] values);
    public sealed virtual IHeaders`2<TKey, TValue> AddInt(TKey name, int value);
    public sealed virtual IHeaders`2<TKey, TValue> AddLong(TKey name, long value);
    public sealed virtual IHeaders`2<TKey, TValue> AddDouble(TKey name, double value);
    public sealed virtual IHeaders`2<TKey, TValue> AddTimeMillis(TKey name, long value);
    public sealed virtual IHeaders`2<TKey, TValue> AddChar(TKey name, char value);
    public sealed virtual IHeaders`2<TKey, TValue> AddBoolean(TKey name, bool value);
    public sealed virtual IHeaders`2<TKey, TValue> AddFloat(TKey name, float value);
    public sealed virtual IHeaders`2<TKey, TValue> AddByte(TKey name, byte value);
    public sealed virtual IHeaders`2<TKey, TValue> AddShort(TKey name, short value);
    public virtual IHeaders`2<TKey, TValue> Add(IHeaders`2<TKey, TValue> headers);
    protected void AddImpl(IHeaders`2<TKey, TValue> headers);
    public sealed virtual IHeaders`2<TKey, TValue> Set(TKey name, TValue value);
    public virtual IHeaders`2<TKey, TValue> Set(TKey name, IEnumerable`1<TValue> values);
    public virtual IHeaders`2<TKey, TValue> SetObject(TKey name, object value);
    public virtual IHeaders`2<TKey, TValue> SetObject(TKey name, IEnumerable`1<object> values);
    public sealed virtual IHeaders`2<TKey, TValue> SetInt(TKey name, int value);
    public sealed virtual IHeaders`2<TKey, TValue> SetLong(TKey name, long value);
    public sealed virtual IHeaders`2<TKey, TValue> SetDouble(TKey name, double value);
    public sealed virtual IHeaders`2<TKey, TValue> SetTimeMillis(TKey name, long value);
    public sealed virtual IHeaders`2<TKey, TValue> SetFloat(TKey name, float value);
    public sealed virtual IHeaders`2<TKey, TValue> SetChar(TKey name, char value);
    public sealed virtual IHeaders`2<TKey, TValue> SetBoolean(TKey name, bool value);
    public sealed virtual IHeaders`2<TKey, TValue> SetByte(TKey name, byte value);
    public sealed virtual IHeaders`2<TKey, TValue> SetShort(TKey name, short value);
    public virtual IHeaders`2<TKey, TValue> Set(IHeaders`2<TKey, TValue> headers);
    public virtual IHeaders`2<TKey, TValue> SetAll(IHeaders`2<TKey, TValue> headers);
    public sealed virtual bool Remove(TKey name);
    public sealed virtual IHeaders`2<TKey, TValue> Clear();
    public sealed virtual IEnumerator`1<HeaderEntry`2<TKey, TValue>> GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    public sealed virtual bool TryGetBoolean(TKey name, Boolean& value);
    public sealed virtual bool GetBoolean(TKey name, bool defaultValue);
    public sealed virtual bool TryGetByte(TKey name, Byte& value);
    public sealed virtual byte GetByte(TKey name, byte defaultValue);
    public sealed virtual bool TryGetChar(TKey name, Char& value);
    public sealed virtual char GetChar(TKey name, char defaultValue);
    public sealed virtual bool TryGetShort(TKey name, Int16& value);
    public sealed virtual short GetShort(TKey name, short defaultValue);
    public sealed virtual bool TryGetInt(TKey name, Int32& value);
    public sealed virtual int GetInt(TKey name, int defaultValue);
    public sealed virtual bool TryGetLong(TKey name, Int64& value);
    public sealed virtual long GetLong(TKey name, long defaultValue);
    public sealed virtual bool TryGetFloat(TKey name, Single& value);
    public sealed virtual float GetFloat(TKey name, float defaultValue);
    public sealed virtual bool TryGetDouble(TKey name, Double& value);
    public sealed virtual double GetDouble(TKey name, double defaultValue);
    public sealed virtual bool TryGetTimeMillis(TKey name, Int64& value);
    public sealed virtual long GetTimeMillis(TKey name, long defaultValue);
    public sealed virtual bool TryGetBooleanAndRemove(TKey name, Boolean& value);
    public sealed virtual bool GetBooleanAndRemove(TKey name, bool defaultValue);
    public sealed virtual bool TryGetByteAndRemove(TKey name, Byte& value);
    public sealed virtual byte GetByteAndRemove(TKey name, byte defaultValue);
    public sealed virtual bool TryGetCharAndRemove(TKey name, Char& value);
    public sealed virtual char GetCharAndRemove(TKey name, char defaultValue);
    public sealed virtual bool TryGetShortAndRemove(TKey name, Int16& value);
    public sealed virtual short GetShortAndRemove(TKey name, short defaultValue);
    public sealed virtual bool TryGetIntAndRemove(TKey name, Int32& value);
    public sealed virtual int GetIntAndRemove(TKey name, int defaultValue);
    public sealed virtual bool TryGetLongAndRemove(TKey name, Int64& value);
    public sealed virtual long GetLongAndRemove(TKey name, long defaultValue);
    public sealed virtual bool TryGetFloatAndRemove(TKey name, Single& value);
    public sealed virtual float GetFloatAndRemove(TKey name, float defaultValue);
    public sealed virtual bool TryGetDoubleAndRemove(TKey name, Double& value);
    public sealed virtual double GetDoubleAndRemove(TKey name, double defaultValue);
    public sealed virtual bool TryGetTimeMillisAndRemove(TKey name, Int64& value);
    public sealed virtual long GetTimeMillisAndRemove(TKey name, long defaultValue);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public bool Equals(IHeaders`2<TKey, TValue> h2, IHashingStrategy`1<TValue> valueHashingStrategy);
    public int HashCode(IHashingStrategy`1<TValue> valueHashingStrategy);
    public virtual string ToString();
    protected HeaderEntry`2<TKey, TValue> NewHeaderEntry(int h, TKey name, TValue value, HeaderEntry`2<TKey, TValue> next);
    private int Index(int hash);
    private void Add0(int h, int i, TKey name, TValue value);
    private bool TryRemove0(int h, int i, TKey name, TValue& value);
    public DefaultHeaders`2<TKey, TValue> Copy();
}
public class DotNetty.Codecs.DelimiterBasedFrameDecoder : ByteToMessageDecoder {
    private IByteBuffer[] delimiters;
    private int maxFrameLength;
    private bool stripDelimiter;
    private bool failFast;
    private bool discardingTooLongFrame;
    private int tooLongFrameLength;
    private LineBasedFrameDecoder lineBasedDecoder;
    public DelimiterBasedFrameDecoder(int maxFrameLength, bool stripDelimiter, bool failFast, IByteBuffer[] delimiters);
    public DelimiterBasedFrameDecoder(int maxFrameLength, IByteBuffer delimiter);
    public DelimiterBasedFrameDecoder(int maxFrameLength, bool stripDelimiter, IByteBuffer delimiter);
    public DelimiterBasedFrameDecoder(int maxFrameLength, bool stripDelimiter, bool failFast, IByteBuffer delimiter);
    public DelimiterBasedFrameDecoder(int maxFrameLength, IByteBuffer[] delimiters);
    public DelimiterBasedFrameDecoder(int maxFrameLength, bool stripDelimiter, IByteBuffer[] delimiters);
    private static bool IsLineBased(IByteBuffer[] delimiters);
    private bool IsSubclass();
    protected internal virtual void Decode(IChannelHandlerContext ctx, IByteBuffer input, List`1<object> output);
    protected virtual object Decode(IChannelHandlerContext ctx, IByteBuffer buffer);
    private void Fail(long frameLength);
    private static int IndexOf(IByteBuffer haystack, IByteBuffer needle);
    private static void ValidateDelimiter(IByteBuffer delimiter);
    private static void ValidateMaxFrameLength(int maxFrameLength);
}
public class DotNetty.Codecs.Delimiters : object {
    public static IByteBuffer[] NullDelimiter();
    public static IByteBuffer[] LineDelimiter();
}
public class DotNetty.Codecs.EncoderException : CodecException {
    public EncoderException(string message);
    public EncoderException(Exception innerException);
    public EncoderException(string message, Exception innerException);
}
public class DotNetty.Codecs.HeaderEntry`2 : object {
    internal int Hash;
    internal TKey key;
    internal TValue value;
    internal HeaderEntry`2<TKey, TValue> Next;
    internal HeaderEntry`2<TKey, TValue> Before;
    internal HeaderEntry`2<TKey, TValue> After;
    public TKey Key { get; }
    public TValue Value { get; }
    public HeaderEntry`2(int hash, TKey key);
    internal HeaderEntry`2(int hash, TKey key, TValue value, HeaderEntry`2<TKey, TValue> next, HeaderEntry`2<TKey, TValue> head);
    internal void Remove();
    public TKey get_Key();
    public TValue get_Value();
    public TValue SetValue(TValue newValue);
    public virtual string ToString();
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
}
public static class DotNetty.Codecs.HeadersUtils : object {
    public static List`1<string> GetAllAsString(IHeaders`2<TKey, TValue> headers, TKey name);
    public static bool TryGetAsString(IHeaders`2<TKey, TValue> headers, TKey name, String& value);
    public static string ToString(IEnumerable`1<HeaderEntry`2<TKey, TValue>> headers, int size);
    public static IList`1<string> NamesAsString(IHeaders`2<ICharSequence, ICharSequence> headers);
    internal static void ThrowArgumentNullException(string name);
    internal static void ThrowArgumentException(string message);
    internal static void ThrowInvalidOperationException(string message);
}
public interface DotNetty.Codecs.IDecoderResultProvider {
    public DecoderResult Result { get; public set; }
    public abstract virtual DecoderResult get_Result();
    public abstract virtual void set_Result(DecoderResult value);
}
public interface DotNetty.Codecs.IHeaders`2 {
    public int Size { get; }
    public bool IsEmpty { get; }
    public abstract virtual bool TryGet(TKey name, TValue& value);
    public abstract virtual TValue Get(TKey name, TValue defaultValue);
    public abstract virtual bool TryGetAndRemove(TKey name, TValue& value);
    public abstract virtual TValue GetAndRemove(TKey name, TValue defaultValue);
    public abstract virtual IList`1<TValue> GetAll(TKey name);
    public abstract virtual IList`1<TValue> GetAllAndRemove(TKey name);
    public abstract virtual bool TryGetBoolean(TKey name, Boolean& value);
    public abstract virtual bool GetBoolean(TKey name, bool defaultValue);
    public abstract virtual bool TryGetByte(TKey name, Byte& value);
    public abstract virtual byte GetByte(TKey name, byte defaultValue);
    public abstract virtual bool TryGetChar(TKey name, Char& value);
    public abstract virtual char GetChar(TKey name, char defaultValue);
    public abstract virtual bool TryGetShort(TKey name, Int16& value);
    public abstract virtual short GetShort(TKey name, short defaultValue);
    public abstract virtual bool TryGetInt(TKey name, Int32& value);
    public abstract virtual int GetInt(TKey name, int defaultValue);
    public abstract virtual bool TryGetLong(TKey name, Int64& value);
    public abstract virtual long GetLong(TKey name, long defaultValue);
    public abstract virtual bool TryGetFloat(TKey name, Single& value);
    public abstract virtual float GetFloat(TKey name, float defaultValue);
    public abstract virtual bool TryGetDouble(TKey name, Double& value);
    public abstract virtual double GetDouble(TKey name, double defaultValue);
    public abstract virtual bool TryGetTimeMillis(TKey name, Int64& value);
    public abstract virtual long GetTimeMillis(TKey name, long defaultValue);
    public abstract virtual bool TryGetBooleanAndRemove(TKey name, Boolean& value);
    public abstract virtual bool GetBooleanAndRemove(TKey name, bool defaultValue);
    public abstract virtual bool TryGetByteAndRemove(TKey name, Byte& value);
    public abstract virtual byte GetByteAndRemove(TKey name, byte defaultValue);
    public abstract virtual bool TryGetCharAndRemove(TKey name, Char& value);
    public abstract virtual char GetCharAndRemove(TKey name, char defaultValue);
    public abstract virtual bool TryGetShortAndRemove(TKey name, Int16& value);
    public abstract virtual short GetShortAndRemove(TKey name, short defaultValue);
    public abstract virtual bool TryGetIntAndRemove(TKey name, Int32& value);
    public abstract virtual int GetIntAndRemove(TKey name, int defaultValue);
    public abstract virtual bool TryGetLongAndRemove(TKey name, Int64& value);
    public abstract virtual long GetLongAndRemove(TKey name, long defaultValue);
    public abstract virtual bool TryGetFloatAndRemove(TKey name, Single& value);
    public abstract virtual float GetFloatAndRemove(TKey name, float defaultValue);
    public abstract virtual bool TryGetDoubleAndRemove(TKey name, Double& value);
    public abstract virtual double GetDoubleAndRemove(TKey name, double defaultValue);
    public abstract virtual bool TryGetTimeMillisAndRemove(TKey name, Int64& value);
    public abstract virtual long GetTimeMillisAndRemove(TKey name, long defaultValue);
    public abstract virtual bool Contains(TKey name);
    public abstract virtual bool Contains(TKey name, TValue value);
    public abstract virtual bool ContainsObject(TKey name, object value);
    public abstract virtual bool ContainsBoolean(TKey name, bool value);
    public abstract virtual bool ContainsByte(TKey name, byte value);
    public abstract virtual bool ContainsChar(TKey name, char value);
    public abstract virtual bool ContainsShort(TKey name, short value);
    public abstract virtual bool ContainsInt(TKey name, int value);
    public abstract virtual bool ContainsLong(TKey name, long value);
    public abstract virtual bool ContainsFloat(TKey name, float value);
    public abstract virtual bool ContainsDouble(TKey name, double value);
    public abstract virtual bool ContainsTimeMillis(TKey name, long value);
    public abstract virtual int get_Size();
    public abstract virtual bool get_IsEmpty();
    public abstract virtual ISet`1<TKey> Names();
    public abstract virtual IHeaders`2<TKey, TValue> Add(TKey name, TValue value);
    public abstract virtual IHeaders`2<TKey, TValue> Add(TKey name, IEnumerable`1<TValue> values);
    public abstract virtual IHeaders`2<TKey, TValue> AddObject(TKey name, object value);
    public abstract virtual IHeaders`2<TKey, TValue> AddObject(TKey name, IEnumerable`1<object> values);
    public abstract virtual IHeaders`2<TKey, TValue> AddBoolean(TKey name, bool value);
    public abstract virtual IHeaders`2<TKey, TValue> AddByte(TKey name, byte value);
    public abstract virtual IHeaders`2<TKey, TValue> AddChar(TKey name, char value);
    public abstract virtual IHeaders`2<TKey, TValue> AddShort(TKey name, short value);
    public abstract virtual IHeaders`2<TKey, TValue> AddInt(TKey name, int value);
    public abstract virtual IHeaders`2<TKey, TValue> AddLong(TKey name, long value);
    public abstract virtual IHeaders`2<TKey, TValue> AddFloat(TKey name, float value);
    public abstract virtual IHeaders`2<TKey, TValue> AddDouble(TKey name, double value);
    public abstract virtual IHeaders`2<TKey, TValue> AddTimeMillis(TKey name, long value);
    public abstract virtual IHeaders`2<TKey, TValue> Add(IHeaders`2<TKey, TValue> headers);
    public abstract virtual IHeaders`2<TKey, TValue> Set(TKey name, TValue value);
    public abstract virtual IHeaders`2<TKey, TValue> Set(TKey name, IEnumerable`1<TValue> values);
    public abstract virtual IHeaders`2<TKey, TValue> SetObject(TKey name, object value);
    public abstract virtual IHeaders`2<TKey, TValue> SetObject(TKey name, IEnumerable`1<object> values);
    public abstract virtual IHeaders`2<TKey, TValue> SetBoolean(TKey name, bool value);
    public abstract virtual IHeaders`2<TKey, TValue> SetByte(TKey name, byte value);
    public abstract virtual IHeaders`2<TKey, TValue> SetChar(TKey name, char value);
    public abstract virtual IHeaders`2<TKey, TValue> SetShort(TKey name, short value);
    public abstract virtual IHeaders`2<TKey, TValue> SetInt(TKey name, int value);
    public abstract virtual IHeaders`2<TKey, TValue> SetLong(TKey name, long value);
    public abstract virtual IHeaders`2<TKey, TValue> SetFloat(TKey name, float value);
    public abstract virtual IHeaders`2<TKey, TValue> SetDouble(TKey name, double value);
    public abstract virtual IHeaders`2<TKey, TValue> SetTimeMillis(TKey name, long value);
    public abstract virtual IHeaders`2<TKey, TValue> Set(IHeaders`2<TKey, TValue> headers);
    public abstract virtual IHeaders`2<TKey, TValue> SetAll(IHeaders`2<TKey, TValue> headers);
    public abstract virtual bool Remove(TKey name);
    public abstract virtual IHeaders`2<TKey, TValue> Clear();
}
public interface DotNetty.Codecs.INameValidator`1 {
    public abstract virtual void ValidateName(T name);
}
public interface DotNetty.Codecs.IValueConverter`1 {
    public abstract virtual T ConvertObject(object value);
    public abstract virtual T ConvertBoolean(bool value);
    public abstract virtual bool ConvertToBoolean(T value);
    public abstract virtual T ConvertByte(byte value);
    public abstract virtual byte ConvertToByte(T value);
    public abstract virtual T ConvertChar(char value);
    public abstract virtual char ConvertToChar(T value);
    public abstract virtual T ConvertShort(short value);
    public abstract virtual short ConvertToShort(T value);
    public abstract virtual T ConvertInt(int value);
    public abstract virtual int ConvertToInt(T value);
    public abstract virtual T ConvertLong(long value);
    public abstract virtual long ConvertToLong(T value);
    public abstract virtual T ConvertTimeMillis(long value);
    public abstract virtual long ConvertToTimeMillis(T value);
    public abstract virtual T ConvertFloat(float value);
    public abstract virtual float ConvertToFloat(T value);
    public abstract virtual T ConvertDouble(double value);
    public abstract virtual double ConvertToDouble(T value);
}
public class DotNetty.Codecs.Json.JsonObjectDecoder : ByteToMessageDecoder {
    private static int StCorrupted;
    private static int StInit;
    private static int StDecodingNormal;
    private static int StDecodingArrayStream;
    private int openBraces;
    private int idx;
    private int state;
    private bool insideString;
    private int maxObjectLength;
    private bool streamArrayElements;
    public JsonObjectDecoder(int maxObjectLength);
    public JsonObjectDecoder(bool streamArrayElements);
    public JsonObjectDecoder(int maxObjectLength, bool streamArrayElements);
    protected internal virtual void Decode(IChannelHandlerContext context, IByteBuffer input, List`1<object> output);
    protected virtual IByteBuffer ExtractObject(IChannelHandlerContext context, IByteBuffer buffer, int index, int length);
    private void DecodeByte(byte c, IByteBuffer input, int idx);
    private void InitDecoding(byte openingBrace);
    private void Reset();
}
public class DotNetty.Codecs.LengthFieldBasedFrameDecoder : ByteToMessageDecoder {
    private ByteOrder byteOrder;
    private int maxFrameLength;
    private int lengthFieldOffset;
    private int lengthFieldLength;
    private int lengthFieldEndOffset;
    private int lengthAdjustment;
    private int initialBytesToStrip;
    private bool failFast;
    private bool discardingTooLongFrame;
    private long tooLongFrameLength;
    private long bytesToDiscard;
    public LengthFieldBasedFrameDecoder(int maxFrameLength, int lengthFieldOffset, int lengthFieldLength);
    public LengthFieldBasedFrameDecoder(int maxFrameLength, int lengthFieldOffset, int lengthFieldLength, int lengthAdjustment, int initialBytesToStrip);
    public LengthFieldBasedFrameDecoder(int maxFrameLength, int lengthFieldOffset, int lengthFieldLength, int lengthAdjustment, int initialBytesToStrip, bool failFast);
    public LengthFieldBasedFrameDecoder(ByteOrder byteOrder, int maxFrameLength, int lengthFieldOffset, int lengthFieldLength, int lengthAdjustment, int initialBytesToStrip, bool failFast);
    protected internal virtual void Decode(IChannelHandlerContext context, IByteBuffer input, List`1<object> output);
    protected virtual object Decode(IChannelHandlerContext context, IByteBuffer input);
    protected virtual long GetUnadjustedFrameLength(IByteBuffer buffer, int offset, int length, ByteOrder order);
    protected virtual IByteBuffer ExtractFrame(IChannelHandlerContext context, IByteBuffer buffer, int index, int length);
    private void FailIfNecessary(bool firstDetectionOfTooLongFrame);
    private void Fail(long frameLength);
}
public class DotNetty.Codecs.LengthFieldPrepender : MessageToMessageEncoder`1<IByteBuffer> {
    private ByteOrder byteOrder;
    private int lengthFieldLength;
    private bool lengthFieldIncludesLengthFieldLength;
    private int lengthAdjustment;
    public LengthFieldPrepender(int lengthFieldLength);
    public LengthFieldPrepender(int lengthFieldLength, bool lengthFieldIncludesLengthFieldLength);
    public LengthFieldPrepender(int lengthFieldLength, int lengthAdjustment);
    public LengthFieldPrepender(int lengthFieldLength, int lengthAdjustment, bool lengthFieldIncludesLengthFieldLength);
    public LengthFieldPrepender(ByteOrder byteOrder, int lengthFieldLength, int lengthAdjustment, bool lengthFieldIncludesLengthFieldLength);
    protected internal virtual void Encode(IChannelHandlerContext context, IByteBuffer message, List`1<object> output);
}
public class DotNetty.Codecs.LineBasedFrameDecoder : ByteToMessageDecoder {
    private int maxLength;
    private bool failFast;
    private bool stripDelimiter;
    private bool discarding;
    private int discardedBytes;
    public LineBasedFrameDecoder(int maxLength);
    public LineBasedFrameDecoder(int maxLength, bool stripDelimiter, bool failFast);
    protected internal virtual void Decode(IChannelHandlerContext context, IByteBuffer input, List`1<object> output);
    protected internal virtual object Decode(IChannelHandlerContext ctx, IByteBuffer buffer);
    private void Fail(IChannelHandlerContext ctx, int length);
    private void Fail(IChannelHandlerContext ctx, string length);
    private int FindEndOfLine(IByteBuffer buffer);
}
public class DotNetty.Codecs.MessageAggregationException : InvalidOperationException {
    public MessageAggregationException(string message);
    public MessageAggregationException(string message, Exception cause);
}
public abstract class DotNetty.Codecs.MessageAggregator`4 : MessageToMessageDecoder`1<TMessage> {
    private static int DefaultMaxCompositebufferComponents;
    private int maxCumulationBufferComponents;
    private TOutput currentMessage;
    private bool handlingOversizedMessage;
    private IChannelHandlerContext handlerContext;
    [CompilerGeneratedAttribute]
private int <MaxContentLength>k__BackingField;
    public int MaxContentLength { get; }
    public int MaxCumulationBufferComponents { get; public set; }
    protected MessageAggregator`4(int maxContentLength);
    private static void ValidateMaxContentLength(int maxContentLength);
    public virtual bool AcceptInboundMessage(object msg);
    protected abstract virtual bool IsStartMessage(TMessage msg);
    protected abstract virtual bool IsContentMessage(TMessage msg);
    protected abstract virtual bool IsLastContentMessage(TContent msg);
    protected abstract virtual bool IsAggregated(TMessage msg);
    [CompilerGeneratedAttribute]
public int get_MaxContentLength();
    public int get_MaxCumulationBufferComponents();
    public void set_MaxCumulationBufferComponents(int value);
    protected IChannelHandlerContext HandlerContext();
    protected internal virtual void Decode(IChannelHandlerContext context, TMessage message, List`1<object> output);
    private static void CloseAfterWriteAction(Task task, object state);
    private static void ContinueResponseWriteAction(Task task, object state);
    private static T As(object obj);
    private static void AppendPartialContent(CompositeByteBuffer content, IByteBuffer partialContent);
    protected abstract virtual bool IsContentLengthInvalid(TStart start, int maxContentLength);
    protected abstract virtual object NewContinueResponse(TStart start, int maxContentLength, IChannelPipeline pipeline);
    protected abstract virtual bool CloseAfterContinueResponse(object msg);
    protected abstract virtual bool IgnoreContentAfterContinueResponse(object msg);
    protected abstract virtual TOutput BeginAggregation(TStart start, IByteBuffer content);
    protected virtual void Aggregate(TOutput aggregated, TContent content);
    protected virtual void FinishAggregation(TOutput aggregated);
    private void InvokeHandleOversizedMessage(IChannelHandlerContext ctx, TStart oversized);
    protected virtual void HandleOversizedMessage(IChannelHandlerContext ctx, TStart oversized);
    public virtual void ChannelReadComplete(IChannelHandlerContext context);
    public virtual void ChannelInactive(IChannelHandlerContext context);
    public virtual void HandlerAdded(IChannelHandlerContext context);
    public virtual void HandlerRemoved(IChannelHandlerContext context);
    private void ReleaseCurrentMessage();
}
public abstract class DotNetty.Codecs.MessageToByteEncoder`1 : ChannelHandlerAdapter {
    public virtual bool AcceptOutboundMessage(object message);
    public virtual Task WriteAsync(IChannelHandlerContext context, object message);
    protected virtual IByteBuffer AllocateBuffer(IChannelHandlerContext context);
    protected abstract virtual void Encode(IChannelHandlerContext context, T message, IByteBuffer output);
}
public abstract class DotNetty.Codecs.MessageToMessageCodec`2 : ChannelDuplexHandler {
    private Encoder<TInbound, TOutbound> encoder;
    private Decoder<TInbound, TOutbound> decoder;
    public sealed virtual void ChannelRead(IChannelHandlerContext context, object message);
    public sealed virtual Task WriteAsync(IChannelHandlerContext context, object message);
    public virtual bool AcceptInboundMessage(object msg);
    public virtual bool AcceptOutboundMessage(object msg);
    protected abstract virtual void Encode(IChannelHandlerContext ctx, TOutbound msg, List`1<object> output);
    protected abstract virtual void Decode(IChannelHandlerContext ctx, TInbound msg, List`1<object> output);
}
public abstract class DotNetty.Codecs.MessageToMessageDecoder`1 : ChannelHandlerAdapter {
    public virtual bool AcceptInboundMessage(object msg);
    public virtual void ChannelRead(IChannelHandlerContext context, object message);
    protected internal abstract virtual void Decode(IChannelHandlerContext context, T message, List`1<object> output);
}
public abstract class DotNetty.Codecs.MessageToMessageEncoder`1 : ChannelHandlerAdapter {
    public virtual bool AcceptOutboundMessage(object msg);
    public virtual Task WriteAsync(IChannelHandlerContext ctx, object msg);
    protected internal abstract virtual void Encode(IChannelHandlerContext context, T message, List`1<object> output);
}
public class DotNetty.Codecs.NullNameValidator`1 : object {
    public sealed virtual void ValidateName(T name);
}
public class DotNetty.Codecs.PrematureChannelClosureException : CodecException {
    public PrematureChannelClosureException(string message);
    public PrematureChannelClosureException(Exception exception);
    public PrematureChannelClosureException(string message, Exception exception);
}
public class DotNetty.Codecs.Protobuf.ProtobufVarint32FrameDecoder : ByteToMessageDecoder {
    protected internal virtual void Decode(IChannelHandlerContext context, IByteBuffer input, List`1<object> output);
    private static int ReadRawVarint32(IByteBuffer buffer);
}
public class DotNetty.Codecs.Protobuf.ProtobufVarint32LengthFieldPrepender : MessageToByteEncoder`1<IByteBuffer> {
    public bool IsSharable { get; }
    protected virtual void Encode(IChannelHandlerContext context, IByteBuffer message, IByteBuffer output);
    internal static void WriteRawVarint32(IByteBuffer output, int value);
    public static int ComputeRawVarint32Size(int value);
    public virtual bool get_IsSharable();
}
public abstract class DotNetty.Codecs.ReplayingDecoder`1 : ByteToMessageDecoder {
    private TState state;
    private int checkpoint;
    private bool replayRequested;
    protected TState State { get; }
    protected bool ReplayRequested { get; }
    protected ReplayingDecoder`1(TState initialState);
    protected TState get_State();
    protected void Checkpoint();
    protected void Checkpoint(TState newState);
    protected bool get_ReplayRequested();
    protected void RequestReplay();
    protected virtual void CallDecode(IChannelHandlerContext context, IByteBuffer input, List`1<object> output);
}
public class DotNetty.Codecs.StringDecoder : MessageToMessageDecoder`1<IByteBuffer> {
    private Encoding encoding;
    public bool IsSharable { get; }
    public StringDecoder(Encoding encoding);
    public virtual bool get_IsSharable();
    protected internal virtual void Decode(IChannelHandlerContext context, IByteBuffer input, List`1<object> output);
    protected string Decode(IChannelHandlerContext context, IByteBuffer input);
}
public class DotNetty.Codecs.StringEncoder : MessageToMessageEncoder`1<string> {
    private Encoding encoding;
    public bool IsSharable { get; }
    public StringEncoder(Encoding encoding);
    public virtual bool get_IsSharable();
    protected internal virtual void Encode(IChannelHandlerContext context, string message, List`1<object> output);
}
public class DotNetty.Codecs.TooLongFrameException : DecoderException {
    public TooLongFrameException(string message);
    public TooLongFrameException(Exception cause);
}
public class DotNetty.Codecs.UnsupportedMessageTypeException : CodecException {
    public UnsupportedMessageTypeException(object message, Type[] expectedTypes);
    public UnsupportedMessageTypeException(string message, Exception innerException);
    public UnsupportedMessageTypeException(string message);
    public UnsupportedMessageTypeException(Exception innerException);
    private static string ComposeMessage(string actualType, Type[] expectedTypes);
}
