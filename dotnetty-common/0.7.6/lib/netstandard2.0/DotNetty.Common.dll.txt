public abstract class DotNetty.Common.Concurrency.AbstractEventExecutor : AbstractExecutorService {
    private static IInternalLogger Logger;
    private static TimeSpan DefaultShutdownQuietPeriod;
    private static TimeSpan DefaultShutdownTimeout;
    [CompilerGeneratedAttribute]
private IEventExecutorGroup <Parent>k__BackingField;
    public bool IsShuttingDown { get; }
    public Task TerminationCompletion { get; }
    public IEventExecutorGroup Parent { get; }
    public bool InEventLoop { get; }
    public IEnumerable`1<IEventExecutor> Items { get; }
    protected AbstractEventExecutor(IEventExecutorGroup parent);
    private static AbstractEventExecutor();
    public abstract virtual bool get_IsShuttingDown();
    public abstract virtual Task get_TerminationCompletion();
    public sealed virtual IEventExecutor GetNext();
    [CompilerGeneratedAttribute]
public sealed virtual IEventExecutorGroup get_Parent();
    public sealed virtual bool get_InEventLoop();
    public sealed virtual IEnumerable`1<IEventExecutor> get_Items();
    protected abstract virtual IEnumerable`1<IEventExecutor> GetItems();
    public abstract virtual bool IsInEventLoop(Thread thread);
    public virtual IScheduledTask Schedule(IRunnable action, TimeSpan delay);
    public virtual IScheduledTask Schedule(Action action, TimeSpan delay);
    public virtual IScheduledTask Schedule(Action`1<object> action, object state, TimeSpan delay);
    public virtual IScheduledTask Schedule(Action`2<object, object> action, object context, object state, TimeSpan delay);
    public virtual Task ScheduleAsync(Action action, TimeSpan delay);
    public virtual Task ScheduleAsync(Action`1<object> action, object state, TimeSpan delay, CancellationToken cancellationToken);
    public virtual Task ScheduleAsync(Action`1<object> action, object state, TimeSpan delay);
    public virtual Task ScheduleAsync(Action action, TimeSpan delay, CancellationToken cancellationToken);
    public virtual Task ScheduleAsync(Action`2<object, object> action, object context, object state, TimeSpan delay);
    public virtual Task ScheduleAsync(Action`2<object, object> action, object context, object state, TimeSpan delay, CancellationToken cancellationToken);
    public sealed virtual Task ShutdownGracefullyAsync();
    public abstract virtual Task ShutdownGracefullyAsync(TimeSpan quietPeriod, TimeSpan timeout);
    protected void SetCurrentExecutor(IEventExecutor executor);
    protected static void SafeExecute(IRunnable task);
}
public abstract class DotNetty.Common.Concurrency.AbstractEventExecutorGroup : object {
    private static TimeSpan DefaultShutdownQuietPeriod;
    private static TimeSpan DefaultShutdownTimeout;
    public bool IsShutdown { get; }
    public bool IsTerminated { get; }
    public bool IsShuttingDown { get; }
    public Task TerminationCompletion { get; }
    public IEnumerable`1<IEventExecutor> Items { get; }
    private static AbstractEventExecutorGroup();
    public abstract virtual bool get_IsShutdown();
    public abstract virtual bool get_IsTerminated();
    public abstract virtual bool get_IsShuttingDown();
    public abstract virtual Task get_TerminationCompletion();
    public sealed virtual IEnumerable`1<IEventExecutor> get_Items();
    public abstract virtual IEventExecutor GetNext();
    public sealed virtual void Execute(IRunnable task);
    public sealed virtual void Execute(Action`1<object> action, object state);
    public sealed virtual void Execute(Action action);
    public sealed virtual void Execute(Action`2<object, object> action, object context, object state);
    public sealed virtual Task`1<T> SubmitAsync(Func`1<T> func);
    public sealed virtual Task`1<T> SubmitAsync(Func`1<T> func, CancellationToken cancellationToken);
    public sealed virtual Task`1<T> SubmitAsync(Func`2<object, T> func, object state);
    public sealed virtual Task`1<T> SubmitAsync(Func`2<object, T> func, object state, CancellationToken cancellationToken);
    public sealed virtual Task`1<T> SubmitAsync(Func`3<object, object, T> func, object context, object state);
    public sealed virtual Task`1<T> SubmitAsync(Func`3<object, object, T> func, object context, object state, CancellationToken cancellationToken);
    public sealed virtual IScheduledTask Schedule(IRunnable action, TimeSpan delay);
    public sealed virtual IScheduledTask Schedule(Action action, TimeSpan delay);
    public sealed virtual IScheduledTask Schedule(Action`1<object> action, object state, TimeSpan delay);
    public sealed virtual IScheduledTask Schedule(Action`2<object, object> action, object context, object state, TimeSpan delay);
    public sealed virtual Task ScheduleAsync(Action`1<object> action, object state, TimeSpan delay, CancellationToken cancellationToken);
    public sealed virtual Task ScheduleAsync(Action`1<object> action, object state, TimeSpan delay);
    public sealed virtual Task ScheduleAsync(Action action, TimeSpan delay, CancellationToken cancellationToken);
    public sealed virtual Task ScheduleAsync(Action action, TimeSpan delay);
    public sealed virtual Task ScheduleAsync(Action`2<object, object> action, object context, object state, TimeSpan delay);
    public sealed virtual Task ScheduleAsync(Action`2<object, object> action, object context, object state, TimeSpan delay, CancellationToken cancellationToken);
    public sealed virtual Task ShutdownGracefullyAsync();
    public abstract virtual Task ShutdownGracefullyAsync(TimeSpan quietPeriod, TimeSpan timeout);
    protected abstract virtual IEnumerable`1<IEventExecutor> GetItems();
}
public abstract class DotNetty.Common.Concurrency.AbstractExecutorService : object {
    public bool IsShutdown { get; }
    public bool IsTerminated { get; }
    public abstract virtual bool get_IsShutdown();
    public abstract virtual bool get_IsTerminated();
    public sealed virtual Task`1<T> SubmitAsync(Func`1<T> func);
    public sealed virtual Task`1<T> SubmitAsync(Func`1<T> func, CancellationToken cancellationToken);
    public sealed virtual Task`1<T> SubmitAsync(Func`2<object, T> func, object state);
    public sealed virtual Task`1<T> SubmitAsync(Func`2<object, T> func, object state, CancellationToken cancellationToken);
    public sealed virtual Task`1<T> SubmitAsync(Func`3<object, object, T> func, object context, object state);
    public sealed virtual Task`1<T> SubmitAsync(Func`3<object, object, T> func, object context, object state, CancellationToken cancellationToken);
    public abstract virtual void Execute(IRunnable task);
    public sealed virtual void Execute(Action`1<object> action, object state);
    public sealed virtual void Execute(Action`2<object, object> action, object context, object state);
    public sealed virtual void Execute(Action action);
}
public abstract class DotNetty.Common.Concurrency.AbstractScheduledEventExecutor : AbstractEventExecutor {
    protected PriorityQueue`1<IScheduledRunnable> ScheduledTaskQueue;
    protected AbstractScheduledEventExecutor(IEventExecutorGroup parent);
    protected static PreciseTimeSpan GetNanos();
    protected static bool IsNullOrEmpty(PriorityQueue`1<T> taskQueue);
    protected virtual void CancelScheduledTasks();
    protected IScheduledRunnable PollScheduledTask();
    protected IScheduledRunnable PollScheduledTask(PreciseTimeSpan nanoTime);
    protected PreciseTimeSpan NextScheduledTaskNanos();
    protected IScheduledRunnable PeekScheduledTask();
    protected bool HasScheduledTasks();
    public virtual IScheduledTask Schedule(IRunnable action, TimeSpan delay);
    public virtual IScheduledTask Schedule(Action action, TimeSpan delay);
    public virtual IScheduledTask Schedule(Action`1<object> action, object state, TimeSpan delay);
    public virtual IScheduledTask Schedule(Action`2<object, object> action, object context, object state, TimeSpan delay);
    public virtual Task ScheduleAsync(Action action, TimeSpan delay, CancellationToken cancellationToken);
    public virtual Task ScheduleAsync(Action`1<object> action, object state, TimeSpan delay, CancellationToken cancellationToken);
    public virtual Task ScheduleAsync(Action`2<object, object> action, object context, object state, TimeSpan delay, CancellationToken cancellationToken);
    protected IScheduledRunnable Schedule(IScheduledRunnable task);
    internal void RemoveScheduled(IScheduledRunnable task);
}
internal class DotNetty.Common.Concurrency.ActionScheduledAsyncTask : ScheduledAsyncTask {
    private Action action;
    public ActionScheduledAsyncTask(AbstractScheduledEventExecutor executor, Action action, PreciseTimeSpan deadline, CancellationToken cancellationToken);
    protected virtual void Execute();
}
internal class DotNetty.Common.Concurrency.ActionScheduledTask : ScheduledTask {
    private Action action;
    public ActionScheduledTask(AbstractScheduledEventExecutor executor, Action action, PreciseTimeSpan deadline);
    protected virtual void Execute();
}
public static class DotNetty.Common.Concurrency.ExecutionEnvironment : object {
    [ThreadStaticAttribute]
private static IEventExecutor currentExecutor;
    public static bool TryGetCurrentExecutor(IEventExecutor& executor);
    internal static void SetCurrentExecutor(IEventExecutor executor);
}
public class DotNetty.Common.Concurrency.ExecutorTaskScheduler : TaskScheduler {
    private IEventExecutor executor;
    private bool started;
    public ExecutorTaskScheduler(IEventExecutor executor);
    protected virtual void QueueTask(Task task);
    protected virtual bool TryExecuteTaskInline(Task task, bool taskWasPreviouslyQueued);
    protected virtual IEnumerable`1<Task> GetScheduledTasks();
    protected virtual bool TryDequeue(Task task);
}
public interface DotNetty.Common.Concurrency.ICallable`1 {
    public abstract virtual T Call();
}
public interface DotNetty.Common.Concurrency.IEventExecutor {
    public IEventExecutorGroup Parent { get; }
    public bool InEventLoop { get; }
    public abstract virtual IEventExecutorGroup get_Parent();
    public abstract virtual bool get_InEventLoop();
    public abstract virtual bool IsInEventLoop(Thread thread);
}
public interface DotNetty.Common.Concurrency.IEventExecutorGroup {
    public IEnumerable`1<IEventExecutor> Items { get; }
    public bool IsShuttingDown { get; }
    public Task TerminationCompletion { get; }
    public abstract virtual IEnumerable`1<IEventExecutor> get_Items();
    public abstract virtual bool get_IsShuttingDown();
    public abstract virtual Task ShutdownGracefullyAsync();
    public abstract virtual Task ShutdownGracefullyAsync(TimeSpan quietPeriod, TimeSpan timeout);
    public abstract virtual Task get_TerminationCompletion();
    public abstract virtual IEventExecutor GetNext();
}
public interface DotNetty.Common.Concurrency.IExecutor {
    public abstract virtual void Execute(IRunnable task);
    public abstract virtual void Execute(Action`1<object> action, object state);
    public abstract virtual void Execute(Action action);
    public abstract virtual void Execute(Action`2<object, object> action, object context, object state);
}
public interface DotNetty.Common.Concurrency.IExecutorService {
    public bool IsShutdown { get; }
    public bool IsTerminated { get; }
    public abstract virtual bool get_IsShutdown();
    public abstract virtual bool get_IsTerminated();
    public abstract virtual Task`1<T> SubmitAsync(Func`1<T> func);
    public abstract virtual Task`1<T> SubmitAsync(Func`1<T> func, CancellationToken cancellationToken);
    public abstract virtual Task`1<T> SubmitAsync(Func`2<object, T> func, object state);
    public abstract virtual Task`1<T> SubmitAsync(Func`2<object, T> func, object state, CancellationToken cancellationToken);
    public abstract virtual Task`1<T> SubmitAsync(Func`3<object, object, T> func, object context, object state);
    public abstract virtual Task`1<T> SubmitAsync(Func`3<object, object, T> func, object context, object state, CancellationToken cancellationToken);
}
public interface DotNetty.Common.Concurrency.IRunnable {
    public abstract virtual void Run();
}
public interface DotNetty.Common.Concurrency.IScheduledExecutorService {
    public abstract virtual IScheduledTask Schedule(IRunnable action, TimeSpan delay);
    public abstract virtual IScheduledTask Schedule(Action action, TimeSpan delay);
    public abstract virtual IScheduledTask Schedule(Action`1<object> action, object state, TimeSpan delay);
    public abstract virtual IScheduledTask Schedule(Action`2<object, object> action, object context, object state, TimeSpan delay);
    public abstract virtual Task ScheduleAsync(Action`1<object> action, object state, TimeSpan delay, CancellationToken cancellationToken);
    public abstract virtual Task ScheduleAsync(Action`1<object> action, object state, TimeSpan delay);
    public abstract virtual Task ScheduleAsync(Action action, TimeSpan delay, CancellationToken cancellationToken);
    public abstract virtual Task ScheduleAsync(Action action, TimeSpan delay);
    public abstract virtual Task ScheduleAsync(Action`2<object, object> action, object context, object state, TimeSpan delay);
    public abstract virtual Task ScheduleAsync(Action`2<object, object> action, object context, object state, TimeSpan delay, CancellationToken cancellationToken);
}
public interface DotNetty.Common.Concurrency.IScheduledRunnable {
}
public interface DotNetty.Common.Concurrency.IScheduledTask {
    public PreciseTimeSpan Deadline { get; }
    public Task Completion { get; }
    public abstract virtual bool Cancel();
    public abstract virtual PreciseTimeSpan get_Deadline();
    public abstract virtual Task get_Completion();
    public abstract virtual TaskAwaiter GetAwaiter();
}
public class DotNetty.Common.Concurrency.RejectedExecutionException : Exception {
    public RejectedExecutionException(string message);
}
internal class DotNetty.Common.Concurrency.RunnableScheduledTask : ScheduledTask {
    private IRunnable action;
    public RunnableScheduledTask(AbstractScheduledEventExecutor executor, IRunnable action, PreciseTimeSpan deadline);
    protected virtual void Execute();
}
internal abstract class DotNetty.Common.Concurrency.ScheduledAsyncTask : ScheduledTask {
    private CancellationToken cancellationToken;
    private CancellationTokenRegistration cancellationTokenRegistration;
    protected ScheduledAsyncTask(AbstractScheduledEventExecutor executor, PreciseTimeSpan deadline, TaskCompletionSource promise, CancellationToken cancellationToken);
    public virtual void Run();
}
internal abstract class DotNetty.Common.Concurrency.ScheduledTask : object {
    private static int CancellationProhibited;
    private static int CancellationRequested;
    protected TaskCompletionSource Promise;
    protected AbstractScheduledEventExecutor Executor;
    private int volatileCancellationState;
    [CompilerGeneratedAttribute]
private PreciseTimeSpan <Deadline>k__BackingField;
    public PreciseTimeSpan Deadline { get; }
    public Task Completion { get; }
    protected ScheduledTask(AbstractScheduledEventExecutor executor, PreciseTimeSpan deadline, TaskCompletionSource promise);
    [CompilerGeneratedAttribute]
public sealed virtual PreciseTimeSpan get_Deadline();
    public sealed virtual bool Cancel();
    public sealed virtual Task get_Completion();
    public sealed virtual TaskAwaiter GetAwaiter();
    private sealed virtual override int System.IComparable<DotNetty.Common.Concurrency.IScheduledRunnable>.CompareTo(IScheduledRunnable other);
    public virtual void Run();
    protected abstract virtual void Execute();
    private bool TrySetUncancelable();
    private bool AtomicCancellationStateUpdate(int newBits, int illegalBits);
}
public class DotNetty.Common.Concurrency.SingleThreadEventExecutor : AbstractScheduledEventExecutor {
    private static int ST_NOT_STARTED;
    private static int ST_STARTED;
    private static int ST_SHUTTING_DOWN;
    private static int ST_SHUTDOWN;
    private static int ST_TERMINATED;
    private static string DefaultWorkerThreadName;
    private static IRunnable WAKEUP_TASK;
    private static IInternalLogger Logger;
    private IQueue`1<IRunnable> taskQueue;
    private Thread thread;
    private Int32 modreq(System.Runtime.CompilerServices.IsVolatile) executionState;
    private PreciseTimeSpan preciseBreakoutInterval;
    private PreciseTimeSpan lastExecutionTime;
    private ManualResetEventSlim emptyEvent;
    private TaskScheduler scheduler;
    private TaskCompletionSource terminationCompletionSource;
    private PreciseTimeSpan gracefulShutdownStartTime;
    private PreciseTimeSpan gracefulShutdownQuietPeriod;
    private PreciseTimeSpan gracefulShutdownTimeout;
    private ISet`1<Action> shutdownHooks;
    private long progress;
    public TaskScheduler Scheduler { get; }
    public long Progress { get; }
    public bool IsBacklogEmpty { get; }
    public int BacklogLength { get; }
    public bool IsShuttingDown { get; }
    public Task TerminationCompletion { get; }
    public bool IsShutdown { get; }
    public bool IsTerminated { get; }
    public SingleThreadEventExecutor(string threadName, TimeSpan breakoutInterval);
    public SingleThreadEventExecutor(IEventExecutorGroup parent, string threadName, TimeSpan breakoutInterval);
    protected SingleThreadEventExecutor(string threadName, TimeSpan breakoutInterval, IQueue`1<IRunnable> taskQueue);
    protected SingleThreadEventExecutor(IEventExecutorGroup parent, string threadName, TimeSpan breakoutInterval, IQueue`1<IRunnable> taskQueue);
    private static SingleThreadEventExecutor();
    public TaskScheduler get_Scheduler();
    public long get_Progress();
    public bool get_IsBacklogEmpty();
    public int get_BacklogLength();
    private void Loop();
    public virtual bool get_IsShuttingDown();
    public virtual Task get_TerminationCompletion();
    public virtual bool get_IsShutdown();
    public virtual bool get_IsTerminated();
    public virtual bool IsInEventLoop(Thread t);
    public virtual void Execute(IRunnable task);
    protected virtual IEnumerable`1<IEventExecutor> GetItems();
    protected void WakeUp(bool inEventLoop);
    public void AddShutdownHook(Action action);
    public void RemoveShutdownHook(Action action);
    private bool RunShutdownHooks();
    public virtual Task ShutdownGracefullyAsync(TimeSpan quietPeriod, TimeSpan timeout);
    protected bool ConfirmShutdown();
    protected void CleanupAndTerminate(bool success);
    protected virtual void Cleanup();
    protected bool RunAllTasks();
    private bool RunAllTasks(PreciseTimeSpan timeout);
    private bool FetchFromScheduledTaskQueue();
    private IRunnable PollTask();
    [CompilerGeneratedAttribute]
private void <Loop>b__33_0();
}
internal class DotNetty.Common.Concurrency.StateActionScheduledAsyncTask : ScheduledAsyncTask {
    private Action`1<object> action;
    public StateActionScheduledAsyncTask(AbstractScheduledEventExecutor executor, Action`1<object> action, object state, PreciseTimeSpan deadline, CancellationToken cancellationToken);
    protected virtual void Execute();
}
internal class DotNetty.Common.Concurrency.StateActionScheduledTask : ScheduledTask {
    private Action`1<object> action;
    public StateActionScheduledTask(AbstractScheduledEventExecutor executor, Action`1<object> action, object state, PreciseTimeSpan deadline);
    protected virtual void Execute();
}
internal class DotNetty.Common.Concurrency.StateActionWithContextScheduledAsyncTask : ScheduledAsyncTask {
    private Action`2<object, object> action;
    private object context;
    public StateActionWithContextScheduledAsyncTask(AbstractScheduledEventExecutor executor, Action`2<object, object> action, object context, object state, PreciseTimeSpan deadline, CancellationToken cancellationToken);
    protected virtual void Execute();
}
internal class DotNetty.Common.Concurrency.StateActionWithContextScheduledTask : ScheduledTask {
    private Action`2<object, object> action;
    private object context;
    public StateActionWithContextScheduledTask(AbstractScheduledEventExecutor executor, Action`2<object, object> action, object context, object state, PreciseTimeSpan deadline);
    protected virtual void Execute();
}
public class DotNetty.Common.Concurrency.TaskCompletionSource : TaskCompletionSource`1<int> {
    public static TaskCompletionSource Void;
    public TaskCompletionSource(object state);
    private static TaskCompletionSource();
    public bool TryComplete();
    public void Complete();
    public bool SetUncancellable();
    public virtual string ToString();
    private static TaskCompletionSource CreateVoidTcs();
}
public abstract class DotNetty.Common.FastThreadLocal : object {
    private static int VariablesToRemoveIndex;
    private static FastThreadLocal();
    public static void RemoveAll();
    public static void Destroy();
    protected static void AddToVariablesToRemove(InternalThreadLocalMap threadLocalMap, FastThreadLocal variable);
    protected static void RemoveFromVariablesToRemove(InternalThreadLocalMap threadLocalMap, FastThreadLocal variable);
    public abstract virtual void Remove(InternalThreadLocalMap threadLocalMap);
}
public class DotNetty.Common.FastThreadLocal`1 : FastThreadLocal {
    private int index;
    public static int Count { get; }
    public T Value { get; public set; }
    public static int get_Count();
    public T get_Value();
    public void set_Value(T value);
    public T Get(InternalThreadLocalMap threadLocalMap);
    private T Initialize(InternalThreadLocalMap threadLocalMap);
    public void Set(InternalThreadLocalMap threadLocalMap, T value);
    public bool IsSet();
    public bool IsSet(InternalThreadLocalMap threadLocalMap);
    protected virtual T GetInitialValue();
    public void Remove();
    public sealed virtual void Remove(InternalThreadLocalMap threadLocalMap);
    protected virtual void OnRemoval(T value);
}
public abstract class DotNetty.Common.Internal.AbstractQueue`1 : object {
    public int Count { get; }
    public bool IsEmpty { get; }
    public abstract virtual bool TryEnqueue(T item);
    public abstract virtual bool TryDequeue(T& item);
    public abstract virtual bool TryPeek(T& item);
    public abstract virtual int get_Count();
    public abstract virtual bool get_IsEmpty();
    public abstract virtual void Clear();
}
[DefaultMemberAttribute("Item")]
public class DotNetty.Common.Internal.AppendableCharSequence : object {
    private Byte[] chars;
    private int pos;
    public int Count { get; }
    public char Item { get; }
    public Byte[]& Bytes { get; }
    public AppendableCharSequence(int length);
    public AppendableCharSequence(Byte[] chars);
    public sealed virtual IEnumerator`1<char> GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    public sealed virtual int get_Count();
    public sealed virtual char get_Item(int index);
    public Byte[]& get_Bytes();
    public sealed virtual ICharSequence SubSequence(int start);
    public sealed virtual ICharSequence SubSequence(int start, int end);
    public sealed virtual int IndexOf(char ch, int start);
    public sealed virtual bool RegionMatches(int thisStart, ICharSequence seq, int start, int length);
    public sealed virtual bool RegionMatchesIgnoreCase(int thisStart, ICharSequence seq, int start, int length);
    public sealed virtual bool ContentEquals(ICharSequence other);
    public sealed virtual bool ContentEqualsIgnoreCase(ICharSequence other);
    public sealed virtual bool Equals(AppendableCharSequence other);
    public virtual bool Equals(object obj);
    public sealed virtual int HashCode(bool ignoreCase);
    public virtual int GetHashCode();
    public sealed virtual IAppendable Append(char c);
    public IAppendable Append(byte c);
    public sealed virtual IAppendable Append(ICharSequence sequence);
    public sealed virtual IAppendable Append(ICharSequence sequence, int start, int end);
    public void Reset();
    public sealed virtual string ToString(int start);
    public virtual string ToString();
    public AsciiString ToAsciiString();
    public AsciiString SubStringUnsafe(int start, int end);
    private static Byte[] Expand(Byte[] array, int neededSpace, int size);
}
internal abstract class DotNetty.Common.Internal.BaseLinkedQueue`1 : BaseLinkedQueueConsumerNodeRef`1<T> {
    public int Count { get; }
    public bool IsEmpty { get; }
    protected T RelaxedPoll();
    protected T RelaxedPeek();
    protected T GetSingleConsumerNodeValue(LinkedQueueNode`1<T> currConsumerNode, LinkedQueueNode`1<T> nextNode);
    public sealed virtual int get_Count();
    public sealed virtual bool get_IsEmpty();
}
internal abstract class DotNetty.Common.Internal.BaseLinkedQueueConsumerNodeRef`1 : BaseLinkedQueuePad1`1<T> {
    protected LinkedQueueNode`1<T> ConsumerNode;
    protected void SpConsumerNode(LinkedQueueNode`1<T> node);
    protected LinkedQueueNode`1<T> LvConsumerNode();
    protected LinkedQueueNode`1<T> LpConsumerNode();
}
internal abstract class DotNetty.Common.Internal.BaseLinkedQueuePad0`1 : object {
    private long p00;
    private long p01;
    private long p02;
    private long p03;
    private long p04;
    private long p05;
    private long p06;
    private long p07;
    private long p10;
    private long p11;
    private long p12;
    private long p13;
    private long p14;
    private long p15;
    private long p16;
    public int Count { get; }
    public bool IsEmpty { get; }
    public abstract virtual bool Offer(T e);
    public abstract virtual T Poll();
    public abstract virtual T Peek();
    public abstract virtual int get_Count();
    public abstract virtual bool get_IsEmpty();
    public abstract virtual void Clear();
}
internal abstract class DotNetty.Common.Internal.BaseLinkedQueuePad1`1 : BaseLinkedQueueProducerNodeRef`1<T> {
    private long p01;
    private long p02;
    private long p03;
    private long p04;
    private long p05;
    private long p06;
    private long p07;
    private long p10;
    private long p11;
    private long p12;
    private long p13;
    private long p14;
    private long p15;
    private long p16;
    private long p17;
}
internal abstract class DotNetty.Common.Internal.BaseLinkedQueueProducerNodeRef`1 : BaseLinkedQueuePad0`1<T> {
    protected LinkedQueueNode`1<T> ProducerNode;
    protected void SpProducerNode(LinkedQueueNode`1<T> node);
    protected LinkedQueueNode`1<T> LvProducerNode();
    protected LinkedQueueNode`1<T> LpProducerNode();
}
public class DotNetty.Common.Internal.CompatibleConcurrentQueue`1 : ConcurrentQueue`1<T> {
    public sealed virtual bool TryEnqueue(T element);
    private sealed virtual override void DotNetty.Common.Internal.IQueue<T>.Clear();
    private sealed virtual override bool DotNetty.Common.Internal.IQueue<T>.TryDequeue(T& item);
    private sealed virtual override bool DotNetty.Common.Internal.IQueue<T>.TryPeek(T& item);
    private sealed virtual override bool DotNetty.Common.Internal.IQueue<T>.get_IsEmpty();
}
internal abstract class DotNetty.Common.Internal.ConcurrentCircularArrayQueue`1 : ConcurrentCircularArrayQueueL0Pad`1<T> {
    protected long Mask;
    protected T[] Buffer;
    protected ConcurrentCircularArrayQueue`1(int capacity);
    protected long CalcElementOffset(long index);
    protected void SpElement(long offset, T e);
    protected void SoElement(long offset, T e);
    protected T LpElement(long offset);
    protected T LvElement(long offset);
    public virtual void Clear();
    public int Capacity();
}
internal abstract class DotNetty.Common.Internal.ConcurrentCircularArrayQueueL0Pad`1 : AbstractQueue`1<T> {
    private long p00;
    private long p01;
    private long p02;
    private long p03;
    private long p04;
    private long p05;
    private long p06;
    private long p07;
    private long p30;
    private long p31;
    private long p32;
    private long p33;
    private long p34;
    private long p35;
    private long p36;
    private long p37;
}
internal class DotNetty.Common.Internal.DefaultPlatform : object {
    private int processId;
    private sealed virtual override int DotNetty.Common.Internal.IPlatform.GetCurrentProcessId();
    private sealed virtual override Byte[] DotNetty.Common.Internal.IPlatform.GetDefaultDeviceId();
}
public static class DotNetty.Common.Internal.EmptyArrays : object {
    public static Int32[] EmptyInts;
    public static Byte[] EmptyBytes;
    public static Char[] EmptyChars;
    public static Object[] EmptyObjects;
    public static String[] EmptyStrings;
    public static AsciiString[] EmptyAsciiStrings;
    private static EmptyArrays();
}
public interface DotNetty.Common.Internal.IAppendable {
    public abstract virtual IAppendable Append(char c);
    public abstract virtual IAppendable Append(ICharSequence sequence);
    public abstract virtual IAppendable Append(ICharSequence sequence, int start, int end);
}
public interface DotNetty.Common.Internal.IDeque`1 {
    public abstract virtual bool TryDequeueLast(T& item);
}
public interface DotNetty.Common.Internal.ILinkedQueue`1 {
    public abstract virtual bool Offer(T e);
    public abstract virtual T Poll();
    public abstract virtual T Peek();
}
public interface DotNetty.Common.Internal.IPlatform {
    public abstract virtual int GetCurrentProcessId();
    public abstract virtual Byte[] GetDefaultDeviceId();
}
public interface DotNetty.Common.Internal.IQueue`1 {
    public int Count { get; }
    public bool IsEmpty { get; }
    public abstract virtual bool TryEnqueue(T item);
    public abstract virtual bool TryDequeue(T& item);
    public abstract virtual bool TryPeek(T& item);
    public abstract virtual int get_Count();
    public abstract virtual bool get_IsEmpty();
    public abstract virtual void Clear();
}
internal class DotNetty.Common.Internal.LinkedQueueNode`1 : object {
    private T value;
    private LinkedQueueNode`1<T> next;
    public LinkedQueueNode`1(T value);
    public T GetAndNullValue();
    public T LpValue();
    public void SpValue(T newValue);
    public void SoNext(LinkedQueueNode`1<T> n);
    public LinkedQueueNode`1<T> LvNext();
}
public abstract class DotNetty.Common.Internal.Logging.AbstractInternalLogger : object {
    private static string EXCEPTION_MESSAGE;
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    public string Name { get; }
    public bool TraceEnabled { get; }
    public bool DebugEnabled { get; }
    public bool InfoEnabled { get; }
    public bool WarnEnabled { get; }
    public bool ErrorEnabled { get; }
    protected AbstractInternalLogger(string name);
    private static AbstractInternalLogger();
    [CompilerGeneratedAttribute]
public sealed virtual string get_Name();
    public sealed virtual bool IsEnabled(InternalLogLevel level);
    public abstract virtual bool get_TraceEnabled();
    public abstract virtual void Trace(string msg);
    public abstract virtual void Trace(string format, object arg);
    public abstract virtual void Trace(string format, object argA, object argB);
    public abstract virtual void Trace(string format, Object[] arguments);
    public abstract virtual void Trace(string msg, Exception t);
    public sealed virtual void Trace(Exception t);
    public abstract virtual bool get_DebugEnabled();
    public abstract virtual void Debug(string msg);
    public abstract virtual void Debug(string format, object arg);
    public abstract virtual void Debug(string format, object argA, object argB);
    public abstract virtual void Debug(string format, Object[] arguments);
    public abstract virtual void Debug(string msg, Exception t);
    public sealed virtual void Debug(Exception t);
    public abstract virtual bool get_InfoEnabled();
    public abstract virtual void Info(string msg);
    public abstract virtual void Info(string format, object arg);
    public abstract virtual void Info(string format, object argA, object argB);
    public abstract virtual void Info(string format, Object[] arguments);
    public abstract virtual void Info(string msg, Exception t);
    public sealed virtual void Info(Exception t);
    public abstract virtual bool get_WarnEnabled();
    public abstract virtual void Warn(string msg);
    public abstract virtual void Warn(string format, object arg);
    public abstract virtual void Warn(string format, Object[] arguments);
    public abstract virtual void Warn(string format, object argA, object argB);
    public abstract virtual void Warn(string msg, Exception t);
    public sealed virtual void Warn(Exception t);
    public abstract virtual bool get_ErrorEnabled();
    public abstract virtual void Error(string msg);
    public abstract virtual void Error(string format, object arg);
    public abstract virtual void Error(string format, object argA, object argB);
    public abstract virtual void Error(string format, Object[] arguments);
    public abstract virtual void Error(string msg, Exception t);
    public sealed virtual void Error(Exception t);
    public sealed virtual void Log(InternalLogLevel level, string msg, Exception cause);
    public sealed virtual void Log(InternalLogLevel level, Exception cause);
    public sealed virtual void Log(InternalLogLevel level, string msg);
    public sealed virtual void Log(InternalLogLevel level, string format, object arg);
    public sealed virtual void Log(InternalLogLevel level, string format, object argA, object argB);
    public sealed virtual void Log(InternalLogLevel level, string format, Object[] arguments);
    public virtual string ToString();
}
[EventSourceAttribute]
public class DotNetty.Common.Internal.Logging.DefaultEventSource : EventSource {
    private static int TraceEventId;
    private static int DebugEventId;
    private static int InfoEventId;
    private static int WarningEventId;
    private static int ErrorEventId;
    public static DefaultEventSource Log;
    public bool IsTraceEnabled { get; }
    public bool IsDebugEnabled { get; }
    public bool IsInfoEnabled { get; }
    public bool IsWarningEnabled { get; }
    public bool IsErrorEnabled { get; }
    private static DefaultEventSource();
    public bool get_IsTraceEnabled();
    public bool get_IsDebugEnabled();
    public bool get_IsInfoEnabled();
    public bool get_IsWarningEnabled();
    public bool get_IsErrorEnabled();
    [NonEventAttribute]
public void Trace(string source, string message);
    [NonEventAttribute]
public void Trace(string source, string message, Exception exception);
    [EventAttribute("1")]
public void Trace(string source, string message, string info);
    [NonEventAttribute]
public void Debug(string source, string message);
    [NonEventAttribute]
public void Debug(string source, string message, Exception exception);
    [EventAttribute("2")]
public void Debug(string source, string message, string info);
    [NonEventAttribute]
public void Info(string source, string message);
    [NonEventAttribute]
public void Info(string source, string message, Exception exception);
    [EventAttribute("3")]
public void Info(string source, string message, string info);
    [NonEventAttribute]
public void Warning(string source, string message);
    [NonEventAttribute]
public void Warning(string source, string message, Exception exception);
    [EventAttribute("4")]
public void Warning(string source, string message, string exception);
    [NonEventAttribute]
public void Error(string source, string message);
    [NonEventAttribute]
public void Error(string source, string message, Exception exception);
    [EventAttribute("5")]
public void Error(string source, string message, string exception);
}
internal class DotNetty.Common.Internal.Logging.EventSourceLogger : object {
    private string name;
    public EventSourceLogger(string name);
    public sealed virtual void Log(LogLevel logLevel, EventId eventId, TState state, Exception exception, Func`3<TState, Exception, string> formatter);
    public sealed virtual bool IsEnabled(LogLevel logLevel);
    public sealed virtual IDisposable BeginScope(TState state);
}
public class DotNetty.Common.Internal.Logging.EventSourceLoggerProvider : object {
    public sealed virtual void Dispose();
    public sealed virtual ILogger CreateLogger(string categoryName);
}
public class DotNetty.Common.Internal.Logging.FormattingTuple : ValueType {
    private static FormattingTuple NULL;
    [CompilerGeneratedAttribute]
private string <Message>k__BackingField;
    [CompilerGeneratedAttribute]
private Object[] <ArgArray>k__BackingField;
    [CompilerGeneratedAttribute]
private Exception <Exception>k__BackingField;
    public string Message { get; private set; }
    public Object[] ArgArray { get; private set; }
    public Exception Exception { get; private set; }
    public FormattingTuple(string message);
    public FormattingTuple(string message, Object[] argArray, Exception exception);
    private static FormattingTuple();
    private static Object[] GetTrimmedCopy(Object[] argArray);
    [CompilerGeneratedAttribute]
public string get_Message();
    [CompilerGeneratedAttribute]
private void set_Message(string value);
    [CompilerGeneratedAttribute]
public Object[] get_ArgArray();
    [CompilerGeneratedAttribute]
private void set_ArgArray(Object[] value);
    [CompilerGeneratedAttribute]
public Exception get_Exception();
    [CompilerGeneratedAttribute]
private void set_Exception(Exception value);
}
internal class DotNetty.Common.Internal.Logging.GenericLogger : AbstractInternalLogger {
    private static Func`3<string, Exception, string> MessageFormatterFunc;
    private ILogger logger;
    public bool TraceEnabled { get; }
    public bool DebugEnabled { get; }
    public bool InfoEnabled { get; }
    public bool WarnEnabled { get; }
    public bool ErrorEnabled { get; }
    public GenericLogger(string name, ILogger logger);
    private static GenericLogger();
    public virtual bool get_TraceEnabled();
    public virtual void Trace(string msg);
    public virtual void Trace(string format, object arg);
    public virtual void Trace(string format, object argA, object argB);
    public virtual void Trace(string format, Object[] arguments);
    public virtual void Trace(string msg, Exception t);
    public virtual bool get_DebugEnabled();
    public virtual void Debug(string msg);
    public virtual void Debug(string format, object arg);
    public virtual void Debug(string format, object argA, object argB);
    public virtual void Debug(string format, Object[] arguments);
    public virtual void Debug(string msg, Exception t);
    public virtual bool get_InfoEnabled();
    public virtual void Info(string msg);
    public virtual void Info(string format, object arg);
    public virtual void Info(string format, object argA, object argB);
    public virtual void Info(string format, Object[] arguments);
    public virtual void Info(string msg, Exception t);
    public virtual bool get_WarnEnabled();
    public virtual void Warn(string msg);
    public virtual void Warn(string format, object arg);
    public virtual void Warn(string format, object argA, object argB);
    public virtual void Warn(string format, Object[] arguments);
    public virtual void Warn(string msg, Exception t);
    public virtual bool get_ErrorEnabled();
    public virtual void Error(string msg);
    public virtual void Error(string format, object arg);
    public virtual void Error(string format, object argA, object argB);
    public virtual void Error(string format, Object[] arguments);
    public virtual void Error(string msg, Exception t);
}
public interface DotNetty.Common.Internal.Logging.IInternalLogger {
    public string Name { get; }
    public bool TraceEnabled { get; }
    public bool DebugEnabled { get; }
    public bool InfoEnabled { get; }
    public bool WarnEnabled { get; }
    public bool ErrorEnabled { get; }
    public abstract virtual string get_Name();
    public abstract virtual bool get_TraceEnabled();
    public abstract virtual void Trace(string msg);
    public abstract virtual void Trace(string format, object arg);
    public abstract virtual void Trace(string format, object argA, object argB);
    public abstract virtual void Trace(string format, Object[] arguments);
    public abstract virtual void Trace(string msg, Exception t);
    public abstract virtual void Trace(Exception t);
    public abstract virtual bool get_DebugEnabled();
    public abstract virtual void Debug(string msg);
    public abstract virtual void Debug(string format, object arg);
    public abstract virtual void Debug(string format, object argA, object argB);
    public abstract virtual void Debug(string format, Object[] arguments);
    public abstract virtual void Debug(string msg, Exception t);
    public abstract virtual void Debug(Exception t);
    public abstract virtual bool get_InfoEnabled();
    public abstract virtual void Info(string msg);
    public abstract virtual void Info(string format, object arg);
    public abstract virtual void Info(string format, object argA, object argB);
    public abstract virtual void Info(string format, Object[] arguments);
    public abstract virtual void Info(string msg, Exception t);
    public abstract virtual void Info(Exception t);
    public abstract virtual bool get_WarnEnabled();
    public abstract virtual void Warn(string msg);
    public abstract virtual void Warn(string format, object arg);
    public abstract virtual void Warn(string format, Object[] arguments);
    public abstract virtual void Warn(string format, object argA, object argB);
    public abstract virtual void Warn(string msg, Exception t);
    public abstract virtual void Warn(Exception t);
    public abstract virtual bool get_ErrorEnabled();
    public abstract virtual void Error(string msg);
    public abstract virtual void Error(string format, object arg);
    public abstract virtual void Error(string format, object argA, object argB);
    public abstract virtual void Error(string format, Object[] arguments);
    public abstract virtual void Error(string msg, Exception t);
    public abstract virtual void Error(Exception t);
    public abstract virtual bool IsEnabled(InternalLogLevel level);
    public abstract virtual void Log(InternalLogLevel level, string msg);
    public abstract virtual void Log(InternalLogLevel level, string format, object arg);
    public abstract virtual void Log(InternalLogLevel level, string format, object argA, object argB);
    public abstract virtual void Log(InternalLogLevel level, string format, Object[] arguments);
    public abstract virtual void Log(InternalLogLevel level, string msg, Exception t);
    public abstract virtual void Log(InternalLogLevel level, Exception t);
}
public static class DotNetty.Common.Internal.Logging.InternalLoggerFactory : object {
    private static ILoggerFactory defaultFactory;
    public static ILoggerFactory DefaultFactory { get; public set; }
    private static ILoggerFactory NewDefaultFactory(string name);
    public static ILoggerFactory get_DefaultFactory();
    public static void set_DefaultFactory(ILoggerFactory value);
    public static IInternalLogger GetInstance();
    public static IInternalLogger GetInstance(Type type);
    public static IInternalLogger GetInstance(string name);
}
public enum DotNetty.Common.Internal.Logging.InternalLogLevel : Enum {
    public int value__;
    public static InternalLogLevel TRACE;
    public static InternalLogLevel DEBUG;
    public static InternalLogLevel INFO;
    public static InternalLogLevel WARN;
    public static InternalLogLevel ERROR;
}
public static class DotNetty.Common.Internal.Logging.MessageFormatter : object {
    private static char DELIM_START;
    private static string DELIM_STR;
    private static char ESCAPE_CHAR;
    private static MessageFormatter();
    public static FormattingTuple Format(string messagePattern, object arg);
    public static FormattingTuple Format(string messagePattern, object argA, object argB);
    public static Exception GetThrowableCandidate(Object[] argArray);
    public static FormattingTuple ArrayFormat(string messagePattern, Object[] argArray);
    public static bool IsEscapedDelimeter(string messagePattern, int delimeterStartIndex);
    public static bool IsDoubleEscaped(string messagePattern, int delimeterStartIndex);
    private static void DeeplyAppendParameter(StringBuilder sbuf, object o, ISet`1<Object[]> seenMap);
    public static void SafeObjectAppend(StringBuilder sbuf, object o);
    private static void ObjectArrayAppend(StringBuilder sbuf, Object[] a, ISet`1<Object[]> seenMap);
    private static void BooleanArrayAppend(StringBuilder sbuf, Boolean[] a);
    private static void ByteArrayAppend(StringBuilder sbuf, Byte[] a);
    private static void CharArrayAppend(StringBuilder sbuf, Char[] a);
    private static void ShortArrayAppend(StringBuilder sbuf, Int16[] a);
    private static void IntArrayAppend(StringBuilder sbuf, Int32[] a);
    private static void LongArrayAppend(StringBuilder sbuf, Int64[] a);
    private static void FloatArrayAppend(StringBuilder sbuf, Single[] a);
    private static void DoubleArrayAppend(StringBuilder sbuf, Double[] a);
}
public static class DotNetty.Common.Internal.MacAddressUtil : object {
    public static int MacAddressLength;
    private static Byte[] NotFound;
    private static IInternalLogger logger;
    private static MacAddressUtil();
    public static Byte[] GetBestAvailableMac();
    public static string FormatAddress(Byte[] addr);
    private static int CompareAddresses(Byte[] current, Byte[] candidate);
    private static int CompareAddresses(IPAddress current, IPAddress candidate);
    private static int ScoreAddress(IPAddress addr);
}
[ExtensionAttribute]
public static class DotNetty.Common.Internal.MathUtil : object {
    public static bool IsOutOfBounds(int index, int length, int capacity);
    public static int FindNextPositivePowerOfTwo(int value);
    public static int SafeFindNextPositivePowerOfTwo(int value);
    [ExtensionAttribute]
public static int NumberOfLeadingZeros(int i);
}
internal class DotNetty.Common.Internal.MpscArrayQueue`1 : MpscArrayQueueConsumerField`1<T> {
    private long p40;
    private long p41;
    private long p42;
    private long p43;
    private long p44;
    private long p45;
    private long p46;
    private long p30;
    private long p31;
    private long p32;
    private long p33;
    private long p34;
    private long p35;
    private long p36;
    private long p37;
    public int Count { get; }
    public bool IsEmpty { get; }
    public MpscArrayQueue`1(int capacity);
    public virtual bool TryEnqueue(T e);
    public int WeakEnqueue(T e);
    public virtual bool TryDequeue(T& item);
    public virtual bool TryPeek(T& item);
    public virtual int get_Count();
    public virtual bool get_IsEmpty();
}
internal abstract class DotNetty.Common.Internal.MpscArrayQueueConsumerField`1 : MpscArrayQueueL2Pad`1<T> {
    private long consumerIndex;
    protected long ConsumerIndex { get; protected set; }
    protected MpscArrayQueueConsumerField`1(int capacity);
    protected long get_ConsumerIndex();
    protected void set_ConsumerIndex(long value);
}
internal abstract class DotNetty.Common.Internal.MpscArrayQueueHeadCacheField`1 : MpscArrayQueueMidPad`1<T> {
    private long headCache;
    protected long ConsumerIndexCache { get; protected set; }
    protected MpscArrayQueueHeadCacheField`1(int capacity);
    protected long get_ConsumerIndexCache();
    protected void set_ConsumerIndexCache(long value);
}
internal abstract class DotNetty.Common.Internal.MpscArrayQueueL1Pad`1 : ConcurrentCircularArrayQueue`1<T> {
    private long p10;
    private long p11;
    private long p12;
    private long p13;
    private long p14;
    private long p15;
    private long p16;
    private long p30;
    private long p31;
    private long p32;
    private long p33;
    private long p34;
    private long p35;
    private long p36;
    private long p37;
    protected MpscArrayQueueL1Pad`1(int capacity);
}
internal abstract class DotNetty.Common.Internal.MpscArrayQueueL2Pad`1 : MpscArrayQueueHeadCacheField`1<T> {
    private long p20;
    private long p21;
    private long p22;
    private long p23;
    private long p24;
    private long p25;
    private long p26;
    private long p30;
    private long p31;
    private long p32;
    private long p33;
    private long p34;
    private long p35;
    private long p36;
    private long p37;
    protected MpscArrayQueueL2Pad`1(int capacity);
}
internal abstract class DotNetty.Common.Internal.MpscArrayQueueMidPad`1 : MpscArrayQueueTailField`1<T> {
    private long p20;
    private long p21;
    private long p22;
    private long p23;
    private long p24;
    private long p25;
    private long p26;
    private long p30;
    private long p31;
    private long p32;
    private long p33;
    private long p34;
    private long p35;
    private long p36;
    private long p37;
    protected MpscArrayQueueMidPad`1(int capacity);
}
internal abstract class DotNetty.Common.Internal.MpscArrayQueueTailField`1 : MpscArrayQueueL1Pad`1<T> {
    private long producerIndex;
    protected long ProducerIndex { get; }
    protected MpscArrayQueueTailField`1(int capacity);
    protected long get_ProducerIndex();
    protected bool TrySetProducerIndex(long expect, long newValue);
}
public static class DotNetty.Common.Internal.PlatformDependent : object {
    private static IInternalLogger Logger;
    private static bool UseDirectBuffer;
    private static int seed;
    private static ThreadLocal`1<Random> ThreadLocalRandom;
    private static bool IsLittleEndian;
    public static bool DirectBufferPreferred { get; }
    private static PlatformDependent();
    public static bool get_DirectBufferPreferred();
    public static IQueue`1<T> NewFixedMpscQueue(int capacity);
    public static IQueue`1<T> NewMpscQueue();
    public static IDictionary`2<TKey, TValue> NewConcurrentHashMap();
    public static ILinkedQueue`1<T> NewSpscLinkedQueue();
    public static Random GetThreadLocalRandom();
    public static bool ByteArrayEquals(Byte[] bytes1, int startPos1, Byte[] bytes2, int startPos2, int length);
    public static int HashCodeAscii(Byte[] bytes, int startPos, int length);
    public static int HashCodeAscii(ICharSequence bytes);
    private static int HashCodeAsciiCompute(ICharSequence value, int offset, int hash);
    private static int HashCodeAsciiSanitizeInt(ICharSequence value, int offset);
    private static int HashCodeAsciiSanitizeShort(ICharSequence value, int offset);
    private static int HashCodeAsciiSanitizsByte(char value);
    public static void CopyMemory(Byte[] src, int srcIndex, Byte[] dst, int dstIndex, int length);
    public static void CopyMemory(Byte* src, Byte* dst, int length);
    public static void CopyMemory(Byte* src, Byte[] dst, int dstIndex, int length);
    public static void CopyMemory(Byte[] src, int srcIndex, Byte* dst, int length);
    public static void Clear(Byte[] src, int srcIndex, int length);
    public static void SetMemory(Byte* src, int length, byte value);
    public static void SetMemory(Byte[] src, int srcIndex, int length, byte value);
}
internal static class DotNetty.Common.Internal.PlatformDependent0 : object {
    internal static int HashCodeAsciiSeed;
    internal static int HashCodeC1;
    internal static int HashCodeC2;
    private static PlatformDependent0();
    internal static bool ByteArrayEquals(Byte* bytes1, Byte* bytes2, int length);
    internal static int HashCodeAscii(Byte* bytes, int length);
    internal static int HashCodeAsciiCompute(long value, int hash);
    private static int HashCodeAsciiSanitize(int value);
    private static int HashCodeAsciiSanitize(short value);
    private static int HashCodeAsciiSanitize(byte value);
}
public static class DotNetty.Common.Internal.PlatformProvider : object {
    private static IPlatform defaultPlatform;
    public static IPlatform Platform { get; public set; }
    public static IPlatform get_Platform();
    public static void set_Platform(IPlatform value);
}
internal static class DotNetty.Common.Internal.RefArrayAccessUtil : object {
    public static int RefBufferPad;
    private static RefArrayAccessUtil();
    public static void SpElement(T[] buffer, long offset, T e);
    public static void SoElement(T[] buffer, long offset, T e);
    public static T LpElement(T[] buffer, long offset);
    public static T LvElement(T[] buffer, long offset);
    public static long CalcElementOffset(long index, long mask);
}
internal class DotNetty.Common.Internal.SpscLinkedQueue`1 : BaseLinkedQueue`1<T> {
    public virtual bool Offer(T e);
    public virtual T Poll();
    public virtual T Peek();
    public virtual void Clear();
}
public static class DotNetty.Common.Internal.SystemPropertyUtil : object {
    private static IInternalLogger Logger;
    private static bool loggedException;
    private static SystemPropertyUtil();
    public static bool Contains(string key);
    public static string Get(string key);
    public static string Get(string key, string def);
    public static bool GetBoolean(string key, bool def);
    public static int GetInt(string key, int def);
    public static long GetLong(string key, long def);
    private static void Log(string msg);
    private static void Log(string msg, Exception e);
}
public class DotNetty.Common.InternalThreadLocalMap : object {
    private static int DefaultArrayListInitialCapacity;
    public static object Unset;
    [ThreadStaticAttribute]
private static InternalThreadLocalMap slowThreadLocalMap;
    private static int nextIndex;
    private Object[] indexedVariables;
    private int futureListenerStackDepth;
    private int localChannelReaderStackDepth;
    private StringBuilder stringBuilder;
    private List`1<ICharSequence> charSequences;
    private List`1<AsciiString> asciiStrings;
    public long rp1;
    public long rp2;
    public long rp3;
    public long rp4;
    public long rp5;
    public long rp6;
    public long rp7;
    public long rp8;
    public long rp9;
    public int Count { get; }
    public StringBuilder StringBuilder { get; }
    public int FutureListenerStackDepth { get; public set; }
    public int LocalChannelReaderStackDepth { get; public set; }
    private static InternalThreadLocalMap();
    internal static int NextVariableIndex();
    public static InternalThreadLocalMap GetIfSet();
    public static InternalThreadLocalMap Get();
    public static void Remove();
    public static void Destroy();
    private static Object[] CreateIndexedVariableTable();
    public int get_Count();
    public StringBuilder get_StringBuilder();
    public List`1<ICharSequence> CharSequenceList(int minCapacity);
    public List`1<AsciiString> AsciiStringList(int minCapacity);
    public int get_FutureListenerStackDepth();
    public void set_FutureListenerStackDepth(int value);
    public int get_LocalChannelReaderStackDepth();
    public void set_LocalChannelReaderStackDepth(int value);
    public object GetIndexedVariable(int index);
    public bool SetIndexedVariable(int index, object value);
    private void ExpandIndexedVariableTableAndSet(int index, object value);
    public object RemoveIndexedVariable(int index);
    public bool IsIndexedVariableSet(int index);
}
public interface DotNetty.Common.IReferenceCounted {
    public int ReferenceCount { get; }
    public abstract virtual int get_ReferenceCount();
    public abstract virtual IReferenceCounted Retain();
    public abstract virtual IReferenceCounted Retain(int increment);
    public abstract virtual IReferenceCounted Touch();
    public abstract virtual IReferenceCounted Touch(object hint);
    public abstract virtual bool Release();
    public abstract virtual bool Release(int decrement);
}
public interface DotNetty.Common.IResourceLeakHint {
    public abstract virtual string ToHintString();
}
public interface DotNetty.Common.IResourceLeakTracker {
    public abstract virtual void Record();
    public abstract virtual void Record(object hint);
    public abstract virtual bool Close(object trackedObject);
}
public static class DotNetty.Common.Platform : object {
    public static int GetCurrentProcessId();
    public static Byte[] GetDefaultDeviceId();
}
public class DotNetty.Common.PreciseTimeSpan : ValueType {
    private static long StartTime;
    private static double PrecisionRatio;
    private static double ReversePrecisionRatio;
    private long ticks;
    public static PreciseTimeSpan Zero;
    public static PreciseTimeSpan MinusOne;
    public long Ticks { get; }
    public static PreciseTimeSpan FromStart { get; }
    private PreciseTimeSpan(long ticks);
    private static PreciseTimeSpan();
    public long get_Ticks();
    public static PreciseTimeSpan FromTicks(long ticks);
    public static PreciseTimeSpan get_FromStart();
    public static PreciseTimeSpan FromTimeSpan(TimeSpan timeSpan);
    public static PreciseTimeSpan Deadline(TimeSpan deadline);
    public static PreciseTimeSpan Deadline(PreciseTimeSpan deadline);
    private static long TicksToPreciseTicks(long ticks);
    public TimeSpan ToTimeSpan();
    private static long GetTimeChangeSinceStart();
    public sealed virtual bool Equals(PreciseTimeSpan other);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public sealed virtual int CompareTo(PreciseTimeSpan other);
    public static bool op_Equality(PreciseTimeSpan t1, PreciseTimeSpan t2);
    public static bool op_Inequality(PreciseTimeSpan t1, PreciseTimeSpan t2);
    public static bool op_GreaterThan(PreciseTimeSpan t1, PreciseTimeSpan t2);
    public static bool op_LessThan(PreciseTimeSpan t1, PreciseTimeSpan t2);
    public static bool op_GreaterThanOrEqual(PreciseTimeSpan t1, PreciseTimeSpan t2);
    public static bool op_LessThanOrEqual(PreciseTimeSpan t1, PreciseTimeSpan t2);
    public static PreciseTimeSpan op_Addition(PreciseTimeSpan t, TimeSpan duration);
    public static PreciseTimeSpan op_Subtraction(PreciseTimeSpan t, TimeSpan duration);
    public static PreciseTimeSpan op_Subtraction(PreciseTimeSpan t1, PreciseTimeSpan t2);
}
public class DotNetty.Common.ResourceLeakDetector : object {
    private static string PropLevel;
    private static DetectionLevel DefaultLevel;
    private static string PropTargetRecords;
    private static int DefaultTargetRecords;
    private static int TargetRecords;
    private static IInternalLogger Logger;
    private static int DefaultSamplingInterval;
    [CompilerGeneratedAttribute]
private static DetectionLevel <Level>k__BackingField;
    private ConditionalWeakTable`2<object, GCNotice> gcNotificationMap;
    private ConcurrentDictionary`2<string, bool> reportedLeaks;
    private string resourceType;
    private int samplingInterval;
    public static bool Enabled { get; }
    public static DetectionLevel Level { get; public set; }
    private static ResourceLeakDetector();
    public ResourceLeakDetector(string resourceType);
    public ResourceLeakDetector(string resourceType, int samplingInterval);
    public static bool get_Enabled();
    [CompilerGeneratedAttribute]
public static DetectionLevel get_Level();
    [CompilerGeneratedAttribute]
public static void set_Level(DetectionLevel value);
    public static ResourceLeakDetector Create();
    public IResourceLeakTracker Track(object obj);
    private void ReportLeak(DefaultResourceLeak resourceLeak);
    protected void ReportTracedLeak(string type, string records);
    protected void ReportUntracedLeak(string type);
}
public static class DotNetty.Common.ThreadDeathWatcher : object {
    private static IInternalLogger Logger;
    private static IQueue`1<Entry> PendingEntries;
    private static Watcher watcher;
    private static int started;
    private static Thread modreq(System.Runtime.CompilerServices.IsVolatile) watcherThread;
    private static ThreadDeathWatcher();
    public static void Watch(Thread thread, Action task);
    public static void Unwatch(Thread thread, Action task);
    private static void Schedule(Thread thread, Action task, bool isWatch);
    public static bool AwaitInactivity(TimeSpan timeout);
}
public class DotNetty.Common.ThreadLocalObjectList : List`1<object> {
    private static int DefaultInitialCapacity;
    private static ThreadLocalPool`1<ThreadLocalObjectList> Pool;
    private Handle returnHandle;
    private ThreadLocalObjectList(Handle returnHandle);
    private static ThreadLocalObjectList();
    public static ThreadLocalObjectList NewInstance();
    public static ThreadLocalObjectList NewInstance(int minCapacity);
    public void Return();
}
public class DotNetty.Common.ThreadLocalPool : object {
    private static int DefaultInitialMaxCapacityPerThread;
    protected static int DefaultMaxCapacityPerThread;
    protected static int DefaultInitialCapacity;
    protected static int DefaultMaxSharedCapacityFactor;
    protected static int DefaultMaxDelayedQueuesPerThread;
    protected static int LinkCapacity;
    protected static int DefaultRatio;
    private static int idSource;
    private static int ownThreadId;
    protected static DelayedThreadLocal DelayedPool;
    protected int maxCapacityPerThread;
    protected int ratioMask;
    protected int maxSharedCapacityFactor;
    protected int maxDelayedQueuesPerThread;
    private static ThreadLocalPool();
    public ThreadLocalPool(int maxCapacityPerThread);
    public ThreadLocalPool(int maxCapacityPerThread, int maxSharedCapacityFactor, int ratio, int maxDelayedQueuesPerThread);
}
public class DotNetty.Common.ThreadLocalPool`1 : ThreadLocalPool {
    private ThreadLocalStack<T> threadLocal;
    private bool preCreate;
    private Func`2<Handle, T> valueFactory;
    internal int ThreadLocalCapacity { get; }
    internal int ThreadLocalSize { get; }
    public ThreadLocalPool`1(Func`2<Handle, T> valueFactory);
    public ThreadLocalPool`1(Func`2<Handle, T> valueFactory, int maxCapacityPerThread);
    public ThreadLocalPool`1(Func`2<Handle, T> valueFactory, int maxCapacityPerThread, bool preCreate);
    public ThreadLocalPool`1(Func`2<Handle, T> valueFactory, int maxCapacityPerThread, int maxSharedCapacityFactor);
    public ThreadLocalPool`1(Func`2<Handle, T> valueFactory, int maxCapacityPerThread, int maxSharedCapacityFactor, int ratio, int maxDelayedQueuesPerThread, bool preCreate);
    public T Take();
    private DefaultHandle CreateValue(Stack stack);
    internal int get_ThreadLocalCapacity();
    internal int get_ThreadLocalSize();
}
public abstract class DotNetty.Common.Utilities.AbstractConstant : object {
    private static long nextUniquifier;
    private long volatileUniquifier;
    [CompilerGeneratedAttribute]
private int <Id>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    public int Id { get; }
    public string Name { get; }
    protected long Uniquifier { get; }
    protected AbstractConstant(int id, string name);
    [CompilerGeneratedAttribute]
public sealed virtual int get_Id();
    [CompilerGeneratedAttribute]
public sealed virtual string get_Name();
    public sealed virtual string ToString();
    protected long get_Uniquifier();
}
public abstract class DotNetty.Common.Utilities.AbstractConstant`1 : AbstractConstant {
    protected AbstractConstant`1(int id, string name);
    public sealed virtual int GetHashCode();
    public sealed virtual bool Equals(object obj);
    public sealed virtual bool Equals(T other);
    public sealed virtual int CompareTo(T o);
}
public abstract class DotNetty.Common.Utilities.AbstractReferenceCounted : object {
    private int referenceCount;
    public int ReferenceCount { get; }
    public sealed virtual int get_ReferenceCount();
    public sealed virtual IReferenceCounted Retain();
    public sealed virtual IReferenceCounted Retain(int increment);
    protected virtual IReferenceCounted RetainCore(int increment);
    public sealed virtual IReferenceCounted Touch();
    public abstract virtual IReferenceCounted Touch(object hint);
    public sealed virtual bool Release();
    public sealed virtual bool Release(int decrement);
    private bool ReleaseCore(int decrement);
    private static void ThrowIllegalReferenceCountException(int count, int increment);
    protected abstract virtual void Deallocate();
    [CompilerGeneratedAttribute]
internal static IllegalReferenceCountException <ThrowIllegalReferenceCountException>g__GetIllegalReferenceCountException|11_0(<>c__DisplayClass11_0& );
}
public class DotNetty.Common.Utilities.ActionTimerTask : object {
    private Action`1<ITimeout> action;
    public ActionTimerTask(Action`1<ITimeout> action);
    public sealed virtual void Run(ITimeout timeout);
}
[ExtensionAttribute]
public static class DotNetty.Common.Utilities.ArrayExtensions : object {
    public static Byte[] ZeroBytes;
    private static ArrayExtensions();
    [ExtensionAttribute]
public static T[] Slice(T[] array, int length);
    [ExtensionAttribute]
public static T[] Slice(T[] array, int index, int length);
    [ExtensionAttribute]
public static void SetRange(T[] array, int index, T[] src);
    [ExtensionAttribute]
public static void SetRange(T[] array, int index, T[] src, int srcIndex, int srcLength);
    [ExtensionAttribute]
public static void Fill(T[] array, T value);
    [ExtensionAttribute]
public static void Fill(T[] array, int offset, int count, T value);
    [ExtensionAttribute]
public static Byte[] CombineBytes(Byte[][] arrays);
}
[DefaultMemberAttribute("Item")]
public class DotNetty.Common.Utilities.AsciiString : object {
    public static AsciiString Empty;
    private static int MaxCharValue;
    private static byte Replacement;
    public static int IndexNotFound;
    public static IHashingStrategy`1<ICharSequence> CaseInsensitiveHasher;
    public static IHashingStrategy`1<ICharSequence> CaseSensitiveHasher;
    private static ICharEqualityComparator DefaultCharComparator;
    private static ICharEqualityComparator GeneralCaseInsensitiveComparator;
    private static ICharEqualityComparator AsciiCaseInsensitiveCharComparator;
    private Byte[] value;
    private int offset;
    private int length;
    private int hash;
    private string stringValue;
    public bool IsEmpty { get; }
    public int Count { get; }
    public Byte[] Array { get; }
    public int Offset { get; }
    public bool IsEntireArrayUsed { get; }
    public char Item { get; }
    internal AsciiString(Byte[] value);
    public AsciiString(Byte[] value, bool copy);
    public AsciiString(Byte[] value, int start, int length, bool copy);
    public AsciiString(Char[] value);
    public AsciiString(Char[] value, int start, int length);
    public AsciiString(Char[] value, Encoding encoding);
    public AsciiString(Char[] value, Encoding encoding, int start, int length);
    public AsciiString(ICharSequence value);
    public AsciiString(ICharSequence value, int start, int length);
    public AsciiString(string value, Encoding encoding);
    public AsciiString(string value, Encoding encoding, int start, int length);
    public AsciiString(string value);
    public AsciiString(string value, int start, int length);
    private static AsciiString();
    public int ForEachByte(IByteProcessor visitor);
    public int ForEachByte(int index, int count, IByteProcessor visitor);
    private int ForEachByte0(int index, int count, IByteProcessor visitor);
    public int ForEachByteDesc(IByteProcessor visitor);
    public int ForEachByteDesc(int index, int count, IByteProcessor visitor);
    private int ForEachByteDesc0(int index, int count, IByteProcessor visitor);
    public byte ByteAt(int index);
    public bool get_IsEmpty();
    public sealed virtual int get_Count();
    public void ArrayChanged();
    public Byte[] get_Array();
    public int get_Offset();
    public bool get_IsEntireArrayUsed();
    public Byte[] ToByteArray();
    public Byte[] ToByteArray(int start, int end);
    public void Copy(int srcIdx, Byte[] dst, int dstIdx, int count);
    public sealed virtual char get_Item(int index);
    public bool Contains(ICharSequence sequence);
    public int CompareTo(ICharSequence other);
    public AsciiString Concat(ICharSequence charSequence);
    public bool EndsWith(ICharSequence suffix);
    public sealed virtual bool ContentEqualsIgnoreCase(ICharSequence other);
    public Char[] ToCharArray();
    public Char[] ToCharArray(int start, int end);
    public void Copy(int srcIdx, Char[] dst, int dstIdx, int count);
    public sealed virtual ICharSequence SubSequence(int start);
    public sealed virtual ICharSequence SubSequence(int start, int end);
    public AsciiString SubSequence(int start, int end, bool copy);
    public int IndexOf(ICharSequence sequence);
    public int IndexOf(ICharSequence subString, int start);
    public sealed virtual int IndexOf(char ch, int start);
    public int LastIndexOf(ICharSequence charSequence);
    public int LastIndexOf(ICharSequence subString, int start);
    public sealed virtual bool RegionMatches(int thisStart, ICharSequence seq, int start, int count);
    public sealed virtual bool RegionMatchesIgnoreCase(int thisStart, ICharSequence seq, int start, int count);
    public AsciiString Replace(char oldChar, char newChar);
    public bool StartsWith(ICharSequence prefix);
    public bool StartsWith(ICharSequence prefix, int start);
    public AsciiString ToLowerCase();
    public AsciiString ToUpperCase();
    public static ICharSequence Trim(ICharSequence c);
    public AsciiString Trim();
    public bool ContentEquals(string a);
    public sealed virtual bool ContentEquals(ICharSequence a);
    public AsciiString[] Split(char delim);
    public virtual int GetHashCode();
    public sealed virtual bool Equals(AsciiString other);
    public virtual bool Equals(object obj);
    public virtual string ToString();
    public sealed virtual string ToString(int start);
    public string ToString(int start, int end);
    public bool ParseBoolean();
    public char ParseChar();
    public char ParseChar(int start);
    public short ParseShort();
    public short ParseShort(int radix);
    public short ParseShort(int start, int end);
    public short ParseShort(int start, int end, int radix);
    public int ParseInt();
    public int ParseInt(int radix);
    public int ParseInt(int start, int end);
    public int ParseInt(int start, int end, int radix);
    private int ParseInt(int start, int end, int radix, bool negative);
    public long ParseLong();
    public long ParseLong(int radix);
    public long ParseLong(int start, int end);
    public long ParseLong(int start, int end, int radix);
    private long ParseLong(int start, int end, int radix, bool negative);
    public float ParseFloat();
    public float ParseFloat(int start, int end);
    public double ParseDouble();
    public double ParseDouble(int start, int end);
    public static AsciiString Of(string value);
    public static AsciiString Of(ICharSequence charSequence);
    public static AsciiString Cached(string value);
    public static int GetHashCode(ICharSequence value);
    public static bool Contains(ICharSequence a, ICharSequence b);
    public static bool ContainsIgnoreCase(ICharSequence a, ICharSequence b);
    public static bool ContentEqualsIgnoreCase(ICharSequence a, ICharSequence b);
    public static bool ContainsContentEqualsIgnoreCase(ICollection`1<ICharSequence> collection, ICharSequence value);
    public static bool ContainsAllContentEqualsIgnoreCase(ICollection`1<ICharSequence> a, ICollection`1<AsciiString> b);
    public static bool ContentEquals(ICharSequence a, ICharSequence b);
    private static bool Contains(ICharSequence a, ICharSequence b, ICharEqualityComparator comparator);
    private static bool RegionMatchesCharSequences(ICharSequence cs, int csStart, ICharSequence seq, int start, int length, ICharEqualityComparator charEqualityComparator);
    public static bool RegionMatches(ICharSequence cs, bool ignoreCase, int csStart, ICharSequence seq, int start, int length);
    public static bool RegionMatchesAscii(ICharSequence cs, bool ignoreCase, int csStart, ICharSequence seq, int start, int length);
    public static int IndexOfIgnoreCase(ICharSequence str, ICharSequence searchStr, int startPos);
    public static int IndexOfIgnoreCaseAscii(ICharSequence str, ICharSequence searchStr, int startPos);
    public static int IndexOf(ICharSequence cs, char searchChar, int start);
    private static bool EqualsIgnoreCase(byte a, byte b);
    private static bool EqualsIgnoreCase(char a, char b);
    private static byte ToLowerCase(byte b);
    private static char ToLowerCase(char c);
    private static byte ToUpperCase(byte b);
    private static bool IsLowerCase(byte value);
    public static bool IsUpperCase(byte value);
    public static bool IsUpperCase(char value);
    public static byte CharToByte(char c);
    public static char ByteToChar(byte b);
    public static string op_Explicit(AsciiString value);
    public static AsciiString op_Explicit(string value);
    private static void GetBytes(Char* chars, int length, Byte* bytes);
    public sealed virtual int HashCode(bool ignoreCase);
    public sealed virtual int CompareTo(AsciiString other);
    public sealed virtual int CompareTo(object obj);
    public sealed virtual IEnumerator`1<char> GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    private static void ThrowIndexOutOfRangeException_Start(int start, int length, int count);
    private static void ThrowIndexOutOfRangeException_StartEnd(int start, int end, int length);
    private static void ThrowIndexOutOfRangeException_SrcIndex(int start, int count, int length);
    private static void ThrowIndexOutOfRangeException_Index(int index, int length, int count);
    private static void ThrowIndexOutOfRangeException_Index(int index, int length);
    [CompilerGeneratedAttribute]
internal static IndexOutOfRangeException <ThrowIndexOutOfRangeException_Start>g__GetIndexOutOfRangeException|142_0(<>c__DisplayClass142_0& );
    [CompilerGeneratedAttribute]
internal static IndexOutOfRangeException <ThrowIndexOutOfRangeException_StartEnd>g__GetIndexOutOfRangeException|143_0(<>c__DisplayClass143_0& );
    [CompilerGeneratedAttribute]
internal static IndexOutOfRangeException <ThrowIndexOutOfRangeException_SrcIndex>g__GetIndexOutOfRangeException|144_0(<>c__DisplayClass144_0& );
    [CompilerGeneratedAttribute]
internal static IndexOutOfRangeException <ThrowIndexOutOfRangeException_Index>g__GetIndexOutOfRangeException|145_0(<>c__DisplayClass145_0& );
    [CompilerGeneratedAttribute]
internal static IndexOutOfRangeException <ThrowIndexOutOfRangeException_Index>g__GetIndexOutOfRangeException|146_0(<>c__DisplayClass146_0& );
}
public class DotNetty.Common.Utilities.AtomicReference`1 : object {
    private T atomicValue;
    public T Value { get; public set; }
    public AtomicReference`1(T originalValue);
    public T get_Value();
    public void set_Value(T value);
    public bool CompareAndSet(T expected, T newValue);
    public static T op_Implicit(AtomicReference`1<T> aRef);
    public static AtomicReference`1<T> op_Implicit(T newValue);
}
internal static class DotNetty.Common.Utilities.AttributeKey : object {
    public static ConstantPool Pool;
    private static AttributeKey();
}
public class DotNetty.Common.Utilities.AttributeKey`1 : AbstractConstant`1<AttributeKey`1<T>> {
    public static ConstantPool Pool;
    internal AttributeKey`1(int id, string name);
    private static AttributeKey`1();
    public static AttributeKey`1<T> ValueOf(string name);
    public static bool Exists(string name);
    public static AttributeKey`1<T> NewInstance(string name);
    public static AttributeKey`1<T> ValueOf(Type firstNameComponent, string secondNameComponent);
}
[ExtensionAttribute]
public static class DotNetty.Common.Utilities.BitOps : object {
    [ExtensionAttribute]
public static int RightUShift(int value, int bits);
    [ExtensionAttribute]
public static long RightUShift(long value, int bits);
}
public class DotNetty.Common.Utilities.ByteProcessor : object {
    private Func`2<byte, bool> customHandler;
    public static IByteProcessor FindNul;
    public static IByteProcessor FindNonNul;
    public static IByteProcessor FindCR;
    public static IByteProcessor FindNonCR;
    public static IByteProcessor FindLF;
    public static IByteProcessor FindNonLF;
    public static IByteProcessor FindSemicolon;
    public static IByteProcessor FindComma;
    public static IByteProcessor FindAsciiSpace;
    public static IByteProcessor FindCrlf;
    public static IByteProcessor FindNonCrlf;
    public static IByteProcessor FindLinearWhitespace;
    public static IByteProcessor FindNonLinearWhitespace;
    public ByteProcessor(Func`2<byte, bool> customHandler);
    private static ByteProcessor();
    public sealed virtual bool Process(byte value);
}
internal static class DotNetty.Common.Utilities.ByteProcessorUtils : object {
    internal static byte Space;
    internal static byte HTab;
    internal static byte CarriageReturn;
    internal static byte LineFeed;
    private static ByteProcessorUtils();
}
internal class DotNetty.Common.Utilities.CharSequenceEnumerator : ValueType {
    private ICharSequence charSequence;
    private int index;
    private char currentElement;
    private object System.Collections.IEnumerator.Current { get; }
    public char Current { get; }
    internal CharSequenceEnumerator(ICharSequence charSequence);
    public sealed virtual bool MoveNext();
    private sealed virtual override object System.Collections.IEnumerator.get_Current();
    public sealed virtual char get_Current();
    public sealed virtual void Reset();
    public sealed virtual void Dispose();
}
[ExtensionAttribute]
public static class DotNetty.Common.Utilities.CharUtil : object {
    public static string Digits;
    public static int MinRadix;
    public static int MaxRadix;
    private static string DigitKeys;
    private static Char[] DigitValues;
    private static CharUtil();
    public static int BinarySearchRange(string data, char c);
    public static int ParseInt(ICharSequence seq, int start, int end, int radix);
    public static int ParseInt(ICharSequence seq);
    public static int ParseInt(ICharSequence seq, int start, int end, int radix, bool negative);
    public static long ParseLong(ICharSequence str, int radix);
    private static long ParseLong(ICharSequence str, int offset, int radix, bool negative);
    private static void ThrowFormatException(ICharSequence str);
    public static bool IsNullOrEmpty(ICharSequence sequence);
    public static ICharSequence[] Split(ICharSequence sequence, Char[] delimiters);
    public static ICharSequence[] Split(ICharSequence sequence, int startIndex, Char[] delimiters);
    internal static bool ContentEquals(ICharSequence left, ICharSequence right);
    internal static bool ContentEqualsIgnoreCase(ICharSequence left, ICharSequence right);
    public static bool RegionMatches(string value, int thisStart, ICharSequence other, int start, int length);
    public static bool RegionMatchesIgnoreCase(string value, int thisStart, ICharSequence other, int start, int length);
    public static bool RegionMatches(IReadOnlyList`1<char> value, int thisStart, ICharSequence other, int start, int length);
    public static bool RegionMatchesIgnoreCase(IReadOnlyList`1<char> value, int thisStart, ICharSequence other, int start, int length);
    [ExtensionAttribute]
public static ICharSequence SubstringAfter(ICharSequence value, char delim);
    public static ICharSequence Trim(ICharSequence sequence);
    private static int IndexOfFirstNonWhiteSpace(IReadOnlyList`1<char> value);
    private static int IndexOfLastNonWhiteSpaceChar(IReadOnlyList`1<char> value, int start);
    public static bool Contains(IReadOnlyList`1<char> value, char c);
    public static int Digit(byte b);
    public static int Digit(char c, int radix);
    public static bool IsISOControl(int c);
    [ExtensionAttribute]
public static int IndexOf(ICharSequence cs, char searchChar, int start);
    private static int IndexOf(Char[] tokens, char value);
    public static int CodePointAt(IReadOnlyList`1<char> seq, int index);
    public static int ToCodePoint(char high, char low);
    private static bool IsSurrogatePair(char high, char low);
    internal static int IndexOf(IReadOnlyList`1<char> value, char ch, int start);
}
public abstract class DotNetty.Common.Utilities.ConstantPool : object {
    private Dictionary`2<string, IConstant> constants;
    private int nextId;
    public IConstant ValueOf(Type firstNameComponent, string secondNameComponent);
    public IConstant ValueOf(string name);
    public bool Exists(string name);
    public IConstant NewInstance(string name);
    private IConstant NewInstance0(string name);
    private static void CheckNotNullAndNotEmpty(string name);
    protected abstract virtual IConstant NewConstant(int id, string name);
    [ObsoleteAttribute]
public int NextId();
}
[ExtensionAttribute]
public static class DotNetty.Common.Utilities.DebugExtensions : object {
    [ExtensionAttribute]
public static string ToDebugString(IDictionary`2<TKey, TValue> dictionary);
}
public class DotNetty.Common.Utilities.DefaultAttributeMap : object {
    private static int BucketSize;
    private static int Mask;
    private DefaultAttribute[] modreq(System.Runtime.CompilerServices.IsVolatile) attributes;
    public sealed virtual IAttribute`1<T> GetAttribute(AttributeKey`1<T> key);
    public sealed virtual bool HasAttribute(AttributeKey`1<T> key);
    private static int Index(AttributeKey`1<T> key);
}
public class DotNetty.Common.Utilities.DefaultHashingStrategy`1 : object {
    public sealed virtual int GetHashCode(T obj);
    public sealed virtual int HashCode(T obj);
    public sealed virtual bool Equals(T a, T b);
}
public class DotNetty.Common.Utilities.HashedWheelTimer : object {
    private static IInternalLogger Logger;
    private static int instanceCounter;
    private static int warnedTooManyInstances;
    private static int InstanceCountLimit;
    private Worker worker;
    private Thread workerThread;
    private CancellationTokenSource cancellationTokenSource;
    private static int WorkerStateInit;
    private static int WorkerStateStarted;
    private static int WorkerStateShutdown;
    private int workerStateVolatile;
    private long tickDuration;
    private HashedWheelBucket[] wheel;
    private int mask;
    private CountdownEvent startTimeInitialized;
    private IQueue`1<HashedWheelTimeout> timeouts;
    private IQueue`1<HashedWheelTimeout> cancelledTimeouts;
    internal long PendingTimeouts;
    private long maxPendingTimeouts;
    private long startTimeVolatile;
    internal CancellationToken CancellationToken { get; }
    private bool ShouldLimitTimeouts { get; }
    private PreciseTimeSpan StartTime { get; private set; }
    private int WorkerState { get; }
    public HashedWheelTimer(TimeSpan tickInterval, int ticksPerWheel, long maxPendingTimeouts);
    private static HashedWheelTimer();
    protected virtual override void Finalize();
    internal CancellationToken get_CancellationToken();
    private bool get_ShouldLimitTimeouts();
    private PreciseTimeSpan get_StartTime();
    private void set_StartTime(PreciseTimeSpan value);
    private int get_WorkerState();
    private static HashedWheelBucket[] CreateWheel(int ticksPerWheel);
    private static int NormalizeTicksPerWheel(int ticksPerWheel);
    public void Start();
    [AsyncStateMachineAttribute("DotNetty.Common.Utilities.HashedWheelTimer/<StopAsync>d__35")]
public sealed virtual Task`1<ISet`1<ITimeout>> StopAsync();
    public sealed virtual ITimeout NewTimeout(ITimerTask task, TimeSpan delay);
    private void ScheduleCancellation(HashedWheelTimeout timeout);
    private static void ReportTooManyInstances();
    private static TimeSpan CeilTimeSpanToMilliseconds(TimeSpan time);
    [CompilerGeneratedAttribute]
private void <.ctor>b__21_0(object st);
}
public interface DotNetty.Common.Utilities.IAttribute`1 {
    public AttributeKey`1<T> Key { get; }
    public abstract virtual AttributeKey`1<T> get_Key();
    public abstract virtual T Get();
    public abstract virtual void Set(T value);
    public abstract virtual T GetAndSet(T value);
    public abstract virtual T SetIfAbsent(T value);
    public abstract virtual T GetAndRemove();
    public abstract virtual bool CompareAndSet(T oldValue, T newValue);
    public abstract virtual void Remove();
}
public interface DotNetty.Common.Utilities.IAttributeMap {
    public abstract virtual IAttribute`1<T> GetAttribute(AttributeKey`1<T> key);
    public abstract virtual bool HasAttribute(AttributeKey`1<T> key);
}
public interface DotNetty.Common.Utilities.IByteProcessor {
    public abstract virtual bool Process(byte value);
}
public interface DotNetty.Common.Utilities.ICharSequence {
    public abstract virtual ICharSequence SubSequence(int start, int end);
    public abstract virtual ICharSequence SubSequence(int start);
    public abstract virtual int IndexOf(char ch, int start);
    public abstract virtual bool RegionMatches(int thisStart, ICharSequence seq, int start, int length);
    public abstract virtual bool RegionMatchesIgnoreCase(int thisStart, ICharSequence seq, int start, int length);
    public abstract virtual bool ContentEquals(ICharSequence other);
    public abstract virtual bool ContentEqualsIgnoreCase(ICharSequence other);
    public abstract virtual int HashCode(bool ignoreCase);
    public abstract virtual string ToString(int start);
    public abstract virtual string ToString();
}
public interface DotNetty.Common.Utilities.IConstant {
    public int Id { get; }
    public string Name { get; }
    public abstract virtual int get_Id();
    public abstract virtual string get_Name();
}
public interface DotNetty.Common.Utilities.IHashingStrategy`1 {
    public abstract virtual int HashCode(T obj);
}
public class DotNetty.Common.Utilities.IllegalReferenceCountException : InvalidOperationException {
    public IllegalReferenceCountException(int count);
    public IllegalReferenceCountException(int refCnt, int increment);
}
public class DotNetty.Common.Utilities.IndexNotOfProcessor : object {
    private byte byteToNotFind;
    public IndexNotOfProcessor(byte byteToNotFind);
    public sealed virtual bool Process(byte value);
}
public class DotNetty.Common.Utilities.IndexOfProcessor : object {
    private byte byteToFind;
    public IndexOfProcessor(byte byteToFind);
    public sealed virtual bool Process(byte value);
}
public static class DotNetty.Common.Utilities.IntegerExtensions : object {
    private static Int32[] MultiplyDeBruijnBitPosition;
    public static int SizeInBits;
    private static IntegerExtensions();
    public static int RoundUpToPowerOfTwo(int res);
    public static int Log2(int v);
}
public interface DotNetty.Common.Utilities.ITimeout {
    public ITimer Timer { get; }
    public ITimerTask Task { get; }
    public bool Expired { get; }
    public bool Canceled { get; }
    public abstract virtual ITimer get_Timer();
    public abstract virtual ITimerTask get_Task();
    public abstract virtual bool get_Expired();
    public abstract virtual bool get_Canceled();
    public abstract virtual bool Cancel();
}
public interface DotNetty.Common.Utilities.ITimer {
    public abstract virtual ITimeout NewTimeout(ITimerTask task, TimeSpan delay);
    public abstract virtual Task`1<ISet`1<ITimeout>> StopAsync();
}
public interface DotNetty.Common.Utilities.ITimerTask {
    public abstract virtual void Run(ITimeout timeout);
}
[ExtensionAttribute]
public static class DotNetty.Common.Utilities.MediumUtil : object {
    private static UInt32 MediumBitMask;
    [ExtensionAttribute]
public static int ToMediumInt(int value);
    [ExtensionAttribute]
public static int ToUnsignedMediumInt(int value);
}
public static class DotNetty.Common.Utilities.NetUtil : object {
    public static string ToSocketAddressString(string host, int port);
    private static StringBuilder NewSocketAddressStringBuilder(string host, string port, bool ipv4);
    public static bool IsValidIpV6Address(string ip);
    private static bool IsValidIpV4Address(string ip, int from, int toExcluded);
    private static bool IsValidIpV4Word(string word, int from, int toExclusive);
    private static bool IsValidHexChar(char c);
    private static bool IsValidNumericChar(char c);
    private static bool IsValidIPv4MappedChar(char c);
}
public class DotNetty.Common.Utilities.PriorityQueue`1 : object {
    private IComparer`1<T> comparer;
    private int count;
    private int capacity;
    private T[] items;
    public int Count { get; }
    public PriorityQueue`1(IComparer`1<T> comparer);
    public int get_Count();
    public T Dequeue();
    public T Peek();
    public void Enqueue(T item);
    public void Remove(T item);
    private void BubbleUp(int index, T item);
    private void GrowHeap();
    private void TrickleDown(int index, T item);
    [IteratorStateMachineAttribute("DotNetty.Common.Utilities.PriorityQueue`1/<GetEnumerator>d__15")]
public sealed virtual IEnumerator`1<T> GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    public void Clear();
}
[ExtensionAttribute]
public static class DotNetty.Common.Utilities.RandomExtensions : object {
    [ExtensionAttribute]
public static long NextLong(Random random);
}
[ExtensionAttribute]
public static class DotNetty.Common.Utilities.ReferenceCountUtil : object {
    private static IInternalLogger Logger;
    private static ReferenceCountUtil();
    public static T Retain(T msg);
    public static T Retain(T msg, int increment);
    public static T Touch(T msg);
    public static T Touch(T msg, object hint);
    public static bool Release(object msg);
    public static bool Release(object msg, int decrement);
    public static void SafeRelease(object msg);
    public static void SafeRelease(object msg, int decrement);
    [ExtensionAttribute]
public static void SafeRelease(IReferenceCounted msg);
    [ExtensionAttribute]
public static void SafeRelease(IReferenceCounted msg, int decrement);
    public static T ReleaseLater(T msg);
    public static T ReleaseLater(T msg, int decrement);
    private static string FormatReleaseString(IReferenceCounted referenceCounted, int decrement);
}
public class DotNetty.Common.Utilities.ReferenceEqualityComparer : object {
    public static ReferenceEqualityComparer Default;
    private static ReferenceEqualityComparer();
    public sealed virtual bool Equals(object x, object y);
    public sealed virtual int GetHashCode(object obj);
}
public class DotNetty.Common.Utilities.Signal : Exception {
    private static SignalConstantPool Pool;
    private SignalConstant constant;
    public int Id { get; }
    public string Name { get; }
    private Signal(int id, string name);
    private static Signal();
    public static Signal ValueOf(string name);
    public static Signal ValueOf(Type firstNameComponent, string secondNameComponent);
    public void Expect(Signal signal);
    public sealed virtual int get_Id();
    public sealed virtual string get_Name();
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public sealed virtual int CompareTo(object obj);
    public sealed virtual int CompareTo(Signal other);
    public virtual string ToString();
}
[DefaultMemberAttribute("Item")]
public class DotNetty.Common.Utilities.StringBuilderCharSequence : object {
    private StringBuilder builder;
    private int offset;
    [CompilerGeneratedAttribute]
private int <Count>k__BackingField;
    public int Count { get; private set; }
    public char Item { get; }
    public StringBuilderCharSequence(int capacity);
    public StringBuilderCharSequence(StringBuilder builder);
    public StringBuilderCharSequence(StringBuilder builder, int offset, int count);
    public sealed virtual ICharSequence SubSequence(int start);
    public sealed virtual ICharSequence SubSequence(int start, int end);
    [CompilerGeneratedAttribute]
public sealed virtual int get_Count();
    [CompilerGeneratedAttribute]
private void set_Count(int value);
    public sealed virtual char get_Item(int index);
    public void Append(string value);
    public void Append(string value, int index, int count);
    public void Append(ICharSequence value);
    public void Append(ICharSequence value, int index, int count);
    public void Append(char value);
    public void Insert(int start, char value);
    public sealed virtual bool RegionMatches(int thisStart, ICharSequence seq, int start, int length);
    public sealed virtual bool RegionMatchesIgnoreCase(int thisStart, ICharSequence seq, int start, int length);
    public sealed virtual int IndexOf(char ch, int start);
    public sealed virtual string ToString(int start);
    public virtual string ToString();
    public sealed virtual bool Equals(StringBuilderCharSequence other);
    public virtual bool Equals(object obj);
    public sealed virtual int HashCode(bool ignoreCase);
    public virtual int GetHashCode();
    public sealed virtual bool ContentEquals(ICharSequence other);
    public sealed virtual bool ContentEqualsIgnoreCase(ICharSequence other);
    public sealed virtual IEnumerator`1<char> GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
}
[DefaultMemberAttribute("Item")]
public class DotNetty.Common.Utilities.StringCharSequence : object {
    public static StringCharSequence Empty;
    private string value;
    private int offset;
    private int count;
    public int Count { get; }
    public char Item { get; }
    public StringCharSequence(string value);
    public StringCharSequence(string value, int offset, int count);
    private static StringCharSequence();
    public sealed virtual int get_Count();
    public static string op_Explicit(StringCharSequence charSequence);
    public static StringCharSequence op_Explicit(string value);
    public sealed virtual ICharSequence SubSequence(int start);
    public sealed virtual ICharSequence SubSequence(int start, int end);
    public sealed virtual char get_Item(int index);
    public sealed virtual bool RegionMatches(int thisStart, ICharSequence seq, int start, int length);
    public sealed virtual bool RegionMatchesIgnoreCase(int thisStart, ICharSequence seq, int start, int length);
    public sealed virtual int IndexOf(char ch, int start);
    public int IndexOf(string target, int start);
    public sealed virtual string ToString(int start);
    public virtual string ToString();
    public sealed virtual bool Equals(StringCharSequence other);
    public virtual bool Equals(object obj);
    public sealed virtual int HashCode(bool ignoreCase);
    public virtual int GetHashCode();
    public sealed virtual bool ContentEquals(ICharSequence other);
    public sealed virtual bool ContentEqualsIgnoreCase(ICharSequence other);
    public sealed virtual IEnumerator`1<char> GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
}
public static class DotNetty.Common.Utilities.StringUtil : object {
    public static string EmptyString;
    public static string Newline;
    public static char DoubleQuote;
    public static char Comma;
    public static char LineFeed;
    public static char CarriageReturn;
    public static char Tab;
    public static char Space;
    public static byte UpperCaseToLowerCaseAsciiOffset;
    private static String[] Byte2HexPad;
    private static String[] Byte2HexNopad;
    private static int CsvNumberEscapeCharacters;
    private static StringUtil();
    public static string SubstringAfter(string value, char delim);
    public static bool CommonSuffixOfLength(string s, string p, int len);
    private static bool RegionMatches(string value, int thisStart, string other, int start, int length);
    public static string ByteToHexStringPadded(int value);
    public static T ByteToHexStringPadded(T buf, int value);
    public static string ToHexStringPadded(Byte[] src);
    public static string ToHexStringPadded(Byte[] src, int offset, int length);
    public static T ToHexStringPadded(T dst, Byte[] src);
    public static T ToHexStringPadded(T dst, Byte[] src, int offset, int length);
    public static string ByteToHexString(byte value);
    public static T ByteToHexString(T buf, byte value);
    public static string ToHexString(Byte[] src);
    public static string ToHexString(Byte[] src, int offset, int length);
    public static T ToHexString(T dst, Byte[] src);
    public static T ToHexString(T dst, Byte[] src, int offset, int length);
    public static int DecodeHexNibble(char c);
    public static byte DecodeHexByte(string s, int pos);
    public static Byte[] DecodeHexDump(string hexDump, int fromIndex, int length);
    public static Byte[] DecodeHexDump(string hexDump);
    public static string SimpleClassName(object o);
    public static string SimpleClassName();
    public static string SimpleClassName(Type type);
    public static ICharSequence EscapeCsv(ICharSequence value, bool trimWhiteSpace);
    public static ICharSequence UnescapeCsv(ICharSequence value);
    public static IList`1<ICharSequence> UnescapeCsvFields(ICharSequence value);
    private static void ValidateCsvFormat(ICharSequence value);
    private static ArgumentException NewInvalidEscapedCsvFieldException(ICharSequence value, int index);
    public static int Length(string s);
    public static int IndexOfNonWhiteSpace(IReadOnlyList`1<char> seq, int offset);
    public static bool IsSurrogate(char c);
    private static bool IsDoubleQuote(char c);
    public static bool EndsWith(IReadOnlyList`1<char> s, char c);
    public static ICharSequence TrimOws(ICharSequence value);
    private static int IndexOfFirstNonOwsChar(IReadOnlyList`1<char> value, int length);
    private static int IndexOfLastNonOwsChar(IReadOnlyList`1<char> value, int start, int length);
    private static bool IsOws(char c);
}
[ExtensionAttribute]
public static class DotNetty.Common.Utilities.TaskEx : object {
    public static Task`1<int> Zero;
    public static Task`1<int> Completed;
    public static Task`1<int> Cancelled;
    public static Task`1<bool> True;
    public static Task`1<bool> False;
    private static Action`2<Task, object> LinkOutcomeContinuationAction;
    private static TaskEx();
    private static Task`1<int> CreateCancelledTask();
    public static Task FromException(Exception exception);
    public static Task`1<T> FromException(Exception exception);
    [ExtensionAttribute]
public static void LinkOutcome(Task task, TaskCompletionSource taskCompletionSource);
    [ExtensionAttribute]
public static void LinkOutcome(Task`1<T> task, TaskCompletionSource`1<T> taskCompletionSource);
    [ExtensionAttribute]
public static void TryUnwrap(TaskCompletionSource`1<T> completionSource, Exception exception);
    [ExtensionAttribute]
public static Exception Unwrap(Exception exception);
}
[ExtensionAttribute]
public static class DotNetty.Common.Utilities.ThreadExtensions : object {
    [ExtensionAttribute]
public static bool Join(Thread thread, TimeSpan timeout);
}
public static class DotNetty.Common.Utilities.TimeUtil : object {
    private static TimeUtil();
    public static TimeSpan Max(TimeSpan t1, TimeSpan t2);
    public static TimeSpan GetSystemTime();
}
