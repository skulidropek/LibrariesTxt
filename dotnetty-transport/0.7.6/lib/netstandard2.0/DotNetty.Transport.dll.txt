public abstract class DotNetty.Transport.Bootstrapping.AbstractBootstrap`2 : object {
    private static IInternalLogger Logger;
    private IEventLoopGroup modreq(System.Runtime.CompilerServices.IsVolatile) group;
    private Func`1 modreq(System.Runtime.CompilerServices.IsVolatile) channelFactory;
    private EndPoint modreq(System.Runtime.CompilerServices.IsVolatile) localAddress;
    private ConcurrentDictionary`2<ChannelOption, ChannelOptionValue<TBootstrap, TChannel>> options;
    private ConcurrentDictionary`2<IConstant, AttributeValue<TBootstrap, TChannel>> attrs;
    private IChannelHandler modreq(System.Runtime.CompilerServices.IsVolatile) handler;
    protected ICollection`1<ChannelOptionValue<TBootstrap, TChannel>> Options { get; }
    protected ICollection`1<AttributeValue<TBootstrap, TChannel>> Attributes { get; }
    protected internal AbstractBootstrap`2(AbstractBootstrap`2<TBootstrap, TChannel> bootstrap);
    private static AbstractBootstrap`2();
    public virtual TBootstrap Group(IEventLoopGroup group);
    public TBootstrap Channel();
    public TBootstrap ChannelFactory(Func`1<TChannel> channelFactory);
    public TBootstrap LocalAddress(EndPoint localAddress);
    public TBootstrap LocalAddress(int inetPort);
    public TBootstrap LocalAddress(string inetHost, int inetPort);
    public TBootstrap LocalAddress(IPAddress inetHost, int inetPort);
    public TBootstrap Option(ChannelOption`1<T> option, T value);
    public TBootstrap Attribute(AttributeKey`1<T> key, T value);
    public virtual TBootstrap Validate();
    public abstract virtual TBootstrap Clone();
    public Task RegisterAsync();
    public Task`1<IChannel> BindAsync();
    public Task`1<IChannel> BindAsync(int inetPort);
    public Task`1<IChannel> BindAsync(string inetHost, int inetPort);
    public Task`1<IChannel> BindAsync(IPAddress inetHost, int inetPort);
    public Task`1<IChannel> BindAsync(EndPoint localAddress);
    [AsyncStateMachineAttribute("DotNetty.Transport.Bootstrapping.AbstractBootstrap`2/<DoBindAsync>d__26")]
private Task`1<IChannel> DoBindAsync(EndPoint localAddress);
    [AsyncStateMachineAttribute("DotNetty.Transport.Bootstrapping.AbstractBootstrap`2/<InitAndRegisterAsync>d__27")]
protected Task`1<IChannel> InitAndRegisterAsync();
    private static Task DoBind0Async(IChannel channel, EndPoint localAddress);
    protected abstract virtual void Init(IChannel channel);
    public TBootstrap Handler(IChannelHandler handler);
    protected EndPoint LocalAddress();
    protected IChannelHandler Handler();
    public IEventLoopGroup Group();
    protected ICollection`1<ChannelOptionValue<TBootstrap, TChannel>> get_Options();
    protected ICollection`1<AttributeValue<TBootstrap, TChannel>> get_Attributes();
    protected static void SetChannelOptions(IChannel channel, ICollection`1<ChannelOptionValue<TBootstrap, TChannel>> options, IInternalLogger logger);
    protected static void SetChannelOptions(IChannel channel, ChannelOptionValue[] options, IInternalLogger logger);
    protected static void SetChannelOption(IChannel channel, ChannelOptionValue<TBootstrap, TChannel> option, IInternalLogger logger);
    public virtual string ToString();
}
public class DotNetty.Transport.Bootstrapping.Bootstrap : AbstractBootstrap`2<Bootstrap, IChannel> {
    private static IInternalLogger Logger;
    private static INameResolver DefaultResolver;
    private INameResolver modreq(System.Runtime.CompilerServices.IsVolatile) resolver;
    private EndPoint modreq(System.Runtime.CompilerServices.IsVolatile) remoteAddress;
    private Bootstrap(Bootstrap bootstrap);
    private static Bootstrap();
    public Bootstrap Resolver(INameResolver resolver);
    public Bootstrap RemoteAddress(EndPoint remoteAddress);
    public Bootstrap RemoteAddress(string inetHost, int inetPort);
    public Bootstrap RemoteAddress(IPAddress inetHost, int inetPort);
    public Task`1<IChannel> ConnectAsync();
    public Task`1<IChannel> ConnectAsync(string inetHost, int inetPort);
    public Task`1<IChannel> ConnectAsync(IPAddress inetHost, int inetPort);
    public Task`1<IChannel> ConnectAsync(EndPoint remoteAddress);
    public Task`1<IChannel> ConnectAsync(EndPoint remoteAddress, EndPoint localAddress);
    [AsyncStateMachineAttribute("DotNetty.Transport.Bootstrapping.Bootstrap/<DoResolveAndConnectAsync>d__15")]
private Task`1<IChannel> DoResolveAndConnectAsync(EndPoint remoteAddress, EndPoint localAddress);
    private static Task DoConnectAsync(IChannel channel, EndPoint remoteAddress, EndPoint localAddress);
    protected virtual void Init(IChannel channel);
    public virtual Bootstrap Validate();
    public virtual Bootstrap Clone();
    public Bootstrap Clone(IEventLoopGroup group);
    public virtual string ToString();
}
public class DotNetty.Transport.Bootstrapping.DefaultNameResolver : object {
    public sealed virtual bool IsResolved(EndPoint address);
    [AsyncStateMachineAttribute("DotNetty.Transport.Bootstrapping.DefaultNameResolver/<ResolveAsync>d__1")]
public sealed virtual Task`1<EndPoint> ResolveAsync(EndPoint address);
}
public interface DotNetty.Transport.Bootstrapping.INameResolver {
    public abstract virtual bool IsResolved(EndPoint address);
    public abstract virtual Task`1<EndPoint> ResolveAsync(EndPoint address);
}
public class DotNetty.Transport.Bootstrapping.ServerBootstrap : AbstractBootstrap`2<ServerBootstrap, IServerChannel> {
    private static IInternalLogger Logger;
    private ConcurrentDictionary`2<ChannelOption, ChannelOptionValue<ServerBootstrap, IServerChannel>> childOptions;
    private ConcurrentDictionary`2<IConstant, AttributeValue<ServerBootstrap, IServerChannel>> childAttrs;
    private IEventLoopGroup modreq(System.Runtime.CompilerServices.IsVolatile) childGroup;
    private IChannelHandler modreq(System.Runtime.CompilerServices.IsVolatile) childHandler;
    private ServerBootstrap(ServerBootstrap bootstrap);
    private static ServerBootstrap();
    public virtual ServerBootstrap Group(IEventLoopGroup group);
    public ServerBootstrap Group(IEventLoopGroup parentGroup, IEventLoopGroup childGroup);
    public ServerBootstrap ChildOption(ChannelOption`1<T> childOption, T value);
    public ServerBootstrap ChildAttribute(AttributeKey`1<T> childKey, T value);
    public ServerBootstrap ChildHandler(IChannelHandler childHandler);
    public IEventLoopGroup ChildGroup();
    protected virtual void Init(IChannel channel);
    public virtual ServerBootstrap Validate();
    public virtual ServerBootstrap Clone();
    public virtual string ToString();
}
public abstract class DotNetty.Transport.Channels.AbstractChannel : DefaultAttributeMap {
    private static IInternalLogger Logger;
    private static NotYetConnectedException NotYetConnectedException;
    private IChannelUnsafe channelUnsafe;
    private DefaultChannelPipeline pipeline;
    private TaskCompletionSource closeFuture;
    private EndPoint modreq(System.Runtime.CompilerServices.IsVolatile) localAddress;
    private EndPoint modreq(System.Runtime.CompilerServices.IsVolatile) remoteAddress;
    private IEventLoop modreq(System.Runtime.CompilerServices.IsVolatile) eventLoop;
    private Boolean modreq(System.Runtime.CompilerServices.IsVolatile) registered;
    private bool strValActive;
    private string strVal;
    [CompilerGeneratedAttribute]
private IChannelId <Id>k__BackingField;
    [CompilerGeneratedAttribute]
private IChannel <Parent>k__BackingField;
    public IChannelId Id { get; }
    public bool IsWritable { get; }
    public IChannel Parent { get; }
    public IChannelPipeline Pipeline { get; }
    public IChannelConfiguration Configuration { get; }
    public IByteBufferAllocator Allocator { get; }
    public IEventLoop EventLoop { get; }
    public bool Open { get; }
    public bool Active { get; }
    public ChannelMetadata Metadata { get; }
    public EndPoint LocalAddress { get; }
    public EndPoint RemoteAddress { get; }
    protected EndPoint LocalAddressInternal { get; }
    protected EndPoint RemoteAddressInternal { get; }
    public bool Registered { get; }
    public Task CloseCompletion { get; }
    public IChannelUnsafe Unsafe { get; }
    protected AbstractChannel(IChannel parent);
    protected AbstractChannel(IChannel parent, IChannelId id);
    private static AbstractChannel();
    [CompilerGeneratedAttribute]
public sealed virtual IChannelId get_Id();
    public sealed virtual bool get_IsWritable();
    [CompilerGeneratedAttribute]
public sealed virtual IChannel get_Parent();
    public sealed virtual IChannelPipeline get_Pipeline();
    public abstract virtual IChannelConfiguration get_Configuration();
    public sealed virtual IByteBufferAllocator get_Allocator();
    public sealed virtual IEventLoop get_EventLoop();
    public abstract virtual bool get_Open();
    public abstract virtual bool get_Active();
    public abstract virtual ChannelMetadata get_Metadata();
    public sealed virtual EndPoint get_LocalAddress();
    public sealed virtual EndPoint get_RemoteAddress();
    protected abstract virtual EndPoint get_LocalAddressInternal();
    protected void InvalidateLocalAddress();
    protected EndPoint CacheLocalAddress();
    protected abstract virtual EndPoint get_RemoteAddressInternal();
    protected void InvalidateRemoteAddress();
    protected EndPoint CacheRemoteAddress();
    public sealed virtual bool get_Registered();
    protected virtual IChannelId NewId();
    protected virtual DefaultChannelPipeline NewChannelPipeline();
    public virtual Task BindAsync(EndPoint localAddress);
    public virtual Task ConnectAsync(EndPoint remoteAddress);
    public virtual Task ConnectAsync(EndPoint remoteAddress, EndPoint localAddress);
    public virtual Task DisconnectAsync();
    public virtual Task CloseAsync();
    public sealed virtual Task DeregisterAsync();
    public sealed virtual IChannel Flush();
    public sealed virtual IChannel Read();
    public sealed virtual Task WriteAsync(object msg);
    public sealed virtual Task WriteAndFlushAsync(object message);
    public sealed virtual Task get_CloseCompletion();
    public sealed virtual IChannelUnsafe get_Unsafe();
    protected abstract virtual IChannelUnsafe NewUnsafe();
    public virtual int GetHashCode();
    public virtual bool Equals(object o);
    public sealed virtual int CompareTo(IChannel o);
    public virtual string ToString();
    protected abstract virtual bool IsCompatible(IEventLoop eventLoop);
    protected virtual void DoRegister();
    protected abstract virtual void DoBind(EndPoint localAddress);
    protected abstract virtual void DoDisconnect();
    protected abstract virtual void DoClose();
    protected virtual void DoDeregister();
    protected abstract virtual void DoBeginRead();
    protected abstract virtual void DoWrite(ChannelOutboundBuffer input);
    protected virtual object FilterOutboundMessage(object msg);
}
internal abstract class DotNetty.Transport.Channels.AbstractChannelHandlerContext : object {
    private static Action`1<object> InvokeChannelReadCompleteAction;
    private static Action`1<object> InvokeReadAction;
    private static Action`1<object> InvokeChannelWritabilityChangedAction;
    private static Action`1<object> InvokeFlushAction;
    private static Action`2<object, object> InvokeUserEventTriggeredAction;
    private static Action`2<object, object> InvokeChannelReadAction;
    private static ConditionalWeakTable`2<Type, Tuple`1<SkipFlags>> SkipTable;
    internal AbstractChannelHandlerContext modreq(System.Runtime.CompilerServices.IsVolatile) Next;
    internal AbstractChannelHandlerContext modreq(System.Runtime.CompilerServices.IsVolatile) Prev;
    internal SkipFlags SkipPropagationFlags;
    internal DefaultChannelPipeline pipeline;
    internal IEventExecutor executor;
    private HandlerState handlerState;
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    private static string ExceptionCaughtMethodName;
    public IChannel Channel { get; }
    public IByteBufferAllocator Allocator { get; }
    public IChannelHandler Handler { get; }
    public bool Added { get; }
    public bool Removed { get; }
    public IEventExecutor Executor { get; }
    public string Name { get; }
    protected AbstractChannelHandlerContext(DefaultChannelPipeline pipeline, IEventExecutor executor, string name, SkipFlags skipPropagationDirections);
    private static AbstractChannelHandlerContext();
    protected static SkipFlags GetSkipPropagationFlags(IChannelHandler handler);
    protected static SkipFlags CalculateSkipPropagationFlags(Type handlerType);
    protected static bool IsSkippable(Type handlerType, string methodName);
    protected static bool IsSkippable(Type handlerType, string methodName, Type[] paramTypes);
    public sealed virtual IChannel get_Channel();
    public sealed virtual IByteBufferAllocator get_Allocator();
    public abstract virtual IChannelHandler get_Handler();
    public bool get_Added();
    public sealed virtual bool get_Removed();
    internal void SetAdded();
    internal void SetRemoved();
    public sealed virtual IEventExecutor get_Executor();
    [CompilerGeneratedAttribute]
public sealed virtual string get_Name();
    public sealed virtual IAttribute`1<T> GetAttribute(AttributeKey`1<T> key);
    public sealed virtual bool HasAttribute(AttributeKey`1<T> key);
    public sealed virtual IChannelHandlerContext FireChannelRegistered();
    internal static void InvokeChannelRegistered(AbstractChannelHandlerContext next);
    private void InvokeChannelRegistered();
    public sealed virtual IChannelHandlerContext FireChannelUnregistered();
    internal static void InvokeChannelUnregistered(AbstractChannelHandlerContext next);
    private void InvokeChannelUnregistered();
    public sealed virtual IChannelHandlerContext FireChannelActive();
    internal static void InvokeChannelActive(AbstractChannelHandlerContext next);
    private void InvokeChannelActive();
    public sealed virtual IChannelHandlerContext FireChannelInactive();
    internal static void InvokeChannelInactive(AbstractChannelHandlerContext next);
    private void InvokeChannelInactive();
    public virtual IChannelHandlerContext FireExceptionCaught(Exception cause);
    internal static void InvokeExceptionCaught(AbstractChannelHandlerContext next, Exception cause);
    private void InvokeExceptionCaught(Exception cause);
    public sealed virtual IChannelHandlerContext FireUserEventTriggered(object evt);
    internal static void InvokeUserEventTriggered(AbstractChannelHandlerContext next, object evt);
    private void InvokeUserEventTriggered(object evt);
    public sealed virtual IChannelHandlerContext FireChannelRead(object msg);
    internal static void InvokeChannelRead(AbstractChannelHandlerContext next, object msg);
    private void InvokeChannelRead(object msg);
    public sealed virtual IChannelHandlerContext FireChannelReadComplete();
    internal static void InvokeChannelReadComplete(AbstractChannelHandlerContext next);
    private void InvokeChannelReadComplete();
    public sealed virtual IChannelHandlerContext FireChannelWritabilityChanged();
    internal static void InvokeChannelWritabilityChanged(AbstractChannelHandlerContext next);
    private void InvokeChannelWritabilityChanged();
    public sealed virtual Task BindAsync(EndPoint localAddress);
    private Task InvokeBindAsync(EndPoint localAddress);
    public sealed virtual Task ConnectAsync(EndPoint remoteAddress);
    public sealed virtual Task ConnectAsync(EndPoint remoteAddress, EndPoint localAddress);
    private Task InvokeConnectAsync(EndPoint remoteAddress, EndPoint localAddress);
    public sealed virtual Task DisconnectAsync();
    private Task InvokeDisconnectAsync();
    public sealed virtual Task CloseAsync();
    private Task InvokeCloseAsync();
    public sealed virtual Task DeregisterAsync();
    private Task InvokeDeregisterAsync();
    public sealed virtual IChannelHandlerContext Read();
    private void InvokeRead();
    public sealed virtual Task WriteAsync(object msg);
    private Task InvokeWriteAsync(object msg);
    private Task InvokeWriteAsync0(object msg);
    public sealed virtual IChannelHandlerContext Flush();
    private void InvokeFlush();
    private void InvokeFlush0();
    public sealed virtual Task WriteAndFlushAsync(object message);
    private Task InvokeWriteAndFlushAsync(object msg);
    private Task WriteAsync(object msg, bool flush);
    private void NotifyHandlerException(Exception cause);
    private static Task ComposeExceptionTask(Exception cause);
    private static bool InExceptionCaught(Exception cause);
    private AbstractChannelHandlerContext FindContextInbound();
    private AbstractChannelHandlerContext FindContextOutbound();
    private static Task SafeExecuteOutboundAsync(IEventExecutor executor, Func`1<Task> function);
    private static void SafeExecuteOutbound(IEventExecutor executor, IRunnable task, TaskCompletionSource promise, object msg);
    public sealed virtual string ToHintString();
    public virtual string ToString();
}
public abstract class DotNetty.Transport.Channels.AbstractServerChannel : AbstractChannel {
    private static ChannelMetadata METADATA;
    public ChannelMetadata Metadata { get; }
    protected EndPoint RemoteAddressInternal { get; }
    private static AbstractServerChannel();
    public virtual ChannelMetadata get_Metadata();
    protected virtual EndPoint get_RemoteAddressInternal();
    protected virtual void DoDisconnect();
    protected virtual IChannelUnsafe NewUnsafe();
    protected virtual void DoWrite(ChannelOutboundBuffer buf);
    protected virtual object FilterOutboundMessage(object msg);
}
public class DotNetty.Transport.Channels.ActionChannelInitializer`1 : ChannelInitializer`1<T> {
    private Action`1<T> initializationAction;
    public ActionChannelInitializer`1(Action`1<T> initializationAction);
    protected virtual void InitChannel(T channel);
    public virtual string ToString();
}
public class DotNetty.Transport.Channels.AdaptiveRecvByteBufAllocator : DefaultMaxMessagesRecvByteBufAllocator {
    private static int DefaultMinimum;
    private static int DefaultInitial;
    private static int DefaultMaximum;
    private static int IndexIncrement;
    private static int IndexDecrement;
    private static Int32[] SizeTable;
    private int minIndex;
    private int maxIndex;
    private int initial;
    private static AdaptiveRecvByteBufAllocator();
    public AdaptiveRecvByteBufAllocator(int minimum, int initial, int maximum);
    private static int GetSizeTableIndex(int size);
    public virtual IRecvByteBufAllocatorHandle NewHandle();
}
public class DotNetty.Transport.Channels.AffinitizedEventLoopGroup : AbstractEventExecutorGroup {
    private IEventLoopGroup innerGroup;
    public bool IsShutdown { get; }
    public bool IsTerminated { get; }
    public bool IsShuttingDown { get; }
    public Task TerminationCompletion { get; }
    public IEnumerable`1<IEventLoop> Items { get; }
    public AffinitizedEventLoopGroup(IEventLoopGroup innerGroup);
    public virtual bool get_IsShutdown();
    public virtual bool get_IsTerminated();
    public virtual bool get_IsShuttingDown();
    public virtual Task get_TerminationCompletion();
    protected virtual IEnumerable`1<IEventExecutor> GetItems();
    public sealed virtual IEnumerable`1<IEventLoop> get_Items();
    public virtual IEventExecutor GetNext();
    private sealed virtual override IEventLoop DotNetty.Transport.Channels.IEventLoopGroup.GetNext();
    public sealed virtual Task RegisterAsync(IChannel channel);
    public virtual Task ShutdownGracefullyAsync(TimeSpan quietPeriod, TimeSpan timeout);
}
public class DotNetty.Transport.Channels.AlreadyConnectedException : Exception {
}
public class DotNetty.Transport.Channels.BatchingPendingWriteQueue : object {
    private static IInternalLogger Logger;
    private IChannelHandlerContext ctx;
    private int maxSize;
    private ChannelOutboundBuffer buffer;
    private IMessageSizeEstimatorHandle estimatorHandle;
    private PendingWrite head;
    private PendingWrite tail;
    private int size;
    public bool IsEmpty { get; }
    public int Size { get; }
    public List`1<object> Current { get; }
    public Nullable`1<long> CurrentSize { get; }
    public BatchingPendingWriteQueue(IChannelHandlerContext ctx, int maxSize);
    private static BatchingPendingWriteQueue();
    public bool get_IsEmpty();
    public int get_Size();
    public Task Add(object msg);
    public void RemoveAndFailAll(Exception cause);
    public void RemoveAndFail(Exception cause);
    public Task RemoveAndWriteAllAsync();
    private void AssertEmpty();
    public Task RemoveAndWriteAsync();
    public TaskCompletionSource Remove();
    public List`1<object> get_Current();
    public Nullable`1<long> get_CurrentSize();
    private bool CanBatch(object message, int size, long currentBatchSize);
    private void Recycle(PendingWrite write, bool update);
    private static void ReleaseMessages(List`1<object> messages);
}
public class DotNetty.Transport.Channels.ChannelDuplexHandler : ChannelHandlerAdapter {
}
public class DotNetty.Transport.Channels.ChannelException : Exception {
    public ChannelException(string message);
    public ChannelException(string message, Exception innerException);
    public ChannelException(Exception innerException);
}
public class DotNetty.Transport.Channels.ChannelHandlerAdapter : object {
    internal bool Added;
    public bool IsSharable { get; }
    [SkipAttribute]
public virtual void ChannelRegistered(IChannelHandlerContext context);
    [SkipAttribute]
public virtual void ChannelUnregistered(IChannelHandlerContext context);
    [SkipAttribute]
public virtual void ChannelActive(IChannelHandlerContext context);
    [SkipAttribute]
public virtual void ChannelInactive(IChannelHandlerContext context);
    [SkipAttribute]
public virtual void ChannelRead(IChannelHandlerContext context, object message);
    [SkipAttribute]
public virtual void ChannelReadComplete(IChannelHandlerContext context);
    [SkipAttribute]
public virtual void ChannelWritabilityChanged(IChannelHandlerContext context);
    [SkipAttribute]
public virtual void HandlerAdded(IChannelHandlerContext context);
    [SkipAttribute]
public virtual void HandlerRemoved(IChannelHandlerContext context);
    [SkipAttribute]
public virtual void UserEventTriggered(IChannelHandlerContext context, object evt);
    [SkipAttribute]
public virtual Task WriteAsync(IChannelHandlerContext context, object message);
    [SkipAttribute]
public virtual void Flush(IChannelHandlerContext context);
    [SkipAttribute]
public virtual Task BindAsync(IChannelHandlerContext context, EndPoint localAddress);
    [SkipAttribute]
public virtual Task ConnectAsync(IChannelHandlerContext context, EndPoint remoteAddress, EndPoint localAddress);
    [SkipAttribute]
public virtual Task DisconnectAsync(IChannelHandlerContext context);
    [SkipAttribute]
public virtual Task CloseAsync(IChannelHandlerContext context);
    [SkipAttribute]
public virtual void ExceptionCaught(IChannelHandlerContext context, Exception exception);
    [SkipAttribute]
public virtual Task DeregisterAsync(IChannelHandlerContext context);
    [SkipAttribute]
public virtual void Read(IChannelHandlerContext context);
    public virtual bool get_IsSharable();
    protected void EnsureNotSharable();
}
public abstract class DotNetty.Transport.Channels.ChannelInitializer`1 : ChannelHandlerAdapter {
    private static IInternalLogger Logger;
    private ConcurrentDictionary`2<IChannelHandlerContext, bool> initMap;
    public bool IsSharable { get; }
    private static ChannelInitializer`1();
    protected abstract virtual void InitChannel(T channel);
    public virtual bool get_IsSharable();
    public sealed virtual void ChannelRegistered(IChannelHandlerContext ctx);
    public virtual void ExceptionCaught(IChannelHandlerContext ctx, Exception cause);
    public virtual void HandlerAdded(IChannelHandlerContext ctx);
    private bool InitChannel(IChannelHandlerContext ctx);
    private void Remove(IChannelHandlerContext ctx);
}
public class DotNetty.Transport.Channels.ChannelMetadata : object {
    [CompilerGeneratedAttribute]
private bool <HasDisconnect>k__BackingField;
    [CompilerGeneratedAttribute]
private int <DefaultMaxMessagesPerRead>k__BackingField;
    public bool HasDisconnect { get; }
    public int DefaultMaxMessagesPerRead { get; }
    public ChannelMetadata(bool hasDisconnect);
    public ChannelMetadata(bool hasDisconnect, int defaultMaxMessagesPerRead);
    [CompilerGeneratedAttribute]
public bool get_HasDisconnect();
    [CompilerGeneratedAttribute]
public int get_DefaultMaxMessagesPerRead();
}
public abstract class DotNetty.Transport.Channels.ChannelOption : AbstractConstant`1<ChannelOption> {
    private static ChannelOptionPool Pool;
    public static ChannelOption`1<IByteBufferAllocator> Allocator;
    public static ChannelOption`1<IRecvByteBufAllocator> RcvbufAllocator;
    public static ChannelOption`1<IMessageSizeEstimator> MessageSizeEstimator;
    public static ChannelOption`1<TimeSpan> ConnectTimeout;
    public static ChannelOption`1<int> WriteSpinCount;
    public static ChannelOption`1<int> WriteBufferHighWaterMark;
    public static ChannelOption`1<int> WriteBufferLowWaterMark;
    public static ChannelOption`1<bool> AllowHalfClosure;
    public static ChannelOption`1<bool> AutoRead;
    public static ChannelOption`1<bool> SoBroadcast;
    public static ChannelOption`1<bool> SoKeepalive;
    public static ChannelOption`1<int> SoSndbuf;
    public static ChannelOption`1<int> SoRcvbuf;
    public static ChannelOption`1<bool> SoReuseaddr;
    public static ChannelOption`1<bool> SoReuseport;
    public static ChannelOption`1<int> SoLinger;
    public static ChannelOption`1<int> SoBacklog;
    public static ChannelOption`1<int> SoTimeout;
    public static ChannelOption`1<int> IpTos;
    public static ChannelOption`1<EndPoint> IpMulticastAddr;
    public static ChannelOption`1<NetworkInterface> IpMulticastIf;
    public static ChannelOption`1<int> IpMulticastTtl;
    public static ChannelOption`1<bool> IpMulticastLoopDisabled;
    public static ChannelOption`1<bool> TcpNodelay;
    internal ChannelOption(int id, string name);
    private static ChannelOption();
    public static ChannelOption`1<T> ValueOf(string name);
    public static ChannelOption`1<T> ValueOf(Type firstNameComponent, string secondNameComponent);
    public static bool Exists(string name);
    public static ChannelOption`1<T> NewInstance(string name);
    public abstract virtual bool Set(IChannelConfiguration configuration, object value);
}
public class DotNetty.Transport.Channels.ChannelOption`1 : ChannelOption {
    internal ChannelOption`1(int id, string name);
    public void Validate(T value);
    public virtual bool Set(IChannelConfiguration configuration, object value);
}
public class DotNetty.Transport.Channels.ChannelOutboundBuffer : object {
    private static IInternalLogger Logger;
    private static ThreadLocalByteBufferList NioBuffers;
    private IChannel channel;
    private Entry flushedEntry;
    private Entry unflushedEntry;
    private Entry tailEntry;
    private int flushed;
    private long nioBufferSize;
    private bool inFail;
    private long totalPendingSize;
    private Int32 modreq(System.Runtime.CompilerServices.IsVolatile) unwritable;
    public object Current { get; }
    public long NioBufferSize { get; }
    public bool IsWritable { get; }
    public int Size { get; }
    public bool IsEmpty { get; }
    internal ChannelOutboundBuffer(IChannel channel);
    private static ChannelOutboundBuffer();
    public void AddMessage(object msg, int size, TaskCompletionSource promise);
    public void AddFlush();
    internal void IncrementPendingOutboundBytes(long size);
    private void IncrementPendingOutboundBytes(long size, bool invokeLater);
    internal void DecrementPendingOutboundBytes(long size);
    private void DecrementPendingOutboundBytes(long size, bool invokeLater, bool notifyWritability);
    public object get_Current();
    public void Progress(long amount);
    public bool Remove();
    public bool Remove(Exception cause);
    private bool Remove0(Exception cause, bool notifyWritability);
    private void RemoveEntry(Entry e);
    public void RemoveBytes(long writtenBytes);
    private void ClearNioBuffers();
    public List`1<ArraySegment`1<byte>> GetSharedBufferList();
    public List`1<ArraySegment`1<byte>> GetSharedBufferList(int maxCount, long maxBytes);
    public long get_NioBufferSize();
    public bool get_IsWritable();
    public bool GetUserDefinedWritability(int index);
    public void SetUserDefinedWritability(int index, bool writable);
    private void SetUserDefinedWritability(int index);
    private void ClearUserDefinedWritability(int index);
    private static int WritabilityMask(int index);
    private void SetWritable(bool invokeLater);
    private void SetUnwritable(bool invokeLater);
    private void FireChannelWritabilityChanged(bool invokeLater);
    public int get_Size();
    public bool get_IsEmpty();
    public void FailFlushed(Exception cause, bool notify);
    internal void Close(Exception cause, bool allowChannelOpen);
    internal void Close(ClosedChannelException cause);
    private static void SafeSuccess(TaskCompletionSource promise);
    private static void SafeFail(TaskCompletionSource promise, Exception cause);
    public long TotalPendingWriteBytes();
    public long BytesBeforeUnwritable();
    public long BytesBeforeWritable();
    public void ForEachFlushedMessage(IMessageProcessor processor);
    private bool IsFlushedEntry(Entry e);
}
internal class DotNetty.Transport.Channels.ChannelPipelineException : Exception {
    public ChannelPipelineException(string message);
    public ChannelPipelineException(string message, Exception innerException);
}
public class DotNetty.Transport.Channels.ClosedChannelException : IOException {
    public ClosedChannelException(string message, Exception innerException);
}
public class DotNetty.Transport.Channels.CombinedChannelDuplexHandler`2 : ChannelDuplexHandler {
    private static IInternalLogger Logger;
    private DelegatingChannelHandlerContext<TIn, TOut> inboundCtx;
    private DelegatingChannelHandlerContext<TIn, TOut> outboundCtx;
    private Boolean modreq(System.Runtime.CompilerServices.IsVolatile) handlerAdded;
    [CompilerGeneratedAttribute]
private TIn <InboundHandler>k__BackingField;
    [CompilerGeneratedAttribute]
private TOut <OutboundHandler>k__BackingField;
    protected TIn InboundHandler { get; private set; }
    protected TOut OutboundHandler { get; private set; }
    public CombinedChannelDuplexHandler`2(TIn inboundHandler, TOut outboundHandler);
    private static CombinedChannelDuplexHandler`2();
    protected void Init(TIn inbound, TOut outbound);
    [CompilerGeneratedAttribute]
protected TIn get_InboundHandler();
    [CompilerGeneratedAttribute]
private void set_InboundHandler(TIn value);
    [CompilerGeneratedAttribute]
protected TOut get_OutboundHandler();
    [CompilerGeneratedAttribute]
private void set_OutboundHandler(TOut value);
    private void Validate(TIn inbound, TOut outbound);
    private void CheckAdded();
    public void RemoveInboundHandler();
    public void RemoveOutboundHandler();
    public virtual void HandlerAdded(IChannelHandlerContext context);
    public virtual void HandlerRemoved(IChannelHandlerContext context);
    public virtual void ChannelRegistered(IChannelHandlerContext context);
    public virtual void ChannelUnregistered(IChannelHandlerContext context);
    public virtual void ChannelActive(IChannelHandlerContext context);
    public virtual void ChannelInactive(IChannelHandlerContext context);
    public virtual void ExceptionCaught(IChannelHandlerContext context, Exception exception);
    public virtual void UserEventTriggered(IChannelHandlerContext context, object evt);
    public virtual void ChannelRead(IChannelHandlerContext context, object message);
    public virtual void ChannelReadComplete(IChannelHandlerContext context);
    public virtual void ChannelWritabilityChanged(IChannelHandlerContext context);
    public virtual Task BindAsync(IChannelHandlerContext context, EndPoint localAddress);
    public virtual Task ConnectAsync(IChannelHandlerContext context, EndPoint remoteAddress, EndPoint localAddress);
    public virtual Task DisconnectAsync(IChannelHandlerContext context);
    public virtual Task CloseAsync(IChannelHandlerContext context);
    public virtual Task DeregisterAsync(IChannelHandlerContext context);
    public virtual void Read(IChannelHandlerContext context);
    public virtual Task WriteAsync(IChannelHandlerContext context, object message);
    public virtual void Flush(IChannelHandlerContext context);
    [CompilerGeneratedAttribute]
private void <HandlerAdded>b__19_0(Exception cause);
}
public class DotNetty.Transport.Channels.ConnectException : Exception {
    public ConnectException(string message, Exception innerException);
}
public class DotNetty.Transport.Channels.ConnectionPendingException : Exception {
}
public class DotNetty.Transport.Channels.ConnectTimeoutException : IOException {
    public ConnectTimeoutException(string message);
}
public class DotNetty.Transport.Channels.DefaultAddressedEnvelope`1 : object {
    [CompilerGeneratedAttribute]
private T <Content>k__BackingField;
    [CompilerGeneratedAttribute]
private EndPoint <Sender>k__BackingField;
    [CompilerGeneratedAttribute]
private EndPoint <Recipient>k__BackingField;
    public T Content { get; }
    public EndPoint Sender { get; }
    public EndPoint Recipient { get; }
    public int ReferenceCount { get; }
    public DefaultAddressedEnvelope`1(T content, EndPoint recipient);
    public DefaultAddressedEnvelope`1(T content, EndPoint sender, EndPoint recipient);
    [CompilerGeneratedAttribute]
public sealed virtual T get_Content();
    [CompilerGeneratedAttribute]
public sealed virtual EndPoint get_Sender();
    [CompilerGeneratedAttribute]
public sealed virtual EndPoint get_Recipient();
    public sealed virtual int get_ReferenceCount();
    public virtual IReferenceCounted Retain();
    public virtual IReferenceCounted Retain(int increment);
    public virtual IReferenceCounted Touch();
    public virtual IReferenceCounted Touch(object hint);
    public sealed virtual bool Release();
    public sealed virtual bool Release(int decrement);
    public virtual string ToString();
}
public class DotNetty.Transport.Channels.DefaultChannelConfiguration : object {
    private static TimeSpan DefaultConnectTimeout;
    private IByteBufferAllocator modreq(System.Runtime.CompilerServices.IsVolatile) allocator;
    private IRecvByteBufAllocator modreq(System.Runtime.CompilerServices.IsVolatile) recvByteBufAllocator;
    private IMessageSizeEstimator modreq(System.Runtime.CompilerServices.IsVolatile) messageSizeEstimator;
    private Int32 modreq(System.Runtime.CompilerServices.IsVolatile) autoRead;
    private Int32 modreq(System.Runtime.CompilerServices.IsVolatile) writeSpinCount;
    private Int32 modreq(System.Runtime.CompilerServices.IsVolatile) writeBufferHighWaterMark;
    private Int32 modreq(System.Runtime.CompilerServices.IsVolatile) writeBufferLowWaterMark;
    private long connectTimeout;
    protected IChannel Channel;
    public TimeSpan ConnectTimeout { get; public set; }
    public IByteBufferAllocator Allocator { get; public set; }
    public IRecvByteBufAllocator RecvByteBufAllocator { get; public set; }
    public IMessageSizeEstimator MessageSizeEstimator { get; public set; }
    public bool AutoRead { get; public set; }
    public int WriteBufferHighWaterMark { get; public set; }
    public int WriteBufferLowWaterMark { get; public set; }
    public int WriteSpinCount { get; public set; }
    public DefaultChannelConfiguration(IChannel channel);
    public DefaultChannelConfiguration(IChannel channel, IRecvByteBufAllocator allocator);
    private static DefaultChannelConfiguration();
    public virtual T GetOption(ChannelOption`1<T> option);
    public sealed virtual bool SetOption(ChannelOption option, object value);
    public virtual bool SetOption(ChannelOption`1<T> option, T value);
    protected virtual void Validate(ChannelOption`1<T> option, T value);
    public sealed virtual TimeSpan get_ConnectTimeout();
    public sealed virtual void set_ConnectTimeout(TimeSpan value);
    public sealed virtual IByteBufferAllocator get_Allocator();
    public sealed virtual void set_Allocator(IByteBufferAllocator value);
    public sealed virtual IRecvByteBufAllocator get_RecvByteBufAllocator();
    public sealed virtual void set_RecvByteBufAllocator(IRecvByteBufAllocator value);
    public sealed virtual IMessageSizeEstimator get_MessageSizeEstimator();
    public sealed virtual void set_MessageSizeEstimator(IMessageSizeEstimator value);
    public sealed virtual bool get_AutoRead();
    public sealed virtual void set_AutoRead(bool value);
    protected virtual void AutoReadCleared();
    public sealed virtual int get_WriteBufferHighWaterMark();
    public sealed virtual void set_WriteBufferHighWaterMark(int value);
    public sealed virtual int get_WriteBufferLowWaterMark();
    public sealed virtual void set_WriteBufferLowWaterMark(int value);
    public sealed virtual int get_WriteSpinCount();
    public sealed virtual void set_WriteSpinCount(int value);
}
internal class DotNetty.Transport.Channels.DefaultChannelHandlerContext : AbstractChannelHandlerContext {
    [CompilerGeneratedAttribute]
private IChannelHandler <Handler>k__BackingField;
    public IChannelHandler Handler { get; }
    public DefaultChannelHandlerContext(DefaultChannelPipeline pipeline, IEventExecutor executor, string name, IChannelHandler handler);
    [CompilerGeneratedAttribute]
public virtual IChannelHandler get_Handler();
}
internal class DotNetty.Transport.Channels.DefaultChannelId : object {
    private static int MachineIdLen;
    private static int ProcessIdLen;
    private static int MaxProcessId;
    private static int SequenceLen;
    private static int TimestampLen;
    private static int RandomLen;
    private static IInternalLogger Logger;
    private static Regex MachineIdPattern;
    private static Byte[] MachineId;
    private static int ProcessId;
    private static int nextSequence;
    private static int seed;
    private static ThreadLocal`1<Random> ThreadLocalRandom;
    private Byte[] data;
    private int hashCode;
    private string longValue;
    private string shortValue;
    private static DefaultChannelId();
    public sealed virtual string AsShortText();
    public sealed virtual string AsLongText();
    public sealed virtual int CompareTo(IChannelId other);
    private static Byte[] ParseMachineId(string value);
    private static int DefaultProcessId();
    public static DefaultChannelId NewInstance();
    private static Byte[] DefaultMachineId();
    private string NewLongValue();
    private int AppendHexDumpField(StringBuilder buf, int i, int length);
    private void Init();
    private int WriteInt(int i, int value);
    private int WriteLong(int i, long value);
    public virtual int GetHashCode();
    public virtual bool Equals(object obj);
    public virtual string ToString();
}
public class DotNetty.Transport.Channels.DefaultChannelPipeline : object {
    internal static IInternalLogger Logger;
    private static Action`2<object, object> CallHandlerAddedAction;
    private static NameCachesLocal NameCaches;
    private IChannel channel;
    private AbstractChannelHandlerContext head;
    private AbstractChannelHandlerContext tail;
    private bool touch;
    private Dictionary`2<IEventExecutorGroup, IEventExecutor> childExecutors;
    private IMessageSizeEstimatorHandle estimatorHandle;
    private PendingHandlerCallback pendingHandlerCallbackHead;
    private bool registered;
    internal IMessageSizeEstimatorHandle EstimatorHandle { get; }
    public IChannel Channel { get; }
    public DefaultChannelPipeline(IChannel channel);
    private static DefaultChannelPipeline();
    internal IMessageSizeEstimatorHandle get_EstimatorHandle();
    internal object Touch(object msg, AbstractChannelHandlerContext next);
    public sealed virtual IChannel get_Channel();
    [IteratorStateMachineAttribute("DotNetty.Transport.Channels.DefaultChannelPipeline/<System-Collections-Generic-IEnumerable<DotNetty-Transport-Channels-IChannelHandler>-GetEnumerator>d__18")]
private sealed virtual override IEnumerator`1<IChannelHandler> System.Collections.Generic.IEnumerable<DotNetty.Transport.Channels.IChannelHandler>.GetEnumerator();
    private AbstractChannelHandlerContext NewContext(IEventExecutorGroup group, string name, IChannelHandler handler);
    private AbstractChannelHandlerContext NewContext(IEventExecutor executor, string name, IChannelHandler handler);
    private IEventExecutor GetChildExecutor(IEventExecutorGroup group);
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    public sealed virtual IChannelPipeline AddFirst(string name, IChannelHandler handler);
    public sealed virtual IChannelPipeline AddFirst(IEventExecutorGroup group, string name, IChannelHandler handler);
    private void AddFirst0(AbstractChannelHandlerContext newCtx);
    public sealed virtual IChannelPipeline AddLast(string name, IChannelHandler handler);
    public sealed virtual IChannelPipeline AddLast(IEventExecutorGroup group, string name, IChannelHandler handler);
    private void AddLast0(AbstractChannelHandlerContext newCtx);
    public sealed virtual IChannelPipeline AddBefore(string baseName, string name, IChannelHandler handler);
    public sealed virtual IChannelPipeline AddBefore(IEventExecutorGroup group, string baseName, string name, IChannelHandler handler);
    private static void AddBefore0(AbstractChannelHandlerContext ctx, AbstractChannelHandlerContext newCtx);
    public sealed virtual IChannelPipeline AddAfter(string baseName, string name, IChannelHandler handler);
    public sealed virtual IChannelPipeline AddAfter(IEventExecutorGroup group, string baseName, string name, IChannelHandler handler);
    private static void AddAfter0(AbstractChannelHandlerContext ctx, AbstractChannelHandlerContext newCtx);
    public sealed virtual IChannelPipeline AddFirst(IChannelHandler[] handlers);
    public sealed virtual IChannelPipeline AddFirst(IEventExecutorGroup group, IChannelHandler[] handlers);
    public sealed virtual IChannelPipeline AddLast(IChannelHandler[] handlers);
    public sealed virtual IChannelPipeline AddLast(IEventExecutorGroup group, IChannelHandler[] handlers);
    private string GenerateName(IChannelHandler handler);
    private static string GenerateName0(Type handlerType);
    public sealed virtual IChannelPipeline Remove(IChannelHandler handler);
    public sealed virtual IChannelHandler Remove(string name);
    public sealed virtual T Remove();
    private AbstractChannelHandlerContext Remove(AbstractChannelHandlerContext ctx);
    private static void Remove0(AbstractChannelHandlerContext context);
    public sealed virtual IChannelHandler RemoveFirst();
    public sealed virtual IChannelHandler RemoveLast();
    public sealed virtual IChannelPipeline Replace(IChannelHandler oldHandler, string newName, IChannelHandler newHandler);
    public sealed virtual IChannelHandler Replace(string oldName, string newName, IChannelHandler newHandler);
    public sealed virtual T Replace(string newName, IChannelHandler newHandler);
    private IChannelHandler Replace(AbstractChannelHandlerContext ctx, string newName, IChannelHandler newHandler);
    private static void Replace0(AbstractChannelHandlerContext oldCtx, AbstractChannelHandlerContext newCtx);
    private static void CheckMultiplicity(IChannelHandler handler);
    private void CallHandlerAdded0(AbstractChannelHandlerContext ctx);
    private void CallHandlerRemoved0(AbstractChannelHandlerContext ctx);
    public sealed virtual IChannelHandler First();
    public sealed virtual IChannelHandlerContext FirstContext();
    public sealed virtual IChannelHandler Last();
    public sealed virtual IChannelHandlerContext LastContext();
    public sealed virtual IChannelHandler Get(string name);
    public sealed virtual T Get();
    public sealed virtual IChannelHandlerContext Context(string name);
    public sealed virtual IChannelHandlerContext Context(IChannelHandler handler);
    public sealed virtual IChannelHandlerContext Context();
    public sealed virtual string ToString();
    public sealed virtual IChannelPipeline FireChannelRegistered();
    public sealed virtual IChannelPipeline FireChannelUnregistered();
    private void Destroy();
    private void DestroyUp(AbstractChannelHandlerContext ctx, bool inEventLoop);
    private void DestroyDown(Thread currentThread, AbstractChannelHandlerContext ctx, bool inEventLoop);
    public sealed virtual IChannelPipeline FireChannelActive();
    public sealed virtual IChannelPipeline FireChannelInactive();
    public sealed virtual IChannelPipeline FireExceptionCaught(Exception cause);
    public sealed virtual IChannelPipeline FireUserEventTriggered(object evt);
    public sealed virtual IChannelPipeline FireChannelRead(object msg);
    public sealed virtual IChannelPipeline FireChannelReadComplete();
    public sealed virtual IChannelPipeline FireChannelWritabilityChanged();
    public sealed virtual Task BindAsync(EndPoint localAddress);
    public sealed virtual Task ConnectAsync(EndPoint remoteAddress);
    public sealed virtual Task ConnectAsync(EndPoint remoteAddress, EndPoint localAddress);
    public sealed virtual Task DisconnectAsync();
    public sealed virtual Task CloseAsync();
    public sealed virtual Task DeregisterAsync();
    public sealed virtual IChannelPipeline Read();
    public sealed virtual Task WriteAsync(object msg);
    public sealed virtual IChannelPipeline Flush();
    public sealed virtual Task WriteAndFlushAsync(object msg);
    private string FilterName(string name, IChannelHandler handler);
    private void CheckDuplicateName(string name);
    private AbstractChannelHandlerContext Context0(string name);
    private AbstractChannelHandlerContext GetContextOrThrow(string name);
    private AbstractChannelHandlerContext GetContextOrThrow(IChannelHandler handler);
    private AbstractChannelHandlerContext GetContextOrThrow();
    private void CallHandlerAddedForAllHandlers();
    private void CallHandlerCallbackLater(AbstractChannelHandlerContext ctx, bool added);
    private IEventExecutor ExecutorSafe(IEventExecutor eventExecutor);
    protected virtual void OnUnhandledInboundException(Exception cause);
    protected virtual void OnUnhandledInboundMessage(object msg);
}
public class DotNetty.Transport.Channels.DefaultFileRegion : AbstractReferenceCounted {
    private static IInternalLogger Logger;
    private FileStream file;
    [CompilerGeneratedAttribute]
private long <Position>k__BackingField;
    [CompilerGeneratedAttribute]
private long <Transferred>k__BackingField;
    [CompilerGeneratedAttribute]
private long <Count>k__BackingField;
    public long Position { get; }
    public long Transferred { get; public set; }
    public long Count { get; }
    public DefaultFileRegion(FileStream file, long position, long count);
    private static DefaultFileRegion();
    public virtual IReferenceCounted Touch(object hint);
    [CompilerGeneratedAttribute]
public sealed virtual long get_Position();
    [CompilerGeneratedAttribute]
public sealed virtual long get_Transferred();
    [CompilerGeneratedAttribute]
public void set_Transferred(long value);
    [CompilerGeneratedAttribute]
public sealed virtual long get_Count();
    public sealed virtual long TransferTo(Stream target, long pos);
    protected virtual void Deallocate();
}
public abstract class DotNetty.Transport.Channels.DefaultMaxMessagesRecvByteBufAllocator : object {
    private Int32 modreq(System.Runtime.CompilerServices.IsVolatile) maxMessagesPerRead;
    public int MaxMessagesPerRead { get; public set; }
    protected DefaultMaxMessagesRecvByteBufAllocator(int maxMessagesPerRead);
    public sealed virtual int get_MaxMessagesPerRead();
    public sealed virtual void set_MaxMessagesPerRead(int value);
    public abstract virtual IRecvByteBufAllocatorHandle NewHandle();
}
public class DotNetty.Transport.Channels.DefaultMessageSizeEstimator : object {
    public static IMessageSizeEstimator Default;
    private IMessageSizeEstimatorHandle handle;
    public DefaultMessageSizeEstimator(int unknownSize);
    private static DefaultMessageSizeEstimator();
    public sealed virtual IMessageSizeEstimatorHandle NewHandle();
}
public class DotNetty.Transport.Channels.Embedded.EmbeddedChannel : AbstractChannel {
    private static EndPoint LOCAL_ADDRESS;
    private static EndPoint REMOTE_ADDRESS;
    private static IChannelHandler[] EMPTY_HANDLERS;
    private static IInternalLogger logger;
    private static ChannelMetadata METADATA_NO_DISCONNECT;
    private static ChannelMetadata METADATA_DISCONNECT;
    private EmbeddedEventLoop loop;
    private Queue`1<object> inboundMessages;
    private Queue`1<object> outboundMessages;
    private Exception lastException;
    private State state;
    [CompilerGeneratedAttribute]
private ChannelMetadata <Metadata>k__BackingField;
    [CompilerGeneratedAttribute]
private IChannelConfiguration <Configuration>k__BackingField;
    public ChannelMetadata Metadata { get; }
    public IChannelConfiguration Configuration { get; }
    public Queue`1<object> InboundMessages { get; }
    public Queue`1<object> OutboundMessages { get; }
    protected EndPoint LocalAddressInternal { get; }
    protected EndPoint RemoteAddressInternal { get; }
    public bool Open { get; }
    public bool Active { get; }
    public EmbeddedChannel(IChannelId channelId);
    public EmbeddedChannel(IChannelHandler[] handlers);
    public EmbeddedChannel(IChannelId id, IChannelHandler[] handlers);
    public EmbeddedChannel(IChannelId id, bool hasDisconnect, IChannelHandler[] handlers);
    public EmbeddedChannel(IChannelId id, bool hasDisconnect, bool register, IChannelHandler[] handlers);
    public EmbeddedChannel(IChannelId id, bool hasDisconnect, IChannelConfiguration config, IChannelHandler[] handlers);
    private static EmbeddedChannel();
    private static ChannelMetadata GetMetadata(bool hasDisconnect);
    private void Setup(bool register, IChannelHandler[] handlers);
    public void Register();
    protected sealed virtual DefaultChannelPipeline NewChannelPipeline();
    [CompilerGeneratedAttribute]
public virtual ChannelMetadata get_Metadata();
    [CompilerGeneratedAttribute]
public virtual IChannelConfiguration get_Configuration();
    public Queue`1<object> get_InboundMessages();
    public Queue`1<object> get_OutboundMessages();
    public sealed virtual T ReadInbound();
    public sealed virtual T ReadOutbound();
    protected virtual EndPoint get_LocalAddressInternal();
    protected virtual EndPoint get_RemoteAddressInternal();
    protected virtual IChannelUnsafe NewUnsafe();
    protected virtual bool IsCompatible(IEventLoop eventLoop);
    protected virtual void DoBind(EndPoint localAddress);
    protected virtual void DoRegister();
    protected virtual void DoDisconnect();
    protected virtual void DoClose();
    protected virtual void DoBeginRead();
    protected virtual void DoWrite(ChannelOutboundBuffer input);
    public virtual bool get_Open();
    public virtual bool get_Active();
    public void RunPendingTasks();
    public PreciseTimeSpan RunScheduledPendingTasks();
    public sealed virtual bool WriteInbound(Object[] msgs);
    public sealed virtual bool WriteOutbound(Object[] msgs);
    private void RecordException(Task future);
    private void RecordException(Exception cause);
    public sealed virtual bool Finish();
    public bool FinishAndReleaseAll();
    private bool Finish(bool releaseAll);
    public bool ReleaseInbound();
    public bool ReleaseOutbound();
    private static bool ReleaseAll(Queue`1<object> queue);
    private void FinishPendingTasks(bool cancel);
    public virtual Task CloseAsync();
    public virtual Task DisconnectAsync();
    private static bool IsNotEmpty(Queue`1<object> queue);
    public void CheckException();
    protected void EnsureOpen();
    private static object Poll(Queue`1<object> queue);
    [CompilerGeneratedAttribute]
private void <WriteOutbound>b__54_0(Task t);
}
public class DotNetty.Transport.Channels.Embedded.EmbeddedChannelId : object {
    public static EmbeddedChannelId Instance;
    private static EmbeddedChannelId();
    public virtual int GetHashCode();
    public virtual bool Equals(object obj);
    public sealed virtual int CompareTo(IChannelId other);
    public virtual string ToString();
    public sealed virtual string AsShortText();
    public sealed virtual string AsLongText();
}
internal class DotNetty.Transport.Channels.Embedded.EmbeddedEventLoop : AbstractScheduledEventExecutor {
    private Queue`1<IRunnable> tasks;
    public bool IsShuttingDown { get; }
    public Task TerminationCompletion { get; }
    public bool IsShutdown { get; }
    public bool IsTerminated { get; }
    public IEventLoopGroup Parent { get; }
    public IEnumerable`1<IEventLoop> Items { get; }
    public sealed virtual IEventLoop GetNext();
    public sealed virtual Task RegisterAsync(IChannel channel);
    public virtual bool get_IsShuttingDown();
    public virtual Task get_TerminationCompletion();
    public virtual bool get_IsShutdown();
    public virtual bool get_IsTerminated();
    public sealed virtual IEventLoopGroup get_Parent();
    protected virtual IEnumerable`1<IEventExecutor> GetItems();
    public sealed virtual IEnumerable`1<IEventLoop> get_Items();
    public virtual bool IsInEventLoop(Thread thread);
    public virtual void Execute(IRunnable command);
    public virtual Task ShutdownGracefullyAsync(TimeSpan quietPeriod, TimeSpan timeout);
    internal PreciseTimeSpan NextScheduledTask();
    internal void RunTasks();
    internal PreciseTimeSpan RunScheduledTasks();
    internal void CancelScheduledTasks();
}
internal class DotNetty.Transport.Channels.Embedded.EmbeddedSocketAddress : EndPoint {
    public virtual string ToString();
}
public interface DotNetty.Transport.Channels.Embedded.IEmbeddedChannel {
    public abstract virtual bool WriteInbound(Object[] msgs);
    public abstract virtual bool WriteOutbound(Object[] msgs);
    public abstract virtual T ReadInbound();
    public abstract virtual T ReadOutbound();
    public abstract virtual bool Finish();
}
public class DotNetty.Transport.Channels.Embedded.SingleThreadedEmbeddedChannel : AbstractChannel {
    private static EndPoint LOCAL_ADDRESS;
    private static EndPoint REMOTE_ADDRESS;
    private static IChannelHandler[] EMPTY_HANDLERS;
    private static IInternalLogger logger;
    private static ChannelMetadata METADATA_NO_DISCONNECT;
    private static ChannelMetadata METADATA_DISCONNECT;
    private IEventLoop loop;
    private Queue`1<object> inboundMessages;
    private Queue`1<object> outboundMessages;
    private Exception lastException;
    private State state;
    [CompilerGeneratedAttribute]
private ChannelMetadata <Metadata>k__BackingField;
    [CompilerGeneratedAttribute]
private IChannelConfiguration <Configuration>k__BackingField;
    public ChannelMetadata Metadata { get; }
    public IChannelConfiguration Configuration { get; }
    public Queue`1<object> InboundMessages { get; }
    public Queue`1<object> OutboundMessages { get; }
    protected EndPoint LocalAddressInternal { get; }
    protected EndPoint RemoteAddressInternal { get; }
    public bool Open { get; }
    public bool Active { get; }
    public SingleThreadedEmbeddedChannel(IEventLoop eventLoop);
    public SingleThreadedEmbeddedChannel(IChannelId channelId, IEventLoop eventLoop);
    public SingleThreadedEmbeddedChannel(IEventLoop eventLoop, IChannelHandler[] handlers);
    public SingleThreadedEmbeddedChannel(IChannelId id, IEventLoop eventLoop, IChannelHandler[] handlers);
    public SingleThreadedEmbeddedChannel(IChannelId id, bool hasDisconnect, IEventLoop eventLoop, IChannelHandler[] handlers);
    public SingleThreadedEmbeddedChannel(IChannelId id, bool hasDisconnect, bool register, IEventLoop eventLoop, IChannelHandler[] handlers);
    public SingleThreadedEmbeddedChannel(IChannelId id, bool hasDisconnect, IChannelConfiguration config, IEventLoop eventLoop, IChannelHandler[] handlers);
    private static SingleThreadedEmbeddedChannel();
    private static ChannelMetadata GetMetadata(bool hasDisconnect);
    private void Setup(bool register, IChannelHandler[] handlers);
    public void Register();
    protected sealed virtual DefaultChannelPipeline NewChannelPipeline();
    [CompilerGeneratedAttribute]
public virtual ChannelMetadata get_Metadata();
    [CompilerGeneratedAttribute]
public virtual IChannelConfiguration get_Configuration();
    public Queue`1<object> get_InboundMessages();
    public Queue`1<object> get_OutboundMessages();
    public sealed virtual T ReadInbound();
    public sealed virtual T ReadOutbound();
    protected virtual EndPoint get_LocalAddressInternal();
    protected virtual EndPoint get_RemoteAddressInternal();
    protected virtual IChannelUnsafe NewUnsafe();
    protected virtual bool IsCompatible(IEventLoop eventLoop);
    protected virtual void DoBind(EndPoint localAddress);
    protected virtual void DoRegister();
    protected virtual void DoDisconnect();
    protected virtual void DoClose();
    protected virtual void DoBeginRead();
    protected virtual void DoWrite(ChannelOutboundBuffer input);
    public virtual bool get_Open();
    public virtual bool get_Active();
    public sealed virtual bool WriteInbound(Object[] msgs);
    public sealed virtual bool WriteOutbound(Object[] msgs);
    private void RecordException(Task future);
    private void RecordException(Exception cause);
    public sealed virtual bool Finish();
    public bool FinishAndReleaseAll();
    private bool Finish(bool releaseAll);
    public bool ReleaseInbound();
    public bool ReleaseOutbound();
    private static bool ReleaseAll(Queue`1<object> queue);
    public virtual Task CloseAsync();
    public virtual Task DisconnectAsync();
    private static bool IsNotEmpty(Queue`1<object> queue);
    public void CheckException();
    protected void EnsureOpen();
    private static object Poll(Queue`1<object> queue);
    [CompilerGeneratedAttribute]
private void <WriteOutbound>b__52_0(Task t);
}
public class DotNetty.Transport.Channels.FixedRecvByteBufAllocator : DefaultMaxMessagesRecvByteBufAllocator {
    public static FixedRecvByteBufAllocator Default;
    private IRecvByteBufAllocatorHandle handle;
    public FixedRecvByteBufAllocator(int bufferSize);
    private static FixedRecvByteBufAllocator();
    public virtual IRecvByteBufAllocatorHandle NewHandle();
}
public class DotNetty.Transport.Channels.Groups.ChannelGroupException : ChannelException {
    private IReadOnlyCollection`1<KeyValuePair`2<IChannel, Exception>> failed;
    public ChannelGroupException(IList`1<KeyValuePair`2<IChannel, Exception>> exceptions);
    public sealed virtual IEnumerator`1<KeyValuePair`2<IChannel, Exception>> GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
}
public static class DotNetty.Transport.Channels.Groups.ChannelMatchers : object {
    private static IChannelMatcher AllMatcher;
    private static IChannelMatcher ServerChannelMatcher;
    private static IChannelMatcher NonServerChannelMatcher;
    private static ChannelMatchers();
    public static IChannelMatcher IsServerChannel();
    public static IChannelMatcher IsNonServerChannel();
    public static IChannelMatcher All();
    public static IChannelMatcher IsNot(IChannel channel);
    public static IChannelMatcher Is(IChannel channel);
    public static IChannelMatcher IsInstanceOf(Type type);
    public static IChannelMatcher IsNotInstanceOf(Type type);
    public static IChannelMatcher Invert(IChannelMatcher matcher);
    public static IChannelMatcher Compose(IChannelMatcher[] matchers);
}
public class DotNetty.Transport.Channels.Groups.CombinedEnumerator`1 : object {
    private IEnumerator`1<T> e1;
    private IEnumerator`1<T> e2;
    private IEnumerator`1<T> currentEnumerator;
    public T Current { get; }
    private object System.Collections.IEnumerator.Current { get; }
    public CombinedEnumerator`1(IEnumerator`1<T> e1, IEnumerator`1<T> e2);
    public sealed virtual T get_Current();
    public sealed virtual void Dispose();
    private sealed virtual override object System.Collections.IEnumerator.get_Current();
    public sealed virtual bool MoveNext();
    public sealed virtual void Reset();
}
public class DotNetty.Transport.Channels.Groups.DefaultChannelGroup : object {
    private static int nextId;
    private IEventExecutor executor;
    private ConcurrentDictionary`2<IChannelId, IChannel> nonServerChannels;
    private ConcurrentDictionary`2<IChannelId, IChannel> serverChannels;
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    public bool IsEmpty { get; }
    public string Name { get; }
    public int Count { get; }
    public bool IsReadOnly { get; }
    public DefaultChannelGroup(IEventExecutor executor);
    public DefaultChannelGroup(string name, IEventExecutor executor);
    public bool get_IsEmpty();
    [CompilerGeneratedAttribute]
public sealed virtual string get_Name();
    public sealed virtual IChannel Find(IChannelId id);
    public sealed virtual Task WriteAsync(object message);
    public sealed virtual Task WriteAsync(object message, IChannelMatcher matcher);
    public sealed virtual IChannelGroup Flush(IChannelMatcher matcher);
    public sealed virtual IChannelGroup Flush();
    public sealed virtual int CompareTo(IChannelGroup other);
    private sealed virtual override void System.Collections.Generic.ICollection<DotNetty.Transport.Channels.IChannel>.Add(IChannel item);
    public sealed virtual void Clear();
    public sealed virtual bool Contains(IChannel item);
    public sealed virtual void CopyTo(IChannel[] array, int arrayIndex);
    public sealed virtual int get_Count();
    public sealed virtual bool get_IsReadOnly();
    public sealed virtual bool Remove(IChannel channel);
    public sealed virtual IEnumerator`1<IChannel> GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    public sealed virtual Task WriteAndFlushAsync(object message);
    public sealed virtual Task WriteAndFlushAsync(object message, IChannelMatcher matcher);
    public sealed virtual Task DisconnectAsync();
    public sealed virtual Task DisconnectAsync(IChannelMatcher matcher);
    public sealed virtual Task CloseAsync();
    public sealed virtual Task CloseAsync(IChannelMatcher matcher);
    public sealed virtual Task DeregisterAsync();
    public sealed virtual Task DeregisterAsync(IChannelMatcher matcher);
    public sealed virtual Task NewCloseFuture();
    public sealed virtual Task NewCloseFuture(IChannelMatcher matcher);
    private static object SafeDuplicate(object message);
    public virtual string ToString();
    public bool Add(IChannel channel);
    public IChannel[] ToArray();
    public bool Remove(IChannelId channelId);
    public bool Remove(object o);
}
public class DotNetty.Transport.Channels.Groups.DefaultChannelGroupCompletionSource : TaskCompletionSource`1<int> {
    private Dictionary`2<IChannel, Task> futures;
    private int failureCount;
    private int successCount;
    [CompilerGeneratedAttribute]
private IChannelGroup <Group>k__BackingField;
    public IChannelGroup Group { get; }
    public ChannelGroupException Cause { get; }
    public Task Current { get; }
    private object System.Collections.IEnumerator.Current { get; }
    public DefaultChannelGroupCompletionSource(IChannelGroup group, Dictionary`2<IChannel, Task> futures);
    public DefaultChannelGroupCompletionSource(IChannelGroup group, Dictionary`2<IChannel, Task> futures, object state);
    [CompilerGeneratedAttribute]
public sealed virtual IChannelGroup get_Group();
    public sealed virtual Task Find(IChannel channel);
    public sealed virtual bool IsPartialSucess();
    public sealed virtual bool IsSucess();
    public sealed virtual bool IsPartialFailure();
    public sealed virtual ChannelGroupException get_Cause();
    public sealed virtual Task get_Current();
    public sealed virtual void Dispose();
    private sealed virtual override object System.Collections.IEnumerator.get_Current();
    public sealed virtual bool MoveNext();
    public sealed virtual void Reset();
    [CompilerGeneratedAttribute]
private void <.ctor>b__4_0(Task x);
}
public interface DotNetty.Transport.Channels.Groups.IChannelGroup {
    public string Name { get; }
    public abstract virtual string get_Name();
    public abstract virtual IChannel Find(IChannelId id);
    public abstract virtual Task WriteAsync(object message);
    public abstract virtual Task WriteAsync(object message, IChannelMatcher matcher);
    public abstract virtual IChannelGroup Flush();
    public abstract virtual IChannelGroup Flush(IChannelMatcher matcher);
    public abstract virtual Task WriteAndFlushAsync(object message);
    public abstract virtual Task WriteAndFlushAsync(object message, IChannelMatcher matcher);
    public abstract virtual Task DisconnectAsync();
    public abstract virtual Task DisconnectAsync(IChannelMatcher matcher);
    public abstract virtual Task CloseAsync();
    public abstract virtual Task CloseAsync(IChannelMatcher matcher);
    public abstract virtual Task DeregisterAsync();
    public abstract virtual Task DeregisterAsync(IChannelMatcher matcher);
    public abstract virtual Task NewCloseFuture();
    public abstract virtual Task NewCloseFuture(IChannelMatcher matcher);
}
public interface DotNetty.Transport.Channels.Groups.IChannelGroupTaskCompletionSource {
    public IChannelGroup Group { get; }
    public ChannelGroupException Cause { get; }
    public abstract virtual IChannelGroup get_Group();
    public abstract virtual ChannelGroupException get_Cause();
    public abstract virtual Task Find(IChannel channel);
    public abstract virtual bool IsPartialSucess();
    public abstract virtual bool IsSucess();
    public abstract virtual bool IsPartialFailure();
}
public interface DotNetty.Transport.Channels.Groups.IChannelMatcher {
    public abstract virtual bool Matches(IChannel channel);
}
public interface DotNetty.Transport.Channels.IAddressedEnvelope`1 {
    public T Content { get; }
    public EndPoint Sender { get; }
    public EndPoint Recipient { get; }
    public abstract virtual T get_Content();
    public abstract virtual EndPoint get_Sender();
    public abstract virtual EndPoint get_Recipient();
}
public interface DotNetty.Transport.Channels.IChannel {
    public IChannelId Id { get; }
    public IByteBufferAllocator Allocator { get; }
    public IEventLoop EventLoop { get; }
    public IChannel Parent { get; }
    public bool Open { get; }
    public bool Active { get; }
    public bool Registered { get; }
    public ChannelMetadata Metadata { get; }
    public EndPoint LocalAddress { get; }
    public EndPoint RemoteAddress { get; }
    public bool IsWritable { get; }
    public IChannelUnsafe Unsafe { get; }
    public IChannelPipeline Pipeline { get; }
    public IChannelConfiguration Configuration { get; }
    public Task CloseCompletion { get; }
    public abstract virtual IChannelId get_Id();
    public abstract virtual IByteBufferAllocator get_Allocator();
    public abstract virtual IEventLoop get_EventLoop();
    public abstract virtual IChannel get_Parent();
    public abstract virtual bool get_Open();
    public abstract virtual bool get_Active();
    public abstract virtual bool get_Registered();
    public abstract virtual ChannelMetadata get_Metadata();
    public abstract virtual EndPoint get_LocalAddress();
    public abstract virtual EndPoint get_RemoteAddress();
    public abstract virtual bool get_IsWritable();
    public abstract virtual IChannelUnsafe get_Unsafe();
    public abstract virtual IChannelPipeline get_Pipeline();
    public abstract virtual IChannelConfiguration get_Configuration();
    public abstract virtual Task get_CloseCompletion();
    public abstract virtual Task DeregisterAsync();
    public abstract virtual Task BindAsync(EndPoint localAddress);
    public abstract virtual Task ConnectAsync(EndPoint remoteAddress);
    public abstract virtual Task ConnectAsync(EndPoint remoteAddress, EndPoint localAddress);
    public abstract virtual Task DisconnectAsync();
    public abstract virtual Task CloseAsync();
    public abstract virtual IChannel Read();
    public abstract virtual Task WriteAsync(object message);
    public abstract virtual IChannel Flush();
    public abstract virtual Task WriteAndFlushAsync(object message);
}
public interface DotNetty.Transport.Channels.IChannelConfiguration {
    public TimeSpan ConnectTimeout { get; public set; }
    public int WriteSpinCount { get; public set; }
    public IByteBufferAllocator Allocator { get; public set; }
    public IRecvByteBufAllocator RecvByteBufAllocator { get; public set; }
    public bool AutoRead { get; public set; }
    public int WriteBufferHighWaterMark { get; public set; }
    public int WriteBufferLowWaterMark { get; public set; }
    public IMessageSizeEstimator MessageSizeEstimator { get; public set; }
    public abstract virtual T GetOption(ChannelOption`1<T> option);
    public abstract virtual bool SetOption(ChannelOption option, object value);
    public abstract virtual bool SetOption(ChannelOption`1<T> option, T value);
    public abstract virtual TimeSpan get_ConnectTimeout();
    public abstract virtual void set_ConnectTimeout(TimeSpan value);
    public abstract virtual int get_WriteSpinCount();
    public abstract virtual void set_WriteSpinCount(int value);
    public abstract virtual IByteBufferAllocator get_Allocator();
    public abstract virtual void set_Allocator(IByteBufferAllocator value);
    public abstract virtual IRecvByteBufAllocator get_RecvByteBufAllocator();
    public abstract virtual void set_RecvByteBufAllocator(IRecvByteBufAllocator value);
    public abstract virtual bool get_AutoRead();
    public abstract virtual void set_AutoRead(bool value);
    public abstract virtual int get_WriteBufferHighWaterMark();
    public abstract virtual void set_WriteBufferHighWaterMark(int value);
    public abstract virtual int get_WriteBufferLowWaterMark();
    public abstract virtual void set_WriteBufferLowWaterMark(int value);
    public abstract virtual IMessageSizeEstimator get_MessageSizeEstimator();
    public abstract virtual void set_MessageSizeEstimator(IMessageSizeEstimator value);
}
public interface DotNetty.Transport.Channels.IChannelHandler {
    public abstract virtual void ChannelRegistered(IChannelHandlerContext context);
    public abstract virtual void ChannelUnregistered(IChannelHandlerContext context);
    public abstract virtual void ChannelActive(IChannelHandlerContext context);
    public abstract virtual void ChannelInactive(IChannelHandlerContext context);
    public abstract virtual void ChannelRead(IChannelHandlerContext context, object message);
    public abstract virtual void ChannelReadComplete(IChannelHandlerContext context);
    public abstract virtual void ChannelWritabilityChanged(IChannelHandlerContext context);
    public abstract virtual void HandlerAdded(IChannelHandlerContext context);
    public abstract virtual void HandlerRemoved(IChannelHandlerContext context);
    public abstract virtual Task WriteAsync(IChannelHandlerContext context, object message);
    public abstract virtual void Flush(IChannelHandlerContext context);
    public abstract virtual Task BindAsync(IChannelHandlerContext context, EndPoint localAddress);
    public abstract virtual Task ConnectAsync(IChannelHandlerContext context, EndPoint remoteAddress, EndPoint localAddress);
    public abstract virtual Task DisconnectAsync(IChannelHandlerContext context);
    public abstract virtual Task CloseAsync(IChannelHandlerContext context);
    public abstract virtual void ExceptionCaught(IChannelHandlerContext context, Exception exception);
    public abstract virtual Task DeregisterAsync(IChannelHandlerContext context);
    public abstract virtual void Read(IChannelHandlerContext context);
    public abstract virtual void UserEventTriggered(IChannelHandlerContext context, object evt);
}
public interface DotNetty.Transport.Channels.IChannelHandlerContext {
    public IChannel Channel { get; }
    public IByteBufferAllocator Allocator { get; }
    public IEventExecutor Executor { get; }
    public string Name { get; }
    public IChannelHandler Handler { get; }
    public bool Removed { get; }
    public abstract virtual IChannel get_Channel();
    public abstract virtual IByteBufferAllocator get_Allocator();
    public abstract virtual IEventExecutor get_Executor();
    public abstract virtual string get_Name();
    public abstract virtual IChannelHandler get_Handler();
    public abstract virtual bool get_Removed();
    public abstract virtual IChannelHandlerContext FireChannelRegistered();
    public abstract virtual IChannelHandlerContext FireChannelUnregistered();
    public abstract virtual IChannelHandlerContext FireChannelActive();
    public abstract virtual IChannelHandlerContext FireChannelInactive();
    public abstract virtual IChannelHandlerContext FireChannelRead(object message);
    public abstract virtual IChannelHandlerContext FireChannelReadComplete();
    public abstract virtual IChannelHandlerContext FireChannelWritabilityChanged();
    public abstract virtual IChannelHandlerContext FireExceptionCaught(Exception ex);
    public abstract virtual IChannelHandlerContext FireUserEventTriggered(object evt);
    public abstract virtual IChannelHandlerContext Read();
    public abstract virtual Task WriteAsync(object message);
    public abstract virtual IChannelHandlerContext Flush();
    public abstract virtual Task WriteAndFlushAsync(object message);
    public abstract virtual Task BindAsync(EndPoint localAddress);
    public abstract virtual Task ConnectAsync(EndPoint remoteAddress);
    public abstract virtual Task ConnectAsync(EndPoint remoteAddress, EndPoint localAddress);
    public abstract virtual Task DisconnectAsync();
    public abstract virtual Task CloseAsync();
    public abstract virtual Task DeregisterAsync();
}
public interface DotNetty.Transport.Channels.IChannelId {
    public abstract virtual string AsShortText();
    public abstract virtual string AsLongText();
}
public interface DotNetty.Transport.Channels.IChannelPipeline {
    public IChannel Channel { get; }
    public abstract virtual IChannelPipeline AddFirst(string name, IChannelHandler handler);
    public abstract virtual IChannelPipeline AddFirst(IEventExecutorGroup group, string name, IChannelHandler handler);
    public abstract virtual IChannelPipeline AddLast(string name, IChannelHandler handler);
    public abstract virtual IChannelPipeline AddLast(IEventExecutorGroup group, string name, IChannelHandler handler);
    public abstract virtual IChannelPipeline AddBefore(string baseName, string name, IChannelHandler handler);
    public abstract virtual IChannelPipeline AddBefore(IEventExecutorGroup group, string baseName, string name, IChannelHandler handler);
    public abstract virtual IChannelPipeline AddAfter(string baseName, string name, IChannelHandler handler);
    public abstract virtual IChannelPipeline AddAfter(IEventExecutorGroup group, string baseName, string name, IChannelHandler handler);
    public abstract virtual IChannelPipeline AddFirst(IChannelHandler[] handlers);
    public abstract virtual IChannelPipeline AddFirst(IEventExecutorGroup group, IChannelHandler[] handlers);
    public abstract virtual IChannelPipeline AddLast(IChannelHandler[] handlers);
    public abstract virtual IChannelPipeline AddLast(IEventExecutorGroup group, IChannelHandler[] handlers);
    public abstract virtual IChannelPipeline Remove(IChannelHandler handler);
    public abstract virtual IChannelHandler Remove(string name);
    public abstract virtual T Remove();
    public abstract virtual IChannelHandler RemoveFirst();
    public abstract virtual IChannelHandler RemoveLast();
    public abstract virtual IChannelPipeline Replace(IChannelHandler oldHandler, string newName, IChannelHandler newHandler);
    public abstract virtual IChannelHandler Replace(string oldName, string newName, IChannelHandler newHandler);
    public abstract virtual T Replace(string newName, IChannelHandler newHandler);
    public abstract virtual IChannelHandler First();
    public abstract virtual IChannelHandlerContext FirstContext();
    public abstract virtual IChannelHandler Last();
    public abstract virtual IChannelHandlerContext LastContext();
    public abstract virtual IChannelHandler Get(string name);
    public abstract virtual T Get();
    public abstract virtual IChannelHandlerContext Context(IChannelHandler handler);
    public abstract virtual IChannelHandlerContext Context(string name);
    public abstract virtual IChannelHandlerContext Context();
    public abstract virtual IChannel get_Channel();
    public abstract virtual IChannelPipeline FireChannelRegistered();
    public abstract virtual IChannelPipeline FireChannelUnregistered();
    public abstract virtual IChannelPipeline FireChannelActive();
    public abstract virtual IChannelPipeline FireChannelInactive();
    public abstract virtual IChannelPipeline FireExceptionCaught(Exception cause);
    public abstract virtual IChannelPipeline FireUserEventTriggered(object evt);
    public abstract virtual IChannelPipeline FireChannelRead(object msg);
    public abstract virtual IChannelPipeline FireChannelReadComplete();
    public abstract virtual IChannelPipeline FireChannelWritabilityChanged();
    public abstract virtual Task BindAsync(EndPoint localAddress);
    public abstract virtual Task ConnectAsync(EndPoint remoteAddress);
    public abstract virtual Task ConnectAsync(EndPoint remoteAddress, EndPoint localAddress);
    public abstract virtual Task DisconnectAsync();
    public abstract virtual Task CloseAsync();
    public abstract virtual Task DeregisterAsync();
    public abstract virtual IChannelPipeline Read();
    public abstract virtual Task WriteAsync(object msg);
    public abstract virtual IChannelPipeline Flush();
    public abstract virtual Task WriteAndFlushAsync(object msg);
}
public interface DotNetty.Transport.Channels.IChannelUnsafe {
    public IRecvByteBufAllocatorHandle RecvBufAllocHandle { get; }
    public ChannelOutboundBuffer OutboundBuffer { get; }
    public abstract virtual IRecvByteBufAllocatorHandle get_RecvBufAllocHandle();
    public abstract virtual Task RegisterAsync(IEventLoop eventLoop);
    public abstract virtual Task DeregisterAsync();
    public abstract virtual Task BindAsync(EndPoint localAddress);
    public abstract virtual Task ConnectAsync(EndPoint remoteAddress, EndPoint localAddress);
    public abstract virtual Task DisconnectAsync();
    public abstract virtual Task CloseAsync();
    public abstract virtual void CloseForcibly();
    public abstract virtual void BeginRead();
    public abstract virtual Task WriteAsync(object message);
    public abstract virtual void Flush();
    public abstract virtual ChannelOutboundBuffer get_OutboundBuffer();
}
public interface DotNetty.Transport.Channels.IEventLoop {
    public IEventLoopGroup Parent { get; }
    public abstract virtual IEventLoopGroup get_Parent();
}
public interface DotNetty.Transport.Channels.IEventLoopGroup {
    public IEnumerable`1<IEventLoop> Items { get; }
    public abstract virtual IEnumerable`1<IEventLoop> get_Items();
    public abstract virtual IEventLoop GetNext();
    public abstract virtual Task RegisterAsync(IChannel channel);
}
public interface DotNetty.Transport.Channels.IFileRegion {
    public long Position { get; }
    public long Transferred { get; }
    public long Count { get; }
    public abstract virtual long get_Position();
    public abstract virtual long get_Transferred();
    public abstract virtual long get_Count();
    public abstract virtual long TransferTo(Stream target, long position);
}
public interface DotNetty.Transport.Channels.IMaxMessagesRecvByteBufAllocator {
    public int MaxMessagesPerRead { get; public set; }
    public abstract virtual int get_MaxMessagesPerRead();
    public abstract virtual void set_MaxMessagesPerRead(int value);
}
public interface DotNetty.Transport.Channels.IMessageSizeEstimator {
    public abstract virtual IMessageSizeEstimatorHandle NewHandle();
}
public interface DotNetty.Transport.Channels.IMessageSizeEstimatorHandle {
    public abstract virtual int Size(object msg);
}
public interface DotNetty.Transport.Channels.IRecvByteBufAllocator {
    public abstract virtual IRecvByteBufAllocatorHandle NewHandle();
}
public interface DotNetty.Transport.Channels.IRecvByteBufAllocatorHandle {
    public int LastBytesRead { get; public set; }
    public int AttemptedBytesRead { get; public set; }
    public abstract virtual IByteBuffer Allocate(IByteBufferAllocator alloc);
    public abstract virtual int Guess();
    public abstract virtual void Reset(IChannelConfiguration config);
    public abstract virtual void IncMessagesRead(int numMessages);
    public abstract virtual int get_LastBytesRead();
    public abstract virtual void set_LastBytesRead(int value);
    public abstract virtual int get_AttemptedBytesRead();
    public abstract virtual void set_AttemptedBytesRead(int value);
    public abstract virtual bool ContinueReading();
    public abstract virtual void ReadComplete();
}
public interface DotNetty.Transport.Channels.IServerChannel {
}
public class DotNetty.Transport.Channels.Local.LocalAddress : EndPoint {
    public static LocalAddress Any;
    private string id;
    private string strVal;
    public string Id { get; }
    internal LocalAddress(IChannel channel);
    public LocalAddress(string id);
    private static LocalAddress();
    public string get_Id();
    public virtual int GetHashCode();
    public virtual string ToString();
    public sealed virtual int CompareTo(LocalAddress other);
}
public class DotNetty.Transport.Channels.Local.LocalChannel : AbstractChannel {
    private static IInternalLogger Logger;
    private static ChannelMetadata METADATA;
    private static int MAX_READER_STACK_DEPTH;
    private static ClosedChannelException DoWriteClosedChannelException;
    private static ClosedChannelException DoCloseClosedChannelException;
    private IQueue`1<object> inboundBuffer;
    private State modreq(System.Runtime.CompilerServices.IsVolatile) state;
    private LocalChannel modreq(System.Runtime.CompilerServices.IsVolatile) peer;
    private LocalAddress modreq(System.Runtime.CompilerServices.IsVolatile) localAddress;
    private LocalAddress modreq(System.Runtime.CompilerServices.IsVolatile) remoteAddress;
    private TaskCompletionSource modreq(System.Runtime.CompilerServices.IsVolatile) connectPromise;
    private Boolean modreq(System.Runtime.CompilerServices.IsVolatile) readInProgress;
    private Boolean modreq(System.Runtime.CompilerServices.IsVolatile) registerInProgress;
    private Boolean modreq(System.Runtime.CompilerServices.IsVolatile) writeInProgress;
    private Task modreq(System.Runtime.CompilerServices.IsVolatile) finishReadFuture;
    private Action shutdownHook;
    [CompilerGeneratedAttribute]
private IChannelConfiguration <Configuration>k__BackingField;
    public ChannelMetadata Metadata { get; }
    public IChannelConfiguration Configuration { get; }
    public LocalServerChannel Parent { get; }
    public LocalAddress LocalAddress { get; }
    public LocalAddress RemoteAddress { get; }
    public bool Open { get; }
    public bool Active { get; }
    protected EndPoint LocalAddressInternal { get; }
    protected EndPoint RemoteAddressInternal { get; }
    internal LocalChannel(LocalServerChannel parent, LocalChannel peer);
    private static LocalChannel();
    public virtual ChannelMetadata get_Metadata();
    [CompilerGeneratedAttribute]
public virtual IChannelConfiguration get_Configuration();
    public LocalServerChannel get_Parent();
    public LocalAddress get_LocalAddress();
    public LocalAddress get_RemoteAddress();
    public virtual bool get_Open();
    public virtual bool get_Active();
    protected virtual IChannelUnsafe NewUnsafe();
    protected virtual bool IsCompatible(IEventLoop loop);
    protected virtual EndPoint get_LocalAddressInternal();
    protected virtual EndPoint get_RemoteAddressInternal();
    private void InternalRead();
    protected virtual void DoRegister();
    protected virtual void DoBind(EndPoint localAddress);
    protected virtual void DoDisconnect();
    protected virtual void DoClose();
    private void TryClose(bool isActive);
    protected virtual void DoDeregister();
    protected virtual void DoBeginRead();
    protected virtual void DoWrite(ChannelOutboundBuffer buffer);
    private void FinishPeerRead(LocalChannel peer);
    private void RunFinishPeerReadTask(LocalChannel peer);
    private void ReleaseInboundBuffers();
    private void FinishPeerRead0(LocalChannel peer);
    [CompilerGeneratedAttribute]
private void <.ctor>b__18_0();
}
public static class DotNetty.Transport.Channels.Local.LocalChannelRegistry : object {
    private static ConcurrentDictionary`2<LocalAddress, IChannel> BoundChannels;
    private static LocalChannelRegistry();
    internal static LocalAddress Register(IChannel channel, LocalAddress oldLocalAddress, EndPoint localAddress);
    internal static IChannel Get(EndPoint localAddress);
    internal static void Unregister(LocalAddress localAddress);
}
public class DotNetty.Transport.Channels.Local.LocalServerChannel : AbstractServerChannel {
    private IQueue`1<object> inboundBuffer;
    private Int32 modreq(System.Runtime.CompilerServices.IsVolatile) state;
    private LocalAddress modreq(System.Runtime.CompilerServices.IsVolatile) localAddress;
    private Boolean modreq(System.Runtime.CompilerServices.IsVolatile) acceptInProgress;
    private Action shutdownHook;
    [CompilerGeneratedAttribute]
private IChannelConfiguration <Configuration>k__BackingField;
    public IChannelConfiguration Configuration { get; }
    public bool Open { get; }
    public bool Active { get; }
    protected EndPoint LocalAddressInternal { get; }
    public LocalAddress LocalAddress { get; }
    public LocalAddress RemoteAddress { get; }
    [CompilerGeneratedAttribute]
public virtual IChannelConfiguration get_Configuration();
    public virtual bool get_Open();
    public virtual bool get_Active();
    protected virtual EndPoint get_LocalAddressInternal();
    protected virtual bool IsCompatible(IEventLoop eventLoop);
    public LocalAddress get_LocalAddress();
    public LocalAddress get_RemoteAddress();
    protected virtual void DoRegister();
    protected virtual void DoBind(EndPoint localAddress);
    protected virtual void DoClose();
    protected virtual void DoDeregister();
    protected virtual void DoBeginRead();
    public LocalChannel Serve(LocalChannel peer);
    protected LocalChannel NewLocalChannel(LocalChannel peer);
    private void Serve0(LocalChannel child);
    [CompilerGeneratedAttribute]
private void <.ctor>b__5_0();
}
public class DotNetty.Transport.Channels.MultithreadEventLoopGroup : AbstractEventExecutorGroup {
    private static int DefaultEventLoopThreadCount;
    private static Func`2<IEventLoopGroup, IEventLoop> DefaultEventLoopFactory;
    private IEventLoop[] eventLoops;
    private int requestId;
    [CompilerGeneratedAttribute]
private Task <TerminationCompletion>k__BackingField;
    public bool IsShutdown { get; }
    public bool IsTerminated { get; }
    public bool IsShuttingDown { get; }
    public Task TerminationCompletion { get; }
    public IEnumerable`1<IEventLoop> Items { get; }
    public MultithreadEventLoopGroup(int eventLoopCount);
    public MultithreadEventLoopGroup(Func`2<IEventLoopGroup, IEventLoop> eventLoopFactory);
    public MultithreadEventLoopGroup(Func`2<IEventLoopGroup, IEventLoop> eventLoopFactory, int eventLoopCount);
    private static MultithreadEventLoopGroup();
    public virtual bool get_IsShutdown();
    public virtual bool get_IsTerminated();
    public virtual bool get_IsShuttingDown();
    [CompilerGeneratedAttribute]
public virtual Task get_TerminationCompletion();
    protected virtual IEnumerable`1<IEventExecutor> GetItems();
    public sealed virtual IEnumerable`1<IEventLoop> get_Items();
    private sealed virtual override IEventLoop DotNetty.Transport.Channels.IEventLoopGroup.GetNext();
    public virtual IEventExecutor GetNext();
    public sealed virtual Task RegisterAsync(IChannel channel);
    public virtual Task ShutdownGracefullyAsync(TimeSpan quietPeriod, TimeSpan timeout);
}
public class DotNetty.Transport.Channels.NotYetConnectedException : IOException {
}
public class DotNetty.Transport.Channels.PendingWriteQueue : object {
    private static IInternalLogger Logger;
    private IChannelHandlerContext ctx;
    private ChannelOutboundBuffer buffer;
    private IMessageSizeEstimatorHandle estimatorHandle;
    private PendingWrite head;
    private PendingWrite tail;
    private int size;
    public bool IsEmpty { get; }
    public int Size { get; }
    public object Current { get; }
    public PendingWriteQueue(IChannelHandlerContext ctx);
    private static PendingWriteQueue();
    public bool get_IsEmpty();
    public int get_Size();
    public Task Add(object msg);
    public void RemoveAndFailAll(Exception cause);
    public void RemoveAndFail(Exception cause);
    public Task RemoveAndWriteAllAsync();
    private void AssertEmpty();
    public Task RemoveAndWriteAsync();
    public TaskCompletionSource Remove();
    public object get_Current();
    private void Recycle(PendingWrite write, bool update);
}
public abstract class DotNetty.Transport.Channels.Pool.AbstractChannelPoolMap`2 : object {
    private ConcurrentDictionary`2<TKey, TPool> map;
    public int Count { get; }
    public bool IsEmpty { get; }
    public sealed virtual TPool Get(TKey key);
    public bool Remove(TKey key);
    public int get_Count();
    public bool get_IsEmpty();
    public sealed virtual bool Contains(TKey key);
    protected abstract virtual TPool NewPool(TKey key);
    public void Dispose();
}
public class DotNetty.Transport.Channels.Pool.ChannelActiveHealthChecker : object {
    public static IChannelHealthChecker Instance;
    private static ChannelActiveHealthChecker();
    public sealed virtual ValueTask`1<bool> IsHealthyAsync(IChannel channel);
}
public class DotNetty.Transport.Channels.Pool.CountingChannelPoolHandler : object {
    private int channelCount;
    private int acquiredCount;
    private int releasedCount;
    public int ChannelCount { get; }
    public int AcquiredCount { get; }
    public int ReleasedCount { get; }
    public int get_ChannelCount();
    public int get_AcquiredCount();
    public int get_ReleasedCount();
    public sealed virtual void ChannelCreated(IChannel ch);
    public sealed virtual void ChannelReleased(IChannel ch);
    public sealed virtual void ChannelAcquired(IChannel ch);
}
public class DotNetty.Transport.Channels.Pool.FixedChannelPool : SimpleChannelPool {
    private static InvalidOperationException FullException;
    private static TimeoutException TimeoutException;
    internal static InvalidOperationException PoolClosedOnReleaseException;
    private static InvalidOperationException PoolClosedOnAcquireException;
    private IEventExecutor executor;
    private TimeSpan acquireTimeout;
    private IRunnable timeoutTask;
    private IQueue`1<AcquireTask> pendingAcquireQueue;
    private int maxConnections;
    private int maxPendingAcquires;
    private int acquiredChannelCount;
    private int pendingAcquireCount;
    private bool closed;
    public FixedChannelPool(Bootstrap bootstrap, IChannelPoolHandler handler, int maxConnections, int maxPendingAcquires);
    public FixedChannelPool(Bootstrap bootstrap, IChannelPoolHandler handler, IChannelHealthChecker healthChecker, AcquireTimeoutAction action, TimeSpan acquireTimeout, int maxConnections, int maxPendingAcquires);
    public FixedChannelPool(Bootstrap bootstrap, IChannelPoolHandler handler, IChannelHealthChecker healthChecker, AcquireTimeoutAction action, TimeSpan acquireTimeout, int maxConnections, int maxPendingAcquires, bool releaseHealthCheck);
    public FixedChannelPool(Bootstrap bootstrap, IChannelPoolHandler handler, IChannelHealthChecker healthChecker, AcquireTimeoutAction action, TimeSpan acquireTimeout, int maxConnections, int maxPendingAcquires, bool releaseHealthCheck, bool lastRecentUsed);
    private static FixedChannelPool();
    public virtual ValueTask`1<IChannel> AcquireAsync();
    [AsyncStateMachineAttribute("DotNetty.Transport.Channels.Pool.FixedChannelPool/<Acquire0>d__19")]
private void Acquire0(object state);
    private ValueTask`1<IChannel> DoAcquireAsync(TaskCompletionSource`1<IChannel> promise);
    private ValueTask`1<IChannel> DoAcquireAsync();
    [AsyncStateMachineAttribute("DotNetty.Transport.Channels.Pool.FixedChannelPool/<ReleaseAsync>d__22")]
public virtual ValueTask`1<bool> ReleaseAsync(IChannel channel);
    [AsyncStateMachineAttribute("DotNetty.Transport.Channels.Pool.FixedChannelPool/<Release0>d__23")]
private void Release0(object channel, object promise);
    [AsyncStateMachineAttribute("DotNetty.Transport.Channels.Pool.FixedChannelPool/<DoReleaseAsync>d__24")]
private ValueTask`1<bool> DoReleaseAsync(IChannel channel);
    private void DecrementAndRunTaskQueue();
    private void RunTaskQueue();
    public virtual void Dispose();
    private void Close();
    private void OnTimeoutNew(AcquireTask task);
    private void OnTimeoutFail(AcquireTask task);
    [CompilerGeneratedAttribute]
private void <DoReleaseAsync>g__FailIfClosed|24_0(IChannel ch);
    [CompilerGeneratedAttribute]
[DebuggerHiddenAttribute]
private ValueTask`1<bool> <>n__0(IChannel channel);
}
public interface DotNetty.Transport.Channels.Pool.IChannelHealthChecker {
    public abstract virtual ValueTask`1<bool> IsHealthyAsync(IChannel channel);
}
public interface DotNetty.Transport.Channels.Pool.IChannelPool {
    public abstract virtual ValueTask`1<IChannel> AcquireAsync();
    public abstract virtual ValueTask`1<bool> ReleaseAsync(IChannel channel);
}
public interface DotNetty.Transport.Channels.Pool.IChannelPoolHandler {
    public abstract virtual void ChannelReleased(IChannel channel);
    public abstract virtual void ChannelAcquired(IChannel channel);
    public abstract virtual void ChannelCreated(IChannel channel);
}
public interface DotNetty.Transport.Channels.Pool.IChannelPoolMap`2 {
    public abstract virtual TPool Get(TKey key);
    public abstract virtual bool Contains(TKey key);
}
public class DotNetty.Transport.Channels.Pool.SimpleChannelPool : object {
    public static AttributeKey`1<SimpleChannelPool> PoolKey;
    private static InvalidOperationException FullException;
    private IQueue`1<IChannel> store;
    [CompilerGeneratedAttribute]
private Bootstrap <Bootstrap>k__BackingField;
    [CompilerGeneratedAttribute]
private IChannelPoolHandler <Handler>k__BackingField;
    [CompilerGeneratedAttribute]
private IChannelHealthChecker <HealthChecker>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <ReleaseHealthCheck>k__BackingField;
    internal Bootstrap Bootstrap { get; }
    internal IChannelPoolHandler Handler { get; }
    internal IChannelHealthChecker HealthChecker { get; }
    internal bool ReleaseHealthCheck { get; }
    public SimpleChannelPool(Bootstrap bootstrap, IChannelPoolHandler handler);
    public SimpleChannelPool(Bootstrap bootstrap, IChannelPoolHandler handler, IChannelHealthChecker healthChecker);
    public SimpleChannelPool(Bootstrap bootstrap, IChannelPoolHandler handler, IChannelHealthChecker healthChecker, bool releaseHealthCheck);
    public SimpleChannelPool(Bootstrap bootstrap, IChannelPoolHandler handler, IChannelHealthChecker healthChecker, bool releaseHealthCheck, bool lastRecentUsed);
    private static SimpleChannelPool();
    private void OnChannelInitializing(IChannel channel);
    [CompilerGeneratedAttribute]
internal Bootstrap get_Bootstrap();
    [CompilerGeneratedAttribute]
internal IChannelPoolHandler get_Handler();
    [CompilerGeneratedAttribute]
internal IChannelHealthChecker get_HealthChecker();
    [CompilerGeneratedAttribute]
internal bool get_ReleaseHealthCheck();
    public virtual ValueTask`1<IChannel> AcquireAsync();
    [AsyncStateMachineAttribute("DotNetty.Transport.Channels.Pool.SimpleChannelPool/<DoHealthCheck>d__21")]
private void DoHealthCheck(object channel, object state);
    [AsyncStateMachineAttribute("DotNetty.Transport.Channels.Pool.SimpleChannelPool/<DoHealthCheck>d__22")]
private ValueTask`1<IChannel> DoHealthCheck(IChannel channel);
    protected virtual Task`1<IChannel> ConnectChannel(Bootstrap bs);
    [AsyncStateMachineAttribute("DotNetty.Transport.Channels.Pool.SimpleChannelPool/<ReleaseAsync>d__24")]
public virtual ValueTask`1<bool> ReleaseAsync(IChannel channel);
    [AsyncStateMachineAttribute("DotNetty.Transport.Channels.Pool.SimpleChannelPool/<DoReleaseChannel>d__25")]
private void DoReleaseChannel(object channel, object state);
    [AsyncStateMachineAttribute("DotNetty.Transport.Channels.Pool.SimpleChannelPool/<DoReleaseChannel>d__26")]
private ValueTask`1<bool> DoReleaseChannel(IChannel channel);
    [AsyncStateMachineAttribute("DotNetty.Transport.Channels.Pool.SimpleChannelPool/<DoHealthCheckOnRelease>d__27")]
private ValueTask`1<bool> DoHealthCheckOnRelease(IChannel channel);
    private void ReleaseAndOffer(IChannel channel);
    private static void CloseChannel(IChannel channel);
    protected virtual bool TryPollChannel(IChannel& channel);
    protected virtual bool TryOfferChannel(IChannel channel);
    public virtual void Dispose();
}
public abstract class DotNetty.Transport.Channels.SimpleChannelInboundHandler`1 : ChannelHandlerAdapter {
    private bool autoRelease;
    protected SimpleChannelInboundHandler`1(bool autoRelease);
    public bool AcceptInboundMessage(object msg);
    public virtual void ChannelRead(IChannelHandlerContext ctx, object msg);
    protected abstract virtual void ChannelRead0(IChannelHandlerContext ctx, I msg);
}
public class DotNetty.Transport.Channels.SingleThreadEventLoop : SingleThreadEventExecutor {
    private static TimeSpan DefaultBreakoutInterval;
    public IEventLoopGroup Parent { get; }
    public IEnumerable`1<IEventLoop> Items { get; }
    public SingleThreadEventLoop(string threadName);
    public SingleThreadEventLoop(string threadName, TimeSpan breakoutInterval);
    public SingleThreadEventLoop(IEventLoopGroup parent);
    public SingleThreadEventLoop(IEventLoopGroup parent, string threadName);
    public SingleThreadEventLoop(IEventLoopGroup parent, string threadName, TimeSpan breakoutInterval);
    protected SingleThreadEventLoop(string threadName, TimeSpan breakoutInterval, IQueue`1<IRunnable> taskQueue);
    protected SingleThreadEventLoop(IEventLoopGroup parent, string threadName, TimeSpan breakoutInterval, IQueue`1<IRunnable> taskQueue);
    private static SingleThreadEventLoop();
    public sealed virtual IEventLoop GetNext();
    public sealed virtual Task RegisterAsync(IChannel channel);
    public sealed virtual IEventLoopGroup get_Parent();
    public sealed virtual IEnumerable`1<IEventLoop> get_Items();
}
[AttributeUsageAttribute("64")]
public class DotNetty.Transport.Channels.SkipAttribute : Attribute {
}
public abstract class DotNetty.Transport.Channels.Sockets.AbstractSocketByteChannel : AbstractSocketChannel {
    private static string ExpectedTypes;
    private static Action`1<object> FlushAction;
    private static Action`2<object, object> ReadCompletedSyncCallback;
    protected AbstractSocketByteChannel(IChannel parent, Socket socket);
    private static AbstractSocketByteChannel();
    protected virtual IChannelUnsafe NewUnsafe();
    protected virtual void ScheduleSocketRead();
    private static void OnReadCompletedSync(object u, object e);
    protected virtual void DoWrite(ChannelOutboundBuffer input);
    protected virtual object FilterOutboundMessage(object msg);
    protected bool IncompleteWrite(bool scheduleAsync, SocketChannelAsyncOperation operation);
    protected abstract virtual int DoReadBytes(IByteBuffer buf);
    protected abstract virtual int DoWriteBytes(IByteBuffer buf);
}
public abstract class DotNetty.Transport.Channels.Sockets.AbstractSocketChannel : AbstractChannel {
    private static IInternalLogger Logger;
    internal static EventHandler`1<SocketAsyncEventArgs> IoCompletedCallback;
    private static Action`2<object, object> ConnectCallbackAction;
    private static Action`2<object, object> ReadCallbackAction;
    private static Action`2<object, object> WriteCallbackAction;
    protected Socket Socket;
    private SocketChannelAsyncOperation readOperation;
    private SocketChannelAsyncOperation writeOperation;
    private Boolean modreq(System.Runtime.CompilerServices.IsVolatile) inputShutdown;
    internal bool ReadPending;
    private StateFlags modreq(System.Runtime.CompilerServices.IsVolatile) state;
    private TaskCompletionSource connectPromise;
    private IScheduledTask connectCancellationTask;
    public bool Open { get; }
    public bool Active { get; }
    protected bool InputShutdown { get; }
    protected SocketChannelAsyncOperation ReadOperation { get; }
    private SocketChannelAsyncOperation WriteOperation { get; }
    protected AbstractSocketChannel(IChannel parent, Socket socket);
    private static AbstractSocketChannel();
    public virtual bool get_Open();
    public virtual bool get_Active();
    protected internal void ClearReadPending();
    private void ClearReadPending0();
    protected bool get_InputShutdown();
    protected void ShutdownInput();
    protected void SetState(StateFlags stateToSet);
    protected StateFlags ResetState(StateFlags stateToReset);
    protected bool TryResetState(StateFlags stateToReset);
    protected bool IsInState(StateFlags stateToCheck);
    protected SocketChannelAsyncOperation get_ReadOperation();
    private SocketChannelAsyncOperation get_WriteOperation();
    protected SocketChannelAsyncOperation PrepareWriteOperation(ArraySegment`1<byte> buffer);
    protected SocketChannelAsyncOperation PrepareWriteOperation(IList`1<ArraySegment`1<byte>> buffers);
    protected void ResetWriteOperation();
    private static void OnIoCompleted(object sender, SocketAsyncEventArgs args);
    protected virtual bool IsCompatible(IEventLoop eventLoop);
    protected virtual void DoBeginRead();
    protected abstract virtual void ScheduleSocketRead();
    protected abstract virtual bool DoConnect(EndPoint remoteAddress, EndPoint localAddress);
    protected abstract virtual void DoFinishConnect(SocketChannelAsyncOperation operation);
    protected virtual void DoClose();
}
public abstract class DotNetty.Transport.Channels.Sockets.AbstractSocketMessageChannel : AbstractSocketChannel {
    protected bool ContinueOnWriteError { get; }
    protected AbstractSocketMessageChannel(IChannel parent, Socket socket);
    protected virtual IChannelUnsafe NewUnsafe();
    protected virtual void DoWrite(ChannelOutboundBuffer input);
    protected abstract virtual void ScheduleMessageWrite(object message);
    protected virtual bool get_ContinueOnWriteError();
    protected abstract virtual int DoReadMessages(List`1<object> buf);
    protected abstract virtual bool DoWriteMessage(object msg, ChannelOutboundBuffer input);
}
public class DotNetty.Transport.Channels.Sockets.ChannelInputShutdownEvent : object {
    public static ChannelInputShutdownEvent Instance;
    private static ChannelInputShutdownEvent();
}
public class DotNetty.Transport.Channels.Sockets.DatagramPacket : DefaultAddressedEnvelope`1<IByteBuffer> {
    public DatagramPacket(IByteBuffer message, EndPoint recipient);
    public DatagramPacket(IByteBuffer message, EndPoint sender, EndPoint recipient);
    public sealed virtual IByteBufferHolder Copy();
    public sealed virtual IByteBufferHolder Duplicate();
    public sealed virtual IByteBufferHolder RetainedDuplicate();
    public sealed virtual IByteBufferHolder Replace(IByteBuffer content);
    public virtual IReferenceCounted Retain();
    public virtual IReferenceCounted Retain(int increment);
    public virtual IReferenceCounted Touch();
    public virtual IReferenceCounted Touch(object hint);
}
public class DotNetty.Transport.Channels.Sockets.DefaultDatagramChannelConfig : DefaultChannelConfiguration {
    private static int DefaultFixedBufferSize;
    private Socket socket;
    public int SendBufferSize { get; public set; }
    public int ReceiveBufferSize { get; public set; }
    public int TrafficClass { get; public set; }
    public bool ReuseAddress { get; public set; }
    public bool Broadcast { get; public set; }
    public bool LoopbackModeDisabled { get; public set; }
    public short TimeToLive { get; public set; }
    public EndPoint Interface { get; public set; }
    public NetworkInterface NetworkInterface { get; public set; }
    internal SocketOptionLevel AddressFamilyOptionLevel { get; }
    public DefaultDatagramChannelConfig(IDatagramChannel channel, Socket socket);
    public virtual T GetOption(ChannelOption`1<T> option);
    public virtual bool SetOption(ChannelOption`1<T> option, T value);
    public sealed virtual int get_SendBufferSize();
    public sealed virtual void set_SendBufferSize(int value);
    public sealed virtual int get_ReceiveBufferSize();
    public sealed virtual void set_ReceiveBufferSize(int value);
    public sealed virtual int get_TrafficClass();
    public sealed virtual void set_TrafficClass(int value);
    public sealed virtual bool get_ReuseAddress();
    public sealed virtual void set_ReuseAddress(bool value);
    public sealed virtual bool get_Broadcast();
    public sealed virtual void set_Broadcast(bool value);
    public sealed virtual bool get_LoopbackModeDisabled();
    public sealed virtual void set_LoopbackModeDisabled(bool value);
    public sealed virtual short get_TimeToLive();
    public sealed virtual void set_TimeToLive(short value);
    public sealed virtual EndPoint get_Interface();
    public sealed virtual void set_Interface(EndPoint value);
    public sealed virtual NetworkInterface get_NetworkInterface();
    public sealed virtual void set_NetworkInterface(NetworkInterface value);
    internal SocketOptionLevel get_AddressFamilyOptionLevel();
    internal int GetNetworkInterfaceIndex(NetworkInterface networkInterface);
}
public class DotNetty.Transport.Channels.Sockets.DefaultServerSocketChannelConfig : DefaultChannelConfiguration {
    protected Socket Socket;
    private Int32 modreq(System.Runtime.CompilerServices.IsVolatile) backlog;
    public bool ReuseAddress { get; public set; }
    public int ReceiveBufferSize { get; public set; }
    public int Backlog { get; public set; }
    public DefaultServerSocketChannelConfig(IServerSocketChannel channel, Socket socket);
    public virtual T GetOption(ChannelOption`1<T> option);
    public virtual bool SetOption(ChannelOption`1<T> option, T value);
    public bool get_ReuseAddress();
    public void set_ReuseAddress(bool value);
    public int get_ReceiveBufferSize();
    public void set_ReceiveBufferSize(int value);
    public sealed virtual int get_Backlog();
    public sealed virtual void set_Backlog(int value);
}
public class DotNetty.Transport.Channels.Sockets.DefaultSocketChannelConfiguration : DefaultChannelConfiguration {
    protected Socket Socket;
    private Boolean modreq(System.Runtime.CompilerServices.IsVolatile) allowHalfClosure;
    public bool AllowHalfClosure { get; public set; }
    public int ReceiveBufferSize { get; public set; }
    public int SendBufferSize { get; public set; }
    public int Linger { get; public set; }
    public bool KeepAlive { get; public set; }
    public bool ReuseAddress { get; public set; }
    public bool TcpNoDelay { get; public set; }
    public DefaultSocketChannelConfiguration(ISocketChannel channel, Socket socket);
    public virtual T GetOption(ChannelOption`1<T> option);
    public virtual bool SetOption(ChannelOption`1<T> option, T value);
    public sealed virtual bool get_AllowHalfClosure();
    public sealed virtual void set_AllowHalfClosure(bool value);
    public sealed virtual int get_ReceiveBufferSize();
    public sealed virtual void set_ReceiveBufferSize(int value);
    public virtual int get_SendBufferSize();
    public virtual void set_SendBufferSize(int value);
    public sealed virtual int get_Linger();
    public sealed virtual void set_Linger(int value);
    public sealed virtual bool get_KeepAlive();
    public sealed virtual void set_KeepAlive(bool value);
    public sealed virtual bool get_ReuseAddress();
    public sealed virtual void set_ReuseAddress(bool value);
    public sealed virtual bool get_TcpNoDelay();
    public sealed virtual void set_TcpNoDelay(bool value);
}
public interface DotNetty.Transport.Channels.Sockets.IDatagramChannel {
    public abstract virtual bool IsConnected();
    public abstract virtual Task JoinGroup(IPEndPoint multicastAddress);
    public abstract virtual Task JoinGroup(IPEndPoint multicastAddress, TaskCompletionSource promise);
    public abstract virtual Task JoinGroup(IPEndPoint multicastAddress, NetworkInterface networkInterface);
    public abstract virtual Task JoinGroup(IPEndPoint multicastAddress, NetworkInterface networkInterface, TaskCompletionSource promise);
    public abstract virtual Task JoinGroup(IPEndPoint multicastAddress, NetworkInterface networkInterface, IPEndPoint source);
    public abstract virtual Task JoinGroup(IPEndPoint multicastAddress, NetworkInterface networkInterface, IPEndPoint source, TaskCompletionSource promise);
    public abstract virtual Task LeaveGroup(IPEndPoint multicastAddress);
    public abstract virtual Task LeaveGroup(IPEndPoint multicastAddress, TaskCompletionSource promise);
    public abstract virtual Task LeaveGroup(IPEndPoint multicastAddress, NetworkInterface networkInterface);
    public abstract virtual Task LeaveGroup(IPEndPoint multicastAddress, NetworkInterface networkInterface, TaskCompletionSource promise);
    public abstract virtual Task LeaveGroup(IPEndPoint multicastAddress, NetworkInterface networkInterface, IPEndPoint source);
    public abstract virtual Task LeaveGroup(IPEndPoint multicastAddress, NetworkInterface networkInterface, IPEndPoint source, TaskCompletionSource promise);
}
public interface DotNetty.Transport.Channels.Sockets.IDatagramChannelConfig {
    public int SendBufferSize { get; public set; }
    public int ReceiveBufferSize { get; public set; }
    public int TrafficClass { get; public set; }
    public bool ReuseAddress { get; public set; }
    public bool Broadcast { get; public set; }
    public bool LoopbackModeDisabled { get; public set; }
    public short TimeToLive { get; public set; }
    public EndPoint Interface { get; public set; }
    public NetworkInterface NetworkInterface { get; public set; }
    public abstract virtual int get_SendBufferSize();
    public abstract virtual void set_SendBufferSize(int value);
    public abstract virtual int get_ReceiveBufferSize();
    public abstract virtual void set_ReceiveBufferSize(int value);
    public abstract virtual int get_TrafficClass();
    public abstract virtual void set_TrafficClass(int value);
    public abstract virtual bool get_ReuseAddress();
    public abstract virtual void set_ReuseAddress(bool value);
    public abstract virtual bool get_Broadcast();
    public abstract virtual void set_Broadcast(bool value);
    public abstract virtual bool get_LoopbackModeDisabled();
    public abstract virtual void set_LoopbackModeDisabled(bool value);
    public abstract virtual short get_TimeToLive();
    public abstract virtual void set_TimeToLive(short value);
    public abstract virtual EndPoint get_Interface();
    public abstract virtual void set_Interface(EndPoint value);
    public abstract virtual NetworkInterface get_NetworkInterface();
    public abstract virtual void set_NetworkInterface(NetworkInterface value);
}
public interface DotNetty.Transport.Channels.Sockets.IServerSocketChannel {
}
public interface DotNetty.Transport.Channels.Sockets.IServerSocketChannelConfiguration {
    public int Backlog { get; public set; }
    public abstract virtual int get_Backlog();
    public abstract virtual void set_Backlog(int value);
}
public interface DotNetty.Transport.Channels.Sockets.ISocketChannel {
}
public interface DotNetty.Transport.Channels.Sockets.ISocketChannelConfiguration {
    public bool AllowHalfClosure { get; public set; }
    public int ReceiveBufferSize { get; public set; }
    public int SendBufferSize { get; public set; }
    public int Linger { get; public set; }
    public bool KeepAlive { get; public set; }
    public bool ReuseAddress { get; public set; }
    public bool TcpNoDelay { get; public set; }
    public abstract virtual bool get_AllowHalfClosure();
    public abstract virtual void set_AllowHalfClosure(bool value);
    public abstract virtual int get_ReceiveBufferSize();
    public abstract virtual void set_ReceiveBufferSize(int value);
    public abstract virtual int get_SendBufferSize();
    public abstract virtual void set_SendBufferSize(int value);
    public abstract virtual int get_Linger();
    public abstract virtual void set_Linger(int value);
    public abstract virtual bool get_KeepAlive();
    public abstract virtual void set_KeepAlive(bool value);
    public abstract virtual bool get_ReuseAddress();
    public abstract virtual void set_ReuseAddress(bool value);
    public abstract virtual bool get_TcpNoDelay();
    public abstract virtual void set_TcpNoDelay(bool value);
}
public class DotNetty.Transport.Channels.Sockets.SocketChannelAsyncOperation : SocketAsyncEventArgs {
    [CompilerGeneratedAttribute]
private AbstractSocketChannel <Channel>k__BackingField;
    public AbstractSocketChannel Channel { get; private set; }
    public SocketChannelAsyncOperation(AbstractSocketChannel channel);
    public SocketChannelAsyncOperation(AbstractSocketChannel channel, bool setEmptyBuffer);
    public void Validate();
    [CompilerGeneratedAttribute]
public AbstractSocketChannel get_Channel();
    [CompilerGeneratedAttribute]
private void set_Channel(AbstractSocketChannel value);
}
public class DotNetty.Transport.Channels.Sockets.SocketDatagramChannel : AbstractSocketMessageChannel {
    private static IInternalLogger Logger;
    private static Action`2<object, object> ReceiveFromCompletedSyncCallback;
    private static ChannelMetadata ChannelMetadata;
    private DefaultDatagramChannelConfig config;
    private IPEndPoint anyRemoteEndPoint;
    public IChannelConfiguration Configuration { get; }
    public ChannelMetadata Metadata { get; }
    protected EndPoint LocalAddressInternal { get; }
    protected EndPoint RemoteAddressInternal { get; }
    public bool Active { get; }
    protected bool ContinueOnWriteError { get; }
    public SocketDatagramChannel(AddressFamily addressFamily);
    public SocketDatagramChannel(Socket socket);
    private static SocketDatagramChannel();
    public virtual IChannelConfiguration get_Configuration();
    public virtual ChannelMetadata get_Metadata();
    protected virtual EndPoint get_LocalAddressInternal();
    protected virtual EndPoint get_RemoteAddressInternal();
    protected virtual void DoBind(EndPoint localAddress);
    public virtual bool get_Active();
    protected virtual bool DoConnect(EndPoint remoteAddress, EndPoint localAddress);
    protected virtual void DoFinishConnect(SocketChannelAsyncOperation operation);
    protected virtual void DoDisconnect();
    protected virtual void DoClose();
    protected virtual void ScheduleSocketRead();
    protected virtual int DoReadMessages(List`1<object> buf);
    private static void OnReceiveFromCompletedSync(object u, object p);
    protected virtual void ScheduleMessageWrite(object message);
    protected virtual IChannelUnsafe NewUnsafe();
    protected virtual bool DoWriteMessage(object msg, ChannelOutboundBuffer input);
    protected virtual object FilterOutboundMessage(object msg);
    private IByteBuffer CreateNewDirectBuffer(IByteBuffer buffer);
    private IByteBuffer CreateNewDirectBuffer(IReferenceCounted holder, IByteBuffer buffer);
    private static bool IsSingleBuffer(IByteBuffer buffer);
    protected virtual bool get_ContinueOnWriteError();
    public sealed virtual bool IsConnected();
    public sealed virtual Task JoinGroup(IPEndPoint multicastAddress);
    public sealed virtual Task JoinGroup(IPEndPoint multicastAddress, TaskCompletionSource promise);
    public sealed virtual Task JoinGroup(IPEndPoint multicastAddress, NetworkInterface networkInterface);
    public sealed virtual Task JoinGroup(IPEndPoint multicastAddress, NetworkInterface networkInterface, TaskCompletionSource promise);
    public sealed virtual Task JoinGroup(IPEndPoint multicastAddress, NetworkInterface networkInterface, IPEndPoint source);
    public sealed virtual Task JoinGroup(IPEndPoint multicastAddress, NetworkInterface networkInterface, IPEndPoint source, TaskCompletionSource promise);
    private void DoJoinGroup(IPEndPoint multicastAddress, NetworkInterface networkInterface, IPEndPoint source, TaskCompletionSource promise);
    public sealed virtual Task LeaveGroup(IPEndPoint multicastAddress);
    public sealed virtual Task LeaveGroup(IPEndPoint multicastAddress, TaskCompletionSource promise);
    public sealed virtual Task LeaveGroup(IPEndPoint multicastAddress, NetworkInterface networkInterface);
    public sealed virtual Task LeaveGroup(IPEndPoint multicastAddress, NetworkInterface networkInterface, TaskCompletionSource promise);
    public sealed virtual Task LeaveGroup(IPEndPoint multicastAddress, NetworkInterface networkInterface, IPEndPoint source);
    public sealed virtual Task LeaveGroup(IPEndPoint multicastAddress, NetworkInterface networkInterface, IPEndPoint source, TaskCompletionSource promise);
    private void DoLeaveGroup(IPEndPoint multicastAddress, NetworkInterface networkInterface, IPEndPoint source, TaskCompletionSource promise);
    private object CreateMulticastOption(IPEndPoint multicastAddress, NetworkInterface networkInterface, IPEndPoint source);
}
public class DotNetty.Transport.Channels.Sockets.TcpServerSocketChannel : AbstractSocketChannel {
    private static IInternalLogger Logger;
    private static ChannelMetadata METADATA;
    private static Action`2<object, object> ReadCompletedSyncCallback;
    private IServerSocketChannelConfiguration config;
    private SocketChannelAsyncOperation acceptOperation;
    public IChannelConfiguration Configuration { get; }
    public bool Active { get; }
    public ChannelMetadata Metadata { get; }
    protected EndPoint RemoteAddressInternal { get; }
    protected EndPoint LocalAddressInternal { get; }
    private SocketChannelAsyncOperation AcceptOperation { get; }
    public TcpServerSocketChannel(AddressFamily addressFamily);
    public TcpServerSocketChannel(Socket socket);
    private static TcpServerSocketChannel();
    public virtual IChannelConfiguration get_Configuration();
    public virtual bool get_Active();
    public virtual ChannelMetadata get_Metadata();
    protected virtual EndPoint get_RemoteAddressInternal();
    protected virtual EndPoint get_LocalAddressInternal();
    private SocketChannelAsyncOperation get_AcceptOperation();
    protected virtual IChannelUnsafe NewUnsafe();
    protected virtual void DoBind(EndPoint localAddress);
    protected virtual void DoClose();
    protected virtual void ScheduleSocketRead();
    private static void OnReadCompletedSync(object u, object p);
    protected virtual bool DoConnect(EndPoint remoteAddress, EndPoint localAddress);
    protected virtual void DoFinishConnect(SocketChannelAsyncOperation operation);
    protected virtual void DoDisconnect();
    protected virtual void DoWrite(ChannelOutboundBuffer input);
    protected sealed virtual object FilterOutboundMessage(object msg);
}
public class DotNetty.Transport.Channels.Sockets.TcpSocketChannel : AbstractSocketByteChannel {
    private static ChannelMetadata METADATA;
    private ISocketChannelConfiguration config;
    public ChannelMetadata Metadata { get; }
    public IChannelConfiguration Configuration { get; }
    protected EndPoint LocalAddressInternal { get; }
    protected EndPoint RemoteAddressInternal { get; }
    public bool IsOutputShutdown { get; }
    public TcpSocketChannel(AddressFamily addressFamily);
    public TcpSocketChannel(Socket socket);
    public TcpSocketChannel(IChannel parent, Socket socket);
    internal TcpSocketChannel(IChannel parent, Socket socket, bool connected);
    private static TcpSocketChannel();
    public virtual ChannelMetadata get_Metadata();
    public virtual IChannelConfiguration get_Configuration();
    protected virtual EndPoint get_LocalAddressInternal();
    protected virtual EndPoint get_RemoteAddressInternal();
    public bool get_IsOutputShutdown();
    public Task ShutdownOutputAsync();
    private void ShutdownOutput0(TaskCompletionSource promise);
    protected virtual void DoBind(EndPoint localAddress);
    protected virtual bool DoConnect(EndPoint remoteAddress, EndPoint localAddress);
    protected virtual void DoFinishConnect(SocketChannelAsyncOperation operation);
    private void OnConnected();
    protected virtual void DoDisconnect();
    protected virtual void DoClose();
    protected virtual int DoReadBytes(IByteBuffer byteBuf);
    protected virtual int DoWriteBytes(IByteBuffer buf);
    protected virtual void DoWrite(ChannelOutboundBuffer input);
    private List`1<ArraySegment`1<byte>> AdjustBufferList(long localWrittenBytes, List`1<ArraySegment`1<byte>> bufferList);
    protected virtual IChannelUnsafe NewUnsafe();
    [CompilerGeneratedAttribute]
private void <ShutdownOutputAsync>b__17_0(object promise);
}
[ExtensionAttribute]
internal static class DotNetty.Transport.Channels.Util : object {
    private static IInternalLogger Log;
    private static Util();
    public static void SafeSetSuccess(TaskCompletionSource promise, IInternalLogger logger);
    public static void SafeSetFailure(TaskCompletionSource promise, Exception cause, IInternalLogger logger);
    [ExtensionAttribute]
public static void CloseSafe(IChannel channel);
    [ExtensionAttribute]
public static void CloseSafe(IChannelUnsafe u);
    [AsyncStateMachineAttribute("DotNetty.Transport.Channels.Util/<CompleteChannelCloseTaskSafely>d__5")]
internal static void CompleteChannelCloseTaskSafely(object channelObject, Task closeTask);
}
