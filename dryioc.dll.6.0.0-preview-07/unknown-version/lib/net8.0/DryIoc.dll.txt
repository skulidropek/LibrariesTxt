public static class DryIoc.Arg : object {
    public static string ArgIndexMethodName;
    private static Arg();
    public static TRequired Of();
    public static TService Of();
    public static TRequired Of(IfUnresolved ifUnresolved);
    public static TService Of(IfUnresolved ifUnresolved);
    public static TRequired Of(object serviceKey);
    public static TService Of(object serviceKey);
    public static TRequired Of(string metadataKey, object metadata);
    public static TService Of(string metadataKey, object metadata);
    public static TRequired Of(IfUnresolved ifUnresolved, object serviceKey);
    public static TService Of(IfUnresolved ifUnresolved, object serviceKey);
    public static TRequired Of(TRequired defaultValue, IfUnresolved ifUnresolved);
    public static TRequired Of(TRequired defaultValue, IfUnresolved ifUnresolved, object serviceKey);
    public static T Index(int argIndex);
}
public class DryIoc.AsyncExecutionFlowScopeContext : object {
    public static string ScopeContextName;
    public static AsyncExecutionFlowScopeContext Default;
    private static AsyncLocal`1<IScope> _ambientScope;
    private static AsyncExecutionFlowScopeContext();
    public sealed virtual IScope GetCurrentOrDefault();
    public sealed virtual IScope SetCurrent(SetCurrentScopeHandler changeCurrentScope);
    public sealed virtual void Dispose();
}
public class DryIoc.CompileTimeContainer : object {
    public static CompileTimeContainer Instance;
    private static CompileTimeContainer();
    public sealed virtual bool IsRegistered(Type serviceType);
    public sealed virtual bool IsRegistered(Type serviceType, object serviceKey);
    public sealed virtual bool TryResolve(Object& service, IResolverContext r, Type serviceType);
    public sealed virtual bool TryResolve(Object& service, IResolverContext r, Type serviceType, object serviceKey, Type requiredServiceType, Request preRequestParent, Object[] args);
    [IteratorStateMachineAttribute("DryIoc.CompileTimeContainer/<ResolveMany>d__5")]
public sealed virtual IEnumerable`1<ResolveManyResult> ResolveMany(IResolverContext _, Type serviceType);
    internal static IService Get_IService_0(IResolverContext r);
    internal static BaseAConsumer Get_BaseAConsumer_1(IResolverContext r);
    internal static DependencyB`1<string> GetDependency_DependencyB_1(IResolverContext r);
}
public class DryIoc.CompositeScopeName : object {
    private Object[] _names;
    private CompositeScopeName(Object[] names);
    public static CompositeScopeName Of(Object[] names);
    public sealed virtual bool Match(object scopeName);
}
public class DryIoc.Container : object {
    [CompilerGeneratedAttribute]
private Rules <Rules>k__BackingField;
    private static int _objectTypeHash;
    private static MethodInfo _kvOfMethod;
    private static LastFactoryIDWinsComparer _lastFactoryIDWinsComparer;
    internal Ref`1<ImHashMap`2<Type, object>> _registry;
    private IScope _singletonScope;
    private IDisposable _ownScopeOrContext;
    private IResolverContext _parent;
    private StackTrace _disposeStackTrace;
    private int _disposed;
    public IResolverContext Parent { get; }
    public IResolverContext Root { get; }
    public IScope SingletonScope { get; }
    public IScopeContext ScopeContext { get; }
    public IScope CurrentScope { get; }
    public IScope CurrentOrSingletonScope { get; }
    public Rules Rules { get; private set; }
    public IScope OwnCurrentScope { get; }
    public bool IsDisposed { get; }
    public object DisposeInfo { get; }
    public Container(Rules rules, IScopeContext scopeContext);
    public Container(Func`2<Rules, Rules> configure, IScopeContext scopeContext);
    private Container(Rules rules, Ref`1<ImHashMap`2<Type, object>> registry, IScope singletonScope, IDisposable ownScopeOrContext, int disposed, StackTrace disposeStackTrace, IResolverContext parent);
    private static Container();
    public static IScope NewSingletonScope();
    public virtual string ToString();
    private void TryCaptureContainerDisposeStackTrace();
    private static void DisposeScopeContextCurrentScope(IScopeContext scopeContext);
    public sealed virtual void Dispose();
    public sealed virtual ValueTask DisposeAsync();
    public sealed virtual IEnumerable`1<ServiceRegistrationInfo> GetServiceRegistrations();
    public sealed virtual IEnumerable`1<R> GetServiceRegistrations(S state, MatchOp`3<S, ServiceRegistrationInfo, R> match);
    public sealed virtual IEnumerable`1<DecoratorRegistrationInfo> GetDecoratorRegistrations();
    public sealed virtual Factory[] GetRegisteredFactories(Type serviceType, object serviceKey, FactoryType factoryType);
    public sealed virtual void Register(Factory factory, Type serviceType, object serviceKey, Nullable`1<IfAlreadyRegistered> ifAlreadyRegistered, bool isStaticallyChecked);
    public sealed virtual void RegisterWithoutValidation(Factory factory, Type serviceType, object serviceKey, Nullable`1<IfAlreadyRegistered> ifAlreadyRegistered);
    private ImHashMap`2<Type, object> RegistrySwap(Factory factory, Type serviceType, Nullable`1<IfAlreadyRegistered> ifAlreadyRegistered, object serviceKey);
    public sealed virtual bool IsRegistered(Type serviceType, object serviceKey, FactoryType factoryType, Func`2<Factory, bool> condition);
    public sealed virtual void Unregister(Type serviceType, object serviceKey, FactoryType factoryType, Func`2<Factory, bool> condition);
    private sealed virtual override object System.IServiceProvider.GetService(Type serviceType);
    public sealed virtual object Resolve(Type serviceType, IfUnresolved ifUnresolved);
    private object ResolveAndCache(int serviceTypeHash, Type serviceType, IfUnresolved ifUnresolved);
    public sealed virtual object Resolve(Type serviceType, object serviceKey, IfUnresolved ifUnresolved, Type requiredServiceType, Request preResolveParent, Object[] args);
    private object ResolveAndCacheKeyed(int serviceTypeHash, Type serviceType, object serviceKey, IfUnresolved ifUnresolved, object scopeName, Type requiredServiceType, Request preResolveParent, Object[] args);
    private static bool TryInterpretOrCompileCachedExpression(IResolverContext r, KeyedFactoryCacheEntry cacheEntry, bool useInterpretation, Object& result);
    [IteratorStateMachineAttribute("DryIoc.Container/<DryIoc-IResolver-ResolveMany>d__24")]
private sealed virtual override IEnumerable`1<object> DryIoc.IResolver.ResolveMany(Type serviceType, object serviceKey, Type requiredServiceType, Request preResolveParent, Object[] args);
    private void ThrowIfContainerDisposed();
    private void ThrowIfRootContainerDisposed();
    public sealed virtual IResolverContext get_Parent();
    public sealed virtual IResolverContext get_Root();
    public sealed virtual IScope get_SingletonScope();
    public sealed virtual IScopeContext get_ScopeContext();
    public sealed virtual IScope get_CurrentScope();
    public sealed virtual IScope get_CurrentOrSingletonScope();
    public sealed virtual IResolverContext WithCurrentScope(IScope ownScope);
    public sealed virtual IResolverContext WithScopeContext(IScopeContext scopeContext);
    public virtual IContainer WithNewOpenScope();
    private IContainer WithNewOpenScopeInScopeContext(IScopeContext scopeContext);
    private sealed virtual override void DryIoc.IResolverContext.InjectPropertiesAndFields(object instance, String[] propertyAndFieldNames);
    public sealed virtual void Use(Type serviceType, object instance);
    [CompilerGeneratedAttribute]
public sealed virtual Rules get_Rules();
    [CompilerGeneratedAttribute]
private void set_Rules(Rules value);
    public sealed virtual IScope get_OwnCurrentScope();
    public sealed virtual bool get_IsDisposed();
    public sealed virtual object get_DisposeInfo();
    public sealed virtual IContainer With(IResolverContext parent, Rules rules, IScopeContext scopeContext, RegistrySharing registrySharing, IScope singletonScope, IScope currentScope, Nullable`1<IsRegistryChangePermitted> isRegistryChangePermitted);
    public sealed virtual KeyValuePair`2[] Validate(IEnumerable`1<ServiceInfo> roots);
    public sealed virtual GeneratedExpressions GenerateResolutionExpressions(Func`2<IEnumerable`1<ServiceRegistrationInfo>, IEnumerable`1<ServiceInfo>> getRoots, bool allowRuntimeState);
    public sealed virtual bool ClearCache(Type serviceType, Nullable`1<FactoryType> factoryType, object serviceKey);
    public sealed virtual Factory ResolveFactory(Request request);
    public sealed virtual Factory ResolveFactory(ServiceInfo serviceInfo);
    public sealed virtual Expression ResolveExpression(ServiceInfo serviceInfo);
    internal static T ThrowUnableToResolveOrGetDefault(Request request, T defaultResult);
    public sealed virtual Factory GetServiceFactoryOrDefault(Request request);
    private Factory GetRuleSelectedServiceFactoryOrDefault(Rules rules, ImHashMap`2<Type, object> serviceFactories, Request request, ServiceDetails details, Type serviceType);
    private static KV`2<object, Factory> FindFactoryWithTheMinReuseLifespanOrDefault(KV`2[] factories);
    public sealed virtual KV`2[] GetAllServiceFactoriesPlusForOpenGeneric(Type serviceType);
    internal static Factory[] MergeSortedByLatestOrderOrRegistration(Factory[] source, Factory[] added);
    public sealed virtual KV`2[] GetAllServiceFactories(Type serviceType);
    public sealed virtual Expression GetDecoratorExpressionOrDefault(Request request);
    private static Int32[] GetAppliedDecoratorIDs(Request request);
    public sealed virtual Factory GetWrapperFactoryOrDefault(Type serviceType);
    public sealed virtual bool IsWrapper(Type serviceType, Type openGenericServiceType);
    public sealed virtual Factory[] GetDecoratorFactoriesOrDefault(Type serviceType);
    public sealed virtual Factory[] GetDecoratorFactoriesOrDefault(int serviceTypeHash, Type serviceType);
    public sealed virtual Type GetWrappedType(Type serviceType, Type requiredServiceType);
    public sealed virtual Expression GetConstantExpression(object item, Type itemType, bool throwIfStateRequired);
    private Expression ConvertConstantToExpression(IConvertibleToExpression convertible, bool throwIfStateRequired);
    public sealed virtual Type GetWrappedType(Type serviceType);
    private Factory GetWrapperFactoryOrDefault(Request request);
    private KV`2[] CombineRegisteredServiceWithDynamicFactories(KV`2[] factories, Type serviceType, Type openGenericServiceType, object serviceKey);
    private KV`2[] CombineRegisteredServiceWithDynamicFactories(KV`2[] factories, Type serviceType, Type openGenericServiceType);
    private Factory[] CombineRegisteredDecoratorWithDynamicFactories(Factory[] factories, Type serviceType);
    internal void TryCacheDefaultFactoryDelegateOrExprOrResult(int serviceTypeHash, Type serviceType, object factory);
    internal void TryCacheKeyedFactoryDelegateOrExprOrResult(int serviceTypeHash, Type serviceType, object key, object factory);
    internal ImHashMapEntry`2<int, object> CacheFactoryExpression(int factoryId);
    private void SetInitialRuntimeFactoryID();
}
public class DryIoc.ContainerException : InvalidOperationException {
    public int Error;
    public ContainerException[] CollectedExceptions;
    public object Details;
    public string ErrorName { get; }
    public ContainerException(int error, ContainerException[] exceptions);
    public ContainerException(int error, string message);
    private ContainerException(object details, int error, string message);
    public ContainerException(int errorCode, string message, Exception innerException);
    protected ContainerException(int errorCode, string message, Exception innerException, Func`4<int, string, Exception, string> formatMessage);
    public string get_ErrorName();
    public static ContainerException Of(ErrorCheck errorCheck, int errorCode, object arg0, object arg1, object arg2, object arg3, Exception innerException);
    protected static string GetMessage(ErrorCheck errorCheck, int errorCode);
    protected static string Print(object arg);
    public static object WithDetails(object details, int error, object arg0, object arg1, object arg2, object arg3);
    protected static string FormatMessage(string errorName, string message);
    public string TryGetDetails(IRegistrator container);
    [CompilerGeneratedAttribute]
internal static string <TryGetDetails>g__GetDecoratorMessage|15_1(IRegistrator container, int decoratorFactoryId);
    [CompilerGeneratedAttribute]
internal static string <TryGetDetails>g__GetServiceMessage|15_0(IRegistrator container, int factoryId);
}
[ExtensionAttribute]
public static class DryIoc.ContainerTools : object {
    internal static ConstantExpression NullTypeConstant;
    internal static ConstantExpression IfUnresolvedThrowConstant;
    internal static ConstantExpression IfUnresolvedReturnDefaultConstant;
    internal static ConstantExpression IfUnresolvedReturnDefaultIfNotRegisteredConstant;
    public static string FacadeKey;
    private static ContainerTools();
    [ExtensionAttribute]
internal static ConstantExpression ToConstant(Type type);
    [ExtensionAttribute]
internal static ConstantExpression ToConstant(IfUnresolved ifUnresolved);
    [ExtensionAttribute]
public static T With(T container, IResolverContext parent, Rules rules, IScopeContext scopeContext, RegistrySharing registrySharing, IScope singletonScope, IScope currentScope);
    [ExtensionAttribute]
public static T With(T container, Rules rules, IScopeContext scopeContext, RegistrySharing registrySharing, IScope singletonScope);
    [ExtensionAttribute]
public static T WithNoMoreRegistrationAllowed(T container, bool ignoreInsteadOfThrow);
    [ExtensionAttribute]
public static Rules WithFacadeRules(Rules rules, string facadeKey);
    [ExtensionAttribute]
public static T CreateFacade(T container, string facadeKey);
    [ExtensionAttribute]
public static IContainer CreateChild(IContainer container, RegistrySharing registrySharing, object childDefaultServiceKey, Nullable`1<IfAlreadyRegistered> ifAlreadyRegistered, Rules newRules, bool withDisposables);
    [ExtensionAttribute]
public static T CreateChild(T container, Nullable`1<IfAlreadyRegistered> ifAlreadyRegistered, Rules newRules, bool withDisposables);
    [ExtensionAttribute]
public static T With(T container, Func`2<Rules, Rules> configure, IScopeContext scopeContext);
    [ExtensionAttribute]
public static T With(T container, S state, Func`3<Rules, S, Rules> configure, IScopeContext scopeContext);
    [ExtensionAttribute]
public static T WithExpressionGeneration(T container, bool allowRuntimeState);
    [ExtensionAttribute]
public static T WithoutCache(T container);
    [ExtensionAttribute]
public static T WithoutSingletonsAndCache(T container);
    [ExtensionAttribute]
public static T WithRegistrationsCopy(T container, bool preserveCache);
    [ExtensionAttribute]
public static T WithRegistrationsCopy(T container, IsRegistryChangePermitted isRegistryChangePermitted, bool preserveCache);
    [ExtensionAttribute]
public static TService InjectPropertiesAndFields(IResolverContext r, TService instance);
    [ExtensionAttribute]
public static TService InjectPropertiesAndFields(IResolverContext r, TService instance, String[] propertyAndFieldNames);
    [ExtensionAttribute]
public static object New(IContainer container, Type concreteType, Setup setup, Made made, RegistrySharing registrySharing);
    [ExtensionAttribute]
public static object New(IContainer container, Type concreteType, Made made, RegistrySharing registrySharing);
    [ExtensionAttribute]
public static T New(IContainer container, Made made, RegistrySharing registrySharing);
    [ExtensionAttribute]
public static T New(IContainer container, TypedMade`1<T> made, RegistrySharing registrySharing);
    [ExtensionAttribute]
public static IContainer WithAutoFallbackDynamicRegistrations(IContainer container, Func`3<Type, object, IEnumerable`1<Type>> getImplTypes, Func`2<Type, Factory> factory);
    [ExtensionAttribute]
public static IContainer WithAutoFallbackDynamicRegistrations(IContainer container, DynamicRegistrationFlags flags, Func`3<Type, object, IEnumerable`1<Type>> getImplTypes, Func`2<Type, Factory> factory);
    [ExtensionAttribute]
public static IContainer WithAutoFallbackDynamicRegistrations(IContainer container, Type[] implTypes);
    [ExtensionAttribute]
public static IContainer WithAutoFallbackDynamicRegistrations(IContainer container, IReuse reuse, Type[] implTypes);
    [ExtensionAttribute]
public static IContainer WithAutoFallbackDynamicRegistrations(IContainer container, IReuse reuse, Setup setup, Type[] implTypes);
    [ExtensionAttribute]
public static IContainer WithAutoFallbackDynamicRegistrations(IContainer container, Func`3<Type, object, IEnumerable`1<Assembly>> getImplTypeAssemblies, Func`2<Type, Factory> factory);
    [ExtensionAttribute]
public static IContainer WithAutoFallbackDynamicRegistrations(IContainer container, DynamicRegistrationFlags flags, Func`3<Type, object, IEnumerable`1<Assembly>> getImplTypeAssemblies, Func`2<Type, Factory> factory);
    [ExtensionAttribute]
public static IContainer WithAutoFallbackDynamicRegistrations(IContainer container, Assembly[] implTypeAssemblies);
    [ExtensionAttribute]
public static IContainer WithAutoFallbackDynamicRegistrations(IContainer container, IEnumerable`1<Assembly> implTypeAssemblies);
    [ExtensionAttribute]
public static IContainer WithDependencies(IContainer container, ParameterSelector parameters, PropertiesAndFieldsSelector propertiesAndFields);
    [ExtensionAttribute]
public static GeneratedExpressions GenerateResolutionExpressions(IContainer container, Func`2<ServiceRegistrationInfo, bool> condition);
    [ExtensionAttribute]
public static GeneratedExpressions GenerateResolutionExpressions(IContainer container, ServiceInfo[] roots);
    public static bool DefaultValidateCondition(ServiceRegistrationInfo reg);
    [ExtensionAttribute]
public static KeyValuePair`2[] Validate(IContainer container, Func`2<ServiceRegistrationInfo, bool> condition);
    [ExtensionAttribute]
public static KeyValuePair`2[] Validate(IContainer container, Type[] serviceTypes);
    [ExtensionAttribute]
public static KeyValuePair`2[] Validate(IContainer container, ServiceInfo[] roots);
    [ExtensionAttribute]
public static void ValidateAndThrow(IContainer container, Func`2<ServiceRegistrationInfo, bool> condition);
    [ExtensionAttribute]
public static void ValidateAndThrow(IContainer container, Type[] serviceTypes);
    [ExtensionAttribute]
public static void ValidateAndThrow(IContainer container, ServiceInfo[] roots);
    [ExtensionAttribute]
public static Expression GetRequestExpression(IContainer container, Request request, RequestFlags requestParentFlags);
    [ExtensionAttribute]
public static bool ClearCache(IContainer container, Nullable`1<FactoryType> factoryType, object serviceKey);
    [ExtensionAttribute]
public static bool ClearCache(IContainer container, Type serviceType, Nullable`1<FactoryType> factoryType, object serviceKey);
    [ExtensionAttribute]
public static void Use(IContainer container, Type serviceType, Func`2<IResolverContext, object> factory);
    [ExtensionAttribute]
internal static bool TryGetCachedExpression(Registry r, Request request, IReuse reuse, Rules rules, ImHashMapEntry`2& cacheEntry, Expression& result);
}
internal static class DryIoc.Converter : object {
    private static MethodInfo _convertManyMethod;
    private static Converter();
    public static object ConvertWithOperator(object source, Expression expr, Type targetType, MethodInfo convertMethod);
    public static object ConvertMany(Object[] source, Type targetType);
    public static R[] DoConvertMany(Object[] items);
}
public class DryIoc.CurrentScopeReuse : object {
    public static int DefaultLifespan;
    [CompilerGeneratedAttribute]
private int <Lifespan>k__BackingField;
    [CompilerGeneratedAttribute]
private object <Name>k__BackingField;
    public bool ScopedOrSingleton;
    internal static MethodInfo GetNameScopedViaFactoryDelegateMethod;
    internal static MethodInfo TrackScopedOrSingletonMethod;
    internal static MethodInfo TrackScopedMethod;
    internal static MethodInfo TrackNameScopedMethod;
    public int Lifespan { get; }
    public object Name { get; }
    public CurrentScopeReuse(object name, bool scopedOrSingleton, int lifespan);
    public CurrentScopeReuse(object name, bool scopedOrSingleton);
    private static CurrentScopeReuse();
    [CompilerGeneratedAttribute]
public sealed virtual int get_Lifespan();
    [CompilerGeneratedAttribute]
public sealed virtual object get_Name();
    public sealed virtual bool CanApply(Request request);
    public sealed virtual Expression Apply(Request request, Expression serviceFactoryExpr);
    public sealed virtual Expression ToExpression(S state, Func`3<S, object, Expression> fallbackConverter);
    public virtual string ToString();
    public static object GetScopedOrSingletonViaFactoryDelegateWithDisposalOrder(IResolverContext r, int id, Func`2<IResolverContext, object> createValue, int disposalOrder);
    public static object GetNameScopedViaFactoryDelegate(IResolverContext r, object scopeName, bool throwIfNoScope, int id, Func`2<IResolverContext, object> createValue, int disposalOrder);
    public static object TrackScopedOrSingleton(IResolverContext r, object item);
    public static object TrackScoped(IResolverContext r, bool throwIfNoScope, object item);
    public static object TrackNameScoped(IResolverContext r, object scopeName, bool throwIfNoScope, object item);
}
public class DryIoc.DecoratorRegistrationInfo : ValueType {
    public Factory Factory;
    public Type DecoratorType;
    public DecoratorRegistrationInfo(Factory factory, Type decoratorType);
    public virtual string ToString();
}
public class DryIoc.DefaultDynamicKey : object {
    public static DefaultDynamicKey Value;
    public int RegistrationOrder;
    private static MethodInfo _ofMethod;
    private DefaultDynamicKey(int registrationOrder);
    private static DefaultDynamicKey();
    public static DefaultDynamicKey Of(int registrationOrder);
    public sealed virtual Expression ToExpression(S state, Func`3<S, object, Expression> fallbackConverter);
    public DefaultDynamicKey Next();
    public virtual bool Equals(object key);
    public virtual int GetHashCode();
    public virtual string ToString();
}
public class DryIoc.DefaultKey : object {
    public static DefaultKey Value;
    public int RegistrationOrder;
    private static MethodInfo _ofMethod;
    private DefaultKey(int registrationOrder);
    private static DefaultKey();
    public static DefaultKey Of(int registrationOrder);
    public sealed virtual Expression ToExpression(S state, Func`3<S, object, Expression> fallbackConverter);
    public DefaultKey Next();
    public virtual bool Equals(object key);
    public virtual int GetHashCode();
    public virtual string ToString();
}
public class DryIoc.DelegateFactory : Factory {
    private Func`2<IResolverContext, object> _factoryDelegate;
    public bool HasRuntimeState { get; }
    public Setup Setup { get; }
    public DelegateFactory(Func`2<IResolverContext, object> factoryDelegate);
    public virtual bool get_HasRuntimeState();
    public virtual Setup get_Setup();
    public static DelegateFactory Of(Func`2<IResolverContext, object> factoryDelegate);
    public static DelegateFactory Of(Func`2<IResolverContext, object> factoryDelegate, IReuse reuse);
    public static DelegateFactory Of(Func`2<IResolverContext, object> factoryDelegate, Setup setup);
    public static DelegateFactory Of(Func`2<IResolverContext, object> factoryDelegate, IReuse reuse, Setup setup);
    public virtual Expression CreateExpressionOrDefault(Request request);
    public virtual Func`2<IResolverContext, object> GetDelegateOrDefault(Request request);
}
public class DryIoc.DynamicRegistration : object {
    public Factory Factory;
    public IfAlreadyRegistered IfAlreadyRegistered;
    public object ServiceKey;
    public DynamicRegistration(Factory factory, IfAlreadyRegistered ifAlreadyRegistered, object serviceKey);
}
[FlagsAttribute]
public enum DryIoc.DynamicRegistrationFlags : Enum {
    public byte value__;
    public static DynamicRegistrationFlags NoFlags;
    public static DynamicRegistrationFlags AsFallback;
    public static DynamicRegistrationFlags Service;
    public static DynamicRegistrationFlags Decorator;
    public static DynamicRegistrationFlags DecoratorOfAnyTypeViaObjectServiceType;
}
public static class DryIoc.Error : object {
    private static int _errorIndex;
    public static String[] Messages;
    public static int UnableToResolveUnknownService;
    public static int UnableToResolveFromRegisteredServices;
    public static int ExpectedSingleDefaultFactory;
    public static int RegisteringImplementationNotAssignableToServiceType;
    public static int RegisteredFactoryMethodResultTypesIsNotAssignableToImplementationType;
    public static int ImpossibleToRegisterOpenGenericWithRegisterDelegate;
    public static int RegisteringOpenGenericImplWithNonGenericService;
    public static int RegisteringOpenGenericServiceWithMissingTypeArgs;
    public static int RegisteringNotAGenericTypedefImplType;
    public static int RegisteringNotAGenericTypedefServiceType;
    public static int RegisteringNullImplementationTypeAndNoFactoryMethod;
    public static int RegisteringObjectTypeAsImplementationIsNotSupported;
    public static int RegisteringAbstractImplementationTypeAndNoFactoryMethod;
    public static int UnableToSelectSinglePublicConstructorFromMultiple;
    public static int UnableToSelectSinglePublicConstructorFromNone;
    public static int NoMatchedImplementedTypesWithServiceType;
    public static int NoMatchedFactoryMethodDeclaringTypeWithServiceTypeArgs;
    public static int NoMatchedFactoryMethodWithServiceTypeArgs;
    public static int OpenGenericFactoryMethodDeclaringTypeIsNotSupportedOnThisPlatform;
    public static int ResolvingOpenGenericServiceTypeIsNotPossible;
    public static int RecursiveDependencyDetected;
    public static int ScopeIsDisposed;
    public static int NotFoundOpenGenericImplTypeArgInService;
    public static int UnableToSelectCtor;
    public static int UnableToFindCtorWithAllResolvableArgs;
    public static int RegisteredDelegateResultIsNotOfServiceType;
    public static int NotFoundSpecifiedWritablePropertyOrField;
    public static int PushingToRequestWithoutFactory;
    public static int NoMatchedGenericParamConstraints;
    public static int GenericWrapperWithMultipleTypeArgsShouldSpecifyArgIndex;
    public static int GenericWrapperTypeArgIndexOutOfBounds;
    public static int DependencyHasShorterReuseLifespan;
    public static int WeakRefReuseWrapperGCed;
    public static int ServiceIsNotAssignableFromFactoryMethod;
    public static int GotNullConstructorFromFactoryMethod;
    public static int UnableToRegisterDuplicateDefault;
    public static int UnableToRegisterDuplicateKey;
    public static int NoCurrentScope;
    public static int ContainerIsDisposed;
    public static int NoMatchedScopeFound;
    public static int NotSupportedMadeOfExpression;
    public static int UnexpectedFactoryMemberExpressionInMadeOf;
    public static int UnexpectedExpressionInsteadOfArgMethodInMadeOf;
    public static int UnexpectedExpressionInsteadOfConstantInMadeOf;
    public static int InjectedCustomValueIsOfDifferentType;
    public static int NoConversionOperatorFoundWhenInterpretingTheConvertExpression;
    public static int StateIsRequiredToUseItem;
    public static int ArgValueIndexIsProvidedButNoArgValues;
    public static int ArgValueIndexIsOutOfProvidedArgValues;
    public static int ResolutionNeedsRequiredServiceType;
    public static int RegisterMappingNotFoundRegisteredService;
    public static int RegisterMappingUnableToSelectFromMultipleFactories;
    public static int RegisteringInstanceNotAssignableToServiceType;
    public static int NoMoreRegistrationsAllowed;
    public static int NoMoreUnregistrationsAllowed;
    public static int GotNullFactoryWhenResolvingService;
    public static int RegisteredDisposableTransientWontBeDisposedByContainer;
    public static int NotFoundMetaCtorWithTwoArgs;
    public static int UnableToSelectFromManyRegistrationsWithMatchingMetadata;
    public static int ImplTypeIsNotSpecifiedForAutoCtorSelection;
    public static int NoImplementationForPlaceholder;
    public static int InjectedIntoFactoryDummy;
    public static int DecoratorShouldNotBeRegisteredWithServiceKey;
    public static int PassedCtorOrMemberIsNull;
    public static int PassedMemberIsNotStaticButInstanceFactoryIsNull;
    public static int PassedMemberIsStaticButInstanceFactoryIsNotNull;
    public static int MadeOfCallExpressionParameterDoesNotCorrespondToTheFactoryInfo;
    public static int UndefinedMethodWhenGettingTheSingleMethod;
    public static int UndefinedMethodWhenGettingMethodWithSpecifiedParameters;
    public static int UndefinedPropertyWhenGettingProperty;
    public static int UndefinedFieldWhenGettingField;
    public static int UnableToFindConstructorWithArgs;
    public static int UnableToFindSingleConstructor;
    public static int DisposerTrackForDisposeError;
    public static int NoServicesWereRegisteredByRegisterMany;
    public static int FoundNoRootsToValidate;
    public static int NoServiceTypesToValidate;
    public static int ValidateFoundErrors;
    public static int UnableToInterpretTheNestedLambda;
    public static int WaitForScopedServiceIsCreatedTimeoutExpired;
    public static int ServiceTypeIsNull;
    private static Error();
    private static int Of(string message);
    public static string NameOf(int error);
}
public enum DryIoc.ErrorCheck : Enum {
    public int value__;
    public static ErrorCheck Unspecified;
    public static ErrorCheck InvalidCondition;
    public static ErrorCheck IsNull;
    public static ErrorCheck IsNotOfType;
    public static ErrorCheck TypeIsNotOfType;
    public static ErrorCheck OperationThrows;
    public static ErrorCheck CollectedExceptions;
}
public class DryIoc.ExpressionFactory : Factory {
    [CompilerGeneratedAttribute]
private IReuse <Reuse>k__BackingField;
    [CompilerGeneratedAttribute]
private Setup <Setup>k__BackingField;
    private Func`2<Request, Expression> _getServiceExpression;
    public IReuse Reuse { get; }
    public Setup Setup { get; }
    public ExpressionFactory(Func`2<Request, Expression> getServiceExpression, IReuse reuse, Setup setup);
    [CompilerGeneratedAttribute]
public virtual IReuse get_Reuse();
    [CompilerGeneratedAttribute]
public virtual Setup get_Setup();
    public virtual Expression CreateExpressionOrDefault(Request request);
}
public abstract class DryIoc.Factory : object {
    internal static int _lastFactoryID;
    [CompilerGeneratedAttribute]
private int <FactoryID>k__BackingField;
    [CompilerGeneratedAttribute]
private FactoryFlags <Flags>k__BackingField;
    public int FactoryID { get; internal set; }
    public IReuse Reuse { get; }
    public Setup Setup { get; }
    public FactoryFlags Flags { get; public set; }
    public bool CanCache { get; }
    public FactoryType FactoryType { get; }
    public Type ImplementationType { get; }
    public bool CanAccessImplementationType { get; }
    public int RegistrationOrder { get; }
    public Made Made { get; }
    public bool HasRuntimeState { get; }
    public bool AsResolutionCall { get; }
    public ImHashMap`2<KV`2<Type, object>, ReflectionFactory> GeneratedFactories { get; }
    public ReflectionFactory GeneratorFactory { get; }
    public static int GetNextID();
    [CompilerGeneratedAttribute]
public int get_FactoryID();
    [CompilerGeneratedAttribute]
internal void set_FactoryID(int value);
    public virtual IReuse get_Reuse();
    public virtual Setup get_Setup();
    [CompilerGeneratedAttribute]
public FactoryFlags get_Flags();
    [CompilerGeneratedAttribute]
public void set_Flags(FactoryFlags value);
    public bool get_CanCache();
    public Factory DoNotCache();
    internal void SetAsResolutionCall();
    public bool CheckCondition(Request request);
    public FactoryType get_FactoryType();
    public virtual Type get_ImplementationType();
    public virtual bool get_CanAccessImplementationType();
    public virtual int get_RegistrationOrder();
    public virtual Made get_Made();
    public virtual bool get_HasRuntimeState();
    public bool get_AsResolutionCall();
    public virtual ImHashMap`2<KV`2<Type, object>, ReflectionFactory> get_GeneratedFactories();
    public virtual ReflectionFactory get_GeneratorFactory();
    public virtual Factory GetGeneratedFactoryOrDefault(Request request, bool ifErrorReturnDefault);
    public abstract virtual Expression CreateExpressionOrDefault(Request request);
    public virtual Expression CreateExpressionWithWrappedFactory(Request request, Factory serviceFactory);
    public virtual Expression GetExpressionOrDefault(Request request);
    private static Expression GetWrappedSingletonAccessExpression(Expression e, Setup setup);
    public virtual Func`2<IResolverContext, object> GetDelegateOrDefault(Request request);
    internal virtual bool ValidateAndNormalizeRegistration(Type serviceType, object serviceKey, bool isStaticallyChecked, Rules rules, bool throwIfInvalid);
    public virtual string ToString();
}
[ExtensionAttribute]
public static class DryIoc.FactoryDelegateCompiler : object {
    public static ParameterExpression ResolverContextParamExpr;
    public static ParameterExpression[] ResolverContextParamExprs;
    public static MethodInfo InvokeMethod;
    internal static OneParameterLambdaExpression FactoryDelegateParamExprs;
    private static Type[] _factoryDelegateAndClosureParams;
    private static FactoryDelegateCompiler();
    [ExtensionAttribute]
internal static CachedResult ToCachedResult(object result);
    [ExtensionAttribute]
public static Expression NormalizeExpression(Expression expr);
    [ExtensionAttribute]
public static Expression`1<Func`2<IResolverContext, object>> WrapInFactoryExpression(Expression expression);
    [ExtensionAttribute]
public static Expression`1<Func`2<IResolverContext, object>> WrapInFactoryExpressionWithoutNormalization(Expression expression);
    [ExtensionAttribute]
public static Func`2<IResolverContext, object> CompileToFactoryDelegate(Expression expression, bool preferInterpretation);
    [ExtensionAttribute]
public static object CompileToFactoryDelegate(Expression expression, Type factoryDelegateType, Type resultType, bool preferInterpretation);
}
internal class DryIoc.FactoryDelegateExpression : Expression`1<Func`2<IResolverContext, object>> {
    public Type ReturnType { get; }
    public int ParameterCount { get; }
    public IReadOnlyList`1<ParameterExpression> Parameters { get; }
    public FactoryDelegateExpression(Expression body);
    public virtual Type get_ReturnType();
    public virtual int get_ParameterCount();
    public virtual IReadOnlyList`1<ParameterExpression> get_Parameters();
    public virtual ParameterExpression GetParameter(int index);
}
[FlagsAttribute]
public enum DryIoc.FactoryFlags : Enum {
    public byte value__;
    public static FactoryFlags Default;
    public static FactoryFlags PleaseDontSetDoNotCache;
    public static FactoryFlags DoNotCache;
    public static FactoryFlags AsResolutionCall;
}
public class DryIoc.FactoryMethod : object {
    public MemberInfo ConstructorOrMethodOrMember;
    public static FactoryMethodSelector ConstructorWithResolvableArgumentsIncludingNonPublicWithoutSameTypeParam;
    public static FactoryMethodSelector ConstructorWithResolvableArguments;
    public static FactoryMethodSelector ConstructorWithResolvableArgumentsIncludingNonPublic;
    public ServiceInfo FactoryServiceInfo { get; }
    public Expression FactoryExpression { get; }
    internal Delegate FactoryFunc { get; }
    internal Expression[] ResolvedParameterExpressions { get; }
    public FactoryMethod(MemberInfo memberInfo);
    private static FactoryMethod();
    public virtual ServiceInfo get_FactoryServiceInfo();
    public virtual Expression get_FactoryExpression();
    internal virtual Delegate get_FactoryFunc();
    internal virtual Expression[] get_ResolvedParameterExpressions();
    public static FactoryMethod OfFunc(MethodInfo funcTypedInvokeMethod, D funcOfObjParamsAndResult);
    public static FactoryMethod Of(MemberInfo ctorOrMethodOrMember, ServiceInfo factoryInfo);
    public static FactoryMethod Of(MemberInfo methodOrMember, object factoryInstance);
    internal static FactoryMethod OfFactory(MemberInfo methodOrMember, F factory);
    public static FactoryMethod Of(string methodOrMemberName);
    public virtual string ToString();
    public static FactoryMethodSelector Constructor(bool mostResolvable, bool includeNonPublic);
    private static FactoryMethod MostResolvableConstructor(Request request, BindingFlags additionalToPublicAndInstance, Func`3<Type, ParameterInfo[], bool> condition);
    private static FactoryMethod Constructor(Request request, BindingFlags additionalToPublicAndInstance);
    public static FactoryMethodSelector DefaultConstructor(bool includeNonPublic);
}
public class DryIoc.FactoryMethodSelector : MulticastDelegate {
    public FactoryMethodSelector(object object, IntPtr method);
    public virtual FactoryMethod Invoke(Request request);
    public virtual IAsyncResult BeginInvoke(Request request, AsyncCallback callback, object object);
    public virtual FactoryMethod EndInvoke(IAsyncResult result);
}
public class DryIoc.FactoryPlaceholder : Factory {
    public static Factory Default;
    private static Setup _setup;
    public Setup Setup { get; }
    public IReuse Reuse { get; }
    private static FactoryPlaceholder();
    public virtual Setup get_Setup();
    public virtual IReuse get_Reuse();
    public virtual Expression CreateExpressionOrDefault(Request request);
}
public enum DryIoc.FactoryType : Enum {
    public byte value__;
    public static FactoryType Service;
    public static FactoryType Decorator;
    public static FactoryType Wrapper;
}
public class DryIoc.FastExpressionCompiler.LightExpression.ArrayIndexExpression : BinaryExpression {
    public ExpressionType NodeType { get; }
    public Type Type { get; }
    internal ArrayIndexExpression(Expression left, Expression right);
    public virtual ExpressionType get_NodeType();
    public virtual Type get_Type();
}
public class DryIoc.FastExpressionCompiler.LightExpression.AssignBinaryExpression : BinaryExpression {
    public ExpressionType NodeType { get; }
    public Type Type { get; }
    internal AssignBinaryExpression(Expression left, Expression right);
    public virtual ExpressionType get_NodeType();
    public sealed virtual Type get_Type();
}
public abstract class DryIoc.FastExpressionCompiler.LightExpression.BinaryExpression : Expression {
    public Expression Left;
    public Expression Right;
    public MethodInfo Method { get; }
    public LambdaExpression Conversion { get; }
    public bool IsLifted { get; }
    public bool IsLiftedToNull { get; }
    protected BinaryExpression(Expression left, Expression right);
    public virtual MethodInfo get_Method();
    public virtual LambdaExpression get_Conversion();
    public bool get_IsLifted();
    public bool get_IsLiftedToNull();
    internal virtual Expression CreateSysExpression(LiveCountArray`1& exprsConverted);
}
public class DryIoc.FastExpressionCompiler.LightExpression.BlockExpression : Expression {
    public IReadOnlyList`1<Expression> Expressions;
    public ExpressionType NodeType { get; }
    public Type Type { get; }
    public IReadOnlyList`1<ParameterExpression> Variables { get; }
    public Expression Result { get; }
    public int ArgumentCount { get; }
    internal BlockExpression(IReadOnlyList`1<Expression> expressions);
    public virtual ExpressionType get_NodeType();
    public virtual Type get_Type();
    public virtual IReadOnlyList`1<ParameterExpression> get_Variables();
    public Expression get_Result();
    public virtual int get_ArgumentCount();
    public virtual Expression GetArgument(int index);
    internal virtual Expression CreateSysExpression(LiveCountArray`1& exprsConverted);
}
public class DryIoc.FastExpressionCompiler.LightExpression.BreakGotoExpression : GotoExpression {
    public GotoExpressionKind Kind { get; }
    internal BreakGotoExpression(LabelTarget target);
    public virtual GotoExpressionKind get_Kind();
}
public class DryIoc.FastExpressionCompiler.LightExpression.BreakTypedGotoExpression : TypedGotoExpression {
    public GotoExpressionKind Kind { get; }
    internal BreakTypedGotoExpression(LabelTarget target, Type type);
    public virtual GotoExpressionKind get_Kind();
}
public class DryIoc.FastExpressionCompiler.LightExpression.BreakTypedValueGotoExpression : TypedValueGotoExpression {
    public GotoExpressionKind Kind { get; }
    internal BreakTypedValueGotoExpression(LabelTarget target, Expression value, Type type);
    public virtual GotoExpressionKind get_Kind();
}
public class DryIoc.FastExpressionCompiler.LightExpression.BreakValueGotoExpression : ValueGotoExpression {
    public GotoExpressionKind Kind { get; }
    internal BreakValueGotoExpression(LabelTarget target, Expression value);
    public virtual GotoExpressionKind get_Kind();
}
internal class DryIoc.FastExpressionCompiler.LightExpression.ByRefParameterExpression : ParameterExpression {
    [CompilerGeneratedAttribute]
private Type <Type>k__BackingField;
    public bool IsByRef { get; }
    public Type Type { get; }
    internal ByRefParameterExpression(Type type, string name);
    public virtual bool get_IsByRef();
    [CompilerGeneratedAttribute]
public virtual Type get_Type();
}
public class DryIoc.FastExpressionCompiler.LightExpression.CatchBlock : object {
    public Type Test;
    public ParameterExpression Variable;
    public Expression Body;
    public Expression Filter;
    internal CatchBlock(Type test, ParameterExpression variable, Expression body, Expression filter);
}
internal class DryIoc.FastExpressionCompiler.LightExpression.CoalesceBinaryExpression : BinaryExpression {
    [CompilerGeneratedAttribute]
private Type <Type>k__BackingField;
    public ExpressionType NodeType { get; }
    public Type Type { get; }
    internal CoalesceBinaryExpression(Expression left, Expression right, Type type);
    public sealed virtual ExpressionType get_NodeType();
    [CompilerGeneratedAttribute]
public virtual Type get_Type();
    internal virtual Expression CreateSysExpression(LiveCountArray`1& exprsConverted);
}
internal class DryIoc.FastExpressionCompiler.LightExpression.CoalesceConversionBinaryExpression : CoalesceBinaryExpression {
    [CompilerGeneratedAttribute]
private LambdaExpression <Conversion>k__BackingField;
    public Type Type { get; }
    public LambdaExpression Conversion { get; }
    internal CoalesceConversionBinaryExpression(Expression left, Expression right, LambdaExpression conversion);
    public virtual Type get_Type();
    [CompilerGeneratedAttribute]
public virtual LambdaExpression get_Conversion();
    internal virtual Expression CreateSysExpression(LiveCountArray`1& exprsConverted);
}
[ExtensionAttribute]
public static class DryIoc.FastExpressionCompiler.LightExpression.CodePrinter : object {
    public static Func`3<Type, string, string> PrintTypeStripOuterClasses;
    private static string _nonPubStatMethods;
    private static string _nonPubInstMethods;
    private static Char[] _enumValueSeparators;
    public static ObjectToCode DefaultNotRecognizedToCode;
    private static Type[] TypesImplementedByArray;
    private static CodePrinter();
    [ExtensionAttribute]
public static StringBuilder AppendTypeOf(StringBuilder sb, Type type, bool stripNamespace, Func`3<Type, string, string> printType, bool printGenericTypeArgs);
    [ExtensionAttribute]
public static StringBuilder AppendTypeOfList(StringBuilder sb, Type[] types, bool stripNamespace, Func`3<Type, string, string> printType, bool printGenericTypeArgs);
    [ExtensionAttribute]
internal static StringBuilder AppendMember(StringBuilder sb, MemberInfo member, bool stripNamespace, Func`3<Type, string, string> printType);
    [ExtensionAttribute]
internal static StringBuilder AppendField(StringBuilder sb, FieldInfo field, bool stripNamespace, Func`3<Type, string, string> printType);
    [ExtensionAttribute]
internal static StringBuilder AppendProperty(StringBuilder sb, PropertyInfo property, bool stripNamespace, Func`3<Type, string, string> printType);
    [ExtensionAttribute]
internal static StringBuilder AppendEnum(StringBuilder sb, TEnum value, bool stripNamespace, Func`3<Type, string, string> printType);
    [ExtensionAttribute]
public static StringBuilder AppendMethod(StringBuilder sb, MethodInfo method, bool stripNamespace, Func`3<Type, string, string> printType);
    [ExtensionAttribute]
internal static StringBuilder AppendName(StringBuilder sb, string name, Type type, T identity);
    [ExtensionAttribute]
public static string ToCode(Type type, bool stripNamespace, Func`3<Type, string, string> printType, bool printGenericTypeArgs);
    [ExtensionAttribute]
public static string ToCode(bool x);
    [ExtensionAttribute]
public static string ToCode(string x);
    [ExtensionAttribute]
public static string ToEnumValueCode(Type enumType, object x, bool stripNamespace, Func`3<Type, string, string> printType);
    [ExtensionAttribute]
private static Type[] GetGenericTypeParametersOrArguments(TypeInfo typeInfo);
    [ExtensionAttribute]
public static string ToCommaSeparatedCode(IEnumerable items, ObjectToCode notRecognizedToCode, bool stripNamespace, Func`3<Type, string, string> printType);
    [ExtensionAttribute]
public static string ToArrayInitializerCode(IEnumerable items, Type itemType, ObjectToCode notRecognizedToCode, bool stripNamespace, Func`3<Type, string, string> printType);
    [ExtensionAttribute]
public static string ToCode(object x, ObjectToCode notRecognizedToCode, bool stripNamespace, Func`3<Type, string, string> printType);
    [ExtensionAttribute]
internal static StringBuilder NewLineIdent(StringBuilder sb, int lineIdent);
    [ExtensionAttribute]
internal static StringBuilder NewLine(StringBuilder sb, int lineIdent, int identSpaces);
    [ExtensionAttribute]
internal static StringBuilder NewLineIdentExpr(StringBuilder sb, Expression expr, List`1<ParameterExpression> paramsExprs, List`1<Expression> uniqueExprs, List`1<LabelTarget> lts, int lineIdent, bool stripNamespace, Func`3<Type, string, string> printType, int identSpaces, ObjectToCode notRecognizedToCode);
    [ExtensionAttribute]
internal static StringBuilder NewLineIdentArgumentExprs(StringBuilder sb, IReadOnlyList`1<T> exprs, List`1<ParameterExpression> paramsExprs, List`1<Expression> uniqueExprs, List`1<LabelTarget> lts, int lineIdent, bool stripNamespace, Func`3<Type, string, string> printType, int identSpaces, ObjectToCode notRecognizedToCode);
    [ExtensionAttribute]
internal static StringBuilder NewLineIdentCs(StringBuilder sb, Expression expr, int lineIdent, bool stripNamespace, Func`3<Type, string, string> printType, int identSpaces, ObjectToCode notRecognizedToCode);
    public static int CountLambdas(string code);
}
[FlagsAttribute]
public enum DryIoc.FastExpressionCompiler.LightExpression.CompilerFlags : Enum {
    public byte value__;
    public static CompilerFlags Default;
    public static CompilerFlags NoInvocationLambdaInlining;
    public static CompilerFlags EnableDelegateDebugInfo;
    public static CompilerFlags ThrowOnNotSupportedExpression;
}
public class DryIoc.FastExpressionCompiler.LightExpression.ConditionalExpression : Expression {
    public Expression Test;
    public Expression IfTrue;
    public ExpressionType NodeType { get; }
    public Type Type { get; }
    public Expression IfFalse { get; }
    internal ConditionalExpression(Expression test, Expression ifTrue);
    public virtual ExpressionType get_NodeType();
    public virtual Type get_Type();
    public virtual Expression get_IfFalse();
    internal virtual Expression CreateSysExpression(LiveCountArray`1& exprsConverted);
}
public abstract class DryIoc.FastExpressionCompiler.LightExpression.ConstantExpression : Expression {
    public ExpressionType NodeType { get; }
    public object Value { get; }
    public sealed virtual ExpressionType get_NodeType();
    public abstract virtual object get_Value();
    internal virtual Expression CreateSysExpression(LiveCountArray`1& _);
    public virtual string ToString();
}
public class DryIoc.FastExpressionCompiler.LightExpression.ContinueGotoExpression : GotoExpression {
    public GotoExpressionKind Kind { get; }
    internal ContinueGotoExpression(LabelTarget target);
    public virtual GotoExpressionKind get_Kind();
}
public class DryIoc.FastExpressionCompiler.LightExpression.ContinueTypedGotoExpression : TypedGotoExpression {
    public GotoExpressionKind Kind { get; }
    internal ContinueTypedGotoExpression(LabelTarget target, Type type);
    public virtual GotoExpressionKind get_Kind();
}
public class DryIoc.FastExpressionCompiler.LightExpression.ConvertIntrinsicExpression : ConvertIntrinsicExpression`1<object> {
    [CompilerGeneratedAttribute]
private Type <Type>k__BackingField;
    public Type Type { get; }
    internal ConvertIntrinsicExpression(Expression operand, Type type);
    [CompilerGeneratedAttribute]
public virtual Type get_Type();
}
public class DryIoc.FastExpressionCompiler.LightExpression.ConvertIntrinsicExpression`1 : UnaryExpression {
    public ExpressionType NodeType { get; }
    public Type Type { get; }
    public bool IsIntrinsic { get; }
    internal ConvertIntrinsicExpression`1(Expression operand);
    public sealed virtual ExpressionType get_NodeType();
    public virtual Type get_Type();
    public virtual bool get_IsIntrinsic();
    public virtual bool TryCollectBoundConstants(CompilerFlags config, ClosureInfo& closure, IParameterProvider paramExprs, bool isNestedLambda, ClosureInfo& rootClosure);
    public virtual bool TryEmit(CompilerFlags config, ClosureInfo& closure, IParameterProvider paramExprs, ILGenerator il, ParentFlags parent, int byRefIndex);
}
public class DryIoc.FastExpressionCompiler.LightExpression.ConvertUnaryExpression : UnaryExpression {
    [CompilerGeneratedAttribute]
private Type <Type>k__BackingField;
    public ExpressionType NodeType { get; }
    public Type Type { get; }
    public ConvertUnaryExpression(Expression operand, Type type);
    public virtual ExpressionType get_NodeType();
    [CompilerGeneratedAttribute]
public virtual Type get_Type();
}
public class DryIoc.FastExpressionCompiler.LightExpression.ConvertWithMethodUnaryExpression : TypedUnaryExpression {
    [CompilerGeneratedAttribute]
private MethodInfo <Method>k__BackingField;
    public MethodInfo Method { get; }
    public ConvertWithMethodUnaryExpression(ExpressionType nodeType, Expression operand, Type type, MethodInfo method);
    [CompilerGeneratedAttribute]
public virtual MethodInfo get_Method();
}
public class DryIoc.FastExpressionCompiler.LightExpression.DebugInfoExpression : Expression {
    public SymbolDocumentInfo Document;
    [CompilerGeneratedAttribute]
private int <StartLine>k__BackingField;
    [CompilerGeneratedAttribute]
private int <StartColumn>k__BackingField;
    [CompilerGeneratedAttribute]
private int <EndLine>k__BackingField;
    [CompilerGeneratedAttribute]
private int <EndColumn>k__BackingField;
    public ExpressionType NodeType { get; }
    public Type Type { get; }
    public int StartLine { get; }
    public int StartColumn { get; }
    public int EndLine { get; }
    public int EndColumn { get; }
    public bool IsClear { get; }
    internal DebugInfoExpression(SymbolDocumentInfo document, int startLine, int startColumn, int endLine, int endColumn);
    public sealed virtual ExpressionType get_NodeType();
    public sealed virtual Type get_Type();
    [CompilerGeneratedAttribute]
public virtual int get_StartLine();
    [CompilerGeneratedAttribute]
public virtual int get_StartColumn();
    [CompilerGeneratedAttribute]
public virtual int get_EndLine();
    [CompilerGeneratedAttribute]
public virtual int get_EndColumn();
    public virtual bool get_IsClear();
    internal virtual Expression CreateSysExpression(LiveCountArray`1& convertedExpressions);
}
public class DryIoc.FastExpressionCompiler.LightExpression.DefaultExpression : Expression {
    [CompilerGeneratedAttribute]
private Type <Type>k__BackingField;
    public ExpressionType NodeType { get; }
    public Type Type { get; }
    internal DefaultExpression(Type type);
    public virtual ExpressionType get_NodeType();
    [CompilerGeneratedAttribute]
public virtual Type get_Type();
    internal virtual Expression CreateSysExpression(LiveCountArray`1& exprsConverted);
}
public class DryIoc.FastExpressionCompiler.LightExpression.DynamicExpression : Expression {
    [CompilerGeneratedAttribute]
private Type <DelegateType>k__BackingField;
    [CompilerGeneratedAttribute]
private CallSiteBinder <Binder>k__BackingField;
    [CompilerGeneratedAttribute]
private IReadOnlyList`1<Expression> <Arguments>k__BackingField;
    public ExpressionType NodeType { get; }
    public Type Type { get; }
    public Type DelegateType { get; }
    public CallSiteBinder Binder { get; }
    public IReadOnlyList`1<Expression> Arguments { get; }
    public DynamicExpression(Type delegateType, CallSiteBinder binder, IReadOnlyList`1<Expression> arguments);
    public virtual ExpressionType get_NodeType();
    public virtual Type get_Type();
    [CompilerGeneratedAttribute]
public Type get_DelegateType();
    [CompilerGeneratedAttribute]
public CallSiteBinder get_Binder();
    [CompilerGeneratedAttribute]
public IReadOnlyList`1<Expression> get_Arguments();
    internal virtual Expression CreateSysExpression(LiveCountArray`1& exprsConverted);
}
public class DryIoc.FastExpressionCompiler.LightExpression.ElementInit : object {
    public MethodInfo AddMethod;
    public IReadOnlyList`1<Expression> Arguments { get; }
    public int ArgumentCount { get; }
    internal ElementInit(MethodInfo addMethod);
    public virtual IReadOnlyList`1<Expression> get_Arguments();
    public virtual int get_ArgumentCount();
    public virtual Expression GetArgument(int i);
}
public abstract class DryIoc.FastExpressionCompiler.LightExpression.Expression : object {
    public static ConstantExpression NullConstant;
    public static ConstantExpression FalseConstant;
    public static ConstantExpression TrueConstant;
    public static ConstantExpression ZeroConstant;
    public static ConstantExpression OneConstant;
    public static ConstantExpression MinusOneConstant;
    public static DefaultExpression VoidDefault;
    public ExpressionType NodeType { get; }
    public Type Type { get; }
    public object Tag { get; }
    public bool IsIntrinsic { get; }
    private static Expression();
    public abstract virtual ExpressionType get_NodeType();
    public abstract virtual Type get_Type();
    public virtual object get_Tag();
    public virtual bool get_IsIntrinsic();
    public virtual bool TryCollectBoundConstants(CompilerFlags config, ClosureInfo& closure, IParameterProvider paramExprs, bool isNestedLambda, ClosureInfo& rootClosure);
    public virtual bool TryEmit(CompilerFlags config, ClosureInfo& closure, IParameterProvider paramExprs, ILGenerator il, ParentFlags parent, int byRefIndex);
    protected internal virtual Expression VisitChildren(ExpressionVisitor visitor);
    public Expression ToExpression();
    internal Expression ToExpression(LiveCountArray`1& exprsConverted);
    internal abstract virtual Expression CreateSysExpression(LiveCountArray`1& convertedExpressions);
    public virtual string ToString();
    public virtual Expression Reduce();
    internal static Expression[] ToExpressions(IReadOnlyList`1<Expression> exprs, LiveCountArray`1& exprsConverted);
    public static ParameterExpression Parameter(Type type, string name);
    public static ParameterExpression ParameterOf(string name);
    public static ParameterExpression Variable(Type type, string name);
    private static ParameterExpression TryToMakeKnownTypeParameter(Type type, string name);
    public static ConstantExpression Constant(bool value);
    public static ConstantExpression Constant(object value);
    public static ConstantExpression Constant(object value, Type type);
    public static ConstantExpression ConstantNull(Type type);
    public static ConstantExpression ConstantNull();
    public static ConstantExpression ConstantInt(int value);
    public static ConstantExpression ConstantOf(T value);
    public static int TryGetIntConstantValue(Expression e);
    public static NewExpression New(Type type);
    public static NewExpression New(ConstructorInfo ctor, IReadOnlyList`1<Expression> arguments);
    public static NewExpression New(ConstructorInfo ctor, Expression[] arguments);
    public static NewExpression New(ConstructorInfo ctor, IEnumerable`1<Expression> arguments);
    public static NewExpression NewNoByRefArgs(ConstructorInfo ctor, IReadOnlyList`1<Expression> arguments);
    public static NewExpression New(ConstructorInfo ctor);
    public static NewExpression New(ConstructorInfo ctor, Expression arg);
    public static NewExpression NewObjArgs(ConstructorInfo ctor, object arg);
    public static NewExpression NewNoByRefArgs(ConstructorInfo ctor, object arg);
    public static NewExpression New(ConstructorInfo ctor, Expression arg0, Expression arg1);
    public static NewExpression NewObjArgs(ConstructorInfo ctor, object arg0, object arg1);
    public static NewExpression NewNoByRefArgs(ConstructorInfo ctor, object arg0, object arg1);
    public static NewExpression New(ConstructorInfo ctor, Expression arg0, Expression arg1, Expression arg2);
    public static NewExpression New(ConstructorInfo ctor, object arg0, object arg1, object arg2);
    public static NewExpression NewNoByRefArgs(ConstructorInfo ctor, object arg0, object arg1, object arg2);
    public static NewExpression New(ConstructorInfo ctor, Expression arg0, Expression arg1, Expression arg2, Expression arg3);
    public static NewExpression NewObjArgs(ConstructorInfo ctor, object arg0, object arg1, object arg2, object arg3);
    public static NewExpression NewNoByRefArgs(ConstructorInfo ctor, object arg0, object arg1, object arg2, object arg3);
    public static NewExpression New(ConstructorInfo ctor, Expression arg0, Expression arg1, Expression arg2, Expression arg3, Expression arg4);
    public static NewExpression NewObjArgs(ConstructorInfo ctor, object arg0, object arg1, object arg2, object arg3, object arg4);
    public static NewExpression NewNoByRefArgs(ConstructorInfo ctor, object arg0, object arg1, object arg2, object arg3, object arg4);
    public static NewExpression New(ConstructorInfo ctor, Expression arg0, Expression arg1, Expression arg2, Expression arg3, Expression arg4, Expression arg5);
    public static NewExpression NewObjArgs(ConstructorInfo ctor, object arg0, object arg1, object arg2, object arg3, object arg4, object arg5);
    public static NewExpression NewNoByRefArgs(ConstructorInfo ctor, object arg0, object arg1, object arg2, object arg3, object arg4, object arg5);
    public static NewExpression New(ConstructorInfo ctor, Expression arg0, Expression arg1, Expression arg2, Expression arg3, Expression arg4, Expression arg5, Expression arg6);
    public static NewExpression NewObjArgs(ConstructorInfo ctor, object arg0, object arg1, object arg2, object arg3, object arg4, object arg5, object arg6);
    public static NewExpression NewNoByRefArgs(ConstructorInfo ctor, object arg0, object arg1, object arg2, object arg3, object arg4, object arg5, object arg6);
    public static MethodCallExpression Call(MethodInfo method, IReadOnlyList`1<Expression> arguments);
    public static MethodCallExpression Call(MethodInfo method, Expression[] arguments);
    public static MethodCallExpression Call(MethodInfo method, IEnumerable`1<Expression> arguments);
    public static MethodCallExpression Call(Expression instance, MethodInfo method, IReadOnlyList`1<Expression> arguments);
    public static MethodCallExpression Call(Expression instance, MethodInfo method, Expression[] arguments);
    public static MethodCallExpression Call(Expression instance, MethodInfo method, IEnumerable`1<Expression> arguments);
    public static MethodCallExpression Call(Type type, string methodName, Type[] typeArguments, IReadOnlyList`1<Expression> arguments);
    public static MethodCallExpression Call(Type type, string methodName, Type[] typeArguments, Expression[] arguments);
    public static MethodCallExpression Call(Type type, string methodName, Type[] typeArguments, IEnumerable`1<Expression> arguments);
    public static MethodCallExpression Call(Expression instance, string methodName, Type[] typeArguments, IReadOnlyList`1<Expression> arguments);
    public static MethodCallExpression Call(Expression instance, string methodName, Type[] typeArguments, Expression[] arguments);
    public static MethodCallExpression Call(Expression instance, string methodName, Type[] typeArguments, IEnumerable`1<Expression> arguments);
    public static MethodCallExpression Call(MethodInfo method);
    public static MethodCallExpression Call(Expression instance, MethodInfo method);
    public static MethodCallExpression Call(MethodInfo method, Expression argument);
    public static MethodCallExpression Call(Expression instance, MethodInfo method, Expression argument);
    public static MethodCallExpression Call(MethodInfo method, Expression arg0, Expression arg1);
    public static MethodCallExpression Call(Expression instance, MethodInfo method, Expression arg0, Expression arg1);
    public static MethodCallExpression Call(MethodInfo method, Expression arg0, Expression arg1, Expression arg2);
    public static MethodCallExpression Call(Expression instance, MethodInfo method, Expression arg0, Expression arg1, Expression arg2);
    public static MethodCallExpression Call(MethodInfo method, Expression arg0, Expression arg1, Expression arg2, Expression arg3);
    public static MethodCallExpression Call(Expression instance, MethodInfo method, Expression arg0, Expression arg1, Expression arg2, Expression arg3);
    public static MethodCallExpression Call(MethodInfo method, Expression arg0, Expression arg1, Expression arg2, Expression arg3, Expression arg4);
    public static MethodCallExpression Call(Expression instance, MethodInfo method, Expression arg0, Expression arg1, Expression arg2, Expression arg3, Expression arg4);
    public static MethodCallExpression Call(MethodInfo method, Expression arg0, Expression arg1, Expression arg2, Expression arg3, Expression arg4, Expression arg5);
    public static MethodCallExpression Call(Expression instance, MethodInfo method, Expression arg0, Expression arg1, Expression arg2, Expression arg3, Expression arg4, Expression arg5);
    public static MethodCallExpression Call(Expression instance, MethodInfo method, Expression arg0, Expression arg1, Expression arg2, Expression arg3, Expression arg4, Expression arg5, Expression arg6);
    public static Expression CallIfNotNull(Expression instance, MethodInfo method);
    public static Expression CallIfNotNull(Expression instance, MethodInfo method, IEnumerable`1<Expression> arguments);
    public static MemberExpression Property(PropertyInfo property);
    public static MemberExpression Property(Expression instance, PropertyInfo property);
    public static MemberExpression Property(Expression expression, string propertyName);
    public static IndexExpression Property(Expression instance, PropertyInfo indexer, Expression argument);
    public static IndexExpression Property(Expression instance, PropertyInfo indexer, Expression[] arguments);
    public static IndexExpression Property(Expression instance, PropertyInfo indexer, IEnumerable`1<Expression> arguments);
    public static MemberExpression PropertyOrField(Expression expression, string memberName);
    public static MemberExpression MakeMemberAccess(Expression expression, MemberInfo member);
    public static IndexExpression MakeIndex(Expression instance, PropertyInfo indexer, IEnumerable`1<Expression> arguments);
    public static IndexExpression ArrayAccess(Expression array, Expression index);
    public static IndexExpression ArrayAccess(Expression array, IReadOnlyList`1<Expression> indexes);
    public static IndexExpression ArrayAccess(Expression array, Expression[] indexes);
    public static IndexExpression ArrayAccess(Expression array, IEnumerable`1<Expression> indexes);
    public static MemberExpression Field(FieldInfo field);
    public static MemberExpression Field(Expression instance, FieldInfo field);
    public static MemberExpression Field(Expression instance, string fieldName);
    public static UnaryExpression Not(Expression expression);
    public static UnaryExpression TypeAs(Expression expression, Type type);
    public static TypeBinaryExpression TypeEqual(Expression operand, Type type);
    public static TypeBinaryExpression TypeIs(Expression operand, Type type);
    public static UnaryExpression ArrayLength(Expression array);
    public static UnaryExpression Convert(Expression expression, Type type);
    public static UnaryExpression Convert(Expression expression);
    public static UnaryExpression TryConvertIntrinsic(Expression expression, Type type);
    public static UnaryExpression TryConvertIntrinsic(Expression expression);
    public static UnaryExpression Convert(Expression expression, Type type, MethodInfo method);
    public static UnaryExpression ConvertChecked(Expression expression, Type type);
    public static UnaryExpression ConvertChecked(Expression expression, Type type, MethodInfo method);
    public static UnaryExpression Decrement(Expression expression);
    public static UnaryExpression Increment(Expression expression);
    public static UnaryExpression IsFalse(Expression expression);
    public static UnaryExpression IsTrue(Expression expression);
    public static UnaryExpression MakeUnary(ExpressionType unaryType, Expression operand, Type type);
    public static UnaryExpression Negate(Expression expression);
    public static UnaryExpression NegateChecked(Expression expression);
    public static UnaryExpression OnesComplement(Expression expression);
    public static UnaryExpression PreIncrementAssign(Expression expression);
    public static UnaryExpression PostIncrementAssign(Expression expression);
    public static UnaryExpression PreDecrementAssign(Expression expression);
    public static UnaryExpression PostDecrementAssign(Expression expression);
    public static UnaryExpression Quote(Expression expression);
    public static UnaryExpression UnaryPlus(Expression expression);
    public static UnaryExpression Unbox(Expression expression, Type type);
    public static LambdaExpression Lambda(Expression body);
    public static LambdaExpression Lambda(Type delegateType, Expression body);
    public static LambdaExpression Lambda(Type delegateType, Expression body, Type returnType);
    public static LambdaExpression Lambda(Expression body, IReadOnlyList`1<ParameterExpression> parameters);
    public static LambdaExpression Lambda(Expression body, ParameterExpression[] parameters);
    public static LambdaExpression Lambda(Expression body, IEnumerable`1<ParameterExpression> parameters);
    public static LambdaExpression Lambda(Expression body, ParameterExpression parameter);
    public static LambdaExpression Lambda(Expression body, ParameterExpression p0, ParameterExpression p1);
    public static LambdaExpression Lambda(Expression body, ParameterExpression p0, ParameterExpression p1, ParameterExpression p2);
    public static LambdaExpression Lambda(Expression body, ParameterExpression p0, ParameterExpression p1, ParameterExpression p2, ParameterExpression p3);
    public static LambdaExpression Lambda(Expression body, ParameterExpression p0, ParameterExpression p1, ParameterExpression p2, ParameterExpression p3, ParameterExpression p4);
    public static LambdaExpression Lambda(Expression body, ParameterExpression p0, ParameterExpression p1, ParameterExpression p2, ParameterExpression p3, ParameterExpression p4, ParameterExpression p5);
    public static LambdaExpression Lambda(Expression body, IReadOnlyList`1<ParameterExpression> parameters, Type returnType);
    public static LambdaExpression Lambda(Expression body, IEnumerable`1<ParameterExpression> parameters, Type returnType);
    public static LambdaExpression Lambda(Type delegateType, Expression body, IReadOnlyList`1<ParameterExpression> parameters);
    public static LambdaExpression Lambda(Type delegateType, Expression body, ParameterExpression[] parameters);
    public static LambdaExpression Lambda(Type delegateType, Expression body, IReadOnlyList`1<ParameterExpression> parameters, Type returnType);
    public static LambdaExpression Lambda(Type delegateType, Expression body, IEnumerable`1<ParameterExpression> parameters, Type returnType);
    public static LambdaExpression Lambda(Type delegateType, Expression body, ParameterExpression p0, Type returnType);
    public static LambdaExpression Lambda(Type delegateType, Expression body, ParameterExpression p0, ParameterExpression p1, Type returnType);
    public static LambdaExpression Lambda(Type delegateType, Expression body, ParameterExpression p0, ParameterExpression p1, ParameterExpression p2, Type returnType);
    public static LambdaExpression Lambda(Type delegateType, Expression body, ParameterExpression p0, ParameterExpression p1, ParameterExpression p2, ParameterExpression p3, Type returnType);
    public static LambdaExpression Lambda(Type delegateType, Expression body, ParameterExpression p0, ParameterExpression p1, ParameterExpression p2, ParameterExpression p3, ParameterExpression p4, Type returnType);
    public static LambdaExpression Lambda(Type delegateType, Expression body, ParameterExpression p0, ParameterExpression p1, ParameterExpression p2, ParameterExpression p3, ParameterExpression p4, ParameterExpression p5, Type returnType);
    public static Expression`1<TDelegate> Lambda(Expression body);
    public static Expression`1<TDelegate> Lambda(Expression body, Type returnType);
    public static Expression`1<TDelegate> Lambda(Expression body, ParameterExpression p0, Type returnType);
    public static Expression`1<TDelegate> Lambda(Expression body, ParameterExpression p0);
    public static Expression`1<TDelegate> Lambda(Expression body, ParameterExpression p0, ParameterExpression p1, Type returnType);
    public static Expression`1<TDelegate> Lambda(Expression body, ParameterExpression p0, ParameterExpression p1);
    public static Expression`1<TDelegate> Lambda(Expression body, ParameterExpression p0, ParameterExpression p1, ParameterExpression p2, Type returnType);
    public static Expression`1<TDelegate> Lambda(Expression body, ParameterExpression p0, ParameterExpression p1, ParameterExpression p2);
    public static Expression`1<TDelegate> Lambda(Expression body, ParameterExpression p0, ParameterExpression p1, ParameterExpression p2, ParameterExpression p3, Type returnType);
    public static Expression`1<TDelegate> Lambda(Expression body, ParameterExpression p0, ParameterExpression p1, ParameterExpression p2, ParameterExpression p3);
    public static Expression`1<TDelegate> Lambda(Expression body, ParameterExpression p0, ParameterExpression p1, ParameterExpression p2, ParameterExpression p3, ParameterExpression p4, Type returnType);
    public static Expression`1<TDelegate> Lambda(Expression body, ParameterExpression p0, ParameterExpression p1, ParameterExpression p2, ParameterExpression p3, ParameterExpression p4);
    public static Expression`1<TDelegate> Lambda(Expression body, ParameterExpression p0, ParameterExpression p1, ParameterExpression p2, ParameterExpression p3, ParameterExpression p4, ParameterExpression p5, Type returnType);
    public static Expression`1<TDelegate> Lambda(Expression body, ParameterExpression p0, ParameterExpression p1, ParameterExpression p2, ParameterExpression p3, ParameterExpression p4, ParameterExpression p5);
    public static Expression`1<TDelegate> Lambda(Expression body, IReadOnlyList`1<ParameterExpression> parameters, Type returnType);
    public static Expression`1<TDelegate> Lambda(Expression body, IEnumerable`1<ParameterExpression> parameters, Type returnType);
    public static Expression`1<TDelegate> Lambda(Expression body, ParameterExpression[] parameters);
    public static Expression`1<TDelegate> Lambda(Expression body, IEnumerable`1<ParameterExpression> parameters);
    public static Expression`1<TDelegate> Lambda(Expression body, string name, ParameterExpression[] parameters);
    private static Type GetDelegateReturnType(Type delegateType);
    public static BinaryExpression ArrayIndex(Expression array, Expression index);
    public static BinaryExpression ArrayIndex(Expression array, Expression index, MethodInfo method);
    public static MethodCallExpression ArrayIndex(Expression array, IEnumerable`1<Expression> indexes);
    public static MethodCallExpression ArrayIndex(Expression array, Expression[] indexes);
    public static MemberAssignment Bind(MemberInfo member, Expression expression);
    public static MemberMemberBinding MemberBind(MemberInfo member, MemberBinding[] bindings);
    public static MemberMemberBinding MemberBind(MemberInfo member, IEnumerable`1<MemberBinding> bindings);
    public static MemberListBinding ListBind(MemberInfo member, ElementInit[] initializers);
    public static MemberListBinding ListBind(MemberInfo member, IEnumerable`1<ElementInit> initializers);
    public static MemberInitExpression MemberInit(NewExpression newExpr);
    public static MemberInitExpression MemberInit(NewExpression newExpr, MemberBinding binding);
    public static MemberInitExpression MemberInit(NewExpression newExpr, MemberBinding b0, MemberBinding b1);
    public static MemberInitExpression MemberInit(NewExpression newExpr, MemberBinding b0, MemberBinding b1, MemberBinding b2);
    public static MemberInitExpression MemberInit(NewExpression newExpr, MemberBinding b0, MemberBinding b1, MemberBinding b2, MemberBinding b3);
    public static MemberInitExpression MemberInit(NewExpression newExpr, MemberBinding b0, MemberBinding b1, MemberBinding b2, MemberBinding b3, MemberBinding b4);
    public static MemberInitExpression MemberInit(NewExpression newExpr, MemberBinding b0, MemberBinding b1, MemberBinding b2, MemberBinding b3, MemberBinding b4, MemberBinding b5);
    public static MemberInitExpression MemberInit(NewExpression newExpr, IReadOnlyList`1<MemberBinding> bindings);
    public static MemberInitExpression MemberInit(NewExpression newExpr, MemberBinding[] bindings);
    public static MemberInitExpression MemberInit(NewExpression newExpr, IEnumerable`1<MemberBinding> bindings);
    public static MemberInitExpression MemberInit(Expression expression, IReadOnlyList`1<MemberBinding> bindings);
    public static MemberInitExpression MemberInit(Expression expression, MemberBinding[] assignments);
    public static MemberInitExpression MemberInitMany(Expression expression, MemberBinding[] assignments);
    public static MemberInitExpression MemberInit(Expression expression, IEnumerable`1<MemberBinding> assignments);
    public static ListInitExpression ListInit(NewExpression newExpression, IReadOnlyList`1<ElementInit> initializers);
    public static ListInitExpression ListInit(NewExpression newExpression, ElementInit[] initializers);
    public static ListInitExpression ListInit(NewExpression newExpression, IEnumerable`1<ElementInit> initializers);
    public static NewArrayExpression NewArrayInit(Type type, IReadOnlyList`1<Expression> initializers);
    public static NewArrayExpression NewArrayInit(Type type, Expression[] initializers);
    public static NewArrayExpression NewArrayInit(Type type, IEnumerable`1<Expression> initializers);
    public static NewArrayExpression NewArrayInit(Type type, Expression element);
    public static NewArrayExpression NewArrayInit(Type type, Expression el0, Expression el1);
    public static NewArrayExpression NewArrayInit(Type type, Expression el0, Expression el1, Expression el2);
    public static NewArrayExpression NewArrayInit(Type type, Expression el0, Expression el1, Expression el2, Expression el3);
    public static NewArrayExpression NewArrayInit(Type type, Expression el0, Expression el1, Expression el2, Expression el3, Expression el4);
    public static NewArrayExpression NewArrayInit(Type type, Expression el0, Expression el1, Expression el2, Expression el3, Expression el4, Expression el5);
    public static NewArrayExpression NewArrayBounds(Type type, Expression bound);
    public static NewArrayExpression MakeArrayBounds(Type type, IReadOnlyList`1<Expression> bounds);
    public static NewArrayExpression NewArrayBounds(Type type, Expression[] bounds);
    public static NewArrayExpression NewArrayBounds(Type type, IEnumerable`1<Expression> bounds);
    public static BinaryExpression Assign(Expression left, Expression right);
    public static BinaryExpression PowerAssign(Expression left, Expression right);
    public static BinaryExpression AddAssign(Expression left, Expression right);
    public static BinaryExpression AddAssignChecked(Expression left, Expression right);
    public static BinaryExpression AndAssign(Expression left, Expression right);
    public static BinaryExpression OrAssign(Expression left, Expression right);
    public static BinaryExpression ExclusiveOrAssign(Expression left, Expression right);
    public static BinaryExpression RightShiftAssign(Expression left, Expression right);
    public static BinaryExpression LeftShiftAssign(Expression left, Expression right);
    public static BinaryExpression ModuloAssign(Expression left, Expression right);
    public static BinaryExpression SubtractAssign(Expression left, Expression right);
    public static BinaryExpression SubtractAssignChecked(Expression left, Expression right);
    public static BinaryExpression MultiplyAssign(Expression left, Expression right);
    public static BinaryExpression MultiplyAssignChecked(Expression left, Expression right);
    public static BinaryExpression DivideAssign(Expression left, Expression right);
    public static ElementInit ElementInit(MethodInfo addMethod, Expression arg);
    public static ElementInit ElementInit(MethodInfo addMethod, IReadOnlyList`1<Expression> arguments);
    public static ElementInit ElementInit(MethodInfo addMethod, Expression[] arguments);
    public static ElementInit ElementInit(MethodInfo addMethod, IEnumerable`1<Expression> arguments);
    public static InvocationExpression Invoke(LambdaExpression expression);
    public static InvocationExpression Invoke(LambdaExpression expression, Expression a0);
    public static InvocationExpression Invoke(Expression expression, Expression a0);
    public static InvocationExpression Invoke(Type returnType, Expression expression, Expression a0);
    public static InvocationExpression Invoke(LambdaExpression expression, Expression a0, Expression a1);
    public static InvocationExpression Invoke(Expression expression, Expression a0, Expression a1);
    public static InvocationExpression Invoke(Type returnType, Expression expression, Expression a0, Expression a1);
    public static InvocationExpression Invoke(LambdaExpression expression, Expression a0, Expression a1, Expression a2);
    public static InvocationExpression Invoke(Expression expression, Expression a0, Expression a1, Expression a2);
    public static InvocationExpression Invoke(Type returnType, Expression expression, Expression a0, Expression a1, Expression a2);
    public static InvocationExpression Invoke(LambdaExpression expression, Expression a0, Expression a1, Expression a2, Expression a3);
    public static InvocationExpression Invoke(Expression expression, Expression a0, Expression a1, Expression a2, Expression a3);
    public static InvocationExpression Invoke(Type returnType, Expression expression, Expression a0, Expression a1, Expression a2, Expression a3);
    public static InvocationExpression Invoke(LambdaExpression expression, Expression a0, Expression a1, Expression a2, Expression a3, Expression a4);
    public static InvocationExpression Invoke(Expression expression, Expression a0, Expression a1, Expression a2, Expression a3, Expression a4);
    public static InvocationExpression Invoke(Type returnType, Expression expression, Expression a0, Expression a1, Expression a2, Expression a3, Expression a4);
    public static InvocationExpression Invoke(LambdaExpression expression, Expression a0, Expression a1, Expression a2, Expression a3, Expression a4, Expression a5);
    public static InvocationExpression Invoke(Expression expression, Expression a0, Expression a1, Expression a2, Expression a3, Expression a4, Expression a5);
    public static InvocationExpression Invoke(Type returnType, Expression expression, Expression a0, Expression a1, Expression a2, Expression a3, Expression a4, Expression a5);
    public static InvocationExpression Invoke(Expression expression, IReadOnlyList`1<Expression> args);
    public static InvocationExpression Invoke(Expression expression, Expression[] args);
    public static InvocationExpression Invoke(Expression expression, IEnumerable`1<Expression> args);
    public static InvocationExpression Invoke(Type returnType, Expression expression, IReadOnlyList`1<Expression> args);
    public static InvocationExpression Invoke(Type returnType, Expression expression, Expression[] args);
    public static InvocationExpression Invoke(Type returnType, Expression expression, IEnumerable`1<Expression> args);
    public static ConditionalExpression Condition(Expression test, Expression ifTrue, Expression ifFalse);
    public static ConditionalExpression Condition(Expression test, Expression ifTrue, Expression ifFalse, Type type);
    public static ConditionalExpression IfThen(Expression test, Expression ifTrue);
    public static ConditionalExpression IfThenElse(Expression test, Expression ifTrue, Expression ifFalse);
    public static DefaultExpression Empty();
    public static DefaultExpression Default(Type type);
    public static BinaryExpression GetArithmeticBinary(ExpressionType nodeType, Expression left, Expression right, MethodInfo method);
    public static BinaryExpression GetLeftTypedBinary(ExpressionType nodeType, Expression left, Expression right, MethodInfo method);
    public static BinaryExpression Add(Expression left, Expression right);
    public static BinaryExpression Add(Expression left, Expression right, MethodInfo method);
    public static BinaryExpression AddChecked(Expression left, Expression right);
    public static BinaryExpression AddChecked(Expression left, Expression right, MethodInfo method);
    public static BinaryExpression ExclusiveOr(Expression left, Expression right);
    public static BinaryExpression ExclusiveOr(Expression left, Expression right, MethodInfo method);
    public static BinaryExpression LeftShift(Expression left, Expression right);
    public static BinaryExpression LeftShift(Expression left, Expression right, MethodInfo method);
    public static BinaryExpression Modulo(Expression left, Expression right);
    public static BinaryExpression Modulo(Expression left, Expression right, MethodInfo method);
    public static BinaryExpression RightShift(Expression left, Expression right);
    public static BinaryExpression RightShift(Expression left, Expression right, MethodInfo method);
    public static BinaryExpression Subtract(Expression left, Expression right);
    public static BinaryExpression Subtract(Expression left, Expression right, MethodInfo method);
    public static BinaryExpression SubtractChecked(Expression left, Expression right);
    public static BinaryExpression SubtractChecked(Expression left, Expression right, MethodInfo method);
    public static BinaryExpression Multiply(Expression left, Expression right);
    public static BinaryExpression Multiply(Expression left, Expression right, MethodInfo method);
    public static BinaryExpression MultiplyChecked(Expression left, Expression right);
    public static BinaryExpression MultiplyChecked(Expression left, Expression right, MethodInfo method);
    public static BinaryExpression Divide(Expression left, Expression right);
    public static BinaryExpression Divide(Expression left, Expression right, MethodInfo method);
    public static BinaryExpression Power(Expression left, Expression right);
    public static BinaryExpression Power(Expression left, Expression right, MethodInfo method);
    public static BinaryExpression And(Expression left, Expression right);
    public static BinaryExpression And(Expression left, Expression right, MethodInfo method);
    public static BinaryExpression AndAlso(Expression left, Expression right);
    public static BinaryExpression AndAlso(Expression left, Expression right, MethodInfo method);
    public static BinaryExpression Or(Expression left, Expression right);
    public static BinaryExpression Or(Expression left, Expression right, MethodInfo method);
    public static BinaryExpression GetLogicalBinary(ExpressionType nodeType, Expression left, Expression right, bool liftToNull, MethodInfo method);
    public static BinaryExpression OrElse(Expression left, Expression right);
    public static BinaryExpression OrElse(Expression left, Expression right, MethodInfo method);
    public static BinaryExpression Equal(Expression left, Expression right);
    public static BinaryExpression Equal(Expression left, Expression right, bool liftToNull, MethodInfo method);
    public static BinaryExpression NotEqual(Expression left, Expression right);
    public static BinaryExpression NotEqual(Expression left, Expression right, bool liftToNull, MethodInfo method);
    public static BinaryExpression GreaterThan(Expression left, Expression right);
    public static BinaryExpression GreaterThan(Expression left, Expression right, bool liftToNull, MethodInfo method);
    public static BinaryExpression GreaterThanOrEqual(Expression left, Expression right);
    public static BinaryExpression GreaterThanOrEqual(Expression left, Expression right, bool liftToNull, MethodInfo method);
    public static BinaryExpression LessThan(Expression left, Expression right);
    public static BinaryExpression LessThan(Expression left, Expression right, bool liftToNull, MethodInfo method);
    public static BinaryExpression LessThanOrEqual(Expression left, Expression right);
    public static BinaryExpression LessThanOrEqual(Expression left, Expression right, bool liftToNull, MethodInfo method);
    public static BlockExpression Block(Expression expr0);
    public static BlockExpression Block(Expression expr0, Expression expr1);
    public static BlockExpression Block(Expression expr0, Expression expr1, Expression expr2);
    public static BlockExpression Block(IReadOnlyList`1<Expression> expressions);
    public static BlockExpression Block(Expression[] expressions);
    public static BlockExpression Block(IEnumerable`1<Expression> expressions);
    public static BlockExpression Block(IEnumerable`1<ParameterExpression> variables, Expression expr0);
    public static BlockExpression Block(IEnumerable`1<ParameterExpression> variables, Expression expr0, Expression expr1);
    public static BlockExpression Block(IEnumerable`1<ParameterExpression> variables, Expression expr0, Expression expr1, Expression expr2);
    public static BlockExpression Block(IEnumerable`1<ParameterExpression> variables, IReadOnlyList`1<Expression> expressions);
    public static BlockExpression Block(IEnumerable`1<ParameterExpression> variables, Expression[] expressions);
    public static BlockExpression Block(IEnumerable`1<ParameterExpression> variables, IEnumerable`1<Expression> expressions);
    public static BlockExpression Block(Type type, IEnumerable`1<ParameterExpression> variables, Expression expr0);
    public static BlockExpression Block(Type type, IEnumerable`1<ParameterExpression> variables, Expression expr0, Expression expr1);
    public static BlockExpression Block(Type type, IEnumerable`1<ParameterExpression> variables, Expression expr0, Expression expr1, Expression expr2);
    public static BlockExpression Block(Type type, IEnumerable`1<ParameterExpression> variables, IReadOnlyList`1<Expression> expressions);
    public static BlockExpression Block(Type type, IEnumerable`1<ParameterExpression> variables, Expression[] expressions);
    public static BlockExpression Block(Type type, IEnumerable`1<ParameterExpression> variables, IEnumerable`1<Expression> expressions);
    public static BlockExpression MakeBlock(Type type, IEnumerable`1<ParameterExpression> variables, IEnumerable`1<Expression> expressions);
    public static Expression DebugInfo(SymbolDocumentInfo doc, int startLine, int startColumn, int endLine, int endColumn);
    public static LoopExpression Loop(Expression body, LabelTarget break);
    public static LoopExpression Loop(Expression body, LabelTarget break, LabelTarget continue);
    public static TryExpression TryCatch(Expression body, CatchBlock[] handlers);
    public static TryExpression TryCatchFinally(Expression body, Expression finally, CatchBlock[] handlers);
    public static TryExpression TryFinally(Expression body, Expression finally);
    public static CatchBlock Catch(ParameterExpression variable, Expression body);
    public static CatchBlock Catch(Type test, Expression body);
    public static CatchBlock MakeCatchBlock(Type test, ParameterExpression variable, Expression body, Expression filter);
    public static UnaryExpression Throw(Expression value);
    public static UnaryExpression Throw(Expression value, Type type);
    public static LabelExpression Label(LabelTarget target);
    public static LabelExpression Label(LabelTarget target, Expression defaultValue);
    public static LabelTarget Label();
    public static LabelTarget Label(Type type);
    public static LabelTarget Label(string name);
    public static LabelTarget Label(Type type, string name);
    public static BinaryExpression MakeBinary(ExpressionType binaryType, Expression left, Expression right, LambdaExpression conversion);
    public static BinaryExpression MakeBinary(ExpressionType binaryType, Expression left, Expression right, bool liftToNull, MethodInfo method, LambdaExpression conversion);
    private static BinaryExpression GetUserDefinedBinaryOperatorOrThrow(ExpressionType binaryType, string name, Expression left, Expression right, bool liftToNull);
    private static BinaryExpression GetUserDefinedBinaryOperator(ExpressionType binaryType, string name, Expression left, Expression right, bool liftToNull);
    private static MethodInfo GetUserDefinedBinaryOperator(ExpressionType binaryType, Type leftType, Type rightType, string name);
    private static BinaryExpression GetMethodBasedBinaryOperator(ExpressionType binaryType, Expression left, Expression right, MethodInfo method, bool liftToNull);
    public static GotoExpression MakeGoto(GotoExpressionKind kind, LabelTarget target, Expression value, Type type);
    public static GotoExpression Goto(LabelTarget target);
    public static GotoExpression Goto(LabelTarget target, Expression value);
    public static GotoExpression Goto(LabelTarget target, Type type);
    public static GotoExpression Goto(LabelTarget target, Expression value, Type type);
    public static GotoExpression Break(LabelTarget target);
    public static GotoExpression Break(LabelTarget target, Expression value);
    public static GotoExpression Break(LabelTarget target, Type type);
    public static GotoExpression Break(LabelTarget target, Expression value, Type type);
    public static GotoExpression Continue(LabelTarget target);
    public static GotoExpression Continue(LabelTarget target, Type type);
    public static GotoExpression Return(LabelTarget target);
    public static GotoExpression Return(LabelTarget target, Type type);
    public static GotoExpression Return(LabelTarget target, Expression value);
    public static GotoExpression Return(LabelTarget target, Expression value, Type type);
    public static SwitchExpression Switch(Expression switchValue, Expression defaultBody, SwitchCase[] cases);
    public static SwitchExpression Switch(Expression switchValue, Expression defaultBody, MethodInfo comparison, SwitchCase[] cases);
    public static SwitchExpression Switch(Type type, Expression switchValue, Expression defaultBody, MethodInfo comparison, SwitchCase[] cases);
    public static SwitchExpression Switch(Type type, Expression switchValue, Expression defaultBody, MethodInfo comparison, IEnumerable`1<SwitchCase> cases);
    public static SwitchExpression Switch(Expression switchValue, SwitchCase[] cases);
    public static SwitchCase SwitchCase(Expression body, IEnumerable`1<Expression> testValues);
    public static SwitchCase SwitchCase(Expression body, Expression[] testValues);
    public static BinaryExpression ReferenceEqual(Expression left, Expression right);
    public static BinaryExpression ReferenceNotEqual(Expression left, Expression right);
    public static BinaryExpression Coalesce(Expression left, Expression right);
    public static BinaryExpression Coalesce(Expression left, Expression right, Type type);
    public static BinaryExpression Coalesce(Expression left, Expression right, LambdaExpression conversion);
    private static Type GetCoalesceType(Type left, Type right);
    public static SymbolDocumentInfo SymbolDocument(string fileName);
}
public class DryIoc.FastExpressionCompiler.LightExpression.Expression`1 : LambdaExpression {
    public Type Type { get; }
    internal Expression`1(Expression body);
    public sealed virtual Type get_Type();
    public Expression`1<TDelegate> ToLambdaExpression();
}
[ExtensionAttribute]
public static class DryIoc.FastExpressionCompiler.LightExpression.ExpressionCompiler : object {
    private static Type[] _closureAsASingleParamType;
    private static Type[][] _closureTypePlusParamTypesPool;
    public static ArrayClosure EmptyArrayClosure;
    public static FieldInfo ArrayClosureArrayField;
    public static FieldInfo ArrayClosureWithNonPassedParamsField;
    private static ConstructorInfo[] _nonPassedParamsArrayClosureCtors;
    public static ConstructorInfo ArrayClosureWithNonPassedParamsConstructor;
    public static ConstructorInfo ArrayClosureWithNonPassedParamsConstructorWithoutConstants;
    private static ExpressionCompiler();
    [ExtensionAttribute]
public static TDelegate CompileFast(LambdaExpression lambdaExpr, bool ifFastFailedReturnNull, CompilerFlags flags);
    [ExtensionAttribute]
public static bool CompileFastToIL(LambdaExpression lambdaExpr, ILGenerator il, CompilerFlags flags);
    [ExtensionAttribute]
public static Delegate CompileFast(LambdaExpression lambdaExpr, bool ifFastFailedReturnNull, CompilerFlags flags);
    [ExtensionAttribute]
public static TDelegate CompileSys(Expression`1<TDelegate> lambdaExpr);
    [ExtensionAttribute]
public static Delegate CompileSys(LambdaExpression lambdaExpr);
    [ExtensionAttribute]
public static TDelegate CompileFast(Expression`1<TDelegate> lambdaExpr, bool ifFastFailedReturnNull, CompilerFlags flags);
    [ExtensionAttribute]
public static Func`1<R> CompileFast(Expression`1<Func`1<R>> lambdaExpr, bool ifFastFailedReturnNull, CompilerFlags flags);
    [ExtensionAttribute]
public static Func`2<T1, R> CompileFast(Expression`1<Func`2<T1, R>> lambdaExpr, bool ifFastFailedReturnNull, CompilerFlags flags);
    [ExtensionAttribute]
public static Func`3<T1, T2, R> CompileFast(Expression`1<Func`3<T1, T2, R>> lambdaExpr, bool ifFastFailedReturnNull, CompilerFlags flags);
    [ExtensionAttribute]
public static Func`4<T1, T2, T3, R> CompileFast(Expression`1<Func`4<T1, T2, T3, R>> lambdaExpr, bool ifFastFailedReturnNull, CompilerFlags flags);
    [ExtensionAttribute]
public static Func`5<T1, T2, T3, T4, R> CompileFast(Expression`1<Func`5<T1, T2, T3, T4, R>> lambdaExpr, bool ifFastFailedReturnNull, CompilerFlags flags);
    [ExtensionAttribute]
public static Func`6<T1, T2, T3, T4, T5, R> CompileFast(Expression`1<Func`6<T1, T2, T3, T4, T5, R>> lambdaExpr, bool ifFastFailedReturnNull, CompilerFlags flags);
    [ExtensionAttribute]
public static Func`7<T1, T2, T3, T4, T5, T6, R> CompileFast(Expression`1<Func`7<T1, T2, T3, T4, T5, T6, R>> lambdaExpr, bool ifFastFailedReturnNull, CompilerFlags flags);
    [ExtensionAttribute]
public static Action CompileFast(Expression`1<Action> lambdaExpr, bool ifFastFailedReturnNull, CompilerFlags flags);
    [ExtensionAttribute]
public static Action`1<T1> CompileFast(Expression`1<Action`1<T1>> lambdaExpr, bool ifFastFailedReturnNull, CompilerFlags flags);
    [ExtensionAttribute]
public static Action`2<T1, T2> CompileFast(Expression`1<Action`2<T1, T2>> lambdaExpr, bool ifFastFailedReturnNull, CompilerFlags flags);
    [ExtensionAttribute]
public static Action`3<T1, T2, T3> CompileFast(Expression`1<Action`3<T1, T2, T3>> lambdaExpr, bool ifFastFailedReturnNull, CompilerFlags flags);
    [ExtensionAttribute]
public static Action`4<T1, T2, T3, T4> CompileFast(Expression`1<Action`4<T1, T2, T3, T4>> lambdaExpr, bool ifFastFailedReturnNull, CompilerFlags flags);
    [ExtensionAttribute]
public static Action`5<T1, T2, T3, T4, T5> CompileFast(Expression`1<Action`5<T1, T2, T3, T4, T5>> lambdaExpr, bool ifFastFailedReturnNull, CompilerFlags flags);
    [ExtensionAttribute]
public static Action`6<T1, T2, T3, T4, T5, T6> CompileFast(Expression`1<Action`6<T1, T2, T3, T4, T5, T6>> lambdaExpr, bool ifFastFailedReturnNull, CompilerFlags flags);
    [ExtensionAttribute]
public static TDelegate TryCompile(LambdaExpression lambdaExpr, CompilerFlags flags);
    [ExtensionAttribute]
public static TDelegate TryCompileWithPreCreatedClosure(LambdaExpression lambdaExpr, ConstantExpression[] closureConstantsExprs);
    [ExtensionAttribute]
public static TDelegate TryCompileWithPreCreatedClosure(LambdaExpression lambdaExpr, ConstantExpression[] closureConstantsExprs, CompilerFlags flags);
    [ExtensionAttribute]
internal static TDelegate TryCompileWithPreCreatedClosure(LambdaExpression lambdaExpr, ClosureInfo& closureInfo, CompilerFlags flags);
    [ExtensionAttribute]
public static TDelegate TryCompileWithoutClosure(LambdaExpression lambdaExpr, CompilerFlags flags);
    private static Delegate CompileNewNoArgs(ConstructorInfo ctor, Type delegateType, Type[] closurePlusParamTypes, Type returnType);
    internal static object TryCompileBoundToFirstClosureParam(Type delegateType, Expression bodyExpr, IParameterProvider paramExprs, Type[] closurePlusParamTypes, Type returnType, CompilerFlags flags);
    private static Type[] RentOrNewClosureTypeToParamTypes(IParameterProvider paramExprs);
    private static void ReturnClosureTypeToParamTypesToPool(Type[] closurePlusParamTypes);
    public static bool IsClosureBoundConstant(object value, Type type);
    public static bool TryCollectBoundConstants(ClosureInfo& closure, Expression expr, IParameterProvider paramExprs, bool isNestedLambda, ClosureInfo& rootClosure, CompilerFlags flags);
    private static void PropagateNonPassedParamsToOuterLambda(ClosureInfo& closure, IParameterProvider paramExprs, IParameterProvider nestedLambdaParamExprs, ParameterExpression[] nestedNonPassedParams);
    private static NestedLambdaInfo FindAlreadyCollectedNestedLambdaInfo(NestedLambdaInfo nestedLambda, LambdaExpression nestedLambdaExpr, Object& foundInLambdaOrLambdas);
    private static NestedLambdaInfo FindAlreadyCollectedNestedLambdaInfo(object nestedLambdaOrLambdas, LambdaExpression nestedLambdaExpr, Object& foundInLambdaOrLambdas);
    private static bool TryCompileNestedLambda(NestedLambdaInfo nestedLambdaInfo, CompilerFlags setup);
    private static bool TryCollectMemberInitExprConstants(ClosureInfo& closure, MemberInitExpression expr, IParameterProvider paramExprs, bool isNestedLambda, ClosureInfo& rootClosure, CompilerFlags flags);
    private static bool TryCollectListInitExprConstants(ClosureInfo& closure, ListInitExpression expr, IParameterProvider paramExprs, bool isNestedLambda, ClosureInfo& rootClosure, CompilerFlags flags);
    private static bool TryCollectTryExprConstants(ClosureInfo& closure, TryExpression tryExpr, IParameterProvider paramExprs, bool isNestedLambda, ClosureInfo& rootClosure, CompilerFlags flags);
    [ExtensionAttribute]
public static bool IgnoresResult(ParentFlags parent);
    [ExtensionAttribute]
internal static bool EmitPopIfIgnoreResult(ILGenerator il, ParentFlags parent);
    [ExtensionAttribute]
internal static bool TryEmitBoxOf(ILGenerator il, Type sourceType);
}
[ExtensionAttribute]
internal static class DryIoc.FastExpressionCompiler.LightExpression.FecHelpers : object {
    [ExtensionAttribute]
public static int GetFirstIndexByReferenceEquals(IReadOnlyList`1<T> source, T item);
    [ExtensionAttribute]
public static T GetArgument(IReadOnlyList`1<T> source, int index);
    [ExtensionAttribute]
public static ParameterExpression GetParameter(IReadOnlyList`1<ParameterExpression> source, int index);
    [ExtensionAttribute]
public static IReadOnlyList`1<ParameterExpression> ToReadOnlyList(IParameterProvider source);
}
public class DryIoc.FastExpressionCompiler.LightExpression.FieldExpression : MemberExpression {
    public Type Type { get; }
    public FieldInfo FieldInfo { get; }
    internal FieldExpression(FieldInfo field);
    public virtual Type get_Type();
    public FieldInfo get_FieldInfo();
    internal virtual Expression CreateSysExpression(LiveCountArray`1& exprsConverted);
}
public class DryIoc.FastExpressionCompiler.LightExpression.FiveArgumentsInvocationExpression : NotNullExpressionInvocationExpression {
    public Expression Argument0;
    public Expression Argument1;
    public Expression Argument2;
    public Expression Argument3;
    public Expression Argument4;
    public IReadOnlyList`1<Expression> Arguments { get; }
    public int ArgumentCount { get; }
    internal FiveArgumentsInvocationExpression(Expression expression, Expression a0, Expression a1, Expression a2, Expression a3, Expression a4);
    public sealed virtual IReadOnlyList`1<Expression> get_Arguments();
    public sealed virtual int get_ArgumentCount();
    public sealed virtual Expression GetArgument(int i);
}
public class DryIoc.FastExpressionCompiler.LightExpression.FiveArgumentsMethodCallExpression : NotNullMethodCallExpression {
    public object A0;
    public object A1;
    public object A2;
    public object A3;
    public object A4;
    public IReadOnlyList`1<Expression> Arguments { get; }
    public Expression Argument0 { get; }
    public Expression Argument1 { get; }
    public Expression Argument2 { get; }
    public Expression Argument3 { get; }
    public Expression Argument4 { get; }
    public int ArgumentCount { get; }
    internal FiveArgumentsMethodCallExpression(MethodInfo method, object a0, object a1, object a2, object a3, object a4);
    public virtual IReadOnlyList`1<Expression> get_Arguments();
    public Expression get_Argument0();
    public Expression get_Argument1();
    public Expression get_Argument2();
    public Expression get_Argument3();
    public Expression get_Argument4();
    public virtual int get_ArgumentCount();
    public virtual Expression GetArgument(int i);
}
public class DryIoc.FastExpressionCompiler.LightExpression.FiveArgumentsNewExpression : NewExpression {
    public object A0;
    public object A1;
    public object A2;
    public object A3;
    public object A4;
    public Expression Argument0 { get; }
    public Expression Argument1 { get; }
    public Expression Argument2 { get; }
    public Expression Argument3 { get; }
    public Expression Argument4 { get; }
    public IReadOnlyList`1<Expression> Arguments { get; }
    public int ArgumentCount { get; }
    internal FiveArgumentsNewExpression(ConstructorInfo constructor, object a0, object a1, object a2, object a3, object a4);
    public Expression get_Argument0();
    public Expression get_Argument1();
    public Expression get_Argument2();
    public Expression get_Argument3();
    public Expression get_Argument4();
    public virtual IReadOnlyList`1<Expression> get_Arguments();
    public virtual int get_ArgumentCount();
    public virtual Expression GetArgument(int i);
}
public class DryIoc.FastExpressionCompiler.LightExpression.FiveBindingsMemberInitExpression : MemberInitExpression {
    public MemberBinding Binding0;
    public MemberBinding Binding1;
    public MemberBinding Binding2;
    public MemberBinding Binding3;
    public MemberBinding Binding4;
    public IReadOnlyList`1<MemberBinding> Bindings { get; }
    public int ArgumentCount { get; }
    internal FiveBindingsMemberInitExpression(Expression expression, MemberBinding b0, MemberBinding b1, MemberBinding b2, MemberBinding b3, MemberBinding b4);
    public virtual IReadOnlyList`1<MemberBinding> get_Bindings();
    public virtual int get_ArgumentCount();
    public virtual MemberBinding GetArgument(int i);
}
public class DryIoc.FastExpressionCompiler.LightExpression.FiveElementNewArrayInitExpression : NewArrayExpression {
    public Expression Element0;
    public Expression Element1;
    public Expression Element2;
    public Expression Element3;
    public Expression Element4;
    public ExpressionType NodeType { get; }
    public IReadOnlyList`1<Expression> Expressions { get; }
    public int ArgumentCount { get; }
    internal FiveElementNewArrayInitExpression(Type arrayType, Expression el0, Expression el1, Expression el2, Expression el3, Expression el4);
    public virtual ExpressionType get_NodeType();
    public virtual IReadOnlyList`1<Expression> get_Expressions();
    public virtual int get_ArgumentCount();
    public virtual Expression GetArgument(int i);
}
public class DryIoc.FastExpressionCompiler.LightExpression.FiveParametersExpression`1 : Expression`1<TDelegate> {
    public ParameterExpression Parameter0;
    public ParameterExpression Parameter1;
    public ParameterExpression Parameter2;
    public ParameterExpression Parameter3;
    public ParameterExpression Parameter4;
    public IReadOnlyList`1<ParameterExpression> Parameters { get; }
    public int ParameterCount { get; }
    internal FiveParametersExpression`1(Expression body, ParameterExpression p0, ParameterExpression p1, ParameterExpression p2, ParameterExpression p3, ParameterExpression p4);
    public sealed virtual IReadOnlyList`1<ParameterExpression> get_Parameters();
    public sealed virtual int get_ParameterCount();
    public sealed virtual ParameterExpression GetParameter(int i);
}
public class DryIoc.FastExpressionCompiler.LightExpression.FiveParametersLambdaExpression : TypedLambdaExpression {
    public ParameterExpression Parameter0;
    public ParameterExpression Parameter1;
    public ParameterExpression Parameter2;
    public ParameterExpression Parameter3;
    public ParameterExpression Parameter4;
    public IReadOnlyList`1<ParameterExpression> Parameters { get; }
    public int ParameterCount { get; }
    internal FiveParametersLambdaExpression(Type delegateType, Expression body, ParameterExpression p0, ParameterExpression p1, ParameterExpression p2, ParameterExpression p3, ParameterExpression p4);
    public sealed virtual IReadOnlyList`1<ParameterExpression> get_Parameters();
    public sealed virtual int get_ParameterCount();
    public sealed virtual ParameterExpression GetParameter(int i);
}
public class DryIoc.FastExpressionCompiler.LightExpression.FourArgumentsInvocationExpression : NotNullExpressionInvocationExpression {
    public Expression Argument0;
    public Expression Argument1;
    public Expression Argument2;
    public Expression Argument3;
    public IReadOnlyList`1<Expression> Arguments { get; }
    public int ArgumentCount { get; }
    internal FourArgumentsInvocationExpression(Expression expression, Expression a0, Expression a1, Expression a2, Expression a3);
    public sealed virtual IReadOnlyList`1<Expression> get_Arguments();
    public sealed virtual int get_ArgumentCount();
    public sealed virtual Expression GetArgument(int i);
}
public class DryIoc.FastExpressionCompiler.LightExpression.FourArgumentsMethodCallExpression : NotNullMethodCallExpression {
    public object A0;
    public object A1;
    public object A2;
    public object A3;
    public IReadOnlyList`1<Expression> Arguments { get; }
    public Expression Argument0 { get; }
    public Expression Argument1 { get; }
    public Expression Argument2 { get; }
    public Expression Argument3 { get; }
    public int ArgumentCount { get; }
    internal FourArgumentsMethodCallExpression(MethodInfo method, object a0, object a1, object a2, object a3);
    public virtual IReadOnlyList`1<Expression> get_Arguments();
    public Expression get_Argument0();
    public Expression get_Argument1();
    public Expression get_Argument2();
    public Expression get_Argument3();
    public virtual int get_ArgumentCount();
    public virtual Expression GetArgument(int i);
}
public class DryIoc.FastExpressionCompiler.LightExpression.FourArgumentsNewExpression : NewExpression {
    public object A0;
    public object A1;
    public object A2;
    public object A3;
    public Expression Argument0 { get; }
    public Expression Argument1 { get; }
    public Expression Argument2 { get; }
    public Expression Argument3 { get; }
    public IReadOnlyList`1<Expression> Arguments { get; }
    public int ArgumentCount { get; }
    internal FourArgumentsNewExpression(ConstructorInfo constructor, object a0, object a1, object a2, object a3);
    public Expression get_Argument0();
    public Expression get_Argument1();
    public Expression get_Argument2();
    public Expression get_Argument3();
    public virtual IReadOnlyList`1<Expression> get_Arguments();
    public virtual int get_ArgumentCount();
    public virtual Expression GetArgument(int i);
}
public class DryIoc.FastExpressionCompiler.LightExpression.FourBindingsMemberInitExpression : MemberInitExpression {
    public MemberBinding Binding0;
    public MemberBinding Binding1;
    public MemberBinding Binding2;
    public MemberBinding Binding3;
    public IReadOnlyList`1<MemberBinding> Bindings { get; }
    public int ArgumentCount { get; }
    internal FourBindingsMemberInitExpression(Expression expression, MemberBinding b0, MemberBinding b1, MemberBinding b2, MemberBinding b3);
    public virtual IReadOnlyList`1<MemberBinding> get_Bindings();
    public virtual int get_ArgumentCount();
    public virtual MemberBinding GetArgument(int i);
}
public class DryIoc.FastExpressionCompiler.LightExpression.FourElementNewArrayInitExpression : NewArrayExpression {
    public Expression Element0;
    public Expression Element1;
    public Expression Element2;
    public Expression Element3;
    public ExpressionType NodeType { get; }
    public IReadOnlyList`1<Expression> Expressions { get; }
    public int ArgumentCount { get; }
    internal FourElementNewArrayInitExpression(Type arrayType, Expression el0, Expression el1, Expression el2, Expression el3);
    public virtual ExpressionType get_NodeType();
    public virtual IReadOnlyList`1<Expression> get_Expressions();
    public virtual int get_ArgumentCount();
    public virtual Expression GetArgument(int i);
}
public class DryIoc.FastExpressionCompiler.LightExpression.FourParametersExpression`1 : Expression`1<TDelegate> {
    public ParameterExpression Parameter0;
    public ParameterExpression Parameter1;
    public ParameterExpression Parameter2;
    public ParameterExpression Parameter3;
    public IReadOnlyList`1<ParameterExpression> Parameters { get; }
    public int ParameterCount { get; }
    internal FourParametersExpression`1(Expression body, ParameterExpression p0, ParameterExpression p1, ParameterExpression p2, ParameterExpression p3);
    public sealed virtual IReadOnlyList`1<ParameterExpression> get_Parameters();
    public sealed virtual int get_ParameterCount();
    public sealed virtual ParameterExpression GetParameter(int i);
}
public class DryIoc.FastExpressionCompiler.LightExpression.FourParametersLambdaExpression : TypedLambdaExpression {
    public ParameterExpression Parameter0;
    public ParameterExpression Parameter1;
    public ParameterExpression Parameter2;
    public ParameterExpression Parameter3;
    public IReadOnlyList`1<ParameterExpression> Parameters { get; }
    public int ParameterCount { get; }
    internal FourParametersLambdaExpression(Type delegateType, Expression body, ParameterExpression p0, ParameterExpression p1, ParameterExpression p2, ParameterExpression p3);
    public sealed virtual IReadOnlyList`1<ParameterExpression> get_Parameters();
    public sealed virtual int get_ParameterCount();
    public sealed virtual ParameterExpression GetParameter(int i);
}
public class DryIoc.FastExpressionCompiler.LightExpression.GotoExpression : Expression {
    public LabelTarget Target;
    public ExpressionType NodeType { get; }
    public Type Type { get; }
    public GotoExpressionKind Kind { get; }
    public Expression Value { get; }
    internal GotoExpression(LabelTarget target);
    public virtual ExpressionType get_NodeType();
    public virtual Type get_Type();
    public virtual GotoExpressionKind get_Kind();
    public virtual Expression get_Value();
    internal virtual Expression CreateSysExpression(LiveCountArray`1& exprsConverted);
}
internal static class DryIoc.FastExpressionCompiler.LightExpression.HashCombiner : object {
    public static int Combine(T1 a, T2 b);
    public static int Combine(int h1, int h2);
}
public class DryIoc.FastExpressionCompiler.LightExpression.HasIndexerManyArgumentsIndexExpression : ManyArgumentsIndexExpression {
    [CompilerGeneratedAttribute]
private PropertyInfo <Indexer>k__BackingField;
    public PropertyInfo Indexer { get; }
    internal HasIndexerManyArgumentsIndexExpression(Expression object, PropertyInfo indexer, IReadOnlyList`1<Expression> arguments);
    [CompilerGeneratedAttribute]
public virtual PropertyInfo get_Indexer();
}
public class DryIoc.FastExpressionCompiler.LightExpression.HasIndexerOneArgumentIndexExpression : OneArgumentIndexExpression {
    [CompilerGeneratedAttribute]
private PropertyInfo <Indexer>k__BackingField;
    public PropertyInfo Indexer { get; }
    internal HasIndexerOneArgumentIndexExpression(Expression object, PropertyInfo indexer, Expression argument);
    [CompilerGeneratedAttribute]
public virtual PropertyInfo get_Indexer();
}
public interface DryIoc.FastExpressionCompiler.LightExpression.IArgumentProvider {
    public int ArgumentCount { get; }
    public abstract virtual int get_ArgumentCount();
    public abstract virtual Expression GetArgument(int index);
}
public interface DryIoc.FastExpressionCompiler.LightExpression.IArgumentProvider`1 {
    public int ArgumentCount { get; }
    public abstract virtual int get_ArgumentCount();
    public abstract virtual T GetArgument(int index);
}
public interface DryIoc.FastExpressionCompiler.LightExpression.IDelegateDebugInfo {
    public LambdaExpression Expression { get; }
    public string ExpressionString { get; }
    public string CSharpString { get; }
    public abstract virtual LambdaExpression get_Expression();
    public abstract virtual string get_ExpressionString();
    public abstract virtual string get_CSharpString();
}
[ExtensionAttribute]
public static class DryIoc.FastExpressionCompiler.LightExpression.ILGeneratorHacks : object {
    private static Func`3<ILGenerator, Type, int> _getNextLocalVarIndex;
    private static ILGeneratorHacks();
    internal static int PostInc(Int32& i);
    [ExtensionAttribute]
public static int GetNextLocalVarIndex(ILGenerator il, Type t);
}
public abstract class DryIoc.FastExpressionCompiler.LightExpression.IndexExpression : Expression {
    public Expression Object;
    public ExpressionType NodeType { get; }
    public Type Type { get; }
    public IReadOnlyList`1<Expression> Arguments { get; }
    public PropertyInfo Indexer { get; }
    public int ArgumentCount { get; }
    internal IndexExpression(Expression object);
    public sealed virtual ExpressionType get_NodeType();
    public sealed virtual Type get_Type();
    public abstract virtual IReadOnlyList`1<Expression> get_Arguments();
    public virtual PropertyInfo get_Indexer();
    public virtual int get_ArgumentCount();
    public virtual Expression GetArgument(int index);
    internal virtual Expression CreateSysExpression(LiveCountArray`1& exprsConverted);
}
public class DryIoc.FastExpressionCompiler.LightExpression.InstanceFieldExpression : FieldExpression {
    [CompilerGeneratedAttribute]
private Expression <Expression>k__BackingField;
    public Expression Expression { get; }
    internal InstanceFieldExpression(Expression instance, FieldInfo field);
    [CompilerGeneratedAttribute]
public virtual Expression get_Expression();
}
public class DryIoc.FastExpressionCompiler.LightExpression.InstanceFiveArgumentsMethodCallExpression : FiveArgumentsMethodCallExpression {
    [CompilerGeneratedAttribute]
private Expression <Object>k__BackingField;
    public Expression Object { get; }
    internal InstanceFiveArgumentsMethodCallExpression(Expression instance, MethodInfo method, Expression a0, Expression a1, Expression a2, Expression a3, Expression a4);
    [CompilerGeneratedAttribute]
public virtual Expression get_Object();
}
public class DryIoc.FastExpressionCompiler.LightExpression.InstanceFourArgumentsMethodCallExpression : FourArgumentsMethodCallExpression {
    [CompilerGeneratedAttribute]
private Expression <Object>k__BackingField;
    public Expression Object { get; }
    internal InstanceFourArgumentsMethodCallExpression(Expression instance, MethodInfo method, Expression argument0, Expression argument1, Expression argument2, Expression argument3);
    [CompilerGeneratedAttribute]
public virtual Expression get_Object();
}
public class DryIoc.FastExpressionCompiler.LightExpression.InstanceManyArgumentsMethodCallExpression : ManyArgumentsMethodCallExpression {
    [CompilerGeneratedAttribute]
private Expression <Object>k__BackingField;
    public Expression Object { get; }
    internal InstanceManyArgumentsMethodCallExpression(Expression instance, MethodInfo method, IReadOnlyList`1<Expression> arguments);
    [CompilerGeneratedAttribute]
public virtual Expression get_Object();
}
public class DryIoc.FastExpressionCompiler.LightExpression.InstanceMethodCallExpression : NotNullMethodCallExpression {
    [CompilerGeneratedAttribute]
private Expression <Object>k__BackingField;
    public Expression Object { get; }
    internal InstanceMethodCallExpression(Expression instance, MethodInfo method);
    [CompilerGeneratedAttribute]
public virtual Expression get_Object();
}
public class DryIoc.FastExpressionCompiler.LightExpression.InstanceOneArgumentMethodCallExpression : OneArgumentMethodCallExpression {
    [CompilerGeneratedAttribute]
private Expression <Object>k__BackingField;
    public Expression Object { get; }
    internal InstanceOneArgumentMethodCallExpression(Expression instance, MethodInfo method, Expression argument);
    [CompilerGeneratedAttribute]
public virtual Expression get_Object();
}
public class DryIoc.FastExpressionCompiler.LightExpression.InstancePropertyExpression : PropertyExpression {
    [CompilerGeneratedAttribute]
private Expression <Expression>k__BackingField;
    public Expression Expression { get; }
    internal InstancePropertyExpression(Expression instance, PropertyInfo property);
    [CompilerGeneratedAttribute]
public virtual Expression get_Expression();
}
public class DryIoc.FastExpressionCompiler.LightExpression.InstanceSevenArgumentsMethodCallExpression : SevenArgumentsMethodCallExpression {
    [CompilerGeneratedAttribute]
private Expression <Object>k__BackingField;
    public Expression Object { get; }
    internal InstanceSevenArgumentsMethodCallExpression(Expression instance, MethodInfo method, Expression a0, Expression a1, Expression a2, Expression a3, Expression a4, Expression a5, Expression a6);
    [CompilerGeneratedAttribute]
public virtual Expression get_Object();
}
public class DryIoc.FastExpressionCompiler.LightExpression.InstanceSixArgumentsMethodCallExpression : SixArgumentsMethodCallExpression {
    [CompilerGeneratedAttribute]
private Expression <Object>k__BackingField;
    public Expression Object { get; }
    internal InstanceSixArgumentsMethodCallExpression(Expression instance, MethodInfo method, Expression a0, Expression a1, Expression a2, Expression a3, Expression a4, Expression a5);
    [CompilerGeneratedAttribute]
public virtual Expression get_Object();
}
public class DryIoc.FastExpressionCompiler.LightExpression.InstanceThreeArgumentsMethodCallExpression : ThreeArgumentsMethodCallExpression {
    [CompilerGeneratedAttribute]
private Expression <Object>k__BackingField;
    public Expression Object { get; }
    internal InstanceThreeArgumentsMethodCallExpression(Expression instance, MethodInfo method, Expression a0, Expression a1, Expression a2);
    [CompilerGeneratedAttribute]
public virtual Expression get_Object();
}
public class DryIoc.FastExpressionCompiler.LightExpression.InstanceTwoArgumentsMethodCallExpression : TwoArgumentsMethodCallExpression {
    [CompilerGeneratedAttribute]
private Expression <Object>k__BackingField;
    public Expression Object { get; }
    internal InstanceTwoArgumentsMethodCallExpression(Expression instance, MethodInfo method, Expression argument0, Expression argument1);
    [CompilerGeneratedAttribute]
public virtual Expression get_Object();
}
public class DryIoc.FastExpressionCompiler.LightExpression.IntConstantExpression : ConstantExpression {
    public int IntValue;
    public Type Type { get; }
    public object Value { get; }
    internal IntConstantExpression(int value);
    public virtual Type get_Type();
    public virtual object get_Value();
}
public class DryIoc.FastExpressionCompiler.LightExpression.InvocationExpression : Expression {
    public ExpressionType NodeType { get; }
    public Type Type { get; }
    public Expression Expression { get; }
    public IReadOnlyList`1<Expression> Arguments { get; }
    public int ArgumentCount { get; }
    public sealed virtual ExpressionType get_NodeType();
    public virtual Type get_Type();
    public virtual Expression get_Expression();
    public virtual IReadOnlyList`1<Expression> get_Arguments();
    public virtual int get_ArgumentCount();
    public virtual Expression GetArgument(int index);
    internal virtual Expression CreateSysExpression(LiveCountArray`1& exprsConverted);
}
public interface DryIoc.FastExpressionCompiler.LightExpression.IParameterProvider {
    public int ParameterCount { get; }
    public abstract virtual int get_ParameterCount();
    public abstract virtual ParameterExpression GetParameter(int index);
}
public class DryIoc.FastExpressionCompiler.LightExpression.LabelExpression : Expression {
    public LabelTarget Target;
    public ExpressionType NodeType { get; }
    public Type Type { get; }
    public Expression DefaultValue { get; }
    internal LabelExpression(LabelTarget target);
    public virtual ExpressionType get_NodeType();
    public virtual Type get_Type();
    public virtual Expression get_DefaultValue();
    internal virtual Expression CreateSysExpression(LiveCountArray`1& exprsConverted);
}
public class DryIoc.FastExpressionCompiler.LightExpression.LabelTarget : object {
    public Type Type { get; }
    public string Name { get; }
    public virtual Type get_Type();
    public virtual string get_Name();
    internal LabelTarget ToSystemLabelTarget(LiveCountArray`1& converted);
    public virtual string ToString();
}
public abstract class DryIoc.FastExpressionCompiler.LightExpression.LambdaExpression : Expression {
    public Expression Body;
    public ExpressionType NodeType { get; }
    public Type ReturnType { get; }
    public IReadOnlyList`1<ParameterExpression> Parameters { get; }
    public int ParameterCount { get; }
    protected LambdaExpression(Expression body);
    public sealed virtual ExpressionType get_NodeType();
    public virtual Type get_ReturnType();
    public virtual IReadOnlyList`1<ParameterExpression> get_Parameters();
    public virtual int get_ParameterCount();
    public virtual ParameterExpression GetParameter(int index);
    public LambdaExpression ToLambdaExpression();
    internal virtual Expression CreateSysExpression(LiveCountArray`1& exprsConverted);
}
internal class DryIoc.FastExpressionCompiler.LightExpression.LeftTypedBinaryExpression : BinaryExpression {
    [CompilerGeneratedAttribute]
private ExpressionType <NodeType>k__BackingField;
    public ExpressionType NodeType { get; }
    public Type Type { get; }
    internal LeftTypedBinaryExpression(ExpressionType nodeType, Expression left, Expression right);
    [CompilerGeneratedAttribute]
public virtual ExpressionType get_NodeType();
    public virtual Type get_Type();
}
internal class DryIoc.FastExpressionCompiler.LightExpression.LiftedToNullBinaryExpression : BinaryExpression {
    [CompilerGeneratedAttribute]
private ExpressionType <NodeType>k__BackingField;
    public ExpressionType NodeType { get; }
    public Type Type { get; }
    internal LiftedToNullBinaryExpression(ExpressionType nodeType, Expression left, Expression right);
    [CompilerGeneratedAttribute]
public virtual ExpressionType get_NodeType();
    public virtual Type get_Type();
    internal virtual Expression CreateSysExpression(LiveCountArray`1& exprsConverted);
}
internal class DryIoc.FastExpressionCompiler.LightExpression.LightAndSysExpr : ValueType {
    public object LightExpr;
    public object SysExpr;
}
public class DryIoc.FastExpressionCompiler.LightExpression.ListInitExpression : Expression {
    public NewExpression NewExpression;
    public IReadOnlyList`1<ElementInit> Initializers;
    public ExpressionType NodeType { get; }
    public Type Type { get; }
    internal ListInitExpression(NewExpression newExpression, IReadOnlyList`1<ElementInit> initializers);
    public virtual ExpressionType get_NodeType();
    public virtual Type get_Type();
    internal virtual Expression CreateSysExpression(LiveCountArray`1& convertedExpressions);
    internal static ElementInit[] ToElementInits(IReadOnlyList`1<ElementInit> elemInits, LiveCountArray`1& exprsConverted);
}
public class DryIoc.FastExpressionCompiler.LightExpression.LiveCountArray`1 : ValueType {
    public int Count;
    public T[] Items;
    public LiveCountArray`1(T[] items);
    public T& PushSlot();
    public void PushSlot(T item);
    public void Pop();
    public static T[] Expand(T[] items);
}
internal class DryIoc.FastExpressionCompiler.LightExpression.LogicalBinaryExpression : BinaryExpression {
    [CompilerGeneratedAttribute]
private ExpressionType <NodeType>k__BackingField;
    public ExpressionType NodeType { get; }
    public Type Type { get; }
    internal LogicalBinaryExpression(ExpressionType nodeType, Expression left, Expression right);
    [CompilerGeneratedAttribute]
public virtual ExpressionType get_NodeType();
    public virtual Type get_Type();
    internal virtual Expression CreateSysExpression(LiveCountArray`1& exprsConverted);
    private static Expression TryConvertSysExprToInt(Expression e);
}
public class DryIoc.FastExpressionCompiler.LightExpression.LoopExpression : Expression {
    public Expression Body;
    public LabelTarget BreakLabel;
    public LabelTarget ContinueLabel;
    public ExpressionType NodeType { get; }
    public Type Type { get; }
    internal LoopExpression(Expression body, LabelTarget breakLabel, LabelTarget continueLabel);
    public virtual ExpressionType get_NodeType();
    public virtual Type get_Type();
    internal virtual Expression CreateSysExpression(LiveCountArray`1& exprsConverted);
}
public class DryIoc.FastExpressionCompiler.LightExpression.ManyArgumentsElementInit : ElementInit {
    [CompilerGeneratedAttribute]
private IReadOnlyList`1<Expression> <Arguments>k__BackingField;
    public IReadOnlyList`1<Expression> Arguments { get; }
    public int ArgumentCount { get; }
    internal ManyArgumentsElementInit(MethodInfo addMethod, IReadOnlyList`1<Expression> args);
    [CompilerGeneratedAttribute]
public virtual IReadOnlyList`1<Expression> get_Arguments();
    public virtual int get_ArgumentCount();
    public virtual Expression GetArgument(int i);
}
public class DryIoc.FastExpressionCompiler.LightExpression.ManyArgumentsIndexExpression : IndexExpression {
    [CompilerGeneratedAttribute]
private IReadOnlyList`1<Expression> <Arguments>k__BackingField;
    public IReadOnlyList`1<Expression> Arguments { get; }
    internal ManyArgumentsIndexExpression(Expression object, IReadOnlyList`1<Expression> arguments);
    [CompilerGeneratedAttribute]
public sealed virtual IReadOnlyList`1<Expression> get_Arguments();
}
public class DryIoc.FastExpressionCompiler.LightExpression.ManyArgumentsInvocationExpression : NotNullExpressionInvocationExpression {
    [CompilerGeneratedAttribute]
private IReadOnlyList`1<Expression> <Arguments>k__BackingField;
    public IReadOnlyList`1<Expression> Arguments { get; }
    public int ArgumentCount { get; }
    internal ManyArgumentsInvocationExpression(Expression expression, IReadOnlyList`1<Expression> arguments);
    [CompilerGeneratedAttribute]
public sealed virtual IReadOnlyList`1<Expression> get_Arguments();
    public sealed virtual int get_ArgumentCount();
    public sealed virtual Expression GetArgument(int index);
}
public class DryIoc.FastExpressionCompiler.LightExpression.ManyArgumentsMethodCallExpression : NotNullMethodCallExpression {
    private IReadOnlyList`1<Expression> _arguments;
    public IReadOnlyList`1<Expression> Arguments { get; }
    public int ArgumentCount { get; }
    internal ManyArgumentsMethodCallExpression(MethodInfo method, IReadOnlyList`1<Expression> arguments);
    public sealed virtual IReadOnlyList`1<Expression> get_Arguments();
    public sealed virtual int get_ArgumentCount();
    public sealed virtual Expression GetArgument(int i);
}
public class DryIoc.FastExpressionCompiler.LightExpression.ManyArgumentsNewExpression : NewExpression {
    protected IReadOnlyList`1<Expression> Args;
    public IReadOnlyList`1<Expression> Arguments { get; }
    public int ArgumentCount { get; }
    internal ManyArgumentsNewExpression(ConstructorInfo constructor, IReadOnlyList`1<Expression> args);
    public virtual IReadOnlyList`1<Expression> get_Arguments();
    public virtual int get_ArgumentCount();
    public virtual Expression GetArgument(int i);
}
public class DryIoc.FastExpressionCompiler.LightExpression.ManyBindingsMemberInitExpression : MemberInitExpression {
    [CompilerGeneratedAttribute]
private IReadOnlyList`1<MemberBinding> <Bindings>k__BackingField;
    public IReadOnlyList`1<MemberBinding> Bindings { get; }
    public int ArgumentCount { get; }
    internal ManyBindingsMemberInitExpression(Expression expression, IReadOnlyList`1<MemberBinding> bindings);
    [CompilerGeneratedAttribute]
public virtual IReadOnlyList`1<MemberBinding> get_Bindings();
    public virtual int get_ArgumentCount();
    public virtual MemberBinding GetArgument(int i);
}
public class DryIoc.FastExpressionCompiler.LightExpression.ManyBoundsNewArrayBoundsExpression : NewArrayExpression {
    [CompilerGeneratedAttribute]
private IReadOnlyList`1<Expression> <Expressions>k__BackingField;
    public ExpressionType NodeType { get; }
    public IReadOnlyList`1<Expression> Expressions { get; }
    internal ManyBoundsNewArrayBoundsExpression(Type arrayType, IReadOnlyList`1<Expression> bounds);
    public virtual ExpressionType get_NodeType();
    [CompilerGeneratedAttribute]
public virtual IReadOnlyList`1<Expression> get_Expressions();
}
public class DryIoc.FastExpressionCompiler.LightExpression.ManyElementsNewArrayInitExpression : NewArrayExpression {
    [CompilerGeneratedAttribute]
private IReadOnlyList`1<Expression> <Expressions>k__BackingField;
    public ExpressionType NodeType { get; }
    public IReadOnlyList`1<Expression> Expressions { get; }
    internal ManyElementsNewArrayInitExpression(Type arrayType, IReadOnlyList`1<Expression> elements);
    public virtual ExpressionType get_NodeType();
    [CompilerGeneratedAttribute]
public virtual IReadOnlyList`1<Expression> get_Expressions();
}
public class DryIoc.FastExpressionCompiler.LightExpression.ManyParametersExpression`1 : Expression`1<TDelegate> {
    private IReadOnlyList`1<ParameterExpression> _parameters;
    public IReadOnlyList`1<ParameterExpression> Parameters { get; }
    public int ParameterCount { get; }
    internal ManyParametersExpression`1(Expression body, IReadOnlyList`1<ParameterExpression> parameters);
    public sealed virtual IReadOnlyList`1<ParameterExpression> get_Parameters();
    public sealed virtual int get_ParameterCount();
    public sealed virtual ParameterExpression GetParameter(int index);
}
public class DryIoc.FastExpressionCompiler.LightExpression.ManyParametersLambdaExpression : TypedLambdaExpression {
    private IReadOnlyList`1<ParameterExpression> _parameters;
    public IReadOnlyList`1<ParameterExpression> Parameters { get; }
    public int ParameterCount { get; }
    internal ManyParametersLambdaExpression(Type delegateType, Expression body, IReadOnlyList`1<ParameterExpression> parameters);
    public sealed virtual IReadOnlyList`1<ParameterExpression> get_Parameters();
    public sealed virtual int get_ParameterCount();
    public sealed virtual ParameterExpression GetParameter(int index);
}
public class DryIoc.FastExpressionCompiler.LightExpression.ManyVariablesBlockExpression : BlockExpression {
    [CompilerGeneratedAttribute]
private IReadOnlyList`1<ParameterExpression> <Variables>k__BackingField;
    public IReadOnlyList`1<ParameterExpression> Variables { get; }
    public int ArgumentCount { get; }
    internal ManyVariablesBlockExpression(IReadOnlyList`1<ParameterExpression> variables, IReadOnlyList`1<Expression> expressions);
    [CompilerGeneratedAttribute]
public sealed virtual IReadOnlyList`1<ParameterExpression> get_Variables();
    public sealed virtual int get_ArgumentCount();
    public sealed virtual Expression GetArgument(int index);
}
public class DryIoc.FastExpressionCompiler.LightExpression.MemberAssignment : MemberBinding {
    public Expression Expression;
    public MemberBindingType BindingType { get; }
    internal MemberAssignment(MemberInfo member, Expression expression);
    public virtual MemberBindingType get_BindingType();
    internal virtual MemberBinding ToMemberBinding(LiveCountArray`1& exprsConverted);
}
public abstract class DryIoc.FastExpressionCompiler.LightExpression.MemberBinding : object {
    public MemberInfo Member;
    public MemberBindingType BindingType { get; }
    internal MemberBinding(MemberInfo member);
    public abstract virtual MemberBindingType get_BindingType();
    internal abstract virtual MemberBinding ToMemberBinding(LiveCountArray`1& exprsConverted);
}
public abstract class DryIoc.FastExpressionCompiler.LightExpression.MemberExpression : Expression {
    public MemberInfo Member;
    public ExpressionType NodeType { get; }
    public Expression Expression { get; }
    protected MemberExpression(MemberInfo member);
    public sealed virtual ExpressionType get_NodeType();
    public virtual Expression get_Expression();
}
public class DryIoc.FastExpressionCompiler.LightExpression.MemberInitExpression : Expression {
    public Expression Expression;
    public ExpressionType NodeType { get; }
    public Type Type { get; }
    public NewExpression NewExpression { get; }
    public IReadOnlyList`1<MemberBinding> Bindings { get; }
    public int ArgumentCount { get; }
    internal MemberInitExpression(Expression expression);
    public sealed virtual ExpressionType get_NodeType();
    public virtual Type get_Type();
    public NewExpression get_NewExpression();
    public virtual IReadOnlyList`1<MemberBinding> get_Bindings();
    public virtual int get_ArgumentCount();
    public virtual MemberBinding GetArgument(int i);
    internal virtual Expression CreateSysExpression(LiveCountArray`1& exprsConverted);
    internal static MemberBinding[] BindingsToExpressions(IReadOnlyList`1<MemberBinding> ms, LiveCountArray`1& exprsConverted);
}
public class DryIoc.FastExpressionCompiler.LightExpression.MemberListBinding : MemberBinding {
    public IReadOnlyList`1<ElementInit> Initializers;
    public MemberBindingType BindingType { get; }
    internal MemberListBinding(MemberInfo member, IReadOnlyList`1<ElementInit> initializers);
    public virtual MemberBindingType get_BindingType();
    internal virtual MemberBinding ToMemberBinding(LiveCountArray`1& exprsConverted);
}
public class DryIoc.FastExpressionCompiler.LightExpression.MemberMemberBinding : MemberBinding {
    public IReadOnlyList`1<MemberBinding> Bindings;
    public MemberBindingType BindingType { get; }
    internal MemberMemberBinding(MemberInfo member, IReadOnlyList`1<MemberBinding> bindings);
    public virtual MemberBindingType get_BindingType();
    private static MemberBinding[] ToMemberBindings(IReadOnlyList`1<MemberBinding> items, LiveCountArray`1& exprsConverted);
    internal virtual MemberBinding ToMemberBinding(LiveCountArray`1& exprsConverted);
}
public class DryIoc.FastExpressionCompiler.LightExpression.MethodBinaryExpression : BinaryExpression {
    [CompilerGeneratedAttribute]
private ExpressionType <NodeType>k__BackingField;
    [CompilerGeneratedAttribute]
private Type <Type>k__BackingField;
    [CompilerGeneratedAttribute]
private MethodInfo <Method>k__BackingField;
    public ExpressionType NodeType { get; }
    public Type Type { get; }
    public MethodInfo Method { get; }
    public MethodBinaryExpression(ExpressionType nodeType, Expression left, Expression right, Type type, MethodInfo method);
    [CompilerGeneratedAttribute]
public virtual ExpressionType get_NodeType();
    [CompilerGeneratedAttribute]
public virtual Type get_Type();
    [CompilerGeneratedAttribute]
public virtual MethodInfo get_Method();
}
public class DryIoc.FastExpressionCompiler.LightExpression.MethodCallExpression : Expression {
    public ExpressionType NodeType { get; }
    public Type Type { get; }
    public MethodInfo Method { get; }
    public Expression Object { get; }
    public IReadOnlyList`1<Expression> Arguments { get; }
    public int ArgumentCount { get; }
    public sealed virtual ExpressionType get_NodeType();
    public virtual Type get_Type();
    public virtual MethodInfo get_Method();
    public virtual Expression get_Object();
    public virtual IReadOnlyList`1<Expression> get_Arguments();
    public virtual int get_ArgumentCount();
    public virtual Expression GetArgument(int i);
    internal virtual Expression CreateSysExpression(LiveCountArray`1& exprsConverted);
}
public class DryIoc.FastExpressionCompiler.LightExpression.NamedLabelTarget : LabelTarget {
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    public string Name { get; }
    public NamedLabelTarget(string name);
    [CompilerGeneratedAttribute]
public virtual string get_Name();
}
public abstract class DryIoc.FastExpressionCompiler.LightExpression.NewArrayExpression : Expression {
    [CompilerGeneratedAttribute]
private Type <Type>k__BackingField;
    public Type Type { get; }
    public IReadOnlyList`1<Expression> Expressions { get; }
    public int ArgumentCount { get; }
    internal NewArrayExpression(Type arrayType);
    [CompilerGeneratedAttribute]
public sealed virtual Type get_Type();
    public abstract virtual IReadOnlyList`1<Expression> get_Expressions();
    public virtual int get_ArgumentCount();
    public virtual Expression GetArgument(int i);
    internal virtual Expression CreateSysExpression(LiveCountArray`1& exprsConverted);
}
public class DryIoc.FastExpressionCompiler.LightExpression.NewExpression : Expression {
    public ConstructorInfo Constructor;
    public ExpressionType NodeType { get; }
    public Type Type { get; }
    public IReadOnlyList`1<Expression> Arguments { get; }
    public int ArgumentCount { get; }
    internal NewExpression(ConstructorInfo constructor);
    public sealed virtual ExpressionType get_NodeType();
    public virtual Type get_Type();
    public virtual IReadOnlyList`1<Expression> get_Arguments();
    public virtual int get_ArgumentCount();
    public virtual Expression GetArgument(int i);
    internal virtual Expression CreateSysExpression(LiveCountArray`1& exprsConverted);
}
public class DryIoc.FastExpressionCompiler.LightExpression.NewValueTypeExpression : NewExpression {
    [CompilerGeneratedAttribute]
private Type <Type>k__BackingField;
    public Type Type { get; }
    internal NewValueTypeExpression(Type type);
    [CompilerGeneratedAttribute]
public virtual Type get_Type();
    internal virtual Expression CreateSysExpression(LiveCountArray`1& exprsConverted);
}
public class DryIoc.FastExpressionCompiler.LightExpression.NoArgsNewClassIntrinsicExpression : NewExpression {
    public bool IsIntrinsic { get; }
    internal NoArgsNewClassIntrinsicExpression(ConstructorInfo constructor);
    public virtual bool get_IsIntrinsic();
    public virtual bool TryCollectBoundConstants(CompilerFlags config, ClosureInfo& closure, IParameterProvider paramExprs, bool isNestedLambda, ClosureInfo& rootClosure);
    public virtual bool TryEmit(CompilerFlags setup, ClosureInfo& closure, IParameterProvider paramExprs, ILGenerator il, ParentFlags parent, int byRefIndex);
}
public class DryIoc.FastExpressionCompiler.LightExpression.NoByRefFiveArgumentsNewIntrinsicExpression : FiveArgumentsNewExpression {
    public bool IsIntrinsic { get; }
    internal NoByRefFiveArgumentsNewIntrinsicExpression(ConstructorInfo constructor, object a0, object a1, object a2, object a3, object a4);
    public virtual bool get_IsIntrinsic();
    public virtual bool TryCollectBoundConstants(CompilerFlags config, ClosureInfo& closure, IParameterProvider paramExprs, bool isNestedLambda, ClosureInfo& rootClosure);
    public virtual bool TryEmit(CompilerFlags setup, ClosureInfo& closure, IParameterProvider paramExprs, ILGenerator il, ParentFlags parent, int byRefIndex);
}
public class DryIoc.FastExpressionCompiler.LightExpression.NoByRefFourArgumentsNewIntrinsicExpression : FourArgumentsNewExpression {
    public bool IsIntrinsic { get; }
    internal NoByRefFourArgumentsNewIntrinsicExpression(ConstructorInfo constructor, object a0, object a1, object a2, object a3);
    public virtual bool get_IsIntrinsic();
    public virtual bool TryCollectBoundConstants(CompilerFlags config, ClosureInfo& closure, IParameterProvider paramExprs, bool isNestedLambda, ClosureInfo& rootClosure);
    public virtual bool TryEmit(CompilerFlags setup, ClosureInfo& closure, IParameterProvider paramExprs, ILGenerator il, ParentFlags parent, int byRefIndex);
}
public class DryIoc.FastExpressionCompiler.LightExpression.NoByRefManyArgsNewIntrinsicExpression : ManyArgumentsNewExpression {
    public bool IsIntrinsic { get; }
    internal NoByRefManyArgsNewIntrinsicExpression(ConstructorInfo constructor, IReadOnlyList`1<Expression> arguments);
    public virtual bool get_IsIntrinsic();
    public virtual bool TryCollectBoundConstants(CompilerFlags config, ClosureInfo& closure, IParameterProvider paramExprs, bool isNestedLambda, ClosureInfo& rootClosure);
    public virtual bool TryEmit(CompilerFlags setup, ClosureInfo& closure, IParameterProvider paramExprs, ILGenerator il, ParentFlags parent, int byRefIndex);
}
public class DryIoc.FastExpressionCompiler.LightExpression.NoByRefOneArgNewIntrinsicExpression : OneArgumentNewExpression {
    public bool IsIntrinsic { get; }
    internal NoByRefOneArgNewIntrinsicExpression(ConstructorInfo constructor, object arg);
    public virtual bool get_IsIntrinsic();
    public virtual bool TryCollectBoundConstants(CompilerFlags config, ClosureInfo& closure, IParameterProvider paramExprs, bool isNestedLambda, ClosureInfo& rootClosure);
    public virtual bool TryEmit(CompilerFlags setup, ClosureInfo& closure, IParameterProvider paramExprs, ILGenerator il, ParentFlags parent, int byRefIndex);
}
public class DryIoc.FastExpressionCompiler.LightExpression.NoByRefSevenArgumentsNewIntrinsicExpression : SevenArgumentsNewExpression {
    public bool IsIntrinsic { get; }
    internal NoByRefSevenArgumentsNewIntrinsicExpression(ConstructorInfo constructor, object a0, object a1, object a2, object a3, object a4, object a5, object a6);
    public virtual bool get_IsIntrinsic();
    public virtual bool TryCollectBoundConstants(CompilerFlags config, ClosureInfo& closure, IParameterProvider paramExprs, bool isNestedLambda, ClosureInfo& rootClosure);
    public virtual bool TryEmit(CompilerFlags setup, ClosureInfo& closure, IParameterProvider paramExprs, ILGenerator il, ParentFlags parent, int byRefIndex);
}
public class DryIoc.FastExpressionCompiler.LightExpression.NoByRefSixArgumentsNewIntrinsicExpression : SixArgumentsNewExpression {
    public bool IsIntrinsic { get; }
    internal NoByRefSixArgumentsNewIntrinsicExpression(ConstructorInfo constructor, object a0, object a1, object a2, object a3, object a4, object a5);
    public virtual bool get_IsIntrinsic();
    public virtual bool TryCollectBoundConstants(CompilerFlags config, ClosureInfo& closure, IParameterProvider paramExprs, bool isNestedLambda, ClosureInfo& rootClosure);
    public virtual bool TryEmit(CompilerFlags setup, ClosureInfo& closure, IParameterProvider paramExprs, ILGenerator il, ParentFlags parent, int byRefIndex);
}
public class DryIoc.FastExpressionCompiler.LightExpression.NoByRefThreeArgumentsNewIntrinsicExpression : ThreeArgumentsNewExpression {
    public bool IsIntrinsic { get; }
    internal NoByRefThreeArgumentsNewIntrinsicExpression(ConstructorInfo constructor, object a0, object a1, object a2);
    public virtual bool get_IsIntrinsic();
    public virtual bool TryCollectBoundConstants(CompilerFlags config, ClosureInfo& closure, IParameterProvider paramExprs, bool isNestedLambda, ClosureInfo& rootClosure);
    public virtual bool TryEmit(CompilerFlags setup, ClosureInfo& closure, IParameterProvider paramExprs, ILGenerator il, ParentFlags parent, int byRefIndex);
}
public class DryIoc.FastExpressionCompiler.LightExpression.NoByRefTwoArgumentsNewIntrinsicExpression : TwoArgumentsNewExpression {
    public bool IsIntrinsic { get; }
    internal NoByRefTwoArgumentsNewIntrinsicExpression(ConstructorInfo constructor, object a0, object a1);
    public virtual bool get_IsIntrinsic();
    public virtual bool TryCollectBoundConstants(CompilerFlags config, ClosureInfo& closure, IParameterProvider paramExprs, bool isNestedLambda, ClosureInfo& rootClosure);
    public virtual bool TryEmit(CompilerFlags setup, ClosureInfo& closure, IParameterProvider paramExprs, ILGenerator il, ParentFlags parent, int byRefIndex);
}
public class DryIoc.FastExpressionCompiler.LightExpression.NodeTypedUnaryExpression : UnaryExpression {
    [CompilerGeneratedAttribute]
private ExpressionType <NodeType>k__BackingField;
    public ExpressionType NodeType { get; }
    public NodeTypedUnaryExpression(ExpressionType nodeType, Expression operand);
    [CompilerGeneratedAttribute]
public virtual ExpressionType get_NodeType();
}
public class DryIoc.FastExpressionCompiler.LightExpression.NotBooleanUnaryExpression : UnaryExpression {
    public ExpressionType NodeType { get; }
    public Type Type { get; }
    public NotBooleanUnaryExpression(Expression operand);
    public virtual ExpressionType get_NodeType();
    public virtual Type get_Type();
}
public class DryIoc.FastExpressionCompiler.LightExpression.NotNullExpressionInvocationExpression : InvocationExpression {
    [CompilerGeneratedAttribute]
private Expression <Expression>k__BackingField;
    public Expression Expression { get; }
    internal NotNullExpressionInvocationExpression(Expression expression);
    [CompilerGeneratedAttribute]
public sealed virtual Expression get_Expression();
}
public class DryIoc.FastExpressionCompiler.LightExpression.NotNullMethodCallExpression : MethodCallExpression {
    [CompilerGeneratedAttribute]
private MethodInfo <Method>k__BackingField;
    public MethodInfo Method { get; }
    internal NotNullMethodCallExpression(MethodInfo method);
    [CompilerGeneratedAttribute]
public virtual MethodInfo get_Method();
}
public enum DryIoc.FastExpressionCompiler.LightExpression.NotSupported : Enum {
    public ushort value__;
    public static NotSupported NewArrayInit_MultidimensionalArray;
    public static NotSupported Quote;
    public static NotSupported Dynamic;
    public static NotSupported RuntimeVariables;
    public static NotSupported MemberInit_MemberBinding;
    public static NotSupported MemberInit_ListBinding;
    public static NotSupported Try_GotoReturnToTheFollowupLabel;
    public static NotSupported Assign_Target;
    public static NotSupported TypeEqual;
}
public class DryIoc.FastExpressionCompiler.LightExpression.NotSupportedExpressionException : InvalidOperationException {
    public NotSupported Reason;
    public NotSupportedExpressionException(NotSupported reason);
    public NotSupportedExpressionException(NotSupported reason, string message);
}
public class DryIoc.FastExpressionCompiler.LightExpression.NullConstantExpression`1 : ConstantExpression {
    public object Value { get; }
    public Type Type { get; }
    public virtual object get_Value();
    public virtual Type get_Type();
}
public class DryIoc.FastExpressionCompiler.LightExpression.OneArgumentElementInit : ElementInit {
    public Expression Argument;
    public IReadOnlyList`1<Expression> Arguments { get; }
    public int ArgumentCount { get; }
    internal OneArgumentElementInit(MethodInfo addMethod, Expression a);
    public virtual IReadOnlyList`1<Expression> get_Arguments();
    public virtual int get_ArgumentCount();
    public virtual Expression GetArgument(int i);
}
public class DryIoc.FastExpressionCompiler.LightExpression.OneArgumentIndexExpression : IndexExpression {
    public Expression Argument;
    public IReadOnlyList`1<Expression> Arguments { get; }
    public int ArgumentCount { get; }
    internal OneArgumentIndexExpression(Expression object, Expression argument);
    public sealed virtual IReadOnlyList`1<Expression> get_Arguments();
    public virtual int get_ArgumentCount();
    public virtual Expression GetArgument(int index);
}
public class DryIoc.FastExpressionCompiler.LightExpression.OneArgumentInvocationExpression : NotNullExpressionInvocationExpression {
    public Expression Argument;
    public IReadOnlyList`1<Expression> Arguments { get; }
    public int ArgumentCount { get; }
    internal OneArgumentInvocationExpression(Expression expression, Expression argument);
    public sealed virtual IReadOnlyList`1<Expression> get_Arguments();
    public sealed virtual int get_ArgumentCount();
    public sealed virtual Expression GetArgument(int index);
}
public class DryIoc.FastExpressionCompiler.LightExpression.OneArgumentMethodCallExpression : NotNullMethodCallExpression {
    public object Arg;
    public IReadOnlyList`1<Expression> Arguments { get; }
    public Expression Argument { get; }
    public int ArgumentCount { get; }
    internal OneArgumentMethodCallExpression(MethodInfo method, object arg);
    public virtual IReadOnlyList`1<Expression> get_Arguments();
    public Expression get_Argument();
    public virtual int get_ArgumentCount();
    public virtual Expression GetArgument(int i);
}
public class DryIoc.FastExpressionCompiler.LightExpression.OneArgumentNewExpression : NewExpression {
    public object Arg;
    public Expression Argument { get; }
    public IReadOnlyList`1<Expression> Arguments { get; }
    public int ArgumentCount { get; }
    internal OneArgumentNewExpression(ConstructorInfo constructor, object arg);
    public Expression get_Argument();
    public virtual IReadOnlyList`1<Expression> get_Arguments();
    public virtual int get_ArgumentCount();
    public virtual Expression GetArgument(int i);
}
public class DryIoc.FastExpressionCompiler.LightExpression.OneBindingMemberInitExpression : MemberInitExpression {
    public MemberBinding Binding;
    public IReadOnlyList`1<MemberBinding> Bindings { get; }
    public int ArgumentCount { get; }
    internal OneBindingMemberInitExpression(Expression expression, MemberBinding b1);
    public virtual IReadOnlyList`1<MemberBinding> get_Bindings();
    public virtual int get_ArgumentCount();
    public virtual MemberBinding GetArgument(int i);
}
public class DryIoc.FastExpressionCompiler.LightExpression.OneBoundNewArrayBoundsExpression : NewArrayExpression {
    public Expression Bound;
    public ExpressionType NodeType { get; }
    public IReadOnlyList`1<Expression> Expressions { get; }
    public int ArgumentCount { get; }
    internal OneBoundNewArrayBoundsExpression(Type arrayType, Expression bound);
    public virtual ExpressionType get_NodeType();
    public virtual IReadOnlyList`1<Expression> get_Expressions();
    public virtual int get_ArgumentCount();
    public virtual Expression GetArgument(int i);
}
public class DryIoc.FastExpressionCompiler.LightExpression.OneElementNewArrayInitExpression : NewArrayExpression {
    public Expression Element;
    public ExpressionType NodeType { get; }
    public IReadOnlyList`1<Expression> Expressions { get; }
    public int ArgumentCount { get; }
    internal OneElementNewArrayInitExpression(Type arrayType, Expression element);
    public virtual ExpressionType get_NodeType();
    public virtual IReadOnlyList`1<Expression> get_Expressions();
    public virtual int get_ArgumentCount();
    public virtual Expression GetArgument(int i);
}
public class DryIoc.FastExpressionCompiler.LightExpression.OneParameterExpression`1 : Expression`1<TDelegate> {
    public ParameterExpression Parameter0;
    public IReadOnlyList`1<ParameterExpression> Parameters { get; }
    public int ParameterCount { get; }
    internal OneParameterExpression`1(Expression body, ParameterExpression p0);
    public sealed virtual IReadOnlyList`1<ParameterExpression> get_Parameters();
    public sealed virtual int get_ParameterCount();
    public sealed virtual ParameterExpression GetParameter(int index);
}
public class DryIoc.FastExpressionCompiler.LightExpression.OneParameterLambdaExpression : TypedLambdaExpression {
    public ParameterExpression Parameter0;
    public IReadOnlyList`1<ParameterExpression> Parameters { get; }
    public int ParameterCount { get; }
    internal OneParameterLambdaExpression(Type delegateType, Expression body, ParameterExpression parameter);
    public sealed virtual IReadOnlyList`1<ParameterExpression> get_Parameters();
    public sealed virtual int get_ParameterCount();
    public sealed virtual ParameterExpression GetParameter(int index);
}
public class DryIoc.FastExpressionCompiler.LightExpression.OpAssignBinaryExpression : AssignBinaryExpression {
    [CompilerGeneratedAttribute]
private ExpressionType <NodeType>k__BackingField;
    public ExpressionType NodeType { get; }
    internal OpAssignBinaryExpression(ExpressionType nodeType, Expression left, Expression right);
    [CompilerGeneratedAttribute]
public sealed virtual ExpressionType get_NodeType();
}
public class DryIoc.FastExpressionCompiler.LightExpression.OpAssignMethodConversionBinaryExpression : OpAssignBinaryExpression {
    [CompilerGeneratedAttribute]
private MethodInfo <Method>k__BackingField;
    [CompilerGeneratedAttribute]
private LambdaExpression <Conversion>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <LiftToNull>k__BackingField;
    public MethodInfo Method { get; }
    public LambdaExpression Conversion { get; }
    public bool LiftToNull { get; }
    internal OpAssignMethodConversionBinaryExpression(ExpressionType nodeType, Expression left, Expression right, MethodInfo method, LambdaExpression conversion, bool liftToNull);
    [CompilerGeneratedAttribute]
public virtual MethodInfo get_Method();
    [CompilerGeneratedAttribute]
public virtual LambdaExpression get_Conversion();
    [CompilerGeneratedAttribute]
public bool get_LiftToNull();
    internal virtual Expression CreateSysExpression(LiveCountArray`1& exprsConverted);
}
public class DryIoc.FastExpressionCompiler.LightExpression.ParameterExpression : Expression {
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    public ExpressionType NodeType { get; }
    public Type Type { get; }
    public bool IsByRef { get; }
    public string Name { get; }
    internal ParameterExpression(string name);
    public sealed virtual ExpressionType get_NodeType();
    public virtual Type get_Type();
    public virtual bool get_IsByRef();
    [CompilerGeneratedAttribute]
public string get_Name();
    internal virtual Expression CreateSysExpression(LiveCountArray`1& exprsConverted);
    internal static ParameterExpression[] ToParameterExpressions(IReadOnlyList`1<ParameterExpression> ps, LiveCountArray`1& exprsConverted);
}
public class DryIoc.FastExpressionCompiler.LightExpression.PropertyExpression : MemberExpression {
    public Type Type { get; }
    public PropertyInfo PropertyInfo { get; }
    internal PropertyExpression(PropertyInfo property);
    public virtual Type get_Type();
    public PropertyInfo get_PropertyInfo();
    internal virtual Expression CreateSysExpression(LiveCountArray`1& exprsConverted);
}
public class DryIoc.FastExpressionCompiler.LightExpression.ReturnGotoExpression : GotoExpression {
    public GotoExpressionKind Kind { get; }
    internal ReturnGotoExpression(LabelTarget target);
    public virtual GotoExpressionKind get_Kind();
}
public class DryIoc.FastExpressionCompiler.LightExpression.ReturnTypedGotoExpression : TypedGotoExpression {
    public GotoExpressionKind Kind { get; }
    internal ReturnTypedGotoExpression(LabelTarget target, Type type);
    public virtual GotoExpressionKind get_Kind();
}
public class DryIoc.FastExpressionCompiler.LightExpression.ReturnTypedValueGotoExpression : TypedValueGotoExpression {
    public GotoExpressionKind Kind { get; }
    internal ReturnTypedValueGotoExpression(LabelTarget target, Expression value, Type type);
    public virtual GotoExpressionKind get_Kind();
}
public class DryIoc.FastExpressionCompiler.LightExpression.ReturnValueGotoExpression : ValueGotoExpression {
    public GotoExpressionKind Kind { get; }
    internal ReturnValueGotoExpression(LabelTarget target, Expression value);
    public virtual GotoExpressionKind get_Kind();
}
public class DryIoc.FastExpressionCompiler.LightExpression.RuntimeVariablesExpression : Expression {
    public IReadOnlyList`1<ParameterExpression> Variables;
    public ExpressionType NodeType { get; }
    public Type Type { get; }
    internal RuntimeVariablesExpression(IReadOnlyList`1<ParameterExpression> variables);
    public sealed virtual ExpressionType get_NodeType();
    public sealed virtual Type get_Type();
    internal virtual Expression CreateSysExpression(LiveCountArray`1& convertedExpressions);
}
public class DryIoc.FastExpressionCompiler.LightExpression.SevenArgumentsMethodCallExpression : NotNullMethodCallExpression {
    public object A0;
    public object A1;
    public object A2;
    public object A3;
    public object A4;
    public object A5;
    public object A6;
    public IReadOnlyList`1<Expression> Arguments { get; }
    public Expression Argument0 { get; }
    public Expression Argument1 { get; }
    public Expression Argument2 { get; }
    public Expression Argument3 { get; }
    public Expression Argument4 { get; }
    public Expression Argument5 { get; }
    public Expression Argument6 { get; }
    public int ArgumentCount { get; }
    internal SevenArgumentsMethodCallExpression(MethodInfo method, object a0, object a1, object a2, object a3, object a4, object a5, object a6);
    public virtual IReadOnlyList`1<Expression> get_Arguments();
    public Expression get_Argument0();
    public Expression get_Argument1();
    public Expression get_Argument2();
    public Expression get_Argument3();
    public Expression get_Argument4();
    public Expression get_Argument5();
    public Expression get_Argument6();
    public virtual int get_ArgumentCount();
    public virtual Expression GetArgument(int i);
}
public class DryIoc.FastExpressionCompiler.LightExpression.SevenArgumentsNewExpression : NewExpression {
    public object A0;
    public object A1;
    public object A2;
    public object A3;
    public object A4;
    public object A5;
    public object A6;
    public Expression Argument0 { get; }
    public Expression Argument1 { get; }
    public Expression Argument2 { get; }
    public Expression Argument3 { get; }
    public Expression Argument4 { get; }
    public Expression Argument5 { get; }
    public Expression Argument6 { get; }
    public IReadOnlyList`1<Expression> Arguments { get; }
    public int ArgumentCount { get; }
    internal SevenArgumentsNewExpression(ConstructorInfo constructor, object a0, object a1, object a2, object a3, object a4, object a5, object a6);
    public Expression get_Argument0();
    public Expression get_Argument1();
    public Expression get_Argument2();
    public Expression get_Argument3();
    public Expression get_Argument4();
    public Expression get_Argument5();
    public Expression get_Argument6();
    public virtual IReadOnlyList`1<Expression> get_Arguments();
    public virtual int get_ArgumentCount();
    public virtual Expression GetArgument(int i);
}
public class DryIoc.FastExpressionCompiler.LightExpression.SixArgumentsInvocationExpression : NotNullExpressionInvocationExpression {
    public Expression Argument0;
    public Expression Argument1;
    public Expression Argument2;
    public Expression Argument3;
    public Expression Argument4;
    public Expression Argument5;
    public IReadOnlyList`1<Expression> Arguments { get; }
    public int ArgumentCount { get; }
    internal SixArgumentsInvocationExpression(Expression expression, Expression a0, Expression a1, Expression a2, Expression a3, Expression a4, Expression a5);
    public sealed virtual IReadOnlyList`1<Expression> get_Arguments();
    public sealed virtual int get_ArgumentCount();
    public sealed virtual Expression GetArgument(int i);
}
public class DryIoc.FastExpressionCompiler.LightExpression.SixArgumentsMethodCallExpression : NotNullMethodCallExpression {
    public object A0;
    public object A1;
    public object A2;
    public object A3;
    public object A4;
    public object A5;
    public IReadOnlyList`1<Expression> Arguments { get; }
    public Expression Argument0 { get; }
    public Expression Argument1 { get; }
    public Expression Argument2 { get; }
    public Expression Argument3 { get; }
    public Expression Argument4 { get; }
    public Expression Argument5 { get; }
    public int ArgumentCount { get; }
    internal SixArgumentsMethodCallExpression(MethodInfo method, object a0, object a1, object a2, object a3, object a4, object a5);
    public virtual IReadOnlyList`1<Expression> get_Arguments();
    public Expression get_Argument0();
    public Expression get_Argument1();
    public Expression get_Argument2();
    public Expression get_Argument3();
    public Expression get_Argument4();
    public Expression get_Argument5();
    public virtual int get_ArgumentCount();
    public virtual Expression GetArgument(int i);
}
public class DryIoc.FastExpressionCompiler.LightExpression.SixArgumentsNewExpression : NewExpression {
    public object A0;
    public object A1;
    public object A2;
    public object A3;
    public object A4;
    public object A5;
    public Expression Argument0 { get; }
    public Expression Argument1 { get; }
    public Expression Argument2 { get; }
    public Expression Argument3 { get; }
    public Expression Argument4 { get; }
    public Expression Argument5 { get; }
    public IReadOnlyList`1<Expression> Arguments { get; }
    public int ArgumentCount { get; }
    internal SixArgumentsNewExpression(ConstructorInfo constructor, object a0, object a1, object a2, object a3, object a4, object a5);
    public Expression get_Argument0();
    public Expression get_Argument1();
    public Expression get_Argument2();
    public Expression get_Argument3();
    public Expression get_Argument4();
    public Expression get_Argument5();
    public virtual IReadOnlyList`1<Expression> get_Arguments();
    public virtual int get_ArgumentCount();
    public virtual Expression GetArgument(int i);
}
public class DryIoc.FastExpressionCompiler.LightExpression.SixBindingsMemberInitExpression : MemberInitExpression {
    public MemberBinding Binding0;
    public MemberBinding Binding1;
    public MemberBinding Binding2;
    public MemberBinding Binding3;
    public MemberBinding Binding4;
    public MemberBinding Binding5;
    public IReadOnlyList`1<MemberBinding> Bindings { get; }
    public int ArgumentCount { get; }
    internal SixBindingsMemberInitExpression(Expression expression, MemberBinding b0, MemberBinding b1, MemberBinding b2, MemberBinding b3, MemberBinding b4, MemberBinding b5);
    public virtual IReadOnlyList`1<MemberBinding> get_Bindings();
    public virtual int get_ArgumentCount();
    public virtual MemberBinding GetArgument(int i);
}
public class DryIoc.FastExpressionCompiler.LightExpression.SixElementNewArrayInitExpression : NewArrayExpression {
    public Expression Element0;
    public Expression Element1;
    public Expression Element2;
    public Expression Element3;
    public Expression Element4;
    public Expression Element5;
    public ExpressionType NodeType { get; }
    public IReadOnlyList`1<Expression> Expressions { get; }
    public int ArgumentCount { get; }
    internal SixElementNewArrayInitExpression(Type arrayType, Expression el0, Expression el1, Expression el2, Expression el3, Expression el4, Expression el5);
    public virtual ExpressionType get_NodeType();
    public virtual IReadOnlyList`1<Expression> get_Expressions();
    public virtual int get_ArgumentCount();
    public virtual Expression GetArgument(int i);
}
public class DryIoc.FastExpressionCompiler.LightExpression.SixParametersExpression`1 : Expression`1<TDelegate> {
    public ParameterExpression Parameter0;
    public ParameterExpression Parameter1;
    public ParameterExpression Parameter2;
    public ParameterExpression Parameter3;
    public ParameterExpression Parameter4;
    public ParameterExpression Parameter5;
    public IReadOnlyList`1<ParameterExpression> Parameters { get; }
    public int ParameterCount { get; }
    internal SixParametersExpression`1(Expression body, ParameterExpression p0, ParameterExpression p1, ParameterExpression p2, ParameterExpression p3, ParameterExpression p4, ParameterExpression p5);
    public sealed virtual IReadOnlyList`1<ParameterExpression> get_Parameters();
    public sealed virtual int get_ParameterCount();
    public sealed virtual ParameterExpression GetParameter(int i);
}
public class DryIoc.FastExpressionCompiler.LightExpression.SixParametersLambdaExpression : TypedLambdaExpression {
    public ParameterExpression Parameter0;
    public ParameterExpression Parameter1;
    public ParameterExpression Parameter2;
    public ParameterExpression Parameter3;
    public ParameterExpression Parameter4;
    public ParameterExpression Parameter5;
    public IReadOnlyList`1<ParameterExpression> Parameters { get; }
    public int ParameterCount { get; }
    internal SixParametersLambdaExpression(Type delegateType, Expression body, ParameterExpression p0, ParameterExpression p1, ParameterExpression p2, ParameterExpression p3, ParameterExpression p4, ParameterExpression p5);
    public sealed virtual IReadOnlyList`1<ParameterExpression> get_Parameters();
    public sealed virtual int get_ParameterCount();
    public sealed virtual ParameterExpression GetParameter(int i);
}
public class DryIoc.FastExpressionCompiler.LightExpression.SwitchCase : ValueType {
    public IReadOnlyList`1<Expression> TestValues;
    public Expression Body;
    public SwitchCase(Expression body, IEnumerable`1<Expression> testValues);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
}
public class DryIoc.FastExpressionCompiler.LightExpression.SwitchExpression : Expression {
    [CompilerGeneratedAttribute]
private Type <Type>k__BackingField;
    public Expression SwitchValue;
    private SwitchCase[] _cases;
    public Expression DefaultBody;
    public ExpressionType NodeType { get; }
    public Type Type { get; }
    public IReadOnlyList`1<SwitchCase> Cases { get; }
    public MethodInfo Comparison { get; }
    public SwitchExpression(Type type, Expression switchValue, Expression defaultBody, SwitchCase[] cases);
    public sealed virtual ExpressionType get_NodeType();
    [CompilerGeneratedAttribute]
public sealed virtual Type get_Type();
    public IReadOnlyList`1<SwitchCase> get_Cases();
    public virtual MethodInfo get_Comparison();
    internal virtual Expression CreateSysExpression(LiveCountArray`1& exprsConverted);
    internal static SwitchCase ToSwitchCase(SwitchCase& sw, LiveCountArray`1& exprsConverted);
    internal static SwitchCase[] ToSwitchCaseExpressions(SwitchCase[] switchCases, LiveCountArray`1& exprsConverted);
}
public class DryIoc.FastExpressionCompiler.LightExpression.SymbolDocumentInfo : object {
    [CompilerGeneratedAttribute]
private string <FileName>k__BackingField;
    internal static Guid DocumentType_Text;
    public string FileName { get; }
    public Guid Language { get; }
    public Guid LanguageVendor { get; }
    public Guid DocumentType { get; }
    internal SymbolDocumentInfo(string fileName);
    private static SymbolDocumentInfo();
    [CompilerGeneratedAttribute]
public string get_FileName();
    public virtual Guid get_Language();
    public virtual Guid get_LanguageVendor();
    public virtual Guid get_DocumentType();
}
public class DryIoc.FastExpressionCompiler.LightExpression.ThreeArgumentsInvocationExpression : NotNullExpressionInvocationExpression {
    public Expression Argument0;
    public Expression Argument1;
    public Expression Argument2;
    public IReadOnlyList`1<Expression> Arguments { get; }
    public int ArgumentCount { get; }
    internal ThreeArgumentsInvocationExpression(Expression expression, Expression a0, Expression a1, Expression a2);
    public sealed virtual IReadOnlyList`1<Expression> get_Arguments();
    public sealed virtual int get_ArgumentCount();
    public sealed virtual Expression GetArgument(int i);
}
public class DryIoc.FastExpressionCompiler.LightExpression.ThreeArgumentsMethodCallExpression : NotNullMethodCallExpression {
    public object A0;
    public object A1;
    public object A2;
    public IReadOnlyList`1<Expression> Arguments { get; }
    public Expression Argument0 { get; }
    public Expression Argument1 { get; }
    public Expression Argument2 { get; }
    public int ArgumentCount { get; }
    internal ThreeArgumentsMethodCallExpression(MethodInfo method, object a0, object a1, object a2);
    public virtual IReadOnlyList`1<Expression> get_Arguments();
    public Expression get_Argument0();
    public Expression get_Argument1();
    public Expression get_Argument2();
    public virtual int get_ArgumentCount();
    public virtual Expression GetArgument(int i);
}
public class DryIoc.FastExpressionCompiler.LightExpression.ThreeArgumentsNewExpression : NewExpression {
    public object A0;
    public object A1;
    public object A2;
    public Expression Argument0 { get; }
    public Expression Argument1 { get; }
    public Expression Argument2 { get; }
    public IReadOnlyList`1<Expression> Arguments { get; }
    public int ArgumentCount { get; }
    internal ThreeArgumentsNewExpression(ConstructorInfo constructor, object a0, object a1, object a2);
    public Expression get_Argument0();
    public Expression get_Argument1();
    public Expression get_Argument2();
    public virtual IReadOnlyList`1<Expression> get_Arguments();
    public virtual int get_ArgumentCount();
    public virtual Expression GetArgument(int i);
}
public class DryIoc.FastExpressionCompiler.LightExpression.ThreeBindingsMemberInitExpression : MemberInitExpression {
    public MemberBinding Binding0;
    public MemberBinding Binding1;
    public MemberBinding Binding2;
    public IReadOnlyList`1<MemberBinding> Bindings { get; }
    public int ArgumentCount { get; }
    internal ThreeBindingsMemberInitExpression(Expression expression, MemberBinding b0, MemberBinding b1, MemberBinding b2);
    public virtual IReadOnlyList`1<MemberBinding> get_Bindings();
    public virtual int get_ArgumentCount();
    public virtual MemberBinding GetArgument(int i);
}
public class DryIoc.FastExpressionCompiler.LightExpression.ThreeElementNewArrayInitExpression : NewArrayExpression {
    public Expression Element0;
    public Expression Element1;
    public Expression Element2;
    public ExpressionType NodeType { get; }
    public IReadOnlyList`1<Expression> Expressions { get; }
    public int ArgumentCount { get; }
    internal ThreeElementNewArrayInitExpression(Type arrayType, Expression el0, Expression el1, Expression el2);
    public virtual ExpressionType get_NodeType();
    public virtual IReadOnlyList`1<Expression> get_Expressions();
    public virtual int get_ArgumentCount();
    public virtual Expression GetArgument(int i);
}
public class DryIoc.FastExpressionCompiler.LightExpression.ThreeParametersExpression`1 : Expression`1<TDelegate> {
    public ParameterExpression Parameter0;
    public ParameterExpression Parameter1;
    public ParameterExpression Parameter2;
    public IReadOnlyList`1<ParameterExpression> Parameters { get; }
    public int ParameterCount { get; }
    internal ThreeParametersExpression`1(Expression body, ParameterExpression p0, ParameterExpression p1, ParameterExpression p2);
    public sealed virtual IReadOnlyList`1<ParameterExpression> get_Parameters();
    public sealed virtual int get_ParameterCount();
    public sealed virtual ParameterExpression GetParameter(int i);
}
public class DryIoc.FastExpressionCompiler.LightExpression.ThreeParametersLambdaExpression : TypedLambdaExpression {
    public ParameterExpression Parameter0;
    public ParameterExpression Parameter1;
    public ParameterExpression Parameter2;
    public IReadOnlyList`1<ParameterExpression> Parameters { get; }
    public int ParameterCount { get; }
    internal ThreeParametersLambdaExpression(Type delegateType, Expression body, ParameterExpression p0, ParameterExpression p1, ParameterExpression p2);
    public sealed virtual IReadOnlyList`1<ParameterExpression> get_Parameters();
    public sealed virtual int get_ParameterCount();
    public sealed virtual ParameterExpression GetParameter(int i);
}
public class DryIoc.FastExpressionCompiler.LightExpression.ThrowUnaryExpression : UnaryExpression {
    public ExpressionType NodeType { get; }
    public Type Type { get; }
    public ThrowUnaryExpression(Expression operand);
    public virtual ExpressionType get_NodeType();
    public virtual Type get_Type();
}
[ExtensionAttribute]
public static class DryIoc.FastExpressionCompiler.LightExpression.ToCSharpPrinter : object {
    private static string NotSupportedExpression;
    [ExtensionAttribute]
public static string ToCSharpString(Expression expr);
    [ExtensionAttribute]
public static string ToCSharpString(Expression expr, ObjectToCode notRecognizedToCode);
    [ExtensionAttribute]
public static StringBuilder ToCSharpString(Expression e, StringBuilder sb, int lineIdent, bool stripNamespace, Func`3<Type, string, string> printType, int identSpaces, ObjectToCode notRecognizedToCode);
    [ExtensionAttribute]
private static StringBuilder AddSemicolonIfFits(StringBuilder sb);
    private static bool CanBeReturned(ExpressionType nt);
    [ExtensionAttribute]
private static string GetCSharpName(MemberInfo m);
    [ExtensionAttribute]
internal static StringBuilder ToCSharpString(LabelTarget target, StringBuilder sb);
    [ExtensionAttribute]
private static StringBuilder ToCSharpString(IReadOnlyList`1<MemberBinding> bindings, StringBuilder sb, int lineIdent, bool stripNamespace, Func`3<Type, string, string> printType, int identSpaces, ObjectToCode notRecognizedToCode);
    [ExtensionAttribute]
private static StringBuilder BlockToCSharpString(BlockExpression b, StringBuilder sb, int lineIdent, bool stripNamespace, Func`3<Type, string, string> printType, int identSpaces, ObjectToCode notRecognizedToCode, bool inTheLastBlock, BinaryExpression blockResultAssignment);
    private static string OperatorToCSharpString(ExpressionType nodeType);
    [CompilerGeneratedAttribute]
internal static void <ToCSharpString>g__PrintPart|2_0(Expression part, <>c__DisplayClass2_0& , <>c__DisplayClass2_1& );
}
[ExtensionAttribute]
public static class DryIoc.FastExpressionCompiler.LightExpression.ToExpressionPrinter : object {
    private static string NotSupportedExpression;
    [ExtensionAttribute]
public static string ToExpressionString(Expression expr, ObjectToCode notRecognizedToCode);
    [ExtensionAttribute]
public static string ToExpressionString(Expression expr, List`1& paramsExprs, List`1& uniqueExprs, List`1& lts, bool stripNamespace, Func`3<Type, string, string> printType, int identSpaces, ObjectToCode notRecognizedToCode);
    [ExtensionAttribute]
internal static StringBuilder ToExpressionString(Expression expr, StringBuilder sb, List`1<ParameterExpression> paramsExprs, List`1<Expression> uniqueExprs, List`1<LabelTarget> lts, int lineIdent, bool stripNamespace, Func`3<Type, string, string> printType, int identSpaces, ObjectToCode notRecognizedToCode);
    [ExtensionAttribute]
internal static StringBuilder ToExpressionString(ParameterExpression pe, StringBuilder sb, List`1<ParameterExpression> paramsExprs, List`1<Expression> uniqueExprs, List`1<LabelTarget> lts, int lineIdent, bool stripNamespace, Func`3<Type, string, string> printType, int identSpaces, ObjectToCode notRecognizedToCode);
    [ExtensionAttribute]
internal static StringBuilder ToExpressionString(LabelTarget lt, StringBuilder sb, List`1<LabelTarget> labelTargets, int lineIdent, bool stripNamespace, Func`3<Type, string, string> printType);
    [ExtensionAttribute]
private static StringBuilder ToExpressionString(IReadOnlyList`1<CatchBlock> bs, StringBuilder sb, List`1<ParameterExpression> paramsExprs, List`1<Expression> uniqueExprs, List`1<LabelTarget> lts, int lineIdent, bool stripNamespace, Func`3<Type, string, string> printType, int identSpaces, ObjectToCode notRecognizedToCode);
    [ExtensionAttribute]
private static StringBuilder ToExpressionString(CatchBlock b, StringBuilder sb, List`1<ParameterExpression> paramsExprs, List`1<Expression> uniqueExprs, List`1<LabelTarget> lts, int lineIdent, bool stripNamespace, Func`3<Type, string, string> printType, int identSpaces, ObjectToCode notRecognizedToCode);
    [ExtensionAttribute]
private static StringBuilder ToExpressionString(IReadOnlyList`1<SwitchCase> items, StringBuilder sb, List`1<ParameterExpression> paramsExprs, List`1<Expression> uniqueExprs, List`1<LabelTarget> lts, int lineIdent, bool stripNamespace, Func`3<Type, string, string> printType, int identSpaces, ObjectToCode notRecognizedToCode);
    [ExtensionAttribute]
private static StringBuilder ToExpressionString(SwitchCase s, StringBuilder sb, List`1<ParameterExpression> paramsExprs, List`1<Expression> uniqueExprs, List`1<LabelTarget> lts, int lineIdent, bool stripNamespace, Func`3<Type, string, string> printType, int identSpaces, ObjectToCode notRecognizedToCode);
    [ExtensionAttribute]
private static StringBuilder ToExpressionString(MemberBinding mb, StringBuilder sb, List`1<ParameterExpression> paramsExprs, List`1<Expression> uniqueExprs, List`1<LabelTarget> lts, int lineIdent, bool stripNamespace, Func`3<Type, string, string> printType, int identSpaces, ObjectToCode notRecognizedToCode);
    [ExtensionAttribute]
private static StringBuilder ToExpressionString(ElementInit ei, StringBuilder sb, List`1<ParameterExpression> paramsExprs, List`1<Expression> uniqueExprs, List`1<LabelTarget> lts, int lineIdent, bool stripNamespace, Func`3<Type, string, string> printType, int identSpaces, ObjectToCode notRecognizedToCode);
    [ExtensionAttribute]
internal static StringBuilder CreateExpressionString(Expression e, StringBuilder sb, List`1<ParameterExpression> paramsExprs, List`1<Expression> uniqueExprs, List`1<LabelTarget> lts, int lineIdent, bool stripNamespace, Func`3<Type, string, string> printType, int identSpaces, ObjectToCode notRecognizedToCode);
}
[ExtensionAttribute]
internal static class DryIoc.FastExpressionCompiler.LightExpression.Tools : object {
    internal static MethodInfo DelegateTargetGetterMethod;
    private static Tools();
    [ExtensionAttribute]
public static Expression AsExpr(object obj);
    [ExtensionAttribute]
public static Expression[] AsExprs(Object[] obj);
    [ExtensionAttribute]
internal static bool IsUnsigned(Type type);
    [ExtensionAttribute]
internal static bool IsNullable(Type type);
    [ExtensionAttribute]
internal static Type GetUnderlyingNullableTypeOrNull(Type type);
    [ExtensionAttribute]
public static string GetArithmeticBinaryOperatorMethodName(ExpressionType nodeType);
    [ExtensionAttribute]
internal static MethodInfo FindMethod(Type type, string methodName);
    [ExtensionAttribute]
internal static MethodInfo FindDelegateInvokeMethod(Type type);
    [ExtensionAttribute]
internal static MethodInfo FindNullableGetValueOrDefaultMethod(Type type);
    [ExtensionAttribute]
internal static MethodInfo FindValueGetterMethod(Type type);
    [ExtensionAttribute]
internal static MethodInfo FindNullableHasValueGetterMethod(Type type);
    [ExtensionAttribute]
internal static MethodInfo FindConvertOperator(Type type, Type sourceType, Type targetType);
    [ExtensionAttribute]
internal static ConstructorInfo FindSingleParamConstructor(Type type, Type paramType);
    [ExtensionAttribute]
public static T[] AsArray(IEnumerable`1<T> xs);
    public static T[] Empty();
    public static Type[] GetParamTypes(IReadOnlyList`1<ParameterExpression> paramExprs);
    public static Type GetFuncOrActionType(Type returnType);
    public static Type GetFuncOrActionType(Type p, Type returnType);
    public static Type GetFuncOrActionType(Type p0, Type p1, Type returnType);
    public static Type GetFuncOrActionType(Type p0, Type p1, Type p2, Type returnType);
    public static Type GetFuncOrActionType(Type p0, Type p1, Type p2, Type p3, Type returnType);
    public static Type GetFuncOrActionType(Type p0, Type p1, Type p2, Type p3, Type p4, Type returnType);
    public static Type GetFuncOrActionType(Type p0, Type p1, Type p2, Type p3, Type p4, Type p5, Type returnType);
    public static Type GetFuncOrActionType(Type[] paramTypes, Type returnType);
    [ExtensionAttribute]
public static T GetFirst(IEnumerable`1<T> source);
    [ExtensionAttribute]
public static T GetFirst(T[] source);
}
public class DryIoc.FastExpressionCompiler.LightExpression.TryExpression : Expression {
    public Expression Body;
    private CatchBlock[] _handlers;
    public ExpressionType NodeType { get; }
    public Type Type { get; }
    public IReadOnlyList`1<CatchBlock> Handlers { get; }
    public Expression Finally { get; }
    internal TryExpression(Expression body, CatchBlock[] handlers);
    public virtual ExpressionType get_NodeType();
    public virtual Type get_Type();
    public IReadOnlyList`1<CatchBlock> get_Handlers();
    public virtual Expression get_Finally();
    internal virtual Expression CreateSysExpression(LiveCountArray`1& exprsConverted);
    private static CatchBlock ToCatchBlock(CatchBlock& cb, LiveCountArray`1& exprsConverted);
    private static CatchBlock[] ToCatchBlocks(CatchBlock[] hs, LiveCountArray`1& exprsConverted);
}
public class DryIoc.FastExpressionCompiler.LightExpression.TwoArgumentsInvocationExpression : NotNullExpressionInvocationExpression {
    public Expression Argument0;
    public Expression Argument1;
    public IReadOnlyList`1<Expression> Arguments { get; }
    public int ArgumentCount { get; }
    internal TwoArgumentsInvocationExpression(Expression expression, Expression a0, Expression a1);
    public sealed virtual IReadOnlyList`1<Expression> get_Arguments();
    public sealed virtual int get_ArgumentCount();
    public sealed virtual Expression GetArgument(int i);
}
public class DryIoc.FastExpressionCompiler.LightExpression.TwoArgumentsMethodCallExpression : NotNullMethodCallExpression {
    public object A0;
    public object A1;
    public IReadOnlyList`1<Expression> Arguments { get; }
    public Expression Argument0 { get; }
    public Expression Argument1 { get; }
    public int ArgumentCount { get; }
    internal TwoArgumentsMethodCallExpression(MethodInfo method, object a0, object a1);
    public virtual IReadOnlyList`1<Expression> get_Arguments();
    public Expression get_Argument0();
    public Expression get_Argument1();
    public virtual int get_ArgumentCount();
    public virtual Expression GetArgument(int i);
}
public class DryIoc.FastExpressionCompiler.LightExpression.TwoArgumentsNewExpression : NewExpression {
    public object A0;
    public object A1;
    public Expression Argument0 { get; }
    public Expression Argument1 { get; }
    public IReadOnlyList`1<Expression> Arguments { get; }
    public int ArgumentCount { get; }
    internal TwoArgumentsNewExpression(ConstructorInfo constructor, object a0, object a1);
    public Expression get_Argument0();
    public Expression get_Argument1();
    public virtual IReadOnlyList`1<Expression> get_Arguments();
    public virtual int get_ArgumentCount();
    public virtual Expression GetArgument(int i);
}
public class DryIoc.FastExpressionCompiler.LightExpression.TwoBindingsMemberInitExpression : MemberInitExpression {
    public MemberBinding Binding0;
    public MemberBinding Binding1;
    public IReadOnlyList`1<MemberBinding> Bindings { get; }
    public int ArgumentCount { get; }
    internal TwoBindingsMemberInitExpression(Expression expression, MemberBinding b0, MemberBinding b1);
    public virtual IReadOnlyList`1<MemberBinding> get_Bindings();
    public virtual int get_ArgumentCount();
    public virtual MemberBinding GetArgument(int i);
}
public class DryIoc.FastExpressionCompiler.LightExpression.TwoElementNewArrayInitExpression : NewArrayExpression {
    public Expression Element0;
    public Expression Element1;
    public ExpressionType NodeType { get; }
    public IReadOnlyList`1<Expression> Expressions { get; }
    public int ArgumentCount { get; }
    internal TwoElementNewArrayInitExpression(Type arrayType, Expression el0, Expression el1);
    public virtual ExpressionType get_NodeType();
    public virtual IReadOnlyList`1<Expression> get_Expressions();
    public virtual int get_ArgumentCount();
    public virtual Expression GetArgument(int i);
}
public class DryIoc.FastExpressionCompiler.LightExpression.TwoParametersExpression`1 : Expression`1<TDelegate> {
    public ParameterExpression Parameter0;
    public ParameterExpression Parameter1;
    public IReadOnlyList`1<ParameterExpression> Parameters { get; }
    public int ParameterCount { get; }
    internal TwoParametersExpression`1(Expression body, ParameterExpression p0, ParameterExpression p1);
    public sealed virtual IReadOnlyList`1<ParameterExpression> get_Parameters();
    public sealed virtual int get_ParameterCount();
    public sealed virtual ParameterExpression GetParameter(int i);
}
public class DryIoc.FastExpressionCompiler.LightExpression.TwoParametersLambdaExpression : TypedLambdaExpression {
    public ParameterExpression Parameter0;
    public ParameterExpression Parameter1;
    public IReadOnlyList`1<ParameterExpression> Parameters { get; }
    public int ParameterCount { get; }
    internal TwoParametersLambdaExpression(Type delegateType, Expression body, ParameterExpression p0, ParameterExpression p1);
    public sealed virtual IReadOnlyList`1<ParameterExpression> get_Parameters();
    public sealed virtual int get_ParameterCount();
    public sealed virtual ParameterExpression GetParameter(int index);
}
public class DryIoc.FastExpressionCompiler.LightExpression.TypeBinaryExpression : Expression {
    [CompilerGeneratedAttribute]
private ExpressionType <NodeType>k__BackingField;
    [CompilerGeneratedAttribute]
private Type <TypeOperand>k__BackingField;
    public Expression Expression;
    public ExpressionType NodeType { get; }
    public Type Type { get; }
    public Type TypeOperand { get; }
    internal TypeBinaryExpression(ExpressionType nodeType, Expression expression, Type typeOperand);
    [CompilerGeneratedAttribute]
public virtual ExpressionType get_NodeType();
    public virtual Type get_Type();
    [CompilerGeneratedAttribute]
public Type get_TypeOperand();
    internal virtual Expression CreateSysExpression(LiveCountArray`1& exprsConverted);
}
public class DryIoc.FastExpressionCompiler.LightExpression.TypedBlockExpression : BlockExpression {
    [CompilerGeneratedAttribute]
private Type <Type>k__BackingField;
    public Type Type { get; }
    internal TypedBlockExpression(Type type, IReadOnlyList`1<Expression> expressions);
    [CompilerGeneratedAttribute]
public virtual Type get_Type();
}
public class DryIoc.FastExpressionCompiler.LightExpression.TypedConvertUnaryExpression`1 : UnaryExpression {
    public ExpressionType NodeType { get; }
    public Type Type { get; }
    public TypedConvertUnaryExpression`1(Expression operand);
    public virtual ExpressionType get_NodeType();
    public virtual Type get_Type();
}
public class DryIoc.FastExpressionCompiler.LightExpression.TypedFiveArgumentsInvocationExpression : FiveArgumentsInvocationExpression {
    [CompilerGeneratedAttribute]
private Type <Type>k__BackingField;
    public Type Type { get; }
    internal TypedFiveArgumentsInvocationExpression(Expression expression, Type type, Expression a0, Expression a1, Expression a2, Expression a3, Expression a4);
    [CompilerGeneratedAttribute]
public virtual Type get_Type();
}
public class DryIoc.FastExpressionCompiler.LightExpression.TypedFourArgumentsInvocationExpression : FourArgumentsInvocationExpression {
    [CompilerGeneratedAttribute]
private Type <Type>k__BackingField;
    public Type Type { get; }
    internal TypedFourArgumentsInvocationExpression(Expression expression, Type type, Expression a0, Expression a1, Expression a2, Expression a3);
    [CompilerGeneratedAttribute]
public virtual Type get_Type();
}
public class DryIoc.FastExpressionCompiler.LightExpression.TypedGotoExpression : GotoExpression {
    [CompilerGeneratedAttribute]
private Type <Type>k__BackingField;
    public Type Type { get; }
    internal TypedGotoExpression(LabelTarget target, Type type);
    [CompilerGeneratedAttribute]
public virtual Type get_Type();
}
public class DryIoc.FastExpressionCompiler.LightExpression.TypedInvocationExpression : NotNullExpressionInvocationExpression {
    [CompilerGeneratedAttribute]
private Type <Type>k__BackingField;
    public Type Type { get; }
    internal TypedInvocationExpression(Expression expression, Type type);
    [CompilerGeneratedAttribute]
public virtual Type get_Type();
}
public class DryIoc.FastExpressionCompiler.LightExpression.TypedLabelTarget : LabelTarget {
    [CompilerGeneratedAttribute]
private Type <Type>k__BackingField;
    public Type Type { get; }
    public TypedLabelTarget(Type type);
    [CompilerGeneratedAttribute]
public virtual Type get_Type();
}
public class DryIoc.FastExpressionCompiler.LightExpression.TypedLambdaExpression : LambdaExpression {
    [CompilerGeneratedAttribute]
private Type <Type>k__BackingField;
    public Type Type { get; }
    internal TypedLambdaExpression(Type delegateType, Expression body);
    [CompilerGeneratedAttribute]
public sealed virtual Type get_Type();
}
public class DryIoc.FastExpressionCompiler.LightExpression.TypedManyArgumentsInvocationExpression : ManyArgumentsInvocationExpression {
    [CompilerGeneratedAttribute]
private Type <Type>k__BackingField;
    public Type Type { get; }
    internal TypedManyArgumentsInvocationExpression(Expression expression, IReadOnlyList`1<Expression> arguments, Type type);
    [CompilerGeneratedAttribute]
public virtual Type get_Type();
}
public class DryIoc.FastExpressionCompiler.LightExpression.TypedManyVariablesBlockExpression : ManyVariablesBlockExpression {
    [CompilerGeneratedAttribute]
private Type <Type>k__BackingField;
    public Type Type { get; }
    internal TypedManyVariablesBlockExpression(Type type, IReadOnlyList`1<ParameterExpression> variables, IReadOnlyList`1<Expression> expressions);
    [CompilerGeneratedAttribute]
public virtual Type get_Type();
}
public class DryIoc.FastExpressionCompiler.LightExpression.TypedNamedLabelTarget : NamedLabelTarget {
    [CompilerGeneratedAttribute]
private Type <Type>k__BackingField;
    public Type Type { get; }
    public TypedNamedLabelTarget(Type type, string name);
    [CompilerGeneratedAttribute]
public virtual Type get_Type();
}
public class DryIoc.FastExpressionCompiler.LightExpression.TypedNullConstantExpression : ConstantExpression {
    [CompilerGeneratedAttribute]
private Type <Type>k__BackingField;
    public Type Type { get; }
    public object Value { get; }
    internal TypedNullConstantExpression(Type type);
    [CompilerGeneratedAttribute]
public virtual Type get_Type();
    public virtual object get_Value();
}
public class DryIoc.FastExpressionCompiler.LightExpression.TypedOneArgumentInvocationExpression : OneArgumentInvocationExpression {
    [CompilerGeneratedAttribute]
private Type <Type>k__BackingField;
    public Type Type { get; }
    internal TypedOneArgumentInvocationExpression(Expression expression, Type type, Expression argument);
    [CompilerGeneratedAttribute]
public virtual Type get_Type();
}
public class DryIoc.FastExpressionCompiler.LightExpression.TypedParameterExpression : ParameterExpression {
    [CompilerGeneratedAttribute]
private Type <Type>k__BackingField;
    public Type Type { get; }
    internal TypedParameterExpression(Type type, string name);
    [CompilerGeneratedAttribute]
public virtual Type get_Type();
}
public class DryIoc.FastExpressionCompiler.LightExpression.TypedParameterExpression`1 : ParameterExpression {
    public Type Type { get; }
    internal TypedParameterExpression`1(string name);
    public virtual Type get_Type();
}
public class DryIoc.FastExpressionCompiler.LightExpression.TypedReturnExpression`1 : Expression`1<TDelegate> {
    [CompilerGeneratedAttribute]
private Type <ReturnType>k__BackingField;
    public Type ReturnType { get; }
    internal TypedReturnExpression`1(Expression body, Type returnType);
    [CompilerGeneratedAttribute]
public virtual Type get_ReturnType();
}
public class DryIoc.FastExpressionCompiler.LightExpression.TypedReturnFiveParametersExpression`1 : FiveParametersExpression`1<TDelegate> {
    [CompilerGeneratedAttribute]
private Type <ReturnType>k__BackingField;
    public Type ReturnType { get; }
    internal TypedReturnFiveParametersExpression`1(Expression body, ParameterExpression p0, ParameterExpression p1, ParameterExpression p2, ParameterExpression p3, ParameterExpression p4, Type returnType);
    [CompilerGeneratedAttribute]
public virtual Type get_ReturnType();
}
public class DryIoc.FastExpressionCompiler.LightExpression.TypedReturnFiveParametersLambdaExpression : FiveParametersLambdaExpression {
    [CompilerGeneratedAttribute]
private Type <ReturnType>k__BackingField;
    public Type ReturnType { get; }
    internal TypedReturnFiveParametersLambdaExpression(Type delegateType, Expression body, ParameterExpression p0, ParameterExpression p1, ParameterExpression p2, ParameterExpression p3, ParameterExpression p4, Type returnType);
    [CompilerGeneratedAttribute]
public virtual Type get_ReturnType();
}
public class DryIoc.FastExpressionCompiler.LightExpression.TypedReturnFourParametersExpression`1 : FourParametersExpression`1<TDelegate> {
    [CompilerGeneratedAttribute]
private Type <ReturnType>k__BackingField;
    public Type ReturnType { get; }
    internal TypedReturnFourParametersExpression`1(Expression body, ParameterExpression p0, ParameterExpression p1, ParameterExpression p2, ParameterExpression p3, Type returnType);
    [CompilerGeneratedAttribute]
public virtual Type get_ReturnType();
}
public class DryIoc.FastExpressionCompiler.LightExpression.TypedReturnFourParametersLambdaExpression : FourParametersLambdaExpression {
    [CompilerGeneratedAttribute]
private Type <ReturnType>k__BackingField;
    public Type ReturnType { get; }
    internal TypedReturnFourParametersLambdaExpression(Type delegateType, Expression body, ParameterExpression p0, ParameterExpression p1, ParameterExpression p2, ParameterExpression p3, Type returnType);
    [CompilerGeneratedAttribute]
public virtual Type get_ReturnType();
}
public class DryIoc.FastExpressionCompiler.LightExpression.TypedReturnLambdaExpression : TypedLambdaExpression {
    [CompilerGeneratedAttribute]
private Type <ReturnType>k__BackingField;
    public Type ReturnType { get; }
    internal TypedReturnLambdaExpression(Type delegateType, Expression body, Type returnType);
    [CompilerGeneratedAttribute]
public virtual Type get_ReturnType();
}
public class DryIoc.FastExpressionCompiler.LightExpression.TypedReturnManyParametersExpression`1 : ManyParametersExpression`1<TDelegate> {
    [CompilerGeneratedAttribute]
private Type <ReturnType>k__BackingField;
    public Type ReturnType { get; }
    internal TypedReturnManyParametersExpression`1(Expression body, IReadOnlyList`1<ParameterExpression> parameters, Type returnType);
    [CompilerGeneratedAttribute]
public virtual Type get_ReturnType();
}
public class DryIoc.FastExpressionCompiler.LightExpression.TypedReturnManyParametersLambdaExpression : ManyParametersLambdaExpression {
    [CompilerGeneratedAttribute]
private Type <ReturnType>k__BackingField;
    public Type ReturnType { get; }
    internal TypedReturnManyParametersLambdaExpression(Type delegateType, Expression body, IReadOnlyList`1<ParameterExpression> parameters, Type returnType);
    [CompilerGeneratedAttribute]
public virtual Type get_ReturnType();
}
public class DryIoc.FastExpressionCompiler.LightExpression.TypedReturnOneParameterExpression`1 : OneParameterExpression`1<TDelegate> {
    [CompilerGeneratedAttribute]
private Type <ReturnType>k__BackingField;
    public Type ReturnType { get; }
    internal TypedReturnOneParameterExpression`1(Expression body, ParameterExpression p0, Type returnType);
    [CompilerGeneratedAttribute]
public virtual Type get_ReturnType();
}
public class DryIoc.FastExpressionCompiler.LightExpression.TypedReturnOneParameterLambdaExpression : OneParameterLambdaExpression {
    [CompilerGeneratedAttribute]
private Type <ReturnType>k__BackingField;
    public Type ReturnType { get; }
    internal TypedReturnOneParameterLambdaExpression(Type delegateType, Expression body, ParameterExpression parameter, Type returnType);
    [CompilerGeneratedAttribute]
public virtual Type get_ReturnType();
}
public class DryIoc.FastExpressionCompiler.LightExpression.TypedReturnSixParametersExpression`1 : SixParametersExpression`1<TDelegate> {
    [CompilerGeneratedAttribute]
private Type <ReturnType>k__BackingField;
    public Type ReturnType { get; }
    internal TypedReturnSixParametersExpression`1(Expression body, ParameterExpression p0, ParameterExpression p1, ParameterExpression p2, ParameterExpression p3, ParameterExpression p4, ParameterExpression p5, Type returnType);
    [CompilerGeneratedAttribute]
public virtual Type get_ReturnType();
}
public class DryIoc.FastExpressionCompiler.LightExpression.TypedReturnSixParametersLambdaExpression : SixParametersLambdaExpression {
    [CompilerGeneratedAttribute]
private Type <ReturnType>k__BackingField;
    public Type ReturnType { get; }
    internal TypedReturnSixParametersLambdaExpression(Type delegateType, Expression body, ParameterExpression p0, ParameterExpression p1, ParameterExpression p2, ParameterExpression p3, ParameterExpression p4, ParameterExpression p5, Type returnType);
    [CompilerGeneratedAttribute]
public virtual Type get_ReturnType();
}
public class DryIoc.FastExpressionCompiler.LightExpression.TypedReturnThreeParametersExpression`1 : ThreeParametersExpression`1<TDelegate> {
    [CompilerGeneratedAttribute]
private Type <ReturnType>k__BackingField;
    public Type ReturnType { get; }
    internal TypedReturnThreeParametersExpression`1(Expression body, ParameterExpression p0, ParameterExpression p1, ParameterExpression p2, Type returnType);
    [CompilerGeneratedAttribute]
public virtual Type get_ReturnType();
}
public class DryIoc.FastExpressionCompiler.LightExpression.TypedReturnThreeParametersLambdaExpression : ThreeParametersLambdaExpression {
    [CompilerGeneratedAttribute]
private Type <ReturnType>k__BackingField;
    public Type ReturnType { get; }
    internal TypedReturnThreeParametersLambdaExpression(Type delegateType, Expression body, ParameterExpression p0, ParameterExpression p1, ParameterExpression p2, Type returnType);
    [CompilerGeneratedAttribute]
public virtual Type get_ReturnType();
}
public class DryIoc.FastExpressionCompiler.LightExpression.TypedReturnTwoParametersExpression`1 : TwoParametersExpression`1<TDelegate> {
    [CompilerGeneratedAttribute]
private Type <ReturnType>k__BackingField;
    public Type ReturnType { get; }
    internal TypedReturnTwoParametersExpression`1(Expression body, ParameterExpression p0, ParameterExpression p1, Type returnType);
    [CompilerGeneratedAttribute]
public virtual Type get_ReturnType();
}
public class DryIoc.FastExpressionCompiler.LightExpression.TypedReturnTwoParametersLambdaExpression : TwoParametersLambdaExpression {
    [CompilerGeneratedAttribute]
private Type <ReturnType>k__BackingField;
    public Type ReturnType { get; }
    internal TypedReturnTwoParametersLambdaExpression(Type delegateType, Expression body, ParameterExpression p0, ParameterExpression p1, Type returnType);
    [CompilerGeneratedAttribute]
public virtual Type get_ReturnType();
}
public class DryIoc.FastExpressionCompiler.LightExpression.TypedSixArgumentsInvocationExpression : SixArgumentsInvocationExpression {
    [CompilerGeneratedAttribute]
private Type <Type>k__BackingField;
    public Type Type { get; }
    internal TypedSixArgumentsInvocationExpression(Expression expression, Type type, Expression a0, Expression a1, Expression a2, Expression a3, Expression a4, Expression a5);
    [CompilerGeneratedAttribute]
public virtual Type get_Type();
}
public class DryIoc.FastExpressionCompiler.LightExpression.TypedThreeArgumentsInvocationExpression : ThreeArgumentsInvocationExpression {
    [CompilerGeneratedAttribute]
private Type <Type>k__BackingField;
    public Type Type { get; }
    internal TypedThreeArgumentsInvocationExpression(Expression expression, Type type, Expression a0, Expression a1, Expression a2);
    [CompilerGeneratedAttribute]
public virtual Type get_Type();
}
public class DryIoc.FastExpressionCompiler.LightExpression.TypedTwoArgumentsInvocationExpression : TwoArgumentsInvocationExpression {
    [CompilerGeneratedAttribute]
private Type <Type>k__BackingField;
    public Type Type { get; }
    internal TypedTwoArgumentsInvocationExpression(Expression expression, Type type, Expression a0, Expression a1);
    [CompilerGeneratedAttribute]
public virtual Type get_Type();
}
public class DryIoc.FastExpressionCompiler.LightExpression.TypedUnaryExpression : UnaryExpression {
    [CompilerGeneratedAttribute]
private ExpressionType <NodeType>k__BackingField;
    [CompilerGeneratedAttribute]
private Type <Type>k__BackingField;
    public ExpressionType NodeType { get; }
    public Type Type { get; }
    public TypedUnaryExpression(ExpressionType nodeType, Expression operand, Type type);
    [CompilerGeneratedAttribute]
public virtual ExpressionType get_NodeType();
    [CompilerGeneratedAttribute]
public sealed virtual Type get_Type();
}
public class DryIoc.FastExpressionCompiler.LightExpression.TypedUnaryExpression`1 : UnaryExpression {
    [CompilerGeneratedAttribute]
private ExpressionType <NodeType>k__BackingField;
    public ExpressionType NodeType { get; }
    public Type Type { get; }
    public TypedUnaryExpression`1(ExpressionType nodeType, Expression operand);
    [CompilerGeneratedAttribute]
public virtual ExpressionType get_NodeType();
    public virtual Type get_Type();
}
public class DryIoc.FastExpressionCompiler.LightExpression.TypedValueConstantExpression : ConstantExpression {
    [CompilerGeneratedAttribute]
private Type <Type>k__BackingField;
    [CompilerGeneratedAttribute]
private object <Value>k__BackingField;
    public Type Type { get; }
    public object Value { get; }
    internal TypedValueConstantExpression(object value, Type type);
    [CompilerGeneratedAttribute]
public virtual Type get_Type();
    [CompilerGeneratedAttribute]
public virtual object get_Value();
}
public class DryIoc.FastExpressionCompiler.LightExpression.TypedValueGotoExpression : ValueGotoExpression {
    [CompilerGeneratedAttribute]
private Type <Type>k__BackingField;
    public Type Type { get; }
    internal TypedValueGotoExpression(LabelTarget target, Expression value, Type type);
    [CompilerGeneratedAttribute]
public virtual Type get_Type();
}
public class DryIoc.FastExpressionCompiler.LightExpression.TypedWithFalseBranchConditionalExpression : VoidWithFalseBranchConditionalExpression {
    [CompilerGeneratedAttribute]
private Type <Type>k__BackingField;
    public Type Type { get; }
    internal TypedWithFalseBranchConditionalExpression(Expression test, Expression ifTrue, Expression ifFalse, Type type);
    [CompilerGeneratedAttribute]
public virtual Type get_Type();
}
[ExtensionAttribute]
internal static class DryIoc.FastExpressionCompiler.LightExpression.TypeTools : object {
    internal static BindingFlags InstanceMethods;
    internal static BindingFlags StaticMethods;
    [ExtensionAttribute]
internal static Type GetNonRef(Type type);
    [ExtensionAttribute]
internal static bool IsAssignableFrom(ParameterInfo p, Type argType);
    [ExtensionAttribute]
public static Type GetNonNullable(Type type);
    [ExtensionAttribute]
public static Type GetNonNullableOrSelf(Type type);
    [ExtensionAttribute]
public static Type GetNullable(Type type);
    [ExtensionAttribute]
public static bool IsArithmetic(Type type);
    [ExtensionAttribute]
public static bool IsNumeric(Type type);
    [ExtensionAttribute]
internal static bool IsImplicitlyBoxingConvertibleTo(Type source, Type target);
    [ExtensionAttribute]
internal static PropertyInfo FindProperty(Type type, string propertyName);
    [ExtensionAttribute]
internal static FieldInfo FindField(Type type, string fieldName);
    [ExtensionAttribute]
internal static MethodInfo MatchesArgumentTypes(MethodInfo m, Type[] argTypes);
    [ExtensionAttribute]
internal static MethodInfo FindMethodOrThrow(Type type, string methodName, Type[] typeArgs, IReadOnlyList`1<Expression> argExprs, BindingFlags flags);
    private static int GetScopeOfExpressionsAssignableToParams(IReadOnlyList`1<Expression> argExprs, ParameterInfo[] pars);
    [ExtensionAttribute]
public static IReadOnlyList`1<T> AsReadOnlyList(IEnumerable`1<T> xs);
    [ExtensionAttribute]
internal static bool IsImplicitlyNumericConvertibleTo(Type source, Type target);
}
public abstract class DryIoc.FastExpressionCompiler.LightExpression.UnaryExpression : Expression {
    public Expression Operand;
    public Type Type { get; }
    public MethodInfo Method { get; }
    public UnaryExpression(Expression operand);
    public virtual Type get_Type();
    public virtual MethodInfo get_Method();
    internal virtual Expression CreateSysExpression(LiveCountArray`1& exprsConverted);
}
public class DryIoc.FastExpressionCompiler.LightExpression.ValueConstantExpression : ConstantExpression {
    [CompilerGeneratedAttribute]
private object <Value>k__BackingField;
    public Type Type { get; }
    public object Value { get; }
    internal ValueConstantExpression(object value);
    public virtual Type get_Type();
    [CompilerGeneratedAttribute]
public virtual object get_Value();
}
public class DryIoc.FastExpressionCompiler.LightExpression.ValueConstantExpression`1 : ConstantExpression {
    [CompilerGeneratedAttribute]
private object <Value>k__BackingField;
    public Type Type { get; }
    public object Value { get; }
    internal ValueConstantExpression`1(object value);
    public virtual Type get_Type();
    [CompilerGeneratedAttribute]
public virtual object get_Value();
}
public class DryIoc.FastExpressionCompiler.LightExpression.ValueGotoExpression : GotoExpression {
    [CompilerGeneratedAttribute]
private Expression <Value>k__BackingField;
    public Type Type { get; }
    public Expression Value { get; }
    internal ValueGotoExpression(LabelTarget target, Expression value);
    public virtual Type get_Type();
    [CompilerGeneratedAttribute]
public virtual Expression get_Value();
}
public class DryIoc.FastExpressionCompiler.LightExpression.VoidWithFalseBranchConditionalExpression : ConditionalExpression {
    [CompilerGeneratedAttribute]
private Expression <IfFalse>k__BackingField;
    public Expression IfFalse { get; }
    internal VoidWithFalseBranchConditionalExpression(Expression test, Expression ifTrue, Expression ifFalse);
    [CompilerGeneratedAttribute]
public virtual Expression get_IfFalse();
}
public class DryIoc.FastExpressionCompiler.LightExpression.WithComparisonSwitchExpression : SwitchExpression {
    [CompilerGeneratedAttribute]
private MethodInfo <Comparison>k__BackingField;
    public MethodInfo Comparison { get; }
    public WithComparisonSwitchExpression(Type type, Expression switchValue, Expression defaultBody, SwitchCase[] cases, MethodInfo comparison);
    [CompilerGeneratedAttribute]
public virtual MethodInfo get_Comparison();
}
public class DryIoc.FastExpressionCompiler.LightExpression.WithDefaultValueLabelExpression : LabelExpression {
    [CompilerGeneratedAttribute]
private Expression <DefaultValue>k__BackingField;
    public Expression DefaultValue { get; }
    internal WithDefaultValueLabelExpression(LabelTarget target, Expression defaultValue);
    [CompilerGeneratedAttribute]
public virtual Expression get_DefaultValue();
}
public class DryIoc.FastExpressionCompiler.LightExpression.WithFalseBranchConditionalExpression : VoidWithFalseBranchConditionalExpression {
    public Type Type { get; }
    internal WithFalseBranchConditionalExpression(Expression test, Expression ifTrue, Expression ifFalse);
    public virtual Type get_Type();
}
public class DryIoc.FastExpressionCompiler.LightExpression.WithFinallyTryExpression : TryExpression {
    [CompilerGeneratedAttribute]
private Expression <Finally>k__BackingField;
    public Expression Finally { get; }
    internal WithFinallyTryExpression(Expression body, CatchBlock[] handlers, Expression finally);
    [CompilerGeneratedAttribute]
public virtual Expression get_Finally();
}
internal class DryIoc.FuncInvoke0Expression : NotNullMethodCallExpression {
    public Delegate Func;
    public Expression Object { get; }
    public bool IsIntrinsic { get; }
    internal FuncInvoke0Expression(Delegate f, MethodInfo m);
    public virtual Expression get_Object();
    public virtual bool get_IsIntrinsic();
    public virtual bool TryCollectBoundConstants(CompilerFlags config, ClosureInfo& closure, IParameterProvider paramExprs, bool isNestedLambda, ClosureInfo& rootClosure);
    public virtual bool TryEmit(CompilerFlags config, ClosureInfo& closure, IParameterProvider paramExprs, ILGenerator il, ParentFlags parent, int byRefIndex);
}
internal class DryIoc.FuncInvoke1Expression : OneArgumentMethodCallExpression {
    public Delegate Func;
    public Expression Object { get; }
    public bool IsIntrinsic { get; }
    internal FuncInvoke1Expression(Delegate f, MethodInfo m, object a0);
    public virtual Expression get_Object();
    public virtual bool get_IsIntrinsic();
    public virtual bool TryCollectBoundConstants(CompilerFlags config, ClosureInfo& closure, IParameterProvider paramExprs, bool isNestedLambda, ClosureInfo& rootClosure);
    public virtual bool TryEmit(CompilerFlags config, ClosureInfo& closure, IParameterProvider paramExprs, ILGenerator il, ParentFlags parent, int byRefIndex);
}
internal class DryIoc.FuncInvoke2Expression : TwoArgumentsMethodCallExpression {
    public Delegate Func;
    public Expression Object { get; }
    public bool IsIntrinsic { get; }
    internal FuncInvoke2Expression(Delegate f, MethodInfo m, object a0, object a1);
    public virtual Expression get_Object();
    public virtual bool get_IsIntrinsic();
    public virtual bool TryCollectBoundConstants(CompilerFlags config, ClosureInfo& closure, IParameterProvider paramExprs, bool isNestedLambda, ClosureInfo& rootClosure);
    public virtual bool TryEmit(CompilerFlags config, ClosureInfo& closure, IParameterProvider paramExprs, ILGenerator il, ParentFlags parent, int byRefIndex);
}
internal class DryIoc.FuncInvoke3Expression : ThreeArgumentsMethodCallExpression {
    public Delegate Func;
    public Expression Object { get; }
    public bool IsIntrinsic { get; }
    internal FuncInvoke3Expression(Delegate f, MethodInfo m, object a0, object a1, object a2);
    public virtual Expression get_Object();
    public virtual bool get_IsIntrinsic();
    public virtual bool TryCollectBoundConstants(CompilerFlags config, ClosureInfo& closure, IParameterProvider paramExprs, bool isNestedLambda, ClosureInfo& rootClosure);
    public virtual bool TryEmit(CompilerFlags config, ClosureInfo& closure, IParameterProvider paramExprs, ILGenerator il, ParentFlags parent, int byRefIndex);
}
internal class DryIoc.FuncInvoke4Expression : FourArgumentsMethodCallExpression {
    public Delegate Func;
    public Expression Object { get; }
    public bool IsIntrinsic { get; }
    internal FuncInvoke4Expression(Delegate f, MethodInfo m, object a0, object a1, object a2, object a3);
    public virtual Expression get_Object();
    public virtual bool get_IsIntrinsic();
    public virtual bool TryCollectBoundConstants(CompilerFlags config, ClosureInfo& closure, IParameterProvider paramExprs, bool isNestedLambda, ClosureInfo& rootClosure);
    public virtual bool TryEmit(CompilerFlags config, ClosureInfo& closure, IParameterProvider paramExprs, ILGenerator il, ParentFlags parent, int byRefIndex);
}
internal class DryIoc.FuncInvoke5Expression : FiveArgumentsMethodCallExpression {
    public Delegate Func;
    public Expression Object { get; }
    public bool IsIntrinsic { get; }
    internal FuncInvoke5Expression(Delegate f, MethodInfo m, object a0, object a1, object a2, object a3, object a4);
    public virtual Expression get_Object();
    public virtual bool get_IsIntrinsic();
    public virtual bool TryCollectBoundConstants(CompilerFlags config, ClosureInfo& closure, IParameterProvider paramExprs, bool isNestedLambda, ClosureInfo& rootClosure);
    public virtual bool TryEmit(CompilerFlags config, ClosureInfo& closure, IParameterProvider paramExprs, ILGenerator il, ParentFlags parent, int byRefIndex);
}
internal class DryIoc.FuncInvoke6Expression : SixArgumentsMethodCallExpression {
    public Delegate Func;
    public Expression Object { get; }
    public bool IsIntrinsic { get; }
    internal FuncInvoke6Expression(Delegate f, MethodInfo m, object a0, object a1, object a2, object a3, object a4, object a5);
    public virtual Expression get_Object();
    public virtual bool get_IsIntrinsic();
    public virtual bool TryCollectBoundConstants(CompilerFlags config, ClosureInfo& closure, IParameterProvider paramExprs, bool isNestedLambda, ClosureInfo& rootClosure);
    public virtual bool TryEmit(CompilerFlags config, ClosureInfo& closure, IParameterProvider paramExprs, ILGenerator il, ParentFlags parent, int byRefIndex);
}
internal class DryIoc.FuncInvoke7Expression : SevenArgumentsMethodCallExpression {
    public Delegate Func;
    public Expression Object { get; }
    public bool IsIntrinsic { get; }
    internal FuncInvoke7Expression(Delegate f, MethodInfo m, object a0, object a1, object a2, object a3, object a4, object a5, object a6);
    public virtual Expression get_Object();
    public virtual bool get_IsIntrinsic();
    public virtual bool TryCollectBoundConstants(CompilerFlags config, ClosureInfo& closure, IParameterProvider paramExprs, bool isNestedLambda, ClosureInfo& rootClosure);
    public virtual bool TryEmit(CompilerFlags config, ClosureInfo& closure, IParameterProvider paramExprs, ILGenerator il, ParentFlags parent, int byRefIndex);
}
public class DryIoc.GeneratedExpressions : object {
    public List`1<KeyValuePair`2<ServiceInfo, Expression`1<Func`2<IResolverContext, object>>>> Roots;
    public List`1<KeyValuePair`2<Request, Expression>> ResolveDependencies;
    public List`1<KeyValuePair`2<ServiceInfo, ContainerException>> Errors;
}
public class DryIoc.HiddenDisposable : object {
    internal static ConstructorInfo Ctor;
    internal static FieldInfo ValueField;
    public object Value;
    public HiddenDisposable(object value);
    private static HiddenDisposable();
}
public interface DryIoc.ICompileTimeContainer {
    public abstract virtual bool IsRegistered(Type serviceType);
    public abstract virtual bool IsRegistered(Type serviceType, object serviceKey);
    public abstract virtual bool TryResolve(Object& service, IResolverContext r, Type serviceType);
    public abstract virtual bool TryResolve(Object& service, IResolverContext r, Type serviceType, object serviceKey, Type requiredServiceType, Request preRequestParent, Object[] args);
    public abstract virtual IEnumerable`1<ResolveManyResult> ResolveMany(IResolverContext r, Type serviceType);
}
public interface DryIoc.IContainer {
    public Rules Rules { get; }
    public abstract virtual Rules get_Rules();
    public abstract virtual IContainer With(IResolverContext parent, Rules rules, IScopeContext scopeContext, RegistrySharing registrySharing, IScope singletonScope, IScope currentScope, Nullable`1<IsRegistryChangePermitted> isRegistryChangePermitted);
    public abstract virtual KeyValuePair`2[] Validate(IEnumerable`1<ServiceInfo> roots);
    public abstract virtual GeneratedExpressions GenerateResolutionExpressions(Func`2<IEnumerable`1<ServiceRegistrationInfo>, IEnumerable`1<ServiceInfo>> getRoots, bool allowRuntimeState);
    public abstract virtual Factory ResolveFactory(Request request);
    public abstract virtual Factory ResolveFactory(ServiceInfo serviceInfo);
    public abstract virtual Expression ResolveExpression(ServiceInfo serviceInfo);
    public abstract virtual Factory GetServiceFactoryOrDefault(Request request);
    public abstract virtual KV`2[] GetAllServiceFactoriesPlusForOpenGeneric(Type serviceType);
    public abstract virtual KV`2[] GetAllServiceFactories(Type serviceType);
    public abstract virtual Factory GetWrapperFactoryOrDefault(Type serviceType);
    public abstract virtual bool IsWrapper(Type serviceType, Type openGenericServiceType);
    public abstract virtual Factory[] GetDecoratorFactoriesOrDefault(Type serviceType);
    public abstract virtual Factory[] GetDecoratorFactoriesOrDefault(int serviceTypeHash, Type serviceType);
    public abstract virtual Expression GetDecoratorExpressionOrDefault(Request request);
    public abstract virtual Type GetWrappedType(Type serviceType, Type requiredServiceType);
    public abstract virtual Type GetWrappedType(Type serviceType);
    public abstract virtual Expression GetConstantExpression(object item, Type itemType, bool throwIfStateRequired);
    public abstract virtual bool ClearCache(Type serviceType, Nullable`1<FactoryType> factoryType, object serviceKey);
    public abstract virtual void Use(Type serviceType, object instance);
}
public interface DryIoc.IConvertibleToExpression {
    public abstract virtual Expression ToExpression(S state, Func`3<S, object, Expression> fallbackConverter);
}
public enum DryIoc.IfAlreadyRegistered : Enum {
    public byte value__;
    public static IfAlreadyRegistered AppendNotKeyed;
    public static IfAlreadyRegistered Throw;
    public static IfAlreadyRegistered Keep;
    public static IfAlreadyRegistered Replace;
    public static IfAlreadyRegistered AppendNewImplementation;
}
internal interface DryIoc.IFuncInvokeExpression {
}
public enum DryIoc.IfUnresolved : Enum {
    public byte value__;
    public static IfUnresolved Throw;
    public static IfUnresolved ReturnDefault;
    public static IfUnresolved ReturnDefaultIfNotRegistered;
}
[ExtensionAttribute]
public static class DryIoc.ImTools.ArrayTools : object {
    public static T[] Empty();
    [ExtensionAttribute]
public static T[] One(T one);
    [ExtensionAttribute]
public static bool IsNullOrEmpty(T[] source);
    [ExtensionAttribute]
public static T[] EmptyIfNull(T[] source);
    [ExtensionAttribute]
public static T[] ToArrayOrSelf(IEnumerable`1<T> source);
    [ExtensionAttribute]
public static IList`1<T> ToListOrSelf(IEnumerable`1<T> source);
    [ExtensionAttribute]
public static T[] Copy(T[] source);
    [ExtensionAttribute]
public static T[] CopyNonEmpty(T[] source);
    [ExtensionAttribute]
public static T[] Append(T[] source, T[] added);
    [ExtensionAttribute]
public static T[] Append(IEnumerable`1<T> source, IEnumerable`1<T> other);
    [ExtensionAttribute]
public static T[] AppendOrUpdate(T[] source, T value, int index);
    [ExtensionAttribute]
public static T[] UpdateNonEmpty(T[] source, T value, int index);
    [ExtensionAttribute]
public static T[] AppendNonEmpty(T[] source, T[] added);
    [ExtensionAttribute]
public static T[] Append(T[] source, T value);
    [ExtensionAttribute]
public static T[] AppendToNonEmpty(T[] source, T value);
    [ExtensionAttribute]
public static T[] PrependToNonEmpty(T[] source, T value);
    [ExtensionAttribute]
public static int IndexOf(T[] source, Func`2<T, bool> predicate);
    [ExtensionAttribute]
public static int IndexOf(T[] source, S state, Func`3<S, T, bool> predicate);
    [ExtensionAttribute]
public static int IndexOf(T[] source, T value);
    [ExtensionAttribute]
public static int IndexOfReference(T[] source, T reference);
    [ExtensionAttribute]
public static T[] RemoveAtSurePresent(T[] source, int index);
    [ExtensionAttribute]
public static T[] RemoveAt(T[] source, int index);
    [ExtensionAttribute]
public static T[] Remove(T[] source, T value);
    [ExtensionAttribute]
public static T FindFirst(T[] source, Func`2<T, bool> predicate);
    [ExtensionAttribute]
public static T FindFirst(T[] source, S state, Func`3<S, T, bool> predicate);
    [ExtensionAttribute]
public static T FindFirst(IEnumerable`1<T> source, Func`2<T, bool> predicate);
    [ExtensionAttribute]
public static T FirstOrDefault(IEnumerable`1<T> source, S state, Func`3<S, T, bool> condition);
    [ExtensionAttribute]
public static T FindFirst(IEnumerable`1<T> source, S state, Func`3<S, T, bool> predicate);
    [ExtensionAttribute]
public static T FindLast(T[] source, Func`2<T, bool> predicate);
    [ExtensionAttribute]
public static T FindLast(T[] source, S state, Func`3<S, T, bool> predicate);
    [ExtensionAttribute]
public static T FindSingle(IEnumerable`1<T> source);
    [ExtensionAttribute]
public static T FindFirstSingle(T[] source, Int32& nextFoundIndex, Func`2<T, bool> condition);
    [ExtensionAttribute]
public static T FindFirstSingle(T[] source, Int32& nextFoundIndex, S state, Func`3<S, T, bool> condition);
    [ExtensionAttribute]
public static void ForEach(T[] source, Action`1<T> action);
    [ExtensionAttribute]
public static T[] Copy(T[] source, int sourcePos, int count);
    [ExtensionAttribute]
private static R[] Copy(T[] source, int sourcePos, int count, Func`2<T, R> map);
    [ExtensionAttribute]
private static R[] Copy(T[] source, S state, int sourcePos, int count, Func`3<S, T, R> map);
    [ExtensionAttribute]
private static R[] Copy(T[] source, S& state, int sourcePos, int count, MapOp`3<S, T, R> map);
    [ExtensionAttribute]
private static R[] Copy(T[] source, A a, B b, int sourcePos, int count, Func`4<A, B, T, R> map);
    [ExtensionAttribute]
public static T[] AppendTo(T[] source, T[] results, int sourcePos, int count);
    [ExtensionAttribute]
private static R[] AppendTo(T[] source, R[] results, int sourcePos, int count, Func`2<T, R> map);
    [ExtensionAttribute]
private static R[] AppendTo(T[] source, S state, R[] results, int sourcePos, int count, Func`3<S, T, R> map);
    [ExtensionAttribute]
private static R[] AppendTo(T[] source, S& state, R[] results, int sourcePos, int count, MapOp`3<S, T, R> map);
    [ExtensionAttribute]
private static R[] AppendTo(T[] source, A a, B b, R[] results, int sourcePos, int count, Func`4<A, B, T, R> map);
    [ExtensionAttribute]
public static T[] Match(T[] source, Func`2<T, bool> condition);
    [ExtensionAttribute]
public static T[] Match(T[] source, S state, Func`3<S, T, bool> condition);
    [ExtensionAttribute]
public static T[] Match(T[] source, A a, B b, Func`4<A, B, T, bool> condition);
    [ExtensionAttribute]
public static R[] Match(T[] source, Func`2<T, bool> condition, Func`2<T, R> map);
    [ExtensionAttribute]
public static R[] Match(T[] source, S state, Func`3<S, T, bool> condition, Func`3<S, T, R> map);
    [ExtensionAttribute]
public static R[] Match(T[] source, S& state, IsOp`2<S, T> condition, MapOp`3<S, T, R> map);
    [ExtensionAttribute]
public static R[] Match(T[] source, A a, B b, Func`4<A, B, T, bool> condition, Func`4<A, B, T, R> map);
    [ExtensionAttribute]
public static R[] Map(T[] source, Func`2<T, R> map);
    [ExtensionAttribute]
public static R[] Map(T[] source, S state, Func`3<S, T, R> map);
    [ExtensionAttribute]
public static R[] Map(T[] source, S& state, MapOp`3<S, T, R> map);
    [ExtensionAttribute]
public static R[] Map(T[] source, A a, B b, Func`4<A, B, T, R> map);
    [ExtensionAttribute]
public static IEnumerable`1<R> Map(IEnumerable`1<T> source, Func`2<T, R> map);
    [ExtensionAttribute]
public static IEnumerable`1<T> Match(IEnumerable`1<T> source, Func`2<T, bool> condition);
    [ExtensionAttribute]
public static IEnumerable`1<T> Match(IEnumerable`1<T> source, S s, Func`3<S, T, bool> condition);
    [IteratorStateMachineAttribute("DryIoc.ImTools.ArrayTools/<Where>d__59`2")]
[ExtensionAttribute]
public static IEnumerable`1<T> Where(IEnumerable`1<T> source, S state, Func`3<S, T, bool> condition);
    [ExtensionAttribute]
public static IEnumerable`1<R> Match(IEnumerable`1<T> source, Func`2<T, bool> condition, Func`2<T, R> map);
    [ExtensionAttribute]
public static IEnumerable`1<R> Match(IEnumerable`1<T> source, S s, Func`3<S, T, bool> condition, Func`3<S, T, R> map);
    [IteratorStateMachineAttribute("DryIoc.ImTools.ArrayTools/<WhereSelect>d__62`3")]
[ExtensionAttribute]
public static IEnumerable`1<R> WhereSelect(IEnumerable`1<T> source, S s, Func`3<S, T, bool> condition, Func`3<S, T, R> map);
    [ExtensionAttribute]
public static IEnumerable`1<R> Match(IEnumerable`1<T> source, A a, B b, Func`4<A, B, T, bool> condition, Func`4<A, B, T, R> map);
    [IteratorStateMachineAttribute("DryIoc.ImTools.ArrayTools/<WhereSelect>d__64`4")]
[ExtensionAttribute]
public static IEnumerable`1<R> WhereSelect(IEnumerable`1<T> source, A a, B b, Func`4<A, B, T, bool> condition, Func`4<A, B, T, R> map);
}
[ExtensionAttribute]
public static class DryIoc.ImTools.Fun : object {
    public static bool Always(T _);
    public static T Id(T x);
    [ExtensionAttribute]
public static R To(T x, Func`2<T, R> map);
    [ExtensionAttribute]
public static R To(T x, S state, Func`3<T, S, R> map);
    [ExtensionAttribute]
public static R To(object x);
    [ExtensionAttribute]
public static T Do(T x, Action`1<T> effect);
    [ExtensionAttribute]
public static T Do(T x, S state, Action`2<T, S> effect);
    [ExtensionAttribute]
public static R ToFunc(R result, T ignoredArg);
    public static void Swap(T& a, T& b);
}
public static class DryIoc.ImTools.GrowingList : object {
    public static int DefaultInitialCapacity;
    public static T& PushSlot(T[]& items, int count);
    public static void Push(T[]& items, int count, T item);
    internal static void Expand(T[]& items);
    public static T[] ResizeToArray(T[] items, int count);
    public static string ToString(T[] items, int count);
}
public class DryIoc.ImTools.GrowingList`1 : ValueType {
    public static int DefaultInitialCapacity;
    public T[] Items;
    public int Count;
    public GrowingList`1(T[] items, int count);
    public T& PushSlot();
    public void Push(T item);
    public void Pop();
    public T[] ResizeToArray();
    public T PopItem();
    public virtual string ToString();
}
public static class DryIoc.ImTools.Hasher : object {
    public static int Combine(T1 a, T2 b);
    public static int Combine(int h1, int h2);
}
[ExtensionAttribute]
public static class DryIoc.ImTools.ImHashMap : object {
    private static object _enumerationB3Tombstone;
    private static ImHashMap();
    [ExtensionAttribute]
public static string ToMermaidString(ImHashMap`2<K, V> map);
    internal static void InsertInOrder(int ph, Entry& p, Entry& e0, Entry& e1);
    internal static void InsertInOrder(int ph, Entry& p, Entry& e0, Entry& e1, Entry& e2);
    internal static void InsertInOrder(int ph, Entry& p, Entry& e0, Entry& e1, Entry& e2, Entry& e3);
    internal static void InsertInOrder(int ph, Entry& p, Entry& e0, Entry& e1, Entry& e2, Entry& e3, Entry& e4);
    internal static void InsertInOrder(int ph, Entry& p, Entry& e0, Entry& e1, Entry& e2, Entry& e3, Entry& e4, Entry& e5);
    internal static void InsertInOrder(int ph, Entry& p, Entry& e0, Entry& e1, Entry& e2, Entry& e3, Entry& e4, Entry& e5, Entry& e6);
    [ExtensionAttribute]
public static Enumerable`1<V> Enumerate(ImHashMap`2<int, V> map);
    [ExtensionAttribute]
public static Enumerable`2<K, V> Enumerate(ImHashMap`2<K, V> map);
    [ExtensionAttribute]
public static S ForEach(ImHashMap`2<K, V> map, S state, Action`3<ImHashMapEntry`2<K, V>, int, S> handler, MapParentStack parents);
    [ExtensionAttribute]
public static S ForEach(ImHashMap`2<int, V> map, S state, Action`3<VEntry`1<V>, int, S> handler, MapParentStack parents);
    [ExtensionAttribute]
public static void ForEach(ImHashMap`2<int, V> map, Action`2<VEntry`1<V>, int> handler, MapParentStack parents);
    [ExtensionAttribute]
public static void ForEach(ImHashMap`2<K, V> map, Action`2<ImHashMapEntry`2<K, V>, int> handler, MapParentStack parents);
    [ExtensionAttribute]
public static S Fold(ImHashMap`2<int, V> map, S state, Func`4<VEntry`1<V>, int, S, S> handler, MapParentStack parents);
    [ExtensionAttribute]
public static S Fold(ImHashMap`2<K, V> map, S state, Func`4<ImHashMapEntry`2<K, V>, int, S, S> handler, MapParentStack parents);
    [ExtensionAttribute]
public static S[] ToArray(ImHashMap`2<int, V> map, Func`2<VEntry`1<V>, S> selector);
    [ExtensionAttribute]
public static S[] ToArray(ImHashMap`2<K, V> map, Func`2<ImHashMapEntry`2<K, V>, S> selector);
    [ExtensionAttribute]
public static VEntry`1[] ToArray(ImHashMap`2<int, V> map);
    [ExtensionAttribute]
public static ImHashMapEntry`2[] ToArray(ImHashMap`2<K, V> map);
    [ExtensionAttribute]
public static Dictionary`2<K, V> ToDictionary(ImHashMap`2<K, V> map);
    [ExtensionAttribute]
public static Dictionary`2<int, V> ToDictionary(ImHashMap`2<int, V> map);
    [ExtensionAttribute]
public static bool Contains(ImHashMap`2<int, V> map, int key);
    [ExtensionAttribute]
public static bool Contains(ImHashMap`2<K, V> map, int hash, K key);
    [ExtensionAttribute]
public static bool Contains(ImHashMap`2<K, V> map, K key);
    [ExtensionAttribute]
public static ImHashMapEntry`2<int, V> GetSurePresent(ImHashMap`2<int, V> map, int hash);
    [ExtensionAttribute]
public static ImHashMapEntry`2<K, V> GetSurePresent(ImHashMap`2<K, V> map, int hash, K key);
    [ExtensionAttribute]
public static ImHashMapEntry`2<K, V> GetSurePresentByReferenceEquals(ImHashMap`2<K, V> map, int hash, K key);
    [ExtensionAttribute]
public static ImHashMapEntry`2<int, V> GetEntryOrDefault(ImHashMap`2<int, V> map, int hash);
    [ExtensionAttribute]
public static ImHashMapEntry`2<K, V> GetEntryOrDefault(ImHashMap`2<K, V> map, int hash, K key);
    [ExtensionAttribute]
public static ImHashMapEntry`2<K, V> GetEntryOrDefault(ImHashMap`2<K, V> map, K key);
    [ExtensionAttribute]
public static ImHashMapEntry`2<K, V> GetEntryOrDefaultByReferenceEquals(ImHashMap`2<K, V> map, int hash, K key);
    [ExtensionAttribute]
public static ImHashMapEntry`2<K, V> GetEntryOrDefaultByReferenceEquals(ImHashMap`2<K, V> map, K key);
    [ExtensionAttribute]
public static V GetValueOrDefault(ImHashMap`2<int, V> map, int hash);
    [ExtensionAttribute]
public static V GetValueOrDefault(ImHashMap`2<int, V> map, int hash, V defaultValue);
    [ExtensionAttribute]
public static V GetValueOrDefault(ImHashMap`2<K, V> map, int hash, K key);
    [ExtensionAttribute]
public static V GetValueOrDefault(ImHashMap`2<K, V> map, int hash, K key, V defaultValue);
    [ExtensionAttribute]
public static V GetValueOrDefault(ImHashMap`2<K, V> map, K key);
    [ExtensionAttribute]
public static V GetValueOrDefault(ImHashMap`2<K, V> map, K key, V defaultValue);
    [ExtensionAttribute]
public static V GetValueOrDefaultByReferenceEquals(ImHashMap`2<K, V> map, int hash, K key);
    [ExtensionAttribute]
public static V GetValueOrDefaultByReferenceEquals(ImHashMap`2<K, V> map, K key);
    [ExtensionAttribute]
public static bool TryFind(ImHashMap`2<int, V> map, int hash, V& value);
    [ExtensionAttribute]
public static bool TryFind(ImHashMap`2<K, V> map, int hash, K key, V& value);
    [ExtensionAttribute]
public static bool TryFind(ImHashMap`2<K, V> map, K key, V& value);
    [ExtensionAttribute]
public static bool TryFindByReferenceEquals(ImHashMap`2<K, V> map, int hash, K key, V& value);
    [ExtensionAttribute]
public static bool TryFindByReferenceEquals(ImHashMap`2<K, V> map, K key, V& value);
    public static ImHashMapEntry`2<int, V> Entry(int key, V value);
    public static ImHashMapEntry`2<int, V> EntryWithDefaultValue(int key);
    [ExtensionAttribute]
public static ImHashMapEntry`2<int, V> WithDefaultValue(ImHashMapEntry`2<int, V> e);
    public static ImHashMapEntry`2<K, V> Entry(int hash, K key, V value);
    public static ImHashMapEntry`2<K, V> EntryWithHash(K key, V value);
    public static ImHashMapEntry`2<K, V> EntryWithDefaultValue(int hash, K key);
    [ExtensionAttribute]
public static ImHashMapEntry`2<K, V> WithDefaultValue(ImHashMapEntry`2<K, V> e);
    [ExtensionAttribute]
public static ImHashMapEntry`2<K, V> SetValue(ImHashMapEntry`2<K, V> e, V value);
    public static ImHashMap`2<K, V> BuildFromDifferent(ImHashMapEntry`2<K, V> e0, ImHashMapEntry`2<K, V> e1);
    public static ImHashMap`2<K, V> BuildFromDifferent(ImHashMapEntry`2<K, V> e0, ImHashMapEntry`2<K, V> e1, ImHashMapEntry`2<K, V> e2);
    public static ImHashMap`2<K, V> BuildFromDifferent(ImHashMapEntry`2<K, V> e0, ImHashMapEntry`2<K, V> e1, ImHashMapEntry`2<K, V> e2, ImHashMapEntry`2<K, V> e3);
    public static ImHashMap`2<K, V> BuildUnchecked(ImHashMapEntry`2<K, V> e0, ImHashMapEntry`2<K, V> e1, ImHashMapEntry`2<K, V> e2, ImHashMapEntry`2<K, V> e3, ImHashMapEntry`2<K, V> e4);
    public static ImHashMap`2<K, V> BuildFromDifferent(ImHashMapEntry`2<K, V> e0, ImHashMapEntry`2<K, V> e1, ImHashMapEntry`2<K, V> e2, ImHashMapEntry`2<K, V> e3, ImHashMapEntry`2<K, V> e4, ImHashMapEntry`2<K, V> e5);
    public static ImHashMap`2<K, V> BuildFromDifferent(ImHashMapEntry`2<K, V> e0, ImHashMapEntry`2<K, V> e1, ImHashMapEntry`2<K, V> e2, ImHashMapEntry`2<K, V> e3, ImHashMapEntry`2<K, V> e4, ImHashMapEntry`2<K, V> e5, ImHashMapEntry`2<K, V> e6);
    public static ImHashMap`2<K, V> BuildFromDifferent(ImHashMapEntry`2<K, V> e0, ImHashMapEntry`2<K, V> e1, ImHashMapEntry`2<K, V> e2, ImHashMapEntry`2<K, V> e3, ImHashMapEntry`2<K, V> e4, ImHashMapEntry`2<K, V> e5, ImHashMapEntry`2<K, V> e6, ImHashMapEntry`2<K, V> e7, ImHashMapEntry`2<K, V> e8, ImHashMapEntry`2<K, V> e9);
    public static ImHashMapEntry`2<K, V> Entry(HKV`2& item);
    public static ImHashMap`2<K, V> BuildUnchecked(E items);
    [ExtensionAttribute]
public static ImHashMap`2<int, V> AddOrGetEntry(ImHashMap`2<int, V> map, ImHashMapEntry`2<int, V> newEntry);
    [ExtensionAttribute]
public static ImHashMap`2<K, V> AddOrGetEntry(ImHashMap`2<K, V> map, ImHashMapEntry`2<K, V> newEntry);
    [ExtensionAttribute]
public static ImHashMap`2<K, V> AddOrGetEntryByReferenceEquals(ImHashMap`2<K, V> map, ImHashMapEntry`2<K, V> newEntry);
    [ExtensionAttribute]
public static ImHashMap`2<K, V> AddOrUpdateEntry(ImHashMap`2<K, V> map, ImHashMapEntry`2<K, V> newEntry);
    [ExtensionAttribute]
public static ImHashMap`2<K, V> AddOrUpdateEntryByReferenceEquals(ImHashMap`2<K, V> map, ImHashMapEntry`2<K, V> newEntry);
    [ExtensionAttribute]
public static ImHashMap`2<int, V> AddOrUpdate(ImHashMap`2<int, V> map, int hash, V value);
    [ExtensionAttribute]
public static ImHashMap`2<int, V> AddSureNotPresent(ImHashMap`2<int, V> map, int hash, V value);
    [ExtensionAttribute]
public static ImHashMap`2<K, V> AddOrUpdate(ImHashMap`2<K, V> map, int hash, K key, V value);
    [ExtensionAttribute]
public static ImHashMap`2<K, V> AddOrUpdateByReferenceEquals(ImHashMap`2<K, V> map, int hash, K key, V value);
    [ExtensionAttribute]
public static ImHashMap`2<K, V> AddOrUpdate(ImHashMap`2<K, V> map, K key, V value);
    [ExtensionAttribute]
public static ImHashMap`2<K, V> AddOrUpdateByReferenceEquals(ImHashMap`2<K, V> map, K key, V value);
    [ExtensionAttribute]
public static ImHashMap`2<K, V> AddSureNotPresentEntry(ImHashMap`2<K, V> map, ImHashMapEntry`2<K, V> newEntry);
    [ExtensionAttribute]
public static ImHashMap`2<K, V> AddSureNotPresent(ImHashMap`2<K, V> map, int hash, K key, V value);
    [ExtensionAttribute]
public static ImHashMap`2<K, V> AddSureNotPresent(ImHashMap`2<K, V> map, K key, V value);
    [ExtensionAttribute]
public static ImHashMap`2<int, V> AddOrUpdate(ImHashMap`2<int, V> map, int hash, V value, Update`2<int, V> update);
    [ExtensionAttribute]
public static ImHashMap`2<K, V> AddOrUpdate(ImHashMap`2<K, V> map, int hash, K key, V value, Update`2<K, V> update);
    [ExtensionAttribute]
public static ImHashMap`2<K, V> AddOrUpdate(ImHashMap`2<K, V> map, int hash, K key, V value, R& result, Update`3<K, V, R> update);
    [ExtensionAttribute]
public static ImHashMap`2<K, V> AddOrUpdateByReferenceEquals(ImHashMap`2<K, V> map, int hash, K key, V value, Update`2<K, V> update);
    [ExtensionAttribute]
public static ImHashMap`2<K, V> AddOrUpdate(ImHashMap`2<K, V> map, K key, V value, Update`2<K, V> update);
    [ExtensionAttribute]
public static ImHashMap`2<K, V> AddOrUpdate(ImHashMap`2<K, V> map, K key, V value, R& result, Update`3<K, V, R> update);
    [ExtensionAttribute]
public static ImHashMap`2<int, V> AddOrKeep(ImHashMap`2<int, V> map, int hash, V value);
    [ExtensionAttribute]
public static ImHashMap`2<K, V> AddOrKeepEntry(ImHashMap`2<K, V> map, ImHashMapEntry`2<K, V> newEntry);
    [ExtensionAttribute]
public static ImHashMap`2<K, V> AddOrKeepEntryByReferenceEquals(ImHashMap`2<K, V> map, ImHashMapEntry`2<K, V> newEntry);
    [ExtensionAttribute]
public static ImHashMap`2<K, V> AddOrKeep(ImHashMap`2<K, V> map, int hash, K key, V value);
    [ExtensionAttribute]
public static ImHashMap`2<K, V> AddOrKeep(ImHashMap`2<K, V> map, K key, V value);
    [ExtensionAttribute]
public static ImHashMap`2<int, V> Update(ImHashMap`2<int, V> map, int hash, V value);
    [ExtensionAttribute]
public static ImHashMap`2<int, V> UpdateToDefault(ImHashMap`2<int, V> map, int hash);
    [ExtensionAttribute]
public static ImHashMap`2<K, V> Update(ImHashMap`2<K, V> map, int hash, K key, V value);
    [ExtensionAttribute]
public static ImHashMap`2<K, V> Update(ImHashMap`2<K, V> map, K key, V value);
    [ExtensionAttribute]
public static ImHashMap`2<K, V> UpdateToDefault(ImHashMap`2<K, V> map, int hash, K key);
    [ExtensionAttribute]
public static ImHashMap`2<K, V> UpdateToDefault(ImHashMap`2<K, V> map, K key);
    [ExtensionAttribute]
public static ImHashMap`2<K, V> Update(ImHashMap`2<K, V> map, int hash, K key, V value, Update`2<K, V> update);
    [ExtensionAttribute]
public static ImHashMap`2<K, V> Update(ImHashMap`2<K, V> map, K key, V value, Update`2<K, V> update);
    [ExtensionAttribute]
public static ImHashMap`2<int, V> Remove(ImHashMap`2<int, V> map, int hash);
    [ExtensionAttribute]
public static ImHashMap`2<K, V> Remove(ImHashMap`2<K, V> map, int hash, K key);
    [ExtensionAttribute]
public static ImHashMap`2<K, V> Remove(ImHashMap`2<K, V> map, K key);
}
public class DryIoc.ImTools.ImHashMap`2 : object {
    public static ImHashMap`2<K, V> Empty;
    public bool IsEmpty { get; }
    internal bool MayTurnToBranch2 { get; }
    private static ImHashMap`2();
    public virtual string ToString();
    internal virtual StringBuilder ToMermaidNodeId(StringBuilder s);
    internal virtual StringBuilder ToMermaidNodeItem(StringBuilder s);
    internal virtual StringBuilder ToMermaidString(StringBuilder s);
    public bool get_IsEmpty();
    public virtual int Count();
    internal virtual bool get_MayTurnToBranch2();
    internal virtual Entry<K, V> GetMinHashEntryOrDefault();
    internal virtual Entry<K, V> GetMaxHashEntryOrDefault();
    internal virtual Entry<K, V> GetEntryOrNull(int hash);
    internal virtual Entry<K, V> GetSurePresentEntry(int hash);
    internal virtual ImHashMap`2<K, V> AddOrGetEntry(int hash, Entry<K, V> entry);
    internal virtual ImHashMap`2<K, V> AddSureNotPresentEntry(Entry<K, V> entry);
    internal virtual ImHashMap`2<K, V> ReplaceEntry(Entry<K, V> oldEntry, Entry<K, V> newEntry);
    internal virtual ImHashMap`2<K, V> RemoveEntry(Entry<K, V> entry);
    internal virtual ImHashMap`2<K, V> GetMapOrReplaceWithEntry(ImHashMap`2<K, V> oldMap, ImHashMapEntry`2<K, V> newEntry);
    internal virtual ImHashMap`2<K, V> GetMapOrReplaceWithEntryByReferenceEquals(ImHashMap`2<K, V> oldMap, ImHashMapEntry`2<K, V> newEntry);
    internal virtual ImHashMap`2<K, V> GetEntryOrReplacedMapWithTheSameHash(ImHashMap`2<K, V> oldMap, ImHashMapEntry`2<K, V> newEntry);
    internal virtual ImHashMap`2<K, V> GetEntryOrReplacedMapWithTheSameHashByReferenceEquals(ImHashMap`2<K, V> oldMap, ImHashMapEntry`2<K, V> newEntry);
    internal virtual ImHashMap`2<K, V> AddOrKeepWithTheSameHash(ImHashMap`2<K, V> oldMap, ImHashMapEntry`2<K, V> newEntry);
    internal virtual ImHashMap`2<K, V> AddOrKeepWithTheSameHashByReferenceEquals(ImHashMap`2<K, V> oldMap, ImHashMapEntry`2<K, V> newEntry);
}
public abstract class DryIoc.ImTools.ImHashMapEntry`2 : Entry<K, V> {
    public V Value;
    protected ImHashMapEntry`2(int hash);
    protected ImHashMapEntry`2(int hash, V value);
    public virtual string ToString();
    public sealed virtual int Count();
    internal virtual int ForEach(S state, int startIndex, Action`3<ImHashMapEntry`2<K, V>, int, S> handler);
}
[ExtensionAttribute]
public static class DryIoc.ImTools.ImList : object {
    [ExtensionAttribute]
public static void Deconstruct(ImList`1<T> list, T& head, ImList`1& tail, Boolean& isEmpty);
    public static ImList`1<T> List(T[] items);
    [ExtensionAttribute]
public static ImList`1<T> ToImList(IList`1<T> source);
    [ExtensionAttribute]
public static ImList`1<T> ToImList(IEnumerable`1<T> source);
    [ExtensionAttribute]
public static ImList`1<T> List(T head);
    [ExtensionAttribute]
public static ImList`1<T> List(T head, ImList`1<T> tail);
    [ExtensionAttribute]
public static void ForEach(ImList`1<T> list, Action`1<T> effect);
    [ExtensionAttribute]
public static S Fold(ImList`1<T> list, S state, Func`3<T, S, S> handler);
    [ExtensionAttribute]
public static S Fold(ImList`1<T> list, S state, Func`4<T, int, S, S> handler);
    [ExtensionAttribute]
public static ImList`1<T> Reverse(ImList`1<T> list);
    [ExtensionAttribute]
public static ImList`1<R> Map(ImList`1<T> list, Func`2<T, R> map);
    [ExtensionAttribute]
public static ImList`1<R> Map(ImList`1<T> list, Func`3<T, int, R> map);
    [ExtensionAttribute]
public static T[] ToArray(ImList`1<T> source);
}
public class DryIoc.ImTools.ImList`1 : object {
    public static ImList`1<T> Empty;
    public T Head;
    public ImList`1<T> Tail;
    public bool IsEmpty { get; }
    private ImList`1(T head, ImList`1<T> tail);
    private static ImList`1();
    public bool get_IsEmpty();
    public ImList`1<T> Push(T head);
    [IteratorStateMachineAttribute("DryIoc.ImTools.ImList`1/<Enumerate>d__6")]
public IEnumerable`1<T> Enumerate();
    public virtual string ToString();
}
[ExtensionAttribute]
public static class DryIoc.ImTools.ImZipper : object {
    public static ImZipper`1<T> Zip(T[] items);
    [ExtensionAttribute]
public static T[] ToArray(ImZipper`1<T> z);
    [ExtensionAttribute]
public static ImZipper`1<T> ShiftTo(ImZipper`1<T> z, int i);
    [ExtensionAttribute]
public static ImZipper`1<T> Update(ImZipper`1<T> z, Func`2<T, T> update);
    [ExtensionAttribute]
public static ImZipper`1<T> UpdateAt(ImZipper`1<T> z, int i, Func`2<T, T> update);
    [ExtensionAttribute]
public static ImZipper`1<T> RemoveAt(ImZipper`1<T> z, int i);
    [ExtensionAttribute]
public static S Fold(ImZipper`1<T> z, S state, Func`3<T, S, S> handler);
    [ExtensionAttribute]
public static S Fold(ImZipper`1<T> z, S state, Func`4<T, int, S, S> handler);
    [ExtensionAttribute]
public static void ForEach(ImZipper`1<T> z, Action`1<T> effect);
}
public class DryIoc.ImTools.ImZipper`1 : object {
    public static ImZipper`1<T> Empty;
    public int Index;
    public int Count;
    public ImList`1<T> Left;
    public ImList`1<T> Right;
    public T Focus;
    public bool IsEmpty { get; }
    private ImZipper`1(ImList`1<T> left, T focus, int index, ImList`1<T> right, int count);
    private static ImZipper`1();
    public bool get_IsEmpty();
    public virtual string ToString();
    public ImZipper`1<T> Append(T focus);
    public ImZipper`1<T> PushLeft(T focus);
    public ImZipper`1<T> Insert(T focus);
    public ImZipper`1<T> PushRight(T focus);
    public ImZipper`1<T> PopLeft();
    public ImZipper`1<T> PopRight();
    public ImZipper`1<T> ShiftLeft();
    public ImZipper`1<T> ShiftRight();
    public ImZipper`1<T> WithFocus(T focus);
    public ImZipper`1<R> Map(Func`2<T, R> map);
    public ImZipper`1<R> Map(Func`3<T, int, R> map);
}
public interface DryIoc.ImTools.IPrintable {
    public abstract virtual StringBuilder Print(StringBuilder s, Func`3<StringBuilder, object, StringBuilder> printer);
}
public class DryIoc.ImTools.IsOp`2 : MulticastDelegate {
    public IsOp`2(object object, IntPtr method);
    public virtual bool Invoke(S& state, T& it);
    public virtual IAsyncResult BeginInvoke(S& state, T& it, AsyncCallback callback, object object);
    public virtual bool EndInvoke(S& state, T& it, IAsyncResult result);
}
[ExtensionAttribute]
public static class DryIoc.ImTools.KeyValuePair : object {
    [ExtensionAttribute]
public static KeyValuePair`2<K, V> Pair(K key, V value);
}
[ExtensionAttribute]
public static class DryIoc.ImTools.KV : object {
    public static KV`2<K, V> Of(K key, V value);
    [ExtensionAttribute]
public static KV`2<K, V> WithValue(KV`2<K, V> kv, V value);
}
public class DryIoc.ImTools.KV`2 : object {
    public K Key;
    public V Value;
    public KV`2(K key, V value);
    public sealed virtual StringBuilder Print(StringBuilder s, Func`3<StringBuilder, object, StringBuilder> printer);
    public virtual string ToString();
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
}
[ExtensionAttribute]
public static class DryIoc.ImTools.KVar : object {
    public static KVar`2<K, V> Of(K key, V value);
    [ExtensionAttribute]
public static KVar`2<K, V> WithValue(KVar`2<K, V> kv, V value);
}
public class DryIoc.ImTools.KVar`2 : ValueType {
    public K Key;
    public V Value;
    public KVar`2(K key, V value);
    public sealed virtual StringBuilder Print(StringBuilder s, Func`3<StringBuilder, object, StringBuilder> printer);
    public virtual string ToString();
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
}
public class DryIoc.ImTools.KVEntry`2 : ImHashMapEntry`2<K, V> {
    internal K _key;
    public K Key { get; }
    public KVEntry`2(int hash, K key);
    public KVEntry`2(int hash, K key, V value);
    public virtual K get_Key();
    public virtual string ToString();
    internal virtual StringBuilder ToMermaidNodeItem(StringBuilder s);
    internal virtual ImHashMapEntry`2<K, V> GetOrNullWithTheSameHash(K key);
    internal virtual ImHashMapEntry`2<K, V> GetOrNullWithTheSameHashByReferenceEquals(K key);
    internal virtual V GetValueOrDefaultWithTheSameHashByReferenceEquals(K key);
    internal virtual Entry<K, V> AddOrUpdateWithTheSameHash(ImHashMapEntry`2<K, V> newEntry);
    internal virtual Entry<K, V> AddOrUpdateWithTheSameHashByReferenceEquals(ImHashMapEntry`2<K, V> newEntry);
    internal virtual Entry<K, V> AddOrUpdateWithTheSameHash(ImHashMapEntry`2<K, V> newEntry, Update`2<K, V> update);
    internal virtual Entry<K, V> AddOrUpdateWithTheSameHash(ImHashMapEntry`2<K, V> newEntry, R& result, Update`3<K, V, R> update);
    internal virtual Entry<K, V> AddOrUpdateWithTheSameHashByReferenceEquals(ImHashMapEntry`2<K, V> newEntry, Update`2<K, V> update);
    internal virtual ImHashMap`2<K, V> GetMapOrReplaceWithEntry(ImHashMap`2<K, V> oldMap, ImHashMapEntry`2<K, V> newEntry);
    internal virtual ImHashMap`2<K, V> GetMapOrReplaceWithEntryByReferenceEquals(ImHashMap`2<K, V> oldMap, ImHashMapEntry`2<K, V> newEntry);
    internal virtual ImHashMap`2<K, V> GetEntryOrReplacedMapWithTheSameHash(ImHashMap`2<K, V> oldMap, ImHashMapEntry`2<K, V> newEntry);
    internal virtual ImHashMap`2<K, V> GetEntryOrReplacedMapWithTheSameHashByReferenceEquals(ImHashMap`2<K, V> oldMap, ImHashMapEntry`2<K, V> newEntry);
    internal virtual ImHashMap`2<K, V> AddOrKeepWithTheSameHash(ImHashMap`2<K, V> oldMap, ImHashMapEntry`2<K, V> newEntry);
    internal virtual ImHashMap`2<K, V> AddOrKeepWithTheSameHashByReferenceEquals(ImHashMap`2<K, V> oldMap, ImHashMapEntry`2<K, V> newEntry);
    internal virtual Entry<K, V> UpdatedOrNullWithTheSameHash(ImHashMapEntry`2<K, V> newEntry);
    internal virtual Entry<K, V> UpdatedOrNullWithTheSameHash(K key, V value, Update`2<K, V> update);
    internal virtual Entry<K, V> RemovedOrNullWithTheSameHash(K key);
    public virtual Entry<K, V> AppendOrUpdateInPlaceOrKeep(S state, ImHashMapEntry`2<K, V> newEntry, UpdaterInPlaceOrKeeper`1<K, V, S> updateOrKeep);
    public virtual Entry<K, V> AppendOrUpdateInPlaceOrKeepByReferenceEquals(S state, ImHashMapEntry`2<K, V> newEntry, UpdaterInPlaceOrKeeper`1<K, V, S> updateOrKeep);
}
public static class DryIoc.ImTools.Lazy : object {
    public static Lazy`1<T> Of(Func`1<T> valueFactory);
}
public class DryIoc.ImTools.MapOp`3 : MulticastDelegate {
    public MapOp`3(object object, IntPtr method);
    public virtual R Invoke(S& state, T& it);
    public virtual IAsyncResult BeginInvoke(S& state, T& it, AsyncCallback callback, object object);
    public virtual R EndInvoke(S& state, T& it, IAsyncResult result);
}
public class DryIoc.ImTools.MapParentStack : object {
    private static int DefaultInitialCapacity;
    private Object[] _items;
    public void Put(object item, int index);
    public object Get(int index);
    private static Object[] Expand(Object[] items);
}
public class DryIoc.ImTools.MapParentStack`2 : object {
    private static int DefaultInitialCapacity;
    public Entry[] Items;
    public MapParentStack`2(int capacity);
    public void Put(int index, Entry<K, V> entry, ImHashMap`2<K, V> branch);
    private static Entry[] Expand(Entry[] items);
}
public class DryIoc.ImTools.MatchOp`3 : MulticastDelegate {
    public MatchOp`3(object object, IntPtr method);
    public virtual bool Invoke(S& state, T& it, R& result);
    public virtual IAsyncResult BeginInvoke(S& state, T& it, R& result, AsyncCallback callback, object object);
    public virtual bool EndInvoke(S& state, T& it, R& result, IAsyncResult __result);
}
public class DryIoc.ImTools.Opt`1 : ValueType {
    public T Value;
    public bool HasValue;
    public Opt`1(T value);
    public static Opt`1<T> op_Implicit(T value);
    public T OrDefault(T defaultValue);
}
[ExtensionAttribute]
public static class DryIoc.ImTools.PartitionedHashMap : object {
    public static int PARTITION_COUNT_POWER_OF_TWO;
    public static int PARTITION_HASH_MASK;
    public static ImHashMap`2[] CreateEmpty(int partitionCountOfPowerOfTwo);
    public static ImHashMap`2[] CreateEmpty(int partitionCountOfPowerOfTwo);
    [ExtensionAttribute]
public static V GetValueOrDefault(ImHashMap`2[] parts, int hash, int partHashMask);
    [ExtensionAttribute]
public static V GetValueOrDefault(ImHashMap`2[] parts, int hash, K key, int partHashMask);
    [ExtensionAttribute]
public static V GetValueOrDefault(ImHashMap`2[] parts, K key, int partHashMask);
    [ExtensionAttribute]
public static V GetValueOrDefaultByReferenceEquals(ImHashMap`2[] parts, int hash, K key, int partHashMask);
    [ExtensionAttribute]
public static V GetValueOrDefaultByReferenceEquals(ImHashMap`2[] parts, K key, int partHashMask);
    [ExtensionAttribute]
public static bool TryFind(ImHashMap`2[] parts, int hash, V& value, int partHashMask);
    [ExtensionAttribute]
public static bool TryFind(ImHashMap`2[] parts, int hash, K key, V& value, int partHashMask);
    [ExtensionAttribute]
public static bool TryFind(ImHashMap`2[] parts, K key, V& value, int partHashMask);
    [ExtensionAttribute]
public static bool TryFindByReferenceEquals(ImHashMap`2[] parts, int hash, K key, V& value, int partHashMask);
    [ExtensionAttribute]
public static bool TryFindByReferenceEquals(ImHashMap`2[] parts, K key, V& value, int partHashMask);
    [ExtensionAttribute]
public static void AddOrUpdate(ImHashMap`2[] parts, int hash, V value, int partHashMask);
    private static void RefAddOrUpdatePart(ImHashMap`2& part, int hash, V value);
    [ExtensionAttribute]
public static void AddOrUpdate(ImHashMap`2[] parts, int hash, K key, V value, int partHashMask);
    [ExtensionAttribute]
public static void AddOrUpdate(ImHashMap`2[] parts, K key, V value, int partHashMask);
    private static void RefAddOrUpdatePart(ImHashMap`2& part, int hash, K key, V value);
    [ExtensionAttribute]
public static void AddOrUpdate(ImHashMap`2[] parts, int hash, V value, Update`2<int, V> update, int partHashMask);
    [ExtensionAttribute]
public static void AddOrUpdate(ImHashMap`2[] parts, int hash, K key, V value, Update`2<K, V> update, int partHashMask);
    [ExtensionAttribute]
public static void AddOrUpdate(ImHashMap`2[] parts, K key, V value, Update`2<K, V> update, int partHashMask);
    [ExtensionAttribute]
public static void AddOrKeep(ImHashMap`2[] parts, int hash, V value, int partHashMask);
    private static void RefAddOrKeepPart(ImHashMap`2& part, int hash, V value);
    [ExtensionAttribute]
public static void AddOrKeep(ImHashMap`2[] parts, int hash, K key, V value, int partHashMask);
    private static void RefAddOrKeepPart(ImHashMap`2& part, int hash, K key, V value);
    [ExtensionAttribute]
public static void Update(ImHashMap`2[] parts, int hash, V value, int partHashMask);
    private static void RefUpdatePart(ImHashMap`2& part, int hash, V value);
    [ExtensionAttribute]
public static Enumerable`1<V> Enumerate(ImHashMap`2[] parts);
    [ExtensionAttribute]
public static Enumerable`2<K, V> Enumerate(ImHashMap`2[] parts);
    [ExtensionAttribute]
public static S ForEach(ImHashMap`2[] parts, S state, Action`3<VEntry`1<V>, int, S> handler, MapParentStack parents);
    [ExtensionAttribute]
public static S ForEach(ImHashMap`2[] parts, S state, Action`3<ImHashMapEntry`2<K, V>, int, S> handler, MapParentStack parents);
}
[ExtensionAttribute]
public static class DryIoc.ImTools.Ref : object {
    public static int RETRY_COUNT_UNTIL_THROW;
    public static Ref`1<T> Of(T value);
    [ExtensionAttribute]
public static Ref`1<T> NewRef(Ref`1<T> original);
    public static T Swap(T& value, Func`2<T, T> getNewValue, int retryCountUntilThrow);
    internal static void ThrowRetryCountExceeded(int retryCountExceeded);
    public static T Swap(T& value, A a, Func`3<T, A, T> getNewValue, int retryCountUntilThrow);
    public static T SwapAndGetNewValue(T& value, Func`2<T, T> getNewValue, int retryCountUntilThrow);
    public static T SwapAndGetNewValue(T& value, A a, Func`3<T, A, T> getNewValue, int retryCountUntilThrow);
    public static R Swap(T& value, A a, R result, Func`4<T, A, R, T> update, GetInterrupted`3<T, A, R> getInterrupted);
    public static T Swap(T& value, A a, B b, Func`4<T, A, B, T> getNewValue, int retryCountUntilThrow);
    public static T Swap(T& value, A& a, B& b, GetNewValue`3<T, A, B> getNewValue, int retryCountUntilThrow);
    public static T Swap(T& value, A a, B b, C c, Func`5<T, A, B, C, T> getNewValue, int retryCountUntilThrow);
    public static T Swap(T& value, A a, B b, C c, D d, Func`6<T, A, B, C, D, T> getNewValue, int retryCountUntilThrow);
}
public class DryIoc.ImTools.Ref`1 : object {
    private T _value;
    public T Value { get; }
    public Ref`1(T initialValue);
    public T get_Value();
    public T Swap(Func`2<T, T> getNewValue);
    public T Swap(A a, Func`3<T, A, T> getNewValue, int retryCountUntilThrow);
    public T Swap(A a, B b, Func`4<T, A, B, T> getNewValue, int retryCountUntilThrow);
    public T SwapAndGetNewValue(Func`2<T, T> getNewValue, int retryCountUntilThrow);
    public T SwapAndGetNewValue(A a, Func`3<T, A, T> getNewValue, int retryCountUntilThrow);
    public T Swap(T newValue);
    public T SetNonAtomic(T newValue);
    public bool TrySwapIfStillCurrent(T currentValue, T newValue);
    public void UnsafeSet(T newValue);
}
public class DryIoc.ImTools.SmallArrayPool`1 : ValueType {
    public static byte MaxSmallArrayLength;
    private static T[][] SmallArrays;
    private static SmallArrayPool`1();
    public static T[] RentOrNew(int requiredLength);
    public static void Return(T[] arr);
}
public class DryIoc.ImTools.SmallStack`1 : ValueType {
    public T Value;
    private Tail<T> _tail;
    internal SmallStack`1(Tail<T> tail, T value);
    public SmallStack`1<T> Push(T& value);
}
public static class DryIoc.ImTools.St : object {
    public static St`1<A> Of(A a);
    public static St`1<A> Rent(A a);
    public static St`2<A, B> Of(A a, B b);
    public static St`2<A, B> Rent(A a, B b);
}
public class DryIoc.ImTools.St`1 : object {
    public A a;
    internal static St`1<A> Pooled;
    public void Pool();
    public void Reset();
    public A ResetButGetA();
}
public class DryIoc.ImTools.St`2 : object {
    public A a;
    public B b;
    internal static St`2<A, B> Pooled;
    public St`2<A, B> Pool();
    public void Reset();
    public A ResetButGetA();
    public B ResetButGetB();
}
public class DryIoc.ImTools.StackPool`1 : object {
    private Stack<T> _s;
    public T RentOrNull();
    public void Return(T x);
}
public class DryIoc.ImTools.Update`1 : MulticastDelegate {
    public Update`1(object object, IntPtr method);
    public virtual V Invoke(V oldValue, V newValue);
    public virtual IAsyncResult BeginInvoke(V oldValue, V newValue, AsyncCallback callback, object object);
    public virtual V EndInvoke(IAsyncResult result);
}
public class DryIoc.ImTools.Update`2 : MulticastDelegate {
    public Update`2(object object, IntPtr method);
    public virtual V Invoke(K key, V oldValue, V newValue);
    public virtual IAsyncResult BeginInvoke(K key, V oldValue, V newValue, AsyncCallback callback, object object);
    public virtual V EndInvoke(IAsyncResult result);
}
public class DryIoc.ImTools.Update`3 : MulticastDelegate {
    public Update`3(object object, IntPtr method);
    public virtual V Invoke(K key, V oldValue, V newValue, R& result);
    public virtual IAsyncResult BeginInvoke(K key, V oldValue, V newValue, R& result, AsyncCallback callback, object object);
    public virtual V EndInvoke(R& result, IAsyncResult __result);
}
public class DryIoc.ImTools.VEntry`1 : ImHashMapEntry`2<int, V> {
    public int Key { get; }
    public VEntry`1(int hash);
    public VEntry`1(int hash, V value);
    public virtual int get_Key();
    internal virtual StringBuilder ToMermaidNodeItem(StringBuilder s);
    internal virtual ImHashMapEntry`2<int, V> GetOrNullWithTheSameHash(int key);
    internal virtual ImHashMapEntry`2<int, V> GetOrNullWithTheSameHashByReferenceEquals(int key);
    internal virtual V GetValueOrDefaultWithTheSameHashByReferenceEquals(int key);
    internal virtual Entry<int, V> AddOrUpdateWithTheSameHash(ImHashMapEntry`2<int, V> newEntry);
    internal virtual Entry<int, V> AddOrUpdateWithTheSameHashByReferenceEquals(ImHashMapEntry`2<int, V> newEntry);
    internal virtual Entry<int, V> AddOrUpdateWithTheSameHash(ImHashMapEntry`2<int, V> newEntry, Update`2<int, V> update);
    internal virtual Entry<int, V> AddOrUpdateWithTheSameHash(ImHashMapEntry`2<int, V> newEntry, R& result, Update`3<int, V, R> update);
    internal virtual Entry<int, V> AddOrUpdateWithTheSameHashByReferenceEquals(ImHashMapEntry`2<int, V> newEntry, Update`2<int, V> update);
    internal virtual ImHashMap`2<int, V> GetMapOrReplaceWithEntry(ImHashMap`2<int, V> oldMap, ImHashMapEntry`2<int, V> newEntry);
    internal virtual ImHashMap`2<int, V> AddOrKeepWithTheSameHash(ImHashMap`2<int, V> oldMap, ImHashMapEntry`2<int, V> newEntry);
    internal virtual Entry<int, V> UpdatedOrNullWithTheSameHash(ImHashMapEntry`2<int, V> newEntry);
    internal virtual Entry<int, V> UpdatedOrNullWithTheSameHash(int key, V value, Update`2<int, V> update);
    internal virtual Entry<int, V> RemovedOrNullWithTheSameHash(int key);
    public virtual Entry<int, V> AppendOrUpdateInPlaceOrKeep(S state, ImHashMapEntry`2<int, V> newEntry, UpdaterInPlaceOrKeeper`1<int, V, S> updateOrKeep);
    public virtual Entry<int, V> AppendOrUpdateInPlaceOrKeepByReferenceEquals(S state, ImHashMapEntry`2<int, V> newEntry, UpdaterInPlaceOrKeeper`1<int, V, S> updateOrKeep);
}
internal class DryIoc.InjectedIntoFactoryDummy : Factory {
    private static Setup _setup;
    [CompilerGeneratedAttribute]
private Type <ImplementationType>k__BackingField;
    public Setup Setup { get; }
    public IReuse Reuse { get; }
    public Type ImplementationType { get; }
    public InjectedIntoFactoryDummy(Type instanceType);
    private static InjectedIntoFactoryDummy();
    public virtual Setup get_Setup();
    public virtual IReuse get_Reuse();
    [CompilerGeneratedAttribute]
public virtual Type get_ImplementationType();
    public virtual Expression CreateExpressionOrDefault(Request request);
}
public class DryIoc.InstanceFactory : Factory {
    public object Instance;
    public Type ImplementationType { get; }
    public IReuse Reuse { get; }
    public Setup Setup { get; }
    public bool HasRuntimeState { get; }
    public InstanceFactory(object instance);
    public virtual Type get_ImplementationType();
    public virtual IReuse get_Reuse();
    public virtual Setup get_Setup();
    public virtual bool get_HasRuntimeState();
    public static InstanceFactory Of(object instance);
    public static InstanceFactory Of(object instance, Setup setup);
    internal virtual bool ValidateAndNormalizeRegistration(Type serviceType, object serviceKey, bool isStaticallyChecked, Rules rules, bool throwIfInvalid);
    public virtual Expression CreateExpressionOrDefault(Request request);
    public virtual Expression GetExpressionOrDefault(Request request);
    public virtual Func`2<IResolverContext, object> GetDelegateOrDefault(Request request);
    private object UnpackWeakRefFactory(IResolverContext _);
}
[ExtensionAttribute]
public static class DryIoc.Interpreter : object {
    private static MethodInfo _convertFuncMethod;
    private static MethodInfo _convertOneArgFuncMethod;
    private static MethodInfo _convertOneArgActionMethod;
    private static MethodInfo _convertTwoArgFuncMethod;
    private static MethodInfo _convertTwoArgActionMethod;
    private static MethodInfo _convertThreeArgFuncMethod;
    private static MethodInfo _convertThreeArgActionMethod;
    private static MethodInfo _convertFourArgFuncMethod;
    private static MethodInfo _convertFourArgActionMethod;
    private static Interpreter();
    public static bool TryInterpretAndUnwrapContainerException(IResolverContext r, Expression expr, Object& result);
    private static bool TrySetScopedOrSingletonItemException(IResolverContext r, Exception ex);
    [ExtensionAttribute]
internal static object InterpretOrCompileSingletonAndUnwrapContainerException(IResolverContext r, Expression expr, ImHashMapEntry`2<int, object> itemRef);
    public static bool TryInterpret(IResolverContext r, Expression expr, IParameterProvider paramExprs, object paramValues, ParentLambdaArgs parentArgs, Object& result);
    private static bool TryInterpretNestedLambda(IResolverContext r, LambdaExpression lambdaExpr, IParameterProvider paramExprs, object paramValues, ParentLambdaArgs parentArgs, Object& result);
    private static Type[] GetParamTypes(IParameterProvider ps);
    private static Type[] GetParamsAndReturnType(IParameterProvider ps, Type returnType);
    private static object TryInterpretNestedLambdaBodyAndUnwrapException(IResolverContext r, Expression bodyExpr, IParameterProvider paramExprs, object paramValues, ParentLambdaArgs parentArgs);
    internal static Func`1<R> ConvertFunc(Func`1<object> f);
    internal static Func`2<T, R> ConvertOneArgFunc(Func`2<object, object> f);
    internal static Action`1<T> ConvertOneArgAction(Action`1<object> f);
    internal static Func`3<T0, T1, R> ConvertTwoArgFunc(Func`3<object, object, object> f);
    internal static Action`2<T0, T1> ConvertTwoArgAction(Action`2<object, object> f);
    internal static Func`4<T0, T1, T2, R> ConvertThreeArgFunc(Func`2<Object[], object> f);
    internal static Action`3<T0, T1, T2> ConvertThreeArgAction(Action`1<Object[]> f);
    internal static Func`5<T0, T1, T2, T3, R> ConvertFourArgFunc(Func`2<Object[], object> f);
    internal static Action`4<T0, T1, T2, T3> ConvertFourArgAction(Action`1<Object[]> f);
    private static bool TryInterpretMethodCall(IResolverContext r, MethodCallExpression callExpr, IParameterProvider paramExprs, object paramValues, ParentLambdaArgs parentArgs, Object& result);
    private static bool TryInterpretFuncInvoke(IResolverContext r, MethodCallExpression e, IParameterProvider paramExprs, object paramValues, ParentLambdaArgs parentArgs, Object& result);
    private static object InterpretGetScopedOrSingletonViaFactoryDelegate(IResolverContext r, GetScopedOrSingletonViaFactoryDelegateExpression e, IParameterProvider paramExprs, object paramValues, ParentLambdaArgs parentArgs);
    private static object InterpretGetScopedOrSingletonViaFactoryDelegateWithDisposalOrder(IResolverContext r, GetScopedOrSingletonViaFactoryDelegateWithDisposalOrderExpression e, IParameterProvider paramExprs, object paramValues, ParentLambdaArgs parentArgs);
    private static object InterpretGetNameScopedViaFactoryDelegate(IResolverContext r, MethodCallExpression callExpr, IParameterProvider paramExprs, object paramValues, ParentLambdaArgs parentArgs);
    private static object ConstValue(Expression expr);
    [CompilerGeneratedAttribute]
internal static bool <TrySetScopedOrSingletonItemException>g__TryFindNoItemAndStoreWrappedException|1_0(IScope scope, Exception ex, ScopedItemException& sex);
}
internal class DryIoc.InvokeFactoryDelegateExpression : InvocationExpression {
    [CompilerGeneratedAttribute]
private Type <Type>k__BackingField;
    public Func`2<IResolverContext, object> FactoryDelegate;
    public Type Type { get; }
    public Expression Expression { get; }
    public int ArgumentCount { get; }
    public IReadOnlyList`1<Expression> Arguments { get; }
    public bool IsIntrinsic { get; }
    public InvokeFactoryDelegateExpression(Type type, Func`2<IResolverContext, object> f);
    [CompilerGeneratedAttribute]
public sealed virtual Type get_Type();
    public sealed virtual Expression get_Expression();
    public sealed virtual int get_ArgumentCount();
    public virtual IReadOnlyList`1<Expression> get_Arguments();
    public virtual Expression GetArgument(int index);
    public sealed virtual bool get_IsIntrinsic();
    public sealed virtual bool TryCollectBoundConstants(CompilerFlags config, ClosureInfo& closure, IParameterProvider paramExprs, bool isNestedLambda, ClosureInfo& rootClosure);
    public virtual bool TryEmit(CompilerFlags config, ClosureInfo& closure, IParameterProvider paramExprs, ILGenerator il, ParentFlags parent, int byRefIndex);
}
internal class DryIoc.InvokeFactoryDelegateOfRootOrSelfExpression : InvokeFactoryDelegateExpression {
    public IReadOnlyList`1<Expression> Arguments { get; }
    public InvokeFactoryDelegateOfRootOrSelfExpression(Type type, Func`2<IResolverContext, object> f);
    public virtual IReadOnlyList`1<Expression> get_Arguments();
    public virtual Expression GetArgument(int index);
    public sealed virtual bool TryEmit(CompilerFlags config, ClosureInfo& closure, IParameterProvider paramExprs, ILGenerator il, ParentFlags parent, int byRefIndex);
}
public interface DryIoc.IRegistrator {
    public Rules Rules { get; }
    public abstract virtual Rules get_Rules();
    public abstract virtual void Register(Factory factory, Type serviceType, object serviceKey, Nullable`1<IfAlreadyRegistered> ifAlreadyRegistered, bool isStaticallyChecked);
    public abstract virtual void RegisterWithoutValidation(Factory factory, Type serviceType, object serviceKey, Nullable`1<IfAlreadyRegistered> ifAlreadyRegistered);
    public abstract virtual bool IsRegistered(Type serviceType, object serviceKey, FactoryType factoryType, Func`2<Factory, bool> condition);
    public abstract virtual void Unregister(Type serviceType, object serviceKey, FactoryType factoryType, Func`2<Factory, bool> condition);
    public abstract virtual IEnumerable`1<ServiceRegistrationInfo> GetServiceRegistrations();
    public abstract virtual IEnumerable`1<R> GetServiceRegistrations(S state, MatchOp`3<S, ServiceRegistrationInfo, R> match);
    public abstract virtual IEnumerable`1<DecoratorRegistrationInfo> GetDecoratorRegistrations();
    public abstract virtual Factory[] GetRegisteredFactories(Type serviceType, object serviceKey, FactoryType factoryType);
    public abstract virtual void Use(Type serviceType, object instance);
}
public interface DryIoc.IResolver {
    public abstract virtual object Resolve(Type serviceType, IfUnresolved ifUnresolved);
    public abstract virtual object Resolve(Type serviceType, object serviceKey, IfUnresolved ifUnresolved, Type requiredServiceType, Request preResolveParent, Object[] args);
    public abstract virtual IEnumerable`1<object> ResolveMany(Type serviceType, object serviceKey, Type requiredServiceType, Request preResolveParent, Object[] args);
}
public interface DryIoc.IResolverContext {
    public Rules Rules { get; }
    public bool IsDisposed { get; }
    public object DisposeInfo { get; }
    public IResolverContext Parent { get; }
    public IResolverContext Root { get; }
    public IScope SingletonScope { get; }
    public IScopeContext ScopeContext { get; }
    public IScope CurrentScope { get; }
    public IScope CurrentOrSingletonScope { get; }
    public IScope OwnCurrentScope { get; }
    public abstract virtual Rules get_Rules();
    public abstract virtual bool get_IsDisposed();
    public abstract virtual object get_DisposeInfo();
    public abstract virtual IResolverContext get_Parent();
    public abstract virtual IResolverContext get_Root();
    public abstract virtual IScope get_SingletonScope();
    public abstract virtual IScopeContext get_ScopeContext();
    public abstract virtual IScope get_CurrentScope();
    public abstract virtual IScope get_CurrentOrSingletonScope();
    public abstract virtual IScope get_OwnCurrentScope();
    public abstract virtual IResolverContext WithCurrentScope(IScope ownScope);
    public abstract virtual IResolverContext WithScopeContext(IScopeContext scopeContext);
    public abstract virtual IContainer WithNewOpenScope();
    public abstract virtual void Use(Type serviceType, object instance);
    public abstract virtual void InjectPropertiesAndFields(object instance, String[] propertyAndFieldNames);
}
public interface DryIoc.IReuse {
    public int Lifespan { get; }
    public object Name { get; }
    public abstract virtual int get_Lifespan();
    public abstract virtual object get_Name();
    public abstract virtual bool CanApply(Request request);
    public abstract virtual Expression Apply(Request request, Expression serviceFactoryExpr);
}
public interface DryIoc.IScope {
    public IScope Parent { get; }
    public object Name { get; }
    public bool IsDisposed { get; }
    public abstract virtual IScope get_Parent();
    public abstract virtual object get_Name();
    public abstract virtual bool get_IsDisposed();
    public abstract virtual bool TryGet(Object& item, int id);
    public abstract virtual object GetOrAddViaFactoryDelegate(int id, Func`2<IResolverContext, object> createValue, IResolverContext r);
    public abstract virtual object GetOrAddViaFactoryDelegateWithDisposalOrder(int id, Func`2<IResolverContext, object> createValue, IResolverContext r, int disposalOrder);
    public abstract virtual object TryGetOrAddWithoutClosure(int id, IResolverContext resolveContext, Expression expr, Func`3<IResolverContext, Expression, object> createValue, int disposalOrder);
    public abstract virtual T TrackDisposable(T disposable, int disposalOrder);
    public abstract virtual void SetOrAdd(int id, object item);
    public abstract virtual void SetUsed(int hash, Type type, object instance);
    public abstract virtual bool TryGetUsed(int hash, Type type, Object& instance);
    public abstract virtual IScope Clone(bool withDisposables);
}
public interface DryIoc.IScopeContext {
    public abstract virtual IScope GetCurrentOrDefault();
    public abstract virtual IScope SetCurrent(SetCurrentScopeHandler setCurrentScope);
}
public interface DryIoc.IScopeName {
    public abstract virtual bool Match(object scopeName);
}
public enum DryIoc.IsRegistryChangePermitted : Enum {
    public byte value__;
    public static IsRegistryChangePermitted Permitted;
    public static IsRegistryChangePermitted Error;
    public static IsRegistryChangePermitted Ignored;
}
public interface DryIoc.ITest {
    public abstract virtual int Run();
}
public class DryIoc.LazyEnumerable`1 : object {
    public IEnumerable`1<TService> Items;
    public LazyEnumerable`1(IEnumerable`1<TService> items);
    public sealed virtual IEnumerator`1<TService> GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
}
public class DryIoc.Made : object {
    [CompilerGeneratedAttribute]
private object <FactoryMethodOrSelector>k__BackingField;
    public static Made Default;
    public object FactoryMethodOrSelector { get; internal set; }
    public Type FactoryMethodKnownResultType { get; }
    public ParameterSelector Parameters { get; }
    public PropertiesAndFieldsSelector PropertiesAndFields { get; }
    internal MadeDetails _details { get; }
    public bool IsConditional { get; }
    public bool HasCustomDependencyValue { get; }
    public bool IsConditionalImplementation { get; }
    public bool IsImplMemberDependsOnRequest { get; }
    internal Made(object factoryMethodOrSelector);
    internal Made(FactoryMethod factoryMethod);
    private static Made();
    [CompilerGeneratedAttribute]
public object get_FactoryMethodOrSelector();
    [CompilerGeneratedAttribute]
internal void set_FactoryMethodOrSelector(object value);
    public virtual Type get_FactoryMethodKnownResultType();
    public virtual ParameterSelector get_Parameters();
    public virtual PropertiesAndFieldsSelector get_PropertiesAndFields();
    internal virtual MadeDetails get__details();
    public bool get_IsConditional();
    public bool get_HasCustomDependencyValue();
    public bool get_IsConditionalImplementation();
    public bool get_IsImplMemberDependsOnRequest();
    public virtual string ToString();
    public static Made op_Implicit(FactoryMethodSelector factoryMethod);
    public static Made op_Implicit(ParameterSelector parameters);
    public static Made op_Implicit(PropertiesAndFieldsSelector propertiesAndFields);
    public static Made Of(FactoryMethodSelector factoryMethodSelector, ParameterSelector parameters, PropertiesAndFieldsSelector propertiesAndFields, bool isConditionalImplementation);
    public static Made OfFactoryMethodAndParameters(FactoryMethod factoryMethod, ParameterSelector parameters);
    internal static Made Create(object factoryMethodOrSelector, ParameterSelector parameters, PropertiesAndFieldsSelector propertiesAndFields, bool isConditionalImplementation);
    public Made With(FactoryMethodSelector factoryMethod, ParameterSelector parameters);
    public static Made Of(FactoryMethod factoryMethod, ParameterSelector parameters, PropertiesAndFieldsSelector propertiesAndFields);
    public static Made Of(MemberInfo factoryMethodOrMember, ServiceInfo factoryInfo, ParameterSelector parameters, PropertiesAndFieldsSelector propertiesAndFields);
    public static Made Of(Func`2<Request, Type> getImplType, ParameterSelector parameters, PropertiesAndFieldsSelector propertiesAndFields);
    public static Made Of(Func`2<Request, MemberInfo> getMethodOrMember, ServiceInfo factoryInfo, ParameterSelector parameters, PropertiesAndFieldsSelector propertiesAndFields);
    public static Made Of(Func`2<Request, MemberInfo> getMethodOrMember, Func`2<Request, ServiceInfo> factoryInfo, ParameterSelector parameters, PropertiesAndFieldsSelector propertiesAndFields);
    public static Made Of(Func`2<Type, ConstructorInfo> getConstructor, ParameterSelector parameters, PropertiesAndFieldsSelector propertiesAndFields);
    public static TypedMade`1<TService> Of(Expression`1<Func`1<TService>> serviceReturningExpr, Func`2[] argValues);
    public static TypedMade`1<TService> Of(Func`2<Request, Typed`1<TFactory>> getFactoryInfo, Expression`1<Func`2<TFactory, TService>> serviceReturningExpr, Func`2[] argValues);
    public static TypedMade`1<TService> Of(TFactory factoryInstance, Expression`1<Func`2<TFactory, TService>> serviceReturningExpr, Func`2[] argValues);
    private static TypedMade`1<TService> FromExpression(Func`2<MemberInfo, FactoryMethodSelector> eitherGetFactoryMethodSelector, Func`2<Request, Typed`1<TFactory>> orGetFactoryInfo, LambdaExpression serviceReturningExpr, Func`2[] argValues);
    internal Made Clone();
    private static ParameterSelector ComposeParameterSelectorFromArgs(Boolean& hasCustomValue, Boolean& hasUsedFactoryInfoForParameter, Func`2<Request, Typed`1<TFactory>> nullOrGetFactoryInfo, Expression wholeServiceExpr, ParameterInfo[] paramInfos, IList`1<Expression> argExprs, Func`2[] argValues);
    private static PropertiesAndFieldsSelector ComposePropertiesAndFieldsSelector(Boolean& hasCustomValue, Expression wholeServiceExpr, IList`1<MemberBinding> memberBindings, Func`2[] argValues);
    private static Func`2<Request, object> GetArgCustomValueProvider(Expression wholeServiceExpr, MethodCallExpression methodCallExpr, Func`2[] argValues);
    private static ServiceDetails GetArgServiceDetails(Expression wholeServiceExpr, MethodCallExpression methodCallExpr, Type dependencyType, IfUnresolved defaultIfUnresolved, object defaultValue);
    private static object GetArgExpressionValueOrThrow(Expression wholeServiceExpr, Expression argExpr);
}
public abstract class DryIoc.Messages.AsyncMessageHandler`2 : object {
    protected abstract virtual Task`1<R> Handle(M message, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("DryIoc.Messages.AsyncMessageHandler`2/<DryIoc-Messages-IMessageHandler<M,R>-Handle>d__1")]
private sealed virtual override Task`1<R> DryIoc.Messages.IMessageHandler<M,R>.Handle(M message, CancellationToken cancellationToken);
}
public class DryIoc.Messages.BroadcastMessageHandler`1 : object {
    private IEnumerable`1<IMessageHandler`2<M, EmptyResponse>> _handlers;
    public BroadcastMessageHandler`1(IEnumerable`1<IMessageHandler`2<M, EmptyResponse>> handlers);
    [AsyncStateMachineAttribute("DryIoc.Messages.BroadcastMessageHandler`1/<Handle>d__2")]
public sealed virtual Task`1<EmptyResponse> Handle(M message, CancellationToken cancellationToken);
}
public class DryIoc.Messages.EmptyResponse : ValueType {
    public static EmptyResponse Value;
    public static Task`1<EmptyResponse> Task;
    private static EmptyResponse();
}
public interface DryIoc.Messages.IMessage {
}
public interface DryIoc.Messages.IMessage`1 {
}
public interface DryIoc.Messages.IMessageHandler`1 {
}
public interface DryIoc.Messages.IMessageHandler`2 {
    public abstract virtual Task`1<R> Handle(M message, CancellationToken cancellationToken);
}
public interface DryIoc.Messages.IMessageMiddleware`2 {
    public int RelativeOrder { get; }
    public abstract virtual int get_RelativeOrder();
    public abstract virtual Task`1<R> Handle(M message, CancellationToken cancellationToken, Func`1<Task`1<R>> nextMiddleware);
}
[ExtensionAttribute]
public static class DryIoc.Messages.MessageExtensions : object {
    [AsyncStateMachineAttribute("DryIoc.Messages.MessageExtensions/<ToEmptyResponse>d__0")]
[ExtensionAttribute]
public static Task`1<EmptyResponse> ToEmptyResponse(Task task);
}
public class DryIoc.Messages.MessageMediator : object {
    private IResolver _resolver;
    public MessageMediator(IResolver resolver);
    public Task`1<R> Send(M message, CancellationToken cancellationToken);
    public Task Send(M message, CancellationToken cancellationToken);
}
public class DryIoc.Messages.MiddlewareMessageHandler`2 : object {
    private IMessageHandler`2<M, R> _handler;
    private IEnumerable`1<IMessageMiddleware`2<M, R>> _middlewares;
    public MiddlewareMessageHandler`2(IMessageHandler`2<M, R> handler, IEnumerable`1<IMessageMiddleware`2<M, R>> middlewares);
    public sealed virtual Task`1<R> Handle(M message, CancellationToken cancellationToken);
}
public class DryIoc.Meta`2 : object {
    public T Value;
    public TMetadata Metadata;
    public Meta`2(T value, TMetadata metadata);
}
[ExtensionAttribute]
public static class DryIoc.Parameters : object {
    public static ParameterSelector Of;
    public static ParameterSelector IfUnresolvedReturnDefault;
    private static Parameters();
    [ExtensionAttribute]
public static ParameterSelector OverrideWith(ParameterSelector source, ParameterSelector other);
    [ExtensionAttribute]
public static ParameterSelector Details(ParameterSelector source, Func`3<Request, ParameterInfo, ServiceDetails> getDetailsOrNull);
    [ExtensionAttribute]
public static ParameterSelector Position(ParameterSelector source, int position, Type requiredServiceType, object serviceKey, IfUnresolved ifUnresolved, object defaultValue, string metadataKey, object metadata);
    [ExtensionAttribute]
public static ParameterSelector Position(ParameterSelector source, int position, Func`3<Request, ParameterInfo, ServiceDetails> getServiceDetails);
    [ExtensionAttribute]
public static ParameterSelector Position(ParameterSelector source, int position, Func`2<Request, object> getCustomValue);
    [ExtensionAttribute]
public static ParameterSelector Name(ParameterSelector source, string name, Type requiredServiceType, object serviceKey, IfUnresolved ifUnresolved, object defaultValue, string metadataKey, object metadata);
    [ExtensionAttribute]
public static ParameterSelector Name(ParameterSelector source, string name, Func`3<Request, ParameterInfo, ServiceDetails> getServiceDetails);
    [ExtensionAttribute]
public static ParameterSelector Name(ParameterSelector source, string name, Func`2<Request, object> getCustomValue);
    [ExtensionAttribute]
public static ParameterSelector Type(ParameterSelector source, Type parameterType, Type requiredServiceType, object serviceKey, IfUnresolved ifUnresolved, object defaultValue, string metadataKey, object metadata);
    [ExtensionAttribute]
public static ParameterSelector Type(ParameterSelector source, Type requiredServiceType, object serviceKey, IfUnresolved ifUnresolved, object defaultValue, string metadataKey, object metadata);
    [ExtensionAttribute]
public static ParameterSelector Type(ParameterSelector source, Func`3<Request, ParameterInfo, ServiceDetails> getServiceDetails);
    [ExtensionAttribute]
public static ParameterSelector Type(ParameterSelector source, Func`2<Request, T> getCustomValue);
    [ExtensionAttribute]
public static ParameterSelector Type(ParameterSelector source, Type parameterType, Func`2<Request, object> getCustomValue);
}
public class DryIoc.ParameterSelector : MulticastDelegate {
    public ParameterSelector(object object, IntPtr method);
    public virtual Func`2<ParameterInfo, ParameterServiceInfo> Invoke(Request request);
    public virtual IAsyncResult BeginInvoke(Request request, AsyncCallback callback, object object);
    public virtual Func`2<ParameterInfo, ParameterServiceInfo> EndInvoke(IAsyncResult result);
}
public class DryIoc.ParameterServiceInfo : ServiceInfo {
    public ParameterInfo Parameter;
    public static ParameterServiceInfo DefinitelyUnresolvedParameter;
    public Type ServiceType { get; }
    private ParameterServiceInfo(ParameterInfo p);
    private static ParameterServiceInfo();
    public virtual Type get_ServiceType();
    internal static ParameterServiceInfo OrNull(ParameterInfo parameter);
    public static ParameterServiceInfo Of(ParameterInfo parameter);
    public static ParameterServiceInfo Of(ParameterInfo parameter, ServiceDetails details);
    public static ParameterServiceInfo Of(ParameterInfo parameter, Type serviceType, ServiceDetails details);
    public virtual ServiceInfo Create(Type serviceType, ServiceDetails details);
    public virtual string ToString();
}
[ExtensionAttribute]
public static class DryIoc.Portable : object {
    private static Lazy`1<Func`2<Assembly, IEnumerable`1<Type>>> _getAssemblyTypes;
    private static Lazy`1<Func`1<int>> _getEnvCurrentManagedThreadId;
    private static Portable();
    public static IEnumerable`1<Type> GetAssemblyTypes(Assembly a);
    private static Func`2<Assembly, IEnumerable`1<Type>> GetAssemblyTypesMethod();
    [ExtensionAttribute]
public static MethodInfo GetGetMethodOrNull(PropertyInfo p, bool includeNonPublic);
    [ExtensionAttribute]
public static MethodInfo GetSetMethodOrNull(PropertyInfo p, bool includeNonPublic);
    public static int GetCurrentManagedThreadID();
}
[ExtensionAttribute]
public static class DryIoc.PrintTools : object {
    public static bool StripNamespace;
    public static Func`3<Type, string, string> TypePrinter;
    private static PrintTools();
    [ExtensionAttribute]
public static StringBuilder Print(StringBuilder s, object x);
    [ExtensionAttribute]
public static string Print(object x);
}
[ExtensionAttribute]
public static class DryIoc.PropertiesAndFields : object {
    public static PropertiesAndFieldsSelector Of;
    public static PropertiesAndFieldsSelector Auto;
    private static PropertiesAndFieldsSelector _requiredProperties;
    private static PropertiesAndFields();
    public static PropertiesAndFieldsSelector Properties(bool withNonPublic, bool withBase, IfUnresolved ifUnresolved);
    public static PropertiesAndFieldsSelector RequiredProperties();
    public static PropertiesAndFieldsSelector All(bool withNonPublic, bool withPrimitive, bool withFields, bool withBase, IfUnresolved ifUnresolved, GetServiceInfo serviceInfo);
    [ExtensionAttribute]
public static PropertiesAndFieldsSelector OverrideWith(PropertiesAndFieldsSelector source, PropertiesAndFieldsSelector other);
    [ExtensionAttribute]
public static PropertiesAndFieldsSelector Details(PropertiesAndFieldsSelector source, string name, Func`2<Request, ServiceDetails> getDetails);
    [ExtensionAttribute]
public static PropertiesAndFieldsSelector Name(PropertiesAndFieldsSelector source, string name, Type requiredServiceType, object serviceKey, IfUnresolved ifUnresolved, object defaultValue, string metadataKey, object metadata);
    [ExtensionAttribute]
public static PropertiesAndFieldsSelector Name(PropertiesAndFieldsSelector source, string name, Func`2<Request, object> getCustomValue);
    [ExtensionAttribute]
public static bool IsInjectable(PropertyInfo property, bool withNonPublic, bool withPrimitive);
    [ExtensionAttribute]
public static bool IsInjectable(FieldInfo field, bool withNonPublic, bool withPrimitive);
}
public class DryIoc.PropertiesAndFieldsSelector : MulticastDelegate {
    public PropertiesAndFieldsSelector(object object, IntPtr method);
    public virtual IEnumerable`1<PropertyOrFieldServiceInfo> Invoke(Request request);
    public virtual IAsyncResult BeginInvoke(Request request, AsyncCallback callback, object object);
    public virtual IEnumerable`1<PropertyOrFieldServiceInfo> EndInvoke(IAsyncResult result);
}
public abstract class DryIoc.PropertyOrFieldServiceInfo : Typed {
    public ServiceDetails Details { get; }
    public MemberInfo Member { get; }
    public PropertyOrFieldServiceInfo(Type serviceType);
    public virtual ServiceDetails get_Details();
    public abstract virtual MemberInfo get_Member();
    public abstract virtual void SetValue(object holder, object value);
    public static PropertyOrFieldServiceInfo Of(MemberInfo member);
    public static PropertyOrFieldServiceInfo Of(PropertyInfo property);
    public static PropertyOrFieldServiceInfo OfRequiredProperty(PropertyInfo property);
    public static PropertyOrFieldServiceInfo Of(FieldInfo field);
}
public class DryIoc.ReflectionFactory : Factory {
    private object _implementationTypeOrProviderOrPubCtorOrCtors;
    public Type ImplementationType { get; }
    public bool CanAccessImplementationType { get; }
    public Made Made { get; }
    public int RegistrationOrder { get; }
    protected ReflectionFactory(Type implementationType);
    public virtual Type get_ImplementationType();
    public ConstructorInfo[] GetConstructors(Request request, BindingFlags additionalToPublicAndInstance);
    private static void ValidateImplementationType(Type type);
    private static Type ValidateImplementationType(Type implType, Made made);
    private static bool IsFactoryGenerator(Type t);
    private static bool IsFactoryGenerator(Type t, Made m);
    public virtual bool get_CanAccessImplementationType();
    public virtual Made get_Made();
    public virtual int get_RegistrationOrder();
    internal static ReflectionFactory OfReuse(Type implementationType, IReuse reuse);
    public static ReflectionFactory Of(Type implementationType, IReuse reuse);
    public static ReflectionFactory Of(Type implementationType);
    public static ReflectionFactory Of(Type implementationType, IReuse reuse, Made made, Setup setup);
    public static ReflectionFactory OfConcreteTypeAndMadeNoValidation(Type knownImplOrServiceType, Made made, IReuse reuse, Setup setup);
    public static ReflectionFactory OfAnyKey(Type knownImplOrServiceType, Made made, IReuse reuse, Setup setup);
    public static ReflectionFactory Of(Func`1<Type> implementationTypeProvider, IReuse reuse, Made made, Setup setup);
    public virtual Expression CreateExpressionOrDefault(Request request);
    private Expression TryGetMemberInitList(NewExpression newExpr, Request request, IContainer container, Rules rules, bool validateOnly);
    private static Expression ConvertExpressionIfNeeded(Expression serviceExpr, Request request, MemberInfo ctorOrMember);
    internal static Expression TryGetExpressionFromInputArgs(Type paramType, Expression[] inputArgs, Int32& argsUsedMask);
    internal static Expression TryGetUsedInstanceOrCustomValueExpression(Request request, Request paramRequest, ServiceDetails paramDetails);
    internal virtual bool ValidateAndNormalizeRegistration(Type serviceType, object serviceKey, bool isStaticallyChecked, Rules rules, bool throwIfInvalid);
    private static bool ValidateImplementationAndServiceTypeParamsMatch(Type implType, Type serviceType, bool throwIfInvalid);
    private static void MatchOpenGenericConstraints(Type[] implTypeParams, Type[] implTypeArgs);
    private static bool MatchServiceWithImplementedTypeParams(Type[] resultImplArgs, Type[] implParams, Type[] serviceParams, Type[] serviceArgs);
    private static FactoryMethod GetClosedFactoryMethodOrDefault(FactoryMethod factoryMethod, Type[] serviceTypeArgs, Request request, bool ifErrorReturnDefault);
}
[ExtensionAttribute]
public static class DryIoc.ReflectionTools : object {
    internal static PropertyInfo WeakReferenceValueProperty;
    internal static ConstructorInfo WeakReferenceCtor;
    internal static MethodInfo GetDefaultMethod;
    private static ReflectionTools();
    [UnsafeAccessorAttribute("1")]
private static void InternalPreserveStackTrace(Exception exception);
    [ExtensionAttribute]
public static Exception TryRethrowWithPreservedStackTrace(Exception ex);
    [ExtensionAttribute]
internal static Type[] GetImplementedTypesExcludingItselfAndObject(Type sourceType);
    [ExtensionAttribute]
public static Type[] GetImplementedTypes(Type sourceType, AsImplementedType asImplementedType);
    [ExtensionAttribute]
public static IEnumerable`1<MemberInfo> GetAllMembers(Type type, bool includeBase);
    [ExtensionAttribute]
public static bool ContainsAllGenericTypeParameters(Type openGenericType, Type[] genericParameters);
    [ExtensionAttribute]
internal static T TryCloseGenericTypeOrMethod(T openGenericTypeOrMethod, Type[] typeArgs, Func`3<T, Type[], T> closeGeneric, bool throwCondition, int error, Request r);
    [ExtensionAttribute]
public static bool IsCompilerGenerated(Type type);
    [ExtensionAttribute]
public static bool IsClosedGeneric(Type type);
    [ExtensionAttribute]
public static bool IsOpenGeneric(Type type);
    [ExtensionAttribute]
public static Type GetGenericDefinitionOrNull(Type type);
    [ExtensionAttribute]
public static Type GetArrayElementTypeOrNull(Type type);
    [ExtensionAttribute]
public static bool IsPublicOrNestedPublic(Type type);
    [ExtensionAttribute]
public static bool IsStatic(Type type);
    [ExtensionAttribute]
public static bool HasConversionOperatorTo(Type sourceType, Type targetType);
    [ExtensionAttribute]
public static MethodInfo GetConversionOperatorOrNull(Type sourceType, Type targetType);
    [ExtensionAttribute]
internal static MethodInfo FindConvertOperator(Type type, Type sourceType, Type targetType);
    [ExtensionAttribute]
public static bool IsAssignableTo(Type type, Type other);
    [ExtensionAttribute]
public static bool IsAssignableTo(Type type);
    [ExtensionAttribute]
public static bool IsAssignableVariantGenericTypeFrom(Type to, Type from);
    [ExtensionAttribute]
public static bool IsPrimitive(Type type, bool orArrayOfPrimitives);
    [ExtensionAttribute]
public static Attribute[] GetAttributes(Type type, Type attributeType, bool inherit);
    [ExtensionAttribute]
public static IEnumerable`1<TMember> GetMembers(Type type, Func`2<TypeInfo, IEnumerable`1<TMember>> getMembers, bool includeBase);
    [ExtensionAttribute]
public static ConstructorInfo[] PublicConstructors(Type type);
    [ExtensionAttribute]
public static IEnumerable`1<ConstructorInfo> PublicAndNonPublicInstanceConstructors(Type type);
    [ExtensionAttribute]
public static IEnumerable`1<ConstructorInfo> Constructors(Type type, bool includeNonPublic, bool includeStatic);
    [ExtensionAttribute]
public static ConstructorInfo GetConstructorOrNull(Type type, bool includeNonPublic, Type[] args);
    [ExtensionAttribute]
public static ConstructorInfo GetConstructorOrNull(Type type, Type[] args);
    [ExtensionAttribute]
public static ConstructorInfo Constructor(Type type, Type[] args);
    [ExtensionAttribute]
public static ConstructorInfo GetSingleConstructorOrNull(Type type, bool includeNonPublic);
    [ExtensionAttribute]
public static ConstructorInfo SingleConstructor(Type type, bool includeNonPublic);
    [ExtensionAttribute]
public static MethodInfo GetSingleMethodOrNull(Type type, string name, bool includeNonPublic);
    [ExtensionAttribute]
public static MethodInfo SingleMethod(Type type, string name, bool includeNonPublic);
    [ExtensionAttribute]
public static MethodInfo Method(Type type, string name, Type[] args);
    [ExtensionAttribute]
public static MethodInfo GetMethodOrNull(Type type, string name, Type[] paramTypes);
    [ExtensionAttribute]
public static PropertyInfo Property(Type type, string name, bool includeBase);
    [ExtensionAttribute]
public static PropertyInfo GetPropertyOrNull(Type type, string name, bool includeBase);
    [ExtensionAttribute]
public static FieldInfo Field(Type type, string name, bool includeBase);
    [ExtensionAttribute]
public static FieldInfo GetFieldOrNull(Type type, string name, bool includeBase);
    [ExtensionAttribute]
public static Assembly GetAssembly(Type type);
    [ExtensionAttribute]
public static bool IsExplicitlyImplemented(PropertyInfo property);
    [ExtensionAttribute]
public static bool IsStatic(MemberInfo member);
    [ExtensionAttribute]
public static bool IsStatic(PropertyInfo property, bool includeNonPublic);
    [ExtensionAttribute]
public static Type GetReturnTypeOrDefault(MemberInfo member);
    [ExtensionAttribute]
public static bool IsBackingField(FieldInfo field);
    [ExtensionAttribute]
public static bool IsIndexer(PropertyInfo property);
    [ExtensionAttribute]
public static bool IsClosureType(Type type);
    [ExtensionAttribute]
public static IEnumerable`1<Attribute> GetAttributes(MemberInfo member, Type attributeType, bool inherit);
    [ExtensionAttribute]
public static IEnumerable`1<Attribute> GetAttributes(ParameterInfo parameter, Type attributeType, bool inherit);
    [ExtensionAttribute]
public static Type[] GetLoadedTypes(Assembly assembly);
    private static int ClearGenericParametersReferencedInConstraints(Type[] genericParams);
    private static int ClearMatchesFoundInGenericParameters(int matchedParamIndexesBitMask, Type[] genericParams, Type[] genericArgs);
    internal static T GetDefault();
    [ExtensionAttribute]
public static Expression GetDefaultValueExpression(Type type);
    [ExtensionAttribute]
internal static bool EmitConvertObjectTo(ILGenerator il, Type t);
    [ExtensionAttribute]
public static object GetValueOrDefault(ImHashMap`2<Type, object> map, Type t);
    [ExtensionAttribute]
public static ImHashMap`2<Type, object> AddOrUpdate(ImHashMap`2<Type, object> map, Type t, object value);
    [ExtensionAttribute]
internal static ImHashMapEntry`2<Type, object> Entry(Type t, object value);
}
[ExtensionAttribute]
public static class DryIoc.Registrator : object {
    public static object AnyKey;
    public static Func`2<Type, bool> Interfaces;
    private static string InvokeMethodName;
    private static MethodInfo _initializerMethod;
    private static Registrator();
    public static object AnyKeyOfResolutionKey(object key);
    [ExtensionAttribute]
public static bool MatchToNotNullRegisteredKey(object resolutionKey, object registeredKey);
    [ExtensionAttribute]
public static void Register(IRegistrator registrator, Type serviceType, Factory factory, Nullable`1<IfAlreadyRegistered> ifAlreadyRegistered, object serviceKey);
    [ExtensionAttribute]
public static void Register(IRegistrator registrator, Type serviceType, Type implementationType, IReuse reuse);
    [ExtensionAttribute]
public static void Register(IRegistrator registrator, Type serviceType, Type implementationType, IReuse reuse, Made made, Setup setup, Nullable`1<IfAlreadyRegistered> ifAlreadyRegistered, object serviceKey);
    [ExtensionAttribute]
public static void Register(IRegistrator registrator, Type serviceAndMayBeImplementationType, IReuse reuse, Made made, Setup setup, Nullable`1<IfAlreadyRegistered> ifAlreadyRegistered, object serviceKey);
    [ExtensionAttribute]
public static void Register(IRegistrator registrator, IReuse reuse, Made made, Setup setup, Nullable`1<IfAlreadyRegistered> ifAlreadyRegistered, object serviceKey);
    [ExtensionAttribute]
public static void Register(IRegistrator registrator, IReuse reuse, Made made, Setup setup, Nullable`1<IfAlreadyRegistered> ifAlreadyRegistered, object serviceKey);
    [ExtensionAttribute]
public static void Register(IRegistrator registrator, TypedMade`1<TMadeResult> made, IReuse reuse, Setup setup, Nullable`1<IfAlreadyRegistered> ifAlreadyRegistered, object serviceKey);
    [ExtensionAttribute]
public static void Register(IRegistrator registrator, TypedMade`1<TService> made, IReuse reuse, Setup setup, Nullable`1<IfAlreadyRegistered> ifAlreadyRegistered, object serviceKey);
    [ExtensionAttribute]
public static void RegisterInstance(IRegistrator registrator, bool isChecked, Type serviceType, object instance, Nullable`1<IfAlreadyRegistered> ifAlreadyRegistered, Setup setup, object serviceKey);
    [ExtensionAttribute]
public static void TrackDisposable(IRegistrator registrator, object instance);
    [ExtensionAttribute]
public static void TrackDisposable(IRegistrator registrator, object instance, Setup setup);
    [ExtensionAttribute]
public static void RegisterInstance(IRegistrator registrator, Type serviceType, object instance, Nullable`1<IfAlreadyRegistered> ifAlreadyRegistered, Setup setup, object serviceKey);
    [ExtensionAttribute]
public static void RegisterInstance(IRegistrator registrator, T instance, Nullable`1<IfAlreadyRegistered> ifAlreadyRegistered, Setup setup, object serviceKey);
    [ExtensionAttribute]
public static void RegisterInstanceMany(IRegistrator registrator, Type implType, object instance, bool nonPublicServiceTypes, Nullable`1<IfAlreadyRegistered> ifAlreadyRegistered, Setup setup, object serviceKey);
    [ExtensionAttribute]
public static void RegisterInstanceMany(IRegistrator registrator, T instance, bool nonPublicServiceTypes, Nullable`1<IfAlreadyRegistered> ifAlreadyRegistered, Setup setup, object serviceKey);
    [ExtensionAttribute]
public static void RegisterInstanceMany(IRegistrator registrator, Type[] serviceTypes, object instance, Nullable`1<IfAlreadyRegistered> ifAlreadyRegistered, Setup setup, object serviceKey);
    [ExtensionAttribute]
public static bool IsExcludedGeneralPurposeServiceType(Type type);
    [ExtensionAttribute]
public static bool IsServiceType(Type type);
    [ExtensionAttribute]
public static bool IsImplementationType(Type type);
    [ExtensionAttribute]
public static Type[] GetImplementedServiceTypes(Type type, bool nonPublicServiceTypes);
    [ExtensionAttribute]
public static bool IsImplementingServiceType(Type type, Type serviceType);
    [ExtensionAttribute]
public static Type[] GetRegisterManyImplementedServiceTypes(Type type, bool nonPublicServiceTypes);
    [ExtensionAttribute]
public static IEnumerable`1<Type> GetImplementationTypes(Assembly assembly);
    [ExtensionAttribute]
public static IEnumerable`1<Type> GetImplementationTypes(Assembly assembly, Func`2<Type, bool> condition);
    [ExtensionAttribute]
public static bool ImplementsServiceType(Type type, Type serviceType);
    [ExtensionAttribute]
public static bool ImplementsServiceType(Type type);
    [ExtensionAttribute]
public static ReflectionFactory ToFactory(Type implType);
    [ExtensionAttribute]
public static ReflectionFactory ToFactory(Type implType, IReuse reuse, Made made, Setup setup);
    [ExtensionAttribute]
public static void RegisterMany(IRegistrator registrator, IEnumerable`1<Type> implTypes, Func`2<Type, Type[]> getServiceTypes, Func`2<Type, Factory> getImplFactory, Func`3<Type, Type, object> getServiceKey, Nullable`1<IfAlreadyRegistered> ifAlreadyRegistered);
    [ExtensionAttribute]
public static void RegisterManyIgnoreNoServicesWereRegistered(IRegistrator registrator, IEnumerable`1<Type> implTypes, Func`2<Type, Type[]> getServiceTypes, Func`2<Type, Factory> getImplFactory, Func`3<Type, Type, object> getServiceKey, Nullable`1<IfAlreadyRegistered> ifAlreadyRegistered);
    [ExtensionAttribute]
public static void RegisterMany(IRegistrator registrator, Type[] serviceTypes, Type implType, IReuse reuse, Made made, Setup setup, Nullable`1<IfAlreadyRegistered> ifAlreadyRegistered, object serviceKey);
    [ExtensionAttribute]
public static void RegisterMany(IRegistrator registrator, IEnumerable`1<Assembly> implTypeAssemblies, Func`2<Type, Type[]> getServiceTypes, Func`2<Type, Factory> getImplFactory, Func`3<Type, Type, object> getServiceKey, Nullable`1<IfAlreadyRegistered> ifAlreadyRegistered);
    [ExtensionAttribute]
public static void RegisterMany(IRegistrator registrator, IEnumerable`1<Assembly> implTypeAssemblies, Func`2<Type, bool> serviceTypeCondition, IReuse reuse, Made made, Setup setup, Nullable`1<IfAlreadyRegistered> ifAlreadyRegistered, bool nonPublicServiceTypes, object serviceKey);
    [ExtensionAttribute]
public static void RegisterMany(IRegistrator registrator, IEnumerable`1<Type> implTypes, IReuse reuse, Made made, Setup setup, Nullable`1<IfAlreadyRegistered> ifAlreadyRegistered, Func`2<Type, bool> serviceTypeCondition, bool nonPublicServiceTypes, object serviceKey);
    [ExtensionAttribute]
public static void RegisterMany(IRegistrator registrator, IReuse reuse, Made made, Setup setup, Nullable`1<IfAlreadyRegistered> ifAlreadyRegistered, Func`2<Type, bool> serviceTypeCondition, bool nonPublicServiceTypes, object serviceKey);
    [ExtensionAttribute]
public static void RegisterMany(IRegistrator registrator, TypedMade`1<TMadeResult> made, IReuse reuse, Setup setup, Nullable`1<IfAlreadyRegistered> ifAlreadyRegistered, Func`2<Type, bool> serviceTypeCondition, bool nonPublicServiceTypes, object serviceKey);
    [ExtensionAttribute]
public static object ToFactoryDelegate(Func`2<IResolverContext, TService> f, IResolverContext r);
    [ExtensionAttribute]
public static object ToFactoryDelegate(object result, IResolverContext _);
    [ExtensionAttribute]
public static void RegisterDelegate(IRegistrator registrator, Func`2<IResolverContext, TService> factoryDelegate, IReuse reuse, Setup setup, Nullable`1<IfAlreadyRegistered> ifAlreadyRegistered, object serviceKey);
    [ExtensionAttribute]
private static object ToFuncWithObjResult(Func`1<TService> f);
    [ExtensionAttribute]
private static object ToFuncWithObjParams(Func`2<D1, TService> f, object d1);
    [ExtensionAttribute]
public static object ToFuncWithObjParams(Func`3<D1, D2, TService> f, object d1, object d2);
    [ExtensionAttribute]
private static object ToFuncWithObjParams(Func`4<D1, D2, D3, TService> f, object d1, object d2, object d3);
    [ExtensionAttribute]
private static object ToFuncWithObjParams(Func`5<D1, D2, D3, D4, TService> f, object d1, object d2, object d3, object d4);
    [ExtensionAttribute]
private static object ToFuncWithObjParams(Func`6<D1, D2, D3, D4, D5, TService> f, object d1, object d2, object d3, object d4, object d5);
    [ExtensionAttribute]
private static object ToFuncWithObjParams(Func`7<D1, D2, D3, D4, D5, D6, TService> f, object d1, object d2, object d3, object d4, object d5, object d6);
    [ExtensionAttribute]
private static object ToFuncWithObjParams(Func`8<D1, D2, D3, D4, D5, D6, D7, TService> f, object d1, object d2, object d3, object d4, object d5, object d6, object d7);
    [ExtensionAttribute]
private static void RegisterFunc(IRegistrator r, Type serviceType, Type sourceFuncType, Delegate funcWithObjParams, IReuse reuse, Setup setup, Nullable`1<IfAlreadyRegistered> ifAlreadyRegistered, object serviceKey);
    [ExtensionAttribute]
public static void RegisterDelegate(IRegistrator r, Func`1<TService> factory, IReuse reuse, Setup setup, Nullable`1<IfAlreadyRegistered> ifAlreadyRegistered, object serviceKey);
    [ExtensionAttribute]
public static void RegisterDelegate(IRegistrator r, Func`2<TDep1, TService> factory, IReuse reuse, Setup setup, Nullable`1<IfAlreadyRegistered> ifAlreadyRegistered, object serviceKey);
    [ExtensionAttribute]
public static void RegisterDelegate(IRegistrator r, Type serviceType, Func`2<TDep1, object> factory, IReuse reuse, Setup setup, Nullable`1<IfAlreadyRegistered> ifAlreadyRegistered, object serviceKey);
    [ExtensionAttribute]
public static void RegisterDelegate(IRegistrator r, Type serviceType, Type depType, Func`2<object, object> factory, IReuse reuse, Setup setup, Nullable`1<IfAlreadyRegistered> ifAlreadyRegistered, object serviceKey);
    [ExtensionAttribute]
public static void RegisterDelegate(IRegistrator r, Func`3<TDep1, TDep2, TService> factory, IReuse reuse, Setup setup, Nullable`1<IfAlreadyRegistered> ifAlreadyRegistered, object serviceKey);
    [ExtensionAttribute]
public static void RegisterDelegate(IRegistrator r, Type serviceType, Func`3<TDep1, TDep2, object> factory, IReuse reuse, Setup setup, Nullable`1<IfAlreadyRegistered> ifAlreadyRegistered, object serviceKey);
    [ExtensionAttribute]
public static void RegisterDelegate(IRegistrator r, Type serviceType, Type dep1Type, Type dep2Type, Func`3<object, object, object> factory, IReuse reuse, Setup setup, Nullable`1<IfAlreadyRegistered> ifAlreadyRegistered, object serviceKey);
    [ExtensionAttribute]
public static void RegisterDelegate(IRegistrator r, Func`4<TDep1, TDep2, TDep3, TService> factory, IReuse reuse, Setup setup, Nullable`1<IfAlreadyRegistered> ifAlreadyRegistered, object serviceKey);
    [ExtensionAttribute]
public static void RegisterDelegate(IRegistrator r, Type serviceType, Func`4<TDep1, TDep2, TDep3, object> factory, IReuse reuse, Setup setup, Nullable`1<IfAlreadyRegistered> ifAlreadyRegistered, object serviceKey);
    [ExtensionAttribute]
public static void RegisterDelegate(IRegistrator r, Type serviceType, Type dep1Type, Type dep2Type, Type dep3Type, Func`4<object, object, object, object> factory, IReuse reuse, Setup setup, Nullable`1<IfAlreadyRegistered> ifAlreadyRegistered, object serviceKey);
    [ExtensionAttribute]
public static void RegisterDelegate(IRegistrator r, Func`5<TDep1, TDep2, TDep3, TDep4, TService> factory, IReuse reuse, Setup setup, Nullable`1<IfAlreadyRegistered> ifAlreadyRegistered, object serviceKey);
    [ExtensionAttribute]
public static void RegisterDelegate(IRegistrator r, Type serviceType, Func`5<TDep1, TDep2, TDep3, TDep4, object> factory, IReuse reuse, Setup setup, Nullable`1<IfAlreadyRegistered> ifAlreadyRegistered, object serviceKey);
    [ExtensionAttribute]
public static void RegisterDelegate(IRegistrator r, Type serviceType, Type dep1Type, Type dep2Type, Type dep3Type, Type dep4Type, Func`5<object, object, object, object, object> factory, IReuse reuse, Setup setup, Nullable`1<IfAlreadyRegistered> ifAlreadyRegistered, object serviceKey);
    [ExtensionAttribute]
public static void RegisterDelegate(IRegistrator r, Func`6<TDep1, TDep2, TDep3, TDep4, TDep5, TService> factory, IReuse reuse, Setup setup, Nullable`1<IfAlreadyRegistered> ifAlreadyRegistered, object serviceKey);
    [ExtensionAttribute]
public static void RegisterDelegate(IRegistrator r, Type serviceType, Func`6<TDep1, TDep2, TDep3, TDep4, TDep5, object> factory, IReuse reuse, Setup setup, Nullable`1<IfAlreadyRegistered> ifAlreadyRegistered, object serviceKey);
    [ExtensionAttribute]
public static void RegisterDelegate(IRegistrator r, Type serviceType, Type dep1Type, Type dep2Type, Type dep3Type, Type dep4Type, Type dep5Type, Func`6<object, object, object, object, object, object> factory, IReuse reuse, Setup setup, Nullable`1<IfAlreadyRegistered> ifAlreadyRegistered, object serviceKey);
    [ExtensionAttribute]
public static void RegisterDelegate(IRegistrator r, Func`7<TDep1, TDep2, TDep3, TDep4, TDep5, TDep6, TService> factory, IReuse reuse, Setup setup, Nullable`1<IfAlreadyRegistered> ifAlreadyRegistered, object serviceKey);
    [ExtensionAttribute]
public static void RegisterDelegate(IRegistrator r, Type serviceType, Func`7<TDep1, TDep2, TDep3, TDep4, TDep5, TDep6, object> factory, IReuse reuse, Setup setup, Nullable`1<IfAlreadyRegistered> ifAlreadyRegistered, object serviceKey);
    [ExtensionAttribute]
public static void RegisterDelegate(IRegistrator r, Type serviceType, Type dep1Type, Type dep2Type, Type dep3Type, Type dep4Type, Type dep5Type, Type dep6Type, Func`7<object, object, object, object, object, object, object> factory, IReuse reuse, Setup setup, Nullable`1<IfAlreadyRegistered> ifAlreadyRegistered, object serviceKey);
    [ExtensionAttribute]
public static void RegisterDelegate(IRegistrator r, Func`8<TDep1, TDep2, TDep3, TDep4, TDep5, TDep6, TDep7, TService> factory, IReuse reuse, Setup setup, Nullable`1<IfAlreadyRegistered> ifAlreadyRegistered, object serviceKey);
    [ExtensionAttribute]
public static void RegisterDelegate(IRegistrator r, Type serviceType, Func`8<TDep1, TDep2, TDep3, TDep4, TDep5, TDep6, TDep7, object> factory, IReuse reuse, Setup setup, Nullable`1<IfAlreadyRegistered> ifAlreadyRegistered, object serviceKey);
    [ExtensionAttribute]
public static void RegisterDelegate(IRegistrator r, Type serviceType, Type dep1Type, Type dep2Type, Type dep3Type, Type dep4Type, Type dep5Type, Type dep6Type, Type dep7Type, Func`8<object, object, object, object, object, object, object, object> factory, IReuse reuse, Setup setup, Nullable`1<IfAlreadyRegistered> ifAlreadyRegistered, object serviceKey);
    [ExtensionAttribute]
public static void RegisterDelegate(IRegistrator registrator, Type serviceType, Func`2<IResolverContext, object> factoryDelegate, IReuse reuse, Setup setup, Nullable`1<IfAlreadyRegistered> ifAlreadyRegistered, object serviceKey);
    [ExtensionAttribute]
[ObsoleteAttribute("Replaced with RegisterDelegate{MyService, Dep1...Dep2, MyService}((service, d1, d2) => new MyServiceDecorator(service, d1, d2), setup: Setup.DecoratorWith(useDecorateeReuse: true, condition: optional))")]
public static void RegisterDelegateDecorator(IRegistrator registrator, Func`2<IResolverContext, Func`2<TService, TService>> getDecorator, Func`2<Request, bool> condition);
    [ExtensionAttribute]
public static void Use(IResolverContext r, Func`2<IResolverContext, TService> factory);
    [ExtensionAttribute]
public static void Use(IResolverContext r, Type serviceType, Func`2<IResolverContext, object> factory);
    [ExtensionAttribute]
public static void Use(IResolverContext r, Func`2<IResolverContext, object> factory);
    [ExtensionAttribute]
public static void Use(IResolverContext r, Type serviceType, object instance);
    [ExtensionAttribute]
public static void Use(IResolverContext r, TService instance);
    [ExtensionAttribute]
public static void Use(IRegistrator r, Func`2<IResolverContext, TService> factory);
    [ExtensionAttribute]
public static void Use(IRegistrator r, Func`2<IResolverContext, object> factory);
    [ExtensionAttribute]
public static void Use(IRegistrator r, Type serviceType, Func`2<IResolverContext, object> factory);
    [ExtensionAttribute]
public static void Use(IRegistrator r, Type serviceType, object instance);
    [ExtensionAttribute]
public static void Use(IRegistrator r, TService instance);
    [ExtensionAttribute]
public static void Use(IContainer c, Func`2<IResolverContext, TService> factory);
    [ExtensionAttribute]
public static void Use(IContainer c, Func`2<IResolverContext, object> factory);
    [ExtensionAttribute]
public static void Use(IContainer c, Type serviceType, Func`2<IResolverContext, object> factory);
    [ExtensionAttribute]
public static void Use(IContainer c, Type serviceType, object instance);
    [ExtensionAttribute]
public static void Use(IContainer c, TService instance);
    [ExtensionAttribute]
public static void RegisterInitializer(IRegistrator registrator, Action`2<TTarget, IResolverContext> initialize, Func`2<Request, bool> condition);
    [ExtensionAttribute]
public static void RegisterInitializer(IRegistrator registrator, Action`2<TTarget, IResolverContext> initialize, IReuse reuse, Func`2<Request, bool> condition);
    internal static TService Initializer(TService service, IResolverContext resolver, Action`2<TTarget, IResolverContext> initialize);
    [ExtensionAttribute]
public static void RegisterDisposer(IRegistrator registrator, Action`1<TService> dispose, Func`2<Request, bool> condition);
    [ExtensionAttribute]
public static bool IsRegistered(IRegistrator registrator, Type serviceType, object serviceKey, FactoryType factoryType, Func`2<Factory, bool> condition);
    [ExtensionAttribute]
public static bool IsRegistered(IRegistrator registrator, object serviceKey, FactoryType factoryType, Func`2<Factory, bool> condition);
    [ExtensionAttribute]
public static void Unregister(IRegistrator registrator, Type serviceType, object serviceKey, FactoryType factoryType, Func`2<Factory, bool> condition);
    [ExtensionAttribute]
public static void Unregister(IRegistrator registrator, object serviceKey, FactoryType factoryType, Func`2<Factory, bool> condition);
    [ExtensionAttribute]
public static void RegisterMapping(IRegistrator registrator, Type serviceType, Type registeredServiceType, Nullable`1<IfAlreadyRegistered> ifAlreadyRegistered, object serviceKey, object registeredServiceKey, FactoryType factoryType);
    [ExtensionAttribute]
public static void RegisterMapping(IRegistrator registrator, Type serviceType, Type registeredServiceType, object serviceKey, object registeredServiceKey, FactoryType factoryType);
    [ExtensionAttribute]
public static void RegisterMapping(IRegistrator registrator, object serviceKey, object registeredServiceKey, FactoryType factoryType);
    [ExtensionAttribute]
public static void RegisterPlaceholder(IRegistrator registrator, Type serviceType, Nullable`1<IfAlreadyRegistered> ifAlreadyRegistered, object serviceKey);
    [ExtensionAttribute]
public static void RegisterPlaceholder(IRegistrator registrator, Nullable`1<IfAlreadyRegistered> ifAlreadyRegistered, object serviceKey);
    [ExtensionAttribute]
public static void RegisterMapping(IContainer container, IfAlreadyRegistered ifAlreadyRegistered, object serviceKey, object registeredServiceKey);
}
public enum DryIoc.RegistrySharing : Enum {
    public byte value__;
    public static RegistrySharing Share;
    public static RegistrySharing CloneButKeepCache;
    public static RegistrySharing CloneAndDropCache;
}
public class DryIoc.Request : object {
    internal static RequestFlags InheritedFlags;
    public static Request Empty;
    internal static Expression EmptyRequestExpr;
    public static Request EmptyOpensResolutionScope;
    [CompilerGeneratedAttribute]
private Container <Container>k__BackingField;
    public Request DirectParent;
    internal Request[] DepRequestStack;
    public RequestFlags Flags;
    internal object ServiceTypeOrInfo;
    internal Expression[] InputArgExprs;
    [CompilerGeneratedAttribute]
private int <FactoryID>k__BackingField;
    [CompilerGeneratedAttribute]
private ConstructorInfo <SelectedConstructor>k__BackingField;
    private int _hashCode;
    [CompilerGeneratedAttribute]
private FactoryType <FactoryType>k__BackingField;
    internal object _factoryOrImplType;
    [CompilerGeneratedAttribute]
private IReuse <Reuse>k__BackingField;
    [CompilerGeneratedAttribute]
private int <DecoratedFactoryID>k__BackingField;
    public int DependencyDepth;
    public int DependencyCount;
    [CompilerGeneratedAttribute]
private Type <ActualServiceType>k__BackingField;
    private static int _depRequestStackDefaultCapacity;
    internal static Lazy`1<MethodInfo> PushMethodWith4Args;
    internal static Lazy`1<MethodInfo> PushMethodWith5Args;
    internal static Lazy`1<MethodInfo> PushMethodWith8Args;
    internal static Lazy`1<MethodInfo> PushMethodWith10Args;
    internal static Lazy`1<MethodInfo> PushMethodWith12Args;
    private static Request _pooledRequest;
    public Container Container { get; private set; }
    internal Factory Factory { get; }
    public int FactoryID { get; private set; }
    public ConstructorInfo SelectedConstructor { get; internal set; }
    public FactoryType FactoryType { get; private set; }
    public Type ImplementationType { get; }
    public IReuse Reuse { get; private set; }
    public int DecoratedFactoryID { get; private set; }
    public bool IsEmpty { get; }
    public bool IsResolutionRoot { get; }
    internal bool AvoidExpressionCaching { get; }
    public bool IsResolutionCall { get; }
    public bool IsNestedResolutionCall { get; }
    public bool OpensResolutionScope { get; }
    public bool TracksTransientDisposable { get; }
    public bool IsSingletonOrDependencyOfSingleton { get; }
    public IScope CurrentScope { get; }
    public IScope SingletonScope { get; }
    public Rules Rules { get; }
    public Made Made { get; }
    public Request Parent { get; }
    public Type ServiceType { get; }
    public Type ActualServiceType { get; private set; }
    public object ServiceKey { get; }
    public IfUnresolved IfUnresolved { get; }
    public Type RequiredServiceType { get; }
    public int ReuseLifespan { get; }
    internal Request(Container container, Request parent, int dependencyDepth, int dependencyCount, Request[] depRequestStack, RequestFlags flags, object serviceInfo, Type actualServiceType, Expression[] inputArgExprs);
    private Request(Container container, Request parent, int dependencyDepth, int dependencyCount, Request[] depRequestStack, RequestFlags flags, object serviceInfo, Type actualServiceType, Expression[] inputArgExprs, object factoryOrImplType, int factoryID, FactoryType factoryType, IReuse reuse, int decoratedFactoryID);
    private static Request();
    internal static Request CreateForValidation(Container container, ServiceInfo serviceInfo, Request[] depRequestStack);
    internal static Request CreateFromServiceType(Container container, Type serviceType, IfUnresolved ifUnresolved);
    internal static Request CreateFromServiceTypeOrInfo(Container container, object serviceTypeOrInfo, Request preResolveParent, RequestFlags flags, Object[] inputArgs);
    public static Request Create(Container container, ServiceInfo serviceInfo, Request preResolveParent, RequestFlags flags, Object[] inputArgs);
    public static Request Create(Container container, Type serviceType, object serviceKey, IfUnresolved ifUnresolved, Type requiredServiceType, Request preResolveParent, RequestFlags flags, Object[] inputArgs);
    [CompilerGeneratedAttribute]
public Container get_Container();
    [CompilerGeneratedAttribute]
private void set_Container(Container value);
    internal Factory get_Factory();
    [CompilerGeneratedAttribute]
public int get_FactoryID();
    [CompilerGeneratedAttribute]
private void set_FactoryID(int value);
    [CompilerGeneratedAttribute]
public ConstructorInfo get_SelectedConstructor();
    [CompilerGeneratedAttribute]
internal void set_SelectedConstructor(ConstructorInfo value);
    [CompilerGeneratedAttribute]
public FactoryType get_FactoryType();
    [CompilerGeneratedAttribute]
private void set_FactoryType(FactoryType value);
    internal int GetCombinedDecoratorAndFactoryID();
    public Type get_ImplementationType();
    public Request WithWrappedServiceFactory(Factory f);
    [CompilerGeneratedAttribute]
public IReuse get_Reuse();
    [CompilerGeneratedAttribute]
private void set_Reuse(IReuse value);
    [CompilerGeneratedAttribute]
public int get_DecoratedFactoryID();
    [CompilerGeneratedAttribute]
private void set_DecoratedFactoryID(int value);
    internal void DecreaseTrackedDependencyCountForParents();
    internal void IncreaseTrackedDependencyCountForParents(int dependencyCount);
    public bool get_IsEmpty();
    public bool get_IsResolutionRoot();
    internal bool get_AvoidExpressionCaching();
    public bool get_IsResolutionCall();
    public bool get_IsNestedResolutionCall();
    public bool get_OpensResolutionScope();
    public bool IsWrappedInFunc();
    public bool IsDirectlyWrappedInFunc();
    public bool IsWrappedInFuncWithArgs();
    public Expression GetInputArgsExpr();
    public bool get_TracksTransientDisposable();
    public bool get_IsSingletonOrDependencyOfSingleton();
    public IScope get_CurrentScope();
    public IScope get_SingletonScope();
    public Rules get_Rules();
    public Made get_Made();
    public Request get_Parent();
    public Type get_ServiceType();
    [CompilerGeneratedAttribute]
public Type get_ActualServiceType();
    [CompilerGeneratedAttribute]
private void set_ActualServiceType(Type value);
    public ServiceDetails GetServiceDetails();
    public object get_ServiceKey();
    public IfUnresolved get_IfUnresolved();
    public Type get_RequiredServiceType();
    public int get_ReuseLifespan();
    public Type GetKnownImplementationOrServiceType();
    private Request& GetOrPushDepRequestStack(int depDepth);
    public Request Push(ServiceInfo info, RequestFlags additionalFlags);
    public Request Push(ParameterInfo parameter, RequestFlags additionalFlags);
    public Request PushServiceType(Type serviceType, RequestFlags additionalFlags);
    public Request Push(Type serviceType, object serviceKey, IfUnresolved ifUnresolved, Type requiredServiceType, RequestFlags flags);
    public Request Push(Type serviceType, int factoryID, Type implementationType, IReuse reuse);
    public Request Push(Type serviceType, int factoryID, Type implementationType, IReuse reuse, RequestFlags flags);
    public Request Push(Type serviceType, Type requiredServiceType, object serviceKey, int factoryID, FactoryType factoryType, Type implementationType, IReuse reuse, RequestFlags flags);
    public Request Push(Type serviceType, Type requiredServiceType, object serviceKey, IfUnresolved ifUnresolved, int factoryID, FactoryType factoryType, Type implementationType, IReuse reuse, RequestFlags flags, int decoratedFactoryID);
    public Request Push(Type serviceType, Type requiredServiceType, object serviceKey, string metadataKey, object metadata, IfUnresolved ifUnresolved, int factoryID, FactoryType factoryType, Type implementationType, IReuse reuse, RequestFlags flags, int decoratedFactoryID);
    public Request WithChangedType(S state, Func`3<Type, S, Type> getInfo);
    public Request WithIfUnresolved(IfUnresolved ifUnresolved);
    public Request WithFlags(RequestFlags newFlags);
    public void ChangeServiceKey(object serviceKey);
    public Request WithInputArgs(Expression[] inputArgs);
    public Request WithResolvedFactory(Factory factory, bool skipRecursiveDependencyCheck, bool skipCaptiveDependencyCheck, bool copyRequest);
    internal Request WithResolvedFactoryUnsafe(Factory factory);
    public bool HasRecursiveParent(int factoryID);
    public bool HasRecursiveParentUntilResolutionRoot(int factoryID);
    public TResult Is(Func`1<TResult> root, Func`2<ParameterInfo, TResult> parameter, Func`2<PropertyInfo, TResult> property, Func`2<FieldInfo, TResult> field);
    [IteratorStateMachineAttribute("DryIoc.Request/<GetEnumerator>d__122")]
public sealed virtual IEnumerator`1<Request> GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    public StringBuilder PrintCurrent(StringBuilder s);
    public StringBuilder PrintRequest(int recursiveFactoryID);
    public virtual string ToString();
    public sealed virtual StringBuilder Print(StringBuilder s, Func`3<StringBuilder, object, StringBuilder> printer);
    public virtual bool Equals(object obj);
    public bool Equals(Request other);
    public bool EqualsWithoutParent(Request other);
    public virtual int GetHashCode();
    internal Request Isolate();
    internal bool CanCache();
    internal Request IsolateRequestChain();
    internal static Request RentRequestOrNull();
    internal void ReturnToPool();
    internal Request CleanBeforePool();
    internal Request SetServiceInfo(Container container, Request parent, int dependencyDepth, int dependencyCount, Request[] depRequestStack, RequestFlags flags, object serviceTypeOrInfo, Type actualServiceType, Expression[] inputArgExprs);
    private void SetResolvedFactory(object factoryOrImplType, int factoryID, FactoryType factoryType, IReuse reuse, int decoratedFactoryID);
}
[FlagsAttribute]
public enum DryIoc.RequestFlags : Enum {
    public ushort value__;
    public static RequestFlags Default;
    public static RequestFlags TracksTransientDisposable;
    public static RequestFlags IsSingletonOrDependencyOfSingleton;
    public static RequestFlags IsWrappedInFunc;
    public static RequestFlags IsResolutionCall;
    public static RequestFlags OpensResolutionScope;
    public static RequestFlags StopRecursiveDependencyCheck;
    public static RequestFlags IsGeneratedResolutionDependencyExpression;
    public static RequestFlags IsDirectlyWrappedInFunc;
    public static RequestFlags DoNotPoolRequest;
    public static RequestFlags DoNotCacheExpression;
}
[ExtensionAttribute]
public static class DryIoc.RequestTools : object {
    [ExtensionAttribute]
public static bool MatchFactoryConditionAndMetadata(Request request, ServiceDetails details, Factory factory);
    [ExtensionAttribute]
public static bool MatchFactoryReuse(Request r, Factory f);
    [ExtensionAttribute]
public static bool MatchGeneratedFactory(Request r, Factory f);
    [ExtensionAttribute]
public static Factory MatchGeneratedFactoryByReuseAndConditionOrNull(Request req, Factory fac);
}
public class DryIoc.ResolutionScopeName : object {
    public Type ServiceType;
    public object ServiceKey;
    private ResolutionScopeName(Type serviceType, object serviceKey);
    public static ResolutionScopeName Of(Type serviceType, object serviceKey);
    public static ResolutionScopeName Of(object serviceKey);
    public sealed virtual bool Match(object scopeName);
    public virtual string ToString();
}
public enum DryIoc.ResolveManyBehavior : Enum {
    public int value__;
    public static ResolveManyBehavior AsLazyEnumerable;
    public static ResolveManyBehavior AsFixedArray;
}
public class DryIoc.ResolveManyResult : ValueType {
    public Func`2<IResolverContext, object> FactoryDelegate;
    public object ServiceKey;
    public Type RequiredServiceType;
    public static ResolveManyResult Of(Func`2<IResolverContext, object> factoryDelegate, object serviceKey, Type requiredServiceType);
}
[ExtensionAttribute]
public static class DryIoc.Resolver : object {
    internal static MethodInfo ResolveFastMethod;
    internal static MethodInfo ResolveMethod;
    internal static MethodInfo ResolveManyMethod;
    internal static ConstructorInfo ResolutionScopeNameCtor;
    private static Resolver();
    [ExtensionAttribute]
public static object Resolve(IResolver resolver, Type serviceType);
    [ExtensionAttribute]
public static object Resolve(IResolver resolver, Type serviceType, IfUnresolved ifUnresolved);
    [ExtensionAttribute]
public static TService Resolve(IResolver resolver, IfUnresolved ifUnresolved);
    [ExtensionAttribute]
public static object Resolve(IResolver resolver, Type serviceType, bool ifUnresolvedReturnDefault);
    [ExtensionAttribute]
public static object Resolve(IResolver resolver, bool ifUnresolvedReturnDefault);
    [ExtensionAttribute]
public static object Resolve(IResolver resolver, Type serviceType, Type requiredServiceType, IfUnresolved ifUnresolved, Object[] args, object serviceKey);
    [ExtensionAttribute]
public static TService Resolve(IResolver resolver, Type requiredServiceType, IfUnresolved ifUnresolved, Object[] args, object serviceKey);
    [ExtensionAttribute]
public static TService Resolve(IResolver resolver, IfUnresolved ifUnresolved, Object[] args, object serviceKey);
    [ExtensionAttribute]
public static object Resolve(IResolver resolver, Type serviceType, object serviceKey, IfUnresolved ifUnresolved, Type requiredServiceType, Object[] args);
    [ExtensionAttribute]
public static TService Resolve(IResolver resolver, object serviceKey, IfUnresolved ifUnresolved, Type requiredServiceType, Object[] args);
    [ExtensionAttribute]
public static object Resolve(IResolver resolver, Type serviceType, Object[] args, IfUnresolved ifUnresolved, Type requiredServiceType, object serviceKey);
    [ExtensionAttribute]
public static TService Resolve(IResolver resolver, Object[] args, IfUnresolved ifUnresolved, Type requiredServiceType, object serviceKey);
    [ExtensionAttribute]
public static IEnumerable`1<TService> ResolveMany(IResolver resolver, Type requiredServiceType, ResolveManyBehavior behavior, Object[] args, object serviceKey);
    [ExtensionAttribute]
public static IEnumerable`1<object> ResolveMany(IResolver resolver, Type serviceType, ResolveManyBehavior behavior, Object[] args, object serviceKey);
    [ExtensionAttribute]
public static object New(IResolver resolver, Type concreteType, Made made, RegistrySharing registrySharing);
    [ExtensionAttribute]
public static T New(IResolver resolver, Made made, RegistrySharing registrySharing);
    [ExtensionAttribute]
public static T New(IResolver resolver, TypedMade`1<T> made, RegistrySharing registrySharing);
    public static Expression CreateResolutionExpression(Request request, bool openResolutionScope, bool stopRecursiveDependencyCheck, bool generateResolutionCallForMissingDependency);
    private static void ResolveAndPopulateDependencyResolutionCallExpressions(Request request, bool generateResolutionCallForMissingDependency);
}
[ExtensionAttribute]
public static class DryIoc.ResolverContext : object {
    internal static MethodInfo OpenScopeMethod;
    public static Expression RootOrSelfExpr;
    public static PropertyExpression SingletonScopeExpr;
    public static PropertyExpression CurrentScopeExpr;
    public static PropertyExpression CurrentOrSingletonScopeExpr;
    public static MethodCallExpression GetCurrentScopeOrThrowExpr;
    private static ResolverContext();
    [ExtensionAttribute]
public static IResolverContext RootOrSelf(IResolverContext r);
    public static Expression GetRootOrSelfExpr(Request request);
    [ExtensionAttribute]
private static bool OpensResolutionScopeUpToResolutionCall(Request r);
    [ExtensionAttribute]
public static bool IsScoped(IResolverContext r);
    [ExtensionAttribute]
public static IScope GetCurrentScopeOrThrow(IResolverContext r);
    [ExtensionAttribute]
public static IScope GetCurrentScope(IResolverContext r, bool throwIfNotFound);
    [ExtensionAttribute]
public static IScope GetNamedScope(IResolverContext r, object name, bool throwIfNotFound);
    [ExtensionAttribute]
public static IResolverContext OpenScope(IResolverContext r, object name, bool trackInParent);
    [ExtensionAttribute]
public static IScope SetNewOpen(IScopeContext ctx);
    [ExtensionAttribute]
public static IScope SetNewOpenWithName(IScopeContext ctx, object name);
    [ExtensionAttribute]
public static IResolverContext OpenScope(IResolverContext r);
    [ExtensionAttribute]
public static bool IsUsed(IResolverContext r, Type serviceType);
    [ExtensionAttribute]
public static bool IsUsed(IResolverContext r);
    [ExtensionAttribute]
internal static bool TryGetUsedInstance(IResolverContext r, int serviceTypeHash, Type serviceType, Object& instance);
    [ExtensionAttribute]
internal static bool TryGetUsedInstance(IResolverContext r, Scope scope, Scope singletons, int serviceTypeHash, Type serviceType, Object& instance);
    [ExtensionAttribute]
public static T TrackDisposable(IResolverContext r, T instance, int disposalOrder);
}
public static class DryIoc.Reuse : object {
    public static IReuse Transient;
    public static IReuse Singleton;
    public static IReuse Scoped;
    public static IReuse ScopedOrSingleton;
    public static IReuse InCurrentScope;
    public static IReuse InThread;
    public static string WebRequestScopeName;
    public static IReuse InWebRequest;
    private static Reuse();
    public static IReuse ScopedTo(object name);
    public static IReuse ScopedTo(object name, bool scopedOrSingleton, int lifespan);
    public static IReuse ScopedTo(Object[] names);
    public static IReuse ScopedToService(Type serviceType, object serviceKey);
    public static IReuse ScopedTo(object serviceKey);
    public static IReuse ScopedToService(object serviceKey);
    public static IReuse InCurrentNamedScope(object name);
}
public class DryIoc.Rules : object {
    public static Rules Default;
    private ImHashMap`2<object, object> _serviceKeyToTypeIndex;
    [ObsoleteAttribute("Please use DryIoc.Microsoft.DependencyInjection.DryIocAdapter.MicrosoftDependencyInjectionRules")]
public static Rules MicrosoftDependencyInjectionRules;
    public static int DefaultDependencyCountInLambdaToSplitBigObjectGraph;
    [CompilerGeneratedAttribute]
private int <DependencyCountInLambdaToSplitBigObjectGraph>k__BackingField;
    [CompilerGeneratedAttribute]
private object <DefaultRegistrationServiceKey>k__BackingField;
    [CompilerGeneratedAttribute]
private FactorySelectorRule <FactorySelector>k__BackingField;
    [CompilerGeneratedAttribute]
private DynamicRegistrationProvider[] <DynamicRegistrationProviders>k__BackingField;
    [CompilerGeneratedAttribute]
private DynamicRegistrationFlags[] <DynamicRegistrationFlags>k__BackingField;
    public static DynamicRegistrationFlags DefaultDynamicRegistrationFlags;
    [CompilerGeneratedAttribute]
private UnknownServiceResolver[] <UnknownServiceResolvers>k__BackingField;
    [CompilerGeneratedAttribute]
private IReuse <DefaultReuse>k__BackingField;
    [CompilerGeneratedAttribute]
private ItemToExpressionConverterRule <ItemToExpressionConverter>k__BackingField;
    [CompilerGeneratedAttribute]
private Ref`1<ImHashMap`2<Request, Expression>> <DependencyResolutionCallExprs>k__BackingField;
    [CompilerGeneratedAttribute]
private IfAlreadyRegistered <DefaultIfAlreadyRegistered>k__BackingField;
    [CompilerGeneratedAttribute]
private ICompileTimeContainer <CompileTimeContainer>k__BackingField;
    internal Made _made;
    internal static Settings DEFAULT_SETTINGS;
    internal Settings _settings;
    public ImHashMap`2<object, object> ServiceKeyToTypeIndex { get; }
    public bool ServiceProviderGetServiceShouldThrowIfUnresolved { get; }
    public int DependencyCountInLambdaToSplitBigObjectGraph { get; private set; }
    public object FactoryMethodOrSelector { get; }
    public ParameterSelector Parameters { get; }
    public PropertiesAndFieldsSelector PropertiesAndFields { get; }
    public bool OverrideRegistrationMade { get; }
    public object DefaultRegistrationServiceKey { get; private set; }
    public FactorySelectorRule FactorySelector { get; private set; }
    public bool IsSelectLastRegisteredFactory { get; }
    public DynamicRegistrationProvider[] DynamicRegistrationProviders { get; private set; }
    public DynamicRegistrationFlags[] DynamicRegistrationFlags { get; private set; }
    public UnknownServiceResolver[] UnknownServiceResolvers { get; private set; }
    public IReuse DefaultReuse { get; private set; }
    public ItemToExpressionConverterRule ItemToExpressionConverter { get; private set; }
    public bool ThrowIfDependencyHasShorterReuseLifespan { get; }
    public bool ThrowIfScopedOrSingletonHasTransientDependency { get; }
    public bool ThrowOnRegisteringDisposableTransient { get; }
    public bool TrackingDisposableTransients { get; }
    public bool EagerCachingSingletonForFasterAccess { get; }
    public Ref`1<ImHashMap`2<Request, Expression>> DependencyResolutionCallExprs { get; private set; }
    public bool UsedForExpressionGeneration { get; }
    public bool UsedForValidation { get; }
    public bool ImplicitCheckForReuseMatchingScope { get; }
    public bool ResolveIEnumerableAsLazyEnumerable { get; }
    public bool VariantGenericTypesInResolvedCollection { get; }
    public bool VariantGenericTypesInResolve { get; }
    public bool HasMultipleSameServiceKeyForTheServiceType { get; }
    public bool GenerateResolutionCallForMissingDependency { get; }
    public IfAlreadyRegistered DefaultIfAlreadyRegistered { get; private set; }
    public bool ThrowIfRuntimeStateRequired { get; }
    public bool ConstantExpressionIsFine { get; }
    public bool CaptureContainerDisposeStackTrace { get; }
    public bool IgnoringReuseForFuncWithArgs { get; }
    public bool FuncAndLazyWithoutRegistration { get; }
    public bool UseInterpretationForTheFirstResolution { get; }
    public bool UseInterpretation { get; }
    public bool UseDecorateeReuseForDecorators { get; }
    public ICompileTimeContainer CompileTimeContainer { get; private set; }
    private Rules(Settings settings, FactorySelectorRule factorySelector, IReuse defaultReuse, Made made, IfAlreadyRegistered defaultIfAlreadyRegistered, int dependencyCountInLambdaToSplitBigObjectGraph, Ref`1<ImHashMap`2<Request, Expression>> dependencyResolutionCallExprs, ItemToExpressionConverterRule itemToExpressionConverter, DynamicRegistrationProvider[] dynamicRegistrationProviders, DynamicRegistrationFlags[] dynamicRegistrationProvidersFlags, UnknownServiceResolver[] unknownServiceResolvers, object defaultRegistrationServiceKey, ImHashMap`2<object, object> serviceKeyToTypeIndex);
    private static Rules();
    public ImHashMap`2<object, object> get_ServiceKeyToTypeIndex();
    public object EnsureUniqueServiceKey(object serviceTypeOrName, object serviceKey);
    public object GetServiceTypesByServiceKeyOrDefault(object serviceKey);
    private static Rules WithMicrosoftDependencyInjectionRules(Rules rules, ParameterSelector parameters);
    [ObsoleteAttribute("Please use DryIoc.Microsoft.DependencyInjection.DryIocAdapter.HasMicrosoftDependencyInjectionRules")]
public bool HasMicrosoftDependencyInjectionRules();
    public bool HasBaseMicrosoftDependencyInjectionRules(Rules exactRulesToCompare);
    [ObsoleteAttribute("Please use DryIoc.Microsoft.DependencyInjection.DryIocAdapter.WithMicrosoftDependencyInjectionRules")]
public Rules WithMicrosoftDependencyInjectionRules();
    public Rules WithBaseMicrosoftDependencyInjectionRules(ParameterSelector parameters);
    public Rules WithServiceProviderGetServiceShouldThrowIfUnresolved();
    public bool get_ServiceProviderGetServiceShouldThrowIfUnresolved();
    [CompilerGeneratedAttribute]
public int get_DependencyCountInLambdaToSplitBigObjectGraph();
    [CompilerGeneratedAttribute]
private void set_DependencyCountInLambdaToSplitBigObjectGraph(int value);
    public Rules WithDependencyCountInLambdaToSplitBigObjectGraph(int dependencyCount);
    public Rules WithoutDependencyCountInLambdaToSplitBigObjectGraph();
    public object get_FactoryMethodOrSelector();
    public ParameterSelector get_Parameters();
    public PropertiesAndFieldsSelector get_PropertiesAndFields();
    public bool get_OverrideRegistrationMade();
    public ParameterSelector TryGetParameterSelector(Made made);
    public PropertiesAndFieldsSelector TryGetPropertiesAndFieldsSelector(Made made);
    public Rules With(FactoryMethodSelector factoryMethod, ParameterSelector parameters, PropertiesAndFieldsSelector propertiesAndFields);
    public Rules With(Made made, bool overrideRegistrationMade);
    [CompilerGeneratedAttribute]
public object get_DefaultRegistrationServiceKey();
    [CompilerGeneratedAttribute]
private void set_DefaultRegistrationServiceKey(object value);
    public Rules WithDefaultRegistrationServiceKey(object serviceKey);
    [CompilerGeneratedAttribute]
public FactorySelectorRule get_FactorySelector();
    [CompilerGeneratedAttribute]
private void set_FactorySelector(FactorySelectorRule value);
    public Rules WithFactorySelector(FactorySelectorRule rule);
    public static FactorySelectorRule SelectLastRegisteredFactory();
    private static Factory SelectLastRegisteredFactory(Request request, Factory singleDefaultFactory, KV`2[] orManyDefaultAndKeyedFactories);
    public bool get_IsSelectLastRegisteredFactory();
    public static FactorySelectorRule SelectFactoryWithTheMinReuseLifespan();
    public static FactorySelectorRule SelectFactoryWithTheMinReuseLifespanOrLastRegistered();
    public static FactorySelectorRule SelectKeyedOverDefaultFactory(object serviceKey);
    private static Factory SelectFactoryWithTheMinReuseLifespan(Request request, Factory singleDefaultFactory, KV`2[] orManyDefaultAndKeyedFactories);
    [CompilerGeneratedAttribute]
public DynamicRegistrationProvider[] get_DynamicRegistrationProviders();
    [CompilerGeneratedAttribute]
private void set_DynamicRegistrationProviders(DynamicRegistrationProvider[] value);
    public bool HasDynamicRegistrationProvider(DynamicRegistrationFlags withFlags, DynamicRegistrationFlags withoutFlags);
    public Rules WithDynamicRegistration(DynamicRegistrationProvider provider, DynamicRegistrationFlags flags);
    public Rules WithoutDynamicRegistration(DynamicRegistrationProvider provider);
    public static DynamicRegistrationProvider DynamicRegistrationOf(Func`2<Type, Factory> getFactoryOrNull);
    public Rules WithDynamicRegistration(Func`2<Type, Factory> getFactoryOrNull);
    [CompilerGeneratedAttribute]
public DynamicRegistrationFlags[] get_DynamicRegistrationFlags();
    [CompilerGeneratedAttribute]
private void set_DynamicRegistrationFlags(DynamicRegistrationFlags[] value);
    public Rules WithDynamicRegistrations(DynamicRegistrationProvider[] rules);
    public Rules WithDynamicRegistrationsAsFallback(DynamicRegistrationProvider[] rules);
    public Rules WithDynamicRegistrations(DynamicRegistrationFlags flags, DynamicRegistrationProvider[] rules);
    private DynamicRegistrationFlags[] WithDynamicRegistrationProviderFlags(int count, DynamicRegistrationFlags flags);
    public Rules WithDynamicRegistrationsAsFallback(DynamicRegistrationFlags flags, DynamicRegistrationProvider[] rules);
    [CompilerGeneratedAttribute]
public UnknownServiceResolver[] get_UnknownServiceResolvers();
    [CompilerGeneratedAttribute]
private void set_UnknownServiceResolvers(UnknownServiceResolver[] value);
    public Rules WithUnknownServiceResolvers(UnknownServiceResolver[] rules);
    public Rules WithoutUnknownServiceResolver(UnknownServiceResolver rule);
    public Rules WithUnknownServiceHandler(Action`1<Request> handler);
    public static UnknownServiceResolver AutoResolveConcreteTypeRule(Func`2<Request, bool> condition);
    private static IEnumerable`1<Type> GetConcreteServiceType(Type serviceType, object serviceKey);
    private static IEnumerable`1<Type> GetConcreteServiceType(Type serviceType, object serviceKey, Func`3<Type, object, bool> serviceCondition);
    private static Factory GetConcreteTypeFactory(Type implType, IReuse reuse, IfUnresolved ifConcreteTypeIsUnresolved);
    public static DynamicRegistrationProvider ConcreteTypeDynamicRegistrations(Func`3<Type, object, bool> condition, IReuse reuse);
    public static DynamicRegistrationProvider ConcreteTypeDynamicRegistrations(IfUnresolved ifConcreteTypeIsUnresolved, Func`3<Type, object, bool> serviceCondition, IReuse reuse);
    public Rules WithConcreteTypeDynamicRegistrations(Func`3<Type, object, bool> condition, IReuse reuse);
    public Rules WithConcreteTypeDynamicRegistrations(IfUnresolved ifConcreteTypeIsUnresolved, Func`3<Type, object, bool> condition, IReuse reuse);
    public Rules WithAutoConcreteTypeResolution(Func`2<Request, bool> condition);
    public static DynamicRegistrationProvider AutoFallbackDynamicRegistrations(Func`3<Type, object, IEnumerable`1<Type>> getImplementationTypes, Func`2<Type, Factory> factory);
    [CompilerGeneratedAttribute]
public IReuse get_DefaultReuse();
    [CompilerGeneratedAttribute]
private void set_DefaultReuse(IReuse value);
    public Rules WithDefaultReuse(IReuse reuse);
    [CompilerGeneratedAttribute]
public ItemToExpressionConverterRule get_ItemToExpressionConverter();
    [CompilerGeneratedAttribute]
private void set_ItemToExpressionConverter(ItemToExpressionConverterRule value);
    public Rules WithItemToExpressionConverter(ItemToExpressionConverterRule itemToExpressionOrDefault);
    public bool get_ThrowIfDependencyHasShorterReuseLifespan();
    public Rules WithoutThrowIfDependencyHasShorterReuseLifespan();
    public bool get_ThrowIfScopedOrSingletonHasTransientDependency();
    public Rules WithThrowIfScopedOrSingletonHasTransientDependency();
    public Rules WithoutThrowIfScopedOrSingletonHasTransientDependency();
    public bool get_ThrowOnRegisteringDisposableTransient();
    public Rules WithoutThrowOnRegisteringDisposableTransient();
    public bool get_TrackingDisposableTransients();
    public Rules WithTrackingDisposableTransients();
    public bool get_EagerCachingSingletonForFasterAccess();
    public Rules WithoutTrackingDisposableTransients();
    public Rules WithoutEagerCachingSingletonForFasterAccess();
    [CompilerGeneratedAttribute]
public Ref`1<ImHashMap`2<Request, Expression>> get_DependencyResolutionCallExprs();
    [CompilerGeneratedAttribute]
private void set_DependencyResolutionCallExprs(Ref`1<ImHashMap`2<Request, Expression>> value);
    public bool get_UsedForExpressionGeneration();
    private Settings GetSettingsForExpressionGeneration(bool allowRuntimeState);
    public Rules WithExpressionGeneration(bool allowRuntimeState);
    public Rules WithExpressionGenerationSettingsOnly(bool allowRuntimeState);
    public bool get_UsedForValidation();
    private Settings GetSettingsForValidation();
    public Rules ForValidate();
    public bool get_ImplicitCheckForReuseMatchingScope();
    public Rules WithoutImplicitCheckForReuseMatchingScope();
    public bool get_ResolveIEnumerableAsLazyEnumerable();
    public Rules WithResolveIEnumerableAsLazyEnumerable();
    public bool get_VariantGenericTypesInResolvedCollection();
    public Rules WithVariantGenericTypesInResolvedCollection();
    public Rules WithoutVariantGenericTypesInResolvedCollection();
    public bool get_VariantGenericTypesInResolve();
    public Rules WithVariantGenericTypesInResolve();
    public Rules WithoutVariantGenericTypesInResolve();
    public bool get_HasMultipleSameServiceKeyForTheServiceType();
    public Rules WithMultipleSameServiceKeyForTheServiceType();
    public bool get_GenerateResolutionCallForMissingDependency();
    public Rules WithGenerateResolutionCallForMissingDependency();
    public Rules WithoutGenerateResolutionCallForMissingDependency();
    [CompilerGeneratedAttribute]
public IfAlreadyRegistered get_DefaultIfAlreadyRegistered();
    [CompilerGeneratedAttribute]
private void set_DefaultIfAlreadyRegistered(IfAlreadyRegistered value);
    public Rules WithDefaultIfAlreadyRegistered(IfAlreadyRegistered rule);
    public bool get_ThrowIfRuntimeStateRequired();
    public bool get_ConstantExpressionIsFine();
    public Rules WithThrowIfRuntimeStateRequired();
    public bool get_CaptureContainerDisposeStackTrace();
    public Rules WithCaptureContainerDisposeStackTrace();
    public bool get_IgnoringReuseForFuncWithArgs();
    public Rules WithIgnoringReuseForFuncWithArgs();
    public bool get_FuncAndLazyWithoutRegistration();
    public Rules WithFuncAndLazyWithoutRegistration();
    public Rules WithoutFuncAndLazyWithoutRegistration();
    public bool get_UseInterpretationForTheFirstResolution();
    public Rules WithCompileServiceExpressionOnTheFirstResolution();
    public Rules WithoutInterpretationForTheFirstResolution();
    public bool get_UseInterpretation();
    public Rules WithUseInterpretation();
    public Rules WithoutUseInterpretation();
    public bool get_UseDecorateeReuseForDecorators();
    public Rules WithUseDecorateeReuseForDecorators();
    public virtual string ToString();
    public Rules With(Made newMade);
    public Rules Clone(bool cloneMade);
    private Rules WithSettings(Settings newSettings);
    [CompilerGeneratedAttribute]
public ICompileTimeContainer get_CompileTimeContainer();
    [CompilerGeneratedAttribute]
private void set_CompileTimeContainer(ICompileTimeContainer value);
    public Rules WithCompileTimeContainer(ICompileTimeContainer container);
}
public class DryIoc.Scope : object {
    internal int _disposed;
    private ImHashMap`2<int, ImList`1<IDisposable>> _disposables;
    internal ImHashMap`2<Type, object> _used;
    internal static int MAP_COUNT;
    internal static int MAP_COUNT_SUFFIX_MASK;
    internal ImHashMap`2[] _maps;
    internal static object NoItem;
    private static ImHashMap`2[] _emptyMaps;
    internal static MethodInfo GetOrAddViaFactoryDelegateMethod;
    internal static MethodInfo GetOrAddViaFactoryDelegateWithDisposalOrderMethod;
    public static int WaitForScopedServiceIsCreatedTimeoutMilliseconds;
    internal static MethodInfo TrackDisposableOpenGenericMethod;
    public IScope Parent { get; }
    public object Name { get; }
    public bool IsDisposed { get; }
    protected Scope(ImHashMap`2[] maps, ImHashMap`2<Type, object> used, ImHashMap`2<int, ImList`1<IDisposable>> disposables);
    private static Scope();
    public virtual IScope get_Parent();
    public virtual object get_Name();
    public sealed virtual bool get_IsDisposed();
    private static ImHashMap`2[] CreateEmptyMaps();
    private static ImHashMap`2<int, ImList`1<IDisposable>> CreateEmptyDisposables();
    internal ImHashMap`2[] CloneMaps();
    public static IScope Of(IScope parent, object name);
    public static IScope Of(IScope parent);
    public static IScope OfSomeParent(IScope parent);
    public static IScope Of(object name);
    public virtual IScope Clone(bool withDisposables);
    public sealed virtual object GetOrAddViaFactoryDelegate(int id, Func`2<IResolverContext, object> createValue, IResolverContext r);
    public sealed virtual object GetOrAddViaFactoryDelegateWithDisposalOrder(int id, Func`2<IResolverContext, object> createValue, IResolverContext r, int disposalOrder);
    internal object TryGetOrAddViaFactoryDelegate(int id, Func`2<IResolverContext, object> createValue, IResolverContext r, int disposalOrder);
    internal static object WaitForItemIsSet(ImHashMapEntry`2<int, object> itemRef);
    public sealed virtual object TryGetOrAddWithoutClosure(int id, IResolverContext resolverContext, Expression expr, Func`3<IResolverContext, Expression, object> createValue, int disposalOrder);
    public sealed virtual void SetOrAdd(int id, object item);
    internal void AddDisposable(IDisposable disposable, int disposalOrder);
    internal void AddUnorderedDisposable(IDisposable disposable);
    private ImHashMapEntry`2<int, ImList`1<IDisposable>> AddDisposableEntry(int disposableOrder);
    public sealed virtual bool TryGet(Object& item, int id);
    public sealed virtual T TrackDisposable(T item, int disposalOrder);
    public sealed virtual void SetUsed(int hash, Type type, object instance);
    public sealed virtual bool TryGetUsed(int hash, Type type, Object& used);
    [IteratorStateMachineAttribute("DryIoc.Scope/<GetEnumerator>d__42")]
public sealed virtual IEnumerator`1<IScope> GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    public sealed virtual void Dispose();
    private static void SafelyDisposeOrderedDisposables(ImHashMap`2<int, ImList`1<IDisposable>> disposables);
    public virtual string ToString();
}
internal class DryIoc.ScopedItemException : object {
    public Exception Ex;
    public ScopedItemException(Exception ex);
    internal void ReThrow();
}
public class DryIoc.ScopeName : object {
    public Func`2<object, bool> MatchPredicate;
    private ScopeName(Func`2<object, bool> matchPredicate);
    public static ScopeName Of(Func`2<object, bool> matchPredicate);
    public sealed virtual bool Match(object scopeName);
}
[ExtensionAttribute]
public static class DryIoc.ScopeTools : object {
    [ExtensionAttribute]
internal static IScope AsScopeOrNull(IDisposable scopeOrContextOrNull);
    [ExtensionAttribute]
public static IScope Clone(IScope s);
    [ExtensionAttribute]
public static bool IsUsed(IScope s, Type serviceType);
    [ExtensionAttribute]
public static void UseFactory(IScope s, Type type, Func`2<IResolverContext, object> factory);
    [ExtensionAttribute]
public static void UseFactory(IScope s, Func`2<IResolverContext, object> factory);
    [ExtensionAttribute]
public static void Use(IScope s, Type type, object instance);
    [ExtensionAttribute]
public static void Use(IScope s, object instance);
}
public class DryIoc.ServiceDetails : object {
    public static ServiceDetails Default;
    public static ServiceDetails IfUnresolvedReturnDefault;
    public static ServiceDetails IfUnresolvedReturnDefaultIfNotRegistered;
    public Type RequiredServiceType;
    public object ServiceKey;
    public string MetadataKey;
    public object Metadata;
    public bool HasCustomValue;
    private object _value;
    public IfUnresolved IfUnresolved;
    public object DefaultValue { get; }
    public object CustomValue { get; }
    internal ServiceDetails(Type requiredServiceType, IfUnresolved ifUnresolved, object serviceKey, string metadataKey, object metadata, object value, bool hasCustomValue);
    private static ServiceDetails();
    public static ServiceDetails Of(IfUnresolved ifUnresolved);
    public static ServiceDetails Of(Type requiredServiceType, object serviceKey, IfUnresolved ifUnresolved, object defaultValue, string metadataKey, object metadata);
    public static ServiceDetails Of(object value);
    public static ServiceDetails OfValue(object value);
    public static ServiceDetails OfServiceKey(object serviceKey);
    public static ServiceDetails WithServiceKey(ServiceDetails d, object serviceKey);
    public object get_DefaultValue();
    public object get_CustomValue();
    public virtual string ToString();
    public bool Equals(ServiceDetails d);
}
public abstract class DryIoc.ServiceInfo : object {
    public Type ServiceType { get; }
    public ServiceDetails Details { get; }
    public object ServiceKey { get; }
    public static ServiceInfo OfServiceAndRequiredType(Type serviceType, Type requiredServiceType, IfUnresolved ifUnresolved, object serviceKey, string metadataKey, object metadata);
    public abstract virtual Type get_ServiceType();
    public virtual ServiceDetails get_Details();
    public object get_ServiceKey();
    public virtual ServiceInfo Create(Type serviceType, ServiceDetails details);
    public static ServiceInfo Of(Type serviceType);
    public static ServiceInfo Of(Type serviceType, IfUnresolved ifUnresolved);
    public static ServiceInfo Of(Type serviceType, object serviceKey);
    public static ServiceInfo Of(Type serviceType, ServiceDetails details);
    public static ServiceInfo Of(Type serviceType, IfUnresolved ifUnresolved, object serviceKey);
    public static ServiceInfo Of(Type serviceType, Type requiredServiceType, IfUnresolved ifUnresolved, object serviceKey, string metadataKey, object metadata);
    internal static object OrServiceType(Type serviceType, Type requiredServiceType, IfUnresolved ifUnresolved, object serviceKey, string metadataKey, object metadata);
    public static Typed`1<TService> Of(IfUnresolved ifUnresolved, object serviceKey);
    public virtual string ToString();
}
[ExtensionAttribute]
public static class DryIoc.ServiceInfoTools : object {
    [ExtensionAttribute]
public static ServiceInfo WithType(ServiceInfo source, Type serviceType);
    [ExtensionAttribute]
public static ServiceInfo WithIfUnresolved(ServiceInfo source, IfUnresolved ifUnresolved);
    [ExtensionAttribute]
public static T WithDetails(T serviceInfo, ServiceDetails details);
    [ExtensionAttribute]
public static ServiceInfo InheritInfoFromDependencyOwner(ServiceInfo dependency, Type ownerServiceType, ServiceDetails ownerDetails, IContainer container, FactoryType ownerType);
    [ExtensionAttribute]
public static object InheritInfoFromDependencyOwner(Type serviceType, Type ownerServiceType, ServiceDetails ownerDetails, IContainer container, FactoryType ownerType);
    [ExtensionAttribute]
public static Type GetActualServiceType(ServiceInfo info);
    [ExtensionAttribute]
public static Type GetActualServiceType(ServiceDetails details, Type serviceType);
    [ExtensionAttribute]
public static StringBuilder Print(StringBuilder s, ServiceInfo info);
}
public class DryIoc.ServiceKeyAndRequiredOpenGenericType : object {
    public Type RequiredServiceType;
    public object ServiceKey;
    private static ConstructorInfo _ctor;
    public ServiceKeyAndRequiredOpenGenericType(Type requiredServiceType, object serviceKey);
    private static ServiceKeyAndRequiredOpenGenericType();
    public virtual string ToString();
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public sealed virtual Expression ToExpression(S state, Func`3<S, object, Expression> fallbackConverter);
}
public class DryIoc.ServiceKeyToTypeIndex : object {
    private ImHashMap`2<object, object> _index;
    public object EnsureUniqueServiceKey(object serviceTypeOrName, object serviceKey);
    public static object EnsureUniqueServiceKey(ImHashMap`2& index, object serviceTypeOrName, object serviceKey);
    public object GetServiceTypesOrDefault(object serviceKey);
    [CompilerGeneratedAttribute]
internal static ImHashMap`2<object, object> <EnsureUniqueServiceKey>g__UpdateMap|2_0(ImHashMap`2<object, object> m, Object& t, Object& k);
    [CompilerGeneratedAttribute]
internal static object <EnsureUniqueServiceKey>g__UpdateTypes|2_1(object originalKey, object oldTypeOrTypes, object newTypeOrName, Object& uniqueKey);
}
public class DryIoc.ServiceRegistrationInfo : ValueType {
    public Factory Factory;
    public Type ServiceType;
    public object OptionalServiceKey;
    public int FactoryRegistrationOrder { get; }
    public Type ImplementationType { get; }
    public bool AsResolutionRoot { get; }
    public ServiceRegistrationInfo(Factory factory, Type serviceType, object optionalServiceKey);
    public int get_FactoryRegistrationOrder();
    public Type get_ImplementationType();
    public bool get_AsResolutionRoot();
    public ServiceInfo ToServiceInfo();
    public ServiceInfo ToServiceInfo(Type serviceType);
    public ServiceInfo ToServiceInfo();
    public sealed virtual int CompareTo(ServiceRegistrationInfo other);
    public virtual string ToString();
}
public class DryIoc.SetCurrentScopeHandler : MulticastDelegate {
    public SetCurrentScopeHandler(object object, IntPtr method);
    public virtual IScope Invoke(IScope oldScope);
    public virtual IAsyncResult BeginInvoke(IScope oldScope, AsyncCallback callback, object object);
    public virtual IScope EndInvoke(IAsyncResult result);
}
public abstract class DryIoc.Setup : object {
    [CompilerGeneratedAttribute]
private Func`2<Request, bool> <Condition>k__BackingField;
    [CompilerGeneratedAttribute]
private int <DisposalOrder>k__BackingField;
    public static Setup AsResolutionCallSetup;
    internal static Setup AsResolutionCallForGeneratedExpressionSetup;
    protected Settings _settings;
    public static Setup Default;
    public static Setup Wrapper;
    internal static Setup WrapperWithPreventDisposal;
    public static Setup Decorator;
    public FactoryType FactoryType { get; }
    public Func`2<Request, bool> Condition { get; }
    public int DisposalOrder { get; }
    public object Metadata { get; }
    public bool AsResolutionCall { get; }
    public bool AsResolutionCallForExpressionGeneration { get; }
    public bool AsResolutionRoot { get; }
    public bool OpenResolutionScope { get; }
    public bool WeaklyReferenced { get; }
    public bool AllowDisposableTransient { get; }
    public bool TrackDisposableTransient { get; }
    public bool UseParentReuse { get; }
    public bool PreventDisposal { get; }
    internal bool WeaklyReferencedOrPreventDisposal { get; }
    public bool PreferInSingleServiceResolve { get; }
    public bool AvoidResolutionScopeTracking { get; }
    private Setup(Func`2<Request, bool> condition, bool openResolutionScope, bool asResolutionCall, bool asResolutionRoot, bool preventDisposal, bool weaklyReferenced, bool allowDisposableTransient, bool trackDisposableTransient, bool useParentReuse, int disposalOrder, bool preferOverMultipleResolved, bool asResolutionCallForExpressionGeneration, bool avoidResolutionScopeTracking);
    private static Setup();
    public abstract virtual FactoryType get_FactoryType();
    [CompilerGeneratedAttribute]
public Func`2<Request, bool> get_Condition();
    [CompilerGeneratedAttribute]
public int get_DisposalOrder();
    public virtual object get_Metadata();
    public bool MatchesMetadata(string metadataKey, object metadata);
    public object GetMetadataValueMatchedByMetadataType(Type metadataType);
    public bool get_AsResolutionCall();
    public bool get_AsResolutionCallForExpressionGeneration();
    internal Setup WithAsResolutionCallForGeneratedExpression();
    public bool get_AsResolutionRoot();
    public bool get_OpenResolutionScope();
    public bool get_WeaklyReferenced();
    public bool get_AllowDisposableTransient();
    public bool get_TrackDisposableTransient();
    public bool get_UseParentReuse();
    public bool get_PreventDisposal();
    internal bool get_WeaklyReferencedOrPreventDisposal();
    public bool get_PreferInSingleServiceResolve();
    public bool get_AvoidResolutionScopeTracking();
    public static Setup With(object metadataOrFuncOfMetadata, Func`2<Request, bool> condition, bool openResolutionScope, bool asResolutionCall, bool asResolutionRoot, bool preventDisposal, bool weaklyReferenced, bool allowDisposableTransient, bool trackDisposableTransient, bool useParentReuse, int disposalOrder, bool preferInSingleServiceResolve, bool avoidResolutionScopeTracking);
    private static Setup CreateWrapperWithPreventDisposal();
    public static Setup WrapperWith(int wrappedServiceTypeArgIndex, bool alwaysWrapsRequiredServiceType, Func`2<Type, Type> unwrap, bool openResolutionScope, bool asResolutionCall, bool preventDisposal, bool weaklyReferenced, bool allowDisposableTransient, bool trackDisposableTransient, bool useParentReuse, Func`2<Request, bool> condition, int disposalOrder, bool avoidResolutionScopeTracking);
    public static Setup DecoratorWith(Func`2<Request, bool> condition, int order, bool useDecorateeReuse, bool openResolutionScope, bool asResolutionCall, bool preventDisposal, bool weaklyReferenced, bool allowDisposableTransient, bool trackDisposableTransient, int disposalOrder, bool avoidResolutionScopeTracking);
    public static Func`2<Request, bool> GetDecorateeCondition(Type decorateeType, object decorateeServiceKey, Func`2<Request, bool> condition);
    public static Setup DecoratorOf(Type decorateeType, int order, bool useDecorateeReuse, bool openResolutionScope, bool asResolutionCall, bool preventDisposal, bool weaklyReferenced, bool allowDisposableTransient, bool trackDisposableTransient, int disposalOrder, object decorateeServiceKey);
    public static Setup DecoratorOf(int order, bool useDecorateeReuse, bool openResolutionScope, bool asResolutionCall, bool preventDisposal, bool weaklyReferenced, bool allowDisposableTransient, bool trackDisposableTransient, int disposalOrder, object decorateeServiceKey);
}
public class DryIoc.SingletonReuse : object {
    public static int DefaultLifespan;
    private static Lazy`1<Expression> _singletonReuseExpr;
    public int Lifespan { get; }
    public object Name { get; }
    private static SingletonReuse();
    public sealed virtual int get_Lifespan();
    public sealed virtual object get_Name();
    public sealed virtual bool CanApply(Request request);
    public sealed virtual Expression Apply(Request request, Expression serviceFactoryExpr);
    public sealed virtual Expression ToExpression(S state, Func`3<S, object, Expression> fallbackConverter);
    public virtual string ToString();
}
public class DryIoc.ThreadScopeContext : object {
    public static string ScopeContextName;
    private ThreadLocal`1<IScope> _scope;
    private static ThreadScopeContext();
    public sealed virtual IScope GetCurrentOrDefault();
    public sealed virtual IScope SetCurrent(SetCurrentScopeHandler setCurrentScope);
    public sealed virtual void Dispose();
}
[ExtensionAttribute]
public static class DryIoc.Throw : object {
    private static String[] _defaultMessages;
    private static GetMatchedExceptionHandler _getMatchedException;
    public static GetMatchedExceptionHandler GetMatchedException { get; public set; }
    private static Throw();
    private static String[] CreateDefaultMessages();
    public static string GetDefaultMessage(ErrorCheck error);
    public static GetMatchedExceptionHandler get_GetMatchedException();
    public static void set_GetMatchedException(GetMatchedExceptionHandler value);
    public static void If(bool throwCondition, int error, object arg0, object arg1, object arg2, object arg3);
    [ExtensionAttribute]
public static T ThrowIf(T arg0, bool throwCondition, int error, object arg1, object arg2, object arg3);
    [ExtensionAttribute]
public static T ThrowIfNull(T arg, int error, object arg0, object arg1, object arg2, object arg3);
    [ExtensionAttribute]
public static T ThrowIfNotInstanceOf(T arg0, Type arg1, int error, object arg2, object arg3);
    [ExtensionAttribute]
public static Type ThrowIfNotImplementedBy(Type arg0, Type arg1, int error, object arg2, object arg3);
    public static T IfThrows(Func`1<T> operation, bool throwCondition, int error, object arg0, object arg1, object arg2, object arg3);
    public static object It(int error, object arg0, object arg1, object arg2, object arg3);
    public static object WithDetails(object details, int error, object arg0, object arg1, object arg2, object arg3);
    public static T For(int error, object arg0, object arg1, object arg2, object arg3);
    public static T For(bool throwCondition, int error, object arg0, object arg1, object arg2, object arg3);
    public static bool When(bool throwIfInvalid, int error, object arg0, object arg1, object arg2, object arg3);
    public static void Many(int error, ContainerException[] errors);
    public static void ScopeIsDisposed(IScope scope, IResolverContext r);
    public static void StateIsRequiredToUseItem(object item, Type itemType);
}
[ExtensionAttribute]
public static class DryIoc.ThrowInGeneratedCode : object {
    internal static MethodInfo WeakRefReuseWrapperGCedMethod;
    private static ThrowInGeneratedCode();
    [ExtensionAttribute]
public static object WeakRefReuseWrapperGCed(object obj);
}
internal class DryIoc.UniqueRegisteredServiceKey : object {
    public int Index;
    public object ServiceKey;
    private static ConstructorInfo _ctor;
    internal UniqueRegisteredServiceKey(object serviceKey);
    public UniqueRegisteredServiceKey(object serviceKey, int index);
    private static UniqueRegisteredServiceKey();
    public sealed virtual StringBuilder Print(StringBuilder s, Func`3<StringBuilder, object, StringBuilder> printer);
    public virtual string ToString();
    public static bool Equals(UniqueRegisteredServiceKey key, object obj);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public sealed virtual Expression ToExpression(S state, Func`3<S, object, Expression> fallbackConverter);
}
public class DryIoc.WrapperExpressionFactory : Factory {
    private Func`3<Request, Factory, Expression> _getServiceExpression;
    public IReuse Reuse { get; }
    public Setup Setup { get; }
    private WrapperExpressionFactory(Func`3<Request, Factory, Expression> getServiceExpression);
    public static WrapperExpressionFactory Of(Func`3<Request, Factory, Expression> getServiceExpression);
    public static WrapperExpressionFactory Of(Func`3<Request, Factory, Expression> getServiceExpression, Setup setup);
    public static WrapperExpressionFactory Of(Func`3<Request, Factory, Expression> getServiceExpression, IReuse reuse, Setup setup);
    public virtual IReuse get_Reuse();
    public virtual Setup get_Setup();
    public virtual Expression CreateExpressionOrDefault(Request request);
    public virtual Expression CreateExpressionWithWrappedFactory(Request request, Factory serviceFactory);
}
[ExtensionAttribute]
public static class DryIoc.WrappersSupport : object {
    public static Type[] FuncTypes;
    public static Type[] ActionTypes;
    public static Type[] SupportedCollectionTypes;
    [CompilerGeneratedAttribute]
private static int <CollectionWrapperID>k__BackingField;
    public static ImHashMap`2<Type, object> Wrappers;
    internal static MethodInfo ToArrayMethod;
    private static MethodInfo _enumerableCastMethod;
    private static MethodInfo _wrapInDictionaryMethod;
    internal static int CollectionWrapperID { get; private set; }
    private static WrappersSupport();
    [ExtensionAttribute]
public static bool IsFunc(Type type);
    [CompilerGeneratedAttribute]
internal static int get_CollectionWrapperID();
    [CompilerGeneratedAttribute]
private static void set_CollectionWrapperID(int value);
    private static ImHashMap`2<Type, object> BuildSupportedWrappers();
    [ExtensionAttribute]
private static ImHashMap`2<Type, object> AddContainerInterfaces(ImHashMap`2<Type, object> wrappers);
    private static Expression GetArrayExpression(Request request, Type collectionType);
    internal static object EnsureItemKeyCanBeMatched(object resolutionKey, object itemKey, bool multipleSameServiceKeySupport);
    private static Expression GetLazyEnumerableExpressionOrDefault(Request request, Type itemType);
    public static Expression GetLazyExpressionOrDefault(Request request, Factory serviceFactory);
    public static Expression GetFuncOrActionExpressionOrDefault(Request request, Factory serviceFactory);
    public static Expression GetDictionaryExpressionOrDefault(Request request);
    public static IDictionary`2<K, V> WrapInDictionary(KeyValuePair`2[] pairs);
    private static Expression GetLambdaExpressionExpressionOrDefault(Request request);
    private static Expression GetFastExpressionCompilerLambdaExpressionExpressionOrDefault(Request request);
    private static Expression GetKeyValuePairExpressionOrDefault(Request request, Factory serviceFactory);
    public static Expression GetMetaExpressionOrDefault(Request request, Factory serviceFactory);
    [ExtensionAttribute]
public static bool MatchMetadataType(Factory f, Type metadataType);
}
public abstract class Example.BaseA : object {
}
public class Example.BaseAConsumer : object {
    public IDictionary`2<object, BaseA> Addict;
    public BaseAConsumer(IDictionary`2<object, BaseA> addict);
}
public class Example.DependencyA : object {
}
public class Example.DependencyB`1 : ValueType {
    public IDependencyA A;
    public DependencyB`1(IDependencyA a);
}
public interface Example.IDependencyA {
}
public interface Example.IService {
}
public class Example.KeyedA : BaseA {
}
public class Example.MyService : object {
    public MyService(IDependencyA a, DependencyB`1<string> b, RuntimeDependencyC c);
}
public class Example.NonKeyedA : BaseA {
}
public class Example.RuntimeDependencyC : object {
}
