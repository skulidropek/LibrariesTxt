[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class DynamicData.Aggregation.AggregateEnumerator`1 : object {
    [CompilerGeneratedAttribute]
private IChangeSet`1<T> <source>P;
    public AggregateEnumerator`1(IChangeSet`1<T> source);
    [IteratorStateMachineAttribute("DynamicData.Aggregation.AggregateEnumerator`1/<GetEnumerator>d__2")]
public sealed virtual IEnumerator`1<AggregateItem`1<T>> GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class DynamicData.Aggregation.AggregateEnumerator`2 : object {
    private ChangeSet`2<TObject, TKey> _source;
    public AggregateEnumerator`2(IChangeSet`2<TObject, TKey> source);
    [IteratorStateMachineAttribute("DynamicData.Aggregation.AggregateEnumerator`2/<GetEnumerator>d__2")]
public sealed virtual IEnumerator`1<AggregateItem`1<TObject>> GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[IsReadOnlyAttribute]
public class DynamicData.Aggregation.AggregateItem`1 : ValueType {
    [CompilerGeneratedAttribute]
private AggregateType <Type>k__BackingField;
    [CompilerGeneratedAttribute]
private TObject <Item>k__BackingField;
    public AggregateType Type { get; }
    public TObject Item { get; }
    public AggregateItem`1(AggregateType type, TObject item);
    [CompilerGeneratedAttribute]
public AggregateType get_Type();
    [CompilerGeneratedAttribute]
public TObject get_Item();
    public static bool op_Equality(AggregateItem`1& left, AggregateItem`1& right);
    public static bool op_Inequality(AggregateItem`1& left, AggregateItem`1& right);
    [NullableContextAttribute("2")]
public virtual bool Equals(object obj);
    public sealed virtual bool Equals(AggregateItem`1<TObject> other);
    public virtual int GetHashCode();
}
public enum DynamicData.Aggregation.AggregateType : Enum {
    public int value__;
    public static AggregateType Add;
    public static AggregateType Remove;
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
public static class DynamicData.Aggregation.AggregationEx : object {
    [ExtensionAttribute]
public static IObservable`1<IAggregateChangeSet`1<TObject>> ForAggregation(IObservable`1<IChangeSet`2<TObject, TKey>> source);
    [ExtensionAttribute]
public static IObservable`1<IAggregateChangeSet`1<TObject>> ForAggregation(IObservable`1<IChangeSet`1<TObject>> source);
    [ExtensionAttribute]
public static IObservable`1<T> InvalidateWhen(IObservable`1<T> source, IObservable`1<Unit> invalidate);
    [ExtensionAttribute]
public static IObservable`1<T> InvalidateWhen(IObservable`1<T> source, IObservable`1<TTrigger> invalidate);
    [ExtensionAttribute]
internal static IObservable`1<TResult> Accumulate(IObservable`1<IChangeSet`1<TObject>> source, TResult seed, Func`2<TObject, TResult> accessor, Func`3<TResult, TResult, TResult> addAction, Func`3<TResult, TResult, TResult> removeAction);
    [ExtensionAttribute]
internal static IObservable`1<TResult> Accumulate(IObservable`1<IChangeSet`2<TObject, TKey>> source, TResult seed, Func`2<TObject, TResult> accessor, Func`3<TResult, TResult, TResult> addAction, Func`3<TResult, TResult, TResult> removeAction);
    [ExtensionAttribute]
internal static IObservable`1<TResult> Accumulate(IObservable`1<IAggregateChangeSet`1<TObject>> source, TResult seed, Func`2<TObject, TResult> accessor, Func`3<TResult, TResult, TResult> addAction, Func`3<TResult, TResult, TResult> removeAction);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[IsReadOnlyAttribute]
internal class DynamicData.Aggregation.Avg`1 : ValueType {
    [CompilerGeneratedAttribute]
private int <Count>k__BackingField;
    [CompilerGeneratedAttribute]
private TValue <Sum>k__BackingField;
    public int Count { get; }
    public TValue Sum { get; }
    public Avg`1(int count, TValue sum);
    [CompilerGeneratedAttribute]
public int get_Count();
    [CompilerGeneratedAttribute]
public TValue get_Sum();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
public static class DynamicData.Aggregation.AvgEx : object {
    [ExtensionAttribute]
public static IObservable`1<double> Avg(IObservable`1<IChangeSet`2<TObject, TKey>> source, Func`2<TObject, int> valueSelector, int emptyValue);
    [ExtensionAttribute]
public static IObservable`1<double> Avg(IObservable`1<IChangeSet`2<TObject, TKey>> source, Func`2<TObject, Nullable`1<int>> valueSelector, int emptyValue);
    [ExtensionAttribute]
public static IObservable`1<double> Avg(IObservable`1<IChangeSet`2<TObject, TKey>> source, Func`2<TObject, long> valueSelector, long emptyValue);
    [ExtensionAttribute]
public static IObservable`1<double> Avg(IObservable`1<IChangeSet`2<TObject, TKey>> source, Func`2<TObject, Nullable`1<long>> valueSelector, long emptyValue);
    [ExtensionAttribute]
public static IObservable`1<double> Avg(IObservable`1<IChangeSet`2<TObject, TKey>> source, Func`2<TObject, double> valueSelector, double emptyValue);
    [ExtensionAttribute]
public static IObservable`1<double> Avg(IObservable`1<IChangeSet`2<TObject, TKey>> source, Func`2<TObject, Nullable`1<double>> valueSelector, double emptyValue);
    [ExtensionAttribute]
public static IObservable`1<decimal> Avg(IObservable`1<IChangeSet`2<TObject, TKey>> source, Func`2<TObject, decimal> valueSelector, decimal emptyValue);
    [ExtensionAttribute]
public static IObservable`1<decimal> Avg(IObservable`1<IChangeSet`2<TObject, TKey>> source, Func`2<TObject, Nullable`1<decimal>> valueSelector, decimal emptyValue);
    [ExtensionAttribute]
public static IObservable`1<float> Avg(IObservable`1<IChangeSet`2<TObject, TKey>> source, Func`2<TObject, float> valueSelector, float emptyValue);
    [ExtensionAttribute]
public static IObservable`1<float> Avg(IObservable`1<IChangeSet`2<TObject, TKey>> source, Func`2<TObject, Nullable`1<float>> valueSelector, float emptyValue);
    [ExtensionAttribute]
public static IObservable`1<double> Avg(IObservable`1<IChangeSet`1<T>> source, Func`2<T, int> valueSelector, int emptyValue);
    [ExtensionAttribute]
public static IObservable`1<double> Avg(IObservable`1<IChangeSet`1<T>> source, Func`2<T, Nullable`1<int>> valueSelector, int emptyValue);
    [ExtensionAttribute]
public static IObservable`1<double> Avg(IObservable`1<IChangeSet`1<T>> source, Func`2<T, long> valueSelector, long emptyValue);
    [ExtensionAttribute]
public static IObservable`1<double> Avg(IObservable`1<IChangeSet`1<T>> source, Func`2<T, Nullable`1<long>> valueSelector, long emptyValue);
    [ExtensionAttribute]
public static IObservable`1<double> Avg(IObservable`1<IChangeSet`1<T>> source, Func`2<T, double> valueSelector, double emptyValue);
    [ExtensionAttribute]
public static IObservable`1<double> Avg(IObservable`1<IChangeSet`1<T>> source, Func`2<T, Nullable`1<double>> valueSelector, double emptyValue);
    [ExtensionAttribute]
public static IObservable`1<decimal> Avg(IObservable`1<IChangeSet`1<T>> source, Func`2<T, decimal> valueSelector, decimal emptyValue);
    [ExtensionAttribute]
public static IObservable`1<decimal> Avg(IObservable`1<IChangeSet`1<T>> source, Func`2<T, Nullable`1<decimal>> valueSelector, decimal emptyValue);
    [ExtensionAttribute]
public static IObservable`1<float> Avg(IObservable`1<IChangeSet`1<T>> source, Func`2<T, float> valueSelector, float emptyValue);
    [ExtensionAttribute]
public static IObservable`1<float> Avg(IObservable`1<IChangeSet`1<T>> source, Func`2<T, Nullable`1<float>> valueSelector, float emptyValue);
    [ExtensionAttribute]
public static IObservable`1<double> Avg(IObservable`1<IAggregateChangeSet`1<T>> source, Func`2<T, int> valueSelector, int emptyValue);
    [ExtensionAttribute]
public static IObservable`1<double> Avg(IObservable`1<IAggregateChangeSet`1<T>> source, Func`2<T, Nullable`1<int>> valueSelector, int emptyValue);
    [ExtensionAttribute]
public static IObservable`1<double> Avg(IObservable`1<IAggregateChangeSet`1<T>> source, Func`2<T, long> valueSelector, long emptyValue);
    [ExtensionAttribute]
public static IObservable`1<double> Avg(IObservable`1<IAggregateChangeSet`1<T>> source, Func`2<T, Nullable`1<long>> valueSelector, long emptyValue);
    [ExtensionAttribute]
public static IObservable`1<double> Avg(IObservable`1<IAggregateChangeSet`1<T>> source, Func`2<T, double> valueSelector, double emptyValue);
    [ExtensionAttribute]
public static IObservable`1<double> Avg(IObservable`1<IAggregateChangeSet`1<T>> source, Func`2<T, Nullable`1<double>> valueSelector, double emptyValue);
    [ExtensionAttribute]
public static IObservable`1<decimal> Avg(IObservable`1<IAggregateChangeSet`1<T>> source, Func`2<T, decimal> valueSelector, decimal emptyValue);
    [ExtensionAttribute]
public static IObservable`1<decimal> Avg(IObservable`1<IAggregateChangeSet`1<T>> source, Func`2<T, Nullable`1<decimal>> valueSelector, decimal emptyValue);
    [ExtensionAttribute]
public static IObservable`1<float> Avg(IObservable`1<IAggregateChangeSet`1<T>> source, Func`2<T, float> valueSelector, float emptyValue);
    [ExtensionAttribute]
public static IObservable`1<float> Avg(IObservable`1<IAggregateChangeSet`1<T>> source, Func`2<T, Nullable`1<float>> valueSelector, float emptyValue);
    [ExtensionAttribute]
private static IObservable`1<TResult> AvgCalc(IObservable`1<IAggregateChangeSet`1<TObject>> source, Func`2<TObject, TValue> valueSelector, TResult fallbackValue, Func`3<Avg`1<TValue>, TValue, Avg`1<TValue>> addAction, Func`3<Avg`1<TValue>, TValue, Avg`1<TValue>> removeAction, Func`2<Avg`1<TValue>, TResult> resultAction);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
public static class DynamicData.Aggregation.CountEx : object {
    [ExtensionAttribute]
public static IObservable`1<int> Count(IObservable`1<IChangeSet`2<TObject, TKey>> source);
    [ExtensionAttribute]
public static IObservable`1<int> Count(IObservable`1<IChangeSet`1<TObject>> source);
    [ExtensionAttribute]
public static IObservable`1<int> Count(IObservable`1<IAggregateChangeSet`1<TObject>> source);
    [ExtensionAttribute]
public static IObservable`1<int> Count(IObservable`1<IDistinctChangeSet`1<TObject>> source);
    [ExtensionAttribute]
public static IObservable`1<bool> IsEmpty(IObservable`1<IChangeSet`2<TObject, TKey>> source);
    [ExtensionAttribute]
public static IObservable`1<bool> IsEmpty(IObservable`1<IChangeSet`1<TObject>> source);
    [ExtensionAttribute]
public static IObservable`1<bool> IsNotEmpty(IObservable`1<IChangeSet`2<TObject, TKey>> source);
    [ExtensionAttribute]
public static IObservable`1<bool> IsNotEmpty(IObservable`1<IChangeSet`1<TObject>> source);
}
public interface DynamicData.Aggregation.IAggregateChangeSet`1 {
}
[ExtensionAttribute]
public static class DynamicData.Aggregation.MaxEx : object {
    [ExtensionAttribute]
public static IObservable`1<TResult> Maximum(IObservable`1<IChangeSet`1<TObject>> source, Func`2<TObject, TResult> valueSelector, TResult emptyValue);
    [NullableContextAttribute("1")]
[ExtensionAttribute]
public static IObservable`1<TResult> Maximum(IObservable`1<IChangeSet`2<TObject, TKey>> source, Func`2<TObject, TResult> valueSelector, TResult emptyValue);
    [ExtensionAttribute]
public static IObservable`1<TResult> Minimum(IObservable`1<IChangeSet`1<TObject>> source, Func`2<TObject, TResult> valueSelector, TResult emptyValue);
    [NullableContextAttribute("1")]
[ExtensionAttribute]
public static IObservable`1<TResult> Minimum(IObservable`1<IChangeSet`2<TObject, TKey>> source, Func`2<TObject, TResult> valueSelector, TResult emptyValue);
    [ExtensionAttribute]
private static IObservable`1<TResult> Calculate(IObservable`1<ChangesAndCollection`1<TObject>> source, Func`2<TObject, TResult> valueSelector, MaxOrMin maxOrMin, TResult emptyValue);
    [NullableContextAttribute("1")]
[ExtensionAttribute]
private static IObservable`1<ChangesAndCollection`1<TObject>> ToChangesAndCollection(IObservable`1<IChangeSet`2<TObject, TKey>> source);
    [NullableContextAttribute("1")]
[ExtensionAttribute]
private static IObservable`1<ChangesAndCollection`1<TObject>> ToChangesAndCollection(IObservable`1<IChangeSet`1<TObject>> source);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[IsReadOnlyAttribute]
internal class DynamicData.Aggregation.StdDev`1 : ValueType {
    [CompilerGeneratedAttribute]
private int <Count>k__BackingField;
    [CompilerGeneratedAttribute]
private TValue <SumOfItems>k__BackingField;
    [CompilerGeneratedAttribute]
private TValue <SumOfSquares>k__BackingField;
    public int Count { get; }
    public TValue SumOfItems { get; }
    public TValue SumOfSquares { get; }
    public StdDev`1(int count, TValue sumOfItems, TValue sumOfSquares);
    [CompilerGeneratedAttribute]
public int get_Count();
    [CompilerGeneratedAttribute]
public TValue get_SumOfItems();
    [CompilerGeneratedAttribute]
public TValue get_SumOfSquares();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
public static class DynamicData.Aggregation.StdDevEx : object {
    [ExtensionAttribute]
public static IObservable`1<double> StdDev(IObservable`1<IChangeSet`1<T>> source, Func`2<T, int> valueSelector, int fallbackValue);
    [ExtensionAttribute]
public static IObservable`1<double> StdDev(IObservable`1<IChangeSet`1<T>> source, Func`2<T, long> valueSelector, long fallbackValue);
    [ExtensionAttribute]
public static IObservable`1<double> StdDev(IObservable`1<IChangeSet`1<T>> source, Func`2<T, double> valueSelector, double fallbackValue);
    [ExtensionAttribute]
public static IObservable`1<decimal> StdDev(IObservable`1<IChangeSet`1<T>> source, Func`2<T, decimal> valueSelector, decimal fallbackValue);
    [ExtensionAttribute]
public static IObservable`1<double> StdDev(IObservable`1<IChangeSet`1<T>> source, Func`2<T, float> valueSelector, float fallbackValue);
    [ExtensionAttribute]
public static IObservable`1<double> StdDev(IObservable`1<IChangeSet`2<TObject, TKey>> source, Func`2<TObject, int> valueSelector, int fallbackValue);
    [ExtensionAttribute]
public static IObservable`1<double> StdDev(IObservable`1<IChangeSet`2<TObject, TKey>> source, Func`2<TObject, long> valueSelector, long fallbackValue);
    [ExtensionAttribute]
public static IObservable`1<double> StdDev(IObservable`1<IChangeSet`2<TObject, TKey>> source, Func`2<TObject, double> valueSelector, double fallbackValue);
    [ExtensionAttribute]
public static IObservable`1<decimal> StdDev(IObservable`1<IChangeSet`2<TObject, TKey>> source, Func`2<TObject, decimal> valueSelector, decimal fallbackValue);
    [ExtensionAttribute]
public static IObservable`1<double> StdDev(IObservable`1<IChangeSet`2<TObject, TKey>> source, Func`2<TObject, float> valueSelector, float fallbackValue);
    [ExtensionAttribute]
public static IObservable`1<double> StdDev(IObservable`1<IAggregateChangeSet`1<T>> source, Func`2<T, int> valueSelector, int fallbackValue);
    [ExtensionAttribute]
public static IObservable`1<double> StdDev(IObservable`1<IAggregateChangeSet`1<T>> source, Func`2<T, long> valueSelector, long fallbackValue);
    [ExtensionAttribute]
public static IObservable`1<decimal> StdDev(IObservable`1<IAggregateChangeSet`1<T>> source, Func`2<T, decimal> valueSelector, decimal fallbackValue);
    [ExtensionAttribute]
public static IObservable`1<double> StdDev(IObservable`1<IAggregateChangeSet`1<T>> source, Func`2<T, double> valueSelector, double fallbackValue);
    [ExtensionAttribute]
public static IObservable`1<double> StdDev(IObservable`1<IAggregateChangeSet`1<T>> source, Func`2<T, float> valueSelector, float fallbackValue);
    [ExtensionAttribute]
private static IObservable`1<TResult> StdDevCalc(IObservable`1<IAggregateChangeSet`1<TObject>> source, Func`2<TObject, TValue> valueSelector, TResult fallbackValue, Func`3<StdDev`1<TValue>, TValue, StdDev`1<TValue>> addAction, Func`3<StdDev`1<TValue>, TValue, StdDev`1<TValue>> removeAction, Func`2<StdDev`1<TValue>, TResult> resultAction);
    private static decimal Sqrt(decimal x, decimal epsilon);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
public static class DynamicData.Aggregation.SumEx : object {
    [ExtensionAttribute]
public static IObservable`1<int> Sum(IObservable`1<IChangeSet`2<TObject, TKey>> source, Func`2<TObject, int> valueSelector);
    [ExtensionAttribute]
public static IObservable`1<int> Sum(IObservable`1<IChangeSet`2<TObject, TKey>> source, Func`2<TObject, Nullable`1<int>> valueSelector);
    [ExtensionAttribute]
public static IObservable`1<long> Sum(IObservable`1<IChangeSet`2<TObject, TKey>> source, Func`2<TObject, long> valueSelector);
    [ExtensionAttribute]
public static IObservable`1<long> Sum(IObservable`1<IChangeSet`2<TObject, TKey>> source, Func`2<TObject, Nullable`1<long>> valueSelector);
    [ExtensionAttribute]
public static IObservable`1<double> Sum(IObservable`1<IChangeSet`2<TObject, TKey>> source, Func`2<TObject, double> valueSelector);
    [ExtensionAttribute]
public static IObservable`1<double> Sum(IObservable`1<IChangeSet`2<TObject, TKey>> source, Func`2<TObject, Nullable`1<double>> valueSelector);
    [ExtensionAttribute]
public static IObservable`1<decimal> Sum(IObservable`1<IChangeSet`2<TObject, TKey>> source, Func`2<TObject, decimal> valueSelector);
    [ExtensionAttribute]
public static IObservable`1<decimal> Sum(IObservable`1<IChangeSet`2<TObject, TKey>> source, Func`2<TObject, Nullable`1<decimal>> valueSelector);
    [ExtensionAttribute]
public static IObservable`1<float> Sum(IObservable`1<IChangeSet`2<TObject, TKey>> source, Func`2<TObject, float> valueSelector);
    [ExtensionAttribute]
public static IObservable`1<float> Sum(IObservable`1<IChangeSet`2<TObject, TKey>> source, Func`2<TObject, Nullable`1<float>> valueSelector);
    [ExtensionAttribute]
public static IObservable`1<int> Sum(IObservable`1<IChangeSet`1<T>> source, Func`2<T, int> valueSelector);
    [ExtensionAttribute]
public static IObservable`1<int> Sum(IObservable`1<IChangeSet`1<T>> source, Func`2<T, Nullable`1<int>> valueSelector);
    [ExtensionAttribute]
public static IObservable`1<long> Sum(IObservable`1<IChangeSet`1<T>> source, Func`2<T, long> valueSelector);
    [ExtensionAttribute]
public static IObservable`1<long> Sum(IObservable`1<IChangeSet`1<T>> source, Func`2<T, Nullable`1<long>> valueSelector);
    [ExtensionAttribute]
public static IObservable`1<double> Sum(IObservable`1<IChangeSet`1<T>> source, Func`2<T, double> valueSelector);
    [ExtensionAttribute]
public static IObservable`1<double> Sum(IObservable`1<IChangeSet`1<T>> source, Func`2<T, Nullable`1<double>> valueSelector);
    [ExtensionAttribute]
public static IObservable`1<decimal> Sum(IObservable`1<IChangeSet`1<T>> source, Func`2<T, decimal> valueSelector);
    [ExtensionAttribute]
public static IObservable`1<decimal> Sum(IObservable`1<IChangeSet`1<T>> source, Func`2<T, Nullable`1<decimal>> valueSelector);
    [ExtensionAttribute]
public static IObservable`1<float> Sum(IObservable`1<IChangeSet`1<T>> source, Func`2<T, float> valueSelector);
    [ExtensionAttribute]
public static IObservable`1<float> Sum(IObservable`1<IChangeSet`1<T>> source, Func`2<T, Nullable`1<float>> valueSelector);
    [ExtensionAttribute]
public static IObservable`1<int> Sum(IObservable`1<IAggregateChangeSet`1<T>> source, Func`2<T, int> valueSelector);
    [ExtensionAttribute]
public static IObservable`1<int> Sum(IObservable`1<IAggregateChangeSet`1<T>> source, Func`2<T, Nullable`1<int>> valueSelector);
    [ExtensionAttribute]
public static IObservable`1<long> Sum(IObservable`1<IAggregateChangeSet`1<T>> source, Func`2<T, long> valueSelector);
    [ExtensionAttribute]
public static IObservable`1<long> Sum(IObservable`1<IAggregateChangeSet`1<T>> source, Func`2<T, Nullable`1<long>> valueSelector);
    [ExtensionAttribute]
public static IObservable`1<double> Sum(IObservable`1<IAggregateChangeSet`1<T>> source, Func`2<T, double> valueSelector);
    [ExtensionAttribute]
public static IObservable`1<double> Sum(IObservable`1<IAggregateChangeSet`1<T>> source, Func`2<T, Nullable`1<double>> valueSelector);
    [ExtensionAttribute]
public static IObservable`1<decimal> Sum(IObservable`1<IAggregateChangeSet`1<T>> source, Func`2<T, decimal> valueSelector);
    [ExtensionAttribute]
public static IObservable`1<decimal> Sum(IObservable`1<IAggregateChangeSet`1<T>> source, Func`2<T, Nullable`1<decimal>> valueSelector);
    [ExtensionAttribute]
public static IObservable`1<float> Sum(IObservable`1<IAggregateChangeSet`1<T>> source, Func`2<T, float> valueSelector);
    [ExtensionAttribute]
public static IObservable`1<float> Sum(IObservable`1<IAggregateChangeSet`1<T>> source, Func`2<T, Nullable`1<float>> valueSelector);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
public static class DynamicData.Alias.ObservableCacheAlias : object {
    [ExtensionAttribute]
public static IObservable`1<IChangeSet`2<TDestination, TKey>> Select(IObservable`1<IChangeSet`2<TSource, TKey>> source, Func`3<TSource, TKey, TDestination> transformFactory, IObservable`1<Unit> forceTransform);
    [ExtensionAttribute]
public static IObservable`1<IChangeSet`2<TDestination, TKey>> Select(IObservable`1<IChangeSet`2<TSource, TKey>> source, Func`3<TSource, TKey, TDestination> transformFactory, IObservable`1<Func`3<TSource, TKey, bool>> forceTransform);
    [ExtensionAttribute]
public static IObservable`1<IChangeSet`2<TDestination, TKey>> Select(IObservable`1<IChangeSet`2<TSource, TKey>> source, Func`2<TSource, TDestination> transformFactory, IObservable`1<Unit> forceTransform);
    [ExtensionAttribute]
public static IObservable`1<IChangeSet`2<TDestination, TKey>> Select(IObservable`1<IChangeSet`2<TSource, TKey>> source, Func`2<TSource, TDestination> transformFactory, IObservable`1<Func`2<TSource, bool>> forceTransform);
    [ExtensionAttribute]
public static IObservable`1<IChangeSet`2<TDestination, TDestinationKey>> SelectMany(IObservable`1<IChangeSet`2<TSource, TSourceKey>> source, Func`2<TSource, IEnumerable`1<TDestination>> manySelector, Func`2<TDestination, TDestinationKey> keySelector);
    [ExtensionAttribute]
public static IObservable`1<IChangeSet`2<TDestination, TKey>> SelectSafe(IObservable`1<IChangeSet`2<TSource, TKey>> source, Func`2<TSource, TDestination> transformFactory, Action`1<Error`2<TSource, TKey>> errorHandler, IObservable`1<Unit> forceTransform);
    [ExtensionAttribute]
public static IObservable`1<IChangeSet`2<TDestination, TKey>> SelectSafe(IObservable`1<IChangeSet`2<TSource, TKey>> source, Func`2<TSource, TDestination> transformFactory, Action`1<Error`2<TSource, TKey>> errorHandler, IObservable`1<Func`2<TSource, bool>> forceTransform);
    [ExtensionAttribute]
public static IObservable`1<IChangeSet`2<TDestination, TKey>> SelectSafe(IObservable`1<IChangeSet`2<TSource, TKey>> source, Func`3<TSource, TKey, TDestination> transformFactory, Action`1<Error`2<TSource, TKey>> errorHandler, IObservable`1<Func`3<TSource, TKey, bool>> forceTransform);
    [ExtensionAttribute]
public static IObservable`1<IChangeSet`2<TDestination, TKey>> SelectSafe(IObservable`1<IChangeSet`2<TSource, TKey>> source, Func`3<TSource, TKey, TDestination> transformFactory, Action`1<Error`2<TSource, TKey>> errorHandler, IObservable`1<Unit> forceTransform);
    [ExtensionAttribute]
public static IObservable`1<IChangeSet`2<Node`2<TObject, TKey>, TKey>> SelectTree(IObservable`1<IChangeSet`2<TObject, TKey>> source, Func`2<TObject, TKey> pivotOn);
    [ExtensionAttribute]
public static IObservable`1<IChangeSet`2<TObject, TKey>> Where(IObservable`1<IChangeSet`2<TObject, TKey>> source, Func`2<TObject, bool> filter);
    [ExtensionAttribute]
public static IObservable`1<IChangeSet`2<TObject, TKey>> Where(IObservable`1<IChangeSet`2<TObject, TKey>> source, IObservable`1<Func`2<TObject, bool>> predicateChanged);
    [ExtensionAttribute]
public static IObservable`1<IChangeSet`2<TObject, TKey>> Where(IObservable`1<IChangeSet`2<TObject, TKey>> source, IObservable`1<Unit> reapplyFilter);
    [ExtensionAttribute]
public static IObservable`1<IChangeSet`2<TObject, TKey>> Where(IObservable`1<IChangeSet`2<TObject, TKey>> source, IObservable`1<Func`2<TObject, bool>> predicateChanged, IObservable`1<Unit> reapplyFilter);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
public static class DynamicData.Alias.ObservableListAlias : object {
    [ExtensionAttribute]
public static IObservable`1<IChangeSet`1<TDestination>> Select(IObservable`1<IChangeSet`1<TSource>> source, Func`2<TSource, TDestination> transformFactory);
    [ExtensionAttribute]
public static IObservable`1<IChangeSet`1<TDestination>> SelectMany(IObservable`1<IChangeSet`1<TSource>> source, Func`2<TSource, IEnumerable`1<TDestination>> manySelector);
    [ExtensionAttribute]
public static IObservable`1<IChangeSet`1<T>> Where(IObservable`1<IChangeSet`1<T>> source, Func`2<T, bool> predicate);
    [ExtensionAttribute]
public static IObservable`1<IChangeSet`1<T>> Where(IObservable`1<IChangeSet`1<T>> source, IObservable`1<Func`2<T, bool>> predicate);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
public abstract class DynamicData.Binding.AbstractNotifyPropertyChanged : object {
    [CompilerGeneratedAttribute]
private PropertyChangedEventHandler PropertyChanged;
    [CompilerGeneratedAttribute]
public sealed virtual void add_PropertyChanged(PropertyChangedEventHandler value);
    [CompilerGeneratedAttribute]
public sealed virtual void remove_PropertyChanged(PropertyChangedEventHandler value);
    [NullableContextAttribute("1")]
[ObsoleteAttribute("This never worked properly in the first place")]
public IDisposable SuspendNotifications(bool invokePropertyChangeEventWhenDisposed);
    protected virtual void OnPropertyChanged(string propertyName);
    [NullableContextAttribute("1")]
protected virtual void SetAndRaise(T& backingField, T newValue, string propertyName);
    [NullableContextAttribute("1")]
protected virtual void SetAndRaise(T& backingField, T newValue, IEqualityComparer`1<T> comparer, string propertyName);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class DynamicData.Binding.BindingListAdaptor`1 : object {
    [CompilerGeneratedAttribute]
private int <refreshThreshold>P;
    private BindingList`1<T> _list;
    private bool _loaded;
    public BindingListAdaptor`1(BindingList`1<T> list, int refreshThreshold);
    public sealed virtual void Adapt(IChangeSet`1<T> changes);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class DynamicData.Binding.BindingListAdaptor`2 : object {
    [CompilerGeneratedAttribute]
private int <refreshThreshold>P;
    private Cache`2<TObject, TKey> _cache;
    private BindingList`1<TObject> _list;
    private bool _loaded;
    public BindingListAdaptor`2(BindingList`1<TObject> list, int refreshThreshold);
    public sealed virtual void Adapt(IChangeSet`2<TObject, TKey> changes);
    private static void DoUpdate(IChangeSet`2<TObject, TKey> changes, BindingList`1<TObject> list);
}
internal class DynamicData.Binding.BindingListEventsSuspender`1 : object {
    [NullableAttribute("1")]
private IDisposable _cleanUp;
    [NullableContextAttribute("1")]
public BindingListEventsSuspender`1(BindingList`1<T> list);
    public sealed virtual void Dispose();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
public static class DynamicData.Binding.BindingListEx : object {
    [ExtensionAttribute]
public static IObservable`1<EventPattern`1<ListChangedEventArgs>> ObserveCollectionChanges(IBindingList source);
    [ExtensionAttribute]
public static IObservable`1<IChangeSet`1<T>> ToObservableChangeSet(BindingList`1<T> source);
    [ExtensionAttribute]
public static IObservable`1<IChangeSet`2<TObject, TKey>> ToObservableChangeSet(BindingList`1<TObject> source, Func`2<TObject, TKey> keySelector);
    [ExtensionAttribute]
public static IObservable`1<IChangeSet`1<T>> ToObservableChangeSet(TCollection source);
    [ExtensionAttribute]
internal static void Clone(BindingList`1<T> source, IEnumerable`1<Change`1<T>> changes);
    [ExtensionAttribute]
private static void Clone(BindingList`1<T> source, Change`1<T> item, IEqualityComparer`1<T> equalityComparer);
}
public class DynamicData.Binding.BindingOptions : ValueType {
    [CompilerGeneratedAttribute]
private int <ResetThreshold>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <UseReplaceForUpdates>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <ResetOnFirstTimeLoad>k__BackingField;
    public static int DefaultResetThreshold;
    public static bool DefaultUseReplaceForUpdates;
    public static bool DefaultResetOnFirstTimeLoad;
    public int ResetThreshold { get; public set; }
    public bool UseReplaceForUpdates { get; public set; }
    public bool ResetOnFirstTimeLoad { get; public set; }
    public BindingOptions(int ResetThreshold, bool UseReplaceForUpdates, bool ResetOnFirstTimeLoad);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public int get_ResetThreshold();
    [CompilerGeneratedAttribute]
public void set_ResetThreshold(int value);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public bool get_UseReplaceForUpdates();
    [CompilerGeneratedAttribute]
public void set_UseReplaceForUpdates(bool value);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public bool get_ResetOnFirstTimeLoad();
    [CompilerGeneratedAttribute]
public void set_ResetOnFirstTimeLoad(bool value);
    public static BindingOptions NeverFireReset(bool useReplaceForUpdates);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public virtual string ToString();
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
private bool PrintMembers(StringBuilder builder);
    [CompilerGeneratedAttribute]
public static bool op_Inequality(BindingOptions left, BindingOptions right);
    [CompilerGeneratedAttribute]
public static bool op_Equality(BindingOptions left, BindingOptions right);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public virtual int GetHashCode();
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public virtual bool Equals(object obj);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public sealed virtual bool Equals(BindingOptions other);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public void Deconstruct(Int32& ResetThreshold, Boolean& UseReplaceForUpdates, Boolean& ResetOnFirstTimeLoad);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class DynamicData.Binding.BindPaged`2 : object {
    [CompilerGeneratedAttribute]
private IObservable`1<IChangeSet`3<TObject, TKey, PageContext`1<TObject>>> <source>P;
    [CompilerGeneratedAttribute]
private IList`1<TObject> <targetList>P;
    [CompilerGeneratedAttribute]
private Nullable`1<SortAndBindOptions> <options>P;
    public BindPaged`2(IObservable`1<IChangeSet`3<TObject, TKey, PageContext`1<TObject>>> source, IList`1<TObject> targetList, Nullable`1<SortAndBindOptions> options);
    public IObservable`1<IChangeSet`2<TObject, TKey>> Run();
    private IObservable`1<IChangeSet`2<TObject, TKey>> UseProvidedOptions(SortAndBindOptions sortAndBindOptions);
    private IObservable`1<IChangeSet`2<TObject, TKey>> UseContextSortOptions();
    [CompilerGeneratedAttribute]
private IDisposable <UseContextSortOptions>b__6_0(IObserver`1<IChangeSet`2<TObject, TKey>> observer);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class DynamicData.Binding.BindVirtualized`2 : object {
    [CompilerGeneratedAttribute]
private IObservable`1<IChangeSet`3<TObject, TKey, VirtualContext`1<TObject>>> <source>P;
    [CompilerGeneratedAttribute]
private IList`1<TObject> <targetList>P;
    [CompilerGeneratedAttribute]
private Nullable`1<SortAndBindOptions> <options>P;
    public BindVirtualized`2(IObservable`1<IChangeSet`3<TObject, TKey, VirtualContext`1<TObject>>> source, IList`1<TObject> targetList, Nullable`1<SortAndBindOptions> options);
    public IObservable`1<IChangeSet`2<TObject, TKey>> Run();
    private IObservable`1<IChangeSet`2<TObject, TKey>> UseProvidedOptions(SortAndBindOptions sortAndBindOptions);
    private IObservable`1<IChangeSet`2<TObject, TKey>> UseVirtualSortOptions();
    [CompilerGeneratedAttribute]
private IDisposable <UseVirtualSortOptions>b__6_0(IObserver`1<IChangeSet`2<TObject, TKey>> observer);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
internal static class DynamicData.Binding.ExpressionBuilder : object {
    [IteratorStateMachineAttribute("DynamicData.Binding.ExpressionBuilder/<GetMembers>d__0`2")]
[ExtensionAttribute]
public static IEnumerable`1<MemberExpression> GetMembers(Expression`1<Func`2<TObject, TProperty>> source);
    [ExtensionAttribute]
internal static Func`2<object, IObservable`1<Unit>> CreatePropertyChangedFactory(MemberExpression source);
    [ExtensionAttribute]
internal static Func`2<object, object> CreateValueAccessor(MemberExpression source);
    [ExtensionAttribute]
internal static MemberInfo GetMember(Expression`1<Func`2<TObject, TProperty>> expression);
    [IteratorStateMachineAttribute("DynamicData.Binding.ExpressionBuilder/<GetMemberChain>d__4`2")]
[ExtensionAttribute]
internal static IEnumerable`1<MemberExpression> GetMemberChain(Expression`1<Func`2<TObject, TProperty>> expression);
    [ExtensionAttribute]
internal static PropertyInfo GetProperty(Expression`1<Func`2<TObject, TProperty>> expression);
    [ExtensionAttribute]
internal static PropertyInfo GetProperty(MemberExpression expression);
    [ExtensionAttribute]
internal static string ToCacheKey(Expression`1<Func`2<TObject, TProperty>> expression);
    private static MemberInfo GetMemberInfo(LambdaExpression lambda);
}
public interface DynamicData.Binding.IEvaluateAware {
    public abstract virtual void Evaluate();
}
public interface DynamicData.Binding.IIndexAware {
    public int Index { get; public set; }
    public abstract virtual int get_Index();
    public abstract virtual void set_Index(int value);
}
[NullableContextAttribute("1")]
public interface DynamicData.Binding.INotifyCollectionChangedSuspender {
    public abstract virtual IDisposable SuspendCount();
    public abstract virtual IDisposable SuspendNotifications();
}
public interface DynamicData.Binding.IObservableCollection`1 {
    [NullableContextAttribute("1")]
public abstract virtual void Load(IEnumerable`1<T> items);
    public abstract virtual void Move(int oldIndex, int newIndex);
}
[NullableContextAttribute("1")]
public interface DynamicData.Binding.IObservableCollectionAdaptor`2 {
    public abstract virtual void Adapt(IChangeSet`2<TObject, TKey> changes, IObservableCollection`1<TObject> collection);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
public static class DynamicData.Binding.IObservableListEx : object {
    [ExtensionAttribute]
public static IObservable`1<IChangeSet`1<TObject>> BindToObservableList(IObservable`1<IChangeSet`1<TObject>> source, IObservableList`1& observableList);
    [ExtensionAttribute]
public static IObservable`1<IChangeSet`2<TObject, TKey>> BindToObservableList(IObservable`1<IChangeSet`2<TObject, TKey>> source, IObservableList`1& observableList);
    [ExtensionAttribute]
public static IObservable`1<ISortedChangeSet`2<TObject, TKey>> BindToObservableList(IObservable`1<ISortedChangeSet`2<TObject, TKey>> source, IObservableList`1& observableList);
    [ExtensionAttribute]
private static IChangeSet`1<TObject> RemoveKey(IChangeSet`2<TObject, TKey> changeSetWithKey, IExtendedList`1<TObject> list);
}
[NullableContextAttribute("1")]
public interface DynamicData.Binding.ISortedObservableCollectionAdaptor`2 {
    public abstract virtual void Adapt(ISortedChangeSet`2<TObject, TKey> changes, IObservableCollection`1<TObject> collection);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
public static class DynamicData.Binding.NotifyPropertyChangedEx : object {
    [ExtensionAttribute]
public static IObservable`1<TObject> WhenAnyPropertyChanged(TObject source, String[] propertiesToMonitor);
    [ExtensionAttribute]
public static IObservable`1<TResult> WhenChanged(TObject source, Expression`1<Func`2<TObject, TProperty1>> p1, Func`3<TObject, TProperty1, TResult> resultSelector, Func`1<TProperty1> p1Fallback);
    [ExtensionAttribute]
public static IObservable`1<TResult> WhenChanged(TObject source, Expression`1<Func`2<TObject, TProperty1>> p1, Expression`1<Func`2<TObject, TProperty2>> p2, Func`4<TObject, TProperty1, TProperty2, TResult> resultSelector, Func`1<TProperty1> p1Fallback, Func`1<TProperty2> p2Fallback);
    [ExtensionAttribute]
public static IObservable`1<TResult> WhenChanged(TObject source, Expression`1<Func`2<TObject, TProperty1>> p1, Expression`1<Func`2<TObject, TProperty2>> p2, Expression`1<Func`2<TObject, TProperty3>> p3, Func`5<TObject, TProperty1, TProperty2, TProperty3, TResult> resultSelector, Func`1<TProperty1> p1Fallback, Func`1<TProperty2> p2Fallback, Func`1<TProperty3> p3Fallback);
    [ExtensionAttribute]
public static IObservable`1<TResult> WhenChanged(TObject source, Expression`1<Func`2<TObject, TProperty1>> p1, Expression`1<Func`2<TObject, TProperty2>> p2, Expression`1<Func`2<TObject, TProperty3>> p3, Expression`1<Func`2<TObject, TProperty4>> p4, Func`6<TObject, TProperty1, TProperty2, TProperty3, TProperty4, TResult> resultSelector, Func`1<TProperty1> p1Fallback, Func`1<TProperty2> p2Fallback, Func`1<TProperty3> p3Fallback, Func`1<TProperty4> p4Fallback);
    [ExtensionAttribute]
public static IObservable`1<TResult> WhenChanged(TObject source, Expression`1<Func`2<TObject, TProperty1>> p1, Expression`1<Func`2<TObject, TProperty2>> p2, Expression`1<Func`2<TObject, TProperty3>> p3, Expression`1<Func`2<TObject, TProperty4>> p4, Expression`1<Func`2<TObject, TProperty5>> p5, Func`7<TObject, TProperty1, TProperty2, TProperty3, TProperty4, TProperty5, TResult> resultSelector, Func`1<TProperty1> p1Fallback, Func`1<TProperty2> p2Fallback, Func`1<TProperty3> p3Fallback, Func`1<TProperty4> p4Fallback, Func`1<TProperty5> p5Fallback);
    [ExtensionAttribute]
public static IObservable`1<TResult> WhenChanged(TObject source, Expression`1<Func`2<TObject, TProperty1>> p1, Expression`1<Func`2<TObject, TProperty2>> p2, Expression`1<Func`2<TObject, TProperty3>> p3, Expression`1<Func`2<TObject, TProperty4>> p4, Expression`1<Func`2<TObject, TProperty5>> p5, Expression`1<Func`2<TObject, TProperty6>> p6, Func`8<TObject, TProperty1, TProperty2, TProperty3, TProperty4, TProperty5, TProperty6, TResult> resultSelector, Func`1<TProperty1> p1Fallback, Func`1<TProperty2> p2Fallback, Func`1<TProperty3> p3Fallback, Func`1<TProperty4> p4Fallback, Func`1<TProperty5> p5Fallback, Func`1<TProperty6> p6Fallback);
    [ExtensionAttribute]
public static IObservable`1<PropertyValue`2<TObject, TProperty>> WhenPropertyChanged(TObject source, Expression`1<Func`2<TObject, TProperty>> propertyAccessor, bool notifyOnInitialValue, Func`1<TProperty> fallbackValue);
    [ExtensionAttribute]
public static IObservable`1<TProperty> WhenValueChanged(TObject source, Expression`1<Func`2<TObject, TProperty>> propertyAccessor, bool notifyOnInitialValue, Func`1<TProperty> fallbackValue);
    [ExtensionAttribute]
internal static Func`3<TObject, bool, IObservable`1<PropertyValue`2<TObject, TProperty>>> GetFactory(Expression`1<Func`2<TObject, TProperty>> expression);
    [ExtensionAttribute]
internal static IObservable`1<TProperty> WhenChanged(TObject source, Expression`1<Func`2<TObject, TProperty>> expression, bool notifyInitial, Func`1<TProperty> fallbackValue);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal static class DynamicData.Binding.Observable`1 : object {
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private static IObservable`1<T> <Default>k__BackingField;
    [CompilerGeneratedAttribute]
private static IObservable`1<T> <Empty>k__BackingField;
    [CompilerGeneratedAttribute]
private static IObservable`1<T> <Never>k__BackingField;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static IObservable`1<T> Default { get; }
    public static IObservable`1<T> Empty { get; }
    public static IObservable`1<T> Never { get; }
    private static Observable`1();
    [CompilerGeneratedAttribute]
public static IObservable`1<T> get_Default();
    [CompilerGeneratedAttribute]
public static IObservable`1<T> get_Empty();
    [CompilerGeneratedAttribute]
public static IObservable`1<T> get_Never();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class DynamicData.Binding.ObservableCollectionAdaptor`1 : object {
    [CompilerGeneratedAttribute]
private int <refreshThreshold>P;
    [CompilerGeneratedAttribute]
private bool <resetOnFirstTimeLoad>P;
    private IObservableCollection`1<T> _collection;
    private bool _loaded;
    public ObservableCollectionAdaptor`1(IObservableCollection`1<T> collection, int refreshThreshold, bool allowReplace, bool resetOnFirstTimeLoad);
    public ObservableCollectionAdaptor`1(IObservableCollection`1<T> collection);
    public ObservableCollectionAdaptor`1(IObservableCollection`1<T> collection, BindingOptions options);
    public sealed virtual void Adapt(IChangeSet`1<T> changes);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class DynamicData.Binding.ObservableCollectionAdaptor`2 : object {
    [CompilerGeneratedAttribute]
private int <refreshThreshold>P;
    [CompilerGeneratedAttribute]
private bool <useReplaceForUpdates>P;
    [CompilerGeneratedAttribute]
private bool <resetOnFirstTimeLoad>P;
    private Cache`2<TObject, TKey> _cache;
    private bool _loaded;
    public ObservableCollectionAdaptor`2(int refreshThreshold, bool useReplaceForUpdates, bool resetOnFirstTimeLoad);
    public ObservableCollectionAdaptor`2(BindingOptions options);
    public sealed virtual void Adapt(IChangeSet`2<TObject, TKey> changes, IObservableCollection`1<TObject> collection);
    private void DoUpdate(IChangeSet`2<TObject, TKey> changes, IObservableCollection`1<TObject> list);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
public static class DynamicData.Binding.ObservableCollectionEx : object {
    [ExtensionAttribute]
public static IObservable`1<EventPattern`1<NotifyCollectionChangedEventArgs>> ObserveCollectionChanges(INotifyCollectionChanged source);
    [ExtensionAttribute]
public static IObservable`1<IChangeSet`1<T>> ToObservableChangeSet(ObservableCollection`1<T> source);
    [ExtensionAttribute]
public static IObservable`1<IChangeSet`2<TObject, TKey>> ToObservableChangeSet(ObservableCollection`1<TObject> source, Func`2<TObject, TKey> keySelector);
    [ExtensionAttribute]
public static IObservable`1<IChangeSet`1<T>> ToObservableChangeSet(ReadOnlyObservableCollection`1<T> source);
    [ExtensionAttribute]
public static IObservable`1<IChangeSet`2<TObject, TKey>> ToObservableChangeSet(ReadOnlyObservableCollection`1<TObject> source, Func`2<TObject, TKey> keySelector);
    [ExtensionAttribute]
public static IObservable`1<IChangeSet`1<T>> ToObservableChangeSet(TCollection source);
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public class DynamicData.Binding.ObservableCollectionExtended`1 : ObservableCollection`1<T> {
    private bool _suspendCount;
    private bool _suspendNotifications;
    public ObservableCollectionExtended`1(List`1<T> list);
    public ObservableCollectionExtended`1(IEnumerable`1<T> collection);
    public sealed virtual void AddRange(IEnumerable`1<T> collection);
    public sealed virtual void InsertRange(IEnumerable`1<T> collection, int index);
    public sealed virtual void Load(IEnumerable`1<T> items);
    public sealed virtual void RemoveRange(int index, int count);
    public sealed virtual IDisposable SuspendCount();
    public sealed virtual IDisposable SuspendNotifications();
    protected virtual void OnCollectionChanged(NotifyCollectionChangedEventArgs e);
    protected virtual void OnPropertyChanged(PropertyChangedEventArgs e);
    private sealed virtual override void DynamicData.Binding.IObservableCollection<T>.Move(int oldIndex, int newIndex);
    private sealed virtual override void DynamicData.IExtendedList<T>.Move(int original, int destination);
    [CompilerGeneratedAttribute]
private void <SuspendNotifications>b__10_0();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class DynamicData.Binding.ObservablePropertyFactory`2 : object {
    private Func`3<TObject, bool, IObservable`1<PropertyValue`2<TObject, TProperty>>> _factory;
    public ObservablePropertyFactory`2(Func`2<TObject, TProperty> valueAccessor, ObservablePropertyPart[] chain);
    public ObservablePropertyFactory`2(Expression`1<Func`2<TObject, TProperty>> expression);
    public IObservable`1<PropertyValue`2<TObject, TProperty>> Create(TObject source, bool notifyInitial);
    [IteratorStateMachineAttribute("DynamicData.Binding.ObservablePropertyFactory`2/<GetNotifiers>d__4")]
private static IEnumerable`1<IObservable`1<Unit>> GetNotifiers(TObject source, IEnumerable`1<ObservablePropertyPart> chain);
    private static PropertyValue`2<TObject, TProperty> GetPropertyValue(TObject source, IEnumerable`1<ObservablePropertyPart> chain, Func`2<TObject, TProperty> valueAccessor);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class DynamicData.Binding.ObservablePropertyFactoryCache : object {
    public static ObservablePropertyFactoryCache Instance;
    private ConcurrentDictionary`2<string, object> _factories;
    private static ObservablePropertyFactoryCache();
    public ObservablePropertyFactory`2<TObject, TProperty> GetFactory(Expression`1<Func`2<TObject, TProperty>> expression);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[DebuggerDisplayAttribute("ObservablePropertyPart<{expression}>")]
internal class DynamicData.Binding.ObservablePropertyPart : object {
    [CompilerGeneratedAttribute]
private Func`2<object, object> <Accessor>k__BackingField;
    [CompilerGeneratedAttribute]
private Func`2<object, IObservable`1<Unit>> <Factory>k__BackingField;
    public Func`2<object, object> Accessor { get; }
    public Func`2<object, IObservable`1<Unit>> Factory { get; }
    public ObservablePropertyPart(MemberExpression expression);
    [CompilerGeneratedAttribute]
public Func`2<object, object> get_Accessor();
    [CompilerGeneratedAttribute]
public Func`2<object, IObservable`1<Unit>> get_Factory();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class DynamicData.Binding.PropertyValue`2 : object {
    [CompilerGeneratedAttribute]
private TObject <Sender>k__BackingField;
    [NullableAttribute("2")]
[CompilerGeneratedAttribute]
private TValue <Value>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <UnobtainableValue>k__BackingField;
    public TObject Sender { get; }
    [NullableAttribute("2")]
public TValue Value { get; }
    internal bool UnobtainableValue { get; }
    public PropertyValue`2(TObject sender, TValue value);
    internal PropertyValue`2(TObject sender);
    [CompilerGeneratedAttribute]
public TObject get_Sender();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public TValue get_Value();
    [CompilerGeneratedAttribute]
internal bool get_UnobtainableValue();
    public static bool op_Equality(PropertyValue`2<TObject, TValue> left, PropertyValue`2<TObject, TValue> right);
    public static bool op_Inequality(PropertyValue`2<TObject, TValue> left, PropertyValue`2<TObject, TValue> right);
    public sealed virtual bool Equals(PropertyValue`2<TObject, TValue> other);
    [NullableContextAttribute("2")]
public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public virtual string ToString();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class DynamicData.Binding.SortAndBind`2 : object {
    private Cache`2<TObject, TKey> _cache;
    private IObservable`1<IChangeSet`2<TObject, TKey>> _sorted;
    public SortAndBind`2(IObservable`1<IChangeSet`2<TObject, TKey>> source, IComparer`1<TObject> comparer, SortAndBindOptions options, IList`1<TObject> target);
    public SortAndBind`2(IObservable`1<IChangeSet`2<TObject, TKey>> source, IObservable`1<IComparer`1<TObject>> comparerChanged, SortAndBindOptions options, IList`1<TObject> target);
    public IObservable`1<IChangeSet`2<TObject, TKey>> Run();
}
public class DynamicData.Binding.SortAndBindOptions : ValueType {
    [CompilerGeneratedAttribute]
private int <ResetThreshold>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <UseReplaceForUpdates>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <UseBinarySearch>k__BackingField;
    [CompilerGeneratedAttribute]
private int <InitialCapacity>k__BackingField;
    public int ResetThreshold { get; public set; }
    public bool UseReplaceForUpdates { get; public set; }
    public bool UseBinarySearch { get; public set; }
    public int InitialCapacity { get; public set; }
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public int get_ResetThreshold();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_ResetThreshold(int value);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public bool get_UseReplaceForUpdates();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_UseReplaceForUpdates(bool value);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public bool get_UseBinarySearch();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_UseBinarySearch(bool value);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public int get_InitialCapacity();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_InitialCapacity(int value);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public virtual string ToString();
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
private bool PrintMembers(StringBuilder builder);
    [CompilerGeneratedAttribute]
public static bool op_Inequality(SortAndBindOptions left, SortAndBindOptions right);
    [CompilerGeneratedAttribute]
public static bool op_Equality(SortAndBindOptions left, SortAndBindOptions right);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public virtual int GetHashCode();
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public virtual bool Equals(object obj);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public sealed virtual bool Equals(SortAndBindOptions other);
}
public enum DynamicData.Binding.SortDirection : Enum {
    public int value__;
    public static SortDirection Ascending;
    public static SortDirection Descending;
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class DynamicData.Binding.SortedBindingListAdaptor`2 : object {
    [CompilerGeneratedAttribute]
private int <refreshThreshold>P;
    private BindingList`1<TObject> _list;
    public SortedBindingListAdaptor`2(BindingList`1<TObject> list, int refreshThreshold);
    public sealed virtual void Adapt(ISortedChangeSet`2<TObject, TKey> changes);
    private void DoUpdate(ISortedChangeSet`2<TObject, TKey> changes);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class DynamicData.Binding.SortedObservableCollectionAdaptor`2 : object {
    [CompilerGeneratedAttribute]
private int <refreshThreshold>P;
    [CompilerGeneratedAttribute]
private bool <useReplaceForUpdates>P;
    [CompilerGeneratedAttribute]
private bool <resetOnFirstTimeLoad>P;
    public SortedObservableCollectionAdaptor`2(int refreshThreshold, bool useReplaceForUpdates, bool resetOnFirstTimeLoad);
    public SortedObservableCollectionAdaptor`2(BindingOptions options);
    public sealed virtual void Adapt(ISortedChangeSet`2<TObject, TKey> changes, IObservableCollection`1<TObject> collection);
    private void DoUpdate(ISortedChangeSet`2<TObject, TKey> updates, IObservableCollection`1<TObject> list);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class DynamicData.Binding.SortExpression`1 : object {
    [CompilerGeneratedAttribute]
private SortDirection <Direction>k__BackingField;
    [CompilerGeneratedAttribute]
private Func`2<T, IComparable> <Expression>k__BackingField;
    public SortDirection Direction { get; }
    public Func`2<T, IComparable> Expression { get; }
    public SortExpression`1(Func`2<T, IComparable> expression, SortDirection direction);
    [CompilerGeneratedAttribute]
public SortDirection get_Direction();
    [CompilerGeneratedAttribute]
public Func`2<T, IComparable> get_Expression();
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public class DynamicData.Binding.SortExpressionComparer`1 : List`1<SortExpression`1<T>> {
    public static SortExpressionComparer`1<T> Ascending(Func`2<T, IComparable> expression);
    public static SortExpressionComparer`1<T> Descending(Func`2<T, IComparable> expression);
    [NullableContextAttribute("2")]
public sealed virtual int Compare(T x, T y);
    public SortExpressionComparer`1<T> ThenByAscending(Func`2<T, IComparable> expression);
    public SortExpressionComparer`1<T> ThenByDescending(Func`2<T, IComparable> expression);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
internal static class DynamicData.Cache.CacheChangeSetEx : object {
    [ExtensionAttribute]
public static ChangeSet`2<TObject, TKey> ToConcreteType(IChangeSet`2<TObject, TKey> changeSet);
    [ExtensionAttribute]
public static IChangeSet`2<TDestination, TKey> Transform(IChangeSet`2<TSource, TKey> source, Func`2<TSource, TDestination> transformer);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal abstract class DynamicData.Cache.Internal.AbstractFilter`2 : object {
    private ChangeAwareCache`2<TObject, TKey> _cache;
    [CompilerGeneratedAttribute]
private Func`2<TObject, bool> <Filter>k__BackingField;
    public Func`2<TObject, bool> Filter { get; }
    protected AbstractFilter`2(ChangeAwareCache`2<TObject, TKey> cache, Func`2<TObject, bool> filter);
    [CompilerGeneratedAttribute]
public sealed virtual Func`2<TObject, bool> get_Filter();
    public sealed virtual IChangeSet`2<TObject, TKey> Refresh(IEnumerable`1<KeyValuePair`2<TKey, TObject>> items);
    public sealed virtual IChangeSet`2<TObject, TKey> Update(IChangeSet`2<TObject, TKey> updates);
    protected abstract virtual IEnumerable`1<UpdateWithFilter<TObject, TKey>> GetChangesWithFilter(ChangeSet`2<TObject, TKey> updates);
    protected abstract virtual IEnumerable`1<Change`2<TObject, TKey>> Refresh(IEnumerable`1<KeyValuePair`2<TKey, TObject>> items, Func`2<KeyValuePair`2<TKey, TObject>, Optional`1<Change`2<TObject, TKey>>> factory);
    private ChangeSet`2<TObject, TKey> ProcessResult(IEnumerable`1<UpdateWithFilter<TObject, TKey>> source);
    [CompilerGeneratedAttribute]
private Optional`1<Change`2<TObject, TKey>> <Refresh>g__Factory|5_0(KeyValuePair`2<TKey, TObject> kv);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[DebuggerDisplayAttribute("AnonymousObservableCache<{typeof(TObject).Name}, {typeof(TKey).Name}> ({Count} Items)")]
internal class DynamicData.Cache.Internal.AnonymousObservableCache`2 : object {
    private IObservableCache`2<TObject, TKey> _cache;
    private IDisposable _cleanUp;
    public int Count { get; }
    public IObservable`1<int> CountChanged { get; }
    public IReadOnlyList`1<TObject> Items { get; }
    public IReadOnlyList`1<TKey> Keys { get; }
    public IReadOnlyDictionary`2<TKey, TObject> KeyValues { get; }
    public AnonymousObservableCache`2(IObservable`1<IChangeSet`2<TObject, TKey>> source);
    public AnonymousObservableCache`2(IObservableCache`2<TObject, TKey> cache);
    public sealed virtual int get_Count();
    public sealed virtual IObservable`1<int> get_CountChanged();
    public sealed virtual IReadOnlyList`1<TObject> get_Items();
    public sealed virtual IReadOnlyList`1<TKey> get_Keys();
    public sealed virtual IReadOnlyDictionary`2<TKey, TObject> get_KeyValues();
    public sealed virtual IObservable`1<IChangeSet`2<TObject, TKey>> Connect(Func`2<TObject, bool> predicate, bool suppressEmptyChangeSets);
    public sealed virtual Optional`1<TObject> Lookup(TKey key);
    public sealed virtual IObservable`1<IChangeSet`2<TObject, TKey>> Preview(Func`2<TObject, bool> predicate);
    public sealed virtual IObservable`1<Change`2<TObject, TKey>> Watch(TKey key);
    public sealed virtual void Dispose();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class DynamicData.Cache.Internal.AnonymousQuery`2 : object {
    private Cache`2<TObject, TKey> _cache;
    public int Count { get; }
    public IEnumerable`1<TObject> Items { get; }
    public IEnumerable`1<TKey> Keys { get; }
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public IEnumerable`1<KeyValuePair`2<TKey, TObject>> KeyValues { get; }
    public AnonymousQuery`2(Cache`2<TObject, TKey> cache);
    public sealed virtual int get_Count();
    public sealed virtual IEnumerable`1<TObject> get_Items();
    public sealed virtual IEnumerable`1<TKey> get_Keys();
    public sealed virtual IEnumerable`1<KeyValuePair`2<TKey, TObject>> get_KeyValues();
    public sealed virtual Optional`1<TObject> Lookup(TKey key);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class DynamicData.Cache.Internal.AutoRefresh`3 : object {
    [CompilerGeneratedAttribute]
private Nullable`1<TimeSpan> <buffer>P;
    private Func`3<TObject, TKey, IObservable`1<TAny>> _reEvaluator;
    private IScheduler _scheduler;
    private IObservable`1<IChangeSet`2<TObject, TKey>> _source;
    public AutoRefresh`3(IObservable`1<IChangeSet`2<TObject, TKey>> source, Func`3<TObject, TKey, IObservable`1<TAny>> reEvaluator, Nullable`1<TimeSpan> buffer, IScheduler scheduler);
    public IObservable`1<IChangeSet`2<TObject, TKey>> Run();
    [CompilerGeneratedAttribute]
private IDisposable <Run>b__5_0(IObserver`1<IChangeSet`2<TObject, TKey>> observer);
    [CompilerGeneratedAttribute]
private IObservable`1<Change`2<TObject, TKey>> <Run>b__5_1(TObject t, TKey k);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class DynamicData.Cache.Internal.BatchIf`2 : object {
    [CompilerGeneratedAttribute]
private Nullable`1<TimeSpan> <timeOut>P;
    [CompilerGeneratedAttribute]
private bool <initialPauseState>P;
    [NullableAttribute("2")]
[CompilerGeneratedAttribute]
private IObservable`1<Unit> <intervalTimer>P;
    private IObservable`1<bool> _pauseIfTrueSelector;
    private IScheduler _scheduler;
    private IObservable`1<IChangeSet`2<TObject, TKey>> _source;
    public BatchIf`2(IObservable`1<IChangeSet`2<TObject, TKey>> source, IObservable`1<bool> pauseIfTrueSelector, Nullable`1<TimeSpan> timeOut, bool initialPauseState, IObservable`1<Unit> intervalTimer, IScheduler scheduler);
    public IObservable`1<ChangeSet`2<TObject, TKey>> Run();
    [CompilerGeneratedAttribute]
private IDisposable <Run>b__7_0(IObserver`1<ChangeSet`2<TObject, TKey>> observer);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[DebuggerDisplayAttribute("Cache<{typeof(TObject).Name}, {typeof(TKey).Name}> ({Count} Items)")]
internal class DynamicData.Cache.Internal.Cache`2 : object {
    public static Cache`2<TObject, TKey> Empty;
    private Dictionary`2<TKey, TObject> _data;
    public int Count { get; }
    public IEnumerable`1<TObject> Items { get; }
    public IEnumerable`1<TKey> Keys { get; }
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public IEnumerable`1<KeyValuePair`2<TKey, TObject>> KeyValues { get; }
    public Cache`2(int capacity);
    public Cache`2(Dictionary`2<TKey, TObject> data);
    private static Cache`2();
    public sealed virtual int get_Count();
    public sealed virtual IEnumerable`1<TObject> get_Items();
    public sealed virtual IEnumerable`1<TKey> get_Keys();
    public sealed virtual IEnumerable`1<KeyValuePair`2<TKey, TObject>> get_KeyValues();
    public sealed virtual void AddOrUpdate(TObject item, TKey key);
    public sealed virtual void Clear();
    public Cache`2<TObject, TKey> Clone();
    public sealed virtual void Clone(IChangeSet`2<TObject, TKey> changes);
    public sealed virtual Optional`1<TObject> Lookup(TKey key);
    public sealed virtual void Refresh();
    public sealed virtual void Refresh(IEnumerable`1<TKey> keys);
    public sealed virtual void Refresh(TKey key);
    public sealed virtual void Remove(IEnumerable`1<TKey> keys);
    public sealed virtual void Remove(TKey key);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
internal static class DynamicData.Cache.Internal.CacheEx : object {
    [ExtensionAttribute]
public static void Clone(IDictionary`2<TKey, TObject> source, IChangeSet`2<TObject, TKey> changes);
    [ExtensionAttribute]
public static IChangeSet`2<TObject, TKey> GetInitialUpdates(ChangeAwareCache`2<TObject, TKey> source, Func`2<TObject, bool> filter);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class DynamicData.Cache.Internal.CacheUpdater`2 : object {
    private ICache`2<TObject, TKey> _cache;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private Func`2<TObject, TKey> _keySelector;
    public int Count { get; }
    public IEnumerable`1<TObject> Items { get; }
    public IEnumerable`1<TKey> Keys { get; }
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public IEnumerable`1<KeyValuePair`2<TKey, TObject>> KeyValues { get; }
    public CacheUpdater`2(ICache`2<TObject, TKey> cache, Func`2<TObject, TKey> keySelector);
    public CacheUpdater`2(Dictionary`2<TKey, TObject> data, Func`2<TObject, TKey> keySelector);
    public sealed virtual int get_Count();
    public sealed virtual IEnumerable`1<TObject> get_Items();
    public sealed virtual IEnumerable`1<TKey> get_Keys();
    public sealed virtual IEnumerable`1<KeyValuePair`2<TKey, TObject>> get_KeyValues();
    public sealed virtual void AddOrUpdate(IEnumerable`1<TObject> items);
    public sealed virtual void AddOrUpdate(IEnumerable`1<TObject> items, IEqualityComparer`1<TObject> comparer);
    public sealed virtual void AddOrUpdate(TObject item);
    public sealed virtual void AddOrUpdate(TObject item, IEqualityComparer`1<TObject> comparer);
    public sealed virtual void AddOrUpdate(IEnumerable`1<KeyValuePair`2<TKey, TObject>> itemsPairs);
    public sealed virtual void AddOrUpdate(KeyValuePair`2<TKey, TObject> item);
    public sealed virtual void AddOrUpdate(TObject item, TKey key);
    public sealed virtual void Clear();
    public sealed virtual void Clone(IChangeSet`2<TObject, TKey> changes);
    public sealed virtual TKey GetKey(TObject item);
    public sealed virtual IEnumerable`1<KeyValuePair`2<TKey, TObject>> GetKeyValues(IEnumerable`1<TObject> items);
    public sealed virtual void Load(IEnumerable`1<TObject> items);
    public sealed virtual Optional`1<TObject> Lookup(TKey key);
    public Optional`1<TObject> Lookup(TObject item);
    public sealed virtual void Refresh();
    public sealed virtual void Refresh(IEnumerable`1<TObject> items);
    public sealed virtual void Refresh(IEnumerable`1<TKey> keys);
    public sealed virtual void Refresh(TObject item);
    public sealed virtual void Refresh(TKey key);
    public sealed virtual void Remove(IEnumerable`1<TObject> items);
    public sealed virtual void Remove(IEnumerable`1<TKey> keys);
    public sealed virtual void Remove(TObject item);
    public sealed virtual void Remove(TKey key);
    public sealed virtual void Remove(IEnumerable`1<KeyValuePair`2<TKey, TObject>> items);
    public sealed virtual void Remove(KeyValuePair`2<TKey, TObject> item);
    public sealed virtual void RemoveKey(TKey key);
    public sealed virtual void RemoveKeys(IEnumerable`1<TKey> keys);
    public sealed virtual void Update(IChangeSet`2<TObject, TKey> changes);
    [NullableContextAttribute("0")]
[CompilerGeneratedAttribute]
private void <AddOrUpdate>g__AddOrUpdateImpl|13_0(TObject item, <>c__DisplayClass13_0& );
    [NullableContextAttribute("0")]
[CompilerGeneratedAttribute]
private KeyValuePair`2<TKey, TObject> <GetKeyValues>b__22_0(TObject t);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class DynamicData.Cache.Internal.Cast`3 : object {
    private Func`2<TSource, TDestination> _converter;
    private IObservable`1<IChangeSet`2<TSource, TKey>> _source;
    public Cast`3(IObservable`1<IChangeSet`2<TSource, TKey>> source, Func`2<TSource, TDestination> converter);
    public IObservable`1<IChangeSet`2<TDestination, TKey>> Run();
    [NullableContextAttribute("0")]
[CompilerGeneratedAttribute]
private ChangeSet`2<TDestination, TKey> <Run>b__3_0(IChangeSet`2<TSource, TKey> changes);
    [NullableContextAttribute("0")]
[CompilerGeneratedAttribute]
private Change`2<TDestination, TKey> <Run>b__3_1(Change`2<TSource, TKey> change);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class DynamicData.Cache.Internal.ChangeSetCache`2 : object {
    [CompilerGeneratedAttribute]
private Cache`2<TObject, TKey> <Cache>k__BackingField;
    [CompilerGeneratedAttribute]
private IObservable`1<IChangeSet`2<TObject, TKey>> <Source>k__BackingField;
    public Cache`2<TObject, TKey> Cache { get; }
    public IObservable`1<IChangeSet`2<TObject, TKey>> Source { get; }
    public ChangeSetCache`2(IObservable`1<IChangeSet`2<TObject, TKey>> source);
    [CompilerGeneratedAttribute]
public Cache`2<TObject, TKey> get_Cache();
    [CompilerGeneratedAttribute]
public IObservable`1<IChangeSet`2<TObject, TKey>> get_Source();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class DynamicData.Cache.Internal.ChangeSetMergeTracker`2 : object {
    [CompilerGeneratedAttribute]
private Func`1<IEnumerable`1<ChangeSetCache`2<TObject, TKey>>> <selectCaches>P;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private IComparer`1<TObject> <comparer>P;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private IEqualityComparer`1<TObject> <equalityComparer>P;
    private ChangeAwareCache`2<TObject, TKey> _resultCache;
    private bool _hasCompleted;
    public ChangeSetMergeTracker`2(Func`1<IEnumerable`1<ChangeSetCache`2<TObject, TKey>>> selectCaches, IComparer`1<TObject> comparer, IEqualityComparer`1<TObject> equalityComparer);
    public void MarkComplete();
    public void RemoveItems(IEnumerable`1<KeyValuePair`2<TKey, TObject>> items, IObserver`1<IChangeSet`2<TObject, TKey>> observer);
    public void RefreshItems(IEnumerable`1<TKey> keys, IObserver`1<IChangeSet`2<TObject, TKey>> observer);
    public void ProcessChangeSet(IChangeSet`2<TObject, TKey> changes, IObserver`1<IChangeSet`2<TObject, TKey>> observer);
    public void EmitChanges(IObserver`1<IChangeSet`2<TObject, TKey>> observer);
    private void OnItemAdded(TObject item, TKey key);
    private void OnItemRemoved(ChangeSetCache`2[] sourceCaches, TObject item, TKey key);
    private void OnItemUpdated(ChangeSetCache`2[] sources, TObject item, TKey key, Optional`1& prev);
    private void OnItemRefreshed(ChangeSetCache`2[] sources, TObject item, TKey key);
    private void ForceEvaluate(ChangeSetCache`2[] sources, TKey key);
    private bool UpdateToBestValue(ChangeSetCache`2[] sources, TKey key, Optional`1& current);
    private Optional`1<TObject> LookupBestValue(ChangeSetCache`2[] sources, TKey key);
    private bool CheckEquality(TObject left, TObject right);
    private bool ShouldReplace(TObject candidate, TObject current);
}
public enum DynamicData.Cache.Internal.CombineOperator : Enum {
    public int value__;
    public static CombineOperator And;
    public static CombineOperator Or;
    public static CombineOperator Xor;
    public static CombineOperator Except;
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class DynamicData.Cache.Internal.Combiner`2 : object {
    [CompilerGeneratedAttribute]
private CombineOperator <type>P;
    [CompilerGeneratedAttribute]
private Action`1<IChangeSet`2<TObject, TKey>> <updatedCallback>P;
    private ChangeAwareCache`2<TObject, TKey> _combinedCache;
    private object _locker;
    private IList`1<Cache`2<TObject, TKey>> _sourceCaches;
    public Combiner`2(CombineOperator type, Action`1<IChangeSet`2<TObject, TKey>> updatedCallback);
    public IDisposable Subscribe(IObservable`1[] source);
    private bool MatchesConstraint(TKey key);
    private void Update(Cache`2<TObject, TKey> cache, IChangeSet`2<TObject, TKey> updates);
    private ChangeSet`2<TObject, TKey> UpdateCombined(IChangeSet`2<TObject, TKey> updates);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class DynamicData.Cache.Internal.DeferUntilLoaded`2 : object {
    private IObservable`1<IChangeSet`2<TObject, TKey>> _result;
    public DeferUntilLoaded`2(IObservableCache`2<TObject, TKey> source);
    public DeferUntilLoaded`2(IObservable`1<IChangeSet`2<TObject, TKey>> source);
    public IObservable`1<IChangeSet`2<TObject, TKey>> Run();
}
[ExtensionAttribute]
internal static class DynamicData.Cache.Internal.DictionaryExtensions : object {
    [NullableContextAttribute("1")]
[ExtensionAttribute]
internal static IEnumerable`1<T> GetOrEmpty(IDictionary`2<TDictKey, IEnumerable`1<T>> dict, TDictKey key);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class DynamicData.Cache.Internal.DisposeMany`2 : object {
    private IObservable`1<IChangeSet`2<TObject, TKey>> _source;
    public DisposeMany`2(IObservable`1<IChangeSet`2<TObject, TKey>> source);
    public IObservable`1<IChangeSet`2<TObject, TKey>> Run();
    private static void ProcessFinalization(Dictionary`2<TKey, TObject> cachedItems);
    [CompilerGeneratedAttribute]
private IDisposable <Run>b__2_0(IObserver`1<IChangeSet`2<TObject, TKey>> observer);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class DynamicData.Cache.Internal.DistinctCalculator`3 : object {
    [CompilerGeneratedAttribute]
private IObservable`1<IChangeSet`2<TObject, TKey>> <source>P;
    private Dictionary`2<TKey, TValue> _itemCache;
    private Dictionary`2<TKey, int> _keyCounters;
    private Dictionary`2<TValue, int> _valueCounters;
    private Func`2<TObject, TValue> _valueSelector;
    public DistinctCalculator`3(IObservable`1<IChangeSet`2<TObject, TKey>> source, Func`2<TObject, TValue> valueSelector);
    public IObservable`1<DistinctChangeSet`1<TValue>> Run();
    private DistinctChangeSet`1<TValue> Calculate(IChangeSet`2<TObject, TKey> changes);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class DynamicData.Cache.Internal.DynamicCombiner`2 : object {
    [CompilerGeneratedAttribute]
private CombineOperator <type>P;
    private IObservableList`1<IObservable`1<IChangeSet`2<TObject, TKey>>> _source;
    public DynamicCombiner`2(IObservableList`1<IObservable`1<IChangeSet`2<TObject, TKey>>> source, CombineOperator type);
    public IObservable`1<IChangeSet`2<TObject, TKey>> Run();
    private bool MatchesConstraint(MergeContainer[] sources, TKey key);
    private void ProcessChanges(ChangeAwareCache`2<TObject, TKey> target, MergeContainer[] sourceLists, IEnumerable`1<KeyValuePair`2<TKey, TObject>> items);
    private void ProcessItem(ChangeAwareCache`2<TObject, TKey> target, MergeContainer[] sourceLists, TObject item, TKey key);
    private void UpdateResultList(ChangeAwareCache`2<TObject, TKey> target, MergeContainer[] sourceLists, IChangeSet`2<TObject, TKey> changes);
    [CompilerGeneratedAttribute]
private IDisposable <Run>b__3_0(IObserver`1<IChangeSet`2<TObject, TKey>> observer);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class DynamicData.Cache.Internal.DynamicFilter`2 : object {
    [NullableAttribute("2")]
[CompilerGeneratedAttribute]
private IObservable`1<Unit> <refilterObservable>P;
    [CompilerGeneratedAttribute]
private bool <suppressEmptyChangeSets>P;
    private IObservable`1<Func`2<TObject, bool>> _predicateChanged;
    private IObservable`1<IChangeSet`2<TObject, TKey>> _source;
    public DynamicFilter`2(IObservable`1<IChangeSet`2<TObject, TKey>> source, IObservable`1<Func`2<TObject, bool>> predicateChanged, IObservable`1<Unit> refilterObservable, bool suppressEmptyChangeSets);
    public IObservable`1<IChangeSet`2<TObject, TKey>> Run();
    private IObservable`1<Func`2<TObject, bool>> LatestPredicateObservable();
    [CompilerGeneratedAttribute]
private IDisposable <Run>b__5_0(IObserver`1<IChangeSet`2<TObject, TKey>> observer);
    [CompilerGeneratedAttribute]
private IDisposable <LatestPredicateObservable>b__6_0(IObserver`1<Func`2<TObject, bool>> observable);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class DynamicData.Cache.Internal.DynamicGrouper`3 : object {
    private ChangeAwareCache`2<IGroup`3<TObject, TKey, TGroupKey>, TGroupKey> _groupCache;
    private Dictionary`2<TKey, TGroupKey> _groupKeys;
    private HashSet`1<ManagedGroup`3<TObject, TKey, TGroupKey>> _emptyGroups;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private SuspendTracker<TObject, TKey, TGroupKey> _suspendTracker;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private Func`3<TObject, TKey, TGroupKey> _groupSelector;
    public DynamicGrouper`3(Func`3<TObject, TKey, TGroupKey> groupSelector);
    public void AddOrUpdate(TKey key, TGroupKey groupKey, TObject item, IObserver`1<IGroupChangeSet`3<TObject, TKey, TGroupKey>> observer);
    public void ProcessChangeSet(IChangeSet`2<TObject, TKey> changeSet, IObserver`1<IGroupChangeSet`3<TObject, TKey, TGroupKey>> observer);
    public void RegroupAll(IObserver`1<IGroupChangeSet`3<TObject, TKey, TGroupKey>> observer);
    public void SetGroupSelector(Func`3<TObject, TKey, TGroupKey> groupSelector, IObserver`1<IGroupChangeSet`3<TObject, TKey, TGroupKey>> observer);
    public void Initialize(IEnumerable`1<KeyValuePair`2<TKey, TObject>> initialValues, Func`3<TObject, TKey, TGroupKey> groupSelector, IObserver`1<IGroupChangeSet`3<TObject, TKey, TGroupKey>> observer);
    public void EmitChanges(IObserver`1<IGroupChangeSet`3<TObject, TKey, TGroupKey>> observer);
    public sealed virtual void Dispose();
    private static void PerformGroupRefresh(TKey key, Optional`1& optionalGroup, SuspendTracker<TObject, TKey, TGroupKey> suspendTracker);
    private Optional`1<ManagedGroup`3<TObject, TKey, TGroupKey>> LookupGroup(TKey key);
    private Optional`1<ManagedGroup`3<TObject, TKey, TGroupKey>> LookupGroup(TGroupKey groupKey);
    private ManagedGroup`3<TObject, TKey, TGroupKey> GetOrAddGroup(TGroupKey groupKey);
    private void PerformAddOrUpdate(TKey key, TGroupKey groupKey, TObject item, SuspendTracker<TObject, TKey, TGroupKey> suspendTracker);
    private void PerformGroupAddOrUpdate(TKey key, TGroupKey groupKey, TObject item, SuspendTracker<TObject, TKey, TGroupKey> suspendTracker);
    private void PerformRefresh(TKey key, SuspendTracker<TObject, TKey, TGroupKey> suspendTracker);
    private void PerformRefresh(TKey key, TGroupKey newGroupKey, TObject item, SuspendTracker<TObject, TKey, TGroupKey> suspendTracker);
    private void PerformRemove(TKey key, SuspendTracker<TObject, TKey, TGroupKey> suspendTracker);
    private void PerformRemove(TKey key, TGroupKey groupKey, SuspendTracker<TObject, TKey, TGroupKey> suspendTracker);
    private void PerformUpdate(TKey key, SuspendTracker<TObject, TKey, TGroupKey> suspendTracker);
    [NullableContextAttribute("0")]
[CompilerGeneratedAttribute]
private IEnumerable`1<ValueTuple`3<KeyValuePair`2<TKey, TObject>, ManagedGroup`3<TObject, TKey, TGroupKey>, TGroupKey>> <RegroupAll>b__8_0(IGroup`3<TObject, TKey, TGroupKey> group);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class DynamicData.Cache.Internal.EditDiff`2 : object {
    private Func`3<TObject, TObject, bool> _areEqual;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private IEqualityComparer`1<KeyValuePair`2<TKey, TObject>> _keyComparer;
    private ISourceCache`2<TObject, TKey> _source;
    public EditDiff`2(ISourceCache`2<TObject, TKey> source, Func`3<TObject, TObject, bool> areEqual);
    public void Edit(IEnumerable`1<TObject> items);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class DynamicData.Cache.Internal.EditDiffChangeSet`2 : object {
    private IObservable`1<IEnumerable`1<TObject>> _source;
    private IEqualityComparer`1<TObject> _equalityComparer;
    private Func`2<TObject, TKey> _keySelector;
    public EditDiffChangeSet`2(IObservable`1<IEnumerable`1<TObject>> source, Func`2<TObject, TKey> keySelector, IEqualityComparer`1<TObject> equalityComparer);
    public IObservable`1<IChangeSet`2<TObject, TKey>> Run();
    [CompilerGeneratedAttribute]
private IDisposable <Run>b__4_0(ISourceCache`2<TObject, TKey> cache);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class DynamicData.Cache.Internal.EditDiffChangeSetOptional`2 : object {
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private IObservable`1<Optional`1<TObject>> _source;
    private IEqualityComparer`1<TObject> _equalityComparer;
    private Func`2<TObject, TKey> _keySelector;
    public EditDiffChangeSetOptional`2(IObservable`1<Optional`1<TObject>> source, Func`2<TObject, TKey> keySelector, IEqualityComparer`1<TObject> equalityComparer);
    public IObservable`1<IChangeSet`2<TObject, TKey>> Run();
    [NullableContextAttribute("0")]
private Change`2[] CreateUpdateChanges(ValueContainer& prev, ValueContainer& curr);
    [CompilerGeneratedAttribute]
private IDisposable <Run>b__4_0(IObserver`1<IChangeSet`2<TObject, TKey>> observer);
    [NullableContextAttribute("0")]
[CompilerGeneratedAttribute]
private ValueContainer<TObject, TKey> <Run>b__4_2(TObject val);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[IsReadOnlyAttribute]
internal class DynamicData.Cache.Internal.ExpirableItem`2 : ValueType {
    [CompilerGeneratedAttribute]
private TObject <Value>k__BackingField;
    [CompilerGeneratedAttribute]
private TKey <Key>k__BackingField;
    [CompilerGeneratedAttribute]
private DateTime <ExpireAt>k__BackingField;
    [CompilerGeneratedAttribute]
private long <Index>k__BackingField;
    public TObject Value { get; }
    public TKey Key { get; }
    public DateTime ExpireAt { get; }
    public long Index { get; }
    public ExpirableItem`2(TObject value, TKey key, DateTime dateTime, long index);
    [CompilerGeneratedAttribute]
public TObject get_Value();
    [CompilerGeneratedAttribute]
public TKey get_Key();
    [CompilerGeneratedAttribute]
public DateTime get_ExpireAt();
    [CompilerGeneratedAttribute]
public long get_Index();
    public static bool op_Equality(ExpirableItem`2& left, ExpirableItem`2& right);
    public static bool op_Inequality(ExpirableItem`2& left, ExpirableItem`2& right);
    public sealed virtual bool Equals(ExpirableItem`2<TObject, TKey> other);
    [NullableContextAttribute("2")]
public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public virtual string ToString();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal static class DynamicData.Cache.Internal.ExpireAfter : object {
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal static class DynamicData.Cache.Internal.FilteredIndexCalculator`2 : object {
    public static IList`1<Change`2<TObject, TKey>> Calculate(IKeyValueCollection`2<TObject, TKey> currentItems, IKeyValueCollection`2<TObject, TKey> previousItems, IChangeSet`2<TObject, TKey> sourceUpdates);
    private static int GetInsertPositionLinear(IList`1<KeyValuePair`2<TKey, TObject>> list, KeyValuePair`2<TKey, TObject> item, IComparer`1<KeyValuePair`2<TKey, TObject>> comparer);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
internal static class DynamicData.Cache.Internal.FilterEx : object {
    [ExtensionAttribute]
public static void FilterChanges(ChangeAwareCache`2<TObject, TKey> cache, IChangeSet`2<TObject, TKey> changes, Func`2<TObject, bool> predicate);
    [ExtensionAttribute]
public static IChangeSet`2<TObject, TKey> RefreshFilteredFrom(ChangeAwareCache`2<TObject, TKey> filtered, Cache`2<TObject, TKey> allData, Func`2<TObject, bool> predicate);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class DynamicData.Cache.Internal.FilterImmutable`2 : object {
    private Action`2<IObserver`1<IChangeSet`2<TObject, TKey>>, IChangeSet`2<TObject, TKey>> _onNextInvoker;
    private Func`2<TObject, bool> _predicate;
    private IObservable`1<IChangeSet`2<TObject, TKey>> _source;
    public FilterImmutable`2(Func`2<TObject, bool> predicate, IObservable`1<IChangeSet`2<TObject, TKey>> source, bool suppressEmptyChangeSets);
    public IObservable`1<IChangeSet`2<TObject, TKey>> Run();
    [CompilerGeneratedAttribute]
private IDisposable <Run>b__4_0(IObserver`1<IChangeSet`2<TObject, TKey>> observer);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class DynamicData.Cache.Internal.FilterOnObservable`2 : object {
    [CompilerGeneratedAttribute]
private Nullable`1<TimeSpan> <buffer>P;
    [NullableAttribute("2")]
[CompilerGeneratedAttribute]
private IScheduler <scheduler>P;
    private Func`3<TObject, TKey, IObservable`1<bool>> _filterFactory;
    private IObservable`1<IChangeSet`2<TObject, TKey>> _source;
    public FilterOnObservable`2(IObservable`1<IChangeSet`2<TObject, TKey>> source, Func`3<TObject, TKey, IObservable`1<bool>> filterFactory, Nullable`1<TimeSpan> buffer, IScheduler scheduler);
    public IObservable`1<IChangeSet`2<TObject, TKey>> Run();
    [CompilerGeneratedAttribute]
private FilterProxy<TObject, TKey> <Run>b__5_0(TObject val, TKey key);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ObsoleteAttribute("Use AutoRefresh(), followed by Filter() instead")]
internal class DynamicData.Cache.Internal.FilterOnProperty`3 : object {
    [CompilerGeneratedAttribute]
private IObservable`1<IChangeSet`2<TObject, TKey>> <source>P;
    [CompilerGeneratedAttribute]
private Expression`1<Func`2<TObject, TProperty>> <propertySelector>P;
    [CompilerGeneratedAttribute]
private Func`2<TObject, bool> <predicate>P;
    [CompilerGeneratedAttribute]
private Nullable`1<TimeSpan> <throttle>P;
    [NullableAttribute("2")]
[CompilerGeneratedAttribute]
private IScheduler <scheduler>P;
    public FilterOnProperty`3(IObservable`1<IChangeSet`2<TObject, TKey>> source, Expression`1<Func`2<TObject, TProperty>> propertySelector, Func`2<TObject, bool> predicate, Nullable`1<TimeSpan> throttle, IScheduler scheduler);
    public IObservable`1<IChangeSet`2<TObject, TKey>> Run();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class DynamicData.Cache.Internal.FinallySafe`1 : object {
    private Action _finallyAction;
    private IObservable`1<T> _source;
    public FinallySafe`1(IObservable`1<T> source, Action finallyAction);
    public IObservable`1<T> Run();
    [CompilerGeneratedAttribute]
private IDisposable <Run>b__3_0(IObserver`1<T> o);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class DynamicData.Cache.Internal.FullJoin`5 : object {
    private IObservable`1<IChangeSet`2<TLeft, TLeftKey>> _left;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private Func`4<TLeftKey, Optional`1<TLeft>, Optional`1<TRight>, TDestination> _resultSelector;
    private IObservable`1<IChangeSet`2<TRight, TRightKey>> _right;
    private Func`2<TRight, TLeftKey> _rightKeySelector;
    public FullJoin`5(IObservable`1<IChangeSet`2<TLeft, TLeftKey>> left, IObservable`1<IChangeSet`2<TRight, TRightKey>> right, Func`2<TRight, TLeftKey> rightKeySelector, Func`4<TLeftKey, Optional`1<TLeft>, Optional`1<TRight>, TDestination> resultSelector);
    public IObservable`1<IChangeSet`2<TDestination, TLeftKey>> Run();
    [CompilerGeneratedAttribute]
private IDisposable <Run>b__5_0(IObserver`1<IChangeSet`2<TDestination, TLeftKey>> observer);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class DynamicData.Cache.Internal.FullJoinMany`5 : object {
    private IObservable`1<IChangeSet`2<TLeft, TLeftKey>> _left;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private Func`4<TLeftKey, Optional`1<TLeft>, IGrouping`3<TRight, TRightKey, TLeftKey>, TDestination> _resultSelector;
    private IObservable`1<IChangeSet`2<TRight, TRightKey>> _right;
    private Func`2<TRight, TLeftKey> _rightKeySelector;
    public FullJoinMany`5(IObservable`1<IChangeSet`2<TLeft, TLeftKey>> left, IObservable`1<IChangeSet`2<TRight, TRightKey>> right, Func`2<TRight, TLeftKey> rightKeySelector, Func`4<TLeftKey, Optional`1<TLeft>, IGrouping`3<TRight, TRightKey, TLeftKey>, TDestination> resultSelector);
    public IObservable`1<IChangeSet`2<TDestination, TLeftKey>> Run();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class DynamicData.Cache.Internal.GroupOn`3 : object {
    private Func`2<TObject, TGroupKey> _groupSelectorKey;
    private IObservable`1<Unit> _regrouper;
    private IObservable`1<IChangeSet`2<TObject, TKey>> _source;
    public GroupOn`3(IObservable`1<IChangeSet`2<TObject, TKey>> source, Func`2<TObject, TGroupKey> groupSelectorKey, IObservable`1<Unit> regrouper);
    public IObservable`1<IGroupChangeSet`3<TObject, TKey, TGroupKey>> Run();
    [CompilerGeneratedAttribute]
private IDisposable <Run>b__4_0(IObserver`1<IGroupChangeSet`3<TObject, TKey, TGroupKey>> observer);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class DynamicData.Cache.Internal.GroupOnDynamic`3 : object {
    [CompilerGeneratedAttribute]
private IObservable`1<IChangeSet`2<TObject, TKey>> <source>P;
    [CompilerGeneratedAttribute]
private IObservable`1<Func`3<TObject, TKey, TGroupKey>> <selectGroupObservable>P;
    [NullableAttribute("2")]
[CompilerGeneratedAttribute]
private IObservable`1<Unit> <regrouper>P;
    public GroupOnDynamic`3(IObservable`1<IChangeSet`2<TObject, TKey>> source, IObservable`1<Func`3<TObject, TKey, TGroupKey>> selectGroupObservable, IObservable`1<Unit> regrouper);
    public IObservable`1<IGroupChangeSet`3<TObject, TKey, TGroupKey>> Run();
    [CompilerGeneratedAttribute]
private IDisposable <Run>b__4_0(IObserver`1<IGroupChangeSet`3<TObject, TKey, TGroupKey>> observer);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class DynamicData.Cache.Internal.GroupOnImmutable`3 : object {
    private Func`2<TObject, TGroupKey> _groupSelectorKey;
    private IObservable`1<Unit> _regrouper;
    private IObservable`1<IChangeSet`2<TObject, TKey>> _source;
    public GroupOnImmutable`3(IObservable`1<IChangeSet`2<TObject, TKey>> source, Func`2<TObject, TGroupKey> groupSelectorKey, IObservable`1<Unit> regrouper);
    public IObservable`1<IImmutableGroupChangeSet`3<TObject, TKey, TGroupKey>> Run();
    [CompilerGeneratedAttribute]
private IDisposable <Run>b__4_0(IObserver`1<IImmutableGroupChangeSet`3<TObject, TKey, TGroupKey>> observer);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class DynamicData.Cache.Internal.GroupOnObservable`3 : object {
    [CompilerGeneratedAttribute]
private IObservable`1<IChangeSet`2<TObject, TKey>> <source>P;
    [CompilerGeneratedAttribute]
private Func`3<TObject, TKey, IObservable`1<TGroupKey>> <selectGroup>P;
    public GroupOnObservable`3(IObservable`1<IChangeSet`2<TObject, TKey>> source, Func`3<TObject, TKey, IObservable`1<TGroupKey>> selectGroup);
    public IObservable`1<IGroupChangeSet`3<TObject, TKey, TGroupKey>> Run();
    [CompilerGeneratedAttribute]
private IDisposable <Run>b__3_0(IObserver`1<IGroupChangeSet`3<TObject, TKey, TGroupKey>> observer);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class DynamicData.Cache.Internal.GroupOnProperty`3 : object {
    [CompilerGeneratedAttribute]
private Expression`1<Func`2<TObject, TGroup>> <groupSelectorKey>P;
    [CompilerGeneratedAttribute]
private Nullable`1<TimeSpan> <throttle>P;
    [NullableAttribute("2")]
[CompilerGeneratedAttribute]
private IScheduler <scheduler>P;
    private Func`2<TObject, TGroup> _groupSelector;
    private IObservable`1<IChangeSet`2<TObject, TKey>> _source;
    public GroupOnProperty`3(IObservable`1<IChangeSet`2<TObject, TKey>> source, Expression`1<Func`2<TObject, TGroup>> groupSelectorKey, Nullable`1<TimeSpan> throttle, IScheduler scheduler);
    public IObservable`1<IGroupChangeSet`3<TObject, TKey, TGroup>> Run();
    [CompilerGeneratedAttribute]
private IObservable`1<IGroupChangeSet`3<TObject, TKey, TGroup>> <Run>b__6_0(IObservable`1<IChangeSet`2<TObject, TKey>> shared);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class DynamicData.Cache.Internal.GroupOnPropertyWithImmutableState`3 : object {
    [CompilerGeneratedAttribute]
private Expression`1<Func`2<TObject, TGroup>> <groupSelectorKey>P;
    [CompilerGeneratedAttribute]
private Nullable`1<TimeSpan> <throttle>P;
    private Func`2<TObject, TGroup> _groupSelector;
    private IScheduler _scheduler;
    private IObservable`1<IChangeSet`2<TObject, TKey>> _source;
    public GroupOnPropertyWithImmutableState`3(IObservable`1<IChangeSet`2<TObject, TKey>> source, Expression`1<Func`2<TObject, TGroup>> groupSelectorKey, Nullable`1<TimeSpan> throttle, IScheduler scheduler);
    public IObservable`1<IImmutableGroupChangeSet`3<TObject, TKey, TGroup>> Run();
    [CompilerGeneratedAttribute]
private IObservable`1<IImmutableGroupChangeSet`3<TObject, TKey, TGroup>> <Run>b__6_0(IObservable`1<IChangeSet`2<TObject, TKey>> shared);
}
[NullableContextAttribute("1")]
internal interface DynamicData.Cache.Internal.IFilter`2 {
    public Func`2<TObject, bool> Filter { get; }
    public abstract virtual Func`2<TObject, bool> get_Filter();
    public abstract virtual IChangeSet`2<TObject, TKey> Refresh(IEnumerable`1<KeyValuePair`2<TKey, TObject>> items);
    public abstract virtual IChangeSet`2<TObject, TKey> Update(IChangeSet`2<TObject, TKey> updates);
}
[NullableContextAttribute("2")]
internal interface DynamicData.Cache.Internal.IKeySelector`2 {
    [NullableContextAttribute("1")]
public abstract virtual TKey GetKey(TObject item);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class DynamicData.Cache.Internal.ImmutableGroup`3 : object {
    private Cache`2<TObject, TKey> _cache;
    [CompilerGeneratedAttribute]
private TGroupKey <Key>k__BackingField;
    public int Count { get; }
    public IEnumerable`1<TObject> Items { get; }
    public TGroupKey Key { get; }
    public IEnumerable`1<TKey> Keys { get; }
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public IEnumerable`1<KeyValuePair`2<TKey, TObject>> KeyValues { get; }
    internal ImmutableGroup`3(TGroupKey key, ICache`2<TObject, TKey> cache);
    public sealed virtual int get_Count();
    public sealed virtual IEnumerable`1<TObject> get_Items();
    [CompilerGeneratedAttribute]
public sealed virtual TGroupKey get_Key();
    public sealed virtual IEnumerable`1<TKey> get_Keys();
    public sealed virtual IEnumerable`1<KeyValuePair`2<TKey, TObject>> get_KeyValues();
    public static bool op_Equality(ImmutableGroup`3<TObject, TKey, TGroupKey> left, ImmutableGroup`3<TObject, TKey, TGroupKey> right);
    public static bool op_Inequality(ImmutableGroup`3<TObject, TKey, TGroupKey> left, ImmutableGroup`3<TObject, TKey, TGroupKey> right);
    public sealed virtual bool Equals(ImmutableGroup`3<TObject, TKey, TGroupKey> other);
    [NullableContextAttribute("2")]
public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public sealed virtual Optional`1<TObject> Lookup(TKey key);
    public virtual string ToString();
    [NullableContextAttribute("0")]
[CompilerGeneratedAttribute]
private void <.ctor>b__1_0(KeyValuePair`2<TKey, TObject> kvp);
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal class DynamicData.Cache.Internal.ImmutableGroupChangeSet`3 : ChangeSet`2<IGrouping`3<TObject, TKey, TGroupKey>, TGroupKey> {
    public static IImmutableGroupChangeSet`3<TObject, TKey, TGroupKey> Empty;
    public ImmutableGroupChangeSet`3(IEnumerable`1<Change`2<IGrouping`3<TObject, TKey, TGroupKey>, TGroupKey>> items);
    private static ImmutableGroupChangeSet`3();
    private sealed virtual override int DynamicData.IChangeSet.get_Capacity();
    private sealed virtual override void DynamicData.IChangeSet.set_Capacity(int value);
}
internal static class DynamicData.Cache.Internal.IndexAndNode : object {
    [NullableContextAttribute("1")]
public static IndexAndNode`1<TNodeValue> Create(int index, LinkedListNode`1<TNodeValue> value);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class DynamicData.Cache.Internal.IndexAndNode`1 : object {
    [CompilerGeneratedAttribute]
private int <Index>k__BackingField;
    [CompilerGeneratedAttribute]
private LinkedListNode`1<TNodeValue> <Node>k__BackingField;
    public int Index { get; }
    public LinkedListNode`1<TNodeValue> Node { get; }
    public IndexAndNode`1(int index, LinkedListNode`1<TNodeValue> node);
    [CompilerGeneratedAttribute]
public int get_Index();
    [CompilerGeneratedAttribute]
public LinkedListNode`1<TNodeValue> get_Node();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class DynamicData.Cache.Internal.IndexCalculator`2 : object {
    [CompilerGeneratedAttribute]
private SortOptimisations <optimisations>P;
    private KeyValueComparer`2<TObject, TKey> _comparer;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private List`1<KeyValuePair`2<TKey, TObject>> <List>k__BackingField;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public IComparer`1<KeyValuePair`2<TKey, TObject>> Comparer { get; }
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public List`1<KeyValuePair`2<TKey, TObject>> List { get; private set; }
    public IndexCalculator`2(KeyValueComparer`2<TObject, TKey> comparer, SortOptimisations optimisations);
    public IComparer`1<KeyValuePair`2<TKey, TObject>> get_Comparer();
    [CompilerGeneratedAttribute]
public List`1<KeyValuePair`2<TKey, TObject>> get_List();
    [CompilerGeneratedAttribute]
private void set_List(List`1<KeyValuePair`2<TKey, TObject>> value);
    public IChangeSet`2<TObject, TKey> Calculate(IChangeSet`2<TObject, TKey> changes);
    public IChangeSet`2<TObject, TKey> ChangeComparer(KeyValueComparer`2<TObject, TKey> comparer);
    public IChangeSet`2<TObject, TKey> Load(ChangeAwareCache`2<TObject, TKey> cache);
    public IChangeSet`2<TObject, TKey> Reorder();
    public void Reset(ChangeAwareCache`2<TObject, TKey> cache);
    private int GetCurrentPosition(KeyValuePair`2<TKey, TObject> item);
    private int GetInsertPositionBinary(KeyValuePair`2<TKey, TObject> item);
    private int GetInsertPositionLinear(IList`1<KeyValuePair`2<TKey, TObject>> list, KeyValuePair`2<TKey, TObject> item);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class DynamicData.Cache.Internal.InnerJoin`5 : object {
    private IObservable`1<IChangeSet`2<TLeft, TLeftKey>> _left;
    [TupleElementNamesAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private Func`4<ValueTuple`2<TLeftKey, TRightKey>, TLeft, TRight, TDestination> _resultSelector;
    private IObservable`1<IChangeSet`2<TRight, TRightKey>> _right;
    private Func`2<TRight, TLeftKey> _rightKeySelector;
    public InnerJoin`5(IObservable`1<IChangeSet`2<TLeft, TLeftKey>> left, IObservable`1<IChangeSet`2<TRight, TRightKey>> right, Func`2<TRight, TLeftKey> rightKeySelector, Func`4<ValueTuple`2<TLeftKey, TRightKey>, TLeft, TRight, TDestination> resultSelector);
    public IObservable`1<IChangeSet`2<TDestination, ValueTuple`2<TLeftKey, TRightKey>>> Run();
    [CompilerGeneratedAttribute]
private IDisposable <Run>b__5_0(IObserver`1<IChangeSet`2<TDestination, ValueTuple`2<TLeftKey, TRightKey>>> observer);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class DynamicData.Cache.Internal.InnerJoinMany`5 : object {
    private IObservable`1<IChangeSet`2<TLeft, TLeftKey>> _left;
    private Func`4<TLeftKey, TLeft, IGrouping`3<TRight, TRightKey, TLeftKey>, TDestination> _resultSelector;
    private IObservable`1<IChangeSet`2<TRight, TRightKey>> _right;
    private Func`2<TRight, TLeftKey> _rightKeySelector;
    public InnerJoinMany`5(IObservable`1<IChangeSet`2<TLeft, TLeftKey>> left, IObservable`1<IChangeSet`2<TRight, TRightKey>> right, Func`2<TRight, TLeftKey> rightKeySelector, Func`4<TLeftKey, TLeft, IGrouping`3<TRight, TRightKey, TLeftKey>, TDestination> resultSelector);
    public IObservable`1<IChangeSet`2<TDestination, TLeftKey>> Run();
    [CompilerGeneratedAttribute]
private TDestination <Run>b__5_1(ValueTuple`2<TLeftKey, TLeftKey> key, TLeft left, IGrouping`3<TRight, TRightKey, TLeftKey> right);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
internal class DynamicData.Cache.Internal.KeyComparer`2 : object {
    public sealed virtual bool Equals(KeyValuePair`2<TKey, TObject> x, KeyValuePair`2<TKey, TObject> y);
    public sealed virtual int GetHashCode(KeyValuePair`2<TKey, TObject> obj);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class DynamicData.Cache.Internal.KeySelector`2 : object {
    private Func`2<TObject, TKey> _keySelector;
    public Type Type { get; }
    public KeySelector`2(Func`2<TObject, TKey> keySelector);
    public Type get_Type();
    public sealed virtual TKey GetKey(TObject item);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class DynamicData.Cache.Internal.KeySelectorException : Exception {
    public KeySelectorException(string message);
    public KeySelectorException(string message, Exception innerException);
}
[DefaultMemberAttribute("Item")]
internal class DynamicData.Cache.Internal.KeyValueCollection`2 : object {
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private IReadOnlyCollection`1<KeyValuePair`2<TKey, TObject>> _items;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private IComparer`1<KeyValuePair`2<TKey, TObject>> <Comparer>k__BackingField;
    [CompilerGeneratedAttribute]
private SortOptimisations <Optimisations>k__BackingField;
    [CompilerGeneratedAttribute]
private SortReason <SortReason>k__BackingField;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public IComparer`1<KeyValuePair`2<TKey, TObject>> Comparer { get; }
    public int Count { get; }
    public SortOptimisations Optimisations { get; }
    public SortReason SortReason { get; }
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public KeyValuePair`2<TKey, TObject> Item { get; }
    public KeyValueCollection`2(IReadOnlyCollection`1<KeyValuePair`2<TKey, TObject>> items, IComparer`1<KeyValuePair`2<TKey, TObject>> comparer, SortReason sortReason, SortOptimisations optimisations);
    [CompilerGeneratedAttribute]
public sealed virtual IComparer`1<KeyValuePair`2<TKey, TObject>> get_Comparer();
    public sealed virtual int get_Count();
    [CompilerGeneratedAttribute]
public sealed virtual SortOptimisations get_Optimisations();
    [CompilerGeneratedAttribute]
public sealed virtual SortReason get_SortReason();
    public sealed virtual KeyValuePair`2<TKey, TObject> get_Item(int index);
    public sealed virtual IEnumerator`1<KeyValuePair`2<TKey, TObject>> GetEnumerator();
    [NullableContextAttribute("1")]
private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
internal class DynamicData.Cache.Internal.KeyValueComparer`2 : object {
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private IComparer`1<TObject> <comparer>P;
    public KeyValueComparer`2(IComparer`1<TObject> comparer);
    public sealed virtual int Compare(KeyValuePair`2<TKey, TObject> x, KeyValuePair`2<TKey, TObject> y);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class DynamicData.Cache.Internal.LeftJoin`5 : object {
    private IObservable`1<IChangeSet`2<TLeft, TLeftKey>> _left;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private Func`4<TLeftKey, TLeft, Optional`1<TRight>, TDestination> _resultSelector;
    private IObservable`1<IChangeSet`2<TRight, TRightKey>> _right;
    private Func`2<TRight, TLeftKey> _rightKeySelector;
    public LeftJoin`5(IObservable`1<IChangeSet`2<TLeft, TLeftKey>> left, IObservable`1<IChangeSet`2<TRight, TRightKey>> right, Func`2<TRight, TLeftKey> rightKeySelector, Func`4<TLeftKey, TLeft, Optional`1<TRight>, TDestination> resultSelector);
    public IObservable`1<IChangeSet`2<TDestination, TLeftKey>> Run();
    [CompilerGeneratedAttribute]
private IDisposable <Run>b__5_0(IObserver`1<IChangeSet`2<TDestination, TLeftKey>> observer);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class DynamicData.Cache.Internal.LeftJoinMany`5 : object {
    private IObservable`1<IChangeSet`2<TLeft, TLeftKey>> _left;
    private Func`4<TLeftKey, TLeft, IGrouping`3<TRight, TRightKey, TLeftKey>, TDestination> _resultSelector;
    private IObservable`1<IChangeSet`2<TRight, TRightKey>> _right;
    private Func`2<TRight, TLeftKey> _rightKeySelector;
    public LeftJoinMany`5(IObservable`1<IChangeSet`2<TLeft, TLeftKey>> left, IObservable`1<IChangeSet`2<TRight, TRightKey>> right, Func`2<TRight, TLeftKey> rightKeySelector, Func`4<TLeftKey, TLeft, IGrouping`3<TRight, TRightKey, TLeftKey>, TDestination> resultSelector);
    public IObservable`1<IChangeSet`2<TDestination, TLeftKey>> Run();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[DebuggerDisplayAttribute("LockFreeObservableCache<{typeof(TObject).Name}, {typeof(TKey).Name}> ({Count} Items)")]
public class DynamicData.Cache.Internal.LockFreeObservableCache`2 : object {
    private Subject`1<IChangeSet`2<TObject, TKey>> _changes;
    private Subject`1<IChangeSet`2<TObject, TKey>> _changesPreview;
    private Subject`1<int> _countChanged;
    private IDisposable _cleanUp;
    private ChangeAwareCache`2<TObject, TKey> _innerCache;
    private ICacheUpdater`2<TObject, TKey> _updater;
    public int Count { get; }
    public IObservable`1<int> CountChanged { get; }
    public IReadOnlyList`1<TObject> Items { get; }
    public IReadOnlyList`1<TKey> Keys { get; }
    public IReadOnlyDictionary`2<TKey, TObject> KeyValues { get; }
    public LockFreeObservableCache`2(IObservable`1<IChangeSet`2<TObject, TKey>> source);
    public sealed virtual int get_Count();
    public sealed virtual IObservable`1<int> get_CountChanged();
    public sealed virtual IReadOnlyList`1<TObject> get_Items();
    public sealed virtual IReadOnlyList`1<TKey> get_Keys();
    public sealed virtual IReadOnlyDictionary`2<TKey, TObject> get_KeyValues();
    public sealed virtual IObservable`1<IChangeSet`2<TObject, TKey>> Connect(Func`2<TObject, bool> predicate, bool suppressEmptyChangeSets);
    public sealed virtual void Dispose();
    public void Edit(Action`1<ICacheUpdater`2<TObject, TKey>> editAction);
    public sealed virtual Optional`1<TObject> Lookup(TKey key);
    public sealed virtual IObservable`1<IChangeSet`2<TObject, TKey>> Preview(Func`2<TObject, bool> predicate);
    public sealed virtual IObservable`1<Change`2<TObject, TKey>> Watch(TKey key);
    [NullableContextAttribute("0")]
[CompilerGeneratedAttribute]
private ChangeSet`2<TObject, TKey> <.ctor>b__6_0(IChangeSet`2<TObject, TKey> changes);
    [CompilerGeneratedAttribute]
private void <.ctor>b__7_0();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class DynamicData.Cache.Internal.ManagedGroup`3 : object {
    private IntermediateCache`2<TObject, TKey> _cache;
    [CompilerGeneratedAttribute]
private TGroupKey <Key>k__BackingField;
    public IObservableCache`2<TObject, TKey> Cache { get; }
    public TGroupKey Key { get; }
    internal int Count { get; }
    public ManagedGroup`3(TGroupKey groupKey);
    public sealed virtual IObservableCache`2<TObject, TKey> get_Cache();
    [CompilerGeneratedAttribute]
public sealed virtual TGroupKey get_Key();
    internal int get_Count();
    public sealed virtual void Dispose();
    public IDisposable SuspendNotifications();
    [NullableContextAttribute("2")]
public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public virtual string ToString();
    internal IChangeSet`2<TObject, TKey> GetInitialUpdates();
    internal void Update(Action`1<ICacheUpdater`2<TObject, TKey>> updateAction);
    private bool Equals(ManagedGroup`3<TObject, TKey, TGroupKey> other);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class DynamicData.Cache.Internal.MergeChangeSets`2 : object {
    [CompilerGeneratedAttribute]
private IObservable`1<IObservable`1<IChangeSet`2<TObject, TKey>>> <source>P;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private IEqualityComparer`1<TObject> <equalityComparer>P;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private IComparer`1<TObject> <comparer>P;
    public MergeChangeSets`2(IObservable`1<IObservable`1<IChangeSet`2<TObject, TKey>>> source, IEqualityComparer`1<TObject> equalityComparer, IComparer`1<TObject> comparer);
    public MergeChangeSets`2(IEnumerable`1<IObservable`1<IChangeSet`2<TObject, TKey>>> source, IEqualityComparer`1<TObject> equalityComparer, IComparer`1<TObject> comparer, bool completable, IScheduler scheduler);
    public IObservable`1<IChangeSet`2<TObject, TKey>> Run();
    private static Change`2<ChangeSetCache`2<TObject, TKey>, int> CreateChange(IObservable`1<IChangeSet`2<TObject, TKey>> source, int index, object locker);
    private static IObservable`1<IChangeSet`2<ChangeSetCache`2<TObject, TKey>, int>> CreateContainerObservable(IObservable`1<IObservable`1<IChangeSet`2<TObject, TKey>>> source, object locker);
    private static IObservable`1<IObservable`1<IChangeSet`2<TObject, TKey>>> CreateObservable(IEnumerable`1<IObservable`1<IChangeSet`2<TObject, TKey>>> source, bool completable, IScheduler scheduler);
    [CompilerGeneratedAttribute]
private IDisposable <Run>b__5_0(IObserver`1<IChangeSet`2<TObject, TKey>> observer);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class DynamicData.Cache.Internal.MergeMany`3 : object {
    private Func`3<TObject, TKey, IObservable`1<TDestination>> _observableSelector;
    private IObservable`1<IChangeSet`2<TObject, TKey>> _source;
    public MergeMany`3(IObservable`1<IChangeSet`2<TObject, TKey>> source, Func`3<TObject, TKey, IObservable`1<TDestination>> observableSelector);
    public MergeMany`3(IObservable`1<IChangeSet`2<TObject, TKey>> source, Func`2<TObject, IObservable`1<TDestination>> observableSelector);
    public IObservable`1<TDestination> Run();
    [CompilerGeneratedAttribute]
private IDisposable <Run>b__4_0(IObserver`1<TDestination> observer);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class DynamicData.Cache.Internal.MergeManyCacheChangeSets`4 : object {
    [CompilerGeneratedAttribute]
private IObservable`1<IChangeSet`2<TObject, TKey>> <source>P;
    [CompilerGeneratedAttribute]
private Func`3<TObject, TKey, IObservable`1<IChangeSet`2<TDestination, TDestinationKey>>> <selector>P;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private IEqualityComparer`1<TDestination> <equalityComparer>P;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private IComparer`1<TDestination> <comparer>P;
    public MergeManyCacheChangeSets`4(IObservable`1<IChangeSet`2<TObject, TKey>> source, Func`3<TObject, TKey, IObservable`1<IChangeSet`2<TDestination, TDestinationKey>>> selector, IEqualityComparer`1<TDestination> equalityComparer, IComparer`1<TDestination> comparer);
    public IObservable`1<IChangeSet`2<TDestination, TDestinationKey>> Run();
    [CompilerGeneratedAttribute]
private IDisposable <Run>b__5_0(IObserver`1<IChangeSet`2<TDestination, TDestinationKey>> observer);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class DynamicData.Cache.Internal.MergeManyCacheChangeSetsSourceCompare`4 : object {
    [CompilerGeneratedAttribute]
private IObservable`1<IChangeSet`2<TObject, TKey>> <source>P;
    [CompilerGeneratedAttribute]
private bool <reevalOnRefresh>P;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private Func`3<TObject, TKey, IObservable`1<IChangeSet`2<ParentChildEntry<TObject, TKey, TDestination, TDestinationKey>, TDestinationKey>>> _changeSetSelector;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private IComparer`1<ParentChildEntry<TObject, TKey, TDestination, TDestinationKey>> _comparer;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private IEqualityComparer`1<ParentChildEntry<TObject, TKey, TDestination, TDestinationKey>> _equalityComparer;
    public MergeManyCacheChangeSetsSourceCompare`4(IObservable`1<IChangeSet`2<TObject, TKey>> source, Func`3<TObject, TKey, IObservable`1<IChangeSet`2<TDestination, TDestinationKey>>> selector, IComparer`1<TObject> parentCompare, IEqualityComparer`1<TDestination> equalityComparer, IComparer`1<TDestination> childCompare, bool reevalOnRefresh);
    public IObservable`1<IChangeSet`2<TDestination, TDestinationKey>> Run();
    [CompilerGeneratedAttribute]
private IDisposable <Run>b__6_0(IObserver`1<IChangeSet`2<ParentChildEntry<TObject, TKey, TDestination, TDestinationKey>, TDestinationKey>> observer);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class DynamicData.Cache.Internal.MergeManyItems`3 : object {
    private Func`3<TObject, TKey, IObservable`1<TDestination>> _observableSelector;
    private IObservable`1<IChangeSet`2<TObject, TKey>> _source;
    public MergeManyItems`3(IObservable`1<IChangeSet`2<TObject, TKey>> source, Func`3<TObject, TKey, IObservable`1<TDestination>> observableSelector);
    public MergeManyItems`3(IObservable`1<IChangeSet`2<TObject, TKey>> source, Func`2<TObject, IObservable`1<TDestination>> observableSelector);
    public IObservable`1<ItemWithValue`2<TObject, TDestination>> Run();
    [CompilerGeneratedAttribute]
private IDisposable <Run>b__4_0(IObserver`1<ItemWithValue`2<TObject, TDestination>> observer);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class DynamicData.Cache.Internal.MergeManyListChangeSets`3 : object {
    [CompilerGeneratedAttribute]
private IObservable`1<IChangeSet`2<TObject, TKey>> <source>P;
    [CompilerGeneratedAttribute]
private Func`3<TObject, TKey, IObservable`1<IChangeSet`1<TDestination>>> <selector>P;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private IEqualityComparer`1<TDestination> <equalityComparer>P;
    public MergeManyListChangeSets`3(IObservable`1<IChangeSet`2<TObject, TKey>> source, Func`3<TObject, TKey, IObservable`1<IChangeSet`1<TDestination>>> selector, IEqualityComparer`1<TDestination> equalityComparer);
    public IObservable`1<IChangeSet`1<TDestination>> Run();
    [CompilerGeneratedAttribute]
private IDisposable <Run>b__4_0(IObserver`1<IChangeSet`1<TDestination>> observer);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class DynamicData.Cache.Internal.ObservableWithValue`2 : object {
    [CompilerGeneratedAttribute]
private TObject <Item>k__BackingField;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private Optional`1<TValue> <LatestValue>k__BackingField;
    [CompilerGeneratedAttribute]
private IObservable`1<TValue> <Observable>k__BackingField;
    public TObject Item { get; }
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public Optional`1<TValue> LatestValue { get; private set; }
    public IObservable`1<TValue> Observable { get; }
    public ObservableWithValue`2(TObject item, IObservable`1<TValue> source);
    [CompilerGeneratedAttribute]
public TObject get_Item();
    [CompilerGeneratedAttribute]
public Optional`1<TValue> get_LatestValue();
    [CompilerGeneratedAttribute]
private void set_LatestValue(Optional`1<TValue> value);
    [CompilerGeneratedAttribute]
public IObservable`1<TValue> get_Observable();
    [NullableContextAttribute("0")]
[CompilerGeneratedAttribute]
private void <.ctor>b__0_0(TValue value);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class DynamicData.Cache.Internal.OfType`3 : object {
    [CompilerGeneratedAttribute]
private IObservable`1<IChangeSet`2<TObject, TKey>> <source>P;
    [CompilerGeneratedAttribute]
private bool <suppressEmptyChangeSets>P;
    public OfType`3(IObservable`1<IChangeSet`2<TObject, TKey>> source, bool suppressEmptyChangeSets);
    public IObservable`1<IChangeSet`2<TDestination, TKey>> Run();
    [CompilerGeneratedAttribute]
private IDisposable <Run>b__3_0(IObserver`1<IChangeSet`2<TDestination, TKey>> observer);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class DynamicData.Cache.Internal.OnBeingRemoved`2 : object {
    private Action`2<TObject, TKey> _removeAction;
    private IObservable`1<IChangeSet`2<TObject, TKey>> _source;
    public OnBeingRemoved`2(IObservable`1<IChangeSet`2<TObject, TKey>> source, Action`2<TObject, TKey> removeAction);
    public IObservable`1<IChangeSet`2<TObject, TKey>> Run();
    private void RegisterForRemoval(IChangeSet`2<TObject, TKey> changes, Cache`2<TObject, TKey> cache);
    [CompilerGeneratedAttribute]
private IDisposable <Run>b__3_0(IObserver`1<IChangeSet`2<TObject, TKey>> observer);
    [NullableContextAttribute("0")]
[CompilerGeneratedAttribute]
private void <Run>b__3_3(KeyValuePair`2<TKey, TObject> kvp);
    [NullableContextAttribute("0")]
[CompilerGeneratedAttribute]
private void <RegisterForRemoval>b__4_0(Change`2<TObject, TKey> change);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class DynamicData.Cache.Internal.Page`2 : object {
    [CompilerGeneratedAttribute]
private IObservable`1<ISortedChangeSet`2<TObject, TKey>> <source>P;
    [CompilerGeneratedAttribute]
private IObservable`1<IPageRequest> <pageRequests>P;
    public Page`2(IObservable`1<ISortedChangeSet`2<TObject, TKey>> source, IObservable`1<IPageRequest> pageRequests);
    public IObservable`1<IPagedChangeSet`2<TObject, TKey>> Run();
    [CompilerGeneratedAttribute]
private IDisposable <Run>b__3_0(IObserver`1<IPagedChangeSet`2<TObject, TKey>> observer);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class DynamicData.Cache.Internal.QueryWhenChanged`3 : object {
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private Func`2<TObject, IObservable`1<TValue>> <itemChangedTrigger>P;
    private IObservable`1<IChangeSet`2<TObject, TKey>> _source;
    public QueryWhenChanged`3(IObservable`1<IChangeSet`2<TObject, TKey>> source, Func`2<TObject, IObservable`1<TValue>> itemChangedTrigger);
    public IObservable`1<IQuery`2<TObject, TKey>> Run();
    [CompilerGeneratedAttribute]
private IObservable`1<Cache`2<TObject, TKey>> <Run>b__3_0();
    [CompilerGeneratedAttribute]
private IObservable`1<AnonymousQuery`2<TObject, TKey>> <Run>b__3_2(IObservable`1<IChangeSet`2<TObject, TKey>> shared);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class DynamicData.Cache.Internal.ReaderWriter`2 : object {
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private Func`2<TObject, TKey> <keySelector>P;
    private object _locker;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private CacheUpdater`2<TObject, TKey> _activeUpdater;
    private Dictionary`2<TKey, TObject> _data;
    public int Count { get; }
    public TObject[] Items { get; }
    public TKey[] Keys { get; }
    public IReadOnlyDictionary`2<TKey, TObject> KeyValues { get; }
    public ReaderWriter`2(Func`2<TObject, TKey> keySelector);
    public int get_Count();
    public TObject[] get_Items();
    public TKey[] get_Keys();
    public IReadOnlyDictionary`2<TKey, TObject> get_KeyValues();
    public ChangeSet`2<TObject, TKey> GetInitialUpdates(Func`2<TObject, bool> filter);
    public Optional`1<TObject> Lookup(TKey key);
    public ChangeSet`2<TObject, TKey> Write(IChangeSet`2<TObject, TKey> changes, Action`1<ChangeSet`2<TObject, TKey>> previewHandler, bool collectChanges);
    public ChangeSet`2<TObject, TKey> Write(Action`1<ICacheUpdater`2<TObject, TKey>> updateAction, Action`1<ChangeSet`2<TObject, TKey>> previewHandler, bool collectChanges);
    public ChangeSet`2<TObject, TKey> Write(Action`1<ISourceUpdater`2<TObject, TKey>> updateAction, Action`1<ChangeSet`2<TObject, TKey>> previewHandler, bool collectChanges);
    public void WriteNested(Action`1<ISourceUpdater`2<TObject, TKey>> updateAction);
    private ChangeSet`2<TObject, TKey> DoUpdate(Action`1<CacheUpdater`2<TObject, TKey>> updateAction, Action`1<ChangeSet`2<TObject, TKey>> previewHandler, bool collectChanges);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class DynamicData.Cache.Internal.RefCount`2 : object {
    private object _locker;
    private IObservable`1<IChangeSet`2<TObject, TKey>> _source;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private IObservableCache`2<TObject, TKey> _cache;
    private int _refCount;
    public RefCount`2(IObservable`1<IChangeSet`2<TObject, TKey>> source);
    public IObservable`1<IChangeSet`2<TObject, TKey>> Run();
    [CompilerGeneratedAttribute]
private IDisposable <Run>b__5_0(IObserver`1<IChangeSet`2<TObject, TKey>> observer);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class DynamicData.Cache.Internal.RemoveKeyEnumerator`2 : object {
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private IExtendedList`1<TObject> <list>P;
    private IChangeSet`2<TObject, TKey> _source;
    public RemoveKeyEnumerator`2(IChangeSet`2<TObject, TKey> source, IExtendedList`1<TObject> list);
    [IteratorStateMachineAttribute("DynamicData.Cache.Internal.RemoveKeyEnumerator`2/<GetEnumerator>d__3")]
public sealed virtual IEnumerator`1<Change`1<TObject>> GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class DynamicData.Cache.Internal.RightJoin`5 : object {
    private IObservable`1<IChangeSet`2<TLeft, TLeftKey>> _left;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private Func`4<TRightKey, Optional`1<TLeft>, TRight, TDestination> _resultSelector;
    private IObservable`1<IChangeSet`2<TRight, TRightKey>> _right;
    private Func`2<TRight, TLeftKey> _rightKeySelector;
    public RightJoin`5(IObservable`1<IChangeSet`2<TLeft, TLeftKey>> left, IObservable`1<IChangeSet`2<TRight, TRightKey>> right, Func`2<TRight, TLeftKey> rightKeySelector, Func`4<TRightKey, Optional`1<TLeft>, TRight, TDestination> resultSelector);
    public IObservable`1<IChangeSet`2<TDestination, TRightKey>> Run();
    [CompilerGeneratedAttribute]
private IDisposable <Run>b__5_0(IObserver`1<IChangeSet`2<TDestination, TRightKey>> observer);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class DynamicData.Cache.Internal.RightJoinMany`5 : object {
    private IObservable`1<IChangeSet`2<TLeft, TLeftKey>> _left;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private Func`4<TLeftKey, Optional`1<TLeft>, IGrouping`3<TRight, TRightKey, TLeftKey>, TDestination> _resultSelector;
    private IObservable`1<IChangeSet`2<TRight, TRightKey>> _right;
    private Func`2<TRight, TLeftKey> _rightKeySelector;
    public RightJoinMany`5(IObservable`1<IChangeSet`2<TLeft, TLeftKey>> left, IObservable`1<IChangeSet`2<TRight, TRightKey>> right, Func`2<TRight, TLeftKey> rightKeySelector, Func`4<TLeftKey, Optional`1<TLeft>, IGrouping`3<TRight, TRightKey, TLeftKey>, TDestination> resultSelector);
    public IObservable`1<IChangeSet`2<TDestination, TLeftKey>> Run();
    [CompilerGeneratedAttribute]
private TDestination <Run>b__5_1(TLeftKey a, Optional`1<TLeft> b, IGrouping`3<TRight, TRightKey, TLeftKey> c);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class DynamicData.Cache.Internal.SizeExpirer`2 : object {
    private int _size;
    private IObservable`1<IChangeSet`2<TObject, TKey>> _source;
    public SizeExpirer`2(IObservable`1<IChangeSet`2<TObject, TKey>> source, int size);
    public IObservable`1<IChangeSet`2<TObject, TKey>> Run();
    [CompilerGeneratedAttribute]
private IDisposable <Run>b__3_0(IObserver`1<IChangeSet`2<TObject, TKey>> observer);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class DynamicData.Cache.Internal.SizeLimiter`2 : object {
    [CompilerGeneratedAttribute]
private int <size>P;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private ChangeAwareCache`2<ExpirableItem`2<TObject, TKey>, TKey> _cache;
    public SizeLimiter`2(int size);
    public IChangeSet`2<TObject, TKey> Change(IChangeSet`2<ExpirableItem`2<TObject, TKey>, TKey> updates);
    public KeyValuePair`2[] CloneAndReturnExpiredOnly(IChangeSet`2<ExpirableItem`2<TObject, TKey>, TKey> updates);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class DynamicData.Cache.Internal.Sort`2 : object {
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private IComparer`1<TObject> _comparer;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private IObservable`1<IComparer`1<TObject>> _comparerChangedObservable;
    private int _resetThreshold;
    [NullableAttribute("2")]
private IObservable`1<Unit> _resorter;
    private SortOptimisations _sortOptimisations;
    private IObservable`1<IChangeSet`2<TObject, TKey>> _source;
    public Sort`2(IObservable`1<IChangeSet`2<TObject, TKey>> source, IComparer`1<TObject> comparer, SortOptimisations sortOptimisations, IObservable`1<IComparer`1<TObject>> comparerChangedObservable, IObservable`1<Unit> resorter, int resetThreshold);
    public IObservable`1<ISortedChangeSet`2<TObject, TKey>> Run();
    [CompilerGeneratedAttribute]
private IDisposable <Run>b__7_0(IObserver`1<ISortedChangeSet`2<TObject, TKey>> observer);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class DynamicData.Cache.Internal.SortAndPage`2 : object {
    private static KeyComparer`2<TObject, TKey> _keyComparer;
    private IObservable`1<IChangeSet`2<TObject, TKey>> _source;
    private IObservable`1<IComparer`1<TObject>> _comparerChanged;
    private IObservable`1<IPageRequest> _pageRequests;
    private SortAndPageOptions _options;
    private static ChangeSet`3<TObject, TKey, PageContext`1<TObject>> Empty;
    public SortAndPage`2(IObservable`1<IChangeSet`2<TObject, TKey>> source, IComparer`1<TObject> comparer, IObservable`1<IPageRequest> virtualRequests, SortAndPageOptions options);
    public SortAndPage`2(IObservable`1<IChangeSet`2<TObject, TKey>> source, IObservable`1<IComparer`1<TObject>> comparerChanged, IObservable`1<IPageRequest> virtualRequests, SortAndPageOptions options);
    private static SortAndPage`2();
    public IObservable`1<IChangeSet`3<TObject, TKey, PageContext`1<TObject>>> Run();
    private static ChangeSet`3<TObject, TKey, PageContext`1<TObject>> CalculatePageChanges(PageContext`1<TObject> context, List`1<KeyValuePair`2<TKey, TObject>> currentItems, List`1<KeyValuePair`2<TKey, TObject>> previousItems, IChangeSet`2<TObject, TKey> changes);
    [CompilerGeneratedAttribute]
private IDisposable <Run>b__8_0(IObserver`1<IChangeSet`3<TObject, TKey, PageContext`1<TObject>>> observer);
    [CompilerGeneratedAttribute]
internal static int <Run>g__CalculatePages|8_7(IPageRequest request, int totalCount);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class DynamicData.Cache.Internal.SortAndVirtualize`2 : object {
    private static KeyComparer`2<TObject, TKey> _keyComparer;
    private IObservable`1<IChangeSet`2<TObject, TKey>> _source;
    private IObservable`1<IComparer`1<TObject>> _comparerChanged;
    private IObservable`1<IVirtualRequest> _virtualRequests;
    private SortAndVirtualizeOptions _options;
    private static ChangeSet`3<TObject, TKey, VirtualContext`1<TObject>> Empty;
    public SortAndVirtualize`2(IObservable`1<IChangeSet`2<TObject, TKey>> source, IComparer`1<TObject> comparer, IObservable`1<IVirtualRequest> virtualRequests, SortAndVirtualizeOptions options);
    public SortAndVirtualize`2(IObservable`1<IChangeSet`2<TObject, TKey>> source, IObservable`1<IComparer`1<TObject>> comparerChanged, IObservable`1<IVirtualRequest> virtualRequests, SortAndVirtualizeOptions options);
    private static SortAndVirtualize`2();
    public IObservable`1<IChangeSet`3<TObject, TKey, VirtualContext`1<TObject>>> Run();
    private static ChangeSet`3<TObject, TKey, VirtualContext`1<TObject>> CalculateVirtualChanges(VirtualContext`1<TObject> context, List`1<KeyValuePair`2<TKey, TObject>> currentItems, List`1<KeyValuePair`2<TKey, TObject>> previousItems, IChangeSet`2<TObject, TKey> changes);
    [CompilerGeneratedAttribute]
private IDisposable <Run>b__8_0(IObserver`1<IChangeSet`3<TObject, TKey, VirtualContext`1<TObject>>> observer);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class DynamicData.Cache.Internal.SortedKeyValueApplicator`2 : object {
    private Cache`2<TObject, TKey> _cache;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private List`1<KeyValuePair`2<TKey, TObject>> _target;
    private SortAndBindOptions _options;
    private KeyValueComparer`2<TObject, TKey> _comparer;
    public SortedKeyValueApplicator`2(List`1<KeyValuePair`2<TKey, TObject>> target, KeyValueComparer`2<TObject, TKey> comparer, SortAndBindOptions options);
    public void ChangeComparer(KeyValueComparer`2<TObject, TKey> comparer);
    public void ProcessChanges(IChangeSet`2<TObject, TKey> changes);
    public void Reset();
    private void ApplyChanges(IChangeSet`2<TObject, TKey> changes);
    private int GetCurrentPosition(KeyValuePair`2<TKey, TObject> item);
    private int GetInsertPosition(KeyValuePair`2<TKey, TObject> item);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
internal static class DynamicData.Cache.Internal.SortExtensions : object {
    [ExtensionAttribute]
public static int GetCurrentPosition(IList`1<TItem> source, TItem item, IComparer`1<TItem> comparer, bool useBinarySearch);
    [ExtensionAttribute]
public static int GetInsertPosition(IList`1<T> source, T item, IComparer`1<T> comparer, bool useBinarySearch);
    [ExtensionAttribute]
public static int GetInsertPositionBinary(IList`1<TItem> list, TItem t, IComparer`1<TItem> c);
    [ExtensionAttribute]
public static int GetInsertPositionLinear(IList`1<TItem> list, TItem t, IComparer`1<TItem> c);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class DynamicData.Cache.Internal.SpecifiedGrouper`3 : object {
    private Func`2<TObject, TGroupKey> _groupSelector;
    private IObservable`1<IDistinctChangeSet`1<TGroupKey>> _resultGroupSource;
    private IObservable`1<IChangeSet`2<TObject, TKey>> _source;
    public SpecifiedGrouper`3(IObservable`1<IChangeSet`2<TObject, TKey>> source, Func`2<TObject, TGroupKey> groupSelector, IObservable`1<IDistinctChangeSet`1<TGroupKey>> resultGroupSource);
    public IObservable`1<IGroupChangeSet`3<TObject, TKey, TGroupKey>> Run();
    [CompilerGeneratedAttribute]
private IDisposable <Run>b__4_0(IObserver`1<IGroupChangeSet`3<TObject, TKey, TGroupKey>> observer);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class DynamicData.Cache.Internal.StaticFilter`2 : object {
    [CompilerGeneratedAttribute]
private IObservable`1<IChangeSet`2<TObject, TKey>> <source>P;
    [CompilerGeneratedAttribute]
private Func`2<TObject, bool> <filter>P;
    [CompilerGeneratedAttribute]
private bool <suppressEmptyChangeSets>P;
    public StaticFilter`2(IObservable`1<IChangeSet`2<TObject, TKey>> source, Func`2<TObject, bool> filter, bool suppressEmptyChangeSets);
    public IObservable`1<IChangeSet`2<TObject, TKey>> Run();
    [CompilerGeneratedAttribute]
private IDisposable <Run>b__4_0(IObserver`1<IChangeSet`2<TObject, TKey>> observer);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class DynamicData.Cache.Internal.StatusMonitor`1 : object {
    [CompilerGeneratedAttribute]
private IObservable`1<T> <source>P;
    public StatusMonitor`1(IObservable`1<T> source);
    public IObservable`1<ConnectionStatus> Run();
    [CompilerGeneratedAttribute]
private IDisposable <Run>b__2_0(IObserver`1<ConnectionStatus> observer);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class DynamicData.Cache.Internal.SubscribeMany`2 : object {
    private IObservable`1<IChangeSet`2<TObject, TKey>> _source;
    private Func`3<TObject, TKey, IDisposable> _subscriptionFactory;
    public SubscribeMany`2(IObservable`1<IChangeSet`2<TObject, TKey>> source, Func`2<TObject, IDisposable> subscriptionFactory);
    public SubscribeMany`2(IObservable`1<IChangeSet`2<TObject, TKey>> source, Func`3<TObject, TKey, IDisposable> subscriptionFactory);
    public IObservable`1<IChangeSet`2<TObject, TKey>> Run();
    [CompilerGeneratedAttribute]
private IDisposable <Run>b__4_0(IObserver`1<IChangeSet`2<TObject, TKey>> observer);
    [CompilerGeneratedAttribute]
private IDisposable <Run>b__4_1(TObject t, TKey k);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class DynamicData.Cache.Internal.Switch`2 : object {
    private IObservable`1<IObservable`1<IChangeSet`2<TObject, TKey>>> _sources;
    public Switch`2(IObservable`1<IObservable`1<IChangeSet`2<TObject, TKey>>> sources);
    public IObservable`1<IChangeSet`2<TObject, TKey>> Run();
    [CompilerGeneratedAttribute]
private IDisposable <Run>b__2_0(IObserver`1<IChangeSet`2<TObject, TKey>> observer);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class DynamicData.Cache.Internal.ToObservableChangeSet`2 : object {
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private Func`2<TObject, Nullable`1<TimeSpan>> _expireAfter;
    private Func`2<TObject, TKey> _keySelector;
    private int _limitSizeTo;
    private IScheduler _scheduler;
    private IObservable`1<IEnumerable`1<TObject>> _source;
    public ToObservableChangeSet`2(IObservable`1<TObject> source, Func`2<TObject, TKey> keySelector, Func`2<TObject, Nullable`1<TimeSpan>> expireAfter, int limitSizeTo, IScheduler scheduler);
    public ToObservableChangeSet`2(IObservable`1<IEnumerable`1<TObject>> source, Func`2<TObject, TKey> keySelector, Func`2<TObject, Nullable`1<TimeSpan>> expireAfter, int limitSizeTo, IScheduler scheduler);
    public IObservable`1<IChangeSet`2<TObject, TKey>> Run();
    [CompilerGeneratedAttribute]
private IDisposable <Run>b__7_0(IObserver`1<IChangeSet`2<TObject, TKey>> observer);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class DynamicData.Cache.Internal.ToObservableOptional`2 : object {
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private IEqualityComparer`1<TObject> <equalityComparer>P;
    private IObservable`1<IChangeSet`2<TObject, TKey>> _source;
    private TKey _key;
    public ToObservableOptional`2(IObservable`1<IChangeSet`2<TObject, TKey>> source, TKey key, IEqualityComparer`1<TObject> equalityComparer);
    public IObservable`1<Optional`1<TObject>> Run();
    private bool ShouldEmitChange(Change`2<TObject, TKey> change);
    [CompilerGeneratedAttribute]
private IDisposable <Run>b__4_0(IObserver`1<Optional`1<TObject>> observer);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class DynamicData.Cache.Internal.Transform`3 : object {
    [CompilerGeneratedAttribute]
private IObservable`1<IChangeSet`2<TSource, TKey>> <source>P;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private Func`4<TSource, Optional`1<TSource>, TKey, TDestination> <transformFactory>P;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private Action`1<Error`2<TSource, TKey>> <exceptionCallback>P;
    [CompilerGeneratedAttribute]
private bool <transformOnRefresh>P;
    public Transform`3(IObservable`1<IChangeSet`2<TSource, TKey>> source, Func`4<TSource, Optional`1<TSource>, TKey, TDestination> transformFactory, Action`1<Error`2<TSource, TKey>> exceptionCallback, bool transformOnRefresh);
    public IObservable`1<IChangeSet`2<TDestination, TKey>> Run();
    private IObservable`1<IChangeSet`2<TDestination, TKey>> RunImpl();
    [NullableContextAttribute("0")]
[CompilerGeneratedAttribute]
private ChangeAwareCache`2<TDestination, TKey> <RunImpl>b__6_0(ChangeAwareCache`2<TDestination, TKey> cache, IChangeSet`2<TSource, TKey> changes);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class DynamicData.Cache.Internal.TransformAsync`3 : object {
    [CompilerGeneratedAttribute]
private IObservable`1<IChangeSet`2<TSource, TKey>> <source>P;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private Func`4<TSource, Optional`1<TSource>, TKey, Task`1<TDestination>> <transformFactory>P;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private Action`1<Error`2<TSource, TKey>> <exceptionCallback>P;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private IObservable`1<Func`3<TSource, TKey, bool>> <forceTransform>P;
    [CompilerGeneratedAttribute]
private Nullable`1<int> <maximumConcurrency>P;
    [CompilerGeneratedAttribute]
private bool <transformOnRefresh>P;
    public TransformAsync`3(IObservable`1<IChangeSet`2<TSource, TKey>> source, Func`4<TSource, Optional`1<TSource>, TKey, Task`1<TDestination>> transformFactory, Action`1<Error`2<TSource, TKey>> exceptionCallback, IObservable`1<Func`3<TSource, TKey, bool>> forceTransform, Nullable`1<int> maximumConcurrency, bool transformOnRefresh);
    public IObservable`1<IChangeSet`2<TDestination, TKey>> Run();
    private IObservable`1<IChangeSet`2<TDestination, TKey>> DoTransform(ChangeAwareCache`2<TransformedItemContainer<TDestination, TSource, TKey>, TKey> cache, Func`3<TSource, TKey, bool> shouldTransform);
    private IObservable`1<IChangeSet`2<TDestination, TKey>> DoTransform(ChangeAwareCache`2<TransformedItemContainer<TDestination, TSource, TKey>, TKey> cache, IChangeSet`2<TSource, TKey> changes);
    private ChangeSet`2<TDestination, TKey> ProcessUpdates(ChangeAwareCache`2<TransformedItemContainer<TDestination, TSource, TKey>, TKey> cache, TransformResult[] transformedItems);
    [AsyncStateMachineAttribute("DynamicData.Cache.Internal.TransformAsync`3/<Transform>d__11")]
private Task`1<TransformResult<TDestination, TSource, TKey>> Transform(Change`2<TSource, TKey> change);
    [CompilerGeneratedAttribute]
private IDisposable <Run>b__7_0(IObserver`1<IChangeSet`2<TDestination, TKey>> observer);
    [NullableContextAttribute("0")]
[CompilerGeneratedAttribute]
private void <ProcessUpdates>b__10_1(TransformResult<TDestination, TSource, TKey> t);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class DynamicData.Cache.Internal.TransformImmutable`3 : object {
    private IObservable`1<IChangeSet`2<TSource, TKey>> _source;
    private Func`2<TSource, TDestination> _transformFactory;
    public TransformImmutable`3(IObservable`1<IChangeSet`2<TSource, TKey>> source, Func`2<TSource, TDestination> transformFactory);
    public IObservable`1<IChangeSet`2<TDestination, TKey>> Run();
    [CompilerGeneratedAttribute]
private IDisposable <Run>b__3_0(IObserver`1<IChangeSet`2<TDestination, TKey>> observer);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class DynamicData.Cache.Internal.TransformMany`4 : object {
    [CompilerGeneratedAttribute]
private IObservable`1<IChangeSet`2<TSource, TSourceKey>> <source>P;
    [CompilerGeneratedAttribute]
private Func`2<TSource, IEnumerable`1<TDestination>> <manySelector>P;
    [CompilerGeneratedAttribute]
private Func`2<TDestination, TDestinationKey> <keySelector>P;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private Func`2<TSource, IObservable`1<IChangeSet`2<TDestination, TDestinationKey>>> <childChanges>P;
    public TransformMany`4(IObservable`1<IChangeSet`2<TSource, TSourceKey>> source, Func`2<TSource, IEnumerable`1<TDestination>> manySelector, Func`2<TDestination, TDestinationKey> keySelector, Func`2<TSource, IObservable`1<IChangeSet`2<TDestination, TDestinationKey>>> childChanges);
    public TransformMany`4(IObservable`1<IChangeSet`2<TSource, TSourceKey>> source, Func`2<TSource, ReadOnlyObservableCollection`1<TDestination>> manySelector, Func`2<TDestination, TDestinationKey> keySelector);
    public TransformMany`4(IObservable`1<IChangeSet`2<TSource, TSourceKey>> source, Func`2<TSource, ObservableCollection`1<TDestination>> manySelector, Func`2<TDestination, TDestinationKey> keySelector);
    public TransformMany`4(IObservable`1<IChangeSet`2<TSource, TSourceKey>> source, Func`2<TSource, IObservableCache`2<TDestination, TDestinationKey>> manySelector, Func`2<TDestination, TDestinationKey> keySelector);
    public IObservable`1<IChangeSet`2<TDestination, TDestinationKey>> Run();
    private IObservable`1<IChangeSet`2<TDestination, TDestinationKey>> Create();
    private IObservable`1<IChangeSet`2<TDestination, TDestinationKey>> CreateWithChangeSet();
    [CompilerGeneratedAttribute]
private ManyContainer<TDestination, TDestinationKey, TSource, TSourceKey> <Create>b__9_0(TSource t, TSourceKey _);
    [NullableContextAttribute("0")]
[CompilerGeneratedAttribute]
private DestinationContainer<TDestination, TDestinationKey, TSource, TSourceKey> <Create>b__9_2(TDestination m);
    [CompilerGeneratedAttribute]
private IDisposable <CreateWithChangeSet>b__10_0(IObserver`1<IChangeSet`2<TDestination, TDestinationKey>> observer);
    [CompilerGeneratedAttribute]
private ManyContainer<TDestination, TDestinationKey, TSource, TSourceKey> <CreateWithChangeSet>b__10_1(TSource t, TSourceKey _);
    [NullableContextAttribute("0")]
[CompilerGeneratedAttribute]
private DestinationContainer<TDestination, TDestinationKey, TSource, TSourceKey> <CreateWithChangeSet>b__10_6(TDestination m);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class DynamicData.Cache.Internal.TransformManyAsync`4 : object {
    [CompilerGeneratedAttribute]
private IObservable`1<IChangeSet`2<TSource, TKey>> <source>P;
    [CompilerGeneratedAttribute]
private Func`3<TSource, TKey, Task`1<IObservable`1<IChangeSet`2<TDestination, TDestinationKey>>>> <selector>P;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private IEqualityComparer`1<TDestination> <equalityComparer>P;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private IComparer`1<TDestination> <comparer>P;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private Action`1<Error`2<TSource, TKey>> <errorHandler>P;
    public TransformManyAsync`4(IObservable`1<IChangeSet`2<TSource, TKey>> source, Func`3<TSource, TKey, Task`1<IObservable`1<IChangeSet`2<TDestination, TDestinationKey>>>> selector, IEqualityComparer`1<TDestination> equalityComparer, IComparer`1<TDestination> comparer, Action`1<Error`2<TSource, TKey>> errorHandler);
    public IObservable`1<IChangeSet`2<TDestination, TDestinationKey>> Run();
    [CompilerGeneratedAttribute]
private IDisposable <Run>b__6_0(IObserver`1<IChangeSet`2<TDestination, TDestinationKey>> observer);
    [AsyncStateMachineAttribute("DynamicData.Cache.Internal.TransformManyAsync`4/<<Run>g__InvokeSelector|6_2>d")]
[CompilerGeneratedAttribute]
private Task`1<IObservable`1<IChangeSet`2<TDestination, TDestinationKey>>> <Run>g__InvokeSelector|6_2(TSource obj, TKey key);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class DynamicData.Cache.Internal.TransformOnObservable`3 : object {
    [CompilerGeneratedAttribute]
private IObservable`1<IChangeSet`2<TSource, TKey>> <source>P;
    [CompilerGeneratedAttribute]
private Func`3<TSource, TKey, IObservable`1<TDestination>> <transform>P;
    public TransformOnObservable`3(IObservable`1<IChangeSet`2<TSource, TKey>> source, Func`3<TSource, TKey, IObservable`1<TDestination>> transform);
    public IObservable`1<IChangeSet`2<TDestination, TKey>> Run();
    [CompilerGeneratedAttribute]
private IDisposable <Run>b__3_0(IObserver`1<IChangeSet`2<TDestination, TKey>> observer);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class DynamicData.Cache.Internal.TransformWithForcedTransform`3 : object {
    [CompilerGeneratedAttribute]
private IObservable`1<IChangeSet`2<TSource, TKey>> <source>P;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private Func`4<TSource, Optional`1<TSource>, TKey, TDestination> <transformFactory>P;
    [CompilerGeneratedAttribute]
private IObservable`1<Func`3<TSource, TKey, bool>> <forceTransform>P;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private Action`1<Error`2<TSource, TKey>> <exceptionCallback>P;
    public TransformWithForcedTransform`3(IObservable`1<IChangeSet`2<TSource, TKey>> source, Func`4<TSource, Optional`1<TSource>, TKey, TDestination> transformFactory, IObservable`1<Func`3<TSource, TKey, bool>> forceTransform, Action`1<Error`2<TSource, TKey>> exceptionCallback);
    public IObservable`1<IChangeSet`2<TDestination, TKey>> Run();
    private static IEnumerable`1<Change`2<TSource, TKey>> CaptureChanges(Cache`2<TSource, TKey> cache, Func`3<TSource, TKey, bool> shouldTransform);
    [CompilerGeneratedAttribute]
private IDisposable <Run>b__5_0(IObserver`1<IChangeSet`2<TDestination, TKey>> observer);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class DynamicData.Cache.Internal.TransformWithInlineUpdate`3 : object {
    [CompilerGeneratedAttribute]
private IObservable`1<IChangeSet`2<TSource, TKey>> <source>P;
    [CompilerGeneratedAttribute]
private Func`2<TSource, TDestination> <transformFactory>P;
    [CompilerGeneratedAttribute]
private Action`2<TDestination, TSource> <updateAction>P;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private Action`1<Error`2<TSource, TKey>> <exceptionCallback>P;
    [CompilerGeneratedAttribute]
private bool <transformOnRefresh>P;
    public TransformWithInlineUpdate`3(IObservable`1<IChangeSet`2<TSource, TKey>> source, Func`2<TSource, TDestination> transformFactory, Action`2<TDestination, TSource> updateAction, Action`1<Error`2<TSource, TKey>> exceptionCallback, bool transformOnRefresh);
    public IObservable`1<IChangeSet`2<TDestination, TKey>> Run();
    private IObservable`1<IChangeSet`2<TDestination, TKey>> RunImpl();
    private void Transform(ChangeAwareCache`2<TDestination, TKey> cache, Change`2& change);
    private void InlineUpdate(ChangeAwareCache`2<TDestination, TKey> cache, Change`2<TSource, TKey> change);
    [NullableContextAttribute("0")]
[CompilerGeneratedAttribute]
private ChangeAwareCache`2<TDestination, TKey> <RunImpl>b__7_0(ChangeAwareCache`2<TDestination, TKey> cache, IChangeSet`2<TSource, TKey> changes);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class DynamicData.Cache.Internal.TreeBuilder`2 : object {
    private Func`2<TObject, TKey> _pivotOn;
    private IObservable`1<Func`2<Node`2<TObject, TKey>, bool>> _predicateChanged;
    private IObservable`1<IChangeSet`2<TObject, TKey>> _source;
    private static Func`2<Node`2<TObject, TKey>, bool> DefaultPredicate { get; }
    public TreeBuilder`2(IObservable`1<IChangeSet`2<TObject, TKey>> source, Func`2<TObject, TKey> pivotOn, IObservable`1<Func`2<Node`2<TObject, TKey>, bool>> predicateChanged);
    private static Func`2<Node`2<TObject, TKey>, bool> get_DefaultPredicate();
    public IObservable`1<IChangeSet`2<Node`2<TObject, TKey>, TKey>> Run();
    [CompilerGeneratedAttribute]
private IDisposable <Run>b__6_0(IObserver`1<IChangeSet`2<Node`2<TObject, TKey>, TKey>> observer);
    [CompilerGeneratedAttribute]
private TKey <Run>b__6_2(Node`2<TObject, TKey> x);
    [NullableContextAttribute("0")]
[CompilerGeneratedAttribute]
private TKey <Run>b__6_9(Change`2<Node`2<TObject, TKey>, TKey> c);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class DynamicData.Cache.Internal.TrueFor`3 : object {
    private Func`2<IEnumerable`1<ObservableWithValue`2<TObject, TValue>>, bool> _collectionMatcher;
    private Func`2<TObject, IObservable`1<TValue>> _observableSelector;
    private IObservable`1<IChangeSet`2<TObject, TKey>> _source;
    public TrueFor`3(IObservable`1<IChangeSet`2<TObject, TKey>> source, Func`2<TObject, IObservable`1<TValue>> observableSelector, Func`2<IEnumerable`1<ObservableWithValue`2<TObject, TValue>>, bool> collectionMatcher);
    public IObservable`1<bool> Run();
    [CompilerGeneratedAttribute]
private IDisposable <Run>b__4_0(IObserver`1<bool> observer);
    [CompilerGeneratedAttribute]
private ObservableWithValue`2<TObject, TValue> <Run>b__4_1(TObject item);
    [NullableContextAttribute("0")]
[CompilerGeneratedAttribute]
private bool <Run>b__4_3(TValue _, IReadOnlyCollection`1<ObservableWithValue`2<TObject, TValue>> itemsWithValues);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class DynamicData.Cache.Internal.UniquenessEnforcer`2 : object {
    [CompilerGeneratedAttribute]
private IObservable`1<IChangeSet`2<TObject, TKey>> <source>P;
    public UniquenessEnforcer`2(IObservable`1<IChangeSet`2<TObject, TKey>> source);
    public IObservable`1<IChangeSet`2<TObject, TKey>> Run();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class DynamicData.Cache.Internal.Virtualise`2 : object {
    private IObservable`1<ISortedChangeSet`2<TObject, TKey>> _source;
    private IObservable`1<IVirtualRequest> _virtualRequests;
    public Virtualise`2(IObservable`1<ISortedChangeSet`2<TObject, TKey>> source, IObservable`1<IVirtualRequest> virtualRequests);
    public IObservable`1<IVirtualChangeSet`2<TObject, TKey>> Run();
    [CompilerGeneratedAttribute]
private IDisposable <Run>b__3_0(IObserver`1<IVirtualChangeSet`2<TObject, TKey>> observer);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class DynamicData.Change`1 : object {
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private ItemChange`1<T> <Item>k__BackingField;
    [CompilerGeneratedAttribute]
private RangeChange`1<T> <Range>k__BackingField;
    [CompilerGeneratedAttribute]
private ListChangeReason <Reason>k__BackingField;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ItemChange`1<T> Item { get; }
    public RangeChange`1<T> Range { get; }
    public ListChangeReason Reason { get; }
    public ChangeType Type { get; }
    public Change`1(ListChangeReason reason, T current, int index);
    public Change`1(ListChangeReason reason, IEnumerable`1<T> items, int index);
    public Change`1(T current, int currentIndex, int previousIndex);
    public Change`1(ListChangeReason reason, T current, Optional`1& previous, int currentIndex, int previousIndex);
    [CompilerGeneratedAttribute]
public ItemChange`1<T> get_Item();
    [CompilerGeneratedAttribute]
public RangeChange`1<T> get_Range();
    [CompilerGeneratedAttribute]
public ListChangeReason get_Reason();
    public ChangeType get_Type();
    public static bool op_Equality(Change`1<T> left, Change`1<T> right);
    public static bool op_Inequality(Change`1<T> left, Change`1<T> right);
    public sealed virtual bool Equals(Change`1<T> other);
    [NullableContextAttribute("2")]
public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public virtual string ToString();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[IsReadOnlyAttribute]
public class DynamicData.Change`2 : ValueType {
    [CompilerGeneratedAttribute]
private TKey <Key>k__BackingField;
    [CompilerGeneratedAttribute]
private ChangeReason <Reason>k__BackingField;
    [CompilerGeneratedAttribute]
private TObject <Current>k__BackingField;
    [CompilerGeneratedAttribute]
private int <CurrentIndex>k__BackingField;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private Optional`1<TObject> <Previous>k__BackingField;
    [CompilerGeneratedAttribute]
private int <PreviousIndex>k__BackingField;
    public TKey Key { get; }
    public ChangeReason Reason { get; }
    public TObject Current { get; }
    public int CurrentIndex { get; }
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public Optional`1<TObject> Previous { get; }
    public int PreviousIndex { get; }
    public Change`2(ChangeReason reason, TKey key, TObject current, int index);
    public Change`2(TKey key, TObject current, int currentIndex, int previousIndex);
    public Change`2(ChangeReason reason, TKey key, TObject current, Optional`1& previous, int currentIndex, int previousIndex);
    [CompilerGeneratedAttribute]
public TKey get_Key();
    [CompilerGeneratedAttribute]
public ChangeReason get_Reason();
    [CompilerGeneratedAttribute]
public TObject get_Current();
    [CompilerGeneratedAttribute]
public int get_CurrentIndex();
    [CompilerGeneratedAttribute]
public Optional`1<TObject> get_Previous();
    [CompilerGeneratedAttribute]
public int get_PreviousIndex();
    public static bool op_Equality(Change`2& left, Change`2& right);
    public static bool op_Inequality(Change`2& left, Change`2& right);
    public sealed virtual bool Equals(Change`2<TObject, TKey> other);
    [NullableContextAttribute("2")]
public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public virtual string ToString();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class DynamicData.ChangeAwareCache`2 : object {
    private Dictionary`2<TKey, TObject> _data;
    private ChangeSet`2<TObject, TKey> _changes;
    public int Count { get; }
    public IEnumerable`1<TObject> Items { get; }
    public IEnumerable`1<TKey> Keys { get; }
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public IEnumerable`1<KeyValuePair`2<TKey, TObject>> KeyValues { get; }
    public ChangeAwareCache`2(int capacity);
    public ChangeAwareCache`2(Dictionary`2<TKey, TObject> data);
    public sealed virtual int get_Count();
    public sealed virtual IEnumerable`1<TObject> get_Items();
    public sealed virtual IEnumerable`1<TKey> get_Keys();
    public sealed virtual IEnumerable`1<KeyValuePair`2<TKey, TObject>> get_KeyValues();
    internal Dictionary`2<TKey, TObject> GetDictionary();
    public void Add(TObject item, TKey key);
    public sealed virtual void AddOrUpdate(TObject item, TKey key);
    public ChangeSet`2<TObject, TKey> CaptureChanges();
    public sealed virtual void Clear();
    public sealed virtual void Clone(IChangeSet`2<TObject, TKey> changes);
    public sealed virtual Optional`1<TObject> Lookup(TKey key);
    public sealed virtual void Refresh(IEnumerable`1<TKey> keys);
    public sealed virtual void Refresh();
    public sealed virtual void Refresh(TKey key);
    public sealed virtual void Remove(IEnumerable`1<TKey> keys);
    public sealed virtual void Remove(TKey key);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[DefaultMemberAttribute("Item")]
public class DynamicData.ChangeAwareList`1 : object {
    private List`1<T> _innerList;
    private ChangeSet`1<T> _changes;
    public int Capacity { get; public set; }
    public int Count { get; }
    public bool IsReadOnly { get; }
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private Optional`1<Change`1<T>> Last { get; }
    public T Item { get; public set; }
    public ChangeAwareList`1(int capacity);
    public ChangeAwareList`1(IEnumerable`1<T> items);
    public ChangeAwareList`1(ChangeAwareList`1<T> list, bool copyChanges);
    public int get_Capacity();
    public void set_Capacity(int value);
    public sealed virtual int get_Count();
    public sealed virtual bool get_IsReadOnly();
    private Optional`1<Change`1<T>> get_Last();
    public sealed virtual T get_Item(int index);
    public sealed virtual void set_Item(int index, T value);
    public sealed virtual void Add(T item);
    public sealed virtual void AddRange(IEnumerable`1<T> collection);
    public IChangeSet`1<T> CaptureChanges();
    public virtual void Clear();
    public virtual bool Contains(T item);
    public sealed virtual void CopyTo(T[] array, int arrayIndex);
    public sealed virtual IEnumerator`1<T> GetEnumerator();
    public sealed virtual int IndexOf(T item);
    public int IndexOf(T item, IEqualityComparer`1<T> equalityComparer);
    public sealed virtual void Insert(int index, T item);
    public sealed virtual void InsertRange(IEnumerable`1<T> collection, int index);
    public virtual void Move(T item, int destination);
    public virtual void Move(int original, int destination);
    public void Refresh(T item, int index);
    public bool Refresh(T item);
    public void RefreshAt(int index);
    public sealed virtual bool Remove(T item);
    public sealed virtual void RemoveAt(int index);
    public sealed virtual void RemoveRange(int index, int count);
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    internal void ClearChanges();
    protected virtual void InsertItem(int index, T item);
    protected virtual void OnInsertItems(int startIndex, IEnumerable`1<T> items);
    protected virtual void OnRemoveItems(int startIndex, IEnumerable`1<T> items);
    protected virtual void OnSetItem(int index, T newItem, T oldItem);
    protected void RemoveItem(int index);
    protected virtual void RemoveItem(int index, T item);
    protected virtual void SetItem(int index, T item);
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal class DynamicData.ChangeAwareListWithRefCounts`1 : ChangeAwareList`1<T> {
    private ReferenceCountTracker`1<T> _tracker;
    public virtual void Clear();
    public virtual bool Contains(T item);
    protected virtual void InsertItem(int index, T item);
    protected virtual void OnInsertItems(int startIndex, IEnumerable`1<T> items);
    protected virtual void OnRemoveItems(int startIndex, IEnumerable`1<T> items);
    protected virtual void OnSetItem(int index, T newItem, T oldItem);
    protected virtual void RemoveItem(int index, T item);
    [NullableContextAttribute("0")]
[CompilerGeneratedAttribute]
private void <OnInsertItems>b__4_0(T t);
    [NullableContextAttribute("0")]
[CompilerGeneratedAttribute]
private void <OnRemoveItems>b__5_0(T t);
}
public enum DynamicData.ChangeReason : Enum {
    public int value__;
    public static ChangeReason Add;
    public static ChangeReason Update;
    public static ChangeReason Remove;
    public static ChangeReason Refresh;
    public static ChangeReason Moved;
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public class DynamicData.ChangeSet`1 : List`1<Change`1<T>> {
    public static IChangeSet`1<T> Empty;
    public int Adds { get; }
    public int Moves { get; }
    public int Refreshes { get; }
    public int Removes { get; }
    public int Replaced { get; }
    public int TotalChanges { get; }
    public ChangeSet`1(IEnumerable`1<Change`1<T>> items);
    public ChangeSet`1(int capacity);
    private static ChangeSet`1();
    public sealed virtual int get_Adds();
    public sealed virtual int get_Moves();
    public sealed virtual int get_Refreshes();
    public sealed virtual int get_Removes();
    public sealed virtual int get_Replaced();
    public sealed virtual int get_TotalChanges();
    public virtual string ToString();
    private sealed virtual override int DynamicData.IChangeSet.get_Capacity();
    private sealed virtual override void DynamicData.IChangeSet.set_Capacity(int value);
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public class DynamicData.ChangeSet`2 : List`1<Change`2<TObject, TKey>> {
    public static ChangeSet`2<TObject, TKey> Empty;
    public int Adds { get; }
    public int Moves { get; }
    public int Refreshes { get; }
    public int Removes { get; }
    public int Updates { get; }
    public ChangeSet`2(IEnumerable`1<Change`2<TObject, TKey>> collection);
    public ChangeSet`2(int capacity);
    private static ChangeSet`2();
    public sealed virtual int get_Adds();
    public sealed virtual int get_Moves();
    public sealed virtual int get_Refreshes();
    public sealed virtual int get_Removes();
    public sealed virtual int get_Updates();
    public virtual string ToString();
    private sealed virtual override int DynamicData.IChangeSet.get_Capacity();
    private sealed virtual override void DynamicData.IChangeSet.set_Capacity(int value);
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public class DynamicData.ChangeSet`3 : ChangeSet`2<TObject, TKey> {
    [CompilerGeneratedAttribute]
private TContext <Context>k__BackingField;
    public TContext Context { get; }
    public ChangeSet`3(TContext context);
    public ChangeSet`3(IEnumerable`1<Change`2<TObject, TKey>> collection, TContext context);
    public ChangeSet`3(int capacity, TContext context);
    [CompilerGeneratedAttribute]
public sealed virtual TContext get_Context();
    private sealed virtual override int DynamicData.IChangeSet.get_Capacity();
    private sealed virtual override void DynamicData.IChangeSet.set_Capacity(int value);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
public static class DynamicData.ChangeSetEx : object {
    [ExtensionAttribute]
public static IEnumerable`1<ItemChange`1<T>> Flatten(IChangeSet`1<T> source);
    [ExtensionAttribute]
public static ChangeType GetChangeType(ListChangeReason source);
    [ExtensionAttribute]
public static IChangeSet`1<TDestination> Transform(IChangeSet`1<TSource> source, Func`2<TSource, TDestination> transformer);
    [ExtensionAttribute]
public static IEnumerable`1<Change`1<T>> YieldWithoutIndex(IEnumerable`1<Change`1<T>> source);
    [ExtensionAttribute]
internal static IEnumerable`1<UnifiedChange`1<T>> Unified(IChangeSet`1<T> source);
}
public enum DynamicData.ChangeType : Enum {
    public int value__;
    public static ChangeType Item;
    public static ChangeType Range;
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal static class DynamicData.Constants : object {
    public static string VirtualizeIsObsolete;
    public static string PageIsObsolete;
    public static string TopIsObsolete;
    public static string SortIsObsolete;
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class DynamicData.Diagnostics.ChangeStatistics : object {
    [CompilerGeneratedAttribute]
private int <Adds>k__BackingField;
    [CompilerGeneratedAttribute]
private int <Count>k__BackingField;
    [CompilerGeneratedAttribute]
private int <Index>k__BackingField;
    [CompilerGeneratedAttribute]
private DateTime <LastUpdated>k__BackingField;
    [CompilerGeneratedAttribute]
private int <Moves>k__BackingField;
    [CompilerGeneratedAttribute]
private int <Refreshes>k__BackingField;
    [CompilerGeneratedAttribute]
private int <Removes>k__BackingField;
    [CompilerGeneratedAttribute]
private int <Updates>k__BackingField;
    public int Adds { get; }
    public int Count { get; }
    public int Index { get; }
    public DateTime LastUpdated { get; }
    public int Moves { get; }
    public int Refreshes { get; }
    public int Removes { get; }
    public int Updates { get; }
    public ChangeStatistics(int index, int adds, int updates, int removes, int refreshes, int moves, int count);
    [CompilerGeneratedAttribute]
public int get_Adds();
    [CompilerGeneratedAttribute]
public int get_Count();
    [CompilerGeneratedAttribute]
public int get_Index();
    [CompilerGeneratedAttribute]
public DateTime get_LastUpdated();
    [CompilerGeneratedAttribute]
public int get_Moves();
    [CompilerGeneratedAttribute]
public int get_Refreshes();
    [CompilerGeneratedAttribute]
public int get_Removes();
    [CompilerGeneratedAttribute]
public int get_Updates();
    public static bool op_Equality(ChangeStatistics left, ChangeStatistics right);
    public static bool op_Inequality(ChangeStatistics left, ChangeStatistics right);
    [NullableContextAttribute("2")]
public sealed virtual bool Equals(ChangeStatistics other);
    [NullableContextAttribute("2")]
public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public virtual string ToString();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class DynamicData.Diagnostics.ChangeSummary : object {
    public static ChangeSummary Empty;
    private int _index;
    [CompilerGeneratedAttribute]
private ChangeStatistics <Latest>k__BackingField;
    [CompilerGeneratedAttribute]
private ChangeStatistics <Overall>k__BackingField;
    public ChangeStatistics Latest { get; }
    public ChangeStatistics Overall { get; }
    public ChangeSummary(int index, ChangeStatistics latest, ChangeStatistics overall);
    private static ChangeSummary();
    [CompilerGeneratedAttribute]
public ChangeStatistics get_Latest();
    [CompilerGeneratedAttribute]
public ChangeStatistics get_Overall();
    [NullableContextAttribute("2")]
public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public virtual string ToString();
    private bool Equals(ChangeSummary other);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
public static class DynamicData.Diagnostics.DiagnosticOperators : object {
    [ExtensionAttribute]
public static IObservable`1<ChangeSummary> CollectUpdateStats(IObservable`1<IChangeSet`2<TSource, TKey>> source);
    [ExtensionAttribute]
public static IObservable`1<ChangeSummary> CollectUpdateStats(IObservable`1<IChangeSet`1<TSource>> source);
}
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal class DynamicData.DistinctChangeSet`1 : ChangeSet`2<T, T> {
    public DistinctChangeSet`1(IEnumerable`1<Change`2<T, T>> items);
    public DistinctChangeSet`1(int capacity);
    private sealed virtual override int DynamicData.IChangeSet.get_Capacity();
    private sealed virtual override void DynamicData.IChangeSet.set_Capacity(int value);
}
public static class DynamicData.DynamicDataOptions : object {
    [CompilerGeneratedAttribute]
private static BindingOptions <Binding>k__BackingField;
    [CompilerGeneratedAttribute]
private static SortAndBindOptions <SortAndBind>k__BackingField;
    public static BindingOptions Binding { get; public set; }
    public static SortAndBindOptions SortAndBind { get; public set; }
    private static DynamicDataOptions();
    [CompilerGeneratedAttribute]
public static BindingOptions get_Binding();
    [CompilerGeneratedAttribute]
public static void set_Binding(BindingOptions value);
    [CompilerGeneratedAttribute]
public static SortAndBindOptions get_SortAndBind();
    [CompilerGeneratedAttribute]
public static void set_SortAndBind(SortAndBindOptions value);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
public static class DynamicData.EnumerableEx : object {
    [ExtensionAttribute]
public static IObservable`1<IChangeSet`2<TObject, TKey>> AsObservableChangeSet(IEnumerable`1<TObject> source, Func`2<TObject, TKey> keySelector, bool completable);
    [ExtensionAttribute]
public static IObservable`1<IChangeSet`1<TObject>> AsObservableChangeSet(IEnumerable`1<TObject> source, bool completable);
}
[ExtensionAttribute]
internal static class DynamicData.ExceptionMixins : object {
    [NullableContextAttribute("2")]
[ExtensionAttribute]
public static void ThrowArgumentNullExceptionIfNull(T value, string name);
}
[ExtensionAttribute]
public static class DynamicData.Experimental.ExperimentalEx : object {
    [NullableContextAttribute("1")]
[ExtensionAttribute]
public static IWatcher`2<TObject, TKey> AsWatcher(IObservable`1<IChangeSet`2<TObject, TKey>> source, IScheduler scheduler);
}
[NullableContextAttribute("2")]
internal interface DynamicData.Experimental.ISubjectWithRefCount`1 {
    public int RefCount { get; }
    public abstract virtual int get_RefCount();
}
[NullableContextAttribute("1")]
public interface DynamicData.Experimental.IWatcher`2 {
    public abstract virtual IObservable`1<Change`2<TObject, TKey>> Watch(TKey key);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class DynamicData.Experimental.SubjectWithRefCount`1 : object {
    private ISubject`1<T> _subject;
    private int _refCount;
    public int RefCount { get; }
    public SubjectWithRefCount`1(ISubject`1<T> subject);
    public sealed virtual int get_RefCount();
    public sealed virtual void OnCompleted();
    public sealed virtual void OnError(Exception error);
    public sealed virtual void OnNext(T value);
    public sealed virtual IDisposable Subscribe(IObserver`1<T> observer);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class DynamicData.Experimental.Watcher`2 : object {
    private IDisposable _disposer;
    private object _locker;
    private IObservableCache`2<TObject, TKey> _source;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private IntermediateCache`2<SubjectWithRefCount`1<Change`2<TObject, TKey>>, TKey> _subscribers;
    public Watcher`2(IObservable`1<IChangeSet`2<TObject, TKey>> source, IScheduler scheduler);
    public sealed virtual void Dispose();
    public sealed virtual IObservable`1<Change`2<TObject, TKey>> Watch(TKey key);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal static class DynamicData.GlobalConfig : object {
    public static IScheduler DefaultScheduler { get; }
    public static IScheduler get_DefaultScheduler();
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal class DynamicData.GroupChangeSet`3 : ChangeSet`2<IGroup`3<TObject, TKey, TGroupKey>, TGroupKey> {
    public static IGroupChangeSet`3<TObject, TKey, TGroupKey> Empty;
    public GroupChangeSet`3(IEnumerable`1<Change`2<IGroup`3<TObject, TKey, TGroupKey>, TGroupKey>> items);
    private static GroupChangeSet`3();
    private sealed virtual override int DynamicData.IChangeSet.get_Capacity();
    private sealed virtual override void DynamicData.IChangeSet.set_Capacity(int value);
}
[NullableContextAttribute("1")]
public interface DynamicData.ICache`2 {
    public abstract virtual void AddOrUpdate(TObject item, TKey key);
    public abstract virtual void Clear();
    public abstract virtual void Clone(IChangeSet`2<TObject, TKey> changes);
    public abstract virtual void Refresh();
    public abstract virtual void Refresh(IEnumerable`1<TKey> keys);
    public abstract virtual void Refresh(TKey key);
    public abstract virtual void Remove(TKey key);
    public abstract virtual void Remove(IEnumerable`1<TKey> keys);
}
[NullableContextAttribute("1")]
public interface DynamicData.ICacheUpdater`2 {
    public abstract virtual void AddOrUpdate(IEnumerable`1<KeyValuePair`2<TKey, TObject>> keyValuePairs);
    public abstract virtual void AddOrUpdate(KeyValuePair`2<TKey, TObject> item);
    public abstract virtual void AddOrUpdate(TObject item, TKey key);
    public abstract virtual void Clear();
    public abstract virtual void Clone(IChangeSet`2<TObject, TKey> changes);
    public abstract virtual TKey GetKey(TObject item);
    public abstract virtual IEnumerable`1<KeyValuePair`2<TKey, TObject>> GetKeyValues(IEnumerable`1<TObject> items);
    public abstract virtual void Refresh();
    public abstract virtual void Refresh(IEnumerable`1<TKey> keys);
    public abstract virtual void Refresh(TKey key);
    public abstract virtual void Remove(IEnumerable`1<TKey> keys);
    public abstract virtual void Remove(TKey key);
    public abstract virtual void Remove(IEnumerable`1<KeyValuePair`2<TKey, TObject>> items);
    public abstract virtual void Remove(KeyValuePair`2<TKey, TObject> item);
    public abstract virtual void RemoveKey(TKey key);
    public abstract virtual void RemoveKeys(IEnumerable`1<TKey> key);
    [ObsoleteAttribute("Use Clone()")]
public abstract virtual void Update(IChangeSet`2<TObject, TKey> changes);
}
public interface DynamicData.IChangeSet {
    public int Adds { get; }
    public int Capacity { get; public set; }
    public int Count { get; }
    public int Moves { get; }
    public int Refreshes { get; }
    public int Removes { get; }
    public abstract virtual int get_Adds();
    public abstract virtual int get_Capacity();
    public abstract virtual void set_Capacity(int value);
    public abstract virtual int get_Count();
    public abstract virtual int get_Moves();
    public abstract virtual int get_Refreshes();
    public abstract virtual int get_Removes();
}
public interface DynamicData.IChangeSet`1 {
    public int Replaced { get; }
    public int TotalChanges { get; }
    public abstract virtual int get_Replaced();
    public abstract virtual int get_TotalChanges();
}
public interface DynamicData.IChangeSet`2 {
    public int Updates { get; }
    public abstract virtual int get_Updates();
}
[NullableContextAttribute("1")]
public interface DynamicData.IChangeSet`3 {
    public TContext Context { get; }
    public abstract virtual TContext get_Context();
}
[NullableContextAttribute("1")]
public interface DynamicData.IChangeSetAdaptor`1 {
    public abstract virtual void Adapt(IChangeSet`1<T> changes);
}
[NullableContextAttribute("1")]
public interface DynamicData.IChangeSetAdaptor`2 {
    public abstract virtual void Adapt(IChangeSet`2<TObject, TKey> changes);
}
[NullableContextAttribute("1")]
public interface DynamicData.IConnectableCache`2 {
    public IObservable`1<int> CountChanged { get; }
    public abstract virtual IObservable`1<int> get_CountChanged();
    public abstract virtual IObservable`1<IChangeSet`2<TObject, TKey>> Connect(Func`2<TObject, bool> predicate, bool suppressEmptyChangeSets);
    public abstract virtual IObservable`1<IChangeSet`2<TObject, TKey>> Preview(Func`2<TObject, bool> predicate);
    public abstract virtual IObservable`1<Change`2<TObject, TKey>> Watch(TKey key);
}
public interface DynamicData.IDistinctChangeSet`1 {
}
[NullableContextAttribute("1")]
public interface DynamicData.IExtendedList`1 {
    public abstract virtual void AddRange(IEnumerable`1<T> collection);
    public abstract virtual void InsertRange(IEnumerable`1<T> collection, int index);
    public abstract virtual void Move(int original, int destination);
    public abstract virtual void RemoveRange(int index, int count);
}
[NullableContextAttribute("1")]
public interface DynamicData.IGroup`2 {
    public TGroup GroupKey { get; }
    public IObservableList`1<TObject> List { get; }
    public abstract virtual TGroup get_GroupKey();
    public abstract virtual IObservableList`1<TObject> get_List();
}
[NullableContextAttribute("1")]
public interface DynamicData.IGroup`3 {
    public IObservableCache`2<TObject, TKey> Cache { get; }
    public abstract virtual IObservableCache`2<TObject, TKey> get_Cache();
}
[NullableContextAttribute("1")]
public interface DynamicData.IGroupChangeSet`3 {
}
[NullableContextAttribute("1")]
public interface DynamicData.IGrouping`3 {
    public int Count { get; }
    public IEnumerable`1<TObject> Items { get; }
    public TGroupKey Key { get; }
    public IEnumerable`1<TKey> Keys { get; }
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public IEnumerable`1<KeyValuePair`2<TKey, TObject>> KeyValues { get; }
    public abstract virtual int get_Count();
    public abstract virtual IEnumerable`1<TObject> get_Items();
    public abstract virtual TGroupKey get_Key();
    public abstract virtual IEnumerable`1<TKey> get_Keys();
    public abstract virtual IEnumerable`1<KeyValuePair`2<TKey, TObject>> get_KeyValues();
    public abstract virtual Optional`1<TObject> Lookup(TKey key);
}
[NullableContextAttribute("1")]
public interface DynamicData.IImmutableGroupChangeSet`3 {
}
[NullableContextAttribute("1")]
public interface DynamicData.IIntermediateCache`2 {
    public abstract virtual void Edit(Action`1<ICacheUpdater`2<TObject, TKey>> updateAction);
}
[NullableContextAttribute("1")]
public interface DynamicData.IKey`1 {
    public T Key { get; }
    public abstract virtual T get_Key();
}
[NullableContextAttribute("1")]
public interface DynamicData.IKeyValue`2 {
    public TObject Value { get; }
    public abstract virtual TObject get_Value();
}
[NullableContextAttribute("2")]
public interface DynamicData.IKeyValueCollection`2 {
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public IComparer`1<KeyValuePair`2<TKey, TObject>> Comparer { get; }
    public SortOptimisations Optimisations { get; }
    public SortReason SortReason { get; }
    public abstract virtual IComparer`1<KeyValuePair`2<TKey, TObject>> get_Comparer();
    public abstract virtual SortOptimisations get_Optimisations();
    public abstract virtual SortReason get_SortReason();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class DynamicData.IndexedItem`2 : object {
    [CompilerGeneratedAttribute]
private int <Index>k__BackingField;
    [CompilerGeneratedAttribute]
private TKey <Key>k__BackingField;
    [CompilerGeneratedAttribute]
private TObject <Value>k__BackingField;
    public int Index { get; }
    public TKey Key { get; }
    public TObject Value { get; }
    public IndexedItem`2(TObject value, TKey key, int index);
    [CompilerGeneratedAttribute]
public int get_Index();
    [CompilerGeneratedAttribute]
public TKey get_Key();
    [CompilerGeneratedAttribute]
public TObject get_Value();
    [NullableContextAttribute("2")]
public virtual bool Equals(object obj);
    public sealed virtual bool Equals(IndexedItem`2<TObject, TKey> other);
    public virtual int GetHashCode();
    public virtual string ToString();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[DebuggerDisplayAttribute("IntermediateCache<{typeof(TObject).Name}, {typeof(TKey).Name}> ({Count} Items)")]
public class DynamicData.IntermediateCache`2 : object {
    private ObservableCache`2<TObject, TKey> _innerCache;
    public int Count { get; }
    public IObservable`1<int> CountChanged { get; }
    public IReadOnlyList`1<TObject> Items { get; }
    public IReadOnlyList`1<TKey> Keys { get; }
    public IReadOnlyDictionary`2<TKey, TObject> KeyValues { get; }
    public IntermediateCache`2(IObservable`1<IChangeSet`2<TObject, TKey>> source);
    public sealed virtual int get_Count();
    public sealed virtual IObservable`1<int> get_CountChanged();
    public sealed virtual IReadOnlyList`1<TObject> get_Items();
    public sealed virtual IReadOnlyList`1<TKey> get_Keys();
    public sealed virtual IReadOnlyDictionary`2<TKey, TObject> get_KeyValues();
    public sealed virtual IObservable`1<IChangeSet`2<TObject, TKey>> Connect(Func`2<TObject, bool> predicate, bool suppressEmptyChangeSets);
    public sealed virtual void Dispose();
    public sealed virtual void Edit(Action`1<ICacheUpdater`2<TObject, TKey>> updateAction);
    public sealed virtual Optional`1<TObject> Lookup(TKey key);
    public sealed virtual IObservable`1<IChangeSet`2<TObject, TKey>> Preview(Func`2<TObject, bool> predicate);
    public sealed virtual IObservable`1<Change`2<TObject, TKey>> Watch(TKey key);
    public sealed virtual IDisposable SuspendCount();
    public sealed virtual IDisposable SuspendNotifications();
    internal IChangeSet`2<TObject, TKey> GetInitialUpdates(Func`2<TObject, bool> filter);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
internal static class DynamicData.Internal.ObservableEx : object {
    [ExtensionAttribute]
public static IDisposable SubscribeSafe(IObservable`1<T> observable, Action`1<T> onNext, Action`1<Exception> onError, Action onCompleted);
    [ExtensionAttribute]
public static IDisposable SubscribeSafe(IObservable`1<T> observable, Action`1<T> onNext, Action`1<Exception> onError);
    [ExtensionAttribute]
public static IDisposable SubscribeSafe(IObservable`1<T> observable, Action`1<Exception> onError, Action onCompleted);
    [ExtensionAttribute]
public static IDisposable SubscribeSafe(IObservable`1<T> observable, Action`1<Exception> onError);
}
[NullableContextAttribute("1")]
public interface DynamicData.IObservableCache`2 {
    public int Count { get; }
    public IReadOnlyList`1<TObject> Items { get; }
    public IReadOnlyList`1<TKey> Keys { get; }
    public IReadOnlyDictionary`2<TKey, TObject> KeyValues { get; }
    public abstract virtual int get_Count();
    public abstract virtual IReadOnlyList`1<TObject> get_Items();
    public abstract virtual IReadOnlyList`1<TKey> get_Keys();
    public abstract virtual IReadOnlyDictionary`2<TKey, TObject> get_KeyValues();
    public abstract virtual Optional`1<TObject> Lookup(TKey key);
}
[NullableContextAttribute("1")]
public interface DynamicData.IObservableList`1 {
    public int Count { get; }
    public IObservable`1<int> CountChanged { get; }
    public IReadOnlyList`1<T> Items { get; }
    public abstract virtual int get_Count();
    public abstract virtual IObservable`1<int> get_CountChanged();
    public abstract virtual IReadOnlyList`1<T> get_Items();
    public abstract virtual IObservable`1<IChangeSet`1<T>> Connect(Func`2<T, bool> predicate);
    public abstract virtual IObservable`1<IChangeSet`1<T>> Preview(Func`2<T, bool> predicate);
}
[NullableContextAttribute("1")]
public interface DynamicData.IPageChangeSet`1 {
    public IPageResponse Response { get; }
    public abstract virtual IPageResponse get_Response();
}
[NullableContextAttribute("1")]
public interface DynamicData.IPagedChangeSet`2 {
    public IPageResponse Response { get; }
    public abstract virtual IPageResponse get_Response();
}
public interface DynamicData.IPageRequest {
    public int Page { get; }
    public int Size { get; }
    public abstract virtual int get_Page();
    public abstract virtual int get_Size();
}
[NullableContextAttribute("1")]
public interface DynamicData.IQuery`2 {
    public int Count { get; }
    public IEnumerable`1<TObject> Items { get; }
    public IEnumerable`1<TKey> Keys { get; }
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public IEnumerable`1<KeyValuePair`2<TKey, TObject>> KeyValues { get; }
    public abstract virtual int get_Count();
    public abstract virtual IEnumerable`1<TObject> get_Items();
    public abstract virtual IEnumerable`1<TKey> get_Keys();
    public abstract virtual IEnumerable`1<KeyValuePair`2<TKey, TObject>> get_KeyValues();
    public abstract virtual Optional`1<TObject> Lookup(TKey key);
}
[NullableContextAttribute("1")]
public interface DynamicData.ISortedChangeSet`2 {
    public IKeyValueCollection`2<TObject, TKey> SortedItems { get; }
    public abstract virtual IKeyValueCollection`2<TObject, TKey> get_SortedItems();
}
[NullableContextAttribute("1")]
public interface DynamicData.ISortedChangeSetAdaptor`2 {
    public abstract virtual void Adapt(ISortedChangeSet`2<TObject, TKey> changes);
}
[NullableContextAttribute("1")]
public interface DynamicData.ISourceCache`2 {
    public Func`2<TObject, TKey> KeySelector { get; }
    public abstract virtual Func`2<TObject, TKey> get_KeySelector();
    public abstract virtual void Edit(Action`1<ISourceUpdater`2<TObject, TKey>> updateAction);
}
[NullableContextAttribute("1")]
public interface DynamicData.ISourceList`1 {
    public abstract virtual void Edit(Action`1<IExtendedList`1<T>> updateAction);
}
[NullableContextAttribute("1")]
public interface DynamicData.ISourceUpdater`2 {
    public abstract virtual void AddOrUpdate(IEnumerable`1<TObject> items);
    public abstract virtual void AddOrUpdate(IEnumerable`1<TObject> items, IEqualityComparer`1<TObject> comparer);
    public abstract virtual void AddOrUpdate(TObject item);
    public abstract virtual void AddOrUpdate(TObject item, IEqualityComparer`1<TObject> comparer);
    public abstract virtual void Load(IEnumerable`1<TObject> items);
    public abstract virtual void Refresh(IEnumerable`1<TObject> items);
    public abstract virtual void Refresh(TObject item);
    public abstract virtual void Remove(IEnumerable`1<TObject> items);
    public abstract virtual void Remove(TObject item);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[IsReadOnlyAttribute]
public class DynamicData.ItemChange`1 : ValueType {
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static ItemChange`1<T> Empty;
    [CompilerGeneratedAttribute]
private ListChangeReason <Reason>k__BackingField;
    [CompilerGeneratedAttribute]
private T <Current>k__BackingField;
    [CompilerGeneratedAttribute]
private int <CurrentIndex>k__BackingField;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private Optional`1<T> <Previous>k__BackingField;
    [CompilerGeneratedAttribute]
private int <PreviousIndex>k__BackingField;
    public ListChangeReason Reason { get; }
    public T Current { get; }
    public int CurrentIndex { get; }
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public Optional`1<T> Previous { get; }
    public int PreviousIndex { get; }
    public ItemChange`1(ListChangeReason reason, T current, Optional`1& previous, int currentIndex, int previousIndex);
    public ItemChange`1(ListChangeReason reason, T current, int currentIndex);
    [CompilerGeneratedAttribute]
public ListChangeReason get_Reason();
    [CompilerGeneratedAttribute]
public T get_Current();
    [CompilerGeneratedAttribute]
public int get_CurrentIndex();
    [CompilerGeneratedAttribute]
public Optional`1<T> get_Previous();
    [CompilerGeneratedAttribute]
public int get_PreviousIndex();
    public static bool op_Equality(ItemChange`1& left, ItemChange`1& right);
    public static bool op_Inequality(ItemChange`1& left, ItemChange`1& right);
    public sealed virtual bool Equals(ItemChange`1<T> other);
    [NullableContextAttribute("2")]
public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public virtual string ToString();
}
[NullableContextAttribute("1")]
public interface DynamicData.IVirtualChangeSet`1 {
    public IVirtualResponse Response { get; }
    public abstract virtual IVirtualResponse get_Response();
}
[NullableContextAttribute("1")]
public interface DynamicData.IVirtualChangeSet`2 {
    public IVirtualResponse Response { get; }
    public abstract virtual IVirtualResponse get_Response();
}
public interface DynamicData.IVirtualRequest {
    public int Size { get; }
    public int StartIndex { get; }
    public abstract virtual int get_Size();
    public abstract virtual int get_StartIndex();
}
public interface DynamicData.IVirtualResponse {
    public int Size { get; }
    public int StartIndex { get; }
    public int TotalSize { get; }
    public abstract virtual int get_Size();
    public abstract virtual int get_StartIndex();
    public abstract virtual int get_TotalSize();
}
public enum DynamicData.Kernel.ConnectionStatus : Enum {
    public int value__;
    public static ConnectionStatus Pending;
    public static ConnectionStatus Loaded;
    public static ConnectionStatus Errored;
    public static ConnectionStatus Completed;
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
public static class DynamicData.Kernel.EnumerableEx : object {
    [ExtensionAttribute]
public static T[] AsArray(IEnumerable`1<T> source);
    [ExtensionAttribute]
public static List`1<T> AsList(IEnumerable`1<T> source);
    [ExtensionAttribute]
public static IEnumerable`1<T> Duplicates(IEnumerable`1<T> source, Func`2<T, TValue> valueSelector);
    [ExtensionAttribute]
public static IEnumerable`1<ItemWithIndex`1<T>> IndexOfMany(IEnumerable`1<T> source, IEnumerable`1<T> itemsToFind);
    [ExtensionAttribute]
public static IEnumerable`1<TResult> IndexOfMany(IEnumerable`1<TObject> source, IEnumerable`1<TObject> itemsToFind, Func`3<TObject, int, TResult> resultSelector);
    [ExtensionAttribute]
internal static IEnumerable`1<T> EmptyIfNull(IEnumerable`1<T> source);
    [IteratorStateMachineAttribute("DynamicData.Kernel.EnumerableEx/<EnumerateOne>d__6`1")]
[ExtensionAttribute]
internal static IEnumerable`1<T> EnumerateOne(T source);
    [ExtensionAttribute]
internal static void ForEach(IEnumerable`1<T> source, Action`1<T> action);
    [ExtensionAttribute]
internal static void ForEach(IEnumerable`1<TObject> source, Action`2<TObject, int> action);
    [ExtensionAttribute]
internal static HashSet`1<T> ToHashSet(IEnumerable`1<T> source);
    [ExtensionAttribute]
internal static IEnumerable`1<ItemWithIndex`1<T>> WithIndex(IEnumerable`1<T> source);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal static class DynamicData.Kernel.EnumerableIList : object {
    public static EnumerableIList`1<T> Create(IList`1<T> list);
    public static EnumerableIList`1<Change`2<TObject, TKey>> Create(IChangeSet`2<TObject, TKey> changeSet);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[IsReadOnlyAttribute]
[DefaultMemberAttribute("Item")]
internal class DynamicData.Kernel.EnumerableIList`1 : ValueType {
    [CompilerGeneratedAttribute]
private IList`1<T> <list>P;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private static EnumerableIList`1<T> <Empty>k__BackingField;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static EnumerableIList`1<T> Empty { get; }
    public int Count { get; }
    public bool IsReadOnly { get; }
    public T Item { get; public set; }
    public EnumerableIList`1(IList`1<T> list);
    [CompilerGeneratedAttribute]
public static EnumerableIList`1<T> get_Empty();
    public sealed virtual int get_Count();
    public sealed virtual bool get_IsReadOnly();
    public sealed virtual T get_Item(int index);
    public sealed virtual void set_Item(int index, T value);
    public static EnumerableIList`1<T> op_Implicit(List`1<T> list);
    public static EnumerableIList`1<T> op_Implicit(T[] array);
    public sealed virtual EnumeratorIList`1<T> GetEnumerator();
    public sealed virtual void Add(T item);
    public sealed virtual void Clear();
    public sealed virtual bool Contains(T item);
    public sealed virtual void CopyTo(T[] array, int arrayIndex);
    public sealed virtual int IndexOf(T item);
    public sealed virtual void Insert(int index, T item);
    public sealed virtual bool Remove(T item);
    public sealed virtual void RemoveAt(int index);
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    private sealed virtual override IEnumerator`1<T> System.Collections.Generic.IEnumerable<T>.GetEnumerator();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class DynamicData.Kernel.EnumeratorIList`1 : ValueType {
    [CompilerGeneratedAttribute]
private IList`1<T> <list>P;
    private int _index;
    public T Current { get; }
    [NullableAttribute("2")]
private object System.Collections.IEnumerator.Current { get; }
    public EnumeratorIList`1(IList`1<T> list);
    [IsReadOnlyAttribute]
public sealed virtual T get_Current();
    [IsReadOnlyAttribute]
[NullableContextAttribute("2")]
private sealed virtual override object System.Collections.IEnumerator.get_Current();
    public sealed virtual bool MoveNext();
    public sealed virtual void Dispose();
    public sealed virtual void Reset();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class DynamicData.Kernel.Error`2 : object {
    [NullableAttribute("2")]
[CompilerGeneratedAttribute]
private Exception <Exception>k__BackingField;
    [CompilerGeneratedAttribute]
private TKey <Key>k__BackingField;
    [CompilerGeneratedAttribute]
private TObject <Value>k__BackingField;
    [NullableAttribute("2")]
public Exception Exception { get; }
    public TKey Key { get; }
    public TObject Value { get; }
    public Error`2(Exception exception, TObject value, TKey key);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public Exception get_Exception();
    [CompilerGeneratedAttribute]
public sealed virtual TKey get_Key();
    [CompilerGeneratedAttribute]
public sealed virtual TObject get_Value();
    public static bool op_Equality(Error`2<TObject, TKey> left, Error`2<TObject, TKey> right);
    public static bool op_Inequality(Error`2<TObject, TKey> left, Error`2<TObject, TKey> right);
    public sealed virtual bool Equals(Error`2<TObject, TKey> other);
    [NullableContextAttribute("2")]
public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public virtual string ToString();
}
internal interface DynamicData.Kernel.IEnumerableIList`1 {
    public abstract virtual EnumeratorIList`1<T> GetEnumerator();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
public static class DynamicData.Kernel.InternalEx : object {
    [ExtensionAttribute]
public static IObservable`1<TSource> RetryWithBackOff(IObservable`1<TSource> source, Func`3<TException, int, Nullable`1<TimeSpan>> backOffStrategy);
    [ExtensionAttribute]
public static IDisposable ScheduleRecurringAction(IScheduler scheduler, TimeSpan interval, Action action);
    [ExtensionAttribute]
public static IDisposable ScheduleRecurringAction(IScheduler scheduler, Func`1<TimeSpan> interval, Action action);
    [ExtensionAttribute]
internal static void OnNext(ISubject`1<Unit> source);
    internal static void Swap(TSwap& t1, TSwap& t2);
    [ExtensionAttribute]
internal static IObservable`1<Unit> ToUnit(IObservable`1<T> source);
    internal static IObservable`1<T> Return(Func`1<T> source);
}
internal interface DynamicData.Kernel.ISupportsCapacity {
    public int Capacity { get; public set; }
    public int Count { get; }
    public abstract virtual int get_Capacity();
    public abstract virtual void set_Capacity(int value);
    public abstract virtual int get_Count();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[IsReadOnlyAttribute]
public class DynamicData.Kernel.ItemWithIndex`1 : ValueType {
    [CompilerGeneratedAttribute]
private T <Item>k__BackingField;
    [CompilerGeneratedAttribute]
private int <Index>k__BackingField;
    public T Item { get; }
    public int Index { get; }
    public ItemWithIndex`1(T item, int index);
    [CompilerGeneratedAttribute]
public T get_Item();
    [CompilerGeneratedAttribute]
public int get_Index();
    public static bool op_Equality(ItemWithIndex`1& left, ItemWithIndex`1& right);
    public static bool op_Inequality(ItemWithIndex`1& left, ItemWithIndex`1& right);
    public sealed virtual bool Equals(ItemWithIndex`1<T> other);
    [NullableContextAttribute("2")]
public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public virtual string ToString();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[IsReadOnlyAttribute]
public class DynamicData.Kernel.ItemWithValue`2 : ValueType {
    [CompilerGeneratedAttribute]
private TObject <Item>k__BackingField;
    [CompilerGeneratedAttribute]
private TValue <Value>k__BackingField;
    public TObject Item { get; }
    public TValue Value { get; }
    public ItemWithValue`2(TObject item, TValue value);
    [CompilerGeneratedAttribute]
public TObject get_Item();
    [CompilerGeneratedAttribute]
public TValue get_Value();
    public static bool op_Equality(ItemWithValue`2& left, ItemWithValue`2& right);
    public static bool op_Inequality(ItemWithValue`2& left, ItemWithValue`2& right);
    public sealed virtual bool Equals(ItemWithValue`2<TObject, TValue> other);
    [NullableContextAttribute("2")]
public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public virtual string ToString();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public static class DynamicData.Kernel.Optional : object {
    public static Optional`1<T> None();
    public static Optional`1<T> Some(T value);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
[IsReadOnlyAttribute]
public class DynamicData.Kernel.Optional`1 : ValueType {
    private T _value;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private static Optional`1<T> <None>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <HasValue>k__BackingField;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static Optional`1<T> None { get; }
    public bool HasValue { get; }
    [NullableAttribute("1")]
public T Value { get; }
    internal Optional`1(T value);
    [CompilerGeneratedAttribute]
public static Optional`1<T> get_None();
    [CompilerGeneratedAttribute]
public bool get_HasValue();
    [NullableContextAttribute("1")]
public T get_Value();
    public static Optional`1<T> op_Implicit(T value);
    public static T op_Explicit(Optional`1& value);
    public static bool op_Equality(Optional`1& left, Optional`1& right);
    public static bool op_Inequality(Optional`1& left, Optional`1& right);
    public static Optional`1<T> Create(T value);
    public static T FromOptional(Optional`1& value);
    public static Optional`1<T> ToOptional(T value);
    public sealed virtual bool Equals(Optional`1<T> other);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public virtual string ToString();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class DynamicData.Kernel.OptionElse : object {
    internal static OptionElse NoAction;
    private bool _shouldRunAction;
    internal OptionElse(bool shouldRunAction);
    private static OptionElse();
    public void Else(Action action);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
public static class DynamicData.Kernel.OptionExtensions : object {
    [ExtensionAttribute]
public static Optional`1<TDestination> Convert(Optional`1& source, Func`2<TSource, TDestination> converter);
    [ExtensionAttribute]
public static Optional`1<TDestination> Convert(Optional`1& source, Func`2<TSource, Optional`1<TDestination>> converter);
    [NullableContextAttribute("2")]
[ExtensionAttribute]
public static TDestination ConvertOr(Optional`1& source, Func`2<TSource, TDestination> converter, Func`1<TDestination> fallbackConverter);
    [ExtensionAttribute]
public static Optional`1<T> OrElse(Optional`1& source, Func`1<Optional`1<T>> fallbackOperation);
    [ExtensionAttribute]
public static Optional`1<T> FirstOrOptional(IEnumerable`1<T> source, Func`2<T, bool> selector);
    [ExtensionAttribute]
public static OptionElse IfHasValue(Optional`1& source, Action`1<T> action);
    [ExtensionAttribute]
public static OptionElse IfHasValue(Nullable`1<Optional`1<T>> source, Action`1<T> action);
    [ExtensionAttribute]
public static Optional`1<TValue> Lookup(IDictionary`2<TKey, TValue> source, TKey key);
    [ExtensionAttribute]
public static bool RemoveIfContained(IDictionary`2<TKey, TValue> source, TKey key);
    [ExtensionAttribute]
public static IEnumerable`1<T> SelectValues(IEnumerable`1<Optional`1<T>> source);
    [NullableContextAttribute("0")]
[ExtensionAttribute]
public static T ValueOr(Nullable`1<T> source, T defaultValue);
    [ExtensionAttribute]
public static T ValueOr(Optional`1& source, Func`1<T> valueSelector);
    [ExtensionAttribute]
public static T ValueOrDefault(Optional`1& source);
    [ExtensionAttribute]
public static T ValueOrThrow(Optional`1& source, Func`1<Exception> exceptionGenerator);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
public static class DynamicData.Kernel.OptionObservableExtensions : object {
    [ExtensionAttribute]
public static IObservable`1<Optional`1<TDestination>> Convert(IObservable`1<Optional`1<TSource>> source, Func`2<TSource, TDestination> converter);
    [ExtensionAttribute]
public static IObservable`1<Optional`1<TDestination>> Convert(IObservable`1<Optional`1<TSource>> source, Func`2<TSource, Optional`1<TDestination>> converter);
    [ExtensionAttribute]
public static IObservable`1<TDestination> ConvertOr(IObservable`1<Optional`1<TSource>> source, Func`2<TSource, TDestination> converter, Func`1<TDestination> fallbackConverter);
    [ExtensionAttribute]
public static IObservable`1<Optional`1<T>> OrElse(IObservable`1<Optional`1<T>> source, Func`1<Optional`1<T>> fallbackOperation);
    [ExtensionAttribute]
public static IObservable`1<Optional`1<T>> OnHasValue(IObservable`1<Optional`1<T>> source, Action`1<T> action, Action elseAction);
    [ExtensionAttribute]
public static IObservable`1<Optional`1<T>> OnHasNoValue(IObservable`1<Optional`1<T>> source, Action action, Action`1<T> elseAction);
    [ExtensionAttribute]
public static IObservable`1<T> SelectValues(IObservable`1<Optional`1<T>> source);
    [ExtensionAttribute]
public static IObservable`1<T> ValueOr(IObservable`1<Optional`1<T>> source, Func`1<T> valueSelector);
    [ExtensionAttribute]
public static IObservable`1<T> ValueOrDefault(IObservable`1<Optional`1<T>> source);
    [ExtensionAttribute]
public static IObservable`1<T> ValueOrThrow(IObservable`1<Optional`1<T>> source, Func`1<Exception> exceptionGenerator);
}
[ExtensionAttribute]
internal static class DynamicData.Kernel.ParallelEx : object {
    [NullableContextAttribute("1")]
[AsyncStateMachineAttribute("DynamicData.Kernel.ParallelEx/<SelectParallel>d__0`2")]
[ExtensionAttribute]
public static Task`1<IEnumerable`1<TDestination>> SelectParallel(IEnumerable`1<TSource> source, Func`2<TSource, Task`1<TDestination>> selector, int maximumThreads);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class DynamicData.Kernel.ReadOnlyCollectionLight`1 : object {
    private IList`1<T> _items;
    [CompilerGeneratedAttribute]
private static IReadOnlyCollection`1<T> <Empty>k__BackingField;
    [CompilerGeneratedAttribute]
private int <Count>k__BackingField;
    public static IReadOnlyCollection`1<T> Empty { get; }
    public int Count { get; }
    public ReadOnlyCollectionLight`1(IEnumerable`1<T> items);
    private static ReadOnlyCollectionLight`1();
    [CompilerGeneratedAttribute]
public static IReadOnlyCollection`1<T> get_Empty();
    [CompilerGeneratedAttribute]
public sealed virtual int get_Count();
    public sealed virtual IEnumerator`1<T> GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
internal class DynamicData.Kernel.ReferenceEqualityComparer`1 : object {
    [NullableAttribute("1")]
public static IEqualityComparer`1<T> Instance;
    private static ReferenceEqualityComparer`1();
    public sealed virtual bool Equals(T x, T y);
    public sealed virtual int GetHashCode(T obj);
}
[NullableContextAttribute("1")]
public interface DynamicData.List.IGrouping`2 {
    public int Count { get; }
    public IEnumerable`1<TObject> Items { get; }
    public TGroupKey Key { get; }
    public abstract virtual int get_Count();
    public abstract virtual IEnumerable`1<TObject> get_Items();
    public abstract virtual TGroupKey get_Key();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[DebuggerDisplayAttribute("AnonymousObservableList<{typeof(T).Name}> ({Count} Items)")]
internal class DynamicData.List.Internal.AnonymousObservableList`1 : object {
    private ISourceList`1<T> _sourceList;
    private IDisposable _cleanUp;
    public int Count { get; }
    public IObservable`1<int> CountChanged { get; }
    public IReadOnlyList`1<T> Items { get; }
    public AnonymousObservableList`1(IObservable`1<IChangeSet`1<T>> source);
    public AnonymousObservableList`1(ISourceList`1<T> sourceList);
    public sealed virtual int get_Count();
    public sealed virtual IObservable`1<int> get_CountChanged();
    public sealed virtual IReadOnlyList`1<T> get_Items();
    public sealed virtual IObservable`1<IChangeSet`1<T>> Connect(Func`2<T, bool> predicate);
    public sealed virtual IObservable`1<IChangeSet`1<T>> Preview(Func`2<T, bool> predicate);
    public sealed virtual void Dispose();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class DynamicData.List.Internal.AutoRefresh`2 : object {
    [CompilerGeneratedAttribute]
private Nullable`1<TimeSpan> <buffer>P;
    [NullableAttribute("2")]
[CompilerGeneratedAttribute]
private IScheduler <scheduler>P;
    private Func`2<TObject, IObservable`1<TAny>> _reEvaluator;
    private IObservable`1<IChangeSet`1<TObject>> _source;
    public AutoRefresh`2(IObservable`1<IChangeSet`1<TObject>> source, Func`2<TObject, IObservable`1<TAny>> reEvaluator, Nullable`1<TimeSpan> buffer, IScheduler scheduler);
    public IObservable`1<IChangeSet`1<TObject>> Run();
    [CompilerGeneratedAttribute]
private IDisposable <Run>b__5_0(IObserver`1<IChangeSet`1<TObject>> observer);
    [CompilerGeneratedAttribute]
private IObservable`1<TObject> <Run>b__5_1(TObject t);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class DynamicData.List.Internal.BufferIf`1 : object {
    [CompilerGeneratedAttribute]
private bool <initialPauseState>P;
    private IObservable`1<bool> _pauseIfTrueSelector;
    private IScheduler _scheduler;
    private IObservable`1<IChangeSet`1<T>> _source;
    private TimeSpan _timeOut;
    public BufferIf`1(IObservable`1<IChangeSet`1<T>> source, IObservable`1<bool> pauseIfTrueSelector, bool initialPauseState, Nullable`1<TimeSpan> timeOut, IScheduler scheduler);
    public IObservable`1<IChangeSet`1<T>> Run();
    [CompilerGeneratedAttribute]
private IDisposable <Run>b__6_0(IObserver`1<IChangeSet`1<T>> observer);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class DynamicData.List.Internal.ChangeSetMergeTracker`1 : object {
    private ChangeAwareList`1<TObject> _resultList;
    public void ProcessChangeSet(IChangeSet`1<TObject> changes, IObserver`1<IChangeSet`1<TObject>> observer);
    public void RemoveItems(IEnumerable`1<TObject> removeItems, IObserver`1<IChangeSet`1<TObject>> observer);
    public void EmitChanges(IObserver`1<IChangeSet`1<TObject>> observer);
    private void OnClear(Change`1<TObject> change);
    private void OnItemAdded(ItemChange`1<TObject> item);
    private void OnItemRefreshed(ItemChange`1<TObject> item);
    private void OnItemRemoved(ItemChange`1<TObject> item);
    private void OnItemReplaced(ItemChange`1<TObject> item);
    private void OnRangeAdded(RangeChange`1<TObject> range);
    private void OnRangeRemoved(RangeChange`1<TObject> range);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class DynamicData.List.Internal.ClonedListChangeSet`1 : object {
    [CompilerGeneratedAttribute]
private List`1<TObject> <List>k__BackingField;
    [CompilerGeneratedAttribute]
private IObservable`1<IChangeSet`1<TObject>> <Source>k__BackingField;
    public List`1<TObject> List { get; }
    public IObservable`1<IChangeSet`1<TObject>> Source { get; }
    public ClonedListChangeSet`1(IObservable`1<IChangeSet`1<TObject>> source, IEqualityComparer`1<TObject> equalityComparer);
    [CompilerGeneratedAttribute]
public List`1<TObject> get_List();
    [CompilerGeneratedAttribute]
public IObservable`1<IChangeSet`1<TObject>> get_Source();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class DynamicData.List.Internal.Combiner`1 : object {
    [CompilerGeneratedAttribute]
private CombineOperator <type>P;
    private object _locker;
    private ICollection`1<IObservable`1<IChangeSet`1<T>>> _source;
    public Combiner`1(ICollection`1<IObservable`1<IChangeSet`1<T>>> source, CombineOperator type);
    public IObservable`1<IChangeSet`1<T>> Run();
    private static void CloneSourceList(ReferenceCountTracker`1<T> tracker, IChangeSet`1<T> changes);
    private bool MatchesConstraint(List`1<ReferenceCountTracker`1<T>> sourceLists, T item);
    private void UpdateItemMembership(T item, List`1<ReferenceCountTracker`1<T>> sourceLists, ChangeAwareListWithRefCounts`1<T> resultList);
    private IChangeSet`1<T> UpdateResultList(IChangeSet`1<T> changes, List`1<ReferenceCountTracker`1<T>> sourceLists, ChangeAwareListWithRefCounts`1<T> resultList);
    [CompilerGeneratedAttribute]
private IDisposable <Run>b__4_0(IObserver`1<IChangeSet`1<T>> observer);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class DynamicData.List.Internal.DeferUntilLoaded`1 : object {
    private IObservable`1<IChangeSet`1<T>> _source;
    public DeferUntilLoaded`1(IObservable`1<IChangeSet`1<T>> source);
    public IObservable`1<IChangeSet`1<T>> Run();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class DynamicData.List.Internal.DisposeMany`1 : object {
    [CompilerGeneratedAttribute]
private IObservable`1<IChangeSet`1<T>> <source>P;
    public DisposeMany`1(IObservable`1<IChangeSet`1<T>> source);
    public IObservable`1<IChangeSet`1<T>> Run();
    private static void ProcessFinalization(List`1<T> cachedItems);
    [CompilerGeneratedAttribute]
private IDisposable <Run>b__2_0(IObserver`1<IChangeSet`1<T>> observer);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class DynamicData.List.Internal.Distinct`2 : object {
    private IObservable`1<IChangeSet`1<T>> _source;
    private Func`2<T, TValue> _valueSelector;
    public Distinct`2(IObservable`1<IChangeSet`1<T>> source, Func`2<T, TValue> valueSelector);
    public IObservable`1<IChangeSet`1<TValue>> Run();
    private static IChangeSet`1<TValue> Process(Dictionary`2<TValue, int> values, ChangeAwareList`1<TValue> result, IChangeSet`1<ItemWithMatch<T, TValue>> changes);
    [CompilerGeneratedAttribute]
private IDisposable <Run>b__3_0(IObserver`1<IChangeSet`1<TValue>> observer);
    [CompilerGeneratedAttribute]
private ItemWithMatch<T, TValue> <Run>b__3_1(T t, Optional`1<ItemWithMatch<T, TValue>> previous, int _);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class DynamicData.List.Internal.DynamicCombiner`1 : object {
    [CompilerGeneratedAttribute]
private CombineOperator <type>P;
    private object _locker;
    private IObservableList`1<IObservable`1<IChangeSet`1<T>>> _source;
    public DynamicCombiner`1(IObservableList`1<IObservable`1<IChangeSet`1<T>>> source, CombineOperator type);
    public IObservable`1<IChangeSet`1<T>> Run();
    private bool MatchesConstraint(MergeContainer[] sourceLists, T item);
    private void UpdateItemMembership(T item, MergeContainer[] sourceLists, ChangeAwareListWithRefCounts`1<T> resultList);
    private IChangeSet`1<T> UpdateItemSetMemberships(MergeContainer[] sourceLists, ChangeAwareListWithRefCounts`1<T> resultingList, IEnumerable`1<T> items);
    private IChangeSet`1<T> UpdateResultList(MergeContainer[] sourceLists, ChangeAwareListWithRefCounts`1<T> resultList, IChangeSet`1<T> changes);
    [CompilerGeneratedAttribute]
private IDisposable <Run>b__4_0(IObserver`1<IChangeSet`1<T>> observer);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class DynamicData.List.Internal.EditDiff`1 : object {
    private IEqualityComparer`1<T> _equalityComparer;
    private ISourceList`1<T> _source;
    public EditDiff`1(ISourceList`1<T> source, IEqualityComparer`1<T> equalityComparer);
    public void Edit(IEnumerable`1<T> items);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class DynamicData.List.Internal.ExpirableItem`1 : object {
    [CompilerGeneratedAttribute]
private DateTime <ExpireAt>k__BackingField;
    [CompilerGeneratedAttribute]
private long <Index>k__BackingField;
    [CompilerGeneratedAttribute]
private TObject <Item>k__BackingField;
    public DateTime ExpireAt { get; }
    public long Index { get; }
    public TObject Item { get; }
    public ExpirableItem`1(TObject value, DateTime dateTime, long index);
    [CompilerGeneratedAttribute]
public DateTime get_ExpireAt();
    [CompilerGeneratedAttribute]
public long get_Index();
    [CompilerGeneratedAttribute]
public TObject get_Item();
    public static bool op_Equality(ExpirableItem`1<TObject> left, ExpirableItem`1<TObject> right);
    public static bool op_Inequality(ExpirableItem`1<TObject> left, ExpirableItem`1<TObject> right);
    public sealed virtual bool Equals(ExpirableItem`1<TObject> other);
    [NullableContextAttribute("2")]
public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public virtual string ToString();
}
internal class DynamicData.List.Internal.ExpireAfter`1 : object {
    [NullableContextAttribute("1")]
public static IObservable`1<IEnumerable`1<T>> Create(ISourceList`1<T> source, Func`2<T, Nullable`1<TimeSpan>> timeSelector, Nullable`1<TimeSpan> pollingInterval, IScheduler scheduler);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class DynamicData.List.Internal.Filter`1 : object {
    private ListFilterPolicy _policy;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private Func`2<T, bool> _predicate;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private IObservable`1<Func`2<T, bool>> _predicates;
    private IObservable`1<IChangeSet`1<T>> _source;
    public Filter`1(IObservable`1<IChangeSet`1<T>> source, IObservable`1<Func`2<T, bool>> predicates, ListFilterPolicy policy);
    public Filter`1(IObservable`1<IChangeSet`1<T>> source, Func`2<T, bool> predicate, ListFilterPolicy policy);
    public IObservable`1<IChangeSet`1<T>> Run();
    private static IChangeSet`1<ItemWithMatch<T>> Process(ChangeAwareList`1<ItemWithMatch<T>> filtered, IChangeSet`1<ItemWithMatch<T>> changes);
    private IChangeSet`1<ItemWithMatch<T>> Requery(Func`2<T, bool> predicate, List`1<ItemWithMatch<T>> all, ChangeAwareList`1<ItemWithMatch<T>> filtered);
    [CompilerGeneratedAttribute]
private IDisposable <Run>b__6_0(IObserver`1<IChangeSet`1<T>> observer);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class DynamicData.List.Internal.FilterOnObservable`1 : object {
    [CompilerGeneratedAttribute]
private Nullable`1<TimeSpan> <buffer>P;
    [NullableAttribute("2")]
[CompilerGeneratedAttribute]
private IScheduler <scheduler>P;
    private Func`2<TObject, IObservable`1<bool>> _filter;
    private IObservable`1<IChangeSet`1<TObject>> _source;
    public FilterOnObservable`1(IObservable`1<IChangeSet`1<TObject>> source, Func`2<TObject, IObservable`1<bool>> filter, Nullable`1<TimeSpan> buffer, IScheduler scheduler);
    public IObservable`1<IChangeSet`1<TObject>> Run();
    private static IEnumerable`1<TResult> IndexOfMany(IEnumerable`1<TObj> source, IEnumerable`1<TObj> itemsToFind, Func`2<TObj, TObjectProp> objectPropertyFunc, Func`3<TObj, int, TResult> resultSelector);
    [CompilerGeneratedAttribute]
private IDisposable <Run>b__5_0(IObserver`1<IChangeSet`1<TObject>> observer);
    [NullableContextAttribute("0")]
[CompilerGeneratedAttribute]
private IObservable`1<ObjWithFilterValue<TObject>> <Run>b__5_2(ObjWithFilterValue<TObject> v);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ObsoleteAttribute("Use AutoRefresh(), followed by Filter() instead")]
internal class DynamicData.List.Internal.FilterOnProperty`2 : object {
    [CompilerGeneratedAttribute]
private IObservable`1<IChangeSet`1<TObject>> <source>P;
    [CompilerGeneratedAttribute]
private Expression`1<Func`2<TObject, TProperty>> <propertySelector>P;
    [CompilerGeneratedAttribute]
private Func`2<TObject, bool> <predicate>P;
    [CompilerGeneratedAttribute]
private Nullable`1<TimeSpan> <throttle>P;
    [NullableAttribute("2")]
[CompilerGeneratedAttribute]
private IScheduler <scheduler>P;
    public FilterOnProperty`2(IObservable`1<IChangeSet`1<TObject>> source, Expression`1<Func`2<TObject, TProperty>> propertySelector, Func`2<TObject, bool> predicate, Nullable`1<TimeSpan> throttle, IScheduler scheduler);
    public IObservable`1<IChangeSet`1<TObject>> Run();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class DynamicData.List.Internal.FilterStatic`1 : object {
    private Func`2<T, bool> _predicate;
    private IObservable`1<IChangeSet`1<T>> _source;
    public FilterStatic`1(IObservable`1<IChangeSet`1<T>> source, Func`2<T, bool> predicate);
    public IObservable`1<IChangeSet`1<T>> Run();
    private void Process(ChangeAwareList`1<T> filtered, IChangeSet`1<T> changes);
    [CompilerGeneratedAttribute]
private IObservable`1<IChangeSet`1<T>> <Run>b__3_0();
    [NullableContextAttribute("0")]
[CompilerGeneratedAttribute]
private ChangeAwareList`1<T> <Run>b__3_1(ChangeAwareList`1<T> state, IChangeSet`1<T> changes);
    [NullableContextAttribute("0")]
[CompilerGeneratedAttribute]
private bool <Process>b__4_0(T t);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class DynamicData.List.Internal.Group`2 : object {
    [CompilerGeneratedAttribute]
private TGroup <GroupKey>k__BackingField;
    [CompilerGeneratedAttribute]
private SourceList`1<TObject> <Source>k__BackingField;
    public TGroup GroupKey { get; }
    public IObservableList`1<TObject> List { get; }
    private SourceList`1<TObject> Source { get; }
    public Group`2(TGroup groupKey);
    [CompilerGeneratedAttribute]
public sealed virtual TGroup get_GroupKey();
    public sealed virtual IObservableList`1<TObject> get_List();
    [CompilerGeneratedAttribute]
private SourceList`1<TObject> get_Source();
    public static bool op_Equality(Group`2<TObject, TGroup> left, Group`2<TObject, TGroup> right);
    public static bool op_Inequality(Group`2<TObject, TGroup> left, Group`2<TObject, TGroup> right);
    public sealed virtual void Dispose();
    public void Edit(Action`1<IList`1<TObject>> editAction);
    public sealed virtual bool Equals(Group`2<TObject, TGroup> other);
    [NullableContextAttribute("2")]
public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public virtual string ToString();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class DynamicData.List.Internal.GroupOn`2 : object {
    private Func`2<TObject, TGroupKey> _groupSelector;
    [NullableAttribute("2")]
private IObservable`1<Unit> _regrouper;
    private IObservable`1<IChangeSet`1<TObject>> _source;
    public GroupOn`2(IObservable`1<IChangeSet`1<TObject>> source, Func`2<TObject, TGroupKey> groupSelector, IObservable`1<Unit> regrouper);
    public IObservable`1<IChangeSet`1<IGroup`2<TObject, TGroupKey>>> Run();
    private static GroupWithAddIndicator<TObject, TGroupKey> GetCache(IDictionary`2<TGroupKey, Group`2<TObject, TGroupKey>> groupCaches, TGroupKey key);
    private static IChangeSet`1<IGroup`2<TObject, TGroupKey>> Process(ChangeAwareList`1<IGroup`2<TObject, TGroupKey>> result, IDictionary`2<TGroupKey, Group`2<TObject, TGroupKey>> groupCollection, IChangeSet`1<ItemWithGroupKey<TObject, TGroupKey>> changes);
    private IChangeSet`1<IGroup`2<TObject, TGroupKey>> Regroup(ChangeAwareList`1<IGroup`2<TObject, TGroupKey>> result, IDictionary`2<TGroupKey, Group`2<TObject, TGroupKey>> groupCollection, IReadOnlyCollection`1<ItemWithGroupKey<TObject, TGroupKey>> currentItems);
    [CompilerGeneratedAttribute]
private IDisposable <Run>b__4_0(IObserver`1<IChangeSet`1<IGroup`2<TObject, TGroupKey>>> observer);
    [CompilerGeneratedAttribute]
private ItemWithGroupKey<TObject, TGroupKey> <Run>b__4_1(TObject t, Optional`1<ItemWithGroupKey<TObject, TGroupKey>> previous);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class DynamicData.List.Internal.GroupOnImmutable`2 : object {
    private Func`2<TObject, TGroupKey> _groupSelector;
    [NullableAttribute("2")]
private IObservable`1<Unit> _reGrouper;
    private IObservable`1<IChangeSet`1<TObject>> _source;
    public GroupOnImmutable`2(IObservable`1<IChangeSet`1<TObject>> source, Func`2<TObject, TGroupKey> groupSelector, IObservable`1<Unit> reGrouper);
    public IObservable`1<IChangeSet`1<IGrouping`2<TObject, TGroupKey>>> Run();
    private static IChangeSet`1<IGrouping`2<TObject, TGroupKey>> CreateChangeSet(ChangeAwareList`1<IGrouping`2<TObject, TGroupKey>> result, IDictionary`2<TGroupKey, GroupContainer<TObject, TGroupKey>> allGroupings, IDictionary`2<TGroupKey, IGrouping`2<TObject, TGroupKey>> initialStateOfGroups);
    private static GroupContainer<TObject, TGroupKey> GetGroup(IDictionary`2<TGroupKey, GroupContainer<TObject, TGroupKey>> groupCaches, TGroupKey key);
    private static ImmutableGroup`2<TObject, TGroupKey> GetGroupState(GroupContainer<TObject, TGroupKey> grouping);
    private static ImmutableGroup`2<TObject, TGroupKey> GetGroupState(TGroupKey key, IList`1<TObject> list);
    private static IChangeSet`1<IGrouping`2<TObject, TGroupKey>> Process(ChangeAwareList`1<IGrouping`2<TObject, TGroupKey>> result, IDictionary`2<TGroupKey, GroupContainer<TObject, TGroupKey>> allGroupings, IChangeSet`1<ItemWithGroupKey<TObject, TGroupKey>> changes);
    private IChangeSet`1<IGrouping`2<TObject, TGroupKey>> Regroup(ChangeAwareList`1<IGrouping`2<TObject, TGroupKey>> result, IDictionary`2<TGroupKey, GroupContainer<TObject, TGroupKey>> allGroupings, IReadOnlyCollection`1<ItemWithGroupKey<TObject, TGroupKey>> currentItems);
    [CompilerGeneratedAttribute]
private IDisposable <Run>b__4_0(IObserver`1<IChangeSet`1<IGrouping`2<TObject, TGroupKey>>> observer);
    [CompilerGeneratedAttribute]
private ItemWithGroupKey<TObject, TGroupKey> <Run>b__4_1(TObject t, Optional`1<ItemWithGroupKey<TObject, TGroupKey>> previous);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class DynamicData.List.Internal.GroupOnProperty`2 : object {
    [CompilerGeneratedAttribute]
private Expression`1<Func`2<TObject, TGroup>> <groupSelectorKey>P;
    [CompilerGeneratedAttribute]
private Nullable`1<TimeSpan> <throttle>P;
    [NullableAttribute("2")]
[CompilerGeneratedAttribute]
private IScheduler <scheduler>P;
    private Func`2<TObject, TGroup> _groupSelector;
    private IObservable`1<IChangeSet`1<TObject>> _source;
    public GroupOnProperty`2(IObservable`1<IChangeSet`1<TObject>> source, Expression`1<Func`2<TObject, TGroup>> groupSelectorKey, Nullable`1<TimeSpan> throttle, IScheduler scheduler);
    public IObservable`1<IChangeSet`1<IGroup`2<TObject, TGroup>>> Run();
    [CompilerGeneratedAttribute]
private IObservable`1<IChangeSet`1<IGroup`2<TObject, TGroup>>> <Run>b__6_0(IObservable`1<IChangeSet`1<TObject>> shared);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class DynamicData.List.Internal.GroupOnPropertyWithImmutableState`2 : object {
    [CompilerGeneratedAttribute]
private Expression`1<Func`2<TObject, TGroup>> <groupSelectorKey>P;
    [CompilerGeneratedAttribute]
private Nullable`1<TimeSpan> <throttle>P;
    [NullableAttribute("2")]
[CompilerGeneratedAttribute]
private IScheduler <scheduler>P;
    private Func`2<TObject, TGroup> _groupSelector;
    private IObservable`1<IChangeSet`1<TObject>> _source;
    public GroupOnPropertyWithImmutableState`2(IObservable`1<IChangeSet`1<TObject>> source, Expression`1<Func`2<TObject, TGroup>> groupSelectorKey, Nullable`1<TimeSpan> throttle, IScheduler scheduler);
    public IObservable`1<IChangeSet`1<IGrouping`2<TObject, TGroup>>> Run();
    [CompilerGeneratedAttribute]
private IObservable`1<IChangeSet`1<IGrouping`2<TObject, TGroup>>> <Run>b__6_0(IObservable`1<IChangeSet`1<TObject>> shared);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class DynamicData.List.Internal.ImmutableGroup`2 : object {
    private IReadOnlyCollection`1<TObject> _items;
    [CompilerGeneratedAttribute]
private TGroupKey <Key>k__BackingField;
    public int Count { get; }
    public IEnumerable`1<TObject> Items { get; }
    public TGroupKey Key { get; }
    internal ImmutableGroup`2(TGroupKey key, IList`1<TObject> items);
    public sealed virtual int get_Count();
    public sealed virtual IEnumerable`1<TObject> get_Items();
    [CompilerGeneratedAttribute]
public sealed virtual TGroupKey get_Key();
    public static bool op_Equality(ImmutableGroup`2<TObject, TGroupKey> left, ImmutableGroup`2<TObject, TGroupKey> right);
    public static bool op_Inequality(ImmutableGroup`2<TObject, TGroupKey> left, ImmutableGroup`2<TObject, TGroupKey> right);
    public sealed virtual bool Equals(ImmutableGroup`2<TObject, TGroupKey> other);
    [NullableContextAttribute("2")]
public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public virtual string ToString();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class DynamicData.List.Internal.LimitSizeTo`1 : object {
    [CompilerGeneratedAttribute]
private int <sizeLimit>P;
    [CompilerGeneratedAttribute]
private object <locker>P;
    private IScheduler _scheduler;
    private ISourceList`1<T> _sourceList;
    public LimitSizeTo`1(ISourceList`1<T> sourceList, int sizeLimit, IScheduler scheduler, object locker);
    public IObservable`1<IEnumerable`1<T>> Run();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class DynamicData.List.Internal.MergeChangeSets`1 : object {
    [CompilerGeneratedAttribute]
private IObservable`1<IObservable`1<IChangeSet`1<TObject>>> <source>P;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private IEqualityComparer`1<TObject> <equalityComparer>P;
    public MergeChangeSets`1(IObservable`1<IObservable`1<IChangeSet`1<TObject>>> source, IEqualityComparer`1<TObject> equalityComparer);
    public MergeChangeSets`1(IEnumerable`1<IObservable`1<IChangeSet`1<TObject>>> source, IEqualityComparer`1<TObject> equalityComparer, bool completable, IScheduler scheduler);
    public IObservable`1<IChangeSet`1<TObject>> Run();
    private static IObservable`1<IObservable`1<IChangeSet`1<TObject>>> CreateObservable(IEnumerable`1<IObservable`1<IChangeSet`1<TObject>>> source, bool completable, IScheduler scheduler);
    private Change`1<ClonedListChangeSet`1<TObject>> CreateChange(IObservable`1<IChangeSet`1<TObject>> source, object locker);
    private IObservable`1<IChangeSet`1<ClonedListChangeSet`1<TObject>>> CreateClonedListObservable(IObservable`1<IObservable`1<IChangeSet`1<TObject>>> source, object locker);
    [CompilerGeneratedAttribute]
private IDisposable <Run>b__4_0(IObserver`1<IChangeSet`1<TObject>> observer);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class DynamicData.List.Internal.MergeMany`2 : object {
    private Func`2<T, IObservable`1<TDestination>> _observableSelector;
    private IObservable`1<IChangeSet`1<T>> _source;
    public MergeMany`2(IObservable`1<IChangeSet`1<T>> source, Func`2<T, IObservable`1<TDestination>> observableSelector);
    public IObservable`1<TDestination> Run();
    [CompilerGeneratedAttribute]
private IDisposable <Run>b__3_0(IObserver`1<TDestination> observer);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class DynamicData.List.Internal.MergeManyCacheChangeSets`3 : object {
    [CompilerGeneratedAttribute]
private IObservable`1<IChangeSet`1<TObject>> <source>P;
    [CompilerGeneratedAttribute]
private Func`2<TObject, IObservable`1<IChangeSet`2<TDestination, TDestinationKey>>> <changeSetSelector>P;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private IEqualityComparer`1<TDestination> <equalityComparer>P;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private IComparer`1<TDestination> <comparer>P;
    public MergeManyCacheChangeSets`3(IObservable`1<IChangeSet`1<TObject>> source, Func`2<TObject, IObservable`1<IChangeSet`2<TDestination, TDestinationKey>>> changeSetSelector, IEqualityComparer`1<TDestination> equalityComparer, IComparer`1<TDestination> comparer);
    public IObservable`1<IChangeSet`2<TDestination, TDestinationKey>> Run();
    [CompilerGeneratedAttribute]
private IDisposable <Run>b__5_0(IObserver`1<IChangeSet`2<TDestination, TDestinationKey>> observer);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class DynamicData.List.Internal.MergeManyListChangeSets`2 : object {
    [CompilerGeneratedAttribute]
private IObservable`1<IChangeSet`1<TObject>> <source>P;
    [CompilerGeneratedAttribute]
private Func`2<TObject, IObservable`1<IChangeSet`1<TDestination>>> <selector>P;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private IEqualityComparer`1<TDestination> <equalityComparer>P;
    public MergeManyListChangeSets`2(IObservable`1<IChangeSet`1<TObject>> source, Func`2<TObject, IObservable`1<IChangeSet`1<TDestination>>> selector, IEqualityComparer`1<TDestination> equalityComparer);
    public IObservable`1<IChangeSet`1<TDestination>> Run();
    [CompilerGeneratedAttribute]
private IDisposable <Run>b__4_0(IObserver`1<IChangeSet`1<TDestination>> observer);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class DynamicData.List.Internal.OnBeingAdded`1 : object {
    private Action`1<T> _callback;
    private IObservable`1<IChangeSet`1<T>> _source;
    public OnBeingAdded`1(IObservable`1<IChangeSet`1<T>> source, Action`1<T> callback);
    public IObservable`1<IChangeSet`1<T>> Run();
    private void RegisterForAddition(IChangeSet`1<T> changes);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class DynamicData.List.Internal.OnBeingRemoved`1 : object {
    [CompilerGeneratedAttribute]
private bool <invokeOnUnsubscribe>P;
    private Action`1<T> _callback;
    private IObservable`1<IChangeSet`1<T>> _source;
    public OnBeingRemoved`1(IObservable`1<IChangeSet`1<T>> source, Action`1<T> callback, bool invokeOnUnsubscribe);
    public IObservable`1<IChangeSet`1<T>> Run();
    private void RegisterForRemoval(IList`1<T> items, IChangeSet`1<T> changes);
    [CompilerGeneratedAttribute]
private IDisposable <Run>b__4_0(IObserver`1<IChangeSet`1<T>> observer);
    [CompilerGeneratedAttribute]
private void <Run>b__4_3(T t);
    [CompilerGeneratedAttribute]
private void <RegisterForRemoval>b__5_0(T t);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class DynamicData.List.Internal.Pager`1 : object {
    private IObservable`1<IPageRequest> _requests;
    private IObservable`1<IChangeSet`1<T>> _source;
    public Pager`1(IObservable`1<IChangeSet`1<T>> source, IObservable`1<IPageRequest> requests);
    public IObservable`1<IPageChangeSet`1<T>> Run();
    private static int CalculatePages(ICollection all, IPageRequest request);
    private static PageChangeSet`1<T> CheckParametersAndPage(List`1<T> all, ChangeAwareList`1<T> paged, IPageRequest request);
    private static PageChangeSet`1<T> Page(List`1<T> all, ChangeAwareList`1<T> paged, IPageRequest request, IChangeSet`1<T> changeSet);
    [CompilerGeneratedAttribute]
private IDisposable <Run>b__3_0(IObserver`1<IPageChangeSet`1<T>> observer);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class DynamicData.List.Internal.QueryWhenChanged`1 : object {
    private IObservable`1<IChangeSet`1<T>> _source;
    public QueryWhenChanged`1(IObservable`1<IChangeSet`1<T>> source);
    public IObservable`1<IReadOnlyCollection`1<T>> Run();
    [CompilerGeneratedAttribute]
private IDisposable <Run>b__2_0(IObserver`1<IReadOnlyCollection`1<T>> observer);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class DynamicData.List.Internal.ReaderWriter`1 : object {
    private object _locker;
    private ChangeAwareList`1<T> _data;
    private bool _updateInProgress;
    public int Count { get; }
    public T[] Items { get; }
    public int get_Count();
    public T[] get_Items();
    public IChangeSet`1<T> Write(IChangeSet`1<T> changes);
    public IChangeSet`1<T> Write(Action`1<IExtendedList`1<T>> updateAction);
    public void WriteNested(Action`1<IExtendedList`1<T>> updateAction);
    public IChangeSet`1<T> WriteWithPreview(Action`1<IExtendedList`1<T>> updateAction, Action`1<IChangeSet`1<T>> previewHandler);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class DynamicData.List.Internal.RefCount`1 : object {
    [CompilerGeneratedAttribute]
private IObservable`1<IChangeSet`1<T>> <source>P;
    private object _locker;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private IObservableList`1<T> _list;
    private int _refCount;
    public RefCount`1(IObservable`1<IChangeSet`1<T>> source);
    public IObservable`1<IChangeSet`1<T>> Run();
    [CompilerGeneratedAttribute]
private IDisposable <Run>b__5_0(IObserver`1<IChangeSet`1<T>> observer);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[DefaultMemberAttribute("Item")]
internal class DynamicData.List.Internal.ReferenceCountTracker`1 : object {
    [CompilerGeneratedAttribute]
private Dictionary`2<T, int> <ReferenceCounts>k__BackingField;
    public IEnumerable`1<T> Items { get; }
    private Dictionary`2<T, int> ReferenceCounts { get; }
    public int Item { get; }
    public IEnumerable`1<T> get_Items();
    [CompilerGeneratedAttribute]
private Dictionary`2<T, int> get_ReferenceCounts();
    public int get_Item(T item);
    public bool Add(T item);
    public void Clear();
    public bool Contains(T item);
    public bool Remove(T item);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class DynamicData.List.Internal.Sort`1 : object {
    [CompilerGeneratedAttribute]
private SortOptions <sortOptions>P;
    [CompilerGeneratedAttribute]
private int <resetThreshold>P;
    private IObservable`1<IComparer`1<T>> _comparerObservable;
    private IObservable`1<Unit> _resort;
    private IObservable`1<IChangeSet`1<T>> _source;
    private IComparer`1<T> _comparer;
    public Sort`1(IObservable`1<IChangeSet`1<T>> source, IComparer`1<T> comparer, SortOptions sortOptions, IObservable`1<Unit> resort, IObservable`1<IComparer`1<T>> comparerObservable, int resetThreshold);
    public IObservable`1<IChangeSet`1<T>> Run();
    private IChangeSet`1<T> ChangeComparer(ChangeAwareList`1<T> target, IComparer`1<T> comparer);
    private int GetCurrentPosition(ChangeAwareList`1<T> target, T item);
    private int GetInsertPosition(ChangeAwareList`1<T> target, T item);
    private int GetInsertPositionBinary(ChangeAwareList`1<T> target, T item);
    private int GetInsertPositionLinear(ChangeAwareList`1<T> target, T item);
    private void Insert(ChangeAwareList`1<T> target, T item);
    private IChangeSet`1<T> Process(ChangeAwareList`1<T> target, IChangeSet`1<T> changes);
    private IChangeSet`1<T> ProcessImpl(ChangeAwareList`1<T> target, IChangeSet`1<T> changes);
    private void Remove(ChangeAwareList`1<T> target, T item);
    private IChangeSet`1<T> Reorder(ChangeAwareList`1<T> target);
    private IChangeSet`1<T> Reset(List`1<T> original, ChangeAwareList`1<T> target);
    [CompilerGeneratedAttribute]
private IDisposable <Run>b__7_0(IObserver`1<IChangeSet`1<T>> observer);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class DynamicData.List.Internal.SubscribeMany`1 : object {
    private IObservable`1<IChangeSet`1<T>> _source;
    private Func`2<T, IDisposable> _subscriptionFactory;
    public SubscribeMany`1(IObservable`1<IChangeSet`1<T>> source, Func`2<T, IDisposable> subscriptionFactory);
    public IObservable`1<IChangeSet`1<T>> Run();
    [CompilerGeneratedAttribute]
private IDisposable <Run>b__3_0(IObserver`1<IChangeSet`1<T>> observer);
    [CompilerGeneratedAttribute]
private IDisposable <Run>b__3_1(T t);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class DynamicData.List.Internal.Switch`1 : object {
    private IObservable`1<IObservable`1<IChangeSet`1<T>>> _sources;
    public Switch`1(IObservable`1<IObservable`1<IChangeSet`1<T>>> sources);
    public IObservable`1<IChangeSet`1<T>> Run();
    [CompilerGeneratedAttribute]
private IDisposable <Run>b__2_0(IObserver`1<IChangeSet`1<T>> observer);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class DynamicData.List.Internal.ToObservableChangeSet`1 : object {
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private Func`2<TObject, Nullable`1<TimeSpan>> _expireAfter;
    private int _limitSizeTo;
    private IScheduler _scheduler;
    private IObservable`1<IEnumerable`1<TObject>> _source;
    public ToObservableChangeSet`1(IObservable`1<TObject> source, Func`2<TObject, Nullable`1<TimeSpan>> expireAfter, int limitSizeTo, IScheduler scheduler);
    public ToObservableChangeSet`1(IObservable`1<IEnumerable`1<TObject>> source, Func`2<TObject, Nullable`1<TimeSpan>> expireAfter, int limitSizeTo, IScheduler scheduler);
    public IObservable`1<IChangeSet`1<TObject>> Run();
    [CompilerGeneratedAttribute]
private IDisposable <Run>b__6_0(IObserver`1<IChangeSet`1<TObject>> observer);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class DynamicData.List.Internal.TransformAsync`2 : object {
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private Func`4<TSource, Optional`1<TDestination>, int, Task`1<TransformedItemContainer<TSource, TDestination>>> _containerFactory;
    private IObservable`1<IChangeSet`1<TSource>> _source;
    private bool _transformOnRefresh;
    public TransformAsync`2(IObservable`1<IChangeSet`1<TSource>> source, Func`4<TSource, Optional`1<TDestination>, int, Task`1<TDestination>> factory, bool transformOnRefresh);
    public IObservable`1<IChangeSet`1<TDestination>> Run();
    private IObservable`1<IChangeSet`1<TDestination>> RunImpl();
    [AsyncStateMachineAttribute("DynamicData.List.Internal.TransformAsync`2/<Transform>d__6")]
private Task Transform(ChangeAwareList`1<TransformedItemContainer<TSource, TDestination>> transformed, IChangeSet`1<TSource> changes);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class DynamicData.List.Internal.Transformer`2 : object {
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private Func`4<TSource, Optional`1<TDestination>, int, TransformedItemContainer<TSource, TDestination>> _containerFactory;
    private IObservable`1<IChangeSet`1<TSource>> _source;
    private bool _transformOnRefresh;
    public Transformer`2(IObservable`1<IChangeSet`1<TSource>> source, Func`4<TSource, Optional`1<TDestination>, int, TDestination> factory, bool transformOnRefresh);
    public IObservable`1<IChangeSet`1<TDestination>> Run();
    private IObservable`1<IChangeSet`1<TDestination>> RunImpl();
    private void Transform(ChangeAwareList`1<TransformedItemContainer<TSource, TDestination>> transformed, IChangeSet`1<TSource> changes);
    [NullableContextAttribute("0")]
[CompilerGeneratedAttribute]
private ChangeAwareList`1<TransformedItemContainer<TSource, TDestination>> <RunImpl>b__5_0(ChangeAwareList`1<TransformedItemContainer<TSource, TDestination>> state, IChangeSet`1<TSource> changes);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class DynamicData.List.Internal.TransformMany`2 : object {
    [CompilerGeneratedAttribute]
private Func`2<TSource, IEnumerable`1<TDestination>> <manySelector>P;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private Func`2<TSource, IObservable`1<IChangeSet`1<TDestination>>> <childChanges>P;
    private IEqualityComparer`1<TDestination> _equalityComparer;
    private IObservable`1<IChangeSet`1<TSource>> _source;
    public TransformMany`2(IObservable`1<IChangeSet`1<TSource>> source, Func`2<TSource, IEnumerable`1<TDestination>> manySelector, IEqualityComparer`1<TDestination> equalityComparer, Func`2<TSource, IObservable`1<IChangeSet`1<TDestination>>> childChanges);
    public TransformMany`2(IObservable`1<IChangeSet`1<TSource>> source, Func`2<TSource, ReadOnlyObservableCollection`1<TDestination>> manySelector, IEqualityComparer`1<TDestination> equalityComparer);
    public TransformMany`2(IObservable`1<IChangeSet`1<TSource>> source, Func`2<TSource, ObservableCollection`1<TDestination>> manySelector, IEqualityComparer`1<TDestination> equalityComparer);
    public TransformMany`2(IObservable`1<IChangeSet`1<TSource>> source, Func`2<TSource, IObservableList`1<TDestination>> manySelector, IEqualityComparer`1<TDestination> equalityComparer);
    public IObservable`1<IChangeSet`1<TDestination>> Run();
    private IObservable`1<IChangeSet`1<TDestination>> CreateWithChangeSet();
    [CompilerGeneratedAttribute]
private IDisposable <Run>b__8_0(IObserver`1<IChangeSet`1<TDestination>> observer);
    [CompilerGeneratedAttribute]
private ManyContainer<TSource, TDestination> <Run>b__8_1(TSource item);
    [CompilerGeneratedAttribute]
private IDisposable <CreateWithChangeSet>b__9_0(IObserver`1<IChangeSet`1<TDestination>> observer);
    [CompilerGeneratedAttribute]
private ManyContainer<TSource, TDestination> <CreateWithChangeSet>b__9_1(TSource t);
    [NullableContextAttribute("0")]
[CompilerGeneratedAttribute]
private ChangeSet`1<TDestination> <CreateWithChangeSet>b__9_2(IChangeSet`1<ManyContainer<TSource, TDestination>> changes);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[IsReadOnlyAttribute]
internal class DynamicData.List.Internal.UnifiedChange`1 : ValueType {
    [CompilerGeneratedAttribute]
private ListChangeReason <Reason>k__BackingField;
    [CompilerGeneratedAttribute]
private T <Current>k__BackingField;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private Optional`1<T> <Previous>k__BackingField;
    public ListChangeReason Reason { get; }
    public T Current { get; }
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public Optional`1<T> Previous { get; }
    public UnifiedChange`1(ListChangeReason reason, T current, Optional`1<T> previous);
    public UnifiedChange`1(ListChangeReason reason, T current);
    [CompilerGeneratedAttribute]
public ListChangeReason get_Reason();
    [CompilerGeneratedAttribute]
public T get_Current();
    [CompilerGeneratedAttribute]
public Optional`1<T> get_Previous();
    public static bool op_Equality(UnifiedChange`1& left, UnifiedChange`1& right);
    public static bool op_Inequality(UnifiedChange`1& left, UnifiedChange`1& right);
    public sealed virtual bool Equals(UnifiedChange`1<T> other);
    [NullableContextAttribute("2")]
public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public virtual string ToString();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class DynamicData.List.Internal.Virtualiser`1 : object {
    private IObservable`1<IVirtualRequest> _requests;
    private IObservable`1<IChangeSet`1<T>> _source;
    public Virtualiser`1(IObservable`1<IChangeSet`1<T>> source, IObservable`1<IVirtualRequest> requests);
    public IObservable`1<IVirtualChangeSet`1<T>> Run();
    private static IChangeSet`1<T> CheckParamsAndVirtualise(IList`1<T> all, ChangeAwareList`1<T> virtualised, IVirtualRequest request);
    private static IChangeSet`1<T> Virtualise(IList`1<T> all, ChangeAwareList`1<T> virtualised, IVirtualRequest request, IChangeSet`1<T> changeSet);
    [CompilerGeneratedAttribute]
private IDisposable <Run>b__3_0(IObserver`1<IVirtualChangeSet`1<T>> observer);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class DynamicData.List.Linq.AddKeyEnumerator`2 : object {
    private Func`2<TObject, TKey> _keySelector;
    private IChangeSet`1<TObject> _source;
    public AddKeyEnumerator`2(IChangeSet`1<TObject> source, Func`2<TObject, TKey> keySelector);
    [IteratorStateMachineAttribute("DynamicData.List.Linq.AddKeyEnumerator`2/<GetEnumerator>d__3")]
public sealed virtual IEnumerator`1<Change`2<TObject, TKey>> GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class DynamicData.List.Linq.ItemChangeEnumerator`1 : object {
    [CompilerGeneratedAttribute]
private IChangeSet`1<T> <changeSet>P;
    public ItemChangeEnumerator`1(IChangeSet`1<T> changeSet);
    [IteratorStateMachineAttribute("DynamicData.List.Linq.ItemChangeEnumerator`1/<GetEnumerator>d__2")]
public sealed virtual IEnumerator`1<ItemChange`1<T>> GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class DynamicData.List.Linq.Reverser`1 : object {
    private int _length;
    [IteratorStateMachineAttribute("DynamicData.List.Linq.Reverser`1/<Reverse>d__1")]
public IEnumerable`1<Change`1<T>> Reverse(IChangeSet`1<T> changes);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class DynamicData.List.Linq.UnifiedChangeEnumerator`1 : object {
    [CompilerGeneratedAttribute]
private IChangeSet`1<T> <changeSet>P;
    public UnifiedChangeEnumerator`1(IChangeSet`1<T> changeSet);
    [IteratorStateMachineAttribute("DynamicData.List.Linq.UnifiedChangeEnumerator`1/<GetEnumerator>d__2")]
public sealed virtual IEnumerator`1<UnifiedChange`1<T>> GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class DynamicData.List.Linq.WithoutIndexEnumerator`1 : object {
    [CompilerGeneratedAttribute]
private IEnumerable`1<Change`1<T>> <changeSet>P;
    public WithoutIndexEnumerator`1(IEnumerable`1<Change`1<T>> changeSet);
    [IteratorStateMachineAttribute("DynamicData.List.Linq.WithoutIndexEnumerator`1/<GetEnumerator>d__2")]
public sealed virtual IEnumerator`1<Change`1<T>> GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
}
public enum DynamicData.ListChangeReason : Enum {
    public int value__;
    public static ListChangeReason Add;
    public static ListChangeReason AddRange;
    public static ListChangeReason Replace;
    public static ListChangeReason Remove;
    public static ListChangeReason RemoveRange;
    public static ListChangeReason Refresh;
    public static ListChangeReason Moved;
    public static ListChangeReason Clear;
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
public static class DynamicData.ListEx : object {
    [ExtensionAttribute]
public static void Add(IList`1<T> source, IEnumerable`1<T> items);
    [ExtensionAttribute]
public static void AddOrInsertRange(IList`1<T> source, IEnumerable`1<T> items, int index);
    [ExtensionAttribute]
public static void AddRange(IList`1<T> source, IEnumerable`1<T> items);
    [ExtensionAttribute]
public static void AddRange(IList`1<T> source, IEnumerable`1<T> items, int index);
    [ExtensionAttribute]
public static int BinarySearch(IList`1<TItem> list, TItem value);
    [ExtensionAttribute]
public static int BinarySearch(IList`1<TItem> list, TItem value, IComparer`1<TItem> comparer);
    [ExtensionAttribute]
public static int BinarySearch(IList`1<TItem> list, TSearch value, Func`3<TSearch, TItem, int> comparer);
    [ExtensionAttribute]
public static void Clone(IList`1<T> source, IChangeSet`1<T> changes);
    [ExtensionAttribute]
public static void Clone(IList`1<T> source, IChangeSet`1<T> changes, IEqualityComparer`1<T> equalityComparer);
    [ExtensionAttribute]
public static void Clone(IList`1<T> source, IEnumerable`1<Change`1<T>> changes, IEqualityComparer`1<T> equalityComparer);
    [ExtensionAttribute]
public static int IndexOf(IEnumerable`1<T> source, T item);
    [ExtensionAttribute]
public static int IndexOf(IEnumerable`1<T> source, T item, IEqualityComparer`1<T> equalityComparer);
    [ExtensionAttribute]
public static Optional`1<ItemWithIndex`1<T>> IndexOfOptional(IEnumerable`1<T> source, T item, IEqualityComparer`1<T> equalityComparer);
    [ExtensionAttribute]
public static void Remove(IList`1<T> source, IEnumerable`1<T> items);
    [ExtensionAttribute]
public static void RemoveMany(IList`1<T> source, IEnumerable`1<T> itemsToRemove);
    [ExtensionAttribute]
public static void Replace(IList`1<T> source, T original, T replaceWith);
    [ExtensionAttribute]
public static void Replace(IList`1<T> source, T original, T replaceWith, IEqualityComparer`1<T> comparer);
    [ExtensionAttribute]
public static void ReplaceOrAdd(IList`1<T> source, T original, T replaceWith);
    [ExtensionAttribute]
internal static void ClearOrRemoveMany(IList`1<T> source, Change`1<T> change);
    [ExtensionAttribute]
internal static bool MovedWithinRange(Change`1<T> source, int startIndex, int endIndex);
    [ExtensionAttribute]
private static void Clone(IList`1<T> source, Change`1<T> item, IEqualityComparer`1<T> equalityComparer);
    [ExtensionAttribute]
private static void RemoveRange(IList`1<T> source, int index, int count);
}
public enum DynamicData.ListFilterPolicy : Enum {
    public int value__;
    public static ListFilterPolicy ClearAndReplace;
    public static ListFilterPolicy CalculateDiff;
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class DynamicData.MissingKeyException : Exception {
    public MissingKeyException(string message);
    public MissingKeyException(string message, Exception innerException);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class DynamicData.Node`2 : object {
    private SourceCache`2<Node`2<TObject, TKey>, TKey> _children;
    private CompositeDisposable _cleanUp;
    private bool _isDisposed;
    [CompilerGeneratedAttribute]
private IObservableCache`2<Node`2<TObject, TKey>, TKey> <Children>k__BackingField;
    [CompilerGeneratedAttribute]
private TObject <Item>k__BackingField;
    [CompilerGeneratedAttribute]
private TKey <Key>k__BackingField;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private Optional`1<Node`2<TObject, TKey>> <Parent>k__BackingField;
    public IObservableCache`2<Node`2<TObject, TKey>, TKey> Children { get; }
    public int Depth { get; }
    public bool IsRoot { get; }
    public TObject Item { get; }
    public TKey Key { get; }
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public Optional`1<Node`2<TObject, TKey>> Parent { get; internal set; }
    public Node`2(TObject item, TKey key);
    public Node`2(TObject item, TKey key, Optional`1& parent);
    [CompilerGeneratedAttribute]
public IObservableCache`2<Node`2<TObject, TKey>, TKey> get_Children();
    public int get_Depth();
    public bool get_IsRoot();
    [CompilerGeneratedAttribute]
public TObject get_Item();
    [CompilerGeneratedAttribute]
public TKey get_Key();
    [CompilerGeneratedAttribute]
public Optional`1<Node`2<TObject, TKey>> get_Parent();
    [CompilerGeneratedAttribute]
internal void set_Parent(Optional`1<Node`2<TObject, TKey>> value);
    public static bool op_Equality(Node`2<TObject, TKey> left, Node`2<TObject, TKey> right);
    public static bool op_Inequality(Node`2<TObject, TKey> left, Node`2<TObject, TKey> right);
    public sealed virtual void Dispose();
    public sealed virtual bool Equals(Node`2<TObject, TKey> other);
    [NullableContextAttribute("2")]
public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public virtual string ToString();
    internal void Update(Action`1<ISourceUpdater`2<Node`2<TObject, TKey>, TKey>> updateAction);
    protected virtual void Dispose(bool isDisposing);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[DebuggerDisplayAttribute("ObservableCache<{typeof(TObject).Name}, {typeof(TKey).Name}> ({Count} Items)")]
internal class DynamicData.ObservableCache`2 : object {
    private Subject`1<ChangeSet`2<TObject, TKey>> _changes;
    private Subject`1<ChangeSet`2<TObject, TKey>> _changesPreview;
    private IDisposable _cleanUp;
    private Lazy`1<ISubject`1<int>> _countChanged;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private Lazy`1<SuspensionTracker<TObject, TKey>> _suspensionTracker;
    private object _locker;
    private ReaderWriter`2<TObject, TKey> _readerWriter;
    private int _editLevel;
    public int Count { get; }
    public IObservable`1<int> CountChanged { get; }
    public IReadOnlyList`1<TObject> Items { get; }
    public IReadOnlyList`1<TKey> Keys { get; }
    public IReadOnlyDictionary`2<TKey, TObject> KeyValues { get; }
    public ObservableCache`2(IObservable`1<IChangeSet`2<TObject, TKey>> source);
    public ObservableCache`2(Func`2<TObject, TKey> keySelector);
    public sealed virtual int get_Count();
    public sealed virtual IObservable`1<int> get_CountChanged();
    public sealed virtual IReadOnlyList`1<TObject> get_Items();
    public sealed virtual IReadOnlyList`1<TKey> get_Keys();
    public sealed virtual IReadOnlyDictionary`2<TKey, TObject> get_KeyValues();
    public sealed virtual IObservable`1<IChangeSet`2<TObject, TKey>> Connect(Func`2<TObject, bool> predicate, bool suppressEmptyChangeSets);
    public sealed virtual void Dispose();
    public sealed virtual Optional`1<TObject> Lookup(TKey key);
    public sealed virtual IObservable`1<IChangeSet`2<TObject, TKey>> Preview(Func`2<TObject, bool> predicate);
    public sealed virtual IObservable`1<Change`2<TObject, TKey>> Watch(TKey key);
    public sealed virtual IDisposable SuspendCount();
    public sealed virtual IDisposable SuspendNotifications();
    internal ChangeSet`2<TObject, TKey> GetInitialUpdates(Func`2<TObject, bool> filter);
    internal void UpdateFromIntermediate(Action`1<ICacheUpdater`2<TObject, TKey>> updateAction);
    internal void UpdateFromSource(Action`1<ISourceUpdater`2<TObject, TKey>> updateAction);
    private IObservable`1<IChangeSet`2<TObject, TKey>> CreateConnectObservable(Func`2<TObject, bool> predicate, bool suppressEmptyChangeSets);
    private IObservable`1<Change`2<TObject, TKey>> CreateWatchObservable(TKey key);
    private void InvokeNext(ChangeSet`2<TObject, TKey> changes);
    private void InvokePreview(ChangeSet`2<TObject, TKey> changes);
    private void InvokeCountNext();
    private void ResumeCount();
    private void ResumeNotifications();
    [CompilerGeneratedAttribute]
private SuspensionTracker<TObject, TKey> <.ctor>b__8_0();
    [CompilerGeneratedAttribute]
private void <.ctor>b__8_1();
    [NullableContextAttribute("0")]
[CompilerGeneratedAttribute]
private void <.ctor>b__8_2(IChangeSet`2<TObject, TKey> changeSet);
    [CompilerGeneratedAttribute]
private void <.ctor>b__8_3(Exception ex);
    [CompilerGeneratedAttribute]
private SuspensionTracker<TObject, TKey> <.ctor>b__9_0();
    [CompilerGeneratedAttribute]
private void <.ctor>b__9_1();
    [CompilerGeneratedAttribute]
private IDisposable <get_CountChanged>b__13_0(IObserver`1<int> observer);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
public static class DynamicData.ObservableCacheEx : object {
    private static int DefaultSortResetThreshold;
    private static bool DefaultResortOnSourceRefresh;
    [ExtensionAttribute]
public static IObservable`1<IChangeSet`2<TObject, TKey>> Adapt(IObservable`1<IChangeSet`2<TObject, TKey>> source, IChangeSetAdaptor`2<TObject, TKey> adaptor);
    [ExtensionAttribute]
public static IObservable`1<IChangeSet`2<TObject, TKey>> Adapt(IObservable`1<ISortedChangeSet`2<TObject, TKey>> source, ISortedChangeSetAdaptor`2<TObject, TKey> adaptor);
    [ExtensionAttribute]
public static void AddOrUpdate(ISourceCache`2<TObject, TKey> source, TObject item);
    [ExtensionAttribute]
public static void AddOrUpdate(ISourceCache`2<TObject, TKey> source, TObject item, IEqualityComparer`1<TObject> equalityComparer);
    [ExtensionAttribute]
public static void AddOrUpdate(ISourceCache`2<TObject, TKey> source, IEnumerable`1<TObject> items);
    [ExtensionAttribute]
public static void AddOrUpdate(ISourceCache`2<TObject, TKey> source, IEnumerable`1<TObject> items, IEqualityComparer`1<TObject> equalityComparer);
    [ExtensionAttribute]
public static void AddOrUpdate(IIntermediateCache`2<TObject, TKey> source, TObject item, TKey key);
    [ExtensionAttribute]
public static IObservable`1<IChangeSet`2<TObject, TKey>> And(IObservable`1<IChangeSet`2<TObject, TKey>> source, IObservable`1[] others);
    [ExtensionAttribute]
public static IObservable`1<IChangeSet`2<TObject, TKey>> And(ICollection`1<IObservable`1<IChangeSet`2<TObject, TKey>>> sources);
    [ExtensionAttribute]
public static IObservable`1<IChangeSet`2<TObject, TKey>> And(IObservableList`1<IObservable`1<IChangeSet`2<TObject, TKey>>> sources);
    [ExtensionAttribute]
public static IObservable`1<IChangeSet`2<TObject, TKey>> And(IObservableList`1<IObservableCache`2<TObject, TKey>> sources);
    [ExtensionAttribute]
public static IObservable`1<IChangeSet`2<TObject, TKey>> And(IObservableList`1<ISourceCache`2<TObject, TKey>> sources);
    [ExtensionAttribute]
public static IObservableCache`2<TObject, TKey> AsObservableCache(IObservableCache`2<TObject, TKey> source);
    [ExtensionAttribute]
public static IObservableCache`2<TObject, TKey> AsObservableCache(IObservable`1<IChangeSet`2<TObject, TKey>> source, bool applyLocking);
    [ExtensionAttribute]
public static IObservable`1<IChangeSet`2<TObject, TKey>> AutoRefresh(IObservable`1<IChangeSet`2<TObject, TKey>> source, Nullable`1<TimeSpan> changeSetBuffer, Nullable`1<TimeSpan> propertyChangeThrottle, IScheduler scheduler);
    [ExtensionAttribute]
public static IObservable`1<IChangeSet`2<TObject, TKey>> AutoRefresh(IObservable`1<IChangeSet`2<TObject, TKey>> source, Expression`1<Func`2<TObject, TProperty>> propertyAccessor, Nullable`1<TimeSpan> changeSetBuffer, Nullable`1<TimeSpan> propertyChangeThrottle, IScheduler scheduler);
    [ExtensionAttribute]
public static IObservable`1<IChangeSet`2<TObject, TKey>> AutoRefreshOnObservable(IObservable`1<IChangeSet`2<TObject, TKey>> source, Func`2<TObject, IObservable`1<TAny>> reevaluator, Nullable`1<TimeSpan> changeSetBuffer, IScheduler scheduler);
    [ExtensionAttribute]
public static IObservable`1<IChangeSet`2<TObject, TKey>> AutoRefreshOnObservable(IObservable`1<IChangeSet`2<TObject, TKey>> source, Func`3<TObject, TKey, IObservable`1<TAny>> reevaluator, Nullable`1<TimeSpan> changeSetBuffer, IScheduler scheduler);
    [ExtensionAttribute]
public static IObservable`1<IChangeSet`2<TObject, TKey>> Batch(IObservable`1<IChangeSet`2<TObject, TKey>> source, TimeSpan timeSpan, IScheduler scheduler);
    [ExtensionAttribute]
public static IObservable`1<IChangeSet`2<TObject, TKey>> BatchIf(IObservable`1<IChangeSet`2<TObject, TKey>> source, IObservable`1<bool> pauseIfTrueSelector, IScheduler scheduler);
    [ExtensionAttribute]
public static IObservable`1<IChangeSet`2<TObject, TKey>> BatchIf(IObservable`1<IChangeSet`2<TObject, TKey>> source, IObservable`1<bool> pauseIfTrueSelector, bool initialPauseState, IScheduler scheduler);
    [ExtensionAttribute]
public static IObservable`1<IChangeSet`2<TObject, TKey>> BatchIf(IObservable`1<IChangeSet`2<TObject, TKey>> source, IObservable`1<bool> pauseIfTrueSelector, Nullable`1<TimeSpan> timeOut, IScheduler scheduler);
    [ExtensionAttribute]
public static IObservable`1<IChangeSet`2<TObject, TKey>> BatchIf(IObservable`1<IChangeSet`2<TObject, TKey>> source, IObservable`1<bool> pauseIfTrueSelector, bool initialPauseState, Nullable`1<TimeSpan> timeOut, IScheduler scheduler);
    [ExtensionAttribute]
public static IObservable`1<IChangeSet`2<TObject, TKey>> BatchIf(IObservable`1<IChangeSet`2<TObject, TKey>> source, IObservable`1<bool> pauseIfTrueSelector, bool initialPauseState, IObservable`1<Unit> timer, IScheduler scheduler);
    [ExtensionAttribute]
public static IObservable`1<IChangeSet`2<TObject, TKey>> Bind(IObservable`1<IChangeSet`2<TObject, TKey>> source, IObservableCollection`1<TObject> destination, int refreshThreshold);
    [ExtensionAttribute]
public static IObservable`1<IChangeSet`2<TObject, TKey>> Bind(IObservable`1<IChangeSet`2<TObject, TKey>> source, IObservableCollection`1<TObject> destination, BindingOptions options);
    [ExtensionAttribute]
public static IObservable`1<IChangeSet`2<TObject, TKey>> Bind(IObservable`1<IChangeSet`2<TObject, TKey>> source, IObservableCollection`1<TObject> destination, IObservableCollectionAdaptor`2<TObject, TKey> updater);
    [ExtensionAttribute]
public static IObservable`1<IChangeSet`2<TObject, TKey>> Bind(IObservable`1<IChangeSet`2<TObject, TKey>> source, ReadOnlyObservableCollection`1& readOnlyObservableCollection, BindingOptions options);
    [ExtensionAttribute]
public static IObservable`1<IChangeSet`2<TObject, TKey>> Bind(IObservable`1<IChangeSet`2<TObject, TKey>> source, ReadOnlyObservableCollection`1& readOnlyObservableCollection, int resetThreshold, bool useReplaceForUpdates, IObservableCollectionAdaptor`2<TObject, TKey> adaptor);
    [ExtensionAttribute]
public static IObservable`1<ISortedChangeSet`2<TObject, TKey>> Bind(IObservable`1<ISortedChangeSet`2<TObject, TKey>> source, IObservableCollection`1<TObject> destination);
    [ExtensionAttribute]
public static IObservable`1<ISortedChangeSet`2<TObject, TKey>> Bind(IObservable`1<ISortedChangeSet`2<TObject, TKey>> source, IObservableCollection`1<TObject> destination, BindingOptions options);
    [ExtensionAttribute]
public static IObservable`1<ISortedChangeSet`2<TObject, TKey>> Bind(IObservable`1<ISortedChangeSet`2<TObject, TKey>> source, IObservableCollection`1<TObject> destination, ISortedObservableCollectionAdaptor`2<TObject, TKey> updater);
    [ExtensionAttribute]
public static IObservable`1<IChangeSet`2<TObject, TKey>> Bind(IObservable`1<ISortedChangeSet`2<TObject, TKey>> source, ReadOnlyObservableCollection`1& readOnlyObservableCollection, BindingOptions options);
    [ExtensionAttribute]
public static IObservable`1<IChangeSet`2<TObject, TKey>> Bind(IObservable`1<ISortedChangeSet`2<TObject, TKey>> source, ReadOnlyObservableCollection`1& readOnlyObservableCollection, int resetThreshold, bool useReplaceForUpdates, ISortedObservableCollectionAdaptor`2<TObject, TKey> adaptor);
    [ExtensionAttribute]
public static IObservable`1<IChangeSet`2<TObject, TKey>> Bind(IObservable`1<IChangeSet`2<TObject, TKey>> source, BindingList`1<TObject> bindingList, int resetThreshold);
    [ExtensionAttribute]
public static IObservable`1<IChangeSet`2<TObject, TKey>> Bind(IObservable`1<ISortedChangeSet`2<TObject, TKey>> source, BindingList`1<TObject> bindingList, int resetThreshold);
    [ExtensionAttribute]
public static IObservable`1<IChangeSet`2<TObject, TKey>> BufferInitial(IObservable`1<IChangeSet`2<TObject, TKey>> source, TimeSpan initialBuffer, IScheduler scheduler);
    [ExtensionAttribute]
public static IObservable`1<IChangeSet`2<TDestination, TKey>> Cast(IObservable`1<IChangeSet`2<TSource, TKey>> source, Func`2<TSource, TDestination> converter);
    [ExtensionAttribute]
public static IObservable`1<IChangeSet`2<TObject, TDestinationKey>> ChangeKey(IObservable`1<IChangeSet`2<TObject, TSourceKey>> source, Func`2<TObject, TDestinationKey> keySelector);
    [ExtensionAttribute]
public static IObservable`1<IChangeSet`2<TObject, TDestinationKey>> ChangeKey(IObservable`1<IChangeSet`2<TObject, TSourceKey>> source, Func`3<TSourceKey, TObject, TDestinationKey> keySelector);
    [ExtensionAttribute]
public static void Clear(ISourceCache`2<TObject, TKey> source);
    [ExtensionAttribute]
public static void Clear(IIntermediateCache`2<TObject, TKey> source);
    [ExtensionAttribute]
public static void Clear(LockFreeObservableCache`2<TObject, TKey> source);
    [ExtensionAttribute]
public static IObservable`1<IChangeSet`2<TObject, TKey>> Clone(IObservable`1<IChangeSet`2<TObject, TKey>> source, ICollection`1<TObject> target);
    [ExtensionAttribute]
[ObsoleteAttribute("This was an experiment that did not work. Use Transform instead")]
public static IObservable`1<IChangeSet`2<TDestination, TKey>> Convert(IObservable`1<IChangeSet`2<TObject, TKey>> source, Func`2<TObject, TDestination> conversionFactory);
    [ExtensionAttribute]
public static IObservable`1<IChangeSet`2<TObject, TKey>> DeferUntilLoaded(IObservable`1<IChangeSet`2<TObject, TKey>> source);
    [ExtensionAttribute]
public static IObservable`1<IChangeSet`2<TObject, TKey>> DeferUntilLoaded(IObservableCache`2<TObject, TKey> source);
    [ExtensionAttribute]
public static IObservable`1<IChangeSet`2<TObject, TKey>> DisposeMany(IObservable`1<IChangeSet`2<TObject, TKey>> source);
    [ExtensionAttribute]
public static IObservable`1<IDistinctChangeSet`1<TValue>> DistinctValues(IObservable`1<IChangeSet`2<TObject, TKey>> source, Func`2<TObject, TValue> valueSelector);
    [ExtensionAttribute]
public static void EditDiff(ISourceCache`2<TObject, TKey> source, IEnumerable`1<TObject> allItems, IEqualityComparer`1<TObject> equalityComparer);
    [ExtensionAttribute]
public static void EditDiff(ISourceCache`2<TObject, TKey> source, IEnumerable`1<TObject> allItems, Func`3<TObject, TObject, bool> areItemsEqual);
    [ExtensionAttribute]
public static IObservable`1<IChangeSet`2<TObject, TKey>> EditDiff(IObservable`1<IEnumerable`1<TObject>> source, Func`2<TObject, TKey> keySelector, IEqualityComparer`1<TObject> equalityComparer);
    [ExtensionAttribute]
public static IObservable`1<IChangeSet`2<TObject, TKey>> EditDiff(IObservable`1<Optional`1<TObject>> source, Func`2<TObject, TKey> keySelector, IEqualityComparer`1<TObject> equalityComparer);
    [ExtensionAttribute]
public static IObservable`1<IChangeSet`2<TObject, TKey>> EnsureUniqueKeys(IObservable`1<IChangeSet`2<TObject, TKey>> source);
    [ExtensionAttribute]
public static IObservable`1<IChangeSet`2<TObject, TKey>> Except(IObservable`1<IChangeSet`2<TObject, TKey>> source, IObservable`1[] others);
    [ExtensionAttribute]
public static IObservable`1<IChangeSet`2<TObject, TKey>> Except(ICollection`1<IObservable`1<IChangeSet`2<TObject, TKey>>> sources);
    [ExtensionAttribute]
public static IObservable`1<IChangeSet`2<TObject, TKey>> Except(IObservableList`1<IObservable`1<IChangeSet`2<TObject, TKey>>> sources);
    [ExtensionAttribute]
public static IObservable`1<IChangeSet`2<TObject, TKey>> Except(IObservableList`1<IObservableCache`2<TObject, TKey>> sources);
    [ExtensionAttribute]
public static IObservable`1<IChangeSet`2<TObject, TKey>> Except(IObservableList`1<ISourceCache`2<TObject, TKey>> sources);
    [ExtensionAttribute]
public static IObservable`1<IChangeSet`2<TObject, TKey>> ExpireAfter(IObservable`1<IChangeSet`2<TObject, TKey>> source, Func`2<TObject, Nullable`1<TimeSpan>> timeSelector);
    [ExtensionAttribute]
public static IObservable`1<IChangeSet`2<TObject, TKey>> ExpireAfter(IObservable`1<IChangeSet`2<TObject, TKey>> source, Func`2<TObject, Nullable`1<TimeSpan>> timeSelector, IScheduler scheduler);
    [ExtensionAttribute]
public static IObservable`1<IChangeSet`2<TObject, TKey>> ExpireAfter(IObservable`1<IChangeSet`2<TObject, TKey>> source, Func`2<TObject, Nullable`1<TimeSpan>> timeSelector, Nullable`1<TimeSpan> pollingInterval);
    [ExtensionAttribute]
public static IObservable`1<IChangeSet`2<TObject, TKey>> ExpireAfter(IObservable`1<IChangeSet`2<TObject, TKey>> source, Func`2<TObject, Nullable`1<TimeSpan>> timeSelector, Nullable`1<TimeSpan> pollingInterval, IScheduler scheduler);
    [ExtensionAttribute]
public static IObservable`1<IEnumerable`1<KeyValuePair`2<TKey, TObject>>> ExpireAfter(ISourceCache`2<TObject, TKey> source, Func`2<TObject, Nullable`1<TimeSpan>> timeSelector, Nullable`1<TimeSpan> pollingInterval, IScheduler scheduler);
    [ExtensionAttribute]
public static IObservable`1<IChangeSet`2<TObject, TKey>> Filter(IObservable`1<IChangeSet`2<TObject, TKey>> source, Func`2<TObject, bool> filter, bool suppressEmptyChangeSets);
    [ExtensionAttribute]
public static IObservable`1<IChangeSet`2<TObject, TKey>> Filter(IObservable`1<IChangeSet`2<TObject, TKey>> source, IObservable`1<Func`2<TObject, bool>> predicateChanged, bool suppressEmptyChangeSets);
    [ExtensionAttribute]
public static IObservable`1<IChangeSet`2<TObject, TKey>> Filter(IObservable`1<IChangeSet`2<TObject, TKey>> source, IObservable`1<Unit> reapplyFilter, bool suppressEmptyChangeSets);
    [ExtensionAttribute]
public static IObservable`1<IChangeSet`2<TObject, TKey>> Filter(IObservable`1<IChangeSet`2<TObject, TKey>> source, IObservable`1<Func`2<TObject, bool>> predicateChanged, IObservable`1<Unit> reapplyFilter, bool suppressEmptyChangeSets);
    [ExtensionAttribute]
public static IObservable`1<IChangeSet`2<TObject, TKey>> FilterImmutable(IObservable`1<IChangeSet`2<TObject, TKey>> source, Func`2<TObject, bool> predicate, bool suppressEmptyChangeSets);
    [ExtensionAttribute]
public static IObservable`1<IChangeSet`2<TObject, TKey>> FilterOnObservable(IObservable`1<IChangeSet`2<TObject, TKey>> source, Func`3<TObject, TKey, IObservable`1<bool>> filterFactory, Nullable`1<TimeSpan> buffer, IScheduler scheduler);
    [ExtensionAttribute]
public static IObservable`1<IChangeSet`2<TObject, TKey>> FilterOnObservable(IObservable`1<IChangeSet`2<TObject, TKey>> source, Func`2<TObject, IObservable`1<bool>> filterFactory, Nullable`1<TimeSpan> buffer, IScheduler scheduler);
    [ExtensionAttribute]
[ObsoleteAttribute("Use AutoRefresh(), followed by Filter() instead")]
public static IObservable`1<IChangeSet`2<TObject, TKey>> FilterOnProperty(IObservable`1<IChangeSet`2<TObject, TKey>> source, Expression`1<Func`2<TObject, TProperty>> propertySelector, Func`2<TObject, bool> predicate, Nullable`1<TimeSpan> propertyChangedThrottle, IScheduler scheduler);
    [ExtensionAttribute]
[ObsoleteAttribute("This can cause unhandled exception issues so do not use")]
public static IObservable`1<T> FinallySafe(IObservable`1<T> source, Action finallyAction);
    [ExtensionAttribute]
public static IObservable`1<Change`2<TObject, TKey>> Flatten(IObservable`1<IChangeSet`2<TObject, TKey>> source);
    [ExtensionAttribute]
public static IObservable`1<IChangeSet`2<TObject, TKey>> FlattenBufferResult(IObservable`1<IList`1<IChangeSet`2<TObject, TKey>>> source);
    [ExtensionAttribute]
public static IObservable`1<IChangeSet`2<TObject, TKey>> ForEachChange(IObservable`1<IChangeSet`2<TObject, TKey>> source, Action`1<Change`2<TObject, TKey>> action);
    [ExtensionAttribute]
public static IObservable`1<IChangeSet`2<TDestination, TLeftKey>> FullJoin(IObservable`1<IChangeSet`2<TLeft, TLeftKey>> left, IObservable`1<IChangeSet`2<TRight, TRightKey>> right, Func`2<TRight, TLeftKey> rightKeySelector, Func`3<Optional`1<TLeft>, Optional`1<TRight>, TDestination> resultSelector);
    [ExtensionAttribute]
public static IObservable`1<IChangeSet`2<TDestination, TLeftKey>> FullJoin(IObservable`1<IChangeSet`2<TLeft, TLeftKey>> left, IObservable`1<IChangeSet`2<TRight, TRightKey>> right, Func`2<TRight, TLeftKey> rightKeySelector, Func`4<TLeftKey, Optional`1<TLeft>, Optional`1<TRight>, TDestination> resultSelector);
    [ExtensionAttribute]
public static IObservable`1<IChangeSet`2<TDestination, TLeftKey>> FullJoinMany(IObservable`1<IChangeSet`2<TLeft, TLeftKey>> left, IObservable`1<IChangeSet`2<TRight, TRightKey>> right, Func`2<TRight, TLeftKey> rightKeySelector, Func`3<Optional`1<TLeft>, IGrouping`3<TRight, TRightKey, TLeftKey>, TDestination> resultSelector);
    [ExtensionAttribute]
public static IObservable`1<IChangeSet`2<TDestination, TLeftKey>> FullJoinMany(IObservable`1<IChangeSet`2<TLeft, TLeftKey>> left, IObservable`1<IChangeSet`2<TRight, TRightKey>> right, Func`2<TRight, TLeftKey> rightKeySelector, Func`4<TLeftKey, Optional`1<TLeft>, IGrouping`3<TRight, TRightKey, TLeftKey>, TDestination> resultSelector);
    [ExtensionAttribute]
public static IObservable`1<IGroupChangeSet`3<TObject, TKey, TGroupKey>> Group(IObservable`1<IChangeSet`2<TObject, TKey>> source, Func`2<TObject, TGroupKey> groupSelector, IObservable`1<IDistinctChangeSet`1<TGroupKey>> resultGroupSource);
    [ExtensionAttribute]
public static IObservable`1<IGroupChangeSet`3<TObject, TKey, TGroupKey>> Group(IObservable`1<IChangeSet`2<TObject, TKey>> source, Func`2<TObject, TGroupKey> groupSelectorKey);
    [ExtensionAttribute]
public static IObservable`1<IGroupChangeSet`3<TObject, TKey, TGroupKey>> Group(IObservable`1<IChangeSet`2<TObject, TKey>> source, Func`2<TObject, TGroupKey> groupSelectorKey, IObservable`1<Unit> regrouper);
    [ExtensionAttribute]
public static IObservable`1<IGroupChangeSet`3<TObject, TKey, TGroupKey>> Group(IObservable`1<IChangeSet`2<TObject, TKey>> source, IObservable`1<Func`3<TObject, TKey, TGroupKey>> groupSelectorKeyObservable, IObservable`1<Unit> regrouper);
    [ExtensionAttribute]
public static IObservable`1<IGroupChangeSet`3<TObject, TKey, TGroupKey>> Group(IObservable`1<IChangeSet`2<TObject, TKey>> source, IObservable`1<Func`2<TObject, TGroupKey>> groupSelectorKeyObservable, IObservable`1<Unit> regrouper);
    [ExtensionAttribute]
public static IObservable`1<IGroupChangeSet`3<TObject, TKey, TGroupKey>> GroupOnObservable(IObservable`1<IChangeSet`2<TObject, TKey>> source, Func`3<TObject, TKey, IObservable`1<TGroupKey>> groupObservableSelector);
    [ExtensionAttribute]
public static IObservable`1<IGroupChangeSet`3<TObject, TKey, TGroupKey>> GroupOnObservable(IObservable`1<IChangeSet`2<TObject, TKey>> source, Func`2<TObject, IObservable`1<TGroupKey>> groupObservableSelector);
    [ExtensionAttribute]
public static IObservable`1<IGroupChangeSet`3<TObject, TKey, TGroupKey>> GroupOnProperty(IObservable`1<IChangeSet`2<TObject, TKey>> source, Expression`1<Func`2<TObject, TGroupKey>> propertySelector, Nullable`1<TimeSpan> propertyChangedThrottle, IScheduler scheduler);
    [ExtensionAttribute]
public static IObservable`1<IImmutableGroupChangeSet`3<TObject, TKey, TGroupKey>> GroupOnPropertyWithImmutableState(IObservable`1<IChangeSet`2<TObject, TKey>> source, Expression`1<Func`2<TObject, TGroupKey>> propertySelector, Nullable`1<TimeSpan> propertyChangedThrottle, IScheduler scheduler);
    [ExtensionAttribute]
public static IObservable`1<IImmutableGroupChangeSet`3<TObject, TKey, TGroupKey>> GroupWithImmutableState(IObservable`1<IChangeSet`2<TObject, TKey>> source, Func`2<TObject, TGroupKey> groupSelectorKey, IObservable`1<Unit> regrouper);
    [ExtensionAttribute]
public static IObservable`1<IChangeSet`2<TObject, TKey>> IgnoreSameReferenceUpdate(IObservable`1<IChangeSet`2<TObject, TKey>> source);
    [ExtensionAttribute]
public static IObservable`1<IChangeSet`2<TObject, TKey>> IgnoreUpdateWhen(IObservable`1<IChangeSet`2<TObject, TKey>> source, Func`3<TObject, TObject, bool> ignoreFunction);
    [ExtensionAttribute]
public static IObservable`1<IChangeSet`2<TObject, TKey>> IncludeUpdateWhen(IObservable`1<IChangeSet`2<TObject, TKey>> source, Func`3<TObject, TObject, bool> includeFunction);
    [ExtensionAttribute]
public static IObservable`1<IChangeSet`2<TDestination, ValueTuple`2<TLeftKey, TRightKey>>> InnerJoin(IObservable`1<IChangeSet`2<TLeft, TLeftKey>> left, IObservable`1<IChangeSet`2<TRight, TRightKey>> right, Func`2<TRight, TLeftKey> rightKeySelector, Func`3<TLeft, TRight, TDestination> resultSelector);
    [ExtensionAttribute]
public static IObservable`1<IChangeSet`2<TDestination, ValueTuple`2<TLeftKey, TRightKey>>> InnerJoin(IObservable`1<IChangeSet`2<TLeft, TLeftKey>> left, IObservable`1<IChangeSet`2<TRight, TRightKey>> right, Func`2<TRight, TLeftKey> rightKeySelector, Func`4<ValueTuple`2<TLeftKey, TRightKey>, TLeft, TRight, TDestination> resultSelector);
    [ExtensionAttribute]
public static IObservable`1<IChangeSet`2<TDestination, TLeftKey>> InnerJoinMany(IObservable`1<IChangeSet`2<TLeft, TLeftKey>> left, IObservable`1<IChangeSet`2<TRight, TRightKey>> right, Func`2<TRight, TLeftKey> rightKeySelector, Func`3<TLeft, IGrouping`3<TRight, TRightKey, TLeftKey>, TDestination> resultSelector);
    [ExtensionAttribute]
public static IObservable`1<IChangeSet`2<TDestination, TLeftKey>> InnerJoinMany(IObservable`1<IChangeSet`2<TLeft, TLeftKey>> left, IObservable`1<IChangeSet`2<TRight, TRightKey>> right, Func`2<TRight, TLeftKey> rightKeySelector, Func`4<TLeftKey, TLeft, IGrouping`3<TRight, TRightKey, TLeftKey>, TDestination> resultSelector);
    [ExtensionAttribute]
public static IObservable`1<IChangeSet`2<TObject, TKey>> InvokeEvaluate(IObservable`1<IChangeSet`2<TObject, TKey>> source);
    [ExtensionAttribute]
public static IObservable`1<IChangeSet`2<TDestination, TLeftKey>> LeftJoin(IObservable`1<IChangeSet`2<TLeft, TLeftKey>> left, IObservable`1<IChangeSet`2<TRight, TRightKey>> right, Func`2<TRight, TLeftKey> rightKeySelector, Func`3<TLeft, Optional`1<TRight>, TDestination> resultSelector);
    [ExtensionAttribute]
public static IObservable`1<IChangeSet`2<TDestination, TLeftKey>> LeftJoin(IObservable`1<IChangeSet`2<TLeft, TLeftKey>> left, IObservable`1<IChangeSet`2<TRight, TRightKey>> right, Func`2<TRight, TLeftKey> rightKeySelector, Func`4<TLeftKey, TLeft, Optional`1<TRight>, TDestination> resultSelector);
    [ExtensionAttribute]
public static IObservable`1<IChangeSet`2<TDestination, TLeftKey>> LeftJoinMany(IObservable`1<IChangeSet`2<TLeft, TLeftKey>> left, IObservable`1<IChangeSet`2<TRight, TRightKey>> right, Func`2<TRight, TLeftKey> rightKeySelector, Func`3<TLeft, IGrouping`3<TRight, TRightKey, TLeftKey>, TDestination> resultSelector);
    [ExtensionAttribute]
public static IObservable`1<IChangeSet`2<TDestination, TLeftKey>> LeftJoinMany(IObservable`1<IChangeSet`2<TLeft, TLeftKey>> left, IObservable`1<IChangeSet`2<TRight, TRightKey>> right, Func`2<TRight, TLeftKey> rightKeySelector, Func`4<TLeftKey, TLeft, IGrouping`3<TRight, TRightKey, TLeftKey>, TDestination> resultSelector);
    [ExtensionAttribute]
public static IObservable`1<IChangeSet`2<TObject, TKey>> LimitSizeTo(IObservable`1<IChangeSet`2<TObject, TKey>> source, int size);
    [ExtensionAttribute]
public static IObservable`1<IEnumerable`1<KeyValuePair`2<TKey, TObject>>> LimitSizeTo(ISourceCache`2<TObject, TKey> source, int sizeLimit, IScheduler scheduler);
    [ExtensionAttribute]
public static IObservable`1<TDestination> MergeMany(IObservable`1<IChangeSet`2<TObject, TKey>> source, Func`2<TObject, IObservable`1<TDestination>> observableSelector);
    [ExtensionAttribute]
public static IObservable`1<TDestination> MergeMany(IObservable`1<IChangeSet`2<TObject, TKey>> source, Func`3<TObject, TKey, IObservable`1<TDestination>> observableSelector);
    [ExtensionAttribute]
public static IObservable`1<IChangeSet`2<TObject, TKey>> MergeChangeSets(IObservable`1<IObservable`1<IChangeSet`2<TObject, TKey>>> source);
    [ExtensionAttribute]
public static IObservable`1<IChangeSet`2<TObject, TKey>> MergeChangeSets(IObservable`1<IObservable`1<IChangeSet`2<TObject, TKey>>> source, IComparer`1<TObject> comparer);
    [ExtensionAttribute]
public static IObservable`1<IChangeSet`2<TObject, TKey>> MergeChangeSets(IObservable`1<IObservable`1<IChangeSet`2<TObject, TKey>>> source, IEqualityComparer`1<TObject> equalityComparer);
    [ExtensionAttribute]
public static IObservable`1<IChangeSet`2<TObject, TKey>> MergeChangeSets(IObservable`1<IObservable`1<IChangeSet`2<TObject, TKey>>> source, IEqualityComparer`1<TObject> equalityComparer, IComparer`1<TObject> comparer);
    [ExtensionAttribute]
public static IObservable`1<IChangeSet`2<TObject, TKey>> MergeChangeSets(IObservable`1<IChangeSet`2<TObject, TKey>> source, IObservable`1<IChangeSet`2<TObject, TKey>> other, IScheduler scheduler, bool completable);
    [ExtensionAttribute]
public static IObservable`1<IChangeSet`2<TObject, TKey>> MergeChangeSets(IObservable`1<IChangeSet`2<TObject, TKey>> source, IObservable`1<IChangeSet`2<TObject, TKey>> other, IComparer`1<TObject> comparer, IScheduler scheduler, bool completable);
    [ExtensionAttribute]
public static IObservable`1<IChangeSet`2<TObject, TKey>> MergeChangeSets(IObservable`1<IChangeSet`2<TObject, TKey>> source, IObservable`1<IChangeSet`2<TObject, TKey>> other, IEqualityComparer`1<TObject> equalityComparer, IScheduler scheduler, bool completable);
    [ExtensionAttribute]
public static IObservable`1<IChangeSet`2<TObject, TKey>> MergeChangeSets(IObservable`1<IChangeSet`2<TObject, TKey>> source, IObservable`1<IChangeSet`2<TObject, TKey>> other, IEqualityComparer`1<TObject> equalityComparer, IComparer`1<TObject> comparer, IScheduler scheduler, bool completable);
    [ExtensionAttribute]
public static IObservable`1<IChangeSet`2<TObject, TKey>> MergeChangeSets(IObservable`1<IChangeSet`2<TObject, TKey>> source, IEnumerable`1<IObservable`1<IChangeSet`2<TObject, TKey>>> others, IScheduler scheduler, bool completable);
    [ExtensionAttribute]
public static IObservable`1<IChangeSet`2<TObject, TKey>> MergeChangeSets(IObservable`1<IChangeSet`2<TObject, TKey>> source, IEnumerable`1<IObservable`1<IChangeSet`2<TObject, TKey>>> others, IComparer`1<TObject> comparer, IScheduler scheduler, bool completable);
    [ExtensionAttribute]
public static IObservable`1<IChangeSet`2<TObject, TKey>> MergeChangeSets(IObservable`1<IChangeSet`2<TObject, TKey>> source, IEnumerable`1<IObservable`1<IChangeSet`2<TObject, TKey>>> others, IEqualityComparer`1<TObject> equalityComparer, IScheduler scheduler, bool completable);
    [ExtensionAttribute]
public static IObservable`1<IChangeSet`2<TObject, TKey>> MergeChangeSets(IObservable`1<IChangeSet`2<TObject, TKey>> source, IEnumerable`1<IObservable`1<IChangeSet`2<TObject, TKey>>> others, IEqualityComparer`1<TObject> equalityComparer, IComparer`1<TObject> comparer, IScheduler scheduler, bool completable);
    [ExtensionAttribute]
public static IObservable`1<IChangeSet`2<TObject, TKey>> MergeChangeSets(IEnumerable`1<IObservable`1<IChangeSet`2<TObject, TKey>>> source, IScheduler scheduler, bool completable);
    [ExtensionAttribute]
public static IObservable`1<IChangeSet`2<TObject, TKey>> MergeChangeSets(IEnumerable`1<IObservable`1<IChangeSet`2<TObject, TKey>>> source, IComparer`1<TObject> comparer, IScheduler scheduler, bool completable);
    [ExtensionAttribute]
public static IObservable`1<IChangeSet`2<TObject, TKey>> MergeChangeSets(IEnumerable`1<IObservable`1<IChangeSet`2<TObject, TKey>>> source, IEqualityComparer`1<TObject> equalityComparer, IScheduler scheduler, bool completable);
    [ExtensionAttribute]
public static IObservable`1<IChangeSet`2<TObject, TKey>> MergeChangeSets(IEnumerable`1<IObservable`1<IChangeSet`2<TObject, TKey>>> source, IEqualityComparer`1<TObject> equalityComparer, IComparer`1<TObject> comparer, IScheduler scheduler, bool completable);
    [ExtensionAttribute]
public static IObservable`1<IChangeSet`2<TDestination, TDestinationKey>> MergeManyChangeSets(IObservable`1<IChangeSet`2<TObject, TKey>> source, Func`2<TObject, IObservable`1<IChangeSet`2<TDestination, TDestinationKey>>> observableSelector, IComparer`1<TDestination> comparer);
    [ExtensionAttribute]
public static IObservable`1<IChangeSet`2<TDestination, TDestinationKey>> MergeManyChangeSets(IObservable`1<IChangeSet`2<TObject, TKey>> source, Func`3<TObject, TKey, IObservable`1<IChangeSet`2<TDestination, TDestinationKey>>> observableSelector, IComparer`1<TDestination> comparer);
    [ExtensionAttribute]
public static IObservable`1<IChangeSet`2<TDestination, TDestinationKey>> MergeManyChangeSets(IObservable`1<IChangeSet`2<TObject, TKey>> source, Func`2<TObject, IObservable`1<IChangeSet`2<TDestination, TDestinationKey>>> observableSelector, IEqualityComparer`1<TDestination> equalityComparer, IComparer`1<TDestination> comparer);
    [ExtensionAttribute]
public static IObservable`1<IChangeSet`2<TDestination, TDestinationKey>> MergeManyChangeSets(IObservable`1<IChangeSet`2<TObject, TKey>> source, Func`3<TObject, TKey, IObservable`1<IChangeSet`2<TDestination, TDestinationKey>>> observableSelector, IEqualityComparer`1<TDestination> equalityComparer, IComparer`1<TDestination> comparer);
    [ExtensionAttribute]
public static IObservable`1<IChangeSet`2<TDestination, TDestinationKey>> MergeManyChangeSets(IObservable`1<IChangeSet`2<TObject, TKey>> source, Func`2<TObject, IObservable`1<IChangeSet`2<TDestination, TDestinationKey>>> observableSelector, IComparer`1<TObject> sourceComparer, IComparer`1<TDestination> childComparer);
    [ExtensionAttribute]
public static IObservable`1<IChangeSet`2<TDestination, TDestinationKey>> MergeManyChangeSets(IObservable`1<IChangeSet`2<TObject, TKey>> source, Func`3<TObject, TKey, IObservable`1<IChangeSet`2<TDestination, TDestinationKey>>> observableSelector, IComparer`1<TObject> sourceComparer, IComparer`1<TDestination> childComparer);
    [ExtensionAttribute]
public static IObservable`1<IChangeSet`2<TDestination, TDestinationKey>> MergeManyChangeSets(IObservable`1<IChangeSet`2<TObject, TKey>> source, Func`2<TObject, IObservable`1<IChangeSet`2<TDestination, TDestinationKey>>> observableSelector, IComparer`1<TObject> sourceComparer, bool resortOnSourceRefresh, IComparer`1<TDestination> childComparer);
    [ExtensionAttribute]
public static IObservable`1<IChangeSet`2<TDestination, TDestinationKey>> MergeManyChangeSets(IObservable`1<IChangeSet`2<TObject, TKey>> source, Func`3<TObject, TKey, IObservable`1<IChangeSet`2<TDestination, TDestinationKey>>> observableSelector, IComparer`1<TObject> sourceComparer, bool resortOnSourceRefresh, IComparer`1<TDestination> childComparer);
    [ExtensionAttribute]
public static IObservable`1<IChangeSet`2<TDestination, TDestinationKey>> MergeManyChangeSets(IObservable`1<IChangeSet`2<TObject, TKey>> source, Func`2<TObject, IObservable`1<IChangeSet`2<TDestination, TDestinationKey>>> observableSelector, IComparer`1<TObject> sourceComparer, IEqualityComparer`1<TDestination> equalityComparer, IComparer`1<TDestination> childComparer);
    [ExtensionAttribute]
public static IObservable`1<IChangeSet`2<TDestination, TDestinationKey>> MergeManyChangeSets(IObservable`1<IChangeSet`2<TObject, TKey>> source, Func`3<TObject, TKey, IObservable`1<IChangeSet`2<TDestination, TDestinationKey>>> observableSelector, IComparer`1<TObject> sourceComparer, IEqualityComparer`1<TDestination> equalityComparer, IComparer`1<TDestination> childComparer);
    [ExtensionAttribute]
public static IObservable`1<IChangeSet`2<TDestination, TDestinationKey>> MergeManyChangeSets(IObservable`1<IChangeSet`2<TObject, TKey>> source, Func`2<TObject, IObservable`1<IChangeSet`2<TDestination, TDestinationKey>>> observableSelector, IComparer`1<TObject> sourceComparer, bool resortOnSourceRefresh, IEqualityComparer`1<TDestination> equalityComparer, IComparer`1<TDestination> childComparer);
    [ExtensionAttribute]
public static IObservable`1<IChangeSet`2<TDestination, TDestinationKey>> MergeManyChangeSets(IObservable`1<IChangeSet`2<TObject, TKey>> source, Func`3<TObject, TKey, IObservable`1<IChangeSet`2<TDestination, TDestinationKey>>> observableSelector, IComparer`1<TObject> sourceComparer, bool resortOnSourceRefresh, IEqualityComparer`1<TDestination> equalityComparer, IComparer`1<TDestination> childComparer);
    [ExtensionAttribute]
public static IObservable`1<IChangeSet`1<TDestination>> MergeManyChangeSets(IObservable`1<IChangeSet`2<TObject, TKey>> source, Func`3<TObject, TKey, IObservable`1<IChangeSet`1<TDestination>>> observableSelector, IEqualityComparer`1<TDestination> equalityComparer);
    [ExtensionAttribute]
public static IObservable`1<IChangeSet`1<TDestination>> MergeManyChangeSets(IObservable`1<IChangeSet`2<TObject, TKey>> source, Func`2<TObject, IObservable`1<IChangeSet`1<TDestination>>> observableSelector, IEqualityComparer`1<TDestination> equalityComparer);
    [ExtensionAttribute]
public static IObservable`1<ItemWithValue`2<TObject, TDestination>> MergeManyItems(IObservable`1<IChangeSet`2<TObject, TKey>> source, Func`2<TObject, IObservable`1<TDestination>> observableSelector);
    [ExtensionAttribute]
public static IObservable`1<ItemWithValue`2<TObject, TDestination>> MergeManyItems(IObservable`1<IChangeSet`2<TObject, TKey>> source, Func`3<TObject, TKey, IObservable`1<TDestination>> observableSelector);
    [ExtensionAttribute]
public static IObservable`1<ConnectionStatus> MonitorStatus(IObservable`1<T> source);
    [ExtensionAttribute]
public static IObservable`1<IChangeSet`2<TObject, TKey>> NotEmpty(IObservable`1<IChangeSet`2<TObject, TKey>> source);
    [ExtensionAttribute]
public static IObservable`1<IChangeSet`2<TDestination, TKey>> OfType(IObservable`1<IChangeSet`2<TObject, TKey>> source, bool suppressEmptyChangeSets);
    [ExtensionAttribute]
public static IObservable`1<IChangeSet`2<TObject, TKey>> OnItemAdded(IObservable`1<IChangeSet`2<TObject, TKey>> source, Action`2<TObject, TKey> addAction);
    [ExtensionAttribute]
public static IObservable`1<IChangeSet`2<TObject, TKey>> OnItemAdded(IObservable`1<IChangeSet`2<TObject, TKey>> source, Action`1<TObject> addAction);
    [ExtensionAttribute]
public static IObservable`1<IChangeSet`2<TObject, TKey>> OnItemRefreshed(IObservable`1<IChangeSet`2<TObject, TKey>> source, Action`2<TObject, TKey> refreshAction);
    [ExtensionAttribute]
public static IObservable`1<IChangeSet`2<TObject, TKey>> OnItemRefreshed(IObservable`1<IChangeSet`2<TObject, TKey>> source, Action`1<TObject> refreshAction);
    [ExtensionAttribute]
public static IObservable`1<IChangeSet`2<TObject, TKey>> OnItemRemoved(IObservable`1<IChangeSet`2<TObject, TKey>> source, Action`2<TObject, TKey> removeAction, bool invokeOnUnsubscribe);
    [ExtensionAttribute]
public static IObservable`1<IChangeSet`2<TObject, TKey>> OnItemRemoved(IObservable`1<IChangeSet`2<TObject, TKey>> source, Action`1<TObject> removeAction, bool invokeOnUnsubscribe);
    [ExtensionAttribute]
public static IObservable`1<IChangeSet`2<TObject, TKey>> OnItemUpdated(IObservable`1<IChangeSet`2<TObject, TKey>> source, Action`3<TObject, TObject, TKey> updateAction);
    [ExtensionAttribute]
public static IObservable`1<IChangeSet`2<TObject, TKey>> OnItemUpdated(IObservable`1<IChangeSet`2<TObject, TKey>> source, Action`2<TObject, TObject> updateAction);
    [ExtensionAttribute]
public static IObservable`1<IChangeSet`2<TObject, TKey>> Or(IObservable`1<IChangeSet`2<TObject, TKey>> source, IObservable`1[] others);
    [ExtensionAttribute]
public static IObservable`1<IChangeSet`2<TObject, TKey>> Or(ICollection`1<IObservable`1<IChangeSet`2<TObject, TKey>>> sources);
    [ExtensionAttribute]
public static IObservable`1<IChangeSet`2<TObject, TKey>> Or(IObservableList`1<IObservable`1<IChangeSet`2<TObject, TKey>>> sources);
    [ExtensionAttribute]
public static IObservable`1<IChangeSet`2<TObject, TKey>> Or(IObservableList`1<IObservableCache`2<TObject, TKey>> sources);
    [ExtensionAttribute]
public static IObservable`1<IChangeSet`2<TObject, TKey>> Or(IObservableList`1<ISourceCache`2<TObject, TKey>> sources);
    [ExtensionAttribute]
public static IDisposable PopulateFrom(ISourceCache`2<TObject, TKey> source, IObservable`1<IEnumerable`1<TObject>> observable);
    [ExtensionAttribute]
public static IDisposable PopulateFrom(ISourceCache`2<TObject, TKey> source, IObservable`1<TObject> observable);
    [ExtensionAttribute]
public static IDisposable PopulateInto(IObservable`1<IChangeSet`2<TObject, TKey>> source, ISourceCache`2<TObject, TKey> destination);
    [ExtensionAttribute]
public static IDisposable PopulateInto(IObservable`1<IChangeSet`2<TObject, TKey>> source, IIntermediateCache`2<TObject, TKey> destination);
    [ExtensionAttribute]
public static IDisposable PopulateInto(IObservable`1<IChangeSet`2<TObject, TKey>> source, LockFreeObservableCache`2<TObject, TKey> destination);
    [ExtensionAttribute]
public static IObservable`1<TDestination> QueryWhenChanged(IObservable`1<IChangeSet`2<TObject, TKey>> source, Func`2<IQuery`2<TObject, TKey>, TDestination> resultSelector);
    [ExtensionAttribute]
public static IObservable`1<IQuery`2<TObject, TKey>> QueryWhenChanged(IObservable`1<IChangeSet`2<TObject, TKey>> source);
    [ExtensionAttribute]
public static IObservable`1<IQuery`2<TObject, TKey>> QueryWhenChanged(IObservable`1<IChangeSet`2<TObject, TKey>> source, Func`2<TObject, IObservable`1<TValue>> itemChangedTrigger);
    [ExtensionAttribute]
public static IObservable`1<IChangeSet`2<TObject, TKey>> RefCount(IObservable`1<IChangeSet`2<TObject, TKey>> source);
    [ExtensionAttribute]
public static void Refresh(ISourceCache`2<TObject, TKey> source, TObject item);
    [ExtensionAttribute]
public static void Refresh(ISourceCache`2<TObject, TKey> source, IEnumerable`1<TObject> items);
    [ExtensionAttribute]
public static void Refresh(ISourceCache`2<TObject, TKey> source);
    [ExtensionAttribute]
public static void Remove(ISourceCache`2<TObject, TKey> source, TObject item);
    [ExtensionAttribute]
public static void Remove(ISourceCache`2<TObject, TKey> source, TKey key);
    [ExtensionAttribute]
public static void Remove(ISourceCache`2<TObject, TKey> source, IEnumerable`1<TObject> items);
    [ExtensionAttribute]
public static void Remove(ISourceCache`2<TObject, TKey> source, IEnumerable`1<TKey> keys);
    [ExtensionAttribute]
public static void Remove(IIntermediateCache`2<TObject, TKey> source, TKey key);
    [ExtensionAttribute]
public static void Remove(IIntermediateCache`2<TObject, TKey> source, IEnumerable`1<TKey> keys);
    [ExtensionAttribute]
public static IObservable`1<IChangeSet`1<TObject>> RemoveKey(IObservable`1<IChangeSet`2<TObject, TKey>> source);
    [ExtensionAttribute]
public static void RemoveKey(ISourceCache`2<TObject, TKey> source, TKey key);
    [ExtensionAttribute]
public static void RemoveKeys(ISourceCache`2<TObject, TKey> source, IEnumerable`1<TKey> keys);
    [ExtensionAttribute]
public static IObservable`1<IChangeSet`2<TDestination, TRightKey>> RightJoin(IObservable`1<IChangeSet`2<TLeft, TLeftKey>> left, IObservable`1<IChangeSet`2<TRight, TRightKey>> right, Func`2<TRight, TLeftKey> rightKeySelector, Func`3<Optional`1<TLeft>, TRight, TDestination> resultSelector);
    [ExtensionAttribute]
public static IObservable`1<IChangeSet`2<TDestination, TRightKey>> RightJoin(IObservable`1<IChangeSet`2<TLeft, TLeftKey>> left, IObservable`1<IChangeSet`2<TRight, TRightKey>> right, Func`2<TRight, TLeftKey> rightKeySelector, Func`4<TRightKey, Optional`1<TLeft>, TRight, TDestination> resultSelector);
    [ExtensionAttribute]
public static IObservable`1<IChangeSet`2<TDestination, TLeftKey>> RightJoinMany(IObservable`1<IChangeSet`2<TLeft, TLeftKey>> left, IObservable`1<IChangeSet`2<TRight, TRightKey>> right, Func`2<TRight, TLeftKey> rightKeySelector, Func`3<Optional`1<TLeft>, IGrouping`3<TRight, TRightKey, TLeftKey>, TDestination> resultSelector);
    [ExtensionAttribute]
public static IObservable`1<IChangeSet`2<TDestination, TLeftKey>> RightJoinMany(IObservable`1<IChangeSet`2<TLeft, TLeftKey>> left, IObservable`1<IChangeSet`2<TRight, TRightKey>> right, Func`2<TRight, TLeftKey> rightKeySelector, Func`4<TLeftKey, Optional`1<TLeft>, IGrouping`3<TRight, TRightKey, TLeftKey>, TDestination> resultSelector);
    [ExtensionAttribute]
public static IObservable`1<IChangeSet`2<TObject, TKey>> SkipInitial(IObservable`1<IChangeSet`2<TObject, TKey>> source);
    [ExtensionAttribute]
[ObsoleteAttribute("Use SortAndBind as it's more efficient")]
public static IObservable`1<ISortedChangeSet`2<TObject, TKey>> Sort(IObservable`1<IChangeSet`2<TObject, TKey>> source, IComparer`1<TObject> comparer, SortOptimisations sortOptimisations, int resetThreshold);
    [ExtensionAttribute]
[ObsoleteAttribute("Use SortAndBind as it's more efficient")]
public static IObservable`1<ISortedChangeSet`2<TObject, TKey>> Sort(IObservable`1<IChangeSet`2<TObject, TKey>> source, IObservable`1<IComparer`1<TObject>> comparerObservable, SortOptimisations sortOptimisations, int resetThreshold);
    [ExtensionAttribute]
[ObsoleteAttribute("Use SortAndBind as it's more efficient")]
public static IObservable`1<ISortedChangeSet`2<TObject, TKey>> Sort(IObservable`1<IChangeSet`2<TObject, TKey>> source, IObservable`1<IComparer`1<TObject>> comparerObservable, IObservable`1<Unit> resorter, SortOptimisations sortOptimisations, int resetThreshold);
    [ExtensionAttribute]
[ObsoleteAttribute("Use SortAndBind as it's more efficient")]
public static IObservable`1<ISortedChangeSet`2<TObject, TKey>> Sort(IObservable`1<IChangeSet`2<TObject, TKey>> source, IComparer`1<TObject> comparer, IObservable`1<Unit> resorter, SortOptimisations sortOptimisations, int resetThreshold);
    [ExtensionAttribute]
public static IObservable`1<ISortedChangeSet`2<TObject, TKey>> SortBy(IObservable`1<IChangeSet`2<TObject, TKey>> source, Func`2<TObject, IComparable> expression, SortDirection sortOrder, SortOptimisations sortOptimisations, int resetThreshold);
    [ExtensionAttribute]
public static IObservable`1<IChangeSet`2<TObject, TKey>> StartWithEmpty(IObservable`1<IChangeSet`2<TObject, TKey>> source);
    [ExtensionAttribute]
public static IObservable`1<ISortedChangeSet`2<TObject, TKey>> StartWithEmpty(IObservable`1<ISortedChangeSet`2<TObject, TKey>> source);
    [ExtensionAttribute]
public static IObservable`1<IVirtualChangeSet`2<TObject, TKey>> StartWithEmpty(IObservable`1<IVirtualChangeSet`2<TObject, TKey>> source);
    [ExtensionAttribute]
public static IObservable`1<IPagedChangeSet`2<TObject, TKey>> StartWithEmpty(IObservable`1<IPagedChangeSet`2<TObject, TKey>> source);
    [ExtensionAttribute]
public static IObservable`1<IGroupChangeSet`3<TObject, TKey, TGroupKey>> StartWithEmpty(IObservable`1<IGroupChangeSet`3<TObject, TKey, TGroupKey>> source);
    [ExtensionAttribute]
public static IObservable`1<IImmutableGroupChangeSet`3<TObject, TKey, TGroupKey>> StartWithEmpty(IObservable`1<IImmutableGroupChangeSet`3<TObject, TKey, TGroupKey>> source);
    [ExtensionAttribute]
public static IObservable`1<IReadOnlyCollection`1<T>> StartWithEmpty(IObservable`1<IReadOnlyCollection`1<T>> source);
    [ExtensionAttribute]
public static IObservable`1<IChangeSet`2<TObject, TKey>> StartWithItem(IObservable`1<IChangeSet`2<TObject, TKey>> source, TObject item);
    [ExtensionAttribute]
public static IObservable`1<IChangeSet`2<TObject, TKey>> StartWithItem(IObservable`1<IChangeSet`2<TObject, TKey>> source, TObject item, TKey key);
    [ExtensionAttribute]
public static IObservable`1<IChangeSet`2<TObject, TKey>> SubscribeMany(IObservable`1<IChangeSet`2<TObject, TKey>> source, Func`2<TObject, IDisposable> subscriptionFactory);
    [ExtensionAttribute]
public static IObservable`1<IChangeSet`2<TObject, TKey>> SubscribeMany(IObservable`1<IChangeSet`2<TObject, TKey>> source, Func`3<TObject, TKey, IDisposable> subscriptionFactory);
    [ExtensionAttribute]
public static IObservable`1<IChangeSet`2<TObject, TKey>> SuppressRefresh(IObservable`1<IChangeSet`2<TObject, TKey>> source);
    [ExtensionAttribute]
public static IObservable`1<IChangeSet`2<TObject, TKey>> Switch(IObservable`1<IObservableCache`2<TObject, TKey>> sources);
    [ExtensionAttribute]
public static IObservable`1<IChangeSet`2<TObject, TKey>> Switch(IObservable`1<IObservable`1<IChangeSet`2<TObject, TKey>>> sources);
    [ExtensionAttribute]
public static IObservable`1<IReadOnlyCollection`1<TObject>> ToCollection(IObservable`1<IChangeSet`2<TObject, TKey>> source);
    [ExtensionAttribute]
public static IObservable`1<IChangeSet`2<TObject, TKey>> ToObservableChangeSet(IObservable`1<TObject> source, Func`2<TObject, TKey> keySelector, Func`2<TObject, Nullable`1<TimeSpan>> expireAfter, int limitSizeTo, IScheduler scheduler);
    [ExtensionAttribute]
public static IObservable`1<IChangeSet`2<TObject, TKey>> ToObservableChangeSet(IObservable`1<IEnumerable`1<TObject>> source, Func`2<TObject, TKey> keySelector, Func`2<TObject, Nullable`1<TimeSpan>> expireAfter, int limitSizeTo, IScheduler scheduler);
    [ExtensionAttribute]
public static IObservable`1<Optional`1<TObject>> ToObservableOptional(IObservable`1<IChangeSet`2<TObject, TKey>> source, TKey key, IEqualityComparer`1<TObject> equalityComparer);
    [ExtensionAttribute]
public static IObservable`1<Optional`1<TObject>> ToObservableOptional(IObservable`1<IChangeSet`2<TObject, TKey>> source, TKey key, bool initialOptionalWhenMissing, IEqualityComparer`1<TObject> equalityComparer);
    [ExtensionAttribute]
public static IObservable`1<IReadOnlyCollection`1<TObject>> ToSortedCollection(IObservable`1<IChangeSet`2<TObject, TKey>> source, Func`2<TObject, TSortKey> sort, SortDirection sortOrder);
    [ExtensionAttribute]
public static IObservable`1<IReadOnlyCollection`1<TObject>> ToSortedCollection(IObservable`1<IChangeSet`2<TObject, TKey>> source, IComparer`1<TObject> comparer);
    [ExtensionAttribute]
public static IObservable`1<IChangeSet`2<TDestination, TKey>> Transform(IObservable`1<IChangeSet`2<TSource, TKey>> source, Func`2<TSource, TDestination> transformFactory, bool transformOnRefresh);
    [ExtensionAttribute]
public static IObservable`1<IChangeSet`2<TDestination, TKey>> Transform(IObservable`1<IChangeSet`2<TSource, TKey>> source, Func`3<TSource, TKey, TDestination> transformFactory, bool transformOnRefresh);
    [ExtensionAttribute]
public static IObservable`1<IChangeSet`2<TDestination, TKey>> Transform(IObservable`1<IChangeSet`2<TSource, TKey>> source, Func`4<TSource, Optional`1<TSource>, TKey, TDestination> transformFactory, bool transformOnRefresh);
    [ExtensionAttribute]
public static IObservable`1<IChangeSet`2<TDestination, TKey>> Transform(IObservable`1<IChangeSet`2<TSource, TKey>> source, Func`2<TSource, TDestination> transformFactory, IObservable`1<Func`2<TSource, bool>> forceTransform);
    [ExtensionAttribute]
public static IObservable`1<IChangeSet`2<TDestination, TKey>> Transform(IObservable`1<IChangeSet`2<TSource, TKey>> source, Func`3<TSource, TKey, TDestination> transformFactory, IObservable`1<Func`3<TSource, TKey, bool>> forceTransform);
    [ExtensionAttribute]
public static IObservable`1<IChangeSet`2<TDestination, TKey>> Transform(IObservable`1<IChangeSet`2<TSource, TKey>> source, Func`4<TSource, Optional`1<TSource>, TKey, TDestination> transformFactory, IObservable`1<Func`3<TSource, TKey, bool>> forceTransform);
    [ExtensionAttribute]
public static IObservable`1<IChangeSet`2<TDestination, TKey>> Transform(IObservable`1<IChangeSet`2<TSource, TKey>> source, Func`2<TSource, TDestination> transformFactory, IObservable`1<Unit> forceTransform);
    [ExtensionAttribute]
public static IObservable`1<IChangeSet`2<TDestination, TKey>> Transform(IObservable`1<IChangeSet`2<TSource, TKey>> source, Func`3<TSource, TKey, TDestination> transformFactory, IObservable`1<Unit> forceTransform);
    [ExtensionAttribute]
public static IObservable`1<IChangeSet`2<TDestination, TKey>> Transform(IObservable`1<IChangeSet`2<TSource, TKey>> source, Func`4<TSource, Optional`1<TSource>, TKey, TDestination> transformFactory, IObservable`1<Unit> forceTransform);
    [ExtensionAttribute]
public static IObservable`1<IChangeSet`2<TDestination, TKey>> TransformAsync(IObservable`1<IChangeSet`2<TSource, TKey>> source, Func`2<TSource, Task`1<TDestination>> transformFactory, IObservable`1<Func`3<TSource, TKey, bool>> forceTransform);
    [ExtensionAttribute]
public static IObservable`1<IChangeSet`2<TDestination, TKey>> TransformAsync(IObservable`1<IChangeSet`2<TSource, TKey>> source, Func`3<TSource, TKey, Task`1<TDestination>> transformFactory, IObservable`1<Func`3<TSource, TKey, bool>> forceTransform);
    [ExtensionAttribute]
public static IObservable`1<IChangeSet`2<TDestination, TKey>> TransformAsync(IObservable`1<IChangeSet`2<TSource, TKey>> source, Func`4<TSource, Optional`1<TSource>, TKey, Task`1<TDestination>> transformFactory, IObservable`1<Func`3<TSource, TKey, bool>> forceTransform);
    [ExtensionAttribute]
public static IObservable`1<IChangeSet`2<TDestination, TKey>> TransformAsync(IObservable`1<IChangeSet`2<TSource, TKey>> source, Func`2<TSource, Task`1<TDestination>> transformFactory, TransformAsyncOptions options);
    [ExtensionAttribute]
public static IObservable`1<IChangeSet`2<TDestination, TKey>> TransformAsync(IObservable`1<IChangeSet`2<TSource, TKey>> source, Func`3<TSource, TKey, Task`1<TDestination>> transformFactory, TransformAsyncOptions options);
    [ExtensionAttribute]
public static IObservable`1<IChangeSet`2<TDestination, TKey>> TransformAsync(IObservable`1<IChangeSet`2<TSource, TKey>> source, Func`4<TSource, Optional`1<TSource>, TKey, Task`1<TDestination>> transformFactory, TransformAsyncOptions options);
    [ExtensionAttribute]
public static IObservable`1<IChangeSet`2<TDestination, TKey>> TransformImmutable(IObservable`1<IChangeSet`2<TSource, TKey>> source, Func`2<TSource, TDestination> transformFactory);
    [ExtensionAttribute]
public static IObservable`1<IChangeSet`2<TDestination, TDestinationKey>> TransformMany(IObservable`1<IChangeSet`2<TSource, TSourceKey>> source, Func`2<TSource, IEnumerable`1<TDestination>> manySelector, Func`2<TDestination, TDestinationKey> keySelector);
    [ExtensionAttribute]
public static IObservable`1<IChangeSet`2<TDestination, TDestinationKey>> TransformMany(IObservable`1<IChangeSet`2<TSource, TSourceKey>> source, Func`2<TSource, ObservableCollection`1<TDestination>> manySelector, Func`2<TDestination, TDestinationKey> keySelector);
    [ExtensionAttribute]
public static IObservable`1<IChangeSet`2<TDestination, TDestinationKey>> TransformMany(IObservable`1<IChangeSet`2<TSource, TSourceKey>> source, Func`2<TSource, ReadOnlyObservableCollection`1<TDestination>> manySelector, Func`2<TDestination, TDestinationKey> keySelector);
    [ExtensionAttribute]
public static IObservable`1<IChangeSet`2<TDestination, TDestinationKey>> TransformMany(IObservable`1<IChangeSet`2<TSource, TSourceKey>> source, Func`2<TSource, IObservableCache`2<TDestination, TDestinationKey>> manySelector, Func`2<TDestination, TDestinationKey> keySelector);
    [ExtensionAttribute]
public static IObservable`1<IChangeSet`2<TDestination, TDestinationKey>> TransformManyAsync(IObservable`1<IChangeSet`2<TSource, TSourceKey>> source, Func`3<TSource, TSourceKey, Task`1<IEnumerable`1<TDestination>>> manySelector, Func`2<TDestination, TDestinationKey> keySelector, IEqualityComparer`1<TDestination> equalityComparer, IComparer`1<TDestination> comparer);
    [ExtensionAttribute]
public static IObservable`1<IChangeSet`2<TDestination, TDestinationKey>> TransformManyAsync(IObservable`1<IChangeSet`2<TSource, TSourceKey>> source, Func`2<TSource, Task`1<IEnumerable`1<TDestination>>> manySelector, Func`2<TDestination, TDestinationKey> keySelector, IEqualityComparer`1<TDestination> equalityComparer, IComparer`1<TDestination> comparer);
    [ExtensionAttribute]
public static IObservable`1<IChangeSet`2<TDestination, TDestinationKey>> TransformManyAsync(IObservable`1<IChangeSet`2<TSource, TSourceKey>> source, Func`3<TSource, TSourceKey, Task`1<TCollection>> manySelector, Func`2<TDestination, TDestinationKey> keySelector, IEqualityComparer`1<TDestination> equalityComparer, IComparer`1<TDestination> comparer);
    [ExtensionAttribute]
public static IObservable`1<IChangeSet`2<TDestination, TDestinationKey>> TransformManyAsync(IObservable`1<IChangeSet`2<TSource, TSourceKey>> source, Func`2<TSource, Task`1<TCollection>> manySelector, Func`2<TDestination, TDestinationKey> keySelector, IEqualityComparer`1<TDestination> equalityComparer, IComparer`1<TDestination> comparer);
    [ExtensionAttribute]
public static IObservable`1<IChangeSet`2<TDestination, TDestinationKey>> TransformManyAsync(IObservable`1<IChangeSet`2<TSource, TSourceKey>> source, Func`3<TSource, TSourceKey, Task`1<IObservableCache`2<TDestination, TDestinationKey>>> manySelector, IEqualityComparer`1<TDestination> equalityComparer, IComparer`1<TDestination> comparer);
    [ExtensionAttribute]
public static IObservable`1<IChangeSet`2<TDestination, TDestinationKey>> TransformManyAsync(IObservable`1<IChangeSet`2<TSource, TSourceKey>> source, Func`2<TSource, Task`1<IObservableCache`2<TDestination, TDestinationKey>>> manySelector, IEqualityComparer`1<TDestination> equalityComparer, IComparer`1<TDestination> comparer);
    [ExtensionAttribute]
public static IObservable`1<IChangeSet`2<TDestination, TDestinationKey>> TransformManySafeAsync(IObservable`1<IChangeSet`2<TSource, TSourceKey>> source, Func`3<TSource, TSourceKey, Task`1<IEnumerable`1<TDestination>>> manySelector, Func`2<TDestination, TDestinationKey> keySelector, Action`1<Error`2<TSource, TSourceKey>> errorHandler, IEqualityComparer`1<TDestination> equalityComparer, IComparer`1<TDestination> comparer);
    [ExtensionAttribute]
public static IObservable`1<IChangeSet`2<TDestination, TDestinationKey>> TransformManySafeAsync(IObservable`1<IChangeSet`2<TSource, TSourceKey>> source, Func`2<TSource, Task`1<IEnumerable`1<TDestination>>> manySelector, Func`2<TDestination, TDestinationKey> keySelector, Action`1<Error`2<TSource, TSourceKey>> errorHandler, IEqualityComparer`1<TDestination> equalityComparer, IComparer`1<TDestination> comparer);
    [ExtensionAttribute]
public static IObservable`1<IChangeSet`2<TDestination, TDestinationKey>> TransformManySafeAsync(IObservable`1<IChangeSet`2<TSource, TSourceKey>> source, Func`3<TSource, TSourceKey, Task`1<TCollection>> manySelector, Func`2<TDestination, TDestinationKey> keySelector, Action`1<Error`2<TSource, TSourceKey>> errorHandler, IEqualityComparer`1<TDestination> equalityComparer, IComparer`1<TDestination> comparer);
    [ExtensionAttribute]
public static IObservable`1<IChangeSet`2<TDestination, TDestinationKey>> TransformManySafeAsync(IObservable`1<IChangeSet`2<TSource, TSourceKey>> source, Func`2<TSource, Task`1<TCollection>> manySelector, Func`2<TDestination, TDestinationKey> keySelector, Action`1<Error`2<TSource, TSourceKey>> errorHandler, IEqualityComparer`1<TDestination> equalityComparer, IComparer`1<TDestination> comparer);
    [ExtensionAttribute]
public static IObservable`1<IChangeSet`2<TDestination, TDestinationKey>> TransformManySafeAsync(IObservable`1<IChangeSet`2<TSource, TSourceKey>> source, Func`3<TSource, TSourceKey, Task`1<IObservableCache`2<TDestination, TDestinationKey>>> manySelector, Action`1<Error`2<TSource, TSourceKey>> errorHandler, IEqualityComparer`1<TDestination> equalityComparer, IComparer`1<TDestination> comparer);
    [ExtensionAttribute]
public static IObservable`1<IChangeSet`2<TDestination, TDestinationKey>> TransformManySafeAsync(IObservable`1<IChangeSet`2<TSource, TSourceKey>> source, Func`2<TSource, Task`1<IObservableCache`2<TDestination, TDestinationKey>>> manySelector, Action`1<Error`2<TSource, TSourceKey>> errorHandler, IEqualityComparer`1<TDestination> equalityComparer, IComparer`1<TDestination> comparer);
    [ExtensionAttribute]
public static IObservable`1<IChangeSet`2<TDestination, TKey>> TransformOnObservable(IObservable`1<IChangeSet`2<TSource, TKey>> source, Func`3<TSource, TKey, IObservable`1<TDestination>> transformFactory);
    [ExtensionAttribute]
public static IObservable`1<IChangeSet`2<TDestination, TKey>> TransformOnObservable(IObservable`1<IChangeSet`2<TSource, TKey>> source, Func`2<TSource, IObservable`1<TDestination>> transformFactory);
    [ExtensionAttribute]
public static IObservable`1<IChangeSet`2<TDestination, TKey>> TransformSafe(IObservable`1<IChangeSet`2<TSource, TKey>> source, Func`2<TSource, TDestination> transformFactory, Action`1<Error`2<TSource, TKey>> errorHandler, IObservable`1<Func`2<TSource, bool>> forceTransform);
    [ExtensionAttribute]
public static IObservable`1<IChangeSet`2<TDestination, TKey>> TransformSafe(IObservable`1<IChangeSet`2<TSource, TKey>> source, Func`3<TSource, TKey, TDestination> transformFactory, Action`1<Error`2<TSource, TKey>> errorHandler, IObservable`1<Func`3<TSource, TKey, bool>> forceTransform);
    [ExtensionAttribute]
public static IObservable`1<IChangeSet`2<TDestination, TKey>> TransformSafe(IObservable`1<IChangeSet`2<TSource, TKey>> source, Func`4<TSource, Optional`1<TSource>, TKey, TDestination> transformFactory, Action`1<Error`2<TSource, TKey>> errorHandler, IObservable`1<Func`3<TSource, TKey, bool>> forceTransform);
    [ExtensionAttribute]
public static IObservable`1<IChangeSet`2<TDestination, TKey>> TransformSafe(IObservable`1<IChangeSet`2<TSource, TKey>> source, Func`2<TSource, TDestination> transformFactory, Action`1<Error`2<TSource, TKey>> errorHandler, IObservable`1<Unit> forceTransform);
    [ExtensionAttribute]
public static IObservable`1<IChangeSet`2<TDestination, TKey>> TransformSafe(IObservable`1<IChangeSet`2<TSource, TKey>> source, Func`3<TSource, TKey, TDestination> transformFactory, Action`1<Error`2<TSource, TKey>> errorHandler, IObservable`1<Unit> forceTransform);
    [ExtensionAttribute]
public static IObservable`1<IChangeSet`2<TDestination, TKey>> TransformSafe(IObservable`1<IChangeSet`2<TSource, TKey>> source, Func`4<TSource, Optional`1<TSource>, TKey, TDestination> transformFactory, Action`1<Error`2<TSource, TKey>> errorHandler, IObservable`1<Unit> forceTransform);
    [ExtensionAttribute]
public static IObservable`1<IChangeSet`2<TDestination, TKey>> TransformSafeAsync(IObservable`1<IChangeSet`2<TSource, TKey>> source, Func`2<TSource, Task`1<TDestination>> transformFactory, Action`1<Error`2<TSource, TKey>> errorHandler, IObservable`1<Func`3<TSource, TKey, bool>> forceTransform);
    [ExtensionAttribute]
public static IObservable`1<IChangeSet`2<TDestination, TKey>> TransformSafeAsync(IObservable`1<IChangeSet`2<TSource, TKey>> source, Func`3<TSource, TKey, Task`1<TDestination>> transformFactory, Action`1<Error`2<TSource, TKey>> errorHandler, IObservable`1<Func`3<TSource, TKey, bool>> forceTransform);
    [ExtensionAttribute]
public static IObservable`1<IChangeSet`2<TDestination, TKey>> TransformSafeAsync(IObservable`1<IChangeSet`2<TSource, TKey>> source, Func`4<TSource, Optional`1<TSource>, TKey, Task`1<TDestination>> transformFactory, Action`1<Error`2<TSource, TKey>> errorHandler, IObservable`1<Func`3<TSource, TKey, bool>> forceTransform);
    [ExtensionAttribute]
public static IObservable`1<IChangeSet`2<TDestination, TKey>> TransformSafeAsync(IObservable`1<IChangeSet`2<TSource, TKey>> source, Func`2<TSource, Task`1<TDestination>> transformFactory, Action`1<Error`2<TSource, TKey>> errorHandler, TransformAsyncOptions options);
    [ExtensionAttribute]
public static IObservable`1<IChangeSet`2<TDestination, TKey>> TransformSafeAsync(IObservable`1<IChangeSet`2<TSource, TKey>> source, Func`3<TSource, TKey, Task`1<TDestination>> transformFactory, Action`1<Error`2<TSource, TKey>> errorHandler, TransformAsyncOptions options);
    [ExtensionAttribute]
public static IObservable`1<IChangeSet`2<TDestination, TKey>> TransformSafeAsync(IObservable`1<IChangeSet`2<TSource, TKey>> source, Func`4<TSource, Optional`1<TSource>, TKey, Task`1<TDestination>> transformFactory, Action`1<Error`2<TSource, TKey>> errorHandler, TransformAsyncOptions options);
    [ExtensionAttribute]
public static IObservable`1<IChangeSet`2<Node`2<TObject, TKey>, TKey>> TransformToTree(IObservable`1<IChangeSet`2<TObject, TKey>> source, Func`2<TObject, TKey> pivotOn, IObservable`1<Func`2<Node`2<TObject, TKey>, bool>> predicateChanged);
    [ExtensionAttribute]
public static IObservable`1<IChangeSet`2<TDestination, TKey>> TransformWithInlineUpdate(IObservable`1<IChangeSet`2<TSource, TKey>> source, Func`2<TSource, TDestination> transformFactory, Action`2<TDestination, TSource> updateAction);
    [ExtensionAttribute]
public static IObservable`1<IChangeSet`2<TDestination, TKey>> TransformWithInlineUpdate(IObservable`1<IChangeSet`2<TSource, TKey>> source, Func`2<TSource, TDestination> transformFactory, Action`2<TDestination, TSource> updateAction, bool transformOnRefresh);
    [ExtensionAttribute]
public static IObservable`1<IChangeSet`2<TDestination, TKey>> TransformWithInlineUpdate(IObservable`1<IChangeSet`2<TSource, TKey>> source, Func`2<TSource, TDestination> transformFactory, Action`2<TDestination, TSource> updateAction, Action`1<Error`2<TSource, TKey>> errorHandler);
    [ExtensionAttribute]
public static IObservable`1<IChangeSet`2<TDestination, TKey>> TransformWithInlineUpdate(IObservable`1<IChangeSet`2<TSource, TKey>> source, Func`2<TSource, TDestination> transformFactory, Action`2<TDestination, TSource> updateAction, Action`1<Error`2<TSource, TKey>> errorHandler, bool transformOnRefresh);
    [ExtensionAttribute]
public static IObservable`1<ISortedChangeSet`2<TObject, TKey>> TreatMovesAsRemoveAdd(IObservable`1<ISortedChangeSet`2<TObject, TKey>> source);
    [ExtensionAttribute]
public static IObservable`1<bool> TrueForAll(IObservable`1<IChangeSet`2<TObject, TKey>> source, Func`2<TObject, IObservable`1<TValue>> observableSelector, Func`2<TValue, bool> equalityCondition);
    [ExtensionAttribute]
public static IObservable`1<bool> TrueForAll(IObservable`1<IChangeSet`2<TObject, TKey>> source, Func`2<TObject, IObservable`1<TValue>> observableSelector, Func`3<TObject, TValue, bool> equalityCondition);
    [ExtensionAttribute]
public static IObservable`1<bool> TrueForAny(IObservable`1<IChangeSet`2<TObject, TKey>> source, Func`2<TObject, IObservable`1<TValue>> observableSelector, Func`3<TObject, TValue, bool> equalityCondition);
    [ExtensionAttribute]
public static IObservable`1<bool> TrueForAny(IObservable`1<IChangeSet`2<TObject, TKey>> source, Func`2<TObject, IObservable`1<TValue>> observableSelector, Func`2<TValue, bool> equalityCondition);
    [ExtensionAttribute]
public static IObservable`1<ISortedChangeSet`2<TObject, TKey>> UpdateIndex(IObservable`1<ISortedChangeSet`2<TObject, TKey>> source);
    [ExtensionAttribute]
public static IObservable`1<Change`2<TObject, TKey>> Watch(IObservable`1<IChangeSet`2<TObject, TKey>> source, TKey key);
    [ExtensionAttribute]
public static IObservable`1<TObject> WatchValue(IObservableCache`2<TObject, TKey> source, TKey key);
    [ExtensionAttribute]
public static IObservable`1<TObject> WatchValue(IObservable`1<IChangeSet`2<TObject, TKey>> source, TKey key);
    [ExtensionAttribute]
public static IObservable`1<TObject> WhenAnyPropertyChanged(IObservable`1<IChangeSet`2<TObject, TKey>> source, String[] propertiesToMonitor);
    [ExtensionAttribute]
public static IObservable`1<PropertyValue`2<TObject, TValue>> WhenPropertyChanged(IObservable`1<IChangeSet`2<TObject, TKey>> source, Expression`1<Func`2<TObject, TValue>> propertyAccessor, bool notifyOnInitialValue);
    [ExtensionAttribute]
public static IObservable`1<TValue> WhenValueChanged(IObservable`1<IChangeSet`2<TObject, TKey>> source, Expression`1<Func`2<TObject, TValue>> propertyAccessor, bool notifyOnInitialValue);
    [ExtensionAttribute]
public static IObservable`1<IChangeSet`2<TObject, TKey>> WhereReasonsAre(IObservable`1<IChangeSet`2<TObject, TKey>> source, ChangeReason[] reasons);
    [ExtensionAttribute]
public static IObservable`1<IChangeSet`2<TObject, TKey>> WhereReasonsAreNot(IObservable`1<IChangeSet`2<TObject, TKey>> source, ChangeReason[] reasons);
    [ExtensionAttribute]
public static IObservable`1<IChangeSet`2<TObject, TKey>> Xor(IObservable`1<IChangeSet`2<TObject, TKey>> source, IObservable`1[] others);
    [ExtensionAttribute]
public static IObservable`1<IChangeSet`2<TObject, TKey>> Xor(ICollection`1<IObservable`1<IChangeSet`2<TObject, TKey>>> sources);
    [ExtensionAttribute]
public static IObservable`1<IChangeSet`2<TObject, TKey>> Xor(IObservableList`1<IObservable`1<IChangeSet`2<TObject, TKey>>> sources);
    [ExtensionAttribute]
public static IObservable`1<IChangeSet`2<TObject, TKey>> Xor(IObservableList`1<IObservableCache`2<TObject, TKey>> sources);
    [ExtensionAttribute]
public static IObservable`1<IChangeSet`2<TObject, TKey>> Xor(IObservableList`1<ISourceCache`2<TObject, TKey>> sources);
    [ExtensionAttribute]
private static IObservable`1<IChangeSet`2<TObject, TKey>> Combine(IObservableList`1<IObservableCache`2<TObject, TKey>> source, CombineOperator type);
    [ExtensionAttribute]
private static IObservable`1<IChangeSet`2<TObject, TKey>> Combine(IObservableList`1<ISourceCache`2<TObject, TKey>> source, CombineOperator type);
    [ExtensionAttribute]
private static IObservable`1<IChangeSet`2<TObject, TKey>> Combine(IObservableList`1<IObservable`1<IChangeSet`2<TObject, TKey>>> source, CombineOperator type);
    [ExtensionAttribute]
private static IObservable`1<IChangeSet`2<TObject, TKey>> Combine(ICollection`1<IObservable`1<IChangeSet`2<TObject, TKey>>> sources, CombineOperator type);
    [ExtensionAttribute]
private static IObservable`1<IChangeSet`2<TObject, TKey>> Combine(IObservable`1<IChangeSet`2<TObject, TKey>> source, CombineOperator type, IObservable`1[] combineTarget);
    [NullableContextAttribute("2")]
[ExtensionAttribute]
private static IObservable`1<Func`3<TSource, TKey, bool>> ForForced(IObservable`1<Unit> source);
    [ExtensionAttribute]
private static IObservable`1<Func`3<TSource, TKey, bool>> ForForced(IObservable`1<Func`2<TSource, bool>> source);
    [ExtensionAttribute]
private static IObservable`1<IChangeSet`2<TObject, TKey>> OnChangeAction(IObservable`1<IChangeSet`2<TObject, TKey>> source, Predicate`1<Change`2<TObject, TKey>> predicate, Action`1<Change`2<TObject, TKey>> changeAction);
    private static Func`3<TObject, TKey, TResult> AdaptSelector(Func`2<TObject, TResult> other);
    [ExtensionAttribute]
private static IObservable`1<IChangeSet`2<TObject, TKey>> OnChangeAction(IObservable`1<IChangeSet`2<TObject, TKey>> source, ChangeReason reason, Action`2<TObject, TKey> action);
    [ExtensionAttribute]
private static IObservable`1<bool> TrueFor(IObservable`1<IChangeSet`2<TObject, TKey>> source, Func`2<TObject, IObservable`1<TValue>> observableSelector, Func`2<IEnumerable`1<ObservableWithValue`2<TObject, TValue>>, bool> collectionMatcher);
    private static Func`3<TSource, TSourceKey, Task`1<IObservable`1<IChangeSet`2<TDestination, TDestinationKey>>>> CreateChangeSetTranformer(Func`3<TSource, TSourceKey, Task`1<IEnumerable`1<TDestination>>> manySelector, Func`2<TDestination, TDestinationKey> keySelector);
    private static Func`3<TSource, TSourceKey, Task`1<IObservable`1<IChangeSet`2<TDestination, TDestinationKey>>>> CreateChangeSetTranformer(Func`3<TSource, TSourceKey, Task`1<TCollection>> manySelector, Func`2<TDestination, TDestinationKey> keySelector);
    private static Func`3<TSource, TSourceKey, Task`1<IObservable`1<IChangeSet`2<TDestination, TDestinationKey>>>> CreateChangeSetTranformer(Func`3<TSource, TSourceKey, Task`1<IObservableCache`2<TDestination, TDestinationKey>>> manySelector);
    [ExtensionAttribute]
public static IObservable`1<IChangeSet`2<TObject, TKey>> Bind(IObservable`1<IChangeSet`3<TObject, TKey, PageContext`1<TObject>>> source, ReadOnlyObservableCollection`1& readOnlyObservableCollection);
    [ExtensionAttribute]
public static IObservable`1<IChangeSet`2<TObject, TKey>> Bind(IObservable`1<IChangeSet`3<TObject, TKey, PageContext`1<TObject>>> source, ReadOnlyObservableCollection`1& readOnlyObservableCollection, SortAndBindOptions options);
    [ExtensionAttribute]
public static IObservable`1<IChangeSet`2<TObject, TKey>> Bind(IObservable`1<IChangeSet`3<TObject, TKey, PageContext`1<TObject>>> source, IList`1<TObject> targetList);
    [ExtensionAttribute]
public static IObservable`1<IChangeSet`2<TObject, TKey>> Bind(IObservable`1<IChangeSet`3<TObject, TKey, PageContext`1<TObject>>> source, IList`1<TObject> targetList, SortAndBindOptions options);
    [ExtensionAttribute]
public static IObservable`1<IChangeSet`2<TObject, TKey>> Bind(IObservable`1<IChangeSet`3<TObject, TKey, VirtualContext`1<TObject>>> source, ReadOnlyObservableCollection`1& readOnlyObservableCollection);
    [ExtensionAttribute]
public static IObservable`1<IChangeSet`2<TObject, TKey>> Bind(IObservable`1<IChangeSet`3<TObject, TKey, VirtualContext`1<TObject>>> source, ReadOnlyObservableCollection`1& readOnlyObservableCollection, SortAndBindOptions options);
    [ExtensionAttribute]
public static IObservable`1<IChangeSet`2<TObject, TKey>> Bind(IObservable`1<IChangeSet`3<TObject, TKey, VirtualContext`1<TObject>>> source, IList`1<TObject> targetList);
    [ExtensionAttribute]
public static IObservable`1<IChangeSet`2<TObject, TKey>> Bind(IObservable`1<IChangeSet`3<TObject, TKey, VirtualContext`1<TObject>>> source, IList`1<TObject> targetList, SortAndBindOptions options);
    [ExtensionAttribute]
public static IObservable`1<IChangeSet`2<TObject, TKey>> SortAndBind(IObservable`1<IChangeSet`2<TObject, TKey>> source, IList`1<TObject> targetList);
    [ExtensionAttribute]
public static IObservable`1<IChangeSet`2<TObject, TKey>> SortAndBind(IObservable`1<IChangeSet`2<TObject, TKey>> source, IList`1<TObject> targetList, SortAndBindOptions options);
    [ExtensionAttribute]
public static IObservable`1<IChangeSet`2<TObject, TKey>> SortAndBind(IObservable`1<IChangeSet`2<TObject, TKey>> source, IList`1<TObject> targetList, IComparer`1<TObject> comparer);
    [ExtensionAttribute]
public static IObservable`1<IChangeSet`2<TObject, TKey>> SortAndBind(IObservable`1<IChangeSet`2<TObject, TKey>> source, IList`1<TObject> targetList, IComparer`1<TObject> comparer, SortAndBindOptions options);
    [ExtensionAttribute]
public static IObservable`1<IChangeSet`2<TObject, TKey>> SortAndBind(IObservable`1<IChangeSet`2<TObject, TKey>> source, IList`1<TObject> targetList, IObservable`1<IComparer`1<TObject>> comparerChanged);
    [ExtensionAttribute]
public static IObservable`1<IChangeSet`2<TObject, TKey>> SortAndBind(IObservable`1<IChangeSet`2<TObject, TKey>> source, IList`1<TObject> targetList, IObservable`1<IComparer`1<TObject>> comparerChanged, SortAndBindOptions options);
    [ExtensionAttribute]
public static IObservable`1<IChangeSet`2<TObject, TKey>> SortAndBind(IObservable`1<IChangeSet`2<TObject, TKey>> source, ReadOnlyObservableCollection`1& readOnlyObservableCollection);
    [ExtensionAttribute]
public static IObservable`1<IChangeSet`2<TObject, TKey>> SortAndBind(IObservable`1<IChangeSet`2<TObject, TKey>> source, ReadOnlyObservableCollection`1& readOnlyObservableCollection, SortAndBindOptions options);
    [ExtensionAttribute]
public static IObservable`1<IChangeSet`2<TObject, TKey>> SortAndBind(IObservable`1<IChangeSet`2<TObject, TKey>> source, ReadOnlyObservableCollection`1& readOnlyObservableCollection, IComparer`1<TObject> comparer);
    [ExtensionAttribute]
public static IObservable`1<IChangeSet`2<TObject, TKey>> SortAndBind(IObservable`1<IChangeSet`2<TObject, TKey>> source, ReadOnlyObservableCollection`1& readOnlyObservableCollection, IComparer`1<TObject> comparer, SortAndBindOptions options);
    [ExtensionAttribute]
public static IObservable`1<IChangeSet`2<TObject, TKey>> SortAndBind(IObservable`1<IChangeSet`2<TObject, TKey>> source, ReadOnlyObservableCollection`1& readOnlyObservableCollection, IObservable`1<IComparer`1<TObject>> comparerChanged);
    [ExtensionAttribute]
public static IObservable`1<IChangeSet`2<TObject, TKey>> SortAndBind(IObservable`1<IChangeSet`2<TObject, TKey>> source, ReadOnlyObservableCollection`1& readOnlyObservableCollection, IObservable`1<IComparer`1<TObject>> comparerChanged, SortAndBindOptions options);
    [ExtensionAttribute]
public static IObservable`1<IChangeSet`3<TObject, TKey, VirtualContext`1<TObject>>> SortAndVirtualize(IObservable`1<IChangeSet`2<TObject, TKey>> source, IComparer`1<TObject> comparer, IObservable`1<IVirtualRequest> virtualRequests);
    [ExtensionAttribute]
public static IObservable`1<IChangeSet`3<TObject, TKey, VirtualContext`1<TObject>>> SortAndVirtualize(IObservable`1<IChangeSet`2<TObject, TKey>> source, IObservable`1<IComparer`1<TObject>> comparerChanged, IObservable`1<IVirtualRequest> virtualRequests);
    [ExtensionAttribute]
public static IObservable`1<IChangeSet`3<TObject, TKey, VirtualContext`1<TObject>>> SortAndVirtualize(IObservable`1<IChangeSet`2<TObject, TKey>> source, IComparer`1<TObject> comparer, IObservable`1<IVirtualRequest> virtualRequests, SortAndVirtualizeOptions options);
    [ExtensionAttribute]
public static IObservable`1<IChangeSet`3<TObject, TKey, VirtualContext`1<TObject>>> SortAndVirtualize(IObservable`1<IChangeSet`2<TObject, TKey>> source, IObservable`1<IComparer`1<TObject>> comparerChanged, IObservable`1<IVirtualRequest> virtualRequests, SortAndVirtualizeOptions options);
    [ExtensionAttribute]
[ObsoleteAttribute("Use SortAndVirtualize as it's more efficient")]
public static IObservable`1<IVirtualChangeSet`2<TObject, TKey>> Virtualise(IObservable`1<ISortedChangeSet`2<TObject, TKey>> source, IObservable`1<IVirtualRequest> virtualRequests);
    [ExtensionAttribute]
public static IObservable`1<IChangeSet`3<TObject, TKey, VirtualContext`1<TObject>>> Top(IObservable`1<IChangeSet`2<TObject, TKey>> source, IComparer`1<TObject> comparer, int size);
    [ExtensionAttribute]
[ObsoleteAttribute("Use Overload with comparer as it's more efficient")]
public static IObservable`1<IVirtualChangeSet`2<TObject, TKey>> Top(IObservable`1<ISortedChangeSet`2<TObject, TKey>> source, int size);
    [ExtensionAttribute]
public static IObservable`1<IChangeSet`3<TObject, TKey, PageContext`1<TObject>>> SortAndPage(IObservable`1<IChangeSet`2<TObject, TKey>> source, IComparer`1<TObject> comparer, IObservable`1<IPageRequest> pageRequests);
    [ExtensionAttribute]
public static IObservable`1<IChangeSet`3<TObject, TKey, PageContext`1<TObject>>> SortAndPage(IObservable`1<IChangeSet`2<TObject, TKey>> source, IObservable`1<IComparer`1<TObject>> comparerChanged, IObservable`1<IPageRequest> pageRequests);
    [ExtensionAttribute]
public static IObservable`1<IChangeSet`3<TObject, TKey, PageContext`1<TObject>>> SortAndPage(IObservable`1<IChangeSet`2<TObject, TKey>> source, IComparer`1<TObject> comparer, IObservable`1<IPageRequest> pageRequests, SortAndPageOptions options);
    [ExtensionAttribute]
public static IObservable`1<IChangeSet`3<TObject, TKey, PageContext`1<TObject>>> SortAndPage(IObservable`1<IChangeSet`2<TObject, TKey>> source, IObservable`1<IComparer`1<TObject>> comparerChanged, IObservable`1<IPageRequest> pageRequests, SortAndPageOptions options);
    [ExtensionAttribute]
[ObsoleteAttribute("Use SortAndPage as it's more efficient")]
public static IObservable`1<IPagedChangeSet`2<TObject, TKey>> Page(IObservable`1<ISortedChangeSet`2<TObject, TKey>> source, IObservable`1<IPageRequest> pageRequests);
    [IteratorStateMachineAttribute("DynamicData.ObservableCacheEx/<<TreatMovesAsRemoveAdd>g__ReplaceMoves|259_0>d`2")]
[CompilerGeneratedAttribute]
internal static IEnumerable`1<Change`2<TObject, TKey>> <TreatMovesAsRemoveAdd>g__ReplaceMoves|259_0(IChangeSet`2<TObject, TKey> items);
    [NullableContextAttribute("0")]
[CompilerGeneratedAttribute]
internal static bool <ForForced>g__Transformer|283_1(TSource item, TKey key);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public static class DynamicData.ObservableChangeSet : object {
    public static IObservable`1<IChangeSet`2<TObject, TKey>> Create(Func`2<ISourceCache`2<TObject, TKey>, Action> subscribe, Func`2<TObject, TKey> keySelector);
    public static IObservable`1<IChangeSet`2<TObject, TKey>> Create(Func`2<ISourceCache`2<TObject, TKey>, IDisposable> subscribe, Func`2<TObject, TKey> keySelector);
    public static IObservable`1<IChangeSet`2<TObject, TKey>> Create(Func`2<ISourceCache`2<TObject, TKey>, Task`1<IDisposable>> subscribe, Func`2<TObject, TKey> keySelector);
    public static IObservable`1<IChangeSet`2<TObject, TKey>> Create(Func`3<ISourceCache`2<TObject, TKey>, CancellationToken, Task`1<IDisposable>> subscribe, Func`2<TObject, TKey> keySelector);
    public static IObservable`1<IChangeSet`2<TObject, TKey>> Create(Func`2<ISourceCache`2<TObject, TKey>, Task`1<Action>> subscribe, Func`2<TObject, TKey> keySelector);
    public static IObservable`1<IChangeSet`2<TObject, TKey>> Create(Func`3<ISourceCache`2<TObject, TKey>, CancellationToken, Task`1<Action>> subscribe, Func`2<TObject, TKey> keySelector);
    public static IObservable`1<IChangeSet`2<TObject, TKey>> Create(Func`2<ISourceCache`2<TObject, TKey>, Task> subscribe, Func`2<TObject, TKey> keySelector);
    public static IObservable`1<IChangeSet`2<TObject, TKey>> Create(Func`3<ISourceCache`2<TObject, TKey>, CancellationToken, Task> subscribe, Func`2<TObject, TKey> keySelector);
    public static IObservable`1<IChangeSet`1<T>> Create(Func`2<ISourceList`1<T>, Action> subscribe);
    public static IObservable`1<IChangeSet`1<T>> Create(Func`2<ISourceList`1<T>, IDisposable> subscribe);
    public static IObservable`1<IChangeSet`1<T>> Create(Func`2<ISourceList`1<T>, Task`1<IDisposable>> subscribe);
    public static IObservable`1<IChangeSet`1<T>> Create(Func`3<ISourceList`1<T>, CancellationToken, Task`1<IDisposable>> subscribe);
    public static IObservable`1<IChangeSet`1<T>> Create(Func`2<ISourceList`1<T>, Task`1<Action>> subscribe);
    public static IObservable`1<IChangeSet`1<T>> Create(Func`3<ISourceList`1<T>, CancellationToken, Task`1<Action>> subscribe);
    public static IObservable`1<IChangeSet`1<T>> Create(Func`2<ISourceList`1<T>, Task> subscribe);
    public static IObservable`1<IChangeSet`1<T>> Create(Func`3<ISourceList`1<T>, CancellationToken, Task> subscribe);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
public static class DynamicData.ObservableListEx : object {
    [ExtensionAttribute]
public static IObservable`1<IChangeSet`1<T>> Adapt(IObservable`1<IChangeSet`1<T>> source, IChangeSetAdaptor`1<T> adaptor);
    [ExtensionAttribute]
public static IObservable`1<IChangeSet`2<TObject, TKey>> AddKey(IObservable`1<IChangeSet`1<TObject>> source, Func`2<TObject, TKey> keySelector);
    [ExtensionAttribute]
public static IObservable`1<IChangeSet`1<T>> And(IObservable`1<IChangeSet`1<T>> source, IObservable`1[] others);
    [ExtensionAttribute]
public static IObservable`1<IChangeSet`1<T>> And(ICollection`1<IObservable`1<IChangeSet`1<T>>> sources);
    [ExtensionAttribute]
public static IObservable`1<IChangeSet`1<T>> And(IObservableList`1<IObservable`1<IChangeSet`1<T>>> sources);
    [ExtensionAttribute]
public static IObservable`1<IChangeSet`1<T>> And(IObservableList`1<IObservableList`1<T>> sources);
    [ExtensionAttribute]
public static IObservable`1<IChangeSet`1<T>> And(IObservableList`1<ISourceList`1<T>> sources);
    [ExtensionAttribute]
public static IObservableList`1<T> AsObservableList(ISourceList`1<T> source);
    [ExtensionAttribute]
public static IObservableList`1<T> AsObservableList(IObservable`1<IChangeSet`1<T>> source);
    [ExtensionAttribute]
public static IObservable`1<IChangeSet`1<TObject>> AutoRefresh(IObservable`1<IChangeSet`1<TObject>> source, Nullable`1<TimeSpan> changeSetBuffer, Nullable`1<TimeSpan> propertyChangeThrottle, IScheduler scheduler);
    [ExtensionAttribute]
public static IObservable`1<IChangeSet`1<TObject>> AutoRefresh(IObservable`1<IChangeSet`1<TObject>> source, Expression`1<Func`2<TObject, TProperty>> propertyAccessor, Nullable`1<TimeSpan> changeSetBuffer, Nullable`1<TimeSpan> propertyChangeThrottle, IScheduler scheduler);
    [ExtensionAttribute]
public static IObservable`1<IChangeSet`1<TObject>> AutoRefreshOnObservable(IObservable`1<IChangeSet`1<TObject>> source, Func`2<TObject, IObservable`1<TAny>> reevaluator, Nullable`1<TimeSpan> changeSetBuffer, IScheduler scheduler);
    [ExtensionAttribute]
public static IObservable`1<IChangeSet`1<T>> Bind(IObservable`1<IChangeSet`1<T>> source, IObservableCollection`1<T> targetCollection, int resetThreshold);
    [ExtensionAttribute]
public static IObservable`1<IChangeSet`1<T>> Bind(IObservable`1<IChangeSet`1<T>> source, IObservableCollection`1<T> targetCollection, BindingOptions options);
    [ExtensionAttribute]
public static IObservable`1<IChangeSet`1<T>> Bind(IObservable`1<IChangeSet`1<T>> source, ReadOnlyObservableCollection`1& readOnlyObservableCollection, int resetThreshold);
    [ExtensionAttribute]
public static IObservable`1<IChangeSet`1<T>> Bind(IObservable`1<IChangeSet`1<T>> source, ReadOnlyObservableCollection`1& readOnlyObservableCollection, BindingOptions options);
    [ExtensionAttribute]
public static IObservable`1<IChangeSet`1<T>> Bind(IObservable`1<IChangeSet`1<T>> source, BindingList`1<T> bindingList, int resetThreshold);
    [ExtensionAttribute]
public static IObservable`1<IChangeSet`1<T>> BufferIf(IObservable`1<IChangeSet`1<T>> source, IObservable`1<bool> pauseIfTrueSelector, IScheduler scheduler);
    [ExtensionAttribute]
public static IObservable`1<IChangeSet`1<T>> BufferIf(IObservable`1<IChangeSet`1<T>> source, IObservable`1<bool> pauseIfTrueSelector, bool initialPauseState, IScheduler scheduler);
    [ExtensionAttribute]
public static IObservable`1<IChangeSet`1<T>> BufferIf(IObservable`1<IChangeSet`1<T>> source, IObservable`1<bool> pauseIfTrueSelector, Nullable`1<TimeSpan> timeOut, IScheduler scheduler);
    [ExtensionAttribute]
public static IObservable`1<IChangeSet`1<T>> BufferIf(IObservable`1<IChangeSet`1<T>> source, IObservable`1<bool> pauseIfTrueSelector, bool initialPauseState, Nullable`1<TimeSpan> timeOut, IScheduler scheduler);
    [ExtensionAttribute]
public static IObservable`1<IChangeSet`1<TObject>> BufferInitial(IObservable`1<IChangeSet`1<TObject>> source, TimeSpan initialBuffer, IScheduler scheduler);
    [ExtensionAttribute]
public static IObservable`1<IChangeSet`1<TDestination>> Cast(IObservable`1<IChangeSet`1<object>> source);
    [ExtensionAttribute]
public static IObservable`1<IChangeSet`1<TDestination>> Cast(IObservable`1<IChangeSet`1<TSource>> source, Func`2<TSource, TDestination> conversionFactory);
    [ExtensionAttribute]
public static IObservable`1<IChangeSet`1<object>> CastToObject(IObservable`1<IChangeSet`1<T>> source);
    [ExtensionAttribute]
public static IObservable`1<IChangeSet`1<T>> Clone(IObservable`1<IChangeSet`1<T>> source, IList`1<T> target);
    [ExtensionAttribute]
[ObsoleteAttribute("Prefer Cast as it is does the same thing but is semantically correct")]
public static IObservable`1<IChangeSet`1<TDestination>> Convert(IObservable`1<IChangeSet`1<TObject>> source, Func`2<TObject, TDestination> conversionFactory);
    [ExtensionAttribute]
public static IObservable`1<IChangeSet`1<T>> DeferUntilLoaded(IObservable`1<IChangeSet`1<T>> source);
    [ExtensionAttribute]
public static IObservable`1<IChangeSet`1<T>> DeferUntilLoaded(IObservableList`1<T> source);
    [ExtensionAttribute]
public static IObservable`1<IChangeSet`1<T>> DisposeMany(IObservable`1<IChangeSet`1<T>> source);
    [ExtensionAttribute]
public static IObservable`1<IChangeSet`1<TValue>> DistinctValues(IObservable`1<IChangeSet`1<TObject>> source, Func`2<TObject, TValue> valueSelector);
    [ExtensionAttribute]
public static IObservable`1<IChangeSet`1<T>> Except(IObservable`1<IChangeSet`1<T>> source, IObservable`1[] others);
    [ExtensionAttribute]
public static IObservable`1<IChangeSet`1<T>> Except(ICollection`1<IObservable`1<IChangeSet`1<T>>> sources);
    [ExtensionAttribute]
public static IObservable`1<IChangeSet`1<T>> Except(IObservableList`1<IObservable`1<IChangeSet`1<T>>> sources);
    [ExtensionAttribute]
public static IObservable`1<IChangeSet`1<T>> Except(IObservableList`1<IObservableList`1<T>> sources);
    [ExtensionAttribute]
public static IObservable`1<IChangeSet`1<T>> Except(IObservableList`1<ISourceList`1<T>> sources);
    [ExtensionAttribute]
public static IObservable`1<IEnumerable`1<T>> ExpireAfter(ISourceList`1<T> source, Func`2<T, Nullable`1<TimeSpan>> timeSelector, Nullable`1<TimeSpan> pollingInterval, IScheduler scheduler);
    [ExtensionAttribute]
public static IObservable`1<IChangeSet`1<T>> Filter(IObservable`1<IChangeSet`1<T>> source, Func`2<T, bool> predicate);
    [ExtensionAttribute]
public static IObservable`1<IChangeSet`1<T>> Filter(IObservable`1<IChangeSet`1<T>> source, IObservable`1<Func`2<T, bool>> predicate, ListFilterPolicy filterPolicy);
    [ExtensionAttribute]
public static IObservable`1<IChangeSet`1<TObject>> FilterOnObservable(IObservable`1<IChangeSet`1<TObject>> source, Func`2<TObject, IObservable`1<bool>> objectFilterObservable, Nullable`1<TimeSpan> propertyChangedThrottle, IScheduler scheduler);
    [ExtensionAttribute]
[ObsoleteAttribute("Use AutoRefresh(), followed by Filter() instead")]
public static IObservable`1<IChangeSet`1<TObject>> FilterOnProperty(IObservable`1<IChangeSet`1<TObject>> source, Expression`1<Func`2<TObject, TProperty>> propertySelector, Func`2<TObject, bool> predicate, Nullable`1<TimeSpan> propertyChangedThrottle, IScheduler scheduler);
    [ExtensionAttribute]
public static IObservable`1<IChangeSet`1<T>> FlattenBufferResult(IObservable`1<IList`1<IChangeSet`1<T>>> source);
    [ExtensionAttribute]
public static IObservable`1<IChangeSet`1<TObject>> ForEachChange(IObservable`1<IChangeSet`1<TObject>> source, Action`1<Change`1<TObject>> action);
    [ExtensionAttribute]
public static IObservable`1<IChangeSet`1<TObject>> ForEachItemChange(IObservable`1<IChangeSet`1<TObject>> source, Action`1<ItemChange`1<TObject>> action);
    [ExtensionAttribute]
public static IObservable`1<IChangeSet`1<IGroup`2<TObject, TGroup>>> GroupOn(IObservable`1<IChangeSet`1<TObject>> source, Func`2<TObject, TGroup> groupSelector, IObservable`1<Unit> regrouper);
    [ExtensionAttribute]
public static IObservable`1<IChangeSet`1<IGroup`2<TObject, TGroup>>> GroupOnProperty(IObservable`1<IChangeSet`1<TObject>> source, Expression`1<Func`2<TObject, TGroup>> propertySelector, Nullable`1<TimeSpan> propertyChangedThrottle, IScheduler scheduler);
    [ExtensionAttribute]
public static IObservable`1<IChangeSet`1<IGrouping`2<TObject, TGroup>>> GroupOnPropertyWithImmutableState(IObservable`1<IChangeSet`1<TObject>> source, Expression`1<Func`2<TObject, TGroup>> propertySelector, Nullable`1<TimeSpan> propertyChangedThrottle, IScheduler scheduler);
    [ExtensionAttribute]
public static IObservable`1<IChangeSet`1<IGrouping`2<TObject, TGroupKey>>> GroupWithImmutableState(IObservable`1<IChangeSet`1<TObject>> source, Func`2<TObject, TGroupKey> groupSelectorKey, IObservable`1<Unit> regrouper);
    [ExtensionAttribute]
public static IObservable`1<IEnumerable`1<T>> LimitSizeTo(ISourceList`1<T> source, int sizeLimit, IScheduler scheduler);
    [ExtensionAttribute]
public static IObservable`1<TDestination> MergeMany(IObservable`1<IChangeSet`1<T>> source, Func`2<T, IObservable`1<TDestination>> observableSelector);
    [ExtensionAttribute]
public static IObservable`1<IChangeSet`1<TObject>> MergeChangeSets(IObservable`1<IObservable`1<IChangeSet`1<TObject>>> source, IEqualityComparer`1<TObject> equalityComparer);
    [ExtensionAttribute]
public static IObservable`1<IChangeSet`1<TObject>> MergeChangeSets(IObservable`1<IChangeSet`1<TObject>> source, IObservable`1<IChangeSet`1<TObject>> other, IEqualityComparer`1<TObject> equalityComparer, IScheduler scheduler, bool completable);
    [ExtensionAttribute]
public static IObservable`1<IChangeSet`1<TObject>> MergeChangeSets(IObservable`1<IChangeSet`1<TObject>> source, IEnumerable`1<IObservable`1<IChangeSet`1<TObject>>> others, IEqualityComparer`1<TObject> equalityComparer, IScheduler scheduler, bool completable);
    [ExtensionAttribute]
public static IObservable`1<IChangeSet`1<TObject>> MergeChangeSets(IEnumerable`1<IObservable`1<IChangeSet`1<TObject>>> source, IEqualityComparer`1<TObject> equalityComparer, IScheduler scheduler, bool completable);
    [ExtensionAttribute]
public static IObservable`1<IChangeSet`1<TObject>> MergeChangeSets(IObservableList`1<IObservable`1<IChangeSet`1<TObject>>> source, IEqualityComparer`1<TObject> equalityComparer);
    [ExtensionAttribute]
public static IObservable`1<IChangeSet`1<TObject>> MergeChangeSets(IObservable`1<IChangeSet`1<IObservable`1<IChangeSet`1<TObject>>>> source, IEqualityComparer`1<TObject> equalityComparer);
    [ExtensionAttribute]
public static IObservable`1<IChangeSet`2<TObject, TKey>> MergeChangeSets(IObservableList`1<IObservable`1<IChangeSet`2<TObject, TKey>>> source, IComparer`1<TObject> comparer);
    [ExtensionAttribute]
public static IObservable`1<IChangeSet`2<TObject, TKey>> MergeChangeSets(IObservableList`1<IObservable`1<IChangeSet`2<TObject, TKey>>> source, IEqualityComparer`1<TObject> equalityComparer, IComparer`1<TObject> comparer);
    [ExtensionAttribute]
public static IObservable`1<IChangeSet`2<TObject, TKey>> MergeChangeSets(IObservable`1<IChangeSet`1<IObservable`1<IChangeSet`2<TObject, TKey>>>> source, IComparer`1<TObject> comparer);
    [ExtensionAttribute]
public static IObservable`1<IChangeSet`2<TObject, TKey>> MergeChangeSets(IObservable`1<IChangeSet`1<IObservable`1<IChangeSet`2<TObject, TKey>>>> source, IEqualityComparer`1<TObject> equalityComparer, IComparer`1<TObject> comparer);
    [ExtensionAttribute]
public static IObservable`1<IChangeSet`1<TDestination>> MergeManyChangeSets(IObservable`1<IChangeSet`1<TObject>> source, Func`2<TObject, IObservable`1<IChangeSet`1<TDestination>>> observableSelector, IEqualityComparer`1<TDestination> equalityComparer);
    [ExtensionAttribute]
public static IObservable`1<IChangeSet`2<TDestination, TDestinationKey>> MergeManyChangeSets(IObservable`1<IChangeSet`1<TObject>> source, Func`2<TObject, IObservable`1<IChangeSet`2<TDestination, TDestinationKey>>> observableSelector, IComparer`1<TDestination> comparer);
    [ExtensionAttribute]
public static IObservable`1<IChangeSet`2<TDestination, TDestinationKey>> MergeManyChangeSets(IObservable`1<IChangeSet`1<TObject>> source, Func`2<TObject, IObservable`1<IChangeSet`2<TDestination, TDestinationKey>>> observableSelector, IEqualityComparer`1<TDestination> equalityComparer, IComparer`1<TDestination> comparer);
    [ExtensionAttribute]
public static IObservable`1<IChangeSet`1<T>> NotEmpty(IObservable`1<IChangeSet`1<T>> source);
    [ExtensionAttribute]
public static IObservable`1<IChangeSet`1<T>> OnItemAdded(IObservable`1<IChangeSet`1<T>> source, Action`1<T> addAction);
    [ExtensionAttribute]
public static IObservable`1<IChangeSet`1<TObject>> OnItemRefreshed(IObservable`1<IChangeSet`1<TObject>> source, Action`1<TObject> refreshAction);
    [ExtensionAttribute]
public static IObservable`1<IChangeSet`1<T>> OnItemRemoved(IObservable`1<IChangeSet`1<T>> source, Action`1<T> removeAction, bool invokeOnUnsubscribe);
    [ExtensionAttribute]
public static IObservable`1<IChangeSet`1<T>> Or(ICollection`1<IObservable`1<IChangeSet`1<T>>> sources);
    [ExtensionAttribute]
public static IObservable`1<IChangeSet`1<T>> Or(IObservable`1<IChangeSet`1<T>> source, IObservable`1[] others);
    [ExtensionAttribute]
public static IObservable`1<IChangeSet`1<T>> Or(IObservableList`1<IObservable`1<IChangeSet`1<T>>> sources);
    [ExtensionAttribute]
public static IObservable`1<IChangeSet`1<T>> Or(IObservableList`1<IObservableList`1<T>> sources);
    [ExtensionAttribute]
public static IObservable`1<IChangeSet`1<T>> Or(IObservableList`1<ISourceList`1<T>> sources);
    [ExtensionAttribute]
public static IObservable`1<IPageChangeSet`1<T>> Page(IObservable`1<IChangeSet`1<T>> source, IObservable`1<IPageRequest> requests);
    [ExtensionAttribute]
public static IDisposable PopulateInto(IObservable`1<IChangeSet`1<T>> source, ISourceList`1<T> destination);
    [ExtensionAttribute]
public static IObservable`1<TDestination> QueryWhenChanged(IObservable`1<IChangeSet`1<TObject>> source, Func`2<IReadOnlyCollection`1<TObject>, TDestination> resultSelector);
    [ExtensionAttribute]
public static IObservable`1<IReadOnlyCollection`1<T>> QueryWhenChanged(IObservable`1<IChangeSet`1<T>> source);
    [ExtensionAttribute]
public static IObservable`1<IChangeSet`1<T>> RefCount(IObservable`1<IChangeSet`1<T>> source);
    [ExtensionAttribute]
public static IObservable`1<IChangeSet`1<T>> RemoveIndex(IObservable`1<IChangeSet`1<T>> source);
    [ExtensionAttribute]
public static IObservable`1<IChangeSet`1<T>> Reverse(IObservable`1<IChangeSet`1<T>> source);
    [ExtensionAttribute]
public static IObservable`1<IChangeSet`1<T>> SkipInitial(IObservable`1<IChangeSet`1<T>> source);
    [ExtensionAttribute]
public static IObservable`1<IChangeSet`1<T>> Sort(IObservable`1<IChangeSet`1<T>> source, IComparer`1<T> comparer, SortOptions options, IObservable`1<Unit> resort, IObservable`1<IComparer`1<T>> comparerChanged, int resetThreshold);
    [ExtensionAttribute]
public static IObservable`1<IChangeSet`1<T>> Sort(IObservable`1<IChangeSet`1<T>> source, IObservable`1<IComparer`1<T>> comparerChanged, SortOptions options, IObservable`1<Unit> resort, int resetThreshold);
    [ExtensionAttribute]
public static IObservable`1<IChangeSet`1<T>> StartWithEmpty(IObservable`1<IChangeSet`1<T>> source);
    [ExtensionAttribute]
public static IObservable`1<IChangeSet`1<T>> SubscribeMany(IObservable`1<IChangeSet`1<T>> source, Func`2<T, IDisposable> subscriptionFactory);
    [ExtensionAttribute]
public static IObservable`1<IChangeSet`1<T>> SuppressRefresh(IObservable`1<IChangeSet`1<T>> source);
    [ExtensionAttribute]
public static IObservable`1<IChangeSet`1<T>> Switch(IObservable`1<IObservableList`1<T>> sources);
    [ExtensionAttribute]
public static IObservable`1<IChangeSet`1<T>> Switch(IObservable`1<IObservable`1<IChangeSet`1<T>>> sources);
    [ExtensionAttribute]
public static IObservable`1<IReadOnlyCollection`1<TObject>> ToCollection(IObservable`1<IChangeSet`1<TObject>> source);
    [ExtensionAttribute]
public static IObservable`1<IChangeSet`1<T>> ToObservableChangeSet(IObservable`1<T> source, IScheduler scheduler);
    [ExtensionAttribute]
public static IObservable`1<IChangeSet`1<T>> ToObservableChangeSet(IObservable`1<T> source, Func`2<T, Nullable`1<TimeSpan>> expireAfter, IScheduler scheduler);
    [ExtensionAttribute]
public static IObservable`1<IChangeSet`1<T>> ToObservableChangeSet(IObservable`1<T> source, int limitSizeTo, IScheduler scheduler);
    [ExtensionAttribute]
public static IObservable`1<IChangeSet`1<T>> ToObservableChangeSet(IObservable`1<T> source, Func`2<T, Nullable`1<TimeSpan>> expireAfter, int limitSizeTo, IScheduler scheduler);
    [ExtensionAttribute]
public static IObservable`1<IChangeSet`1<T>> ToObservableChangeSet(IObservable`1<IEnumerable`1<T>> source, IScheduler scheduler);
    [ExtensionAttribute]
public static IObservable`1<IChangeSet`1<T>> ToObservableChangeSet(IObservable`1<IEnumerable`1<T>> source, int limitSizeTo, IScheduler scheduler);
    [ExtensionAttribute]
public static IObservable`1<IChangeSet`1<T>> ToObservableChangeSet(IObservable`1<IEnumerable`1<T>> source, Func`2<T, Nullable`1<TimeSpan>> expireAfter, IScheduler scheduler);
    [ExtensionAttribute]
public static IObservable`1<IChangeSet`1<T>> ToObservableChangeSet(IObservable`1<IEnumerable`1<T>> source, Func`2<T, Nullable`1<TimeSpan>> expireAfter, int limitSizeTo, IScheduler scheduler);
    [ExtensionAttribute]
public static IObservable`1<IChangeSet`1<T>> Top(IObservable`1<IChangeSet`1<T>> source, int numberOfItems);
    [ExtensionAttribute]
public static IObservable`1<IReadOnlyCollection`1<TObject>> ToSortedCollection(IObservable`1<IChangeSet`1<TObject>> source, Func`2<TObject, TSortKey> sort, SortDirection sortOrder);
    [ExtensionAttribute]
public static IObservable`1<IReadOnlyCollection`1<TObject>> ToSortedCollection(IObservable`1<IChangeSet`1<TObject>> source, IComparer`1<TObject> comparer);
    [ExtensionAttribute]
public static IObservable`1<IChangeSet`1<TDestination>> Transform(IObservable`1<IChangeSet`1<TSource>> source, Func`2<TSource, TDestination> transformFactory, bool transformOnRefresh);
    [ExtensionAttribute]
public static IObservable`1<IChangeSet`1<TDestination>> Transform(IObservable`1<IChangeSet`1<TSource>> source, Func`3<TSource, int, TDestination> transformFactory, bool transformOnRefresh);
    [ExtensionAttribute]
public static IObservable`1<IChangeSet`1<TDestination>> Transform(IObservable`1<IChangeSet`1<TSource>> source, Func`3<TSource, Optional`1<TDestination>, TDestination> transformFactory, bool transformOnRefresh);
    [ExtensionAttribute]
public static IObservable`1<IChangeSet`1<TDestination>> Transform(IObservable`1<IChangeSet`1<TSource>> source, Func`4<TSource, Optional`1<TDestination>, int, TDestination> transformFactory, bool transformOnRefresh);
    [ExtensionAttribute]
public static IObservable`1<IChangeSet`1<TDestination>> TransformAsync(IObservable`1<IChangeSet`1<TSource>> source, Func`2<TSource, Task`1<TDestination>> transformFactory, bool transformOnRefresh);
    [ExtensionAttribute]
public static IObservable`1<IChangeSet`1<TDestination>> TransformAsync(IObservable`1<IChangeSet`1<TSource>> source, Func`3<TSource, int, Task`1<TDestination>> transformFactory, bool transformOnRefresh);
    [ExtensionAttribute]
public static IObservable`1<IChangeSet`1<TDestination>> TransformAsync(IObservable`1<IChangeSet`1<TSource>> source, Func`3<TSource, Optional`1<TDestination>, Task`1<TDestination>> transformFactory, bool transformOnRefresh);
    [ExtensionAttribute]
public static IObservable`1<IChangeSet`1<TDestination>> TransformAsync(IObservable`1<IChangeSet`1<TSource>> source, Func`4<TSource, Optional`1<TDestination>, int, Task`1<TDestination>> transformFactory, bool transformOnRefresh);
    [ExtensionAttribute]
public static IObservable`1<IChangeSet`1<TDestination>> TransformMany(IObservable`1<IChangeSet`1<TSource>> source, Func`2<TSource, IEnumerable`1<TDestination>> manySelector, IEqualityComparer`1<TDestination> equalityComparer);
    [ExtensionAttribute]
public static IObservable`1<IChangeSet`1<TDestination>> TransformMany(IObservable`1<IChangeSet`1<TSource>> source, Func`2<TSource, ObservableCollection`1<TDestination>> manySelector, IEqualityComparer`1<TDestination> equalityComparer);
    [ExtensionAttribute]
public static IObservable`1<IChangeSet`1<TDestination>> TransformMany(IObservable`1<IChangeSet`1<TSource>> source, Func`2<TSource, ReadOnlyObservableCollection`1<TDestination>> manySelector, IEqualityComparer`1<TDestination> equalityComparer);
    [ExtensionAttribute]
public static IObservable`1<IChangeSet`1<TDestination>> TransformMany(IObservable`1<IChangeSet`1<TSource>> source, Func`2<TSource, IObservableList`1<TDestination>> manySelector, IEqualityComparer`1<TDestination> equalityComparer);
    [ExtensionAttribute]
public static IObservable`1<IVirtualChangeSet`1<T>> Virtualise(IObservable`1<IChangeSet`1<T>> source, IObservable`1<IVirtualRequest> requests);
    [ExtensionAttribute]
public static IObservable`1<TObject> WhenAnyPropertyChanged(IObservable`1<IChangeSet`1<TObject>> source, String[] propertiesToMonitor);
    [ExtensionAttribute]
public static IObservable`1<PropertyValue`2<TObject, TValue>> WhenPropertyChanged(IObservable`1<IChangeSet`1<TObject>> source, Expression`1<Func`2<TObject, TValue>> propertyAccessor, bool notifyOnInitialValue);
    [ExtensionAttribute]
public static IObservable`1<TValue> WhenValueChanged(IObservable`1<IChangeSet`1<TObject>> source, Expression`1<Func`2<TObject, TValue>> propertyAccessor, bool notifyOnInitialValue);
    [ExtensionAttribute]
public static IObservable`1<IChangeSet`1<T>> WhereReasonsAre(IObservable`1<IChangeSet`1<T>> source, ListChangeReason[] reasons);
    [ExtensionAttribute]
public static IObservable`1<IChangeSet`1<T>> WhereReasonsAreNot(IObservable`1<IChangeSet`1<T>> source, ListChangeReason[] reasons);
    [ExtensionAttribute]
public static IObservable`1<IChangeSet`1<T>> Xor(IObservable`1<IChangeSet`1<T>> source, IObservable`1[] others);
    [ExtensionAttribute]
public static IObservable`1<IChangeSet`1<T>> Xor(ICollection`1<IObservable`1<IChangeSet`1<T>>> sources);
    [ExtensionAttribute]
public static IObservable`1<IChangeSet`1<T>> Xor(IObservableList`1<IObservable`1<IChangeSet`1<T>>> sources);
    [ExtensionAttribute]
public static IObservable`1<IChangeSet`1<T>> Xor(IObservableList`1<IObservableList`1<T>> sources);
    [ExtensionAttribute]
public static IObservable`1<IChangeSet`1<T>> Xor(IObservableList`1<ISourceList`1<T>> sources);
    [ExtensionAttribute]
private static IObservable`1<IChangeSet`1<T>> Combine(ICollection`1<IObservable`1<IChangeSet`1<T>>> sources, CombineOperator type);
    [ExtensionAttribute]
private static IObservable`1<IChangeSet`1<T>> Combine(IObservable`1<IChangeSet`1<T>> source, CombineOperator type, IObservable`1[] others);
    [ExtensionAttribute]
private static IObservable`1<IChangeSet`1<T>> Combine(IObservableList`1<ISourceList`1<T>> sources, CombineOperator type);
    [ExtensionAttribute]
private static IObservable`1<IChangeSet`1<T>> Combine(IObservableList`1<IObservableList`1<T>> sources, CombineOperator type);
    [ExtensionAttribute]
private static IObservable`1<IChangeSet`1<T>> Combine(IObservableList`1<IObservable`1<IChangeSet`1<T>>> sources, CombineOperator type);
}
public static class DynamicData.ObsoleteEx : object {
}
public interface DynamicData.Operators.IPageResponse {
    public int Page { get; }
    public int Pages { get; }
    public int PageSize { get; }
    public int TotalSize { get; }
    public abstract virtual int get_Page();
    public abstract virtual int get_Pages();
    public abstract virtual int get_PageSize();
    public abstract virtual int get_TotalSize();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class DynamicData.PageChangeSet`1 : object {
    private IChangeSet`1<T> _virtualChangeSet;
    [CompilerGeneratedAttribute]
private IPageResponse <Response>k__BackingField;
    public int Count { get; }
    public int Refreshes { get; }
    public IPageResponse Response { get; }
    private int DynamicData.IChangeSet.Adds { get; }
    private int DynamicData.IChangeSet.Capacity { get; private set; }
    private int DynamicData.IChangeSet.Moves { get; }
    private int DynamicData.IChangeSet.Removes { get; }
    private int DynamicData.IChangeSet<T>.Replaced { get; }
    private int DynamicData.IChangeSet<T>.TotalChanges { get; }
    public PageChangeSet`1(IChangeSet`1<T> virtualChangeSet, IPageResponse response);
    public sealed virtual int get_Count();
    public sealed virtual int get_Refreshes();
    [CompilerGeneratedAttribute]
public sealed virtual IPageResponse get_Response();
    private sealed virtual override int DynamicData.IChangeSet.get_Adds();
    private sealed virtual override int DynamicData.IChangeSet.get_Capacity();
    private sealed virtual override void DynamicData.IChangeSet.set_Capacity(int value);
    private sealed virtual override int DynamicData.IChangeSet.get_Moves();
    private sealed virtual override int DynamicData.IChangeSet.get_Removes();
    private sealed virtual override int DynamicData.IChangeSet<T>.get_Replaced();
    private sealed virtual override int DynamicData.IChangeSet<T>.get_TotalChanges();
    public sealed virtual IEnumerator`1<Change`1<T>> GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class DynamicData.PageContext`1 : object {
    [CompilerGeneratedAttribute]
private IPageResponse <Response>k__BackingField;
    [CompilerGeneratedAttribute]
private IComparer`1<TObject> <Comparer>k__BackingField;
    [CompilerGeneratedAttribute]
private SortAndPageOptions <Options>k__BackingField;
    internal static PageContext`1<TObject> Empty;
    [CompilerGeneratedAttribute]
protected Type EqualityContract { get; }
    public IPageResponse Response { get; public set; }
    public IComparer`1<TObject> Comparer { get; public set; }
    public SortAndPageOptions Options { get; public set; }
    public PageContext`1(IPageResponse Response, IComparer`1<TObject> Comparer, SortAndPageOptions Options);
    [CompilerGeneratedAttribute]
protected PageContext`1(PageContext`1<TObject> original);
    private static PageContext`1();
    [CompilerGeneratedAttribute]
protected virtual Type get_EqualityContract();
    [CompilerGeneratedAttribute]
public IPageResponse get_Response();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_Response(IPageResponse value);
    [CompilerGeneratedAttribute]
public IComparer`1<TObject> get_Comparer();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_Comparer(IComparer`1<TObject> value);
    [CompilerGeneratedAttribute]
public SortAndPageOptions get_Options();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_Options(SortAndPageOptions value);
    [CompilerGeneratedAttribute]
public virtual string ToString();
    [CompilerGeneratedAttribute]
protected virtual bool PrintMembers(StringBuilder builder);
    [CompilerGeneratedAttribute]
public static bool op_Inequality(PageContext`1<TObject> left, PageContext`1<TObject> right);
    [CompilerGeneratedAttribute]
public static bool op_Equality(PageContext`1<TObject> left, PageContext`1<TObject> right);
    [CompilerGeneratedAttribute]
public virtual int GetHashCode();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public virtual bool Equals(object obj);
    [CompilerGeneratedAttribute]
public virtual bool Equals(PageContext`1<TObject> other);
    [CompilerGeneratedAttribute]
public virtual PageContext`1<TObject> <Clone>$();
    [CompilerGeneratedAttribute]
public void Deconstruct(IPageResponse& Response, IComparer`1& Comparer, SortAndPageOptions& Options);
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal class DynamicData.PagedChangeSet`2 : ChangeSet`2<TObject, TKey> {
    public static IPagedChangeSet`2<TObject, TKey> Empty;
    [CompilerGeneratedAttribute]
private IPageResponse <Response>k__BackingField;
    [CompilerGeneratedAttribute]
private IKeyValueCollection`2<TObject, TKey> <SortedItems>k__BackingField;
    public IPageResponse Response { get; }
    public IKeyValueCollection`2<TObject, TKey> SortedItems { get; }
    public PagedChangeSet`2(IKeyValueCollection`2<TObject, TKey> sortedItems, IEnumerable`1<Change`2<TObject, TKey>> updates, IPageResponse response);
    private static PagedChangeSet`2();
    [CompilerGeneratedAttribute]
public sealed virtual IPageResponse get_Response();
    [CompilerGeneratedAttribute]
public sealed virtual IKeyValueCollection`2<TObject, TKey> get_SortedItems();
    public bool Equals(PagedChangeSet`2<TObject, TKey> other);
    [NullableContextAttribute("2")]
public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public virtual string ToString();
    private sealed virtual override int DynamicData.IChangeSet.get_Capacity();
    private sealed virtual override void DynamicData.IChangeSet.set_Capacity(int value);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class DynamicData.PageRequest : object {
    public static IPageRequest Default;
    public static IPageRequest Empty;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private static IEqualityComparer`1<IPageRequest> <DefaultComparer>k__BackingField;
    [CompilerGeneratedAttribute]
private int <Page>k__BackingField;
    [CompilerGeneratedAttribute]
private int <Size>k__BackingField;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static IEqualityComparer`1<IPageRequest> DefaultComparer { get; }
    public int Page { get; }
    public int Size { get; }
    public PageRequest(int page, int size);
    private static PageRequest();
    [CompilerGeneratedAttribute]
public static IEqualityComparer`1<IPageRequest> get_DefaultComparer();
    [CompilerGeneratedAttribute]
public sealed virtual int get_Page();
    [CompilerGeneratedAttribute]
public sealed virtual int get_Size();
    [NullableContextAttribute("2")]
public sealed virtual bool Equals(IPageRequest other);
    [NullableContextAttribute("2")]
public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public virtual string ToString();
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
internal class DynamicData.PageResponse : object {
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private static IEqualityComparer`1<IPageResponse> <DefaultComparer>k__BackingField;
    [CompilerGeneratedAttribute]
private int <Page>k__BackingField;
    [CompilerGeneratedAttribute]
private int <Pages>k__BackingField;
    [CompilerGeneratedAttribute]
private int <PageSize>k__BackingField;
    [CompilerGeneratedAttribute]
private int <TotalSize>k__BackingField;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static IEqualityComparer`1<IPageResponse> DefaultComparer { get; }
    public int Page { get; }
    public int Pages { get; }
    public int PageSize { get; }
    public int TotalSize { get; }
    public PageResponse(int pageSize, int totalSize, int page, int pages);
    private static PageResponse();
    [CompilerGeneratedAttribute]
public static IEqualityComparer`1<IPageResponse> get_DefaultComparer();
    [CompilerGeneratedAttribute]
public sealed virtual int get_Page();
    [CompilerGeneratedAttribute]
public sealed virtual int get_Pages();
    [CompilerGeneratedAttribute]
public sealed virtual int get_PageSize();
    [CompilerGeneratedAttribute]
public sealed virtual int get_TotalSize();
    public sealed virtual bool Equals(IPageResponse other);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    [NullableContextAttribute("1")]
public virtual string ToString();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
internal static class DynamicData.PLinq.ParallelEx : object {
    [ExtensionAttribute]
internal static ParallelQuery`1<Change`2<TObject, TKey>> Parallelise(IChangeSet`2<TObject, TKey> source, ParallelisationOptions option);
    [ExtensionAttribute]
internal static ParallelQuery`1<KeyValuePair`2<TKey, TObject>> Parallelise(IEnumerable`1<KeyValuePair`2<TKey, TObject>> source, ParallelisationOptions option);
    [ExtensionAttribute]
internal static IEnumerable`1<T> Parallelise(IEnumerable`1<T> source, ParallelisationOptions option);
    [ExtensionAttribute]
internal static bool ShouldParallelise(IChangeSet`2<TObject, TKey> source, ParallelisationOptions option);
    [ExtensionAttribute]
internal static bool ShouldParallelise(IEnumerable`1<KeyValuePair`2<TKey, TObject>> source, ParallelisationOptions option);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class DynamicData.PLinq.ParallelisationOptions : object {
    public static ParallelisationOptions Default;
    public static ParallelisationOptions None;
    [CompilerGeneratedAttribute]
private int <MaxDegreeOfParallelisation>k__BackingField;
    [CompilerGeneratedAttribute]
private int <Threshold>k__BackingField;
    [CompilerGeneratedAttribute]
private ParallelType <Type>k__BackingField;
    public int MaxDegreeOfParallelisation { get; }
    public int Threshold { get; }
    public ParallelType Type { get; }
    public ParallelisationOptions(ParallelType type, int threshold, int maxDegreeOfParallelisation);
    private static ParallelisationOptions();
    [CompilerGeneratedAttribute]
public int get_MaxDegreeOfParallelisation();
    [CompilerGeneratedAttribute]
public int get_Threshold();
    [CompilerGeneratedAttribute]
public ParallelType get_Type();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
public static class DynamicData.PLinq.ParallelOperators : object {
    [ExtensionAttribute]
public static IObservable`1<IChangeSet`2<TObject, TKey>> Filter(IObservable`1<IChangeSet`2<TObject, TKey>> source, Func`2<TObject, bool> filter, ParallelisationOptions parallelisationOptions);
    [ExtensionAttribute]
public static IObservable`1<IChangeSet`2<TObject, TKey>> SubscribeMany(IObservable`1<IChangeSet`2<TObject, TKey>> source, Func`2<TObject, IDisposable> subscriptionFactory, ParallelisationOptions parallelisationOptions);
    [ExtensionAttribute]
public static IObservable`1<IChangeSet`2<TObject, TKey>> SubscribeMany(IObservable`1<IChangeSet`2<TObject, TKey>> source, Func`3<TObject, TKey, IDisposable> subscriptionFactory, ParallelisationOptions parallelisationOptions);
    [ExtensionAttribute]
public static IObservable`1<IChangeSet`2<TDestination, TKey>> Transform(IObservable`1<IChangeSet`2<TSource, TKey>> source, Func`3<TSource, TKey, TDestination> transformFactory, ParallelisationOptions parallelisationOptions);
    [ExtensionAttribute]
public static IObservable`1<IChangeSet`2<TDestination, TKey>> Transform(IObservable`1<IChangeSet`2<TSource, TKey>> source, Func`2<TSource, TDestination> transformFactory, ParallelisationOptions parallelisationOptions);
    [ExtensionAttribute]
public static IObservable`1<IChangeSet`2<TDestination, TKey>> TransformSafe(IObservable`1<IChangeSet`2<TSource, TKey>> source, Func`2<TSource, TDestination> transformFactory, Action`1<Error`2<TSource, TKey>> errorHandler, ParallelisationOptions parallelisationOptions);
    [ExtensionAttribute]
public static IObservable`1<IChangeSet`2<TDestination, TKey>> TransformSafe(IObservable`1<IChangeSet`2<TSource, TKey>> source, Func`3<TSource, TKey, TDestination> transformFactory, Action`1<Error`2<TSource, TKey>> errorHandler, ParallelisationOptions parallelisationOptions);
}
public enum DynamicData.PLinq.ParallelType : Enum {
    public int value__;
    public static ParallelType None;
    public static ParallelType Parallelise;
    public static ParallelType Ordered;
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class DynamicData.PLinq.PFilter`2 : object {
    [CompilerGeneratedAttribute]
private IObservable`1<IChangeSet`2<TObject, TKey>> <source>P;
    [CompilerGeneratedAttribute]
private Func`2<TObject, bool> <filter>P;
    [CompilerGeneratedAttribute]
private ParallelisationOptions <parallelisationOptions>P;
    public PFilter`2(IObservable`1<IChangeSet`2<TObject, TKey>> source, Func`2<TObject, bool> filter, ParallelisationOptions parallelisationOptions);
    public IObservable`1<IChangeSet`2<TObject, TKey>> Run();
    [CompilerGeneratedAttribute]
private IDisposable <Run>b__4_0(IObserver`1<IChangeSet`2<TObject, TKey>> observer);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class DynamicData.PLinq.PSubscribeMany`2 : object {
    [CompilerGeneratedAttribute]
private ParallelisationOptions <parallelisationOptions>P;
    private IObservable`1<IChangeSet`2<TObject, TKey>> _source;
    private Func`3<TObject, TKey, IDisposable> _subscriptionFactory;
    public PSubscribeMany`2(IObservable`1<IChangeSet`2<TObject, TKey>> source, Func`3<TObject, TKey, IDisposable> subscriptionFactory, ParallelisationOptions parallelisationOptions);
    public IObservable`1<IChangeSet`2<TObject, TKey>> Run();
    [CompilerGeneratedAttribute]
private IDisposable <Run>b__4_0(IObserver`1<IChangeSet`2<TObject, TKey>> observer);
    [CompilerGeneratedAttribute]
private IDisposable <Run>b__4_1(TObject t, TKey k);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class DynamicData.PLinq.PTransform`3 : object {
    [CompilerGeneratedAttribute]
private IObservable`1<IChangeSet`2<TSource, TKey>> <source>P;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private Func`4<TSource, Optional`1<TSource>, TKey, TDestination> <transformFactory>P;
    [CompilerGeneratedAttribute]
private ParallelisationOptions <parallelisationOptions>P;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private Action`1<Error`2<TSource, TKey>> <exceptionCallback>P;
    public PTransform`3(IObservable`1<IChangeSet`2<TSource, TKey>> source, Func`4<TSource, Optional`1<TSource>, TKey, TDestination> transformFactory, ParallelisationOptions parallelisationOptions, Action`1<Error`2<TSource, TKey>> exceptionCallback);
    public IObservable`1<IChangeSet`2<TDestination, TKey>> Run();
    private ChangeSet`2<TDestination, TKey> DoTransform(ChangeAwareCache`2<TDestination, TKey> cache, IChangeSet`2<TSource, TKey> changes);
    [NullableContextAttribute("0")]
private TransformResult<TDestination, TSource, TKey> ToDestination(Change`2<TSource, TKey> change);
    private ChangeSet`2<TDestination, TKey> ProcessUpdates(ChangeAwareCache`2<TDestination, TKey> cache, IEnumerable`1<TransformResult<TDestination, TSource, TKey>> transformedItems);
    [CompilerGeneratedAttribute]
private IDisposable <Run>b__5_0(IObserver`1<IChangeSet`2<TDestination, TKey>> observer);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class DynamicData.RangeChange`1 : object {
    private List`1<T> _items;
    [CompilerGeneratedAttribute]
private static RangeChange`1<T> <Empty>k__BackingField;
    [CompilerGeneratedAttribute]
private int <Index>k__BackingField;
    public static RangeChange`1<T> Empty { get; }
    public int Count { get; }
    public int Index { get; private set; }
    public RangeChange`1(IEnumerable`1<T> items, int index);
    private static RangeChange`1();
    [CompilerGeneratedAttribute]
public static RangeChange`1<T> get_Empty();
    public int get_Count();
    [CompilerGeneratedAttribute]
public int get_Index();
    [CompilerGeneratedAttribute]
private void set_Index(int value);
    public void Add(T item);
    public sealed virtual IEnumerator`1<T> GetEnumerator();
    public void Insert(int index, T item);
    public void SetStartingIndex(int index);
    public virtual string ToString();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
}
public class DynamicData.SortAndPageOptions : ValueType {
    [CompilerGeneratedAttribute]
private int <ResetThreshold>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <UseBinarySearch>k__BackingField;
    [CompilerGeneratedAttribute]
private int <InitialCapacity>k__BackingField;
    public int ResetThreshold { get; public set; }
    public bool UseBinarySearch { get; public set; }
    public int InitialCapacity { get; public set; }
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public int get_ResetThreshold();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_ResetThreshold(int value);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public bool get_UseBinarySearch();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_UseBinarySearch(bool value);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public int get_InitialCapacity();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_InitialCapacity(int value);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public virtual string ToString();
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
private bool PrintMembers(StringBuilder builder);
    [CompilerGeneratedAttribute]
public static bool op_Inequality(SortAndPageOptions left, SortAndPageOptions right);
    [CompilerGeneratedAttribute]
public static bool op_Equality(SortAndPageOptions left, SortAndPageOptions right);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public virtual int GetHashCode();
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public virtual bool Equals(object obj);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public sealed virtual bool Equals(SortAndPageOptions other);
}
public class DynamicData.SortAndVirtualizeOptions : ValueType {
    [CompilerGeneratedAttribute]
private int <ResetThreshold>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <UseBinarySearch>k__BackingField;
    [CompilerGeneratedAttribute]
private int <InitialCapacity>k__BackingField;
    public int ResetThreshold { get; public set; }
    public bool UseBinarySearch { get; public set; }
    public int InitialCapacity { get; public set; }
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public int get_ResetThreshold();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_ResetThreshold(int value);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public bool get_UseBinarySearch();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_UseBinarySearch(bool value);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public int get_InitialCapacity();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_InitialCapacity(int value);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public virtual string ToString();
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
private bool PrintMembers(StringBuilder builder);
    [CompilerGeneratedAttribute]
public static bool op_Inequality(SortAndVirtualizeOptions left, SortAndVirtualizeOptions right);
    [CompilerGeneratedAttribute]
public static bool op_Equality(SortAndVirtualizeOptions left, SortAndVirtualizeOptions right);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public virtual int GetHashCode();
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public virtual bool Equals(object obj);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public sealed virtual bool Equals(SortAndVirtualizeOptions other);
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal class DynamicData.SortedChangeSet`2 : ChangeSet`2<TObject, TKey> {
    public static ISortedChangeSet`2<TObject, TKey> Empty;
    [CompilerGeneratedAttribute]
private IKeyValueCollection`2<TObject, TKey> <SortedItems>k__BackingField;
    public IKeyValueCollection`2<TObject, TKey> SortedItems { get; }
    public SortedChangeSet`2(IKeyValueCollection`2<TObject, TKey> sortedItems, IEnumerable`1<Change`2<TObject, TKey>> updates);
    private static SortedChangeSet`2();
    [CompilerGeneratedAttribute]
public sealed virtual IKeyValueCollection`2<TObject, TKey> get_SortedItems();
    public bool Equals(SortedChangeSet`2<TObject, TKey> other);
    [NullableContextAttribute("2")]
public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public virtual string ToString();
    private sealed virtual override int DynamicData.IChangeSet.get_Capacity();
    private sealed virtual override void DynamicData.IChangeSet.set_Capacity(int value);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class DynamicData.SortException : Exception {
    public SortException(string message);
    public SortException(string message, Exception innerException);
}
[FlagsAttribute]
public enum DynamicData.SortOptimisations : Enum {
    public int value__;
    public static SortOptimisations None;
    public static SortOptimisations ComparesImmutableValuesOnly;
    public static SortOptimisations IgnoreEvaluates;
    [ObsoleteAttribute("This is no longer being used. Use one of the other options instead.")]
public static SortOptimisations InsertAtEndThenSort;
}
public enum DynamicData.SortOptions : Enum {
    public int value__;
    public static SortOptions None;
    public static SortOptions UseBinarySearch;
}
public enum DynamicData.SortReason : Enum {
    public int value__;
    public static SortReason InitialLoad;
    public static SortReason ComparerChanged;
    public static SortReason DataChanged;
    public static SortReason Reorder;
    public static SortReason Reset;
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[DebuggerDisplayAttribute("SourceCache<{typeof(TObject).Name}, {typeof(TKey).Name}> ({Count} Items)")]
public class DynamicData.SourceCache`2 : object {
    private ObservableCache`2<TObject, TKey> _innerCache;
    [CompilerGeneratedAttribute]
private Func`2<TObject, TKey> <KeySelector>k__BackingField;
    public int Count { get; }
    public IObservable`1<int> CountChanged { get; }
    public IReadOnlyList`1<TObject> Items { get; }
    public IReadOnlyList`1<TKey> Keys { get; }
    public Func`2<TObject, TKey> KeySelector { get; }
    public IReadOnlyDictionary`2<TKey, TObject> KeyValues { get; }
    public SourceCache`2(Func`2<TObject, TKey> keySelector);
    public sealed virtual int get_Count();
    public sealed virtual IObservable`1<int> get_CountChanged();
    public sealed virtual IReadOnlyList`1<TObject> get_Items();
    public sealed virtual IReadOnlyList`1<TKey> get_Keys();
    [CompilerGeneratedAttribute]
public sealed virtual Func`2<TObject, TKey> get_KeySelector();
    public sealed virtual IReadOnlyDictionary`2<TKey, TObject> get_KeyValues();
    public sealed virtual IObservable`1<IChangeSet`2<TObject, TKey>> Connect(Func`2<TObject, bool> predicate, bool suppressEmptyChangeSets);
    public sealed virtual void Dispose();
    public sealed virtual void Edit(Action`1<ISourceUpdater`2<TObject, TKey>> updateAction);
    public sealed virtual Optional`1<TObject> Lookup(TKey key);
    public sealed virtual IObservable`1<IChangeSet`2<TObject, TKey>> Preview(Func`2<TObject, bool> predicate);
    public sealed virtual IObservable`1<Change`2<TObject, TKey>> Watch(TKey key);
    public sealed virtual IDisposable SuspendCount();
    public sealed virtual IDisposable SuspendNotifications();
}
[ExtensionAttribute]
public static class DynamicData.SourceCacheEx : object {
    [NullableContextAttribute("1")]
[ExtensionAttribute]
public static IObservable`1<IChangeSet`2<TDestination, TKey>> Cast(IObservableCache`2<TSource, TKey> source, Func`2<TSource, TDestination> converter);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[DebuggerDisplayAttribute("SourceList<{typeof(T).Name}> ({Count} Items)")]
public class DynamicData.SourceList`1 : object {
    private ISubject`1<IChangeSet`1<T>> _changes;
    private Subject`1<IChangeSet`1<T>> _changesPreview;
    private IDisposable _cleanUp;
    private Lazy`1<ISubject`1<int>> _countChanged;
    private object _locker;
    private ReaderWriter`1<T> _readerWriter;
    private int _editLevel;
    public int Count { get; }
    public IObservable`1<int> CountChanged { get; }
    public IReadOnlyList`1<T> Items { get; }
    public SourceList`1(IObservable`1<IChangeSet`1<T>> source);
    public sealed virtual int get_Count();
    public sealed virtual IObservable`1<int> get_CountChanged();
    public sealed virtual IReadOnlyList`1<T> get_Items();
    public sealed virtual IObservable`1<IChangeSet`1<T>> Connect(Func`2<T, bool> predicate);
    public sealed virtual void Dispose();
    public sealed virtual void Edit(Action`1<IExtendedList`1<T>> updateAction);
    public sealed virtual IObservable`1<IChangeSet`1<T>> Preview(Func`2<T, bool> predicate);
    private void InvokeNext(IChangeSet`1<T> changes);
    private void InvokeNextPreview(IChangeSet`1<T> changes);
    private IDisposable LoadFromSource(IObservable`1<IChangeSet`1<T>> source);
    private void OnCompleted();
    private void OnError(Exception exception);
    [CompilerGeneratedAttribute]
private IDisposable <get_CountChanged>b__11_0(IObserver`1<int> observer);
    [CompilerGeneratedAttribute]
private IDisposable <Connect>b__14_0(IObserver`1<IChangeSet`1<T>> observer);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
public static class DynamicData.SourceListEditConvenienceEx : object {
    [ExtensionAttribute]
public static void Add(ISourceList`1<T> source, T item);
    [ExtensionAttribute]
public static void AddRange(ISourceList`1<T> source, IEnumerable`1<T> items);
    [ExtensionAttribute]
public static void Clear(ISourceList`1<T> source);
    [ExtensionAttribute]
public static void EditDiff(ISourceList`1<T> source, IEnumerable`1<T> allItems, IEqualityComparer`1<T> equalityComparer);
    [ExtensionAttribute]
public static void Insert(ISourceList`1<T> source, int index, T item);
    [ExtensionAttribute]
public static void InsertRange(ISourceList`1<T> source, IEnumerable`1<T> items, int index);
    [ExtensionAttribute]
public static void Move(ISourceList`1<T> source, int original, int destination);
    [ExtensionAttribute]
public static bool Remove(ISourceList`1<T> source, T item);
    [ExtensionAttribute]
public static void RemoveAt(ISourceList`1<T> source, int index);
    [ExtensionAttribute]
public static void RemoveMany(ISourceList`1<T> source, IEnumerable`1<T> itemsToRemove);
    [ExtensionAttribute]
public static void RemoveRange(ISourceList`1<T> source, int index, int count);
    [ExtensionAttribute]
public static void Replace(ISourceList`1<T> source, T original, T destination);
    [ExtensionAttribute]
public static void ReplaceAt(ISourceList`1<T> source, int index, T item);
}
[ExtensionAttribute]
public static class DynamicData.SourceListEx : object {
    [NullableContextAttribute("1")]
[ExtensionAttribute]
public static IObservable`1<IChangeSet`1<TDestination>> Cast(ISourceList`1<TSource> source, Func`2<TSource, TDestination> conversionFactory);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[IsByRefLikeAttribute]
[ObsoleteAttribute("Types with embedded references are not supported in this version of your compiler.", "True")]
[CompilerFeatureRequiredAttribute("RefStructs")]
internal class DynamicData.SwappableLock : ValueType {
    private bool _hasLock;
    [NullableAttribute("2")]
private object _gate;
    public static SwappableLock CreateAndEnter(object gate);
    public void SwapTo(object gate);
    public void Dispose();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class DynamicData.Tests.ChangeSetAggregator`1 : object {
    private IDisposable _disposer;
    private bool _isDisposed;
    [NullableAttribute("2")]
[CompilerGeneratedAttribute]
private Exception <Exception>k__BackingField;
    [CompilerGeneratedAttribute]
private IObservableList`1<TObject> <Data>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsCompleted>k__BackingField;
    [CompilerGeneratedAttribute]
private IList`1<IChangeSet`1<TObject>> <Messages>k__BackingField;
    [NullableAttribute("2")]
public Exception Exception { get; public set; }
    public IObservableList`1<TObject> Data { get; }
    public bool IsCompleted { get; private set; }
    public IList`1<IChangeSet`1<TObject>> Messages { get; }
    public ChangeSetAggregator`1(IObservable`1<IChangeSet`1<TObject>> source);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public Exception get_Exception();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public void set_Exception(Exception value);
    [CompilerGeneratedAttribute]
public IObservableList`1<TObject> get_Data();
    [CompilerGeneratedAttribute]
public bool get_IsCompleted();
    [CompilerGeneratedAttribute]
private void set_IsCompleted(bool value);
    [CompilerGeneratedAttribute]
public IList`1<IChangeSet`1<TObject>> get_Messages();
    public sealed virtual void Dispose();
    protected virtual void Dispose(bool isDisposing);
    [CompilerGeneratedAttribute]
private void <.ctor>b__2_0(Exception error);
    [CompilerGeneratedAttribute]
private void <.ctor>b__2_1();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class DynamicData.Tests.ChangeSetAggregator`2 : object {
    private IDisposable _disposer;
    [CompilerGeneratedAttribute]
private IObservableCache`2<TObject, TKey> <Data>k__BackingField;
    [NullableAttribute("2")]
[CompilerGeneratedAttribute]
private Exception <Error>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsCompleted>k__BackingField;
    [CompilerGeneratedAttribute]
private IList`1<IChangeSet`2<TObject, TKey>> <Messages>k__BackingField;
    [CompilerGeneratedAttribute]
private ChangeSummary <Summary>k__BackingField;
    public IObservableCache`2<TObject, TKey> Data { get; }
    [NullableAttribute("2")]
public Exception Error { get; private set; }
    public bool IsCompleted { get; private set; }
    public IList`1<IChangeSet`2<TObject, TKey>> Messages { get; }
    public ChangeSummary Summary { get; private set; }
    public ChangeSetAggregator`2(IObservable`1<IChangeSet`2<TObject, TKey>> source);
    [CompilerGeneratedAttribute]
public IObservableCache`2<TObject, TKey> get_Data();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public Exception get_Error();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
private void set_Error(Exception value);
    [CompilerGeneratedAttribute]
public bool get_IsCompleted();
    [CompilerGeneratedAttribute]
private void set_IsCompleted(bool value);
    [CompilerGeneratedAttribute]
public IList`1<IChangeSet`2<TObject, TKey>> get_Messages();
    [CompilerGeneratedAttribute]
public ChangeSummary get_Summary();
    [CompilerGeneratedAttribute]
private void set_Summary(ChangeSummary value);
    public sealed virtual void Dispose();
    [NullableContextAttribute("0")]
[CompilerGeneratedAttribute]
private void <.ctor>b__1_0(IChangeSet`2<TObject, TKey> updates);
    [CompilerGeneratedAttribute]
private void <.ctor>b__1_1(Exception ex);
    [CompilerGeneratedAttribute]
private void <.ctor>b__1_2();
    [NullableContextAttribute("0")]
[CompilerGeneratedAttribute]
private void <.ctor>b__1_3(ChangeSummary summary);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class DynamicData.Tests.ChangeSetAggregator`3 : object {
    private IDisposable _disposer;
    [CompilerGeneratedAttribute]
private IObservableCache`2<TObject, TKey> <Data>k__BackingField;
    [NullableAttribute("2")]
[CompilerGeneratedAttribute]
private Exception <Error>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsCompleted>k__BackingField;
    [CompilerGeneratedAttribute]
private IList`1<IChangeSet`3<TObject, TKey, TContext>> <Messages>k__BackingField;
    [CompilerGeneratedAttribute]
private ChangeSummary <Summary>k__BackingField;
    public IObservableCache`2<TObject, TKey> Data { get; }
    [NullableAttribute("2")]
public Exception Error { get; private set; }
    public bool IsCompleted { get; private set; }
    public IList`1<IChangeSet`3<TObject, TKey, TContext>> Messages { get; }
    public ChangeSummary Summary { get; private set; }
    public ChangeSetAggregator`3(IObservable`1<IChangeSet`3<TObject, TKey, TContext>> source);
    [CompilerGeneratedAttribute]
public IObservableCache`2<TObject, TKey> get_Data();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public Exception get_Error();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
private void set_Error(Exception value);
    [CompilerGeneratedAttribute]
public bool get_IsCompleted();
    [CompilerGeneratedAttribute]
private void set_IsCompleted(bool value);
    [CompilerGeneratedAttribute]
public IList`1<IChangeSet`3<TObject, TKey, TContext>> get_Messages();
    [CompilerGeneratedAttribute]
public ChangeSummary get_Summary();
    [CompilerGeneratedAttribute]
private void set_Summary(ChangeSummary value);
    public sealed virtual void Dispose();
    [NullableContextAttribute("0")]
[CompilerGeneratedAttribute]
private void <.ctor>b__1_0(IChangeSet`3<TObject, TKey, TContext> updates);
    [CompilerGeneratedAttribute]
private void <.ctor>b__1_1(Exception ex);
    [CompilerGeneratedAttribute]
private void <.ctor>b__1_2();
    [NullableContextAttribute("0")]
[CompilerGeneratedAttribute]
private void <.ctor>b__1_3(ChangeSummary summary);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class DynamicData.Tests.DistinctChangeSetAggregator`1 : object {
    private IDisposable _disposer;
    private bool _isDisposed;
    [CompilerGeneratedAttribute]
private IObservableCache`2<TValue, TValue> <Data>k__BackingField;
    [NullableAttribute("2")]
[CompilerGeneratedAttribute]
private Exception <Error>k__BackingField;
    [CompilerGeneratedAttribute]
private IList`1<IChangeSet`2<TValue, TValue>> <Messages>k__BackingField;
    [CompilerGeneratedAttribute]
private ChangeSummary <Summary>k__BackingField;
    public IObservableCache`2<TValue, TValue> Data { get; }
    [NullableAttribute("2")]
public Exception Error { get; private set; }
    public IList`1<IChangeSet`2<TValue, TValue>> Messages { get; }
    public ChangeSummary Summary { get; private set; }
    public DistinctChangeSetAggregator`1(IObservable`1<IDistinctChangeSet`1<TValue>> source);
    [CompilerGeneratedAttribute]
public IObservableCache`2<TValue, TValue> get_Data();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public Exception get_Error();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
private void set_Error(Exception value);
    [CompilerGeneratedAttribute]
public IList`1<IChangeSet`2<TValue, TValue>> get_Messages();
    [CompilerGeneratedAttribute]
public ChangeSummary get_Summary();
    [CompilerGeneratedAttribute]
private void set_Summary(ChangeSummary value);
    public sealed virtual void Dispose();
    protected virtual void Dispose(bool isDisposing);
    [CompilerGeneratedAttribute]
private void <.ctor>b__2_1(Exception ex);
    [NullableContextAttribute("0")]
[CompilerGeneratedAttribute]
private void <.ctor>b__2_2(IDistinctChangeSet`1<TValue> updates);
    [NullableContextAttribute("0")]
[CompilerGeneratedAttribute]
private void <.ctor>b__2_3(ChangeSummary summary);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class DynamicData.Tests.GroupChangeSetAggregator`3 : object {
    private CompositeDisposable _compositeDisposable;
    private List`1<IGroupChangeSet`3<TObject, TKey, TGroupKey>> _messages;
    private bool _disposedValue;
    [CompilerGeneratedAttribute]
private IObservableCache`2<IGroup`3<TObject, TKey, TGroupKey>, TGroupKey> <Data>k__BackingField;
    [CompilerGeneratedAttribute]
private IObservableCache`2<ChangeSetAggregator`2<TObject, TKey>, TGroupKey> <Groups>k__BackingField;
    [NullableAttribute("2")]
[CompilerGeneratedAttribute]
private Exception <Error>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsCompleted>k__BackingField;
    [CompilerGeneratedAttribute]
private ChangeSummary <Summary>k__BackingField;
    public IObservableCache`2<IGroup`3<TObject, TKey, TGroupKey>, TGroupKey> Data { get; }
    public IObservableCache`2<ChangeSetAggregator`2<TObject, TKey>, TGroupKey> Groups { get; }
    [NullableAttribute("2")]
public Exception Error { get; private set; }
    public bool IsCompleted { get; private set; }
    public IReadOnlyList`1<IGroupChangeSet`3<TObject, TKey, TGroupKey>> Messages { get; }
    public ChangeSummary Summary { get; private set; }
    public GroupChangeSetAggregator`3(IObservable`1<IGroupChangeSet`3<TObject, TKey, TGroupKey>> source);
    [CompilerGeneratedAttribute]
public IObservableCache`2<IGroup`3<TObject, TKey, TGroupKey>, TGroupKey> get_Data();
    [CompilerGeneratedAttribute]
public IObservableCache`2<ChangeSetAggregator`2<TObject, TKey>, TGroupKey> get_Groups();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public Exception get_Error();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
private void set_Error(Exception value);
    [CompilerGeneratedAttribute]
public bool get_IsCompleted();
    [CompilerGeneratedAttribute]
private void set_IsCompleted(bool value);
    public IReadOnlyList`1<IGroupChangeSet`3<TObject, TKey, TGroupKey>> get_Messages();
    [CompilerGeneratedAttribute]
public ChangeSummary get_Summary();
    [CompilerGeneratedAttribute]
private void set_Summary(ChangeSummary value);
    public sealed virtual void Dispose();
    protected virtual void Dispose(bool disposing);
    [CompilerGeneratedAttribute]
private void <.ctor>b__3_1(Exception ex);
    [CompilerGeneratedAttribute]
private void <.ctor>b__3_2();
    [NullableContextAttribute("0")]
[CompilerGeneratedAttribute]
private void <.ctor>b__3_3(ChangeSummary summary);
}
[ExtensionAttribute]
public static class DynamicData.Tests.ListTextEx : object {
    [NullableContextAttribute("1")]
[ExtensionAttribute]
public static ChangeSetAggregator`1<T> AsAggregator(IObservable`1<IChangeSet`1<T>> source);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class DynamicData.Tests.PagedChangeSetAggregator`2 : object {
    private IDisposable _disposer;
    private bool _isDisposed;
    [CompilerGeneratedAttribute]
private IObservableCache`2<TObject, TKey> <Data>k__BackingField;
    [NullableAttribute("2")]
[CompilerGeneratedAttribute]
private Exception <Error>k__BackingField;
    [CompilerGeneratedAttribute]
private IList`1<IPagedChangeSet`2<TObject, TKey>> <Messages>k__BackingField;
    [CompilerGeneratedAttribute]
private ChangeSummary <Summary>k__BackingField;
    public IObservableCache`2<TObject, TKey> Data { get; }
    [NullableAttribute("2")]
public Exception Error { get; private set; }
    public IList`1<IPagedChangeSet`2<TObject, TKey>> Messages { get; }
    public ChangeSummary Summary { get; private set; }
    public PagedChangeSetAggregator`2(IObservable`1<IPagedChangeSet`2<TObject, TKey>> source);
    [CompilerGeneratedAttribute]
public IObservableCache`2<TObject, TKey> get_Data();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public Exception get_Error();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
private void set_Error(Exception value);
    [CompilerGeneratedAttribute]
public IList`1<IPagedChangeSet`2<TObject, TKey>> get_Messages();
    [CompilerGeneratedAttribute]
public ChangeSummary get_Summary();
    [CompilerGeneratedAttribute]
private void set_Summary(ChangeSummary value);
    public sealed virtual void Dispose();
    protected virtual void Dispose(bool isDisposing);
    [CompilerGeneratedAttribute]
private void <.ctor>b__2_1(Exception ex);
    [NullableContextAttribute("0")]
[CompilerGeneratedAttribute]
private void <.ctor>b__2_2(IPagedChangeSet`2<TObject, TKey> updates);
    [NullableContextAttribute("0")]
[CompilerGeneratedAttribute]
private void <.ctor>b__2_3(ChangeSummary summary);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class DynamicData.Tests.SortedChangeSetAggregator`2 : object {
    private IDisposable _disposer;
    private bool _isDisposed;
    [CompilerGeneratedAttribute]
private IObservableCache`2<TObject, TKey> <Data>k__BackingField;
    [NullableAttribute("2")]
[CompilerGeneratedAttribute]
private Exception <Error>k__BackingField;
    [CompilerGeneratedAttribute]
private IList`1<ISortedChangeSet`2<TObject, TKey>> <Messages>k__BackingField;
    [CompilerGeneratedAttribute]
private ChangeSummary <Summary>k__BackingField;
    public IObservableCache`2<TObject, TKey> Data { get; }
    [NullableAttribute("2")]
public Exception Error { get; private set; }
    public IList`1<ISortedChangeSet`2<TObject, TKey>> Messages { get; }
    public ChangeSummary Summary { get; private set; }
    public SortedChangeSetAggregator`2(IObservable`1<ISortedChangeSet`2<TObject, TKey>> source);
    [CompilerGeneratedAttribute]
public IObservableCache`2<TObject, TKey> get_Data();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public Exception get_Error();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
private void set_Error(Exception value);
    [CompilerGeneratedAttribute]
public IList`1<ISortedChangeSet`2<TObject, TKey>> get_Messages();
    [CompilerGeneratedAttribute]
public ChangeSummary get_Summary();
    [CompilerGeneratedAttribute]
private void set_Summary(ChangeSummary value);
    public sealed virtual void Dispose();
    protected virtual void Dispose(bool isDisposing);
    [CompilerGeneratedAttribute]
private void <.ctor>b__2_1(Exception ex);
    [NullableContextAttribute("0")]
[CompilerGeneratedAttribute]
private void <.ctor>b__2_2(ISortedChangeSet`2<TObject, TKey> updates);
    [NullableContextAttribute("0")]
[CompilerGeneratedAttribute]
private void <.ctor>b__2_3(ChangeSummary summary);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
public static class DynamicData.Tests.TestEx : object {
    [ExtensionAttribute]
public static ChangeSetAggregator`2<TObject, TKey> AsAggregator(IObservable`1<IChangeSet`2<TObject, TKey>> source);
    [ExtensionAttribute]
public static ChangeSetAggregator`3<TObject, TKey, TContext> AsAggregator(IObservable`1<IChangeSet`3<TObject, TKey, TContext>> source);
    [ExtensionAttribute]
public static DistinctChangeSetAggregator`1<TValue> AsAggregator(IObservable`1<IDistinctChangeSet`1<TValue>> source);
    [ExtensionAttribute]
public static GroupChangeSetAggregator`3<TValue, TKey, TGroupKey> AsAggregator(IObservable`1<IGroupChangeSet`3<TValue, TKey, TGroupKey>> source);
    [ExtensionAttribute]
public static SortedChangeSetAggregator`2<TObject, TKey> AsAggregator(IObservable`1<ISortedChangeSet`2<TObject, TKey>> source);
    [ExtensionAttribute]
public static VirtualChangeSetAggregator`2<TObject, TKey> AsAggregator(IObservable`1<IVirtualChangeSet`2<TObject, TKey>> source);
    [ExtensionAttribute]
public static PagedChangeSetAggregator`2<TObject, TKey> AsAggregator(IObservable`1<IPagedChangeSet`2<TObject, TKey>> source);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class DynamicData.Tests.VirtualChangeSetAggregator`2 : object {
    private IDisposable _disposer;
    private bool _isDisposed;
    [CompilerGeneratedAttribute]
private IObservableCache`2<TObject, TKey> <Data>k__BackingField;
    [NullableAttribute("2")]
[CompilerGeneratedAttribute]
private Exception <Error>k__BackingField;
    [CompilerGeneratedAttribute]
private IList`1<IVirtualChangeSet`2<TObject, TKey>> <Messages>k__BackingField;
    [CompilerGeneratedAttribute]
private ChangeSummary <Summary>k__BackingField;
    public IObservableCache`2<TObject, TKey> Data { get; }
    [NullableAttribute("2")]
public Exception Error { get; private set; }
    public IList`1<IVirtualChangeSet`2<TObject, TKey>> Messages { get; }
    public ChangeSummary Summary { get; private set; }
    public VirtualChangeSetAggregator`2(IObservable`1<IVirtualChangeSet`2<TObject, TKey>> source);
    [CompilerGeneratedAttribute]
public IObservableCache`2<TObject, TKey> get_Data();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public Exception get_Error();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
private void set_Error(Exception value);
    [CompilerGeneratedAttribute]
public IList`1<IVirtualChangeSet`2<TObject, TKey>> get_Messages();
    [CompilerGeneratedAttribute]
public ChangeSummary get_Summary();
    [CompilerGeneratedAttribute]
private void set_Summary(ChangeSummary value);
    public sealed virtual void Dispose();
    protected virtual void Dispose(bool isDisposing);
    [CompilerGeneratedAttribute]
private void <.ctor>b__2_1(Exception ex);
    [NullableContextAttribute("0")]
[CompilerGeneratedAttribute]
private void <.ctor>b__2_2(IVirtualChangeSet`2<TObject, TKey> updates);
    [NullableContextAttribute("0")]
[CompilerGeneratedAttribute]
private void <.ctor>b__2_3(ChangeSummary summary);
}
public class DynamicData.TransformAsyncOptions : ValueType {
    [CompilerGeneratedAttribute]
private Nullable`1<int> <MaximumConcurrency>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <TransformOnRefresh>k__BackingField;
    public static TransformAsyncOptions Default;
    public Nullable`1<int> MaximumConcurrency { get; public set; }
    public bool TransformOnRefresh { get; public set; }
    public TransformAsyncOptions(Nullable`1<int> MaximumConcurrency, bool TransformOnRefresh);
    private static TransformAsyncOptions();
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public Nullable`1<int> get_MaximumConcurrency();
    [CompilerGeneratedAttribute]
public void set_MaximumConcurrency(Nullable`1<int> value);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public bool get_TransformOnRefresh();
    [CompilerGeneratedAttribute]
public void set_TransformOnRefresh(bool value);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public virtual string ToString();
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
private bool PrintMembers(StringBuilder builder);
    [CompilerGeneratedAttribute]
public static bool op_Inequality(TransformAsyncOptions left, TransformAsyncOptions right);
    [CompilerGeneratedAttribute]
public static bool op_Equality(TransformAsyncOptions left, TransformAsyncOptions right);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public virtual int GetHashCode();
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public virtual bool Equals(object obj);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public sealed virtual bool Equals(TransformAsyncOptions other);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public void Deconstruct(Nullable`1& MaximumConcurrency, Boolean& TransformOnRefresh);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class DynamicData.UnspecifiedIndexException : Exception {
    public UnspecifiedIndexException(string message);
    public UnspecifiedIndexException(string message, Exception innerException);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class DynamicData.VirtualChangeSet`1 : object {
    private IChangeSet`1<T> _virtualChangeSet;
    [CompilerGeneratedAttribute]
private IVirtualResponse <Response>k__BackingField;
    public int Refreshes { get; }
    public IVirtualResponse Response { get; }
    private int DynamicData.IChangeSet.Adds { get; }
    private int DynamicData.IChangeSet.Capacity { get; private set; }
    private int DynamicData.IChangeSet.Count { get; }
    private int DynamicData.IChangeSet.Moves { get; }
    private int DynamicData.IChangeSet.Removes { get; }
    private int DynamicData.IChangeSet<T>.Replaced { get; }
    private int DynamicData.IChangeSet<T>.TotalChanges { get; }
    public VirtualChangeSet`1(IChangeSet`1<T> virtualChangeSet, IVirtualResponse response);
    public sealed virtual int get_Refreshes();
    [CompilerGeneratedAttribute]
public sealed virtual IVirtualResponse get_Response();
    private sealed virtual override int DynamicData.IChangeSet.get_Adds();
    private sealed virtual override int DynamicData.IChangeSet.get_Capacity();
    private sealed virtual override void DynamicData.IChangeSet.set_Capacity(int value);
    private sealed virtual override int DynamicData.IChangeSet.get_Count();
    private sealed virtual override int DynamicData.IChangeSet.get_Moves();
    private sealed virtual override int DynamicData.IChangeSet.get_Removes();
    private sealed virtual override int DynamicData.IChangeSet<T>.get_Replaced();
    private sealed virtual override int DynamicData.IChangeSet<T>.get_TotalChanges();
    public sealed virtual IEnumerator`1<Change`1<T>> GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal class DynamicData.VirtualChangeSet`2 : ChangeSet`2<TObject, TKey> {
    public static IVirtualChangeSet`2<TObject, TKey> Empty;
    [CompilerGeneratedAttribute]
private IVirtualResponse <Response>k__BackingField;
    [CompilerGeneratedAttribute]
private IKeyValueCollection`2<TObject, TKey> <SortedItems>k__BackingField;
    public IVirtualResponse Response { get; }
    public IKeyValueCollection`2<TObject, TKey> SortedItems { get; }
    public VirtualChangeSet`2(IEnumerable`1<Change`2<TObject, TKey>> items, IKeyValueCollection`2<TObject, TKey> sortedItems, IVirtualResponse response);
    private static VirtualChangeSet`2();
    [CompilerGeneratedAttribute]
public sealed virtual IVirtualResponse get_Response();
    [CompilerGeneratedAttribute]
public sealed virtual IKeyValueCollection`2<TObject, TKey> get_SortedItems();
    public static bool op_Equality(VirtualChangeSet`2<TObject, TKey> left, VirtualChangeSet`2<TObject, TKey> right);
    public static bool op_Inequality(VirtualChangeSet`2<TObject, TKey> left, VirtualChangeSet`2<TObject, TKey> right);
    public sealed virtual bool Equals(VirtualChangeSet`2<TObject, TKey> other);
    [NullableContextAttribute("2")]
public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    private sealed virtual override int DynamicData.IChangeSet.get_Capacity();
    private sealed virtual override void DynamicData.IChangeSet.set_Capacity(int value);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class DynamicData.VirtualContext`1 : object {
    [CompilerGeneratedAttribute]
private IVirtualResponse <Response>k__BackingField;
    [CompilerGeneratedAttribute]
private IComparer`1<TObject> <Comparer>k__BackingField;
    [CompilerGeneratedAttribute]
private SortAndVirtualizeOptions <Options>k__BackingField;
    internal static VirtualContext`1<TObject> Empty;
    [CompilerGeneratedAttribute]
protected Type EqualityContract { get; }
    public IVirtualResponse Response { get; public set; }
    public IComparer`1<TObject> Comparer { get; public set; }
    public SortAndVirtualizeOptions Options { get; public set; }
    public VirtualContext`1(IVirtualResponse Response, IComparer`1<TObject> Comparer, SortAndVirtualizeOptions Options);
    [CompilerGeneratedAttribute]
protected VirtualContext`1(VirtualContext`1<TObject> original);
    private static VirtualContext`1();
    [CompilerGeneratedAttribute]
protected virtual Type get_EqualityContract();
    [CompilerGeneratedAttribute]
public IVirtualResponse get_Response();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_Response(IVirtualResponse value);
    [CompilerGeneratedAttribute]
public IComparer`1<TObject> get_Comparer();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_Comparer(IComparer`1<TObject> value);
    [CompilerGeneratedAttribute]
public SortAndVirtualizeOptions get_Options();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_Options(SortAndVirtualizeOptions value);
    [CompilerGeneratedAttribute]
public virtual string ToString();
    [CompilerGeneratedAttribute]
protected virtual bool PrintMembers(StringBuilder builder);
    [CompilerGeneratedAttribute]
public static bool op_Inequality(VirtualContext`1<TObject> left, VirtualContext`1<TObject> right);
    [CompilerGeneratedAttribute]
public static bool op_Equality(VirtualContext`1<TObject> left, VirtualContext`1<TObject> right);
    [CompilerGeneratedAttribute]
public virtual int GetHashCode();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public virtual bool Equals(object obj);
    [CompilerGeneratedAttribute]
public virtual bool Equals(VirtualContext`1<TObject> other);
    [CompilerGeneratedAttribute]
public virtual VirtualContext`1<TObject> <Clone>$();
    [CompilerGeneratedAttribute]
public void Deconstruct(IVirtualResponse& Response, IComparer`1& Comparer, SortAndVirtualizeOptions& Options);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
public class DynamicData.VirtualRequest : object {
    [NullableAttribute("1")]
public static VirtualRequest Default;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private static IEqualityComparer`1<IVirtualRequest> <StartIndexSizeComparer>k__BackingField;
    [CompilerGeneratedAttribute]
private int <Size>k__BackingField;
    [CompilerGeneratedAttribute]
private int <StartIndex>k__BackingField;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static IEqualityComparer`1<IVirtualRequest> StartIndexSizeComparer { get; }
    public int Size { get; }
    public int StartIndex { get; }
    public VirtualRequest(int startIndex, int size);
    private static VirtualRequest();
    [CompilerGeneratedAttribute]
public static IEqualityComparer`1<IVirtualRequest> get_StartIndexSizeComparer();
    [CompilerGeneratedAttribute]
public sealed virtual int get_Size();
    [CompilerGeneratedAttribute]
public sealed virtual int get_StartIndex();
    public sealed virtual bool Equals(IVirtualRequest other);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    [NullableContextAttribute("1")]
public virtual string ToString();
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
internal class DynamicData.VirtualResponse : object {
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private static IEqualityComparer`1<IVirtualResponse> <DefaultComparer>k__BackingField;
    [CompilerGeneratedAttribute]
private int <Size>k__BackingField;
    [CompilerGeneratedAttribute]
private int <StartIndex>k__BackingField;
    [CompilerGeneratedAttribute]
private int <TotalSize>k__BackingField;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static IEqualityComparer`1<IVirtualResponse> DefaultComparer { get; }
    public int Size { get; }
    public int StartIndex { get; }
    public int TotalSize { get; }
    public VirtualResponse(int size, int startIndex, int totalSize);
    private static VirtualResponse();
    [CompilerGeneratedAttribute]
public static IEqualityComparer`1<IVirtualResponse> get_DefaultComparer();
    [CompilerGeneratedAttribute]
public sealed virtual int get_Size();
    [CompilerGeneratedAttribute]
public sealed virtual int get_StartIndex();
    [CompilerGeneratedAttribute]
public sealed virtual int get_TotalSize();
    public sealed virtual bool Equals(IVirtualResponse other);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    [NullableContextAttribute("1")]
public virtual string ToString();
}
[GeneratedCodeAttribute("Nerdbank.GitVersioning.Tasks", "3.6.139.59561")]
[ExcludeFromCodeCoverageAttribute]
internal static class ThisAssembly : object {
    internal static string AssemblyConfiguration;
    internal static string AssemblyFileVersion;
    internal static string AssemblyInformationalVersion;
    internal static string AssemblyName;
    internal static string AssemblyTitle;
    internal static string AssemblyVersion;
    internal static DateTime GitCommitDate;
    internal static string GitCommitId;
    internal static bool IsPrerelease;
    internal static bool IsPublicRelease;
    internal static string RootNamespace;
    private static ThisAssembly();
}
