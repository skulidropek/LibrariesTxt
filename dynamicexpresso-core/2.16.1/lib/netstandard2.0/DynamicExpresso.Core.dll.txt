[FlagsAttribute]
public enum DynamicExpresso.AssignmentOperators : Enum {
    public int value__;
    public static AssignmentOperators None;
    public static AssignmentOperators AssignmentEqual;
    public static AssignmentOperators All;
}
public enum DynamicExpresso.DefaultNumberType : Enum {
    public int value__;
    public static DefaultNumberType Default;
    public static DefaultNumberType Int;
    public static DefaultNumberType Long;
    public static DefaultNumberType Single;
    public static DefaultNumberType Double;
    public static DefaultNumberType Decimal;
}
internal class DynamicExpresso.Detector : object {
    private ParserSettings _settings;
    private static string Type;
    private static string Id;
    private static Regex LambdaDetectionRegex;
    private static Regex IdentifiersDetectionRegex;
    private static Regex StringDetectionRegex;
    private static Regex CharDetectionRegex;
    public Detector(ParserSettings settings);
    private static Detector();
    public IdentifiersInfo DetectIdentifiers(string expression);
    private static string PrepareExpression(string expression);
    private static string RemoveStringLiterals(string expression);
    private static string RemoveCharLiterals(string expression);
    private bool IsReservedKeyword(string identifier);
}
public class DynamicExpresso.Exceptions.AssignmentOperatorDisabledException : ParseException {
    [CompilerGeneratedAttribute]
private string <OperatorString>k__BackingField;
    public string OperatorString { get; private set; }
    public AssignmentOperatorDisabledException(string operatorString, int position);
    protected AssignmentOperatorDisabledException(SerializationInfo info, StreamingContext context);
    [CompilerGeneratedAttribute]
public string get_OperatorString();
    [CompilerGeneratedAttribute]
private void set_OperatorString(string value);
    public virtual void GetObjectData(SerializationInfo info, StreamingContext context);
}
public class DynamicExpresso.Exceptions.DuplicateParameterException : DynamicExpressoException {
    [CompilerGeneratedAttribute]
private string <Identifier>k__BackingField;
    public string Identifier { get; private set; }
    public DuplicateParameterException(string identifier);
    protected DuplicateParameterException(SerializationInfo info, StreamingContext context);
    [CompilerGeneratedAttribute]
public string get_Identifier();
    [CompilerGeneratedAttribute]
private void set_Identifier(string value);
    public virtual void GetObjectData(SerializationInfo info, StreamingContext context);
}
public class DynamicExpresso.Exceptions.DynamicExpressoException : Exception {
    public DynamicExpressoException(string message);
    public DynamicExpressoException(string message, Exception inner);
    protected DynamicExpressoException(SerializationInfo info, StreamingContext context);
}
public class DynamicExpresso.Exceptions.NoApplicableMethodException : ParseException {
    [CompilerGeneratedAttribute]
private string <MethodTypeName>k__BackingField;
    [CompilerGeneratedAttribute]
private string <MethodName>k__BackingField;
    public string MethodTypeName { get; private set; }
    public string MethodName { get; private set; }
    public NoApplicableMethodException(string methodName, string methodTypeName, int position);
    protected NoApplicableMethodException(SerializationInfo info, StreamingContext context);
    [CompilerGeneratedAttribute]
public string get_MethodTypeName();
    [CompilerGeneratedAttribute]
private void set_MethodTypeName(string value);
    [CompilerGeneratedAttribute]
public string get_MethodName();
    [CompilerGeneratedAttribute]
private void set_MethodName(string value);
    public virtual void GetObjectData(SerializationInfo info, StreamingContext context);
}
public class DynamicExpresso.Exceptions.ParseException : DynamicExpressoException {
    [CompilerGeneratedAttribute]
private int <Position>k__BackingField;
    public int Position { get; private set; }
    public ParseException(string message, int position);
    public ParseException(string message, int position, Exception innerException);
    protected ParseException(SerializationInfo info, StreamingContext context);
    [CompilerGeneratedAttribute]
public int get_Position();
    [CompilerGeneratedAttribute]
private void set_Position(int value);
    public virtual void GetObjectData(SerializationInfo info, StreamingContext context);
}
public class DynamicExpresso.Exceptions.ReflectionNotAllowedException : ParseException {
    protected ReflectionNotAllowedException(SerializationInfo info, StreamingContext context);
    public virtual void GetObjectData(SerializationInfo info, StreamingContext context);
}
public class DynamicExpresso.Exceptions.UnknownIdentifierException : ParseException {
    [CompilerGeneratedAttribute]
private string <Identifier>k__BackingField;
    public string Identifier { get; private set; }
    public UnknownIdentifierException(string identifier, int position);
    protected UnknownIdentifierException(SerializationInfo info, StreamingContext context);
    [CompilerGeneratedAttribute]
public string get_Identifier();
    [CompilerGeneratedAttribute]
private void set_Identifier(string value);
    public virtual void GetObjectData(SerializationInfo info, StreamingContext context);
}
internal class DynamicExpresso.FunctionIdentifier : Identifier {
    internal FunctionIdentifier(string name, Delegate value);
    internal void AddOverload(Delegate overload);
}
public class DynamicExpresso.Identifier : object {
    [CompilerGeneratedAttribute]
private Expression <Expression>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    public Expression Expression { get; private set; }
    public string Name { get; private set; }
    public Identifier(string name, Expression expression);
    [CompilerGeneratedAttribute]
public Expression get_Expression();
    [CompilerGeneratedAttribute]
private void set_Expression(Expression value);
    [CompilerGeneratedAttribute]
public string get_Name();
    [CompilerGeneratedAttribute]
private void set_Name(string value);
}
public class DynamicExpresso.IdentifiersInfo : object {
    [CompilerGeneratedAttribute]
private IEnumerable`1<string> <UnknownIdentifiers>k__BackingField;
    [CompilerGeneratedAttribute]
private IEnumerable`1<Identifier> <Identifiers>k__BackingField;
    [CompilerGeneratedAttribute]
private IEnumerable`1<ReferenceType> <Types>k__BackingField;
    public IEnumerable`1<string> UnknownIdentifiers { get; private set; }
    public IEnumerable`1<Identifier> Identifiers { get; private set; }
    public IEnumerable`1<ReferenceType> Types { get; private set; }
    public IdentifiersInfo(IEnumerable`1<string> unknownIdentifiers, IEnumerable`1<Identifier> identifiers, IEnumerable`1<ReferenceType> types);
    [CompilerGeneratedAttribute]
public IEnumerable`1<string> get_UnknownIdentifiers();
    [CompilerGeneratedAttribute]
private void set_UnknownIdentifiers(IEnumerable`1<string> value);
    [CompilerGeneratedAttribute]
public IEnumerable`1<Identifier> get_Identifiers();
    [CompilerGeneratedAttribute]
private void set_Identifiers(IEnumerable`1<Identifier> value);
    [CompilerGeneratedAttribute]
public IEnumerable`1<ReferenceType> get_Types();
    [CompilerGeneratedAttribute]
private void set_Types(IEnumerable`1<ReferenceType> value);
}
public class DynamicExpresso.Interpreter : object {
    private ParserSettings _settings;
    private ISet`1<ExpressionVisitor> _visitors;
    public bool CaseInsensitive { get; }
    public IEnumerable`1<ReferenceType> ReferencedTypes { get; }
    public IEnumerable`1<Identifier> Identifiers { get; }
    public AssignmentOperators AssignmentOperators { get; }
    public ISet`1<ExpressionVisitor> Visitors { get; }
    public Interpreter(InterpreterOptions options);
    internal Interpreter(ParserSettings settings);
    public bool get_CaseInsensitive();
    public IEnumerable`1<ReferenceType> get_ReferencedTypes();
    public IEnumerable`1<Identifier> get_Identifiers();
    public AssignmentOperators get_AssignmentOperators();
    public Interpreter SetDefaultNumberType(DefaultNumberType defaultNumberType);
    public Interpreter EnableAssignment(AssignmentOperators assignmentOperators);
    public ISet`1<ExpressionVisitor> get_Visitors();
    public Interpreter EnableReflection();
    public Interpreter SetFunction(string name, Delegate value);
    public Interpreter SetVariable(string name, object value);
    public Interpreter SetVariable(string name, T value);
    public Interpreter SetVariable(string name, object value, Type type);
    public Interpreter SetExpression(string name, Expression expression);
    public Interpreter SetIdentifiers(IEnumerable`1<Identifier> identifiers);
    public Interpreter SetIdentifier(Identifier identifier);
    public Interpreter UnsetFunction(string name);
    public Interpreter UnsetVariable(string name);
    public Interpreter UnsetExpression(string name);
    public Interpreter UnsetIdentifier(string name);
    public Interpreter Reference(Type type);
    public Interpreter Reference(IEnumerable`1<ReferenceType> types);
    public Interpreter Reference(Type type, string typeName);
    public Interpreter Reference(ReferenceType type);
    public Lambda Parse(string expressionText, Parameter[] parameters);
    public Lambda Parse(string expressionText, Type expressionType, Parameter[] parameters);
    [ObsoleteAttribute("Use ParseAsDelegate<TDelegate>(string, params string[])")]
public TDelegate Parse(string expressionText, String[] parametersNames);
    public TDelegate ParseAsDelegate(string expressionText, String[] parametersNames);
    public Expression`1<TDelegate> ParseAsExpression(string expressionText, String[] parametersNames);
    internal LambdaExpression ParseAsExpression(Type delegateType, string expressionText, String[] parametersNames);
    public Lambda ParseAs(string expressionText, String[] parametersNames);
    internal Lambda ParseAs(Type delegateType, string expressionText, String[] parametersNames);
    public object Eval(string expressionText, Parameter[] parameters);
    public T Eval(string expressionText, Parameter[] parameters);
    public object Eval(string expressionText, Type expressionType, Parameter[] parameters);
    public IdentifiersInfo DetectIdentifiers(string expression);
    private Lambda ParseAsLambda(string expressionText, Type expressionType, Parameter[] parameters);
}
[FlagsAttribute]
public enum DynamicExpresso.InterpreterOptions : Enum {
    public int value__;
    public static InterpreterOptions None;
    public static InterpreterOptions PrimitiveTypes;
    public static InterpreterOptions SystemKeywords;
    public static InterpreterOptions CommonTypes;
    public static InterpreterOptions CaseInsensitive;
    public static InterpreterOptions LateBindObject;
    public static InterpreterOptions LambdaExpressions;
    public static InterpreterOptions Default;
    public static InterpreterOptions DefaultCaseInsensitive;
}
public class DynamicExpresso.Lambda : object {
    private Expression _expression;
    private ParserArguments _parserArguments;
    private Lazy`1<Delegate> _delegate;
    public Expression Expression { get; }
    public bool CaseInsensitive { get; }
    public string ExpressionText { get; }
    public Type ReturnType { get; }
    [ObsoleteAttribute("Use UsedParameters or DeclaredParameters")]
public IEnumerable`1<Parameter> Parameters { get; }
    public IEnumerable`1<Parameter> UsedParameters { get; }
    public IEnumerable`1<Parameter> DeclaredParameters { get; }
    public IEnumerable`1<ReferenceType> Types { get; }
    public IEnumerable`1<Identifier> Identifiers { get; }
    internal Lambda(Expression expression, ParserArguments parserArguments);
    public Expression get_Expression();
    public bool get_CaseInsensitive();
    public string get_ExpressionText();
    public Type get_ReturnType();
    public IEnumerable`1<Parameter> get_Parameters();
    public IEnumerable`1<Parameter> get_UsedParameters();
    public IEnumerable`1<Parameter> get_DeclaredParameters();
    public IEnumerable`1<ReferenceType> get_Types();
    public IEnumerable`1<Identifier> get_Identifiers();
    public object Invoke();
    public object Invoke(Parameter[] parameters);
    public object Invoke(IEnumerable`1<Parameter> parameters);
    public object Invoke(Object[] args);
    private object InvokeWithUsedParameters(Object[] orderedArgs);
    public virtual string ToString();
    public TDelegate Compile();
    [ObsoleteAttribute("Use Compile<TDelegate>()")]
public TDelegate Compile(IEnumerable`1<Parameter> parameters);
    public Expression`1<TDelegate> LambdaExpression();
    internal LambdaExpression LambdaExpression(Type delegateType);
    [CompilerGeneratedAttribute]
private Delegate <.ctor>b__3_0();
}
public static class DynamicExpresso.LanguageConstants : object {
    public static string This;
    public static ReferenceType[] PrimitiveTypes;
    public static ReferenceType[] CSharpPrimitiveTypes;
    public static ReferenceType[] CommonTypes;
    public static Identifier[] Literals;
    [ObsoleteAttribute("Use ReservedKeywords")]
public static String[] ReserverKeywords;
    public static String[] ReservedKeywords;
    private static LanguageConstants();
}
internal class DynamicExpresso.MethodGroupExpression : Expression {
    private List`1<Delegate> _overloads;
    internal IReadOnlyCollection`1<Delegate> Overloads { get; }
    internal MethodGroupExpression(Delegate overload);
    internal IReadOnlyCollection`1<Delegate> get_Overloads();
    internal void AddOverload(Delegate overload);
    private void RemoveDelegateSignature(Delegate overload);
    private static bool HasSameSignature(MethodInfo method, MethodInfo other);
}
public class DynamicExpresso.Parameter : object {
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    [CompilerGeneratedAttribute]
private Type <Type>k__BackingField;
    [CompilerGeneratedAttribute]
private object <Value>k__BackingField;
    [CompilerGeneratedAttribute]
private ParameterExpression <Expression>k__BackingField;
    public string Name { get; private set; }
    public Type Type { get; private set; }
    public object Value { get; private set; }
    public ParameterExpression Expression { get; private set; }
    public Parameter(string name, object value);
    public Parameter(ParameterExpression parameterExpression);
    public Parameter(string name, Type type, object value);
    public static Parameter Create(string name, T value);
    [CompilerGeneratedAttribute]
public string get_Name();
    [CompilerGeneratedAttribute]
private void set_Name(string value);
    [CompilerGeneratedAttribute]
public Type get_Type();
    [CompilerGeneratedAttribute]
private void set_Type(Type value);
    [CompilerGeneratedAttribute]
public object get_Value();
    [CompilerGeneratedAttribute]
private void set_Value(object value);
    [CompilerGeneratedAttribute]
public ParameterExpression get_Expression();
    [CompilerGeneratedAttribute]
private void set_Expression(ParameterExpression value);
}
internal class DynamicExpresso.ParserArguments : object {
    private Dictionary`2<string, Parameter> _declaredParameters;
    private HashSet`1<Parameter> _usedParameters;
    private HashSet`1<ReferenceType> _usedTypes;
    private HashSet`1<Identifier> _usedIdentifiers;
    [CompilerGeneratedAttribute]
private ParserSettings <Settings>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ExpressionText>k__BackingField;
    [CompilerGeneratedAttribute]
private Type <ExpressionReturnType>k__BackingField;
    public ParserSettings Settings { get; private set; }
    public string ExpressionText { get; private set; }
    public Type ExpressionReturnType { get; private set; }
    public IEnumerable`1<Parameter> DeclaredParameters { get; }
    public IEnumerable`1<Parameter> UsedParameters { get; }
    public IEnumerable`1<ReferenceType> UsedTypes { get; }
    public IEnumerable`1<Identifier> UsedIdentifiers { get; }
    public ParserArguments(string expressionText, ParserSettings settings, Type expressionReturnType, IEnumerable`1<Parameter> declaredParameters);
    [CompilerGeneratedAttribute]
public ParserSettings get_Settings();
    [CompilerGeneratedAttribute]
private void set_Settings(ParserSettings value);
    [CompilerGeneratedAttribute]
public string get_ExpressionText();
    [CompilerGeneratedAttribute]
private void set_ExpressionText(string value);
    [CompilerGeneratedAttribute]
public Type get_ExpressionReturnType();
    [CompilerGeneratedAttribute]
private void set_ExpressionReturnType(Type value);
    public IEnumerable`1<Parameter> get_DeclaredParameters();
    public IEnumerable`1<Parameter> get_UsedParameters();
    public IEnumerable`1<ReferenceType> get_UsedTypes();
    public IEnumerable`1<Identifier> get_UsedIdentifiers();
    public bool TryGetKnownType(string name, Type& type);
    public bool TryGetIdentifier(string name, Expression& expression);
    public bool TryGetParameters(string name, ParameterExpression& expression);
    public IEnumerable`1<MethodInfo> GetExtensionMethods(string methodName);
}
internal class DynamicExpresso.Parsing.Parser : object {
    private static NumberStyles ParseLiteralNumberStyle;
    private static NumberStyles ParseLiteralUnsignedNumberStyle;
    private static NumberStyles ParseLiteralHexNumberStyle;
    private static NumberStyles ParseLiteralDecimalNumberStyle;
    private static NumberStyles ParseLiteralDoubleNumberStyle;
    private static CultureInfo ParseCulture;
    private ParserArguments _arguments;
    private static MethodInfo _concatMethod;
    private static MethodInfo _toStringMethod;
    private int _parsePosition;
    private string _expressionText;
    private int _expressionTextLength;
    private char _parseChar;
    private Token _token;
    private BindingFlags _bindingCase;
    private MemberFilter _memberFilterCase;
    private DefaultNumberType _defaultNumberType;
    private Parser(ParserArguments arguments);
    private static Parser();
    public static Expression Parse(ParserArguments arguments);
    private static MethodInfo GetConcatMethod();
    private static MethodInfo GetToStringMethod();
    private Expression Parse();
    private Expression ParseExpressionSegment(Type returnType);
    private Expression ParseExpressionSegment();
    private Expression ParseLambdaExpression();
    private ParameterWithPosition[] ParseLambdaParameterList();
    private ParameterWithPosition[] ParseLambdaParameters();
    private ParameterWithPosition ParseLambdaParameter();
    private Expression ParseAssignment();
    private Expression ParseConditional();
    private Expression ParseConditionalOr();
    private Expression ParseConditionalAnd();
    private Expression ParseLogicalOr();
    private Expression ParseLogicalXor();
    private Expression ParseLogicalAnd();
    private Expression ParseComparison();
    private Expression ParseTypeTesting();
    private Expression ParseAdditive();
    private Expression ParseShift();
    public bool IsShiftOperator(ExpressionType& shiftType);
    private Expression ParseMultiplicative();
    private Expression ParseUnary();
    private Expression GenerateUnary(ExpressionType unaryType, Expression expr);
    private Expression GenerateUnaryEnums(ExpressionType unaryType, Expression expr);
    private Expression GenerateUnaryDynamic(ExpressionType unaryType, Expression expr);
    private MethodData FindUnaryOperator(string operatorName, Expression expr);
    private Expression ParsePrimary();
    private Expression GenerateGetNullableValue(Expression expr);
    private Expression ParsePrimaryStart();
    private Expression ParseCharLiteral();
    private Expression ParseStringLiteral();
    private string EvalEscapeStringLiteral(string source);
    private char EvalEscapeChar(char source);
    private Expression ParseIntegerLiteral();
    private Expression ParseRealLiteral();
    private static Expression CreateLiteral(object value);
    private Expression ParseParenExpression();
    private Expression ParseIdentifier();
    private Expression ParseTypeof();
    private Expression ParseDefaultOperator();
    private Expression GenerateConditional(Expression test, Expression expr1, Expression expr2, int errorPos);
    private Expression GenerateConditionalDynamic(Expression test, Expression expr1, Expression expr2, int errorPos);
    private Expression ParseNew();
    private Expression[] ParseArrayInitializerList();
    private Expression ParseWithObjectInitializer(NewExpression newExpr, Type newType);
    private Expression ParseMemberAndInitializerList(NewExpression newExpr, Type newType);
    private void ParsePossibleMemberBinding(Type newType, int originalPos, List`1<MemberBinding> bindingList, List`1<Expression> actions, ParameterExpression instance, bool allowCollectionInit);
    private void ParseCollectionInitalizer(Type newType, int originalPos, List`1<MemberBinding> bindingList, List`1<Expression> actions, ParameterExpression instance, bool allowCollectionInit);
    private Expression ParseLambdaInvocation(LambdaExpression lambda, int errorPos);
    private Expression ParseDelegateInvocation(Expression delegateExp, int errorPos);
    private Expression ParseInvocation(Expression expr, int errorPos, string error);
    private Expression ParseMethodGroupInvocation(MethodGroupExpression methodGroup, int errorPos);
    private Type ParseKnownType();
    private bool TryParseKnownType(string name, Type& type);
    private Type ParseKnownGenericType(string name, Type type);
    private Type ParseTypeModifiers(Type type);
    private Type ParseArrayRankSpecifier(Type type);
    private List`1<Type> ParseTypeArgumentList();
    private List`1<Type> ParseTypeArguments();
    private int ParseUnboundTypeArity();
    private Expression ParseTypeKeyword(Type type);
    private Expression GenerateConversion(Expression expr, Type type, int errorPos);
    private Expression ParseMemberAccess(Expression instance);
    private Expression ParseMemberAccess(Type type, Expression instance);
    private Expression GeneratePropertyOrFieldExpression(Type type, Expression instance, int errorPos, string propertyOrFieldName);
    private Expression ParseMethodInvocation(Type type, Expression instance, int errorPos, string methodName);
    private Expression ParseMethodInvocation(Type type, Expression instance, int errorPos, string methodName, TokenId open, string openExpected, TokenId close, string closeExpected);
    private Expression ParseExtensionMethodInvocation(Type type, Expression instance, int errorPos, string id, Expression[] args);
    private Expression ParseNormalMethodInvocation(Type type, Expression instance, int errorPos, string id, Expression[] args);
    private static Type RemoveArrayType(Type t);
    private static Expression ParseDynamicProperty(Type type, Expression instance, string propertyOrFieldName);
    private static Expression ParseDynamicMethodInvocation(Type type, Expression instance, string methodName, Expression[] args);
    private static Expression ParseDynamicIndex(Type type, Expression instance, Expression[] args);
    private Expression[] ParseArgumentList(TokenId openToken, string missingOpenTokenMsg, TokenId closeToken, string missingCloseTokenMsg, bool allowTrailingComma);
    private Expression[] ParseArgumentList();
    private Expression ParseElementAccess(Expression expr);
    private static bool IsNullableType(Type type);
    private static bool IsDynamicType(Type type);
    private bool IsDynamicExpression(Expression instance);
    private static Type GetNonNullableType(Type type);
    private static string GetTypeName(Type type);
    private static bool IsNumericType(Type type);
    private static bool IsSignedIntegralType(Type type);
    private static bool IsUnsignedIntegralType(Type type);
    private static int GetNumericTypeKind(Type type);
    private void CheckAndPromoteOperand(Type signatures, Expression& expr);
    private void CheckAndPromoteOperands(Type signatures, Expression& left, Expression& right);
    private Expression[] PrepareOperandArguments(Type signatures, Expression[] args);
    private MemberInfo FindPropertyOrField(Type type, string memberName, bool staticAccess);
    private MethodData[] FindMethods(Type type, string methodName, bool staticAccess, Expression[] args);
    private MethodData FindInvokeMethod(Type type);
    private MethodData[] FindExtensionMethods(string methodName, Expression[] args);
    private MethodData[] FindIndexer(Type type, Expression[] args);
    private static IEnumerable`1<Type> SelfAndBaseTypes(Type type);
    [IteratorStateMachineAttribute("DynamicExpresso.Parsing.Parser/<SelfAndBaseClasses>d__115")]
private static IEnumerable`1<Type> SelfAndBaseClasses(Type type);
    private static void AddInterface(List`1<Type> types, Type type);
    private static MethodData[] FindBestMethod(IEnumerable`1<MethodBase> methods, Expression[] args);
    private static MethodData[] FindBestMethod(IEnumerable`1<MethodData> methods, Expression[] args);
    private static Type GetConcreteTypeForGenericMethod(Type type, List`1<Expression> promotedArgs, MethodData method);
    private static bool CheckIfMethodIsApplicableAndPrepareIt(MethodData method, Expression[] args);
    private static LambdaExpression GenerateLambdaFromInterpreterExpression(InterpreterExpression ie, Type delegateType);
    private static MethodInfo MakeGenericMethod(MethodData method);
    private static Dictionary`2<string, Type> ExtractActualGenericArguments(Type[] methodGenericParameters, Type[] methodActualParameters);
    private static Expression PromoteExpression(Expression expr, Type type, bool exact);
    private static bool IsCompatibleWith(Type source, Type target);
    private static bool IsWritable(Expression expression);
    private static Type FindAssignableGenericType(Type givenType, Type constructedGenericType);
    private static bool HasParamsArrayType(ParameterInfo parameterInfo);
    private static Type GetParameterType(ParameterInfo parameterInfo);
    private static bool MethodHasPriority(Expression[] args, MethodData method, MethodData otherMethod);
    private static int CompareConversions(Type s, Type t1, Type t2);
    private Expression GenerateEqual(Expression left, Expression right);
    private Expression GenerateNotEqual(Expression left, Expression right);
    private Expression GenerateGreaterThan(Expression left, Expression right);
    private Expression GenerateGreaterThanEqual(Expression left, Expression right);
    private Expression GenerateLessThan(Expression left, Expression right);
    private Expression GenerateLessThanEqual(Expression left, Expression right);
    private Expression GenerateBinary(ExpressionType binaryType, Expression left, Expression right);
    private Expression GenerateBinaryDynamic(ExpressionType binaryType, Expression left, Expression right);
    private Expression GenerateBinaryEnums(ExpressionType binaryType, Expression left, Expression right);
    private MethodData FindBinaryOperator(string operatorName, Expression left, Expression right);
    private static Expression GenerateStringConcat(Expression left, Expression right);
    private static Expression ToStringOrNull(Expression expression);
    private static Expression GenerateStringConcatOperand(Expression expression);
    private static MethodInfo GetStaticMethod(string methodName, Expression left, Expression right);
    private static Expression GenerateStaticMethodCall(string methodName, Expression left, Expression right);
    private void SetTextPos(int pos);
    private void NextChar();
    private void PreviousChar();
    private void NextToken();
    private string GetIdentifier();
    private void ValidateDigit();
    private void ValidateToken(TokenId t, string errorMessage);
    private void ValidateToken(TokenId t);
    private static Exception WrapWithParseException(int pos, string format, Exception ex, Object[] args);
    private static Exception CreateParseException(int pos, string format, Object[] args);
    private static Expression GenerateNullableTypeConversion(Expression expr);
}
internal static class DynamicExpresso.Parsing.ParserConstants : object {
    public static Expression NullLiteralExpression;
    public static string KeywordAs;
    public static string KeywordIs;
    public static string KeywordNew;
    public static string KeywordTypeof;
    public static string KeywordDefault;
    public static String[] ReservedKeywords;
    private static ParserConstants();
}
internal class DynamicExpresso.Parsing.ParserSettings : object {
    private Dictionary`2<string, Identifier> _identifiers;
    private Dictionary`2<string, ReferenceType> _knownTypes;
    private HashSet`1<MethodInfo> _extensionMethods;
    [CompilerGeneratedAttribute]
private bool <CaseInsensitive>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <LateBindObject>k__BackingField;
    [CompilerGeneratedAttribute]
private StringComparison <KeyComparison>k__BackingField;
    [CompilerGeneratedAttribute]
private IEqualityComparer`1<string> <KeyComparer>k__BackingField;
    [CompilerGeneratedAttribute]
private DefaultNumberType <DefaultNumberType>k__BackingField;
    [CompilerGeneratedAttribute]
private AssignmentOperators <AssignmentOperators>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <LambdaExpressions>k__BackingField;
    public IDictionary`2<string, ReferenceType> KnownTypes { get; }
    public IDictionary`2<string, Identifier> Identifiers { get; }
    public HashSet`1<MethodInfo> ExtensionMethods { get; }
    public bool CaseInsensitive { get; }
    public bool LateBindObject { get; }
    public StringComparison KeyComparison { get; }
    public IEqualityComparer`1<string> KeyComparer { get; }
    public DefaultNumberType DefaultNumberType { get; public set; }
    public AssignmentOperators AssignmentOperators { get; public set; }
    public bool LambdaExpressions { get; public set; }
    public ParserSettings(bool caseInsensitive, bool lateBindObject);
    private ParserSettings(ParserSettings other);
    public ParserSettings Clone();
    public IDictionary`2<string, ReferenceType> get_KnownTypes();
    public IDictionary`2<string, Identifier> get_Identifiers();
    public HashSet`1<MethodInfo> get_ExtensionMethods();
    [CompilerGeneratedAttribute]
public bool get_CaseInsensitive();
    [CompilerGeneratedAttribute]
public bool get_LateBindObject();
    [CompilerGeneratedAttribute]
public StringComparison get_KeyComparison();
    [CompilerGeneratedAttribute]
public IEqualityComparer`1<string> get_KeyComparer();
    [CompilerGeneratedAttribute]
public DefaultNumberType get_DefaultNumberType();
    [CompilerGeneratedAttribute]
public void set_DefaultNumberType(DefaultNumberType value);
    [CompilerGeneratedAttribute]
public AssignmentOperators get_AssignmentOperators();
    [CompilerGeneratedAttribute]
public void set_AssignmentOperators(AssignmentOperators value);
    [CompilerGeneratedAttribute]
public bool get_LambdaExpressions();
    [CompilerGeneratedAttribute]
public void set_LambdaExpressions(bool value);
}
internal class DynamicExpresso.Parsing.ParseSignatures : object {
}
internal class DynamicExpresso.Parsing.Token : ValueType {
    public TokenId id;
    public string text;
    public int pos;
}
internal enum DynamicExpresso.Parsing.TokenId : Enum {
    public int value__;
    public static TokenId Unknown;
    public static TokenId End;
    public static TokenId Identifier;
    public static TokenId CharLiteral;
    public static TokenId StringLiteral;
    public static TokenId IntegerLiteral;
    public static TokenId RealLiteral;
    public static TokenId Exclamation;
    public static TokenId Percent;
    public static TokenId OpenParen;
    public static TokenId CloseParen;
    public static TokenId Asterisk;
    public static TokenId Plus;
    public static TokenId Comma;
    public static TokenId Minus;
    public static TokenId Tilde;
    public static TokenId Dot;
    public static TokenId QuestionQuestion;
    public static TokenId Slash;
    public static TokenId Colon;
    public static TokenId LessThan;
    public static TokenId GreaterThan;
    public static TokenId Question;
    public static TokenId OpenBracket;
    public static TokenId CloseBracket;
    public static TokenId ExclamationEqual;
    public static TokenId Amphersand;
    public static TokenId DoubleAmphersand;
    public static TokenId LessThanEqual;
    public static TokenId DoubleEqual;
    public static TokenId GreaterThanEqual;
    public static TokenId Bar;
    public static TokenId DoubleBar;
    public static TokenId Equal;
    public static TokenId Caret;
    public static TokenId OpenCurlyBracket;
    public static TokenId CloseCurlyBracket;
    public static TokenId LambdaArrow;
}
public class DynamicExpresso.ReferenceType : object {
    [CompilerGeneratedAttribute]
private Type <Type>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    [CompilerGeneratedAttribute]
private IList`1<MethodInfo> <ExtensionMethods>k__BackingField;
    public Type Type { get; private set; }
    public string Name { get; private set; }
    public IList`1<MethodInfo> ExtensionMethods { get; private set; }
    public ReferenceType(string name, Type type);
    public ReferenceType(Type type);
    [CompilerGeneratedAttribute]
public Type get_Type();
    [CompilerGeneratedAttribute]
private void set_Type(Type value);
    [CompilerGeneratedAttribute]
public string get_Name();
    [CompilerGeneratedAttribute]
private void set_Name(string value);
    [CompilerGeneratedAttribute]
public IList`1<MethodInfo> get_ExtensionMethods();
    [CompilerGeneratedAttribute]
private void set_ExtensionMethods(IList`1<MethodInfo> value);
}
internal static class DynamicExpresso.Reflection.ReflectionExtensions : object {
    public static DelegateInfo GetDelegateInfo(Type delegateType, String[] parametersNames);
    public static IEnumerable`1<MethodInfo> GetExtensionMethods(Type type);
}
[GeneratedCodeAttribute("System.Resources.Tools.StronglyTypedResourceBuilder", "4.0.0.0")]
[DebuggerNonUserCodeAttribute]
[CompilerGeneratedAttribute]
internal class DynamicExpresso.Resources.ErrorMessages : object {
    private static ResourceManager resourceMan;
    private static CultureInfo resourceCulture;
    [EditorBrowsableAttribute("2")]
internal static ResourceManager ResourceManager { get; }
    [EditorBrowsableAttribute("2")]
internal static CultureInfo Culture { get; internal set; }
    internal static string AmbiguousIndexerInvocation { get; }
    internal static string AmbiguousMethodInvocation { get; }
    internal static string AmbiguousUnaryOperatorInvocation { get; }
    internal static string AmbiguousBinaryOperatorInvocation { get; }
    internal static string AmbiguousDelegateInvocation { get; }
    internal static string ArgsIncompatibleWithDelegate { get; }
    internal static string ArgsIncompatibleWithLambda { get; }
    internal static string BothTypesConvertToOther { get; }
    internal static string CannotConvertValue { get; }
    internal static string CloseBracketOrCommaExpected { get; }
    internal static string CloseParenOrCommaExpected { get; }
    internal static string CloseParenOrOperatorExpected { get; }
    internal static string EqualExpected { get; }
    internal static string ColonExpected { get; }
    internal static string DigitExpected { get; }
    internal static string DotOrOpenParenExpected { get; }
    internal static string ExpressionExpected { get; }
    internal static string ExpressionMustBeWritable { get; }
    internal static string FirstExprMustBeBool { get; }
    internal static string Format { get; }
    internal static string IdentifierExpected { get; }
    internal static string IncompatibleOperand { get; }
    internal static string IncompatibleOperands { get; }
    internal static string IncorrectNumberOfIndexes { get; }
    internal static string InvalidCharacter { get; }
    internal static string InvalidCharacterLiteral { get; }
    internal static string InvalidEscapeSequence { get; }
    internal static string InvalidIndex { get; }
    internal static string InvalidIntegerLiteral { get; }
    internal static string InvalidMethodCall { get; }
    internal static string ParamsArrayTypeNotAnArray { get; }
    internal static string MethodTypeParametersCantBeInferred { get; }
    internal static string InvalidRealLiteral { get; }
    internal static string NeitherTypeConvertsToOther { get; }
    internal static string NoApplicableConstructor { get; }
    internal static string AmbiguousConstructorInvocation { get; }
    internal static string NoApplicableIndexer { get; }
    internal static string OpenParenExpected { get; }
    internal static string OpenCurlyBracketExpected { get; }
    internal static string CloseCurlyBracketExpected { get; }
    internal static string CloseTypeArgumentListExpected { get; }
    internal static string SyntaxError { get; }
    internal static string TypeHasNoNullableForm { get; }
    internal static string TypeIdentifierExpected { get; }
    internal static string TypeofRequiresAType { get; }
    internal static string TypeofRequiresOneArg { get; }
    internal static string UnknownPropertyOrField { get; }
    internal static string UnterminatedStringLiteral { get; }
    internal static string InvalidOperation { get; }
    internal static string UnsupportedMultidimensionalArrays { get; }
    internal static string InvalidInitializerMemberDeclarator { get; }
    internal static string CollectionInitializationNotSupported { get; }
    internal static string UnableToFindAppropriateAddMethod { get; }
    internal static ResourceManager get_ResourceManager();
    internal static CultureInfo get_Culture();
    internal static void set_Culture(CultureInfo value);
    internal static string get_AmbiguousIndexerInvocation();
    internal static string get_AmbiguousMethodInvocation();
    internal static string get_AmbiguousUnaryOperatorInvocation();
    internal static string get_AmbiguousBinaryOperatorInvocation();
    internal static string get_AmbiguousDelegateInvocation();
    internal static string get_ArgsIncompatibleWithDelegate();
    internal static string get_ArgsIncompatibleWithLambda();
    internal static string get_BothTypesConvertToOther();
    internal static string get_CannotConvertValue();
    internal static string get_CloseBracketOrCommaExpected();
    internal static string get_CloseParenOrCommaExpected();
    internal static string get_CloseParenOrOperatorExpected();
    internal static string get_EqualExpected();
    internal static string get_ColonExpected();
    internal static string get_DigitExpected();
    internal static string get_DotOrOpenParenExpected();
    internal static string get_ExpressionExpected();
    internal static string get_ExpressionMustBeWritable();
    internal static string get_FirstExprMustBeBool();
    internal static string get_Format();
    internal static string get_IdentifierExpected();
    internal static string get_IncompatibleOperand();
    internal static string get_IncompatibleOperands();
    internal static string get_IncorrectNumberOfIndexes();
    internal static string get_InvalidCharacter();
    internal static string get_InvalidCharacterLiteral();
    internal static string get_InvalidEscapeSequence();
    internal static string get_InvalidIndex();
    internal static string get_InvalidIntegerLiteral();
    internal static string get_InvalidMethodCall();
    internal static string get_ParamsArrayTypeNotAnArray();
    internal static string get_MethodTypeParametersCantBeInferred();
    internal static string get_InvalidRealLiteral();
    internal static string get_NeitherTypeConvertsToOther();
    internal static string get_NoApplicableConstructor();
    internal static string get_AmbiguousConstructorInvocation();
    internal static string get_NoApplicableIndexer();
    internal static string get_OpenParenExpected();
    internal static string get_OpenCurlyBracketExpected();
    internal static string get_CloseCurlyBracketExpected();
    internal static string get_CloseTypeArgumentListExpected();
    internal static string get_SyntaxError();
    internal static string get_TypeHasNoNullableForm();
    internal static string get_TypeIdentifierExpected();
    internal static string get_TypeofRequiresAType();
    internal static string get_TypeofRequiresOneArg();
    internal static string get_UnknownPropertyOrField();
    internal static string get_UnterminatedStringLiteral();
    internal static string get_InvalidOperation();
    internal static string get_UnsupportedMultidimensionalArrays();
    internal static string get_InvalidInitializerMemberDeclarator();
    internal static string get_CollectionInitializationNotSupported();
    internal static string get_UnableToFindAppropriateAddMethod();
}
public class DynamicExpresso.Visitors.DisableReflectionVisitor : ExpressionVisitor {
    protected virtual Expression VisitMethodCall(MethodCallExpression node);
    protected virtual Expression VisitMember(MemberExpression node);
}
