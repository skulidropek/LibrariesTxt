[CompilerGeneratedAttribute]
[EmbeddedAttribute]
internal class Microsoft.CodeAnalysis.EmbeddedAttribute : Attribute {
}
public abstract class Microsoft.Scripting.Actions.ActionBinder : object {
    private ScriptDomainManager _manager;
    public bool PrivateBinding { get; }
    [ObsoleteAttribute("ScriptDomainManager is no longer required by ActionBinder and will no longer be available on the base class.")]
public ScriptDomainManager Manager { get; }
    [ObsoleteAttribute("ScriptDomainManager is no longer required by ActionBinder and will go away, you should call the default constructor instead.  You should also override PrivateBinding which is the only thing which previously used the ScriptDomainManager.")]
protected ActionBinder(ScriptDomainManager manager);
    public virtual bool get_PrivateBinding();
    public ScriptDomainManager get_Manager();
    public virtual object Convert(object obj, Type toType);
    public abstract virtual bool CanConvertFrom(Type fromType, Type toType, bool toNotNullable, NarrowingLevel level);
    public abstract virtual Candidate PreferConvert(Type t1, Type t2);
    public virtual Expression ConvertExpression(Expression expr, Type toType, ConversionResultKind kind, OverloadResolverFactory resolverFactory);
    public virtual MemberGroup GetMember(MemberRequestKind action, Type type, string name);
    public virtual ErrorInfo MakeContainsGenericParametersError(MemberTracker tracker);
    public virtual ErrorInfo MakeMissingMemberErrorInfo(Type type, string name);
    public virtual ErrorInfo MakeGenericAccessError(MemberTracker info);
    public ErrorInfo MakeStaticPropertyInstanceAccessError(PropertyTracker tracker, bool isAssignment, DynamicMetaObject[] parameters);
    public virtual ErrorInfo MakeStaticAssignFromDerivedTypeError(Type accessingType, DynamicMetaObject self, MemberTracker assigning, DynamicMetaObject assignedValue, OverloadResolverFactory context);
    public virtual ErrorInfo MakeStaticPropertyInstanceAccessError(PropertyTracker tracker, bool isAssignment, IList`1<DynamicMetaObject> parameters);
    public virtual ErrorInfo MakeSetValueTypeFieldError(FieldTracker field, DynamicMetaObject instance, DynamicMetaObject value);
    public virtual ErrorInfo MakeConversionError(Type toType, Expression value);
    public virtual ErrorInfo MakeMissingMemberError(Type type, DynamicMetaObject self, string name);
    public virtual ErrorInfo MakeMissingMemberErrorForAssign(Type type, DynamicMetaObject self, string name);
    public virtual ErrorInfo MakeMissingMemberErrorForAssignReadOnlyProperty(Type type, DynamicMetaObject self, string name);
    public virtual ErrorInfo MakeMissingMemberErrorForDelete(Type type, DynamicMetaObject self, string name);
    public virtual string GetTypeName(Type t);
    public virtual string GetObjectTypeName(object arg);
    public MemberGroup GetAllExtensionMembers(Type type, string name);
    public MemberGroup GetExtensionMembers(Type declaringType, string name);
    private MethodInfo GetExtensionOperator(Type ext, string name);
    public virtual bool IncludeExtensionMember(MemberInfo member);
    public virtual IList`1<Type> GetExtensionTypes(Type t);
    public virtual DynamicMetaObject ReturnMemberTracker(Type type, MemberTracker memberTracker);
    public DynamicMetaObject MakeCallExpression(OverloadResolverFactory resolverFactory, MethodInfo method, DynamicMetaObject[] parameters);
}
public class Microsoft.Scripting.Actions.Argument : ValueType {
    private ArgumentType _kind;
    private string _name;
    public static Argument Simple;
    public ArgumentType Kind { get; }
    public string Name { get; }
    public bool IsSimple { get; }
    public Argument(string name);
    public Argument(ArgumentType kind);
    public Argument(ArgumentType kind, string name);
    private static Argument();
    public ArgumentType get_Kind();
    public string get_Name();
    public virtual bool Equals(object obj);
    public sealed virtual bool Equals(Argument other);
    public static bool op_Equality(Argument left, Argument right);
    public static bool op_Inequality(Argument left, Argument right);
    public virtual int GetHashCode();
    public bool get_IsSimple();
    public virtual string ToString();
    internal Expression CreateExpression();
}
public enum Microsoft.Scripting.Actions.ArgumentType : Enum {
    public int value__;
    public static ArgumentType Simple;
    public static ArgumentType Named;
    public static ArgumentType List;
    public static ArgumentType Dictionary;
    public static ArgumentType Instance;
}
public class Microsoft.Scripting.Actions.BinderMappingInfo : object {
    public DynamicMetaObjectBinder Binder;
    public IList`1<ParameterMappingInfo> MappingInfo;
    public BinderMappingInfo(DynamicMetaObjectBinder binder, IList`1<ParameterMappingInfo> mappingInfo);
    public BinderMappingInfo(DynamicMetaObjectBinder binder, ParameterMappingInfo[] mappingInfos);
    public virtual string ToString();
}
public class Microsoft.Scripting.Actions.BoundMemberTracker : MemberTracker {
    [CompilerGeneratedAttribute]
private DynamicMetaObject <Instance>k__BackingField;
    [CompilerGeneratedAttribute]
private object <ObjectInstance>k__BackingField;
    [CompilerGeneratedAttribute]
private MemberTracker <BoundTo>k__BackingField;
    public TrackerTypes MemberType { get; }
    public Type DeclaringType { get; }
    public string Name { get; }
    public DynamicMetaObject Instance { get; }
    public object ObjectInstance { get; }
    public MemberTracker BoundTo { get; }
    public BoundMemberTracker(MemberTracker tracker, DynamicMetaObject instance);
    public BoundMemberTracker(MemberTracker tracker, object instance);
    public virtual TrackerTypes get_MemberType();
    public virtual Type get_DeclaringType();
    public virtual string get_Name();
    [CompilerGeneratedAttribute]
public DynamicMetaObject get_Instance();
    [CompilerGeneratedAttribute]
public object get_ObjectInstance();
    [CompilerGeneratedAttribute]
public MemberTracker get_BoundTo();
    public virtual DynamicMetaObject GetValue(OverloadResolverFactory resolverFactory, ActionBinder binder, Type instanceType);
    public virtual ErrorInfo GetError(ActionBinder binder, Type instanceType);
    public virtual DynamicMetaObject SetValue(OverloadResolverFactory resolverFactory, ActionBinder binder, Type instanceType, DynamicMetaObject value);
    public virtual DynamicMetaObject SetValue(OverloadResolverFactory resolverFactory, ActionBinder binder, Type instanceType, DynamicMetaObject value, DynamicMetaObject errorSuggestion);
}
[DefaultMemberAttribute("Item")]
public class Microsoft.Scripting.Actions.Calls.ActualArguments : object {
    [CompilerGeneratedAttribute]
private int <CollapsedCount>k__BackingField;
    [CompilerGeneratedAttribute]
private int <SplatIndex>k__BackingField;
    [CompilerGeneratedAttribute]
private int <FirstSplattedArg>k__BackingField;
    [CompilerGeneratedAttribute]
private IList`1<string> <ArgNames>k__BackingField;
    [CompilerGeneratedAttribute]
private IList`1<DynamicMetaObject> <NamedArguments>k__BackingField;
    [CompilerGeneratedAttribute]
private IList`1<DynamicMetaObject> <Arguments>k__BackingField;
    [CompilerGeneratedAttribute]
private int <HiddenCount>k__BackingField;
    public int CollapsedCount { get; }
    public int SplatIndex { get; }
    public int FirstSplattedArg { get; }
    public IList`1<string> ArgNames { get; }
    public IList`1<DynamicMetaObject> NamedArguments { get; }
    public IList`1<DynamicMetaObject> Arguments { get; }
    public int Count { get; }
    public int HiddenCount { get; }
    public int VisibleCount { get; }
    public DynamicMetaObject Item { get; }
    public ActualArguments(IList`1<DynamicMetaObject> args, IList`1<DynamicMetaObject> namedArgs, IList`1<string> argNames, int hiddenCount, int collapsedCount, int firstSplattedArg, int splatIndex);
    [CompilerGeneratedAttribute]
public int get_CollapsedCount();
    [CompilerGeneratedAttribute]
public int get_SplatIndex();
    [CompilerGeneratedAttribute]
public int get_FirstSplattedArg();
    [CompilerGeneratedAttribute]
public IList`1<string> get_ArgNames();
    [CompilerGeneratedAttribute]
public IList`1<DynamicMetaObject> get_NamedArguments();
    [CompilerGeneratedAttribute]
public IList`1<DynamicMetaObject> get_Arguments();
    internal int ToSplattedItemIndex(int collapsedArgIndex);
    public int get_Count();
    [CompilerGeneratedAttribute]
public int get_HiddenCount();
    public int get_VisibleCount();
    public DynamicMetaObject get_Item(int index);
    internal bool TryBindNamedArguments(MethodCandidate method, ArgumentBinding& binding, CallFailure& failure);
}
public class Microsoft.Scripting.Actions.Calls.ApplicableCandidate : object {
    public MethodCandidate Method;
    public ArgumentBinding ArgumentBinding;
    internal ApplicableCandidate(MethodCandidate method, ArgumentBinding argBinding);
    public ParameterWrapper GetParameter(int argumentIndex);
    public virtual string ToString();
}
public abstract class Microsoft.Scripting.Actions.Calls.ArgBuilder : object {
    internal static int AllArguments;
    [CompilerGeneratedAttribute]
private ParameterInfo <ParameterInfo>k__BackingField;
    public int Priority { get; }
    public ParameterInfo ParameterInfo { get; }
    public int ConsumedArgumentCount { get; }
    public Type Type { get; }
    internal Expression ByRefArgument { get; }
    protected ArgBuilder(ParameterInfo info);
    public abstract virtual int get_Priority();
    [CompilerGeneratedAttribute]
public ParameterInfo get_ParameterInfo();
    public abstract virtual int get_ConsumedArgumentCount();
    protected internal abstract virtual Expression ToExpression(OverloadResolver resolver, RestrictedArguments args, Boolean[] hasBeenUsed);
    public virtual Type get_Type();
    internal virtual Expression UpdateFromReturn(OverloadResolver resolver, RestrictedArguments args);
    internal virtual Expression ToReturnExpression(OverloadResolver resolver);
    internal virtual Expression get_ByRefArgument();
    public virtual ArgBuilder Clone(ParameterInfo newType);
}
public class Microsoft.Scripting.Actions.Calls.ArgumentBinding : ValueType {
    private static Int32[] _EmptyBinding;
    private int _positionalArgCount;
    private Int32[] _binding;
    public int PositionalArgCount { get; }
    internal ArgumentBinding(int positionalArgCount);
    internal ArgumentBinding(int positionalArgCount, Int32[] binding);
    private static ArgumentBinding();
    public int get_PositionalArgCount();
    public int ArgumentToParameter(int argumentIndex);
}
public enum Microsoft.Scripting.Actions.Calls.BindingResult : Enum {
    public int value__;
    public static BindingResult Success;
    public static BindingResult AmbiguousMatch;
    public static BindingResult IncorrectArgumentCount;
    public static BindingResult CallFailure;
    public static BindingResult InvalidArguments;
    public static BindingResult NoCallableMethod;
}
public class Microsoft.Scripting.Actions.Calls.BindingTarget : object {
    private CallFailure[] _callFailures;
    private MethodCandidate[] _ambiguousMatches;
    private Int32[] _expectedArgs;
    [CompilerGeneratedAttribute]
private BindingResult <Result>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    [CompilerGeneratedAttribute]
private MethodCandidate <MethodCandidate>k__BackingField;
    [CompilerGeneratedAttribute]
private int <ActualArgumentCount>k__BackingField;
    [CompilerGeneratedAttribute]
private RestrictedArguments <RestrictedArguments>k__BackingField;
    [CompilerGeneratedAttribute]
private NarrowingLevel <NarrowingLevel>k__BackingField;
    public BindingResult Result { get; }
    [ObsoleteAttribute("Use Overload instead")]
public MethodBase Method { get; }
    public OverloadInfo Overload { get; }
    public string Name { get; }
    public MethodCandidate MethodCandidate { get; }
    public IEnumerable`1<MethodCandidate> AmbiguousMatches { get; }
    public ICollection`1<CallFailure> CallFailures { get; }
    public IList`1<int> ExpectedArgumentCount { get; }
    public int ActualArgumentCount { get; }
    public RestrictedArguments RestrictedArguments { get; }
    public Type ReturnType { get; }
    public NarrowingLevel NarrowingLevel { get; }
    public bool Success { get; }
    internal BindingTarget(string name, int actualArgumentCount, MethodCandidate candidate, NarrowingLevel level, RestrictedArguments restrictedArgs);
    internal BindingTarget(string name, int actualArgumentCount, Int32[] expectedArgCount);
    internal BindingTarget(string name, int actualArgumentCount, CallFailure[] failures);
    internal BindingTarget(string name, int actualArgumentCount, MethodCandidate[] ambiguousMatches);
    internal BindingTarget(string name, BindingResult result);
    [CompilerGeneratedAttribute]
public BindingResult get_Result();
    public Expression MakeExpression();
    public MethodBase get_Method();
    public OverloadInfo get_Overload();
    [CompilerGeneratedAttribute]
public string get_Name();
    [CompilerGeneratedAttribute]
public MethodCandidate get_MethodCandidate();
    public IEnumerable`1<MethodCandidate> get_AmbiguousMatches();
    public ICollection`1<CallFailure> get_CallFailures();
    public IList`1<int> get_ExpectedArgumentCount();
    [CompilerGeneratedAttribute]
public int get_ActualArgumentCount();
    [CompilerGeneratedAttribute]
public RestrictedArguments get_RestrictedArguments();
    public Type get_ReturnType();
    [CompilerGeneratedAttribute]
public NarrowingLevel get_NarrowingLevel();
    public bool get_Success();
}
internal class Microsoft.Scripting.Actions.Calls.ByRefReturnBuilder : ReturnBuilder {
    private IList`1<int> _returnArgs;
    public int CountOutParams { get; }
    public ByRefReturnBuilder(IList`1<int> returnArgs);
    internal virtual Expression ToExpression(OverloadResolver resolver, IList`1<ArgBuilder> builders, RestrictedArguments args, Expression ret);
    public virtual int get_CountOutParams();
}
public class Microsoft.Scripting.Actions.Calls.CallFailure : object {
    private ConversionResult[] _results;
    private String[] _keywordArgs;
    private Int32[] _positionalArgs;
    [CompilerGeneratedAttribute]
private MethodCandidate <Candidate>k__BackingField;
    [CompilerGeneratedAttribute]
private CallFailureReason <Reason>k__BackingField;
    public MethodCandidate Candidate { get; }
    public CallFailureReason Reason { get; }
    public IList`1<ConversionResult> ConversionResults { get; }
    public IList`1<string> KeywordArguments { get; }
    public IList`1<int> PositionalArguments { get; }
    internal CallFailure(MethodCandidate candidate, ConversionResult[] results);
    internal CallFailure(MethodCandidate candidate, String[] keywordArgs);
    internal CallFailure(MethodCandidate candidate, String[] keywordArgs, Int32[] positionalArgs);
    internal CallFailure(MethodCandidate candidate, CallFailureReason reason);
    [CompilerGeneratedAttribute]
public MethodCandidate get_Candidate();
    [CompilerGeneratedAttribute]
public CallFailureReason get_Reason();
    public IList`1<ConversionResult> get_ConversionResults();
    public IList`1<string> get_KeywordArguments();
    public IList`1<int> get_PositionalArguments();
}
public enum Microsoft.Scripting.Actions.Calls.CallFailureReason : Enum {
    public int value__;
    public static CallFailureReason None;
    public static CallFailureReason ConversionFailure;
    public static CallFailureReason UnassignableKeyword;
    public static CallFailureReason DuplicateKeyword;
    public static CallFailureReason TypeInference;
}
public enum Microsoft.Scripting.Actions.Calls.Candidate : Enum {
    public int value__;
    public static Candidate Equivalent;
    public static Candidate One;
    public static Candidate Two;
    public static Candidate Ambiguous;
}
[ExtensionAttribute]
internal static class Microsoft.Scripting.Actions.Calls.CandidateExtension : object {
    [ExtensionAttribute]
public static bool Chosen(Candidate candidate);
    [ExtensionAttribute]
public static Candidate TheOther(Candidate candidate);
}
internal class Microsoft.Scripting.Actions.Calls.CandidateSet : object {
    private int _arity;
    private List`1<MethodCandidate> _candidates;
    internal List`1<MethodCandidate> Candidates { get; }
    internal int Arity { get; }
    internal CandidateSet(int count);
    internal List`1<MethodCandidate> get_Candidates();
    internal int get_Arity();
    internal bool IsParamsDictionaryOnly();
    internal void Add(MethodCandidate target);
    public virtual string ToString();
}
public class Microsoft.Scripting.Actions.Calls.ConversionResult : object {
    private object _arg;
    [CompilerGeneratedAttribute]
private Type <ArgType>k__BackingField;
    [CompilerGeneratedAttribute]
private Type <To>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <Failed>k__BackingField;
    public object Arg { get; }
    public Type ArgType { get; }
    public Type To { get; }
    public bool Failed { get; }
    internal ConversionResult(object arg, Type argType, Type toType, bool failed);
    public object get_Arg();
    [CompilerGeneratedAttribute]
public Type get_ArgType();
    [CompilerGeneratedAttribute]
public Type get_To();
    [CompilerGeneratedAttribute]
public bool get_Failed();
    internal static void ReplaceLastFailure(IList`1<ConversionResult> failures, bool isFailure);
    public string GetArgumentTypeName(ActionBinder binder);
}
internal class Microsoft.Scripting.Actions.Calls.DefaultArgBuilder : ArgBuilder {
    public int Priority { get; }
    public int ConsumedArgumentCount { get; }
    public DefaultArgBuilder(ParameterInfo info);
    public virtual int get_Priority();
    public virtual int get_ConsumedArgumentCount();
    protected internal virtual Expression ToExpression(OverloadResolver resolver, RestrictedArguments args, Boolean[] hasBeenUsed);
}
public interface Microsoft.Scripting.Actions.Calls.IInferableInvokable {
    public abstract virtual InferenceResult GetInferredType(Type delegateType, Type parameterType);
}
public class Microsoft.Scripting.Actions.Calls.InferenceResult : object {
    [CompilerGeneratedAttribute]
private Type <Type>k__BackingField;
    [CompilerGeneratedAttribute]
private BindingRestrictions <Restrictions>k__BackingField;
    public Type Type { get; }
    public BindingRestrictions Restrictions { get; }
    public InferenceResult(Type type, BindingRestrictions restrictions);
    [CompilerGeneratedAttribute]
public Type get_Type();
    [CompilerGeneratedAttribute]
public BindingRestrictions get_Restrictions();
}
public class Microsoft.Scripting.Actions.Calls.InstanceBuilder : object {
    private int _index;
    public bool HasValue { get; }
    public int ConsumedArgumentCount { get; }
    public InstanceBuilder(int index);
    public virtual bool get_HasValue();
    public virtual int get_ConsumedArgumentCount();
    protected internal virtual Expression ToExpression(MethodInfo& method, OverloadResolver resolver, RestrictedArguments args, Boolean[] hasBeenUsed);
    private void GetCallableMethod(RestrictedArguments args, MethodInfo& method);
}
internal class Microsoft.Scripting.Actions.Calls.KeywordArgBuilder : ArgBuilder {
    private int _kwArgCount;
    private int _kwArgIndex;
    private ArgBuilder _builder;
    public int Priority { get; }
    public int ConsumedArgumentCount { get; }
    public Type Type { get; }
    internal Expression ByRefArgument { get; }
    public KeywordArgBuilder(ArgBuilder builder, int kwArgCount, int kwArgIndex);
    public virtual int get_Priority();
    public virtual int get_ConsumedArgumentCount();
    internal static bool BuilderExpectsSingleParameter(ArgBuilder builder);
    protected internal virtual Expression ToExpression(OverloadResolver resolver, RestrictedArguments args, Boolean[] hasBeenUsed);
    public virtual Type get_Type();
    internal virtual Expression ToReturnExpression(OverloadResolver resolver);
    internal virtual Expression UpdateFromReturn(OverloadResolver resolver, RestrictedArguments args);
    private static RestrictedArguments MakeRestrictedArg(RestrictedArguments args, int index);
    private int GetKeywordIndex(int paramCount);
    internal virtual Expression get_ByRefArgument();
    public virtual ArgBuilder Clone(ParameterInfo newType);
}
internal class Microsoft.Scripting.Actions.Calls.KeywordConstructorReturnBuilder : ReturnBuilder {
    private ReturnBuilder _builder;
    private int _kwArgCount;
    private Int32[] _indexesUsed;
    private MemberInfo[] _membersSet;
    private bool _privateBinding;
    public KeywordConstructorReturnBuilder(ReturnBuilder builder, int kwArgCount, Int32[] indexesUsed, MemberInfo[] membersSet, bool privateBinding);
    internal virtual Expression ToExpression(OverloadResolver resolver, IList`1<ArgBuilder> builders, RestrictedArguments args, Expression ret);
    private static Expression ConvertToHelper(OverloadResolver resolver, Expression value, Type type);
}
public class Microsoft.Scripting.Actions.Calls.MethodCandidate : object {
    private List`1<ParameterWrapper> _parameters;
    private ParameterWrapper _paramsDict;
    private InstanceBuilder _instanceBuilder;
    [CompilerGeneratedAttribute]
private ReturnBuilder <ReturnBuilder>k__BackingField;
    [CompilerGeneratedAttribute]
private IList`1<ArgBuilder> <ArgBuilders>k__BackingField;
    [CompilerGeneratedAttribute]
private OverloadResolver <Resolver>k__BackingField;
    [CompilerGeneratedAttribute]
private OverloadInfo <Overload>k__BackingField;
    [CompilerGeneratedAttribute]
private Dictionary`2<DynamicMetaObject, BindingRestrictions> <Restrictions>k__BackingField;
    [CompilerGeneratedAttribute]
private int <ParamsArrayIndex>k__BackingField;
    internal ReturnBuilder ReturnBuilder { get; }
    internal IList`1<ArgBuilder> ArgBuilders { get; }
    public OverloadResolver Resolver { get; }
    [ObsoleteAttribute("Use Overload instead")]
public MethodBase Method { get; }
    public OverloadInfo Overload { get; }
    internal Dictionary`2<DynamicMetaObject, BindingRestrictions> Restrictions { get; }
    public Type ReturnType { get; }
    public int ParamsArrayIndex { get; }
    public bool HasParamsArray { get; }
    public bool HasParamsDictionary { get; }
    public ActionBinder Binder { get; }
    internal int ParameterCount { get; }
    internal MethodCandidate(OverloadResolver resolver, OverloadInfo method, List`1<ParameterWrapper> parameters, ParameterWrapper paramsDict, ReturnBuilder returnBuilder, InstanceBuilder instanceBuilder, IList`1<ArgBuilder> argBuilders, Dictionary`2<DynamicMetaObject, BindingRestrictions> restrictions);
    internal MethodCandidate ReplaceMethod(OverloadInfo newMethod, List`1<ParameterWrapper> parameters, IList`1<ArgBuilder> argBuilders, Dictionary`2<DynamicMetaObject, BindingRestrictions> restrictions);
    [CompilerGeneratedAttribute]
internal ReturnBuilder get_ReturnBuilder();
    [CompilerGeneratedAttribute]
internal IList`1<ArgBuilder> get_ArgBuilders();
    [CompilerGeneratedAttribute]
public OverloadResolver get_Resolver();
    public MethodBase get_Method();
    [CompilerGeneratedAttribute]
public OverloadInfo get_Overload();
    [CompilerGeneratedAttribute]
internal Dictionary`2<DynamicMetaObject, BindingRestrictions> get_Restrictions();
    public Type get_ReturnType();
    [CompilerGeneratedAttribute]
public int get_ParamsArrayIndex();
    public bool get_HasParamsArray();
    public bool get_HasParamsDictionary();
    public ActionBinder get_Binder();
    internal ParameterWrapper GetParameter(int argumentIndex, ArgumentBinding namesBinding);
    internal ParameterWrapper GetParameter(int parameterIndex);
    internal int get_ParameterCount();
    internal int IndexOfParameter(string name);
    internal int PositionOfParameter(string name);
    public int GetVisibleParameterCount();
    public IList`1<ParameterWrapper> GetParameters();
    internal MethodCandidate MakeParamsExtended(int count, IList`1<string> names);
    private MethodCandidate MakeParamsExtended(String[] names, Int32[] nameIndices, List`1<ParameterWrapper> parameters);
    private int GetConsumedArguments();
    public Type[] GetParameterTypes();
    internal Expression MakeExpression(RestrictedArguments restrictedArgs);
    private Expression[] GetArgumentExpressions(RestrictedArguments restrictedArgs, Boolean[]& usageMarkers, Expression[]& spilledArgs);
    private static Expression[] RemoveNulls(Expression[] args);
    public virtual string ToString();
}
public enum Microsoft.Scripting.Actions.Calls.NarrowingLevel : Enum {
    public int value__;
    public static NarrowingLevel None;
    public static NarrowingLevel One;
    public static NarrowingLevel Two;
    public static NarrowingLevel Three;
    public static NarrowingLevel All;
}
internal class Microsoft.Scripting.Actions.Calls.OutArgBuilder : ArgBuilder {
    private Type _parameterType;
    private bool _isRef;
    private ParameterExpression _tmp;
    public int ConsumedArgumentCount { get; }
    public int Priority { get; }
    internal Expression ByRefArgument { get; }
    public OutArgBuilder(ParameterInfo info);
    public virtual int get_ConsumedArgumentCount();
    public virtual int get_Priority();
    protected internal virtual Expression ToExpression(OverloadResolver resolver, RestrictedArguments args, Boolean[] hasBeenUsed);
    internal virtual Expression ToReturnExpression(OverloadResolver resolver);
    internal virtual Expression get_ByRefArgument();
    private Expression GetDefaultValue();
}
[DebuggerDisplayAttribute("{DebugString}")]
public abstract class Microsoft.Scripting.Actions.Calls.OverloadInfo : object {
    public string Name { get; }
    public IList`1<ParameterInfo> Parameters { get; }
    public int ParameterCount { get; }
    public ParameterInfo ReturnParameter { get; }
    public Type DeclaringType { get; }
    public Type ReturnType { get; }
    public MethodAttributes Attributes { get; }
    public bool IsConstructor { get; }
    public bool IsExtension { get; }
    public bool IsVariadic { get; }
    public bool IsGenericMethodDefinition { get; }
    public bool IsGenericMethod { get; }
    public bool ContainsGenericParameters { get; }
    public IList`1<Type> GenericArguments { get; }
    public CallingConventions CallingConvention { get; }
    public MethodBase ReflectionInfo { get; }
    private object DebugString { get; }
    public bool IsInstanceFactory { get; }
    public bool IsPrivate { get; }
    public bool IsPublic { get; }
    public bool IsAssembly { get; }
    public bool IsFamily { get; }
    public bool IsFamilyOrAssembly { get; }
    public bool IsFamilyAndAssembly { get; }
    public bool IsProtected { get; }
    public bool IsStatic { get; }
    public bool IsVirtual { get; }
    public bool IsSpecialName { get; }
    public bool IsFinal { get; }
    public abstract virtual string get_Name();
    public abstract virtual IList`1<ParameterInfo> get_Parameters();
    public virtual int get_ParameterCount();
    public abstract virtual ParameterInfo get_ReturnParameter();
    public virtual bool ProhibitsNull(int parameterIndex);
    public virtual bool ProhibitsNullItems(int parameterIndex);
    public virtual bool IsParamArray(int parameterIndex);
    public virtual bool IsParamDictionary(int parameterIndex);
    public abstract virtual Type get_DeclaringType();
    public abstract virtual Type get_ReturnType();
    public abstract virtual MethodAttributes get_Attributes();
    public abstract virtual bool get_IsConstructor();
    public abstract virtual bool get_IsExtension();
    public abstract virtual bool get_IsVariadic();
    public abstract virtual bool get_IsGenericMethodDefinition();
    public abstract virtual bool get_IsGenericMethod();
    public abstract virtual bool get_ContainsGenericParameters();
    public abstract virtual IList`1<Type> get_GenericArguments();
    public abstract virtual OverloadInfo MakeGenericMethod(Type[] genericArguments);
    public virtual CallingConventions get_CallingConvention();
    public virtual MethodBase get_ReflectionInfo();
    private object get_DebugString();
    public virtual bool get_IsInstanceFactory();
    public bool get_IsPrivate();
    public bool get_IsPublic();
    public bool get_IsAssembly();
    public bool get_IsFamily();
    public bool get_IsFamilyOrAssembly();
    public bool get_IsFamilyAndAssembly();
    public bool get_IsProtected();
    public bool get_IsStatic();
    public bool get_IsVirtual();
    public bool get_IsSpecialName();
    public bool get_IsFinal();
}
public abstract class Microsoft.Scripting.Actions.Calls.OverloadResolver : object {
    private string _methodName;
    private NarrowingLevel _minLevel;
    private NarrowingLevel _maxLevel;
    private IList`1<string> _argNames;
    private Dictionary`2<int, CandidateSet> _candidateSets;
    private List`1<MethodCandidate> _paramsCandidates;
    private ActualArguments _actualArguments;
    private int _maxAccessedCollapsedArg;
    private List`1<ParameterExpression> _temps;
    [CompilerGeneratedAttribute]
private ActionBinder <Binder>k__BackingField;
    public ActionBinder Binder { get; }
    internal List`1<ParameterExpression> Temps { get; }
    public int MaxAccessedCollapsedArg { get; }
    protected OverloadResolver(ActionBinder binder);
    [CompilerGeneratedAttribute]
public ActionBinder get_Binder();
    internal List`1<ParameterExpression> get_Temps();
    internal ParameterExpression GetTemporary(Type type, string name);
    public BindingTarget ResolveOverload(string methodName, IList`1<MethodBase> methods, NarrowingLevel minLevel, NarrowingLevel maxLevel);
    public BindingTarget ResolveOverload(string methodName, IList`1<OverloadInfo> methods, NarrowingLevel minLevel, NarrowingLevel maxLevel);
    protected internal virtual bool AllowMemberInitialization(OverloadInfo method);
    [ObsoleteAttribute("Use OverloadInfo.AllowMemberInitialization instead")]
protected internal virtual bool AllowKeywordArgumentSetting(MethodBase method);
    protected internal virtual Expression GetByRefArrayExpression(Expression argumentArrayExpression);
    protected virtual bool BindToUnexpandedParams(MethodCandidate candidate);
    protected internal virtual bool AllowByKeywordArgument(OverloadInfo method, ParameterInfo parameter);
    protected internal virtual BitArray MapSpecialParameters(ParameterMapping mapping);
    private void BuildCandidateSets(IEnumerable`1<OverloadInfo> methods);
    private CandidateSet GetCandidateSet();
    private CandidateSet BuildExpandedTargetSet(int count);
    private void AddTarget(MethodCandidate target);
    private void AddSimpleTarget(MethodCandidate target);
    private void AddBasicMethodTargets(OverloadInfo method);
    private static bool IsUnsupported(OverloadInfo method);
    public ActualArguments GetActualArguments();
    protected virtual void GetNamedArguments(IList`1& namedArgs, IList`1& argNames);
    protected abstract virtual ActualArguments CreateActualArguments(IList`1<DynamicMetaObject> namedArgs, IList`1<string> argNames, int preSplatLimit, int postSplatLimit);
    internal BindingTarget MakeBindingTarget(CandidateSet targetSet);
    private List`1<ApplicableCandidate> EnsureMatchingNamedArgs(List`1<MethodCandidate> candidates, List`1& failures);
    private List`1<ApplicableCandidate> SelectCandidatesWithConvertibleArgs(List`1<ApplicableCandidate> candidates, NarrowingLevel level, List`1& failures);
    private List`1<ApplicableCandidate> SelectCandidatesWithConvertibleCollapsedArgs(List`1<ApplicableCandidate> candidates, NarrowingLevel level, List`1& failures);
    private static void AddFailure(List`1& failures, CallFailure failure);
    private bool TryConvertArguments(MethodCandidate candidate, ArgumentBinding namesBinding, NarrowingLevel narrowingLevel, CallFailure& failure);
    private bool TryConvertCollapsedArguments(MethodCandidate candidate, NarrowingLevel narrowingLevel, CallFailure& failure);
    private RestrictedArguments GetRestrictedArgs(ApplicableCandidate selectedCandidate, IList`1<ApplicableCandidate> candidates, int targetSetSize);
    private DynamicMetaObject RestrictArgument(DynamicMetaObject arg, ParameterWrapper parameter);
    private static bool IsOverloadedOnParameter(int argIndex, int argCount, IList`1<ApplicableCandidate> overloads);
    private bool IsBest(ApplicableCandidate candidate, List`1<ApplicableCandidate> candidates, NarrowingLevel level);
    internal Candidate GetPreferredCandidate(ApplicableCandidate one, ApplicableCandidate two, NarrowingLevel level);
    protected internal virtual Candidate CompareEquivalentCandidates(ApplicableCandidate one, ApplicableCandidate two);
    internal Candidate CompareEquivalentParameters(MethodCandidate one, MethodCandidate two);
    private static int Compare(int x, int y);
    private static int FindMaxPriority(IList`1<ArgBuilder> abs, int ceiling);
    private Candidate GetPreferredParameters(ApplicableCandidate one, ApplicableCandidate two, NarrowingLevel level);
    private Candidate GetPreferredParameter(ParameterWrapper candidateOne, ParameterWrapper candidateTwo, DynamicMetaObject arg, NarrowingLevel level);
    private ApplicableCandidate SelectBestCandidate(List`1<ApplicableCandidate> candidates, NarrowingLevel level);
    private BindingTarget MakeSuccessfulBindingTarget(ApplicableCandidate result, List`1<ApplicableCandidate> potentialCandidates, NarrowingLevel level, CandidateSet targetSet);
    private BindingTarget MakeFailedBindingTarget(CallFailure[] failures);
    private BindingTarget MakeAmbiguousBindingTarget(List`1<ApplicableCandidate> result);
    public virtual bool ParametersEquivalent(ParameterWrapper parameter1, ParameterWrapper parameter2);
    public virtual bool CanConvertFrom(ParameterWrapper parameter1, ParameterWrapper parameter2);
    public virtual bool CanConvertFrom(Type fromType, DynamicMetaObject fromArgument, ParameterWrapper toParameter, NarrowingLevel level);
    public virtual Candidate SelectBestConversionFor(DynamicMetaObject arg, ParameterWrapper candidateOne, ParameterWrapper candidateTwo, NarrowingLevel level);
    public virtual Candidate PreferConvert(Type t1, Type t2);
    public virtual Expression Convert(DynamicMetaObject metaObject, Type restrictedType, ParameterInfo info, Type toType);
    public virtual Expression GetDynamicConversion(Expression value, Type type);
    private Int32[] GetExpectedArgCounts();
    public virtual ErrorInfo MakeInvalidParametersError(BindingTarget target);
    private static ErrorInfo MakeIncorrectArgumentCountError(BindingTarget target);
    private ErrorInfo MakeAmbiguousCallError(BindingTarget target);
    private ErrorInfo MakeCallFailureError(BindingTarget target);
    private ErrorInfo MakeInvalidArgumentsError();
    private ErrorInfo MakeNoCallableMethodError();
    private void GetSplatLimits(Int32& preSplatLimit, Int32& postSplatLimit);
    internal Expression GetSplattedItemExpression(Expression indexExpression);
    protected abstract virtual Expression GetSplattedExpression();
    protected abstract virtual object GetSplattedItem(int index);
    internal object GetCollapsedArgumentValue(int collapsedArgIndex);
    public int get_MaxAccessedCollapsedArg();
    internal Type[] GetAccessedCollapsedArgTypes();
    public Expression GetCollapsedArgsCondition();
    public virtual Type GetGenericInferenceType(DynamicMetaObject dynamicObject);
    public virtual string ToString();
}
public abstract class Microsoft.Scripting.Actions.Calls.OverloadResolverFactory : object {
    public abstract virtual DefaultOverloadResolver CreateOverloadResolver(IList`1<DynamicMetaObject> args, CallSignature signature, CallTypes callType);
}
[FlagsAttribute]
public enum Microsoft.Scripting.Actions.Calls.ParameterBindingFlags : Enum {
    public int value__;
    public static ParameterBindingFlags None;
    public static ParameterBindingFlags ProhibitNull;
    public static ParameterBindingFlags ProhibitNullItems;
    public static ParameterBindingFlags IsParamArray;
    public static ParameterBindingFlags IsParamDictionary;
    public static ParameterBindingFlags IsHidden;
}
public class Microsoft.Scripting.Actions.Calls.ParameterMapping : object {
    private OverloadResolver _resolver;
    private IList`1<string> _argNames;
    private List`1<ParameterWrapper> _parameters;
    private List`1<ArgBuilder> _arguments;
    private List`1<int> _returnArgs;
    private InstanceBuilder _instanceBuilder;
    private ReturnBuilder _returnBuilder;
    private List`1<ArgBuilder> _defaultArguments;
    private bool _hasByRef;
    private bool _hasDefaults;
    private ParameterWrapper _paramsDict;
    [CompilerGeneratedAttribute]
private OverloadInfo <Overload>k__BackingField;
    [CompilerGeneratedAttribute]
private int <ArgIndex>k__BackingField;
    public OverloadInfo Overload { get; }
    public int ArgIndex { get; private set; }
    [ObsoleteAttribute("Use Overload.ReflectionInfo instead")]
public MethodBase Method { get; }
    [ObsoleteAttribute("Use Overload.Parameters instead")]
public ParameterInfo[] ParameterInfos { get; }
    internal ParameterMapping(OverloadResolver resolver, OverloadInfo method, IList`1<string> argNames);
    [CompilerGeneratedAttribute]
public OverloadInfo get_Overload();
    [CompilerGeneratedAttribute]
public int get_ArgIndex();
    [CompilerGeneratedAttribute]
private void set_ArgIndex(int value);
    public MethodBase get_Method();
    public ParameterInfo[] get_ParameterInfos();
    internal void MapParameters(bool reduceByRef);
    private bool IsSpecialParameter(BitArray specialParameters, int infoIndex);
    public void AddInstanceBuilder(InstanceBuilder builder);
    public void AddBuilder(ArgBuilder builder);
    public void AddParameter(ParameterWrapper parameter);
    public void MapParameter(ParameterInfo pi);
    private void MapParameterReduceByRef(ParameterInfo pi);
    private ParameterWrapper CreateParameterWrapper(ParameterInfo info);
    private SimpleArgBuilder AddSimpleParameterMapping(ParameterInfo info, int index);
    internal MethodCandidate CreateCandidate();
    internal MethodCandidate CreateByRefReducedCandidate();
    [IteratorStateMachineAttribute("Microsoft.Scripting.Actions.Calls.ParameterMapping/<CreateDefaultCandidates>d__34")]
internal IEnumerable`1<MethodCandidate> CreateDefaultCandidates();
    private MethodCandidate CreateDefaultCandidate(int defaultsUsed);
    private ReturnBuilder MakeReturnBuilder(BitArray specialParameters);
    private static List`1<MemberInfo> GetBindableMembers(Type returnType, List`1<string> unusedNames);
    private List`1<string> GetUnusedArgNames(BitArray specialParameters);
}
public class Microsoft.Scripting.Actions.Calls.ParameterWrapper : object {
    private ParameterBindingFlags _flags;
    [CompilerGeneratedAttribute]
private Type <Type>k__BackingField;
    [CompilerGeneratedAttribute]
private ParameterInfo <ParameterInfo>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    public Type Type { get; }
    public ParameterInfo ParameterInfo { get; }
    public string Name { get; }
    public ParameterBindingFlags Flags { get; }
    public bool ProhibitNull { get; }
    public bool ProhibitNullItems { get; }
    public bool IsHidden { get; }
    public bool IsByRef { get; }
    public bool IsParamsArray { get; }
    public bool IsParamsDict { get; }
    [ObsoleteAttribute("Use ParameterBindingAttributes overload")]
public ParameterWrapper(Type type, string name, bool prohibitNull);
    [ObsoleteAttribute("Use ParameterBindingAttributes overload")]
public ParameterWrapper(ParameterInfo info, Type type, string name, bool prohibitNull, bool isParams, bool isParamsDict, bool isHidden);
    public ParameterWrapper(ParameterInfo info, Type type, string name, ParameterBindingFlags flags);
    public ParameterWrapper Clone(string name);
    [CompilerGeneratedAttribute]
public Type get_Type();
    [CompilerGeneratedAttribute]
public ParameterInfo get_ParameterInfo();
    [CompilerGeneratedAttribute]
public string get_Name();
    public ParameterBindingFlags get_Flags();
    public bool get_ProhibitNull();
    public bool get_ProhibitNullItems();
    public bool get_IsHidden();
    public bool get_IsByRef();
    public bool get_IsParamsArray();
    public bool get_IsParamsDict();
    internal static int IndexOfParamsArray(IList`1<ParameterWrapper> parameters);
    internal ParameterWrapper Expand();
}
internal class Microsoft.Scripting.Actions.Calls.ParamsArgBuilder : ArgBuilder {
    private int _start;
    private int _expandedCount;
    private Type _elementType;
    public int ConsumedArgumentCount { get; }
    public int Priority { get; }
    public Type Type { get; }
    internal ParamsArgBuilder(ParameterInfo info, Type elementType, int start, int expandedCount);
    public virtual int get_ConsumedArgumentCount();
    public virtual int get_Priority();
    protected internal virtual Expression ToExpression(OverloadResolver resolver, RestrictedArguments args, Boolean[] hasBeenUsed);
    public virtual Type get_Type();
    public virtual ArgBuilder Clone(ParameterInfo newType);
}
internal class Microsoft.Scripting.Actions.Calls.ParamsDictArgBuilder : ArgBuilder {
    private String[] _names;
    private Int32[] _nameIndexes;
    private int _argIndex;
    public int ConsumedArgumentCount { get; }
    public int Priority { get; }
    public Type Type { get; }
    public ParamsDictArgBuilder(ParameterInfo info, int argIndex, String[] names, Int32[] nameIndexes);
    public virtual int get_ConsumedArgumentCount();
    public virtual int get_Priority();
    protected internal virtual Expression ToExpression(OverloadResolver resolver, RestrictedArguments args, Boolean[] hasBeenUsed);
    private static InvalidOperationException BadDictionaryType(Type dictType);
    public virtual Type get_Type();
    private List`1<Expression> GetParameters(RestrictedArguments args, Boolean[] hasBeenUsed);
    private Int32[] GetParameters(Boolean[] hasBeenUsed);
    private Expression[] ConstantNames();
    private Func`3<String[], Object[], object> GetCreationDelegate(Type dictType);
}
internal class Microsoft.Scripting.Actions.Calls.ReferenceArgBuilder : SimpleArgBuilder {
    private Type _elementType;
    private ParameterExpression _tmp;
    public int Priority { get; }
    internal Expression ByRefArgument { get; }
    public ReferenceArgBuilder(ParameterInfo info, Type elementType, Type strongBox, int index);
    protected virtual SimpleArgBuilder Copy(int newIndex);
    public virtual ArgBuilder Clone(ParameterInfo newType);
    public virtual int get_Priority();
    protected internal virtual Expression ToExpression(OverloadResolver resolver, RestrictedArguments args, Boolean[] hasBeenUsed);
    internal virtual Expression UpdateFromReturn(OverloadResolver resolver, RestrictedArguments args);
    internal virtual Expression get_ByRefArgument();
}
public class Microsoft.Scripting.Actions.Calls.ReflectionOverloadInfo : OverloadInfo {
    private MethodBase _method;
    private ReadOnlyCollection`1<ParameterInfo> _parameters;
    private ReadOnlyCollection`1<Type> _genericArguments;
    private _Flags _flags;
    public MethodBase ReflectionInfo { get; }
    public string Name { get; }
    public IList`1<ParameterInfo> Parameters { get; }
    public ParameterInfo ReturnParameter { get; }
    public IList`1<Type> GenericArguments { get; }
    public Type DeclaringType { get; }
    public Type ReturnType { get; }
    public CallingConventions CallingConvention { get; }
    public MethodAttributes Attributes { get; }
    public bool IsInstanceFactory { get; }
    public bool IsConstructor { get; }
    public bool IsExtension { get; }
    public bool IsVariadic { get; }
    public bool IsGenericMethod { get; }
    public bool IsGenericMethodDefinition { get; }
    public bool ContainsGenericParameters { get; }
    public ReflectionOverloadInfo(MethodBase method);
    public virtual MethodBase get_ReflectionInfo();
    public virtual string get_Name();
    public virtual IList`1<ParameterInfo> get_Parameters();
    public virtual ParameterInfo get_ReturnParameter();
    public virtual IList`1<Type> get_GenericArguments();
    public virtual Type get_DeclaringType();
    public virtual Type get_ReturnType();
    public virtual CallingConventions get_CallingConvention();
    public virtual MethodAttributes get_Attributes();
    public virtual bool get_IsInstanceFactory();
    public virtual bool get_IsConstructor();
    public virtual bool get_IsExtension();
    public virtual bool get_IsVariadic();
    private bool IsVariadicInternal();
    public virtual bool get_IsGenericMethod();
    public virtual bool get_IsGenericMethodDefinition();
    public virtual bool get_ContainsGenericParameters();
    public virtual OverloadInfo MakeGenericMethod(Type[] genericArguments);
    public static OverloadInfo[] CreateArray(MethodBase[] methods);
}
public class Microsoft.Scripting.Actions.Calls.RestrictedArguments : object {
    private DynamicMetaObject[] _objects;
    private Type[] _types;
    [CompilerGeneratedAttribute]
private bool <HasUntypedRestrictions>k__BackingField;
    public int Length { get; }
    public bool HasUntypedRestrictions { get; }
    public RestrictedArguments(DynamicMetaObject[] objects, Type[] types, bool hasUntypedRestrictions);
    public int get_Length();
    public DynamicMetaObject GetObject(int i);
    public Type GetType(int i);
    [CompilerGeneratedAttribute]
public bool get_HasUntypedRestrictions();
    public BindingRestrictions GetAllRestrictions();
    public IList`1<DynamicMetaObject> GetObjects();
    public IList`1<Type> GetTypes();
}
internal class Microsoft.Scripting.Actions.Calls.ReturnBuilder : object {
    [CompilerGeneratedAttribute]
private Type <ReturnType>k__BackingField;
    public int CountOutParams { get; }
    public Type ReturnType { get; }
    public ReturnBuilder(Type returnType);
    internal virtual Expression ToExpression(OverloadResolver resolver, IList`1<ArgBuilder> builders, RestrictedArguments args, Expression ret);
    public virtual int get_CountOutParams();
    [CompilerGeneratedAttribute]
public Type get_ReturnType();
}
internal class Microsoft.Scripting.Actions.Calls.ReturnReferenceArgBuilder : SimpleArgBuilder {
    private ParameterExpression _tmp;
    internal Expression ByRefArgument { get; }
    public int Priority { get; }
    public ReturnReferenceArgBuilder(ParameterInfo info, int index);
    protected virtual SimpleArgBuilder Copy(int newIndex);
    public virtual ArgBuilder Clone(ParameterInfo newType);
    protected internal virtual Expression ToExpression(OverloadResolver resolver, RestrictedArguments args, Boolean[] hasBeenUsed);
    internal virtual Expression ToReturnExpression(OverloadResolver resolver);
    internal virtual Expression get_ByRefArgument();
    public virtual int get_Priority();
}
public class Microsoft.Scripting.Actions.Calls.SimpleArgBuilder : ArgBuilder {
    private Type _parameterType;
    [CompilerGeneratedAttribute]
private bool <IsParamsArray>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsParamsDict>k__BackingField;
    [CompilerGeneratedAttribute]
private int <Index>k__BackingField;
    public int ConsumedArgumentCount { get; }
    public int Priority { get; }
    public bool IsParamsArray { get; }
    public bool IsParamsDict { get; }
    public int Index { get; }
    public Type Type { get; }
    public SimpleArgBuilder(Type parameterType, int index, bool isParams, bool isParamsDict);
    [ObsoleteAttribute("Use other overload")]
public SimpleArgBuilder(ParameterInfo info, int index);
    public SimpleArgBuilder(ParameterInfo info, Type parameterType, int index, bool isParams, bool isParamsDict);
    internal SimpleArgBuilder MakeCopy(int newIndex);
    protected virtual SimpleArgBuilder Copy(int newIndex);
    public virtual int get_ConsumedArgumentCount();
    public virtual int get_Priority();
    [CompilerGeneratedAttribute]
public bool get_IsParamsArray();
    [CompilerGeneratedAttribute]
public bool get_IsParamsDict();
    protected internal virtual Expression ToExpression(OverloadResolver resolver, RestrictedArguments args, Boolean[] hasBeenUsed);
    [CompilerGeneratedAttribute]
public int get_Index();
    public virtual Type get_Type();
    public virtual ArgBuilder Clone(ParameterInfo newType);
}
public static class Microsoft.Scripting.Actions.Calls.TypeInferer : object {
    private static ArgumentInputs EnsureInputs(Dictionary`2<Type, ArgumentInputs> dict, Type type);
    internal static MethodCandidate InferGenericMethod(ApplicableCandidate candidate, ActualArguments actualArgs);
    private static Type[] GetGenericArgumentsForInferedMethod(OverloadInfo target, Dictionary`2<Type, Type> constraints);
    private static List`1<ArgBuilder> CreateNewArgBuilders(MethodCandidate candidate, OverloadInfo newOverload);
    private static List`1<ParameterWrapper> CreateNewWrappers(MethodCandidate candidate, OverloadInfo newOverload, OverloadInfo oldOverload);
    private static List`1<DynamicMetaObject> GetAllArguments(ApplicableCandidate candidate, ActualArguments actualArgs);
    private static Type[] GetSortedGenericArguments(OverloadInfo info, Dictionary`2<Type, List`1<Type>> dependencies);
    private static bool IsDependentConstraint(Dictionary`2<Type, List`1<Type>> dependencies, Type x, Type y);
    private static Dictionary`2<Type, List`1<Type>> GetDependencyMapping(OverloadInfo info);
    private static void AddNestedDependencies(Dictionary`2<Type, List`1<Type>> dependencies, Type genArg, Type t);
    private static void AddDependency(Dictionary`2<Type, List`1<Type>> dependencies, Type genArg, Type t);
    private static Dictionary`2<Type, ArgumentInputs> GetArgumentToInputMapping(MethodCandidate candidate, IList`1<DynamicMetaObject> args);
    private static void AddOneInput(Dictionary`2<Type, ArgumentInputs> inputs, DynamicMetaObject arg, Type paramType);
    private static void CollectGenericParameters(Type type, List`1<Type> containedGenArgs);
    internal static Type GetInferedType(OverloadResolver resolver, Type genericParameter, Type parameterType, DynamicMetaObject input, Dictionary`2<Type, Type> binding, Dictionary`2<DynamicMetaObject, BindingRestrictions> restrictions);
    public static Type GetInferedType(Type genericParameter, Type parameterType, Type inputType, Type argType, Dictionary`2<Type, Type> binding);
    private static Type GetInferedTypeForInterface(Type genericParameter, Type interfaceType, Type inputType, Dictionary`2<Type, Type> binding);
    private static bool ConstraintsViolated(Type inputType, Type genericMethodParameterType, Dictionary`2<Type, Type> binding);
    private static Type MatchGenericParameter(Type genericParameter, Type closedType, Type openType, Dictionary`2<Type, Type> binding);
    private static bool MatchGenericParameter(Type genericParameter, Type closedType, Type openType, Dictionary`2<Type, Type> binding, Type& match);
}
public class Microsoft.Scripting.Actions.CallSignature : ValueType {
    private Argument[] _infos;
    private int _argumentCount;
    public bool IsSimple { get; }
    public int ArgumentCount { get; }
    public CallSignature(CallSignature signature);
    public CallSignature(int argumentCount);
    public CallSignature(Argument[] infos);
    public CallSignature(ArgumentType[] kinds);
    public bool get_IsSimple();
    public int get_ArgumentCount();
    public sealed virtual bool Equals(CallSignature other);
    public virtual bool Equals(object obj);
    public static bool op_Equality(CallSignature left, CallSignature right);
    public static bool op_Inequality(CallSignature left, CallSignature right);
    public virtual string ToString();
    public virtual int GetHashCode();
    public Argument[] GetArgumentInfos();
    public CallSignature InsertArgument(Argument info);
    public CallSignature InsertArgumentAt(int index, Argument info);
    public CallSignature RemoveFirstArgument();
    public CallSignature RemoveArgumentAt(int index);
    public int IndexOf(ArgumentType kind);
    public bool HasDictionaryArgument();
    public bool HasInstanceArgument();
    public bool HasListArgument();
    internal bool HasNamedArgument();
    public bool HasKeywordArgument();
    public ArgumentType GetArgumentKind(int index);
    public string GetArgumentName(int index);
    public int GetProvidedPositionalArgumentCount();
    public String[] GetArgumentNames();
    public Expression CreateExpression();
}
public class Microsoft.Scripting.Actions.ComboActionRewriter : DynamicExpressionVisitor {
    protected virtual Expression VisitDynamic(DynamicExpression node);
    private bool IsSideEffectFree(Expression rewritten);
}
public class Microsoft.Scripting.Actions.ComboBinder : DynamicMetaObjectBinder {
    private BinderMappingInfo[] _metaBinders;
    public Type ReturnType { get; }
    public ComboBinder(BinderMappingInfo[] binders);
    public ComboBinder(ICollection`1<BinderMappingInfo> binders);
    public virtual DynamicMetaObject Bind(DynamicMetaObject target, DynamicMetaObject[] args);
    public virtual Type get_ReturnType();
    private DynamicMetaObject[] GetArguments(DynamicMetaObject[] args, IList`1<DynamicMetaObject> results, int metaBinderIndex);
    public virtual int GetHashCode();
    public virtual bool Equals(object obj);
}
internal class Microsoft.Scripting.Actions.ConditionalBuilder : object {
    private List`1<Expression> _conditions;
    private List`1<Expression> _bodies;
    private List`1<ParameterExpression> _variables;
    private Expression _body;
    private bool _isError;
    private BindingRestrictions _restrictions;
    public BindingRestrictions Restrictions { get; public set; }
    public void AddCondition(Expression condition, Expression body);
    public void FinishCondition(DynamicMetaObject body);
    public void FinishCondition(Expression body);
    public void FinishError(DynamicMetaObject body);
    public void FinishError(Expression body);
    public BindingRestrictions get_Restrictions();
    public void set_Restrictions(BindingRestrictions value);
    public DynamicMetaObject GetMetaObject(DynamicMetaObject[] types);
    public void AddVariable(ParameterExpression var);
}
public class Microsoft.Scripting.Actions.ConstructorTracker : MemberTracker {
    private ConstructorInfo _ctor;
    public Type DeclaringType { get; }
    public TrackerTypes MemberType { get; }
    public string Name { get; }
    public bool IsPublic { get; }
    public ConstructorTracker(ConstructorInfo ctor);
    public virtual Type get_DeclaringType();
    public virtual TrackerTypes get_MemberType();
    public virtual string get_Name();
    public bool get_IsPublic();
    public virtual string ToString();
}
public enum Microsoft.Scripting.Actions.ConversionResultKind : Enum {
    public int value__;
    public static ConversionResultKind ImplicitCast;
    public static ConversionResultKind ExplicitCast;
    public static ConversionResultKind ImplicitTry;
    public static ConversionResultKind ExplicitTry;
}
public abstract class Microsoft.Scripting.Actions.CustomTracker : MemberTracker {
    public TrackerTypes MemberType { get; }
    public sealed virtual TrackerTypes get_MemberType();
}
public class Microsoft.Scripting.Actions.DefaultBinder : ActionBinder {
    internal static DefaultBinder Instance;
    private static DefaultBinder();
    public DynamicMetaObject ConvertTo(Type toType, ConversionResultKind kind, DynamicMetaObject arg);
    public DynamicMetaObject ConvertTo(Type toType, ConversionResultKind kind, DynamicMetaObject arg, OverloadResolverFactory resolverFactory);
    public DynamicMetaObject ConvertTo(Type toType, ConversionResultKind kind, DynamicMetaObject arg, OverloadResolverFactory resolverFactory, DynamicMetaObject errorSuggestion);
    private static DynamicMetaObject TryConvertToObject(Type toType, Type knownType, DynamicMetaObject arg, BindingRestrictions restrictions);
    private DynamicMetaObject TryAllConversions(OverloadResolverFactory factory, Type toType, ConversionResultKind kind, Type knownType, BindingRestrictions restrictions, DynamicMetaObject arg);
    private static DynamicMetaObject TryAssignableConversion(Type toType, Type type, BindingRestrictions restrictions, DynamicMetaObject arg);
    private DynamicMetaObject TryUserDefinedConversion(ConversionResultKind kind, Type toType, Type type, BindingRestrictions restrictions, DynamicMetaObject arg);
    private DynamicMetaObject TryOneConversion(ConversionResultKind kind, Type toType, Type type, Type fromType, string methodName, bool isImplicit, BindingRestrictions restrictions, DynamicMetaObject arg);
    private static DynamicMetaObject TryUserDefinedConversion(ConversionResultKind kind, Type toType, Type type, MemberGroup conversions, bool isImplicit, BindingRestrictions restrictions, DynamicMetaObject arg);
    private static DynamicMetaObject TryExtensibleConversion(Type toType, Type type, BindingRestrictions restrictions, DynamicMetaObject arg);
    private static DynamicMetaObject TryImplicitNumericConversion(Type toType, Type type, BindingRestrictions restrictions, DynamicMetaObject arg);
    private DynamicMetaObject TryNullableConversion(OverloadResolverFactory factory, Type toType, ConversionResultKind kind, Type knownType, BindingRestrictions restrictions, DynamicMetaObject arg);
    private static DynamicMetaObject TryNullConversion(Type toType, Type knownType, BindingRestrictions restrictions);
    private DynamicMetaObject MakeErrorTarget(Type toType, ConversionResultKind kind, BindingRestrictions restrictions, DynamicMetaObject arg);
    private static DynamicMetaObject MakeBoxingTarget(DynamicMetaObject arg, BindingRestrictions restrictions);
    private static DynamicMetaObject MakeConversionTarget(ConversionResultKind kind, MethodTracker method, Type fromType, bool isImplicit, BindingRestrictions restrictions, DynamicMetaObject arg);
    private static DynamicMetaObject MakeExtensibleConversionTarget(ConversionResultKind kind, MethodTracker method, Type fromType, bool isImplicit, BindingRestrictions restrictions, DynamicMetaObject arg);
    private static DynamicMetaObject MakeConversionTargetWorker(ConversionResultKind kind, MethodTracker method, bool isImplicit, BindingRestrictions restrictions, Expression param);
    private static Expression WrapForThrowingTry(ConversionResultKind kind, bool isImplicit, Expression ret, Type retType);
    private static DynamicMetaObject MakeSimpleConversionTarget(Type toType, BindingRestrictions restrictions, DynamicMetaObject arg);
    private static DynamicMetaObject MakeSimpleExtensibleConversionTarget(Type toType, BindingRestrictions restrictions, DynamicMetaObject arg);
    private static DynamicMetaObject MakeExtensibleTarget(Type extensibleType, BindingRestrictions restrictions, DynamicMetaObject arg);
    private static DynamicMetaObject MakeNullToNullableOfTTarget(Type toType, BindingRestrictions restrictions);
    private static DynamicMetaObject MakeTToNullableOfTTarget(Type toType, Type knownType, BindingRestrictions restrictions, DynamicMetaObject arg);
    private DynamicMetaObject MakeConvertingToTToNullableOfTTarget(OverloadResolverFactory resolverFactory, Type toType, ConversionResultKind kind, BindingRestrictions restrictions, DynamicMetaObject arg);
    public static Expression GetTryConvertReturnValue(Type type);
    private static Expression GetExtensibleValue(Type extType, DynamicMetaObject arg);
    private static Type GetUnderlyingType(Type fromType);
    private static DynamicMetaObject MakeNullTarget(Type toType, BindingRestrictions restrictions);
    public virtual bool CanConvertFrom(Type fromType, Type toType, bool toNotNullable, NarrowingLevel level);
    public virtual Candidate PreferConvert(Type t1, Type t2);
    public virtual ErrorInfo MakeUndeletableMemberError(Type type, string name);
    public virtual ErrorInfo MakeNonPublicMemberGetError(OverloadResolverFactory resolverFactory, MemberTracker member, Type type, DynamicMetaObject instance);
    public virtual ErrorInfo MakeReadOnlyMemberError(Type type, string name);
    public virtual ErrorInfo MakeEventValidation(MemberGroup members, DynamicMetaObject eventObject, DynamicMetaObject value, OverloadResolverFactory resolverFactory);
    public static DynamicMetaObject MakeError(ErrorInfo error, Type type);
    public static DynamicMetaObject MakeError(ErrorInfo error, BindingRestrictions restrictions, Type type);
    private static Expression MakeAmbiguousMatchError(MemberGroup members);
    public TrackerTypes GetMemberType(MemberGroup members, Expression& error);
    public MethodInfo GetMethod(Type type, string name);
    private static MethodInfo GetSpecialNameMethod(Type type, string name);
    private static Exception AmbiguousMatch(Type type, string name);
    public DynamicMetaObject DeleteMember(string name, DynamicMetaObject target);
    public DynamicMetaObject DeleteMember(string name, DynamicMetaObject target, OverloadResolverFactory resolutionFactory);
    public DynamicMetaObject DeleteMember(string name, DynamicMetaObject target, OverloadResolverFactory resolutionFactory, DynamicMetaObject errorSuggestion);
    private DynamicMetaObject MakeDeleteMemberTarget(SetOrDeleteMemberInfo delInfo, DynamicMetaObject target, DynamicMetaObject errorSuggestion);
    private static Type GetDeclaringMemberType(MemberGroup group);
    private void MakePropertyDeleteStatement(SetOrDeleteMemberInfo delInfo, DynamicMetaObject instance, MethodInfo delete);
    private bool MakeOperatorDeleteMemberBody(SetOrDeleteMemberInfo delInfo, DynamicMetaObject instance, Type type, string name);
    public DynamicMetaObject GetMember(string name, DynamicMetaObject target);
    public DynamicMetaObject GetMember(string name, DynamicMetaObject target, OverloadResolverFactory resolverFactory);
    public DynamicMetaObject GetMember(string name, DynamicMetaObject target, OverloadResolverFactory resolverFactory, bool isNoThrow, DynamicMetaObject errorSuggestion);
    public DynamicMetaObject GetMember(string name, DynamicMetaObject target, bool isNoThrow, DynamicMetaObject errorSuggestion);
    private DynamicMetaObject MakeGetMemberTarget(GetMemberInfo getMemInfo, DynamicMetaObject target);
    private static Type EnsureTrackerRepresentsNonGenericType(TypeTracker tracker);
    private void MakeBodyHelper(GetMemberInfo getMemInfo, DynamicMetaObject self, DynamicMetaObject propSelf, Type targetType, MemberGroup members);
    private void MakeSuccessfulMemberAccess(GetMemberInfo getMemInfo, DynamicMetaObject self, DynamicMetaObject propSelf, Type selfType, MemberGroup members, TrackerTypes memberType);
    private void MakeGenericBody(GetMemberInfo getMemInfo, Type instanceType, MemberGroup members, DynamicMetaObject instance);
    private static bool IsTrackerApplicableForType(Type type, MemberTracker mt);
    private void MakeTypeBody(GetMemberInfo getMemInfo, Type instanceType, MemberGroup members);
    private void MakeGenericBodyWorker(GetMemberInfo getMemInfo, Type instanceType, MemberTracker tracker, DynamicMetaObject instance);
    private void MakeOperatorGetMemberBody(GetMemberInfo getMemInfo, DynamicMetaObject instance, Type instanceType, string name);
    private void MakeMissingMemberRuleForGet(GetMemberInfo getMemInfo, DynamicMetaObject self, Type type);
    private static MemberExpression MakeOperationFailed();
    public DynamicMetaObject Call(CallSignature signature, DynamicMetaObject target, DynamicMetaObject[] args);
    public DynamicMetaObject Call(CallSignature signature, OverloadResolverFactory resolverFactory, DynamicMetaObject target, DynamicMetaObject[] args);
    public DynamicMetaObject Call(CallSignature signature, DynamicMetaObject errorSuggestion, OverloadResolverFactory resolverFactory, DynamicMetaObject target, DynamicMetaObject[] args);
    private DynamicMetaObject MakeMetaMethodCall(CallSignature signature, OverloadResolverFactory resolverFactory, TargetInfo targetInfo);
    private TargetInfo GetTargetInfo(DynamicMetaObject target, DynamicMetaObject[] args);
    private static TargetInfo TryGetMethodGroupTargets(DynamicMetaObject target, DynamicMetaObject[] args, MethodGroup mthgrp);
    private static TargetInfo TryGetMemberGroupTargets(DynamicMetaObject target, DynamicMetaObject[] args, MemberGroup mg);
    private TargetInfo TryGetBoundMemberTargets(DynamicMetaObject self, DynamicMetaObject[] args, BoundMemberTracker bmt);
    private static TargetInfo TryGetDelegateTargets(DynamicMetaObject target, DynamicMetaObject[] args, Delegate d);
    private TargetInfo TryGetOperatorTargets(DynamicMetaObject self, DynamicMetaObject[] args, object target);
    private DynamicMetaObject MakeCannotCallRule(DynamicMetaObject self, Type type);
    public DynamicMetaObject CallMethod(DefaultOverloadResolver resolver, IList`1<MethodBase> targets);
    public DynamicMetaObject CallMethod(DefaultOverloadResolver resolver, IList`1<MethodBase> targets, string name);
    public DynamicMetaObject CallMethod(DefaultOverloadResolver resolver, IList`1<MethodBase> targets, BindingRestrictions restrictions);
    public DynamicMetaObject CallMethod(DefaultOverloadResolver resolver, IList`1<MethodBase> targets, BindingRestrictions restrictions, string name);
    public DynamicMetaObject CallMethod(DefaultOverloadResolver resolver, IList`1<MethodBase> targets, BindingRestrictions restrictions, string name, NarrowingLevel minLevel, NarrowingLevel maxLevel, BindingTarget& target);
    internal static string GetTargetName(IList`1<MethodBase> targets);
    private DynamicMetaObject MakeInvalidParametersRule(DefaultOverloadResolver binder, BindingRestrictions restrictions, BindingTarget bt);
    private static BindingRestrictions MakeSplatTests(CallTypes callType, CallSignature signature, IList`1<DynamicMetaObject> args);
    private static BindingRestrictions MakeSplatTests(CallTypes callType, CallSignature signature, bool testTypes, IList`1<DynamicMetaObject> args);
    private static BindingRestrictions MakeParamsArrayTest(CallTypes callType, CallSignature signature, bool testTypes, IList`1<DynamicMetaObject> args);
    private static BindingRestrictions MakeParamsTest(DynamicMetaObject splattee, bool testTypes);
    private static BindingRestrictions MakeParamsDictionaryTest(IList`1<DynamicMetaObject> args, bool testTypes);
    [ObsoleteAttribute("You should use the overload which takes ExpressionType instead")]
public DynamicMetaObject DoOperation(string operation, DynamicMetaObject[] args);
    [ObsoleteAttribute("You should use the overload which takes ExpressionType instead")]
public DynamicMetaObject DoOperation(string operation, OverloadResolverFactory resolverFactory, DynamicMetaObject[] args);
    public DynamicMetaObject DoOperation(ExpressionType operation, DynamicMetaObject[] args);
    public DynamicMetaObject DoOperation(ExpressionType operation, OverloadResolverFactory resolverFactory, DynamicMetaObject[] args);
    public DynamicMetaObject GetIndex(DynamicMetaObject[] args);
    public DynamicMetaObject GetIndex(OverloadResolverFactory resolverFactory, DynamicMetaObject[] args);
    public DynamicMetaObject SetIndex(DynamicMetaObject[] args);
    public DynamicMetaObject SetIndex(OverloadResolverFactory resolverFactory, DynamicMetaObject[] args);
    public DynamicMetaObject GetDocumentation(DynamicMetaObject target);
    public DynamicMetaObject GetMemberNames(DynamicMetaObject target);
    public DynamicMetaObject GetCallSignatures(DynamicMetaObject target);
    public DynamicMetaObject GetIsCallable(DynamicMetaObject target);
    private DynamicMetaObject MakeGeneralOperatorRule(string operation, OverloadResolverFactory resolverFactory, DynamicMetaObject[] args);
    private DynamicMetaObject MakeGeneralOperatorRule(ExpressionType operation, OverloadResolverFactory resolverFactory, DynamicMetaObject[] args);
    private DynamicMetaObject MakeGeneratorOperatorRule(OverloadResolverFactory resolverFactory, DynamicMetaObject[] args, OperatorInfo info);
    private DynamicMetaObject MakeComparisonRule(OperatorInfo info, OverloadResolverFactory resolverFactory, DynamicMetaObject[] args);
    private DynamicMetaObject TryComparisonMethod(OperatorInfo info, OverloadResolverFactory resolverFactory, DynamicMetaObject target, DynamicMetaObject[] args);
    private static DynamicMetaObject MakeOperatorError(OperatorInfo info, DynamicMetaObject[] args);
    private DynamicMetaObject TryNumericComparison(OperatorInfo info, OverloadResolverFactory resolverFactory, DynamicMetaObject[] args);
    private DynamicMetaObject TryInvertedComparison(OperatorInfo info, OverloadResolverFactory resolverFactory, DynamicMetaObject target, DynamicMetaObject[] args);
    private static DynamicMetaObject TryNullComparisonRule(DynamicMetaObject[] args);
    private static DynamicMetaObject TryPrimitiveCompare(OperatorInfo info, DynamicMetaObject[] args);
    private DynamicMetaObject MakeOperatorRule(OperatorInfo info, OverloadResolverFactory resolverFactory, DynamicMetaObject[] args);
    private static DynamicMetaObject TryPrimitiveOperator(OperatorInfo info, DynamicMetaObject[] args);
    private DynamicMetaObject TryForwardOperator(OperatorInfo info, OverloadResolverFactory resolverFactory, DynamicMetaObject[] args);
    private DynamicMetaObject TryReverseOperator(OperatorInfo info, OverloadResolverFactory resolverFactory, DynamicMetaObject[] args);
    private static DynamicMetaObject TryMakeDefaultUnaryRule(OperatorInfo info, DynamicMetaObject[] args);
    private static DynamicMetaObject MakeCallSignatureResult(MethodBase[] methods, DynamicMetaObject target);
    private static Type GetArgType(DynamicMetaObject[] args, int index);
    private DynamicMetaObject MakeMethodIndexRule(IndexType oper, OverloadResolverFactory resolverFactory, DynamicMetaObject[] args);
    private DynamicMetaObject MakeArrayIndexRule(OverloadResolverFactory factory, IndexType oper, DynamicMetaObject[] args);
    private MethodInfo[] GetMethodsFromDefaults(IEnumerable`1<MemberInfo> defaults, IndexType op);
    private DynamicMetaObject TryMakeBindingTarget(OverloadResolverFactory resolverFactory, MethodInfo[] targets, DynamicMetaObject[] args, BindingRestrictions restrictions);
    private DynamicMetaObject TryMakeInvertedBindingTarget(OverloadResolverFactory resolverFactory, MethodBase[] targets, DynamicMetaObject[] args);
    private static ExpressionType GetInvertedOperator(ExpressionType op);
    private Expression ConvertIfNeeded(OverloadResolverFactory factory, Expression expression, Type type);
    private MethodInfo[] GetApplicableMembers(Type t, OperatorInfo info);
    private static MethodInfo[] FilterNonMethods(Type t, MemberGroup members);
    public DynamicMetaObject SetMember(string name, DynamicMetaObject target, DynamicMetaObject value);
    public DynamicMetaObject SetMember(string name, DynamicMetaObject target, DynamicMetaObject value, OverloadResolverFactory resolverFactory);
    public DynamicMetaObject SetMember(string name, DynamicMetaObject target, DynamicMetaObject value, DynamicMetaObject errorSuggestion);
    public DynamicMetaObject SetMember(string name, DynamicMetaObject target, DynamicMetaObject value, DynamicMetaObject errorSuggestion, OverloadResolverFactory resolverFactory);
    private DynamicMetaObject MakeSetMemberTarget(SetOrDeleteMemberInfo memInfo, DynamicMetaObject target, DynamicMetaObject value, DynamicMetaObject errorSuggestion);
    private void MakeSetMemberRule(SetOrDeleteMemberInfo memInfo, Type type, DynamicMetaObject self, DynamicMetaObject value, DynamicMetaObject errorSuggestion);
    private void MakeGenericBody(SetOrDeleteMemberInfo memInfo, DynamicMetaObject instance, DynamicMetaObject target, Type instanceType, MemberTracker tracker, DynamicMetaObject errorSuggestion);
    private void MakePropertyRule(SetOrDeleteMemberInfo memInfo, DynamicMetaObject instance, DynamicMetaObject target, Type targetType, MemberGroup properties, DynamicMetaObject errorSuggestion);
    private void MakeFieldRule(SetOrDeleteMemberInfo memInfo, DynamicMetaObject instance, DynamicMetaObject target, Type targetType, MemberGroup fields, DynamicMetaObject errorSuggestion);
    private DynamicMetaObject MakeReturnValue(DynamicMetaObject expression, DynamicMetaObject target);
    private Expression MakeReturnValue(Expression expression, DynamicMetaObject target);
    private bool MakeOperatorSetMemberBody(SetOrDeleteMemberInfo memInfo, DynamicMetaObject self, DynamicMetaObject target, Type type, string name);
    private static Expression MakeGenericPropertyExpression(SetOrDeleteMemberInfo memInfo);
}
public class Microsoft.Scripting.Actions.DefaultOverloadResolver : OverloadResolver {
    private IList`1<DynamicMetaObject> _args;
    private CallSignature _signature;
    private CallTypes _callType;
    private DynamicMetaObject _invalidSplattee;
    private static DefaultOverloadResolverFactory _factory;
    public static OverloadResolverFactory Factory { get; }
    public CallSignature Signature { get; }
    public IList`1<DynamicMetaObject> Arguments { get; }
    public CallTypes CallType { get; }
    public DefaultOverloadResolver(ActionBinder binder, DynamicMetaObject instance, IList`1<DynamicMetaObject> args, CallSignature signature);
    public DefaultOverloadResolver(ActionBinder binder, IList`1<DynamicMetaObject> args, CallSignature signature);
    public DefaultOverloadResolver(ActionBinder binder, IList`1<DynamicMetaObject> args, CallSignature signature, CallTypes callType);
    private static DefaultOverloadResolver();
    public static OverloadResolverFactory get_Factory();
    public CallSignature get_Signature();
    public IList`1<DynamicMetaObject> get_Arguments();
    public CallTypes get_CallType();
    protected internal virtual BitArray MapSpecialParameters(ParameterMapping mapping);
    protected internal virtual Candidate CompareEquivalentCandidates(ApplicableCandidate one, ApplicableCandidate two);
    private DynamicMetaObject GetArgument(int i);
    protected virtual void GetNamedArguments(IList`1& namedArgs, IList`1& argNames);
    protected internal virtual bool AllowByKeywordArgument(OverloadInfo method, ParameterInfo parameter);
    protected virtual ActualArguments CreateActualArguments(IList`1<DynamicMetaObject> namedArgs, IList`1<string> argNames, int preSplatLimit, int postSplatLimit);
    private void SplatDictionaryArgument(IList`1<string> splattedNames, IList`1<DynamicMetaObject> splattedArgs);
    protected virtual Expression GetSplattedExpression();
    protected virtual object GetSplattedItem(int index);
    public virtual ErrorInfo MakeInvalidParametersError(BindingTarget target);
    private ErrorInfo MakeInvalidSplatteeError(BindingTarget target);
}
internal class Microsoft.Scripting.Actions.DefaultOverloadResolverFactory : OverloadResolverFactory {
    private DefaultBinder _binder;
    public DefaultOverloadResolverFactory(DefaultBinder binder);
    public virtual DefaultOverloadResolver CreateOverloadResolver(IList`1<DynamicMetaObject> args, CallSignature signature, CallTypes callType);
}
[ExtensionAttribute]
public static class Microsoft.Scripting.Actions.DynamicSiteHelpers : object {
    private static int MaximumArity;
    private static Dictionary`2<ICollection`1<Type>, Type> _DelegateTypes;
    public static Type MakeCallSiteDelegate(Type[] types);
    private static Type MakeDelegate(Type[] types);
    public static Type GetStandardDelegateType(Type[] types);
    private static Type GetFuncType(Type[] types);
    private static Type GetActionType(Type[] types);
    [ExtensionAttribute]
private static T[] AddFirst(IList`1<T> list, T item);
    [ExtensionAttribute]
private static bool Any(IEnumerable`1<T> source, Func`2<T, bool> predicate);
    [ExtensionAttribute]
private static T[] RemoveLast(T[] array);
    private static Type MakeCustomDelegate(Type[] types);
    private static Type MakeNewCustomDelegate(Type[] types);
    public static bool IsInvisibleDlrStackFrame(MethodBase mb);
}
public class Microsoft.Scripting.Actions.ErrorInfo : object {
    [CompilerGeneratedAttribute]
private ErrorInfoKind <Kind>k__BackingField;
    [CompilerGeneratedAttribute]
private Expression <Expression>k__BackingField;
    public ErrorInfoKind Kind { get; }
    public Expression Expression { get; }
    private ErrorInfo(Expression value, ErrorInfoKind kind);
    public static ErrorInfo FromException(Expression exceptionValue);
    public static ErrorInfo FromValue(Expression resultValue);
    public static ErrorInfo FromValueNoError(Expression resultValue);
    [CompilerGeneratedAttribute]
public ErrorInfoKind get_Kind();
    [CompilerGeneratedAttribute]
public Expression get_Expression();
}
public enum Microsoft.Scripting.Actions.ErrorInfoKind : Enum {
    public int value__;
    public static ErrorInfoKind Exception;
    public static ErrorInfoKind Error;
    public static ErrorInfoKind Success;
}
public class Microsoft.Scripting.Actions.ErrorMetaObject : DynamicMetaObject {
    public ErrorMetaObject(Expression body, BindingRestrictions restrictions);
}
public class Microsoft.Scripting.Actions.EventTracker : MemberTracker {
    private WeakDictionary`2<object, NormalHandlerList> _handlerLists;
    private static object _staticTarget;
    private EventInfo _eventInfo;
    private MethodInfo _addMethod;
    private MethodInfo _removeMethod;
    public Type DeclaringType { get; }
    public TrackerTypes MemberType { get; }
    public string Name { get; }
    public EventInfo Event { get; }
    public bool IsStatic { get; }
    internal EventTracker(EventInfo eventInfo);
    private static EventTracker();
    public virtual Type get_DeclaringType();
    public virtual TrackerTypes get_MemberType();
    public virtual string get_Name();
    public EventInfo get_Event();
    public MethodInfo GetCallableAddMethod();
    public MethodInfo GetCallableRemoveMethod();
    public bool get_IsStatic();
    protected internal virtual DynamicMetaObject GetBoundValue(OverloadResolverFactory resolverFactory, ActionBinder binder, Type type, DynamicMetaObject instance);
    public virtual MemberTracker BindToInstance(DynamicMetaObject instance);
    public virtual string ToString();
    public void AddHandler(object target, object handler, DynamicDelegateCreator delegateCreator);
    public void RemoveHandler(object target, object handler, IEqualityComparer`1<object> objectComparer);
    private HandlerList GetHandlerList(object instance);
    private HandlerList GetComHandlerList(object instance);
}
public abstract class Microsoft.Scripting.Actions.ExtensionBinaryOperationBinder : BinaryOperationBinder {
    private string _operation;
    public string ExtensionOperation { get; }
    protected ExtensionBinaryOperationBinder(string operation);
    public string get_ExtensionOperation();
    public virtual int GetHashCode();
    public virtual bool Equals(object obj);
}
public class Microsoft.Scripting.Actions.ExtensionMethodTracker : MethodTracker {
    [CompilerGeneratedAttribute]
private Type <DeclaringType>k__BackingField;
    public Type DeclaringType { get; }
    internal ExtensionMethodTracker(MethodInfo method, bool isStatic, Type declaringType);
    [CompilerGeneratedAttribute]
public virtual Type get_DeclaringType();
}
public class Microsoft.Scripting.Actions.ExtensionPropertyTracker : PropertyTracker {
    private MethodInfo _getter;
    private MethodInfo _setter;
    private MethodInfo _deleter;
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    [CompilerGeneratedAttribute]
private Type <DeclaringType>k__BackingField;
    public string Name { get; }
    public Type DeclaringType { get; }
    public bool IsStatic { get; }
    public Type PropertyType { get; }
    public ExtensionPropertyTracker(string name, MethodInfo getter, MethodInfo setter, MethodInfo deleter, Type declaringType);
    [CompilerGeneratedAttribute]
public virtual string get_Name();
    [CompilerGeneratedAttribute]
public virtual Type get_DeclaringType();
    public virtual bool get_IsStatic();
    public virtual MethodInfo GetGetMethod();
    public virtual MethodInfo GetSetMethod();
    public virtual MethodInfo GetGetMethod(bool privateMembers);
    public virtual MethodInfo GetSetMethod(bool privateMembers);
    public virtual MethodInfo GetDeleteMethod();
    public virtual MethodInfo GetDeleteMethod(bool privateMembers);
    public virtual ParameterInfo[] GetIndexParameters();
    private static bool IsStaticProperty(MethodInfo method);
    public virtual Type get_PropertyType();
}
public abstract class Microsoft.Scripting.Actions.ExtensionUnaryOperationBinder : UnaryOperationBinder {
    private string _operation;
    public string ExtensionOperation { get; }
    protected ExtensionUnaryOperationBinder(string operation);
    public string get_ExtensionOperation();
    public virtual int GetHashCode();
    public virtual bool Equals(object obj);
}
public class Microsoft.Scripting.Actions.FieldTracker : MemberTracker {
    private FieldInfo _field;
    public Type DeclaringType { get; }
    public TrackerTypes MemberType { get; }
    public string Name { get; }
    public bool IsPublic { get; }
    public bool IsInitOnly { get; }
    public bool IsLiteral { get; }
    public Type FieldType { get; }
    public bool IsStatic { get; }
    public FieldInfo Field { get; }
    public FieldTracker(FieldInfo field);
    public virtual Type get_DeclaringType();
    public virtual TrackerTypes get_MemberType();
    public virtual string get_Name();
    public bool get_IsPublic();
    public bool get_IsInitOnly();
    public bool get_IsLiteral();
    public Type get_FieldType();
    public bool get_IsStatic();
    public FieldInfo get_Field();
    public virtual string ToString();
    public virtual DynamicMetaObject GetValue(OverloadResolverFactory resolverFactory, ActionBinder binder, Type type);
    public virtual ErrorInfo GetError(ActionBinder binder, Type instanceType);
    protected internal virtual DynamicMetaObject GetBoundValue(OverloadResolverFactory resolverFactory, ActionBinder binder, Type type, DynamicMetaObject instance);
    public virtual MemberTracker BindToInstance(DynamicMetaObject instance);
}
public interface Microsoft.Scripting.Actions.ILightExceptionBinder {
    public bool SupportsLightThrow { get; }
    public abstract virtual bool get_SupportsLightThrow();
    public abstract virtual CallSiteBinder GetLightExceptionBinder();
}
public static class Microsoft.Scripting.Actions.Interceptor : object {
    public static Expression Intercept(Expression expression);
    public static LambdaExpression Intercept(LambdaExpression lambda);
}
[DefaultMemberAttribute("Item")]
public class Microsoft.Scripting.Actions.MemberGroup : object {
    public static MemberGroup EmptyGroup;
    private MemberTracker[] _members;
    public int Count { get; }
    public MemberTracker Item { get; }
    private MemberGroup(MemberTracker[] members, bool noChecks);
    public MemberGroup(MemberTracker[] members);
    public MemberGroup(MemberInfo[] members);
    private static MemberGroup();
    internal static MemberGroup CreateInternal(MemberTracker[] members);
    public int get_Count();
    public MemberTracker get_Item(int index);
    [IteratorStateMachineAttribute("Microsoft.Scripting.Actions.MemberGroup/<GetEnumerator>d__10")]
public sealed virtual IEnumerator`1<MemberTracker> GetEnumerator();
    [IteratorStateMachineAttribute("Microsoft.Scripting.Actions.MemberGroup/<System-Collections-IEnumerable-GetEnumerator>d__11")]
private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
}
public enum Microsoft.Scripting.Actions.MemberRequestKind : Enum {
    public int value__;
    public static MemberRequestKind None;
    public static MemberRequestKind Get;
    public static MemberRequestKind Set;
    public static MemberRequestKind Delete;
    public static MemberRequestKind Invoke;
    public static MemberRequestKind InvokeMember;
    public static MemberRequestKind Convert;
    public static MemberRequestKind Operation;
}
public abstract class Microsoft.Scripting.Actions.MemberTracker : object {
    public static MemberTracker[] EmptyTrackers;
    private static Dictionary`2<MemberKey, MemberTracker> _trackers;
    public TrackerTypes MemberType { get; }
    public Type DeclaringType { get; }
    public string Name { get; }
    private static MemberTracker();
    public abstract virtual TrackerTypes get_MemberType();
    public abstract virtual Type get_DeclaringType();
    public abstract virtual string get_Name();
    public static MemberTracker FromMemberInfo(MemberInfo member);
    public static MemberTracker FromMemberInfo(MemberInfo member, Type extending);
    public virtual DynamicMetaObject GetValue(OverloadResolverFactory resolverFactory, ActionBinder binder, Type instanceType);
    public virtual DynamicMetaObject SetValue(OverloadResolverFactory resolverFactory, ActionBinder binder, Type instanceType, DynamicMetaObject value);
    public virtual DynamicMetaObject SetValue(OverloadResolverFactory resolverFactory, ActionBinder binder, Type instanceType, DynamicMetaObject value, DynamicMetaObject errorSuggestion);
    internal virtual DynamicMetaObject Call(OverloadResolverFactory resolverFactory, ActionBinder binder, DynamicMetaObject[] arguments);
    public virtual ErrorInfo GetError(ActionBinder binder, Type instanceType);
    public virtual ErrorInfo GetBoundError(ActionBinder binder, DynamicMetaObject instance, Type instanceType);
    protected internal virtual DynamicMetaObject GetBoundValue(OverloadResolverFactory resolverFactory, ActionBinder binder, Type instanceType, DynamicMetaObject instance);
    protected internal virtual DynamicMetaObject SetBoundValue(OverloadResolverFactory resolverFactory, ActionBinder binder, Type instanceType, DynamicMetaObject value, DynamicMetaObject instance);
    protected internal virtual DynamicMetaObject SetBoundValue(OverloadResolverFactory resolverFactory, ActionBinder binder, Type instanceType, DynamicMetaObject value, DynamicMetaObject instance, DynamicMetaObject errorSuggestion);
    public virtual MemberTracker BindToInstance(DynamicMetaObject instance);
}
public class Microsoft.Scripting.Actions.MethodGroup : MemberTracker {
    private MethodTracker[] _methods;
    private Dictionary`2<TypeList, MethodGroup> _boundGenerics;
    public TrackerTypes MemberType { get; }
    public Type DeclaringType { get; }
    public string Name { get; }
    public bool ContainsInstance { get; }
    public bool ContainsStatic { get; }
    public IList`1<MethodTracker> Methods { get; }
    internal MethodGroup(MethodTracker[] methods);
    public virtual TrackerTypes get_MemberType();
    public virtual Type get_DeclaringType();
    public virtual string get_Name();
    public bool get_ContainsInstance();
    public bool get_ContainsStatic();
    public IList`1<MethodTracker> get_Methods();
    public MethodBase[] GetMethodBases();
    public virtual MemberTracker BindToInstance(DynamicMetaObject instance);
    protected internal virtual DynamicMetaObject GetBoundValue(OverloadResolverFactory resolverFactory, ActionBinder binder, Type type, DynamicMetaObject instance);
    public MethodGroup MakeGenericMethod(Type[] types);
    private void EnsureBoundGenericDict();
}
public class Microsoft.Scripting.Actions.MethodTracker : MemberTracker {
    private MethodInfo _method;
    [CompilerGeneratedAttribute]
private bool <IsStatic>k__BackingField;
    public Type DeclaringType { get; }
    public TrackerTypes MemberType { get; }
    public string Name { get; }
    public MethodInfo Method { get; }
    public bool IsPublic { get; }
    public bool IsStatic { get; }
    internal MethodTracker(MethodInfo method);
    internal MethodTracker(MethodInfo method, bool isStatic);
    public virtual Type get_DeclaringType();
    public virtual TrackerTypes get_MemberType();
    public virtual string get_Name();
    public MethodInfo get_Method();
    public bool get_IsPublic();
    [CompilerGeneratedAttribute]
public bool get_IsStatic();
    public virtual string ToString();
    public virtual MemberTracker BindToInstance(DynamicMetaObject instance);
    protected internal virtual DynamicMetaObject GetBoundValue(OverloadResolverFactory resolverFactory, ActionBinder binder, Type type, DynamicMetaObject instance);
    internal virtual DynamicMetaObject Call(OverloadResolverFactory resolverFactory, ActionBinder binder, DynamicMetaObject[] arguments);
}
[DefaultMemberAttribute("Item")]
public class Microsoft.Scripting.Actions.NamespaceTracker : MemberTracker {
    internal Dictionary`2<string, MemberTracker> _dict;
    internal List`1<Assembly> _packageAssemblies;
    internal Dictionary`2<Assembly, TypeNames> _typeNames;
    private string _fullName;
    private TopNamespaceTracker _topPackage;
    private int _id;
    private static int _masterId;
    public string Name { get; }
    public object Item { get; }
    public int Count { get; }
    public ICollection`1<string> Keys { get; }
    public IList`1<Assembly> PackageAssemblies { get; }
    public int Id { get; }
    public TrackerTypes MemberType { get; }
    public Type DeclaringType { get; }
    protected NamespaceTracker(string name);
    public virtual string ToString();
    internal NamespaceTracker GetOrMakeChildPackage(string childName, Assembly assem);
    private NamespaceTracker MakeChildPackage(string childName, Assembly assem);
    private string GetFullChildName(string childName);
    private static Type LoadType(Assembly assem, string fullTypeName);
    internal void AddTypeName(string typeName, Assembly assem);
    private void LoadAllTypes();
    public virtual string get_Name();
    protected void DiscoverAllTypes(Assembly assem);
    private NamespaceTracker GetOrMakePackageHierarchy(Assembly assem, string fullNamespace);
    private MemberTracker CheckForUnlistedType(string nameString);
    public bool TryGetValue(string name, Object& value);
    public bool TryGetValue(string name, MemberTracker& value);
    public bool ContainsKey(string name);
    public object get_Item(string name);
    public int get_Count();
    public ICollection`1<string> get_Keys();
    private IList AddKeys(IList res);
    [IteratorStateMachineAttribute("Microsoft.Scripting.Actions.NamespaceTracker/<GetEnumerator>d__30")]
public sealed virtual IEnumerator`1<KeyValuePair`2<string, object>> GetEnumerator();
    [IteratorStateMachineAttribute("Microsoft.Scripting.Actions.NamespaceTracker/<System-Collections-IEnumerable-GetEnumerator>d__31")]
private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    public IList`1<Assembly> get_PackageAssemblies();
    protected virtual void LoadNamespaces();
    protected void SetTopPackage(TopNamespaceTracker pkg);
    public int get_Id();
    public sealed virtual IList`1<string> GetMemberNames();
    public virtual TrackerTypes get_MemberType();
    public virtual Type get_DeclaringType();
    private void UpdateId();
    protected void UpdateSubtreeIds();
}
public class Microsoft.Scripting.Actions.NestedTypeTracker : TypeTracker {
    private Type _type;
    public Type DeclaringType { get; }
    public TrackerTypes MemberType { get; }
    public string Name { get; }
    public bool IsPublic { get; }
    public Type Type { get; }
    public bool IsGenericType { get; }
    public NestedTypeTracker(Type type);
    public virtual Type get_DeclaringType();
    public virtual TrackerTypes get_MemberType();
    public virtual string get_Name();
    public virtual bool get_IsPublic();
    public virtual Type get_Type();
    public virtual bool get_IsGenericType();
    public virtual string ToString();
}
[AttributeUsageAttribute("96")]
public class Microsoft.Scripting.Actions.NoSideEffectsAttribute : Attribute {
}
[ObsoleteAttribute("Use ExtensionBinaryOperationBinder or ExtensionUnaryOperationBinder")]
public abstract class Microsoft.Scripting.Actions.OperationBinder : DynamicMetaObjectBinder {
    [CompilerGeneratedAttribute]
private string <Operation>k__BackingField;
    public string Operation { get; }
    protected OperationBinder(string operation);
    [CompilerGeneratedAttribute]
public string get_Operation();
    public DynamicMetaObject FallbackOperation(DynamicMetaObject target, DynamicMetaObject[] args);
    public abstract virtual DynamicMetaObject FallbackOperation(DynamicMetaObject target, DynamicMetaObject[] args, DynamicMetaObject errorSuggestion);
    public sealed virtual DynamicMetaObject Bind(DynamicMetaObject target, DynamicMetaObject[] args);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
}
public class Microsoft.Scripting.Actions.OperationMetaObject : DynamicMetaObject {
    public OperationMetaObject(Expression expression, BindingRestrictions restrictions);
    public OperationMetaObject(Expression expression, BindingRestrictions restrictions, object value);
    [ObsoleteAttribute("Use ExtensionBinaryOperationBinder or ExtensionUnaryOperationBinder")]
public virtual DynamicMetaObject BindOperation(OperationBinder binder, DynamicMetaObject[] args);
}
internal class Microsoft.Scripting.Actions.OperatorInfo : object {
    private static Dictionary`2<ExpressionType, OperatorInfo> _infos;
    [CompilerGeneratedAttribute]
private ExpressionType <Operator>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    [CompilerGeneratedAttribute]
private string <AlternateName>k__BackingField;
    public ExpressionType Operator { get; }
    public string Name { get; }
    public string AlternateName { get; }
    private OperatorInfo(ExpressionType op, string name, string altName);
    private static OperatorInfo();
    public static OperatorInfo GetOperatorInfo(ExpressionType op);
    public static OperatorInfo GetOperatorInfo(string name);
    [CompilerGeneratedAttribute]
public ExpressionType get_Operator();
    [CompilerGeneratedAttribute]
public string get_Name();
    [CompilerGeneratedAttribute]
public string get_AlternateName();
    private static Dictionary`2<ExpressionType, OperatorInfo> MakeOperatorTable();
}
public class Microsoft.Scripting.Actions.ParameterMappingInfo : object {
    private int _parameterIndex;
    private int _actionIndex;
    private ConstantExpression _fixedInput;
    public int ParameterIndex { get; }
    public int ActionIndex { get; }
    public ConstantExpression Constant { get; }
    public bool IsParameter { get; }
    public bool IsAction { get; }
    public bool IsConstant { get; }
    private ParameterMappingInfo(int param, int action, ConstantExpression fixedInput);
    public static ParameterMappingInfo Parameter(int index);
    public static ParameterMappingInfo Action(int index);
    public static ParameterMappingInfo Fixed(ConstantExpression e);
    public int get_ParameterIndex();
    public int get_ActionIndex();
    public ConstantExpression get_Constant();
    public bool get_IsParameter();
    public bool get_IsAction();
    public bool get_IsConstant();
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public virtual string ToString();
}
public abstract class Microsoft.Scripting.Actions.PropertyTracker : MemberTracker {
    public TrackerTypes MemberType { get; }
    public bool IsStatic { get; }
    public Type PropertyType { get; }
    public virtual TrackerTypes get_MemberType();
    public abstract virtual MethodInfo GetGetMethod();
    public abstract virtual MethodInfo GetSetMethod();
    public abstract virtual MethodInfo GetGetMethod(bool privateMembers);
    public abstract virtual MethodInfo GetSetMethod(bool privateMembers);
    public virtual MethodInfo GetDeleteMethod();
    public virtual MethodInfo GetDeleteMethod(bool privateMembers);
    public abstract virtual ParameterInfo[] GetIndexParameters();
    public abstract virtual bool get_IsStatic();
    public abstract virtual Type get_PropertyType();
    public virtual DynamicMetaObject GetValue(OverloadResolverFactory resolverFactory, ActionBinder binder, Type instanceType);
    public virtual ErrorInfo GetError(ActionBinder binder, Type instanceType);
    protected internal virtual DynamicMetaObject GetBoundValue(OverloadResolverFactory resolverFactory, ActionBinder binder, Type type, DynamicMetaObject instance);
    public virtual ErrorInfo GetBoundError(ActionBinder binder, DynamicMetaObject instance, Type instanceType);
    public virtual MemberTracker BindToInstance(DynamicMetaObject instance);
    private MethodInfo ResolveGetter(Type instanceType, bool privateBinding);
}
public class Microsoft.Scripting.Actions.ReflectedPropertyTracker : PropertyTracker {
    private PropertyInfo _propInfo;
    public string Name { get; }
    public Type DeclaringType { get; }
    public bool IsStatic { get; }
    public Type PropertyType { get; }
    public PropertyInfo Property { get; }
    public ReflectedPropertyTracker(PropertyInfo property);
    public virtual string get_Name();
    public virtual Type get_DeclaringType();
    public virtual bool get_IsStatic();
    public virtual Type get_PropertyType();
    public virtual MethodInfo GetGetMethod();
    public virtual MethodInfo GetSetMethod();
    public virtual MethodInfo GetGetMethod(bool privateMembers);
    public virtual MethodInfo GetSetMethod(bool privateMembers);
    public virtual MethodInfo GetDeleteMethod();
    public virtual MethodInfo GetDeleteMethod(bool privateMembers);
    public virtual ParameterInfo[] GetIndexParameters();
    public PropertyInfo get_Property();
    public virtual string ToString();
}
public class Microsoft.Scripting.Actions.TopNamespaceTracker : NamespaceTracker {
    private int _lastDiscovery;
    internal object HierarchyLock;
    private static Dictionary`2<Guid, Type> _comTypeCache;
    [CompilerGeneratedAttribute]
private ScriptDomainManager <DomainManager>k__BackingField;
    public ScriptDomainManager DomainManager { get; }
    public TopNamespaceTracker(ScriptDomainManager manager);
    private static TopNamespaceTracker();
    public NamespaceTracker TryGetPackage(string name);
    public MemberTracker TryGetPackageAny(string name);
    public MemberTracker TryGetPackageLazy(string name);
    public bool LoadAssembly(Assembly assem);
    public static void PublishComTypes(Assembly interopAssembly);
    protected virtual void LoadNamespaces();
    [CompilerGeneratedAttribute]
public ScriptDomainManager get_DomainManager();
}
[FlagsAttribute]
public enum Microsoft.Scripting.Actions.TrackerTypes : Enum {
    public int value__;
    public static TrackerTypes None;
    public static TrackerTypes Constructor;
    public static TrackerTypes Event;
    public static TrackerTypes Field;
    public static TrackerTypes Method;
    public static TrackerTypes Property;
    public static TrackerTypes Type;
    public static TrackerTypes Namespace;
    public static TrackerTypes MethodGroup;
    public static TrackerTypes TypeGroup;
    public static TrackerTypes Custom;
    public static TrackerTypes Bound;
    public static TrackerTypes All;
}
public class Microsoft.Scripting.Actions.TypeGroup : TypeTracker {
    private Dictionary`2<int, Type> _typesByArity;
    private string _name;
    private Type SampleType { get; }
    public IEnumerable`1<Type> Types { get; }
    public IDictionary`2<int, Type> TypesByArity { get; }
    public TrackerTypes MemberType { get; }
    public Type DeclaringType { get; }
    public string Name { get; }
    public Type Type { get; }
    public bool IsGenericType { get; }
    public bool IsPublic { get; }
    private TypeGroup(Type t1, int arity1, Type t2, int arity2);
    private TypeGroup(Type t1, TypeGroup existingTypes);
    public virtual string ToString();
    public virtual IList`1<string> GetMemberNames();
    public TypeTracker GetTypeForArity(int arity);
    public static TypeTracker UpdateTypeEntity(TypeTracker existingTypeEntity, TypeTracker newType);
    private static int GetGenericArity(Type type);
    public Type GetNonGenericType();
    public bool TryGetNonGenericType(Type& nonGenericType);
    private Type get_SampleType();
    public IEnumerable`1<Type> get_Types();
    public IDictionary`2<int, Type> get_TypesByArity();
    public virtual TrackerTypes get_MemberType();
    public virtual Type get_DeclaringType();
    public virtual string get_Name();
    public virtual Type get_Type();
    public virtual bool get_IsGenericType();
    public virtual bool get_IsPublic();
}
public abstract class Microsoft.Scripting.Actions.TypeTracker : MemberTracker {
    private static Dictionary`2<Type, TypeTracker> _typeCache;
    public Type Type { get; }
    public bool IsGenericType { get; }
    public bool IsPublic { get; }
    private static TypeTracker();
    public abstract virtual Type get_Type();
    public abstract virtual bool get_IsGenericType();
    public abstract virtual bool get_IsPublic();
    public virtual IList`1<string> GetMemberNames();
    internal static void GetMemberNames(Type type, HashSet`1<string> result);
    public static Type op_Explicit(TypeTracker tracker);
    public static TypeTracker GetTypeTracker(Type type);
}
public class Microsoft.Scripting.AmbiguousFileNameException : Exception {
    [CompilerGeneratedAttribute]
private string <FirstPath>k__BackingField;
    [CompilerGeneratedAttribute]
private string <SecondPath>k__BackingField;
    public string FirstPath { get; }
    public string SecondPath { get; }
    public AmbiguousFileNameException(string firstPath, string secondPath);
    public AmbiguousFileNameException(string firstPath, string secondPath, string message);
    public AmbiguousFileNameException(string firstPath, string secondPath, string message, Exception inner);
    protected AmbiguousFileNameException(SerializationInfo info, StreamingContext context);
    [CompilerGeneratedAttribute]
public string get_FirstPath();
    [CompilerGeneratedAttribute]
public string get_SecondPath();
    public virtual void GetObjectData(SerializationInfo info, StreamingContext context);
}
public class Microsoft.Scripting.Ast.BlockBuilder : ExpressionCollectionBuilder`1<Expression> {
    public Expression ToExpression();
    public static Expression op_Implicit(BlockBuilder block);
}
[FlagsAttribute]
public enum Microsoft.Scripting.Ast.ExpressionAccess : Enum {
    public int value__;
    public static ExpressionAccess None;
    public static ExpressionAccess Read;
    public static ExpressionAccess Write;
    public static ExpressionAccess ReadWrite;
}
public class Microsoft.Scripting.Ast.ExpressionCollectionBuilder : ExpressionCollectionBuilder`1<Expression> {
    public Expression ToMethodCall(Expression instance, MethodInfo method);
}
public class Microsoft.Scripting.Ast.ExpressionCollectionBuilder`1 : object {
    [CompilerGeneratedAttribute]
private TExpression <Expression0>k__BackingField;
    [CompilerGeneratedAttribute]
private TExpression <Expression1>k__BackingField;
    [CompilerGeneratedAttribute]
private TExpression <Expression2>k__BackingField;
    [CompilerGeneratedAttribute]
private TExpression <Expression3>k__BackingField;
    private int _count;
    private ReadOnlyCollectionBuilder`1<TExpression> _expressions;
    public TExpression Expression0 { get; private set; }
    public TExpression Expression1 { get; private set; }
    public TExpression Expression2 { get; private set; }
    public TExpression Expression3 { get; private set; }
    public int Count { get; }
    public ReadOnlyCollectionBuilder`1<TExpression> Expressions { get; }
    public bool IsReadOnly { get; }
    [CompilerGeneratedAttribute]
public TExpression get_Expression0();
    [CompilerGeneratedAttribute]
private void set_Expression0(TExpression value);
    [CompilerGeneratedAttribute]
public TExpression get_Expression1();
    [CompilerGeneratedAttribute]
private void set_Expression1(TExpression value);
    [CompilerGeneratedAttribute]
public TExpression get_Expression2();
    [CompilerGeneratedAttribute]
private void set_Expression2(TExpression value);
    [CompilerGeneratedAttribute]
public TExpression get_Expression3();
    [CompilerGeneratedAttribute]
private void set_Expression3(TExpression value);
    public sealed virtual int get_Count();
    public ReadOnlyCollectionBuilder`1<TExpression> get_Expressions();
    public void Add(IEnumerable`1<TExpression> expressions);
    public sealed virtual void Add(TExpression item);
    [IteratorStateMachineAttribute("Microsoft.Scripting.Ast.ExpressionCollectionBuilder`1/<GetItemEnumerator>d__24")]
private IEnumerator`1<TExpression> GetItemEnumerator();
    public sealed virtual IEnumerator`1<TExpression> GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    public sealed virtual void Clear();
    public sealed virtual bool Contains(TExpression item);
    public sealed virtual void CopyTo(TExpression[] array, int arrayIndex);
    public sealed virtual bool get_IsReadOnly();
    public sealed virtual bool Remove(TExpression item);
}
public class Microsoft.Scripting.Ast.FinallyFlowControlExpression : Expression {
    private Expression _body;
    private Expression _reduced;
    public bool CanReduce { get; }
    public Type Type { get; }
    public ExpressionType NodeType { get; }
    public Expression Body { get; }
    internal FinallyFlowControlExpression(Expression body);
    public virtual bool get_CanReduce();
    public sealed virtual Type get_Type();
    public sealed virtual ExpressionType get_NodeType();
    public Expression get_Body();
    public virtual Expression Reduce();
    protected virtual Expression VisitChildren(ExpressionVisitor visitor);
    private sealed virtual override void Microsoft.Scripting.Interpreter.IInstructionProvider.AddInstructions(LightCompiler compiler);
}
internal class Microsoft.Scripting.Ast.FlowControlRewriter : ExpressionVisitor {
    private Dictionary`2<LabelTarget, LabelInfo> _labels;
    private Stack`1<BlockInfo> _blocks;
    private ParameterExpression _flowVariable;
    internal Expression Reduce(Expression node);
    private void EnsureFlow(BlockInfo block);
    private LabelInfo EnsureLabelInfo(LabelTarget target);
    protected virtual Expression VisitExtension(Expression node);
    protected virtual Expression VisitLambda(Expression`1<T> node);
    protected virtual Expression VisitTry(TryExpression node);
    private Expression MakeFlowControlSwitch(BlockInfo block);
    private Expression MakeFlowJump(LabelTarget target);
    protected virtual Expression VisitGoto(GotoExpression node);
    protected virtual Expression VisitBlock(BlockExpression node);
    protected virtual LabelTarget VisitLabelTarget(LabelTarget node);
    [CompilerGeneratedAttribute]
private SwitchCase <MakeFlowControlSwitch>b__11_0(LabelTarget target);
}
public class Microsoft.Scripting.Ast.GeneratorExpression : Expression {
    private LabelTarget _target;
    private Expression _body;
    private Expression _reduced;
    private string _name;
    [CompilerGeneratedAttribute]
private Type <Type>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <RewriteAssignments>k__BackingField;
    public bool CanReduce { get; }
    public Type Type { get; }
    public ExpressionType NodeType { get; }
    public string Name { get; }
    public LabelTarget Target { get; }
    public Expression Body { get; }
    public bool RewriteAssignments { get; }
    internal bool IsEnumerable { get; }
    internal GeneratorExpression(string name, Type type, LabelTarget label, Expression body, bool rewriteAssignments);
    public virtual bool get_CanReduce();
    [CompilerGeneratedAttribute]
public sealed virtual Type get_Type();
    public sealed virtual ExpressionType get_NodeType();
    public string get_Name();
    public LabelTarget get_Target();
    public Expression get_Body();
    [CompilerGeneratedAttribute]
public bool get_RewriteAssignments();
    public virtual Expression Reduce();
    protected virtual Expression VisitChildren(ExpressionVisitor visitor);
    internal bool get_IsEnumerable();
}
internal class Microsoft.Scripting.Ast.GeneratorRewriter : DynamicExpressionVisitor {
    private static int GotoRouterYielding;
    private static int GotoRouterNone;
    internal static int NotStarted;
    internal static int Finished;
    private GeneratorExpression _generator;
    private ParameterExpression _current;
    private ParameterExpression _state;
    private Stack`1<LabelTarget> _returnLabels;
    private ParameterExpression _gotoRouter;
    private bool _inTryWithFinally;
    private List`1<YieldMarker> _yields;
    private List`1<int> _debugCookies;
    private HashSet`1<ParameterExpression> _vars;
    private List`1<ParameterExpression> _temps;
    private Dictionary`2<LabelTarget, LabelInfo> _labelTemps;
    internal GeneratorRewriter(GeneratorExpression generator);
    internal Expression Reduce();
    private YieldMarker GetYieldMarker(YieldExpression node);
    private Expression MakeAssign(ParameterExpression variable, Expression value);
    private Expression MakeAssignLabel(ParameterExpression variable, LabelExpression value);
    private Expression MakeAssignLabel(ParameterExpression variable, GotoRewriteInfo curVariable, Expression defaultValue);
    private Expression MakeAssignBlock(ParameterExpression variable, Expression value);
    private Expression MakeAssignConditional(ParameterExpression variable, Expression value);
    protected virtual Expression VisitTry(TryExpression node);
    private Expression MakeSkipFinallyBlock(LabelTarget target);
    protected virtual CatchBlock VisitCatchBlock(CatchBlock node);
    private SwitchExpression MakeYieldRouter(Type type, int start, int end, LabelTarget newTarget);
    protected virtual Expression VisitExtension(Expression node);
    private Expression VisitYield(YieldExpression node);
    protected virtual Expression VisitBlock(BlockExpression node);
    protected virtual Expression VisitLambda(Expression`1<T> node);
    protected virtual Expression VisitLabel(LabelExpression node);
    protected virtual Expression VisitGoto(GotoExpression node);
    private LabelInfo GetLabelInfo(LabelTarget label);
    private static bool IsConstant(Expression e);
    private Expression ToTemp(ReadOnlyCollectionBuilder`1<Expression> block, Expression e);
    private ReadOnlyCollection`1<Expression> ToTemp(ReadOnlyCollectionBuilder`1<Expression> block, ICollection`1<Expression> args);
    private Expression Rewrite(Expression node, ReadOnlyCollection`1<Expression> arguments, Func`2<ReadOnlyCollection`1<Expression>, Expression> factory);
    private Expression Rewrite(Expression node, Expression expr, ReadOnlyCollection`1<Expression> arguments, Func`3<Expression, ReadOnlyCollection`1<Expression>, Expression> factory);
    private Expression Rewrite(Expression node, Expression expr, Func`2<Expression, Expression> factory);
    private Expression Rewrite(Expression node, Expression expr1, Expression expr2, Func`3<Expression, Expression, Expression> factory);
    private Expression VisitAssign(BinaryExpression node);
    protected virtual Expression VisitDynamic(DynamicExpression node);
    protected virtual Expression VisitIndex(IndexExpression node);
    protected virtual Expression VisitInvocation(InvocationExpression node);
    protected virtual Expression VisitMethodCall(MethodCallExpression node);
    protected virtual Expression VisitNew(NewExpression node);
    protected virtual Expression VisitNewArray(NewArrayExpression node);
    protected virtual Expression VisitMember(MemberExpression node);
    protected virtual Expression VisitBinary(BinaryExpression node);
    protected virtual Expression VisitTypeBinary(TypeBinaryExpression node);
    protected virtual Expression VisitUnary(UnaryExpression node);
    protected virtual Expression VisitMemberInit(MemberInitExpression node);
    protected virtual Expression VisitListInit(ListInitExpression node);
}
public class Microsoft.Scripting.Ast.IfStatementBuilder : object {
    private List`1<IfStatementTest> _clauses;
    public IfStatementBuilder ElseIf(Expression test, Expression[] body);
    public IfStatementBuilder ElseIf(Expression test, Expression body);
    public Expression Else(Expression[] body);
    public Expression Else(Expression body);
    internal static Expression BuildConditions(IList`1<IfStatementTest> clauses, Expression else);
    public Expression ToStatement();
    public static Expression op_Implicit(IfStatementBuilder builder);
}
public class Microsoft.Scripting.Ast.IfStatementTest : object {
    [CompilerGeneratedAttribute]
private Expression <Test>k__BackingField;
    [CompilerGeneratedAttribute]
private Expression <Body>k__BackingField;
    public Expression Test { get; }
    public Expression Body { get; }
    internal IfStatementTest(Expression test, Expression body);
    [CompilerGeneratedAttribute]
public Expression get_Test();
    [CompilerGeneratedAttribute]
public Expression get_Body();
}
public interface Microsoft.Scripting.Ast.ILightExceptionAwareExpression {
    public abstract virtual Expression ReduceForLightExceptions();
}
public class Microsoft.Scripting.Ast.LambdaBuilder : object {
    private List`1<ParameterExpression> _locals;
    private List`1<ParameterExpression> _params;
    private List`1<KeyValuePair`2<ParameterExpression, bool>> _visibleVars;
    private string _name;
    private Type _returnType;
    private Expression _body;
    private bool _visible;
    private bool _completed;
    private static int _lambdaId;
    [CompilerGeneratedAttribute]
private ParameterExpression <ParamsArray>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <Dictionary>k__BackingField;
    public string Name { get; public set; }
    public Type ReturnType { get; public set; }
    public List`1<ParameterExpression> Locals { get; }
    public List`1<ParameterExpression> Parameters { get; }
    public ParameterExpression ParamsArray { get; private set; }
    public Expression Body { get; public set; }
    public bool Dictionary { get; public set; }
    public bool Visible { get; public set; }
    private bool EmitDictionary { get; }
    internal LambdaBuilder(string name, Type returnType);
    public string get_Name();
    public void set_Name(string value);
    public Type get_ReturnType();
    public void set_ReturnType(Type value);
    public List`1<ParameterExpression> get_Locals();
    public List`1<ParameterExpression> get_Parameters();
    [CompilerGeneratedAttribute]
public ParameterExpression get_ParamsArray();
    [CompilerGeneratedAttribute]
private void set_ParamsArray(ParameterExpression value);
    public Expression get_Body();
    public void set_Body(Expression value);
    [CompilerGeneratedAttribute]
public bool get_Dictionary();
    [CompilerGeneratedAttribute]
public void set_Dictionary(bool value);
    public bool get_Visible();
    public void set_Visible(bool value);
    public List`1<ParameterExpression> GetVisibleVariables();
    public ParameterExpression Parameter(Type type, string name);
    public ParameterExpression ClosedOverParameter(Type type, string name);
    public void AddParameters(ParameterExpression[] parameters);
    public ParameterExpression CreateHiddenParameter(string name, Type type);
    public ParameterExpression CreateParamsArray(Type type, string name);
    public Expression ClosedOverVariable(Type type, string name);
    public Expression Variable(Type type, string name);
    public ParameterExpression HiddenVariable(Type type, string name);
    public void AddHiddenVariable(ParameterExpression temp);
    public LambdaExpression MakeLambda(Type lambdaType);
    public LambdaExpression MakeLambda();
    public LambdaExpression MakeGenerator(LabelTarget label, Type lambdaType);
    private void EnsureSignature(Type delegateType);
    private void Validate();
    private bool get_EmitDictionary();
    private Expression MakeBody();
    private Expression AddDefaultReturn(Expression body);
    private static Type GetLambdaType(Type returnType, IList`1<ParameterExpression> parameterList);
}
internal class Microsoft.Scripting.Ast.LambdaParameterRewriter : ExpressionVisitor {
    private Dictionary`2<ParameterExpression, ParameterExpression> _map;
    internal LambdaParameterRewriter(Dictionary`2<ParameterExpression, ParameterExpression> map);
    protected virtual Expression VisitParameter(ParameterExpression node);
}
internal class Microsoft.Scripting.Ast.LightCheckAndThrowExpression : Expression {
    private Expression _expr;
    public bool CanReduce { get; }
    public ExpressionType NodeType { get; }
    public Type Type { get; }
    internal LightCheckAndThrowExpression(Expression instance);
    public virtual bool get_CanReduce();
    public virtual ExpressionType get_NodeType();
    public virtual Type get_Type();
    public virtual Expression Reduce();
    private sealed virtual override Expression Microsoft.Scripting.Ast.ILightExceptionAwareExpression.ReduceForLightExceptions();
    protected virtual Expression VisitChildren(ExpressionVisitor visitor);
}
public abstract class Microsoft.Scripting.Ast.LightDynamicExpression : Expression {
    private CallSiteBinder _binder;
    public bool CanReduce { get; }
    public CallSiteBinder Binder { get; }
    public ExpressionType NodeType { get; }
    public Type Type { get; }
    protected int ArgumentCount { get; }
    protected LightDynamicExpression(CallSiteBinder binder);
    public virtual bool get_CanReduce();
    public CallSiteBinder get_Binder();
    public virtual ExpressionType get_NodeType();
    public virtual Type get_Type();
    public virtual void AddInstructions(LightCompiler compiler);
    public abstract virtual Expression Reduce();
    protected abstract virtual int get_ArgumentCount();
    protected abstract virtual Expression GetArgument(int index);
    protected CallSiteBinder GetLightBinder();
}
public class Microsoft.Scripting.Ast.LightDynamicExpression1 : LightDynamicExpression {
    internal Expression _arg0;
    protected int ArgumentCount { get; }
    public Expression Argument0 { get; }
    protected internal LightDynamicExpression1(CallSiteBinder binder, Expression arg0);
    public virtual Expression Reduce();
    protected sealed virtual int get_ArgumentCount();
    public Expression get_Argument0();
    protected sealed virtual Expression GetArgument(int index);
    protected virtual Expression VisitChildren(ExpressionVisitor visitor);
    protected virtual Expression Rewrite(CallSiteBinder binder, Expression arg0);
    private sealed virtual override Expression Microsoft.Scripting.Ast.ILightExceptionAwareExpression.ReduceForLightExceptions();
}
public class Microsoft.Scripting.Ast.LightDynamicExpression2 : LightDynamicExpression {
    internal Expression _arg0;
    internal Expression _arg1;
    protected int ArgumentCount { get; }
    public Expression Argument0 { get; }
    public Expression Argument1 { get; }
    protected internal LightDynamicExpression2(CallSiteBinder binder, Expression arg0, Expression arg1);
    public virtual Expression Reduce();
    protected virtual int get_ArgumentCount();
    public Expression get_Argument0();
    public Expression get_Argument1();
    protected virtual Expression GetArgument(int index);
    protected virtual Expression VisitChildren(ExpressionVisitor visitor);
    protected virtual Expression Rewrite(CallSiteBinder binder, Expression arg0, Expression arg1);
    private sealed virtual override Expression Microsoft.Scripting.Ast.ILightExceptionAwareExpression.ReduceForLightExceptions();
}
public class Microsoft.Scripting.Ast.LightDynamicExpression3 : LightDynamicExpression {
    internal Expression _arg0;
    internal Expression _arg1;
    internal Expression _arg2;
    protected int ArgumentCount { get; }
    public Expression Argument0 { get; }
    public Expression Argument1 { get; }
    public Expression Argument2 { get; }
    protected internal LightDynamicExpression3(CallSiteBinder binder, Expression arg0, Expression arg1, Expression arg2);
    public virtual Expression Reduce();
    protected sealed virtual int get_ArgumentCount();
    public Expression get_Argument0();
    public Expression get_Argument1();
    public Expression get_Argument2();
    protected sealed virtual Expression GetArgument(int index);
    protected virtual Expression VisitChildren(ExpressionVisitor visitor);
    protected virtual Expression Rewrite(CallSiteBinder binder, Expression arg0, Expression arg1, Expression arg2);
    private sealed virtual override Expression Microsoft.Scripting.Ast.ILightExceptionAwareExpression.ReduceForLightExceptions();
}
public class Microsoft.Scripting.Ast.LightDynamicExpression4 : LightDynamicExpression {
    internal Expression _arg0;
    internal Expression _arg1;
    internal Expression _arg2;
    internal Expression _arg3;
    protected int ArgumentCount { get; }
    public Expression Argument0 { get; }
    public Expression Argument1 { get; }
    public Expression Argument2 { get; }
    public Expression Argument3 { get; }
    protected internal LightDynamicExpression4(CallSiteBinder binder, Expression arg0, Expression arg1, Expression arg2, Expression arg3);
    public virtual Expression Reduce();
    protected sealed virtual int get_ArgumentCount();
    public Expression get_Argument0();
    public Expression get_Argument1();
    public Expression get_Argument2();
    public Expression get_Argument3();
    protected sealed virtual Expression GetArgument(int index);
    protected virtual Expression VisitChildren(ExpressionVisitor visitor);
    protected virtual Expression Rewrite(CallSiteBinder binder, Expression arg0, Expression arg1, Expression arg2, Expression arg3);
    private sealed virtual override Expression Microsoft.Scripting.Ast.ILightExceptionAwareExpression.ReduceForLightExceptions();
}
internal class Microsoft.Scripting.Ast.LightExceptionConvertingExpression : Expression {
    private Expression _expr;
    private bool _supportsLightEx;
    public bool CanReduce { get; }
    public ExpressionType NodeType { get; }
    public Type Type { get; }
    internal LightExceptionConvertingExpression(Expression expr, bool supportsLightEx);
    public virtual bool get_CanReduce();
    public virtual ExpressionType get_NodeType();
    public virtual Type get_Type();
    public virtual Expression Reduce();
    private sealed virtual override Expression Microsoft.Scripting.Ast.ILightExceptionAwareExpression.ReduceForLightExceptions();
    protected virtual Expression VisitChildren(ExpressionVisitor visitor);
}
internal class Microsoft.Scripting.Ast.LightExceptionRewriter : DynamicExpressionVisitor {
    private LabelTarget _currentHandler;
    private ParameterExpression _rethrow;
    private static ParameterExpression _lastValue;
    private static ReadOnlyCollection`1<ParameterExpression> _lastValueParamArray;
    private static Expression _isLightExExpr;
    private static Expression _lastException;
    private LabelTarget _returnLabel;
    private static LightExceptionRewriter();
    internal Expression Rewrite(Expression expr);
    protected virtual Expression VisitLambda(Expression`1<T> node);
    protected virtual Expression VisitExtension(Expression node);
    protected virtual Expression VisitDynamic(DynamicExpression node);
    protected virtual Expression VisitTry(TryExpression node);
    private Expression RewriteTryFinally(Expression tryBody, Expression finallyBody);
    private static string GetEhLabelName(string baseName);
    protected virtual Expression VisitUnary(UnaryExpression node);
    private Expression RewriteTryBody(TryExpression node, LabelTarget ehLabel);
    private CatchBlock[] VisitHandlers(TryExpression node, bool realCatch);
    private Expression TrackCatch(Expression expression, Expression exception, bool realCatch);
    private Expression RewriteTryCatch(TryExpression node);
    private Expression LightCatch(CatchBlock[] handlers);
    private Expression CheckExpression(Expression expr, Type retType);
    private Expression PropagateException(Type retType);
}
public class Microsoft.Scripting.Ast.LightExpression`1 : LightLambdaExpression {
    public Type Type { get; }
    internal LightExpression`1(Type retType, Expression body, string name, IList`1<ParameterExpression> args);
    public Expression`1<T> ReduceToLambda();
    public virtual Type get_Type();
    public T Compile();
    public T Compile(int compilationThreshold);
    internal virtual LambdaExpression ReduceToLambdaWorker();
}
public class Microsoft.Scripting.Ast.LightLambdaExpression : Expression {
    [CompilerGeneratedAttribute]
private Expression <Body>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    [CompilerGeneratedAttribute]
private IList`1<ParameterExpression> <Parameters>k__BackingField;
    [CompilerGeneratedAttribute]
private Type <ReturnType>k__BackingField;
    public Expression Body { get; }
    public string Name { get; }
    public IList`1<ParameterExpression> Parameters { get; }
    public ExpressionType NodeType { get; }
    public bool CanReduce { get; }
    public Type ReturnType { get; }
    internal LightLambdaExpression(Type retType, Expression body, string name, IList`1<ParameterExpression> args);
    [CompilerGeneratedAttribute]
public Expression get_Body();
    [CompilerGeneratedAttribute]
public string get_Name();
    [CompilerGeneratedAttribute]
public IList`1<ParameterExpression> get_Parameters();
    internal virtual LambdaExpression ReduceToLambdaWorker();
    public Delegate Compile();
    public Delegate Compile(int compilationThreshold);
    public virtual ExpressionType get_NodeType();
    public virtual bool get_CanReduce();
    public virtual Expression Reduce();
    [CompilerGeneratedAttribute]
public Type get_ReturnType();
}
internal class Microsoft.Scripting.Ast.LightThrowExpression : Expression {
    private Expression _exception;
    private static MethodInfo _throw;
    public bool CanReduce { get; }
    public ExpressionType NodeType { get; }
    public Type Type { get; }
    public LightThrowExpression(Expression exception);
    private static LightThrowExpression();
    public virtual Expression Reduce();
    protected virtual Expression VisitChildren(ExpressionVisitor visitor);
    public virtual bool get_CanReduce();
    public virtual ExpressionType get_NodeType();
    public virtual Type get_Type();
}
public class Microsoft.Scripting.Ast.LightTypedDynamicExpression1 : LightDynamicExpression1 {
    private Type _returnType;
    public Type Type { get; }
    protected internal LightTypedDynamicExpression1(CallSiteBinder binder, Type returnType, Expression arg0);
    public sealed virtual Type get_Type();
    protected virtual Expression Rewrite(CallSiteBinder binder, Expression arg0);
    private sealed virtual override Expression Microsoft.Scripting.Ast.ILightExceptionAwareExpression.ReduceForLightExceptions();
}
public class Microsoft.Scripting.Ast.LightTypedDynamicExpression2 : LightDynamicExpression2 {
    private Type _returnType;
    public Type Type { get; }
    protected internal LightTypedDynamicExpression2(CallSiteBinder binder, Type returnType, Expression arg0, Expression arg1);
    public sealed virtual Type get_Type();
    protected virtual Expression Rewrite(CallSiteBinder binder, Expression arg0, Expression arg1);
    private sealed virtual override Expression Microsoft.Scripting.Ast.ILightExceptionAwareExpression.ReduceForLightExceptions();
}
internal class Microsoft.Scripting.Ast.LightTypedDynamicExpression3 : LightDynamicExpression3 {
    private Type _returnType;
    public Type Type { get; }
    protected internal LightTypedDynamicExpression3(CallSiteBinder binder, Type returnType, Expression arg0, Expression arg1, Expression arg2);
    public sealed virtual Type get_Type();
    protected virtual Expression Rewrite(CallSiteBinder binder, Expression arg0, Expression arg1, Expression arg2);
    private sealed virtual override Expression Microsoft.Scripting.Ast.ILightExceptionAwareExpression.ReduceForLightExceptions();
}
public class Microsoft.Scripting.Ast.LightTypedDynamicExpression4 : LightDynamicExpression4 {
    private Type _returnType;
    public Type Type { get; }
    internal LightTypedDynamicExpression4(CallSiteBinder binder, Type returnType, Expression arg0, Expression arg1, Expression arg2, Expression arg3);
    protected virtual Expression Rewrite(CallSiteBinder binder, Expression arg0, Expression arg1, Expression arg2, Expression arg3);
    public sealed virtual Type get_Type();
    private sealed virtual override Expression Microsoft.Scripting.Ast.ILightExceptionAwareExpression.ReduceForLightExceptions();
}
public class Microsoft.Scripting.Ast.LightTypedDynamicExpressionN : LightDynamicExpression {
    private IList`1<Expression> _args;
    private Type _returnType;
    protected int ArgumentCount { get; }
    public Type Type { get; }
    public IList`1<Expression> Arguments { get; }
    protected internal LightTypedDynamicExpressionN(CallSiteBinder binder, Type returnType, IList`1<Expression> args);
    public virtual Expression Reduce();
    protected sealed virtual int get_ArgumentCount();
    public sealed virtual Type get_Type();
    public IList`1<Expression> get_Arguments();
    protected virtual Expression Rewrite(CallSiteBinder binder, IList`1<Expression> args);
    protected virtual Expression VisitChildren(ExpressionVisitor visitor);
    protected sealed virtual Expression GetArgument(int index);
    private sealed virtual override Expression Microsoft.Scripting.Ast.ILightExceptionAwareExpression.ReduceForLightExceptions();
}
public class Microsoft.Scripting.Ast.TryStatementBuilder : object {
    private List`1<CatchBlock> _catchBlocks;
    private Expression _try;
    private Expression _finally;
    private Expression _fault;
    private bool _enableJumpsFromFinally;
    internal TryStatementBuilder(Expression body);
    public TryStatementBuilder Catch(Type type, Expression body);
    public TryStatementBuilder Catch(Type type, Expression expr0, Expression expr1);
    public TryStatementBuilder Catch(Type type, Expression expr0, Expression expr1, Expression expr2);
    public TryStatementBuilder Catch(Type type, Expression expr0, Expression expr1, Expression expr2, Expression expr3);
    public TryStatementBuilder Catch(Type type, Expression[] body);
    public TryStatementBuilder Catch(ParameterExpression holder, Expression expr0, Expression expr1);
    public TryStatementBuilder Catch(ParameterExpression holder, Expression expr0, Expression expr1, Expression expr2);
    public TryStatementBuilder Catch(ParameterExpression holder, Expression expr0, Expression expr1, Expression expr2, Expression expr3);
    public TryStatementBuilder Catch(ParameterExpression holder, Expression[] body);
    public TryStatementBuilder Catch(ParameterExpression holder, Expression body);
    public TryStatementBuilder Filter(Type type, Expression condition, Expression[] body);
    public TryStatementBuilder Filter(Type type, Expression condition, Expression body);
    public TryStatementBuilder Filter(ParameterExpression holder, Expression condition, Expression[] body);
    public TryStatementBuilder Filter(ParameterExpression holder, Expression condition, Expression body);
    public TryStatementBuilder Finally(Expression[] body);
    public TryStatementBuilder Finally(Expression body);
    public TryStatementBuilder FinallyWithJumps(Expression[] body);
    public TryStatementBuilder FinallyWithJumps(Expression body);
    public TryStatementBuilder Fault(Expression[] body);
    public static Expression op_Implicit(TryStatementBuilder builder);
    public Expression ToExpression();
}
internal class Microsoft.Scripting.Ast.TypedLightLambdaExpression : LightLambdaExpression {
    private Type _delegateType;
    public Type Type { get; }
    internal TypedLightLambdaExpression(Type retType, Type delegateType, Expression body, string name, IList`1<ParameterExpression> args);
    internal virtual LambdaExpression ReduceToLambdaWorker();
    public virtual Type get_Type();
}
[ExtensionAttribute]
public static class Microsoft.Scripting.Ast.Utils : object {
    private static ConstantExpression TrueLiteral;
    private static ConstantExpression FalseLiteral;
    private static ConstantExpression NullLiteral;
    private static ConstantExpression EmptyStringLiteral;
    private static ConstantExpression[] IntCache;
    private static DefaultExpression VoidInstance;
    private static Utils();
    public static Expression Coalesce(Expression left, Expression right, ParameterExpression& temp);
    public static Expression CoalesceTrue(Expression left, Expression right, MethodInfo isTrue, ParameterExpression& temp);
    public static Expression CoalesceFalse(Expression left, Expression right, MethodInfo isTrue, ParameterExpression& temp);
    private static Expression CoalesceInternal(Expression left, Expression right, MethodInfo isTrue, bool isReverse, ParameterExpression& temp);
    public static Expression Coalesce(LambdaBuilder builder, Expression left, Expression right);
    public static Expression CoalesceTrue(LambdaBuilder builder, Expression left, Expression right, MethodInfo isTrue);
    public static Expression CoalesceFalse(LambdaBuilder builder, Expression left, Expression right, MethodInfo isTrue);
    [ExtensionAttribute]
public static BinaryExpression Update(BinaryExpression expression, Expression left, Expression right);
    internal static Expression AddScopedVariable(Expression body, ParameterExpression variable, Expression variableInit);
    internal static BlockExpression BlockVoid(Expression[] expressions);
    internal static BlockExpression Block(Expression[] expressions);
    public static MemberExpression WeakConstant(object value);
    public static ConstantExpression Constant(object value, Type type);
    public static Expression Constant(object value);
    private static Expression BigIntegerConstant(BigInteger value);
    private static Expression CreateArray(T[] array);
    private static Expression ComplexConstant(Complex value);
    public static Expression DebugMarker(string marker);
    public static Expression DebugMark(Expression expression, string marker);
    public static Expression AddDebugInfo(Expression expression, SymbolDocumentInfo document, SourceLocation start, SourceLocation end);
    public static Expression AddDebugInfo(Expression expression, SymbolDocumentInfo document, int startLine, int startColumn, int endLine, int endColumn);
    public static DefaultExpression Empty();
    public static DefaultExpression Default(Type type);
    public static Expression FinallyFlowControl(Expression body);
    public static GeneratorExpression Generator(LabelTarget label, Expression body);
    public static GeneratorExpression Generator(LabelTarget label, Expression body, Type type);
    public static GeneratorExpression Generator(string name, LabelTarget label, Expression body, Type type);
    public static GeneratorExpression Generator(string name, LabelTarget label, Expression body, Type type, bool rewriteAssignments);
    private static ArgumentException GeneratorTypeMustBeEnumerableOfT(Type type);
    internal static bool IsEnumerableType(Type type);
    public static Expression`1<T> GeneratorLambda(LabelTarget label, Expression body, ParameterExpression[] parameters);
    public static Expression`1<T> GeneratorLambda(LabelTarget label, Expression body, string name, ParameterExpression[] parameters);
    public static Expression`1<T> GeneratorLambda(LabelTarget label, Expression body, string name, IEnumerable`1<ParameterExpression> parameters);
    public static LambdaExpression GeneratorLambda(Type delegateType, LabelTarget label, Expression body, ParameterExpression[] parameters);
    public static LambdaExpression GeneratorLambda(Type delegateType, LabelTarget label, Expression body, string name, ParameterExpression[] parameters);
    public static LambdaExpression GeneratorLambda(Type delegateType, LabelTarget label, Expression body, string name, IEnumerable`1<ParameterExpression> parameters);
    public static LambdaExpression GeneratorLambda(Type delegateType, LabelTarget label, Expression body, string name, bool rewriteAssignments, IEnumerable`1<ParameterExpression> parameters);
    private static Expression TransformEnumerable(Expression body, ReadOnlyCollection`1<ParameterExpression> paramList);
    public static IfStatementBuilder If();
    public static IfStatementBuilder If(Expression test, Expression[] body);
    public static IfStatementBuilder If(Expression test, Expression body);
    public static Expression If(IfStatementTest[] tests, Expression else);
    public static Expression IfThen(Expression test, Expression body);
    public static Expression IfThen(Expression test, Expression[] body);
    public static Expression IfThenElse(Expression test, Expression body, Expression else);
    public static Expression Unless(Expression test, Expression body);
    public static IfStatementTest IfCondition(Expression test, Expression body);
    public static LambdaBuilder Lambda(Type returnType, string name);
    public static LightDynamicExpression LightDynamic(CallSiteBinder binder, Expression arg0);
    public static LightDynamicExpression LightDynamic(CallSiteBinder binder, Type returnType, Expression arg0);
    public static LightDynamicExpression LightDynamic(CallSiteBinder binder, Expression arg0, Expression arg1);
    public static LightDynamicExpression LightDynamic(CallSiteBinder binder, Type returnType, Expression arg0, Expression arg1);
    public static LightDynamicExpression LightDynamic(CallSiteBinder binder, Expression arg0, Expression arg1, Expression arg2);
    public static LightDynamicExpression LightDynamic(CallSiteBinder binder, Type returnType, Expression arg0, Expression arg1, Expression arg2);
    public static LightDynamicExpression LightDynamic(CallSiteBinder binder, Expression arg0, Expression arg1, Expression arg2, Expression arg3);
    public static LightDynamicExpression LightDynamic(CallSiteBinder binder, Type returnType, Expression arg0, Expression arg1, Expression arg2, Expression arg3);
    public static LightDynamicExpression LightDynamic(CallSiteBinder binder, IList`1<Expression> arguments);
    public static LightDynamicExpression LightDynamic(CallSiteBinder binder, Type returnType, IList`1<Expression> arguments);
    public static LightDynamicExpression LightDynamic(CallSiteBinder binder, ExpressionCollectionBuilder`1<Expression> arguments);
    public static LightDynamicExpression LightDynamic(CallSiteBinder binder, Type returnType, ExpressionCollectionBuilder`1<Expression> arguments);
    public static LightExpression`1<T> LightLambda(Type retType, Expression body, string name, IList`1<ParameterExpression> args);
    public static LightLambdaExpression LightLambda(Type retType, Type delegateType, Expression body, string name, IList`1<ParameterExpression> args);
    public static LoopExpression While(Expression test, Expression body, Expression else);
    public static LoopExpression While(Expression test, Expression body, Expression else, LabelTarget break, LabelTarget continue);
    public static LoopExpression Infinite(Expression body);
    public static LoopExpression Infinite(Expression body, LabelTarget break, LabelTarget continue);
    public static LoopExpression Loop(Expression test, Expression increment, Expression body, Expression else);
    public static LoopExpression Loop(Expression test, Expression increment, Expression body, Expression else, LabelTarget break, LabelTarget continue);
    public static MethodCallExpression SimpleCallHelper(MethodInfo method, Expression[] arguments);
    public static MethodCallExpression SimpleCallHelper(Expression instance, MethodInfo method, Expression[] arguments);
    private static Expression[] ArgumentConvertHelper(Expression[] arguments, ParameterInfo[] parameters);
    private static Expression ArgumentConvertHelper(Expression argument, Type type);
    private static bool CompatibleParameterTypes(Type parameter, Type argument);
    public static Expression ComplexCallHelper(MethodInfo method, Expression[] arguments);
    public static Expression ComplexCallHelper(Expression instance, MethodInfo method, Expression[] arguments);
    private static Expression CreateDefaultValueExpression(ParameterInfo parameter);
    public static NewArrayExpression NewArrayHelper(Type type, IEnumerable`1<Expression> initializers);
    public static NewExpression SimpleNewHelper(ConstructorInfo constructor, Expression[] arguments);
    public static TryStatementBuilder Try(Expression body);
    public static TryStatementBuilder Try(Expression expr0, Expression expr1);
    public static TryStatementBuilder Try(Expression expr0, Expression expr1, Expression expr2);
    public static TryStatementBuilder Try(Expression expr0, Expression expr1, Expression expr2, Expression expr3);
    public static TryStatementBuilder Try(Expression[] body);
    public static Expression Void(Expression expression);
    public static Expression Convert(Expression expression, Type type);
    public static Expression Box(Expression expression);
    [ExtensionAttribute]
public static bool IsAssignment(ExpressionType type);
    [ExtensionAttribute]
public static bool IsWriteOnlyAssignment(ExpressionType type);
    [ExtensionAttribute]
public static bool IsReadWriteAssignment(ExpressionType type);
    [ExtensionAttribute]
public static ExpressionAccess GetLValueAccess(ExpressionType type);
    [ExtensionAttribute]
public static bool IsLValue(ExpressionType type);
    public static YieldExpression YieldBreak(LabelTarget target);
    public static YieldExpression YieldReturn(LabelTarget target, Expression value);
    public static YieldExpression YieldReturn(LabelTarget target, Expression value, int yieldMarker);
    public static YieldExpression MakeYield(LabelTarget target, Expression value, int yieldMarker);
}
public class Microsoft.Scripting.Ast.YieldExpression : Expression {
    private Expression _value;
    [CompilerGeneratedAttribute]
private LabelTarget <Target>k__BackingField;
    [CompilerGeneratedAttribute]
private int <YieldMarker>k__BackingField;
    public bool CanReduce { get; }
    public Type Type { get; }
    public ExpressionType NodeType { get; }
    public Expression Value { get; }
    public LabelTarget Target { get; }
    public int YieldMarker { get; }
    internal YieldExpression(LabelTarget target, Expression value, int yieldMarker);
    public virtual bool get_CanReduce();
    public sealed virtual Type get_Type();
    public sealed virtual ExpressionType get_NodeType();
    public Expression get_Value();
    [CompilerGeneratedAttribute]
public LabelTarget get_Target();
    [CompilerGeneratedAttribute]
public int get_YieldMarker();
    protected virtual Expression VisitChildren(ExpressionVisitor visitor);
}
internal abstract class Microsoft.Scripting.ComInterop.ArgBuilder : object {
    internal abstract virtual Expression Marshal(Expression parameter);
    internal virtual Expression MarshalToRef(Expression parameter);
    internal virtual Expression UnmarshalFromRef(Expression newValue);
}
internal class Microsoft.Scripting.ComInterop.BoolArgBuilder : SimpleArgBuilder {
    internal BoolArgBuilder(Type parameterType);
    internal virtual Expression MarshalToRef(Expression parameter);
    internal virtual Expression UnmarshalFromRef(Expression value);
}
internal class Microsoft.Scripting.ComInterop.BoundDispEvent : DynamicObject {
    private object _rcw;
    private Guid _sourceIid;
    private int _dispid;
    internal BoundDispEvent(object rcw, Guid sourceIid, int dispid);
    public virtual bool TryBinaryOperation(BinaryOperationBinder binder, object handler, Object& result);
    private static void VerifyHandler(object handler);
    private object InPlaceAdd(object handler);
    private object InPlaceSubtract(object handler);
}
[ExtensionAttribute]
internal static class Microsoft.Scripting.ComInterop.CollectionExtensions : object {
    [ExtensionAttribute]
internal static T[] RemoveFirst(T[] array);
    [ExtensionAttribute]
internal static T[] AddFirst(IList`1<T> list, T item);
    [ExtensionAttribute]
internal static T[] ToArray(IList`1<T> list);
    [ExtensionAttribute]
internal static T[] AddLast(IList`1<T> list, T item);
}
public static class Microsoft.Scripting.ComInterop.ComBinder : object {
    public static bool IsComObject(object value);
    public static bool CanComBind(object value);
    public static bool TryBindGetMember(GetMemberBinder binder, DynamicMetaObject instance, DynamicMetaObject& result, bool delayInvocation);
    public static bool TryBindGetMember(GetMemberBinder binder, DynamicMetaObject instance, DynamicMetaObject& result);
    public static bool TryBindSetMember(SetMemberBinder binder, DynamicMetaObject instance, DynamicMetaObject value, DynamicMetaObject& result);
    public static bool TryBindInvoke(InvokeBinder binder, DynamicMetaObject instance, DynamicMetaObject[] args, DynamicMetaObject& result);
    public static bool TryBindInvokeMember(InvokeMemberBinder binder, DynamicMetaObject instance, DynamicMetaObject[] args, DynamicMetaObject& result);
    public static bool TryBindGetIndex(GetIndexBinder binder, DynamicMetaObject instance, DynamicMetaObject[] args, DynamicMetaObject& result);
    public static bool TryBindSetIndex(SetIndexBinder binder, DynamicMetaObject instance, DynamicMetaObject[] args, DynamicMetaObject value, DynamicMetaObject& result);
    public static bool TryConvert(ConvertBinder binder, DynamicMetaObject instance, DynamicMetaObject& result);
    public static IEnumerable`1<string> GetDynamicMemberNames(object value);
    internal static IList`1<string> GetDynamicDataMemberNames(object value);
    internal static IList`1<KeyValuePair`2<string, object>> GetDynamicDataMembers(object value, IEnumerable`1<string> names);
    private static bool TryGetMetaObject(DynamicMetaObject& instance);
    private static bool TryGetMetaObjectInvoke(DynamicMetaObject& instance);
}
internal static class Microsoft.Scripting.ComInterop.ComBinderHelpers : object {
    internal static bool PreferPut(Type type, bool holdsNull);
    internal static bool IsByRef(DynamicMetaObject mo);
    internal static bool IsStrongBoxArg(DynamicMetaObject o);
    internal static Boolean[] ProcessArgumentsForCom(DynamicMetaObject[]& args);
    internal static BindingRestrictions GetTypeRestrictionForDynamicMetaObject(DynamicMetaObject obj);
}
internal class Microsoft.Scripting.ComInterop.ComClassMetaObject : DynamicMetaObject {
    internal ComClassMetaObject(Expression expression, ComTypeClassDesc cls);
    public virtual DynamicMetaObject BindCreateInstance(CreateInstanceBinder binder, DynamicMetaObject[] args);
}
internal static class Microsoft.Scripting.ComInterop.ComDispIds : object {
    internal static int DISPID_VALUE;
    internal static int DISPID_PROPERTYPUT;
    internal static int DISPID_NEWENUM;
}
internal class Microsoft.Scripting.ComInterop.ComEventDesc : object {
    internal Guid sourceIID;
    internal int dispid;
}
internal class Microsoft.Scripting.ComInterop.ComEventSink : object {
    private Guid _iidSourceItf;
    private IConnectionPoint _connectionPoint;
    private int _cookie;
    private ComEventsMethod _methods;
    private static VarEnum VT_BYREF_VARIANT;
    private static VarEnum VT_TYPEMASK;
    private static VarEnum VT_BYREF_TYPEMASK;
    public ComEventSink(object rcw, Guid iid);
    private void Initialize(object rcw, Guid iid);
    public static ComEventSink FromRuntimeCallableWrapper(object rcw, Guid sourceIid, bool createIfNotFound);
    public ComEventsMethod RemoveMethod(ComEventsMethod method);
    public ComEventsMethod FindMethod(int dispid);
    public ComEventsMethod AddMethod(int dispid);
    public void AddHandler(int dispid, object func);
    public void RemoveHandler(int dispid, object func);
    private sealed virtual override int Microsoft.Scripting.ComInterop.IDispatch.TryGetTypeInfoCount(UInt32& pctinfo);
    private sealed virtual override int Microsoft.Scripting.ComInterop.IDispatch.TryGetTypeInfo(UInt32 iTInfo, int lcid, IntPtr& info);
    private sealed virtual override int Microsoft.Scripting.ComInterop.IDispatch.TryGetIDsOfNames(Guid& iid, String[] names, UInt32 cNames, int lcid, Int32[] rgDispId);
    private static Variant& GetVariant(Variant& pSrc);
    private sealed virtual override int Microsoft.Scripting.ComInterop.IDispatch.TryInvoke(int dispIdMember, Guid& riid, int lcid, INVOKEKIND wFlags, DISPPARAMS& pDispParams, IntPtr VarResult, IntPtr pExcepInfo, IntPtr puArgErr);
    private sealed virtual override CustomQueryInterfaceResult System.Runtime.InteropServices.ICustomQueryInterface.GetInterface(Guid& iid, IntPtr& ppv);
    private void Advise(object rcw);
    public sealed virtual void Dispose();
}
internal class Microsoft.Scripting.ComInterop.ComEventSinksContainer : List`1<ComEventSink> {
    private static object _ComObjectEventSinksKey;
    private static ComEventSinksContainer();
    public static ComEventSinksContainer FromRuntimeCallableWrapper(object rcw, bool createIfNotFound);
    public sealed virtual void Dispose();
    private void DisposeAll();
    protected virtual override void Finalize();
}
internal class Microsoft.Scripting.ComInterop.ComEventsMethod : object {
    private Func`2<Object[], object> _delegate;
    private object lockObject;
    private int _dispid;
    private ComEventsMethod _next;
    public bool Empty { get; }
    public ComEventsMethod(int dispid);
    public static ComEventsMethod Find(ComEventsMethod methods, int dispid);
    public static ComEventsMethod Add(ComEventsMethod methods, ComEventsMethod method);
    public static ComEventsMethod Remove(ComEventsMethod methods, ComEventsMethod method);
    public bool get_Empty();
    public void AddDelegate(Func`2<Object[], object> d);
    internal void RemoveDelegates(Func`2<Func`2<Object[], object>, bool> condition);
    public object Invoke(Object[] args);
}
internal class Microsoft.Scripting.ComInterop.ComFallbackMetaObject : DynamicMetaObject {
    internal ComFallbackMetaObject(Expression expression, BindingRestrictions restrictions, object arg);
    public virtual DynamicMetaObject BindGetIndex(GetIndexBinder binder, DynamicMetaObject[] indexes);
    public virtual DynamicMetaObject BindSetIndex(SetIndexBinder binder, DynamicMetaObject[] indexes, DynamicMetaObject value);
    public virtual DynamicMetaObject BindGetMember(GetMemberBinder binder);
    public virtual DynamicMetaObject BindInvokeMember(InvokeMemberBinder binder, DynamicMetaObject[] args);
    public virtual DynamicMetaObject BindSetMember(SetMemberBinder binder, DynamicMetaObject value);
    protected virtual ComUnwrappedMetaObject UnwrapSelf();
}
internal static class Microsoft.Scripting.ComInterop.ComHresults : object {
    internal static int S_OK;
    internal static int CONNECT_E_NOCONNECTION;
    internal static int DISP_E_UNKNOWNINTERFACE;
    internal static int DISP_E_MEMBERNOTFOUND;
    internal static int DISP_E_PARAMNOTFOUND;
    internal static int DISP_E_TYPEMISMATCH;
    internal static int DISP_E_UNKNOWNNAME;
    internal static int DISP_E_NONAMEDARGS;
    internal static int DISP_E_BADVARTYPE;
    internal static int DISP_E_EXCEPTION;
    internal static int DISP_E_OVERFLOW;
    internal static int DISP_E_BADINDEX;
    internal static int DISP_E_UNKNOWNLCID;
    internal static int DISP_E_ARRAYISLOCKED;
    internal static int DISP_E_BADPARAMCOUNT;
    internal static int DISP_E_PARAMNOTOPTIONAL;
    internal static int E_NOINTERFACE;
    internal static int E_FAIL;
    internal static int E_NOTIMPL;
    internal static int TYPE_E_LIBNOTREGISTERED;
    internal static bool IsSuccess(int hresult);
}
internal class Microsoft.Scripting.ComInterop.ComInvokeAction : InvokeBinder {
    internal ComInvokeAction(CallInfo callInfo);
    public virtual int GetHashCode();
    public virtual bool Equals(object obj);
    public virtual DynamicMetaObject FallbackInvoke(DynamicMetaObject target, DynamicMetaObject[] args, DynamicMetaObject errorSuggestion);
}
internal class Microsoft.Scripting.ComInterop.ComInvokeBinder : object {
    private ComMethodDesc _methodDesc;
    private Expression _method;
    private Expression _dispatch;
    private CallInfo _callInfo;
    private DynamicMetaObject[] _args;
    private Boolean[] _isByRef;
    private Expression _instance;
    private BindingRestrictions _restrictions;
    private VarEnumSelector _varEnumSelector;
    private String[] _keywordArgNames;
    private int _totalExplicitArgs;
    private ParameterExpression _dispatchObject;
    private ParameterExpression _dispatchPointer;
    private ParameterExpression _dispId;
    private ParameterExpression _dispParams;
    private ParameterExpression _paramVariants;
    private ParameterExpression _invokeResult;
    private ParameterExpression _returnValue;
    private ParameterExpression _dispIdsOfKeywordArgsPinned;
    private ParameterExpression _propertyPutDispId;
    private ParameterExpression DispatchObjectVariable { get; }
    private ParameterExpression DispatchPointerVariable { get; }
    private ParameterExpression DispIdVariable { get; }
    private ParameterExpression DispParamsVariable { get; }
    private ParameterExpression InvokeResultVariable { get; }
    private ParameterExpression ReturnValueVariable { get; }
    private ParameterExpression DispIdsOfKeywordArgsPinnedVariable { get; }
    private ParameterExpression PropertyPutDispIdVariable { get; }
    private ParameterExpression ParamVariantsVariable { get; }
    internal ComInvokeBinder(CallInfo callInfo, DynamicMetaObject[] args, Boolean[] isByRef, BindingRestrictions restrictions, Expression method, Expression dispatch, ComMethodDesc methodDesc);
    private ParameterExpression get_DispatchObjectVariable();
    private ParameterExpression get_DispatchPointerVariable();
    private ParameterExpression get_DispIdVariable();
    private ParameterExpression get_DispParamsVariable();
    private ParameterExpression get_InvokeResultVariable();
    private ParameterExpression get_ReturnValueVariable();
    private ParameterExpression get_DispIdsOfKeywordArgsPinnedVariable();
    private ParameterExpression get_PropertyPutDispIdVariable();
    private ParameterExpression get_ParamVariantsVariable();
    private static ParameterExpression EnsureVariable(ParameterExpression& var, Type type, string name);
    private static Type MarshalType(DynamicMetaObject mo, bool isByRef);
    internal DynamicMetaObject Invoke();
    private static void AddNotNull(List`1<ParameterExpression> list, ParameterExpression var);
    private Expression CreateScope(Expression expression);
    private Expression GenerateTryBlock();
    private Expression GenerateFinallyBlock();
    private Expression MakeIDispatchInvokeTarget();
    private Expression[] MakeArgumentExpressions();
}
internal class Microsoft.Scripting.ComInterop.ComMetaObject : DynamicMetaObject {
    internal ComMetaObject(Expression expression, BindingRestrictions restrictions, object arg);
    public virtual DynamicMetaObject BindInvokeMember(InvokeMemberBinder binder, DynamicMetaObject[] args);
    public virtual DynamicMetaObject BindInvoke(InvokeBinder binder, DynamicMetaObject[] args);
    public virtual DynamicMetaObject BindGetMember(GetMemberBinder binder);
    public virtual DynamicMetaObject BindSetMember(SetMemberBinder binder, DynamicMetaObject value);
    public virtual DynamicMetaObject BindGetIndex(GetIndexBinder binder, DynamicMetaObject[] indexes);
    public virtual DynamicMetaObject BindSetIndex(SetIndexBinder binder, DynamicMetaObject[] indexes, DynamicMetaObject value);
    private DynamicMetaObject WrapSelf();
}
public class Microsoft.Scripting.ComInterop.ComMethodDesc : object {
    private int _memid;
    private string _name;
    internal INVOKEKIND InvokeKind;
    private int _paramCnt;
    public string Name { get; }
    public int DispId { get; }
    public bool IsPropertyGet { get; }
    public bool IsDataMember { get; }
    public bool IsPropertyPut { get; }
    public bool IsPropertyPutRef { get; }
    internal int ParamCount { get; }
    private ComMethodDesc(int dispId);
    internal ComMethodDesc(string name, int dispId);
    internal ComMethodDesc(string name, int dispId, INVOKEKIND invkind);
    internal ComMethodDesc(ITypeInfo typeInfo, FUNCDESC funcDesc);
    public string get_Name();
    public int get_DispId();
    public bool get_IsPropertyGet();
    public bool get_IsDataMember();
    public bool get_IsPropertyPut();
    public bool get_IsPropertyPutRef();
    internal int get_ParamCount();
}
internal class Microsoft.Scripting.ComInterop.ComObject : object {
    [CompilerGeneratedAttribute]
private object <RuntimeCallableWrapper>k__BackingField;
    private static object _ComObjectInfoKey;
    internal object RuntimeCallableWrapper { get; }
    internal ComObject(object rcw);
    private static ComObject();
    [CompilerGeneratedAttribute]
internal object get_RuntimeCallableWrapper();
    public static ComObject ObjectToComObject(object rcw);
    internal static MemberExpression RcwFromComObject(Expression comObject);
    internal static MethodCallExpression RcwToComObject(Expression rcw);
    private static ComObject CreateComObject(object rcw);
    internal virtual IList`1<string> GetMemberNames(bool dataOnly);
    internal virtual IList`1<KeyValuePair`2<string, object>> GetMembers(IEnumerable`1<string> names);
    private sealed virtual override DynamicMetaObject System.Dynamic.IDynamicMetaObjectProvider.GetMetaObject(Expression parameter);
}
public class Microsoft.Scripting.ComInterop.ComParamDesc : object {
    private bool _isOut;
    private bool _isOpt;
    private bool _byRef;
    private bool _isArray;
    private VarEnum _vt;
    private string _name;
    private Type _type;
    private object _defaultValue;
    public bool IsOut { get; }
    public bool IsOptional { get; }
    public bool ByReference { get; }
    public bool IsArray { get; }
    public Type ParameterType { get; }
    internal object DefaultValue { get; }
    internal ComParamDesc(ELEMDESC& elemDesc, string name);
    internal ComParamDesc(ELEMDESC& elemDesc);
    private static Type GetTypeForVarEnum(VarEnum vt);
    public virtual string ToString();
    public bool get_IsOut();
    public bool get_IsOptional();
    public bool get_ByReference();
    public bool get_IsArray();
    public Type get_ParameterType();
    internal object get_DefaultValue();
}
internal static class Microsoft.Scripting.ComInterop.ComRuntimeHelpers : object {
    public static void CheckThrowException(int hresult, ExcepInfo& excepInfo, UInt32 argErr, string message);
    internal static void GetInfoFromType(ITypeInfo typeInfo, String& name, String& documentation);
    internal static string GetNameOfMethod(ITypeInfo typeInfo, int memid);
    internal static string GetNameOfLib(ITypeLib typeLib);
    internal static string GetNameOfType(ITypeInfo typeInfo);
    internal static ITypeInfo GetITypeInfoFromIDispatch(IDispatch dispatch, bool throwIfMissingExpectedTypeInfo);
    private static void CheckIfMissingTypeInfoIsExpected(int hresult, bool throwIfMissingExpectedTypeInfo);
    internal static TYPEATTR GetTypeAttrForTypeInfo(ITypeInfo typeInfo);
    internal static TYPELIBATTR GetTypeAttrForTypeLib(ITypeLib typeLib);
    public static BoundDispEvent CreateComEvent(object rcw, Guid sourceIid, int dispid);
    public static DispCallable CreateDispCallable(IDispatchComObject dispatch, ComMethodDesc method);
    internal static MethodInfo GetGetIDispatchForObjectMethod();
}
public enum Microsoft.Scripting.ComInterop.ComType : Enum {
    public int value__;
    public static ComType Class;
    public static ComType Enum;
    public static ComType Interface;
}
public class Microsoft.Scripting.ComInterop.ComTypeClassDesc : ComTypeDesc {
    private LinkedList`1<string> _itfs;
    private LinkedList`1<string> _sourceItfs;
    private Type _typeObj;
    internal ComTypeClassDesc(ITypeInfo typeInfo, ComTypeLibDesc typeLibDesc);
    public object CreateInstance();
    private void AddInterface(ITypeInfo itfTypeInfo, bool isSourceItf);
    internal bool Implements(string itfName, bool isSourceItf);
    public sealed virtual DynamicMetaObject GetMetaObject(Expression parameter);
}
public class Microsoft.Scripting.ComInterop.ComTypeDesc : ComTypeLibMemberDesc {
    private string _typeName;
    private string _documentation;
    private Hashtable _funcs;
    private Hashtable _puts;
    private Hashtable _putRefs;
    private ComMethodDesc _getItem;
    private ComMethodDesc _setItem;
    private Dictionary`2<string, ComEventDesc> _events;
    private static Dictionary`2<string, ComEventDesc> _EmptyEventsDict;
    [CompilerGeneratedAttribute]
private ComTypeLibDesc <TypeLib>k__BackingField;
    [CompilerGeneratedAttribute]
private Guid <Guid>k__BackingField;
    internal static Dictionary`2<string, ComEventDesc> EmptyEvents { get; }
    internal Hashtable Funcs { get; internal set; }
    internal Hashtable Puts { get; internal set; }
    unknown Hashtable PutRefs {internal set; }
    internal Dictionary`2<string, ComEventDesc> Events { get; internal set; }
    public string TypeName { get; }
    internal string Documentation { get; }
    public ComTypeLibDesc TypeLib { get; }
    internal Guid Guid { get; internal set; }
    internal ComMethodDesc GetItem { get; }
    internal ComMethodDesc SetItem { get; }
    internal ComTypeDesc(ITypeInfo typeInfo, ComType memberType, ComTypeLibDesc typeLibDesc);
    private static ComTypeDesc();
    internal static ComTypeDesc FromITypeInfo(ITypeInfo typeInfo, TYPEATTR typeAttr);
    internal static ComTypeDesc CreateEmptyTypeDesc();
    internal static Dictionary`2<string, ComEventDesc> get_EmptyEvents();
    internal Hashtable get_Funcs();
    internal void set_Funcs(Hashtable value);
    internal Hashtable get_Puts();
    internal void set_Puts(Hashtable value);
    internal void set_PutRefs(Hashtable value);
    internal Dictionary`2<string, ComEventDesc> get_Events();
    internal void set_Events(Dictionary`2<string, ComEventDesc> value);
    internal bool TryGetFunc(string name, ComMethodDesc& method);
    internal void AddFunc(string name, ComMethodDesc method);
    internal bool TryGetPut(string name, ComMethodDesc& method);
    internal void AddPut(string name, ComMethodDesc method);
    internal bool TryGetPutRef(string name, ComMethodDesc& method);
    internal void AddPutRef(string name, ComMethodDesc method);
    internal bool TryGetEvent(string name, ComEventDesc& event);
    internal String[] GetMemberNames(bool dataOnly);
    public string get_TypeName();
    internal string get_Documentation();
    [CompilerGeneratedAttribute]
public ComTypeLibDesc get_TypeLib();
    [CompilerGeneratedAttribute]
internal Guid get_Guid();
    [CompilerGeneratedAttribute]
internal void set_Guid(Guid value);
    internal ComMethodDesc get_GetItem();
    internal void EnsureGetItem(ComMethodDesc candidate);
    internal ComMethodDesc get_SetItem();
    internal void EnsureSetItem(ComMethodDesc candidate);
}
public class Microsoft.Scripting.ComInterop.ComTypeEnumDesc : ComTypeDesc {
    private String[] _memberNames;
    private Object[] _memberValues;
    internal ComTypeEnumDesc(ITypeInfo typeInfo, ComTypeLibDesc typeLibDesc);
    public virtual string ToString();
    private sealed virtual override DynamicMetaObject System.Dynamic.IDynamicMetaObjectProvider.GetMetaObject(Expression parameter);
    public object GetValue(string enumValueName);
    internal bool HasMember(string name);
    public String[] GetMemberNames();
}
public class Microsoft.Scripting.ComInterop.ComTypeLibDesc : object {
    private LinkedList`1<ComTypeClassDesc> _classes;
    private Dictionary`2<string, ComTypeEnumDesc> _enums;
    private string _typeLibName;
    private TYPELIBATTR _typeLibAttributes;
    private static Dictionary`2<Guid, ComTypeLibDesc> _CachedTypeLibDesc;
    public string Documentation { get; }
    public Guid Guid { get; }
    public short VersionMajor { get; }
    public short VersionMinor { get; }
    public string Name { get; }
    private static ComTypeLibDesc();
    public virtual string ToString();
    public string get_Documentation();
    private sealed virtual override DynamicMetaObject System.Dynamic.IDynamicMetaObjectProvider.GetMetaObject(Expression parameter);
    public static ComTypeLibInfo CreateFromGuid(Guid typeLibGuid);
    public static ComTypeLibInfo CreateFromObject(object rcw);
    internal static ComTypeLibDesc GetFromTypeLib(ITypeLib typeLib);
    public object GetTypeLibObjectDesc(string member);
    public String[] GetMemberNames();
    internal bool HasMember(string member);
    public Guid get_Guid();
    public short get_VersionMajor();
    public short get_VersionMinor();
    public string get_Name();
    internal ComTypeClassDesc GetCoClassForInterface(string itfName);
}
public class Microsoft.Scripting.ComInterop.ComTypeLibInfo : object {
    private ComTypeLibDesc _typeLibDesc;
    public string Name { get; }
    public Guid Guid { get; }
    public short VersionMajor { get; }
    public short VersionMinor { get; }
    public ComTypeLibDesc TypeLibDesc { get; }
    internal ComTypeLibInfo(ComTypeLibDesc typeLibDesc);
    public string get_Name();
    public Guid get_Guid();
    public short get_VersionMajor();
    public short get_VersionMinor();
    public ComTypeLibDesc get_TypeLibDesc();
    public String[] GetMemberNames();
    private sealed virtual override DynamicMetaObject System.Dynamic.IDynamicMetaObjectProvider.GetMetaObject(Expression parameter);
}
public class Microsoft.Scripting.ComInterop.ComTypeLibMemberDesc : object {
    [CompilerGeneratedAttribute]
private ComType <Kind>k__BackingField;
    public ComType Kind { get; }
    internal ComTypeLibMemberDesc(ComType kind);
    [CompilerGeneratedAttribute]
public ComType get_Kind();
}
internal class Microsoft.Scripting.ComInterop.ComUnwrappedMetaObject : DynamicMetaObject {
    internal ComUnwrappedMetaObject(Expression expression, BindingRestrictions restrictions, object value);
}
internal class Microsoft.Scripting.ComInterop.ConversionArgBuilder : ArgBuilder {
    private SimpleArgBuilder _innerBuilder;
    private Type _parameterType;
    internal ConversionArgBuilder(Type parameterType, SimpleArgBuilder innerBuilder);
    internal virtual Expression Marshal(Expression parameter);
    internal virtual Expression MarshalToRef(Expression parameter);
}
internal class Microsoft.Scripting.ComInterop.ConvertArgBuilder : SimpleArgBuilder {
    private Type _marshalType;
    internal ConvertArgBuilder(Type parameterType, Type marshalType);
    internal virtual Expression Marshal(Expression parameter);
    internal virtual Expression UnmarshalFromRef(Expression newValue);
}
internal class Microsoft.Scripting.ComInterop.ConvertibleArgBuilder : ArgBuilder {
    internal virtual Expression Marshal(Expression parameter);
    internal virtual Expression MarshalToRef(Expression parameter);
}
internal class Microsoft.Scripting.ComInterop.CurrencyArgBuilder : SimpleArgBuilder {
    internal CurrencyArgBuilder(Type parameterType);
    internal virtual Expression Marshal(Expression parameter);
    internal virtual Expression MarshalToRef(Expression parameter);
    internal virtual Expression UnmarshalFromRef(Expression value);
}
internal class Microsoft.Scripting.ComInterop.DateTimeArgBuilder : SimpleArgBuilder {
    internal DateTimeArgBuilder(Type parameterType);
    internal virtual Expression MarshalToRef(Expression parameter);
    internal virtual Expression UnmarshalFromRef(Expression value);
}
internal class Microsoft.Scripting.ComInterop.DispatchArgBuilder : SimpleArgBuilder {
    private bool _isWrapper;
    internal DispatchArgBuilder(Type parameterType);
    internal virtual Expression Marshal(Expression parameter);
    internal virtual Expression MarshalToRef(Expression parameter);
    internal virtual Expression UnmarshalFromRef(Expression value);
}
internal class Microsoft.Scripting.ComInterop.DispCallable : object {
    private IDispatchComObject _dispatch;
    private string _memberName;
    private int _dispId;
    public IDispatchComObject DispatchComObject { get; }
    public IDispatch DispatchObject { get; }
    public string MemberName { get; }
    public int DispId { get; }
    internal DispCallable(IDispatchComObject dispatch, string memberName, int dispId);
    public virtual string ToString();
    public IDispatchComObject get_DispatchComObject();
    public IDispatch get_DispatchObject();
    public string get_MemberName();
    public int get_DispId();
    public sealed virtual DynamicMetaObject GetMetaObject(Expression parameter);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
}
internal class Microsoft.Scripting.ComInterop.DispCallableMetaObject : DynamicMetaObject {
    private DispCallable _callable;
    internal DispCallableMetaObject(Expression expression, DispCallable callable);
    public virtual DynamicMetaObject BindGetIndex(GetIndexBinder binder, DynamicMetaObject[] indexes);
    public virtual DynamicMetaObject BindInvoke(InvokeBinder binder, DynamicMetaObject[] args);
    private DynamicMetaObject BindGetOrInvoke(DynamicMetaObject[] args, CallInfo callInfo);
    public virtual DynamicMetaObject BindSetIndex(SetIndexBinder binder, DynamicMetaObject[] indexes, DynamicMetaObject value);
    private DynamicMetaObject BindComInvoke(ComMethodDesc method, DynamicMetaObject[] indexes, CallInfo callInfo, Boolean[] isByRef);
    private BindingRestrictions DispCallableRestrictions();
}
internal class Microsoft.Scripting.ComInterop.ErrorArgBuilder : SimpleArgBuilder {
    internal ErrorArgBuilder(Type parameterType);
    internal virtual Expression Marshal(Expression parameter);
    internal virtual Expression UnmarshalFromRef(Expression value);
}
internal class Microsoft.Scripting.ComInterop.ExcepInfo : ValueType {
    private short wCode;
    private short wReserved;
    private IntPtr bstrSource;
    private IntPtr bstrDescription;
    private IntPtr bstrHelpFile;
    private int dwHelpContext;
    private IntPtr pvReserved;
    private IntPtr pfnDeferredFillIn;
    private int scode;
    private static string ConvertAndFreeBstr(IntPtr& bstr);
    internal void Dummy();
    internal Exception GetException();
}
internal static class Microsoft.Scripting.ComInterop.Helpers : object {
    internal static Expression Convert(Expression expression, Type type);
}
[InterfaceTypeAttribute("1")]
[GuidAttribute("00020400-0000-0000-C000-000000000046")]
internal interface Microsoft.Scripting.ComInterop.IDispatch {
    public abstract virtual int TryGetTypeInfoCount(UInt32& pctinfo);
    public abstract virtual int TryGetTypeInfo(UInt32 iTInfo, int lcid, IntPtr& info);
    public abstract virtual int TryGetIDsOfNames(Guid& iid, String[] names, UInt32 cNames, int lcid, Int32[] rgDispId);
    public abstract virtual int TryInvoke(int dispIdMember, Guid& riid, int lcid, INVOKEKIND wFlags, DISPPARAMS& pDispParams, IntPtr VarResult, IntPtr pExcepInfo, IntPtr puArgErr);
}
internal class Microsoft.Scripting.ComInterop.IDispatchComObject : ComObject {
    private IDispatch _dispatchObject;
    private ComTypeDesc _comTypeDesc;
    private static Dictionary`2<Guid, ComTypeDesc> _CacheComTypeDesc;
    public ComTypeDesc ComTypeDesc { get; }
    public IDispatch DispatchObject { get; }
    internal IDispatchComObject(IDispatch rcw);
    private static IDispatchComObject();
    public virtual string ToString();
    public ComTypeDesc get_ComTypeDesc();
    public IDispatch get_DispatchObject();
    private static int GetIDsOfNames(IDispatch dispatch, string name, Int32& dispId);
    private static int Invoke(IDispatch dispatch, int memberDispId, Object& result);
    internal bool TryGetGetItem(ComMethodDesc& value);
    private bool SlowTryGetGetItem(ComMethodDesc& value);
    internal bool TryGetSetItem(ComMethodDesc& value);
    private bool SlowTryGetSetItem(ComMethodDesc& value);
    internal bool TryGetMemberMethod(string name, ComMethodDesc& method);
    internal bool TryGetMemberEvent(string name, ComEventDesc& event);
    internal bool TryGetMemberMethodExplicit(string name, ComMethodDesc& method);
    internal bool TryGetPropertySetterExplicit(string name, ComMethodDesc& method, Type limitType, bool holdsNull);
    internal virtual IList`1<string> GetMemberNames(bool dataOnly);
    internal virtual IList`1<KeyValuePair`2<string, object>> GetMembers(IEnumerable`1<string> names);
    private sealed virtual override DynamicMetaObject System.Dynamic.IDynamicMetaObjectProvider.GetMetaObject(Expression parameter);
    private static void GetFuncDescForDescIndex(ITypeInfo typeInfo, int funcIndex, FUNCDESC& funcDesc, IntPtr& funcDescHandle);
    private void EnsureScanDefinedEvents();
    private static void ScanSourceInterface(ITypeInfo sourceTypeInfo, Dictionary`2& events);
    private static ITypeInfo GetCoClassTypeInfo(object rcw, ITypeInfo typeInfo);
    private void EnsureScanDefinedMethods();
    internal bool TryGetPropertySetter(string name, ComMethodDesc& method, Type limitType, bool holdsNull);
}
[InterfaceTypeAttribute("2")]
[GuidAttribute("00020400-0000-0000-C000-000000000046")]
internal interface Microsoft.Scripting.ComInterop.IDispatchForReflection {
}
internal class Microsoft.Scripting.ComInterop.IDispatchMetaObject : ComFallbackMetaObject {
    private IDispatchComObject _self;
    internal IDispatchMetaObject(Expression expression, IDispatchComObject self);
    public virtual DynamicMetaObject BindInvokeMember(InvokeMemberBinder binder, DynamicMetaObject[] args);
    public virtual DynamicMetaObject BindInvoke(InvokeBinder binder, DynamicMetaObject[] args);
    private DynamicMetaObject BindComInvoke(DynamicMetaObject[] args, ComMethodDesc method, CallInfo callInfo, Boolean[] isByRef);
    public virtual DynamicMetaObject BindGetMember(GetMemberBinder binder);
    private DynamicMetaObject BindGetMember(ComMethodDesc method, bool canReturnCallables);
    private DynamicMetaObject BindEvent(ComEventDesc event);
    public virtual DynamicMetaObject BindGetIndex(GetIndexBinder binder, DynamicMetaObject[] indexes);
    public virtual DynamicMetaObject BindSetIndex(SetIndexBinder binder, DynamicMetaObject[] indexes, DynamicMetaObject value);
    public virtual DynamicMetaObject BindSetMember(SetMemberBinder binder, DynamicMetaObject value);
    private DynamicMetaObject TryPropertyPut(SetMemberBinder binder, DynamicMetaObject value);
    private DynamicMetaObject TryEventHandlerNoop(SetMemberBinder binder, DynamicMetaObject value);
    private BindingRestrictions IDispatchRestriction();
    internal static BindingRestrictions IDispatchRestriction(Expression expr, ComTypeDesc typeDesc);
    protected virtual ComUnwrappedMetaObject UnwrapSelf();
}
internal enum Microsoft.Scripting.ComInterop.IDispatchMethodIndices : Enum {
    public int value__;
    public static IDispatchMethodIndices IUnknown_QueryInterface;
    public static IDispatchMethodIndices IUnknown_AddRef;
    public static IDispatchMethodIndices IUnknown_Release;
    public static IDispatchMethodIndices IDispatch_GetTypeInfoCount;
    public static IDispatchMethodIndices IDispatch_GetTypeInfo;
    public static IDispatchMethodIndices IDispatch_GetIDsOfNames;
    public static IDispatchMethodIndices IDispatch_Invoke;
}
[InterfaceTypeAttribute("1")]
[GuidAttribute("B196B283-BAB4-101A-B69C-00AA00341D07")]
internal interface Microsoft.Scripting.ComInterop.IProvideClassInfo {
    public abstract virtual void GetClassInfo(IntPtr& info);
}
internal interface Microsoft.Scripting.ComInterop.IPseudoComObject {
    public abstract virtual DynamicMetaObject GetMetaObject(Expression expression);
}
internal static class Microsoft.Scripting.ComInterop.NativeMethods : object {
    internal static void VariantClear(IntPtr variant);
}
internal class Microsoft.Scripting.ComInterop.NullArgBuilder : ArgBuilder {
    internal virtual Expression Marshal(Expression parameter);
}
internal class Microsoft.Scripting.ComInterop.SimpleArgBuilder : ArgBuilder {
    private Type _parameterType;
    internal Type ParameterType { get; }
    internal SimpleArgBuilder(Type parameterType);
    internal Type get_ParameterType();
    internal virtual Expression Marshal(Expression parameter);
    internal virtual Expression UnmarshalFromRef(Expression newValue);
}
internal class Microsoft.Scripting.ComInterop.SplatCallSite : object {
    internal object _callable;
    internal CallSite`1<Func`4<CallSite, object, Object[], object>> _site;
    internal SplatCallSite(object callable);
    internal object Invoke(Object[] args);
}
internal class Microsoft.Scripting.ComInterop.SplatInvokeBinder : CallSiteBinder {
    internal static SplatInvokeBinder Instance;
    private static SplatInvokeBinder();
    public virtual Expression Bind(Object[] args, ReadOnlyCollection`1<ParameterExpression> parameters, LabelTarget returnLabel);
}
internal class Microsoft.Scripting.ComInterop.StringArgBuilder : SimpleArgBuilder {
    private bool _isWrapper;
    internal StringArgBuilder(Type parameterType);
    internal virtual Expression Marshal(Expression parameter);
    internal virtual Expression MarshalToRef(Expression parameter);
    internal virtual Expression UnmarshalFromRef(Expression value);
}
internal class Microsoft.Scripting.ComInterop.TypeEnumMetaObject : DynamicMetaObject {
    private ComTypeEnumDesc _desc;
    internal TypeEnumMetaObject(ComTypeEnumDesc desc, Expression expression);
    public virtual DynamicMetaObject BindGetMember(GetMemberBinder binder);
    public virtual IEnumerable`1<string> GetDynamicMemberNames();
    private BindingRestrictions EnumRestrictions();
}
internal class Microsoft.Scripting.ComInterop.TypeLibInfoMetaObject : DynamicMetaObject {
    private ComTypeLibInfo _info;
    internal TypeLibInfoMetaObject(Expression expression, ComTypeLibInfo info);
    public virtual DynamicMetaObject BindGetMember(GetMemberBinder binder);
    public virtual IEnumerable`1<string> GetDynamicMemberNames();
    private BindingRestrictions ComTypeLibInfoRestrictions(DynamicMetaObject[] args);
}
internal class Microsoft.Scripting.ComInterop.TypeLibMetaObject : DynamicMetaObject {
    private ComTypeLibDesc _lib;
    internal TypeLibMetaObject(Expression expression, ComTypeLibDesc lib);
    private DynamicMetaObject TryBindGetMember(string name);
    public virtual DynamicMetaObject BindGetMember(GetMemberBinder binder);
    public virtual DynamicMetaObject BindInvokeMember(InvokeMemberBinder binder, DynamicMetaObject[] args);
    public virtual IEnumerable`1<string> GetDynamicMemberNames();
}
[ExtensionAttribute]
internal static class Microsoft.Scripting.ComInterop.TypeUtils : object {
    internal static MethodAttributes PublicStatic;
    internal static Type GetNonNullableType(Type type);
    [ExtensionAttribute]
internal static bool IsNullableType(Type type);
    internal static bool AreReferenceAssignable(Type dest, Type src);
    internal static bool AreAssignable(Type dest, Type src);
    internal static bool IsImplicitlyConvertible(Type source, Type destination);
    internal static bool IsImplicitlyConvertible(Type source, Type destination, bool considerUserDefined);
    internal static MethodInfo GetUserDefinedCoercionMethod(Type convertFrom, Type convertToType, bool implicitOnly);
    internal static MethodInfo FindConversionOperator(MethodInfo[] methods, Type typeFrom, Type typeTo, bool implicitOnly);
    private static bool IsIdentityConversion(Type source, Type destination);
    private static bool IsImplicitNumericConversion(Type source, Type destination);
    private static bool IsImplicitReferenceConversion(Type source, Type destination);
    private static bool IsImplicitBoxingConversion(Type source, Type destination);
}
internal class Microsoft.Scripting.ComInterop.UnknownArgBuilder : SimpleArgBuilder {
    private bool _isWrapper;
    internal UnknownArgBuilder(Type parameterType);
    internal virtual Expression Marshal(Expression parameter);
    internal virtual Expression MarshalToRef(Expression parameter);
    internal virtual Expression UnmarshalFromRef(Expression value);
}
internal static class Microsoft.Scripting.ComInterop.UnsafeMethods : object {
    private static MethodInfo _ConvertByrefToPtr;
    private static ConvertByrefToPtrDelegate`1<Variant> _ConvertVariantByrefToPtr;
    private static ConvertByrefToPtrDelegate`1<sbyte> _ConvertSByteByrefToPtr;
    private static ConvertByrefToPtrDelegate`1<short> _ConvertInt16ByrefToPtr;
    private static ConvertByrefToPtrDelegate`1<int> _ConvertInt32ByrefToPtr;
    private static ConvertByrefToPtrDelegate`1<long> _ConvertInt64ByrefToPtr;
    private static ConvertByrefToPtrDelegate`1<byte> _ConvertByteByrefToPtr;
    private static ConvertByrefToPtrDelegate`1<ushort> _ConvertUInt16ByrefToPtr;
    private static ConvertByrefToPtrDelegate`1<UInt32> _ConvertUInt32ByrefToPtr;
    private static ConvertByrefToPtrDelegate`1<ulong> _ConvertUInt64ByrefToPtr;
    private static ConvertByrefToPtrDelegate`1<IntPtr> _ConvertIntPtrByrefToPtr;
    private static ConvertByrefToPtrDelegate`1<UIntPtr> _ConvertUIntPtrByrefToPtr;
    private static ConvertByrefToPtrDelegate`1<float> _ConvertSingleByrefToPtr;
    private static ConvertByrefToPtrDelegate`1<double> _ConvertDoubleByrefToPtr;
    private static ConvertByrefToPtrDelegate`1<decimal> _ConvertDecimalByrefToPtr;
    private static object _lock;
    private static ModuleBuilder _dynamicModule;
    private static int _dummyMarker;
    private static IUnknownReleaseDelegate _IUnknownRelease;
    internal static IntPtr NullInterfaceId;
    private static IDispatchInvokeDelegate _IDispatchInvoke;
    private static IDispatchInvokeDelegate _IDispatchInvokeNoResultImpl;
    internal static ModuleBuilder DynamicModule { get; }
    private static IDispatchInvokeDelegate _IDispatchInvokeNoResult { get; }
    private static UnsafeMethods();
    internal static void VariantClear(IntPtr variant);
    internal static ITypeLib LoadRegTypeLib(Guid& clsid, short majorVersion, short minorVersion, int lcid);
    private static MethodInfo Create_ConvertByrefToPtr();
    public static IntPtr ConvertSByteByrefToPtr(SByte& value);
    public static IntPtr ConvertInt16ByrefToPtr(Int16& value);
    public static IntPtr ConvertInt32ByrefToPtr(Int32& value);
    public static IntPtr ConvertInt64ByrefToPtr(Int64& value);
    public static IntPtr ConvertByteByrefToPtr(Byte& value);
    public static IntPtr ConvertUInt16ByrefToPtr(UInt16& value);
    public static IntPtr ConvertUInt32ByrefToPtr(UInt32& value);
    public static IntPtr ConvertUInt64ByrefToPtr(UInt64& value);
    public static IntPtr ConvertIntPtrByrefToPtr(IntPtr& value);
    public static IntPtr ConvertUIntPtrByrefToPtr(UIntPtr& value);
    public static IntPtr ConvertSingleByrefToPtr(Single& value);
    public static IntPtr ConvertDoubleByrefToPtr(Double& value);
    public static IntPtr ConvertDecimalByrefToPtr(Decimal& value);
    public static IntPtr ConvertVariantByrefToPtr(Variant& value);
    internal static Variant GetVariantForObject(object obj);
    internal static void InitVariantForObject(object obj, Variant& variant);
    [ObsoleteAttribute("do not use this method", "True")]
public static object GetObjectForVariant(Variant variant);
    [ObsoleteAttribute("do not use this method", "True")]
public static int IUnknownRelease(IntPtr interfacePointer);
    [ObsoleteAttribute("do not use this method", "True")]
public static void IUnknownReleaseNotZero(IntPtr interfacePointer);
    [ObsoleteAttribute("do not use this method", "True")]
public static int IDispatchInvoke(IntPtr dispatchPointer, int memberDispId, INVOKEKIND flags, DISPPARAMS& dispParams, Variant& result, ExcepInfo& excepInfo, UInt32& argErr);
    [ObsoleteAttribute("do not use this method", "True")]
public static IntPtr GetIdsOfNamedParameters(IDispatch dispatch, String[] names, int methodDispId, GCHandle& pinningHandle);
    private static void EmitLoadArg(ILGenerator il, int index);
    [ConditionalAttribute("DEBUG")]
public static void AssertByrefPointsToStack(IntPtr ptr);
    internal static ModuleBuilder get_DynamicModule();
    private static IUnknownReleaseDelegate Create_IUnknownRelease();
    private static IntPtr GetNullInterfaceId();
    private static IDispatchInvokeDelegate get__IDispatchInvokeNoResult();
    private static IDispatchInvokeDelegate Create_IDispatchInvoke(bool returnResult);
}
internal class Microsoft.Scripting.ComInterop.VarEnumSelector : object {
    private VariantBuilder[] _variantBuilders;
    private static Dictionary`2<VarEnum, Type> _ComToManagedPrimitiveTypes;
    private static IList`1<IList`1<VarEnum>> _ComPrimitiveTypeFamilies;
    private static VarEnum VT_DEFAULT;
    internal VariantBuilder[] VariantBuilders { get; }
    internal VarEnumSelector(Type[] explicitArgTypes);
    private static VarEnumSelector();
    internal VariantBuilder[] get_VariantBuilders();
    internal static Type GetManagedMarshalType(VarEnum varEnum);
    private static Dictionary`2<VarEnum, Type> CreateComToManagedPrimitiveTypes();
    private static IList`1<IList`1<VarEnum>> CreateComPrimitiveTypeFamilies();
    private static List`1<VarEnum> GetConversionsToComPrimitiveTypeFamilies(Type argumentType);
    private static void CheckForAmbiguousMatch(Type argumentType, List`1<VarEnum> compatibleComTypes);
    private static bool TryGetPrimitiveComType(Type argumentType, VarEnum& primitiveVarEnum);
    private static bool TryGetPrimitiveComTypeViaConversion(Type argumentType, VarEnum& primitiveVarEnum);
    private VarEnum GetComType(Type& argumentType);
    private VariantBuilder GetVariantBuilder(Type argumentType);
    private static ArgBuilder GetByValArgBuilder(Type elementType, VarEnum& elementVarEnum);
    private static SimpleArgBuilder GetSimpleArgBuilder(Type elementType, VarEnum elementVarEnum);
}
internal class Microsoft.Scripting.ComInterop.Variant : ValueType {
    private TypeUnion _typeUnion;
    private decimal _decimal;
    public VarEnum VariantType { get; public set; }
    internal bool IsEmpty { get; }
    public sbyte AsI1 { get; public set; }
    public short AsI2 { get; public set; }
    public int AsI4 { get; public set; }
    public long AsI8 { get; public set; }
    public byte AsUi1 { get; public set; }
    public ushort AsUi2 { get; public set; }
    public UInt32 AsUi4 { get; public set; }
    public ulong AsUi8 { get; public set; }
    public IntPtr AsInt { get; public set; }
    public UIntPtr AsUint { get; public set; }
    public bool AsBool { get; public set; }
    public int AsError { get; public set; }
    public float AsR4 { get; public set; }
    public double AsR8 { get; public set; }
    public decimal AsDecimal { get; public set; }
    public decimal AsCy { get; public set; }
    public DateTime AsDate { get; public set; }
    public string AsBstr { get; public set; }
    public object AsUnknown { get; public set; }
    public object AsDispatch { get; public set; }
    public object AsVariant { get; public set; }
    public IntPtr AsByRefVariant { get; }
    public virtual string ToString();
    internal static bool IsPrimitiveType(VarEnum varEnum);
    public object ToObject();
    public void Clear();
    public VarEnum get_VariantType();
    public void set_VariantType(VarEnum value);
    internal bool get_IsEmpty();
    public void SetAsNull();
    public void SetAsIConvertible(IConvertible value);
    public sbyte get_AsI1();
    public void set_AsI1(sbyte value);
    public void SetAsByrefI1(SByte& value);
    public short get_AsI2();
    public void set_AsI2(short value);
    public void SetAsByrefI2(Int16& value);
    public int get_AsI4();
    public void set_AsI4(int value);
    public void SetAsByrefI4(Int32& value);
    public long get_AsI8();
    public void set_AsI8(long value);
    public void SetAsByrefI8(Int64& value);
    public byte get_AsUi1();
    public void set_AsUi1(byte value);
    public void SetAsByrefUi1(Byte& value);
    public ushort get_AsUi2();
    public void set_AsUi2(ushort value);
    public void SetAsByrefUi2(UInt16& value);
    public UInt32 get_AsUi4();
    public void set_AsUi4(UInt32 value);
    public void SetAsByrefUi4(UInt32& value);
    public ulong get_AsUi8();
    public void set_AsUi8(ulong value);
    public void SetAsByrefUi8(UInt64& value);
    public IntPtr get_AsInt();
    public void set_AsInt(IntPtr value);
    public void SetAsByrefInt(IntPtr& value);
    public UIntPtr get_AsUint();
    public void set_AsUint(UIntPtr value);
    public void SetAsByrefUint(UIntPtr& value);
    public bool get_AsBool();
    public void set_AsBool(bool value);
    public void SetAsByrefBool(Int16& value);
    public int get_AsError();
    public void set_AsError(int value);
    public void SetAsByrefError(Int32& value);
    public float get_AsR4();
    public void set_AsR4(float value);
    public void SetAsByrefR4(Single& value);
    public double get_AsR8();
    public void set_AsR8(double value);
    public void SetAsByrefR8(Double& value);
    public decimal get_AsDecimal();
    public void set_AsDecimal(decimal value);
    public void SetAsByrefDecimal(Decimal& value);
    public decimal get_AsCy();
    public void set_AsCy(decimal value);
    public void SetAsByrefCy(Int64& value);
    public DateTime get_AsDate();
    public void set_AsDate(DateTime value);
    public void SetAsByrefDate(Double& value);
    public string get_AsBstr();
    public void set_AsBstr(string value);
    public void SetAsByrefBstr(IntPtr& value);
    public object get_AsUnknown();
    public void set_AsUnknown(object value);
    public void SetAsByrefUnknown(IntPtr& value);
    public object get_AsDispatch();
    public void set_AsDispatch(object value);
    public void SetAsByrefDispatch(IntPtr& value);
    private static IntPtr GetIDispatchForObject(object value);
    public object get_AsVariant();
    public void set_AsVariant(object value);
    public void SetAsByrefVariant(Variant& value);
    public void SetAsByrefVariantIndirect(Variant& value);
    internal static PropertyInfo GetAccessor(VarEnum varType);
    internal static MethodInfo GetByrefSetter(VarEnum varType);
    internal void CopyFromIndirect(object value);
    public IntPtr get_AsByRefVariant();
}
internal class Microsoft.Scripting.ComInterop.VariantArgBuilder : SimpleArgBuilder {
    private bool _isWrapper;
    internal VariantArgBuilder(Type parameterType);
    internal virtual Expression Marshal(Expression parameter);
    internal virtual Expression MarshalToRef(Expression parameter);
    internal virtual Expression UnmarshalFromRef(Expression value);
}
internal static class Microsoft.Scripting.ComInterop.VariantArray : object {
    private static List`1<Type> _generatedTypes;
    private static VariantArray();
    internal static MemberExpression GetStructField(ParameterExpression variantArray, int field);
    internal static Type GetStructType(int args);
    private static Type CreateCustomType(int size);
}
internal class Microsoft.Scripting.ComInterop.VariantArray1 : ValueType {
    public Variant Element0;
}
internal class Microsoft.Scripting.ComInterop.VariantArray2 : ValueType {
    public Variant Element0;
    public Variant Element1;
}
internal class Microsoft.Scripting.ComInterop.VariantArray4 : ValueType {
    public Variant Element0;
    public Variant Element1;
    public Variant Element2;
    public Variant Element3;
}
internal class Microsoft.Scripting.ComInterop.VariantArray8 : ValueType {
    public Variant Element0;
    public Variant Element1;
    public Variant Element2;
    public Variant Element3;
    public Variant Element4;
    public Variant Element5;
    public Variant Element6;
    public Variant Element7;
}
internal class Microsoft.Scripting.ComInterop.VariantBuilder : object {
    private MemberExpression _variant;
    private ArgBuilder _argBuilder;
    private VarEnum _targetComType;
    [CompilerGeneratedAttribute]
private ParameterExpression <TempVariable>k__BackingField;
    internal ParameterExpression TempVariable { get; private set; }
    internal bool IsByRef { get; }
    internal VariantBuilder(VarEnum targetComType, ArgBuilder builder);
    [CompilerGeneratedAttribute]
internal ParameterExpression get_TempVariable();
    [CompilerGeneratedAttribute]
private void set_TempVariable(ParameterExpression value);
    internal bool get_IsByRef();
    internal Expression InitializeArgumentVariant(MemberExpression variant, Expression parameter);
    private static Expression Release(Expression pUnk);
    internal Expression Clear();
    internal Expression UpdateFromReturn(Expression parameter);
}
[ExtensionAttribute]
internal static class Microsoft.Scripting.Debugging.CollectionUtils : object {
    [ExtensionAttribute]
internal static T[] RemoveLast(T[] array);
    [ExtensionAttribute]
internal static bool ListEquals(ICollection`1<T> first, ICollection`1<T> second);
    [ExtensionAttribute]
internal static int ListHashCode(IEnumerable`1<T> list);
}
public class Microsoft.Scripting.Debugging.CompilerServices.DebugContext : object {
    private IDebugCallback _traceHook;
    private DebugMode _debugMode;
    private ThreadLocal`1<DebugThread> _thread;
    private DebugThread _cachedThread;
    private Dictionary`2<string, DebugSourceFile> _sourceFiles;
    private IDebugThreadFactory _threadFactory;
    private static object _debugYieldValue;
    [ObsoleteAttribute("do not call this property", "True")]
public int Mode { get; }
    internal DebugMode DebugMode { get; internal set; }
    internal IEnumerable`1<DebugThread> Threads { get; }
    internal IDebugCallback DebugCallback { get; internal set; }
    internal IDebugThreadFactory ThreadFactory { get; }
    internal static object DebugYieldValue { get; }
    private DebugContext(IDebugThreadFactory runtimeThreadFactory);
    public static DebugContext CreateInstance();
    internal static DebugContext CreateInstance(IDebugThreadFactory runtimeThreadFactory);
    public LambdaExpression TransformLambda(LambdaExpression lambda, DebugLambdaInfo lambdaInfo);
    public LambdaExpression TransformLambda(LambdaExpression lambda);
    public void ResetSourceFile(string sourceFileName);
    public int get_Mode();
    internal DebugMode get_DebugMode();
    internal void set_DebugMode(DebugMode value);
    internal DebugSourceFile Lookup(string sourceFile);
    [IteratorStateMachineAttribute("Microsoft.Scripting.Debugging.CompilerServices.DebugContext/<get_Threads>d__19")]
internal IEnumerable`1<DebugThread> get_Threads();
    internal IDebugCallback get_DebugCallback();
    internal void set_DebugCallback(IDebugCallback value);
    internal DebugSourceFile GetDebugSourceFile(string sourceFile);
    internal static FunctionInfo CreateFunctionInfo(Delegate generatorFactory, string name, DebugSourceSpan[] locationSpanMap, IList`1[] scopedVariables, IList`1<VariableInfo> variables, object customPayload);
    internal DebugFrame CreateFrameForGenerator(FunctionInfo func);
    internal void DispatchDebugEvent(DebugThread thread, int debugMarker, TraceEventKind eventKind, object payload);
    internal IDebugThreadFactory get_ThreadFactory();
    internal DebugThread GetCurrentThread();
    internal static object get_DebugYieldValue();
    internal object GeneratorLoopProc(DebugFrame frame, Boolean& moveNext);
}
public class Microsoft.Scripting.Debugging.CompilerServices.DebugLambdaInfo : object {
    [CompilerGeneratedAttribute]
private IDebugCompilerSupport <CompilerSupport>k__BackingField;
    [CompilerGeneratedAttribute]
private string <LambdaAlias>k__BackingField;
    [CompilerGeneratedAttribute]
private IList`1<ParameterExpression> <HiddenVariables>k__BackingField;
    [CompilerGeneratedAttribute]
private IDictionary`2<ParameterExpression, string> <VariableAliases>k__BackingField;
    [CompilerGeneratedAttribute]
private object <CustomPayload>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <OptimizeForLeafFrames>k__BackingField;
    public IDebugCompilerSupport CompilerSupport { get; }
    public string LambdaAlias { get; }
    public IList`1<ParameterExpression> HiddenVariables { get; }
    public IDictionary`2<ParameterExpression, string> VariableAliases { get; }
    public object CustomPayload { get; }
    public bool OptimizeForLeafFrames { get; }
    public DebugLambdaInfo(IDebugCompilerSupport compilerSupport, string lambdaAlias, bool optimizeForLeafFrames, IList`1<ParameterExpression> hiddenVariables, IDictionary`2<ParameterExpression, string> variableAliases, object customPayload);
    [CompilerGeneratedAttribute]
public IDebugCompilerSupport get_CompilerSupport();
    [CompilerGeneratedAttribute]
public string get_LambdaAlias();
    [CompilerGeneratedAttribute]
public IList`1<ParameterExpression> get_HiddenVariables();
    [CompilerGeneratedAttribute]
public IDictionary`2<ParameterExpression, string> get_VariableAliases();
    [CompilerGeneratedAttribute]
public object get_CustomPayload();
    [CompilerGeneratedAttribute]
public bool get_OptimizeForLeafFrames();
}
public interface Microsoft.Scripting.Debugging.CompilerServices.IDebugCompilerSupport {
    public abstract virtual bool DoesExpressionNeedReduction(Expression expression);
    public abstract virtual Expression QueueExpressionForReduction(Expression expression);
    public abstract virtual bool IsCallToDebuggableLambda(Expression expression);
}
[DebuggerDisplayAttribute("FunctionInfo = {_funcInfo.Name}, CurrentSequencePointIndex = {CurrentSequencePointIndex}")]
public class Microsoft.Scripting.Debugging.DebugFrame : object {
    private FunctionInfo _funcInfo;
    private Exception _thrownException;
    private IRuntimeVariables _liftedLocals;
    private IDebuggableGenerator _generator;
    private int _lastKnownGeneratorYieldMarker;
    private bool _inTraceBack;
    private bool _inGeneratorLoop;
    private bool _forceToGeneratorLoop;
    private Dictionary`2<IList`1<VariableInfo>, ScopeData> _variables;
    private static string _exceptionVariableSymbol;
    [CompilerGeneratedAttribute]
private DebugThread <Thread>k__BackingField;
    [CompilerGeneratedAttribute]
private int <StackDepth>k__BackingField;
    internal DebugThread Thread { get; }
    internal int StackDepth { get; internal set; }
    internal VariableInfo[] Variables { get; }
    internal int CurrentSequencePointIndex { get; internal set; }
    internal FunctionInfo FunctionInfo { get; }
    internal Exception ThrownException { get; internal set; }
    internal IDebuggableGenerator Generator { get; }
    internal bool IsInTraceback { get; internal set; }
    internal bool InGeneratorLoop { get; internal set; }
    internal bool ForceSwitchToGeneratorLoop { get; internal set; }
    internal DebugContext DebugContext { get; }
    internal int CurrentLocationCookie { get; }
    internal int LastKnownGeneratorYieldMarker { get; internal set; }
    private ScopeData CurrentScopeData { get; }
    private IList`1<VariableInfo> LocalsInCurrentScope { get; }
    internal DebugFrame(DebugThread thread, FunctionInfo funcInfo);
    internal DebugFrame(DebugThread thread, FunctionInfo funcInfo, IRuntimeVariables liftedLocals, int frameOrder);
    [CompilerGeneratedAttribute]
internal DebugThread get_Thread();
    [CompilerGeneratedAttribute]
internal int get_StackDepth();
    [CompilerGeneratedAttribute]
internal void set_StackDepth(int value);
    internal VariableInfo[] get_Variables();
    internal int get_CurrentSequencePointIndex();
    internal void set_CurrentSequencePointIndex(int value);
    internal void RemapToLatestVersion();
    internal FunctionInfo get_FunctionInfo();
    internal Exception get_ThrownException();
    internal void set_ThrownException(Exception value);
    internal IDebuggableGenerator get_Generator();
    internal bool get_IsInTraceback();
    internal void set_IsInTraceback(bool value);
    internal bool get_InGeneratorLoop();
    internal void set_InGeneratorLoop(bool value);
    internal bool get_ForceSwitchToGeneratorLoop();
    internal void set_ForceSwitchToGeneratorLoop(bool value);
    internal DebugContext get_DebugContext();
    internal int get_CurrentLocationCookie();
    internal int get_LastKnownGeneratorYieldMarker();
    internal void set_LastKnownGeneratorYieldMarker(int value);
    internal void ReplaceLiftedLocals(IRuntimeVariables liftedLocals);
    internal void RemapToGenerator(int version);
    internal IDictionary`2<object, object> GetLocalsScope();
    private void CreateGenerator(FunctionInfo targetFuncInfo);
    private Object[] GetParamValuesForGenerator();
    private FunctionInfo GetFunctionInfo(int version);
    private ScopeData get_CurrentScopeData();
    private IList`1<VariableInfo> get_LocalsInCurrentScope();
}
internal class Microsoft.Scripting.Debugging.DebuggableLambdaBuilder : object {
    private DebugContext _debugContext;
    private Dictionary`2<DebugSourceFile, ParameterExpression> _sourceFilesMap;
    private DebugLambdaInfo _lambdaInfo;
    private string _alias;
    private Expression _debugContextExpression;
    private Expression _globalDebugMode;
    private LabelTarget _generatorLabelTarget;
    private DebugSourceSpan[] _debugMarkerLocationMap;
    private IList`1[] _variableScopeMap;
    private List`1<ParameterExpression> _lambdaVars;
    private List`1<ParameterExpression> _lambdaParams;
    private List`1<ParameterExpression> _generatorVars;
    private List`1<ParameterExpression> _generatorParams;
    private ParameterExpression _retVal;
    private Expression _pushFrame;
    private Expression _conditionalPushFrame;
    private bool _noPushFrameOptimization;
    private List`1<ParameterExpression> _pendingLocals;
    private List`1<ParameterExpression> _verifiedLocals;
    private Dictionary`2<string, object> _verifiedLocalNames;
    private List`1<VariableInfo> _variableInfos;
    private Dictionary`2<ParameterExpression, VariableInfo> _pendingToVariableInfosMap;
    private Dictionary`2<ParameterExpression, ParameterExpression> _pendingToVerifiedLocalsMap;
    private Expression _functionInfo;
    private int _lambdaId;
    private static ParameterExpression _frame;
    private static ParameterExpression _thread;
    private static ParameterExpression _debugMarker;
    private static ParameterExpression _framePushed;
    private static ParameterExpression _funcInfo;
    private static ParameterExpression _traceLocations;
    private static ParameterExpression _retValAsObject;
    private static ParameterExpression _retValFromGeneratorLoop;
    private static ParameterExpression _frameExitException;
    internal DebuggableLambdaBuilder(DebugContext debugContext, DebugLambdaInfo lambdaInfo);
    private static DebuggableLambdaBuilder();
    internal LambdaExpression Transform(LambdaExpression lambda);
    private LambdaExpression TransformLambda(LambdaExpression lambda);
    private LambdaExpression TransformGenerator(LambdaExpression lambda);
    private void LayOutVariables(Dictionary`2<ParameterExpression, object> strongBoxedLocals, Dictionary`2<ParameterExpression, object> parameters);
    private void LayoutVariablesForGenerator(Dictionary`2<ParameterExpression, object> parameters);
    private void CreatePushFrameExpression();
    private void CreateFunctionInfo(LambdaExpression generatorFactoryLambda);
    private Expression TransformToDebuggableBody(Expression body);
    private Expression TransformToGeneratorBody(Expression body);
    private LambdaExpression CreateOuterLambda(Type lambdaType, Expression debuggableBody);
    private LambdaExpression CreateGeneratorFactoryLambda(Expression generatorBody);
    private LambdaExpression CreateOuterGeneratorFactory(Type lambdaType);
}
internal class Microsoft.Scripting.Debugging.DebugGenerator`1 : object {
    private DebugFrame _frame;
    public T Current { get; }
    private object System.Collections.IEnumerator.Current { get; }
    internal DebugGenerator`1(DebugFrame frame);
    public sealed virtual T get_Current();
    private sealed virtual override void System.IDisposable.Dispose();
    private sealed virtual override object System.Collections.IEnumerator.get_Current();
    public sealed virtual bool MoveNext();
    public sealed virtual void Reset();
}
internal class Microsoft.Scripting.Debugging.DebugInfoRewriter : DynamicExpressionVisitor {
    private DebugContext _debugContext;
    private bool _transformToGenerator;
    private Expression _thread;
    private Expression _frame;
    private Expression _debugMarker;
    private Expression _traceLocations;
    private Dictionary`2<ParameterExpression, ParameterExpression> _replacedLocals;
    private Dictionary`2<ParameterExpression, VariableInfo> _localsToVarInfos;
    private Stack`1<BlockExpression> _currentLocals;
    private Dictionary`2<int, DebugSourceSpan> _markerLocationMap;
    private Dictionary`2<int, IList`1<VariableInfo>> _variableScopeMap;
    private Dictionary`2<BlockExpression, IList`1<VariableInfo>> _variableScopeMapCache;
    private Dictionary`2<DebugSourceFile, ParameterExpression> _sourceFilesToVariablesMap;
    private Expression _globalDebugMode;
    private LabelTarget _generatorLabelTarget;
    private ConstantExpression _debugYieldValue;
    private Expression _pushFrame;
    private DebugLambdaInfo _lambdaInfo;
    private int _locationCookie;
    private bool _hasUnconditionalFunctionCalls;
    private bool _insideConditionalBlock;
    internal DebugSourceSpan[] DebugMarkerLocationMap { get; }
    internal bool HasUnconditionalFunctionCalls { get; }
    internal IList`1[] VariableScopeMap { get; }
    internal DebugInfoRewriter(DebugContext debugContext, bool transformToGenerator, Expression traceLocations, Expression thread, Expression frame, Expression pushFrame, Expression debugMarker, Expression globalDebugMode, Dictionary`2<DebugSourceFile, ParameterExpression> sourceFilesToVariablesMap, LabelTarget generatorLabel, Dictionary`2<ParameterExpression, ParameterExpression> replacedLocals, Dictionary`2<ParameterExpression, VariableInfo> localsToVarInfos, DebugLambdaInfo lambdaInfo);
    internal DebugSourceSpan[] get_DebugMarkerLocationMap();
    internal bool get_HasUnconditionalFunctionCalls();
    internal IList`1[] get_VariableScopeMap();
    protected virtual Expression VisitLambda(Expression`1<T> node);
    protected virtual Expression VisitBlock(BlockExpression node);
    protected virtual Expression VisitTry(TryExpression node);
    protected virtual CatchBlock VisitCatchBlock(CatchBlock node);
    protected virtual Expression VisitConditional(ConditionalExpression node);
    protected virtual SwitchCase VisitSwitchCase(SwitchCase node);
    protected virtual Expression VisitDynamic(DynamicExpression node);
    protected virtual Expression VisitMethodCall(MethodCallExpression node);
    protected virtual Expression VisitInvocation(InvocationExpression node);
    protected virtual Expression VisitNew(NewExpression node);
    internal Expression VisitCall(Expression node);
    protected virtual Expression VisitParameter(ParameterExpression node);
    protected virtual Expression VisitDebugInfo(DebugInfoExpression node);
}
internal enum Microsoft.Scripting.Debugging.DebugMode : Enum {
    public int value__;
    public static DebugMode Disabled;
    public static DebugMode ExceptionsOnly;
    public static DebugMode TracePoints;
    public static DebugMode FullyEnabled;
}
[DefaultMemberAttribute("Item")]
[DebuggerDisplayAttribute("Count = {Count}")]
internal class Microsoft.Scripting.Debugging.DebugRuntimeVariables : object {
    private IRuntimeVariables _runtimeVariables;
    public int Count { get; }
    public object Item { get; public set; }
    public FunctionInfo FunctionInfo { get; }
    public int DebugMarker { get; }
    internal DebugRuntimeVariables(IRuntimeVariables runtimeVariables);
    public sealed virtual int get_Count();
    public sealed virtual object get_Item(int index);
    public sealed virtual void set_Item(int index, object value);
    public sealed virtual FunctionInfo get_FunctionInfo();
    public sealed virtual int get_DebugMarker();
}
public class Microsoft.Scripting.Debugging.DebugSourceFile : object {
    private DebugMode _debugMode;
    private Dictionary`2<DebugSourceSpan, FunctionInfo> _functionInfoMap;
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    internal Dictionary`2<DebugSourceSpan, FunctionInfo> FunctionInfoMap { get; }
    internal string Name { get; }
    internal DebugMode DebugMode { get; internal set; }
    [ObsoleteAttribute("do not call this property", "True")]
public int Mode { get; }
    internal DebugSourceFile(string fileName, DebugMode debugMode);
    internal Dictionary`2<DebugSourceSpan, FunctionInfo> get_FunctionInfoMap();
    [CompilerGeneratedAttribute]
internal string get_Name();
    internal DebugMode get_DebugMode();
    internal void set_DebugMode(DebugMode value);
    internal FunctionInfo LookupFunctionInfo(DebugSourceSpan span);
    public int get_Mode();
}
[DebuggerDisplayAttribute("{LineStart}, {ColumnStart} - {LineEnd}, {ColumnEnd}")]
internal class Microsoft.Scripting.Debugging.DebugSourceSpan : object {
    private DebugSourceFile _sourceFile;
    private int _lineStart;
    private int _columnStart;
    private int _lineEnd;
    private int _columnEnd;
    internal DebugSourceFile SourceFile { get; }
    internal int LineStart { get; }
    internal int ColumnStart { get; }
    internal int LineEnd { get; }
    internal int ColumnEnd { get; }
    internal DebugSourceSpan(DebugSourceFile sourceFile, int lineStart, int columnStart, int lineEnd, int columnEnd);
    internal DebugSourceSpan(DebugSourceFile sourceFile, SourceSpan& dlrSpan);
    internal DebugSourceFile get_SourceFile();
    internal int get_LineStart();
    internal int get_ColumnStart();
    internal int get_LineEnd();
    internal int get_ColumnEnd();
    internal SourceSpan ToDlrSpan();
    internal bool Contains(DebugSourceSpan candidateSpan);
    internal bool Intersects(DebugSourceSpan candidateSpan);
    internal int GetSequencePointIndex(FunctionInfo funcInfo);
}
[DebuggerDisplayAttribute("ThreadId = {_threadId}")]
public abstract class Microsoft.Scripting.Debugging.DebugThread : object {
    private int _threadId;
    [CompilerGeneratedAttribute]
private DebugContext <DebugContext>k__BackingField;
    [CompilerGeneratedAttribute]
private Exception <ThrownException>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsInTraceback>k__BackingField;
    internal DebugContext DebugContext { get; }
    internal Exception ThrownException { get; internal set; }
    internal bool IsCurrentThread { get; }
    internal bool IsInTraceback { get; internal set; }
    internal IEnumerable`1<DebugFrame> Frames { get; }
    internal int FrameCount { get; }
    internal DebugThread(DebugContext debugContext);
    [CompilerGeneratedAttribute]
internal DebugContext get_DebugContext();
    [CompilerGeneratedAttribute]
internal Exception get_ThrownException();
    [CompilerGeneratedAttribute]
internal void set_ThrownException(Exception value);
    internal bool get_IsCurrentThread();
    [CompilerGeneratedAttribute]
internal bool get_IsInTraceback();
    [CompilerGeneratedAttribute]
internal void set_IsInTraceback(bool value);
    internal abstract virtual IEnumerable`1<DebugFrame> get_Frames();
    internal abstract virtual DebugFrame GetLeafFrame();
    internal abstract virtual bool TryGetLeafFrame(DebugFrame& frame);
    internal abstract virtual int get_FrameCount();
    internal abstract virtual void PushExistingFrame(DebugFrame frame);
    internal abstract virtual bool PopFrame();
    internal abstract virtual FunctionInfo GetLeafFrameFunctionInfo(Int32& stackDepth);
}
internal class Microsoft.Scripting.Debugging.DefaultDebugThread : DebugThread {
    private List`1<FrameRuntimeVariablesPair> _frames;
    internal IEnumerable`1<DebugFrame> Frames { get; }
    internal int FrameCount { get; }
    internal DefaultDebugThread(DebugContext debugContext);
    internal void LiftVariables(IRuntimeVariables runtimeVariables);
    [IteratorStateMachineAttribute("Microsoft.Scripting.Debugging.DefaultDebugThread/<get_Frames>d__4")]
internal virtual IEnumerable`1<DebugFrame> get_Frames();
    internal virtual DebugFrame GetLeafFrame();
    internal virtual bool TryGetLeafFrame(DebugFrame& frame);
    internal virtual int get_FrameCount();
    internal virtual void PushExistingFrame(DebugFrame frame);
    internal virtual bool PopFrame();
    internal virtual FunctionInfo GetLeafFrameFunctionInfo(Int32& stackDepth);
    private DebugFrame GetFrame(int index);
}
internal class Microsoft.Scripting.Debugging.DefaultDebugThreadFactory : object {
    public sealed virtual DebugThread CreateDebugThread(DebugContext debugContext);
    public sealed virtual Expression CreatePushFrameExpression(ParameterExpression functionInfo, ParameterExpression debugMarker, IList`1<ParameterExpression> locals, IList`1<VariableInfo> varInfos, Expression runtimeThread);
}
internal static class Microsoft.Scripting.Debugging.DelegateHelpers : object {
    private static ModuleBuilder _moduleBuilder;
    private static MethodAttributes CtorAttributes;
    private static MethodImplAttributes ImplAttributes;
    private static MethodAttributes InvokeAttributes;
    private static Type[] _DelegateCtorSignature;
    private static DelegateHelpers();
    internal static Type MakeNewCustomDelegateType(Type[] types);
    private static TypeBuilder DefineDelegateType(string name);
    private static ModuleBuilder GetModule();
}
internal static class Microsoft.Scripting.Debugging.ErrorStrings : object {
    internal static string JumpNotAllowedInNonLeafFrames { get; }
    internal static string DebugContextAlreadyConnectedToTracePipeline { get; }
    internal static string InvalidSourceSpan { get; }
    internal static string SetNextStatementOnlyAllowedInsideTraceback { get; }
    internal static string ITracePipelineClosed { get; }
    internal static string InvalidFunctionVersion { get; }
    internal static string DebugInfoWithoutSymbolDocumentInfo { get; }
    internal static string get_JumpNotAllowedInNonLeafFrames();
    internal static string get_DebugContextAlreadyConnectedToTracePipeline();
    internal static string get_InvalidSourceSpan();
    internal static string get_SetNextStatementOnlyAllowedInsideTraceback();
    internal static string get_ITracePipelineClosed();
    internal static string get_InvalidFunctionVersion();
    internal static string get_DebugInfoWithoutSymbolDocumentInfo();
}
public class Microsoft.Scripting.Debugging.ForceToGeneratorLoopException : Exception {
}
[DebuggerDisplayAttribute("{Name}")]
public class Microsoft.Scripting.Debugging.FunctionInfo : object {
    private Boolean[] _traceLocations;
    [CompilerGeneratedAttribute]
private Delegate <GeneratorFactory>k__BackingField;
    [CompilerGeneratedAttribute]
private IList`1<VariableInfo> <Variables>k__BackingField;
    [CompilerGeneratedAttribute]
private IList`1[] <VariableScopeMap>k__BackingField;
    [CompilerGeneratedAttribute]
private FunctionInfo <PreviousVersion>k__BackingField;
    [CompilerGeneratedAttribute]
private FunctionInfo <NextVersion>k__BackingField;
    [CompilerGeneratedAttribute]
private int <Version>k__BackingField;
    [CompilerGeneratedAttribute]
private DebugSourceSpan[] <SequencePoints>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    [CompilerGeneratedAttribute]
private object <CustomPayload>k__BackingField;
    internal Delegate GeneratorFactory { get; }
    internal IList`1<VariableInfo> Variables { get; }
    internal IList`1[] VariableScopeMap { get; }
    internal FunctionInfo PreviousVersion { get; internal set; }
    internal FunctionInfo NextVersion { get; internal set; }
    internal int Version { get; internal set; }
    internal DebugSourceSpan[] SequencePoints { get; }
    internal string Name { get; }
    internal object CustomPayload { get; }
    internal FunctionInfo(Delegate generatorFactory, string name, DebugSourceSpan[] sequencePoints, IList`1[] scopedVariables, IList`1<VariableInfo> variables, object customPayload);
    [CompilerGeneratedAttribute]
internal Delegate get_GeneratorFactory();
    [CompilerGeneratedAttribute]
internal IList`1<VariableInfo> get_Variables();
    [CompilerGeneratedAttribute]
internal IList`1[] get_VariableScopeMap();
    [CompilerGeneratedAttribute]
internal FunctionInfo get_PreviousVersion();
    [CompilerGeneratedAttribute]
internal void set_PreviousVersion(FunctionInfo value);
    [CompilerGeneratedAttribute]
internal FunctionInfo get_NextVersion();
    [CompilerGeneratedAttribute]
internal void set_NextVersion(FunctionInfo value);
    [CompilerGeneratedAttribute]
internal int get_Version();
    [CompilerGeneratedAttribute]
internal void set_Version(int value);
    [CompilerGeneratedAttribute]
internal DebugSourceSpan[] get_SequencePoints();
    [CompilerGeneratedAttribute]
internal string get_Name();
    [CompilerGeneratedAttribute]
internal object get_CustomPayload();
    internal Boolean[] GetTraceLocations();
}
internal interface Microsoft.Scripting.Debugging.IDebugCallback {
    public abstract virtual void OnDebugEvent(TraceEventKind kind, DebugThread thread, FunctionInfo functionInfo, int sequencePointIndex, int stackDepth, object payload);
}
internal interface Microsoft.Scripting.Debugging.IDebugRuntimeVariables {
    public FunctionInfo FunctionInfo { get; }
    public int DebugMarker { get; }
    public abstract virtual FunctionInfo get_FunctionInfo();
    public abstract virtual int get_DebugMarker();
}
internal interface Microsoft.Scripting.Debugging.IDebugThreadFactory {
    public abstract virtual DebugThread CreateDebugThread(DebugContext debugContext);
    public abstract virtual Expression CreatePushFrameExpression(ParameterExpression functionInfo, ParameterExpression debugMarker, IList`1<ParameterExpression> locals, IList`1<VariableInfo> varInfos, Expression runtimeThread);
}
internal static class Microsoft.Scripting.Debugging.InvokeTargets : object {
    internal static Type GetGeneratorFactoryTarget(Type[] parameterTypes);
}
public interface Microsoft.Scripting.Debugging.ITraceCallback {
    public abstract virtual void OnTraceEvent(TraceEventKind kind, string name, string sourceFileName, SourceSpan sourceSpan, Func`1<IDictionary`2<object, object>> scopeCallback, object payload, object customPayload);
}
public interface Microsoft.Scripting.Debugging.ITracePipeline {
    public ITraceCallback TraceCallback { get; public set; }
    public abstract virtual void Close();
    public abstract virtual bool TrySetNextStatement(string sourceFile, SourceSpan sourceSpan);
    public abstract virtual ITraceCallback get_TraceCallback();
    public abstract virtual void set_TraceCallback(ITraceCallback value);
}
internal class Microsoft.Scripting.Debugging.LambdaWalker : ExpressionVisitor {
    private List`1<ParameterExpression> _locals;
    private Dictionary`2<ParameterExpression, object> _strongBoxedLocals;
    internal List`1<ParameterExpression> Locals { get; }
    internal Dictionary`2<ParameterExpression, object> StrongBoxedLocals { get; }
    internal List`1<ParameterExpression> get_Locals();
    internal Dictionary`2<ParameterExpression, object> get_StrongBoxedLocals();
    protected virtual Expression VisitBlock(BlockExpression node);
    protected virtual Expression VisitRuntimeVariables(RuntimeVariablesExpression node);
    protected virtual Expression VisitLambda(Expression`1<T> node);
}
internal class Microsoft.Scripting.Debugging.ListEqualityComparer`1 : EqualityComparer`1<ICollection`1<T>> {
    internal static ListEqualityComparer`1<T> Instance;
    private static ListEqualityComparer`1();
    public virtual bool Equals(ICollection`1<T> x, ICollection`1<T> y);
    public virtual int GetHashCode(ICollection`1<T> obj);
}
public static class Microsoft.Scripting.Debugging.RuntimeOps : object {
    [ObsoleteAttribute("do not call this method", "True")]
public static DebugFrame CreateFrameForGenerator(DebugContext debugContext, FunctionInfo func);
    [ObsoleteAttribute("do not call this method", "True")]
public static bool PopFrame(DebugThread thread);
    [ObsoleteAttribute("do not call this method", "True")]
public static void OnTraceEvent(DebugThread thread, int debugMarker, Exception exception);
    [ObsoleteAttribute("do not call this method", "True")]
public static void OnTraceEventUnwind(DebugThread thread, int debugMarker, Exception exception);
    [ObsoleteAttribute("do not call this method", "True")]
public static void OnFrameEnterTraceEvent(DebugThread thread);
    [ObsoleteAttribute("do not call this method", "True")]
public static void OnFrameExitTraceEvent(DebugThread thread, int debugMarker, object retVal);
    [ObsoleteAttribute("do not call this method", "True")]
public static void OnThreadExitEvent(DebugThread thread);
    [ObsoleteAttribute("do not call this method", "True")]
public static void ReplaceLiftedLocals(DebugFrame frame, IRuntimeVariables liftedLocals);
    [ObsoleteAttribute("do not call this method", "True")]
public static object GeneratorLoopProc(DebugThread thread);
    [ObsoleteAttribute("do not call this method", "True")]
public static IEnumerator`1<T> CreateDebugGenerator(DebugFrame frame);
    [ObsoleteAttribute("do not call this method", "True")]
public static int GetCurrentSequencePointForGeneratorFrame(DebugFrame frame);
    [ObsoleteAttribute("do not call this method", "True")]
public static int GetCurrentSequencePointForLeafGeneratorFrame(DebugThread thread);
    [ObsoleteAttribute("do not call this method", "True")]
public static bool IsCurrentLeafFrameRemappingToGenerator(DebugThread thread);
    [ObsoleteAttribute("do not call this method", "True")]
public static FunctionInfo CreateFunctionInfo(Delegate generatorFactory, string name, object locationSpanMap, object scopedVariables, object variables, object customPayload);
    [ObsoleteAttribute("do not call this method", "True")]
public static DebugThread GetCurrentThread(DebugContext debugContext);
    [ObsoleteAttribute("do not call this method", "True")]
public static DebugThread GetThread(DebugFrame frame);
    [ObsoleteAttribute("do not call this method", "True")]
public static Boolean[] GetTraceLocations(FunctionInfo functionInfo);
    [ObsoleteAttribute("do not call this method", "True")]
public static void LiftVariables(DebugThread thread, IRuntimeVariables runtimeVariables);
}
[DefaultMemberAttribute("Item")]
internal class Microsoft.Scripting.Debugging.ScopedRuntimeVariables : object {
    private IList`1<VariableInfo> _variableInfos;
    private IRuntimeVariables _variables;
    public int Count { get; }
    public object Item { get; public set; }
    internal ScopedRuntimeVariables(IList`1<VariableInfo> variableInfos, IRuntimeVariables variables);
    public sealed virtual int get_Count();
    public sealed virtual object get_Item(int index);
    public sealed virtual void set_Item(int index, object value);
}
internal class Microsoft.Scripting.Debugging.ThreadLocal`1 : object {
    private StorageInfo[] _stores;
    private static StorageInfo[] Updating;
    internal T Value { get; internal set; }
    internal T[] Values { get; }
    private static ThreadLocal`1();
    internal T get_Value();
    internal void set_Value(T value);
    internal T[] get_Values();
    private StorageInfo<T> GetStorageInfo();
    private StorageInfo<T> GetStorageInfo(StorageInfo[] curStorage);
    private StorageInfo<T> RetryOrCreateStorageInfo(StorageInfo[] curStorage);
    private StorageInfo<T> CreateStorageInfo();
}
public enum Microsoft.Scripting.Debugging.TraceEventKind : Enum {
    public int value__;
    public static TraceEventKind FrameEnter;
    public static TraceEventKind FrameExit;
    public static TraceEventKind ThreadExit;
    public static TraceEventKind TracePoint;
    public static TraceEventKind Exception;
    public static TraceEventKind ExceptionUnwind;
}
public class Microsoft.Scripting.Debugging.TracePipeline : object {
    private DebugContext _debugContext;
    private ThreadLocal`1<DebugFrame> _traceFrame;
    private ITraceCallback _traceCallback;
    private bool _closed;
    public ITraceCallback TraceCallback { get; public set; }
    private TracePipeline(DebugContext debugContext);
    public static TracePipeline CreateInstance(DebugContext debugContext);
    public sealed virtual void Close();
    public sealed virtual bool TrySetNextStatement(string sourceFile, SourceSpan sourceSpan);
    public sealed virtual ITraceCallback get_TraceCallback();
    public sealed virtual void set_TraceCallback(ITraceCallback value);
    private sealed virtual override void Microsoft.Scripting.Debugging.IDebugCallback.OnDebugEvent(TraceEventKind kind, DebugThread thread, FunctionInfo functionInfo, int sequencePointIndex, int stackDepth, object payload);
    private int GetSequencePointIndexForSourceSpan(string sourceFile, SourceSpan& sourceSpan, DebugFrame frame);
    private void VerifyNotClosed();
}
[DebuggerDisplayAttribute("{Name}")]
internal class Microsoft.Scripting.Debugging.VariableInfo : object {
    private int _localIndex;
    private int _globalIndex;
    [CompilerGeneratedAttribute]
private bool <Hidden>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsStrongBoxed>k__BackingField;
    [CompilerGeneratedAttribute]
private Type <VariableType>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsParameter>k__BackingField;
    internal bool Hidden { get; }
    internal bool IsStrongBoxed { get; }
    internal int LocalIndex { get; }
    internal int GlobalIndex { get; }
    internal Type VariableType { get; }
    internal string Name { get; }
    internal bool IsParameter { get; }
    internal VariableInfo(string name, Type type, bool parameter, bool hidden, bool strongBoxed, int localIndex, int globalIndex);
    internal VariableInfo(string name, Type type, bool parameter, bool hidden, bool strongBoxed);
    [CompilerGeneratedAttribute]
internal bool get_Hidden();
    [CompilerGeneratedAttribute]
internal bool get_IsStrongBoxed();
    internal int get_LocalIndex();
    internal int get_GlobalIndex();
    [CompilerGeneratedAttribute]
internal Type get_VariableType();
    [CompilerGeneratedAttribute]
internal string get_Name();
    [CompilerGeneratedAttribute]
internal bool get_IsParameter();
}
internal static class Microsoft.Scripting.DebugOptions : object {
    private static bool _trackPerformance;
    internal static bool TrackPerformance { get; }
    private static DebugOptions();
    private static bool ReadOption(string name);
    private static bool ReadDebugOption(string name);
    private static string ReadString(string name);
    private static string ReadDebugString(string name);
    internal static bool get_TrackPerformance();
}
internal static class Microsoft.Scripting.Error : object {
    internal static Exception COMObjectDoesNotSupportEvents();
    internal static Exception COMObjectDoesNotSupportSourceInterface();
    internal static Exception SetComObjectDataFailed();
    internal static Exception MethodShouldNotBeCalled();
    internal static Exception UnexpectedVarEnum(object p0);
    internal static Exception DispBadParamCount(object p0);
    internal static Exception DispMemberNotFound(object p0);
    internal static Exception DispNoNamedArgs(object p0);
    internal static Exception DispOverflow(object p0);
    internal static Exception DispTypeMismatch(object p0, object p1);
    internal static Exception DispParamNotOptional(object p0);
    internal static Exception CannotRetrieveTypeInformation();
    internal static Exception GetIDsOfNamesInvalid(object p0);
    internal static Exception UnsupportedEnumType();
    internal static Exception UnsupportedHandlerType();
    internal static Exception CouldNotGetDispId(object p0, object p1);
    internal static Exception AmbiguousConversion(object p0, object p1);
    internal static Exception VariantGetAccessorNYI(object p0);
    internal static Exception MustHaveCodeOrTarget();
    internal static Exception TypeParameterIsNotDelegate(object p0);
    internal static Exception InvalidCast(object p0, object p1);
    internal static Exception UnknownMemberType(object p0);
    internal static Exception FirstArgumentMustBeCallSite();
    internal static Exception NoInstanceForCall();
    internal static Exception MissingTest();
    internal static Exception MissingTarget();
    internal static Exception NonGenericWithGenericGroup(object p0);
    internal static Exception InvalidOperation(object p0);
    internal static Exception FinallyAlreadyDefined();
    internal static Exception CannotHaveFaultAndFinally();
    internal static Exception FaultAlreadyDefined();
    internal static Exception CantCreateDefaultTypeFor(object p0);
    internal static Exception UnhandledConvert(object p0);
    internal static Exception NoCallableMethods(object p0, object p1);
    internal static Exception GlobalsMustBeUnique();
    internal static Exception GenNonSerializableBinder();
    internal static Exception InvalidPath();
    internal static Exception DictionaryNotHashable();
    internal static Exception LanguageRegistered();
    internal static Exception MethodOrOperatorNotImplemented();
    internal static Exception NoException();
    internal static Exception ExtensionMustBePublic(object p0);
    internal static Exception AlreadyInitialized();
    internal static Exception MustReturnScopeExtension();
    internal static Exception InvalidParamNumForService();
    internal static Exception InvalidArgumentType(object p0, object p1);
    internal static Exception CannotChangeNonCachingValue();
    internal static Exception FieldReadonly(object p0);
    internal static Exception PropertyReadonly(object p0);
    internal static Exception UnexpectedEvent(object p0, object p1, object p2, object p3);
    internal static Exception ExpectedBoundEvent(object p0);
    internal static Exception UnexpectedType(object p0, object p1);
    internal static Exception MemberWriteOnly(object p0);
    internal static Exception NoCodeToCompile();
    internal static Exception InvalidStreamType(object p0);
    internal static Exception QueueEmpty();
    internal static Exception EnumerationNotStarted();
    internal static Exception EnumerationFinished();
    internal static Exception CantAddCasing(object p0);
    internal static Exception CantAddIdentifier(object p0);
    internal static Exception InvalidOutputDir();
    internal static Exception InvalidAsmNameOrExtension();
    internal static Exception CanotEmitConstant(object p0, object p1);
    internal static Exception NoImplicitCast(object p0, object p1);
    internal static Exception NoExplicitCast(object p0, object p1);
    internal static Exception NameNotDefined(object p0);
    internal static Exception NoDefaultValue();
    internal static Exception UnknownLanguageProviderType();
    internal static Exception CantReadProperty();
    internal static Exception CantWriteProperty();
    internal static Exception IllegalNew_GenericParams(object p0);
    internal static Exception VerificationException(object p0, object p1, object p2);
}
internal class Microsoft.Scripting.FileStreamContentProvider : StreamContentProvider {
    private string _path;
    private PALHolder _pal;
    internal string Path { get; }
    internal FileStreamContentProvider(PlatformAdaptationLayer pal, string path);
    internal string get_Path();
    public virtual Stream GetStream();
}
public class Microsoft.Scripting.Generation.ActionRef`2 : MulticastDelegate {
    public ActionRef`2(object object, IntPtr method);
    public virtual void Invoke(T0& arg0, T1& arg1);
    public virtual IAsyncResult BeginInvoke(T0& arg0, T1& arg1, AsyncCallback callback, object object);
    public virtual void EndInvoke(T0& arg0, T1& arg1, IAsyncResult result);
}
public class Microsoft.Scripting.Generation.AssemblyGen : object {
    private AssemblyBuilder _myAssembly;
    private ModuleBuilder _myModule;
    private bool _isDebuggable;
    private int _index;
    private static MethodAttributes CtorAttributes;
    private static MethodImplAttributes ImplAttributes;
    private static MethodAttributes InvokeAttributes;
    private static TypeAttributes DelegateAttributes;
    private static Type[] _DelegateCtorSignature;
    internal bool IsDebuggable { get; }
    public AssemblyBuilder AssemblyBuilder { get; }
    public ModuleBuilder ModuleBuilder { get; }
    public AssemblyGen(AssemblyName name, string outDir, string outFileExtension, bool isDebuggable, IDictionary`2<string, object> attrs);
    private static AssemblyGen();
    internal bool get_IsDebuggable();
    internal void SetDebuggableAttributes();
    public string SaveAssembly();
    internal void Verify();
    internal static void PeVerifyAssemblyFile(string fileLocation);
    public TypeBuilder DefinePublicType(string name, Type parent, bool preserveName);
    internal TypeBuilder DefineType(string name, Type parent, TypeAttributes attr, bool preserveName);
    public AssemblyBuilder get_AssemblyBuilder();
    public ModuleBuilder get_ModuleBuilder();
    public Type MakeDelegateType(string name, Type[] parameters, Type returnType);
}
[ExtensionAttribute]
public static class Microsoft.Scripting.Generation.CompilerHelpers : object {
    public static MethodAttributes PublicStatic;
    private static MethodInfo _CreateInstanceMethod;
    private static int _Counter;
    private static CompilerHelpers();
    public static object GetMissingValue(Type type);
    public static bool IsStatic(MethodBase mi);
    public static bool IsConstructor(MethodBase mb);
    public static T[] MakeRepeatedArray(T item, int count);
    public static bool IsComparisonOperator(ExpressionType op);
    public static Type GetType(object obj);
    public static Type[] GetTypes(Object[] args);
    public static bool TypesEqual(IList args, int start, Type[] types);
    public static bool CanOptimizeMethod(MethodBase method);
    public static MethodInfo TryGetCallableMethod(Type targetType, MethodInfo method);
    public static IEnumerable`1<MemberInfo> FilterNonVisibleMembers(Type targetType, IEnumerable`1<MemberInfo> members);
    [IteratorStateMachineAttribute("Microsoft.Scripting.Generation.CompilerHelpers/<FilterNonVisibleMembersIterator>d__14")]
public static IEnumerable`1<MemberInfo> FilterNonVisibleMembersIterator(Type targetType, IEnumerable`1<MemberInfo> members);
    public static MemberInfo TryGetVisibleMember(Type targetType, MemberInfo member);
    [ExtensionAttribute]
public static bool MemberEquals(MemberInfo self, MemberInfo other);
    public static bool IsVisible(MethodBase info);
    public static bool IsVisible(FieldInfo info);
    [ExtensionAttribute]
public static bool IsProtected(MethodBase info);
    [ExtensionAttribute]
public static bool IsProtected(FieldInfo info);
    [ExtensionAttribute]
public static bool IsProtected(Type type);
    public static Type GetVisibleType(object value);
    public static Type GetVisibleType(Type t);
    public static MethodBase[] GetConstructors(Type t, bool privateBinding);
    public static MethodBase[] GetConstructors(Type t, bool privateBinding, bool includeProtected);
    [IteratorStateMachineAttribute("Microsoft.Scripting.Generation.CompilerHelpers/<FilterConstructorsToPublicAndProtected>d__26")]
public static IEnumerable`1<ConstructorInfo> FilterConstructorsToPublicAndProtected(IEnumerable`1<ConstructorInfo> ctors);
    private static MethodBase GetStructDefaultCtor(Type t);
    private static MethodBase GetArrayCtor(Type t);
    public static MethodInfo GetImplicitConverter(Type fromType, Type toType);
    public static MethodInfo GetExplicitConverter(Type fromType, Type toType);
    private static MethodInfo GetConverter(Type type, Type fromType, Type toType, string opMethodName);
    public static bool TryImplicitConversion(object value, Type to, Object& result);
    private static bool TryImplicitConvert(object value, Type to, IEnumerable`1<MethodInfo> implicitConv, Object& result);
    public static bool IsStrongBox(object target);
    public static bool IsStrongBox(Type t);
    public static Expression GetTryConvertReturnValue(Type type);
    public static bool HasTypeConverter(Type fromType, Type toType);
    public static bool TryApplyTypeConverter(object value, Type toType, Object& result);
    public static bool TryGetTypeConverter(Type fromType, Type toType, TypeConverter& converter);
    public static MethodBase[] GetMethodTargets(object obj);
    private static MethodBase[] MakeCallSignatureForCallableObject(Type t);
    public static Type[] GetSiteTypes(IList`1<Expression> arguments, Type returnType);
    public static Type[] GetExpressionTypes(Expression[] expressions);
    public static Type MakeCallSiteType(Type[] types);
    public static Type MakeCallSiteDelegateType(Type[] types);
    [ExtensionAttribute]
public static Delegate LightCompile(LambdaExpression lambda);
    [ExtensionAttribute]
public static Delegate LightCompile(LambdaExpression lambda, int compilationThreshold);
    [ExtensionAttribute]
public static T LightCompile(Expression`1<T> lambda);
    [ExtensionAttribute]
public static T LightCompile(Expression`1<T> lambda, int compilationThreshold);
    [ExtensionAttribute]
public static T Compile(Expression`1<T> lambda, bool emitDebugSymbols);
    public static string GetUniqueMethodName();
    public static bool CanEmitConstant(object value, Type type);
    internal static bool CanEmitILConstant(Type type);
    public static Expression Reduce(DynamicExpression node);
    [ObsoleteAttribute("Use CreateBigInteger instead.")]
public static BigInteger CreateBigInt(int value);
    public static BigInteger CreateBigInteger(int value);
    [ObsoleteAttribute("Use CreateBigInteger instead.")]
public static BigInteger CreateBigInt(long value);
    public static BigInteger CreateBigInteger(long value);
    [ObsoleteAttribute("Use CreateBigInteger instead.")]
public static BigInteger CreateBigInt(bool isNegative, Byte[] data);
    public static BigInteger CreateBigInteger(bool isNegative, Byte[] data);
}
public static class Microsoft.Scripting.Generation.ConstantCheck : object {
    public static bool Check(Expression expression, object value);
    internal static bool IsConstant(Expression e, object value);
    internal static bool IsNull(Expression e);
    private static bool CheckAndAlso(BinaryExpression node, object value);
    private static bool CheckOrElse(BinaryExpression node, object value);
    private static bool CheckConstant(ConstantExpression node, object value);
    private static bool Check(TypeBinaryExpression node, object value);
}
internal static class Microsoft.Scripting.Generation.DelegateHelpers : object {
    private static Dictionary`2<ICollection`1<Type>, Type> _DelegateTypes;
    private static int MaximumArity;
    private static Type MakeCustomDelegate(Type[] types);
    private static Type MakeNewCustomDelegate(Type[] types);
    internal static Type MakeDelegate(Type[] types);
}
public abstract class Microsoft.Scripting.Generation.DynamicILGen : ILGen {
    internal DynamicILGen(ILGenerator il);
    public T CreateDelegate();
    public abstract virtual T CreateDelegate(MethodInfo& mi);
    public abstract virtual MethodInfo Finish();
}
internal class Microsoft.Scripting.Generation.DynamicILGenMethod : DynamicILGen {
    private DynamicMethod _dm;
    internal DynamicILGenMethod(DynamicMethod dm, ILGenerator il);
    public virtual T CreateDelegate(MethodInfo& mi);
    public virtual MethodInfo Finish();
}
internal class Microsoft.Scripting.Generation.DynamicILGenType : DynamicILGen {
    private TypeBuilder _tb;
    private MethodBuilder _mb;
    internal DynamicILGenType(TypeBuilder tb, MethodBuilder mb, ILGenerator il);
    public virtual T CreateDelegate(MethodInfo& mi);
    private MethodInfo CreateMethod();
    public virtual MethodInfo Finish();
}
public class Microsoft.Scripting.Generation.EmitArrayHelper : MulticastDelegate {
    public EmitArrayHelper(object object, IntPtr method);
    public virtual void Invoke(int index);
    public virtual IAsyncResult BeginInvoke(int index, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
public class Microsoft.Scripting.Generation.FieldBuilderExpression : Expression {
    private FieldBuilder _builder;
    private StrongBox`1<Type> _finishedType;
    public bool CanReduce { get; }
    public ExpressionType NodeType { get; }
    public Type Type { get; }
    public FieldBuilderExpression(FieldBuilder builder, StrongBox`1<Type> finishedType);
    public virtual bool get_CanReduce();
    public sealed virtual ExpressionType get_NodeType();
    public sealed virtual Type get_Type();
    public virtual Expression Reduce();
    private FieldInfo GetFieldInfo();
    protected virtual Expression VisitChildren(ExpressionVisitor visitor);
}
public static class Microsoft.Scripting.Generation.GeneratorOps : object {
    public static object BoxGeneric(T value);
}
public class Microsoft.Scripting.Generation.ILGen : object {
    private ILGenerator _ilg;
    private KeyedQueue`2<Type, LocalBuilder> _freeLocals;
    public ILGen(ILGenerator ilg);
    public virtual void BeginCatchBlock(Type exceptionType);
    public virtual void BeginExceptFilterBlock();
    public virtual Label BeginExceptionBlock();
    public virtual void BeginFaultBlock();
    public virtual void BeginFinallyBlock();
    public virtual void EndExceptionBlock();
    public virtual void BeginScope();
    public virtual void EndScope();
    public virtual LocalBuilder DeclareLocal(Type localType);
    public virtual LocalBuilder DeclareLocal(Type localType, bool pinned);
    public virtual Label DefineLabel();
    public virtual void MarkLabel(Label loc);
    public virtual void Emit(OpCode opcode);
    public virtual void Emit(OpCode opcode, byte arg);
    public virtual void Emit(OpCode opcode, ConstructorInfo con);
    public virtual void Emit(OpCode opcode, double arg);
    public virtual void Emit(OpCode opcode, FieldInfo field);
    public virtual void Emit(OpCode opcode, float arg);
    public virtual void Emit(OpCode opcode, int arg);
    public virtual void Emit(OpCode opcode, Label label);
    public virtual void Emit(OpCode opcode, Label[] labels);
    public virtual void Emit(OpCode opcode, LocalBuilder local);
    public virtual void Emit(OpCode opcode, long arg);
    public virtual void Emit(OpCode opcode, MethodInfo meth);
    [CLSCompliantAttribute("False")]
public virtual void Emit(OpCode opcode, sbyte arg);
    public virtual void Emit(OpCode opcode, short arg);
    public virtual void Emit(OpCode opcode, SignatureHelper signature);
    public virtual void Emit(OpCode opcode, string str);
    public virtual void Emit(OpCode opcode, Type cls);
    public virtual void EmitCall(OpCode opcode, MethodInfo methodInfo, Type[] optionalParameterTypes);
    public virtual void EmitCalli(OpCode opcode, CallingConvention unmanagedCallConv, Type returnType, Type[] parameterTypes);
    public virtual void EmitCalli(OpCode opcode, CallingConventions callingConvention, Type returnType, Type[] parameterTypes, Type[] optionalParameterTypes);
    public virtual void UsingNamespace(string usingNamespace);
    [ConditionalAttribute("DEBUG")]
internal void EmitDebugWriteLine(string message);
    internal void Emit(OpCode opcode, MethodBase methodBase);
    public void EmitLoadArg(int index);
    public void EmitLoadArgAddress(int index);
    public void EmitStoreArg(int index);
    public void EmitLoadValueIndirect(Type type);
    public void EmitStoreValueIndirect(Type type);
    public void EmitLoadElement(Type type);
    public void EmitStoreElement(Type type);
    public void EmitType(Type type);
    public void EmitUnbox(Type type);
    public void EmitPropertyGet(PropertyInfo pi);
    public void EmitPropertySet(PropertyInfo pi);
    public void EmitFieldAddress(FieldInfo fi);
    public void EmitFieldGet(FieldInfo fi);
    public void EmitFieldSet(FieldInfo fi);
    public void EmitNew(ConstructorInfo ci);
    public void EmitNew(Type type, Type[] paramTypes);
    public void EmitCall(MethodInfo mi);
    public void EmitCall(Type type, string name);
    public void EmitCall(Type type, string name, Type[] paramTypes);
    public void EmitNull();
    public void EmitString(string value);
    public void EmitBoolean(bool value);
    public void EmitChar(char value);
    public void EmitByte(byte value);
    [CLSCompliantAttribute("False")]
public void EmitSByte(sbyte value);
    public void EmitShort(short value);
    [CLSCompliantAttribute("False")]
public void EmitUShort(ushort value);
    public void EmitInt(int value);
    [CLSCompliantAttribute("False")]
public void EmitUInt(UInt32 value);
    public void EmitLong(long value);
    [CLSCompliantAttribute("False")]
public void EmitULong(ulong value);
    public void EmitDouble(double value);
    public void EmitSingle(float value);
    private void EmitSimpleConstant(object value);
    internal bool TryEmitConstant(object value, Type type);
    public static bool ShouldLdtoken(Type t);
    public static bool ShouldLdtoken(MethodBase mb);
    private bool TryEmitILConstant(object value, Type type);
    public void EmitImplicitCast(Type from, Type to);
    public void EmitExplicitCast(Type from, Type to);
    public bool TryEmitImplicitCast(Type from, Type to);
    public bool TryEmitExplicitCast(Type from, Type to);
    private bool TryEmitCast(Type from, Type to, bool implicitOnly);
    public bool EmitNumericCast(Type from, Type to, bool implicitOnly);
    public void EmitBoxing(Type type);
    internal void EmitConvertToType(Type typeFrom, Type typeTo, bool isChecked);
    private void EmitCastToType(Type typeFrom, Type typeTo);
    private void EmitNumericConversion(Type typeFrom, Type typeTo, bool isChecked);
    private void EmitNullableToNullableConversion(Type typeFrom, Type typeTo, bool isChecked);
    private void EmitNonNullableToNullableConversion(Type typeFrom, Type typeTo, bool isChecked);
    private void EmitNullableToNonNullableConversion(Type typeFrom, Type typeTo, bool isChecked);
    private void EmitNullableToNonNullableStructConversion(Type typeFrom, Type typeTo, bool isChecked);
    private void EmitNullableToReferenceConversion(Type typeFrom);
    private void EmitNullableConversion(Type typeFrom, Type typeTo, bool isChecked);
    internal void EmitHasValue(Type nullableType);
    internal void EmitGetValue(Type nullableType);
    internal void EmitGetValueOrDefault(Type nullableType);
    public void EmitArray(IList`1<T> items);
    public void EmitArray(Type elementType, int count, EmitArrayHelper emit);
    public void EmitArray(Type arrayType);
    public void EmitDecimal(decimal value);
    private void EmitDecimalBits(decimal value);
    internal void EmitDefault(Type type);
    public void EmitMissingValue(Type type);
    internal LocalBuilder GetLocal(Type type);
    internal void FreeLocal(LocalBuilder local);
}
internal class Microsoft.Scripting.Generation.KeyedQueue`2 : object {
    private Dictionary`2<K, Queue`1<V>> _data;
    internal void Enqueue(K key, V value);
    internal V Dequeue(K key);
    internal bool TryDequeue(K key, V& value);
    internal V Peek(K key);
    internal int GetCount(K key);
    internal void Clear();
}
public class Microsoft.Scripting.Generation.MethodSignatureInfo : object {
    private ParameterInfo[] _pis;
    private bool _isStatic;
    private int _genericArity;
    public MethodSignatureInfo(MethodInfo info);
    public MethodSignatureInfo(bool isStatic, ParameterInfo[] pis, int genericArity);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
}
internal class Microsoft.Scripting.Generation.ReturnFixer : object {
    private LocalBuilder _refSlot;
    private int _argIndex;
    private Type _argType;
    private ReturnFixer(LocalBuilder refSlot, int argIndex, Type argType);
    internal static ReturnFixer EmitArgument(ILGen cg, int argIndex, Type argType);
    internal void FixReturn(ILGen cg);
}
public class Microsoft.Scripting.Generation.Snippets : object {
    public static Snippets Shared;
    private int _methodNameIndex;
    private AssemblyGen _assembly;
    private AssemblyGen _debugAssembly;
    private string _snippetsDirectory;
    private bool _saveSnippets;
    private static Type[] _DelegateCtorSignature;
    public string SnippetsDirectory { get; }
    public bool SaveSnippets { get; }
    private static Snippets();
    public string get_SnippetsDirectory();
    public bool get_SaveSnippets();
    private AssemblyGen GetAssembly(bool emitSymbols);
    private AssemblyGen GetOrCreateAssembly(bool emitSymbols, AssemblyGen& assembly);
    private AssemblyGen CreateNewAssembly(string nameSuffix, bool emitSymbols);
    public static void SetSaveAssemblies(bool enable, string directory);
    private void ConfigureSaveAssemblies(bool enable, string directory);
    public static void SaveAndVerifyAssemblies();
    private String[] SaveAssemblies();
    public TypeBuilder DefinePublicType(string name, Type parent);
    public TypeGen DefineType(string name, Type parent, bool preserveName, bool emitDebugSymbols);
    public TypeBuilder DefineDelegateType(string name);
    public Type DefineDelegate(string name, Type returnType, Type[] argTypes);
    public bool IsSnippetsAssembly(Assembly asm);
    public DynamicILGen CreateDynamicMethod(string methodName, Type returnType, Type[] parameterTypes, bool isDebuggable);
    internal DynamicMethod CreateDynamicMethod(string name, Type returnType, Type[] parameterTypes);
}
internal static class Microsoft.Scripting.Generation.SymbolGuids : object {
    internal static Guid LanguageType_ILAssembly;
    internal static Guid DocumentType_Text;
    internal static Guid LanguageVendor_Microsoft;
    private static SymbolGuids();
}
internal class Microsoft.Scripting.Generation.ToDiskRewriter : DynamicExpressionVisitor {
    private static int _uniqueNameId;
    private List`1<Expression> _constants;
    private Dictionary`2<object, Expression> _constantCache;
    private ParameterExpression _constantPool;
    private Dictionary`2<Type, Type> _delegateTypes;
    private int _depth;
    private TypeGen _typeGen;
    internal ToDiskRewriter(TypeGen typeGen);
    public LambdaExpression RewriteLambda(LambdaExpression lambda);
    protected virtual Expression VisitLambda(Expression`1<T> node);
    protected virtual Expression VisitExtension(Expression node);
    protected virtual Expression VisitConstant(ConstantExpression node);
    protected virtual Expression VisitDynamic(DynamicExpression node);
    private bool RewriteDelegate(Type delegateType, Type& newDelegateType);
    private bool ShouldRewriteDelegate(Type delegateType);
    private Expression RewriteCallSite(CallSite site);
    private void EnsureConstantPool();
}
public class Microsoft.Scripting.Generation.TypeGen : object {
    private ILGen _initGen;
    [CompilerGeneratedAttribute]
private AssemblyGen <AssemblyGen>k__BackingField;
    [CompilerGeneratedAttribute]
private TypeBuilder <TypeBuilder>k__BackingField;
    private static MethodAttributes MethodAttributesToEraseInOveride;
    public ILGen TypeInitializer { get; }
    internal AssemblyGen AssemblyGen { get; }
    public TypeBuilder TypeBuilder { get; }
    public TypeGen(AssemblyGen myAssembly, TypeBuilder myType);
    public ILGen get_TypeInitializer();
    [CompilerGeneratedAttribute]
internal AssemblyGen get_AssemblyGen();
    [CompilerGeneratedAttribute]
public TypeBuilder get_TypeBuilder();
    public virtual string ToString();
    public Type FinishType();
    public FieldBuilder AddStaticField(Type fieldType, string name);
    public FieldBuilder AddStaticField(Type fieldType, FieldAttributes attributes, string name);
    public ILGen DefineExplicitInterfaceImplementation(MethodInfo baseMethod);
    public ILGen DefineMethodOverride(MethodInfo baseMethod);
}
public class Microsoft.Scripting.Hosting.Shell.BasicConsole : object {
    private TextWriter _output;
    private TextWriter _errorOutput;
    [CompilerGeneratedAttribute]
private AutoResetEvent <CtrlCEvent>k__BackingField;
    [CompilerGeneratedAttribute]
private Thread <CreatingThread>k__BackingField;
    [CompilerGeneratedAttribute]
private ConsoleCancelEventHandler <ConsoleCancelEventHandler>k__BackingField;
    private ConsoleColor _promptColor;
    private ConsoleColor _outColor;
    private ConsoleColor _errorColor;
    private ConsoleColor _warningColor;
    public TextWriter Output { get; public set; }
    public TextWriter ErrorOutput { get; public set; }
    protected AutoResetEvent CtrlCEvent { get; protected set; }
    protected Thread CreatingThread { get; protected set; }
    public ConsoleCancelEventHandler ConsoleCancelEventHandler { get; public set; }
    public BasicConsole(bool colorful);
    public sealed virtual TextWriter get_Output();
    public sealed virtual void set_Output(TextWriter value);
    public sealed virtual TextWriter get_ErrorOutput();
    public sealed virtual void set_ErrorOutput(TextWriter value);
    [CompilerGeneratedAttribute]
protected AutoResetEvent get_CtrlCEvent();
    [CompilerGeneratedAttribute]
protected void set_CtrlCEvent(AutoResetEvent value);
    [CompilerGeneratedAttribute]
protected Thread get_CreatingThread();
    [CompilerGeneratedAttribute]
protected void set_CreatingThread(Thread value);
    [CompilerGeneratedAttribute]
public ConsoleCancelEventHandler get_ConsoleCancelEventHandler();
    [CompilerGeneratedAttribute]
public void set_ConsoleCancelEventHandler(ConsoleCancelEventHandler value);
    private void SetupColors(bool colorful);
    private static ConsoleColor PickColor(ConsoleColor best, ConsoleColor other);
    private static bool IsDark(ConsoleColor color);
    private static ConsoleColor MakeLight(ConsoleColor color);
    private static ConsoleColor MakeDark(ConsoleColor color);
    protected void WriteColor(TextWriter output, string str, ConsoleColor c);
    public virtual string ReadLine(int autoIndentSize);
    public virtual void Write(string text, Style style);
    public sealed virtual void WriteLine(string text, Style style);
    public sealed virtual void WriteLine();
    public sealed virtual void Dispose();
    [CompilerGeneratedAttribute]
private void <.ctor>b__24_0(object sender, ConsoleCancelEventArgs e);
    [CompilerGeneratedAttribute]
private void <.ctor>b__24_1(object sender, ConsoleCancelEventArgs e);
}
public class Microsoft.Scripting.Hosting.Shell.CommandLine : object {
    private LanguageContext _language;
    private IConsole _console;
    private ConsoleOptions _options;
    private ScriptScope _scope;
    private ScriptEngine _engine;
    private ICommandDispatcher _commandDispatcher;
    private Nullable`1<int> _terminatingExitCode;
    private int _exitCode;
    protected IConsole Console { get; }
    protected ConsoleOptions Options { get; }
    protected ScriptEngine Engine { get; }
    public ScriptScope ScriptScope { get; protected set; }
    public int ExitCode { get; protected set; }
    protected Scope Scope { get; protected set; }
    protected LanguageContext Language { get; }
    protected string Prompt { get; }
    public string PromptContinuation { get; }
    protected string Logo { get; }
    protected ErrorSink ErrorSink { get; }
    protected IConsole get_Console();
    protected ConsoleOptions get_Options();
    protected ScriptEngine get_Engine();
    public ScriptScope get_ScriptScope();
    protected void set_ScriptScope(ScriptScope value);
    public int get_ExitCode();
    protected void set_ExitCode(int value);
    protected Scope get_Scope();
    protected void set_Scope(Scope value);
    protected LanguageContext get_Language();
    protected virtual string get_Prompt();
    public virtual string get_PromptContinuation();
    protected virtual string get_Logo();
    protected virtual void Initialize();
    protected virtual Scope CreateScope();
    protected virtual ICommandDispatcher CreateCommandDispatcher();
    public virtual void Terminate(int exitCode);
    public void Run(ScriptEngine engine, IConsole console, ConsoleOptions options);
    protected virtual int Run();
    protected virtual void Shutdown();
    protected virtual int RunFile(string fileName);
    protected virtual int RunCommand(string command);
    protected virtual int RunFile(ScriptSource source);
    protected void PrintLogo();
    protected virtual int RunInteractive();
    protected virtual int RunInteractiveLoop();
    internal static bool IsFatalException(Exception e);
    protected virtual void UnhandledException(Exception e);
    protected virtual Nullable`1<int> TryInteractiveAction();
    private Nullable`1<int> RunOneInteraction();
    protected virtual void ExecuteCommand(string command);
    protected object ExecuteCommand(ScriptSource source);
    protected virtual ErrorSink get_ErrorSink();
    private static bool TreatAsBlankLine(string line, int autoIndentSize);
    protected string ReadStatement(Boolean& continueInteraction);
    protected virtual ScriptCodeParseResult GetCommandProperties(string code);
    protected virtual int GetNextAutoIndentSize(string text);
    protected virtual string ReadLine(int autoIndentSize);
    protected internal virtual TextWriter GetOutputWriter(bool isErrorOutput);
    public IList`1<string> GetMemberNames(string code);
    public virtual IList`1<string> GetGlobals(string name);
}
public abstract class Microsoft.Scripting.Hosting.Shell.ConsoleHost : object {
    private int _exitCode;
    private ConsoleHostOptionsParser _optionsParser;
    private ScriptRuntime _runtime;
    private ScriptEngine _engine;
    private ConsoleOptions _consoleOptions;
    private IConsole _console;
    private CommandLine _commandLine;
    public ConsoleHostOptions Options { get; }
    public ScriptRuntimeSetup RuntimeSetup { get; }
    public ScriptEngine Engine { get; protected set; }
    public ScriptRuntime Runtime { get; protected set; }
    protected int ExitCode { get; protected set; }
    protected ConsoleHostOptionsParser ConsoleHostOptionsParser { get; protected set; }
    protected IConsole ConsoleIO { get; protected set; }
    protected CommandLine CommandLine { get; }
    protected string ExeName { get; }
    protected PlatformAdaptationLayer PlatformAdaptationLayer { get; }
    protected Type Provider { get; }
    public ConsoleHostOptions get_Options();
    public ScriptRuntimeSetup get_RuntimeSetup();
    public ScriptEngine get_Engine();
    protected void set_Engine(ScriptEngine value);
    public ScriptRuntime get_Runtime();
    protected void set_Runtime(ScriptRuntime value);
    protected int get_ExitCode();
    protected void set_ExitCode(int value);
    protected ConsoleHostOptionsParser get_ConsoleHostOptionsParser();
    protected void set_ConsoleHostOptionsParser(ConsoleHostOptionsParser value);
    protected IConsole get_ConsoleIO();
    protected void set_ConsoleIO(IConsole value);
    protected CommandLine get_CommandLine();
    protected virtual string get_ExeName();
    protected virtual void ParseHostOptions(String[] args);
    protected virtual ScriptRuntimeSetup CreateRuntimeSetup();
    protected virtual LanguageSetup CreateLanguageSetup();
    protected virtual PlatformAdaptationLayer get_PlatformAdaptationLayer();
    protected virtual Type get_Provider();
    private string GetLanguageProvider(ScriptRuntimeSetup setup);
    protected virtual CommandLine CreateCommandLine();
    protected virtual OptionsParser CreateOptionsParser();
    protected virtual IConsole CreateConsole(ScriptEngine engine, CommandLine commandLine, ConsoleOptions options);
    private static IConsole CreateSuperConsole(CommandLine commandLine, bool isColorful);
    public virtual void Terminate(int exitCode);
    public virtual int Run(String[] args);
    protected virtual ConsoleOptions ParseOptions(String[] args, ScriptRuntimeSetup runtimeSetup, LanguageSetup languageSetup);
    protected virtual void ReportInvalidOption(InvalidOptionException e);
    private static void InsertSearchPaths(IDictionary`2<string, object> options, ICollection`1<string> paths);
    protected virtual void PrintHelp();
    protected virtual string GetHelp();
    public virtual void PrintLanguageHelp(StringBuilder output);
    private void Execute();
    protected virtual void ExecuteInternal();
    private void SetEnvironment();
    private int RunFile();
    private int RunCommandLine();
    protected virtual void PrintUsage();
    protected virtual void PrintVersion();
    private static string GetRuntime();
    protected virtual void UnhandledException(ScriptEngine engine, Exception e);
    protected static void PrintException(TextWriter output, Exception e);
}
public class Microsoft.Scripting.Hosting.Shell.ConsoleHostOptions : object {
    [CompilerGeneratedAttribute]
private List`1<string> <IgnoredArgs>k__BackingField;
    [CompilerGeneratedAttribute]
private string <RunFile>k__BackingField;
    [CompilerGeneratedAttribute]
private String[] <SourceUnitSearchPaths>k__BackingField;
    [CompilerGeneratedAttribute]
private Action <RunAction>k__BackingField;
    [CompilerGeneratedAttribute]
private List`1<string> <EnvironmentVars>k__BackingField;
    [CompilerGeneratedAttribute]
private string <LanguageProvider>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <HasLanguageProvider>k__BackingField;
    public List`1<string> IgnoredArgs { get; }
    public string RunFile { get; public set; }
    public String[] SourceUnitSearchPaths { get; public set; }
    public Action RunAction { get; public set; }
    public List`1<string> EnvironmentVars { get; }
    public string LanguageProvider { get; public set; }
    public bool HasLanguageProvider { get; public set; }
    [CompilerGeneratedAttribute]
public List`1<string> get_IgnoredArgs();
    [CompilerGeneratedAttribute]
public string get_RunFile();
    [CompilerGeneratedAttribute]
public void set_RunFile(string value);
    [CompilerGeneratedAttribute]
public String[] get_SourceUnitSearchPaths();
    [CompilerGeneratedAttribute]
public void set_SourceUnitSearchPaths(String[] value);
    [CompilerGeneratedAttribute]
public Action get_RunAction();
    [CompilerGeneratedAttribute]
public void set_RunAction(Action value);
    [CompilerGeneratedAttribute]
public List`1<string> get_EnvironmentVars();
    [CompilerGeneratedAttribute]
public string get_LanguageProvider();
    [CompilerGeneratedAttribute]
public void set_LanguageProvider(string value);
    [CompilerGeneratedAttribute]
public bool get_HasLanguageProvider();
    [CompilerGeneratedAttribute]
public void set_HasLanguageProvider(bool value);
    public String[0...,0...] GetHelp();
}
public class Microsoft.Scripting.Hosting.Shell.ConsoleHostOptionsParser : object {
    [CompilerGeneratedAttribute]
private ConsoleHostOptions <Options>k__BackingField;
    [CompilerGeneratedAttribute]
private ScriptRuntimeSetup <RuntimeSetup>k__BackingField;
    public ConsoleHostOptions Options { get; }
    public ScriptRuntimeSetup RuntimeSetup { get; }
    public ConsoleHostOptionsParser(ConsoleHostOptions options, ScriptRuntimeSetup runtimeSetup);
    [CompilerGeneratedAttribute]
public ConsoleHostOptions get_Options();
    [CompilerGeneratedAttribute]
public ScriptRuntimeSetup get_RuntimeSetup();
    public void Parse(String[] args);
    private void ParseOption(string arg, String& name, String& value);
    protected void OptionValueRequired(string optionName, string value);
}
public class Microsoft.Scripting.Hosting.Shell.ConsoleOptions : object {
    private string _command;
    private string _filename;
    private bool _printVersion;
    private bool _exit;
    private int _autoIndentSize;
    private String[] _remainingArgs;
    private bool _introspection;
    private bool _autoIndent;
    private bool _handleExceptions;
    private bool _tabCompletion;
    private bool _colorfulConsole;
    private bool _printUsage;
    private bool _isMta;
    public bool AutoIndent { get; public set; }
    public bool HandleExceptions { get; public set; }
    public bool TabCompletion { get; public set; }
    public bool ColorfulConsole { get; public set; }
    public bool PrintUsage { get; public set; }
    public string Command { get; public set; }
    public string FileName { get; public set; }
    public bool PrintVersion { get; public set; }
    public bool Exit { get; public set; }
    public int AutoIndentSize { get; public set; }
    public String[] RemainingArgs { get; public set; }
    public bool Introspection { get; public set; }
    public bool IsMta { get; public set; }
    protected ConsoleOptions(ConsoleOptions options);
    public bool get_AutoIndent();
    public void set_AutoIndent(bool value);
    public bool get_HandleExceptions();
    public void set_HandleExceptions(bool value);
    public bool get_TabCompletion();
    public void set_TabCompletion(bool value);
    public bool get_ColorfulConsole();
    public void set_ColorfulConsole(bool value);
    public bool get_PrintUsage();
    public void set_PrintUsage(bool value);
    public string get_Command();
    public void set_Command(string value);
    public string get_FileName();
    public void set_FileName(string value);
    public bool get_PrintVersion();
    public void set_PrintVersion(bool value);
    public bool get_Exit();
    public void set_Exit(bool value);
    public int get_AutoIndentSize();
    public void set_AutoIndentSize(int value);
    public String[] get_RemainingArgs();
    public void set_RemainingArgs(String[] value);
    public bool get_Introspection();
    public void set_Introspection(bool value);
    public bool get_IsMta();
    public void set_IsMta(bool value);
}
public interface Microsoft.Scripting.Hosting.Shell.ICommandDispatcher {
    public abstract virtual object Execute(CompiledCode compiledCode, ScriptScope scope);
}
public interface Microsoft.Scripting.Hosting.Shell.IConsole {
    public TextWriter Output { get; public set; }
    public TextWriter ErrorOutput { get; public set; }
    public abstract virtual string ReadLine(int autoIndentSize);
    public abstract virtual void Write(string text, Style style);
    public abstract virtual void WriteLine(string text, Style style);
    public abstract virtual void WriteLine();
    public abstract virtual TextWriter get_Output();
    public abstract virtual void set_Output(TextWriter value);
    public abstract virtual TextWriter get_ErrorOutput();
    public abstract virtual void set_ErrorOutput(TextWriter value);
}
public class Microsoft.Scripting.Hosting.Shell.InvalidOptionException : Exception {
    public InvalidOptionException(string message);
    public InvalidOptionException(string message, Exception inner);
    protected InvalidOptionException(SerializationInfo info, StreamingContext context);
}
public abstract class Microsoft.Scripting.Hosting.Shell.OptionsParser : object {
    private ScriptRuntimeSetup _runtimeSetup;
    private LanguageSetup _languageSetup;
    private PlatformAdaptationLayer _platform;
    private List`1<string> _ignoredArgs;
    private String[] _args;
    private int _current;
    public ScriptRuntimeSetup RuntimeSetup { get; }
    public LanguageSetup LanguageSetup { get; }
    public PlatformAdaptationLayer Platform { get; }
    public ConsoleOptions CommonConsoleOptions { get; }
    public IList`1<string> IgnoredArgs { get; }
    public ScriptRuntimeSetup get_RuntimeSetup();
    public LanguageSetup get_LanguageSetup();
    public PlatformAdaptationLayer get_Platform();
    public abstract virtual ConsoleOptions get_CommonConsoleOptions();
    public IList`1<string> get_IgnoredArgs();
    public void Parse(String[] args, ScriptRuntimeSetup setup, LanguageSetup languageSetup, PlatformAdaptationLayer platform);
    protected virtual void BeforeParse();
    protected virtual void AfterParse();
    protected abstract virtual void ParseArgument(string arg);
    protected void IgnoreRemainingArgs();
    protected String[] PopRemainingArgs();
    protected string PeekNextArg();
    protected string PopNextArg();
    protected void PushArgBack();
    protected static Exception InvalidOptionValue(string option, string value);
    public abstract virtual void GetHelp(String& commandLine, String[0...,0...]& options, String[0...,0...]& environmentVariables, String& comments);
}
public class Microsoft.Scripting.Hosting.Shell.OptionsParser`1 : OptionsParser {
    private TConsoleOptions _consoleOptions;
    public TConsoleOptions ConsoleOptions { get; public set; }
    public ConsoleOptions CommonConsoleOptions { get; }
    public TConsoleOptions get_ConsoleOptions();
    public void set_ConsoleOptions(TConsoleOptions value);
    public sealed virtual ConsoleOptions get_CommonConsoleOptions();
    protected virtual void ParseArgument(string arg);
    protected virtual void HandleImplementationSpecificOption(string arg, string val);
    internal static void SetDlrOption(string option);
    internal static void SetDlrOption(string option, string value);
    public virtual void GetHelp(String& commandLine, String[0...,0...]& options, String[0...,0...]& environmentVariables, String& comments);
}
public enum Microsoft.Scripting.Hosting.Shell.Style : Enum {
    public int value__;
    public static Style Prompt;
    public static Style Out;
    public static Style Error;
    public static Style Warning;
}
public class Microsoft.Scripting.Hosting.Shell.SuperConsole : BasicConsole {
    private StringBuilder _input;
    private int _current;
    private int _autoIndentSize;
    private int _rendered;
    private History _history;
    private SuperConsoleOptions _options;
    private Cursor _cursor;
    private CommandLine _commandLine;
    private EditMode _editMode;
    private static int TabSize;
    private string FinalLineText { get; }
    public SuperConsole(CommandLine commandLine, bool colorful);
    public SuperConsole(CommandLine commandLine, bool colorful, EditMode editMode);
    private bool GetOptions();
    private void SetInput(string line);
    private void Initialize();
    private bool BackspaceAutoIndentation();
    private void OnBackspace(ConsoleModifiers keyModifiers);
    private void OnDelete();
    private void Insert(ConsoleKeyInfo key);
    private void Insert(char c);
    private void DeleteTillEnd();
    private void DeleteFromStart();
    private static string MapCharacter(char c);
    private static int GetCharacterSize(char c);
    private void Render();
    private bool IsSeparator(char ch);
    private void MovePrevWordStart();
    private void MoveNextWordEnd();
    private void MoveNextWordStart();
    private void MoveLeft(ConsoleModifiers keyModifiers);
    private void MoveRight(ConsoleModifiers keyModifiers);
    private void MoveLeft();
    private void MoveRight();
    private void InsertTab();
    private void MoveHome();
    private void MoveEnd();
    public virtual string ReadLine(int autoIndentSize);
    private void DisplayNextOption(ConsoleKeyInfo key, bool prefix);
    private string OnEnter(bool inputChanged);
    private string get_FinalLineText();
}
public interface Microsoft.Scripting.ICustomScriptCodeData {
    public abstract virtual string GetCustomScriptCodeData();
}
internal class Microsoft.Scripting.Interpreter.ActionCallInstruction : CallInstruction {
    private Action _target;
    public MethodInfo Info { get; }
    public int ArgumentCount { get; }
    public ActionCallInstruction(Action target);
    public ActionCallInstruction(MethodInfo target);
    public virtual MethodInfo get_Info();
    public virtual int get_ArgumentCount();
    public virtual object Invoke();
    public virtual int Run(InterpretedFrame frame);
}
internal class Microsoft.Scripting.Interpreter.ActionCallInstruction`1 : CallInstruction {
    private Action`1<T0> _target;
    public MethodInfo Info { get; }
    public int ArgumentCount { get; }
    public ActionCallInstruction`1(Action`1<T0> target);
    public ActionCallInstruction`1(MethodInfo target);
    public virtual MethodInfo get_Info();
    public virtual int get_ArgumentCount();
    public virtual object Invoke(object arg0);
    public virtual int Run(InterpretedFrame frame);
}
internal class Microsoft.Scripting.Interpreter.ActionCallInstruction`2 : CallInstruction {
    private Action`2<T0, T1> _target;
    public MethodInfo Info { get; }
    public int ArgumentCount { get; }
    public ActionCallInstruction`2(Action`2<T0, T1> target);
    public ActionCallInstruction`2(MethodInfo target);
    public virtual MethodInfo get_Info();
    public virtual int get_ArgumentCount();
    public virtual object Invoke(object arg0, object arg1);
    public virtual int Run(InterpretedFrame frame);
}
internal class Microsoft.Scripting.Interpreter.ActionCallInstruction`3 : CallInstruction {
    private Action`3<T0, T1, T2> _target;
    public MethodInfo Info { get; }
    public int ArgumentCount { get; }
    public ActionCallInstruction`3(Action`3<T0, T1, T2> target);
    public ActionCallInstruction`3(MethodInfo target);
    public virtual MethodInfo get_Info();
    public virtual int get_ArgumentCount();
    public virtual object Invoke(object arg0, object arg1, object arg2);
    public virtual int Run(InterpretedFrame frame);
}
internal class Microsoft.Scripting.Interpreter.ActionCallInstruction`4 : CallInstruction {
    private Action`4<T0, T1, T2, T3> _target;
    public MethodInfo Info { get; }
    public int ArgumentCount { get; }
    public ActionCallInstruction`4(Action`4<T0, T1, T2, T3> target);
    public ActionCallInstruction`4(MethodInfo target);
    public virtual MethodInfo get_Info();
    public virtual int get_ArgumentCount();
    public virtual object Invoke(object arg0, object arg1, object arg2, object arg3);
    public virtual int Run(InterpretedFrame frame);
}
internal class Microsoft.Scripting.Interpreter.ActionCallInstruction`5 : CallInstruction {
    private Action`5<T0, T1, T2, T3, T4> _target;
    public MethodInfo Info { get; }
    public int ArgumentCount { get; }
    public ActionCallInstruction`5(Action`5<T0, T1, T2, T3, T4> target);
    public ActionCallInstruction`5(MethodInfo target);
    public virtual MethodInfo get_Info();
    public virtual int get_ArgumentCount();
    public virtual object Invoke(object arg0, object arg1, object arg2, object arg3, object arg4);
    public virtual int Run(InterpretedFrame frame);
}
internal class Microsoft.Scripting.Interpreter.ActionCallInstruction`6 : CallInstruction {
    private Action`6<T0, T1, T2, T3, T4, T5> _target;
    public MethodInfo Info { get; }
    public int ArgumentCount { get; }
    public ActionCallInstruction`6(Action`6<T0, T1, T2, T3, T4, T5> target);
    public ActionCallInstruction`6(MethodInfo target);
    public virtual MethodInfo get_Info();
    public virtual int get_ArgumentCount();
    public virtual object Invoke(object arg0, object arg1, object arg2, object arg3, object arg4, object arg5);
    public virtual int Run(InterpretedFrame frame);
}
internal class Microsoft.Scripting.Interpreter.ActionCallInstruction`7 : CallInstruction {
    private Action`7<T0, T1, T2, T3, T4, T5, T6> _target;
    public MethodInfo Info { get; }
    public int ArgumentCount { get; }
    public ActionCallInstruction`7(Action`7<T0, T1, T2, T3, T4, T5, T6> target);
    public ActionCallInstruction`7(MethodInfo target);
    public virtual MethodInfo get_Info();
    public virtual int get_ArgumentCount();
    public virtual object Invoke(object arg0, object arg1, object arg2, object arg3, object arg4, object arg5, object arg6);
    public virtual int Run(InterpretedFrame frame);
}
internal class Microsoft.Scripting.Interpreter.ActionCallInstruction`8 : CallInstruction {
    private Action`8<T0, T1, T2, T3, T4, T5, T6, T7> _target;
    public MethodInfo Info { get; }
    public int ArgumentCount { get; }
    public ActionCallInstruction`8(Action`8<T0, T1, T2, T3, T4, T5, T6, T7> target);
    public ActionCallInstruction`8(MethodInfo target);
    public virtual MethodInfo get_Info();
    public virtual int get_ArgumentCount();
    public virtual object Invoke(object arg0, object arg1, object arg2, object arg3, object arg4, object arg5, object arg6, object arg7);
    public virtual int Run(InterpretedFrame frame);
}
internal class Microsoft.Scripting.Interpreter.ActionCallInstruction`9 : CallInstruction {
    private Action`9<T0, T1, T2, T3, T4, T5, T6, T7, T8> _target;
    public MethodInfo Info { get; }
    public int ArgumentCount { get; }
    public ActionCallInstruction`9(Action`9<T0, T1, T2, T3, T4, T5, T6, T7, T8> target);
    public ActionCallInstruction`9(MethodInfo target);
    public virtual MethodInfo get_Info();
    public virtual int get_ArgumentCount();
    public virtual object Invoke(object arg0, object arg1, object arg2, object arg3, object arg4, object arg5, object arg6, object arg7, object arg8);
    public virtual int Run(InterpretedFrame frame);
}
internal abstract class Microsoft.Scripting.Interpreter.AddInstruction : Instruction {
    private static Instruction _Int16;
    private static Instruction _Int32;
    private static Instruction _Int64;
    private static Instruction _UInt16;
    private static Instruction _UInt32;
    private static Instruction _UInt64;
    private static Instruction _Single;
    private static Instruction _Double;
    public int ConsumedStack { get; }
    public int ProducedStack { get; }
    public virtual int get_ConsumedStack();
    public virtual int get_ProducedStack();
    public static Instruction Create(Type type);
    public virtual string ToString();
}
internal abstract class Microsoft.Scripting.Interpreter.AddOvfInstruction : Instruction {
    private static Instruction _Int16;
    private static Instruction _Int32;
    private static Instruction _Int64;
    private static Instruction _UInt16;
    private static Instruction _UInt32;
    private static Instruction _UInt64;
    public int ConsumedStack { get; }
    public int ProducedStack { get; }
    public virtual int get_ConsumedStack();
    public virtual int get_ProducedStack();
    public static Instruction Create(Type type);
    public virtual string ToString();
}
internal class Microsoft.Scripting.Interpreter.AssignLocalBoxedInstruction : LocalAccessInstruction {
    public int ConsumedStack { get; }
    public int ProducedStack { get; }
    internal AssignLocalBoxedInstruction(int index);
    public virtual int get_ConsumedStack();
    public virtual int get_ProducedStack();
    public virtual int Run(InterpretedFrame frame);
}
internal class Microsoft.Scripting.Interpreter.AssignLocalInstruction : LocalAccessInstruction {
    public int ConsumedStack { get; }
    public int ProducedStack { get; }
    internal AssignLocalInstruction(int index);
    public virtual int get_ConsumedStack();
    public virtual int get_ProducedStack();
    public virtual int Run(InterpretedFrame frame);
    public sealed virtual Instruction BoxIfIndexMatches(int index);
}
internal class Microsoft.Scripting.Interpreter.AssignLocalToClosureInstruction : LocalAccessInstruction {
    public int ConsumedStack { get; }
    public int ProducedStack { get; }
    internal AssignLocalToClosureInstruction(int index);
    public virtual int get_ConsumedStack();
    public virtual int get_ProducedStack();
    public virtual int Run(InterpretedFrame frame);
}
internal class Microsoft.Scripting.Interpreter.BranchFalseInstruction : OffsetInstruction {
    private static Instruction[] _cache;
    public Instruction[] Cache { get; }
    public int ConsumedStack { get; }
    public virtual Instruction[] get_Cache();
    public virtual int get_ConsumedStack();
    public virtual int Run(InterpretedFrame frame);
}
internal class Microsoft.Scripting.Interpreter.BranchInstruction : OffsetInstruction {
    private static Instruction[][][] _caches;
    internal bool _hasResult;
    internal bool _hasValue;
    public Instruction[] Cache { get; }
    public int ConsumedStack { get; }
    public int ProducedStack { get; }
    public BranchInstruction(bool hasResult, bool hasValue);
    public virtual Instruction[] get_Cache();
    public virtual int get_ConsumedStack();
    public virtual int get_ProducedStack();
    public virtual int Run(InterpretedFrame frame);
}
public class Microsoft.Scripting.Interpreter.BranchLabel : object {
    internal static int UnknownIndex;
    internal static int UnknownDepth;
    internal int _labelIndex;
    internal int _targetIndex;
    internal int _stackDepth;
    internal int _continuationStackDepth;
    private List`1<int> _forwardBranchFixups;
    internal int LabelIndex { get; internal set; }
    internal bool HasRuntimeLabel { get; }
    internal int TargetIndex { get; }
    internal int get_LabelIndex();
    internal void set_LabelIndex(int value);
    internal bool get_HasRuntimeLabel();
    internal int get_TargetIndex();
    internal RuntimeLabel ToRuntimeLabel();
    internal void Mark(InstructionList instructions);
    internal void AddBranch(InstructionList instructions, int branchIndex);
    internal void FixupBranch(InstructionList instructions, int branchIndex);
}
internal class Microsoft.Scripting.Interpreter.BranchTrueInstruction : OffsetInstruction {
    private static Instruction[] _cache;
    public Instruction[] Cache { get; }
    public int ConsumedStack { get; }
    public virtual Instruction[] get_Cache();
    public virtual int get_ConsumedStack();
    public virtual int Run(InterpretedFrame frame);
}
public abstract class Microsoft.Scripting.Interpreter.CallInstruction : Instruction {
    private static Dictionary`2<MethodInfo, CallInstruction> _cache;
    private static int MaxHelpers;
    private static int MaxArgs;
    public MethodInfo Info { get; }
    public int ArgumentCount { get; }
    public int ProducedStack { get; }
    public int ConsumedStack { get; }
    public string InstructionName { get; }
    private static CallInstruction();
    public abstract virtual MethodInfo get_Info();
    public abstract virtual int get_ArgumentCount();
    public static CallInstruction Create(MethodInfo info);
    public static CallInstruction Create(MethodInfo info, ParameterInfo[] parameters);
    private static CallInstruction GetArrayAccessor(MethodInfo info, int argumentCount);
    public static void ArrayItemSetter1(Array array, int index0, object value);
    public static void ArrayItemSetter2(Array array, int index0, int index1, object value);
    public static void ArrayItemSetter3(Array array, int index0, int index1, int index2, object value);
    private static bool ShouldCache(MethodInfo info);
    private static Type TryGetParameterOrReturnType(MethodInfo target, ParameterInfo[] pi, int index);
    private static bool IndexIsNotReturnType(int index, MethodInfo target, ParameterInfo[] pi);
    private static CallInstruction SlowCreate(MethodInfo info, ParameterInfo[] pis);
    public sealed virtual int get_ProducedStack();
    public sealed virtual int get_ConsumedStack();
    public sealed virtual string get_InstructionName();
    public virtual string ToString();
    public virtual object InvokeInstance(object instance, Object[] args);
    public virtual object Invoke(Object[] args);
    public virtual object Invoke();
    public virtual object Invoke(object arg0);
    public virtual object Invoke(object arg0, object arg1);
    public virtual object Invoke(object arg0, object arg1, object arg2);
    public virtual object Invoke(object arg0, object arg1, object arg2, object arg3);
    public virtual object Invoke(object arg0, object arg1, object arg2, object arg3, object arg4);
    public virtual object Invoke(object arg0, object arg1, object arg2, object arg3, object arg4, object arg5);
    public virtual object Invoke(object arg0, object arg1, object arg2, object arg3, object arg4, object arg5, object arg6);
    public virtual object Invoke(object arg0, object arg1, object arg2, object arg3, object arg4, object arg5, object arg6, object arg7);
    public virtual object Invoke(object arg0, object arg1, object arg2, object arg3, object arg4, object arg5, object arg6, object arg7, object arg8);
    private static CallInstruction FastCreate(MethodInfo target, ParameterInfo[] pi);
    private static CallInstruction FastCreate(MethodInfo target, ParameterInfo[] pi);
    private static CallInstruction FastCreate(MethodInfo target, ParameterInfo[] pi);
    private static Type GetHelperType(MethodInfo info, Type[] arrTypes);
    public static MethodInfo CacheFunc(Func`1<TRet> method);
    public static MethodInfo CacheFunc(Func`2<T0, TRet> method);
    public static MethodInfo CacheFunc(Func`3<T0, T1, TRet> method);
    public static MethodInfo CacheFunc(Func`4<T0, T1, T2, TRet> method);
    public static MethodInfo CacheFunc(Func`5<T0, T1, T2, T3, TRet> method);
    public static MethodInfo CacheFunc(Func`6<T0, T1, T2, T3, T4, TRet> method);
    public static MethodInfo CacheFunc(Func`7<T0, T1, T2, T3, T4, T5, TRet> method);
    public static MethodInfo CacheFunc(Func`8<T0, T1, T2, T3, T4, T5, T6, TRet> method);
    public static MethodInfo CacheFunc(Func`9<T0, T1, T2, T3, T4, T5, T6, T7, TRet> method);
    public static MethodInfo CacheFunc(Func`10<T0, T1, T2, T3, T4, T5, T6, T7, T8, TRet> method);
    public static MethodInfo CacheAction(Action method);
    public static MethodInfo CacheAction(Action`1<T0> method);
    public static MethodInfo CacheAction(Action`2<T0, T1> method);
    public static MethodInfo CacheAction(Action`3<T0, T1, T2> method);
    public static MethodInfo CacheAction(Action`4<T0, T1, T2, T3> method);
    public static MethodInfo CacheAction(Action`5<T0, T1, T2, T3, T4> method);
    public static MethodInfo CacheAction(Action`6<T0, T1, T2, T3, T4, T5> method);
    public static MethodInfo CacheAction(Action`7<T0, T1, T2, T3, T4, T5, T6> method);
    public static MethodInfo CacheAction(Action`8<T0, T1, T2, T3, T4, T5, T6, T7> method);
    public static MethodInfo CacheAction(Action`9<T0, T1, T2, T3, T4, T5, T6, T7, T8> method);
}
internal class Microsoft.Scripting.Interpreter.CoalescingBranchInstruction : OffsetInstruction {
    private static Instruction[] _cache;
    public Instruction[] Cache { get; }
    public int ConsumedStack { get; }
    public int ProducedStack { get; }
    public virtual Instruction[] get_Cache();
    public virtual int get_ConsumedStack();
    public virtual int get_ProducedStack();
    public virtual int Run(InterpretedFrame frame);
}
internal class Microsoft.Scripting.Interpreter.CompiledLoopInstruction : Instruction {
    private Func`4<Object[], StrongBox`1[], InterpretedFrame, int> _compiledLoop;
    public CompiledLoopInstruction(Func`4<Object[], StrongBox`1[], InterpretedFrame, int> compiledLoop);
    public virtual int Run(InterpretedFrame frame);
}
internal class Microsoft.Scripting.Interpreter.CreateDelegateInstruction : Instruction {
    private LightDelegateCreator _creator;
    public int ConsumedStack { get; }
    public int ProducedStack { get; }
    internal CreateDelegateInstruction(LightDelegateCreator delegateCreator);
    public virtual int get_ConsumedStack();
    public virtual int get_ProducedStack();
    public virtual int Run(InterpretedFrame frame);
}
public class Microsoft.Scripting.Interpreter.DebugInfo : object {
    public int StartLine;
    public int EndLine;
    public int Index;
    public string FileName;
    public bool IsClear;
    private static DebugInfoComparer _debugComparer;
    private static DebugInfo();
    public static DebugInfo GetMatchingDebugInfo(DebugInfo[] debugInfos, int index);
    public virtual string ToString();
}
internal class Microsoft.Scripting.Interpreter.DefaultValueInstruction`1 : Instruction {
    public int ConsumedStack { get; }
    public int ProducedStack { get; }
    public virtual int get_ConsumedStack();
    public virtual int get_ProducedStack();
    public virtual int Run(InterpretedFrame frame);
    public virtual string ToString();
}
internal abstract class Microsoft.Scripting.Interpreter.DivInstruction : Instruction {
    private static Instruction _Int16;
    private static Instruction _Int32;
    private static Instruction _Int64;
    private static Instruction _UInt16;
    private static Instruction _UInt32;
    private static Instruction _UInt64;
    private static Instruction _Single;
    private static Instruction _Double;
    public int ConsumedStack { get; }
    public int ProducedStack { get; }
    public virtual int get_ConsumedStack();
    public virtual int get_ProducedStack();
    public static Instruction Create(Type type);
    public virtual string ToString();
}
internal class Microsoft.Scripting.Interpreter.DupInstruction : Instruction {
    internal static DupInstruction Instance;
    public int ConsumedStack { get; }
    public int ProducedStack { get; }
    private static DupInstruction();
    public virtual int get_ConsumedStack();
    public virtual int get_ProducedStack();
    public virtual int Run(InterpretedFrame frame);
    public virtual string ToString();
}
internal class Microsoft.Scripting.Interpreter.DynamicInstruction`1 : Instruction {
    private CallSite`1<Func`2<CallSite, TRet>> _site;
    public int ProducedStack { get; }
    public int ConsumedStack { get; }
    private DynamicInstruction`1(CallSite`1<Func`2<CallSite, TRet>> site);
    public static Instruction Factory(CallSiteBinder binder);
    public virtual int get_ProducedStack();
    public virtual int get_ConsumedStack();
    public virtual int Run(InterpretedFrame frame);
    public virtual string ToString();
}
internal class Microsoft.Scripting.Interpreter.DynamicInstruction`10 : Instruction {
    private CallSite`1<Func`11<CallSite, T0, T1, T2, T3, T4, T5, T6, T7, T8, TRet>> _site;
    public int ProducedStack { get; }
    public int ConsumedStack { get; }
    private DynamicInstruction`10(CallSite`1<Func`11<CallSite, T0, T1, T2, T3, T4, T5, T6, T7, T8, TRet>> site);
    public static Instruction Factory(CallSiteBinder binder);
    public virtual int get_ProducedStack();
    public virtual int get_ConsumedStack();
    public virtual int Run(InterpretedFrame frame);
    public virtual string ToString();
}
internal class Microsoft.Scripting.Interpreter.DynamicInstruction`11 : Instruction {
    private CallSite`1<Func`12<CallSite, T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, TRet>> _site;
    public int ProducedStack { get; }
    public int ConsumedStack { get; }
    private DynamicInstruction`11(CallSite`1<Func`12<CallSite, T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, TRet>> site);
    public static Instruction Factory(CallSiteBinder binder);
    public virtual int get_ProducedStack();
    public virtual int get_ConsumedStack();
    public virtual int Run(InterpretedFrame frame);
    public virtual string ToString();
}
internal class Microsoft.Scripting.Interpreter.DynamicInstruction`12 : Instruction {
    private CallSite`1<Func`13<CallSite, T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, TRet>> _site;
    public int ProducedStack { get; }
    public int ConsumedStack { get; }
    private DynamicInstruction`12(CallSite`1<Func`13<CallSite, T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, TRet>> site);
    public static Instruction Factory(CallSiteBinder binder);
    public virtual int get_ProducedStack();
    public virtual int get_ConsumedStack();
    public virtual int Run(InterpretedFrame frame);
    public virtual string ToString();
}
internal class Microsoft.Scripting.Interpreter.DynamicInstruction`13 : Instruction {
    private CallSite`1<Func`14<CallSite, T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, TRet>> _site;
    public int ProducedStack { get; }
    public int ConsumedStack { get; }
    private DynamicInstruction`13(CallSite`1<Func`14<CallSite, T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, TRet>> site);
    public static Instruction Factory(CallSiteBinder binder);
    public virtual int get_ProducedStack();
    public virtual int get_ConsumedStack();
    public virtual int Run(InterpretedFrame frame);
    public virtual string ToString();
}
internal class Microsoft.Scripting.Interpreter.DynamicInstruction`14 : Instruction {
    private CallSite`1<Func`15<CallSite, T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, TRet>> _site;
    public int ProducedStack { get; }
    public int ConsumedStack { get; }
    private DynamicInstruction`14(CallSite`1<Func`15<CallSite, T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, TRet>> site);
    public static Instruction Factory(CallSiteBinder binder);
    public virtual int get_ProducedStack();
    public virtual int get_ConsumedStack();
    public virtual int Run(InterpretedFrame frame);
    public virtual string ToString();
}
internal class Microsoft.Scripting.Interpreter.DynamicInstruction`15 : Instruction {
    private CallSite`1<Func`16<CallSite, T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, TRet>> _site;
    public int ProducedStack { get; }
    public int ConsumedStack { get; }
    private DynamicInstruction`15(CallSite`1<Func`16<CallSite, T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, TRet>> site);
    public static Instruction Factory(CallSiteBinder binder);
    public virtual int get_ProducedStack();
    public virtual int get_ConsumedStack();
    public virtual int Run(InterpretedFrame frame);
    public virtual string ToString();
}
internal class Microsoft.Scripting.Interpreter.DynamicInstruction`16 : Instruction {
    private CallSite`1<Func`17<CallSite, T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, TRet>> _site;
    public int ProducedStack { get; }
    public int ConsumedStack { get; }
    private DynamicInstruction`16(CallSite`1<Func`17<CallSite, T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, TRet>> site);
    public static Instruction Factory(CallSiteBinder binder);
    public virtual int get_ProducedStack();
    public virtual int get_ConsumedStack();
    public virtual int Run(InterpretedFrame frame);
    public virtual string ToString();
}
internal class Microsoft.Scripting.Interpreter.DynamicInstruction`2 : Instruction {
    private CallSite`1<Func`3<CallSite, T0, TRet>> _site;
    public int ProducedStack { get; }
    public int ConsumedStack { get; }
    private DynamicInstruction`2(CallSite`1<Func`3<CallSite, T0, TRet>> site);
    public static Instruction Factory(CallSiteBinder binder);
    public virtual int get_ProducedStack();
    public virtual int get_ConsumedStack();
    public virtual int Run(InterpretedFrame frame);
    public virtual string ToString();
}
internal class Microsoft.Scripting.Interpreter.DynamicInstruction`3 : Instruction {
    private CallSite`1<Func`4<CallSite, T0, T1, TRet>> _site;
    public int ProducedStack { get; }
    public int ConsumedStack { get; }
    private DynamicInstruction`3(CallSite`1<Func`4<CallSite, T0, T1, TRet>> site);
    public static Instruction Factory(CallSiteBinder binder);
    public virtual int get_ProducedStack();
    public virtual int get_ConsumedStack();
    public virtual int Run(InterpretedFrame frame);
    public virtual string ToString();
}
internal class Microsoft.Scripting.Interpreter.DynamicInstruction`4 : Instruction {
    private CallSite`1<Func`5<CallSite, T0, T1, T2, TRet>> _site;
    public int ProducedStack { get; }
    public int ConsumedStack { get; }
    private DynamicInstruction`4(CallSite`1<Func`5<CallSite, T0, T1, T2, TRet>> site);
    public static Instruction Factory(CallSiteBinder binder);
    public virtual int get_ProducedStack();
    public virtual int get_ConsumedStack();
    public virtual int Run(InterpretedFrame frame);
    public virtual string ToString();
}
internal class Microsoft.Scripting.Interpreter.DynamicInstruction`5 : Instruction {
    private CallSite`1<Func`6<CallSite, T0, T1, T2, T3, TRet>> _site;
    public int ProducedStack { get; }
    public int ConsumedStack { get; }
    private DynamicInstruction`5(CallSite`1<Func`6<CallSite, T0, T1, T2, T3, TRet>> site);
    public static Instruction Factory(CallSiteBinder binder);
    public virtual int get_ProducedStack();
    public virtual int get_ConsumedStack();
    public virtual int Run(InterpretedFrame frame);
    public virtual string ToString();
}
internal class Microsoft.Scripting.Interpreter.DynamicInstruction`6 : Instruction {
    private CallSite`1<Func`7<CallSite, T0, T1, T2, T3, T4, TRet>> _site;
    public int ProducedStack { get; }
    public int ConsumedStack { get; }
    private DynamicInstruction`6(CallSite`1<Func`7<CallSite, T0, T1, T2, T3, T4, TRet>> site);
    public static Instruction Factory(CallSiteBinder binder);
    public virtual int get_ProducedStack();
    public virtual int get_ConsumedStack();
    public virtual int Run(InterpretedFrame frame);
    public virtual string ToString();
}
internal class Microsoft.Scripting.Interpreter.DynamicInstruction`7 : Instruction {
    private CallSite`1<Func`8<CallSite, T0, T1, T2, T3, T4, T5, TRet>> _site;
    public int ProducedStack { get; }
    public int ConsumedStack { get; }
    private DynamicInstruction`7(CallSite`1<Func`8<CallSite, T0, T1, T2, T3, T4, T5, TRet>> site);
    public static Instruction Factory(CallSiteBinder binder);
    public virtual int get_ProducedStack();
    public virtual int get_ConsumedStack();
    public virtual int Run(InterpretedFrame frame);
    public virtual string ToString();
}
internal class Microsoft.Scripting.Interpreter.DynamicInstruction`8 : Instruction {
    private CallSite`1<Func`9<CallSite, T0, T1, T2, T3, T4, T5, T6, TRet>> _site;
    public int ProducedStack { get; }
    public int ConsumedStack { get; }
    private DynamicInstruction`8(CallSite`1<Func`9<CallSite, T0, T1, T2, T3, T4, T5, T6, TRet>> site);
    public static Instruction Factory(CallSiteBinder binder);
    public virtual int get_ProducedStack();
    public virtual int get_ConsumedStack();
    public virtual int Run(InterpretedFrame frame);
    public virtual string ToString();
}
internal class Microsoft.Scripting.Interpreter.DynamicInstruction`9 : Instruction {
    private CallSite`1<Func`10<CallSite, T0, T1, T2, T3, T4, T5, T6, T7, TRet>> _site;
    public int ProducedStack { get; }
    public int ConsumedStack { get; }
    private DynamicInstruction`9(CallSite`1<Func`10<CallSite, T0, T1, T2, T3, T4, T5, T6, T7, TRet>> site);
    public static Instruction Factory(CallSiteBinder binder);
    public virtual int get_ProducedStack();
    public virtual int get_ConsumedStack();
    public virtual int Run(InterpretedFrame frame);
    public virtual string ToString();
}
internal class Microsoft.Scripting.Interpreter.DynamicInstructionN : Instruction {
    private CallInstruction _targetInvocationInstruction;
    private object _targetDelegate;
    private CallSite _site;
    private int _argumentCount;
    private bool _isVoid;
    public int ProducedStack { get; }
    public int ConsumedStack { get; }
    public DynamicInstructionN(Type delegateType, CallSite site);
    public DynamicInstructionN(Type delegateType, CallSite site, bool isVoid);
    public virtual int get_ProducedStack();
    public virtual int get_ConsumedStack();
    public virtual int Run(InterpretedFrame frame);
    public virtual string ToString();
    internal static Type GetDynamicInstructionType(Type delegateType);
    internal static Instruction CreateUntypedInstruction(CallSiteBinder binder, int argCount);
}
internal class Microsoft.Scripting.Interpreter.DynamicSplatInstruction : Instruction {
    private CallSite`1<Func`3<CallSite, ArgumentArray, object>> _site;
    private int _argumentCount;
    public int ProducedStack { get; }
    public int ConsumedStack { get; }
    internal DynamicSplatInstruction(int argumentCount, CallSite`1<Func`3<CallSite, ArgumentArray, object>> site);
    public virtual int get_ProducedStack();
    public virtual int get_ConsumedStack();
    public virtual int Run(InterpretedFrame frame);
    public virtual string ToString();
}
internal class Microsoft.Scripting.Interpreter.EnterExceptionHandlerInstruction : Instruction {
    internal static EnterExceptionHandlerInstruction Void;
    internal static EnterExceptionHandlerInstruction NonVoid;
    private bool _hasValue;
    public int ConsumedStack { get; }
    public int ProducedStack { get; }
    private EnterExceptionHandlerInstruction(bool hasValue);
    private static EnterExceptionHandlerInstruction();
    public virtual int get_ConsumedStack();
    public virtual int get_ProducedStack();
    public virtual int Run(InterpretedFrame frame);
}
internal class Microsoft.Scripting.Interpreter.EnterFinallyInstruction : Instruction {
    internal static Instruction Instance;
    public int ProducedStack { get; }
    public int ConsumedContinuations { get; }
    private static EnterFinallyInstruction();
    public virtual int get_ProducedStack();
    public virtual int get_ConsumedContinuations();
    public virtual int Run(InterpretedFrame frame);
}
internal class Microsoft.Scripting.Interpreter.EnterLoopInstruction : Instruction {
    private int _instructionIndex;
    private Dictionary`2<ParameterExpression, LocalVariable> _variables;
    private Dictionary`2<ParameterExpression, LocalVariable> _closureVariables;
    private LoopExpression _loop;
    private int _loopEnd;
    private int _compilationThreshold;
    private bool Compiled { get; }
    internal EnterLoopInstruction(LoopExpression loop, LocalVariables locals, int compilationThreshold, int instructionIndex);
    internal void FinishLoop(int loopEnd);
    public virtual int Run(InterpretedFrame frame);
    private bool get_Compiled();
    private void Compile(object frameObj);
}
internal class Microsoft.Scripting.Interpreter.EnterTryFinallyInstruction : IndexedBranchInstruction {
    private static EnterTryFinallyInstruction[] Cache;
    public int ProducedContinuations { get; }
    private EnterTryFinallyInstruction(int targetIndex);
    private static EnterTryFinallyInstruction();
    public virtual int get_ProducedContinuations();
    internal static EnterTryFinallyInstruction Create(int labelIndex);
    public virtual int Run(InterpretedFrame frame);
}
internal abstract class Microsoft.Scripting.Interpreter.EqualInstruction : Instruction {
    private static Instruction _Reference;
    private static Instruction _Boolean;
    private static Instruction _SByte;
    private static Instruction _Int16;
    private static Instruction _Char;
    private static Instruction _Int32;
    private static Instruction _Int64;
    private static Instruction _Byte;
    private static Instruction _UInt16;
    private static Instruction _UInt32;
    private static Instruction _UInt64;
    private static Instruction _Single;
    private static Instruction _Double;
    public int ConsumedStack { get; }
    public int ProducedStack { get; }
    public virtual int get_ConsumedStack();
    public virtual int get_ProducedStack();
    public static Instruction Create(Type type);
    public virtual string ToString();
}
public class Microsoft.Scripting.Interpreter.ExceptionHandler : object {
    public Type ExceptionType;
    public int StartIndex;
    public int EndIndex;
    public int LabelIndex;
    public int HandlerStartIndex;
    public bool IsFault { get; }
    internal ExceptionHandler(int start, int end, int labelIndex, int handlerStartIndex, Type exceptionType);
    public bool get_IsFault();
    public bool Matches(Type exceptionType, int index);
    public bool IsBetterThan(ExceptionHandler other);
    internal bool IsInside(int index);
    public virtual string ToString();
}
internal class Microsoft.Scripting.Interpreter.FuncCallInstruction`1 : CallInstruction {
    private Func`1<TRet> _target;
    public MethodInfo Info { get; }
    public int ArgumentCount { get; }
    public FuncCallInstruction`1(Func`1<TRet> target);
    public FuncCallInstruction`1(MethodInfo target);
    public virtual MethodInfo get_Info();
    public virtual int get_ArgumentCount();
    public virtual object Invoke();
    public virtual int Run(InterpretedFrame frame);
}
internal class Microsoft.Scripting.Interpreter.FuncCallInstruction`10 : CallInstruction {
    private Func`10<T0, T1, T2, T3, T4, T5, T6, T7, T8, TRet> _target;
    public MethodInfo Info { get; }
    public int ArgumentCount { get; }
    public FuncCallInstruction`10(Func`10<T0, T1, T2, T3, T4, T5, T6, T7, T8, TRet> target);
    public FuncCallInstruction`10(MethodInfo target);
    public virtual MethodInfo get_Info();
    public virtual int get_ArgumentCount();
    public virtual object Invoke(object arg0, object arg1, object arg2, object arg3, object arg4, object arg5, object arg6, object arg7, object arg8);
    public virtual int Run(InterpretedFrame frame);
}
internal class Microsoft.Scripting.Interpreter.FuncCallInstruction`2 : CallInstruction {
    private Func`2<T0, TRet> _target;
    public MethodInfo Info { get; }
    public int ArgumentCount { get; }
    public FuncCallInstruction`2(Func`2<T0, TRet> target);
    public FuncCallInstruction`2(MethodInfo target);
    public virtual MethodInfo get_Info();
    public virtual int get_ArgumentCount();
    public virtual object Invoke(object arg0);
    public virtual int Run(InterpretedFrame frame);
}
internal class Microsoft.Scripting.Interpreter.FuncCallInstruction`3 : CallInstruction {
    private Func`3<T0, T1, TRet> _target;
    public MethodInfo Info { get; }
    public int ArgumentCount { get; }
    public FuncCallInstruction`3(Func`3<T0, T1, TRet> target);
    public FuncCallInstruction`3(MethodInfo target);
    public virtual MethodInfo get_Info();
    public virtual int get_ArgumentCount();
    public virtual object Invoke(object arg0, object arg1);
    public virtual int Run(InterpretedFrame frame);
}
internal class Microsoft.Scripting.Interpreter.FuncCallInstruction`4 : CallInstruction {
    private Func`4<T0, T1, T2, TRet> _target;
    public MethodInfo Info { get; }
    public int ArgumentCount { get; }
    public FuncCallInstruction`4(Func`4<T0, T1, T2, TRet> target);
    public FuncCallInstruction`4(MethodInfo target);
    public virtual MethodInfo get_Info();
    public virtual int get_ArgumentCount();
    public virtual object Invoke(object arg0, object arg1, object arg2);
    public virtual int Run(InterpretedFrame frame);
}
internal class Microsoft.Scripting.Interpreter.FuncCallInstruction`5 : CallInstruction {
    private Func`5<T0, T1, T2, T3, TRet> _target;
    public MethodInfo Info { get; }
    public int ArgumentCount { get; }
    public FuncCallInstruction`5(Func`5<T0, T1, T2, T3, TRet> target);
    public FuncCallInstruction`5(MethodInfo target);
    public virtual MethodInfo get_Info();
    public virtual int get_ArgumentCount();
    public virtual object Invoke(object arg0, object arg1, object arg2, object arg3);
    public virtual int Run(InterpretedFrame frame);
}
internal class Microsoft.Scripting.Interpreter.FuncCallInstruction`6 : CallInstruction {
    private Func`6<T0, T1, T2, T3, T4, TRet> _target;
    public MethodInfo Info { get; }
    public int ArgumentCount { get; }
    public FuncCallInstruction`6(Func`6<T0, T1, T2, T3, T4, TRet> target);
    public FuncCallInstruction`6(MethodInfo target);
    public virtual MethodInfo get_Info();
    public virtual int get_ArgumentCount();
    public virtual object Invoke(object arg0, object arg1, object arg2, object arg3, object arg4);
    public virtual int Run(InterpretedFrame frame);
}
internal class Microsoft.Scripting.Interpreter.FuncCallInstruction`7 : CallInstruction {
    private Func`7<T0, T1, T2, T3, T4, T5, TRet> _target;
    public MethodInfo Info { get; }
    public int ArgumentCount { get; }
    public FuncCallInstruction`7(Func`7<T0, T1, T2, T3, T4, T5, TRet> target);
    public FuncCallInstruction`7(MethodInfo target);
    public virtual MethodInfo get_Info();
    public virtual int get_ArgumentCount();
    public virtual object Invoke(object arg0, object arg1, object arg2, object arg3, object arg4, object arg5);
    public virtual int Run(InterpretedFrame frame);
}
internal class Microsoft.Scripting.Interpreter.FuncCallInstruction`8 : CallInstruction {
    private Func`8<T0, T1, T2, T3, T4, T5, T6, TRet> _target;
    public MethodInfo Info { get; }
    public int ArgumentCount { get; }
    public FuncCallInstruction`8(Func`8<T0, T1, T2, T3, T4, T5, T6, TRet> target);
    public FuncCallInstruction`8(MethodInfo target);
    public virtual MethodInfo get_Info();
    public virtual int get_ArgumentCount();
    public virtual object Invoke(object arg0, object arg1, object arg2, object arg3, object arg4, object arg5, object arg6);
    public virtual int Run(InterpretedFrame frame);
}
internal class Microsoft.Scripting.Interpreter.FuncCallInstruction`9 : CallInstruction {
    private Func`9<T0, T1, T2, T3, T4, T5, T6, T7, TRet> _target;
    public MethodInfo Info { get; }
    public int ArgumentCount { get; }
    public FuncCallInstruction`9(Func`9<T0, T1, T2, T3, T4, T5, T6, T7, TRet> target);
    public FuncCallInstruction`9(MethodInfo target);
    public virtual MethodInfo get_Info();
    public virtual int get_ArgumentCount();
    public virtual object Invoke(object arg0, object arg1, object arg2, object arg3, object arg4, object arg5, object arg6, object arg7);
    public virtual int Run(InterpretedFrame frame);
}
public class Microsoft.Scripting.Interpreter.GetArrayItemInstruction`1 : Instruction {
    public int ConsumedStack { get; }
    public int ProducedStack { get; }
    public string InstructionName { get; }
    public virtual int get_ConsumedStack();
    public virtual int get_ProducedStack();
    public virtual int Run(InterpretedFrame frame);
    public virtual string get_InstructionName();
}
internal class Microsoft.Scripting.Interpreter.GotoInstruction : IndexedBranchInstruction {
    private static int Variants;
    private static GotoInstruction[] Cache;
    private bool _hasResult;
    private bool _hasValue;
    public int ConsumedContinuations { get; }
    public int ProducedContinuations { get; }
    public int ConsumedStack { get; }
    public int ProducedStack { get; }
    private GotoInstruction(int targetIndex, bool hasResult, bool hasValue);
    private static GotoInstruction();
    public virtual int get_ConsumedContinuations();
    public virtual int get_ProducedContinuations();
    public virtual int get_ConsumedStack();
    public virtual int get_ProducedStack();
    internal static GotoInstruction Create(int labelIndex, bool hasResult, bool hasValue);
    public virtual int Run(InterpretedFrame frame);
}
internal abstract class Microsoft.Scripting.Interpreter.GreaterThanInstruction : Instruction {
    private static Instruction _SByte;
    private static Instruction _Int16;
    private static Instruction _Char;
    private static Instruction _Int32;
    private static Instruction _Int64;
    private static Instruction _Byte;
    private static Instruction _UInt16;
    private static Instruction _UInt32;
    private static Instruction _UInt64;
    private static Instruction _Single;
    private static Instruction _Double;
    public int ConsumedStack { get; }
    public int ProducedStack { get; }
    public virtual int get_ConsumedStack();
    public virtual int get_ProducedStack();
    public static Instruction Create(Type type);
    public virtual string ToString();
}
internal interface Microsoft.Scripting.Interpreter.IBoxableInstruction {
    public abstract virtual Instruction BoxIfIndexMatches(int index);
}
public interface Microsoft.Scripting.Interpreter.IInstructionProvider {
    public abstract virtual void AddInstructions(LightCompiler compiler);
}
public interface Microsoft.Scripting.Interpreter.ILightCallSiteBinder {
    public bool AcceptsArgumentArray { get; }
    public abstract virtual bool get_AcceptsArgumentArray();
}
internal abstract class Microsoft.Scripting.Interpreter.IndexedBranchInstruction : Instruction {
    protected static int CacheSize;
    internal int _labelIndex;
    public IndexedBranchInstruction(int labelIndex);
    public RuntimeLabel GetLabel(InterpretedFrame frame);
    public virtual string ToDebugString(int instructionIndex, object cookie, Func`2<int, int> labelIndexer, IList`1<object> objects);
    public virtual string ToString();
}
internal abstract class Microsoft.Scripting.Interpreter.InitializeLocalInstruction : LocalAccessInstruction {
    internal InitializeLocalInstruction(int index);
}
public abstract class Microsoft.Scripting.Interpreter.Instruction : object {
    public int ConsumedStack { get; }
    public int ProducedStack { get; }
    public int ConsumedContinuations { get; }
    public int ProducedContinuations { get; }
    public int StackBalance { get; }
    public int ContinuationsBalance { get; }
    public string InstructionName { get; }
    public virtual int get_ConsumedStack();
    public virtual int get_ProducedStack();
    public virtual int get_ConsumedContinuations();
    public virtual int get_ProducedContinuations();
    public int get_StackBalance();
    public int get_ContinuationsBalance();
    public abstract virtual int Run(InterpretedFrame frame);
    public virtual string get_InstructionName();
    public virtual string ToString();
    public virtual string ToDebugString(int instructionIndex, object cookie, Func`2<int, int> labelIndexer, IList`1<object> objects);
    public virtual object GetDebugCookie(LightCompiler compiler);
}
[DebuggerTypeProxyAttribute("Microsoft.Scripting.Interpreter.InstructionArray/DebugView")]
public class Microsoft.Scripting.Interpreter.InstructionArray : ValueType {
    internal int MaxStackDepth;
    internal int MaxContinuationDepth;
    internal Instruction[] Instructions;
    internal Object[] Objects;
    internal RuntimeLabel[] Labels;
    internal List`1<KeyValuePair`2<int, object>> DebugCookies;
    internal int Length { get; }
    internal InstructionArray(int maxStackDepth, int maxContinuationDepth, Instruction[] instructions, Object[] objects, RuntimeLabel[] labels, List`1<KeyValuePair`2<int, object>> debugCookies);
    internal int get_Length();
}
public abstract class Microsoft.Scripting.Interpreter.InstructionFactory : object {
    private static Dictionary`2<Type, InstructionFactory> _factories;
    internal static InstructionFactory GetFactory(Type type);
    protected internal abstract virtual Instruction GetArrayItem();
    protected internal abstract virtual Instruction SetArrayItem();
    protected internal abstract virtual Instruction TypeIs();
    protected internal abstract virtual Instruction TypeAs();
    protected internal abstract virtual Instruction DefaultValue();
    protected internal abstract virtual Instruction NewArray();
    protected internal abstract virtual Instruction NewArrayInit(int elementCount);
}
public class Microsoft.Scripting.Interpreter.InstructionFactory`1 : InstructionFactory {
    public static InstructionFactory Factory;
    private Instruction _getArrayItem;
    private Instruction _setArrayItem;
    private Instruction _typeIs;
    private Instruction _defaultValue;
    private Instruction _newArray;
    private Instruction _typeAs;
    private static InstructionFactory`1();
    protected internal virtual Instruction GetArrayItem();
    protected internal virtual Instruction SetArrayItem();
    protected internal virtual Instruction TypeIs();
    protected internal virtual Instruction TypeAs();
    protected internal virtual Instruction DefaultValue();
    protected internal virtual Instruction NewArray();
    protected internal virtual Instruction NewArrayInit(int elementCount);
}
[DebuggerTypeProxyAttribute("Microsoft.Scripting.Interpreter.InstructionList/DebugView")]
public class Microsoft.Scripting.Interpreter.InstructionList : object {
    private List`1<Instruction> _instructions;
    private List`1<object> _objects;
    private int _currentStackDepth;
    private int _maxStackDepth;
    private int _currentContinuationsDepth;
    private int _maxContinuationDepth;
    private int _runtimeLabelCount;
    private List`1<BranchLabel> _labels;
    private List`1<KeyValuePair`2<int, object>> _debugCookies;
    private static int PushIntMinCachedValue;
    private static int PushIntMaxCachedValue;
    private static int CachedObjectCount;
    private static Instruction _null;
    private static Instruction _true;
    private static Instruction _false;
    private static Instruction[] _ints;
    private static Instruction[] _loadObjectCached;
    private static int LocalInstrCacheSize;
    private static Instruction[] _loadLocal;
    private static Instruction[] _loadLocalBoxed;
    private static Instruction[] _loadLocalFromClosure;
    private static Instruction[] _loadLocalFromClosureBoxed;
    private static Instruction[] _assignLocal;
    private static Instruction[] _storeLocal;
    private static Instruction[] _assignLocalBoxed;
    private static Instruction[] _storeLocalBoxed;
    private static Instruction[] _assignLocalToClosure;
    private static Instruction[] _initReference;
    private static Instruction[] _initImmutableRefBox;
    private static Instruction[] _parameterBox;
    private static Instruction[] _parameter;
    private static Dictionary`2<FieldInfo, Instruction> _loadFields;
    private static Dictionary`2<Type, Func`2<CallSiteBinder, Instruction>> _factories;
    private static RuntimeLabel[] EmptyRuntimeLabels;
    public int Count { get; }
    public int CurrentStackDepth { get; }
    public int CurrentContinuationsDepth { get; }
    public int MaxStackDepth { get; }
    private static InstructionList();
    public void Emit(Instruction instruction);
    private void UpdateStackDepth(Instruction instruction);
    [ConditionalAttribute("DEBUG")]
public void SetDebugCookie(object cookie);
    public int get_Count();
    public int get_CurrentStackDepth();
    public int get_CurrentContinuationsDepth();
    public int get_MaxStackDepth();
    internal Instruction GetInstruction(int index);
    public InstructionArray ToArray();
    public void EmitLoad(object value);
    public void EmitLoad(bool value);
    public void EmitLoad(object value, Type type);
    public void EmitDup();
    public void EmitPop();
    internal void SwitchToBoxed(int index, int instructionIndex);
    public void EmitLoadLocal(int index);
    public void EmitLoadLocalBoxed(int index);
    internal static Instruction LoadLocalBoxed(int index);
    public void EmitLoadLocalFromClosure(int index);
    public void EmitLoadLocalFromClosureBoxed(int index);
    public void EmitAssignLocal(int index);
    public void EmitStoreLocal(int index);
    public void EmitAssignLocalBoxed(int index);
    internal static Instruction AssignLocalBoxed(int index);
    public void EmitStoreLocalBoxed(int index);
    internal static Instruction StoreLocalBoxed(int index);
    public void EmitAssignLocalToClosure(int index);
    public void EmitStoreLocalToClosure(int index);
    public void EmitInitializeLocal(int index, Type type);
    internal void EmitInitializeParameter(int index);
    internal static Instruction Parameter(int index);
    internal static Instruction ParameterBox(int index);
    internal static Instruction InitReference(int index);
    internal static Instruction InitImmutableRefBox(int index);
    public void EmitNewRuntimeVariables(int count);
    public void EmitGetArrayItem(Type arrayType);
    public void EmitSetArrayItem(Type arrayType);
    public void EmitNewArray(Type elementType);
    public void EmitNewArrayBounds(Type elementType, int rank);
    public void EmitNewArrayInit(Type elementType, int elementCount);
    public void EmitAdd(Type type, bool checked);
    public void EmitSub(Type type, bool checked);
    public void EmitMul(Type type, bool checked);
    public void EmitDiv(Type type);
    public void EmitEqual(Type type);
    public void EmitNotEqual(Type type);
    public void EmitLessThan(Type type);
    public void EmitLessThanOrEqual(Type type);
    public void EmitGreaterThan(Type type);
    public void EmitGreaterThanOrEqual(Type type);
    public void EmitNumericConvertChecked(TypeCode from, TypeCode to);
    public void EmitNumericConvertUnchecked(TypeCode from, TypeCode to);
    public void EmitNot();
    public void EmitDefaultValue(Type type);
    public void EmitNew(ConstructorInfo constructorInfo);
    internal void EmitCreateDelegate(LightDelegateCreator creator);
    public void EmitTypeEquals();
    public void EmitTypeIs(Type type);
    public void EmitTypeAs(Type type);
    public void EmitLoadField(FieldInfo field);
    private Instruction GetLoadField(FieldInfo field);
    public void EmitStoreField(FieldInfo field);
    public void EmitDynamic(Type type, CallSiteBinder binder);
    public void EmitDynamic(CallSiteBinder binder);
    public void EmitDynamic(CallSiteBinder binder);
    public void EmitDynamic(CallSiteBinder binder);
    public void EmitDynamic(CallSiteBinder binder);
    public void EmitDynamic(CallSiteBinder binder);
    public void EmitDynamic(CallSiteBinder binder);
    public void EmitDynamic(CallSiteBinder binder);
    public void EmitDynamic(CallSiteBinder binder);
    public void EmitDynamic(CallSiteBinder binder);
    public void EmitDynamic(CallSiteBinder binder);
    public void EmitDynamic(CallSiteBinder binder);
    public void EmitDynamic(CallSiteBinder binder);
    public void EmitDynamic(CallSiteBinder binder);
    public void EmitDynamic(CallSiteBinder binder);
    public void EmitDynamic(CallSiteBinder binder);
    internal static Instruction CreateDynamicInstruction(Type delegateType, CallSiteBinder binder);
    private RuntimeLabel[] BuildRuntimeLabels();
    public BranchLabel MakeLabel();
    internal void FixupBranch(int branchIndex, int offset);
    private int EnsureLabelIndex(BranchLabel label);
    public int MarkRuntimeLabel();
    public void MarkLabel(BranchLabel label);
    public void EmitGoto(BranchLabel label, bool hasResult, bool hasValue);
    private void EmitBranch(OffsetInstruction instruction, BranchLabel label);
    public void EmitBranch(BranchLabel label);
    public void EmitBranch(BranchLabel label, bool hasResult, bool hasValue);
    public void EmitCoalescingBranch(BranchLabel leftNotNull);
    public void EmitBranchTrue(BranchLabel elseLabel);
    public void EmitBranchFalse(BranchLabel elseLabel);
    public void EmitThrow();
    public void EmitThrowVoid();
    public void EmitRethrow();
    public void EmitRethrowVoid();
    public void EmitEnterTryFinally(BranchLabel finallyStartLabel);
    public void EmitEnterFinally();
    public void EmitLeaveFinally();
    public void EmitLeaveFault(bool hasValue);
    public void EmitEnterExceptionHandlerNonVoid();
    public void EmitEnterExceptionHandlerVoid();
    public void EmitLeaveExceptionHandler(bool hasValue, BranchLabel tryExpressionEndLabel);
    public void EmitSwitch(Dictionary`2<int, int> cases);
}
public class Microsoft.Scripting.Interpreter.InterpretedFrame : object {
    public static ThreadLocal`1<InterpretedFrame> CurrentFrame;
    internal Interpreter Interpreter;
    private Int32[] _continuations;
    private int _continuationIndex;
    private int _pendingContinuation;
    private object _pendingValue;
    public Object[] Data;
    public StrongBox`1[] Closure;
    public int StackIndex;
    public int InstructionIndex;
    public ExceptionHandler CurrentAbortHandler;
    [CompilerGeneratedAttribute]
private InterpretedFrame <Parent>k__BackingField;
    private static MethodInfo _Goto;
    private static MethodInfo _VoidGoto;
    public string Name { get; }
    public InterpretedFrame Parent { get; private set; }
    internal static MethodInfo GotoMethod { get; }
    internal static MethodInfo VoidGotoMethod { get; }
    internal InterpretedFrame(Interpreter interpreter, StrongBox`1[] closure);
    private static InterpretedFrame();
    public DebugInfo GetDebugInfo(int instructionIndex);
    public string get_Name();
    public void Push(object value);
    public void Push(bool value);
    public void Push(int value);
    public object Pop();
    public object Pop(int n);
    internal void SetStackDepth(int depth);
    public object Peek();
    public void Dup();
    [CompilerGeneratedAttribute]
public InterpretedFrame get_Parent();
    [CompilerGeneratedAttribute]
private void set_Parent(InterpretedFrame value);
    public static bool IsInterpretedFrame(MethodBase method);
    [IteratorStateMachineAttribute("Microsoft.Scripting.Interpreter.InterpretedFrame/<GroupStackFrames>d__28")]
public static IEnumerable`1<StackFrame> GroupStackFrames(IEnumerable`1<StackFrame> stackTrace);
    [IteratorStateMachineAttribute("Microsoft.Scripting.Interpreter.InterpretedFrame/<GetStackTraceDebugInfo>d__29")]
public IEnumerable`1<InterpretedFrameInfo> GetStackTraceDebugInfo();
    internal void SaveTraceToException(Exception exception);
    public static InterpretedFrameInfo[] GetExceptionStackTrace(Exception exception);
    internal StorageInfo<InterpretedFrame> Enter();
    internal void Leave(StorageInfo<InterpretedFrame> currentFrame);
    public void RemoveContinuation();
    public void PushContinuation(int continuation);
    public int YieldToCurrentContinuation();
    public int YieldToPendingContinuation();
    internal void PushPendingContinuation();
    internal void PopPendingContinuation();
    internal static MethodInfo get_GotoMethod();
    internal static MethodInfo get_VoidGotoMethod();
    public int VoidGoto(int labelIndex);
    public int Goto(int labelIndex, object value);
}
public class Microsoft.Scripting.Interpreter.InterpretedFrameInfo : ValueType {
    public string MethodName;
    public DebugInfo DebugInfo;
    public InterpretedFrameInfo(string methodName, DebugInfo info);
    public virtual string ToString();
}
internal class Microsoft.Scripting.Interpreter.Interpreter : object {
    internal static object NoValue;
    internal static int RethrowOnReturn;
    internal int _compilationThreshold;
    internal Object[] _objects;
    internal RuntimeLabel[] _labels;
    internal string _name;
    private ExceptionHandler[] _handlers;
    internal DebugInfo[] _debugInfos;
    [CompilerGeneratedAttribute]
private int <LocalCount>k__BackingField;
    [CompilerGeneratedAttribute]
private InstructionArray <Instructions>k__BackingField;
    [CompilerGeneratedAttribute]
private Dictionary`2<ParameterExpression, LocalVariable> <ClosureVariables>k__BackingField;
    [CompilerGeneratedAttribute]
private HybridReferenceDictionary`2<LabelTarget, BranchLabel> <LabelMapping>k__BackingField;
    [ThreadStaticAttribute]
private static ThreadAbortException _anyAbortException;
    internal int ClosureSize { get; }
    internal int LocalCount { get; }
    internal bool CompileSynchronously { get; }
    internal InstructionArray Instructions { get; }
    internal Dictionary`2<ParameterExpression, LocalVariable> ClosureVariables { get; }
    internal HybridReferenceDictionary`2<LabelTarget, BranchLabel> LabelMapping { get; }
    internal int ReturnAndRethrowLabelIndex { get; }
    internal Interpreter(string name, LocalVariables locals, HybridReferenceDictionary`2<LabelTarget, BranchLabel> labelMapping, InstructionArray instructions, ExceptionHandler[] handlers, DebugInfo[] debugInfos, int compilationThreshold);
    private static Interpreter();
    internal int get_ClosureSize();
    [CompilerGeneratedAttribute]
internal int get_LocalCount();
    internal bool get_CompileSynchronously();
    [CompilerGeneratedAttribute]
internal InstructionArray get_Instructions();
    [CompilerGeneratedAttribute]
internal Dictionary`2<ParameterExpression, LocalVariable> get_ClosureVariables();
    [CompilerGeneratedAttribute]
internal HybridReferenceDictionary`2<LabelTarget, BranchLabel> get_LabelMapping();
    public void Run(InterpretedFrame frame);
    private ExceptionHandlingResult HandleException(InterpretedFrame frame, Exception exception);
    internal static void AbortThreadIfRequested(InterpretedFrame frame, int targetLabelIndex);
    internal ExceptionHandler GetBestHandler(int instructionIndex, Type exceptionType);
    internal int get_ReturnAndRethrowLabelIndex();
    internal int GotoHandler(InterpretedFrame frame, object exception, ExceptionHandler& handler);
}
internal class Microsoft.Scripting.Interpreter.LabelInfo : object {
    private LabelTarget _node;
    private BranchLabel _label;
    private object _definitions;
    private List`1<LabelScopeInfo> _references;
    private bool _acrossBlockJump;
    private bool HasDefinitions { get; }
    private bool HasMultipleDefinitions { get; }
    internal LabelInfo(LabelTarget node);
    internal BranchLabel GetLabel(LightCompiler compiler);
    internal void Reference(LabelScopeInfo block);
    internal void Define(LabelScopeInfo block);
    private void ValidateJump(LabelScopeInfo reference);
    internal void ValidateFinish();
    private void EnsureLabel(LightCompiler compiler);
    private bool DefinedIn(LabelScopeInfo scope);
    private bool get_HasDefinitions();
    private LabelScopeInfo FirstDefinition();
    private void AddDefinition(LabelScopeInfo scope);
    private bool get_HasMultipleDefinitions();
    internal static T CommonNode(T first, T second, Func`2<T, T> parent);
}
internal class Microsoft.Scripting.Interpreter.LabelScopeInfo : object {
    private HybridReferenceDictionary`2<LabelTarget, LabelInfo> Labels;
    internal LabelScopeKind Kind;
    internal LabelScopeInfo Parent;
    internal bool CanJumpInto { get; }
    internal LabelScopeInfo(LabelScopeInfo parent, LabelScopeKind kind);
    internal bool get_CanJumpInto();
    internal bool ContainsTarget(LabelTarget target);
    internal bool TryGetLabelInfo(LabelTarget target, LabelInfo& info);
    internal void AddLabelInfo(LabelTarget target, LabelInfo info);
}
public enum Microsoft.Scripting.Interpreter.LabelScopeKind : Enum {
    public int value__;
    public static LabelScopeKind Statement;
    public static LabelScopeKind Block;
    public static LabelScopeKind Switch;
    public static LabelScopeKind Lambda;
    public static LabelScopeKind Try;
    public static LabelScopeKind Catch;
    public static LabelScopeKind Finally;
    public static LabelScopeKind Filter;
    public static LabelScopeKind Expression;
}
internal class Microsoft.Scripting.Interpreter.LeaveExceptionHandlerInstruction : IndexedBranchInstruction {
    private static LeaveExceptionHandlerInstruction[] Cache;
    private bool _hasValue;
    public int ConsumedStack { get; }
    public int ProducedStack { get; }
    private LeaveExceptionHandlerInstruction(int labelIndex, bool hasValue);
    private static LeaveExceptionHandlerInstruction();
    public virtual int get_ConsumedStack();
    public virtual int get_ProducedStack();
    internal static LeaveExceptionHandlerInstruction Create(int labelIndex, bool hasValue);
    public virtual int Run(InterpretedFrame frame);
}
internal class Microsoft.Scripting.Interpreter.LeaveFaultInstruction : Instruction {
    internal static Instruction NonVoid;
    internal static Instruction Void;
    private bool _hasValue;
    public int ConsumedStack { get; }
    public int ProducedStack { get; }
    private LeaveFaultInstruction(bool hasValue);
    private static LeaveFaultInstruction();
    public virtual int get_ConsumedStack();
    public virtual int get_ProducedStack();
    public virtual int Run(InterpretedFrame frame);
}
internal class Microsoft.Scripting.Interpreter.LeaveFinallyInstruction : Instruction {
    internal static Instruction Instance;
    public int ConsumedStack { get; }
    private static LeaveFinallyInstruction();
    public virtual int get_ConsumedStack();
    public virtual int Run(InterpretedFrame frame);
}
internal abstract class Microsoft.Scripting.Interpreter.LessThanInstruction : Instruction {
    private object _nullValue;
    private static Instruction _SByte;
    private static Instruction _Int16;
    private static Instruction _Char;
    private static Instruction _Int32;
    private static Instruction _Int64;
    private static Instruction _Byte;
    private static Instruction _UInt16;
    private static Instruction _UInt32;
    private static Instruction _UInt64;
    private static Instruction _Single;
    private static Instruction _Double;
    private static Instruction _liftedToNullSByte;
    private static Instruction _liftedToNullInt16;
    private static Instruction _liftedToNullChar;
    private static Instruction _liftedToNullInt32;
    private static Instruction _liftedToNullInt64;
    private static Instruction _liftedToNullByte;
    private static Instruction _liftedToNullUInt16;
    private static Instruction _liftedToNullUInt32;
    private static Instruction _liftedToNullUInt64;
    private static Instruction _liftedToNullSingle;
    private static Instruction _liftedToNullDouble;
    public int ConsumedStack { get; }
    public int ProducedStack { get; }
    private LessThanInstruction(object nullValue);
    public virtual int get_ConsumedStack();
    public virtual int get_ProducedStack();
    public static Instruction Create(Type type, bool liftedToNull);
    public virtual string ToString();
}
public class Microsoft.Scripting.Interpreter.LightCompiler : object {
    internal static int DefaultCompilationThreshold;
    private int _compilationThreshold;
    private LocalVariables _locals;
    private List`1<ExceptionHandler> _handlers;
    private List`1<DebugInfo> _debugInfos;
    private HybridReferenceDictionary`2<LabelTarget, LabelInfo> _treeLabels;
    private LabelScopeInfo _labelBlock;
    private Stack`1<ParameterExpression> _exceptionForRethrowStack;
    private bool _forceCompile;
    private LightCompiler _parent;
    private static LocalDefinition[] EmptyLocals;
    [CompilerGeneratedAttribute]
private InstructionList <Instructions>k__BackingField;
    public InstructionList Instructions { get; }
    public LocalVariables Locals { get; }
    internal LightCompiler(int compilationThreshold);
    private LightCompiler(LightCompiler parent);
    private static LightCompiler();
    [CompilerGeneratedAttribute]
public InstructionList get_Instructions();
    public LocalVariables get_Locals();
    internal static Expression Unbox(Expression strongBoxExpression);
    internal LightDelegateCreator CompileTop(LambdaExpression node);
    internal LightDelegateCreator CompileTop(LightLambdaExpression node);
    private Interpreter MakeInterpreter(string lambdaName);
    private void CompileConstantExpression(Expression expr);
    private void CompileDefaultExpression(Expression expr);
    private void CompileDefaultExpression(Type type);
    private LocalVariable EnsureAvailableForClosure(ParameterExpression expr);
    private void EnsureVariable(ParameterExpression variable);
    private LocalVariable ResolveLocal(ParameterExpression variable);
    public void CompileGetVariable(ParameterExpression variable);
    public void CompileGetBoxedVariable(ParameterExpression variable);
    public void CompileSetVariable(ParameterExpression variable, bool isVoid);
    public void CompileParameterExpression(Expression expr);
    private void CompileBlockExpression(Expression expr, bool asVoid);
    private LocalDefinition[] CompileBlockStart(BlockExpression node);
    private void CompileBlockEnd(LocalDefinition[] locals);
    private void CompileIndexExpression(Expression expr);
    private void CompileIndexAssignment(BinaryExpression node, bool asVoid);
    private void CompileMemberAssignment(BinaryExpression node, bool asVoid);
    private void CompileVariableAssignment(BinaryExpression node, bool asVoid);
    private void CompileAssignBinaryExpression(Expression expr, bool asVoid);
    private void CompileBinaryExpression(Expression expr);
    private void CompileEqual(Expression left, Expression right);
    private void CompileNotEqual(Expression left, Expression right);
    private void CompileComparison(ExpressionType nodeType, Expression left, Expression right);
    private void CompileArithmetic(ExpressionType nodeType, Expression left, Expression right);
    private void CompileConvertUnaryExpression(Expression expr);
    private void CompileConvertToType(Type typeFrom, Type typeTo, bool isChecked);
    private void CompileNotExpression(UnaryExpression node);
    private void CompileUnaryExpression(Expression expr);
    private void CompileAndAlsoBinaryExpression(Expression expr);
    private void CompileOrElseBinaryExpression(Expression expr);
    private void CompileLogicalBinaryExpression(Expression expr, bool andAlso);
    private void CompileConditionalExpression(Expression expr, bool asVoid);
    private void CompileLoopExpression(Expression expr);
    private void CompileSwitchExpression(Expression expr);
    private void CompileLabelExpression(Expression expr);
    private void CompileGotoExpression(Expression expr);
    public BranchLabel GetBranchLabel(LabelTarget target);
    public void PushLabelBlock(LabelScopeKind type);
    public void PopLabelBlock(LabelScopeKind kind);
    private LabelInfo EnsureLabel(LabelTarget node);
    private LabelInfo ReferenceLabel(LabelTarget node);
    internal LabelInfo DefineLabel(LabelTarget node);
    private bool TryPushLabelBlock(Expression node);
    private void DefineBlockLabels(Expression node);
    private HybridReferenceDictionary`2<LabelTarget, BranchLabel> GetBranchMapping();
    private void CompileThrowUnaryExpression(Expression expr, bool asVoid);
    private bool EndsWithRethrow(Expression expr);
    private void CompileAsVoidRemoveRethrow(Expression expr);
    private void CompileTryExpression(Expression expr);
    private void CompileDynamicExpression(Expression expr);
    private void CompileMethodCallExpression(Expression expr);
    public void EmitCall(MethodInfo method);
    public void EmitCall(MethodInfo method, ParameterInfo[] parameters);
    private void CompileNewExpression(Expression expr);
    private void CompileMemberExpression(Expression expr);
    private void CompileNewArrayExpression(Expression expr);
    private void CompileExtensionExpression(Expression expr);
    private void CompileDebugInfoExpression(Expression expr);
    private void CompileRuntimeVariablesExpression(Expression expr);
    private void CompileLambdaExpression(Expression expr);
    private void CompileCoalesceBinaryExpression(Expression expr);
    private void CompileInvocationExpression(Expression expr);
    private void CompileListInitExpression(Expression expr);
    private void CompileMemberInitExpression(Expression expr);
    private void CompileQuoteUnaryExpression(Expression expr);
    private void CompileUnboxUnaryExpression(Expression expr);
    private void CompileTypeEqualExpression(Expression expr);
    private void CompileTypeAsExpression(UnaryExpression node);
    private void CompileTypeIsExpression(Expression expr);
    private void CompileReducibleExpression(Expression expr);
    internal void Compile(Expression expr, bool asVoid);
    internal void CompileAsVoid(Expression expr);
    private void CompileNoLabelPush(Expression expr);
    public void Compile(Expression expr);
}
internal class Microsoft.Scripting.Interpreter.LightDelegateCreator : object {
    private Expression _lambda;
    private Type _compiledDelegateType;
    private Delegate _compiled;
    private object _compileLock;
    [CompilerGeneratedAttribute]
private Interpreter <Interpreter>k__BackingField;
    internal Interpreter Interpreter { get; }
    private bool HasClosure { get; }
    internal bool HasCompiled { get; }
    internal bool SameDelegateType { get; }
    private Type DelegateType { get; }
    internal LightDelegateCreator(Interpreter interpreter, LambdaExpression lambda);
    internal LightDelegateCreator(Interpreter interpreter, LightLambdaExpression lambda);
    [CompilerGeneratedAttribute]
internal Interpreter get_Interpreter();
    private bool get_HasClosure();
    internal bool get_HasCompiled();
    internal bool get_SameDelegateType();
    internal Delegate CreateDelegate();
    internal Delegate CreateDelegate(StrongBox`1[] closure);
    private Type get_DelegateType();
    internal Delegate CreateCompiledDelegate(StrongBox`1[] closure);
    internal void Compile(object state);
    private static Type GetFuncOrAction(LambdaExpression lambda);
}
public class Microsoft.Scripting.Interpreter.LightLambda : object {
    private StrongBox`1[] _closure;
    private Interpreter _interpreter;
    private static CacheDict`2<Type, Func`2<LightLambda, Delegate>> _runCache;
    private LightDelegateCreator _delegateCreator;
    private Delegate _compiled;
    private int _compilationThreshold;
    [CompilerGeneratedAttribute]
private EventHandler`1<LightLambdaCompileEventArgs> Compile;
    internal static int MaxParameters;
    internal LightLambda(LightDelegateCreator delegateCreator, StrongBox`1[] closure, int compilationThreshold);
    private static LightLambda();
    [CompilerGeneratedAttribute]
public void add_Compile(EventHandler`1<LightLambdaCompileEventArgs> value);
    [CompilerGeneratedAttribute]
public void remove_Compile(EventHandler`1<LightLambdaCompileEventArgs> value);
    private static Func`2<LightLambda, Delegate> GetRunDelegateCtor(Type delegateType);
    private static Func`2<LightLambda, Delegate> MakeRunDelegateCtor(Type delegateType);
    private Delegate CreateCustomDelegate(Type delegateType);
    internal Delegate MakeDelegate(Type delegateType);
    private bool TryGetCompiled();
    private InterpretedFrame MakeFrame();
    internal void RunVoidRef2(T0& arg0, T1& arg1);
    public object Run(Object[] arguments);
    internal TRet Run0();
    internal void RunVoid0();
    internal static Delegate MakeRun0(LightLambda lambda);
    internal static Delegate MakeRunVoid0(LightLambda lambda);
    internal TRet Run1(T0 arg0);
    internal void RunVoid1(T0 arg0);
    internal static Delegate MakeRun1(LightLambda lambda);
    internal static Delegate MakeRunVoid1(LightLambda lambda);
    internal TRet Run2(T0 arg0, T1 arg1);
    internal void RunVoid2(T0 arg0, T1 arg1);
    internal static Delegate MakeRun2(LightLambda lambda);
    internal static Delegate MakeRunVoid2(LightLambda lambda);
    internal TRet Run3(T0 arg0, T1 arg1, T2 arg2);
    internal void RunVoid3(T0 arg0, T1 arg1, T2 arg2);
    internal static Delegate MakeRun3(LightLambda lambda);
    internal static Delegate MakeRunVoid3(LightLambda lambda);
    internal TRet Run4(T0 arg0, T1 arg1, T2 arg2, T3 arg3);
    internal void RunVoid4(T0 arg0, T1 arg1, T2 arg2, T3 arg3);
    internal static Delegate MakeRun4(LightLambda lambda);
    internal static Delegate MakeRunVoid4(LightLambda lambda);
    internal TRet Run5(T0 arg0, T1 arg1, T2 arg2, T3 arg3, T4 arg4);
    internal void RunVoid5(T0 arg0, T1 arg1, T2 arg2, T3 arg3, T4 arg4);
    internal static Delegate MakeRun5(LightLambda lambda);
    internal static Delegate MakeRunVoid5(LightLambda lambda);
    internal TRet Run6(T0 arg0, T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5);
    internal void RunVoid6(T0 arg0, T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5);
    internal static Delegate MakeRun6(LightLambda lambda);
    internal static Delegate MakeRunVoid6(LightLambda lambda);
    internal TRet Run7(T0 arg0, T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5, T6 arg6);
    internal void RunVoid7(T0 arg0, T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5, T6 arg6);
    internal static Delegate MakeRun7(LightLambda lambda);
    internal static Delegate MakeRunVoid7(LightLambda lambda);
    internal TRet Run8(T0 arg0, T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5, T6 arg6, T7 arg7);
    internal void RunVoid8(T0 arg0, T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5, T6 arg6, T7 arg7);
    internal static Delegate MakeRun8(LightLambda lambda);
    internal static Delegate MakeRunVoid8(LightLambda lambda);
    internal TRet Run9(T0 arg0, T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5, T6 arg6, T7 arg7, T8 arg8);
    internal void RunVoid9(T0 arg0, T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5, T6 arg6, T7 arg7, T8 arg8);
    internal static Delegate MakeRun9(LightLambda lambda);
    internal static Delegate MakeRunVoid9(LightLambda lambda);
    internal TRet Run10(T0 arg0, T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5, T6 arg6, T7 arg7, T8 arg8, T9 arg9);
    internal void RunVoid10(T0 arg0, T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5, T6 arg6, T7 arg7, T8 arg8, T9 arg9);
    internal static Delegate MakeRun10(LightLambda lambda);
    internal static Delegate MakeRunVoid10(LightLambda lambda);
    internal TRet Run11(T0 arg0, T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5, T6 arg6, T7 arg7, T8 arg8, T9 arg9, T10 arg10);
    internal void RunVoid11(T0 arg0, T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5, T6 arg6, T7 arg7, T8 arg8, T9 arg9, T10 arg10);
    internal static Delegate MakeRun11(LightLambda lambda);
    internal static Delegate MakeRunVoid11(LightLambda lambda);
    internal TRet Run12(T0 arg0, T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5, T6 arg6, T7 arg7, T8 arg8, T9 arg9, T10 arg10, T11 arg11);
    internal void RunVoid12(T0 arg0, T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5, T6 arg6, T7 arg7, T8 arg8, T9 arg9, T10 arg10, T11 arg11);
    internal static Delegate MakeRun12(LightLambda lambda);
    internal static Delegate MakeRunVoid12(LightLambda lambda);
    internal TRet Run13(T0 arg0, T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5, T6 arg6, T7 arg7, T8 arg8, T9 arg9, T10 arg10, T11 arg11, T12 arg12);
    internal void RunVoid13(T0 arg0, T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5, T6 arg6, T7 arg7, T8 arg8, T9 arg9, T10 arg10, T11 arg11, T12 arg12);
    internal static Delegate MakeRun13(LightLambda lambda);
    internal static Delegate MakeRunVoid13(LightLambda lambda);
    internal TRet Run14(T0 arg0, T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5, T6 arg6, T7 arg7, T8 arg8, T9 arg9, T10 arg10, T11 arg11, T12 arg12, T13 arg13);
    internal void RunVoid14(T0 arg0, T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5, T6 arg6, T7 arg7, T8 arg8, T9 arg9, T10 arg10, T11 arg11, T12 arg12, T13 arg13);
    internal static Delegate MakeRun14(LightLambda lambda);
    internal static Delegate MakeRunVoid14(LightLambda lambda);
    internal TRet Run15(T0 arg0, T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5, T6 arg6, T7 arg7, T8 arg8, T9 arg9, T10 arg10, T11 arg11, T12 arg12, T13 arg13, T14 arg14);
    internal void RunVoid15(T0 arg0, T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5, T6 arg6, T7 arg7, T8 arg8, T9 arg9, T10 arg10, T11 arg11, T12 arg12, T13 arg13, T14 arg14);
    internal static Delegate MakeRun15(LightLambda lambda);
    internal static Delegate MakeRunVoid15(LightLambda lambda);
}
internal class Microsoft.Scripting.Interpreter.LightLambdaClosureVisitor : ExpressionVisitor {
    private Dictionary`2<ParameterExpression, LocalVariable> _closureVars;
    private ParameterExpression _closureArray;
    private Stack`1<HashSet`1<ParameterExpression>> _shadowedVars;
    private LightLambdaClosureVisitor(Dictionary`2<ParameterExpression, LocalVariable> closureVariables, ParameterExpression closureArray);
    internal static Func`2<StrongBox`1[], Delegate> BindLambda(LambdaExpression lambda, Dictionary`2<ParameterExpression, LocalVariable> closureVariables);
    protected virtual Expression VisitLambda(Expression`1<T> node);
    protected virtual Expression VisitBlock(BlockExpression node);
    protected virtual CatchBlock VisitCatchBlock(CatchBlock node);
    protected virtual Expression VisitRuntimeVariables(RuntimeVariablesExpression node);
    protected virtual Expression VisitParameter(ParameterExpression node);
    protected virtual Expression VisitBinary(BinaryExpression node);
    private Expression GetClosureItem(ParameterExpression variable, bool unbox);
    protected virtual Expression VisitExtension(Expression node);
}
public class Microsoft.Scripting.Interpreter.LightLambdaCompileEventArgs : EventArgs {
    [CompilerGeneratedAttribute]
private Delegate <Compiled>k__BackingField;
    public Delegate Compiled { get; }
    internal LightLambdaCompileEventArgs(Delegate compiled);
    [CompilerGeneratedAttribute]
public Delegate get_Compiled();
}
internal class Microsoft.Scripting.Interpreter.LoadCachedObjectInstruction : Instruction {
    private UInt32 _index;
    public int ProducedStack { get; }
    internal LoadCachedObjectInstruction(UInt32 index);
    public virtual int get_ProducedStack();
    public virtual int Run(InterpretedFrame frame);
    public virtual string ToDebugString(int instructionIndex, object cookie, Func`2<int, int> labelIndexer, IList`1<object> objects);
    public virtual string ToString();
}
internal class Microsoft.Scripting.Interpreter.LoadFieldInstruction : Instruction {
    private FieldInfo _field;
    public int ConsumedStack { get; }
    public int ProducedStack { get; }
    public LoadFieldInstruction(FieldInfo field);
    public virtual int get_ConsumedStack();
    public virtual int get_ProducedStack();
    public virtual int Run(InterpretedFrame frame);
}
internal class Microsoft.Scripting.Interpreter.LoadLocalBoxedInstruction : LocalAccessInstruction {
    public int ProducedStack { get; }
    internal LoadLocalBoxedInstruction(int index);
    public virtual int get_ProducedStack();
    public virtual int Run(InterpretedFrame frame);
}
internal class Microsoft.Scripting.Interpreter.LoadLocalFromClosureBoxedInstruction : LocalAccessInstruction {
    public int ProducedStack { get; }
    internal LoadLocalFromClosureBoxedInstruction(int index);
    public virtual int get_ProducedStack();
    public virtual int Run(InterpretedFrame frame);
}
internal class Microsoft.Scripting.Interpreter.LoadLocalFromClosureInstruction : LocalAccessInstruction {
    public int ProducedStack { get; }
    internal LoadLocalFromClosureInstruction(int index);
    public virtual int get_ProducedStack();
    public virtual int Run(InterpretedFrame frame);
}
internal class Microsoft.Scripting.Interpreter.LoadLocalInstruction : LocalAccessInstruction {
    public int ProducedStack { get; }
    internal LoadLocalInstruction(int index);
    public virtual int get_ProducedStack();
    public virtual int Run(InterpretedFrame frame);
    public sealed virtual Instruction BoxIfIndexMatches(int index);
}
internal class Microsoft.Scripting.Interpreter.LoadObjectInstruction : Instruction {
    private object _value;
    public int ProducedStack { get; }
    internal LoadObjectInstruction(object value);
    public virtual int get_ProducedStack();
    public virtual int Run(InterpretedFrame frame);
    public virtual string ToString();
}
internal class Microsoft.Scripting.Interpreter.LoadStaticFieldInstruction : Instruction {
    private FieldInfo _field;
    public int ProducedStack { get; }
    public LoadStaticFieldInstruction(FieldInfo field);
    public virtual int get_ProducedStack();
    public virtual int Run(InterpretedFrame frame);
}
internal abstract class Microsoft.Scripting.Interpreter.LocalAccessInstruction : Instruction {
    internal int _index;
    protected LocalAccessInstruction(int index);
    public virtual string ToDebugString(int instructionIndex, object cookie, Func`2<int, int> labelIndexer, IList`1<object> objects);
}
public class Microsoft.Scripting.Interpreter.LocalDefinition : ValueType {
    [CompilerGeneratedAttribute]
private int <Index>k__BackingField;
    [CompilerGeneratedAttribute]
private ParameterExpression <Parameter>k__BackingField;
    public int Index { get; }
    public ParameterExpression Parameter { get; }
    internal LocalDefinition(int localIndex, ParameterExpression parameter);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public int get_Index();
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public ParameterExpression get_Parameter();
    public virtual bool Equals(object obj);
    public sealed virtual bool Equals(LocalDefinition other);
    public virtual int GetHashCode();
    public static bool op_Equality(LocalDefinition self, LocalDefinition other);
    public static bool op_Inequality(LocalDefinition self, LocalDefinition other);
}
public class Microsoft.Scripting.Interpreter.LocalVariable : object {
    private static int IsBoxedFlag;
    private static int InClosureFlag;
    public int Index;
    private int _flags;
    public bool IsBoxed { get; public set; }
    public bool InClosure { get; }
    public bool InClosureOrBoxed { get; }
    internal LocalVariable(int index, bool closure, bool boxed);
    public bool get_IsBoxed();
    public void set_IsBoxed(bool value);
    public bool get_InClosure();
    public bool get_InClosureOrBoxed();
    internal Expression LoadFromArray(Expression frameData, Expression closure);
    public virtual string ToString();
}
public class Microsoft.Scripting.Interpreter.LocalVariables : object {
    private HybridReferenceDictionary`2<ParameterExpression, VariableScope> _variables;
    private int _localCount;
    private int _maxLocalCount;
    [CompilerGeneratedAttribute]
private Dictionary`2<ParameterExpression, LocalVariable> <ClosureVariables>k__BackingField;
    public int LocalCount { get; }
    internal Dictionary`2<ParameterExpression, LocalVariable> ClosureVariables { get; private set; }
    public LocalDefinition DefineLocal(ParameterExpression variable, int start);
    public void UndefineLocal(LocalDefinition definition, int end);
    internal void Box(ParameterExpression variable, InstructionList instructions);
    public int get_LocalCount();
    public int GetOrDefineLocal(ParameterExpression var);
    public int GetLocalIndex(ParameterExpression var);
    public bool TryGetLocalOrClosure(ParameterExpression var, LocalVariable& local);
    internal Dictionary`2<ParameterExpression, LocalVariable> CopyLocals();
    internal bool ContainsVariable(ParameterExpression variable);
    [CompilerGeneratedAttribute]
internal Dictionary`2<ParameterExpression, LocalVariable> get_ClosureVariables();
    [CompilerGeneratedAttribute]
private void set_ClosureVariables(Dictionary`2<ParameterExpression, LocalVariable> value);
    internal LocalVariable AddClosureVariable(ParameterExpression variable);
}
internal class Microsoft.Scripting.Interpreter.LoopCompiler : ExpressionVisitor {
    private ParameterExpression _frameDataVar;
    private ParameterExpression _frameClosureVar;
    private ParameterExpression _frameVar;
    private LabelTarget _returnLabel;
    private Dictionary`2<ParameterExpression, LocalVariable> _outerVariables;
    private Dictionary`2<ParameterExpression, LocalVariable> _closureVariables;
    private LoopExpression _loop;
    private ReadOnlyCollectionBuilder`1<ParameterExpression> _temps;
    private Dictionary`2<ParameterExpression, LoopVariable> _loopVariables;
    private HashSet`1<ParameterExpression> _loopLocals;
    private HybridReferenceDictionary`2<LabelTarget, BranchLabel> _labelMapping;
    private int _loopStartInstructionIndex;
    private int _loopEndInstructionIndex;
    internal LoopCompiler(LoopExpression loop, HybridReferenceDictionary`2<LabelTarget, BranchLabel> labelMapping, Dictionary`2<ParameterExpression, LocalVariable> locals, Dictionary`2<ParameterExpression, LocalVariable> closureVariables, int loopStartInstructionIndex, int loopEndInstructionIndex);
    internal Func`4<Object[], StrongBox`1[], InterpretedFrame, int> CreateDelegate();
    protected virtual Expression VisitExtension(Expression node);
    protected virtual Expression VisitGoto(GotoExpression node);
    protected virtual Expression VisitBlock(BlockExpression node);
    private HashSet`1<ParameterExpression> EnterVariableScope(ICollection`1<ParameterExpression> variables);
    protected virtual CatchBlock VisitCatchBlock(CatchBlock node);
    protected virtual Expression VisitLambda(Expression`1<T> node);
    private void ExitVariableScope(HashSet`1<ParameterExpression> prevLocals);
    protected virtual Expression VisitBinary(BinaryExpression node);
    protected virtual Expression VisitUnary(UnaryExpression node);
    protected virtual Expression VisitParameter(ParameterExpression node);
    private Expression VisitVariable(ParameterExpression node, ExpressionAccess access);
    private ParameterExpression AddTemp(ParameterExpression variable);
}
internal class Microsoft.Scripting.Interpreter.MethodInfoCallInstruction : CallInstruction {
    private MethodInfo _target;
    private int _argumentCount;
    public MethodInfo Info { get; }
    public int ArgumentCount { get; }
    internal MethodInfoCallInstruction(MethodInfo target, int argumentCount);
    public virtual MethodInfo get_Info();
    public virtual int get_ArgumentCount();
    public virtual object Invoke(Object[] args);
    public virtual object InvokeInstance(object instance, Object[] args);
    private object InvokeWorker(Object[] args);
    private static Object[] GetNonStaticArgs(Object[] args);
    public sealed virtual int Run(InterpretedFrame frame);
    public virtual object Invoke();
    public virtual object Invoke(object arg0);
    public virtual object Invoke(object arg0, object arg1);
}
public class Microsoft.Scripting.Interpreter.NewArrayBoundsInstruction : Instruction {
    private Type _elementType;
    private int _rank;
    public int ConsumedStack { get; }
    public int ProducedStack { get; }
    internal NewArrayBoundsInstruction(Type elementType, int rank);
    public virtual int get_ConsumedStack();
    public virtual int get_ProducedStack();
    public virtual int Run(InterpretedFrame frame);
}
public class Microsoft.Scripting.Interpreter.NewArrayInitInstruction`1 : Instruction {
    private int _elementCount;
    public int ConsumedStack { get; }
    public int ProducedStack { get; }
    internal NewArrayInitInstruction`1(int elementCount);
    public virtual int get_ConsumedStack();
    public virtual int get_ProducedStack();
    public virtual int Run(InterpretedFrame frame);
}
public class Microsoft.Scripting.Interpreter.NewArrayInstruction`1 : Instruction {
    public int ConsumedStack { get; }
    public int ProducedStack { get; }
    public virtual int get_ConsumedStack();
    public virtual int get_ProducedStack();
    public virtual int Run(InterpretedFrame frame);
}
internal class Microsoft.Scripting.Interpreter.NewInstruction : Instruction {
    private ConstructorInfo _constructor;
    private int _argCount;
    public int ConsumedStack { get; }
    public int ProducedStack { get; }
    public NewInstruction(ConstructorInfo constructor);
    public virtual int get_ConsumedStack();
    public virtual int get_ProducedStack();
    public virtual int Run(InterpretedFrame frame);
    public virtual string ToString();
}
internal abstract class Microsoft.Scripting.Interpreter.NotEqualInstruction : Instruction {
    private static Instruction _Reference;
    private static Instruction _Boolean;
    private static Instruction _SByte;
    private static Instruction _Int16;
    private static Instruction _Char;
    private static Instruction _Int32;
    private static Instruction _Int64;
    private static Instruction _Byte;
    private static Instruction _UInt16;
    private static Instruction _UInt32;
    private static Instruction _UInt64;
    private static Instruction _Single;
    private static Instruction _Double;
    public int ConsumedStack { get; }
    public int ProducedStack { get; }
    public virtual int get_ConsumedStack();
    public virtual int get_ProducedStack();
    public static Instruction Create(Type type);
    public virtual string ToString();
}
internal class Microsoft.Scripting.Interpreter.NotInstruction : Instruction {
    public static Instruction Instance;
    public int ConsumedStack { get; }
    public int ProducedStack { get; }
    private static NotInstruction();
    public virtual int get_ConsumedStack();
    public virtual int get_ProducedStack();
    public virtual int Run(InterpretedFrame frame);
}
internal abstract class Microsoft.Scripting.Interpreter.NumericConvertInstruction : Instruction {
    internal TypeCode _from;
    internal TypeCode _to;
    public int ConsumedStack { get; }
    public int ProducedStack { get; }
    protected NumericConvertInstruction(TypeCode from, TypeCode to);
    public virtual int get_ConsumedStack();
    public virtual int get_ProducedStack();
    public virtual string ToString();
}
internal abstract class Microsoft.Scripting.Interpreter.OffsetInstruction : Instruction {
    internal static int Unknown;
    internal static int CacheSize;
    protected int _offset;
    public int Offset { get; }
    public Instruction[] Cache { get; }
    public int get_Offset();
    public abstract virtual Instruction[] get_Cache();
    public Instruction Fixup(int offset);
    public virtual string ToDebugString(int instructionIndex, object cookie, Func`2<int, int> labelIndexer, IList`1<object> objects);
    public virtual string ToString();
}
internal class Microsoft.Scripting.Interpreter.PopInstruction : Instruction {
    internal static PopInstruction Instance;
    public int ConsumedStack { get; }
    private static PopInstruction();
    public virtual int get_ConsumedStack();
    public virtual int Run(InterpretedFrame frame);
    public virtual string ToString();
}
internal class Microsoft.Scripting.Interpreter.PopNInstruction : Instruction {
    private int _n;
    public int ConsumedStack { get; }
    internal PopNInstruction(int n);
    public virtual int get_ConsumedStack();
    public virtual int Run(InterpretedFrame frame);
    public virtual string ToString();
}
internal class Microsoft.Scripting.Interpreter.RuntimeLabel : ValueType {
    public int Index;
    public int StackDepth;
    public int ContinuationStackDepth;
    public RuntimeLabel(int index, int continuationStackDepth, int stackDepth);
    public virtual string ToString();
}
internal class Microsoft.Scripting.Interpreter.RuntimeVariables : object {
    private IStrongBox[] _boxes;
    private int System.Runtime.CompilerServices.IRuntimeVariables.Count { get; }
    private object System.Runtime.CompilerServices.IRuntimeVariables.Item { get; private set; }
    private RuntimeVariables(IStrongBox[] boxes);
    private sealed virtual override int System.Runtime.CompilerServices.IRuntimeVariables.get_Count();
    private sealed virtual override object System.Runtime.CompilerServices.IRuntimeVariables.get_Item(int index);
    private sealed virtual override void System.Runtime.CompilerServices.IRuntimeVariables.set_Item(int index, object value);
    internal static IRuntimeVariables Create(IStrongBox[] boxes);
}
internal class Microsoft.Scripting.Interpreter.RuntimeVariablesInstruction : Instruction {
    private int _count;
    public int ProducedStack { get; }
    public int ConsumedStack { get; }
    public RuntimeVariablesInstruction(int count);
    public virtual int get_ProducedStack();
    public virtual int get_ConsumedStack();
    public virtual int Run(InterpretedFrame frame);
    public virtual string ToString();
}
public class Microsoft.Scripting.Interpreter.SetArrayItemInstruction`1 : Instruction {
    public int ConsumedStack { get; }
    public int ProducedStack { get; }
    public string InstructionName { get; }
    public virtual int get_ConsumedStack();
    public virtual int get_ProducedStack();
    public virtual int Run(InterpretedFrame frame);
    public virtual string get_InstructionName();
}
internal class Microsoft.Scripting.Interpreter.StoreFieldInstruction : Instruction {
    private FieldInfo _field;
    public int ConsumedStack { get; }
    public int ProducedStack { get; }
    public StoreFieldInstruction(FieldInfo field);
    public virtual int get_ConsumedStack();
    public virtual int get_ProducedStack();
    public virtual int Run(InterpretedFrame frame);
}
internal class Microsoft.Scripting.Interpreter.StoreLocalBoxedInstruction : LocalAccessInstruction {
    public int ConsumedStack { get; }
    public int ProducedStack { get; }
    internal StoreLocalBoxedInstruction(int index);
    public virtual int get_ConsumedStack();
    public virtual int get_ProducedStack();
    public virtual int Run(InterpretedFrame frame);
}
internal class Microsoft.Scripting.Interpreter.StoreLocalInstruction : LocalAccessInstruction {
    public int ConsumedStack { get; }
    internal StoreLocalInstruction(int index);
    public virtual int get_ConsumedStack();
    public virtual int Run(InterpretedFrame frame);
    public sealed virtual Instruction BoxIfIndexMatches(int index);
}
internal class Microsoft.Scripting.Interpreter.StoreStaticFieldInstruction : Instruction {
    private FieldInfo _field;
    public int ConsumedStack { get; }
    public int ProducedStack { get; }
    public StoreStaticFieldInstruction(FieldInfo field);
    public virtual int get_ConsumedStack();
    public virtual int get_ProducedStack();
    public virtual int Run(InterpretedFrame frame);
}
internal class Microsoft.Scripting.Interpreter.SwitchInstruction : Instruction {
    private Dictionary`2<int, int> _cases;
    public int ConsumedStack { get; }
    public int ProducedStack { get; }
    internal SwitchInstruction(Dictionary`2<int, int> cases);
    public virtual int get_ConsumedStack();
    public virtual int get_ProducedStack();
    public virtual int Run(InterpretedFrame frame);
}
internal class Microsoft.Scripting.Interpreter.ThrowInstruction : Instruction {
    internal static ThrowInstruction Throw;
    internal static ThrowInstruction VoidThrow;
    internal static ThrowInstruction Rethrow;
    internal static ThrowInstruction VoidRethrow;
    private bool _hasResult;
    private bool _rethrow;
    public int ProducedStack { get; }
    public int ConsumedStack { get; }
    private ThrowInstruction(bool hasResult, bool isRethrow);
    private static ThrowInstruction();
    public virtual int get_ProducedStack();
    public virtual int get_ConsumedStack();
    public virtual int Run(InterpretedFrame frame);
}
internal class Microsoft.Scripting.Interpreter.TypeAsInstruction`1 : Instruction {
    public int ConsumedStack { get; }
    public int ProducedStack { get; }
    public virtual int get_ConsumedStack();
    public virtual int get_ProducedStack();
    public virtual int Run(InterpretedFrame frame);
    public virtual string ToString();
}
internal class Microsoft.Scripting.Interpreter.TypeEqualsInstruction : Instruction {
    public static TypeEqualsInstruction Instance;
    public int ConsumedStack { get; }
    public int ProducedStack { get; }
    public string InstructionName { get; }
    private static TypeEqualsInstruction();
    public virtual int get_ConsumedStack();
    public virtual int get_ProducedStack();
    public virtual int Run(InterpretedFrame frame);
    public virtual string get_InstructionName();
}
internal class Microsoft.Scripting.Interpreter.TypeIsInstruction`1 : Instruction {
    public int ConsumedStack { get; }
    public int ProducedStack { get; }
    public virtual int get_ConsumedStack();
    public virtual int get_ProducedStack();
    public virtual int Run(InterpretedFrame frame);
    public virtual string ToString();
}
public class Microsoft.Scripting.KeyboardInterruptException : Exception {
    public KeyboardInterruptException(string msg);
    public KeyboardInterruptException(string message, Exception innerException);
    protected KeyboardInterruptException(SerializationInfo info, StreamingContext context);
}
[ConditionalAttribute("DEBUG")]
[AttributeUsageAttribute("256")]
public class Microsoft.Scripting.MultiRuntimeAwareAttribute : Attribute {
}
public abstract class Microsoft.Scripting.MutableTuple : object {
    public static int MaxSize;
    private static Dictionary`2<Type, int> _sizeDict;
    public int Capacity { get; }
    private static MutableTuple();
    public abstract virtual object GetValue(int index);
    public abstract virtual void SetValue(int index, object value);
    public void SetNestedValue(int size, int index, object value);
    public object GetNestedValue(int size, int index);
    public static Type GetTupleType(int size);
    public static Type MakeTupleType(Type[] types);
    public static int GetSize(Type tupleType);
    public static MutableTuple MakeTuple(Type tupleType, Object[] args);
    public static Object[] GetTupleValues(MutableTuple tuple);
    public static IEnumerable`1<PropertyInfo> GetAccessPath(Type tupleType, int index);
    [IteratorStateMachineAttribute("Microsoft.Scripting.MutableTuple/<GetAccessPath>d__12")]
public static IEnumerable`1<PropertyInfo> GetAccessPath(Type tupleType, int size, int index);
    [IteratorStateMachineAttribute("Microsoft.Scripting.MutableTuple/<GetAccessPath>d__13")]
internal static IEnumerable`1<int> GetAccessPath(int size, int index);
    private static void GetTupleValues(MutableTuple tuple, List`1<object> args);
    private static MutableTuple MakeTuple(Type tupleType, int start, int end, Object[] args);
    private static MutableTuple CreateTupleInstance(Type tupleType, int start, int end, Object[] args);
    private static Type MakeTupleType(Type[] types, int start, int end);
    public abstract virtual int get_Capacity();
    public static Expression Create(Expression[] values);
    private static int PowerOfTwoRound(int value);
    internal static Expression CreateNew(Type tupleType, int start, int end, Expression[] values);
}
[GeneratedCodeAttribute("DLR", "2.0")]
public class Microsoft.Scripting.MutableTuple`1 : MutableTuple {
    [CompilerGeneratedAttribute]
private T0 <Item000>k__BackingField;
    public T0 Item000 { get; public set; }
    public int Capacity { get; }
    public MutableTuple`1(T0 item0);
    [CompilerGeneratedAttribute]
public T0 get_Item000();
    [CompilerGeneratedAttribute]
public void set_Item000(T0 value);
    public virtual object GetValue(int index);
    public virtual void SetValue(int index, object value);
    public virtual int get_Capacity();
}
[GeneratedCodeAttribute("DLR", "2.0")]
public class Microsoft.Scripting.MutableTuple`128 : MutableTuple`64<T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, T20, T21, T22, T23, T24, T25, T26, T27, T28, T29, T30, T31, T32, T33, T34, T35, T36, T37, T38, T39, T40, T41, T42, T43, T44, T45, T46, T47, T48, T49, T50, T51, T52, T53, T54, T55, T56, T57, T58, T59, T60, T61, T62, T63> {
    [CompilerGeneratedAttribute]
private T64 <Item064>k__BackingField;
    [CompilerGeneratedAttribute]
private T65 <Item065>k__BackingField;
    [CompilerGeneratedAttribute]
private T66 <Item066>k__BackingField;
    [CompilerGeneratedAttribute]
private T67 <Item067>k__BackingField;
    [CompilerGeneratedAttribute]
private T68 <Item068>k__BackingField;
    [CompilerGeneratedAttribute]
private T69 <Item069>k__BackingField;
    [CompilerGeneratedAttribute]
private T70 <Item070>k__BackingField;
    [CompilerGeneratedAttribute]
private T71 <Item071>k__BackingField;
    [CompilerGeneratedAttribute]
private T72 <Item072>k__BackingField;
    [CompilerGeneratedAttribute]
private T73 <Item073>k__BackingField;
    [CompilerGeneratedAttribute]
private T74 <Item074>k__BackingField;
    [CompilerGeneratedAttribute]
private T75 <Item075>k__BackingField;
    [CompilerGeneratedAttribute]
private T76 <Item076>k__BackingField;
    [CompilerGeneratedAttribute]
private T77 <Item077>k__BackingField;
    [CompilerGeneratedAttribute]
private T78 <Item078>k__BackingField;
    [CompilerGeneratedAttribute]
private T79 <Item079>k__BackingField;
    [CompilerGeneratedAttribute]
private T80 <Item080>k__BackingField;
    [CompilerGeneratedAttribute]
private T81 <Item081>k__BackingField;
    [CompilerGeneratedAttribute]
private T82 <Item082>k__BackingField;
    [CompilerGeneratedAttribute]
private T83 <Item083>k__BackingField;
    [CompilerGeneratedAttribute]
private T84 <Item084>k__BackingField;
    [CompilerGeneratedAttribute]
private T85 <Item085>k__BackingField;
    [CompilerGeneratedAttribute]
private T86 <Item086>k__BackingField;
    [CompilerGeneratedAttribute]
private T87 <Item087>k__BackingField;
    [CompilerGeneratedAttribute]
private T88 <Item088>k__BackingField;
    [CompilerGeneratedAttribute]
private T89 <Item089>k__BackingField;
    [CompilerGeneratedAttribute]
private T90 <Item090>k__BackingField;
    [CompilerGeneratedAttribute]
private T91 <Item091>k__BackingField;
    [CompilerGeneratedAttribute]
private T92 <Item092>k__BackingField;
    [CompilerGeneratedAttribute]
private T93 <Item093>k__BackingField;
    [CompilerGeneratedAttribute]
private T94 <Item094>k__BackingField;
    [CompilerGeneratedAttribute]
private T95 <Item095>k__BackingField;
    [CompilerGeneratedAttribute]
private T96 <Item096>k__BackingField;
    [CompilerGeneratedAttribute]
private T97 <Item097>k__BackingField;
    [CompilerGeneratedAttribute]
private T98 <Item098>k__BackingField;
    [CompilerGeneratedAttribute]
private T99 <Item099>k__BackingField;
    [CompilerGeneratedAttribute]
private T100 <Item100>k__BackingField;
    [CompilerGeneratedAttribute]
private T101 <Item101>k__BackingField;
    [CompilerGeneratedAttribute]
private T102 <Item102>k__BackingField;
    [CompilerGeneratedAttribute]
private T103 <Item103>k__BackingField;
    [CompilerGeneratedAttribute]
private T104 <Item104>k__BackingField;
    [CompilerGeneratedAttribute]
private T105 <Item105>k__BackingField;
    [CompilerGeneratedAttribute]
private T106 <Item106>k__BackingField;
    [CompilerGeneratedAttribute]
private T107 <Item107>k__BackingField;
    [CompilerGeneratedAttribute]
private T108 <Item108>k__BackingField;
    [CompilerGeneratedAttribute]
private T109 <Item109>k__BackingField;
    [CompilerGeneratedAttribute]
private T110 <Item110>k__BackingField;
    [CompilerGeneratedAttribute]
private T111 <Item111>k__BackingField;
    [CompilerGeneratedAttribute]
private T112 <Item112>k__BackingField;
    [CompilerGeneratedAttribute]
private T113 <Item113>k__BackingField;
    [CompilerGeneratedAttribute]
private T114 <Item114>k__BackingField;
    [CompilerGeneratedAttribute]
private T115 <Item115>k__BackingField;
    [CompilerGeneratedAttribute]
private T116 <Item116>k__BackingField;
    [CompilerGeneratedAttribute]
private T117 <Item117>k__BackingField;
    [CompilerGeneratedAttribute]
private T118 <Item118>k__BackingField;
    [CompilerGeneratedAttribute]
private T119 <Item119>k__BackingField;
    [CompilerGeneratedAttribute]
private T120 <Item120>k__BackingField;
    [CompilerGeneratedAttribute]
private T121 <Item121>k__BackingField;
    [CompilerGeneratedAttribute]
private T122 <Item122>k__BackingField;
    [CompilerGeneratedAttribute]
private T123 <Item123>k__BackingField;
    [CompilerGeneratedAttribute]
private T124 <Item124>k__BackingField;
    [CompilerGeneratedAttribute]
private T125 <Item125>k__BackingField;
    [CompilerGeneratedAttribute]
private T126 <Item126>k__BackingField;
    [CompilerGeneratedAttribute]
private T127 <Item127>k__BackingField;
    public T64 Item064 { get; public set; }
    public T65 Item065 { get; public set; }
    public T66 Item066 { get; public set; }
    public T67 Item067 { get; public set; }
    public T68 Item068 { get; public set; }
    public T69 Item069 { get; public set; }
    public T70 Item070 { get; public set; }
    public T71 Item071 { get; public set; }
    public T72 Item072 { get; public set; }
    public T73 Item073 { get; public set; }
    public T74 Item074 { get; public set; }
    public T75 Item075 { get; public set; }
    public T76 Item076 { get; public set; }
    public T77 Item077 { get; public set; }
    public T78 Item078 { get; public set; }
    public T79 Item079 { get; public set; }
    public T80 Item080 { get; public set; }
    public T81 Item081 { get; public set; }
    public T82 Item082 { get; public set; }
    public T83 Item083 { get; public set; }
    public T84 Item084 { get; public set; }
    public T85 Item085 { get; public set; }
    public T86 Item086 { get; public set; }
    public T87 Item087 { get; public set; }
    public T88 Item088 { get; public set; }
    public T89 Item089 { get; public set; }
    public T90 Item090 { get; public set; }
    public T91 Item091 { get; public set; }
    public T92 Item092 { get; public set; }
    public T93 Item093 { get; public set; }
    public T94 Item094 { get; public set; }
    public T95 Item095 { get; public set; }
    public T96 Item096 { get; public set; }
    public T97 Item097 { get; public set; }
    public T98 Item098 { get; public set; }
    public T99 Item099 { get; public set; }
    public T100 Item100 { get; public set; }
    public T101 Item101 { get; public set; }
    public T102 Item102 { get; public set; }
    public T103 Item103 { get; public set; }
    public T104 Item104 { get; public set; }
    public T105 Item105 { get; public set; }
    public T106 Item106 { get; public set; }
    public T107 Item107 { get; public set; }
    public T108 Item108 { get; public set; }
    public T109 Item109 { get; public set; }
    public T110 Item110 { get; public set; }
    public T111 Item111 { get; public set; }
    public T112 Item112 { get; public set; }
    public T113 Item113 { get; public set; }
    public T114 Item114 { get; public set; }
    public T115 Item115 { get; public set; }
    public T116 Item116 { get; public set; }
    public T117 Item117 { get; public set; }
    public T118 Item118 { get; public set; }
    public T119 Item119 { get; public set; }
    public T120 Item120 { get; public set; }
    public T121 Item121 { get; public set; }
    public T122 Item122 { get; public set; }
    public T123 Item123 { get; public set; }
    public T124 Item124 { get; public set; }
    public T125 Item125 { get; public set; }
    public T126 Item126 { get; public set; }
    public T127 Item127 { get; public set; }
    public int Capacity { get; }
    public MutableTuple`128(T0 item0, T1 item1, T2 item2, T3 item3, T4 item4, T5 item5, T6 item6, T7 item7, T8 item8, T9 item9, T10 item10, T11 item11, T12 item12, T13 item13, T14 item14, T15 item15, T16 item16, T17 item17, T18 item18, T19 item19, T20 item20, T21 item21, T22 item22, T23 item23, T24 item24, T25 item25, T26 item26, T27 item27, T28 item28, T29 item29, T30 item30, T31 item31, T32 item32, T33 item33, T34 item34, T35 item35, T36 item36, T37 item37, T38 item38, T39 item39, T40 item40, T41 item41, T42 item42, T43 item43, T44 item44, T45 item45, T46 item46, T47 item47, T48 item48, T49 item49, T50 item50, T51 item51, T52 item52, T53 item53, T54 item54, T55 item55, T56 item56, T57 item57, T58 item58, T59 item59, T60 item60, T61 item61, T62 item62, T63 item63, T64 item64, T65 item65, T66 item66, T67 item67, T68 item68, T69 item69, T70 item70, T71 item71, T72 item72, T73 item73, T74 item74, T75 item75, T76 item76, T77 item77, T78 item78, T79 item79, T80 item80, T81 item81, T82 item82, T83 item83, T84 item84, T85 item85, T86 item86, T87 item87, T88 item88, T89 item89, T90 item90, T91 item91, T92 item92, T93 item93, T94 item94, T95 item95, T96 item96, T97 item97, T98 item98, T99 item99, T100 item100, T101 item101, T102 item102, T103 item103, T104 item104, T105 item105, T106 item106, T107 item107, T108 item108, T109 item109, T110 item110, T111 item111, T112 item112, T113 item113, T114 item114, T115 item115, T116 item116, T117 item117, T118 item118, T119 item119, T120 item120, T121 item121, T122 item122, T123 item123, T124 item124, T125 item125, T126 item126, T127 item127);
    [CompilerGeneratedAttribute]
public T64 get_Item064();
    [CompilerGeneratedAttribute]
public void set_Item064(T64 value);
    [CompilerGeneratedAttribute]
public T65 get_Item065();
    [CompilerGeneratedAttribute]
public void set_Item065(T65 value);
    [CompilerGeneratedAttribute]
public T66 get_Item066();
    [CompilerGeneratedAttribute]
public void set_Item066(T66 value);
    [CompilerGeneratedAttribute]
public T67 get_Item067();
    [CompilerGeneratedAttribute]
public void set_Item067(T67 value);
    [CompilerGeneratedAttribute]
public T68 get_Item068();
    [CompilerGeneratedAttribute]
public void set_Item068(T68 value);
    [CompilerGeneratedAttribute]
public T69 get_Item069();
    [CompilerGeneratedAttribute]
public void set_Item069(T69 value);
    [CompilerGeneratedAttribute]
public T70 get_Item070();
    [CompilerGeneratedAttribute]
public void set_Item070(T70 value);
    [CompilerGeneratedAttribute]
public T71 get_Item071();
    [CompilerGeneratedAttribute]
public void set_Item071(T71 value);
    [CompilerGeneratedAttribute]
public T72 get_Item072();
    [CompilerGeneratedAttribute]
public void set_Item072(T72 value);
    [CompilerGeneratedAttribute]
public T73 get_Item073();
    [CompilerGeneratedAttribute]
public void set_Item073(T73 value);
    [CompilerGeneratedAttribute]
public T74 get_Item074();
    [CompilerGeneratedAttribute]
public void set_Item074(T74 value);
    [CompilerGeneratedAttribute]
public T75 get_Item075();
    [CompilerGeneratedAttribute]
public void set_Item075(T75 value);
    [CompilerGeneratedAttribute]
public T76 get_Item076();
    [CompilerGeneratedAttribute]
public void set_Item076(T76 value);
    [CompilerGeneratedAttribute]
public T77 get_Item077();
    [CompilerGeneratedAttribute]
public void set_Item077(T77 value);
    [CompilerGeneratedAttribute]
public T78 get_Item078();
    [CompilerGeneratedAttribute]
public void set_Item078(T78 value);
    [CompilerGeneratedAttribute]
public T79 get_Item079();
    [CompilerGeneratedAttribute]
public void set_Item079(T79 value);
    [CompilerGeneratedAttribute]
public T80 get_Item080();
    [CompilerGeneratedAttribute]
public void set_Item080(T80 value);
    [CompilerGeneratedAttribute]
public T81 get_Item081();
    [CompilerGeneratedAttribute]
public void set_Item081(T81 value);
    [CompilerGeneratedAttribute]
public T82 get_Item082();
    [CompilerGeneratedAttribute]
public void set_Item082(T82 value);
    [CompilerGeneratedAttribute]
public T83 get_Item083();
    [CompilerGeneratedAttribute]
public void set_Item083(T83 value);
    [CompilerGeneratedAttribute]
public T84 get_Item084();
    [CompilerGeneratedAttribute]
public void set_Item084(T84 value);
    [CompilerGeneratedAttribute]
public T85 get_Item085();
    [CompilerGeneratedAttribute]
public void set_Item085(T85 value);
    [CompilerGeneratedAttribute]
public T86 get_Item086();
    [CompilerGeneratedAttribute]
public void set_Item086(T86 value);
    [CompilerGeneratedAttribute]
public T87 get_Item087();
    [CompilerGeneratedAttribute]
public void set_Item087(T87 value);
    [CompilerGeneratedAttribute]
public T88 get_Item088();
    [CompilerGeneratedAttribute]
public void set_Item088(T88 value);
    [CompilerGeneratedAttribute]
public T89 get_Item089();
    [CompilerGeneratedAttribute]
public void set_Item089(T89 value);
    [CompilerGeneratedAttribute]
public T90 get_Item090();
    [CompilerGeneratedAttribute]
public void set_Item090(T90 value);
    [CompilerGeneratedAttribute]
public T91 get_Item091();
    [CompilerGeneratedAttribute]
public void set_Item091(T91 value);
    [CompilerGeneratedAttribute]
public T92 get_Item092();
    [CompilerGeneratedAttribute]
public void set_Item092(T92 value);
    [CompilerGeneratedAttribute]
public T93 get_Item093();
    [CompilerGeneratedAttribute]
public void set_Item093(T93 value);
    [CompilerGeneratedAttribute]
public T94 get_Item094();
    [CompilerGeneratedAttribute]
public void set_Item094(T94 value);
    [CompilerGeneratedAttribute]
public T95 get_Item095();
    [CompilerGeneratedAttribute]
public void set_Item095(T95 value);
    [CompilerGeneratedAttribute]
public T96 get_Item096();
    [CompilerGeneratedAttribute]
public void set_Item096(T96 value);
    [CompilerGeneratedAttribute]
public T97 get_Item097();
    [CompilerGeneratedAttribute]
public void set_Item097(T97 value);
    [CompilerGeneratedAttribute]
public T98 get_Item098();
    [CompilerGeneratedAttribute]
public void set_Item098(T98 value);
    [CompilerGeneratedAttribute]
public T99 get_Item099();
    [CompilerGeneratedAttribute]
public void set_Item099(T99 value);
    [CompilerGeneratedAttribute]
public T100 get_Item100();
    [CompilerGeneratedAttribute]
public void set_Item100(T100 value);
    [CompilerGeneratedAttribute]
public T101 get_Item101();
    [CompilerGeneratedAttribute]
public void set_Item101(T101 value);
    [CompilerGeneratedAttribute]
public T102 get_Item102();
    [CompilerGeneratedAttribute]
public void set_Item102(T102 value);
    [CompilerGeneratedAttribute]
public T103 get_Item103();
    [CompilerGeneratedAttribute]
public void set_Item103(T103 value);
    [CompilerGeneratedAttribute]
public T104 get_Item104();
    [CompilerGeneratedAttribute]
public void set_Item104(T104 value);
    [CompilerGeneratedAttribute]
public T105 get_Item105();
    [CompilerGeneratedAttribute]
public void set_Item105(T105 value);
    [CompilerGeneratedAttribute]
public T106 get_Item106();
    [CompilerGeneratedAttribute]
public void set_Item106(T106 value);
    [CompilerGeneratedAttribute]
public T107 get_Item107();
    [CompilerGeneratedAttribute]
public void set_Item107(T107 value);
    [CompilerGeneratedAttribute]
public T108 get_Item108();
    [CompilerGeneratedAttribute]
public void set_Item108(T108 value);
    [CompilerGeneratedAttribute]
public T109 get_Item109();
    [CompilerGeneratedAttribute]
public void set_Item109(T109 value);
    [CompilerGeneratedAttribute]
public T110 get_Item110();
    [CompilerGeneratedAttribute]
public void set_Item110(T110 value);
    [CompilerGeneratedAttribute]
public T111 get_Item111();
    [CompilerGeneratedAttribute]
public void set_Item111(T111 value);
    [CompilerGeneratedAttribute]
public T112 get_Item112();
    [CompilerGeneratedAttribute]
public void set_Item112(T112 value);
    [CompilerGeneratedAttribute]
public T113 get_Item113();
    [CompilerGeneratedAttribute]
public void set_Item113(T113 value);
    [CompilerGeneratedAttribute]
public T114 get_Item114();
    [CompilerGeneratedAttribute]
public void set_Item114(T114 value);
    [CompilerGeneratedAttribute]
public T115 get_Item115();
    [CompilerGeneratedAttribute]
public void set_Item115(T115 value);
    [CompilerGeneratedAttribute]
public T116 get_Item116();
    [CompilerGeneratedAttribute]
public void set_Item116(T116 value);
    [CompilerGeneratedAttribute]
public T117 get_Item117();
    [CompilerGeneratedAttribute]
public void set_Item117(T117 value);
    [CompilerGeneratedAttribute]
public T118 get_Item118();
    [CompilerGeneratedAttribute]
public void set_Item118(T118 value);
    [CompilerGeneratedAttribute]
public T119 get_Item119();
    [CompilerGeneratedAttribute]
public void set_Item119(T119 value);
    [CompilerGeneratedAttribute]
public T120 get_Item120();
    [CompilerGeneratedAttribute]
public void set_Item120(T120 value);
    [CompilerGeneratedAttribute]
public T121 get_Item121();
    [CompilerGeneratedAttribute]
public void set_Item121(T121 value);
    [CompilerGeneratedAttribute]
public T122 get_Item122();
    [CompilerGeneratedAttribute]
public void set_Item122(T122 value);
    [CompilerGeneratedAttribute]
public T123 get_Item123();
    [CompilerGeneratedAttribute]
public void set_Item123(T123 value);
    [CompilerGeneratedAttribute]
public T124 get_Item124();
    [CompilerGeneratedAttribute]
public void set_Item124(T124 value);
    [CompilerGeneratedAttribute]
public T125 get_Item125();
    [CompilerGeneratedAttribute]
public void set_Item125(T125 value);
    [CompilerGeneratedAttribute]
public T126 get_Item126();
    [CompilerGeneratedAttribute]
public void set_Item126(T126 value);
    [CompilerGeneratedAttribute]
public T127 get_Item127();
    [CompilerGeneratedAttribute]
public void set_Item127(T127 value);
    public virtual object GetValue(int index);
    public virtual void SetValue(int index, object value);
    public virtual int get_Capacity();
}
[GeneratedCodeAttribute("DLR", "2.0")]
public class Microsoft.Scripting.MutableTuple`16 : MutableTuple`8<T0, T1, T2, T3, T4, T5, T6, T7> {
    [CompilerGeneratedAttribute]
private T8 <Item008>k__BackingField;
    [CompilerGeneratedAttribute]
private T9 <Item009>k__BackingField;
    [CompilerGeneratedAttribute]
private T10 <Item010>k__BackingField;
    [CompilerGeneratedAttribute]
private T11 <Item011>k__BackingField;
    [CompilerGeneratedAttribute]
private T12 <Item012>k__BackingField;
    [CompilerGeneratedAttribute]
private T13 <Item013>k__BackingField;
    [CompilerGeneratedAttribute]
private T14 <Item014>k__BackingField;
    [CompilerGeneratedAttribute]
private T15 <Item015>k__BackingField;
    public T8 Item008 { get; public set; }
    public T9 Item009 { get; public set; }
    public T10 Item010 { get; public set; }
    public T11 Item011 { get; public set; }
    public T12 Item012 { get; public set; }
    public T13 Item013 { get; public set; }
    public T14 Item014 { get; public set; }
    public T15 Item015 { get; public set; }
    public int Capacity { get; }
    public MutableTuple`16(T0 item0, T1 item1, T2 item2, T3 item3, T4 item4, T5 item5, T6 item6, T7 item7, T8 item8, T9 item9, T10 item10, T11 item11, T12 item12, T13 item13, T14 item14, T15 item15);
    [CompilerGeneratedAttribute]
public T8 get_Item008();
    [CompilerGeneratedAttribute]
public void set_Item008(T8 value);
    [CompilerGeneratedAttribute]
public T9 get_Item009();
    [CompilerGeneratedAttribute]
public void set_Item009(T9 value);
    [CompilerGeneratedAttribute]
public T10 get_Item010();
    [CompilerGeneratedAttribute]
public void set_Item010(T10 value);
    [CompilerGeneratedAttribute]
public T11 get_Item011();
    [CompilerGeneratedAttribute]
public void set_Item011(T11 value);
    [CompilerGeneratedAttribute]
public T12 get_Item012();
    [CompilerGeneratedAttribute]
public void set_Item012(T12 value);
    [CompilerGeneratedAttribute]
public T13 get_Item013();
    [CompilerGeneratedAttribute]
public void set_Item013(T13 value);
    [CompilerGeneratedAttribute]
public T14 get_Item014();
    [CompilerGeneratedAttribute]
public void set_Item014(T14 value);
    [CompilerGeneratedAttribute]
public T15 get_Item015();
    [CompilerGeneratedAttribute]
public void set_Item015(T15 value);
    public virtual object GetValue(int index);
    public virtual void SetValue(int index, object value);
    public virtual int get_Capacity();
}
[GeneratedCodeAttribute("DLR", "2.0")]
public class Microsoft.Scripting.MutableTuple`2 : MutableTuple`1<T0> {
    [CompilerGeneratedAttribute]
private T1 <Item001>k__BackingField;
    public T1 Item001 { get; public set; }
    public int Capacity { get; }
    public MutableTuple`2(T0 item0, T1 item1);
    [CompilerGeneratedAttribute]
public T1 get_Item001();
    [CompilerGeneratedAttribute]
public void set_Item001(T1 value);
    public virtual object GetValue(int index);
    public virtual void SetValue(int index, object value);
    public virtual int get_Capacity();
}
[GeneratedCodeAttribute("DLR", "2.0")]
public class Microsoft.Scripting.MutableTuple`32 : MutableTuple`16<T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15> {
    [CompilerGeneratedAttribute]
private T16 <Item016>k__BackingField;
    [CompilerGeneratedAttribute]
private T17 <Item017>k__BackingField;
    [CompilerGeneratedAttribute]
private T18 <Item018>k__BackingField;
    [CompilerGeneratedAttribute]
private T19 <Item019>k__BackingField;
    [CompilerGeneratedAttribute]
private T20 <Item020>k__BackingField;
    [CompilerGeneratedAttribute]
private T21 <Item021>k__BackingField;
    [CompilerGeneratedAttribute]
private T22 <Item022>k__BackingField;
    [CompilerGeneratedAttribute]
private T23 <Item023>k__BackingField;
    [CompilerGeneratedAttribute]
private T24 <Item024>k__BackingField;
    [CompilerGeneratedAttribute]
private T25 <Item025>k__BackingField;
    [CompilerGeneratedAttribute]
private T26 <Item026>k__BackingField;
    [CompilerGeneratedAttribute]
private T27 <Item027>k__BackingField;
    [CompilerGeneratedAttribute]
private T28 <Item028>k__BackingField;
    [CompilerGeneratedAttribute]
private T29 <Item029>k__BackingField;
    [CompilerGeneratedAttribute]
private T30 <Item030>k__BackingField;
    [CompilerGeneratedAttribute]
private T31 <Item031>k__BackingField;
    public T16 Item016 { get; public set; }
    public T17 Item017 { get; public set; }
    public T18 Item018 { get; public set; }
    public T19 Item019 { get; public set; }
    public T20 Item020 { get; public set; }
    public T21 Item021 { get; public set; }
    public T22 Item022 { get; public set; }
    public T23 Item023 { get; public set; }
    public T24 Item024 { get; public set; }
    public T25 Item025 { get; public set; }
    public T26 Item026 { get; public set; }
    public T27 Item027 { get; public set; }
    public T28 Item028 { get; public set; }
    public T29 Item029 { get; public set; }
    public T30 Item030 { get; public set; }
    public T31 Item031 { get; public set; }
    public int Capacity { get; }
    public MutableTuple`32(T0 item0, T1 item1, T2 item2, T3 item3, T4 item4, T5 item5, T6 item6, T7 item7, T8 item8, T9 item9, T10 item10, T11 item11, T12 item12, T13 item13, T14 item14, T15 item15, T16 item16, T17 item17, T18 item18, T19 item19, T20 item20, T21 item21, T22 item22, T23 item23, T24 item24, T25 item25, T26 item26, T27 item27, T28 item28, T29 item29, T30 item30, T31 item31);
    [CompilerGeneratedAttribute]
public T16 get_Item016();
    [CompilerGeneratedAttribute]
public void set_Item016(T16 value);
    [CompilerGeneratedAttribute]
public T17 get_Item017();
    [CompilerGeneratedAttribute]
public void set_Item017(T17 value);
    [CompilerGeneratedAttribute]
public T18 get_Item018();
    [CompilerGeneratedAttribute]
public void set_Item018(T18 value);
    [CompilerGeneratedAttribute]
public T19 get_Item019();
    [CompilerGeneratedAttribute]
public void set_Item019(T19 value);
    [CompilerGeneratedAttribute]
public T20 get_Item020();
    [CompilerGeneratedAttribute]
public void set_Item020(T20 value);
    [CompilerGeneratedAttribute]
public T21 get_Item021();
    [CompilerGeneratedAttribute]
public void set_Item021(T21 value);
    [CompilerGeneratedAttribute]
public T22 get_Item022();
    [CompilerGeneratedAttribute]
public void set_Item022(T22 value);
    [CompilerGeneratedAttribute]
public T23 get_Item023();
    [CompilerGeneratedAttribute]
public void set_Item023(T23 value);
    [CompilerGeneratedAttribute]
public T24 get_Item024();
    [CompilerGeneratedAttribute]
public void set_Item024(T24 value);
    [CompilerGeneratedAttribute]
public T25 get_Item025();
    [CompilerGeneratedAttribute]
public void set_Item025(T25 value);
    [CompilerGeneratedAttribute]
public T26 get_Item026();
    [CompilerGeneratedAttribute]
public void set_Item026(T26 value);
    [CompilerGeneratedAttribute]
public T27 get_Item027();
    [CompilerGeneratedAttribute]
public void set_Item027(T27 value);
    [CompilerGeneratedAttribute]
public T28 get_Item028();
    [CompilerGeneratedAttribute]
public void set_Item028(T28 value);
    [CompilerGeneratedAttribute]
public T29 get_Item029();
    [CompilerGeneratedAttribute]
public void set_Item029(T29 value);
    [CompilerGeneratedAttribute]
public T30 get_Item030();
    [CompilerGeneratedAttribute]
public void set_Item030(T30 value);
    [CompilerGeneratedAttribute]
public T31 get_Item031();
    [CompilerGeneratedAttribute]
public void set_Item031(T31 value);
    public virtual object GetValue(int index);
    public virtual void SetValue(int index, object value);
    public virtual int get_Capacity();
}
[GeneratedCodeAttribute("DLR", "2.0")]
public class Microsoft.Scripting.MutableTuple`4 : MutableTuple`2<T0, T1> {
    [CompilerGeneratedAttribute]
private T2 <Item002>k__BackingField;
    [CompilerGeneratedAttribute]
private T3 <Item003>k__BackingField;
    public T2 Item002 { get; public set; }
    public T3 Item003 { get; public set; }
    public int Capacity { get; }
    public MutableTuple`4(T0 item0, T1 item1, T2 item2, T3 item3);
    [CompilerGeneratedAttribute]
public T2 get_Item002();
    [CompilerGeneratedAttribute]
public void set_Item002(T2 value);
    [CompilerGeneratedAttribute]
public T3 get_Item003();
    [CompilerGeneratedAttribute]
public void set_Item003(T3 value);
    public virtual object GetValue(int index);
    public virtual void SetValue(int index, object value);
    public virtual int get_Capacity();
}
[GeneratedCodeAttribute("DLR", "2.0")]
public class Microsoft.Scripting.MutableTuple`64 : MutableTuple`32<T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, T20, T21, T22, T23, T24, T25, T26, T27, T28, T29, T30, T31> {
    [CompilerGeneratedAttribute]
private T32 <Item032>k__BackingField;
    [CompilerGeneratedAttribute]
private T33 <Item033>k__BackingField;
    [CompilerGeneratedAttribute]
private T34 <Item034>k__BackingField;
    [CompilerGeneratedAttribute]
private T35 <Item035>k__BackingField;
    [CompilerGeneratedAttribute]
private T36 <Item036>k__BackingField;
    [CompilerGeneratedAttribute]
private T37 <Item037>k__BackingField;
    [CompilerGeneratedAttribute]
private T38 <Item038>k__BackingField;
    [CompilerGeneratedAttribute]
private T39 <Item039>k__BackingField;
    [CompilerGeneratedAttribute]
private T40 <Item040>k__BackingField;
    [CompilerGeneratedAttribute]
private T41 <Item041>k__BackingField;
    [CompilerGeneratedAttribute]
private T42 <Item042>k__BackingField;
    [CompilerGeneratedAttribute]
private T43 <Item043>k__BackingField;
    [CompilerGeneratedAttribute]
private T44 <Item044>k__BackingField;
    [CompilerGeneratedAttribute]
private T45 <Item045>k__BackingField;
    [CompilerGeneratedAttribute]
private T46 <Item046>k__BackingField;
    [CompilerGeneratedAttribute]
private T47 <Item047>k__BackingField;
    [CompilerGeneratedAttribute]
private T48 <Item048>k__BackingField;
    [CompilerGeneratedAttribute]
private T49 <Item049>k__BackingField;
    [CompilerGeneratedAttribute]
private T50 <Item050>k__BackingField;
    [CompilerGeneratedAttribute]
private T51 <Item051>k__BackingField;
    [CompilerGeneratedAttribute]
private T52 <Item052>k__BackingField;
    [CompilerGeneratedAttribute]
private T53 <Item053>k__BackingField;
    [CompilerGeneratedAttribute]
private T54 <Item054>k__BackingField;
    [CompilerGeneratedAttribute]
private T55 <Item055>k__BackingField;
    [CompilerGeneratedAttribute]
private T56 <Item056>k__BackingField;
    [CompilerGeneratedAttribute]
private T57 <Item057>k__BackingField;
    [CompilerGeneratedAttribute]
private T58 <Item058>k__BackingField;
    [CompilerGeneratedAttribute]
private T59 <Item059>k__BackingField;
    [CompilerGeneratedAttribute]
private T60 <Item060>k__BackingField;
    [CompilerGeneratedAttribute]
private T61 <Item061>k__BackingField;
    [CompilerGeneratedAttribute]
private T62 <Item062>k__BackingField;
    [CompilerGeneratedAttribute]
private T63 <Item063>k__BackingField;
    public T32 Item032 { get; public set; }
    public T33 Item033 { get; public set; }
    public T34 Item034 { get; public set; }
    public T35 Item035 { get; public set; }
    public T36 Item036 { get; public set; }
    public T37 Item037 { get; public set; }
    public T38 Item038 { get; public set; }
    public T39 Item039 { get; public set; }
    public T40 Item040 { get; public set; }
    public T41 Item041 { get; public set; }
    public T42 Item042 { get; public set; }
    public T43 Item043 { get; public set; }
    public T44 Item044 { get; public set; }
    public T45 Item045 { get; public set; }
    public T46 Item046 { get; public set; }
    public T47 Item047 { get; public set; }
    public T48 Item048 { get; public set; }
    public T49 Item049 { get; public set; }
    public T50 Item050 { get; public set; }
    public T51 Item051 { get; public set; }
    public T52 Item052 { get; public set; }
    public T53 Item053 { get; public set; }
    public T54 Item054 { get; public set; }
    public T55 Item055 { get; public set; }
    public T56 Item056 { get; public set; }
    public T57 Item057 { get; public set; }
    public T58 Item058 { get; public set; }
    public T59 Item059 { get; public set; }
    public T60 Item060 { get; public set; }
    public T61 Item061 { get; public set; }
    public T62 Item062 { get; public set; }
    public T63 Item063 { get; public set; }
    public int Capacity { get; }
    public MutableTuple`64(T0 item0, T1 item1, T2 item2, T3 item3, T4 item4, T5 item5, T6 item6, T7 item7, T8 item8, T9 item9, T10 item10, T11 item11, T12 item12, T13 item13, T14 item14, T15 item15, T16 item16, T17 item17, T18 item18, T19 item19, T20 item20, T21 item21, T22 item22, T23 item23, T24 item24, T25 item25, T26 item26, T27 item27, T28 item28, T29 item29, T30 item30, T31 item31, T32 item32, T33 item33, T34 item34, T35 item35, T36 item36, T37 item37, T38 item38, T39 item39, T40 item40, T41 item41, T42 item42, T43 item43, T44 item44, T45 item45, T46 item46, T47 item47, T48 item48, T49 item49, T50 item50, T51 item51, T52 item52, T53 item53, T54 item54, T55 item55, T56 item56, T57 item57, T58 item58, T59 item59, T60 item60, T61 item61, T62 item62, T63 item63);
    [CompilerGeneratedAttribute]
public T32 get_Item032();
    [CompilerGeneratedAttribute]
public void set_Item032(T32 value);
    [CompilerGeneratedAttribute]
public T33 get_Item033();
    [CompilerGeneratedAttribute]
public void set_Item033(T33 value);
    [CompilerGeneratedAttribute]
public T34 get_Item034();
    [CompilerGeneratedAttribute]
public void set_Item034(T34 value);
    [CompilerGeneratedAttribute]
public T35 get_Item035();
    [CompilerGeneratedAttribute]
public void set_Item035(T35 value);
    [CompilerGeneratedAttribute]
public T36 get_Item036();
    [CompilerGeneratedAttribute]
public void set_Item036(T36 value);
    [CompilerGeneratedAttribute]
public T37 get_Item037();
    [CompilerGeneratedAttribute]
public void set_Item037(T37 value);
    [CompilerGeneratedAttribute]
public T38 get_Item038();
    [CompilerGeneratedAttribute]
public void set_Item038(T38 value);
    [CompilerGeneratedAttribute]
public T39 get_Item039();
    [CompilerGeneratedAttribute]
public void set_Item039(T39 value);
    [CompilerGeneratedAttribute]
public T40 get_Item040();
    [CompilerGeneratedAttribute]
public void set_Item040(T40 value);
    [CompilerGeneratedAttribute]
public T41 get_Item041();
    [CompilerGeneratedAttribute]
public void set_Item041(T41 value);
    [CompilerGeneratedAttribute]
public T42 get_Item042();
    [CompilerGeneratedAttribute]
public void set_Item042(T42 value);
    [CompilerGeneratedAttribute]
public T43 get_Item043();
    [CompilerGeneratedAttribute]
public void set_Item043(T43 value);
    [CompilerGeneratedAttribute]
public T44 get_Item044();
    [CompilerGeneratedAttribute]
public void set_Item044(T44 value);
    [CompilerGeneratedAttribute]
public T45 get_Item045();
    [CompilerGeneratedAttribute]
public void set_Item045(T45 value);
    [CompilerGeneratedAttribute]
public T46 get_Item046();
    [CompilerGeneratedAttribute]
public void set_Item046(T46 value);
    [CompilerGeneratedAttribute]
public T47 get_Item047();
    [CompilerGeneratedAttribute]
public void set_Item047(T47 value);
    [CompilerGeneratedAttribute]
public T48 get_Item048();
    [CompilerGeneratedAttribute]
public void set_Item048(T48 value);
    [CompilerGeneratedAttribute]
public T49 get_Item049();
    [CompilerGeneratedAttribute]
public void set_Item049(T49 value);
    [CompilerGeneratedAttribute]
public T50 get_Item050();
    [CompilerGeneratedAttribute]
public void set_Item050(T50 value);
    [CompilerGeneratedAttribute]
public T51 get_Item051();
    [CompilerGeneratedAttribute]
public void set_Item051(T51 value);
    [CompilerGeneratedAttribute]
public T52 get_Item052();
    [CompilerGeneratedAttribute]
public void set_Item052(T52 value);
    [CompilerGeneratedAttribute]
public T53 get_Item053();
    [CompilerGeneratedAttribute]
public void set_Item053(T53 value);
    [CompilerGeneratedAttribute]
public T54 get_Item054();
    [CompilerGeneratedAttribute]
public void set_Item054(T54 value);
    [CompilerGeneratedAttribute]
public T55 get_Item055();
    [CompilerGeneratedAttribute]
public void set_Item055(T55 value);
    [CompilerGeneratedAttribute]
public T56 get_Item056();
    [CompilerGeneratedAttribute]
public void set_Item056(T56 value);
    [CompilerGeneratedAttribute]
public T57 get_Item057();
    [CompilerGeneratedAttribute]
public void set_Item057(T57 value);
    [CompilerGeneratedAttribute]
public T58 get_Item058();
    [CompilerGeneratedAttribute]
public void set_Item058(T58 value);
    [CompilerGeneratedAttribute]
public T59 get_Item059();
    [CompilerGeneratedAttribute]
public void set_Item059(T59 value);
    [CompilerGeneratedAttribute]
public T60 get_Item060();
    [CompilerGeneratedAttribute]
public void set_Item060(T60 value);
    [CompilerGeneratedAttribute]
public T61 get_Item061();
    [CompilerGeneratedAttribute]
public void set_Item061(T61 value);
    [CompilerGeneratedAttribute]
public T62 get_Item062();
    [CompilerGeneratedAttribute]
public void set_Item062(T62 value);
    [CompilerGeneratedAttribute]
public T63 get_Item063();
    [CompilerGeneratedAttribute]
public void set_Item063(T63 value);
    public virtual object GetValue(int index);
    public virtual void SetValue(int index, object value);
    public virtual int get_Capacity();
}
[GeneratedCodeAttribute("DLR", "2.0")]
public class Microsoft.Scripting.MutableTuple`8 : MutableTuple`4<T0, T1, T2, T3> {
    [CompilerGeneratedAttribute]
private T4 <Item004>k__BackingField;
    [CompilerGeneratedAttribute]
private T5 <Item005>k__BackingField;
    [CompilerGeneratedAttribute]
private T6 <Item006>k__BackingField;
    [CompilerGeneratedAttribute]
private T7 <Item007>k__BackingField;
    public T4 Item004 { get; public set; }
    public T5 Item005 { get; public set; }
    public T6 Item006 { get; public set; }
    public T7 Item007 { get; public set; }
    public int Capacity { get; }
    public MutableTuple`8(T0 item0, T1 item1, T2 item2, T3 item3, T4 item4, T5 item5, T6 item6, T7 item7);
    [CompilerGeneratedAttribute]
public T4 get_Item004();
    [CompilerGeneratedAttribute]
public void set_Item004(T4 value);
    [CompilerGeneratedAttribute]
public T5 get_Item005();
    [CompilerGeneratedAttribute]
public void set_Item005(T5 value);
    [CompilerGeneratedAttribute]
public T6 get_Item006();
    [CompilerGeneratedAttribute]
public void set_Item006(T6 value);
    [CompilerGeneratedAttribute]
public T7 get_Item007();
    [CompilerGeneratedAttribute]
public void set_Item007(T7 value);
    public virtual object GetValue(int index);
    public virtual void SetValue(int index, object value);
    public virtual int get_Capacity();
}
public static class Microsoft.Scripting.PerfTrack : object {
    private static int totalEvents;
    private static Dictionary`2<Categories, Dictionary`2<string, int>> _events;
    private static Dictionary`2<Categories, int> summaryStats;
    private static PerfTrack();
    private static Dictionary`2<Categories, Dictionary`2<string, int>> MakeEventsDictionary();
    public static void DumpHistogram(IDictionary`2<TKey, int> histogram);
    public static void DumpStats();
    public static void DumpHistogram(IDictionary`2<TKey, int> histogram, TextWriter output);
    public static void AddHistograms(IDictionary`2<TKey, int> result, IDictionary`2<TKey, int> addend);
    public static void IncrementEntry(IDictionary`2<TKey, int> histogram, TKey key);
    public static void DumpStats(TextWriter output);
    [ConditionalAttribute("DEBUG")]
public static void NoteEvent(Categories category, object key);
}
public class Microsoft.Scripting.Runtime.ArgumentArray : object {
    private Object[] _arguments;
    private int _first;
    [CompilerGeneratedAttribute]
private int <Count>k__BackingField;
    private static MethodInfo _GetArgMethod;
    public int Count { get; }
    internal ArgumentArray(Object[] arguments, int first, int count);
    private static ArgumentArray();
    [CompilerGeneratedAttribute]
public int get_Count();
    public object GetArgument(int index);
    public DynamicMetaObject GetMetaObject(Expression parameter, int index);
    [CLSCompliantAttribute("False")]
public static object GetArg(ArgumentArray array, int index);
}
internal static class Microsoft.Scripting.Runtime.AssemblyTypeNames : object {
    public static IEnumerable`1<TypeName> GetTypeNames(Assembly assem, bool includePrivateTypes);
    [IteratorStateMachineAttribute("Microsoft.Scripting.Runtime.AssemblyTypeNames/<GetTypeNames>d__1")]
private static IEnumerable`1<TypeName> GetTypeNames(String[] namespaces, String[][] types);
}
public static class Microsoft.Scripting.Runtime.BinderOps : object {
    public static Object[] GetCombinedParameters(Object[] initialArgs, object additionalArgs);
    public static Dictionary`2<TKey, TValue> MakeDictionary(String[] names, Object[] values);
    public static IReadOnlyDictionary`2<TKey, TValue> MakeReadOnlyDictionary(String[] names, Object[] values);
    public static ArgumentTypeException BadArgumentsForOperation(ExpressionType op, Object[] args);
    public static ArgumentTypeException TypeErrorForIncorrectArgumentCount(string methodName, int formalNormalArgumentCount, int defaultArgumentCount, int providedArgumentCount, bool hasArgList, bool keywordArgumentsProvided);
    public static ArgumentTypeException TypeErrorForIncorrectArgumentCount(string methodName, int minFormalNormalArgumentCount, int maxFormalNormalArgumentCount, int defaultArgumentCount, int providedArgumentCount, bool hasArgList, bool keywordArgumentsProvided);
    public static ArgumentTypeException TypeErrorForIncorrectArgumentCount(string name, int formalNormalArgumentCount, int defaultArgumentCount, int providedArgumentCount);
    public static ArgumentTypeException TypeErrorForIncorrectArgumentCount(string name, int expected, int received);
    public static ArgumentTypeException TypeErrorForExtraKeywordArgument(string name, string argumentName);
    public static ArgumentTypeException TypeErrorForDuplicateKeywordArgument(string name, string argumentName);
    public static ArgumentTypeException TypeErrorForDuplicateArgument(string name, int position, string argumentName);
    public static ArgumentTypeException TypeErrorForNonInferrableMethod(string name);
    public static ArgumentTypeException SimpleTypeError(string message);
    public static ArgumentTypeException InvalidSplatteeError(string name, string typeName);
    public static object InvokeMethod(MethodBase mb, object obj, Object[] args);
    public static object InvokeConstructor(ConstructorInfo ci, Object[] args);
    public static bool CheckDictionaryMembers(IDictionary dict, String[] names, Type[] types);
    public static IList`1<string> GetStringMembers(IList`1<object> members);
    public static Type GetEventHandlerType(EventInfo eventInfo);
    public static void SetEvent(EventTracker eventTracker, object value);
}
public enum Microsoft.Scripting.Runtime.BinderType : Enum {
    public int value__;
    public static BinderType Normal;
    public static BinderType BinaryOperator;
    public static BinderType ComparisonOperator;
    public static BinderType Constructor;
}
public static class Microsoft.Scripting.Runtime.BindingRestrictionsHelpers : object {
    public static BindingRestrictions GetRuntimeTypeRestriction(Expression expr, Type type);
    public static BindingRestrictions GetRuntimeTypeRestriction(DynamicMetaObject obj);
}
[AttributeUsageAttribute("64")]
public class Microsoft.Scripting.Runtime.CachedOptimizedCodeAttribute : Attribute {
    [CompilerGeneratedAttribute]
private String[] <Names>k__BackingField;
    public String[] Names { get; }
    public CachedOptimizedCodeAttribute(String[] names);
    [CompilerGeneratedAttribute]
public String[] get_Names();
}
[FlagsAttribute]
public enum Microsoft.Scripting.Runtime.CallTypes : Enum {
    public int value__;
    public static CallTypes None;
    public static CallTypes ImplicitInstance;
}
[GeneratedCodeAttribute("DLR", "2.0")]
public static class Microsoft.Scripting.Runtime.Cast : object {
    internal static Type BooleanType;
    internal static Type ByteType;
    internal static Type CharType;
    internal static Type DecimalType;
    internal static Type DoubleType;
    internal static Type Int16Type;
    internal static Type Int32Type;
    internal static Type Int64Type;
    internal static Type ObjectType;
    internal static Type SByteType;
    internal static Type SingleType;
    internal static Type UInt16Type;
    internal static Type UInt32Type;
    internal static Type UInt64Type;
    internal static Type NullableBooleanType;
    internal static Type NullableByteType;
    internal static Type NullableCharType;
    internal static Type NullableDecimalType;
    internal static Type NullableDoubleType;
    internal static Type NullableInt16Type;
    internal static Type NullableInt32Type;
    internal static Type NullableInt64Type;
    internal static Type NullableSByteType;
    internal static Type NullableSingleType;
    internal static Type NullableUInt16Type;
    internal static Type NullableUInt32Type;
    internal static Type NullableUInt64Type;
    internal static Type NullableType;
    private static Cast();
    public static object Explicit(object o, Type to);
    public static T Explicit(object o);
    private static object ExplicitCastToValueType(object o, Type to);
    private static object NewNullableInstanceSlow(Type type);
    private static InvalidCastException InvalidCast(object o, string typeName);
    public static bool ExplicitCastToBoolean(object o);
    public static byte ExplicitCastToByte(object o);
    public static char ExplicitCastToChar(object o);
    public static decimal ExplicitCastToDecimal(object o);
    public static double ExplicitCastToDouble(object o);
    public static short ExplicitCastToInt16(object o);
    public static int ExplicitCastToInt32(object o);
    public static long ExplicitCastToInt64(object o);
    [CLSCompliantAttribute("False")]
public static sbyte ExplicitCastToSByte(object o);
    public static float ExplicitCastToSingle(object o);
    [CLSCompliantAttribute("False")]
public static ushort ExplicitCastToUInt16(object o);
    [CLSCompliantAttribute("False")]
public static UInt32 ExplicitCastToUInt32(object o);
    [CLSCompliantAttribute("False")]
public static ulong ExplicitCastToUInt64(object o);
    public static Nullable`1<bool> ExplicitCastToNullableBoolean(object o);
    public static Nullable`1<byte> ExplicitCastToNullableByte(object o);
    public static Nullable`1<char> ExplicitCastToNullableChar(object o);
    public static Nullable`1<decimal> ExplicitCastToNullableDecimal(object o);
    public static Nullable`1<double> ExplicitCastToNullableDouble(object o);
    public static Nullable`1<short> ExplicitCastToNullableInt16(object o);
    public static Nullable`1<int> ExplicitCastToNullableInt32(object o);
    public static Nullable`1<long> ExplicitCastToNullableInt64(object o);
    [CLSCompliantAttribute("False")]
public static Nullable`1<sbyte> ExplicitCastToNullableSByte(object o);
    public static Nullable`1<float> ExplicitCastToNullableSingle(object o);
    [CLSCompliantAttribute("False")]
public static Nullable`1<ushort> ExplicitCastToNullableUInt16(object o);
    [CLSCompliantAttribute("False")]
public static Nullable`1<UInt32> ExplicitCastToNullableUInt32(object o);
    [CLSCompliantAttribute("False")]
public static Nullable`1<ulong> ExplicitCastToNullableUInt64(object o);
    public static object NewNullableInstance(Type type);
    internal static byte ExplicitCastEnumToByte(object o);
    internal static sbyte ExplicitCastEnumToSByte(object o);
    internal static short ExplicitCastEnumToInt16(object o);
    internal static ushort ExplicitCastEnumToUInt16(object o);
    internal static int ExplicitCastEnumToInt32(object o);
    internal static UInt32 ExplicitCastEnumToUInt32(object o);
    internal static long ExplicitCastEnumToInt64(object o);
    internal static ulong ExplicitCastEnumToUInt64(object o);
}
public abstract class Microsoft.Scripting.Runtime.CodeDomCodeGen : object {
    protected static object SourceSpanKey;
    [CompilerGeneratedAttribute]
private PositionTrackingWriter <Writer>k__BackingField;
    protected PositionTrackingWriter Writer { get; private set; }
    private static CodeDomCodeGen();
    [CompilerGeneratedAttribute]
protected PositionTrackingWriter get_Writer();
    [CompilerGeneratedAttribute]
private void set_Writer(PositionTrackingWriter value);
    protected abstract virtual void WriteExpressionStatement(CodeExpressionStatement s);
    protected abstract virtual void WriteFunctionDefinition(CodeMemberMethod func);
    protected abstract virtual string QuoteString(string val);
    public SourceUnit GenerateCode(CodeMemberMethod codeDom, LanguageContext context, string path, SourceCodeKind kind);
    private SourceUnit CreateSourceUnit(LanguageContext context, string path, SourceCodeKind kind);
    protected virtual void WriteArgumentReferenceExpression(CodeArgumentReferenceExpression e);
    protected virtual void WriteSnippetExpression(CodeSnippetExpression e);
    protected virtual void WriteSnippetStatement(CodeSnippetStatement s);
    protected void WriteStatement(CodeStatement s);
    protected void WriteExpression(CodeExpression e);
    protected void WritePrimitiveExpression(CodePrimitiveExpression e);
    protected void WriteCallExpression(CodeMethodInvokeExpression m);
}
public class Microsoft.Scripting.Runtime.CompilerContext : object {
    [CompilerGeneratedAttribute]
private SourceUnit <SourceUnit>k__BackingField;
    [CompilerGeneratedAttribute]
private ParserSink <ParserSink>k__BackingField;
    [CompilerGeneratedAttribute]
private ErrorSink <Errors>k__BackingField;
    [CompilerGeneratedAttribute]
private CompilerOptions <Options>k__BackingField;
    public SourceUnit SourceUnit { get; }
    public ParserSink ParserSink { get; }
    public ErrorSink Errors { get; }
    public CompilerOptions Options { get; }
    public CompilerContext(SourceUnit sourceUnit, CompilerOptions options, ErrorSink errorSink);
    public CompilerContext(SourceUnit sourceUnit, CompilerOptions options, ErrorSink errorSink, ParserSink parserSink);
    [CompilerGeneratedAttribute]
public SourceUnit get_SourceUnit();
    [CompilerGeneratedAttribute]
public ParserSink get_ParserSink();
    [CompilerGeneratedAttribute]
public ErrorSink get_Errors();
    [CompilerGeneratedAttribute]
public CompilerOptions get_Options();
}
[DefaultMemberAttribute("Item")]
[DebuggerDisplayAttribute("Count = {Count}")]
public abstract class Microsoft.Scripting.Runtime.CustomStringDictionary : object {
    private Dictionary`2<object, object> _data;
    private static object _nullObject;
    public ICollection`1<object> Keys { get; }
    private ICollection`1<object> System.Collections.Generic.IDictionary<System.Object,System.Object>.Values { get; }
    public object Item { get; public set; }
    public int Count { get; }
    public bool IsReadOnly { get; }
    public bool IsFixedSize { get; }
    private ICollection System.Collections.IDictionary.Keys { get; }
    private ICollection System.Collections.IDictionary.Values { get; }
    public bool IsSynchronized { get; }
    public object SyncRoot { get; }
    private static CustomStringDictionary();
    public abstract virtual String[] GetExtraKeys();
    protected internal abstract virtual bool TrySetExtraValue(string key, object value);
    protected internal abstract virtual bool TryGetExtraValue(string key, Object& value);
    private void InitializeData();
    private sealed virtual override void System.Collections.Generic.IDictionary<System.Object,System.Object>.Add(object key, object value);
    private void AddObjectKey(object key, object value);
    private sealed virtual override bool System.Collections.Generic.IDictionary<System.Object,System.Object>.ContainsKey(object key);
    public sealed virtual ICollection`1<object> get_Keys();
    private sealed virtual override bool System.Collections.Generic.IDictionary<System.Object,System.Object>.Remove(object key);
    private bool RemoveObjectKey(object key);
    public sealed virtual bool TryGetValue(object key, Object& value);
    private bool TryGetObjectValue(object key, Object& value);
    private sealed virtual override ICollection`1<object> System.Collections.Generic.IDictionary<System.Object,System.Object>.get_Values();
    public sealed virtual object get_Item(object key);
    public sealed virtual void set_Item(object key, object value);
    public sealed virtual void Add(KeyValuePair`2<object, object> item);
    public sealed virtual void Clear();
    public sealed virtual bool Contains(KeyValuePair`2<object, object> item);
    public sealed virtual void CopyTo(KeyValuePair`2[] array, int arrayIndex);
    public sealed virtual int get_Count();
    public sealed virtual bool get_IsReadOnly();
    public sealed virtual bool Remove(KeyValuePair`2<object, object> item);
    public bool Remove(object key);
    [IteratorStateMachineAttribute("Microsoft.Scripting.Runtime.CustomStringDictionary/<System-Collections-Generic-IEnumerable<System-Collections-Generic-KeyValuePair<System-Object,System-Object>>-GetEnumerator>d__30")]
private sealed virtual override IEnumerator`1<KeyValuePair`2<object, object>> System.Collections.Generic.IEnumerable<System.Collections.Generic.KeyValuePair<System.Object,System.Object>>.GetEnumerator();
    public sealed virtual IEnumerator GetEnumerator();
    private sealed virtual override void System.Collections.IDictionary.Add(object key, object value);
    public sealed virtual bool Contains(object key);
    private sealed virtual override IDictionaryEnumerator System.Collections.IDictionary.GetEnumerator();
    public sealed virtual bool get_IsFixedSize();
    private sealed virtual override ICollection System.Collections.IDictionary.get_Keys();
    private sealed virtual override void System.Collections.IDictionary.Remove(object key);
    private sealed virtual override ICollection System.Collections.IDictionary.get_Values();
    public int GetValueHashCode();
    public virtual bool ValueEquals(object other);
    public sealed virtual void CopyTo(Array array, int index);
    public sealed virtual bool get_IsSynchronized();
    public sealed virtual object get_SyncRoot();
    public static object NullToObj(object o);
    public static object ObjToNull(object o);
    public static bool IsNullObject(object o);
}
[ObsoleteAttribute("Derive directly from CustomStringDictionary instead")]
public abstract class Microsoft.Scripting.Runtime.CustomSymbolDictionary : CustomStringDictionary {
}
internal class Microsoft.Scripting.Runtime.DebugGeneratorEnumerable`1 : GeneratorEnumerable`1<T> {
    private Int32[] _yieldMarkers;
    internal DebugGeneratorEnumerable`1(Func`1<GeneratorNext`1<T>> next, Int32[] yieldMarkers);
    private sealed virtual override IEnumerator`1<T> System.Collections.Generic.IEnumerable<T>.GetEnumerator();
}
internal class Microsoft.Scripting.Runtime.DebugGeneratorEnumerator`1 : GeneratorEnumerator`1<T> {
    private Int32[] _yieldMarkers;
    private int Microsoft.Scripting.Runtime.IDebuggableGenerator.YieldMarkerLocation { get; private set; }
    internal DebugGeneratorEnumerator`1(GeneratorNext`1<T> next, Int32[] yieldMarkers);
    private sealed virtual override int Microsoft.Scripting.Runtime.IDebuggableGenerator.get_YieldMarkerLocation();
    private sealed virtual override void Microsoft.Scripting.Runtime.IDebuggableGenerator.set_YieldMarkerLocation(int value);
}
public class Microsoft.Scripting.Runtime.DelegateInfo : object {
    private static int TargetIndex;
    private static int CallSiteIndex;
    private static int ConvertSiteIndex;
    private static object TargetPlaceHolder;
    private static object CallSitePlaceHolder;
    private static object ConvertSitePlaceHolder;
    private WeakDictionary`2<object, WeakReference> _closureMap;
    private Type _returnType;
    private Type[] _parameterTypes;
    private MethodInfo _method;
    private InvokeBinder _invokeBinder;
    private ConvertBinder _convertBinder;
    public DelegateInfo(LanguageContext context, Type returnType, Type[] parameters);
    private static DelegateInfo();
    public Delegate CreateDelegate(Type delegateType, object dynamicObject);
    private void EmitClrCallStub(Type returnType, Type[] parameterTypes, MethodInfo& method);
    private void EmitClrCallStub(ILGen cg);
    private static void EmitConstantGet(ILGen il, int index, Type type);
    private static Type[] MakeSiteSignature(Type[] parameterTypes);
}
internal class Microsoft.Scripting.Runtime.DelegateSignatureInfo : object {
    [CompilerGeneratedAttribute]
private Type <ReturnType>k__BackingField;
    [CompilerGeneratedAttribute]
private Type[] <ParameterTypes>k__BackingField;
    internal Type ReturnType { get; }
    internal Type[] ParameterTypes { get; }
    internal DelegateSignatureInfo(MethodInfo invoke);
    [CompilerGeneratedAttribute]
internal Type get_ReturnType();
    [CompilerGeneratedAttribute]
internal Type[] get_ParameterTypes();
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public virtual string ToString();
}
[AttributeUsageAttribute("4")]
public class Microsoft.Scripting.Runtime.DlrCachedCodeAttribute : Attribute {
}
public class Microsoft.Scripting.Runtime.DlrMainCallTarget : MulticastDelegate {
    public DlrMainCallTarget(object object, IntPtr method);
    public virtual object Invoke(Scope scope, LanguageContext context);
    public virtual IAsyncResult BeginInvoke(Scope scope, LanguageContext context, AsyncCallback callback, object object);
    public virtual object EndInvoke(IAsyncResult result);
}
[AttributeUsageAttribute("32767")]
public class Microsoft.Scripting.Runtime.DocumentationAttribute : Attribute {
    [CompilerGeneratedAttribute]
private string <Documentation>k__BackingField;
    public string Documentation { get; }
    public DocumentationAttribute(string documentation);
    [CompilerGeneratedAttribute]
public string get_Documentation();
}
public class Microsoft.Scripting.Runtime.DynamicDelegateCreator : object {
    private LanguageContext _languageContext;
    private Publisher`2<DelegateSignatureInfo, DelegateInfo> _dynamicDelegateCache;
    public DynamicDelegateCreator(LanguageContext languageContext);
    public Delegate GetDelegate(object callableObject, Type delegateType);
    public Delegate GetOrCreateDelegateForDynamicObject(object dynamicObject, Type delegateType, MethodInfo invoke);
}
public class Microsoft.Scripting.Runtime.DynamicNull : object {
}
public static class Microsoft.Scripting.Runtime.ExceptionHelpers : object {
    private static string prevStackTraces;
    public static Exception UpdateForRethrow(Exception rethrow);
    public static IList`1<StackTrace> GetExceptionStackTraces(Exception rethrow);
    private static void AssociateStackTraces(Exception e, List`1<StackTrace> traces);
    private static bool TryGetAssociatedStackTraces(Exception e, List`1& traces);
}
[AttributeUsageAttribute("64")]
public class Microsoft.Scripting.Runtime.ExplicitConversionMethodAttribute : Attribute {
}
public class Microsoft.Scripting.Runtime.Extensible`1 : object {
    [CompilerGeneratedAttribute]
private T <Value>k__BackingField;
    public T Value { get; }
    public Extensible`1(T value);
    [CompilerGeneratedAttribute]
public T get_Value();
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public virtual string ToString();
    public static T op_Implicit(Extensible`1<T> extensible);
}
[AttributeUsageAttribute("1")]
public class Microsoft.Scripting.Runtime.ExtensionTypeAttribute : Attribute {
    [CompilerGeneratedAttribute]
private Type <ExtensionType>k__BackingField;
    [CompilerGeneratedAttribute]
private Type <Extends>k__BackingField;
    public Type ExtensionType { get; }
    public Type Extends { get; }
    public ExtensionTypeAttribute(Type extends, Type extensionType);
    [CompilerGeneratedAttribute]
public Type get_ExtensionType();
    [CompilerGeneratedAttribute]
public Type get_Extends();
}
internal class Microsoft.Scripting.Runtime.ExtraKeyEnumerator : CheckedDictionaryEnumerator {
    private CustomStringDictionary _idDict;
    private int _curIndex;
    public ExtraKeyEnumerator(CustomStringDictionary idDict);
    protected virtual object GetKey();
    protected virtual object GetValue();
    protected virtual bool DoMoveNext();
    protected virtual void DoReset();
}
internal class Microsoft.Scripting.Runtime.GeneratorEnumerable`1 : object {
    protected Func`1<GeneratorNext`1<T>> _next;
    internal GeneratorEnumerable`1(Func`1<GeneratorNext`1<T>> next);
    private sealed virtual override IEnumerator`1<T> System.Collections.Generic.IEnumerable<T>.GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
}
internal class Microsoft.Scripting.Runtime.GeneratorEnumerator`1 : object {
    private GeneratorNext`1<T> _next;
    private T _current;
    protected int _state;
    private T System.Collections.Generic.IEnumerator<T>.Current { get; }
    private object System.Collections.IEnumerator.Current { get; }
    internal GeneratorEnumerator`1(GeneratorNext`1<T> next);
    private sealed virtual override T System.Collections.Generic.IEnumerator<T>.get_Current();
    private sealed virtual override bool System.Collections.IEnumerator.MoveNext();
    private sealed virtual override object System.Collections.IEnumerator.get_Current();
    private sealed virtual override void System.Collections.IEnumerator.Reset();
    private sealed virtual override void System.IDisposable.Dispose();
}
public class Microsoft.Scripting.Runtime.GeneratorNext`1 : MulticastDelegate {
    public GeneratorNext`1(object object, IntPtr method);
    public virtual void Invoke(Int32& state, T& current);
    public virtual IAsyncResult BeginInvoke(Int32& state, T& current, AsyncCallback callback, object object);
    public virtual void EndInvoke(Int32& state, T& current, IAsyncResult result);
}
public interface Microsoft.Scripting.Runtime.IConvertibleMetaObject {
    public abstract virtual bool CanConvertTo(Type type, bool isExplicit);
}
public static class Microsoft.Scripting.Runtime.IdDispenser : object {
    private static IEqualityComparer`1<object> _comparer;
    private static Dictionary`2<object, object> _hashtable;
    private static object _synchObject;
    private static long _currentId;
    private static long _cleanupId;
    private static int _cleanupGC;
    private static IdDispenser();
    public static object GetObject(long id);
    public static long GetId(object o);
    private static void Cleanup();
}
public interface Microsoft.Scripting.Runtime.IDebuggableGenerator {
    public int YieldMarkerLocation { get; public set; }
    public abstract virtual int get_YieldMarkerLocation();
    public abstract virtual void set_YieldMarkerLocation(int value);
}
public interface Microsoft.Scripting.Runtime.IExpressionSerializable {
    public abstract virtual Expression CreateExpression();
}
public interface Microsoft.Scripting.Runtime.IMembersList {
    public abstract virtual IList`1<string> GetMemberNames();
}
[AttributeUsageAttribute("64")]
public class Microsoft.Scripting.Runtime.ImplicitConversionMethodAttribute : Attribute {
}
public interface Microsoft.Scripting.Runtime.IRestrictedMetaObject {
    public abstract virtual DynamicMetaObject Restrict(Type type);
}
public interface Microsoft.Scripting.Runtime.ISlice {
    public object Start { get; }
    public object Stop { get; }
    public object Step { get; }
    public abstract virtual object get_Start();
    public abstract virtual object get_Stop();
    public abstract virtual object get_Step();
}
internal class Microsoft.Scripting.Runtime.LanguageBoundTextContentProvider : TextContentProvider {
    private LanguageContext _context;
    private StreamContentProvider _streamProvider;
    private Encoding _defaultEncoding;
    private string _path;
    public LanguageBoundTextContentProvider(LanguageContext context, StreamContentProvider streamProvider, Encoding defaultEncoding, string path);
    public virtual SourceCodeReader GetReader();
}
[ExtensionAttribute]
public static class Microsoft.Scripting.Runtime.LightExceptions : object {
    internal static MethodInfo _checkAndThrow;
    private static LightExceptions();
    public static Expression Rewrite(Expression expression);
    public static Expression RewriteLazy(Expression expression);
    public static Expression RewriteExternal(Expression expression);
    public static object Throw(Exception exceptionValue);
    public static Expression Throw(Expression exceptionValue);
    public static Expression Throw(Expression exceptionValue, Type retType);
    [ExtensionAttribute]
public static Expression Throw(DynamicMetaObjectBinder binder, Expression exceptionValue);
    [ExtensionAttribute]
public static Expression Throw(DynamicMetaObjectBinder binder, Expression exceptionValue, Type retType);
    public static object CheckAndThrow(object value);
    private static void ThrowException(LightException lightEx);
    public static Expression CheckAndThrow(Expression expr);
    public static bool IsLightException(object value);
    public static Exception GetLightException(object exceptionValue);
    [ExtensionAttribute]
public static bool SupportsLightThrow(CallSiteBinder binder);
    private static ReadOnlyCollection`1<Expression> ToReadOnly(Expression[] args);
}
[AttributeUsageAttribute("64")]
public class Microsoft.Scripting.Runtime.LightThrowingAttribute : Attribute {
}
public class Microsoft.Scripting.Runtime.LocalsDictionary : CustomStringDictionary {
    private IRuntimeVariables _locals;
    private String[] _symbols;
    private Dictionary`2<string, int> _boxes;
    public LocalsDictionary(IRuntimeVariables locals, String[] symbols);
    private void EnsureBoxes();
    public virtual String[] GetExtraKeys();
    protected internal virtual bool TrySetExtraValue(string key, object value);
    protected internal virtual bool TryGetExtraValue(string key, Object& value);
}
[ExtensionAttribute]
public static class Microsoft.Scripting.Runtime.MetaObjectExtensions : object {
    [ExtensionAttribute]
public static bool NeedsDeferral(DynamicMetaObject self);
    [ExtensionAttribute]
public static DynamicMetaObject Restrict(DynamicMetaObject self, Type type);
    [ExtensionAttribute]
public static DynamicMetaObject Clone(DynamicMetaObject self, Expression newExpression);
    [ExtensionAttribute]
public static DynamicMetaObject Clone(DynamicMetaObject self, BindingRestrictions newRestrictions);
    [ExtensionAttribute]
public static DynamicMetaObject Clone(DynamicMetaObject self, Expression newExpression, BindingRestrictions newRestrictions);
    [ExtensionAttribute]
public static Type GetLimitType(DynamicMetaObject self);
    [ExtensionAttribute]
public static Type GetRuntimeType(DynamicMetaObject self);
}
public class Microsoft.Scripting.Runtime.ModuleChangeEventArgs : EventArgs {
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    [CompilerGeneratedAttribute]
private ModuleChangeType <ChangeType>k__BackingField;
    [CompilerGeneratedAttribute]
private object <Value>k__BackingField;
    public string Name { get; }
    public ModuleChangeType ChangeType { get; }
    public object Value { get; }
    public ModuleChangeEventArgs(string name, ModuleChangeType changeType);
    public ModuleChangeEventArgs(string name, ModuleChangeType changeType, object value);
    [CompilerGeneratedAttribute]
public string get_Name();
    [CompilerGeneratedAttribute]
public ModuleChangeType get_ChangeType();
    [CompilerGeneratedAttribute]
public object get_Value();
}
public enum Microsoft.Scripting.Runtime.ModuleChangeType : Enum {
    public int value__;
    public static ModuleChangeType Set;
    public static ModuleChangeType Delete;
}
public class Microsoft.Scripting.Runtime.NullTextContentProvider : TextContentProvider {
    public static NullTextContentProvider Null;
    private static NullTextContentProvider();
    public virtual SourceCodeReader GetReader();
}
public class Microsoft.Scripting.Runtime.OperationFailed : object {
    public static OperationFailed Value;
    private static OperationFailed();
}
[AttributeUsageAttribute("256")]
public class Microsoft.Scripting.Runtime.OperatorSlotAttribute : Attribute {
}
public class Microsoft.Scripting.Runtime.PositionTrackingWriter : StringWriter {
    private List`1<KeyValuePair`2<int, int>> _lineMap;
    private List`1<KeyValuePair`2<int, string>> _fileMap;
    private int _line;
    private int _column;
    public void MapLocation(CodeLinePragma linePragma);
    public KeyValuePair`2[] GetLineMap();
    public KeyValuePair`2[] GetFileMap();
    public virtual void Write(char value);
    public virtual void Write(string value);
    public virtual void Write(Char[] buffer, int index, int count);
    private void UpdateLineColumn(string value);
    private void UpdateLineColumn(Char[] buffer, int index, int count);
}
[AttributeUsageAttribute("64")]
public class Microsoft.Scripting.Runtime.PropertyMethodAttribute : Attribute {
}
public static class Microsoft.Scripting.Runtime.ReflectionCache : object {
    private static Dictionary`2<MethodBaseCache, MethodGroup> _functions;
    private static Dictionary`2<Type, TypeTracker> _typeCache;
    private static ReflectionCache();
    public static MethodGroup GetMethodGroup(string name, MethodBase[] methods);
    public static MethodGroup GetMethodGroup(string name, MemberGroup mems);
    public static TypeTracker GetTypeTracker(Type type);
}
public class Microsoft.Scripting.Runtime.RestrictedMetaObject : DynamicMetaObject {
    public RestrictedMetaObject(Expression expression, BindingRestrictions restriction, object value);
    public RestrictedMetaObject(Expression expression, BindingRestrictions restriction);
    public sealed virtual DynamicMetaObject Restrict(Type type);
}
public static class Microsoft.Scripting.Runtime.ScriptingRuntimeHelpers : object {
    private static int MIN_CACHE;
    private static int MAX_CACHE;
    private static Object[] cache;
    public static object True;
    public static object False;
    internal static MethodInfo BooleanToObjectMethod;
    internal static MethodInfo Int32ToObjectMethod;
    private static String[] chars;
    private static ScriptingRuntimeHelpers();
    public static T[] ShiftParamsArray(T[] array, int count);
    [ObsoleteAttribute("do not call this method", "True")]
public static IEnumerable`1<T> MakeGenerator(Func`1<GeneratorNext`1<T>> next);
    [ObsoleteAttribute("do not call this method", "True")]
public static IEnumerator`1<T> MakeGenerator(GeneratorNext`1<T> next);
    [ObsoleteAttribute("do not call this method", "True")]
public static IEnumerable`1<T> MakeGenerator(Func`1<GeneratorNext`1<T>> next, Int32[] yieldMarkers);
    [ObsoleteAttribute("do not call this method", "True")]
public static IEnumerator`1<T> MakeGenerator(GeneratorNext`1<T> next, Int32[] yieldMarkers);
    private static Object[] MakeCache();
    public static object Int32ToObject(int value);
    private static String[] MakeSingleCharStrings();
    public static object BooleanToObject(bool value);
    public static string CharToString(char ch);
    internal static object GetPrimitiveDefaultValue(Type type);
    public static ArgumentTypeException SimpleTypeError(string message);
    public static Exception CannotConvertError(Type toType, object value);
    public static Exception SimpleAttributeError(string message);
    public static object ReadOnlyAssignError(bool field, string fieldName);
    public static T CreateInstance();
    public static T[] CreateArray(int args);
    public static Type GetEventHandlerType(EventInfo eventInfo);
    public static IList`1<string> GetStringMembers(IList`1<object> members);
    public static void SetEvent(EventTracker eventTracker, object value);
    public static bool CheckDictionaryMembers(IDictionary dict, String[] names);
    [ObsoleteAttribute("use MakeIncorrectBoxTypeError instead")]
public static T IncorrectBoxType(object received);
    public static Exception MakeIncorrectBoxTypeError(Type type, object received);
    public static bool InterpretedCallSiteTest(bool restrictionResult, object bindingInfo);
}
[AttributeUsageAttribute("64")]
public class Microsoft.Scripting.Runtime.StaticExtensionMethodAttribute : Attribute {
}
public class Microsoft.Scripting.Runtime.TokenizerBuffer : object {
    private static int FirstColumn;
    public static int EndOfFile;
    public static int InvalidCharacter;
    private bool _multiEolns;
    private Char[] _buffer;
    private bool _bufferResized;
    private int _position;
    private SourceLocation _tokenStartLocation;
    private SourceLocation _tokenEndLocation;
    private int _start;
    private int _end;
    private int _tokenEnd;
    [CompilerGeneratedAttribute]
private TextReader <Reader>k__BackingField;
    public TextReader Reader { get; private set; }
    public bool AtBeginning { get; }
    public int TokenLength { get; }
    public int TokenRelativePosition { get; }
    public int Position { get; }
    public SourceSpan TokenSpan { get; }
    public SourceLocation TokenStart { get; }
    public SourceLocation TokenEnd { get; }
    public TokenizerBuffer(TextReader reader, SourceLocation initialLocation, int initialCapacity, bool multiEolns);
    [CompilerGeneratedAttribute]
public TextReader get_Reader();
    [CompilerGeneratedAttribute]
private void set_Reader(TextReader value);
    public bool get_AtBeginning();
    public int get_TokenLength();
    public int get_TokenRelativePosition();
    public int get_Position();
    public SourceSpan get_TokenSpan();
    public SourceLocation get_TokenStart();
    public SourceLocation get_TokenEnd();
    public void Initialize(TextReader reader, SourceLocation initialLocation, int initialCapacity, bool multiEolns);
    public int Read();
    public bool Read(int ch);
    public bool Read(string str);
    public int Peek();
    private void RefillBuffer();
    public void Back();
    public void Seek(int offset);
    public void SeekRelative(int disp);
    public void MarkMultiLineTokenEnd();
    public void MarkSingleLineTokenEnd();
    public void MarkMultiLineTokenEnd(int disp);
    public void MarkSingleLineTokenEnd(int disp);
    public void MarkTokenEnd(bool isMultiLine);
    public void DiscardToken();
    public char GetChar(int offset);
    public char GetCharRelative(int disp);
    public string GetTokenString();
    public string GetTokenSubstring(int offset);
    public string GetTokenSubstring(int offset, int length);
    private SourceLocation GetTokenEndSingleEoln();
    private SourceLocation GetTokenEndMultiEolns();
    public bool IsEoln(int current);
    public int ReadEolnOpt(int current);
    public int ReadLine();
    private static void ResizeInternal(Char[]& array, int newSize, int start, int count);
    [ConditionalAttribute("DEBUG")]
private void ClearInvalidChars();
    [ConditionalAttribute("DEBUG")]
private void CheckInvariants();
    [ConditionalAttribute("DUMP_TOKENS")]
private void DumpToken();
}
internal class Microsoft.Scripting.Runtime.TypeName : ValueType {
    [CompilerGeneratedAttribute]
private string <Namespace>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    internal string Namespace { get; }
    internal string Name { get; }
    internal TypeName(Type type);
    internal TypeName(string nameSpace, string typeName);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
internal string get_Namespace();
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
internal string get_Name();
    public virtual int GetHashCode();
    public virtual bool Equals(object obj);
    public sealed virtual bool Equals(TypeName other);
    public static bool op_Equality(TypeName a, TypeName b);
    public static bool op_Inequality(TypeName a, TypeName b);
}
public class Microsoft.Scripting.Runtime.Uninitialized : object {
    public static Uninitialized Instance;
    private static Uninitialized();
}
public abstract class Microsoft.Scripting.SavableScriptCode : ScriptCode {
    protected SavableScriptCode(SourceUnit sourceUnit);
    public static void SaveToAssembly(string assemblyName, IDictionary`2<string, object> assemblyAttributes, SavableScriptCode[] codes);
    public static void SaveToAssembly(string assemblyName, SavableScriptCode[] codes);
    public static ScriptCode[] LoadFromAssembly(ScriptDomainManager runtime, Assembly assembly);
    protected LambdaExpression RewriteForSave(TypeGen typeGen, LambdaExpression code);
    protected virtual KeyValuePair`2<MethodBuilder, Type> CompileForSave(TypeGen typeGen);
    public virtual string ToString();
}
public class Microsoft.Scripting.SourceFileInformation : object {
    [CompilerGeneratedAttribute]
private string <FileName>k__BackingField;
    [CompilerGeneratedAttribute]
private Guid <LanguageGuid>k__BackingField;
    [CompilerGeneratedAttribute]
private Guid <VendorGuid>k__BackingField;
    public string FileName { get; }
    public Guid LanguageGuid { get; }
    public Guid VendorGuid { get; }
    public SourceFileInformation(string fileName);
    public SourceFileInformation(string fileName, Guid language);
    public SourceFileInformation(string fileName, Guid language, Guid vendor);
    [CompilerGeneratedAttribute]
public string get_FileName();
    [CompilerGeneratedAttribute]
public Guid get_LanguageGuid();
    [CompilerGeneratedAttribute]
public Guid get_VendorGuid();
}
internal class Microsoft.Scripting.SourceStringContentProvider : TextContentProvider {
    private string _code;
    internal SourceStringContentProvider(string code);
    public virtual SourceCodeReader GetReader();
}
internal static class Microsoft.Scripting.Strings : object {
    internal static string ComObjectExpected { get; }
    internal static string CannotCall { get; }
    internal static string COMObjectDoesNotSupportEvents { get; }
    internal static string COMObjectDoesNotSupportSourceInterface { get; }
    internal static string SetComObjectDataFailed { get; }
    internal static string MethodShouldNotBeCalled { get; }
    internal static string CannotRetrieveTypeInformation { get; }
    internal static string UnsupportedEnumType { get; }
    internal static string UnsupportedHandlerType { get; }
    internal static string MethodPreconditionViolated { get; }
    internal static string InvalidArgumentValue { get; }
    internal static string NonEmptyStringRequired { get; }
    internal static string NonEmptyCollectionRequired { get; }
    internal static string MustBeExceptionInstance { get; }
    internal static string TypeOfTestMustBeBool { get; }
    internal static string TypeOfExpressionMustBeBool { get; }
    internal static string EmptyStringIsInvalidPath { get; }
    internal static string InvalidDelegate { get; }
    internal static string ExpectedStaticProperty { get; }
    internal static string PropertyDoesNotExist { get; }
    internal static string FieldDoesNotExist { get; }
    internal static string TypeDoesNotHaveConstructorForTheSignature { get; }
    internal static string TypeDoesNotHaveMethodForName { get; }
    internal static string TypeDoesNotHaveMethodForNameSignature { get; }
    internal static string CountCannotBeNegative { get; }
    internal static string ArrayTypeMustBeArray { get; }
    internal static string MustHaveCodeOrTarget { get; }
    internal static string FirstArgumentMustBeCallSite { get; }
    internal static string NoInstanceForCall { get; }
    internal static string MissingTest { get; }
    internal static string MissingTarget { get; }
    internal static string FinallyAlreadyDefined { get; }
    internal static string CannotHaveFaultAndFinally { get; }
    internal static string FaultAlreadyDefined { get; }
    internal static string GlobalsMustBeUnique { get; }
    internal static string GenNonSerializableBinder { get; }
    internal static string InvalidPath { get; }
    internal static string DictionaryNotHashable { get; }
    internal static string LanguageRegistered { get; }
    internal static string MethodOrOperatorNotImplemented { get; }
    internal static string NoException { get; }
    internal static string AlreadyInitialized { get; }
    internal static string MustReturnScopeExtension { get; }
    internal static string InvalidParamNumForService { get; }
    internal static string CannotChangeNonCachingValue { get; }
    internal static string NoCodeToCompile { get; }
    internal static string QueueEmpty { get; }
    internal static string EnumerationNotStarted { get; }
    internal static string EnumerationFinished { get; }
    internal static string InvalidOutputDir { get; }
    internal static string InvalidAsmNameOrExtension { get; }
    internal static string NoDefaultValue { get; }
    internal static string UnknownLanguageProviderType { get; }
    internal static string CantReadProperty { get; }
    internal static string CantWriteProperty { get; }
    internal static string get_ComObjectExpected();
    internal static string get_CannotCall();
    internal static string get_COMObjectDoesNotSupportEvents();
    internal static string get_COMObjectDoesNotSupportSourceInterface();
    internal static string get_SetComObjectDataFailed();
    internal static string get_MethodShouldNotBeCalled();
    internal static string UnexpectedVarEnum(object p0);
    internal static string DispBadParamCount(object p0);
    internal static string DispMemberNotFound(object p0);
    internal static string DispNoNamedArgs(object p0);
    internal static string DispOverflow(object p0);
    internal static string DispTypeMismatch(object p0, object p1);
    internal static string DispParamNotOptional(object p0);
    internal static string get_CannotRetrieveTypeInformation();
    internal static string GetIDsOfNamesInvalid(object p0);
    internal static string get_UnsupportedEnumType();
    internal static string get_UnsupportedHandlerType();
    internal static string CouldNotGetDispId(object p0, object p1);
    internal static string AmbiguousConversion(object p0, object p1);
    internal static string VariantGetAccessorNYI(object p0);
    private static string FormatString(string format, Object[] args);
    internal static string InvalidOperation_ContainsGenericParameters(object p0, object p1);
    internal static string MissingType(object p0);
    internal static string StaticAccessFromInstanceError(object p0, object p1);
    internal static string StaticAssignmentFromInstanceError(object p0, object p1);
    internal static string get_MethodPreconditionViolated();
    internal static string get_InvalidArgumentValue();
    internal static string get_NonEmptyStringRequired();
    internal static string get_NonEmptyCollectionRequired();
    internal static string get_MustBeExceptionInstance();
    internal static string get_TypeOfTestMustBeBool();
    internal static string get_TypeOfExpressionMustBeBool();
    internal static string get_EmptyStringIsInvalidPath();
    internal static string get_InvalidDelegate();
    internal static string get_ExpectedStaticProperty();
    internal static string get_PropertyDoesNotExist();
    internal static string get_FieldDoesNotExist();
    internal static string get_TypeDoesNotHaveConstructorForTheSignature();
    internal static string get_TypeDoesNotHaveMethodForName();
    internal static string get_TypeDoesNotHaveMethodForNameSignature();
    internal static string get_CountCannotBeNegative();
    internal static string get_ArrayTypeMustBeArray();
    internal static string get_MustHaveCodeOrTarget();
    internal static string TypeParameterIsNotDelegate(object p0);
    internal static string InvalidCast(object p0, object p1);
    internal static string UnknownMemberType(object p0);
    internal static string get_FirstArgumentMustBeCallSite();
    internal static string get_NoInstanceForCall();
    internal static string get_MissingTest();
    internal static string get_MissingTarget();
    internal static string NonGenericWithGenericGroup(object p0);
    internal static string InvalidOperation(object p0);
    internal static string get_FinallyAlreadyDefined();
    internal static string get_CannotHaveFaultAndFinally();
    internal static string get_FaultAlreadyDefined();
    internal static string CantCreateDefaultTypeFor(object p0);
    internal static string UnhandledConvert(object p0);
    internal static string NoCallableMethods(object p0, object p1);
    internal static string get_GlobalsMustBeUnique();
    internal static string get_GenNonSerializableBinder();
    internal static string get_InvalidPath();
    internal static string get_DictionaryNotHashable();
    internal static string get_LanguageRegistered();
    internal static string get_MethodOrOperatorNotImplemented();
    internal static string get_NoException();
    internal static string ExtensionMustBePublic(object p0);
    internal static string get_AlreadyInitialized();
    internal static string get_MustReturnScopeExtension();
    internal static string get_InvalidParamNumForService();
    internal static string InvalidArgumentType(object p0, object p1);
    internal static string get_CannotChangeNonCachingValue();
    internal static string FieldReadonly(object p0);
    internal static string PropertyReadonly(object p0);
    internal static string UnexpectedEvent(object p0, object p1, object p2, object p3);
    internal static string ExpectedBoundEvent(object p0);
    internal static string UnexpectedType(object p0, object p1);
    internal static string MemberWriteOnly(object p0);
    internal static string get_NoCodeToCompile();
    internal static string InvalidStreamType(object p0);
    internal static string get_QueueEmpty();
    internal static string get_EnumerationNotStarted();
    internal static string get_EnumerationFinished();
    internal static string CantAddCasing(object p0);
    internal static string CantAddIdentifier(object p0);
    internal static string InvalidCtorImplementation(object p0, object p1);
    internal static string get_InvalidOutputDir();
    internal static string get_InvalidAsmNameOrExtension();
    internal static string CanotEmitConstant(object p0, object p1);
    internal static string NoImplicitCast(object p0, object p1);
    internal static string NoExplicitCast(object p0, object p1);
    internal static string NameNotDefined(object p0);
    internal static string get_NoDefaultValue();
    internal static string get_UnknownLanguageProviderType();
    internal static string get_CantReadProperty();
    internal static string get_CantWriteProperty();
    internal static string IllegalNew_GenericParams(object p0);
    internal static string VerificationException(object p0, object p1, object p2);
}
[ExtensionAttribute]
public static class Microsoft.Scripting.Utils.ArrayUtils : object {
    public static String[] EmptyStrings;
    public static Object[] EmptyObjects;
    private static ArrayUtils();
    public static IComparer`1<T> ToComparer(Comparison`1<T> comparison);
    public static TOutput[] ConvertAll(TInput[] input, Func`2<TInput, TOutput> conv);
    public static void PrintTable(StringBuilder output, String[0...,0...] table);
    public static T[] Copy(T[] array);
    public static T[] ToArray(ICollection`1<T> list);
    public static TResult[] ToArray(ICollection`1<TElement> list, Func`2<TElement, TResult> convertor);
    public static T[] MakeArray(ICollection`1<T> list);
    public static T[] MakeArray(ICollection`1<T> elements, int reservedSlotsBefore, int reservedSlotsAfter);
    public static T[] RotateRight(T[] array, int count);
    public static T[] ShiftRight(T[] array, int count);
    public static T[] ShiftLeft(T[] array, int count);
    public static T[] Insert(T item, IList`1<T> list);
    public static T[] Insert(T item1, T item2, IList`1<T> list);
    public static T[] Insert(T item, T[] array);
    public static T[] Insert(T item1, T item2, T[] array);
    public static T[] Append(T[] array, T item);
    public static T[] AppendRange(T[] array, IList`1<T> items);
    public static T[] AppendRange(T[] array, IList`1<T> items, int additionalItemCount);
    public static T[0...,0...] Concatenate(T[0...,0...] array1, T[0...,0...] array2);
    public static void SwapLastTwo(T[] array);
    public static T[] RemoveFirst(IList`1<T> list);
    public static T[] RemoveFirst(T[] array);
    public static T[] RemoveLast(T[] array);
    public static T[] RemoveAt(IList`1<T> list, int indexToRemove);
    public static T[] RemoveAt(T[] array, int indexToRemove);
    public static T[] InsertAt(IList`1<T> list, int index, T[] items);
    public static T[] InsertAt(T[] array, int index, T[] items);
    [ExtensionAttribute]
public static bool ValueEquals(T[] array, T[] other);
    [ExtensionAttribute]
public static int GetValueHashCode(T[] array);
    [ExtensionAttribute]
public static int GetValueHashCode(T[] array, int start, int count);
    [ExtensionAttribute]
public static T[] Reverse(T[] array);
}
public static class Microsoft.Scripting.Utils.Assert : object {
    public static Exception Unreachable { get; }
    public static Exception get_Unreachable();
    [ConditionalAttribute("DEBUG")]
public static void NotNull(object var);
    [ConditionalAttribute("DEBUG")]
public static void NotNull(object var1, object var2);
    [ConditionalAttribute("DEBUG")]
public static void NotNull(object var1, object var2, object var3);
    [ConditionalAttribute("DEBUG")]
public static void NotNull(object var1, object var2, object var3, object var4);
    [ConditionalAttribute("DEBUG")]
public static void NotEmpty(string str);
    [ConditionalAttribute("DEBUG")]
public static void NotEmpty(ICollection`1<T> array);
    [ConditionalAttribute("DEBUG")]
public static void NotNullItems(IEnumerable`1<T> items);
    [ConditionalAttribute("DEBUG")]
public static void IsTrue(Func`1<bool> predicate);
}
internal abstract class Microsoft.Scripting.Utils.CachedBindingInfo : object {
    public DynamicMetaObjectBinder Binder;
    public int CompilationThreshold;
    public CachedBindingInfo(DynamicMetaObjectBinder binder, int compilationThreshold);
    public abstract virtual bool CheckCompiled();
}
internal class Microsoft.Scripting.Utils.CachedBindingInfo`1 : CachedBindingInfo {
    public T CompiledTarget;
    public Expression`1<T> Target;
    [ThreadStaticAttribute]
public static CachedBindingInfo`1<T> LastInterpretedFailure;
    public CachedBindingInfo`1(DynamicMetaObjectBinder binder, int compilationThreshold);
    public virtual bool CheckCompiled();
}
[DefaultMemberAttribute("Item")]
public class Microsoft.Scripting.Utils.CacheDict`2 : object {
    private Dictionary`2<TKey, KeyInfo<TKey, TValue>> _dict;
    private LinkedList`1<TKey> _list;
    private int _maxSize;
    public TValue Item { get; public set; }
    public CacheDict`2(int maxSize);
    public bool TryGetValue(TKey key, TValue& value);
    public void Add(TKey key, TValue value);
    public TValue get_Item(TKey key);
    public void set_Item(TKey key, TValue value);
}
public abstract class Microsoft.Scripting.Utils.CheckedDictionaryEnumerator : object {
    private EnumeratorState _enumeratorState;
    public DictionaryEntry Entry { get; }
    public object Key { get; }
    public object Value { get; }
    public object Current { get; }
    private KeyValuePair`2<object, object> System.Collections.Generic.IEnumerator<System.Collections.Generic.KeyValuePair<System.Object,System.Object>>.Current { get; }
    private void CheckEnumeratorState();
    public sealed virtual DictionaryEntry get_Entry();
    public sealed virtual object get_Key();
    public sealed virtual object get_Value();
    public sealed virtual bool MoveNext();
    public sealed virtual object get_Current();
    public sealed virtual void Reset();
    private sealed virtual override KeyValuePair`2<object, object> System.Collections.Generic.IEnumerator<System.Collections.Generic.KeyValuePair<System.Object,System.Object>>.get_Current();
    public sealed virtual void Dispose();
    protected abstract virtual object GetKey();
    protected abstract virtual object GetValue();
    protected abstract virtual bool DoMoveNext();
    protected abstract virtual void DoReset();
}
[ExtensionAttribute]
internal static class Microsoft.Scripting.Utils.CollectionExtensions : object {
    [ExtensionAttribute]
internal static ReadOnlyCollection`1<T> ToReadOnly(IEnumerable`1<T> enumerable);
    [ExtensionAttribute]
internal static int ListHashCode(IEnumerable`1<T> list);
    [ExtensionAttribute]
internal static bool ListEquals(ICollection`1<T> first, ICollection`1<T> second);
    [ExtensionAttribute]
internal static U[] Map(ICollection`1<T> collection, Func`2<T, U> select);
    [ExtensionAttribute]
internal static T[] RemoveFirst(T[] array);
    [ExtensionAttribute]
internal static T[] RemoveLast(T[] array);
    [ExtensionAttribute]
internal static T[] AddFirst(IList`1<T> list, T item);
    [ExtensionAttribute]
internal static T[] AddLast(IList`1<T> list, T item);
    [ExtensionAttribute]
internal static T[] RemoveAt(T[] array, int indexToRemove);
    [ExtensionAttribute]
internal static T[] RotateRight(T[] array, int count);
}
[ExtensionAttribute]
public static class Microsoft.Scripting.Utils.CollectionUtils : object {
    [ExtensionAttribute]
public static IEnumerable`1<T> Cast(IEnumerable`1<S> sequence);
    public static IEnumerable`1<TSuper> ToCovariant(IEnumerable`1<T> enumerable);
    public static void AddRange(ICollection`1<T> collection, IEnumerable`1<T> items);
    [ExtensionAttribute]
public static void AddRange(IList`1<T> list, IEnumerable`1<T> items);
    [IteratorStateMachineAttribute("Microsoft.Scripting.Utils.CollectionUtils/<ToEnumerable>d__4`1")]
public static IEnumerable`1<T> ToEnumerable(IEnumerable enumerable);
    [IteratorStateMachineAttribute("Microsoft.Scripting.Utils.CollectionUtils/<ToCovariant>d__5`2")]
public static IEnumerator`1<TSuper> ToCovariant(IEnumerator`1<T> enumerator);
    public static IDictionaryEnumerator ToDictionaryEnumerator(IEnumerator`1<KeyValuePair`2<object, object>> enumerator);
    public static List`1<T> MakeList(T item);
    public static int CountOf(IList`1<T> list, T item);
    [ExtensionAttribute]
public static int Max(IEnumerable`1<int> values);
    public static bool TrueForAll(IEnumerable`1<T> collection, Predicate`1<T> predicate);
    public static IList`1<TRet> ConvertAll(IList`1<T> collection, Func`2<T, TRet> predicate);
    [IteratorStateMachineAttribute("Microsoft.Scripting.Utils.CollectionUtils/<Select>d__14`1")]
[ExtensionAttribute]
public static IEnumerable`1<TRet> Select(IEnumerable enumerable, Func`2<object, TRet> selector);
    public static List`1<T> GetRange(IList`1<T> list, int index, int count);
    public static void InsertRange(IList`1<T> collection, int index, IEnumerable`1<T> items);
    public static void RemoveRange(IList`1<T> collection, int index, int count);
    [ExtensionAttribute]
public static int FindIndex(IList`1<T> collection, Predicate`1<T> predicate);
    [ExtensionAttribute]
public static IList`1<T> ToSortedList(ICollection`1<T> collection, Comparison`1<T> comparison);
    [ExtensionAttribute]
public static T[] ToReverseArray(IList`1<T> list);
    public static IEqualityComparer`1<HashSet`1<T>> CreateSetComparer();
}
public static class Microsoft.Scripting.Utils.ContractUtils : object {
    [ConditionalAttribute("DEBUG")]
public static void Assert(bool precondition);
    public static void Requires(bool precondition);
    public static void Requires(bool precondition, string paramName);
    public static void Requires(bool precondition, string paramName, string message);
    public static void RequiresNotNull(object value, string paramName);
    public static void RequiresNotEmpty(string str, string paramName);
    public static void RequiresNotEmpty(ICollection`1<T> collection, string paramName);
    public static void RequiresArrayIndex(IList`1<T> array, int index, string indexName);
    public static void RequiresArrayIndex(int arraySize, int index, string indexName);
    public static void RequiresArrayInsertIndex(IList`1<T> array, int index, string indexName);
    public static void RequiresArrayInsertIndex(int arraySize, int index, string indexName);
    public static void RequiresArrayRange(IList`1<T> array, int offset, int count, string offsetName, string countName);
    public static void RequiresArrayRange(int arraySize, int offset, int count, string offsetName, string countName);
    public static void RequiresListRange(IList array, int offset, int count, string offsetName, string countName);
    public static void RequiresArrayRange(string str, int offset, int count, string offsetName, string countName);
    public static void RequiresNotNullItems(IList`1<T> array, string arrayName);
    public static void RequiresNotNullItems(IEnumerable`1<T> collection, string collectionName);
    [ConditionalAttribute("FALSE")]
public static void Invariant(bool condition);
    [ConditionalAttribute("FALSE")]
public static void Invariant(bool condition, string message);
    [ConditionalAttribute("FALSE")]
public static void Ensures(bool condition);
    [ConditionalAttribute("FALSE")]
public static void Ensures(bool condition, string message);
    public static T Result();
    public static T Parameter(T& value);
    public static T Old(T value);
}
[DefaultMemberAttribute("Item")]
public class Microsoft.Scripting.Utils.CopyOnWriteList`1 : object {
    private List`1<T> _list;
    public T Item { get; public set; }
    public int Count { get; }
    public bool IsReadOnly { get; }
    private List`1<T> GetNewListForWrite();
    public List`1<T> GetCopyForRead();
    public sealed virtual int IndexOf(T item);
    public sealed virtual void Insert(int index, T item);
    public sealed virtual void RemoveAt(int index);
    public sealed virtual T get_Item(int index);
    public sealed virtual void set_Item(int index, T value);
    public sealed virtual void Add(T item);
    public sealed virtual void Clear();
    public sealed virtual bool Contains(T item);
    public sealed virtual void CopyTo(T[] array, int arrayIndex);
    public sealed virtual int get_Count();
    public sealed virtual bool get_IsReadOnly();
    public sealed virtual bool Remove(T item);
    public sealed virtual IEnumerator`1<T> GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
}
public class Microsoft.Scripting.Utils.DictionaryUnionEnumerator : CheckedDictionaryEnumerator {
    private IList`1<IDictionaryEnumerator> _enums;
    private int _current;
    public DictionaryUnionEnumerator(IList`1<IDictionaryEnumerator> enums);
    protected virtual object GetKey();
    protected virtual object GetValue();
    protected virtual bool DoMoveNext();
    protected virtual void DoReset();
}
[ExtensionAttribute]
public static class Microsoft.Scripting.Utils.DynamicUtils : object {
    public static Expression[] GetExpressions(DynamicMetaObject[] objects);
    public static DynamicMetaObject ObjectToMetaObject(object argValue, Expression parameterExpression);
    [ExtensionAttribute]
public static T LightBind(DynamicMetaObjectBinder binder, Object[] args, int compilationThreshold);
}
internal static class Microsoft.Scripting.Utils.EmptyArray`1 : object {
    internal static T[] Instance;
    private static EmptyArray`1();
}
internal static class Microsoft.Scripting.Utils.EmptyReadOnlyCollection`1 : object {
    internal static ReadOnlyCollection`1<T> Instance;
    private static EmptyReadOnlyCollection`1();
}
internal static class Microsoft.Scripting.Utils.EmptyReadOnlyDictionary`2 : object {
    internal static IReadOnlyDictionary`2<TKey, TValue> Instance;
    private static EmptyReadOnlyDictionary`2();
}
public class Microsoft.Scripting.Utils.EnumerableWrapper : object {
    private IEnumerable _wrappedObject;
    public EnumerableWrapper(IEnumerable o);
    public sealed virtual IEnumerator GetEnumerator();
}
public static class Microsoft.Scripting.Utils.EnumUtils : object {
    public static object BitwiseOr(object self, object other);
    public static object BitwiseAnd(object self, object other);
    public static object ExclusiveOr(object self, object other);
    public static object OnesComplement(object self);
}
[ExtensionAttribute]
public static class Microsoft.Scripting.Utils.ExceptionUtils : object {
    private static ConditionalWeakTable`2<Exception, List`1<KeyValuePair`2<object, object>>> _exceptionData;
    public static ArgumentOutOfRangeException MakeArgumentOutOfRangeException(string paramName, object actualValue, string message);
    public static ArgumentNullException MakeArgumentItemNullException(int index, string arrayName);
    [ExtensionAttribute]
public static void SetData(Exception e, object key, object value);
    [ExtensionAttribute]
public static object GetData(Exception e, object key);
    [ExtensionAttribute]
public static void RemoveData(Exception e, object key);
}
public class Microsoft.Scripting.Utils.ExtensionMethodInfo : ValueType {
    private Type _extendedType;
    private MethodInfo _method;
    public Type ExtendedType { get; }
    public MethodInfo Method { get; }
    internal ExtensionMethodInfo(Type extendedType, MethodInfo method);
    public Type get_ExtendedType();
    public MethodInfo get_Method();
    public virtual bool Equals(object obj);
    public sealed virtual bool Equals(ExtensionMethodInfo other);
    public static bool op_Equality(ExtensionMethodInfo self, ExtensionMethodInfo other);
    public static bool op_Inequality(ExtensionMethodInfo self, ExtensionMethodInfo other);
    public virtual int GetHashCode();
    public bool IsExtensionOf(Type type);
}
public class Microsoft.Scripting.Utils.HybridMapping`1 : object {
    private Dictionary`2<int, object> _dict;
    private object _synchObject;
    private int _offset;
    private int _current;
    public static int SIZE;
    private static int MIN_RANGE;
    public HybridMapping`1(int offset);
    private void NextKey();
    public int WeakAdd(T value);
    public int StrongAdd(T value, int pos);
    public T GetObjectFromId(int id);
    public int GetIdFromObject(T value);
    public void RemoveOnId(int id);
    public void RemoveOnObject(T value);
}
[DefaultMemberAttribute("Item")]
internal class Microsoft.Scripting.Utils.HybridReferenceDictionary`2 : object {
    private KeyValuePair`2[] _keysAndValues;
    private Dictionary`2<TKey, TValue> _dict;
    private int _count;
    private static int _arraySize;
    public int Count { get; }
    public TValue Item { get; public set; }
    public HybridReferenceDictionary`2(int initialCapicity);
    public bool TryGetValue(TKey key, TValue& value);
    public bool Remove(TKey key);
    public bool ContainsKey(TKey key);
    public int get_Count();
    public IEnumerator`1<KeyValuePair`2<TKey, TValue>> GetEnumerator();
    [IteratorStateMachineAttribute("Microsoft.Scripting.Utils.HybridReferenceDictionary`2/<GetEnumeratorWorker>d__12")]
private IEnumerator`1<KeyValuePair`2<TKey, TValue>> GetEnumeratorWorker();
    public TValue get_Item(TKey key);
    public void set_Item(TKey key, TValue value);
}
public static class Microsoft.Scripting.Utils.IOUtils : object {
    public static bool SeekLine(TextReader reader, int line);
    public static string ReadTo(TextReader reader, char terminator);
    public static bool SeekTo(TextReader reader, char c);
    public static string ToValidPath(string path);
    public static string ToValidPath(string path, bool isMask);
    public static string ToValidFileName(string path);
    private static string ToValidPath(string path, bool isMask, bool isPath);
}
internal class Microsoft.Scripting.Utils.ListEqualityComparer`1 : EqualityComparer`1<ICollection`1<T>> {
    internal static ListEqualityComparer`1<T> Instance;
    private static ListEqualityComparer`1();
    public virtual bool Equals(ICollection`1<T> x, ICollection`1<T> y);
    public virtual int GetHashCode(ICollection`1<T> obj);
}
[ExtensionAttribute]
public static class Microsoft.Scripting.Utils.MathUtils : object {
    private static Double[] _RoundPowersOfTens;
    private static Double[] ErfNumerCoeffs;
    private static Double[] ErfDenomCoeffs;
    private static Double[] ErfcNumerCoeffs;
    private static Double[] ErfcDenomCoeffs;
    private static Double[] GammaNumerCoeffs;
    private static Double[] GammaDenomCoeffs;
    private static UInt32[] maxCharsPerDigit;
    private static UInt32[] groupRadixValues;
    private static int BitsPerDigit;
    private static MathUtils();
    public static int FloorDivideUnchecked(int x, int y);
    public static long FloorDivideUnchecked(long x, long y);
    public static int FloorRemainder(int x, int y);
    public static long FloorRemainder(long x, long y);
    [ObsoleteAttribute("The method has been deprecated. Call MathUtils.Round(value, 0, MidpointRounding.AwayFromZero) instead.")]
public static double RoundAwayFromZero(double value);
    private static double GetPowerOf10(int precision);
    [ObsoleteAttribute("The method has been deprecated. Call MathUtils.Round(value, precision, MidpointRounding.AwayFromZero) instead.")]
public static double RoundAwayFromZero(double value, int precision);
    public static bool IsNegativeZero(double self);
    public static double Round(double value, int precision, MidpointRounding mode);
    public static double Erf(double v0);
    public static double ErfComplement(double v0);
    public static double Gamma(double v0);
    public static double LogGamma(double v0);
    public static double Hypot(double x, double y);
    private static double EvalPolynomial(double v0, Double[] coeffs);
    private static double EvalPolynomial(double v0, Double[] coeffs, bool reverse);
    private static double SinPi(double v0);
    private static double AbsSinPi(double v0);
    private static double GammaRationalFunc(double v0);
    private static double PositiveGamma(double v0);
    private static double PositiveLGamma(double v0);
    internal static string BigIntegerToString(UInt32[] d, int sign, int radix, bool lowerCase);
    private static UInt32 div(UInt32[] n, Int32& nl, UInt32 d);
    private static void AppendRadix(UInt32 rem, UInt32 radix, Char[] tmp, StringBuilder buf, bool leadingZeros, bool lowerCase);
    private static UInt32 GetWord(Byte[] bytes, int start, int end);
    public static BigInteger GetRandBits(Action`1<Byte[]> NextBytes, int bits);
    [ExtensionAttribute]
public static BigInteger GetRandBits(Random generator, int bits);
    [ExtensionAttribute]
public static BigInteger Random(Random generator, BigInteger limit);
    [ExtensionAttribute]
public static bool TryToFloat64(BigInteger self, Double& result);
    [ExtensionAttribute]
public static double ToFloat64(BigInteger self);
    public static int BitLength(BigInteger x);
    public static int BitLength(long x);
    [CLSCompliantAttribute("False")]
public static int BitLengthUnsigned(ulong x);
    public static int BitLength(int x);
    [CLSCompliantAttribute("False")]
public static int BitLengthUnsigned(UInt32 x);
    [ExtensionAttribute]
public static bool AsInt32(BigInteger self, Int32& ret);
    [ExtensionAttribute]
public static bool AsInt64(BigInteger self, Int64& ret);
    [ExtensionAttribute]
[CLSCompliantAttribute("False")]
public static bool AsUInt32(BigInteger self, UInt32& ret);
    [ExtensionAttribute]
[CLSCompliantAttribute("False")]
public static bool AsUInt64(BigInteger self, UInt64& ret);
    [ExtensionAttribute]
public static BigInteger Abs(BigInteger self);
    [ExtensionAttribute]
public static bool IsZero(BigInteger self);
    [ExtensionAttribute]
public static bool IsPositive(BigInteger self);
    [ExtensionAttribute]
public static bool IsNegative(BigInteger self);
    [ExtensionAttribute]
public static double Log(BigInteger self);
    [ExtensionAttribute]
public static double Log(BigInteger self, double baseValue);
    [ExtensionAttribute]
public static double Log10(BigInteger self);
    [ExtensionAttribute]
public static BigInteger Power(BigInteger self, int exp);
    [ExtensionAttribute]
public static BigInteger Power(BigInteger self, long exp);
    [ExtensionAttribute]
public static BigInteger ModPow(BigInteger self, int power, BigInteger mod);
    [ExtensionAttribute]
public static BigInteger ModPow(BigInteger self, BigInteger power, BigInteger mod);
    [ExtensionAttribute]
public static string ToString(BigInteger self, int radix);
    [ExtensionAttribute]
[CLSCompliantAttribute("False")]
public static UInt32[] GetWords(BigInteger self);
    [ExtensionAttribute]
[CLSCompliantAttribute("False")]
public static UInt32 GetWord(BigInteger self, int index);
    [ExtensionAttribute]
public static int GetWordCount(BigInteger self);
    [ExtensionAttribute]
public static int GetByteCount(BigInteger self);
    [ExtensionAttribute]
public static int GetBitCount(BigInteger self);
    private static byte GetHighestByte(BigInteger self, Int32& index, Byte[]& byteArray);
    public static Complex MakeReal(double real);
    public static Complex MakeImaginary(double imag);
    public static Complex MakeComplex(double real, double imag);
    [ExtensionAttribute]
public static double Imaginary(Complex self);
    [ExtensionAttribute]
public static bool IsZero(Complex self);
    [ExtensionAttribute]
public static Complex Conjugate(Complex self);
    [ExtensionAttribute]
public static double Abs(Complex self);
    [ExtensionAttribute]
public static Complex Pow(Complex self, Complex power);
}
public static class Microsoft.Scripting.Utils.MonitorUtils : object {
    public static void Enter(object obj, Boolean& lockTaken);
    public static bool TryEnter(object obj, Boolean& lockTaken);
    public static void Exit(object obj, Boolean& lockTaken);
}
public class Microsoft.Scripting.Utils.Publisher`2 : object {
    private Dictionary`2<TKey, PublishInfo`1<TKey, TValue, TValue>> data;
    public IEnumerable`1<TKey> Keys { get; }
    public TValue GetOrCreateValue(TKey key, Func`1<TValue> create);
    public IEnumerable`1<TKey> get_Keys();
}
public class Microsoft.Scripting.Utils.ReferenceEqualityComparer`1 : object {
    public static ReferenceEqualityComparer`1<T> Instance;
    private static ReferenceEqualityComparer`1();
    public sealed virtual bool Equals(T x, T y);
    public sealed virtual int GetHashCode(T obj);
}
[ExtensionAttribute]
public static class Microsoft.Scripting.Utils.ReflectionUtils : object {
    public static BindingFlags AllMembers;
    public static Type[] EmptyTypes;
    public static char GenericArityDelimiter;
    private static MethodAttributes MethodAttributesToEraseInOveride;
    private static Dictionary`2<Assembly, Dictionary`2<string, List`1<ExtensionMethodInfo>>> _extensionMethodsCache;
    private static ReflectionUtils();
    [ExtensionAttribute]
public static bool IsPublic(PropertyInfo property);
    [ExtensionAttribute]
public static bool IsStatic(PropertyInfo property);
    [ExtensionAttribute]
public static bool IsStatic(EventInfo evnt);
    [ExtensionAttribute]
public static bool IsPrivate(PropertyInfo property);
    [ExtensionAttribute]
public static bool IsPrivate(EventInfo evnt);
    private static bool MatchesFlags(ConstructorInfo member, BindingFlags flags);
    private static bool MatchesFlags(MethodInfo member, BindingFlags flags);
    private static bool MatchesFlags(FieldInfo member, BindingFlags flags);
    private static bool MatchesFlags(PropertyInfo member, BindingFlags flags);
    private static bool MatchesFlags(EventInfo member, BindingFlags flags);
    private static bool MatchesFlags(Type member, BindingFlags flags);
    private static bool MatchesFlags(MemberInfo member, BindingFlags flags);
    [ExtensionAttribute]
private static IEnumerable`1<T> WithBindingFlags(IEnumerable`1<T> members, Func`3<T, BindingFlags, bool> matchFlags, BindingFlags flags);
    [ExtensionAttribute]
public static IEnumerable`1<MemberInfo> WithBindingFlags(IEnumerable`1<MemberInfo> members, BindingFlags flags);
    [ExtensionAttribute]
public static IEnumerable`1<MethodInfo> WithBindingFlags(IEnumerable`1<MethodInfo> members, BindingFlags flags);
    [ExtensionAttribute]
public static IEnumerable`1<ConstructorInfo> WithBindingFlags(IEnumerable`1<ConstructorInfo> members, BindingFlags flags);
    [ExtensionAttribute]
public static IEnumerable`1<FieldInfo> WithBindingFlags(IEnumerable`1<FieldInfo> members, BindingFlags flags);
    [ExtensionAttribute]
public static IEnumerable`1<PropertyInfo> WithBindingFlags(IEnumerable`1<PropertyInfo> members, BindingFlags flags);
    [ExtensionAttribute]
public static IEnumerable`1<EventInfo> WithBindingFlags(IEnumerable`1<EventInfo> members, BindingFlags flags);
    [ExtensionAttribute]
public static IEnumerable`1<Type> WithBindingFlags(IEnumerable`1<Type> members, BindingFlags flags);
    [ExtensionAttribute]
public static MemberInfo WithBindingFlags(MemberInfo member, BindingFlags flags);
    [ExtensionAttribute]
public static MethodInfo WithBindingFlags(MethodInfo member, BindingFlags flags);
    [ExtensionAttribute]
public static ConstructorInfo WithBindingFlags(ConstructorInfo member, BindingFlags flags);
    [ExtensionAttribute]
public static FieldInfo WithBindingFlags(FieldInfo member, BindingFlags flags);
    [ExtensionAttribute]
public static PropertyInfo WithBindingFlags(PropertyInfo member, BindingFlags flags);
    [ExtensionAttribute]
public static EventInfo WithBindingFlags(EventInfo member, BindingFlags flags);
    [ExtensionAttribute]
public static Type WithBindingFlags(Type member, BindingFlags flags);
    [ExtensionAttribute]
public static IEnumerable`1<MethodInfo> WithSignature(IEnumerable`1<MethodInfo> members, Type[] parameterTypes);
    [ExtensionAttribute]
public static IEnumerable`1<ConstructorInfo> WithSignature(IEnumerable`1<ConstructorInfo> members, Type[] parameterTypes);
    [IteratorStateMachineAttribute("Microsoft.Scripting.Utils.ReflectionUtils/<GetInheritedMethods>d__30")]
[ExtensionAttribute]
public static IEnumerable`1<MethodInfo> GetInheritedMethods(Type type, string name, bool flattenHierarchy);
    private static bool IncludeMethod(MethodInfo member, Type reflectedType, HashSet`1<MethodInfo> baseDefinitions, bool flattenHierarchy);
    [IteratorStateMachineAttribute("Microsoft.Scripting.Utils.ReflectionUtils/<GetInheritedProperties>d__32")]
[ExtensionAttribute]
public static IEnumerable`1<PropertyInfo> GetInheritedProperties(Type type, string name, bool flattenHierarchy);
    private static bool IncludeProperty(PropertyInfo member, Type reflectedType, HashSet`1<MethodInfo> baseDefinitions, bool flattenHierarchy);
    [IteratorStateMachineAttribute("Microsoft.Scripting.Utils.ReflectionUtils/<GetInheritedEvents>d__34")]
[ExtensionAttribute]
public static IEnumerable`1<EventInfo> GetInheritedEvents(Type type, string name, bool flattenHierarchy);
    private static bool IncludeEvent(EventInfo member, Type reflectedType, HashSet`1<MethodInfo> baseDefinitions, bool flattenHierarchy);
    [IteratorStateMachineAttribute("Microsoft.Scripting.Utils.ReflectionUtils/<GetInheritedFields>d__36")]
[ExtensionAttribute]
public static IEnumerable`1<FieldInfo> GetInheritedFields(Type type, string name, bool flattenHierarchy);
    private static bool IncludeField(FieldInfo member, Type reflectedType, bool flattenHierarchy);
    [ExtensionAttribute]
public static IEnumerable`1<MemberInfo> GetInheritedMembers(Type type, string name, bool flattenHierarchy);
    [ExtensionAttribute]
public static IEnumerable`1<ConstructorInfo> GetDeclaredConstructors(Type type);
    [ExtensionAttribute]
public static IEnumerable`1<MethodInfo> GetDeclaredMethods(Type type, string name);
    [ExtensionAttribute]
public static IEnumerable`1<PropertyInfo> GetDeclaredProperties(Type type);
    [ExtensionAttribute]
public static PropertyInfo GetDeclaredProperty(Type type, string name);
    [ExtensionAttribute]
public static IEnumerable`1<EventInfo> GetDeclaredEvents(Type type);
    [ExtensionAttribute]
public static EventInfo GetDeclaredEvent(Type type, string name);
    [ExtensionAttribute]
public static IEnumerable`1<FieldInfo> GetDeclaredFields(Type type);
    [ExtensionAttribute]
public static FieldInfo GetDeclaredField(Type type, string name);
    [ExtensionAttribute]
public static IEnumerable`1<Type> GetDeclaredNestedTypes(Type type);
    [ExtensionAttribute]
public static Type GetDeclaredNestedType(Type type, string name);
    [ExtensionAttribute]
public static IEnumerable`1<MemberInfo> GetDeclaredMembers(Type type, string name);
    [ExtensionAttribute]
public static Type[] GetGenericTypeArguments(Type type);
    [ExtensionAttribute]
public static Type[] GetGenericTypeParameters(Type type);
    [ExtensionAttribute]
[ObsoleteAttribute("Use Assembly.GetModules directly instead.")]
public static IEnumerable`1<Module> GetModules(Assembly assembly);
    [ExtensionAttribute]
[ObsoleteAttribute("Use Type.GetInterfaces directly instead.")]
public static IEnumerable`1<Type> GetImplementedInterfaces(Type type);
    [ExtensionAttribute]
public static TypeCode GetTypeCode(Type type);
    [ExtensionAttribute]
[ObsoleteAttribute("Use Delegate.GetMethodInfo directly instead.")]
public static MethodInfo GetMethod(Delegate d);
    [ExtensionAttribute]
public static bool IsDefined(Assembly assembly, Type attributeType);
    [ExtensionAttribute]
public static T GetCustomAttribute(Assembly assembly, bool inherit);
    [ExtensionAttribute]
public static T GetCustomAttribute(MemberInfo member, bool inherit);
    [ExtensionAttribute]
[ObsoleteAttribute("Use Type.ContainsGenericParameters directly instead.")]
public static bool ContainsGenericParameters(Type type);
    [ExtensionAttribute]
[ObsoleteAttribute("Use Type.IsInterface directly instead.")]
public static bool IsInterface(Type type);
    [ExtensionAttribute]
[ObsoleteAttribute("Use Type.IsClass directly instead.")]
public static bool IsClass(Type type);
    [ExtensionAttribute]
[ObsoleteAttribute("Use Type.IsGenericType directly instead.")]
public static bool IsGenericType(Type type);
    [ExtensionAttribute]
[ObsoleteAttribute("Use Type.IsGenericTypeDefinition directly instead.")]
public static bool IsGenericTypeDefinition(Type type);
    [ExtensionAttribute]
[ObsoleteAttribute("Use Type.IsSealed directly instead.")]
public static bool IsSealed(Type type);
    [ExtensionAttribute]
[ObsoleteAttribute("Use Type.IsAbstract directly instead.")]
public static bool IsAbstract(Type type);
    [ExtensionAttribute]
[ObsoleteAttribute("Use Type.IsPublic directly instead.")]
public static bool IsPublic(Type type);
    [ExtensionAttribute]
[ObsoleteAttribute("Use Type.IsVisible directly instead.")]
public static bool IsVisible(Type type);
    [ExtensionAttribute]
[ObsoleteAttribute("Use Type.BaseType directly instead.")]
public static Type GetBaseType(Type type);
    [ExtensionAttribute]
[ObsoleteAttribute("Use Type.IsValueType directly instead.")]
public static bool IsValueType(Type type);
    [ExtensionAttribute]
[ObsoleteAttribute("Use Type.IsEnum directly instead.")]
public static bool IsEnum(Type type);
    [ExtensionAttribute]
[ObsoleteAttribute("Use Type.IsPrimitive directly instead.")]
public static bool IsPrimitive(Type type);
    [ExtensionAttribute]
[ObsoleteAttribute("Use Type.GenericParameterAttributes directly instead.")]
public static GenericParameterAttributes GetGenericParameterAttributes(Type type);
    [ExtensionAttribute]
public static object GetRawConstantValue(FieldInfo field);
    public static object UnwrapEnumValue(object value);
    public static AssemblyBuilder DefineDynamicAssembly(AssemblyName name, AssemblyBuilderAccess access);
    [ExtensionAttribute]
public static ModuleBuilder DefineDynamicModule(AssemblyBuilder assembly, string name, bool emitDebugInfo);
    public static StringBuilder FormatSignature(StringBuilder result, MethodBase method);
    public static StringBuilder FormatSignature(StringBuilder result, MethodBase method, Func`2<Type, string> nameDispenser);
    public static StringBuilder FormatTypeName(StringBuilder result, Type type);
    public static StringBuilder FormatTypeName(StringBuilder result, Type type, Func`2<Type, string> nameDispenser);
    public static StringBuilder FormatTypeArgs(StringBuilder result, Type[] types);
    public static StringBuilder FormatTypeArgs(StringBuilder result, Type[] types, Func`2<Type, string> nameDispenser);
    internal static string ToValidTypeName(string str);
    public static string GetNormalizedTypeName(Type type);
    public static string GetNormalizedTypeName(string typeName);
    [ExtensionAttribute]
public static Delegate CreateDelegate(MethodInfo methodInfo, Type delegateType);
    [ExtensionAttribute]
public static Delegate CreateDelegate(MethodInfo methodInfo, Type delegateType, object target);
    public static bool IsDynamicMethod(MethodBase method);
    private static bool IsDynamicMethodInternal(MethodBase method);
    public static void GetDelegateSignature(Type delegateType, ParameterInfo[]& parameterInfos, ParameterInfo& returnInfo);
    public static Type GetObjectCallSiteDelegateType(int paramCnt);
    internal static DynamicMethod RawCreateDynamicMethod(string name, Type returnType, Type[] parameterTypes);
    public static MethodBase[] GetMethodInfos(MemberInfo[] members);
    public static Type[] GetParameterTypes(ParameterInfo[] parameterInfos);
    public static Type[] GetParameterTypes(IList`1<ParameterInfo> parameterInfos);
    [ExtensionAttribute]
public static Type GetReturnType(MethodBase mi);
    public static bool SignatureEquals(MethodInfo method, Type[] requiredSignature);
    [ExtensionAttribute]
public static bool IsExtension(MemberInfo member);
    [ExtensionAttribute]
public static bool IsOutParameter(ParameterInfo pi);
    [ExtensionAttribute]
public static bool IsMandatory(ParameterInfo pi);
    [ExtensionAttribute]
public static bool HasDefaultValue(ParameterInfo pi);
    [ExtensionAttribute]
public static bool ProhibitsNull(ParameterInfo parameter);
    [ExtensionAttribute]
public static bool ProhibitsNullItems(ParameterInfo parameter);
    [ExtensionAttribute]
public static bool IsParamArray(ParameterInfo parameter);
    [ExtensionAttribute]
public static bool IsParamDictionary(ParameterInfo parameter);
    public static bool IsParamsMethod(MethodBase method);
    public static bool IsParamsMethod(ParameterInfo[] pis);
    [ExtensionAttribute]
public static object GetDefaultValue(ParameterInfo info);
    [IteratorStateMachineAttribute("Microsoft.Scripting.Utils.ReflectionUtils/<Ancestors>d__111")]
[ExtensionAttribute]
public static IEnumerable`1<Type> Ancestors(Type type);
    public static List`1<Type> GetDeclaredInterfaces(Type type);
    [IteratorStateMachineAttribute("Microsoft.Scripting.Utils.ReflectionUtils/<GetAllTypesFromAssembly>d__113")]
internal static IEnumerable`1<Type> GetAllTypesFromAssembly(Assembly asm);
    internal static IEnumerable`1<Type> GetAllTypesFromAssembly(Assembly assembly, bool includePrivateTypes);
    public static MethodBuilder DefineMethodOverride(TypeBuilder tb, MethodAttributes extra, MethodInfo decl);
    public static void CopyMethodSignature(MethodInfo from, MethodBuilder to, bool substituteDeclaringType);
    private static void CopyGenericMethodAttributes(MethodInfo from, MethodBuilder to);
    public static IEnumerable`1<MethodInfo> GetVisibleExtensionMethods(Assembly assembly);
    private static IEnumerable`1<MethodInfo> GetVisibleExtensionMethodsFast(Assembly assembly);
    [IteratorStateMachineAttribute("Microsoft.Scripting.Utils.ReflectionUtils/<GetVisibleExtensionMethodsSlow>d__121")]
public static IEnumerable`1<MethodInfo> GetVisibleExtensionMethodsSlow(Assembly assembly);
    public static IEnumerable`1<KeyValuePair`2<string, IEnumerable`1<ExtensionMethodInfo>>> GetVisibleExtensionMethodGroups(Assembly assembly, bool useCache);
    [IteratorStateMachineAttribute("Microsoft.Scripting.Utils.ReflectionUtils/<EnumerateExtensionMethods>d__124")]
private static IEnumerable`1<KeyValuePair`2<string, IEnumerable`1<ExtensionMethodInfo>>> EnumerateExtensionMethods(Dictionary`2<string, List`1<ExtensionMethodInfo>> dict);
    internal static Dictionary`2<Type, Type> BindGenericParameters(Type openType, Type closedType, bool ignoreUnboundParameters);
    internal static bool BindGenericParameters(Type openType, Type closedType, Func`3<Type, Type, bool> binder);
    internal static bool ConstraintsViolated(Dictionary`2<Type, Type> binding, bool ignoreUnboundParameters);
    internal static bool ConstraintsViolated(Type genericParameter, Type closedType, Dictionary`2<Type, Type> binding, bool ignoreUnboundParameters);
    internal static Type InstantiateConstraint(Type constraint, Dictionary`2<Type, Type> binding);
}
public static class Microsoft.Scripting.Utils.StringUtils : object {
    [CompilerGeneratedAttribute]
private static Encoding <DefaultEncoding>k__BackingField;
    [ObsoleteAttribute("Use Encoding.Default")]
public static Encoding DefaultEncoding { get; }
    private static StringUtils();
    [CompilerGeneratedAttribute]
public static Encoding get_DefaultEncoding();
    public static string GetSuffix(string str, char separator, bool includeSeparator);
    public static string GetLongestPrefix(string str, char separator, bool includeSeparator);
    public static int CountOf(string str, char c);
    public static String[] Split(string str, string separator, int maxComponents, StringSplitOptions options);
    [ObsoleteAttribute("Use string.Split")]
public static String[] Split(string str, Char[] separators, int maxComponents, StringSplitOptions options);
    public static string SplitWords(string text, bool indentFirst, int lineWidth);
    public static string AddSlashes(string str);
    [ObsoleteAttribute("Use double.TryParse")]
public static bool TryParseDouble(string s, NumberStyles style, IFormatProvider provider, Double& result);
    [ObsoleteAttribute("Use int.TryParse")]
public static bool TryParseInt32(string s, Int32& result);
    [ObsoleteAttribute("Use DateTime.TryParseExact")]
public static bool TryParseDateTimeExact(string s, string format, IFormatProvider provider, DateTimeStyles style, DateTime& result);
    [ObsoleteAttribute("Use DateTime.TryParseExact")]
public static bool TryParseDateTimeExact(string s, String[] formats, IFormatProvider provider, DateTimeStyles style, DateTime& result);
    [ObsoleteAttribute("Use DateTime.TryParse")]
public static bool TryParseDate(string s, IFormatProvider provider, DateTimeStyles style, DateTime& result);
    [ObsoleteAttribute("Use CultureInfo.GetCultureInfo")]
public static CultureInfo GetCultureInfo(string name);
    [IteratorStateMachineAttribute("Microsoft.Scripting.Utils.StringUtils/<Split>d__16")]
public static IEnumerable`1<string> Split(string str, string sep);
}
[DefaultMemberAttribute("Item")]
public class Microsoft.Scripting.Utils.SynchronizedDictionary`2 : object {
    private Dictionary`2<TKey, TValue> _dictionary;
    public Dictionary`2<TKey, TValue> UnderlyingDictionary { get; }
    public ICollection`1<TKey> Keys { get; }
    public ICollection`1<TValue> Values { get; }
    public TValue Item { get; public set; }
    public int Count { get; }
    public bool IsReadOnly { get; }
    public SynchronizedDictionary`2(Dictionary`2<TKey, TValue> dictionary);
    public Dictionary`2<TKey, TValue> get_UnderlyingDictionary();
    public sealed virtual void Add(TKey key, TValue value);
    public sealed virtual bool ContainsKey(TKey key);
    public sealed virtual ICollection`1<TKey> get_Keys();
    public sealed virtual bool Remove(TKey key);
    public sealed virtual bool TryGetValue(TKey key, TValue& value);
    public sealed virtual ICollection`1<TValue> get_Values();
    public sealed virtual TValue get_Item(TKey key);
    public sealed virtual void set_Item(TKey key, TValue value);
    private ICollection`1<KeyValuePair`2<TKey, TValue>> AsICollection();
    public sealed virtual void Add(KeyValuePair`2<TKey, TValue> item);
    public sealed virtual void Clear();
    public sealed virtual bool Contains(KeyValuePair`2<TKey, TValue> item);
    public sealed virtual void CopyTo(KeyValuePair`2[] array, int arrayIndex);
    public sealed virtual int get_Count();
    public sealed virtual bool get_IsReadOnly();
    public sealed virtual bool Remove(KeyValuePair`2<TKey, TValue> item);
    public sealed virtual IEnumerator`1<KeyValuePair`2<TKey, TValue>> GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
}
public static class Microsoft.Scripting.Utils.ThreadingUtils : object {
    private static int id;
    private static ThreadLocal`1<int> threadIds;
    private static ThreadingUtils();
    public static int GetCurrentThreadId();
}
public class Microsoft.Scripting.Utils.ThreadLocal`1 : object {
    private StorageInfo[] _stores;
    private static StorageInfo[] Updating;
    private bool _refCounted;
    public T Value { get; public set; }
    public ThreadLocal`1(bool refCounted);
    private static ThreadLocal`1();
    public T get_Value();
    public void set_Value(T value);
    public T GetOrCreate(Func`1<T> func);
    public T Update(Func`2<T, T> updater);
    public T Update(T newValue);
    private static int GetCurrentThreadId();
    public StorageInfo<T> GetStorageInfo();
    private StorageInfo<T> GetStorageInfo(StorageInfo[] curStorage);
    private StorageInfo<T> RetryOrCreateStorageInfo(StorageInfo[] curStorage);
    private StorageInfo<T> CreateStorageInfo();
}
public class Microsoft.Scripting.Utils.TypeMemberCache`1 : object {
    private ConditionalWeakTable`2<Type, Dictionary`2<string, List`1<T>>> _typeMembersByName;
    private Func`2<Type, IEnumerable`1<T>> _reflector;
    public TypeMemberCache`1(Func`2<Type, IEnumerable`1<T>> reflector);
    private Dictionary`2<string, List`1<T>> GetMembers(Type type);
    public IEnumerable`1<T> GetMembers(Type type, string name, bool inherited);
    private Dictionary`2<string, List`1<T>> ReflectMembers(Type type);
    [CompilerGeneratedAttribute]
private Dictionary`2<string, List`1<T>> <GetMembers>b__1_0(Type t);
}
[ExtensionAttribute]
public static class Microsoft.Scripting.Utils.TypeUtils : object {
    public static Type ComObjectType;
    private static TypeUtils();
    [ExtensionAttribute]
public static bool IsNested(Type t);
    [ExtensionAttribute]
internal static Type GetNonNullableType(Type type);
    [ExtensionAttribute]
internal static Type GetNullableType(Type type);
    [ExtensionAttribute]
internal static bool IsNullableType(Type type);
    [ExtensionAttribute]
internal static bool IsBool(Type type);
    [ExtensionAttribute]
internal static bool IsNumeric(Type type);
    internal static bool IsNumeric(TypeCode typeCode);
    [ExtensionAttribute]
internal static bool IsArithmetic(Type type);
    [ExtensionAttribute]
internal static bool IsUnsignedInt(Type type);
    [ExtensionAttribute]
internal static bool IsIntegerOrBool(Type type);
    internal static bool CanAssign(Type to, Expression from);
    internal static bool CanAssign(Type to, Type from);
    internal static bool IsGeneric(Type type);
    internal static bool CanCompareToNull(Type type);
    internal static bool GetNumericConversionOrder(TypeCode code, Int32& x, Int32& y);
    internal static bool IsImplicitlyConvertible(int fromX, int fromY, int toX, int toY);
    internal static bool HasBuiltinEquality(Type left, Type right);
    private static bool NullVsNullable(Type left, Type right);
    internal static bool AreEquivalent(Type t1, Type t2);
    internal static bool AreReferenceAssignable(Type dest, Type src);
    internal static bool AreAssignable(Type dest, Type src);
    internal static Type GetConstantType(Type type);
    internal static bool IsConvertible(Type type);
    internal static bool IsFloatingPoint(Type type);
    public static bool IsComObjectType(Type type);
    public static bool IsComObject(object obj);
}
public class Microsoft.Scripting.Utils.ValueArray`1 : object {
    private T[] _array;
    public ValueArray`1(T[] array);
    public sealed virtual bool Equals(ValueArray`1<T> other);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
}
internal class Microsoft.Scripting.Utils.WeakCollection`1 : object {
    private static int DefaultCapacity;
    private WeakReference[] _items;
    private int _size;
    public void Add(T t);
    private void EnsureCapacity(int size);
    private void Compact();
    [IteratorStateMachineAttribute("Microsoft.Scripting.Utils.WeakCollection`1/<GetEnumerator>d__6")]
public sealed virtual IEnumerator`1<T> GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
}
internal class Microsoft.Scripting.Utils.WeakComparer`1 : object {
    private sealed virtual override bool System.Collections.Generic.IEqualityComparer<T>.Equals(T x, T y);
    private sealed virtual override int System.Collections.Generic.IEqualityComparer<T>.GetHashCode(T obj);
}
[DefaultMemberAttribute("Item")]
public class Microsoft.Scripting.Utils.WeakDictionary`2 : object {
    private static IEqualityComparer`1<object> comparer;
    private static ConstructorInfo valueConstructor;
    private IDictionary`2<object, TValue> dict;
    private int version;
    private int cleanupVersion;
    private int cleanupGC;
    public ICollection`1<TKey> Keys { get; }
    public ICollection`1<TValue> Values { get; }
    public TValue Item { get; public set; }
    public int Count { get; }
    public bool IsReadOnly { get; }
    private static WeakDictionary`2();
    public sealed virtual void Add(TKey key, TValue value);
    public sealed virtual bool ContainsKey(TKey key);
    public sealed virtual ICollection`1<TKey> get_Keys();
    public sealed virtual bool Remove(TKey key);
    public sealed virtual bool TryGetValue(TKey key, TValue& value);
    public TValue GetOrCreateValue(TKey key);
    public sealed virtual ICollection`1<TValue> get_Values();
    public sealed virtual TValue get_Item(TKey key);
    public sealed virtual void set_Item(TKey key, TValue value);
    private void CheckCleanup();
    private void Cleanup();
    public sealed virtual void Add(KeyValuePair`2<TKey, TValue> item);
    public sealed virtual void Clear();
    public sealed virtual bool Contains(KeyValuePair`2<TKey, TValue> item);
    public sealed virtual void CopyTo(KeyValuePair`2[] array, int arrayIndex);
    public sealed virtual int get_Count();
    public sealed virtual bool get_IsReadOnly();
    public sealed virtual bool Remove(KeyValuePair`2<TKey, TValue> item);
    public sealed virtual IEnumerator`1<KeyValuePair`2<TKey, TValue>> GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
}
public class Microsoft.Scripting.Utils.WeakHandle : ValueType {
    private GCHandle _gcHandle;
    public object Target { get; }
    public WeakHandle(object target, bool trackResurrection);
    public object get_Target();
    public void Free();
}
internal class Microsoft.Scripting.Utils.WeakObject : object {
    private WeakReference weakReference;
    private int hashCode;
    public object Target { get; }
    public WeakObject(object obj);
    public object get_Target();
    public virtual int GetHashCode();
    public virtual bool Equals(object obj);
}
[CompilerGeneratedAttribute]
[EmbeddedAttribute]
[AttributeUsageAttribute("27524")]
internal class System.Runtime.CompilerServices.NullableAttribute : Attribute {
    public Byte[] NullableFlags;
    public NullableAttribute(byte );
    public NullableAttribute(Byte[] );
}
