public class Microsoft.Scripting.ArgumentTypeException : Exception {
    public ArgumentTypeException(string message);
    public ArgumentTypeException(string message, Exception innerException);
    protected ArgumentTypeException(SerializationInfo info, StreamingContext context);
}
public class Microsoft.Scripting.AssemblyLoadedEventArgs : EventArgs {
    [CompilerGeneratedAttribute]
private Assembly <Assembly>k__BackingField;
    public Assembly Assembly { get; }
    public AssemblyLoadedEventArgs(Assembly assembly);
    [CompilerGeneratedAttribute]
public Assembly get_Assembly();
}
public class Microsoft.Scripting.CompilerOptions : object {
}
internal static class Microsoft.Scripting.Error : object {
    internal static Exception MustHaveCodeOrTarget();
    internal static Exception TypeParameterIsNotDelegate(object p0);
    internal static Exception InvalidCast(object p0, object p1);
    internal static Exception UnknownMemberType(object p0);
    internal static Exception FirstArgumentMustBeCallSite();
    internal static Exception NoInstanceForCall();
    internal static Exception MissingTest();
    internal static Exception MissingTarget();
    internal static Exception NonGenericWithGenericGroup(object p0);
    internal static Exception InvalidOperation(object p0);
    internal static Exception FinallyAlreadyDefined();
    internal static Exception CannotHaveFaultAndFinally();
    internal static Exception FaultAlreadyDefined();
    internal static Exception CantCreateDefaultTypeFor(object p0);
    internal static Exception UnhandledConvert(object p0);
    internal static Exception NoCallableMethods(object p0, object p1);
    internal static Exception GlobalsMustBeUnique();
    internal static Exception GenNonSerializableBinder();
    internal static Exception InvalidPath();
    internal static Exception DictionaryNotHashable();
    internal static Exception LanguageRegistered();
    internal static Exception MethodOrOperatorNotImplemented();
    internal static Exception NoException();
    internal static Exception ExtensionMustBePublic(object p0);
    internal static Exception AlreadyInitialized();
    internal static Exception MustReturnScopeExtension();
    internal static Exception InvalidParamNumForService();
    internal static Exception InvalidArgumentType(object p0, object p1);
    internal static Exception CannotChangeNonCachingValue();
    internal static Exception FieldReadonly(object p0);
    internal static Exception PropertyReadonly(object p0);
    internal static Exception UnexpectedEvent(object p0, object p1, object p2, object p3);
    internal static Exception ExpectedBoundEvent(object p0);
    internal static Exception UnexpectedType(object p0, object p1);
    internal static Exception MemberWriteOnly(object p0);
    internal static Exception NoCodeToCompile();
    internal static Exception InvalidStreamType(object p0);
    internal static Exception QueueEmpty();
    internal static Exception EnumerationNotStarted();
    internal static Exception EnumerationFinished();
    internal static Exception CantAddCasing(object p0);
    internal static Exception CantAddIdentifier(object p0);
    internal static Exception InvalidOutputDir();
    internal static Exception InvalidAsmNameOrExtension();
    internal static Exception CanotEmitConstant(object p0, object p1);
    internal static Exception NoImplicitCast(object p0, object p1);
    internal static Exception NoExplicitCast(object p0, object p1);
    internal static Exception NameNotDefined(object p0);
    internal static Exception NoDefaultValue();
    internal static Exception UnknownLanguageProviderType();
    internal static Exception CantReadProperty();
    internal static Exception CantWriteProperty();
    internal static Exception IllegalNew_GenericParams(object p0);
    internal static Exception VerificationException(object p0, object p1, object p2);
}
public class Microsoft.Scripting.ErrorCounter : ErrorSink {
    private ErrorSink _sink;
    private int _fatalErrorCount;
    private int _errorCount;
    private int _warningCount;
    public int FatalErrorCount { get; }
    public int ErrorCount { get; }
    public int WarningCount { get; }
    public bool AnyError { get; }
    public ErrorCounter(ErrorSink sink);
    public int get_FatalErrorCount();
    public int get_ErrorCount();
    public int get_WarningCount();
    public bool get_AnyError();
    protected virtual void CountError(Severity severity);
    public void ClearCounters();
    public virtual void Add(SourceUnit source, string message, SourceSpan span, int errorCode, Severity severity);
}
public class Microsoft.Scripting.ErrorSink : object {
    public static ErrorSink Default;
    public static ErrorSink Null;
    private static ErrorSink();
    public virtual void Add(SourceUnit source, string message, SourceSpan span, int errorCode, Severity severity);
    public virtual void Add(string message, string path, string code, string line, SourceSpan span, int errorCode, Severity severity);
}
internal class Microsoft.Scripting.FileStreamContentProvider : StreamContentProvider {
    private string _path;
    private PALHolder _pal;
    internal string Path { get; }
    internal FileStreamContentProvider(PlatformAdaptationLayer pal, string path);
    internal string get_Path();
    public virtual Stream GetStream();
}
public class Microsoft.Scripting.Hosting.CompiledCode : object {
    private ScriptScope _defaultScope;
    [CompilerGeneratedAttribute]
private ScriptCode <ScriptCode>k__BackingField;
    [CompilerGeneratedAttribute]
private ScriptEngine <Engine>k__BackingField;
    internal ScriptCode ScriptCode { get; }
    public ScriptEngine Engine { get; }
    public ScriptScope DefaultScope { get; }
    internal CompiledCode(ScriptEngine engine, ScriptCode code);
    [CompilerGeneratedAttribute]
internal ScriptCode get_ScriptCode();
    [CompilerGeneratedAttribute]
public ScriptEngine get_Engine();
    public ScriptScope get_DefaultScope();
    public object Execute();
    public object Execute(ScriptScope scope);
    public T Execute();
    public T Execute(ScriptScope scope);
}
public class Microsoft.Scripting.Hosting.Configuration.LanguageElement : ConfigurationElement {
    private static string _Names;
    private static string _Extensions;
    private static string _Type;
    private static string _DisplayName;
    private static ConfigurationPropertyCollection _Properties;
    protected ConfigurationPropertyCollection Properties { get; }
    public string Names { get; public set; }
    public string Extensions { get; public set; }
    public string Type { get; public set; }
    public string DisplayName { get; public set; }
    private static LanguageElement();
    protected virtual ConfigurationPropertyCollection get_Properties();
    public string get_Names();
    public void set_Names(string value);
    public string get_Extensions();
    public void set_Extensions(string value);
    public string get_Type();
    public void set_Type(string value);
    public string get_DisplayName();
    public void set_DisplayName(string value);
    public String[] GetNamesArray();
    public String[] GetExtensionsArray();
    private static String[] Split(string str);
}
public class Microsoft.Scripting.Hosting.Configuration.LanguageElementCollection : ConfigurationElementCollection {
    public ConfigurationElementCollectionType CollectionType { get; }
    protected bool ThrowOnDuplicate { get; }
    protected string ElementName { get; }
    public virtual ConfigurationElementCollectionType get_CollectionType();
    protected virtual bool get_ThrowOnDuplicate();
    protected virtual ConfigurationElement CreateNewElement();
    protected virtual string get_ElementName();
    protected virtual object GetElementKey(ConfigurationElement element);
}
public class Microsoft.Scripting.Hosting.Configuration.OptionElement : ConfigurationElement {
    private static string _Option;
    private static string _Value;
    private static string _Language;
    private static ConfigurationPropertyCollection _Properties;
    protected ConfigurationPropertyCollection Properties { get; }
    public string Name { get; public set; }
    public string Value { get; public set; }
    public string Language { get; public set; }
    private static OptionElement();
    protected virtual ConfigurationPropertyCollection get_Properties();
    public string get_Name();
    public void set_Name(string value);
    public string get_Value();
    public void set_Value(string value);
    public string get_Language();
    public void set_Language(string value);
    internal object GetKey();
}
public class Microsoft.Scripting.Hosting.Configuration.OptionElementCollection : ConfigurationElementCollection {
    public ConfigurationElementCollectionType CollectionType { get; }
    protected bool ThrowOnDuplicate { get; }
    public virtual ConfigurationElementCollectionType get_CollectionType();
    protected virtual ConfigurationElement CreateNewElement();
    protected virtual bool get_ThrowOnDuplicate();
    protected virtual object GetElementKey(ConfigurationElement element);
}
public class Microsoft.Scripting.Hosting.Configuration.Section : ConfigurationSection {
    public static string SectionName;
    private static string _DebugMode;
    private static string _PrivateBinding;
    private static string _Languages;
    private static string _Options;
    private static ConfigurationPropertyCollection _Properties;
    protected ConfigurationPropertyCollection Properties { get; }
    public Nullable`1<bool> DebugMode { get; public set; }
    public Nullable`1<bool> PrivateBinding { get; public set; }
    private static Section();
    protected virtual ConfigurationPropertyCollection get_Properties();
    public Nullable`1<bool> get_DebugMode();
    public void set_DebugMode(Nullable`1<bool> value);
    public Nullable`1<bool> get_PrivateBinding();
    public void set_PrivateBinding(Nullable`1<bool> value);
    [IteratorStateMachineAttribute("Microsoft.Scripting.Hosting.Configuration.Section/<GetLanguages>d__14")]
public IEnumerable`1<LanguageElement> GetLanguages();
    [IteratorStateMachineAttribute("Microsoft.Scripting.Hosting.Configuration.Section/<GetOptions>d__15")]
public IEnumerable`1<OptionElement> GetOptions();
    private static Section LoadFromFile(Stream configFileStream);
    internal static void LoadRuntimeSetup(ScriptRuntimeSetup setup, Stream configFileStream);
}
public class Microsoft.Scripting.Hosting.DocumentationOperations : object {
    private DocumentationProvider _provider;
    internal DocumentationOperations(DocumentationProvider provider);
    public ICollection`1<MemberDoc> GetMembers(object value);
    public ICollection`1<OverloadDoc> GetOverloads(object value);
}
public abstract class Microsoft.Scripting.Hosting.ErrorListener : object {
    internal void ReportError(ScriptSource source, string message, SourceSpan& span, int errorCode, Severity severity);
    public abstract virtual void ErrorReported(ScriptSource source, string message, SourceSpan span, int errorCode, Severity severity);
}
internal class Microsoft.Scripting.Hosting.ErrorListenerProxySink : ErrorSink {
    private ErrorListener _listener;
    private ScriptSource _source;
    public ErrorListenerProxySink(ScriptSource source, ErrorListener listener);
    public virtual void Add(SourceUnit sourceUnit, string message, SourceSpan span, int errorCode, Severity severity);
}
public class Microsoft.Scripting.Hosting.ErrorSinkProxyListener : ErrorListener {
    private ErrorSink _errorSink;
    public ErrorSinkProxyListener(ErrorSink errorSink);
    public virtual void ErrorReported(ScriptSource source, string message, SourceSpan span, int errorCode, Severity severity);
}
public class Microsoft.Scripting.Hosting.ExceptionOperations : object {
    private LanguageContext _context;
    internal ExceptionOperations(LanguageContext context);
    public string FormatException(Exception exception);
    public void GetExceptionMessage(Exception exception, String& message, String& errorTypeName);
    public bool HandleException(Exception exception);
    public IList`1<DynamicStackFrame> GetStackFrames(Exception exception);
}
public class Microsoft.Scripting.Hosting.LanguageSetup : object {
    private string _typeName;
    private string _displayName;
    private bool _frozen;
    private Nullable`1<bool> _interpretedMode;
    private Nullable`1<bool> _exceptionDetail;
    private Nullable`1<bool> _perfStats;
    private Nullable`1<bool> _noAdaptiveCompilation;
    [CompilerGeneratedAttribute]
private IList`1<string> <Names>k__BackingField;
    [CompilerGeneratedAttribute]
private IList`1<string> <FileExtensions>k__BackingField;
    [CompilerGeneratedAttribute]
private IDictionary`2<string, object> <Options>k__BackingField;
    public string TypeName { get; public set; }
    public string DisplayName { get; public set; }
    public IList`1<string> Names { get; private set; }
    public IList`1<string> FileExtensions { get; private set; }
    public IDictionary`2<string, object> Options { get; private set; }
    [ObsoleteAttribute("This option is ignored")]
public bool InterpretedMode { get; public set; }
    [ObsoleteAttribute("Use Options["NoAdaptiveCompilation"] instead.")]
public bool NoAdaptiveCompilation { get; public set; }
    public bool ExceptionDetail { get; public set; }
    [ObsoleteAttribute("Use Options["PerfStats"] instead.")]
public bool PerfStats { get; public set; }
    public LanguageSetup(string typeName);
    public LanguageSetup(string typeName, string displayName);
    public LanguageSetup(string typeName, string displayName, IEnumerable`1<string> names, IEnumerable`1<string> fileExtensions);
    public T GetOption(string name, T defaultValue);
    public string get_TypeName();
    public void set_TypeName(string value);
    public string get_DisplayName();
    public void set_DisplayName(string value);
    [CompilerGeneratedAttribute]
public IList`1<string> get_Names();
    [CompilerGeneratedAttribute]
private void set_Names(IList`1<string> value);
    [CompilerGeneratedAttribute]
public IList`1<string> get_FileExtensions();
    [CompilerGeneratedAttribute]
private void set_FileExtensions(IList`1<string> value);
    [CompilerGeneratedAttribute]
public IDictionary`2<string, object> get_Options();
    [CompilerGeneratedAttribute]
private void set_Options(IDictionary`2<string, object> value);
    public bool get_InterpretedMode();
    public void set_InterpretedMode(bool value);
    public bool get_NoAdaptiveCompilation();
    public void set_NoAdaptiveCompilation(bool value);
    public bool get_ExceptionDetail();
    public void set_ExceptionDetail(bool value);
    public bool get_PerfStats();
    public void set_PerfStats(bool value);
    private bool GetCachedOption(string name, Nullable`1& storage);
    internal void Freeze();
    private void CheckFrozen();
}
public class Microsoft.Scripting.Hosting.MemberDoc : object {
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    [CompilerGeneratedAttribute]
private MemberKind <Kind>k__BackingField;
    public string Name { get; }
    public MemberKind Kind { get; }
    public MemberDoc(string name, MemberKind kind);
    [CompilerGeneratedAttribute]
public string get_Name();
    [CompilerGeneratedAttribute]
public MemberKind get_Kind();
}
public enum Microsoft.Scripting.Hosting.MemberKind : Enum {
    public int value__;
    public static MemberKind None;
    public static MemberKind Class;
    public static MemberKind Delegate;
    public static MemberKind Enum;
    public static MemberKind Event;
    public static MemberKind Field;
    public static MemberKind Function;
    public static MemberKind Module;
    public static MemberKind Property;
    public static MemberKind Constant;
    public static MemberKind EnumMember;
    public static MemberKind Instance;
    public static MemberKind Method;
    public static MemberKind Namespace;
}
public class Microsoft.Scripting.Hosting.ObjectOperations : object {
    private DynamicOperations _ops;
    [CompilerGeneratedAttribute]
private ScriptEngine <Engine>k__BackingField;
    public ScriptEngine Engine { get; }
    internal ObjectOperations(DynamicOperations ops, ScriptEngine engine);
    [CompilerGeneratedAttribute]
public ScriptEngine get_Engine();
    public bool IsCallable(object obj);
    public object Invoke(object obj, Object[] parameters);
    public object InvokeMember(object obj, string memberName, Object[] parameters);
    public object CreateInstance(object obj, Object[] parameters);
    public object GetMember(object obj, string name);
    public T GetMember(object obj, string name);
    public bool TryGetMember(object obj, string name, Object& value);
    public bool ContainsMember(object obj, string name);
    public void RemoveMember(object obj, string name);
    public void SetMember(object obj, string name, object value);
    public void SetMember(object obj, string name, T value);
    public object GetMember(object obj, string name, bool ignoreCase);
    public T GetMember(object obj, string name, bool ignoreCase);
    public bool TryGetMember(object obj, string name, bool ignoreCase, Object& value);
    public bool ContainsMember(object obj, string name, bool ignoreCase);
    public void RemoveMember(object obj, string name, bool ignoreCase);
    public void SetMember(object obj, string name, object value, bool ignoreCase);
    public void SetMember(object obj, string name, T value, bool ignoreCase);
    public T ConvertTo(object obj);
    public object ConvertTo(object obj, Type type);
    public bool TryConvertTo(object obj, T& result);
    public bool TryConvertTo(object obj, Type type, Object& result);
    public T ExplicitConvertTo(object obj);
    public object ExplicitConvertTo(object obj, Type type);
    public bool TryExplicitConvertTo(object obj, T& result);
    public bool TryExplicitConvertTo(object obj, Type type, Object& result);
    public T ImplicitConvertTo(object obj);
    public object ImplicitConvertTo(object obj, Type type);
    public bool TryImplicitConvertTo(object obj, T& result);
    public bool TryImplicitConvertTo(object obj, Type type, Object& result);
    public object DoOperation(ExpressionType operation, object target);
    public TResult DoOperation(ExpressionType operation, TTarget target);
    public object DoOperation(ExpressionType operation, object target, object other);
    public TResult DoOperation(ExpressionType operation, TTarget target, TOther other);
    public object Add(object self, object other);
    public object Subtract(object self, object other);
    public object Power(object self, object other);
    public object Multiply(object self, object other);
    public object Divide(object self, object other);
    public object Modulo(object self, object other);
    public object LeftShift(object self, object other);
    public object RightShift(object self, object other);
    public object BitwiseAnd(object self, object other);
    public object BitwiseOr(object self, object other);
    public object ExclusiveOr(object self, object other);
    public bool LessThan(object self, object other);
    public bool GreaterThan(object self, object other);
    public bool LessThanOrEqual(object self, object other);
    public bool GreaterThanOrEqual(object self, object other);
    public bool Equal(object self, object other);
    public bool NotEqual(object self, object other);
    [ObsoleteAttribute("Use Format method instead.")]
public string GetCodeRepresentation(object obj);
    public string Format(object obj);
    public IList`1<string> GetMemberNames(object obj);
    public string GetDocumentation(object obj);
    public IList`1<string> GetCallSignatures(object obj);
}
public class Microsoft.Scripting.Hosting.OverloadDoc : object {
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Documentation>k__BackingField;
    [CompilerGeneratedAttribute]
private ICollection`1<ParameterDoc> <Parameters>k__BackingField;
    [CompilerGeneratedAttribute]
private ParameterDoc <ReturnParameter>k__BackingField;
    public string Name { get; }
    public string Documentation { get; }
    public ICollection`1<ParameterDoc> Parameters { get; }
    public ParameterDoc ReturnParameter { get; }
    public OverloadDoc(string name, string documentation, ICollection`1<ParameterDoc> parameters);
    public OverloadDoc(string name, string documentation, ICollection`1<ParameterDoc> parameters, ParameterDoc returnParameter);
    [CompilerGeneratedAttribute]
public string get_Name();
    [CompilerGeneratedAttribute]
public string get_Documentation();
    [CompilerGeneratedAttribute]
public ICollection`1<ParameterDoc> get_Parameters();
    [CompilerGeneratedAttribute]
public ParameterDoc get_ReturnParameter();
}
public class Microsoft.Scripting.Hosting.ParameterDoc : object {
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    [CompilerGeneratedAttribute]
private string <TypeName>k__BackingField;
    [CompilerGeneratedAttribute]
private ParameterFlags <Flags>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Documentation>k__BackingField;
    public string Name { get; }
    public string TypeName { get; }
    public ParameterFlags Flags { get; }
    public string Documentation { get; }
    public ParameterDoc(string name);
    public ParameterDoc(string name, ParameterFlags paramFlags);
    public ParameterDoc(string name, string typeName);
    public ParameterDoc(string name, string typeName, string documentation);
    public ParameterDoc(string name, string typeName, string documentation, ParameterFlags paramFlags);
    [CompilerGeneratedAttribute]
public string get_Name();
    [CompilerGeneratedAttribute]
public string get_TypeName();
    [CompilerGeneratedAttribute]
public ParameterFlags get_Flags();
    [CompilerGeneratedAttribute]
public string get_Documentation();
}
[FlagsAttribute]
public enum Microsoft.Scripting.Hosting.ParameterFlags : Enum {
    public int value__;
    public static ParameterFlags None;
    public static ParameterFlags ParamsArray;
    public static ParameterFlags ParamsDict;
}
public static class Microsoft.Scripting.Hosting.Providers.HostingHelpers : object {
    public static ScriptDomainManager GetDomainManager(ScriptRuntime runtime);
    public static LanguageContext GetLanguageContext(ScriptEngine engine);
    public static SourceUnit GetSourceUnit(ScriptSource scriptSource);
    public static ScriptCode GetScriptCode(CompiledCode compiledCode);
    public static SharedIO GetSharedIO(ScriptIO io);
    public static Scope GetScope(ScriptScope scriptScope);
    public static ScriptScope CreateScriptScope(ScriptEngine engine, Scope scope);
    [ObsoleteAttribute("You should implement a service via LanguageContext and call ScriptEngine.GetService")]
public static TRet CallEngine(ScriptEngine engine, Func`3<LanguageContext, T, TRet> f, T arg);
    public static DocumentationOperations CreateDocumentationOperations(DocumentationProvider provider);
}
[DebuggerDisplayAttribute("{Setup.DisplayName}")]
public class Microsoft.Scripting.Hosting.ScriptEngine : object {
    private LanguageSetup _config;
    private ObjectOperations _operations;
    [CompilerGeneratedAttribute]
private ScriptRuntime <Runtime>k__BackingField;
    [CompilerGeneratedAttribute]
private LanguageContext <LanguageContext>k__BackingField;
    public ObjectOperations Operations { get; }
    public LanguageSetup Setup { get; }
    public ScriptRuntime Runtime { get; }
    public Version LanguageVersion { get; }
    internal LanguageContext LanguageContext { get; }
    internal ScriptEngine(ScriptRuntime runtime, LanguageContext context);
    public ObjectOperations get_Operations();
    public ObjectOperations CreateOperations();
    public ObjectOperations CreateOperations(ScriptScope scope);
    public object Execute(string expression);
    public object Execute(string expression, ScriptScope scope);
    public T Execute(string expression);
    public T Execute(string expression, ScriptScope scope);
    public ScriptScope ExecuteFile(string path);
    public ScriptScope ExecuteFile(string path, ScriptScope scope);
    public ScriptScope CreateScope();
    public ScriptScope CreateScope(IDictionary`2<string, object> dictionary);
    public ScriptScope CreateScope(IDynamicMetaObjectProvider storage);
    public ScriptScope GetScope(string path);
    public ScriptSource CreateScriptSourceFromString(string expression);
    public ScriptSource CreateScriptSourceFromString(string code, SourceCodeKind kind);
    public ScriptSource CreateScriptSourceFromString(string expression, string path);
    public ScriptSource CreateScriptSourceFromString(string code, string path, SourceCodeKind kind);
    public ScriptSource CreateScriptSourceFromFile(string path);
    public ScriptSource CreateScriptSourceFromFile(string path, Encoding encoding);
    public ScriptSource CreateScriptSourceFromFile(string path, Encoding encoding, SourceCodeKind kind);
    public ScriptSource CreateScriptSource(CodeObject content);
    public ScriptSource CreateScriptSource(CodeObject content, string path);
    public ScriptSource CreateScriptSource(CodeObject content, SourceCodeKind kind);
    public ScriptSource CreateScriptSource(CodeObject content, string path, SourceCodeKind kind);
    public ScriptSource CreateScriptSource(StreamContentProvider content, string path);
    public ScriptSource CreateScriptSource(StreamContentProvider content, string path, Encoding encoding);
    public ScriptSource CreateScriptSource(StreamContentProvider content, string path, Encoding encoding, SourceCodeKind kind);
    public ScriptSource CreateScriptSource(TextContentProvider contentProvider, string path, SourceCodeKind kind);
    public TService GetService(Object[] args);
    public LanguageSetup get_Setup();
    [CompilerGeneratedAttribute]
public ScriptRuntime get_Runtime();
    public Version get_LanguageVersion();
    public CompilerOptions GetCompilerOptions();
    public CompilerOptions GetCompilerOptions(ScriptScope scope);
    public void SetSearchPaths(ICollection`1<string> paths);
    public ICollection`1<string> GetSearchPaths();
    [CompilerGeneratedAttribute]
internal LanguageContext get_LanguageContext();
    internal TRet Call(Func`3<LanguageContext, T, TRet> f, T arg);
}
public class Microsoft.Scripting.Hosting.ScriptHost : object {
    private ScriptRuntime _runtime;
    public ScriptRuntime Runtime { get; }
    public PlatformAdaptationLayer PlatformAdaptationLayer { get; }
    internal void SetRuntime(ScriptRuntime runtime);
    public ScriptRuntime get_Runtime();
    public virtual PlatformAdaptationLayer get_PlatformAdaptationLayer();
    protected virtual void RuntimeAttached();
    protected internal virtual void EngineCreated(ScriptEngine engine);
}
internal class Microsoft.Scripting.Hosting.ScriptHostProxy : DynamicRuntimeHostingProvider {
    private ScriptHost _host;
    public PlatformAdaptationLayer PlatformAdaptationLayer { get; }
    public ScriptHostProxy(ScriptHost host);
    public virtual PlatformAdaptationLayer get_PlatformAdaptationLayer();
}
public class Microsoft.Scripting.Hosting.ScriptIO : object {
    [CompilerGeneratedAttribute]
private SharedIO <SharedIO>k__BackingField;
    public Stream InputStream { get; }
    public Stream OutputStream { get; }
    public Stream ErrorStream { get; }
    public TextReader InputReader { get; }
    public TextWriter OutputWriter { get; }
    public TextWriter ErrorWriter { get; }
    public Encoding InputEncoding { get; }
    public Encoding OutputEncoding { get; }
    public Encoding ErrorEncoding { get; }
    internal SharedIO SharedIO { get; }
    internal ScriptIO(SharedIO io);
    public Stream get_InputStream();
    public Stream get_OutputStream();
    public Stream get_ErrorStream();
    public TextReader get_InputReader();
    public TextWriter get_OutputWriter();
    public TextWriter get_ErrorWriter();
    public Encoding get_InputEncoding();
    public Encoding get_OutputEncoding();
    public Encoding get_ErrorEncoding();
    [CompilerGeneratedAttribute]
internal SharedIO get_SharedIO();
    public void SetOutput(Stream stream, Encoding encoding);
    public void SetOutput(Stream stream, TextWriter writer);
    public void SetErrorOutput(Stream stream, Encoding encoding);
    public void SetErrorOutput(Stream stream, TextWriter writer);
    public void SetInput(Stream stream, Encoding encoding);
    public void SetInput(Stream stream, TextReader reader, Encoding encoding);
    public void RedirectToConsole();
}
public class Microsoft.Scripting.Hosting.ScriptRuntime : object {
    private Dictionary`2<LanguageContext, ScriptEngine> _engines;
    private InvariantContext _invariantContext;
    private object _lock;
    private ScriptScope _globals;
    private Scope _scopeGlobals;
    private ScriptEngine _invariantEngine;
    [CompilerGeneratedAttribute]
private ScriptDomainManager <Manager>k__BackingField;
    [CompilerGeneratedAttribute]
private ScriptHost <Host>k__BackingField;
    [CompilerGeneratedAttribute]
private ScriptIO <IO>k__BackingField;
    [CompilerGeneratedAttribute]
private ScriptRuntimeSetup <Setup>k__BackingField;
    internal ScriptDomainManager Manager { get; }
    public ScriptHost Host { get; }
    public ScriptIO IO { get; }
    public ScriptRuntimeSetup Setup { get; }
    public ScriptScope Globals { get; public set; }
    public ObjectOperations Operations { get; }
    internal ScriptEngine InvariantEngine { get; }
    public ScriptRuntime(ScriptRuntimeSetup setup);
    [CompilerGeneratedAttribute]
internal ScriptDomainManager get_Manager();
    [CompilerGeneratedAttribute]
public ScriptHost get_Host();
    [CompilerGeneratedAttribute]
public ScriptIO get_IO();
    public static ScriptRuntime CreateFromConfiguration();
    [CompilerGeneratedAttribute]
public ScriptRuntimeSetup get_Setup();
    public ScriptEngine GetEngine(string languageName);
    public ScriptEngine GetEngineByTypeName(string assemblyQualifiedTypeName);
    public ScriptEngine GetEngineByFileExtension(string fileExtension);
    public bool TryGetEngine(string languageName, ScriptEngine& engine);
    public bool TryGetEngineByFileExtension(string fileExtension, ScriptEngine& engine);
    internal ScriptEngine GetEngine(LanguageContext language);
    private ScriptEngine GetEngineNoLockNoNotification(LanguageContext language, Boolean& freshEngineCreated);
    public ScriptScope CreateScope();
    public ScriptScope CreateScope(string languageId);
    public ScriptScope CreateScope(IDynamicMetaObjectProvider storage);
    public ScriptScope CreateScope(string languageId, IDynamicMetaObjectProvider storage);
    public ScriptScope CreateScope(IDictionary`2<string, object> dictionary);
    public ScriptScope CreateScope(string languageId, IDictionary`2<string, object> storage);
    public ScriptScope ExecuteFile(string path);
    public ScriptScope UseFile(string path);
    public ScriptScope get_Globals();
    public void set_Globals(ScriptScope value);
    public void LoadAssembly(Assembly assembly);
    public ObjectOperations get_Operations();
    public ObjectOperations CreateOperations();
    public void Shutdown();
    internal ScriptEngine get_InvariantEngine();
}
public class Microsoft.Scripting.Hosting.ScriptRuntimeSetup : object {
    private Type _hostType;
    private IList`1<object> _hostArguments;
    private bool _debugMode;
    private bool _privateBinding;
    private bool _frozen;
    [CompilerGeneratedAttribute]
private IList`1<LanguageSetup> <LanguageSetups>k__BackingField;
    [CompilerGeneratedAttribute]
private IDictionary`2<string, object> <Options>k__BackingField;
    public IList`1<LanguageSetup> LanguageSetups { get; private set; }
    public bool DebugMode { get; public set; }
    public bool PrivateBinding { get; public set; }
    public Type HostType { get; public set; }
    public IDictionary`2<string, object> Options { get; private set; }
    public IList`1<object> HostArguments { get; public set; }
    [CompilerGeneratedAttribute]
public IList`1<LanguageSetup> get_LanguageSetups();
    [CompilerGeneratedAttribute]
private void set_LanguageSetups(IList`1<LanguageSetup> value);
    public bool get_DebugMode();
    public void set_DebugMode(bool value);
    public bool get_PrivateBinding();
    public void set_PrivateBinding(bool value);
    public Type get_HostType();
    public void set_HostType(Type value);
    [CompilerGeneratedAttribute]
public IDictionary`2<string, object> get_Options();
    [CompilerGeneratedAttribute]
private void set_Options(IDictionary`2<string, object> value);
    public IList`1<object> get_HostArguments();
    public void set_HostArguments(IList`1<object> value);
    internal DlrConfiguration ToConfiguration();
    private void Freeze(ReadOnlyCollection`1<LanguageSetup> setups);
    private void CheckFrozen();
    public static ScriptRuntimeSetup ReadConfiguration();
    private static void LoadRuntimeSetup(ScriptRuntimeSetup setup, Stream configFileStream);
    private static void LoadRuntimeSetupImpl(ScriptRuntimeSetup setup, Stream configFileStream);
    public static ScriptRuntimeSetup ReadConfiguration(Stream configFileStream);
    public static ScriptRuntimeSetup ReadConfiguration(string configFilePath);
}
[DebuggerTypeProxyAttribute("Microsoft.Scripting.Hosting.ScriptScope/DebugView")]
public class Microsoft.Scripting.Hosting.ScriptScope : object {
    [CompilerGeneratedAttribute]
private Scope <Scope>k__BackingField;
    [CompilerGeneratedAttribute]
private ScriptEngine <Engine>k__BackingField;
    internal Scope Scope { get; }
    public ScriptEngine Engine { get; }
    internal ScriptScope(ScriptEngine engine, Scope scope);
    [CompilerGeneratedAttribute]
internal Scope get_Scope();
    [CompilerGeneratedAttribute]
public ScriptEngine get_Engine();
    public object GetVariable(string name);
    public T GetVariable(string name);
    public bool TryGetVariable(string name, Object& value);
    public bool TryGetVariable(string name, T& value);
    public void SetVariable(string name, object value);
    public bool ContainsVariable(string name);
    public bool RemoveVariable(string name);
    public IEnumerable`1<string> GetVariableNames();
    public IEnumerable`1<KeyValuePair`2<string, object>> GetItems();
    private sealed virtual override DynamicMetaObject System.Dynamic.IDynamicMetaObjectProvider.GetMetaObject(Expression parameter);
}
[DebuggerDisplayAttribute("{DebugString}")]
public class Microsoft.Scripting.Hosting.ScriptSource : object {
    [CompilerGeneratedAttribute]
private SourceUnit <SourceUnit>k__BackingField;
    [CompilerGeneratedAttribute]
private ScriptEngine <Engine>k__BackingField;
    internal SourceUnit SourceUnit { get; }
    public string Path { get; }
    private string DebugString { get; }
    public SourceCodeKind Kind { get; }
    public ScriptEngine Engine { get; }
    internal ScriptSource(ScriptEngine engine, SourceUnit sourceUnit);
    [CompilerGeneratedAttribute]
internal SourceUnit get_SourceUnit();
    public string get_Path();
    private string get_DebugString();
    public SourceCodeKind get_Kind();
    [CompilerGeneratedAttribute]
public ScriptEngine get_Engine();
    public CompiledCode Compile();
    public CompiledCode Compile(ErrorListener errorListener);
    public CompiledCode Compile(CompilerOptions compilerOptions);
    public CompiledCode Compile(CompilerOptions compilerOptions, ErrorListener errorListener);
    private CompiledCode CompileInternal(CompilerOptions compilerOptions, ErrorListener errorListener);
    public object Execute(ScriptScope scope);
    public object Execute();
    public T Execute(ScriptScope scope);
    public T Execute();
    public int ExecuteProgram();
    public ScriptCodeParseResult GetCodeProperties();
    public ScriptCodeParseResult GetCodeProperties(CompilerOptions options);
    public SourceCodeReader GetReader();
    public Encoding DetectEncoding();
    public String[] GetCodeLines(int start, int count);
    public string GetCodeLine(int line);
    public string GetCode();
    public int MapLine(int line);
    public SourceSpan MapLine(SourceSpan span);
    public SourceLocation MapLine(SourceLocation location);
    public string MapLinetoFile(int line);
}
public class Microsoft.Scripting.Hosting.TokenCategorizer : object {
    private TokenizerService _tokenizer;
    public object CurrentState { get; }
    public SourceLocation CurrentPosition { get; }
    public bool IsRestartable { get; }
    public ErrorSink ErrorSink { get; public set; }
    internal TokenCategorizer(TokenizerService tokenizer);
    public void Initialize(object state, ScriptSource scriptSource, SourceLocation initialLocation);
    public object get_CurrentState();
    public SourceLocation get_CurrentPosition();
    public TokenInfo ReadToken();
    public bool get_IsRestartable();
    public ErrorSink get_ErrorSink();
    public void set_ErrorSink(ErrorSink value);
    public bool SkipToken();
    public IEnumerable`1<TokenInfo> ReadTokens(int characterCount);
    public bool SkipTokens(int characterCount);
}
[IsReadOnlyAttribute]
public class Microsoft.Scripting.IndexSpan : ValueType {
    [CompilerGeneratedAttribute]
private int <Start>k__BackingField;
    [CompilerGeneratedAttribute]
private int <Length>k__BackingField;
    public int Start { get; }
    public int End { get; }
    public int Length { get; }
    public bool IsEmpty { get; }
    public IndexSpan(int start, int length);
    [CompilerGeneratedAttribute]
public int get_Start();
    public int get_End();
    [CompilerGeneratedAttribute]
public int get_Length();
    public bool get_IsEmpty();
    public virtual int GetHashCode();
    public virtual bool Equals(object obj);
    public static bool op_Equality(IndexSpan self, IndexSpan other);
    public static bool op_Inequality(IndexSpan self, IndexSpan other);
    public sealed virtual bool Equals(IndexSpan other);
}
public class Microsoft.Scripting.InvalidImplementationException : Exception {
    public InvalidImplementationException(string message);
    public InvalidImplementationException(string message, Exception e);
    protected InvalidImplementationException(SerializationInfo info, StreamingContext context);
}
public interface Microsoft.Scripting.IScopeVariable {
    public bool HasValue { get; }
    public abstract virtual bool get_HasValue();
    public abstract virtual bool TryGetValue(Object& value);
    public abstract virtual void SetValue(object value);
    public abstract virtual bool DeleteValue();
}
internal interface Microsoft.Scripting.IWeakReferencable {
    public WeakReference WeakReference { get; }
    public abstract virtual WeakReference get_WeakReference();
}
public class Microsoft.Scripting.LanguageOptions : object {
    private bool _exceptionDetail;
    private bool _showClrExceptions;
    private bool _interpretedMode;
    private bool _perfStats;
    private bool _noAdaptiveCompilation;
    private int _compilationThreshold;
    private ReadOnlyCollection`1<string> _searchPaths;
    protected static ReadOnlyCollection`1<string> EmptyStringCollection;
    public bool NoAdaptiveCompilation { get; }
    public int CompilationThreshold { get; }
    [ObsoleteAttribute("No longer used.")]
public bool InterpretedMode { get; public set; }
    public bool ExceptionDetail { get; public set; }
    public bool ShowClrExceptions { get; public set; }
    public bool PerfStats { get; }
    public ReadOnlyCollection`1<string> SearchPaths { get; }
    public LanguageOptions(IDictionary`2<string, object> options);
    private static LanguageOptions();
    public bool get_NoAdaptiveCompilation();
    public int get_CompilationThreshold();
    public bool get_InterpretedMode();
    public void set_InterpretedMode(bool value);
    public bool get_ExceptionDetail();
    public void set_ExceptionDetail(bool value);
    public bool get_ShowClrExceptions();
    public void set_ShowClrExceptions(bool value);
    public bool get_PerfStats();
    public ReadOnlyCollection`1<string> get_SearchPaths();
    public static T GetOption(IDictionary`2<string, object> options, string name, T defaultValue);
    public static ReadOnlyCollection`1<string> GetStringCollectionOption(IDictionary`2<string, object> options, string name, Char[] separators);
    public static ReadOnlyCollection`1<string> GetSearchPathsOption(IDictionary`2<string, object> options);
}
internal class Microsoft.Scripting.NullErrorSink : ErrorSink {
    public virtual void Add(SourceUnit source, string message, SourceSpan span, int errorCode, Severity severity);
}
[AttributeUsageAttribute("2048")]
public class Microsoft.Scripting.ParamDictionaryAttribute : Attribute {
}
public class Microsoft.Scripting.PlatformAdaptationLayer : object {
    public static PlatformAdaptationLayer Default;
    [ObsoleteAttribute("This will be removed in the the future.")]
public static bool IsCompactFramework;
    [CompilerGeneratedAttribute]
private static bool <IsNativeModule>k__BackingField;
    public static bool IsNativeModule { get; }
    public bool IsSingleRootFileSystem { get; }
    public StringComparer PathComparer { get; }
    public string CurrentDirectory { get; public set; }
    private static PlatformAdaptationLayer();
    [CompilerGeneratedAttribute]
public static bool get_IsNativeModule();
    private static bool _IsNativeModule();
    public virtual Assembly LoadAssembly(string name);
    public virtual Assembly LoadAssemblyFromPath(string path);
    public virtual void TerminateScriptExecution(int exitCode);
    public virtual bool get_IsSingleRootFileSystem();
    public virtual StringComparer get_PathComparer();
    public virtual bool FileExists(string path);
    public virtual bool DirectoryExists(string path);
    public virtual Stream OpenFileStream(string path, FileMode mode, FileAccess access, FileShare share, int bufferSize);
    public virtual Stream OpenInputFileStream(string path, FileMode mode, FileAccess access, FileShare share, int bufferSize);
    public virtual Stream OpenOutputFileStream(string path);
    public virtual void DeleteFile(string path, bool deleteReadOnly);
    public String[] GetFiles(string path, string searchPattern);
    public String[] GetDirectories(string path, string searchPattern);
    public String[] GetFileSystemEntries(string path, string searchPattern);
    public virtual String[] GetFileSystemEntries(string path, string searchPattern, bool includeFiles, bool includeDirectories);
    public virtual string GetFullPath(string path);
    public virtual string CombinePaths(string path1, string path2);
    public virtual string GetFileName(string path);
    public virtual string GetDirectoryName(string path);
    public virtual string GetExtension(string path);
    public virtual string GetFileNameWithoutExtension(string path);
    public virtual bool IsAbsolutePath(string path);
    public virtual string get_CurrentDirectory();
    public virtual void set_CurrentDirectory(string value);
    public virtual void CreateDirectory(string path);
    public virtual void DeleteDirectory(string path, bool recursive);
    public virtual void MoveFileSystemEntry(string sourcePath, string destinationPath);
    public virtual string GetEnvironmentVariable(string key);
    public virtual void SetEnvironmentVariable(string key, string value);
    private static void SetEmptyEnvironmentVariable(string key);
    public virtual Dictionary`2<string, string> GetEnvironmentVariables();
}
[IsReadOnlyAttribute]
public class Microsoft.Scripting.Runtime.ContextId : ValueType {
    private static Dictionary`2<object, ContextId> _contexts;
    private static int _maxId;
    public static ContextId Empty;
    [CompilerGeneratedAttribute]
private int <Id>k__BackingField;
    public int Id { get; }
    internal ContextId(int id);
    private static ContextId();
    public static ContextId RegisterContext(object identifier);
    public static ContextId LookupContext(object identifier);
    [CompilerGeneratedAttribute]
public int get_Id();
    public sealed virtual bool Equals(ContextId other);
    public virtual int GetHashCode();
    public virtual bool Equals(object obj);
    public static bool op_Equality(ContextId self, ContextId other);
    public static bool op_Inequality(ContextId self, ContextId other);
}
internal class Microsoft.Scripting.Runtime.DictionaryExpandoMetaObject : DynamicMetaObject {
    private Func`3<object, string, object> _getMember;
    private Action`3<object, string, object> _setMember;
    private Func`3<object, string, bool> _deleteMember;
    private IEnumerable _keys;
    public DictionaryExpandoMetaObject(Expression parameter, object storage, IEnumerable keys, Func`3<object, string, object> getMember, Action`3<object, string, object> setMember, Func`3<object, string, bool> deleteMember);
    public virtual DynamicMetaObject BindGetMember(GetMemberBinder binder);
    public virtual DynamicMetaObject BindInvokeMember(InvokeMemberBinder binder, DynamicMetaObject[] args);
    private DynamicMetaObject DynamicTryGetMember(string name, Expression fallback, Func`2<Expression, Expression> resultOp);
    private BindingRestrictions GetRestrictions();
    public virtual DynamicMetaObject BindSetMember(SetMemberBinder binder, DynamicMetaObject value);
    public virtual DynamicMetaObject BindDeleteMember(DeleteMemberBinder binder);
    [IteratorStateMachineAttribute("Microsoft.Scripting.Runtime.DictionaryExpandoMetaObject/<GetDynamicMemberNames>d__11")]
public virtual IEnumerable`1<string> GetDynamicMemberNames();
}
public class Microsoft.Scripting.Runtime.DlrConfiguration : object {
    private bool _frozen;
    public static StringComparer FileExtensionComparer;
    public static StringComparer LanguageNameComparer;
    public static StringComparer OptionNameComparer;
    private Dictionary`2<string, LanguageConfiguration> _languageNames;
    private Dictionary`2<string, LanguageConfiguration> _languageExtensions;
    private Dictionary`2<AssemblyQualifiedTypeName, LanguageConfiguration> _languageConfigurations;
    private Dictionary`2<Type, LanguageConfiguration> _loadedProviderTypes;
    [CompilerGeneratedAttribute]
private bool <DebugMode>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <PrivateBinding>k__BackingField;
    [CompilerGeneratedAttribute]
private IDictionary`2<string, object> <Options>k__BackingField;
    public bool DebugMode { get; }
    public bool PrivateBinding { get; }
    internal IDictionary`2<string, object> Options { get; }
    internal IDictionary`2<AssemblyQualifiedTypeName, LanguageConfiguration> Languages { get; }
    public DlrConfiguration(bool debugMode, bool privateBinding, IDictionary`2<string, object> options);
    private static DlrConfiguration();
    [CompilerGeneratedAttribute]
public bool get_DebugMode();
    [CompilerGeneratedAttribute]
public bool get_PrivateBinding();
    [CompilerGeneratedAttribute]
internal IDictionary`2<string, object> get_Options();
    internal IDictionary`2<AssemblyQualifiedTypeName, LanguageConfiguration> get_Languages();
    public void AddLanguage(string languageTypeName, string displayName, IList`1<string> names, IList`1<string> fileExtensions, IDictionary`2<string, object> options);
    internal void AddLanguage(string languageTypeName, string displayName, IList`1<string> names, IList`1<string> fileExtensions, IDictionary`2<string, object> options, string paramName);
    internal static string NormalizeExtension(string extension);
    internal void Freeze();
    internal bool TryLoadLanguage(ScriptDomainManager manager, AssemblyQualifiedTypeName& providerName, LanguageContext& language);
    internal bool TryLoadLanguage(ScriptDomainManager manager, string str, bool isExtension, LanguageContext& language);
    private LanguageContext LoadLanguageContext(ScriptDomainManager manager, LanguageConfiguration config);
    public String[] GetLanguageNames(LanguageContext context);
    internal String[] GetLanguageNames(LanguageConfiguration config);
    public String[] GetLanguageNames();
    public String[] GetFileExtensions(LanguageContext context);
    internal String[] GetFileExtensions(LanguageConfiguration config);
    public String[] GetFileExtensions();
    internal LanguageConfiguration GetLanguageConfig(LanguageContext context);
    [CompilerGeneratedAttribute]
private bool <AddLanguage>b__21_0(string id);
    [CompilerGeneratedAttribute]
private bool <AddLanguage>b__21_1(string ext);
}
public abstract class Microsoft.Scripting.Runtime.DocumentationProvider : object {
    public abstract virtual ICollection`1<MemberDoc> GetMembers(object value);
    public abstract virtual ICollection`1<OverloadDoc> GetOverloads(object value);
}
public class Microsoft.Scripting.Runtime.DynamicOperations : object {
    private LanguageContext _lc;
    private Dictionary`2<SiteKey, SiteKey> _sites;
    private int LastCleanup;
    private int SitesCreated;
    private static int CleanupThreshold;
    private static int RemoveThreshold;
    private static int StopCleanupThreshold;
    private static int ClearThreshold;
    private Dictionary`2<int, Func`5<DynamicOperations, CallSiteBinder, object, Object[], object>> _invokers;
    private static int PregeneratedInvokerCount;
    public DynamicOperations(LanguageContext lc);
    public object Invoke(object obj, Object[] parameters);
    public object InvokeMember(object obj, string memberName, Object[] parameters);
    public object InvokeMember(object obj, string memberName, bool ignoreCase, Object[] parameters);
    public object CreateInstance(object obj, Object[] parameters);
    public object GetMember(object obj, string name);
    public T GetMember(object obj, string name);
    public bool TryGetMember(object obj, string name, Object& value);
    public bool ContainsMember(object obj, string name);
    public void RemoveMember(object obj, string name);
    public void SetMember(object obj, string name, object value);
    public void SetMember(object obj, string name, T value);
    public object GetMember(object obj, string name, bool ignoreCase);
    public T GetMember(object obj, string name, bool ignoreCase);
    public bool TryGetMember(object obj, string name, bool ignoreCase, Object& value);
    public bool ContainsMember(object obj, string name, bool ignoreCase);
    public void RemoveMember(object obj, string name, bool ignoreCase);
    public void SetMember(object obj, string name, object value, bool ignoreCase);
    public void SetMember(object obj, string name, T value, bool ignoreCase);
    public T ConvertTo(object obj);
    public object ConvertTo(object obj, Type type);
    public bool TryConvertTo(object obj, T& result);
    public bool TryConvertTo(object obj, Type type, Object& result);
    public T ExplicitConvertTo(object obj);
    public object ExplicitConvertTo(object obj, Type type);
    public bool TryExplicitConvertTo(object obj, Type type, Object& result);
    public bool TryExplicitConvertTo(object obj, T& result);
    public T ImplicitConvertTo(object obj);
    public object ImplicitConvertTo(object obj, Type type);
    public bool TryImplicitConvertTo(object obj, Type type, Object& result);
    public bool TryImplicitConvertTo(object obj, T& result);
    public TResult DoOperation(ExpressionType operation, TTarget target);
    public TResult DoOperation(ExpressionType operation, TTarget target, TOther other);
    public string GetDocumentation(object o);
    public IList`1<string> GetCallSignatures(object o);
    public bool IsCallable(object o);
    public IList`1<string> GetMemberNames(object obj);
    public string Format(object obj);
    public CallSite`1<Func`3<CallSite, T1, TResult>> GetOrCreateSite(CallSiteBinder siteBinder);
    public CallSite`1<Action`2<CallSite, T1>> GetOrCreateActionSite(CallSiteBinder siteBinder);
    public CallSite`1<Func`4<CallSite, T1, T2, TResult>> GetOrCreateSite(CallSiteBinder siteBinder);
    public CallSite`1<Func`5<CallSite, T1, T2, T3, TResult>> GetOrCreateSite(CallSiteBinder siteBinder);
    public CallSite`1<TSiteFunc> GetOrCreateSite(CallSiteBinder siteBinder);
    private T GetOrCreateSite(CallSiteBinder siteBinder, Func`2<CallSiteBinder, T> factory);
    private void CleanupNoLock();
    private Func`5<DynamicOperations, CallSiteBinder, object, Object[], object> GetInvoker(int paramCount);
    private Func`5<DynamicOperations, CallSiteBinder, object, Object[], object> EmitInvoker(int paramCount);
    private static Func`5<DynamicOperations, CallSiteBinder, object, Object[], object> GetPregeneratedInvoker(int paramCount);
}
public abstract class Microsoft.Scripting.Runtime.DynamicRuntimeHostingProvider : object {
    public PlatformAdaptationLayer PlatformAdaptationLayer { get; }
    public abstract virtual PlatformAdaptationLayer get_PlatformAdaptationLayer();
}
public class Microsoft.Scripting.Runtime.DynamicStackFrame : object {
    private string _funcName;
    private string _filename;
    private int _lineNo;
    private MethodBase _method;
    public DynamicStackFrame(MethodBase method, string funcName, string filename, int line);
    public MethodBase GetMethod();
    public string GetMethodName();
    public string GetFileName();
    public int GetFileLineNumber();
    public virtual string ToString();
}
internal class Microsoft.Scripting.Runtime.InvariantContext : LanguageContext {
    public bool CanCreateSourceCode { get; }
    internal InvariantContext(ScriptDomainManager manager);
    public virtual bool get_CanCreateSourceCode();
    public virtual ScriptCode CompileSourceCode(SourceUnit sourceUnit, CompilerOptions options, ErrorSink errorSink);
    public virtual T ScopeGetVariable(Scope scope, string name);
    public virtual object ScopeGetVariable(Scope scope, string name);
    public virtual void ScopeSetVariable(Scope scope, string name, object value);
    public virtual bool ScopeTryGetVariable(Scope scope, string name, Object& value);
}
internal class Microsoft.Scripting.Runtime.LanguageBoundTextContentProvider : TextContentProvider {
    private LanguageContext _context;
    private StreamContentProvider _streamProvider;
    private Encoding _defaultEncoding;
    private string _path;
    public LanguageBoundTextContentProvider(LanguageContext context, StreamContentProvider streamProvider, Encoding defaultEncoding, string path);
    public virtual SourceCodeReader GetReader();
}
internal class Microsoft.Scripting.Runtime.LanguageConfiguration : object {
    private IDictionary`2<string, object> _options;
    private LanguageContext _context;
    [CompilerGeneratedAttribute]
private AssemblyQualifiedTypeName <ProviderName>k__BackingField;
    [CompilerGeneratedAttribute]
private string <DisplayName>k__BackingField;
    public LanguageContext LanguageContext { get; }
    public AssemblyQualifiedTypeName ProviderName { get; }
    public string DisplayName { get; }
    public LanguageConfiguration(AssemblyQualifiedTypeName providerName, string displayName, IDictionary`2<string, object> options);
    public LanguageContext get_LanguageContext();
    [CompilerGeneratedAttribute]
public AssemblyQualifiedTypeName get_ProviderName();
    [CompilerGeneratedAttribute]
public string get_DisplayName();
    internal LanguageContext LoadLanguageContext(ScriptDomainManager domainManager, Boolean& alreadyLoaded);
}
public abstract class Microsoft.Scripting.Runtime.LanguageContext : object {
    private DynamicOperations _operations;
    [CompilerGeneratedAttribute]
private ContextId <ContextId>k__BackingField;
    [CompilerGeneratedAttribute]
private ScriptDomainManager <DomainManager>k__BackingField;
    [CompilerGeneratedAttribute]
private Encoding <DefaultEncoding>k__BackingField;
    public ContextId ContextId { get; }
    public ScriptDomainManager DomainManager { get; }
    public bool CanCreateSourceCode { get; }
    public Version LanguageVersion { get; }
    public Encoding DefaultEncoding { get; }
    public Guid LanguageGuid { get; }
    public Guid VendorGuid { get; }
    public LanguageOptions Options { get; }
    public DynamicOperations Operations { get; }
    protected LanguageContext(ScriptDomainManager domainManager);
    [CompilerGeneratedAttribute]
public ContextId get_ContextId();
    [CompilerGeneratedAttribute]
public ScriptDomainManager get_DomainManager();
    public virtual bool get_CanCreateSourceCode();
    public virtual Scope GetScope(string path);
    public virtual Scope CreateScope();
    public virtual Scope CreateScope(IDictionary`2<string, object> dictionary);
    public virtual Scope CreateScope(IDynamicMetaObjectProvider storage);
    public ScopeExtension EnsureScopeExtension(Scope scope);
    public virtual ScopeExtension CreateScopeExtension(Scope scope);
    public virtual void ScopeSetVariable(Scope scope, string name, object value);
    public virtual bool ScopeTryGetVariable(Scope scope, string name, Object& value);
    public virtual T ScopeGetVariable(Scope scope, string name);
    public virtual object ScopeGetVariable(Scope scope, string name);
    public virtual SourceCodeReader GetSourceReader(Stream stream, Encoding defaultEncoding, string path);
    public virtual CompilerOptions GetCompilerOptions();
    public virtual CompilerOptions GetCompilerOptions(Scope scope);
    public abstract virtual ScriptCode CompileSourceCode(SourceUnit sourceUnit, CompilerOptions options, ErrorSink errorSink);
    public virtual ScriptCode LoadCompiledCode(Delegate method, string path, string customData);
    public virtual int ExecuteProgram(SourceUnit program);
    public virtual Version get_LanguageVersion();
    public virtual void SetSearchPaths(ICollection`1<string> paths);
    public virtual ICollection`1<string> GetSearchPaths();
    public virtual SourceUnit GenerateSourceCode(CodeObject codeDom, string path, SourceCodeKind kind);
    public virtual TService GetService(Object[] args);
    [CompilerGeneratedAttribute]
public virtual Encoding get_DefaultEncoding();
    public virtual Guid get_LanguageGuid();
    public virtual Guid get_VendorGuid();
    public virtual void Shutdown();
    public virtual string FormatException(Exception exception);
    public virtual IList`1<DynamicStackFrame> GetStackFrames(Exception exception);
    public virtual LanguageOptions get_Options();
    public SourceUnit CreateSnippet(string code, SourceCodeKind kind);
    public SourceUnit CreateSnippet(string code, string id, SourceCodeKind kind);
    public SourceUnit CreateFileUnit(string path);
    public SourceUnit CreateFileUnit(string path, Encoding encoding);
    public SourceUnit CreateFileUnit(string path, Encoding encoding, SourceCodeKind kind);
    public SourceUnit CreateFileUnit(string path, string content);
    public SourceUnit CreateSourceUnit(StreamContentProvider contentProvider, string path, Encoding encoding, SourceCodeKind kind);
    public SourceUnit CreateSourceUnit(TextContentProvider contentProvider, string path, SourceCodeKind kind);
    public virtual ErrorSink GetCompilerErrorSink();
    internal static DynamicMetaObject ErrorMetaObject(Type resultType, DynamicMetaObject target, DynamicMetaObject[] args, DynamicMetaObject errorSuggestion);
    public virtual UnaryOperationBinder CreateUnaryOperationBinder(ExpressionType operation);
    public virtual BinaryOperationBinder CreateBinaryOperationBinder(ExpressionType operation);
    public virtual ConvertBinder CreateConvertBinder(Type toType, Nullable`1<bool> explicitCast);
    public virtual GetMemberBinder CreateGetMemberBinder(string name, bool ignoreCase);
    public virtual SetMemberBinder CreateSetMemberBinder(string name, bool ignoreCase);
    public virtual DeleteMemberBinder CreateDeleteMemberBinder(string name, bool ignoreCase);
    public virtual InvokeMemberBinder CreateCallBinder(string name, bool ignoreCase, CallInfo callInfo);
    public virtual InvokeBinder CreateInvokeBinder(CallInfo callInfo);
    public virtual CreateInstanceBinder CreateCreateBinder(CallInfo callInfo);
    public DynamicOperations get_Operations();
    public virtual IList`1<string> GetMemberNames(object obj);
    public virtual string GetDocumentation(object obj);
    public virtual IList`1<string> GetCallSignatures(object obj);
    public virtual bool IsCallable(object obj);
    public virtual string FormatObject(DynamicOperations operations, object obj);
    public virtual void GetExceptionMessage(Exception exception, String& message, String& errorTypeName);
}
[AttributeUsageAttribute("2048")]
public class Microsoft.Scripting.Runtime.NotNullAttribute : Attribute {
}
[AttributeUsageAttribute("2048")]
public class Microsoft.Scripting.Runtime.NotNullItemsAttribute : Attribute {
}
public class Microsoft.Scripting.Runtime.ObjectDictionaryExpando : object {
    private IDictionary`2<object, object> _data;
    public IDictionary`2<object, object> Dictionary { get; }
    public ObjectDictionaryExpando(IDictionary`2<object, object> dictionary);
    public IDictionary`2<object, object> get_Dictionary();
    private static object TryGetMember(object adapter, string name);
    private static void TrySetMember(object adapter, string name, object value);
    private static bool TryDeleteMember(object adapter, string name);
    private sealed virtual override DynamicMetaObject System.Dynamic.IDynamicMetaObjectProvider.GetMetaObject(Expression parameter);
}
public class Microsoft.Scripting.Runtime.ParserSink : object {
    public static ParserSink Null;
    private static ParserSink();
    public virtual void MatchPair(SourceSpan opening, SourceSpan closing, int priority);
    public virtual void MatchTriple(SourceSpan opening, SourceSpan middle, SourceSpan closing, int priority);
    public virtual void EndParameters(SourceSpan span);
    public virtual void NextParameter(SourceSpan span);
    public virtual void QualifyName(SourceSpan selector, SourceSpan span, string name);
    public virtual void StartName(SourceSpan span, string name);
    public virtual void StartParameters(SourceSpan context);
}
public class Microsoft.Scripting.Runtime.Scope : object {
    private ScopeExtension[] _extensions;
    private object _extensionsLock;
    private IDynamicMetaObjectProvider _storage;
    [DynamicAttribute]
public object Storage { get; }
    public Scope(IDictionary`2<string, object> dictionary);
    public Scope(IDynamicMetaObjectProvider storage);
    public ScopeExtension GetExtension(ContextId languageContextId);
    public ScopeExtension SetExtension(ContextId languageContextId, ScopeExtension extension);
    public object get_Storage();
    private sealed virtual override DynamicMetaObject System.Dynamic.IDynamicMetaObjectProvider.GetMetaObject(Expression parameter);
}
public class Microsoft.Scripting.Runtime.ScopeExtension : object {
    public static ScopeExtension[] EmptyArray;
    [CompilerGeneratedAttribute]
private Scope <Scope>k__BackingField;
    public Scope Scope { get; }
    public ScopeExtension(Scope scope);
    private static ScopeExtension();
    [CompilerGeneratedAttribute]
public Scope get_Scope();
}
public class Microsoft.Scripting.Runtime.ScriptDomainManager : object {
    private List`1<Assembly> _loadedAssemblies;
    private int _lastContextId;
    [CompilerGeneratedAttribute]
private SharedIO <SharedIO>k__BackingField;
    [CompilerGeneratedAttribute]
private DynamicRuntimeHostingProvider <Host>k__BackingField;
    [CompilerGeneratedAttribute]
private DlrConfiguration <Configuration>k__BackingField;
    [CompilerGeneratedAttribute]
private Scope <Globals>k__BackingField;
    [CompilerGeneratedAttribute]
private EventHandler`1<AssemblyLoadedEventArgs> AssemblyLoaded;
    public PlatformAdaptationLayer Platform { get; }
    public SharedIO SharedIO { get; }
    public DynamicRuntimeHostingProvider Host { get; }
    public DlrConfiguration Configuration { get; }
    public Scope Globals { get; public set; }
    public ScriptDomainManager(DynamicRuntimeHostingProvider hostingProvider, DlrConfiguration configuration);
    public PlatformAdaptationLayer get_Platform();
    [CompilerGeneratedAttribute]
public SharedIO get_SharedIO();
    [CompilerGeneratedAttribute]
public DynamicRuntimeHostingProvider get_Host();
    [CompilerGeneratedAttribute]
public DlrConfiguration get_Configuration();
    internal ContextId GenerateContextId();
    public LanguageContext GetLanguage(Type providerType);
    public LanguageContext GetLanguageByTypeName(string providerAssemblyQualifiedTypeName);
    public bool TryGetLanguage(string languageName, LanguageContext& language);
    public LanguageContext GetLanguageByName(string languageName);
    public bool TryGetLanguageByFileExtension(string fileExtension, LanguageContext& language);
    public LanguageContext GetLanguageByExtension(string fileExtension);
    [CompilerGeneratedAttribute]
public Scope get_Globals();
    [CompilerGeneratedAttribute]
public void set_Globals(Scope value);
    [CompilerGeneratedAttribute]
public void add_AssemblyLoaded(EventHandler`1<AssemblyLoadedEventArgs> value);
    [CompilerGeneratedAttribute]
public void remove_AssemblyLoaded(EventHandler`1<AssemblyLoadedEventArgs> value);
    public bool LoadAssembly(Assembly assembly);
    public IList`1<Assembly> GetLoadedAssemblyList();
}
public class Microsoft.Scripting.Runtime.SharedIO : object {
    private object _mutex;
    private Stream _inputStream;
    private Stream _outputStream;
    private Stream _errorStream;
    private TextReader _inputReader;
    private TextWriter _outputWriter;
    private TextWriter _errorWriter;
    private Encoding _inputEncoding;
    public Stream InputStream { get; }
    public Stream OutputStream { get; }
    public Stream ErrorStream { get; }
    public TextReader InputReader { get; }
    public TextWriter OutputWriter { get; }
    public TextWriter ErrorWriter { get; }
    public Encoding InputEncoding { get; }
    public Encoding OutputEncoding { get; }
    public Encoding ErrorEncoding { get; }
    public Stream get_InputStream();
    public Stream get_OutputStream();
    public Stream get_ErrorStream();
    public TextReader get_InputReader();
    public TextWriter get_OutputWriter();
    public TextWriter get_ErrorWriter();
    public Encoding get_InputEncoding();
    public Encoding get_OutputEncoding();
    public Encoding get_ErrorEncoding();
    private void InitializeInput();
    private void InitializeOutput();
    private void InitializeErrorOutput();
    public void SetOutput(Stream stream, TextWriter writer);
    public void SetErrorOutput(Stream stream, TextWriter writer);
    public void SetInput(Stream stream, TextReader reader, Encoding encoding);
    public void RedirectToConsole();
    public Stream GetStream(ConsoleStreamType type);
    public TextWriter GetWriter(ConsoleStreamType type);
    public Encoding GetEncoding(ConsoleStreamType type);
    public TextReader GetReader(Encoding& encoding);
    public Stream GetStreamProxy(ConsoleStreamType type);
}
public class Microsoft.Scripting.Runtime.StringDictionaryExpando : object {
    private IDictionary`2<string, object> _data;
    internal static object _getFailed;
    public IDictionary`2<string, object> Dictionary { get; }
    public StringDictionaryExpando(IDictionary`2<string, object> data);
    private static StringDictionaryExpando();
    public IDictionary`2<string, object> get_Dictionary();
    private static object TryGetMember(object adapter, string name);
    private static void TrySetMember(object adapter, string name, object value);
    private static bool TryDeleteMember(object adapter, string name);
    private sealed virtual override DynamicMetaObject System.Dynamic.IDynamicMetaObjectProvider.GetMetaObject(Expression parameter);
}
public abstract class Microsoft.Scripting.Runtime.TokenizerService : object {
    public object CurrentState { get; }
    public SourceLocation CurrentPosition { get; }
    public bool IsRestartable { get; }
    public ErrorSink ErrorSink { get; public set; }
    public abstract virtual void Initialize(object state, TextReader sourceReader, SourceUnit sourceUnit, SourceLocation initialLocation);
    public abstract virtual object get_CurrentState();
    public abstract virtual SourceLocation get_CurrentPosition();
    public abstract virtual TokenInfo ReadToken();
    public abstract virtual bool get_IsRestartable();
    public abstract virtual ErrorSink get_ErrorSink();
    public abstract virtual void set_ErrorSink(ErrorSink value);
    public virtual bool SkipToken();
    public IEnumerable`1<TokenInfo> ReadTokens(int characterCount);
    public bool SkipTokens(int countOfChars);
}
[DefaultMemberAttribute("Item")]
public class Microsoft.Scripting.ScopeStorage : object {
    private Dictionary`2<string, ScopeVariableIgnoreCase> _storage;
    [DynamicAttribute]
public object Item { get; public set; }
    public object GetValue(string name, bool ignoreCase);
    public bool TryGetValue(string name, bool ignoreCase, Object& value);
    public void SetValue(string name, bool ignoreCase, object value);
    public bool DeleteValue(string name, bool ignoreCase);
    public bool HasValue(string name, bool ignoreCase);
    public IScopeVariable GetScopeVariable(string name, bool ignoreCase);
    public ScopeVariable GetScopeVariable(string name);
    public ScopeVariableIgnoreCase GetScopeVariableIgnoreCase(string name);
    public object get_Item(string index);
    public void set_Item(string index, object value);
    public IList`1<string> GetMemberNames();
    public IList`1<KeyValuePair`2<string, object>> GetItems();
    private bool HasVariable(string name);
    public sealed virtual DynamicMetaObject GetMetaObject(Expression parameter);
    [CompilerGeneratedAttribute]
private bool <TryGetValue>g__TryGetScopeVariable|2_0(IScopeVariable& scopeVariable, <>c__DisplayClass2_0& );
}
public class Microsoft.Scripting.ScopeVariable : object {
    private object _value;
    private WeakReference _weakref;
    private static object _novalue;
    public bool HasValue { get; }
    public WeakReference WeakReference { get; }
    private static ScopeVariable();
    public sealed virtual bool get_HasValue();
    public sealed virtual bool TryGetValue(Object& value);
    public sealed virtual void SetValue(object value);
    public sealed virtual bool DeleteValue();
    public sealed virtual WeakReference get_WeakReference();
}
public class Microsoft.Scripting.ScopeVariableIgnoreCase : object {
    private string _firstCasing;
    private ScopeVariable _firstVariable;
    private WeakReference _weakref;
    private Dictionary`2<string, ScopeVariable> _overflow;
    public bool HasValue { get; }
    public WeakReference WeakReference { get; }
    internal ScopeVariableIgnoreCase(string casing);
    public sealed virtual bool get_HasValue();
    public sealed virtual bool TryGetValue(Object& value);
    public sealed virtual void SetValue(object value);
    public sealed virtual bool DeleteValue();
    internal ScopeVariable GetCaseSensitiveStorage(string name);
    internal void AddNames(List`1<string> list);
    internal void AddItems(List`1<KeyValuePair`2<string, object>> list);
    private ScopeVariable GetStorageSlow(string name);
    public sealed virtual WeakReference get_WeakReference();
}
public abstract class Microsoft.Scripting.ScriptCode : object {
    [CompilerGeneratedAttribute]
private SourceUnit <SourceUnit>k__BackingField;
    public LanguageContext LanguageContext { get; }
    public SourceUnit SourceUnit { get; }
    protected ScriptCode(SourceUnit sourceUnit);
    public LanguageContext get_LanguageContext();
    [CompilerGeneratedAttribute]
public SourceUnit get_SourceUnit();
    public virtual Scope CreateScope();
    public virtual object Run();
    public abstract virtual object Run(Scope scope);
    public virtual string ToString();
}
public enum Microsoft.Scripting.ScriptCodeParseResult : Enum {
    public int value__;
    public static ScriptCodeParseResult Complete;
    public static ScriptCodeParseResult Empty;
    public static ScriptCodeParseResult Invalid;
    public static ScriptCodeParseResult IncompleteToken;
    public static ScriptCodeParseResult IncompleteStatement;
}
public enum Microsoft.Scripting.Severity : Enum {
    public int value__;
    public static Severity Ignore;
    public static Severity Warning;
    public static Severity Error;
    public static Severity FatalError;
}
public enum Microsoft.Scripting.SourceCodeKind : Enum {
    public int value__;
    [EditorBrowsableAttribute("1")]
public static SourceCodeKind Unspecified;
    public static SourceCodeKind Expression;
    public static SourceCodeKind Statements;
    public static SourceCodeKind SingleStatement;
    public static SourceCodeKind File;
    public static SourceCodeKind InteractiveCode;
    public static SourceCodeKind AutoDetect;
}
public static class Microsoft.Scripting.SourceCodePropertiesUtils : object {
    public static bool IsCompleteOrInvalid(ScriptCodeParseResult props, bool allowIncompleteStatement);
}
public class Microsoft.Scripting.SourceCodeReader : TextReader {
    public static SourceCodeReader Null;
    [CompilerGeneratedAttribute]
private Encoding <Encoding>k__BackingField;
    [CompilerGeneratedAttribute]
private TextReader <BaseReader>k__BackingField;
    public Encoding Encoding { get; }
    public TextReader BaseReader { get; }
    public SourceCodeReader(TextReader textReader, Encoding encoding);
    private static SourceCodeReader();
    [CompilerGeneratedAttribute]
public Encoding get_Encoding();
    [CompilerGeneratedAttribute]
public TextReader get_BaseReader();
    public virtual string ReadLine();
    public virtual bool SeekLine(int line);
    public virtual string ReadToEnd();
    public virtual int Read(Char[] buffer, int index, int count);
    public virtual int Peek();
    public virtual int Read();
    protected virtual void Dispose(bool disposing);
}
[IsReadOnlyAttribute]
public class Microsoft.Scripting.SourceLocation : ValueType {
    [CompilerGeneratedAttribute]
private int <Index>k__BackingField;
    [CompilerGeneratedAttribute]
private int <Line>k__BackingField;
    [CompilerGeneratedAttribute]
private int <Column>k__BackingField;
    public static SourceLocation None;
    public static SourceLocation Invalid;
    public static SourceLocation MinValue;
    public int Index { get; }
    public int Line { get; }
    public int Column { get; }
    public bool IsValid { get; }
    public SourceLocation(int index, int line, int column);
    private SourceLocation(int index, int line, int column, bool noChecks);
    private static SourceLocation();
    private static void ValidateLocation(int index, int line, int column);
    private static Exception ErrorOutOfRange(object p0, object p1);
    [CompilerGeneratedAttribute]
public int get_Index();
    [CompilerGeneratedAttribute]
public int get_Line();
    [CompilerGeneratedAttribute]
public int get_Column();
    public static bool op_Equality(SourceLocation left, SourceLocation right);
    public static bool op_Inequality(SourceLocation left, SourceLocation right);
    public static bool op_LessThan(SourceLocation left, SourceLocation right);
    public static bool op_GreaterThan(SourceLocation left, SourceLocation right);
    public static bool op_LessThanOrEqual(SourceLocation left, SourceLocation right);
    public static bool op_GreaterThanOrEqual(SourceLocation left, SourceLocation right);
    public static int Compare(SourceLocation left, SourceLocation right);
    public bool get_IsValid();
    public sealed virtual bool Equals(SourceLocation other);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public virtual string ToString();
    internal string ToDebugString();
}
[IsReadOnlyAttribute]
public class Microsoft.Scripting.SourceSpan : ValueType {
    [CompilerGeneratedAttribute]
private SourceLocation <Start>k__BackingField;
    [CompilerGeneratedAttribute]
private SourceLocation <End>k__BackingField;
    public static SourceSpan None;
    public static SourceSpan Invalid;
    public SourceLocation Start { get; }
    public SourceLocation End { get; }
    public int Length { get; }
    public bool IsValid { get; }
    public SourceSpan(SourceLocation start, SourceLocation end);
    private static SourceSpan();
    private static void ValidateLocations(SourceLocation& start, SourceLocation& end);
    [CompilerGeneratedAttribute]
public SourceLocation get_Start();
    [CompilerGeneratedAttribute]
public SourceLocation get_End();
    public int get_Length();
    public bool get_IsValid();
    public static bool op_Equality(SourceSpan left, SourceSpan right);
    public static bool op_Inequality(SourceSpan left, SourceSpan right);
    public sealed virtual bool Equals(SourceSpan other);
    public virtual bool Equals(object obj);
    public virtual string ToString();
    public virtual int GetHashCode();
    internal string ToDebugString();
}
internal class Microsoft.Scripting.SourceStringContentProvider : TextContentProvider {
    private string _code;
    internal SourceStringContentProvider(string code);
    public virtual SourceCodeReader GetReader();
}
[DebuggerDisplayAttribute("{DebugString}")]
public class Microsoft.Scripting.SourceUnit : object {
    private LanguageContext _language;
    private TextContentProvider _contentProvider;
    private Nullable`1<ScriptCodeParseResult> _parseResult;
    private KeyValuePair`2[] _lineMap;
    [CompilerGeneratedAttribute]
private string <Path>k__BackingField;
    [CompilerGeneratedAttribute]
private SourceCodeKind <Kind>k__BackingField;
    public string Path { get; }
    private string DebugString { get; }
    public bool HasPath { get; }
    public SourceCodeKind Kind { get; }
    public SymbolDocumentInfo Document { get; }
    public LanguageContext LanguageContext { get; }
    public Nullable`1<ScriptCodeParseResult> CodeProperties { get; public set; }
    public bool HasLineMapping { get; }
    public bool EmitDebugSymbols { get; }
    public SourceUnit(LanguageContext context, TextContentProvider contentProvider, string path, SourceCodeKind kind);
    [CompilerGeneratedAttribute]
public string get_Path();
    private string get_DebugString();
    public bool get_HasPath();
    [CompilerGeneratedAttribute]
public SourceCodeKind get_Kind();
    public SymbolDocumentInfo get_Document();
    public LanguageContext get_LanguageContext();
    public ScriptCodeParseResult GetCodeProperties();
    public ScriptCodeParseResult GetCodeProperties(CompilerOptions options);
    public Nullable`1<ScriptCodeParseResult> get_CodeProperties();
    public void set_CodeProperties(Nullable`1<ScriptCodeParseResult> value);
    public SourceCodeReader GetReader();
    public String[] GetCodeLines(int start, int count);
    public string GetCodeLine(int line);
    public string GetCode();
    public SourceLocation MakeLocation(int index, int line, int column);
    public SourceLocation MakeLocation(SourceLocation loc);
    public int MapLine(int line);
    public bool get_HasLineMapping();
    private static int BinarySearch(KeyValuePair`2[] array, int line);
    public bool get_EmitDebugSymbols();
    public ScriptCode Compile();
    public ScriptCode Compile(ErrorSink errorSink);
    public ScriptCode Compile(CompilerOptions options, ErrorSink errorSink);
    public object Execute(Scope scope);
    public object Execute(Scope scope, ErrorSink errorSink);
    public object Execute();
    public object Execute(ErrorSink errorSink);
    public object Execute(CompilerOptions options, ErrorSink errorSink);
    public int ExecuteProgram();
    public void SetLineMapping(KeyValuePair`2[] lineMap);
}
public abstract class Microsoft.Scripting.StreamContentProvider : object {
    public abstract virtual Stream GetStream();
}
internal static class Microsoft.Scripting.Strings : object {
    internal static string MethodPreconditionViolated { get; }
    internal static string InvalidArgumentValue { get; }
    internal static string NonEmptyStringRequired { get; }
    internal static string NonEmptyCollectionRequired { get; }
    internal static string MustBeExceptionInstance { get; }
    internal static string TypeOfTestMustBeBool { get; }
    internal static string TypeOfExpressionMustBeBool { get; }
    internal static string EmptyStringIsInvalidPath { get; }
    internal static string InvalidDelegate { get; }
    internal static string ExpectedStaticProperty { get; }
    internal static string PropertyDoesNotExist { get; }
    internal static string FieldDoesNotExist { get; }
    internal static string TypeDoesNotHaveConstructorForTheSignature { get; }
    internal static string TypeDoesNotHaveMethodForName { get; }
    internal static string TypeDoesNotHaveMethodForNameSignature { get; }
    internal static string CountCannotBeNegative { get; }
    internal static string ArrayTypeMustBeArray { get; }
    internal static string MustHaveCodeOrTarget { get; }
    internal static string FirstArgumentMustBeCallSite { get; }
    internal static string NoInstanceForCall { get; }
    internal static string MissingTest { get; }
    internal static string MissingTarget { get; }
    internal static string FinallyAlreadyDefined { get; }
    internal static string CannotHaveFaultAndFinally { get; }
    internal static string FaultAlreadyDefined { get; }
    internal static string GlobalsMustBeUnique { get; }
    internal static string GenNonSerializableBinder { get; }
    internal static string InvalidPath { get; }
    internal static string DictionaryNotHashable { get; }
    internal static string LanguageRegistered { get; }
    internal static string MethodOrOperatorNotImplemented { get; }
    internal static string NoException { get; }
    internal static string AlreadyInitialized { get; }
    internal static string MustReturnScopeExtension { get; }
    internal static string InvalidParamNumForService { get; }
    internal static string CannotChangeNonCachingValue { get; }
    internal static string NoCodeToCompile { get; }
    internal static string QueueEmpty { get; }
    internal static string EnumerationNotStarted { get; }
    internal static string EnumerationFinished { get; }
    internal static string InvalidOutputDir { get; }
    internal static string InvalidAsmNameOrExtension { get; }
    internal static string NoDefaultValue { get; }
    internal static string UnknownLanguageProviderType { get; }
    internal static string CantReadProperty { get; }
    internal static string CantWriteProperty { get; }
    private static string FormatString(string format, Object[] args);
    internal static string InvalidOperation_ContainsGenericParameters(object p0, object p1);
    internal static string MissingType(object p0);
    internal static string StaticAccessFromInstanceError(object p0, object p1);
    internal static string StaticAssignmentFromInstanceError(object p0, object p1);
    internal static string get_MethodPreconditionViolated();
    internal static string get_InvalidArgumentValue();
    internal static string get_NonEmptyStringRequired();
    internal static string get_NonEmptyCollectionRequired();
    internal static string get_MustBeExceptionInstance();
    internal static string get_TypeOfTestMustBeBool();
    internal static string get_TypeOfExpressionMustBeBool();
    internal static string get_EmptyStringIsInvalidPath();
    internal static string get_InvalidDelegate();
    internal static string get_ExpectedStaticProperty();
    internal static string get_PropertyDoesNotExist();
    internal static string get_FieldDoesNotExist();
    internal static string get_TypeDoesNotHaveConstructorForTheSignature();
    internal static string get_TypeDoesNotHaveMethodForName();
    internal static string get_TypeDoesNotHaveMethodForNameSignature();
    internal static string get_CountCannotBeNegative();
    internal static string get_ArrayTypeMustBeArray();
    internal static string get_MustHaveCodeOrTarget();
    internal static string TypeParameterIsNotDelegate(object p0);
    internal static string InvalidCast(object p0, object p1);
    internal static string UnknownMemberType(object p0);
    internal static string get_FirstArgumentMustBeCallSite();
    internal static string get_NoInstanceForCall();
    internal static string get_MissingTest();
    internal static string get_MissingTarget();
    internal static string NonGenericWithGenericGroup(object p0);
    internal static string InvalidOperation(object p0);
    internal static string get_FinallyAlreadyDefined();
    internal static string get_CannotHaveFaultAndFinally();
    internal static string get_FaultAlreadyDefined();
    internal static string CantCreateDefaultTypeFor(object p0);
    internal static string UnhandledConvert(object p0);
    internal static string NoCallableMethods(object p0, object p1);
    internal static string get_GlobalsMustBeUnique();
    internal static string get_GenNonSerializableBinder();
    internal static string get_InvalidPath();
    internal static string get_DictionaryNotHashable();
    internal static string get_LanguageRegistered();
    internal static string get_MethodOrOperatorNotImplemented();
    internal static string get_NoException();
    internal static string ExtensionMustBePublic(object p0);
    internal static string get_AlreadyInitialized();
    internal static string get_MustReturnScopeExtension();
    internal static string get_InvalidParamNumForService();
    internal static string InvalidArgumentType(object p0, object p1);
    internal static string get_CannotChangeNonCachingValue();
    internal static string FieldReadonly(object p0);
    internal static string PropertyReadonly(object p0);
    internal static string UnexpectedEvent(object p0, object p1, object p2, object p3);
    internal static string ExpectedBoundEvent(object p0);
    internal static string UnexpectedType(object p0, object p1);
    internal static string MemberWriteOnly(object p0);
    internal static string get_NoCodeToCompile();
    internal static string InvalidStreamType(object p0);
    internal static string get_QueueEmpty();
    internal static string get_EnumerationNotStarted();
    internal static string get_EnumerationFinished();
    internal static string CantAddCasing(object p0);
    internal static string CantAddIdentifier(object p0);
    internal static string InvalidCtorImplementation(object p0, object p1);
    internal static string get_InvalidOutputDir();
    internal static string get_InvalidAsmNameOrExtension();
    internal static string CanotEmitConstant(object p0, object p1);
    internal static string NoImplicitCast(object p0, object p1);
    internal static string NoExplicitCast(object p0, object p1);
    internal static string NameNotDefined(object p0);
    internal static string get_NoDefaultValue();
    internal static string get_UnknownLanguageProviderType();
    internal static string get_CantReadProperty();
    internal static string get_CantWriteProperty();
    internal static string IllegalNew_GenericParams(object p0);
    internal static string VerificationException(object p0, object p1, object p2);
}
public class Microsoft.Scripting.SyntaxErrorException : Exception {
    private SourceSpan _span;
    private string _sourceCode;
    private string _sourceLine;
    private string _sourcePath;
    private Severity _severity;
    private int _errorCode;
    public SourceSpan RawSpan { get; }
    public string SourceCode { get; }
    public string SourcePath { get; }
    public Severity Severity { get; }
    public int Line { get; }
    public int Column { get; }
    public int ErrorCode { get; }
    public SyntaxErrorException(string message);
    public SyntaxErrorException(string message, Exception innerException);
    public SyntaxErrorException(string message, SourceUnit sourceUnit, SourceSpan span, int errorCode, Severity severity);
    public SyntaxErrorException(string message, string path, string code, string line, SourceSpan span, int errorCode, Severity severity);
    protected SyntaxErrorException(SerializationInfo info, StreamingContext context);
    [SecurityCriticalAttribute]
public virtual void GetObjectData(SerializationInfo info, StreamingContext context);
    public SourceSpan get_RawSpan();
    public string get_SourceCode();
    public string get_SourcePath();
    public Severity get_Severity();
    public int get_Line();
    public int get_Column();
    public int get_ErrorCode();
    public string GetSymbolDocumentName();
    public string GetCodeLine();
}
public abstract class Microsoft.Scripting.TextContentProvider : object {
    public abstract virtual SourceCodeReader GetReader();
}
public enum Microsoft.Scripting.TokenCategory : Enum {
    public int value__;
    public static TokenCategory None;
    public static TokenCategory EndOfStream;
    public static TokenCategory WhiteSpace;
    public static TokenCategory Comment;
    public static TokenCategory LineComment;
    public static TokenCategory DocComment;
    public static TokenCategory NumericLiteral;
    public static TokenCategory CharacterLiteral;
    public static TokenCategory StringLiteral;
    public static TokenCategory RegularExpressionLiteral;
    public static TokenCategory Keyword;
    public static TokenCategory Directive;
    public static TokenCategory Operator;
    public static TokenCategory Delimiter;
    public static TokenCategory Identifier;
    public static TokenCategory Grouping;
    public static TokenCategory Error;
    public static TokenCategory LanguageDefined;
}
public class Microsoft.Scripting.TokenInfo : ValueType {
    [CompilerGeneratedAttribute]
private TokenCategory <Category>k__BackingField;
    [CompilerGeneratedAttribute]
private TokenTriggers <Trigger>k__BackingField;
    [CompilerGeneratedAttribute]
private SourceSpan <SourceSpan>k__BackingField;
    public TokenCategory Category { get; public set; }
    public TokenTriggers Trigger { get; public set; }
    public SourceSpan SourceSpan { get; public set; }
    public TokenInfo(SourceSpan span, TokenCategory category, TokenTriggers trigger);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public TokenCategory get_Category();
    [CompilerGeneratedAttribute]
public void set_Category(TokenCategory value);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public TokenTriggers get_Trigger();
    [CompilerGeneratedAttribute]
public void set_Trigger(TokenTriggers value);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public SourceSpan get_SourceSpan();
    [CompilerGeneratedAttribute]
public void set_SourceSpan(SourceSpan value);
    public static bool op_Equality(TokenInfo first, TokenInfo second);
    public static bool op_Inequality(TokenInfo first, TokenInfo second);
    public virtual int GetHashCode();
    public virtual bool Equals(object obj);
    public sealed virtual bool Equals(TokenInfo other);
    public virtual string ToString();
}
public enum Microsoft.Scripting.TokenKind : Enum {
    public int value__;
    public static TokenKind Default;
    public static TokenKind Error;
    public static TokenKind Whitespace;
    public static TokenKind EndOfLine;
    public static TokenKind LineJoin;
    public static TokenKind Indentation;
    public static TokenKind SingleLineComment;
    public static TokenKind MultiLineComment;
    public static TokenKind NestableCommentStart;
    public static TokenKind NestableCommentEnd;
    public static TokenKind SingleLineDocComment;
    public static TokenKind MultiLineDocComment;
    public static TokenKind Directive;
    public static TokenKind Keyword;
    public static TokenKind Identifier;
    public static TokenKind VerbatimIdentifier;
    public static TokenKind Variable;
    public static TokenKind IntegerLiteral;
    public static TokenKind FloatLiteral;
    public static TokenKind CharacterLiteral;
    public static TokenKind String;
    public static TokenKind UnicodeString;
    public static TokenKind FormattedString;
    public static TokenKind FormattedUnicodeString;
    public static TokenKind LeftParenthesis;
    public static TokenKind RightParenthesis;
    public static TokenKind LeftBracket;
    public static TokenKind RightBracket;
    public static TokenKind LeftBrace;
    public static TokenKind RightBrace;
    public static TokenKind Comma;
    public static TokenKind Dot;
    public static TokenKind Semicolon;
    public static TokenKind Colon;
    public static TokenKind DoubleColon;
    public static TokenKind TripleColon;
    public static TokenKind Plus;
    public static TokenKind PlusPlus;
    public static TokenKind PlusEqual;
    public static TokenKind Minus;
    public static TokenKind MinusMinus;
    public static TokenKind MinusEqual;
    public static TokenKind Mul;
    public static TokenKind MulEqual;
    public static TokenKind Div;
    public static TokenKind DivEqual;
    public static TokenKind FloorDivide;
    public static TokenKind FloorDivideEqual;
    public static TokenKind Mod;
    public static TokenKind ModEqual;
    public static TokenKind Power;
    public static TokenKind PowerEqual;
    public static TokenKind LeftShift;
    public static TokenKind LeftShiftEqual;
    public static TokenKind RightShift;
    public static TokenKind RightShiftEqual;
    public static TokenKind BitwiseAnd;
    public static TokenKind BitwiseAndEqual;
    public static TokenKind BitwiseOr;
    public static TokenKind BitwiseOrEqual;
    public static TokenKind Xor;
    public static TokenKind XorEqual;
    public static TokenKind BooleanAnd;
    public static TokenKind BooleanAndEqual;
    public static TokenKind BooleanOr;
    public static TokenKind BooleanOrEqual;
    public static TokenKind Twiddle;
    public static TokenKind TwiddleEqual;
    public static TokenKind LessThan;
    public static TokenKind GreaterThan;
    public static TokenKind LessThanOrEqual;
    public static TokenKind GreaterThanOrEqual;
    public static TokenKind Assign;
    public static TokenKind AssignAlias;
    public static TokenKind AssignColon;
    public static TokenKind Equal;
    public static TokenKind StrictEqual;
    public static TokenKind Not;
    public static TokenKind NotEqual;
    public static TokenKind StrictNotEqual;
    public static TokenKind Unequal;
    public static TokenKind CompareEqual;
    public static TokenKind Match;
    public static TokenKind NotMatch;
    public static TokenKind Arrow;
    public static TokenKind DoubleArrow;
    public static TokenKind BackQuote;
    public static TokenKind DoubleDot;
    public static TokenKind TripleDot;
    public static TokenKind At;
    public static TokenKind DoubleAt;
    public static TokenKind Question;
    public static TokenKind DoubleQuestion;
    public static TokenKind Backslash;
    public static TokenKind DoubleBackslash;
    public static TokenKind Dollar;
    public static TokenKind DoubleDollar;
    public static TokenKind LanguageDefined;
}
[FlagsAttribute]
public enum Microsoft.Scripting.TokenTriggers : Enum {
    public int value__;
    public static TokenTriggers None;
    public static TokenTriggers MemberSelect;
    public static TokenTriggers MatchBraces;
    public static TokenTriggers ParameterStart;
    public static TokenTriggers ParameterNext;
    public static TokenTriggers ParameterEnd;
    public static TokenTriggers Parameter;
    public static TokenTriggers MethodTip;
}
[ExtensionAttribute]
internal static class Microsoft.Scripting.Utils.ArrayUtils : object {
    public static String[] EmptyStrings;
    public static Object[] EmptyObjects;
    private static ArrayUtils();
    public static IComparer`1<T> ToComparer(Comparison`1<T> comparison);
    public static void PrintTable(StringBuilder output, String[0...,0...] table);
    public static T[] Copy(T[] array);
    public static T[] MakeArray(ICollection`1<T> list);
    public static T[] MakeArray(ICollection`1<T> elements, int reservedSlotsBefore, int reservedSlotsAfter);
    public static T[] RotateRight(T[] array, int count);
    public static T[] ShiftRight(T[] array, int count);
    public static T[] ShiftLeft(T[] array, int count);
    public static T[] Insert(T item, IList`1<T> list);
    public static T[] Insert(T item1, T item2, IList`1<T> list);
    public static T[] Insert(T item, T[] array);
    public static T[] Insert(T item1, T item2, T[] array);
    public static T[] Append(T[] array, T item);
    public static T[] AppendRange(T[] array, IList`1<T> items);
    public static T[] AppendRange(T[] array, IList`1<T> items, int additionalItemCount);
    public static T[0...,0...] Concatenate(T[0...,0...] array1, T[0...,0...] array2);
    public static void SwapLastTwo(T[] array);
    public static T[] RemoveFirst(IList`1<T> list);
    public static T[] RemoveFirst(T[] array);
    public static T[] RemoveLast(T[] array);
    public static T[] RemoveAt(IList`1<T> list, int indexToRemove);
    public static T[] RemoveAt(T[] array, int indexToRemove);
    public static T[] InsertAt(IList`1<T> list, int index, T[] items);
    public static T[] InsertAt(T[] array, int index, T[] items);
    public static T[] ToArray(ICollection`1<T> list);
    [ExtensionAttribute]
public static bool ValueEquals(T[] array, T[] other);
    [ExtensionAttribute]
public static T[] Reverse(T[] array);
}
[IsReadOnlyAttribute]
internal class Microsoft.Scripting.Utils.AssemblyQualifiedTypeName : ValueType {
    public string TypeName;
    public AssemblyName AssemblyName;
    public AssemblyQualifiedTypeName(string typeName, AssemblyName assemblyName);
    public AssemblyQualifiedTypeName(Type type);
    public AssemblyQualifiedTypeName(string assemblyQualifiedTypeName);
    internal static AssemblyQualifiedTypeName ParseArgument(string str, string argumentName);
    public sealed virtual bool Equals(AssemblyQualifiedTypeName other);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public virtual string ToString();
    public static bool op_Equality(AssemblyQualifiedTypeName& name, AssemblyQualifiedTypeName& other);
    public static bool op_Inequality(AssemblyQualifiedTypeName& name, AssemblyQualifiedTypeName& other);
}
internal static class Microsoft.Scripting.Utils.Assert : object {
    [ConditionalAttribute("DEBUG")]
public static void NotNull(object var);
    [ConditionalAttribute("DEBUG")]
public static void NotNull(object var1, object var2);
    [ConditionalAttribute("DEBUG")]
public static void NotNull(object var1, object var2, object var3);
    [ConditionalAttribute("DEBUG")]
public static void NotNullItems(IEnumerable`1<T> items);
    [ConditionalAttribute("DEBUG")]
public static void NotEmpty(string str);
}
[ExtensionAttribute]
internal static class Microsoft.Scripting.Utils.CollectionExtensions : object {
    [ExtensionAttribute]
internal static ReadOnlyCollection`1<T> ToReadOnly(IEnumerable`1<T> enumerable);
    [ExtensionAttribute]
internal static T[] ToArray(IEnumerable`1<T> enumerable);
    [ExtensionAttribute]
internal static bool Any(IEnumerable`1<T> source, Func`2<T, bool> predicate);
    [ExtensionAttribute]
internal static TSource Aggregate(IEnumerable`1<TSource> source, Func`3<TSource, TSource, TSource> func);
    [ExtensionAttribute]
internal static T[] AddFirst(IList`1<T> list, T item);
    [ExtensionAttribute]
internal static bool TrueForAll(IEnumerable`1<T> collection, Predicate`1<T> predicate);
}
public class Microsoft.Scripting.Utils.ConsoleInputStream : Stream {
    public static ConsoleInputStream Instance;
    private static int MinimalBufferSize;
    private Stream _input;
    private object _lock;
    private Byte[] _buffer;
    private int _bufferPos;
    private int _bufferSize;
    public bool CanRead { get; }
    public bool CanSeek { get; }
    public bool CanWrite { get; }
    public long Length { get; }
    public long Position { get; public set; }
    private static ConsoleInputStream();
    public virtual bool get_CanRead();
    public virtual int Read(Byte[] buffer, int offset, int count);
    public virtual bool get_CanSeek();
    public virtual bool get_CanWrite();
    public virtual void Flush();
    public virtual long get_Length();
    public virtual long get_Position();
    public virtual void set_Position(long value);
    public virtual long Seek(long offset, SeekOrigin origin);
    public virtual void SetLength(long value);
    public virtual void Write(Byte[] buffer, int offset, int count);
}
public enum Microsoft.Scripting.Utils.ConsoleStreamType : Enum {
    public int value__;
    public static ConsoleStreamType Input;
    public static ConsoleStreamType Output;
    public static ConsoleStreamType ErrorOutput;
}
internal static class Microsoft.Scripting.Utils.ContractUtils : object {
    public static Exception Unreachable { get; }
    public static void RequiresNotNull(object value, string paramName);
    public static void Requires(bool precondition);
    public static void Requires(bool precondition, string paramName);
    public static void Requires(bool precondition, string paramName, string message);
    public static void RequiresNotEmpty(string str, string paramName);
    public static void RequiresNotEmpty(ICollection`1<T> collection, string paramName);
    public static void RequiresArrayRange(IList`1<T> array, int offset, int count, string offsetName, string countName);
    public static void RequiresArrayRange(int arraySize, int offset, int count, string offsetName, string countName);
    public static void RequiresNotNullItems(IList`1<T> array, string arrayName);
    public static void RequiresNotNullItems(IEnumerable`1<T> collection, string collectionName);
    public static void RequiresListRange(IList array, int offset, int count, string offsetName, string countName);
    public static Exception get_Unreachable();
}
internal static class Microsoft.Scripting.Utils.DelegateUtils : object {
    private static AssemblyBuilder _assembly;
    private static ModuleBuilder _modBuilder;
    private static int _typeCount;
    private static Type[] _DelegateCtorSignature;
    public static char GenericArityDelimiter;
    private static DelegateUtils();
    private static TypeBuilder DefineDelegateType(string name);
    internal static Type EmitCallSiteDelegateType(int paramCount);
}
internal static class Microsoft.Scripting.Utils.EmptyArray`1 : object {
    internal static T[] Instance;
    private static EmptyArray`1();
}
internal static class Microsoft.Scripting.Utils.EmptyReadOnlyCollection`1 : object {
    internal static ReadOnlyCollection`1<T> Instance;
    private static EmptyReadOnlyCollection`1();
}
[ExtensionAttribute]
public static class Microsoft.Scripting.Utils.EnumBounds : object {
    [ExtensionAttribute]
public static bool IsValid(SourceCodeKind value);
}
internal static class Microsoft.Scripting.Utils.ExceptionUtils : object {
    public static ArgumentNullException MakeArgumentItemNullException(int index, string arrayName);
}
internal class Microsoft.Scripting.Utils.ExpressionUtils : object {
    internal static Expression Convert(Expression expression, Type type);
}
internal static class Microsoft.Scripting.Utils.NativeMethods : object {
    internal static bool SetEnvironmentVariable(string name, string value);
}
[ExtensionAttribute]
internal static class Microsoft.Scripting.Utils.ReflectionUtils : object {
    [ExtensionAttribute]
public static MethodInfo GetMethodInfo(Delegate d);
    [ExtensionAttribute]
public static IEnumerable`1<MethodInfo> GetDeclaredMethods(Type type, string name);
}
