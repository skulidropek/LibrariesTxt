internal class EcmaScript.NET.Arguments : IdScriptableObject {
    private static int Id_callee;
    private static int Id_length;
    private static int Id_caller;
    private static int MAX_INSTANCE_ID;
    private object callerObj;
    private object calleeObj;
    private object lengthObj;
    private BuiltinCall activation;
    private Object[] args;
    public string ClassName { get; }
    protected internal int MaxInstanceId { get; }
    public Arguments(BuiltinCall activation);
    public virtual string get_ClassName();
    protected internal virtual int get_MaxInstanceId();
    public virtual bool Has(int index, IScriptable start);
    public virtual object Get(int index, IScriptable start);
    private bool sharedWithActivation(int index);
    public virtual object Put(int index, IScriptable start, object value);
    public virtual void Delete(int index);
    protected internal virtual int FindInstanceIdInfo(string s);
    protected internal virtual string GetInstanceIdName(int id);
    protected internal virtual object GetInstanceIdValue(int id);
    protected internal virtual void SetInstanceIdValue(int id, object value);
    internal virtual Object[] GetIds(bool getAll);
}
[AttributeUsageAttribute("4")]
public class EcmaScript.NET.Attributes.EcmaScriptClassAttribute : Attribute {
    private string m_Name;
    public string Name { get; }
    public EcmaScriptClassAttribute(string name);
    public string get_Name();
}
[AttributeUsageAttribute("96")]
public class EcmaScript.NET.Attributes.EcmaScriptFunctionAttribute : Attribute {
    private string m_Name;
    internal MethodInfo MethodInfo;
    public string Name { get; }
    public EcmaScriptFunctionAttribute(string name);
    public string get_Name();
}
public enum EcmaScript.NET.Attributes.EcmaScriptPropertyAccess : Enum {
    public int value__;
    public static EcmaScriptPropertyAccess AsDeclared;
    public static EcmaScriptPropertyAccess Get;
    public static EcmaScriptPropertyAccess Set;
}
[AttributeUsageAttribute("384")]
public class EcmaScript.NET.Attributes.EcmaScriptPropertyAttribute : Attribute {
    private string m_Name;
    private EcmaScriptPropertyAccess m_Access;
    public string Name { get; }
    public EcmaScriptPropertyAccess Access { get; }
    public EcmaScriptPropertyAttribute(string name);
    public EcmaScriptPropertyAttribute(string name, EcmaScriptPropertyAccess access);
    public string get_Name();
    public EcmaScriptPropertyAccess get_Access();
}
public class EcmaScript.NET.BaseFunction : IdScriptableObject {
    private static object FUNCTION_TAG;
    private static int Id_length;
    private static int Id_arity;
    private static int Id_name;
    private static int Id_prototype;
    private static int Id_arguments;
    private static int MAX_INSTANCE_ID;
    private static int Id_constructor;
    private static int Id_toString;
    private static int Id_toSource;
    private static int Id_apply;
    private static int Id_call;
    private static int MAX_PROTOTYPE_ID;
    private object prototypeProperty;
    private bool isPrototypePropertyImmune;
    public string ClassName { get; }
    protected internal int MaxInstanceId { get; }
    unknown object ImmunePrototypeProperty {public set; }
    public int Arity { get; }
    public int Length { get; }
    public string FunctionName { get; }
    internal object PrototypeProperty { get; }
    private object Arguments { get; }
    public BaseFunction(IScriptable scope, IScriptable prototype);
    private static BaseFunction();
    public virtual string get_ClassName();
    protected internal virtual int get_MaxInstanceId();
    public virtual void set_ImmunePrototypeProperty(object value);
    public virtual int get_Arity();
    public virtual int get_Length();
    public virtual string get_FunctionName();
    internal virtual object get_PrototypeProperty();
    private object get_Arguments();
    internal static void Init(IScriptable scope, bool zealed);
    public virtual bool HasInstance(IScriptable instance);
    protected internal virtual int FindInstanceIdInfo(string s);
    protected internal virtual string GetInstanceIdName(int id);
    protected internal virtual object GetInstanceIdValue(int id);
    protected internal virtual void SetInstanceIdValue(int id, object value);
    protected internal virtual void FillConstructorProperties(IdFunctionObject ctor);
    protected internal virtual void InitPrototypeId(int id);
    public virtual object ExecIdCall(IdFunctionObject f, Context cx, IScriptable scope, IScriptable thisObj, Object[] args);
    private BaseFunction RealFunction(IScriptable thisObj, IdFunctionObject f);
    protected internal virtual IScriptable GetClassPrototype();
    public virtual object Call(Context cx, IScriptable scope, IScriptable thisObj, Object[] args);
    public virtual IScriptable Construct(Context cx, IScriptable scope, Object[] args);
    public virtual IScriptable CreateObject(Context cx, IScriptable scope);
    internal virtual string Decompile(int indent, int flags);
    private void SetupDefaultPrototype();
    private static object JsConstructor(Context cx, IScriptable scope, Object[] args);
    protected internal virtual int FindPrototypeId(string s);
}
internal class EcmaScript.NET.CliHelper : object {
    internal static Type GetType(string className);
    internal static bool IsNegativeZero(double d);
    internal static bool IsPositiveZero(double d);
    internal static bool Equals(object o1, object o2);
    internal static string ToSignature(ConstructorInfo ci);
    internal static string ToSignature(PropertyInfo pi);
    internal static string ToSignature(FieldInfo fi);
    internal static string ToSignature(Object[] args);
    internal static string ToSignature(MemberInfo mi);
    internal static string ToSignature(char parenOpen, ParameterInfo[] pi, char parenClose);
    internal static string ToSignature(MethodInfo mi);
    internal static bool HasParamsParameter(MethodBase mb);
    internal static bool HasParamsParameter(ParameterInfo[] pis);
    internal static bool IsParamsParameter(ParameterInfo pi);
    internal static string ToSignature(Type type);
    internal static bool IsNumberType(Type type);
    internal static bool IsNumber(object value);
    internal static object CreateInstance(Type cl);
    internal static object GetCustomAttribute(Type type, Type attribute);
    internal static object GetCustomAttribute(Type type, MemberInfo mi);
    internal static object GetCustomAttribute(Type type, ParameterInfo pi);
    internal static Type[] GetParameterTypes(ParameterInfo[] parameters);
}
public class EcmaScript.NET.Collections.ObjArray : object {
    private int m_Size;
    private bool zealed;
    private static int FIELDS_STORE_SIZE;
    private object f0;
    private object f1;
    private object f2;
    private object f3;
    private object f4;
    private Object[] data;
    public bool Sealed { get; }
    public bool Empty { get; }
    unknown int Size {public set; }
    public virtual bool get_Sealed();
    public virtual bool get_Empty();
    public virtual void set_Size(int value);
    public void seal();
    public int size();
    public object Get(int index);
    public void Set(int index, object value);
    private object GetImpl(int index);
    private void SetImpl(int index, object value);
    public virtual int indexOf(object obj);
    public virtual int lastIndexOf(object obj);
    public object peek();
    public object pop();
    public void push(object value);
    public void add(object value);
    public void add(int index, object value);
    public void remove(int index);
    public void clear();
    public Object[] ToArray();
    public void ToArray(Object[] array);
    public void ToArray(Object[] array, int offset);
    private void ensureCapacity(int minimalCapacity);
    private static Exception onInvalidIndex(int index, int upperBound);
    private static Exception onEmptyStackTopRead();
    private static Exception onSeledMutation();
}
public class EcmaScript.NET.Collections.ObjToIntMap : object {
    private static int A;
    private static object DELETED;
    private Object[] keys;
    private Int32[] values;
    private int power;
    private int keyCount;
    private int occupiedCount;
    private static bool check;
    public bool Empty { get; }
    public ObjToIntMap(int keyCountHint);
    private static ObjToIntMap();
    public virtual bool get_Empty();
    public virtual int size();
    public virtual bool has(object key);
    public virtual int Get(object key, int defaultValue);
    public virtual int getExisting(object key);
    public virtual void put(object key, int value);
    public virtual object intern(object keyArg);
    public virtual void remove(object key);
    public virtual void clear();
    public virtual Iterator newIterator();
    internal void initIterator(Iterator i);
    public virtual Object[] getKeys();
    public virtual void getKeys(Object[] array, int offset);
    private static int tableLookupStep(int fraction, int mask, int power);
    private int findIndex(object key);
    private int insertNewKey(object key, int hash);
    private void rehashTable();
    private int ensureIndex(object key);
}
public class EcmaScript.NET.Collections.UintMap : object {
    private static int A;
    private static int EMPTY;
    private static int DELETED;
    private Int32[] keys;
    private Object[] values;
    private int power;
    private int keyCount;
    private int occupiedCount;
    private int ivaluesShift;
    private static bool check;
    public bool Empty { get; }
    public Int32[] Keys { get; }
    public UintMap(int initialCapacity);
    private static UintMap();
    public virtual bool get_Empty();
    public virtual Int32[] get_Keys();
    public virtual int size();
    public virtual bool has(int key);
    public virtual object getObject(int key);
    public virtual int getInt(int key, int defaultValue);
    public virtual int getExistingInt(int key);
    public virtual void put(int key, object value);
    public virtual void put(int key, int value);
    public virtual void remove(int key);
    public virtual void clear();
    private static int tableLookupStep(int fraction, int mask, int power);
    private int findIndex(int key);
    private int insertNewKey(int key);
    private void rehashTable(bool ensureIntSpace);
    private int ensureIndex(int key, bool intType);
}
public class EcmaScript.NET.CompilerEnvirons : object {
    private ErrorReporter errorReporter;
    private Versions languageVersion;
    private bool generateDebugInfo;
    private bool useDynamicScope;
    private bool reservedKeywordAsIdentifier;
    private bool allowMemberExprAsFunctionName;
    private bool xmlAvailable;
    private int optimizationLevel;
    private bool generatingSource;
    internal Hashtable activationNames;
    internal bool getterAndSetterSupport;
    public bool UseDynamicScope { get; }
    public Versions LanguageVersion { get; public set; }
    public virtual bool get_UseDynamicScope();
    public virtual void initFromContext(Context cx);
    public ErrorReporter getErrorReporter();
    public virtual void setErrorReporter(ErrorReporter errorReporter);
    public Versions get_LanguageVersion();
    public void set_LanguageVersion(Versions value);
    public bool isGenerateDebugInfo();
    public virtual void setGenerateDebugInfo(bool flag);
    public bool isReservedKeywordAsIdentifier();
    public virtual void setReservedKeywordAsIdentifier(bool flag);
    public bool isAllowMemberExprAsFunctionName();
    public virtual void setAllowMemberExprAsFunctionName(bool flag);
    public bool isXmlAvailable();
    public virtual void setXmlAvailable(bool flag);
    public int getOptimizationLevel();
    public virtual void setOptimizationLevel(int level);
    public bool isGeneratingSource();
    public virtual void setGeneratingSource(bool generatingSource);
}
public class EcmaScript.NET.Context : object {
    [CompilerGeneratedAttribute]
private ContextWrapHandler OnWrap;
    private int m_MaximumInterpreterStackDepth;
    private AppDomain m_AppDomain;
    public static string languageVersionProperty;
    public static string errorReporterProperty;
    public static Object[] EmptyArgs;
    private Features m_Features;
    private static string implementationVersion;
    private ContextFactory factory;
    private bool m_Sealed;
    private object m_SealKey;
    internal IScriptable topCallScope;
    internal BuiltinCall currentActivationCall;
    internal XMLLib cachedXMLLib;
    internal ObjToIntMap iterating;
    internal object interpreterSecurityDomain;
    internal Versions m_Version;
    private SecurityController securityController;
    private ErrorReporter m_ErrorReporter;
    internal RegExpProxy regExpProxy;
    private CultureInfo culture;
    private bool generatingDebug;
    private bool generatingDebugChanged;
    private bool generatingSource;
    internal bool compileFunctionsWithDynamicScopeFlag;
    internal bool useDynamicScope;
    private int m_OptimizationLevel;
    internal Debugger m_Debugger;
    private object debuggerData;
    private int enterCount;
    private Hashtable hashtable;
    private bool creationEventWasSent;
    internal Hashtable activationNames;
    internal object lastInterpreterFrame;
    internal ObjArray previousInterpreterInvocations;
    internal int instructionCount;
    internal int instructionThreshold;
    internal int scratchIndex;
    internal long scratchUint32;
    internal IScriptable scratchScriptable;
    public int MaximumInterpreterStackDepth { get; public set; }
    public AppDomain AppDomain { get; }
    private static LocalDataStoreSlot LocalSlot { get; }
    public static Context CurrentContext { get; }
    public ContextFactory Factory { get; }
    public bool Sealed { get; }
    public string ImplementationVersion { get; }
    public static object UndefinedValue { get; }
    public bool GeneratingDebug { get; public set; }
    public bool GeneratingSource { get; public set; }
    public int OptimizationLevel { get; public set; }
    public object DebuggerContextData { get; }
    public int InstructionObserverThreshold { get; public set; }
    internal RegExpProxy RegExpProxy { get; internal set; }
    internal bool VersionECMA1 { get; }
    public bool GeneratingDebugChanged { get; }
    public Versions Version { get; public set; }
    public ErrorReporter ErrorReporter { get; public set; }
    public CultureInfo CurrentCulture { get; public set; }
    public SecurityController SecurityController { get; public set; }
    public Debugger Debugger { get; }
    public Context(AppDomain appDomain);
    private static Context();
    [CompilerGeneratedAttribute]
public void add_OnWrap(ContextWrapHandler value);
    [CompilerGeneratedAttribute]
public void remove_OnWrap(ContextWrapHandler value);
    public int get_MaximumInterpreterStackDepth();
    public void set_MaximumInterpreterStackDepth(int value);
    public AppDomain get_AppDomain();
    private static LocalDataStoreSlot get_LocalSlot();
    public static Context get_CurrentContext();
    public ContextFactory get_Factory();
    public bool get_Sealed();
    public string get_ImplementationVersion();
    public static object get_UndefinedValue();
    public bool get_GeneratingDebug();
    public void set_GeneratingDebug(bool value);
    public bool get_GeneratingSource();
    public void set_GeneratingSource(bool value);
    public int get_OptimizationLevel();
    public void set_OptimizationLevel(int value);
    public object get_DebuggerContextData();
    public object Wrap(IScriptable scope, object obj, Type staticType);
    public int get_InstructionObserverThreshold();
    public void set_InstructionObserverThreshold(int value);
    internal RegExpProxy get_RegExpProxy();
    internal void set_RegExpProxy(RegExpProxy value);
    internal bool get_VersionECMA1();
    public bool get_GeneratingDebugChanged();
    public static Context Enter();
    public static Context Enter(AppDomain appDomain);
    public static Context Enter(Context cx);
    public static Context Enter(Context cx, AppDomain appDomain);
    public static void Exit();
    public static object Call(ContextFactory factory, ICallable callable, IScriptable scope, IScriptable thisObj, Object[] args);
    internal void InitDefaultFeatures();
    private static Context PrepareNewContext(AppDomain appDomain, ContextFactory factory);
    private static void ReleaseContext(Context cx);
    public void Seal(object sealKey);
    public void Unseal(object sealKey);
    internal static void OnSealedMutation();
    public Versions get_Version();
    public void set_Version(Versions value);
    public static bool IsValidLanguageVersion(int version);
    public static Versions ToValidLanguageVersion(int version);
    public static void CheckLanguageVersion(int version);
    public ErrorReporter get_ErrorReporter();
    public void set_ErrorReporter(ErrorReporter value);
    public CultureInfo get_CurrentCulture();
    public void set_CurrentCulture(CultureInfo value);
    public static void ReportWarning(string message, string sourceName, int lineno, string lineSource, int lineOffset);
    public static void ReportWarningById(string messageId, String[] arguments);
    public static void ReportWarning(string message);
    public static void ReportError(string message, string sourceName, int lineno, string lineSource, int lineOffset);
    public static void ReportError(string message);
    public static EcmaScriptRuntimeException ReportRuntimeError(string message, string sourceName, int lineno, string lineSource, int lineOffset);
    internal static EcmaScriptRuntimeException ReportRuntimeErrorById(string messageId, Object[] args);
    public static EcmaScriptRuntimeException ReportRuntimeError(string message);
    public ScriptableObject InitStandardObjects();
    public IScriptable InitStandardObjects(ScriptableObject scope);
    public ScriptableObject InitStandardObjects(ScriptableObject scope, bool zealed);
    public object EvaluateString(IScriptable scope, string source, string sourceName, int lineno, object securityDomain);
    public object EvaluateReader(IScriptable scope, StreamReader sr, string sourceName, int lineno, object securityDomain);
    public ScriptOrFnNode IsCompilableUnit(string source);
    public IScript CompileReader(StreamReader sr, string sourceName, int lineno, object securityDomain);
    public IScript CompileString(string source, string sourceName, int lineno, object securityDomain);
    internal IScript CompileString(string source, Interpreter compiler, ErrorReporter compilationErrorReporter, string sourceName, int lineno, object securityDomain);
    public IFunction CompileFunction(IScriptable scope, string source, string sourceName, int lineno, object securityDomain);
    internal IFunction CompileFunction(IScriptable scope, string source, Interpreter compiler, ErrorReporter compilationErrorReporter, string sourceName, int lineno, object securityDomain);
    public string DecompileScript(IScript script, int indent);
    public string DecompileFunction(IFunction fun, int indent);
    public string DecompileFunctionBody(IFunction fun, int indent);
    public IScriptable NewObject(IScriptable scope);
    public IScriptable NewObject(IScriptable scope, string constructorName);
    public IScriptable NewObject(IScriptable scope, string constructorName, Object[] args);
    public IScriptable NewArray(IScriptable scope, int length);
    public IScriptable NewArray(IScriptable scope, Object[] elements);
    public Object[] GetElements(IScriptable obj);
    public static object CliToJS(Context cx, object value, IScriptable scope);
    public static object JsToCli(object value, Type desiredType);
    public static Exception ThrowAsScriptRuntimeEx(Exception e);
    public static bool IsValidOptimizationLevel(int optimizationLevel);
    public static void CheckOptimizationLevel(int optimizationLevel);
    public void set_SecurityController(SecurityController value);
    public SecurityController get_SecurityController();
    public object GetThreadLocal(object key);
    public void PutThreadLocal(object key, object value);
    public void RemoveThreadLocal(object key);
    public Debugger get_Debugger();
    public void SetDebugger(Debugger debugger, object contextData);
    public static DebuggableScript getDebuggableView(IScript script);
    public bool HasFeature(Features feature);
    public void SetFeature(Features feature, bool isEnabled);
    protected internal void ObserveInstructionCount(int instructionCount);
    private object CompileImpl(IScriptable scope, StreamReader sourceReader, string sourceString, string sourceName, int lineno, object securityDomain, bool returnFunction, Interpreter compiler, ErrorReporter compilationErrorReporter);
    private static void NotifyDebugger(Context cx, DebuggableScript dscript, string debugSource);
    internal static string GetSourcePositionFromStack(Int32[] linep);
    public void AddActivationName(string name);
    public bool IsActivationNeeded(string name);
    public void RemoveActivationName(string name);
    public sealed virtual void Dispose();
    public static Exception CodeBug();
}
public class EcmaScript.NET.ContextEventArgs : EventArgs {
    private Context m_Context;
    public Context Context { get; }
    public ContextEventArgs(Context cx);
    public Context get_Context();
}
public class EcmaScript.NET.ContextEventHandler : MulticastDelegate {
    public ContextEventHandler(object object, IntPtr method);
    public virtual void Invoke(object sender, ContextEventArgs e);
    public virtual IAsyncResult BeginInvoke(object sender, ContextEventArgs e, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
public class EcmaScript.NET.ContextFactory : object {
    private static Boolean modreq(System.Runtime.CompilerServices.IsVolatile) hasCustomGlobal;
    private static ContextFactory global;
    private Boolean modreq(System.Runtime.CompilerServices.IsVolatile) zealed;
    [CompilerGeneratedAttribute]
private ContextEventHandler OnContextCreated;
    [CompilerGeneratedAttribute]
private ContextEventHandler OnContextReleased;
    public static ContextFactory Global { get; }
    public bool Sealed { get; }
    public static bool HasExplicitGlobal { get; }
    private static ContextFactory();
    public static ContextFactory get_Global();
    public virtual bool get_Sealed();
    [CompilerGeneratedAttribute]
public void add_OnContextCreated(ContextEventHandler value);
    [CompilerGeneratedAttribute]
public void remove_OnContextCreated(ContextEventHandler value);
    [CompilerGeneratedAttribute]
public void add_OnContextReleased(ContextEventHandler value);
    [CompilerGeneratedAttribute]
public void remove_OnContextReleased(ContextEventHandler value);
    public static bool get_HasExplicitGlobal();
    public static void InitGlobal(ContextFactory factory);
    protected internal virtual object DoTopCall(ICallable callable, Context cx, IScriptable scope, IScriptable thisObj, Object[] args);
    protected internal virtual void ObserveInstructionCount(Context cx, int instructionCount);
    protected internal virtual void FireOnContextCreated(Context cx);
    protected internal virtual void FireOnContextReleased(Context cx);
    public void Seal();
    protected internal void CheckNotSealed();
}
public class EcmaScript.NET.ContextScriptableEventArgs : ContextEventArgs {
    private IScriptable m_Scope;
    public IScriptable Scope { get; }
    public ContextScriptableEventArgs(Context cx, IScriptable scope);
    public IScriptable get_Scope();
}
public class EcmaScript.NET.ContextWrapEventArgs : ContextScriptableEventArgs {
    private object m_Source;
    private object m_Target;
    private Type m_StaticType;
    public object Source { get; }
    public object Target { get; public set; }
    public Type staticType { get; }
    public ContextWrapEventArgs(Context cx, IScriptable scope, object obj, Type staticType);
    public object get_Source();
    public object get_Target();
    public void set_Target(object value);
    public Type get_staticType();
}
public class EcmaScript.NET.ContextWrapHandler : MulticastDelegate {
    public ContextWrapHandler(object object, IntPtr method);
    public virtual void Invoke(object sender, ContextWrapEventArgs e);
    public virtual IAsyncResult BeginInvoke(object sender, ContextWrapEventArgs e, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
public class EcmaScript.NET.Continuation : IdScriptableObject {
    private static object FTAG;
    private object implementation;
    private static int Id_constructor;
    private static int MAX_PROTOTYPE_ID;
    public object Implementation { get; }
    public string ClassName { get; }
    private static Continuation();
    public object get_Implementation();
    public virtual string get_ClassName();
    public static void Init(IScriptable scope, bool zealed);
    public void initImplementation(object implementation);
    public sealed virtual IScriptable Construct(Context cx, IScriptable scope, Object[] args);
    public sealed virtual object Call(Context cx, IScriptable scope, IScriptable thisObj, Object[] args);
    public static bool IsContinuationConstructor(IdFunctionObject f);
    protected internal virtual void InitPrototypeId(int id);
    public virtual object ExecIdCall(IdFunctionObject f, Context cx, IScriptable scope, IScriptable thisObj, Object[] args);
    protected internal virtual int FindPrototypeId(string s);
}
public interface EcmaScript.NET.Debugging.DebugFrame {
    public abstract virtual void OnEnter(Context cx, IScriptable activation, IScriptable thisObj, Object[] args);
    public abstract virtual void OnLineChange(Context cx, int lineNumber);
    public abstract virtual void OnExceptionThrown(Context cx, Exception ex);
    public abstract virtual void OnExit(Context cx, bool byThrow, object resultOrException);
    public abstract virtual void OnDebuggerStatement(Context cx);
}
public interface EcmaScript.NET.Debugging.DebuggableObject {
    public Object[] AllIds { get; }
    public abstract virtual Object[] get_AllIds();
}
public interface EcmaScript.NET.Debugging.DebuggableScript {
    public bool TopLevel { get; }
    public string FunctionName { get; }
    public int ParamCount { get; }
    public int ParamAndVarCount { get; }
    public string SourceName { get; }
    public bool GeneratedScript { get; }
    public Int32[] LineNumbers { get; }
    public int FunctionCount { get; }
    public DebuggableScript Parent { get; }
    public abstract virtual bool get_TopLevel();
    public abstract virtual string get_FunctionName();
    public abstract virtual int get_ParamCount();
    public abstract virtual int get_ParamAndVarCount();
    public abstract virtual string get_SourceName();
    public abstract virtual bool get_GeneratedScript();
    public abstract virtual Int32[] get_LineNumbers();
    public abstract virtual int get_FunctionCount();
    public abstract virtual DebuggableScript get_Parent();
    public abstract virtual bool IsFunction();
    public abstract virtual string GetParamOrVarName(int index);
    public abstract virtual DebuggableScript GetFunction(int index);
}
public interface EcmaScript.NET.Debugging.Debugger {
    public abstract virtual void HandleCompilationDone(Context cx, DebuggableScript fnOrScript, string source);
    public abstract virtual DebugFrame GetFrame(Context cx, DebuggableScript fnOrScript);
}
public class EcmaScript.NET.Decompiler : object {
    public static int ONLY_BODY_FLAG;
    public static int TO_SOURCE_FLAG;
    public static int TO_STRING_FLAG;
    public static int INITIAL_INDENT_PROP;
    public static int INDENT_GAP_PROP;
    public static int CASE_GAP_PROP;
    private static int FUNCTION_END;
    private Char[] sourceBuffer;
    private int sourceTop;
    private static bool printSource;
    internal string EncodedSource { get; }
    internal int CurrentOffset { get; }
    private static Decompiler();
    internal string get_EncodedSource();
    internal int get_CurrentOffset();
    internal int MarkFunctionStart(int functionType);
    internal int MarkFunctionEnd(int functionStart);
    internal void AddToken(int token);
    internal void AddEol(int token);
    internal void AddName(string str);
    internal void AddString(string str);
    internal void AddRegexp(string regexp, string flags);
    internal void AddJScriptConditionalComment(string str);
    internal void AddPreservedComment(string str);
    internal void AddNumber(double n);
    private void AppendString(string str);
    private void Append(char c);
    private void IncreaseSourceCapacity(int minimalCapacity);
    private string SourceToString(int offset);
    public static string Decompile(string source, int flags, UintMap properties);
    private static int GetNext(string source, int length, int i);
    private static int GetSourceStringEnd(string source, int offset);
    private static int PrintSourceString(string source, int offset, bool asQuotedString, StringBuilder sb);
    private static int PrintSourceNumber(string source, int offset, StringBuilder sb);
}
internal class EcmaScript.NET.DefaultErrorReporter : object {
    internal static DefaultErrorReporter instance;
    private bool forEval;
    private ErrorReporter chainedReporter;
    private static DefaultErrorReporter();
    internal static ErrorReporter ForEval(ErrorReporter reporter);
    public virtual void Warning(string message, string sourceURI, int line, string lineText, int lineOffset);
    public virtual void Error(string message, string sourceURI, int line, string lineText, int lineOffset);
    public virtual EcmaScriptRuntimeException RuntimeError(string message, string sourceURI, int line, string lineText, int lineOffset);
}
public class EcmaScript.NET.Delegator : object {
    protected internal IScriptable obj;
    public IScriptable Delegee { get; public set; }
    public string ClassName { get; }
    public IScriptable ParentScope { get; public set; }
    public Delegator(IScriptable obj);
    public virtual IScriptable get_Delegee();
    public virtual void set_Delegee(IScriptable value);
    public virtual string get_ClassName();
    public virtual IScriptable get_ParentScope();
    public virtual void set_ParentScope(IScriptable value);
    protected internal virtual Delegator NewInstance();
    public virtual object Get(string name, IScriptable start);
    public virtual object Get(int index, IScriptable start);
    public virtual bool Has(string name, IScriptable start);
    public virtual bool Has(int index, IScriptable start);
    public virtual object Put(string name, IScriptable start, object value);
    public virtual object Put(int index, IScriptable start, object value);
    public virtual void Delete(string name);
    public virtual void Delete(int index);
    public virtual IScriptable GetPrototype();
    public virtual void SetPrototype(IScriptable prototype);
    public virtual Object[] GetIds();
    public virtual object GetDefaultValue(Type hint);
    public virtual bool HasInstance(IScriptable instance);
    public virtual object Call(Context cx, IScriptable scope, IScriptable thisObj, Object[] args);
    public virtual IScriptable Construct(Context cx, IScriptable scope, Object[] args);
}
public class EcmaScript.NET.EcmaScriptError : EcmaScriptException {
    private string m_ErrorName;
    private string m_ErrorMessage;
    public string Name { get; }
    public string Message { get; }
    public string ErrorMessage { get; }
    internal EcmaScriptError(string errorName, string errorMessage, string sourceName, int lineNumber, string lineSource, int columnNumber);
    public virtual string get_Name();
    public virtual string get_Message();
    public virtual string get_ErrorMessage();
}
public abstract class EcmaScript.NET.EcmaScriptException : Exception {
    private string m_SourceName;
    private int m_LineNumber;
    private string m_LineSource;
    private int m_ColumnNumber;
    internal object m_InterpreterStackInfo;
    internal Int32[] m_InterpreterLineData;
    private string m_ScriptStackTrace;
    public string Message { get; }
    public string SourceName { get; }
    public int LineNumber { get; }
    public int ColumnNumber { get; }
    public string LineSource { get; }
    public string ScriptStackTrace { get; }
    internal EcmaScriptException(string details);
    internal EcmaScriptException(string details, Exception innerException);
    public virtual string get_Message();
    public virtual string get_SourceName();
    public void InitSourceName(string sourceName);
    public int get_LineNumber();
    public void InitLineNumber(int lineNumber);
    public int get_ColumnNumber();
    public void InitColumnNumber(int columnNumber);
    public string get_LineSource();
    public void InitLineSource(string lineSource);
    internal void RecordErrorOrigin(string sourceName, int lineNumber, string lineSource, int columnNumber);
    private void InitScriptStackTrace();
    public string get_ScriptStackTrace();
    public virtual string ToString();
}
public class EcmaScript.NET.EcmaScriptRuntimeException : EcmaScriptException {
    public EcmaScriptRuntimeException(Exception innerException);
    public EcmaScriptRuntimeException(string detail);
    public EcmaScriptRuntimeException(string detail, string sourceName, int lineNumber);
    public EcmaScriptRuntimeException(string detail, string sourceName, int lineNumber, string lineSource, int columnNumber);
}
public class EcmaScript.NET.EcmaScriptThrow : EcmaScriptException {
    private object value;
    public object Value { get; }
    public string Message { get; }
    public EcmaScriptThrow(object value, string sourceName, int lineNumber);
    public virtual object get_Value();
    public virtual string get_Message();
}
public interface EcmaScript.NET.ErrorReporter {
    public abstract virtual void Warning(string message, string sourceName, int line, string lineSource, int lineOffset);
    public abstract virtual void Error(string message, string sourceName, int line, string lineSource, int lineOffset);
    public abstract virtual EcmaScriptRuntimeException RuntimeError(string message, string sourceName, int line, string lineSource, int lineOffset);
}
public class EcmaScript.NET.FunctionNode : ScriptOrFnNode {
    public static int FUNCTION_STATEMENT;
    public static int FUNCTION_EXPRESSION;
    public static int FUNCTION_EXPRESSION_STATEMENT;
    internal string functionName;
    internal bool itsNeedsActivation;
    internal int itsFunctionType;
    internal bool itsIgnoreDynamicScope;
    public string FunctionName { get; }
    public bool IgnoreDynamicScope { get; }
    public int FunctionType { get; }
    public bool RequiresActivation { get; }
    public FunctionNode(string name);
    public virtual string get_FunctionName();
    public virtual bool get_IgnoreDynamicScope();
    public virtual int get_FunctionType();
    public virtual bool get_RequiresActivation();
}
public class EcmaScript.NET.Helpers.StackOverflowVerifier : object {
    [ThreadStaticAttribute]
private static long m_Counter;
    private int m_MaxStackSize;
    public StackOverflowVerifier(int maxStackSize);
    private static StackOverflowVerifier();
    public sealed virtual void Dispose();
    private void ChangeStackDepth(int offset);
}
internal class EcmaScript.NET.Helpers.StackOverflowVerifierException : Exception {
}
public interface EcmaScript.NET.ICallable {
    public abstract virtual object Call(Context cx, IScriptable scope, IScriptable thisObj, Object[] args);
}
public class EcmaScript.NET.IdEnumeration : object {
    private IScriptable obj;
    private Object[] ids;
    private int index;
    private ObjToIntMap used;
    private string currentId;
    private bool enumValues;
    public IdEnumeration(object value, Context cx, bool enumValues);
    public virtual bool MoveNext();
    public virtual object Current(Context cx);
    private void ChangeObject();
}
public class EcmaScript.NET.IdFunctionObject : BaseFunction {
    private IIdFunctionCall idcall;
    private object tag;
    private int m_MethodId;
    private int arity;
    private bool useCallAsConstructor;
    private string functionName;
    public int Arity { get; }
    public int Length { get; }
    public string FunctionName { get; }
    public int MethodId { get; }
    public IdFunctionObject(IIdFunctionCall idcall, object tag, int id, int arity);
    public IdFunctionObject(IIdFunctionCall idcall, object tag, int id, string name, int arity, IScriptable scope);
    public virtual int get_Arity();
    public virtual int get_Length();
    public virtual string get_FunctionName();
    public virtual void InitFunction(string name, IScriptable scope);
    public bool HasTag(object tag);
    public int get_MethodId();
    public void MarkAsConstructor(IScriptable prototypeProperty);
    public void AddAsProperty(IScriptable target);
    public void AddAsProperty(IScriptable target, int attributes);
    public virtual void ExportAsScopeProperty();
    public virtual void ExportAsScopeProperty(int attributes);
    public virtual IScriptable GetPrototype();
    public virtual object Call(Context cx, IScriptable scope, IScriptable thisObj, Object[] args);
    public virtual IScriptable CreateObject(Context cx, IScriptable scope);
    internal virtual string Decompile(int indent, int flags);
    public Exception Unknown();
}
public abstract class EcmaScript.NET.IdScriptableObject : ScriptableObject {
    private PrototypeValues modreq(System.Runtime.CompilerServices.IsVolatile) prototypeValues;
    protected internal int MaxInstanceId { get; }
    public IdScriptableObject(IScriptable scope, IScriptable prototype);
    protected internal virtual int get_MaxInstanceId();
    protected internal object DefaultGet(string name);
    protected internal void DefaultPut(string name, object value);
    public virtual bool Has(string name, IScriptable start);
    public virtual object Get(string name, IScriptable start);
    public virtual object Put(string name, IScriptable start, object value);
    public virtual void Delete(string name);
    public virtual int GetAttributes(string name);
    public virtual void SetAttributes(string name, int attributes);
    internal virtual Object[] GetIds(bool getAll);
    protected internal static int InstanceIdInfo(int attributes, int id);
    protected internal virtual int FindInstanceIdInfo(string name);
    protected internal virtual string GetInstanceIdName(int id);
    protected internal virtual object GetInstanceIdValue(int id);
    protected internal virtual void SetInstanceIdValue(int id, object value);
    public virtual object ExecIdCall(IdFunctionObject f, Context cx, IScriptable scope, IScriptable thisObj, Object[] args);
    public IdFunctionObject ExportAsJSClass(int maxPrototypeId, IScriptable scope, bool zealed);
    public IdFunctionObject ExportAsJSClass(int maxPrototypeId, IScriptable scope, bool zealed, int attributes);
    public void ActivatePrototypeMap(int maxPrototypeId);
    public void InitPrototypeMethod(object tag, int id, string name, int arity);
    public void InitPrototypeConstructor(IdFunctionObject f);
    public void InitPrototypeValue(int id, string name, object value, int attributes);
    protected internal virtual void InitPrototypeId(int id);
    protected internal virtual int FindPrototypeId(string name);
    protected internal virtual void FillConstructorProperties(IdFunctionObject ctor);
    protected internal virtual void AddIdFunctionProperty(IScriptable obj, object tag, int id, string name, int arity);
    protected internal static EcmaScriptError IncompatibleCallError(IdFunctionObject f);
    private IdFunctionObject NewIdFunction(object tag, int id, string name, int arity, IScriptable scope);
}
public interface EcmaScript.NET.IFunction {
    public abstract virtual IScriptable Construct(Context cx, IScriptable scope, Object[] args);
}
internal interface EcmaScript.NET.IIdEnumerable {
    public abstract virtual IdEnumeration GetEnumeration(Context cx, bool enumValues);
}
public interface EcmaScript.NET.IIdFunctionCall {
    public abstract virtual object ExecIdCall(IdFunctionObject f, Context cx, IScriptable scope, IScriptable thisObj, Object[] args);
}
internal class EcmaScript.NET.InterpretedFunction : BuiltinFunction {
    internal InterpreterData idata;
    internal SecurityController securityController;
    internal object securityDomain;
    internal IScriptable[] functionRegExps;
    public string FunctionName { get; }
    public string EncodedSource { get; }
    public DebuggableScript DebuggableView { get; }
    protected internal Versions LanguageVersion { get; }
    protected internal int ParamCount { get; }
    protected internal int ParamAndVarCount { get; }
    private InterpretedFunction(InterpreterData idata, object staticSecurityDomain);
    private InterpretedFunction(InterpretedFunction parent, int index);
    public virtual string get_FunctionName();
    public virtual string get_EncodedSource();
    public virtual DebuggableScript get_DebuggableView();
    protected internal virtual Versions get_LanguageVersion();
    protected internal virtual int get_ParamCount();
    protected internal virtual int get_ParamAndVarCount();
    internal static InterpretedFunction createScript(InterpreterData idata, object staticSecurityDomain);
    internal static InterpretedFunction createFunction(Context cx, IScriptable scope, InterpreterData idata, object staticSecurityDomain);
    internal static InterpretedFunction createFunction(Context cx, IScriptable scope, InterpretedFunction parent, int index);
    internal IScriptable[] createRegExpWraps(Context cx, IScriptable scope);
    private void initInterpretedFunction(Context cx, IScriptable scope);
    public virtual object Call(Context cx, IScriptable scope, IScriptable thisObj, Object[] args);
    public sealed virtual object Exec(Context cx, IScriptable scope);
    protected internal virtual string getParamOrVarName(int index);
}
public class EcmaScript.NET.Interpreter : object {
    private static int Icode_DUP;
    private static int Icode_DUP2;
    private static int Icode_SWAP;
    private static int Icode_POP;
    private static int Icode_POP_RESULT;
    private static int Icode_IFEQ_POP;
    private static int Icode_VAR_INC_DEC;
    private static int Icode_NAME_INC_DEC;
    private static int Icode_PROP_INC_DEC;
    private static int Icode_ELEM_INC_DEC;
    private static int Icode_REF_INC_DEC;
    private static int Icode_SCOPE_LOAD;
    private static int Icode_SCOPE_SAVE;
    private static int Icode_TYPEOFNAME;
    private static int Icode_NAME_AND_THIS;
    private static int Icode_PROP_AND_THIS;
    private static int Icode_ELEM_AND_THIS;
    private static int Icode_VALUE_AND_THIS;
    private static int Icode_CLOSURE_EXPR;
    private static int Icode_CLOSURE_STMT;
    private static int Icode_CALLSPECIAL;
    private static int Icode_RETUNDEF;
    private static int Icode_GOSUB;
    private static int Icode_STARTSUB;
    private static int Icode_RETSUB;
    private static int Icode_LINE;
    private static int Icode_SHORTNUMBER;
    private static int Icode_INTNUMBER;
    private static int Icode_LITERAL_NEW;
    private static int Icode_LITERAL_SET;
    private static int Icode_SPARE_ARRAYLIT;
    private static int Icode_REG_IND_C0;
    private static int Icode_REG_IND_C1;
    private static int Icode_REG_IND_C2;
    private static int Icode_REG_IND_C3;
    private static int Icode_REG_IND_C4;
    private static int Icode_REG_IND_C5;
    private static int Icode_REG_IND1;
    private static int Icode_REG_IND2;
    private static int Icode_REG_IND4;
    private static int Icode_REG_STR_C0;
    private static int Icode_REG_STR_C1;
    private static int Icode_REG_STR_C2;
    private static int Icode_REG_STR_C3;
    private static int Icode_REG_STR1;
    private static int Icode_REG_STR2;
    private static int Icode_REG_STR4;
    private static int Icode_GETVAR1;
    private static int Icode_SETVAR1;
    private static int Icode_UNDEF;
    private static int Icode_ZERO;
    private static int Icode_ONE;
    private static int Icode_ENTERDQ;
    private static int Icode_LEAVEDQ;
    private static int Icode_TAIL_CALL;
    private static int Icode_LOCAL_CLEAR;
    private static int Icode_DEBUGGER;
    private static int MIN_ICODE;
    private CompilerEnvirons compilerEnv;
    private bool itsInFunctionFlag;
    private InterpreterData itsData;
    private ScriptOrFnNode scriptOrFn;
    private int itsICodeTop;
    private int itsStackDepth;
    private int itsLineNumber;
    private int itsDoubleTableTop;
    private ObjToIntMap itsStrings;
    private int itsLocalTop;
    private static int MIN_LABEL_TABLE_SIZE;
    private static int MIN_FIXUP_TABLE_SIZE;
    private Int32[] itsLabelTable;
    private int itsLabelTableTop;
    private Int64[] itsFixupTable;
    private int itsFixupTableTop;
    private ObjArray itsLiteralIds;
    private int itsExceptionTableTop;
    private static int EXCEPTION_TRY_START_SLOT;
    private static int EXCEPTION_TRY_END_SLOT;
    private static int EXCEPTION_HANDLER_SLOT;
    private static int EXCEPTION_TYPE_SLOT;
    private static int EXCEPTION_LOCAL_SLOT;
    private static int EXCEPTION_SCOPE_SLOT;
    private static int EXCEPTION_SLOT_SIZE;
    private static int ECF_TAIL;
    private static string bytecodeName(int bytecode);
    private static bool validIcode(int icode);
    private static bool ValidTokenCode(int token);
    private static bool validBytecode(int bytecode);
    public virtual object Compile(CompilerEnvirons compilerEnv, ScriptOrFnNode tree, string encodedSource, bool returnFunction);
    public virtual IScript CreateScriptObject(object bytecode, object staticSecurityDomain);
    public virtual IFunction CreateFunctionObject(Context cx, IScriptable scope, object bytecode, object staticSecurityDomain);
    private void generateFunctionICode();
    private void generateICodeFromTree(Node tree);
    private void generateNestedFunctions();
    private void generateRegExpLiterals();
    private void updateLineNumber(Node node);
    private Exception badTree(Node node);
    private void VisitStatement(Node node);
    private bool VisitExpressionOptimized(Node node, int contextFlags);
    private void VisitExpression(Node node, int contextFlags);
    private void generateCallFunAndThis(Node left);
    private void VisitIncDec(Node node, Node child);
    private void VisitLiteral(Node node, Node child);
    private int getLocalBlockRef(Node node);
    private int getTargetLabel(Node target);
    private void markTargetLabel(Node target);
    private void addGoto(Node target, int gotoOp);
    private void fixLabelGotos();
    private void addBackwardGoto(int gotoOp, int jumpPC);
    private void resolveForwardGoto(int fromPC);
    private void resolveGoto(int fromPC, int jumpPC);
    private void addToken(int token);
    private void addIcode(int icode);
    private void addUint8(int value);
    private void addUint16(int value);
    private void addInt(int i);
    private int GetDoubleIndex(double num);
    private void addVarOp(int op, int varIndex);
    private void addStringOp(int op, string str);
    private void addIndexOp(int op, int index);
    private void addStringPrefix(string str);
    private void addIndexPrefix(int index);
    private void addExceptionHandler(int icodeStart, int icodeEnd, int handlerStart, bool isFinally, int exceptionObjectLocal, int scopeLocal);
    private SByte[] increaseICodeCapasity(int extraSize);
    private void stackChange(int change);
    private int allocLocal();
    private void releaseLocal(int localSlot);
    private static int GetShort(SByte[] iCode, int pc);
    private static int GetIndex(SByte[] iCode, int pc);
    private static int GetInt(SByte[] iCode, int pc);
    private static int getExceptionHandler(CallFrame frame, bool onlyFinally);
    private static void dumpICode(InterpreterData idata);
    private static int bytecodeSpan(int bytecode);
    internal static Int32[] getLineNumbers(InterpreterData data);
    internal static void captureInterpreterStackInfo(EcmaScriptException ex);
    internal static string GetSourcePositionFromStack(Context cx, Int32[] linep);
    internal static string GetStack(EcmaScriptException ex);
    internal static string getPatchedStack(EcmaScriptException ex, string nativeStackTrace);
    internal static string GetEncodedSource(InterpreterData idata);
    private static void initFunction(Context cx, IScriptable scope, InterpretedFunction parent, int index);
    internal static object Interpret(InterpretedFunction ifun, Context cx, IScriptable scope, IScriptable thisObj, Object[] args);
    public static object restartContinuation(Continuation c, Context cx, IScriptable scope, Object[] args);
    private static object InterpretLoop(Context cx, CallFrame frame, object throwable);
    private static void initFrame(Context cx, IScriptable callerScope, IScriptable thisObj, Object[] args, Double[] argsDbl, int argShift, int argCount, InterpretedFunction fnOrScript, CallFrame parentFrame, CallFrame frame);
    private static bool isFrameEnterExitRequired(CallFrame frame);
    private static void EnterFrame(Context cx, CallFrame frame, Object[] args);
    private static void ExitFrame(Context cx, CallFrame frame, object throwable);
    private static void setCallResult(CallFrame frame, object callResult, double callResultDbl);
    private static void captureContinuation(Context cx, CallFrame frame, int stackTop);
    private static int stack_int32(CallFrame frame, int i);
    private static double stack_double(CallFrame frame, int i);
    private static bool stack_boolean(CallFrame frame, int i);
    private static void DoAdd(Object[] stack, Double[] sDbl, int stackTop, Context cx);
    private void addGotoOp(int gotoOp);
    private static Object[] GetArgsArray(Object[] stack, Double[] sDbl, int shift, int count);
    private static void addInstructionCount(Context cx, CallFrame frame, int extra);
}
internal class EcmaScript.NET.InterpreterData : object {
    internal static int INITIAL_MAX_ICODE_LENGTH;
    internal static int INITIAL_STRINGTABLE_SIZE;
    internal static int INITIAL_NUMBERTABLE_SIZE;
    internal string itsName;
    internal string itsSourceFile;
    internal bool itsNeedsActivation;
    internal int itsFunctionType;
    internal String[] itsStringTable;
    internal Double[] itsDoubleTable;
    internal InterpreterData[] itsNestedFunctions;
    internal Object[] itsRegExpLiterals;
    internal SByte[] itsICode;
    internal Int32[] itsExceptionTable;
    internal int itsMaxVars;
    internal int itsMaxLocals;
    internal int itsMaxStack;
    internal int itsMaxFrameArray;
    internal String[] argNames;
    internal int argCount;
    internal int itsMaxCalleeArgs;
    internal string encodedSource;
    internal int encodedSourceStart;
    internal int encodedSourceEnd;
    internal Versions languageVersion;
    internal bool useDynamicScope;
    internal bool topLevel;
    internal Object[] literalIds;
    internal UintMap longJumps;
    internal int firstLinePC;
    internal InterpreterData parentData;
    internal bool evalScriptFlag;
    public bool TopLevel { get; }
    public string FunctionName { get; }
    public int ParamCount { get; }
    public int ParamAndVarCount { get; }
    public string SourceName { get; }
    public bool GeneratedScript { get; }
    public Int32[] LineNumbers { get; }
    public int FunctionCount { get; }
    public DebuggableScript Parent { get; }
    internal InterpreterData(Versions languageVersion, string sourceFile, string encodedSource);
    internal InterpreterData(InterpreterData parent);
    public sealed virtual bool get_TopLevel();
    public sealed virtual string get_FunctionName();
    public sealed virtual int get_ParamCount();
    public sealed virtual int get_ParamAndVarCount();
    public sealed virtual string get_SourceName();
    public sealed virtual bool get_GeneratedScript();
    public sealed virtual Int32[] get_LineNumbers();
    public sealed virtual int get_FunctionCount();
    public sealed virtual DebuggableScript get_Parent();
    private void Init();
    public sealed virtual bool IsFunction();
    public sealed virtual string GetParamOrVarName(int index);
    public sealed virtual DebuggableScript GetFunction(int index);
}
public interface EcmaScript.NET.IRef {
    public abstract virtual bool Has(Context cx);
    public abstract virtual object Get(Context cx);
    public abstract virtual object Set(Context cx, object value);
    public abstract virtual bool Delete(Context cx);
}
public interface EcmaScript.NET.IRefCallable {
    public abstract virtual IRef RefCall(Context cx, IScriptable thisObj, Object[] args);
}
public interface EcmaScript.NET.IScript {
    public abstract virtual object Exec(Context cx, IScriptable scope);
}
public interface EcmaScript.NET.IScriptable {
    public string ClassName { get; }
    public IScriptable ParentScope { get; public set; }
    public abstract virtual string get_ClassName();
    public abstract virtual IScriptable get_ParentScope();
    public abstract virtual void set_ParentScope(IScriptable value);
    public abstract virtual object Get(string name, IScriptable start);
    public abstract virtual object Get(int index, IScriptable start);
    public abstract virtual bool Has(string name, IScriptable start);
    public abstract virtual bool Has(int index, IScriptable start);
    public abstract virtual object Put(string name, IScriptable start, object value);
    public abstract virtual object Put(int index, IScriptable start, object value);
    public abstract virtual void Delete(string name);
    public abstract virtual void Delete(int index);
    public abstract virtual IScriptable GetPrototype();
    public abstract virtual void SetPrototype(IScriptable prototype);
    public abstract virtual Object[] GetIds();
    public abstract virtual object GetDefaultValue(Type hint);
    public abstract virtual bool HasInstance(IScriptable instance);
}
public class EcmaScript.NET.Node : object {
    public static int FUNCTION_PROP;
    public static int LOCAL_PROP;
    public static int LOCAL_BLOCK_PROP;
    public static int REGEXP_PROP;
    public static int CASEARRAY_PROP;
    public static int TARGETBLOCK_PROP;
    public static int VARIABLE_PROP;
    public static int ISNUMBER_PROP;
    public static int DIRECTCALL_PROP;
    public static int SPECIALCALL_PROP;
    public static int SKIP_INDEXES_PROP;
    public static int OBJECT_IDS_PROP;
    public static int INCRDECR_PROP;
    public static int CATCH_SCOPE_PROP;
    public static int LABEL_ID_PROP;
    public static int MEMBER_TYPE_PROP;
    public static int NAME_PROP;
    public static int LAST_PROP;
    public static int BOTH;
    public static int LEFT;
    public static int RIGHT;
    public static int NON_SPECIALCALL;
    public static int SPECIALCALL_EVAL;
    public static int SPECIALCALL_WITH;
    public static int DECR_FLAG;
    public static int POST_FLAG;
    public static int PROPERTY_FLAG;
    public static int ATTRIBUTE_FLAG;
    public static int DESCENDANTS_FLAG;
    internal int Type;
    internal Node next;
    private Node first;
    private Node last;
    private int lineno;
    private PropListItem propListHead;
    public Node FirstChild { get; }
    public Node LastChild { get; }
    public Node Next { get; }
    public Node LastSibling { get; }
    public int Lineno { get; }
    public double Double { get; public set; }
    public string String { get; public set; }
    public Node(int nodeType);
    public Node(int nodeType, Node child);
    public Node(int nodeType, Node left, Node right);
    public Node(int nodeType, Node left, Node mid, Node right);
    public Node(int nodeType, int line);
    public Node(int nodeType, Node child, int line);
    public Node(int nodeType, Node left, Node right, int line);
    public Node(int nodeType, Node left, Node mid, Node right, int line);
    public Node get_FirstChild();
    public Node get_LastChild();
    public Node get_Next();
    public Node get_LastSibling();
    public int get_Lineno();
    public double get_Double();
    public void set_Double(double value);
    public string get_String();
    public void set_String(string value);
    public static Node newNumber(double number);
    public static Node newString(string str);
    public static Node newString(int Type, string str);
    public bool hasChildren();
    public Node getChildBefore(Node child);
    public void addChildToFront(Node child);
    public void addChildToBack(Node child);
    public void addChildrenToFront(Node children);
    public void addChildrenToBack(Node children);
    public void addChildBefore(Node newChild, Node node);
    public void addChildAfter(Node newChild, Node node);
    public void removeChild(Node child);
    public void replaceChild(Node child, Node newChild);
    public void replaceChildAfter(Node prevChild, Node newChild);
    private static string propToString(int propType);
    private PropListItem lookupProperty(int propType);
    private PropListItem ensureProperty(int propType);
    public void removeProp(int propType);
    public object getProp(int propType);
    public int getIntProp(int propType, int defaultValue);
    public int getExistingIntProp(int propType);
    public void putProp(int propType, object prop);
    public void putIntProp(int propType, int prop);
    public static Node newTarget();
    public int labelId();
    public void labelId(int labelId);
    public virtual string ToString();
    private void toString(ObjToIntMap printIds, StringBuilder sb);
    public string toStringTree(ScriptOrFnNode treeTop);
    private static void toStringTreeHelper(ScriptOrFnNode treeTop, Node n, ObjToIntMap printIds, int level, StringBuilder sb);
    private static void generatePrintIds(Node n, ObjToIntMap map);
    private static void appendPrintId(Node n, ObjToIntMap printIds, StringBuilder sb);
}
internal class EcmaScript.NET.NodeFactory : object {
    private Parser parser;
    private static int LOOP_DO_WHILE;
    private static int LOOP_WHILE;
    private static int LOOP_FOR;
    private static int ALWAYS_TRUE_BOOLEAN;
    private static int ALWAYS_FALSE_BOOLEAN;
    internal NodeFactory(Parser parser);
    internal ScriptOrFnNode CreateScript();
    internal void initScript(ScriptOrFnNode scriptNode, Node body);
    internal Node CreateLeaf(int nodeType);
    internal Node CreateLeaf(int nodeType, int nodeOp);
    internal Node CreateSwitch(Node expr, int lineno);
    internal void addSwitchCase(Node switchBlock, Node caseExpression, Node statements);
    internal void closeSwitch(Node switchBlock);
    internal Node CreateVariables(int lineno);
    internal Node CreateExprStatement(Node expr, int lineno);
    internal Node CreateExprStatementNoReturn(Node expr, int lineno);
    internal Node CreateDefaultNamespace(Node expr, int lineno);
    internal Node CreateName(string name);
    internal Node CreateString(string str);
    internal Node CreateNumber(double number);
    internal Node CreateCatch(string varName, Node catchCond, Node stmts, int lineno);
    internal Node CreateThrow(Node expr, int lineno);
    internal Node CreateReturn(Node expr, int lineno);
    internal Node CreateDebugger(int lineno);
    internal Node CreateLabel(int lineno);
    internal Node getLabelLoop(Node label);
    internal Node CreateLabeledStatement(Node labelArg, Node statement);
    internal Node CreateBreak(Node breakStatement, int lineno);
    internal Node CreateContinue(Node loop, int lineno);
    internal Node CreateBlock(int lineno);
    internal FunctionNode CreateFunction(string name);
    internal Node initFunction(FunctionNode fnNode, int functionIndex, Node statements, int functionType);
    internal void addChildToBack(Node parent, Node child);
    internal Node CreateLoopNode(Node loopLabel, int lineno);
    internal Node CreateWhile(Node loop, Node cond, Node body);
    internal Node CreateDoWhile(Node loop, Node body, Node cond);
    internal Node CreateFor(Node loop, Node init, Node test, Node incr, Node body);
    private Node CreateLoop(Jump loop, int loopType, Node body, Node cond, Node init, Node incr);
    internal Node CreateForIn(Node loop, Node lhs, Node obj, Node body, bool isForEach);
    internal Node CreateTryCatchFinally(Node tryBlock, Node catchBlocks, Node finallyBlock, int lineno);
    internal Node CreateWith(Node obj, Node body, int lineno);
    public Node CreateDotQuery(Node obj, Node body, int lineno);
    internal Node CreateArrayLiteral(ObjArray elems, int skipCount);
    internal Node CreateObjectLiteral(ObjArray elems);
    internal Node CreateRegExp(int regexpIndex);
    internal Node CreateIf(Node cond, Node ifTrue, Node ifFalse, int lineno);
    internal Node CreateCondExpr(Node cond, Node ifTrue, Node ifFalse);
    internal Node CreateUnary(int nodeType, Node child);
    internal Node CreateCallOrNew(int nodeType, Node child);
    internal Node CreateIncDec(int nodeType, bool post, Node child);
    internal Node CreatePropertyGet(Node target, string ns, string name, int memberTypeFlags);
    internal Node CreateElementGet(Node target, string ns, Node elem, int memberTypeFlags);
    private Node CreateMemberRefGet(Node target, string ns, Node elem, int memberTypeFlags);
    internal Node CreateBinary(int nodeType, Node left, Node right);
    private Node simpleAssignment(Node left, Node right);
    private void checkMutableReference(Node n);
    internal Node CreateAssignment(int assignType, Node left, Node right);
    internal Node CreateUseLocal(Node localBlock);
    private Jump makeJump(int type, Node target);
    private Node makeReference(Node node);
    private static int isAlwaysDefinedBoolean(Node node);
    private static bool hasSideEffects(Node exprTree);
    private void checkActivationName(string name, int token);
    private void setRequiresActivation();
}
public class EcmaScript.NET.NodeTransformer : object {
    private ObjArray loops;
    private ObjArray loopEnds;
    private bool hasFinally;
    public void transform(ScriptOrFnNode tree);
    private void transformCompilationUnit(ScriptOrFnNode tree);
    private void transformCompilationUnit_r(ScriptOrFnNode tree, Node parent);
    protected internal virtual void visitNew(Node node, ScriptOrFnNode tree);
    protected internal virtual void visitCall(Node node, ScriptOrFnNode tree);
    private static Node addBeforeCurrent(Node parent, Node previous, Node current, Node toAdd);
    private static Node replaceCurrent(Node parent, Node previous, Node current, Node replacement);
}
public class EcmaScript.NET.Parser : object {
    internal static int CLEAR_TI_MASK;
    internal static int TI_AFTER_EOL;
    internal static int TI_CHECK_LABEL;
    internal Regex SIMPLE_IDENTIFIER_NAME_PATTERN;
    internal CompilerEnvirons compilerEnv;
    private ErrorReporter errorReporter;
    private string sourceURI;
    internal bool calledByCompileFunction;
    private TokenStream ts;
    private int currentFlaggedToken;
    private int syntaxErrorCount;
    private NodeFactory nf;
    private int nestingOfFunction;
    private Decompiler decompiler;
    private string encodedSource;
    internal ScriptOrFnNode currentScriptOrFn;
    private int nestingOfWith;
    private Hashtable labelSet;
    private ObjArray loopSet;
    private ObjArray loopAndSwitchSet;
    private int currentStackIndex;
    public string EncodedSource { get; }
    public bool Eof { get; }
    public Parser(CompilerEnvirons compilerEnv, ErrorReporter errorReporter);
    public string get_EncodedSource();
    private Decompiler CreateDecompiler(CompilerEnvirons compilerEnv);
    internal void AddWarning(string messageId, string messageArg);
    internal void AddError(string messageId);
    internal Exception ReportError(string messageId);
    private int peekToken();
    private int peekFlaggedToken();
    private void consumeToken();
    private int nextToken();
    private int nextFlaggedToken();
    private bool matchToken(int toMatch);
    private int peekTokenOrEOL();
    private void setCheckForLabel();
    private void mustMatchToken(int toMatch, string messageId);
    private void mustHaveXML();
    public bool get_Eof();
    internal bool insideFunction();
    private Node enterLoop(Node loopLabel);
    private void exitLoop();
    private Node enterSwitch(Node switchSelector, int lineno, Node switchLabel);
    private void exitSwitch();
    public ScriptOrFnNode Parse(string sourceString, string sourceURI, int lineno);
    public ScriptOrFnNode Parse(StreamReader sourceReader, string sourceURI, int lineno);
    private ScriptOrFnNode Parse();
    private Node parseFunctionBody();
    private Node function(int functionType);
    private Node statements();
    private Node condition();
    private Node matchJumpLabelName();
    private Node statement();
    private Node statementHelper(Node statementLabel);
    private Node variables(bool inForInit);
    private Node expr(bool inForInit);
    private Node assignExpr(bool inForInit);
    private Node condExpr(bool inForInit);
    private Node orExpr(bool inForInit);
    private Node andExpr(bool inForInit);
    private Node bitOrExpr(bool inForInit);
    private Node bitXorExpr(bool inForInit);
    private Node bitAndExpr(bool inForInit);
    private Node eqExpr(bool inForInit);
    private Node relExpr(bool inForInit);
    private Node shiftExpr();
    private Node addExpr();
    private Node mulExpr();
    private Node unaryExpr();
    private Node xmlInitializer();
    private void argumentList(Node listNode);
    private Node memberExpr(bool allowCallSyntax);
    private Node memberExprTail(bool allowCallSyntax, Node pn);
    private Node attributeAccess(Node pn, int memberTypeFlags);
    private Node propertyName(Node pn, string name, int memberTypeFlags);
    private Node primaryExpr();
    private bool CheckForGetOrSet(ObjArray elems);
    private bool CheckForGetterOrSetter(ObjArray elems);
}
public enum EcmaScript.NET.RegExpActions : Enum {
    public int value__;
    public static RegExpActions None;
    public static RegExpActions Match;
    public static RegExpActions Replace;
    public static RegExpActions Search;
}
public interface EcmaScript.NET.RegExpProxy {
    public abstract virtual bool IsRegExp(IScriptable obj);
    public abstract virtual object Compile(Context cx, string source, string flags);
    public abstract virtual IScriptable Wrap(Context cx, IScriptable scope, object compiled);
    public abstract virtual object Perform(Context cx, IScriptable scope, IScriptable thisObj, Object[] args, RegExpActions actionType);
    public abstract virtual int FindSplit(Context cx, IScriptable scope, string target, string separator, IScriptable re, Int32[] ip, Int32[] matchlen, Boolean[] matched, String[][] parensp);
}
public abstract class EcmaScript.NET.ScriptableObject : object {
    public static int EMPTY;
    public static int READONLY;
    public static int DONTENUM;
    public static int PERMANENT;
    private IScriptable prototypeObject;
    private IScriptable parentScopeObject;
    private static object HAS_STATIC_ACCESSORS;
    private static Slot REMOVED;
    private Slot[] slots;
    private int count;
    private Slot lastAccess;
    private Hashtable modreq(System.Runtime.CompilerServices.IsVolatile) associatedValues;
    public string ClassName { get; }
    public IScriptable ParentScope { get; public set; }
    public Object[] AllIds { get; }
    public bool Sealed { get; }
    public ScriptableObject(IScriptable scope, IScriptable prototype);
    private static ScriptableObject();
    public abstract virtual string get_ClassName();
    public sealed virtual IScriptable get_ParentScope();
    public sealed virtual void set_ParentScope(IScriptable value);
    public virtual Object[] get_AllIds();
    public bool get_Sealed();
    internal static void CheckValidAttributes(int attributes);
    public virtual bool Has(string name, IScriptable start);
    public virtual bool Has(int index, IScriptable start);
    public virtual object Get(string name, IScriptable start);
    public virtual object Get(int index, IScriptable start);
    public virtual object Put(string name, IScriptable start, object value);
    public virtual object Put(int index, IScriptable start, object value);
    public virtual void Delete(string name);
    public virtual void Delete(int index);
    public virtual int GetAttributes(string name);
    public virtual int GetAttributes(int index);
    public virtual void SetAttributes(string name, int attributes);
    public virtual void SetAttributes(int index, int attributes);
    public virtual IScriptable GetPrototype();
    public virtual void SetPrototype(IScriptable m);
    public virtual Object[] GetIds();
    public virtual object GetDefaultValue(Type typeHint);
    public virtual bool HasInstance(IScriptable instance);
    protected internal virtual object EquivalentValues(object value);
    public virtual void DefineProperty(string propertyName, object value, int attributes);
    public static void DefineProperty(IScriptable destination, string propertyName, object value, int attributes);
    public static IScriptable GetObjectPrototype(IScriptable scope);
    public static IScriptable GetFunctionPrototype(IScriptable scope);
    public static IScriptable getClassPrototype(IScriptable scope, string className);
    public static IScriptable GetTopLevelScope(IScriptable obj);
    public virtual void SealObject();
    public static object GetProperty(IScriptable obj, string name);
    public static object GetProperty(IScriptable obj, int index);
    public static bool HasProperty(IScriptable obj, string name);
    public static bool HasProperty(IScriptable obj, int index);
    public static object PutProperty(IScriptable obj, string name, object value);
    public static object PutProperty(IScriptable obj, int index, object value);
    public static bool DeleteProperty(IScriptable obj, string name);
    public static bool DeleteProperty(IScriptable obj, int index);
    public static Object[] GetPropertyIds(IScriptable obj);
    public static object CallMethod(IScriptable obj, string methodName, Object[] args);
    public static object CallMethod(Context cx, IScriptable obj, string methodName, Object[] args);
    private static IScriptable GetBase(IScriptable obj, string name);
    private static IScriptable GetBase(IScriptable obj, int index);
    public object GetAssociatedValue(object key);
    public static object GetTopScopeValue(IScriptable scope, object key);
    public object AssociateValue(object key, object value);
    private object InitHash(Hashtable h, object key, object initialValue);
    private Slot GetNamedSlot(string name);
    private Slot GetSlot(string id, int index);
    private static int GetSlotPosition(Slot[] slots, string id, int index);
    private Slot AddSlot(string id, int index, Slot newSlot);
    private Slot AddSlotImpl(string id, int index, Slot newSlot);
    private void RemoveSlot(string name, int index);
    private void Grow();
    internal virtual Object[] GetIds(bool getAll);
    public virtual void DefineSetter(string name, ICallable setter);
    public virtual void DefineSetter(int index, ICallable setter);
    public virtual void DefineGetter(int index, ICallable getter);
    public virtual void DefineGetter(string name, ICallable getter);
    public virtual object LookupGetter(string name);
    public virtual object LookupSetter(string name);
}
public class EcmaScript.NET.ScriptConvert : object {
    internal static int XDigitToInt(int c, int accumulator);
    public static IScriptable ToObject(IScriptable scope, object val);
    public static IScriptable ToObjectOrNull(Context cx, object obj);
    public static IScriptable ToObject(Context cx, IScriptable scope, object val);
    public static double ToInteger(object val);
    public static double ToInteger(double d);
    public static double ToInteger(Object[] args, int index);
    public static int ToInt32(object val);
    public static int ToInt32(Object[] args, int index);
    public static int ToInt32(double d);
    public static long ToUint32(double d);
    public static long ToUint32(object val);
    public static bool ToBoolean(object val);
    public static bool ToBoolean(Object[] args, int index);
    public static double ToNumber(object val);
    public static double ToNumber(Object[] args, int index);
    internal static double ToNumber(string s, int start, int radix);
    public static string ToString(Object[] args, int index);
    internal static object ToPrimitive(object val);
    public static string ToString(object val);
    public static double ToNumber(string input);
    public static char ToUint16(object val);
    public static string ToString(double val);
    public static string ToString(double d, int toBase);
}
public class EcmaScript.NET.ScriptOrFnNode : Node {
    private int encodedSourceStart;
    private int encodedSourceEnd;
    private string sourceName;
    private int baseLineno;
    private int endLineno;
    private ObjArray functions;
    private ObjArray regexps;
    private ObjArray itsVariables;
    private ObjToIntMap itsVariableNames;
    private int varStart;
    private object compilerData;
    public string SourceName { get; public set; }
    public int EncodedSourceStart { get; }
    public int EncodedSourceEnd { get; }
    public int BaseLineno { get; public set; }
    public int EndLineno { get; public set; }
    public int FunctionCount { get; }
    public int RegexpCount { get; }
    public int ParamCount { get; }
    public int ParamAndVarCount { get; }
    public String[] ParamAndVarNames { get; }
    public object CompilerData { get; public set; }
    public ScriptOrFnNode(int nodeType);
    public virtual string get_SourceName();
    public virtual void set_SourceName(string value);
    public virtual int get_EncodedSourceStart();
    public virtual int get_EncodedSourceEnd();
    public virtual int get_BaseLineno();
    public virtual void set_BaseLineno(int value);
    public virtual int get_EndLineno();
    public virtual void set_EndLineno(int value);
    public virtual int get_FunctionCount();
    public virtual int get_RegexpCount();
    public virtual int get_ParamCount();
    public virtual int get_ParamAndVarCount();
    public virtual String[] get_ParamAndVarNames();
    public virtual object get_CompilerData();
    public virtual void set_CompilerData(object value);
    public void setEncodedSourceBounds(int start, int end);
    public FunctionNode getFunctionNode(int i);
    public int addFunction(FunctionNode fnNode);
    public string getRegexpString(int index);
    public string getRegexpFlags(int index);
    public int addRegexp(string str, string flags);
    public bool hasParamOrVar(string name);
    public int getParamOrVarIndex(string name);
    public string getParamOrVarName(int index);
    public void addParam(string name);
    public void addVar(string name);
    public void removeParamOrVar(string name);
}
public class EcmaScript.NET.ScriptRuntime : object {
    public static int MAXSTACKSIZE;
    private static string XML_INIT_CLASS;
    private static object LIBRARY_SCOPE_KEY;
    private static string DEFAULT_NS_TAG;
    private static ResourceManager m_ResourceManager;
    public static Object[] EmptyArgs;
    public static String[] EmptyStrings;
    private static ScriptRuntime();
    public static bool IsNativeRuntimeType(Type cl);
    public static ScriptableObject InitStandardObjects(Context cx, ScriptableObject scope, bool zealed);
    private static void InitItObject(Context cx, ScriptableObject scope);
    public static ScriptableObject getLibraryScopeOrNull(IScriptable scope);
    public static bool isJSLineTerminator(int c);
    public static Object[] padArguments(Object[] args, int count);
    public static string escapeString(string s);
    public static string escapeString(string s, char escapeQuote);
    internal static bool isValidIdentifierName(string s);
    internal static string DefaultObjectToString(IScriptable obj);
    internal static string uneval(Context cx, IScriptable scope, object value);
    internal static string defaultObjectToSource(Context cx, IScriptable scope, IScriptable thisObj, Object[] args);
    public static IScriptable NewObject(Context cx, IScriptable scope, string constructorName, Object[] args);
    public static object setDefaultNamespace(object ns, Context cx);
    public static object searchDefaultNamespace(Context cx);
    public static object getTopLevelProp(IScriptable scope, string id);
    internal static IFunction getExistingCtor(Context cx, IScriptable scope, string constructorName);
    private static long indexFromString(string str);
    public static long testUint32String(string str);
    internal static object getIndexObject(string s);
    internal static object getIndexObject(double d);
    internal static string ToStringIdOrIndex(Context cx, object id);
    public static object getObjectElem(object obj, object elem, Context cx);
    public static object getObjectElem(IScriptable obj, object elem, Context cx);
    public static object getObjectProp(object obj, string property, Context cx);
    public static object getObjectProp(IScriptable obj, string property, Context cx);
    public static object getObjectIndex(object obj, double dblIndex, Context cx);
    public static object getObjectIndex(IScriptable obj, int index, Context cx);
    public static object setObjectElem(object obj, object elem, object value, Context cx);
    public static object setObjectElem(IScriptable obj, object elem, object value, Context cx);
    public static object setObjectProp(object obj, string property, object value, Context cx);
    public static object setObjectProp(IScriptable obj, string property, object value, Context cx);
    public static object setObjectIndex(object obj, double dblIndex, object value, Context cx);
    public static object setObjectIndex(IScriptable obj, int index, object value, Context cx);
    public static bool deleteObjectElem(IScriptable target, object elem, Context cx);
    public static bool hasObjectElem(IScriptable target, object elem, Context cx);
    public static object refGet(IRef rf, Context cx);
    public static object refSet(IRef rf, object value, Context cx);
    public static object refDel(IRef rf, Context cx);
    internal static bool isSpecialProperty(string s);
    public static IRef specialRef(object obj, string specialProperty, Context cx);
    public static object delete(object obj, object id, Context cx);
    public static object name(Context cx, IScriptable scope, string name);
    private static object nameOrFunction(Context cx, IScriptable scope, IScriptable parentScope, string name, bool asFunctionCall);
    private static object topScopeName(Context cx, IScriptable scope, string name);
    public static IScriptable bind(Context cx, IScriptable scope, string id);
    public static object setName(IScriptable bound, object value, Context cx, IScriptable scope, string id);
    public static ICallable getNameFunctionAndThis(string name, Context cx, IScriptable scope);
    public static ICallable GetElemFunctionAndThis(object obj, object elem, Context cx);
    public static ICallable getPropFunctionAndThis(object obj, string property, Context cx);
    public static ICallable getValueFunctionAndThis(object value, Context cx);
    public static IRef callRef(ICallable function, IScriptable thisObj, Object[] args, Context cx);
    public static IScriptable NewObject(object fun, Context cx, IScriptable scope, Object[] args);
    public static object callSpecial(Context cx, ICallable fun, IScriptable thisObj, Object[] args, IScriptable scope, IScriptable callerThis, int callType, string filename, int lineNumber);
    public static object newSpecial(Context cx, object fun, Object[] args, IScriptable scope, int callType);
    public static object applyOrCall(bool isApply, Context cx, IScriptable scope, IScriptable thisObj, Object[] args);
    public static object evalSpecial(Context cx, IScriptable scope, object thisArg, Object[] args, string filename, int lineNumber);
    public static string Typeof(object value);
    internal static Exception errorWithClassName(string msg, object val);
    public static string TypeofName(IScriptable scope, string id);
    public static object Add(object val1, object val2, Context cx);
    public static object nameIncrDecr(IScriptable scopeChain, string id, int incrDecrMask);
    public static object propIncrDecr(object obj, string id, Context cx, int incrDecrMask);
    private static object doScriptableIncrDecr(IScriptable target, string id, IScriptable protoChainStart, object value, int incrDecrMask);
    public static object elemIncrDecr(object obj, object index, Context cx, int incrDecrMask);
    public static object refIncrDecr(IRef rf, Context cx, int incrDecrMask);
    public static bool eq(object x, object y);
    internal static bool eqNumber(double x, object y);
    private static bool eqString(string x, object y);
    public static bool shallowEq(object x, object y);
    public static bool InstanceOf(object a, object b, Context cx);
    protected internal static bool jsDelegatesTo(IScriptable lhs, IScriptable rhs);
    public static bool In(object a, object b, Context cx);
    public static bool cmp_LT(object val1, object val2);
    public static bool cmp_LE(object val1, object val2);
    public static bool hasTopCall(Context cx);
    public static IScriptable getTopCallScope(Context cx);
    public static object DoTopCall(ICallable callable, Context cx, IScriptable scope, IScriptable thisObj, Object[] args);
    internal static IScriptable checkDynamicScope(IScriptable possibleDynamicScope, IScriptable staticTopScope);
    public static void initScript(BuiltinFunction funObj, IScriptable thisObj, Context cx, IScriptable scope, bool evalScript);
    public static IScriptable createFunctionActivation(BuiltinFunction funObj, IScriptable scope, Object[] args);
    public static void enterActivationFunction(Context cx, IScriptable activation);
    public static void exitActivationFunction(Context cx);
    internal static BuiltinCall findFunctionActivation(Context cx, IFunction f);
    public static IScriptable NewCatchScope(Exception t, IScriptable lastCatchScope, string exceptionName, Context cx, IScriptable scope);
    public static IScriptable enterWith(object obj, Context cx, IScriptable scope);
    public static IScriptable leaveWith(IScriptable scope);
    public static IScriptable enterDotQuery(object value, IScriptable scope);
    public static object updateDotQuery(bool value, IScriptable scope);
    public static IScriptable leaveDotQuery(IScriptable scope);
    public static void setFunctionProtoAndParent(BaseFunction fn, IScriptable scope);
    public static void setObjectProtoAndParent(ScriptableObject obj, IScriptable scope);
    public static void initFunction(Context cx, IScriptable scope, BuiltinFunction function, int type, bool fromEvalCode);
    public static IScriptable newArrayLiteral(Object[] objects, Int32[] skipIndexces, Context cx, IScriptable scope);
    public static IScriptable newObjectLiteral(Object[] propertyIds, Object[] propertyValues, Context cx, IScriptable scope);
    public static bool isArrayObject(object obj);
    public static Object[] getArrayElements(IScriptable obj);
    internal static void checkDeprecated(Context cx, string name);
    public static string GetMessage(string messageId, Object[] arguments);
    public static EcmaScriptError ConstructError(string error, string message);
    public static EcmaScriptError ConstructError(string error, string message, string sourceName, int lineNumber, string lineSource, int columnNumber);
    public static EcmaScriptError TypeError(string message);
    public static EcmaScriptError TypeErrorById(string messageId, String[] args);
    public static Exception UndefReadError(object obj, object id);
    public static Exception UndefCallError(object obj, object id);
    public static Exception UndefWriteError(object obj, object id, object value);
    public static Exception NotFoundError(IScriptable obj, string property);
    public static Exception NotFunctionError(object value);
    public static Exception NotFunctionError(object value, object messageHelper);
    private static Exception NotXmlError(object value);
    internal static void WarnAboutNonJSObject(object nonJSObject);
    private static XMLLib CurrentXMLLib(Context cx);
    public static string escapeAttributeValue(object value, Context cx);
    public static string escapeTextValue(object value, Context cx);
    public static IRef memberRef(object obj, object elem, Context cx, int memberTypeFlags);
    public static IRef memberRef(object obj, object ns, object elem, Context cx, int memberTypeFlags);
    public static IRef nameRef(object name, Context cx, IScriptable scope, int memberTypeFlags);
    public static IRef nameRef(object ns, object name, Context cx, IScriptable scope, int memberTypeFlags);
    private static void storeIndexResult(Context cx, int index);
    internal static int lastIndexResult(Context cx);
    public static void storeUint32Result(Context cx, long value);
    public static long lastUint32Result(Context cx);
    private static void storeScriptable(Context cx, IScriptable value);
    public static IScriptable lastStoredScriptable(Context cx);
    internal static string makeUrlForGeneratedScript(bool isEval, string masterScriptUrl, int masterScriptLine);
    internal static bool isGeneratedScript(string sourceUrl);
}
public abstract class EcmaScript.NET.SecurityController : object {
    private static SecurityController m_Global;
    internal static SecurityController Global { get; }
    internal static SecurityController get_Global();
    public static bool HasGlobal();
    public static void initGlobal(SecurityController controller);
    public abstract virtual object getDynamicSecurityDomain(object securityDomain);
    public abstract virtual object callWithDomain(object securityDomain, Context cx, ICallable callable, IScriptable scope, IScriptable thisObj, Object[] args);
}
internal class EcmaScript.NET.SpecialRef : object {
    private IScriptable target;
    private Types type;
    private string name;
    private SpecialRef(IScriptable target, Types type, string name);
    internal static IRef createSpecial(Context cx, object obj, string name);
    public sealed virtual object Get(Context cx);
    public sealed virtual object Set(Context cx, object value);
    public sealed virtual bool Has(Context cx);
    public sealed virtual bool Delete(Context cx);
}
public class EcmaScript.NET.Token : object {
    internal static bool printTrees;
    internal static bool printICode;
    internal static bool printNames;
    public static int ERROR;
    public static int EOF;
    public static int EOL;
    public static int FIRST_BYTECODE_TOKEN;
    public static int ENTERWITH;
    public static int LEAVEWITH;
    public static int RETURN;
    public static int GOTO;
    public static int IFEQ;
    public static int IFNE;
    public static int SETNAME;
    public static int BITOR;
    public static int BITXOR;
    public static int BITAND;
    public static int EQ;
    public static int NE;
    public static int LT;
    public static int LE;
    public static int GT;
    public static int GE;
    public static int LSH;
    public static int RSH;
    public static int URSH;
    public static int ADD;
    public static int SUB;
    public static int MUL;
    public static int DIV;
    public static int MOD;
    public static int NOT;
    public static int BITNOT;
    public static int POS;
    public static int NEG;
    public static int NEW;
    public static int DELPROP;
    public static int TYPEOF;
    public static int GETPROP;
    public static int SETPROP;
    public static int GETELEM;
    public static int SETELEM;
    public static int CALL;
    public static int NAME;
    public static int NUMBER;
    public static int STRING;
    public static int NULL;
    public static int THIS;
    public static int FALSE;
    public static int TRUE;
    public static int SHEQ;
    public static int SHNE;
    public static int REGEXP;
    public static int BINDNAME;
    public static int THROW;
    public static int RETHROW;
    public static int IN;
    public static int INSTANCEOF;
    public static int LOCAL_LOAD;
    public static int GETVAR;
    public static int SETVAR;
    public static int CATCH_SCOPE;
    public static int ENUM_INIT_KEYS;
    public static int ENUM_INIT_VALUES;
    public static int ENUM_NEXT;
    public static int ENUM_ID;
    public static int THISFN;
    public static int RETURN_RESULT;
    public static int ARRAYLIT;
    public static int OBJECTLIT;
    public static int GET_REF;
    public static int SET_REF;
    public static int DEL_REF;
    public static int REF_CALL;
    public static int REF_SPECIAL;
    public static int DEFAULTNAMESPACE;
    public static int ESCXMLATTR;
    public static int ESCXMLTEXT;
    public static int REF_MEMBER;
    public static int REF_NS_MEMBER;
    public static int REF_NAME;
    public static int REF_NS_NAME;
    public static int SETPROP_GETTER;
    public static int SETPROP_SETTER;
    public static int LAST_BYTECODE_TOKEN;
    public static int TRY;
    public static int SEMI;
    public static int LB;
    public static int RB;
    public static int LC;
    public static int RC;
    public static int LP;
    public static int RP;
    public static int COMMA;
    public static int ASSIGN;
    public static int ASSIGN_BITOR;
    public static int ASSIGN_BITXOR;
    public static int ASSIGN_BITAND;
    public static int ASSIGN_LSH;
    public static int ASSIGN_RSH;
    public static int ASSIGN_URSH;
    public static int ASSIGN_ADD;
    public static int ASSIGN_SUB;
    public static int ASSIGN_MUL;
    public static int ASSIGN_DIV;
    public static int ASSIGN_MOD;
    public static int FIRST_ASSIGN;
    public static int LAST_ASSIGN;
    public static int HOOK;
    public static int COLON;
    public static int OR;
    public static int AND;
    public static int INC;
    public static int DEC;
    public static int DOT;
    public static int FUNCTION;
    public static int EXPORT;
    public static int IMPORT;
    public static int IF;
    public static int ELSE;
    public static int SWITCH;
    public static int CASE;
    public static int DEFAULT;
    public static int WHILE;
    public static int DO;
    public static int FOR;
    public static int BREAK;
    public static int CONTINUE;
    public static int VAR;
    public static int WITH;
    public static int CATCH;
    public static int FINALLY;
    public static int VOID;
    public static int RESERVED;
    public static int EMPTY;
    public static int BLOCK;
    public static int LABEL;
    public static int TARGET;
    public static int LOOP;
    public static int EXPR_VOID;
    public static int EXPR_RESULT;
    public static int JSR;
    public static int SCRIPT;
    public static int TYPEOFNAME;
    public static int USE_STACK;
    public static int SETPROP_OP;
    public static int SETELEM_OP;
    public static int LOCAL_BLOCK;
    public static int SET_REF_OP;
    public static int DOTDOT;
    public static int COLONCOLON;
    public static int XML;
    public static int DOTQUERY;
    public static int XMLATTR;
    public static int XMLEND;
    public static int TO_OBJECT;
    public static int TO_DOUBLE;
    public static int GET;
    public static int SET;
    public static int CONST;
    public static int SETCONST;
    public static int SETCONSTVAR;
    public static int CONDCOMMENT;
    public static int KEEPCOMMENT;
    public static int DEBUGGER;
    public static int LAST_TOKEN;
    private static Token();
    public static string name(int token);
}
internal class EcmaScript.NET.TokenStream : object {
    private static int EOF_CHAR;
    private static int Id_break;
    private static int Id_case;
    private static int Id_continue;
    private static int Id_default;
    private static int Id_delete;
    private static int Id_do;
    private static int Id_else;
    private static int Id_export;
    private static int Id_false;
    private static int Id_for;
    private static int Id_function;
    private static int Id_if;
    private static int Id_in;
    private static int Id_new;
    private static int Id_null;
    private static int Id_return;
    private static int Id_switch;
    private static int Id_this;
    private static int Id_true;
    private static int Id_typeof;
    private static int Id_var;
    private static int Id_void;
    private static int Id_while;
    private static int Id_with;
    private static int Id_abstract;
    private static int Id_boolean;
    private static int Id_byte;
    private static int Id_catch;
    private static int Id_char;
    private static int Id_class;
    private static int Id_const;
    private static int Id_debugger;
    private static int Id_double;
    private static int Id_enum;
    private static int Id_extends;
    private static int Id_final;
    private static int Id_finally;
    private static int Id_float;
    private static int Id_goto;
    private static int Id_implements;
    private static int Id_import;
    private static int Id_instanceof;
    private static int Id_int;
    private static int Id_interface;
    private static int Id_long;
    private static int Id_native;
    private static int Id_package;
    private static int Id_private;
    private static int Id_protected;
    private static int Id_public;
    private static int Id_short;
    private static int Id_static;
    private static int Id_super;
    private static int Id_synchronized;
    private static int Id_throw;
    private static int Id_throws;
    private static int Id_transient;
    private static int Id_try;
    private static int Id_volatile;
    private bool dirtyLine;
    internal string regExpFlags;
    private string str;
    private double dNumber;
    private string tokenstr;
    private Char[] stringBuffer;
    private int stringBufferTop;
    private ObjToIntMap allStrings;
    private Int32[] ungetBuffer;
    private int ungetCursor;
    private bool hitEOF;
    private int lineStart;
    private int lineno;
    private int lineEndChar;
    private string sourceString;
    private StreamReader sourceReader;
    private Char[] sourceBuffer;
    private int sourceEnd;
    private int sourceCursor;
    private bool xmlIsAttribute;
    private bool xmlIsTagContent;
    private int xmlOpenTagsCount;
    private Parser parser;
    internal int Lineno { get; }
    internal string String { get; }
    internal string TokenString { get; }
    internal double Number { get; }
    internal int Token { get; }
    internal bool XMLAttribute { get; }
    internal int FirstXMLToken { get; }
    internal int NextXMLToken { get; }
    private string StringFromBuffer { get; }
    private int Char { get; }
    internal int Offset { get; }
    internal string Line { get; }
    internal TokenStream(Parser parser, StreamReader sourceReader, string sourceString, int lineno);
    internal int get_Lineno();
    internal string get_String();
    internal string get_TokenString();
    internal double get_Number();
    internal int get_Token();
    internal bool get_XMLAttribute();
    internal int get_FirstXMLToken();
    internal int get_NextXMLToken();
    private string get_StringFromBuffer();
    private int get_Char();
    internal int get_Offset();
    internal string get_Line();
    internal string tokenToString(int token);
    internal static bool isKeyword(string s);
    private static int stringToKeyword(string name);
    internal bool eof();
    private static bool isAlpha(int c);
    internal static bool isDigit(int c);
    internal static bool isJSSpace(int c);
    private static bool isJSFormatChar(int c);
    internal void readRegExp(int startToken);
    private bool readQuotedString(int quote);
    private bool readXmlComment();
    private bool readCDATA();
    private bool readEntity();
    private bool readPI();
    private void addToString(int c);
    private void ungetChar(int c);
    private bool matchChar(int test);
    private int peekChar();
    private void skipLine();
    private bool fillSourceBuffer();
    internal static bool IsJavaIdentifierPart(char c);
    internal static bool IsIdentifierIgnorable(char c);
    internal static bool IsJavaIdentifierStart(char c);
}
public class EcmaScript.NET.Types.BuiltinArray : IdScriptableObject {
    private long length;
    private Object[] dense;
    private static int maximumDenseLength;
    private static object ARRAY_TAG;
    private static int Id_length;
    private static int MAX_INSTANCE_ID;
    private static int Id_constructor;
    private static int Id_toString;
    private static int Id_toLocaleString;
    private static int Id_toSource;
    private static int Id_join;
    private static int Id_reverse;
    private static int Id_sort;
    private static int Id_push;
    private static int Id_pop;
    private static int Id_shift;
    private static int Id_unshift;
    private static int Id_splice;
    private static int Id_concat;
    private static int Id_slice;
    private static int MAX_PROTOTYPE_ID;
    public string ClassName { get; }
    protected internal int MaxInstanceId { get; }
    public BuiltinArray(long length);
    public BuiltinArray(Object[] array);
    private static BuiltinArray();
    public virtual string get_ClassName();
    protected internal virtual int get_MaxInstanceId();
    internal static void Init(IScriptable scope, bool zealed);
    protected internal virtual int FindInstanceIdInfo(string s);
    protected internal virtual string GetInstanceIdName(int id);
    protected internal virtual object GetInstanceIdValue(int id);
    protected internal virtual void SetInstanceIdValue(int id, object value);
    protected internal virtual void InitPrototypeId(int id);
    public virtual object ExecIdCall(IdFunctionObject f, Context cx, IScriptable scope, IScriptable thisObj, Object[] args);
    public virtual object Get(int index, IScriptable start);
    public virtual bool Has(int index, IScriptable start);
    private static long toArrayIndex(string id);
    public virtual object Put(string id, IScriptable start, object value);
    public virtual object Put(int index, IScriptable start, object value);
    public virtual void Delete(int index);
    public virtual Object[] GetIds();
    public virtual object GetDefaultValue(Type hint);
    private static object ImplCtor(Context cx, IScriptable scope, Object[] args);
    private static long VerifyOutOfRange(long newLen);
    private static long VerifyOutOfRange(object newLen);
    public virtual long getLength();
    private void setLength(object val);
    internal static long getLengthProperty(Context cx, IScriptable obj);
    private static object setLengthProperty(Context cx, IScriptable target, long length);
    private static void deleteElem(IScriptable target, long index);
    private static object getElem(Context cx, IScriptable target, long index);
    private static void setElem(Context cx, IScriptable target, long index, object value);
    private static string toStringHelper(Context cx, IScriptable scope, IScriptable thisObj, bool toSource, bool toLocale);
    private static string ImplJoin(Context cx, IScriptable thisObj, Object[] args);
    private static IScriptable ImplReverse(Context cx, IScriptable thisObj, Object[] args);
    private static IScriptable ImplSort(Context cx, IScriptable scope, IScriptable thisObj, Object[] args);
    private static bool IsBigger(Context cx, IScriptable scope, object x, object y, object cmp, Object[] cmpBuf);
    private static void heapsort(Context cx, IScriptable scope, Object[] array, int length, object cmp, Object[] cmpBuf);
    private static void heapify(Context cx, IScriptable scope, object pivot, Object[] array, int i, int end, object cmp, Object[] cmpBuf);
    private static void heapsort_extended(Context cx, IScriptable scope, IScriptable target, long length, object cmp, Object[] cmpBuf);
    private static void heapify_extended(Context cx, IScriptable scope, object pivot, IScriptable target, long i, long end, object cmp, Object[] cmpBuf);
    private static object ImplPush(Context cx, IScriptable thisObj, Object[] args);
    private static object ImplPop(Context cx, IScriptable thisObj, Object[] args);
    private static object ImplShift(Context cx, IScriptable thisObj, Object[] args);
    private static object ImplUnshift(Context cx, IScriptable thisObj, Object[] args);
    private static object ImplSplice(Context cx, IScriptable scope, IScriptable thisObj, Object[] args);
    private static IScriptable ImplConcat(Context cx, IScriptable scope, IScriptable thisObj, Object[] args);
    private IScriptable ImplSlice(Context cx, IScriptable thisObj, Object[] args);
    private static long toSliceIndex(double value, long length);
    protected internal virtual int FindPrototypeId(string s);
}
internal class EcmaScript.NET.Types.BuiltinBoolean : IdScriptableObject {
    private static object BOOLEAN_TAG;
    private static int Id_constructor;
    private static int Id_toString;
    private static int Id_toSource;
    private static int Id_valueOf;
    private static int MAX_PROTOTYPE_ID;
    private bool booleanValue;
    public string ClassName { get; }
    private BuiltinBoolean(bool b);
    private static BuiltinBoolean();
    public virtual string get_ClassName();
    internal static void Init(IScriptable scope, bool zealed);
    public virtual object GetDefaultValue(Type typeHint);
    protected internal virtual void InitPrototypeId(int id);
    public virtual object ExecIdCall(IdFunctionObject f, Context cx, IScriptable scope, IScriptable thisObj, Object[] args);
    protected internal virtual int FindPrototypeId(string s);
}
public class EcmaScript.NET.Types.BuiltinCall : IdScriptableObject {
    private static object CALL_TAG;
    private static int Id_constructor;
    private static int MAX_PROTOTYPE_ID;
    internal BuiltinFunction function;
    internal Object[] originalArgs;
    internal BuiltinCall parentActivationCall;
    public string ClassName { get; }
    internal BuiltinCall(BuiltinFunction function, IScriptable scope, Object[] args);
    private static BuiltinCall();
    public virtual string get_ClassName();
    internal static void Init(IScriptable scope, bool zealed);
    protected internal virtual int FindPrototypeId(string s);
    protected internal virtual void InitPrototypeId(int id);
    public virtual object ExecIdCall(IdFunctionObject f, Context cx, IScriptable scope, IScriptable thisObj, Object[] args);
}
internal class EcmaScript.NET.Types.BuiltinDate : IdScriptableObject {
    private static object DATE_TAG;
    private static string js_NaN_date_str;
    private static double HalfTimeDomain;
    private static double HoursPerDay;
    private static double MinutesPerHour;
    private static double SecondsPerMinute;
    private static double msPerSecond;
    private static double MinutesPerDay;
    private static double SecondsPerDay;
    private static double SecondsPerHour;
    private static double msPerDay;
    private static double msPerHour;
    private static double msPerMinute;
    private static int MAXARGS;
    private static int ConstructorId_now;
    private static int ConstructorId_parse;
    private static int ConstructorId_UTC;
    private static int Id_constructor;
    private static int Id_toString;
    private static int Id_toTimeString;
    private static int Id_toDateString;
    private static int Id_toLocaleString;
    private static int Id_toLocaleTimeString;
    private static int Id_toLocaleDateString;
    private static int Id_toUTCString;
    private static int Id_toGMTString;
    private static int Id_toSource;
    private static int Id_valueOf;
    private static int Id_getTime;
    private static int Id_getYear;
    private static int Id_getFullYear;
    private static int Id_getUTCFullYear;
    private static int Id_getMonth;
    private static int Id_getUTCMonth;
    private static int Id_getDate;
    private static int Id_getUTCDate;
    private static int Id_getDay;
    private static int Id_getUTCDay;
    private static int Id_getHours;
    private static int Id_getUTCHours;
    private static int Id_getMinutes;
    private static int Id_getUTCMinutes;
    private static int Id_getSeconds;
    private static int Id_getUTCSeconds;
    private static int Id_getMilliseconds;
    private static int Id_getUTCMilliseconds;
    private static int Id_getTimezoneOffset;
    private static int Id_setTime;
    private static int Id_setMilliseconds;
    private static int Id_setUTCMilliseconds;
    private static int Id_setSeconds;
    private static int Id_setUTCSeconds;
    private static int Id_setMinutes;
    private static int Id_setUTCMinutes;
    private static int Id_setHours;
    private static int Id_setUTCHours;
    private static int Id_setDate;
    private static int Id_setUTCDate;
    private static int Id_setMonth;
    private static int Id_setUTCMonth;
    private static int Id_setFullYear;
    private static int Id_setUTCFullYear;
    private static int Id_setYear;
    private static int MAX_PROTOTYPE_ID;
    private static TimeZone thisTimeZone;
    private static double LocalTZA;
    private double date;
    private static DateTime StandardBaseTime;
    public string ClassName { get; }
    internal double JSTimeValue { get; }
    private static BuiltinDate();
    public virtual string get_ClassName();
    internal double get_JSTimeValue();
    internal static void Init(IScriptable scope, bool zealed);
    public virtual object GetDefaultValue(Type typeHint);
    protected internal virtual void FillConstructorProperties(IdFunctionObject ctor);
    protected internal virtual void InitPrototypeId(int id);
    public virtual object ExecIdCall(IdFunctionObject f, Context cx, IScriptable scope, IScriptable thisObj, Object[] args);
    private static double Day(double t);
    private static double TimeWithinDay(double t);
    private static bool IsLeapYear(int year);
    private static double DayFromYear(double y);
    private static double TimeFromYear(double y);
    private static int YearFromTime(double t);
    private static bool InLeapYear(double t);
    private static double DayFromMonth(int m, int year);
    private static int MonthFromTime(double t);
    private static int DateFromTime(double t);
    private static int WeekDay(double t);
    private static double now();
    private static double DaylightSavingTA(double t);
    private static int EquivalentYear(int year);
    private static double LocalTime(double t);
    private static double internalUTC(double t);
    private static int HourFromTime(double t);
    private static int MinFromTime(double t);
    private static int SecFromTime(double t);
    private static int msFromTime(double t);
    private static double MakeTime(double hour, double min, double sec, double ms);
    private static double MakeDay(double year, double month, double date);
    private static double MakeDate(double day, double time);
    private static double TimeClip(double d);
    private static double date_msecFromDate(double year, double mon, double mday, double hour, double min, double sec, double msec);
    private static double jsStaticFunction_UTC(Object[] args);
    public static double date_parseString(string s);
    private static string date_format(double t, int methodId);
    private static object jsConstructor(Object[] args);
    private static string toLocale_helper(double t, int methodId);
    private static string js_toUTCString(double date);
    private static void append0PaddedUint(StringBuilder sb, int i, int minWidth);
    private static void appendMonthName(StringBuilder sb, int index);
    private static void appendWeekDayName(StringBuilder sb, int index);
    private static double makeTime(double date, Object[] args, int methodId);
    private static double makeDate(double date, Object[] args, int methodId);
    protected internal virtual int FindPrototypeId(string s);
    internal static DateTime FromMilliseconds(double ms);
}
internal class EcmaScript.NET.Types.BuiltinError : IdScriptableObject {
    private static object ERROR_TAG;
    private static int Id_constructor;
    private static int Id_toString;
    private static int Id_toSource;
    private static int MAX_PROTOTYPE_ID;
    public string ClassName { get; }
    private static BuiltinError();
    public virtual string get_ClassName();
    internal static void Init(IScriptable scope, bool zealed);
    internal static BuiltinError make(Context cx, IScriptable scope, IdFunctionObject ctorObj, Object[] args);
    public virtual string ToString();
    protected internal virtual void InitPrototypeId(int id);
    public virtual object ExecIdCall(IdFunctionObject f, Context cx, IScriptable scope, IScriptable thisObj, Object[] args);
    private static string js_toString(IScriptable thisObj);
    private static string js_toSource(Context cx, IScriptable scope, IScriptable thisObj);
    private static string getString(IScriptable obj, string id);
    protected internal virtual int FindPrototypeId(string s);
}
public abstract class EcmaScript.NET.Types.BuiltinFunction : BaseFunction {
    public int Length { get; }
    public int Arity { get; }
    public string EncodedSource { get; }
    public DebuggableScript DebuggableView { get; }
    protected internal Versions LanguageVersion { get; }
    protected internal int ParamCount { get; }
    protected internal int ParamAndVarCount { get; }
    public virtual int get_Length();
    public virtual int get_Arity();
    public virtual string get_EncodedSource();
    public virtual DebuggableScript get_DebuggableView();
    protected internal abstract virtual Versions get_LanguageVersion();
    protected internal abstract virtual int get_ParamCount();
    protected internal abstract virtual int get_ParamAndVarCount();
    public void initScriptFunction(Context cx, IScriptable scope);
    internal virtual string Decompile(int indent, int flags);
    protected internal abstract virtual string getParamOrVarName(int index);
}
public class EcmaScript.NET.Types.BuiltinGlobal : object {
    private static string URI_DECODE_RESERVED;
    private static object FTAG;
    private static int Id_decodeURI;
    private static int Id_decodeURIComponent;
    private static int Id_encodeURI;
    private static int Id_encodeURIComponent;
    private static int Id_escape;
    private static int Id_eval;
    private static int Id_isFinite;
    private static int Id_isNaN;
    private static int Id_isXMLName;
    private static int Id_parseFloat;
    private static int Id_parseInt;
    private static int Id_unescape;
    private static int Id_uneval;
    private static int LAST_SCOPE_FUNCTION_ID;
    private static int Id_new_CommonError;
    private static BuiltinGlobal();
    public static void Init(Context cx, IScriptable scope, bool zealed);
    public virtual object ExecIdCall(IdFunctionObject f, Context cx, IScriptable scope, IScriptable thisObj, Object[] args);
    private object js_parseInt(Object[] args);
    private object js_parseFloat(Object[] args);
    private object js_escape(Object[] args);
    private object js_unescape(Object[] args);
    private object ImplEval(Context cx, IScriptable scope, IScriptable thisObj, Object[] args);
    internal static bool isEvalFunction(object functionObj);
    private static string encode(string str, bool fullUri);
    private static char toHexChar(int i);
    private static int unHex(char c);
    private static int unHex(char c1, char c2);
    private static string decode(string str, bool fullUri);
    private static bool encodeUnescaped(char c, bool fullUri);
    private static int oneUcs4ToUtf8Char(SByte[] utf8Buffer, int ucs4Char);
}
public class EcmaScript.NET.Types.BuiltinGlobalObject : IdScriptableObject {
    private static object GLOBALOBJECT_TAG;
    private static int Id_print;
    private static int Id_version;
    private static int Id_options;
    private static int Id_gc;
    private static int MAX_PROTOTYPE_ID;
    public string ClassName { get; }
    private static BuiltinGlobalObject();
    public virtual string get_ClassName();
    public virtual object ExecIdCall(IdFunctionObject f, Context cx, IScriptable scope, IScriptable thisObj, Object[] args);
    protected internal virtual void InitPrototypeId(int id);
    internal virtual Object[] GetIds(bool getAll);
    public void Init(IScriptable scope, bool zealed);
    protected internal virtual int FindPrototypeId(string s);
    private int HideIfNotSet(int id);
    private int HideIfNotSet(Features feature, int id, int requiredId);
}
internal class EcmaScript.NET.Types.BuiltinMath : IdScriptableObject {
    private static double NET_WORKAROUND_1;
    private static double NET_WORKAROUND_2;
    private static double NET_WORKAROUND_3;
    private static double NET_WORKAROUND_4;
    private static object MATH_TAG;
    private static int Id_toSource;
    private static int Id_abs;
    private static int Id_acos;
    private static int Id_asin;
    private static int Id_atan;
    private static int Id_atan2;
    private static int Id_ceil;
    private static int Id_cos;
    private static int Id_exp;
    private static int Id_floor;
    private static int Id_log;
    private static int Id_max;
    private static int Id_min;
    private static int Id_pow;
    private static int Id_random;
    private static int Id_round;
    private static int Id_sin;
    private static int Id_sqrt;
    private static int Id_tan;
    private static int LAST_METHOD_ID;
    private static int Id_E;
    private static int Id_PI;
    private static int Id_LN10;
    private static int Id_LN2;
    private static int Id_LOG2E;
    private static int Id_LOG10E;
    private static int Id_SQRT1_2;
    private static int Id_SQRT2;
    private static int MAX_ID;
    public string ClassName { get; }
    private static BuiltinMath();
    public virtual string get_ClassName();
    internal static void Init(IScriptable scope, bool zealed);
    protected internal virtual void InitPrototypeId(int id);
    public virtual object ExecIdCall(IdFunctionObject f, Context cx, IScriptable scope, IScriptable thisObj, Object[] args);
    private double js_pow(double x, double y);
    protected internal virtual int FindPrototypeId(string s);
}
internal class EcmaScript.NET.Types.BuiltinNumber : IdScriptableObject {
    internal static int DTOSTR_STANDARD;
    internal static int DTOSTR_STANDARD_EXPONENTIAL;
    internal static int DTOSTR_FIXED;
    internal static int DTOSTR_EXPONENTIAL;
    internal static int DTOSTR_PRECISION;
    public static double NaN;
    public static double POSITIVE_INFINITY;
    public static double NEGATIVE_INFINITY;
    public static double MAX_VALUE;
    public static double MIN_VALUE;
    public static double NegativeZero;
    private static object NUMBER_TAG;
    private static int MAX_PRECISION;
    private static NumberFormatInfo m_NumberFormatter;
    private static int Id_constructor;
    private static int Id_toString;
    private static int Id_toLocaleString;
    private static int Id_toSource;
    private static int Id_valueOf;
    private static int Id_toFixed;
    private static int Id_toExponential;
    private static int Id_toPrecision;
    private static int MAX_PROTOTYPE_ID;
    private double doubleValue;
    public string ClassName { get; }
    public static NumberFormatInfo NumberFormatter { get; }
    private BuiltinNumber(double number);
    private static BuiltinNumber();
    public virtual string get_ClassName();
    internal static void Init(IScriptable scope, bool zealed);
    protected internal virtual void FillConstructorProperties(IdFunctionObject ctor);
    protected internal virtual void InitPrototypeId(int id);
    public virtual object ExecIdCall(IdFunctionObject f, Context cx, IScriptable scope, IScriptable thisObj, Object[] args);
    private static string GetFormatString(int precision);
    public virtual string ToString();
    public static NumberFormatInfo get_NumberFormatter();
    private static string num_to(double val, Object[] args, int zeroArgMode, int oneArgMode, int precisionMin, int precisionOffset);
    protected internal virtual int FindPrototypeId(string s);
}
public class EcmaScript.NET.Types.BuiltinObject : IdScriptableObject {
    private static object OBJECT_TAG;
    private static int Id_constructor;
    private static int Id_toString;
    private static int Id_toLocaleString;
    private static int Id_valueOf;
    private static int Id_hasOwnProperty;
    private static int Id_propertyIsEnumerable;
    private static int Id_isPrototypeOf;
    private static int Id_toSource;
    private static int Id___defineGetter__;
    private static int Id___defineSetter__;
    private static int Id___lookupGetter__;
    private static int Id___lookupSetter__;
    private static int MAX_PROTOTYPE_ID;
    public string ClassName { get; }
    private static BuiltinObject();
    public virtual string get_ClassName();
    internal static void Init(IScriptable scope, bool zealed);
    public virtual string ToString();
    protected internal virtual void InitPrototypeId(int id);
    public virtual object ExecIdCall(IdFunctionObject f, Context cx, IScriptable scope, IScriptable thisObj, Object[] args);
    protected internal virtual int FindPrototypeId(string s);
}
internal class EcmaScript.NET.Types.BuiltinScript : BaseFunction {
    private static object SCRIPT_TAG;
    private static int Id_constructor;
    private static int Id_toString;
    private static int Id_compile;
    private static int Id_exec;
    private static int MAX_PROTOTYPE_ID;
    private IScript script;
    public string ClassName { get; }
    public int Length { get; }
    public int Arity { get; }
    private BuiltinScript(IScript script);
    private static BuiltinScript();
    public virtual string get_ClassName();
    public virtual int get_Length();
    public virtual int get_Arity();
    internal static void Init(IScriptable scope, bool zealed);
    public virtual object Call(Context cx, IScriptable scope, IScriptable thisObj, Object[] args);
    public virtual IScriptable Construct(Context cx, IScriptable scope, Object[] args);
    internal virtual string Decompile(int indent, int flags);
    protected internal virtual void InitPrototypeId(int id);
    public virtual object ExecIdCall(IdFunctionObject f, Context cx, IScriptable scope, IScriptable thisObj, Object[] args);
    private static BuiltinScript realThis(IScriptable thisObj, IdFunctionObject f);
    private static IScript compile(Context cx, string source);
    protected internal virtual int FindPrototypeId(string s);
}
internal class EcmaScript.NET.Types.BuiltinString : IdScriptableObject {
    private static object STRING_TAG;
    private static int Id_length;
    private static int MAX_INSTANCE_ID;
    private static int ConstructorId_fromCharCode;
    private static int Id_constructor;
    private static int Id_toString;
    private static int Id_toSource;
    private static int Id_valueOf;
    private static int Id_charAt;
    private static int Id_charCodeAt;
    private static int Id_indexOf;
    private static int Id_lastIndexOf;
    private static int Id_split;
    private static int Id_substring;
    private static int Id_toLowerCase;
    private static int Id_toUpperCase;
    private static int Id_substr;
    private static int Id_concat;
    private static int Id_slice;
    private static int Id_bold;
    private static int Id_italics;
    private static int Id_fixed;
    private static int Id_strike;
    private static int Id_small;
    private static int Id_big;
    private static int Id_blink;
    private static int Id_sup;
    private static int Id_sub;
    private static int Id_fontsize;
    private static int Id_fontcolor;
    private static int Id_link;
    private static int Id_anchor;
    private static int Id_equals;
    private static int Id_equalsIgnoreCase;
    private static int Id_match;
    private static int Id_search;
    private static int Id_replace;
    private static int MAX_PROTOTYPE_ID;
    private string m_Value;
    public string ClassName { get; }
    protected internal int MaxInstanceId { get; }
    internal int Length { get; }
    private BuiltinString(string s);
    private static BuiltinString();
    public virtual string get_ClassName();
    protected internal virtual int get_MaxInstanceId();
    internal int get_Length();
    internal static void Init(IScriptable scope, bool zealed);
    protected internal virtual int FindInstanceIdInfo(string s);
    protected internal virtual string GetInstanceIdName(int id);
    protected internal virtual object GetInstanceIdValue(int id);
    protected internal virtual void FillConstructorProperties(IdFunctionObject ctor);
    protected internal virtual void InitPrototypeId(int id);
    public virtual object ExecIdCall(IdFunctionObject f, Context cx, IScriptable scope, IScriptable thisObj, Object[] args);
    private static BuiltinString RealThis(IScriptable thisObj, IdFunctionObject f);
    private static string Tagify(object thisObj, string tag, string attribute, Object[] args);
    public virtual string ToString();
    public virtual object Get(int index, IScriptable start);
    public virtual object Put(int index, IScriptable start, object value);
    private static int js_indexOf(string target, Object[] args);
    private static int js_lastIndexOf(string target, Object[] args);
    private static int lastIndexOf(Char[] source, int sourceOffset, int sourceCount, Char[] target, int targetOffset, int targetCount, int fromIndex);
    private static int find_split(Context cx, IScriptable scope, string target, string separator, Versions version, RegExpProxy reProxy, IScriptable re, Int32[] ip, Int32[] matchlen, Boolean[] matched, String[][] parensp);
    private static object ImplSplit(Context cx, IScriptable scope, string target, Object[] args);
    private static string js_substring(Context cx, string target, Object[] args);
    private static string js_substr(string target, Object[] args);
    private static string js_concat(string target, Object[] args);
    private static string js_slice(string target, Object[] args);
    protected internal virtual int FindPrototypeId(string s);
}
public class EcmaScript.NET.Types.BuiltinWith : object {
    private static object FTAG;
    private static int Id_constructor;
    protected internal IScriptable prototype;
    protected internal IScriptable parent;
    public string ClassName { get; }
    public IScriptable ParentScope { get; public set; }
    internal BuiltinWith(IScriptable parent, IScriptable prototype);
    private static BuiltinWith();
    public virtual string get_ClassName();
    public virtual IScriptable get_ParentScope();
    public virtual void set_ParentScope(IScriptable value);
    internal static void Init(IScriptable scope, bool zealed);
    public virtual bool Has(string id, IScriptable start);
    public virtual bool Has(int index, IScriptable start);
    public virtual object Get(string id, IScriptable start);
    public virtual object Get(int index, IScriptable start);
    public virtual object Put(string id, IScriptable start, object value);
    public virtual object Put(int index, IScriptable start, object value);
    public virtual void Delete(string id);
    public virtual void Delete(int index);
    public virtual IScriptable GetPrototype();
    public virtual void SetPrototype(IScriptable prototype);
    public virtual Object[] GetIds();
    public virtual object GetDefaultValue(Type typeHint);
    public virtual bool HasInstance(IScriptable value);
    protected internal virtual object UpdateDotQuery(bool value);
    public virtual object ExecIdCall(IdFunctionObject f, Context cx, IScriptable scope, IScriptable thisObj, Object[] args);
    internal static bool IsWithFunction(object functionObj);
    internal static object NewWithSpecial(Context cx, IScriptable scope, Object[] args);
}
public class EcmaScript.NET.Types.Cli.CliArray : CliObject {
    internal object array;
    internal int length;
    internal Type cls;
    internal IScriptable prototype;
    public string ClassName { get; }
    public CliArray(IScriptable scope, object array);
    public virtual string get_ClassName();
    public virtual bool Has(string id, IScriptable start);
    public virtual bool Has(int index, IScriptable start);
    public virtual object Get(string id, IScriptable start);
    public virtual object Get(int index, IScriptable start);
    public virtual object Put(string id, IScriptable start, object value);
    public virtual object Put(int index, IScriptable start, object value);
    public virtual object GetDefaultValue(Type hint);
    public virtual Object[] GetIds();
    public virtual bool HasInstance(IScriptable value);
    public virtual IScriptable GetPrototype();
}
public class EcmaScript.NET.Types.Cli.CliEnum : CliObject {
    public string ClassName { get; }
    public CliEnum(Enum enm);
    public virtual string get_ClassName();
}
public class EcmaScript.NET.Types.Cli.CliEventInfo : CliObject {
    private EventInfo m_EventInfo;
    private static Hashtable m_EventHandlerTypes;
    public string ClassName { get; }
    public CliEventInfo(EventInfo ei);
    private static CliEventInfo();
    public virtual string get_ClassName();
    internal object Add(object val2, Context cx);
    internal object Del(object val2, Context cx);
    private static Type GetOrCreateType(Type eventHandlerType);
}
public class EcmaScript.NET.Types.Cli.CliMethodInfo : BaseFunction {
    private string m_Name;
    private MethodInfo[] m_MethodInfos;
    private object m_Target;
    private Boolean[] paramsParameters;
    private static int PREFERENCE_EQUAL;
    private static int PREFERENCE_FIRST_ARG;
    private static int PREFERENCE_SECOND_ARG;
    private static int PREFERENCE_AMBIGUOUS;
    public string ClassName { get; }
    public string FunctionName { get; }
    public CliMethodInfo(object target, string methodName);
    public CliMethodInfo(string name, MemberInfo methodInfo, object target);
    public CliMethodInfo(string name, MemberInfo[] methodInfos, object target);
    public virtual string get_ClassName();
    public virtual string get_FunctionName();
    private void Init(string name, MemberInfo[] methodInfos, object target);
    public virtual object Call(Context cx, IScriptable scope, IScriptable thisObj, Object[] args);
    internal static int FindFunction(Context cx, MethodBase[] methodsOrCtors, Object[] args, Boolean[] paramsParameter);
    internal static string ScriptSignature(Object[] values);
    private static int PreferSignature(Object[] args, ParameterInfo[] sig1, ParameterInfo[] sig2);
    public virtual object GetDefaultValue(Type typeHint);
    public virtual string ToString();
}
public class EcmaScript.NET.Types.Cli.CliObject : ScriptableObject {
    private object m_Object;
    private CliType m_Type;
    private static int JSTYPE_UNDEFINED;
    private static int JSTYPE_NULL;
    private static int JSTYPE_BOOLEAN;
    private static int JSTYPE_NUMBER;
    private static int JSTYPE_STRING;
    private static int JSTYPE_CLI_CLASS;
    private static int JSTYPE_CLI_OBJECT;
    private static int JSTYPE_CLI_ARRAY;
    private static int JSTYPE_OBJECT;
    internal static sbyte CONVERSION_TRIVIAL;
    internal static sbyte CONVERSION_NONTRIVIAL;
    internal static sbyte CONVERSION_NONE;
    public object Object { get; }
    public string ClassName { get; }
    public CliObject(object obj);
    public CliObject(object obj, Type type);
    public object get_Object();
    public sealed virtual object Unwrap();
    protected void Init(object obj, Type type);
    public virtual string get_ClassName();
    public virtual object GetDefaultValue(Type hint);
    public virtual object Put(int index, IScriptable start, object value);
    public virtual Object[] GetIds();
    public virtual bool Has(int index, IScriptable start);
    public virtual object Put(string name, IScriptable start, object value);
    public virtual object Get(int index, IScriptable start);
    public virtual object Get(string name, IScriptable start);
    public static bool CanConvert(object fromObj, Type to);
    internal static int GetConversionWeight(object fromObj, Type to);
    private static int GetSizeRank(Type aType);
    private static int GetJSTypeCode(object value);
    internal static object CoerceType(Type type, object value);
    private static object CoerceToNumber(Type type, object value);
    private static double toDouble(object value);
    private static long toInteger(object value, Type type, double min, double max);
    internal static void reportConversionError(object value, Type type);
    public virtual string ToString();
    public sealed virtual IdEnumeration GetEnumeration(Context cx, bool enumValues);
}
[EcmaScriptClassAttribute("Cli")]
public class EcmaScript.NET.Types.Cli.CliPackage : CliObject {
    public static void Init(IScriptable scope);
    [EcmaScriptFunctionAttribute("load")]
public void Load(string assembly);
    [EcmaScriptFunctionAttribute("using")]
public void Using(string ns);
    public static void ImportAssembly(IScriptable scope, Assembly ass);
    public static void ImportAssembly(IScriptable scope, Assembly ass, string startsWith);
    public static void ImportTypes(IScriptable scope, string startsWith);
    public static void ImportType(IScriptable scope, Type type);
}
public class EcmaScript.NET.Types.Cli.CliType : BaseFunction {
    private CliObject m_CliObject;
    private Type m_Type;
    private static Hashtable typeCache;
    private MemberInfo[] m_IndexGetter;
    public EcmaScriptClassAttribute m_ClassAttribute;
    private EcmaScriptFunctionAttribute[] m_FunctionAttributes;
    private Hashtable functionCache;
    private Hashtable functionsWithAttributeCache;
    private MemberInfo[] m_IndexSetter;
    private Hashtable propertyCache;
    private Hashtable fieldCache;
    public string ClassName { get; }
    public Type UnderlyingType { get; }
    public MemberInfo[] IndexGetter { get; }
    public EcmaScriptClassAttribute ClassAttribute { get; }
    public EcmaScriptFunctionAttribute[] FunctionAttributes { get; }
    public MemberInfo[] IndexSetter { get; }
    private CliType(Type type);
    private static CliType();
    public virtual string get_ClassName();
    public sealed virtual object Unwrap();
    public Type get_UnderlyingType();
    private void Init();
    public static CliType GetNativeCliType(Type type);
    public MemberInfo[] get_IndexGetter();
    public EcmaScriptClassAttribute get_ClassAttribute();
    public EcmaScriptFunctionAttribute[] get_FunctionAttributes();
    public CliMethodInfo GetFunctions(string name);
    public CliMethodInfo GetFunctionsWithAttribute(string name);
    public MemberInfo[] get_IndexSetter();
    public virtual object Call(Context cx, IScriptable scope, IScriptable thisObj, Object[] args);
    public virtual object Get(string name, IScriptable start);
    public PropertyInfo GetCachedProperty(string name);
    public FieldInfo GetCachedField(string name);
    internal EventInfo GetCachedEvent(string name);
    public virtual object GetDefaultValue(Type typeHint);
    public virtual string ToString();
}
internal class EcmaScript.NET.Types.E4X.Namespace : IdScriptableObject {
    private static object NAMESPACE_TAG;
    private XMLLib lib;
    private string prefix;
    private string uri;
    private static int Id_prefix;
    private static int Id_uri;
    private static int MAX_INSTANCE_ID;
    private static int Id_constructor;
    private static int Id_toString;
    private static int Id_toSource;
    private static int MAX_PROTOTYPE_ID;
    public string ClassName { get; }
    protected internal int MaxInstanceId { get; }
    public string Uri { get; }
    public string Prefix { get; }
    internal Namespace(XMLLib lib);
    public Namespace(XMLLib lib, string uri);
    public Namespace(XMLLib lib, string prefix, string uri);
    private static Namespace();
    public virtual string get_ClassName();
    protected internal virtual int get_MaxInstanceId();
    public virtual void ExportAsJSClass(bool sealed_Renamed);
    public virtual string get_Uri();
    public virtual string get_Prefix();
    public virtual string ToString();
    public virtual string toLocaleString();
    public virtual bool Equals(object obj);
    protected internal virtual object EquivalentValues(object value_Renamed);
    private bool equals(Namespace n);
    public virtual object GetDefaultValue(Type hint);
    protected internal virtual int FindInstanceIdInfo(string s);
    protected internal virtual string GetInstanceIdName(int id);
    protected internal virtual object GetInstanceIdValue(int id);
    protected internal virtual int FindPrototypeId(string s);
    protected internal virtual void InitPrototypeId(int id);
    public virtual object ExecIdCall(IdFunctionObject f, Context cx, IScriptable scope, IScriptable thisObj, Object[] args);
    private Namespace realThis(IScriptable thisObj, IdFunctionObject f);
    private object jsConstructor(Context cx, bool inNewExpr, Object[] args);
    private string js_toSource();
    internal static void toSourceImpl(string prefix, string uri, StringBuilder sb);
    public static Namespace Parse(XMLLib lib, Context cx, object prefixValue, object uriValue);
    internal static Namespace Parse(XMLLib lib, Context cx);
    internal static Namespace Parse(XMLLib lib, Context cx, object uriValue);
    public virtual int GetHashCode();
}
internal class EcmaScript.NET.Types.E4X.QName : IdScriptableObject {
    private static object QNAME_TAG;
    internal XMLLib lib;
    private string prefix;
    private string localName;
    private string uri;
    private static int Id_localName;
    private static int Id_uri;
    private static int MAX_INSTANCE_ID;
    private static int Id_constructor;
    private static int Id_toString;
    private static int Id_toSource;
    private static int MAX_PROTOTYPE_ID;
    public string ClassName { get; }
    protected internal int MaxInstanceId { get; }
    public string LocalName { get; }
    internal string Prefix { get; }
    internal string Uri { get; }
    internal QName(XMLLib lib);
    internal QName(XMLLib lib, QName qname);
    internal QName(XMLLib lib, string uri, string localName, string prefix);
    private static QName();
    public virtual string get_ClassName();
    protected internal virtual int get_MaxInstanceId();
    internal void ExportAsJSClass(bool zealed);
    public virtual string ToString();
    public string get_LocalName();
    internal string get_Prefix();
    internal string get_Uri();
    public virtual int GetHashCode();
    public virtual bool Equals(object obj);
    protected internal virtual object EquivalentValues(object value);
    private bool Equals(QName q);
    public virtual object GetDefaultValue(Type hint);
    protected internal virtual int FindInstanceIdInfo(string s);
    protected internal virtual string GetInstanceIdName(int id);
    protected internal virtual object GetInstanceIdValue(int id);
    protected internal virtual int FindPrototypeId(string s);
    protected internal virtual void InitPrototypeId(int id);
    public virtual object ExecIdCall(IdFunctionObject f, Context cx, IScriptable scope, IScriptable thisObj, Object[] args);
    private QName realThis(IScriptable thisObj, IdFunctionObject f);
    private object jsConstructor(Context cx, bool inNewExpr, Object[] args);
    internal static QName Parse(XMLLib lib, Context cx, object value);
    internal static QName Parse(XMLLib lib, Context cx, string localName);
    internal static QName Parse(XMLLib lib, Context cx, object namespaceValue, object nameValue);
    private string js_toSource();
    private static void toSourceImpl(string uri, string localName, string prefix, StringBuilder sb);
}
internal class EcmaScript.NET.Types.E4X.XML : XMLObject {
    private static object XMLOBJECT_TAG;
    private XmlNode underlyingNode;
    private static int Id_constructor;
    private static int Id_addNamespace;
    private static int Id_appendChild;
    private static int Id_attribute;
    private static int Id_attributes;
    private static int Id_child;
    private static int Id_childIndex;
    private static int Id_children;
    private static int Id_comments;
    private static int Id_contains;
    private static int Id_copy;
    private static int Id_descendants;
    private static int Id_elements;
    private static int Id_hasOwnProperty;
    private static int Id_hasComplexContent;
    private static int Id_hasSimpleContent;
    private static int Id_inScopeNamespaces;
    private static int Id_insertChildAfter;
    private static int Id_insertChildBefore;
    private static int Id_length;
    private static int Id_localName;
    private static int Id_name;
    private static int Id_namespace;
    private static int Id_namespaceDeclarations;
    private static int Id_nodeKind;
    private static int Id_normalize;
    private static int Id_parent;
    private static int Id_processingInstructions;
    private static int Id_prependChild;
    private static int Id_propertyIsEnumerable;
    private static int Id_removeNamespace;
    private static int Id_replace;
    private static int Id_setChildren;
    private static int Id_setLocalName;
    private static int Id_setName;
    private static int Id_setNamespace;
    private static int Id_text;
    private static int Id_toString;
    private static int Id_toXMLString;
    private static int Id_valueOf;
    private static int Id_domNode;
    private static int Id_domNodeList;
    private static int Id_xpath;
    private static int MAX_PROTOTYPE_ID;
    protected XmlNode UnderlyingNode { get; protected set; }
    public string ClassName { get; }
    public XML(XMLLib lib);
    public XML(XMLLib lib, XmlNode underlyingNode);
    private static XML();
    protected virtual XmlNode get_UnderlyingNode();
    protected virtual void set_UnderlyingNode(XmlNode value);
    public virtual string get_ClassName();
    public void ExportAsJSClass(bool zealed);
    protected internal virtual int FindPrototypeId(string s);
    protected internal virtual void InitPrototypeId(int id);
    public virtual object ExecIdCall(IdFunctionObject f, Context cx, IScriptable scope, IScriptable thisObj, Object[] args);
    internal XMLObject AddNamespace(object value);
    private object JsConstructor(Context cx, bool inNewExpr, Object[] args);
    internal static XML CreateFromJS(XMLLib lib, object inputObject);
    protected internal virtual IScriptable GetExtraMethodSource(Context cx);
    internal static XML CreateEmptyXml(XMLLib impl);
    protected internal virtual string ToXMLString();
    internal XMLObject ValueOf();
    internal bool HasSimpleContent();
    internal bool HasComplexContent();
    internal Object[] InScopeNamespaces();
    internal int Length();
    public virtual object GetDefaultValue(Type typeHint);
    internal string ToSource(int indent);
    internal object Namespace(object value);
    internal object Parent();
    internal int ChildIndex();
    internal XMLList Children();
    private XMLList Comments();
    internal XMLList ProcessingInstructions(XMLName xmlName);
    private bool Contains(object value);
    protected internal virtual bool EquivalentXml(object value);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    internal XMLList Attribute(XMLName xmlName);
    internal void MatchAttributes(XMLList list, XMLName xmlName, XmlNode parent, bool recursive);
    internal XMLList Attributes();
    internal XMLList Descendants(XMLName xmlName);
    private XMLList Elements(XMLName xmlName);
    public void MatchChildren(XMLList list, XMLName xmlName, XmlNode parent, bool recursive);
    public virtual Object[] GetIds();
    internal QName Name();
    internal string LocalName();
    internal string NodeKind();
    internal XMLList Child(long index);
    internal XMLList Child(XMLName xmlName);
    protected internal virtual object GetXMLProperty(XMLName name);
    internal string Text();
    internal XMLObject Normalize();
    internal object Copy();
    internal Object[] NamespaceDeclarations();
    internal bool HasOwnProperty(XMLName xmlName);
    protected internal virtual void PutXMLProperty(XMLName xmlName, object value);
    internal void SetAttribute(XMLName xmlName, object value);
    internal XML AppendChild(object child);
    internal XML PrependChild(object child);
    internal bool PropertyIsEnumerable(object p);
    internal XMLObject RemoveNamespace(object ns);
    internal XMLObject Replace(object name, object value);
    internal XMLObject SetChildren(object value);
    internal void SetLocalName(object name);
    internal void SetName(object name);
    internal void SetNamespace(object ns);
    internal XML InsertChildAfter(object newChild, object refChild);
    internal XML InsertChildBefore(object newChild, object refChild);
    internal XMLList GetPropertyList(XMLName name);
    public virtual string ToString();
    private XmlNode ImportNode(XmlNode node);
    private XmlNode Rename(XmlNode node, string prefix, string localName, string namespaceUri);
    private XmlNode Rename(XmlElement source, string prefix, string localName, string namespaceUri);
    private void RemoveAllChildren();
}
internal class EcmaScript.NET.Types.E4X.XMLCtor : IdFunctionObject {
    private static object XMLCTOR_TAG;
    private XMLLib lib;
    private static int Id_defaultSettings;
    private static int Id_settings;
    private static int Id_setSettings;
    private static int MAX_FUNCTION_ID;
    private static int Id_ignoreComments;
    private static int Id_ignoreProcessingInstructions;
    private static int Id_ignoreWhitespace;
    private static int Id_prettyIndent;
    private static int Id_prettyPrinting;
    private static int MAX_INSTANCE_ID;
    protected internal int MaxInstanceId { get; }
    internal XMLCtor(XML xml, object tag, int id, int arity);
    private static XMLCtor();
    protected internal virtual int get_MaxInstanceId();
    protected internal virtual int FindPrototypeId(string s);
    protected internal virtual void InitPrototypeId(int id);
    public virtual object ExecIdCall(IdFunctionObject f, Context cx, IScriptable scope, IScriptable thisObj, Object[] args);
    protected internal virtual int FindInstanceIdInfo(string s);
    protected internal virtual string GetInstanceIdName(int id);
    protected internal virtual object GetInstanceIdValue(int id);
    protected internal virtual void SetInstanceIdValue(int id, object value_Renamed);
    private void WriteSetting(IScriptable target);
    private void ReadSettings(IScriptable source);
}
internal class EcmaScript.NET.Types.E4X.XMLLib : object {
    private IScriptable globalScope;
    internal bool ignoreComments;
    internal bool ignoreProcessingInstructions;
    internal bool ignoreWhitespace;
    internal bool prettyPrinting;
    internal int prettyIndent;
    internal XML xmlPrototype;
    internal XMLList xmlListPrototype;
    internal Namespace namespacePrototype;
    internal QName qnamePrototype;
    private static object XML_LIB_KEY;
    public IScriptable GlobalScope { get; }
    private XMLLib(IScriptable globalScope);
    private static XMLLib();
    public IScriptable get_GlobalScope();
    internal void SetDefaultSettings();
    public static XMLLib ExtractFromScopeOrNull(IScriptable scope);
    public static XMLLib ExtractFromScope(IScriptable scope);
    internal XMLLib BindToScope(IScriptable scope);
    public static void Init(IScriptable scope, bool zealed);
    public bool IsXMLName(Context cx, object value);
    private static bool IsNCNameStartChar(int c);
    private static bool IsNCNameChar(int c);
    public string GetDefaultNamespaceURI(Context cx);
    public Namespace GetDefaultNamespace(Context cx);
    public IRef NameRef(Context cx, object name, IScriptable scope, int memberTypeFlags);
    public IRef NameRef(Context cx, object ns, object name, IScriptable scope, int memberTypeFlags);
    public string EscapeAttributeValue(object value);
    public string EscapeTextValue(object value);
    public object ToDefaultXmlNamespace(Context cx, object uriValue);
    internal static EcmaScriptError BadXMLName(object value);
    internal XMLName toQualifiedName(Context cx, object namespaceValue, object nameValue);
    internal XMLList ToXMLList(object value);
    internal XML ToXML(object value);
}
[DefaultMemberAttribute("Item")]
internal class EcmaScript.NET.Types.E4X.XMLList : XMLObject {
    private static object XMLOBJECT_TAG;
    private static int Id_constructor;
    private static int Id_attribute;
    private static int Id_attributes;
    private static int Id_child;
    private static int Id_children;
    private static int Id_comments;
    private static int Id_contains;
    private static int Id_copy;
    private static int Id_descendants;
    private static int Id_elements;
    private static int Id_hasOwnProperty;
    private static int Id_hasComplexContent;
    private static int Id_hasSimpleContent;
    private static int Id_length;
    private static int Id_normalize;
    private static int Id_parent;
    private static int Id_processingInstructions;
    private static int Id_propertyIsEnumerable;
    private static int Id_text;
    private static int Id_toString;
    private static int Id_toXMLString;
    private static int Id_valueOf;
    private static int Id_domNode;
    private static int Id_domNodeList;
    private static int Id_xpath;
    private static int Id_addNamespace;
    private static int Id_appendChild;
    private static int Id_childIndex;
    private static int Id_inScopeNamespaces;
    private static int Id_insertChildAfter;
    private static int Id_insertChildBefore;
    private static int Id_localName;
    private static int Id_name;
    private static int Id_namespace;
    private static int Id_namespaceDeclarations;
    private static int Id_nodeKind;
    private static int Id_prependChild;
    private static int Id_removeNamespace;
    private static int Id_replace;
    private static int Id_setChildren;
    private static int Id_setLocalName;
    private static int Id_setName;
    private static int Id_setNamespace;
    private static int MAX_PROTOTYPE_ID;
    internal ArrayList m_Nodes;
    public string ClassName { get; }
    public XML Item { get; }
    public XMLList(XMLLib lib);
    public XMLList(XMLLib lib, object inputObject);
    private static XMLList();
    public virtual string get_ClassName();
    public XML get_Item(int index);
    public void ExportAsJSClass(bool zealed);
    protected internal virtual int FindPrototypeId(string s);
    protected internal virtual void InitPrototypeId(int id);
    public virtual object ExecIdCall(IdFunctionObject f, Context cx, IScriptable scope, IScriptable thisObj, Object[] args);
    private XML DelegateTo(string methodName);
    internal void Add(XML node);
    internal void AddRange(XMLList list);
    internal int Length();
    public sealed virtual object Call(Context cx, IScriptable scope, IScriptable thisObj, Object[] args);
    public sealed virtual IScriptable Construct(Context cx, IScriptable scope, Object[] args);
    private object JsConstructor(Context cx, bool inNewExpr, Object[] args);
    protected internal virtual string ToXMLString();
    private bool HasSimpleContent();
    private bool HasComplexContent();
    protected internal virtual IScriptable GetExtraMethodSource(Context cx);
    private string ToSource(int indent);
    public virtual bool Has(int index, IScriptable start);
    public virtual object Get(int index, IScriptable start);
    private string NodeKind();
    private object Namespace(string prefix);
    private object Parent();
    private string Text();
    private XMLObject Normalize();
    private XMLList Children();
    public virtual Object[] GetIds();
    public virtual object GetDefaultValue(Type typeHint);
    private XMLList Attribute(XMLName xmlName);
    private XMLList Attributes();
    protected internal virtual object GetXMLProperty(XMLName name);
    private XMLList Descendants(XMLName xmlName);
    private XMLList Child(XMLName xmlName);
    private XMLList Child(long index);
    protected internal virtual void PutXMLProperty(XMLName name, object value);
    protected internal virtual bool EquivalentXml(object value);
    private object Copy();
    private Object[] NamespaceDeclarations();
    private bool HasOwnProperty(XMLName xmlName);
    internal XMLList GetPropertyList(XMLName xmlName);
    private void SetNamespace(object ns);
    private bool Contains(object value);
    private XMLList ProcessingInstructions(XMLName name);
    internal bool PropertyIsEnumerable(object p);
    private XMLObject ValueOf();
    public sealed virtual IEnumerator GetEnumerator();
}
internal class EcmaScript.NET.Types.E4X.XMLName : object {
    internal string uri;
    internal string localName;
    private XMLObject xmlObject;
    internal bool IsAttributeName;
    internal bool IsDescendants;
    public XMLName(string uri, string localName);
    public void BindTo(XMLObject obj);
    public sealed virtual object Get(Context cx);
    public sealed virtual object Set(Context cx, object value);
    public sealed virtual bool Has(Context cx);
    public sealed virtual bool Delete(Context cx);
    internal bool Matches(XmlNode node);
    public virtual string ToString();
    internal static XMLName Parse(XMLLib lib, Context cx, object value);
    internal static XMLName FormStar();
    internal static XMLName FormProperty(string uri, string localName);
    internal static XMLName Parse(XMLLib lib, Context cx, string name);
}
internal abstract class EcmaScript.NET.Types.E4X.XMLObject : IdScriptableObject {
    private static object XMLOBJECT_TAG;
    internal XMLLib lib;
    internal bool isPrototype;
    public string ClassName { get; }
    public XMLObject(IScriptable scope, IScriptable prototype);
    protected internal XMLObject(XMLLib lib, XMLObject prototype);
    private static XMLObject();
    public virtual string get_ClassName();
    public virtual object AddValues(Context cx, bool thisIsLeft, object value);
    public bool EcmaHas(Context cx, object id);
    public object EcmaGet(Context cx, object id);
    public void EcmaPut(Context cx, object id, object value);
    public bool EcmaDelete(Context cx, object id);
    public IRef MemberRef(Context cx, object elem, int memberTypeFlags);
    public IRef MemberRef(Context cx, object ns, object elem, int memberTypeFlags);
    public BuiltinWith EnterWith(IScriptable scope);
    public BuiltinWith EnterDotQuery(IScriptable scope);
    protected internal virtual object EquivalentValues(object value);
    protected object GetArgSafe(Object[] args, int index);
    protected internal abstract virtual IScriptable GetExtraMethodSource(Context cx);
    protected internal abstract virtual bool EquivalentXml(object value);
    protected internal abstract virtual object GetXMLProperty(XMLName name);
    protected internal abstract virtual void PutXMLProperty(XMLName xmlName, object value);
    protected internal abstract virtual string ToXMLString();
}
public class EcmaScript.NET.Types.RegExp.BuiltinRegExp : IdScriptableObject {
    private static object REGEXP_TAG;
    public static int JSREG_GLOB;
    public static int JSREG_FOLD;
    public static int JSREG_MULTILINE;
    public static int TEST;
    public static int MATCH;
    public static int PREFIX;
    private static bool debug;
    public static sbyte REOP_EMPTY;
    public static sbyte REOP_ALT;
    public static sbyte REOP_BOL;
    public static sbyte REOP_EOL;
    public static sbyte REOP_WBDRY;
    public static sbyte REOP_WNONBDRY;
    public static sbyte REOP_QUANT;
    public static sbyte REOP_STAR;
    public static sbyte REOP_PLUS;
    public static sbyte REOP_OPT;
    public static sbyte REOP_LPAREN;
    public static sbyte REOP_RPAREN;
    public static sbyte REOP_DOT;
    public static sbyte REOP_CCLASS;
    public static sbyte REOP_DIGIT;
    public static sbyte REOP_NONDIGIT;
    public static sbyte REOP_ALNUM;
    public static sbyte REOP_NONALNUM;
    public static sbyte REOP_SPACE;
    public static sbyte REOP_NONSPACE;
    public static sbyte REOP_BACKREF;
    public static sbyte REOP_FLAT;
    public static sbyte REOP_FLAT1;
    public static sbyte REOP_JUMP;
    public static sbyte REOP_DOTSTAR;
    public static sbyte REOP_ANCHOR;
    public static sbyte REOP_EOLONLY;
    public static sbyte REOP_UCFLAT;
    public static sbyte REOP_UCFLAT1;
    public static sbyte REOP_UCCLASS;
    public static sbyte REOP_NUCCLASS;
    public static sbyte REOP_BACKREFi;
    public static sbyte REOP_FLATi;
    public static sbyte REOP_FLAT1i;
    public static sbyte REOP_UCFLATi;
    public static sbyte REOP_UCFLAT1i;
    public static sbyte REOP_ANCHOR1;
    public static sbyte REOP_NCCLASS;
    public static sbyte REOP_DOTSTARMIN;
    public static sbyte REOP_LPARENNON;
    public static sbyte REOP_RPARENNON;
    public static sbyte REOP_ASSERT;
    public static sbyte REOP_ASSERT_NOT;
    public static sbyte REOP_ASSERTTEST;
    public static sbyte REOP_ASSERTNOTTEST;
    public static sbyte REOP_MINIMALSTAR;
    public static sbyte REOP_MINIMALPLUS;
    public static sbyte REOP_MINIMALOPT;
    public static sbyte REOP_MINIMALQUANT;
    public static sbyte REOP_ENDCHILD;
    public static sbyte REOP_CLASS;
    public static sbyte REOP_REPEAT;
    public static sbyte REOP_MINIMALREPEAT;
    public static sbyte REOP_END;
    private static int OFFSET_LEN;
    private static int INDEX_LEN;
    private static int Id_lastIndex;
    private static int Id_source;
    private static int Id_global;
    private static int Id_ignoreCase;
    private static int Id_multiline;
    private static int MAX_INSTANCE_ID;
    private static int Id_compile;
    private static int Id_toString;
    private static int Id_toSource;
    private static int Id_exec;
    private static int Id_test;
    private static int Id_prefix;
    private static int MAX_PROTOTYPE_ID;
    private RECompiled re;
    internal double lastIndex;
    public string ClassName { get; }
    internal int Flags { get; }
    protected internal int MaxInstanceId { get; }
    internal BuiltinRegExp(IScriptable scope, object regexpCompiled);
    private static BuiltinRegExp();
    public virtual string get_ClassName();
    internal virtual int get_Flags();
    protected internal virtual int get_MaxInstanceId();
    private static string DebugNameOp(sbyte op);
    public static void Init(IScriptable scope, bool zealed);
    public virtual object Call(Context cx, IScriptable scope, IScriptable thisObj, Object[] args);
    public virtual IScriptable Construct(Context cx, IScriptable scope, Object[] args);
    internal virtual IScriptable compile(Context cx, IScriptable scope, Object[] args);
    public virtual string ToString();
    private static RegExpImpl getImpl(Context cx);
    private object execSub(Context cx, IScriptable scopeObj, Object[] args, int matchType);
    internal static object compileRE(string str, string global, bool flat);
    internal static bool isDigit(char c);
    private static bool isWord(char c);
    private static bool isLineTerm(char c);
    private static bool isREWhiteSpace(int c);
    private static char upcase(char ch);
    private static char downcase(char ch);
    private static int toASCIIHexDigit(int c);
    private static bool parseDisjunction(CompilerState state);
    private static bool parseAlternative(CompilerState state);
    private static bool calculateBitmapSize(CompilerState state, RENode target, Char[] src, int index, int end);
    private static void doFlat(CompilerState state, char c);
    private static int getDecimalValue(char c, CompilerState state, int maxValue, string overflowMessageId);
    private static bool parseTerm(CompilerState state);
    private static void resolveForwardJump(SByte[] array, int from, int pc);
    private static int getOffset(SByte[] array, int pc);
    private static int addIndex(SByte[] array, int pc, int index);
    private static int getIndex(SByte[] array, int pc);
    private static int emitREBytecode(CompilerState state, RECompiled re, int pc, RENode t);
    private static void pushProgState(REGlobalData gData, int min, int max, REBackTrackData backTrackLastToSave, int continuation_pc, int continuation_op);
    private static REProgState popProgState(REGlobalData gData);
    private static void pushBackTrackState(REGlobalData gData, sbyte op, int target);
    private static bool flatNMatcher(REGlobalData gData, int matchChars, int length, Char[] chars, int end);
    private static bool flatNIMatcher(REGlobalData gData, int matchChars, int length, Char[] chars, int end);
    private static bool backrefMatcher(REGlobalData gData, int parenIndex, Char[] chars, int end);
    private static void addCharacterToCharSet(RECharSet cs, char c);
    private static void addCharacterRangeToCharSet(RECharSet cs, char c1, char c2);
    private static void processCharSet(REGlobalData gData, RECharSet charSet);
    private static void processCharSetImpl(REGlobalData gData, RECharSet charSet);
    private static bool classMatcher(REGlobalData gData, RECharSet charSet, char ch);
    private static bool executeREBytecode(REGlobalData gData, Char[] chars, int end);
    private static bool matchRegExp(REGlobalData gData, RECompiled re, Char[] chars, int start, int end, bool multiline);
    internal virtual object executeRegExp(Context cx, IScriptable scopeObj, RegExpImpl res, string str, Int32[] indexp, int matchType);
    private static void reportError(string messageId, string arg);
    protected internal virtual int FindInstanceIdInfo(string s);
    protected internal virtual string GetInstanceIdName(int id);
    protected internal virtual object GetInstanceIdValue(int id);
    protected internal virtual void SetInstanceIdValue(int id, object value);
    protected internal virtual void InitPrototypeId(int id);
    public virtual object ExecIdCall(IdFunctionObject f, Context cx, IScriptable scope, IScriptable thisObj, Object[] args);
    private static BuiltinRegExp realThis(IScriptable thisObj, IdFunctionObject f);
    protected internal virtual int FindPrototypeId(string s);
}
internal class EcmaScript.NET.Types.RegExp.BuiltinRegExpCtor : BaseFunction {
    private static int Id_multiline;
    private static int Id_STAR;
    private static int Id_input;
    private static int Id_UNDERSCORE;
    private static int Id_lastMatch;
    private static int Id_AMPERSAND;
    private static int Id_lastParen;
    private static int Id_PLUS;
    private static int Id_leftContext;
    private static int Id_BACK_QUOTE;
    private static int Id_rightContext;
    private static int Id_QUOTE;
    private static int DOLLAR_ID_BASE;
    private static int Id_DOLLAR_1;
    private static int Id_DOLLAR_2;
    private static int Id_DOLLAR_3;
    private static int Id_DOLLAR_4;
    private static int Id_DOLLAR_5;
    private static int Id_DOLLAR_6;
    private static int Id_DOLLAR_7;
    private static int Id_DOLLAR_8;
    private static int Id_DOLLAR_9;
    private static int MAX_INSTANCE_ID;
    public string FunctionName { get; }
    private static RegExpImpl Impl { get; }
    protected internal int MaxInstanceId { get; }
    public virtual string get_FunctionName();
    private static RegExpImpl get_Impl();
    protected internal virtual int get_MaxInstanceId();
    public virtual object Call(Context cx, IScriptable scope, IScriptable thisObj, Object[] args);
    public virtual IScriptable Construct(Context cx, IScriptable scope, Object[] args);
    protected internal virtual int FindInstanceIdInfo(string s);
    protected internal virtual string GetInstanceIdName(int id);
    protected internal virtual object GetInstanceIdValue(int id);
    protected internal virtual void SetInstanceIdValue(int id, object value);
}
internal class EcmaScript.NET.Types.RegExp.CompilerState : object {
    internal Char[] cpbegin;
    internal int cpend;
    internal int cp;
    internal int flags;
    internal int parenCount;
    internal int parenNesting;
    internal int classCount;
    internal int progLength;
    internal RENode result;
    internal CompilerState(Char[] source, int length, int flags);
}
internal class EcmaScript.NET.Types.RegExp.GlobData : object {
    internal RegExpActions mode;
    internal int optarg;
    internal bool global;
    internal string str;
    internal BuiltinRegExp regexp;
    internal IScriptable arrayobj;
    internal IFunction lambda;
    internal string repstr;
    internal int dollar;
    internal StringBuilder charBuf;
    internal int leftIndex;
}
internal class EcmaScript.NET.Types.RegExp.REBackTrackData : object {
    internal REBackTrackData previous;
    internal int continuation_op;
    internal int continuation_pc;
    internal int lastParen;
    internal Int64[] parens;
    internal int cp;
    internal REProgState stateStackTop;
    internal REBackTrackData(REGlobalData gData, int op, int pc);
}
internal class EcmaScript.NET.Types.RegExp.RECharSet : object {
    internal int length;
    internal int startIndex;
    internal int strlength;
    internal Boolean modreq(System.Runtime.CompilerServices.IsVolatile) converted;
    internal Boolean modreq(System.Runtime.CompilerServices.IsVolatile) sense;
    internal SByte[] modreq(System.Runtime.CompilerServices.IsVolatile) bits;
    internal RECharSet(int length, int startIndex, int strlength);
}
internal class EcmaScript.NET.Types.RegExp.RECompiled : object {
    internal Char[] source;
    internal int parenCount;
    internal int flags;
    internal SByte[] program;
    internal int classCount;
    internal RECharSet[] classList;
    internal int anchorCh;
}
public class EcmaScript.NET.Types.RegExp.RegExpImpl : object {
    internal string input;
    internal bool multiline;
    internal SubString[] parens;
    internal SubString lastMatch;
    internal SubString lastParen;
    internal SubString leftContext;
    internal SubString rightContext;
    public virtual bool IsRegExp(IScriptable obj);
    public virtual object Compile(Context cx, string source, string flags);
    public virtual IScriptable Wrap(Context cx, IScriptable scope, object compiled);
    public virtual object Perform(Context cx, IScriptable scope, IScriptable thisObj, Object[] args, RegExpActions actionType);
    private static object matchOrReplace(Context cx, IScriptable scope, IScriptable thisObj, Object[] args, RegExpImpl reImpl, GlobData data, bool forceFlat);
    public virtual int FindSplit(Context cx, IScriptable scope, string target, string separator, IScriptable reObj, Int32[] ip, Int32[] matchlen, Boolean[] matched, String[][] parensp);
    internal virtual SubString getParenSubString(int i);
    private static void match_glob(GlobData mdata, Context cx, IScriptable scope, int count, RegExpImpl reImpl);
    private static void replace_glob(GlobData rdata, Context cx, IScriptable scope, RegExpImpl reImpl, int leftIndex, int leftlen);
    private static SubString interpretDollar(Context cx, RegExpImpl res, string da, int dp, Int32[] skip);
    private static void do_replace(GlobData rdata, Context cx, RegExpImpl regExpImpl);
}
internal class EcmaScript.NET.Types.RegExp.REGlobalData : object {
    internal bool multiline;
    internal RECompiled regexp;
    internal int lastParen;
    internal int skipped;
    internal int cp;
    internal Int64[] parens;
    internal REProgState stateStackTop;
    internal REBackTrackData backTrackStackTop;
    internal virtual int parens_index(int i);
    internal virtual int parens_length(int i);
    internal virtual void set_parens(int i, int index, int length);
}
internal class EcmaScript.NET.Types.RegExp.RENode : object {
    internal sbyte op;
    internal RENode next;
    internal RENode kid;
    internal RENode kid2;
    internal int parenIndex;
    internal int min;
    internal int max;
    internal int parenCount;
    internal bool greedy;
    internal int startIndex;
    internal int kidlen;
    internal int bmsize;
    internal int index;
    internal char chr;
    internal int length;
    internal int flatIndex;
    internal RENode(sbyte op);
    public virtual string ToString();
}
internal class EcmaScript.NET.Types.RegExp.REProgState : object {
    internal REProgState previous;
    internal int min;
    internal int max;
    internal int index;
    internal int continuation_op;
    internal int continuation_pc;
    internal REBackTrackData backTrack;
    internal REProgState(REProgState previous, int min, int max, int index, REBackTrackData backTrack, int continuation_pc, int continuation_op);
}
internal class EcmaScript.NET.Types.RegExp.SubString : object {
    internal static SubString EmptySubString;
    internal Char[] charArray;
    internal int index;
    internal int length;
    public SubString(string str);
    public SubString(Char[] source, int start, int len);
    private static SubString();
    public virtual string ToString();
}
public class EcmaScript.NET.Undefined : object {
    public static object Value;
    private static Undefined();
}
public class EcmaScript.NET.UniqueTag : object {
    public static UniqueTag NotFound;
    public static UniqueTag NullValue;
    public static UniqueTag DoubleMark;
    public static UniqueTag LongMark;
    private string tagName;
    private UniqueTag(string tagName);
    private static UniqueTag();
    public virtual string ToString();
}
public interface EcmaScript.NET.Wrapper {
    public abstract virtual object Unwrap();
}
