public class Ecng.Collections.BackwardComparer`1 : object {
    private sealed virtual override int System.Collections.Generic.IComparer<T>.Compare(T x, T y);
}
public abstract class Ecng.Collections.BaseBlockingQueue`2 : object {
    [CompilerGeneratedAttribute]
private TF <InnerCollection>k__BackingField;
    private int _maxSize;
    private SyncObject _syncRoot;
    private bool _isClosed;
    protected TF InnerCollection { get; }
    public int MaxSize { get; public set; }
    public SyncObject SyncRoot { get; }
    public int Count { get; }
    public bool IsClosed { get; }
    private bool System.Collections.Generic.ICollection<T>.IsReadOnly { get; }
    protected BaseBlockingQueue`2(TF innerCollection);
    [CompilerGeneratedAttribute]
protected TF get_InnerCollection();
    public sealed virtual int get_MaxSize();
    public sealed virtual void set_MaxSize(int value);
    public sealed virtual SyncObject get_SyncRoot();
    public sealed virtual int get_Count();
    public sealed virtual bool get_IsClosed();
    public sealed virtual void Close();
    public sealed virtual void Open();
    private void WaitWhileFull();
    public sealed virtual void WaitUntilEmpty();
    public sealed virtual void Enqueue(T item, bool force);
    protected abstract virtual void OnEnqueue(T item, bool force);
    protected abstract virtual T OnDequeue();
    protected abstract virtual T OnPeek();
    public sealed virtual T Dequeue();
    private bool WaitWhileEmpty(bool exitOnClose, bool block);
    public sealed virtual bool TryDequeue(T& value, bool exitOnClose, bool block);
    public sealed virtual T Peek();
    public sealed virtual bool TryPeek(T& value, bool exitOnClose, bool block);
    public sealed virtual void Clear();
    private sealed virtual override bool System.Collections.Generic.ICollection<T>.Remove(T item);
    private sealed virtual override bool System.Collections.Generic.ICollection<T>.get_IsReadOnly();
    private sealed virtual override void System.Collections.Generic.ICollection<T>.Add(T item);
    private sealed virtual override bool System.Collections.Generic.ICollection<T>.Contains(T item);
    private sealed virtual override void System.Collections.Generic.ICollection<T>.CopyTo(T[] array, int arrayIndex);
    public sealed virtual IEnumerator`1<T> GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
}
[DefaultMemberAttribute("Item")]
public abstract class Ecng.Collections.BaseCollection`2 : object {
    [CompilerGeneratedAttribute]
private bool <CheckNullableItems>k__BackingField;
    [CompilerGeneratedAttribute]
private TCollection <InnerCollection>k__BackingField;
    [CompilerGeneratedAttribute]
private Func`2<TItem, bool> Adding;
    [CompilerGeneratedAttribute]
private Action`1<TItem> Added;
    [CompilerGeneratedAttribute]
private Func`2<TItem, bool> Removing;
    [CompilerGeneratedAttribute]
private Action`1<TItem> Removed;
    [CompilerGeneratedAttribute]
private Func`2<int, bool> RemovingAt;
    [CompilerGeneratedAttribute]
private Action`1<int> RemovedAt;
    [CompilerGeneratedAttribute]
private Func`1<bool> Clearing;
    [CompilerGeneratedAttribute]
private Action Cleared;
    [CompilerGeneratedAttribute]
private Func`3<int, TItem, bool> Inserting;
    [CompilerGeneratedAttribute]
private Action`2<int, TItem> Inserted;
    [CompilerGeneratedAttribute]
private Action Changed;
    private static bool _isValueType;
    public bool CheckNullableItems { get; public set; }
    protected TCollection InnerCollection { get; }
    public int Count { get; }
    public TItem Item { get; public set; }
    public bool IsReadOnly { get; }
    private bool System.Collections.IList.IsReadOnly { get; }
    private object System.Collections.IList.Item { get; private set; }
    private bool System.Collections.IList.IsFixedSize { get; }
    private bool System.Collections.ICollection.IsSynchronized { get; }
    private object System.Collections.ICollection.SyncRoot { get; }
    protected BaseCollection`2(TCollection innerCollection);
    private static BaseCollection`2();
    [CompilerGeneratedAttribute]
public bool get_CheckNullableItems();
    [CompilerGeneratedAttribute]
public void set_CheckNullableItems(bool value);
    [CompilerGeneratedAttribute]
protected TCollection get_InnerCollection();
    protected abstract virtual TItem OnGetItem(int index);
    protected abstract virtual void OnInsert(int index, TItem item);
    protected abstract virtual void OnRemoveAt(int index);
    protected virtual void OnAdd(TItem item);
    protected virtual bool OnRemove(TItem item);
    protected virtual void OnClear();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    public virtual IEnumerator`1<TItem> GetEnumerator();
    public virtual int get_Count();
    public virtual bool Contains(TItem item);
    private void CheckIndex(int index);
    public virtual TItem get_Item(int index);
    public virtual void set_Item(int index, TItem value);
    public abstract virtual int IndexOf(TItem item);
    public virtual void RemoveAt(int index);
    public virtual void Insert(int index, TItem item);
    public virtual bool get_IsReadOnly();
    public virtual void Add(TItem item);
    public virtual void Clear();
    public virtual bool Remove(TItem item);
    [CompilerGeneratedAttribute]
public sealed virtual void add_Adding(Func`2<TItem, bool> value);
    [CompilerGeneratedAttribute]
public sealed virtual void remove_Adding(Func`2<TItem, bool> value);
    [CompilerGeneratedAttribute]
public sealed virtual void add_Added(Action`1<TItem> value);
    [CompilerGeneratedAttribute]
public sealed virtual void remove_Added(Action`1<TItem> value);
    [CompilerGeneratedAttribute]
public sealed virtual void add_Removing(Func`2<TItem, bool> value);
    [CompilerGeneratedAttribute]
public sealed virtual void remove_Removing(Func`2<TItem, bool> value);
    [CompilerGeneratedAttribute]
public sealed virtual void add_Removed(Action`1<TItem> value);
    [CompilerGeneratedAttribute]
public sealed virtual void remove_Removed(Action`1<TItem> value);
    [CompilerGeneratedAttribute]
public sealed virtual void add_RemovingAt(Func`2<int, bool> value);
    [CompilerGeneratedAttribute]
public sealed virtual void remove_RemovingAt(Func`2<int, bool> value);
    [CompilerGeneratedAttribute]
public void add_RemovedAt(Action`1<int> value);
    [CompilerGeneratedAttribute]
public void remove_RemovedAt(Action`1<int> value);
    [CompilerGeneratedAttribute]
public sealed virtual void add_Clearing(Func`1<bool> value);
    [CompilerGeneratedAttribute]
public sealed virtual void remove_Clearing(Func`1<bool> value);
    [CompilerGeneratedAttribute]
public sealed virtual void add_Cleared(Action value);
    [CompilerGeneratedAttribute]
public sealed virtual void remove_Cleared(Action value);
    [CompilerGeneratedAttribute]
public sealed virtual void add_Inserting(Func`3<int, TItem, bool> value);
    [CompilerGeneratedAttribute]
public sealed virtual void remove_Inserting(Func`3<int, TItem, bool> value);
    [CompilerGeneratedAttribute]
public sealed virtual void add_Inserted(Action`2<int, TItem> value);
    [CompilerGeneratedAttribute]
public sealed virtual void remove_Inserted(Action`2<int, TItem> value);
    [CompilerGeneratedAttribute]
public sealed virtual void add_Changed(Action value);
    [CompilerGeneratedAttribute]
public sealed virtual void remove_Changed(Action value);
    protected virtual bool OnInserting(int index, TItem item);
    protected virtual void OnInserted(int index, TItem item);
    protected virtual bool OnAdding(TItem item);
    protected virtual void OnAdded(TItem item);
    protected virtual bool OnClearing();
    protected virtual void OnCleared();
    protected virtual bool OnRemoving(TItem item);
    protected virtual void OnRemoved(TItem item);
    protected virtual bool OnRemovingAt(int index);
    protected virtual void OnRemovedAt(int index);
    protected virtual void OnChanged();
    private sealed virtual override bool System.Collections.IList.Contains(object value);
    private sealed virtual override int System.Collections.IList.Add(object value);
    private sealed virtual override bool System.Collections.IList.get_IsReadOnly();
    private sealed virtual override object System.Collections.IList.get_Item(int index);
    private sealed virtual override void System.Collections.IList.set_Item(int index, object value);
    private sealed virtual override void System.Collections.IList.Clear();
    private sealed virtual override int System.Collections.IList.IndexOf(object value);
    private sealed virtual override void System.Collections.IList.Insert(int index, object value);
    private sealed virtual override void System.Collections.IList.Remove(object value);
    private sealed virtual override void System.Collections.IList.RemoveAt(int index);
    private sealed virtual override bool System.Collections.IList.get_IsFixedSize();
    private static bool IsCompatible(object value);
    private sealed virtual override bool System.Collections.ICollection.get_IsSynchronized();
    private sealed virtual override object System.Collections.ICollection.get_SyncRoot();
    private sealed virtual override void System.Collections.ICollection.CopyTo(Array array, int index);
    private sealed virtual override void System.Collections.Generic.ICollection<TItem>.CopyTo(TItem[] array, int index);
}
public abstract class Ecng.Collections.BaseEnumerator`2 : SimpleEnumerator`1<TItem> {
    [CompilerGeneratedAttribute]
private TEnumerable <Source>k__BackingField;
    public TEnumerable Source { get; private set; }
    protected BaseEnumerator`2(TEnumerable source);
    [CompilerGeneratedAttribute]
public TEnumerable get_Source();
    [CompilerGeneratedAttribute]
private void set_Source(TEnumerable value);
    protected virtual void DisposeManaged();
    public virtual bool MoveNext();
    public virtual void Reset();
    protected abstract virtual TItem ProcessMove(Boolean& canProcess);
}
public abstract class Ecng.Collections.BaseList`1 : BaseCollection`2<TItem, IList`1<TItem>> {
    protected BaseList`1(IList`1<TItem> innerList);
    protected virtual TItem OnGetItem(int index);
    protected virtual void OnInsert(int index, TItem item);
    protected virtual void OnRemoveAt(int index);
    public virtual int IndexOf(TItem item);
}
[TupleElementNamesAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public abstract class Ecng.Collections.BaseOrderedBlockingQueue`3 : BaseBlockingQueue`2<ValueTuple`2<TSort, TValue>, TCollection> {
    protected BaseOrderedBlockingQueue`3(TCollection collection);
    public bool TryDequeue(TValue& value, bool exitOnClose, bool block);
    protected void Enqueue(TSort sort, TValue value);
    protected virtual void OnEnqueue(ValueTuple`2<TSort, TValue> item, bool force);
    protected virtual ValueTuple`2<TSort, TValue> OnDequeue();
    protected virtual ValueTuple`2<TSort, TValue> OnPeek();
}
public class Ecng.Collections.BitArrayReader : object {
    private int _bitOffset;
    private long _dataOffset;
    private UInt64[] _data;
    private Stream _underlyingStream;
    public long Offset { get; public set; }
    public BitArrayReader(Stream underlyingStream);
    public long get_Offset();
    public void set_Offset(long value);
    private ulong Get(long offset);
    public bool Read();
    public Boolean[] ReadArray(int count);
    public int Read(int count);
    public void Seek(int offset);
    public long ReadLong(int count);
    public int ReadInt();
    public long ReadLong();
    public decimal ReadDecimal();
}
public class Ecng.Collections.BitArrayWriter : Disposable {
    private Stream _underlyingStream;
    private int _temp;
    private int _bitOffset;
    public BitArrayWriter(Stream underlyingStream);
    private void Flush();
    protected virtual void DisposeManaged();
    public void Write(bool bit);
    public void WriteInt(int value);
    public void WriteLong(long value);
    public void WriteBits(int value, int bitCount);
    public void WriteBits(long value, int bitCount);
    public void WriteDecimal(decimal value);
}
public class Ecng.Collections.BlockingQueue`1 : BaseBlockingQueue`2<T, QueueEx`1<T>> {
    protected virtual void OnEnqueue(T item, bool force);
    protected virtual T OnDequeue();
    protected virtual T OnPeek();
}
[DefaultMemberAttribute("Item")]
public class Ecng.Collections.CachedSynchronizedDictionary`2 : SynchronizedDictionary`2<TKey, TValue> {
    private TKey[] _cachedKeys;
    private TValue[] _cachedValues;
    private KeyValuePair`2[] _cachedPairs;
    public TKey[] CachedKeys { get; }
    public TValue[] CachedValues { get; }
    public KeyValuePair`2[] CachedPairs { get; }
    unknown TValue Item {public set; }
    public CachedSynchronizedDictionary`2(int capacity);
    public CachedSynchronizedDictionary`2(IEqualityComparer`1<TKey> comparer);
    public CachedSynchronizedDictionary`2(int capacity, IEqualityComparer`1<TKey> comparer);
    public TKey[] get_CachedKeys();
    public TValue[] get_CachedValues();
    public KeyValuePair`2[] get_CachedPairs();
    public virtual void set_Item(TKey key, TValue value);
    public virtual void Add(TKey key, TValue value);
    public virtual bool Remove(TKey key);
    public virtual void Clear();
}
public class Ecng.Collections.CachedSynchronizedList`1 : SynchronizedList`1<T> {
    private T[] _cache;
    public T[] Cache { get; }
    public CachedSynchronizedList`1(int capacity);
    public T[] get_Cache();
    protected virtual void OnChanged();
}
[DefaultMemberAttribute("Item")]
public class Ecng.Collections.CachedSynchronizedOrderedDictionary`2 : SynchronizedOrderedDictionary`2<TKey, TValue> {
    private TKey[] _cachedKeys;
    private TValue[] _cachedValues;
    private KeyValuePair`2[] _cachedPairs;
    public TKey[] CachedKeys { get; }
    public TValue[] CachedValues { get; }
    public KeyValuePair`2[] CachedPairs { get; }
    unknown TValue Item {public set; }
    public CachedSynchronizedOrderedDictionary`2(IComparer`1<TKey> comparer);
    public CachedSynchronizedOrderedDictionary`2(Func`3<TKey, TKey, int> comparer);
    public TKey[] get_CachedKeys();
    public TValue[] get_CachedValues();
    public KeyValuePair`2[] get_CachedPairs();
    public virtual void set_Item(TKey key, TValue value);
    public virtual void Add(TKey key, TValue value);
    public virtual bool Remove(TKey key);
    public virtual void Clear();
}
[DefaultMemberAttribute("Item")]
public class Ecng.Collections.CachedSynchronizedPairSet`2 : SynchronizedPairSet`2<TKey, TValue> {
    private TKey[] _cachedKeys;
    private TValue[] _cachedValues;
    private KeyValuePair`2[] _cachedPairs;
    public TKey[] CachedKeys { get; }
    public TValue[] CachedValues { get; }
    public KeyValuePair`2[] CachedPairs { get; }
    unknown TValue Item {public set; }
    public CachedSynchronizedPairSet`2(IEqualityComparer`1<TKey> comparer);
    public CachedSynchronizedPairSet`2(IEqualityComparer`1<TKey> keyComparer, IEqualityComparer`1<TValue> valueComparer);
    public TKey[] get_CachedKeys();
    public TValue[] get_CachedValues();
    public KeyValuePair`2[] get_CachedPairs();
    public virtual void set_Item(TKey key, TValue value);
    public virtual void Add(TKey key, TValue value);
    public virtual bool Remove(TKey key);
    public virtual void Clear();
}
public class Ecng.Collections.CachedSynchronizedSet`1 : SynchronizedSet`1<T> {
    private T[] _cache;
    public T[] Cache { get; }
    public CachedSynchronizedSet`1(bool allowIndexing);
    public CachedSynchronizedSet`1(IEnumerable`1<T> collection);
    public CachedSynchronizedSet`1(IEqualityComparer`1<T> comparer);
    public CachedSynchronizedSet`1(IEnumerable`1<T> collection, IEqualityComparer`1<T> comparer);
    public CachedSynchronizedSet`1(bool allowIndexing, IEqualityComparer`1<T> comparer);
    public CachedSynchronizedSet`1(bool allowIndexing, IEnumerable`1<T> collection, IEqualityComparer`1<T> comparer);
    public T[] get_Cache();
    protected virtual void OnChanged();
}
[DefaultMemberAttribute("Item")]
public class Ecng.Collections.CircularBuffer`1 : object {
    private T[] _buffer;
    private int _start;
    private int _end;
    private int _count;
    public int Capacity { get; public set; }
    public bool IsFull { get; }
    public bool IsEmpty { get; }
    public int Count { get; }
    public T Item { get; public set; }
    private bool System.Collections.Generic.ICollection<T>.IsReadOnly { get; }
    public CircularBuffer`1(int capacity);
    public CircularBuffer`1(int capacity, T[] items);
    public virtual int get_Capacity();
    public virtual void set_Capacity(int value);
    public bool get_IsFull();
    public bool get_IsEmpty();
    public sealed virtual int get_Count();
    public T Front();
    public T Back();
    public sealed virtual T get_Item(int index);
    public sealed virtual void set_Item(int index, T value);
    public virtual void PushBack(T item);
    public void PushFront(T item);
    public void PopBack();
    public void PopFront();
    public virtual void Clear();
    public T[] ToArray();
    public IList`1<ArraySegment`1<T>> ToArraySegments();
    [IteratorStateMachineAttribute("Ecng.Collections.CircularBuffer`1/<GetEnumerator>d__27")]
public sealed virtual IEnumerator`1<T> GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    private void ThrowIfEmpty(string message);
    private void Increment(Int32& index);
    private void Decrement(Int32& index);
    private int InternalIndex(int index);
    private ArraySegment`1<T> ArrayOne();
    private ArraySegment`1<T> ArrayTwo();
    private sealed virtual override int System.Collections.Generic.IList<T>.IndexOf(T item);
    private sealed virtual override void System.Collections.Generic.IList<T>.Insert(int index, T item);
    private sealed virtual override void System.Collections.Generic.IList<T>.RemoveAt(int index);
    private sealed virtual override bool System.Collections.Generic.ICollection<T>.get_IsReadOnly();
    private sealed virtual override void System.Collections.Generic.ICollection<T>.Add(T item);
    private sealed virtual override bool System.Collections.Generic.ICollection<T>.Contains(T item);
    private sealed virtual override void System.Collections.Generic.ICollection<T>.CopyTo(T[] array, int arrayIndex);
    private sealed virtual override bool System.Collections.Generic.ICollection<T>.Remove(T item);
}
public class Ecng.Collections.CircularBufferEx`1 : CircularBuffer`1<TItem> {
    [CompilerGeneratedAttribute]
private IOperator`1<TItem> <Operator>k__BackingField;
    [CompilerGeneratedAttribute]
private IComparer`1<TItem> <MaxComparer>k__BackingField;
    [CompilerGeneratedAttribute]
private IComparer`1<TItem> <MinComparer>k__BackingField;
    [CompilerGeneratedAttribute]
private NullableEx`1<TItem> <Max>k__BackingField;
    [CompilerGeneratedAttribute]
private NullableEx`1<TItem> <Min>k__BackingField;
    [CompilerGeneratedAttribute]
private TItem <Sum>k__BackingField;
    public IOperator`1<TItem> Operator { get; public set; }
    public IComparer`1<TItem> MaxComparer { get; public set; }
    public IComparer`1<TItem> MinComparer { get; public set; }
    public NullableEx`1<TItem> Max { get; private set; }
    public NullableEx`1<TItem> Min { get; private set; }
    public TItem Sum { get; private set; }
    public TItem SumNoFirst { get; }
    public int Capacity { get; public set; }
    public CircularBufferEx`1(int capacity);
    [CompilerGeneratedAttribute]
public IOperator`1<TItem> get_Operator();
    [CompilerGeneratedAttribute]
public void set_Operator(IOperator`1<TItem> value);
    [CompilerGeneratedAttribute]
public IComparer`1<TItem> get_MaxComparer();
    [CompilerGeneratedAttribute]
public void set_MaxComparer(IComparer`1<TItem> value);
    [CompilerGeneratedAttribute]
public IComparer`1<TItem> get_MinComparer();
    [CompilerGeneratedAttribute]
public void set_MinComparer(IComparer`1<TItem> value);
    [CompilerGeneratedAttribute]
public NullableEx`1<TItem> get_Max();
    [CompilerGeneratedAttribute]
private void set_Max(NullableEx`1<TItem> value);
    [CompilerGeneratedAttribute]
public NullableEx`1<TItem> get_Min();
    [CompilerGeneratedAttribute]
private void set_Min(NullableEx`1<TItem> value);
    [CompilerGeneratedAttribute]
public TItem get_Sum();
    [CompilerGeneratedAttribute]
private void set_Sum(TItem value);
    public TItem get_SumNoFirst();
    public virtual void PushBack(TItem result);
    public virtual int get_Capacity();
    public virtual void set_Capacity(int value);
    public virtual void Clear();
}
[ExtensionAttribute]
public static class Ecng.Collections.CollectionHelper : object {
    [ExtensionAttribute]
public static IEqualityComparer`1<T> ToComparer(Func`3<T, T, bool> comparer);
    [ExtensionAttribute]
public static IComparer`1<T> ToComparer(Func`3<T, T, int> comparer);
    [ExtensionAttribute]
public static IComparer`1<T> ToComparer(Comparison`1<T> comparer);
    [ExtensionAttribute]
public static Func`3<T, T, int> ToFunc(Comparison`1<T> comparer);
    [ExtensionAttribute]
public static bool SequenceEqual(IEnumerable`1<T> first, IEnumerable`1<T> second, Func`3<T, T, bool> comparer);
    [ExtensionAttribute]
public static IOrderedEnumerable`1<T> OrderBy(IEnumerable`1<T> collection, Comparison`1<T> comparison);
    [ExtensionAttribute]
public static int IndexOf(IEnumerable`1<T> source, Func`2<T, bool> predicate);
    [ExtensionAttribute]
public static void TryAdd(ICollection`1<T> collection, IEnumerable`1<T> values);
    [ExtensionAttribute]
public static bool TryAdd(ICollection`1<T> collection, T value);
    [ExtensionAttribute]
public static bool TryAdd2(IDictionary`2<TKey, TValue> dict, TKey key, TValue value);
    [ExtensionAttribute]
public static T ConcatEx(T first, T second);
    [ExtensionAttribute]
public static void AddRange(ICollection`1<T> source, IEnumerable`1<T> items);
    [ExtensionAttribute]
public static void RemoveRange(ICollection`1<T> source, IEnumerable`1<T> items);
    [ExtensionAttribute]
public static int RemoveWhere2(IList`1<T> list, Func`2<T, bool> filter);
    [ExtensionAttribute]
public static IEnumerable`1<T> RemoveWhere(ICollection`1<T> collection, Func`2<T, bool> filter);
    [ExtensionAttribute]
public static IEnumerable`1<T> SelectMany(IEnumerable`1<IEnumerable`1<T>> values);
    [ExtensionAttribute]
public static IEnumerable`1<T> OrderBy(IEnumerable`1<T> values);
    [ExtensionAttribute]
public static IEnumerable`1<T> OrderByDescending(IEnumerable`1<T> values);
    [ExtensionAttribute]
public static int GetHashCodeEx(IEnumerable`1<T> collection);
    [ExtensionAttribute]
public static bool HasNullItem(IEnumerable`1<T> items);
    [ExtensionAttribute]
public static T[] CopyAndClear(ICollection`1<T> items);
    [ExtensionAttribute]
public static TValue GetAndRemove(IDictionary`2<TKey, TValue> dict, TKey key);
    [ExtensionAttribute]
public static Nullable`1<TValue> TryGetAndRemove2(IDictionary`2<TKey, TValue> dict, TKey key);
    [ExtensionAttribute]
public static TValue TryGetAndRemove(IDictionary`2<TKey, TValue> dict, TKey key);
    [ExtensionAttribute]
public static bool TryGetAndRemove(IDictionary`2<TKey, TValue> dict, TKey key, TValue& value);
    [ExtensionAttribute]
public static T ElementAtFromEnd(IEnumerable`1<T> source, int index);
    [ExtensionAttribute]
public static T ElementAtFromEndOrDefault(IEnumerable`1<T> source, int index);
    [ExtensionAttribute]
private static int GetIndexFromEnd(IEnumerable`1<T> source, int index);
    [ExtensionAttribute]
public static T ElementAtFromEnd(LinkedList`1<T> list, int index);
    [ExtensionAttribute]
public static T ElementAtFromEnd(SynchronizedLinkedList`1<T> list, int index);
    [ExtensionAttribute]
public static T ElementAtFromEndOrDefault(LinkedList`1<T> list, int index);
    [ExtensionAttribute]
public static T ElementAtFromEndOrDefault(SynchronizedLinkedList`1<T> list, int index);
    [ExtensionAttribute]
public static PairSet`2<TKey, TValue> ToPairSet(IEnumerable`1<KeyValuePair`2<TKey, TValue>> source);
    [ExtensionAttribute]
public static PairSet`2<TKey, TValue> ToPairSet(IEnumerable`1<KeyValuePair`2<TKey, TValue>> source, IEqualityComparer`1<TKey> comparer);
    [ExtensionAttribute]
public static PairSet`2<TKey, TValue> ToPairSet(IEnumerable`1<TSource> source, Func`3<TSource, int, TKey> keySelector, Func`3<TSource, int, TValue> valueSelector);
    [ExtensionAttribute]
public static void CopyTo(IEnumerable`1<KeyValuePair`2<TKey, TValue>> source, IDictionary`2<TKey, TValue> destination);
    [ExtensionAttribute]
public static IDictionary`2<TKey, TValue> TypedAs(IDictionary dictionary);
    [ExtensionAttribute]
public static IDictionary`2<TKey, TValue> ToDictionary(IEnumerable`1<KeyValuePair`2<TKey, TValue>> source);
    [ExtensionAttribute]
public static IDictionary`2<TKey, TValue> ToDictionary(IEnumerable`1<KeyValuePair`2<TKey, TValue>> source, IEqualityComparer`1<TKey> comparer);
    [ExtensionAttribute]
public static IDictionary`2<TKey, TValue> ToDictionary(IEnumerable`1<Tuple`2<TKey, TValue>> source);
    [ExtensionAttribute]
public static IDictionary`2<TKey, TValue> ToDictionary(IEnumerable`1<Tuple`2<TKey, TValue>> source, IEqualityComparer`1<TKey> comparer);
    [ExtensionAttribute]
public static Tuple`2<TKey, TValue> ToTuple(KeyValuePair`2<TKey, TValue> pair);
    [ExtensionAttribute]
public static KeyValuePair`2<TKey, TValue> ToPair(Tuple`2<TKey, TValue> pair);
    [ExtensionAttribute]
public static IDictionary`2<TKey, TValue> ToDictionary(IEnumerable`1<TSource> source, Func`3<TSource, int, TKey> keySelector, Func`3<TSource, int, TValue> valueSelector);
    [ExtensionAttribute]
public static IDictionary`2<TKey, IEnumerable`1<TValue>> ToDictionary(IEnumerable`1<IGrouping`2<TKey, TValue>> grouping);
    [ExtensionAttribute]
public static IEnumerable`1<TKey> GetKeys(IDictionary`2<TKey, TValue> dictionary, TValue value);
    [ExtensionAttribute]
public static TValue SafeAdd(IDictionary`2<TKey, TValue> dictionary, TKey key);
    [ExtensionAttribute]
public static TValue SafeAdd(IDictionary`2<TKey, TValue> dictionary, TKey key, Boolean& isNew);
    [ExtensionAttribute]
public static TValue SafeAdd(IDictionary`2<TKey, TValue> dictionary, TKey key, Func`2<TKey, TValue> handler);
    [ExtensionAttribute]
public static TValue SafeAdd(IDictionary`2<TKey, TValue> dictionary, TKey key, Func`2<TKey, TValue> handler, Boolean& isNew);
    [AsyncStateMachineAttribute("Ecng.Collections.CollectionHelper/<SafeAddAsync>d__53`2")]
[ExtensionAttribute]
[CLSCompliantAttribute("False")]
public static Task`1<TValue> SafeAddAsync(IDictionary`2<TKey, TValue> dictionary, AsyncReaderWriterLock sync, TKey key, Func`3<TKey, CancellationToken, Task`1<TValue>> handler, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Ecng.Collections.CollectionHelper/<SafeAddAsync>d__54`2")]
[ExtensionAttribute]
[CLSCompliantAttribute("False")]
public static Task`1<TValue> SafeAddAsync(IDictionary`2<TKey, TaskCompletionSource`1<TValue>> dictionary, AsyncReaderWriterLock sync, TKey key, Func`3<TKey, CancellationToken, Task`1<TValue>> handler, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static Task`1<TValue> SafeAddAsync(IDictionary`2<TKey, TaskCompletionSource`1<TValue>> dictionary, TKey key, Func`3<TKey, CancellationToken, Task`1<TValue>> handler, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static TValue TryGetValue(IDictionary`2<TKey, TValue> dict, TKey key);
    [ExtensionAttribute]
public static Nullable`1<TValue> TryGetValue2(IDictionary`2<TKey, TValue> dict, TKey key);
    [ExtensionAttribute]
public static TKey TryGetKey(PairSet`2<TKey, TValue> pairSet, TValue value);
    [ExtensionAttribute]
public static Nullable`1<TKey> TryGetKey2(PairSet`2<TKey, TValue> pairSet, TValue value);
    [ExtensionAttribute]
public static TResult SyncGet(TCollection collection, Func`2<TCollection, TResult> func);
    [ExtensionAttribute]
public static void SyncDo(TCollection collection, Action`1<TCollection> action);
    [ExtensionAttribute]
public static IEnumerable`1<TKey> GetKeys(SynchronizedDictionary`2<TKey, TValue> dictionary, TValue value);
    [ExtensionAttribute]
public static T TryDequeue(Queue`1<T> queue);
    [ExtensionAttribute]
public static Nullable`1<T> TryDequeue2(Queue`1<T> queue);
    [ExtensionAttribute]
public static T TryDequeue(SynchronizedQueue`1<T> queue);
    [ExtensionAttribute]
public static Nullable`1<T> TryDequeue2(SynchronizedQueue`1<T> queue);
    [ExtensionAttribute]
public static T TryPeek(Queue`1<T> queue);
    [ExtensionAttribute]
public static Nullable`1<T> TryPeek2(Queue`1<T> queue);
    [ExtensionAttribute]
public static T TryPeek(SynchronizedQueue`1<T> queue);
    [ExtensionAttribute]
public static Nullable`1<T> TryPeek2(SynchronizedQueue`1<T> queue);
    [ExtensionAttribute]
public static T FirstOr(IEnumerable`1<T> source, T alternate);
    [ExtensionAttribute]
public static Nullable`1<T> FirstOr(IEnumerable`1<T> source);
    [ExtensionAttribute]
public static Nullable`1<T> LastOr(IEnumerable`1<T> source);
    [ExtensionAttribute]
public static Nullable`1<T> ElementAtOr(IEnumerable`1<T> source, int index);
    [ExtensionAttribute]
[ObsoleteAttribute("Use StringHelper.IsEmpty.")]
public static bool IsEmpty(IEnumerable`1<char> source);
    [ExtensionAttribute]
public static bool IsEmpty(IEnumerable`1<T> source);
    [ExtensionAttribute]
public static bool IsEmpty(IEnumerable`1<T> source, Func`2<T, bool> predicate);
    [ExtensionAttribute]
public static bool IsEmpty(ICollection`1<T> source);
    [ExtensionAttribute]
public static bool IsEmpty(T[] source);
    [ExtensionAttribute]
public static Boolean[] ToBits(double value);
    [ExtensionAttribute]
public static Boolean[] ToBits(double value, int count);
    [ExtensionAttribute]
public static Boolean[] ToBits(double value, int startBit, int bitCount);
    [ExtensionAttribute]
public static Boolean[] ToBits(float value);
    [ExtensionAttribute]
public static Boolean[] ToBits(float value, int bitCount);
    [ExtensionAttribute]
public static Boolean[] ToBits(float value, int startBit, int bitCount);
    [ExtensionAttribute]
public static Boolean[] ToBits(long value);
    [ExtensionAttribute]
public static Boolean[] ToBits(long value, int bitCount);
    [ExtensionAttribute]
public static Boolean[] ToBits(long value, int startBit, int bitCount);
    [ExtensionAttribute]
public static Boolean[] ToBits(int value);
    [ExtensionAttribute]
public static Boolean[] ToBits(int value, int bitCount);
    [ExtensionAttribute]
public static Boolean[] ToBits(int value, int startBit, int bitCount);
    [ExtensionAttribute]
public static int FromBits(Boolean[] bits);
    [ExtensionAttribute]
public static int FromBits(Boolean[] bits, int startBit);
    [ExtensionAttribute]
public static long FromBits2(Boolean[] bits);
    [ExtensionAttribute]
public static long FromBits2(Boolean[] bits, int startBit);
    [ExtensionAttribute]
public static void AddRange(BitArray array, Boolean[] bits);
    [ExtensionAttribute]
public static IEnumerableEx`1<T> ToEx(IEnumerable`1<T> values);
    [ExtensionAttribute]
public static IEnumerableEx`1<T> ToEx(IEnumerable`1<T> values, int count);
    [ExtensionAttribute]
public static SynchronizedList`1<T> Sync(IList`1<T> list);
    [ExtensionAttribute]
public static SynchronizedDictionary`2<TKey, TValue> Sync(IDictionary`2<TKey, TValue> dict);
    [ExtensionAttribute]
public static SynchronizedSet`1<T> Sync(HashSet`1<T> list);
    [IteratorStateMachineAttribute("Ecng.Collections.CollectionHelper/<WhereWithPrevious>d__103`1")]
[ExtensionAttribute]
public static IEnumerable`1<TSource> WhereWithPrevious(IEnumerable`1<TSource> source, Func`3<TSource, TSource, bool> predicate);
    [ExtensionAttribute]
public static void Bind(INotifyList`1<T> source, IList`1<T> destination);
    public static int DamerauLevenshteinDistance(T[] source, T[] target, int threshold);
    [ExtensionAttribute]
public static ISet`1<T> ToSet(IEnumerable`1<T> values);
    [ExtensionAttribute]
public static ISet`1<string> ToIgnoreCaseSet(IEnumerable`1<string> values);
    [ExtensionAttribute]
public static IEnumerable`1<T[]> Batch(IEnumerable`1<T> source, int size);
    [IteratorStateMachineAttribute("Ecng.Collections.CollectionHelper/<Batch>d__109`2")]
[ExtensionAttribute]
public static IEnumerable`1<TResult> Batch(IEnumerable`1<TSource> source, int size, Func`2<IEnumerable`1<TSource>, TResult> resultSelector, Func`1<bool> needStop);
    [ExtensionAttribute]
public static IEnumerable`1<T> Append2(IEnumerable`1<T> values, T value);
    [AsyncStateMachineAttribute("Ecng.Collections.CollectionHelper/<SelectManyAsync>d__111`2")]
[ExtensionAttribute]
public static Task`1<IEnumerable`1<T1>> SelectManyAsync(IEnumerable`1<T> enumeration, Func`2<T, Task`1<IEnumerable`1<T1>>> func);
    [ExtensionAttribute]
public static KeyValuePair`2<TKey, TValue> ToPair(ValueTuple`2<TKey, TValue> _);
    [ExtensionAttribute]
public static void Add(IDictionary`2<TKey, TValue> dict, ValueTuple`2<TKey, TValue> tuple);
    [ExtensionAttribute]
public static void ForEach(IEnumerable`1<T> source, Action`1<T> action);
    [IteratorStateMachineAttribute("Ecng.Collections.CollectionHelper/<Permutations>d__115`2")]
[ExtensionAttribute]
public static IEnumerable`1<TValue[]> Permutations(IEnumerable`1<TKey> keys, Func`2<TKey, IEnumerable`1<TValue>> selector);
    [ExtensionAttribute]
public static T SingleWhenOnly(IEnumerable`1<T> source);
    [ExtensionAttribute]
public static int Count2(IEnumerable source);
    [CompilerGeneratedAttribute]
internal static void <TryAdd>g__InternalTryAdd|9_0(<>c__DisplayClass9_0`1& );
    [CompilerGeneratedAttribute]
internal static bool <TryAdd>g__InternalTryAdd|10_0(<>c__DisplayClass10_0`1& );
    [CompilerGeneratedAttribute]
internal static bool <TryAdd2>g__InternalTryAdd|11_0(<>c__DisplayClass11_0`2& );
    [CompilerGeneratedAttribute]
internal static T[] <CopyAndClear>g__InternalCopyAndClear|22_0(<>c__DisplayClass22_0`1& );
    [CompilerGeneratedAttribute]
internal static TValue <GetAndRemove>g__InternalGetAndRemove|23_0(<>c__DisplayClass23_0`2& );
    [CompilerGeneratedAttribute]
internal static bool <TryGetAndRemove>g__InternalTryGetAndRemove|26_0(TValue& value2, <>c__DisplayClass26_0`2& );
    [IteratorStateMachineAttribute("Ecng.Collections.CollectionHelper/<<Permutations>g__Permutations|115_0>d`2")]
[CompilerGeneratedAttribute]
internal static IEnumerable`1<TValue[]> <Permutations>g__Permutations|115_0(TKey[] keys, int index, Func`2<TKey, IEnumerable`1<TValue>> selector, TValue[] values);
}
public interface Ecng.Collections.IBlockingQueue`1 {
    public int Count { get; }
    public int MaxSize { get; public set; }
    public bool IsClosed { get; }
    public abstract virtual int get_Count();
    public abstract virtual int get_MaxSize();
    public abstract virtual void set_MaxSize(int value);
    public abstract virtual bool get_IsClosed();
    public abstract virtual void Open();
    public abstract virtual void Close();
    public abstract virtual void WaitUntilEmpty();
    public abstract virtual void Enqueue(T item, bool force);
    public abstract virtual T Dequeue();
    public abstract virtual bool TryDequeue(T& value, bool exitOnClose, bool block);
    public abstract virtual T Peek();
    public abstract virtual bool TryPeek(T& value, bool exitOnClose, bool block);
    public abstract virtual void Clear();
}
public interface Ecng.Collections.ICollectionEx`1 {
    [CompilerGeneratedAttribute]
public abstract virtual void add_AddedRange(Action`1<IEnumerable`1<T>> value);
    [CompilerGeneratedAttribute]
public abstract virtual void remove_AddedRange(Action`1<IEnumerable`1<T>> value);
    [CompilerGeneratedAttribute]
public abstract virtual void add_RemovedRange(Action`1<IEnumerable`1<T>> value);
    [CompilerGeneratedAttribute]
public abstract virtual void remove_RemovedRange(Action`1<IEnumerable`1<T>> value);
    public abstract virtual void AddRange(IEnumerable`1<T> items);
    public abstract virtual void RemoveRange(IEnumerable`1<T> items);
    public abstract virtual int RemoveRange(int index, int count);
}
public interface Ecng.Collections.IEnumerableEx {
    public int Count { get; }
    public abstract virtual int get_Count();
}
public interface Ecng.Collections.IEnumerableEx`1 {
}
public interface Ecng.Collections.IListEx`1 {
}
public interface Ecng.Collections.INotifyCollection`1 {
    [CompilerGeneratedAttribute]
public abstract virtual void add_Adding(Func`2<TItem, bool> value);
    [CompilerGeneratedAttribute]
public abstract virtual void remove_Adding(Func`2<TItem, bool> value);
    [CompilerGeneratedAttribute]
public abstract virtual void add_Added(Action`1<TItem> value);
    [CompilerGeneratedAttribute]
public abstract virtual void remove_Added(Action`1<TItem> value);
    [CompilerGeneratedAttribute]
public abstract virtual void add_Removing(Func`2<TItem, bool> value);
    [CompilerGeneratedAttribute]
public abstract virtual void remove_Removing(Func`2<TItem, bool> value);
    [CompilerGeneratedAttribute]
public abstract virtual void add_RemovingAt(Func`2<int, bool> value);
    [CompilerGeneratedAttribute]
public abstract virtual void remove_RemovingAt(Func`2<int, bool> value);
    [CompilerGeneratedAttribute]
public abstract virtual void add_Removed(Action`1<TItem> value);
    [CompilerGeneratedAttribute]
public abstract virtual void remove_Removed(Action`1<TItem> value);
    [CompilerGeneratedAttribute]
public abstract virtual void add_Clearing(Func`1<bool> value);
    [CompilerGeneratedAttribute]
public abstract virtual void remove_Clearing(Func`1<bool> value);
    [CompilerGeneratedAttribute]
public abstract virtual void add_Cleared(Action value);
    [CompilerGeneratedAttribute]
public abstract virtual void remove_Cleared(Action value);
    [CompilerGeneratedAttribute]
public abstract virtual void add_Inserting(Func`3<int, TItem, bool> value);
    [CompilerGeneratedAttribute]
public abstract virtual void remove_Inserting(Func`3<int, TItem, bool> value);
    [CompilerGeneratedAttribute]
public abstract virtual void add_Inserted(Action`2<int, TItem> value);
    [CompilerGeneratedAttribute]
public abstract virtual void remove_Inserted(Action`2<int, TItem> value);
    [CompilerGeneratedAttribute]
public abstract virtual void add_Changed(Action value);
    [CompilerGeneratedAttribute]
public abstract virtual void remove_Changed(Action value);
}
public interface Ecng.Collections.INotifyList`1 {
}
public interface Ecng.Collections.INotifyListEx`1 {
}
public interface Ecng.Collections.IQueue`1 {
    public abstract virtual T Dequeue();
    public abstract virtual T Peek();
    public abstract virtual void Enqueue(T item);
}
public interface Ecng.Collections.ISynchronizedCollection {
    public SyncObject SyncRoot { get; }
    public abstract virtual SyncObject get_SyncRoot();
}
public interface Ecng.Collections.ISynchronizedCollection`1 {
}
[DefaultMemberAttribute("Item")]
public abstract class Ecng.Collections.KeyedCollection`2 : object {
    [CompilerGeneratedAttribute]
private IDictionary`2<TKey, TValue> <InnerDictionary>k__BackingField;
    protected IDictionary`2<TKey, TValue> InnerDictionary { get; }
    public TValue Item { get; public set; }
    public int Count { get; }
    public ICollection`1<TKey> Keys { get; }
    public ICollection`1<TValue> Values { get; }
    private bool System.Collections.Generic.ICollection<System.Collections.Generic.KeyValuePair<TKey,TValue>>.IsReadOnly { get; }
    protected KeyedCollection`2(IDictionary`2<TKey, TValue> innerDictionary);
    protected KeyedCollection`2(IEqualityComparer`1<TKey> comparer);
    [CompilerGeneratedAttribute]
protected IDictionary`2<TKey, TValue> get_InnerDictionary();
    public virtual void Add(TKey key, TValue value);
    public virtual TValue get_Item(TKey key);
    public virtual void set_Item(TKey key, TValue value);
    public virtual void Clear();
    public virtual bool Remove(TKey key);
    public virtual bool TryGetValue(TKey key, TValue& value);
    public virtual int get_Count();
    public virtual IEnumerator`1<KeyValuePair`2<TKey, TValue>> GetEnumerator();
    protected virtual void OnAdding(TKey key, TValue value);
    protected virtual void OnAdded(TKey key, TValue value);
    protected virtual void OnSetting(TKey key, TValue value);
    protected virtual void OnSetted(TKey key, TValue value);
    protected virtual void OnClearing();
    protected virtual void OnCleared();
    protected virtual void OnRemoving(TKey key, TValue value);
    protected virtual void OnRemoved(TKey key, TValue value);
    protected virtual bool CanAdd(TKey key, TValue value);
    public sealed virtual ICollection`1<TKey> get_Keys();
    public sealed virtual ICollection`1<TValue> get_Values();
    private sealed virtual override bool System.Collections.Generic.ICollection<System.Collections.Generic.KeyValuePair<TKey,TValue>>.get_IsReadOnly();
    public sealed virtual bool ContainsKey(TKey key);
    public sealed virtual void Add(KeyValuePair`2<TKey, TValue> item);
    public sealed virtual bool Contains(KeyValuePair`2<TKey, TValue> item);
    public sealed virtual void CopyTo(KeyValuePair`2[] array, int arrayIndex);
    public sealed virtual bool Remove(KeyValuePair`2<TKey, TValue> item);
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
}
[ObsoleteAttribute("Use PriorityQueue.")]
public class Ecng.Collections.OrderedPriorityQueue`2 : object {
    private SortedDictionary`2<TPriority, Queue`1<TValue>> _dictionary;
    [CompilerGeneratedAttribute]
private int <Count>k__BackingField;
    public bool IsEmpty { get; }
    public int Count { get; private set; }
    public bool IsReadOnly { get; }
    private IEnumerable`1<KeyValuePair`2<TPriority, TValue>> AllItems { get; }
    public OrderedPriorityQueue`2(IComparer`1<TPriority> comparer);
    public void Enqueue(TPriority priority, TValue value);
    public sealed virtual KeyValuePair`2<TPriority, TValue> Dequeue();
    public TValue DequeueValue();
    public sealed virtual KeyValuePair`2<TPriority, TValue> Peek();
    public TValue PeekValue();
    public bool get_IsEmpty();
    public sealed virtual void Add(KeyValuePair`2<TPriority, TValue> item);
    public sealed virtual void Clear();
    public sealed virtual bool Contains(KeyValuePair`2<TPriority, TValue> item);
    [CompilerGeneratedAttribute]
public sealed virtual int get_Count();
    [CompilerGeneratedAttribute]
private void set_Count(int value);
    public sealed virtual void CopyTo(KeyValuePair`2[] array, int arrayIndex);
    public sealed virtual bool get_IsReadOnly();
    public sealed virtual bool Remove(KeyValuePair`2<TPriority, TValue> item);
    public void RemoveRange(IEnumerable`1<KeyValuePair`2<TPriority, TValue>> items);
    private bool Remove(TPriority key, ICollection`1<TValue> items);
    public sealed virtual IEnumerator`1<KeyValuePair`2<TPriority, TValue>> GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    private IEnumerable`1<KeyValuePair`2<TPriority, TValue>> get_AllItems();
    private sealed virtual override void Ecng.Collections.IQueue<System.Collections.Generic.KeyValuePair<TPriority,TValue>>.Enqueue(KeyValuePair`2<TPriority, TValue> item);
}
[DefaultMemberAttribute("Item")]
public class Ecng.Collections.PairSet`2 : KeyedCollection`2<TKey, TValue> {
    private Dictionary`2<TValue, TKey> _values;
    public TKey Item { get; }
    public PairSet`2(IEqualityComparer`1<TKey> comparer);
    public PairSet`2(IEqualityComparer`1<TKey> keyComparer, IEqualityComparer`1<TValue> valueComparer);
    public TKey get_Item(TValue value);
    public TKey GetKey(TValue value);
    public TValue GetValue(TKey key);
    public void SetKey(TValue value, TKey key);
    public void SetValue(TKey key, TValue value);
    protected virtual bool CanAdd(TKey key, TValue value);
    protected virtual void OnAdding(TKey key, TValue value);
    protected virtual void OnSetting(TKey key, TValue value);
    protected virtual void OnClearing();
    protected virtual void OnRemoving(TKey key, TValue value);
    public bool TryGetKey(TValue value, TKey& key);
    public bool TryAdd(TKey key, TValue value);
    public bool RemoveByValue(TValue value);
    public bool ContainsValue(TValue value);
}
[DebuggerDisplayAttribute("Count = {Count}")]
public class Ecng.Collections.PriorityQueue`2 : object {
    private LinkedList`1<Node<TPriority, TElement>> _nodes;
    private int _version;
    private Func`3<TPriority, TPriority, TPriority> _subtractAbs;
    private int _count;
    private IComparer`1<TPriority> _comparer;
    public int Count { get; }
    public IComparer`1<TPriority> Comparer { get; }
    private bool System.Collections.Generic.ICollection<System.ValueTuple<TPriority,TElement>>.IsReadOnly { get; }
    public PriorityQueue`2(Func`3<TPriority, TPriority, TPriority> subtractAbs, IComparer`1<TPriority> comparer);
    public PriorityQueue`2(Func`3<TPriority, TPriority, TPriority> subtractAbs);
    public sealed virtual int get_Count();
    public IComparer`1<TPriority> get_Comparer();
    private void ChechCount();
    private void EnqueueInternal(TPriority priority, TElement element);
    private ValueTuple`2<TPriority, TElement> DequeueInternal();
    public void Enqueue(TPriority priority, TElement element);
    public sealed virtual ValueTuple`2<TPriority, TElement> Peek();
    public sealed virtual ValueTuple`2<TPriority, TElement> Dequeue();
    public TElement DequeueEnqueue(TPriority priority, TElement element);
    public bool TryDequeue(TElement& element, TPriority& priority);
    public bool TryPeek(TElement& element, TPriority& priority);
    public TElement EnqueueDequeue(TPriority priority, TElement element);
    public void EnqueueRange(IEnumerable`1<ValueTuple`2<TPriority, TElement>> items);
    public void EnqueueRange(TPriority priority, IEnumerable`1<TElement> elements);
    public sealed virtual void Clear();
    private sealed virtual override bool System.Collections.Generic.ICollection<System.ValueTuple<TPriority,TElement>>.get_IsReadOnly();
    private sealed virtual override void System.Collections.Generic.ICollection<System.ValueTuple<TPriority,TElement>>.Add(ValueTuple`2<TPriority, TElement> item);
    private sealed virtual override bool System.Collections.Generic.ICollection<System.ValueTuple<TPriority,TElement>>.Contains(ValueTuple`2<TPriority, TElement> item);
    private sealed virtual override void System.Collections.Generic.ICollection<System.ValueTuple<TPriority,TElement>>.CopyTo(ValueTuple`2[] array, int arrayIndex);
    private sealed virtual override bool System.Collections.Generic.ICollection<System.ValueTuple<TPriority,TElement>>.Remove(ValueTuple`2<TPriority, TElement> item);
    private sealed virtual override IEnumerator`1<ValueTuple`2<TPriority, TElement>> System.Collections.Generic.IEnumerable<System.ValueTuple<TPriority,TElement>>.GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    private sealed virtual override void Ecng.Collections.IQueue<System.ValueTuple<TPriority,TElement>>.Enqueue(ValueTuple`2<TPriority, TElement> item);
}
public class Ecng.Collections.QueueEx`1 : Queue`1<T> {
    private bool System.Collections.Generic.ICollection<T>.IsReadOnly { get; }
    private sealed virtual override void System.Collections.Generic.ICollection<T>.Add(T item);
    private sealed virtual override bool System.Collections.Generic.ICollection<T>.Remove(T item);
    private sealed virtual override bool System.Collections.Generic.ICollection<T>.get_IsReadOnly();
    private sealed virtual override void System.Collections.Generic.ICollection<T>.Clear();
    private sealed virtual override bool System.Collections.Generic.ICollection<T>.Contains(T item);
    private sealed virtual override void System.Collections.Generic.ICollection<T>.CopyTo(T[] array, int arrayIndex);
}
public class Ecng.Collections.SimpleEnumerable`1 : object {
    private Func`1<IEnumerator`1<T>> _createEnumerator;
    public SimpleEnumerable`1(Func`1<IEnumerator`1<T>> createEnumerator);
    public sealed virtual IEnumerator`1<T> GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
}
public abstract class Ecng.Collections.SimpleEnumerator`1 : Disposable {
    [CompilerGeneratedAttribute]
private T <Current>k__BackingField;
    public T Current { get; protected set; }
    private object System.Collections.IEnumerator.Current { get; }
    public abstract virtual bool MoveNext();
    public virtual void Reset();
    [CompilerGeneratedAttribute]
public sealed virtual T get_Current();
    [CompilerGeneratedAttribute]
protected void set_Current(T value);
    private sealed virtual override object System.Collections.IEnumerator.get_Current();
}
public class Ecng.Collections.StackEx`1 : Stack`1<T> {
    private bool System.Collections.Generic.ICollection<T>.IsReadOnly { get; }
    private sealed virtual override void System.Collections.Generic.ICollection<T>.Add(T item);
    private sealed virtual override bool System.Collections.Generic.ICollection<T>.Remove(T item);
    private sealed virtual override bool System.Collections.Generic.ICollection<T>.get_IsReadOnly();
    private sealed virtual override void System.Collections.Generic.ICollection<T>.Clear();
    private sealed virtual override bool System.Collections.Generic.ICollection<T>.Contains(T item);
    private sealed virtual override void System.Collections.Generic.ICollection<T>.CopyTo(T[] array, int arrayIndex);
}
[DefaultMemberAttribute("Item")]
public abstract class Ecng.Collections.SynchronizedCollection`2 : BaseCollection`2<TItem, TCollection> {
    [CompilerGeneratedAttribute]
private SyncObject <SyncRoot>k__BackingField;
    public SyncObject SyncRoot { get; }
    public int Count { get; }
    public TItem Item { get; public set; }
    protected SynchronizedCollection`2(TCollection innerCollection);
    [CompilerGeneratedAttribute]
public sealed virtual SyncObject get_SyncRoot();
    public virtual int get_Count();
    public virtual TItem get_Item(int index);
    public virtual void set_Item(int index, TItem value);
    public virtual void Add(TItem item);
    public virtual void Clear();
    public virtual bool Remove(TItem item);
    public virtual void RemoveAt(int index);
    public virtual void Insert(int index, TItem item);
    public virtual int IndexOf(TItem item);
    public virtual bool Contains(TItem item);
    protected abstract virtual int OnIndexOf(TItem item);
    public virtual IEnumerator`1<TItem> GetEnumerator();
}
[DefaultMemberAttribute("Item")]
public class Ecng.Collections.SynchronizedDictionary`2 : object {
    private IDictionary`2<TKey, TValue> _inner;
    [CompilerGeneratedAttribute]
private SyncObject <SyncRoot>k__BackingField;
    public SyncObject SyncRoot { get; }
    public int Count { get; }
    public bool IsReadOnly { get; }
    public TValue Item { get; public set; }
    public ICollection`1<TKey> Keys { get; }
    public ICollection`1<TValue> Values { get; }
    public SynchronizedDictionary`2(int capacity);
    public SynchronizedDictionary`2(IEqualityComparer`1<TKey> comparer);
    public SynchronizedDictionary`2(int capacity, IEqualityComparer`1<TKey> comparer);
    protected SynchronizedDictionary`2(IDictionary`2<TKey, TValue> inner);
    [CompilerGeneratedAttribute]
public sealed virtual SyncObject get_SyncRoot();
    public sealed virtual IEnumerator`1<KeyValuePair`2<TKey, TValue>> GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    public sealed virtual void Add(KeyValuePair`2<TKey, TValue> item);
    public virtual void Clear();
    public sealed virtual bool Contains(KeyValuePair`2<TKey, TValue> item);
    public virtual void CopyTo(KeyValuePair`2[] array, int arrayIndex);
    public sealed virtual bool Remove(KeyValuePair`2<TKey, TValue> item);
    public sealed virtual int get_Count();
    public sealed virtual bool get_IsReadOnly();
    public virtual bool ContainsKey(TKey key);
    public virtual void Add(TKey key, TValue value);
    public virtual bool Remove(TKey key);
    public virtual bool TryGetValue(TKey key, TValue& value);
    public virtual TValue get_Item(TKey key);
    public virtual void set_Item(TKey key, TValue value);
    public sealed virtual ICollection`1<TKey> get_Keys();
    public sealed virtual ICollection`1<TValue> get_Values();
}
[DefaultMemberAttribute("Item")]
public abstract class Ecng.Collections.SynchronizedKeyedCollection`2 : KeyedCollection`2<TKey, TValue> {
    private SynchronizedDictionary`2<TKey, TValue> SyncDict { get; }
    public SyncObject SyncRoot { get; }
    unknown TValue Item {public set; }
    protected SynchronizedKeyedCollection`2(IEqualityComparer`1<TKey> comparer);
    private SynchronizedDictionary`2<TKey, TValue> get_SyncDict();
    public sealed virtual SyncObject get_SyncRoot();
    public virtual void set_Item(TKey key, TValue value);
    public virtual void Clear();
    public virtual bool Remove(TKey key);
}
public class Ecng.Collections.SynchronizedLinkedList`1 : object {
    private LinkedList`1<T> _inner;
    private SyncObject _syncRoot;
    public SyncObject SyncRoot { get; }
    public LinkedListNode`1<T> First { get; }
    public LinkedListNode`1<T> Last { get; }
    public int Count { get; }
    private bool System.Collections.Generic.ICollection<T>.IsReadOnly { get; }
    public sealed virtual SyncObject get_SyncRoot();
    public virtual LinkedListNode`1<T> get_First();
    public virtual LinkedListNode`1<T> get_Last();
    public virtual void AddBefore(LinkedListNode`1<T> node, T value);
    public virtual void AddBefore(LinkedListNode`1<T> node, LinkedListNode`1<T> newNode);
    public virtual void AddFirst(T value);
    public virtual void AddFirst(LinkedListNode`1<T> node);
    public virtual void AddLast(T value);
    public virtual void AddLast(LinkedListNode`1<T> node);
    public virtual void Remove(LinkedListNode`1<T> node);
    public virtual void RemoveFirst();
    public virtual void RemoveLast();
    public virtual LinkedListNode`1<T> Find(T value);
    public virtual LinkedListNode`1<T> FindLast(T value);
    public sealed virtual IEnumerator`1<T> GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    private sealed virtual override void System.Collections.Generic.ICollection<T>.Add(T item);
    public sealed virtual void Clear();
    public sealed virtual bool Contains(T item);
    public sealed virtual void CopyTo(T[] array, int arrayIndex);
    public sealed virtual bool Remove(T item);
    public sealed virtual int get_Count();
    private sealed virtual override bool System.Collections.Generic.ICollection<T>.get_IsReadOnly();
}
public class Ecng.Collections.SynchronizedList`1 : SynchronizedCollection`2<T, List`1<T>> {
    [CompilerGeneratedAttribute]
private Action`1<IEnumerable`1<T>> AddedRange;
    [CompilerGeneratedAttribute]
private Action`1<IEnumerable`1<T>> RemovedRange;
    public SynchronizedList`1(int capacity);
    protected virtual T OnGetItem(int index);
    protected virtual void OnInsert(int index, T item);
    protected virtual void OnRemoveAt(int index);
    protected virtual int OnIndexOf(T item);
    [CompilerGeneratedAttribute]
public sealed virtual void add_AddedRange(Action`1<IEnumerable`1<T>> value);
    [CompilerGeneratedAttribute]
public sealed virtual void remove_AddedRange(Action`1<IEnumerable`1<T>> value);
    [CompilerGeneratedAttribute]
public sealed virtual void add_RemovedRange(Action`1<IEnumerable`1<T>> value);
    [CompilerGeneratedAttribute]
public sealed virtual void remove_RemovedRange(Action`1<IEnumerable`1<T>> value);
    protected virtual void OnAdded(T item);
    protected virtual void OnRemoved(T item);
    public sealed virtual void AddRange(IEnumerable`1<T> items);
    public sealed virtual void RemoveRange(IEnumerable`1<T> items);
    public sealed virtual int RemoveRange(int index, int count);
    public IEnumerable`1<T> GetRange(int index, int count);
    [CompilerGeneratedAttribute]
private bool <AddRange>b__14_0(T t);
}
public class Ecng.Collections.SynchronizedOrderedDictionary`2 : SynchronizedDictionary`2<TKey, TValue> {
    public SynchronizedOrderedDictionary`2(IComparer`1<TKey> comparer);
    public SynchronizedOrderedDictionary`2(Func`3<TKey, TKey, int> comparer);
}
[DefaultMemberAttribute("Item")]
public class Ecng.Collections.SynchronizedPairSet`2 : SynchronizedKeyedCollection`2<TKey, TValue> {
    private Dictionary`2<TValue, TKey> _values;
    public TKey Item { get; }
    public SynchronizedPairSet`2(IEqualityComparer`1<TKey> comparer);
    public SynchronizedPairSet`2(IEqualityComparer`1<TKey> keyComparer, IEqualityComparer`1<TValue> valueComparer);
    public virtual void Add(TKey key, TValue value);
    public TKey get_Item(TValue value);
    public TKey GetKey(TValue value);
    public TValue GetValue(TKey key);
    public void SetKey(TKey key, TValue value);
    public void SetValue(TKey key, TValue value);
    protected virtual bool CanAdd(TKey key, TValue value);
    protected virtual void OnAdding(TKey key, TValue value);
    protected virtual void OnSetting(TKey key, TValue value);
    protected virtual void OnClearing();
    protected virtual void OnRemoving(TKey key, TValue value);
    public bool TryAdd(TKey key, TValue value);
    public TKey TryGetKey(TValue value);
    public bool TryGetKey(TValue value, TKey& key);
    public bool TryGetKeyAndRemove(TValue value, TKey& key);
    public bool RemoveByValue(TValue value);
    public bool ContainsValue(TValue value);
}
public class Ecng.Collections.SynchronizedQueue`1 : SynchronizedCollection`2<T, QueueEx`1<T>> {
    public void Enqueue(T item);
    public T Dequeue();
    public T Peek();
    protected virtual T OnGetItem(int index);
    protected virtual void OnInsert(int index, T item);
    protected virtual void OnRemoveAt(int index);
    protected virtual int OnIndexOf(T item);
}
public class Ecng.Collections.SynchronizedSet`1 : SynchronizedCollection`2<T, ISet`1<T>> {
    private PairSet`2<int, T> _indecies;
    private int _maxIndex;
    private bool _raiseRangeEvents;
    [CompilerGeneratedAttribute]
private bool <ThrowIfDuplicate>k__BackingField;
    [CompilerGeneratedAttribute]
private Action`1<IEnumerable`1<T>> AddedRange;
    [CompilerGeneratedAttribute]
private Action`1<IEnumerable`1<T>> RemovedRange;
    public bool ThrowIfDuplicate { get; public set; }
    public SynchronizedSet`1(bool allowIndexing);
    public SynchronizedSet`1(IEqualityComparer`1<T> comparer);
    public SynchronizedSet`1(bool allowIndexing, IEqualityComparer`1<T> comparer);
    public SynchronizedSet`1(IEnumerable`1<T> collection);
    public SynchronizedSet`1(IEnumerable`1<T> collection, IEqualityComparer`1<T> comparer);
    public SynchronizedSet`1(bool allowIndexing, IEnumerable`1<T> collection, IEqualityComparer`1<T> comparer);
    protected SynchronizedSet`1(bool allowIndexing, ISet`1<T> innerCollection);
    [CompilerGeneratedAttribute]
public bool get_ThrowIfDuplicate();
    [CompilerGeneratedAttribute]
public void set_ThrowIfDuplicate(bool value);
    private void Duplicate();
    private void CheckIndexingEnabled();
    private void AddIndicies(T item);
    private bool RemoveIndicies(T item);
    protected virtual bool OnAdding(T item);
    protected virtual T OnGetItem(int index);
    protected virtual void OnInsert(int index, T item);
    protected virtual void OnRemoveAt(int index);
    protected virtual void OnAdd(T item);
    protected virtual bool OnRemove(T item);
    protected virtual void OnClear();
    protected virtual int OnIndexOf(T item);
    public sealed virtual void UnionWith(IEnumerable`1<T> other);
    public sealed virtual void IntersectWith(IEnumerable`1<T> other);
    public sealed virtual void ExceptWith(IEnumerable`1<T> other);
    public sealed virtual void SymmetricExceptWith(IEnumerable`1<T> other);
    public sealed virtual bool IsSubsetOf(IEnumerable`1<T> other);
    public sealed virtual bool IsSupersetOf(IEnumerable`1<T> other);
    public sealed virtual bool IsProperSupersetOf(IEnumerable`1<T> other);
    public sealed virtual bool IsProperSubsetOf(IEnumerable`1<T> other);
    public sealed virtual bool Overlaps(IEnumerable`1<T> other);
    public sealed virtual bool SetEquals(IEnumerable`1<T> other);
    private sealed virtual override bool System.Collections.Generic.ISet<T>.Add(T item);
    public bool TryAdd(T item);
    [CompilerGeneratedAttribute]
public sealed virtual void add_AddedRange(Action`1<IEnumerable`1<T>> value);
    [CompilerGeneratedAttribute]
public sealed virtual void remove_AddedRange(Action`1<IEnumerable`1<T>> value);
    [CompilerGeneratedAttribute]
public sealed virtual void add_RemovedRange(Action`1<IEnumerable`1<T>> value);
    [CompilerGeneratedAttribute]
public sealed virtual void remove_RemovedRange(Action`1<IEnumerable`1<T>> value);
    protected virtual void OnAdded(T item);
    protected virtual void OnRemoved(T item);
    public sealed virtual void AddRange(IEnumerable`1<T> items);
    public sealed virtual void RemoveRange(IEnumerable`1<T> items);
    private void ProcessRange(IEnumerable`1<T> items, Action`1<T> action);
    public sealed virtual int RemoveRange(int index, int count);
    [CompilerGeneratedAttribute]
private bool <AddRange>b__47_0(T t);
    [CompilerGeneratedAttribute]
private void <AddRange>b__47_1(T item);
    [CompilerGeneratedAttribute]
private void <RemoveRange>b__48_0(T item);
}
public class Ecng.Collections.SynchronizedStack`1 : SynchronizedCollection`2<T, StackEx`1<T>> {
    public void Push(T item);
    public T Pop();
    public T Peek();
    protected virtual T OnGetItem(int index);
    protected virtual void OnInsert(int index, T item);
    protected virtual void OnRemoveAt(int index);
    protected virtual int OnIndexOf(T item);
}
[CompilerGeneratedAttribute]
[EmbeddedAttribute]
internal class Microsoft.CodeAnalysis.EmbeddedAttribute : Attribute {
}
[CompilerGeneratedAttribute]
[EmbeddedAttribute]
[AttributeUsageAttribute("27524")]
internal class System.Runtime.CompilerServices.NullableAttribute : Attribute {
    public Byte[] NullableFlags;
    public NullableAttribute(byte );
    public NullableAttribute(Byte[] );
}
[CompilerGeneratedAttribute]
[EmbeddedAttribute]
[AttributeUsageAttribute("2")]
internal class System.Runtime.CompilerServices.RefSafetyRulesAttribute : Attribute {
    public int Version;
    public RefSafetyRulesAttribute(int );
}
