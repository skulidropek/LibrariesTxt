public class BoldOclConst.Units.BoldOclConst : object {
    public static string sAssignNotSupported;
    public static string sSetAsObjectNotSupported;
    public static string sIComparableNotImplemented;
    public static string sUnknownTypeOfMemberOf;
    public static string sUnknownTypeOfMember;
    public static string sTypesDoNotConform;
    public static string OclHelpAbs;
    public static string OclHelpAllInstances;
    public static string OclHelpAllInstancesAtTime;
    public static string OclHelpAllLoadedObjects;
    public static string OclHelpAllSubClasses;
    public static string OclHelpAllSuperTypes;
    public static string OclHelpAppend;
    public static string OclHelpAsBag;
    public static string OclHelpAsOrderedSet;
    public static string OclHelpAsSequence;
    public static string OclHelpAsSet;
    public static string OclHelpAssociationEnds;
    public static string OclHelpasString;
    public static string OclHelpat;
    public static string OclHelpAtTime;
    public static string OclHelpAttributes;
    public static string OclHelpAverage;
    public static string OclHelpcollect;
    public static string OclHelpconcat;
    public static string OclHelpCount;
    public static string OclHelpCreate;
    public static string OclHelpDelete;
    public static string OclHelpdifference;
    public static string OclHelpEmptyList;
    public static string OclHelpexcluding;
    public static string OclHelpExisting;
    public static string OclHelpExists;
    public static string OclHelpExternalId;
    public static string OclHelpFilterOnType;
    public static string OclHelpfirst;
    public static string OclHelpFloor;
    public static string OclHelpForAll;
    public static string OclHelpFormatDateTime;
    public static string OclHelpFormat;
    public static string OclHelpimplies;
    public static string OclHelpincludes;
    public static string OclHelpindexOf;
    public static string OclHelpIncludesAll;
    public static string OclHelpIncluding;
    public static string OclHelpInDateRange;
    public static string OclHelpIntersection;
    public static string OclHelpInTimeRange;
    public static string OclHelpisEmpty;
    public static string OclHelpisNull;
    public static string OclHelplast;
    public static string OclHelpLength;
    public static string OclHelpLet;
    public static string OclHelpListAdd;
    public static string OclHelpListClear;
    public static string OclHelpListRemove;
    public static string OclHelpListRemoveAt;
    public static string OclHelpMax;
    public static string OclHelpMaxLength;
    public static string OclHelpMaxvalue;
    public static string OclHelpMin;
    public static string OclHelpMinValue;
    public static string OclHelpNotEmpty;
    public static string OclHelpObjectTimeStamp;
    public static string OclHelpOclAsType;
    public static string OclHelpoclGetStates;
    public static string OclHelpoclGetTriggers;
    public static string OclHelpoclIsInState;
    public static string OclHelpoclIsKindOf;
    public static string OclHelpOclIsTypeOf;
    public static string OclHelpoclType;
    public static string OclHelporderby;
    public static string OclHelporderDescending;
    public static string OclHelporderGeneric;
    public static string OclHelpPad;
    public static string OclHelpPostPad;
    public static string OclHelpPrepend;
    public static string OclHelpRegExpMatch;
    public static string OclHelpreject;
    public static string OclHelpRound;
    public static string OclHelpsafeCast;
    public static string OclHelpSelect;
    public static string OclHelpSize;
    public static string OclHelpSQLLike;
    public static string OclHelpSQLLikeCaseInsensitive;
    public static string OclHelpStrToDate;
    public static string OclHelpStrToDateTime;
    public static string OclHelpstrToInt;
    public static string OclHelpStrToTime;
    public static string OclHelpSubSequence;
    public static string OclHelpSubString;
    public static string OclHelpSum;
    public static string OclHelpSumDecimal;
    public static string OclHelpsumTime;
    public static string OclHelpSuperTypes;
    public static string OclHelpSymmetricDifference;
    public static string OclHelpTaggedValue;
    public static string OclHelpTimeStampToTime;
    public static string OclHelpTimeToTimeStamp;
    public static string OclHelptoLower;
    public static string OclHelpToUpper;
    public static string OclHelpTypeName;
    public static string OclHelpunion;
    public static string OclHelpModifiedSinceTimeStamp;
    public static string OclHelpTypeMethod;
    public static string sClassHasNoStateMachine;
    public static string sUnknownState;
    public static string sResultMustBeObjectList;
    public static string sCannotPerformPSEvalWithoutSystem;
    public static string sCollectionLiteralsNotSupported;
    public static string sPersistentMembersRequired;
    public static string sBooleanOperatorRequired;
    public static string sCannotCompareBooleanToLiteral;
    public static string sEnumNameNotValid;
    public static string sTypeNotSupportedOnOLW;
    public static string sIllegalTypeForLoopVar;
    public static string sOnlyRolesMayBeQualified;
    public static string sRoleNotQualified;
    public static string sNoDeduceMethod;
    public static string sSameTypeAsLoopVar;
    public static string sSameTypeAsArg1;
    public static string sSameTypeAsListElemOfArg1;
    public static string sSameTypeAsArg2;
    public static string sSameTypeAsArg3;
    public static string sLeastCommonSuperTypeArg1Arg2;
    public static string sLeastCommonSuperTypeArg2Arg3;
    public static string sSameTypeAsListElemOfArg2;
    public static string sTypeIsObjectList;
    public static string sTypeIsObject;
    public static string sTypeIsMetaType;
    public static string sTypeIsArg2;
    public static string sArg1AsaOrderedSet;
    public static string sArg1AsaBag;
    public static string sArg1AsaSequence;
    public static string sArg1AsaSet;
    public static string sListWithTypeOfArg2;
    public static string sBoolean_TypesMustShareDomain;
    public static string sSymbolCalculated;
    public static string sExpressionNotComplete;
    public static string sOclSyntaxError;
    public static string sEvaluatorUnfitForEvaluation;
    public static string sVariablelacksType;
    public static string sArgumentsDoNotConform;
    public static string sOperationsCannotHaveQualifiers;
    public static string sInvalidConstraint;
}
public class BoldOclParserCoreBackend.Units.BoldOclParserCoreBackend : object {
    public static string PrintExpr(OclNode node);
}
public class BoldOclSemantics.Units.BoldOclSemantics : object {
    public static int GetFormArgIndex(int ActArgIndex, IOclOperation op);
}
public class BORepresentationConst.Units.BORepresentationConst : object {
    public static string sNoSuchRoleInClass;
    public static string sIllegalArrayDimension;
    public static string sNoMemberWithName;
    public static string sObjectNotAssigned;
    public static string sElementNotObject;
    public static string sNoSuitableConstructorFound;
    public static string sElementIsReadOnly;
    public static string sListIsReadOnly;
    public static string sPreDeleteRaisedException;
    public static string sPreDeleteFailed;
    public static string sParameterNotReferingAnEcoObject;
    public static string sCannotDeleteDeletedObject;
    public static string sCannotDeleteObject;
    public static string sCannotSetOrderNo_NotAReference;
    public static string sIncompatibleAssignment;
    public static string sListOfLinkObjectsIsReadOnly;
    public static string sEndOfLinkObjectIsReadOnly;
    public static string sMemberIsDerived;
    public static string sDerivedAssociationIsReadOnly;
    public static string sEnumeratorIsPositionedBeforeFirstElement;
    public static string sEnumeratorIsPositionedAfterLastElement;
    public static string sClassIsNotInModel;
    public static string sStringTooLong;
    public static string sMemberFailureMessage;
    public static string sClassFailureMessage;
    public static string sObjectsBelongToDifferentEcoSpace;
    public static string ObjectIsAlreadyDeleted;
    public static string sEcoTypeLacksNetClass;
    public static string sInvalidCallToInternalConstructor;
    public static string sUnknownMethodOnClass;
    public static string sCannotSetStateAttributeDirectly;
    public static string sAttributeDoesNotAllowNull;
    public static string CacheNotActive;
    public static string sIncompatibleTypesInSetAsObject;
}
public class BORepresentationConst.Units.BORepresentationConstxx : object {
    public static string sRoleNotQualified;
    public static string sNoCommonSuperClass;
    public static string sNoSuchRoleInClass;
    public static string sNoPersistenceControllerAvailable;
    public static string sForeignObjectsInUpdateDatabase;
    public static string sSupportsSyncIsNotEnabled;
    public static string sOptimisticLockingConflict;
    public static string sListContainsNullLocator;
    public static string sCantUpdateTransientObject;
    public static string sCantAccessVersionInfoWithoutAPersistenceMapper;
    public static string sRegionHasWrongRootClass;
    public static string sRegionLogAddedRegions;
    public static string sRegionLogExpandingParents;
    public static string sRegionLogExpandingSubregions;
    public static string sParseErrorMessage;
    public static string sParseWrongToken;
    public static string sParseClassNameExpected;
    public static string sParseMemberNameExpected;
    public static string sParseRegionNameExpected;
    public static string sParseXNotaMemberOfY;
    public static string sParseMemberNotARole;
    public static string sParseMultipleDefinitions;
    public static string sParseUnknownClassName;
    public static string sParseUndefinedReference;
    public static string sMultiLinksNotModifiableInICache;
    public static string sCannotSetLinkObjectReference;
    public static string sCannotLinkLinkedSingleLink;
    public static string sCannotLinkAssignedSingleLink;
    public static string sCannotSetOrderNumOnUnassignedLink;
    public static string sCannotSetValueOfNonembeddedLinkInCache;
    public static string sCacheContentMismatch;
    public static string sIllegalArrayDimension;
    public static string sAllowObjectDestructionMatchingCallMissing;
    public static string sObjectNotDestroyable;
    public static string sCantInstansiateAbstract;
    public static string sCannotDestroyDirectly;
    public static string sNoMemberWithName;
    public static string sCannotMakePersistent;
    public static string sCannotMakeLinkPersistent;
    public static string sObjectIDIsInternal;
    public static string sObjectNotAssigned;
    public static string sElementNotObject;
    public static string sNoSuitableConstructorFound;
    public static string sElementIsReadOnly;
    public static string sListIsReadOnly;
    public static string sPreDeleteFailed;
    public static string sParameterNotReferingAnEcoObject;
    public static string sCannotDeleteDeletedObject;
    public static string sCannotDeleteObject;
    public static string sCannotSetAssociationEndDirectly;
    public static string sCannotSetOrderNo_NotAReference;
    public static string sIncompatibleAssignment;
    public static string sNoObjectsInParameter;
    public static string sClassNotVersioned;
    public static string sListOfLinkObjectsIsReadOnly;
    public static string sEndOfLinkObjectIsReadOnly;
    public static string sMemberIsDerived;
    public static string sDerivedAssociationIsReadOnly;
    public static string sEnumeratorIsPositionedBeforeFirstElement;
    public static string sEnumeratorIsPositionedAfterLastElement;
    public static string sClassIsNotInModel;
    public static string sStringTooLong;
    public static string sMemberFailureMessage;
    public static string sClassFailureMessage;
    public static string sObjectsBelongToDifferentEcoSpace;
    public static string sEcoTypeLacksNetClass;
    public static string sInvalidCallToInternalConstructor;
    public static string sUnknownMethodOnClass;
    public static string sCannotSetStateAttributeDirectly;
    public static string sAttributeDoesNotAllowNull;
    public static string CacheNotActive;
    public static string sIncompatibleTypesInSetAsObject;
    public static string sWrongParamCount;
    public static string sInvalidParamType;
    public static string sUnknownStateName;
    public static string sUnknownRegionName;
    public static string sUnknownTriggerName;
    public static string sAmbiguousTransitionsForTrigger;
    public static string sNoValidInitialTransition;
    public static string sNoTransition;
}
public class Eco.AutoContainers.AutoContainerArgs : object {
    private bool m_forceReadOnly;
    private EcoSpace m_EcoSpace;
    private AutoContainerMemberVisibility m_MemberVisibility;
    private ContainerReusage m_ContainerReusage;
    private bool m_ShowModal;
    public bool ForceReadOnly { get; }
    public AutoContainerMemberVisibility MemberVisibility { get; }
    public EcoSpace EcoSpace { get; }
    public ContainerReusage ContainerReusage { get; }
    public bool ShowModal { get; }
    public AutoContainerArgs(EcoSpace ecoSpace);
    public AutoContainerArgs(EcoSpace ecoSpace, bool forceReadOnly, AutoContainerMemberVisibility memberVisibility, ContainerReusage containerReusage, bool showModal);
    public AutoContainerArgs(EcoSpace ecoSpace, bool forceReadOnly, AutoContainerMemberVisibility memberVisibility, ContainerReusage containerReusage);
    public bool get_ForceReadOnly();
    public AutoContainerMemberVisibility get_MemberVisibility();
    public EcoSpace get_EcoSpace();
    public ContainerReusage get_ContainerReusage();
    public bool get_ShowModal();
}
public enum Eco.AutoContainers.AutoContainerMemberVisibility : Enum {
    public int value__;
    public static AutoContainerMemberVisibility AllMembers;
    public static AutoContainerMemberVisibility ProtectedOrHigher;
    public static AutoContainerMemberVisibility PublicOnly;
}
public class Eco.AutoContainers.AutoContainerService : object {
    private static AutoContainerService c_Instance;
    private Dictionary`2<IElement, IAutoContainer> m_HashElement;
    private Dictionary`2<IClassifier, IAutoContainer> m_HashClass;
    private List`1<IAutoContainerFactory> mapperCollection;
    public static IAutoContainerService Instance { get; }
    private static AutoContainerService();
    public static IAutoContainerService get_Instance();
    private bool HistoricalReadOnly(IObject o, AutoContainerArgs autoContainerArgs);
    public sealed virtual IAutoContainer CreateContainer(IElement element, AutoContainerArgs autoContainerArgs);
    public sealed virtual void RemoveAllContainers();
    private void RemoveContainerFromHash(Dictionary`2<IElement, IAutoContainer> dictionary, IAutoContainer value);
    private void RemoveContainerFromHash(Dictionary`2<IClassifier, IAutoContainer> dictionary, IAutoContainer value);
    private void RemoveContainer(IAutoContainer container);
    private void OnContainerDisposed(object sender, EventArgs e);
    private void StoreContainer(IAutoContainer container, IElement element);
    private IAutoContainer RetrieveContainerForClass(IClassifier classifier);
    private IAutoContainer RetrieveContainerForElement(IElement element);
    public sealed virtual IAutoContainer RetrieveContainer(IElement element, AutoContainerArgs autoContainerArgs);
    public sealed virtual void RegisterContainerForElement(IAutoContainer container, IElement element);
    public sealed virtual void UnregisterContainer(IAutoContainer container);
    public IAutoContainer CreateContainer(EcoSpace ecoSpace, IElement element);
    public sealed virtual void AddFactory(IAutoContainerFactory autoContainerFactory);
    public sealed virtual bool RemoveFactory(IAutoContainerFactory autoContainerFactory);
    public sealed virtual ArrayList RegisteredFactories();
    private IAutoContainer AutoContainerForClassifier(IClassifier classifier);
}
public enum Eco.AutoContainers.ContainerReusage : Enum {
    public int value__;
    public static ContainerReusage NeverReuse;
    public static ContainerReusage ReuseForClass;
    public static ContainerReusage ReuseForElement;
}
public interface Eco.AutoContainers.IAutoContainer {
    unknown EcoSpace EcoSpace {public set; }
    public bool IsDisposed { get; }
    public abstract virtual void BuildControls(IElement element, AutoContainerArgs autoContainerArgs);
    public abstract virtual void HookUpGUI(EcoSpace ecoSpace, IElement element);
    public abstract virtual void set_EcoSpace(EcoSpace value);
    public abstract virtual void Show(AutoContainerArgs autoContainerArgs);
    public abstract virtual bool get_IsDisposed();
}
public interface Eco.AutoContainers.IAutoContainerFactory {
    public IAutoContainer AutoContainer { get; }
    public abstract virtual IAutoContainer get_AutoContainer();
    public abstract virtual bool Matches(IModelElement modelElement);
}
public interface Eco.AutoContainers.IAutoContainerService {
    public abstract virtual IAutoContainer RetrieveContainer(IElement element, AutoContainerArgs autoContainerArgs);
    public abstract virtual void RegisterContainerForElement(IAutoContainer container, IElement element);
    public abstract virtual void UnregisterContainer(IAutoContainer container);
    public abstract virtual IAutoContainer CreateContainer(IElement element, AutoContainerArgs autoContainerArgs);
    public abstract virtual void AddFactory(IAutoContainerFactory autoContainerFactory);
    public abstract virtual bool RemoveFactory(IAutoContainerFactory autoContainerFactory);
    public abstract virtual ArrayList RegisteredFactories();
    public abstract virtual void RemoveAllContainers();
}
public class Eco.Cache.ChainedCacheBase : EcoSpacePart {
    private ICache m_nextCache;
    public ICache NextCache { get; public set; }
    public bool IsActive { get; }
    public ICollection`1<Locator> DeleteStack { get; }
    public ICache get_NextCache();
    public void set_NextCache(ICache value);
    protected virtual void DoActivate();
    public virtual bool get_IsActive();
    public virtual void SetCurrentValue(Locator locator, IStructuralFeature structuralFeature, object value);
    public virtual Locator[] GetAllLocators();
    public virtual void ApplyTranslationList(IdTranslationList idTranslationList);
    public sealed virtual void SetObjectId(Locator locator, ObjectId newId);
    public virtual void add_ValueChanged(ValueChangedDelegate value);
    public virtual void remove_ValueChanged(ValueChangedDelegate value);
    public virtual void add_LocatorAdded(LocatorEventHandler value);
    public virtual void remove_LocatorAdded(LocatorEventHandler value);
    public virtual void add_DirtyChanged(LocatorEventHandler value);
    public virtual void remove_DirtyChanged(LocatorEventHandler value);
    public virtual void add_ExistenceChanged(LocatorEventHandler value);
    public virtual void remove_ExistenceChanged(LocatorEventHandler value);
    public virtual void add_CanRelease(CanReleaseDelegate value);
    public virtual void remove_CanRelease(CanReleaseDelegate value);
    public virtual void add_ExtentInvalidated(ExtentChangedEventHandler value);
    public virtual void remove_ExtentInvalidated(ExtentChangedEventHandler value);
    public virtual Locator GetEnsuredLocatorById(ObjectId objectId);
    public virtual Locator GetLocatorById(ObjectId objectId);
    public virtual ObjectId GetIdByLocator(Locator locator);
    public virtual Locator CreateNewObject(IClass class_);
    public virtual Locator CreateNewObject(IClass class_, ILoopBack loopback);
    public virtual void DestroyObject(Locator locator);
    public virtual IClass GetUmlClass(Locator locator);
    public virtual void SetExistenceState(Locator locator, ExistenceState value);
    public virtual ExistenceState GetExistenceState(Locator locator);
    public virtual void SetPersistenceState(Locator locator, PersistenceState value);
    public virtual PersistenceState GetPersistenceState(Locator locator);
    public virtual bool IsPersistent(Locator locator);
    public virtual bool IsDirty(Locator locator);
    public virtual bool IsDefaultFetched(Locator locator);
    public virtual bool Contains(Locator locator);
    public virtual int GetTimestamp(Locator locator);
    public virtual void SetTimestamp(Locator locator, int value);
    public virtual void SetCurrentOrderNo(Locator locator, IStructuralFeature structuralFeature, int orderNo);
    public virtual void SetCurrentAndFetchedOrderNo(Locator locator, IStructuralFeature structuralFeature, int orderNo);
    public virtual int GetCurrentOrderNo(Locator locator, IStructuralFeature structuralFeature);
    public virtual PersistenceState GetMemberPersistenceState(Locator locator, IStructuralFeature structuralFeature);
    public virtual void SetMemberPersistenceState(Locator locator, IStructuralFeature structuralFeature, PersistenceState value);
    public virtual object GetCurrentValue(Locator locator, IStructuralFeature structuralFeature);
    public virtual object GetCurrentValueRaw(Locator locator, IStructuralFeature structuralFeature);
    public virtual object GetFetchedValueRaw(Locator locator, IStructuralFeature structuralFeature);
    public virtual object GetFetchedValue(Locator locator, IStructuralFeature structuralFeature);
    public virtual bool GetMemberHasFetchedValue(Locator locator, IStructuralFeature structuralFeature);
    public virtual int GetFetchedOrderNo(Locator locator, IStructuralFeature structuralFeature);
    public virtual void SetFetchedValue(Locator locator, IStructuralFeature structuralFeature, object value);
    public virtual void SetCurrentAndFetchedValue(Locator locator, IStructuralFeature structuralFeature, object value);
    public virtual bool GetExtentIsCurrent(IClass c);
    public virtual void InvalidateExtent(IClass c);
    public virtual void SetExtentCurrent(IClass c);
    public sealed virtual ICollection`1<Locator> get_DeleteStack();
    public virtual void CleanForFree();
    public sealed virtual object GetAsSharedBigValue(Locator locator, IAttribute attribute, object sourceValue);
    public sealed virtual void RememberGhostFKCreatedUntilNextSave(Locator locator);
    public sealed virtual List`1<Locator> GetAllGhostFKCreatedAndClearList();
}
public class Eco.Cache.ChangeDelegate : MulticastDelegate {
    public ChangeDelegate(object object, IntPtr method);
    public virtual void Invoke(string message);
    public virtual IAsyncResult BeginInvoke(string message, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
internal class Eco.Framework.CodeAutoDerivedMember : DerivedMember {
    public CodeAutoDerivedMember(DerivedMemberManager manager, IObjectInstance obj, IStructuralFeature member);
    protected virtual void DoDeriveAndSubscribe(bool subscribe);
}
internal class Eco.Framework.CodeDerivedMember : DerivedMember {
    public CodeDerivedMember(DerivedMemberManager manager, IObjectInstance obj, IStructuralFeature member);
    protected virtual void DoDeriveAndSubscribe(bool subscribe);
}
internal class Eco.Framework.DefaultDerivedMember : DerivedMember {
    public DefaultDerivedMember(DerivedMemberManager manager, IObjectInstance obj, IStructuralFeature member);
    protected virtual void DoDeriveAndSubscribe(bool subscribe);
}
public class Eco.Framework.DefaultImpl.ChangeHandlerImpl : EcoSpacePartWithTypeSystem {
    private ICache m_Cache;
    private IObjectRepresentationProvider m_ObjRepProv;
    private IPersistenceMapper m_PersistenceMapper;
    private List`1<IChange> m_List;
    private SyncVersion m_ChangesCurrentTo;
    private List`1<SyncVersion> m_IgnoreVersions;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
private DateTime <LatestServerRestartDiscovered>k__BackingField;
    public ICache Cache { get; public set; }
    public IObjectRepresentationProvider ObjectRepresentationProvider { get; public set; }
    public IPersistenceMapper PersistenceMapper { get; public set; }
    public DateTime LatestServerRestartDiscovered { get; internal set; }
    public SyncVersion ChangesCurrentTo { get; public set; }
    public SyncVersion[] IgnoreVersions { get; }
    public ChangeHandlerImpl(IEcoTypeSystem typeSystem);
    protected virtual void DoActivate();
    protected virtual void DoDeactivate();
    public virtual void CleanForFree();
    private void Write(SyncVersion sv, BinaryWriter writer);
    private SyncVersion ReadSyncVersion(BinaryReader reader);
    protected virtual void DoSerialize(Stream target, EcoSpaceSerializationConfig config);
    protected virtual void DoDeserialize(Stream source, BinaryReader reader);
    public ICache get_Cache();
    public void set_Cache(ICache value);
    public IObjectRepresentationProvider get_ObjectRepresentationProvider();
    public void set_ObjectRepresentationProvider(IObjectRepresentationProvider value);
    public IPersistenceMapper get_PersistenceMapper();
    public void set_PersistenceMapper(IPersistenceMapper value);
    public sealed virtual void AddMemberChanged(Locator locator, IStructuralFeature feature);
    public sealed virtual void AddObjectCreated(ObjectId obj);
    public sealed virtual void AddObjectDeleted(Locator locator);
    public sealed virtual void AddLinkConflict(Locator locator, IAssociationEnd end, Locator newValue);
    public sealed virtual void AddAllChanged();
    private void FetchNewDbValues(IChange[] changes);
    public sealed virtual void ApplyAll();
    public sealed virtual IChange[] GetChanges();
    private void Remove(Change change);
    [CompilerGeneratedAttribute]
internal void set_LatestServerRestartDiscovered(DateTime value);
    [CompilerGeneratedAttribute]
public sealed virtual DateTime get_LatestServerRestartDiscovered();
    public sealed virtual SyncVersion get_ChangesCurrentTo();
    public sealed virtual void set_ChangesCurrentTo(SyncVersion value);
    public sealed virtual SyncVersion[] get_IgnoreVersions();
    public sealed virtual void IgnoreVersion(SyncVersion version);
}
public class Eco.Framework.DefaultImpl.FetchedBlockHandler : EcoSpacePart {
    private ICache m_Cache;
    private IChangeHandler m_ChangeHandler;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
private static EventHandler`1<EventArgs> OnApplyDataBlockEventUsedForDebugAndLatencySimulation;
    private int _simulatedLatencyForDebug;
    public static int kBigValueThreshold;
    public ICache Cache { get; public set; }
    public IChangeHandler ChangeHandler { get; public set; }
    private static FetchedBlockHandler();
    public ICache get_Cache();
    public void set_Cache(ICache value);
    public IChangeHandler get_ChangeHandler();
    public void set_ChangeHandler(IChangeHandler value);
    private bool Equal(object o1, object o2);
    public sealed virtual void ApplyAttributeValue(Locator loc, IAttribute attribute, object sourceValue);
    private Locator LocatorForId(ObjectId id);
    [CompilerGeneratedAttribute]
public static void add_OnApplyDataBlockEventUsedForDebugAndLatencySimulation(EventHandler`1<EventArgs> value);
    [CompilerGeneratedAttribute]
public static void remove_OnApplyDataBlockEventUsedForDebugAndLatencySimulation(EventHandler`1<EventArgs> value);
    private void NullOutValuesAndSetAsDeleted(Locator targetLocator);
    public sealed virtual void ApplyDataBlock(Datablock block);
    private object PossiblyUpgradeToSharedBigValue(Locator targetLocator, IAttribute feature, object sourceValue);
    private void HandleLog(Dictionary`2<string, int> detailedlog, object sourceValue, IClass umlClass, IStructuralFeature feature, Int32& detaillogReportDefaultLoadOnce);
    private void ApplyDirectMultiLinkFromDatablock(MultiAssociationEnd sourceValue, Locator loc, IAssociationEnd assocEnd);
    public sealed virtual void ApplyIndirectMultilink(Locator loc, IAssociationEnd assocEnd, IEnumerable`1<LocatorPair> sourceValue);
    private void ApplyIndirectMultilinkFromDatablock(Locator targetLocator, IAssociationEnd assocEnd, IndirectMultiAssociationEnd sourceValue);
    public sealed virtual void ApplyIndirectSinglelink(Locator loc, IAssociationEnd assocEnd, LocatorPair sourceValue);
    private void ApplyIndirectSinglelinkFromDatablock(IndirectSingleAssociationEnd sourceValue, Locator loc, IAssociationEnd assocEnd);
    public sealed virtual void ApplyMultilink(Locator loc, IAssociationEnd assocEnd, IEnumerable`1<Locator> sourceValue, Dictionary`2<ObjectId, int> storedOrderNo);
    private bool ApplyEmbeddedLink(Locator loc, IAssociationEnd assocEnd, Locator value, int orderNo);
    public sealed virtual void ApplySinglelink(Locator loc, IAssociationEnd assocEnd, Locator sourceValue, int orderNo);
    private bool InternalApplySinglelink(Locator loc, IAssociationEnd assocEnd, Locator sourceValue, int orderNo);
    protected virtual void DoActivate();
    public virtual void CleanForFree();
}
public class Eco.Framework.DefaultImpl.OclServicesImpl : object {
    private OclServiceImpl m_OclServiceImpl;
    private IActionLanguageService m_ActionLanguageService;
    private OclPsServiceImpl m_OclPsService;
    private OclSupport m_OclSupport;
    public IOclService OclService { get; }
    public IActionLanguageService ActionLanguageService { get; }
    public IOclPsService OclPsService { get; }
    public IVariableFactoryService VariableFactory { get; public set; }
    public IObjectFactoryService ObjectFactory { get; public set; }
    public IVersionService VersionService { get; public set; }
    public IAutoSubscriptionService AutoSubscriptionService { get; public set; }
    public IAsyncSupportService AsyncSupportService { get; public set; }
    public IPersistenceService PersistenceService { get; public set; }
    public IUndoService UndoService { get; public set; }
    public IExtentService ExtentService { get; public set; }
    public IExternalIdService ExternalIdService { get; public set; }
    public ICache Cache { get; public set; }
    public IObjectRepresentationProvider ObjectRepresentationProvider { get; public set; }
    public OclServicesImpl(IEcoTypeSystem typeSystem, IEcoServiceProvider serviceProvider);
    public void ClearCachedExpressions();
    public sealed virtual void CleanForFree();
    public sealed virtual void PruneResources(bool LowMemoryCondition);
    public sealed virtual EcoRuntimeInformation GetRuntimeInformation(IExecutionAndDebug owner, DebugSettingsStack settings, int depth);
    public IOclService get_OclService();
    public IActionLanguageService get_ActionLanguageService();
    public IOclPsService get_OclPsService();
    public IVariableFactoryService get_VariableFactory();
    public void set_VariableFactory(IVariableFactoryService value);
    public IObjectFactoryService get_ObjectFactory();
    public void set_ObjectFactory(IObjectFactoryService value);
    public IVersionService get_VersionService();
    public void set_VersionService(IVersionService value);
    public IAutoSubscriptionService get_AutoSubscriptionService();
    public void set_AutoSubscriptionService(IAutoSubscriptionService value);
    public IAsyncSupportService get_AsyncSupportService();
    public void set_AsyncSupportService(IAsyncSupportService value);
    public IPersistenceService get_PersistenceService();
    public void set_PersistenceService(IPersistenceService value);
    public IUndoService get_UndoService();
    public void set_UndoService(IUndoService value);
    public IExtentService get_ExtentService();
    public void set_ExtentService(IExtentService value);
    public IExternalIdService get_ExternalIdService();
    public void set_ExternalIdService(IExternalIdService value);
    public ICache get_Cache();
    public void set_Cache(ICache value);
    public IObjectRepresentationProvider get_ObjectRepresentationProvider();
    public void set_ObjectRepresentationProvider(IObjectRepresentationProvider value);
}
public class Eco.Framework.DefaultImpl.PersistenceHandlerImpl : EcoSpacePartWithTypeSystem {
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
private LocatorArrayEventHandler ObjectsUpdated;
    private ICache m_Cache;
    private int m_TimeStampOfLatestUpdate;
    private bool m_SupportsSync;
    private bool m_SupportsSyncInit;
    private IPersistenceMapper m_PMapper;
    private bool m_UpdateWholeObjects;
    private IOptimisticLockHandler m_OptimisticLockHandler;
    private IChangeHandler m_ChangeHandler;
    private bool m_FirstCurrentEnsured;
    private IFetchHandler m_FetchHandler;
    private bool _initiated;
    private HashSet`1<Locator> _currentWorkSetHash;
    private List`1<Locator> _locatorsToAddDueToTouchByOnChange;
    private List`1<object> _worksetlock;
    private Dictionary`2<Guid, ConsolidaterRow> _ConsolidatorFetchRequest;
    private static int _savestats_nonaddeddoubletts;
    private static int _savestats_handledbyother;
    private static int _savestats_consolidatedLoc;
    private static int _savestats_handledbymeToSaveTime;
    private static int _savestats_wasfetchedalreadySoAvoided;
    private static int _savestats_wasfetchedalreadySoAvoided_MemberSpecific;
    private static int _savestats_BiggestResultingConsolidatedBlock;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
private EventHandler`1<PreviewFetchedDataBlockArgs> OnPreviewFetchedDataBlock;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
private IAsyncSupportService <AsyncSupportService>k__BackingField;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
private IDirtyListService <DirtyListService>k__BackingField;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
private int <CurrentModelChecksumForPrecondition>k__BackingField;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
private IFetchConsolidationService <FetchConsolidationService>k__BackingField;
    public IPersistenceMapper PersistenceMapper { get; public set; }
    public IOptimisticLockHandler OptimisticLockHandler { get; public set; }
    public bool UpdateWholeObjects { get; public set; }
    public ICache Cache { get; public set; }
    public IChangeHandler ChangeHandler { get; public set; }
    public IFetchHandler FetchHandler { get; public set; }
    public int MaxSavedVersion { get; }
    public bool IsPersistent { get; }
    public bool SupportsSync { get; }
    public IAsyncSupportService AsyncSupportService { get; public set; }
    public IDirtyListService DirtyListService { get; public set; }
    public int CurrentModelChecksumForPrecondition { get; public set; }
    public IFetchConsolidationService FetchConsolidationService { get; public set; }
    public PersistenceHandlerImpl(IEcoTypeSystem TypeSystem);
    public IPersistenceMapper get_PersistenceMapper();
    public void set_PersistenceMapper(IPersistenceMapper value);
    public IOptimisticLockHandler get_OptimisticLockHandler();
    public void set_OptimisticLockHandler(IOptimisticLockHandler value);
    public bool get_UpdateWholeObjects();
    public void set_UpdateWholeObjects(bool value);
    public ICache get_Cache();
    public void set_Cache(ICache value);
    public IChangeHandler get_ChangeHandler();
    public void set_ChangeHandler(IChangeHandler value);
    [CompilerGeneratedAttribute]
public sealed virtual void add_ObjectsUpdated(LocatorArrayEventHandler value);
    [CompilerGeneratedAttribute]
public sealed virtual void remove_ObjectsUpdated(LocatorArrayEventHandler value);
    public IFetchHandler get_FetchHandler();
    public void set_FetchHandler(IFetchHandler value);
    public sealed virtual ICollection`1<Locator> FetchLinksWithObjects(ICollection`1<Locator> objects, IAssociationEnd assocEnd);
    public sealed virtual ICollection`1<Locator> GetAllWithCondition(AbstractCondition Condition, int MaxAnswers, int Offset);
    public sealed virtual Datablock GetValueWithCondition(AbstractCondition Condition, int MaxAnswers, int Offset);
    public sealed virtual void UpdateDatabaseWithList(ICollection`1<Locator> LocatorsToUpdate);
    private void DirtyListService_DirtyListChanged(object sender, EventArgs e);
    private void InternalUpdateDatabaseWithLocators(ICollection`1<Locator> LocatorsToUpdate, List`1<Locator> seensysasyncticketsthatpointsatnewobjects);
    private void CleanAwayKeysThatPointToDeletedObjects();
    private static void DoOnUpdateAndCheckForAsyncTickets(Locator l, List`1<Locator> seensysasyncticketsthatpointsatnewobjects, List`1<Locator> newobjectspointedtobyasyncticket);
    private void CheckForIllegals(ICollection`1<Locator> LocatorsToUpdate);
    public sealed virtual void SuspectExternalUpdateInvalidate(ICollection`1<Locator> locators);
    public sealed virtual int get_MaxSavedVersion();
    public sealed virtual DateTime TimeForVersion(int version);
    public sealed virtual int VersionAtTime(DateTime clockTime);
    public static Datablock BuildBlockForUpdate(ICache cache, ICollection`1<Locator> locatorList, bool updateWholeObjects, bool ignoreSaveAction);
    private void EnsureFirstCurrentToSyncVersion();
    public sealed virtual bool get_IsPersistent();
    public sealed virtual bool get_SupportsSync();
    public void RetrieveChanges_AddEmbeddedMembers(Locator l, IClass c);
    public sealed virtual void RetrieveChanges(DBChangeCollection& ignoredChanges);
    public sealed virtual void Fetch(ICollection`1<Locator> locators, IStructuralFeature[] members, FetchStrategy fetchStrategy);
    private void InternalFetchDoneInAsync(ObjectIdList idList, IStructuralFeature[] members, FetchStrategy fetchStrategy, bool checkFetchConsolidation, Guid guidForThisRow, ConsolidaterRow thisrow);
    [CompilerGeneratedAttribute]
public sealed virtual void add_OnPreviewFetchedDataBlock(EventHandler`1<PreviewFetchedDataBlockArgs> value);
    [CompilerGeneratedAttribute]
public sealed virtual void remove_OnPreviewFetchedDataBlock(EventHandler`1<PreviewFetchedDataBlockArgs> value);
    private bool CheckAndConsolidateFetchRequest(Guid guid, ConsolidaterRow thisrow, ObjectIdList& idList);
    private bool CheckIfEqualValues(ConsolidaterRow r1, ConsolidaterRow r2, bool alsocheckLocators);
    protected virtual void DoActivate();
    protected virtual void DoDeactivate();
    public virtual void CleanForFree();
    [CompilerGeneratedAttribute]
public IAsyncSupportService get_AsyncSupportService();
    [CompilerGeneratedAttribute]
public void set_AsyncSupportService(IAsyncSupportService value);
    [CompilerGeneratedAttribute]
public IDirtyListService get_DirtyListService();
    [CompilerGeneratedAttribute]
public void set_DirtyListService(IDirtyListService value);
    [CompilerGeneratedAttribute]
public int get_CurrentModelChecksumForPrecondition();
    [CompilerGeneratedAttribute]
public void set_CurrentModelChecksumForPrecondition(int value);
    [CompilerGeneratedAttribute]
public IFetchConsolidationService get_FetchConsolidationService();
    [CompilerGeneratedAttribute]
public void set_FetchConsolidationService(IFetchConsolidationService value);
    [CompilerGeneratedAttribute]
private void <EnsureFirstCurrentToSyncVersion>b__51_0();
    [CompilerGeneratedAttribute]
private void <get_SupportsSync>b__55_0();
}
public class Eco.Framework.DefaultImpl.TypeSystemServiceImpl : object {
    private IEcoTypeSystem m_TypeSystem;
    private OclServiceImpl m_StaticOclService;
    private EcoServiceProvider m_ServiceProvider;
    public IEcoTypeSystem TypeSystem { get; }
    public IEcoServiceProvider StaticEcoServices { get; }
    public ITypeSystemService TypeSystemService { get; }
    public TypeSystemServiceImpl(Type ecoSpaceType);
    public TypeSystemServiceImpl(IEcoTypeSystem typeSystem);
    private void CreateServices(Type ecoSpaceType);
    public sealed virtual IEcoTypeSystem get_TypeSystem();
    public sealed virtual IEcoServiceProvider get_StaticEcoServices();
    public ITypeSystemService get_TypeSystemService();
}
public class Eco.Framework.DefaultImpl.UpdateResultHandler : object {
    private ICache m_Cache;
    private IChangeHandler m_ChangeHandler;
    private ICache Cache { get; }
    private IChangeHandler ChangeHandler { get; }
    public UpdateResultHandler(ICache cache, IChangeHandler changeHandler);
    private ICache get_Cache();
    private IChangeHandler get_ChangeHandler();
    private void HandleOptimisticFailiure(UpdateResult updResult);
    public void HandleUpdateResult(ICollection`1<Locator> locatorsToUpdate, IdTranslationList translationList, UpdateResult updResult);
    private void EndUpdateMembers(Locator locator, bool isNew);
    private void EndUpdateForAll(ICollection`1<Locator> locatorList, IList`1<Locator> locatorsToDestroy);
}
public abstract class Eco.Framework.DerivedMember : AbstractDeriver {
    private DerivedMemberManager manager;
    protected IObjectInstance objectWithDerivation;
    protected IStructuralFeature member;
    protected object _val;
    private bool _submitted;
    public Nullable`1<DateTime> LastTimeValueWasAccessed;
    public Nullable`1<DateTime> LastTimeWithSubscribers;
    protected bool memberAllowsNull;
    public bool CanYieldLock { get; }
    public IEcoServiceProvider ServiceProvider { get; }
    protected DerivedMemberManager Manager { get; }
    public object Value { get; }
    public object SyncRoot { get; }
    internal bool HasSubscribers { get; }
    public string GetDebugInfoOfDeriver { get; }
    protected DerivedMember(DerivedMemberManager manager, IObjectInstance obj, IStructuralFeature member);
    public void NoSubscribers();
    public virtual bool get_CanYieldLock();
    public virtual IEcoServiceProvider get_ServiceProvider();
    protected DerivedMemberManager get_Manager();
    protected virtual void HandleRecursiveDerive();
    protected virtual void DoNotifyOutOfDate();
    public object get_Value();
    public virtual object get_SyncRoot();
    protected void ValidateValue(object val);
    public virtual void CleanForFree();
    internal bool get_HasSubscribers();
    public sealed virtual void PruneResources(bool LowMemoryCondition);
    public virtual string get_GetDebugInfoOfDeriver();
    public sealed virtual EcoRuntimeInformation GetRuntimeInformation(IExecutionAndDebug owner, DebugSettingsStack settings, int depth);
}
public class Eco.Framework.DerivedMemberManager : object {
    private List`1<DerivedFeatureMembers> m_DerivedFeaturesList;
    private IAutoSubscriptionService m_AutoSubscriptionService;
    private IAsyncSupportService _asyncsupport;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
private IFetchConsolidationService <FetchConsolidationService>k__BackingField;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
private ValueChangedDelegate ValueChanged;
    public int PruneAfterSeconds;
    public IAutoSubscriptionService AutoSubscriptionService { get; }
    public IAsyncSupportService AsyncSupportService { get; }
    public IFetchConsolidationService FetchConsolidationService { get; public set; }
    public DerivedMemberManager(IAutoSubscriptionService autoSubscriptionService, IAsyncSupportService asyncsupport);
    public IAutoSubscriptionService get_AutoSubscriptionService();
    public IAsyncSupportService get_AsyncSupportService();
    [CompilerGeneratedAttribute]
public IFetchConsolidationService get_FetchConsolidationService();
    [CompilerGeneratedAttribute]
public void set_FetchConsolidationService(IFetchConsolidationService value);
    private DerivedMember GetEnsuredDerivedMember(IObjectInstance obj, IStructuralFeature member);
    [CompilerGeneratedAttribute]
public sealed virtual void add_ValueChanged(ValueChangedDelegate value);
    [CompilerGeneratedAttribute]
public sealed virtual void remove_ValueChanged(ValueChangedDelegate value);
    private DerivedMember GetDerivedMember(IProperty prop);
    public sealed virtual object GetMemberValue(IProperty prop);
    public sealed virtual bool GetIsDerived(IProperty prop);
    internal void SendEvent(IProperty prop, EventArgs args);
    public sealed virtual void CleanForFree();
    public sealed virtual void PruneResources(bool LowMemoryCondition);
    public sealed virtual EcoRuntimeInformation GetRuntimeInformation(IExecutionAndDebug owner, DebugSettingsStack settings, int depth);
}
public class Eco.Framework.EcoServiceProvider : object {
    private Dictionary`2<Type, object> services;
    private Dictionary`2<Type, Dictionary`2<object, object>> keyedServices;
    [ObsoleteAttribute]
public virtual object GetEcoService(Type serviceType);
    public virtual T GetEcoService();
    public virtual T GetEcoService(object key);
    [ObsoleteAttribute]
public virtual void RegisterEcoService(Type serviceType, object service);
    public sealed virtual void RegisterEcoService(T service);
    public sealed virtual void RegisterEcoService(object key, T service);
    public void ActivateEcoSpaceParts();
    public void DeactivateEcoSpaceParts();
    public void CleanForFreeEcoSpaceParts();
}
public interface Eco.Framework.IChangeHandler {
    public SyncVersion ChangesCurrentTo { get; public set; }
    public SyncVersion[] IgnoreVersions { get; }
    public DateTime LatestServerRestartDiscovered { get; }
    public abstract virtual IChange[] GetChanges();
    public abstract virtual void ApplyAll();
    public abstract virtual void AddMemberChanged(Locator locator, IStructuralFeature feature);
    public abstract virtual void AddObjectCreated(ObjectId obj);
    public abstract virtual void AddObjectDeleted(Locator locator);
    public abstract virtual void AddLinkConflict(Locator locator, IAssociationEnd end, Locator newValue);
    public abstract virtual void AddAllChanged();
    public abstract virtual SyncVersion get_ChangesCurrentTo();
    public abstract virtual void set_ChangesCurrentTo(SyncVersion value);
    public abstract virtual void IgnoreVersion(SyncVersion version);
    public abstract virtual SyncVersion[] get_IgnoreVersions();
    public abstract virtual DateTime get_LatestServerRestartDiscovered();
}
public interface Eco.Framework.IDerivedMemberManager {
    public abstract virtual object GetMemberValue(IProperty prop);
    public abstract virtual bool GetIsDerived(IProperty prop);
    [CompilerGeneratedAttribute]
public abstract virtual void add_ValueChanged(ValueChangedDelegate value);
    [CompilerGeneratedAttribute]
public abstract virtual void remove_ValueChanged(ValueChangedDelegate value);
    public abstract virtual void CleanForFree();
}
public class Eco.Framework.Impl.ArrayAttributeCachePolicy : AttributeCachePolicy {
    public ArrayAttributeCachePolicy(ClassCachePolicy owner, IAttribute attribute, int memberContentIndex, int flagIndex);
    private object CloneIfNotNull(object value);
    public virtual void SetCurrentValue(CacheLocator owningLocator, object value);
    public virtual object GetCurrentValue(CacheLocator owningLocator);
    public virtual void SetFetchedValue(CacheLocator owningObject, object value);
}
public abstract class Eco.Framework.Impl.AssociationEndCachePolicy : MemberCachePolicy {
    private IAssociationEnd m_AssociationEnd;
    private IAssociationEnd m_MainOppositeEnd;
    private IOtherEndController m_MainOppositeEndController;
    public IAssociationEnd AssociationEnd { get; }
    public IAssociationEnd MainOppositeEnd { get; }
    public IOtherEndController MainOppositeEndController { get; }
    public IStructuralFeature StructuralFeature { get; }
    public AssociationEndCachePolicy(ClassCachePolicy owner, IAssociationEnd associationEnd, int memberContentIndex, int flagIndex);
    public IAssociationEnd get_AssociationEnd();
    public IAssociationEnd get_MainOppositeEnd();
    public IOtherEndController get_MainOppositeEndController();
    public virtual IStructuralFeature get_StructuralFeature();
    public virtual void Initialize(Object[] objectContents);
    public virtual void SetCurrentAndFetchedValue(object value, CacheLocator owningLocator);
    protected void SerializeNonEmbeddedLink(CacheLocator locator, Stream target, EcoSpaceSerializationConfig config);
    public virtual void Pass2();
}
public class Eco.Framework.Impl.AttributeCachePolicy : MemberCachePolicy {
    private IAttribute m_Attribute;
    private Type m_BaseType;
    public IStructuralFeature StructuralFeature { get; }
    public AttributeCachePolicy(ClassCachePolicy owner, IAttribute attribute, int memberContentIndex, int flagIndex);
    public virtual IStructuralFeature get_StructuralFeature();
    protected void ValidateDatatype(object value);
    public virtual void Initialize(Object[] objectContents);
    public virtual void SetCurrentAndFetchedValue(object value, CacheLocator owningLocator);
    protected virtual object TransformValueFromCacheToOutside(object value);
    protected virtual object TransformValueFromOutsideToCache(object value);
    public virtual void SetCurrentValue(CacheLocator owningLocator, object value);
    public virtual object GetCurrentValue(CacheLocator owningLocator);
    public virtual void SetFetchedValue(CacheLocator owningObject, object value);
    public virtual object GetFetchedValue(CacheLocator owningObject);
    public virtual void DoSerialize(CacheLocator locator, Stream target, EcoSpaceSerializationConfig config);
    public virtual void DoDeserialize(CacheLocator locator, Stream source, BinaryReader reader);
    public virtual void FreeMemberContent(Object[] objectContents);
    public virtual void SaveOldValue(Object[] objectContents);
    public virtual void ClearOldValue(Object[] objectContents);
}
public class Eco.Framework.Impl.CacheImpl : EcoSpacePartWithTypeSystem {
    private IAsyncSupportService _asyncSupportService;
    private GenericCollection`1<Locator> m_DeleteStack;
    private bool m_Persistent;
    private ClassCachePolicy[] m_ClassCachePolicies;
    private Boolean[] m_ExtentsCurrent;
    private LocatorDictionary m_Locators;
    private int m_InternalIdCounter;
    private LocatorFactory m_LocatorFactory;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
private ValueChangedDelegate ValueChanged;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
private LocatorEventHandler ExistenceChanged;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
private ExtentChangedEventHandler ExtentInvalidated;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
private LocatorEventHandler LocatorAdded;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
private LocatorEventHandler DirtyChanged;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
private CanReleaseDelegate CanRelease;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
private EventHandler`1<RealtimeChangeArgs> OnRealtimeChangeDetected;
    private static ReaderWriterLockReporting _lockForSharedBigValue;
    private static Dictionary`2<string, SharedBigValue> _SharedBigValueStorage;
    private HashSet`1<Locator> _RememberGhostFKCreatedUntilNextSave;
    public bool Persistent { get; public set; }
    public LocatorFactory LocatorFactory { get; public set; }
    public bool AsyncHandlingEnabled { get; }
    public ICollection`1<Locator> DeleteStack { get; }
    public bool IsActive { get; }
    public CacheImpl(IEcoTypeSystem typeSystem, IAsyncSupportService asyncSupportService);
    private static CacheImpl();
    public bool get_Persistent();
    public void set_Persistent(bool value);
    public LocatorFactory get_LocatorFactory();
    public void set_LocatorFactory(LocatorFactory value);
    public sealed virtual Locator GetEnsuredLocatorById(ObjectId objectID);
    public void MarkObjectDirty(CacheLocator locator);
    public void MarkObjectPossiblyCleaner(CacheLocator locator);
    private void AddLocator(CacheLocator locator);
    protected virtual void DoDeactivate();
    public virtual void CleanForFree();
    private void ExpandOptimisticLockingForSerialization(EcoSpaceSerializationConfig config, Dictionary`2<Locator, Locator> locatorsToStream);
    internal void RealtimeChangeDetected(CacheLocator locator, IStructuralFeature structuralFeature);
    protected virtual void DoSerialize(Stream target, EcoSpaceSerializationConfig config);
    protected virtual void DoDeserialize(Stream source, BinaryReader reader);
    protected virtual void DoActivate();
    private void OnDirtyChanged(CacheLocator locator);
    public sealed virtual IClass GetUmlClass(Locator locator);
    public ObjectId GetIdByLocator(CacheLocator locator);
    public ClassCachePolicy GetClassPolicy(CacheLocator locator);
    public Object[] GetObjectContents(CacheLocator locator);
    public bool GetMemberHasFetchedValue(CacheLocator locator, IStructuralFeature structuralFeature);
    public void MemberChanged(CacheLocator locator, IStructuralFeature structuralFeature);
    public void OnExistenceChanged(CacheLocator locator);
    public sealed virtual void ApplyTranslationList(IdTranslationList IdTranslationList);
    public sealed virtual void SetObjectId(Locator locator, ObjectId newId);
    public sealed virtual void SetExistenceState(Locator locator, ExistenceState value);
    public sealed virtual ExistenceState GetExistenceState(Locator locator);
    public sealed virtual void SetPersistenceState(Locator locator, PersistenceState value);
    public sealed virtual PersistenceState GetPersistenceState(Locator locator);
    public sealed virtual void DestroyObject(Locator locator);
    public sealed virtual void SetCurrentValue(Locator locator, IStructuralFeature StructuralFeature, object value);
    public object GetCurrentValue(CacheLocator locator, IStructuralFeature structuralFeature);
    public PersistenceState GetMemberPersistenceState(CacheLocator locator, IStructuralFeature structuralFeature);
    public sealed virtual void SetMemberPersistenceState(Locator locator, IStructuralFeature structuralFeature, PersistenceState value);
    public sealed virtual Locator CreateNewObject(IClass umlClass);
    private void InitializeLocator(IClass umlClass, CacheLocator loc, ILoopBack loopback);
    public sealed virtual Locator CreateNewObject(IClass umlClass, ILoopBack loopback);
    public sealed virtual void SetCurrentOrderNo(Locator locator, IStructuralFeature structuralFeature, int orderNo);
    public sealed virtual void SetCurrentAndFetchedOrderNo(Locator locator, IStructuralFeature StructuralFeature, int orderNo);
    public sealed virtual int GetCurrentOrderNo(Locator locator, IStructuralFeature StructuralFeature);
    [CompilerGeneratedAttribute]
public sealed virtual void add_ValueChanged(ValueChangedDelegate value);
    [CompilerGeneratedAttribute]
public sealed virtual void remove_ValueChanged(ValueChangedDelegate value);
    [CompilerGeneratedAttribute]
public sealed virtual void add_ExistenceChanged(LocatorEventHandler value);
    [CompilerGeneratedAttribute]
public sealed virtual void remove_ExistenceChanged(LocatorEventHandler value);
    public sealed virtual Locator GetLocatorById(ObjectId objectId);
    public sealed virtual ObjectId GetIdByLocator(Locator locator);
    public object GetFetchedValue(CacheLocator locator, IStructuralFeature structuralFeature);
    public sealed virtual object GetFetchedValueRaw(Locator locator, IStructuralFeature structuralFeature);
    public sealed virtual bool GetExtentIsCurrent(IClass c);
    public sealed virtual void InvalidateExtent(IClass umlClass);
    public sealed virtual void SetExtentCurrent(IClass umlClass);
    public bool get_AsyncHandlingEnabled();
    public sealed virtual ICollection`1<Locator> get_DeleteStack();
    public sealed virtual int GetTimestamp(Locator locator);
    public sealed virtual bool IsPersistent(Locator locator);
    public sealed virtual bool Contains(Locator locator);
    public sealed virtual void SetFetchedValue(Locator locator, IStructuralFeature structuralFeature, object value);
    public sealed virtual void SetTimestamp(Locator locator, int value);
    public sealed virtual void SetCurrentAndFetchedValue(Locator locator, IStructuralFeature structuralFeature, object value);
    public sealed virtual bool get_IsActive();
    public sealed virtual Locator[] GetAllLocators();
    [CompilerGeneratedAttribute]
public sealed virtual void add_ExtentInvalidated(ExtentChangedEventHandler value);
    [CompilerGeneratedAttribute]
public sealed virtual void remove_ExtentInvalidated(ExtentChangedEventHandler value);
    [CompilerGeneratedAttribute]
public sealed virtual void add_LocatorAdded(LocatorEventHandler value);
    [CompilerGeneratedAttribute]
public sealed virtual void remove_LocatorAdded(LocatorEventHandler value);
    [CompilerGeneratedAttribute]
public sealed virtual void add_DirtyChanged(LocatorEventHandler value);
    [CompilerGeneratedAttribute]
public sealed virtual void remove_DirtyChanged(LocatorEventHandler value);
    [CompilerGeneratedAttribute]
public sealed virtual void add_CanRelease(CanReleaseDelegate value);
    [CompilerGeneratedAttribute]
public sealed virtual void remove_CanRelease(CanReleaseDelegate value);
    [CompilerGeneratedAttribute]
public void add_OnRealtimeChangeDetected(EventHandler`1<RealtimeChangeArgs> value);
    [CompilerGeneratedAttribute]
public void remove_OnRealtimeChangeDetected(EventHandler`1<RealtimeChangeArgs> value);
    public sealed virtual bool IsDirty(Locator locator);
    public sealed virtual bool IsDefaultFetched(Locator locator);
    public ClassCachePolicy GetClassPolicy(IClass Class_);
    public MemberCachePolicy GetMemberPolicy(IStructuralFeature member);
    public sealed virtual int GetFetchedOrderNo(Locator locator, IStructuralFeature structuralFeature);
    public sealed virtual bool GetMemberHasFetchedValue(Locator locator, IStructuralFeature structuralFeature);
    public sealed virtual object GetFetchedValue(Locator locator, IStructuralFeature structuralFeature);
    public sealed virtual object GetCurrentValue(Locator locator, IStructuralFeature structuralFeature);
    public sealed virtual object GetCurrentValueRaw(Locator locator, IStructuralFeature structuralFeature);
    public sealed virtual PersistenceState GetMemberPersistenceState(Locator locator, IStructuralFeature structuralFeature);
    public static bool SharedBigValueReport(Int32& bigValueCount, Int64& bigValueSpaceUsed);
    public sealed virtual void RememberGhostFKCreatedUntilNextSave(Locator locator);
    public sealed virtual List`1<Locator> GetAllGhostFKCreatedAndClearList();
    public sealed virtual object GetAsSharedBigValue(Locator locator, IAttribute attribute, object sourcevalue);
    public sealed virtual void PruneResources(bool LowMemoryCondition);
    public sealed virtual EcoRuntimeInformation GetRuntimeInformation(IExecutionAndDebug owner, DebugSettingsStack settings, int depth);
}
public abstract class Eco.Framework.Impl.CacheLocator : Locator {
    private Object[] m_Contents;
    private ObjectId m_Id;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
private bool <IsCleanedForFree>k__BackingField;
    public Object[] Contents { get; public set; }
    public IClass UmlClass { get; }
    public ObjectId Id { get; }
    public ObjectId ObjectId { get; public set; }
    public bool IsCleanedForFree { get; private set; }
    public Object[] get_Contents();
    public void set_Contents(Object[] value);
    public abstract virtual IClass get_UmlClass();
    public virtual ObjectId get_Id();
    public ObjectId get_ObjectId();
    public void set_ObjectId(ObjectId value);
    [CompilerGeneratedAttribute]
public bool get_IsCleanedForFree();
    [CompilerGeneratedAttribute]
private void set_IsCleanedForFree(bool value);
    public abstract virtual EcoRuntimeInformation GetRuntimeInformation(IExecutionAndDebug owner, DebugSettingsStack settings, int depth);
    public abstract virtual void PruneResources(bool LowMemoryCondition);
    public virtual void CleanForFree();
    private void CleanUpContents(Object[] contents);
}
[DefaultMemberAttribute("Item")]
public abstract class Eco.Framework.Impl.CacheMultilinkAdapter : object {
    private MultiAssociationEndCachePolicy m_ListController;
    private CacheLocator m_Locator;
    protected MultiAssociationEndCachePolicy ListController { get; }
    protected CacheLocator Locator { get; }
    public bool IsReadOnly { get; }
    public bool IsFixedSize { get; }
    public object Item { get; public set; }
    public int Count { get; }
    public object SyncRoot { get; }
    public bool IsSynchronized { get; }
    public CacheMultilinkAdapter(CacheLocator locator, MultiAssociationEndCachePolicy listController);
    protected MultiAssociationEndCachePolicy get_ListController();
    protected CacheLocator get_Locator();
    public sealed virtual bool get_IsReadOnly();
    public sealed virtual bool get_IsFixedSize();
    public virtual object get_Item(int index);
    public virtual void set_Item(int index, object value);
    public abstract virtual int get_Count();
    public sealed virtual object get_SyncRoot();
    public sealed virtual bool get_IsSynchronized();
    public abstract virtual bool Contains(object value);
    public abstract virtual int IndexOf(object value);
    public sealed virtual int Add(object value);
    public sealed virtual void Clear();
    public sealed virtual void CopyTo(Array arr, int index);
    public sealed virtual IEnumerator GetEnumerator();
    public sealed virtual void Insert(int index, object value);
    public sealed virtual void Remove(object value);
    public sealed virtual void RemoveAt(int index);
}
[DefaultMemberAttribute("Item")]
public class Eco.Framework.Impl.CacheMultilinkCurrentValueAdapter : CacheMultilinkAdapter {
    public object Item { get; }
    public int Count { get; }
    public CacheMultilinkCurrentValueAdapter(CacheLocator OwningObject, MultiAssociationEndCachePolicy ListController);
    public virtual object get_Item(int index);
    public virtual int get_Count();
    public virtual bool Contains(object value);
    public virtual int IndexOf(object value);
}
public class Eco.Framework.Impl.CacheMultilinkEnumerator : object {
    private CacheMultilinkAdapter m_Adapter;
    private int m_Index;
    public object Current { get; }
    public CacheMultilinkEnumerator(CacheMultilinkAdapter adapter);
    public sealed virtual object get_Current();
    public sealed virtual bool MoveNext();
    public sealed virtual void Reset();
}
[DefaultMemberAttribute("Item")]
public class Eco.Framework.Impl.CacheMultilinkFetchedValueAdapter : CacheMultilinkAdapter {
    public object Item { get; }
    public int Count { get; }
    public CacheMultilinkFetchedValueAdapter(CacheLocator OwningObject, MultiAssociationEndCachePolicy ListController);
    public virtual object get_Item(int index);
    public virtual int get_Count();
    public virtual int IndexOf(object value);
    public virtual bool Contains(object value);
    private LocatorList GetList();
}
public class Eco.Framework.Impl.ClassCachePolicy : object {
    private static object s_BoxedMinusOne;
    public static int FlagsIndex;
    public static int MembersOffset;
    public static int ObjectPersistenceStateIndex;
    public static int ObjectExistenceStateIndex;
    public static int ObjectFlagsIndex;
    public static int FlagsOffset;
    private MemberCachePolicy[] m_Members;
    private CacheImpl m_Owner;
    private IClass m_UmlClass;
    private int m_VersionIndex;
    private int m_ContentSize;
    private int m_OldValueIndex;
    private int m_FlagsSize;
    private MemberCachePolicy[] Members { get; }
    public IClass UmlClass { get; }
    public CacheImpl Owner { get; }
    public int VersionIndex { get; }
    public int ContentSize { get; }
    public int FlagsSize { get; }
    public int OldValueIndex { get; }
    public static object BoxedMinusOne { get; }
    public ClassCachePolicy(IClass class_, CacheImpl owner);
    private static ClassCachePolicy();
    private MemberCachePolicy[] get_Members();
    public IClass get_UmlClass();
    public CacheImpl get_Owner();
    public int get_VersionIndex();
    public int get_ContentSize();
    public int get_FlagsSize();
    public int get_OldValueIndex();
    public static object get_BoxedMinusOne();
    public Object[] CreateContent(CacheLocator locator, bool isNew, bool persistentInstance);
    public Object[] CreateContent(CacheLocator locator, bool isNew, bool persistentInstance, ILoopBack loopback);
    private static void NewMethod(bool isNew, Object[] result, MemberCachePolicy m);
    public void DoSerialize(CacheLocator locator, Stream target, EcoSpaceSerializationConfig config);
    public void DoDeserialize(CacheLocator locator, Stream source, BinaryReader reader);
    public bool GetDirty(Object[] objectContents);
    public bool GetDefaultFetched(Object[] objectContents);
    private void CalculateMemberModified(Object[] objectContents);
    private void CalculateDefaultFetched(Object[] objectContents);
    public int GetVersion(Object[] objectContents);
    public void SetVersion(Object[] objectContents, int value);
    public void SetExistenceState(Object[] objectContents, CacheLocator locator, ExistenceState value);
    public void SetPersistenceState(Object[] objectContents, CacheLocator locator, PersistenceState value);
    public void ClearTouched(Object[] objectContents);
    public PersistenceState GetPersistenceState(Object[] objectContents);
    private byte GetObjectFlags(Object[] objectContents);
    public ExistenceState GetExistenceState(Object[] objectContents);
    private void InternalSetPersistenceState(Object[] objectContents, PersistenceState value);
    private void SetObjectFlags(Object[] objectContents, byte value);
    private void InternalSetExistenceState(Object[] objectContents, ExistenceState value);
    private bool GetHasModifedMemberKnown(Object[] objectContents);
    public bool GetIsDefaultFetchedKnown(Object[] objectContents);
    public void SetTouched(Object[] objectContents, bool value);
    public void SetHasModifedMember(Object[] objectContents, bool value);
    public void SetIsDefaultFetched(Object[] objectContents, bool value);
    public void SetHasModifedMemberKnown(Object[] objectContents, bool value);
    public void SetIsDefaultFetchedKnown(Object[] objectContents, bool value);
    public bool GetPersistent(Object[] objectContents);
    public bool GetTouched(Object[] objectContents);
    public bool GetHasModifedMember(Object[] objectContents);
    public bool GetIsDefaultFetched(Object[] objectContents);
    public void Pass2();
    public MemberCachePolicy GetMemberPolicy(IStructuralFeature member);
}
public class Eco.Framework.Impl.DirectMultiAssociationEndCachePolicy : MainMultiAssociationEndCachePolicy {
    protected DirectSingleAssociationEndCachePolicy m_OppositeEndPolicy;
    public DirectMultiAssociationEndCachePolicy(ClassCachePolicy Owner, IAssociationEnd AssociationEnd, int MemberContentIndex, int FlagIndex);
    protected virtual object TransformValueFromCacheToOutside(object value);
    protected virtual object TransformValueFromOutsideToCache(object value);
    public virtual int GetCount(CacheLocator owningObject);
    public sealed virtual void LinkTo_CurrentAndFetched(CacheLocator newLocator, CacheLocator owningObject);
    public sealed virtual void LinkTo_Current(CacheLocator newLocator, CacheLocator owningObject);
    public sealed virtual void Unlink_CurrentAndFetched(CacheLocator oldLocator, CacheLocator owningObject);
    public sealed virtual void Unlink_Current(CacheLocator oldLocator, CacheLocator owningObject);
    public virtual void FreeContent();
    protected virtual void Resort(CacheLocator owningObject);
    protected virtual bool IsInOrder(CacheLocator owningObject);
    protected void SetOtherEndOrderNo(int index, CacheLocator owningObject, int value);
    public virtual void Pass2();
    public virtual void SaveOldValue(Object[] objectContents);
    public virtual void ClearOldValue(Object[] objectContents);
    public sealed virtual void LinkTo_fetched(CacheLocator newLocator, CacheLocator owningObject);
    public sealed virtual void Unlink_fetched(CacheLocator oldLocator, CacheLocator owningObject);
    protected int GetOtherEndOrderNo(int index, CacheLocator owningObject);
}
public class Eco.Framework.Impl.DirectSingleAssociationEndCachePolicy : SingleAssociationEndCachePolicy {
    public DirectSingleAssociationEndCachePolicy(ClassCachePolicy owner, IAssociationEnd associationEnd, int memberContentIndex, int flagIndex);
    protected virtual object TransformValueFromCacheToOutside(object value);
    protected virtual object TransformValueFromOutsideToCache(object value);
    private void AddToOtherEnd_CurrentAndFetched(CacheLocator owningObject);
    private void AddToOtherEnd_Current(CacheLocator owningObject);
    public sealed virtual void LinkTo_CurrentAndFetched(CacheLocator newLocator, CacheLocator owningObject);
    private void RemoveFromOtherEnd_CurrentAndFetched(CacheLocator owningObject);
    private void RemoveFromOtherEnd_Current(CacheLocator owningObject);
    public void SetLocator_CurrentAndFetched(CacheLocator newLocator, CacheLocator owningObject);
    public virtual void SetLocator_Current(CacheLocator newLocator, CacheLocator owningObject);
    private void InternalSetLocator(CacheLocator newLocator, CacheLocator owningObject);
    public sealed virtual void Unlink_CurrentAndFetched(CacheLocator oldLocator, CacheLocator owningObject);
    public sealed virtual void LinkTo_Current(CacheLocator newLocator, CacheLocator owningObject);
    public sealed virtual void Unlink_Current(CacheLocator oldLocator, CacheLocator owningObject);
    public virtual void SetOrderNo_cache(int orderNo, CacheLocator owningObject);
    public virtual void SetCurrentAndFetchedValue(object value, CacheLocator owningObject);
    public virtual void SaveOldValue(Object[] objectContents);
    public virtual void ClearOldValue(Object[] objectContents);
    public ObjectId DoSerialize_ToId(object obj);
    public virtual void DoSerialize(CacheLocator locator, Stream target, EcoSpaceSerializationConfig config);
    private Locator GetLocatorFromId(ObjectId id);
    public virtual void DoDeserialize(CacheLocator locator, Stream source, BinaryReader reader);
    public sealed virtual void LinkTo_fetched(CacheLocator newLocator, CacheLocator owningObject);
    public sealed virtual void Unlink_fetched(CacheLocator oldLocator, CacheLocator owningObject);
}
public abstract class Eco.Framework.Impl.Frontside.AssociationEndFrontsidePolicy : MemberFrontsidePolicy {
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
private IAssociationEnd <OppositeEnd>k__BackingField;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
private IAssociationEnd <AssociationEnd>k__BackingField;
    private MemberFrontsidePolicy m_OppositeEndPolicy;
    public IStructuralFeature Feature { get; }
    protected IAssociationEnd OppositeEnd { get; private set; }
    public IAssociationEnd AssociationEnd { get; private set; }
    protected FetchStrategy EffectiveFetchStrategy { get; }
    public AssociationEndFrontsidePolicy(IAssociationEnd assocEnd, ClassFrontsidePolicy owner);
    public virtual IStructuralFeature get_Feature();
    [CompilerGeneratedAttribute]
protected IAssociationEnd get_OppositeEnd();
    [CompilerGeneratedAttribute]
private void set_OppositeEnd(IAssociationEnd value);
    [CompilerGeneratedAttribute]
public IAssociationEnd get_AssociationEnd();
    [CompilerGeneratedAttribute]
private void set_AssociationEnd(IAssociationEnd value);
    protected virtual FetchStrategy get_EffectiveFetchStrategy();
    public MemberFrontsidePolicy GetOppositeEndPolicy();
}
public class Eco.Framework.Impl.Frontside.AttributeFrontsidePolicy : MemberFrontsidePolicy {
    private IAttribute m_Attribute;
    public IStructuralFeature Feature { get; }
    public AttributeFrontsidePolicy(IAttribute feature, ClassFrontsidePolicy owner);
    public virtual IStructuralFeature get_Feature();
    public virtual void ApplyMemberValue(Locator locator, object value, bool callerStateMachine);
    public virtual object RetrieveMemberValue(DefaultFrontsideLocator locator);
    public virtual IProperty GetPropertyAdapter(DefaultFrontsideLocator locator);
}
public class Eco.Framework.Impl.Frontside.AttributePropertyAdapter : MemberPropertyAdapter {
    public IDataType UmlDataType { get; }
    public ContentType ContentType { get; }
    unknown object AsObject {public set; }
    public AttributePropertyAdapter(Locator locator, MemberFrontsidePolicy memberPolicy);
    public sealed virtual IDataType get_UmlDataType();
    public virtual int GetIsEqualHashCode();
    public virtual ContentType get_ContentType();
    public virtual IElementCollection GetAsCollection();
    public virtual IList`1<T> GetAsIList();
    public virtual bool IsEqual(IElement element);
    public virtual void Assign(IElement element);
    public void AsObjectConvertError(object value);
    public virtual void set_AsObject(object value);
    public virtual IElement CloneValue(bool readOnly);
}
public class Eco.Framework.Impl.Frontside.ClassFrontsidePolicy : object {
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
private DefaultFrontsidePolicy <Owner>k__BackingField;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
private IClass <UmlClass>k__BackingField;
    private MemberFrontsidePolicy[] m_Members;
    private ConstructorInfo m_FrontEndObjectConstructorInfo;
    private ConstructorInfo m_NewObjectConstructorInfo;
    private bool m_PreDeleteIntitialized;
    private MethodInfo m_PreDeleteMethod;
    private IMethod m_OnDeleteMethod;
    private bool m_OnDeleteMethodIntitialized;
    private IMethod m_OnStateChangeMethod;
    private bool m_OnStateChangeMethodIntitialized;
    private IMethod m_OnCreateMethod;
    private bool m_OnCreateMethodIntitialized;
    private IMethod m_OnUpdateMethod;
    private bool m_OnUpdateMethodIntitialized;
    private static Type[] FrontEndObjectConstructorParms;
    private static Type[] NewObjectConstructorParms;
    public DefaultFrontsidePolicy Owner { get; public set; }
    public IClass UmlClass { get; private set; }
    public ClassFrontsidePolicy(IClass umlClass, DefaultFrontsidePolicy owner);
    private static ClassFrontsidePolicy();
    [CompilerGeneratedAttribute]
public DefaultFrontsidePolicy get_Owner();
    [CompilerGeneratedAttribute]
public void set_Owner(DefaultFrontsidePolicy value);
    [CompilerGeneratedAttribute]
public IClass get_UmlClass();
    [CompilerGeneratedAttribute]
private void set_UmlClass(IClass value);
    public object CreateFrontendObject(IContent contents);
    private MemberFrontsidePolicy CreateMemberPolicy(IStructuralFeature feature);
    public Locator CreateNewLinkObject(Locator locator1, IAssociationEnd end1, Locator locator2, IAssociationEnd end2);
    public ICache GetCache();
    public MemberFrontsidePolicy GetMemberPolicy(int memberIndex);
    public MemberFrontsidePolicy GetMemberPolicyByLoopbackIndex(int loopbackIndex);
    public MethodInfo GetPreDeleteMethod();
    public IMethod GetOnDeleteMethod();
    public IMethod GetOnStateChangeMethod();
    public IMethod GetOnCreateMethod();
    public IMethod GetOnUpdateMethod();
    public IObjectInstance CreateNewObject();
    internal void CleanForFree();
}
public class Eco.Framework.Impl.Frontside.CreateFrontEndObjectDelegate : MulticastDelegate {
    public CreateFrontEndObjectDelegate(object object, IntPtr method);
    public virtual object Invoke(IClass umlClass, ConstructorInfo constructorInfo, IEcoServiceProvider sp);
    public virtual IAsyncResult BeginInvoke(IClass umlClass, ConstructorInfo constructorInfo, IEcoServiceProvider sp, AsyncCallback callback, object object);
    public virtual object EndInvoke(IAsyncResult result);
}
[DefaultMemberAttribute("Item")]
public class Eco.Framework.Impl.Frontside.DefaultFrontsideLocator : CacheLocator {
    private PublisherList m_PublisherList;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
private ClassFrontsidePolicy <ClassPolicy>k__BackingField;
    private ILoopBack m_LoopBack;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
private PropertyChangedEventHandler PropertyChanged;
    private ConstraintInstanceList _ConstraintInstances;
    public DefaultFrontsidePolicy FrontsidePolicy { get; }
    public ClassFrontsidePolicy ClassPolicy { get; private set; }
    public object AsObject { get; public set; }
    public ContentType ContentType { get; }
    public bool Deleted { get; }
    public bool IsProperty { get; }
    public IProperty Item { get; }
    public IProperty Item { get; }
    public IProperty Item { get; }
    public ILoopBack EnsuredLoopBack { get; }
    public bool Mutable { get; }
    public IPropertyCollection Properties { get; }
    public bool ReadOnly { get; }
    public IEcoServiceProvider ServiceProvider { get; }
    public IClass UmlClass { get; }
    public IClassifier UmlType { get; }
    public IUndoService UndoService { get; }
    private int Eco.ObjectRepresentation.IObjectContainer.Count { get; }
    private int Eco.ObjectRepresentation.IPropertyCollection.Count { get; }
    public bool IsDeletable { get; }
    public INonDeletableReason NonDeletableReason { get; }
    public IObjectInstance ObjectInstance { get; public set; }
    public string DefaultStringRepresentation { get; }
    public bool IsNullInstance { get; }
    public IObjectStateMachine StateMachine { get; }
    private IElement Eco.ObjectRepresentation.IElementProvider.Element { get; }
    public IList`1<IConstraintInstance> ConstraintInstances { get; }
    public DefaultFrontsideLocator(object owner, IClass umlClass);
    public DefaultFrontsidePolicy get_FrontsidePolicy();
    [CompilerGeneratedAttribute]
public ClassFrontsidePolicy get_ClassPolicy();
    [CompilerGeneratedAttribute]
private void set_ClassPolicy(ClassFrontsidePolicy value);
    public sealed virtual IObjectInstance AsIObject();
    public sealed virtual void AssertLoopbackUnassigned();
    public sealed virtual void Assign(IElement element);
    public sealed virtual void Clear();
    public sealed virtual IElement CloneValue(bool readOnly);
    public void Delete_CascadeDelete(IProperty member);
    private void DoDelete();
    public sealed virtual void Delete();
    private void OnDelete();
    private void EndDelete();
    public sealed virtual object get_AsObject();
    public sealed virtual void set_AsObject(object value);
    private object GetAsObject();
    public sealed virtual T GetValue();
    public sealed virtual void SetValue(T value);
    public sealed virtual IList`1<T> GetAsIList();
    public sealed virtual ContentType get_ContentType();
    public sealed virtual bool get_Deleted();
    public sealed virtual void EnsureFetched();
    public sealed virtual bool get_IsProperty();
    public sealed virtual IProperty get_Item(IStructuralFeature feature);
    public sealed virtual IProperty get_Item(int index);
    public sealed virtual IProperty GetByLoopbackIndex(int loopbackIndex);
    public sealed virtual IProperty get_Item(string name);
    private IProperty GetItem(MemberFrontsidePolicy memberPolicy);
    public ILoopBack get_EnsuredLoopBack();
    public sealed virtual object get_MemberByIndex(int index);
    public sealed virtual bool get_Mutable();
    public sealed virtual IPropertyCollection get_Properties();
    public sealed virtual bool get_ReadOnly();
    public sealed virtual IEcoServiceProvider get_ServiceProvider();
    public virtual IClass get_UmlClass();
    public sealed virtual IClassifier get_UmlType();
    public sealed virtual IUndoService get_UndoService();
    public sealed virtual IElementCollection GetAsCollection();
    public sealed virtual int GetIsEqualHashCode();
    private void AutoSubscribe();
    public bool InternalCanDelete_CheckEmpty(IProperty member);
    public NonDeletableReason InternalCanDelete_CascadeCanDelete(Dictionary`2<DefaultFrontsideLocator, DefaultFrontsideLocator> checkedObjects, bool cascade, IProperty member, bool deleteIsInProgress);
    private NonDeletableReason InternalCanDelete(Dictionary`2<DefaultFrontsideLocator, DefaultFrontsideLocator> checkedObjects, bool cascade, bool deleteIsInProgress);
    public List`1<int> MembersWithAtLeastOneSubscriptionAndNonDefaultFetchedFetched();
    private sealed virtual override int Eco.ObjectRepresentation.IObjectContainer.get_Count();
    private sealed virtual override int Eco.ObjectRepresentation.IPropertyCollection.get_Count();
    public sealed virtual bool IsEqual(IElement element);
    private void PreDelete();
    public virtual void CleanForFree();
    public sealed virtual void set_MemberByIndex(int index, object value);
    public sealed virtual object get_MemberByIndex_OfflineAware(int index, Type expectedType);
    public sealed virtual void set_MemberByIndex_OfflineAware(int index, object value, string memberName);
    private Publisher EnsuredPublisherForIndex(int index);
    private Publisher PublisherForIndex(int index);
    private bool SendEvent(int index, object sender, EventArgs args);
    public sealed virtual void SubscribeToPropertyChanged(ISubscriber subscriber);
    public void UnsubscribeFromPropertyChanged(ISubscriber subscriber);
    public sealed virtual void SubscribeToValue(ISubscriber subscriber);
    public sealed virtual void UnsubscribeFromValue(ISubscriber subscriber);
    private sealed virtual override void Eco.ObjectRepresentation.IElement.add_ValueChanged(EventHandler value);
    private sealed virtual override void Eco.ObjectRepresentation.IElement.remove_ValueChanged(EventHandler value);
    public void ExistenceChanged();
    public void MemberChanged(IStructuralFeature feature);
    public void OnPropertyChanged(string name);
    public void SubscribeToMember(IStructuralFeature member, ISubscriber subscriber);
    public void UnsubscribeFromMember(IStructuralFeature member, ISubscriber subscriber);
    public void AddValueChanged(IStructuralFeature member, EventHandler handler);
    public void RemoveValueChanged(IStructuralFeature member, EventHandler handler);
    public sealed virtual bool get_IsDeletable();
    public sealed virtual INonDeletableReason get_NonDeletableReason();
    public sealed virtual IObjectInstance get_ObjectInstance();
    public void set_ObjectInstance(IObjectInstance value);
    public sealed virtual string get_DefaultStringRepresentation();
    public sealed virtual bool get_IsNullInstance();
    public sealed virtual IObjectStateMachine get_StateMachine();
    public sealed virtual object Invoke(string methodName, Object[] parameters);
    private static IMethod FindCorrectOverride(IClass cls, IMethod method);
    private static IElement ExecuteExternalLateBound(IClassifier classifier, IObject theobject, IMethod method, IModifiableVariableList variableList);
    private static bool CheckMethodForExternalLateboundInfo(IMethod method);
    public static object GenericInvoke(IObject root, bool isquery, IVariableFactoryService variableFactory, IActionLanguageService actionService, IOclService oclService, IMethod method, IElement[] parameters, bool disregardOverride, ISubscriber reevaluateSubscriber, ISubscriber resubscribeSubscriber);
    private static object GenericInvokeCodegen(object methodOwner, IMethod method, Object[] parameters);
    public sealed virtual object Invoke(IMethod method, Object[] parameters);
    public sealed virtual object Invoke(IMethod method, IElement[] parameters, bool disregardOverride);
    public sealed virtual object InvokeQuery(IMethod method, IElement[] parameters, ISubscriber reevaluateSubscriber, ISubscriber resubscribeSubscriber, bool disregardOverride);
    private sealed virtual override void Eco.FrameworkImpl.Frontside.IStateMachineAccess.SetState(IState state);
    private void CheckActiveRegion(IRegion r, Dictionary`2<IAttribute, IAttribute> usedAttributes);
    public sealed virtual void LoopbackValid();
    public sealed virtual IObjectInstance GetOwner();
    public void set_LoopBack(ILoopBack value);
    public sealed virtual IObjectList GetAsList();
    private sealed virtual override IElement Eco.ObjectRepresentation.IElementProvider.get_Element();
    [CompilerGeneratedAttribute]
public sealed virtual void add_PropertyChanged(PropertyChangedEventHandler value);
    [CompilerGeneratedAttribute]
public sealed virtual void remove_PropertyChanged(PropertyChangedEventHandler value);
    private sealed virtual override IObjectInstance Eco.ObjectRepresentation.IEcoObject.AsIObject();
    public virtual EcoRuntimeInformation GetRuntimeInformation(IExecutionAndDebug owner, DebugSettingsStack settings, int depth);
    public virtual void PruneResources(bool LowMemoryCondition);
    internal bool HasSubscribers(int index);
    public sealed virtual IProperty TryGetName(string name);
    public sealed virtual IList`1<IConstraintInstance> get_ConstraintInstances();
}
public class Eco.Framework.Impl.Frontside.DefaultFrontsideLocatorValueTransporter : DefaultFrontsideLocator {
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
private string <Value>k__BackingField;
    public string Value { get; }
    public DefaultFrontsideLocatorValueTransporter(string value);
    [CompilerGeneratedAttribute]
public string get_Value();
}
public class Eco.Framework.Impl.Frontside.DefaultFrontsidePolicy : EcoSpacePart {
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
private ICache <Cache>k__BackingField;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
private IDerivedMemberManager <DerivedMemberManager>k__BackingField;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
private IUndoService <UndoService>k__BackingField;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
private IEcoServiceProvider <ServiceProvider>k__BackingField;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
private IEcoTypeSystem <TypeSystem>k__BackingField;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
private IVariableFactoryService <VariableFactory>k__BackingField;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
private IAutoSubscriptionService <AutoSubscriptionService>k__BackingField;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
private IPersistenceHandler <PersistenceHandler>k__BackingField;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
private bool <EnforceStringLength>k__BackingField;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
private FetchStrategy <FetchStrategy>k__BackingField;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
private RecreateFrontEndObjectDelegate RecreateFrontEndObject;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
private CreateFrontEndObjectDelegate CreateFrontEndObject;
    private ClassFrontsidePolicy[] fClasses;
    private IOclService m_OclService;
    private IActionLanguageService m_ActionLanguageService;
    public static int C_ExistenceQualifier;
    public static int C_PropertyValueChangeQualifier;
    private int _FetchFactFinderMode;
    private int _UnsafeCountCursor;
    private List`1<string> _operationskipmemory;
    private HashSet`1<IAbstractDeriver> _DeferedDeriversUntilAfterQueryPlan;
    private HashSet`1<IAbstractDeriver> _DeferedDeriversUntilAfterNextLap;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
private EventHandler`1<OnFetchFactFinderCallbackArgs> OnFetchFactFinderCallback;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
private IAsyncSupportService <AsyncSupportService>k__BackingField;
    public IOclService OclService { get; }
    public IActionLanguageService ActionLanguageService { get; }
    public ICache Cache { get; public set; }
    public IDerivedMemberManager DerivedMemberManager { get; private set; }
    public IUndoService UndoService { get; public set; }
    public IEcoServiceProvider ServiceProvider { get; public set; }
    public IEcoTypeSystem TypeSystem { get; public set; }
    public IVariableFactoryService VariableFactory { get; public set; }
    public IAutoSubscriptionService AutoSubscriptionService { get; public set; }
    public IPersistenceHandler PersistenceHandler { get; public set; }
    public bool EnforceStringLength { get; public set; }
    public FetchStrategy FetchStrategy { get; public set; }
    public IObjectRepresentationProvider ObjectRepresentationProvider { get; }
    public IObjectFactoryService ObjectFactoryService { get; }
    public object LocatorOwner { get; }
    public IAsyncSupportService AsyncSupportService { get; public set; }
    public IOclService get_OclService();
    public IActionLanguageService get_ActionLanguageService();
    [CompilerGeneratedAttribute]
public ICache get_Cache();
    [CompilerGeneratedAttribute]
public void set_Cache(ICache value);
    [CompilerGeneratedAttribute]
public IDerivedMemberManager get_DerivedMemberManager();
    [CompilerGeneratedAttribute]
private void set_DerivedMemberManager(IDerivedMemberManager value);
    [CompilerGeneratedAttribute]
public IUndoService get_UndoService();
    [CompilerGeneratedAttribute]
public void set_UndoService(IUndoService value);
    [CompilerGeneratedAttribute]
public IEcoServiceProvider get_ServiceProvider();
    [CompilerGeneratedAttribute]
public void set_ServiceProvider(IEcoServiceProvider value);
    [CompilerGeneratedAttribute]
public IEcoTypeSystem get_TypeSystem();
    [CompilerGeneratedAttribute]
public void set_TypeSystem(IEcoTypeSystem value);
    [CompilerGeneratedAttribute]
public IVariableFactoryService get_VariableFactory();
    [CompilerGeneratedAttribute]
public void set_VariableFactory(IVariableFactoryService value);
    [CompilerGeneratedAttribute]
public IAutoSubscriptionService get_AutoSubscriptionService();
    [CompilerGeneratedAttribute]
public void set_AutoSubscriptionService(IAutoSubscriptionService value);
    [CompilerGeneratedAttribute]
public IPersistenceHandler get_PersistenceHandler();
    [CompilerGeneratedAttribute]
public void set_PersistenceHandler(IPersistenceHandler value);
    [CompilerGeneratedAttribute]
public bool get_EnforceStringLength();
    [CompilerGeneratedAttribute]
public void set_EnforceStringLength(bool value);
    [CompilerGeneratedAttribute]
public FetchStrategy get_FetchStrategy();
    [CompilerGeneratedAttribute]
public void set_FetchStrategy(FetchStrategy value);
    public IObjectRepresentationProvider get_ObjectRepresentationProvider();
    public IObjectFactoryService get_ObjectFactoryService();
    public object get_LocatorOwner();
    [CompilerGeneratedAttribute]
public void add_RecreateFrontEndObject(RecreateFrontEndObjectDelegate value);
    [CompilerGeneratedAttribute]
public void remove_RecreateFrontEndObject(RecreateFrontEndObjectDelegate value);
    [CompilerGeneratedAttribute]
public void add_CreateFrontEndObject(CreateFrontEndObjectDelegate value);
    [CompilerGeneratedAttribute]
public void remove_CreateFrontEndObject(CreateFrontEndObjectDelegate value);
    internal object DoRecreateFrontEndObject(IClass umlClass, ConstructorInfo constructorInfo, IContent content);
    internal object DoCreateFrontEndObject(IClass umlClass, ConstructorInfo constructorInfo, IEcoServiceProvider sp);
    private void CacheExistenceChanged(object sender, LocatorEventArgs args);
    private void CacheValueChanged(Locator locator, IStructuralFeature feature);
    public sealed virtual IContent CreateContent(ILoopBack dotNetObject);
    public sealed virtual void CreateContentFailed(IContent obj, object dotNetObject);
    public sealed virtual IObjectInstance CreateNewObject(IClass c);
    public sealed virtual IObjectInstance CreateNewObject(Type t);
    public sealed virtual IObjectInstance CreateNewObject(string className);
    public sealed virtual IObjectInstance CreateNewLinkObject(IEcoObject end1, IEcoObject end2);
    public sealed virtual IObjectInstance CreateNewLinkObject(IEcoObject end1, IEcoObject end2, IAssociation assoc);
    public sealed virtual object CreateNewLinkObject(IEcoObject end1, IEcoObject end2, Type assocClass);
    public sealed virtual void DeleteObjects(IEnumerable`1<IEcoObject> list);
    private void DerivedMemberValueChanged(IProperty prop, EventArgs args);
    public ClassFrontsidePolicy GetClassPolicy(IClass class_);
    public sealed virtual IObjectInstance IObjectForLocator(Locator locator);
    public sealed virtual Locator LocatorForIObject(IObjectInstance obj);
    public sealed virtual IObjectList LocatorCollectionToIObjectList(IEnumerable`1<Locator> locators, IClass umlClass);
    public sealed virtual IList`1<Locator> IObjectListToLocatorList(IEnumerable`1<T> objectList);
    protected virtual void DoActivate();
    protected virtual void DoDeactivate();
    public sealed virtual void EnterFetchFactFinderMode();
    public sealed virtual void LeaveFetchFactFinderMode();
    public sealed virtual bool IsFetchFactFinderMode();
    public sealed virtual bool FetchFactFinderRunFactsFeedback(ObjectIdList idList, Int32[] memberindices);
    public sealed virtual int UnsafeCountCursor();
    public sealed virtual bool IsFetchFactFinderButSafeToDoEval(IObjectInstance objectInstance, IStructuralFeature member);
    public sealed virtual void IsPartOfUnsafeEval(IObjectInstance io, IStructuralFeature member);
    public sealed virtual void OperationSkippingReportBack(string operationname);
    public sealed virtual List`1<string> OperationSkippingPeek();
    public sealed virtual void OperationSkippingReset();
    public sealed virtual void DeferInvalidation(IAbstractDeriver deriver, bool deferToNextLapNotAfterAll);
    public sealed virtual void InvalidateDeferedInvalidationsNow(bool nextlaponly);
    [CompilerGeneratedAttribute]
public sealed virtual void add_OnFetchFactFinderCallback(EventHandler`1<OnFetchFactFinderCallbackArgs> value);
    [CompilerGeneratedAttribute]
public sealed virtual void remove_OnFetchFactFinderCallback(EventHandler`1<OnFetchFactFinderCallbackArgs> value);
    [CompilerGeneratedAttribute]
public IAsyncSupportService get_AsyncSupportService();
    [CompilerGeneratedAttribute]
public void set_AsyncSupportService(IAsyncSupportService value);
    public virtual void CleanForFree();
}
public class Eco.Framework.Impl.Frontside.DefaultLoopback : object {
    private IContent m_Content;
    public DefaultLoopback(IContent content);
    public sealed virtual IObject AsIObject();
    public sealed virtual object get_MemberByIndex(int index);
    public sealed virtual void set_MemberByIndex(int index, object value);
    private sealed virtual override void System.ComponentModel.INotifyPropertyChanged.add_PropertyChanged(PropertyChangedEventHandler value);
    private sealed virtual override void System.ComponentModel.INotifyPropertyChanged.remove_PropertyChanged(PropertyChangedEventHandler value);
    private sealed virtual override AttributeCollection System.ComponentModel.ICustomTypeDescriptor.GetAttributes();
    private sealed virtual override string System.ComponentModel.ICustomTypeDescriptor.GetClassName();
    private sealed virtual override string System.ComponentModel.ICustomTypeDescriptor.GetComponentName();
    private sealed virtual override TypeConverter System.ComponentModel.ICustomTypeDescriptor.GetConverter();
    private sealed virtual override EventDescriptor System.ComponentModel.ICustomTypeDescriptor.GetDefaultEvent();
    private sealed virtual override PropertyDescriptor System.ComponentModel.ICustomTypeDescriptor.GetDefaultProperty();
    private sealed virtual override object System.ComponentModel.ICustomTypeDescriptor.GetEditor(Type editorBaseType);
    private sealed virtual override EventDescriptorCollection System.ComponentModel.ICustomTypeDescriptor.GetEvents(Attribute[] attributes);
    private sealed virtual override EventDescriptorCollection System.ComponentModel.ICustomTypeDescriptor.GetEvents();
    private sealed virtual override PropertyDescriptorCollection System.ComponentModel.ICustomTypeDescriptor.GetProperties(Attribute[] attributes);
    private sealed virtual override PropertyDescriptorCollection System.ComponentModel.ICustomTypeDescriptor.GetProperties();
    private sealed virtual override object System.ComponentModel.ICustomTypeDescriptor.GetPropertyOwner(PropertyDescriptor pd);
    private sealed virtual override IObjectInstance Eco.ObjectRepresentation.IEcoObject.AsIObject();
}
public class Eco.Framework.Impl.Frontside.DerivedAttributeFrontsidePolicy : DerivedMemberFrontsidePolicy {
    public DerivedAttributeFrontsidePolicy(IAttribute feature, ClassFrontsidePolicy owner);
    public virtual IProperty GetPropertyAdapter(DefaultFrontsideLocator locator);
}
public abstract class Eco.Framework.Impl.Frontside.DerivedMemberFrontsidePolicy : MemberFrontsidePolicy {
    private IDerivedMemberManager m_DerivedMemberManager;
    private IStructuralFeature m_StructuralFeature;
    public IStructuralFeature Feature { get; }
    public DerivedMemberFrontsidePolicy(IStructuralFeature feature, ClassFrontsidePolicy owner);
    public virtual void ApplyMemberValue(Locator locator, object value, bool CallerStateMachine);
    public virtual IStructuralFeature get_Feature();
    public object GetDerivedValue(Locator locator);
    public virtual object RetrieveMemberValue(DefaultFrontsideLocator locator);
}
public class Eco.Framework.Impl.Frontside.DerivedMultilinkFrontsidePolicy : DerivedMemberFrontsidePolicy {
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
private IAssociationEnd <AssociationEnd>k__BackingField;
    private IFrontsideDerivedAdapterFactory m_Factory;
    public IAssociationEnd AssociationEnd { get; private set; }
    public DerivedMultilinkFrontsidePolicy(IAssociationEnd assocEnd, ClassFrontsidePolicy owner);
    [CompilerGeneratedAttribute]
public IAssociationEnd get_AssociationEnd();
    [CompilerGeneratedAttribute]
private void set_AssociationEnd(IAssociationEnd value);
    public IFrontsideDerivedAdapterFactory GetFactory();
    public virtual IProperty GetPropertyAdapter(DefaultFrontsideLocator locator);
    public virtual object RetrieveMemberValue(DefaultFrontsideLocator locator);
}
public class Eco.Framework.Impl.Frontside.DerivedSingleLinkFrontsidePolicy : DerivedMemberFrontsidePolicy {
    public DerivedSingleLinkFrontsidePolicy(IAssociationEnd feature, ClassFrontsidePolicy owner);
    public virtual IProperty GetPropertyAdapter(DefaultFrontsideLocator locator);
}
public class Eco.Framework.Impl.Frontside.DirectMultiFrontsidePolicy : MultAssociationEndFrontsidePolicy {
    public DirectMultiFrontsidePolicy(IAssociationEnd assocEnd, ClassFrontsidePolicy owner);
    public virtual int Add(Locator locator, object value);
    public virtual void Clear(Locator locator);
    public virtual void Insert(Locator locator, int index, object value);
    public virtual void Remove(Locator locator, object value);
    public virtual void RemoveAt(Locator locator, int index);
    public virtual void SetItem(Locator locator, int index, object value);
}
public class Eco.Framework.Impl.Frontside.DirectSingleMultiFrontsidePolicy : SingleAssociationEndFrontsidePolicy {
    public DirectSingleMultiFrontsidePolicy(IAssociationEnd assocEnd, ClassFrontsidePolicy owner);
    public virtual void ApplyMemberValue(Locator locator, object value, bool CallerStateMachine);
}
public class Eco.Framework.Impl.Frontside.DirectSingleSingleEmbeddedFrontsidePolicy : SingleAssociationEndFrontsidePolicy {
    public DirectSingleSingleEmbeddedFrontsidePolicy(IAssociationEnd assocEnd, ClassFrontsidePolicy owner);
    public virtual void ApplyMemberValue(Locator locator, object value, bool CallerStateMachine);
}
public class Eco.Framework.Impl.Frontside.DirectSingleSingleNonembeddedFrontsidePolicy : SingleAssociationEndFrontsidePolicy {
    public DirectSingleSingleNonembeddedFrontsidePolicy(IAssociationEnd assocEnd, ClassFrontsidePolicy owner);
    public virtual void ApplyMemberValue(Locator locator, object value, bool CallerStateMachine);
}
public class Eco.Framework.Impl.Frontside.FrontSideAdapterFactory`1 : object {
    public sealed virtual object Make(DefaultFrontsideLocator locator, MultAssociationEndFrontsidePolicy policy);
}
public class Eco.Framework.Impl.Frontside.FrontSideDerivedAdapterFactory`1 : object {
    public sealed virtual object Make(DefaultFrontsideLocator locator, DerivedMemberFrontsidePolicy policy);
}
[DefaultMemberAttribute("Item")]
public class Eco.Framework.Impl.Frontside.FrontsideDerivedMultilinkAdapter`1 : object {
    private DefaultFrontsideLocator m_Locator;
    private DerivedMemberFrontsidePolicy m_Policy;
    private ListChangedEventHandler m_ListChanged;
    private NotifyCollectionChangedEventHandler _collectionChanged;
    public T Item { get; public set; }
    public bool IsReadOnly { get; }
    public bool IsFixedSize { get; }
    public int Count { get; }
    public object SyncRoot { get; }
    public bool IsSynchronized { get; }
    public IObjectList AsIObjectList { get; }
    private object System.Collections.IList.Item { get; private set; }
    private bool System.ComponentModel.IBindingList.AllowEdit { get; }
    public bool AllowNew { get; }
    private bool System.ComponentModel.IBindingList.AllowRemove { get; }
    private bool System.ComponentModel.IBindingList.IsSorted { get; }
    private ListSortDirection System.ComponentModel.IBindingList.SortDirection { get; }
    private PropertyDescriptor System.ComponentModel.IBindingList.SortProperty { get; }
    private bool System.ComponentModel.IBindingList.SupportsChangeNotification { get; }
    private bool System.ComponentModel.IBindingList.SupportsSearching { get; }
    private bool System.ComponentModel.IBindingList.SupportsSorting { get; }
    public IEcoServiceProvider ServiceProvider { get; }
    public FrontsideDerivedMultilinkAdapter`1(DefaultFrontsideLocator locator, DerivedMemberFrontsidePolicy policy);
    public sealed virtual T get_Item(int index);
    public sealed virtual void set_Item(int index, T value);
    private IList GetList();
    public sealed virtual bool get_IsReadOnly();
    public sealed virtual bool get_IsFixedSize();
    public sealed virtual int get_Count();
    public sealed virtual object get_SyncRoot();
    public sealed virtual bool get_IsSynchronized();
    public sealed virtual IObjectList get_AsIObjectList();
    public sealed virtual int Add(object value);
    public sealed virtual void Add(T value);
    public sealed virtual void Clear();
    public sealed virtual bool Contains(object value);
    private bool InternalContains(object value);
    public sealed virtual void CopyTo(T[] arr, int index);
    public sealed virtual void CopyTo(Array arr, int index);
    private sealed virtual override object System.Collections.IList.get_Item(int index);
    private sealed virtual override void System.Collections.IList.set_Item(int index, object value);
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    public sealed virtual IEnumerator`1<T> GetEnumerator();
    public sealed virtual int IndexOf(object value);
    public sealed virtual int IndexOf(T value);
    public sealed virtual void Insert(int index, T value);
    public sealed virtual void Insert(int index, object value);
    private int InternalIndexOf(object value);
    public sealed virtual void Remove(object value);
    public sealed virtual bool Remove(T value);
    public sealed virtual void RemoveAt(int index);
    public sealed virtual bool Contains(T value);
    private sealed virtual override void System.ComponentModel.IBindingList.AddIndex(PropertyDescriptor property);
    private sealed virtual override object System.ComponentModel.IBindingList.AddNew();
    private sealed virtual override bool System.ComponentModel.IBindingList.get_AllowEdit();
    public sealed virtual bool get_AllowNew();
    private sealed virtual override bool System.ComponentModel.IBindingList.get_AllowRemove();
    private sealed virtual override void System.ComponentModel.IBindingList.ApplySort(PropertyDescriptor property, ListSortDirection direction);
    private sealed virtual override int System.ComponentModel.IBindingList.Find(PropertyDescriptor property, object key);
    private sealed virtual override bool System.ComponentModel.IBindingList.get_IsSorted();
    private void OnValueChanged(object sender, EventArgs e);
    private sealed virtual override void System.ComponentModel.IBindingList.add_ListChanged(ListChangedEventHandler value);
    private sealed virtual override void System.ComponentModel.IBindingList.remove_ListChanged(ListChangedEventHandler value);
    private sealed virtual override void System.ComponentModel.IBindingList.RemoveIndex(PropertyDescriptor property);
    private sealed virtual override void System.ComponentModel.IBindingList.RemoveSort();
    private sealed virtual override ListSortDirection System.ComponentModel.IBindingList.get_SortDirection();
    private sealed virtual override PropertyDescriptor System.ComponentModel.IBindingList.get_SortProperty();
    private sealed virtual override bool System.ComponentModel.IBindingList.get_SupportsChangeNotification();
    private sealed virtual override bool System.ComponentModel.IBindingList.get_SupportsSearching();
    private sealed virtual override bool System.ComponentModel.IBindingList.get_SupportsSorting();
    public sealed virtual IEcoServiceProvider get_ServiceProvider();
    private void OnValueChanged_INotifyCollectionChanged(object sender, EventArgs e);
    public sealed virtual void add_CollectionChanged(NotifyCollectionChangedEventHandler value);
    public sealed virtual void remove_CollectionChanged(NotifyCollectionChangedEventHandler value);
    private void HandleINotifyCollectionChanged(object o, NotifyCollectionChangedAction action, int newpos, int oldpos);
}
[DefaultMemberAttribute("Item")]
public class Eco.Framework.Impl.Frontside.FrontsideMultilinkAdapter`1 : object {
    private DefaultFrontsideLocator m_Locator;
    private MultAssociationEndFrontsidePolicy m_Policy;
    private ListChangedEventHandler m_ListChanged;
    private NotifyCollectionChangedEventHandler _collectionChanged;
    public IObjectList AsIObjectList { get; }
    private List`1<T> _DebugContents { get; }
    public T Item { get; public set; }
    public bool IsReadOnly { get; }
    public bool IsFixedSize { get; }
    public int Count { get; }
    public object SyncRoot { get; }
    public bool IsSynchronized { get; }
    private object System.Collections.IList.Item { get; private set; }
    private bool System.ComponentModel.IBindingList.AllowEdit { get; }
    public bool AllowNew { get; }
    private bool System.ComponentModel.IBindingList.AllowRemove { get; }
    private bool System.ComponentModel.IBindingList.IsSorted { get; }
    private ListSortDirection System.ComponentModel.IBindingList.SortDirection { get; }
    private PropertyDescriptor System.ComponentModel.IBindingList.SortProperty { get; }
    private bool System.ComponentModel.IBindingList.SupportsChangeNotification { get; }
    private bool System.ComponentModel.IBindingList.SupportsSearching { get; }
    private bool System.ComponentModel.IBindingList.SupportsSorting { get; }
    public IEcoServiceProvider ServiceProvider { get; }
    public FrontsideMultilinkAdapter`1(DefaultFrontsideLocator locator, MultAssociationEndFrontsidePolicy policy);
    public sealed virtual IObjectList get_AsIObjectList();
    private List`1<T> get__DebugContents();
    public sealed virtual T get_Item(int index);
    public sealed virtual void set_Item(int index, T value);
    public sealed virtual bool get_IsReadOnly();
    public sealed virtual bool get_IsFixedSize();
    public sealed virtual int get_Count();
    public sealed virtual object get_SyncRoot();
    public sealed virtual bool get_IsSynchronized();
    public sealed virtual void Add(T value);
    public sealed virtual int Add(object value);
    public sealed virtual void Clear();
    public sealed virtual bool Contains(object value);
    public sealed virtual bool Contains(T value);
    public sealed virtual void CopyTo(T[] arr, int index);
    public sealed virtual void CopyTo(Array arr, int index);
    public sealed virtual IEnumerator`1<T> GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    private sealed virtual override object System.Collections.IList.get_Item(int index);
    private sealed virtual override void System.Collections.IList.set_Item(int index, object value);
    private T GetItemFromPolicyEnsureFetchedPage(int index);
    public sealed virtual int IndexOf(T value);
    public sealed virtual int IndexOf(object value);
    public sealed virtual void Insert(int index, T value);
    public sealed virtual void Insert(int index, object value);
    public sealed virtual void Remove(object value);
    public sealed virtual bool Remove(T value);
    public sealed virtual void RemoveAt(int index);
    private sealed virtual override void System.ComponentModel.IBindingList.AddIndex(PropertyDescriptor property);
    private sealed virtual override object System.ComponentModel.IBindingList.AddNew();
    private sealed virtual override bool System.ComponentModel.IBindingList.get_AllowEdit();
    public sealed virtual bool get_AllowNew();
    private sealed virtual override bool System.ComponentModel.IBindingList.get_AllowRemove();
    private sealed virtual override void System.ComponentModel.IBindingList.ApplySort(PropertyDescriptor property, ListSortDirection direction);
    private sealed virtual override int System.ComponentModel.IBindingList.Find(PropertyDescriptor property, object key);
    private sealed virtual override bool System.ComponentModel.IBindingList.get_IsSorted();
    private void OnValueChanged(object sender, EventArgs e);
    private sealed virtual override void System.ComponentModel.IBindingList.add_ListChanged(ListChangedEventHandler value);
    private sealed virtual override void System.ComponentModel.IBindingList.remove_ListChanged(ListChangedEventHandler value);
    private sealed virtual override void System.ComponentModel.IBindingList.RemoveIndex(PropertyDescriptor property);
    private sealed virtual override void System.ComponentModel.IBindingList.RemoveSort();
    private sealed virtual override ListSortDirection System.ComponentModel.IBindingList.get_SortDirection();
    private sealed virtual override PropertyDescriptor System.ComponentModel.IBindingList.get_SortProperty();
    private sealed virtual override bool System.ComponentModel.IBindingList.get_SupportsChangeNotification();
    private sealed virtual override bool System.ComponentModel.IBindingList.get_SupportsSearching();
    private sealed virtual override bool System.ComponentModel.IBindingList.get_SupportsSorting();
    public sealed virtual IEcoServiceProvider get_ServiceProvider();
    private void OnValueChanged_INotifyCollectionChanged(object sender, EventArgs e);
    public sealed virtual void add_CollectionChanged(NotifyCollectionChangedEventHandler value);
    public sealed virtual void remove_CollectionChanged(NotifyCollectionChangedEventHandler value);
    private void HandleINotifyCollectionChanged(object o, NotifyCollectionChangedAction action, int newpos, int oldpos);
}
public class Eco.Framework.Impl.Frontside.FrontsideUtils : object {
    public static DefaultFrontsideLocator GetLocatorFromFrontendObject(object obj);
    public static void EnsureLocatorsCanBeLinked(Locator locator1, Locator locator2, ICache cache);
}
public interface Eco.Framework.Impl.Frontside.IFrontsideAdapterFactory {
    public abstract virtual object Make(DefaultFrontsideLocator locator, MultAssociationEndFrontsidePolicy policy);
}
public interface Eco.Framework.Impl.Frontside.IFrontsideDerivedAdapterFactory {
    public abstract virtual object Make(DefaultFrontsideLocator locator, DerivedMemberFrontsidePolicy policy);
}
public abstract class Eco.Framework.Impl.Frontside.IndirectMultiFrontsidePolicy : MultAssociationEndFrontsidePolicy {
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
private IAssociationEnd <EndPointingToAssociationClass>k__BackingField;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
private IAssociationEnd <AssociationClassEndPointingHere>k__BackingField;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
private IAssociationEnd <AssociationClassEndPointingAway>k__BackingField;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
private IClass <AssociationClass>k__BackingField;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
private IAssociationEnd <EndPointingHere>k__BackingField;
    protected IAssociationEnd EndPointingToAssociationClass { get; private set; }
    protected IAssociationEnd AssociationClassEndPointingHere { get; private set; }
    protected IAssociationEnd AssociationClassEndPointingAway { get; private set; }
    protected IClass AssociationClass { get; private set; }
    protected IAssociationEnd EndPointingHere { get; private set; }
    public IndirectMultiFrontsidePolicy(IAssociationEnd assocEnd, ClassFrontsidePolicy owner);
    [CompilerGeneratedAttribute]
protected IAssociationEnd get_EndPointingToAssociationClass();
    [CompilerGeneratedAttribute]
private void set_EndPointingToAssociationClass(IAssociationEnd value);
    [CompilerGeneratedAttribute]
protected IAssociationEnd get_AssociationClassEndPointingHere();
    [CompilerGeneratedAttribute]
private void set_AssociationClassEndPointingHere(IAssociationEnd value);
    [CompilerGeneratedAttribute]
protected IAssociationEnd get_AssociationClassEndPointingAway();
    [CompilerGeneratedAttribute]
private void set_AssociationClassEndPointingAway(IAssociationEnd value);
    [CompilerGeneratedAttribute]
protected IClass get_AssociationClass();
    [CompilerGeneratedAttribute]
private void set_AssociationClass(IClass value);
    [CompilerGeneratedAttribute]
protected IAssociationEnd get_EndPointingHere();
    [CompilerGeneratedAttribute]
private void set_EndPointingHere(IAssociationEnd value);
    public virtual int Add(Locator locator, object value);
    public virtual void Clear(Locator locator);
    protected ClassFrontsidePolicy GetAssociationClassPolicy();
    protected MemberFrontsidePolicy GetEndPointingHerePolicy();
    public virtual void Insert(Locator locator, int index, object value);
    public virtual void Remove(Locator locator, object value);
    public virtual void RemoveAt(Locator locator, int index);
    public virtual void SetItem(Locator locator, int index, object value);
}
public class Eco.Framework.Impl.Frontside.IndirectMultiSingleFrontsidePolicy : IndirectMultiFrontsidePolicy {
    public IndirectMultiSingleFrontsidePolicy(IAssociationEnd assocEnd, ClassFrontsidePolicy owner);
}
public class Eco.Framework.Impl.Frontside.IndirectSingleFrontsidePolicy : SingleAssociationEndFrontsidePolicy {
    private IAssociationEnd m_EndPointingToAssociationClass;
    private IAssociationEnd m_AssociationClassEndPointingHere;
    private IAssociationEnd m_AssociationClassEndPointingAway;
    private ClassFrontsidePolicy m_AssociationClassPolicy;
    public IndirectSingleFrontsidePolicy(IAssociationEnd assocEnd, ClassFrontsidePolicy owner);
    public virtual void ApplyMemberValue(Locator locator, object value, bool CallerStateMachine);
    private ClassFrontsidePolicy GetAssociationClassPolicy();
}
public class Eco.Framework.Impl.Frontside.InnerLinkFrontsidePolicy : SingleAssociationEndFrontsidePolicy {
    private bool _elevatedPriv;
    public InnerLinkFrontsidePolicy(IAssociationEnd assocEnd, ClassFrontsidePolicy owner);
    public virtual void ApplyMemberValue(Locator locator, object value, bool callerStateMachine);
    public virtual bool GetIsReadOnly(Locator locator);
    public void ElevatedPriviliges();
    public void StandardPriviliges();
}
public class Eco.Framework.Impl.Frontside.LocatorFactory : object {
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
private object <LocatorOwner>k__BackingField;
    public object LocatorOwner { get; public set; }
    [CompilerGeneratedAttribute]
public object get_LocatorOwner();
    [CompilerGeneratedAttribute]
public void set_LocatorOwner(object value);
    public CacheLocator CreateLocator(IClass umlClass);
    public CacheLocator CreateLocator(IClass umlClass, ILoopBack loopback);
}
public abstract class Eco.Framework.Impl.Frontside.MemberFrontsidePolicy : object {
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
private IStructuralFeature <FeatureWithPersistenceState>k__BackingField;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
private bool <CanBeEnsured>k__BackingField;
    private ClassFrontsidePolicy m_Owner;
    private int m_LoopbackIndex;
    private bool m_UseGetter;
    private bool m_UseSetter;
    private bool m_TypeHandlesNull;
    public static string vInputParameterNameUsedByDerivationOCLSet;
    protected FetchStrategy EffectiveFetchStrategy { get; }
    public ClassFrontsidePolicy Owner { get; }
    public IStructuralFeature Feature { get; }
    public IStructuralFeature FeatureWithPersistenceState { get; private set; }
    public bool CanBeEnsured { get; private set; }
    public bool UseGetter { get; }
    public bool UseSetter { get; }
    public bool TypeHandlesNull { get; }
    public MemberFrontsidePolicy(IStructuralFeature feature, ClassFrontsidePolicy owner);
    protected virtual FetchStrategy get_EffectiveFetchStrategy();
    public ClassFrontsidePolicy get_Owner();
    public abstract virtual IStructuralFeature get_Feature();
    [CompilerGeneratedAttribute]
public IStructuralFeature get_FeatureWithPersistenceState();
    [CompilerGeneratedAttribute]
private void set_FeatureWithPersistenceState(IStructuralFeature value);
    [CompilerGeneratedAttribute]
public bool get_CanBeEnsured();
    [CompilerGeneratedAttribute]
private void set_CanBeEnsured(bool value);
    public bool get_UseGetter();
    public bool get_UseSetter();
    public bool get_TypeHandlesNull();
    public abstract virtual void ApplyMemberValue(Locator locator, object value, bool CallerStateMachine);
    public abstract virtual object RetrieveMemberValue(DefaultFrontsideLocator locator);
    protected void ThrowException(string method);
    public void ApplyMemberValueViaSetter(DefaultFrontsideLocator locator, object value);
    public void EndModify(Locator locator);
    public void EnsureContentsCurrent(Locator locator, FetchStrategy FetchStrategy);
    public void EnsureContentsCurrent(Locator locator);
    public ICache GetCache();
    public virtual bool GetIsReadOnly(Locator locator);
    public void MakeDbCurrent(Locator loc, FetchStrategy FetchStrategy);
    public object RetrieveMemberValueViaGetter(DefaultFrontsideLocator locator);
    public void SubscribeToValue(DefaultFrontsideLocator locator, ISubscriber Subscriber);
    public void UnsubscribeFromValue(DefaultFrontsideLocator locator, ISubscriber Subscriber);
    public void AddValueChanged(DefaultFrontsideLocator locator, EventHandler handler);
    public void RemoveValueChanged(DefaultFrontsideLocator locator, EventHandler handler);
    public abstract virtual IProperty GetPropertyAdapter(DefaultFrontsideLocator locator);
    [CompilerGeneratedAttribute]
private string <MakeDbCurrent>b__36_0();
}
public abstract class Eco.Framework.Impl.Frontside.MemberPropertyAdapter : object {
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
private MemberFrontsidePolicy <MemberPolicy>k__BackingField;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
private DefaultFrontsideLocator <Locator>k__BackingField;
    protected DefaultFrontsidePolicy FrontsidePolicy { get; }
    public MemberFrontsidePolicy MemberPolicy { get; private set; }
    protected DefaultFrontsideLocator Locator { get; private set; }
    public ContentType ContentType { get; }
    public bool Mutable { get; }
    public object AsObject { get; public set; }
    public bool IsProperty { get; }
    public bool ReadOnly { get; }
    public IClassifier UmlType { get; }
    public IFeatured Owner { get; }
    public IStructuralFeature StructuralFeature { get; }
    private IElement Eco.ObjectRepresentation.IElementProvider.Element { get; }
    public IEcoServiceProvider ServiceProvider { get; }
    public MemberPropertyAdapter(Locator locator, MemberFrontsidePolicy memberPolicy);
    protected DefaultFrontsidePolicy get_FrontsidePolicy();
    [CompilerGeneratedAttribute]
public MemberFrontsidePolicy get_MemberPolicy();
    [CompilerGeneratedAttribute]
private void set_MemberPolicy(MemberFrontsidePolicy value);
    [CompilerGeneratedAttribute]
protected DefaultFrontsideLocator get_Locator();
    [CompilerGeneratedAttribute]
private void set_Locator(DefaultFrontsideLocator value);
    public abstract virtual ContentType get_ContentType();
    public abstract virtual IElement CloneValue(bool __readonly);
    public abstract virtual IElementCollection GetAsCollection();
    public abstract virtual bool IsEqual(IElement Element);
    public abstract virtual int GetIsEqualHashCode();
    public abstract virtual void Assign(IElement element);
    public sealed virtual bool get_Mutable();
    public virtual int GetHashCode();
    public virtual bool Equals(object obj);
    public virtual object get_AsObject();
    public virtual void set_AsObject(object value);
    protected object GetAsObject();
    public virtual T GetValue();
    public sealed virtual void SetValue(T value);
    public abstract virtual IList`1<T> GetAsIList();
    public sealed virtual bool get_IsProperty();
    public sealed virtual bool get_ReadOnly();
    public virtual IClassifier get_UmlType();
    public sealed virtual void SubscribeToValue(ISubscriber subscriber);
    public sealed virtual void UnsubscribeFromValue(ISubscriber subscriber);
    private sealed virtual override void Eco.ObjectRepresentation.IElement.add_ValueChanged(EventHandler value);
    private sealed virtual override void Eco.ObjectRepresentation.IElement.remove_ValueChanged(EventHandler value);
    public sealed virtual IFeatured get_Owner();
    public sealed virtual IStructuralFeature get_StructuralFeature();
    protected void AutoSubscribe();
    public static void TrimStringValueToMaxLen(IProperty prop, String& value);
    private sealed virtual override IElement Eco.ObjectRepresentation.IElementProvider.get_Element();
    public sealed virtual IEcoServiceProvider get_ServiceProvider();
}
public abstract class Eco.Framework.Impl.Frontside.MultAssociationEndFrontsidePolicy : AssociationEndFrontsidePolicy {
    private IFrontsideAdapterFactory m_Factory;
    public MultAssociationEndFrontsidePolicy(IAssociationEnd assocEnd, ClassFrontsidePolicy owner);
    public abstract virtual int Add(Locator locator, object value);
    public abstract virtual void Clear(Locator locator);
    public abstract virtual void Insert(Locator locator, int index, object value);
    public abstract virtual void Remove(Locator locator, object value);
    public abstract virtual void RemoveAt(Locator locator, int index);
    public abstract virtual void SetItem(Locator locator, int index, object value);
    public virtual IProperty GetPropertyAdapter(DefaultFrontsideLocator locator);
    public virtual void ApplyMemberValue(Locator locator, object value, bool CallerStateMachine);
    public bool Contains(Locator locator, object value);
    private IFrontsideAdapterFactory GetFactory();
    protected IList GetEnsuredCurrentList(Locator locator);
    public int GetCount(Locator locator);
    public DefaultFrontsideLocator GetItemLocator(Locator locator, int index);
    public object GetItem(Locator locator, int index);
    public int IndexOf(Locator locator, object value);
    protected void Reorder(IList`1<Locator> Locators, MemberFrontsidePolicy singleEndPolicy);
    public virtual object RetrieveMemberValue(DefaultFrontsideLocator locator);
}
public class Eco.Framework.Impl.Frontside.MultiLinkAdapterEnumerator`1 : object {
    private IList`1<T> m_Adapter;
    private int m_CurrentIndex;
    private int m_Count;
    public T Current { get; }
    private object System.Collections.IEnumerator.Current { get; }
    public MultiLinkAdapterEnumerator`1(IList`1<T> Adapter);
    public sealed virtual T get_Current();
    private sealed virtual override void System.IDisposable.Dispose();
    private sealed virtual override object System.Collections.IEnumerator.get_Current();
    public sealed virtual bool MoveNext();
    public sealed virtual void Reset();
    [CompilerGeneratedAttribute]
private void <Reset>b__10_0();
}
public class Eco.Framework.Impl.Frontside.MultiMultiFrontsidePolicy : IndirectMultiFrontsidePolicy {
    public MultiMultiFrontsidePolicy(IAssociationEnd assocEnd, ClassFrontsidePolicy owner);
}
public class Eco.Framework.Impl.Frontside.NonDeletableReason : object {
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
private IObjectInstance <Obj>k__BackingField;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
private IAssociationEnd <AssociationEnd>k__BackingField;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
private bool <BusinessDeleteRuleReason>k__BackingField;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
private string <BusinessDeleteRuleText>k__BackingField;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
private IConstraint <BrokenConstraint>k__BackingField;
    public IObjectInstance Obj { get; private set; }
    public IAssociationEnd AssociationEnd { get; private set; }
    public bool BusinessDeleteRuleReason { get; internal set; }
    public string BusinessDeleteRuleText { get; internal set; }
    public IConstraint BrokenConstraint { get; internal set; }
    public NonDeletableReason(IObjectInstance obj, IAssociationEnd associationEnd, IConstraint brokenconstraint);
    [CompilerGeneratedAttribute]
public sealed virtual IObjectInstance get_Obj();
    [CompilerGeneratedAttribute]
private void set_Obj(IObjectInstance value);
    [CompilerGeneratedAttribute]
public sealed virtual IAssociationEnd get_AssociationEnd();
    [CompilerGeneratedAttribute]
private void set_AssociationEnd(IAssociationEnd value);
    [CompilerGeneratedAttribute]
public sealed virtual bool get_BusinessDeleteRuleReason();
    [CompilerGeneratedAttribute]
internal void set_BusinessDeleteRuleReason(bool value);
    [CompilerGeneratedAttribute]
public sealed virtual string get_BusinessDeleteRuleText();
    [CompilerGeneratedAttribute]
internal void set_BusinessDeleteRuleText(string value);
    [CompilerGeneratedAttribute]
public IConstraint get_BrokenConstraint();
    [CompilerGeneratedAttribute]
internal void set_BrokenConstraint(IConstraint value);
}
[DefaultMemberAttribute("Item")]
public class Eco.Framework.Impl.Frontside.ObjectListPropertyAdapter : MemberPropertyAdapter {
    public bool IsSynchronized { get; }
    public object SyncRoot { get; }
    public ContentType ContentType { get; }
    public IClassifier UmlType { get; }
    public IClass UmlClass { get; }
    public int Count { get; }
    public IObjectInstance Item { get; public set; }
    public bool SupportsMove { get; }
    public bool RemoveDeletedObjects { get; public set; }
    private IElement Eco.ObjectRepresentation.IElementCollection.Item { get; private set; }
    public bool SupportsAddNew { get; }
    public ICollectionType UmlCollectionType { get; }
    public bool SupportsRemoveAt { get; }
    public ObjectListPropertyAdapter(Locator Locator, MemberFrontsidePolicy memberPolicy);
    public sealed virtual void Add(IEcoObject value);
    private IObjectInstance[] GetAsArray();
    public sealed virtual IEnumerator GetEnumerator();
    private sealed virtual override IEnumerator`1<IObjectInstance> System.Collections.Generic.IEnumerable<Eco.ObjectRepresentation.IObjectInstance>.GetEnumerator();
    public sealed virtual bool get_IsSynchronized();
    public sealed virtual object get_SyncRoot();
    public sealed virtual void CopyTo(Array array_, int index);
    public virtual ContentType get_ContentType();
    public virtual IElementCollection GetAsCollection();
    public virtual IList`1<T> GetAsIList();
    public sealed virtual IEcoList`1<T> GetAsEcoList();
    public virtual bool IsEqual(IElement Element);
    public virtual int GetIsEqualHashCode();
    public virtual IClassifier get_UmlType();
    public virtual T GetValue();
    public virtual void Assign(IElement Element);
    public sealed virtual void Clear(bool sendValueChanged);
    public sealed virtual bool Contains(IEcoObject value);
    public sealed virtual IClass get_UmlClass();
    public sealed virtual int get_Count();
    public sealed virtual IObjectInstance get_Item(int index);
    public sealed virtual void set_Item(int index, IObjectInstance value);
    private IObjectInstance GetItem(int index);
    public sealed virtual int IndexOf(IEcoObject value);
    public sealed virtual void Insert(int index, IEcoObject value);
    public sealed virtual void Move(int fromPos, int toPos);
    public sealed virtual bool get_SupportsMove();
    public sealed virtual void Remove(IEcoObject value);
    public sealed virtual void RemoveAt(int index);
    public sealed virtual IObjectList EnsureRelatedObjects(string MemberName);
    private void InternalEnsure(FetchStrategy strategy);
    public sealed virtual void EnsureIdsOnly();
    public sealed virtual void EnsureObjects();
    public sealed virtual bool get_RemoveDeletedObjects();
    public sealed virtual void set_RemoveDeletedObjects(bool value);
    private sealed virtual override IElement Eco.ObjectRepresentation.IElementCollection.get_Item(int index);
    private sealed virtual override void Eco.ObjectRepresentation.IElementCollection.set_Item(int index, IElement value);
    public sealed virtual IObjectInstance InternalGet(int index);
    public sealed virtual bool get_SupportsAddNew();
    public sealed virtual IElement AddNew();
    private sealed virtual override void Eco.ObjectRepresentation.IElementCollection.Add(IElement value, bool sendValueChanged);
    private sealed virtual override void Eco.ObjectRepresentation.IObjectContainer.Clear();
    private sealed virtual override bool Eco.ObjectRepresentation.IElementCollection.Contains(IElement value);
    private sealed virtual override int Eco.ObjectRepresentation.IElementCollection.IndexOf(IElement value);
    private sealed virtual override void Eco.ObjectRepresentation.IElementCollection.Insert(int index, IElement value);
    private sealed virtual override void Eco.ObjectRepresentation.IElementCollection.Remove(IElement value);
    public sealed virtual ICollectionType get_UmlCollectionType();
    private Locator[] GetLocatorArray(int FromIndex, int ToIndex);
    public sealed virtual void EnsureRange(int FromIndex, int ToIndex);
    private IList GetAdaptedList();
    public virtual IElement CloneValue(bool readOnly);
    public sealed virtual bool get_SupportsRemoveAt();
    public static IObject AssertedIObject(IElement value);
    public sealed virtual IObjectList GetAsList();
    [CompilerGeneratedAttribute]
private void <Clear>b__21_0();
    [CompilerGeneratedAttribute]
private void <EnsureObjects>b__41_0();
}
public class Eco.Framework.Impl.Frontside.ObjectReferencePropertyAdapter : MemberPropertyAdapter {
    public IPropertyCollection Properties { get; }
    public ContentType ContentType { get; }
    public int Count { get; }
    public IClass UmlClass { get; }
    public IClassifier UmlType { get; }
    public bool Deleted { get; }
    public INonDeletableReason NonDeletableReason { get; }
    public string DefaultStringRepresentation { get; }
    public bool IsDeletable { get; }
    public IObjectInstance ObjectInstance { get; public set; }
    public ObjectReferencePropertyAdapter(Locator Locator, MemberFrontsidePolicy MemberPolicy);
    public sealed virtual IPropertyCollection get_Properties();
    public virtual int GetIsEqualHashCode();
    public virtual ContentType get_ContentType();
    public virtual IElementCollection GetAsCollection();
    public virtual IList`1<T> GetAsIList();
    public virtual bool IsEqual(IElement Element);
    public virtual void Assign(IElement element);
    public virtual IElement CloneValue(bool readOnly);
    public sealed virtual int get_Count();
    public sealed virtual void Clear();
    public sealed virtual IClass get_UmlClass();
    public virtual IClassifier get_UmlType();
    public sealed virtual void EnsureFetched();
    public sealed virtual bool get_Deleted();
    public sealed virtual INonDeletableReason get_NonDeletableReason();
    public sealed virtual string get_DefaultStringRepresentation();
    public sealed virtual bool get_IsDeletable();
    public sealed virtual void Delete();
    private DefaultFrontsideLocator ReferredLocator();
    public sealed virtual IObjectInstance get_ObjectInstance();
    public sealed virtual void set_ObjectInstance(IObjectInstance value);
    public sealed virtual IObjectList GetAsList();
    private sealed virtual override IObjectInstance Eco.ObjectRepresentation.IEcoObject.AsIObject();
}
public class Eco.Framework.Impl.Frontside.RecreateFrontEndObjectDelegate : MulticastDelegate {
    public RecreateFrontEndObjectDelegate(object object, IntPtr method);
    public virtual object Invoke(IClass umlClass, ConstructorInfo constructorInfo, IContent content);
    public virtual IAsyncResult BeginInvoke(IClass umlClass, ConstructorInfo constructorInfo, IContent content, AsyncCallback callback, object object);
    public virtual object EndInvoke(IAsyncResult result);
}
internal static class Eco.Framework.Impl.Frontside.ReenterFetchPageProtector : object {
    [ThreadStaticAttribute]
private static List`1<DefaultFrontsideLocator> _reenterFetchPageProtector;
    internal static List`1<DefaultFrontsideLocator> List { get; }
    internal static List`1<DefaultFrontsideLocator> get_List();
}
public abstract class Eco.Framework.Impl.Frontside.SingleAssociationEndFrontsidePolicy : AssociationEndFrontsidePolicy {
    public SingleAssociationEndFrontsidePolicy(IAssociationEnd assocEnd, ClassFrontsidePolicy owner);
    public virtual IProperty GetPropertyAdapter(DefaultFrontsideLocator locator);
    public virtual object RetrieveMemberValue(DefaultFrontsideLocator locator);
}
public static class Eco.Framework.Impl.Frontside.StateMachineAdmin : object {
    [ThreadStaticAttribute]
private static string _attributeName;
    private static StateMachineAdmin();
    public static bool IsStateMachineForceMode(string name);
    public static void StateMachineForceModeDone(string name);
    public static void EnterStateMachineForceMode(string name);
}
public class Eco.Framework.Impl.Frontside.ToInnerMultiFrontsidePolicy : MultAssociationEndFrontsidePolicy {
    public ToInnerMultiFrontsidePolicy(IAssociationEnd assocEnd, ClassFrontsidePolicy owner);
    public virtual int Add(Locator locator, object value);
    public virtual void Clear(Locator locator);
    public virtual void Insert(Locator locator, int index, object value);
    public virtual void Remove(Locator locator, object value);
    public virtual void RemoveAt(Locator locator, int index);
    public virtual void SetItem(Locator locator, int index, object value);
}
public class Eco.Framework.Impl.Frontside.ToInnerSingleFrontsidePolicy : SingleAssociationEndFrontsidePolicy {
    public ToInnerSingleFrontsidePolicy(IAssociationEnd assocEnd, ClassFrontsidePolicy owner);
    public virtual void ApplyMemberValue(Locator locator, object value, bool CallerStateMachine);
}
public class Eco.Framework.Impl.Frontside.Utils : object {
    public static string DeCamelString(string value);
    public static bool ContainsContextBasedPresentation(string caption);
    public static string ResolveContextBasedPresentation(string caption, IElement context);
    private string GetAsStringValue(IEcoObject obj);
}
public interface Eco.Framework.Impl.IIndirectController {
    public abstract virtual void AdjustIndirectAdd(CacheLocator ReferredLocator, CacheLocator OwningObject);
    public abstract virtual void AdjustIndirectRemove(CacheLocator ReferredLocator, CacheLocator OwningObject);
    public abstract virtual void PreChange(CacheLocator OwningObject);
}
public class Eco.Framework.Impl.IndirectMultiAssociationEndCachePolicy : MainMultiAssociationEndCachePolicy {
    private InnerAssociationEndCachePolicy m_InnerEndPointingAwayPolicy;
    private LinkObjectMultiAssociationEndCachePolicy m_IndirectEndPolicy;
    private InnerAssociationEndCachePolicy m_InnerEndPointingHerePolicy;
    public IndirectMultiAssociationEndCachePolicy(ClassCachePolicy Owner, IAssociationEnd AssociationEnd, int MemberContentIndex, int FlagIndex);
    protected virtual void Changed(CacheLocator locator);
    protected virtual object TransformValueFromCacheToOutside(object value);
    protected virtual object TransformValueFromOutsideToCache(object value);
    public sealed virtual void LinkTo_CurrentAndFetched(CacheLocator newLocator, CacheLocator owningObject);
    public sealed virtual void Unlink_CurrentAndFetched(CacheLocator oldLocator, CacheLocator owningObject);
    public virtual void FreeContent();
    protected virtual void Resort(CacheLocator owningObject);
    protected virtual bool IsInOrder(CacheLocator owningObject);
    private CacheLocator GetLinkObjectOtherLinkLocator(CacheLocator LinkObjectLocator);
    public sealed virtual void Unlink_Current(CacheLocator oldLocator, CacheLocator owningObject);
    public sealed virtual void LinkTo_Current(CacheLocator newLocator, CacheLocator owningObject);
    public sealed virtual void AdjustIndirectAdd(CacheLocator referredLocator, CacheLocator owningObject);
    public sealed virtual void AdjustIndirectRemove(CacheLocator referredLocator, CacheLocator owningObject);
    private int GetLinkObjectOwnLinkOrderNo(int index, CacheLocator owningObject);
    private void SetLinkObjectOwnLinkOrderNo(int index, CacheLocator owningObject, int value);
    public LocatorList GetEnsuredLinkLocatorList(CacheLocator owningObject);
    public virtual void Pass2();
    public virtual void SaveOldValue(Object[] objectContents);
    public virtual void ClearOldValue(Object[] objectContents);
    public sealed virtual void LinkTo_fetched(CacheLocator newLocator, CacheLocator owningObject);
    public sealed virtual void Unlink_fetched(CacheLocator oldLocator, CacheLocator owningObject);
    public virtual int GetCount(CacheLocator owningObject);
}
public class Eco.Framework.Impl.IndirectSingleAssociationEndCachePolicy : SingleAssociationEndCachePolicy {
    private LinkObjectSingleAssociationEndCachePolicy m_LinkObjectEndPolicy;
    private InnerAssociationEndCachePolicy m_InnerEndPolicy;
    public IndirectSingleAssociationEndCachePolicy(ClassCachePolicy owner, IAssociationEnd associationEnd, int memberContentIndex, int flagIndex);
    protected virtual object TransformValueFromCacheToOutside(object value);
    protected virtual object TransformValueFromOutsideToCache(object value);
    public virtual void SetLocator_Current(CacheLocator newLocator, CacheLocator owningObject);
    private CacheLocator GetLinkObjectOtherLinkLocator(CacheLocator LinkObjectLocator);
    public sealed virtual void AdjustIndirectAdd(CacheLocator ReferredLocator, CacheLocator owningObject);
    public sealed virtual void AdjustIndirectRemove(CacheLocator referredLocator, CacheLocator owningObject);
    public sealed virtual void LinkTo_Current(CacheLocator newLocator, CacheLocator owningObject);
    public sealed virtual void Unlink_Current(CacheLocator oldLocator, CacheLocator owningObject);
    public sealed virtual void LinkTo_CurrentAndFetched(CacheLocator newLocator, CacheLocator owningObject);
    public sealed virtual void Unlink_CurrentAndFetched(CacheLocator oldLocator, CacheLocator owningObject);
    public CacheLocator GetLinkObjectLocator(CacheLocator owningObject);
    protected virtual void Changed(CacheLocator locator);
    public virtual void Pass2();
    public virtual void SaveOldValue(Object[] objectContents);
    public virtual void ClearOldValue(Object[] objectContents);
    public virtual void DoDeserialize(CacheLocator locator, Stream source, BinaryReader reader);
    public virtual void DoSerialize(CacheLocator locator, Stream target, EcoSpaceSerializationConfig config);
    public sealed virtual void LinkTo_fetched(CacheLocator newLocator, CacheLocator owningObject);
    public sealed virtual void Unlink_fetched(CacheLocator oldLocator, CacheLocator owningObject);
}
public class Eco.Framework.Impl.InnerAssociationEndCachePolicy : DirectSingleAssociationEndCachePolicy {
    private IIndirectController m_OtherEndMainPolicy;
    public InnerAssociationEndCachePolicy m_OhterInnerPolicy;
    public InnerAssociationEndCachePolicy(ClassCachePolicy owner, IAssociationEnd associationEnd, int memberContentIndex, int flagIndex);
    private CacheLocator GetOtherOuterLocator(CacheLocator owningObject);
    public virtual void Pass2();
    public virtual void SetCurrentAndFetchedValue(object value, CacheLocator owningObject);
    public virtual void SetLocator_Current(CacheLocator newLocator, CacheLocator owningObject);
}
public interface Eco.Framework.Impl.IOtherEndController {
    public abstract virtual void Unlink_CurrentAndFetched(CacheLocator OldLocator, CacheLocator OwningObject);
    public abstract virtual void Unlink_Current(CacheLocator OldLocator, CacheLocator OwningObject);
    public abstract virtual void Unlink_fetched(CacheLocator OldLocator, CacheLocator OwningObject);
    public abstract virtual void LinkTo_CurrentAndFetched(CacheLocator NewLocator, CacheLocator OwningObject);
    public abstract virtual void LinkTo_Current(CacheLocator NewLocator, CacheLocator OwningObject);
    public abstract virtual void LinkTo_fetched(CacheLocator NewLocator, CacheLocator OwningObject);
}
public class Eco.Framework.Impl.LinkObjectMultiAssociationEndCachePolicy : MultiAssociationEndCachePolicy {
    private IndirectMultiAssociationEndCachePolicy m_MainEndPolicy;
    public LinkObjectMultiAssociationEndCachePolicy(ClassCachePolicy owner, IAssociationEnd associationEnd, int memberContentIndex, int flagIndex);
    protected virtual object TransformValueFromCacheToOutside(object value);
    protected virtual object TransformValueFromOutsideToCache(object value);
    public virtual void Pass2();
    public virtual PersistenceState GetPersistenceState(Object[] objectContents);
    public virtual void SetPersistenceState(Object[] objectContents, CacheLocator locator, PersistenceState value);
    public virtual void EnsureOrder(CacheLocator owningObject);
    public virtual void SaveOldValue(Object[] objectContents);
    public virtual void ClearOldValue(Object[] objectContents);
    public virtual int GetCount(CacheLocator owningObject);
}
public class Eco.Framework.Impl.LinkObjectSingleAssociationEndCachePolicy : SingleAssociationEndCachePolicy {
    private IndirectSingleAssociationEndCachePolicy m_MainEndPolicy;
    public LinkObjectSingleAssociationEndCachePolicy(ClassCachePolicy owner, IAssociationEnd associationEnd, int memberContentIndex, int flagIndex);
    protected virtual object TransformValueFromCacheToOutside(object value);
    protected virtual object TransformValueFromOutsideToCache(object value);
    public virtual PersistenceState GetPersistenceState(Object[] objectContents);
    public virtual void SetPersistenceState(Object[] objectContents, CacheLocator locator, PersistenceState value);
    public virtual void SetLocator_Current(CacheLocator newLocator, CacheLocator owningObject);
    public virtual void Pass2();
    public virtual void SaveOldValue(Object[] objectContents);
    public virtual void ClearOldValue(Object[] objectContents);
}
[DefaultMemberAttribute("Item")]
public class Eco.Framework.Impl.LocatorDictionary : object {
    private PooledDictionary`2<ObjectId, CacheLocator> m_Dictionary;
    public CacheLocator Item { get; }
    public CacheLocator get_Item(ObjectId objectID);
    public void UpdateID(CacheLocator Locator, ObjectId NewObjectID, bool AllowInternal);
    public void Remove(CacheLocator Locator);
    public ICollection GetLocators();
    public ICollection`1<CacheLocator> GetLocatorsTyped();
    public bool ContainsInstance(CacheLocator Locator);
    public void Add(CacheLocator Locator);
    public sealed virtual void CleanForFree();
    public sealed virtual void PruneResources(bool LowMemoryCondition);
    public sealed virtual EcoRuntimeInformation GetRuntimeInformation(IExecutionAndDebug owner, DebugSettingsStack settings, int depth);
}
public abstract class Eco.Framework.Impl.MainMultiAssociationEndCachePolicy : MultiAssociationEndCachePolicy {
    public MainMultiAssociationEndCachePolicy(ClassCachePolicy owner, IAssociationEnd associationEnd, int memberContentIndex, int flagIndex);
    public virtual void DoDeserialize(CacheLocator locator, Stream source, BinaryReader reader);
    protected abstract virtual bool IsInOrder(CacheLocator owningObject);
    protected abstract virtual void Resort(CacheLocator owningObject);
    public virtual void EnsureOrder(CacheLocator owningObject);
    public void MarkPossiblyOutOfOrder(CacheLocator owningObject);
}
public abstract class Eco.Framework.Impl.MemberCachePolicy : object {
    private ClassCachePolicy m_Owner;
    private int m_MemberContentIndex;
    private int m_MemberFlagsIndex;
    private bool m_IsDefaultFetch;
    private byte m_InitialFlagsNewPerisistentInstance;
    private byte m_InitialFlagsOldInstance;
    private bool _isRealtime;
    protected ClassCachePolicy ClassCachePolicy { get; }
    public int MemberContentIndex { get; }
    public int MemberFlagIndex { get; }
    public IStructuralFeature StructuralFeature { get; }
    public ClassCachePolicy Owner { get; }
    public CacheImpl OwningCache { get; }
    public bool IsDefaultFetch { get; }
    public MemberCachePolicy(ClassCachePolicy Owner, IStructuralFeature structuralFeature, int MemberContentIndex, int FlagIndex);
    protected ClassCachePolicy get_ClassCachePolicy();
    public int get_MemberContentIndex();
    public int get_MemberFlagIndex();
    public abstract virtual IStructuralFeature get_StructuralFeature();
    public ClassCachePolicy get_Owner();
    public CacheImpl get_OwningCache();
    public bool get_IsDefaultFetch();
    public Object[] GetObjectContents(CacheLocator locator);
    public abstract virtual void SetCurrentValue(CacheLocator locator, object value);
    public abstract virtual object GetCurrentValue(CacheLocator locator);
    public abstract virtual void SetCurrentAndFetchedValue(object value, CacheLocator locator);
    public abstract virtual void SetFetchedValue(CacheLocator locator, object value);
    public abstract virtual object GetFetchedValue(CacheLocator locator);
    public abstract virtual void SaveOldValue(Object[] objectContents);
    public abstract virtual void ClearOldValue(Object[] objectContents);
    protected abstract virtual object TransformValueFromCacheToOutside(object value);
    protected abstract virtual object TransformValueFromOutsideToCache(object value);
    public object GetCurrentValueRaw(CacheLocator locator);
    public object GetFetchedValueRaw(CacheLocator locator);
    public object GetContents(Object[] objectContents);
    public void SetContents(Object[] objectContents, object value);
    public virtual void SetPersistenceState(Object[] objectContents, CacheLocator locator, PersistenceState value);
    private void CheckRealtimeStateChange(CacheLocator locator);
    public void CopyOldMemberContent(Object[] objectContents);
    public object GetEnsuredOldMemberContent(Object[] objectContents);
    protected Object[] GetEnsuredOldValues(Object[] objectContents);
    protected void RemoveOldMemberContent(Object[] objectContents);
    public object GetOldMemberContent(Object[] objectContents);
    public void SetOldMemberContent(Object[] objectContents, object oldValue);
    protected virtual void Changed(CacheLocator locator);
    private static bool IsInnerOrIndirectAassociationEnd(IStructuralFeature structuralFeature);
    public virtual void FreeMemberContent(Object[] objectContents);
    public bool GetMayBeOutOfOrder(Object[] objectContents);
    public virtual PersistenceState GetPersistenceState(Object[] objectContents);
    public bool GetTouched(Object[] objectContents);
    protected byte GetMemberFlags(Object[] objectContents);
    public sealed virtual void PreChange(CacheLocator locator);
    protected bool MemberExistsInDatablock(CacheLocator locator, Datablock block);
    protected void SetMemberFlags(Object[] objectContents, byte value);
    protected void SetFlag(Object[] objectContents, int flag, bool value);
    public void SetMayBeOutOfOrder(Object[] objectContents, bool value);
    public byte UpdatePersistenceStateFlags(byte flags, PersistenceState value);
    public void InternalSetPersistenceState(Object[] objectContents, PersistenceState value);
    public void SetTouched(Object[] objectContents, bool value);
    protected void ValueChanged(CacheLocator locator);
    public object GetContents(CacheLocator locator);
    public void SetContents(CacheLocator locator, object value);
    public virtual int GetMemberSlots();
    public virtual void Pass2();
    public virtual void DoSerialize(CacheLocator locator, Stream target, EcoSpaceSerializationConfig config);
    public virtual void DoDeserialize(CacheLocator locator, Stream source, BinaryReader reader);
    public bool GetIsPersistent(Object[] objectContents);
    public void InitState(Object[] objectContents, bool persistentObject, bool isNew);
    public abstract virtual void Initialize(Object[] objectContents);
    public bool GetHasOldValue(Object[] objectContents);
    public void SetHasOldValue(Object[] objectContents, bool value);
}
public abstract class Eco.Framework.Impl.MultiAssociationEndCachePolicy : AssociationEndCachePolicy {
    public MultiAssociationEndCachePolicy(ClassCachePolicy owner, IAssociationEnd associationEnd, int memberContentIndex, int flagIndex);
    public abstract virtual void EnsureOrder(CacheLocator owningObject);
    public abstract virtual int GetCount(CacheLocator owningObject);
    public virtual void DoDeserialize(CacheLocator locator, Stream source, BinaryReader reader);
    public virtual void DoSerialize(CacheLocator locator, Stream target, EcoSpaceSerializationConfig config);
    public LocatorList GetEnsuredContentAsLocatorList(CacheLocator owningObject);
    public LocatorList GetContentAsLocatorList(CacheLocator owningObject);
    public virtual void SetFetchedValue(CacheLocator owningObject, object value);
    public virtual object GetFetchedValue(CacheLocator owningObject);
    public virtual void FreeContent();
    public virtual void SetCurrentValue(CacheLocator owningObject, object value);
    public virtual object GetCurrentValue(CacheLocator owningObject);
    public int IndexOfLocator(CacheLocator item, CacheLocator owningObject);
    public bool IncludesLocator(CacheLocator item, CacheLocator owningObject);
    public CacheLocator GetLocator(int index, CacheLocator owningObject);
    protected void CopyOldLocatorList(Object[] objectContents);
    public void InternalAddLocator(CacheLocator owningObject, CacheLocator locator);
    public void ResortContents(CacheLocator owningObject, Int32[] keys);
}
public class Eco.Framework.Impl.RealtimeChangeArgs : EventArgs {
    public Locator Locator;
    public IStructuralFeature Feature;
}
public class Eco.Framework.Impl.SharedBigValue : object {
    private WeakReference _weakvalue;
    public object RealValue { get; }
    public SharedBigValue(object theValue);
    public object get_RealValue();
    public void Clear();
}
public abstract class Eco.Framework.Impl.SingleAssociationEndCachePolicy : AssociationEndCachePolicy {
    private int m_OrderNoIndex;
    protected int OrderNoIndex { get; }
    public SingleAssociationEndCachePolicy(ClassCachePolicy owner, IAssociationEnd associationEnd, int memberContentIndex, int flagIndex);
    protected int get_OrderNoIndex();
    public abstract virtual void SetLocator_Current(CacheLocator newLocator, CacheLocator owningObject);
    public virtual void SetFetchedValue(CacheLocator owningObject, object value);
    public virtual object GetFetchedValue(CacheLocator owningObject);
    public virtual void SetOrderNo_cache(int orderNo, CacheLocator owningObject);
    public virtual void SetCurrentValue(CacheLocator owningObject, object value);
    public virtual object GetCurrentValue(CacheLocator owningObject);
    public virtual int GetMemberSlots();
    public int GetOrderNo(CacheLocator locator);
    public int GetOrderNo(Object[] objectContents);
    public void SetOrderNo(CacheLocator locator, int value);
    public void SetOrderNo(Object[] objectContents, int value);
    public virtual void Initialize(Object[] objectContents);
    public CacheLocator GetContentsAsLocator(CacheLocator owningObject);
    public int GetFetchedOrderNo(CacheLocator locator);
}
public class Eco.Framework.MemberDeriveException : InvalidOperationException {
    public MemberDeriveException(string message, Exception innerException);
    public MemberDeriveException(string message);
}
internal class Eco.Framework.OclDerivedMember : DerivedMember {
    public OclDerivedMember(DerivedMemberManager manager, IObjectInstance obj, IStructuralFeature member);
    protected virtual void DoDeriveAndSubscribe(bool subscribe);
}
public class Eco.Framework.ValueChangedDelegate : MulticastDelegate {
    public ValueChangedDelegate(object object, IntPtr method);
    public virtual void Invoke(IProperty prop, EventArgs args);
    public virtual IAsyncResult BeginInvoke(IProperty prop, EventArgs args, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
public interface Eco.FrameworkImpl.Frontside.IStateMachineAccess {
    public IUndoService UndoService { get; }
    public abstract virtual IObjectInstance GetOwner();
    public abstract virtual void SetState(IState state);
    public abstract virtual IUndoService get_UndoService();
}
public class Eco.FrameworkImpl.Frontside.ObjectStateMachine : object {
    private IOclService m_OclService;
    private IActionLanguageService m_ActionService;
    private IVariableFactoryService m_VariableFactoryService;
    private IStateMachine m_StateMachine;
    private IStateMachineAccess m_StateMachineAccess;
    private static object s_TrueBoolean;
    public IObjectInstance Owner { get; }
    public IStateMachine StateMachine { get; }
    public ObjectStateMachine(IStateMachineAccess stateMachineAccess);
    private static ObjectStateMachine();
    public sealed virtual bool CanTrigger(ITrigger trigger, Object[] parameters);
    public sealed virtual IObjectInstance get_Owner();
    public sealed virtual bool IsInState(IState state);
    public sealed virtual ITriggerCollection GetTriggers();
    public sealed virtual object Trigger(ITrigger trigger, Object[] parameters);
    public sealed virtual ITriggerCollection GetTriggers(IRegion region);
    private void AddStates(StateCollection list, IRegion region, StateFilter filter);
    public sealed virtual bool IsInRegion(IRegion region);
    private bool CanTrigger(ITrigger trigger, IElement[] parameters, ISubscriber reevaluateSubscriber, ISubscriber resubscribeSubscriber, ICollection States);
    public sealed virtual bool IsTriggerCurrentlyAvailable(ITrigger trigger);
    private bool IsSameTrigger(ITrigger t1, ITrigger t2);
    private bool CheckGuard(ITransition transition, IExternalVariableList variables, ISubscriber reevaluateSubscriber, ISubscriber resubscribeSubscriber);
    private IElement PerformTransition(ITransition transition, IExternalVariableList variables);
    public static bool FilterState(IState state, StateFilter filter);
    private ITriggerCollection GetTriggers(IStateCollection states);
    private ITransitionCollection GetTransitions(IStateCollection states);
    public sealed virtual ITransitionCollection GetTransitions(IRegion region);
    public sealed virtual ITransitionCollection GetTransitions();
    private IExternalVariableList MakeVariableList(ITrigger trigger, IElement[] parameters);
    public sealed virtual IStateCollection GetStates(IRegion region, StateFilter filter);
    public sealed virtual IStateCollection GetStates(StateFilter filter);
    public sealed virtual IState StateByName(string name);
    public sealed virtual IRegion RegionByName(string name);
    public sealed virtual object Trigger(string triggerName, Object[] parameters);
    public ITrigger TriggerByName(string name);
    public sealed virtual bool CanTrigger(string triggerName, Object[] parameters);
    public sealed virtual IStateCollection GetStates(string regionName, StateFilter Filter);
    public sealed virtual ITriggerCollection GetTriggers(string regionName);
    public sealed virtual bool IsInState(string stateName);
    public sealed virtual bool IsInState(IStateName stateName);
    public sealed virtual bool IsInRegion(string regionName);
    public sealed virtual ITransitionCollection GetTransitions(string regionName);
    public void InitializeObject();
    public sealed virtual IStateMachine get_StateMachine();
    public sealed virtual void SubscribeToState(ISubscriber subscriber);
    public void UnsubscribeFromState(ISubscriber subscriber);
    private IElement[] MakeElementArray(Object[] parameters);
    private IElement[] MakeElementArray(Object[] parameters, IMethod method);
    private string GetFullStateName(IVertex state);
    public sealed virtual IElement Trigger(ITrigger trigger, IElement[] parameters);
    private void CallOnStateChange(string attribname, string oldstate, string newstate);
    private string GetCurrentState();
    public sealed virtual IElement Trigger(string triggerName, IElement[] parameters);
    public sealed virtual bool CanTrigger(ITrigger trigger, IElement[] parameters);
    public sealed virtual bool CanTrigger(string triggerName, IElement[] parameters);
    public sealed virtual bool CanTrigger(ITrigger trigger, IElement[] parameters, ISubscriber reevaluateSubscriber, ISubscriber resubscribeSubscriber);
    private TriggerResult InternalTrigger(IVertex vertex, ITrigger trigger, IExternalVariableList variables, bool mandatory);
    private void FinalStateReached(IFinalState finalState);
    private bool AllRegionsInFinalState(IRegionContainer container);
    private void EnterContainer(IRegionContainer container, IState startState);
    private void ExitState(IState source, IState stateToExit, IRegion targetRegion);
    public IState GetState(IRegion region);
}
public class Eco.FrameworkImpl.LockRegions.ConcreteRegionDefinitionList : List`1<TBoldConcreteRegionDefinition> {
    public TBoldConcreteRegionDefinition FindByRootClass(IClass RootClass);
}
internal static class Eco.FrameworkImpl.LockRegions.ExpanderHelper : object {
    public static void FetchAndExpandOneLevelParentRegions(TBoldRegionLookup regions, TBoldRegionLookup ParentRegions, TBoldRegionLookup AlreadyExpandedRegions, TBoldRegionLookup AlreadyKnownRegions, IPersistenceHandler PersistenceHandler);
    public static void ExpandOneLevelRegionsForNavigation(TBoldRegionLookup regions, TBoldRegionLookup parentRegions, IAssociationEnd Navigation, TBoldRegionCoreDefinition CoreDef, TBoldRegionLookup AlreadyExpandedRegions, TBoldRegionLookup AlreadyKnownRegions);
    public static void FetchAndExpandOneLevelSubRegions(TBoldRegionLookup regions, TBoldRegionLookup SubRegions, TBoldRegionLookup AdditionalRegions, TBoldRegionLookup AlreadyExpandedRegions, TBoldRegionLookup AlreadyKnownRegions, IPersistenceHandler PersistenceHandler, ICache Cache);
    private static void FetchAndExpandOneLevelSubRegions_MassiveFetch(TBoldRegionLookup regions, ICollection`1<Locator> ObjectList, IAssociationEnd AssociationEnd, TBoldRegionLookup AdditionalRegions, IPersistenceHandler PersistenceHandler, ICache Cache);
    private static ICollection`1<Locator> GetEnsuredLocators(TBoldRegionLookup regions, IPersistenceHandler persistenceHandler);
    private static ILockRegion AnyRegion(TBoldRegionLookup regions);
}
public class Eco.FrameworkImpl.LockRegions.IdChangedEventargs : ElementChangedEventArgs {
    private bool fPreChange;
    public bool PreChange { get; }
    public IdChangedEventargs(IElement Element, bool PreChange);
    public bool get_PreChange();
}
public interface Eco.FrameworkImpl.LockRegions.ILockRegion {
    public IClass RootClass { get; }
    public Locator RootLocator { get; }
    public TBoldConcreteRegionDefinition Definition { get; }
    public string RegionId { get; }
    public abstract virtual IClass get_RootClass();
    public abstract virtual Locator get_RootLocator();
    public abstract virtual TBoldConcreteRegionDefinition get_Definition();
    public abstract virtual ICollection`1<TRegionElement> GetRegionElements();
    public abstract virtual string get_RegionId();
}
public interface Eco.FrameworkImpl.LockRegions.IRegionFactory {
    public abstract virtual ICollection`1<ILockRegion> GetRegionsForObject(Locator locator);
    public abstract virtual ICollection`1<ILockRegion> GetRegionsForMember(Locator locator, IStructuralFeature structuralFeature);
}
public class Eco.FrameworkImpl.LockRegions.LockRegionImpl : object {
    private TBoldConcreteRegionDefinition m_Definition;
    private Locator m_RootLocator;
    private TBoldRegionFactory m_Factory;
    private TBoldIdChangedAdapter m_IdChangedAdapter;
    private TBoldRegionChangedAdapter m_RegionChangedAdapter;
    private string m_IdString;
    public TBoldConcreteRegionDefinition Definition { get; }
    public Locator RootLocator { get; }
    public IClass RootClass { get; }
    public TBoldRegionFactory Factory { get; }
    public TBoldRegionChangedAdapter RegionChangedAdapter { get; public set; }
    public string RegionId { get; }
    public LockRegionImpl(TBoldConcreteRegionDefinition Definition, Locator RootLocator, TBoldRegionFactory Factory);
    public sealed virtual TBoldConcreteRegionDefinition get_Definition();
    public sealed virtual Locator get_RootLocator();
    public sealed virtual IClass get_RootClass();
    public TBoldRegionFactory get_Factory();
    public TBoldRegionChangedAdapter get_RegionChangedAdapter();
    public void set_RegionChangedAdapter(TBoldRegionChangedAdapter value);
    public IEnumerable`1<Locator> NavigateAndSubscribe(IAssociationEnd RoleRT, ISubscriber Subscriber, bool Ensure);
    public void FillDependentSubregions(List`1<ILockRegion> RegionList);
    public void FillIndependentSubregions(List`1<ILockRegion> RegionList);
    private void FillSubregions(List`1<ILockRegion> RegionList, bool Dependent);
    public virtual string ToString();
    public sealed virtual string get_RegionId();
    public sealed virtual ICollection`1<TRegionElement> GetRegionElements();
    private void PlaceRootSubscriptions();
    internal void ReceiveIdEvent(EventArgs e);
    internal void ReceiveRegionChanged();
}
public class Eco.FrameworkImpl.LockRegions.RegionExpressionSyntaxErrorException : Exception {
    public RegionExpressionSyntaxErrorException(string s);
}
public class Eco.FrameworkImpl.LockRegions.RegionParser : object {
    private string m_Expression;
    private int m_Position;
    private TBoldRegionDefinitions m_RegionDefinitions;
    private IEcoTypeSystem m_SystemTypeInfo;
    private List`1<string> m_Errors;
    private int m_LastSymbolPosition;
    private bool EOS { get; }
    private char NextToken { get; }
    public TBoldRegionDefinitions RegionDefinitions { get; }
    public IList`1<string> Errors { get; }
    public RegionParser(IEcoTypeSystem systemTypeInfo);
    private bool get_EOS();
    private char get_NextToken();
    public TBoldRegionDefinitions get_RegionDefinitions();
    public IList`1<string> get_Errors();
    private void Eat(string s);
    private void GenerateDefaultRegions();
    private string GetSymbol(RegionDefinitionSymbolType Symboltype);
    public bool Parse(string RegionDefinitionListAsString);
    private void ParseMembers(TBoldConcreteRegionDefinition ConcreteRegionDefinition);
    private void ParseSubregions(TBoldConcreteRegionDefinition ConcreteRegionDefinition);
    private void ParseMembersAndSubregions(TBoldRegionCoreDefinition CoreDefinition, IClass ClassTypeInfo);
    protected void Skip();
    protected bool TryToEat(string s);
    private void ParseCurrentExpression();
    private void AddError(int pos, string msg, Object[] args, RegionParserErrorType ErrorType);
    private void CheckRegionReferences();
}
public class Eco.FrameworkImpl.LockRegions.TBoldConcreteRegionDefinition : object {
    private List`1<TBoldRegionElementInclusion> fElements;
    private List`1<TBoldSubregionReference> fSubregions;
    private IClass fRootClass;
    private TBoldRegionCoreDefinition fCoreDefinition;
    private List`1<TBoldSubregionReference> fParentRegions;
    public TBoldRegionCoreDefinition CoreDefinition { get; }
    public IClass RootClass { get; }
    public List`1<TBoldRegionElementInclusion> Elements { get; }
    public ICollection`1<TBoldSubregionReference> Subregions { get; }
    public List`1<TBoldSubregionReference> ParentRegions { get; }
    public TBoldConcreteRegionDefinition(TBoldRegionCoreDefinition CoreDefinition, IClass Root);
    public TBoldRegionCoreDefinition get_CoreDefinition();
    public IClass get_RootClass();
    public List`1<TBoldRegionElementInclusion> get_Elements();
    public ICollection`1<TBoldSubregionReference> get_Subregions();
    public List`1<TBoldSubregionReference> get_ParentRegions();
    internal void CopyFromDefinition(TBoldConcreteRegionDefinition SuperDef);
    public virtual string ToString();
}
public class Eco.FrameworkImpl.LockRegions.TBoldIdChangedAdapter : SubscriberAdapterBase {
    public TBoldIdChangedAdapter(object subscriber);
    protected virtual void DoReceive(object sender, EventArgs e, object actualSubscriber);
}
public class Eco.FrameworkImpl.LockRegions.TBoldOrderedRegionLookup : TBoldRegionLookup {
    private List`1<ILockRegion> fList;
    public ILockRegion FirstRegion { get; }
    public ILockRegion get_FirstRegion();
    public virtual void Add(ILockRegion Region);
    public virtual void Clear();
    public virtual void Remove(ILockRegion Region);
}
public class Eco.FrameworkImpl.LockRegions.TBoldRegionChangedAdapter : SubscriberAdapterBase {
    public TBoldRegionChangedAdapter(object subscriber);
    protected virtual void DoReceive(object sender, EventArgs e, object actualSubscriber);
}
public class Eco.FrameworkImpl.LockRegions.TBoldRegionCoreDefinition : object {
    private string fName;
    private TBoldRegionDefinitions fOwner;
    private List`1<TBoldSubregionReference> fUsedBy;
    private ConcreteRegionDefinitionList fConcreteDefinitions;
    public string Name { get; }
    public TBoldRegionDefinitions Owner { get; }
    public ConcreteRegionDefinitionList ConcreteDefinitions { get; }
    public List`1<TBoldSubregionReference> UsedBy { get; }
    public TBoldRegionCoreDefinition(TBoldRegionDefinitions Owner, string Name);
    public string get_Name();
    public TBoldRegionDefinitions get_Owner();
    public ConcreteRegionDefinitionList get_ConcreteDefinitions();
    public List`1<TBoldSubregionReference> get_UsedBy();
    public TBoldConcreteRegionDefinition EnsuredConcreteDefinition(IClass Root, Boolean& Existed);
    internal void ExpandDefinitions();
}
public class Eco.FrameworkImpl.LockRegions.TBoldRegionDefinitions : object {
    private ClassListType fClassList;
    private List`1<ConcreteRegionDefinitionList> fConcreteRegions;
    private List`1<TBoldRegionCoreDefinition> fCoreDefinitions;
    public List`1<TBoldRegionCoreDefinition> CoreDefinitions { get; }
    public List`1<TBoldRegionElementInclusion> RegionInclusionsByMember(IStructuralFeature Member);
    public ConcreteRegionDefinitionList ConcreteRegionDefinitionsByRootClass(IClass TheClass);
    public TBoldRegionCoreDefinition CoreDefinition(string Name);
    public List`1<TBoldRegionCoreDefinition> get_CoreDefinitions();
    internal void AddConcreteRegionDefinition(TBoldConcreteRegionDefinition Item);
    internal void AddCoreDefinition(TBoldRegionCoreDefinition Item);
    internal void AddRegionElementInclusion(TBoldRegionElementInclusion Item);
    public TBoldRegionCoreDefinition EnsuredCoreDefinition(string Name);
    public void ExpandDefinitions();
}
public class Eco.FrameworkImpl.LockRegions.TBoldRegionElementInclusion : object {
    private IStructuralFeature fMember;
    private TBoldConcreteRegionDefinition fRegion;
    public TBoldConcreteRegionDefinition Region { get; }
    public IStructuralFeature Member { get; }
    public TBoldRegionElementInclusion(TBoldConcreteRegionDefinition Region, IStructuralFeature Member);
    public TBoldConcreteRegionDefinition get_Region();
    public IStructuralFeature get_Member();
    internal void Clone(TBoldConcreteRegionDefinition NewOwner);
}
public class Eco.FrameworkImpl.LockRegions.TBoldRegionExpander : object {
    private IEcoTypeSystem fTypeSystem;
    private TBoldRegionLookup fNewParentRegions;
    private TBoldRegionLookup fNewSubregions;
    private TBoldOrderedRegionLookup fToBeSubExpanded;
    private TBoldOrderedRegionLookup fToBeParentExpanded;
    private object fOnActivityProgress;
    public TBoldRegionLookup NewParentRegions { get; }
    public TBoldRegionLookup NewSubRegions { get; }
    public object OnProgress { get; public set; }
    public TBoldRegionExpander(IEcoTypeSystem typeSystem);
    public TBoldRegionLookup get_NewParentRegions();
    public TBoldRegionLookup get_NewSubRegions();
    public object get_OnProgress();
    public void set_OnProgress(object value);
    protected void Clear();
    protected void ExtractSimilarRegions(TBoldRegionLookup Regions, ILockRegion Region, TBoldRegionLookup Result);
    public void ExpandParentRegions(TBoldRegionLookup RegionsToExpand, TBoldRegionLookup KnownParentRegions, TBoldRegionLookup KnownSubregions, IPersistenceHandler PersistenceHandler);
    public void ExpandSubregions(TBoldRegionLookup RegionsToExpand, TBoldRegionLookup KnownSubregions, IPersistenceHandler System, ICache Cache);
    private void SignalProgress();
    public void ExpandRegionEnclosure(TBoldRegionLookup Regions, IPersistenceHandler PersistenceHandler, ICache Cache);
}
public class Eco.FrameworkImpl.LockRegions.TBoldRegionFactory : EcoSpacePartWithTypeSystem {
    private TBoldRegionDefinitions m_Definitions;
    private IObjectRepresentationProvider m_ObjRepProv;
    private ICache m_Cache;
    private TBoldRegionLookup m_Lookup;
    public IObjectRepresentationProvider ObjectRepresentationProvider { get; public set; }
    public ICache Cache { get; public set; }
    internal TBoldRegionLookup FLookup { get; }
    public TBoldRegionFactory(IEcoTypeSystem typeSystem);
    public IObjectRepresentationProvider get_ObjectRepresentationProvider();
    public void set_ObjectRepresentationProvider(IObjectRepresentationProvider value);
    public ICache get_Cache();
    public void set_Cache(ICache value);
    internal TBoldRegionLookup get_FLookup();
    private TBoldRegionCoreDefinition CoreDefintionFromRegionId(string RegionId);
    protected virtual void DoActivate();
    protected virtual void DoDeactivate();
    public ILockRegion GetRegion(TBoldRegionCoreDefinition Definition, Locator RootLocator);
    public ILockRegion GetRegionByName(string RegionName);
    public sealed virtual ICollection`1<ILockRegion> GetRegionsForObject(Locator aLocator);
    public sealed virtual ICollection`1<ILockRegion> GetRegionsForMember(Locator aLocator, IStructuralFeature StructuralFeature);
    public string GetRegionId(TBoldRegionCoreDefinition Definition, Locator RootLocator);
    public static void RootObjectLocatorFromRegionId_ExtractIdAndClass(string s, Int32& Id, Int32& ClassId);
    private Locator RootObjectLocatorFromRegionId(string RegionId);
}
public class Eco.FrameworkImpl.LockRegions.TBoldRegionLookup : object {
    private Dictionary`2<string, ILockRegion> m_Dictionary;
    public int Count { get; }
    public int get_Count();
    public void AddRegionLookup(TBoldRegionLookup Regions);
    public bool ContainsKey(string key);
    public bool TryGetValue(string key, ILockRegion& value);
    internal void AddIfKeyNotPresent(ILockRegion Region);
    public void AddRegionLookupWithFilter(TBoldRegionLookup Regions, TBoldRegionLookup Filter);
    public virtual void Add(ILockRegion Region);
    public virtual void Remove(ILockRegion Region);
    public virtual void Clear();
    public ICollection`1<ILockRegion> GetRegions(bool clone);
}
public class Eco.FrameworkImpl.LockRegions.TBoldSubregionReference : object {
    private IAssociationEnd fSubregionRootNavigation;
    private TBoldRegionCoreDefinition fSubregionCoreDefinition;
    private TBoldConcreteRegionDefinition fParentRegion;
    private bool fIsDependent;
    public TBoldConcreteRegionDefinition ParentRegion { get; }
    public IAssociationEnd SubregionRootNavigation { get; }
    public TBoldRegionCoreDefinition SubregionCoreDefinition { get; }
    public bool IsDependent { get; }
    public TBoldSubregionReference(TBoldConcreteRegionDefinition ParentRegion, TBoldRegionCoreDefinition SubregionCoreDefinition, IAssociationEnd Navigation, bool IsDependent);
    public TBoldConcreteRegionDefinition get_ParentRegion();
    public IAssociationEnd get_SubregionRootNavigation();
    public TBoldRegionCoreDefinition get_SubregionCoreDefinition();
    public bool get_IsDependent();
    internal void Clone(TBoldConcreteRegionDefinition NewOwner);
}
public class Eco.FrameworkImpl.LockRegions.TRegionElement : ValueType {
    private Locator m_Locator;
    private ICollection`1<IStructuralFeature> m_Members;
    public Locator MyLocator { get; }
    public ICollection`1<IStructuralFeature> Members { get; }
    public TRegionElement(Locator locator, ICollection`1<IStructuralFeature> members);
    public Locator get_MyLocator();
    public ICollection`1<IStructuralFeature> get_Members();
}
public class Eco.FrameworkImpl.LockRegions.Units.BoldRegionDefinitionParser : object {
    public static char SPACE;
    public static char TAB;
    public static string BOLDDEFAULTREGIONNAME;
    public static string BOLDDEFAULTEMPTYREGIONNAME;
    public static string BOLDINDEPENDENTCASCADECOREREGIONPREFIX;
    public static bool CharIsDigit(char ch);
    public static bool CharIsAlfaChar(char ch);
}
public abstract class Eco.FrameworkImpl.Ocl.GreaterLesserAbstract : OclOperationBase {
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
private bool <PSSubset>k__BackingField;
    public bool PSSubset { get; public set; }
    [CompilerGeneratedAttribute]
public void set_PSSubset(bool value);
    [CompilerGeneratedAttribute]
public bool get_PSSubset();
    public virtual void SemanticCheck(IOclOperationParameters oclParameters);
}
public interface Eco.FrameworkImpl.Ocl.IExtendedEval {
    public abstract virtual void SemanticCheckExtended(IOclOperationParameters oclParameters, OclEnvironment oclenv);
    public abstract virtual void EvaluateExtended(IOclOperationParameters oclParameters, Stack`1<OclVariableBinding> loopvars);
}
public interface Eco.FrameworkImpl.Ocl.IIsPassthroughUser {
}
public interface Eco.FrameworkImpl.Ocl.IShortCutArgument {
}
public class Eco.FrameworkImpl.Ocl.MDrivenWeekHelper : object {
    public static DateTime FirstDateOfWeekISO8601(int year, int weekOfYear);
    public static int GetIso8601WeekOfYear(DateTime time);
}
public abstract class Eco.FrameworkImpl.Ocl.Ocl__ListCopier : OclOperationBase {
    public virtual void Evaluate(IOclOperationParameters __Params);
}
public abstract class Eco.FrameworkImpl.Ocl.Ocl_AbstractCompare : OclOperationBase {
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
private bool <PSSubset>k__BackingField;
    public bool PSSubset { get; public set; }
    [CompilerGeneratedAttribute]
public void set_PSSubset(bool value);
    [CompilerGeneratedAttribute]
public bool get_PSSubset();
    protected bool CompareEnumLiterals(IOclOperationParameters __Params);
    protected bool CompareElements(IElement el1, IElement el2);
    protected bool CompareEquals(IOclOperationParameters __Params);
    public virtual void SemanticCheck(IOclOperationParameters oclParameters);
    public static void CheckComparableTypes(IOclOperationParameters oclParameters, bool PSSubset, IOclOperationSupport Support);
    public static void SpecialCheckValidityOfLiteral(TBoldOclNamedEnumLiteral boldOclNamedEnumLiteral, IOclValue p2);
}
public abstract class Eco.FrameworkImpl.Ocl.Ocl_AbstractOrder : OclOperationBase {
    public virtual void Evaluate(IOclOperationParameters __Params);
    public virtual void SemanticCheck(IOclOperationParameters oclParameters);
}
[EcoOclOperationResourcedHelpAttribute("Eco.Internal.BoldOclConst:OclHelpAllInstances")]
public class Eco.FrameworkImpl.Ocl.Ocl_AllInstances : OclOperationBase {
    protected virtual void Init();
    public virtual bool ResultIsReadOnly(Boolean[] Args);
    public virtual void Evaluate(IOclOperationParameters __Params);
}
[EcoOclOperationResourcedHelpAttribute("Like allinstances - but on a Versioned class the Time is used")]
public class Eco.FrameworkImpl.Ocl.Ocl_AllInstancesAtTime : OclOperationBase {
    protected virtual void Init();
    public virtual void Evaluate(IOclOperationParameters __Params);
}
[EcoOclOperationResourcedHelpAttribute("Eco.Internal.BoldOclConst:OclHelpAllLoadedObjects")]
public class Eco.FrameworkImpl.Ocl.Ocl_AllLoadedObjects : OclOperationBase {
    protected virtual void Init();
    public virtual void Evaluate(IOclOperationParameters __Params);
}
[EcoOclOperationResourcedHelpAttribute("Return names of all states in all state machines for this type")]
public class Eco.FrameworkImpl.Ocl.Ocl_AllStates : OclOperationBase {
    protected virtual void Init();
    public void AddRegion(IElementCollection List, IRegion r, IStateMachine sm);
    private void AddState(IElementCollection List, IState state, IStateMachine sm);
    public virtual void Evaluate(IOclOperationParameters __Params);
}
[EcoOclOperationResourcedHelpAttribute("Eco.Internal.BoldOclConst:OclHelpAllSubClasses")]
public class Eco.FrameworkImpl.Ocl.Ocl_AllSubClasses : OclOperationBase {
    protected virtual void Init();
    public void Evaluate_AddAllSubTypes(IElementCollection List, IClassifier Classifier);
    public virtual void Evaluate(IOclOperationParameters __Params);
}
[EcoOclOperationResourcedHelpAttribute("Eco.Internal.BoldOclConst:OclHelpAllSuperTypes")]
public class Eco.FrameworkImpl.Ocl.Ocl_AllSuperTypes : OclOperationBase {
    protected virtual void Init();
    public void Evaluate_AddAllSuperTypes(IElementCollection List, IClassifier Classifier);
    public virtual void Evaluate(IOclOperationParameters __Params);
}
[EcoOclOperationResourcedHelpAttribute("logical AND between to booleans")]
public class Eco.FrameworkImpl.Ocl.Ocl_and : OclOperationBase {
    protected virtual void Init();
    public virtual void Evaluate(IOclOperationParameters __Params);
}
[EcoOclOperationResourcedHelpAttribute("Eco.Internal.BoldOclConst:OclHelpAppend")]
public class Eco.FrameworkImpl.Ocl.Ocl_Append : OclOperationBase {
    protected virtual void Init();
    public virtual void Evaluate(IOclOperationParameters __Params);
}
[EcoOclOperationResourcedHelpAttribute("object.ApplyTaJson(viewmodelname,json) applies the json data as defined by the ViewModel. Removes objects in target that are not in input")]
public class Eco.FrameworkImpl.Ocl.Ocl_ApplyTaJson : OclOperationBase {
    protected virtual void Init();
    public virtual void Evaluate(IOclOperationParameters __Params);
}
[EcoOclOperationResourcedHelpAttribute("Eco.Internal.BoldOclConst:OclHelpAsBag")]
public class Eco.FrameworkImpl.Ocl.Ocl_AsBag : Ocl__ListCopier {
    protected virtual void Init();
}
[EcoOclOperationResourcedHelpAttribute("Eco.Internal.BoldOclConst:OclHelpAsOrderedSet")]
public class Eco.FrameworkImpl.Ocl.Ocl_AsOrderedSet : Ocl__ListCopier {
    protected virtual void Init();
}
[EcoOclOperationResourcedHelpAttribute("Eco.Internal.BoldOclConst:OclHelpAsSequence")]
public class Eco.FrameworkImpl.Ocl.Ocl_AsSequence : Ocl__ListCopier {
    protected virtual void Init();
}
[EcoOclOperationResourcedHelpAttribute("Eco.Internal.BoldOclConst:OclHelpAsSet")]
public class Eco.FrameworkImpl.Ocl.Ocl_AsSet : Ocl__ListCopier {
    protected virtual void Init();
}
[EcoOclOperationResourcedHelpAttribute("Eco.Internal.BoldOclConst:OclHelpAssociationEnds")]
public class Eco.FrameworkImpl.Ocl.Ocl_AssociationEnds : OclOperationBase {
    protected virtual void Init();
    public virtual void Evaluate(IOclOperationParameters __Params);
}
[EcoOclOperationResourcedHelpAttribute("Returns the associationend:nameOfOtherSide:ClassOfOtherSide:IsSingle")]
public class Eco.FrameworkImpl.Ocl.Ocl_AssociationEndsWithType : OclOperationBase {
    protected virtual void Init();
    public virtual void Evaluate(IOclOperationParameters __Params);
}
[EcoOclOperationResourcedHelpAttribute("Eco.Internal.BoldOclConst:OclHelpasString")]
public class Eco.FrameworkImpl.Ocl.Ocl_asString : OclOperationBase {
    protected virtual void Init();
    public virtual void Evaluate(IOclOperationParameters __Params);
}
[EcoOclOperationResourcedHelpAttribute("object.AsTaJson(viewmodelname,skipempties) returns a json string defined by the ViewModel")]
public class Eco.FrameworkImpl.Ocl.Ocl_AsTaJson : OclOperationBase {
    protected virtual void Init();
    public virtual void Evaluate(IOclOperationParameters __Params);
}
[EcoOclOperationResourcedHelpAttribute("Eco.Internal.BoldOclConst:OclHelpat")]
public class Eco.FrameworkImpl.Ocl.Ocl_at : OclOperationBase {
    protected virtual void Init();
    public virtual void Evaluate(IOclOperationParameters __Params);
}
[EcoOclOperationResourcedHelpAttribute("Eco.Internal.BoldOclConst:OclHelpAtTime")]
public class Eco.FrameworkImpl.Ocl.Ocl_AtTime : OclOperationBase {
    protected virtual void Init();
    public virtual void Evaluate(IOclOperationParameters __Params);
}
[EcoOclOperationResourcedHelpAttribute("Eco.Internal.BoldOclConst:OclHelpAttributes")]
public class Eco.FrameworkImpl.Ocl.Ocl_Attributes : OclOperationBase {
    protected virtual void Init();
    public virtual void Evaluate(IOclOperationParameters __Params);
}
[EcoOclOperationResourcedHelpAttribute("base.SomeCall()  calls overriden implementation of base class ")]
public class Eco.FrameworkImpl.Ocl.Ocl_Base : OclOperationBase {
    protected virtual void Init();
    public virtual IOclType CalculateReturnType(IOclOperationParameters oclParameters);
    public virtual void Evaluate(IOclOperationParameters __Params);
}
public class Eco.FrameworkImpl.Ocl.Ocl_BrokenConstraints : OclOperationBase {
    protected virtual void Init();
    private void AddConstraintsOfClassAndSuperClasses(IOclOperationParameters __Params, IElementCollection ResList, IObjectInstance Subject, IClass ClassTypeInfo, SubscriberPair Subscribers);
    public virtual void Evaluate(IOclOperationParameters __Params);
}
[EcoOclOperationResourcedHelpAttribute("canAccess(nameOfViewModel)  check viewmodels Access expression for root  ")]
public class Eco.FrameworkImpl.Ocl.Ocl_CanAccess : OclOperationBase {
    protected virtual void Init();
    public virtual void Evaluate(IOclOperationParameters __Params);
}
[EcoOclOperationResourcedHelpAttribute("same as if-statement but more compact and more inline")]
public class Eco.FrameworkImpl.Ocl.Ocl_CaseTrueFalse : OclOperationBase {
    protected virtual void Init();
    public virtual bool ResultIsReadOnly(Boolean[] Args);
    public virtual void Evaluate(IOclOperationParameters __Params);
}
[EcoOclOperationResourcedHelpAttribute("ChangePoints gives back versioned objects from timestamp start to stop - -1 in stop means int.maxvalue means end of time")]
public class Eco.FrameworkImpl.Ocl.Ocl_ChangePoints : OclOperationBase {
    protected virtual void Init();
    public virtual void Evaluate(IOclOperationParameters __Params);
}
[EcoOclOperationResourcedHelpAttribute("Given a string - looks up the Class as oclType")]
public class Eco.FrameworkImpl.Ocl.Ocl_ClassFromString : OclOperationBase {
    protected virtual void Init();
    public virtual IOclType CalculateReturnType(IOclOperationParameters oclParameters);
    private void GetClassifierAndSetAsRef(IOclOperationParameters oclParameters);
    public virtual void Evaluate(IOclOperationParameters __Params);
    public virtual void SemanticCheck(IOclOperationParameters oclParameters);
}
[EcoOclOperationResourcedHelpAttribute("Eco.Internal.BoldOclConst:OclHelpcollect")]
public class Eco.FrameworkImpl.Ocl.Ocl_collect : Ocl_TupleOperation {
    protected virtual void Init();
    public virtual void Evaluate(IOclOperationParameters __Params);
    public virtual IOclType CalculateReturnType(IOclOperationParameters oclParameters);
}
[EcoOclOperationResourcedHelpAttribute("Eco.Internal.BoldOclConst:OclHelpconcat")]
public class Eco.FrameworkImpl.Ocl.Ocl_concat : OclOperationBase {
    protected virtual void Init();
    public virtual void Evaluate(IOclOperationParameters __Params);
}
[EcoOclOperationResourcedHelpAttribute("Returns a tuple with information on all constraints on this object - including if it is broken")]
public class Eco.FrameworkImpl.Ocl.Ocl_Constraints : Ocl_TupleOperation {
    protected virtual void Init();
    public virtual bool ResultIsReadOnly(Boolean[] Args);
    private void AddConstraintsOfClassAndSuperClasses(IOclOperationParameters __Params, IElementCollection ResList, IObjectInstance Subject, IClass ClassTypeInfo, SubscriberPair Subscribers);
    public virtual void Evaluate(IOclOperationParameters __Params);
    public virtual IOclType CalculateReturnType(IOclOperationParameters oclParameters);
}
[EcoOclOperationResourcedHelpAttribute("Eco.Internal.BoldOclConst:OclHelpCount")]
public class Eco.FrameworkImpl.Ocl.Ocl_Count : OclOperationBase {
    protected virtual void Init();
    public virtual void Evaluate(IOclOperationParameters __Params);
}
[EcoOclOperationResourcedHelpAttribute("Eco.Internal.BoldOclConst:OclHelpCreate")]
public class Eco.FrameworkImpl.Ocl.Ocl_Create : OclOperationBase {
    protected virtual void Init();
    public virtual void Evaluate(IOclOperationParameters __Params);
}
[EcoOclOperationResourcedHelpAttribute("object.deepclone(viewmodelname) returns a deepclone copy of the object - viewmodel decide copy depth")]
public class Eco.FrameworkImpl.Ocl.Ocl_DeepClone : OclOperationBase {
    protected virtual void Init();
    public virtual void Evaluate(IOclOperationParameters __Params);
}
[EcoOclOperationResourcedHelpAttribute("Eco.Internal.BoldOclConst:OclHelpDelete")]
public class Eco.FrameworkImpl.Ocl.Ocl_Delete : OclOperationBase {
    protected virtual void Init();
    public virtual void Evaluate(IOclOperationParameters __Params);
}
[EcoOclOperationResourcedHelpAttribute("Dictionary builds a dictionary on the first argument, and access values matching second argument ")]
public class Eco.FrameworkImpl.Ocl.Ocl_dictionary : Ocl_TupleOperation {
    protected virtual void Init();
    public virtual void Evaluate(IOclOperationParameters __Params);
}
[EcoOclOperationResourcedHelpAttribute("Eco.Internal.BoldOclConst:OclHelpdifference")]
public class Eco.FrameworkImpl.Ocl.Ocl_difference : OclOperationBase {
    protected virtual void Init();
    public virtual void Evaluate(IOclOperationParameters __Params);
}
[EcoOclOperationResourcedHelpAttribute("DiscardChanges will discard any changes currently existing on any object in the supplied list")]
public class Eco.FrameworkImpl.Ocl.Ocl_DiscardChanges : OclOperationBase {
    protected virtual void Init();
    public virtual void Evaluate(IOclOperationParameters __Params);
}
[EcoOclOperationResourcedHelpAttribute("Integer division")]
public class Eco.FrameworkImpl.Ocl.Ocl_Div : OclOperationBase {
    protected virtual void Init();
    public virtual void Evaluate(IOclOperationParameters __Params);
}
[EcoOclOperationResourcedHelpAttribute("Eco.Internal.BoldOclConst:OclHelpEmptyList")]
public class Eco.FrameworkImpl.Ocl.Ocl_EmptyList : OclOperationBase {
    protected virtual void Init();
    public virtual void Evaluate(IOclOperationParameters __Params);
}
public class Eco.FrameworkImpl.Ocl.Ocl_EndsWith : OclPsOperationBase {
    protected virtual void Init();
}
public class Eco.FrameworkImpl.Ocl.Ocl_Equal : Ocl_AbstractCompare {
    protected virtual void Init();
    public virtual void Evaluate(IOclOperationParameters __Params);
}
[EcoOclOperationResourcedHelpAttribute("Eco.Internal.BoldOclConst:OclHelpexcluding")]
public class Eco.FrameworkImpl.Ocl.Ocl_excluding : OclOperationBase {
    protected virtual void Init();
    public virtual void Evaluate(IOclOperationParameters __Params);
}
[EcoOclOperationResourcedHelpAttribute("Eco.Internal.BoldOclConst:OclHelpExisting")]
public class Eco.FrameworkImpl.Ocl.Ocl_Existing : OclOperationBase {
    protected virtual void Init();
    public virtual void Evaluate(IOclOperationParameters __Params);
}
[EcoOclOperationResourcedHelpAttribute("Eco.Internal.BoldOclConst:OclHelpExists")]
public class Eco.FrameworkImpl.Ocl.Ocl_Exists : OclOperationBase {
    protected virtual void Init();
    public virtual void Evaluate(IOclOperationParameters __Params);
}
[EcoOclOperationResourcedHelpAttribute("Eco.Internal.BoldOclConst:OclHelpExternalId")]
public class Eco.FrameworkImpl.Ocl.Ocl_ExternalId : OclOperationBase {
    protected virtual void Init();
    public virtual void Evaluate(IOclOperationParameters __Params);
}
[EcoOclOperationResourcedHelpAttribute("Eco.Internal.BoldOclConst:OclHelpFilterOnType")]
public class Eco.FrameworkImpl.Ocl.Ocl_FilterOnType : OclOperationBase {
    protected virtual void Init();
    public virtual void Evaluate(IOclOperationParameters __Params);
}
[EcoOclOperationResourcedHelpAttribute("Eco.Internal.BoldOclConst:OclHelpfirst")]
public class Eco.FrameworkImpl.Ocl.Ocl_first : OclOperationBase {
    protected virtual void Init();
    public virtual void Evaluate(IOclOperationParameters __Params);
}
[EcoOclOperationResourcedHelpAttribute("Eco.Internal.BoldOclConst:OclHelpForAll")]
public class Eco.FrameworkImpl.Ocl.Ocl_ForAll : OclOperationBase {
    protected virtual void Init();
    public virtual void Evaluate(IOclOperationParameters __Params);
}
[EcoOclOperationResourcedHelpAttribute("Foreach iterates a collection and returns the collection untransformed")]
public class Eco.FrameworkImpl.Ocl.Ocl_foreach : Ocl_TupleOperation {
    protected virtual void Init();
    public virtual void SemanticCheck(IOclOperationParameters oclParameters);
    public virtual void Evaluate(IOclOperationParameters __Params);
}
[EcoOclOperationResourcedHelpAttribute("calls .net System.String.Format")]
public class Eco.FrameworkImpl.Ocl.Ocl_Format : OclOperationBase {
    protected virtual void Init();
    public virtual void Evaluate(IOclOperationParameters __Params);
}
[EcoOclOperationResourcedHelpAttribute("Eco.Internal.BoldOclConst:OclHelpFormatDateTime")]
public class Eco.FrameworkImpl.Ocl.Ocl_FormatDateTime : OclOperationBase {
    protected virtual void Init();
    public virtual void Evaluate(IOclOperationParameters __Params);
}
public class Eco.FrameworkImpl.Ocl.Ocl_Greater : GreaterLesserAbstract {
    protected virtual void Init();
    public virtual void Evaluate(IOclOperationParameters __Params);
}
public class Eco.FrameworkImpl.Ocl.Ocl_GreaterEQ : GreaterLesserAbstract {
    protected virtual void Init();
    public virtual void Evaluate(IOclOperationParameters __Params);
}
[EcoOclOperationResourcedHelpAttribute("Like collect but creates tuple for matching attributes and a list of all incomming of that match")]
public class Eco.FrameworkImpl.Ocl.Ocl_GroupBy : Ocl_TupleOperation {
    protected virtual void Init();
    public virtual IOclType CalculateReturnType(IOclOperationParameters oclParameters);
    public virtual void Evaluate(IOclOperationParameters __Params);
}
[EcoOclOperationResourcedHelpAttribute("if statement: if boolean then expression1 else expression2 endif , note expression1 and 2 must result in same type")]
public class Eco.FrameworkImpl.Ocl.Ocl_if : OclOperationBase {
    protected virtual void Init();
    public virtual bool ResultIsReadOnly(Boolean[] Args);
    public virtual void Evaluate(IOclOperationParameters __Params);
}
[EcoOclOperationResourcedHelpAttribute("Eco.Internal.BoldOclConst:OclHelpimplies")]
public class Eco.FrameworkImpl.Ocl.Ocl_implies : OclOperationBase {
    protected virtual void Init();
    public virtual void Evaluate(IOclOperationParameters __Params);
}
[EcoOclOperationResourcedHelpAttribute("Eco.Internal.BoldOclConst:OclHelpincludes")]
public class Eco.FrameworkImpl.Ocl.Ocl_includes : OclOperationBase {
    protected virtual void Init();
    public virtual void Evaluate(IOclOperationParameters __Params);
}
[EcoOclOperationResourcedHelpAttribute("Eco.Internal.BoldOclConst:OclHelpIncludesAll")]
public class Eco.FrameworkImpl.Ocl.Ocl_IncludesAll : OclOperationBase {
    protected virtual void Init();
    public virtual void Evaluate(IOclOperationParameters __Params);
}
[EcoOclOperationResourcedHelpAttribute("Eco.Internal.BoldOclConst:OclHelpIncluding")]
public class Eco.FrameworkImpl.Ocl.Ocl_Including : OclOperationBase {
    protected virtual void Init();
    public virtual void Evaluate(IOclOperationParameters __Params);
}
[EcoOclOperationResourcedHelpAttribute("Eco.Internal.BoldOclConst:OclHelpindexOf")]
public class Eco.FrameworkImpl.Ocl.Ocl_IndexOf : OclOperationBase {
    protected virtual void Init();
    public virtual void Evaluate(IOclOperationParameters __Params);
}
[EcoOclOperationResourcedHelpAttribute("Eco.Internal.BoldOclConst:OclHelpIntersection")]
public class Eco.FrameworkImpl.Ocl.Ocl_Intersection : OclOperationBase {
    protected virtual void Init();
    public virtual void Evaluate(IOclOperationParameters __Params);
}
[EcoOclOperationResourcedHelpAttribute("Returns true if object is touched and unsaved")]
public class Eco.FrameworkImpl.Ocl.Ocl_IsDirty : OclOperationBase {
    protected virtual void Init();
    public virtual void Evaluate(IOclOperationParameters __Params);
}
[EcoOclOperationResourcedHelpAttribute("Does this member contained unsaved changes")]
public class Eco.FrameworkImpl.Ocl.Ocl_IsDirtyMember : OclOperationBase {
    protected virtual void Init();
    public virtual void SemanticCheck(IOclOperationParameters oclParameters);
    public virtual void Evaluate(IOclOperationParameters __Params);
}
[EcoOclOperationResourcedHelpAttribute("Eco.Internal.BoldOclConst:OclHelpisEmpty")]
public class Eco.FrameworkImpl.Ocl.Ocl_isEmpty : OclOperationBase {
    protected virtual void Init();
    public virtual void Evaluate(IOclOperationParameters __Params);
}
[EcoOclOperationResourcedHelpAttribute("Returns true if this object has not been saved (yet)")]
public class Eco.FrameworkImpl.Ocl.Ocl_IsNew : OclOperationBase {
    protected virtual void Init();
    public virtual void Evaluate(IOclOperationParameters __Params);
}
[EcoOclOperationResourcedHelpAttribute("Eco.Internal.BoldOclConst:OclHelpisNull")]
public class Eco.FrameworkImpl.Ocl.Ocl_isNull : OclOperationBase {
    protected virtual void Init();
    public virtual void Evaluate(IOclOperationParameters __Params);
}
[EcoOclOperationResourcedHelpAttribute("string.JsonGetProp('propname') returns value of prop (if found) as string")]
public class Eco.FrameworkImpl.Ocl.Ocl_JsonGetProp : OclOperationBase {
    protected virtual void Init();
    public virtual void Evaluate(IOclOperationParameters __Params);
}
[EcoOclOperationResourcedHelpAttribute("Eco.Internal.BoldOclConst:OclHelplast")]
public class Eco.FrameworkImpl.Ocl.Ocl_last : OclOperationBase {
    protected virtual void Init();
    public virtual void Evaluate(IOclOperationParameters __Params);
}
[EcoOclOperationResourcedHelpAttribute("Eco.Internal.BoldOclConst:OclHelpLength")]
public class Eco.FrameworkImpl.Ocl.Ocl_Length : OclPsOperationBase {
    protected virtual void Init();
}
public class Eco.FrameworkImpl.Ocl.Ocl_Less : GreaterLesserAbstract {
    protected virtual void Init();
    public virtual void Evaluate(IOclOperationParameters __Params);
}
public class Eco.FrameworkImpl.Ocl.Ocl_LessEQ : GreaterLesserAbstract {
    protected virtual void Init();
    public virtual void Evaluate(IOclOperationParameters __Params);
}
[EcoOclOperationResourcedHelpAttribute("Eco.Internal.BoldOclConst:OclHelpLet")]
public class Eco.FrameworkImpl.Ocl.Ocl_Let : OclOperationBase {
    protected virtual void Init();
    public virtual void Evaluate(IOclOperationParameters __Params);
}
[EcoOclOperationResourcedHelpAttribute("Eco.Internal.BoldOclConst:OclHelpListAdd")]
public class Eco.FrameworkImpl.Ocl.Ocl_ListAdd : OclOperationBase {
    protected virtual void Init();
    public virtual void Evaluate(IOclOperationParameters __Params);
    public virtual void SemanticCheck(IOclOperationParameters __Params);
    public static void CheckListSemanticTypes(IOclValue oclValueTheList, IOclValue oclValueTheArgument);
}
[EcoOclOperationResourcedHelpAttribute("addReturnIndexOf0 is like a normal Add - but returns the zero based position the object in the list")]
public class Eco.FrameworkImpl.Ocl.Ocl_ListAddReturnIndexOf0 : OclOperationBase {
    protected virtual void Init();
    public virtual void Evaluate(IOclOperationParameters __Params);
    public virtual void SemanticCheck(IOclOperationParameters __Params);
    public static void CheckListSemanticTypes(IOclValue oclValueTheList, IOclValue oclValueTheArgument);
}
[EcoOclOperationResourcedHelpAttribute("Eco.Internal.BoldOclConst:OclHelpListClear")]
public class Eco.FrameworkImpl.Ocl.Ocl_ListClear : OclOperationBase {
    protected virtual void Init();
    public virtual void Evaluate(IOclOperationParameters __Params);
}
[EcoOclOperationResourcedHelpAttribute("Inserts element at given position in list")]
public class Eco.FrameworkImpl.Ocl.Ocl_ListInsertAt : OclOperationBase {
    protected virtual void Init();
    public virtual void Evaluate(IOclOperationParameters __Params);
    public virtual void SemanticCheck(IOclOperationParameters __Params);
}
[EcoOclOperationResourcedHelpAttribute("Eco.Internal.BoldOclConst:OclHelpListRemove")]
public class Eco.FrameworkImpl.Ocl.Ocl_ListRemove : OclOperationBase {
    protected virtual void Init();
    public virtual void Evaluate(IOclOperationParameters __Params);
    public virtual void SemanticCheck(IOclOperationParameters __Params);
}
[EcoOclOperationResourcedHelpAttribute("Eco.Internal.BoldOclConst:OclHelpListRemoveAt")]
public class Eco.FrameworkImpl.Ocl.Ocl_ListRemoveAt : OclOperationBase {
    protected virtual void Init();
    public virtual void Evaluate(IOclOperationParameters __Params);
}
[EcoOclOperationResourcedHelpAttribute("Eco.Internal.BoldOclConst:OclHelpMaxLength")]
public class Eco.FrameworkImpl.Ocl.Ocl_MaxLength : OclOperationBase {
    protected virtual void Init();
    public virtual void Evaluate(IOclOperationParameters __Params);
}
[EcoOclOperationResourcedHelpAttribute("object.MergeTaJson(viewmodelname,json) applies the json data as defined by the ViewModel - does not remove objects missing in input but existing in target")]
public class Eco.FrameworkImpl.Ocl.Ocl_MergeTaJson : OclOperationBase {
    protected virtual void Init();
    public virtual void Evaluate(IOclOperationParameters __Params);
}
[EcoOclOperationResourcedHelpAttribute("Integer modulus with  a % b")]
public class Eco.FrameworkImpl.Ocl.Ocl_Mod : OclOperationBase {
    protected virtual void Init();
    public virtual void Evaluate(IOclOperationParameters __Params);
}
[EcoOclOperationResourcedHelpAttribute("logical NOT negates the boolean")]
public class Eco.FrameworkImpl.Ocl.Ocl_not : OclOperationBase {
    protected virtual void Init();
    public virtual void Evaluate(IOclOperationParameters __Params);
}
[EcoOclOperationResourcedHelpAttribute("Eco.Internal.BoldOclConst:OclHelpNotEmpty")]
public class Eco.FrameworkImpl.Ocl.Ocl_NotEmpty : OclOperationBase {
    protected virtual void Init();
    public virtual void Evaluate(IOclOperationParameters __Params);
}
public class Eco.FrameworkImpl.Ocl.Ocl_NotEqual : Ocl_AbstractCompare {
    protected virtual void Init();
    public virtual void Evaluate(IOclOperationParameters __Params);
}
[EcoOclOperationResourcedHelpAttribute("Eco.Internal.BoldOclConst:OclHelpisNull")]
public class Eco.FrameworkImpl.Ocl.Ocl_NotNull : OclOperationBase {
    protected virtual void Init();
    public virtual void Evaluate(IOclOperationParameters __Params);
}
[EcoOclOperationResourcedHelpAttribute("Returns a typed nullvalue")]
public class Eco.FrameworkImpl.Ocl.Ocl_NullValue : OclOperationBase {
    protected virtual void Init();
    public virtual void Evaluate(IOclOperationParameters __Params);
}
[EcoOclOperationResourcedHelpAttribute("Given an external id as string - looks up the object")]
public class Eco.FrameworkImpl.Ocl.Ocl_ObjectFromExternalId : OclOperationBase {
    protected virtual void Init();
    public virtual void Evaluate(IOclOperationParameters __Params);
}
[EcoOclOperationResourcedHelpAttribute("Eco.Internal.BoldOclConst:OclHelpObjectTimeStamp")]
public class Eco.FrameworkImpl.Ocl.Ocl_ObjectTimeStamp : OclOperationBase {
    protected virtual void Init();
    public virtual void Evaluate(IOclOperationParameters __Params);
}
[EcoOclOperationResourcedHelpAttribute("Eco.Internal.BoldOclConst:OclHelpOclAsType")]
public class Eco.FrameworkImpl.Ocl.Ocl_OclAsType : OclOperationBase {
    protected virtual void Init();
    public virtual void Evaluate(IOclOperationParameters __Params);
}
[EcoOclOperationResourcedHelpAttribute("Gives the collection type that can hold the context")]
public class Eco.FrameworkImpl.Ocl.Ocl_OclCollectionType : OclOperationBase {
    protected virtual void Init();
    public virtual void Evaluate(IOclOperationParameters __Params);
    public virtual void SemanticCheck(IOclOperationParameters oclParameters);
}
[EcoOclOperationResourcedHelpAttribute("Eco.Internal.BoldOclConst:OclHelpoclGetStates")]
public class Eco.FrameworkImpl.Ocl.Ocl_oclGetStates : OclOperationBase {
    protected virtual void Init();
    public virtual void Evaluate(IOclOperationParameters __Params);
}
[EcoOclOperationResourcedHelpAttribute("Eco.Internal.BoldOclConst:OclHelpoclGetTriggers")]
public class Eco.FrameworkImpl.Ocl.Ocl_oclGetTriggers : OclOperationBase {
    protected virtual void Init();
    public virtual void Evaluate(IOclOperationParameters __Params);
}
[EcoOclOperationResourcedHelpAttribute("Eco.Internal.BoldOclConst:OclHelpoclIsInState")]
public class Eco.FrameworkImpl.Ocl.Ocl_oclIsInState : OclOperationBase {
    protected virtual void Init();
    public virtual void SemanticCheck(IOclOperationParameters __Params);
    public virtual void Evaluate(IOclOperationParameters __Params);
}
[EcoOclOperationResourcedHelpAttribute("Eco.Internal.BoldOclConst:OclHelpoclIsKindOf")]
public class Eco.FrameworkImpl.Ocl.Ocl_oclIsKindOf : OclOperationBase {
    protected virtual void Init();
    public virtual void Evaluate(IOclOperationParameters __Params);
}
[EcoOclOperationResourcedHelpAttribute("Eco.Internal.BoldOclConst:OclHelpOclIsTypeOf")]
public class Eco.FrameworkImpl.Ocl.Ocl_OclIsTypeOf : OclOperationBase {
    protected virtual void Init();
    public virtual void Evaluate(IOclOperationParameters __Params);
}
[EcoOclOperationResourcedHelpAttribute("Returns(possibly also creates) the one instance for this class (Must be marked IsSingleton)")]
public class Eco.FrameworkImpl.Ocl.Ocl_oclSingleton : OclOperationBase {
    protected virtual void Init();
    public virtual void SemanticCheck(IOclOperationParameters oclParameters);
    public virtual void Evaluate(IOclOperationParameters oclParameters);
}
[EcoOclOperationResourcedHelpAttribute("Gives the type of the context")]
public class Eco.FrameworkImpl.Ocl.Ocl_OclType : OclOperationBase {
    protected virtual void Init();
    public virtual void Evaluate(IOclOperationParameters __Params);
    public virtual void SemanticCheck(IOclOperationParameters oclParameters);
}
[EcoOclOperationResourcedHelpAttribute("AccessGroupsEnable('ag1,ag2,ag3')  Checks if AccessGroup(s) says enable or not - 1 enable is enough for true")]
public class Eco.FrameworkImpl.Ocl.Ocl_OnViewModelReference_AccessGroupsEnable : OclOperationBase {
    protected virtual void Init();
    public virtual void Evaluate(IOclOperationParameters __Params);
}
[EcoOclOperationResourcedHelpAttribute("CanExecuteAction(nameofNesting,NameOfColumn)  Checks if you can Execute the action with ExecuteAction operator")]
public class Eco.FrameworkImpl.Ocl.Ocl_OnViewModelReference_CanExecuteAction : OclOperationBase {
    protected virtual void Init();
    public virtual void Evaluate(IOclOperationParameters __Params);
}
[EcoOclOperationResourcedHelpAttribute("Triggering a download of arbitrary byte array to client under a file name and file type, (filename,filetype,data)")]
public class Eco.FrameworkImpl.Ocl.Ocl_OnViewModelReference_Download : OclOperationBase {
    protected virtual void Init();
    public virtual void Evaluate(IOclOperationParameters __Params);
}
[EcoOclOperationResourcedHelpAttribute("ExecuteAction(nameofNesting,NameOfColumn)  Executes the action")]
public class Eco.FrameworkImpl.Ocl.Ocl_OnViewModelReference_ExecuteAction : OclOperationBase {
    protected virtual void Init();
    public virtual void Evaluate(IOclOperationParameters __Params);
}
[EcoOclOperationResourcedHelpAttribute("On Rest operations, if the call fails due to a stale accesstoken - then you get a new one and resume with this call in the Nesting from the onfail column")]
public class Eco.FrameworkImpl.Ocl.Ocl_OnViewModelReference_ExecuteCurrentActionAgainOnce : OclOperationBase {
    protected virtual void Init();
    public virtual void Evaluate(IOclOperationParameters __Params);
}
[EcoOclOperationResourcedHelpAttribute("ExecuteFetchHints(objectlist) executes the expressions found in any nesting starting with fetchhints and matches the type")]
public class Eco.FrameworkImpl.Ocl.Ocl_OnViewModelReference_ExecuteFetchHints : OclOperationBase {
    protected virtual void Init();
    public virtual void Evaluate(IOclOperationParameters __Params);
}
[EcoOclOperationResourcedHelpAttribute("ExecutePS(TYPEofresult,nestingname,columninnesting)  executes the expression in column and returns list of objects ")]
public class Eco.FrameworkImpl.Ocl.Ocl_OnViewModelReference_ExecutePS : OclOperationBase {
    protected virtual void Init();
    public virtual void Evaluate(IOclOperationParameters __Params);
}
[EcoOclOperationResourcedHelpAttribute("ExecuteQueryPlan executes the QueryPlan for effecient fetch - normally called automatically, but if you change roots with expressions you may trigger it")]
public class Eco.FrameworkImpl.Ocl.Ocl_OnViewModelReference_ExecuteQueryPlan : OclOperationBase {
    protected virtual void Init();
    public virtual void Evaluate(IOclOperationParameters __Params);
}
[EcoOclOperationResourcedHelpAttribute("The list of objects touched(changed, dirty) in the current scope")]
public class Eco.FrameworkImpl.Ocl.Ocl_OnViewModelReference_GetDirtyList : OclOperationBase {
    protected virtual void Init();
    public virtual IOclType CalculateReturnType(IOclOperationParameters oclParameters);
    public virtual void Evaluate(IOclOperationParameters __Params);
}
[EcoOclOperationResourcedHelpAttribute("GetGridAsTabSepData(theVMColumnThatDefinesGrid):string ")]
public class Eco.FrameworkImpl.Ocl.Ocl_OnViewModelReference_GetGridAsTabSepData : OclOperationBase {
    protected virtual void Init();
    public virtual void Evaluate(IOclOperationParameters __Params);
}
[EcoOclOperationResourcedHelpAttribute("ImportTabSepData will trigger import functionality using SearchExpressions in your ViewModel, use TabSeperated data, first column is key, if key not found by search CreatNew action will be executed if available, use readonly expression to control what columns to write")]
public class Eco.FrameworkImpl.Ocl.Ocl_OnViewModelReference_ImportTabSepData : OclOperationBase {
    protected virtual void Init();
    public virtual void Evaluate(IOclOperationParameters __Params);
}
[EcoOclOperationResourcedHelpAttribute("True if any objects touched(changed, dirty) in the current scope")]
public class Eco.FrameworkImpl.Ocl.Ocl_OnViewModelReference_IsDirty : OclOperationBase {
    protected virtual void Init();
    public virtual void Evaluate(IOclOperationParameters __Params);
}
[EcoOclOperationResourcedHelpAttribute("JSonToObjects(TYPE,stringwithjson)  Creates objects, tries to follow associations, sets attributes. The attribute RawJSon: String is treated special and receives all Json as a string")]
public class Eco.FrameworkImpl.Ocl.Ocl_OnViewModelReference_JSonToObjects : OclOperationBase {
    protected virtual void Init();
    public virtual void Evaluate(IOclOperationParameters __Params);
    public virtual IOclType CalculateReturnType(IOclOperationParameters oclParameters);
}
[EcoOclOperationResourcedHelpAttribute("ListActions(nameofNesting)  Lists available action")]
public class Eco.FrameworkImpl.Ocl.Ocl_OnViewModelReference_ListActions : OclOperationBase {
    protected virtual void Init();
    public virtual void Evaluate(IOclOperationParameters __Params);
    public virtual IOclType CalculateReturnType(IOclOperationParameters oclParameters);
}
[EcoOclOperationResourcedHelpAttribute("Navigate(rootobject,NameOfViewModel)  a pseudo action that can do only 1 thing - navigate to rooted viewmodel")]
public class Eco.FrameworkImpl.Ocl.Ocl_OnViewModelReference_Navigate : OclOperationBase {
    protected virtual void Init();
    public virtual void Evaluate(IOclOperationParameters __Params);
}
[EcoOclOperationResourcedHelpAttribute("NavigateUrl(theurl)  a action that allows you to change the target of the browser to any url in a new tab")]
public class Eco.FrameworkImpl.Ocl.Ocl_OnViewModelReference_NavigateUrl : OclOperationBase {
    protected virtual void Init();
    public virtual void Evaluate(IOclOperationParameters __Params);
}
[EcoOclOperationResourcedHelpAttribute("NavigateUrl(theurl,newtab) an action that allows you to change the target of the browser to any url")]
public class Eco.FrameworkImpl.Ocl.Ocl_OnViewModelReference_NavigateUrloverload : Ocl_OnViewModelReference_NavigateUrl {
    protected virtual void Init();
}
[EcoOclOperationResourcedHelpAttribute("Nestings is a tuple with all Nestings in the viewmodel including the top level")]
public class Eco.FrameworkImpl.Ocl.Ocl_OnViewModelReference_Nestings : OclOperationBase {
    protected virtual void Init();
    public virtual void Evaluate(IOclOperationParameters __Params);
    public virtual IOclType CalculateReturnTypeExtended(IOclOperationParameters __Params, object untypedOclEnv);
}
[EcoOclOperationResourcedHelpAttribute("PSExpression_Refresh  Loops thru columns starting with PSExpression_ and executes the expression - thus refreshing them")]
public class Eco.FrameworkImpl.Ocl.Ocl_OnViewModelReference_PSExpression_Refresh : OclOperationBase {
    protected virtual void Init();
    public virtual void Evaluate(IOclOperationParameters __Params);
}
[EcoOclOperationResourcedHelpAttribute("In a persistent system this will ask persistenceserver for changes we have yet to see")]
public class Eco.FrameworkImpl.Ocl.Ocl_OnViewModelReference_Refresh : OclOperationBase {
    protected virtual void Init();
    public virtual void Evaluate(IOclOperationParameters __Params);
}
[EcoOclOperationResourcedHelpAttribute("RemoteTurnkeyCloseSession(sessionid):status")]
public class Eco.FrameworkImpl.Ocl.Ocl_OnViewModelReference_RemoteTurnkeyCloseSession : OclOperationBase {
    protected virtual void Init();
    public virtual void Evaluate(IOclOperationParameters __Params);
}
[EcoOclOperationResourcedHelpAttribute("RemoteTurnkeyConnectGetSessionKey(urlToTurnkey,user,pwd):status")]
public class Eco.FrameworkImpl.Ocl.Ocl_OnViewModelReference_RemoteTurnkeyConnectGetSessionKey : OclOperationBase {
    protected virtual void Init();
    public virtual void Evaluate(IOclOperationParameters __Params);
}
[EcoOclOperationResourcedHelpAttribute("RemoteTurnkeyExecuteAction(sessionid,vmclassid,action)  , note that 'GLOBAL.Save' will do Save action of remote ")]
public class Eco.FrameworkImpl.Ocl.Ocl_OnViewModelReference_RemoteTurnkeyExecuteAction : OclOperationBase {
    protected virtual void Init();
    public virtual void Evaluate(IOclOperationParameters __Params);
}
[EcoOclOperationResourcedHelpAttribute("RemoteTurnkeyGetByteArray(sessionid,vmclassid,column):result")]
public class Eco.FrameworkImpl.Ocl.Ocl_OnViewModelReference_RemoteTurnkeyGetByteArray : OclOperationBase {
    protected virtual void Init();
    public virtual void Evaluate(IOclOperationParameters __Params);
}
[EcoOclOperationResourcedHelpAttribute("RemoteTurnkeyGetStringValue(sessionid,vmclassid,column):result")]
public class Eco.FrameworkImpl.Ocl.Ocl_OnViewModelReference_RemoteTurnkeyGetStringValue : OclOperationBase {
    protected virtual void Init();
    public virtual void Evaluate(IOclOperationParameters __Params);
}
[EcoOclOperationResourcedHelpAttribute("RemoteTurnkeySetByteArray(sessionid,vmclassid,column,blobvaluetoset):status")]
public class Eco.FrameworkImpl.Ocl.Ocl_OnViewModelReference_RemoteTurnkeySetByteArray : OclOperationBase {
    protected virtual void Init();
    public virtual void Evaluate(IOclOperationParameters __Params);
}
[EcoOclOperationResourcedHelpAttribute("RemoteTurnkeySetStringValue(sessionid,vmclassid,column,valuetoset):status")]
public class Eco.FrameworkImpl.Ocl.Ocl_OnViewModelReference_RemoteTurnkeySetStringValue : OclOperationBase {
    protected virtual void Init();
    public virtual void Evaluate(IOclOperationParameters __Params);
}
[EcoOclOperationResourcedHelpAttribute("ReQuery will search again (without moving to the next expression) in your ViewModel and populate vSeekerResult")]
public class Eco.FrameworkImpl.Ocl.Ocl_OnViewModelReference_ReQuery : OclOperationBase {
    protected virtual void Init();
    public virtual void Evaluate(IOclOperationParameters __Params);
}
[EcoOclOperationResourcedHelpAttribute("RestDelete(targeturl,user,pwd,nameofnesting)  returns a string type, HEADER_aaa columns in nesting will set header of name aaa in request")]
public class Eco.FrameworkImpl.Ocl.Ocl_OnViewModelReference_RestDelete : OclOperationBase {
    protected virtual void Init();
    public virtual void Evaluate(IOclOperationParameters __Params);
}
[EcoOclOperationResourcedHelpAttribute("RestDownload(targeturl,user,pwd,nameofnesting)  returns a blob type")]
public class Eco.FrameworkImpl.Ocl.Ocl_OnViewModelReference_RestDownload : OclOperationBase {
    protected virtual void Init();
    public virtual void Evaluate(IOclOperationParameters __Params);
}
[EcoOclOperationResourcedHelpAttribute("RestGet(targeturl,user,pwd,nameofnesting)  returns a string type, HEADER_aaa columns in nesting will set header of name aaa in request")]
public class Eco.FrameworkImpl.Ocl.Ocl_OnViewModelReference_RestGet : OclOperationBase {
    protected virtual void Init();
    public virtual void Evaluate(IOclOperationParameters __Params);
}
[EcoOclOperationResourcedHelpAttribute("RestPatch(targeturl,user,pwd,nameofnesting)  patch data to url - adds data in nesting, FILENAME_aaa will upload aaa column with filename from FILENAME_aaa")]
public class Eco.FrameworkImpl.Ocl.Ocl_OnViewModelReference_RestPatch : OclOperationBase {
    protected virtual void Init();
    public virtual void Evaluate(IOclOperationParameters __Params);
}
[EcoOclOperationResourcedHelpAttribute("RestPost(targeturl,user,pwd,nameofnesting)  posts data to url - adds data in nesting, FILENAME_aaa will upload aaa column with filename from FILENAME_aaa")]
public class Eco.FrameworkImpl.Ocl.Ocl_OnViewModelReference_RestPost : OclOperationBase {
    protected virtual void Init();
    public virtual void Evaluate(IOclOperationParameters __Params);
}
[EcoOclOperationResourcedHelpAttribute("RestPut(targeturl,user,pwd,nameofnesting)  posts data to url - adds data in nesting, FILENAME_aaa will upload aaa column with filename from FILENAME_aaa")]
public class Eco.FrameworkImpl.Ocl.Ocl_OnViewModelReference_RestPut : OclOperationBase {
    protected virtual void Init();
    public virtual void Evaluate(IOclOperationParameters __Params);
}
[EcoOclOperationResourcedHelpAttribute("Return RootObject of view - this is readonly")]
public class Eco.FrameworkImpl.Ocl.Ocl_OnViewModelReference_RootObject : OclOperationBase {
    protected virtual void Init();
    public virtual void Evaluate(IOclOperationParameters __Params);
    public virtual IOclType CalculateReturnType(IOclOperationParameters __Params);
}
[EcoOclOperationResourcedHelpAttribute("RunServerSideViewModelNow - ServerSideViewModels run periodically - but this call can force early execution of named Server side viewmodel")]
public class Eco.FrameworkImpl.Ocl.Ocl_OnViewModelReference_RunServerSideViewModelNow : OclOperationBase {
    protected virtual void Init();
    public virtual void Evaluate(IOclOperationParameters __Params);
}
[EcoOclOperationResourcedHelpAttribute("Save commits changes done in this viewmodel to db/persistent storage")]
public class Eco.FrameworkImpl.Ocl.Ocl_OnViewModelReference_Save : OclOperationBase {
    protected virtual void Init();
    public virtual void Evaluate(IOclOperationParameters __Params);
}
[EcoOclOperationResourcedHelpAttribute("SaveToFile(filename,data)  save to a file on the machine that execute this")]
public class Eco.FrameworkImpl.Ocl.Ocl_OnViewModelReference_SaveToFile : OclOperationBase {
    protected virtual void Init();
    public virtual void Evaluate(IOclOperationParameters __Params);
}
[EcoOclOperationResourcedHelpAttribute("Search will trigger search functionality using SearchExpressions in your ViewModel and populate vSeekerResult")]
public class Eco.FrameworkImpl.Ocl.Ocl_OnViewModelReference_Search : OclOperationBase {
    protected virtual void Init();
    public virtual void Evaluate(IOclOperationParameters __Params);
}
[EcoOclOperationResourcedHelpAttribute("ShowActionMenuForCurrentInNesting(nameofNesting)  brings up action menu for the vCurrent of given Nesting")]
public class Eco.FrameworkImpl.Ocl.Ocl_OnViewModelReference_ShowActionMenuForCurrentInNesting : OclOperationBase {
    protected virtual void Init();
    public virtual void Evaluate(IOclOperationParameters __Params);
}
[EcoOclOperationResourcedHelpAttribute("SoapCall(targeturl,action,actionnamespace, user, pwd, nestingWithParams,passwordDigest,SOAPAction)
Calls Soap actionnamespace:action on targeturl - with params found in nesting - user and pwd are needed if the Soap service require them. 
PasswordDigest - if pwd is sent as clear text or if nonce createtime and hash is used
SOAPAction - the SOAPAction header attribute value ")]
public class Eco.FrameworkImpl.Ocl.Ocl_OnViewModelReference_SoapCall : OclOperationBase {
    protected virtual void Init();
    public virtual void Evaluate(IOclOperationParameters __Params);
}
[EcoOclOperationResourcedHelpAttribute("Lists all styles seen in StylesInModel")]
public class Eco.FrameworkImpl.Ocl.Ocl_OnViewModelReference_Styles : OclOperationBase {
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
private static EventHandler`1<OnStylesInModelAccessArgs> OnDesignTimeStylesInModelAccess;
    protected virtual void Init();
    public virtual void Evaluate(IOclOperationParameters __Params);
    [CompilerGeneratedAttribute]
public static void add_OnDesignTimeStylesInModelAccess(EventHandler`1<OnStylesInModelAccessArgs> value);
    [CompilerGeneratedAttribute]
public static void remove_OnDesignTimeStylesInModelAccess(EventHandler`1<OnStylesInModelAccessArgs> value);
    public virtual IOclType CalculateReturnTypeExtended(IOclOperationParameters oclParameters, object untypedOclEnv);
}
[EcoOclOperationResourcedHelpAttribute("SuspectExternalUpdateInvalidate - if your server support Refresh - when you suspect 3-party write to db-row call this to signal all clients to reread on refresh")]
public class Eco.FrameworkImpl.Ocl.Ocl_OnViewModelReference_SuspectExternalUpdateInvalidate : OclOperationBase {
    protected virtual void Init();
    public virtual void Evaluate(IOclOperationParameters __Params);
}
[EcoOclOperationResourcedHelpAttribute("Using the SysDocBatch -* SysDoc model pattern - you can Zip all SysDoc into a bytearray")]
public class Eco.FrameworkImpl.Ocl.Ocl_OnViewModelReference_SysDocBatchZip : OclOperationBase {
    protected virtual void Init();
    public virtual void Evaluate(IOclOperationParameters __Params);
    public virtual void SemanticCheck(IOclOperationParameters oclParameters);
}
[EcoOclOperationResourcedHelpAttribute("ViewModelAsJSon(ViewmodelName,rootObject):string  Returns the ViewModel content as a Json formatted string")]
public class Eco.FrameworkImpl.Ocl.Ocl_OnViewModelReference_ViewModelAsJSon : OclOperationBase {
    protected virtual void Init();
    public virtual void Evaluate(IOclOperationParameters __Params);
}
[EcoOclOperationResourcedHelpAttribute("ViewModelAsXml(viewModelName,objectroot)  expands viewmodel as xml")]
public class Eco.FrameworkImpl.Ocl.Ocl_OnViewModelReference_ViewModelAsXml : OclOperationBase {
    protected virtual void Init();
    public virtual void Evaluate(IOclOperationParameters __Params);
}
[EcoOclOperationResourcedHelpAttribute("ViewModelName returns the name of the this ViewModel")]
public class Eco.FrameworkImpl.Ocl.Ocl_OnViewModelReference_ViewModelName : OclOperationBase {
    protected virtual void Init();
    public virtual void Evaluate(IOclOperationParameters __Params);
}
[EcoOclOperationResourcedHelpAttribute("XmlToObjects(TYPE,stringwithjson)  First converts Xml to Json with Newtonsoft.Json.JsonConvert.SerializeXmlNode(doc) Creates objects, tries to follow associations, sets attributes")]
public class Eco.FrameworkImpl.Ocl.Ocl_OnViewModelReference_XmlToObjects : OclOperationBase {
    protected virtual void Init();
    public virtual void Evaluate(IOclOperationParameters __Params);
    public virtual IOclType CalculateReturnType(IOclOperationParameters oclParameters);
}
[EcoOclOperationResourcedHelpAttribute("XmlValidateWithSchemas(xmlstring,collection(strings with urls to schemas))  Validates xml according to schemas - returns list of violations")]
public class Eco.FrameworkImpl.Ocl.Ocl_OnViewModelReference_XmlValidateWithSchema : OclOperationBase {
    protected virtual void Init();
    public virtual void Evaluate(IOclOperationParameters __Params);
}
[EcoOclOperationResourcedHelpAttribute("XsltTransformXml(xsltstring,xmlstring)  transforms xml")]
public class Eco.FrameworkImpl.Ocl.Ocl_OnViewModelReference_XsltTransformXml : OclOperationBase {
    protected virtual void Init();
    public virtual void Evaluate(IOclOperationParameters __Params);
}
[EcoOclOperationResourcedHelpAttribute("opendocumentreportasblob(nameOfViewModel)  creates a report and returns is as a blob  ")]
public class Eco.FrameworkImpl.Ocl.Ocl_OpenDocumentReportAsArray : OclOperationBase {
    protected virtual void Init();
    public virtual void Evaluate(IOclOperationParameters __Params);
}
[EcoOclOperationResourcedHelpAttribute("opendocumentreportshow(nameOfViewModel)  creates a report and tries to open it ")]
public class Eco.FrameworkImpl.Ocl.Ocl_OpenDocumentReportShow : OclOperationBase {
    protected virtual void Init();
    public virtual void Evaluate(IOclOperationParameters __Params);
}
[EcoOclOperationResourcedHelpAttribute("logical OR between to booleans")]
public class Eco.FrameworkImpl.Ocl.Ocl_or : OclOperationBase {
    protected virtual void Init();
    public virtual void Evaluate(IOclOperationParameters __Params);
}
[EcoOclOperationResourcedHelpAttribute("Eco.Internal.BoldOclConst:OclHelporderby")]
public class Eco.FrameworkImpl.Ocl.Ocl_orderby : Ocl_AbstractOrder {
    protected virtual void Init();
}
[EcoOclOperationResourcedHelpAttribute("Eco.Internal.BoldOclConst:OclHelporderDescending")]
public class Eco.FrameworkImpl.Ocl.Ocl_orderDescending : Ocl_AbstractOrder {
    protected virtual void Init();
}
[EcoOclOperationResourcedHelpAttribute("Eco.Internal.BoldOclConst:OclHelporderGeneric")]
public class Eco.FrameworkImpl.Ocl.Ocl_OrderGeneric : OclOperationBase {
    protected virtual void Init();
    public virtual void Evaluate(IOclOperationParameters __Params);
}
[EcoOclOperationResourcedHelpAttribute("Eco.Internal.BoldOclConst:OclHelpPad")]
public class Eco.FrameworkImpl.Ocl.Ocl_Pad : OclOperationBase {
    protected virtual void Init();
    public virtual void Evaluate(IOclOperationParameters __Params);
}
[EcoOclOperationResourcedHelpAttribute("Eco.Internal.BoldOclConst:OclHelpPostPad")]
public class Eco.FrameworkImpl.Ocl.Ocl_PostPad : OclOperationBase {
    protected virtual void Init();
    public virtual void Evaluate(IOclOperationParameters __Params);
}
[EcoOclOperationResourcedHelpAttribute("Eco.Internal.BoldOclConst:OclHelpPrepend")]
public class Eco.FrameworkImpl.Ocl.Ocl_Prepend : OclOperationBase {
    protected virtual void Init();
    public virtual void Evaluate(IOclOperationParameters __Params);
}
[EcoOclOperationResourcedHelpAttribute("PS-Expression  SomeClass.PSEval(SomeClass.allinstances->select(x|x.name=vWhatever),maxfetch,offset,dependon) -  offers a way to reach into the database from ocl and action-lang - beware that we dont subscribe on sets from db, send things to subscribe on dependon")]
public class Eco.FrameworkImpl.Ocl.Ocl_PSEval : Ocl_PSEvalSharedLogic {
    protected virtual void Init();
    public virtual bool ResultIsReadOnly(Boolean[] Args);
    public sealed virtual void SemanticCheckExtended(IOclOperationParameters oclParameters, OclEnvironment oclenv);
    public sealed virtual void EvaluateExtended(IOclOperationParameters oclParameters, Stack`1<OclVariableBinding> loopvars);
    public virtual void Evaluate(IOclOperationParameters __Params);
}
public abstract class Eco.FrameworkImpl.Ocl.Ocl_PSEvalSharedLogic : OclOperationBase {
    protected void InitForSemanicCheck(IOclOperationParameters oclParameters, OclEnvironment oclenv, IModifiableVariableList& extvarlist, IClassifier& roottype, IClassifier& thetype);
    protected bool CheckAndActOnFetchConsolidation(string op, IOclOperationParameters oclParameters);
    protected IExternalVariableList GetVarListExtendedWithLoopVars(Stack`1<OclVariableBinding> loopvars);
}
[EcoOclOperationResourcedHelpAttribute("PS-Expression  SomeClass.PSEval(SomeClass.allinstances->select(x|x.name=vWhatever),maxfetch,offset,dependon) -  offers a way to reach into the database from ocl and action-lang - beware that we dont subscribe on sets from db, send things to subscribe on dependon")]
public class Eco.FrameworkImpl.Ocl.Ocl_PSEvalTuples : Ocl_PSEvalSharedLogic {
    protected virtual void Init();
    public virtual bool ResultIsReadOnly(Boolean[] Args);
    public sealed virtual void SemanticCheckExtended(IOclOperationParameters oclParameters, OclEnvironment oclenv);
    public sealed virtual void EvaluateExtended(IOclOperationParameters oclParameters, Stack`1<OclVariableBinding> loopvars);
    public virtual IOclType CalculateReturnTypeExtended(IOclOperationParameters oclParameters, object envUntyped);
    public virtual void Evaluate(IOclOperationParameters __Params);
}
[EcoOclOperationResourcedHelpAttribute("PS-Expression  SomeClass.PSEvalValue(SomeClass.allinstances->select(x|x.name=vWhatever)->size,dependon) -  offers a way to reach into the database from ocl and action-lang - beware that we dont subscribe on sets from db, send things to subscribe on dependon")]
public class Eco.FrameworkImpl.Ocl.Ocl_PSEvalValue : Ocl_PSEvalSharedLogic {
    protected virtual void Init();
    public virtual bool ResultIsReadOnly(Boolean[] Args);
    public sealed virtual void SemanticCheckExtended(IOclOperationParameters oclParameters, OclEnvironment oclenv);
    public sealed virtual void EvaluateExtended(IOclOperationParameters oclParameters, Stack`1<OclVariableBinding> loopvars);
    public virtual void Evaluate(IOclOperationParameters __Params);
}
[EcoOclOperationResourcedHelpAttribute("Eco.Internal.BoldOclConst:OclHelpRegExpMatch")]
public class Eco.FrameworkImpl.Ocl.Ocl_RegExpMatch : OclOperationBase {
    protected virtual void Init();
    public virtual void Evaluate(IOclOperationParameters __Params);
}
[EcoOclOperationResourcedHelpAttribute("Eco.Internal.BoldOclConst:OclHelpreject")]
public class Eco.FrameworkImpl.Ocl.Ocl_reject : OclOperationBase {
    protected virtual void Init();
    public virtual void Evaluate(IOclOperationParameters __Params);
}
[EcoOclOperationResourcedHelpAttribute("Eco.Internal.BoldOclConst:OclHelpsafeCast")]
public class Eco.FrameworkImpl.Ocl.Ocl_safeCast : OclOperationBase {
    protected virtual void Init();
    public virtual void Evaluate(IOclOperationParameters __Params);
}
[EcoOclOperationResourcedHelpAttribute("ScriptEval  SomeObject.ScriptEval(isActionNotOcl,ResultType,'some ocl/eal as string that returns value of string type')")]
public class Eco.FrameworkImpl.Ocl.Ocl_ScriptEval : Ocl_ScriptEvalBase {
    protected virtual void Init();
    public virtual void Evaluate(IOclOperationParameters __Params);
}
public abstract class Eco.FrameworkImpl.Ocl.Ocl_ScriptEvalBase : OclOperationBase {
    public virtual bool ResultIsReadOnly(Boolean[] Args);
    protected void CommonScriptEval(IOclOperationParameters __Params, bool isExecuteNotSyntaxCheck);
}
[EcoOclOperationResourcedHelpAttribute("ScriptEvalCheck  SomeObject.ScriptEvalCheck(isActionNotOcl,ResultType,'some ocl/eal as string that returns value of string type'):string. Returns ok or detailed error-string")]
public class Eco.FrameworkImpl.Ocl.Ocl_ScriptEvalCheck : Ocl_ScriptEvalBase {
    protected virtual void Init();
    public virtual void Evaluate(IOclOperationParameters __Params);
}
[EcoOclOperationResourcedHelpAttribute("Eco.Internal.BoldOclConst:OclHelpSelect")]
public class Eco.FrameworkImpl.Ocl.Ocl_Select : OclOperationBase {
    protected virtual void Init();
    public virtual void Evaluate(IOclOperationParameters __Params);
}
[EcoOclOperationResourcedHelpAttribute("Eco.Internal.BoldOclConst:OclHelpSize")]
public class Eco.FrameworkImpl.Ocl.Ocl_Size : OclOperationBase {
    protected virtual void Init();
    public virtual void Evaluate(IOclOperationParameters __Params);
    public virtual void SemanticCheck(IOclOperationParameters oclParameters);
}
[EcoOclOperationResourcedHelpAttribute("Eco.Internal.BoldOclConst:OclHelpSQLLike")]
public class Eco.FrameworkImpl.Ocl.Ocl_SQLLike : Ocl_SqlLikeCommon {
    protected virtual void Init();
    public virtual void Evaluate(IOclOperationParameters __Params);
}
[EcoOclOperationResourcedHelpAttribute("Eco.Internal.BoldOclConst:OclHelpSQLLikeCaseInsensitive")]
public class Eco.FrameworkImpl.Ocl.Ocl_SQLLikeCaseInsensitive : Ocl_SqlLikeCommon {
    protected virtual void Init();
    public virtual void Evaluate(IOclOperationParameters __Params);
}
public abstract class Eco.FrameworkImpl.Ocl.Ocl_SqlLikeCommon : OclOperationBase {
    public bool Match(IOclOperationParameters __Params, RegexOptions options);
}
[EcoOclOperationResourcedHelpAttribute("PS-Expression  SomeClass.sqlpassthrough('SqlExpression',Type1OfTupleResult,Type2OfTupleResult,...)")]
public class Eco.FrameworkImpl.Ocl.Ocl_SqlPassthrough : Ocl_TupleOperation {
    protected virtual void Init();
    public virtual IOclType CalculateReturnType(IOclOperationParameters oclParameters);
    public virtual bool ResultIsReadOnly(Boolean[] Args);
    public virtual void Evaluate(IOclOperationParameters __Params);
}
[EcoOclOperationResourcedHelpAttribute("PS-Expression  SomeClass.sqlpassthroughObjects('SqlExpression') - promise to return primary key of SomeClass. This can be combined with other Ocl-PS via ->intersection or union. Avoid clashing with table alias(we postfix with '_Number')")]
public class Eco.FrameworkImpl.Ocl.Ocl_SqlPassthroughObjects : OclOperationBase {
    protected virtual void Init();
    public virtual bool ResultIsReadOnly(Boolean[] Args);
    public virtual void Evaluate(IOclOperationParameters __Params);
}
public class Eco.FrameworkImpl.Ocl.Ocl_StartsWith : OclPsOperationBase {
    protected virtual void Init();
}
[EcoOclOperationResourcedHelpAttribute("Acts as a seperator of expressions, use to stack several expressions, only meaningful in in Action")]
public class Eco.FrameworkImpl.Ocl.Ocl_StatementSequence : OclOperationBase {
    protected virtual void Init();
    public virtual void Evaluate(IOclOperationParameters __Params);
}
[EcoOclOperationResourcedHelpAttribute("Eco.Internal.BoldOclConst:OclHelpStrToDate")]
public class Eco.FrameworkImpl.Ocl.Ocl_StrToDate : OclOperationBase {
    protected virtual void Init();
    public virtual void Evaluate(IOclOperationParameters __Params);
}
[EcoOclOperationResourcedHelpAttribute("Eco.Internal.BoldOclConst:OclHelpStrToDateTime")]
public class Eco.FrameworkImpl.Ocl.Ocl_StrToDateTime : OclOperationBase {
    protected virtual void Init();
    public virtual void Evaluate(IOclOperationParameters __Params);
}
[EcoOclOperationResourcedHelpAttribute("Eco.Internal.BoldOclConst:OclHelpstrToInt")]
public class Eco.FrameworkImpl.Ocl.Ocl_strToInt : OclOperationBase {
    protected virtual void Init();
    public virtual void Evaluate(IOclOperationParameters __Params);
}
[EcoOclOperationResourcedHelpAttribute("Eco.Internal.BoldOclConst:OclHelpStrToTime")]
public class Eco.FrameworkImpl.Ocl.Ocl_StrToTime : OclOperationBase {
    protected virtual void Init();
    public virtual void Evaluate(IOclOperationParameters __Params);
}
[EcoOclOperationResourcedHelpAttribute("Eco.Internal.BoldOclConst:OclHelpSubSequence")]
public class Eco.FrameworkImpl.Ocl.Ocl_SubSequence : OclOperationBase {
    protected virtual void Init();
    public virtual void Evaluate(IOclOperationParameters __Params);
}
[EcoOclOperationResourcedHelpAttribute("Eco.Internal.BoldOclConst:OclHelpSubString")]
public class Eco.FrameworkImpl.Ocl.Ocl_SubString : OclOperationBase {
    protected virtual void Init();
    public virtual void Evaluate(IOclOperationParameters __Params);
}
[EcoOclOperationResourcedHelpAttribute("Eco.Internal.BoldOclConst:OclHelpSuperTypes")]
public class Eco.FrameworkImpl.Ocl.Ocl_SuperTypes : OclOperationBase {
    protected virtual void Init();
    public virtual void Evaluate(IOclOperationParameters __Params);
}
[EcoOclOperationResourcedHelpAttribute("Eco.Internal.BoldOclConst:OclHelpSymmetricDifference")]
public class Eco.FrameworkImpl.Ocl.Ocl_SymmetricDifference : OclOperationBase {
    protected virtual void Init();
    public virtual void Evaluate(IOclOperationParameters __Params);
}
[EcoOclOperationResourcedHelpAttribute("Eco.Internal.BoldOclConst:OclHelpTaggedValue")]
public class Eco.FrameworkImpl.Ocl.Ocl_TaggedValue : OclOperationBase {
    protected virtual void Init();
    public virtual void Evaluate(IOclOperationParameters __Params);
}
[EcoOclOperationResourcedHelpAttribute("Access to tagged values placed on a attribute or associationend")]
public class Eco.FrameworkImpl.Ocl.Ocl_TaggedValueOnFeature : OclOperationBase {
    protected virtual void Init();
    public virtual void Evaluate(IOclOperationParameters __Params);
}
[EcoOclOperationResourcedHelpAttribute("Eco.Internal.BoldOclConst:OclHelpTimeStampToTime")]
public class Eco.FrameworkImpl.Ocl.Ocl_TimeStampToTime : OclOperationBase {
    protected virtual void Init();
    public virtual void Evaluate(IOclOperationParameters __Params);
}
[EcoOclOperationResourcedHelpAttribute("Eco.Internal.BoldOclConst:OclHelpTimeToTimeStamp")]
public class Eco.FrameworkImpl.Ocl.Ocl_TimeToTimeStamp : OclOperationBase {
    protected virtual void Init();
    public virtual void Evaluate(IOclOperationParameters __Params);
}
[EcoOclOperationResourcedHelpAttribute("Eco.Internal.BoldOclConst:OclHelptoLower")]
public class Eco.FrameworkImpl.Ocl.Ocl_toLower : OclPsOperationBase {
    protected virtual void Init();
}
[EcoOclOperationResourcedHelpAttribute("Eco.Internal.BoldOclConst:OclHelpToUpper")]
public class Eco.FrameworkImpl.Ocl.Ocl_ToUpper : OclPsOperationBase {
    protected virtual void Init();
}
[EcoOclOperationResourcedHelpAttribute("object.transform(viewmodelname, <destination object>) uses the viewmodel to transform information from <object> into the <destination object>. Returns True if transform is full.")]
public class Eco.FrameworkImpl.Ocl.Ocl_Transform : OclOperationBase {
    protected virtual void Init();
    public virtual void Evaluate(IOclOperationParameters __Params);
}
[EcoOclOperationResourcedHelpAttribute("string.Translate('en-US') returns translated string from SysTranslation class, string.translate('') will translate to users current language")]
public class Eco.FrameworkImpl.Ocl.Ocl_Translate : OclOperationBase {
    protected virtual void Init();
    public virtual void Evaluate(IOclOperationParameters __Params);
}
[EcoOclOperationResourcedHelpAttribute("Tries to convert the date and time string to a DateTime returning null if the string is not a valid date and/or time. ")]
public class Eco.FrameworkImpl.Ocl.Ocl_TryParse : OclOperationBase {
    protected virtual void Init();
    public virtual void Evaluate(IOclOperationParameters __Params);
}
public abstract class Eco.FrameworkImpl.Ocl.Ocl_TupleOperation : OclOperationBase {
    public ClassifierNamePair GenerateTuplePart(IOclValue value, int index, StringDictionary names, bool acceptTypeNodes);
    public string GetUniqueName(string baseName, StringDictionary names);
}
[EcoOclOperationResourcedHelpAttribute("Eco.Internal.BoldOclConst:OclHelpTypeName")]
public class Eco.FrameworkImpl.Ocl.Ocl_TypeName : OclOperationBase {
    protected virtual void Init();
    public virtual void Evaluate(IOclOperationParameters __Params);
}
[EcoOclOperationResourcedHelpAttribute("Eco.Internal.BoldOclConst:OclHelpunion")]
public class Eco.FrameworkImpl.Ocl.Ocl_union : OclOperationBase {
    protected virtual void Init();
    public void Evaluate_AddList(IElementCollection Target, IElementCollection Source);
    public virtual void Evaluate(IOclOperationParameters __Params);
}
[EcoOclOperationResourcedHelpAttribute("All ViewModels having this type as root type")]
public class Eco.FrameworkImpl.Ocl.Ocl_ViewModels : Ocl_TupleOperation {
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
private static EventHandler`1<OnDesignTimeViewModelAccessArgs> OnDesignTimeViewModelAccess;
    protected virtual void Init();
    public virtual bool ResultIsReadOnly(Boolean[] Args);
    public virtual void Evaluate(IOclOperationParameters __Params);
    [CompilerGeneratedAttribute]
public static void add_OnDesignTimeViewModelAccess(EventHandler`1<OnDesignTimeViewModelAccessArgs> value);
    [CompilerGeneratedAttribute]
public static void remove_OnDesignTimeViewModelAccess(EventHandler`1<OnDesignTimeViewModelAccessArgs> value);
    public virtual IOclType CalculateReturnType(IOclOperationParameters oclParameters);
}
[EcoOclOperationResourcedHelpAttribute("will execute included expression if false, boolean value passed on")]
public class Eco.FrameworkImpl.Ocl.Ocl_WhenFalse : OclOperationBase {
    protected virtual void Init();
    public virtual bool ResultIsReadOnly(Boolean[] Args);
    public virtual void Evaluate(IOclOperationParameters __Params);
}
[EcoOclOperationResourcedHelpAttribute("will execute included expression if true, boolean value passed on")]
public class Eco.FrameworkImpl.Ocl.Ocl_WhenTrue : OclOperationBase {
    protected virtual void Init();
    public virtual bool ResultIsReadOnly(Boolean[] Args);
    public virtual void Evaluate(IOclOperationParameters __Params);
}
[EcoOclOperationResourcedHelpAttribute("XHtmlReportAsString(nameOfViewModel)  works with XHTML content and transforms it using data from the viewmodel returning a string with XHTML")]
public class Eco.FrameworkImpl.Ocl.Ocl_XHtmlReportAsString : OclOperationBase {
    protected virtual void Init();
    public virtual void Evaluate(IOclOperationParameters __Params);
}
[EcoOclOperationResourcedHelpAttribute("logical XOR exlusive or operation")]
public class Eco.FrameworkImpl.Ocl.Ocl_xor : OclOperationBase {
    protected virtual void Init();
    public virtual void Evaluate(IOclOperationParameters __Params);
}
public abstract class Eco.FrameworkImpl.Ocl.OclPsOperationBase : OclOperationBase {
    public virtual void Evaluate(IOclOperationParameters __Params);
}
public class Eco.FrameworkImpl.Ocl.OnDesignTimeViewModelAccessArgs : EventArgs {
    public string Class;
    public IList`1<string> ReturnViewModelsForClassHere;
}
public class Eco.FrameworkImpl.Ocl.OnStylesInModelAccessArgs : EventArgs {
    public IList`1<string> ReturnStylesInModel;
}
public class Eco.FrameworkImpl.Ocl.SymbolImplementationUtils : object {
    public static int CompareNodes(IOclOperationParameters __Params, IOclOperationSupport Support);
    public static string FixSQLRegExp(string S);
}
public class Eco.FrameworkImpl.Ocl.TBoldDefaultActionLanguageSymbolFactory : object {
    public static void InstallSymbols(ITypeService typeService, IEcoTypeSystem typeSystem, OclTypeMethodInstaller MethodInstaller);
}
public class Eco.FrameworkImpl.Ocl.TBoldDefaultOclPsSymbolFactory : object {
    public static void InstallSymbols(ITypeService typeService, IEcoTypeSystem typeSystem, OclTypeMethodInstaller MethodInstaller);
}
public class Eco.FrameworkImpl.Ocl.TBoldDefaultOclSymbolFactory : object {
    public static void InstallSymbols(ITypeService typeService, IEcoTypeSystem typeSystem, OclTypeMethodInstaller MethodInstaller);
}
internal static class Eco.FrameworkImpl.OptimisticLocking.DataBlockConverter : object {
    private static bool IsDirect(IAssociationEnd associationEnd);
    public static object GetDatablockFetchedValue(ICache cache, Locator locator, IStructuralFeature member);
    public static ObjectId IdForLocator(ICache cache, Locator locator);
}
public class Eco.FrameworkImpl.OptimisticLocking.OptimisticLockHandler : EcoSpacePartWithTypeSystem {
    private ICache m_Cache;
    private IRegionFactory m_RegionFactory;
    private IPersistenceHandler m_PersistenceHandler;
    private IObjectRepresentationProvider m_ObjectRepresentationProvider;
    public IPersistenceHandler PersistenceHandler { get; public set; }
    public IRegionFactory RegionFactory { get; public set; }
    public IObjectRepresentationProvider ObjectRepresentationProvider { get; public set; }
    public ICache Cache { get; public set; }
    public OptimisticLockHandler(IEcoTypeSystem typeSystem);
    public IPersistenceHandler get_PersistenceHandler();
    public void set_PersistenceHandler(IPersistenceHandler value);
    public IRegionFactory get_RegionFactory();
    public void set_RegionFactory(IRegionFactory value);
    public IObjectRepresentationProvider get_ObjectRepresentationProvider();
    public void set_ObjectRepresentationProvider(IObjectRepresentationProvider value);
    public ICache get_Cache();
    public void set_Cache(ICache value);
    public sealed virtual OptimisticLockingPrecondition CreatePrecondition(IEnumerable`1<Locator> locators);
    private void AddOptimisticRegionLocks(IEnumerable`1<Locator> locators, OptimisticLockingPrecondition preCondition);
    private void GetRegionsForDirtyOtherEnds(IEnumerable`1<Locator> locators, TBoldRegionLookup regions);
    private void GetLockingValuesForRegion(ILockRegion region, OptimisticLockingPrecondition preCondition);
    private void GetLockingValuesForRegions(TBoldRegionLookup regions, OptimisticLockingPrecondition preCondition);
    private void GetRegionsForDirtyMembersInList(IEnumerable objectList, TBoldRegionLookup regions);
    private void GetRegionsForObject(Locator locator, TBoldRegionLookup regions);
    private void GetRegionsForMember(Locator locator, IStructuralFeature StructuralFeature, TBoldRegionLookup regions);
    private void RetrieveOptimisticLockingvalues(IEnumerable`1<Locator> objectList, OptimisticLockingPrecondition preCondition);
    private void GetRegionsForRemoteMember(Locator loc, TBoldRegionLookup regions, IAssociationEnd owningAssociationEnd);
    public void EnsureEnclosure(Locator aLocator, IObjectList Enclosure, bool ValidateOnly, Boolean& ListIsEnclosure);
    private void GetRegionsForDirtyMembers(Locator aLocator, TBoldRegionLookup Regions);
    private void AddRegionObjectsToEnclosure(ILockRegion Region, IObjectList Enclosure, bool ValidateOnly, Boolean& ListIsEnclosure);
    private void AddRegionsObjectsToEnclosure(TBoldRegionLookup Regions, IObjectList Enclosure, bool ValidateOnly, Boolean& ListIsEnclosure);
    private bool IsNewObject(Locator Loc);
    protected virtual void DoActivate();
}
internal class Eco.FrameworkImpl.OptimisticLocking.OptimisticLockRegionHandler : object {
}
public abstract class Eco.Handles.AbstractColumn : object {
    private ColumnCollection m_Owner;
    private string m_Name;
    private bool m_Nested;
    private string m_NestingName;
    private bool m_IsReadOnly;
    private bool m_AsExternalId;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
private bool <ForceColumnToSignalNotReadOnlyInOrderToWorkAroundWPFBindingLimitation>k__BackingField;
    internal ColumnCollection Owner { get; internal set; }
    private bool Eco.Handles.IColumn.IsEventDerived { get; }
    [BrowsableAttribute("False")]
public string TypeName { get; public set; }
    private bool Eco.Handles.IColumn.IsNested { get; }
    [LocalizableCategoryAttribute("Eco.Handles.HandlesStringRes", "sCategoryBinding")]
[LocalizableDescriptionAttribute("Eco.Handles.HandlesStringRes", "sPropertyColumnName")]
[DefaultValueAttribute("")]
public string Name { get; public set; }
    [LocalizableCategoryAttribute("Eco.Handles.HandlesStringRes", "sCategoryBinding")]
[LocalizableDescriptionAttribute("Eco.Handles.HandlesStringRes", "sPropertyIsReadOnly")]
[DefaultValueAttribute("False")]
public bool IsReadOnly { get; public set; }
    [LocalizableCategoryAttribute("Eco.Handles.HandlesStringRes", "sCategoryBinding")]
[LocalizableDescriptionAttribute("Eco.Handles.HandlesStringRes", "sPropertyAsExternalId")]
[DefaultValueAttribute("False")]
public bool AsExternalId { get; public set; }
    [LocalizableCategoryAttribute("Eco.Handles.HandlesStringRes", "sCategoryNesting")]
[LocalizableDescriptionAttribute("Eco.Handles.HandlesStringRes", "sPropertyNesting")]
[DefaultValueAttribute("")]
public string NestingName { get; public set; }
    [BrowsableAttribute("False")]
[DesignerSerializationVisibilityAttribute("0")]
public string Expression { get; public set; }
    [BrowsableAttribute("False")]
[DesignerSerializationVisibilityAttribute("0")]
public string NullElementRepresentation { get; public set; }
    [BrowsableAttribute("False")]
[DesignerSerializationVisibilityAttribute("0")]
public bool EventDerivedValue { get; public set; }
    [LocalizableCategoryAttribute("Eco.Handles.HandlesStringRes", "sCategoryNesting")]
[LocalizableDescriptionAttribute("Eco.Handles.HandlesStringRes", "sPropertyNested")]
[DefaultValueAttribute("False")]
public bool Nested { get; public set; }
    public bool ForceColumnToSignalNotReadOnlyInOrderToWorkAroundWPFBindingLimitation { get; public set; }
    internal void set_Owner(ColumnCollection value);
    internal ColumnCollection get_Owner();
    protected void Changed();
    private sealed virtual override bool Eco.Handles.IColumn.get_IsEventDerived();
    public virtual string get_TypeName();
    public virtual void set_TypeName(string value);
    private sealed virtual override bool Eco.Handles.IColumn.get_IsNested();
    private void CheckUniqueName(string name);
    public sealed virtual string get_Name();
    public void set_Name(string value);
    public sealed virtual bool get_IsReadOnly();
    public void set_IsReadOnly(bool value);
    public sealed virtual bool get_AsExternalId();
    public void set_AsExternalId(bool value);
    public sealed virtual string get_NestingName();
    public void set_NestingName(string value);
    public abstract virtual string get_Expression();
    public abstract virtual void set_Expression(string value);
    public abstract virtual string get_NullElementRepresentation();
    public abstract virtual void set_NullElementRepresentation(string value);
    public abstract virtual bool get_EventDerivedValue();
    public abstract virtual void set_EventDerivedValue(bool value);
    public bool get_Nested();
    public void set_Nested(bool value);
    [CompilerGeneratedAttribute]
public bool get_ForceColumnToSignalNotReadOnlyInOrderToWorkAroundWPFBindingLimitation();
    [CompilerGeneratedAttribute]
public void set_ForceColumnToSignalNotReadOnlyInOrderToWorkAroundWPFBindingLimitation(bool value);
}
public abstract class Eco.Handles.AbstractColumnConverter : ExpandableObjectConverter {
    public virtual bool CanConvertTo(ITypeDescriptorContext context, Type destinationType);
    protected abstract virtual Type GetTargetType();
    public virtual object ConvertTo(ITypeDescriptorContext context, CultureInfo culture, object value, Type destinationType);
}
public abstract class Eco.Handles.AbstractCursorHandle : RootedHandle {
    [BrowsableAttribute("False")]
[DesignerSerializationVisibilityAttribute("0")]
public int Position { get; public set; }
    protected virtual IClassifier GetStaticUmlType();
    public abstract virtual int get_Position();
    public abstract virtual void set_Position(int value);
    protected virtual void DeriveAndSubscribe(ISubscriber valueChangeSubscriber, ISubscriber resubscribeSubscriber);
}
public abstract class Eco.Handles.AbstractRenderedTuple : object {
    private bool m_NeedsPush;
    private AbstractRenderedTupleProperty[] m_Properties;
    private ITupleRenderingContext m_Owner;
    private IElement m_Root;
    private bool _initToMakeSureWeHaveValuesEvenForUnread;
    private PropertyChangedEventHandler _propertyChanged;
    public ITupleRenderingContext Owner { get; public set; }
    internal bool HasUnNotifiedChange { get; internal set; }
    public bool OwnerEnabled { get; }
    public bool AddDefaultProperties { get; }
    public bool IsTestTuple { get; }
    private IEcoServiceProvider Eco.Handles.IRenderingContext.ServiceProvider { get; }
    public string GetFirstPropertyAsString { get; }
    public IElement Element { get; }
    protected AbstractRenderedTuple(IElement element, ITupleRenderingContext owner);
    public ITupleRenderingContext get_Owner();
    public void set_Owner(ITupleRenderingContext value);
    internal bool get_HasUnNotifiedChange();
    internal void set_HasUnNotifiedChange(bool value);
    internal void MakeListsCurrent();
    public sealed virtual bool get_OwnerEnabled();
    public sealed virtual bool get_AddDefaultProperties();
    public virtual bool get_IsTestTuple();
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    private sealed virtual override IEcoServiceProvider Eco.Handles.IRenderingContext.get_ServiceProvider();
    private sealed virtual override void Eco.Handles.ITuplePropertyRenderingContext.PropertyOutOfDate(string name);
    public sealed virtual void SignalPropertyChanged(string name);
    public string get_GetFirstPropertyAsString();
    public sealed virtual IElement get_Element();
    private sealed virtual override AttributeCollection System.ComponentModel.ICustomTypeDescriptor.GetAttributes();
    private sealed virtual override string System.ComponentModel.ICustomTypeDescriptor.GetClassName();
    private sealed virtual override string System.ComponentModel.ICustomTypeDescriptor.GetComponentName();
    private sealed virtual override TypeConverter System.ComponentModel.ICustomTypeDescriptor.GetConverter();
    private sealed virtual override EventDescriptor System.ComponentModel.ICustomTypeDescriptor.GetDefaultEvent();
    private sealed virtual override PropertyDescriptor System.ComponentModel.ICustomTypeDescriptor.GetDefaultProperty();
    private sealed virtual override object System.ComponentModel.ICustomTypeDescriptor.GetEditor(Type editorBaseType);
    private sealed virtual override EventDescriptorCollection System.ComponentModel.ICustomTypeDescriptor.GetEvents();
    private sealed virtual override EventDescriptorCollection System.ComponentModel.ICustomTypeDescriptor.GetEvents(Attribute[] attributes);
    private sealed virtual override PropertyDescriptorCollection System.ComponentModel.ICustomTypeDescriptor.GetProperties();
    private sealed virtual override PropertyDescriptorCollection System.ComponentModel.ICustomTypeDescriptor.GetProperties(Attribute[] attributes);
    private sealed virtual override object System.ComponentModel.ICustomTypeDescriptor.GetPropertyOwner(PropertyDescriptor pd);
    public AbstractRenderedTupleProperty GetProperty(RenderedTuplePropertyDescriptor descriptor);
    public AbstractRenderedTupleProperty GetProperty(string propName);
    public object GetPropertyValue(string propName);
    public sealed virtual void add_PropertyChanged(PropertyChangedEventHandler value);
    public sealed virtual void remove_PropertyChanged(PropertyChangedEventHandler value);
}
public abstract class Eco.Handles.AbstractRenderedTupleProperty : AbstractDeriver {
    private IElement m_Value;
    protected bool m_IsNullElementProperty;
    protected RenderedTuplePropertyDescriptor m_Descriptor;
    protected ITuplePropertyRenderingContext m_Owner;
    private Publisher m_elementChangedPublisher;
    private int _invalidatedCursor;
    private int _updatedCursor;
    private int _signaledControlCursor;
    private bool _DisplayedQueued;
    internal ITuplePropertyRenderingContext Owner { get; }
    internal bool AddDefaultProperties { get; }
    public IElement Element { get; }
    private Publisher EnsuredPublisher { get; }
    private IElement Eco.ObjectRepresentation.IElementProvider.Element { get; }
    protected AbstractRenderedTupleProperty(RenderedTuplePropertyDescriptor descriptor, ITuplePropertyRenderingContext owner);
    internal ITuplePropertyRenderingContext get_Owner();
    internal bool get_AddDefaultProperties();
    public IElement get_Element();
    private void OnLastSub();
    private Publisher get_EnsuredPublisher();
    internal virtual void MakeListsCurrent();
    public virtual string ToString();
    protected virtual void DoNotifyOutOfDate();
    protected virtual void DoDeriveAndSubscribe(bool subscribe);
    private sealed virtual override IElement Eco.ObjectRepresentation.IElementProvider.get_Element();
    private sealed virtual override void Eco.ObjectRepresentation.ISubscribableElementProvider.SubscribeToElement(ISubscriber subscriber);
    public object GetValue();
    protected abstract virtual object DoGetValue();
    public abstract virtual void SetValue(object value);
    [CompilerGeneratedAttribute]
private void <DoNotifyOutOfDate>b__21_0();
    [CompilerGeneratedAttribute]
private string <DoDeriveAndSubscribe>b__22_0();
}
public enum Eco.Handles.CodeDressingEnum : Enum {
    public int value__;
    public static CodeDressingEnum NoCodeDressing;
    public static CodeDressingEnum CodeFoundButOutOfSync;
    public static CodeDressingEnum CodeFoundAndDressed;
}
[TypeConverterAttribute("Eco.Handles.ColumnConverter")]
[ObsoleteAttribute("For backwards compatibility only")]
public class Eco.Handles.Column : OclColumn {
    private bool m_EventDerivedValue;
    public bool EventDerivedValue { get; public set; }
    public virtual bool get_EventDerivedValue();
    public virtual void set_EventDerivedValue(bool value);
}
[DefaultMemberAttribute("Item")]
[ListBindableAttribute("False")]
[EditorAttribute("Eco.Handles.Design.ColumnCollectionEditor, Eco.Handles.Design, Version=7.1.0.0, Culture=neutral, PublicKeyToken=46a833be9e90de8c", "System.Drawing.Design.UITypeEditor")]
public class Eco.Handles.ColumnCollection : CollectionBase {
    private IStaticContext m_StaticContext;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
private EventHandler OnChange;
    public IStaticContext StaticContext { get; }
    public AbstractColumn Item { get; }
    public AbstractColumn Item { get; }
    public ColumnCollection(IStaticContext staticContext);
    public IStaticContext get_StaticContext();
    public AbstractColumn get_Item(int index);
    public AbstractColumn get_Item(string name);
    public void Add(AbstractColumn column);
    public int IndexOf(object value);
    public void AddRange(AbstractColumn[] columns);
    [ObsoleteAttribute("For backwards compatibility only")]
public void AddRange(Column[] columns);
    internal bool NameIsUnique(string name);
    private string GetUniqueName();
    internal void Changed();
    protected virtual void OnInsert(int index, object value);
    protected virtual void OnInsertComplete(int index, object value);
    protected virtual void OnClearComplete();
    protected virtual void OnRemoveComplete(int index, object value);
    [CompilerGeneratedAttribute]
public void add_OnChange(EventHandler value);
    [CompilerGeneratedAttribute]
public void remove_OnChange(EventHandler value);
}
public static class Eco.Handles.ColumnConstants : object {
    public static string DbNullRep;
    public static string NullRep;
}
[ObsoleteAttribute("For backwards compatibility only")]
public class Eco.Handles.ColumnConverter : AbstractColumnConverter {
    protected virtual Type GetTargetType();
}
internal class Eco.Handles.ColumnFilter : RenderedTupleFilter {
    public ColumnFilter(string filter, PropertyDescriptorCollection properties);
    public virtual bool Match(AbstractRenderedTuple row);
}
internal class Eco.Handles.CrossThreadNotify : object {
    internal INotifyOnIdle NotifyOnIdle;
    internal int CallingThreadId;
    internal long ThreadCursorValueOnSubmit;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
private int <TimesThisItemHasBeenTried>k__BackingField;
    internal int TimesThisItemHasBeenTried { get; internal set; }
    [CompilerGeneratedAttribute]
internal int get_TimesThisItemHasBeenTried();
    [CompilerGeneratedAttribute]
internal void set_TimesThisItemHasBeenTried(int value);
}
[ToolboxBitmapAttribute("Eco.Handles.CursorHandle")]
[ToolboxItemAttribute("True")]
public class Eco.Handles.CursorHandle : AbstractCursorHandle {
    private int m_Position;
    [BrowsableAttribute("False")]
[DesignerSerializationVisibilityAttribute("0")]
public int Position { get; public set; }
    public virtual int get_Position();
    public virtual void set_Position(int value);
}
[ComVisibleAttribute("True")]
[GuidAttribute("1CF6799C-6E7F-464B-8F46-60F2F76C1DE8")]
[DesignerAttribute("Eco.Handles.Design.EcoSpaceDesigner, Eco.Handles.Design, Version=7.1.0.0, Culture=neutral, PublicKeyToken=46a833be9e90de8c", "System.ComponentModel.Design.IRootDesigner")]
[ToolboxItemAttribute("False")]
[ComponentHelpAttribute("Eco.Handles.Design.EcoSpaceInspector", "Eco.Handles.Design, Version=7.1.0.0, Culture=neutral, PublicKeyToken=46a833be9e90de8c")]
public class Eco.Handles.DefaultEcoSpace : EcoSpace {
    private bool m_AllowDeactivateDirty;
    private IPersistenceMapper m_IPersistenceMapper;
    private EcoSpacePartList m_MandatoryParts;
    private EcoSpacePartList m_OptionalParts;
    private CacheImpl m_CacheImpl;
    private UndoImpl m_UndoImpl;
    private PersistenceHandlerImpl m_PersistenceHandlerImpl;
    private FetchedBlockHandler m_FetchHandlerImpl;
    private OptimisticLockHandler m_OptimisticLockHandlerImpl;
    private TBoldRegionFactory m_RegionFactoryImpl;
    private DefaultFrontsidePolicy m_frontsidePolicy;
    private LocatorFactory m_locatorFactory;
    private EcoServiceProvider m_ecoServiceProvider;
    private ChangeHandlerImpl m_ChangeHandler;
    private OclServicesImpl m_oclServicesImpl;
    private ExtentServiceImpl m_ExtentService;
    private PersistenceServiceImpl m_PersistenceService;
    private ExternalIdServiceBase m_ExternalIdService;
    private StateServiceImpl m_StateService;
    private VersionServiceImpl m_VersionService;
    private DirtyListServiceImpl m_DirtyListService;
    private VariableFactoryServiceImpl m_VariableFactoryService;
    private CacheContentServiceImpl m_CacheContentService;
    private AutoSubscriptionServiceImpl m_AutoSubscriptionService;
    private AsyncSupportServiceImpl m_AsyncSupportService;
    private BusinessDeleteServiceImpl m_BusinessDeleteService;
    private static ITypeSystemService typeSystemProvider;
    private bool m_Active;
    private static HashSet`1<int> _globalListOfTypeSystemChecksumsThatHaveBeenSingletonEnsured;
    private PersistenceMapper persistenceMapper;
    private bool m_OptimisticLocking;
    private Publisher m_ActiveChangedPublisher;
    private static int serializationVersion;
    private static string serializationHeader;
    private bool _GlobalSettingsInitiated;
    private bool _GlobalReadOnlyMode;
    private bool _GlobalToolbarMode;
    private bool _GlobalHideActionOnDisable;
    private bool _GlobalCenteredPopUp;
    private bool _GlobalBlazorClient;
    private string _GlobalBlazorClientComponentOverride;
    private bool _GlobalNavigateOnDoubleClickWithoutMenu;
    private bool _GlobalReadOnlyModeUseSaveAndLock;
    private bool _GlobalModalOfferOpenStandalone;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
private bool <EnsureSingletonInstancesOnEachEcoSpace>k__BackingField;
    private IObject _SysMDrivenMiscSettingsSingletonAsIObject;
    private bool _GetTheSysAsyncTicketClassIfItExistsDone;
    private IClass _GetTheSysAsyncTicketClassIfItExistsResult;
    private bool _ModelPatternCheck_SysDocBatchDone;
    private bool _ModelPatternCheck_SysDocBatchResult;
    private bool _ModelPatternCheck_SysViewStateCookie_Done;
    private bool _ModelPatternCheck_SysViewStateCookie_Result;
    protected EcoSpacePartList MandatoryParts { get; }
    protected EcoSpacePartList OptionalParts { get; }
    protected CacheImpl DefaultCacheImpl { get; }
    protected UndoImpl DefaultUndoImpl { get; }
    protected PersistenceHandlerImpl DefaultPersistenceHandlerImpl { get; }
    protected FetchedBlockHandler DefaultFetchHandlerImpl { get; }
    protected OptimisticLockHandler DefaultOptimisticLockHandlerImpl { get; }
    protected TBoldRegionFactory DefaultRegionFactoryImpl { get; }
    protected DefaultFrontsidePolicy FrontsidePolicy { get; }
    protected LocatorFactory LocatorFactory { get; }
    protected EcoServiceProvider EcoServiceProvider { get; }
    protected ChangeHandlerImpl ChangeHandler { get; }
    protected OclServicesImpl OclServicesImpl { get; }
    protected ExtentServiceImpl DefaultExtentService { get; }
    protected PersistenceServiceImpl DefaultPersistenceService { get; }
    protected ExternalIdServiceBase DefaultExternalIdService { get; }
    protected StateServiceImpl DefaultStateService { get; }
    protected VersionServiceImpl DefaultVersionService { get; }
    protected DirtyListServiceImpl DefaultDirtyListService { get; }
    protected VariableFactoryServiceImpl DefaultVariableFactoryService { get; }
    protected CacheContentServiceImpl DefaultCacheContentService { get; }
    protected AutoSubscriptionServiceImpl DefaultAutoSubscriptionServiceImpl { get; }
    protected AsyncSupportServiceImpl DefaultAsyncSupportServiceImpl { get; }
    protected BusinessDeleteServiceImpl DefaultBusinessDeleteServiceImpl { get; }
    [BrowsableAttribute("False")]
[DesignerSerializationVisibilityAttribute("0")]
public bool Persistent { get; }
    [BrowsableAttribute("False")]
[DesignerSerializationVisibilityAttribute("0")]
public bool Active { get; public set; }
    [LocalizableCategoryAttribute("Eco.Handles.HandlesStringRes", "sCategoryBehaviour")]
[LocalizableDescriptionAttribute("Eco.Handles.HandlesStringRes", "PropertyAllowDeactivateDirty")]
[DefaultValueAttribute("False")]
public bool AllowDeactivateDirty { get; public set; }
    [BrowsableAttribute("False")]
[ObsoleteAttribute("Use DefaultLinkFetchStrategy instead")]
unknown LinkFetchStrategy LinkFetchStrategy {public set; }
    [DefaultValueAttribute("Mono.Cecil.CustomAttributeArgument")]
[LocalizableCategoryAttribute("Eco.Handles.HandlesStringRes", "sCategoryPersistence")]
[LocalizableDescriptionAttribute("Eco.Handles.HandlesStringRes", "sPropertyDefaultLinkFetchStrategy")]
public FetchStrategy DefaultLinkFetchStrategy { get; public set; }
    [BrowsableAttribute("False")]
[DesignerSerializationVisibilityAttribute("0")]
public IEcoTypeSystem TypeSystem { get; }
    [LocalizableCategoryAttribute("Eco.Handles.HandlesStringRes", "sCategoryPersistence")]
[LocalizableDescriptionAttribute("Eco.Handles.HandlesStringRes", "sPropertyPersistenceMapper")]
[DefaultValueAttribute("")]
public PersistenceMapper PersistenceMapper { get; public set; }
    [LocalizableCategoryAttribute("Eco.Handles.HandlesStringRes", "sCategoryPersistence")]
[LocalizableDescriptionAttribute("Eco.Handles.HandlesStringRes", "sPropertyOptimisticLocking")]
[DefaultValueAttribute("False")]
public bool OptimisticLocking { get; public set; }
    [LocalizableCategoryAttribute("Eco.Handles.HandlesStringRes", "sCategoryPersistence")]
[LocalizableDescriptionAttribute("Eco.Handles.HandlesStringRes", "sPropertyUpdateWholeObjects")]
[DefaultValueAttribute("False")]
public bool UpdateWholeObjects { get; public set; }
    [LocalizableCategoryAttribute("Eco.Handles.HandlesStringRes", "sCategoryBehaviour")]
[LocalizableDescriptionAttribute("Eco.Handles.HandlesStringRes", "PropertyEnforceStringLength")]
[DefaultValueAttribute("False")]
public bool EnforceStringLength { get; public set; }
    [BrowsableAttribute("False")]
[DesignerSerializationVisibilityAttribute("0")]
public IObjectFactoryService ObjectFactory { get; }
    [BrowsableAttribute("False")]
[DesignerSerializationVisibilityAttribute("0")]
public IExternalIdService ExternalIds { get; }
    [BrowsableAttribute("False")]
[DesignerSerializationVisibilityAttribute("0")]
public IUndoService Undo { get; }
    [BrowsableAttribute("False")]
[DesignerSerializationVisibilityAttribute("0")]
public IStateService States { get; }
    [BrowsableAttribute("False")]
[DesignerSerializationVisibilityAttribute("0")]
public IPersistenceService Persistence { get; }
    [BrowsableAttribute("False")]
[DesignerSerializationVisibilityAttribute("0")]
public IVersionService Versioning { get; }
    [BrowsableAttribute("False")]
[DesignerSerializationVisibilityAttribute("0")]
public IDirtyListService DirtyList { get; }
    [BrowsableAttribute("False")]
[DesignerSerializationVisibilityAttribute("0")]
public IAutoSubscriptionService AutoSubscriptionService { get; }
    [BrowsableAttribute("False")]
[DesignerSerializationVisibilityAttribute("0")]
public IExtentService Extents { get; }
    [BrowsableAttribute("False")]
[DesignerSerializationVisibilityAttribute("0")]
public IVariableFactoryService VariableFactory { get; }
    [BrowsableAttribute("False")]
[DesignerSerializationVisibilityAttribute("0")]
public ITypeSystemService TypeSystemService { get; }
    [BrowsableAttribute("False")]
[DesignerSerializationVisibilityAttribute("0")]
public IOclService Ocl { get; }
    [BrowsableAttribute("False")]
[DesignerSerializationVisibilityAttribute("0")]
public IActionLanguageService ActionLanguage { get; }
    [BrowsableAttribute("False")]
[DesignerSerializationVisibilityAttribute("0")]
public IOclPsService OclPs { get; }
    [BrowsableAttribute("False")]
[DesignerSerializationVisibilityAttribute("0")]
public ICacheContentService CacheContent { get; }
    public bool GlobalBlazorClient { get; }
    public bool GlobalReadOnlyMode { get; }
    public string GlobalBlazorClientComponentOverride { get; }
    public bool GlobalNavigateOnDoubleClickWithoutMenu { get; }
    public bool GlobalReadOnlyModeUseSaveAndLock { get; }
    public bool GlobalModalOfferOpenStandalone { get; }
    public bool GlobalToolbarMode { get; }
    public bool GlobalHideActionOnDisable { get; }
    public bool GlobalCenteredPopUp { get; }
    public bool EnsureSingletonInstancesOnEachEcoSpace { get; public set; }
    protected DefaultEcoSpace(IEcoTypeSystem typeSystem);
    private static DefaultEcoSpace();
    protected EcoSpacePartList get_MandatoryParts();
    protected EcoSpacePartList get_OptionalParts();
    protected CacheImpl get_DefaultCacheImpl();
    protected UndoImpl get_DefaultUndoImpl();
    protected PersistenceHandlerImpl get_DefaultPersistenceHandlerImpl();
    protected FetchedBlockHandler get_DefaultFetchHandlerImpl();
    protected OptimisticLockHandler get_DefaultOptimisticLockHandlerImpl();
    protected TBoldRegionFactory get_DefaultRegionFactoryImpl();
    protected DefaultFrontsidePolicy get_FrontsidePolicy();
    protected LocatorFactory get_LocatorFactory();
    protected EcoServiceProvider get_EcoServiceProvider();
    protected ChangeHandlerImpl get_ChangeHandler();
    protected OclServicesImpl get_OclServicesImpl();
    protected ExtentServiceImpl get_DefaultExtentService();
    protected PersistenceServiceImpl get_DefaultPersistenceService();
    protected ExternalIdServiceBase get_DefaultExternalIdService();
    protected StateServiceImpl get_DefaultStateService();
    protected VersionServiceImpl get_DefaultVersionService();
    protected DirtyListServiceImpl get_DefaultDirtyListService();
    protected VariableFactoryServiceImpl get_DefaultVariableFactoryService();
    protected CacheContentServiceImpl get_DefaultCacheContentService();
    protected AutoSubscriptionServiceImpl get_DefaultAutoSubscriptionServiceImpl();
    protected AsyncSupportServiceImpl get_DefaultAsyncSupportServiceImpl();
    protected BusinessDeleteServiceImpl get_DefaultBusinessDeleteServiceImpl();
    public static ITypeSystemService GetTypeSystemService();
    protected virtual ITypeSystemService GetTypeSystemProvider();
    public static ITypeSystemService MakeTypeService(Type ecoSpaceType);
    protected static ITypeSystemService MakeTypeService(object dummy, Type ecoSpaceType);
    [ObsoleteAttribute]
public virtual object GetEcoService(Type serviceType);
    public virtual T GetEcoService();
    public virtual T GetEcoService(object key);
    public bool get_Persistent();
    public virtual bool get_Active();
    public virtual void set_Active(bool value);
    private void EnsureSingletonInstances();
    private void Setup();
    public bool get_AllowDeactivateDirty();
    public void set_AllowDeactivateDirty(bool value);
    public void set_LinkFetchStrategy(LinkFetchStrategy value);
    public FetchStrategy get_DefaultLinkFetchStrategy();
    public void set_DefaultLinkFetchStrategy(FetchStrategy value);
    public virtual void Initialize(IEcoTypeSystem typeSystem);
    protected virtual ExternalIdServiceBase CreateExternalIdService(IEcoTypeSystem typeSystem);
    protected virtual void Dispose(bool disposing);
    public virtual void CleanForFree();
    public sealed virtual void PruneResources(bool LowMemoryCondition);
    public sealed virtual EcoRuntimeInformation GetRuntimeInformation(IExecutionAndDebug owner, DebugSettingsStack settings, int depth);
    private void CreateDefaultServices();
    public virtual IEcoTypeSystem get_TypeSystem();
    public PersistenceMapper get_PersistenceMapper();
    public void set_PersistenceMapper(PersistenceMapper value);
    public bool get_OptimisticLocking();
    public void set_OptimisticLocking(bool value);
    public bool get_UpdateWholeObjects();
    public void set_UpdateWholeObjects(bool value);
    public virtual void SubscribeToActive(ISubscriber subscriber);
    public bool get_EnforceStringLength();
    public void set_EnforceStringLength(bool value);
    [ObsoleteAttribute]
public void RegisterEcoService(Type serviceType, object service);
    public virtual void RegisterEcoService(T service);
    public virtual void RegisterEcoService(object key, T service);
    public virtual void Serialize(Stream target, EcoSpaceSerializationConfig config);
    public void Deserialize(Stream source);
    public virtual void Deserialize(Stream source, BinaryReader reader);
    public IObjectFactoryService get_ObjectFactory();
    public IExternalIdService get_ExternalIds();
    public IUndoService get_Undo();
    public IStateService get_States();
    public IPersistenceService get_Persistence();
    public IVersionService get_Versioning();
    public IDirtyListService get_DirtyList();
    public IAutoSubscriptionService get_AutoSubscriptionService();
    public IExtentService get_Extents();
    public IVariableFactoryService get_VariableFactory();
    public ITypeSystemService get_TypeSystemService();
    public IOclService get_Ocl();
    public IActionLanguageService get_ActionLanguage();
    public IOclPsService get_OclPs();
    public ICacheContentService get_CacheContent();
    public sealed virtual bool get_GlobalBlazorClient();
    public sealed virtual bool get_GlobalReadOnlyMode();
    public string get_GlobalBlazorClientComponentOverride();
    public sealed virtual bool get_GlobalNavigateOnDoubleClickWithoutMenu();
    public sealed virtual bool get_GlobalReadOnlyModeUseSaveAndLock();
    public bool get_GlobalModalOfferOpenStandalone();
    private void EnsureGlobalSettingsInitiated();
    public sealed virtual bool get_GlobalToolbarMode();
    public sealed virtual bool get_GlobalHideActionOnDisable();
    public sealed virtual bool get_GlobalCenteredPopUp();
    [CompilerGeneratedAttribute]
public bool get_EnsureSingletonInstancesOnEachEcoSpace();
    [CompilerGeneratedAttribute]
public void set_EnsureSingletonInstancesOnEachEcoSpace(bool value);
    public IObject GetTheSysMDrivenMiscSettingsObject();
    public void PreAllocateGuidID(IEnumerable`1<IEcoObject> list);
    public void PreAllocateGuidID(IEcoObject obj);
    public IClass GetTheSysAsyncTicketClassIfItExists();
    public IClass GetTheSysAsyncTicketClassIfItExists(StringBuilder log);
    public bool ModelPatternCheck_SysDocBatch();
    public bool ModelPatternCheck_SysViewStateCookie();
}
public class Eco.Handles.DeriveEventArgs : EventArgs {
    private string m_Name;
    private IElement m_RootElement;
    private IElement m_ResultElement;
    private ISubscriber m_ValueChangeSubscriber;
    private ISubscriber m_ResubscribeSubscriber;
    private IEcoServiceProvider m_ServiceProvider;
    private IStaticContext m_StaticContext;
    public IEcoServiceProvider ServiceProvider { get; }
    public IOclService OclService { get; }
    public string Name { get; }
    public IStaticContext StaticContext { get; }
    public IElement RootElement { get; }
    public IElement ResultElement { get; public set; }
    public ISubscriber ValueChangeSubscriber { get; }
    public ISubscriber ResubscribeSubscriber { get; }
    public DeriveEventArgs(string name, IEcoServiceProvider serviceProvider, IElement rootElement, ISubscriber valueChangeSubscriber, ISubscriber resubscribeSubscriber, IStaticContext staticContext);
    public IEcoServiceProvider get_ServiceProvider();
    public IOclService get_OclService();
    public string get_Name();
    public IStaticContext get_StaticContext();
    public IElement get_RootElement();
    public void set_ResultElement(IElement value);
    public IElement get_ResultElement();
    public ISubscriber get_ValueChangeSubscriber();
    public ISubscriber get_ResubscribeSubscriber();
}
public class Eco.Handles.DeriveEventHandler : MulticastDelegate {
    public DeriveEventHandler(object object, IntPtr method);
    public virtual void Invoke(object sender, DeriveEventArgs e);
    public virtual IAsyncResult BeginInvoke(object sender, DeriveEventArgs e, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
public class Eco.Handles.DescriptorFactory : object {
    private Dictionary`2<DescriptorKey, RenderedTupleDescriptor> m_Descriptors;
    private INestingProvider m_Nestings;
    private IStaticContext m_staticContext;
    private bool m_AddDefaultNestings;
    private bool m_SupportSorting;
    private FilterMode m_FilterMode;
    private bool m_DesignMode;
    private MemberVisibility m_MemberVisibility;
    public DescriptorFactory(IStaticContext staticContext, INestingProvider nestings, bool addDefaultNestings, MemberVisibility memberVisibility, bool designMode, bool supportSorting, FilterMode filterMode);
    public RenderedTupleDescriptor GetDescriptor(IClassifier staticType, string nestingName);
}
public class Eco.Handles.Design.ModelValidationIncident : ValidationIncident {
    private IModelElement m_Owner;
    private static string ViolationError;
    private static string ViolationWarning;
    private static string ViolationHint;
    public IModelElement Owner { get; }
    public ModelValidationIncident(IModelElement owner, Severity severity, string message);
    public IModelElement get_Owner();
    public virtual string ToString();
}
public class Eco.Handles.Design.ModelValidationReport : ValidationReport {
    public void AddError(string description, IModelElement element);
    public void AddWarning(string description, IModelElement element);
    public void AddHint(string description, IModelElement element);
}
public enum Eco.Handles.Design.Severity : Enum {
    public int value__;
    public static Severity Error;
    public static Severity Warning;
    public static Severity Hint;
    public static Severity Info;
}
public class Eco.Handles.Design.ValidationIncident : object {
    private Severity m_Severity;
    private string m_Message;
    public string Message { get; }
    public Severity Severity { get; }
    public ValidationIncident(Severity severity, string message);
    public string get_Message();
    public Severity get_Severity();
    public virtual string ToString();
    public virtual string ToShortString();
}
public class Eco.Handles.Design.ValidationReport : object {
    private List`1<ValidationIncident> m_Incidents;
    public List`1<ValidationIncident> Incidents { get; }
    public List`1<ValidationIncident> get_Incidents();
    public int Count(Severity severity);
    public void Clear();
    public virtual List`1<string> GetMessages();
}
public abstract class Eco.Handles.DisplayQueue : object {
    private static List`1<CrossThreadNotify> T_DisplayQueue;
    [ThreadStaticAttribute]
private static List`1<CrossThreadNotify> T_DisplayQueue_ThreadStatic;
    private static object c_DisplayQueueLock;
    private static bool _isThreadStatic;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
private static DisplayQueueNotEmptyEventHandler OnQueueNotEmpty;
    private static bool _DisplayQueueTurnedOn;
    private static long _displayPassCount;
    private static long _displayPassCountOnLastAdd;
    private static DateTime _lastLifeSignDisplayQueue;
    [ThreadStaticAttribute]
private static long _threadCursorThreadStatic;
    private static long _threadCursorCommonForAllThreads;
    private static Dictionary`2<int, long> _threadCursors;
    private static HashSet`1<int> _threadsToIgnore;
    private static TimeSpan _timeDoingQueueTotal;
    private static List`1<CrossThreadNotify> _SavedNotNowQueue;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
private static EventHandler`1<ExceptionInDisplayArgs> ExceptionsInDisplay;
    private static List`1<CrossThreadNotify> Queue { get; }
    public static bool DisplayQueueTurnedOn { get; public set; }
    private static DisplayQueue();
    private static List`1<CrossThreadNotify> get_Queue();
    public static void MakeDisplayQueueThreadStatic(bool yesno);
    public static void OnIdle(object sender, EventArgs args);
    [CompilerGeneratedAttribute]
public static void add_OnQueueNotEmpty(DisplayQueueNotEmptyEventHandler value);
    [CompilerGeneratedAttribute]
public static void remove_OnQueueNotEmpty(DisplayQueueNotEmptyEventHandler value);
    public static void Remove(INotifyOnIdle displayable);
    public static void RemoveAllWithOwner(object owner);
    public static bool get_DisplayQueueTurnedOn();
    public static void set_DisplayQueueTurnedOn(bool value);
    public static void Add(INotifyOnIdle displayable);
    private static void IncreaseAddCursor();
    public static long GetAddCursor();
    internal static void DisplayQueueNotEmpty();
    private static long GetCurrentThreadCursorValue();
    private static int EnsureCurrentThreadCursor();
    private static bool CheckIfThreadIsReadyForDisplayOfThisItem(CrossThreadNotify crossThreadNotify);
    public static void IgnoreForThisThread();
    public static bool ShouldIgnoreThisThread();
    public static void StepCurrentThreadCursor();
    public static void DisplayClearFreshStart();
    public static void DisplayAll();
    private static void SaveNotNowQueueUntilCursorMoves(List`1<CrossThreadNotify> notNowQueue);
    private static void TryNotNowQueueOnceMore();
    [CompilerGeneratedAttribute]
public static void add_ExceptionsInDisplay(EventHandler`1<ExceptionInDisplayArgs> value);
    [CompilerGeneratedAttribute]
public static void remove_ExceptionsInDisplay(EventHandler`1<ExceptionInDisplayArgs> value);
}
public class Eco.Handles.DisplayQueueNotEmptyEventHandler : MulticastDelegate {
    public DisplayQueueNotEmptyEventHandler(object object, IntPtr method);
    public virtual void Invoke();
    public virtual IAsyncResult BeginInvoke(AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
public class Eco.Handles.DisplayQueueThis : object {
    private Action _task;
    private WeakReference _ownerForRevert;
    public DisplayQueueThis(Action t);
    public DisplayQueueThis(Action t, object ownerForRevert);
    public sealed virtual void NotifyOnIdle();
    public sealed virtual bool Match(object ownerForRevert);
}
public class Eco.Handles.DisplayQueueThisOnlyTheLast : object {
    private Action _task;
    public DisplayQueueThisOnlyTheLast(Action t);
    public sealed virtual void NotifyOnIdle();
    public sealed virtual bool Match(object task);
}
[ComVisibleAttribute("True")]
[GuidAttribute("1E3C0670-37FA-4A6E-AD8F-823149BCCF85")]
[ToolboxItemAttribute("False")]
public abstract class Eco.Handles.EcoSpace : EcoSpaceBase {
    private DateTime m_CreateTime;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
private string <CreationChecksum>k__BackingField;
    private static Dictionary`2<string, Type> ecoSpaceTypes;
    private static IEcoSpaceTypeLookupService ecoSpaceTypeLookupService;
    public string CreationChecksum { get; private set; }
    [BrowsableAttribute("False")]
[DesignerSerializationVisibilityAttribute("0")]
public bool Active { get; public set; }
    public IEcoTypeSystem TypeSystem { get; }
    [BrowsableAttribute("False")]
[DesignerSerializationVisibilityAttribute("0")]
public DateTime CreateTime { get; }
    public static IEcoSpaceTypeLookupService EcoSpaceTypeLookupService { get; public set; }
    private static EcoSpace();
    public abstract virtual object GetEcoService(Type serviceType);
    public abstract virtual T GetEcoService();
    public abstract virtual T GetEcoService(object key);
    public abstract virtual void RegisterEcoService(T service);
    public abstract virtual void RegisterEcoService(object key, T service);
    [CompilerGeneratedAttribute]
public virtual string get_CreationChecksum();
    [CompilerGeneratedAttribute]
private void set_CreationChecksum(string value);
    public void SetCreationChecksum(string checksumstring);
    protected virtual object GetService(Type service);
    public abstract virtual bool get_Active();
    public abstract virtual void set_Active(bool value);
    public abstract virtual IEcoTypeSystem get_TypeSystem();
    public abstract virtual void SubscribeToActive(ISubscriber subscriber);
    protected virtual void Dispose(bool disposing);
    public DateTime get_CreateTime();
    public static void RegisterEcoSpaceType(Type t);
    public static Type GetEcoSpaceType(string name);
    public static IEcoSpaceTypeLookupService get_EcoSpaceTypeLookupService();
    public static void set_EcoSpaceTypeLookupService(IEcoSpaceTypeLookupService value);
    public abstract virtual void Serialize(Stream target, EcoSpaceSerializationConfig config);
    public void Serialize(Stream target);
    public abstract virtual void Deserialize(Stream source, BinaryReader reader);
    public sealed virtual IEcoSpaceService GetEcoSpace();
}
public class Eco.Handles.EcoSpaceSerializer : object {
    private EcoSpace m_EcoSpace;
    public EcoSpace EcoSpace { get; public set; }
    protected EcoSpaceSerializer(SerializationInfo si, StreamingContext context);
    [SecurityCriticalAttribute]
private sealed virtual override void System.Runtime.Serialization.ISerializable.GetObjectData(SerializationInfo si, StreamingContext context);
    public EcoSpace get_EcoSpace();
    public void set_EcoSpace(EcoSpace value);
}
[LocalizableCategoryAttribute("Eco.Handles.ElementHandle", "ComponentCategoryHandles")]
public abstract class Eco.Handles.ElementHandle : Component {
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
private string <RefName>k__BackingField;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
private bool <IsDisposed>k__BackingField;
    private HandleAdapter m_HandleAdapter;
    private ColumnCollection m_Columns;
    private NestingCollection m_Nestings;
    private bool m_AddDefaultProperties;
    private bool m_AddDefaultPropertiesSkipDelayedFetch;
    private bool m_AddDefaultPropertiesSkipDerived;
    private NullRowMode m_NullRowMode;
    private bool m_AddSelfColumn;
    private bool m_AddExternalId;
    private bool m_AddDefaultNestings;
    private MemberVisibility m_MemberVisibility;
    private bool m_SupportSorting;
    private FilterMode m_FilterMode;
    private bool m_AllowNew;
    private Publisher m_ElementChangedPublisher;
    private Publisher m_StaticContextChangedPublisher;
    private IElement m_InternalElement;
    private ActiveChangedAdapter m_ActiveChangedAdapter;
    private Publisher m_ActiveChangedPublisher;
    private bool m_Enabled;
    private VariablesChangedAdapter m_VariablesChangedAdapter;
    private OclVariables m_Variables;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
private AddNewObjectHandler AddNewObject;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
private ListChangedEventHandler ListChanged;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
private bool <IsInitializing>k__BackingField;
    protected bool AutoQueue { get; }
    public string RefName { get; public set; }
    [BrowsableAttribute("False")]
public IList List { get; }
    protected bool IsDisposed { get; protected set; }
    private HandleAdapter HandleAdapter { get; }
    [DesignerSerializationVisibilityAttribute("2")]
[LocalizableCategoryAttribute("Eco.Handles.HandlesStringRes", "sCategoryPresentation")]
[LocalizableDescriptionAttribute("Eco.Handles.HandlesStringRes", "sPropertyColumns")]
public ColumnCollection Columns { get; }
    [EditorAttribute("CollectionEditor", "UITypeEditor")]
[DesignerSerializationVisibilityAttribute("2")]
[LocalizableCategoryAttribute("Eco.Handles.HandlesStringRes", "sCategoryPresentation")]
[LocalizableDescriptionAttribute("Eco.Handles.HandlesStringRes", "sPropertyNestings")]
public NestingCollection Nestings { get; }
    [LocalizableCategoryAttribute("Eco.Handles.HandlesStringRes", "sCategoryPresentation")]
[LocalizableDescriptionAttribute("Eco.Handles.HandlesStringRes", "sPropertyAddDefaultProperties")]
[DefaultValueAttribute("True")]
public bool AddDefaultProperties { get; public set; }
    public bool AddDefaultPropertiesSkipDelayedFetch { get; public set; }
    public bool AddDefaultPropertiesSkipDerived { get; public set; }
    [LocalizableCategoryAttribute("Eco.Handles.HandlesStringRes", "sCategoryPresentation")]
[LocalizableDescriptionAttribute("Eco.Handles.HandlesStringRes", "sNullRowMode")]
[DefaultValueAttribute("Mono.Cecil.CustomAttributeArgument")]
public NullRowMode NullRowMode { get; public set; }
    [LocalizableCategoryAttribute("Eco.Handles.HandlesStringRes", "sCategoryPresentation")]
[LocalizableDescriptionAttribute("Eco.Handles.HandlesStringRes", "sPropertyAddSelfColumn")]
[DefaultValueAttribute("False")]
public bool AddSelfColumn { get; public set; }
    [LocalizableCategoryAttribute("Eco.Handles.HandlesStringRes", "sCategoryPresentation")]
[LocalizableDescriptionAttribute("Eco.Handles.HandlesStringRes", "sPropertyAddExternalId")]
[DefaultValueAttribute("False")]
public bool AddExternalId { get; public set; }
    [LocalizableCategoryAttribute("Eco.Handles.HandlesStringRes", "sCategoryPresentation")]
[LocalizableDescriptionAttribute("Eco.Handles.HandlesStringRes", "sPropertyAddDefaultNestings")]
[DefaultValueAttribute("False")]
public bool AddDefaultNestings { get; public set; }
    [LocalizableCategoryAttribute("Eco.Handles.HandlesStringRes", "sCategoryPresentation")]
[LocalizableDescriptionAttribute("Eco.Handles.HandlesStringRes", "sPropertyMemberVisibility")]
[DefaultValueAttribute("Mono.Cecil.CustomAttributeArgument")]
public MemberVisibility MemberVisibility { get; public set; }
    [LocalizableCategoryAttribute("Eco.Handles.HandlesStringRes", "sCategoryBehaviour")]
[LocalizableDescriptionAttribute("Eco.Handles.HandlesStringRes", "sPropertySupportSorting")]
[DefaultValueAttribute("True")]
public bool SupportSorting { get; public set; }
    [LocalizableCategoryAttribute("Eco.Handles.HandlesStringRes", "sCategoryBehaviour")]
[LocalizableDescriptionAttribute("Eco.Handles.HandlesStringRes", "sPropertyFilterMode")]
[DefaultValueAttribute("Mono.Cecil.CustomAttributeArgument")]
public FilterMode FilterMode { get; public set; }
    [LocalizableCategoryAttribute("Eco.Handles.HandlesStringRes", "sCategoryBehaviour")]
[LocalizableDescriptionAttribute("Eco.Handles.HandlesStringRes", "sPropertyAllowNew")]
[DefaultValueAttribute("False")]
public bool AllowNew { get; public set; }
    private IEcoTypeSystem Eco.Services.IStaticContext.TypeSystem { get; }
    private IOclTypeService Eco.Services.IStaticContext.OclTypeService { get; }
    private IOclPsTypeService Eco.Services.IStaticContext.OclPsTypeService { get; }
    private IActionLanguageTypeService Eco.Services.IStaticContext.ActionLanguageTypeService { get; }
    private IExternalVariableList Eco.Services.IStaticContext.VariableList { get; }
    [BrowsableAttribute("False")]
public IClassifier StaticUmlType { get; }
    [BrowsableAttribute("False")]
[DesignerSerializationVisibilityAttribute("0")]
public IElement Element { get; }
    private Publisher EnsuredPublisher { get; }
    private Publisher EnsuredStaticContextPublisher { get; }
    protected IElement InternalElement { get; protected set; }
    [ObsoleteAttribute("Replaced by EffectiveEnabled")]
[BrowsableAttribute("False")]
[DesignerSerializationVisibilityAttribute("0")]
public bool Active { get; public set; }
    [BrowsableAttribute("False")]
[DesignerSerializationVisibilityAttribute("0")]
public bool EffectiveEnabled { get; }
    private Publisher EnsuredActiveChangedPublisher { get; }
    [LocalizableCategoryAttribute("Eco.Handles.HandlesStringRes", "sCategoryPresentation")]
[LocalizableDescriptionAttribute("Eco.Handles.HandlesStringRes", "sPropertyEnabled")]
[DefaultValueAttribute("True")]
public bool Enabled { get; public set; }
    [LocalizableCategoryAttribute("Eco.Handles.HandlesStringRes", "sCategoryOCL")]
[LocalizableDescriptionAttribute("Eco.Handles.HandlesStringRes", "sPropertyVariables")]
[BrowsableAttribute("True")]
[DefaultValueAttribute("")]
public OclVariables Variables { get; public set; }
    private bool System.Collections.ICollection.IsSynchronized { get; }
    private int System.Collections.ICollection.Count { get; }
    private object System.Collections.ICollection.SyncRoot { get; }
    private bool System.Collections.IList.IsReadOnly { get; }
    private object System.Collections.IList.Item { get; private set; }
    private bool System.Collections.IList.IsFixedSize { get; }
    private bool System.ComponentModel.IBindingList.AllowEdit { get; }
    private bool System.ComponentModel.IBindingList.AllowNew { get; }
    private bool System.ComponentModel.IBindingList.AllowRemove { get; }
    private bool System.ComponentModel.IBindingList.IsSorted { get; }
    private ListSortDirection System.ComponentModel.IBindingList.SortDirection { get; }
    private PropertyDescriptor System.ComponentModel.IBindingList.SortProperty { get; }
    private bool System.ComponentModel.IBindingList.SupportsChangeNotification { get; }
    private bool System.ComponentModel.IBindingList.SupportsSearching { get; }
    private bool System.ComponentModel.IBindingList.SupportsSorting { get; }
    private bool System.ComponentModel.IBindingListView.SupportsAdvancedSorting { get; }
    private bool System.ComponentModel.IBindingListView.SupportsFiltering { get; }
    private ListSortDescriptionCollection System.ComponentModel.IBindingListView.SortDescriptions { get; }
    [LocalizableCategoryAttribute("Eco.Handles.HandlesStringRes", "sCategoryBehaviour")]
[LocalizableDescriptionAttribute("Eco.Handles.HandlesStringRes", "sPropertyFilter")]
[BrowsableAttribute("True")]
[DefaultValueAttribute("")]
public string Filter { get; public set; }
    public Predicate`1<object> FilterPredicateCallback { get; public set; }
    protected bool IsInitializing { get; private set; }
    protected virtual bool get_AutoQueue();
    [CompilerGeneratedAttribute]
public string get_RefName();
    [CompilerGeneratedAttribute]
public void set_RefName(string value);
    public object GetCell(int x, int y);
    public RenderedTuplePropertyDescriptor GetPropertyDescriptorForColumn(string name);
    private sealed virtual override void Eco.Handles.INotifyOnIdle.NotifyOnIdle();
    protected virtual void Dispose(bool disposing);
    public IList GetList();
    public IList get_List();
    [CompilerGeneratedAttribute]
protected void set_IsDisposed(bool value);
    [CompilerGeneratedAttribute]
protected bool get_IsDisposed();
    private void SetupProperties();
    private void EnsureHandleAdapter();
    private void ElementHandle_ListChanged(object sender, ListChangedEventArgs e);
    private HandleAdapter get_HandleAdapter();
    private bool ColumnNameExists(string name);
    private static AbstractColumn MakeNewColumn(IStructuralFeature sf);
    private static bool ShowMember(VisibilityKind visibility, MemberVisibility memberVisibility);
    public void CreateDefaultColumns();
    public ColumnCollection get_Columns();
    public object GetRenderedValue(int row, string columnName);
    public object GetRenderedValueDefaultOnNull(int row, string columnName, object returnthisifnull);
    public NestingCollection get_Nestings();
    public sealed virtual bool get_AddDefaultProperties();
    public void set_AddDefaultProperties(bool value);
    public bool get_AddDefaultPropertiesSkipDelayedFetch();
    public void set_AddDefaultPropertiesSkipDelayedFetch(bool value);
    public bool get_AddDefaultPropertiesSkipDerived();
    public void set_AddDefaultPropertiesSkipDerived(bool value);
    public NullRowMode get_NullRowMode();
    public void set_NullRowMode(NullRowMode value);
    public bool get_AddSelfColumn();
    public void set_AddSelfColumn(bool value);
    public bool get_AddExternalId();
    public void set_AddExternalId(bool value);
    public bool get_AddDefaultNestings();
    public void set_AddDefaultNestings(bool value);
    public MemberVisibility get_MemberVisibility();
    public void set_MemberVisibility(MemberVisibility value);
    private void ColumnsOrNestingsChanged(object dummy1, EventArgs dummy2);
    private void OptionsChanged();
    public void add_DeriveValue(DeriveEventHandler value);
    public void remove_DeriveValue(DeriveEventHandler value);
    public void add_ReverseDeriveValue(ReverseDeriveEventHandler value);
    public void remove_ReverseDeriveValue(ReverseDeriveEventHandler value);
    public bool get_SupportSorting();
    public void set_SupportSorting(bool value);
    public FilterMode get_FilterMode();
    public void set_FilterMode(FilterMode value);
    public bool get_AllowNew();
    public void set_AllowNew(bool value);
    public object RenderElement(IElement element);
    public void SetRenderedElementProperty(object item, string propertyName, object value, bool autoConvert);
    protected abstract virtual IEcoTypeSystem GetTypeSystem();
    private sealed virtual override IEcoTypeSystem Eco.Services.IStaticContext.get_TypeSystem();
    protected abstract virtual IOclTypeService GetOclTypeService();
    protected abstract virtual IOclPsTypeService GetOclPsTypeService();
    protected abstract virtual IActionLanguageTypeService GetActionLanguageTypeService();
    private sealed virtual override IOclTypeService Eco.Services.IStaticContext.get_OclTypeService();
    private sealed virtual override IOclPsTypeService Eco.Services.IStaticContext.get_OclPsTypeService();
    private sealed virtual override IActionLanguageTypeService Eco.Services.IStaticContext.get_ActionLanguageTypeService();
    private sealed virtual override IExternalVariableList Eco.Services.IStaticContext.get_VariableList();
    protected abstract virtual IClassifier GetStaticUmlType();
    public sealed virtual IClassifier get_StaticUmlType();
    private sealed virtual override object Eco.ObjectRepresentation.IEcoServiceProvider.GetEcoService(Type serviceType);
    public sealed virtual T GetEcoService();
    private sealed virtual override T Eco.ObjectRepresentation.IEcoServiceProvider.GetEcoService(object key);
    protected abstract virtual object GetEcoService(Type serviceType);
    protected abstract virtual T GetEcoService(object key);
    public abstract virtual void RegisterEcoService(T service);
    public abstract virtual void RegisterEcoService(object key, T service);
    public sealed virtual void SubscribeToStaticContext(ISubscriber subscriber);
    protected virtual void EnsureInternalElement();
    public sealed virtual IElement get_Element();
    public T GetElementValue();
    public sealed virtual void SubscribeToElement(ISubscriber subscriber);
    public static void EnsureAllBindingLists();
    public void EnsureBindingList();
    private Publisher get_EnsuredPublisher();
    private void OnLastSub();
    protected void ElementChanged();
    protected IExternalVariableList MergeVariables(IExternalVariableList list1, IExternalVariableList list2);
    protected virtual IExternalVariableList EffectiveVariables();
    private Publisher get_EnsuredStaticContextPublisher();
    private void OnLastSubStaticContext();
    protected virtual void StaticContextChanged();
    protected void CheckType();
    protected IElement get_InternalElement();
    protected void set_InternalElement(IElement value);
    public bool get_Active();
    public void set_Active(bool value);
    public abstract virtual bool get_EffectiveEnabled();
    protected void UpdateActiveSubscription();
    protected abstract virtual void SubscribeToDownstreamActive(ISubscriber subscriber);
    private Publisher get_EnsuredActiveChangedPublisher();
    private void OnLastSubActiveChanged();
    protected virtual void EffectiveEnabledChanged();
    public sealed virtual void SubscribeToEffectiveEnabled(ISubscriber subscriber);
    [ObsoleteAttribute("Replaced by SubscribeToEffectiveEnabled")]
public void SubscribeToActive(ISubscriber subscriber);
    public bool get_Enabled();
    public void set_Enabled(bool value);
    public OclVariables get_Variables();
    public void set_Variables(OclVariables value);
    public abstract virtual bool UsesVariables(IOclVariables variables);
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    private sealed virtual override bool System.Collections.ICollection.get_IsSynchronized();
    private sealed virtual override int System.Collections.ICollection.get_Count();
    private sealed virtual override void System.Collections.ICollection.CopyTo(Array array, int index);
    private sealed virtual override object System.Collections.ICollection.get_SyncRoot();
    private sealed virtual override bool System.Collections.IList.get_IsReadOnly();
    private sealed virtual override object System.Collections.IList.get_Item(int index);
    private sealed virtual override void System.Collections.IList.set_Item(int index, object value);
    private sealed virtual override void System.Collections.IList.RemoveAt(int index);
    private sealed virtual override void System.Collections.IList.Insert(int index, object value);
    private sealed virtual override void System.Collections.IList.Remove(object value);
    private sealed virtual override bool System.Collections.IList.Contains(object value);
    private sealed virtual override void System.Collections.IList.Clear();
    private sealed virtual override int System.Collections.IList.IndexOf(object value);
    private sealed virtual override int System.Collections.IList.Add(object value);
    private sealed virtual override bool System.Collections.IList.get_IsFixedSize();
    private ITypedList GetTypedList();
    private sealed virtual override PropertyDescriptorCollection System.ComponentModel.ITypedList.GetItemProperties(PropertyDescriptor[] listAccessors);
    private sealed virtual override string System.ComponentModel.ITypedList.GetListName(PropertyDescriptor[] listAccessors);
    private IBindingListView GetBindingList();
    private sealed virtual override bool System.ComponentModel.IBindingList.get_AllowEdit();
    private sealed virtual override bool System.ComponentModel.IBindingList.get_AllowNew();
    private sealed virtual override bool System.ComponentModel.IBindingList.get_AllowRemove();
    private sealed virtual override bool System.ComponentModel.IBindingList.get_IsSorted();
    private sealed virtual override ListSortDirection System.ComponentModel.IBindingList.get_SortDirection();
    private sealed virtual override PropertyDescriptor System.ComponentModel.IBindingList.get_SortProperty();
    private sealed virtual override bool System.ComponentModel.IBindingList.get_SupportsChangeNotification();
    private sealed virtual override bool System.ComponentModel.IBindingList.get_SupportsSearching();
    private sealed virtual override bool System.ComponentModel.IBindingList.get_SupportsSorting();
    private sealed virtual override void System.ComponentModel.IBindingList.AddIndex(PropertyDescriptor property);
    [CompilerGeneratedAttribute]
public void add_AddNewObject(AddNewObjectHandler value);
    [CompilerGeneratedAttribute]
public void remove_AddNewObject(AddNewObjectHandler value);
    private sealed virtual override object System.ComponentModel.IBindingList.AddNew();
    private sealed virtual override void System.ComponentModel.IBindingList.ApplySort(PropertyDescriptor property, ListSortDirection direction);
    private sealed virtual override int System.ComponentModel.IBindingList.Find(PropertyDescriptor property, object key);
    private sealed virtual override void System.ComponentModel.IBindingList.RemoveIndex(PropertyDescriptor property);
    private sealed virtual override void System.ComponentModel.IBindingList.RemoveSort();
    private sealed virtual override bool System.ComponentModel.IBindingListView.get_SupportsAdvancedSorting();
    private sealed virtual override bool System.ComponentModel.IBindingListView.get_SupportsFiltering();
    private sealed virtual override ListSortDescriptionCollection System.ComponentModel.IBindingListView.get_SortDescriptions();
    private sealed virtual override void System.ComponentModel.IBindingListView.ApplySort(ListSortDescriptionCollection sortDescriptions);
    private sealed virtual override void System.ComponentModel.IBindingListView.RemoveFilter();
    public sealed virtual string get_Filter();
    public sealed virtual void set_Filter(string value);
    public Predicate`1<object> get_FilterPredicateCallback();
    public void set_FilterPredicateCallback(Predicate`1<object> value);
    [CompilerGeneratedAttribute]
public sealed virtual void add_ListChanged(ListChangedEventHandler value);
    [CompilerGeneratedAttribute]
public sealed virtual void remove_ListChanged(ListChangedEventHandler value);
    [CompilerGeneratedAttribute]
protected bool get_IsInitializing();
    [CompilerGeneratedAttribute]
private void set_IsInitializing(bool value);
    protected void DoEndInit();
    public sealed virtual void BeginInit();
    public sealed virtual void EndInit();
    [CompilerGeneratedAttribute]
private void <ElementChanged>b__128_0();
}
[TypeConverterAttribute("Eco.Handles.EventDerivedColumnConverter")]
public class Eco.Handles.EventDerivedColumn : AbstractColumn {
    private string m_TypeName;
    public string Expression { get; public set; }
    public string NullElementRepresentation { get; public set; }
    public bool EventDerivedValue { get; public set; }
    private IEcoTypeSystem Eco.Handles.IHasTypeSystem.TypeSystem { get; }
    private bool Eco.Handles.IHasTypeSystem.IsHookedUp { get; }
    [LocalizableCategoryAttribute("Eco.Handles.HandlesStringRes", "sCategoryDerivation")]
[LocalizableDescriptionAttribute("Eco.Handles.HandlesStringRes", "sPropertyTypeName")]
[EditorAttribute("Eco.Handles.Design.AnyTypeNameSelectorEditor, Eco.Handles.Design, Version=7.1.0.0, Culture=neutral, PublicKeyToken=46a833be9e90de8c", "System.Drawing.Design.UITypeEditor")]
[DefaultValueAttribute("")]
[BrowsableAttribute("True")]
public string TypeName { get; public set; }
    public virtual string get_Expression();
    public virtual void set_Expression(string value);
    public virtual string get_NullElementRepresentation();
    public virtual void set_NullElementRepresentation(string value);
    public virtual bool get_EventDerivedValue();
    public virtual void set_EventDerivedValue(bool value);
    private sealed virtual override IEcoTypeSystem Eco.Handles.IHasTypeSystem.get_TypeSystem();
    private sealed virtual override bool Eco.Handles.IHasTypeSystem.get_IsHookedUp();
    public virtual string get_TypeName();
    public virtual void set_TypeName(string value);
}
public class Eco.Handles.EventDerivedColumnConverter : AbstractColumnConverter {
    protected virtual Type GetTargetType();
}
public class Eco.Handles.ExceptionInDisplayArgs : EventArgs {
    public List`1<Exception> ListofExceptions;
}
[ToolboxBitmapAttribute("Eco.Handles.ExpressionHandle")]
[ToolboxItemAttribute("True")]
[DesignerAttribute("Eco.Handles.Design.ExpressionHandleDesigner, Eco.Handles.Design, Version=7.1.0.0, Culture=neutral, PublicKeyToken=46a833be9e90de8c", "System.ComponentModel.Design.IDesigner")]
public class Eco.Handles.ExpressionHandle : RootedHandle {
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
private EventHandler`1<EventArgs> BeforeDeriveExpressionIsEvaluated;
    private IClassifier m_CachedStaticType;
    private string m_Expression;
    private bool useSubscriptions;
    private IStaticContext Eco.Handles.IHasEditableExpression.StaticContext { get; }
    private ExpressionKind Eco.Handles.IHasEditableExpression.ExpressionKind { get; }
    private IClassifier Eco.Handles.IHasEditableExpression.ExpectedType { get; }
    [LocalizableCategoryAttribute("Eco.Handles.HandlesStringRes", "sCategoryOCL")]
[LocalizableDescriptionAttribute("Eco.Handles.HandlesStringRes", "sPropertyExpression")]
[EditorAttribute("Eco.Handles.Design.OclEditorWakeup, Eco.Handles.Design, Version=7.1.0.0, Culture=neutral, PublicKeyToken=46a833be9e90de8c", "System.Drawing.Design.UITypeEditor")]
[DefaultValueAttribute("")]
public string Expression { get; public set; }
    [LocalizableCategoryAttribute("Eco.Handles.HandlesStringRes", "sCategoryOCL")]
[LocalizableDescriptionAttribute("Eco.Handles.HandlesStringRes", "sPropertyUseSubscription")]
[DefaultValueAttribute("True")]
public bool UseSubscriptions { get; public set; }
    private sealed virtual override IStaticContext Eco.Handles.IHasEditableExpression.get_StaticContext();
    private sealed virtual override ExpressionKind Eco.Handles.IHasEditableExpression.get_ExpressionKind();
    private sealed virtual override IClassifier Eco.Handles.IHasEditableExpression.get_ExpectedType();
    protected virtual void DeriveAndSubscribe(ISubscriber valueChangeSubscriber, ISubscriber resubscribeSubscriber);
    [CompilerGeneratedAttribute]
public void add_BeforeDeriveExpressionIsEvaluated(EventHandler`1<EventArgs> value);
    [CompilerGeneratedAttribute]
public void remove_BeforeDeriveExpressionIsEvaluated(EventHandler`1<EventArgs> value);
    protected virtual void StaticContextChanged();
    protected sealed virtual IClassifier GetStaticUmlType();
    public sealed virtual string get_Expression();
    public sealed virtual void set_Expression(string value);
    public bool get_UseSubscriptions();
    public void set_UseSubscriptions(bool value);
}
public enum Eco.Handles.ExpressionKind : Enum {
    public int value__;
    public static ExpressionKind Ocl;
    public static ExpressionKind OclPs;
    public static ExpressionKind EcoActionLanguage;
}
public enum Eco.Handles.FilterMode : Enum {
    public int value__;
    public static FilterMode None;
    public static FilterMode Column;
    public static FilterMode Ocl;
    public static FilterMode PredicateCallback;
}
internal class Eco.Handles.FilterPredicateCallbackHandler : RenderedTupleFilter {
    private Predicate`1<object> _callback;
    public FilterPredicateCallbackHandler(Predicate`1<object> callback);
    public virtual bool Match(AbstractRenderedTuple row);
}
public class Eco.Handles.HandleAdapter : object {
    private IElementHandle m_Handle;
    private RenderedList m_RenderedList;
    private bool m_InQueue;
    private RenderedTupleDescriptor m_TupleDescriptor;
    public IList List { get; }
    private IEcoServiceProvider Eco.Handles.IRenderingContext.ServiceProvider { get; }
    public RenderedTupleDescriptor TupleDescriptor { get; }
    private bool Eco.Handles.ITupleRenderingContext.OwnerEnabled { get; }
    private bool Eco.Handles.ITupleRenderingContext.AddDefaultProperties { get; }
    private IElement Eco.ObjectRepresentation.IElementProvider.Element { get; }
    public HandleAdapter(IElementHandle handle);
    public virtual string ToString();
    public void SetupProperties(IEnumerable columns, bool addDefaultProperties, bool AddDefaultPropertiesSkipDelayedFetch, bool addDefaultNestings, bool addExternalId, bool addSelfColumn, MemberVisibility memberVisibility, INestingProvider nestings, bool designMode, NullRowMode nullRowMode, bool supportSorting, bool allowNew, FilterMode filterMode, bool addDefaultPropertiesSkipDerived);
    public IList get_List();
    private void Enqueue();
    public object GetRenderedTupleForElement(IElement element);
    public void EnsureCurrent();
    private void LazyUpdateOfTupleValue();
    private sealed virtual override IEcoServiceProvider Eco.Handles.IRenderingContext.get_ServiceProvider();
    public sealed virtual RenderedTupleDescriptor get_TupleDescriptor();
    private sealed virtual override void Eco.Handles.ITupleRenderingContext.PartOutOfDate();
    private sealed virtual override bool Eco.Handles.ITupleRenderingContext.get_OwnerEnabled();
    private sealed virtual override bool Eco.Handles.ITupleRenderingContext.get_AddDefaultProperties();
    private sealed virtual override IElement Eco.ObjectRepresentation.IElementProvider.get_Element();
    private sealed virtual override void Eco.ObjectRepresentation.ISubscribableElementProvider.SubscribeToElement(ISubscriber subscriber);
    [CompilerGeneratedAttribute]
private void <Enqueue>b__9_0();
    [CompilerGeneratedAttribute]
private void <EnsureCurrent>b__11_0();
}
public class Eco.Handles.HandlesStringRes : object {
    public static string sCircularReference { get; }
    public static string ComponentCategoryHandles { get; }
    public static string ComponentCategoryPersistence { get; }
    public static string sPropertyPersistenceMapper { get; }
    public static string sPropertyDefaultLinkFetchStrategy { get; }
    public static string sPropertyOptimisticLocking { get; }
    public static string sPropertyUpdateWholeObjects { get; }
    public static string sDeactivatingWithDirtyObjects { get; }
    public static string PropertyEnforceStringLength { get; }
    public static string sDeserializingActive { get; }
    public static string PropertyAllowDeactivateDirty { get; }
    public static string CantChangePMapperOnActiveSystem { get; }
    public static string DeserializationStreamEmpty { get; }
    public static string DeserializationEndOfStream { get; }
    public static string DeserializationNoEcoSpace { get; }
    public static string sPropertyColumns { get; }
    public static string sPropertyDeriveValue { get; }
    public static string sPropertyReverseDeriveValue { get; }
    public static string sPropertyEnabled { get; }
    public static string sPropertyVariables { get; }
    public static string sPropertyAddDefaultProperties { get; }
    public static string sNullRowMode { get; }
    public static string sPropertyAddDefaultNestings { get; }
    public static string sPropertyAddExternalId { get; }
    public static string sPropertyNestings { get; }
    public static string sPropertyMemberVisibility { get; }
    public static string sPropertyAddSelfColumn { get; }
    public static string sPropertyFilterMode { get; }
    public static string sPropertyAllowNew { get; }
    public static string sPropertySupportSorting { get; }
    public static string sPropertyFilter { get; }
    public static string sPropertyColumnName { get; }
    public static string sPropertyIsReadOnly { get; }
    public static string sPropertyAsExternalId { get; }
    public static string sPropertyNesting { get; }
    public static string sPropertyNested { get; }
    public static string sPropertyDerivationExpression { get; }
    public static string sPropertyNullElementRepresentation { get; }
    public static string sPropertyTypeName { get; }
    public static string sVariableRoot { get; }
    public static string sNotConnected { get; }
    public static string sTypeSystemProblems { get; }
    public static string sPropertyStaticValueTypeName { get; }
    public static string sPropertyEcoSpaceTypeName { get; }
    public static string sHandleHasNoStaticValueTypeName { get; }
    public static string sHandleHasNoEcoSpaceTypeName { get; }
    public static string sHandleHasNoEcoSpace { get; }
    public static string sPropertyExpression { get; }
    public static string sPropertyInitialValues { get; }
    public static string sPropertyMaxAnswers { get; }
    public static string sPropertyOffset { get; }
    public static string sOclPSHandleNotConnected { get; }
    public static string sOclPSHandleUnableToFindService { get; }
    public static string sPropertyVariableName { get; }
    public static string sPropertyElementHandle { get; }
    public static string sPropertyOclVariableCollection { get; }
    public static string sEcoSpaceNotSet { get; }
    public static string sTypeOfValueUnknown { get; }
    public static string sElementBelongsToAnotherEcoSpace { get; }
    public static string sPropertyRootHandle { get; }
    public static string HandleNotEnabled { get; }
    public static string sPropertyAddRootVariables { get; }
    public static string sCategoryPresentation { get; }
    public static string sCategoryPersistence { get; }
    public static string sCategoryOCL { get; }
    public static string sCategoryConnections { get; }
    public static string sCategoryTypes { get; }
    public static string sCategoryBinding { get; }
    public static string sCategoryNesting { get; }
    public static string sCategoryDerivation { get; }
    public static string sCategoryBehaviour { get; }
    public static string sDescriptorIsNotAProperty { get; }
    public static string sOwnerNotSet { get; }
    public static string sRootContextNotSet { get; }
    public static string sNoObjectsInParameter { get; }
    public static string sInternalIDFromOtherEcoSpace { get; }
    public static string sObjectIsDirtyOrTransient { get; }
    public static string sObjectIsTransient { get; }
    public static string sMemberIsDerived { get; }
    public static string sNoPersistenceControllerAvailable { get; }
    public static string sListContainsNullLocator { get; }
    public static string sCantUpdateTransientObject { get; }
    public static string sForeignObjectsInUpdateDatabase { get; }
    public static string sCantAccessVersionInfoWithoutAPersistenceMapper { get; }
    public static string sSupportsSyncIsNotEnabled { get; }
    public static string sNoRuntimeLicense { get; }
    public static string sWrongIDE { get; }
    public static string sWrongIDEShort { get; }
    public static string sNoLicense { get; }
    public static string sExpired { get; }
    public static string sLicensedForDifferentIDE { get; }
    public static string s4pack { get; }
    public static string s8pack { get; }
    public static string sSiteLicense { get; }
    public static string sSingleUserLicense { get; }
    public static string sNotLicensed { get; }
    public static string sLicenseHasExpired { get; }
    public static string sExpiredShort { get; }
    public static string LicenseStatus { get; }
    public static string sListIsReadOnly { get; }
    public static string sCannotSetAssociationEndDirectly { get; }
    public static string sCannotSetOrderNo_NotAReference { get; }
    public static string sMultiLinksNotModifiableInICache { get; }
    public static string sCannotSetLinkObjectReference { get; }
    public static string sCannotLinkLinkedSingleLink { get; }
    public static string sCannotLinkAssignedSingleLink { get; }
    public static string sCannotSetOrderNumOnUnassignedLink { get; }
    public static string sCannotSetValueOfNonembeddedLinkInCache { get; }
    public static string sCacheContentMismatch { get; }
    public static string sObjectNotDestroyable { get; }
    public static string ComponentCategoryDroopyEyes { get; }
    public static string sPropertyFileName { get; }
    public static string sPropertyCacheData { get; }
    public static string sWrongPMapperReturned { get; }
    public static string sObjectNotFoundInFile { get; }
    public static string sPersistenceHandleIsActive { get; }
    public static string sInconsistentUmlRtModel { get; }
    public static string sFileIsInconsistent { get; }
    public static string sFileWrittenSinceLastAccess { get; }
    public static string sPreconditionsNotAllowed { get; }
    public static string sPropertySyncHandler { get; }
    public static string sSyncNotActive { get; }
    public static string UnknownAutoincKey { get; }
    public static string sHelpSetFilename { get; }
    public static string sSpecifyXmlFile { get; }
    public static string sXmlFileFilter { get; }
    public static string XmlDocumentContainsNoDatablock { get; }
    public static string get_sCircularReference();
    public static string sNameNotUnique(object param0);
    public static string get_ComponentCategoryHandles();
    public static string get_ComponentCategoryPersistence();
    public static string sInvalidName(object param0);
    public static string get_sPropertyPersistenceMapper();
    public static string get_sPropertyDefaultLinkFetchStrategy();
    public static string get_sPropertyOptimisticLocking();
    public static string get_sPropertyUpdateWholeObjects();
    public static string get_sDeactivatingWithDirtyObjects();
    public static string get_PropertyEnforceStringLength();
    public static string get_sDeserializingActive();
    public static string get_PropertyAllowDeactivateDirty();
    public static string get_CantChangePMapperOnActiveSystem();
    public static string get_DeserializationStreamEmpty();
    public static string get_DeserializationEndOfStream();
    public static string get_DeserializationNoEcoSpace();
    public static string DeserializationIncompatibleVersions(object param0, object param1);
    public static string DeserializationIncompatibleModels(object param0, object param1);
    public static string DeserializationError(object param0);
    public static string ClassLimitReached(object param0);
    public static string sTypeMismatchInHandle(object param0, object param1);
    public static string sStaticTypeNotMatching(object param0, object param1);
    public static string get_sPropertyColumns();
    public static string get_sPropertyDeriveValue();
    public static string get_sPropertyReverseDeriveValue();
    public static string get_sPropertyEnabled();
    public static string get_sPropertyVariables();
    public static string get_sPropertyAddDefaultProperties();
    public static string get_sNullRowMode();
    public static string get_sPropertyAddDefaultNestings();
    public static string get_sPropertyAddExternalId();
    public static string get_sPropertyNestings();
    public static string get_sPropertyMemberVisibility();
    public static string get_sPropertyAddSelfColumn();
    public static string get_sPropertyFilterMode();
    public static string get_sPropertyAllowNew();
    public static string get_sPropertySupportSorting();
    public static string get_sPropertyFilter();
    public static string HandleHasNoPropertyNamedSo(object param0);
    public static string ParameterRowIsOutOfRange(object param0, object param1);
    public static string get_sPropertyColumnName();
    public static string get_sPropertyIsReadOnly();
    public static string get_sPropertyAsExternalId();
    public static string get_sPropertyNesting();
    public static string get_sPropertyNested();
    public static string get_sPropertyDerivationExpression();
    public static string get_sPropertyNullElementRepresentation();
    public static string get_sPropertyTypeName();
    public static string get_sVariableRoot();
    public static string get_sNotConnected();
    public static string sNotATypeSystemProvider(object param0);
    public static string sGetTypeSystemServiceMissing(object param0);
    public static string get_sTypeSystemProblems();
    public static string get_sPropertyStaticValueTypeName();
    public static string get_sPropertyEcoSpaceTypeName();
    public static string UnknownTypeName(object param0);
    public static string get_sHandleHasNoStaticValueTypeName();
    public static string get_sHandleHasNoEcoSpaceTypeName();
    public static string sUnableToResolveEcoSpaceTypeName(object param0);
    public static string get_sHandleHasNoEcoSpace();
    public static string get_sPropertyExpression();
    public static string get_sPropertyInitialValues();
    public static string get_sPropertyMaxAnswers();
    public static string get_sPropertyOffset();
    public static string get_sOclPSHandleNotConnected();
    public static string get_sOclPSHandleUnableToFindService();
    public static string get_sPropertyVariableName();
    public static string get_sPropertyElementHandle();
    public static string get_sPropertyOclVariableCollection();
    public static string get_sEcoSpaceNotSet();
    public static string get_sTypeOfValueUnknown();
    public static string get_sElementBelongsToAnotherEcoSpace();
    public static string get_sPropertyRootHandle();
    public static string get_HandleNotEnabled();
    public static string get_sPropertyAddRootVariables();
    public static string get_sCategoryPresentation();
    public static string get_sCategoryPersistence();
    public static string get_sCategoryOCL();
    public static string get_sCategoryConnections();
    public static string get_sCategoryTypes();
    public static string get_sCategoryBinding();
    public static string get_sCategoryNesting();
    public static string get_sCategoryDerivation();
    public static string get_sCategoryBehaviour();
    public static string get_sDescriptorIsNotAProperty();
    public static string get_sOwnerNotSet();
    public static string get_sRootContextNotSet();
    public static string get_sNoObjectsInParameter();
    public static string sClassNotVersioned(object param0);
    public static string sNoMemberWithName(object param0);
    public static string get_sInternalIDFromOtherEcoSpace();
    public static string sInvalidClassId(object param0);
    public static string sClassIsAbstract(object param0);
    public static string sClassHasNoModelId(object param0);
    public static string get_sObjectIsDirtyOrTransient();
    public static string get_sObjectIsTransient();
    public static string get_sMemberIsDerived();
    public static string get_sNoPersistenceControllerAvailable();
    public static string get_sListContainsNullLocator();
    public static string get_sCantUpdateTransientObject();
    public static string get_sForeignObjectsInUpdateDatabase();
    public static string get_sCantAccessVersionInfoWithoutAPersistenceMapper();
    public static string get_sSupportsSyncIsNotEnabled();
    public static string get_sNoRuntimeLicense();
    public static string get_sWrongIDE();
    public static string get_sWrongIDEShort();
    public static string get_sNoLicense();
    public static string sTrialLicense(object param0);
    public static string sFreeVersion(object param0);
    public static string get_sExpired();
    public static string get_sLicensedForDifferentIDE();
    public static string get_s4pack();
    public static string get_s8pack();
    public static string get_sSiteLicense();
    public static string get_sSingleUserLicense();
    public static string get_sNotLicensed();
    public static string get_sLicenseHasExpired();
    public static string get_sExpiredShort();
    public static string get_LicenseStatus();
    public static string get_sListIsReadOnly();
    public static string get_sCannotSetAssociationEndDirectly();
    public static string get_sCannotSetOrderNo_NotAReference();
    public static string get_sMultiLinksNotModifiableInICache();
    public static string get_sCannotSetLinkObjectReference();
    public static string get_sCannotLinkLinkedSingleLink();
    public static string get_sCannotLinkAssignedSingleLink();
    public static string get_sCannotSetOrderNumOnUnassignedLink();
    public static string get_sCannotSetValueOfNonembeddedLinkInCache();
    public static string get_sCacheContentMismatch();
    public static string get_sObjectNotDestroyable();
    public static string sCantInstansiateAbstract(object param0);
    public static string sIncompatibleAssignment(object param0, object param1, object param2, object param3);
    public static string get_ComponentCategoryDroopyEyes();
    public static string get_sPropertyFileName();
    public static string get_sPropertyCacheData();
    public static string get_sWrongPMapperReturned();
    public static string get_sObjectNotFoundInFile();
    public static string get_sPersistenceHandleIsActive();
    public static string get_sInconsistentUmlRtModel();
    public static string get_sFileIsInconsistent();
    public static string get_sFileWrittenSinceLastAccess();
    public static string get_sPreconditionsNotAllowed();
    public static string sUnsupportedCondition(object param0);
    public static string get_sPropertySyncHandler();
    public static string get_sSyncNotActive();
    public static string sFailedToLoadXmlFile(object param0, object param1);
    public static string get_UnknownAutoincKey();
    public static string get_sHelpSetFilename();
    public static string get_sSpecifyXmlFile();
    public static string get_sXmlFileFilter();
    public static string FilenameNotSet(object param0, object param1);
    public static string UnableToHandleAttribute(object param0, object param1, object param2, object param3, object param4);
    public static string InvalidAssociatedType(object param0, object param1, object param2, object param3);
    public static string UnknownAssociatedType(object param0, object param1, object param2);
    public static string UnknownAttribute(object param0, object param1);
    public static string UnknownLink(object param0, object param1);
    public static string ObjectWithNoId(object param0);
    public static string UnknownClass(object param0);
    public static string get_XmlDocumentContainsNoDatablock();
    public static string FailedCodederivedMember(object param0, object param1, object param2, object param3);
    public static string RecursivelyDerivedMember(object param0, object param1);
    public static string TriedToAddNullToMultilink(object param0, object param1);
    public static string TriedToInsertNullIntoMultilink(object param0, object param1);
}
public static class Eco.Handles.HandleUtils : object {
    public static IClassifier ItemType(IClassifier classifier);
}
public interface Eco.Handles.IColumn {
    public string Name { get; }
    public bool AsExternalId { get; }
    public bool IsReadOnly { get; }
    public string Expression { get; }
    public bool IsEventDerived { get; }
    public string TypeName { get; }
    public bool IsNested { get; }
    public string NestingName { get; }
    public string NullElementRepresentation { get; }
    public abstract virtual string get_Name();
    public abstract virtual bool get_AsExternalId();
    public abstract virtual bool get_IsReadOnly();
    public abstract virtual string get_Expression();
    public abstract virtual bool get_IsEventDerived();
    public abstract virtual string get_TypeName();
    public abstract virtual bool get_IsNested();
    public abstract virtual string get_NestingName();
    public abstract virtual string get_NullElementRepresentation();
}
public interface Eco.Handles.IEcoSpaceTypeLookupService {
    public abstract virtual Type GetEcoSpaceType(string name);
}
public interface Eco.Handles.IElementHandle {
    public bool EffectiveEnabled { get; }
    public bool AddDefaultProperties { get; }
    public abstract virtual bool get_EffectiveEnabled();
    public abstract virtual void SubscribeToStaticContext(ISubscriber subscriber);
    public abstract virtual void SubscribeToEffectiveEnabled(ISubscriber subscriber);
    public abstract virtual bool UsesVariables(IOclVariables variables);
    public abstract virtual bool get_AddDefaultProperties();
}
public interface Eco.Handles.IHasEditableExpression {
    public IStaticContext StaticContext { get; }
    public string Expression { get; public set; }
    public ExpressionKind ExpressionKind { get; }
    public IClassifier ExpectedType { get; }
    public abstract virtual IStaticContext get_StaticContext();
    public abstract virtual void set_Expression(string value);
    public abstract virtual string get_Expression();
    public abstract virtual ExpressionKind get_ExpressionKind();
    public abstract virtual IClassifier get_ExpectedType();
}
public interface Eco.Handles.IHasSecondEditableExpression {
    public IHasEditableExpression HasEditableExpression { get; }
    public abstract virtual IHasEditableExpression get_HasEditableExpression();
}
public interface Eco.Handles.IHasTypeSystem {
    public IEcoTypeSystem TypeSystem { get; }
    public bool IsHookedUp { get; }
    public abstract virtual IEcoTypeSystem get_TypeSystem();
    public abstract virtual bool get_IsHookedUp();
}
public interface Eco.Handles.IMaxLengthSupportProvider {
    public abstract virtual void SetMaxLength(object obj);
}
public interface Eco.Handles.INesting {
    public IEnumerable Columns { get; }
    public bool AddDefaultProperties { get; }
    public bool AddDefaultPropertiesSkipDelayedFetch { get; }
    public bool AddDefaultNestings { get; }
    public NullRowMode NullRowMode { get; }
    public abstract virtual IEnumerable get_Columns();
    public abstract virtual bool get_AddDefaultProperties();
    public abstract virtual bool get_AddDefaultPropertiesSkipDelayedFetch();
    public abstract virtual bool get_AddDefaultNestings();
    public abstract virtual NullRowMode get_NullRowMode();
}
[DefaultMemberAttribute("Item")]
public interface Eco.Handles.INestingProvider {
    public INesting Item { get; }
    public abstract virtual INesting get_Item(string name);
}
public interface Eco.Handles.INotifyOnIdle {
    public abstract virtual void NotifyOnIdle();
}
public interface Eco.Handles.IOclVariables {
    public IExternalVariableList VariableList { get; }
    public abstract virtual IExternalVariableList get_VariableList();
}
public interface Eco.Handles.IRemovableAction {
    public abstract virtual bool Match(object ownerForRevert);
}
public interface Eco.Handles.IRenderingContext {
    public IEcoServiceProvider ServiceProvider { get; }
    public abstract virtual IEcoServiceProvider get_ServiceProvider();
}
public interface Eco.Handles.IReorderableList {
    public bool SupportsMove { get; }
    public abstract virtual bool get_SupportsMove();
    public abstract virtual void Move(int from, int to);
}
public interface Eco.Handles.IRooted {
    public abstract virtual bool IsRootLinkedTo(IElementHandle handle);
}
public interface Eco.Handles.IStaticContextFromObject {
    public abstract virtual IStaticContext StaticContextForObject(object o);
    public abstract virtual IClassifier GetExpectedType(ExtenderProvidedPropertyAttribute prop, IStaticContext context);
}
public class Eco.Handles.ItemStaticContext : object {
    private IStaticContext m_AdaptedContext;
    private IEcoTypeSystem Eco.Services.IStaticContext.TypeSystem { get; }
    private IOclTypeService Eco.Services.IStaticContext.OclTypeService { get; }
    private IOclPsTypeService Eco.Services.IStaticContext.OclPsTypeService { get; }
    private IActionLanguageTypeService Eco.Services.IStaticContext.ActionLanguageTypeService { get; }
    private IExternalVariableList Eco.Services.IStaticContext.VariableList { get; }
    private IClassifier Eco.Services.IStaticContext.StaticUmlType { get; }
    public ItemStaticContext(IStaticContext adaptedContext);
    private sealed virtual override IEcoTypeSystem Eco.Services.IStaticContext.get_TypeSystem();
    private sealed virtual override IOclTypeService Eco.Services.IStaticContext.get_OclTypeService();
    private sealed virtual override IOclPsTypeService Eco.Services.IStaticContext.get_OclPsTypeService();
    private sealed virtual override IActionLanguageTypeService Eco.Services.IStaticContext.get_ActionLanguageTypeService();
    private sealed virtual override IExternalVariableList Eco.Services.IStaticContext.get_VariableList();
    private sealed virtual override IClassifier Eco.Services.IStaticContext.get_StaticUmlType();
}
public interface Eco.Handles.ITupleListRenderingContext {
}
public interface Eco.Handles.ITuplePropertyRenderingContext {
    public bool IsTestTuple { get; }
    public bool OwnerEnabled { get; }
    public bool AddDefaultProperties { get; }
    public abstract virtual void PropertyOutOfDate(string name);
    public abstract virtual bool get_IsTestTuple();
    public abstract virtual void SignalPropertyChanged(string name);
    public abstract virtual bool get_OwnerEnabled();
    public abstract virtual bool get_AddDefaultProperties();
}
public interface Eco.Handles.ITupleRenderingContext {
    public RenderedTupleDescriptor TupleDescriptor { get; }
    public bool OwnerEnabled { get; }
    public bool AddDefaultProperties { get; }
    public abstract virtual RenderedTupleDescriptor get_TupleDescriptor();
    public abstract virtual void PartOutOfDate();
    public abstract virtual bool get_OwnerEnabled();
    public abstract virtual bool get_AddDefaultProperties();
}
public class Eco.Handles.MaxLengthSupportFunctions : object {
    private static Dictionary`2<Type, IMaxLengthSupportProvider> MaxLengthDictionary;
    private static bool dictionaryInitialized;
    private static MaxLengthSupportFunctions();
    public static int GetMaxLength(string expression, IElementHandle handle, int def);
    public static int GetMaxLength(RenderedTuplePropertyDescriptor prop, IElementHandle handle, int def);
    public static void RegisterMaxLengthSupportProvider(IMaxLengthSupportProvider maxLengthSupportProvider, Type supportedType);
    private static void EnsureDictionaryInitialized();
    public static void RegisterMaxLengthSupportLibrary(Assembly assembly);
    public static void UpdateMaxLengths(IEnumerable objects);
    public static void UpdateMaxLengths(object obj);
}
[AttributeUsageAttribute("1")]
public class Eco.Handles.MaxLengthSupportLibraryAttribute : Attribute {
}
[AttributeUsageAttribute("4")]
public class Eco.Handles.MaxLengthSupportProviderAttribute : Attribute {
    public Type type;
    public MaxLengthSupportProviderAttribute(Type type);
}
public enum Eco.Handles.MemberVisibility : Enum {
    public int value__;
    public static MemberVisibility AllMembers;
    public static MemberVisibility ProtectedOrHigher;
    public static MemberVisibility PublicOnly;
}
public static class Eco.Handles.NameValidator : object {
    public static bool CheckNameIsValid(string name);
    public static void AssertNameIsValid(string name);
}
[TypeConverterAttribute("Eco.Handles.NestingConverter")]
public class Eco.Handles.Nesting : object {
    private NestingCollection m_Owner;
    private string m_Name;
    private string m_TypeName;
    private NullRowMode m_NullRowMode;
    private ColumnCollection m_Columns;
    private bool m_AddDefaultProperties;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
private bool <AddDefaultPropertiesSkipDelayedFetch>k__BackingField;
    private bool m_AddDefaultNestings;
    [BrowsableAttribute("False")]
[DesignerSerializationVisibilityAttribute("0")]
public IStaticContext RootContext { get; }
    internal IStaticContext AssertedRootContext { get; }
    unknown NestingCollection Owner {internal set; }
    [EditorAttribute("CollectionEditor", "UITypeEditor")]
[DesignerSerializationVisibilityAttribute("2")]
[LocalizableDescriptionAttribute("Eco.Handles.HandlesStringRes", "sPropertyColumns")]
public ColumnCollection Columns { get; }
    private IEnumerable Eco.Handles.INesting.Columns { get; }
    [LocalizableDescriptionAttribute("Eco.Handles.HandlesStringRes", "sPropertyAddDefaultProperties")]
[DefaultValueAttribute("True")]
public bool AddDefaultProperties { get; public set; }
    public bool AddDefaultPropertiesSkipDelayedFetch { get; public set; }
    [DefaultValueAttribute("True")]
public bool AddDefaultNestings { get; public set; }
    public string Name { get; public set; }
    public NullRowMode NullRowMode { get; public set; }
    [EditorAttribute("Eco.Handles.Design.NonCollectionTypeNameSelectorEditor, Eco.Handles.Design, Version=7.1.0.0, Culture=neutral, PublicKeyToken=46a833be9e90de8c", "System.Drawing.Design.UITypeEditor")]
public string TypeName { get; public set; }
    private IEcoTypeSystem Eco.Handles.IHasTypeSystem.TypeSystem { get; }
    private bool Eco.Handles.IHasTypeSystem.IsHookedUp { get; }
    private IEcoTypeSystem Eco.Services.IStaticContext.TypeSystem { get; }
    [BrowsableAttribute("False")]
[DesignerSerializationVisibilityAttribute("0")]
public IOclTypeService OclTypeService { get; }
    [BrowsableAttribute("False")]
[DesignerSerializationVisibilityAttribute("0")]
public IOclPsTypeService OclPsTypeService { get; }
    [BrowsableAttribute("False")]
[DesignerSerializationVisibilityAttribute("0")]
public IActionLanguageTypeService ActionLanguageTypeService { get; }
    [BrowsableAttribute("False")]
[DesignerSerializationVisibilityAttribute("0")]
public IExternalVariableList VariableList { get; }
    private IClassifier Eco.Services.IStaticContext.StaticUmlType { get; }
    public IStaticContext get_RootContext();
    internal IStaticContext get_AssertedRootContext();
    internal void set_Owner(NestingCollection value);
    private void Changed();
    private void ColumnsChanged(object dummy1, EventArgs dummy2);
    public ColumnCollection get_Columns();
    private sealed virtual override IEnumerable Eco.Handles.INesting.get_Columns();
    public sealed virtual bool get_AddDefaultProperties();
    public void set_AddDefaultProperties(bool value);
    [CompilerGeneratedAttribute]
public void set_AddDefaultPropertiesSkipDelayedFetch(bool value);
    [CompilerGeneratedAttribute]
public sealed virtual bool get_AddDefaultPropertiesSkipDelayedFetch();
    public sealed virtual bool get_AddDefaultNestings();
    public void set_AddDefaultNestings(bool value);
    private void CheckUniqueName(string name);
    public string get_Name();
    public void set_Name(string value);
    public sealed virtual NullRowMode get_NullRowMode();
    public void set_NullRowMode(NullRowMode value);
    public string get_TypeName();
    public void set_TypeName(string value);
    private sealed virtual override IEcoTypeSystem Eco.Handles.IHasTypeSystem.get_TypeSystem();
    private sealed virtual override bool Eco.Handles.IHasTypeSystem.get_IsHookedUp();
    private sealed virtual override IEcoTypeSystem Eco.Services.IStaticContext.get_TypeSystem();
    public sealed virtual IOclTypeService get_OclTypeService();
    public sealed virtual IOclPsTypeService get_OclPsTypeService();
    public sealed virtual IActionLanguageTypeService get_ActionLanguageTypeService();
    public sealed virtual IExternalVariableList get_VariableList();
    private sealed virtual override IClassifier Eco.Services.IStaticContext.get_StaticUmlType();
}
[DefaultMemberAttribute("Item")]
[ListBindableAttribute("False")]
public class Eco.Handles.NestingCollection : CollectionBase {
    private IStaticContext m_StaticContext;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
private EventHandler OnChange;
    public IStaticContext StaticContext { get; }
    public Nesting Item { get; }
    public INesting Item { get; }
    public NestingCollection(IStaticContext staticContext);
    public IStaticContext get_StaticContext();
    public Nesting get_Item(int index);
    public sealed virtual INesting get_Item(string name);
    public void Add(Nesting nesting);
    public int IndexOf(object value);
    public void AddRange(Nesting[] nestings);
    internal bool NameIsUnique(string name);
    private string GetUniqueName();
    internal void Changed();
    protected virtual void OnInsert(int index, object value);
    protected virtual void OnInsertComplete(int index, object value);
    protected virtual void OnClearComplete();
    protected virtual void OnRemoveComplete(int index, object value);
    [CompilerGeneratedAttribute]
public void add_OnChange(EventHandler value);
    [CompilerGeneratedAttribute]
public void remove_OnChange(EventHandler value);
}
public class Eco.Handles.NestingConverter : ExpandableObjectConverter {
    public virtual bool CanConvertTo(ITypeDescriptorContext context, Type destinationType);
    public virtual object ConvertTo(ITypeDescriptorContext context, CultureInfo culture, object value, Type destinationType);
}
public enum Eco.Handles.NullRowMode : Enum {
    public int value__;
    public static NullRowMode None;
    public static NullRowMode First;
    public static NullRowMode Last;
    public static NullRowMode IfEmpty;
}
[TypeConverterAttribute("Eco.Handles.OclColumnConverter")]
public class Eco.Handles.OclColumn : AbstractColumn {
    private string m_Expression;
    private string m_NullElementRepresentation;
    private IStaticContext Eco.Handles.IHasEditableExpression.StaticContext { get; }
    private ExpressionKind Eco.Handles.IHasEditableExpression.ExpressionKind { get; }
    private IClassifier Eco.Handles.IHasEditableExpression.ExpectedType { get; }
    [EditorAttribute("Eco.Handles.Design.OclEditorWakeup, Eco.Handles.Design, Version=7.1.0.0, Culture=neutral, PublicKeyToken=46a833be9e90de8c", "System.Drawing.Design.UITypeEditor")]
[DefaultValueAttribute("")]
[BrowsableAttribute("True")]
[DesignerSerializationVisibilityAttribute("1")]
[LocalizableCategoryAttribute("Eco.Handles.HandlesStringRes", "sCategoryDerivation")]
[LocalizableDescriptionAttribute("Eco.Handles.HandlesStringRes", "sPropertyDerivationExpression")]
public string Expression { get; public set; }
    [DefaultValueAttribute("<Null>")]
[BrowsableAttribute("True")]
[DesignerSerializationVisibilityAttribute("1")]
[LocalizableCategoryAttribute("Eco.Handles.HandlesStringRes", "sCategoryDerivation")]
[LocalizableDescriptionAttribute("Eco.Handles.HandlesStringRes", "sPropertyNullElementRepresentation")]
public string NullElementRepresentation { get; public set; }
    public bool EventDerivedValue { get; public set; }
    private sealed virtual override IStaticContext Eco.Handles.IHasEditableExpression.get_StaticContext();
    private sealed virtual override ExpressionKind Eco.Handles.IHasEditableExpression.get_ExpressionKind();
    private sealed virtual override IClassifier Eco.Handles.IHasEditableExpression.get_ExpectedType();
    public virtual string get_Expression();
    public virtual void set_Expression(string value);
    public virtual string get_NullElementRepresentation();
    public virtual void set_NullElementRepresentation(string value);
    public virtual bool get_EventDerivedValue();
    public virtual void set_EventDerivedValue(bool value);
}
public class Eco.Handles.OclColumnConverter : AbstractColumnConverter {
    protected virtual Type GetTargetType();
}
internal class Eco.Handles.OclFilter : RenderedTupleFilter {
    private string m_Filter;
    private IOclService m_OclService;
    public OclFilter(string filter, IOclService oclService);
    public virtual bool Match(AbstractRenderedTuple rt);
}
[ToolboxBitmapAttribute("Eco.Handles.OclPSHandle")]
[ToolboxItemAttribute("True")]
[DesignerAttribute("Eco.Handles.Design.OclPSHandleDesigner, Eco.Handles.Design, Version=7.1.0.0, Culture=neutral, PublicKeyToken=46a833be9e90de8c", "System.ComponentModel.Design.IDesigner")]
public class Eco.Handles.OclPSHandle : RootedHandle {
    private IClassifier m_CachedStaticType;
    private string m_Expression;
    private int m_MaxAnswers;
    private int m_Offset;
    private IStaticContext Eco.Handles.IHasEditableExpression.StaticContext { get; }
    private ExpressionKind Eco.Handles.IHasEditableExpression.ExpressionKind { get; }
    private IClassifier Eco.Handles.IHasEditableExpression.ExpectedType { get; }
    [LocalizableCategoryAttribute("Eco.Handles.HandlesStringRes", "sCategoryOCL")]
[LocalizableDescriptionAttribute("Eco.Handles.HandlesStringRes", "sPropertyExpression")]
[EditorAttribute("Eco.Handles.Design.OclEditorWakeup, Eco.Handles.Design, Version=7.1.0.0, Culture=neutral, PublicKeyToken=46a833be9e90de8c", "System.Drawing.Design.UITypeEditor")]
[DefaultValueAttribute("")]
public string Expression { get; public set; }
    [LocalizableCategoryAttribute("Eco.Interfaces.InterfacesStringRes", "sCategoryPersistenceTuning")]
[LocalizableDescriptionAttribute("Eco.Handles.HandlesStringRes", "sPropertyMaxAnswers")]
[DefaultValueAttribute("-1")]
public int MaxAnswers { get; public set; }
    [LocalizableCategoryAttribute("Eco.Interfaces.InterfacesStringRes", "sCategoryPersistenceTuning")]
[LocalizableDescriptionAttribute("Eco.Handles.HandlesStringRes", "sPropertyOffset")]
[DefaultValueAttribute("0")]
public int Offset { get; public set; }
    private sealed virtual override IStaticContext Eco.Handles.IHasEditableExpression.get_StaticContext();
    private sealed virtual override ExpressionKind Eco.Handles.IHasEditableExpression.get_ExpressionKind();
    private sealed virtual override IClassifier Eco.Handles.IHasEditableExpression.get_ExpectedType();
    protected virtual void DeriveAndSubscribe(ISubscriber valueChangeSubscriber, ISubscriber resubscribeSubscriber);
    protected virtual void StaticContextChanged();
    protected sealed virtual IClassifier GetStaticUmlType();
    public sealed virtual string get_Expression();
    public sealed virtual void set_Expression(string value);
    public int get_MaxAnswers();
    public void set_MaxAnswers(int value);
    public int get_Offset();
    public void set_Offset(int value);
    public void Execute();
}
[TypeConverterAttribute("Eco.Handles.Design.OclVariableConverter, Eco.Handles.Design, Version=7.1.0.0, Culture=neutral, PublicKeyToken=46a833be9e90de8c")]
public class Eco.Handles.OclVariable : object {
    private VariableDefinition variableDefinition;
    private OclVariableCollection m_Owner;
    [BrowsableAttribute("False")]
[DesignerSerializationVisibilityAttribute("0")]
internal IExternalVariable Variable { get; }
    [LocalizableCategoryAttribute("Eco.Handles.HandlesStringRes", "sCategoryOCL")]
[LocalizableDescriptionAttribute("Eco.Handles.HandlesStringRes", "sPropertyVariableName")]
public string VariableName { get; public set; }
    [LocalizableCategoryAttribute("Eco.Handles.HandlesStringRes", "sCategoryConnections")]
[LocalizableDescriptionAttribute("Eco.Handles.HandlesStringRes", "sPropertyElementHandle")]
[TypeConverterAttribute("Eco.Handles.OclVariableHandleConverter")]
public ElementHandle ElementHandle { get; public set; }
    public OclVariable(string variableName, ElementHandle elementHandle);
    public OclVariable(OclVariable oclVariable);
    public bool LinksToHandle(ElementHandle handle);
    internal void SetOwner(OclVariableCollection value);
    internal bool CanSetHandleTo(ElementHandle value);
    private void SetDefinition(string variableName, ElementHandle elementHandle);
    internal IExternalVariable get_Variable();
    public virtual string ToString();
    private void CheckUniqueName(string name);
    public string get_VariableName();
    public void set_VariableName(string value);
    public ElementHandle get_ElementHandle();
    public void set_ElementHandle(ElementHandle value);
}
[DefaultMemberAttribute("Item")]
public class Eco.Handles.OclVariableCollection : CollectionBase {
    private Publisher _publisher;
    internal OclVariables Owner;
    private ElementSubscriberAdapter subscriber;
    private IExternalVariable Eco.ObjectRepresentation.IExternalVariableList.Item { get; }
    private IExternalVariable Eco.ObjectRepresentation.IExternalVariableList.Item { get; }
    private Publisher EnsuredPublisher { get; }
    public OclVariable Item { get; }
    public OclVariableCollection(OclVariables owner);
    private sealed virtual override IExternalVariable Eco.ObjectRepresentation.IExternalVariableList.get_Item(int index);
    private sealed virtual override IEnumerator Eco.ObjectRepresentation.IExternalVariableList.GetEnumerator();
    private sealed virtual override IExternalVariable Eco.ObjectRepresentation.IExternalVariableList.get_Item(string name);
    private sealed virtual override void Eco.ObjectRepresentation.IExternalVariableList.Subscribe(ISubscriber subscriber);
    private Publisher get_EnsuredPublisher();
    private void OnLastSub();
    internal void Changed();
    internal bool NameIsUnique(string name);
    private string StringGetUniqueName();
    public OclVariable get_Item(int index);
    protected virtual void OnInsert(int index, object value);
    protected virtual void OnInsertComplete(int index, object value);
    public void Add(OclVariable oclVariable);
    public void Remove(OclVariable oclVariable);
    public void AddRange(OclVariable[] oclVariables);
    public static OclVariableCollection Merge(OclVariableCollection baseVars, OclVariableCollection overrideVars);
}
internal class Eco.Handles.OclVariableHandleConverter : ReferenceConverter {
    public OclVariableHandleConverter(Type type);
    protected virtual bool IsValueAllowed(ITypeDescriptorContext context, object value);
}
[ToolboxBitmapAttribute("Eco.Handles.OclVariables")]
[ToolboxItemAttribute("True")]
[LocalizableCategoryAttribute("Eco.Handles.OclVariables", "ComponentCategoryHandles")]
public class Eco.Handles.OclVariables : Component {
    private OclVariableCollection oclVariableCollection;
    [EditorAttribute("CollectionEditor", "UITypeEditor")]
[DesignerSerializationVisibilityAttribute("2")]
[LocalizableCategoryAttribute("Eco.Handles.HandlesStringRes", "sCategoryOCL")]
[LocalizableDescriptionAttribute("Eco.Handles.HandlesStringRes", "sPropertyOclVariableCollection")]
public OclVariableCollection OclVariableCollection { get; }
    private IExternalVariableList Eco.Handles.IOclVariables.VariableList { get; }
    internal bool LinksToHandle(ElementHandle handle);
    public OclVariableCollection get_OclVariableCollection();
    private sealed virtual override IExternalVariableList Eco.Handles.IOclVariables.get_VariableList();
    public void CleanForFree();
    protected virtual void Dispose(bool disposing);
}
public class Eco.Handles.PropertyComparer : object {
    private ListSortDescriptionCollection m_SortDescriptions;
    public PropertyComparer(ListSortDescriptionCollection sortDescriptions);
    private sealed virtual override int System.Collections.Generic.IComparer<Eco.Handles.AbstractRenderedTuple>.Compare(AbstractRenderedTuple x, AbstractRenderedTuple y);
}
public class Eco.Handles.PrototypeEcoSpace : DefaultEcoSpace {
    private IEcoTypeSystem m_TypeSystem;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
private CodeDressingEnum <CodeDressing>k__BackingField;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
private DateTime <CodeDressingLatestCodeChangeTime>k__BackingField;
    private IEcoTypeSystem Eco.Services.ITypeSystemService.TypeSystem { get; }
    private IEcoServiceProvider Eco.Services.ITypeSystemService.StaticEcoServices { get; }
    public CodeDressingEnum CodeDressing { get; public set; }
    public DateTime CodeDressingLatestCodeChangeTime { get; public set; }
    public string CodeDressingInfo { get; }
    public PrototypeEcoSpace(IEcoTypeSystem typeSystem);
    private sealed virtual override IEcoTypeSystem Eco.Services.ITypeSystemService.get_TypeSystem();
    private sealed virtual override IEcoServiceProvider Eco.Services.ITypeSystemService.get_StaticEcoServices();
    protected virtual ITypeSystemService GetTypeSystemProvider();
    [CompilerGeneratedAttribute]
public CodeDressingEnum get_CodeDressing();
    [CompilerGeneratedAttribute]
public void set_CodeDressing(CodeDressingEnum value);
    [CompilerGeneratedAttribute]
public DateTime get_CodeDressingLatestCodeChangeTime();
    [CompilerGeneratedAttribute]
public void set_CodeDressingLatestCodeChangeTime(DateTime value);
    public string get_CodeDressingInfo();
}
[ToolboxBitmapAttribute("Eco.Handles.ReferenceHandle")]
[ToolboxItemAttribute("True")]
public class Eco.Handles.ReferenceHandle : RootHandle {
    private void DoSetElement(IElement value);
    public void SetElement(object value);
}
[DefaultMemberAttribute("Item")]
public class Eco.Handles.RenderedList : AbstractDeriver {
    private ITupleListRenderingContext m_Context;
    private ListSortDescriptionCollection m_SortDescriptions;
    private string m_Filter;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
private ListChangedEventHandler m_ListChanged;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
private Predicate`1<object> <FilterPredicateCallback>k__BackingField;
    private Dictionary`2<IElement, AbstractRenderedTuple> m_AllElementDictionary;
    private List`1<AbstractRenderedTuple> m_ItemList;
    private bool m_TupleDescriptorChanged;
    private bool m_DoMinimumChanges;
    private List`1<ListChangedEventArgs> pendingEvents;
    public string GetDebugInfoOfDeriver { get; }
    public bool CanYieldLock { get; }
    public IEcoServiceProvider ServiceProvider { get; }
    public ITupleListRenderingContext Context { get; }
    private IElementCollection ElementCollection { get; }
    private int Count { get; }
    private int System.Collections.ICollection.Count { get; }
    private bool System.Collections.ICollection.IsSynchronized { get; }
    private object System.Collections.ICollection.SyncRoot { get; }
    private bool System.Collections.IList.IsFixedSize { get; }
    private bool System.Collections.IList.IsReadOnly { get; }
    private object System.Collections.IList.Item { get; private set; }
    private bool Eco.Handles.IReorderableList.SupportsMove { get; }
    private bool System.ComponentModel.IBindingList.AllowEdit { get; }
    private bool System.ComponentModel.IBindingList.AllowNew { get; }
    private bool System.ComponentModel.IBindingList.AllowRemove { get; }
    private bool System.ComponentModel.IBindingList.IsSorted { get; }
    private ListSortDirection System.ComponentModel.IBindingList.SortDirection { get; }
    private PropertyDescriptor System.ComponentModel.IBindingList.SortProperty { get; }
    private bool System.ComponentModel.IBindingList.SupportsChangeNotification { get; }
    private bool System.ComponentModel.IBindingList.SupportsSearching { get; }
    private bool System.ComponentModel.IBindingList.SupportsSorting { get; }
    public bool SupportsAddNew { get; }
    private bool System.ComponentModel.IBindingListView.SupportsAdvancedSorting { get; }
    private bool System.ComponentModel.IBindingListView.SupportsFiltering { get; }
    private ListSortDescriptionCollection System.ComponentModel.IBindingListView.SortDescriptions { get; }
    private string System.ComponentModel.IBindingListView.Filter { get; private set; }
    public Predicate`1<object> FilterPredicateCallback { get; public set; }
    public string FirstItemAsString { get; }
    private AbstractRenderedTuple Item { get; }
    public RenderedList(ITupleListRenderingContext context);
    public virtual string get_GetDebugInfoOfDeriver();
    public virtual bool get_CanYieldLock();
    public virtual IEcoServiceProvider get_ServiceProvider();
    public ITupleListRenderingContext get_Context();
    public void CreateTestData(int minimumRows);
    public void MakeListsCurrent();
    public void SignalListChanged(ListChangedEventArgs args);
    private IList GetEnsuredList();
    private IElementCollection get_ElementCollection();
    private int get_Count();
    public object GetItem(int index);
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    private sealed virtual override int System.Collections.ICollection.get_Count();
    private sealed virtual override bool System.Collections.ICollection.get_IsSynchronized();
    private sealed virtual override object System.Collections.ICollection.get_SyncRoot();
    private sealed virtual override void System.Collections.ICollection.CopyTo(Array array, int index);
    private sealed virtual override bool System.Collections.IList.get_IsFixedSize();
    private sealed virtual override bool System.Collections.IList.get_IsReadOnly();
    private sealed virtual override object System.Collections.IList.get_Item(int index);
    private sealed virtual override void System.Collections.IList.set_Item(int index, object value);
    private sealed virtual override int System.Collections.IList.Add(object value);
    private sealed virtual override void System.Collections.IList.Clear();
    private sealed virtual override bool System.Collections.IList.Contains(object value);
    private sealed virtual override int System.Collections.IList.IndexOf(object value);
    private sealed virtual override bool Eco.Handles.IReorderableList.get_SupportsMove();
    private sealed virtual override void Eco.Handles.IReorderableList.Move(int from, int to);
    private sealed virtual override void System.Collections.IList.Insert(int index, object value);
    private void RemoveAt(int index);
    private sealed virtual override void System.Collections.IList.Remove(object value);
    private sealed virtual override void System.Collections.IList.RemoveAt(int index);
    private sealed virtual override PropertyDescriptorCollection System.ComponentModel.ITypedList.GetItemProperties(PropertyDescriptor[] listAccessors);
    private sealed virtual override string System.ComponentModel.ITypedList.GetListName(PropertyDescriptor[] listAccessors);
    private sealed virtual override bool System.ComponentModel.IBindingList.get_AllowEdit();
    private sealed virtual override bool System.ComponentModel.IBindingList.get_AllowNew();
    private sealed virtual override bool System.ComponentModel.IBindingList.get_AllowRemove();
    private sealed virtual override bool System.ComponentModel.IBindingList.get_IsSorted();
    private sealed virtual override ListSortDirection System.ComponentModel.IBindingList.get_SortDirection();
    private sealed virtual override PropertyDescriptor System.ComponentModel.IBindingList.get_SortProperty();
    private sealed virtual override bool System.ComponentModel.IBindingList.get_SupportsChangeNotification();
    private sealed virtual override bool System.ComponentModel.IBindingList.get_SupportsSearching();
    private sealed virtual override bool System.ComponentModel.IBindingList.get_SupportsSorting();
    private sealed virtual override void System.ComponentModel.IBindingList.AddIndex(PropertyDescriptor property);
    public bool get_SupportsAddNew();
    private sealed virtual override object System.ComponentModel.IBindingList.AddNew();
    private sealed virtual override void System.ComponentModel.IBindingList.ApplySort(PropertyDescriptor property, ListSortDirection direction);
    private sealed virtual override int System.ComponentModel.IBindingList.Find(PropertyDescriptor property, object key);
    private sealed virtual override void System.ComponentModel.IBindingList.RemoveIndex(PropertyDescriptor property);
    private sealed virtual override void System.ComponentModel.IBindingList.RemoveSort();
    [CompilerGeneratedAttribute]
private void add_m_ListChanged(ListChangedEventHandler value);
    [CompilerGeneratedAttribute]
private void remove_m_ListChanged(ListChangedEventHandler value);
    private sealed virtual override void System.ComponentModel.IBindingList.add_ListChanged(ListChangedEventHandler value);
    private sealed virtual override void System.ComponentModel.IBindingList.remove_ListChanged(ListChangedEventHandler value);
    private sealed virtual override bool System.ComponentModel.IBindingListView.get_SupportsAdvancedSorting();
    private sealed virtual override bool System.ComponentModel.IBindingListView.get_SupportsFiltering();
    private sealed virtual override ListSortDescriptionCollection System.ComponentModel.IBindingListView.get_SortDescriptions();
    private sealed virtual override void System.ComponentModel.IBindingListView.ApplySort(ListSortDescriptionCollection sortDescriptions);
    private sealed virtual override void System.ComponentModel.IBindingListView.RemoveFilter();
    private sealed virtual override string System.ComponentModel.IBindingListView.get_Filter();
    private sealed virtual override void System.ComponentModel.IBindingListView.set_Filter(string value);
    [CompilerGeneratedAttribute]
public Predicate`1<object> get_FilterPredicateCallback();
    [CompilerGeneratedAttribute]
public void set_FilterPredicateCallback(Predicate`1<object> value);
    public virtual string ToString();
    public string get_FirstItemAsString();
    public void TupleDescriptorChanged();
    private AbstractRenderedTuple get_Item(int index);
    protected virtual void DoNotifyOutOfDate();
    private static ListChangedEventArgs MergeEvents(ListChangedEventArgs oldEvent, ListChangedEventArgs newEvent);
    private static ListChangedEventArgs MergeEvents(ListChangedEventArgs oldEvent, ListChangedType lct, int index);
    private static bool ElementsEqual(IElement e1, IElement e2);
    private void SortingOrFilteringChanged();
    private ListChangedEventArgs EnsureElement(int index, AbstractRenderedTuple rt, ListChangedEventArgs oldEvent);
    private bool ContainsElement(IList`1<AbstractRenderedTuple> list, IElement element, int tryIndex);
    private List`1<AbstractRenderedTuple> FilterAndSort(List`1<AbstractRenderedTuple> list);
    private List`1<AbstractRenderedTuple> MakeNewList(IElement element);
    private ListChangedEventArgs UpdateItemList(IList`1<AbstractRenderedTuple> newList, ListChangedEventArgs args);
    protected virtual void DoDeriveAndSubscribe(bool subscribe);
    protected virtual void DoPostDeriveEvents();
    internal void ClearDueToDisable();
    [CompilerGeneratedAttribute]
private void <MakeNewList>b__114_1();
}
public class Eco.Handles.RenderedTestTuple : AbstractRenderedTuple {
    public bool IsTestTuple { get; }
    public RenderedTestTuple(ITupleRenderingContext owner, int testData);
    public virtual bool get_IsTestTuple();
}
public class Eco.Handles.RenderedTuple : AbstractRenderedTuple {
    public RenderedTuple(IElement element, ITupleRenderingContext owner);
}
public class Eco.Handles.RenderedTupleDescriptor : PropertyDescriptorCollection {
    private IStaticContext m_StaticContext;
    private DescriptorFactory m_DescriptorFactory;
    private NullRowMode m_NullRowMode;
    private bool m_SupportSorting;
    private bool m_AllowNew;
    private FilterMode m_FilterMode;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
private DeriveEventHandler DeriveValue;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
private ReverseDeriveEventHandler ReverseDeriveValue;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
private SignalListChangedHandler DescriptorsChanged;
    public DescriptorFactory DescriptorFactory { get; }
    public IStaticContext StaticContext { get; }
    public NullRowMode NullRowMode { get; }
    public FilterMode FilterMode { get; }
    public bool SupportSorting { get; }
    public bool AllowNew { get; }
    public bool IsDeriveValueAssigned { get; }
    public bool IsReverseDeriveValueAssigned { get; }
    public bool HasEditableProperty { get; }
    public RenderedTupleDescriptor(IStaticContext staticContext);
    public DescriptorFactory get_DescriptorFactory();
    public IStaticContext get_StaticContext();
    public NullRowMode get_NullRowMode();
    public FilterMode get_FilterMode();
    public bool get_SupportSorting();
    public bool get_AllowNew();
    [CompilerGeneratedAttribute]
public void add_DeriveValue(DeriveEventHandler value);
    [CompilerGeneratedAttribute]
public void remove_DeriveValue(DeriveEventHandler value);
    [CompilerGeneratedAttribute]
public void add_ReverseDeriveValue(ReverseDeriveEventHandler value);
    [CompilerGeneratedAttribute]
public void remove_ReverseDeriveValue(ReverseDeriveEventHandler value);
    [CompilerGeneratedAttribute]
public void add_DescriptorsChanged(SignalListChangedHandler value);
    [CompilerGeneratedAttribute]
public void remove_DescriptorsChanged(SignalListChangedHandler value);
    public bool get_IsDeriveValueAssigned();
    public bool get_IsReverseDeriveValueAssigned();
    internal void ExecuteDeriveValue(DeriveEventArgs e);
    internal void ExecuteReverseDeriveValue(ReverseDeriveEventArgs e);
    private bool NonExistingPropDesc(string aName);
    public bool get_HasEditableProperty();
    private void AddDescriptor(RenderedTuplePropertyDescriptor rtpd, bool designMode, List`1<ListChangedEventArgs> descriptorEvents);
    private static bool ShowMember(VisibilityKind visibility, MemberVisibility memberVisibility);
    public void SetupProperties(IEnumerable columns, bool addDefaultProperties, bool addDefaultPropertiesSkipDelayedFetch, bool addDefaultNestings, bool addExternalId, bool addSelfColumn, MemberVisibility memberVisibility, DescriptorFactory descriptorFacory, bool designMode, NullRowMode nullRowMode, bool supportSorting, bool allowNew, FilterMode filterMode, bool addDefaultPropertiesSkipDerived);
}
internal abstract class Eco.Handles.RenderedTupleFilter : object {
    public abstract virtual bool Match(AbstractRenderedTuple rt);
    public List`1<AbstractRenderedTuple> Filter(List`1<AbstractRenderedTuple> list);
}
public class Eco.Handles.RenderedTupleListProperty : AbstractRenderedTupleProperty {
    private RenderedList m_List;
    public string GetDebugInfoOfDeriver { get; }
    public bool CanYieldLock { get; }
    public IEcoServiceProvider ServiceProvider { get; }
    private IEcoServiceProvider Eco.Handles.IRenderingContext.ServiceProvider { get; }
    private RenderedTupleDescriptor Eco.Handles.ITupleRenderingContext.TupleDescriptor { get; }
    private bool Eco.Handles.ITupleRenderingContext.OwnerEnabled { get; }
    private bool Eco.Handles.ITupleRenderingContext.AddDefaultProperties { get; }
    public RenderedTupleListProperty(RenderedTuplePropertyDescriptor descriptor, ITuplePropertyRenderingContext owner);
    public virtual string get_GetDebugInfoOfDeriver();
    public virtual bool get_CanYieldLock();
    public virtual IEcoServiceProvider get_ServiceProvider();
    internal virtual void MakeListsCurrent();
    protected virtual object DoGetValue();
    public virtual void SetValue(object value);
    private sealed virtual override IEcoServiceProvider Eco.Handles.IRenderingContext.get_ServiceProvider();
    private sealed virtual override RenderedTupleDescriptor Eco.Handles.ITupleRenderingContext.get_TupleDescriptor();
    private sealed virtual override void Eco.Handles.ITupleRenderingContext.PartOutOfDate();
    private sealed virtual override bool Eco.Handles.ITupleRenderingContext.get_OwnerEnabled();
    private sealed virtual override bool Eco.Handles.ITupleRenderingContext.get_AddDefaultProperties();
}
public class Eco.Handles.RenderedTupleProperty : AbstractRenderedTupleProperty {
    public string GetDebugInfoOfDeriver { get; }
    public IEcoServiceProvider ServiceProvider { get; }
    public bool CanYieldLock { get; }
    public RenderedTupleProperty(RenderedTuplePropertyDescriptor descriptor, ITuplePropertyRenderingContext owner);
    public virtual string get_GetDebugInfoOfDeriver();
    public virtual IEcoServiceProvider get_ServiceProvider();
    public virtual bool get_CanYieldLock();
    public virtual string ToString();
    protected virtual object DoGetValue();
    public virtual void SetValue(object value);
}
public class Eco.Handles.RenderedTuplePropertyDescriptor : PropertyDescriptor {
    private RenderedTupleDescriptor m_OwningTupleDescriptor;
    private string m_Expression;
    private string m_NullElementRepresentation;
    private bool m_IsNested;
    private bool m_IsEventDerived;
    private bool m_AsExternalId;
    private string m_NestingName;
    private IClassifier m_StaticType;
    private bool m_Readonly;
    private bool m_ForceColumnToSignalNotReadOnlyInOrderToWorkAroundWPFBindingLimitation;
    private RenderedTupleDescriptor m_ItemProperties;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
private EventHandler`1<ValueChangeArgs> OnItemInColumnUpdated;
    private bool _isCleanedForFree;
    public bool AsExternalId { get; }
    public bool IsEventDerived { get; }
    public string NullElementRepresentation { get; }
    public string NestingName { get; }
    public string Expression { get; }
    public IClassifier StaticType { get; }
    public Type ComponentType { get; }
    public bool IsReadOnly { get; }
    public Type PropertyType { get; }
    public bool IsNested { get; }
    internal RenderedTuplePropertyDescriptor(RenderedTupleDescriptor owner, IColumn column);
    internal RenderedTuplePropertyDescriptor(string name, RenderedTupleDescriptor owner, string expression, bool nested, bool asExternalId);
    private bool GetReadOnly(IStaticContext staticContext, string expression);
    private IClassifier GetStaticType(IStaticContext staticContext, string expression);
    public bool get_AsExternalId();
    public bool get_IsEventDerived();
    public string get_NullElementRepresentation();
    public string get_NestingName();
    public string get_Expression();
    public IClassifier get_StaticType();
    private AbstractRenderedTupleProperty GetTupleProperty(object component);
    public virtual object GetValue(object component);
    public virtual void SetValue(object component, object value);
    public virtual Type get_ComponentType();
    public virtual bool get_IsReadOnly();
    public virtual Type get_PropertyType();
    public virtual bool CanResetValue(object component);
    public virtual void ResetValue(object component);
    public virtual bool ShouldSerializeValue(object component);
    public bool get_IsNested();
    public RenderedTupleDescriptor GetOwnItemProperties();
    private void Nested_ReverseDeriveValue(object sender, ReverseDeriveEventArgs e);
    private void Nested_DeriveValue(object sender, DeriveEventArgs e);
    public RenderedTupleDescriptor GetItemProperties(PropertyDescriptor[] listAccessors, int startIndex);
    public IElement DeriveAndSubscribe(IEcoServiceProvider serviceProvider, IElement rootElement, ISubscriber valueChangeSubscriber, ISubscriber resubscribeSubscriber);
    public void ReverseDerive(IEcoServiceProvider serviceProvider, IElement rootElement, object value);
    [CompilerGeneratedAttribute]
public void add_OnItemInColumnUpdated(EventHandler`1<ValueChangeArgs> value);
    [CompilerGeneratedAttribute]
public void remove_OnItemInColumnUpdated(EventHandler`1<ValueChangeArgs> value);
    internal void DoOnValueChanged(object o, EventArgs e);
    internal void DoOnItemInColumnUpdated(object o);
    public void CleanForFree();
}
public class Eco.Handles.RenderedTupleTestProperty : AbstractRenderedTupleProperty {
    private int m_TestData;
    public string GetDebugInfoOfDeriver { get; }
    public bool CanYieldLock { get; }
    public IEcoServiceProvider ServiceProvider { get; }
    public RenderedTupleTestProperty(RenderedTuplePropertyDescriptor descriptor, ITuplePropertyRenderingContext owner, int testData);
    public virtual string get_GetDebugInfoOfDeriver();
    public virtual bool get_CanYieldLock();
    public virtual IEcoServiceProvider get_ServiceProvider();
    protected virtual object DoGetValue();
    public virtual void SetValue(object value);
}
public class Eco.Handles.ReverseDeriveEventArgs : EventArgs {
    private string m_Name;
    private IElement m_RootElement;
    private object m_Value;
    private IEcoServiceProvider m_ServiceProvider;
    private IStaticContext m_StaticContext;
    public IEcoServiceProvider ServiceProvider { get; }
    public IOclService OclService { get; }
    public string Name { get; }
    public object Value { get; }
    public IStaticContext StaticContext { get; }
    public IElement RootElement { get; }
    public ReverseDeriveEventArgs(string name, IEcoServiceProvider serviceProvider, IElement rootElement, IStaticContext staticContext, object value);
    public IEcoServiceProvider get_ServiceProvider();
    public IOclService get_OclService();
    public string get_Name();
    public object get_Value();
    public IStaticContext get_StaticContext();
    public IElement get_RootElement();
}
public class Eco.Handles.ReverseDeriveEventHandler : MulticastDelegate {
    public ReverseDeriveEventHandler(object object, IntPtr method);
    public virtual void Invoke(object sender, ReverseDeriveEventArgs e);
    public virtual IAsyncResult BeginInvoke(object sender, ReverseDeriveEventArgs e, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
[DesignerAttribute("Eco.Handles.Design.RootedHandleDesigner, Eco.Handles.Design, Version=7.1.0.0, Culture=neutral, PublicKeyToken=46a833be9e90de8c", "System.ComponentModel.Design.IDesigner")]
public abstract class Eco.Handles.RootedHandle : ElementHandle {
    private AbstractDeriver deriver;
    private ElementHandle rootHandle;
    private RootElementChangedAdapter rootChangedAdapter;
    private RootStaticContextChangedAdapter rootStaticContextChangedAdapter;
    private VariableAdder variableAdder;
    private IExternalVariableList effectiveVariables;
    private bool addRootVariables;
    protected IStaticContext EffectiveRootStaticContext { get; }
    [LocalizableCategoryAttribute("Eco.Handles.HandlesStringRes", "sCategoryConnections")]
[LocalizableDescriptionAttribute("Eco.Handles.HandlesStringRes", "sPropertyRootHandle")]
[TypeConverterAttribute("Eco.Handles.RootHandleConverter")]
[BrowsableAttribute("True")]
[DefaultValueAttribute("")]
[EditorAttribute("Eco.Handles.Design.RootHandleEditor, Eco.Handles.Design, Version=7.1.0.0, Culture=neutral, PublicKeyToken=46a833be9e90de8c", "System.Drawing.Design.UITypeEditor")]
public ElementHandle RootHandle { get; public set; }
    [LocalizableCategoryAttribute("Eco.Handles.HandlesStringRes", "sCategoryOCL")]
[LocalizableDescriptionAttribute("Eco.Handles.HandlesStringRes", "sPropertyAddRootVariables")]
[BrowsableAttribute("True")]
[DefaultValueAttribute("False")]
public bool AddRootVariables { get; public set; }
    public bool EffectiveEnabled { get; }
    protected sealed virtual IOclTypeService GetOclTypeService();
    protected sealed virtual IOclPsTypeService GetOclPsTypeService();
    protected sealed virtual IActionLanguageTypeService GetActionLanguageTypeService();
    protected sealed virtual T GetEcoService(object key);
    protected sealed virtual object GetEcoService(Type serviceType);
    public virtual void RegisterEcoService(T service);
    public virtual void RegisterEcoService(object key, T service);
    public sealed virtual bool UsesVariables(IOclVariables variables);
    internal void EffectiveRootValueChanged();
    internal void RootStaticContextChanged();
    protected virtual void StaticContextChanged();
    protected IElement EffectiveRootValue();
    protected virtual void EffectiveEnabledChanged();
    protected abstract virtual void DeriveAndSubscribe(ISubscriber valueChangeSubscriber, ISubscriber resubscribeSubscriber);
    protected void MarkSubscriptionOutOfDate();
    protected virtual void EnsureInternalElement();
    protected IStaticContext get_EffectiveRootStaticContext();
    protected sealed virtual IEcoTypeSystem GetTypeSystem();
    public sealed virtual bool IsRootLinkedTo(IElementHandle handle);
    protected virtual void SubscribeToDownstreamActive(ISubscriber subscriber);
    public ElementHandle get_RootHandle();
    public void set_RootHandle(ElementHandle value);
    protected virtual IExternalVariableList EffectiveVariables();
    public bool get_AddRootVariables();
    public void set_AddRootVariables(bool value);
    public virtual bool get_EffectiveEnabled();
}
[DesignerAttribute("Eco.Handles.Design.RootHandleDesigner, Eco.Handles.Design, Version=7.1.0.0, Culture=neutral, PublicKeyToken=46a833be9e90de8c", "System.ComponentModel.Design.IDesigner")]
public abstract class Eco.Handles.RootHandle : ElementHandle {
    private EcoSpace m_EcoSpace;
    private string m_StaticValueTypeName;
    private Type m_EcoSpaceType;
    private string m_EcoSpaceTypeName;
    [BrowsableAttribute("False")]
[DesignerSerializationVisibilityAttribute("0")]
public EcoSpace EcoSpace { get; public set; }
    private IEcoTypeSystem Eco.Handles.IHasTypeSystem.TypeSystem { get; }
    private bool Eco.Handles.IHasTypeSystem.IsHookedUp { get; }
    [LocalizableCategoryAttribute("Eco.Handles.HandlesStringRes", "sCategoryTypes")]
[LocalizableDescriptionAttribute("Eco.Handles.HandlesStringRes", "sPropertyStaticValueTypeName")]
[EditorAttribute("Eco.Handles.Design.AnyTypeNameSelectorEditor, Eco.Handles.Design, Version=7.1.0.0, Culture=neutral, PublicKeyToken=46a833be9e90de8c", "System.Drawing.Design.UITypeEditor")]
[DefaultValueAttribute("")]
public string StaticValueTypeName { get; public set; }
    public bool EffectiveEnabled { get; }
    [BrowsableAttribute("False")]
[DesignerSerializationVisibilityAttribute("0")]
public Type EcoSpaceType { get; public set; }
    [LocalizableCategoryAttribute("Eco.Handles.HandlesStringRes", "sCategoryTypes")]
[LocalizableDescriptionAttribute("Eco.Handles.HandlesStringRes", "sPropertyEcoSpaceTypeName")]
[TypeConverterAttribute("Eco.Handles.Design.EcoSpaceTypeNameTypeConverter, Eco.Handles.Design, Version=7.1.0.0, Culture=neutral, PublicKeyToken=46a833be9e90de8c")]
[DefaultValueAttribute("")]
public string EcoSpaceTypeName { get; public set; }
    protected virtual void SubscribeToDownstreamActive(ISubscriber subscriber);
    protected sealed virtual IEcoTypeSystem GetTypeSystem();
    protected sealed virtual IOclTypeService GetOclTypeService();
    protected sealed virtual IOclPsTypeService GetOclPsTypeService();
    protected sealed virtual IActionLanguageTypeService GetActionLanguageTypeService();
    public sealed virtual bool UsesVariables(IOclVariables variables);
    private void EcoSpaceChanged();
    public EcoSpace get_EcoSpace();
    public void set_EcoSpace(EcoSpace value);
    private sealed virtual override IEcoTypeSystem Eco.Handles.IHasTypeSystem.get_TypeSystem();
    private sealed virtual override bool Eco.Handles.IHasTypeSystem.get_IsHookedUp();
    public string get_StaticValueTypeName();
    public void set_StaticValueTypeName(string value);
    protected virtual void Dispose(bool disposing);
    protected virtual void PossibleAllowNull();
    protected sealed virtual IClassifier GetStaticUmlType();
    protected sealed virtual object GetEcoService(Type serviceType);
    protected sealed virtual T GetEcoService(object key);
    public virtual void RegisterEcoService(T service);
    public virtual void RegisterEcoService(object key, T service);
    private IEcoServiceProvider GetInternalServiceProvider();
    private object InternalGetEcoService(Type serviceType);
    private T InternalGetEcoService(object key);
    public virtual bool get_EffectiveEnabled();
    protected virtual void EffectiveEnabledChanged();
    public Type get_EcoSpaceType();
    public void set_EcoSpaceType(Type value);
    public string get_EcoSpaceTypeName();
    public void set_EcoSpaceTypeName(string value);
    public void RefreshTypeInfo();
    protected void EnsureConfigured();
}
internal class Eco.Handles.RootHandleConverter : ReferenceConverter {
    public RootHandleConverter(Type type);
    protected virtual bool IsValueAllowed(ITypeDescriptorContext context, object value);
}
public class Eco.Handles.SignalListChangedHandler : MulticastDelegate {
    public SignalListChangedHandler(object object, IntPtr method);
    public virtual void Invoke(ListChangedEventArgs args);
    public virtual IAsyncResult BeginInvoke(ListChangedEventArgs args, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
public class Eco.Handles.TupleContext : object {
    private ITupleRenderingContext m_Owner;
    private IEcoServiceProvider Eco.Handles.IRenderingContext.ServiceProvider { get; }
    private bool Eco.Handles.ITupleRenderingContext.OwnerEnabled { get; }
    public RenderedTupleDescriptor TupleDescriptor { get; }
    private bool Eco.Handles.ITupleRenderingContext.AddDefaultProperties { get; }
    public TupleContext(ITupleRenderingContext owner);
    private sealed virtual override IEcoServiceProvider Eco.Handles.IRenderingContext.get_ServiceProvider();
    private sealed virtual override bool Eco.Handles.ITupleRenderingContext.get_OwnerEnabled();
    public sealed virtual RenderedTupleDescriptor get_TupleDescriptor();
    private sealed virtual override void Eco.Handles.ITupleRenderingContext.PartOutOfDate();
    private sealed virtual override bool Eco.Handles.ITupleRenderingContext.get_AddDefaultProperties();
}
public class Eco.Handles.ValueChangeArgs : EventArgs {
    public RenderedTuplePropertyDescriptor Descriptor;
    public RenderedTuple Row;
    public RenderedTupleProperty Cell;
}
[ToolboxBitmapAttribute("Eco.Handles.VariableHandle")]
[ToolboxItemAttribute("True")]
public class Eco.Handles.VariableHandle : RootHandle {
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
private bool <AllowNull>k__BackingField;
    private string m_InitialValues;
    private bool AllowNull { get; public set; }
    [DefaultValueAttribute("")]
[LocalizableCategoryAttribute("Eco.Handles.HandlesStringRes", "sCategoryBehaviour")]
[LocalizableDescriptionAttribute("Eco.Handles.HandlesStringRes", "sPropertyInitialValues")]
[EditorAttribute("System.ComponentModel.Design.MultilineStringEditor, System.Design", "System.Drawing.Design.UITypeEditor")]
public string InitialValues { get; public set; }
    private void EnsureVariable();
    [CompilerGeneratedAttribute]
public void set_AllowNull(bool value);
    [CompilerGeneratedAttribute]
private bool get_AllowNull();
    protected virtual void PossibleAllowNull();
    private void InitializeInternalElement();
    protected virtual void StaticContextChanged();
    public void SetElementValue(T value);
    protected virtual void EnsureInternalElement();
    protected virtual void EffectiveEnabledChanged();
    public string get_InitialValues();
    public void set_InitialValues(string value);
    public void ResetToInitialValue();
}
public static class Eco.ModelValidation.DesignStringRes2 : object {
    public static string UMVClassNameEmpty;
    public static string UMVExpressionNameEmpty;
    public static string UMVExpressionNameOCLReserved;
    public static string UMVSQLTableNameEmpty;
    public static string UMVSQLColumnNameEmpty;
    public static string UMVTableNameInvalid;
    public static string UMVColumnNameInvalid;
    public static string UMVAttributeUnknownMapper;
    public static string UMVAssociationEndIsMultiWithOtherEndComposite;
    public static string UMVSingleAssociationEndsEmbeddedInBothEnds;
    public static string UMVAssociationEndNeedsType;
    public static string UMVDerivedAssociationCanNotHaveClass;
    public static string UMVAssociationM2MNeedsClass;
    public static string UMVAssociationRolesNeedClass;
    public static string UMVAssociationClassCannotBePart;
    public static string UMVPersistenceSubClass;
    public static string UMVParentMappedClass;
    public static string UMVChildrenMappedClass;
    public static string UMVRecursiveMapping;
    public static string UMVParentMappedWithNotNullAttribute;
    public static string UMVAssociationDerivedAndPersistent;
    public static string UMVAssociationWithTwoAggregatedEnds;
    public static string UMVDuplicateAssociationEndName;
    public static string UMVVersionedClassWithNonVersionedSuperClass;
    public static string UMVAssociationEndIllegalQualifier;
    public static string UMVAssociationEndQualifiedAndMulti;
    public static string UMVRootClassMissing;
    public static string UMVLinkClassWithSuperClassAsEnd;
    public static string UMVAssociationAndClassNotEquallyPersistent;
    public static string UMVInvalidMappingModeTimeStampColumn;
    public static string UMVNoClassesInModel;
    public static string UMVUMLModelNotAssigned;
    public static string UMVLinkClassMustBeConcrete;
    public static string UMVMultipleSuperClasses;
    public static string UMVOtherEndNotSet;
    private static DesignStringRes2();
    internal static string F(string s, object p1);
    internal static string F(string s, object p1, object p2);
}
public interface Eco.ModelValidation.IModelValidator {
    public abstract virtual void ValidateModel(IEcoTypeSystem model, ValidationArgs validationArgs);
    public abstract virtual void ValidateClass(IClass class_, ValidationArgs validationArgs);
    public abstract virtual void ValidateAssociation(IAssociation association, ValidationArgs validationArgs);
    public abstract virtual void ValidateAssociationEnd(IAssociationEnd associationEnd, ValidationArgs validationArgs);
    public abstract virtual void ValidateAttribute(IAttribute attribute, ValidationArgs validationArgs);
    public abstract virtual void PostValidation(IEcoTypeSystem model, ValidationArgs validationArgs);
    public abstract virtual void Reset();
}
public class Eco.ModelValidation.ModelValidator : object {
    private static String[] OclReserved;
    private static ModelValidator();
    private static bool IsOclReservedWord(string name);
    private static bool IsValidSQLIdentifier(string name, SqlDatabaseConfig config);
    private static string ExpandedDBName(IModelElement element, SqlDatabaseConfig databaseConfig);
    private static void ValidateNames(IModelElement element, string elementName, ValidationArgs validationArgs);
    private static bool HasVersionedClass(IEcoTypeSystem model);
    public sealed virtual void ValidateModel(IEcoTypeSystem model, ValidationArgs validationArgs);
    private static bool HasNotNullMembers(IClass class_);
    public sealed virtual void ValidateClass(IClass class_, ValidationArgs validationArgs);
    public sealed virtual void ValidateAssociation(IAssociation association, ValidationArgs validationArgs);
    public sealed virtual void ValidateAssociationEnd(IAssociationEnd associationEnd, ValidationArgs validationArgs);
    public sealed virtual void ValidateAttribute(IAttribute attribute, ValidationArgs validationArgs);
    public sealed virtual void PostValidation(IEcoTypeSystem model, ValidationArgs validationArgs);
    public sealed virtual void Reset();
}
public class Eco.ModelValidation.ValidationArgs : object {
    private ModelValidationReport m_Report;
    private SqlDatabaseConfig m_DatabaseConfig;
    private IEcoServiceProvider m_ServiceProvider;
    public ModelValidationReport Report { get; }
    public SqlDatabaseConfig DatabaseConfig { get; }
    public IVariableFactoryService VariableFactoryService { get; }
    public IOclTypeService OclTypeService { get; }
    public IActionLanguageTypeService ActionLanguageTypeService { get; }
    public ValidationArgs(IEcoServiceProvider serviceProvider, SqlDatabaseConfig databaseConfig, ModelValidationReport report);
    public ModelValidationReport get_Report();
    public SqlDatabaseConfig get_DatabaseConfig();
    public IVariableFactoryService get_VariableFactoryService();
    public IOclTypeService get_OclTypeService();
    public IActionLanguageTypeService get_ActionLanguageTypeService();
}
public class Eco.ModelValidation.ValidatorPluginsValidator : object {
    private static List`1<IModelValidator> c_Registry;
    private SqlDatabaseConfig m_SQLDataBaseConfig;
    private ModelValidationReport m_Report;
    private IEcoServiceProvider m_ServiceProvider;
    private ValidationArgs m_ValidationArgs;
    public static List`1<IModelValidator> ValidatorPlugins { get; }
    public ModelValidationReport Report { get; }
    public ValidatorPluginsValidator(IEcoServiceProvider serviceProvider, SqlDatabaseConfig sqlDatabaseConfig);
    private static ValidatorPluginsValidator();
    public static List`1<IModelValidator> get_ValidatorPlugins();
    public ModelValidationReport get_Report();
    private void ValidateAssociation(IModelValidator validator, IAssociation association);
    private void ValidateClass(IModelValidator ModelValidator, IClass aClass);
    private void ValidateModel(IModelValidator validator);
    public void Validate();
}
public class Eco.ObjectImplementation.StateName : object {
    private string name;
    public string Name { get; }
    public StateName(string name);
    public sealed virtual string get_Name();
    public virtual string ToString();
}
internal class Eco.ObjectRepresentation.Impl.BagImpl : object {
    private static object BoxedOne;
    private int m_Count;
    private Dictionary`2<IElement, int> m_Hashtable;
    public int Count { get; }
    public BagImpl(int capacity, IEqualityComparer`1<IElement> ec);
    public BagImpl(IEqualityComparer`1<IElement> ec);
    private static BagImpl();
    public int get_Count();
    public int Occurrence(IElement value);
    public bool Contains(IElement value);
    public bool Equals(BagImpl bi);
    public void Add(IElement value);
    public void Remove(IElement value);
    internal void CleanForFree();
}
public class Eco.ObjectRepresentation.Impl.ConstraintInstance : AbstractDeriver {
    private BrokenHolderElement _BrokenHolderElement;
    private IObject _owner;
    private IConstraint _constraint;
    private ITuple _tuple;
    public IObject Owner { get; }
    public string Name { get; }
    public string Description { get; }
    public ErrorLevel ErrorLevel { get; }
    public bool IsDeleteConstraint { get; }
    public bool IsAutoGenerated { get; }
    public string ModeledName { get; }
    public bool Broken { get; }
    public string GetDebugInfoOfDeriver { get; }
    public bool CanYieldLock { get; }
    public IEcoServiceProvider ServiceProvider { get; }
    public ConstraintInstance(IObject owner, IConstraint constraint);
    private IClassifier GetBoolUmlType();
    public sealed virtual IObject get_Owner();
    public sealed virtual string get_Name();
    public sealed virtual string get_Description();
    public sealed virtual ErrorLevel get_ErrorLevel();
    public sealed virtual bool get_IsDeleteConstraint();
    public sealed virtual bool get_IsAutoGenerated();
    public sealed virtual string get_ModeledName();
    public sealed virtual bool get_Broken();
    public sealed virtual ITuple GetAsTuple();
    public sealed virtual IElement GetBrokenHolderElement();
    public virtual string get_GetDebugInfoOfDeriver();
    public virtual bool get_CanYieldLock();
    protected virtual void DoNotifyOutOfDate();
    protected virtual void DoDeriveAndSubscribe(bool subscribe);
    public virtual IEcoServiceProvider get_ServiceProvider();
    public virtual void CleanForFree();
}
public class Eco.ObjectRepresentation.Impl.ConstraintInstanceList : List`1<IConstraintInstance> {
    private IObject _owner;
    public ConstraintInstanceList(IObject owner);
    private void AddConstraintInstancesfor(IClass umlClass);
    public void CleanForFree();
}
public class Eco.ObjectRepresentation.Impl.ElementCollectionConstantImpl : ElementCollectionImpl`1<IElement> {
    public bool ReadOnly { get; }
    public bool SupportsAddNew { get; }
    public ElementCollectionConstantImpl(IElementImplContext elementImplContext, ICollectionType umlCollectionType, object initialValue);
    public ElementCollectionConstantImpl(IElementImplContext elementImplContext, ElementCollectionImpl`1<IElement> value);
    public virtual bool get_ReadOnly();
    public virtual bool get_SupportsAddNew();
    protected virtual IElement CloneToConstantImpl();
    protected virtual IElement CloneToVariableImpl();
}
[DefaultMemberAttribute("Item")]
internal class Eco.ObjectRepresentation.Impl.ElementCollectionContentImpl`1 : object {
    private bool m_NoDuplicates;
    private IList`1<T> m_List;
    private BagImpl m_BagImpl;
    private BagImpl m_delayedRemove;
    private static object BoxedOne;
    private static int CreateHashCount;
    private static int RemoveHashCount;
    private IElementImplContext m_ElementImplContext;
    private IList`1<T> List { get; }
    private BagImpl BagImpl { get; }
    public T Item { get; public set; }
    public int Count { get; }
    public ElementCollectionContentImpl`1(ElementCollectionContentImpl`1<T> original, bool mutable, IElementImplContext elementImplContext);
    public ElementCollectionContentImpl`1(bool NoDuplicates, IEnumerable collection, bool readOnly, IClassifier elementType, IElementImplContext elementImplContext);
    private static ElementCollectionContentImpl`1();
    private IList`1<T> get_List();
    public int GetIsEqualHashCode();
    private bool IsEqual(BagImpl bi);
    public bool IsEqual(ElementCollectionContentImpl`1<T> ec, bool ordered);
    public bool IsEqual(IElementCollection coll, bool ordered);
    public IEnumerator GetEnumerator();
    public void CopyTo(Array array, int index);
    private BagImpl get_BagImpl();
    private void RemoveFromHash(IElement value);
    public void Add(T value);
    public void Clear();
    public bool Contains(T value);
    public void Move(int fromPos, int toPos);
    public int IndexOf(T value);
    public void Insert(int index, T value);
    public void Remove(T value);
    public void RemoveAt(int index);
    public T get_Item(int index);
    public void set_Item(int index, T value);
    public int get_Count();
}
[DefaultMemberAttribute("Item")]
public abstract class Eco.ObjectRepresentation.Impl.ElementCollectionImpl`1 : object {
    private ICollectionType m_UmlCollectionType;
    private ElementCollectionContentImpl`1<T> m_Content;
    private bool m_ContentShared;
    private IElementImplContext m_ElementImplContext;
    protected IElementImplContext ElementImplContext { get; }
    private object System.Collections.ICollection.SyncRoot { get; }
    private bool System.Collections.ICollection.IsSynchronized { get; }
    public bool Ordered { get; }
    public bool NoDuplicates { get; }
    public ContentType ContentType { get; }
    public bool Mutable { get; }
    public bool ReadOnly { get; }
    public bool IsProperty { get; }
    public IClassifier UmlType { get; }
    public object AsObject { get; public set; }
    public ICollectionType UmlCollectionType { get; }
    public IElement Item { get; public set; }
    public bool SupportsMove { get; }
    public int Count { get; }
    public bool SupportsAddNew { get; }
    public bool SupportsRemoveAt { get; }
    private IElement Eco.ObjectRepresentation.IElementProvider.Element { get; }
    public IEcoServiceProvider ServiceProvider { get; }
    protected ElementCollectionImpl`1(IElementImplContext elementImplContext, ICollectionType umlCollectionType, object value);
    protected ElementCollectionImpl`1(IElementImplContext elementImplContext, ElementCollectionImpl`1<T> value);
    protected IElementImplContext get_ElementImplContext();
    protected void AutoSubscribe();
    public virtual IEnumerator GetEnumerator();
    public sealed virtual void CopyTo(Array array, int index);
    private sealed virtual override object System.Collections.ICollection.get_SyncRoot();
    private sealed virtual override bool System.Collections.ICollection.get_IsSynchronized();
    private sealed virtual override ElementCollectionContentImpl`1<T> Eco.ObjectRepresentation.Impl.ICollectionContentImplProvider<T>.ShareContent();
    private sealed virtual override ElementCollectionContentImpl`1<T> Eco.ObjectRepresentation.Impl.ICollectionContentImplProvider<T>.GetContent();
    public sealed virtual int GetIsEqualHashCode();
    public bool get_Ordered();
    public bool get_NoDuplicates();
    private void EnsureListPrivate();
    private void SetValue(object value);
    public sealed virtual IElement CloneValue(bool readOnly);
    protected abstract virtual IElement CloneToConstantImpl();
    protected abstract virtual IElement CloneToVariableImpl();
    public sealed virtual bool IsEqual(IElement element);
    public sealed virtual void Assign(IElement element);
    public virtual void SubscribeToValue(ISubscriber subscriber);
    public virtual void UnsubscribeFromValue(ISubscriber subscriber);
    private sealed virtual override void Eco.ObjectRepresentation.IElement.add_ValueChanged(EventHandler value);
    private sealed virtual override void Eco.ObjectRepresentation.IElement.remove_ValueChanged(EventHandler value);
    protected virtual void OnValueChanged();
    protected virtual void ElementAdded(IElement element);
    protected virtual void MajorChange();
    public virtual ContentType get_ContentType();
    public sealed virtual IElementCollection GetAsCollection();
    public virtual bool get_Mutable();
    public abstract virtual bool get_ReadOnly();
    public sealed virtual bool get_IsProperty();
    public sealed virtual IClassifier get_UmlType();
    protected T InternalGetByIndex(int index);
    protected virtual IElement GetByIndex(int index);
    public sealed virtual object get_AsObject();
    public sealed virtual void set_AsObject(object value);
    private sealed virtual override Tvalue Eco.ObjectRepresentation.IElement.GetValue();
    private sealed virtual override void Eco.ObjectRepresentation.IElement.SetValue(Tvalue value);
    private sealed virtual override IList`1<TItem> Eco.ObjectRepresentation.IElement.GetAsIList();
    public sealed virtual ICollectionType get_UmlCollectionType();
    private T CheckValue(IElement value);
    public sealed virtual void Add(IElement value, bool sendValueChanged);
    protected void InternalAdd(T value, bool sendValueChanged);
    internal void InternalClear(bool sendValueChanged);
    public sealed virtual void Clear(bool sendValueChanged);
    public sealed virtual bool Contains(IElement value);
    public sealed virtual int IndexOf(IElement value);
    public sealed virtual void Insert(int index, IElement value);
    public sealed virtual void Remove(IElement value);
    protected void InternalRemove(T value, bool sendValueChanged);
    public sealed virtual void RemoveAt(int index);
    public virtual void InternalRemoveAt(int index, bool sendValueChanged);
    public virtual void EnsureRange(int fromIndex, int toIndex);
    public sealed virtual IElement get_Item(int index);
    public sealed virtual void set_Item(int index, IElement value);
    public sealed virtual bool get_SupportsMove();
    public sealed virtual void Move(int fromPos, int toPos);
    public sealed virtual int get_Count();
    public abstract virtual bool get_SupportsAddNew();
    public virtual bool get_SupportsRemoveAt();
    public virtual IElement AddNew();
    private sealed virtual override IElement Eco.ObjectRepresentation.IElementProvider.get_Element();
    public sealed virtual IEcoServiceProvider get_ServiceProvider();
}
internal class Eco.ObjectRepresentation.Impl.ElementCollectionVariableImpl : ElementCollectionImpl`1<IElement> {
    private Publisher m_Publisher;
    public bool ReadOnly { get; }
    public bool SupportsAddNew { get; }
    private Publisher EnsuredPublisher { get; }
    public ElementCollectionVariableImpl(IElementImplContext elementImplContext, ICollectionType umlCollectionType, object initialValue);
    public ElementCollectionVariableImpl(IElementImplContext elementImplContext, ICollectionType umlCollectionType);
    public ElementCollectionVariableImpl(IElementImplContext elementImplContext, ElementCollectionImpl`1<IElement> value);
    public virtual bool get_ReadOnly();
    public virtual bool get_SupportsAddNew();
    protected virtual IElement CloneToConstantImpl();
    protected virtual IElement CloneToVariableImpl();
    private Publisher get_EnsuredPublisher();
    private void OnLastSub();
    public virtual void SubscribeToValue(ISubscriber subscriber);
    public virtual void UnsubscribeFromValue(ISubscriber subscriber);
    public void add_ValueChanged(EventHandler value);
    public void remove_ValueChanged(EventHandler value);
    protected virtual void OnValueChanged();
    [CompilerGeneratedAttribute]
private void <OnLastSub>b__12_0();
}
internal interface Eco.ObjectRepresentation.Impl.ICollectionContentImplProvider`1 {
    public abstract virtual ElementCollectionContentImpl`1<T> GetContent();
    public abstract virtual ElementCollectionContentImpl`1<T> ShareContent();
}
public interface Eco.ObjectRepresentation.Impl.IElementImplContext {
    public ISubscriber CurrentAutoSubscriber { get; }
    public IVariableFactoryService VariableFactoryService { get; }
    public IEcoTypeSystem TypeSystem { get; }
    public IObjectFactoryService ObjectFactoryService { get; }
    public IEcoServiceProvider ServiceProvider { get; }
    public abstract virtual ISubscriber get_CurrentAutoSubscriber();
    public abstract virtual IVariableFactoryService get_VariableFactoryService();
    public abstract virtual IEcoTypeSystem get_TypeSystem();
    public abstract virtual IObjectFactoryService get_ObjectFactoryService();
    public abstract virtual IEcoServiceProvider get_ServiceProvider();
}
internal abstract class Eco.ObjectRepresentation.Impl.ObjectCollectionAutoremoveImpl : ObjectCollectionImpl {
    private bool m_RemoveDeletedObjects;
    private IClass subscribedClass;
    private ObjectDeletedAdapter adapter;
    public bool RemoveDeletedObjects { get; public set; }
    protected ObjectCollectionAutoremoveImpl(IElementImplContext elementImplContext, ICollectionType umlCollectionType, object initialValue);
    protected ObjectCollectionAutoremoveImpl(IElementImplContext elementImplContext, ObjectCollectionImpl value);
    public virtual bool get_RemoveDeletedObjects();
    public virtual void set_RemoveDeletedObjects(bool value);
    protected virtual void ElementAdded(IElement element);
    protected virtual void MajorChange();
    private void SubscribeToAllObjects();
    private void SubscribeToObject(IObjectInstance obj);
    private void _ReceiveObjectDeleted(IObjectInstance obj);
}
internal class Eco.ObjectRepresentation.Impl.ObjectCollectionConstantImpl : ObjectCollectionAutoremoveImpl {
    public bool ReadOnly { get; }
    public bool SupportsAddNew { get; }
    public bool Mutable { get; }
    public ObjectCollectionConstantImpl(IElementImplContext elementImplContext, ICollectionType umlCollectionType, object initialValue);
    public ObjectCollectionConstantImpl(IElementImplContext elementImplContext, ObjectCollectionImpl value);
    public virtual bool get_ReadOnly();
    public virtual bool get_SupportsAddNew();
    public virtual bool get_Mutable();
}
public abstract class Eco.ObjectRepresentation.Impl.ObjectCollectionImpl : ElementCollectionImpl`1<IObjectInstance> {
    private Publisher m_Publisher;
    protected IObjectFactoryService ObjectFactoryService { get; }
    private Publisher EnsuredPublisher { get; }
    public IClass UmlClass { get; }
    public ContentType ContentType { get; }
    private IObjectInstance Eco.ObjectRepresentation.IObjectList.Item { get; private set; }
    public bool RemoveDeletedObjects { get; public set; }
    private IElement Eco.ObjectRepresentation.IElementProvider.Element { get; }
    private IElement Eco.ObjectRepresentation.IElementCollection.Item { get; private set; }
    protected ObjectCollectionImpl(IElementImplContext elementImplContext, ICollectionType umlCollectionType, object initialValue);
    protected ObjectCollectionImpl(IElementImplContext elementImplContext, ObjectCollectionImpl value);
    protected IObjectFactoryService get_ObjectFactoryService();
    private IEnumerable`1<IObjectInstance> GetAsCautiosList();
    [IteratorStateMachineAttribute("Eco.ObjectRepresentation.Impl.ObjectCollectionImpl/<GetEnumerator>d__5")]
public virtual IEnumerator GetEnumerator();
    [IteratorStateMachineAttribute("Eco.ObjectRepresentation.Impl.ObjectCollectionImpl/<System-Collections-Generic-IEnumerable<Eco-ObjectRepresentation-IObjectInstance>-GetEnumerator>d__6")]
private sealed virtual override IEnumerator`1<IObjectInstance> System.Collections.Generic.IEnumerable<Eco.ObjectRepresentation.IObjectInstance>.GetEnumerator();
    private Publisher get_EnsuredPublisher();
    private void OnLastSub();
    public virtual void SubscribeToValue(ISubscriber subscriber);
    public virtual void UnsubscribeFromValue(ISubscriber subscriber);
    private sealed virtual override void Eco.ObjectRepresentation.IElement.add_ValueChanged(EventHandler value);
    private sealed virtual override void Eco.ObjectRepresentation.IElement.remove_ValueChanged(EventHandler value);
    protected virtual void OnValueChanged();
    protected virtual IElement CloneToConstantImpl();
    protected virtual IElement CloneToVariableImpl();
    public sealed virtual IClass get_UmlClass();
    public virtual ContentType get_ContentType();
    public virtual IElement AddNew();
    private sealed virtual override void Eco.ObjectRepresentation.IObjectList.Add(IEcoObject value);
    private sealed virtual override void Eco.ObjectRepresentation.IObjectContainer.Clear();
    private sealed virtual override bool Eco.ObjectRepresentation.IObjectList.Contains(IEcoObject value);
    private sealed virtual override int Eco.ObjectRepresentation.IObjectList.IndexOf(IEcoObject value);
    private sealed virtual override void Eco.ObjectRepresentation.IObjectList.Insert(int index, IEcoObject value);
    private sealed virtual override void Eco.ObjectRepresentation.IObjectList.Remove(IEcoObject value);
    private sealed virtual override void Eco.ObjectRepresentation.IObjectList.EnsureIdsOnly();
    private sealed virtual override void Eco.ObjectRepresentation.IObjectList.EnsureObjects();
    private sealed virtual override IObjectList Eco.ObjectRepresentation.IObjectList.EnsureRelatedObjects(string memberName);
    public virtual void EnsureRange(int fromIndex, int toIndex);
    private sealed virtual override IObjectList Eco.ObjectRepresentation.IObjectContainer.GetAsList();
    protected virtual IElement GetByIndex(int index);
    private sealed virtual override IObjectInstance Eco.ObjectRepresentation.IObjectList.InternalGet(int index);
    private sealed virtual override IObjectInstance Eco.ObjectRepresentation.IObjectList.get_Item(int index);
    private sealed virtual override void Eco.ObjectRepresentation.IObjectList.set_Item(int index, IObjectInstance value);
    public abstract virtual bool get_RemoveDeletedObjects();
    public abstract virtual void set_RemoveDeletedObjects(bool value);
    public sealed virtual IEcoList`1<T> GetAsEcoList();
    private sealed virtual override IElement Eco.ObjectRepresentation.IElementProvider.get_Element();
    private sealed virtual override void Eco.ObjectRepresentation.IElementCollection.Add(IElement value, bool sendValueChanged);
    private sealed virtual override bool Eco.ObjectRepresentation.IElementCollection.Contains(IElement value);
    private sealed virtual override int Eco.ObjectRepresentation.IElementCollection.IndexOf(IElement value);
    private sealed virtual override void Eco.ObjectRepresentation.IElementCollection.Insert(int index, IElement value);
    private sealed virtual override void Eco.ObjectRepresentation.IElementCollection.Remove(IElement value);
    private sealed virtual override IElement Eco.ObjectRepresentation.IElementCollection.get_Item(int index);
    private sealed virtual override void Eco.ObjectRepresentation.IElementCollection.set_Item(int index, IElement value);
    [CompilerGeneratedAttribute]
private void <OnLastSub>b__11_0();
    [CompilerGeneratedAttribute]
private void <Eco.ObjectRepresentation.IObjectList.EnsureObjects>b__32_0();
    [CompilerGeneratedAttribute]
[DebuggerHiddenAttribute]
private IElement <>n__0(int index);
    [CompilerGeneratedAttribute]
[DebuggerHiddenAttribute]
private void <>n__1(int index, IElement value);
}
internal class Eco.ObjectRepresentation.Impl.ObjectCollectionVariableImpl : ObjectCollectionAutoremoveImpl {
    public bool ReadOnly { get; }
    public bool SupportsAddNew { get; }
    public bool Mutable { get; }
    public ObjectCollectionVariableImpl(IElementImplContext elementImplContext, ICollectionType umlCollectionType, object initialValue);
    public ObjectCollectionVariableImpl(IElementImplContext elementImplContext, ICollectionType umlCollectionType);
    public ObjectCollectionVariableImpl(IElementImplContext elementImplContext, ObjectCollectionImpl value);
    public virtual bool get_ReadOnly();
    public virtual bool get_SupportsAddNew();
    public virtual bool get_Mutable();
}
internal class Eco.ObjectRepresentation.Impl.ObjectNullImpl : object {
    private IElementImplContext m_ElementImplContext;
    private IClass m_UmlClass;
    private ConstraintInstanceList _ConstraintInstances;
    private ContentType Eco.ObjectRepresentation.IElement.ContentType { get; }
    private bool Eco.ObjectRepresentation.IElement.Mutable { get; }
    private bool Eco.ObjectRepresentation.IElement.ReadOnly { get; }
    private bool Eco.ObjectRepresentation.IElement.IsProperty { get; }
    public IClass UmlClass { get; }
    public IClassifier UmlType { get; }
    public object AsObject { get; public set; }
    private int Eco.ObjectRepresentation.IObjectContainer.Count { get; }
    private IPropertyCollection Eco.ObjectRepresentation.IFeatured.Properties { get; }
    public IEcoServiceProvider ServiceProvider { get; }
    private bool Eco.ObjectRepresentation.IObject.Deleted { get; }
    private bool Eco.ObjectRepresentation.IObject.IsDeletable { get; }
    public INonDeletableReason NonDeletableReason { get; }
    private IObjectInstance Eco.ObjectRepresentation.IObject.ObjectInstance { get; }
    private IObjectStateMachine Eco.ObjectRepresentation.IObjectInstance.StateMachine { get; }
    private string Eco.ObjectRepresentation.IObject.DefaultStringRepresentation { get; }
    private IElement Eco.ObjectRepresentation.IElementProvider.Element { get; }
    public bool IsNullInstance { get; }
    private IEcoServiceProvider Eco.ObjectRepresentation.IElement.ServiceProvider { get; }
    public IList`1<IConstraintInstance> ConstraintInstances { get; }
    public ObjectNullImpl(IElementImplContext elementImplContext, IClass umlClass);
    public ObjectNullImpl(IElementImplContext elementImplContext);
    private sealed virtual override int Eco.ObjectRepresentation.IElement.GetIsEqualHashCode();
    private sealed virtual override IElement Eco.ObjectRepresentation.IElement.CloneValue(bool readOnly);
    private sealed virtual override bool Eco.ObjectRepresentation.IElement.IsEqual(IElement element);
    private sealed virtual override void Eco.ObjectRepresentation.IElement.Assign(IElement element);
    public sealed virtual void SubscribeToValue(ISubscriber subscriber);
    public sealed virtual void UnsubscribeFromValue(ISubscriber subscriber);
    private sealed virtual override void Eco.ObjectRepresentation.IElement.add_ValueChanged(EventHandler value);
    private sealed virtual override void Eco.ObjectRepresentation.IElement.remove_ValueChanged(EventHandler value);
    private sealed virtual override ContentType Eco.ObjectRepresentation.IElement.get_ContentType();
    private sealed virtual override IElementCollection Eco.ObjectRepresentation.IElement.GetAsCollection();
    private sealed virtual override bool Eco.ObjectRepresentation.IElement.get_Mutable();
    private sealed virtual override bool Eco.ObjectRepresentation.IElement.get_ReadOnly();
    private sealed virtual override bool Eco.ObjectRepresentation.IElement.get_IsProperty();
    public sealed virtual IClass get_UmlClass();
    public sealed virtual IClassifier get_UmlType();
    public sealed virtual object get_AsObject();
    public sealed virtual void set_AsObject(object value);
    private sealed virtual override T Eco.ObjectRepresentation.IElement.GetValue();
    private sealed virtual override void Eco.ObjectRepresentation.IElement.SetValue(T value);
    private sealed virtual override IList`1<T> Eco.ObjectRepresentation.IElement.GetAsIList();
    private sealed virtual override int Eco.ObjectRepresentation.IObjectContainer.get_Count();
    private sealed virtual override void Eco.ObjectRepresentation.IObjectContainer.Clear();
    public sealed virtual IObjectList GetAsList();
    private sealed virtual override IPropertyCollection Eco.ObjectRepresentation.IFeatured.get_Properties();
    public IEcoServiceProvider get_ServiceProvider();
    private sealed virtual override void Eco.ObjectRepresentation.IObject.EnsureFetched();
    private sealed virtual override bool Eco.ObjectRepresentation.IObject.get_Deleted();
    private sealed virtual override bool Eco.ObjectRepresentation.IObject.get_IsDeletable();
    public sealed virtual INonDeletableReason get_NonDeletableReason();
    private sealed virtual override void Eco.ObjectRepresentation.IObject.Delete();
    private sealed virtual override IObjectInstance Eco.ObjectRepresentation.IObject.get_ObjectInstance();
    private sealed virtual override IObjectStateMachine Eco.ObjectRepresentation.IObjectInstance.get_StateMachine();
    private sealed virtual override object Eco.ObjectRepresentation.IObjectInstance.Invoke(IMethod method, Object[] parameters);
    private sealed virtual override object Eco.ObjectRepresentation.IObjectInstance.Invoke(string methodName, Object[] parameters);
    private sealed virtual override object Eco.ObjectRepresentation.IObjectInstance.Invoke(IMethod method, IElement[] parameters, bool disregardOverride);
    private sealed virtual override object Eco.ObjectRepresentation.IObjectInstance.InvokeQuery(IMethod method, IElement[] parameters, ISubscriber reevaluateSubscriber, ISubscriber resubscribeSubscriber, bool disregardOverride);
    private sealed virtual override string Eco.ObjectRepresentation.IObject.get_DefaultStringRepresentation();
    private sealed virtual override IElement Eco.ObjectRepresentation.IElementProvider.get_Element();
    private sealed virtual override IObjectInstance Eco.ObjectRepresentation.IEcoObject.AsIObject();
    public sealed virtual bool get_IsNullInstance();
    private sealed virtual override IEcoServiceProvider Eco.ObjectRepresentation.IElement.get_ServiceProvider();
    public sealed virtual IList`1<IConstraintInstance> get_ConstraintInstances();
}
internal class Eco.ObjectRepresentation.Impl.ObjectRefVariableImpl : object {
    private Publisher m_Publisher;
    private IClass m_StaticUmlClass;
    private IElementImplContext m_ElementImplContext;
    private IObjectInstance m_Object;
    private ContentType Eco.ObjectRepresentation.IElement.ContentType { get; }
    private bool Eco.ObjectRepresentation.IElement.Mutable { get; }
    private bool Eco.ObjectRepresentation.IElement.ReadOnly { get; }
    private bool Eco.ObjectRepresentation.IElement.IsProperty { get; }
    private IClassifier Eco.ObjectRepresentation.IElement.UmlType { get; }
    private IClass StaticUmlClass { get; }
    public IClass UmlClass { get; }
    public object AsObject { get; public set; }
    public int Count { get; }
    public IPropertyCollection Properties { get; }
    public IEcoServiceProvider ServiceProvider { get; }
    public bool Deleted { get; }
    public bool IsDeletable { get; }
    public INonDeletableReason NonDeletableReason { get; }
    private Publisher EnsuredPublisher { get; }
    private IClassifier Eco.ObjectRepresentation.IVariable.StaticUmlType { get; }
    public IObjectInstance ObjectInstance { get; }
    private IObjectInstance Eco.ObjectRepresentation.IObjectReference.ObjectInstance { get; private set; }
    private string Eco.ObjectRepresentation.IObject.DefaultStringRepresentation { get; }
    private IElement Eco.ObjectRepresentation.IElementProvider.Element { get; }
    public ObjectRefVariableImpl(IElementImplContext elementImplContext, IClass umlClass, IObjectInstance initialValue);
    public ObjectRefVariableImpl(IElementImplContext elementImplContext, IClass umlClass);
    private void AutoSubscribe();
    private sealed virtual override int Eco.ObjectRepresentation.IElement.GetIsEqualHashCode();
    private sealed virtual override bool Eco.ObjectRepresentation.IElement.IsEqual(IElement element);
    private sealed virtual override ContentType Eco.ObjectRepresentation.IElement.get_ContentType();
    private sealed virtual override bool Eco.ObjectRepresentation.IElement.get_Mutable();
    private sealed virtual override bool Eco.ObjectRepresentation.IElement.get_ReadOnly();
    private sealed virtual override bool Eco.ObjectRepresentation.IElement.get_IsProperty();
    private sealed virtual override IClassifier Eco.ObjectRepresentation.IElement.get_UmlType();
    private IClass get_StaticUmlClass();
    private void SetToNull();
    private void SetObject(IObject o);
    public sealed virtual IClass get_UmlClass();
    public sealed virtual void Assign(IElement element);
    public sealed virtual object get_AsObject();
    public sealed virtual void set_AsObject(object value);
    private sealed virtual override T Eco.ObjectRepresentation.IElement.GetValue();
    private sealed virtual override void Eco.ObjectRepresentation.IElement.SetValue(T value);
    private sealed virtual override IList`1<T> Eco.ObjectRepresentation.IElement.GetAsIList();
    public sealed virtual IElementCollection GetAsCollection();
    public sealed virtual IObjectList GetAsList();
    public sealed virtual int get_Count();
    public sealed virtual void Clear();
    public sealed virtual IPropertyCollection get_Properties();
    public sealed virtual IEcoServiceProvider get_ServiceProvider();
    public sealed virtual void EnsureFetched();
    public sealed virtual bool get_Deleted();
    public sealed virtual bool get_IsDeletable();
    public sealed virtual INonDeletableReason get_NonDeletableReason();
    public sealed virtual void Delete();
    public sealed virtual IElement CloneValue(bool readOnly);
    private Publisher get_EnsuredPublisher();
    private void OnLastSub();
    public sealed virtual void SubscribeToValue(ISubscriber subscriber);
    public sealed virtual void UnsubscribeFromValue(ISubscriber subscriber);
    private sealed virtual override void Eco.ObjectRepresentation.IElement.add_ValueChanged(EventHandler value);
    private sealed virtual override void Eco.ObjectRepresentation.IElement.remove_ValueChanged(EventHandler value);
    private void OnValueChanged();
    private sealed virtual override IClassifier Eco.ObjectRepresentation.IVariable.get_StaticUmlType();
    public sealed virtual IObjectInstance get_ObjectInstance();
    private sealed virtual override IObjectInstance Eco.ObjectRepresentation.IObjectReference.get_ObjectInstance();
    private sealed virtual override void Eco.ObjectRepresentation.IObjectReference.set_ObjectInstance(IObjectInstance value);
    private sealed virtual override string Eco.ObjectRepresentation.IObject.get_DefaultStringRepresentation();
    private sealed virtual override IElement Eco.ObjectRepresentation.IElementProvider.get_Element();
    private sealed virtual override IObjectInstance Eco.ObjectRepresentation.IEcoObject.AsIObject();
    [CompilerGeneratedAttribute]
private void <OnLastSub>b__52_0();
}
public class Eco.ObjectRepresentation.Impl.PrimitiveConstantImpl : PrimitiveImpl {
    public bool ReadOnly { get; }
    public PrimitiveConstantImpl(IElementImplContext elementImplContext, IDataType umlType, object initialValue);
    public virtual bool get_ReadOnly();
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
}
public abstract class Eco.ObjectRepresentation.Impl.PrimitiveImpl : object {
    private IDataType m_UmlDataType;
    private object m_AsObject;
    private IElementImplContext m_ElementImplContext;
    private static object c_Unassigned;
    public IElementImplContext ElementImplContext { get; }
    protected static object UnAssigned { get; }
    public ContentType ContentType { get; }
    public bool Mutable { get; }
    public bool ReadOnly { get; }
    public bool IsProperty { get; }
    public IClassifier UmlType { get; }
    public object AsObject { get; public set; }
    public IDataType UmlDataType { get; }
    private IElement Eco.ObjectRepresentation.IElementProvider.Element { get; }
    public IEcoServiceProvider ServiceProvider { get; }
    protected PrimitiveImpl(IElementImplContext elementImplContext, IDataType umlDataType, object value);
    private static PrimitiveImpl();
    public IElementImplContext get_ElementImplContext();
    private void AutoSubscribe();
    protected static object get_UnAssigned();
    private sealed virtual override int Eco.ObjectRepresentation.IElement.GetIsEqualHashCode();
    private void SetValue(object value);
    public virtual IElement CloneValue(bool readOnly);
    public virtual bool IsEqual(IElement element);
    public sealed virtual void Assign(IElement element);
    public virtual void SubscribeToValue(ISubscriber subscriber);
    public virtual void UnsubscribeFromValue(ISubscriber subscriber);
    private sealed virtual override void Eco.ObjectRepresentation.IElement.add_ValueChanged(EventHandler value);
    private sealed virtual override void Eco.ObjectRepresentation.IElement.remove_ValueChanged(EventHandler value);
    protected virtual void OnValueChanged();
    public sealed virtual ContentType get_ContentType();
    public sealed virtual IElementCollection GetAsCollection();
    public sealed virtual bool get_Mutable();
    public abstract virtual bool get_ReadOnly();
    public sealed virtual bool get_IsProperty();
    public sealed virtual IClassifier get_UmlType();
    public sealed virtual object get_AsObject();
    public sealed virtual void set_AsObject(object value);
    private sealed virtual override T Eco.ObjectRepresentation.IElement.GetValue();
    private sealed virtual override void Eco.ObjectRepresentation.IElement.SetValue(T value);
    private sealed virtual override IList`1<T> Eco.ObjectRepresentation.IElement.GetAsIList();
    public sealed virtual IDataType get_UmlDataType();
    private sealed virtual override IElement Eco.ObjectRepresentation.IElementProvider.get_Element();
    public sealed virtual IEcoServiceProvider get_ServiceProvider();
}
public class Eco.ObjectRepresentation.Impl.PrimitiveVariableImpl : PrimitiveImpl {
    private Publisher m_Publisher;
    private IClassifier Eco.ObjectRepresentation.IVariable.StaticUmlType { get; }
    public bool ReadOnly { get; }
    private Publisher EnsuredPublisher { get; }
    public PrimitiveVariableImpl(IElementImplContext elementImplContext, IDataType umlType, object initialValue);
    public PrimitiveVariableImpl(IElementImplContext elementImplContext, IDataType umlType);
    private sealed virtual override IClassifier Eco.ObjectRepresentation.IVariable.get_StaticUmlType();
    public virtual bool get_ReadOnly();
    private Publisher get_EnsuredPublisher();
    private void OnLastSub();
    public virtual void SubscribeToValue(ISubscriber subscriber);
    private sealed virtual override void Eco.ObjectRepresentation.IElement.add_ValueChanged(EventHandler value);
    private sealed virtual override void Eco.ObjectRepresentation.IElement.remove_ValueChanged(EventHandler value);
    protected virtual void OnValueChanged();
    [CompilerGeneratedAttribute]
private void <OnLastSub>b__9_0();
}
[DefaultMemberAttribute("Item")]
public class Eco.ObjectRepresentation.Impl.TupleImpl : object {
    private IElementImplContext m_ElementImplContext;
    private ITupleType m_UmlTupleType;
    private IElement[] m_Parts;
    private bool m_IsReadOnly;
    private Publisher _publisher;
    private EventHandler m_ValueChanged;
    private Publisher EnsuredPublisher { get; }
    internal IElementImplContext ElementImplContext { get; }
    public ITupleType UmlTupleType { get; }
    public IPropertyCollection Properties { get; }
    public ContentType ContentType { get; }
    public bool Mutable { get; }
    public bool ReadOnly { get; }
    public bool IsProperty { get; }
    public IClassifier UmlType { get; }
    public object AsObject { get; public set; }
    public int Count { get; }
    public IProperty Item { get; }
    public IProperty Item { get; }
    public IProperty Item { get; }
    private IElement Eco.ObjectRepresentation.IElementProvider.Element { get; }
    public IEcoServiceProvider ServiceProvider { get; }
    public TupleImpl(IElementImplContext elementImplContext, ITupleType umlTupleType, Object[] values, bool clone, bool isReadOnly);
    private Publisher get_EnsuredPublisher();
    private void LastSubCallback();
    internal IElementImplContext get_ElementImplContext();
    public static TupleImpl CreateTupleImpl(IElementImplContext elementImplContext, ITupleType umlTupleType, object obj, bool isReadOnly);
    public sealed virtual ITupleType get_UmlTupleType();
    public sealed virtual IPropertyCollection get_Properties();
    public sealed virtual IElement CloneValue(bool readOnly);
    public virtual bool Equals(object o);
    public virtual int GetHashCode();
    public sealed virtual bool IsEqual(IElement element);
    public sealed virtual int GetIsEqualHashCode();
    public sealed virtual void Assign(IElement element);
    public sealed virtual void SubscribeToValue(ISubscriber subscriber);
    public sealed virtual void UnsubscribeFromValue(ISubscriber subscriber);
    private void OnValueChanged(object sender, EventArgs e);
    private sealed virtual override void Eco.ObjectRepresentation.IElement.add_ValueChanged(EventHandler value);
    private sealed virtual override void Eco.ObjectRepresentation.IElement.remove_ValueChanged(EventHandler value);
    public sealed virtual ContentType get_ContentType();
    public sealed virtual IElementCollection GetAsCollection();
    public sealed virtual bool get_Mutable();
    public sealed virtual bool get_ReadOnly();
    public sealed virtual bool get_IsProperty();
    public sealed virtual IClassifier get_UmlType();
    public sealed virtual object get_AsObject();
    public sealed virtual void set_AsObject(object value);
    public sealed virtual T GetValue();
    public sealed virtual void SetValue(T value);
    public sealed virtual IList`1<T> GetAsIList();
    private IProperty CreatePropertyAdapter(int index);
    public sealed virtual int get_Count();
    public sealed virtual IProperty get_Item(int index);
    public sealed virtual IProperty get_Item(IStructuralFeature feature);
    public sealed virtual IProperty get_Item(string name);
    public sealed virtual IProperty GetByLoopbackIndex(int loopbackIndex);
    public sealed virtual void SubscribeToPropertyChanged(ISubscriber subscriber);
    private void AutoSubscribe();
    private sealed virtual override IElement Eco.ObjectRepresentation.IElementProvider.get_Element();
    private sealed virtual override AttributeCollection System.ComponentModel.ICustomTypeDescriptor.GetAttributes();
    private sealed virtual override string System.ComponentModel.ICustomTypeDescriptor.GetClassName();
    private sealed virtual override string System.ComponentModel.ICustomTypeDescriptor.GetComponentName();
    private sealed virtual override TypeConverter System.ComponentModel.ICustomTypeDescriptor.GetConverter();
    private sealed virtual override EventDescriptor System.ComponentModel.ICustomTypeDescriptor.GetDefaultEvent();
    private sealed virtual override PropertyDescriptor System.ComponentModel.ICustomTypeDescriptor.GetDefaultProperty();
    private sealed virtual override object System.ComponentModel.ICustomTypeDescriptor.GetEditor(Type editorBaseType);
    private sealed virtual override EventDescriptorCollection System.ComponentModel.ICustomTypeDescriptor.GetEvents(Attribute[] attributes);
    private sealed virtual override EventDescriptorCollection System.ComponentModel.ICustomTypeDescriptor.GetEvents();
    private sealed virtual override PropertyDescriptorCollection System.ComponentModel.ICustomTypeDescriptor.GetProperties(Attribute[] attributes);
    private sealed virtual override PropertyDescriptorCollection System.ComponentModel.ICustomTypeDescriptor.GetProperties();
    private sealed virtual override object System.ComponentModel.ICustomTypeDescriptor.GetPropertyOwner(PropertyDescriptor pd);
    public sealed virtual IProperty TryGetName(string name);
    public sealed virtual IEcoServiceProvider get_ServiceProvider();
}
public abstract class Eco.ObjectRepresentation.Impl.TuplePartImpl : object {
    private IStructuralFeature m_StructuralFeature;
    private TupleImpl m_Owner;
    private bool m_IsReadOnly;
    protected IElement Value { get; }
    public IStructuralFeature StructuralFeature { get; }
    public IFeatured Owner { get; }
    public ContentType ContentType { get; }
    public bool Mutable { get; }
    public bool ReadOnly { get; }
    public bool IsProperty { get; }
    public IClassifier UmlType { get; }
    public object AsObject { get; public set; }
    private IElement Eco.ObjectRepresentation.IElementProvider.Element { get; }
    public IEcoServiceProvider ServiceProvider { get; }
    public TuplePartImpl(IStructuralFeature structuralFeature, TupleImpl owner, bool isReadOnly);
    protected abstract virtual IElement GetValue();
    protected IElement get_Value();
    public sealed virtual IStructuralFeature get_StructuralFeature();
    public sealed virtual IFeatured get_Owner();
    public sealed virtual IElement CloneValue(bool readOnly);
    public sealed virtual bool IsEqual(IElement element);
    public sealed virtual int GetIsEqualHashCode();
    public sealed virtual void Assign(IElement element);
    public sealed virtual void SubscribeToValue(ISubscriber subscriber);
    public sealed virtual void UnsubscribeFromValue(ISubscriber subscriber);
    private sealed virtual override void Eco.ObjectRepresentation.IElement.add_ValueChanged(EventHandler value);
    private sealed virtual override void Eco.ObjectRepresentation.IElement.remove_ValueChanged(EventHandler value);
    public sealed virtual ContentType get_ContentType();
    public sealed virtual IElementCollection GetAsCollection();
    public sealed virtual bool get_Mutable();
    public sealed virtual bool get_ReadOnly();
    public sealed virtual bool get_IsProperty();
    public sealed virtual IClassifier get_UmlType();
    public sealed virtual object get_AsObject();
    public sealed virtual void set_AsObject(object value);
    public sealed virtual T GetValue();
    public sealed virtual void SetValue(T value);
    public sealed virtual IList`1<T> GetAsIList();
    private sealed virtual override IElement Eco.ObjectRepresentation.IElementProvider.get_Element();
    public sealed virtual IEcoServiceProvider get_ServiceProvider();
}
public class Eco.ObjectRepresentation.Impl.TuplePartImpl_Attr : TuplePartImpl {
    private IElement m_Value;
    public TuplePartImpl_Attr(IElement value, IStructuralFeature structuralFeature, TupleImpl owner, bool isReadOnly);
    protected virtual IElement GetValue();
}
[DefaultMemberAttribute("Item")]
public class Eco.ObjectRepresentation.Impl.TuplePartImpl_ElementCollection : TuplePartImpl {
    private IElementCollection m_Collection;
    public bool SupportsAddNew { get; }
    public bool SupportsRemoveAt { get; }
    public bool SupportsMove { get; }
    public IElement Item { get; public set; }
    public ICollectionType UmlCollectionType { get; }
    public int Count { get; }
    public bool IsSynchronized { get; }
    public object SyncRoot { get; }
    public TuplePartImpl_ElementCollection(IElementCollection value, IStructuralFeature structuralFeature, TupleImpl owner, bool isReadOnly);
    protected virtual IElement GetValue();
    public sealed virtual void Add(IElement value, bool sendValueChanged);
    public sealed virtual void Clear(bool sendValueChanged);
    public sealed virtual bool Contains(IElement value);
    public sealed virtual bool get_SupportsAddNew();
    public sealed virtual bool get_SupportsRemoveAt();
    public sealed virtual IElement AddNew();
    public sealed virtual int IndexOf(IElement value);
    public sealed virtual void Insert(int index, IElement value);
    public sealed virtual bool get_SupportsMove();
    public sealed virtual void Move(int fromPos, int toPos);
    public sealed virtual void Remove(IElement value);
    public sealed virtual void RemoveAt(int index);
    public sealed virtual void EnsureRange(int fromIndex, int toIndex);
    public sealed virtual IElement get_Item(int index);
    public sealed virtual void set_Item(int index, IElement value);
    public sealed virtual ICollectionType get_UmlCollectionType();
    public sealed virtual void CopyTo(Array array, int index);
    public sealed virtual int get_Count();
    public sealed virtual bool get_IsSynchronized();
    public sealed virtual object get_SyncRoot();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
}
public class Eco.ObjectRepresentation.Impl.TuplePartImpl_Object : TuplePartImpl {
    private IObject m_Object;
    public IPropertyCollection Properties { get; }
    public int Count { get; }
    public IClass UmlClass { get; }
    public bool Deleted { get; }
    public bool IsDeletable { get; }
    public INonDeletableReason NonDeletableReason { get; }
    public IObjectInstance ObjectInstance { get; }
    public string DefaultStringRepresentation { get; }
    public TuplePartImpl_Object(IObject value, IStructuralFeature structuralFeature, TupleImpl owner, bool isReadOnly);
    protected virtual IElement GetValue();
    public sealed virtual IPropertyCollection get_Properties();
    public sealed virtual void Clear();
    public sealed virtual int get_Count();
    public sealed virtual IClass get_UmlClass();
    public sealed virtual IObjectList GetAsList();
    public sealed virtual bool get_Deleted();
    public sealed virtual bool get_IsDeletable();
    public sealed virtual INonDeletableReason get_NonDeletableReason();
    public sealed virtual void Delete();
    public sealed virtual void EnsureFetched();
    public sealed virtual IObjectInstance get_ObjectInstance();
    public sealed virtual string get_DefaultStringRepresentation();
    private sealed virtual override IObjectInstance Eco.ObjectRepresentation.IEcoObject.AsIObject();
}
public class Eco.Ocl.Impl.ActionServiceImpl : OclImplBase {
    private bool _SideEffectsTurnedOff;
    public bool SideEffectsTurnedOff { get; }
    protected bool IsPsEvaluator { get; }
    protected bool IsEalEvaluator { get; }
    public ActionServiceImpl(OclSupport oclOperationSupport);
    public sealed virtual void TurnOffAllModelSideEffects(bool turnOff);
    public sealed virtual bool get_SideEffectsTurnedOff();
    public sealed virtual void Execute(string expression);
    protected virtual bool get_IsPsEvaluator();
    protected virtual bool get_IsEalEvaluator();
    public sealed virtual void Execute(string expression, IExternalVariableList vars);
    public sealed virtual void Execute(IElement root, string expression);
    public sealed virtual IElement Evaluate(string expression, IExternalVariableList vars);
    public sealed virtual IElement Evaluate(string expression);
    public sealed virtual IElement Evaluate(IElement root, string expression, IExternalVariableList vars);
    public sealed virtual IElement Evaluate(IElement root, IClassifier context, string expression, IExternalVariableList vars);
    private IElement BaseEvaluate(IElement root, IClassifier context, string expression, IExternalVariableList vars);
    public sealed virtual IElement Evaluate(IElement root, string expression);
    public sealed virtual void Execute(IElement root, string expression, IExternalVariableList vars);
}
public enum Eco.Ocl.Impl.ArgumentConformanceStatus : Enum {
    public int value__;
    public static ArgumentConformanceStatus PerfectMatch;
    public static ArgumentConformanceStatus Conforms;
    public static ArgumentConformanceStatus DoesntConform;
}
public class Eco.Ocl.Impl.DerivedElement : AbstractDeriver {
    private IElement fRoot;
    private IClassifier fUmlType;
    private IElement fValue;
    private Publisher m_Publisher;
    private string fExpression;
    private IOclService fEvaluator;
    private IEcoServiceProvider m_ServiceProvider;
    protected IElement Root { get; }
    public string GetDebugInfoOfDeriver { get; }
    public bool CanYieldLock { get; }
    protected string Expression { get; }
    public object AsObject { get; public set; }
    public ContentType ContentType { get; }
    public bool IsProperty { get; }
    public bool ReadOnly { get; }
    public bool Mutable { get; }
    public IClassifier UmlType { get; }
    private Publisher EnsuredPublisher { get; }
    private IElement Eco.ObjectRepresentation.IElementProvider.Element { get; }
    public IEcoServiceProvider ServiceProvider { get; }
    public DerivedElement(IElement root, IEcoServiceProvider serviceProvider, IOclService Evaluator, string Expression);
    protected IElement get_Root();
    public virtual string get_GetDebugInfoOfDeriver();
    public virtual bool get_CanYieldLock();
    protected string get_Expression();
    public sealed virtual void Assign(IElement Element);
    public sealed virtual IElement CloneValue(bool __ReadOnly);
    protected virtual void DoDeriveAndSubscribe(bool subscribe);
    protected virtual void DoNotifyOutOfDate();
    public sealed virtual IElementCollection GetAsCollection();
    public sealed virtual object get_AsObject();
    public sealed virtual void set_AsObject(object value);
    public sealed virtual T GetValue();
    public sealed virtual void SetValue(T value);
    public sealed virtual IList`1<T> GetAsIList();
    public virtual ContentType get_ContentType();
    public sealed virtual bool get_IsProperty();
    public sealed virtual bool get_ReadOnly();
    public sealed virtual bool get_Mutable();
    public sealed virtual IClassifier get_UmlType();
    public sealed virtual bool IsEqual(IElement Element);
    private Publisher get_EnsuredPublisher();
    private sealed virtual override void Eco.ObjectRepresentation.IElement.SubscribeToValue(ISubscriber subscriber);
    private sealed virtual override void Eco.ObjectRepresentation.IElement.UnsubscribeFromValue(ISubscriber subscriber);
    private sealed virtual override void Eco.ObjectRepresentation.IElement.add_ValueChanged(EventHandler value);
    private sealed virtual override void Eco.ObjectRepresentation.IElement.remove_ValueChanged(EventHandler value);
    public sealed virtual int GetIsEqualHashCode();
    private sealed virtual override IElement Eco.ObjectRepresentation.IElementProvider.get_Element();
    public virtual IEcoServiceProvider get_ServiceProvider();
    [CompilerGeneratedAttribute]
private void <get_EnsuredPublisher>b__39_0();
}
public interface Eco.Ocl.Impl.IInternalTypeAccess {
    public abstract virtual OclTypeImpl GetType();
}
public class Eco.Ocl.Impl.MDrivenOclEvaluatorVisitor : OclVisitor {
    private SubscriberPair fSubscribers;
    private OclSupport fHelp;
    private bool fsideeffectsAllowed;
    private Stack`1<OclVariableBinding> _activeloopvars;
    public static Stack`1<MDrivenOclEvaluatorVisitor> MDrivenOclEvaluatorVisitorCache;
    private bool _isStepper;
    private bool _isBreak;
    private OclNode _stoppedOnNode;
    private EventWaitHandle _stepperEvent;
    private Action _callbackOnStepStop;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
private StopObject <StopObject>k__BackingField;
    private Stack`1<OclVariableBinding> activeloopvars { get; }
    public int ActiveLoopVarCount { get; }
    public OclNode StoppedOnNode { get; }
    public StopObject StopObject { get; internal set; }
    public MDrivenOclEvaluatorVisitor(SubscriberPair SubscriberBlock, OclSupport Help, bool sideeffectsAllowed);
    private static MDrivenOclEvaluatorVisitor();
    private Stack`1<OclVariableBinding> get_activeloopvars();
    public static MDrivenOclEvaluatorVisitor Get(SubscriberPair SubscriberBlock, OclSupport Help, bool sideeffectsAllowed);
    public static void Return(MDrivenOclEvaluatorVisitor visitor);
    public int get_ActiveLoopVarCount();
    public void SubScribeToElem(OclNode N);
    public virtual void VisitTBoldOclListCoercion(OclListCoercion N);
    public virtual void VisitTBoldOclOperation(OclOperation N);
    public virtual void VisitTBoldOclIteration(TBoldOclIteration N);
    private void HandleDictionary(TBoldOclIteration N);
    private void HandleOrderBy(TBoldOclIteration N);
    public IObject VisitTBoldOclMember_RetrieveQualifiedSingle(TBoldOclMember N, IFeatured featured);
    public IElementCollection VisitTBoldOclMember_retrieveAttribute(TBoldOclMember N, IElementCollection elementList);
    public static void HandleMissingData(string errorIfThrow);
    public IObjectList VisitTBoldOclMember_retrieveClass(TBoldOclIteration N);
    public IElementCollection VisitTBoldOclMember_retrieveMultiLink(TBoldOclMember N, IElementCollection elementList);
    public IElementCollection VisitTBoldOclMember_RetrieveSingleLink(TBoldOclMember N, IElementCollection elementList);
    public virtual void VisitTBoldOclMember(TBoldOclMember N);
    public virtual void VisitTBoldOclVariableReference(TBoldOclVariableReference N);
    public void BreakOnNext();
    public OclNode get_StoppedOnNode();
    [CompilerGeneratedAttribute]
public StopObject get_StopObject();
    [CompilerGeneratedAttribute]
internal void set_StopObject(StopObject value);
    public void TurnVisitorIntoStepper(Action callbackOnStepStop);
    public void CheckStopOrBreak(OclNode onNode);
    public void NextStep();
    public virtual void VisitTBoldOclNamedEnumLiteral(TBoldOclNamedEnumLiteral N);
    public virtual void VisitTBoldOclTypedEnumLiteral(TBoldOclTypedEnumLiteral N);
    public virtual void VisitTBoldOclCollectionLiteral(TBoldOClCollectionLiteral N);
    public virtual void VisitTBoldOclNumericLiteral(TBoldOclNumericLiteral N);
    public virtual void VisitTBoldOclIntLiteral(TBoldOclIntLiteral N);
    public virtual void VisitTBoldOclStrLiteral(TBoldOclStrLiteral N);
    public virtual void VisitTBoldOclDateLiteral(TBoldOclDateLiteral N);
    public virtual void VisitTBoldOclTimeLiteral(TBoldOclTimeLiteral N);
    public void SubscribeToIElement(IElement Element, bool Resubscribe);
}
public static class Eco.Ocl.Impl.NodeFlags : object {
    public static int NeedsListCoercion;
    public static int IsConstant;
    public static int Resubscribe;
    public static int HastemporaryDummyValue;
    public static int OwnsValue;
}
public class Eco.Ocl.Impl.OclEntry : object {
    private string m_OclString;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
private OclEnvironment <OclEnvironmentForVars>k__BackingField;
    private OclVariableBinding m_SelfVar;
    private IClassifier m_Context;
    public int BindingListThumbprint;
    public int NumberOfUses;
    private bool m_IsEvaluatedOnce;
    private bool m_CanBeStoredInDictionary;
    private OclNode m_OclNode;
    private bool m_IsInUse;
    private Stopwatch _stopWatch;
    private long _stopMax;
    private long _stopMin;
    private long _stopSum;
    internal int DictionaryKey;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
private int <Used>k__BackingField;
    public string OclString { get; }
    public OclEnvironment OclEnvironmentForVars { get; public set; }
    public OclVariableBinding SelfVar { get; public set; }
    public IClassifier Context { get; }
    public bool IsEvaluatedOnce { get; }
    public bool CanBeStoredInDictionary { get; public set; }
    public OclNode OclNode { get; public set; }
    public bool IsInUse { get; public set; }
    public int Used { get; private set; }
    internal long SumOfUsedTime { get; }
    public OclEntry(string Str, OclNode OclNode);
    public string get_OclString();
    [CompilerGeneratedAttribute]
public OclEnvironment get_OclEnvironmentForVars();
    [CompilerGeneratedAttribute]
public void set_OclEnvironmentForVars(OclEnvironment value);
    public OclVariableBinding get_SelfVar();
    public void set_SelfVar(OclVariableBinding value);
    public IClassifier get_Context();
    public bool get_IsEvaluatedOnce();
    public void EvaluatedOnce();
    public bool get_CanBeStoredInDictionary();
    public void set_CanBeStoredInDictionary(bool value);
    public OclNode get_OclNode();
    public void set_OclNode(OclNode value);
    public bool get_IsInUse();
    public void set_IsInUse(bool value);
    [CompilerGeneratedAttribute]
public int get_Used();
    [CompilerGeneratedAttribute]
private void set_Used(int value);
    public void ClearReferencedValues();
    public void Setup(IClassifier context);
    public void Clear();
    internal string UsageReportString();
    internal long get_SumOfUsedTime();
}
public class Eco.Ocl.Impl.OclEnvironment : object {
    private int GenSymCounter;
    private OclEnvironment fOuterScope;
    private List`1<OclVariableBinding> fBindingList;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
private int <BindingListThumbprint>k__BackingField;
    public int Count { get; }
    internal List`1<OclVariableBinding> BindingList { get; }
    public int BindingListThumbprint { get; internal set; }
    public OclEnvironment(OclEnvironment OuterScope);
    public int get_Count();
    internal List`1<OclVariableBinding> get_BindingList();
    [CompilerGeneratedAttribute]
public int get_BindingListThumbprint();
    [CompilerGeneratedAttribute]
internal void set_BindingListThumbprint(int value);
    public static int CalculateVariableListThumbprint(IExternalVariableList variableList);
    public void PushBinding(OclVariableBinding B);
    public void AddBinding(OclVariableBinding B);
    public OclVariableBinding popBinding();
    public OclVariableBinding Lookup(string S);
    public OclVariableBinding lookupSelf();
    public OclVariableBinding CurrentImplicitVariable();
    public string MakeGenSymName();
    public sealed virtual void PruneResources(bool LowMemoryCondition);
    public sealed virtual void CleanForFree();
    public sealed virtual EcoRuntimeInformation GetRuntimeInformation(IExecutionAndDebug owner, DebugSettingsStack settings, int depth);
}
public abstract class Eco.Ocl.Impl.OclImplBase : object {
    private OclParsedExpressionHandler m_ParsedExpressionHandler;
    private OclEnvironment m_GlobalEnv;
    private OclSupport m_Help;
    private OclSymbolDictionary m_SymbolTable;
    protected OclTypeMethodInstaller m_OclTypeMethodInstaller;
    [ThreadStaticAttribute]
private StopObject _stopObject;
    private bool _cleanedForFree;
    [ThreadStaticAttribute]
private static EvalState _threadEvalState;
    [ThreadStaticAttribute]
private static IExternalVariableList _VariableAccessForInvocationOfPSService;
    [ThreadStaticAttribute]
private static IElement _SelfVarAccessForInvocationOfPSService;
    public OclParsedExpressionHandler ParsedExpressionHandler { get; }
    protected OclEnvironment GlobalEnv { get; }
    public OclSymbolDictionary SymbolTable { get; }
    public OclSupport Help { get; }
    public StopObject StopObject { get; }
    public IOclType TypeType { get; }
    protected bool IsPsEvaluator { get; }
    protected bool IsEalEvaluator { get; }
    public static IExternalVariableList VariableAccessForInvocationOfPSService { get; }
    public static IElement SelfVarAccessForInvocationOfPSService { get; }
    public IOclOperation[] InstalledOclOperations { get; }
    public OclImplBase(OclSupport oclOperationSupport);
    public OclParsedExpressionHandler get_ParsedExpressionHandler();
    protected OclEnvironment get_GlobalEnv();
    public OclSymbolDictionary get_SymbolTable();
    public OclSupport get_Help();
    public StopObject get_StopObject();
    public StopObject StopObjectInit(bool allow);
    public sealed virtual IOclType TypeForClassifier(IClassifier classifier);
    public sealed virtual IOclType get_TypeType();
    public sealed virtual void PruneResources(bool LowMemoryCondition);
    public sealed virtual void CleanForFree();
    public sealed virtual EcoRuntimeInformation GetRuntimeInformation(IExecutionAndDebug owner, DebugSettingsStack settings, int depth);
    public sealed virtual void ClearCachedExpressions();
    public sealed virtual StringBuilder GetOCLUsageReport();
    protected abstract virtual bool get_IsPsEvaluator();
    protected abstract virtual bool get_IsEalEvaluator();
    protected void InstallGlobalVariables();
    public void DefineGlobalVariable(string variableName, IElement varValue, IClassifier variableType, bool ownValue);
    public sealed virtual IFeature ExpressionFeatureInfo(string expression, IClassifier context, bool reRaise);
    public sealed virtual IFeature ExpressionFeatureInfo(string expression, IClassifier context, IExternalVariableList variableList, bool reRaise);
    public sealed virtual IStructuralFeature ExpressionModelInfo(string expression, IClassifier context, bool reRaise);
    public sealed virtual IStructuralFeature ExpressionModelInfo(string expression, IClassifier context, bool reRaise, IExternalVariableList variableList);
    public IFeature ExpressionFeatureInfo(string expression, IClassifier context, bool reRaise, IExternalVariableList variableList, bool alsoCheckMethods);
    public sealed virtual object ExpressionParseTree(string expression, IClassifier context, bool reRaise, IExternalVariableList variableList);
    public sealed virtual object ExpressionSyntacticParseTree(string expression, IClassifier context, bool reRaise, IExternalVariableList variableList);
    private OclEntry ExpressionParseTreeEnv(string expression, IClassifier context, bool reRaise, OclEnvironment oclEnvironment);
    public sealed virtual string ExpandDerivationsInExpressionExtractOrderBy(string expression, IClassifier context, bool reRaise, IExternalVariableList variableList, String& orderexpression);
    public sealed virtual string ExpandDerivationsInExpression(string expression, IClassifier context, bool reRaise, IExternalVariableList variableList);
    public string ExpandDerivationsInExpression(string expression, IClassifier context, bool reRaise, OclEnvironment oclEnvironment, OclEntry& resultingOclEntry);
    private string ExpandDerivationsInExpression_AntiRecursion(string expression, IClassifier context, bool reRaise, OclEnvironment oclEnvironment, OclEntry& resultingOclEntry, List`1<IStructuralFeature> avoidrecursionmmemory, bool extractOrderExpression, String& orderexpression);
    private TBoldOclIteration InjectCollector(OclNode nodewithreplacement, OclNode unchangedNodeToConnectTo, OclVariableBinding& VarBind);
    private void ReplaceSelfNameInExp(OclNode oclNode, string newname, Int32& foundreplacements);
    private void ScanAfterUsageOfThisAndReplaceWithThat(OclNode oclNode, OclNode nodeToReplace, OclNode nodewithreplacement);
    private void MakeThisPointToThat(OclNode nodewithreplacement, OclNode thepartthatNodeWithReplacementShouldFitIn);
    private void HandleNodeAndReplaceDerivations(OclNode oclNode, OclNode& nodeToReplace, OclNode& nodewithreplacement, List`1<IStructuralFeature> avoidrecursionmmemory);
    private OclNode GetStartingNodeExceptSelf(OclNode oclNode);
    private bool IsSelfVar(OclNode oclNode);
    public sealed virtual bool ExpressionIsReadOnly(string expression, IClassifier context, bool reRaise);
    public sealed virtual bool ExpressionIsReadOnly(string expression, IClassifier context, bool reRaise, IExternalVariableList variableList);
    public sealed virtual IClassifier ExpressionType(string expression, IClassifier context, bool reRaise, IExternalVariableList variableList);
    public sealed virtual IClassifier ExpressionType(string Expression, IClassifier Context, bool ReRaise);
    protected IElement Evaluate(OclEntry entry, SubscriberPair subscriberPair);
    internal static EvalState CreateSingletonExceptionToTheRuleOfNeverCreatingStuffInOCL_Enter();
    internal static void CreateSingletonExceptionToTheRuleOfNeverCreatingStuffInOCL_Leave(EvalState original);
    public static IExternalVariableList get_VariableAccessForInvocationOfPSService();
    public static IElement get_SelfVarAccessForInvocationOfPSService();
    public DebugStep DebugStepEvaluateInit(string oclExpression, IElement rootElement, IClassifier context, IExternalVariableList variableList, Action callbackOnStepStop);
    public void DebugStepEvaluateRun(DebugStep debugStep);
    protected IElement InternalEvaluate(string oclExpression, IElement rootElement, IClassifier context, SubscriberPair subscriberPair, IExternalVariableList variableList);
    private IElement InternalEvaluateCritical(string oclExpression, IElement rootElement, SubscriberPair subscriberPair, IExternalVariableList variableList, int bughuntinfo, IClassifier effectiveContext);
    private static IClassifier GetEffectiveContext(IElement rootElement, IClassifier context);
    public sealed virtual IOclOperation[] get_InstalledOclOperations();
    public sealed virtual void InstallOperation(IOclOperation operation);
    public OclEnvironment GetEnvironment(IExternalVariableList variableList, bool initializevalues);
}
public class Eco.Ocl.Impl.OclListCoercion : OclNode {
    private OclNode m_Child;
    public OclNode Child { get; public set; }
    public OclListCoercion(OclNode child);
    public OclNode get_Child();
    public void set_Child(OclNode value);
    public virtual void AcceptVisitor(OclVisitor V);
    public virtual void ClearReferencedValues();
    public virtual string ReconstructOcl(OclSymbolDictionary symdict);
}
public class Eco.Ocl.Impl.OclNode : object {
    private int m_Flags;
    private IElement m_Element;
    private IClassifier m_ClassifierValue;
    private bool m_IsTypeNode;
    private int m_Position;
    private IOclType m_OclType;
    public IOclType OclType { get; public set; }
    public IElement Element { get; }
    public bool NeedsListCoercion { get; public set; }
    public bool IsConstant { get; public set; }
    public bool Resubscribe { get; public set; }
    public bool HastemporaryDummyValue { get; public set; }
    public bool OwnsValue { get; public set; }
    public bool IsTypeNode { get; }
    public IClassifier ClassifierValue { get; }
    public bool IsReadOnly { get; }
    public int Position { get; public set; }
    public string ModelName { get; }
    public int Pos { get; }
    public sealed virtual IOclType get_OclType();
    public void set_OclType(IOclType value);
    public sealed virtual IElement get_Element();
    public bool get_NeedsListCoercion();
    public void set_NeedsListCoercion(bool value);
    public bool get_IsConstant();
    public void set_IsConstant(bool value);
    public bool get_Resubscribe();
    public void set_Resubscribe(bool value);
    public bool get_HastemporaryDummyValue();
    public void set_HastemporaryDummyValue(bool value);
    public sealed virtual bool get_OwnsValue();
    public void set_OwnsValue(bool value);
    public sealed virtual bool get_IsTypeNode();
    public sealed virtual IClassifier get_ClassifierValue();
    public virtual bool get_IsReadOnly();
    public int get_Position();
    public void set_Position(int value);
    public virtual void AcceptVisitor(OclVisitor V);
    public sealed virtual void SetReferenceClassifier(IClassifier value);
    public sealed virtual void TransferValue(IOclValue node);
    public sealed virtual void SetOwnedElement(IElement value);
    public sealed virtual void SetReferenceElement(IElement value);
    public virtual string get_ModelName();
    public sealed virtual void SetDefaultValue(IOclOperationSupport support);
    public sealed virtual int get_Pos();
    public virtual void ClearReferencedValues();
    public IElement GetResult();
    public virtual string ReconstructOcl(OclSymbolDictionary symdict);
    public void WalkTreeAndCollectQueryPlan(HashSet`1& queryplanMembers, HashSet`1& queryplanAllInstances, HashSet`1& variablenames, Boolean& containsPSEvalOperations);
    public void WalkTreeAndCollectMembers(List`1<IClassifier> classifiers, List`1<IFeature> members, List`1<IClassifier> classifiersCreate, List`1<IClassifier> classifiersDelete, HashSet`1<IFeature> queryplanMembers, HashSet`1<IClassifier> queryplanAllInstances, HashSet`1<string> variablenames, HashSet`1<string> viewmodelrefs, HashSet`1<string> stylerefs, List`1<IStructuralFeature> featuresToTheLeftOfOperators, Boolean& containsPSEvalOperations);
    internal void WalkTreeAndCollectMembersInternal(List`1<IClassifier> classifiers, List`1<IFeature> members, List`1<IClassifier> classifiersCreate, List`1<IClassifier> classifiersDelete, HashSet`1<IFeature> queryplanMembers, HashSet`1<IClassifier> queryplanAllInstances, HashSet`1<string> variablenames, HashSet`1<string> viewmodelrefs, HashSet`1<string> stylerefs, List`1<IStructuralFeature> featuresToTheLeftOfOperators, bool currentlyInPSEval, Boolean& containsPSEvalOperations);
}
public class Eco.Ocl.Impl.OclOperation : OclNode {
    private TBoldOclNodeList fArgs;
    private int fWeight;
    private int fDepth;
    private bool fForceParenthesis;
    public TBoldOCLIteratorSpecifier IteratorSpecifier;
    public IOclOperation Symbol;
    public string OperationName;
    public TBoldOclNodeList Args { get; }
    public int Weight { get; public set; }
    public bool ForceParenthesis { get; public set; }
    public int Depth { get; public set; }
    public bool IsReadOnly { get; }
    public TBoldOclNodeList get_Args();
    public int get_Weight();
    public void set_Weight(int value);
    public bool get_ForceParenthesis();
    public void set_ForceParenthesis(bool value);
    public int get_Depth();
    public void set_Depth(int value);
    public virtual bool get_IsReadOnly();
    public virtual void AcceptVisitor(OclVisitor V);
    public virtual void ClearReferencedValues();
    public virtual string ReconstructOcl(OclSymbolDictionary symdict);
}
public class Eco.Ocl.Impl.OclParsedExpressionHandler : object {
    private int oclDictionaryHits;
    private int oclDictionaryMisses;
    private int oclReusedFromDictionary;
    private int oclReturnedToCache;
    private int oclNotToUseCache;
    private int oclNewOclCreated;
    private Dictionary`2<int, Stack`1<OclEntry>> m_OclDictionary;
    private static SSLexTable m_OclScannerTable;
    private static SSYaccTable m_OclParserTable;
    private OclImplBase m_oclImplbase;
    private OclSymbolDictionary m_SymbolTable;
    private OclSupport m_Help;
    public OclParsedExpressionHandler(OclImplBase oclImplBase, OclSymbolDictionary symbolTable, OclSupport operationSupport);
    public void ClearCachedExpressions();
    private string getError(string expression, int errorPosition);
    public sealed virtual void CleanForFree();
    private bool CanUseEntry(OclEntry entry, IClassifier context);
    internal OclEntry GetEntrySyntactic(string expression, IClassifier context, OclEnvironment oclEnvironment, bool isPsEvaluation);
    public OclEntry CreateEntry(string expression, IClassifier context, OclEnvironment oclEnvironment, bool isPsEvaluation);
    public OclEntry GetEntry(string expression, IClassifier context, bool UseDictionary, IExternalVariableList variableList, bool isPsEvaluation, bool initializevalues);
    public void DoneWithEntry(OclEntry entry);
    public void SemanticCheck(OclEntry entry, OclEnvironment oclEnvironment, bool isPsEvaluation);
    public OclEntry SemanticCheck(string fixedExpression, string originalExpression, IClassifier context, OclEnvironment oclEnvironment, bool isPsEvaluation);
    private OclEntry SyntacticParse(string fixedExpression, string originalExpression, IClassifier context);
    public static SSLexTable OclScannerTable();
    public static SSYaccTable OclParserTable();
    private string FixExpression(string expression);
    public StringBuilder GetOCLUsageReport();
    public sealed virtual void PruneResources(bool LowMemoryCondition);
    public sealed virtual EcoRuntimeInformation GetRuntimeInformation(IExecutionAndDebug owner, DebugSettingsStack settings, int depth);
}
public class Eco.Ocl.Impl.OclParserCoreBackend : object {
    private int fRotations;
    private IEcoTypeSystem fTypeSystem;
    private static String[] _prefix;
    public OclParserCoreBackend(IEcoTypeSystem TypeSystem);
    private static OclParserCoreBackend();
    public OclStackElement Make1Operation(string OpName, OclStackElement arg1, int Offs);
    public OclStackElement ForceParenthesis(OclStackElement arg);
    public OclOperation Balance_GetChild(OclOperation Root, int i);
    private string Copy(Char[] chars, int index, int length);
    private OclOperation Balance(OclOperation Root);
    public OclStackElement Make2Operation(string OpName, OclStackElement arg1, OclStackElement arg2, int Offs);
    public OclStackElement Make3Operation(string OpName, OclStackElement arg1, OclStackElement arg2, OclStackElement arg3, int Offs);
    public OclStackElement MakeLet(OclStackElement variable, OclStackElement value, OclStackElement expr, int Offs);
    public OclStackElement MakeCollectionKind(CollectionKind Kind, int Offs);
    public OclStackElement MakeDeclarator(OclStackElement VarName, OclStackElement VarType, int Offs);
    public OclStackElement MakeEmptyList();
    public OclStackElement MakeFeatureCall(OclStackElement DeclaratorName, OclStackElement DeclaratorType, OclStackElement ParamList, int Offs);
    public OclStackElement MakeList(OclStackElement First, int Offs);
    public OclStackElement MakeLiteralCollection(OclStackElement CollectionType, OclStackElement ExprListOrRange, int Offs);
    public OclStackElement MakeLiteralDate(OclStackElement Date, int Offs);
    public OclStackElement MakeLiteralDateTime(OclStackElement DateTime, int Offs);
    public OclStackElement MakeLiteralFloat(OclStackElement __Float, int Offs);
    public OclStackElement MakeLiteralInt(OclStackElement __Int, int Offs);
    public OclStackElement MakeLiteralName(OclStackElement Name, int Offs);
    public OclStackElement MakeLiteralString(OclStackElement Str, int Offs);
    public OclStackElement MakeLiteralTime(OclStackElement Time, int Offs);
    private OclVariableBinding MakeLoopVar(OclStackElement __Params);
    public OclStackElement MakeMember(OclStackElement Context, OclStackElement Name, OclStackElement Time, OclStackElement Qual, int Offs);
    public OclStackElement MakeName(OclStackElement Name, int Offs);
    public static TBoldOCLIteratorSpecifier GetIteratorSpecifierFromOperationName(string opname);
    public OclStackElement MakeOperation(OclStackElement Context, OclStackElement Name, OclStackElement Time, OclStackElement Qual, OclStackElement __Params, int Offs);
    public OclStackElement MakeRange(OclStackElement Start, OclStackElement Stop, int Offs);
    public OclStackElement MakeSimpleEnumType(OclStackElement Enumeration, int Offs);
    public OclStackElement MakeSimplePath(OclStackElement Path, int Offs);
    public OclStackElement MakeTimeExpression(OclStackElement Kind, int Offs);
    public OclStackElement MakeUnaryMinus(string OpName, OclStackElement arg1, int Offs);
    public OclStackElement PushList(OclStackElement First, OclStackElement List, int Offs);
    private void RetrieveNodeList(OclStackElement ParseList, TBoldOclNodeList NodeList);
    public static string GetOnType(IOclOperation symbol);
    internal static string CleanUpTypePres(string paramType);
    private static bool OddCaseSymbol(IOclOperation symbol, String& res);
    public static string GetFormalPresentationComplete(IOclOperation symbol);
    public static string GetFormalPresentation(IOclOperation symbol);
}
public class Eco.Ocl.Impl.OclPsServiceImpl : OclImplBase {
    private IObjectRepresentationProvider m_ObjectRepresentationProvider;
    private ICache m_Cache;
    internal IObjectRepresentationProvider ObjectRepresentationProvider { get; internal set; }
    internal ICache Cache { get; internal set; }
    protected bool IsPsEvaluator { get; }
    protected bool IsEalEvaluator { get; }
    public OclPsServiceImpl(OclSupport oclOperationSupport);
    public void SemanticCheck(OclEntry entry, OclEnvironment env);
    internal IObjectRepresentationProvider get_ObjectRepresentationProvider();
    internal void set_ObjectRepresentationProvider(IObjectRepresentationProvider value);
    internal ICache get_Cache();
    internal void set_Cache(ICache value);
    protected virtual bool get_IsPsEvaluator();
    protected virtual bool get_IsEalEvaluator();
    private void EnsureObjectIsNotNew(IObject obj);
    private void EnsureObjectsAreNotNew(IObjectList list);
    private void EnsureObjectsAreNotNew(IElement el);
    private OclConditionAndType CreateOclCondition(string Expr, IElement Root, OclEntry OclEntry, OclEnvironment Env, PsMode psmode, bool ismetaReturnPlatformQuery);
    public OclConditionAndType CreateRetrieveCondition(OclEntry entry, PsMode psmode, bool ismetaReturnPlatformQuery);
    public OclConditionAndType CreateRetrieveCondition(IElement root, IExternalVariableList vars, string expression, PsMode psmode, bool ismetaReturnPlatformQuery);
    public sealed virtual IObjectList Execute(string expression);
    public sealed virtual IObjectList Execute(string expression, int maxAnswers, int offset);
    public sealed virtual IObjectList Execute(IElement root, string expression);
    public sealed virtual IObjectList Execute(IElement root, IExternalVariableList variableList, string expression, int maxAnswers, int offset);
    public sealed virtual string ReturnPlatformQuery(IElement root, IExternalVariableList variableList, string expression);
    public sealed virtual IObjectList ExpandDerivationsThenExecute(IElement root, IExternalVariableList variableList, string expression, int maxAnswers, int offset);
    public sealed virtual IElement GetValue(IElement root, IExternalVariableList variableList, string expression, int maxAnswers, int offset);
    public sealed virtual IElementCollection GetTuples(IElement root, IExternalVariableList variableList, string expression, int maxAnswers, int offset);
    public sealed virtual string ReturnPlatformQueryValue(IElement root, IExternalVariableList variableList, string expression);
    public sealed virtual string ReturnPlatformQueryTuples(IElement root, IExternalVariableList variableList, string expression);
}
public class Eco.Ocl.Impl.OclServiceImpl : OclImplBase {
    public bool CanEvaluate { get; }
    protected bool IsPsEvaluator { get; }
    protected bool IsEalEvaluator { get; }
    public OclServiceImpl(OclSupport oclOperationSupport);
    public void SemanticCheck(OclEntry entry, OclEnvironment oclEnvironment);
    public IElement Evaluate(OclEntry entry);
    public bool get_CanEvaluate();
    protected virtual bool get_IsPsEvaluator();
    protected virtual bool get_IsEalEvaluator();
    public sealed virtual IElement GetDerivedElement(IElement root, string expression);
    public sealed virtual IElement EvaluateAndSubscribe(IElement root, IExternalVariableList vars, string expression, ISubscriber reevaluateSubscriber, ISubscriber resubscribeSubscriber);
    public sealed virtual IElement EvaluateAndSubscribe(IElement root, IClassifier Context, string expression, ISubscriber reevaluateSubscriber, ISubscriber resubscribeSubscriber);
    public sealed virtual IElement EvaluateAndSubscribe(IElement root, IClassifier Context, IExternalVariableList vars, string expression, ISubscriber reevaluateSubscriber, ISubscriber resubscribeSubscriber);
    private IElement InternalBaseEvaluateAndSubscribe(IElement root, IClassifier Context, IExternalVariableList vars, string expression, ISubscriber reevaluateSubscriber, ISubscriber resubscribeSubscriber);
    private IElement BaseEvaluateAndSubscribe(IElement root, IClassifier Context, IExternalVariableList vars, string expression, ISubscriber reevaluateSubscriber, ISubscriber resubscribeSubscriber);
    private IElement BaseEvaluate(IElement root, IClassifier Context, IExternalVariableList vars, string expression);
    public sealed virtual IElement Evaluate(string expression);
    public sealed virtual IElement Evaluate(string expression, IExternalVariableList vars);
    public sealed virtual IElement Evaluate(IElement root, string expression);
    public sealed virtual IElement Evaluate(IElement root, string expression, IExternalVariableList vars);
    public sealed virtual IElement EvaluateAndSubscribe(IElement root, string expression, ISubscriber reevaluateSubscriber, ISubscriber resubscribeSubscriber);
}
public class Eco.Ocl.Impl.OclSupport : object {
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
private IEcoTypeSystem <Model>k__BackingField;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
private IOclType <BooleanType>k__BackingField;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
private IOclType <BooleanTypeWhenMissingType>k__BackingField;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
private IOclType <ByteType>k__BackingField;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
private IOclType <BlobType>k__BackingField;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
private IOclType <SByteType>k__BackingField;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
private IOclType <Int64Type>k__BackingField;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
private IOclType <Int16Type>k__BackingField;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
private IOclType <UInt16Type>k__BackingField;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
private IOclType <IntegerType>k__BackingField;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
private IOclType <RealType>k__BackingField;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
private IOclType <DecimalType>k__BackingField;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
private IOclType <TimeSpanType>k__BackingField;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
private IOclType <DateTimeType>k__BackingField;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
private IOclType <StringType>k__BackingField;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
private IOclType <OclSortDirection>k__BackingField;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
private IOclType <ConstraintErrorLevel>k__BackingField;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
private IOclType <ListType>k__BackingField;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
private IOclType <ObjectType>k__BackingField;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
private IOclType <TypeType>k__BackingField;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
private IOclType <AnyType>k__BackingField;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
private IOclType <EnumLiteralType>k__BackingField;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
private IOclType <NumericListType>k__BackingField;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
private IOclType <DecimalListType>k__BackingField;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
private IOclType <Int64ListType>k__BackingField;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
private IOclType <IntegerListType>k__BackingField;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
private IOclType <TimeSpanListType>k__BackingField;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
private IOclType <DateTimeListType>k__BackingField;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
private IOclType <StringListType>k__BackingField;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
private IOclType <ObjectListType>k__BackingField;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
private IOclType <GuidType>k__BackingField;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
private IOclType <ViewModelReferenceType>k__BackingField;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
private IVariableFactoryService <VariableFactory>k__BackingField;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
private IObjectFactoryService <ObjectFactory>k__BackingField;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
private IExternalIdService <ExternalIdService>k__BackingField;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
private IPersistenceService <PersistenceService>k__BackingField;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
private IUndoService <UndoService>k__BackingField;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
private IOclService <OclService>k__BackingField;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
private IExtentService <ExtentService>k__BackingField;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
private IVersionService <VersionService>k__BackingField;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
private IAutoSubscriptionService <AutoSubscriptionService>k__BackingField;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
private IAsyncSupportService <AsyncSupportService>k__BackingField;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
private IEcoServiceProvider <ServiceProvider>k__BackingField;
    private Dictionary`2<IClassifier, IOclType> m_TypeCache;
    private ITupleType _ConstraintTupleType;
    private IOclType _ConstraintsReturnType;
    private ITupleType _actionTupleType;
    private IOclType _actionsReturnType;
    public bool CanEvaluate { get; }
    public IEcoTypeSystem Model { get; private set; }
    public IOclType BooleanType { get; private set; }
    public IOclType BooleanTypeWhenMissingType { get; private set; }
    public IOclType ByteType { get; private set; }
    public IOclType BlobType { get; private set; }
    public IOclType SByteType { get; private set; }
    public IOclType Int64Type { get; private set; }
    public IOclType Int16Type { get; private set; }
    public IOclType UInt16Type { get; private set; }
    public IOclType IntegerType { get; private set; }
    public IOclType RealType { get; private set; }
    public IOclType DecimalType { get; private set; }
    public IOclType TimeSpanType { get; private set; }
    public IOclType DateTimeType { get; private set; }
    public IOclType StringType { get; private set; }
    public IOclType OclSortDirection { get; private set; }
    public IOclType ConstraintErrorLevel { get; private set; }
    public IOclType ListType { get; private set; }
    public IOclType ObjectType { get; private set; }
    public IOclType TypeType { get; private set; }
    public IOclType AnyType { get; private set; }
    public IOclType EnumLiteralType { get; private set; }
    public IOclType NumericListType { get; private set; }
    public IOclType DecimalListType { get; private set; }
    public IOclType Int64ListType { get; private set; }
    public IOclType IntegerListType { get; private set; }
    public IOclType TimeSpanListType { get; private set; }
    public IOclType DateTimeListType { get; private set; }
    public IOclType StringListType { get; private set; }
    public IOclType ObjectListType { get; private set; }
    public IOclType GuidType { get; private set; }
    public IOclType ViewModelReferenceType { get; private set; }
    public IVariableFactoryService VariableFactory { get; public set; }
    public IObjectFactoryService ObjectFactory { get; public set; }
    public IExternalIdService ExternalIdService { get; public set; }
    public IPersistenceService PersistenceService { get; public set; }
    public IUndoService UndoService { get; public set; }
    public IOclService OclService { get; public set; }
    public IExtentService ExtentService { get; public set; }
    public IVersionService VersionService { get; public set; }
    public IAutoSubscriptionService AutoSubscriptionService { get; public set; }
    public IAsyncSupportService AsyncSupportService { get; public set; }
    public IEcoServiceProvider ServiceProvider { get; public set; }
    public OclSupport(IEcoTypeSystem TypeSystem);
    public bool get_CanEvaluate();
    [CompilerGeneratedAttribute]
public sealed virtual IEcoTypeSystem get_Model();
    [CompilerGeneratedAttribute]
private void set_Model(IEcoTypeSystem value);
    [CompilerGeneratedAttribute]
public sealed virtual IOclType get_BooleanType();
    [CompilerGeneratedAttribute]
private void set_BooleanType(IOclType value);
    [CompilerGeneratedAttribute]
public sealed virtual IOclType get_BooleanTypeWhenMissingType();
    [CompilerGeneratedAttribute]
private void set_BooleanTypeWhenMissingType(IOclType value);
    [CompilerGeneratedAttribute]
public sealed virtual IOclType get_ByteType();
    [CompilerGeneratedAttribute]
private void set_ByteType(IOclType value);
    [CompilerGeneratedAttribute]
public sealed virtual IOclType get_BlobType();
    [CompilerGeneratedAttribute]
private void set_BlobType(IOclType value);
    [CompilerGeneratedAttribute]
public sealed virtual IOclType get_SByteType();
    [CompilerGeneratedAttribute]
private void set_SByteType(IOclType value);
    [CompilerGeneratedAttribute]
public sealed virtual IOclType get_Int64Type();
    [CompilerGeneratedAttribute]
private void set_Int64Type(IOclType value);
    [CompilerGeneratedAttribute]
public sealed virtual IOclType get_Int16Type();
    [CompilerGeneratedAttribute]
private void set_Int16Type(IOclType value);
    [CompilerGeneratedAttribute]
public sealed virtual IOclType get_UInt16Type();
    [CompilerGeneratedAttribute]
private void set_UInt16Type(IOclType value);
    [CompilerGeneratedAttribute]
public sealed virtual IOclType get_IntegerType();
    [CompilerGeneratedAttribute]
private void set_IntegerType(IOclType value);
    [CompilerGeneratedAttribute]
public sealed virtual IOclType get_RealType();
    [CompilerGeneratedAttribute]
private void set_RealType(IOclType value);
    [CompilerGeneratedAttribute]
public sealed virtual IOclType get_DecimalType();
    [CompilerGeneratedAttribute]
private void set_DecimalType(IOclType value);
    [CompilerGeneratedAttribute]
public sealed virtual IOclType get_TimeSpanType();
    [CompilerGeneratedAttribute]
private void set_TimeSpanType(IOclType value);
    [CompilerGeneratedAttribute]
public sealed virtual IOclType get_DateTimeType();
    [CompilerGeneratedAttribute]
private void set_DateTimeType(IOclType value);
    [CompilerGeneratedAttribute]
public sealed virtual IOclType get_StringType();
    [CompilerGeneratedAttribute]
private void set_StringType(IOclType value);
    [CompilerGeneratedAttribute]
public sealed virtual IOclType get_OclSortDirection();
    [CompilerGeneratedAttribute]
private void set_OclSortDirection(IOclType value);
    [CompilerGeneratedAttribute]
public sealed virtual IOclType get_ConstraintErrorLevel();
    [CompilerGeneratedAttribute]
private void set_ConstraintErrorLevel(IOclType value);
    [CompilerGeneratedAttribute]
public sealed virtual IOclType get_ListType();
    [CompilerGeneratedAttribute]
private void set_ListType(IOclType value);
    [CompilerGeneratedAttribute]
public sealed virtual IOclType get_ObjectType();
    [CompilerGeneratedAttribute]
private void set_ObjectType(IOclType value);
    [CompilerGeneratedAttribute]
public sealed virtual IOclType get_TypeType();
    [CompilerGeneratedAttribute]
private void set_TypeType(IOclType value);
    [CompilerGeneratedAttribute]
public sealed virtual IOclType get_AnyType();
    [CompilerGeneratedAttribute]
private void set_AnyType(IOclType value);
    [CompilerGeneratedAttribute]
public sealed virtual IOclType get_EnumLiteralType();
    [CompilerGeneratedAttribute]
private void set_EnumLiteralType(IOclType value);
    [CompilerGeneratedAttribute]
public sealed virtual IOclType get_NumericListType();
    [CompilerGeneratedAttribute]
private void set_NumericListType(IOclType value);
    [CompilerGeneratedAttribute]
public sealed virtual IOclType get_DecimalListType();
    [CompilerGeneratedAttribute]
private void set_DecimalListType(IOclType value);
    [CompilerGeneratedAttribute]
public sealed virtual IOclType get_Int64ListType();
    [CompilerGeneratedAttribute]
private void set_Int64ListType(IOclType value);
    [CompilerGeneratedAttribute]
public sealed virtual IOclType get_IntegerListType();
    [CompilerGeneratedAttribute]
private void set_IntegerListType(IOclType value);
    [CompilerGeneratedAttribute]
public sealed virtual IOclType get_TimeSpanListType();
    [CompilerGeneratedAttribute]
private void set_TimeSpanListType(IOclType value);
    [CompilerGeneratedAttribute]
public sealed virtual IOclType get_DateTimeListType();
    [CompilerGeneratedAttribute]
private void set_DateTimeListType(IOclType value);
    [CompilerGeneratedAttribute]
public sealed virtual IOclType get_StringListType();
    [CompilerGeneratedAttribute]
private void set_StringListType(IOclType value);
    [CompilerGeneratedAttribute]
public sealed virtual IOclType get_ObjectListType();
    [CompilerGeneratedAttribute]
private void set_ObjectListType(IOclType value);
    [CompilerGeneratedAttribute]
public sealed virtual IOclType get_GuidType();
    [CompilerGeneratedAttribute]
private void set_GuidType(IOclType value);
    [CompilerGeneratedAttribute]
public sealed virtual IOclType get_ViewModelReferenceType();
    [CompilerGeneratedAttribute]
private void set_ViewModelReferenceType(IOclType value);
    [CompilerGeneratedAttribute]
public sealed virtual IVariableFactoryService get_VariableFactory();
    [CompilerGeneratedAttribute]
public void set_VariableFactory(IVariableFactoryService value);
    [CompilerGeneratedAttribute]
public sealed virtual IObjectFactoryService get_ObjectFactory();
    [CompilerGeneratedAttribute]
public void set_ObjectFactory(IObjectFactoryService value);
    [CompilerGeneratedAttribute]
public sealed virtual IExternalIdService get_ExternalIdService();
    [CompilerGeneratedAttribute]
public void set_ExternalIdService(IExternalIdService value);
    [CompilerGeneratedAttribute]
public sealed virtual IPersistenceService get_PersistenceService();
    [CompilerGeneratedAttribute]
public void set_PersistenceService(IPersistenceService value);
    [CompilerGeneratedAttribute]
public sealed virtual IUndoService get_UndoService();
    [CompilerGeneratedAttribute]
public void set_UndoService(IUndoService value);
    [CompilerGeneratedAttribute]
public sealed virtual IOclService get_OclService();
    [CompilerGeneratedAttribute]
public void set_OclService(IOclService value);
    [CompilerGeneratedAttribute]
public sealed virtual IExtentService get_ExtentService();
    [CompilerGeneratedAttribute]
public void set_ExtentService(IExtentService value);
    [CompilerGeneratedAttribute]
public sealed virtual IVersionService get_VersionService();
    [CompilerGeneratedAttribute]
public void set_VersionService(IVersionService value);
    [CompilerGeneratedAttribute]
public sealed virtual IAutoSubscriptionService get_AutoSubscriptionService();
    [CompilerGeneratedAttribute]
public void set_AutoSubscriptionService(IAutoSubscriptionService value);
    [CompilerGeneratedAttribute]
public IAsyncSupportService get_AsyncSupportService();
    [CompilerGeneratedAttribute]
public void set_AsyncSupportService(IAsyncSupportService value);
    [CompilerGeneratedAttribute]
public sealed virtual IEcoServiceProvider get_ServiceProvider();
    [CompilerGeneratedAttribute]
public void set_ServiceProvider(IEcoServiceProvider value);
    private void MakeNew(IOclValue node, IOclType newType, object initialValue);
    public sealed virtual void MakeNewNumeric(IOclValue node, double value);
    public sealed virtual void MakeNewDecimal(IOclValue node, decimal value);
    public sealed virtual void MakeNewString(IOclValue node, string value);
    public sealed virtual void MakeNewBlob(IOclValue node, Byte[] value);
    public sealed virtual void MakeNewInteger(IOclValue node, int value);
    public sealed virtual void MakeNewTimeSpan(IOclValue node, TimeSpan value);
    public sealed virtual void MakeNewDateTime(IOclValue node, DateTime value);
    public sealed virtual void MakeNewInt64(IOclValue node, long value);
    public sealed virtual void MakeNewBoolean(IOclValue node, bool value);
    public sealed virtual void TransferOrClone(IOclValue source, IOclValue dest);
    public sealed virtual bool GetAsBoolean(IOclValue Node);
    public sealed virtual int GetAsInteger(IOclValue Node);
    public sealed virtual int GetAsInteger(IElement Element);
    public sealed virtual DateTime GetAsDateTime(IOclValue Node);
    public sealed virtual TimeSpan GetAsTimeSpan(IOclValue Node);
    public sealed virtual TimeSpan GetAsTimeSpan(IElement Element);
    public sealed virtual double GetAsNumeric(IOclValue Node);
    public sealed virtual double GetAsNumeric(IElement Element);
    public sealed virtual string GetAsString(IOclValue Node);
    public sealed virtual decimal GetAsDecimal(IOclValue Node);
    public sealed virtual decimal GetAsDecimal(IElement Element);
    public sealed virtual IClassifier GetAsType(IOclValue Node);
    public sealed virtual long GetAsInt64(IOclValue Node);
    public sealed virtual long GetAsInt64(IElement Element);
    public sealed virtual IElementCollection GetAsList(IOclValue Node);
    public sealed virtual IElement CreateNewConstant(IOclType formalArgument, object value);
    public sealed virtual IElement CreateNewVariable(IOclType FormalArgument);
    public sealed virtual IElement CreateNewVariableDontSubscribeToDeleteIfList(IOclType FormalArgument);
    public sealed virtual IElement CreateNewSimpleVariable(ISimpleType DataType);
    public ITupleType GetConstraintTupleType();
    public sealed virtual IOclType GetConstraintsReturnType();
    public ITupleType GetActionTupleType();
    public sealed virtual IOclType GetListActionsReturnType();
    public sealed virtual object ConvertElement(IOclType toType, IElement element);
    public sealed virtual IOclType GetOclTypeFor(IClassifier classifier);
    public void CleanForFree();
}
public class Eco.Ocl.Impl.OclSymbolDictionary : object {
    private Dictionary`2<string, List`1<IOclOperation>> fHashTable;
    private OclSupport fHelp;
    private OclSupport Help { get; }
    public OclSymbolDictionary(OclSupport Help);
    private OclSupport get_Help();
    public void Add(IOclOperation operation);
    public IOclOperation[] GetSymbols(string name);
    public IOclOperation[] GetOperations();
    public sealed virtual void PruneResources(bool LowMemoryCondition);
    public sealed virtual void CleanForFree();
    public sealed virtual EcoRuntimeInformation GetRuntimeInformation(IExecutionAndDebug owner, DebugSettingsStack settings, int depth);
}
public class Eco.Ocl.Impl.OclTypeImpl : object {
    private static OclTypeImpl C_AnyInstance;
    private static OclTypeImpl C_TypeInstance;
    private static OclTypeImpl C_ObjectInstance;
    private static OclTypeImpl C_AnyListInstance;
    private static OclTypeImpl C_ObjectListInstance;
    private static OclTypeImpl C_EnumLiteralInstance;
    private IClassifier fUMLTYpe;
    private string fName;
    public IClassifier UMLType { get; }
    private IOclType Eco.Ocl.Support.IOclType.CollectionType { get; }
    private IOclType Eco.Ocl.Support.IOclType.ElementType { get; }
    public OclTypeImpl(IClassifier UMLType);
    public OclTypeImpl(string Name);
    private static OclTypeImpl();
    public sealed virtual IClassifier get_UMLType();
    public static OclTypeImpl AnyType();
    public static OclTypeImpl EnumLiteralType();
    public static OclTypeImpl AnyListType();
    public static OclTypeImpl ObjectListType();
    public static OclTypeImpl AnyObjectType();
    public static OclTypeImpl TypeType();
    public bool OclConformsTo(OclTypeImpl OclType);
    public sealed virtual IOclType LeastCommonType(IOclType OclType);
    public sealed virtual bool IsListType();
    public sealed virtual bool IsFeaturedType();
    public bool IsTupleType();
    public sealed virtual bool IsObjectType();
    public sealed virtual bool IsObjectListType();
    public OclTypeImpl CollectionType();
    public sealed virtual IOclType BagType();
    public sealed virtual IOclType SetType();
    public sealed virtual IOclType SequenceType();
    public sealed virtual IOclType OrderedSetType();
    public sealed virtual bool HasUmlType();
    public OclTypeImpl ElementType();
    public sealed virtual bool IsPrimitiveType();
    public sealed virtual bool IsEnumType();
    public sealed virtual OclTypeImpl GetType();
    private sealed virtual override IOclType Eco.Ocl.Support.IOclType.get_CollectionType();
    private sealed virtual override bool Eco.Ocl.Support.IOclType.ConformsTo(IOclType OclType);
    private sealed virtual override IOclType Eco.Ocl.Support.IOclType.get_ElementType();
    public sealed virtual bool IsSimpleType();
    public sealed virtual bool IsSameType(IOclType oclType);
    public sealed virtual string Name();
}
public class Eco.Ocl.Impl.OclTypeNode : OclNode {
    private string m_TypeName;
    public string TypeName { get; }
    public OclTypeNode(string typeName);
    public string get_TypeName();
    public virtual void AcceptVisitor(OclVisitor V);
    public virtual string ReconstructOcl(OclSymbolDictionary symdict);
}
public class Eco.Ocl.Impl.OclVariableBinding : OclNode {
    private string m_VariableName;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
private bool <IsLoopVar>k__BackingField;
    public string VariableName { get; public set; }
    public bool IsLoopVar { get; public set; }
    public string get_VariableName();
    public void set_VariableName(string value);
    [CompilerGeneratedAttribute]
public bool get_IsLoopVar();
    [CompilerGeneratedAttribute]
public void set_IsLoopVar(bool value);
    public virtual void AcceptVisitor(OclVisitor V);
    public virtual void Subscribe(ISubscriber subscriber);
    public virtual string ReconstructOcl(OclSymbolDictionary symdict);
}
public abstract class Eco.Ocl.Impl.OclVisitor : object {
    public virtual void VisitTBoldOclNode(OclNode N);
    public virtual void VisitTBoldOclTypeNode(OclTypeNode N);
    public virtual void VisitTBoldOclListCoercion(OclListCoercion N);
    public virtual void VisitTBoldOclCollectionLiteral(TBoldOClCollectionLiteral N);
    public virtual void VisitTBoldOclOperation(OclOperation N);
    public virtual void VisitTBoldOclIteration(TBoldOclIteration N);
    public virtual void VisitTBoldOclMember(TBoldOclMember N);
    public virtual void VisitTBoldOclLiteral(TBoldOclLiteral N);
    public virtual void VisitTBoldOclStrLiteral(TBoldOclStrLiteral N);
    public virtual void VisitTBoldOclNumericLiteral(TBoldOclNumericLiteral N);
    public virtual void VisitTBoldOclNamedEnumLiteral(TBoldOclNamedEnumLiteral N);
    public virtual void VisitTBoldOclTypedEnumLiteral(TBoldOclTypedEnumLiteral N);
    public virtual void VisitTBoldOclIntLiteral(TBoldOclIntLiteral N);
    public virtual void VisitTBoldOclVariableReference(TBoldOclVariableReference N);
    public virtual void VisitTBoldOclVariableBinding(OclVariableBinding N);
    public virtual void VisitTBoldOclDateLiteral(TBoldOclDateLiteral N);
    public virtual void VisitTBoldOclMomentLiteral(TBoldOclMomentLiteral N);
    public virtual void VisitTBoldOclTimeLiteral(TBoldOclTimeLiteral N);
}
public class Eco.Ocl.Impl.StopObject : object {
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
private bool <Stop>k__BackingField;
    public bool Stop { get; public set; }
    [CompilerGeneratedAttribute]
public bool get_Stop();
    [CompilerGeneratedAttribute]
public void set_Stop(bool value);
}
public enum Eco.Ocl.Impl.TBOCollectionKind : Enum {
    public int value__;
    public static TBOCollectionKind OclSet;
    public static TBOCollectionKind OclBag;
    public static TBOCollectionKind OclSequence;
}
public class Eco.Ocl.Impl.TBoldInternalSortWrapper : object {
    public sealed virtual int Compare(TBoldOCLSortClass Item1, TBoldOCLSortClass Item2);
}
public class Eco.Ocl.Impl.TBoldOClCollectionLiteral : TBoldOclLiteral {
    public TBOCollectionKind CollectionKind;
    public bool IsRange;
    public OclNode RangeStart;
    public OclNode RangeStop;
    public TBoldOclNodeList Elements;
    public virtual void AcceptVisitor(OclVisitor V);
    public virtual void ClearReferencedValues();
    public virtual string ReconstructOcl(OclSymbolDictionary symdict);
}
public class Eco.Ocl.Impl.TBoldOclDateLiteral : TBoldOclMomentLiteral {
    private DateTime fDateTimeValue;
    public DateTime DateValue { get; public set; }
    public DateTime get_DateValue();
    public void set_DateValue(DateTime value);
    public virtual void AcceptVisitor(OclVisitor V);
    public virtual string ReconstructOcl(OclSymbolDictionary symdict);
}
public class Eco.Ocl.Impl.TBoldOclExternalVariableBinding : OclVariableBinding {
    public IExternalVariable Variable;
    public virtual void Subscribe(ISubscriber Subscriber);
}
public class Eco.Ocl.Impl.TBoldOclIntLiteral : TBoldOclNumericLiteral {
    public int IntValue;
    public virtual void AcceptVisitor(OclVisitor V);
    public virtual string ReconstructOcl(OclSymbolDictionary symdict);
}
public class Eco.Ocl.Impl.TBoldOclIteration : OclOperation {
    public OclVariableBinding LoopVar;
    public int LoopVarCount;
    public int LoopVarIndex;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
private OclDictionaryImpl <Dictionary>k__BackingField;
    public OclDictionaryImpl Dictionary { get; internal set; }
    [CompilerGeneratedAttribute]
public OclDictionaryImpl get_Dictionary();
    [CompilerGeneratedAttribute]
internal void set_Dictionary(OclDictionaryImpl value);
    public virtual void AcceptVisitor(OclVisitor V);
    public virtual void ClearReferencedValues();
    public virtual string ReconstructOcl(OclSymbolDictionary symdict);
}
public enum Eco.Ocl.Impl.TBoldOCLIteratorSpecifier : Enum {
    public int value__;
    public static TBoldOCLIteratorSpecifier OclNoIterator;
    public static TBoldOCLIteratorSpecifier OclSelect;
    public static TBoldOCLIteratorSpecifier OclReject;
    public static TBoldOCLIteratorSpecifier OclCollect;
    public static TBoldOCLIteratorSpecifier OclIterate;
    public static TBoldOCLIteratorSpecifier OclExists;
    public static TBoldOCLIteratorSpecifier OclForAll;
    public static TBoldOCLIteratorSpecifier OclOrderBy;
    public static TBoldOCLIteratorSpecifier OclOrderDescending;
    public static TBoldOCLIteratorSpecifier OclOrderGeneric;
    public static TBoldOCLIteratorSpecifier OclUnique;
    public static TBoldOCLIteratorSpecifier OclGroupBy;
    public static TBoldOCLIteratorSpecifier OclForEach;
    public static TBoldOCLIteratorSpecifier OclDictionary;
}
public class Eco.Ocl.Impl.TBoldOclLetOperation : OclOperation {
    public OclNode variableValue;
    public OclVariableBinding variableBinding;
    public virtual string ReconstructOcl(OclSymbolDictionary symdict);
}
public class Eco.Ocl.Impl.TBoldOclLiteral : OclNode {
    public virtual void AcceptVisitor(OclVisitor V);
}
public class Eco.Ocl.Impl.TBoldOclMember : OclNode {
    private OclNode fMemberOf;
    public string MemberName;
    public OclTypeImpl MemberType;
    public TBoldOclNodeList Qualifier;
    public IStructuralFeature MemberMeta;
    public OclNode MemberOf { get; public set; }
    public bool IsReadOnly { get; }
    public string ModelName { get; }
    public OclNode get_MemberOf();
    public void set_MemberOf(OclNode value);
    public virtual bool get_IsReadOnly();
    public virtual void AcceptVisitor(OclVisitor V);
    public virtual string get_ModelName();
    public virtual void ClearReferencedValues();
    public virtual string ReconstructOcl(OclSymbolDictionary symdict);
}
public class Eco.Ocl.Impl.TBoldOclMomentLiteral : TBoldOclLiteral {
    public virtual void AcceptVisitor(OclVisitor V);
}
public class Eco.Ocl.Impl.TBoldOclNamedEnumLiteral : TBoldOclLiteral {
    private string fName;
    public string Name { get; public set; }
    public sealed virtual string get_Name();
    public void set_Name(string value);
    public virtual void AcceptVisitor(OclVisitor V);
    public virtual string ReconstructOcl(OclSymbolDictionary symdict);
}
[DefaultMemberAttribute("Item")]
public class Eco.Ocl.Impl.TBoldOclNodeList : object {
    private List`1<OclNode> FList;
    public OclNode Item { get; public set; }
    public OclNode get_Item(int index);
    public void set_Item(int index, OclNode value);
    public void Add(OclNode Item);
    public void Delete(int index);
    public void Clear();
    public int Count();
    public void ClearReferencedValues();
}
public class Eco.Ocl.Impl.TBoldOclNumericLiteral : TBoldOclLiteral {
    public double FloatValue;
    public virtual void AcceptVisitor(OclVisitor V);
    public virtual string ReconstructOcl(OclSymbolDictionary symdict);
}
public class Eco.Ocl.Impl.TBoldOclSemanticsVisitor : OclVisitor {
    private OclNode replacementNode;
    private bool ReSubscribe;
    private bool fOnlyAllowPersistentSubset;
    private OclSymbolDictionary SymbolTable;
    private OclEnvironment fEnv;
    private OclSupport fHelp;
    public TBoldOclSemanticsVisitor(OclSupport Help, OclSymbolDictionary SymTab, OclEnvironment Env, bool OnlyPersistent);
    public void PushResubscribe(Boolean& ReSubscribe, Boolean& OldReSubscribe);
    public ArgumentConformanceStatus CheckArgumentType(OclNode ActArg, IOclType FormArg, bool Force, bool AllowImplicitCollect, IClassifier TypeTestValue);
    public void ReplaceEnumLiterals(TBoldOclNodeList Args, IOclOperation Op);
    public OclNode Traverse(OclNode InNode);
    public void TraverseList(TBoldOclNodeList List, int Start, int Stop);
    public IOclOperation[] FindSymbol(string name);
    public void AddListCoercionOnArgs(OclOperation N);
    public void VisitTBoldOclOperation_FixImplicitCollect(OclOperation N);
    public bool VisitTBoldOclOperation_OperationParamsConform(IOclOperation op1, IOclOperation op2);
    public static string OperationHelpString(IOclOperation operation);
    public virtual void VisitTBoldOclOperation(OclOperation N);
    public bool CheckParamCount(IOclOperation Op, OclOperation N);
    public virtual void VisitTBoldOclIteration(TBoldOclIteration N);
    public bool TestForOperation(TBoldOclMember N);
    public virtual void VisitTBoldOclMember(TBoldOclMember N);
    public virtual void VisitTBoldOclVariableReference(TBoldOclVariableReference N);
    public virtual void VisitTBoldOclTypeNode(OclTypeNode N);
    public virtual void VisitTBoldOclStrLiteral(TBoldOclStrLiteral N);
    public virtual void VisitTBoldOclCollectionLiteral(TBoldOClCollectionLiteral N);
    public virtual void VisitTBoldOclNumericLiteral(TBoldOclNumericLiteral N);
    public virtual void VisitTBoldOclNamedEnumLiteral(TBoldOclNamedEnumLiteral N);
    public virtual void VisitTBoldOclTypedEnumLiteral(TBoldOclTypedEnumLiteral N);
    public virtual void VisitTBoldOclIntLiteral(TBoldOclIntLiteral N);
    private TBoldOclSymbolParameters PrepareSymbolParameters(OclOperation N);
    public void SymbolValidation(OclOperation N);
    public void DeduceBoldType(OclOperation N);
    public virtual void VisitTBoldOclDateLiteral(TBoldOclDateLiteral N);
    public virtual void VisitTBoldOclTimeLiteral(TBoldOclTimeLiteral N);
}
public class Eco.Ocl.Impl.TBoldOCLSortClass : object {
    public List`1<IElement> SortArg;
    public IElement SortObj;
}
public class Eco.Ocl.Impl.TBoldOclStrLiteral : TBoldOclLiteral {
    public string StrValue;
    public virtual void AcceptVisitor(OclVisitor V);
    public virtual string ReconstructOcl(OclSymbolDictionary symdict);
}
public class Eco.Ocl.Impl.TBoldOclSymbolParameters : object {
    private int fPos;
    private IOclValue[] fValues;
    private IOclValue fResult;
    private SubscriberPair fSubscriberBlock;
    private int fParamCount;
    public IOclValue[] Values { get; }
    public IOclValue Result { get; public set; }
    public SubscriberPair SubscriberBlock { get; public set; }
    public int Pos { get; public set; }
    public int ParamCount { get; public set; }
    public sealed virtual IOclValue[] get_Values();
    public sealed virtual IOclValue get_Result();
    public void set_Result(IOclValue value);
    public sealed virtual SubscriberPair get_SubscriberBlock();
    public void set_SubscriberBlock(SubscriberPair value);
    public sealed virtual int get_Pos();
    public void set_Pos(int value);
    public sealed virtual int get_ParamCount();
    public void set_ParamCount(int value);
}
public class Eco.Ocl.Impl.TBoldOclTimeLiteral : TBoldOclMomentLiteral {
    private TimeSpan fTimeValue;
    public TimeSpan TimeValue { get; public set; }
    public TimeSpan get_TimeValue();
    public void set_TimeValue(TimeSpan value);
    public virtual void AcceptVisitor(OclVisitor V);
    public virtual string ReconstructOcl(OclSymbolDictionary symdict);
}
public class Eco.Ocl.Impl.TBoldOclTypedEnumLiteral : TBoldOclLiteral {
    private IEnumerationType fEnumType;
    private IEnumerationLiteral fEnumValue;
    public IEnumerationType EnumType { get; public set; }
    public IEnumerationLiteral EnumValue { get; public set; }
    public IEnumerationType get_EnumType();
    public void set_EnumType(IEnumerationType value);
    public IEnumerationLiteral get_EnumValue();
    public void set_EnumValue(IEnumerationLiteral value);
    public virtual void AcceptVisitor(OclVisitor V);
    public virtual string ReconstructOcl(OclSymbolDictionary symdict);
}
public class Eco.Ocl.Impl.TBoldOclVariableReference : OclNode {
    public string VariableName;
    public OclVariableBinding VariableBinding;
    public virtual void AcceptVisitor(OclVisitor V);
    public virtual void ClearReferencedValues();
    public virtual string ReconstructOcl(OclSymbolDictionary symdict);
}
public class Eco.Ocl.Impl.TBoldOLWNodeMaker : OclVisitor {
    private bool fFailed;
    private int fFailurePosition;
    private string fFailureReason;
    private TBoldOLWNode fRootNode;
    private List`1<TBoldOLWVariableBinding> fOLWVarBindings;
    private List`1<OclVariableBinding> fVarBindings;
    private List`1<TBoldOLWVariableBinding> fExternalVarBindings;
    private OclNode fOclRootNode;
    private OclEnvironment fEnv;
    private OclSupport fHelp;
    private ICache fCache;
    private IObjectRepresentationProvider fObjRepProv;
    protected List`1<TBoldOLWVariableBinding> OLWVarBindings { get; }
    protected List`1<OclVariableBinding> VarBindings { get; }
    public TBoldOLWNode RootNode { get; }
    public bool Failed { get; }
    public string FailureReason { get; }
    public int FailurePosition { get; }
    public List`1<TBoldOLWVariableBinding> ExternalVarBindings { get; }
    public TBoldOLWNodeMaker(OclNode OclRootNode, OclEnvironment Env, OclSupport Help, ICache cache, IObjectRepresentationProvider objRepProv, PsMode psmode);
    protected List`1<TBoldOLWVariableBinding> get_OLWVarBindings();
    protected List`1<OclVariableBinding> get_VarBindings();
    public TBoldOLWNode get_RootNode();
    public bool get_Failed();
    public string get_FailureReason();
    public int get_FailurePosition();
    public List`1<TBoldOLWVariableBinding> get_ExternalVarBindings();
    protected void SetFailure(int Position, string Message);
    public TBoldOLWVariableBinding OLWBindingForVarBinding(OclVariableBinding VarBinding);
    public virtual void VisitTBoldOclCollectionLiteral(TBoldOClCollectionLiteral N);
    public virtual void VisitTBoldOclNamedEnumLiteral(TBoldOclNamedEnumLiteral N);
    public virtual void VisitTBoldOclTypedEnumLiteral(TBoldOclTypedEnumLiteral N);
    public virtual void VisitTBoldOclIntLiteral(TBoldOclIntLiteral N);
    public virtual void VisitTBoldOclIteration(TBoldOclIteration N);
    public virtual void VisitTBoldOclListCoercion(OclListCoercion N);
    public virtual void VisitTBoldOclLiteral(TBoldOclLiteral N);
    public virtual void VisitTBoldOclMember(TBoldOclMember N);
    public virtual void VisitTBoldOclNode(OclNode N);
    public virtual void VisitTBoldOclNumericLiteral(TBoldOclNumericLiteral N);
    public virtual void VisitTBoldOclOperation(OclOperation N);
    public virtual void VisitTBoldOclStrLiteral(TBoldOclStrLiteral N);
    public virtual void VisitTBoldOclTypeNode(OclTypeNode N);
    public ObjectId VisitTBoldOclVariableBinding_IdForObject(IElement obj);
    public virtual void VisitTBoldOclVariableBinding(OclVariableBinding N);
    public virtual void VisitTBoldOclVariableReference(TBoldOclVariableReference N);
    public virtual void VisitTBoldOclDateLiteral(TBoldOclDateLiteral N);
    public virtual void VisitTBoldOclTimeLiteral(TBoldOclTimeLiteral N);
}
public enum Eco.Ocl.ParserCore.CollectionKind : Enum {
    public int value__;
    public static CollectionKind Set;
    public static CollectionKind Bag;
    public static CollectionKind Sequence;
}
public class Eco.Ocl.ParserCore.InvalidOclException : Exception {
    public InvalidOclException(string message);
    public InvalidOclException(string message, Exception inner);
    protected InvalidOclException(SerializationInfo info, StreamingContext context);
}
public class Eco.Ocl.ParserCore.InvalidOclSyntaxException : InvalidOclException {
    public InvalidOclSyntaxException(string message);
    public InvalidOclSyntaxException(string message, Exception inner);
    protected InvalidOclSyntaxException(SerializationInfo info, StreamingContext context);
}
public class Eco.Ocl.ParserCore.MDriOclLexClass : SSLex {
    public static int MDriOclLexExprMain;
    public static int MDriOclLexExprStringLiteral;
    public static int MDriOclLexTokenINTEGER;
    public static int MDriOclLexTokenFLOAT;
    public static int MDriOclLexTokenNAME;
    public static int MDriOclLexTokenENUMLITERAL;
    public static int MDriOclLexTokenDATE;
    public static int MDriOclLexTokenTIME;
    public static int MDriOclLexTokenDATETIME;
    public static int MDriOclLexTokenStringSt;
    public static int MDriOclLexTokenLBrack;
    public static int MDriOclLexTokenRBrack;
    public static int MDriOclLexTokenLParen;
    public static int MDriOclLexTokenRParen;
    public static int MDriOclLexTokenLBrace;
    public static int MDriOclLexTokenRBrace;
    public static int MDriOclLexTokenGreater;
    public static int MDriOclLexTokenLess;
    public static int MDriOclLexTokenEqual;
    public static int MDriOclLexTokenGTEqual;
    public static int MDriOclLexTokenLTEqual;
    public static int MDriOclLexTokenNEqual;
    public static int MDriOclLexTokenPlus;
    public static int MDriOclLexTokenMinus;
    public static int MDriOclLexTokenMult;
    public static int MDriOclLexTokenDiv;
    public static int MDriOclLexTokenDot;
    public static int MDriOclLexTokenArrow;
    public static int MDriOclLexTokenComma;
    public static int MDriOclLexTokenCommercialAt;
    public static int MDriOclLexTokenIF;
    public static int MDriOclLexTokenLET;
    public static int MDriOclLexTokenIN;
    public static int MDriOclLexTokenTHEN;
    public static int MDriOclLexTokenELSE;
    public static int MDriOclLexTokenENDIF;
    public static int MDriOclLexTokenENUM;
    public static int MDriOclLexTokenBAR;
    public static int MDriOclLexTokenDOUBLECOLON;
    public static int MDriOclLexTokenDOUBLEDOT;
    public static int MDriOclLexTokenCOLON;
    public static int MDriOclLexTokenASSIGN;
    public static int MDriOclLexTokenSTMTSEPARATOR;
    public static int MDriOclLexTokenBAG;
    public static int MDriOclLexTokenSET;
    public static int MDriOclLexTokenSEQUENCE;
    public static int MDriOclLexTokenCOLLECTION;
    public static int MDriOclLexTokenIntDIV;
    public static int MDriOclLexTokenMOD;
    public static int MDriOclLexTokenAND;
    public static int MDriOclLexTokenOR;
    public static int MDriOclLexTokenNOT;
    public static int MDriOclLexTokenXOR;
    public static int MDriOclLexTokenIMPLIES;
    public static int MDriOclLexTokenString;
    public static int MDriOclLexTokenStringEnd;
    public MDriOclLexClass(SSLexTable q_table, SSLexConsumer q_consumer);
}
public class Eco.Ocl.ParserCore.MDriOclLexTable : SSLexTable {
    private Int32[] m_rows0;
    private Int32[] m_rows1;
    private Int32[] m_finalStates0;
    private Int32[] m_finalStates1;
}
public class Eco.Ocl.ParserCore.MDriOclYaccClass : SSYacc {
    public static int MDriOclYaccProdGoal;
    public static int MDriOclYaccProdexpressionPost;
    public static int MDriOclYaccProdexpressionAnd;
    public static int MDriOclYaccProdexpressionOr;
    public static int MDriOclYaccProdexpressionXor;
    public static int MDriOclYaccProdexpressionImp;
    public static int MDriOclYaccProdexpressionEQ;
    public static int MDriOclYaccProdexpressionLT;
    public static int MDriOclYaccProdexpressionGT;
    public static int MDriOclYaccProdexpressionLE;
    public static int MDriOclYaccProdexpressionGE;
    public static int MDriOclYaccProdexpressionNE;
    public static int MDriOclYaccProdexpressionAdd;
    public static int MDriOclYaccProdexpressionSub;
    public static int MDriOclYaccProdexpressionDiv;
    public static int MDriOclYaccProdexpressionMul;
    public static int MDriOclYaccProdexpressionDivI;
    public static int MDriOclYaccProdexpressionMod;
    public static int MDriOclYaccProdexpressionASSIGN;
    public static int MDriOclYaccProdexpressionSTRMSEQUENCE;
    public static int MDriOclYaccProdexpressionLET;
    public static int MDriOclYaccProdexpressionNeg;
    public static int MDriOclYaccProdexpressionNOT;
    public static int MDriOclYaccProdifExpression;
    public static int MDriOclYaccProdpostFixFirst;
    public static int MDriOclYaccProdpostFixMember;
    public static int MDriOclYaccProdpostFixMethod;
    public static int MDriOclYaccProdpostFixOperation;
    public static int MDriOclYaccProdpostFixOperationParams;
    public static int MDriOclYaccProdprimaryExpLittCollection;
    public static int MDriOclYaccProdprimaryExpLitt;
    public static int MDriOclYaccProdprimaryExpParen;
    public static int MDriOclYaccProdprimaryExpIf;
    public static int MDriOclYaccProdPrimaryNoParams;
    public static int MDriOclYaccProdPrimaryWithParams;
    public static int MDriOclYaccProdfeatureCallParameters1;
    public static int MDriOclYaccProdfeatureCallParameters2;
    public static int MDriOclYaccProdliteral_String;
    public static int MDriOclYaccProdliteral_EmptyString;
    public static int MDriOclYaccProdliteral_Number;
    public static int MDriOclYaccProdliteral_float;
    public static int MDriOclYaccProdliteral_Date;
    public static int MDriOclYaccProdliteral_DateTime;
    public static int MDriOclYaccProdliteral_Time;
    public static int MDriOclYaccProdliteral_Name;
    public static int MDriOclYaccProdliteralCollection;
    public static int MDriOclYaccProdexpressionListOrRange_List;
    public static int MDriOclYaccProdexpressionList;
    public static int MDriOclYaccProdexpressionList_Rec;
    public static int MDriOclYaccProdexpressionListOrRange_Range;
    public static int MDriOclYaccProdqualifiers_Ety;
    public static int MDriOclYaccProdqualifiers;
    public static int MDriOclYaccProdpathName;
    public static int MDriOclYaccProdpathName_Rec;
    public static int MDriOclYaccProdanyName_Name;
    public static int MDriOclYaccProdtimeExpression;
    public static int MDriOclYaccProdtimeExpression_Ety;
    public static int MDriOclYaccProdactualParameterList_ety;
    public static int MDriOclYaccProdActualParameterlist_nonEty;
    public static int MDriOclYaccProdNonEmptyactualParameterList;
    public static int MDriOclYaccProdNonEmptyactualParameterList_Rec;
    public static int MDriOclYaccProdcollectionKind_Set;
    public static int MDriOclYaccProdcollectionKind_Bag;
    public static int MDriOclYaccProdcollectionKind_Sequence;
    public static int MDriOclYaccProdcollectionKind_Collection;
    private OclParserCoreBackend backend;
    public SSYaccStackElement finalValue;
    public int Errorposition { get; }
    public MDriOclYaccClass(SSYaccTable q_table, SSLex q_lex, OclParserCoreBackend initBackend);
    private OclStackElement getStackElement(int index);
    public virtual SSYaccStackElement stackElement();
    public virtual SSYaccStackElement reduce(int q_prod, int q_size);
    public int get_Errorposition();
}
public class Eco.Ocl.ParserCore.MDriOclYaccTable : SSYaccTable {
    private Int32[] m_prodData;
    private Int32[] m_rowData;
}
public class Eco.Ocl.ParserCore.OclStackElement : SSYaccStackElement {
    private int offset;
    private OclNode node;
    private string name;
    private List`1<OclStackElement> declaratorTypeList;
    private List`1<OclStackElement> list;
    private bool simpleTypeSpecifierIsEnum;
    private OclNode start;
    private OclNode stop;
    public int Offset { get; }
    public OclNode Node { get; public set; }
    public string Name { get; public set; }
    public List`1<OclStackElement> DeclaratorTypeList { get; public set; }
    public List`1<OclStackElement> List { get; public set; }
    public bool SimpleTypeSpecifierIsEnum { get; public set; }
    public OclNode Start { get; public set; }
    public OclNode Stop { get; public set; }
    public OclStackElement(int InitOffset);
    public OclStackElement Clone();
    public int get_Offset();
    public OclNode get_Node();
    public void set_Node(OclNode value);
    public string get_Name();
    public void set_Name(string value);
    public List`1<OclStackElement> get_DeclaratorTypeList();
    public void set_DeclaratorTypeList(List`1<OclStackElement> value);
    public List`1<OclStackElement> get_List();
    public void set_List(List`1<OclStackElement> value);
    public bool get_SimpleTypeSpecifierIsEnum();
    public void set_SimpleTypeSpecifierIsEnum(bool value);
    public OclNode get_Start();
    public void set_Start(OclNode value);
    public OclNode get_Stop();
    public void set_Stop(OclNode value);
}
public class Eco.Ocl.ParserCore.SSLex : object {
    private int m_state;
    private Char[] m_currentChar;
    private SSLexTable m_table;
    private SSLexConsumer m_consumer;
    internal SSLex(SSLexTable q_table, SSLexConsumer q_consumer);
    public SSLexTable table();
    public SSLexConsumer consumer();
    public virtual bool error(SSLexLexeme q_lexeme);
    public virtual bool complete(SSLexLexeme q_lexeme);
    internal SSLexLexeme next();
}
public class Eco.Ocl.ParserCore.SSLexCharacterClass : object {
    private int m_size;
    private int m_min;
    private int m_max;
    private Int32[] m_array;
    public SSLexCharacterClass(int q_size, int q_min, int q_max, Int32[] q_array);
    internal bool translate(Char[] q_char);
}
public abstract class Eco.Ocl.ParserCore.SSLexConsumer : object {
    private static ArrayPool`1<char> _pool;
    private int m_line;
    private int m_start;
    protected int m_index;
    private int m_offset;
    protected char m_current;
    protected int m_length;
    private int m_scanLine;
    private int m_scanOffset;
    private int m_bufferIndex;
    private char m_bof;
    private bool m_endOfData;
    private Char[] m_buffer;
    private int m_bufferLength;
    private static SSLexConsumer();
    public abstract virtual bool getNext();
    internal bool next();
    internal int line();
    internal int offset();
    internal char getCurrent();
    public int absoluteOffset();
    internal SSLexMark mark();
    internal void flushEndOfLine(SSLexMark q_mark);
    internal void flushStartOfLine(SSLexMark q_mark);
    public virtual void flushLexeme(SSLexMark q_mark);
    internal void flushLexeme();
    internal int lexemeLength();
    internal int lexemeLength(SSLexMark q_mark);
    internal Char[] lexemeBuffer();
    internal Char[] lexemeBuffer(SSLexMark q_mark);
    public sealed virtual void Dispose();
}
public class Eco.Ocl.ParserCore.SSLexFinalState : object {
    public static int m_flagContextStart;
    public static int m_flagStartOfLine;
    public static int m_flagPop;
    public static int m_flagFinal;
    public static int m_flagPush;
    public static int m_flagIgnore;
    public static int m_flagContextEnd;
    public static int m_flagReduce;
    public static int m_flagKeyword;
    public static int m_flagParseToken;
    private int m_flags;
    private int m_token;
    private int m_pushIndex;
    public SSLexFinalState(Int32[] q_final, int q_index);
    internal int token();
    internal int pushIndex();
    internal bool isPop();
    internal bool isPush();
    internal bool isFinal();
    internal bool isIgnore();
    internal bool isReduce();
    internal bool isContextEnd();
    internal bool isStartOfLine();
    internal bool isContextStart();
    internal bool isKeyword();
    public bool isParseToken();
}
public class Eco.Ocl.ParserCore.SSLexKeyTable : object {
    internal Int32[] m_index;
    internal String[] m_keys;
}
public class Eco.Ocl.ParserCore.SSLexLexeme : object {
    private int m_line;
    private int m_token;
    private int m_length;
    private int m_offset;
    private int m_parseToken;
    private Char[] m_lexeme;
    public SSLexLexeme(string q_lexeme, int q_token);
    public SSLexLexeme(SSLexConsumer q_consumer);
    public SSLexLexeme(SSLexConsumer q_consumer, SSLexFinalState q_final, SSLexMark q_mark);
    public int line();
    internal int token();
    internal int offset();
    public int length();
    public int parseToken();
    public Char[] lexeme();
    public void setLine(int q_line);
    internal void setToken(int q_token);
    internal void setOffset(int q_offset);
    public void setLength(int q_length);
    public void setparseToken(int q_parseToken);
    public void setLexeme(Char[] q_lexeme);
}
public class Eco.Ocl.ParserCore.SSLexMark : object {
    internal int m_line;
    internal int m_index;
    internal int m_offset;
    public SSLexMark(int q_line, int q_offset, int q_index);
    internal int index();
}
public class Eco.Ocl.ParserCore.SSLexStringConsumer : SSLexConsumer {
    private string m_string;
    public SSLexStringConsumer(string q_string);
    public virtual bool getNext();
}
internal class Eco.Ocl.ParserCore.SSLexSubtable : object {
    private int m_size;
    private SSLexTableRow[] m_rows;
    private SSLexFinalState[] m_final;
    public static int SSLexStateInvalid;
    internal SSLexSubtable(int q_numRows, Int32[] q_rows, Int32[] q_final);
    internal int lookup(int q_state, int q_next);
    internal SSLexFinalState lookupFinal(int q_state);
}
public class Eco.Ocl.ParserCore.SSLexTable : object {
    private Stack`1<SSLexSubtable> m_stack;
    private int m_classes;
    private int m_classMin;
    private int m_classMax;
    public SSLexFinalState[] m_final;
    internal SSLexSubtable[] m_subTables;
    private SSLexKeyTable[] m_keyTables;
    private SSLexCharacterClass[] m_charClassTables;
    public static int SSLexStateInvalid;
    internal void CleanForFree();
    internal bool translateClass(Char[] q_char);
    public int convertInt(Byte[] b, int offset);
    internal void findKeyword(SSLexLexeme z_lexeme);
    internal void gotoSubtable(int q_index);
    internal void pushSubtable(int q_index);
    internal void popSubtable();
    internal int lookup(int q_state, int q_next);
    internal SSLexFinalState lookupFinal(int q_state);
}
public class Eco.Ocl.ParserCore.SSLexTableHeader : object {
    public int size;
    public int type;
    public Int32[] reserved;
}
public class Eco.Ocl.ParserCore.SSLexTableRow : object {
    private int m_size;
    private SSLexTableRowEntry[] m_entries;
    public SSLexTableRow(Int32[] q_row, int q_index);
    internal int lookup(int q_code);
}
internal class Eco.Ocl.ParserCore.SSLexTableRowEntry : object {
    private int m_end;
    private int m_start;
    private int m_state;
    internal SSLexTableRowEntry(int q_start, int q_end, int q_state);
    internal int end();
    internal int start();
    internal int state();
}
public class Eco.Ocl.ParserCore.SSYacc : object {
    public static int SSYaccActionShift;
    public static int SSYaccActionError;
    public static int SSYaccActionReduce;
    public static int SSYaccActionAccept;
    public static int SSYaccActionConflict;
    private int m_cache;
    private int m_state;
    private SSLex m_lex;
    private int m_action;
    private int m_leftside;
    private bool m_error;
    private bool m_abort;
    private int m_production;
    private SSYaccStack m_stack;
    private SSYaccTable m_table;
    private int m_productionSize;
    private bool m_endOfInput;
    private SSLexLexeme m_endLexeme;
    private SSLexLexeme m_lookahead;
    private SSLexLexeme m_larLookahead;
    private SSLexSubtable m_lexSubtable;
    private SSYaccStackElement m_element;
    private SSYaccStackElement m_treeRoot;
    private SSYaccCache m_lexemeCache;
    public static int m_eofToken;
    public static int m_errorToken;
    public static int SSYaccLexemeCacheMax;
    public SSYaccStackElement Element { get; }
    protected SSYacc(SSYaccTable q_table, SSLex q_lex);
    public SSYaccStackElement get_Element();
    public virtual SSYaccStackElement reduce(int q_prod, int q_length);
    public virtual SSLexLexeme nextLexeme();
    public virtual SSYaccStackElement stackElement();
    public virtual SSYaccStackElement shift(SSLexLexeme q_lexeme);
    private bool larLookahead(SSLexLexeme q_lex);
    public virtual bool error(int q_state, SSLexLexeme q_look);
    private bool larError(int q_state, SSLexLexeme q_look, SSLexLexeme q_larLook);
    public bool parse();
    private bool doShift();
    private bool doReduce();
    private bool doError();
    private bool doLarError();
    private SSLexLexeme getLexemeCache();
    private bool doConflict();
    private bool doGetLexeme(bool q_look);
    private bool getLexeme(bool q_look);
    private bool goTo(int q_goto);
    private bool syncErr();
    private void lookupAction(int q_state, int q_token);
    private bool lookupGoto(int q_state, int q_token);
    private bool push();
    private bool push(SSYaccStackElement q_element);
    private bool pop(int q_pop);
    protected SSYaccStackElement elementFromProduction(int q_index);
    public void setAbort();
    public bool wasAborted();
    public bool wasError();
    public SSYaccStackElement addSubTree();
    public SSYaccStackElement treeRoot();
}
public class Eco.Ocl.ParserCore.SSYaccCache : Queue`1<SSLexLexeme> {
    internal bool hasElements();
    internal SSLexLexeme remove();
}
internal class Eco.Ocl.ParserCore.SSYaccSet : Queue`1<int> {
    internal bool add(int q_object);
    internal bool locate(int q_locate);
}
internal class Eco.Ocl.ParserCore.SSYaccStack : List`1<object> {
    private int m_size;
    internal SSYaccStack(int q_size, int q_inc);
    internal void push(object q_ele);
    internal void pop();
    internal object elementAt(int index);
    internal int getSize();
    internal object peek();
}
public class Eco.Ocl.ParserCore.SSYaccStackElement : object {
    private int m_state;
    private int m_subTreeSize;
    private SSLexLexeme m_lexeme;
    private SSYaccStackElement[] m_subTree;
    internal int state();
    public SSLexLexeme lexeme();
    internal void setState(int q_state);
    internal void setLexeme(SSLexLexeme q_lexeme);
    internal void createSubTree(int q_size);
    internal bool addSubTree(int q_index, SSYaccStackElement q_ele);
    public SSYaccStackElement getSubTree(int q_index);
    public int getSubTreeSize();
}
public class Eco.Ocl.ParserCore.SSYaccTable : object {
    protected SSYaccTableRow[] m_rows;
    internal SSYaccTableProd[] m_prods;
    private SSLexSubtable[] m_lexSubtables;
    public int convertInt(Byte[] b, int offset);
    internal SSYaccTableRow lookupRow(int q_state);
    internal SSYaccTableProd lookupProd(int q_index);
    internal SSLexSubtable larTable(int q_entry);
    internal void CleanForFree();
}
public class Eco.Ocl.ParserCore.SSYaccTableHeader : object {
    public int type;
    private int prodOrLar;
    public int numRows;
    public int rowOffset;
    public int prodOffset;
    public int numLars();
    public int numProds();
}
public class Eco.Ocl.ParserCore.SSYaccTableProd : object {
    private int m_size;
    private int m_leftside;
    public SSYaccTableProd(int q_size, int q_leftside);
    internal int size();
    internal int leftside();
}
public class Eco.Ocl.ParserCore.SSYaccTableRow : object {
    private int m_goto;
    public int m_flags;
    private int m_action;
    private bool m_sync;
    private bool m_error;
    private bool m_syncAll;
    private SSYaccTableRowEntry[] m_entries;
    public SSYaccTableRow(Int32[] q_data, int q_index);
    internal SSYaccTableRowEntry lookupEntry(int q_index);
    internal SSYaccTableRowEntry lookupAction(int q_index);
    internal SSYaccTableRowEntry lookupGoto(int q_index);
    internal SSYaccTableRowEntry lookupError();
    internal bool hasError();
    internal bool hasSync();
    internal bool hasSyncAll();
    internal int action();
    private int numEntries();
}
internal class Eco.Ocl.ParserCore.SSYaccTableRowEntry : object {
    public static int SSYaccActionShift;
    public static int SSYaccActionError;
    public static int SSYaccActionReduce;
    public static int SSYaccActionAccept;
    public static int SSYaccActionConflict;
    private static UInt32 SSYaccTableEntryFlagSync;
    private static int SSYaccTableEntryFlagShift;
    private static int SSYaccTableEntryFlagReduce;
    private static int SSYaccTableEntryFlagAccept;
    private static int SSYaccTableEntryFlagConflict;
    private static UInt32 SSYaccTableEntryFlagMask;
    private int m_token;
    private int m_entry;
    private int m_action;
    private bool m_sync;
    internal SSYaccTableRowEntry(int q_token, int q_entry, int q_action, int q_sync);
    internal int action();
    internal int entry();
    internal int token();
    internal bool hasSync();
}
[EcoOclOperationResourcedHelpAttribute("Returns the zero based position of the element in the list")]
public class Eco.Ocl.Support.At0 : OclOperationBase {
    public static void InstallOperation(IEcoServiceProvider serviceProvider);
    public virtual void Evaluate(IOclOperationParameters oclParameters);
    protected virtual void Init();
}
[EcoOclOperationResourcedHelpAttribute("calls .net System.Convert.FromBase64String")]
public class Eco.Ocl.Support.Base64ToBlob : OclOperationBase {
    protected virtual void Init();
    public virtual void Evaluate(IOclOperationParameters __Params);
}
[EcoOclOperationResourcedHelpAttribute("calls .net System.Convert.FromBase64String with UTF8")]
public class Eco.Ocl.Support.Base64ToString : OclOperationBase {
    protected virtual void Init();
    public virtual void Evaluate(IOclOperationParameters __Params);
}
[EcoOclOperationResourcedHelpAttribute("calls .net System.Convert.ToBase64String")]
public class Eco.Ocl.Support.BlobToBase64 : OclOperationBase {
    protected virtual void Init();
    public virtual void Evaluate(IOclOperationParameters __Params);
}
[EcoOclOperationResourcedHelpAttribute("Returns Date part of Now")]
public class Eco.Ocl.Support.DateTimeDate : OclOperationBase {
    public virtual void Evaluate(IOclOperationParameters oclParameters);
    protected virtual void Init();
}
[EcoOclOperationResourcedHelpAttribute("Returns time part of Now")]
public class Eco.Ocl.Support.DateTimeTime : OclOperationBase {
    public virtual void Evaluate(IOclOperationParameters oclParameters);
    protected virtual void Init();
}
public static class Eco.Ocl.Support.EcoEnvironment : object {
    private static IElement _UserNameElement;
    private static IElement _UserDomainNameElement;
    private static string _UserName;
    private static string _UserDomainName;
    public static object UserDomainName { get; }
    public static object UserName { get; }
    private static EcoEnvironment();
    public static void OverrideCurrentUserAndDomainSetting(string userName, string userDomainName);
    internal static IElement GetOrCreateUserDomainNameAsElement(IOclOperationSupport support);
    internal static IElement GetOrCreateUserNameAsElement(IOclOperationSupport support);
    public static object get_UserDomainName();
    public static object get_UserName();
}
[EcoOclOperationResourcedHelpAttribute("Will return windows Environment.UserName")]
public class Eco.Ocl.Support.EnvironmentUser : OclOperationBase {
    public virtual void Evaluate(IOclOperationParameters oclParameters);
    protected virtual void Init();
}
[EcoOclOperationResourcedHelpAttribute("Will return windows Environment.UserDomainName")]
public class Eco.Ocl.Support.EnvironmentUserDomain : OclOperationBase {
    public virtual void Evaluate(IOclOperationParameters oclParameters);
    protected virtual void Init();
}
[EcoOclOperationResourcedHelpAttribute("Returns the position of the element as a 0-based index.")]
public class Eco.Ocl.Support.IndexOf0 : OclOperationBase {
    public static void InstallOperation(IEcoServiceProvider serviceProvider);
    public virtual void Evaluate(IOclOperationParameters oclParameters);
    protected virtual void Init();
}
[EcoOclOperationResourcedHelpAttribute("Assigns a new value to a property, associationend or variable")]
public class Eco.Ocl.Support.OclAssign : OclOperationBase {
    public virtual void Evaluate(IOclOperationParameters oclParameters);
    protected virtual void Init();
    public virtual void SemanticCheck(IOclOperationParameters oclParameters);
    public static void CheckEnumLiteral(IOclValue param, IOclValue param2);
    private static void CheckEnumLiteralInternal(IOclValue param, IOclValue param2);
}
[EcoOclOperationResourcedHelpAttribute("Enters mode where you are allowed to assign value to state attribute - ignoring all rules")]
public class Eco.Ocl.Support.OclEnterStateMachineAdminMode : OclOperationBase {
    public virtual void Evaluate(IOclOperationParameters oclParameters);
    protected virtual void Init();
}
public class Eco.Ocl.Support.OclMethod : OclMethodBase {
    public OclMethod(IMethod method);
}
public class Eco.Ocl.Support.OclMethodBase : OclOperationBase {
    private IMethod m_Method;
    public IFeature MemberMeta { get; }
    public OclMethodBase(IMethod method);
    public IFeature get_MemberMeta();
    public virtual void Evaluate(IOclOperationParameters oclParameters);
    private bool CheckIfWeShouldIgnoreOverrides(IOclOperationParameters oclParameters);
    protected virtual void Init();
}
public abstract class Eco.Ocl.Support.OclMethodInstaller : object {
    private static void InstallMethod(ITypeService typeService, IMethod method, OclMethodsFilter filter);
    public static void InstallMethodsForClass(ITypeService typeService, IClass umlClass, OclMethodsFilter filter);
    public static void InstallMethods(ITypeService typeService, IEcoTypeSystem typeSystem, OclMethodsFilter filter);
    public static void InstallQueryMethods(ITypeService typeService, IEcoTypeSystem typeSystem);
    public static void InstallNonQueryMethods(ITypeService typeService, IEcoTypeSystem typeSystem);
}
[FlagsAttribute]
public enum Eco.Ocl.Support.OclMethodsFilter : Enum {
    public int value__;
    public static OclMethodsFilter NonQuery;
    public static OclMethodsFilter IsQuery;
    public static OclMethodsFilter All;
}
[EcoOclOperationResourcedHelpAttribute("Generates a new Guid")]
public class Eco.Ocl.Support.OclNewGuid : OclOperationBase {
    public virtual void Evaluate(IOclOperationParameters oclParameters);
    public virtual void SemanticCheck(IOclOperationParameters oclParameters);
    protected virtual void Init();
}
public class Eco.Ocl.Support.OclPreconditionQuery : OclOperationBase {
    private IMethod m_Method;
    public OclPreconditionQuery(IMethod method);
    public virtual void Evaluate(IOclOperationParameters oclParameters);
    protected virtual void Init();
}
public class Eco.Ocl.Support.OclPsStandardOperations : object {
    public static int op_Addition(int a, int b);
    public static long op_Addition(long a, long b);
    public static double op_Addition(double a, double b);
    public static int op_Subtraction(int a, int b);
    public static long op_Subtraction(long a, long b);
    public static double op_Subtraction(double a, double b);
    public static int op_Multiply(int a, int b);
    public static long op_Multiply(long a, long b);
    public static double op_Multiply(double a, double b);
    public static double op_Division(int a, int b);
    public static double op_Division(long a, long b);
    public static double op_Division(double a, double b);
    public static int op_UnaryNegation(int b);
    public static long op_UnaryNegation(long b);
    public static double op_UnaryNegation(double b);
    public static int minValue(IList`1<int> list);
    public static long minValue(IList`1<long> list);
    public static double minValue(IList`1<double> list);
    public static decimal minValue(IList`1<decimal> list);
    public static DateTime minValue(IList`1<DateTime> list);
    public static TimeSpan minValue(IList`1<TimeSpan> list);
    public static int maxValue(IList`1<int> list);
    public static long maxValue(IList`1<long> list);
    public static double maxValue(IList`1<double> list);
    public static decimal maxValue(IList`1<decimal> list);
    public static DateTime maxValue(IList`1<DateTime> list);
    public static TimeSpan maxValue(IList`1<TimeSpan> list);
    public static decimal average(IList`1<decimal> list);
    public static double average(IList`1<double> list);
    public static double average(IList`1<int> list);
    public static double average(IList`1<long> list);
    public static int sum(IList`1<int> list);
    public static double sum(IList`1<double> list);
    public static long sum(IList`1<long> list);
    public static decimal sum(IList`1<decimal> list);
}
public class Eco.Ocl.Support.OclPsStringOperations : object {
    public static string op_Addition(string a, string b);
}
[EcoOclOperationResourcedHelpAttribute("Returns a random number lower than argument")]
public class Eco.Ocl.Support.OclRandom : OclOperationBase {
    private static Random _random;
    public virtual void Evaluate(IOclOperationParameters oclParameters);
    protected virtual void Init();
}
[EcoOclOperationResourcedHelpAttribute("sets the attribute or associationend to null")]
public class Eco.Ocl.Support.OclSetToNull : OclOperationBase {
    public virtual void Evaluate(IOclOperationParameters oclParameters);
    public virtual void SemanticCheck(IOclOperationParameters oclParameters);
    protected virtual void Init();
}
public class Eco.Ocl.Support.OclStandardOperations : object {
    public static string op_Addition(string a, string b);
    public static decimal toDecimal(double a);
    public static double toDouble(decimal a);
    public static TimeSpan sumTime(IList`1<TimeSpan> list);
    [EcoOclOperationResourcedHelpAttribute("Eco.Internal.BoldOclConst:OclHelpInDateRange")]
public static bool inDateRange(DateTime dt, DateTime start, DateTime stop);
    [EcoOclOperationResourcedHelpAttribute("Eco.Internal.BoldOclConst:OclHelpInTimeRange")]
public static bool inTimeRange(TimeSpan ts, TimeSpan start, TimeSpan stop);
    public static string asCommaList(IList`1<string> list);
    public static string asSeparatedList(IList`1<string> list, string separator);
}
public class Eco.Ocl.Support.OclStateMachineTrigger : OclOperationBase {
    public virtual void Evaluate(IOclOperationParameters oclParameters);
    protected virtual void Init();
}
public class Eco.Ocl.Support.OclTrigger : OclMethodBase {
    public OclTrigger(IMethod method);
}
public class Eco.Ocl.Support.OclTriggerQuery : OclOperationBase {
    private IMethod m_Method;
    public OclTriggerQuery(IMethod method);
    public virtual void Evaluate(IOclOperationParameters oclParameters);
    protected virtual void Init();
}
[EcoOclOperationResourcedHelpAttribute("calls .net System.Convert.ToBase64String with System.Text.Encoding.GetEncoding(1252)")]
public class Eco.Ocl.Support.StringToAnsiBase64 : OclOperationBase {
    protected virtual void Init();
    public virtual void Evaluate(IOclOperationParameters __Params);
}
[EcoOclOperationResourcedHelpAttribute("calls .net System.Convert.ToBase64String with UTF8")]
public class Eco.Ocl.Support.StringToBase64 : OclOperationBase {
    protected virtual void Init();
    public virtual void Evaluate(IOclOperationParameters __Params);
}
[EcoOclOperationResourcedHelpAttribute("calls .net System.Convert.ToBase64String with encoding as sent in codepage (System.Text.Encoding.GetEncoding)")]
public class Eco.Ocl.Support.StringToEncodedBase64 : OclOperationBase {
    protected virtual void Init();
    public virtual void Evaluate(IOclOperationParameters __Params);
}
public class Eco.Ocl.Support.TimeSpanSum : OclOperationBase {
    public virtual void Evaluate(IOclOperationParameters oclParameters);
    protected virtual void Init();
}
public abstract class Eco.Persistence.AbstractDataBlockPersistenceMapper : PersistenceMapper {
    private int m_ActiveCount;
    private bool m_CacheData;
    private bool m_MultiUser;
    private ITypeSystemService m_TypeSystemService;
    private Datablock m_Cache;
    protected Dictionary`2<object, int> m_AutoIncValues;
    private static Random m_Random;
    private Dictionary`2<int, List`1<IAttribute>> classesWithDbAssignedAttributes;
    private AbstractSyncHandler m_SyncHandler;
    protected object idkey;
    protected object versionkey;
    [DefaultValueAttribute("True")]
public bool MultiUser { get; public set; }
    private bool Active { get; }
    [LocalizableCategoryAttribute("Eco.Handles.HandlesStringRes", "sCategorySynchronization")]
[LocalizableDescriptionAttribute("Eco.Handles.HandlesStringRes", "sPropertySyncHandler")]
[DefaultValueAttribute("")]
public AbstractSyncHandler SyncHandler { get; public set; }
    private bool Eco.Persistence.IPersistenceMapper.SupportsSync { get; }
    private SyncVersion Eco.Persistence.IPersistenceMapper.CurrentSyncVersion { get; }
    protected Datablock Cache { get; }
    protected IEcoTypeSystem TypeSystem { get; }
    [LocalizableCategoryAttribute("Eco.Handles.HandlesStringRes", "sCategoryPersistence")]
[LocalizableDescriptionAttribute("Eco.Handles.HandlesStringRes", "sPropertyCacheData")]
[DefaultValueAttribute("True")]
public bool CacheData { get; public set; }
    private static AbstractDataBlockPersistenceMapper();
    public bool get_MultiUser();
    public void set_MultiUser(bool value);
    private bool get_Active();
    private void Activate();
    private void Deactivate();
    public virtual void ReturnPersistenceMapper(IPersistenceMapper persistenceMapper);
    private void InitDbAssignedAttributes();
    public virtual IPersistenceMapper GetPersistenceMapper(ITypeSystemService typeSystemService);
    protected virtual void Activating();
    protected virtual void Deactivating();
    private void InternalFetch(ObjectIdList idList, Datablock datablock, Int32[] memberIdList, FetchStrategy fetchStrategy);
    private sealed virtual override void Eco.Persistence.IPersistenceMapper.Fetch(ObjectIdList idList, Datablock& datablock, Int32[] memberIdList, FetchStrategy fetchStrategy);
    private ObjectIdList GetOclCondition(OclCondition cond, int maxResults, int offset);
    private Datablock GetOclDatablockViewModelQueryplanFetchCondition(AbstractCondition cond, int maxResults, int offset);
    private Datablock GetOclDatablockCondition(OclCondition cond, int maxResults, int offset);
    private static ObjectContents GetAnonymousObjectContents(Datablock result);
    private void ElementToDatablockContent(IElement el, ObjectContents oc);
    private IElement GetOclValue(OclCondition cond, TempEcoSpace es);
    private sealed virtual override void Eco.Persistence.IPersistenceMapper.FetchIDListWithCondition(AbstractCondition condition, ObjectIdList& result, int maxResults, int offset);
    private sealed virtual override void Eco.Persistence.IPersistenceMapper.FetchDatablockWithCondition(AbstractCondition condition, Datablock& result, int maxResults, int offset);
    protected bool CompareValues(object o1, object o2);
    private bool CompareIds(ObjectId id1, ObjectId id2);
    private bool CompareIdLists(ObjectIdList idlist1, ObjectIdList idlist2);
    protected abstract virtual void EnsureCacheCurrent();
    private UpdateResult CheckOptimisticLocking(OptimisticLockingPrecondition precondition);
    private void FetchOldSingleLinkValues(Datablock newValues, Datablock oldValues);
    private sealed virtual override void Eco.Persistence.IPersistenceMapper.Update(Datablock datablock, UpdatePrecondition precondition, IdTranslationList& translationList, Int32& version, SyncVersion& syncVersion, UpdateResult& result);
    protected virtual void Update(Datablock datablock, IdTranslationList& translationList, int version);
    private sealed virtual override void Eco.Persistence.IPersistenceMapper.VersionForTime(DateTime clockTime, Int32& version);
    private sealed virtual override void Eco.Persistence.IPersistenceMapper.TimeForVersion(int version, DateTime& clockTime);
    public AbstractSyncHandler get_SyncHandler();
    public void set_SyncHandler(AbstractSyncHandler value);
    private sealed virtual override bool Eco.Persistence.IPersistenceMapper.get_SupportsSync();
    private sealed virtual override void Eco.Persistence.IPersistenceMapper.GetChangesSince(SyncVersion syncVersion, SyncVersion[] excludeList, DBChangeCollection& changes, SyncVersion& lastSyncVersion);
    private sealed virtual override SyncVersion Eco.Persistence.IPersistenceMapper.get_CurrentSyncVersion();
    protected void ClearCache();
    protected Datablock get_Cache();
    protected void EnsureCache();
    protected virtual Datablock GetCache();
    protected IEcoTypeSystem get_TypeSystem();
    private void ReserveNewIds(Datablock datablock, IdTranslationList TranslationList);
    private void DoFetch(Datablock result, ObjectIdList objectIds, Int32[] memberIds);
    private static void AssertModel(bool ok);
    private ObjectIdList GetAllPointingAt(ObjectId target, IClass otherEndClass, IAssociationEnd ae, int memberIndex);
    private void FetchMember(ObjectContents dest, ObjectContents source, int memberId, IClass umlClass);
    private int GetNewAutoIncValue(object key);
    protected virtual void DoUpdateObject(ObjectId id, Datablock changes);
    private void DoUpdate(Datablock changes, int version);
    protected abstract virtual void WriteDatablock(Datablock datablock);
    public bool get_CacheData();
    public void set_CacheData(bool value);
}
public abstract class Eco.Persistence.AbstractPersistenceMapperFile : AbstractDataBlockPersistenceMapper {
    private string m_FileName;
    protected DateTime m_FileTimestamp;
    private bool _currentdirfetched;
    private string _currentdir;
    private IsolatedStorageFile _isolatedStorage;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
private EventHandler`1<EventArgs> OnFileBasedCacheDetectedInvalidAndReRead;
    private bool _currentlyUnloading;
    [LocalizableCategoryAttribute("Eco.Handles.HandlesStringRes", "sCategoryPersistence")]
[LocalizableDescriptionAttribute("Eco.Handles.HandlesStringRes", "sPropertyFileName")]
[EditorAttribute("Eco.Persistence.Xml.Design.NewXmlFileNameEditor, Eco.Handles.Design, Version=7.1.0.0, Culture=neutral, PublicKeyToken=46a833be9e90de8c", "System.Drawing.Design.UITypeEditor")]
[DefaultValueAttribute("")]
public string FileName { get; public set; }
    protected IsolatedStorageFile IsolatedStorageInstance { get; }
    public string get_FileName();
    public void set_FileName(string value);
    public string FullFileName();
    protected IsolatedStorageFile get_IsolatedStorageInstance();
    protected virtual bool DataFileExists();
    protected virtual void Activating();
    protected virtual void RememberCurrentFileTimestamp();
    protected virtual Datablock GetCache();
    protected abstract virtual Datablock ReadDatablock();
    protected virtual void EnsureCacheCurrent();
    [CompilerGeneratedAttribute]
public void add_OnFileBasedCacheDetectedInvalidAndReRead(EventHandler`1<EventArgs> value);
    [CompilerGeneratedAttribute]
public void remove_OnFileBasedCacheDetectedInvalidAndReRead(EventHandler`1<EventArgs> value);
    public void InvalidateAllInES(DefaultEcoSpace rmes);
    protected virtual DateTime GetCurrentFileTimestamp();
    protected virtual void Update(Datablock datablock, IdTranslationList& translationList, int version);
}
public class Eco.Persistence.DatablockConverter : object {
    private Dictionary`2<string, IModelElement> idToModelElementHash;
    private bool m_Compact;
    private bool m_DebugMode;
    private bool m_StrictParsing;
    private IEcoTypeSystem m_TypeSystem;
    private Dictionary`2<string, string> nameToIdHash;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
private ExportFeatureFilterHandler ExportFeatureFilter;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
private IdToNodeHandler IdToNodeEvent;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
private NodeToIdKeyHandler NodeToIdKeyEvent;
    private static IFormatProvider _numberformat;
    public bool Compact { get; public set; }
    public bool DebugMode { get; public set; }
    public bool StrictParsing { get; public set; }
    public IEcoTypeSystem TypeSystem { get; }
    public DatablockConverter(IEcoTypeSystem typeSystem);
    [CompilerGeneratedAttribute]
public void add_ExportFeatureFilter(ExportFeatureFilterHandler value);
    [CompilerGeneratedAttribute]
public void remove_ExportFeatureFilter(ExportFeatureFilterHandler value);
    [CompilerGeneratedAttribute]
public void add_IdToNodeEvent(IdToNodeHandler value);
    [CompilerGeneratedAttribute]
public void remove_IdToNodeEvent(IdToNodeHandler value);
    [CompilerGeneratedAttribute]
public void add_NodeToIdKeyEvent(NodeToIdKeyHandler value);
    [CompilerGeneratedAttribute]
public void remove_NodeToIdKeyEvent(NodeToIdKeyHandler value);
    public static bool ByteArraysAreEqual(object value, object columnValue);
    public static bool CharArraysAreEqual(object value, object columnValue);
    public bool ContainsEcoData(XDocument doc);
    public Datablock ConvertToDatablock(XDocument doc);
    public Datablock ConvertToDatablock(XDocument doc, bool setInitialValues);
    public void ConvertToDatablock(XDocument doc, bool setInitialValues, Datablock datablock);
    public XDocument ConvertToXml(Datablock datablock, bool includeModel);
    public static object ConvertValueFromString(IAttribute attr, string strValue);
    public static object ConvertValueFromString(Type targetType, string strValue, ISimpleType optionalFallbackSimpleType);
    private static string GetDecimalNumberSafe(string strValue);
    private static IFormatProvider GetNumberFormat();
    private string ConvertValueToReadable(IAttribute attr, object value);
    public static string ConvertValueToString(IAttribute attr, object value);
    public static string ConvertValueToStringReadableDates(ISimpleType simpleType, object value);
    public static string ConvertValueToString(ISimpleType simpleType, object value);
    public static string ConvertValueToString(ISimpleType simpleType, object value, bool readableDates);
    public XElement CreateChild(XContainer parent, XElement elmt);
    public IAssociationEnd GetAssocEndByName(IClass c, string oldClassName, string name);
    public IAttribute GetAttributeByName(IClass c, string oldClassName, string name);
    public IClass GetClassById(string name);
    private IClass GetClassByName(string name);
    private IStructuralFeature GetFeatureById(string oldClassName, string name);
    private IStructuralFeature GetFeatureByName(IClass c, string name);
    private string GetModelId(IModelElement me);
    private void IdToElement(ObjectId id, XElement elmt);
    private ObjectId NodeToId(XElement elmt, IClass cls);
    private void ReadAssocEnd(XElement aeElmt, IAssociationEnd ae, ObjectContents oc, IClass c);
    private void ReadAttribute(XElement attrElmt, IAttribute attr, ObjectContents oc, IClass c);
    private void ReadClass(XElement classElmt);
    private void ReadModel(XElement modelInfoNode);
    private void ReadObject(XElement objectElmt, Datablock res, bool setInitialValues);
    private void ReadPackage(XElement packageNode);
    public void SetAttribute(XElement elmt, string attributeName, string value);
    private void WriteAssocEnd(IClass c, IAssociationEnd ae, int index, ObjectContents oc, XElement parentElmt);
    private void WriteAttribute(IClass c, IAttribute attr, int index, ObjectContents oc, XElement parentNode);
    private void WriteClass(XElement parentNode, IClass c);
    private void WriteModel(XElement parentElmt);
    private void WriteObject(ObjectContents oc, XElement parentNode);
    private void WritePackage(XElement parentNode, IPackage p);
    public bool get_Compact();
    public void set_Compact(bool value);
    public bool get_DebugMode();
    public void set_DebugMode(bool value);
    public bool get_StrictParsing();
    public void set_StrictParsing(bool value);
    public IEcoTypeSystem get_TypeSystem();
}
public class Eco.Persistence.OnLoadAsXMLArgs : EventArgs {
    public string FileName;
    public bool ContinueWithDefault;
    public string LoadedDataAsXml;
}
public class Eco.Persistence.OnSaveAsXMLArgs : EventArgs {
    public string FileName;
    public bool ContinueWithDefault;
    public XDocument XDocumentToSave;
}
[ToolboxBitmapAttribute("Eco.Persistence.PersistenceMapperXml", "Eco.Persistence.PersistenceMapperMemory.bmp")]
[ToolboxItemAttribute("True")]
public class Eco.Persistence.PersistenceMapperMemory : AbstractDataBlockPersistenceMapper {
    protected virtual void EnsureCacheCurrent();
    protected virtual void WriteDatablock(Datablock datablock);
    protected virtual void Deactivating();
}
[ToolboxBitmapAttribute("Eco.Persistence.PersistenceMapperXml", "Eco.Persistence.PersistenceMapperXml.bmp")]
[ToolboxItemAttribute("True")]
[DesignerAttribute("Eco.Persistence.Design.PersistenceMapperDesignerXml, Eco.Handles.Design, Version=7.1.0.0, Culture=neutral, PublicKeyToken=46a833be9e90de8c", "System.ComponentModel.Design.IDesigner")]
[ComponentHelpAttribute("Eco.Persistence.Xml.Design.PersistenceMapperXmlInspector", "Eco.Handles.Design, Version=7.1.0.0, Culture=neutral, PublicKeyToken=46a833be9e90de8c")]
public class Eco.Persistence.PersistenceMapperXml : AbstractPersistenceMapperFile {
    private bool m_StrictParsing;
    private bool m_DebugMode;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
private EventHandler`1<OnSaveAsXMLArgs> OnSaveAsXML;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
private EventHandler`1<OnLoadAsXMLArgs> OnLoadAsXML;
    [DefaultValueAttribute("False")]
public bool StrictParsing { get; public set; }
    [DefaultValueAttribute("True")]
public bool DebugMode { get; public set; }
    public bool get_StrictParsing();
    public void set_StrictParsing(bool value);
    public bool get_DebugMode();
    public void set_DebugMode(bool value);
    protected virtual void WriteDatablock(Datablock datablock);
    [CompilerGeneratedAttribute]
public void add_OnSaveAsXML(EventHandler`1<OnSaveAsXMLArgs> value);
    [CompilerGeneratedAttribute]
public void remove_OnSaveAsXML(EventHandler`1<OnSaveAsXMLArgs> value);
    [CompilerGeneratedAttribute]
public void add_OnLoadAsXML(EventHandler`1<OnLoadAsXMLArgs> value);
    [CompilerGeneratedAttribute]
public void remove_OnLoadAsXML(EventHandler`1<OnLoadAsXMLArgs> value);
    protected virtual void StoreXml(XDocument doc);
    protected virtual XDocument LoadXml();
    protected virtual Datablock ReadDatablock();
}
public class Eco.ReflectionReader.AssociationClassLink : object {
    public string Association;
    public UmlClass Class_;
    public AssociationClassLink(string association, UmlClass class_);
}
public class Eco.ReflectionReader.AssociationLink : object {
    public string Association;
    public AssociationEndNormal AssociationEnd;
    public int Index;
    public AssociationLink(string association, AssociationEndNormal associationEnd, int index);
}
public class Eco.ReflectionReader.ClassData : object {
    private UmlClass m_Class;
    private IList`1<StateMachineTransport> m_StateMachineTransports;
    private bool m_IsOldStyleAssociationClass;
    private bool m_FoundInPackage;
    public bool FoundInPackage { get; public set; }
    public IList`1<StateMachineTransport> StateMachineTransports { get; }
    public UmlClass UmlClass { get; }
    public bool IsOldStyleAssociationClass { get; public set; }
    public ClassData(UmlClass Class_, IList`1<StateMachineTransport> StateMachineTransports);
    public bool get_FoundInPackage();
    public void set_FoundInPackage(bool value);
    public IList`1<StateMachineTransport> get_StateMachineTransports();
    public UmlClass get_UmlClass();
    public bool get_IsOldStyleAssociationClass();
    public void set_IsOldStyleAssociationClass(bool value);
}
public class Eco.ReflectionReader.CustomAttributeCracker : object {
    private UmlElementAttribute m_ElementAttribute;
    private List`1<UmlMetaAttributeAttribute> m_MetaAttributes;
    private List`1<UmlTaggedValueAttribute> m_TaggedValues;
    private bool m_EcoAutoGenerated;
    private bool m_EcoAutoMaintained;
    private List`1<StateMachineTransport> m_StateMachineTransports;
    private MemberInfo memberInfo;
    private bool initialized;
    public UmlElementAttribute UmlElement { get; }
    public IList`1<UmlMetaAttributeAttribute> MetaAttributes { get; }
    public IList`1<UmlTaggedValueAttribute> TaggedValues { get; }
    public bool EcoAutoGenerated { get; }
    public bool EcoAutoMaintained { get; }
    public IList`1<StateMachineTransport> StateMachines { get; }
    public CustomAttributeCracker(MemberInfo m);
    public UmlElementAttribute get_UmlElement();
    public IList`1<UmlMetaAttributeAttribute> get_MetaAttributes();
    public IList`1<UmlTaggedValueAttribute> get_TaggedValues();
    public bool get_EcoAutoGenerated();
    public bool get_EcoAutoMaintained();
    public IList`1<StateMachineTransport> get_StateMachines();
    private void EnsureInitialized();
    private void Initialize();
}
public class Eco.ReflectionReader.NonNavigableAssociationEndData : object {
    public Type Type_;
    public CustomAttributeCracker EndAttributes;
    public UmlAssociation Association;
    public NonNavigableAssociationEndData(Type t, CustomAttributeCracker endAttributes, UmlAssociation association);
}
public class Eco.ReflectionReader.ReflectionReader : object {
    private static string Attribute_association;
    private static string Attribute_multiplicity;
    private static string Attribute_ownedElement;
    private static string Attribute_initialValue;
    private static string Attribute_constraint;
    private static string Attribute_aggregation;
    private static string Attribute_changeability;
    private static string Attribute_ordering;
    private static string Attribute_isQuery;
    private static string Meta_AssociationEnd;
    private static string Meta_Association;
    private static string Meta_Package;
    private static string Meta_AssociationClass;
    private Dictionary`2<Type, ClassData> m_ClassByType;
    private Dictionary`2<Type, UmlAssociation> m_AssociationByType;
    private List`1<Type> m_PackageAssociations;
    private List`1<AssociationLink> m_UnresolvedAssociationEnds;
    private List`1<NonNavigableAssociationEndData> m_UnresolvedNonNaviagableAssociationEnds;
    private List`1<AssociationClassLink> m_UnresolvedAssociationClasses;
    private List`1<Method> m_MethodsToScanForParameters;
    private EcoTypeSystem m_EcoTypeSystem;
    private static Dictionary`2<string, DateTime> m_LastCodeGenTimeStamps;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
private static bool <HistorySlaveServerAutoModelModification>k__BackingField;
    private Dictionary`2<MemberInfo, CustomAttributeCracker> crackerdic;
    public static IDictionary`2<string, DateTime> LastCodeGenTimeStamps { get; }
    public static bool HistorySlaveServerAutoModelModification { get; public set; }
    private static ReflectionReader();
    public UmlAssociation EnsureElement_GetAssociation(Type t, CustomAttributeCracker attributes);
    private void EnsureElement(Package package, Type t, CustomAttributeCracker attributes);
    public static IDictionary`2<string, DateTime> get_LastCodeGenTimeStamps();
    private Package ReadPackage(Type pkg);
    private UmlAssociation GetEnsuredAssociation(Type t, CustomAttributeCracker Attributes);
    public static void ReadAttributeUmlAttributes(CustomAttributeCracker Attributes, UmlAttribute Attr);
    private void ReadClassUmlAttributes(Type c, CustomAttributeCracker Attributes, UmlClass aClass);
    private ClassData ConvertAssociationClass(Type ac, CustomAttributeCracker Attributes);
    [CompilerGeneratedAttribute]
public static void set_HistorySlaveServerAutoModelModification(bool value);
    [CompilerGeneratedAttribute]
public static bool get_HistorySlaveServerAutoModelModification();
    private ClassData ConvertClass(Type c, CustomAttributeCracker Attributes);
    private CustomAttributeCracker GetAttributeCracker(MemberInfo mi);
    private bool CheckHasUserCode(Type t, string memberName, CustomAttributeCracker Attributes);
    private void ConvertProperty(PropertyInfo p, CustomAttributeCracker attributes, UmlClass class_);
    private ClassData GetClassData(Type c, CustomAttributeCracker attributes);
    public static string StripEqual(string s);
    public static void GetTaggedValues(MemberInfo e, CustomAttributeCracker Attributes, UmlRtElement Element);
    public static void ConvertStructuralFeature(PropertyInfo p, CustomAttributeCracker attributes, StructuralFeature member);
    private string UnqualifiedName(string name);
    private void ReadAssociationEndUmlAttributes(MemberInfo m, CustomAttributeCracker attributes, AssociationEndNormal associationEnd);
    public static string GetAsString(object value);
    public static string EnsuredModelName(EcoSpaceAttribute nameAttribute);
    private void DoConvert(Type ecoSpaceType);
    private void DoConvert(IEnumerable`1<Type> packages, string ecospacename);
    private void ReadStateMachineForClassAndSuperClasses(ClassData classdata, UmlClass targetclass);
    private void MergeStateMachines(UmlClass targetclass, IStateMachine savedcurrentstatemachine);
    private void CreateNonnavigableAssociationEnd(Type t, CustomAttributeCracker endAttributes, UmlAssociation association);
    private UmlAssociation ConvertAssociation(Type a, CustomAttributeCracker attributes);
    private void ConvertMethod(MethodInfo mi, CustomAttributeCracker attributes, UmlClass class_);
    public static void ReadMethodUmlAttributes(MethodInfo mi, CustomAttributeCracker Attributes, Method Method);
    private UmlClass GetClass(Type c, CustomAttributeCracker Attributes);
    private IClassifier ResolveType(Type t);
    private void BuildParameters(Method method);
    public EcoTypeSystem Convert(IEnumerable`1<Type> packages, string ecoSpaceName);
    public EcoTypeSystem Convert(Type ecoSpaceType);
}
public class Eco.ReflectionReader.StateMachineReader : object {
    private Dictionary`2<RegionTransport, RegionImpl> m_RegionByRegionTransport;
    private IErrorLogger m_ErrorLogger;
    private RegionImpl BuildRegionAndStates(RegionTransport reg, IRegionContainer container, StateMachineImpl stateMachine);
    private StateImpl BuildRegularState(VertexTransport vtx, RegionImpl reg, StateMachineImpl stateMachine);
    private StateMachineImpl BuildStatemachine(string name, ICollection`1<StateMachineTransport> stateMachineTransports, UmlClass umlClass);
    private TransitionImpl BuildTransition(TransitionTransport trans, RegionImpl region, StateMachineImpl stateMachine, string namePrefix);
    private void HandleGuardDefinitionResolveConstraintGuards(TransitionTransport trans, StateMachineImpl stateMachine, TransitionImpl result);
    private void BuildRegionTransitions(RegionTransport reg, StateMachineImpl stateMachine, string namePrefix);
    public static StateMachineImpl Read(string name, ICollection`1<StateMachineTransport> stateMachineTransports, UmlClass umlClass);
    private FinalStateImpl BuildFinalStateState(VertexTransport vtx, RegionImpl reg);
}
internal enum Eco.Runtime.Zip.AddOrUpdateAction : Enum {
    public int value__;
    public static AddOrUpdateAction AddOnly;
    public static AddOrUpdateAction AddOrUpdate;
}
public class Eco.Runtime.Zip.BadCrcException : ZipException {
    public BadCrcException(string message);
    public BadCrcException(string message, Exception innerException);
    protected BadCrcException(SerializationInfo serializationInfo, StreamingContext streamingContext);
}
public class Eco.Runtime.Zip.BadPasswordException : ZipException {
    public BadPasswordException(string message);
    public BadPasswordException(string message, Exception innerException);
    protected BadPasswordException(SerializationInfo serializationInfo, StreamingContext streamingContext);
}
public class Eco.Runtime.Zip.BadReadException : ZipException {
    public BadReadException(string message);
    public BadReadException(string message, Exception innerException);
    protected BadReadException(SerializationInfo serializationInfo, StreamingContext streamingContext);
}
public class Eco.Runtime.Zip.BadStateException : ZipException {
    public BadStateException(string message);
    public BadStateException(string message, Exception innerException);
    protected BadStateException(SerializationInfo serializationInfo, StreamingContext streamingContext);
}
internal class Eco.Runtime.Zip.CountingStream : Stream {
    private Stream _s;
    private int _bytesWritten;
    private int _bytesRead;
    public int BytesWritten { get; }
    public int BytesRead { get; }
    public bool CanRead { get; }
    public bool CanSeek { get; }
    public bool CanWrite { get; }
    public long Length { get; }
    public long Position { get; public set; }
    public CountingStream(Stream s);
    public int get_BytesWritten();
    public int get_BytesRead();
    public void Adjust(int delta);
    public virtual int Read(Byte[] buffer, int offset, int count);
    public virtual void Write(Byte[] buffer, int offset, int count);
    public virtual bool get_CanRead();
    public virtual bool get_CanSeek();
    public virtual bool get_CanWrite();
    public virtual void Flush();
    public virtual long get_Length();
    public virtual long get_Position();
    public virtual void set_Position(long value);
    public virtual long Seek(long offset, SeekOrigin origin);
    public virtual void SetLength(long value);
}
public class Eco.Runtime.Zip.CRC32 : object {
    private int _TotalBytesRead;
    private static UInt32[] crc32Table;
    private static int BUFFER_SIZE;
    private UInt32 _RunningCrc32Result;
    public int TotalBytesRead { get; }
    public int Crc32Result { get; }
    public int get_TotalBytesRead();
    public int get_Crc32Result();
    public int GetCrc32(Stream input);
    public int GetCrc32AndCopy(Stream input, Stream output);
    public int ComputeCrc32(int W, byte B);
    internal int ComputeCrc32(UInt32 W, byte B);
    public void SlurpBlock(Byte[] block, int offset, int count);
}
public class Eco.Runtime.Zip.CrcCalculatorStream : Stream {
    private Stream _InnerStream;
    private CRC32 _Crc32;
    private int _length;
    public int TotalBytesSlurped { get; }
    public int Crc32 { get; }
    public bool CanRead { get; }
    public bool CanSeek { get; }
    public bool CanWrite { get; }
    public long Length { get; }
    public long Position { get; public set; }
    public CrcCalculatorStream(Stream stream);
    public CrcCalculatorStream(Stream stream, int length);
    public int get_TotalBytesSlurped();
    public int get_Crc32();
    public virtual int Read(Byte[] buffer, int offset, int count);
    public virtual void Write(Byte[] buffer, int offset, int count);
    public virtual bool get_CanRead();
    public virtual bool get_CanSeek();
    public virtual bool get_CanWrite();
    public virtual void Flush();
    public virtual long get_Length();
    public virtual long get_Position();
    public virtual void set_Position(long value);
    public virtual long Seek(long offset, SeekOrigin origin);
    public virtual void SetLength(long value);
}
internal enum Eco.Runtime.Zip.CryptoMode : Enum {
    public int value__;
    public static CryptoMode Encrypt;
    public static CryptoMode Decrypt;
}
public enum Eco.Runtime.Zip.EncryptionAlgorithm : Enum {
    public int value__;
    public static EncryptionAlgorithm None;
    public static EncryptionAlgorithm PkzipWeak;
}
internal enum Eco.Runtime.Zip.EntrySource : Enum {
    public int value__;
    public static EntrySource None;
    public static EntrySource Filesystem;
    public static EntrySource Zipfile;
    public static EntrySource Stream;
}
public class Eco.Runtime.Zip.ExtractEventArgs : EventArgs {
    private string _name;
    private string _target;
    private bool _overwrite;
    public string ArchiveName { get; }
    public string ExtractLocation { get; }
    public bool Overwrite { get; }
    internal ExtractEventArgs(string archiveName, string extractLocation, bool wantOverwrite);
    public string get_ArchiveName();
    public string get_ExtractLocation();
    public bool get_Overwrite();
}
public class Eco.Runtime.Zip.ExtractProgressEventArgs : ZipProgressEventArgs {
    private int _entriesExtracted;
    private bool _overwrite;
    private string _target;
    public int EntriesExtracted { get; }
    public bool Overwrite { get; }
    public string ExtractLocation { get; }
    internal ExtractProgressEventArgs(int entriesTotal, int entriesExtracted, string lastEntry, string extractLocation, bool wantOverwrite);
    public int get_EntriesExtracted();
    public bool get_Overwrite();
    public string get_ExtractLocation();
}
public class Eco.Runtime.Zip.ReReadApprovalCallback : MulticastDelegate {
    public ReReadApprovalCallback(object object, IntPtr method);
    public virtual bool Invoke(int uncompressedSize, int compressedSize, string filename);
    public virtual IAsyncResult BeginInvoke(int uncompressedSize, int compressedSize, string filename, AsyncCallback callback, object object);
    public virtual bool EndInvoke(IAsyncResult result);
}
public class Eco.Runtime.Zip.SaveEventArgs : EventArgs {
    private string _name;
    public string ArchiveName { get; }
    internal SaveEventArgs(string archiveName);
    public string get_ArchiveName();
}
public class Eco.Runtime.Zip.SaveProgressEventArgs : ZipProgressEventArgs {
    private int _entriesSaved;
    public int EntriesSaved { get; }
    internal SaveProgressEventArgs(int entriesTotal, int entriesSaved, string lastEntry);
    public int get_EntriesSaved();
}
public class Eco.Runtime.Zip.SfxGenerationException : ZipException {
    public SfxGenerationException(string message);
    public SfxGenerationException(string message, Exception innerException);
    protected SfxGenerationException(SerializationInfo serializationInfo, StreamingContext streamingContext);
}
internal class Eco.Runtime.Zip.SharedUtilities : object {
    private static Encoding ibm437;
    private static Encoding utf8;
    private static SharedUtilities();
    public static DateTime RoundToEvenSecond(DateTime source);
    public static string TrimVolumeAndSwapSlashes(string pathName);
    internal static Byte[] StringToByteArray(string value, Encoding encoding);
    internal static Byte[] StringToByteArray(string value);
    internal static Byte[] Utf8StringToByteArray(string value);
    internal static string StringFromBuffer(Byte[] buf, int maxlength);
    internal static string Utf8StringFromBuffer(Byte[] buf, int maxlength);
    internal static string StringFromBuffer(Byte[] buf, int maxlength, Encoding encoding);
    internal static int ReadSignature(Stream s);
    internal static int ReadInt(Stream s);
    private static int _ReadFourBytes(Stream s, string message);
    protected internal static long FindSignature(Stream stream, int SignatureToFind);
    internal static DateTime PackedToDateTime(int packedDateTime);
    internal static int DateTimeToPacked(DateTime time);
    public static MemoryStream StringToMemoryStream(string s);
    internal static bool HighBytes(Byte[] buffer);
}
public class Eco.Runtime.Zip.WantCompressionCallback : MulticastDelegate {
    public WantCompressionCallback(object object, IntPtr method);
    public virtual bool Invoke(string localFilename, string filenameInArchive);
    public virtual IAsyncResult BeginInvoke(string localFilename, string filenameInArchive, AsyncCallback callback, object object);
    public virtual bool EndInvoke(IAsyncResult result);
}
internal class Eco.Runtime.Zip.ZipCipherStream : Stream {
    private ZipCrypto _cipher;
    private Stream _s;
    private CryptoMode _mode;
    public bool CanRead { get; }
    public bool CanSeek { get; }
    public bool CanWrite { get; }
    public long Length { get; }
    public long Position { get; public set; }
    public ZipCipherStream(Stream s, ZipCrypto cipher, CryptoMode mode);
    public virtual int Read(Byte[] buffer, int offset, int count);
    public virtual void Write(Byte[] buffer, int offset, int count);
    public virtual bool get_CanRead();
    public virtual bool get_CanSeek();
    public virtual bool get_CanWrite();
    public virtual void Flush();
    public virtual long get_Length();
    public virtual long get_Position();
    public virtual void set_Position(long value);
    public virtual long Seek(long offset, SeekOrigin origin);
    public virtual void SetLength(long value);
}
internal static class Eco.Runtime.Zip.ZipConstants : object {
    public static UInt32 EndOfCentralDirectorySignature;
    public static int ZipEntrySignature;
    public static int ZipEntryDataDescriptorSignature;
    public static int ZipDirEntrySignature;
    public static int AesKeySize;
    public static int AesBlockSize;
    public static ushort AesAlgId128;
    public static ushort AesAlgId192;
    public static ushort AesAlgId256;
}
public class Eco.Runtime.Zip.ZipCrypto : object {
    private UInt32[] _Keys;
    private CRC32 crc32;
    private byte MagicByte { get; }
    private byte get_MagicByte();
    public Byte[] DecryptMessage(Byte[] cipherText, int length);
    public Byte[] EncryptMessage(Byte[] plaintext, int length);
    public void InitCipher(string passphrase);
    private void UpdateKeys(byte byeValue);
}
internal class Eco.Runtime.Zip.ZipDirEntry : object {
    private string _FileName;
    private string _Comment;
    private short _InternalFileAttrs;
    private int _ExternalFileAttrs;
    private Byte[] _Extra;
    public string FileName { get; }
    public string Comment { get; }
    public bool IsDirectory { get; }
    public string get_FileName();
    public string get_Comment();
    public bool get_IsDirectory();
    public static ZipDirEntry Read(Stream s, Encoding expectedEncoding);
    internal static bool IsNotValidSig(int signature);
}
public class Eco.Runtime.Zip.ZipEntry : object {
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
private ReReadApprovalCallback <WillReadTwiceOnInflation>k__BackingField;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
private WantCompressionCallback <WantCompression>k__BackingField;
    private DateTime _LastModified;
    private bool _TrimVolumeFromFullyQualifiedPaths;
    private bool _ForceNoCompression;
    private string _LocalFileName;
    private string _FileNameInArchive;
    private short _VersionNeeded;
    private short _BitField;
    private short _CompressionMethod;
    private string _Comment;
    private bool _IsDirectory;
    private Byte[] _CommentBytes;
    private int _CompressedSize;
    private int _CompressedFileDataSize;
    private int _UncompressedSize;
    private int _TimeBlob;
    private bool _crcCalculated;
    private int _Crc32;
    private Byte[] _Extra;
    private bool _OverwriteOnExtract;
    private Encoding _encoding;
    internal ZipFile _zipfile;
    private long __FileDataPosition;
    private Byte[] _EntryHeader;
    private int _RelativeOffsetOfHeader;
    private int _LengthOfHeader;
    private int _TotalEntrySize;
    private string _Password;
    internal EntrySource _Source;
    private EncryptionAlgorithm _Encryption;
    private Byte[] _WeakEncryptionHeader;
    private Stream _archiveStream;
    private Stream _sourceStream;
    private static int READBLOCK_SIZE;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
private string <ErrorMessage>k__BackingField;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
private bool <DoNotThrowOnCRCError>k__BackingField;
    public DateTime LastModified { get; public set; }
    public bool TrimVolumeFromFullyQualifiedPaths { get; public set; }
    public bool ForceNoCompression { get; public set; }
    public string LocalFileName { get; }
    public string FileName { get; }
    public short VersionNeeded { get; }
    public string Comment { get; public set; }
    public short BitField { get; }
    public short CompressionMethod { get; public set; }
    public int CompressedSize { get; }
    public int UncompressedSize { get; }
    public double CompressionRatio { get; }
    public int Crc32 { get; }
    public bool IsDirectory { get; }
    public bool UsesEncryption { get; }
    public EncryptionAlgorithm Encryption { get; public set; }
    unknown string Password {public set; }
    public bool OverwriteOnExtract { get; public set; }
    public ReReadApprovalCallback WillReadTwiceOnInflation { get; public set; }
    public WantCompressionCallback WantCompression { get; public set; }
    public bool UseUtf8Encoding { get; public set; }
    public Encoding Encoding { get; public set; }
    private Stream ArchiveStream { get; }
    public string ErrorMessage { get; public set; }
    public bool DoNotThrowOnCRCError { get; public set; }
    public DateTime get_LastModified();
    public void set_LastModified(DateTime value);
    public bool get_TrimVolumeFromFullyQualifiedPaths();
    public void set_TrimVolumeFromFullyQualifiedPaths(bool value);
    public bool get_ForceNoCompression();
    public void set_ForceNoCompression(bool value);
    public string get_LocalFileName();
    public string get_FileName();
    public short get_VersionNeeded();
    public string get_Comment();
    public void set_Comment(string value);
    public short get_BitField();
    public short get_CompressionMethod();
    public void set_CompressionMethod(short value);
    public int get_CompressedSize();
    public int get_UncompressedSize();
    public double get_CompressionRatio();
    public int get_Crc32();
    public bool get_IsDirectory();
    public bool get_UsesEncryption();
    public EncryptionAlgorithm get_Encryption();
    public void set_Encryption(EncryptionAlgorithm value);
    public void set_Password(string value);
    public bool get_OverwriteOnExtract();
    public void set_OverwriteOnExtract(bool value);
    [CompilerGeneratedAttribute]
public ReReadApprovalCallback get_WillReadTwiceOnInflation();
    [CompilerGeneratedAttribute]
public void set_WillReadTwiceOnInflation(ReReadApprovalCallback value);
    [CompilerGeneratedAttribute]
public WantCompressionCallback get_WantCompression();
    [CompilerGeneratedAttribute]
public void set_WantCompression(WantCompressionCallback value);
    public bool get_UseUtf8Encoding();
    public void set_UseUtf8Encoding(bool value);
    public Encoding get_Encoding();
    public void set_Encoding(Encoding value);
    private static bool ReadHeader(ZipEntry ze, Encoding defaultEncoding);
    private static bool IsNotValidSig(int signature);
    internal static ZipEntry Read(Stream s, Encoding defaultEncoding);
    private static void HandleUnexpectedDataDescriptor(ZipEntry entry);
    internal static string NameInArchive(string filename, string directoryPathInArchive);
    internal static ZipEntry Create(string filename, string nameInArchive);
    internal static ZipEntry Create(string filename, string nameInArchive, Stream stream);
    public void Extract();
    public void Extract(bool overwrite);
    public void Extract(Stream stream);
    public void Extract(string baseDirectory);
    public void Extract(string baseDirectory, bool overwrite);
    public void ExtractWithPassword(string password);
    public void ExtractWithPassword(string baseDirectory, string password);
    public void ExtractWithPassword(bool overwrite, string password);
    public void ExtractWithPassword(string baseDirectory, bool overwrite, string password);
    public void ExtractWithPassword(Stream stream, string password);
    public CrcCalculatorStream OpenReader();
    public CrcCalculatorStream OpenReader(string password);
    private Stream get_ArchiveStream();
    private CrcCalculatorStream InternalOpenReader(string password);
    private void InternalExtract(string baseDir, Stream outstream, string password);
    private ZipCrypto SetupCipher(string password);
    private void ValidateEncryption();
    private void ValidateCompression();
    private bool ValidateOutput(string basedir, Stream outstream, String& OutputFile);
    private void _CheckRead(int nbytes);
    private int _ExtractOne(Stream output, ZipCrypto cipher);
    internal void MarkAsDirectory();
    internal void WriteCentralDirectoryEntry(Stream s);
    private Byte[] GetExtraField();
    private Byte[] GetFileNameBytes();
    private bool WantReadAgain();
    private bool SeemsCompressible(string filename);
    private bool DefaultWantCompression();
    private void FigureCompressionMethodForWriting(int cycle);
    private void WriteHeader(Stream s, int cycle);
    private int FigureCrc32();
    internal void CopyMetaData(ZipEntry source);
    private void _WriteFileData(ZipCrypto cipher, Stream s);
    internal void Write(Stream outstream);
    private void _EmitOne(Stream outstream, ZipCrypto& cipher);
    private void CopyThroughOneEntry(Stream outstream);
    internal static bool IsStrong(EncryptionAlgorithm e);
    [CompilerGeneratedAttribute]
public string get_ErrorMessage();
    [CompilerGeneratedAttribute]
public void set_ErrorMessage(string value);
    [CompilerGeneratedAttribute]
public bool get_DoNotThrowOnCRCError();
    [CompilerGeneratedAttribute]
public void set_DoNotThrowOnCRCError(bool value);
}
public class Eco.Runtime.Zip.ZipException : Exception {
    public ZipException(string message);
    public ZipException(string message, Exception innerException);
    protected ZipException(SerializationInfo serializationInfo, StreamingContext streamingContext);
}
[DefaultMemberAttribute("Item")]
public class Eco.Runtime.Zip.ZipFile : object {
    public static Encoding DefaultEncoding;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
private ReReadApprovalCallback <WillReadTwiceOnInflation>k__BackingField;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
private EventHandler`1<SaveEventArgs> SaveStarted;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
private EventHandler`1<SaveProgressEventArgs> SaveProgress;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
private EventHandler`1<SaveEventArgs> SaveCompleted;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
private EventHandler`1<ExtractEventArgs> ExtractStarted;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
private EventHandler`1<ExtractProgressEventArgs> ExtractProgress;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
private EventHandler`1<ExtractEventArgs> ExtractCompleted;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
private bool <DoNotThrowOnCRCError>k__BackingField;
    private TextWriter _StatusMessageTextWriter;
    private bool _CaseSensitiveRetrieval;
    private Stream _readstream;
    private Stream _writestream;
    private bool _disposed;
    private List`1<ZipEntry> _entries;
    private List`1<ZipDirEntry> _direntries;
    private bool _TrimVolumeFromFullyQualifiedPaths;
    private bool _ForceNoCompression;
    private string _name;
    private string _Comment;
    private string _Password;
    private bool _fileAlreadyExists;
    private string _temporaryFileName;
    private bool _contentsChanged;
    private string _TempFileFolder;
    private bool _ReadStreamIsOurs;
    private object LOCK;
    private bool _saveOperationCanceled;
    private bool _extractOperationCanceled;
    private bool _JustSaved;
    private Encoding _encoding;
    public string Name { get; }
    public string Comment { get; public set; }
    public bool TrimVolumeFromFullyQualifiedPaths { get; public set; }
    private bool Verbose { get; }
    public bool CaseSensitiveRetrieval { get; public set; }
    public bool UseUnicode { get; public set; }
    public Encoding Encoding { get; public set; }
    public TextWriter StatusMessageTextWriter { get; public set; }
    public bool ForceNoCompression { get; public set; }
    public string TempFileFolder { get; public set; }
    unknown string Password {public set; }
    public ReReadApprovalCallback WillReadTwiceOnInflation { get; public set; }
    internal Stream ReadStream { get; }
    public static Version LibraryVersion { get; }
    public ZipEntry Item { get; public set; }
    public ZipEntry Item { get; public set; }
    public ReadOnlyCollection`1<string> EntryFileNames { get; }
    private Stream WriteStream { get; private set; }
    public bool DoNotThrowOnCRCError { get; public set; }
    public ZipFile(string zipFileName);
    public ZipFile(string zipFileName, TextWriter statusMessageWriter);
    public ZipFile(Stream outputStream);
    public ZipFile(Stream outputStream, TextWriter statusMessageWriter);
    private static ZipFile();
    public string get_Name();
    public string get_Comment();
    public void set_Comment(string value);
    public bool get_TrimVolumeFromFullyQualifiedPaths();
    public void set_TrimVolumeFromFullyQualifiedPaths(bool value);
    private bool get_Verbose();
    public bool get_CaseSensitiveRetrieval();
    public void set_CaseSensitiveRetrieval(bool value);
    public bool get_UseUnicode();
    public void set_UseUnicode(bool value);
    public Encoding get_Encoding();
    public void set_Encoding(Encoding value);
    public TextWriter get_StatusMessageTextWriter();
    public void set_StatusMessageTextWriter(TextWriter value);
    public bool get_ForceNoCompression();
    public void set_ForceNoCompression(bool value);
    public string get_TempFileFolder();
    public void set_TempFileFolder(string value);
    public void set_Password(string value);
    [CompilerGeneratedAttribute]
public ReReadApprovalCallback get_WillReadTwiceOnInflation();
    [CompilerGeneratedAttribute]
public void set_WillReadTwiceOnInflation(ReReadApprovalCallback value);
    internal Stream get_ReadStream();
    internal void Reset();
    public static Version get_LibraryVersion();
    private void InitFile(string zipFileName, TextWriter statusMessageWriter);
    public void AddItem(string fileOrDirectoryName);
    public void AddItem(string fileOrDirectoryName, string directoryPathInArchive);
    public ZipEntry AddFile(string fileName);
    public ZipEntry AddFile(string fileName, string directoryPathInArchive);
    public ZipEntry UpdateFile(string fileName);
    public ZipEntry UpdateFile(string fileName, string directoryPathInArchive);
    public void UpdateDirectory(string directoryName);
    public void UpdateDirectory(string directoryName, string directoryPathInArchive);
    public void UpdateItem(string itemName);
    public void UpdateItem(string itemName, string directoryPathInArchive);
    public ZipEntry AddFileStream(string fileName, string directoryPathInArchive, Stream stream);
    public ZipEntry AddFileFromString(string fileName, string directoryPathInArchive, string content);
    public ZipEntry UpdateFileStream(string fileName, string directoryPathInArchive, Stream stream);
    private void InsureUniqueEntry(ZipEntry ze1);
    public void AddDirectory(string directoryName);
    public void AddDirectory(string directoryName, string directoryPathInArchive);
    public ZipEntry AddDirectoryByName(string directoryNameInArchive);
    private void AddOrUpdateDirectoryImpl(string directoryName, string rootDirectoryPathInArchive, AddOrUpdateAction action);
    private void AddOrUpdateDirectoryImpl(string directoryName, string rootDirectoryPathInArchive, AddOrUpdateAction action, int level);
    public void Save();
    private void RemoveTempFile();
    private void CleanupAfterSaveOperation();
    public void Save(string zipFileName);
    private void WriteCentralDirectoryStructure(Stream s);
    private void WriteCentralDirectoryFooter(Stream s, long StartOfCentralDirectory, long EndOfCentralDirectory);
    [CompilerGeneratedAttribute]
public void add_SaveStarted(EventHandler`1<SaveEventArgs> value);
    [CompilerGeneratedAttribute]
public void remove_SaveStarted(EventHandler`1<SaveEventArgs> value);
    [CompilerGeneratedAttribute]
public void add_SaveProgress(EventHandler`1<SaveProgressEventArgs> value);
    [CompilerGeneratedAttribute]
public void remove_SaveProgress(EventHandler`1<SaveProgressEventArgs> value);
    [CompilerGeneratedAttribute]
public void add_SaveCompleted(EventHandler`1<SaveEventArgs> value);
    [CompilerGeneratedAttribute]
public void remove_SaveCompleted(EventHandler`1<SaveEventArgs> value);
    private void OnSaveProgress(int current, string currentEntryName);
    private void OnSaveCompleted();
    private void OnSaveStarted();
    [CompilerGeneratedAttribute]
public void add_ExtractStarted(EventHandler`1<ExtractEventArgs> value);
    [CompilerGeneratedAttribute]
public void remove_ExtractStarted(EventHandler`1<ExtractEventArgs> value);
    [CompilerGeneratedAttribute]
public void add_ExtractProgress(EventHandler`1<ExtractProgressEventArgs> value);
    [CompilerGeneratedAttribute]
public void remove_ExtractProgress(EventHandler`1<ExtractProgressEventArgs> value);
    [CompilerGeneratedAttribute]
public void add_ExtractCompleted(EventHandler`1<ExtractEventArgs> value);
    [CompilerGeneratedAttribute]
public void remove_ExtractCompleted(EventHandler`1<ExtractEventArgs> value);
    private void OnExtractProgress(int current, string currentEntryName, string path, bool overwrite);
    private void OnExtractCompleted(string path, bool wantOverwrite);
    private void OnExtractStarted(string path, bool wantOverwrite);
    public static bool IsZipFile(string fileName);
    public static ZipFile Read(string zipFileName);
    public static ZipFile Read(string zipFileName, TextWriter statusMessageWriter);
    public static ZipFile Read(string zipFileName, Encoding encoding);
    public static ZipFile Read(string zipFileName, TextWriter statusMessageWriter, Encoding encoding);
    public static ZipFile Read(Stream zipStream);
    public static ZipFile Read(Stream zipStream, TextWriter statusMessageWriter);
    public static ZipFile Read(Stream zipStream, Encoding encoding);
    public static ZipFile Read(Stream zipStream, TextWriter statusMessageWriter, Encoding encoding);
    public static ZipFile Read(Byte[] buffer);
    public static ZipFile Read(Byte[] buffer, TextWriter statusMessageWriter);
    public static ZipFile Read(Byte[] buffer, TextWriter statusMessageWriter, Encoding encoding);
    private static void ReadIntoInstance(ZipFile zf);
    private static void ReadCentralDirectoryFooter(ZipFile zf);
    private static void ReadZipFileComment(ZipFile zf);
    [IteratorStateMachineAttribute("Eco.Runtime.Zip.ZipFile/<GetEnumerator>d__110")]
public sealed virtual IEnumerator`1<ZipEntry> GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    public void ExtractAll(string path);
    public void ExtractAll(string path, bool wantOverwrite);
    public void Extract(string fileName);
    public void Extract(string fileName, string directoryName);
    public void Extract(string fileName, bool wantOverwrite);
    public void Extract(string fileName, string directoryName, bool wantOverwrite);
    public void Extract(string fileName, Stream outputStream);
    public ZipEntry get_Item(int ix);
    public void set_Item(int ix, ZipEntry value);
    public ZipEntry get_Item(string fileName);
    public void set_Item(string fileName, ZipEntry value);
    public ReadOnlyCollection`1<string> get_EntryFileNames();
    public void RemoveEntry(ZipEntry entry);
    public void RemoveEntry(string fileName);
    protected virtual override void Finalize();
    public sealed virtual void Dispose();
    protected virtual void Dispose(bool disposeManagedResources);
    private Stream get_WriteStream();
    private void set_WriteStream(Stream value);
    [CompilerGeneratedAttribute]
public bool get_DoNotThrowOnCRCError();
    [CompilerGeneratedAttribute]
public void set_DoNotThrowOnCRCError(bool value);
}
public class Eco.Runtime.Zip.ZipProgressEventArgs : EventArgs {
    private int _entriesTotal;
    private bool _cancel;
    private string _nameOfLatestEntry;
    public int EntriesTotal { get; }
    public string NameOfLatestEntry { get; }
    public bool Cancel { get; public set; }
    internal ZipProgressEventArgs(int entriesTotal, string lastEntry);
    public int get_EntriesTotal();
    public string get_NameOfLatestEntry();
    public bool get_Cancel();
    public void set_Cancel(bool value);
}
public class Eco.Services.ChainedUndoServiceBase : object {
    private IUndoService m_NextUndoService;
    public IUndoService NextUndoService { get; }
    public IUndoBlockList UndoList { get; }
    public IUndoBlockList RedoList { get; }
    public bool IsInTransaction { get; }
    public int TransactionNesting { get; }
    public ChainedUndoServiceBase(IUndoService nextUndoService);
    public IUndoService get_NextUndoService();
    public virtual string GetUniqueBlockName(string suggestedName);
    public virtual bool CanUndoBlock(string blockName);
    public virtual bool CanRedoBlock(string blockName);
    public virtual void UndoLatest();
    public virtual void RedoLatest();
    public virtual void UndoBlock(string blockName);
    public virtual void RedoBlock(string blockName);
    public virtual void StartUndoBlock(string blockName);
    public virtual void StartUndoBlock();
    public virtual void ClearAllUndoBlocks();
    public virtual IUndoBlockList get_UndoList();
    public virtual IUndoBlockList get_RedoList();
    public virtual void StartTransaction();
    public virtual void CommitTransaction();
    public virtual void RollbackTransaction();
    public virtual bool get_IsInTransaction();
    public virtual int get_TransactionNesting();
}
public static class Eco.Services.EcoOfflineObjectHelper : object {
    public static void ApplyValues(IEcoObject ecooffline, IEcoObject ecoonline);
    public static void ApplyValues(IEcoObject ecooffline, IEcoObject ecoonline, Func`2<IEcoObject, IEcoObject> offlineToOnlineResolver);
    private static void ApplyValues(IEcoObject ecooffline, IEcoObject ecoonline, Func`2<IEcoObject, IEcoObject> offlineToOnlineResolver, Dictionary`2<IEcoObject, IEcoObject> doneAlready);
}
public class Eco.Services.Impl.AsyncSupportServiceImpl : EcoSpacePart {
    private List`1<Action> _asyncTasksTodo;
    private Dictionary`2<Action, string> _asyncTasksOriginTraceDictionary;
    private List`1<Exception> _asyncExceptions;
    private Thread _threadForAsyncOperations;
    private Action _currentTask;
    private bool _killed;
    private bool _safekill;
    private AutoResetEvent _todoEvents;
    private AutoResetEvent _workQueueDone;
    private Dispatcher _dispatcherForMainThread;
    private bool _asyncHandlingON;
    private int _queueCounter;
    private bool _ExecuteTaskDispatchedToMainThreadImmediately;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
private IEcoServiceProvider <ServiceProvider>k__BackingField;
    private bool _explicitTurnOffDebug;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
private EventHandler AsyncExceptionsEvent;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
private EventHandler AsyncQueueHasFormedEvent;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
private EventHandler AsyncQueueDissolvedEvent;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
private EventHandler AsyncQueueTickEvent;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
private bool <AllowFetchingFromMainThreadTemporarilyToAllowPSEvalFromOCL>k__BackingField;
    private DateTime _latestTimeWeSentStart;
    private int _queuePendingStarts;
    private bool _AsyncPriorityAboveNormal;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
private bool <UseDispatchEvenIfAsyncHandlingIsOff>k__BackingField;
    public DateTime LastLoop;
    private int _simulatedLatencyForDebug;
    private int _inthread;
    private object _InsideCriticalEvalMonitor;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
private string <InsideCriticalEvalMonitorExpression>k__BackingField;
    public IEcoServiceProvider ServiceProvider { get; public set; }
    public bool AsyncHandlingEnabled { get; }
    public bool AllowFetchingFromMainThreadTemporarilyToAllowPSEvalFromOCL { get; public set; }
    public List`1<Exception> AsyncExceptions { get; }
    public List`1<Action> AsyncTasksTodo { get; }
    public Action CurrentAsyncTask { get; }
    public Thread ThreadForAsyncOperations { get; }
    public bool CurrentContextIsAsync { get; }
    public bool CurrentContextIsTrulyAsync { get; }
    public bool AsyncPriorityAboveNormal { get; public set; }
    public bool UseDispatchEvenIfAsyncHandlingIsOff { get; public set; }
    public object InsideCriticalEvalMonitor { get; }
    public string InsideCriticalEvalMonitorExpression { get; internal set; }
    private Dispatcher EnsureDispatcher();
    public sealed virtual void ExecuteTaskDispatchedToMainThreadImmediately(bool yes);
    public sealed virtual DateTime GetTimeForLastAsyncThreadLoop();
    [CompilerGeneratedAttribute]
public sealed virtual IEcoServiceProvider get_ServiceProvider();
    [CompilerGeneratedAttribute]
public void set_ServiceProvider(IEcoServiceProvider value);
    private void EnsureThreadStarted();
    protected virtual void DoActivate();
    private void SetupThread();
    protected virtual void DoDeactivate();
    protected virtual void DoPreDeactivate();
    public sealed virtual void TurnOffAsyncHandling();
    public sealed virtual void TurnOnAsyncHandling();
    public sealed virtual bool get_AsyncHandlingEnabled();
    [CompilerGeneratedAttribute]
public sealed virtual void add_AsyncExceptionsEvent(EventHandler value);
    [CompilerGeneratedAttribute]
public sealed virtual void remove_AsyncExceptionsEvent(EventHandler value);
    [CompilerGeneratedAttribute]
public sealed virtual void add_AsyncQueueHasFormedEvent(EventHandler value);
    [CompilerGeneratedAttribute]
public sealed virtual void remove_AsyncQueueHasFormedEvent(EventHandler value);
    [CompilerGeneratedAttribute]
public sealed virtual void add_AsyncQueueDissolvedEvent(EventHandler value);
    [CompilerGeneratedAttribute]
public sealed virtual void remove_AsyncQueueDissolvedEvent(EventHandler value);
    [CompilerGeneratedAttribute]
public sealed virtual void add_AsyncQueueTickEvent(EventHandler value);
    [CompilerGeneratedAttribute]
public sealed virtual void remove_AsyncQueueTickEvent(EventHandler value);
    public sealed virtual bool WaitForWorkDoneWithTimeout(int ms);
    [CompilerGeneratedAttribute]
public sealed virtual bool get_AllowFetchingFromMainThreadTemporarilyToAllowPSEvalFromOCL();
    [CompilerGeneratedAttribute]
public sealed virtual void set_AllowFetchingFromMainThreadTemporarilyToAllowPSEvalFromOCL(bool value);
    private void NotifyAbout_AsyncExceptions();
    private void NotifyAbout_QueueFormed();
    private void NotifyAbout_QueueDissolved();
    private void NotifyAboutTick();
    public sealed virtual void PerformTaskAsyncWaitUntilFinished(Action task);
    public sealed virtual void PerformTaskAsync(Action task);
    public sealed virtual void PerformTaskNowIfInAsyncThread(Action task);
    public sealed virtual bool WrapTaskInStandardExceptionHandling(Action task);
    public sealed virtual List`1<Exception> get_AsyncExceptions();
    public sealed virtual void DispatchTaskToMainThread(Action task);
    public sealed virtual void DispatchTaskToMainThread(Action task, bool asyncexecution);
    public void DispatchTaskToMainThread(Action task, bool asyncexecution, DispatcherPriority prio);
    public sealed virtual List`1<Action> get_AsyncTasksTodo();
    public sealed virtual Action get_CurrentAsyncTask();
    public sealed virtual Thread get_ThreadForAsyncOperations();
    public sealed virtual bool get_CurrentContextIsAsync();
    public sealed virtual bool get_CurrentContextIsTrulyAsync();
    public sealed virtual bool get_AsyncPriorityAboveNormal();
    public sealed virtual void set_AsyncPriorityAboveNormal(bool value);
    [CompilerGeneratedAttribute]
public bool get_UseDispatchEvenIfAsyncHandlingIsOff();
    [CompilerGeneratedAttribute]
public void set_UseDispatchEvenIfAsyncHandlingIsOff(bool value);
    private void MainLoop2(object o);
    private void AsyncThreadMainLoop();
    public virtual void CleanForFree();
    public sealed virtual bool RemoveTasksForObject(object objectToRemove);
    public sealed virtual object get_InsideCriticalEvalMonitor();
    [CompilerGeneratedAttribute]
public string get_InsideCriticalEvalMonitorExpression();
    [CompilerGeneratedAttribute]
internal void set_InsideCriticalEvalMonitorExpression(string value);
    public sealed virtual void MainThreadInExpressionEnter();
    public sealed virtual void MainThreadInExpressionExit();
    [CompilerGeneratedAttribute]
private void <NotifyAbout_AsyncExceptions>b__48_0();
    [CompilerGeneratedAttribute]
private void <NotifyAbout_QueueFormed>b__51_0();
    [CompilerGeneratedAttribute]
private void <NotifyAboutTick>b__53_0();
}
internal class Eco.Services.Impl.AutoSubscriptionContextImpl : object {
    private AutoSubscriptionServiceImpl m_AutoSubscriptionService;
    private ISubscriber m_Subscriber;
    private string m_AutoSubscriberTagname;
    public string AutoSubscriberTagname { get; }
    public ISubscriber Subscriber { get; }
    public AutoSubscriptionContextImpl(AutoSubscriptionServiceImpl autoSubscriptionService, ISubscriber subscriber, string autoSubscriberTagname);
    public string get_AutoSubscriberTagname();
    public sealed virtual ISubscriber get_Subscriber();
    public sealed virtual void Dispose();
    public void CleanForFree();
}
public class Eco.Services.Impl.AutoSubscriptionServiceImpl : EcoSpacePart {
    private ThreadLocal`1<Stack`1<AutoSubscriptionContextImpl>> _oldContexts;
    private ThreadLocal`1<AutoSubscriptionContextImpl> _activeContext;
    private int _sanitycount;
    private bool _isCleanedAndFreed;
    private IAutoSubscriptionContext Eco.Services.IAutoSubscriptionService.ActiveContext { get; }
    private ISubscriber Eco.Services.IAutoSubscriptionService.ActiveSubscriber { get; }
    private sealed virtual override IAutoSubscriptionContext Eco.Services.IAutoSubscriptionService.StartSubscribe(ISubscriber subscriber, string autoSubscriberTagname);
    private sealed virtual override IAutoSubscriptionContext Eco.Services.IAutoSubscriptionService.get_ActiveContext();
    private sealed virtual override ISubscriber Eco.Services.IAutoSubscriptionService.get_ActiveSubscriber();
    internal void EndSubscribe(AutoSubscriptionContextImpl context);
    public virtual void CleanForFree();
    public sealed virtual void PruneResources(bool LowMemoryCondition);
    public sealed virtual EcoRuntimeInformation GetRuntimeInformation(IExecutionAndDebug owner, DebugSettingsStack settings, int depth);
}
public class Eco.Services.Impl.BusinessDeleteServiceImpl : EcoSpacePart {
    private static HashSet`1<IAssociationEnd> _askedAlreadyDeleteWarning;
    private int _NumberOfTimesWeWarned;
    private bool _SkipFurtherWarnings;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
private EventHandler`1<BusinessDeleteServiceEventArgs> OnInformTheUser;
    public sealed virtual void CheckDeleteConstraints(IObject io, Boolean& goAheadAndDelete, String& reasontext, IConstraint& brokenconstraint, bool deleteIsInProgress);
    public sealed virtual void CheckOneAssociationEnd(IAssociationEnd associationEnd, IProperty member, Boolean& goAheadAndDelete, String& reasontext, bool deleteIsInProgress);
    [CompilerGeneratedAttribute]
public sealed virtual void add_OnInformTheUser(EventHandler`1<BusinessDeleteServiceEventArgs> value);
    [CompilerGeneratedAttribute]
public sealed virtual void remove_OnInformTheUser(EventHandler`1<BusinessDeleteServiceEventArgs> value);
    public virtual void CleanForFree();
}
public class Eco.Services.Impl.CacheContentServiceImpl : EcoSpacePartWithTypeSystem {
    private IObjectRepresentationProvider m_ObjRepProv;
    private IFetchHandler m_FetchHandler;
    private ICache m_Cache;
    public IObjectRepresentationProvider ObjectRepresentationProvider { get; public set; }
    public IFetchHandler FetchHandler { get; public set; }
    public ICache Cache { get; public set; }
    public CacheContentServiceImpl(IEcoTypeSystem typeSystem);
    public IObjectRepresentationProvider get_ObjectRepresentationProvider();
    public void set_ObjectRepresentationProvider(IObjectRepresentationProvider value);
    public IFetchHandler get_FetchHandler();
    public void set_FetchHandler(IFetchHandler value);
    public sealed virtual ICache get_Cache();
    public void set_Cache(ICache value);
    public sealed virtual IObjectRepresentationProvider GetObjectRepresentationProvider();
    public sealed virtual void SendStructuralFeatureChanged(IObject io, IStructuralFeature sf);
    private IClass GetClassByName(string className);
    private IStructuralFeature GetStructuralFeatureByName(IObject obj, string name);
    private IStructuralFeature GetStructuralFeatureByLoopbackIndex(IObject obj, int loopbackIndex);
    public sealed virtual void SetAttribute(IObject obj, string attributeName, object value);
    public sealed virtual void SetAttribute(IObject obj, int loopbackIndex, object value);
    public sealed virtual void SetAttribute(IObject obj, IAttribute attribute, object value);
    public sealed virtual void SetSinglelink(IObject obj, string attributeName, IObject value, int orderNo);
    public sealed virtual void SetSinglelink(IObject obj, IAssociationEnd assocEnd, IObject value, int orderNo);
    public sealed virtual void SetSinglelink(IObject obj, int loopbackIndex, IObject value, int orderNo);
    public sealed virtual void SetMultilink(IObject obj, string assocEndName, IEnumerable value);
    public sealed virtual void SetMultilink(IObject obj, IAssociationEnd assocEnd, IEnumerable value);
    public sealed virtual void SetMultilink(IObject obj, int loopbackIndex, IEnumerable value);
    public sealed virtual void SetIndirectMultilink(IObject obj, string assocEndName, IEnumerable value);
    public sealed virtual void SetIndirectMultilink(IObject obj, IAssociationEnd assocEnd, IEnumerable value);
    public sealed virtual void SetIndirectMultilink(IObject obj, int loopbackIndex, IEnumerable value);
    public sealed virtual void SetIndirectSinglelink(IObject obj, string assocEndName, IObjectPair value);
    public sealed virtual void SetIndirectSinglelink(IObject obj, IAssociationEnd assocEnd, IObjectPair value);
    public sealed virtual void SetIndirectSinglelink(IObject obj, int loopbackIndex, IObjectPair value);
    public sealed virtual void SetMultilinkCurrent(IObject obj, string assocEndName);
    public sealed virtual void SetMultilinkCurrent(IObject obj, IAssociationEnd assocEnd);
    public sealed virtual void SetMultilinkCurrent(IObject obj, int loopbackIndex);
    public sealed virtual IObjectInstance GetObject(object key, IClass c);
    public sealed virtual IObjectInstance GetObject(object key, Type t);
    public sealed virtual IObjectInstance GetObject(object key, string className);
    private IObjectInstance GetObject(Locator loc);
    public sealed virtual T GetObject(object key);
    private Locator GetLocator(IObject obj);
    public sealed virtual object GetKey(IObject obj);
    public sealed virtual void SetExtentCurrent(IClass c);
    public sealed virtual void SetExtentCurrent(Type t);
    public sealed virtual void SetExtentCurrent(string className);
    public sealed virtual void ApplyDatablock(Datablock datablock);
    public virtual void CleanForFree();
}
public class Eco.Services.Impl.DirectSingleLinkContent : object {
    private int m_Orderno;
    private Locator m_Locator;
    public Locator Locator { get; }
    public int OrderNo { get; public set; }
    public DirectSingleLinkContent(Locator target, int orderno);
    public Locator get_Locator();
    public int get_OrderNo();
    public void set_OrderNo(int value);
}
public class Eco.Services.Impl.DirtyListServiceImpl : EcoSpacePart {
    private IObjectRepresentationProvider m_ObjectRepresentationProvider;
    private ICache m_Cache;
    private IVariableFactoryService m_VariableFactoryService;
    private IObjectList m_DirtyObjects;
    private Dictionary`2<Locator, Locator> m_UnsureLocators;
    private Publisher m_DirtyChangedPublisher;
    private Dictionary`2<Guid, IObjectList> _contextDirtyList;
    private Guid _contextDirtyListCurrent;
    private List`1<Guid> _memoryOfOld;
    public IObjectRepresentationProvider ObjectRepresentationProvider { get; public set; }
    public ICache Cache { get; public set; }
    public IVariableFactoryService VariableFactoryService { get; public set; }
    public IObjectList DirtyObjects { get; }
    public IObjectRepresentationProvider get_ObjectRepresentationProvider();
    public void set_ObjectRepresentationProvider(IObjectRepresentationProvider value);
    public ICache get_Cache();
    public void set_Cache(ICache value);
    public IVariableFactoryService get_VariableFactoryService();
    public void set_VariableFactoryService(IVariableFactoryService value);
    private void EnsureDirtyObjectsList();
    public IObjectList get_DirtyObjects();
    private void EnsureDirtyObjects();
    private sealed virtual override IObjectList Eco.Services.IDirtyListService.AllDirtyObjects();
    private sealed virtual override bool Eco.Services.IDirtyListService.HasDirtyObjects();
    private sealed virtual override void Eco.Services.IDirtyListService.Subscribe(ISubscriber subscriber);
    private void HandleDirtyChange(object sender, LocatorEventArgs args);
    protected virtual void DoActivate();
    protected virtual void DoDeactivate();
    protected virtual void DoDeserialize(Stream source, BinaryReader reader);
    public sealed virtual void add_DirtyListChanged(EventHandler value);
    public sealed virtual void remove_DirtyListChanged(EventHandler value);
    public sealed virtual void EnterContext(Guid guid);
    public sealed virtual void LeaveContext(Guid guid);
    public sealed virtual Guid GetCurrentContext();
    public sealed virtual void ForgetAboutContext(Guid guid);
    public sealed virtual IObjectList GetContextDirtyList(Guid guid);
    private void RemoveDirtiesThatHasBecomeClean(IObjectList iObjectList);
    internal void TryAddToContextDirty(IObjectInstance obj);
    internal void TryRemoveToContextDirty(IObjectInstance obj);
    public virtual void CleanForFree();
}
internal class Eco.Services.Impl.EmptyVariableListImpl : object {
    private static IExternalVariableList C_Empty;
    private int Eco.ObjectRepresentation.IExternalVariableList.Count { get; }
    private IExternalVariable Eco.ObjectRepresentation.IExternalVariableList.Item { get; }
    private IExternalVariable Eco.ObjectRepresentation.IExternalVariableList.Item { get; }
    public static IExternalVariableList Empty { get; }
    private static EmptyVariableListImpl();
    private sealed virtual override int Eco.ObjectRepresentation.IExternalVariableList.get_Count();
    private sealed virtual override IExternalVariable Eco.ObjectRepresentation.IExternalVariableList.get_Item(int index);
    private sealed virtual override IExternalVariable Eco.ObjectRepresentation.IExternalVariableList.get_Item(string name);
    private sealed virtual override void Eco.ObjectRepresentation.IExternalVariableList.Subscribe(ISubscriber subscriber);
    private sealed virtual override IEnumerator Eco.ObjectRepresentation.IExternalVariableList.GetEnumerator();
    public static IExternalVariableList get_Empty();
}
internal class Eco.Services.Impl.EnclosureHandler : object {
    private ICache m_Cache;
    private List`1<Locator> m_LocatorList;
    private Dictionary`2<Locator, Locator> m_LocatorHash;
    private bool m_ValidateOnly;
    private bool m_ListIsModified;
    private EnclosureHandler(ICache cache, List`1<Locator> locatorList, bool validateOnly);
    private void AddLocatorToEnclosure(Locator locator);
    private void AddUnsavedLocatorToEnclosure(Locator locator);
    private void AddOldValuesForRole(Locator locator, IAssociationEnd associationEnd);
    private void HandleAssociationEnd(Locator examineLocator, IAssociationEnd associationEnd);
    private void DoEnsureEnclosure();
    public static bool EnsureEnclosure(ICache cache, List`1<Locator> locatorList, bool validateOnly);
}
public class Eco.Services.Impl.ExtentServiceImpl : EcoSpacePartWithTypeSystem {
    private ExtentClassImpl[] m_Extents;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
private IEcoServiceProvider <ServiceProvider>k__BackingField;
    private IObjectFactoryService m_ObjectFactory;
    private IVariableFactoryService m_VariableFactory;
    private IAutoSubscriptionService m_AutoSubscriptionService;
    private IPersistenceHandler m_PersistenceHandler;
    private IVersionService m_VersionService;
    private ICache m_Cache;
    private IDirtyListService m_DirtyListService;
    private IObjectRepresentationProvider m_ObjectRepresentationProvider;
    private HashSet`1<IClass> _extentsInQueForCurrent;
    private Dictionary`2<int, Dictionary`2<IClass, IObjectList>> _historyextentDictionary;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
private IAsyncSupportService <AsyncSupportService>k__BackingField;
    public IEcoServiceProvider ServiceProvider { get; public set; }
    public IObjectFactoryService ObjectFactory { get; public set; }
    public IVariableFactoryService VariableFactory { get; public set; }
    public IAutoSubscriptionService AutoSubscriptionService { get; public set; }
    public IPersistenceHandler PersistenceHandler { get; public set; }
    public IVersionService VersionService { get; public set; }
    public ICache Cache { get; public set; }
    public IDirtyListService DirtyListService { get; public set; }
    public IObjectRepresentationProvider ObjectRepresentationProvider { get; public set; }
    public ISubscriber CurrentAutoSubscriber { get; }
    private IObjectFactoryService Eco.ObjectRepresentation.Impl.IElementImplContext.ObjectFactoryService { get; }
    private IVariableFactoryService Eco.ObjectRepresentation.Impl.IElementImplContext.VariableFactoryService { get; }
    public IAsyncSupportService AsyncSupportService { get; public set; }
    public ExtentServiceImpl(IEcoTypeSystem typeSystem);
    [CompilerGeneratedAttribute]
public sealed virtual IEcoServiceProvider get_ServiceProvider();
    [CompilerGeneratedAttribute]
public void set_ServiceProvider(IEcoServiceProvider value);
    public IObjectFactoryService get_ObjectFactory();
    public void set_ObjectFactory(IObjectFactoryService value);
    public IVariableFactoryService get_VariableFactory();
    public void set_VariableFactory(IVariableFactoryService value);
    public IAutoSubscriptionService get_AutoSubscriptionService();
    public void set_AutoSubscriptionService(IAutoSubscriptionService value);
    public IPersistenceHandler get_PersistenceHandler();
    public void set_PersistenceHandler(IPersistenceHandler value);
    public IVersionService get_VersionService();
    public void set_VersionService(IVersionService value);
    public ICache get_Cache();
    public void set_Cache(ICache value);
    public IDirtyListService get_DirtyListService();
    public void set_DirtyListService(IDirtyListService value);
    public IObjectRepresentationProvider get_ObjectRepresentationProvider();
    public void set_ObjectRepresentationProvider(IObjectRepresentationProvider value);
    protected virtual void DoActivate();
    private void ExtentInvalidated(IClass c);
    protected virtual void DoDeactivate();
    public virtual void CleanForFree();
    private IObjectList EnsuredExtentForClass(IClass c, bool all);
    public sealed virtual bool IsAllKnownFetched(IClass c);
    private IObjectList EnsuredExtentForClassInternal(IClass c, bool all);
    private ICollection`1<Locator> LocatorListForClassFromCache(IClass fillClass);
    private IObjectList FetchAdjustedClassList(IClass fillClass);
    private ExtentClassImpl ClosestUseableExtent(IClass c, bool all);
    private sealed virtual override IObjectList Eco.Services.IExtentService.AllInstances(IClass c);
    private sealed virtual override IObjectList Eco.Services.IExtentService.AllInstancesAtTime(IClass c, int version);
    private IObjectList AllInstancesAtTimeInternal(IClass c, int version, bool all);
    private sealed virtual override IObjectList Eco.Services.IExtentService.AllInstances(Type t);
    private sealed virtual override IObjectList Eco.Services.IExtentService.AllInstances(string className);
    private sealed virtual override IEcoList`1<T> Eco.Services.IExtentService.AllInstances();
    private sealed virtual override IObjectList Eco.Services.IExtentService.AllLoadedInstances(IClass c);
    private sealed virtual override IObjectList Eco.Services.IExtentService.AllLoadedInstances(Type t);
    private sealed virtual override IObjectList Eco.Services.IExtentService.AllLoadedInstances(string className);
    private sealed virtual override IEcoList`1<T> Eco.Services.IExtentService.AllLoadedInstances();
    private sealed virtual override void Eco.Services.IExtentService.SubscribeToObjectAdded(ISubscriber subscriber, IClass c);
    private sealed virtual override void Eco.Services.IExtentService.SubscribeToObjectAdded(ISubscriber subscriber, Type t);
    private sealed virtual override void Eco.Services.IExtentService.SubscribeToObjectAdded(ISubscriber subscriber, string className);
    private sealed virtual override void Eco.Services.IExtentService.SubscribeToObjectRemoved(ISubscriber subscriber, IClass c);
    private sealed virtual override void Eco.Services.IExtentService.SubscribeToObjectRemoved(ISubscriber subscriber, Type t);
    private sealed virtual override void Eco.Services.IExtentService.SubscribeToObjectRemoved(ISubscriber subscriber, string className);
    private sealed virtual override void Eco.Services.IExtentService.Unload(IClass c);
    private void LocatorAdded(object sender, LocatorEventArgs args);
    private void ExistenceChanged(object sender, LocatorEventArgs args);
    private void LocatorAffected(Locator locator);
    public sealed virtual ISubscriber get_CurrentAutoSubscriber();
    private sealed virtual override IObjectFactoryService Eco.ObjectRepresentation.Impl.IElementImplContext.get_ObjectFactoryService();
    private sealed virtual override IVariableFactoryService Eco.ObjectRepresentation.Impl.IElementImplContext.get_VariableFactoryService();
    [CompilerGeneratedAttribute]
public IAsyncSupportService get_AsyncSupportService();
    [CompilerGeneratedAttribute]
public void set_AsyncSupportService(IAsyncSupportService value);
    protected virtual void DoPreDeactivate();
    private sealed virtual override IEcoTypeSystem Eco.ObjectRepresentation.Impl.IElementImplContext.get_TypeSystem();
}
public class Eco.Services.Impl.ExternalIdServiceImpl : ExternalIdServiceBase {
    public ExternalIdServiceImpl(IEcoTypeSystem typeSystem);
    protected virtual string GetExternalClassId(IObject obj, Locator loc, ObjectId id);
    protected virtual int GetTopSortedIndex(string externalClassId);
}
public class Eco.Services.Impl.ExternalIdServiceImpl_Id : ExternalIdServiceBase {
    private Dictionary`2<string, int> m_ClassIdHash;
    public ExternalIdServiceImpl_Id(IEcoTypeSystem typeSystem);
    private void InitIdHash();
    protected virtual string GetExternalClassId(IObject obj, Locator loc, ObjectId id);
    protected virtual int GetTopSortedIndex(string externalClassId);
}
public class Eco.Services.Impl.ExternalIdServiceImpl_Name : ExternalIdServiceBase {
    public ExternalIdServiceImpl_Name(IEcoTypeSystem typeSystem);
    protected virtual string GetExternalClassId(IObject obj, Locator loc, ObjectId id);
    protected virtual int GetTopSortedIndex(string externalClassId);
}
public interface Eco.Services.Impl.IIsExtentList {
}
internal interface Eco.Services.Impl.IUndohandler {
    public abstract virtual void HandleCacheMember(ICache cache, Locator locator, IStructuralFeature StructuralFeature);
    public abstract virtual void HandleCacheObject(ICache cache, Locator locator, bool RegardAsExisting);
}
public class Eco.Services.Impl.MemberContent : object {
    private static MemberContent s_NilId;
    private PersistenceState m_PersistenceState;
    private object m_Content;
    public PersistenceState PersistenceState { get; public set; }
    public object Contents { get; public set; }
    public static MemberContent NilIdValue { get; }
    private static MemberContent();
    public PersistenceState get_PersistenceState();
    public void set_PersistenceState(PersistenceState value);
    public object get_Contents();
    public void set_Contents(object value);
    public void AssignContent(MemberContent Source);
    public void AssignContent(ICache Cache, Locator Loc, int MemberIndex);
    public static MemberContent get_NilIdValue();
}
public class Eco.Services.Impl.ObjectContent : object {
    private ExistenceState m_ExistenceState;
    private PersistenceState m_PersistenceState;
    private List`1<MemberContent> m_MemberList;
    private Locator m_Locator;
    public ExistenceState ExistenceState { get; public set; }
    public PersistenceState PersistenceState { get; public set; }
    public int MemberCount { get; }
    public ObjectContent(Locator Loc);
    public MemberContent ValueByIndex(int i);
    public ExistenceState get_ExistenceState();
    public void set_ExistenceState(ExistenceState value);
    public PersistenceState get_PersistenceState();
    public void set_PersistenceState(PersistenceState value);
    public int get_MemberCount();
    public void ApplyObjectContent(ObjectContent ObjectContents, bool ApplyValues);
    public void UpdateObjectContentFrom(ICache Cache, Locator Loc);
    public MemberContent GetEnsuredMember(int Index);
    public void SetStates(ICache Cache, Locator locator);
}
public class Eco.Services.Impl.ObjectContentList : object {
    private Dictionary`2<Locator, ObjectContent> m_ObjectContentsList;
    public ICollection`1<Locator> AllLocators { get; }
    public ObjectContent GetObjectContent(Locator locator);
    public bool ContainsKey(Locator locator);
    public void EnsureObjectContent(Locator locator);
    public ICollection`1<Locator> get_AllLocators();
    public ObjectContent GetEnsuredObjectContent(Locator locator);
    public bool ContainsData();
}
public class Eco.Services.Impl.PersistenceServiceImpl : EcoSpacePartWithTypeSystem {
    private ICache m_Cache;
    private IObjectRepresentationProvider m_ObjectRepresentationProvider;
    private IPersistenceHandler m_PersistenceHandler;
    private IChangeHandler m_ChangeHandler;
    private IStateService m_StateService;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
private IVariableFactoryService <VariableFactoryService>k__BackingField;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
private IAutoSubscriptionService <AutoSubscriptionService>k__BackingField;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
private IObjectFactoryService <ObjectFactoryService>k__BackingField;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
private IEcoServiceProvider <ServiceProvider>k__BackingField;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
private EventHandler InvalidationsDone;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
private EventHandler`1<InvalidateByRealtimeDoneArgs> InvalidateByRealtimeDone;
    private DateTime _lastRefreshSafePeriodic;
    private int _pagesize;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
private IAsyncSupportService <AsyncSupportService>k__BackingField;
    public ICache Cache { get; public set; }
    public IObjectRepresentationProvider ObjectRepresentationProvider { get; public set; }
    public IPersistenceHandler PersistenceHandler { get; public set; }
    public IChangeHandler ChangeHandler { get; public set; }
    public IStateService StateService { get; public set; }
    public IVariableFactoryService VariableFactoryService { get; public set; }
    public IAutoSubscriptionService AutoSubscriptionService { get; public set; }
    public IObjectFactoryService ObjectFactoryService { get; public set; }
    public IEcoServiceProvider ServiceProvider { get; public set; }
    public DateTime LatestServerRestartDiscovered { get; }
    private bool Eco.Services.IPersistenceService.SupportsSync { get; }
    private int Eco.Services.IPersistenceService.PageSize { get; private set; }
    private bool Eco.Services.IPersistenceService.IsPersistent { get; }
    public ISubscriber CurrentAutoSubscriber { get; }
    public IAsyncSupportService AsyncSupportService { get; public set; }
    public PersistenceServiceImpl(IEcoTypeSystem typeSystem);
    public ICache get_Cache();
    public void set_Cache(ICache value);
    public IObjectRepresentationProvider get_ObjectRepresentationProvider();
    public void set_ObjectRepresentationProvider(IObjectRepresentationProvider value);
    public IPersistenceHandler get_PersistenceHandler();
    public void set_PersistenceHandler(IPersistenceHandler value);
    public IChangeHandler get_ChangeHandler();
    public void set_ChangeHandler(IChangeHandler value);
    public IStateService get_StateService();
    public void set_StateService(IStateService value);
    [CompilerGeneratedAttribute]
public sealed virtual IVariableFactoryService get_VariableFactoryService();
    [CompilerGeneratedAttribute]
public void set_VariableFactoryService(IVariableFactoryService value);
    [CompilerGeneratedAttribute]
public IAutoSubscriptionService get_AutoSubscriptionService();
    [CompilerGeneratedAttribute]
public void set_AutoSubscriptionService(IAutoSubscriptionService value);
    [CompilerGeneratedAttribute]
public sealed virtual IObjectFactoryService get_ObjectFactoryService();
    [CompilerGeneratedAttribute]
public void set_ObjectFactoryService(IObjectFactoryService value);
    [CompilerGeneratedAttribute]
public sealed virtual IEcoServiceProvider get_ServiceProvider();
    [CompilerGeneratedAttribute]
public void set_ServiceProvider(IEcoServiceProvider value);
    public sealed virtual DateTime get_LatestServerRestartDiscovered();
    protected virtual void DoActivate();
    public sealed virtual void UpdateDatabaseWithList(IEnumerable`1<T> list);
    public sealed virtual void SuspectExternalUpdateInvalidate(IEnumerable`1<T> list);
    private sealed virtual override bool Eco.Services.IPersistenceService.get_SupportsSync();
    private sealed virtual override void Eco.Services.IPersistenceService.Refresh(bool fetchValues);
    [CompilerGeneratedAttribute]
public sealed virtual void add_InvalidationsDone(EventHandler value);
    [CompilerGeneratedAttribute]
public sealed virtual void remove_InvalidationsDone(EventHandler value);
    [CompilerGeneratedAttribute]
public sealed virtual void add_InvalidateByRealtimeDone(EventHandler`1<InvalidateByRealtimeDoneArgs> value);
    [CompilerGeneratedAttribute]
public sealed virtual void remove_InvalidateByRealtimeDone(EventHandler`1<InvalidateByRealtimeDoneArgs> value);
    private sealed virtual override bool Eco.Services.IPersistenceService.RefreshSafePeriodic(int secsapart);
    public void InvalidateByRealtime(Locator l, IStructuralFeature sf);
    public sealed virtual void RetrieveChanges();
    public sealed virtual void RetrieveChanges(DBChangeCollection& ignoredChanges);
    private sealed virtual override IChange[] Eco.Services.IPersistenceService.GetChanges();
    private sealed virtual override void Eco.Services.IPersistenceService.ApplyAllChanges();
    private sealed virtual override IObjectList Eco.Services.IPersistenceService.GetAllWithCondition(AbstractCondition condition);
    public sealed virtual IObjectList GetAllWithCondition(AbstractCondition condition, int maxAnswers, int offset);
    public sealed virtual Datablock GetObjectsWithCondition(AbstractCondition condition, int maxAnswers, int offset);
    public sealed virtual IElement GetValueWithCondition(AbstractCondition condition, int maxAnswers, int offset, IClassifier resultType);
    public sealed virtual IElementCollection GetTuplesWithCondition(AbstractCondition condition, int maxAnswers, int offset, IClassifier resultType);
    private sealed virtual override void Eco.Services.IPersistenceService.EnsureEnclosure(IObjectList list);
    private sealed virtual override void Eco.Services.IPersistenceService.Unload(IEnumerable`1<T> objects);
    private void Unload(IEcoObject obj);
    private sealed virtual override void Eco.Services.IPersistenceService.DiscardChanges(IEnumerable`1<T> objects);
    private void DiscardChanges(IEcoObject obj);
    public sealed virtual bool IsLoaded(IEcoObject obj);
    private sealed virtual override void Eco.Services.IPersistenceService.set_PageSize(int value);
    private sealed virtual override int Eco.Services.IPersistenceService.get_PageSize();
    private sealed virtual override void Eco.Services.IPersistenceService.EnsureRange(IObjectList objects, int fromIndex, int toIndex);
    private sealed virtual override bool Eco.Services.IPersistenceService.IsRangeEnsured(IObjectList objects, int fromIndex, int toIndex);
    private sealed virtual override void Eco.Services.IPersistenceService.EnsureObject(IObjectInstance obj);
    private sealed virtual override IObjectList Eco.Services.IPersistenceService.EnsureRelatedObjects(IEnumerable`1<T> objects, string memberName);
    private sealed virtual override IObjectList Eco.Services.IPersistenceService.EnsureRelatedObjects(IEnumerable`1<T> objects, IAssociationEnd assocEnd);
    private sealed virtual override bool Eco.Services.IPersistenceService.get_IsPersistent();
    public sealed virtual ISubscriber get_CurrentAutoSubscriber();
    [CompilerGeneratedAttribute]
public IAsyncSupportService get_AsyncSupportService();
    [CompilerGeneratedAttribute]
public void set_AsyncSupportService(IAsyncSupportService value);
    public virtual void CleanForFree();
    private sealed virtual override IEcoTypeSystem Eco.ObjectRepresentation.Impl.IElementImplContext.get_TypeSystem();
    [CompilerGeneratedAttribute]
private void <Eco.Services.IPersistenceService.RefreshSafePeriodic>b__52_0();
    [CompilerGeneratedAttribute]
private void <RetrieveChanges>b__54_0();
}
public class Eco.Services.Impl.StateServiceImpl : EcoSpacePart {
    private IObjectRepresentationProvider m_ObjectRepresentationProvider;
    private ICache m_Cache;
    public IObjectRepresentationProvider ObjectRepresentationProvider { get; public set; }
    public ICache Cache { get; public set; }
    public IObjectRepresentationProvider get_ObjectRepresentationProvider();
    public void set_ObjectRepresentationProvider(IObjectRepresentationProvider value);
    public ICache get_Cache();
    public void set_Cache(ICache value);
    public sealed virtual bool IsNew(IEcoObject obj);
    public sealed virtual bool IsDirty(IEcoObject obj);
    private sealed virtual override bool Eco.Services.IStateService.IsDirty(IProperty prop);
    private sealed virtual override bool Eco.Services.IStateService.IsInvalid(IProperty prop);
    protected virtual void DoActivate();
    public virtual void CleanForFree();
}
public class Eco.Services.Impl.UndoBlock : object {
    private ObjectContentList m_ObjectContentList;
    private bool m_ContainsChanges;
    private UndoBlockList m_OwningList;
    private IObjectList m_ChangedObjects;
    private Publisher m_UndoBlockPublisher;
    private string m_Name;
    public ObjectContentList ObjectContentList { get; public set; }
    public string Name { get; public set; }
    public bool ContainsChanges { get; }
    public UndoBlock(string Name, UndoBlockList owningList, ObjectContentList ValueSpace);
    public ObjectContentList get_ObjectContentList();
    public void set_ObjectContentList(ObjectContentList value);
    public sealed virtual string get_Name();
    public void set_Name(string value);
    public sealed virtual void Subscribe(ISubscriber subscriber);
    public DirectSingleLinkContent DoDeserialize_FromId(ICache cache, ObjectId id);
    public void DoDeserialize(Stream source, BinaryReader reader);
    public ObjectId LocatorToId(ICache cache, Locator l);
    public void DoSerialize(Stream target);
    public bool IsDependentOn(UndoBlock block);
    public void Merge(UndoBlock block, bool overwrite);
    public bool ValueExists(Locator locator, int memberIndex);
    public void HandleCacheMember(ICache cache, Locator locator, IStructuralFeature StructuralFeature);
    public void HandleCacheObject(ICache cache, Locator locator, bool regardAsExisting);
    private void ObjectChanged(Locator locator);
    public sealed virtual bool get_ContainsChanges();
    public bool Contains(Locator l);
    public bool ContainsAny(ICollection`1<Locator> locatorList);
    public void FreeLocators(ICache cache);
    public sealed virtual IObjectList GetChangedObjects();
}
[DefaultMemberAttribute("Item")]
public class Eco.Services.Impl.UndoBlockList : object {
    private List`1<UndoBlock> m_List;
    private UndoHandler m_Owner;
    public int Count { get; }
    public UndoBlock CurrentBlock { get; }
    public UndoHandler Owner { get; }
    public IUndoBlock Item { get; }
    public IUndoBlock Item { get; }
    public IUndoBlock TopBlock { get; }
    public UndoBlockList(UndoHandler handler);
    public UndoBlock AssertedBlocksByName(string blockName);
    public UndoBlock AssertedBlocksByIndex(int Index);
    public UndoBlock BlocksbyIndex(int index);
    public UndoBlock BlocksByName(string BlockName);
    private void EnsureNoNullBlocks();
    public sealed virtual int get_Count();
    public UndoBlock get_CurrentBlock();
    public UndoHandler get_Owner();
    public UndoBlock AddBlock(string BlockName, ObjectContentList ValueSpace);
    public sealed virtual bool CanMoveBlock(int CurIndex, int NewIndex);
    public void Clear();
    public void DoDeserialize(Stream source, BinaryReader reader);
    public void DoSerialize(Stream target);
    public void EnsureNotEmpty();
    public sealed virtual int IndexOf(string blockName);
    public sealed virtual void MoveToTop(string blockName);
    public void InternalRemoveBlock(string blockName);
    public sealed virtual void RenameBlock(string oldName, string newName);
    public void InternalMergeBlocks(string destinationBlockName, string sourceBlockName);
    public sealed virtual bool CanMergeBlock(int curIndex, int newIndex);
    public sealed virtual IEnumerator GetEnumerator();
    public bool CanMoveToTop(int CurIndex);
    public int AssertedIndexOf(string blockName);
    public sealed virtual IUndoBlock get_Item(string name);
    public sealed virtual IUndoBlock get_Item(int Index);
    public sealed virtual IUndoBlock get_TopBlock();
    public void MergeAll();
    public bool InternalRemoveBlock2(string BlockName);
    public sealed virtual void MoveBlock(int curIndex, int newIndex);
    public bool Contains(Locator l);
    public void RemoveAllDependentBlocks(ICollection`1<Locator> locatorList);
    public void InternalRemoveAndFree(int index);
    public sealed virtual void MergeBlocks(string DestinationBlockName, string SourceBlockName);
    public sealed virtual bool RemoveBlock(string blockName);
}
public class Eco.Services.Impl.UndoCacheWrapper : ChainedCacheBase {
    private IUndohandler m_UndoHandler;
    internal UndoCacheWrapper(IUndohandler undoHandler);
    public virtual void ApplyTranslationList(IdTranslationList idTranslationList);
    public virtual void SetCurrentValue(Locator locator, IStructuralFeature structuralFeature, object value);
    public virtual void SetExistenceState(Locator locator, ExistenceState value);
    public virtual void SetMemberPersistenceState(Locator locator, IStructuralFeature structuralFeature, PersistenceState value);
    public virtual void SetPersistenceState(Locator locator, PersistenceState value);
    public virtual void SetCurrentOrderNo(Locator locator, IStructuralFeature structuralFeature, int orderNo);
    public virtual void SetFetchedValue(Locator locator, IStructuralFeature structuralFeature, object value);
    public virtual void SetTimestamp(Locator locator, int value);
    public virtual void SetCurrentAndFetchedOrderNo(Locator locator, IStructuralFeature structuralFeature, int orderNo);
    public virtual void SetCurrentAndFetchedValue(Locator locator, IStructuralFeature structuralFeature, object value);
}
public class Eco.Services.Impl.UndoHandler : EcoSpacePartWithTypeSystem {
    private int m_TransactionNesting;
    private bool m_TransactionRollbackOnly;
    private UndoBlockList m_UndoBlocks;
    private UndoBlockList m_RedoBlocks;
    private UndoState m_UndoState;
    private string m_TransactionAreaName;
    private IObjectRepresentationProvider m_ObjectRepresentationProvider;
    private ICache m_Cache;
    private UndoBlockList UndoBlocks { get; }
    private UndoBlockList RedoBlocks { get; }
    public IObjectRepresentationProvider ObjectRepresentationProvider { get; public set; }
    public ICache Cache { get; public set; }
    public IUndoBlockList RedoList { get; }
    public IUndoBlockList UndoList { get; }
    public int TransactionNesting { get; }
    public bool IsInTransaction { get; }
    public UndoHandler(IEcoTypeSystem typeSystem);
    private UndoBlockList get_UndoBlocks();
    private UndoBlockList get_RedoBlocks();
    public IObjectRepresentationProvider get_ObjectRepresentationProvider();
    public void set_ObjectRepresentationProvider(IObjectRepresentationProvider value);
    public ICache get_Cache();
    public void set_Cache(ICache value);
    public sealed virtual void HandleCacheMember(ICache cache, Locator locator, IStructuralFeature structuralFeature);
    public sealed virtual void StartUndoBlock(string blockName);
    public sealed virtual void UndoBlock(string blockName);
    public sealed virtual void RedoBlock(string blockName);
    public sealed virtual void RedoLatest();
    public sealed virtual void UndoLatest();
    public sealed virtual void HandleCacheObject(ICache cache, Locator locator, bool regardAsExisting);
    public void UndoSingleLinkContent(Locator loc, IAssociationEnd associationEnd, MemberContent value);
    public void UnDoObjectAndAttributes(Locator loc, ObjectContent objectContents);
    public void UndoLinks(Locator loc, ObjectContent ObjectContents);
    public void SaveOldValues(ObjectContentList undoContents, IEnumerable`1<Locator> locators, ObjectContentList redoContents);
    private ObjectAction GetObjectAction(ObjectContent objectContent, Locator loc);
    private void DoUndo(ObjectContentList unDoValueSpace, ObjectContentList redoValueSpace);
    private void DoUndoInTransaction(string blockName, UndoBlockList fromList, UndoBlockList toList);
    public sealed virtual bool CanRedoBlock(string blockName);
    public sealed virtual bool CanUndoBlock(string blockName);
    public sealed virtual IUndoBlockList get_RedoList();
    public sealed virtual IUndoBlockList get_UndoList();
    public sealed virtual string GetUniqueBlockName(string suggestedName);
    public sealed virtual void StartUndoBlock();
    public sealed virtual void ClearAllUndoBlocks();
    public sealed virtual void StartTransaction();
    public sealed virtual void CommitTransaction();
    public sealed virtual void RollbackTransaction();
    private void DoCanRelease(Locator l, CanReleaseResult res);
    public void ObjectsUpdated(object sender, LocatorCollectionEventArgs args);
    public static bool StoreInUndo(IStructuralFeature StructuralFeature);
    protected virtual void DoDeactivate();
    public virtual void CleanForFree();
    protected virtual void DoDeserialize(Stream source, BinaryReader reader);
    protected virtual void DoSerialize(Stream target, EcoSpaceSerializationConfig config);
    protected virtual void DoActivate();
    public sealed virtual int get_TransactionNesting();
    public sealed virtual bool get_IsInTransaction();
    public void EnsureNotInTransaction();
}
public class Eco.Services.Impl.UndoImpl : EcoSpacePartWithTypeSystem {
    private UndoCacheWrapper m_UndoableCache;
    private UndoHandler m_UndoService;
    public ICache Cache { get; public set; }
    public IObjectRepresentationProvider ObjectRepresentationProvider { get; public set; }
    public IUndoService UndoService { get; }
    public ICache UndoableCache { get; }
    public UndoImpl(IEcoTypeSystem TypeSystem);
    public ICache get_Cache();
    public void set_Cache(ICache value);
    public IObjectRepresentationProvider get_ObjectRepresentationProvider();
    public void set_ObjectRepresentationProvider(IObjectRepresentationProvider value);
    public IUndoService get_UndoService();
    public ICache get_UndoableCache();
    public void ObjectsUpdated(object sender, LocatorCollectionEventArgs args);
    protected virtual void DoDeactivate();
    public virtual void CleanForFree();
    protected virtual void DoDeserialize(Stream source, BinaryReader reader);
    protected virtual void DoSerialize(Stream target, EcoSpaceSerializationConfig config);
    protected virtual void DoActivate();
}
public class Eco.Services.Impl.VariableFactoryServiceImpl : EcoSpacePartWithTypeSystem {
    private IObjectInstance m_NullReference;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
private IObjectFactoryService <ObjectFactoryService>k__BackingField;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
private IAutoSubscriptionService <AutoSubscriptionService>k__BackingField;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
private IEcoServiceProvider <ServiceProvider>k__BackingField;
    public IObjectFactoryService ObjectFactoryService { get; public set; }
    public IAutoSubscriptionService AutoSubscriptionService { get; public set; }
    public IEcoServiceProvider ServiceProvider { get; public set; }
    private IExternalVariableList Eco.Services.IVariableFactoryService.EmptyVariableList { get; }
    private IObjectInstance Eco.Services.IVariableFactoryService.NullReference { get; }
    public ISubscriber CurrentAutoSubscriber { get; }
    private IVariableFactoryService Eco.ObjectRepresentation.Impl.IElementImplContext.VariableFactoryService { get; }
    public VariableFactoryServiceImpl(IEcoTypeSystem typeSystem);
    [CompilerGeneratedAttribute]
public sealed virtual IObjectFactoryService get_ObjectFactoryService();
    [CompilerGeneratedAttribute]
public void set_ObjectFactoryService(IObjectFactoryService value);
    [CompilerGeneratedAttribute]
public IAutoSubscriptionService get_AutoSubscriptionService();
    [CompilerGeneratedAttribute]
public void set_AutoSubscriptionService(IAutoSubscriptionService value);
    [CompilerGeneratedAttribute]
public sealed virtual IEcoServiceProvider get_ServiceProvider();
    [CompilerGeneratedAttribute]
public void set_ServiceProvider(IEcoServiceProvider value);
    private IClassifier GetEnsuredClassifier(Type type);
    private IClass GetEnsuredClass(Type type);
    private IClassifier GetEnsuredClassifier(string typeName);
    private sealed virtual override IElement Eco.Services.IVariableFactoryService.CreateVariable(Type type);
    private sealed virtual override IElement Eco.Services.IVariableFactoryService.CreateVariable(string typeName);
    private sealed virtual override IElement Eco.Services.IVariableFactoryService.CreateConstant(object asObject);
    public sealed virtual IElement CreateVariable(IClassifier classifier);
    public sealed virtual IElement CreateConstant(IClassifier classifier, object asObject);
    public sealed virtual IObjectList CreateUntypedObjectList(bool allowDuplicates);
    public sealed virtual IObjectList CreateTypedObjectList(IClass umlClass, bool allowDuplicates);
    public sealed virtual IObjectList CreateTypedObjectList(Type type, bool allowDuplicates);
    public sealed virtual IElementCollection CreateUntypedElementCollection(bool allowDuplicates);
    public sealed virtual IElementCollection CreateTypedElementCollection(Type type, bool allowDuplicates);
    private sealed virtual override IModifiableVariableList Eco.Services.IVariableFactoryService.CreateVariableList();
    private sealed virtual override IModifiableVariableList Eco.Services.IVariableFactoryService.CreateVariableList(string name, IClassifier classifier);
    private sealed virtual override IModifiableVariableList Eco.Services.IVariableFactoryService.CreateVariableList(string name, Type type);
    private sealed virtual override IModifiableVariableList Eco.Services.IVariableFactoryService.CreateVariableList(string name, object valueAsObject);
    private sealed virtual override IModifiableVariableList Eco.Services.IVariableFactoryService.CreateVariableList(string name, IElement value);
    private sealed virtual override IExternalVariableList Eco.Services.IVariableFactoryService.get_EmptyVariableList();
    private sealed virtual override IObjectInstance Eco.Services.IVariableFactoryService.get_NullReference();
    protected virtual void DoActivate();
    public sealed virtual ISubscriber get_CurrentAutoSubscriber();
    private sealed virtual override IVariableFactoryService Eco.ObjectRepresentation.Impl.IElementImplContext.get_VariableFactoryService();
    public sealed virtual IObjectInstance CreateTypedNullReference(IClass umlClass);
    public virtual void CleanForFree();
    private sealed virtual override IEcoTypeSystem Eco.ObjectRepresentation.Impl.IElementImplContext.get_TypeSystem();
}
[DefaultMemberAttribute("Item")]
internal class Eco.Services.Impl.VariableListImpl : object {
    private List`1<IExternalVariable> m_Variables;
    private Publisher m_Publisher;
    private IElementImplContext m_ElementImplContext;
    private Publisher EnsuredPublisher { get; }
    public IElementImplContext ElementImplContext { get; }
    public int Count { get; }
    private int Eco.ObjectRepresentation.IExternalVariableList.Count { get; }
    public IExternalVariable Item { get; }
    private IExternalVariable Eco.ObjectRepresentation.IExternalVariableList.Item { get; }
    private IExternalVariable Eco.ObjectRepresentation.IExternalVariableList.Item { get; }
    public VariableListImpl(IElementImplContext elementImplContext);
    private Publisher get_EnsuredPublisher();
    private void OnLastSub();
    public IElementImplContext get_ElementImplContext();
    private void AutoSubscribe();
    public int get_Count();
    private sealed virtual override int Eco.ObjectRepresentation.IExternalVariableList.get_Count();
    private sealed virtual override IEnumerator Eco.ObjectRepresentation.IExternalVariableList.GetEnumerator();
    public IExternalVariable get_Item(int index);
    private sealed virtual override IExternalVariable Eco.ObjectRepresentation.IExternalVariableList.get_Item(int index);
    private sealed virtual override IExternalVariable Eco.ObjectRepresentation.IExternalVariableList.get_Item(string name);
    public sealed virtual void Subscribe(ISubscriber subscriber);
    private sealed virtual override void Eco.ObjectRepresentation.IModifiableVariableList.Remove(string name);
    public sealed virtual void RemoveAt(int i);
    private sealed virtual override void Eco.ObjectRepresentation.IModifiableVariableList.Add(IExternalVariable variable);
    private sealed virtual override void Eco.ObjectRepresentation.IModifiableVariableList.Add(string name, IElement element);
    private sealed virtual override void Eco.ObjectRepresentation.IModifiableVariableList.Add(string name, IClassifier umlType);
    private sealed virtual override void Eco.ObjectRepresentation.IModifiableVariableList.Add(string name, Type t);
    private sealed virtual override void Eco.ObjectRepresentation.IModifiableVariableList.AddConstant(string name, object value);
}
public class Eco.Services.Impl.VersionServiceImpl : EcoSpacePart {
    private IObjectRepresentationProvider m_ObjectRepresentationProvider;
    private ICache m_Cache;
    private IPersistenceHandler m_PersistenceHandler;
    private Dictionary`2<int, DateTime> m_VersionCache;
    private int _SystemWideVersionNumber;
    public IObjectRepresentationProvider ObjectRepresentationProvider { get; public set; }
    public ICache Cache { get; public set; }
    public IPersistenceHandler PersistenceHandler { get; public set; }
    private int Eco.Services.IVersionService.MaxSavedVersion { get; }
    private int Eco.Services.IVersionService.CurrentVersion { get; }
    public IObjectRepresentationProvider get_ObjectRepresentationProvider();
    public void set_ObjectRepresentationProvider(IObjectRepresentationProvider value);
    public ICache get_Cache();
    public void set_Cache(ICache value);
    public IPersistenceHandler get_PersistenceHandler();
    public void set_PersistenceHandler(IPersistenceHandler value);
    protected virtual void DoActivate();
    private sealed virtual override int Eco.Services.IVersionService.get_MaxSavedVersion();
    private sealed virtual override int Eco.Services.IVersionService.get_CurrentVersion();
    public sealed virtual int ElementVersion(IElement element);
    public sealed virtual IElement GetVersion(int version, IElement element);
    private sealed virtual override DateTime Eco.Services.IVersionService.TimeForVersion(int version);
    private sealed virtual override int Eco.Services.IVersionService.VersionAtTime(DateTime time);
    private AbstractCondition InternalGetChangePointCondition(IClass c, IObjectList objects, int startVersion, int stopVersion, IStructuralFeature[] members);
    public sealed virtual AbstractCondition GetChangePointCondition(IObjectList objects, int startVersion, int stopVersion, String[] members);
    public sealed virtual AbstractCondition GetChangePointCondition(IObjectList objects, int startVersion, int stopVersion);
    public sealed virtual AbstractCondition GetChangePointCondition(IEcoObject obj, int startVersion, int stopVersion, String[] members);
    public sealed virtual AbstractCondition GetChangePointCondition(IEcoObject obj, int startVersion, int stopVersion);
    public sealed virtual bool SystemWideVersionNumberInUse();
    public sealed virtual int GetSystemWideVersionNumber();
    public sealed virtual void SetSystemWideVersionNumber(int version);
    public virtual void CleanForFree();
}
public interface Eco.Services.IMultiLinkCatcher {
    public abstract virtual void MultiLinkModified(IAssociationEnd ae);
}
public interface Eco.Services.ISingleLinkCatcher {
    public abstract virtual void SingleLinkModified(IAssociationEnd ae, IEcoObject oldValue, IEcoObject newValue);
}
public class Eco.Services.LinkOperationCache : ChainedCacheBase {
    private IObjectRepresentationProvider objrep;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
private bool <Enabled>k__BackingField;
    private Dictionary`2<Locator, IEcoObject> firstInnerLinkValues;
    public bool Enabled { get; public set; }
    public LinkOperationCache(DefaultFrontsidePolicy fsp);
    [CompilerGeneratedAttribute]
public bool get_Enabled();
    [CompilerGeneratedAttribute]
public void set_Enabled(bool value);
    public virtual void SetCurrentValue(Locator locator, IStructuralFeature structuralFeature, object value);
    private static void NotifyAssociationEnds(IEcoObject oldValue, IObject owner, IAssociationEnd ae, IEcoObject newValue);
}
public abstract class Eco.Support.Deriver.AbstractDeriver : object {
    private State m_DeriverState;
    private ResubscribeAdapterClass m_ResubscribeAdapter;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
private static bool <ThrowExceptionOnFailedDerivation>k__BackingField;
    private int _invalidatesInAsyncCursor;
    private IAsyncSupportService _refToAsyncSupportService;
    private int _ensureCurrentYields;
    public string GetDebugInfoOfDeriver { get; }
    protected bool IsOutOfDate { get; }
    public bool CanYieldLock { get; }
    public object SyncRoot { get; }
    internal State DeriverState { get; internal set; }
    public static bool ThrowExceptionOnFailedDerivation { get; public set; }
    private ResubscribeAdapterClass EnsuredResubscribeAdapter { get; }
    protected ISubscriber ReevaluateSubscriber { get; }
    protected ISubscriber ResubscribeSubscriber { get; }
    public IEcoServiceProvider ServiceProvider { get; }
    public bool IsDeriving { get; }
    public bool IsUpToDate { get; }
    private static AbstractDeriver();
    public abstract virtual string get_GetDebugInfoOfDeriver();
    private void Reevaluate();
    private void Resubscribe();
    protected bool get_IsOutOfDate();
    private static bool OutOfDate(State s);
    public abstract virtual bool get_CanYieldLock();
    public virtual object get_SyncRoot();
    internal State get_DeriverState();
    internal void set_DeriverState(State value);
    [CompilerGeneratedAttribute]
public static bool get_ThrowExceptionOnFailedDerivation();
    [CompilerGeneratedAttribute]
public static void set_ThrowExceptionOnFailedDerivation(bool value);
    protected abstract virtual void DoDeriveAndSubscribe(bool subscribe);
    protected virtual void DoNotifyOutOfDate();
    protected void CancelAllSubscriptions();
    public virtual void CleanForFree();
    private ResubscribeAdapterClass get_EnsuredResubscribeAdapter();
    protected ISubscriber get_ReevaluateSubscriber();
    protected ISubscriber get_ResubscribeSubscriber();
    public abstract virtual IEcoServiceProvider get_ServiceProvider();
    private bool EnsuredAsyncServRef(IAsyncSupportService& async);
    private void TrackAsyncChangesCursor();
    public void MarkSubscriptionOutOfDate();
    public sealed virtual void MarkOutOfDate();
    protected virtual void HandleRecursiveDerive();
    public void EnsureCurrent();
    private void CheckDoublePassDueToAsyncNewsDuringThisDerivationRun(int invalidatecursorInAsyncOnEnter);
    protected virtual void DoPostDeriveEvents();
    private void Derive();
    public bool get_IsDeriving();
    public bool get_IsUpToDate();
    [CompilerGeneratedAttribute]
private void <EnsureCurrent>b__43_0();
    [CompilerGeneratedAttribute]
private void <EnsureCurrent>b__43_1();
    [CompilerGeneratedAttribute]
private void <EnsureCurrent>b__43_3();
    [CompilerGeneratedAttribute]
private void <EnsureCurrent>b__43_2();
}
public class Eco.UmlRt.Impl.AssociationCollection : ModelElementCollectionBaseY`1<IAssociation> {
}
public abstract class Eco.UmlRt.Impl.AssociationEndBase : StructuralFeature {
    private IAssociation m_Association;
    private IAssociationEnd m_OppositeEnd;
    public IClass AssociationClass { get; }
    public IClass Class_ { get; }
    public IEcoAssociationEnd EcoAssociationEnd { get; }
    public IEcoStructuralFeature EcoStructuralFeature { get; }
    public FeatureType FeatureType { get; }
    public IClassifier Type_ { get; }
    public IAssociation Association { get; public set; }
    public IAssociationEnd OppositeEnd { get; public set; }
    protected AssociationEndBase(UmlClass umlClass, string name);
    public sealed virtual IClass get_AssociationClass();
    public sealed virtual IClass get_Class_();
    public sealed virtual IEcoAssociationEnd get_EcoAssociationEnd();
    public sealed virtual IEcoStructuralFeature get_EcoStructuralFeature();
    public virtual FeatureType get_FeatureType();
    public abstract virtual IClassifier get_Type_();
    protected virtual Type DerivationType();
    protected virtual string GetUmlClassName();
    public sealed virtual IAssociation get_Association();
    public void set_Association(IAssociation value);
    public sealed virtual IAssociationEnd get_OppositeEnd();
    public void set_OppositeEnd(IAssociationEnd value);
}
public class Eco.UmlRt.Impl.AssociationEndInnerLink : AssociationEndSpecialBase {
    private IAssociationEnd otherEnd;
    public string Presentation { get; }
    public bool IsNavigable { get; }
    public OrderingKind Ordering { get; }
    public AggregationKind Aggregation { get; }
    public AssociationEndKind AssociationEndKind { get; }
    public IAssociationEnd MainAssociationEnd { get; }
    public bool IsStoredInObject { get; }
    public bool IsDelayedFetch { get; }
    public bool Persistent { get; }
    public DeleteAction DeleteAction { get; }
    public AssociationEndDefaultRegionMode DefaultRegionMode { get; }
    public LinkFetchStrategy LinkFetchStrategy { get; }
    public AssociationEndInnerLink(UmlClass umlClass, IAssociation association, IAssociationEnd otherEnd, string name);
    public virtual string get_Presentation();
    public sealed virtual bool get_IsNavigable();
    public sealed virtual OrderingKind get_Ordering();
    public sealed virtual AggregationKind get_Aggregation();
    public sealed virtual AssociationEndKind get_AssociationEndKind();
    public sealed virtual IAssociationEnd get_MainAssociationEnd();
    public sealed virtual bool get_IsStoredInObject();
    public sealed virtual bool get_IsDelayedFetch();
    public sealed virtual bool get_Persistent();
    public sealed virtual DeleteAction get_DeleteAction();
    public sealed virtual AssociationEndDefaultRegionMode get_DefaultRegionMode();
    public sealed virtual LinkFetchStrategy get_LinkFetchStrategy();
}
public class Eco.UmlRt.Impl.AssociationEndNormal : AssociationEndBase {
    private AggregationKind m_Aggregation;
    private IAssociationEnd m_AssociationClassEndPointingAway;
    private IAssociationEnd m_AssociationClassEndPointingHere;
    private IClassifier m_ClassOfOppositeEnd;
    private AssociationEndDefaultRegionMode m_DefaultRegionMode;
    private DeleteAction m_DeleteAction;
    private IAssociationEnd m_EndPointingToAssociationClass;
    private bool m_IsDelayedFetch;
    private bool m_IsDerived;
    private bool m_IsNavigable;
    private bool m_IsStoredInObject;
    private LinkFetchStrategy m_LinkFetchStrategy;
    private bool m_MemberPersistent;
    private OrderingKind m_Ordering;
    public IClassifier Type_ { get; }
    public IClassifier ClassOfOppositeEnd { get; public set; }
    public bool CanHaveOldValue { get; }
    public bool IsNavigable { get; public set; }
    public OrderingKind Ordering { get; public set; }
    public AggregationKind Aggregation { get; public set; }
    public AssociationEndKind AssociationEndKind { get; }
    public bool EncouragesOptimisticLockingOnDeletedOnly { get; }
    public IAssociationEnd MainAssociationEnd { get; }
    public bool IsStoredInObject { get; }
    public IAssociationEnd AssociationClassEndPointingAway { get; }
    public IAssociationEnd AssociationClassEndPointingHere { get; }
    public IAssociationEnd EndPointingToAssociationClass { get; }
    public bool IsDelayedFetch { get; }
    public bool Persistent { get; }
    public bool IsDerived { get; }
    public DeleteAction DeleteAction { get; }
    public AssociationEndDefaultRegionMode DefaultRegionMode { get; }
    public LinkFetchStrategy LinkFetchStrategy { get; }
    public AssociationEndNormal(UmlClass umlClass, string name);
    public virtual IClassifier get_Type_();
    public IClassifier get_ClassOfOppositeEnd();
    public void set_ClassOfOppositeEnd(IClassifier value);
    public sealed virtual bool get_CanHaveOldValue();
    public sealed virtual bool get_IsNavigable();
    public void set_IsNavigable(bool value);
    public sealed virtual OrderingKind get_Ordering();
    public void set_Ordering(OrderingKind value);
    public sealed virtual AggregationKind get_Aggregation();
    public void set_Aggregation(AggregationKind value);
    public sealed virtual AssociationEndKind get_AssociationEndKind();
    public sealed virtual bool get_EncouragesOptimisticLockingOnDeletedOnly();
    public sealed virtual IAssociationEnd get_MainAssociationEnd();
    public sealed virtual bool get_IsStoredInObject();
    public sealed virtual IAssociationEnd get_AssociationClassEndPointingAway();
    public sealed virtual IAssociationEnd get_AssociationClassEndPointingHere();
    public sealed virtual IAssociationEnd get_EndPointingToAssociationClass();
    public sealed virtual bool get_IsDelayedFetch();
    public sealed virtual bool get_Persistent();
    public sealed virtual bool get_IsDerived();
    public sealed virtual DeleteAction get_DeleteAction();
    public sealed virtual AssociationEndDefaultRegionMode get_DefaultRegionMode();
    public sealed virtual LinkFetchStrategy get_LinkFetchStrategy();
    public void SetAssociation(IAssociation association, IAssociationEnd otherEndRole);
    public virtual void Ecoify(int IndexInAllStructuralFeatures);
    public virtual void CollectCheckSumData(StringBuilder sb);
}
public abstract class Eco.UmlRt.Impl.AssociationEndSpecialBase : AssociationEndBase {
    public IAssociationEnd AssociationClassEndPointingAway { get; }
    public IAssociationEnd AssociationClassEndPointingHere { get; }
    public bool CanHaveOldValue { get; }
    public bool EncouragesOptimisticLockingOnDeletedOnly { get; }
    public IAssociationEnd EndPointingToAssociationClass { get; }
    public bool IsDerived { get; }
    public IClassifier Type_ { get; }
    protected AssociationEndSpecialBase(UmlClass umlClass, string name);
    public sealed virtual IAssociationEnd get_AssociationClassEndPointingAway();
    public sealed virtual IAssociationEnd get_AssociationClassEndPointingHere();
    public sealed virtual bool get_CanHaveOldValue();
    public sealed virtual bool get_EncouragesOptimisticLockingOnDeletedOnly();
    public sealed virtual IAssociationEnd get_EndPointingToAssociationClass();
    public sealed virtual bool get_IsDerived();
    public virtual IClassifier get_Type_();
}
public class Eco.UmlRt.Impl.AssociationEndToLinkObject : AssociationEndSpecialBase {
    private IAssociationEnd m_Mainend;
    public string Presentation { get; }
    public bool IsNavigable { get; }
    public OrderingKind Ordering { get; }
    public AggregationKind Aggregation { get; }
    public AssociationEndKind AssociationEndKind { get; }
    public IAssociationEnd MainAssociationEnd { get; }
    public bool IsStoredInObject { get; }
    public bool IsDelayedFetch { get; }
    public bool Persistent { get; }
    public DeleteAction DeleteAction { get; }
    public AssociationEndDefaultRegionMode DefaultRegionMode { get; }
    public LinkFetchStrategy LinkFetchStrategy { get; }
    public AssociationEndToLinkObject(string name, IAssociationEnd mainEnd, UmlClass umlClass);
    public virtual string get_Presentation();
    public sealed virtual bool get_IsNavigable();
    public sealed virtual OrderingKind get_Ordering();
    public sealed virtual AggregationKind get_Aggregation();
    public sealed virtual AssociationEndKind get_AssociationEndKind();
    public sealed virtual IAssociationEnd get_MainAssociationEnd();
    public sealed virtual bool get_IsStoredInObject();
    public sealed virtual bool get_IsDelayedFetch();
    public sealed virtual bool get_Persistent();
    public sealed virtual DeleteAction get_DeleteAction();
    public sealed virtual AssociationEndDefaultRegionMode get_DefaultRegionMode();
    public sealed virtual LinkFetchStrategy get_LinkFetchStrategy();
}
public class Eco.UmlRt.Impl.AttributeCollection : ModelElementCollectionBaseY`1<IAttribute> {
    private IFeature Eco.UmlRt.IFeatureCollection.Item { get; }
    private IStructuralFeature Eco.UmlRt.IStructuralFeatureCollection.Item { get; }
    private sealed virtual override IFeature Eco.UmlRt.IFeatureCollection.GetItemByName(string Name);
    private sealed virtual override IFeature Eco.UmlRt.IFeatureCollection.get_Item(int index);
    private sealed virtual override IStructuralFeature Eco.UmlRt.IStructuralFeatureCollection.GetItemByName(string Name);
    private sealed virtual override IStructuralFeature Eco.UmlRt.IStructuralFeatureCollection.get_Item(int index);
}
internal class Eco.UmlRt.Impl.BagTypeAdapter : CollectionTypeAdapter {
    public CollectionTypeKind Kind { get; }
    public BagTypeAdapter(ICollectionType BaseType);
    public virtual CollectionTypeKind get_Kind();
}
public class Eco.UmlRt.Impl.ClassCollection : ModelElementCollectionBaseY`1<IClass> {
    private static ClassCollection m_Empty;
    private IClassifier Eco.UmlRt.IClassifierCollection.Item { get; }
    public static ClassCollection Empty { get; }
    private static ClassCollection();
    private sealed virtual override IClassifier Eco.UmlRt.IClassifierCollection.GetItemByName(string Name);
    private sealed virtual override IClassifier Eco.UmlRt.IClassifierCollection.get_Item(int index);
    public static ClassCollection get_Empty();
}
public class Eco.UmlRt.Impl.ClassifierCollection : ClassifierCollectionBase`1<IClassifier> {
    private static ClassifierCollection m_Empty;
    public static ClassifierCollection Empty { get; }
    private static ClassifierCollection();
    public static ClassifierCollection get_Empty();
}
public class Eco.UmlRt.Impl.ClassifierCollectionBase`1 : ModelElementCollectionBaseY`1<T> {
    private IClassifier Eco.UmlRt.IClassifierCollection.Item { get; }
    private sealed virtual override IClassifier Eco.UmlRt.IClassifierCollection.GetItemByName(string Name);
    private sealed virtual override IClassifier Eco.UmlRt.IClassifierCollection.get_Item(int index);
}
public class Eco.UmlRt.Impl.ClassNameComparer : object {
    public sealed virtual int Compare(IClass x, IClass y);
    public int Compare(IModelElement x, IModelElement y);
}
[DefaultMemberAttribute("Item")]
public class Eco.UmlRt.Impl.CollectionBaseX`1 : object {
    private List`1<T> m_List;
    public T Item { get; }
    public bool IsSynchronized { get; }
    public object SyncRoot { get; }
    public int Count { get; }
    public virtual void Add(T Item);
    protected T BaseGetItem(int index);
    public T get_Item(int index);
    public bool Contains(T item);
    public sealed virtual void CopyTo(Array arr, int index);
    public sealed virtual bool get_IsSynchronized();
    public sealed virtual object get_SyncRoot();
    public sealed virtual IEnumerator GetEnumerator();
    private sealed virtual override IEnumerator`1<T> System.Collections.Generic.IEnumerable<T>.GetEnumerator();
    public void Sort(IComparer`1<T> comparer);
    public sealed virtual int get_Count();
}
[DefaultMemberAttribute("Item")]
public class Eco.UmlRt.Impl.CollectionBaseY`1 : object {
    private List`1<T> m_List;
    public T Item { get; }
    public bool IsSynchronized { get; }
    public object SyncRoot { get; }
    public int Count { get; }
    public virtual void Add(T Item);
    protected T BaseGetItem(int index);
    public sealed virtual T get_Item(int index);
    public sealed virtual bool Contains(T item);
    public sealed virtual void CopyTo(Array arr, int index);
    public sealed virtual bool get_IsSynchronized();
    public sealed virtual object get_SyncRoot();
    public sealed virtual IEnumerator GetEnumerator();
    private sealed virtual override IEnumerator`1<T> System.Collections.Generic.IEnumerable<T>.GetEnumerator();
    public void Sort(IComparer`1<T> comparer);
    public sealed virtual int get_Count();
}
internal class Eco.UmlRt.Impl.CollectionKinds : object {
    private IBagType m_BagType;
    private ICollectionType m_BaseType;
    private IOrderedSetType m_OrderedSetType;
    private ISequenceType m_SequenceType;
    private ISetType m_SetType;
    public ICollectionType CollectionType { get; }
    public IBagType BagType { get; }
    public ISetType SetType { get; }
    public ISequenceType SequenceType { get; }
    public IOrderedSetType OrderedSetType { get; }
    public CollectionKinds(ICollectionType baseType);
    public sealed virtual ICollectionType get_CollectionType();
    public sealed virtual IBagType get_BagType();
    public sealed virtual ISetType get_SetType();
    public sealed virtual ISequenceType get_SequenceType();
    public sealed virtual IOrderedSetType get_OrderedSetType();
}
internal abstract class Eco.UmlRt.Impl.CollectionTypeAdapter : SimpleUmlRtElement {
    private ICollectionType m_BaseType;
    public ClassifierType ClassifierType { get; }
    public ICollectionKinds CollectionKinds { get; }
    public ICollectionType CollectionType { get; }
    public IConstraintCollection Constraints { get; }
    public IEcoClassifier EcoClassifier { get; }
    public IClassifier ElementType { get; }
    public IFeatureCollection Features { get; }
    public bool IsAbstract { get; }
    public CollectionTypeKind Kind { get; }
    public string Name { get; }
    public Type ObjectType { get; }
    public IClassifierCollection SubTypes { get; }
    public IClassifierCollection SuperTypes { get; }
    public IEcoTypeSystem TypeSystem { get; }
    protected CollectionTypeAdapter(ICollectionType baseType, string name);
    public sealed virtual bool ConformsTo(IClassifier Classifier);
    public sealed virtual object ConvertAsObject(object value, IClassifier toType);
    public sealed virtual ClassifierType get_ClassifierType();
    public sealed virtual ICollectionKinds get_CollectionKinds();
    public sealed virtual ICollectionType get_CollectionType();
    public virtual IConstraintCollection get_Constraints();
    public sealed virtual IEcoClassifier get_EcoClassifier();
    public sealed virtual IClassifier get_ElementType();
    public sealed virtual IFeatureCollection get_Features();
    public sealed virtual bool get_IsAbstract();
    public abstract virtual CollectionTypeKind get_Kind();
    public virtual string get_Name();
    public sealed virtual Type get_ObjectType();
    public sealed virtual IClassifierCollection get_SubTypes();
    public sealed virtual IClassifierCollection get_SuperTypes();
    public sealed virtual IEcoTypeSystem get_TypeSystem();
    public sealed virtual bool IsA(IClassifier classifier);
    public sealed virtual IClassifier LeastCommonType(IClassifier classifier);
}
public class Eco.UmlRt.Impl.CollectionTypeImpl : SimpleUmlRtElementWithSystem {
    private ICollectionKinds m_CollectionKinds;
    private IClassifier m_ListElementTypeInfo;
    public IClassifier ElementType { get; }
    public IClassifier ListElementTypeInfo { get; }
    public ClassifierType ClassifierType { get; }
    public ICollectionKinds CollectionKinds { get; }
    public ICollectionType CollectionType { get; }
    public IEcoClassifier EcoClassifier { get; }
    public IFeatureCollection Features { get; }
    public bool IsAbstract { get; }
    public CollectionTypeKind Kind { get; }
    public Type ObjectType { get; }
    public IClassifierCollection SubTypes { get; }
    public IClassifierCollection SuperTypes { get; }
    public CollectionTypeImpl(IClassifier ListElementTypeInfo, IEcoTypeSystem SystemTypeInfo);
    public sealed virtual bool ConformsTo(IClassifier compareElement);
    public sealed virtual object ConvertAsObject(object value, IClassifier toType);
    public sealed virtual IClassifier get_ElementType();
    public IClassifier get_ListElementTypeInfo();
    public sealed virtual ClassifierType get_ClassifierType();
    public sealed virtual ICollectionKinds get_CollectionKinds();
    public sealed virtual ICollectionType get_CollectionType();
    public sealed virtual IEcoClassifier get_EcoClassifier();
    public sealed virtual IFeatureCollection get_Features();
    public sealed virtual bool get_IsAbstract();
    public sealed virtual CollectionTypeKind get_Kind();
    public sealed virtual Type get_ObjectType();
    public sealed virtual IClassifierCollection get_SubTypes();
    public sealed virtual IClassifierCollection get_SuperTypes();
    public sealed virtual bool IsA(IClassifier classifier);
    public sealed virtual IClassifier LeastCommonType(IClassifier classifier);
}
public class Eco.UmlRt.Impl.Constraint : SimpleUmlRtElement {
    private IExpression m_Body;
    private string m_Description;
    private bool m_IsAutoGenerated;
    private ErrorLevel m_ErrorLevel;
    private bool m_isDeleteConstraint;
    private string m_Id;
    private string m_constrainedTargetName;
    public IEcoConstraint EcoConstraint { get; }
    public IExpression Body { get; }
    public string Description { get; }
    public ErrorLevel ErrorLevel { get; }
    public bool IsAutoGenerated { get; }
    public bool IsDeleteConstraint { get; }
    public string ConstrainedTargetName { get; }
    public string Id { get; }
    public Constraint(string name, string expression, string description, ErrorLevel errorLevel, bool isAutoGenerated, bool isDeleteConstraint, string id, string constrainedTargetName);
    public sealed virtual IEcoConstraint get_EcoConstraint();
    public sealed virtual IExpression get_Body();
    public sealed virtual string get_Description();
    public sealed virtual ErrorLevel get_ErrorLevel();
    public sealed virtual bool get_IsAutoGenerated();
    public sealed virtual bool get_IsDeleteConstraint();
    public sealed virtual string get_ConstrainedTargetName();
    public sealed virtual string get_Id();
}
public class Eco.UmlRt.Impl.ConstraintCollection : ModelElementCollectionBaseY`1<IConstraint> {
    private static ConstraintCollection m_Empty;
    public static ConstraintCollection Empty { get; }
    private static ConstraintCollection();
    public static ConstraintCollection get_Empty();
}
[DefaultMemberAttribute("Item")]
public class Eco.UmlRt.Impl.DefaultedTaggedValueImpl : object {
    private ITaggedValueCollection m_DefaultValues;
    private Dictionary`2<string, ITaggedValue> m_Overrides;
    private TaggedValueCollectionImpl m_OtherValues;
    public int Count { get; }
    public ITaggedValue Item { get; }
    private object System.Collections.ICollection.SyncRoot { get; }
    private bool System.Collections.ICollection.IsSynchronized { get; }
    public DefaultedTaggedValueImpl(ITaggedValueCollection defaultValues);
    public sealed virtual int get_Count();
    public sealed virtual ITaggedValue get_Item(int index);
    public sealed virtual ITaggedValue GetItemByTag(string tag);
    public void SetValue(string tag, string value);
    private sealed virtual override void System.Collections.ICollection.CopyTo(Array array, int index);
    private sealed virtual override object System.Collections.ICollection.get_SyncRoot();
    private sealed virtual override bool System.Collections.ICollection.get_IsSynchronized();
    public sealed virtual IEnumerator GetEnumerator();
    public sealed virtual string ValueForTag(string tag, string defaultValue);
    public sealed virtual bool ValueForTagBoolean(string tag, bool defaultValue);
    public sealed virtual string ValueForTag(string tag);
    public void CollectCheckSumData(StringBuilder sb);
}
public abstract class Eco.UmlRt.Impl.DefaultTaggedValues : object {
    private static Dictionary`2<string, ITaggedValueCollection> C_Dictionary;
    private static TaggedValueCollectionImpl c_Model;
    private static TaggedValueCollectionImpl c_Package;
    private static TaggedValueCollectionImpl c_Class;
    private static TaggedValueCollectionImpl c_Association;
    private static TaggedValueCollectionImpl c_Attribute;
    private static TaggedValueCollectionImpl c_AssociationEnd;
    private static TaggedValueCollectionImpl c_Region;
    private static TaggedValueCollectionImpl c_State;
    private static TaggedValueCollectionImpl c_Method;
    private static TaggedValueCollectionImpl c_VACDefinition;
    private static TaggedValueCollectionImpl c_VACStep;
    private static DefaultTaggedValues();
    public static ITaggedValueCollection GetDefaultForUmlClassName(string name);
}
public class Eco.UmlRt.Impl.EcoTypeSystem : UmlRtElement {
    private static object C_AmbigousTypeMarker;
    private static char C_SpaceCharacter;
    private Dictionary`2<string, IClassifier> m_AllClassifiersByName;
    private Dictionary`2<string, IClass> m_AllClassesById;
    private Dictionary`2<string, object> m_AllClassifiersByShortName;
    private PackageCollection m_AllPackages;
    private AssociationCollection m_Associations;
    private List`1<string> m_InitializationLog;
    private List`1<Tuple`2<string, object>> m_InitializationLogWithContext;
    private bool m_IsBrowsable;
    private bool m_IsEcoified;
    private PackageCollection m_Packages;
    private IEcoPredefinedTypes m_PreDefinedTypes;
    private string m_RegionDefinitions;
    private SimpleTypeCollection m_SimpleTypes;
    private ClassCollection m_TopSortedClasses;
    private Dictionary`2<Type, IClassifier> m_TypeIndex;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
private bool <InitializeNullableStringsToNull>k__BackingField;
    private int m_CheckSum;
    private int m_CheckSumRelaxed;
    private ITupleType _ConstraintInstanceTupleType;
    private ITupleType _actionInstanceTupleType;
    public bool IsRunnable { get; }
    public bool IsBrowsable { get; }
    public string NonRunnableReason { get; }
    public Tuple`2[] ErrorsWithContext { get; }
    public String[] Errors { get; }
    public ClassCollection TopSortedClasses { get; }
    public IClassCollection AllClasses { get; }
    public SimpleTypeCollection SimpleTypes { get; }
    public IClassifierCollection AllDatatypes { get; }
    public AssociationCollection Associations { get; }
    public IAssociationCollection AllAssociations { get; }
    public IEcoPredefinedTypes PredefinedTypes { get; }
    public bool GenerateDefaultRegions { get; }
    public string RegionDefinitions { get; }
    public bool InitializeNullableStringsToNull { get; private set; }
    public IPackageCollection Packages { get; }
    public IPackageCollection AllPackages { get; }
    public int CheckSum { get; }
    public int CheckSumRelaxed { get; }
    public EcoTypeSystem(string name);
    private static EcoTypeSystem();
    protected virtual string GetUmlClassName();
    public sealed virtual void InitializationError(bool browsable, string message);
    public sealed virtual void InitializationError(bool browsable, string message, Object[] args);
    private void EnsureEcoified();
    public sealed virtual IClass GetClassById(string id);
    public sealed virtual IClassifier GetClassifierByName(string name);
    public sealed virtual IClassifier GetClassifierByType(Type t);
    private bool IsSystemAssemblyType(Type t);
    public sealed virtual IClass GetClassByType(Type t);
    public sealed virtual bool get_IsRunnable();
    public sealed virtual bool get_IsBrowsable();
    public sealed virtual string get_NonRunnableReason();
    public Tuple`2[] get_ErrorsWithContext();
    public sealed virtual String[] get_Errors();
    public ClassCollection get_TopSortedClasses();
    public sealed virtual IClassCollection get_AllClasses();
    public SimpleTypeCollection get_SimpleTypes();
    public sealed virtual IClassifierCollection get_AllDatatypes();
    public AssociationCollection get_Associations();
    public sealed virtual IAssociationCollection get_AllAssociations();
    public sealed virtual IEcoPredefinedTypes get_PredefinedTypes();
    public sealed virtual bool get_GenerateDefaultRegions();
    public sealed virtual string get_RegionDefinitions();
    [CompilerGeneratedAttribute]
public sealed virtual bool get_InitializeNullableStringsToNull();
    [CompilerGeneratedAttribute]
private void set_InitializeNullableStringsToNull(bool value);
    public sealed virtual IPackageCollection get_Packages();
    public sealed virtual IPackageCollection get_AllPackages();
    public void AddPackage(IPackage package);
    public void AddToAllPackages(IPackage package);
    public void PreEcoifySanityCheck();
    public void PostEcoifySanityCheck();
    private static bool EmbedAndNotMulti(IAssociationEnd ae);
    private void AddClassifier(IClassifier classifier);
    private void AddClassifier(IClassifier classifier, bool addShortName);
    internal void InstallShortName(IClassifier classifier, string shortName);
    public void SetTaggedValue(string tag, string value);
    public void Ecoify();
    public void AddCodeGenClassTypesToTypeIndex();
    public void PropagateStateMachines();
    public void InstallAssignConverter(Type fromType, Type toType, ITypeConverter converter);
    public void InstallConverter(Type fromType, Type toType, ITypeConverter converter);
    public ISimpleType GetEnsuredSimpleType(Type type_);
    public void AddSimpleType(SimpleType simpleType);
    public void AddClass(IClass class_);
    public string GetCheckSumData();
    public sealed virtual int get_CheckSum();
    public sealed virtual int get_CheckSumRelaxed();
    public sealed virtual ITupleType GetTupleType(string name, IList`1<ClassifierNamePair> parts);
    public sealed virtual ITupleType GetTupleType(IList`1<ClassifierNamePair> parts);
    public sealed virtual ITupleType GetConstraintInstanceTupleType();
    public sealed virtual ITupleType GetActionInstanceTupleType();
    public void CleanForFree();
}
public class Eco.UmlRt.Impl.EnumerationLiteral : SimpleUmlRtElement {
    private object m_EnumValue;
    private int m_IntegerValue;
    public object EnumValue { get; }
    public int IntegerValue { get; }
    public IEcoEnumerationLiteral EcoEnumerationLiteral { get; }
    public EnumerationLiteral(string name, object enumValue);
    public sealed virtual object get_EnumValue();
    public sealed virtual int get_IntegerValue();
    public sealed virtual IEcoEnumerationLiteral get_EcoEnumerationLiteral();
}
[DefaultMemberAttribute("Item")]
public class Eco.UmlRt.Impl.EnumerationLiteralCollection : object {
    private EnumerationLiteral[] m_Litterals;
    public IEnumerationLiteral Item { get; }
    public int Count { get; }
    public object SyncRoot { get; }
    public bool IsSynchronized { get; }
    public EnumerationLiteralCollection(IList`1<EnumerationLiteral> literals);
    public EnumerationLiteralCollection(Type enumType);
    public sealed virtual IEnumerationLiteral get_Item(int index);
    public sealed virtual void CopyTo(Array a, int index);
    public sealed virtual int get_Count();
    public sealed virtual object get_SyncRoot();
    public sealed virtual bool get_IsSynchronized();
    public sealed virtual IEnumerator GetEnumerator();
    private sealed virtual override IEnumerator`1<IEnumerationLiteral> System.Collections.Generic.IEnumerable<Eco.UmlRt.IEnumerationLiteral>.GetEnumerator();
}
public abstract class Eco.UmlRt.Impl.Feature : UmlRtElement {
    private IClassifier m_Owner;
    private ScopeKind m_OwnerScope;
    private VisibilityKind m_Visibility;
    public ScopeKind OwnerScope { get; public set; }
    public VisibilityKind Visibility { get; public set; }
    public IClassifier Owner { get; }
    public IEcoFeature EcoFeature { get; }
    public string Presentation { get; }
    public FeatureType FeatureType { get; }
    public Feature(IClassifier owner, string name);
    public sealed virtual ScopeKind get_OwnerScope();
    public void set_OwnerScope(ScopeKind value);
    public sealed virtual VisibilityKind get_Visibility();
    public void set_Visibility(VisibilityKind value);
    public sealed virtual IClassifier get_Owner();
    public sealed virtual IEcoFeature get_EcoFeature();
    public virtual string get_Presentation();
    public abstract virtual FeatureType get_FeatureType();
    public virtual void CollectCheckSumData(StringBuilder sb);
}
public class Eco.UmlRt.Impl.FeatureCollection : ModelElementCollectionBaseY`1<IFeature> {
    private static FeatureCollection m_Empty;
    public static FeatureCollection Empty { get; }
    private static FeatureCollection();
    public static FeatureCollection get_Empty();
    public IList`1<IFeature> OrderedByName();
}
internal class Eco.UmlRt.Impl.FeaturePropertyDescriptor : PropertyDescriptor {
    private IStructuralFeature m_Feature;
    public Type ComponentType { get; }
    public bool IsReadOnly { get; }
    public Type PropertyType { get; }
    public FeaturePropertyDescriptor(IStructuralFeature feature);
    public virtual bool CanResetValue(object component);
    public virtual Type get_ComponentType();
    private IFeatured GetFeatured(object component);
    public virtual object GetValue(object component);
    public virtual bool get_IsReadOnly();
    public virtual Type get_PropertyType();
    public virtual void ResetValue(object component);
    public virtual void SetValue(object component, object value);
    public virtual bool ShouldSerializeValue(object component);
    public virtual void AddValueChanged(object component, EventHandler handler);
    public virtual void RemoveValueChanged(object component, EventHandler handler);
}
public class Eco.UmlRt.Impl.FinalStateImpl : StateImpl {
    public bool IsFinalState { get; }
    public FinalStateImpl(RegionImpl container, string name, IErrorLogger errorLogger);
    public virtual bool get_IsFinalState();
}
public interface Eco.UmlRt.Impl.IErrorLogger {
    public abstract virtual void InitializationError(bool browsable, string message, Object[] args);
    public abstract virtual void InitializationError(bool browsable, string message);
}
public class Eco.UmlRt.Impl.InitialStateImpl : VertexImpl {
    public PseudostateKind Kind { get; }
    public InitialStateImpl(RegionImpl container, string name, IErrorLogger errorLogger);
    protected virtual string GetUmlClassName();
    public sealed virtual PseudostateKind get_Kind();
    public virtual void InitializePartialNameDictionary(PartialNameDictionary vertexNameDictionary, PartialNameDictionary regionNameDictionary);
    public virtual void PostEcoifySanityCheck(StateMachineImpl stateMachine);
}
public interface Eco.UmlRt.Impl.IStructuralFeatureCacheData {
    public object MemberPolicy { get; public set; }
    public abstract virtual object get_MemberPolicy();
    public abstract virtual void set_MemberPolicy(object value);
}
public class Eco.UmlRt.Impl.Method : Feature {
    private IActivity m_Implementation;
    private bool m_IsEcoCallable;
    private bool m_IsQuery;
    private MethodInfo m_MethodInfo;
    private ParameterCollection m_Parameters;
    private List`1<IMethod> m_Overloads;
    private IExpression m_Precondition;
    private IClassifier m_ReturnType;
    private TriggerCollection m_Triggers;
    public FeatureType FeatureType { get; }
    public bool IsQuery { get; public set; }
    public IParameterCollection Parameters { get; }
    public IList`1<IMethod> Overloads { get; }
    public IClassifier ReturnType { get; public set; }
    public IEcoMethod EcoMethod { get; }
    public MethodInfo MethodInfo { get; public set; }
    public bool IsTrigger { get; }
    public bool IsEcoCallable { get; public set; }
    public TriggerCollection Triggers { get; }
    private ITriggerCollection Eco.UmlRt.IMethod.Triggers { get; }
    public bool IsImplementedAsActivity { get; }
    public IActivity Implementation { get; }
    public IExpression Precondition { get; public set; }
    public Method(UmlClass owner, string name);
    protected virtual string GetUmlClassName();
    public virtual FeatureType get_FeatureType();
    public virtual void CollectCheckSumData(StringBuilder sb);
    public sealed virtual bool get_IsQuery();
    public void set_IsQuery(bool value);
    public sealed virtual IParameterCollection get_Parameters();
    public sealed virtual IList`1<IMethod> get_Overloads();
    public void AddOverload(IMethod method);
    public sealed virtual IClassifier get_ReturnType();
    public void set_ReturnType(IClassifier value);
    public sealed virtual IEcoMethod get_EcoMethod();
    public sealed virtual MethodInfo get_MethodInfo();
    public void set_MethodInfo(MethodInfo value);
    public sealed virtual bool get_IsTrigger();
    public sealed virtual bool get_IsEcoCallable();
    public void set_IsEcoCallable(bool value);
    public TriggerCollection get_Triggers();
    private sealed virtual override ITriggerCollection Eco.UmlRt.IMethod.get_Triggers();
    public sealed virtual bool get_IsImplementedAsActivity();
    public sealed virtual IActivity get_Implementation();
    public sealed virtual IExpression get_Precondition();
    public void set_Precondition(IExpression value);
    public void AddParameter(IParameter Parameter);
}
public class Eco.UmlRt.Impl.MethodCollection : ModelElementCollectionBaseY`1<IMethod> {
    private IFeature Eco.UmlRt.IFeatureCollection.Item { get; }
    private sealed virtual override IFeature Eco.UmlRt.IFeatureCollection.GetItemByName(string Name);
    private sealed virtual override IFeature Eco.UmlRt.IFeatureCollection.get_Item(int index);
}
public class Eco.UmlRt.Impl.MethodTriggerImpl : object {
    private IMethod m_Method;
    public IMethod Method { get; }
    public string Name { get; }
    public MethodTriggerImpl(Method Method);
    public sealed virtual IMethod get_Method();
    public sealed virtual string get_Name();
}
[DefaultMemberAttribute("Item")]
public class Eco.UmlRt.Impl.ModelElementCollectionBaseY`1 : object {
    private List`1<T> m_List;
    private Dictionary`2<string, T> m_NameDictionary;
    public T Item { get; }
    public bool IsSynchronized { get; }
    public object SyncRoot { get; }
    public int Count { get; }
    private IModelElement Eco.UmlRt.IModelElementCollection.Item { get; }
    protected T BaseGetItem(int index);
    public sealed virtual T get_Item(int index);
    public sealed virtual bool Contains(T item);
    public sealed virtual void CopyTo(Array arr, int index);
    public sealed virtual bool get_IsSynchronized();
    public sealed virtual object get_SyncRoot();
    public sealed virtual IEnumerator GetEnumerator();
    private sealed virtual override IEnumerator`1<T> System.Collections.Generic.IEnumerable<T>.GetEnumerator();
    public void Sort(IComparer`1<T> comparer);
    public sealed virtual int get_Count();
    public virtual void Add(T item);
    protected object BaseGetItemByName(string name);
    public sealed virtual T GetItemByName(string Name);
    private sealed virtual override IModelElement Eco.UmlRt.IModelElementCollection.GetItemByName(string Name);
    private sealed virtual override IModelElement Eco.UmlRt.IModelElementCollection.get_Item(int index);
    private sealed virtual override bool Eco.UmlRt.IModelElementCollection.Contains(IModelElement item);
}
public class Eco.UmlRt.Impl.ModelElementNamedCollectionBase : CollectionBaseX`1<IModelElement> {
    private Dictionary`2<string, IModelElement> m_NameDictionary;
    private IModelElement Eco.UmlRt.IModelElementCollection.Item { get; }
    public virtual void Add(IModelElement item);
    protected object BaseGetItemByName(string name);
    public IModelElement GetItemByName(string Name);
    private sealed virtual override IModelElement Eco.UmlRt.IModelElementCollection.GetItemByName(string Name);
    private sealed virtual override IModelElement Eco.UmlRt.IModelElementCollection.get_Item(int index);
    private sealed virtual override bool Eco.UmlRt.IModelElementCollection.Contains(IModelElement item);
    public IList`1<IModelElement> OrderedByName();
}
public class Eco.UmlRt.Impl.MultiplicityImpl : object {
    private string m_Multiplicity;
    private int m_Upper;
    private int m_Lower;
    private bool m_IsUnbounded;
    private bool m_IsSingle;
    private static Dictionary`2<string, IMultiplicity> L_Dictionary;
    private static IMultiplicity C_Single;
    private static IMultiplicity C_Multi;
    public static IMultiplicity Single { get; }
    public static IMultiplicity Multi { get; }
    private int Eco.UmlRt.IMultiplicity.Lower { get; }
    private int Eco.UmlRt.IMultiplicity.Upper { get; }
    private bool Eco.UmlRt.IMultiplicity.IsUnbounded { get; }
    private bool Eco.UmlRt.IMultiplicity.IsSingle { get; }
    public string Multiplicity { get; }
    private MultiplicityImpl(string multiplicity);
    private static MultiplicityImpl();
    public static IMultiplicity GetMultiplicity(string multiplicity);
    public static IMultiplicity get_Single();
    public static IMultiplicity get_Multi();
    private static int ParseWithDefault(string value, int defaultValue);
    private sealed virtual override int Eco.UmlRt.IMultiplicity.get_Lower();
    private sealed virtual override int Eco.UmlRt.IMultiplicity.get_Upper();
    private sealed virtual override bool Eco.UmlRt.IMultiplicity.get_IsUnbounded();
    private sealed virtual override bool Eco.UmlRt.IMultiplicity.get_IsSingle();
    public string get_Multiplicity();
}
public abstract class Eco.UmlRt.Impl.NamedTransportElement : object {
    private string m_Name;
    [XmlAttributeAttribute]
public string Name { get; public set; }
    public string get_Name();
    public void set_Name(string value);
}
public class Eco.UmlRt.Impl.NullType : UmlClass {
    public NullType(EcoTypeSystem typeSystem);
    public virtual bool IsA(IClassifier C2);
}
public class Eco.UmlRt.Impl.OclActivity : object {
    private string m_Body;
    private static OclActivity m_Empty;
    public string Body { get; }
    public string Language { get; }
    public static OclActivity Empty { get; }
    public OclActivity(string Body);
    private static OclActivity();
    public sealed virtual string get_Body();
    public sealed virtual string get_Language();
    public static OclActivity get_Empty();
}
public class Eco.UmlRt.Impl.OclExpression : object {
    private string m_Body;
    private static OclExpression m_Empty;
    public string Body { get; }
    public string Language { get; }
    public static OclExpression Empty { get; }
    public OclExpression(string Body);
    private static OclExpression();
    public sealed virtual string get_Body();
    public sealed virtual string get_Language();
    public static OclExpression get_Empty();
}
internal class Eco.UmlRt.Impl.OrderedSetTypeAdapter : CollectionTypeAdapter {
    public CollectionTypeKind Kind { get; }
    public OrderedSetTypeAdapter(ICollectionType BaseType);
    public virtual CollectionTypeKind get_Kind();
}
public class Eco.UmlRt.Impl.Package : UmlRtElementWithSystem {
    private AssociationCollection m_Associations;
    private ClassCollection m_Classes;
    private ModelElementNamedCollectionBase m_OwnedElements;
    private PackageCollection m_Packages;
    private UmlClass m_DefaultSuperClass;
    public IModelElementCollection OwnedElements { get; }
    public IEcoPackage EcoPackage { get; }
    public IClassCollection Classes { get; }
    public IPackageCollection Packages { get; }
    public IAssociationCollection Associations { get; }
    public UmlClass DefaultSuperClass { get; public set; }
    public Package(string name, IEcoTypeSystem typeSystem);
    public sealed virtual IModelElementCollection get_OwnedElements();
    public sealed virtual IEcoPackage get_EcoPackage();
    public sealed virtual IClassCollection get_Classes();
    public sealed virtual IPackageCollection get_Packages();
    public sealed virtual IAssociationCollection get_Associations();
    public UmlClass get_DefaultSuperClass();
    public void set_DefaultSuperClass(UmlClass value);
    private void AddOwnedElement(IModelElement element);
    protected virtual string GetUmlClassName();
    public void AddClass(UmlClass class_);
    public void AddAssociation(UmlAssociation Association);
    public void AddPackage(Package package);
    public virtual void CollectCheckSumData(StringBuilder sb);
}
public class Eco.UmlRt.Impl.PackageCollection : ModelElementCollectionBaseY`1<IPackage> {
    public IList`1<IPackage> OrderedByName();
}
public class Eco.UmlRt.Impl.Parameter : SimpleUmlRtElement {
    private ParameterDirectionKind m_Kind;
    private IClassifier m_Type;
    public ParameterDirectionKind Kind { get; public set; }
    public IClassifier Type { get; public set; }
    public Parameter(string name);
    public sealed virtual ParameterDirectionKind get_Kind();
    public void set_Kind(ParameterDirectionKind value);
    public sealed virtual IClassifier get_Type();
    public void set_Type(IClassifier value);
}
public class Eco.UmlRt.Impl.ParameterCollection : ModelElementCollectionBaseY`1<IParameter> {
}
public class Eco.UmlRt.Impl.PartialNameDictionary : object {
    private Dictionary`2<string, NameEntry> m_NameDictionary;
    private static Char[] SplitChars;
    private static PartialNameDictionary();
    public IModelElement ElementByFullName(string fullName);
    public IModelElement[] ElementsByPartialName(string partialName);
    public IModelElement ElementByPartialName(string partialName);
    public IModelElement EnsuredElementByPartialName(string partialName);
    public void Install(string fullName, IModelElement modelElement);
    private void InstallPartialNames(String[] names, FullNameEntry fullnameEntry);
}
internal class Eco.UmlRt.Impl.PredefinedTypes : object {
    private IDataType fBoolean;
    private IDataType fByte;
    private IDataType fBlob;
    private IDataType fChar;
    private IDataType fDateTime;
    private IDataType fDecimal;
    private IDataType fDouble;
    private ICollectionType fGenericList;
    private IDataType fInt16;
    private IDataType fInt32;
    private IDataType fInt64;
    private IClass fNullType;
    private IEnumerationType fOclSortDirection;
    private IEnumerationType fConstraintErrorLevel;
    private IDataType fSByte;
    private IDataType fSingle;
    private IDataType fString;
    private EcoTypeSystem fTypeSystem;
    private IDataType fTimeSpan;
    private IDataType fUInt16;
    private IDataType fUInt32;
    private IDataType fUInt64;
    private IDataType fGuid;
    private IDataType fViewModelReference;
    private IDataType fEncoding;
    public ICollectionType GenericCollectionType { get; }
    public IClass RootClassType { get; }
    public IEnumerationType OclSortDirection { get; }
    public IEnumerationType ConstraintErrorLevel { get; }
    public IDataType Boolean { get; }
    public IDataType Byte { get; }
    public IDataType Blob { get; }
    public IDataType Char { get; }
    public IDataType DateTime { get; }
    public IDataType Decimal { get; }
    public IDataType Double { get; }
    public IDataType Int16 { get; }
    public IDataType Int32 { get; }
    public IDataType Int64 { get; }
    public IClass NullType { get; }
    public IDataType SByte { get; }
    public IDataType Single { get; }
    public IDataType String_ { get; }
    public IDataType TimeSpan { get; }
    public IDataType UInt16 { get; }
    public IDataType UInt32 { get; }
    public IDataType UInt64 { get; }
    public IDataType Guid { get; }
    public IDataType ViewModelReference { get; }
    public PredefinedTypes(EcoTypeSystem typeSystem);
    public sealed virtual ICollectionType get_GenericCollectionType();
    public sealed virtual IClass get_RootClassType();
    public sealed virtual IEnumerationType get_OclSortDirection();
    public sealed virtual IEnumerationType get_ConstraintErrorLevel();
    public sealed virtual IDataType get_Boolean();
    public sealed virtual IDataType get_Byte();
    public sealed virtual IDataType get_Blob();
    public sealed virtual IDataType get_Char();
    public sealed virtual IDataType get_DateTime();
    public sealed virtual IDataType get_Decimal();
    public sealed virtual IDataType get_Double();
    public sealed virtual IDataType get_Int16();
    public sealed virtual IDataType get_Int32();
    public sealed virtual IDataType get_Int64();
    public sealed virtual IClass get_NullType();
    public sealed virtual IDataType get_SByte();
    public sealed virtual IDataType get_Single();
    public sealed virtual IDataType get_String_();
    public sealed virtual IDataType get_TimeSpan();
    public sealed virtual IDataType get_UInt16();
    public sealed virtual IDataType get_UInt32();
    public sealed virtual IDataType get_UInt64();
    public sealed virtual IDataType get_Guid();
    public sealed virtual IDataType get_ViewModelReference();
}
public class Eco.UmlRt.Impl.PrimitiveType : SimpleType {
    private Dictionary`2<IClassifier, ITypeConverter> m_AssignConverters;
    public IEcoPrimitiveType EcoPrimitiveType { get; }
    public ClassifierType ClassifierType { get; }
    public PrimitiveType(string name, Type objecctType, IEcoTypeSystem typeSystemem, object defaultContent);
    public void AddAssignConversion(IClassifier ToType, ITypeConverter Converter);
    protected ITypeConverter GetAssignConverter(IClassifier toType);
    public sealed virtual object AssignConvertAsObject(object value, IClassifier toType);
    public sealed virtual IEcoPrimitiveType get_EcoPrimitiveType();
    public virtual ClassifierType get_ClassifierType();
}
public class Eco.UmlRt.Impl.ReflectedEnumerationType : SimpleType {
    private EnumerationLiteralCollection m_Literals;
    public ClassifierType ClassifierType { get; }
    public IEnumerationLiteralCollection Literals { get; }
    public ReflectedEnumerationType(string name, Type objectType, IEcoTypeSystem typeSystem, object defaultContent);
    public virtual ClassifierType get_ClassifierType();
    public sealed virtual IEnumerationLiteralCollection get_Literals();
}
public class Eco.UmlRt.Impl.RegionCollection : ModelElementCollectionBaseY`1<IRegion> {
}
public class Eco.UmlRt.Impl.RegionImpl : UmlRtElement {
    private TransitionCollection m_Transitions;
    private VertexCollection m_Vertexes;
    private StateNamedCollection m_States;
    private StateCollection m_AllStates;
    private StateCollection m_AllSimpleStates;
    private StateMachineImpl m_StateMachine;
    private IRegionContainer m_Container;
    private IAttribute m_StateAttribute;
    private IPseudostate m_InitialState;
    private bool m_IsTopLevel;
    private bool m_NeedsInitialState;
    public IAttribute StateAttribute { get; public set; }
    public IStateMachine StateMachine { get; }
    public IStateCollection AllStates { get; }
    public IStateCollection AllSimpleStates { get; }
    public IRegionContainer Container { get; }
    public IEcoRegion EcoRegion { get; }
    public string FullStatemachineName { get; }
    public IPseudostate InitialState { get; }
    public IStateNamedCollection States { get; }
    public ITransitionCollection Transitions { get; }
    public IVertexCollection Vertexes { get; }
    public bool IsTopLevel { get; }
    public RegionImpl(IRegionContainer Container, string Name);
    public sealed virtual IAttribute get_StateAttribute();
    public void set_StateAttribute(IAttribute value);
    public void AddStates(StateCollection List, bool All);
    public virtual void CollectCheckSumData(StringBuilder sb);
    public void Ecoify(StateMachineImpl StateMachine, IAttribute StateAttribute, IRegion VariableDefiningRegion, IRegion TopSimpleRegion);
    public sealed virtual IStateMachine get_StateMachine();
    protected virtual string GetUmlClassName();
    public sealed virtual IStateCollection get_AllStates();
    public IStateCollection get_AllSimpleStates();
    public sealed virtual IRegionContainer get_Container();
    public sealed virtual IEcoRegion get_EcoRegion();
    public sealed virtual string get_FullStatemachineName();
    public sealed virtual IPseudostate get_InitialState();
    public sealed virtual IStateNamedCollection get_States();
    public sealed virtual ITransitionCollection get_Transitions();
    public sealed virtual IVertexCollection get_Vertexes();
    public void InitializePartialNameDictionary(PartialNameDictionary vertexNameDictionary, PartialNameDictionary regionNameDictionary);
    public void AddVertex(IVertex vertex, IErrorLogger errorLogger);
    public void AddTransition(ITransition transition);
    public sealed virtual bool get_IsTopLevel();
    public void PostEcoifySanityCheck(StateMachineImpl stateMachine);
}
[XmlTypeAttribute("Region")]
public class Eco.UmlRt.Impl.RegionTransport : NamedTransportElement {
    private TransitionTransport[] m_Transitions;
    private VertexTransport[] m_Vertexes;
    private string m_StateAttribute;
    public TransitionTransport[] Transitions { get; public set; }
    public VertexTransport[] Vertexes { get; public set; }
    [XmlAttributeAttribute]
[DefaultValueAttribute("")]
public string StateAttribute { get; public set; }
    public TransitionTransport[] get_Transitions();
    public void set_Transitions(TransitionTransport[] value);
    public VertexTransport[] get_Vertexes();
    public void set_Vertexes(VertexTransport[] value);
    public string get_StateAttribute();
    public void set_StateAttribute(string value);
}
public class Eco.UmlRt.Impl.RegularStateImpl : StateImpl {
    public RegularStateImpl(RegionImpl Container, string Name, IErrorLogger ErrorLogger);
}
internal class Eco.UmlRt.Impl.SequenceTypeAdapter : CollectionTypeAdapter {
    public CollectionTypeKind Kind { get; }
    public SequenceTypeAdapter(ICollectionType BaseType);
    public virtual CollectionTypeKind get_Kind();
}
internal class Eco.UmlRt.Impl.SetTypeAdapter : CollectionTypeAdapter {
    public CollectionTypeKind Kind { get; }
    public SetTypeAdapter(ICollectionType BaseType);
    public virtual CollectionTypeKind get_Kind();
}
public abstract class Eco.UmlRt.Impl.SimpleType : SimpleUmlRtElementWithSystem {
    private ICollectionType m_CollectionTypeInfo;
    private object m_DefaultContent;
    private Type m_ObjectType;
    private Dictionary`2<IClassifier, ITypeConverter> m_TypeConverters;
    public ClassifierType ClassifierType { get; }
    public ICollectionType CollectionType { get; }
    public object DefaultContent { get; }
    public IEcoClassifier EcoClassifier { get; }
    public IEcoSimpleType EcoSimpleType { get; }
    public IFeatureCollection Features { get; }
    public bool IsAbstract { get; }
    public Type ObjectType { get; }
    public IClassifierCollection SubTypes { get; }
    public IClassifierCollection SuperTypes { get; }
    public SimpleType(string name, Type objectType, IEcoTypeSystem typeSystem, object defaultContent);
    public void AddConversion(IClassifier toType, ITypeConverter converter);
    public sealed virtual object AsObjectFromStringNotNull(string value);
    public static IEnumerationLiteral GetLiteralFromString(IEnumerationType iEnumerationType, string p);
    public sealed virtual object AsObjectFromString(string value);
    public sealed virtual bool ConformsTo(IClassifier CompareElement);
    private SimpleType GetNonNullableType();
    private static IClassifier GetNonNullableType(IClassifier orgType);
    public sealed virtual object ConvertAsObject(object value, IClassifier toType);
    public abstract virtual ClassifierType get_ClassifierType();
    public sealed virtual ICollectionType get_CollectionType();
    public sealed virtual object get_DefaultContent();
    public sealed virtual IEcoClassifier get_EcoClassifier();
    public sealed virtual IEcoSimpleType get_EcoSimpleType();
    public sealed virtual IFeatureCollection get_Features();
    public sealed virtual bool get_IsAbstract();
    public sealed virtual Type get_ObjectType();
    public sealed virtual IClassifierCollection get_SubTypes();
    public sealed virtual IClassifierCollection get_SuperTypes();
    protected ITypeConverter GetTypeConverter(IClassifier toType);
    public sealed virtual bool IsA(IClassifier classifier);
    public sealed virtual IClassifier LeastCommonType(IClassifier classifier);
    public static object CreateBoxedFromString(Type objectType, string value, bool invariantCulture);
}
[DefaultMemberAttribute("Item")]
public class Eco.UmlRt.Impl.SimpleTypeCollection : ModelElementCollectionBaseY`1<ISimpleType> {
    private static SimpleTypeCollection m_Empty;
    private Dictionary`2<Type, ISimpleType> m_SimpleTypeByType;
    public static SimpleTypeCollection Empty { get; }
    private IClassifier Eco.UmlRt.IClassifierCollection.Item { get; }
    public ISimpleType Item { get; }
    private static SimpleTypeCollection();
    public static SimpleTypeCollection get_Empty();
    private sealed virtual override IClassifier Eco.UmlRt.IClassifierCollection.GetItemByName(string Name);
    private sealed virtual override IClassifier Eco.UmlRt.IClassifierCollection.get_Item(int index);
    public virtual void Add(ISimpleType item);
    public ISimpleType get_Item(Type type);
}
public abstract class Eco.UmlRt.Impl.SimpleUmlRtElement : UmlRtElementBase {
    public IConstraintCollection Constraints { get; }
    public ITaggedValueCollection TaggedValues { get; }
    public IPackage Package { get; }
    public SimpleUmlRtElement(string name);
    public virtual IConstraintCollection get_Constraints();
    public sealed virtual ITaggedValueCollection get_TaggedValues();
    public sealed virtual IPackage get_Package();
}
public abstract class Eco.UmlRt.Impl.SimpleUmlRtElementWithSystem : SimpleUmlRtElement {
    private IEcoTypeSystem m_typeSystem;
    public IEcoTypeSystem TypeSystem { get; }
    protected SimpleUmlRtElementWithSystem(string name, IEcoTypeSystem typeSystem);
    public sealed virtual IEcoTypeSystem get_TypeSystem();
}
public class Eco.UmlRt.Impl.StateCollection : CollectionBaseY`1<IState> {
}
public class Eco.UmlRt.Impl.StateImpl : VertexImpl {
    private IActivity m_Entry;
    private IActivity m_Exit;
    private RegionCollection m_Regions;
    private StateRepresentationPartCollection m_Representation;
    public IActivity Entry { get; public set; }
    public IActivity Exit { get; public set; }
    public IStateRepresentationPartCollection Representation { get; }
    public IEcoState EcoState { get; }
    public IRegionCollection Regions { get; }
    public bool IsOrthogonal { get; }
    public bool IsSimple { get; }
    public bool IsComposite { get; }
    public IEcoRegionContainer EcoRegionContainer { get; }
    public StateImpl(RegionImpl Container, string Name, IErrorLogger ErrorLogger);
    public sealed virtual IActivity get_Entry();
    public void set_Entry(IActivity value);
    public sealed virtual IActivity get_Exit();
    public void set_Exit(IActivity value);
    private void AddRepresenationPart(StateMachineImpl stateMachine, IAttribute attribute, string value);
    public virtual void Ecoify(StateMachineImpl stateMachine, IAttribute stateAttribute, IRegion variableDefiningRegion, IRegion topSimpleRegion);
    protected virtual string GetUmlClassName();
    public sealed virtual IStateRepresentationPartCollection get_Representation();
    public sealed virtual IEcoState get_EcoState();
    public sealed virtual IRegionCollection get_Regions();
    public virtual void InitializePartialNameDictionary(PartialNameDictionary vertexNameDictionary, PartialNameDictionary regionNameDictionary);
    public sealed virtual bool get_IsOrthogonal();
    public sealed virtual bool get_IsSimple();
    public sealed virtual bool get_IsComposite();
    public sealed virtual IEcoRegionContainer get_EcoRegionContainer();
    public sealed virtual bool Contains(IState state);
    public void AddRegion(IRegion region, IErrorLogger errorLogger);
    public virtual void CollectCheckSumData(StringBuilder sb);
}
public class Eco.UmlRt.Impl.StateMachineImpl : SimpleUmlRtElementWithSystem {
    private RegionCollection m_Regions;
    private PartialNameDictionary m_VertexNameDictionary;
    private PartialNameDictionary m_RegionNameDictionary;
    private Dictionary`2<string, ITrigger> m_TriggerByName;
    private IClass m_Class;
    private AttributeCollection m_AllStateAttributes;
    public IClass Class_ { get; }
    public string FullStatemachineName { get; }
    public IRegionCollection Regions { get; }
    public IEcoStateMachine EcoStateMachine { get; }
    public IAttributeCollection AllStateAttributes { get; }
    public IEcoRegionContainer EcoRegionContainer { get; }
    public StateMachineImpl(string name, IEcoTypeSystem ecoTypeSystem, IClass class_);
    public void Ecoify();
    public IAttribute GetStateAttribute(string Name, bool Ensure);
    public sealed virtual IClass get_Class_();
    public sealed virtual string get_FullStatemachineName();
    public sealed virtual IRegionCollection get_Regions();
    public sealed virtual void InitializationError(bool browsable, string message);
    public void InitializePartialNameDictionaries();
    public sealed virtual IVertex GetVertexByFullName(string fullName);
    public sealed virtual IVertex GetVertexByPartialName(string partialName);
    public sealed virtual IRegion GetRegionByPartialName(string partialName);
    public sealed virtual IRegion GetRegionByFullName(string fullName);
    public sealed virtual IEcoStateMachine get_EcoStateMachine();
    private ITrigger GetNewTrigger(string name, IClass c, string leafClassName);
    public sealed virtual ITrigger GetTriggerByName(string name);
    public IAttribute GetStateAttribute(IClass class_, string name, bool ensure);
    public VertexImpl GetVertexImplByFullName(string fullName);
    public sealed virtual void InitializationError(bool browsable, string message, Object[] args);
    public void PostEcoifySanityCheck();
    public sealed virtual IAttributeCollection get_AllStateAttributes();
    public void AddUsedStateAttrbute(IAttribute attribute);
    public sealed virtual IEcoRegionContainer get_EcoRegionContainer();
    public sealed virtual bool Contains(IState state);
    public void AddRegion(IRegion region, IErrorLogger errorLogger);
}
[XmlTypeAttribute("StateMachine")]
public class Eco.UmlRt.Impl.StateMachineTransport : RegionTransport {
}
public class Eco.UmlRt.Impl.StateNamedCollection : ModelElementCollectionBaseY`1<IState> {
}
public class Eco.UmlRt.Impl.StateRepresentationPartCollection : CollectionBaseY`1<IStateRepresentationPart> {
}
public class Eco.UmlRt.Impl.StateRepresentationPartImpl : object {
    private IAttribute m_Attribute;
    private object m_Value;
    public object Value { get; }
    public IAttribute Attribute { get; }
    public StateRepresentationPartImpl(IAttribute attribute, object value);
    public sealed virtual object get_Value();
    public sealed virtual IAttribute get_Attribute();
}
public class Eco.UmlRt.Impl.StdTypeConverterInstaller : object {
    public static void InstallGenericConverter(Type source, Type target, EcoTypeSystem TypeSystem);
    public static void InstallAssignConverter(Type source, Type target, EcoTypeSystem TypeSystem);
    public static void Install(EcoTypeSystem typeSystem);
}
public abstract class Eco.UmlRt.Impl.StructuralFeature : Feature {
    private ChangeableKind m_Changeability;
    private MethodInfo m_DeriveAndSubscribeMethod;
    private bool m_AutoDerived;
    private bool m_HasUserCode;
    private int m_IndexInAllStructuralFeatures;
    private bool m_IsEcoified;
    protected bool m_IsReverseDerived;
    private int m_LoopbackIndex;
    private IMultiplicity m_Multiplicity;
    private PropertyInfo m_PropertyInfo;
    private SaveAction m_SaveAction;
    private object m_MemberPolicy;
    private PropertyDescriptor m_PropertyDescriptor;
    public object MemberPolicy { get; public set; }
    public IMultiplicity Multiplicity { get; public set; }
    public ChangeableKind Changeability { get; public set; }
    public int IndexInAllStructuralFeatures { get; }
    public int LoopbackIndex { get; public set; }
    public SaveAction SaveAction { get; }
    public bool IsReverseDerived { get; }
    public bool HasUserCode { get; public set; }
    public MethodInfo DeriveAndSubscribeMethod { get; }
    public bool IsAutoDerived { get; }
    public PropertyInfo PropertyInfo { get; public set; }
    public PropertyDescriptor PropertyDescriptor { get; }
    protected StructuralFeature(UmlClass classImpl, string name);
    public sealed virtual object get_MemberPolicy();
    public sealed virtual void set_MemberPolicy(object value);
    private void EcoifiedError();
    protected void EnsureEcoified();
    public virtual void Ecoify(int idexInAllStructuralFeatures);
    public virtual IMultiplicity get_Multiplicity();
    public virtual void set_Multiplicity(IMultiplicity value);
    public sealed virtual ChangeableKind get_Changeability();
    public void set_Changeability(ChangeableKind value);
    public sealed virtual int get_IndexInAllStructuralFeatures();
    public sealed virtual int get_LoopbackIndex();
    public void set_LoopbackIndex(int value);
    public sealed virtual SaveAction get_SaveAction();
    public sealed virtual bool get_IsReverseDerived();
    public sealed virtual bool get_HasUserCode();
    public void set_HasUserCode(bool value);
    protected abstract virtual Type DerivationType();
    private void EnsureDerivationMethod();
    public sealed virtual MethodInfo get_DeriveAndSubscribeMethod();
    public sealed virtual bool get_IsAutoDerived();
    public sealed virtual PropertyInfo get_PropertyInfo();
    public void set_PropertyInfo(PropertyInfo value);
    public virtual void CollectCheckSumData(StringBuilder sb);
    public sealed virtual PropertyDescriptor get_PropertyDescriptor();
}
public class Eco.UmlRt.Impl.StructuralFeatureCollection : ModelElementCollectionBaseY`1<IStructuralFeature> {
    private static StructuralFeatureCollection m_Empty;
    public static StructuralFeatureCollection Empty { get; }
    private IFeature Eco.UmlRt.IFeatureCollection.Item { get; }
    private static StructuralFeatureCollection();
    public static StructuralFeatureCollection get_Empty();
    private sealed virtual override IFeature Eco.UmlRt.IFeatureCollection.GetItemByName(string Name);
    private sealed virtual override IFeature Eco.UmlRt.IFeatureCollection.get_Item(int index);
}
[DefaultMemberAttribute("Item")]
public class Eco.UmlRt.Impl.TaggedValueCollectionImpl : object {
    private List`1<ITaggedValue> m_List;
    private Dictionary`2<string, ITaggedValue> m_TVDictionary;
    private static int dictionaryLimit;
    private static TaggedValueCollectionImpl c_Empty;
    public bool IsSynchronized { get; }
    public object SyncRoot { get; }
    public static ITaggedValueCollection Empty { get; }
    public ITaggedValue Item { get; }
    public int Count { get; }
    private static TaggedValueCollectionImpl();
    public sealed virtual IEnumerator GetEnumerator();
    public sealed virtual bool get_IsSynchronized();
    public sealed virtual object get_SyncRoot();
    public sealed virtual void CopyTo(Array arr, int index);
    public static ITaggedValueCollection get_Empty();
    public void SetValue(string tag, string value);
    public void Add(string tag, string value);
    public void Remove(string tag);
    public sealed virtual ITaggedValue GetItemByTag(string tag);
    public sealed virtual ITaggedValue get_Item(int index);
    public sealed virtual int get_Count();
    public sealed virtual string ValueForTag(string tag, string defaultValue);
    public sealed virtual bool ValueForTagBoolean(string tag, bool defaultValue);
    public sealed virtual string ValueForTag(string tag);
}
public class Eco.UmlRt.Impl.TaggedValueImpl : object {
    private string m_Tag;
    private string m_Value;
    private static Dictionary`2<string, string> C_Strings;
    private string Eco.UmlRt.ITaggedValue.Tag { get; }
    private string Eco.UmlRt.ITaggedValue.Value { get; }
    public TaggedValueImpl(string tag, string value);
    private static TaggedValueImpl();
    private static string GetShared(string s);
    private sealed virtual override string Eco.UmlRt.ITaggedValue.get_Tag();
    private sealed virtual override string Eco.UmlRt.ITaggedValue.get_Value();
}
public class Eco.UmlRt.Impl.TransitionCollection : CollectionBaseY`1<ITransition> {
}
public class Eco.UmlRt.Impl.TransitionImpl : object {
    private IExpression m_Guard;
    private IVertex m_Source;
    private IVertex m_Target;
    private IRegion m_Region;
    private ITrigger m_Trigger;
    private IActivity m_Effect;
    public IRegion Region { get; }
    public IExpression Guard { get; public set; }
    public IVertex Source { get; }
    public IVertex Target { get; }
    public ITrigger Trigger { get; public set; }
    public IActivity Effect { get; public set; }
    public TransitionImpl(RegionImpl Region, VertexImpl Source, VertexImpl Target);
    public sealed virtual IRegion get_Region();
    public sealed virtual IExpression get_Guard();
    public void set_Guard(IExpression value);
    public sealed virtual IVertex get_Source();
    public sealed virtual IVertex get_Target();
    public sealed virtual ITrigger get_Trigger();
    public void set_Trigger(ITrigger value);
    public sealed virtual IActivity get_Effect();
    public void set_Effect(IActivity value);
    public void PostEcoifySanityCheck(StateMachineImpl stateMachine);
}
[XmlTypeAttribute("Transition")]
public class Eco.UmlRt.Impl.TransitionTransport : object {
    private string m_Guard;
    private string m_Source;
    private string m_Target;
    private string m_Trigger;
    private string m_Effect;
    private string m_GuardConstraints;
    [XmlAttributeAttribute]
[DefaultValueAttribute("")]
public string Guard { get; public set; }
    [XmlAttributeAttribute]
public string Source { get; public set; }
    [XmlAttributeAttribute]
public string Target { get; public set; }
    [XmlAttributeAttribute]
[DefaultValueAttribute("")]
public string Trigger { get; public set; }
    [XmlAttributeAttribute]
[DefaultValueAttribute("")]
public string Effect { get; public set; }
    [XmlAttributeAttribute]
[DefaultValueAttribute("")]
public string GuardConstraints { get; public set; }
    public string get_Guard();
    public void set_Guard(string value);
    public string get_Source();
    public void set_Source(string value);
    public string get_Target();
    public void set_Target(string value);
    public string get_Trigger();
    public void set_Trigger(string value);
    public string get_Effect();
    public void set_Effect(string value);
    public string get_GuardConstraints();
    public void set_GuardConstraints(string value);
}
public class Eco.UmlRt.Impl.TriggerCollection : CollectionBaseY`1<ITrigger> {
}
public class Eco.UmlRt.Impl.TuplePart : Feature {
    private IClassifier m_Type;
    private int m_IndexInAllStructuralFeatures;
    private PropertyDescriptor m_PropertyDescriptor;
    public IClassifier Type_ { get; }
    public FeatureType FeatureType { get; }
    public IMultiplicity Multiplicity { get; }
    public ChangeableKind Changeability { get; }
    public IEcoStructuralFeature EcoStructuralFeature { get; }
    public int IndexInAllStructuralFeatures { get; }
    public bool IsStoredInObject { get; }
    public bool Persistent { get; }
    public bool IsDerived { get; }
    public bool IsReverseDerived { get; }
    public bool IsDelayedFetch { get; }
    public bool CanHaveOldValue { get; }
    public bool HasUserCode { get; }
    public bool EncouragesOptimisticLockingOnDeletedOnly { get; }
    public int LoopbackIndex { get; }
    public SaveAction SaveAction { get; }
    public MethodInfo DeriveAndSubscribeMethod { get; }
    public bool IsAutoDerived { get; }
    public PropertyInfo PropertyInfo { get; }
    public PropertyDescriptor PropertyDescriptor { get; }
    public TuplePart(TupleType owner, IClassifier type, string name, int indexInAllStructuraFeatures);
    public sealed virtual IClassifier get_Type_();
    public virtual FeatureType get_FeatureType();
    protected virtual string GetUmlClassName();
    public sealed virtual IMultiplicity get_Multiplicity();
    public sealed virtual ChangeableKind get_Changeability();
    public sealed virtual IEcoStructuralFeature get_EcoStructuralFeature();
    public sealed virtual int get_IndexInAllStructuralFeatures();
    public sealed virtual bool get_IsStoredInObject();
    public sealed virtual bool get_Persistent();
    public sealed virtual bool get_IsDerived();
    public sealed virtual bool get_IsReverseDerived();
    public sealed virtual bool get_IsDelayedFetch();
    public sealed virtual bool get_CanHaveOldValue();
    public sealed virtual bool get_HasUserCode();
    public sealed virtual bool get_EncouragesOptimisticLockingOnDeletedOnly();
    public sealed virtual int get_LoopbackIndex();
    public sealed virtual SaveAction get_SaveAction();
    public sealed virtual MethodInfo get_DeriveAndSubscribeMethod();
    public sealed virtual bool get_IsAutoDerived();
    public sealed virtual PropertyInfo get_PropertyInfo();
    public sealed virtual PropertyDescriptor get_PropertyDescriptor();
}
public class Eco.UmlRt.Impl.TupleType : UmlRtElementBase {
    private Type m_ObjectType;
    private IEcoTypeSystem m_TypeSystem;
    private IPackage m_Package;
    private CollectionTypeImpl m_CollectionTypeInfo;
    private StructuralFeatureCollection m_AllStructuralFeatures;
    private FeatureCollection m_Features;
    private PropertyDescriptorCollection m_Properties;
    public IEcoTypeSystem TypeSystem { get; }
    public IConstraintCollection Constraints { get; }
    public ITaggedValueCollection TaggedValues { get; }
    public IPackage Package { get; public set; }
    public ClassifierType ClassifierType { get; }
    public ICollectionType CollectionType { get; }
    public IEcoClassifier EcoClassifier { get; }
    public IStructuralFeatureCollection AllStructuralFeatures { get; }
    public IFeatureCollection Features { get; }
    public bool IsAbstract { get; }
    public Type ObjectType { get; }
    public IClassifierCollection SubTypes { get; }
    public IClassifierCollection SuperTypes { get; }
    public PropertyDescriptorCollection Properties { get; }
    public TupleType(string name, Type objectType, IEcoTypeSystem typeSystem, Dictionary`2<Type, IClassifier> typeIndex);
    public TupleType(string name, IList`1<ClassifierNamePair> parts, IEcoTypeSystem typeSystem);
    public sealed virtual IEcoTypeSystem get_TypeSystem();
    public sealed virtual IConstraintCollection get_Constraints();
    public sealed virtual ITaggedValueCollection get_TaggedValues();
    public sealed virtual IPackage get_Package();
    public void set_Package(IPackage value);
    public sealed virtual ClassifierType get_ClassifierType();
    public sealed virtual ICollectionType get_CollectionType();
    public sealed virtual IEcoClassifier get_EcoClassifier();
    public sealed virtual IStructuralFeatureCollection get_AllStructuralFeatures();
    public sealed virtual IFeatureCollection get_Features();
    public sealed virtual bool get_IsAbstract();
    public sealed virtual Type get_ObjectType();
    public sealed virtual IClassifierCollection get_SubTypes();
    public sealed virtual IClassifierCollection get_SuperTypes();
    public sealed virtual bool IsA(IClassifier classifier);
    public sealed virtual IClassifier LeastCommonType(IClassifier classifier);
    public sealed virtual bool ConformsTo(IClassifier CompareElement);
    public sealed virtual object ConvertAsObject(object value, IClassifier toType);
    public sealed virtual PropertyDescriptorCollection get_Properties();
}
public class Eco.UmlRt.Impl.TupleTypeForActionInstance : TupleType {
    public TupleTypeForActionInstance(string name, IList`1<ClassifierNamePair> parts, IEcoTypeSystem typeSystem);
}
public class Eco.UmlRt.Impl.TupleTypeForConstraintInstance : TupleType {
    public TupleTypeForConstraintInstance(string name, IList`1<ClassifierNamePair> parts, IEcoTypeSystem typeSystem);
}
[DefaultMemberAttribute("Item")]
public class Eco.UmlRt.Impl.UmlAssociation : UmlRtElementWithSystem {
    private IClass m_AssociationClass;
    private AssociationEndNormal[] m_Ends;
    public IClass AssociationClass { get; public set; }
    private IAssociationEnd Eco.UmlRt.IAssociation.Item { get; }
    public AssociationEndNormal Item { get; }
    public int Count { get; }
    public IEcoAssociation EcoAssociation { get; }
    public bool IsDerived { get; }
    public bool IsReverseDerived { get; }
    public UmlAssociation(string name, EcoTypeSystem typeSystem);
    public sealed virtual IClass get_AssociationClass();
    public void set_AssociationClass(IClass value);
    private sealed virtual override IAssociationEnd Eco.UmlRt.IAssociation.get_Item(int index);
    public AssociationEndNormal get_Item(int index);
    public sealed virtual int get_Count();
    public sealed virtual IEcoAssociation get_EcoAssociation();
    public sealed virtual bool get_IsDerived();
    public sealed virtual bool get_IsReverseDerived();
    protected virtual string GetUmlClassName();
    public void SetEnd(int index, AssociationEndNormal associationEnd);
    public void SetFirstFreeEnd(AssociationEndNormal AssociationEnd);
    public void Validate();
    public virtual void CollectCheckSumData(StringBuilder sb);
}
public class Eco.UmlRt.Impl.UmlAttribute : StructuralFeature {
    private bool m_AllowNull;
    private string m_DefaultDbValue;
    private IExpression m_Initialvalue;
    private object m_InitialValueAsObject;
    private bool m_IsDelayedFetch;
    private bool m_IsDerived;
    private bool m_IsStateAttribute;
    private int m_Length;
    private int m_Precision;
    private int m_Scale;
    private bool m_MemberPersistent;
    private IClassifier m_Type;
    public IClassifier Type_ { get; }
    public IEcoStructuralFeature EcoStructuralFeature { get; }
    public IEcoAttribute EcoAttribute { get; }
    public IExpression InitialValue { get; public set; }
    public bool CanHaveOldValue { get; }
    public bool EncouragesOptimisticLockingOnDeletedOnly { get; }
    public bool IsDelayedFetch { get; }
    public bool IsDerived { get; }
    public bool Persistent { get; }
    public bool IsStateAttribute { get; }
    public bool IsStoredInObject { get; }
    public bool AllowNull { get; }
    public object InitialValueAsObject { get; }
    public int Length { get; }
    public int Scale { get; }
    public int Precision { get; }
    public string DefaultDbValue { get; }
    public FeatureType FeatureType { get; }
    public UmlAttribute(UmlClass umlClass, string name, IClassifier type);
    protected virtual string GetUmlClassName();
    public sealed virtual IClassifier get_Type_();
    protected virtual Type DerivationType();
    public sealed virtual IEcoStructuralFeature get_EcoStructuralFeature();
    public sealed virtual IEcoAttribute get_EcoAttribute();
    public sealed virtual IExpression get_InitialValue();
    public void set_InitialValue(IExpression value);
    public sealed virtual bool get_CanHaveOldValue();
    public sealed virtual bool get_EncouragesOptimisticLockingOnDeletedOnly();
    public sealed virtual bool get_IsDelayedFetch();
    public sealed virtual bool get_IsDerived();
    public sealed virtual bool get_Persistent();
    public sealed virtual bool get_IsStateAttribute();
    public sealed virtual bool get_IsStoredInObject();
    public sealed virtual bool get_AllowNull();
    public sealed virtual object get_InitialValueAsObject();
    public sealed virtual int get_Length();
    public sealed virtual int get_Scale();
    public sealed virtual int get_Precision();
    public sealed virtual string get_DefaultDbValue();
    public virtual FeatureType get_FeatureType();
    public virtual void Ecoify(int IndexInAllStructuralFeatures);
    public virtual void CollectCheckSumData(StringBuilder sb);
}
public class Eco.UmlRt.Impl.UmlClass : UmlRtElementWithSystem {
    private MethodCollection m_AllMethods;
    private StructuralFeatureCollection m_AllStructuralFeatures;
    private UmlAssociation m_Association;
    private string m_DefaultStringRepresentation;
    private String[] m_DerivationExpressions;
    private String[] m_DerivationExpressionsSET;
    private FeatureCollection m_Features;
    private int m_FirstOwnStructuralFeatureIndex;
    private bool m_GenerateDefaultRegion;
    private int m_InternalIndex;
    private bool m_IsAbstract;
    private bool m_IsEcoified;
    private bool m_IsImplicit;
    private ICollectionType m_ListTypeInfo;
    private Int32[] m_MemberIndexByLoopbackIndex;
    private Type m_ObjectType;
    private OptimisticLockingMode m_OptimisticLockingMode;
    private bool m_Persistent;
    private IStateMachine m_StateMachine;
    private ClassCollection m_SubClasses;
    private UmlClass m_SuperClassImpl;
    private bool m_Versioned;
    private bool m_VersionedDueToHistorySlave;
    private bool m_VersionedStopTimeOnAllTables;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
private bool <HasTriggers>k__BackingField;
    private PropertyDescriptorCollection m_Properties;
    public Type ObjectType { get; public set; }
    internal bool HasTriggers { get; private set; }
    public IClass SuperClass { get; }
    public IClassifierCollection SuperTypes { get; }
    public IClassifierCollection SubTypes { get; }
    public ClassCollection SubClassesImpl { get; }
    public IFeatureCollection Features { get; }
    public ClassifierType ClassifierType { get; }
    public IEcoClassifier EcoClassifier { get; }
    public IEcoClass EcoClass { get; }
    public ICollectionType CollectionType { get; }
    public bool IsAssociationClass { get; }
    public IAssociation Association { get; }
    public UmlAssociation AssociationInfo { get; public set; }
    public IStateMachine StateMachine { get; public set; }
    public bool IsAbstract { get; public set; }
    public string DefaultStringRepresentation { get; }
    public bool Versioned { get; }
    public bool VersionedStopTimeOnAllTables { get; }
    public IStructuralFeatureCollection AllStructuralFeatures { get; }
    public IMethodCollection AllMethods { get; }
    public int FirstOwnStructuralFeatureIndex { get; }
    public bool Persistent { get; }
    public bool IsLinkClass { get; }
    public bool IsImplicit { get; public set; }
    public int InternalIndex { get; }
    public bool GenerateDefaultRegion { get; }
    public OptimisticLockingMode OptimisticLockingMode { get; }
    public string Presentation { get; }
    public PropertyDescriptorCollection Properties { get; }
    public UmlClass(string name, IEcoTypeSystem typeSystem);
    public sealed virtual Type get_ObjectType();
    public void set_ObjectType(Type value);
    public void ReCreateListTypeInfo(IEcoTypeSystem typeSystem);
    [CompilerGeneratedAttribute]
internal bool get_HasTriggers();
    [CompilerGeneratedAttribute]
private void set_HasTriggers(bool value);
    public sealed virtual IClass get_SuperClass();
    public sealed virtual IClassifierCollection get_SuperTypes();
    public sealed virtual IClassifierCollection get_SubTypes();
    public ClassCollection get_SubClassesImpl();
    public sealed virtual IFeatureCollection get_Features();
    public sealed virtual ClassifierType get_ClassifierType();
    public sealed virtual IEcoClassifier get_EcoClassifier();
    public sealed virtual IEcoClass get_EcoClass();
    public sealed virtual ICollectionType get_CollectionType();
    public sealed virtual bool get_IsAssociationClass();
    public sealed virtual IAssociation get_Association();
    public UmlAssociation get_AssociationInfo();
    public void set_AssociationInfo(UmlAssociation value);
    public sealed virtual IStateMachine get_StateMachine();
    public void set_StateMachine(IStateMachine value);
    public sealed virtual bool get_IsAbstract();
    public void set_IsAbstract(bool value);
    public sealed virtual string get_DefaultStringRepresentation();
    public sealed virtual bool get_Versioned();
    public void MakeClassHistorySlaveVersionedInRuntime();
    public sealed virtual bool get_VersionedStopTimeOnAllTables();
    public sealed virtual IStructuralFeatureCollection get_AllStructuralFeatures();
    public sealed virtual IMethodCollection get_AllMethods();
    public sealed virtual int get_FirstOwnStructuralFeatureIndex();
    public sealed virtual bool get_Persistent();
    public sealed virtual bool get_IsLinkClass();
    public sealed virtual bool get_IsImplicit();
    public void set_IsImplicit(bool value);
    public sealed virtual int get_InternalIndex();
    public sealed virtual bool get_GenerateDefaultRegion();
    public sealed virtual OptimisticLockingMode get_OptimisticLockingMode();
    public virtual bool IsA(IClassifier classifier);
    public sealed virtual IClassifier LeastCommonType(IClassifier classifier);
    public sealed virtual bool ConformsTo(IClassifier compareElement);
    public sealed virtual object ConvertAsObject(object value, IClassifier toType);
    public sealed virtual string GetDerivationOcl(IStructuralFeature feature);
    public sealed virtual string GetDerivationOclSettable(IStructuralFeature feature);
    public sealed virtual int GetStructuralFeatureIndexByLoopbackIndex(int loopbackIndex);
    private void AddToAllStructralFeatures(IStructuralFeature feature);
    private void EcoifiedError();
    protected void EnsureEcoified();
    protected virtual string GetUmlClassName();
    public void Ecoify(int internalIndex);
    public sealed virtual string get_Presentation();
    public void EcoifyAllMembers();
    public void FixupVersioned();
    public void InitializeDerivationExpressions();
    public void InitializeLoopBackIndexLookup();
    private void AddMultiplicityConstraint(IAssociationEnd Role, string exprFragment, string moreless, int limit);
    private void AddMandatoryConstraint(IAssociationEnd Role);
    public void AddMultiplicityConstraints();
    public void AddFeature(IFeature feature);
    public void SetSuperClass(UmlClass SuperClass);
    public virtual void CollectCheckSumData(StringBuilder sb);
    public sealed virtual PropertyDescriptorCollection get_Properties();
}
public abstract class Eco.UmlRt.Impl.UmlRtElement : UmlRtElementBase {
    private string m_Id;
    private ConstraintCollection m_Constraints;
    private DefaultedTaggedValueImpl m_TaggedValueImpl;
    private IPackage m_Package;
    public string ModeledName { get; }
    public DefaultedTaggedValueImpl TaggedValueImpl { get; }
    public IConstraintCollection Constraints { get; }
    public ITaggedValueCollection TaggedValues { get; }
    public IPackage Package { get; public set; }
    public string Id { get; public set; }
    public UmlRtElement(string name);
    public virtual string get_ModeledName();
    public DefaultedTaggedValueImpl get_TaggedValueImpl();
    public sealed virtual IConstraintCollection get_Constraints();
    public sealed virtual ITaggedValueCollection get_TaggedValues();
    public sealed virtual IPackage get_Package();
    public void set_Package(IPackage value);
    public void AddConstraint(IConstraint Constraint, IErrorLogger ErrorLogger);
    public sealed virtual string get_Id();
    public void set_Id(string value);
    protected abstract virtual string GetUmlClassName();
    public virtual void CollectCheckSumData(StringBuilder sb);
}
public abstract class Eco.UmlRt.Impl.UmlRtElementBase : object {
    private string m_Name;
    public string Name { get; }
    public string ModeledName { get; }
    protected UmlRtElementBase(string name);
    public virtual string get_Name();
    public virtual string get_ModeledName();
    public sealed virtual bool IsSame(IModelElement value);
    public sealed virtual int GetIsSameHashCode();
    public virtual void CollectCheckSumData(StringBuilder sb);
}
public abstract class Eco.UmlRt.Impl.UmlRtElementWithSystem : UmlRtElement {
    private IEcoTypeSystem m_typeSystem;
    public IEcoTypeSystem TypeSystem { get; }
    protected UmlRtElementWithSystem(string name, IEcoTypeSystem typeSystem);
    public sealed virtual IEcoTypeSystem get_TypeSystem();
    public sealed virtual void InitializationError(bool Browsable, string Message, Object[] args);
    public sealed virtual void InitializationError(bool Browsable, string Message);
}
public abstract class Eco.UmlRt.Impl.UmlRtSupport : object {
    private static Dictionary`2<Type, Type> validAttributeTypes;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
private static bool <GlobalChecksumRelax>k__BackingField;
    public static bool GlobalChecksumRelax { get; internal set; }
    private static UmlRtSupport();
    public static bool IsValidEcoAttributeType(Type type);
    [CompilerGeneratedAttribute]
public static bool get_GlobalChecksumRelax();
    [CompilerGeneratedAttribute]
internal static void set_GlobalChecksumRelax(bool value);
    public static void RegisterValidEcoAttributeType(Type type);
    [ObsoleteAttribute("Use the method in Eco.Support.TypeSupport instead")]
public static bool IsNullable(Type type);
    [ObsoleteAttribute("Use the method in Eco.Support.TypeSupport instead")]
public static Type GetNullableParameterType(Type type);
    public static bool IsEffectivePersistent(IAssociation a);
    public static bool IsEffectivePersistent(IClass class_);
    public static bool IsEffectivePersistent(IClassifier classifier);
    private static bool HasPersistentSubClass(IClass class_);
}
public class Eco.UmlRt.Impl.VertexCollection : ModelElementCollectionBaseY`1<IVertex> {
}
public abstract class Eco.UmlRt.Impl.VertexImpl : UmlRtElement {
    private TransitionCollection m_Outgoing;
    private TransitionCollection m_Incoming;
    private IRegion m_Container;
    private IRegion m_TopSimpleRegion;
    private bool m_HasUntriggeredOutgoing;
    public TransitionCollection OutgoingImpl { get; }
    public TransitionCollection IncomingImpl { get; }
    public IRegion Container { get; }
    public ITransitionCollection Outgoing { get; }
    public ITransitionCollection Incoming { get; }
    public string FullStatemachineName { get; }
    public IEcoVertex EcoVertex { get; }
    public bool HasUntriggeredOutgoing { get; }
    public bool IsFinalState { get; }
    public IRegion TopSimpleRegion { get; }
    public VertexImpl(RegionImpl container, string name, IErrorLogger errorLogger);
    public TransitionCollection get_OutgoingImpl();
    public TransitionCollection get_IncomingImpl();
    public abstract virtual void InitializePartialNameDictionary(PartialNameDictionary vertexNameDictionary, PartialNameDictionary regionNameDictionary);
    public sealed virtual IRegion get_Container();
    public sealed virtual ITransitionCollection get_Outgoing();
    public sealed virtual ITransitionCollection get_Incoming();
    public sealed virtual string get_FullStatemachineName();
    public virtual void Ecoify(StateMachineImpl stateMachine, IAttribute stateAttribute, IRegion variableDefiningRegion, IRegion topSimpleRegion);
    public virtual void PostEcoifySanityCheck(StateMachineImpl stateMachine);
    public sealed virtual IEcoVertex get_EcoVertex();
    public sealed virtual bool get_HasUntriggeredOutgoing();
    public virtual bool get_IsFinalState();
    public sealed virtual IRegion get_TopSimpleRegion();
}
public enum Eco.UmlRt.Impl.VertexKind : Enum {
    public int value__;
    public static VertexKind RegularState;
    public static VertexKind InitialState;
    public static VertexKind FinalState;
}
[XmlTypeAttribute("Vertex")]
public class Eco.UmlRt.Impl.VertexTransport : NamedTransportElement {
    private VertexKind m_Kind;
    private RegionTransport[] m_Regions;
    private string m_Entry;
    private string m_Exit;
    private string m_Representation;
    [XmlAttributeAttribute]
public VertexKind Kind { get; public set; }
    public RegionTransport[] Regions { get; public set; }
    [XmlAttributeAttribute]
[DefaultValueAttribute("")]
public string Entry { get; public set; }
    [XmlAttributeAttribute]
[DefaultValueAttribute("")]
public string Exit { get; public set; }
    [XmlAttributeAttribute]
[DefaultValueAttribute("")]
public string Representation { get; public set; }
    public VertexKind get_Kind();
    public void set_Kind(VertexKind value);
    public RegionTransport[] get_Regions();
    public void set_Regions(RegionTransport[] value);
    public string get_Entry();
    public void set_Entry(string value);
    public string get_Exit();
    public void set_Exit(string value);
    public string get_Representation();
    public void set_Representation(string value);
}
[ToolboxBitmapAttribute("Eco.Wcf.Client.PersistenceMapperWCFClient")]
[ToolboxItemAttribute("True")]
public class Eco.Wcf.Client.PersistenceMapperWCFClient : PersistenceMapper {
    private IEcoTypeSystem typeSystem;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
private string <Uri>k__BackingField;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
private long <MaxReceivedMessageSize>k__BackingField;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
private string <EndpointConfigurationName>k__BackingField;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
private HttpClientCredentialType <ClientCredentialType>k__BackingField;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
private string <WCFServerUserName>k__BackingField;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
private string <WCFServerPassword>k__BackingField;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
private bool <UseWSHttp>k__BackingField;
    private WFCWrapProxyAndActSync proxy;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
private EventHandler`1<WCFFactoryCreatedArgs> WCFFactoryCreated;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
private EventHandler`1<WCFProvideBindingArgs> WCFProvideBinding;
    private int _FailedConnectionRetryTimes;
    private int _FailedConnectionRetryMaxSeconds;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
private DateTime <MDrivenServerHasAdvisedRestartOfClient>k__BackingField;
    public string Uri { get; public set; }
    public long MaxReceivedMessageSize { get; public set; }
    [DescriptionAttribute("When this is set, all the WCF settings, binding type, and enpoint address is read from the config file (app.config or web.config)")]
public string EndpointConfigurationName { get; public set; }
    [DescriptionAttribute("Set to None if you do not have server login, or use Basic if you do")]
public HttpClientCredentialType ClientCredentialType { get; public set; }
    public string WCFServerUserName { get; public set; }
    public string WCFServerPassword { get; public set; }
    [DescriptionAttribute("When true WSHttpBinding is used, else BasicHttpBinding")]
public bool UseWSHttp { get; public set; }
    public int FailedConnectionRetryTimes { get; public set; }
    public int FailedConnectionRetryMaxSeconds { get; public set; }
    private SyncVersion Eco.Persistence.IPersistenceMapper.CurrentSyncVersion { get; }
    private bool Eco.Persistence.IPersistenceMapper.SupportsSync { get; }
    public DateTime MDrivenServerHasAdvisedRestartOfClient { get; private set; }
    [CompilerGeneratedAttribute]
public string get_Uri();
    [CompilerGeneratedAttribute]
public void set_Uri(string value);
    [CompilerGeneratedAttribute]
public long get_MaxReceivedMessageSize();
    [CompilerGeneratedAttribute]
public void set_MaxReceivedMessageSize(long value);
    [CompilerGeneratedAttribute]
public string get_EndpointConfigurationName();
    [CompilerGeneratedAttribute]
public void set_EndpointConfigurationName(string value);
    [CompilerGeneratedAttribute]
public HttpClientCredentialType get_ClientCredentialType();
    [CompilerGeneratedAttribute]
public void set_ClientCredentialType(HttpClientCredentialType value);
    [CompilerGeneratedAttribute]
public string get_WCFServerUserName();
    [CompilerGeneratedAttribute]
public void set_WCFServerUserName(string value);
    [CompilerGeneratedAttribute]
public string get_WCFServerPassword();
    [CompilerGeneratedAttribute]
public void set_WCFServerPassword(string value);
    [CompilerGeneratedAttribute]
public bool get_UseWSHttp();
    [CompilerGeneratedAttribute]
public void set_UseWSHttp(bool value);
    public virtual IPersistenceMapper GetPersistenceMapper(ITypeSystemService typeSystemService);
    public virtual void ReturnPersistenceMapper(IPersistenceMapper persistenceMapper);
    public void Connect();
    private void proxy_Faulted(object sender, EventArgs e);
    [CompilerGeneratedAttribute]
public void add_WCFFactoryCreated(EventHandler`1<WCFFactoryCreatedArgs> value);
    [CompilerGeneratedAttribute]
public void remove_WCFFactoryCreated(EventHandler`1<WCFFactoryCreatedArgs> value);
    [CompilerGeneratedAttribute]
public void add_WCFProvideBinding(EventHandler`1<WCFProvideBindingArgs> value);
    [CompilerGeneratedAttribute]
public void remove_WCFProvideBinding(EventHandler`1<WCFProvideBindingArgs> value);
    private void EnsureProxy();
    public void set_FailedConnectionRetryTimes(int value);
    public int get_FailedConnectionRetryTimes();
    public void set_FailedConnectionRetryMaxSeconds(int value);
    public int get_FailedConnectionRetryMaxSeconds();
    private sealed virtual override SyncVersion Eco.Persistence.IPersistenceMapper.get_CurrentSyncVersion();
    private sealed virtual override void Eco.Persistence.IPersistenceMapper.Fetch(ObjectIdList idList, Datablock& datablock, Int32[] memberIdList, FetchStrategy fetchStrategy);
    private sealed virtual override void Eco.Persistence.IPersistenceMapper.FetchIDListWithCondition(AbstractCondition condition, ObjectIdList& result, int maxResults, int offset);
    private sealed virtual override void Eco.Persistence.IPersistenceMapper.GetChangesSince(SyncVersion syncVersion, SyncVersion[] excludeList, DBChangeCollection& changes, SyncVersion& lastSyncVersion);
    private sealed virtual override bool Eco.Persistence.IPersistenceMapper.get_SupportsSync();
    [CompilerGeneratedAttribute]
public DateTime get_MDrivenServerHasAdvisedRestartOfClient();
    [CompilerGeneratedAttribute]
private void set_MDrivenServerHasAdvisedRestartOfClient(DateTime value);
    private sealed virtual override void Eco.Persistence.IPersistenceMapper.TimeForVersion(int version, DateTime& clockTime);
    private sealed virtual override void Eco.Persistence.IPersistenceMapper.Update(Datablock datablock, UpdatePrecondition precondition, IdTranslationList& translationList, Int32& version, SyncVersion& syncVersion, UpdateResult& result);
    private sealed virtual override void Eco.Persistence.IPersistenceMapper.VersionForTime(DateTime clockTime, Int32& version);
    private sealed virtual override void Eco.Persistence.IPersistenceMapper.FetchDatablockWithCondition(AbstractCondition condition, Datablock& result, int maxResults, int offset);
}
public class Eco.Wcf.Client.WCFFactoryCreatedArgs : EventArgs {
    public ChannelFactory`1<IPersistenceMapperWCF> Factory;
}
public class Eco.Wcf.Client.WCFProvideBindingArgs : EventArgs {
    public Binding BindingToUse;
}
public class UndoConst.Units.UndoConst : object {
    public static string sNameInUse;
    public static string sInvalidBlockName;
    public static string sCannotMoveToTop;
    public static string sCannotMoveBlock;
    public static string sCannotRenameBlock;
    public static string sCannotMergeBlock;
    public static string sUnnamedBlockName;
    public static string sNoSuchBlock;
    public static string sNoBlockWithIndex;
    public static string sNotACallableOperation;
    public static string sUnmatchedCallToCommitTransaction;
    public static string sCannotCommit_SubtransactionRolledBack;
    public static string sUnmatchedCallToRollbackTransaction;
}
public class Units.BoldOclClasses : object {
    public static void BoldClearOclSymbolParameters(TBoldOclSymbolParameters& p);
}
public class Units.BoldOclEvaluator : object {
    public static int CompareElements(List`1<IElement> List1, List`1<IElement> List2);
    public static void DoSortList(TBoldOclIteration Node, IElementCollection BoldList, List`1<List`1<IElement>> SortKeys, TBoldOCLIteratorSpecifier Order);
}
public class Units.BoldOclLightWeightNodeMaker : object {
    public static bool MainRolePersistent(IStructuralFeature Member);
}
