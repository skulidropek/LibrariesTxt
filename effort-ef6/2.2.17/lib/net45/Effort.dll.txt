public class Effort.DataLoaders.CachingDataLoader : object {
    private static string WrappedType;
    private static string WrappedArgument;
    private IDataLoader wrappedDataLoader;
    private bool locking;
    public IDataLoader WrappedDataLoader { get; }
    private string Effort.DataLoaders.IDataLoader.Argument { get; private set; }
    public CachingDataLoader(IDataLoader wrappedDataLoader);
    public CachingDataLoader(IDataLoader wrappedDataLoader, bool locking);
    public IDataLoader get_WrappedDataLoader();
    private sealed virtual override string Effort.DataLoaders.IDataLoader.get_Argument();
    private sealed virtual override void Effort.DataLoaders.IDataLoader.set_Argument(string value);
    public sealed virtual ITableDataLoaderFactory CreateTableDataLoaderFactory();
}
public class Effort.DataLoaders.CachingTableDataLoader : object {
    private Object[][] data;
    public CachingTableDataLoader(ITableDataLoader tableDataLoader);
    public sealed virtual IEnumerable`1<Object[]> GetData();
}
public class Effort.DataLoaders.CachingTableDataLoaderFactory : object {
    private IDataLoader wrappedDataLoader;
    private ITableDataLoaderFactory wrappedTableDataLoaderFactory;
    private IDataLoaderConfigurationLatch latch;
    private ICachingTableDataLoaderStore dataStore;
    public CachingTableDataLoaderFactory(IDataLoader wrappedDataLoader);
    public CachingTableDataLoaderFactory(IDataLoader wrappedDataLoader, bool locking);
    internal CachingTableDataLoaderFactory(IDataLoader wrappedDataLoader, IDataLoaderConfigurationLatch latch, ICachingTableDataLoaderStore dataStore);
    public sealed virtual ITableDataLoader CreateTableDataLoader(TableDescription table);
    public sealed virtual void Dispose();
    private static IDataLoaderConfigurationLatch CreateLatch(IDataLoader dataLoader);
    private CachingTableDataLoader CreateCachedData(TableDescription table);
}
internal class Effort.DataLoaders.CachingTableDataLoaderStoreProxy : object {
    public sealed virtual CachingTableDataLoader GetCachedData(CachingTableDataLoaderKey key, Func`1<CachingTableDataLoader> factoryMethod);
    public sealed virtual bool Contains(CachingTableDataLoaderKey key);
}
public class Effort.DataLoaders.ColumnDescription : object {
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    [CompilerGeneratedAttribute]
private Type <Type>k__BackingField;
    public string Name { get; private set; }
    public Type Type { get; private set; }
    internal ColumnDescription(string name, Type type);
    [CompilerGeneratedAttribute]
public string get_Name();
    [CompilerGeneratedAttribute]
private void set_Name(string value);
    [CompilerGeneratedAttribute]
public Type get_Type();
    [CompilerGeneratedAttribute]
private void set_Type(Type value);
}
public class Effort.DataLoaders.CsvDataLoader : object {
    private string path;
    public string ContainerFolderPath { get; }
    private string Effort.DataLoaders.IDataLoader.Argument { get; private set; }
    public CsvDataLoader(string path);
    public string get_ContainerFolderPath();
    private sealed virtual override string Effort.DataLoaders.IDataLoader.get_Argument();
    private sealed virtual override void Effort.DataLoaders.IDataLoader.set_Argument(string value);
    public sealed virtual ITableDataLoaderFactory CreateTableDataLoaderFactory();
}
public class Effort.DataLoaders.CsvTableDataLoader : TableDataLoaderBase {
    private IFileReference file;
    private IValueConverter valueConverter;
    public CsvTableDataLoader(IFileReference file, TableDescription table);
    [IteratorStateMachineAttribute("Effort.DataLoaders.CsvTableDataLoader/<GetData>d__3")]
public virtual IEnumerable`1<Object[]> GetData();
    protected virtual IDataReader CreateDataReader();
    protected virtual object ConvertValue(object value, Type type);
    [CompilerGeneratedAttribute]
[DebuggerHiddenAttribute]
private IEnumerable`1<Object[]> <>n__0();
}
internal class Effort.DataLoaders.CsvTableDataLoaderFactory : object {
    private FileSource source;
    public CsvTableDataLoaderFactory(FileSource source);
    public sealed virtual ITableDataLoader CreateTableDataLoader(TableDescription table);
    private static string CreateName(String[] args);
    public sealed virtual void Dispose();
}
internal class Effort.DataLoaders.CsvValueConverter : object {
    public sealed virtual object ConvertValue(object value, Type type);
    private static string ResolveEscapeCharacters(string value);
}
internal class Effort.DataLoaders.DataLoaderConfigurationLatchProxy : object {
    private bool aquired;
    private DataLoaderConfigurationKey key;
    private DataLoaderConfigurationLatch latch;
    public DataLoaderConfigurationLatchProxy(DataLoaderConfigurationKey key);
    protected virtual override void Finalize();
    public sealed virtual void Acquire();
    public sealed virtual void Release();
    private sealed virtual override void System.IDisposable.Dispose();
    private void Dispose(bool disposing);
}
public class Effort.DataLoaders.EmptyDataLoader : object {
    [CompilerGeneratedAttribute]
private string <Effort.DataLoaders.IDataLoader.Argument>k__BackingField;
    private string Effort.DataLoaders.IDataLoader.Argument { get; private set; }
    [CompilerGeneratedAttribute]
private sealed virtual override string Effort.DataLoaders.IDataLoader.get_Argument();
    [CompilerGeneratedAttribute]
private sealed virtual override void Effort.DataLoaders.IDataLoader.set_Argument(string value);
    public sealed virtual ITableDataLoaderFactory CreateTableDataLoaderFactory();
}
public class Effort.DataLoaders.EmptyTableDataLoader : object {
    [IteratorStateMachineAttribute("Effort.DataLoaders.EmptyTableDataLoader/<GetData>d__0")]
public sealed virtual IEnumerable`1<Object[]> GetData();
}
public class Effort.DataLoaders.EmptyTableDataLoaderFactory : object {
    public sealed virtual ITableDataLoader CreateTableDataLoader(TableDescription table);
    public sealed virtual void Dispose();
}
public class Effort.DataLoaders.EntityDataLoader : object {
    private string entityConnectionString;
    private string Effort.DataLoaders.IDataLoader.Argument { get; private set; }
    public EntityDataLoader(string entityConnectionString);
    private sealed virtual override string Effort.DataLoaders.IDataLoader.get_Argument();
    private sealed virtual override void Effort.DataLoaders.IDataLoader.set_Argument(string value);
    public sealed virtual ITableDataLoaderFactory CreateTableDataLoaderFactory();
    [CompilerGeneratedAttribute]
private EntityConnection <CreateTableDataLoaderFactory>b__6_0();
}
public class Effort.DataLoaders.EntityTableDataLoader : TableDataLoaderBase {
    private EntityConnection connection;
    private MetadataWorkspace workspace;
    private EntitySet entitySet;
    public EntityTableDataLoader(EntityConnection connection, TableDescription table);
    protected virtual IDataReader CreateDataReader();
    protected virtual object ConvertValue(object value, Type type);
}
public class Effort.DataLoaders.EntityTableDataLoaderFactory : object {
    private Func`1<EntityConnection> connectionFactory;
    private EntityConnection connection;
    public EntityTableDataLoaderFactory(Func`1<EntityConnection> connectionFactory);
    public sealed virtual ITableDataLoader CreateTableDataLoader(TableDescription table);
    public sealed virtual void Dispose();
}
public class Effort.DataLoaders.FileSource : object {
    private string path;
    private IFileProvider provider;
    public bool IsValid { get; }
    public string Path { get; }
    public FileSource(string path);
    public bool get_IsValid();
    public string get_Path();
    public IFileReference GetFile(string name);
    private IFileProvider GetProvider(string path);
}
internal interface Effort.DataLoaders.ICachingTableDataLoaderStore {
    public abstract virtual CachingTableDataLoader GetCachedData(CachingTableDataLoaderKey key, Func`1<CachingTableDataLoader> factoryMethod);
    public abstract virtual bool Contains(CachingTableDataLoaderKey key);
}
public interface Effort.DataLoaders.IDataLoader {
    public string Argument { get; public set; }
    public abstract virtual string get_Argument();
    public abstract virtual void set_Argument(string value);
    public abstract virtual ITableDataLoaderFactory CreateTableDataLoaderFactory();
}
internal interface Effort.DataLoaders.IDataLoaderConfigurationLatch {
    public abstract virtual void Acquire();
    public abstract virtual void Release();
}
public interface Effort.DataLoaders.IFileReference {
    public bool Exists { get; }
    public abstract virtual Stream Open();
    public abstract virtual bool get_Exists();
}
internal class Effort.DataLoaders.Internal.FileSystemFileProvider : object {
    private DirectoryInfo directory;
    public bool IsValid { get; }
    public FileSystemFileProvider(Uri path);
    public sealed virtual IFileReference GetFile(string name);
    public sealed virtual bool get_IsValid();
}
internal class Effort.DataLoaders.Internal.FileSystemFileReference : object {
    private FileInfo file;
    public bool Exists { get; }
    public FileSystemFileReference(FileInfo file);
    public sealed virtual Stream Open();
    public sealed virtual bool get_Exists();
}
internal interface Effort.DataLoaders.Internal.IFileProvider {
    public bool IsValid { get; }
    public abstract virtual IFileReference GetFile(string name);
    public abstract virtual bool get_IsValid();
}
internal class Effort.DataLoaders.Internal.InvalidFileProvider : object {
    public bool IsValid { get; }
    public sealed virtual IFileReference GetFile(string name);
    public sealed virtual bool get_IsValid();
}
internal class Effort.DataLoaders.Internal.ResourceFileProvider : object {
    private bool valid;
    private Assembly assembly;
    private string resourcePath;
    public bool IsValid { get; }
    public ResourceFileProvider(Uri path);
    public sealed virtual IFileReference GetFile(string name);
    public sealed virtual bool get_IsValid();
    [CompilerGeneratedAttribute]
private bool <.ctor>b__3_3(string x);
}
internal class Effort.DataLoaders.Internal.ResourceFileReference : object {
    private Assembly assembly;
    private string path;
    public bool Exists { get; }
    public ResourceFileReference(Assembly assembly, string path);
    public sealed virtual Stream Open();
    public sealed virtual bool get_Exists();
}
public interface Effort.DataLoaders.ITableDataLoader {
    public abstract virtual IEnumerable`1<Object[]> GetData();
}
public interface Effort.DataLoaders.ITableDataLoaderFactory {
    public abstract virtual ITableDataLoader CreateTableDataLoader(TableDescription table);
}
internal interface Effort.DataLoaders.IValueConverter {
    public abstract virtual object ConvertValue(object value, Type type);
}
public class Effort.DataLoaders.ObjectData : object {
    private IDictionary`2<string, IEnumerable> tables;
    private Func`2<string, string> generateTableName;
    [CompilerGeneratedAttribute]
private Guid <Identifier>k__BackingField;
    internal Guid Identifier { get; }
    [CompilerGeneratedAttribute]
internal virtual Guid get_Identifier();
    public ObjectDataTable`1<T> Table(string tableName);
    internal bool HasTable(string tableName);
    internal Type TableType(string tableName);
    internal object GetTable(string tableName);
    internal string FindWithEntitySet(EntitySet entitySet);
}
public class Effort.DataLoaders.ObjectDataLoader : object {
    private static ConcurrentDictionary`2<Guid, ObjectData> DataCollection;
    [CompilerGeneratedAttribute]
private string <Argument>k__BackingField;
    public string Argument { get; public set; }
    public ObjectDataLoader(ObjectData data);
    private static ObjectDataLoader();
    [CompilerGeneratedAttribute]
public sealed virtual string get_Argument();
    [CompilerGeneratedAttribute]
public sealed virtual void set_Argument(string value);
    public sealed virtual ITableDataLoaderFactory CreateTableDataLoaderFactory();
}
internal class Effort.DataLoaders.ObjectDataLoaderFactory : object {
    private static Type LoaderType;
    private ObjectData data;
    public ObjectDataLoaderFactory(ObjectData data);
    private static ObjectDataLoaderFactory();
    public sealed virtual void Dispose();
    public sealed virtual ITableDataLoader CreateTableDataLoader(TableDescription table);
}
[DefaultMemberAttribute("Item")]
public class Effort.DataLoaders.ObjectDataTable`1 : object {
    private IList`1<T> list;
    private IDictionary`2<Type, string> discriminators;
    [CompilerGeneratedAttribute]
private string <DiscriminatorColumn>k__BackingField;
    public string DiscriminatorColumn { get; public set; }
    public T Item { get; public set; }
    public int Count { get; }
    public bool IsReadOnly { get; }
    [CompilerGeneratedAttribute]
public string get_DiscriminatorColumn();
    [CompilerGeneratedAttribute]
public void set_DiscriminatorColumn(string value);
    public void AddDiscriminator(string discriminator);
    internal string GetDiscriminator(T item);
    public sealed virtual T get_Item(int index);
    public sealed virtual void set_Item(int index, T value);
    public sealed virtual int get_Count();
    public sealed virtual bool get_IsReadOnly();
    public sealed virtual IEnumerator`1<T> GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    public sealed virtual void Add(T item);
    public sealed virtual void Clear();
    public sealed virtual bool Contains(T item);
    public sealed virtual void CopyTo(T[] array, int arrayIndex);
    public sealed virtual bool Remove(T item);
    public sealed virtual int IndexOf(T item);
    public sealed virtual void Insert(int index, T item);
    public sealed virtual void RemoveAt(int index);
}
internal static class Effort.DataLoaders.ObjectLoader : object {
    [IteratorStateMachineAttribute("Effort.DataLoaders.ObjectLoader/<Load>d__0")]
public static IEnumerable`1<object> Load(ITableDataLoaderFactory loaderFactory, DbTableInfo table);
    private static object ConvertTimestamp(object obj);
    private static object ConvertBinary(object obj);
}
internal class Effort.DataLoaders.ObjectTableDataLoader`1 : object {
    private static BindingFlags PropertyFlags;
    private TableDescription description;
    private ObjectDataTable`1<T> table;
    private Lazy`1<Func`2<T, Object[]>> formatter;
    public ObjectTableDataLoader`1(TableDescription description, ObjectDataTable`1<T> table);
    protected Func`2<T, Object[]> CreateFormatter();
    private static PropertyInfo GetProperty(Type parentType, ColumnDescription column);
    private string GetDiscriminator(T item);
    private Expression ToExpression(ParameterExpression parameter, PropertyInfo property, ColumnDescription column);
    private static Expression CastExpression(Expression expression);
    private static bool MatchColumnAttribute(PropertyInfo property, ColumnDescription column);
    public sealed virtual IEnumerable`1<Object[]> GetData();
}
public abstract class Effort.DataLoaders.TableDataLoaderBase : object {
    private TableDescription table;
    protected TableDescription Table { get; }
    public TableDataLoaderBase(TableDescription table);
    protected TableDescription get_Table();
    [IteratorStateMachineAttribute("Effort.DataLoaders.TableDataLoaderBase/<GetData>d__4")]
public virtual IEnumerable`1<Object[]> GetData();
    protected abstract virtual IDataReader CreateDataReader();
    protected virtual object ConvertValue(object value, Type type);
}
public class Effort.DataLoaders.TableDescription : object {
    [CompilerGeneratedAttribute]
private DbTableInfo <TableInfo>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Schema>k__BackingField;
    [CompilerGeneratedAttribute]
private ReadOnlyCollection`1<ColumnDescription> <Columns>k__BackingField;
    public DbTableInfo TableInfo { get; public set; }
    public string Name { get; private set; }
    public string Schema { get; public set; }
    public ReadOnlyCollection`1<ColumnDescription> Columns { get; private set; }
    internal TableDescription(DbTableInfo dbTableInfo, string schema, string name, IEnumerable`1<ColumnDescription> columns);
    internal TableDescription(string schema, string name, IEnumerable`1<ColumnDescription> columns);
    internal TableDescription(string name, IEnumerable`1<ColumnDescription> columns);
    [CompilerGeneratedAttribute]
public DbTableInfo get_TableInfo();
    [CompilerGeneratedAttribute]
public void set_TableInfo(DbTableInfo value);
    [CompilerGeneratedAttribute]
public string get_Name();
    [CompilerGeneratedAttribute]
private void set_Name(string value);
    [CompilerGeneratedAttribute]
public string get_Schema();
    [CompilerGeneratedAttribute]
public void set_Schema(string value);
    [CompilerGeneratedAttribute]
public ReadOnlyCollection`1<ColumnDescription> get_Columns();
    [CompilerGeneratedAttribute]
private void set_Columns(ReadOnlyCollection`1<ColumnDescription> value);
}
public static class Effort.DbConnectionFactory : object {
    public static int LargePropertyCount { get; public set; }
    private static DbConnectionFactory();
    public static int get_LargePropertyCount();
    public static void set_LargePropertyCount(int value);
    public static EffortConnection CreatePersistent(string instanceId, IDataLoader dataLoader);
    public static EffortConnection CreatePersistent(string instanceId);
    public static EffortConnection CreateTransient(IDataLoader dataLoader);
    public static EffortConnection CreateTransient();
    private static EffortConnection Create(string instanceId, IDataLoader dataLoader);
}
public static class Effort.EntityConnectionFactory : object {
    private static EntityConnectionFactory();
    public static EntityConnection CreatePersistent(string instanceId, string entityConnectionString, IDataLoader dataLoader);
    public static EntityConnection CreatePersistent(string entityConnectionString, IDataLoader dataLoader);
    public static EntityConnection CreatePersistent(string entityConnectionString);
    public static EntityConnection CreatePersistent(string instanceId, string entityConnectionString);
    public static EntityConnection CreateTransient(string entityConnectionString, IDataLoader dataLoader);
    public static EntityConnection CreateTransient(string entityConnectionString);
    public static EntityConnection Create(string entityConnectionString, string effortConnectionString, bool persistent);
    private static string GetFullEntityConnectionString(string entityConnectionString);
    private static EntityConnection CreateEntityConnection(MetadataWorkspace metadata, DbConnection connection);
    private static MetadataWorkspace GetEffortCompatibleMetadataWorkspace(String& entityConnectionString);
}
public class Effort.EntityFrameworkEffortManager : object {
    public static string CustomManifestPath;
    public static Func`2<DbContext, DbContext> ContextFactory;
    public static bool UseDefaultForNotNullable { get; public set; }
    public static bool get_UseDefaultForNotNullable();
    public static void set_UseDefaultForNotNullable(bool value);
    internal static DbContext CreateFactoryContext(DbContext context);
}
public class Effort.Exceptions.EffortException : Exception {
    public EffortException(string message);
    public EffortException(string message, Exception inner);
    protected EffortException(SerializationInfo info, StreamingContext context);
}
internal class Effort.Exceptions.ExceptionMessages : object {
    private static string InvariantName;
    private static string FactoryType;
    private static string ProviderServicesType;
    private static string Break;
    private static string AutomaticRegistationFailedResolveCode;
    private static string AutomaticRegistationFailedResolveConfig;
    public static string AutomaticRegistrationFailed;
    public static string EntityPropertyAssignFailed;
    public static string TableInitializationFailed;
    public static string DbExpressionTransformationNotImplemented;
    public static string TableNotFound;
    public static string DatabaseNotInitialized;
    private static ExceptionMessages();
}
internal class Effort.Internal.Caching.CachingTableDataLoaderKey : object {
    private DataLoaderConfigurationKey loaderConfiguration;
    private string tableName;
    public CachingTableDataLoaderKey(DataLoaderConfigurationKey loaderConfiguration, string tableName);
    public sealed virtual bool Equals(CachingTableDataLoaderKey other);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
}
internal static class Effort.Internal.Caching.CachingTableDataLoaderStore : object {
    private static ConcurrentCache`2<CachingTableDataLoaderKey, CachingTableDataLoader> store;
    private static CachingTableDataLoaderStore();
    public static CachingTableDataLoader GetCachedData(CachingTableDataLoaderKey key, Func`1<CachingTableDataLoader> factoryMethod);
    public static bool Contains(CachingTableDataLoaderKey key);
}
internal class Effort.Internal.Caching.ConcurrentCache`2 : object {
    private ConcurrentDictionary`2<TKey, Lazy`1<TElement>> store;
    public TElement Get(TKey key);
    public TElement Get(TKey key, Func`1<TElement> factory);
    public bool Contains(TKey key);
    public void Remove(TKey key);
}
internal class Effort.Internal.Caching.DataLoaderConfigurationKey : object {
    private Type type;
    private string argument;
    public DataLoaderConfigurationKey(IDataLoader loader);
    public sealed virtual bool Equals(DataLoaderConfigurationKey other);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
}
internal class Effort.Internal.Caching.DataLoaderConfigurationLatch : object {
    private SemaphoreSlim semaphore;
    public sealed virtual void Acquire();
    public sealed virtual void Release();
}
internal static class Effort.Internal.Caching.DataLoaderConfigurationLatchStore : object {
    private static ConcurrentCache`2<DataLoaderConfigurationKey, DataLoaderConfigurationLatch> store;
    private static DataLoaderConfigurationLatchStore();
    public static DataLoaderConfigurationLatch GetLatch(DataLoaderConfigurationKey key);
}
internal class Effort.Internal.Caching.DbContainerStore : object {
    private static ConcurrentCache`2<string, DbContainer> store;
    private static DbContainerStore();
    public static DbContainer GetDbContainer(string instanceId, Func`1<DbContainer> databaseFactoryMethod);
    public static void RemoveDbContainer(string instanceId);
}
internal class Effort.Internal.Caching.DbSchemaKey : object {
    private string innerKey;
    public DbSchemaKey(StoreItemCollection storeItemCollection);
    public static DbSchemaKey FromString(string value);
    public sealed virtual bool Equals(DbSchemaKey other);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public virtual string ToString();
}
internal static class Effort.Internal.Caching.DbSchemaStore : object {
    private static ConcurrentCache`2<DbSchemaKey, DbSchema> store;
    private static DbSchemaStore();
    public static DbSchema GetDbSchema(DbSchemaKey schemaKey);
    public static DbSchema GetDbSchema(StoreItemCollection metadata, Func`2<StoreItemCollection, DbSchema> schemaFactoryMethod);
}
internal class Effort.Internal.Caching.MetadataWorkspaceStore : object {
    private static ConcurrentCache`2<string, MetadataWorkspace> store;
    private static MetadataWorkspaceStore();
    public static MetadataWorkspace GetMetadataWorkspace(string metadata, Func`2<string, MetadataWorkspace> workspaceFactoryMethod);
}
internal class Effort.Internal.Caching.ObjectContextTypeKey : object {
    private string entityConnectionString;
    private string effortConnectionString;
    private string objectContextType;
    public ObjectContextTypeKey(string entityConnectionString, string effortConnectionString, Type objectContextType);
    public sealed virtual bool Equals(ObjectContextTypeKey other);
    public virtual int GetHashCode();
    public virtual bool Equals(object obj);
}
internal class Effort.Internal.Caching.ObjectContextTypeStore : object {
    private static ConcurrentCache`2<ObjectContextTypeKey, Type> store;
    private static ObjectContextTypeStore();
    public static Type GetObjectContextType(string entityConnectionString, string effortConnectionString, Type objectContextType, Func`1<Type> objectContextTypeFactoryMethod);
}
internal class Effort.Internal.CommandActions.ActionContext : object {
    private DbContainer container;
    private IList`1<CommandActionParameter> parameters;
    [CompilerGeneratedAttribute]
private Transaction <Transaction>k__BackingField;
    public DbContainer DbContainer { get; }
    public IList`1<CommandActionParameter> Parameters { get; }
    public Transaction Transaction { get; public set; }
    public ActionContext(DbContainer container);
    public DbContainer get_DbContainer();
    public IList`1<CommandActionParameter> get_Parameters();
    [CompilerGeneratedAttribute]
public Transaction get_Transaction();
    [CompilerGeneratedAttribute]
public void set_Transaction(Transaction value);
}
internal static class Effort.Internal.CommandActions.CommandActionFactory : object {
    public static ICommandAction Create(DbCommandTree commandTree);
}
internal class Effort.Internal.CommandActions.CommandActionParameter : object {
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    [CompilerGeneratedAttribute]
private object <Value>k__BackingField;
    public string Name { get; private set; }
    public object Value { get; private set; }
    public CommandActionParameter(string name, object value);
    [CompilerGeneratedAttribute]
public string get_Name();
    [CompilerGeneratedAttribute]
private void set_Name(string value);
    [CompilerGeneratedAttribute]
public object get_Value();
    [CompilerGeneratedAttribute]
private void set_Value(object value);
}
internal static class Effort.Internal.CommandActions.DbCommandActionHelper : object {
    public static FieldDescription[] GetReturningFields(DbExpression returning);
    public static ITable GetTable(DbModificationCommandTree commandTree, DbContainer container);
    public static List`1<ITable> GetAllTables(DbContainer container);
    public static IDictionary`2<string, DbExpression> GetSetClauseExpressions(IList`1<DbModificationClause> clauses);
    public static Expression GetEnumeratorExpression(DbExpression predicate, DbModificationCommandTree commandTree, DbContainer container, ITable& table);
    public static Dictionary`2<string, object> CreateReturningEntity(ActionContext context, FieldDescription[] returningFields, object entity);
    public static IDictionary`2<string, object> FormatParameters(IList`1<CommandActionParameter> source, IList`1<ParameterDescription> description, ITypeConverter converter);
}
internal class Effort.Internal.CommandActions.DeleteCommandAction : object {
    private DbDeleteCommandTree commandTree;
    public DeleteCommandAction(DbDeleteCommandTree commandTree);
    public sealed virtual DbDataReader ExecuteDataReader(ActionContext context);
    public sealed virtual object ExecuteScalar(ActionContext context);
    public sealed virtual int ExecuteNonQuery(ActionContext context);
}
internal interface Effort.Internal.CommandActions.ICommandAction {
    public abstract virtual DbDataReader ExecuteDataReader(ActionContext context);
    public abstract virtual object ExecuteScalar(ActionContext context);
    public abstract virtual int ExecuteNonQuery(ActionContext context);
}
internal class Effort.Internal.CommandActions.InsertCommandAction : object {
    private DbInsertCommandTree commandTree;
    public InsertCommandAction(DbInsertCommandTree commandTree);
    public sealed virtual DbDataReader ExecuteDataReader(ActionContext context);
    public sealed virtual int ExecuteNonQuery(ActionContext context);
    public sealed virtual object ExecuteScalar(ActionContext context);
    private static object CreateAndInsertEntity(ITable table, IList`1<MemberBinding> memberBindings, Transaction transaction);
}
internal class Effort.Internal.CommandActions.QueryCommandAction : object {
    private DbQueryCommandTree commandTree;
    public QueryCommandAction(DbQueryCommandTree commandTree);
    public sealed virtual DbDataReader ExecuteDataReader(ActionContext context);
    public sealed virtual object ExecuteScalar(ActionContext context);
    public sealed virtual int ExecuteNonQuery(ActionContext context);
    private static List`1<FieldDescription> GetReturningFields(DbQueryCommandTree commandTree);
}
internal class Effort.Internal.CommandActions.UpdateCommandAction : object {
    private DbUpdateCommandTree commandTree;
    public UpdateCommandAction(DbUpdateCommandTree commandTree);
    public sealed virtual DbDataReader ExecuteDataReader(ActionContext context);
    public sealed virtual int ExecuteNonQuery(ActionContext context);
    public sealed virtual object ExecuteScalar(ActionContext context);
}
internal static class Effort.Internal.Common.CommandTreeBuilder : object {
    public static DbCommandTree CreateSelectAll(MetadataWorkspace workspace, EntitySet entitySet);
}
internal static class Effort.Internal.Common.DatabaseReflectionHelper : object {
    public static ITable CreateTable(Database database, Type entityType, IKeyInfo primaryKeyInfo, MemberInfo identityField, Object[] constraintFactories, DbTableInfo tableInfo);
    public static IIndex CreateIndex(ITable table, IKeyInfo key, bool unique);
    public static void InitializeTableData(ITable table, IEnumerable`1<object> entities);
    public static void InsertEntity(ITable table, object entity, Transaction transaction);
    public static IEnumerable`1<object> UpdateEntities(IQueryable source, Expression updater, Transaction transaction);
    public static int DeleteEntities(IQueryable source, Transaction transaction);
    public static IQueryable CreateTableQuery(Expression query, Database database);
    public static ISharedStoredProcedure CreateSharedStoredProcedure(LambdaExpression query);
    public static void CreateAssociation(Database database, DbRelationInfo relation);
    private static IIndex FindIndex(ITable table, IKeyInfo key, bool unique);
    private static ITable GetTable(Database database, RelationshipEndMember rel);
}
[ExtensionAttribute]
internal static class Effort.Internal.Common.EdmHelper : object {
    [ExtensionAttribute]
public static TableName GetFullTableName(EntitySetBase entitySet);
    [ExtensionAttribute]
public static string GetSchema(EntitySetBase entitySet);
    [ExtensionAttribute]
public static string GetTableName(EntitySetBase entitySet);
    [ExtensionAttribute]
public static string GetColumnName(EdmMember member);
}
internal static class Effort.Internal.Common.EmitHelper : object {
    public static PropertyBuilder AddProperty(TypeBuilder tb, string name);
    public static PropertyBuilder AddProperty(TypeBuilder tb, string name, Type type);
}
internal class Effort.Internal.Common.ExpressionHelper : object {
    public static void TryUnifyValueTypes(Expression& left, Expression& right);
    public static Expression ConvertToNotNull(Expression exp);
    public static Expression CorrectType(Expression exp, Type desiredType);
    public static Expression SkipConversionNodes(Expression expression);
    private static void ConvertExpression(Expression& to, Expression& expr);
}
internal class Effort.Internal.Common.FastLazy`1 : object {
    private Func`1<T> factory;
    private T value;
    public T Value { get; }
    public FastLazy`1(Func`1<T> factory);
    public T get_Value();
}
internal class Effort.Internal.Common.FieldDescription : object {
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    [CompilerGeneratedAttribute]
private Type <Type>k__BackingField;
    public string Name { get; private set; }
    public Type Type { get; private set; }
    public FieldDescription(string name, Type type);
    [CompilerGeneratedAttribute]
public string get_Name();
    [CompilerGeneratedAttribute]
private void set_Name(string value);
    [CompilerGeneratedAttribute]
public Type get_Type();
    [CompilerGeneratedAttribute]
private void set_Type(Type value);
}
internal static class Effort.Internal.Common.MetadataWorkspaceHelper : object {
    private static Byte[] systemPublicKeyToken;
    private static Regex resRegex;
    private static string httpContextTypeName;
    private static MetadataWorkspaceHelper();
    public static EntityContainer GetEntityContainer(MetadataWorkspace workspace);
    public static MetadataWorkspace Rewrite(string metadata, string providerInvariantName, string providerManifestToken);
    public static MetadataWorkspace CreateMetadataWorkspace(List`1<XElement> csdl, List`1<XElement> ssdl, List`1<XElement> msl);
    public static MetadataWorkspace GetMetadataWorkspace(string connectionStringName, Assembly assembly);
    public static void ParseMetadata(string metadata, List`1<XElement> csdl, List`1<XElement> ssdl, List`1<XElement> msl);
    private static void ParseResources(string resPath, List`1<XElement> csdl, List`1<XElement> ssdl, List`1<XElement> msl);
    private static IEnumerable`1<string> FindResources(string resourceName, Assembly asm);
    [IteratorStateMachineAttribute("Effort.Internal.Common.MetadataWorkspaceHelper/<GetAllResources>d__10")]
private static IEnumerable`1<string> GetAllResources(Assembly asm);
    private static bool IsEcmaAssembly(Assembly asm);
    private static bool IsSystemAssembly(Assembly asm);
    private static void ParseDirectory(string directory, List`1<XElement> csdl, List`1<XElement> ssdl, List`1<XElement> msl);
}
internal class Effort.Internal.Common.ProviderHelper : object {
    public static DbProviderManifest GetProviderManifest(string providerInvariantName, string providerManifestToken);
    public static DbConnection CreateConnection(string providerInvariantName);
}
internal static class Effort.Internal.Common.ReflectionHelper : object {
    public static MethodInfo GetMethodInfo(Expression`1<Func`2<TSource, TResult>> expr);
    public static MethodInfo GetMethodInfo(Expression`1<Func`2<T, object>> expr);
    public static MethodInfo GetMethodInfo(Expression`1<Func`1<object>> expr, bool makeGeneric);
    public static MemberInfo GetMemberInfo(Expression`1<Func`1<TResult>> expr);
    public static MemberInfo GetMemberInfo(Expression`1<Func`1<object>> expr);
}
internal class Effort.Internal.Common.TupleTypeHelper : object {
    public static int LargeTupleSize;
    private static TupleTypeHelper();
    public static Type CreateTupleType(Type[] memberTypes);
    private static Type CreateTupleType(Type[] memberTypes, int offset);
    private static Type GetTupleType(Type[] memberTypes);
}
internal static class Effort.Internal.Common.TypeHelper : object {
    public static Type GetEnumerableInterfaceTypeDefinition(Type type);
    public static Type GetElementType(Type type);
    public static bool IsNullable(Type type);
    public static Type MakeNullable(Type type);
    public static Type MakeNotNullable(Type type);
    public static bool IsCastableTo(Type from, Type to);
    public static Type GetDelegateReturnType(Type type);
    public static string NormalizeForCliTypeName(string name);
    public static Type GetMemberType(MemberInfo member);
    public static bool IsNumeric(Type type);
}
internal static class Effort.Internal.Common.TypeUsageHelper : object {
    public static bool TryGetMaxLength(TypeUsage typeUsage, Int32& maxLength);
    public static bool TryGetIsFixedLength(TypeUsage typeUsage, Boolean& isFixed);
    public static bool TryGetPrecision(TypeUsage typeUsage, Byte& precision);
    public static bool TryGetScale(TypeUsage typeUsage, Byte& scale);
    public static bool TryGetIsUnicode(TypeUsage typeUsage, Boolean& isUnicode);
    private static bool TryGetFacetValue(TypeUsage typeUsage, string facetDescription, bool checkUnbound, T& value);
}
internal class Effort.Internal.Common.XmlProcessing.AggregatedElementModifier : object {
    private IList`1<IElementModifier> modifiers;
    public void AddModifier(IElementModifier modifier);
    public sealed virtual void Modify(XElement root, IModificationContext context);
}
internal class Effort.Internal.Common.XmlProcessing.ComposedElementModifier : object {
    private IElementSelector elementSelector;
    private IElementAttributeSelector attributeSelector;
    private IAttributeModifier attributeModifier;
    private IElementModifier elementModifier;
    public ComposedElementModifier(IElementSelector elementSelector, IElementAttributeSelector attributeSelector, IAttributeModifier attributeModifier);
    public ComposedElementModifier(IElementSelector elementSelector, IElementModifier elementModifier);
    public sealed virtual void Modify(XElement element, IModificationContext context);
}
internal interface Effort.Internal.Common.XmlProcessing.IAttributeModifier {
    public abstract virtual void Modify(XAttribute attribute, IModificationContext context);
}
internal interface Effort.Internal.Common.XmlProcessing.IElementAttributeSelector {
    public abstract virtual XAttribute SelectAttribute(XElement element);
}
internal interface Effort.Internal.Common.XmlProcessing.IElementModifier {
    public abstract virtual void Modify(XElement element, IModificationContext context);
}
internal interface Effort.Internal.Common.XmlProcessing.IElementSelector {
    public abstract virtual IEnumerable`1<XElement> SelectElements(XElement element);
}
internal interface Effort.Internal.Common.XmlProcessing.IElementVisitor`1 {
    public abstract virtual T VisitElement(XElement element);
}
internal interface Effort.Internal.Common.XmlProcessing.IModificationContext {
    public abstract virtual void Set(string key, T element);
    public abstract virtual T Get(string key, T defaultElement);
}
internal class Effort.Internal.Common.XmlProcessing.ModificationContext : object {
    private IDictionary`2<string, object> elements;
    public sealed virtual void Set(string key, T element);
    public sealed virtual T Get(string key, T failback);
}
internal class Effort.Internal.Common.XmlProcessing.SelfElementSelector : object {
    [IteratorStateMachineAttribute("Effort.Internal.Common.XmlProcessing.SelfElementSelector/<SelectElements>d__0")]
public sealed virtual IEnumerable`1<XElement> SelectElements(XElement element);
}
[DefaultMemberAttribute("Item")]
internal class Effort.Internal.Csv.CsvReader : object {
    public static int DefaultBufferSize;
    public static char DefaultDelimiter;
    public static char DefaultQuote;
    public static char DefaultEscape;
    public static char DefaultComment;
    private static StringComparer fieldHeaderComparer;
    private TextReader reader;
    private int bufferSize;
    private char comment;
    private char escape;
    private char delimiter;
    private char quote;
    private ValueTrimmingOptions trimmingOptions;
    private bool hasHeaders;
    private ParseErrorAction defaultParseErrorAction;
    private MissingFieldAction missingFieldAction;
    private bool supportsMultiline;
    private bool skipEmptyLines;
    private bool initialized;
    private String[] fieldHeaders;
    private Dictionary`2<string, int> fieldHeaderIndexes;
    private long currentRecordIndex;
    private int nextFieldStart;
    private int nextFieldIndex;
    private FieldValue[] fields;
    private int fieldCount;
    private Char[] buffer;
    private int bufferLength;
    private bool eof;
    private bool eol;
    private bool firstRecordInCache;
    private bool missingFieldFlag;
    private bool parseErrorFlag;
    private bool isDisposed;
    private object latch;
    [CompilerGeneratedAttribute]
private EventHandler`1<ParseErrorEventArgs> ParseError;
    [CompilerGeneratedAttribute]
private string <DefaultHeaderName>k__BackingField;
    public char Comment { get; }
    public char Escape { get; }
    public char Delimiter { get; }
    public char Quote { get; }
    public bool HasHeaders { get; }
    public ValueTrimmingOptions TrimmingOption { get; }
    public int BufferSize { get; }
    public ParseErrorAction DefaultParseErrorAction { get; public set; }
    public MissingFieldAction MissingFieldAction { get; public set; }
    public bool SupportsMultiline { get; public set; }
    public bool SkipEmptyLines { get; public set; }
    public string DefaultHeaderName { get; public set; }
    public int FieldCount { get; }
    public bool EndOfStream { get; }
    public long CurrentRecordIndex { get; }
    public bool MissingFieldFlag { get; }
    public bool ParseErrorFlag { get; }
    public string Item { get; }
    public string Item { get; }
    public string Item { get; }
    public string Item { get; }
    private int System.Data.IDataReader.RecordsAffected { get; }
    private bool System.Data.IDataReader.IsClosed { get; }
    private int System.Data.IDataReader.Depth { get; }
    private object System.Data.IDataRecord.Item { get; }
    private object System.Data.IDataRecord.Item { get; }
    [BrowsableAttribute("False")]
public bool IsDisposed { get; }
    public CsvReader(TextReader reader, bool hasHeaders);
    public CsvReader(TextReader reader, bool hasHeaders, int bufferSize);
    public CsvReader(TextReader reader, bool hasHeaders, char delimiter);
    public CsvReader(TextReader reader, bool hasHeaders, char delimiter, int bufferSize);
    public CsvReader(TextReader reader, bool hasHeaders, char delimiter, char quote, char escape, char comment, ValueTrimmingOptions trimmingOptions);
    public CsvReader(TextReader reader, bool hasHeaders, char delimiter, char quote, char escape, char comment, ValueTrimmingOptions trimmingOptions, int bufferSize);
    private static CsvReader();
    [CompilerGeneratedAttribute]
public void add_ParseError(EventHandler`1<ParseErrorEventArgs> value);
    [CompilerGeneratedAttribute]
public void remove_ParseError(EventHandler`1<ParseErrorEventArgs> value);
    protected virtual void OnParseError(ParseErrorEventArgs e);
    public char get_Comment();
    public char get_Escape();
    public char get_Delimiter();
    public char get_Quote();
    public bool get_HasHeaders();
    public ValueTrimmingOptions get_TrimmingOption();
    public int get_BufferSize();
    public ParseErrorAction get_DefaultParseErrorAction();
    public void set_DefaultParseErrorAction(ParseErrorAction value);
    public MissingFieldAction get_MissingFieldAction();
    public void set_MissingFieldAction(MissingFieldAction value);
    public bool get_SupportsMultiline();
    public void set_SupportsMultiline(bool value);
    public bool get_SkipEmptyLines();
    public void set_SkipEmptyLines(bool value);
    [CompilerGeneratedAttribute]
public string get_DefaultHeaderName();
    [CompilerGeneratedAttribute]
public void set_DefaultHeaderName(string value);
    public sealed virtual int get_FieldCount();
    public virtual bool get_EndOfStream();
    public String[] GetFieldHeaders();
    public virtual long get_CurrentRecordIndex();
    public bool get_MissingFieldFlag();
    public bool get_ParseErrorFlag();
    public string get_Item(int record, string field);
    public string get_Item(int record, int field);
    public string get_Item(string field);
    public virtual string get_Item(int field);
    private void EnsureInitialize();
    public int GetFieldIndex(string header);
    public void CopyCurrentRecordTo(String[] array, int index);
    public string GetCurrentRawData();
    private bool IsWhiteSpace(char c);
    public virtual bool MoveTo(long record);
    private bool ParseNewLine(Int32& pos);
    private bool IsNewLine(int pos);
    private bool ReadBuffer();
    private FieldValue ReadField(int field, bool initializing, bool discardValue);
    public bool ReadNextRecord();
    protected virtual bool ReadNextRecord(bool onlyReadHeaders, bool skipToNextLine);
    private bool SkipEmptyAndCommentedLines(Int32& pos);
    private void DoSkipEmptyAndCommentedLines(Int32& pos);
    private bool SkipWhiteSpaces(Int32& pos);
    private bool SkipToNextLine(Int32& pos);
    private void HandleParseError(MalformedCsvException error, Int32& pos);
    private FieldValue HandleMissingField(FieldValue value, int fieldIndex, Int32& currentPosition);
    private void ValidateDataReader(DataReaderValidations validations);
    private long CopyFieldToArray(int field, long fieldOffset, Array destinationArray, int destinationOffset, int length);
    private sealed virtual override int System.Data.IDataReader.get_RecordsAffected();
    private sealed virtual override bool System.Data.IDataReader.get_IsClosed();
    private sealed virtual override bool System.Data.IDataReader.NextResult();
    private sealed virtual override void System.Data.IDataReader.Close();
    private sealed virtual override bool System.Data.IDataReader.Read();
    private sealed virtual override int System.Data.IDataReader.get_Depth();
    private sealed virtual override DataTable System.Data.IDataReader.GetSchemaTable();
    private static void AddColumn(DataTable schema, string columnName, Type type);
    private sealed virtual override int System.Data.IDataRecord.GetInt32(int i);
    private sealed virtual override object System.Data.IDataRecord.get_Item(string name);
    private sealed virtual override object System.Data.IDataRecord.get_Item(int i);
    private sealed virtual override object System.Data.IDataRecord.GetValue(int i);
    private sealed virtual override bool System.Data.IDataRecord.IsDBNull(int i);
    private sealed virtual override long System.Data.IDataRecord.GetBytes(int i, long fieldOffset, Byte[] buffer, int bufferoffset, int length);
    private sealed virtual override byte System.Data.IDataRecord.GetByte(int i);
    private sealed virtual override Type System.Data.IDataRecord.GetFieldType(int i);
    private sealed virtual override decimal System.Data.IDataRecord.GetDecimal(int i);
    private sealed virtual override int System.Data.IDataRecord.GetValues(Object[] values);
    private sealed virtual override string System.Data.IDataRecord.GetName(int i);
    private sealed virtual override long System.Data.IDataRecord.GetInt64(int i);
    private sealed virtual override double System.Data.IDataRecord.GetDouble(int i);
    private sealed virtual override bool System.Data.IDataRecord.GetBoolean(int i);
    private sealed virtual override Guid System.Data.IDataRecord.GetGuid(int i);
    private sealed virtual override DateTime System.Data.IDataRecord.GetDateTime(int i);
    private sealed virtual override int System.Data.IDataRecord.GetOrdinal(string name);
    private sealed virtual override string System.Data.IDataRecord.GetDataTypeName(int i);
    private sealed virtual override float System.Data.IDataRecord.GetFloat(int i);
    private sealed virtual override IDataReader System.Data.IDataRecord.GetData(int i);
    private sealed virtual override long System.Data.IDataRecord.GetChars(int i, long fieldoffset, Char[] buffer, int bufferoffset, int length);
    private sealed virtual override string System.Data.IDataRecord.GetString(int i);
    private sealed virtual override char System.Data.IDataRecord.GetChar(int i);
    private sealed virtual override short System.Data.IDataRecord.GetInt16(int i);
    public RecordEnumerator GetEnumerator();
    private sealed virtual override IEnumerator`1<String[]> System.Collections.Generic.IEnumerable<System.String[]>.GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    public bool get_IsDisposed();
    protected void CheckDisposed();
    public sealed virtual void Dispose();
    protected virtual void Dispose(bool disposing);
    protected virtual override void Finalize();
}
[GeneratedCodeAttribute("System.Resources.Tools.StronglyTypedResourceBuilder", "4.0.0.0")]
[DebuggerNonUserCodeAttribute]
[CompilerGeneratedAttribute]
internal class Effort.Internal.Csv.ExceptionMessages : object {
    private static ResourceManager resourceMan;
    private static CultureInfo resourceCulture;
    [EditorBrowsableAttribute("2")]
internal static ResourceManager ResourceManager { get; }
    [EditorBrowsableAttribute("2")]
internal static CultureInfo Culture { get; internal set; }
    internal static string BufferSizeTooSmall { get; }
    internal static string CannotMovePreviousRecordInForwardOnly { get; }
    internal static string CannotReadRecordAtIndex { get; }
    internal static string EnumerationFinishedOrNotStarted { get; }
    internal static string EnumerationVersionCheckFailed { get; }
    internal static string FieldHeaderNotFound { get; }
    internal static string FieldIndexOutOfRange { get; }
    internal static string MalformedCsvException { get; }
    internal static string MissingFieldActionNotSupported { get; }
    internal static string NoCurrentRecord { get; }
    internal static string NoHeaders { get; }
    internal static string NotEnoughSpaceInArray { get; }
    internal static string ParseErrorActionInvalidInsideParseErrorEvent { get; }
    internal static string ParseErrorActionNotSupported { get; }
    internal static string ReaderClosed { get; }
    internal static string RecordIndexLessThanZero { get; }
    internal static ResourceManager get_ResourceManager();
    internal static CultureInfo get_Culture();
    internal static void set_Culture(CultureInfo value);
    internal static string get_BufferSizeTooSmall();
    internal static string get_CannotMovePreviousRecordInForwardOnly();
    internal static string get_CannotReadRecordAtIndex();
    internal static string get_EnumerationFinishedOrNotStarted();
    internal static string get_EnumerationVersionCheckFailed();
    internal static string get_FieldHeaderNotFound();
    internal static string get_FieldIndexOutOfRange();
    internal static string get_MalformedCsvException();
    internal static string get_MissingFieldActionNotSupported();
    internal static string get_NoCurrentRecord();
    internal static string get_NoHeaders();
    internal static string get_NotEnoughSpaceInArray();
    internal static string get_ParseErrorActionInvalidInsideParseErrorEvent();
    internal static string get_ParseErrorActionNotSupported();
    internal static string get_ReaderClosed();
    internal static string get_RecordIndexLessThanZero();
}
internal class Effort.Internal.Csv.FieldValue : ValueType {
    private bool hasValue;
    private string value;
    public static FieldValue Missing;
    public bool IsMissing { get; }
    public string Value { get; }
    private FieldValue(string value, bool hasValue);
    private static FieldValue();
    public bool get_IsMissing();
    public string get_Value();
    public static FieldValue op_Implicit(string value);
    public static FieldValue op_Addition(FieldValue left, string right);
    public static FieldValue op_Addition(string left, FieldValue right);
    public virtual string ToString();
    public virtual int GetHashCode();
}
internal class Effort.Internal.Csv.MalformedCsvException : Exception {
    private string message;
    private string rawData;
    private int currentFieldIndex;
    private long currentRecordIndex;
    private int currentPosition;
    public string RawData { get; }
    public int CurrentPosition { get; }
    public long CurrentRecordIndex { get; }
    public int CurrentFieldIndex { get; }
    public string Message { get; }
    public MalformedCsvException(string message);
    public MalformedCsvException(string message, Exception innerException);
    public MalformedCsvException(string rawData, int currentPosition, long currentRecordIndex, int currentFieldIndex);
    public MalformedCsvException(string rawData, int currentPosition, long currentRecordIndex, int currentFieldIndex, Exception innerException);
    protected MalformedCsvException(SerializationInfo info, StreamingContext context);
    public string get_RawData();
    public int get_CurrentPosition();
    public long get_CurrentRecordIndex();
    public int get_CurrentFieldIndex();
    public virtual string get_Message();
    public virtual void GetObjectData(SerializationInfo info, StreamingContext context);
}
internal enum Effort.Internal.Csv.MissingFieldAction : Enum {
    public int value__;
    public static MissingFieldAction ParseError;
    public static MissingFieldAction ReplaceByEmpty;
    public static MissingFieldAction ReplaceByNull;
}
internal class Effort.Internal.Csv.MissingFieldCsvException : MalformedCsvException {
    public MissingFieldCsvException(string message);
    public MissingFieldCsvException(string message, Exception innerException);
    public MissingFieldCsvException(string rawData, int currentPosition, long currentRecordIndex, int currentFieldIndex);
    public MissingFieldCsvException(string rawData, int currentPosition, long currentRecordIndex, int currentFieldIndex, Exception innerException);
    protected MissingFieldCsvException(SerializationInfo info, StreamingContext context);
}
internal enum Effort.Internal.Csv.ParseErrorAction : Enum {
    public int value__;
    public static ParseErrorAction RaiseEvent;
    public static ParseErrorAction AdvanceToNextLine;
    public static ParseErrorAction ThrowException;
}
internal class Effort.Internal.Csv.ParseErrorEventArgs : EventArgs {
    private MalformedCsvException error;
    private ParseErrorAction action;
    public MalformedCsvException Error { get; }
    public ParseErrorAction Action { get; public set; }
    public ParseErrorEventArgs(MalformedCsvException error, ParseErrorAction defaultAction);
    public MalformedCsvException get_Error();
    public ParseErrorAction get_Action();
    public void set_Action(ParseErrorAction value);
}
[FlagsAttribute]
internal enum Effort.Internal.Csv.ValueTrimmingOptions : Enum {
    public int value__;
    public static ValueTrimmingOptions None;
    public static ValueTrimmingOptions UnquotedOnly;
    public static ValueTrimmingOptions QuotedOnly;
    public static ValueTrimmingOptions All;
}
internal class Effort.Internal.DbCommandTreeTransformation.CanonicalFunctionMapper : object {
    private Dictionary`2<string, Func`3<EdmFunction, Expression[], Expression>> mappings;
    private EdmTypeConverter converter;
    public CanonicalFunctionMapper(ITypeConverter converter, DbContainer container);
    private void AddMiscMappings();
    private void AddBitwiseMappings();
    private void AddMathMappings();
    private void AddStringMappings(DbContainer container);
    private void AddDateTimeMappings();
    private static MethodCallExpression MapRound(EdmFunction f, Expression[] args);
    private static MethodCallExpression MapAbs(EdmFunction f, Expression[] args);
    private static MethodInfo GetAbsMethod(FunctionParameter param);
    private void Map(string name, MethodInfo method);
    private void MapDate(string name, MethodInfo dateTime, MethodInfo dateTimeOffset, MethodInfo time);
    private void MapMath(string name, MethodInfo decimalMethod, MethodInfo doubleMethod);
    private void Map(string name, Func`3<EdmFunction, Expression[], int> methodSelector, MethodInfo[] methods);
    private static bool IsDecimal(FunctionParameter param);
    private static int SelectMathMethod(EdmFunction function, Expression[] args);
    private static int SelectDateTimeMethod(EdmFunction function, Expression[] args);
    internal static Type GetTypeBinary(Type leftType, Type rightType);
    private static Expression[] FixArguments(MethodInfo method, Expression[] args);
    public Expression CreateMethodCall(EdmFunction function, Expression[] arguments);
}
internal class Effort.Internal.DbCommandTreeTransformation.DbFunctions : object {
    public static Nullable`1<decimal> Truncate(Nullable`1<decimal> input);
    public static Nullable`1<double> Truncate(Nullable`1<double> input);
    public static Nullable`1<decimal> Ceiling(Nullable`1<decimal> input);
    public static Nullable`1<double> Ceiling(Nullable`1<double> input);
    public static Nullable`1<decimal> Floor(Nullable`1<decimal> input);
    public static Nullable`1<double> Floor(Nullable`1<double> input);
    public static Nullable`1<decimal> Round(Nullable`1<decimal> input);
    public static Nullable`1<double> Round(Nullable`1<double> input);
    public static Nullable`1<decimal> Round(Nullable`1<decimal> input, Nullable`1<int> decimals);
    public static Nullable`1<double> Round(Nullable`1<double> input, Nullable`1<int> digits);
    public static Nullable`1<double> Pow(Nullable`1<double> x, Nullable`1<double> y);
    public static Nullable`1<double> Abs(Nullable`1<double> input);
    public static Nullable`1<decimal> Abs(Nullable`1<decimal> input);
    public static Nullable`1<long> Abs(Nullable`1<long> input);
    public static Nullable`1<int> Abs(Nullable`1<int> input);
    public static Nullable`1<short> Abs(Nullable`1<short> input);
    public static Nullable`1<sbyte> Abs(Nullable`1<sbyte> input);
    public static string Concat(string a, string b);
    public static Nullable`1<bool> Contains(string a, string b);
    public static string Left(string a, Nullable`1<int> count);
    public static string Right(string a, Nullable`1<int> count);
    public static string ToUpper(string data);
    public static string ToLower(string data);
    public static Nullable`1<int> IndexOf(string a, string b);
    public static string ReverseString(string data);
    public static string Substring(string data, Nullable`1<int> begin, Nullable`1<int> length);
    public static string Trim(string data);
    public static string LTrim(string data);
    public static string RTrim(string data);
    public static Nullable`1<int> Length(string data);
    public static string Replace(string data, string oldValue, string newValue);
    public static Nullable`1<bool> StartsWith(string a, string b);
    public static Nullable`1<bool> EndsWith(string a, string b);
    internal static int CompareTo(string a, string b);
    public static Nullable`1<bool> ContainsCaseInsensitive(string a, string b);
    public static Nullable`1<int> IndexOfCaseInsensitive(string a, string b);
    public static Nullable`1<bool> StartsWithCaseInsensitive(string a, string b);
    public static Nullable`1<bool> EndsWithCaseInsensitive(string a, string b);
    public static Nullable`1<DateTime> CurrentDateTime();
    public static Nullable`1<DateTime> CurrentUtcDateTime();
    public static Nullable`1<DateTime> CreateDateTime(Nullable`1<int> year, Nullable`1<int> month, Nullable`1<int> day, Nullable`1<int> hour, Nullable`1<int> minute, Nullable`1<int> second);
    public static Nullable`1<int> GetYear(Nullable`1<DateTime> date);
    public static Nullable`1<int> GetMonth(Nullable`1<DateTime> date);
    public static Nullable`1<int> GetDay(Nullable`1<DateTime> date);
    public static Nullable`1<int> GetHour(Nullable`1<DateTime> date);
    public static Nullable`1<int> GetMinute(Nullable`1<DateTime> date);
    public static Nullable`1<int> GetSecond(Nullable`1<DateTime> date);
    public static Nullable`1<int> GetMillisecond(Nullable`1<DateTime> date);
    public static Nullable`1<DateTime> AddYears(Nullable`1<DateTime> date, Nullable`1<int> value);
    public static Nullable`1<DateTime> AddMonths(Nullable`1<DateTime> date, Nullable`1<int> value);
    public static Nullable`1<DateTime> AddDays(Nullable`1<DateTime> date, Nullable`1<int> value);
    public static Nullable`1<DateTime> AddHours(Nullable`1<DateTime> date, Nullable`1<int> value);
    public static Nullable`1<DateTime> AddMinutes(Nullable`1<DateTime> date, Nullable`1<int> value);
    public static Nullable`1<DateTime> AddSeconds(Nullable`1<DateTime> date, Nullable`1<int> value);
    public static Nullable`1<DateTime> AddMilliseconds(Nullable`1<DateTime> date, Nullable`1<int> value);
    public static Nullable`1<DateTime> AddMicroseconds(Nullable`1<DateTime> date, Nullable`1<int> value);
    public static Nullable`1<DateTime> AddNanoseconds(Nullable`1<DateTime> date, Nullable`1<int> value);
    public static Nullable`1<int> DiffYears(Nullable`1<DateTime> val1, Nullable`1<DateTime> val2);
    public static Nullable`1<int> DiffMonths(Nullable`1<DateTime> val1, Nullable`1<DateTime> val2);
    public static Nullable`1<int> DiffDays(Nullable`1<DateTime> val1, Nullable`1<DateTime> val2);
    public static Nullable`1<int> DiffHours(Nullable`1<DateTime> val1, Nullable`1<DateTime> val2);
    public static Nullable`1<int> DiffMinutes(Nullable`1<DateTime> val1, Nullable`1<DateTime> val2);
    public static Nullable`1<int> DiffSeconds(Nullable`1<DateTime> val1, Nullable`1<DateTime> val2);
    public static Nullable`1<int> DiffMilliseconds(Nullable`1<DateTime> val1, Nullable`1<DateTime> val2);
    public static Nullable`1<int> DiffMicroseconds(Nullable`1<DateTime> val1, Nullable`1<DateTime> val2);
    public static Nullable`1<int> DiffNanoseconds(Nullable`1<DateTime> val1, Nullable`1<DateTime> val2);
    public static Nullable`1<DateTime> TruncateTime(Nullable`1<DateTime> date);
    public static Nullable`1<int> DayOfYear(Nullable`1<DateTime> date);
    public static Nullable`1<DateTimeOffset> CurrentDateTimeOffset();
    public static Nullable`1<DateTimeOffset> CreateDateTimeOffset(Nullable`1<int> year, Nullable`1<int> month, Nullable`1<int> day, Nullable`1<int> hour, Nullable`1<int> minute, Nullable`1<int> second, Nullable`1<int> offsetMinutes);
    public static Nullable`1<int> GetYear(Nullable`1<DateTimeOffset> date);
    public static Nullable`1<int> GetMonth(Nullable`1<DateTimeOffset> date);
    public static Nullable`1<int> GetDay(Nullable`1<DateTimeOffset> date);
    public static Nullable`1<int> GetHour(Nullable`1<DateTimeOffset> date);
    public static Nullable`1<int> GetMinute(Nullable`1<DateTimeOffset> date);
    public static Nullable`1<int> GetSecond(Nullable`1<DateTimeOffset> date);
    public static Nullable`1<int> GetMillisecond(Nullable`1<DateTimeOffset> date);
    public static Nullable`1<DateTimeOffset> AddYears(Nullable`1<DateTimeOffset> date, Nullable`1<int> value);
    public static Nullable`1<DateTimeOffset> AddMonths(Nullable`1<DateTimeOffset> date, Nullable`1<int> value);
    public static Nullable`1<DateTimeOffset> AddDays(Nullable`1<DateTimeOffset> date, Nullable`1<int> value);
    public static Nullable`1<DateTimeOffset> AddHours(Nullable`1<DateTimeOffset> date, Nullable`1<int> value);
    public static Nullable`1<DateTimeOffset> AddMinutes(Nullable`1<DateTimeOffset> date, Nullable`1<int> value);
    public static Nullable`1<DateTimeOffset> AddSeconds(Nullable`1<DateTimeOffset> date, Nullable`1<int> value);
    public static Nullable`1<DateTimeOffset> AddMilliseconds(Nullable`1<DateTimeOffset> date, Nullable`1<int> value);
    public static Nullable`1<DateTimeOffset> AddMicroseconds(Nullable`1<DateTimeOffset> date, Nullable`1<int> value);
    public static Nullable`1<DateTimeOffset> AddNanoseconds(Nullable`1<DateTimeOffset> date, Nullable`1<int> value);
    public static Nullable`1<int> DiffYears(Nullable`1<DateTimeOffset> val1, Nullable`1<DateTimeOffset> val2);
    public static Nullable`1<int> DiffMonths(Nullable`1<DateTimeOffset> val1, Nullable`1<DateTimeOffset> val2);
    public static Nullable`1<int> DiffDays(Nullable`1<DateTimeOffset> val1, Nullable`1<DateTimeOffset> val2);
    public static Nullable`1<int> DiffHours(Nullable`1<DateTimeOffset> val1, Nullable`1<DateTimeOffset> val2);
    public static Nullable`1<int> DiffMinutes(Nullable`1<DateTimeOffset> val1, Nullable`1<DateTimeOffset> val2);
    public static Nullable`1<int> DiffSeconds(Nullable`1<DateTimeOffset> val1, Nullable`1<DateTimeOffset> val2);
    public static Nullable`1<int> DiffMilliseconds(Nullable`1<DateTimeOffset> val1, Nullable`1<DateTimeOffset> val2);
    public static Nullable`1<int> DiffMicroseconds(Nullable`1<DateTimeOffset> val1, Nullable`1<DateTimeOffset> val2);
    public static Nullable`1<int> DiffNanoseconds(Nullable`1<DateTimeOffset> val1, Nullable`1<DateTimeOffset> val2);
    public static Nullable`1<DateTimeOffset> TruncateTime(Nullable`1<DateTimeOffset> date);
    public static Nullable`1<int> DayOfYear(Nullable`1<DateTimeOffset> date);
    public static Nullable`1<int> GetTotalOffsetMinutes(Nullable`1<DateTimeOffset> date);
    internal static int CompareTo(Nullable`1<Guid> a, Nullable`1<Guid> b);
    public static Nullable`1<TimeSpan> CreateTime(Nullable`1<int> hour, Nullable`1<int> minute, Nullable`1<int> second);
    public static Nullable`1<int> GetHour(Nullable`1<TimeSpan> time);
    public static Nullable`1<int> GetMinute(Nullable`1<TimeSpan> time);
    public static Nullable`1<int> GetSecond(Nullable`1<TimeSpan> time);
    public static Nullable`1<int> GetMillisecond(Nullable`1<TimeSpan> time);
    public static Nullable`1<TimeSpan> AddHours(Nullable`1<TimeSpan> date, Nullable`1<int> value);
    public static Nullable`1<TimeSpan> AddMinutes(Nullable`1<TimeSpan> date, Nullable`1<int> value);
    public static Nullable`1<TimeSpan> AddSeconds(Nullable`1<TimeSpan> date, Nullable`1<int> value);
    public static Nullable`1<TimeSpan> AddMilliseconds(Nullable`1<TimeSpan> date, Nullable`1<int> value);
    public static Nullable`1<TimeSpan> AddMicroseconds(Nullable`1<TimeSpan> date, Nullable`1<int> value);
    public static Nullable`1<TimeSpan> AddNanoseconds(Nullable`1<TimeSpan> date, Nullable`1<int> value);
    public static Nullable`1<int> DiffHours(Nullable`1<TimeSpan> val1, Nullable`1<TimeSpan> val2);
    public static Nullable`1<int> DiffMinutes(Nullable`1<TimeSpan> val1, Nullable`1<TimeSpan> val2);
    public static Nullable`1<int> DiffSeconds(Nullable`1<TimeSpan> val1, Nullable`1<TimeSpan> val2);
    public static Nullable`1<int> DiffMilliseconds(Nullable`1<TimeSpan> val1, Nullable`1<TimeSpan> val2);
    public static Nullable`1<int> DiffMicroseconds(Nullable`1<TimeSpan> val1, Nullable`1<TimeSpan> val2);
    public static Nullable`1<int> DiffNanoseconds(Nullable`1<TimeSpan> val1, Nullable`1<TimeSpan> val2);
    public static string ToString(object obj);
    public static Nullable`1<T> TryParse(string s);
}
internal class Effort.Internal.DbCommandTreeTransformation.EntitySetSearchVisitor : TraversalVisitor {
    private List`1<EntitySetBase> tables;
    public EntitySetBase[] Search(DbExpression expression);
    protected virtual void OnVisited(DbScanExpression expression);
}
internal class Effort.Internal.DbCommandTreeTransformation.Functions.DateTimeFunctions : object {
    public static MethodInfo Current;
    public static MethodInfo CurrentUtc;
    public static MethodInfo CreateDateTime;
    public static MethodInfo GetYear;
    public static MethodInfo GetMonth;
    public static MethodInfo GetDay;
    public static MethodInfo GetHour;
    public static MethodInfo GetMinute;
    public static MethodInfo GetSecond;
    public static MethodInfo GetMillisecond;
    public static MethodInfo AddYears;
    public static MethodInfo AddMonths;
    public static MethodInfo AddDays;
    public static MethodInfo AddHours;
    public static MethodInfo AddMinutes;
    public static MethodInfo AddSeconds;
    public static MethodInfo AddMilliseconds;
    public static MethodInfo AddMicroseconds;
    public static MethodInfo AddNanoseconds;
    public static MethodInfo TruncateTime;
    public static MethodInfo DiffYears;
    public static MethodInfo DiffMonths;
    public static MethodInfo DiffDays;
    public static MethodInfo DiffHours;
    public static MethodInfo DiffMinutes;
    public static MethodInfo DiffSeconds;
    public static MethodInfo DiffMilliseconds;
    public static MethodInfo DiffMicroseconds;
    public static MethodInfo DiffNanoseconds;
    public static MethodInfo DayOfYear;
    private static DateTimeFunctions();
}
internal class Effort.Internal.DbCommandTreeTransformation.Functions.DateTimeOffsetFunctions : object {
    public static MethodInfo Current;
    public static MethodInfo CreateDateTimeOffset;
    public static MethodInfo GetYear;
    public static MethodInfo GetMonth;
    public static MethodInfo GetDay;
    public static MethodInfo GetHour;
    public static MethodInfo GetMinute;
    public static MethodInfo GetSecond;
    public static MethodInfo GetMillisecond;
    public static MethodInfo AddYears;
    public static MethodInfo AddMonths;
    public static MethodInfo AddDays;
    public static MethodInfo AddHours;
    public static MethodInfo AddMinutes;
    public static MethodInfo AddSeconds;
    public static MethodInfo AddMilliseconds;
    public static MethodInfo AddMicroseconds;
    public static MethodInfo AddNanoseconds;
    public static MethodInfo DiffYears;
    public static MethodInfo DiffMonths;
    public static MethodInfo DiffDays;
    public static MethodInfo DiffHours;
    public static MethodInfo DiffMinutes;
    public static MethodInfo DiffSeconds;
    public static MethodInfo DiffMilliseconds;
    public static MethodInfo DiffMicroseconds;
    public static MethodInfo DiffNanoseconds;
    public static MethodInfo TruncateTime;
    public static MethodInfo DayOfYear;
    public static MethodInfo GetTotalOffsetMinutes;
    private static DateTimeOffsetFunctions();
}
internal class Effort.Internal.DbCommandTreeTransformation.Functions.DecimalFunctions : object {
    public static MethodInfo Ceiling;
    public static MethodInfo Truncate;
    public static MethodInfo Floor;
    public static MethodInfo Round;
    public static MethodInfo RoundDigits;
    public static MethodInfo Abs;
    private static DecimalFunctions();
}
internal class Effort.Internal.DbCommandTreeTransformation.Functions.DoubleFunctions : object {
    public static MethodInfo Truncate;
    public static MethodInfo Ceiling;
    public static MethodInfo Floor;
    public static MethodInfo Round;
    public static MethodInfo RoundDigits;
    public static MethodInfo Pow;
    public static MethodInfo Abs;
    private static DoubleFunctions();
}
internal class Effort.Internal.DbCommandTreeTransformation.Functions.GuidFunctions : object {
    public static MethodInfo CompareTo;
    private static GuidFunctions();
}
internal class Effort.Internal.DbCommandTreeTransformation.Functions.IntegerFunctions : object {
    public static MethodInfo Abs64;
    public static MethodInfo Abs32;
    public static MethodInfo Abs16;
    public static MethodInfo Abs8;
    private static IntegerFunctions();
}
internal class Effort.Internal.DbCommandTreeTransformation.Functions.StringFunctions : object {
    public static MethodInfo Concat;
    public static MethodInfo Contains;
    public static MethodInfo ToLower;
    public static MethodInfo ToUpper;
    public static MethodInfo IndexOf;
    public static MethodInfo ReverseString;
    public static MethodInfo Substring;
    public static MethodInfo Trim;
    public static MethodInfo LTrim;
    public static MethodInfo RTrim;
    public static MethodInfo Left;
    public static MethodInfo Right;
    public static MethodInfo Length;
    public static MethodInfo Replace;
    public static MethodInfo StartsWith;
    public static MethodInfo EndsWith;
    public static MethodInfo CompareTo;
    public static MethodInfo ConvertToString;
    public static MethodInfo ParseString;
    public static MethodInfo ContainsCaseInsensitive;
    public static MethodInfo IndexOfCaseInsensitive;
    public static MethodInfo StartsWithCaseInsensitive;
    public static MethodInfo EndsWithCaseInsensitive;
    private static StringFunctions();
}
internal class Effort.Internal.DbCommandTreeTransformation.Functions.TimeFunctions : object {
    public static MethodInfo CreateTime;
    public static MethodInfo GetHour;
    public static MethodInfo GetMinute;
    public static MethodInfo GetSecond;
    public static MethodInfo GetMillisecond;
    public static MethodInfo AddHours;
    public static MethodInfo AddMinutes;
    public static MethodInfo AddSeconds;
    public static MethodInfo AddMilliseconds;
    public static MethodInfo AddMicroseconds;
    public static MethodInfo AddNanoseconds;
    public static MethodInfo DiffHours;
    public static MethodInfo DiffMinutes;
    public static MethodInfo DiffSeconds;
    public static MethodInfo DiffMilliseconds;
    public static MethodInfo DiffMicroseconds;
    public static MethodInfo DiffNanoseconds;
    private static TimeFunctions();
}
internal interface Effort.Internal.DbCommandTreeTransformation.IDbMethodProvider {
    public MethodInfo Like { get; }
    public abstract virtual MethodInfo get_Like();
}
internal interface Effort.Internal.DbCommandTreeTransformation.ITableProvider {
    public abstract virtual object GetTable(TableName name);
}
internal class Effort.Internal.DbCommandTreeTransformation.LinqMethodExpressionBuilder : object {
    private LinqMethodProvider queryMethods;
    public Expression Select(Expression source, LambdaExpression selector);
    public Expression SelectMany(Expression source, LambdaExpression selector);
    public Expression SelectMany(Expression first, LambdaExpression collectionSelector, LambdaExpression resultSelector);
    public Expression Where(Expression source, LambdaExpression predicate);
    public Expression Take(Expression source, Expression count);
    public Expression Skip(Expression source, Expression count);
    public Expression OrderBy(Expression source, LambdaExpression selector);
    public Expression OrderByDescending(Expression source, LambdaExpression selector);
    public Expression ThenBy(Expression source, LambdaExpression selector);
    public Expression ThenByDescending(Expression source, LambdaExpression selector);
    public Expression GroupBy(Expression source, LambdaExpression selector);
    public Expression Distinct(Expression source);
    public Expression FirstOrDefault(Expression source);
    public Expression First(Expression source);
    public Expression Any(Expression source);
    public Expression DefaultIfEmpty(Expression source);
    public Expression AsQueryable(Expression source);
    public Expression Except(Expression first, Expression second);
    public Expression Intersect(Expression first, Expression second);
    public Expression Union(Expression first, Expression second);
    public Expression Concat(Expression first, Expression second);
    public Expression Count(Expression source);
    public Expression LongCount(Expression source);
    public Expression Max(Expression source, LambdaExpression selector);
    public Expression Min(Expression source, LambdaExpression selector);
    public Expression Average(Expression source, LambdaExpression selector);
    public Expression Sum(Expression source, LambdaExpression selector);
    private static MethodInfo GetAggregationMethod(Expression source, LambdaExpression selector, MethodInfoGroup group, Func`1<MethodInfo> generic);
    [CompilerGeneratedAttribute]
private MethodInfo <Max>b__25_0();
    [CompilerGeneratedAttribute]
private MethodInfo <Min>b__26_0();
    [CompilerGeneratedAttribute]
private MethodInfo <Average>b__27_0();
}
internal class Effort.Internal.DbCommandTreeTransformation.LinqMethodProvider : object {
    public static LinqMethodProvider Instance;
    private FastLazy`1<MethodInfo> select;
    private FastLazy`1<MethodInfo> selectMany;
    private FastLazy`1<MethodInfo> selectManyWithResultSelector;
    private FastLazy`1<MethodInfo> count;
    private FastLazy`1<MethodInfo> longCount;
    private FastLazy`1<MethodInfo> where;
    private FastLazy`1<MethodInfo> take;
    private FastLazy`1<MethodInfo> skip;
    private FastLazy`1<MethodInfo> groupBy;
    private FastLazy`1<MethodInfo> orderBy;
    private FastLazy`1<MethodInfo> orderByDescending;
    private FastLazy`1<MethodInfo> thenBy;
    private FastLazy`1<MethodInfo> thenByDescending;
    private FastLazy`1<MethodInfo> firstOrDefault;
    private FastLazy`1<MethodInfo> first;
    private FastLazy`1<MethodInfo> any;
    private FastLazy`1<MethodInfo> defaultIfEmpty;
    private FastLazy`1<MethodInfo> asQueryable;
    private FastLazy`1<MethodInfo> distinct;
    private FastLazy`1<MethodInfo> except;
    private FastLazy`1<MethodInfo> intersect;
    private FastLazy`1<MethodInfo> union;
    private FastLazy`1<MethodInfo> concat;
    private MethodInfoGroup sum;
    private MethodInfoGroup min;
    private MethodInfoGroup max;
    private MethodInfoGroup average;
    private FastLazy`1<MethodInfo> minGeneric;
    private FastLazy`1<MethodInfo> maxGeneric;
    private FastLazy`1<MethodInfo> averageGeneric;
    public MethodInfo Select { get; }
    public MethodInfo SelectMany { get; }
    public MethodInfo SelectManyWithResultSelector { get; }
    public MethodInfo Count { get; }
    public MethodInfo LongCount { get; }
    public MethodInfo Where { get; }
    public MethodInfo Take { get; }
    public MethodInfo Skip { get; }
    public MethodInfo GroupBy { get; }
    public MethodInfo OrderBy { get; }
    public MethodInfo OrderByDescending { get; }
    public MethodInfo ThenBy { get; }
    public MethodInfo ThenByDescending { get; }
    public MethodInfo First { get; }
    public MethodInfo FirstOrDefault { get; }
    public MethodInfo Any { get; }
    public MethodInfo AsQueryable { get; }
    public MethodInfo DefaultIfEmpty { get; }
    public MethodInfo Distinct { get; }
    public MethodInfo Except { get; }
    public MethodInfo Intersect { get; }
    public MethodInfo Union { get; }
    public MethodInfo Concat { get; }
    public MethodInfoGroup Sum { get; }
    public MethodInfoGroup Min { get; }
    public MethodInfoGroup Max { get; }
    public MethodInfoGroup Average { get; }
    public MethodInfo MinGeneric { get; }
    public MethodInfo MaxGeneric { get; }
    public MethodInfo AverageGeneric { get; }
    private static LinqMethodProvider();
    public MethodInfo get_Select();
    public MethodInfo get_SelectMany();
    public MethodInfo get_SelectManyWithResultSelector();
    public MethodInfo get_Count();
    public MethodInfo get_LongCount();
    public MethodInfo get_Where();
    public MethodInfo get_Take();
    public MethodInfo get_Skip();
    public MethodInfo get_GroupBy();
    public MethodInfo get_OrderBy();
    public MethodInfo get_OrderByDescending();
    public MethodInfo get_ThenBy();
    public MethodInfo get_ThenByDescending();
    public MethodInfo get_First();
    public MethodInfo get_FirstOrDefault();
    public MethodInfo get_Any();
    public MethodInfo get_AsQueryable();
    public MethodInfo get_DefaultIfEmpty();
    public MethodInfo get_Distinct();
    public MethodInfo get_Except();
    public MethodInfo get_Intersect();
    public MethodInfo get_Union();
    public MethodInfo get_Concat();
    public MethodInfoGroup get_Sum();
    public MethodInfoGroup get_Min();
    public MethodInfoGroup get_Max();
    public MethodInfoGroup get_Average();
    public MethodInfo get_MinGeneric();
    public MethodInfo get_MaxGeneric();
    public MethodInfo get_AverageGeneric();
    private static MethodInfo CreateSelect();
    private static MethodInfo CreateSelectMany();
    private static MethodInfo CreateSelectManyWithResultSelector();
    private static MethodInfo CreateJoin();
    private static MethodInfo CreateCount();
    private static MethodInfo CreateLongCount();
    private static MethodInfo CreateWhere();
    private static MethodInfo CreateTake();
    private static MethodInfo CreateSkip();
    private static MethodInfo CreateGroupBy();
    private static MethodInfo CreateOrderBy();
    private static MethodInfo CreateOrderByDescending();
    private static MethodInfo CreateThenBy();
    private static MethodInfo CreateThenByDescending();
    private static MethodInfo CreateFirst();
    private static MethodInfo CreateFirstOrDefault();
    private static MethodInfo CreateAny();
    private static MethodInfo CreateDefaultIfEmpty();
    private static MethodInfo CreateAsQueryable();
    private static MethodInfo CreateDistinct();
    private static MethodInfo CreateExcept();
    private static MethodInfo CreateConcat();
    private static MethodInfo CreateUnion();
    private static MethodInfo CreateIntersect();
    private static MethodInfo CreateSumInt();
    private static MethodInfo CreateSumNInt();
    private static MethodInfo CreateSumLong();
    private static MethodInfo CreateSumNLong();
    private static MethodInfo CreateSumFloat();
    private static MethodInfo CreateSumNFloat();
    private static MethodInfo CreateSumDouble();
    private static MethodInfo CreateSumNDouble();
    private static MethodInfo CreateSumDecimal();
    private static MethodInfo CreateSumNDecimal();
    private static MethodInfo CreateMinGeneric();
    private static MethodInfo CreateMinInt();
    private static MethodInfo CreateMinNInt();
    private static MethodInfo CreateMinLong();
    private static MethodInfo CreateMinNLong();
    private static MethodInfo CreateMinFloat();
    private static MethodInfo CreateMinNFloat();
    private static MethodInfo CreateMinDouble();
    private static MethodInfo CreateMinNDouble();
    private static MethodInfo CreateMinDecimal();
    private static MethodInfo CreateMinNDecimal();
    private static MethodInfo CreateMaxGeneric();
    private static MethodInfo CreateMaxInt();
    private static MethodInfo CreateMaxNInt();
    private static MethodInfo CreateMaxLong();
    private static MethodInfo CreateMaxNLong();
    private static MethodInfo CreateMaxFloat();
    private static MethodInfo CreateMaxNFloat();
    private static MethodInfo CreateMaxDouble();
    private static MethodInfo CreateMaxNDouble();
    private static MethodInfo CreateMaxDecimal();
    private static MethodInfo CreateMaxNDecimal();
    private static MethodInfo CreateAvgGeneric();
    private static MethodInfo CreateAvgInt();
    private static MethodInfo CreateAvgNInt();
    private static MethodInfo CreateAvgLong();
    private static MethodInfo CreateAvgNLong();
    private static MethodInfo CreateAvgFloat();
    private static MethodInfo CreateAvgNFloat();
    private static MethodInfo CreateAvgDouble();
    private static MethodInfo CreateAvgNDouble();
    private static MethodInfo CreateAvgDecimal();
    private static MethodInfo CreateAvgNDecimal();
    private static FastLazy`1<MethodInfo> CreateLazy(Func`1<MethodInfo> factory);
    private static MethodInfo GetMethod(Expression`1<Func`2<IQueryable`1<object>, T>> function);
    private static MethodInfo GetOrderedMethod(Expression`1<Func`2<IOrderedQueryable`1<object>, T>> function);
}
[DefaultMemberAttribute("Item")]
internal class Effort.Internal.DbCommandTreeTransformation.MethodInfoGroup : object {
    private Dictionary`2<Type, FastLazy`1<MethodInfo>> methods;
    public MethodInfo Item { get; }
    public MethodInfoGroup(Tuple`2[] methods);
    public MethodInfo get_Item(Type type);
}
internal static class Effort.Internal.DbCommandTreeTransformation.NullableEnumerableExtensionMethods : object {
    public static Nullable`1<decimal> Sum(IEnumerable`1<TSource> source, Func`2<TSource, Nullable`1<decimal>> selector);
    public static Nullable`1<double> Sum(IEnumerable`1<TSource> source, Func`2<TSource, Nullable`1<double>> selector);
    public static Nullable`1<float> Sum(IEnumerable`1<TSource> source, Func`2<TSource, Nullable`1<float>> selector);
    public static Nullable`1<int> Sum(IEnumerable`1<TSource> source, Func`2<TSource, Nullable`1<int>> selector);
    public static Nullable`1<long> Sum(IEnumerable`1<TSource> source, Func`2<TSource, Nullable`1<long>> selector);
}
internal class Effort.Internal.DbCommandTreeTransformation.SingleResult`1 : object {
    private T item;
    public SingleResult`1(T item);
    [IteratorStateMachineAttribute("Effort.Internal.DbCommandTreeTransformation.SingleResult`1/<GetEnumerator>d__2")]
public sealed virtual IEnumerator`1<T> GetEnumerator();
    [IteratorStateMachineAttribute("Effort.Internal.DbCommandTreeTransformation.SingleResult`1/<System-Collections-IEnumerable-GetEnumerator>d__3")]
private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
}
internal class Effort.Internal.DbCommandTreeTransformation.TransformVisitor : DbExpressionVisitor`1<Expression> {
    private Dictionary`2<string, Tuple`2<TypeUsage, int>> parameters;
    private ITableProvider tableProvider;
    private IDbMethodProvider methodProvider;
    private LinqMethodExpressionBuilder queryMethodExpressionBuilder;
    private CanonicalFunctionMapper functionMapper;
    private ITypeConverter converter;
    private EdmTypeConverter edmTypeConverter;
    private VariableCollection currentVariables;
    private DbContainer container;
    public ITableProvider TableProvider { get; public set; }
    public IDbMethodProvider MethodProvider { get; public set; }
    public TransformVisitor(DbContainer container);
    public virtual Expression Visit(DbAndExpression expression);
    public virtual Expression Visit(DbApplyExpression expression);
    public virtual Expression Visit(DbArithmeticExpression expression);
    public virtual Expression Visit(DbCaseExpression expression);
    public virtual Expression Visit(DbCastExpression expression);
    public virtual Expression Visit(DbComparisonExpression expression);
    private Expression CreateComparison(Expression left, Expression right, DbExpressionKind kind);
    private Expression CreateStringComparison(Expression left, Expression right, DbExpressionKind kind);
    private Expression CreateGuidComparison(Expression left, Expression right, DbExpressionKind kind);
    private Tuple`2<int, bool> GetCompareMode(DbExpressionKind kind);
    public virtual Expression Visit(DbConstantExpression expression);
    public virtual Expression Visit(DbCrossJoinExpression expression);
    private Expression CreateCrossJoin(Expression first, LambdaExpression collectionSelector, string firstName, string secondName);
    public void set_TableProvider(ITableProvider value);
    public ITableProvider get_TableProvider();
    public void set_MethodProvider(IDbMethodProvider value);
    public IDbMethodProvider get_MethodProvider();
    public VariableHandler CreateVariable(Expression contextParam, string name);
    public virtual Expression Visit(DbExpression expression);
    private Expression Visit(DbExpression expression, Type requiredType);
    private Expression CreateAggregateFunction(DbFunctionAggregate functionAggregate, string sourceVariableName, Type sourceType, Expression sourceGroup, Type resultType);
    private Expression[] VisitExpressions(IList`1<DbExpression> expressions);
    private Expression CreateSelector(Expression[] arguments, Type resultType);
    public virtual Expression Visit(DbDerefExpression expression);
    public virtual Expression Visit(DbDistinctExpression expression);
    public virtual Expression Visit(DbElementExpression expression);
    public virtual Expression Visit(DbEntityRefExpression expression);
    public virtual Expression Visit(DbExceptExpression expression);
    private void UnifyCollections(Type expectedType, Expression& e1, Expression& e2);
    private void ChangeCollectionType(Type expectedType, Expression& node);
    public virtual Expression Visit(DbFilterExpression expression);
    public virtual Expression Visit(DbFunctionExpression expression);
    public virtual Expression Visit(DbGroupByExpression expression);
    public virtual Expression Visit(DbInExpression expression);
    public virtual Expression Visit(DbIntersectExpression expression);
    public virtual Expression Visit(DbIsEmptyExpression expression);
    public virtual Expression Visit(DbIsNullExpression expression);
    public virtual Expression Visit(DbIsOfExpression expression);
    public virtual Expression Visit(DbJoinExpression expression);
    public virtual Expression Visit(DbLikeExpression expression);
    public virtual Expression Visit(DbLimitExpression expression);
    public virtual Expression Visit(DbNewInstanceExpression expression);
    public virtual Expression Visit(DbNotExpression expression);
    public virtual Expression Visit(DbNullExpression expression);
    public virtual Expression Visit(DbOfTypeExpression expression);
    public virtual Expression Visit(DbOrExpression expression);
    public virtual Expression Visit(DbParameterReferenceExpression expression);
    public virtual Expression Visit(DbProjectExpression expression);
    public virtual Expression Visit(DbPropertyExpression expression);
    public virtual Expression Visit(DbQuantifierExpression expression);
    public virtual Expression Visit(DbRefExpression expression);
    public virtual Expression Visit(DbRefKeyExpression expression);
    public virtual Expression Visit(DbRelationshipNavigationExpression expression);
    public virtual Expression Visit(DbScanExpression expression);
    public virtual Expression Visit(DbSkipExpression expression);
    public virtual Expression Visit(DbSortExpression expression);
    private Expression CreateOrderByExpression(IList`1<DbSortClause> sortorder, string sourceVariableName, Expression source);
    public virtual Expression Visit(DbTreatExpression expression);
    public virtual Expression Visit(DbUnionAllExpression expression);
    public virtual Expression Visit(DbVariableReferenceExpression expression);
}
internal class Effort.Internal.DbCommandTreeTransformation.TraversalVisitor : DbExpressionVisitor`1<object> {
    public virtual object Visit(DbVariableReferenceExpression expression);
    public virtual object Visit(DbUnionAllExpression expression);
    public virtual object Visit(DbTreatExpression expression);
    public virtual object Visit(DbSkipExpression expression);
    public virtual object Visit(DbSortExpression expression);
    public virtual object Visit(DbScanExpression expression);
    public virtual object Visit(DbRelationshipNavigationExpression expression);
    public virtual object Visit(DbRefExpression expression);
    public virtual object Visit(DbQuantifierExpression expression);
    public virtual object Visit(DbPropertyExpression expression);
    public virtual object Visit(DbProjectExpression expression);
    public virtual object Visit(DbParameterReferenceExpression expression);
    public virtual object Visit(DbOrExpression expression);
    public virtual object Visit(DbOfTypeExpression expression);
    public virtual object Visit(DbNullExpression expression);
    public virtual object Visit(DbNotExpression expression);
    public virtual object Visit(DbNewInstanceExpression expression);
    public virtual object Visit(DbLimitExpression expression);
    public virtual object Visit(DbLikeExpression expression);
    public virtual object Visit(DbJoinExpression expression);
    public virtual object Visit(DbIsOfExpression expression);
    public virtual object Visit(DbIsNullExpression expression);
    public virtual object Visit(DbIsEmptyExpression expression);
    public virtual object Visit(DbIntersectExpression expression);
    public virtual object Visit(DbGroupByExpression expression);
    public virtual object Visit(DbRefKeyExpression expression);
    public virtual object Visit(DbEntityRefExpression expression);
    public virtual object Visit(DbFunctionExpression expression);
    public virtual object Visit(DbFilterExpression expression);
    public virtual object Visit(DbExceptExpression expression);
    public virtual object Visit(DbElementExpression expression);
    public virtual object Visit(DbDistinctExpression expression);
    public virtual object Visit(DbDerefExpression expression);
    public virtual object Visit(DbCrossJoinExpression expression);
    public virtual object Visit(DbConstantExpression expression);
    public virtual object Visit(DbComparisonExpression expression);
    public virtual object Visit(DbCastExpression expression);
    public virtual object Visit(DbCaseExpression expression);
    public virtual object Visit(DbArithmeticExpression expression);
    public virtual object Visit(DbApplyExpression expression);
    public virtual object Visit(DbAndExpression expression);
    public virtual object Visit(DbInExpression expression);
    public virtual object Visit(DbExpression expression);
    protected virtual void OnVisited(DbScanExpression expression);
}
internal class Effort.Internal.DbCommandTreeTransformation.Variable : object {
    [CompilerGeneratedAttribute]
private Expression <Expression>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    public Expression Expression { get; public set; }
    public string Name { get; public set; }
    [CompilerGeneratedAttribute]
public Expression get_Expression();
    [CompilerGeneratedAttribute]
public void set_Expression(Expression value);
    [CompilerGeneratedAttribute]
public string get_Name();
    [CompilerGeneratedAttribute]
public void set_Name(string value);
}
internal class Effort.Internal.DbCommandTreeTransformation.VariableCollection : object {
    private Dictionary`2<string, Variable> variables;
    public void Add(Variable context);
    public Variable GetVariable(string name);
    public void Delete(Variable context);
}
internal class Effort.Internal.DbCommandTreeTransformation.VariableHandler : object {
    private VariableCollection collection;
    private Variable variable;
    public Variable Context { get; }
    public VariableHandler(Variable variable, VariableCollection collection);
    public Variable get_Context();
    public sealed virtual void Dispose();
}
internal class Effort.Internal.DbManagement.CanonicalContainer : object {
    private EdmTypeConverter converter;
    private List`1<EntityContainer> containers;
    private Lazy`1<ReadOnlyCollection`1<EntityInfo>> entities;
    private Lazy`1<ReadOnlyCollection`1<AssociationInfo>> associations;
    public ReadOnlyCollection`1<EntityInfo> Entities { get; }
    public ReadOnlyCollection`1<AssociationInfo> Associations { get; }
    public CanonicalContainer(ItemCollection source, EdmTypeConverter converter);
    public ReadOnlyCollection`1<EntityInfo> get_Entities();
    public ReadOnlyCollection`1<AssociationInfo> get_Associations();
    [IteratorStateMachineAttribute("Effort.Internal.DbManagement.CanonicalContainer/<GetEntities>d__9")]
private IEnumerable`1<EntityInfo> GetEntities();
    [IteratorStateMachineAttribute("Effort.Internal.DbManagement.CanonicalContainer/<GetProperties>d__10")]
private IEnumerable`1<EntityPropertyInfo> GetProperties(IEnumerable`1<EdmProperty> props, EdmTypeConverter converter);
    [IteratorStateMachineAttribute("Effort.Internal.DbManagement.CanonicalContainer/<GetIndexes>d__11")]
private static IEnumerable`1<IndexInfo> GetIndexes(EdmProperty prop);
    private static IndexInfo GetIndexInfo(object index);
    [IteratorStateMachineAttribute("Effort.Internal.DbManagement.CanonicalContainer/<GetAssociations>d__13")]
private IEnumerable`1<AssociationInfo> GetAssociations();
    private String[] GetPropertyNames(IEnumerable`1<EdmProperty> properties);
    private TableName GetTable(AssociationSet association, RelationshipEndMember relationEndpoint);
    [CompilerGeneratedAttribute]
private ReadOnlyCollection`1<EntityInfo> <.ctor>b__4_0();
    [CompilerGeneratedAttribute]
private ReadOnlyCollection`1<AssociationInfo> <.ctor>b__4_1();
}
internal class Effort.Internal.DbManagement.DbContainer : object {
    internal Database database;
    private List`1<TableName> tableNames;
    private ITypeConverter converter;
    private DbContainerParameters parameters;
    private ILogger logger;
    private ConcurrentDictionary`2<string, IStoredProcedure> transformCache;
    private bool isCaseSensitive;
    public Database Internal { get; }
    public ILogger Logger { get; }
    public ConcurrentDictionary`2<string, IStoredProcedure> TransformCache { get; }
    public bool IsCaseSensitive { get; public set; }
    public ITypeConverter TypeConverter { get; }
    public IList`1<TableName> TableNames { get; }
    public DbContainer(DbContainerParameters parameters);
    public Database get_Internal();
    public ILogger get_Logger();
    public ConcurrentDictionary`2<string, IStoredProcedure> get_TransformCache();
    public bool get_IsCaseSensitive();
    public void set_IsCaseSensitive(bool value);
    public ITypeConverter get_TypeConverter();
    public IList`1<TableName> get_TableNames();
    public sealed virtual object GetTable(TableName name);
    public object GetAllTables();
    public void SetIdentityFields(bool enabled);
    public bool IsInitialized(StoreItemCollection edmStoreSchema);
    public void Initialize(StoreItemCollection edmStoreSchema);
    public void Initialize(DbSchema schema);
    private void EnsureInitializedDatabase();
    private ITableDataLoaderFactory CreateDataLoaderFactory();
}
internal class Effort.Internal.DbManagement.DbContainerManagerWrapper : object {
    private DbContainer container;
    private static string MigrationHistoryTable;
    public DbContainerManagerWrapper(DbContainer container);
    private static DbContainerManagerWrapper();
    public sealed virtual void SetIdentityFields(bool enabled);
    public sealed virtual void SetIdentity(Nullable`1<int> seed, Nullable`1<int> increment);
    public sealed virtual void ClearMigrationHistory();
    public sealed virtual void ClearTables();
    private void SetRelations(bool enabled);
    internal IExtendedTable TryGetTable();
}
internal class Effort.Internal.DbManagement.DbContainerParameters : object {
    [CompilerGeneratedAttribute]
private IDataLoader <DataLoader>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsTransient>k__BackingField;
    public IDataLoader DataLoader { get; public set; }
    public bool IsTransient { get; public set; }
    [CompilerGeneratedAttribute]
public IDataLoader get_DataLoader();
    [CompilerGeneratedAttribute]
public void set_DataLoader(IDataLoader value);
    [CompilerGeneratedAttribute]
public bool get_IsTransient();
    [CompilerGeneratedAttribute]
public void set_IsTransient(bool value);
}
[ExtensionAttribute]
internal static class Effort.Internal.DbManagement.DbExtensions : object {
    [ExtensionAttribute]
public static ITable GetTable(Database database, TableName name);
    [ExtensionAttribute]
public static List`1<ITable> GetAllTables(Database database);
    [ExtensionAttribute]
public static bool ContainsTable(Database database, TableName name);
}
internal class Effort.Internal.DbManagement.DbMethodProvider : object {
    public MethodInfo Like { get; }
    public sealed virtual MethodInfo get_Like();
}
internal class Effort.Internal.DbManagement.Engine.DatabaseComponentFactory : DefaultDatabaseComponentFactory {
    private bool isTransient;
    public DatabaseComponentFactory(bool isTransient);
    public virtual IQueryCompiler CreateQueryCompiler();
    public virtual IConcurrencyManager CreateConcurrencyManager();
    public virtual IServiceProvider CreateServiceProvider();
}
internal class Effort.Internal.DbManagement.Engine.ExtendedQueryCompiler : QueryCompiler {
    protected virtual Expression PostprocessExpression(Expression expression, ITransformationContext context);
    [IteratorStateMachineAttribute("Effort.Internal.DbManagement.Engine.ExtendedQueryCompiler/<GetRewriters>d__2")]
protected virtual IEnumerable`1<IExpressionRewriter> GetRewriters(Expression expression, ITransformationContext context);
    [IteratorStateMachineAttribute("Effort.Internal.DbManagement.Engine.ExtendedQueryCompiler/<GetPostprocessingRewriters>d__3")]
protected virtual IEnumerable`1<IExpressionRewriter> GetPostprocessingRewriters(Expression expression, ITransformationContext context);
    [CompilerGeneratedAttribute]
[DebuggerHiddenAttribute]
private IEnumerable`1<IExpressionRewriter> <>n__0(Expression expression, ITransformationContext context);
}
internal class Effort.Internal.DbManagement.Engine.ExtendedServiceProvider : DefaultServiceProvider {
}
internal class Effort.Internal.DbManagement.Engine.ExtendedTable`2 : DefaultTable`2<TEntity, TPrimaryKey> {
    private bool identityEnabled;
    private bool wasRecordAdded;
    public bool IsIdentityFieldEnabled { get; public set; }
    public ExtendedTable`2(IDatabase database, IKeyInfo`2<TEntity, TPrimaryKey> primaryKey, IdentitySpecification`1<TEntity> identity, object tableInfo);
    public sealed virtual bool get_IsIdentityFieldEnabled();
    public sealed virtual void set_IsIdentityFieldEnabled(bool value);
    public sealed virtual void Initialize(IEnumerable`1<TEntity> entities);
    public sealed virtual void Clear();
    protected virtual void InsertCore(TEntity entity, Transaction transaction);
    protected virtual void GenerateIdentityFieldValue(TEntity entity);
    private sealed virtual override void Effort.Internal.DbManagement.Engine.IExtendedTable.SetIdentity(Nullable`1<int> seed, Nullable`1<int> increment);
}
internal class Effort.Internal.DbManagement.Engine.ExtendedTableService : object {
    public sealed virtual Table`2<TEntity, TPrimaryKey> CreateTable(IKeyInfo`2<TEntity, TPrimaryKey> primaryKey, IdentitySpecification`1<TEntity> identitySpecification, IDatabase database, object tableInfo);
    public sealed virtual Table`2<TEntity, TPrimaryKey> CreateTable(IKeyInfo`2<TEntity, TPrimaryKey> primaryKey, IdentitySpecification`1<TEntity> identitySpecification, IDatabase database);
}
internal interface Effort.Internal.DbManagement.Engine.IExtendedTable {
    public bool IsIdentityFieldEnabled { get; public set; }
    public abstract virtual bool get_IsIdentityFieldEnabled();
    public abstract virtual void set_IsIdentityFieldEnabled(bool value);
    public abstract virtual void SetIdentity(Nullable`1<int> seed, Nullable`1<int> increment);
    public abstract virtual void Clear();
}
internal interface Effort.Internal.DbManagement.Engine.IExtendedTable`1 {
    public abstract virtual void Initialize(IEnumerable`1<TEntity> entities);
}
internal class Effort.Internal.DbManagement.Engine.Modifiers.ExcrescentInitializationCleanserVisitor : ExpressionRewriterBase {
    protected virtual Expression VisitMember(MemberExpression node);
}
internal class Effort.Internal.DbManagement.Engine.Modifiers.ExcrescentSingleResultCleanserVisitor : ExpressionRewriterBase {
    protected virtual Expression VisitMethodCall(MethodCallExpression node);
}
internal class Effort.Internal.DbManagement.Engine.Modifiers.SumTransformerVisitor : ExpressionRewriterBase {
    protected virtual Expression VisitMethodCall(MethodCallExpression node);
}
internal class Effort.Internal.DbManagement.Engine.Services.DataRowKeyInfo`2 : KeyInfoBase`2<TEntity, TKey> {
    internal static IKeyInfoHelper KeyInfoHelper;
    private IKeyInfoHelper NMemory.Indexes.IKeyInfoHelperProvider.KeyInfoHelper { get; }
    public DataRowKeyInfo`2(MemberInfo[] entityKeyMembers);
    private static DataRowKeyInfo`2();
    private sealed virtual override IKeyInfoHelper NMemory.Indexes.IKeyInfoHelperProvider.get_KeyInfoHelper();
}
internal class Effort.Internal.DbManagement.Engine.Services.DataRowKeyInfoHelper : object {
    private Type type;
    private PropertyInfo[] properties;
    private bool isLarge;
    private ConstructorInfo ctor;
    public DataRowKeyInfoHelper(Type type);
    public sealed virtual Expression CreateKeyFactoryExpression(Expression[] arguments);
    public sealed virtual Expression CreateKeyMemberSelectorExpression(Expression source, int index);
    public sealed virtual int GetMemberCount();
    public sealed virtual bool TryParseKeySelectorExpression(Expression keySelector, bool strict, MemberInfo[]& result);
}
internal class Effort.Internal.DbManagement.Engine.Services.DataRowKeyInfoService : object {
    public sealed virtual bool TryCreateKeyInfo(Expression`1<Func`2<TEntity, TKey>> keySelector, IKeyInfo`2& result);
    public sealed virtual bool TryCreateKeyInfoHelper(Type keyType, IKeyInfoHelper& result);
}
internal class Effort.Internal.DbManagement.Engine.Services.ExtendedKeyInfoFactory : ModularKeyInfoFactory {
    public static IKeyInfoFactory Instance;
    private static ExtendedKeyInfoFactory();
    public static IKeyInfoService CreateFactoryService();
}
internal class Effort.Internal.DbManagement.Schema.BareSchemaBase : object {
    private Dictionary`2<TableName, Type> entityTypes;
    public Type[] EntityTypes { get; }
    public TableName[] Tables { get; }
    public sealed virtual Type GetEntityType(TableName tableName);
    public sealed virtual TableName GetTableName(Type entityType);
    public sealed virtual Type[] get_EntityTypes();
    public sealed virtual TableName[] get_Tables();
    protected void Register(TableName tableName, Type entityType);
}
internal class Effort.Internal.DbManagement.Schema.Configuration.AssociationInfo : object {
    [CompilerGeneratedAttribute]
private AssociationTableInfo <PrimaryTable>k__BackingField;
    [CompilerGeneratedAttribute]
private AssociationTableInfo <ForeignTable>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <CascadedDelete>k__BackingField;
    public AssociationTableInfo PrimaryTable { get; private set; }
    public AssociationTableInfo ForeignTable { get; private set; }
    public bool CascadedDelete { get; private set; }
    public AssociationInfo(AssociationTableInfo primary, AssociationTableInfo foreign, bool cascadedDelete);
    [CompilerGeneratedAttribute]
public AssociationTableInfo get_PrimaryTable();
    [CompilerGeneratedAttribute]
private void set_PrimaryTable(AssociationTableInfo value);
    [CompilerGeneratedAttribute]
public AssociationTableInfo get_ForeignTable();
    [CompilerGeneratedAttribute]
private void set_ForeignTable(AssociationTableInfo value);
    [CompilerGeneratedAttribute]
public bool get_CascadedDelete();
    [CompilerGeneratedAttribute]
private void set_CascadedDelete(bool value);
}
internal class Effort.Internal.DbManagement.Schema.Configuration.AssociationTableInfo : object {
    [CompilerGeneratedAttribute]
private TableName <TableName>k__BackingField;
    [CompilerGeneratedAttribute]
private ReadOnlyCollection`1<string> <PropertyNames>k__BackingField;
    public TableName TableName { get; private set; }
    public ReadOnlyCollection`1<string> PropertyNames { get; private set; }
    public AssociationTableInfo(TableName tableName, String[] properties);
    [CompilerGeneratedAttribute]
public TableName get_TableName();
    [CompilerGeneratedAttribute]
private void set_TableName(TableName value);
    [CompilerGeneratedAttribute]
public ReadOnlyCollection`1<string> get_PropertyNames();
    [CompilerGeneratedAttribute]
private void set_PropertyNames(ReadOnlyCollection`1<string> value);
}
internal class Effort.Internal.DbManagement.Schema.Configuration.BareSchemaConfiguration : object {
    private IBareSchema schema;
    public BareSchemaConfiguration(IBareSchema schema);
    public sealed virtual void Configure(EntityInfo entityInfo, DbTableInfoBuilder builder);
}
internal class Effort.Internal.DbManagement.Schema.Configuration.CharLimitConfiguration : object {
    public sealed virtual void Configure(EntityInfo entityInfo, DbTableInfoBuilder builder);
}
internal class Effort.Internal.DbManagement.Schema.Configuration.EntityInfo : object {
    private ReadOnlyCollection`1<EntityPropertyInfo> properties;
    private ReadOnlyCollection`1<EntityPropertyInfo> keyMembers;
    private TableName tableName;
    [CompilerGeneratedAttribute]
private EntitySet <EntitySet>k__BackingField;
    public ReadOnlyCollection`1<EntityPropertyInfo> Properties { get; }
    public TableName TableName { get; }
    public ReadOnlyCollection`1<EntityPropertyInfo> KeyMembers { get; }
    public EntitySet EntitySet { get; private set; }
    public EntityInfo(EntitySet entitySet, TableName tableName, IEnumerable`1<EntityPropertyInfo> properties, String[] keyMembers);
    public ReadOnlyCollection`1<EntityPropertyInfo> get_Properties();
    public TableName get_TableName();
    public ReadOnlyCollection`1<EntityPropertyInfo> get_KeyMembers();
    [CompilerGeneratedAttribute]
public EntitySet get_EntitySet();
    [CompilerGeneratedAttribute]
private void set_EntitySet(EntitySet value);
}
internal class Effort.Internal.DbManagement.Schema.Configuration.EntityPropertyInfo : object {
    private string name;
    private Type type;
    private FacetInfo facets;
    private ReadOnlyCollection`1<IndexInfo> indexes;
    public string Name { get; }
    public FacetInfo Facets { get; }
    public Type ClrType { get; }
    public IList`1<IndexInfo> Indexes { get; }
    public EntityPropertyInfo(string name, Type type, FacetInfo facets, List`1<IndexInfo> indexes);
    public string get_Name();
    public FacetInfo get_Facets();
    public Type get_ClrType();
    public IList`1<IndexInfo> get_Indexes();
}
internal class Effort.Internal.DbManagement.Schema.Configuration.GeneratedGuidConfiguration : object {
    public sealed virtual void Configure(EntityInfo entityInfo, DbTableInfoBuilder builder);
}
internal class Effort.Internal.DbManagement.Schema.Configuration.IdentityConfiguration : object {
    public sealed virtual void Configure(EntityInfo entityInfo, DbTableInfoBuilder builder);
    private static bool IsIdentityType(Type fieldType);
}
internal class Effort.Internal.DbManagement.Schema.Configuration.IndexConfiguration : object {
    public sealed virtual void Configure(EntityInfo entityInfo, DbTableInfoBuilder builder);
}
internal class Effort.Internal.DbManagement.Schema.Configuration.IndexInfo : object {
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    [CompilerGeneratedAttribute]
private int <Order>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsUnique>k__BackingField;
    public string Name { get; private set; }
    public int Order { get; private set; }
    public bool IsUnique { get; private set; }
    public IndexInfo(string name, int order, bool unique);
    [CompilerGeneratedAttribute]
public string get_Name();
    [CompilerGeneratedAttribute]
private void set_Name(string value);
    [CompilerGeneratedAttribute]
public int get_Order();
    [CompilerGeneratedAttribute]
private void set_Order(int value);
    [CompilerGeneratedAttribute]
public bool get_IsUnique();
    [CompilerGeneratedAttribute]
private void set_IsUnique(bool value);
}
internal interface Effort.Internal.DbManagement.Schema.Configuration.IRelationConfiguration {
    public abstract virtual void Configure(AssociationInfo entityInfo, DbSchemaBuilder builder);
}
internal interface Effort.Internal.DbManagement.Schema.Configuration.ITableConfiguration {
    public abstract virtual void Configure(EntityInfo entityInfo, DbTableInfoBuilder builder);
}
internal class Effort.Internal.DbManagement.Schema.Configuration.NotNullConfiguration : object {
    public sealed virtual void Configure(EntityInfo entityInfo, DbTableInfoBuilder builder);
}
internal class Effort.Internal.DbManagement.Schema.Configuration.PrimaryKeyConfiguration : object {
    public sealed virtual void Configure(EntityInfo entityInfo, DbTableInfoBuilder builder);
}
internal class Effort.Internal.DbManagement.Schema.Configuration.RelationConfiguration : object {
    private static MethodInfo PrimaryToForeignConverterMethod;
    private static MethodInfo ForeignToPrimaryConverterMethod;
    private static RelationConfiguration();
    public sealed virtual void Configure(AssociationInfo associationInfo, DbSchemaBuilder builder);
    public static IKeyInfo EnsureKey(MemberInfo[] members, bool unique, DbTableInfoBuilder tableBuilder);
    private static MemberInfo[] GetMembers(Type entityType, ICollection`1<string> properties);
    private static Delegate CreateConverter(MethodInfo converterMethod, IKeyInfo primaryKeyInfo, IKeyInfo foreignKeyInfo, IRelationContraint[] relationConstraints);
}
internal class Effort.Internal.DbManagement.Schema.Configuration.RelationConfigurationGroup : object {
    private IList`1<IRelationConfiguration> members;
    public void Register();
    public void Register(T configuration);
    public sealed virtual void Configure(AssociationInfo associationInfo, DbSchemaBuilder builder);
}
internal class Effort.Internal.DbManagement.Schema.Configuration.TableConfigurationGroup : object {
    private IList`1<ITableConfiguration> members;
    public void Register();
    public void Register(T configuration);
    public sealed virtual void Configure(EntityInfo entityInfo, DbTableInfoBuilder builder);
}
internal class Effort.Internal.DbManagement.Schema.Configuration.VarcharLimitConfiguration : object {
    public sealed virtual void Configure(EntityInfo entityInfo, DbTableInfoBuilder builder);
}
internal class Effort.Internal.DbManagement.Schema.Constraints.CharLimitConstraintFactory`1 : ConstraintFactoryBase`2<TEntity, string> {
    private int maxLength;
    public CharLimitConstraintFactory`1(IEntityMemberInfo`2<TEntity, string> member, int maxLength);
    protected virtual IConstraint`1<TEntity> Create(IEntityMemberInfo`2<TEntity, string> member);
}
internal static class Effort.Internal.DbManagement.Schema.Constraints.ConstraintFactories : object {
    public static object NotNull(MemberInfo member);
    public static object GeneratedGuid(MemberInfo member);
    public static object CharLimit(MemberInfo member, int maxLength);
    public static object VarCharLimit(MemberInfo member, int maxLength);
    private static object Create(Type factory, MemberInfo member, Object[] args);
    private static IEntityMemberInfo CreateEntityMemberInfo(MemberInfo member);
    private static object CreateFactory(Type factoryType, IEntityMemberInfo member, Object[] args);
}
internal abstract class Effort.Internal.DbManagement.Schema.Constraints.ConstraintFactoryBase`2 : object {
    private IEntityMemberInfo`2<TEntity, TMember> member;
    public ConstraintFactoryBase`2(IEntityMemberInfo`2<TEntity, TMember> member);
    public sealed virtual IConstraint`1<TEntity> Create();
    protected abstract virtual IConstraint`1<TEntity> Create(IEntityMemberInfo`2<TEntity, TMember> member);
}
internal class Effort.Internal.DbManagement.Schema.Constraints.GeneratedGuidConstraintFactory`1 : ConstraintFactoryBase`2<TEntity, Guid> {
    public GeneratedGuidConstraintFactory`1(IEntityMemberInfo`2<TEntity, Guid> member);
    protected virtual IConstraint`1<TEntity> Create(IEntityMemberInfo`2<TEntity, Guid> member);
}
internal class Effort.Internal.DbManagement.Schema.Constraints.NotNullableConstraintFactory`2 : ConstraintFactoryBase`2<TEntity, TMember> {
    public NotNullableConstraintFactory`2(IEntityMemberInfo`2<TEntity, TMember> member);
    protected virtual IConstraint`1<TEntity> Create(IEntityMemberInfo`2<TEntity, TMember> member);
}
internal class Effort.Internal.DbManagement.Schema.Constraints.VarCharLimitConstraintFactory`1 : ConstraintFactoryBase`2<TEntity, string> {
    private int maxLength;
    public VarCharLimitConstraintFactory`1(IEntityMemberInfo`2<TEntity, string> member, int maxLength);
    protected virtual IConstraint`1<TEntity> Create(IEntityMemberInfo`2<TEntity, string> member);
}
internal class Effort.Internal.DbManagement.Schema.DbRelationInfo : object {
    [CompilerGeneratedAttribute]
private TableName <PrimaryTable>k__BackingField;
    [CompilerGeneratedAttribute]
private TableName <ForeignTable>k__BackingField;
    [CompilerGeneratedAttribute]
private IKeyInfo <PrimaryKeyInfo>k__BackingField;
    [CompilerGeneratedAttribute]
private IKeyInfo <ForeignKeyInfo>k__BackingField;
    [CompilerGeneratedAttribute]
private Delegate <PrimaryToForeignConverter>k__BackingField;
    [CompilerGeneratedAttribute]
private Delegate <ForeignToPrimaryConverter>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <CascadedDelete>k__BackingField;
    public TableName PrimaryTable { get; private set; }
    public TableName ForeignTable { get; private set; }
    public IKeyInfo PrimaryKeyInfo { get; private set; }
    public IKeyInfo ForeignKeyInfo { get; private set; }
    public Delegate PrimaryToForeignConverter { get; private set; }
    public Delegate ForeignToPrimaryConverter { get; private set; }
    public bool CascadedDelete { get; private set; }
    public DbRelationInfo(TableName primaryTable, TableName foreignTable, IKeyInfo primaryKeyInfo, IKeyInfo foreignKeyInfo, Delegate primaryToForeignConverter, Delegate foreignToPrimaryConverter, bool cascadedDelete);
    [CompilerGeneratedAttribute]
public TableName get_PrimaryTable();
    [CompilerGeneratedAttribute]
private void set_PrimaryTable(TableName value);
    [CompilerGeneratedAttribute]
public TableName get_ForeignTable();
    [CompilerGeneratedAttribute]
private void set_ForeignTable(TableName value);
    [CompilerGeneratedAttribute]
public IKeyInfo get_PrimaryKeyInfo();
    [CompilerGeneratedAttribute]
private void set_PrimaryKeyInfo(IKeyInfo value);
    [CompilerGeneratedAttribute]
public IKeyInfo get_ForeignKeyInfo();
    [CompilerGeneratedAttribute]
private void set_ForeignKeyInfo(IKeyInfo value);
    [CompilerGeneratedAttribute]
public Delegate get_PrimaryToForeignConverter();
    [CompilerGeneratedAttribute]
private void set_PrimaryToForeignConverter(Delegate value);
    [CompilerGeneratedAttribute]
public Delegate get_ForeignToPrimaryConverter();
    [CompilerGeneratedAttribute]
private void set_ForeignToPrimaryConverter(Delegate value);
    [CompilerGeneratedAttribute]
public bool get_CascadedDelete();
    [CompilerGeneratedAttribute]
private void set_CascadedDelete(bool value);
}
internal class Effort.Internal.DbManagement.Schema.DbSchema : object {
    private Dictionary`2<TableName, DbTableInfo> tableLookup;
    private List`1<DbTableInfo> tables;
    private List`1<DbRelationInfo> relations;
    public ICollection`1<DbTableInfo> Tables { get; }
    public ICollection`1<DbRelationInfo> Relations { get; }
    public DbSchema(IEnumerable`1<DbTableInfo> tables, IEnumerable`1<DbRelationInfo> relations);
    public DbTableInfo GetTable(TableName tableName);
    public TableName[] GetTableNames();
    public ICollection`1<DbTableInfo> get_Tables();
    public ICollection`1<DbRelationInfo> get_Relations();
}
internal class Effort.Internal.DbManagement.Schema.DbSchemaBuilder : object {
    private IList`1<DbTableInfoBuilder> tables;
    private IList`1<DbRelationInfo> relations;
    public void Register(DbTableInfoBuilder table);
    public void Register(DbRelationInfo relation);
    public DbTableInfoBuilder Find(TableName tableName);
    public DbSchema Create();
}
internal static class Effort.Internal.DbManagement.Schema.DbSchemaFactory : object {
    public static DbSchema CreateDbSchema(StoreItemCollection edmStoreSchema);
}
public class Effort.Internal.DbManagement.Schema.DbTableInfo : object {
    private FastLazy`1<Func`2<Object[], object>> initializer;
    [CompilerGeneratedAttribute]
private EntitySet <EntitySet>k__BackingField;
    [CompilerGeneratedAttribute]
private TableName <TableName>k__BackingField;
    [CompilerGeneratedAttribute]
private Type <EntityType>k__BackingField;
    [CompilerGeneratedAttribute]
private MemberInfo <IdentityField>k__BackingField;
    [CompilerGeneratedAttribute]
private PropertyInfo[] <Properties>k__BackingField;
    [CompilerGeneratedAttribute]
private Object[] <ConstraintFactories>k__BackingField;
    [CompilerGeneratedAttribute]
private IKeyInfo <PrimaryKeyInfo>k__BackingField;
    [CompilerGeneratedAttribute]
private IKeyInfo[] <ForeignKeys>k__BackingField;
    [CompilerGeneratedAttribute]
private IKeyInfo[] <UniqueKeys>k__BackingField;
    public EntitySet EntitySet { get; public set; }
    public TableName TableName { get; private set; }
    public Type EntityType { get; private set; }
    public MemberInfo IdentityField { get; private set; }
    public PropertyInfo[] Properties { get; private set; }
    public Object[] ConstraintFactories { get; private set; }
    public IKeyInfo PrimaryKeyInfo { get; private set; }
    public IKeyInfo[] ForeignKeys { get; private set; }
    public IKeyInfo[] UniqueKeys { get; private set; }
    public Func`2<Object[], object> EntityInitializer { get; }
    public DbTableInfo(EntitySet entitySet, TableName tableName, Type entityType, MemberInfo identityField, PropertyInfo[] properties, IKeyInfo primaryKeyInfo, IKeyInfo[] uniqueKeys, IKeyInfo[] foreignKeys, Object[] constraintFactories);
    [CompilerGeneratedAttribute]
public EntitySet get_EntitySet();
    [CompilerGeneratedAttribute]
public void set_EntitySet(EntitySet value);
    [CompilerGeneratedAttribute]
public TableName get_TableName();
    [CompilerGeneratedAttribute]
private void set_TableName(TableName value);
    [CompilerGeneratedAttribute]
public Type get_EntityType();
    [CompilerGeneratedAttribute]
private void set_EntityType(Type value);
    [CompilerGeneratedAttribute]
public MemberInfo get_IdentityField();
    [CompilerGeneratedAttribute]
private void set_IdentityField(MemberInfo value);
    [CompilerGeneratedAttribute]
public PropertyInfo[] get_Properties();
    [CompilerGeneratedAttribute]
private void set_Properties(PropertyInfo[] value);
    [CompilerGeneratedAttribute]
public Object[] get_ConstraintFactories();
    [CompilerGeneratedAttribute]
private void set_ConstraintFactories(Object[] value);
    [CompilerGeneratedAttribute]
public IKeyInfo get_PrimaryKeyInfo();
    [CompilerGeneratedAttribute]
private void set_PrimaryKeyInfo(IKeyInfo value);
    [CompilerGeneratedAttribute]
public IKeyInfo[] get_ForeignKeys();
    [CompilerGeneratedAttribute]
private void set_ForeignKeys(IKeyInfo[] value);
    [CompilerGeneratedAttribute]
public IKeyInfo[] get_UniqueKeys();
    [CompilerGeneratedAttribute]
private void set_UniqueKeys(IKeyInfo[] value);
    public Func`2<Object[], object> get_EntityInitializer();
    private Func`2<Object[], object> CreateEntityInitializer();
    private void HandleConvertException(Exception exception, PropertyInfo property, object value);
}
internal class Effort.Internal.DbManagement.Schema.DbTableInfoBuilder : object {
    private IList`1<IKeyInfo> uniqueKeys;
    private IList`1<IKeyInfo> otherKeys;
    private IList`1<object> constraintFactories;
    private Type entityType;
    private ILookup`2<string, PropertyInfo> members;
    [CompilerGeneratedAttribute]
private IKeyInfo <PrimaryKey>k__BackingField;
    [CompilerGeneratedAttribute]
private MemberInfo <IdentityField>k__BackingField;
    [CompilerGeneratedAttribute]
private TableName <Name>k__BackingField;
    [CompilerGeneratedAttribute]
private EntitySet <EntitySet>k__BackingField;
    public IKeyInfo PrimaryKey { get; public set; }
    public MemberInfo IdentityField { get; public set; }
    public TableName Name { get; public set; }
    public EntitySet EntitySet { get; public set; }
    public Type EntityType { get; public set; }
    protected IEnumerable`1<IKeyInfo> AllKeys { get; }
    protected IEnumerable`1<IKeyInfo> AllUniqueKeys { get; }
    [CompilerGeneratedAttribute]
public IKeyInfo get_PrimaryKey();
    [CompilerGeneratedAttribute]
public void set_PrimaryKey(IKeyInfo value);
    [CompilerGeneratedAttribute]
public MemberInfo get_IdentityField();
    [CompilerGeneratedAttribute]
public void set_IdentityField(MemberInfo value);
    [CompilerGeneratedAttribute]
public TableName get_Name();
    [CompilerGeneratedAttribute]
public void set_Name(TableName value);
    [CompilerGeneratedAttribute]
public EntitySet get_EntitySet();
    [CompilerGeneratedAttribute]
public void set_EntitySet(EntitySet value);
    public Type get_EntityType();
    public void set_EntityType(Type value);
    protected IEnumerable`1<IKeyInfo> get_AllKeys();
    protected IEnumerable`1<IKeyInfo> get_AllUniqueKeys();
    public void AddKey(IKeyInfo key, bool isUnique);
    public void AddContraintFactory(object constraintFactory);
    public IKeyInfo FindKey(MemberInfo[] members, bool strictOrder, bool unique);
    public PropertyInfo FindMember(EntityPropertyInfo property);
    public PropertyInfo FindMember(string name);
    public DbTableInfo Create();
}
internal class Effort.Internal.DbManagement.Schema.DynamicBareSchema : BareSchemaBase {
    private Assembly dynamicAssembly;
    public DynamicBareSchema(CanonicalContainer container);
    private static Type CreateEntityType(EntityInfo entity, ModuleBuilder entityModule);
}
internal interface Effort.Internal.DbManagement.Schema.IBareSchema {
    public Type[] EntityTypes { get; }
    public TableName[] Tables { get; }
    public abstract virtual Type GetEntityType(TableName tableName);
    public abstract virtual TableName GetTableName(Type entityType);
    public abstract virtual Type[] get_EntityTypes();
    public abstract virtual TableName[] get_Tables();
}
internal static class Effort.Internal.DbManagement.Schema.KeyInfoHelper : object {
    public static IKeyInfo CreateKeyInfo(Type entityType, MemberInfo[] properties);
    public static IKeyInfo CreateKeyInfo(LambdaExpression selector);
    private static LambdaExpression CreateSelectorExpression(Type sourceType, MemberInfo[] selectorFields);
    private static Expression CreateTupleSelector(Expression body, Expression[] memberSelectors);
    private static Expression CreateDataRowSelector(Expression body, Expression[] memberSelectors);
}
public class Effort.Internal.DbManagement.Schema.TableName : object {
    [CompilerGeneratedAttribute]
private string <Schema>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    public string Schema { get; public set; }
    public string Name { get; public set; }
    public string FullName { get; }
    public TableName(string schema, string name);
    [CompilerGeneratedAttribute]
public string get_Schema();
    [CompilerGeneratedAttribute]
public void set_Schema(string value);
    [CompilerGeneratedAttribute]
public string get_Name();
    [CompilerGeneratedAttribute]
public void set_Name(string value);
    public string get_FullName();
    public virtual int GetHashCode();
    public virtual bool Equals(object obj);
    public sealed virtual bool Equals(TableName other);
    public sealed virtual int CompareTo(TableName other);
}
internal interface Effort.Internal.Diagnostics.ILogger {
    public abstract virtual void Write(string message);
    public abstract virtual void Write(string message, Object[] args);
}
internal class Effort.Internal.Diagnostics.Logger : object {
    private TraceSource source;
    public sealed virtual void Write(string message);
    public sealed virtual void Write(string message, Object[] args);
}
[ExtensionAttribute]
internal static class Effort.Internal.InternalExtensions : object {
    [ExtensionAttribute]
internal static EntityConnection GetEntityConnection(Database database);
}
internal class Effort.Internal.StorageSchema.CommonPropertyElementModifier : object {
    private StorageSchemaContentNameProvider nameProvider;
    private IEnumerable`1<XName> CommonPropertyAttributeNames { get; }
    public CommonPropertyElementModifier(StorageSchemaContentNameProvider nameProvider);
    [IteratorStateMachineAttribute("Effort.Internal.StorageSchema.CommonPropertyElementModifier/<get_CommonPropertyAttributeNames>d__3")]
private IEnumerable`1<XName> get_CommonPropertyAttributeNames();
    public sealed virtual void Modify(XElement element, IModificationContext context);
}
internal class Effort.Internal.StorageSchema.EffortProviderInformation : ProviderInformation {
}
internal class Effort.Internal.StorageSchema.EntityTypePropertyElementSelector : object {
    private StorageSchemaContentNameProvider nameProvider;
    public EntityTypePropertyElementSelector(StorageSchemaContentNameProvider nameProvider);
    public sealed virtual IEnumerable`1<XElement> SelectElements(XElement root);
    [CompilerGeneratedAttribute]
private IEnumerable`1<XElement> <SelectElements>b__2_0(XElement x);
}
internal class Effort.Internal.StorageSchema.FunctionElementSelector : object {
    private StorageSchemaContentNameProvider nameProvider;
    public FunctionElementSelector(StorageSchemaContentNameProvider nameProvider);
    public sealed virtual IEnumerable`1<XElement> SelectElements(XElement root);
}
internal class Effort.Internal.StorageSchema.FunctionParameterElementSelector : object {
    private StorageSchemaContentNameProvider nameProvider;
    public FunctionParameterElementSelector(StorageSchemaContentNameProvider nameProvider);
    public sealed virtual IEnumerable`1<XElement> SelectElements(XElement root);
    [CompilerGeneratedAttribute]
private IEnumerable`1<XElement> <SelectElements>b__2_0(XElement e);
}
internal class Effort.Internal.StorageSchema.FunctionReturnRowTypePropertyElementSelector : object {
    private StorageSchemaContentNameProvider nameProvider;
    public FunctionReturnRowTypePropertyElementSelector(StorageSchemaContentNameProvider nameProvider);
    public sealed virtual IEnumerable`1<XElement> SelectElements(XElement root);
    [CompilerGeneratedAttribute]
private IEnumerable`1<XElement> <SelectElements>b__2_0(XElement e);
    [CompilerGeneratedAttribute]
private IEnumerable`1<XElement> <SelectElements>b__2_1(XElement e);
    [CompilerGeneratedAttribute]
private IEnumerable`1<XElement> <SelectElements>b__2_2(XElement e);
    [CompilerGeneratedAttribute]
private IEnumerable`1<XElement> <SelectElements>b__2_3(XElement e);
}
internal class Effort.Internal.StorageSchema.FunctionTypeAttributeModifier : object {
    public sealed virtual void Modify(XAttribute attribute, IModificationContext context);
}
internal interface Effort.Internal.StorageSchema.IProviderInformation {
    public string InvariantName { get; }
    public string ManifestToken { get; }
    public DbProviderManifest Manifest { get; }
    public abstract virtual string get_InvariantName();
    public abstract virtual string get_ManifestToken();
    public abstract virtual DbProviderManifest get_Manifest();
}
internal class Effort.Internal.StorageSchema.ModificationContextHelper : object {
    public static string OriginalProvider;
    public static string NewProvider;
    public static string TypeConverter;
    private static ModificationContextHelper();
    public static StorageTypeConverter GetTypeConverter(IModificationContext context);
}
internal class Effort.Internal.StorageSchema.ModificationFunctionMappingModifier : object {
    public sealed virtual void Modify(XElement element, IModificationContext context);
}
internal class Effort.Internal.StorageSchema.PropertyTypeAttributeModifier : object {
    public sealed virtual void Modify(XAttribute attribute, IModificationContext context);
}
internal class Effort.Internal.StorageSchema.ProviderAttributeModifier : object {
    public sealed virtual void Modify(XAttribute attribute, IModificationContext context);
}
internal class Effort.Internal.StorageSchema.ProviderAttributeSelector : object {
    private StorageSchemaContentNameProvider nameProvider;
    public ProviderAttributeSelector(StorageSchemaContentNameProvider nameProvider);
    public sealed virtual XAttribute SelectAttribute(XElement element);
}
internal class Effort.Internal.StorageSchema.ProviderInformation : object {
    private string invariantName;
    private string manifestToken;
    private DbProviderManifest manifest;
    public string InvariantName { get; }
    public string ManifestToken { get; }
    public DbProviderManifest Manifest { get; }
    public ProviderInformation(string invariantName, string manifestToken);
    public sealed virtual string get_InvariantName();
    public sealed virtual string get_ManifestToken();
    public sealed virtual DbProviderManifest get_Manifest();
}
internal class Effort.Internal.StorageSchema.ProviderManifestTokenAttributeModifier : object {
    public sealed virtual void Modify(XAttribute attribute, IModificationContext context);
}
internal class Effort.Internal.StorageSchema.ProviderManifestTokenAttributeSelector : object {
    private StorageSchemaContentNameProvider nameProvider;
    public ProviderManifestTokenAttributeSelector(StorageSchemaContentNameProvider nameProvider);
    public sealed virtual XAttribute SelectAttribute(XElement element);
}
internal class Effort.Internal.StorageSchema.ProviderParser : object {
    private StorageSchemaContentNameProvider nameProvider;
    public ProviderParser(StorageSchemaContentNameProvider nameProvider);
    public sealed virtual IProviderInformation VisitElement(XElement element);
}
internal class Effort.Internal.StorageSchema.ReturnTypeAttributeSelector : object {
    private StorageSchemaContentNameProvider nameProvider;
    public ReturnTypeAttributeSelector(StorageSchemaContentNameProvider nameProvider);
    public sealed virtual XAttribute SelectAttribute(XElement element);
}
internal class Effort.Internal.StorageSchema.StorageSchemaContentNameProvider : object {
    private XNamespace ns;
    public XName SchemaElement { get; }
    public XName EntityTypeElement { get; }
    public XName FunctionElement { get; }
    public XName PropertyElement { get; }
    public XName ParameterElement { get; }
    public XName ReturnTypeElement { get; }
    public XName CollectionTypeElement { get; }
    public XName RowTypeElement { get; }
    public XName TypeAttribute { get; }
    public XName ReturnTypeAttribute { get; }
    public XName ProviderAttribute { get; }
    public XName ProviderManifestTokenAttribute { get; }
    public XName MaxLengthAttribute { get; }
    public XName FixedLengthAttribute { get; }
    public XName PrecisionAttribute { get; }
    public XName ScaleAttribute { get; }
    public XName UnicodeAttribute { get; }
    public XName CollationAttribute { get; }
    public XName NullableAttribute { get; }
    public XName DefaultValueAttribute { get; }
    public StorageSchemaContentNameProvider(XNamespace ns);
    public XName get_SchemaElement();
    public XName get_EntityTypeElement();
    public XName get_FunctionElement();
    public XName get_PropertyElement();
    public XName get_ParameterElement();
    public XName get_ReturnTypeElement();
    public XName get_CollectionTypeElement();
    public XName get_RowTypeElement();
    public XName get_TypeAttribute();
    public XName get_ReturnTypeAttribute();
    public XName get_ProviderAttribute();
    public XName get_ProviderManifestTokenAttribute();
    public XName get_MaxLengthAttribute();
    public XName get_FixedLengthAttribute();
    public XName get_PrecisionAttribute();
    public XName get_ScaleAttribute();
    public XName get_UnicodeAttribute();
    public XName get_CollationAttribute();
    public XName get_NullableAttribute();
    public XName get_DefaultValueAttribute();
}
internal static class Effort.Internal.StorageSchema.StorageSchemaNamespaces : object {
    public static XNamespace V1;
    public static XNamespace V2;
    public static XNamespace V3;
    private static StorageSchemaNamespaces();
}
internal class Effort.Internal.StorageSchema.StorageSchemaV1Modifier : object {
    public static XNamespace Namespace;
    private StorageSchemaContentNameProvider nameProvider;
    private AggregatedElementModifier modificationLogic;
    private IElementVisitor`1<IProviderInformation> providerParser;
    private static StorageSchemaV1Modifier();
    public sealed virtual void Modify(XElement ssdl, IModificationContext context);
}
internal class Effort.Internal.StorageSchema.StorageSchemaV2Modifier : object {
    public static XNamespace Namespace;
    private StorageSchemaContentNameProvider nameProvider;
    private AggregatedElementModifier modificationLogic;
    private IElementVisitor`1<IProviderInformation> providerParser;
    private static StorageSchemaV2Modifier();
    public sealed virtual void Modify(XElement ssdl, IModificationContext context);
}
internal class Effort.Internal.StorageSchema.StorageSchemaV3Modifier : object {
    public static XNamespace Namespace;
    private StorageSchemaContentNameProvider nameProvider;
    private AggregatedElementModifier modificationLogic;
    private IElementVisitor`1<IProviderInformation> providerParser;
    private static StorageSchemaV3Modifier();
    public sealed virtual void Modify(XElement ssdl, IModificationContext context);
}
internal class Effort.Internal.StorageSchema.StorageTypeConverter : object {
    private IProviderInformation oldProvider;
    private IProviderInformation newProvider;
    private IDictionary`2<string, PrimitiveType> oldStoreTypes;
    public StorageTypeConverter(IProviderInformation oldProvider, IProviderInformation newProvider);
    public bool TryConvertType(string oldStorageTypeName, String& result, Facet[]& facets);
}
internal class Effort.Internal.StorageSchema.TypeAttributeSelector : object {
    private StorageSchemaContentNameProvider nameProvider;
    public TypeAttributeSelector(StorageSchemaContentNameProvider nameProvider);
    public sealed virtual XAttribute SelectAttribute(XElement element);
}
internal class Effort.Internal.StorageSchema.UniversalStorageSchemaModifier : object {
    public static UniversalStorageSchemaModifier Instance;
    private IElementModifier schemaV1Modifier;
    private IElementModifier schemaV2Modifier;
    private IElementModifier schemaV3Modifier;
    protected IElementModifier SchemaV1Modifier { get; }
    protected IElementModifier SchemaV2Modifier { get; }
    protected IElementModifier SchemaV3Modifier { get; }
    private static UniversalStorageSchemaModifier();
    public void Modify(XElement ssdl, IProviderInformation newProvider);
    protected IElementModifier get_SchemaV1Modifier();
    protected IElementModifier get_SchemaV2Modifier();
    protected IElementModifier get_SchemaV3Modifier();
}
internal class Effort.Internal.TypeConversion.DefaultTypeConverter : object {
    public sealed virtual object ConvertClrObject(object obj, Type type);
    public object ConvertClrObjectReverse(object obj, Type type);
    public sealed virtual bool TryConvertEdmType(PrimitiveType primitiveType, FacetInfo facets, Type& result);
}
internal class Effort.Internal.TypeConversion.EdmTypeConverter : object {
    private ITypeConverter converter;
    public EdmTypeConverter(ITypeConverter converter);
    public Type Convert(TypeUsage type);
    public Type ConvertNotNull(TypeUsage type);
    public Type GetElementType(TypeUsage type);
    public FacetInfo GetTypeFacets(TypeUsage type);
    private Type ConvertWithFacets(TypeUsage type, FacetInfo facets);
    private Type CreatePrimitiveType(PrimitiveType primitiveType, FacetInfo facets);
    private Type CreateRowType(RowType rowType, FacetInfo facets);
    private Type CreateCollectionType(CollectionType collectionType, FacetInfo facets);
}
internal class Effort.Internal.TypeConversion.FacetInfo : object {
    [CompilerGeneratedAttribute]
private bool <Nullable>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <Identity>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <Computed>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <LimitedLength>k__BackingField;
    [CompilerGeneratedAttribute]
private int <MaxLength>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <FixedLength>k__BackingField;
    public bool Nullable { get; public set; }
    public bool Identity { get; public set; }
    public bool Computed { get; public set; }
    public bool LimitedLength { get; public set; }
    public int MaxLength { get; public set; }
    public bool FixedLength { get; public set; }
    [CompilerGeneratedAttribute]
public bool get_Nullable();
    [CompilerGeneratedAttribute]
public void set_Nullable(bool value);
    [CompilerGeneratedAttribute]
public bool get_Identity();
    [CompilerGeneratedAttribute]
public void set_Identity(bool value);
    [CompilerGeneratedAttribute]
public bool get_Computed();
    [CompilerGeneratedAttribute]
public void set_Computed(bool value);
    [CompilerGeneratedAttribute]
public bool get_LimitedLength();
    [CompilerGeneratedAttribute]
public void set_LimitedLength(bool value);
    [CompilerGeneratedAttribute]
public int get_MaxLength();
    [CompilerGeneratedAttribute]
public void set_MaxLength(int value);
    [CompilerGeneratedAttribute]
public bool get_FixedLength();
    [CompilerGeneratedAttribute]
public void set_FixedLength(bool value);
}
internal interface Effort.Internal.TypeConversion.ITypeConverter {
    public abstract virtual object ConvertClrObject(object obj, Type type);
    public abstract virtual bool TryConvertEdmType(PrimitiveType primitiveType, FacetInfo facets, Type& result);
}
public abstract class Effort.Internal.TypeGeneration.DataRow : object {
    public abstract virtual object GetValue(int index);
}
internal static class Effort.Internal.TypeGeneration.DataRowFactory : object {
    private static int typeCount;
    private static AssemblyBuilder assemblyBuilder;
    private static ModuleBuilder moduleBuilder;
    private static object moduleBuilderLock;
    private static ConcurrentCache`2<TypeCacheEntryKey, Type> typeCache;
    private static MethodInfo GetValueNameMethod;
    private static DataRowFactory();
    public static Type Create(IDictionary`2<string, Type> properties);
    private static Type CreateRowType(IDictionary`2<string, Type> properties);
    private static FieldBuilder CreateFieldAndProperty(TypeBuilder typeBuilder, string name, int index, Type type);
    private static void GenerateConstructorIL(ILGenerator gen, FieldBuilder[] fields, bool array);
    private static void GenerateGetHashcodeIL(ILGenerator gen, FieldBuilder[] fields);
    private static void GenerateEqualsIL(ILGenerator gen, FieldBuilder[] fields, TypeBuilder typeBuilder);
    private static void GenerateGetValueIL(ILGenerator gen, FieldBuilder[] fields, TypeBuilder typeBuilder);
    private static void GenerateLdArg(ILGenerator gen, int i);
    private static void GenerateLdc_I4(ILGenerator gen, int constant);
}
[AttributeUsageAttribute("128")]
public class Effort.Internal.TypeGeneration.DataRowPropertyAttribute : Attribute {
    private int index;
    public int Index { get; }
    public DataRowPropertyAttribute(int index);
    public int get_Index();
}
[AttributeUsageAttribute("128")]
public class Effort.Internal.TypeGeneration.LargeDataRowAttribute : Attribute {
    internal static int LargePropertyCount;
    private static LargeDataRowAttribute();
}
public static class Effort.ObjectContextFactory : object {
    private static ModuleBuilder objectContextContainer;
    private static int objectContextCount;
    private static ObjectContextFactory();
    public static Type CreatePersistentType(string entityConnectionString, IDataLoader dataLoader);
    public static Type CreatePersistentType(string entityConnectionString);
    public static Type CreatePersistentType();
    public static Type CreatePersistentType(IDataLoader dataLoader);
    public static T CreatePersistent(string entityConnectionString);
    public static T CreatePersistent(string entityConnectionString, IDataLoader dataLoader);
    public static T CreatePersistent();
    public static T CreatePersistent(IDataLoader dataLoader);
    public static Type CreateTransientType(string entityConnectionString, IDataLoader dataLoader);
    public static Type CreateTransientType(string entityConnectionString);
    public static Type CreateTransientType();
    public static Type CreateTransientType(IDataLoader dataLoader);
    public static T CreateTransient(string entityConnectionString, IDataLoader dataLoader);
    public static T CreateTransient(string entityConnectionString);
    public static T CreateTransient(IDataLoader dataLoader);
    public static T CreateTransient();
    private static Type CreateType(string entityConnectionString, bool persistent, IDataLoader dataLoader);
    private static string GetDefaultConnectionString();
    private static Type CreateType(string entityConnectionString, string effortConnectionString, bool persistent);
    private static string FindDefaultConnectionStringByConvention();
}
public class Effort.Provider.EffortCommand : EffortCommandBase {
    protected virtual DbDataReader ExecuteDbDataReader(CommandBehavior behavior);
    public virtual int ExecuteNonQuery();
    public virtual object ExecuteScalar();
    public virtual object Clone();
}
public abstract class Effort.Provider.EffortCommandBase : DbCommand {
    private EffortConnection connection;
    private EffortTransaction transaction;
    private EffortParameterCollection parameters;
    [CompilerGeneratedAttribute]
private string <CommandText>k__BackingField;
    [CompilerGeneratedAttribute]
private int <CommandTimeout>k__BackingField;
    [CompilerGeneratedAttribute]
private CommandType <CommandType>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <DesignTimeVisible>k__BackingField;
    [CompilerGeneratedAttribute]
private UpdateRowSource <UpdatedRowSource>k__BackingField;
    public string CommandText { get; public set; }
    public int CommandTimeout { get; public set; }
    public CommandType CommandType { get; public set; }
    protected DbParameterCollection DbParameterCollection { get; }
    protected DbConnection DbConnection { get; protected set; }
    protected DbTransaction DbTransaction { get; protected set; }
    public bool DesignTimeVisible { get; public set; }
    protected EffortConnection EffortConnection { get; }
    protected EffortTransaction EffortTransaction { get; }
    public UpdateRowSource UpdatedRowSource { get; public set; }
    [CompilerGeneratedAttribute]
public virtual string get_CommandText();
    [CompilerGeneratedAttribute]
public virtual void set_CommandText(string value);
    [CompilerGeneratedAttribute]
public virtual int get_CommandTimeout();
    [CompilerGeneratedAttribute]
public virtual void set_CommandTimeout(int value);
    [CompilerGeneratedAttribute]
public virtual CommandType get_CommandType();
    [CompilerGeneratedAttribute]
public virtual void set_CommandType(CommandType value);
    protected void AddParameter(string name);
    protected virtual DbParameterCollection get_DbParameterCollection();
    protected virtual DbConnection get_DbConnection();
    protected virtual void set_DbConnection(DbConnection value);
    protected virtual DbTransaction get_DbTransaction();
    protected virtual void set_DbTransaction(DbTransaction value);
    [CompilerGeneratedAttribute]
public virtual bool get_DesignTimeVisible();
    [CompilerGeneratedAttribute]
public virtual void set_DesignTimeVisible(bool value);
    protected EffortConnection get_EffortConnection();
    protected EffortTransaction get_EffortTransaction();
    public abstract virtual int ExecuteNonQuery();
    public abstract virtual object ExecuteScalar();
    public virtual void Prepare();
    [CompilerGeneratedAttribute]
public virtual UpdateRowSource get_UpdatedRowSource();
    [CompilerGeneratedAttribute]
public virtual void set_UpdatedRowSource(UpdateRowSource value);
    public virtual void Cancel();
    protected virtual DbParameter CreateDbParameter();
    public abstract virtual object Clone();
    protected abstract virtual DbDataReader ExecuteDbDataReader(CommandBehavior behavior);
}
public class Effort.Provider.EffortCommandDefinition : DbCommandDefinition {
    private EffortCommandBase prototype;
    public EffortCommandDefinition(EffortCommandBase prototype);
    public virtual DbCommand CreateCommand();
}
public class Effort.Provider.EffortConnection : DbConnection {
    private string connectionString;
    private string lastContainerId;
    private DbContainerManagerWrapper containerConfiguration;
    private DbContainer container;
    private Guid identifier;
    private ConnectionState state;
    private bool isPrimaryTransient;
    private EffortRestorePoint RestorePoint;
    private Nullable`1<int> _connectionTimeout;
    public int ConnectionTimeout { get; }
    public bool IsCaseSensitive { get; public set; }
    public string ConnectionString { get; public set; }
    public string DataSource { get; }
    public string ServerVersion { get; }
    public ConnectionState State { get; }
    internal DbContainer DbContainer { get; }
    protected DbProviderFactory DbProviderFactory { get; }
    public string Database { get; }
    public IDbManager DbManager { get; }
    public virtual int get_ConnectionTimeout();
    public void SetConnectionTimeout(int value);
    public bool get_IsCaseSensitive();
    public void set_IsCaseSensitive(bool value);
    public ITable GetTable(DbTableInfo tableInfo);
    public DbTableInfo GetTableInfo(string schema, string name);
    public List`1<ITable> GetAllTables();
    public void CreateRestorePoint();
    public void RollbackToRestorePoint();
    public void RollbackToRestorePoint(DbContext context);
    public void ClearTables();
    public void ClearTables(DbContext context);
    public virtual string get_ConnectionString();
    public virtual void set_ConnectionString(string value);
    public virtual string get_DataSource();
    public virtual string get_ServerVersion();
    public virtual ConnectionState get_State();
    internal DbContainer get_DbContainer();
    protected virtual DbProviderFactory get_DbProviderFactory();
    public virtual void ChangeDatabase(string databaseName);
    public virtual string get_Database();
    public IDbManager get_DbManager();
    public virtual void Open();
    public virtual void Close();
    internal void MarkAsPrimaryTransient();
    protected virtual DbCommand CreateDbCommand();
    protected virtual DbTransaction BeginDbTransaction(IsolationLevel isolationLevel);
    public virtual void EnlistTransaction(Transaction transaction);
    protected virtual void Dispose(bool disposing);
    internal virtual void UnregisterContainer();
    private void ChangeConnectionState(ConnectionState state);
    private DbContainer CreateDbContainer();
}
public class Effort.Provider.EffortConnectionStringBuilder : DbConnectionStringBuilder {
    private static string InstanceIdKey;
    private static string DataLoaderTypeKey;
    private static string DataLoaderArgKey;
    private static string IsTransientKey;
    public string InstanceId { get; public set; }
    public bool IsTransient { get; public set; }
    public Type DataLoaderType { get; public set; }
    public string DataLoaderArgument { get; public set; }
    public EffortConnectionStringBuilder(string connectionString);
    private static EffortConnectionStringBuilder();
    public string get_InstanceId();
    public void set_InstanceId(string value);
    public bool get_IsTransient();
    public void set_IsTransient(bool value);
    public Type get_DataLoaderType();
    public void set_DataLoaderType(Type value);
    public string get_DataLoaderArgument();
    public void set_DataLoaderArgument(string value);
    internal void Normalize();
}
[DefaultMemberAttribute("Item")]
public class Effort.Provider.EffortDataReader : DbDataReader {
    private IEnumerator enumerator;
    private int recordsAffected;
    private FieldDescription[] fields;
    private Object[] currentValues;
    private DbContainer container;
    public int Depth { get; }
    public int RecordsAffected { get; }
    public int FieldCount { get; }
    public bool HasRows { get; }
    public bool IsClosed { get; }
    public object Item { get; }
    public object Item { get; }
    internal EffortDataReader(IEnumerable result, int recordsAffected, FieldDescription[] fields, DbContainer container);
    public virtual int get_Depth();
    public virtual int get_RecordsAffected();
    public virtual int get_FieldCount();
    public virtual bool GetBoolean(int ordinal);
    public virtual byte GetByte(int ordinal);
    public virtual long GetBytes(int ordinal, long dataOffset, Byte[] buffer, int bufferOffset, int length);
    public virtual char GetChar(int ordinal);
    public virtual long GetChars(int ordinal, long dataOffset, Char[] buffer, int bufferOffset, int length);
    public virtual string GetDataTypeName(int ordinal);
    public virtual DateTime GetDateTime(int ordinal);
    public virtual decimal GetDecimal(int ordinal);
    public virtual double GetDouble(int ordinal);
    public virtual Type GetFieldType(int ordinal);
    public virtual float GetFloat(int ordinal);
    public virtual Guid GetGuid(int ordinal);
    public virtual short GetInt16(int ordinal);
    public virtual int GetInt32(int ordinal);
    public virtual long GetInt64(int ordinal);
    public virtual string GetName(int ordinal);
    public virtual int GetOrdinal(string name);
    public virtual IEnumerator GetEnumerator();
    public virtual DataTable GetSchemaTable();
    public virtual string GetString(int ordinal);
    public virtual object GetValue(int ordinal);
    public virtual int GetValues(Object[] values);
    public virtual bool get_HasRows();
    public virtual bool get_IsClosed();
    public virtual bool IsDBNull(int ordinal);
    public virtual bool NextResult();
    public virtual bool Read();
    public virtual void Close();
    public virtual object get_Item(string name);
    public virtual object get_Item(int ordinal);
    protected virtual void Dispose(bool disposing);
    private void EnsureValues();
}
public class Effort.Provider.EffortEntityCommand : EffortCommandBase {
    private ICommandAction commandAction;
    public EffortEntityCommand(DbCommandTree commandtree);
    private EffortEntityCommand(EffortEntityCommand prototype);
    public virtual int ExecuteNonQuery();
    public virtual object ExecuteScalar();
    public virtual object Clone();
    protected virtual DbDataReader ExecuteDbDataReader(CommandBehavior behavior);
    private ActionContext CreateActionContext();
}
public class Effort.Provider.EffortParameter : DbParameter {
    [CompilerGeneratedAttribute]
private DbType <DbType>k__BackingField;
    [CompilerGeneratedAttribute]
private ParameterDirection <Direction>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsNullable>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ParameterName>k__BackingField;
    [CompilerGeneratedAttribute]
private int <Size>k__BackingField;
    [CompilerGeneratedAttribute]
private string <SourceColumn>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <SourceColumnNullMapping>k__BackingField;
    [CompilerGeneratedAttribute]
private DataRowVersion <SourceVersion>k__BackingField;
    [CompilerGeneratedAttribute]
private object <Value>k__BackingField;
    public DbType DbType { get; public set; }
    public ParameterDirection Direction { get; public set; }
    public bool IsNullable { get; public set; }
    public string ParameterName { get; public set; }
    public int Size { get; public set; }
    public string SourceColumn { get; public set; }
    public bool SourceColumnNullMapping { get; public set; }
    public DataRowVersion SourceVersion { get; public set; }
    public object Value { get; public set; }
    [CompilerGeneratedAttribute]
public virtual DbType get_DbType();
    [CompilerGeneratedAttribute]
public virtual void set_DbType(DbType value);
    [CompilerGeneratedAttribute]
public virtual ParameterDirection get_Direction();
    [CompilerGeneratedAttribute]
public virtual void set_Direction(ParameterDirection value);
    [CompilerGeneratedAttribute]
public virtual bool get_IsNullable();
    [CompilerGeneratedAttribute]
public virtual void set_IsNullable(bool value);
    [CompilerGeneratedAttribute]
public virtual string get_ParameterName();
    [CompilerGeneratedAttribute]
public virtual void set_ParameterName(string value);
    public virtual void ResetDbType();
    [CompilerGeneratedAttribute]
public virtual int get_Size();
    [CompilerGeneratedAttribute]
public virtual void set_Size(int value);
    [CompilerGeneratedAttribute]
public virtual string get_SourceColumn();
    [CompilerGeneratedAttribute]
public virtual void set_SourceColumn(string value);
    [CompilerGeneratedAttribute]
public virtual bool get_SourceColumnNullMapping();
    [CompilerGeneratedAttribute]
public virtual void set_SourceColumnNullMapping(bool value);
    [CompilerGeneratedAttribute]
public virtual DataRowVersion get_SourceVersion();
    [CompilerGeneratedAttribute]
public virtual void set_SourceVersion(DataRowVersion value);
    [CompilerGeneratedAttribute]
public virtual object get_Value();
    [CompilerGeneratedAttribute]
public virtual void set_Value(object value);
}
public class Effort.Provider.EffortParameterCollection : DbParameterCollection {
    private object syncRoot;
    private List`1<EffortParameter> internalCollection;
    public int Count { get; }
    public bool IsFixedSize { get; }
    public bool IsReadOnly { get; }
    public bool IsSynchronized { get; }
    public object SyncRoot { get; }
    public virtual int Add(object value);
    public virtual void AddRange(Array values);
    public virtual void Clear();
    public virtual bool Contains(string value);
    public virtual bool Contains(object value);
    public virtual void CopyTo(Array array, int index);
    public virtual int get_Count();
    public virtual IEnumerator GetEnumerator();
    protected virtual DbParameter GetParameter(string parameterName);
    protected virtual DbParameter GetParameter(int index);
    public virtual int IndexOf(string parameterName);
    public virtual int IndexOf(object value);
    public virtual void Insert(int index, object value);
    public virtual bool get_IsFixedSize();
    public virtual bool get_IsReadOnly();
    public virtual bool get_IsSynchronized();
    public virtual void Remove(object value);
    public virtual void RemoveAt(string parameterName);
    public virtual void RemoveAt(int index);
    protected virtual void SetParameter(string parameterName, DbParameter value);
    protected virtual void SetParameter(int index, DbParameter value);
    public virtual object get_SyncRoot();
}
public static class Effort.Provider.EffortProviderConfiguration : object {
    public static string ProviderInvariantName;
    private static bool isRegistered;
    private static object latch;
    private static EffortProviderConfiguration();
    public static void RegisterProvider();
    internal static void VerifyProvider();
    private static void RegisterProvider(string name, string invariantName, Type factoryType);
    internal static void RegisterDbConfigurationEventHandler();
    private static void OnDbConfigurationLoaded(object sender, DbConfigurationLoadedEventArgs e);
    internal static void RegisterDbConfiguration();
}
public class Effort.Provider.EffortProviderFactory : DbProviderFactory {
    public static EffortProviderFactory Instance;
    private static EffortProviderFactory();
    public virtual DbConnection CreateConnection();
    public sealed virtual object GetService(Type serviceType);
}
public class Effort.Provider.EffortProviderInvariantName : object {
    public static IProviderInvariantName Instance;
    public string Name { get; }
    private static EffortProviderInvariantName();
    public sealed virtual string get_Name();
}
public class Effort.Provider.EffortProviderManifest : DbXmlEnabledProviderManifest {
    private static string MetadataResource;
    private EffortVersion version;
    public EffortProviderManifest(EffortVersion version);
    public virtual TypeUsage GetEdmType(TypeUsage storeType);
    public virtual TypeUsage GetStoreType(TypeUsage edmType);
    protected virtual XmlReader GetDbInformation(string informationType);
    private static XmlReader GetProviderManifest();
    private static TypeUsage ConvertTypeUsage(TypeUsage original, PrimitiveType goal);
}
public static class Effort.Provider.EffortProviderManifestTokens : object {
    public static string Version1;
    public static EffortVersion GetVersion(string manifestToken);
}
public class Effort.Provider.EffortProviderServices : DbProviderServices {
    public static EffortProviderServices Instance;
    private static EffortProviderServices();
    public virtual DbCommandDefinition CreateCommandDefinition(DbCommand prototype);
    protected virtual DbCommandDefinition CreateDbCommandDefinition(DbProviderManifest providerManifest, DbCommandTree commandTree);
    public void Register();
    protected virtual DbProviderManifest GetDbProviderManifest(string manifestToken);
    protected virtual string GetDbProviderManifestToken(DbConnection connection);
    protected virtual bool DbDatabaseExists(DbConnection connection, Nullable`1<int> commandTimeout, StoreItemCollection storeItemCollection);
    protected virtual void DbCreateDatabase(DbConnection connection, Nullable`1<int> commandTimeout, StoreItemCollection storeItemCollection);
    protected virtual void DbDeleteDatabase(DbConnection connection, Nullable`1<int> commandTimeout, StoreItemCollection storeItemCollection);
    protected virtual string DbCreateDatabaseScript(string providerManifestToken, StoreItemCollection storeItemCollection);
    private static DbContainer GetDbContainer(DbConnection connection);
    private static T Wrap(DbConnection connection, Func`2<DbConnection, T> action);
}
public class Effort.Provider.EffortTransaction : DbTransaction {
    private EffortConnection connection;
    private IsolationLevel isolationLevel;
    private CommittableTransaction systemTransaction;
    private Transaction transaction;
    public IsolationLevel IsolationLevel { get; }
    public Transaction InternalTransaction { get; }
    protected DbConnection DbConnection { get; }
    public EffortTransaction(EffortConnection connection, IsolationLevel isolationLevel);
    public virtual void Commit();
    public virtual IsolationLevel get_IsolationLevel();
    public Transaction get_InternalTransaction();
    public virtual void Rollback();
    protected virtual DbConnection get_DbConnection();
    protected virtual void Dispose(bool disposing);
    private static IsolationLevel TranslateIsolationLevel(IsolationLevel isolationLevel);
}
public enum Effort.Provider.EffortVersion : Enum {
    public int value__;
    public static EffortVersion Version1;
}
public interface Effort.Provider.IDbManager {
    public abstract virtual void SetIdentityFields(bool enabled);
    public abstract virtual void SetIdentity(Nullable`1<int> seed, Nullable`1<int> increment);
    public abstract virtual void ClearMigrationHistory();
    public abstract virtual void ClearTables();
}
public static class Effort.Shared.Internal.CreateEntityHelper : object {
    public static ConcurrentDictionary`2<string, Func`2<Object[], object>> DictCreateAndInsertEntityDelegate;
    private static CreateEntityHelper();
    public static object Create(ITable table, IList`1<MemberBinding> memberBindings);
}
public class Effort.Shared.Provider.EffortRestorePoint : object {
    [CompilerGeneratedAttribute]
private EffortConnection <EffortConnection>k__BackingField;
    [CompilerGeneratedAttribute]
private List`1<EffortRestorePointEntry> <Entities>k__BackingField;
    [CompilerGeneratedAttribute]
private List`1<EffortRestorePointEntry> <OrderedEntities>k__BackingField;
    public EffortConnection EffortConnection { get; public set; }
    public List`1<EffortRestorePointEntry> Entities { get; public set; }
    private List`1<EffortRestorePointEntry> OrderedEntities { get; private set; }
    public EffortRestorePoint(EffortConnection effortConnection);
    [CompilerGeneratedAttribute]
public EffortConnection get_EffortConnection();
    [CompilerGeneratedAttribute]
public void set_EffortConnection(EffortConnection value);
    [CompilerGeneratedAttribute]
public List`1<EffortRestorePointEntry> get_Entities();
    [CompilerGeneratedAttribute]
public void set_Entities(List`1<EffortRestorePointEntry> value);
    [CompilerGeneratedAttribute]
private List`1<EffortRestorePointEntry> get_OrderedEntities();
    [CompilerGeneratedAttribute]
private void set_OrderedEntities(List`1<EffortRestorePointEntry> value);
    public void AddToIndex(object table, List`1<object> entities);
    public void Restore(DbContext context, object dbContainer);
    public void CreateOrderedEntities();
    public static T ShallowCopy(T this);
}
