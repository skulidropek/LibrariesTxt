[NullableContextAttribute("1")]
[NullableAttribute("0")]
[DefaultMemberAttribute("Item")]
public class EnumsNET.AttributeCollection : object {
    internal static AttributeCollection Empty;
    private Attribute[] _attributes;
    public Attribute Item { get; }
    public int Count { get; }
    private bool System.Collections.Generic.ICollection<System.Attribute>.IsReadOnly { get; }
    private Attribute System.Collections.Generic.IList<System.Attribute>.Item { get; private set; }
    internal AttributeCollection(Attribute[] attributes);
    private static AttributeCollection();
    public sealed virtual Attribute get_Item(int index);
    public sealed virtual int get_Count();
    [NullableContextAttribute("0")]
public bool Has();
    public bool Has(Type attributeType);
    [NullableContextAttribute("0")]
public TAttribute Get();
    public Attribute Get(Type attributeType);
    [IteratorStateMachineAttribute("EnumsNET.AttributeCollection/<GetAll>d__11`1")]
public IEnumerable`1<TAttribute> GetAll();
    [IteratorStateMachineAttribute("EnumsNET.AttributeCollection/<GetAll>d__12")]
public IEnumerable`1<Attribute> GetAll(Type attributeType);
    public sealed virtual IEnumerator`1<Attribute> GetEnumerator();
    private sealed virtual override bool System.Collections.Generic.ICollection<System.Attribute>.get_IsReadOnly();
    private sealed virtual override bool System.Collections.Generic.ICollection<System.Attribute>.Contains(Attribute item);
    private sealed virtual override void System.Collections.Generic.ICollection<System.Attribute>.CopyTo(Attribute[] array, int arrayIndex);
    private sealed virtual override int System.Collections.Generic.IList<System.Attribute>.IndexOf(Attribute item);
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    private sealed virtual override Attribute System.Collections.Generic.IList<System.Attribute>.get_Item(int index);
    private sealed virtual override void System.Collections.Generic.IList<System.Attribute>.set_Item(int index, Attribute value);
    private sealed virtual override void System.Collections.Generic.ICollection<System.Attribute>.Add(Attribute item);
    private sealed virtual override void System.Collections.Generic.ICollection<System.Attribute>.Clear();
    private sealed virtual override bool System.Collections.Generic.ICollection<System.Attribute>.Remove(Attribute item);
    private sealed virtual override void System.Collections.Generic.IList<System.Attribute>.Insert(int index, Attribute item);
    private sealed virtual override void System.Collections.Generic.IList<System.Attribute>.RemoveAt(int index);
}
internal class EnumsNET.ContiguousStandardEnumCache`2 : StandardEnumCache`2<TUnderlying, TUnderlyingOperations> {
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private EnumMemberInternal`2[] _distinctMembers;
    public ContiguousStandardEnumCache`2(Type enumType, IEnumBridge`2<TUnderlying, TUnderlyingOperations> enumBridge, EnumMemberInternal`2[] members, EnumMemberInternal`2[] buckets, TUnderlying allFlags, int distinctCount, object customValidator);
    [NullableContextAttribute("1")]
public sealed virtual string AsString(Byte& value);
    [NullableContextAttribute("1")]
public sealed virtual string AsString(object value);
    public string AsString(TUnderlying value);
    public virtual bool TryFormat(Byte& value, Span`1<char> destination, Int32& charsWritten);
    public virtual bool TryFormat(object value, Span`1<char> destination, Int32& charsWritten);
    public bool TryFormat(TUnderlying value, Span`1<char> destination, Int32& charsWritten);
    public virtual bool IsDefined(Byte& value);
    [NullableContextAttribute("1")]
public virtual bool IsDefined(object value);
    public bool IsDefined(TUnderlying value);
    [NullableContextAttribute("2")]
public virtual EnumMemberInternal GetMember(Byte& value);
    [NullableContextAttribute("1")]
public virtual EnumMemberInternal GetMember(object value);
    public EnumMemberInternal`2<TUnderlying, TUnderlyingOperations> GetMember(TUnderlying value);
}
internal class EnumsNET.EnumBridge`3 : object {
    public sealed virtual object ToObjectUnchecked(TUnderlying value);
    public sealed virtual bool CustomValidate(object customValidator, TUnderlying value);
    [NullableContextAttribute("1")]
public sealed virtual EnumComparer CreateEnumComparer(EnumCache enumCache);
    [NullableContextAttribute("1")]
public sealed virtual EnumMember CreateEnumMember(EnumMemberInternal member);
    public sealed virtual Nullable`1<TUnderlying> IsEnum(object value);
    [NullableContextAttribute("1")]
public sealed virtual IValuesContainer CreateValuesContainer(IEnumerable`1<EnumMemberInternal`2<TUnderlying, TUnderlyingOperations>> members, int count, bool cached);
    [NullableContextAttribute("1")]
public sealed virtual IReadOnlyList`1<EnumMember> CreateMembersContainer(IEnumerable`1<EnumMemberInternal> members, int count, bool cached);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal abstract class EnumsNET.EnumCache : object {
    public Type EnumType;
    public Type UnderlyingType;
    public TypeCode TypeCode;
    public bool IsFlagEnum;
    private protected bool _hasDuplicateValues;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private IReadOnlyList`1<string> _names;
    [NullableAttribute("2")]
private IValuesContainer _values;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private IReadOnlyList`1<EnumMember> _members;
    [NullableAttribute("2")]
private EnumComparer _enumComparer;
    [NullableAttribute("2")]
internal EnumCache Next;
    public EnumComparer EnumComparer { get; }
    protected EnumCache(Type enumType, Type underlyingType, bool isFlagEnum, bool hasDuplicateValues);
    protected static bool IsNumeric(string value);
    public IReadOnlyList`1<EnumMember> GetMembers(EnumMemberSelection selection);
    public IReadOnlyList`1<string> GetNames(EnumMemberSelection selection);
    public IValuesContainer GetValues(EnumMemberSelection selection);
    public EnumComparer get_EnumComparer();
    protected abstract virtual EnumComparer CreateEnumComparer();
    public abstract virtual string AsString(Byte& value);
    public abstract virtual string AsString(Byte& value, string format);
    [NullableContextAttribute("2")]
public abstract virtual string AsString(Byte& value, EnumFormat format);
    [NullableContextAttribute("0")]
public abstract virtual string AsString(Byte& value, ValueCollection`1<EnumFormat> formats);
    public abstract virtual string AsString(object value);
    public abstract virtual string AsString(object value, string format);
    public abstract virtual string AsString(object value, EnumFormat format);
    [NullableContextAttribute("0")]
public abstract virtual string AsString(object value, ValueCollection`1<EnumFormat> formats);
    public abstract virtual void CombineFlags(Byte& value, Byte& otherFlags, Byte& result);
    public abstract virtual void CombineFlags(Byte& flag0, Byte& flag1, Byte& flag2, Byte& result);
    public abstract virtual void CombineFlags(Byte& flag0, Byte& flag1, Byte& flag2, Byte& flag3, Byte& result);
    public abstract virtual void CombineFlags(Byte& flag0, Byte& flag1, Byte& flag2, Byte& flag3, Byte& flag4, Byte& result);
    public abstract virtual object CombineFlags(IEnumerable`1<object> flags, bool isNullable);
    public abstract virtual object CombineFlags(object value, object otherFlags);
    public abstract virtual void CommonFlags(Byte& value, Byte& otherFlags, Byte& result);
    public abstract virtual object CommonFlags(object value, object otherFlags);
    public abstract virtual int CompareTo(Byte& value, Byte& other);
    public abstract virtual int CompareTo(object value, object other);
    public abstract virtual bool Equals(Byte& value, Byte& other);
    public abstract virtual bool Equals(object value, object other);
    [NullableContextAttribute("2")]
public abstract virtual string FormatFlags(Byte& value, string delimiter, ValueCollection`1<EnumFormat> formats);
    [NullableContextAttribute("2")]
public abstract virtual string FormatFlags(object value, string delimiter, ValueCollection`1<EnumFormat> formats);
    public abstract virtual void GetAllFlags(Byte& result);
    public abstract virtual object GetAllFlags();
    public abstract virtual int GetFlagCount();
    public abstract virtual int GetFlagCount(Byte& value);
    public abstract virtual int GetFlagCount(object value);
    public abstract virtual int GetFlagCount(Byte& value, Byte& otherFlags);
    public abstract virtual int GetFlagCount(object value, object otherFlags);
    public abstract virtual IReadOnlyList`1<EnumMember> GetFlagMembers(Byte& value);
    public abstract virtual IReadOnlyList`1<EnumMember> GetFlagMembers(object value);
    public abstract virtual IValuesContainer GetFlags(Byte& value);
    public abstract virtual IReadOnlyList`1<object> GetFlags(object value);
    public abstract virtual int GetHashCode(Byte& value);
    [NullableContextAttribute("2")]
public abstract virtual EnumMemberInternal GetMember(Byte& value);
    public abstract virtual EnumMemberInternal GetMember(object value);
    [NullableContextAttribute("0")]
public abstract virtual EnumMember GetMember(string value, bool ignoreCase, ValueCollection`1<EnumFormat> formats);
    protected abstract virtual IReadOnlyList`1<EnumMember> GetMembersInternal(EnumMemberSelection selection, bool cached);
    public abstract virtual int GetMemberCount(EnumMemberSelection selection);
    protected abstract virtual IReadOnlyList`1<string> GetNamesInternal(EnumMemberSelection selection, bool cached);
    public abstract virtual object GetUnderlyingValue(Byte& value);
    public abstract virtual object GetUnderlyingValue(object value);
    protected abstract virtual IValuesContainer GetValuesInternal(EnumMemberSelection selection, bool cached);
    public abstract virtual bool HasAllFlags(Byte& value);
    public abstract virtual bool HasAllFlags(object value);
    public abstract virtual bool HasAllFlags(Byte& value, Byte& otherFlags);
    public abstract virtual bool HasAllFlags(object value, object otherFlags);
    public abstract virtual bool HasAnyFlags(Byte& value);
    public abstract virtual bool HasAnyFlags(object value);
    public abstract virtual bool HasAnyFlags(Byte& value, Byte& otherFlags);
    public abstract virtual bool HasAnyFlags(object value, object otherFlags);
    public abstract virtual bool IsDefined(Byte& value);
    public abstract virtual bool IsDefined(object value);
    public abstract virtual bool IsValid(Byte& value, EnumValidation validation);
    public abstract virtual bool IsValid(object value, EnumValidation validation);
    public abstract virtual bool IsValidFlagCombination(Byte& value);
    public abstract virtual bool IsValidFlagCombination(object value);
    [NullableContextAttribute("0")]
public abstract virtual void Parse(string value, bool ignoreCase, ValueCollection`1<EnumFormat> formats, Byte& result);
    public abstract virtual object Parse(string value, bool ignoreCase, ValueCollection`1<EnumFormat> formats);
    public abstract virtual void Parse(string value, bool ignoreCase, Byte& result);
    public abstract virtual object Parse(string value, bool ignoreCase);
    [NullableContextAttribute("0")]
public abstract virtual void ParseFlags(string value, bool ignoreCase, string delimiter, ValueCollection`1<EnumFormat> formats, Byte& result);
    public abstract virtual object ParseFlags(string value, bool ignoreCase, string delimiter, ValueCollection`1<EnumFormat> formats);
    public abstract virtual void RemoveFlags(Byte& value, Byte& otherFlags, Byte& result);
    public abstract virtual object RemoveFlags(object value, object otherFlags);
    public abstract virtual byte ToByte(Byte& value);
    public abstract virtual byte ToByte(object value);
    public abstract virtual void ToggleFlags(Byte& value, Byte& result);
    public abstract virtual object ToggleFlags(object value);
    public abstract virtual void ToggleFlags(Byte& value, Byte& otherFlags, Byte& result);
    public abstract virtual object ToggleFlags(object value, object otherFlags);
    public abstract virtual short ToInt16(Byte& value);
    public abstract virtual short ToInt16(object value);
    public abstract virtual int ToInt32(Byte& value);
    public abstract virtual int ToInt32(object value);
    public abstract virtual long ToInt64(Byte& value);
    public abstract virtual long ToInt64(object value);
    public abstract virtual void ToObject(ulong value, EnumValidation validation, Byte& result);
    public abstract virtual object ToObject(ulong value, EnumValidation validation);
    public abstract virtual void ToObject(object value, EnumValidation validation, Byte& result);
    public abstract virtual object ToObject(object value, EnumValidation validation);
    public abstract virtual void ToObject(long value, EnumValidation validation, Byte& result);
    public abstract virtual object ToObject(long value, EnumValidation validation);
    public abstract virtual sbyte ToSByte(Byte& value);
    public abstract virtual sbyte ToSByte(object value);
    public abstract virtual ushort ToUInt16(Byte& value);
    public abstract virtual ushort ToUInt16(object value);
    public abstract virtual UInt32 ToUInt32(Byte& value);
    public abstract virtual UInt32 ToUInt32(object value);
    public abstract virtual ulong ToUInt64(Byte& value);
    public abstract virtual ulong ToUInt64(object value);
    [NullableContextAttribute("0")]
public abstract virtual bool TryFormat(Byte& value, Span`1<char> destination, Int32& charsWritten);
    [NullableContextAttribute("0")]
public abstract virtual bool TryFormat(object value, Span`1<char> destination, Int32& charsWritten);
    [NullableContextAttribute("0")]
public abstract virtual bool TryFormat(Byte& value, Span`1<char> destination, Int32& charsWritten, ReadOnlySpan`1<char> format);
    [NullableContextAttribute("0")]
public abstract virtual bool TryFormat(object value, Span`1<char> destination, Int32& charsWritten, ReadOnlySpan`1<char> format);
    [NullableContextAttribute("0")]
public abstract virtual bool TryFormat(Byte& value, Span`1<char> destination, Int32& charsWritten, ValueCollection`1<EnumFormat> formats);
    [NullableContextAttribute("0")]
public abstract virtual bool TryFormat(object value, Span`1<char> destination, Int32& charsWritten, ValueCollection`1<EnumFormat> formats);
    [NullableContextAttribute("0")]
public abstract virtual bool TryFormatFlags(Byte& value, Span`1<char> destination, Int32& charsWritten, ReadOnlySpan`1<char> delimiter, ValueCollection`1<EnumFormat> formats);
    [NullableContextAttribute("0")]
public abstract virtual bool TryFormatFlags(object value, Span`1<char> destination, Int32& charsWritten, ReadOnlySpan`1<char> delimiter, ValueCollection`1<EnumFormat> formats);
    [NullableContextAttribute("0")]
internal static bool TryWriteNonNullableStringToSpan(string str, Span`1<char> destination, Int32& charsWritten);
    [NullableContextAttribute("0")]
public abstract virtual bool TryParse(string value, bool ignoreCase, Byte& result, ValueCollection`1<EnumFormat> formats);
    [NullableContextAttribute("2")]
public abstract virtual bool TryParse(string value, bool ignoreCase, Object& result, ValueCollection`1<EnumFormat> formats);
    [NullableContextAttribute("2")]
public abstract virtual bool TryParse(string value, bool ignoreCase, Byte& result);
    [NullableContextAttribute("2")]
public abstract virtual bool TryParse(string value, bool ignoreCase, Object& result);
    [NullableContextAttribute("2")]
public abstract virtual bool TryParseFlags(string value, bool ignoreCase, string delimiter, Byte& result, ValueCollection`1<EnumFormat> formats);
    [NullableContextAttribute("2")]
public abstract virtual bool TryParseFlags(string value, bool ignoreCase, string delimiter, Object& result, ValueCollection`1<EnumFormat> formats);
    public abstract virtual bool TryToObject(ulong value, Byte& result, EnumValidation validation);
    [NullableContextAttribute("2")]
public abstract virtual bool TryToObject(ulong value, Object& result, EnumValidation validation);
    [NullableContextAttribute("2")]
public abstract virtual bool TryToObject(object value, Byte& result, EnumValidation validation);
    [NullableContextAttribute("2")]
public abstract virtual bool TryToObject(object value, Object& result, EnumValidation validation);
    public abstract virtual bool TryToObject(long value, Byte& result, EnumValidation validation);
    [NullableContextAttribute("2")]
public abstract virtual bool TryToObject(long value, Object& result, EnumValidation validation);
    public abstract virtual void Validate(Byte& value, string paramName, EnumValidation validation);
    public abstract virtual object Validate(object value, string paramName, EnumValidation validation);
}
internal abstract class EnumsNET.EnumCache`2 : EnumCache {
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal IEnumBridge`2<TUnderlying, TUnderlyingOperations> EnumBridge;
    private bool _isContiguous;
    [NullableAttribute("2")]
private object _customValidator;
    private TUnderlying _allFlags;
    private protected TUnderlying _maxDefined;
    private protected TUnderlying _minDefined;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private EnumMemberInternal`2[] _buckets;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private EnumMemberInternal`2[] _members;
    private int _distinctCount;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private EnumMemberParser[] _enumMemberParsers;
    protected EnumCache`2(Type enumType, IEnumBridge`2<TUnderlying, TUnderlyingOperations> enumBridge, bool isFlagEnum, EnumMemberInternal`2[] members, EnumMemberInternal`2[] buckets, TUnderlying allFlags, int distinctCount, bool isContiguous, object customValidator);
    [NullableContextAttribute("1")]
protected sealed virtual EnumComparer CreateEnumComparer();
    public sealed virtual int GetMemberCount(EnumMemberSelection selection);
    [NullableContextAttribute("1")]
protected sealed virtual IReadOnlyList`1<EnumMember> GetMembersInternal(EnumMemberSelection selection, bool cached);
    [NullableContextAttribute("1")]
protected sealed virtual IReadOnlyList`1<string> GetNamesInternal(EnumMemberSelection selection, bool cached);
    [NullableContextAttribute("1")]
protected sealed virtual IValuesContainer GetValuesInternal(EnumMemberSelection selection, bool cached);
    private IEnumerable`1<EnumMemberInternal`2<TUnderlying, TUnderlyingOperations>> GetMembersInternal(EnumMemberSelection selection);
    public sealed virtual void ToObject(ulong value, EnumValidation validation, Byte& result);
    [NullableContextAttribute("1")]
public sealed virtual object ToObject(ulong value, EnumValidation validation);
    [NullableContextAttribute("1")]
public sealed virtual void ToObject(object value, EnumValidation validation, Byte& result);
    [NullableContextAttribute("1")]
public sealed virtual object ToObject(object value, EnumValidation validation);
    public sealed virtual void ToObject(long value, EnumValidation validation, Byte& result);
    [NullableContextAttribute("1")]
public sealed virtual object ToObject(long value, EnumValidation validation);
    public TUnderlying ToObject(object value);
    public TUnderlying ToObjectNoInlining(object value);
    public TUnderlying ToObjectInternal(object value, EnumValidation validation);
    public TUnderlying ToObject(long value);
    public TUnderlying ToObjectInternal(long value, EnumValidation validation);
    public TUnderlying ToObject(ulong value);
    public TUnderlying ToObjectInternal(ulong value, EnumValidation validation);
    [NullableContextAttribute("2")]
public sealed virtual bool TryToObject(object value, Byte& result, EnumValidation validation);
    [NullableContextAttribute("2")]
public sealed virtual bool TryToObject(object value, Object& result, EnumValidation validation);
    public sealed virtual bool TryToObject(long value, Byte& result, EnumValidation validation);
    [NullableContextAttribute("2")]
public sealed virtual bool TryToObject(long value, Object& result, EnumValidation validation);
    public sealed virtual bool TryToObject(ulong value, Byte& result, EnumValidation validation);
    [NullableContextAttribute("2")]
public sealed virtual bool TryToObject(ulong value, Object& result, EnumValidation validation);
    public bool TryToObject(object value, TUnderlying& result, EnumValidation validation);
    public bool TryToObject(long value, TUnderlying& result, EnumValidation validation);
    public bool TryToObject(ulong value, TUnderlying& result, EnumValidation validation);
    public sealed virtual bool IsValid(Byte& value, EnumValidation validation);
    [NullableContextAttribute("1")]
public sealed virtual bool IsValid(object value, EnumValidation validation);
    public bool IsValid(TUnderlying value, EnumValidation validation);
    public bool IsDefined(TUnderlying value);
    [NullableContextAttribute("1")]
public sealed virtual void Validate(Byte& value, string paramName, EnumValidation validation);
    [NullableContextAttribute("1")]
public sealed virtual object Validate(object value, string paramName, EnumValidation validation);
    public void Validate(TUnderlying value, string paramName, EnumValidation validation);
    [NullableContextAttribute("1")]
public sealed virtual string AsString(Byte& value, string format);
    [NullableContextAttribute("1")]
public sealed virtual string AsString(object value, string format);
    [NullableContextAttribute("2")]
public sealed virtual string AsString(Byte& value, EnumFormat format);
    [NullableContextAttribute("1")]
public sealed virtual string AsString(object value, EnumFormat format);
    public sealed virtual string AsString(Byte& value, ValueCollection`1<EnumFormat> formats);
    public sealed virtual string AsString(object value, ValueCollection`1<EnumFormat> formats);
    public string AsString(TUnderlying value);
    public string AsString(TUnderlying value, EnumFormat format);
    [NullableContextAttribute("1")]
internal string AsStringInternal(TUnderlying value, EnumMemberInternal`2<TUnderlying, TUnderlyingOperations> member, string format);
    internal string AsStringInternal(TUnderlying value, Boolean& isInitialized, EnumMemberInternal`2& member, EnumFormat format);
    private EnumMemberInternal`2<TUnderlying, TUnderlyingOperations> TryInitializeMember(TUnderlying value, Boolean& isInitialized, EnumMemberInternal`2& member);
    internal string AsStringInternal(TUnderlying value, EnumMemberInternal`2<TUnderlying, TUnderlyingOperations> member, ValueCollection`1<EnumFormat> formats);
    public sealed virtual bool TryFormat(Byte& value, Span`1<char> destination, Int32& charsWritten, ReadOnlySpan`1<char> format);
    public sealed virtual bool TryFormat(object value, Span`1<char> destination, Int32& charsWritten, ReadOnlySpan`1<char> format);
    internal bool TryFormatInternal(TUnderlying value, EnumMemberInternal`2<TUnderlying, TUnderlyingOperations> member, Span`1<char> destination, Int32& charsWritten, ReadOnlySpan`1<char> format);
    public sealed virtual bool TryFormat(Byte& value, Span`1<char> destination, Int32& charsWritten, ValueCollection`1<EnumFormat> formats);
    public sealed virtual bool TryFormat(object value, Span`1<char> destination, Int32& charsWritten, ValueCollection`1<EnumFormat> formats);
    internal bool TryFormatInternal(TUnderlying value, EnumMemberInternal`2<TUnderlying, TUnderlyingOperations> member, Span`1<char> destination, Int32& charsWritten, ValueCollection`1<EnumFormat> formats);
    private Nullable`1<bool> TryFormatInternal(TUnderlying value, Boolean& isInitialized, EnumMemberInternal`2& member, Span`1<char> destination, Int32& charsWritten, EnumFormat format);
    private static Nullable`1<bool> TryWriteStringToSpan(string str, Span`1<char> destination, Int32& charsWritten);
    [NullableContextAttribute("1")]
public sealed virtual object GetUnderlyingValue(object value);
    [NullableContextAttribute("1")]
public sealed virtual object GetUnderlyingValue(Byte& value);
    public sealed virtual int GetHashCode(Byte& value);
    public sealed virtual bool Equals(Byte& value, Byte& other);
    [NullableContextAttribute("1")]
public sealed virtual bool Equals(object value, object other);
    public sealed virtual int CompareTo(Byte& value, Byte& other);
    [NullableContextAttribute("1")]
public sealed virtual int CompareTo(object value, object other);
    public sealed virtual sbyte ToSByte(Byte& value);
    [NullableContextAttribute("1")]
public sealed virtual sbyte ToSByte(object value);
    public sealed virtual byte ToByte(Byte& value);
    [NullableContextAttribute("1")]
public sealed virtual byte ToByte(object value);
    public sealed virtual short ToInt16(Byte& value);
    [NullableContextAttribute("1")]
public sealed virtual short ToInt16(object value);
    public sealed virtual ushort ToUInt16(Byte& value);
    [NullableContextAttribute("1")]
public sealed virtual ushort ToUInt16(object value);
    public sealed virtual int ToInt32(Byte& value);
    [NullableContextAttribute("1")]
public sealed virtual int ToInt32(object value);
    public sealed virtual UInt32 ToUInt32(Byte& value);
    [NullableContextAttribute("1")]
public sealed virtual UInt32 ToUInt32(object value);
    public sealed virtual long ToInt64(Byte& value);
    [NullableContextAttribute("1")]
public sealed virtual long ToInt64(object value);
    public sealed virtual ulong ToUInt64(Byte& value);
    [NullableContextAttribute("1")]
public sealed virtual ulong ToUInt64(object value);
    [NullableContextAttribute("2")]
public virtual EnumMemberInternal GetMember(Byte& value);
    [NullableContextAttribute("1")]
public virtual EnumMemberInternal GetMember(object value);
    public EnumMemberInternal`2<TUnderlying, TUnderlyingOperations> GetMember(TUnderlying value);
    public sealed virtual EnumMember GetMember(string value, bool ignoreCase, ValueCollection`1<EnumFormat> formats);
    public TUnderlying ParseInternal(string value, bool ignoreCase);
    public bool TryParse(string value, bool ignoreCase, TUnderlying& result);
    protected bool TryParseInternal(string value, bool ignoreCase, TUnderlying& result, EnumMemberInternal`2& member, ValueCollection`1<EnumFormat> formats);
    protected bool TryParseInternal(string value, bool ignoreCase, TUnderlying& result);
    private EnumMemberParser<TUnderlying, TUnderlyingOperations> GetEnumMemberParser(EnumFormat format);
    private EnumMemberParser<TUnderlying, TUnderlyingOperations> AddEnumMemberParser(EnumFormat format, int index, EnumMemberParser[] parsers);
    public sealed virtual void GetAllFlags(Byte& result);
    [NullableContextAttribute("1")]
public sealed virtual object GetAllFlags();
    public sealed virtual bool IsValidFlagCombination(Byte& value);
    [NullableContextAttribute("1")]
public sealed virtual bool IsValidFlagCombination(object value);
    public bool IsValidFlagCombination(TUnderlying value);
    [NullableContextAttribute("2")]
public sealed virtual string FormatFlags(Byte& value, string delimiter, ValueCollection`1<EnumFormat> formats);
    [NullableContextAttribute("2")]
public sealed virtual string FormatFlags(object value, string delimiter, ValueCollection`1<EnumFormat> formats);
    private string FormatFlagsInternal(TUnderlying value, string delimiter, ValueCollection`1<EnumFormat> formats);
    internal string FormatFlagsInternal(TUnderlying value, EnumMemberInternal`2<TUnderlying, TUnderlyingOperations> member, string delimiter, ValueCollection`1<EnumFormat> formats);
    public sealed virtual bool TryFormatFlags(Byte& value, Span`1<char> destination, Int32& charsWritten, ReadOnlySpan`1<char> delimiter, ValueCollection`1<EnumFormat> formats);
    public sealed virtual bool TryFormatFlags(object value, Span`1<char> destination, Int32& charsWritten, ReadOnlySpan`1<char> delimiter, ValueCollection`1<EnumFormat> formats);
    private bool TryFormatFlags(TUnderlying value, Span`1<char> destination, Int32& charsWritten, ReadOnlySpan`1<char> delimiter, ValueCollection`1<EnumFormat> formats);
    internal bool TryFormatFlagsInternal(TUnderlying value, EnumMemberInternal`2<TUnderlying, TUnderlyingOperations> member, Span`1<char> destination, Int32& charsWritten, ReadOnlySpan`1<char> delimiter, ValueCollection`1<EnumFormat> formats);
    [NullableContextAttribute("1")]
public sealed virtual IReadOnlyList`1<object> GetFlags(object value);
    [NullableContextAttribute("1")]
public sealed virtual IValuesContainer GetFlags(Byte& value);
    public IValuesContainer GetFlags(TUnderlying value);
    [NullableContextAttribute("1")]
public sealed virtual IReadOnlyList`1<EnumMember> GetFlagMembers(Byte& value);
    [NullableContextAttribute("1")]
public sealed virtual IReadOnlyList`1<EnumMember> GetFlagMembers(object value);
    public IReadOnlyList`1<EnumMember> GetFlagMembers(TUnderlying value);
    [IteratorStateMachineAttribute("EnumsNET.EnumCache`2/<EnumerateFlagMembers>d__118")]
private IEnumerable`1<EnumMemberInternal`2<TUnderlying, TUnderlyingOperations>> EnumerateFlagMembers(TUnderlying value);
    public sealed virtual int GetFlagCount();
    public sealed virtual int GetFlagCount(Byte& value);
    [NullableContextAttribute("1")]
public sealed virtual int GetFlagCount(object value);
    public int GetFlagCount(TUnderlying value);
    public sealed virtual int GetFlagCount(Byte& value, Byte& otherFlags);
    [NullableContextAttribute("1")]
public sealed virtual int GetFlagCount(object value, object otherFlags);
    public int GetFlagCount(TUnderlying value, TUnderlying otherFlags);
    public sealed virtual bool HasAnyFlags(Byte& value);
    [NullableContextAttribute("1")]
public sealed virtual bool HasAnyFlags(object value);
    public bool HasAnyFlags(TUnderlying value);
    public sealed virtual bool HasAnyFlags(Byte& value, Byte& otherFlags);
    [NullableContextAttribute("1")]
public sealed virtual bool HasAnyFlags(object value, object otherFlags);
    public bool HasAnyFlags(TUnderlying value, TUnderlying otherFlags);
    public sealed virtual bool HasAllFlags(Byte& value);
    [NullableContextAttribute("1")]
public sealed virtual bool HasAllFlags(object value);
    public bool HasAllFlags(TUnderlying value);
    public sealed virtual bool HasAllFlags(Byte& value, Byte& otherFlags);
    [NullableContextAttribute("1")]
public sealed virtual bool HasAllFlags(object value, object otherFlags);
    public bool HasAllFlags(TUnderlying value, TUnderlying otherFlags);
    public sealed virtual void ToggleFlags(Byte& value, Byte& result);
    [NullableContextAttribute("1")]
public sealed virtual object ToggleFlags(object value);
    public TUnderlying ToggleFlags(TUnderlying value);
    public sealed virtual void ToggleFlags(Byte& value, Byte& otherFlags, Byte& result);
    [NullableContextAttribute("1")]
public sealed virtual object ToggleFlags(object value, object otherFlags);
    public TUnderlying ToggleFlags(TUnderlying value, TUnderlying otherFlags);
    public sealed virtual void CommonFlags(Byte& value, Byte& otherFlags, Byte& result);
    [NullableContextAttribute("1")]
public sealed virtual object CommonFlags(object value, object otherFlags);
    public TUnderlying CommonFlags(TUnderlying value, TUnderlying otherFlags);
    public sealed virtual void CombineFlags(Byte& value, Byte& otherFlags, Byte& result);
    [NullableContextAttribute("1")]
public sealed virtual object CombineFlags(object value, object otherFlags);
    public sealed virtual void CombineFlags(Byte& flag0, Byte& flag1, Byte& flag2, Byte& result);
    public sealed virtual void CombineFlags(Byte& flag0, Byte& flag1, Byte& flag2, Byte& flag3, Byte& result);
    public sealed virtual void CombineFlags(Byte& flag0, Byte& flag1, Byte& flag2, Byte& flag3, Byte& flag4, Byte& result);
    [NullableContextAttribute("1")]
public sealed virtual object CombineFlags(IEnumerable`1<object> flags, bool isNullable);
    public sealed virtual void RemoveFlags(Byte& value, Byte& otherFlags, Byte& result);
    [NullableContextAttribute("1")]
public sealed virtual object RemoveFlags(object value, object otherFlags);
    public TUnderlying RemoveFlags(TUnderlying value, TUnderlying otherFlags);
    public sealed virtual void ParseFlags(string value, bool ignoreCase, string delimiter, ValueCollection`1<EnumFormat> formats, Byte& result);
    [NullableContextAttribute("1")]
public sealed virtual object ParseFlags(string value, bool ignoreCase, string delimiter, ValueCollection`1<EnumFormat> formats);
    public TUnderlying ParseFlagsInternal(string value, bool ignoreCase, string delimiter, ValueCollection`1<EnumFormat> formats);
    [NullableContextAttribute("2")]
public sealed virtual bool TryParseFlags(string value, bool ignoreCase, string delimiter, Byte& result, ValueCollection`1<EnumFormat> formats);
    [NullableContextAttribute("2")]
public sealed virtual bool TryParseFlags(string value, bool ignoreCase, string delimiter, Object& result, ValueCollection`1<EnumFormat> formats);
    public bool TryParseFlags(string value, bool ignoreCase, string delimiter, TUnderlying& result, ValueCollection`1<EnumFormat> formats);
    [CompilerGeneratedAttribute]
private int <TryFormatFlagsInternal>g__Iterate|111_0(ReadOnlySpan`1<char> delimiter, Span`1<char> dest, int maxLength, <>c__DisplayClass111_0& );
}
public abstract class EnumsNET.EnumComparer : object {
    [NullableAttribute("1")]
private protected EnumCache _enumCache;
    [NullableContextAttribute("1")]
private protected EnumComparer(EnumCache enumCache);
    [NullableContextAttribute("1")]
public static EnumComparer GetInstance(Type enumType);
    [NullableContextAttribute("2")]
public sealed virtual bool Equals(object x, object y);
    [NullableContextAttribute("2")]
public sealed virtual int GetHashCode(object obj);
    [NullableContextAttribute("2")]
public sealed virtual int Compare(object x, object y);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class EnumsNET.EnumComparer`1 : EnumComparer {
    public static EnumComparer`1<TEnum> Instance { get; }
    internal EnumComparer`1(EnumCache enumCache);
    public static EnumComparer`1<TEnum> get_Instance();
    public sealed virtual bool Equals(TEnum x, TEnum y);
    public sealed virtual int GetHashCode(TEnum obj);
    public sealed virtual int Compare(TEnum x, TEnum y);
}
[EnumFormatValidatorAttribute]
public enum EnumsNET.EnumFormat : Enum {
    public int value__;
    public static EnumFormat DecimalValue;
    public static EnumFormat HexadecimalValue;
    public static EnumFormat UnderlyingValue;
    public static EnumFormat Name;
    public static EnumFormat Description;
    public static EnumFormat EnumMemberValue;
    public static EnumFormat DisplayName;
}
[AttributeUsageAttribute("16")]
internal class EnumsNET.EnumFormatValidatorAttribute : Attribute {
    public sealed virtual bool IsValid(EnumFormat value);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
public abstract class EnumsNET.EnumMember : object {
    [NullableAttribute("1")]
private protected EnumMemberInternal Member;
    [NullableAttribute("1")]
public object Value { get; }
    [NullableAttribute("1")]
public string Name { get; }
    [NullableAttribute("1")]
public AttributeCollection Attributes { get; }
    [NullableContextAttribute("1")]
private protected EnumMember(EnumMemberInternal member);
    [NullableContextAttribute("1")]
public object get_Value();
    [NullableContextAttribute("1")]
public string get_Name();
    [NullableContextAttribute("1")]
public AttributeCollection get_Attributes();
    [NullableContextAttribute("1")]
public sealed virtual string ToString();
    [NullableContextAttribute("1")]
public string AsString();
    [NullableContextAttribute("1")]
public string AsString(string format);
    public string AsString(EnumFormat format);
    public string AsString(EnumFormat format0, EnumFormat format1);
    public string AsString(EnumFormat format0, EnumFormat format1, EnumFormat format2);
    public string AsString(EnumFormat[] formats);
    [NullableContextAttribute("0")]
public bool TryFormat(Span`1<char> destination, Int32& charsWritten);
    [NullableContextAttribute("0")]
public bool TryFormat(Span`1<char> destination, Int32& charsWritten, ReadOnlySpan`1<char> format);
    [NullableContextAttribute("0")]
public bool TryFormat(Span`1<char> destination, Int32& charsWritten, EnumFormat[] formats);
    [NullableContextAttribute("1")]
public object GetUnderlyingValue();
    [CLSCompliantAttribute("False")]
public sbyte ToSByte();
    public byte ToByte();
    public short ToInt16();
    [CLSCompliantAttribute("False")]
public ushort ToUInt16();
    public int ToInt32();
    [CLSCompliantAttribute("False")]
public UInt32 ToUInt32();
    public long ToInt64();
    [CLSCompliantAttribute("False")]
public ulong ToUInt64();
    public sealed virtual int GetHashCode();
    public sealed virtual bool Equals(EnumMember other);
    public sealed virtual bool Equals(object other);
    [NullableContextAttribute("1")]
private protected abstract virtual object GetValue();
    [NullableContextAttribute("1")]
internal IValuesContainer GetFlags();
    [NullableContextAttribute("1")]
internal IReadOnlyList`1<EnumMember> GetFlagMembers();
    internal bool IsValidFlagCombination();
    internal int GetFlagCount();
    internal bool HasAnyFlags();
    internal bool HasAllFlags();
    private sealed virtual override string System.IFormattable.ToString(string format, IFormatProvider formatProvider);
    private sealed virtual override TypeCode System.IConvertible.GetTypeCode();
    private sealed virtual override bool System.IConvertible.ToBoolean(IFormatProvider provider);
    private sealed virtual override char System.IConvertible.ToChar(IFormatProvider provider);
    private sealed virtual override sbyte System.IConvertible.ToSByte(IFormatProvider provider);
    private sealed virtual override byte System.IConvertible.ToByte(IFormatProvider provider);
    private sealed virtual override short System.IConvertible.ToInt16(IFormatProvider provider);
    private sealed virtual override ushort System.IConvertible.ToUInt16(IFormatProvider provider);
    private sealed virtual override int System.IConvertible.ToInt32(IFormatProvider provider);
    private sealed virtual override UInt32 System.IConvertible.ToUInt32(IFormatProvider provider);
    private sealed virtual override long System.IConvertible.ToInt64(IFormatProvider provider);
    private sealed virtual override ulong System.IConvertible.ToUInt64(IFormatProvider provider);
    private sealed virtual override float System.IConvertible.ToSingle(IFormatProvider provider);
    private sealed virtual override double System.IConvertible.ToDouble(IFormatProvider provider);
    private sealed virtual override decimal System.IConvertible.ToDecimal(IFormatProvider provider);
    private sealed virtual override DateTime System.IConvertible.ToDateTime(IFormatProvider provider);
    [NullableContextAttribute("1")]
private sealed virtual override string System.IConvertible.ToString(IFormatProvider provider);
    [NullableContextAttribute("1")]
private sealed virtual override object System.IConvertible.ToType(Type conversionType, IFormatProvider provider);
    private sealed virtual override int System.IComparable.CompareTo(object obj);
    private sealed virtual override int System.IComparable<EnumsNET.EnumMember>.CompareTo(EnumMember other);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class EnumsNET.EnumMember`1 : EnumMember {
    public TEnum Value { get; }
    internal EnumMember`1(EnumMemberInternal member);
    public TEnum get_Value();
    public sealed virtual bool Equals(EnumMember`1<TEnum> other);
    private protected virtual object GetValue();
    [NullableContextAttribute("2")]
private sealed virtual override int System.IComparable<EnumsNET.EnumMember>.CompareTo(EnumMember other);
    private sealed virtual override int System.IComparable<EnumsNET.EnumMember<TEnum>>.CompareTo(EnumMember`1<TEnum> other);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal abstract class EnumsNET.EnumMemberInternal : object {
    public string Name;
    public AttributeCollection Attributes;
    [NullableAttribute("2")]
private EnumMember _enumMember;
    public EnumMember EnumMember { get; }
    protected EnumMemberInternal(string name, AttributeCollection attributes);
    public EnumMember get_EnumMember();
    private protected abstract virtual EnumMember CreateEnumMember();
    public abstract virtual void GetValue(Byte& result);
    public abstract virtual object GetValue();
    public abstract virtual string AsString(string format);
    [NullableContextAttribute("2")]
public abstract virtual string AsString(EnumFormat format);
    [NullableContextAttribute("0")]
public abstract virtual string AsString(ValueCollection`1<EnumFormat> formats);
    [NullableContextAttribute("0")]
public abstract virtual bool TryFormat(Span`1<char> destination, Int32& charsWritten, ReadOnlySpan`1<char> format);
    [NullableContextAttribute("0")]
public abstract virtual bool TryFormat(Span`1<char> destination, Int32& charsWritten, ValueCollection`1<EnumFormat> formats);
    public abstract virtual byte ToByte();
    public abstract virtual short ToInt16();
    public abstract virtual int ToInt32();
    public abstract virtual long ToInt64();
    public abstract virtual sbyte ToSByte();
    public abstract virtual ushort ToUInt16();
    public abstract virtual UInt32 ToUInt32();
    public abstract virtual ulong ToUInt64();
    public abstract virtual bool IsValidFlagCombination();
    public abstract virtual bool HasAnyFlags();
    public abstract virtual bool HasAllFlags();
    public abstract virtual int GetFlagCount();
    public abstract virtual IValuesContainer GetFlags();
    public abstract virtual IReadOnlyList`1<EnumMember> GetFlagMembers();
    [NullableContextAttribute("2")]
public abstract virtual int CompareTo(EnumMemberInternal other);
    public abstract virtual TypeCode GetTypeCode();
    [NullableContextAttribute("2")]
public abstract virtual bool ToBoolean(IFormatProvider provider);
    [NullableContextAttribute("2")]
public abstract virtual char ToChar(IFormatProvider provider);
    [NullableContextAttribute("2")]
public abstract virtual float ToSingle(IFormatProvider provider);
    [NullableContextAttribute("2")]
public abstract virtual double ToDouble(IFormatProvider provider);
    [NullableContextAttribute("2")]
public abstract virtual decimal ToDecimal(IFormatProvider provider);
    [NullableContextAttribute("2")]
public abstract virtual DateTime ToDateTime(IFormatProvider provider);
    public abstract virtual object ToType(Type conversionType, IFormatProvider provider);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class EnumsNET.EnumMemberInternal`2 : EnumMemberInternal {
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal EnumCache`2<TUnderlying, TUnderlyingOperations> EnumCache;
    [NullableAttribute("0")]
public TUnderlying Value;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal EnumMemberInternal`2<TUnderlying, TUnderlyingOperations> Next;
    public EnumMemberInternal`2(TUnderlying value, string name, AttributeCollection attributes);
    private protected virtual EnumMember CreateEnumMember();
    public virtual void GetValue(Byte& result);
    public virtual object GetValue();
    public virtual string AsString(string format);
    [NullableContextAttribute("2")]
public virtual string AsString(EnumFormat format);
    [NullableContextAttribute("0")]
public virtual string AsString(ValueCollection`1<EnumFormat> formats);
    [NullableContextAttribute("0")]
public virtual bool TryFormat(Span`1<char> destination, Int32& charsWritten, ReadOnlySpan`1<char> format);
    [NullableContextAttribute("0")]
public virtual bool TryFormat(Span`1<char> destination, Int32& charsWritten, ValueCollection`1<EnumFormat> formats);
    public virtual int GetHashCode();
    public virtual bool IsValidFlagCombination();
    public virtual int GetFlagCount();
    public virtual bool HasAnyFlags();
    public virtual bool HasAllFlags();
    public virtual IValuesContainer GetFlags();
    public virtual IReadOnlyList`1<EnumMember> GetFlagMembers();
    [NullableContextAttribute("2")]
public virtual int CompareTo(EnumMemberInternal other);
    public sealed virtual bool Equals(EnumMemberInternal`2<TUnderlying, TUnderlyingOperations> other);
    public virtual sbyte ToSByte();
    public virtual byte ToByte();
    public virtual short ToInt16();
    public virtual ushort ToUInt16();
    public virtual int ToInt32();
    public virtual UInt32 ToUInt32();
    public virtual long ToInt64();
    public virtual ulong ToUInt64();
    public virtual TypeCode GetTypeCode();
    [NullableContextAttribute("2")]
public virtual bool ToBoolean(IFormatProvider provider);
    [NullableContextAttribute("2")]
public virtual char ToChar(IFormatProvider provider);
    [NullableContextAttribute("2")]
public virtual float ToSingle(IFormatProvider provider);
    [NullableContextAttribute("2")]
public virtual double ToDouble(IFormatProvider provider);
    [NullableContextAttribute("2")]
public virtual decimal ToDecimal(IFormatProvider provider);
    [NullableContextAttribute("2")]
public virtual DateTime ToDateTime(IFormatProvider provider);
    public virtual object ToType(Type conversionType, IFormatProvider provider);
}
[FlagsAttribute]
public enum EnumsNET.EnumMemberSelection : Enum {
    public int value__;
    public static EnumMemberSelection All;
    public static EnumMemberSelection Distinct;
    public static EnumMemberSelection Flags;
    public static EnumMemberSelection DisplayOrder;
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
public static class EnumsNET.Enums : object {
    private static int s_startingCustomEnumFormatValue;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private static Func`2[] s_customEnumMemberFormatters;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private static EnumCache[] s_enumCacheBuckets;
    private static object s_lockObject;
    private static int s_enumCacheCount;
    [NullableAttribute("0")]
internal static ValueCollection`1<EnumFormat> DefaultFormats { get; }
    [NullableAttribute("0")]
internal static ValueCollection`1<EnumFormat> NameFormat { get; }
    private static Enums();
    [NullableContextAttribute("0")]
internal static ValueCollection`1<EnumFormat> get_DefaultFormats();
    [NullableContextAttribute("0")]
internal static ValueCollection`1<EnumFormat> get_NameFormat();
    public static EnumFormat RegisterCustomEnumFormat(Func`2<EnumMember, string> enumMemberFormatter);
    internal static bool EnumFormatIsValid(EnumFormat format);
    [NullableContextAttribute("2")]
internal static string CustomEnumMemberFormat(EnumMember member, EnumFormat format);
    public static Type GetUnderlyingType();
    [NullableContextAttribute("0")]
public static TypeCode GetTypeCode();
    [NullableContextAttribute("0")]
public static int GetMemberCount(EnumMemberSelection selection);
    [NullableContextAttribute("0")]
public static IReadOnlyList`1<EnumMember`1<TEnum>> GetMembers(EnumMemberSelection selection);
    public static IReadOnlyList`1<string> GetNames(EnumMemberSelection selection);
    [NullableContextAttribute("0")]
public static IReadOnlyList`1<TEnum> GetValues(EnumMemberSelection selection);
    [NullableContextAttribute("0")]
public static TEnum ToObject(object value, EnumValidation validation);
    [NullableContextAttribute("0")]
[CLSCompliantAttribute("False")]
public static TEnum ToObject(sbyte value, EnumValidation validation);
    [NullableContextAttribute("0")]
public static TEnum ToObject(byte value, EnumValidation validation);
    [NullableContextAttribute("0")]
public static TEnum ToObject(short value, EnumValidation validation);
    [NullableContextAttribute("0")]
[CLSCompliantAttribute("False")]
public static TEnum ToObject(ushort value, EnumValidation validation);
    [NullableContextAttribute("0")]
public static TEnum ToObject(int value, EnumValidation validation);
    [NullableContextAttribute("0")]
[CLSCompliantAttribute("False")]
public static TEnum ToObject(UInt32 value, EnumValidation validation);
    [NullableContextAttribute("0")]
public static TEnum ToObject(long value, EnumValidation validation);
    [NullableContextAttribute("0")]
[CLSCompliantAttribute("False")]
public static TEnum ToObject(ulong value, EnumValidation validation);
    [NullableContextAttribute("0")]
public static bool TryToObject(object value, TEnum& result, EnumValidation validation);
    [NullableContextAttribute("0")]
[CLSCompliantAttribute("False")]
public static bool TryToObject(sbyte value, TEnum& result, EnumValidation validation);
    [NullableContextAttribute("0")]
public static bool TryToObject(byte value, TEnum& result, EnumValidation validation);
    [NullableContextAttribute("0")]
public static bool TryToObject(short value, TEnum& result, EnumValidation validation);
    [NullableContextAttribute("0")]
[CLSCompliantAttribute("False")]
public static bool TryToObject(ushort value, TEnum& result, EnumValidation validation);
    [NullableContextAttribute("0")]
public static bool TryToObject(int value, TEnum& result, EnumValidation validation);
    [NullableContextAttribute("0")]
[CLSCompliantAttribute("False")]
public static bool TryToObject(UInt32 value, TEnum& result, EnumValidation validation);
    [NullableContextAttribute("0")]
public static bool TryToObject(long value, TEnum& result, EnumValidation validation);
    [NullableContextAttribute("0")]
[CLSCompliantAttribute("False")]
public static bool TryToObject(ulong value, TEnum& result, EnumValidation validation);
    [NullableContextAttribute("0")]
[ExtensionAttribute]
public static bool IsValid(TEnum value, EnumValidation validation);
    [NullableContextAttribute("0")]
[ExtensionAttribute]
public static bool IsDefined(TEnum value);
    [NullableContextAttribute("0")]
[ExtensionAttribute]
public static TEnum Validate(TEnum value, string paramName, EnumValidation validation);
    [NullableContextAttribute("0")]
[ExtensionAttribute]
public static string AsString(TEnum value);
    [NullableContextAttribute("0")]
[ExtensionAttribute]
public static string AsString(TEnum value, string format);
    [NullableContextAttribute("0")]
[ExtensionAttribute]
public static string AsString(TEnum value, EnumFormat format);
    [NullableContextAttribute("0")]
[ExtensionAttribute]
public static string AsString(TEnum value, EnumFormat format0, EnumFormat format1);
    [NullableContextAttribute("0")]
[ExtensionAttribute]
public static string AsString(TEnum value, EnumFormat format0, EnumFormat format1, EnumFormat format2);
    [NullableContextAttribute("0")]
[ExtensionAttribute]
public static string AsString(TEnum value, EnumFormat[] formats);
    [NullableContextAttribute("0")]
[ExtensionAttribute]
public static bool TryFormat(TEnum value, Span`1<char> destination, Int32& charsWritten);
    [NullableContextAttribute("0")]
[ExtensionAttribute]
public static bool TryFormat(TEnum value, Span`1<char> destination, Int32& charsWritten, ReadOnlySpan`1<char> format);
    [NullableContextAttribute("0")]
[ExtensionAttribute]
public static bool TryFormat(TEnum value, Span`1<char> destination, Int32& charsWritten, EnumFormat[] formats);
    public static string Format(TEnum value, string format);
    [NullableContextAttribute("0")]
public static object GetUnderlyingValue(TEnum value);
    [NullableContextAttribute("0")]
[CLSCompliantAttribute("False")]
public static sbyte ToSByte(TEnum value);
    [NullableContextAttribute("0")]
public static byte ToByte(TEnum value);
    [NullableContextAttribute("0")]
public static short ToInt16(TEnum value);
    [NullableContextAttribute("0")]
[CLSCompliantAttribute("False")]
public static ushort ToUInt16(TEnum value);
    [NullableContextAttribute("0")]
public static int ToInt32(TEnum value);
    [NullableContextAttribute("0")]
[CLSCompliantAttribute("False")]
public static UInt32 ToUInt32(TEnum value);
    [NullableContextAttribute("0")]
public static long ToInt64(TEnum value);
    [NullableContextAttribute("0")]
[CLSCompliantAttribute("False")]
public static ulong ToUInt64(TEnum value);
    [NullableContextAttribute("0")]
public static int GetHashCode(TEnum value);
    [NullableContextAttribute("0")]
[ExtensionAttribute]
public static bool Equals(TEnum value, TEnum other);
    [NullableContextAttribute("0")]
[ExtensionAttribute]
public static int CompareTo(TEnum value, TEnum other);
    [NullableContextAttribute("0")]
[ExtensionAttribute]
public static string GetName(TEnum value);
    [NullableContextAttribute("0")]
[ExtensionAttribute]
public static AttributeCollection GetAttributes(TEnum value);
    [NullableContextAttribute("0")]
[ExtensionAttribute]
public static EnumMember`1<TEnum> GetMember(TEnum value);
    public static EnumMember`1<TEnum> GetMember(string name);
    public static EnumMember`1<TEnum> GetMember(string name, bool ignoreCase);
    public static EnumMember`1<TEnum> GetMember(string value, bool ignoreCase, EnumFormat format);
    public static EnumMember`1<TEnum> GetMember(string value, bool ignoreCase, EnumFormat format0, EnumFormat format1);
    public static EnumMember`1<TEnum> GetMember(string value, bool ignoreCase, EnumFormat format0, EnumFormat format1, EnumFormat format2);
    public static EnumMember`1<TEnum> GetMember(string value, bool ignoreCase, EnumFormat[] formats);
    [NullableContextAttribute("0")]
private static EnumMember`1<TEnum> GetMember(string value, bool ignoreCase, ValueCollection`1<EnumFormat> formats);
    [NullableContextAttribute("0")]
public static TEnum Parse(string value);
    [NullableContextAttribute("0")]
public static TEnum Parse(string value, bool ignoreCase);
    [NullableContextAttribute("0")]
public static TEnum Parse(string value, bool ignoreCase, EnumFormat format);
    [NullableContextAttribute("0")]
public static TEnum Parse(string value, bool ignoreCase, EnumFormat format0, EnumFormat format1);
    [NullableContextAttribute("0")]
public static TEnum Parse(string value, bool ignoreCase, EnumFormat format0, EnumFormat format1, EnumFormat format2);
    [NullableContextAttribute("0")]
public static TEnum Parse(string value, bool ignoreCase, EnumFormat[] formats);
    [NullableContextAttribute("0")]
private static TEnum Parse(string value, bool ignoreCase, ValueCollection`1<EnumFormat> formats);
    [NullableContextAttribute("0")]
public static bool TryParse(string value, TEnum& result);
    [NullableContextAttribute("0")]
public static bool TryParse(string value, bool ignoreCase, TEnum& result);
    [NullableContextAttribute("0")]
public static bool TryParse(string value, bool ignoreCase, TEnum& result, EnumFormat format);
    [NullableContextAttribute("0")]
public static bool TryParse(string value, bool ignoreCase, TEnum& result, EnumFormat format0, EnumFormat format1);
    [NullableContextAttribute("0")]
public static bool TryParse(string value, bool ignoreCase, TEnum& result, EnumFormat format0, EnumFormat format1, EnumFormat format2);
    [NullableContextAttribute("0")]
public static bool TryParse(string value, bool ignoreCase, TEnum& result, EnumFormat[] formats);
    [NullableContextAttribute("0")]
private static bool TryParse(string value, bool ignoreCase, TEnum& result, ValueCollection`1<EnumFormat> formats);
    internal static EnumCache GetCacheUnsafe();
    public static Type GetUnderlyingTypeUnsafe();
    [NullableContextAttribute("2")]
public static TypeCode GetTypeCodeUnsafe();
    [NullableContextAttribute("2")]
public static int GetMemberCountUnsafe(EnumMemberSelection selection);
    public static IReadOnlyList`1<EnumMember`1<TEnum>> GetMembersUnsafe(EnumMemberSelection selection);
    public static IReadOnlyList`1<string> GetNamesUnsafe(EnumMemberSelection selection);
    public static IReadOnlyList`1<TEnum> GetValuesUnsafe(EnumMemberSelection selection);
    public static TEnum ToObjectUnsafe(object value, EnumValidation validation);
    [CLSCompliantAttribute("False")]
public static TEnum ToObjectUnsafe(sbyte value, EnumValidation validation);
    public static TEnum ToObjectUnsafe(byte value, EnumValidation validation);
    public static TEnum ToObjectUnsafe(short value, EnumValidation validation);
    [CLSCompliantAttribute("False")]
public static TEnum ToObjectUnsafe(ushort value, EnumValidation validation);
    public static TEnum ToObjectUnsafe(int value, EnumValidation validation);
    [CLSCompliantAttribute("False")]
public static TEnum ToObjectUnsafe(UInt32 value, EnumValidation validation);
    public static TEnum ToObjectUnsafe(long value, EnumValidation validation);
    [CLSCompliantAttribute("False")]
public static TEnum ToObjectUnsafe(ulong value, EnumValidation validation);
    [NullableContextAttribute("2")]
public static bool TryToObjectUnsafe(object value, TEnum& result, EnumValidation validation);
    [CLSCompliantAttribute("False")]
public static bool TryToObjectUnsafe(sbyte value, TEnum& result, EnumValidation validation);
    public static bool TryToObjectUnsafe(byte value, TEnum& result, EnumValidation validation);
    public static bool TryToObjectUnsafe(short value, TEnum& result, EnumValidation validation);
    [CLSCompliantAttribute("False")]
public static bool TryToObjectUnsafe(ushort value, TEnum& result, EnumValidation validation);
    public static bool TryToObjectUnsafe(int value, TEnum& result, EnumValidation validation);
    [CLSCompliantAttribute("False")]
public static bool TryToObjectUnsafe(UInt32 value, TEnum& result, EnumValidation validation);
    public static bool TryToObjectUnsafe(long value, TEnum& result, EnumValidation validation);
    [CLSCompliantAttribute("False")]
public static bool TryToObjectUnsafe(ulong value, TEnum& result, EnumValidation validation);
    public static bool IsValidUnsafe(TEnum value, EnumValidation validation);
    public static bool IsDefinedUnsafe(TEnum value);
    public static TEnum ValidateUnsafe(TEnum value, string paramName, EnumValidation validation);
    public static string AsStringUnsafe(TEnum value);
    public static string AsStringUnsafe(TEnum value, string format);
    [NullableContextAttribute("2")]
public static string AsStringUnsafe(TEnum value, EnumFormat format);
    [NullableContextAttribute("2")]
public static string AsStringUnsafe(TEnum value, EnumFormat format0, EnumFormat format1);
    [NullableContextAttribute("2")]
public static string AsStringUnsafe(TEnum value, EnumFormat format0, EnumFormat format1, EnumFormat format2);
    [NullableContextAttribute("2")]
public static string AsStringUnsafe(TEnum value, EnumFormat[] formats);
    [NullableContextAttribute("0")]
public static bool TryFormatUnsafe(TEnum value, Span`1<char> destination, Int32& charsWritten);
    [NullableContextAttribute("0")]
public static bool TryFormatUnsafe(TEnum value, Span`1<char> destination, Int32& charsWritten, ReadOnlySpan`1<char> format);
    [NullableContextAttribute("2")]
public static bool TryFormatUnsafe(TEnum value, Span`1<char> destination, Int32& charsWritten, EnumFormat[] formats);
    public static string FormatUnsafe(TEnum value, string format);
    public static object GetUnderlyingValueUnsafe(TEnum value);
    [CLSCompliantAttribute("False")]
public static sbyte ToSByteUnsafe(TEnum value);
    public static byte ToByteUnsafe(TEnum value);
    public static short ToInt16Unsafe(TEnum value);
    [CLSCompliantAttribute("False")]
public static ushort ToUInt16Unsafe(TEnum value);
    public static int ToInt32Unsafe(TEnum value);
    [CLSCompliantAttribute("False")]
public static UInt32 ToUInt32Unsafe(TEnum value);
    public static long ToInt64Unsafe(TEnum value);
    [CLSCompliantAttribute("False")]
public static ulong ToUInt64Unsafe(TEnum value);
    public static int GetHashCodeUnsafe(TEnum value);
    public static bool EqualsUnsafe(TEnum value, TEnum other);
    public static int CompareToUnsafe(TEnum value, TEnum other);
    [NullableContextAttribute("2")]
public static string GetNameUnsafe(TEnum value);
    [NullableContextAttribute("2")]
public static AttributeCollection GetAttributesUnsafe(TEnum value);
    public static EnumMember`1<TEnum> GetMemberUnsafe(TEnum value);
    public static EnumMember`1<TEnum> GetMemberUnsafe(string name);
    public static EnumMember`1<TEnum> GetMemberUnsafe(string name, bool ignoreCase);
    public static EnumMember`1<TEnum> GetMemberUnsafe(string value, bool ignoreCase, EnumFormat format);
    public static EnumMember`1<TEnum> GetMemberUnsafe(string value, bool ignoreCase, EnumFormat format0, EnumFormat format1);
    public static EnumMember`1<TEnum> GetMemberUnsafe(string value, bool ignoreCase, EnumFormat format0, EnumFormat format1, EnumFormat format2);
    [NullableContextAttribute("2")]
public static EnumMember`1<TEnum> GetMemberUnsafe(string value, bool ignoreCase, EnumFormat[] formats);
    [NullableContextAttribute("0")]
private static EnumMember`1<TEnum> GetMemberUnsafe(string value, bool ignoreCase, ValueCollection`1<EnumFormat> formats);
    public static TEnum ParseUnsafe(string value);
    public static TEnum ParseUnsafe(string value, bool ignoreCase);
    public static TEnum ParseUnsafe(string value, bool ignoreCase, EnumFormat format);
    public static TEnum ParseUnsafe(string value, bool ignoreCase, EnumFormat format0, EnumFormat format1);
    public static TEnum ParseUnsafe(string value, bool ignoreCase, EnumFormat format0, EnumFormat format1, EnumFormat format2);
    public static TEnum ParseUnsafe(string value, bool ignoreCase, EnumFormat[] formats);
    private static TEnum ParseUnsafe(string value, bool ignoreCase, ValueCollection`1<EnumFormat> formats);
    [NullableContextAttribute("2")]
public static bool TryParseUnsafe(string value, TEnum& result);
    [NullableContextAttribute("2")]
public static bool TryParseUnsafe(string value, bool ignoreCase, TEnum& result);
    [NullableContextAttribute("2")]
public static bool TryParseUnsafe(string value, bool ignoreCase, TEnum& result, EnumFormat format);
    [NullableContextAttribute("2")]
public static bool TryParseUnsafe(string value, bool ignoreCase, TEnum& result, EnumFormat format0, EnumFormat format1);
    [NullableContextAttribute("2")]
public static bool TryParseUnsafe(string value, bool ignoreCase, TEnum& result, EnumFormat format0, EnumFormat format1, EnumFormat format2);
    [NullableContextAttribute("2")]
public static bool TryParseUnsafe(string value, bool ignoreCase, TEnum& result, EnumFormat[] formats);
    [NullableContextAttribute("2")]
private static bool TryParseUnsafe(string value, bool ignoreCase, TEnum& result, ValueCollection`1<EnumFormat> formats);
    internal static EnumCache GetCache(Type enumType);
    private static EnumCache GetOrAddCache(Type enumType);
    public static Type GetUnderlyingType(Type enumType);
    public static TypeCode GetTypeCode(Type enumType);
    public static int GetMemberCount(Type enumType, EnumMemberSelection selection);
    public static IReadOnlyList`1<EnumMember> GetMembers(Type enumType, EnumMemberSelection selection);
    public static IReadOnlyList`1<string> GetNames(Type enumType, EnumMemberSelection selection);
    public static IReadOnlyList`1<object> GetValues(Type enumType, EnumMemberSelection selection);
    public static object ToObject(Type enumType, object value, EnumValidation validation);
    [CLSCompliantAttribute("False")]
public static object ToObject(Type enumType, sbyte value, EnumValidation validation);
    public static object ToObject(Type enumType, byte value, EnumValidation validation);
    public static object ToObject(Type enumType, short value, EnumValidation validation);
    [CLSCompliantAttribute("False")]
public static object ToObject(Type enumType, ushort value, EnumValidation validation);
    public static object ToObject(Type enumType, int value, EnumValidation validation);
    [CLSCompliantAttribute("False")]
public static object ToObject(Type enumType, UInt32 value, EnumValidation validation);
    public static object ToObject(Type enumType, long value, EnumValidation validation);
    [CLSCompliantAttribute("False")]
public static object ToObject(Type enumType, ulong value, EnumValidation validation);
    [NullableContextAttribute("2")]
public static bool TryToObject(Type enumType, object value, Object& result, EnumValidation validation);
    [CLSCompliantAttribute("False")]
public static bool TryToObject(Type enumType, sbyte value, Object& result, EnumValidation validation);
    public static bool TryToObject(Type enumType, byte value, Object& result, EnumValidation validation);
    public static bool TryToObject(Type enumType, short value, Object& result, EnumValidation validation);
    [CLSCompliantAttribute("False")]
public static bool TryToObject(Type enumType, ushort value, Object& result, EnumValidation validation);
    public static bool TryToObject(Type enumType, int value, Object& result, EnumValidation validation);
    [CLSCompliantAttribute("False")]
public static bool TryToObject(Type enumType, UInt32 value, Object& result, EnumValidation validation);
    public static bool TryToObject(Type enumType, long value, Object& result, EnumValidation validation);
    [CLSCompliantAttribute("False")]
public static bool TryToObject(Type enumType, ulong value, Object& result, EnumValidation validation);
    public static bool IsValid(Type enumType, object value, EnumValidation validation);
    public static bool IsDefined(Type enumType, object value);
    public static object Validate(Type enumType, object value, string paramName, EnumValidation validation);
    public static string AsString(Type enumType, object value);
    public static string AsString(Type enumType, object value, string format);
    public static string AsString(Type enumType, object value, EnumFormat format);
    public static string AsString(Type enumType, object value, EnumFormat format0, EnumFormat format1);
    public static string AsString(Type enumType, object value, EnumFormat format0, EnumFormat format1, EnumFormat format2);
    public static string AsString(Type enumType, object value, EnumFormat[] formats);
    public static bool TryFormat(Type enumType, object value, Span`1<char> destination, Int32& charsWritten);
    [NullableContextAttribute("0")]
public static bool TryFormat(Type enumType, object value, Span`1<char> destination, Int32& charsWritten, ReadOnlySpan`1<char> format);
    public static bool TryFormat(Type enumType, object value, Span`1<char> destination, Int32& charsWritten, EnumFormat[] formats);
    public static string Format(Type enumType, object value, string format);
    public static object GetUnderlyingValue(Type enumType, object value);
    [CLSCompliantAttribute("False")]
public static sbyte ToSByte(Type enumType, object value);
    public static byte ToByte(Type enumType, object value);
    public static short ToInt16(Type enumType, object value);
    [CLSCompliantAttribute("False")]
public static ushort ToUInt16(Type enumType, object value);
    public static int ToInt32(Type enumType, object value);
    [CLSCompliantAttribute("False")]
public static UInt32 ToUInt32(Type enumType, object value);
    public static long ToInt64(Type enumType, object value);
    [CLSCompliantAttribute("False")]
public static ulong ToUInt64(Type enumType, object value);
    public static bool Equals(Type enumType, object value, object other);
    public static int CompareTo(Type enumType, object value, object other);
    public static string GetName(Type enumType, object value);
    public static AttributeCollection GetAttributes(Type enumType, object value);
    public static EnumMember GetMember(Type enumType, object value);
    public static EnumMember GetMember(Type enumType, string name);
    public static EnumMember GetMember(Type enumType, string name, bool ignoreCase);
    public static EnumMember GetMember(Type enumType, string value, bool ignoreCase, EnumFormat format);
    public static EnumMember GetMember(Type enumType, string value, bool ignoreCase, EnumFormat format0, EnumFormat format1);
    public static EnumMember GetMember(Type enumType, string value, bool ignoreCase, EnumFormat format0, EnumFormat format1, EnumFormat format2);
    public static EnumMember GetMember(Type enumType, string value, bool ignoreCase, EnumFormat[] formats);
    private static EnumMember GetMember(Type enumType, string value, bool ignoreCase, ValueCollection`1<EnumFormat> formats);
    public static object Parse(Type enumType, string value);
    public static object Parse(Type enumType, string value, bool ignoreCase);
    public static object Parse(Type enumType, string value, bool ignoreCase, EnumFormat format);
    public static object Parse(Type enumType, string value, bool ignoreCase, EnumFormat format0, EnumFormat format1);
    public static object Parse(Type enumType, string value, bool ignoreCase, EnumFormat format0, EnumFormat format1, EnumFormat format2);
    public static object Parse(Type enumType, string value, bool ignoreCase, EnumFormat[] formats);
    private static object Parse(Type enumType, string value, bool ignoreCase, ValueCollection`1<EnumFormat> formats);
    [NullableContextAttribute("2")]
public static bool TryParse(Type enumType, string value, Object& result);
    [NullableContextAttribute("2")]
public static bool TryParse(Type enumType, string value, bool ignoreCase, Object& result);
    [NullableContextAttribute("2")]
public static bool TryParse(Type enumType, string value, bool ignoreCase, Object& result, EnumFormat format);
    [NullableContextAttribute("2")]
public static bool TryParse(Type enumType, string value, bool ignoreCase, Object& result, EnumFormat format0, EnumFormat format1);
    [NullableContextAttribute("2")]
public static bool TryParse(Type enumType, string value, bool ignoreCase, Object& result, EnumFormat format0, EnumFormat format1, EnumFormat format2);
    [NullableContextAttribute("2")]
public static bool TryParse(Type enumType, string value, bool ignoreCase, Object& result, EnumFormat[] formats);
    internal static EnumCache GetEnumCache(Type enumType);
    private static object GetEnumValidatorAttribute(Type enumType);
}
public enum EnumsNET.EnumValidation : Enum {
    public int value__;
    public static EnumValidation None;
    public static EnumValidation Default;
    public static EnumValidation IsDefined;
    public static EnumValidation IsValidFlagCombination;
}
[AttributeUsageAttribute("16")]
public abstract class EnumsNET.EnumValidatorAttribute`1 : Attribute {
    public abstract virtual bool IsValid(TEnum value);
}
internal class EnumsNET.FlagEnumCache`2 : EnumCache`2<TUnderlying, TUnderlyingOperations> {
    public FlagEnumCache`2(Type enumType, IEnumBridge`2<TUnderlying, TUnderlyingOperations> enumBridge, EnumMemberInternal`2[] members, EnumMemberInternal`2[] buckets, TUnderlying allFlags, int distinctCount, bool isContiguous, object customValidator);
    [NullableContextAttribute("1")]
public virtual string AsString(Byte& value);
    [NullableContextAttribute("1")]
public virtual string AsString(object value);
    public string AsString(TUnderlying value);
    public virtual bool TryFormat(Byte& value, Span`1<char> destination, Int32& charsWritten);
    public virtual bool TryFormat(object value, Span`1<char> destination, Int32& charsWritten);
    public bool TryFormat(TUnderlying value, Span`1<char> destination, Int32& charsWritten);
    public virtual bool IsDefined(Byte& value);
    [NullableContextAttribute("1")]
public virtual bool IsDefined(object value);
    public virtual void Parse(string value, bool ignoreCase, ValueCollection`1<EnumFormat> formats, Byte& result);
    [NullableContextAttribute("1")]
public virtual object Parse(string value, bool ignoreCase, ValueCollection`1<EnumFormat> formats);
    [NullableContextAttribute("1")]
public virtual void Parse(string value, bool ignoreCase, Byte& result);
    [NullableContextAttribute("1")]
public virtual object Parse(string value, bool ignoreCase);
    public virtual bool TryParse(string value, bool ignoreCase, Byte& result, ValueCollection`1<EnumFormat> formats);
    [NullableContextAttribute("2")]
public virtual bool TryParse(string value, bool ignoreCase, Object& result, ValueCollection`1<EnumFormat> formats);
    [NullableContextAttribute("2")]
public virtual bool TryParse(string value, bool ignoreCase, Byte& result);
    [NullableContextAttribute("2")]
public virtual bool TryParse(string value, bool ignoreCase, Object& result);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
public static class EnumsNET.FlagEnums : object {
    internal static string DefaultDelimiter;
    internal static string DefaultParsingDelimiter;
    [NullableContextAttribute("0")]
public static bool IsFlagEnum();
    [NullableContextAttribute("0")]
public static TEnum GetAllFlags();
    [NullableContextAttribute("0")]
public static bool IsValidFlagCombination(TEnum value);
    [NullableContextAttribute("0")]
public static string FormatFlags(TEnum value);
    [NullableContextAttribute("0")]
public static string FormatFlags(TEnum value, string delimiter);
    [NullableContextAttribute("0")]
public static string FormatFlags(TEnum value, string delimiter, EnumFormat format);
    [NullableContextAttribute("0")]
public static string FormatFlags(TEnum value, string delimiter, EnumFormat format0, EnumFormat format1);
    [NullableContextAttribute("0")]
public static string FormatFlags(TEnum value, string delimiter, EnumFormat format0, EnumFormat format1, EnumFormat format2);
    [NullableContextAttribute("2")]
public static string FormatFlags(TEnum value, string delimiter, EnumFormat[] formats);
    [NullableContextAttribute("0")]
public static bool TryFormatFlags(TEnum value, Span`1<char> destination, Int32& charsWritten, ReadOnlySpan`1<char> delimiter, EnumFormat[] formats);
    [NullableContextAttribute("0")]
[ExtensionAttribute]
public static IReadOnlyList`1<TEnum> GetFlags(TEnum value);
    [NullableContextAttribute("0")]
public static IReadOnlyList`1<EnumMember`1<TEnum>> GetFlagMembers(TEnum value);
    [NullableContextAttribute("0")]
public static int GetFlagCount();
    [NullableContextAttribute("0")]
[ExtensionAttribute]
public static int GetFlagCount(TEnum value);
    [NullableContextAttribute("0")]
[ExtensionAttribute]
public static int GetFlagCount(TEnum value, TEnum otherFlags);
    [NullableContextAttribute("0")]
[ExtensionAttribute]
public static bool HasAnyFlags(TEnum value);
    [NullableContextAttribute("0")]
[ExtensionAttribute]
public static bool HasAnyFlags(TEnum value, TEnum otherFlags);
    [NullableContextAttribute("0")]
[ExtensionAttribute]
public static bool HasAllFlags(TEnum value);
    [NullableContextAttribute("0")]
[ExtensionAttribute]
public static bool HasAllFlags(TEnum value, TEnum otherFlags);
    [NullableContextAttribute("0")]
public static TEnum ToggleFlags(TEnum value);
    [NullableContextAttribute("0")]
public static TEnum ToggleFlags(TEnum value, TEnum otherFlags);
    [NullableContextAttribute("0")]
[ExtensionAttribute]
public static TEnum CommonFlags(TEnum value, TEnum otherFlags);
    [NullableContextAttribute("0")]
[ExtensionAttribute]
public static TEnum CombineFlags(TEnum value, TEnum otherFlags);
    [NullableContextAttribute("0")]
public static TEnum CombineFlags(TEnum flag0, TEnum flag1, TEnum flag2);
    [NullableContextAttribute("0")]
public static TEnum CombineFlags(TEnum flag0, TEnum flag1, TEnum flag2, TEnum flag3);
    [NullableContextAttribute("0")]
public static TEnum CombineFlags(TEnum flag0, TEnum flag1, TEnum flag2, TEnum flag3, TEnum flag4);
    [NullableContextAttribute("0")]
public static TEnum CombineFlags(TEnum[] flags);
    [NullableContextAttribute("0")]
public static TEnum CombineFlags(IEnumerable`1<TEnum> flags);
    [NullableContextAttribute("0")]
[ExtensionAttribute]
public static TEnum RemoveFlags(TEnum value, TEnum otherFlags);
    [NullableContextAttribute("0")]
public static TEnum ParseFlags(string value);
    [NullableContextAttribute("0")]
public static TEnum ParseFlags(string value, bool ignoreCase);
    [NullableContextAttribute("0")]
public static TEnum ParseFlags(string value, bool ignoreCase, string delimiter);
    [NullableContextAttribute("0")]
public static TEnum ParseFlags(string value, bool ignoreCase, string delimiter, EnumFormat format);
    [NullableContextAttribute("0")]
public static TEnum ParseFlags(string value, bool ignoreCase, string delimiter, EnumFormat format0, EnumFormat format1);
    [NullableContextAttribute("0")]
public static TEnum ParseFlags(string value, bool ignoreCase, string delimiter, EnumFormat format0, EnumFormat format1, EnumFormat format2);
    [NullableContextAttribute("0")]
public static TEnum ParseFlags(string value, bool ignoreCase, string delimiter, EnumFormat[] formats);
    [NullableContextAttribute("0")]
private static TEnum ParseFlags(string value, bool ignoreCase, string delimiter, ValueCollection`1<EnumFormat> formats);
    [NullableContextAttribute("0")]
public static bool TryParseFlags(string value, TEnum& result);
    [NullableContextAttribute("0")]
public static bool TryParseFlags(string value, bool ignoreCase, TEnum& result);
    [NullableContextAttribute("0")]
public static bool TryParseFlags(string value, bool ignoreCase, string delimiter, TEnum& result);
    [NullableContextAttribute("0")]
public static bool TryParseFlags(string value, bool ignoreCase, string delimiter, TEnum& result, EnumFormat format);
    [NullableContextAttribute("0")]
public static bool TryParseFlags(string value, bool ignoreCase, string delimiter, TEnum& result, EnumFormat format0, EnumFormat format1);
    [NullableContextAttribute("0")]
public static bool TryParseFlags(string value, bool ignoreCase, string delimiter, TEnum& result, EnumFormat format0, EnumFormat format1, EnumFormat format2);
    [NullableContextAttribute("2")]
public static bool TryParseFlags(string value, bool ignoreCase, string delimiter, TEnum& result, EnumFormat[] formats);
    [NullableContextAttribute("0")]
private static bool TryParseFlags(string value, bool ignoreCase, string delimiter, TEnum& result, ValueCollection`1<EnumFormat> formats);
    [NullableContextAttribute("2")]
public static bool IsFlagEnumUnsafe();
    public static TEnum GetAllFlagsUnsafe();
    public static bool IsValidFlagCombinationUnsafe(TEnum value);
    public static string FormatFlagsUnsafe(TEnum value);
    public static string FormatFlagsUnsafe(TEnum value, string delimiter);
    [NullableContextAttribute("2")]
public static string FormatFlagsUnsafe(TEnum value, string delimiter, EnumFormat format);
    [NullableContextAttribute("2")]
public static string FormatFlagsUnsafe(TEnum value, string delimiter, EnumFormat format0, EnumFormat format1);
    [NullableContextAttribute("2")]
public static string FormatFlagsUnsafe(TEnum value, string delimiter, EnumFormat format0, EnumFormat format1, EnumFormat format2);
    [NullableContextAttribute("2")]
public static string FormatFlagsUnsafe(TEnum value, string delimiter, EnumFormat[] formats);
    [NullableContextAttribute("0")]
public static bool TryFormatFlagsUnsafe(TEnum value, Span`1<char> destination, Int32& charsWritten, ReadOnlySpan`1<char> delimiter, EnumFormat[] formats);
    public static IReadOnlyList`1<TEnum> GetFlagsUnsafe(TEnum value);
    public static IReadOnlyList`1<EnumMember`1<TEnum>> GetFlagMembersUnsafe(TEnum value);
    [NullableContextAttribute("2")]
public static int GetFlagCountUnsafe();
    public static int GetFlagCountUnsafe(TEnum value);
    public static int GetFlagCountUnsafe(TEnum value, TEnum otherFlags);
    public static bool HasAnyFlagsUnsafe(TEnum value);
    public static bool HasAnyFlagsUnsafe(TEnum value, TEnum otherFlags);
    public static bool HasAllFlagsUnsafe(TEnum value);
    public static bool HasAllFlagsUnsafe(TEnum value, TEnum otherFlags);
    public static TEnum ToggleFlagsUnsafe(TEnum value);
    public static TEnum ToggleFlagsUnsafe(TEnum value, TEnum otherFlags);
    public static TEnum CommonFlagsUnsafe(TEnum value, TEnum otherFlags);
    public static TEnum CombineFlagsUnsafe(TEnum value, TEnum otherFlags);
    public static TEnum CombineFlagsUnsafe(TEnum flag0, TEnum flag1, TEnum flag2);
    public static TEnum CombineFlagsUnsafe(TEnum flag0, TEnum flag1, TEnum flag2, TEnum flag3);
    public static TEnum CombineFlagsUnsafe(TEnum flag0, TEnum flag1, TEnum flag2, TEnum flag3, TEnum flag4);
    public static TEnum CombineFlagsUnsafe(TEnum[] flags);
    public static TEnum CombineFlagsUnsafe(IEnumerable`1<TEnum> flags);
    public static TEnum RemoveFlagsUnsafe(TEnum value, TEnum otherFlags);
    public static TEnum ParseFlagsUnsafe(string value);
    public static TEnum ParseFlagsUnsafe(string value, bool ignoreCase);
    public static TEnum ParseFlagsUnsafe(string value, bool ignoreCase, string delimiter);
    public static TEnum ParseFlagsUnsafe(string value, bool ignoreCase, string delimiter, EnumFormat format);
    public static TEnum ParseFlagsUnsafe(string value, bool ignoreCase, string delimiter, EnumFormat format0, EnumFormat format1);
    public static TEnum ParseFlagsUnsafe(string value, bool ignoreCase, string delimiter, EnumFormat format0, EnumFormat format1, EnumFormat format2);
    [NullableContextAttribute("2")]
public static TEnum ParseFlagsUnsafe(string value, bool ignoreCase, string delimiter, EnumFormat[] formats);
    private static TEnum ParseFlagsUnsafe(string value, bool ignoreCase, string delimiter, ValueCollection`1<EnumFormat> formats);
    [NullableContextAttribute("2")]
public static bool TryParseFlagsUnsafe(string value, TEnum& result);
    [NullableContextAttribute("2")]
public static bool TryParseFlagsUnsafe(string value, bool ignoreCase, TEnum& result);
    [NullableContextAttribute("2")]
public static bool TryParseFlagsUnsafe(string value, bool ignoreCase, string delimiter, TEnum& result);
    [NullableContextAttribute("2")]
public static bool TryParseFlagsUnsafe(string value, bool ignoreCase, string delimiter, TEnum& result, EnumFormat format);
    [NullableContextAttribute("2")]
public static bool TryParseFlagsUnsafe(string value, bool ignoreCase, string delimiter, TEnum& result, EnumFormat format0, EnumFormat format1);
    [NullableContextAttribute("2")]
public static bool TryParseFlagsUnsafe(string value, bool ignoreCase, string delimiter, TEnum& result, EnumFormat format0, EnumFormat format1, EnumFormat format2);
    [NullableContextAttribute("2")]
public static bool TryParseFlagsUnsafe(string value, bool ignoreCase, string delimiter, TEnum& result, EnumFormat[] formats);
    [NullableContextAttribute("2")]
private static bool TryParseFlagsUnsafe(string value, bool ignoreCase, string delimiter, TEnum& result, ValueCollection`1<EnumFormat> formats);
    public static bool IsFlagEnum(Type enumType);
    public static object GetAllFlags(Type enumType);
    public static bool IsValidFlagCombination(Type enumType, object value);
    public static string FormatFlags(Type enumType, object value);
    public static string FormatFlags(Type enumType, object value, string delimiter);
    public static string FormatFlags(Type enumType, object value, string delimiter, EnumFormat format);
    public static string FormatFlags(Type enumType, object value, string delimiter, EnumFormat format0, EnumFormat format1);
    public static string FormatFlags(Type enumType, object value, string delimiter, EnumFormat format0, EnumFormat format1, EnumFormat format2);
    [NullableContextAttribute("2")]
public static string FormatFlags(Type enumType, object value, string delimiter, EnumFormat[] formats);
    [NullableContextAttribute("0")]
public static bool TryFormatFlags(Type enumType, object value, Span`1<char> destination, Int32& charsWritten, ReadOnlySpan`1<char> delimiter, EnumFormat[] formats);
    public static IReadOnlyList`1<object> GetFlags(Type enumType, object value);
    public static IReadOnlyList`1<EnumMember> GetFlagMembers(Type enumType, object value);
    public static int GetFlagCount(Type enumType);
    public static int GetFlagCount(Type enumType, object value);
    public static int GetFlagCount(Type enumType, object value, object otherFlags);
    public static bool HasAnyFlags(Type enumType, object value);
    public static bool HasAnyFlags(Type enumType, object value, object otherFlags);
    public static bool HasAllFlags(Type enumType, object value);
    public static bool HasAllFlags(Type enumType, object value, object otherFlags);
    public static object ToggleFlags(Type enumType, object value);
    public static object ToggleFlags(Type enumType, object value, object otherFlags);
    public static object CommonFlags(Type enumType, object value, object otherFlags);
    public static object CombineFlags(Type enumType, object value, object otherFlags);
    public static object CombineFlags(Type enumType, Object[] flags);
    public static object CombineFlags(Type enumType, IEnumerable`1<object> flags);
    public static object RemoveFlags(Type enumType, object value, object otherFlags);
    public static object ParseFlags(Type enumType, string value);
    public static object ParseFlags(Type enumType, string value, bool ignoreCase);
    public static object ParseFlags(Type enumType, string value, bool ignoreCase, string delimiter);
    public static object ParseFlags(Type enumType, string value, bool ignoreCase, string delimiter, EnumFormat format);
    public static object ParseFlags(Type enumType, string value, bool ignoreCase, string delimiter, EnumFormat format0, EnumFormat format1);
    public static object ParseFlags(Type enumType, string value, bool ignoreCase, string delimiter, EnumFormat format0, EnumFormat format1, EnumFormat format2);
    public static object ParseFlags(Type enumType, string value, bool ignoreCase, string delimiter, EnumFormat[] formats);
    private static object ParseFlags(Type enumType, string value, bool ignoreCase, string delimiter, ValueCollection`1<EnumFormat> formats);
    public static bool TryParseFlags(Type enumType, string value, Object& result);
    public static bool TryParseFlags(Type enumType, string value, bool ignoreCase, Object& result);
    public static bool TryParseFlags(Type enumType, string value, bool ignoreCase, string delimiter, Object& result);
    public static bool TryParseFlags(Type enumType, string value, bool ignoreCase, string delimiter, Object& result, EnumFormat format);
    public static bool TryParseFlags(Type enumType, string value, bool ignoreCase, string delimiter, Object& result, EnumFormat format0, EnumFormat format1);
    public static bool TryParseFlags(Type enumType, string value, bool ignoreCase, string delimiter, Object& result, EnumFormat format0, EnumFormat format1, EnumFormat format2);
    [NullableContextAttribute("2")]
public static bool TryParseFlags(Type enumType, string value, bool ignoreCase, string delimiter, Object& result, EnumFormat[] formats);
    [ExtensionAttribute]
public static bool IsValidFlagCombination(EnumMember member);
    [ExtensionAttribute]
public static IReadOnlyList`1<TEnum> GetFlags(EnumMember`1<TEnum> member);
    [ExtensionAttribute]
public static IReadOnlyList`1<EnumMember`1<TEnum>> GetFlagMembers(EnumMember`1<TEnum> member);
    [ExtensionAttribute]
public static bool HasAnyFlags(EnumMember member);
    [ExtensionAttribute]
public static bool HasAllFlags(EnumMember member);
    [ExtensionAttribute]
public static int GetFlagCount(EnumMember member);
    [ExtensionAttribute]
public static IReadOnlyList`1<object> GetFlags(EnumMember member);
    [ExtensionAttribute]
public static IReadOnlyList`1<EnumMember> GetFlagMembers(EnumMember member);
}
[NullableContextAttribute("1")]
internal interface EnumsNET.IEnumBridge {
    public abstract virtual EnumComparer CreateEnumComparer(EnumCache enumCache);
    public abstract virtual EnumMember CreateEnumMember(EnumMemberInternal member);
    public abstract virtual IReadOnlyList`1<EnumMember> CreateMembersContainer(IEnumerable`1<EnumMemberInternal> members, int count, bool cached);
}
internal interface EnumsNET.IEnumBridge`2 {
    public abstract virtual bool CustomValidate(object customValidator, TUnderlying value);
    public abstract virtual Nullable`1<TUnderlying> IsEnum(object value);
    public abstract virtual object ToObjectUnchecked(TUnderlying value);
    [NullableContextAttribute("1")]
public abstract virtual IValuesContainer CreateValuesContainer(IEnumerable`1<EnumMemberInternal`2<TUnderlying, TUnderlyingOperations>> members, int count, bool cached);
}
public interface EnumsNET.IEnumValidatorAttribute`1 {
    public abstract virtual bool IsValid(TEnum value);
}
[NullableContextAttribute("1")]
internal interface EnumsNET.IValuesContainer {
    public abstract virtual IReadOnlyList`1<object> GetNonGenericContainer();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[DefaultMemberAttribute("Item")]
internal class EnumsNET.MembersContainer`1 : object {
    private IEnumerable`1<EnumMemberInternal> _members;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private EnumMember`1[] _membersArray;
    [CompilerGeneratedAttribute]
private int <Count>k__BackingField;
    public int Count { get; }
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public EnumMember`1<TEnum> Item { get; }
    public MembersContainer`1(IEnumerable`1<EnumMemberInternal> members, int count, bool cached);
    [CompilerGeneratedAttribute]
public sealed virtual int get_Count();
    public sealed virtual EnumMember`1<TEnum> get_Item(int index);
    public sealed virtual IEnumerator`1<EnumMember`1<TEnum>> GetEnumerator();
    [IteratorStateMachineAttribute("EnumsNET.MembersContainer`1/<Enumerate>d__9")]
private IEnumerator`1<EnumMember`1<TEnum>> Enumerate();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[DefaultMemberAttribute("Item")]
internal class EnumsNET.NamesContainer : object {
    private IEnumerable`1<EnumMemberInternal> _members;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private String[] _namesArray;
    [CompilerGeneratedAttribute]
private int <Count>k__BackingField;
    public int Count { get; }
    public string Item { get; }
    public NamesContainer(IEnumerable`1<EnumMemberInternal> members, int count, bool cached);
    [CompilerGeneratedAttribute]
public sealed virtual int get_Count();
    public sealed virtual string get_Item(int index);
    public sealed virtual IEnumerator`1<string> GetEnumerator();
    [IteratorStateMachineAttribute("EnumsNET.NamesContainer/<Enumerate>d__9")]
private IEnumerator`1<string> Enumerate();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
}
internal class EnumsNET.NonContiguousStandardEnumCache`2 : StandardEnumCache`2<TUnderlying, TUnderlyingOperations> {
    public NonContiguousStandardEnumCache`2(Type enumType, IEnumBridge`2<TUnderlying, TUnderlyingOperations> enumBridge, EnumMemberInternal`2[] members, EnumMemberInternal`2[] buckets, TUnderlying allFlags, int distinctCount, object customValidator);
    [NullableContextAttribute("1")]
public sealed virtual string AsString(Byte& value);
    [NullableContextAttribute("1")]
public sealed virtual string AsString(object value);
    public string AsString(TUnderlying value);
    public virtual bool TryFormat(Byte& value, Span`1<char> destination, Int32& charsWritten);
    public virtual bool TryFormat(object value, Span`1<char> destination, Int32& charsWritten);
    public bool TryFormat(TUnderlying value, Span`1<char> destination, Int32& charsWritten);
    public virtual bool IsDefined(Byte& value);
    [NullableContextAttribute("1")]
public virtual bool IsDefined(object value);
    public bool IsDefined(TUnderlying value);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[DefaultMemberAttribute("Item")]
internal class EnumsNET.NonGenericValuesContainer`3 : object {
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private ValuesContainer`3<TEnum, TUnderlying, TUnderlyingOperations> _container;
    public object Item { get; }
    public int Count { get; }
    public NonGenericValuesContainer`3(ValuesContainer`3<TEnum, TUnderlying, TUnderlyingOperations> container);
    public sealed virtual object get_Item(int index);
    public sealed virtual int get_Count();
    [IteratorStateMachineAttribute("EnumsNET.NonGenericValuesContainer`3/<GetEnumerator>d__6")]
public sealed virtual IEnumerator`1<object> GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
}
internal interface EnumsNET.Numerics.IUnderlyingOperations`1 {
    public T One { get; }
    public abstract virtual T get_One();
    public abstract virtual bool LessThan(T left, T right);
    public abstract virtual T And(T left, T right);
    public abstract virtual T Or(T left, T right);
    public abstract virtual T Xor(T left, T right);
    public abstract virtual T Not(T value);
    public abstract virtual T LeftShift(T value, int amount);
    public abstract virtual T Subtract(T left, T right);
    public abstract virtual T Create(long value);
    public abstract virtual bool IsInValueRange(long value);
    public abstract virtual bool IsInValueRange(ulong value);
    [NullableContextAttribute("1")]
public abstract virtual bool TryParseNumber(string s, NumberStyles style, IFormatProvider provider, T& result);
    public abstract virtual bool TryParseNative(string s, T& result);
    public abstract virtual string ToHexadecimalString(T value);
    public abstract virtual string ToDecimalString(T value);
    public abstract virtual bool TryFormat(T value, Span`1<char> destination, Int32& charsWritten);
    public abstract virtual bool TryToHexadecimalString(T value, Span`1<char> destination, Int32& charsWritten);
    public abstract virtual bool TryToDecimalString(T value, Span`1<char> destination, Int32& charsWritten);
    public abstract virtual int BitCount(T value);
    public abstract virtual bool InRange(T value, T minValue, T maxValue);
}
internal static class EnumsNET.Numerics.Number : object {
    public static int BitCount(int v);
    public static int BitCount(long v);
}
internal class EnumsNET.Numerics.UnderlyingOperations : ValueType {
    private byte EnumsNET.Numerics.IUnderlyingOperations<System.Byte>.One { get; }
    private char EnumsNET.Numerics.IUnderlyingOperations<System.Char>.One { get; }
    private short EnumsNET.Numerics.IUnderlyingOperations<System.Int16>.One { get; }
    private int EnumsNET.Numerics.IUnderlyingOperations<System.Int32>.One { get; }
    private long EnumsNET.Numerics.IUnderlyingOperations<System.Int64>.One { get; }
    private sbyte EnumsNET.Numerics.IUnderlyingOperations<System.SByte>.One { get; }
    private ushort EnumsNET.Numerics.IUnderlyingOperations<System.UInt16>.One { get; }
    private UInt32 EnumsNET.Numerics.IUnderlyingOperations<System.UInt32>.One { get; }
    private ulong EnumsNET.Numerics.IUnderlyingOperations<System.UInt64>.One { get; }
    [IsReadOnlyAttribute]
private sealed virtual override byte EnumsNET.Numerics.IUnderlyingOperations<System.Byte>.get_One();
    [IsReadOnlyAttribute]
private sealed virtual override char EnumsNET.Numerics.IUnderlyingOperations<System.Char>.get_One();
    [IsReadOnlyAttribute]
private sealed virtual override short EnumsNET.Numerics.IUnderlyingOperations<System.Int16>.get_One();
    [IsReadOnlyAttribute]
private sealed virtual override int EnumsNET.Numerics.IUnderlyingOperations<System.Int32>.get_One();
    [IsReadOnlyAttribute]
private sealed virtual override long EnumsNET.Numerics.IUnderlyingOperations<System.Int64>.get_One();
    [IsReadOnlyAttribute]
private sealed virtual override sbyte EnumsNET.Numerics.IUnderlyingOperations<System.SByte>.get_One();
    [IsReadOnlyAttribute]
private sealed virtual override ushort EnumsNET.Numerics.IUnderlyingOperations<System.UInt16>.get_One();
    [IsReadOnlyAttribute]
private sealed virtual override UInt32 EnumsNET.Numerics.IUnderlyingOperations<System.UInt32>.get_One();
    [IsReadOnlyAttribute]
private sealed virtual override ulong EnumsNET.Numerics.IUnderlyingOperations<System.UInt64>.get_One();
    [IsReadOnlyAttribute]
public sealed virtual byte And(byte left, byte right);
    [IsReadOnlyAttribute]
public sealed virtual char And(char left, char right);
    [IsReadOnlyAttribute]
public sealed virtual short And(short left, short right);
    [IsReadOnlyAttribute]
public sealed virtual int And(int left, int right);
    [IsReadOnlyAttribute]
public sealed virtual long And(long left, long right);
    [IsReadOnlyAttribute]
public sealed virtual sbyte And(sbyte left, sbyte right);
    [IsReadOnlyAttribute]
public sealed virtual ushort And(ushort left, ushort right);
    [IsReadOnlyAttribute]
public sealed virtual UInt32 And(UInt32 left, UInt32 right);
    [IsReadOnlyAttribute]
public sealed virtual ulong And(ulong left, ulong right);
    [IsReadOnlyAttribute]
public sealed virtual byte Xor(byte left, byte right);
    [IsReadOnlyAttribute]
public sealed virtual char Xor(char left, char right);
    [IsReadOnlyAttribute]
public sealed virtual short Xor(short left, short right);
    [IsReadOnlyAttribute]
public sealed virtual int Xor(int left, int right);
    [IsReadOnlyAttribute]
public sealed virtual long Xor(long left, long right);
    [IsReadOnlyAttribute]
public sealed virtual sbyte Xor(sbyte left, sbyte right);
    [IsReadOnlyAttribute]
public sealed virtual ushort Xor(ushort left, ushort right);
    [IsReadOnlyAttribute]
public sealed virtual UInt32 Xor(UInt32 left, UInt32 right);
    [IsReadOnlyAttribute]
public sealed virtual ulong Xor(ulong left, ulong right);
    [IsReadOnlyAttribute]
public sealed virtual byte LeftShift(byte value, int amount);
    [IsReadOnlyAttribute]
public sealed virtual char LeftShift(char value, int amount);
    [IsReadOnlyAttribute]
public sealed virtual short LeftShift(short value, int amount);
    [IsReadOnlyAttribute]
public sealed virtual int LeftShift(int value, int amount);
    [IsReadOnlyAttribute]
public sealed virtual long LeftShift(long value, int amount);
    [IsReadOnlyAttribute]
public sealed virtual sbyte LeftShift(sbyte value, int amount);
    [IsReadOnlyAttribute]
public sealed virtual ushort LeftShift(ushort value, int amount);
    [IsReadOnlyAttribute]
public sealed virtual UInt32 LeftShift(UInt32 value, int amount);
    [IsReadOnlyAttribute]
public sealed virtual ulong LeftShift(ulong value, int amount);
    [IsReadOnlyAttribute]
public sealed virtual bool LessThan(byte left, byte right);
    [IsReadOnlyAttribute]
public sealed virtual bool LessThan(char left, char right);
    [IsReadOnlyAttribute]
public sealed virtual bool LessThan(short left, short right);
    [IsReadOnlyAttribute]
public sealed virtual bool LessThan(int left, int right);
    [IsReadOnlyAttribute]
public sealed virtual bool LessThan(long left, long right);
    [IsReadOnlyAttribute]
public sealed virtual bool LessThan(sbyte left, sbyte right);
    [IsReadOnlyAttribute]
public sealed virtual bool LessThan(ushort left, ushort right);
    [IsReadOnlyAttribute]
public sealed virtual bool LessThan(UInt32 left, UInt32 right);
    [IsReadOnlyAttribute]
public sealed virtual bool LessThan(ulong left, ulong right);
    [IsReadOnlyAttribute]
public sealed virtual byte Not(byte value);
    [IsReadOnlyAttribute]
public sealed virtual char Not(char value);
    [IsReadOnlyAttribute]
public sealed virtual short Not(short value);
    [IsReadOnlyAttribute]
public sealed virtual int Not(int value);
    [IsReadOnlyAttribute]
public sealed virtual long Not(long value);
    [IsReadOnlyAttribute]
public sealed virtual sbyte Not(sbyte value);
    [IsReadOnlyAttribute]
public sealed virtual ushort Not(ushort value);
    [IsReadOnlyAttribute]
public sealed virtual UInt32 Not(UInt32 value);
    [IsReadOnlyAttribute]
public sealed virtual ulong Not(ulong value);
    [IsReadOnlyAttribute]
public sealed virtual byte Or(byte left, byte right);
    [IsReadOnlyAttribute]
public sealed virtual char Or(char left, char right);
    [IsReadOnlyAttribute]
public sealed virtual short Or(short left, short right);
    [IsReadOnlyAttribute]
public sealed virtual int Or(int left, int right);
    [IsReadOnlyAttribute]
public sealed virtual long Or(long left, long right);
    [IsReadOnlyAttribute]
public sealed virtual sbyte Or(sbyte left, sbyte right);
    [IsReadOnlyAttribute]
public sealed virtual ushort Or(ushort left, ushort right);
    [IsReadOnlyAttribute]
public sealed virtual UInt32 Or(UInt32 left, UInt32 right);
    [IsReadOnlyAttribute]
public sealed virtual ulong Or(ulong left, ulong right);
    [IsReadOnlyAttribute]
public sealed virtual byte Subtract(byte left, byte right);
    [IsReadOnlyAttribute]
public sealed virtual char Subtract(char left, char right);
    [IsReadOnlyAttribute]
public sealed virtual short Subtract(short left, short right);
    [IsReadOnlyAttribute]
public sealed virtual int Subtract(int left, int right);
    [IsReadOnlyAttribute]
public sealed virtual long Subtract(long left, long right);
    [IsReadOnlyAttribute]
public sealed virtual sbyte Subtract(sbyte left, sbyte right);
    [IsReadOnlyAttribute]
public sealed virtual ushort Subtract(ushort left, ushort right);
    [IsReadOnlyAttribute]
public sealed virtual UInt32 Subtract(UInt32 left, UInt32 right);
    [IsReadOnlyAttribute]
public sealed virtual ulong Subtract(ulong left, ulong right);
    [IsReadOnlyAttribute]
public sealed virtual int BitCount(byte value);
    [IsReadOnlyAttribute]
public sealed virtual int BitCount(char value);
    [IsReadOnlyAttribute]
public sealed virtual int BitCount(short value);
    [IsReadOnlyAttribute]
public sealed virtual int BitCount(int value);
    [IsReadOnlyAttribute]
public sealed virtual int BitCount(long value);
    [IsReadOnlyAttribute]
public sealed virtual int BitCount(sbyte value);
    [IsReadOnlyAttribute]
public sealed virtual int BitCount(ushort value);
    [IsReadOnlyAttribute]
public sealed virtual int BitCount(UInt32 value);
    [IsReadOnlyAttribute]
public sealed virtual int BitCount(ulong value);
    [IsReadOnlyAttribute]
private sealed virtual override byte EnumsNET.Numerics.IUnderlyingOperations<System.Byte>.Create(long value);
    [IsReadOnlyAttribute]
private sealed virtual override char EnumsNET.Numerics.IUnderlyingOperations<System.Char>.Create(long value);
    [IsReadOnlyAttribute]
private sealed virtual override short EnumsNET.Numerics.IUnderlyingOperations<System.Int16>.Create(long value);
    [IsReadOnlyAttribute]
private sealed virtual override int EnumsNET.Numerics.IUnderlyingOperations<System.Int32>.Create(long value);
    [IsReadOnlyAttribute]
private sealed virtual override long EnumsNET.Numerics.IUnderlyingOperations<System.Int64>.Create(long value);
    [IsReadOnlyAttribute]
private sealed virtual override sbyte EnumsNET.Numerics.IUnderlyingOperations<System.SByte>.Create(long value);
    [IsReadOnlyAttribute]
private sealed virtual override ushort EnumsNET.Numerics.IUnderlyingOperations<System.UInt16>.Create(long value);
    [IsReadOnlyAttribute]
private sealed virtual override UInt32 EnumsNET.Numerics.IUnderlyingOperations<System.UInt32>.Create(long value);
    [IsReadOnlyAttribute]
private sealed virtual override ulong EnumsNET.Numerics.IUnderlyingOperations<System.UInt64>.Create(long value);
    [IsReadOnlyAttribute]
public sealed virtual bool InRange(byte value, byte minValue, byte maxValue);
    [IsReadOnlyAttribute]
public sealed virtual bool InRange(char value, char minValue, char maxValue);
    [IsReadOnlyAttribute]
public sealed virtual bool InRange(short value, short minValue, short maxValue);
    [IsReadOnlyAttribute]
public sealed virtual bool InRange(int value, int minValue, int maxValue);
    [IsReadOnlyAttribute]
public sealed virtual bool InRange(long value, long minValue, long maxValue);
    [IsReadOnlyAttribute]
public sealed virtual bool InRange(sbyte value, sbyte minValue, sbyte maxValue);
    [IsReadOnlyAttribute]
public sealed virtual bool InRange(ushort value, ushort minValue, ushort maxValue);
    [IsReadOnlyAttribute]
public sealed virtual bool InRange(UInt32 value, UInt32 minValue, UInt32 maxValue);
    [IsReadOnlyAttribute]
public sealed virtual bool InRange(ulong value, ulong minValue, ulong maxValue);
    [IsReadOnlyAttribute]
private sealed virtual override bool EnumsNET.Numerics.IUnderlyingOperations<System.Byte>.IsInValueRange(ulong value);
    [IsReadOnlyAttribute]
private sealed virtual override bool EnumsNET.Numerics.IUnderlyingOperations<System.Char>.IsInValueRange(ulong value);
    [IsReadOnlyAttribute]
private sealed virtual override bool EnumsNET.Numerics.IUnderlyingOperations<System.Int16>.IsInValueRange(ulong value);
    [IsReadOnlyAttribute]
private sealed virtual override bool EnumsNET.Numerics.IUnderlyingOperations<System.Int32>.IsInValueRange(ulong value);
    [IsReadOnlyAttribute]
private sealed virtual override bool EnumsNET.Numerics.IUnderlyingOperations<System.Int64>.IsInValueRange(ulong value);
    [IsReadOnlyAttribute]
private sealed virtual override bool EnumsNET.Numerics.IUnderlyingOperations<System.SByte>.IsInValueRange(ulong value);
    [IsReadOnlyAttribute]
private sealed virtual override bool EnumsNET.Numerics.IUnderlyingOperations<System.UInt16>.IsInValueRange(ulong value);
    [IsReadOnlyAttribute]
private sealed virtual override bool EnumsNET.Numerics.IUnderlyingOperations<System.UInt32>.IsInValueRange(ulong value);
    [IsReadOnlyAttribute]
private sealed virtual override bool EnumsNET.Numerics.IUnderlyingOperations<System.UInt64>.IsInValueRange(ulong value);
    [IsReadOnlyAttribute]
private sealed virtual override bool EnumsNET.Numerics.IUnderlyingOperations<System.Byte>.IsInValueRange(long value);
    [IsReadOnlyAttribute]
private sealed virtual override bool EnumsNET.Numerics.IUnderlyingOperations<System.Char>.IsInValueRange(long value);
    [IsReadOnlyAttribute]
private sealed virtual override bool EnumsNET.Numerics.IUnderlyingOperations<System.Int16>.IsInValueRange(long value);
    [IsReadOnlyAttribute]
private sealed virtual override bool EnumsNET.Numerics.IUnderlyingOperations<System.Int32>.IsInValueRange(long value);
    [IsReadOnlyAttribute]
private sealed virtual override bool EnumsNET.Numerics.IUnderlyingOperations<System.Int64>.IsInValueRange(long value);
    [IsReadOnlyAttribute]
private sealed virtual override bool EnumsNET.Numerics.IUnderlyingOperations<System.SByte>.IsInValueRange(long value);
    [IsReadOnlyAttribute]
private sealed virtual override bool EnumsNET.Numerics.IUnderlyingOperations<System.UInt16>.IsInValueRange(long value);
    [IsReadOnlyAttribute]
private sealed virtual override bool EnumsNET.Numerics.IUnderlyingOperations<System.UInt32>.IsInValueRange(long value);
    [IsReadOnlyAttribute]
private sealed virtual override bool EnumsNET.Numerics.IUnderlyingOperations<System.UInt64>.IsInValueRange(long value);
    [IsReadOnlyAttribute]
[NullableContextAttribute("1")]
public sealed virtual string ToHexadecimalString(byte value);
    [IsReadOnlyAttribute]
[NullableContextAttribute("1")]
public sealed virtual string ToHexadecimalString(char value);
    [IsReadOnlyAttribute]
[NullableContextAttribute("1")]
public sealed virtual string ToHexadecimalString(short value);
    [IsReadOnlyAttribute]
[NullableContextAttribute("1")]
public sealed virtual string ToHexadecimalString(int value);
    [IsReadOnlyAttribute]
[NullableContextAttribute("1")]
public sealed virtual string ToHexadecimalString(long value);
    [IsReadOnlyAttribute]
[NullableContextAttribute("1")]
public sealed virtual string ToHexadecimalString(sbyte value);
    [IsReadOnlyAttribute]
[NullableContextAttribute("1")]
public sealed virtual string ToHexadecimalString(ushort value);
    [IsReadOnlyAttribute]
[NullableContextAttribute("1")]
public sealed virtual string ToHexadecimalString(UInt32 value);
    [IsReadOnlyAttribute]
[NullableContextAttribute("1")]
public sealed virtual string ToHexadecimalString(ulong value);
    [IsReadOnlyAttribute]
[NullableContextAttribute("1")]
public sealed virtual string ToDecimalString(byte value);
    [IsReadOnlyAttribute]
[NullableContextAttribute("1")]
public sealed virtual string ToDecimalString(char value);
    [IsReadOnlyAttribute]
[NullableContextAttribute("1")]
public sealed virtual string ToDecimalString(short value);
    [IsReadOnlyAttribute]
[NullableContextAttribute("1")]
public sealed virtual string ToDecimalString(int value);
    [IsReadOnlyAttribute]
[NullableContextAttribute("1")]
public sealed virtual string ToDecimalString(long value);
    [IsReadOnlyAttribute]
[NullableContextAttribute("1")]
public sealed virtual string ToDecimalString(sbyte value);
    [IsReadOnlyAttribute]
[NullableContextAttribute("1")]
public sealed virtual string ToDecimalString(ushort value);
    [IsReadOnlyAttribute]
[NullableContextAttribute("1")]
public sealed virtual string ToDecimalString(UInt32 value);
    [IsReadOnlyAttribute]
[NullableContextAttribute("1")]
public sealed virtual string ToDecimalString(ulong value);
    [IsReadOnlyAttribute]
public sealed virtual bool TryFormat(byte value, Span`1<char> destination, Int32& charsWritten);
    [IsReadOnlyAttribute]
public sealed virtual bool TryFormat(char value, Span`1<char> destination, Int32& charsWritten);
    [IsReadOnlyAttribute]
public sealed virtual bool TryFormat(short value, Span`1<char> destination, Int32& charsWritten);
    [IsReadOnlyAttribute]
public sealed virtual bool TryFormat(int value, Span`1<char> destination, Int32& charsWritten);
    [IsReadOnlyAttribute]
public sealed virtual bool TryFormat(long value, Span`1<char> destination, Int32& charsWritten);
    [IsReadOnlyAttribute]
public sealed virtual bool TryFormat(sbyte value, Span`1<char> destination, Int32& charsWritten);
    [IsReadOnlyAttribute]
public sealed virtual bool TryFormat(ushort value, Span`1<char> destination, Int32& charsWritten);
    [IsReadOnlyAttribute]
public sealed virtual bool TryFormat(UInt32 value, Span`1<char> destination, Int32& charsWritten);
    [IsReadOnlyAttribute]
public sealed virtual bool TryFormat(ulong value, Span`1<char> destination, Int32& charsWritten);
    [IsReadOnlyAttribute]
public sealed virtual bool TryToHexadecimalString(byte value, Span`1<char> destination, Int32& charsWritten);
    [IsReadOnlyAttribute]
public sealed virtual bool TryToHexadecimalString(char value, Span`1<char> destination, Int32& charsWritten);
    [IsReadOnlyAttribute]
public sealed virtual bool TryToHexadecimalString(short value, Span`1<char> destination, Int32& charsWritten);
    [IsReadOnlyAttribute]
public sealed virtual bool TryToHexadecimalString(int value, Span`1<char> destination, Int32& charsWritten);
    [IsReadOnlyAttribute]
public sealed virtual bool TryToHexadecimalString(long value, Span`1<char> destination, Int32& charsWritten);
    [IsReadOnlyAttribute]
public sealed virtual bool TryToHexadecimalString(sbyte value, Span`1<char> destination, Int32& charsWritten);
    [IsReadOnlyAttribute]
public sealed virtual bool TryToHexadecimalString(ushort value, Span`1<char> destination, Int32& charsWritten);
    [IsReadOnlyAttribute]
public sealed virtual bool TryToHexadecimalString(UInt32 value, Span`1<char> destination, Int32& charsWritten);
    [IsReadOnlyAttribute]
public sealed virtual bool TryToHexadecimalString(ulong value, Span`1<char> destination, Int32& charsWritten);
    [IsReadOnlyAttribute]
public sealed virtual bool TryToDecimalString(byte value, Span`1<char> destination, Int32& charsWritten);
    [IsReadOnlyAttribute]
public sealed virtual bool TryToDecimalString(char value, Span`1<char> destination, Int32& charsWritten);
    [IsReadOnlyAttribute]
public sealed virtual bool TryToDecimalString(short value, Span`1<char> destination, Int32& charsWritten);
    [IsReadOnlyAttribute]
public sealed virtual bool TryToDecimalString(int value, Span`1<char> destination, Int32& charsWritten);
    [IsReadOnlyAttribute]
public sealed virtual bool TryToDecimalString(long value, Span`1<char> destination, Int32& charsWritten);
    [IsReadOnlyAttribute]
public sealed virtual bool TryToDecimalString(sbyte value, Span`1<char> destination, Int32& charsWritten);
    [IsReadOnlyAttribute]
public sealed virtual bool TryToDecimalString(ushort value, Span`1<char> destination, Int32& charsWritten);
    [IsReadOnlyAttribute]
public sealed virtual bool TryToDecimalString(UInt32 value, Span`1<char> destination, Int32& charsWritten);
    [IsReadOnlyAttribute]
public sealed virtual bool TryToDecimalString(ulong value, Span`1<char> destination, Int32& charsWritten);
    [IsReadOnlyAttribute]
[NullableContextAttribute("1")]
public sealed virtual bool TryParseNumber(string s, NumberStyles style, IFormatProvider provider, Byte& result);
    [IsReadOnlyAttribute]
[NullableContextAttribute("1")]
public sealed virtual bool TryParseNumber(string s, NumberStyles style, IFormatProvider provider, Char& result);
    [IsReadOnlyAttribute]
[NullableContextAttribute("1")]
public sealed virtual bool TryParseNumber(string s, NumberStyles style, IFormatProvider provider, Int16& result);
    [IsReadOnlyAttribute]
[NullableContextAttribute("1")]
public sealed virtual bool TryParseNumber(string s, NumberStyles style, IFormatProvider provider, Int32& result);
    [IsReadOnlyAttribute]
[NullableContextAttribute("1")]
public sealed virtual bool TryParseNumber(string s, NumberStyles style, IFormatProvider provider, Int64& result);
    [IsReadOnlyAttribute]
[NullableContextAttribute("1")]
public sealed virtual bool TryParseNumber(string s, NumberStyles style, IFormatProvider provider, SByte& result);
    [IsReadOnlyAttribute]
[NullableContextAttribute("1")]
public sealed virtual bool TryParseNumber(string s, NumberStyles style, IFormatProvider provider, UInt16& result);
    [IsReadOnlyAttribute]
[NullableContextAttribute("1")]
public sealed virtual bool TryParseNumber(string s, NumberStyles style, IFormatProvider provider, UInt32& result);
    [IsReadOnlyAttribute]
[NullableContextAttribute("1")]
public sealed virtual bool TryParseNumber(string s, NumberStyles style, IFormatProvider provider, UInt64& result);
    [IsReadOnlyAttribute]
[NullableContextAttribute("1")]
public sealed virtual bool TryParseNative(string s, Byte& result);
    [IsReadOnlyAttribute]
[NullableContextAttribute("1")]
public sealed virtual bool TryParseNative(string s, Char& result);
    [IsReadOnlyAttribute]
[NullableContextAttribute("1")]
public sealed virtual bool TryParseNative(string s, Int16& result);
    [IsReadOnlyAttribute]
[NullableContextAttribute("1")]
public sealed virtual bool TryParseNative(string s, Int32& result);
    [IsReadOnlyAttribute]
[NullableContextAttribute("1")]
public sealed virtual bool TryParseNative(string s, Int64& result);
    [IsReadOnlyAttribute]
[NullableContextAttribute("1")]
public sealed virtual bool TryParseNative(string s, SByte& result);
    [IsReadOnlyAttribute]
[NullableContextAttribute("1")]
public sealed virtual bool TryParseNative(string s, UInt16& result);
    [IsReadOnlyAttribute]
[NullableContextAttribute("1")]
public sealed virtual bool TryParseNative(string s, UInt32& result);
    [IsReadOnlyAttribute]
[NullableContextAttribute("1")]
public sealed virtual bool TryParseNative(string s, UInt64& result);
}
internal static class EnumsNET.Preconditions : object {
    [NullableContextAttribute("1")]
public static void NotNull(object value, string paramName);
}
[AttributeUsageAttribute("256")]
public class EnumsNET.PrimaryEnumMemberAttribute : Attribute {
}
internal abstract class EnumsNET.StandardEnumCache`2 : EnumCache`2<TUnderlying, TUnderlyingOperations> {
    protected StandardEnumCache`2(Type enumType, IEnumBridge`2<TUnderlying, TUnderlyingOperations> enumBridge, EnumMemberInternal`2[] members, EnumMemberInternal`2[] buckets, TUnderlying allFlags, int distinctCount, bool isContiguous, object customValidator);
    public sealed virtual void Parse(string value, bool ignoreCase, ValueCollection`1<EnumFormat> formats, Byte& result);
    [NullableContextAttribute("1")]
public sealed virtual object Parse(string value, bool ignoreCase, ValueCollection`1<EnumFormat> formats);
    public TUnderlying ParseInternal(string value, bool ignoreCase, ValueCollection`1<EnumFormat> formats);
    [NullableContextAttribute("1")]
public sealed virtual void Parse(string value, bool ignoreCase, Byte& result);
    [NullableContextAttribute("1")]
public sealed virtual object Parse(string value, bool ignoreCase);
    public TUnderlying ParseInternal(string value, bool ignoreCase);
    public sealed virtual bool TryParse(string value, bool ignoreCase, Byte& result, ValueCollection`1<EnumFormat> formats);
    [NullableContextAttribute("2")]
public sealed virtual bool TryParse(string value, bool ignoreCase, Object& result, ValueCollection`1<EnumFormat> formats);
    [NullableContextAttribute("2")]
public sealed virtual bool TryParse(string value, bool ignoreCase, Byte& result);
    [NullableContextAttribute("2")]
public sealed virtual bool TryParse(string value, bool ignoreCase, Object& result);
}
internal static class EnumsNET.Utilities.ArrayHelper : object {
    [NullableContextAttribute("1")]
public static T[] ToArray(IEnumerable`1<T> items, int count);
}
internal static class EnumsNET.Utilities.HashHelpers : object {
    public static int PowerOf2(int v);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal static class EnumsNET.ValueCollection : object {
    public static ValueCollection`1<T> Create(T item1);
    public static ValueCollection`1<T> Create(T item1, T item2);
    public static ValueCollection`1<T> Create(T item1, T item2, T item3);
    public static ValueCollection`1<T> Create(T[] items);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class EnumsNET.ValueCollection`1 : ValueType {
    private static T[] s_size1Array;
    private static T[] s_size2Array;
    private static T[] s_size3Array;
    private T _item1;
    private T _item2;
    private T _item3;
    private T[] _items;
    private int _index;
    public int Count { get; }
    public T Current { get; }
    public ValueCollection`1(T item1);
    public ValueCollection`1(T item1, T item2);
    public ValueCollection`1(T item1, T item2, T item3);
    public ValueCollection`1(T[] items);
    private static ValueCollection`1();
    public int get_Count();
    public T get_Current();
    public ValueCollection`1<T> GetEnumerator();
    public bool MoveNext();
}
[DefaultMemberAttribute("Item")]
internal class EnumsNET.ValuesContainer`3 : object {
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private IEnumerable`1<EnumMemberInternal`2<TUnderlying, TUnderlyingOperations>> _members;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private TEnum[] _valuesArray;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private IReadOnlyList`1<object> _nonGenericValuesContainer;
    [CompilerGeneratedAttribute]
private int <Count>k__BackingField;
    public int Count { get; }
    public TEnum Item { get; }
    public ValuesContainer`3(IEnumerable`1<EnumMemberInternal`2<TUnderlying, TUnderlyingOperations>> members, int count, bool cached);
    [CompilerGeneratedAttribute]
public sealed virtual int get_Count();
    public sealed virtual TEnum get_Item(int index);
    public sealed virtual IEnumerator`1<TEnum> GetEnumerator();
    [IteratorStateMachineAttribute("EnumsNET.ValuesContainer`3/<Enumerate>d__10")]
private IEnumerator`1<TEnum> Enumerate();
    [NullableContextAttribute("1")]
public sealed virtual IReadOnlyList`1<object> GetNonGenericContainer();
    [NullableContextAttribute("1")]
private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
}
[CompilerGeneratedAttribute]
[EmbeddedAttribute]
internal class Microsoft.CodeAnalysis.EmbeddedAttribute : Attribute {
}
[CompilerGeneratedAttribute]
[EmbeddedAttribute]
[AttributeUsageAttribute("27524")]
internal class System.Runtime.CompilerServices.NullableAttribute : Attribute {
    public Byte[] NullableFlags;
    public NullableAttribute(byte );
    public NullableAttribute(Byte[] );
}
[CompilerGeneratedAttribute]
[EmbeddedAttribute]
[AttributeUsageAttribute("5196")]
internal class System.Runtime.CompilerServices.NullableContextAttribute : Attribute {
    public byte Flag;
    public NullableContextAttribute(byte );
}
[CompilerGeneratedAttribute]
[EmbeddedAttribute]
[AttributeUsageAttribute("2")]
internal class System.Runtime.CompilerServices.RefSafetyRulesAttribute : Attribute {
    public int Version;
    public RefSafetyRulesAttribute(int );
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
internal static class System.Runtime.CompilerServices.UnsafeUtility : object {
    [SecuritySafeCriticalAttribute]
public static int SizeOf();
    [NullableContextAttribute("1")]
[SecuritySafeCriticalAttribute]
public static TTo& As(TFrom& source);
    [SecuritySafeCriticalAttribute]
public static T As(object value);
}
